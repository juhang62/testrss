<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>字符串匹配—KMP算法 - 温暖如太阳</title>
<link>http://www.cnblogs.com/xtt321/p/14022697.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xtt321/p/14022697.html</guid>
<description>&lt;p&gt;KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。具体实现就是通过一个next()函数实现，函数本身包含了模式串的局部匹配信息。KMP算法的时间复杂度O(m+n) 。&lt;br/&gt;实现方式就不再这里献丑了，网上很多讲解，此处只是记录下c#实现的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; KMP
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[] GetNext(String ps)
    {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] p =&lt;span&gt; ps.ToArray();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;[] next = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;[p.Length];
        next[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; k = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (j &amp;lt; p.Length - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (k == -&lt;span&gt;1&lt;/span&gt; || p[j] ==&lt;span&gt; p[k])
            {
                next[&lt;/span&gt;++j] = ++&lt;span&gt;k;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                k &lt;/span&gt;=&lt;span&gt; next[k];
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; next;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; GetIndex(String ts, String ps)
    {
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] t =&lt;span&gt; ts.ToArray();
        &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;[] p =&lt;span&gt; ps.ToArray();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 主串的位置&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 模式串的位置&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt;[] next =&lt;span&gt; GetNext(ps);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (i &amp;lt; t.Length &amp;amp;&amp;amp; j &amp;lt;&lt;span&gt; p.Length)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (j == -&lt;span&gt;1&lt;/span&gt; || t[i] ==&lt;span&gt; p[j])
            { 
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当j为-1时，要移动的是i，当然j也要归0&lt;/span&gt;
                i++&lt;span&gt;;
                j&lt;/span&gt;++&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; i不需要回溯了
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; i = i - j + 1;&lt;/span&gt;
                j = next[j]; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; j回到指定位置&lt;/span&gt;
&lt;span&gt;            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (j ==&lt;span&gt; p.Length)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; i -&lt;span&gt; j;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        }
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
{
    Console.WriteLine( KMP.GetIndex(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abcdbcxdbc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dbc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    Console.ReadKey();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/404258/202011/404258-20201123084149434-892683565.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 23 Nov 2020 00:45:00 +0000</pubDate>
<dc:creator>温暖如太阳</dc:creator>
<og:description>KMP算法是一种改进的字符串匹配算法，由D.E.Knuth，J.H.Morris和V.R.Pratt提出的，因此人们称它为克努特—莫里斯—普拉特操作（简称KMP算法）。KMP算法的核心是利用匹配失败后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xtt321/p/14022697.html</dc:identifier>
</item>
<item>
<title>Pinpoint 编译环境搭建(Pinpoint系列一) - 自由早晚乱余生</title>
<link>http://www.cnblogs.com/operationhome/p/14016353.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/operationhome/p/14016353.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文基于 Pinpoint 2.1.0 版本&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;新版本的内容参考官方文档， Pinpoint的整个搭建是历经艰辛。&lt;/p&gt;
&lt;h2 id=&quot;一、210-版本特性&quot;&gt;一、2.1.0 版本特性&lt;/h2&gt;
&lt;blockquote readability=&quot;1.1267605633803&quot;&gt;
&lt;p&gt;见官方文档 &lt;a href=&quot;https://pinpoint-apm.github.io/pinpoint/2.1.0/main.html&quot;&gt;https://pinpoint-apm.github.io/pinpoint/2.1.0/main.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;Pinpoint-collector and Pinpoint-web has changed to spring boot. 使用 spring boot 部署了，导致很多时候更改配置只能重新编译打包。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二、编译环境准备&quot;&gt;二、编译环境准备&lt;/h2&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://pinpoint-apm.github.io/pinpoint/2.1.0/installation.html#quick-overview-of-installation&quot;&gt;https://pinpoint-apm.github.io/pinpoint/2.1.0/installation.html#quick-overview-of-installation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;Clone Pinpoint - &lt;code&gt;git clone $PINPOINT_GIT_REPOSITORY&lt;/code&gt; (下载代码)&lt;/li&gt;
&lt;li&gt;Set JAVA_HOME environment variable to JDK 8 home directory.&lt;/li&gt;
&lt;li&gt;Set JAVA_6_HOME environment variable to JDK 6 home directory (1.6.0_45 recommended).&lt;/li&gt;
&lt;li&gt;Set JAVA_7_HOME environment variable to JDK 7 home directory (1.7.0_80 recommended).&lt;/li&gt;
&lt;li&gt;Set JAVA_8_HOME environment variable to JDK 8 home directory.&lt;/li&gt;
&lt;li&gt;Set JAVA_9_HOME environment variable to JDK 9 home directory.&lt;/li&gt;
&lt;li&gt;Run &lt;code&gt;./mvnw clean install -DskipTests=true&lt;/code&gt; (or &lt;code&gt;./mvnw.cmd&lt;/code&gt; for Windows)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这个项目需要 4个 Java 版本的环境，我也是很心累，弄这个环境也花费了比较多的时间，上面的四个 java 版本的 安装包也不好下载(Linux)，可以加我群联系我获取链接(群的信息底部)。&lt;/p&gt;
&lt;p&gt;下载完上面的安装包， 安装完之后，需要注意，需要添加环境变量。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意这一步很重要，一定要添加对应的 &lt;code&gt;CLASSPATH&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;export JAVA_HOME=/usr/java/jdk1.8.0_131/
export PATH=$PATH:$JAVA_HOME/bin
export CLASSPATH=.:$JAVA_HOME/jre/lib:$JAVA_HOME/lib:$JAVA_HOME/lib/tools.jar
 
export JAVA_6_HOME=/usr/java/jdk1.6.0_45/
export PATH=$PATH:$JAVA_6_HOME/bin
export CLASSPATH=.:$JAVA_6_HOME/jre/lib:$JAVA_6_HOME/lib:$JAVA_6_HOME/lib/tools.jar
 
export JAVA_7_HOME=/java/jdk1.7.0_80/
export PATH=$PATH:$JAVA_7_HOME/bin
export CLASSPATH=.:$JAVA_7_HOME/jre/lib:$JAVA_7_HOME/lib:$JAVA_7_HOME/lib/tools.jar
 
export JAVA_8_HOME=/usr/java/jdk1.8.0_131/
export PATH=$PATH:$JAVA_8_HOME/bin
export CLASSPATH=.:$JAVA_8_HOME/jre/lib:$JAVA_8_HOME/lib:$JAVA_8_HOME/lib/tools.jar
 
export JAVA_9_HOME=/java/jdk-9.0.4/
export PATH=$PATH:$JAVA_9_HOME/bin
export CLASSPATH=.:$JAVA_9_HOME/lib:$JAVA_9_HOME/lib/tools.jar
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;maven 这边是不需要安装的，因为它这边使用的是 &lt;code&gt;mvnw&lt;/code&gt;， &lt;code&gt;mvnw&lt;/code&gt; 会自动安装一个 maven 。&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;code&gt;mvnw&lt;/code&gt;是Maven Wrapper的缩写。因为我们安装Maven时，默认情况下，系统所有项目都会使用全局安装的这个Maven版本。但是，对于某些项目来说，它可能必须使用某个特定的Maven版本，这个时候，就可以使用Maven Wrapper，它可以负责给这个特定的项目安装指定版本的Maven，而其他项目不受影响。&lt;/p&gt;
&lt;p&gt;简单地说，Maven Wrapper就是给一个项目提供一个独立的，指定版本的Maven给它使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;三、编译注意事项&quot;&gt;三、编译注意事项&lt;/h2&gt;
&lt;p&gt;上面环境安装完了之后，我建议大家将自己的 maven 配置文件 &lt;code&gt;settings.xml&lt;/code&gt; 上传到编辑机器。上传的原因是因为默认 &lt;code&gt;mvnw&lt;/code&gt; 使用的是默认的源，下载是比较慢的，所以我们建议使用我们添加了阿里云的maven 源的 配置文件，这样下载会更快点。&lt;/p&gt;
&lt;p&gt;接下来就是编译了 -s &lt;code&gt;指定我们的maven 配置文件&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;./mvnw clean  install -DskipTests=true  -s /usr/local/apache-maven/conf/settings.xml
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、编译目录&quot;&gt;四、编译目录&lt;/h2&gt;
&lt;p&gt;编译完之后，我们会使用到的包的目录分别为&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pinpoint # 打包目录
&lt;ul&gt;&lt;li&gt;agent 包 &lt;code&gt;agent/target/pinpoint-agent-2.1.0.tar.gz or agent/target/pinpoint-agent-2.1.0.zip&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;web 包 &lt;code&gt;web/target/deploy/pinpoint-web-boot-2.1.0.jar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;collector 包 &lt;code&gt;collector/target/deploy/pinpoint-collector-boot-2.1.0.jar&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;flink job包 &lt;code&gt;flink/target/pinpoint-flink-job-2.1.0.jar&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五、注意事项&quot;&gt;五、注意事项&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;注意编译web 的时候会用到 node, 这个项目会自动去下载node, 然后进行进行拉取包安装。 我们可以找到对应的 node ，然后将node 源设置为淘宝的源，这样编译会快很多。&lt;/li&gt;
&lt;li&gt;整个编译第一次需要的时间比较长，需要耐心等待&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Mon, 23 Nov 2020 00:41:00 +0000</pubDate>
<dc:creator>自由早晚乱余生</dc:creator>
<og:description>本文基于 Pinpoint 2.1.0 版本 新版本的内容参考官方文档， Pinpoint的整个搭建是历经艰辛。 一、2.1.0 版本特性 见官方文档 https://pinpoint-apm.git</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/operationhome/p/14016353.html</dc:identifier>
</item>
<item>
<title>小游戏2048最佳算法怎么实现？思路全解析！ - 锅外的大佬</title>
<link>http://www.cnblogs.com/liululee/p/14022691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liululee/p/14022691.html</guid>
<description>&lt;h2 id=&quot;1简介&quot;&gt;&lt;strong&gt;1.简介&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;很多人都玩过2048，我就比较老套，因为我一向看不上这类单机游戏。但是就在某一天泡脚的无聊时光，拿了媳妇儿的手机，左看看右点点，莫名打开了2048。嗯... 这真是一款打发无聊时光的 &quot;good game&quot;。通过滑动来使得每行或每列相邻并且相同的数字相加而得到一个最大的数字，最后的数字越大，得分越高！于是，我在想，是否能像魔方一样，有一定的套路来帮助我们决定每一步该往哪个方向滑动最佳，以便获得最好的成绩呢？&lt;/p&gt;
&lt;h2 id=&quot;2如何玩2048&quot;&gt;&lt;strong&gt;2.如何玩2048&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2048是在4×4方格中玩的游戏。&lt;/strong&gt;方格的每个位置都可能是空的，也可能是一个带有数字的方块。&lt;/p&gt;
&lt;p&gt;开始游戏时，方格上会在随机位置产生两个方块，数字为“ 2”或“ 4”。每个方块都有10％的几率是“ 4”，否则为“2”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通过将所有方块向某个方向&lt;/strong&gt;（上，下，左或右）&lt;strong&gt;移动来进行游戏&lt;/strong&gt;。这样做时，彼此相邻且一起移动的具有相同值的所有方块将合并成一个新的方块，该方块的值等于前两个方块的和：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1692986/202011/1692986-20201123083819882-2004814968.png&quot; alt=&quot;2048游戏&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;进行滑动后，将在随机位置产生一个新的方块。新方块有 90% 的几率为 ”2“, 10% 的几率是 ”4“。&lt;/p&gt;
&lt;p&gt;然后，继续进行游戏，直到方格中不再有能移动的方块为止。&lt;/p&gt;
&lt;p&gt;按理来说，这游戏的目标是达到一个值为“ 2048”的方块就结束了。但是，we never stop，我们可以继续进行游戏，来争取更大的胜利。理论上，方块最大值为 “ 131072” 。&lt;/p&gt;
&lt;h2 id=&quot;3问题说明&quot;&gt;3.问题说明&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;想要解决这个游戏，是个灰常因缺斯汀的问题。&lt;/strong&gt;因为我们不仅要正确预测每个新方块产生的位置，而且还要正确地预测它是“ 2”还是“ 4”。这是随机事件，理论上每一次都预测正确是不可能的。&lt;/p&gt;
&lt;p&gt;因此，不可能有一种算法每次都能轻松而正确解决难题。我们能尽可能做到的玩好这个概率游戏，确定每个步骤的最佳操作。&lt;/p&gt;
&lt;p&gt;不管什么时候，我们只能采取四种行为，然后面临的挑战是确定这四项举措中哪一项将取得最佳的长期效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们的算法基于 [Expectimax] 算法，它本身是 [Minimax] 算法的一种变体，但是树的路由会根据它们发生的可能性进行加权。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从本质上讲，我们将游戏视为两人游戏：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;玩家一（人类玩家）可以向四个方向的某个方向移动方块。&lt;/li&gt;
&lt;li&gt;玩家二（计算机玩家）可以将方块放置在方格的任一空白位置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于此，我们可以根据每个动作发生的概率对每个动作生成结果树。然后，这可以为我们提供确定哪种人员举动可能给出最佳结果所需的详细信息。&lt;/p&gt;
&lt;h3 id=&quot;31-游戏流程图&quot;&gt;&lt;strong&gt;3.1. 游戏流程图&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;游戏玩法的一般流程：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1692986/202011/1692986-20201123083820131-1782815388.png&quot; alt=&quot;2048算法&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以在“添加随机方块”过程中看到游戏的随机性——既要找到随机的正方形来添加方块，又要为方块选择一个随机值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然后，我们面临的挑战是在“确定下一步行动”步骤中确定要做什么。&lt;/strong&gt;这是我们玩游戏的算法。&lt;/p&gt;
&lt;p&gt;总体上看似看似简单：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1692986/202011/1692986-20201123083820305-662388238.png&quot; alt=&quot;java2028&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们需要做的是模拟每一种可能，确定哪个滑动给出最佳结果，然后使用它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;因此，我们现在将算法简化为模拟任何给定的移动并为结果生成分数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个分为两部分的过程。第一步是看是否可以移动，如果不能移动，则以“ 0”的分数提前中止。如果可以移动，那么我们将继续进行真正的算法，在该算法中确定移动的效果如何：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1692986/202011/1692986-20201123083820456-948100273.png&quot; alt=&quot;评分流程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-确定下一步行动&quot;&gt;&lt;strong&gt;3.2 确定下一步行动&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;到目前为止，算法的主要部分是模拟滑动，然而关键的问题是：如何为每个可能的移动进行评分。这下就是 Expectimax 算法发挥作用的时候了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我将模拟两个玩家的所有可能动作，并进行几个步骤，然后看看其中哪个能带来最佳结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于人类玩家而言，只有“上”，“下”，“左”和“右”的这四个动作。&lt;br/&gt;对于计算机则是，将“ 2”或“ 4” 方块随机放置在空白的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1692986/202011/1692986-20201123083820615-1084859775.png&quot; alt=&quot;模拟过程&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;该算法是递归的，每个递归步骤只有在距离真实游戏中的实际移动有一定深度时才会停止。这样导致流程图会循环返回自身，但实际上我们将这么做：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.如果处于极限深度则停止，为当前模拟的方格计算分数。&lt;/li&gt;
&lt;li&gt;2.计算机模拟所有可能的移动：模拟任何可能的人类玩家移动，返回人的移动，并计算出的分数。&lt;/li&gt;
&lt;li&gt;3.对模拟移动计算出的分数相加，然后对该移动发生的可能性进行加权。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;完成此操作后，我们将所有计算出的分数相加，这就是我们要从当前游戏板上进行的移动的最终分数。因为我们执行了四次操作（从当前游戏界面开始，每个可能的动作都获得一个），所以我们最终得到了四个分数，其中得分最高的就是应该做出的动作。&lt;/p&gt;
&lt;h3 id=&quot;33-计分&quot;&gt;&lt;strong&gt;3.3. 计分&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;此时，剩下要做的就是计算方格的分数。但还需要考虑，如何从这个位置继续得分。&lt;/p&gt;
&lt;p&gt;通过添加几个因素以及适当的权重，可以实现很多方法。例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;空方块数&lt;/li&gt;
&lt;li&gt;可能合并的次数——即，两个相邻位置中相同数字的次数&lt;/li&gt;
&lt;li&gt;每个方块上的最大值&lt;/li&gt;
&lt;li&gt;所有方块的总和&lt;/li&gt;
&lt;li&gt;方格的单一性——确定方格的结构好坏，使得方块的值在一个方向上增加。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;4伪代码&quot;&gt;&lt;strong&gt;4.伪代码&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;现在我们知道了算法的工作原理，接下来探索一些详细描述算法的伪代码。&lt;/p&gt;
&lt;p&gt;我对游戏的实际玩法并不感冒，只对确定移动的算法有点兴趣，所以从这里开始：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1692986/202011/1692986-20201123083820773-302226346.png&quot; alt=&quot;算法1-2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在到了这样的步骤：从第一个方块开始，模拟每一个可能的动作，并返回得分最好的那一个。因此我们需要为新模拟的方格生成分数。&lt;/p&gt;
&lt;p&gt;因为使用的是递归算法，所以我增加了一个深度限制，用来停止，否则可能会无止境运行下去。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1692986/202011/1692986-20201123083820918-1518521331.png&quot; alt=&quot;算法3&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1692986/202011/1692986-20201123083821045-1741703450.png&quot; alt=&quot;算法4&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这又是一个递归，模拟了每个人移动一定数量的步骤，并确定哪些移动可以拿到最佳的结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;剩下的唯一事情就是为移动后得到的每个方格，计算出最终分数。&lt;strong&gt;当然，这也没有十全十美的算法，不同的因素会造成不同的结果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1692986/202011/1692986-20201123083821175-1151452299.png&quot; alt=&quot;算法5&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;5性能优化&quot;&gt;&lt;strong&gt;5.性能优化&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;到目前为止，我们已经有了一种算法来尝试解决游戏问题，但是它效率不高。由于过程的特性，总是会有一定程度的重复。&lt;/p&gt;
&lt;p&gt;我们已经在上面的算法中做了一些优化，不处理对游戏没有任何影响的移动。但是，我们还有其他方法可以减少工作量，例如跟踪移动的累积概率，以及在移动的概率太低时停止。&lt;/p&gt;
&lt;p&gt;我们还可以动态确定深度次数的限制。&lt;strong&gt;上面的伪代码的硬编码限制为3，但我们可以在计算开始时根据方格的形状动态计算该限制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此外，由于可以多次重新访问同一方格的位置，因此我们可以记住这些位置并缓存这些位置的分数，而不必每次都重新计算它们。&lt;/strong&gt;潜在地，我们可以提前生成每个方块可能的位置，但是最多有2048个方块，281,474,976,710,656个可能的位置，因此这可能不可行。&lt;/p&gt;
&lt;p&gt;但是，我们可以做的最重要的优化是调整生成方格分数的算法。计分的因素和权重与我们的算法发挥得如何直接相关。&lt;/p&gt;
&lt;h2 id=&quot;六，结论&quot;&gt;&lt;strong&gt;六，结论&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;2048是一款非常有趣的游戏，可以尝试破解。虽然没有完美的方法，但是我们可以用一些启发式的方法，来探索游戏的最佳路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这类原则同样适用其他类型的两人游戏（例如国际象棋），在这种游戏中，无法准确预测别人会做什么。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;思考一下，棋牌类游戏电脑托管代打的策略是什么呢？在评论区留下你的答案吧！&lt;/p&gt;
&lt;p&gt;如果你觉得文章还不错，记得关注公众号： 锅外的大佬&lt;br/&gt;&lt;a href=&quot;http://developlee.top&quot;&gt;刘一手的博客&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Nov 2020 00:38:00 +0000</pubDate>
<dc:creator>锅外的大佬</dc:creator>
<og:description>1.简介 很多人都玩过2048，我就比较老套，因为我一向看不上这类单机游戏。但是就在某一天泡脚的无聊时光，拿了媳妇儿的手机，左看看右点点，莫名打开了2048。嗯... 这真是一款打发无聊时光的 &amp;am</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liululee/p/14022691.html</dc:identifier>
</item>
<item>
<title>【干货！！】十分钟带你搞懂 Java AQS 核心设计与实现！！！ - 使徒行者白</title>
<link>http://www.cnblogs.com/cfyrwang/p/14022685.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cfyrwang/p/14022685.html</guid>
<description>&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章写完放着也蛮久的了，今天终于发布了，对于拖延症患者来说也真是不容易～哈哈哈。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;言归正传，其实吧。。我觉得对于大部分想了解 AQS 的朋友来说，明白 AQS 是个啥玩意儿以及为啥需要 AQS，其实是最重要的。就像我一开始去看 AQS 的时候，抱着代码就啃，看不懂就去网上搜。。但是网上文章千篇一律。。大部分都是给你逐行分析下代码然后就没了。。。&lt;strong&gt;&lt;code&gt;但其实对我们来说我知道为啥要这么干其实也相当重要。。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;嗯。。所以就有了这篇文章。。笔者会先给你介绍下 AQS 的作者为啥要整这个东西。。然后笔者再结合自身感悟给你划了划重点。。如果你认真读了。。肯定会有所收获的哦&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;一、AQS 是什么？为什么需要 AQS ？&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;试想有这么一种场景：有四个线程由于业务需求需要同时占用某资源，但该资源在同一个时刻只能被其中唯一线程所独占。那么此时应该如何标识该资源已经被独占，同时剩余无法获取该资源的线程又该何去何从呢？ &lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b8f63f1f324cae93b2eb4cf604b3d1~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot;/&gt; 这里就涉及到了关于共享资源的竞争与同步关系。对于不同的开发者来说，实现的思路可能会有不同。这时如果能够有一个较为通用的且性能较优同步框架，那么可以在一定程度上帮助开发人员快速有效的完成多线程资源同步竞争方面的编码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;AQS 正是为了解决这个问题而被设计出来的。AQS 是一个集同步状态管理、线程阻塞、线程释放及队列管理功能与一身的同步框架。其核心思想是当多个线程竞争资源时会将未成功竞争到资源的线程构造为 Node 节点放置到一个双向 FIFO 队列中。被放入到该队列中的线程会保持阻塞直至被前驱节点唤醒。值得注意的是该队列中只有队首节点有资格被唤醒竞争锁。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;如果希望更具体的了解 AQS 设计初衷与原理，可以看下链接中的翻译版论文《The java.util.concurrent Synchronizer Framework》&lt;/code&gt;&lt;/strong&gt; https://www.cnblogs.com/dennyzhangdd/p/7218510.html&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你能耐心看完上面这篇论文，接着再从以下几个点切入翻阅 AQS 源码，那就相当如鱼得水了：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;strong&gt;同步状态的处理&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;FIFO 队列的设计，如何处理未竞争到资源的线程&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;竞争失败时线程如何处理&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;共享资源的释放&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;后面的章节主要会结合 AQS 源码，介绍下独占模式下锁竞争及释放相关内容。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;二、同步状态的处理&lt;/span&gt;&lt;/h2&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; state;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;翻阅下 AQS 源码，不难发现有这么一个 volatile 类型的 state 变量。通俗的说这个 state 变量可以用于标识当前锁的占用情况。打个比方：当 state 值为 1 的时候表示当前锁已经被某线程占用，除非等占用的锁的线程释放锁后将 state 置为 0，否则其它线程无法获取该锁。这里的 state 变量用 volatile 关键字保证其在多线程之间的可见性。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;tryAcquire&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;tryRelease&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; UnsupportedOperationException();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时，我们发现 AQS 预留了个口子可以供开发人员按照自身需求进行二次重构。因此也就出现了类似与 &lt;strong&gt;ReentrantLock&lt;/strong&gt; 可重入锁、&lt;strong&gt;CountDownLatch&lt;/strong&gt; 等实现。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;三、AQS 灵魂队列的设计&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于整个 AQS 框架来说，队列的设计可以说重中之重。那么为什么 AQS 需要一个队列呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于一个资源同步竞争框架来说，如何处理没有获取到锁的线程是非常重要的，比方说现在有 ABCD 四个线程同时竞争锁，其中线程 A 竞争成功了。那么剩下的线程 BCD 该咋办呢？ &lt;img src=&quot;https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d6b8f63f1f324cae93b2eb4cf604b3d1~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot;/&gt; 我们可以尝试试想下自己会如何解决：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;线程自旋等待，不断重新尝试获取锁。这样虽然可以满足需求，但是众多线程同时自旋等待实际上是对 CPU 资源的一种浪费，这么做不太合适。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;将线程挂起，等待锁释放时唤醒，再竞争获取。如果等待的线程比较多，同时被唤醒可能会发生“惊群”问题。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面两种方法的可行性其实都不太高，对于一个同步框架来说，当有多个线程尝试竞争资源时，我们并不希望所有的线程同时来竞争锁。而且更重要的是，&lt;strong&gt;&lt;code&gt;能够有效的监控当前处于等待过程中的线程也十分必要&lt;/code&gt;&lt;/strong&gt;。那么这个时候借助 FIFO 队列管理线程，既可以有效的帮助开发者监控线程，同时也可以在一定程度上减少饥饿问题出现的概率(&lt;strong&gt;线程先入先出&lt;/strong&gt;)。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外 AQS 中用于存放线程的队列还有以下几点考量：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Node 节点的设计&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;前驱、后继节点，分别保存当前节点在队列中的前驱节点和后继节点&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;节点状态：节点拥有不同的状态可以帮助我们更好的管理队列中的线程。在本文中我们只讨论 SIGNAL 和 CANCEL 状态。当前驱节点的状态为 SIGNAL 时，表示当前节点可以被安全挂起，锁释放时当前线程会被唤醒去尝试重新获取锁；CANCEL 状态表示当前线程被取消，无需再尝试获取锁，可以被移除队列&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;  &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; CANCELLED =  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; SIGNAL    = -&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; CONDITION = -&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; PROPAGATE = -&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;section readability=&quot;5&quot;&gt;&lt;p&gt;AQS 中的双向线程队列 由于 Node 前驱和后继节点的存在。这里保存 Node 的队列实际上是一个双向队列。在这个队列里前驱节点的存在会更重要些：&lt;strong&gt;&lt;code&gt;当前新节点被插入到队列中时，如果前驱节点状态为取消状态。我们可以通过前驱节点不断往前回溯，完成一个类似滑动窗口的功能，跳过无效线程&lt;/code&gt;&lt;/strong&gt;，从而帮助我们更有效的管理等待队列中线程。而且上面也提过了，等待线程都放在队列中，一方面可以管控等待线程，另一方面也可以较少饥饿现象发生的概率。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;section readability=&quot;5&quot;&gt;&lt;p&gt;HEAD 和 TAIL HEAD 和 TAIL 节点分别指向队列的首尾节点。当第一次往队列中塞入一个新的节点时会构造一个虚拟节点作为 HEAD 头节点。为什么需要虚拟的 HEAD 头节点呢？因为在 AQS 的设计理念中，当前节点能够安心自我阻塞的前提条件是前驱节点在释放锁资源时，能够唤醒后继节点。&lt;strong&gt;&lt;code&gt;而插入到第一个队列中的节点，没有前驱节点怎么办，我们就构造一个虚拟节点来满足需求&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同时 HEAD 和 TAIL 节点的存在加上双向队列的设计，整体的队列就显的非常灵活。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;四、资源竞争(获取锁)&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一章节开始我们将结合源码对 AQS 获取锁的流程进行讨论。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;acquire&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!tryAcquire(arg) &amp;amp;&amp;amp;&lt;br/&gt;acquireQueued(addWaiter(Node.EXCLUSIVE), arg))&lt;br/&gt;selfInterrupt();&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;acquire 方法用于获取锁，这里可以拆解为三步：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;strong&gt;tryAcquired&lt;/strong&gt;： 看名字就知道用于尝试获取所，并不保证一定可以获取锁，具体逻辑由子类实现。如果在这一步成功获取到了锁，后面的逻辑也就没有必要继续执行了。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;addWaiter&lt;/strong&gt;：&lt;strong&gt;&lt;code&gt;尝试竞争锁资源失败后，我们就要考虑将这个线程构造成一个节点插入到队列中了&lt;/code&gt;&lt;/strong&gt;。这里的 addWaiter() 方法会将当前线程包装成一个 Node 节点后，维护到 FIFO 双向队列中。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt; &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;hljs-title&quot;&gt;addWaiter&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Node mode)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;Node node = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Node(Thread.currentThread(), mode);&lt;br/&gt;Node pred = tail;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (pred != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) {&lt;br/&gt;node.prev = pred;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (compareAndSetTail(pred, node)) {&lt;br/&gt;pred.next = node;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; node;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;enq(node);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; node;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; Node &lt;span class=&quot;hljs-title&quot;&gt;enq&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;Node t = tail;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (t == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;) { &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (compareAndSetHead(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Node()))&lt;br/&gt;tail = head;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;node.prev = t;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (compareAndSetTail(t, node)) {&lt;br/&gt;t.next = node;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; t;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这段逻辑不复杂：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;当我们处理第一个节点时，此时 tail 节点为 null，因此会执行 enq() 方法。可以看到 enq 方法实际是一个死循环，只有当节点成功被插入到队列后，才能跳出去循环。那这么做的目的是什么呢？&lt;strong&gt;&lt;code&gt;其实不难看出，这里是为了应对多线程竞争而采取的妥协之策&lt;/code&gt;&lt;/strong&gt;。多个线程同时执行这段逻辑时，只有一个线程可以成功调用 compareAndSetHead() 并将 head 头指向一个新的节点，此时的 head 和 tail 都指向一个空节点。这个空节点的作用前面已经提过了，用于帮助后继节点可以在合适的场景下自我阻塞等待被唤醒。其它并发执行的线程执行 compareAndSetHead() 方法失败后，发现 tail 已经不为 null 了，依次将自己插入到 tail 节点后。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;当 tail 节点不为空时，表示此时队列中有数据。因此我们借助 CAS 将新节点插入到尾节点之后，同时将 tail 指向新节点 &lt;img src=&quot;https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22bae261c2914972a62ac048a70748e4~tplv-k3u1fbpfcp-watermark.image&quot; alt=&quot;&quot;/&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;strong&gt;acquireQueued&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;acquireQueued&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; Node node, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; failed = &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; interrupted = &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (;;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; Node p = node.predecessor();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {&lt;br/&gt;setHead(node);&lt;br/&gt;p.next = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;; &lt;br/&gt;failed = &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; interrupted;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;&lt;br/&gt;parkAndCheckInterrupt())&lt;br/&gt;interrupted = &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;finally&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (failed)&lt;br/&gt;cancelAcquire(node);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里又是一个死循环&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;section readability=&quot;5&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;这里需要注意的是只有前驱节点为 head 时，我们才会再次尝试获取锁&lt;/code&gt;&lt;/strong&gt;。也就是在当前队列中，只有队首节点才会尝试获取锁。&lt;strong&gt;&lt;code&gt;这里也体现了如何降低饥饿现象发生的概率&lt;/code&gt;&lt;/strong&gt;。如果成功获取到了锁：将 node 节点设置为头节点，同时将前驱节点的 next 设置为 null 帮助 gc。&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;section readability=&quot;4&quot;&gt;&lt;p&gt;如果 node 节点前驱节点不为 head 或者获取锁失败，执行 shouldParkAfterFailedAcquire() 方法判断当前线程是否需要阻塞，如果需要阻塞则会调用 parkAndCheckInterrupt() 方法挂起当前线程&lt;/p&gt;
&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;shouldParkAfterFailedAcquire&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Node pred, Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; ws = pred.waitStatus;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (ws == Node.SIGNAL)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (ws &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;do&lt;/span&gt; {&lt;br/&gt;node.prev = pred = pred.prev;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (pred.waitStatus &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);&lt;br/&gt;pred.next = node;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;compareAndSetWaitStatus(pred, ws, Node.SIGNAL);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;code&gt;当节点状态为 SIGNAL 时，表示当前线程可以被安全挂起。waitStats 大于0表示当前线程已经被取消，我们需要往前回溯找到有效节点。&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;在开始阅读这段代码时，一直想不通在哪些场景下 waitStatus 的状态可能为 0，在参阅了其它笔者分析的文章再加上自己的理解后，总结出以下两种场景：&lt;/strong&gt;&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;code&gt;当我们往队列中新插入一个节点时。队尾节点的 waitStatus 值应为初始状态 0&lt;/code&gt;&lt;/strong&gt;。此时执行 shouldParkAfterFailedAcquire() 方法会执行最后一个判断条件将前驱 waitStatus 状态更新为 SIGNAL,同时方法返回 false 。然后会继续执行一次 acquireQueued() 中的死循环，此时前驱节点的状态已经被更新为 SIGNAL，再次执行 shouldParkAfterFailedAcquire() 方法会返回 true，当前线程即可放心的将自己挂起，等待被线程唤醒。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;code&gt;当调用 release() 方法释放锁时，会将占用锁的节点的 waitStatus 状态更新为 0&lt;/code&gt;&lt;/strong&gt;，同时会调用 LockSupport.unpark() 方法唤醒后继节点。当后继节点被唤醒之后，会继续执行被挂起之前执行的 acquireQueued() 方法中的 for 循环再次尝试获取锁。&lt;strong&gt;&lt;code&gt;但是被唤醒并不代表一定可以获取到锁&lt;/code&gt;&lt;/strong&gt;，如果获取不到锁则会再次执行 shouldParkAfterFailedAcquire() 方法。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;为什么说被唤醒的线程不一定可以获取到锁呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于基础的 acquire 方法来说，没有任何规则规定队首节点一定可以获取到锁。当我们在唤醒队列中的第一个有效线程时，此时如果出现了一个线程 A 尝试获取锁，那么该线程会调用 acquire() 方法尝试获取锁，如果运气不错，线程 A 完全有可能会窃取当前处于队列头中的线程获取锁的机会。&lt;strong&gt;&lt;code&gt;因此基础的 acquire 方法实际上是不公平的&lt;/code&gt;&lt;/strong&gt;。那么为什么这么做？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果队列头处于解除阻塞过程中，这一段时间实际上没有线程可以获取资源，属于一种资源浪费。所以这里只能认为是有一定概率的公平。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;五、资源释放(释放锁)&lt;/span&gt;&lt;/h2&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;release&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; arg)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (tryRelease(arg)) {&lt;br/&gt;Node h = head;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (h != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; h.waitStatus != &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;br/&gt;unparkSuccessor(h);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;unparkSuccessor&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Node node)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; ws = node.waitStatus;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (ws &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;br/&gt;compareAndSetWaitStatus(node, ws, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;);&lt;br/&gt;Node s = node.next;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (s == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; || s.waitStatus &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;s = &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (Node t = tail; t != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; &amp;amp;&amp;amp; t != node; t = t.prev)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (t.waitStatus &amp;lt;= &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;)&lt;br/&gt;s = t;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (s != &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt;)&lt;br/&gt;LockSupport.unpark(s.thread);&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;release 整体流程比较简单。需要我们注意的就是为什么此时需要把 head 节点的状态更新为 0，主要是便于唤起后续节点，这个问题第四章节也已经聊过了，就不赘述了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;另外，当前节点的后继为 null 或者 后继节点的状态为 CANCEL，那么会从尾节点开始，从后往前寻找队列中最靠前的有效节点。&lt;/p&gt;
&lt;hr data-tool=&quot;mdnice编辑器&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如果你觉得文章写的还不错，快给笔者点个赞吧，你的鼓励是笔者创作最大的支持！！！！！！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 23 Nov 2020 00:35:00 +0000</pubDate>
<dc:creator>使徒行者白</dc:creator>
<og:description>前言 这篇文章写完放着也蛮久的了，今天终于发布了，对于拖延症患者来说也真是不容易～哈哈哈。 言归正传，其实吧。。我觉得对于大部分想了解 AQS 的朋友来说，明白 AQS 是个啥玩意儿以及为啥需要 AQ</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cfyrwang/p/14022685.html</dc:identifier>
</item>
<item>
<title>NVM、NPM、Node.js的安装选择 - 奶酪魔像</title>
<link>http://www.cnblogs.com/LFeather/p/14022683.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LFeather/p/14022683.html</guid>
<description>&lt;p&gt;在安装和使用这三种工具时，我们有很多方式可以选择，这些方法各有优劣，每个人都有自己用起来比较习惯的配置，所以我在这里记录下自己比较习惯的一种安装方式与其他一些可能的选项。&lt;/p&gt;
&lt;h2 id=&quot;nvm、npm、nodejs的关系&quot;&gt;NVM、NPM、Node.js的关系&lt;/h2&gt;
&lt;p&gt;假定我们的最终目的是为了安装并使用Node.js，那么我们有两种常规的选择：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Node.js安装包&lt;/li&gt;
&lt;li&gt;NVM&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一种方式非常直接，搜索Node.js，在官网下载需要的的版本并进行安装就可以了，但是一般不推荐这种方式，因为Node.js的版本众多，开发时不同的项目可能会使用不同的版本，每次面对不同的项目都要重新安装，版本的切换十分麻烦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/20/QjU1kmzoZvYKrlD.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了解决上面的问题，使用NVM是一个不错的选择，我们先看的NVM的全称：&lt;strong&gt;Node Version Manager&lt;/strong&gt;，也就是说NVM是Node.js的版本管理器，通过NVM我们就可以安装多个不同版本的Node.js并在需要的时候进行切换，具体的方法在下面介绍。&lt;/p&gt;
&lt;p&gt;NVM是Node.js管理器，那么NPM呢？还是看全称：&lt;strong&gt;Node Package Manager&lt;/strong&gt;，也就是Node.js包管理器，用于管理Node的大量扩展API。在安装Node.js时就会自动安装相应版本的NPM。&lt;/p&gt;
&lt;h2 id=&quot;nvm&quot;&gt;NVM&lt;/h2&gt;
&lt;p&gt;直接从GitHub上下载 &lt;a href=&quot;https://github.com/coreybutler/nvm-windows/releases&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;分成安装版（setup）和免安装版（noinstall）,区别不大但如果希望能在全局的各个文件位置都可以使用NVM、NPM和Node.js这些工具的指令，要注意使用免安装版需要自行设置环境变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/20/UemOab4Nn8Lc1st.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装版（setup）&quot;&gt;安装版（setup）&lt;/h3&gt;
&lt;p&gt;安装过程需要设置两个路径，就是环境变量相应的值，分别是NVM和Node.js的路径，建议路径中不要有空格，安装时会自动建立环境变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/20/qsIGVYmcWrfTNoj.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/20/Nj7nswxf3OmZ26D.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;免安装版（noinstall）设置环境变量&quot;&gt;免安装版（noinstall）设置环境变量&lt;/h3&gt;
&lt;p&gt;使用免安装版时可以配置环境变量如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/20/ErWL5luA1v7cJSZ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NVM_HOME&lt;/strong&gt; 就是NVM所在的目录，&lt;strong&gt;NVM_SYMLINK&lt;/strong&gt; 则是Node.js的目录，但变量名看起来好像没什么关系，原因我们在下面切换Node.js版本的操作方法处说明。&lt;/p&gt;
&lt;h3 id=&quot;验证nvm安装&quot;&gt;验证nvm安装&lt;/h3&gt;
&lt;p&gt;安装完成后我们可以通过&lt;code&gt;nvm version&lt;/code&gt;命令查看nvm的版本来验证是否已经成功安装。由于我们配置了环境变量，所以可以在任意目录中执行nvm命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/20/WYj7ptmakdsbo61.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装指定版本的nodejs&quot;&gt;安装指定版本的Node.js&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;nvm install 版本号

// 举例
nvm install 12.19.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令很简单，但是在版本号的选择上似乎有些问题，最开始我们就说到Node.js版本众多，这里我到底该选择哪个版本呢？&lt;/p&gt;
&lt;p&gt;我们回过头看下Node.js的首页,可以看到两种版本&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;LTS（Long-Term Support）&lt;/li&gt;
&lt;li&gt;Current&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/20/OJvq1a9QeSWGFfn.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于Node.js版本的成因和各种具体的说明已经有文章写得很明确了，&lt;a href=&quot;https://nodejs.org/en/about/releases/&quot;&gt;官网页面&lt;/a&gt;也有说明，有兴趣可以去了解一下，根据 &lt;strong&gt;Recommended For Most Users&lt;/strong&gt; 和 &lt;strong&gt;Latest Features&lt;/strong&gt; 可以得出一个简单的结论：&lt;strong&gt;通常情况，为了稳定选择LTS版本，为了尝鲜选择Current版本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外值得一提的就是Node.js采用奇偶版本号的形式，奇数为非稳定版（如9.11、15.2.1），偶数为稳定版（如10.23、12.19.1），通过这个也可以简单判断。&lt;/p&gt;
&lt;p&gt;但既然我们使用了nvm，难道还要每次去Node,js官网看下版本再安装吗？当然不需要，通过指令&lt;code&gt;nvm list available&lt;/code&gt;就可以查看近期的可用版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/20/JRdUWlBGhxwV5Ef.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;下载服务器&quot;&gt;下载服务器&lt;/h3&gt;
&lt;p&gt;在开始安装之前还有一件事要注意，npm与Node.js的默认下载服务器均在国外，国内进行下载时往往有速度较慢的问题，我们可以通过配置为淘宝镜像进行解决。在安装目录下面我们可以找到名为 &lt;strong&gt;settings.txt&lt;/strong&gt; 的文件，打开并在最后加上两行来将Node.js和npm的下载服务器地址替换为服务器在国内的淘宝镜像:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;node_mirror: https://npm.taobao.org/mirrors/node/
npm_mirror: https://npm.taobao.org/mirrors/npm/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;切换nodejs版本&quot;&gt;切换Node.js版本&lt;/h3&gt;
&lt;p&gt;得到版本号后执行上面的install指令进行安装。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/OxqzMPCI9Q5UE7X.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时可以先通过&lt;code&gt;nvm list&lt;/code&gt;指令来查看已经安装的Node.js版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/ny5vKhrpLfgkeWU.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到已经有一个版本的Node.js被安装了，也许这时已经有人开始跃跃欲试地输入&lt;code&gt;node -v&lt;/code&gt;来测试Node.js的安装情况了，但此时会发现&lt;code&gt;node&lt;/code&gt;指令仍然没有被系统识别，显然我们还有什么步骤没有做，在安装步骤的最后，nvm也提醒我们使用&lt;code&gt;nvm use&lt;/code&gt;指令。&lt;/p&gt;
&lt;p&gt;输入&lt;code&gt;nvm use 版本号&lt;/code&gt;，例如&lt;code&gt;nvm use 12.19.1&lt;/code&gt;来切换Node.js到指定的版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/zJaN2OXTPV6eCRr.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到提示我们已经切换到对应的版本，之后可以通过&lt;code&gt;nvm list&lt;/code&gt;来查看当前已经安装和正在使用的Node.js版本。正在使用的Node.js版本会用星号标出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/MNtH1aZUJmREqBV.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们就可以用我们熟悉的命令来查看一下Node.js和npm的安装情况了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/4GQVO6gDzxFBq8s.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于nvm版本切换的实质&quot;&gt;关于nvm版本切换的实质&lt;/h3&gt;
&lt;p&gt;在最开始使用nvm的时候我遇到了一些特殊的情况导致版本切换功能整个失效，借这个问题我观察了一下nvm的安装目录从而发现了端倪。大家应该还记得，在最初安装nvm的时候我们选择了两个路径，一个是nvm的路径，另一个是Node.js的路径，但是直到我们安装第一个版本的Node.js后，这个文件夹也是未使用的状态，此时再查看nvm的安装目录，可以看到有对应版本号的文件夹被创建，里面就是对应版本Node.js的文件，每一个版本对应一个文件夹。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/XFKHbaJSUfxV3Z2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那版本切换时怎么做到的呢？如果使用普通权限的命令提示行来进行版本切换操作，我们会发现系统提示cmd申请管理员权限，同意操作后再查看之前的nodejs文件夹：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/SyPaGszrCmD2RH4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图标有所变化，看到左下角的标记应该可以猜到这里可能是用了Windows系统中的快捷方式来实现这一操作，右键-属性查看一下果不其然：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/dDxnalb5mHIThQS.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个文件夹此时就变成了nvm目录下的对应版本文件夹的快捷方式，切换版本正是在进行创建或修改快捷方式这一操作。&lt;/p&gt;
&lt;p&gt;而且我们可以回忆一下在最初安装时设置的系统变量，nodejs目录采用的SYMLINK可能就是System Link这一缩写，所以每次切换版本，Node.js的全局变量也已经设置好了，我们自然可以直接在各个文件位置使用node和npm指令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/20/ErWL5luA1v7cJSZ.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;npm&quot;&gt;NPM&lt;/h2&gt;
&lt;p&gt;关于NPM的配置我们还可以进行一些小的调整。输入&lt;code&gt;npm config ls&lt;/code&gt;指令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/mWl8U4qAHTXeJ6L.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;红线圈出的两个部分默认未修改的情况应该是在C盘的用户目录下，这两个路径是npm全局包的安装和缓存目录。在我的C盘目录比较拮据的情况下，将全局包安装在C盘显然不太合适，所以我选择将这两个路径改到之前nvm目录的附件，便于查看和管理，指令如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm config set prefix &quot;D:/web/package/npm_global&quot;
npm config set cache &quot;D:/web/package/npm_cache&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来可以安装一个全局包试一下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install vue -g
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成，全局查看可以看到当前的全局目录和vue已经安装成功：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm ls -g
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/fKzVXmSBZsE8i7A.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;疑问&quot;&gt;疑问&lt;/h3&gt;
&lt;p&gt;由于npm现在已经固定包的安装目录了，即使切换Node.js版本，npm的包安装目录也仍然是我们设置的文件夹，使用&lt;code&gt;npm ls -g&lt;/code&gt;指令查看仍然会发现之前安装的包，不知道是否出现依赖于不同npm版本的包互相冲突的情况，目前我还没有太多关于Node.js版本切换的实践场景，准备日后遇到这个问题再进行一些实际的测试。&lt;/p&gt;
</description>
<pubDate>Mon, 23 Nov 2020 00:34:00 +0000</pubDate>
<dc:creator>奶酪魔像</dc:creator>
<og:description>在安装和使用这三种工具时，我们有很多方式可以选择，这些方法各有优劣，每个人都有自己用起来比较习惯的配置，所以我在这里记录下自己比较习惯的一种安装方式与其他一些可能的选项。 NVM、NPM、Node.j</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LFeather/p/14022683.html</dc:identifier>
</item>
<item>
<title>【开源】.net微服务开发引擎Anno开源啦 - 杜燕明</title>
<link>http://www.cnblogs.com/duyanming/p/13949446.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duyanming/p/13949446.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1、Anno是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;a href=&quot;https://github.com/duyanming/Anno.Core&quot; target=&quot;_blank&quot;&gt;Anno&lt;/a&gt;&lt;/strong&gt;是一个微服务框架引擎。&lt;strong&gt;入门简单&lt;/strong&gt;、&lt;strong&gt;安全&lt;/strong&gt;、&lt;strong&gt;稳定&lt;/strong&gt;、&lt;strong&gt;高可用&lt;/strong&gt;、&lt;strong&gt;全平台可监控、依赖第三方框架少。&lt;/strong&gt;底层通讯RPC(Remote Procedure Call)采用稳定可靠经过无数成功项目验证过的跨语言的&lt;strong&gt;&lt;code&gt;&lt;a href=&quot;https://github.com/apache/thrift&quot; target=&quot;_blank&quot;&gt;thrift&lt;/a&gt;、&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;https://github.com/grpc/grpc-dotnet&quot; target=&quot;_blank&quot;&gt;grpc&lt;/a&gt;&lt;/code&gt;&lt;/strong&gt;。 自带服务注册发现健康检查（不依赖于Etcd、Consul、Zookeeper）、调用链追踪、Cron 调度、限流、事件总线。插件化开发，业务模块以CQRS 、DDD作为指导思想。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;　　一个&lt;code&gt;不可监控&lt;/code&gt;的微服务平台是&lt;code&gt;可怕的&lt;/code&gt;&lt;/strong&gt;，出了问题&lt;strong&gt; 难以准确定位问题的根源&lt;/strong&gt;， Anno则提供了一套完整的监控体系，包括&lt;strong&gt;&lt;code&gt;链路追踪&lt;/code&gt;、&lt;code&gt;服务占用的系统资源&lt;/code&gt;、系统自身 &lt;code&gt;CPU、内存、硬盘使用率&lt;/code&gt;&lt;/strong&gt;实时可监控等等。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;github Anno:&lt;a href=&quot;https://github.com/duyanming/Anno.Core&quot; target=&quot;_blank&quot;&gt;https://github.com/duyanming/Anno.Core&lt;/a&gt;  &lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;体验地址：&lt;a href=&quot;http://140.143.207.244/Home/Login&quot; target=&quot;_blank&quot;&gt;http://140.143.207.244/Home/Login&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 2&lt;strong&gt;、Anno微服务集群面板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;从微服务面板中我们可以看到整个微服务集群中的所有服务的基本信息，包括&lt;strong&gt;服务名称&lt;/strong&gt;（例如：App001）、&lt;strong&gt;服务地址&lt;/strong&gt;（例如：10.163.66.68）、&lt;strong&gt;端口&lt;/strong&gt;（例如：6600）、&lt;strong&gt;服务超时时间&lt;/strong&gt;（例如：20000毫秒）、&lt;strong&gt;服务权重&lt;/strong&gt;（例如：1，根据需要配置不要设置过大）、&lt;strong&gt;服务功能承载范围&lt;/strong&gt;（例如： &lt;span class=&quot;el-tag el-tag--warning el-tag--mini el-tag--light is-hit&quot;&gt;Anno.Plugs.DLock、Anno.Plugs.Viper、Anno.Plugs.Logic【路由也是根据此标记选择服务的】&lt;/span&gt;）&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在微服务面板中，也可以点击每个服务的链接跳转到此服务的资源监控面板中实时查看CPU、内存、硬盘等信息的占用情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202011/998152-20201121073650978-1744324106.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3、资源监控面板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;WebSocket实时推送到前端，方便掌握第一手资料。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202011/998152-20201121073847989-449884463.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt; 4、完善的文档&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;文档托管在GitHub上地址是：&lt;a href=&quot;https://duyanming.github.io/&quot; target=&quot;_blank&quot;&gt;https://duyanming.github.io/&lt;/a&gt; 。对Anno的整体设计思路，架构组成都有说明。后面也会逐步完善。&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/998152/202011/998152-20201121075946004-772323137.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 5&lt;strong&gt;、学习交流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;在这里作者刚刚建立了一个&lt;strong&gt;QQ群：478399354&lt;/strong&gt; ，到这里我们互为师长项目学习。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Anno开源地址：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Anno&lt;/strong&gt;核心源码:&lt;a href=&quot;https://github.com/duyanming/Anno.Core&quot; target=&quot;_blank&quot;&gt;https://github.com/duyanming/Anno.Core&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Viper&lt;/strong&gt;示例项目:&lt;a href=&quot;https://github.com/duyanming/Viper&quot; target=&quot;_blank&quot;&gt;https://github.com/duyanming/Viper&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;体验地址：&lt;a href=&quot;http://140.143.207.244/Home/Login&quot; target=&quot;_blank&quot;&gt;http://140.143.207.244/Home/Login&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文档地址：&lt;a href=&quot;https://duyanming.github.io/&quot; target=&quot;_blank&quot;&gt;https://duyanming.github.io/&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关于Anno的更多内容，随后更新。敬请关注。开源不易，感谢Star。&lt;/p&gt;
</description>
<pubDate>Sun, 22 Nov 2020 23:45:00 +0000</pubDate>
<dc:creator>杜燕明</dc:creator>
<og:description>1、Anno是什么？ Anno是一个微服务框架引擎。入门简单、安全、稳定、高可用、全平台可监控、依赖第三方框架少。底层通讯RPC(Remote Procedure Call)采用稳定可靠经过无数成功项</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duyanming/p/13949446.html</dc:identifier>
</item>
<item>
<title>HotSpot类模型之ArrayKlass - HotSpot-Researcher</title>
<link>http://www.cnblogs.com/mazhimazhi/p/14022630.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mazhimazhi/p/14022630.html</guid>
<description>&lt;p&gt;上一篇分析了 &lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/14014628.html&quot;&gt;HotSpot类模型之InstanceKlass&lt;/a&gt; ，这次主要分析表示java数组类型的C++类。&lt;/p&gt;
&lt;h2&gt;1、&lt;strong&gt;ArrayKlass&lt;/strong&gt;&lt;strong&gt;类&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;ArrayKlass继承自Klass，是所有数组类的抽象基类，类及重要属性的定义如下：  &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
class ArrayKlass: public Klass {
  ...
 private:
  int               _dimension;         // This is n'th-dimensional array.
  Klass* volatile   _higher_dimension;  // Refers the (n+1)'th-dimensional array (if present).
  Klass* volatile   _lower_dimension;   // Refers the (n-1)'th-dimensional array (if present).
  int               _vtable_len;        // size of vtable for this klass
  oop               _component_mirror;  // component type, as a java/lang/Class
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Klass的基础上增加的属性如下表所示。&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;字段&lt;/td&gt;
&lt;td&gt;作用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_dimension&lt;/td&gt;
&lt;td&gt;int类型，表示数组的维度，记为n&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_higher_dimension&lt;/td&gt;
&lt;td&gt;Klass指针，表示对n+1维数组Klass的引用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_lower_dimension&lt;/td&gt;
&lt;td&gt;Klass指针，表示对n-1维数组Klass的引用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_vtable_len&lt;/td&gt;
&lt;td&gt;int类型， 虚函数表的长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_component_mirror&lt;/td&gt;
&lt;td&gt;oop， 数组元素对应的java.lang.Class对象的Oop&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;_vtable_len的值为5，因为数组是引用类型，父类为Object类，而Object类中有5个虚方法可被用来继承和重写，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void          finalize()
boolean       equals(Object)
String        toString()
int           hashCode()
Object        clone()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; _dimension、_higher_dimension与_lower_dimension对于一维及多维数组的描述非常重要，属性值的设置相对简单，这里不在介绍。&lt;/p&gt;
&lt;h2&gt;2、ArrayKlass类的子类&lt;/h2&gt;
&lt;h3&gt;（1）&lt;strong&gt;TypeArrayKlass类&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;TypeArrayKlass是ArrayKlass的子类，用于表示数组元素是基本类型的数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
class TypeArrayKlass : public ArrayKlass {
  ...
 private:
  jint _max_length;  // maximum number of elements allowed in an array
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; _max_length表示该数组允许的最大长度。&lt;/p&gt;
&lt;p&gt;数组类和普通类不同，数组类没有对应的Class文件，所以数组类是直接被虚拟机创建的。HotSpot在初始化时就会创建好8个基本类型的一维数组对象TypeArrayKlass。之前在讲解HotSpot启动时讲到过，调用initializeJVM()方法初始化HotSpot，这个方法会最终调用到Universe::genesis()方法，在这个方法中初始化基本类型的一维数组对象TypeArrayKlass。例如初始化boolean类型的一维数组，调用语句如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
_boolArrayKlassObj = TypeArrayKlass::create_klass(T_BOOLEAN, sizeof(jboolean), CHECK);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中_boolArrayKlassObj是声明在universe.cpp文件中的全局变量，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
Klass* Universe::_boolArrayKlassObj = NULL;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用TypeArrayKlass::create_klass()方法创建TypeArrayKlass对象，具体就是调用TypeArrayKlass::create_klass()方法来完成，方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
TypeArrayKlass* TypeArrayKlass::allocate(ClassLoaderData* loader_data, BasicType type, Symbol* name, TRAPS) {

  int x = TypeArrayKlass::header_size();
  int size = ArrayKlass::static_size(x);
  // 调用的构造函数在下面
  return new (loader_data, size, THREAD) TypeArrayKlass(type, name);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非常类似于InstanceKlass等对象的创建，首先获取需要内存的大小size，然后通过重载new运算符完成对象内存分配后，调用TypeArrayKlass的构造函数初始化一些属性。&lt;/p&gt;
&lt;p&gt;TypeArrayKlass的header_size()及static_size()函数的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
static int header_size(){
          int k = sizeof(TypeArrayKlass);
          return k/HeapWordSize;
}

int ArrayKlass::static_size(int header_size) {
  // size of an array klass object
  assert(header_size &amp;lt;= InstanceKlass::header_size(), &quot;bad header size&quot;);
  // If this assert fails, see comments in base_create_array_klass.
  header_size = InstanceKlass::header_size();  // 为什么是InstanceKlass的大小？？看ArrayKlass::start_of_vtable()函数有说明
  int vtable_len = Universe::base_vtable_size(); //  值为5

  int size = header_size + align_object_offset(vtable_len); // 对vtable_len进行对齐操作

  return align_object_size(size);
}

static int header_size(){
   return align_object_offset(sizeof(InstanceKlass)/HeapWordSize);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意header_size属性的值应该是TypeArrayKlass这个类自身占用的内存大小，但是现在却取的是InstanceKlass这个类自身占用内存的大小。这是因为InstanceKlass占用内存大小比TypeArrayKlass大，有足够内存存放相关数据，更重要的是为了统一从固定的偏移位置取出vtable_len属性的值。这样在实际操作过程中，无需关心是数组还是类，都直接偏移固定位置后取vtable_len属性值即可。　&lt;/p&gt;
&lt;p&gt;TypeArrayKlass的构造函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
TypeArrayKlass::TypeArrayKlass(BasicType type, Symbol* name) : ArrayKlass(name) {
  int lh = array_layout_helper(type);
  set_layout_helper(lh);
  assert(oop_is_array(), &quot;sanity&quot;);
  assert(oop_is_typeArray(), &quot;sanity&quot;);

  set_max_length(arrayOopDesc::max_array_length(type)); // 设置数组的最大长度
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面详细介绍一下对_layout_helper属性的设置。调用Klass::array_layout_helper()方法获取_layout_helper属性的值&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
jint Klass::array_layout_helper(BasicType etype) {
  assert(etype &amp;gt;= T_BOOLEAN &amp;amp;&amp;amp; etype &amp;lt;= T_OBJECT, &quot;valid etype&quot;);
  // Note that T_ARRAY is not allowed here.
  int  hsize = arrayOopDesc::base_offset_in_bytes(etype); // hsize表示数组元素的对象头部大小
  int  esize = type2aelembytes(etype); // 对应类型存储所需要的字节数
  bool isobj = (etype == T_OBJECT);
  int  tag   =  isobj ? _lh_array_tag_obj_value : _lh_array_tag_type_value;
  int  esz = exact_log2(esize);
  int  lh = array_layout_helper(tag, hsize, etype, esz);
  

  return lh;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;关于_layout_helper在之前已经介绍过，由于T_BOOLEAN为基本类型，所以tag的值取0xC0；hsize调用arrayOopDesc::base_offset_in_bytes()方法获取，值为16，后面在讲解arrayOopDesc时会介绍，数组对象其实是由对象头、对象字段数据和对齐填充组成，而这里获取的就是对象头的大小；esize表示对应类型存储所需要的字节数，对于T_BOOLEAN来说，只需要1个字节即可，所以esz为0。最后调用array_layout_helper()方法按照约定组合成一个int类型的数字即可。array_layout_helper()方法的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
 static jint array_layout_helper(jint tag, int hsize, BasicType etype, int log2_esize) {
    return (tag        &amp;lt;&amp;lt; _lh_array_tag_shift)          // 左移30位
      |    (hsize      &amp;lt;&amp;lt; _lh_header_size_shift)        // 左移16位
      |    ((int)etype &amp;lt;&amp;lt; _lh_element_type_shift)       // 左移1位
      |    (log2_esize &amp;lt;&amp;lt; _lh_log2_element_size_shift); // 左移0位
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外还有对_component_mirror属性的设置。对于一维基本类型的数组来说，这个值是java.lang.Class对象。Class对象使用oop对象来表示，调用java_lang_Class::create_basic_type_mirror()方法获取_component_mirror属性的值，通过java_lang_Class::create_mirror()方法完成属性的设置。例如获取boolean类型的属性值，调用语句如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
void Universe::initialize_basic_type_mirrors(TRAPS) {
   ...
   _bool_mirror = java_lang_Class::create_basic_type_mirror(&quot;boolean&quot;,T_BOOLEAN, CHECK);
   ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法create_basic_type_mirror()的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
oop java_lang_Class::create_basic_type_mirror(const char* basic_type_name, BasicType type, TRAPS) {
  // This should be improved by adding a field at the Java level or by
  // introducing a new VM klass (see comment in ClassFileParser)
  oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())-&amp;gt;allocate_instance(NULL, CHECK_0);
  if (type != T_VOID) {
      Klass* aklass = Universe::typeArrayKlassObj(type);
      assert(aklass != NULL, &quot;correct bootstrap&quot;);
      set_array_klass(java_class, aklass); // 设置表示基本类型数组的TypeArrayKlass的
  }
  return java_class;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过InstanceMirrorKlass对象（表示java.lang.Class类）来创建oop（表示java.lang.Class对象），_component_mirror最终设置的就是这个oop。引用类型组成的一维或多维数组的基本元素可以使用Klass对象来表示，如对于下面即将要介绍的Object[]来说，元素类型为Object，所以可以使用InstanceKlass来表示；基本类型组成的一维或多维数组的基本元素没有对应的Klass对象，所以只能使用Class对象来描述boolean、int等类型，这样就会与表示Class对象的oop对象产生关系，相关属性最终的值如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
TypeArrayKlass._component_mirror=oop

oop._array_klass_offset=TypeArrayKlass
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;oop表示java.lang.Class对象，用来描述Java类（包括数组类），而TypeArrayKlass也用来描述Java类（包括数组类），那么2者之间必须会的联系。可以通过_component_mirror属性（和_array_klass_offset属性找到对方，属性的设置过程在在java_lang_Class::create_mirror()函数中进行。&lt;/p&gt;
&lt;p&gt;其它的属性设置很简单，这里不在介绍。 &lt;/p&gt;
&lt;h3&gt;（2）&lt;strong&gt;ObjArrayKlass类&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;ObjArrayKlass是ArrayKlass的子类，用于表示数组元素是类或者数组&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
class ObjArrayKlass : public ArrayKlass {
  ...
 private:
  Klass* _element_klass;            // The klass of the elements of this array type
  Klass* _bottom_klass;             // The one-dimensional type (InstanceKlass or TypeArrayKlass)
  ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该类新增了2个属性，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; _element_klass：数组元素对应的Klass对象，如果是多维数组，对应数组元素的ObjArrayKlass对象&lt;/li&gt;
&lt;li&gt; _bottom_klass：一维数组的类型，可以是InstanceKlass或者TypeArrayKlass。一维基本类型数组为TypeArrayKlass，而二维基本类型数组就会使用ObjArrayKlass来表示，所以其_bottom_klass会是TypeArrayKlass。　&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HotSpot在Universe::genesis()方法中创建Object数组，如下： &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
InstanceKlass* ik = InstanceKlass::cast(SystemDictionary::Object_klass());
_objectArrayKlassObj = ik-&amp;gt;array_klass(1, CHECK); // 调用表示Object类的InstanceKlass类的array_klass()方法
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用array_klass()方法时传递的参数1表示创建一维数组。调用表示Object类的InstanceKlass对象的方法创建的，所以Object数组的创建要依赖于InstanceKlass对象（表示Object类）进行创建。&lt;/p&gt;
&lt;p&gt;传递的参数1表示创建Object的一维数组类型，array_klass()函数及调用的相关函数的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// array class with specific rank
Klass* array_klass(int rank, TRAPS)         {
          return array_klass_impl(false, rank, THREAD);
}

Klass* InstanceKlass::array_klass_impl(bool or_null, int n, TRAPS) {
  instanceKlassHandle  this_oop(THREAD, this);
  return array_klass_impl(this_oop, or_null, n, THREAD);
}

Klass* InstanceKlass::array_klass_impl(instanceKlassHandle this_oop, bool or_null, int n, TRAPS) {
  if (this_oop-&amp;gt;array_klasses() == NULL) { // 获取_array_klasses属性的值
    if (or_null){
        return NULL;
    }
    ResourceMark rm;
    JavaThread *jt = (JavaThread *)THREAD;
    {
      // Atomic creation of array_klasses
      MutexLocker mc(Compile_lock, THREAD);   // for vtables
      MutexLocker ma(MultiArray_lock, THREAD);
      // Check if update has already taken place
      if (this_oop-&amp;gt;array_klasses() == NULL) {
         ClassLoaderData* CLD = this_oop-&amp;gt;class_loader_data();
         Klass*  k = ObjArrayKlass::allocate_objArray_klass(CLD, 1, this_oop, CHECK_NULL);
         this_oop-&amp;gt;set_array_klasses(k); // 设置InstanceKlass::_array_klasses属性的值
      }
    }
  }
  // _this will always be set at this point
  ObjArrayKlass* oak = (ObjArrayKlass*)this_oop-&amp;gt;array_klasses(); // 获取InstanceKlass::_array_klasses属性的值
  if (or_null) {
    return oak-&amp;gt;array_klass_or_null(n);
  }
  return oak-&amp;gt;array_klass(n, CHECK_NULL); // 在创建出一维的引用类型数组后，接着创建n维的引用类型数组
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首次创建ObjTypeKlass时，InstanceKlass::_array_klasses属性的值为NULL，这样就会调用objArrayKlass::allocate_objArray_klass()函数，创建出一维的引用类型数组并保存到了InstanceKlass::_array_klasses属性中。有了一维的引用类型数组后就可以接着调用array_klass()方法创建n维的引用类型数组了。&lt;/p&gt;
&lt;p&gt;（1）创建一维引用类型数组ObjArrayKlass::allocate_objArray_klass()&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;61&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
Klass* ObjArrayKlass::allocate_objArray_klass(
        ClassLoaderData*   loader_data,
        int                n,
        KlassHandle        element_klass,
        TRAPS
) {
  // Eagerly allocate the direct array supertype.
  KlassHandle  super_klass = KlassHandle();
  if (!Universe::is_bootstrapping() || SystemDictionary::Object_klass_loaded()) {
    KlassHandle element_super (THREAD, element_klass-&amp;gt;super());
    if (element_super.not_null()) { // element_super是Object，Object的父类是null
      // The element type has a direct super.  E.g., String[] has direct super of Object[].
      super_klass = KlassHandle(THREAD, element_super-&amp;gt;array_klass_or_null());
      bool supers_exist = super_klass.not_null();
      // Also, see if the element has secondary supertypes.
      // We need an array type for each.
      Array&amp;lt;Klass*&amp;gt;* element_supers = element_klass-&amp;gt;secondary_supers();
      for( int i = element_supers-&amp;gt;length()-1; i &amp;gt;= 0; i-- ) {
        Klass* elem_super = element_supers-&amp;gt;at(i);
        if (elem_super-&amp;gt;array_klass_or_null() == NULL) {
            supers_exist = false;
            break;
        }
      }
      if (!supers_exist) {
        // Oops.  Not allocated yet.  Back out, allocate it, and retry.
        KlassHandle ek;
        {
          MutexUnlocker mu(MultiArray_lock);
          MutexUnlocker mc(Compile_lock);   // for vtables
          Klass* sk = element_super-&amp;gt;array_klass(CHECK_0);
          super_klass = KlassHandle(THREAD, sk);
          for( int i = element_supers-&amp;gt;length()-1; i &amp;gt;= 0; i-- ) {
              KlassHandle  elem_super(THREAD, element_supers-&amp;gt;at(i));
              elem_super-&amp;gt;array_klass(CHECK_0);
          }
          // Now retry from the beginning
          Klass* klass_oop = element_klass-&amp;gt;array_klass(n, CHECK_0);
          // Create a handle because the enclosing brace, when locking
          // can cause a gc.  Better to have this function return a Handle.
          ek = KlassHandle(THREAD, klass_oop);
        }  // re-lock
        return ek();
      }
    } else { // element_super不是Object
        // The element type is already Object.  Object[] has direct super of Object.
        super_klass = KlassHandle(THREAD, SystemDictionary::Object_klass());
    }
  }

  // Create type name for klass.
  Symbol* name = NULL;
  if ( !element_klass-&amp;gt;oop_is_instance() ||
       (name = InstanceKlass::cast(element_klass())-&amp;gt;array_name()) == NULL
  ){
    ResourceMark rm(THREAD);
    char *name_str = element_klass-&amp;gt;name()-&amp;gt;as_C_string();
    int len = element_klass-&amp;gt;name()-&amp;gt;utf8_length();
    char *new_str = NEW_RESOURCE_ARRAY(char, len + 4);
    int idx = 0;
    new_str[idx++] = '[';
    if (element_klass-&amp;gt;oop_is_instance()) { // it could be an array or simple type
       new_str[idx++] = 'L';
    }
    memcpy(&amp;amp;new_str[idx], name_str, len * sizeof(char));
    idx += len;
    if (element_klass-&amp;gt;oop_is_instance()) {
       new_str[idx++] = ';';
    }
    new_str[idx++] = '\0';
    name = SymbolTable::new_permanent_symbol(new_str, CHECK_0);
    if (element_klass-&amp;gt;oop_is_instance()) {
      InstanceKlass* ik = InstanceKlass::cast(element_klass());
      ik-&amp;gt;set_array_name(name);// 设置InstanceKlass::_array_name的属性
    }
  }

  // Initialize instance variables
  ObjArrayKlass* oak = ObjArrayKlass::allocate(loader_data, n, element_klass, name, CHECK_0);

  // Add all classes to our internal class loader list here,
  // including classes in the bootstrap (NULL) class loader.
  // GC walks these as strong roots.
  loader_data-&amp;gt;add_class(oak);

  // Call complete_create_array_klass after all instance variables has been initialized.
  ArrayKlass::complete_create_array_klass(oak, super_klass, CHECK_0);

  return oak;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用的 ObjArrayKlass::allocate()函数的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
ObjArrayKlass* ObjArrayKlass::allocate(ClassLoaderData* loader_data, int n, KlassHandle klass_handle, Symbol* name, TRAPS) {
  assert(ObjArrayKlass::header_size() &amp;lt;= InstanceKlass::header_size(),&quot;array klasses must be same size as InstanceKlass&quot;);
  int x = ObjArrayKlass::header_size();
  int size = ArrayKlass::static_size(x);

  return new (loader_data, size, THREAD) ObjArrayKlass(n, klass_handle, name);
}

int ArrayKlass::static_size(int header_size) {
  // size of an array klass object
  assert(header_size &amp;lt;= InstanceKlass::header_size(), &quot;bad header size&quot;);
  // If this assert fails, see comments in base_create_array_klass.
  header_size = InstanceKlass::header_size();  // 为什么是InstanceKlass的大小？？看ArrayKlass::start_of_vtable()函数有说明
  int    vtable_len = Universe::base_vtable_size(); //  值为5
  int    size = header_size + align_object_offset(vtable_len); // 对vtable_len进行对齐操作
  return align_object_size(size);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ArrayKlass::complete_create_array_klass()函数的实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
// Initialization of vtables and mirror object is done separatly from base_create_array_klass,
// since a GC can happen. At this point all instance variables of the ArrayKlass must be setup.
void ArrayKlass::complete_create_array_klass(ArrayKlass* k, KlassHandle super_klass, TRAPS) {
  ResourceMark rm(THREAD);

  Klass*  curr_superklass = super_klass(); // super_klass是个参数，类型为KlassHandle
  k-&amp;gt;initialize_supers(curr_superklass, CHECK);

  klassVtable* kv = k-&amp;gt;vtable();
  kv-&amp;gt;initialize_vtable(false, CHECK); // 会初始化当前Klass的vtable(含有_length个vtableEntry)

  java_lang_Class::create_mirror(k, Handle(NULL), CHECK);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用initialize_vtalbe()完成虚函数表的初始化，调用java_lang_Class::create_mirror()函数完成当前ObjTypeArray对象对应的java.lang.Class对象的创建并设置了相关属性。&lt;/p&gt;
&lt;p&gt;（2）创建n维引用类型数组ObjArrayKlass::array_klass()&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
Klass* ObjArrayKlass::array_klass_impl(bool or_null, int n, TRAPS) {

  assert(dimension() &amp;lt;= n, &quot;check order of chain&quot;);
  int dim = dimension();
  if (dim == n)
          return this;

  if (higher_dimension() == NULL) {
    if (or_null)
        return NULL;

    ResourceMark rm;
    JavaThread *jt = (JavaThread *)THREAD;
    {
      MutexLocker mc(Compile_lock, THREAD);   // for vtables
      // Ensure atomic creation of higher dimensions
      MutexLocker mu(MultiArray_lock, THREAD);

      // Check if another thread beat us
      if (higher_dimension() == NULL) {

        // Create multi-dim klass object and link them together
        Klass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), dim + 1, this, CHECK_NULL);
        ObjArrayKlass* ak = ObjArrayKlass::cast(k);
        ak-&amp;gt;set_lower_dimension(this);
        OrderAccess::storestore();
        set_higher_dimension(ak);
        assert(ak-&amp;gt;oop_is_objArray(), &quot;incorrect initialization of ObjArrayKlass&quot;);
      }
    }
  } else {
    CHECK_UNHANDLED_OOPS_ONLY(Thread::current()-&amp;gt;clear_unhandled_oops());
  }


  ObjArrayKlass *ak = ObjArrayKlass::cast(higher_dimension());
  if (or_null) {
    return ak-&amp;gt;array_klass_or_null(n);
  }
  return ak-&amp;gt;array_klass(n, CHECK_NULL);
}

Klass* ObjArrayKlass::array_klass_impl(bool or_null, TRAPS) {
  return array_klass_impl(or_null, dimension() +  1, CHECK_NULL);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终表示Object类的InstanceKlass与表示一维数组Object[]的ObjArrayKlass之间的相关属性如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:false;&quot;&gt;
ObjArrayKlass._element_klass=InstanceKlass
ObjArrayKlass._bottom_klass=InstanceKlass 

InstanceKlass._array_name=&quot;[Ljava/lang/Object;&quot;
InstanceKlass._array_klasses=ObjArrayKlass
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ObjArrayKlass中其它的属性设置也并不复杂，这里不在介绍。&lt;/p&gt;
&lt;p&gt;其它参考文章：&lt;/p&gt;
&lt;p&gt;1、&lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13983301.html&quot; target=&quot;_blank&quot;&gt;在Ubuntu 16.04上编译OpenJDK8的源代码（配视频）&lt;/a&gt;  &lt;/p&gt;
&lt;p&gt;2、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13992240.html&quot;&gt;调试HotSpot源代码（配视频）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13222664.html&quot;&gt;HotSpot项目结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/13997925.html&quot;&gt;HotSpot的启动过程（配视频进行源码分析）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/14003295.html&quot;&gt;HotSpot源码分析之C++对象的内存布局&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/14008940.html&quot;&gt;HotSpot源码分析之类模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;7、&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/mazhimazhi/p/14014628.html&quot;&gt;HotSpot类模型之InstanceKlass&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;搭建过程中如果有问题可直接评论留言或加作者微信mazhimazh。&lt;/p&gt;
&lt;p&gt;作者持续维护的个人博客  &lt;a href=&quot;http://classloading.com/&quot; target=&quot;_blank&quot;&gt;classloading.com&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;B站上有HotSpot源码分析相关视频 &lt;a href=&quot;https://space.bilibili.com/27533329&quot;&gt;https://space.bilibili.com/27533329&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关注公众号，有HotSpot源码剖析系列文章！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1236123/202006/1236123-20200630200021532-955264784.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;  &lt;/p&gt;

</description>
<pubDate>Sun, 22 Nov 2020 23:44:00 +0000</pubDate>
<dc:creator>HotSpot-Researcher</dc:creator>
<og:description>上一篇分析了&amp;#160;HotSpot类模型之InstanceKlass&amp;#160;，这次主要分析表示java数组类型的C++类。 1、ArrayKlass类 ArrayKlass继承自Klass，是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mazhimazhi/p/14022630.html</dc:identifier>
</item>
<item>
<title>10 张图聊聊线程的生命周期和常用 APIs - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/14022631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/14022631.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzIzNDQ3MzgxMw==&amp;amp;mid=2247485902&amp;amp;idx=1&amp;amp;sn=0df41b33ce6b32487316f3978c3330fa&amp;amp;chksm=e8f499f4df8310e2b1deb1c2d88e3162c6f722b6ec21269a6958f4020660b142e3435f054989&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;strong&gt;上一篇文章&lt;/strong&gt;&lt;/a&gt;我们聊了多线程的基础内容，比如为什么要使用多线程，线程和进程之间的不同，以及创建线程的 4 种方式。&lt;strong&gt;本文已收录至我的 Github&lt;/strong&gt;: &lt;strong&gt;https://github.com/xiaoqi6666/NYCSDE&lt;/strong&gt;&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天我们来说一下线程的生命周期和常用 APIs：我们需要非常清楚的知道线程的各种状态，比如排查程序运行慢的原因时，就需要看下是不是哪里被阻塞了；另外它也是面试时非常喜欢问的，如果基础内容都答不好，恐怕直接就挂了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文分为两大部分，&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;线程的 6 大状态；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;多线程常用的 APIs：
&lt;ol&gt;&lt;li&gt;
&lt;section&gt;join()&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;wait()&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;notify()&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;yield()&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;sleep()&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;currentThread()&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;getName()&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;getId()&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;getPriority()&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;setPriority()&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;stop()&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;线程状态&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;关于线程的状态，网上各种说法都有，比较流行的是 5 种或者 6 种。关于 5 种状态的那个版本我没有找到理论依据，如果有小伙伴清楚的也欢迎留言指出。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我这里所写的是根据 &lt;code&gt;java.lang.Thread&lt;/code&gt; 的源码，线程有以下 6 大状态：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;enum&lt;/span&gt; State {&lt;br/&gt;NEW,&lt;br/&gt;RUNNABLE,&lt;br/&gt;BLOCKED,&lt;br/&gt;WAITTING,&lt;br/&gt;TIMED_WAITTING,&lt;br/&gt;TERMINATED;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先上图，我们再依次来看。&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1giixvqnaqrj312k0u0qk4.jpg&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1. New&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;A thread that has not yet started is in this state.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;就是指线程刚创建，还没启动的时候，比如刚 &lt;code&gt;new&lt;/code&gt; 了一个 &lt;code&gt;thread&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;MyThread myThread = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MyThread();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. Runnable&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;A thread is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么接下来，自然就是要启动线程了，也就是调用 &lt;code&gt;thread&lt;/code&gt; 的 &lt;code&gt;start()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;myThread.start();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动之后，线程就进入了 &lt;code&gt;Runnable&lt;/code&gt; 状态。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此时所有的线程都会添加到一个等待队列里，等待“CPU 调度”。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果抢占到 CPU 的资源，那就执行；如果没抢到，就等着呗，等当前正在执行的线程完成它能执行的时间片之后，再次抢占。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;要注意这里在等待的一般是&lt;strong&gt;系统资源&lt;/strong&gt;，而不是锁或者其他阻塞。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. Blocked&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;Thread state for a thread blocked waiting for a monitor lock.&lt;br/&gt;A thread in the blocked state is &lt;strong&gt;waiting for a monitor lock to enter a synchronized block/method&lt;/strong&gt; or reenter a synchronized block/method after calling &lt;code&gt;wait()&lt;/code&gt; Object.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里给出了非常明确的 &lt;code&gt;use case&lt;/code&gt;，就是&lt;strong&gt;被锁在外面的才叫阻塞&lt;/strong&gt;。所以这里必须要有至少 2 个线程。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. Waiting&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;A thread in the waiting state is waiting for another thread to perform a particular action.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那具体有哪些原因呢？&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;A thread is in the waiting state due to calling one of the following methods:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;Object.wait with no timeout&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Thread.join with no timeout&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;LockSupport.park&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以说，当调用了&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;code&gt;wait()&lt;/code&gt;，&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;code&gt;join()&lt;/code&gt;，&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;code&gt;park()&lt;/code&gt;&lt;br/&gt;方法之后，线程进入等待状态。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里的等待状态是没有时间限制的，可以无限的等下去... 所以需要有人来&lt;strong&gt;唤醒&lt;/strong&gt;：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;如果是通过 &lt;code&gt;wait()&lt;/code&gt; 进入等待状态的，需要有 &lt;code&gt;notify()&lt;/code&gt; 或者 &lt;code&gt;notifyAll()&lt;/code&gt; 方法来唤醒；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;如果是通过 &lt;code&gt;join()&lt;/code&gt; 进入等待状态的，需要等待目标线程运行结束。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如在&lt;strong&gt;生产者消费者模型&lt;/strong&gt;里，当没有商品的时候，消费者就需要等待，等待生产者生产好了商品发 &lt;code&gt;notify()&lt;/code&gt;。下一篇文章我们会细讲。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. Timed_waiting&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;导致这个状态的原因如下：&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;Thread.sleep&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Object.wait with timeout&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Thread.join with timeout&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;LockSupport.parkNanos&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;LockSupport.parkUntil&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实就是在上一种状态的基础上，给了&lt;strong&gt;具体的时间限制&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么当时间结束后，线程就解放了。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6. Terminated&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;A thread that has exited is in this state.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里有 3 种情况会终止线程：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;执行完所有代码，正常结束；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;强制被结束，比如调用了 &lt;code&gt;stop()&lt;/code&gt; 方法，现在已经被弃用；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;抛出了未捕获的异常。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程一旦死亡就不能复生。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果在一个死去的线程上调用 &lt;code&gt;start()&lt;/code&gt; 方法，那么程序会抛出 &lt;code&gt;java.lang.IllegalThreadStateException&lt;/code&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们说说多线程中常用的 11 个 APIs。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;APIs&lt;/span&gt;&lt;/h2&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1. join()&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;join()&lt;/code&gt; 方法会&lt;strong&gt;强制让该线程执行&lt;/strong&gt;，并且一直会让它执行完。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如上一篇文章的例子是两个线程交替执行的，那么我们这里该下，改成调用&lt;code&gt;小齐线程.join()&lt;/code&gt;，那么效果就是先输出 &lt;code&gt;小齐666&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;5&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyRunnable&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Runnable&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;; i++) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小齐666：&quot;&lt;/span&gt; + i);&lt;br/&gt;}&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;Thread t = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MyRunnable());&lt;br/&gt;t.start();&lt;br/&gt;t.join();&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;; i++) {&lt;br/&gt;System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;主线程&quot;&lt;/span&gt; + i + &lt;span class=&quot;hljs-string&quot;&gt;&quot;：齐姐666&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1giiz5wnn0xj30bu0nk763.jpg&quot; alt=&quot;图2&quot;/&gt;图2
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以 &lt;code&gt;join()&lt;/code&gt; 能够保证某个线程优先执行，而且会一直让它执行完，再回归到公平竞争状态。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;join()&lt;/code&gt; 方法其实是用 &lt;code&gt;wait()&lt;/code&gt; 来实现的，我们来看下这个方法。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. wait() and notify()&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;wait()&lt;/code&gt; 其实并不是 &lt;code&gt;Thread&lt;/code&gt; 类的方法，而是 &lt;code&gt;Object&lt;/code&gt; 里面的方法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法就是让当前对象等待，直到另一个对象调用 &lt;code&gt;notify()&lt;/code&gt; 或者 &lt;code&gt;notifyAll()&lt;/code&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然了，我们也可以设定一个等待时长，到时间之后对象将会自动苏醒。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. yield()&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;yield&lt;/code&gt; 本身的中文意思是屈服，用在这里倒也合适。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;code&gt;yield()&lt;/code&gt; 表示当前线程主动让出 CPU 资源一下，然后我们再一起去抢。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意这里让一下&lt;strong&gt;真的只是一下&lt;/strong&gt;，从“执行中”回到“等待 CPU 分配资源”，然后所有线程再一起抢占资源。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. sleep()&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;顾名思义，这个方法就是让当前线程睡一会，比如说，&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;myThread.sleep(&lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;); &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;它会抛出一个 &lt;code&gt;InterruptedException&lt;/code&gt; 异常，所以还要 &lt;code&gt;try catch&lt;/code&gt; 一下。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6. currentThread()&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;Returns a reference to the currently executing thread object.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法是获取当前线程对象。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意它是一个 &lt;code&gt;static&lt;/code&gt; 方法，所以直接通过 &lt;code&gt;Thread&lt;/code&gt; 类调用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如打印当前线程&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;System.out.println(Thread.currentThread());&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前文的例子中，它会输出：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;Thread[Thread-0,5,main]&lt;br/&gt;Thread[main,5,main]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没错，它的返回值也是 &lt;code&gt;Thread&lt;/code&gt; 类型。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;7. getName()&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法可以获取当前线程名称。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个名称可以自己设置，比如：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;Thread t = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Thread(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MyRunnable(), &lt;span class=&quot;hljs-string&quot;&gt;&quot;壹齐学&quot;&lt;/span&gt;);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;8. getId()&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;该方法是获取线程的 &lt;code&gt;Id&lt;/code&gt;.&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;9. getPriority()&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;线程也有优先级的哦～&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然优先级高的线程并不能百分百保证一定会先执行，但它是有更大的概率被先执行的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;优先级的范围是 &lt;code&gt;1-10&lt;/code&gt;，我们来看源码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;4&quot;&gt;    &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; MIN_PRIORITY = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; NORM_PRIORITY = &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; MAX_PRIORITY = &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不在这个范围，JDK 抛出 &lt;code&gt;IllegalArgumentException()&lt;/code&gt; 的异常。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;10. setPriority()&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然啦，我们也是可以自己设置某个线程的优先级的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;设置的优先级也需要在规定的 &lt;code&gt;1-10&lt;/code&gt; 的范围内哦，如果不在这个范围也会抛异常。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;11. stop()&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们来说下 &lt;code&gt;stop()&lt;/code&gt; 方法，也是前文提到过的强制停止线程的一种方式，但现在已被弃用，因为会引起一些线程安全方面的问题。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好了，以上就是有关线程状态和常用 API 的介绍了。相信大家看完之后对线程的整个流程应该有了清晰的认识，其实里面还有很多细节我没有展开，毕竟这是多线程的第 2 讲，更深入的内容我们慢慢来。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你喜欢这篇文章，记得给我点赞留言哦～你们的支持和认可，就是我创作的最大动力，我们下篇文章见！&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我是小齐，纽约程序媛，终生学习者，每天晚上 &lt;strong&gt;9&lt;/strong&gt; 点，云自习室里不见不散！&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**更多干货文章见我的 &lt;strong&gt;Github&lt;/strong&gt;: &lt;strong&gt;https://github.com/xiaoqi6666/NYCSDE&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 22 Nov 2020 23:42:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>上一篇文章我们聊了多线程的基础内容，比如为什么要使用多线程，线程和进程之间的不同，以及创建线程的 4 种方式。本文已收录至我的 Github: https://github.com/xiaoqi666</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/14022631.html</dc:identifier>
</item>
<item>
<title>Spring Cloud实战 | 最八篇：Spring Cloud +Spring Security OAuth2+ Axios前后端分离模式下无感刷新实现JWT续期 - 你好，旧时光</title>
<link>http://www.cnblogs.com/haoxianrui/p/14022632.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haoxianrui/p/14022632.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;34&quot;&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/oUEmhBeAlgpZ1WH.gif&quot; class=&quot;desc_img&quot;/&gt;项目中如何通过前后端配合利用双token刷新实现JWT续期的功能需求，后端抛出token过期异常，前端捕获之后调用刷新token请求，成功则完成续期，失败（一般指refresh_token也过期了）则需要重新登录。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;158.01374141162&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/oUEmhBeAlgpZ1WH.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;记得上一篇Spring Cloud的文章关于如何使JWT失效进行了理论结合代码实践的说明，想当然的以为那篇会是基于Spring Cloud统一认证架构系列的最终篇。但关于JWT另外还有一个热议的话题是&lt;strong&gt;JWT续期？&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;本篇就个人觉得比较好的JWT续期方案以及落地和大家分享一下，算是抛转引玉，大家有好的方案欢迎留言哈。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;后端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13581881.html&quot;&gt;Spring Cloud实战 | 第一篇：Windows搭建Nacos服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13584204.html&quot;&gt;Spring Cloud实战 | 第二篇：Spring Cloud整合Nacos实现注册中心&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13585125.html&quot;&gt;Spring Cloud实战 | 第三篇：Spring Cloud整合Nacos实现配置中心&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13608650.html&quot;&gt;Spring Cloud实战 | 第四篇：Spring Cloud整合Gateway实现API网关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13615592.html&quot;&gt;Spring Cloud实战 | 第五篇：Spring Cloud整合OpenFeign实现微服务之间的调用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13719356.html&quot;&gt;Spring Cloud实战 | 第六篇：Spring Cloud Gateway+Spring Security OAuth2+JWT实现微服务统一认证授权&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13740264.html&quot;&gt;Spring Cloud实战 | 最七篇：Spring Cloud Gateway+Spring Security OAuth2集成统一认证授权平台下实现注销使JWT失效方案&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13740264.html&quot;&gt;Spring Cloud实战 | 最八篇：Spring Cloud +Spring Security OAuth2+ Axios前后端分离模式下无感刷新实现JWT续期&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;管理前端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13624548.html&quot;&gt;vue-element-admin实战 | 第一篇： 移除mock接入后台，搭建有来商城youlai-mall前后端分离管理平台&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13676619.html&quot;&gt;vue-element-admin实战 | 第二篇： 最小改动接入后台实现根据权限动态加载菜单&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote&gt;
&lt;p&gt;微信小程序&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/haoxianrui/p/13882310.html&quot;&gt;vue+uniapp商城实战 | 第一篇：【有来小店】微信小程序快速开发接入Spring Cloud OAuth2认证中心完成授权登录&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;理论背景：&lt;/strong&gt; 在 &lt;a href=&quot;https://github.com/hxrui/youlai-mall.git&quot;&gt;&lt;strong&gt;++有来商城++&lt;/strong&gt;&lt;/a&gt; 微服务项目 OAuth2实现微服务的统一认证的背景下，前端调用/oauth/token接口认证，在认证成功会返回两个令牌access_token和refresh_token，出于安全考虑access_token时效相较refresh_token短很多（access_token默认12小时,refresh_token默认30天）。当access_token过期或者将要过期时，需要拿refresh_token去刷新获取新的access_token返回给客户端，但是为了客户良好的体验需要做到无感知刷新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;浏览器起一个定时轮询任务，每次在access_token过期之前刷新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案二：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求时返回access_token过期的异常时，浏览器发出一次使用refresh_token换取access_token的请求，获取到新的access_token之后，重试因access_token过期而失败的请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案比较：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;++第一种方案++&lt;/span&gt;实现简单，但在access_token过期之前刷新，那些旧access_token依然能够有效访问，如果使用黑名单的方式限制这些就的access_token无疑是在浪费资源。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;++第二种方案++&lt;/span&gt;是在access_token已经失效的情况下才去刷新便不会有上面的问题，但是它会多出来一次请求，而且实现起来考虑的问题相较下比较多，例如在token刷新阶段后面来的请求如何处理，等获取到新的access_token之后怎么重新重试这些请求。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结：&lt;/span&gt;第一种方案实现简单；第二种方案更为严谨，过期续期不会造成已被刷掉的access_token还有效；总之两者都是可行方案，本篇就第二种方案如何通过前后端的配合实现无感知刷新token实现JWT续期展开说明。&lt;/p&gt;

&lt;p&gt;直接进入主题，如何通过代码实现在access_token过期时使用refresh_token刷新续期，本篇涉及代码基于Spring Cloud后端&lt;a href=&quot;https://github.com/hxrui/youlai-mall.git&quot;&gt;&lt;strong&gt;++youlai-mall++&lt;/strong&gt;&lt;/a&gt; 和 Vue前端 &lt;a href=&quot;https://github.com/hxrui/youlai-mall-admin.git&quot;&gt;&lt;strong&gt;++youlai-mall-admin++&lt;/strong&gt;&lt;/a&gt;，需要的小伙伴可以下载到本地参考下，如果对你有帮助，也希望给个star,感谢~&lt;/p&gt;
&lt;h2 id=&quot;后端&quot;&gt;后端&lt;/h2&gt;
&lt;p&gt;后端部分这里唯一工作是在网关youlai-gateway鉴定access_token过期时抛出一个自定义异常提供给前端判定，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/Y2jLFHxa6ORSloe.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小伙伴们在这里也许会有疑问，网关这里如何判断JWT是否已过期？先不急，下文会说明，先看实现之后再说原理。&lt;/p&gt;
&lt;h2 id=&quot;前端&quot;&gt;前端&lt;/h2&gt;
&lt;h3 id=&quot;1-oauth2客户端设置&quot;&gt;1. OAuth2客户端设置&lt;/h3&gt;
&lt;p&gt;设置OAuth2客户端支持刷新模式,只有这样才能使用refresh_token刷新换取新的access_token。以及为了方便我们测试分别设置access_token和refresh_token的过期时间，因为默认的12小时和30天我们吃不消的；除此之外，还必须满足t(refresh_token) &amp;gt; 60s + t(access_token)的条件， refresh_token的时效大于access_token时效我们可以理解，那这个60s是怎么回事，别急还是先看实现，原因下文会说明。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/qBsFPIlw6Sp5CnG.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-添加刷新令牌方法&quot;&gt;2. 添加刷新令牌方法&lt;/h3&gt;
&lt;p&gt;设置了支持客户端刷新模式之后，在前端添加一个refreshToken方法，调用的接口和登录认证是同一个接口/oauth/token,只是参数授权方式grant_type的值由password切换到refresh_token，即密码模式切换到刷新模式，这个方法作用是在刷新token之后将新的token写入到localStorage覆盖旧的token。&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/g7WfsvialEXhDIo.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;3-请求响应拦截添加令牌过期处理&quot;&gt;3. 请求响应拦截添加令牌过期处理&lt;/h3&gt;
&lt;p&gt;在判断响应结果是token过期时，执行刷新令牌方法覆盖本地的token。&lt;/p&gt;
&lt;p&gt;在刷新&lt;span&gt;期间&lt;/span&gt;需做到两点，一是避免重复刷新，二是请求重试，为了满足以上两点添加了两个关键变量：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;refreshing&lt;/strong&gt;----刷新标识&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在第一次access_token过期请求失败时，调用刷新token请求时开启此标识，标识当前正在刷新中，避免后续请求因token失效重复刷新。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;waitQueue&lt;/strong&gt;----请求等待队列&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当执行刷新token期间时，需要把后来的请求先缓存到等待队列，在刷新token成功时，重新执行等待队列的请求即可。&lt;/p&gt;
&lt;p&gt;修改请求响应封装request.js的代码如下，关键部分使用注释说明，完整工程 &lt;a href=&quot;https://github.com/hxrui/youlai-mall-admin.git&quot;&gt;&lt;strong&gt;++youlai-mall-admin++&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;let refreshing = false,// 正在刷新标识，避免重复刷新
  waitQueue = [] // 请求等待队列

service.interceptors.response.use(
  response =&amp;gt; {
    const {code, msg, data} = response.data
    if (code !== '00000') {
      if (code === 'A0230') { // access_token过期 使用refresh_token刷新换取access_token
        const config = response.config
        if (refreshing == false) {
          refreshing = true
          const refreshToken = getRefreshToken()
          return store.dispatch('user/refreshToken', refreshToken).then((token) =&amp;gt; {
            config.headers['Authorization'] = 'Bearer ' + token
            config.baseURL = '' // 请求重试时，url已包含baseURL
            waitQueue.forEach(callback =&amp;gt; callback(token)) // 已刷新token，所有队列中的请求重试
            waitQueue = []
            return service(config)
          }).catch(() =&amp;gt; { // refresh_token也过期，直接跳转登录页面重新登录
            MessageBox.confirm('当前页面已失效，请重新登录', '确认退出', {
              confirmButtonText: '重新登录',
              cancelButtonText: '取消',
              type: 'warning'
            }).then(() =&amp;gt; {
              store.dispatch('user/resetToken').then(() =&amp;gt; {
                location.reload()
              })
            })
          }).finally(() =&amp;gt; {
            refreshing = false
          })
        } else {
          // 正在刷新token，返回未执行resolve的Promise,刷新token执行回调
          return new Promise((resolve =&amp;gt; {
            waitQueue.push((token) =&amp;gt; {
              config.headers['Authorization'] = 'Bearer ' + token
              config.baseURL = '' // 请求重试时，url已包含baseURL
              resolve(service(config))
            })
          }))
        }
      } else {
        Message({
          message: msg || '系统出错',
          type: 'error',
          duration: 5 * 1000
        })
      }
    }
    return {code, msg, data}
  },
  error =&amp;gt; {
    return Promise.reject(error)
  }
)
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;完成上面前后端代码调整之后，接下来进入测试，还记得上面设置access_token时效为1s、refresh_token为120s吧。这里access_token设置为1s，但是时效确是61s，至于原因下文细说。这里把测试根据时间分为3个阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;0~61s：双token都没过期，正常请求过程。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/EPU5rkCgAq3JYRw.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;strong&gt;61s~120s：access_token过期，再次请求会执行一次刷新请求。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/TvXE28hmV5RI4b1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/gnOrV9EtIwTisZ4.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;strong&gt;120s+： refresh_token过期，神仙都救不了，重新登录。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/BmtkUp1TfEbghIy.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;声明：&lt;/strong&gt; 问题基于&lt;a href=&quot;https://github.com/hxrui/youlai-mall.git&quot;&gt;&lt;strong&gt;++youlai-mall++&lt;/strong&gt;&lt;/a&gt;项目使用的nimbus-jose-jwt这个JWT库，依赖spring-security-oauth2-jose这个jar包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 如何判定JWT过期？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;JWT的是否过期判断最终落点是在JwtTimestampValidator#validate方法上&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.为什么access_token比设定多了60s时效？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;开挂？有后台？向天再借60s？&lt;/p&gt;
&lt;p&gt;刚开始在不知情的情况下以为自己哪里配置错了，设置5s过期，等个1min多钟。后来确实没办法决心去调试下源码，最后找到JWT验证过期的方法JwtTimestampValidator#validate&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2020/11/22/Fur6ghT4xCEAcGB.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本上满足 &lt;code&gt;Instant.now(this.clock).minus(this.clockSkew).isAfter(expiry)&lt;/code&gt; 就说明JWT过期了&lt;/p&gt;
&lt;p&gt;now - 60s &amp;gt; expiry &lt;span&gt;&lt;strong&gt;=转换=&amp;gt;&lt;/strong&gt;&lt;/span&gt; now &amp;gt; expiry + 60s&lt;/p&gt;
&lt;p&gt;按正常理解当前时间大于过期时间就可判定为过期，但这里却在过期时间加了个时钟偏移60s，活生生的延长了一分钟，至于为什么？没找到说明文档，注释也没说明，知道的小伙伴欢迎下方留言~&lt;/p&gt;

&lt;p&gt;本篇讲述 &lt;a href=&quot;https://github.com/hxrui/youlai-mall.git&quot;&gt;&lt;strong&gt;++youlai-mall++&lt;/strong&gt;&lt;/a&gt; 项目中如何通过前后端配合利用双token刷新实现JWT续期的功能需求，后端抛出token过期异常，前端捕获之后调用刷新token请求，成功则完成续期，失败（一般指refresh_token也过期了）则需要重新登录。在代码的实现过程中了解到在资源服务器（youlai-gateway）如何判断JWT是否过期、axios如何进行请求重试等一些问题。&lt;/p&gt;
&lt;p&gt;最后说一下自己的项目，&lt;a href=&quot;https://github.com/hxrui/youlai-mall.git&quot;&gt;&lt;strong&gt;++youlai-mall++&lt;/strong&gt;&lt;/a&gt; 集成当前&lt;span&gt;主流开发模式&lt;/span&gt;微服务加前后端分离，当前&lt;span&gt;最新主流技术栈&lt;/span&gt; Spring Cloud + Spring Cloud Alibaba + Vue , 以及&lt;span&gt;最流行统一认证授权&lt;/span&gt;Spring Cloud Gateway + Spring Security OAuth2 + JWT。所以觉得本文对你有所帮助的话给个关注（持续更新中...），或者对该项目感兴趣的小伙伴给个star，也期待你的加入和建议，还是老样子有问题随时联系我~（微信号：haoxianrui）。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 22 Nov 2020 23:42:00 +0000</pubDate>
<dc:creator>你好，旧时光</dc:creator>
<og:description>一. 前言 记得上一篇Spring Cloud的文章关于如何使JWT失效进行了理论结合代码实践的说明，想当然的以为那篇会是基于Spring Cloud统一认证架构系列的最终篇。但关于JWT另外还有一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haoxianrui/p/14022632.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core使用HostingStartup增强启动操作 - yi念之间</title>
<link>http://www.cnblogs.com/wucy/p/14013622.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wucy/p/14013622.html</guid>
<description>&lt;h4 id=&quot;概念&quot;&gt;概念&lt;/h4&gt;
&lt;p&gt;    在ASP.NET Core中我们可以使用一种机制来增强启动时的操作，它就是HostingStartup。如何叫&quot;增强&quot;操作，相信了解过AOP概念的同学应该都非常的熟悉。我们常说AOP使用了关注点分离的方式，增强了对现有逻辑的操作。而我们今天要说的HostingStartup就是为了&quot;增强&quot;启动操作，这种&quot;增强&quot;的操作甚至可以对现有的程序可以做到无改动的操作。例如，外部程序集可通过HostingStartup实现为应用提供配置服务、注册服务或中间件管道操作等。&lt;/p&gt;
&lt;h4 id=&quot;使用方式&quot;&gt;使用方式&lt;/h4&gt;
&lt;p&gt;    HostingStartup属性表示要在运行时激活的承载启动程序集。大致分为两种情况，一种是自动扫描当前Web程序集中通过HostingStartup指定的类，另一种是手动添加配置hostingstartupassembles指定外部的程序集中通过HostingStartup指定的类。第一种方式相对简单，但是对Web程序本身有入侵，第二种方式稍微复杂一点点，但是可以做到对现有代码无入侵操作，接下来我们分别演示这两种使用方式。&lt;/p&gt;
&lt;h5 id=&quot;aspnet-core中直接定义&quot;&gt;ASP.NET Core中直接定义&lt;/h5&gt;
&lt;p&gt;首先是在ASP.NET Core程序中直接使用HostingStartup,这种方式比较简单首先在Web程序中随便定义一个类,然后实现IHostingStartup接口，最后别忘了在程序集中添加HostingStartupAttribute指定要启动的类的类型，具体代码如下所示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Collections.Generic;
using System.Diagnostics;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
//通过HostingStartup指定要启动的类型
[assembly: HostingStartup(typeof(HostStartupWeb.HostingStartupInWeb))]
namespace HostStartupWeb
{
    public class HostingStartupInWeb : IHostingStartup
    {
        public void Configure(IWebHostBuilder builder)
        {
            //程序启动时打印依据话，代表执行到了这里
            Debug.WriteLine(&quot;Web程序中HostingStartupInWeb类启动&quot;);

            //可以添加配置
            builder.ConfigureAppConfiguration(config =&amp;gt; {
                //模拟添加一个一个内存配置
                var datas = new List&amp;lt;KeyValuePair&amp;lt;string, string&amp;gt;&amp;gt;
                {
                    new KeyValuePair&amp;lt;string, string&amp;gt;(&quot;ServiceName&quot;, &quot;HostStartupWeb&quot;)
                };
                config.AddInMemoryCollection(datas);
            });

            //可以添加ConfigureServices
            builder.ConfigureServices(services=&amp;gt; {
                //模拟注册一个PersonDto
                services.AddScoped(provider=&amp;gt;new PersonDto { Id = 1, Name = &quot;yi念之间&quot;, Age = 18 });
            });

            //可以添加Configure
            builder.Configure(app =&amp;gt; {
                //模拟添加一个中间件
                app.Use(async (context, next) =&amp;gt;
                {
                    await next();
                });
            });
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅仅使用上面所示的这些代码，便可在Web程序启动的时候去自动执行HostingStartupInWeb的Configure方法，在这里面我们几乎可以使用所有针对ASP.NET Core程序配置的操作，而且不需要在Web程序中额外添加别的代码就可以自动调用HostingStartupInWeb的Configure方法。&lt;/p&gt;
&lt;h5 id=&quot;外部程序集引入&quot;&gt;外部程序集引入&lt;/h5&gt;
&lt;p&gt;我们之前也说过，上面的方式虽然使用起来相对简单一点，仅仅是一点，那就是省去了指定启动程序集的逻辑。但是，上面的方式需要在Web程序中添加，这样的话还是会修改代码。而且，可能更多的时候我们是在外部的程序集中编写HostingStartup逻辑，这时候就需要使用另一种方式在将外部程序集中引入HostingStartup。首先我们要在自定义的程序集中至少引入Microsoft.AspNetCore.Hosting包才能使用HostingStartup&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.Hosting&quot; Version=&quot;2.2.7&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你不需要使用注册中间件的逻辑那么仅仅引入Microsoft.AspNetCore.Hosting.Abstractions即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;PackageReference Include=&quot;Microsoft.AspNetCore.Hosting.Abstractions&quot; Version=&quot;2.2.0&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果需要使用其他功能包，可以自行在定义的程序集中引入。比如我们定义了一个名为HostStartupLib的Standard类库，并创建了名为HostStartupLib的类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;
using System.Collections.Generic;
using System.Diagnostics;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
[assembly: HostingStartup(typeof(HostStartupLib.HostingStartupInLib))]
namespace HostStartupLib
{
    public class HostingStartupInLib : IHostingStartup
    {
        public void Configure(IWebHostBuilder builder)
        {
            Debug.WriteLine(&quot;Lib程序中HostingStartupInLib类启动&quot;);

            //添加配置
            builder.ConfigureAppConfiguration((context, config) =&amp;gt; {
                var datas = new List&amp;lt;KeyValuePair&amp;lt;string, string&amp;gt;&amp;gt;
                {
                    new KeyValuePair&amp;lt;string, string&amp;gt;(&quot;ServiceName&quot;, &quot;HostStartupLib&quot;)
                };
                config.AddInMemoryCollection(datas);
            });

            //添加ConfigureServices
            builder.ConfigureServices(services=&amp;gt; {
                services.AddScoped(provider=&amp;gt;new PersonDto { Id = 2, Name = &quot;er念之间&quot;, Age = 19 });
            });

            //添加Configure
            builder.Configure(app =&amp;gt; {
                app.Use(async (context, next) =&amp;gt;
                {
                    await next();
                });
            });

        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们将自定义的HostStartupLib这个Standard类库引入Web项目中，运行Web程序，发现HostingStartupInLib的Configure方法并不能被调用。其实我们上面说过了，将HostingStartup从外部程序集引入的话需要手动指定启动程序集的名称。指定启动程序集的方式有两种，一种是指定IWebHostBuilder的扩展UseSetting指定&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&amp;gt;
                {
                    //通过UseSetting的方式指定程序集的名称
                    webBuilder.UseSetting(WebHostDefaults.HostingStartupAssembliesKey, &quot;HostStartupLib&quot;);
                    //如果HostingStartup存在多个程序集中可以使用;分隔,比如HostStartupLib;HostStartupLib2
                    //webBuilder.UseSetting(WebHostDefaults.HostingStartupAssembliesKey, &quot;HostStartupLib;HostStartupLib2&quot;);
                    webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
                });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另一种通过添加环境变量ASPNETCORE_HOSTINGSTARTUPASSEMBLIES的方式，可以通过设置launchSettings.json中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;&quot;environmentVariables&quot;: {
        &quot;ASPNETCORE_HOSTINGSTARTUPASSEMBLIES&quot;: &quot;HostStartupLib&quot;
        //如果HostingStartup存在多个程序集中可以使用;分隔,比如HostStartupLib;HostStartupLib2
        //&quot;ASPNETCORE_HOSTINGSTARTUPASSEMBLIES&quot;: &quot;HostStartupLib;HostStartupLib2&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    可以引入多个包含HostingStartup的程序集，在设置WebHostDefaults.HostingStartupAssembliesKey或者ASPNETCORE_HOSTINGSTARTUPASSEMBLIES指定多个程序集名称可以使用英文分号(;)隔开程序集名称。虽然是两种形似指定，但是其实本质是一样的那就是设置配置key为hostingStartupAssemblie配置的值，下面我们会详细讲解。&lt;br/&gt;    通过在程序中设置环境变量的方式等同于Window系统中Set的方式设置环境变量，或Linux系统中export的方式设置环境变量，亦或是直接设置系统环境变量，效果都是一致的。指定完成启动程序集之后，再次运行程序便可以看到HostingStartupInLib的Configure方法被调用到了。在这里我们可以看到&lt;span&gt;如果是使用的环境变量的方式去指定启动程序集的话，对现有代码可以做到完全无入侵。&lt;/span&gt;&lt;/p&gt;
&lt;h4 id=&quot;源码探究&quot;&gt;源码探究&lt;/h4&gt;
&lt;p&gt;在上面我们简单的介绍了HostingStartup的概念及基本的使用方式，基于这些我们产生了几个疑问&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是关于HostingStartup的基本工作方式是什么&lt;/li&gt;
&lt;li&gt;其次是为什么HostingStartup在Web程序中不需要配置程序集信息就可以被调用到，而通过外部程序集引入HostingStartup需要手动指定程序集&lt;/li&gt;
&lt;li&gt;最后是通过外部程序集引入HostingStartup的指定方式为何只能是UseSetting和环境变量的方式&lt;br/&gt;基于以上几个疑问，我们来探索一下HostingStartup的相关源码，来揭开它的神秘面纱。首先废话不多说直接找到源码位置[&lt;a href=&quot;https://github.com/dotnet/aspnetcore/blob/v5.0.0/src/Hosting/Hosting/src/GenericHost/GenericWebHostBuilder.cs#L123&quot;&gt;点击查看源码👈&lt;/a&gt;]在GenericWebHostBuilder类中的ExecuteHostingStartups方法中，关于GenericWebHostBuilder类我们在上篇文章&lt;a href=&quot;https://www.cnblogs.com/wucy/p/13886728.html&quot;&gt;深入探究ASP.NET Core Startup初始化&lt;/a&gt;中主要就是分析这个类，因为这是构建WebHost的默认类，而我们接下来要说的ExecuteHostingStartups方法也是承载在这个类中，直接贴代码如下所示&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;private void ExecuteHostingStartups()
{
    //通过配置_config和当前程序集名称构建WebHostOptions类
    var webHostOptions = new WebHostOptions(_config, Assembly.GetEntryAssembly()?.GetName().Name);
    //如果PreventHostingStartup属性为true则直接返回
    //通过这个可以配置阻止启动逻辑
    if (webHostOptions.PreventHostingStartup)
    {
        return;
    }

    var exceptions = new List&amp;lt;Exception&amp;gt;();
    //构建HostingStartupWebHostBuilder
    _hostingStartupWebHostBuilder = new HostingStartupWebHostBuilder(this);
    //GetFinalHostingStartupAssemblies获取最终要执行的程序集名称
    foreach (var assemblyName in webHostOptions.GetFinalHostingStartupAssemblies().Distinct(StringComparer.OrdinalIgnoreCase))
    {
        try
        {
            //通过程序集名称加载程序集信息，因为使用了AssemblyName所以只需要使用程序集名称即可
            var assembly = Assembly.Load(new AssemblyName(assemblyName));
            //获取包含HostingStartupAttribute的程序集
            foreach (var attribute in assembly.GetCustomAttributes&amp;lt;HostingStartupAttribute&amp;gt;())
            {
                //实例化HostingStartupAttribute的HostingStartupType属性的对象实例
                //即我们上面声明的[assembly: HostingStartup(typeof(HostStartupWeb.HostingStartupInWeb))]
                var hostingStartup = (IHostingStartup)Activator.CreateInstance(attribute.HostingStartupType);
                //调用HostingStartup的Configure方法
                hostingStartup.Configure(_hostingStartupWebHostBuilder);
            }
        }
        catch (Exception ex)
        {
            exceptions.Add(new InvalidOperationException($&quot;Startup assembly {assemblyName} failed to execute. See the inner exception for more details.&quot;, ex));
        }
    }

    if (exceptions.Count &amp;gt; 0)
    {
        _hostingStartupErrors = new AggregateException(exceptions);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    通过上面的源码我们就可以很清楚的了解到HostingStartup的基本工作方式。获取的程序集中包含的HostingStartupAttribute，通过获取HostingStartupAttribute的HostingStartupType属性得到要执行的IHostingStartup实例，最后执行Configure方法，Configure方法需要传递IWebHostBuilder的实例，而HostingStartupWebHostBuilder正是实现了IWebHostBuilder接口。&lt;br/&gt;    我们了解到了HostStartup的工作方式，接下来我们来探究一下为什么HostingStartup在Web程序中不需要配置程序集信息就可以被调用到，而通过外部程序集引入HostingStartup需要手动指定程序集。通过上面的源码我们可以得到一个信息那就是所有需要启动的程序集信息都是来自WebHostOptions的GetFinalHostingStartupAssemblies方法，接下来我们就来查看一下GetFinalHostingStartupAssemblies方法的实现源码[&lt;a href=&quot;https://github.com/dotnet/aspnetcore/blob/v5.0.0/src/Hosting/Hosting/src/Internal/WebHostOptions.cs#L72&quot;&gt;点击查看源码👈&lt;/a&gt;]&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public IEnumerable&amp;lt;string&amp;gt; GetFinalHostingStartupAssemblies()
{
    return HostingStartupAssemblies.Except(HostingStartupExcludeAssemblies, StringComparer.OrdinalIgnoreCase);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这里我们可以看出程序集信息来自于HostingStartupAssemblies属性，而且还要排除掉HostingStartupExcludeAssemblies包含的程序集。我们找到他们初始化的相关逻辑大致如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;//承载启动是需要调用的HostingStartup程序集
public IReadOnlyList&amp;lt;string&amp;gt; HostingStartupAssemblies { get; set; }
//承载启动时排除掉不不要执行的程序集
public IReadOnlyList&amp;lt;string&amp;gt; HostingStartupExcludeAssemblies { get; set; }
//是否阻止HostingStartup启动执行功能，如果设置为false则HostingStartup功能失效
//通过上面的ExecuteHostingStartups方法源码可知
public bool PreventHostingStartup { get; set; }
//应用程序名称
public string ApplicationName { get; set; }

public WebHostOptions(IConfiguration configuration, string applicationNameFallback)
{
    ApplicationName = configuration[WebHostDefaults.ApplicationKey] ?? applicationNameFallback;
    HostingStartupAssemblies = Split($&quot;{ApplicationName};{configuration[WebHostDefaults.HostingStartupAssembliesKey]}&quot;);
    HostingStartupExcludeAssemblies = Split(configuration[WebHostDefaults.HostingStartupExcludeAssembliesKey]);
    PreventHostingStartup = WebHostUtilities.ParseBool(configuration, WebHostDefaults.PreventHostingStartupKey);
}

//分隔配置的程序集信息,分隔依据为&quot;;&quot;分号,这也是我们上面说过配置多程序集的时候采用分号分隔的原因
private IReadOnlyList&amp;lt;string&amp;gt; Split(string value)
{
    return value?.Split(';', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries)
        ?? Array.Empty&amp;lt;string&amp;gt;();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    &lt;span&gt;首先,通过HostingStartupAssemblies的初始化逻辑我们可以得出，默认会是有两个数据来源，一个是当前的ApplicationName，另一个是通过HostingStartupAssembliesKey配置的程序集信息。这也解答了我们上面说过的为什么HostingStartup在Web程序中不需要配置程序集信息就可以被调用到，而通过外部程序集引入HostingStartup需要手动指定程序集。&lt;/span&gt;其次,我们可以了解到通过配置HostingStartupExcludeAssemblies信息排除你不想启动的HostingStartup程序集，而且还可以通过配置PreventHostingStartup值来禁止使用HostingStartup的功能。&lt;br/&gt;通过上面的代码我们还了解到这三个属性的来源的配置名称都是来自WebHostDefaults这个常量类，接下来我们查看一下这三个属性对应的配置名称&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public static readonly string HostingStartupAssembliesKey = &quot;hostingStartupAssemblies&quot;;
public static readonly string HostingStartupExcludeAssembliesKey = &quot;hostingStartupExcludeAssemblies&quot;;
public static readonly string PreventHostingStartupKey = &quot;preventHostingStartup&quot;;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，我们可以可以通过配置这三个名称的配置，来完成HostingStartup相关的功能比如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
            Host.CreateDefaultBuilder(args)
                .ConfigureWebHostDefaults(webBuilder =&amp;gt;
                {
                    //通过UseSetting的方式指定程序集的名称
                    webBuilder.UseSetting(WebHostDefaults.HostingStartupAssembliesKey, &quot;HostStartupLib&quot;);
                    //如果HostingStartup存在多个程序集中可以使用;分隔,比如HostStartupLib;HostStartupLib2
                    //webBuilder.UseSetting(WebHostDefaults.HostingStartupAssembliesKey, &quot;HostStartupLib;HostStartupLib2&quot;);

                    //排除执行HostStartupLib2程序集执行HostingStartup逻辑
                    webBuilder.UseSetting(WebHostDefaults.HostingStartupExcludeAssembliesKey, &quot;HostStartupLib2&quot;);
                    //禁用HostingStartup功能
                    webBuilder.UseSetting(WebHostDefaults.PreventHostingStartupKey, &quot;true&quot;);
                    webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
                });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或通过环境变量的方式去操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;&quot;environmentVariables&quot;: {
        &quot;ASPNETCORE_HOSTINGSTARTUPASSEMBLIES&quot;: &quot;HostStartupLib&quot;,
        //如果HostingStartup存在多个程序集中可以使用;分隔,比如HostStartupLib;HostStartupLib2
        //&quot;ASPNETCORE_HOSTINGSTARTUPASSEMBLIES&quot;: &quot;HostStartupLib;HostStartupLib2&quot;

       //排除执行HostStartupLib2程序集执行HostingStartup逻辑
       &quot;ASPNETCORE_HOSTINGSTARTUPEXCLUDEASSEMBLIES&quot;：&quot;HostStartupLib2&quot;,
       //禁用HostingStartup功能
       &quot;ASPNETCORE_PREVENTHOSTINGSTARTUP&quot;:&quot;true&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;其实这两种配置方式是完全等价的，为什么这么说呢？首先是在Configuration中获取配置是忽略大小写的，其实是使用ConfigureWebHostDefaults配置WebHost相关信息的时候会添加configBuilder.AddEnvironmentVariables(prefix: &quot;ASPNETCORE_&quot;)逻辑这样的话获取环境变量的时候可以忽略ASPNETCORE_前缀。&lt;/span&gt;&lt;br/&gt;那么到目前为止，还有一个疑问尚未解决，那就是为何只能通过UseSetting和环境变量的方式去配置HostingStartup相关配置，解铃还须系铃人，我们在上面的ExecuteHostingStartups方法中看到了这个逻辑&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;//这里传递了一个_config
var webHostOptions = new WebHostOptions(_config, Assembly.GetEntryAssembly()?.GetName().Name);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到传递了配置Configuration的实例_config，我们到初始化_config地方有如下逻辑&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var configBuilder = new ConfigurationBuilder()
                .AddInMemoryCollection();
if (!options.SuppressEnvironmentConfiguration)
{
    //添加环境变量
    configBuilder.AddEnvironmentVariables(prefix: &quot;ASPNETCORE_&quot;);
}
//构建了_config实例
private readonly IConfiguration _config = configBuilder.Build();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就可以解释为何我们可以通过环境变量去配置HostingStartup，然后我们再来看UseSetting方法的逻辑&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public IWebHostBuilder UseSetting(string key, string value)
{
    _config[key] = value;
    return this;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原来UseSetting也是给_config实例设置值，所以无论通过UseSetting或环境环境变量的方式去配置，本质都是在操作_config这个配置实例，到此为止所有谜团均以解开。&lt;/p&gt;
&lt;h4 id=&quot;在skyapm中的使用&quot;&gt;在SkyAPM中的使用&lt;/h4&gt;
&lt;p&gt;我们上面说了HostingStartup可以增强启动时候的操作，可以通过对现有代码无入侵的方式增强程序功能。而&lt;a href=&quot;https://github.com/SkyAPM/SkyAPM-dotnet&quot;&gt;SkyAPM-dotnet&lt;/a&gt;也正是使用了这个功能，实现了无入侵启动APM监控。我们来回顾一下SkyAPM-dotnet的使用方式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是使用Nuget添加SkyAPM.Agent.AspNetCore程序集引用。&lt;/li&gt;
&lt;li&gt;其次是在launchSettings.json文件中添加ASPNETCORE_HOSTINGSTARTUPASSEMBLIES:&quot;SkyAPM.Agent.AspNetCore&quot;环境变量配置(等同于set ASPNETCORE_HOSTINGSTARTUPASSEMBLIES=SkyAPM.Agent.AspNetCore或export ASPNETCORE_HOSTINGSTARTUPASSEMBLIES=SkyAPM.Agent.AspNetCore&lt;br/&gt;的方式，本质都是在配置环境变量)&lt;/li&gt;
&lt;li&gt;最后通过SKYWALKING__SERVICENAME设置程序名称&lt;br/&gt;这里我们通过需要配置ASPNETCORE_HOSTINGSTARTUPASSEMBLIES名称可以看出确实是使用了HostingStartup功能，而通过HostingStartup增强的操作入口肯定就在SkyAPM.Agent.AspNetCore程序集中，我们找到SkyAPM.Agent.AspNetCore程序集的源码[&lt;a href=&quot;https://github.com/SkyAPM/SkyAPM-dotnet/blob/master/src/SkyApm.Agent.AspNetCore/SkyApmHostingStartup.cs&quot;&gt;点击查看源码👈&lt;/a&gt;]看到了SkyApmHostingStartup类实现如下&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.DependencyInjection;
using SkyApm.Agent.AspNetCore;
using SkyApm.AspNetCore.Diagnostics;

[assembly: HostingStartup(typeof(SkyApmHostingStartup))]

namespace SkyApm.Agent.AspNetCore
{
    internal class SkyApmHostingStartup : IHostingStartup
    {
        public void Configure(IWebHostBuilder builder)
        {
            builder.ConfigureServices(services =&amp;gt; services.AddSkyAPM(ext =&amp;gt; ext.AddAspNetCoreHosting()));
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过这个我们可以看出确实如此，当然也是等同于我们通过UseSetting(WebHostDefaults.HostingStartupAssembliesKey, &quot;SkyApm.Agent.AspNetCore&quot;)去配置，我们甚至可使用如下的方式去使用SkyAPM-dotnet&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;public void ConfigureServices(IServiceCollection services)
{
   services.AddSkyAPM(ext =&amp;gt; ext.AddAspNetCoreHosting())
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些写法其实是完全等价的，但是通过环境变量的方式配置HostingStartup启动程序集的方式无疑是最优雅的。所以我们在日常的学习开发中，最好还是通过这种方式去操作。&lt;/p&gt;
&lt;h4 id=&quot;改造zipkin使用&quot;&gt;改造Zipkin使用&lt;/h4&gt;
&lt;p&gt;我们在之前的文章&lt;a href=&quot;https://www.cnblogs.com/wucy/p/13642289.html&quot;&gt;ASP.NET Core整合Zipkin链路跟踪&lt;/a&gt;中曾演示过基于诊断日志DiagnosticSource改进Zipkin的集成方式，通过本篇文章讲述的HostingStartup我们可以进步一改进Zipkin的集成方式，可以让它使用起来和SkyAPM-dotnet类似的方式，我们基于之前的示例中的ZipkinExtensions程序集中添加一个ZipkinHostingStartup类，用于承载集成Zipkin的操作，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;using System;
using Microsoft.AspNetCore.Hosting;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;

namespace ZipkinExtensions
{
    public class ZipkinHostingStartup: IHostingStartup
    {

        public void Configure(IWebHostBuilder builder)
        {
            builder.ConfigureServices(services=&amp;gt; {
                services.AddZipkin();
                services.AddSingleton&amp;lt;ITraceDiagnosticListener, HttpDiagnosticListener&amp;gt;();
            });

            builder.Configure(app=&amp;gt; {
                IHostApplicationLifetime lifetime = app.ApplicationServices.GetService&amp;lt;IHostApplicationLifetime&amp;gt;();
                ILoggerFactory loggerFactory = app.ApplicationServices.GetService&amp;lt;ILoggerFactory&amp;gt;();
                IConfiguration configuration = app.ApplicationServices.GetService&amp;lt;IConfiguration&amp;gt;();
                string serivceName = configuration.GetValue&amp;lt;string&amp;gt;(&quot;ServiceName&quot;);
                string zipKinUrl = configuration.GetValue&amp;lt;string&amp;gt;(&quot;ASPNETCORE_ZIPKINADDRESS&quot;);

                app.UseZipkin(lifetime, loggerFactory, serivceName, zipKinUrl);
            });
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在每个项目的launchSettings.json文件中添加如下所示的配置即可，这样的话就可以做到对现有业务代码无任何入侵。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt; &quot;environmentVariables&quot;: {
    &quot;ASPNETCORE_HOSTINGSTARTUPASSEMBLIES&quot;: &quot;ZipkinExtensions&quot;,
    &quot;ASPNETCORE_ZIPKINADDRESS&quot;: &quot;http://localhost:9411/&quot;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;    本文介绍了HostingStartup的基本概念，基础使用以及对其源码的分析和在SkyAPM-dotnet中的应用，最后我们改造了Zipkin的集成方式。HostingStartup在一些集成APM或者链路跟踪的类似场景还是非常实用的，或者如果我们有集成一些基础组件或者三方的组件，但是我们的代码中并不需要直接的使用这些组件中的类或者直接的代码关系，均可以使用HostingStartup的方式去集成，为我们实现对现有代码提供无入侵增强提供了强大的支持。关于HostingStartup我也是在看源码中无意发现的，后来发现微软ASP.NET Core官方文档&lt;br/&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/platform-specific-configuration?view=aspnetcore-5.0&quot;&gt;Use hosting startup assemblies in ASP.NET Core&lt;/a&gt;一文中有讲解，然后联想到自己使用过的SkyAPM-dotnet正是使用了HostingStartup+诊断日志DiagnosticSource的方式实现了对代码无入侵的方式进行监控和链路跟踪。于是决定深入研究一下，可谓收获满满，便写下这篇文章希望更多的人能够了解使用这个功能。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;span&gt;👇欢迎扫码关注我的公众号👇&lt;/span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2042116/202006/2042116-20200622133425514-1420050576.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 22 Nov 2020 23:28:00 +0000</pubDate>
<dc:creator>yi念之间</dc:creator>
<og:description>概念 在ASP.NET Core中我们可以使用一种机制来增强启动时的操作，它就是HostingStartup。如何叫&amp;amp;quot;增强&amp;amp;quot;操作，相信了解过AOP概念的同学应该都非</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wucy/p/14013622.html</dc:identifier>
</item>
</channel>
</rss>