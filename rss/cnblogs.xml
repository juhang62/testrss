<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>字符串匹配算法：Sunday算法 - RioTian</title>
<link>http://www.cnblogs.com/RioTian/p/12903710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RioTian/p/12903710.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;我们第一次接触字符串匹配，想到的肯定是直接用2个循环来遍历，这样代码虽然简单，但时间复杂度却是&lt;span class=&quot;math inline&quot;&gt;\(Ω(m*n)\)&lt;/span&gt;，也就是达到了字符串匹配效率的下限。于是后来人经过研究，构造出了著名的KMP算法（Knuth-Morris-Pratt算法），让我们的时间复杂度降低到了&lt;span class=&quot;math inline&quot;&gt;\(O(m+n)\)&lt;/span&gt;，但现代文字处理器中，却很少使用KMP算法来做字符串匹配，因为还是太慢了。现在主流的算法是BM算法（Boyer-Moore算法），成功让平均时间复杂度降低到了&lt;span class=&quot;math inline&quot;&gt;\(O(m/n)\)&lt;/span&gt;，而Sunday算法，则是对BM算法的进一步小幅优化。&lt;/p&gt;
&lt;p&gt;KMP算法很多人看了一遍遍以后，对&lt;code&gt;next[n]&lt;/code&gt;数组的理解还是有点困难（包括笔者），写代码的时候总是容易变成这种情况（/捂脸.jpg）：&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;（切到网页）：马冬梅&lt;/p&gt;
&lt;p&gt;（切到编译器）：马什么梅&lt;/p&gt;
&lt;p&gt;（切到网页）：马冬梅&lt;/p&gt;
&lt;p&gt;（切到编译器）：马冬什么&lt;/p&gt;
&lt;p&gt;（切到网页）：马冬梅&lt;/p&gt;
&lt;p&gt;（切到编译器）：什么冬梅&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而Sunday算法，理解起来则是非常容易，同时极低的时间复杂度，让Sunday算法成为了我目前最常使用的字符串匹配算法&lt;/p&gt;
&lt;p&gt;Sunday 算法是 Daniel M.Sunday 于 1990 年提出的字符串模式匹配。其效率在匹配随机的字符串时比其他匹配算法还要更快。Sunday 算法的实现可比 KMP，BM 的实现容易太多。&lt;/p&gt;
&lt;p&gt;平均性能的时间复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;；&lt;br/&gt;最差情况的时间复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(n * m)\)&lt;/span&gt;。&lt;/p&gt;
&lt;h2 id=&quot;算法过程&quot;&gt;算法过程&lt;/h2&gt;
&lt;p&gt;Sunday算法和BM算法稍有不同的是，Sunday算法是从前往后匹配，在匹配失败时关注的是主串中参加匹配的最末位字符的下一位字符。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果该字符没有在模式串中出现则直接跳过，即移动位数 = 模式串长度 + 1；&lt;/li&gt;
&lt;li&gt;否则，其移动位数 = 模式串长度 - 该字符最右出现的位置(以0开始) = 模式串中该字符最右出现的位置到尾部的距离 + 1。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在举个例子讲解Sunday算法&lt;/p&gt;
&lt;p&gt;假定主串为 &quot;HERE IS A SIMPLE EXAMPLE&quot;，模式串为 &quot;EXAMPLE&quot;。&lt;/p&gt;
&lt;p&gt;（1）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://resource.ethsonliu.com/image/20190815_01.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从头部开始比较，发现不匹配。则 Sunday 算法要求如下：找到主串中位于模式串后面的第一个字符，即红色箭头所指的 &quot;空格&quot;，再在模式串中从后往前找 &quot;空格&quot;，没有找到，则直接把模式串移到 &quot;空格&quot; 的后面。&lt;/p&gt;
&lt;p&gt;（2）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://resource.ethsonliu.com/image/20190815_02.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依旧从头部开始比较，发现不匹配。找到主串中位于模式串后面的第一个字符 L，模式串中存在 L，则移动模式串使两个 L 对齐。&lt;/p&gt;
&lt;p&gt;（3）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://resource.ethsonliu.com/image/20190815_03.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到匹配。&lt;/p&gt;
&lt;h2 id=&quot;完整代码&quot;&gt;完整代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;

#define MAX_CHAR 256
#define MAX_LENGTH 1000

using namespace std;

void GetNext(string &amp;amp; p, int &amp;amp; m, int next[])
{
        for (int i = 0; i &amp;lt; MAX_CHAR; i++)
                next[i] = -1;
        for (int i = 0; i &amp;lt; m; i++)
                next[p[i]] = i;
}

void Sunday(string &amp;amp; s, int &amp;amp; n, string &amp;amp; p, int &amp;amp; m)
{
        int next[MAX_CHAR];
        GetNext(p, m, next);

        int j;  // s 的下标
        int k;  // p 的下标
        int i = 0;
        bool is_find = false;
        while (i &amp;lt;= n - m)
        {
                j = i;
                k = 0;
                while (j &amp;lt; n &amp;amp;&amp;amp; k &amp;lt; m &amp;amp;&amp;amp; s[j] == p[k])
                        j++, k++;

                if (k == m)
                {
                        cout &amp;lt;&amp;lt; &quot;在主串下标 &quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; 处找到匹配\n&quot;;
                        is_find = true;
                }

                if (i + m &amp;lt; n)
                        i += (m - next[s[i + m]]);
                else
                        break;
        }

        if (!is_find)
                cout &amp;lt;&amp;lt; &quot;未找到匹配\n&quot;;
}

int main()
{
        string s, p;
        int n, m;

        while (cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; p)
        {
                n = s.size();
                m = p.size();
                Sunday(s, n, p, m);
                cout &amp;lt;&amp;lt; endl;
        }

        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据测试如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;here#is#a#example
example
在主串下标 10 处找到匹配

aaa
a
在主串下标 0 处找到匹配
在主串下标 1 处找到匹配
在主串下标 2 处找到匹配

aaa
b
未找到匹配
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/kexuanxiu1163/article/details/98557240&quot;&gt;附小吴师兄的动画讲解链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;sunday算法的缺点&quot;&gt;Sunday算法的缺点&lt;/h2&gt;
&lt;p&gt;看上去简单高效非常美好的Sunday算法，也有一些缺点。因为Sunday算法的核心依赖于move数组，而move数组的值则取决于模式串，那么就可能存在模式串构造出很差的move数组。例如下面一个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;主串：baaaabaaaabaaaabaaaa

模式串：aaaaa
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个模式串使得move[a]的值为1，即每次匹配失败时，只让模式串向后移动一位再进行匹配。这样就让Sunday算法的时间复杂度飙升到了&lt;code&gt;O(m*n)&lt;/code&gt;，也就是字符串匹配的最坏情况,在这种情况下效率就明显低于KMP等算法了 例如：&lt;a href=&quot;http://acm.hdu.edu.cn/showproblem.php?pid=1686&quot;&gt;HDU1686&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;当然，也不能因为存在最坏的情况就直接否定Sunday算法，大多数情况下，Sunday依然是一个简单高效的算法，值得我们熟练学习掌握。&lt;/p&gt;
</description>
<pubDate>Sun, 17 May 2020 00:37:00 +0000</pubDate>
<dc:creator>RioTian</dc:creator>
<og:description>背景 我们第一次接触字符串匹配，想到的肯定是直接用2个循环来遍历，这样代码虽然简单，但时间复杂度却是$Ω(m n)$，也就是达到了字符串匹配效率的下限。于是后来人经过研究，构造出了著名的KMP算法（K</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RioTian/p/12903710.html</dc:identifier>
</item>
<item>
<title>关于tez-ui的&quot;All DAGs&quot;和&quot;Hive Queries&quot;页面信息为空的问题解决过程 - 白竹山</title>
<link>http://www.cnblogs.com/roushi17/p/tez-ui-issue.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/roushi17/p/tez-ui-issue.html</guid>
<description>&lt;p&gt;近段时间发现公司的HDP大数据平台的tez-ui页面不能用了，页面显示为空，导致通过hive提交的sql不能方便地查找到Yarn上对应的applicationId，只能通过beeline的屏幕输出信息、hiveserver2的日志、yarn的日志等一步步去查找，非常麻烦（查找方法见上一篇博客“&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/roushi17/p/hive_tez.html&quot;&gt;如何找到Hive提交的SQL相对应的Yarn程序的applicationId&lt;/a&gt;”）。因此下决心解决这个问题。&lt;/p&gt;
&lt;p&gt;于是找时间去了解了一下tez-ui的原理，它其实是Tez项目下的一个子项目（web项目），可以单独部署在诸如tomcat之类的应用服务器下。tez-ui上显示的tez程序信息实际是来自yarn的timeline service服务，前者通过后者提供的REST接口获取程序的metrics信息。Yarn Timeline Service的架构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1869750/202005/1869750-20200515231917071-1188504619.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的集群tez-ui和timeline service是在不同的机器上面，比如tez-ui部署在A机器，timeline service部署在B机器。&lt;/p&gt;
&lt;p&gt;首先检查了A、B机器，发现它们的时间不一致，其实是timeline service所在的B机器的时间不正确。进一步检查发现B机器的NTP服务关闭了，因此开启B机器的NTP服务，自动同步时间。&lt;/p&gt;
&lt;p&gt;其次，修改tez所在机器的tez-site.xml配置文件，修改下列配置项为对应的值。这一步可以解决&quot;All DAGs”页面不显示信息的问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;tez.am.tez-ui.history-url.template __HISTORY_URL_BASE__?viewPath=/#/tez-app/__APPLICATION_ID__&lt;/span&gt;&lt;br/&gt;&lt;span&gt;tez.history.logging.service.class org.apache.tez.dag.history.logging.ats.ATSV15HistoryLoggingService&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;再次，修改hiveserver2服务所在机器的hive-site.xml配置文件，修改下列配置项为对应的值，然后逐个重启hiveserver2服务。这一步可以解决“Hive Queries”页面不显示信息的问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;hive.exec.failure.hooks: org.apache.hadoop.hive.ql.hooks.ATSHook&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hive.exec.post.hooks: org.apache.hadoop.hive.ql.hooks.ATSHook&lt;/span&gt;&lt;br/&gt;&lt;span&gt;hive.exec.pre.hooks: org.apache.hadoop.hive.ql.hooks.ATSHook&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最后，重启A机器上的tez-ui程序和B机器上的timeline server服务。前者部署在tomcat下，只需要重启下tomcat即可。后者通过如下命令重启。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;./yarn-daemon.sh stop timelineserver&lt;/span&gt;&lt;br/&gt;&lt;span&gt;./yarn-daemon.sh start timelineserver&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最终，我们打开tez-ui页面，地址是http://A:18088/tez-ui，可以看到现在页面可以正确展示&quot;All DAGs&quot;和&quot;Hive Queries&quot;信息了。&lt;/p&gt;
&lt;p&gt;&quot;All DAGs&quot;页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1869750/202005/1869750-20200515233736331-826470803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &quot;Hive Queries&quot;页面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1869750/202005/1869750-20200515233912009-1531009159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 17 May 2020 00:36:00 +0000</pubDate>
<dc:creator>白竹山</dc:creator>
<og:description>近段时间发现公司的HDP大数据平台的tez-ui页面不能用了，页面显示为空，导致通过hive提交的sql不能方便地查找到Yarn上对应的applicationId，只能通过beeline的屏幕输出信息</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/roushi17/p/tez-ui-issue.html</dc:identifier>
</item>
<item>
<title>手把手golang教程【二】——数组与切片 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12903705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12903705.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是&lt;strong&gt;golang专题&lt;/strong&gt;的第五篇，这一篇我们将会了解golang中的数组和切片的使用。&lt;/p&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;数组与切片&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang当中数组和C++中的定义类似，除了变量类型写在后面。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如我们要声明一个长度为10的int型的数组，会写成这样：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;]&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;数组的长度定义了之后不能改变，这点和C++以及Java是一样的。但是在我们日常使用的过程当中，除非我们非常确定数组长度不会发生变化，否则我们一般不会使用数组，而是使用&lt;strong&gt;切片&lt;/strong&gt;(slice)。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切片有些像是&lt;strong&gt;数组的引用&lt;/strong&gt;，它的大小可以是动态的，因此更加灵活。所以在我们日常的使用当中，比数组应用更广。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;切片的声明源于数组，和Python中的list切片类似，我们通过指定左右区间的范围来声明一个切片。这里的范围和Python一样，左闭右开。我们来看个例子：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;]&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; s []&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; = a[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是标准的声明写法，我们也可以不用var来声明，而是直接利用数组给切片赋值，比如上面的语句可以写成这样：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;s := a[:&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在Python当中，当我们使用切片的时候，解释器会为我们将切片对应的数据复制一份。所以切片之后和之前的结果是不同的，但是golang当中则不同。切片和数据对应的是&lt;strong&gt;同一份数据&lt;/strong&gt;，切片只是数组的一个引用，如果原数组的数据发生变化，那么会连带着切片中的数据一起变化。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;还是刚才那个例子：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;]&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; s []&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; = a[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]
fmt.Println(s)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样我们输出得到的结果是[0 0 0 0]，因为数组初始化默认值为0。而假如我们修改一个a中的元素，我们再来打印s，得到的结果就不同了：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a [&lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;]&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; s []&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; = a[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]
a[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;
fmt.Println(s)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样得到的结果就是[4 0 0 0]，虽然我们并没有修改s当中的数据，由于s本质是a的引用，所以a中发生变化会连带着s一起变化。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;进阶用法&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说了，因为切片比数组更加方便，所以我们日常使用当中都倾向于使用切片，而不是数组。但是根据目前的语法，切片都是从数组当中产生的，这岂不是意味着，我们如果想要使用切片，&lt;strong&gt;必须先要创建出一个对应的数组来吗&lt;/strong&gt;？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang的设计者考虑到了这个问题，为了方便我们的使用，golang设计了直接定义切片的方法。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这是一个数组的声明，我们固定了数组的长度，并且用指定的元素对它进行了初始化。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = [&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;]&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;{&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果我们去掉长度的声明，那么它就成了一个切片的声明：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = []&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;{&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样是同样可以运行的，在golang的内部下面的语句同样创建了数组，我们获取的a是这个数组的一个切片。但是这个数组对我们是&lt;strong&gt;不可见&lt;/strong&gt;的，golang编译器替我们省略了这个逻辑。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;长度和容量&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;理解了切片和数组之间的关系之后，我们就可以来看它的&lt;strong&gt;长度&lt;/strong&gt;和&lt;strong&gt;容量&lt;/strong&gt;这两个概念了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个单词的英文分别是length和capability，长度指的是&lt;strong&gt;切片本身包含的元素的个数&lt;/strong&gt;，而容量则是&lt;strong&gt;切片对应的数组从开始到末尾包含的元素个数&lt;/strong&gt;。我们可以用len操作来获取切片的长度，用cap操作来获取它的容量。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看一个例子，首先我们创建一个切片，然后写一个函数来打印出一个切片的长度和容量：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; main

&lt;span class=&quot;hljs-keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;fmt&quot;&lt;/span&gt;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt; {
 s := []&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;}
 printSlice(s)
 
}

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;func&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;printSlice&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(s []&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt; {
 fmt.Printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;len=%d cap=%d %v\n&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-built_in&quot;&gt;len&lt;/span&gt;(s), &lt;span class=&quot;hljs-built_in&quot;&gt;cap&lt;/span&gt;(s), s)
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当我们运行之后得到的结果是这样的：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/17/172200b1abbd165e?w=892&amp;amp;h=222&amp;amp;f=jpeg&amp;amp;s=9717&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个和我的预期应该是一致的，我们创建出了6个元素的切片，自然它的容量和长度应该都是6，但接下来的操作可能就会有点出入了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们对这个切片再进行切片，继续输出切片之后的容量和长度：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;s = s[:&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]
printSlice(s)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行之后会得到下面这个结果：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/17/172200b1c8d84f3a?w=1018&amp;amp;h=234&amp;amp;f=jpeg&amp;amp;s=9126&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们发现它的长度变成了2，但是容量还是6，这个也不是特别难理解。因为虽然当前的切片长度变小了，但是它对应的数组并没有任何变化，所以它的容量应该还是6。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们继续，我们继续切片：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;s := []&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;}
s = s[:&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]
s = s[:&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;]
printSlice(s)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;得到这样的结果：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/17/172200b1cd2d590c?w=1028&amp;amp;h=270&amp;amp;f=jpeg&amp;amp;s=11670&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;事情开始有点不一样了，比较令人关注的点有两个。一个是s在之前切片结束之后的结果长度是2，但是我们居然可以对它切片到下标4的位置。这说明我们在执行切片的时候，&lt;strong&gt;执行的对象并不是切片本身&lt;/strong&gt;，而是切片背后对应的数组。这一点非常重要，如果不能理解这点，那么切片的很多操作看起来都会觉得匪夷所思难以理解。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第二个点是&lt;strong&gt;切片的容量依然没有发生变化&lt;/strong&gt;，这样不会发生变化，那么我们再换一种切片的方法试试，看看会不会有什么不同。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;s = s[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;:]
printSlice(s)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一次得到的结果就不同了，它是这样的：&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/17/172200b1de12c382?w=926&amp;amp;h=248&amp;amp;f=jpeg&amp;amp;s=9374&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这一次发生变化了，切片的容量变成了4，也就是说变小了，这是为什么呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;原因很简单，因为数组的&lt;strong&gt;头指针的位置移动了&lt;/strong&gt;。数组原本的长度是6，往右移动了两位，剩下的长度自然就是4了。但是剩下的问题是，为什么数组的头指针会移动呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为数组的头指针和切片的位置是挂钩的，我们前面的切片操作虽然会改变切片中的元素和它的长度，但是都没有改变切片指针的位置。而这一次我们进行的切片是[2:]，当我们执行这个操作的时候，本质上是指针的位置向右移动到了2。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是为什么切片的容量定义是它对应的数组从开始到末尾元素的个数，而不是对应的数组元素的个数。因为指针向右移动会改变容量的大小，但是&lt;strong&gt;数组本身的长度是没有变化的&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们来看个例子就明白了：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt; a = [&lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;]&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;{&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt;}
 s := a[:]
 
 s = s[:&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]
 printSlice(s)
 s = s[&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;:]
 printSlice(s)
 
 fmt.Println(a)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们这一次使用显性的切片，我们对s进行一系列切片之后，它的容量变成了4，但是a当中的元素个数还是6，并没有变化。所以&lt;strong&gt;不能简单将容量理解成数组的长度&lt;/strong&gt;，而是切片位置到数组末尾的长度。因为切片操作会改变切片指针的位置，从而改变容量，但是数组的大小是没有变化的。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;make操作&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;一般在我们使用切片的时候，我们都是把它当做动态数组用的，也就是Python中的list。所以我们一方面不希望关心切片背后数组，另一方面希望能够有一个区分度较大的构造方法，和创建数组做一个鲜明的区分。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以基于以上考虑，golang当中为我们提供了一个&lt;strong&gt;make方法&lt;/strong&gt;，可以用来创建切片。由于make还可以用来创建其他的类型，比如map，所以我们在使用make的时候，需要传入我们想要创建的变量类型。这里我们想要创建的是切片，所以我们要传入切片的类型，也就是[]int，或者是[]float等等。之后，我们需要传入切片的长度和容量。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;比如：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;s := &lt;span class=&quot;hljs-built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们就得到了一个长度为0，容量是5的切片。我们也可以只传入一个参数，如果只传入一个参数的话，表示切片的长度和容量相等。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;像是这样：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;s := &lt;span class=&quot;hljs-built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们如果打印这个s的话，会得到[0 0 0 0 0]，也就是说golang会为我们给切片填充零值。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;append方法&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;前面说了和数组比起来切片的使用更加灵活，意味着&lt;strong&gt;切片的长度是可变的&lt;/strong&gt;，我们可以通过使用append方法向切片当中追加元素。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang中的append方法和Python已经其他语言不同，golang中的append方法需要传入&lt;strong&gt;两个参数&lt;/strong&gt;，一个是切片本身，另一个是需要添加的元素，最后会返回一个切片。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们应该写成这样：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;s := &lt;span class=&quot;hljs-built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;)
s = &lt;span class=&quot;hljs-built_in&quot;&gt;append&lt;/span&gt;(s, &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么做的目的也很简单，因为切片的&lt;strong&gt;长度是动态的&lt;/strong&gt;，也就意味着切片对应的数组的长度也是可变的，至少是可能增大的。如果当前的数组容量不足以存储切片的时候，golang会分配一个更大的数组，这时候会返回一个指向新数组的切片。也就是说由于切片底层实现机制的关系，导致了append方法不能做成inplace的，所以必须要进行返回。我猜，这也是由于性能的考虑。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;二维切片&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们来看看&lt;strong&gt;二维切片&lt;/strong&gt;在golang当中应该怎么实现，只能要能理解二维，拓展到多维也是一样。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;golang创造二维切片的方式和C++创建二维的vector有些类似，我们一开始先直接定义一个二维的切片，然后用循环往里面填充。我们定义二维切片的方法和一维的切片类似，只是多了一个方括号而已，之后我们用循环往其中填充若干个一维切片：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;mat := &lt;span class=&quot;hljs-built_in&quot;&gt;make&lt;/span&gt;([][]&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i := &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;; i++ {
  mat[i] = &lt;span class=&quot;hljs-built_in&quot;&gt;make&lt;/span&gt;([]&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;结尾&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，golang中关于数组和切片的常见的用法就介绍完了。不仅如此，关于切片底层的实现原理，我们也有了一点浅薄的理解。刚开始接触切片这个概念的时候可能会觉得有点怪，总觉得好像和我们之前学习的语言对不上号，关于容量的概念也不太容易理解，这个是非常正常的，本质上来说，这一切看起来不太正常或者是不太舒服的地方，背后都有创作者的思考，以及为了&lt;strong&gt;性能的权衡&lt;/strong&gt;。所以，如果你觉得想不通的话，可以多往这个方面思考，也许会有不一样的收获。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章就到这里，原创不易，&lt;strong&gt;扫码关注我&lt;/strong&gt;，获取更多精彩文章。&lt;/p&gt;
</description>
<pubDate>Sun, 17 May 2020 00:34:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是golang专题的第五篇，这一篇我们将会了解golang中的数组和切片的使用。 数组与切片 golang当中数组和C++中的定义类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12903705.html</dc:identifier>
</item>
<item>
<title>2020年腾讯实习生C++面试题&amp;持续更新中（5） - 好好学习天天编程</title>
<link>http://www.cnblogs.com/bitzhidu/p/12903698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bitzhidu/p/12903698.html</guid>
<description>&lt;p&gt;2020年腾讯实习生C++面试题&amp;amp;持续更新中（5）&lt;/p&gt;
&lt;div class=&quot;stackedit__html&quot; readability=&quot;15&quot;&gt;
&lt;h5&gt;大家好呀，我是好好学习天天编程的天天~&lt;/h5&gt;
&lt;p&gt;昨天一位小伙伴反馈已经拿到了腾讯offer，很是替小伙伴的激动~&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200515130003276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JpdHpoaWR1,size_16,color_FFFFFF,t_70&quot; alt=&quot;上图为证&quot;/&gt;&lt;br/&gt;那今天还是持续给大家分享面经，希望可以帮助到更多的同学，大家也可以留言告诉我，你们的需求~&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;腾讯面试一面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;自我介绍;&lt;/li&gt;
&lt;li&gt;你是非科班的，说一下你的自学过程;&lt;/li&gt;
&lt;li&gt;简单介绍一下你的项目;&lt;/li&gt;
&lt;li&gt;项目用到了epoll，讲一下epoll的ET模式和LT模式;&lt;/li&gt;
&lt;li&gt;讲一下epoll的oneshot?&lt;/li&gt;
&lt;li&gt;惊群效应;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;腾讯二面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;介绍一下项目;&lt;/li&gt;
&lt;li&gt;项目用到了线程池，如何避免多线程的同步错误?&lt;/li&gt;
&lt;li&gt;线程间的通信机制;&lt;/li&gt;
&lt;li&gt;项目用到了stl，从源码角度讲一种你熟悉的stl容器的实现?map与unordered_map的底层数据结构与查找复杂度;&lt;/li&gt;
&lt;li&gt;项目是用Cpp11写的吗?讲一下Cpp11的新特性?&lt;/li&gt;
&lt;li&gt;讲一下智能指针为何能避免内存泄露?为什么匿名函数能提高程序效率?&lt;/li&gt;
&lt;li&gt;你的http报文解析是怎么做的?用到了什么数据结构?如果http应答报文大于你设定的写缓冲区怎么处理?&lt;/li&gt;
&lt;li&gt;既然tcp更可靠，为什么有很多项目还是优先选择udp?udp快在哪里?如何保证udp的可靠性?&lt;/li&gt;
&lt;li&gt;libevent了解过吗?讲一下libevent的原理;&lt;/li&gt;
&lt;li&gt;内存对齐;&lt;/li&gt;
&lt;li&gt;虚函数工作原理;&lt;/li&gt;
&lt;li&gt;什么时候用模板函数?什么时候用虚函数?&lt;/li&gt;
&lt;li&gt;Cpp 类对象的内存分布;&lt;/li&gt;
&lt;li&gt;手撕LRUmap&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;腾讯三面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;介绍一下你的项目;&lt;/li&gt;
&lt;li&gt;你写的服务器性能怎么样?&lt;/li&gt;
&lt;li&gt;服务器压力测试怎么做的?&lt;/li&gt;
&lt;li&gt;服务器吞吐量?&lt;/li&gt;
&lt;li&gt;服务器响应时间?&lt;/li&gt;
&lt;li&gt;如何减少响应时间?&lt;/li&gt;
&lt;li&gt;如何确定服务器的最大并发连接数?&lt;/li&gt;
&lt;li&gt;讲一个你做过的一个确实能用的项目;&lt;/li&gt;
&lt;li&gt;还有什么问题吗?&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;腾讯四面：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;做一下自我介绍;&lt;/li&gt;
&lt;li&gt;你在一年时间内又要做项目又要自学计算机基础又要打比赛，时间是怎么分配的?&lt;/li&gt;
&lt;li&gt;你是哪里人?未来打算在哪里发展?&lt;/li&gt;
&lt;li&gt;现在拿到几个offer了?&lt;/li&gt;
&lt;li&gt;最早能过来实习的时间?实习时长?&lt;/li&gt;
&lt;li&gt;还有什么要问的吗?&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;hr/&gt;
&lt;p&gt;推荐一个公众号：IT笔试面试真题讲解&lt;/p&gt;
&lt;p&gt;每天更新一个视频，讲解IT公司的高频笔试面试题，完全免费哦~~&lt;/p&gt;
&lt;p&gt;面经分享结束，大家需要更多资料私信我哦&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200515163857409.png&quot; alt=&quot;点赞&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Sun, 17 May 2020 00:27:00 +0000</pubDate>
<dc:creator>好好学习天天编程</dc:creator>
<og:description>持续分享腾讯面试真题，面试腾讯早知道</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bitzhidu/p/12903698.html</dc:identifier>
</item>
<item>
<title>红黑树 - Java伴我余生</title>
<link>http://www.cnblogs.com/reminis/p/12898793.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/reminis/p/12898793.html</guid>
<description>&lt;h3 id=&quot;什么是红黑树&quot;&gt;什么是红黑树&lt;/h3&gt;
&lt;p&gt;红黑树依然是一棵二分搜索树，《算法导论》中的红黑树定义如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个节点或者是红色的，或者是黑色的&lt;/li&gt;
&lt;li&gt;根节点是黑色的&lt;/li&gt;
&lt;li&gt;每一个叶子节点（最后的空节点）是黑色的&lt;/li&gt;
&lt;li&gt;如果一个节点是红色的，那么他的孩子节点都是黑色的&lt;/li&gt;
&lt;li&gt;从任意一个节点到叶子节点，经过的黑色节点是一样的&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;  在学习红黑树之前，我们有必要先学习一下什么是2-3树，学习2-3树不仅对于理解红黑树有帮助，对于理解B类树，也是有巨大帮助的。我们常用到的磁盘存储、文件系统、数据库等相应的数据存储都是采用的B类型这样的数据结构。&lt;/p&gt;
&lt;h3 id=&quot;什么是2-3树&quot;&gt;什么是2-3树&lt;/h3&gt;
&lt;p&gt;  2-3树依然满足二分搜索树的基本性质，但2-3树不是一种二叉树，2-3树有两种节点，节点可以存放一个元素或者两个元素；&lt;span&gt;2-3树是一棵绝对平衡的树，2-3树对于任意一个节点的的左右子树的高度一定是相等的&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200516075132415-325210096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-3树的添加操作&quot;&gt;2-3树的添加操作&lt;/h3&gt;
&lt;p&gt;  2-3树的添加操作将新节点添加到空的位置，若添加一个比根节点小的元素，并且根节点的左子树为空，待添加的新元素会和根节点先融合，由二节点变成三节点，当此时再添加一个元素时，会发现根节点的左子树仍然为空，就还是会先和根节点向融合，但2-3树不能有四节点，最多只能有三节点，所以需要将这个四节点分裂成有三个二节点的绝对平衡二叉树，如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200516081527397-527158092.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  让我们再来看一下2-3树添加元素的过程：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200516083912898-1981114721.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  再向2-3树中添加一些元素，找出规律：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200516085329103-1774570483.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  通过如上的分析，不难知道，如果添加一个元素是添加到一个2-节点，会直接与之融合，如果是添加到一个3-节点，会暂时融合形成一个四节点，然后分裂成一个绝对平衡树。如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200516090309546-485427014.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;红黑树与2-3树的等价性&quot;&gt;红黑树与2-3树的等价性&lt;/h3&gt;
&lt;p&gt;  我们在这里定义所有的红色节点都是向左倾斜的，红色节点代表与父亲节点相融合，由于我们可以通过2-3树画出一个棵红黑树：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200516091633578-707375249.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  由此可知，红黑树是保持“黑平衡”的二叉树，严格意义上 ，不是平衡二叉树，最大高度为2logn,并且从图中也可以看出，只有三节点左侧的元素才是红色的。红黑树和AVL树：由于红黑树的最大高度是2logn,所以在查找时，相比于AVL树会慢一些，而红黑树的添加和删除元素比AVL树更快一些，如果只是用于查询，AVL树的性能要更高一些。&lt;br/&gt;  向红黑树中添加一个新元素，类比于2-3树中添加一个新元素，就是或者添加进2-节点，形成3-节点；或者添加进3-节点，暂时形成一个4-节点，这样我们可以让我们的红黑树，永远添加红节点。由于我们在本文是定义的所有红色节点都是向左倾斜的，当我们新添加的红色节点在根节点的右侧时，我们需要先进行左旋转擦欧总，然后再进行染色操作，在我们左旋转的过程中并不保持红黑树的性质，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200516095459848-1642108096.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;左旋转的代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //   node                     x
    //  /   \     左旋转         /  \
    // T1   x   ---------&amp;gt;   node   T3
    //     / \              /   \
    //    T2 T3            T1   T2
    private Node leftRotate(Node node){

        Node x = node.right;

        // 左旋转
        node.right = x.left;
        x.left = node;

        x.color = node.color;
        node.color = RED;

        return x;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们向红黑树中的“3-节点”添加新元素，由于添加的新节点颜色都默认是红色的，红色节点表示是去和 父亲节点融合的，当4-节点分裂成3个2-节点时，新的根节点需要和父亲节点去融合，这意味着这个新的根节点需要变成红色节点。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200516102339385-211818634.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;颜色翻转的代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    // 颜色翻转
    private void flipColors(Node node){

        node.color = RED;
        node.left.color = BLACK;
        node.right.color = BLACK;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三个2-节点的自平衡，如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200516103327348-2067590212.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;右旋转代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //     node                   x
    //    /   \     右旋转       /  \
    //   x    T2   -------&amp;gt;   y   node
    //  / \                       /  \
    // y  T1                     T1  T2
    private Node rightRotate(Node node){

        Node x = node.left;

        // 右旋转
        node.left = x.right;
        x.right = node;

        x.color = node.color;
        node.color = RED;

        return x;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;三节点的另外一种情况：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1975191/202005/1975191-20200516105239890-1889711056.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;像红黑树中添加节点，就分析到这里了，下面让我们来用代码实现一个红黑树和红黑树的添加操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RBTree&amp;lt;K extends Comparable&amp;lt;K&amp;gt;, V&amp;gt; {

    private static final boolean RED = true;
    private static final boolean BLACK = false;

    private class Node{
        public K key;
        public V value;
        public Node left, right;
        public boolean color;

        public Node(K key, V value){
            this.key = key;
            this.value = value;
            left = null;
            right = null;
            color = RED;
        }
    }

    private Node root;
    private int size;

    public RBTree(){
        root = null;
        size = 0;
    }

    public int getSize(){
        return size;
    }

    public boolean isEmpty(){
        return size == 0;
    }

    // 判断节点node的颜色
    private boolean isRed(Node node){
        if(node == null)
            return BLACK;
        return node.color;
    }

    //   node                     x
    //  /   \     左旋转         /  \
    // T1   x   ---------&amp;gt;   node   T3
    //     / \              /   \
    //    T2 T3            T1   T2
    private Node leftRotate(Node node){

        Node x = node.right;

        // 左旋转
        node.right = x.left;
        x.left = node;

        x.color = node.color;
        node.color = RED;

        return x;
    }

    //     node                   x
    //    /   \     右旋转       /  \
    //   x    T2   -------&amp;gt;   y   node
    //  / \                       /  \
    // y  T1                     T1  T2
    private Node rightRotate(Node node){

        Node x = node.left;

        // 右旋转
        node.left = x.right;
        x.right = node;

        x.color = node.color;
        node.color = RED;

        return x;
    }

    // 颜色翻转
    private void flipColors(Node node){

        node.color = RED;
        node.left.color = BLACK;
        node.right.color = BLACK;
    }

    // 向红黑树中添加新的元素(key, value)
    public void add(K key, V value){
        root = add(root, key, value);
        root.color = BLACK; // 最终根节点为黑色节点
    }

    // 向以node为根的红黑树中插入元素(key, value)，递归算法
    // 返回插入新节点后红黑树的根
    private Node add(Node node, K key, V value){

        if(node == null){
            size ++;
            return new Node(key, value); // 默认插入红色节点
        }

        if(key.compareTo(node.key) &amp;lt; 0)
            node.left = add(node.left, key, value);
        else if(key.compareTo(node.key) &amp;gt; 0)
            node.right = add(node.right, key, value);
        else // key.compareTo(node.key) == 0
            node.value = value;

        if (isRed(node.right) &amp;amp;&amp;amp; !isRed(node.left))
            node = leftRotate(node);

        if (isRed(node.left) &amp;amp;&amp;amp; isRed(node.left.left))
            node = rightRotate(node);

        if (isRed(node.left) &amp;amp;&amp;amp; isRed(node.right))
            flipColors(node);

        return node;
    }

    // 返回以node为根节点的二分搜索树中，key所在的节点
    private Node getNode(Node node, K key){

        if(node == null)
            return null;

        if(key.equals(node.key))
            return node;
        else if(key.compareTo(node.key) &amp;lt; 0)
            return getNode(node.left, key);
        else // if(key.compareTo(node.key) &amp;gt; 0)
            return getNode(node.right, key);
    }

    public boolean contains(K key){
        return getNode(root, key) != null;
    }

    public V get(K key){

        Node node = getNode(root, key);
        return node == null ? null : node.value;
    }

    public void set(K key, V newValue){
        Node node = getNode(root, key);
        if(node == null)
            throw new IllegalArgumentException(key + &quot; doesn't exist!&quot;);

        node.value = newValue;
    }

    // 返回以node为根的二分搜索树的最小值所在的节点
    private Node minimum(Node node){
        if(node.left == null)
            return node;
        return minimum(node.left);
    }

    // 删除掉以node为根的二分搜索树中的最小节点
    // 返回删除节点后新的二分搜索树的根
    private Node removeMin(Node node){

        if(node.left == null){
            Node rightNode = node.right;
            node.right = null;
            size --;
            return rightNode;
        }

        node.left = removeMin(node.left);
        return node;
    }

    // 从二分搜索树中删除键为key的节点
    public V remove(K key){

        Node node = getNode(root, key);
        if(node != null){
            root = remove(root, key);
            return node.value;
        }
        return null;
    }

    private Node remove(Node node, K key){

        if( node == null )
            return null;

        if( key.compareTo(node.key) &amp;lt; 0 ){
            node.left = remove(node.left , key);
            return node;
        }
        else if(key.compareTo(node.key) &amp;gt; 0 ){
            node.right = remove(node.right, key);
            return node;
        }
        else{   // key.compareTo(node.key) == 0

            // 待删除节点左子树为空的情况
            if(node.left == null){
                Node rightNode = node.right;
                node.right = null;
                size --;
                return rightNode;
            }

            // 待删除节点右子树为空的情况
            if(node.right == null){
                Node leftNode = node.left;
                node.left = null;
                size --;
                return leftNode;
            }

            // 待删除节点左右子树均不为空的情况

            // 找到比待删除节点大的最小节点, 即待删除节点右子树的最小节点
            // 用这个节点顶替待删除节点的位置
            Node successor = minimum(node.right);
            successor.right = removeMin(node.right);
            successor.left = node.left;

            node.left = node.right = null;

            return successor;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，在这里做一个红黑树的总结：&lt;br/&gt;  对于完全随机的数据，普通的二分搜索树就很好用，缺点:机端情况会退化成链表（或者高度布不平衡）；对于查询较多的情况，AVL树很好用！红黑树牺牲了平衡性（2logn的高度），统计性能更优（总和增删改查所有的操作）。&lt;/p&gt;
</description>
<pubDate>Sun, 17 May 2020 00:06:00 +0000</pubDate>
<dc:creator>Java伴我余生</dc:creator>
<og:description>什么是红黑树 红黑树依然是一棵二分搜索树，《算法导论》中的红黑树定义如下： 1. 每个节点或者是红色的，或者是黑色的 2. 根节点是黑色的 3. 每一个叶子节点（最后的空节点）是黑色的 4. 如果一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/reminis/p/12898793.html</dc:identifier>
</item>
<item>
<title>今天，你遇到redis线上连接超时了吗？ - WindWant</title>
<link>http://www.cnblogs.com/niejunlei/p/12900578.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niejunlei/p/12900578.html</guid>
<description>&lt;p&gt;一封报警邮件，大量服务节点 redis 响应超时。&lt;/p&gt;
&lt;p&gt;又来，好烦。&lt;/p&gt;
&lt;p&gt;redis 响应变慢，查看日志，发现大量 TimeoutException。&lt;/p&gt;
&lt;p&gt;大量TimeoutException，说明当前redis服务节点上已经堆积了大量的连接查询，超出redis服务能力，再次尝试连接的客户端，redis 服务节点直接拒绝，抛出错误。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那到底是什么导致了这种情况的发生呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总结起来，我们可以从以下几方面进行关注：&lt;/p&gt;
&lt;h2&gt;一、redis 服务节点受到外部关联影响&lt;/h2&gt;
&lt;p&gt;redis服务所在服务器，物理机的资源竞争及网络状况等。同一台服务器上的服务必然面对着服务资源的竞争，CPU，内存，固存等。&lt;/p&gt;
&lt;h3&gt;1、CPU资源竞争&lt;/h3&gt;
&lt;p&gt;redis属于CPU密集型服务，对CPU资源依赖尤为紧密，当所在服务器存在其它CPU密集型应用时，必然会影响redis的服务能力，尤其是在其它服务对CPU资源消耗不稳定的情况下。&lt;/p&gt;
&lt;p&gt;因此，在实际规划redis这种基础性数据服务时应该注意一下几点：&lt;/p&gt;
&lt;p&gt;1）一般不要和其它类型的服务进行混部。&lt;/p&gt;
&lt;p&gt;2）同类型的redis服务，也应该针对所服务的不同上层应用进行资源隔离。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说到CPU关联性，可能有人会问是否应该对redis服务进行CPU绑定，以降低由CPU上下文切换带来的性能消耗及关联影响？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单来说，是可以的，这种优化可以针对任何CPU亲和性要求比较高的服务，但是在此处，有一点我们也应该特别注意：我们在 &lt;a href=&quot;https://www.cnblogs.com/niejunlei/p/12898225.html&quot; target=&quot;_blank&quot;&gt;关于redis内存分析，内存优化 &lt;/a&gt;中介绍内存时，曾经提到过子进程内存消耗，也就是redis持久化时会fork出子进程进行AOF/RDB持久化任务。对于开启了持久化配置的redis服务（一般情况下都会开启），假如我们做了CPU亲和性处理，那么redis fork出的子进程则会和父进程共享同一个CPU资源，我们知道，redis持久化进程是一个非常耗资源的过程，这种自竞争必然会引发redis服务的极大不稳定。&lt;/p&gt;
&lt;h3&gt;2、内存不在内存了&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/niejunlei/p/12898225.html&quot; target=&quot;_blank&quot;&gt;关于redis内存分析，内存优化 &lt;/a&gt; 开篇就讲过，redis最重要的东西，内存。&lt;/p&gt;
&lt;p&gt;内存稳定性是redis提供稳定，低延迟服务的最基本的要求。&lt;/p&gt;
&lt;p&gt;然而，我们也知道操作系统有一个 swap 的东西，也就将内存交换到硬盘。假如发生了redis内存被交换到硬盘的情景发生，那么必然，redis服务能力会骤然下降。&lt;/p&gt;
&lt;p&gt;swap发现及避免：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）info memory：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/niejunlei/p/12898225.html&quot; target=&quot;_blank&quot;&gt;关于redis内存分析，内存优化 &lt;/a&gt; 中我们也讲过，swap这种情景，此时，查看redis的内存信息，可以观察到碎片率会小于1。这也可以作为监控redis服务稳定性的一个指标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）通过redis进程查看。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先通过 info server 获取进程id：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200516130427065-593030250.png&quot; alt=&quot;&quot; width=&quot;362&quot; height=&quot;187&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查看 redis 进程 swap 情况：cat /proc/1686/smaps&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200516130910988-432860866.png&quot; alt=&quot;&quot; width=&quot;266&quot; height=&quot;24&quot;/&gt;&lt;/p&gt;
&lt;p&gt;确定交换量都为0KB或者4KB。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）redis服务maxmemory配置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/niejunlei/p/12898225.html&quot; target=&quot;_blank&quot;&gt;关于redis内存分析，内存优化 &lt;/a&gt; 中我们提到过，对redis服务必要的内存上限配置，这是内存隔离的一种必要。需要确定的是所有redis实例的分配内存总额小于总的可用物理内存。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）系统优化：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;另外，在最初的基础服务操作系统安装部署时，也需要做一些必要的前置优化，如关闭swap或配置系统尽量避免使用。&lt;/p&gt;
&lt;h3&gt;3、网络问题&lt;/h3&gt;
&lt;p&gt;网络问题，是一个普遍的影响因素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）网络资源耗尽&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;简单来说，就是带宽不够了，整个属于基础资源架构的问题了，对网络资源的预估不足，跨机房，异地部署等都会成为诱因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）连接数用完了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个客户端连接对应着一个TCP连接，一个TCP连接在LINUX系统内对应着一个文件句柄，系统级别连接句柄用完了，也就无法再进行连接了。&lt;/p&gt;
&lt;p&gt;查看当前系统限制：ulimit -n&lt;/p&gt;
&lt;p&gt;设置：ulimit -n {num}&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）端口TCP backlog队列满了&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;linux系统对于每个端口使用backlog保存每一个TCP连接。&lt;/p&gt;
&lt;p&gt;redis配置：tcp_backlog 默认511&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200516134330142-161633258.png&quot; alt=&quot;&quot; width=&quot;483&quot; height=&quot;104&quot;/&gt;&lt;/p&gt;
&lt;p&gt;高并发情境下，可以适当调整此配置，但需要注意的是，同时要调整系统相关设置。&lt;/p&gt;
&lt;p&gt;系统修改命令：echo {num}&amp;gt;/proc/sys/net/core/somaxconn&lt;/p&gt;
&lt;p&gt;查看因为队列溢出导致的连接绝句：&lt;span class=&quot;s1&quot;&gt;netstat -s | grep overflowed&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200516140153004-1614005094.png&quot; alt=&quot;&quot; width=&quot;467&quot; height=&quot;22&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;s1&quot;&gt;4）网络延迟&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;网络质量问题，可以使用 redis-cli 进行网络状况的测试：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;延迟测试：&lt;/strong&gt;redis-cli -h {host} -p {port} --latency&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200516140755664-1539893667.png&quot; alt=&quot;&quot; width=&quot;393&quot; height=&quot;17&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;采样延迟测试：&lt;/strong&gt;redis-cli -h {host} -p {port} --latency-history 默认15s一次&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200516140959147-450189485.png&quot; alt=&quot;&quot; width=&quot;530&quot; height=&quot;45&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图形线上测试结果：&lt;/strong&gt;redis-cli -h {host} -p {port} --latency-dist&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200516141141045-710540564.png&quot; alt=&quot;&quot; width=&quot;375&quot; height=&quot;273&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）网卡软中断&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;单个网卡队列只能使用单个CPU资源问题。&lt;/p&gt;
&lt;h2&gt;二、redis 服务使用问题&lt;/h2&gt;
&lt;h3&gt;1、慢查询&lt;/h3&gt;
&lt;p&gt;如果你的查询总是慢查询，那么必然你的使用存在不合理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1）你的key规划是否合理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;太长或太短都是不建议的，key需要设置的简短而有意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）值类型选择是否合理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;hash还是string，set还是zset，避免大对象存储。&lt;/p&gt;
&lt;p&gt;线上可以通过scan命令进行大对象发现治理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）是否能够批查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;get 还是 mget；是否应该使用pipeline。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）禁止线上大数据量操作&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2、redis 服务运行状况&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;查看redis服务运行状况：redis-cli -h {host} -p {port} --stat&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200516142836064-1761932562.png&quot; alt=&quot;&quot; width=&quot;612&quot; height=&quot;99&quot;/&gt;&lt;/p&gt;
&lt;p&gt;keys：当前key总数；mem：内存使用；clients：当前连接client数；blocked：阻塞数；requests：累计请求数；connections：累计连接数&lt;/p&gt;
&lt;h3&gt;3、持久化操作影响&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）fork子进程影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;redis 进行持久化操作需要fork出子进程。fork子进程本身如果时间过长，则会产生一定的影响。&lt;/p&gt;
&lt;p&gt;查看命令最近一次fork耗时：info stats&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200516143929679-228319423.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单位微妙，确保不要超过1s。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）AOF刷盘阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AOF持久化开启，后台每秒进行AOF文件刷盘操作，系统fsync操作将AOF文件同步到硬盘，如果主线程发现距离上一次成功fsync超过2s，则会阻塞后台线程等待fsync完成以保障数据安全性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3）THP问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/niejunlei/p/12898225.html&quot; target=&quot;_blank&quot;&gt;关于redis内存分析，内存优化 &lt;/a&gt; 中我们讲过透明大页问题，linux系统的写时复制机制会使得每次写操作引起的页复制由4KB提升至2M从而导致写慢查询。如果慢查询堆积必然导致后续连接问题。&lt;/p&gt;

</description>
<pubDate>Sat, 16 May 2020 16:01:00 +0000</pubDate>
<dc:creator>WindWant</dc:creator>
<og:description>今天，你遇到redis线上连接超时了吗？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niejunlei/p/12900578.html</dc:identifier>
</item>
<item>
<title>javaweb学习之路（3）Cookie - 侠客小飞</title>
<link>http://www.cnblogs.com/ma1998/p/12902971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ma1998/p/12902971.html</guid>
<description>&lt;h3&gt;1.Cookies的原理&lt;/h3&gt;
&lt;p class=&quot;p0&quot;&gt;1）首先浏览器向服务器发出请求。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;2）服务器就会根据需要生成一个Cookie对象，并且把数据保存在该对象内。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;3）然后把该Cookie对象放在响应头，一并发送回浏览器。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;4）浏览器接收服务器响应后，提出该Cookie保存在浏览器端。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;5）当下一次浏览器再次访问那个服务器，就会把这个Cookie放在请求头内一并发给服务器。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;6)服务器从请求头提取出该Cookie，判别里面的数据，然后作出相应的动作。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;2.Cookie程序&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;建一个response_addCookie.jsp的文件，主要代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;%&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;服务端
        Cookie cookie1 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mwf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Cookie cookie2 &lt;/span&gt;&lt;span&gt;=&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Cookie(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        response.addCookie(cookie1);
        response.addCookie(cookie2);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面跳转到客户端（转发、重定向）
        response.sendRedirect(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result.jsp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;建一个result.jsp文件，获取得到的Cookie值，主要代码为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;%&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;客户端
        Cookie[] cookies &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; request.getCookies();
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(Cookie cookie:cookies){
            out.print(cookie.getName()&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;cookie.getValue()&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;br/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    &lt;/span&gt;&lt;span&gt;%&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.运行结果和查看网页的Cookie值，在Natwork的respose header里面可以看浏览器的缓存，和输出的一致。&lt;/p&gt;
&lt;p class=&quot;p0&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1369308/202005/1369308-20200516234026548-1280574831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5.总结：使用Cookie实现 记住用户名 功能。&lt;/p&gt;
&lt;p&gt;Cookie可以提高访问服务端的效率，但是安全性较差。而session可以弥补这个缺点。&lt;/p&gt;
&lt;p&gt; 服务端准备Cookie：response.addCookie(Cookie cookie)页面跳转（转发，重定向）&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;客户端获取cookie: request.getCookies();&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;要注意的地方：&lt;/p&gt;
&lt;p&gt;服务端增加cookie :response对象；客户端获取对象：request对象。&lt;br/&gt;不能直接获取某一个单独对象，只能一次性将 全部的cookie拿到。&lt;/p&gt;
&lt;p&gt;通过F12可以发现 除了自己设置的Cookie对象外，还有一个name为 JSESSIONID的cookie。&lt;/p&gt;
&lt;p&gt;建议 cookie只保存 英文数字，否则需要进行编码、解码。&lt;/p&gt;

</description>
<pubDate>Sat, 16 May 2020 15:50:00 +0000</pubDate>
<dc:creator>侠客小飞</dc:creator>
<og:description>1.Cookies的原理 1）首先浏览器向服务器发出请求。 2）服务器就会根据需要生成一个Cookie对象，并且把数据保存在该对象内。 3）然后把该Cookie对象放在响应头，一并发送回浏览器。 4）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ma1998/p/12902971.html</dc:identifier>
</item>
<item>
<title>Mockito不能mock final类的解决办法 - 南瓜慢说</title>
<link>http://www.cnblogs.com/larrydpk/p/12902949.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/larrydpk/p/12902949.html</guid>
<description>&lt;p&gt;&lt;code&gt;Mockito&lt;/code&gt;是很常用的测试工具，使用过程中可能会遇到下面的问题：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Mockito cannot mock/spy because : - final class&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;问题重现：&lt;/p&gt;
&lt;p&gt;引入该依赖到项目的maven配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.mockito&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;mockito-core&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;3.3.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.pkslow.basic;

import org.junit.Assert;
import org.junit.Test;

import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

public class MockitoTest {

    public static final class FinalPumpkin {
        public String getName() {
            return &quot;pkslow.com&quot;;
        }

    }

    @Test
    public void test() {
        FinalPumpkin pumpkin = mock(FinalPumpkin.class);
        when(pumpkin.getName()).thenReturn(&quot;www.pkslow.com&quot;);
        Assert.assertEquals(&quot;www.pkslow.com&quot;, pumpkin.getName());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;报错信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;org.mockito.exceptions.base.MockitoException: 
Cannot mock/spy class com.pkslow.basic.MockitoTest$FinalPumpkin
Mockito cannot mock/spy because :
 - final class
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为低版本的&lt;code&gt;mockito&lt;/code&gt;是不能&lt;code&gt;mock&lt;/code&gt; &lt;code&gt;final&lt;/code&gt;类的。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;改变&lt;code&gt;mockito&lt;/code&gt;的版本，修改maven依赖如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.mockito&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;mockito-inline&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;3.3.3&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重跑测试，问题解决！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎访问&lt;a href=&quot;https://www.pkslow.com/&quot;&gt;南瓜慢说 www.pkslow.com&lt;/a&gt;获取更多精彩文章！&lt;/p&gt;
&lt;p&gt;欢迎关注微信公众号&amp;lt;&lt;strong&gt;南瓜慢说&lt;/strong&gt;&amp;gt;，将持续为你更新...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/946674/202005/946674-20200516234510536-2016446473.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多读书，多分享；多写作，多整理。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 16 May 2020 15:45:00 +0000</pubDate>
<dc:creator>南瓜慢说</dc:creator>
<og:description>`Mockito`是很常用的测试工具，使用过程中可能会遇到下面的问题： 问题重现： 引入该依赖到项目的maven配置如下： 测试代码如下： 报错信息如下： 这是因为低版本的 是不能 `final`类的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/larrydpk/p/12902949.html</dc:identifier>
</item>
<item>
<title>python 利用 for ... else 跳出双层嵌套循环 - 我是冰霜</title>
<link>http://www.cnblogs.com/hanmk/p/12902812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hanmk/p/12902812.html</guid>
<description>&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;周末在写一个爬虫时，遇到这样一种场景：从搜索结果中下载指定数量的文件&lt;/p&gt;
&lt;p&gt;例如：搜索结果中共分为10页展示，加起来一共50条数据，现在要做的是从50条数据中下载指定数量的数据&lt;/p&gt;
&lt;p&gt;为了实现这个功能，开始我是这样想的：&lt;/p&gt;
&lt;p&gt;1、依次遍历10页数据，并且把每页的数据都追加到同一个列表中，这样的话，请求完10页数据后，这个列表中就包含了所有结果；&lt;/p&gt;
&lt;p&gt;2、然后再从这个大列表中提取指定数量的数据进行下载即可&lt;/p&gt;
&lt;p&gt;这种方法确实可行，但是在运行过程中发现一个问题：程序运行速度太慢了，原因是无论你想下载多少条数据，都会先把&lt;strong&gt;所有&lt;/strong&gt;数据请求下来并追加到列表中，这个过程实在是太耗时了，而且也不合理&lt;/p&gt;
&lt;p&gt;所以换一种思路：要下载n条数据，就只提取n条，不提前把所有数据请求下来&lt;/p&gt;
&lt;h3&gt;具体实现方法&lt;/h3&gt;
&lt;p&gt;上面举的例子，可以抽象为如下功能&lt;/p&gt;
&lt;p&gt;首先有一个嵌套的列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
[[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后提取这个列表中的数据到一个新的列表中，例如取前3个数字、前5个数字或者前8个数字&lt;/p&gt;
&lt;p&gt;可以通过双层for循环来实现，另外要注意设置条件来跳出循环，如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; source = [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20&lt;span&gt;]]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; target =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_data(source, count):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(0, len(source)+1&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         temp =&lt;span&gt; source[i]
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; temp:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            target.append(j)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; len(target) &amp;gt;=&lt;span&gt; count:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; t = get_data(source, 6&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(target)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;source代表原列表；count代表提取数字的个数&lt;/p&gt;
&lt;p&gt;根据菜鸟教程的提示， for ... else 的意思如下：&lt;/p&gt;
&lt;p&gt;1、for 中的语句和普通的没有区别，else 中的语句会在循环正常执行完的情况下执行（即 for 不是通过 break 跳出而中断的）；&lt;/p&gt;
&lt;p&gt;2、如果for是由于break中断的，则不会执行else语句&lt;/p&gt;

&lt;p&gt;来分析下count为不同值时的运行过程及结果&lt;/p&gt;
&lt;p&gt; 1、count=3&lt;/p&gt;
&lt;p&gt;当count=3时，得到如下结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
target = [1, 2, 3]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;source中包含4个子列表，每个子列表包含5个数字；&lt;/p&gt;
&lt;p&gt;先遍历外层for循环，当遍历到第一个子列表时，就能够满足内层for循环中断的条件了，即：当提取到第一个子列表的数字3时，target的长度等于3，满足len(target)&amp;gt;=count，跳出内层for循环&lt;/p&gt;
&lt;p&gt;由于此时不是正常退出内层for循环，所以不会执行后面的else语句（ps：这里else语句下是执行continue指令，也就是继续遍历外层for循环），然后继续执行else后的berak语句，跳出外层for循环&lt;/p&gt;
&lt;p&gt;综上，得到 target = [1, 2, 3] 的结果&lt;/p&gt;
&lt;p&gt;2、count=8&lt;/p&gt;
&lt;p&gt;当count=3时，得到如下结果&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
target = [1, 2, 3, 4, 5, 6, 7, 8]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样，先取出外层for循环的第一个子列表，第一个子列表只有5个数字，当遍历完后，target的长度等于5，不满足len(target)&amp;gt;=count&lt;/p&gt;
&lt;p&gt;此时内层for循环正常结束第一轮遍历，由于for循环正常结束，所以执行else下的语句，也就是执行continue指令，这里的continue是针对外层for循环的，也就是说继续取出外层for循环的第二个子列表&lt;/p&gt;
&lt;p&gt;当第二个子列表遍历到第三个数字时，target的长度等于8，满足len(target)&amp;gt;=count，，跳出内层for循环&lt;/p&gt;
&lt;p&gt;同理，由于此时不是正常退出内层for循环，所以不会执行后面的else语句，然后继续执行else后的berak语句，跳出外层for循环&lt;/p&gt;
&lt;p&gt;综上，得到 target =[1, 2, 3, 4, 5, 6, 7, 8] 的结果&lt;/p&gt;

&lt;p&gt;以上就是 for ... else 跳出双层嵌套循环的内容，希望对大家有帮助~&lt;/p&gt;

</description>
<pubDate>Sat, 16 May 2020 15:45:00 +0000</pubDate>
<dc:creator>我是冰霜</dc:creator>
<og:description>背景 周末在写一个爬虫时，遇到这样一种场景：从搜索结果中下载指定数量的文件 例如：搜索结果中共分为10页展示，加起来一共50条数据，现在要做的是从50条数据中下载指定数量的数据 为了实现这个功能，开始</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hanmk/p/12902812.html</dc:identifier>
</item>
<item>
<title>Spring Boot 之 Spring Batch 批处理实践 - Jafeney</title>
<link>http://www.cnblogs.com/Jafeney/p/12902941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jafeney/p/12902941.html</guid>
<description>&lt;h4 id=&quot;实践内容&quot;&gt;实践内容&lt;/h4&gt;
&lt;p&gt;从 MariaDB 一张表内读 10 万条记录，经处理后写到 MongoDB 。&lt;/p&gt;
&lt;h4 id=&quot;具体实现&quot;&gt;具体实现&lt;/h4&gt;
&lt;p&gt;1、新建 Spring Boot 应用，依赖如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;        &amp;lt;!-- Web 应用 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;spring-boot-starter-logging&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;spring-boot-starter-tomcat&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- Web 容器 undertow --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-undertow&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- 日志 Log4j2 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-log4j2&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- MongoDB --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-data-mongodb&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- Brantch --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-batch&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- Mariadb 驱动 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mariadb.jdbc&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mariadb-java-client&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.0.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- Lombok 代码简化 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;1.16.14&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、创建一张表，并生成 10 万条数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;DROP TABLE people IF EXISTS;

CREATE TABLE people  (
    id BIGINT IDENTITY NOT NULL PRIMARY KEY,
    first_name VARCHAR(20),
    last_name VARCHAR(20)
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、创建 Person 类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Data
public class Person {
    private Long id;
    private String lastName;
    private String firstName;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、创建一个中间处理器 &lt;code&gt;PersonItemProcessor&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import org.springframework.batch.item.ItemProcessor;

@Log4j2
public class PersonItemProcessor implements ItemProcessor&amp;lt;Person, Person&amp;gt; {

    @Override
    public Person process(final Person person) throws Exception {
        final String firstName = person.getFirstName().toUpperCase();
        final String lastName = person.getLastName().toUpperCase();

        final Person transformedPerson = new Person(firstName, lastName);

        log.info(&quot;Converting (&quot; + person + &quot;) into (&quot; + transformedPerson + &quot;)&quot;);

        return transformedPerson;
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、创建 &lt;code&gt;PersonMapper&lt;/code&gt;，用户数据库映射&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class PersonMapper implements RowMapper {

    private static final String ID_COLUMN = &quot;id&quot;;
    private static final String NICKNAME_COLUMN = &quot;first_name&quot;;
    private static final String EMAIL_COLUMN = &quot;last_name&quot;;


    @Override
    public Object mapRow(ResultSet resultSet, int i) throws SQLException {
        Person user = new Person();
        person.setId(resultSet.getLong(ID_COLUMN));
        person.setNickname(resultSet.getString(NICKNAME_COLUMN));
        person.setEmail(resultSet.getString(EMAIL_COLUMN));
        return person;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、创建任务完成的监听 &lt;code&gt;JobCompletionNotificationListener&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Log4j2
@Component
public class JobCompletionNotificationListener extends JobExecutionListenerSupport {

    @Override
    public void afterJob(JobExecution jobExecution) {
        if(jobExecution.getStatus() == BatchStatus.COMPLETED) {
            log.info(&quot;!!! JOB FINISHED! Time to verify the results&quot;);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7、构建批处理任务 &lt;code&gt;BatchConfiguration&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
@EnableBatchProcessing
public class BatchConfiguration {

    @Autowired
    public JobBuilderFactory jobBuilderFactory;

    @Autowired
    public StepBuilderFactory stepBuilderFactory;

    @Autowired
    public DataSource dataSource;
    
    @Autowired
    public MongoTemplate mongoTemplate;

    @Bean
    public JdbcCursorItemReader&amp;lt;Person&amp;gt; reader(){
        JdbcCursorItemReader&amp;lt;Person&amp;gt; itemReader = new JdbcCursorItemReader&amp;lt;Person&amp;gt;();
        itemReader.setDataSource(dataSource);
        itemReader.setSql(&quot;select id, nickname, email from people&quot;);
        itemReader.setRowMapper(new PersonMapper());
        return itemReader;
    }

    @Bean
    public PersonItemProcessor processor() {
        return new PersonItemProcessor();
    }
    
    @Bean
    MongoItemWriter&amp;lt;Person&amp;gt; writer(){
        MongoItemWriter&amp;lt;Person&amp;gt; itemWriter = new MongoItemWriter&amp;lt;Person&amp;gt;();
        itemWriter.setTemplate(mongoTemplate);
        itemWriter.setCollection(&quot;branch&quot;);
        return itemWriter;
    }

    @Bean
    public Step step() {
        return stepBuilderFactory.get(&quot;step&quot;)
                .&amp;lt;Person, Person&amp;gt; chunk(10)
                .reader(reader())
                .processor(processor())
                .writer(writer())
                .build();
    }

    @Bean
    public Job importUserJob(JobCompletionNotificationListener listener) {
        return jobBuilderFactory.get(&quot;importUserJob&quot;)
                .incrementer(new RunIdIncrementer())
                .listener(listener)
                .flow(step())
                .end()
                .build();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;任务处理结果&quot;&gt;任务处理结果&lt;/h4&gt;
&lt;p&gt;0出错，耗时 2 分钟左右，测试机 Mac&lt;/p&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 16 May 2020 15:43:00 +0000</pubDate>
<dc:creator>Jafeney</dc:creator>
<og:description>实践内容 从 MariaDB 一张表内读 10 万条记录，经处理后写到 MongoDB 。 具体实现 1、新建 Spring Boot 应用，依赖如下： 2、创建一张表，并生成 10 万条数据 3、创</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jafeney/p/12902941.html</dc:identifier>
</item>
</channel>
</rss>