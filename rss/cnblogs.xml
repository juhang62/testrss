<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Dubbo 服务 IP 注册错误踩坑经历 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/12319868.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/12319868.html</guid>
<description>&lt;blockquote readability=&quot;4.8387096774194&quot;&gt;
&lt;p&gt;个人博客地址 &lt;a href=&quot;https://studyidea.cn/dubbo_error_ip&quot;&gt;studyidea.cn&lt;/a&gt;,点击查看更多原创文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;踩坑&quot;&gt;踩坑&lt;/h2&gt;
&lt;p&gt;公司最近新建一个机房，需要将现有系统同步部署到新机房，部署完成之后，两地机房同时对提供服务。系统架构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202002/1419561-20200217072021897-308954624.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个系统当前对外采用 &lt;code&gt;Restful&lt;/code&gt; 接口，内部远程采用 &lt;code&gt;Dubbo&lt;/code&gt;，服务注册中心使用 &lt;code&gt;zookeeper&lt;/code&gt;。服务当前设定只会调用本机房内服务。&lt;/p&gt;
&lt;p&gt;原先服务都在 A 机房，B 机房为新建机房。B 机房部署完成之后，需要测试 B 机房系统可用性。生产测试的发现 B 机房竟然调用 A 机房服务。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;A/B 机房网络互相打通，可以互相访问&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过排查 B 机房服务日志，发现 &lt;code&gt;Service B&lt;/code&gt; 一个服务节点注册 &lt;strong&gt;IP&lt;/strong&gt; 解析错误，将 B 机房机器 &lt;strong&gt;IP&lt;/strong&gt; 解析成 A 机房机器 &lt;strong&gt;IP&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;于是当测试流量进入 B 机房时，&lt;code&gt;openapi&lt;/code&gt;服务通过注册中心获取到错误的 &lt;code&gt;Service B&lt;/code&gt; 服务地址，从而调用了 A 机房的服务。调用方式简化成如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202002/1419561-20200217072022316-1382664771.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;知识点：Dubbo 服务提供者启动时将会将服务地址（&lt;strong&gt;IP&lt;/strong&gt;+端口）注册到注册中心，消费者启动时将会通过注册中心获取服务提供者地址（&lt;strong&gt;IP&lt;/strong&gt;+端口），后续服务调用将会直接通过服务地址直接调用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;问题分析&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Debug&lt;/strong&gt; &lt;code&gt;Dubbo&lt;/code&gt; 源码，定位到 &lt;code&gt;IP&lt;/code&gt; 解析代码，位于 &lt;code&gt;ServiceConfig#findConfigedHosts&lt;/code&gt;，源码如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Dubbo 版本为 2.6.7&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202002/1419561-20200217072025877-1154581361.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个方法源码比较长，看起来比较费劲，不过好在这个方法注释上已经写明白 &lt;code&gt;IP&lt;/code&gt; 地址查找顺序。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Register &amp;amp; bind IP address for service provider, can be configured separately. Configuration priority: environment variables -&amp;gt; java system properties -&amp;gt; host property in config file -&amp;gt; /etc/hosts -&amp;gt; default network address -&amp;gt; first available network address&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找顺序如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202002/1419561-20200217072028228-1050667355.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;解析过程，&lt;code&gt;Dubbo&lt;/code&gt; 将会过滤无用 &lt;strong&gt;IP&lt;/strong&gt;，过滤规则如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202002/1419561-20200217072029572-1810567279.jpg&quot; alt=&quot;image-20200201203655297&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面将结合图示讲解查找顺序，只要其中一步读取 &lt;strong&gt;IP&lt;/strong&gt; 符合上述规则，方法就会返回。&lt;/p&gt;
&lt;p&gt;第一步将会调用 &lt;code&gt;ServiceConfig#getValueFromConfig&lt;/code&gt; 从 &lt;code&gt;environment variables&lt;/code&gt; 或 &lt;code&gt;java system properties&lt;/code&gt; 配置 &lt;strong&gt;IP&lt;/strong&gt; 地址。&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202002/1419561-20200217072031555-254359950.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方式通过在 &lt;code&gt;JVM&lt;/code&gt; 启动参数中显示指定 &lt;strong&gt;IP&lt;/strong&gt; 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-DDUBBO_IP_TO_BIND=1.2.3.4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步通过读取 &lt;code&gt;Dubbo&lt;/code&gt; 配置文件配置变量获取 &lt;strong&gt;IP&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- protocol 指定整个 Dubbo 应用服务默认 IP --&amp;gt;
&amp;lt;dubbo:protocol host=&quot;1.2.3.4&quot;/&amp;gt;
&amp;lt;!-- provider 指定 Dubbo 应用具体某个服务默认 IP --&amp;gt;
&amp;lt;dubbo:provider host=&quot;1.2.3.4&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步通过调用 &lt;code&gt;InetAddress.getLocalHost().getHostAddress()&lt;/code&gt; 获取本地 &lt;strong&gt;IP&lt;/strong&gt;。该方法将会获取机器 &lt;code&gt;hostname&lt;/code&gt;，然后再在 &lt;code&gt;/etc/hosts&lt;/code&gt; 配置文件中查找 &lt;code&gt;hostname&lt;/code&gt; 对应的配置 IP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202002/1419561-20200217072035120-1530169716.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第四步通过 &lt;code&gt;socket&lt;/code&gt; 连接注册中心从而获取本机 IP。&lt;/p&gt;
&lt;p&gt;如果上述几步都不成功，Dubbo 将会轮询本机所有网卡，直到找到合适的 &lt;strong&gt;IP&lt;/strong&gt; 地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202002/1419561-20200217072037834-210833730.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过排查上述几个规则，最后发现本地 &lt;code&gt;/etc/hosts&lt;/code&gt; 文件 &lt;strong&gt;IP&lt;/strong&gt; 配置错误， &lt;code&gt;hostname&lt;/code&gt; 配置成了 A 机房的 &lt;strong&gt;IP&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Dubbo 在 &lt;strong&gt;IP&lt;/strong&gt; 解析上花费很大功夫，最大程度上帮我们自动获取正确 &lt;strong&gt;IP&lt;/strong&gt;。但是现实还是很残酷，真实环境下机器可能存在多网卡，内外网 &lt;strong&gt;IP&lt;/strong&gt;，&lt;strong&gt;VPN&lt;/strong&gt; ，或者应用采用 &lt;strong&gt;Docker&lt;/strong&gt; 部署，这些情况下&lt;code&gt;Dubbo&lt;/code&gt; 有可能就会获取到错误 &lt;strong&gt;IP&lt;/strong&gt;，从而导致消费者调用失败。如果真遇到这种情况，读者首先通过上面顺序排查 &lt;strong&gt;IP&lt;/strong&gt; 读取来源，若最后确定 &lt;strong&gt;IP&lt;/strong&gt; 读取自网卡 。这种情况下就只能根据下面几种方式显示指定 IP。&lt;/p&gt;
&lt;p&gt;配置方式一：&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;JVM&lt;/code&gt; 启动参数中加入如下配置&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;-DDUBBO_IP_TO_BIND=1.2.3.4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置方式二：&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;/etc/hosts&lt;/code&gt; 设置 &lt;code&gt;hostname&lt;/code&gt; 对应的 &lt;strong&gt;IP&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;配置方式三：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Dubbo&lt;/code&gt; 配置文件显示指定 IP。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- protocol 指定整个 Dubbo 应用服务默认 IP --&amp;gt;
&amp;lt;dubbo:protocol host=&quot;1.2.3.4&quot;/&amp;gt;
&amp;lt;!-- provider 指定 Dubbo 应用具体某个服务默认 IP --&amp;gt;
&amp;lt;dubbo:provider host=&quot;1.2.3.4&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;随便聊聊&quot;&gt;随便聊聊&lt;/h2&gt;
&lt;p&gt;这次的问题其实不大，就是 hosts 文件配置错误，但是整个查找问题的过程还是值得学习的，深入到了源码层面，跟踪代码，最终发现问题。生产出现问题，如何第一时间定位到问题，这是一门学问。我们不仅要了解业务代码，也要清楚框架的原理。每一次的踩坑经历，都是一次考验，经历的多了，经验自然也会多了，这也许就是资深程序员与初级程序员差别。&lt;/p&gt;
&lt;h2 id=&quot;帮助链接&quot;&gt;帮助链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://dubbo.apache.org/zh-cn/blog/dubbo-network-interfaces.html&quot; class=&quot;uri&quot;&gt;https://dubbo.apache.org/zh-cn/blog/dubbo-network-interfaces.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1419561/202002/1419561-20200217072038554-519954420.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 16 Feb 2020 23:21:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>Hosts 地址错误，导致 Dubbo 提供者服务 IP 选择错误的问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/12319868.html</dc:identifier>
</item>
<item>
<title>敏捷开发：我们这段时间好像是伪敏捷 - K战神</title>
<link>http://www.cnblogs.com/sunchong/p/12318704.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunchong/p/12318704.html</guid>
<description>&lt;h2 id=&quot;自觉良好&quot;&gt;自觉良好&lt;/h2&gt;
&lt;p&gt;就在之前几篇的时候，我们已经默默开始给小团队灌输敏捷知识。&lt;/p&gt;
&lt;p&gt;这个团队很小，产品：应届生；开发：毕业一年，初级程序员；还有一个有些经验的我。&lt;/p&gt;
&lt;p&gt;我们负责的项目有开发任务，同时也有不少运维工作。经常会有新需求插入和变更。&lt;/p&gt;
&lt;p&gt;我们效仿一些敏捷形式和方法。有些做得挺好，有些做得不能够长期坚持。&lt;/p&gt;
&lt;p&gt;我们产品列表比较混乱，没有做整理细化，有一个摞一个。从外面看整个产品是混乱的，看不清未来方向的。&lt;/p&gt;
&lt;p&gt;我们虽然每周都有计划，从上面可以看出，我们没有远期目标。因为我的懒惰，没有从项目上梳理长期的规划。&lt;/p&gt;
&lt;p&gt;自认为需求频繁变动，所以没必要清晰的长期规划。也不是说没有想过，讨论过，也达成一致过。但是没有落实到产品列表中。&lt;/p&gt;
&lt;p&gt;你从产品列表中不会看到未来系统的模样。&lt;/p&gt;
&lt;p&gt;应届生的产品做么？他一直也是这么做的，只是有时我们稍微缺少了引导就会止步不前，不是积极性问题，是他有时真的无法下手。&lt;/p&gt;
&lt;p&gt;就好比，你刚毕业就让你负责系统架构一样，我想刚毕业的我有心想做，但是心里还是会战战兢兢。&lt;/p&gt;
&lt;h2 id=&quot;冥冥之中的隐患&quot;&gt;冥冥之中的隐患&lt;/h2&gt;
&lt;p&gt;其实说到底还是项目管理的问题。我现在隐隐体会到，敏捷是指导原则，实际贯穿主线的还是项目管理。&lt;/p&gt;
&lt;p&gt;所以两者的结合孕育出了很多的优秀的敏捷实践。&lt;/p&gt;
&lt;p&gt;我们省去了产品列表的规划，只有零星的周计划。我们甚至没有了项目回顾会议。&lt;/p&gt;
&lt;p&gt;我们起初所认为的快 —— 实际上是省去了各种产品列表的优先级排列：史诗级、主题级、冲刺级，由粗到细的用户故事的拆分。&lt;/p&gt;
&lt;p&gt;我们虽然将周期调整为一周一个计划，来应对频繁的运维需求的变更。但是我们也缺少了项目相关的评审会议、回顾会议。&lt;/p&gt;
&lt;p&gt;我们只管往前跑，冥冥之中感觉自己在做无用功，甚至说我们所做的任务价值意义不大。&lt;/p&gt;
&lt;p&gt;导致这种错觉的，一个是很大程度上是没有长远规划，另一个是各种评审和关键点没有设卡，还有一个是没有了回顾和反省。&lt;/p&gt;
&lt;p&gt;所以要遵循项目管理的主要规律和重要的实践，虽然这些操作时间上付出是有一定的成本，这些付出是值得的。&lt;/p&gt;
&lt;h2 id=&quot;需要长远规划&quot;&gt;需要长远规划&lt;/h2&gt;
&lt;p&gt;就好比大家没有了共同的目标，这个不利于团队的士气，不利于项目的发展。&lt;/p&gt;
&lt;p&gt;需要付出时间和精力来做这些事情，这个好比是架构，一部成长史。参与其中的成长是非常有成就的。&lt;/p&gt;
&lt;p&gt;产品列表：史诗级用户故事；主题级用户故事；冲刺级用户故事。冲刺级别是具体可执行的任务。&lt;/p&gt;
&lt;p&gt;比如史诗级别：作为一个运维人员，我希望有一个后台可以方便我的日常运维工作，来提高处理问题的速度更快地相应客户。&lt;/p&gt;
&lt;p&gt;比如主题级别：作为一个用户，我想我发起的任务可以并行调度而不是长时间等待顺序排队，这样才能很快并陆续收到反馈。&lt;/p&gt;
&lt;p&gt;比如冲刺级别：作为一个运维人员，我在系统中能够拥有在线对账的权限，这样利于月中对账，而不是每次都需要写邮件给DBA申请导出.&lt;/p&gt;
&lt;h2 id=&quot;设卡评审&quot;&gt;设卡&amp;amp;评审&lt;/h2&gt;
&lt;p&gt;关于评审，比如 核心模块的设计评审（思路和技术点）&lt;/p&gt;
&lt;p&gt;需求评审&lt;/p&gt;
&lt;p&gt;接口协议的设计评审（命名，出入参）&lt;/p&gt;
&lt;p&gt;代码走查评审&lt;/p&gt;
&lt;p&gt;测试用例评审&lt;/p&gt;
&lt;p&gt;从各种评审中我收获到的几个基本的好处是：&lt;/p&gt;
&lt;p&gt;1、对于被评审人员，专业技能上是一个肉眼可见的提升。&lt;/p&gt;
&lt;p&gt;2、三个臭皮匠顶一个诸葛亮，大家不同的智慧的碰撞会发现很多新的坑。&lt;/p&gt;
&lt;p&gt;3、是一种态度的输出&lt;/p&gt;
&lt;p&gt;其中几个经验是：&lt;/p&gt;
&lt;p&gt;1、功夫都在平时准备：比如设计文档、接口规范设计文档、测试用例的用例（这个我们做的还行，也是需要导师多督促，成员能够主动沟通）&lt;/p&gt;
&lt;p&gt;2、会前，发布一个会议大纲。（这个做得也行，这个都会说一下）&lt;/p&gt;
&lt;p&gt;比如会议的主要讨论主题是什么？会议的时间是多久？&lt;/p&gt;
&lt;p&gt;自己会大约使用多长时间？留给其他人员的讨论时间是多少？&lt;/p&gt;
&lt;p&gt;开会只是一个对当前结果的一个讨论。&lt;/p&gt;
&lt;p&gt;3、会议设定一个主持人&lt;/p&gt;
&lt;p&gt;（这个很重要也很有效果，之前没有主持人会议经常超时。关键是超时还觉得自豪，自豪会议又讨论出很多东西，自豪发言很踊跃。）&lt;/p&gt;
&lt;p&gt;其实还是为了一个开会的效果，可以找一个资历高一点的把控会议。避免过度讨论。&lt;/p&gt;
&lt;p&gt;也就是大家的时间成本和开会的效果尽量地高效。&lt;/p&gt;
&lt;p&gt;4、结束后整理会议纪要（这个执行得算是及格，但是不够坚持）&lt;/p&gt;
&lt;p&gt;其实会议纪要是次要的，主要是对会议讨论的结果负责，最好有产出物或者结论。&lt;/p&gt;
&lt;h2 id=&quot;项目回顾&quot;&gt;项目回顾&lt;/h2&gt;
&lt;p&gt;项目上的回顾，总结过去，计划未来。&lt;/p&gt;
&lt;p&gt;好的不好的都需要说。个人来说也是这样，好的不好的都需要总结。个人提高了也是项目整体提高的一部分。&lt;/p&gt;
&lt;p&gt;再就是计划一下接下来的工作，明确下一个版本的目标。&lt;/p&gt;
&lt;h2 id=&quot;加入测试&quot;&gt;加入测试&lt;/h2&gt;
&lt;p&gt;因为主要提供接口。一开始我们的都是自己测试，久而久之就没有让测试加入。&lt;/p&gt;
&lt;p&gt;开始觉得这样挺好，流程更短。&lt;/p&gt;
&lt;p&gt;现在想我们的3个总结是：&lt;/p&gt;
&lt;p&gt;1、我们其实做得工作并不少，反而多了，因为兼顾了测试的一部分工作&lt;/p&gt;
&lt;p&gt;2、任务多了，有可能影响了工期和质量&lt;/p&gt;
&lt;p&gt;3、我们相信我们，但是我们还是不够专业。就算是接口简单不需要测试人员介入。&lt;/p&gt;
&lt;p&gt;但是需要测试思维，测试的测试角度思维经常会给我们当头一棒，很受用。&lt;/p&gt;
&lt;h2 id=&quot;坚持执行不断调整&quot;&gt;坚持执行，不断调整&lt;/h2&gt;
&lt;p&gt;希望我能够坚持执行，不断反思调整。&lt;/p&gt;
&lt;p&gt;根据成员能力和专业程度采用相关的敏捷实践，不是所有市面上好的都有效。&lt;/p&gt;
&lt;p&gt;自己近期看了很多敏捷相关的书籍，最近又看完的这一本，收获还是很大的，纠正了很多原来的认知。&lt;/p&gt;
&lt;p&gt;比如：所有的用户故事必须符合6原则（其实是允许出现史诗级的用户故事的）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/202002/406456-20200217010955468-2101508813.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/406456/202002/406456-20200217011022885-664565150.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;项目管理，甚至说软件工程需要我们不断吸收并反复琢磨实践。&lt;/p&gt;
&lt;p&gt;自己&lt;del&gt;立一个Flag&lt;/del&gt; 立一个愿望，希望上述我们项目中存在的问题能够在上半年有所改善。&lt;/p&gt;
&lt;p&gt;能够督促系统的成长和发展。&lt;/p&gt;
&lt;p&gt;（喝茶水有点多，睡不着，深夜发个文章催眠一下）&lt;/p&gt;
</description>
<pubDate>Sun, 16 Feb 2020 17:12:00 +0000</pubDate>
<dc:creator>K战神</dc:creator>
<og:description>自觉良好 就在之前几篇的时候，我们已经默默开始给小团队灌输敏捷知识。 这个团队很小，产品：应届生；开发：毕业一年，初级程序员；还有一个有些经验的我。 我们负责的项目有开发任务，同时也有不少运维工作。经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunchong/p/12318704.html</dc:identifier>
</item>
<item>
<title>OpenCV3入门（七）图像形态学 - 啊哈彭</title>
<link>http://www.cnblogs.com/pingwen/p/12319629.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pingwen/p/12319629.html</guid>
<description>&lt;h2&gt;1、膨胀&lt;/h2&gt;
&lt;p&gt;所谓的图片的膨胀处理，其实就是在图像的边缘添加像素值，使得整体的像素值扩张，进而达到图像的膨胀效果。&lt;/p&gt;
&lt;p&gt;对Z&lt;sup&gt;2&lt;/sup&gt;上元素集合A和结构体元素S，使用S对A进行腐蚀，记作：&lt;/p&gt;
&lt;p&gt;A⊕S={z|(S)z ∩ A ≠ Ø}&lt;/p&gt;
&lt;p&gt;让位于图像圆点的结构元素S在Z平面上移动，如果S的圆点移动到z点时，S与A有公共的交集（非空集），则认为这样的z点构成的集合是S对A的膨胀图像。&lt;/p&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
CV_EXPORTS_W &lt;span&gt;void&lt;/span&gt;&lt;span&gt; dilate( InputArray src, OutputArray dst, InputArray kernel,
                          Point anchor &lt;/span&gt;= Point(-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;int&lt;/span&gt; iterations = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                          &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; borderType =&lt;span&gt; BORDER_CONSTANT,
                          &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Scalar&amp;amp; borderValue = morphologyDefaultBorderValue() );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;dst表示处理的结果&lt;/p&gt;
&lt;p&gt;src表示原图像&lt;/p&gt;
&lt;p&gt;kernel表示卷积核&lt;/p&gt;
&lt;p&gt;anchor是point类型，表示锚的位置，默认正中心&lt;/p&gt;
&lt;p&gt;iterations表示迭代次数&lt;/p&gt;
&lt;p&gt;borderType边缘的模糊方式&lt;/p&gt;
&lt;p&gt;一般需要前三个参数即可，第三个参数需要用getStructuringElement函数确定，该函数确定模板内核特性和锚点的位置。&lt;/p&gt;
&lt;p&gt;CV_EXPORTS_W Mat getStructuringElement(int shape, Size ksize, Point anchor = Point(-1,-1));&lt;/p&gt;
&lt;p&gt;模板内核的类型有：&lt;/p&gt;
&lt;p&gt;MORPH_RECT：矩形&lt;/p&gt;
&lt;p&gt;MORPH_CROSS：交叉型&lt;/p&gt;
&lt;p&gt;MORPH_ELLIPSE：椭圆型&lt;/p&gt;
&lt;p&gt;示例如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
img = imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\WORK\\5.OpenCV\\LeanOpenCV\\pic_src\\pic7.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

img1 &lt;/span&gt;=&lt;span&gt; img.clone();
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img);
Mat element &lt;/span&gt;= getStructuringElement(MORPH_RECT, Size(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;));
dilate(img, img2, element);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;膨胀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, img2); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200216233720696-1032299388.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;2、腐蚀&lt;/h2&gt;
&lt;p&gt;腐蚀：就是求局部最小值的操作。&lt;/p&gt;
&lt;p&gt;结构元素（Sturcture Element），形象称呼刷子，在每个像素位置上与二值图像对应的区域进行特定的逻辑运算。运算结构是输出图像的相应像素。运算效果取决于结构元素大小内容以及逻辑运算性质。&lt;/p&gt;
&lt;p&gt;对Z&lt;sup&gt;2&lt;/sup&gt;上元素集合A和结构体元素S，使用S对A进行腐蚀，记作：&lt;/p&gt;
&lt;p&gt;AΘS={z|(S)z € A}&lt;/p&gt;
&lt;p&gt;让位于图像圆点的结构元素S在Z平面上移动，如果S的圆点移动到z点时，S能够完全的包含于A中，则认为这样的z点构成的集合是S对A的腐蚀图像。&lt;/p&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
CV_EXPORTS_W &lt;span&gt;void&lt;/span&gt;&lt;span&gt; erode( InputArray src, OutputArray dst, InputArray kernel,
                         Point anchor &lt;/span&gt;= Point(-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;int&lt;/span&gt; iterations = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                         &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; borderType =&lt;span&gt; BORDER_CONSTANT,
                         &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Scalar&amp;amp; borderValue = morphologyDefaultBorderValue() );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
img = imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\WORK\\5.OpenCV\\LeanOpenCV\\pic_src\\pic7.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

img1 &lt;/span&gt;=&lt;span&gt; img.clone();
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img);
Mat element &lt;/span&gt;= getStructuringElement(MORPH_RECT, Size(&lt;span&gt;5&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;));
erode(img, img2, element);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;腐蚀&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, img2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200216233814302-423917939.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3、开运算和闭运算&lt;/h2&gt;
&lt;p&gt;1）开运算就是先腐蚀后膨胀的过程，可以表示为：&lt;/p&gt;
&lt;p&gt;dst = open(src, element)&lt;/p&gt;
&lt;p&gt;dst = dilate(erode(dst, element))&lt;/p&gt;
&lt;p&gt;作用：用来消除小的物体，平滑形状边界，并且不改变其面积。可以去除小颗粒噪声，断开物体之间的粘连。&lt;/p&gt;
&lt;p&gt;2）闭运算是先膨胀后腐蚀的过程，可以表示为：&lt;/p&gt;
&lt;p&gt;dst = close(src, element)&lt;/p&gt;
&lt;p&gt;dst = erode(dilate (dst, element))&lt;/p&gt;
&lt;p&gt;作用：用来填充物体内的小空洞，连接邻近的物体，连接断开的轮廓线，平滑其边界的同时不改变面积。&lt;/p&gt;
&lt;p&gt;函数原型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
CV_EXPORTS_W &lt;span&gt;void&lt;/span&gt;&lt;span&gt; morphologyEx( InputArray src, OutputArray dst,
                                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; op, InputArray kernel,
                                Point anchor &lt;/span&gt;= Point(-&lt;span&gt;1&lt;/span&gt;,-&lt;span&gt;1&lt;/span&gt;), &lt;span&gt;int&lt;/span&gt; iterations = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;,
                                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; borderType =&lt;span&gt; BORDER_CONSTANT,
                                &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Scalar&amp;amp; borderValue = morphologyDefaultBorderValue() );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中第三个参数op代表形态学运算的类型，具体如下表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200216233858478-199152114.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
img = imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\WORK\\5.OpenCV\\LeanOpenCV\\pic_src\\pic7.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

img1 &lt;/span&gt;=&lt;span&gt; img.clone();
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img);
Mat element &lt;/span&gt;= getStructuringElement(MORPH_RECT, Size(&lt;span&gt;7&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;&lt;span&gt;));
morphologyEx(img, img2, MORPH_OPEN, element);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;开运算&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img2);
morphologyEx(img, img3, MORPH_CLOSE, element);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;闭运算&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, img3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;内核模板大小为Size（3,3）时测试如下图，开运算因为先做了腐蚀所以图片上的小白点都消失了。而闭运算因为先膨胀，所以小白点被放大了，再次腐蚀后也留了下来，并且有多个小白点连在了一起。此外闭运算图中细菌出现了互相连接的边缘，开运算细菌边缘间隔更加清晰。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200216233937623-884490245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内核模板大小为Size（7,7）时测试如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200216233959228-690182096.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4、形态学梯度&lt;/h2&gt;
&lt;p&gt;形态学梯度就是膨胀图与腐蚀图之差，梯度从原区域的膨胀中减去了原区域的收缩，保留了图像的外边缘部分，也就是图像的轮廓。&lt;/p&gt;
&lt;p&gt;可以表示为：&lt;/p&gt;
&lt;p&gt;dst = morpd_grad(src, element) = dilate (src, element) - erode(src, element)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200216234025835-149912290.png&quot; alt=&quot;&quot; width=&quot;613&quot; height=&quot;619&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;5、顶帽和黑帽&lt;/h2&gt;
&lt;p&gt;1）顶帽（Top Hat）：&lt;/p&gt;
&lt;p&gt;又称“礼帽”运算，原图像与开运算图的差，突出原图像中比周围亮的区域。&lt;/p&gt;
&lt;p&gt;因为开运算放大了裂缝或者局部低亮度的区域，再从原图中减去开运算后的图，就保留了比原图轮廓周围的区域更明亮的区域。顶帽运算往往用来分离比邻近点亮一些的斑块。当一幅图像具有大幅的背景的时候，而微小物品比较有规律的情况下，可以使用顶帽运算进行背景提取。&lt;/p&gt;
&lt;p&gt;2）黑帽（Black Hat）：&lt;/p&gt;
&lt;p&gt;闭操作图像减去原图像，突出原图像中比周围暗的区域。&lt;/p&gt;
&lt;p&gt;黑帽运算后的效果图突出了比原图轮廓周围的区域更暗的区域，此外黑帽还能得到图像内部的小孔，或者前景色中的小黑点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200216234104106-512257547.png&quot; alt=&quot;&quot; width=&quot;778&quot; height=&quot;266&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;6、高斯金字塔&lt;/h2&gt;
&lt;p&gt;图像金字塔是图像中多尺度表达的一种，最初用于机器视觉和图像压缩，金字塔的底部是高分辨率的图像，而顶部是低分辨率的近似，当向金字塔的上层移动时，尺寸和分辨率降低，伴随的细节就越少。低分辨率的图像主要用于分析大的结构或图像的整体内容，高分辨率图像适合分析单个物体的特性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200216234136043-494390282.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1）下采样：就是图片缩小，使用PryDown函数，先高斯模糊，再降采样。下采样将步骤：先对图像进行高斯内核卷积，再将所有偶数行和列去除，图像缩小到原来四分之一，迭代上述步骤就得到的金字塔。&lt;/p&gt;
&lt;p&gt;2）上采样：就是图片放大，使用PryUp函数。先将图像在每个方向扩大为原来的两倍，新增的行和列以0填充，再卷积得到放大后的图像。&lt;/p&gt;
&lt;p&gt;函数原型为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
CV_EXPORTS_W &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pyrUp( InputArray src, OutputArray dst,
                         &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Size&amp;amp; dstsize = Size(), &lt;span&gt;int&lt;/span&gt; borderType =&lt;span&gt; BORDER_DEFAULT );
CV_EXPORTS_W &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; pyrDown( InputArray src, OutputArray dst,
                          &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; Size&amp;amp; dstsize = Size(), &lt;span&gt;int&lt;/span&gt; borderType = BORDER_DEFAULT );
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
img = imread(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D:\\WORK\\5.OpenCV\\LeanOpenCV\\pic_src\\pic5.bmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;原图&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img);
pyrDown(img, img2, Size(img.cols &lt;/span&gt;* &lt;span&gt;2&lt;/span&gt;, img.rows * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上采样运算1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, img2);
pyrDown(img2, img3, Size(img2.cols &lt;/span&gt;* &lt;span&gt;2&lt;/span&gt;, img2.rows * &lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
imshow(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;上采样运算2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, img3);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上采样结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200216234241820-708190858.png&quot; alt=&quot;&quot; width=&quot;926&quot; height=&quot;495&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下采样结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/743748/202002/743748-20200216234301366-872418911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;7、参考文献&lt;/h2&gt;
&lt;p&gt;1、《OpenCV3 编程入门》，电子工业出版社，毛星雨著&lt;/p&gt;
&lt;p&gt;2、《学习OpenCV》，清华大学出版社，Gary Bradski， Adrian kaehler著&lt;/p&gt;
&lt;p&gt;3、图像金字塔（高斯金字塔、拉普拉斯金字塔）&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/sddai/p/10330756.html&quot;&gt;https://www.cnblogs.com/sddai/p/10330756.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4、图像金字塔&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.kancloud.cn/aollo/aolloopencv/272073&quot;&gt;https://www.kancloud.cn/aollo/aolloopencv/272073&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;5、Image Pyramids&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_pyramids/py_pyramids.html&quot;&gt;https://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_pyramids/py_pyramids.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;6、Image Pyramids&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.opencv.org/2.4/doc/tutorials/imgproc/pyramids/pyramids.html&quot;&gt;https://docs.opencv.org/2.4/doc/tutorials/imgproc/pyramids/pyramids.html&lt;/a&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;3.5368421052632&quot;&gt;
&lt;p&gt; 尊重原创技术文章，转载请注明。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/pingwen/p/12319629.html&quot;&gt;https://www.cnblogs.com/pingwen/p/12319629.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 16 Feb 2020 15:45:00 +0000</pubDate>
<dc:creator>啊哈彭</dc:creator>
<og:description>OpenCV3入门（七）图像形态学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pingwen/p/12319629.html</dc:identifier>
</item>
<item>
<title>Java并发编程-扩展可回调的Future - throwable</title>
<link>http://www.cnblogs.com/throwable/p/12319626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/12319626.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/7/1701d5f0e21f941b?w=816&amp;amp;h=629&amp;amp;f=png&amp;amp;s=39856&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;最近在看JUC线程池&lt;code&gt;java.util.concurrent.ThreadPoolExecutor&lt;/code&gt;的源码实现，其中了解到&lt;code&gt;java.util.concurrent.Future&lt;/code&gt;的实现原理。从目前&lt;code&gt;java.util.concurrent.Future&lt;/code&gt;的实现来看，虽然实现了异步提交任务，但是任务结果的获取过程需要主动调用&lt;code&gt;Future#get()&lt;/code&gt;或者&lt;code&gt;Future#get(long timeout, TimeUnit unit)&lt;/code&gt;，而前者是阻塞的，后者在异步任务执行时间不确定的情况下有可能需要进行轮询，这两种情况和异步调用的初衷有点相违背。于是笔者想结合目前了解到的&lt;code&gt;Future&lt;/code&gt;实现原理的前提下扩展出支持（监听）回调的&lt;code&gt;Future&lt;/code&gt;，思路上参考了&lt;code&gt;Guava&lt;/code&gt;增强的&lt;code&gt;ListenableFuture&lt;/code&gt;。本文编写的时候使用的JDK是JDK11，其他版本可能不适合。&lt;/p&gt;
&lt;h2 id=&quot;简单分析future的实现原理&quot;&gt;简单分析Future的实现原理&lt;/h2&gt;
&lt;h3 id=&quot;虚拟例子推演&quot;&gt;虚拟例子推演&lt;/h3&gt;
&lt;p&gt;并发大师&lt;strong&gt;Doug Lea&lt;/strong&gt;在设计JUC线程池的时候，提供了一个顶层执行器接口&lt;code&gt;Executor&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Executor {

    void execute(Runnable command);
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，这里定义的方法&lt;code&gt;Executor#execute()&lt;/code&gt;是整套线程池体系最核心的接口，也就是&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;定义的核心线程、额外创建的线程（线程池最大线程容量 - 核心线程数）都是在这个接口提交任务的时候懒创建的，也就是说&lt;code&gt;ExecutorService&lt;/code&gt;接口扩展的功能都是基于&lt;code&gt;Executor#execute()&lt;/code&gt;的基础进行扩展。&lt;code&gt;Executor#execute()&lt;/code&gt;方法只是单纯地把任务实例&lt;code&gt;Runnable&lt;/code&gt;对象投放到线程池中分配合适的线程执行，但是由于方法返回值是&lt;code&gt;void&lt;/code&gt;类型，我们是无法感知任务什么时候执行完毕。这个时候就需要对&lt;code&gt;Runnable&lt;/code&gt;任务实例进行包装（下面是伪代码 + 伪逻辑）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 下面这个Wrapper和Status类是笔者虚构出来
@RequiredArgsConstructor
class Wrapper implements Runnable{

    private final Runnable target;
    private Status status = Status.of(&quot;初始化&quot;);

    @Override
    public void run(){
        try{
           target.run();
           status = Status.of(&quot;执行成功&quot;);
        }catch(Throwable t){
           status = Status.of(&quot;执行异常&quot;); 
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只需要把&lt;code&gt;new Wrapper(原始Runnable实例)&lt;/code&gt;投放到线程池执行，那么通过定义好的&lt;code&gt;Status&lt;/code&gt;状态记录变量就能得知异步任务执行的状态，以及什么时候执行完毕（包括正常的执行完毕和异常的执行完毕）。这里仅仅解决了任务执行的状态获取，但是&lt;code&gt;Executor#execute()&lt;/code&gt;方法法返回值是&lt;code&gt;void&lt;/code&gt;类型的特点使得我们无法回调&lt;code&gt;Runnable&lt;/code&gt;对象执行的结果。这个时候需要定义一个可以回调执行结果的接口，其实已经有现成的接口&lt;code&gt;Callable&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface Callable&amp;lt;V&amp;gt; {

    V call() throws Exception;
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里遇到了一个问题：由于&lt;code&gt;Executor#execute()&lt;/code&gt;只接收&lt;code&gt;Runnable&lt;/code&gt;参数，我们需要把&lt;code&gt;Callable&lt;/code&gt;接口适配到&lt;code&gt;Runnable&lt;/code&gt;接口，这个时候，做一次简单的委托即可：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequiredArgsConstructor
class Wrapper implements Runnable{

    private final Callable callable;
    private Status status = Status.of(&quot;初始化&quot;);
    @Getter
    private Object outcome;

    @Override
    public void run(){
        try{
           outcome = callable.call();
           status = Status.of(&quot;执行成功&quot;);
        }catch(Throwable t){
           status = Status.of(&quot;执行异常&quot;); 
           outcome = t;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里把&lt;code&gt;Callable&lt;/code&gt;实例直接委托给&lt;code&gt;Wrapper&lt;/code&gt;，而&lt;code&gt;Wrapper&lt;/code&gt;实现了&lt;code&gt;Runnable&lt;/code&gt;接口，执行结果直接存放在定义好的&lt;code&gt;Object&lt;/code&gt;类型的对象&lt;code&gt;outcome&lt;/code&gt;中即可。当我们感知到执行状态已经结束，就可以从&lt;code&gt;outcome&lt;/code&gt;中提取到执行结果。&lt;/p&gt;
&lt;h3 id=&quot;future的实现&quot;&gt;Future的实现&lt;/h3&gt;
&lt;p&gt;上面一个小结仅仅对&lt;code&gt;Future&lt;/code&gt;实现做一个相对合理的虚拟推演，实际上，&lt;code&gt;RunnableFuture&lt;/code&gt;才是JUC中常用的复合接口，它同时实现了&lt;code&gt;Runnable&lt;/code&gt;和&lt;code&gt;Future&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface RunnableFuture&amp;lt;V&amp;gt; extends Runnable, Future&amp;lt;V&amp;gt; {
    
    void run();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上一节提到的虚构出来的&lt;code&gt;Wrapper&lt;/code&gt;类，在JUC中类似的实现是&lt;code&gt;java.util.concurrent.FutureTask&lt;/code&gt;，它就是&lt;code&gt;Callable&lt;/code&gt;和&lt;code&gt;Runnable&lt;/code&gt;的适配器，&lt;code&gt;FutureTask&lt;/code&gt;实现了&lt;code&gt;RunnableFuture&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FutureTask&amp;lt;V&amp;gt; implements RunnableFuture&amp;lt;V&amp;gt; {

    private volatile int state;
    private static final int NEW          = 0;
    private static final int COMPLETING   = 1;
    private static final int NORMAL       = 2;
    private static final int EXCEPTIONAL  = 3;
    private static final int CANCELLED    = 4;
    private static final int INTERRUPTING = 5;
    private static final int INTERRUPTED  = 6;

    /** The underlying callable; nulled out after running */
    private Callable&amp;lt;V&amp;gt; callable;
    /** The result to return or exception to throw from get() */
    private Object outcome; // non-volatile, protected by state reads/writes
    /** The thread running the callable; CASed during run() */
    private volatile Thread runner;
    /** Treiber stack of waiting threads */
    private volatile WaitNode waiters;
    
    // 省略其他代码
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意到核心属性&lt;code&gt;state&lt;/code&gt;表示执行状态，&lt;code&gt;outcome&lt;/code&gt;承载执行结果。接着看提交&lt;code&gt;Callable&lt;/code&gt;类型任务的方法&lt;code&gt;ExecutorService#submit()&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ExecutorService extends Executor {

    // 省略其他接口方法

    &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task);
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们通过上述&lt;code&gt;ExecutorService#submit()&lt;/code&gt;方法提交&lt;code&gt;Callable&lt;/code&gt;类型任务的时候，实际上做了如下的步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检查入参&lt;code&gt;task&lt;/code&gt;的存在性，如果为&lt;code&gt;null&lt;/code&gt;抛出&lt;code&gt;NullPointerException&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;把&lt;code&gt;Callable&lt;/code&gt;类型的&lt;code&gt;task&lt;/code&gt;包装为&lt;code&gt;FutureTask&lt;/code&gt;实例。&lt;/li&gt;
&lt;li&gt;把新建的&lt;code&gt;FutureTask&lt;/code&gt;实例放到线程池中执行，也就是调用&lt;code&gt;Executor#execute(FutureTask实例)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;返回&lt;code&gt;FutureTask&lt;/code&gt;实例的接口实例&lt;code&gt;RunnableFuture&lt;/code&gt;（实际上是返回子接口&lt;code&gt;Future&lt;/code&gt;实例）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果我们需要获取结果，可以&lt;code&gt;Future#get()&lt;/code&gt;或者&lt;code&gt;Future#get(long timeout, TimeUnit unit)&lt;/code&gt;获取，调用这两个方法的时候参看&lt;code&gt;FutureTask&lt;/code&gt;里面的方法实现，得知步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果状态&lt;code&gt;state&lt;/code&gt;小于等于&lt;code&gt;COMPLETING(1)&lt;/code&gt;，说明任务还在执行中，获取结果的请求线程会放入&lt;code&gt;WaitNode&lt;/code&gt;类型的队列中进行阻塞。&lt;/li&gt;
&lt;li&gt;如果任务执行完毕，不管异常完毕还是正常完毕，除了会更新状态&lt;code&gt;state&lt;/code&gt;和把结果赋值到&lt;code&gt;outcome&lt;/code&gt;之外，还会唤醒所有阻塞获取结果的线程，然后调用钩子方法&lt;code&gt;FutureTask#done()&lt;/code&gt;（具体见源码&lt;code&gt;FutureTask#finishCompletion()&lt;/code&gt;）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实分析了这么多，笔者想指出的结论就是：&lt;strong&gt;&lt;code&gt;Callable&lt;/code&gt;类型任务提交到线程池中执行完毕（包括正常执行完毕和异常执行完毕）之后，都会回调钩子方法&lt;code&gt;FutureTask#done()&lt;/code&gt;&lt;/strong&gt;。这个就是我们扩展可监听&lt;code&gt;Future&lt;/code&gt;的理论依据。&lt;/p&gt;
&lt;h2 id=&quot;扩展可回调的future&quot;&gt;扩展可回调的Future&lt;/h2&gt;
&lt;p&gt;先做一次编码实现，再简单测试其功能。&lt;/p&gt;
&lt;h3 id=&quot;编码实现&quot;&gt;编码实现&lt;/h3&gt;
&lt;p&gt;先定义一个&lt;code&gt;Future&lt;/code&gt;接口的子接口&lt;code&gt;ListenableFuture&lt;/code&gt;，用于添加可监听的回调：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ListenableFuture&amp;lt;V&amp;gt; extends Future&amp;lt;V&amp;gt; {

    void addCallback(ListenableFutureCallback&amp;lt;V&amp;gt; callback, Executor executor);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ListenableFutureCallback&lt;/code&gt;是一个函数式回调接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface ListenableFutureCallback&amp;lt;V&amp;gt; {

    void callback(V value, Throwable throwable);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;ListenableFutureCallback&lt;/code&gt;而言，回调的结果&lt;code&gt;value&lt;/code&gt;和&lt;code&gt;throwable&lt;/code&gt;是互斥的。正常执行完毕的情况下&lt;code&gt;value&lt;/code&gt;将会是执行结果值，&lt;code&gt;throwable&lt;/code&gt;为&lt;code&gt;null&lt;/code&gt;；异常执行完毕的情况下，&lt;code&gt;value&lt;/code&gt;将会是&lt;code&gt;null&lt;/code&gt;，&lt;code&gt;throwable&lt;/code&gt;将会是抛出的异常实例。如果更习惯于分开处理正常执行完毕的结果和异常执行完毕的结果，&lt;code&gt;ListenableFutureCallback&lt;/code&gt;可以这样定义：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ListenableFutureCallback&amp;lt;V&amp;gt; {

    void onSuccess(V value);

    void onError(Throwable throwable);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着定义&lt;code&gt;ListenableExecutorService&lt;/code&gt;接口继承&lt;code&gt;ExecutorService&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ListenableExecutorService extends ExecutorService {

    &amp;lt;T&amp;gt; ListenableFuture&amp;lt;T&amp;gt; listenableSubmit(Callable&amp;lt;T&amp;gt; callable);

    /**
     * 定义这个方法是因为有些时候由于任务执行时间非常短，有可能通过返回的ListenableFuture实例添加回调之前已经执行完毕，因此可以支持显式传入回调
     *
     * @param callable  callable
     * @param callbacks callbacks
     * @param executor  executor
     * @return ListenableFuture
     */
    &amp;lt;T&amp;gt; ListenableFuture&amp;lt;T&amp;gt; listenableSubmit(Callable&amp;lt;T&amp;gt; callable, List&amp;lt;ListenableFutureCallback&amp;lt;T&amp;gt;&amp;gt; callbacks, Executor executor);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后添加一个执行单元适配器&lt;code&gt;ListenableFutureCallbackRunnable&lt;/code&gt;，承载每次回调触发的调用（实现&lt;code&gt;Runnable&lt;/code&gt;接口，从而支持异步执行）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequiredArgsConstructor
public class ListenableFutureCallbackRunnable&amp;lt;V&amp;gt; implements Runnable {

    private final ListenableFutureCallback&amp;lt;V&amp;gt; callback;
    private final V value;
    private final Throwable throwable;

    @Override
    public void run() {
        callback.callback(value, throwable);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着需要定义一个&lt;code&gt;FutureTask&lt;/code&gt;的子类&lt;code&gt;ListenableFutureTask&lt;/code&gt;，核心逻辑是覆盖&lt;code&gt;FutureTask#done()&lt;/code&gt;方法触发回调：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// ListenableFutureTask
public class ListenableFutureTask&amp;lt;V&amp;gt; extends FutureTask&amp;lt;V&amp;gt; implements ListenableFuture&amp;lt;V&amp;gt; {

    private final List&amp;lt;Execution&amp;lt;V&amp;gt;&amp;gt; executions = new ArrayList&amp;lt;&amp;gt;();

    public ListenableFutureTask(Callable&amp;lt;V&amp;gt; callable) {
        super(callable);
    }

    public ListenableFutureTask(Runnable runnable, V result) {
        super(runnable, result);
    }

    public static &amp;lt;V&amp;gt; ListenableFutureTask&amp;lt;V&amp;gt; newTaskFor(Callable&amp;lt;V&amp;gt; callable) {
        return new ListenableFutureTask&amp;lt;&amp;gt;(callable);
    }

    @Override
    protected void done() {
        Iterator&amp;lt;Execution&amp;lt;V&amp;gt;&amp;gt; iterator = executions.iterator();
        Throwable throwable = null;
        V value = null;
        try {
            value = get();
        } catch (Throwable t) {
            throwable = t;
        }
        while (iterator.hasNext()) {
            Execution&amp;lt;V&amp;gt; execution = iterator.next();
            ListenableFutureCallbackRunnable&amp;lt;V&amp;gt; callbackRunnable = new ListenableFutureCallbackRunnable&amp;lt;&amp;gt;(execution.getCallback(),
                    value, throwable);
            // 异步回调
            if (null != execution.getExecutor()) {
                execution.getExecutor().execute(callbackRunnable);
            } else {
                // 同步回调
                callbackRunnable.run();
            }
        }
    }

    @Override
    public void addCallback(ListenableFutureCallback&amp;lt;V&amp;gt; callback, Executor executor) {
        Execution&amp;lt;V&amp;gt; execution = new Execution&amp;lt;&amp;gt;();
        execution.setCallback(callback);
        execution.setExecutor(executor);
        executions.add(execution);
    }
}

// Execution - 承载每个回调实例和对应的Executor，Executor实例为null则进行同步回调
@Data
public class Execution &amp;lt;V&amp;gt;{

    private Executor executor;
    private ListenableFutureCallback&amp;lt;V&amp;gt; callback;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后一步就是编写线程池&lt;code&gt;ListenableThreadPoolExecutor&lt;/code&gt;，继承自&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;并且实现&lt;code&gt;ListenableExecutorService&lt;/code&gt;接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ListenableThreadPoolExecutor extends ThreadPoolExecutor implements ListenableExecutorService {

    public ListenableThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&amp;lt;Runnable&amp;gt; workQueue) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);
    }

    public ListenableThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, 
    BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);
    }

    public ListenableThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, 
    BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);
    }

    public ListenableThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit,
     BlockingQueue&amp;lt;Runnable&amp;gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {
        super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);
    }

    @Override
    public &amp;lt;T&amp;gt; ListenableFuture&amp;lt;T&amp;gt; listenableSubmit(Callable&amp;lt;T&amp;gt; callable) {
        if (null == callable) {
            throw new IllegalArgumentException(&quot;callable&quot;);
        }
        ListenableFutureTask&amp;lt;T&amp;gt; listenableFutureTask = ListenableFutureTask.newTaskFor(callable);
        execute(listenableFutureTask);
        return listenableFutureTask;
    }

    @Override
    public &amp;lt;T&amp;gt; ListenableFuture&amp;lt;T&amp;gt; listenableSubmit(Callable&amp;lt;T&amp;gt; callable, List&amp;lt;ListenableFutureCallback&amp;lt;T&amp;gt;&amp;gt; callbacks, Executor executor) {
        if (null == callable) {
            throw new IllegalArgumentException(&quot;callable&quot;);
        }
        if (null == callbacks) {
            throw new IllegalArgumentException(&quot;callbacks&quot;);
        }
        ListenableFutureTask&amp;lt;T&amp;gt; listenableFutureTask = ListenableFutureTask.newTaskFor(callable);
        for (ListenableFutureCallback&amp;lt;T&amp;gt; callback : callbacks) {
            listenableFutureTask.addCallback(callback, executor);
        }
        execute(listenableFutureTask);
        return listenableFutureTask;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;引入&lt;code&gt;junit&lt;/code&gt;，编写测试类如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ListenableFutureTest {

    private static ListenableExecutorService EXECUTOR;
    private static Executor E;

    @BeforeClass
    public static void before() {
        EXECUTOR = new ListenableThreadPoolExecutor(1, 3, 0, TimeUnit.SECONDS,
                new ArrayBlockingQueue&amp;lt;&amp;gt;(10), new ThreadFactory() {

            private final AtomicInteger counter = new AtomicInteger();

            @Override
            public Thread newThread(Runnable r) {
                Thread thread = new Thread(r);
                thread.setDaemon(true);
                thread.setName(String.format(&quot;ListenableWorker-%d&quot;, counter.getAndIncrement()));
                return thread;
            }
        });
        E = Executors.newFixedThreadPool(3);
    }

    @Test
    public void testListenableFuture1() throws Exception {
        ListenableFuture&amp;lt;String&amp;gt; future = EXECUTOR.listenableSubmit(() -&amp;gt; {
            Thread.sleep(1000);
            return &quot;message&quot;;
        });
        future.addCallback((v, t) -&amp;gt; {
            System.out.println(String.format(&quot;Value = %s,Throwable = %s&quot;, v, t));
        }, null);
        Thread.sleep(2000);
    }

    @Test
    public void testListenableFuture2() throws Exception {
        ListenableFuture&amp;lt;String&amp;gt; future = EXECUTOR.listenableSubmit(() -&amp;gt; {
            Thread.sleep(1000);
            throw new RuntimeException(&quot;exception&quot;);
        });
        future.addCallback((v, t) -&amp;gt; {
            System.out.println(String.format(&quot;Value = %s,Throwable = %s&quot;, v, t));
        }, null);
        Thread.sleep(2000);
    }

    @Test
    public void testListenableFuture3() throws Exception {
        ListenableFuture&amp;lt;String&amp;gt; future = EXECUTOR.listenableSubmit(() -&amp;gt; {
            Thread.sleep(1000);
            return &quot;message&quot;;
        });
        future.addCallback((v, t) -&amp;gt; {
            System.out.println(String.format(&quot;Value = %s,Throwable = %s&quot;, v, t));
        }, E);
        System.out.println(&quot;testListenableFuture3 end...&quot;);
        Thread.sleep(2000);
    }

    @Test
    public void testListenableFuture4() throws Exception {
        ListenableFuture&amp;lt;String&amp;gt; future = EXECUTOR.listenableSubmit(() -&amp;gt; {
            Thread.sleep(1000);
            throw new RuntimeException(&quot;exception&quot;);
        });
        future.addCallback((v, t) -&amp;gt; {
            System.out.println(String.format(&quot;Value = %s,Throwable = %s&quot;, v, t));
        }, E);
        System.out.println(&quot;testListenableFuture4 end...&quot;);
        Thread.sleep(2000);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;// testListenableFuture1
Value = message,Throwable = null

// testListenableFuture2
Value = null,Throwable = java.util.concurrent.ExecutionException: java.lang.RuntimeException: exception

// testListenableFuture3
testListenableFuture3 end...
Value = message,Throwable = null

// testListenableFuture4
testListenableFuture4 end...
Value = null,Throwable = java.util.concurrent.ExecutionException: java.lang.RuntimeException: exception&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和预期的结果一致，注意一下如果&lt;code&gt;Callable&lt;/code&gt;执行抛出异常，异常被包装为&lt;code&gt;ExecutionException&lt;/code&gt;，要调用&lt;code&gt;Throwable#getCause()&lt;/code&gt;才能得到原始的异常实例。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文通过了解&lt;code&gt;ThreadPoolExecutor&lt;/code&gt;和&lt;code&gt;Future&lt;/code&gt;的实现原理做简单的扩展，使得异步提交任务变得更加优雅和简便。强化了动手能力的同时，也能加深对并发编程的一些认知。当然，本文只是提供一个十分简陋的实现，笔者其实还想到了如对回调处理的耗时做监控、回调打上分组标签执行等等更完善的功能，等到有需要的场景再进行实现。&lt;/p&gt;
&lt;p&gt;这里记录一下过程中的一些领悟：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Executor#execute()&lt;/code&gt;是线程池的核心接口，所有其他功能都是基于此接口做扩展，它的设计本身是无状态的。&lt;/li&gt;
&lt;li&gt;灵活使用适配器模式，可以在不改变已发布的接口的功能同时实现新的接口的功能适配。&lt;/li&gt;
&lt;li&gt;要善于发掘和使用JDK类库设计者留给开发者的扩展接口。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;个人博客&quot;&gt;个人博客&lt;/h2&gt;
&lt;p&gt;（本文完 c-1-d e-a-20190702）&lt;/p&gt;
</description>
<pubDate>Sun, 16 Feb 2020 15:42:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 最近在看JUC线程池 的源码实现，其中了解到 的实现原理。从目前 的实现来看，虽然实现了异步提交任务，但是任务结果的获取过程需要主动调用 或者 ，而前者是阻塞的，后者在异步任务执行时间不确定的情</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/throwable/p/12319626.html</dc:identifier>
</item>
<item>
<title>以“一个公式” 的角度理解原型链 - TensionMax</title>
<link>http://www.cnblogs.com/TensionMax/p/12319472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TensionMax/p/12319472.html</guid>
<description>&lt;p&gt;&lt;strong&gt;米娜桑，哦哈哟~&lt;/strong&gt;&lt;br/&gt;原型链，已经是一个老生常谈的话题了，这里就不过多总结，精华一张图就可以搞定。该文章更多的是从 &lt;strong&gt;一个公式&lt;/strong&gt; 的角度讲述原型链。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;补充说明&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;实例化&lt;/strong&gt;：用类（&lt;strong&gt;class&lt;/strong&gt;）创建对象（&lt;strong&gt;obj&lt;/strong&gt;）的过程。&lt;br/&gt;如：&lt;code&gt;TensionMax = new Person()&lt;/code&gt;，那么 &lt;code&gt;TensionMax&lt;/code&gt; 是 &lt;code&gt;Person&lt;/code&gt; 的实例（对象）。&lt;br/&gt;但由于 JavaScript 并不存在类，所以 JavaScript 所谓的类，只是我们模拟出来的函数，最终还是基于原型构建。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下 3 个观点只是为了更方便快捷地理解原型链，切勿对号入座&lt;/strong&gt;。其中依然存在着先有鸡还是先有蛋的问题。对于单纯的开发者来说，感兴趣或者时间充裕的话可以深究，已附上友情链接于本章结尾。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;先上结论&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1、&lt;strong&gt;obj.proto === class.prototype&lt;/strong&gt;&lt;br/&gt;满足此式子时，我们可以把 &lt;strong&gt;obj&lt;/strong&gt; 称之为 &lt;strong&gt;class&lt;/strong&gt; 实例出来的对象。&lt;/p&gt;
&lt;p&gt;2、&lt;strong&gt;obj&lt;/strong&gt; 上属性的查找会以 &lt;code&gt;__proto__&lt;/code&gt; 链条的方式进行查找，直到为 &lt;code&gt;null&lt;/code&gt; 时终止。&lt;/p&gt;
&lt;p&gt;3、以第 1 点为理解导向，原型链的终点是 &lt;code&gt;Object.prototype&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;class.prototype-obj.__proto__&quot;&gt;1、class.prototype === obj.__proto__&lt;/h3&gt;
&lt;p&gt;这条就当作是一个公式。满足这一条，那么我们可以把 &lt;strong&gt;&lt;code&gt;obj&lt;/code&gt;&lt;/strong&gt; 当作 &lt;strong&gt;&lt;code&gt;class&lt;/code&gt;&lt;/strong&gt; 实例出来的对象。&lt;br/&gt;当我们实例出 &lt;strong&gt;Person&lt;/strong&gt; 即 &lt;code&gt;let Tension = new Person()&lt;/code&gt;，其中的关系图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://segmentfault.com/img/bVbDtwr&quot; alt=&quot;11.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let Person = function (name, age) {
    this.name = name
    this.age = age
    this.race = 'human'
}
Person.prototype.country = 'China'

console.log(Person.prototype) 
//输出{country: 'China', constructor: Person}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说 &lt;strong&gt;Person.prototype.constructor === Person&lt;/strong&gt;&lt;br/&gt;创建函数时，函数会自带特有的属性 &lt;code&gt;prototype&lt;/code&gt; 。&lt;br/&gt;而当实例 &lt;strong&gt;Person&lt;/strong&gt; 时&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let TensionMax = new Person('huang', 10) 

console.log(TensionMax) //{name: 'huang', age: 10, race: 'human'}
console.log(TensionMax.country) //China
console.log(TensionMax.__proto__.country) //China&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;换句话而言，&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new&quot;&gt;new 操纵符&lt;/a&gt; 实际做了以下的事情。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let TensionMax = {} //即 new Object()
TensionMax.__proto__ = Person.prototype

Person.call(TensionMax)
//call在这里的作用是将 Person 的 this 值拷贝到 TensionMax 对象中。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是说，当实例化对象后，对象 &lt;code&gt;TensionMax&lt;/code&gt; 和对应的类 &lt;code&gt;Person&lt;/code&gt; 通过 &lt;code&gt;__proto__&lt;/code&gt; 来链接。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;obj-的属性会以-proto-链条的方式进行查找直到为-null-时终止&quot;&gt;2、obj 的属性会以 &quot;&lt;strong&gt;proto&lt;/strong&gt;&quot; 链条的方式进行查找，直到为 null 时终止&lt;/h3&gt;
&lt;p&gt;根据上述的关系图，如果一直根据 &lt;strong&gt;&lt;code&gt;__proto__&lt;/code&gt;&lt;/strong&gt; 这个链条查找，会有一个终点。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.log(TensionMax.__proto__.__proto__.__proto__) //null

(TensionMax.__proto__).__proto__ === Object.prototype //true&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据第 1 点的公式，&lt;code&gt;TensionMax.__proto__&lt;/code&gt; 即 &lt;code&gt;Person.prototype&lt;/code&gt; 为 &lt;strong&gt;Object&lt;/strong&gt; 函数这个类实例出来的对象。最终到达终点 &lt;strong&gt;Object.prototype&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://segmentfault.com/img/bVbDtwG&quot; alt=&quot;22.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;console.log(Object.prototype.prototype) //undefined
console.log(Object.prototype.__proto__) //null&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h3 id=&quot;原型链的终点是-object.prototype&quot;&gt;3、原型链的终点是 Object.prototype&lt;/h3&gt;
&lt;p&gt;以第 1 点为理解导向，原型链的终点是 &lt;strong&gt;&lt;code&gt;Object.prototype&lt;/code&gt;&lt;/strong&gt;，那么有如下关系：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;Tension&lt;/strong&gt; 为 &lt;strong&gt;Person&lt;/strong&gt; 的实例对象&lt;br/&gt;&lt;strong&gt;Person&lt;/strong&gt; 为 &lt;strong&gt;Function&lt;/strong&gt; 的实例对象&lt;br/&gt;&lt;strong&gt;Person.prototype&lt;/strong&gt; 为 &lt;strong&gt;Object&lt;/strong&gt; 的实例对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function&lt;/strong&gt; 为 &lt;strong&gt;Function&lt;/strong&gt; 的实例对象&lt;br/&gt;&lt;strong&gt;Object&lt;/strong&gt; 为 &lt;strong&gt;Function&lt;/strong&gt; 的实例对象&lt;br/&gt;&lt;strong&gt;Function.prototype&lt;/strong&gt; 为 &lt;strong&gt;Object&lt;/strong&gt; 的实例对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://segmentfault.com/img/bVbDtwV&quot; alt=&quot;33.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据第 &lt;strong&gt;1&lt;/strong&gt; 点的公式，以 &lt;code&gt;__proto__&lt;/code&gt; 箭头为导向可以看出，先有 &lt;strong&gt;&lt;code&gt;Object.prototype&lt;/code&gt;&lt;/strong&gt;，由之诞生 &lt;strong&gt;&lt;code&gt;Function.prototype&lt;/code&gt;&lt;/strong&gt;，随后才有了 &lt;strong&gt;Function&lt;/strong&gt; 和 &lt;strong&gt;Object&lt;/strong&gt;。&lt;br/&gt;那么 &lt;strong&gt;Function&lt;/strong&gt; 和 &lt;strong&gt;Object&lt;/strong&gt; 谁先有，还有待深究。&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;相关参考&quot;&gt;相关参考&lt;/h3&gt;
</description>
<pubDate>Sun, 16 Feb 2020 15:33:00 +0000</pubDate>
<dc:creator>TensionMax</dc:creator>
<og:description>米娜桑，哦哈哟~ 原型链，已经是一个老生常谈的话题了，这里就不过多总结，精华一张图就可以搞定。该文章更多的是从 一个公式 的角度讲述原型链。 补充说明 实例化 ：用类（ class ）创建对象（ ob</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/TensionMax/p/12319472.html</dc:identifier>
</item>
<item>
<title>微信小程序开发技巧总结（二） --  文件的选取、移动、上传和下载 - Kindear_chen</title>
<link>http://www.cnblogs.com/masterchd/p/12319440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/masterchd/p/12319440.html</guid>
<description>&lt;h4 id=&quot;微信小程序开发技巧总结二----文件的选取移动上传和下载&quot;&gt;微信小程序开发技巧总结（二） -- 文件的选取、移动、上传和下载&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;1.不同类型文件的选取&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.1 常用的图片 视频&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于大部分开发者来说，需要上传的文件形式主要为图片，微信为此提供了接口。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;wx.chooseImage({
  count: 1,
  sizeType: ['original', 'compressed'],
  sourceType: ['album', 'camera'],
  success (res) {
    // tempFilePath可以作为img标签的src属性显示图片
    const tempFilePaths = res.tempFilePaths
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次为视频文件的选取，微信也为此提供了接口。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;wx.chooseVideo({
  sourceType: ['album','camera'],
  maxDuration: 60, //视频长度 单位 s
  camera: 'back', //选取前置  摄像 还是 后置 摄像
  success(res) {
    console.log(res.tempFilePath)
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也为其提供了视频和图片的二合一接口，这个接口不建议调用，图片和视频的上传建议区分开。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;wx.chooseMedia({
  count: 9,
  mediaType: ['image','video'],
  sourceType: ['album', 'camera'],
  maxDuration: 30,
  camera: 'back',
  success(res) {
    console.log(res.tempFilePath)con
    console.log(res.size)
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这几个接口调用成功的回调函数中，都返回的是文件在文件在本机中的路径。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;res.tempFilePath&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个 数组，存放着选择的所有文件的路径，用于上传。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2 其余形式各种文档&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么如果是想要在小程序中上传 doc、pdf、ppt 等类型的文件怎么处理？首先要注意的是微信小程序并没有给用户提供文件管理器接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;开发者：我想要个文件管理器接口！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;官方：不，你不想&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;聪明的开发者他没有办法，只能另辟蹊径。微信提供了一个选择客户端会话文件的方法。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;wx.chooseMessageFile({
   success(res){
       console.log(res.tempFilePath)
    }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与上面两个接口相同，返回的也是文件在本地的存储路径，但是不同的是，这个接口可以选取全部的文件类型。&lt;/p&gt;
&lt;p&gt;开发者如果想要上传非图片和视频内容的话，需要两步走。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开微信文件传输助手，将想要上传的文件发送到文件传输助手&lt;/li&gt;
&lt;li&gt;在小程序中调用这个接口，选择文件传输助手，从会话中选择想要上传的文件。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1141382/202002/1141382-20200216204319121-903655157.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1141382/202002/1141382-20200216204814139-710426635.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2.文件的上传&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;2.1 uploadFile方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有的文件都是以字节流的形式进行上传，所以上传形式并没有什么本质区别，都是调用相应的接口进行上传。&lt;/p&gt;
&lt;p&gt;小程序端写法如下：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;wx.uploadFile({
      url: '你的服务器函数地址', //仅为示例，非真实的接口地址
      filePath: '需要上传的文件路径', //res.tempFilepaths
      name: 'file', // 文件对应的key ，默认 为 file
      formData: {
        'user': 'test'
      }, //上传额外携带的参数
      success (res){
        const data = res.data
        //do something
      }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.2 服务器端如何处理上传的文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务端如何接受文件的上传？仅展示Java方式（SpringBoot 框架）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
@ResponseBody
public class FileController {
    //文件上传控制类,是核心配置类，Win &amp;lt;-&amp;gt;Linux
    @RequestMapping(value = &quot;/upload/images&quot;)
    public String uploadimages(HttpServletRequest request,@RequestParam(&quot;file&quot;) MultipartFile file, @RequestParam(&quot;user&quot;) String user) throws IOException {
       //更换服务器，这个值也需要修改
        //图片上传写法
        //type 是上传图片的类型
        if(!file.isEmpty()){
            //文件不为空
            //String path = &quot;E:&quot;+File.separator+&quot;images&quot;+File.separator+type; // this is windows method
            String path = &quot;/share&quot;+File.separator+&quot;images&quot;+File.separator+type;
            // this is Linux method
            String filename = file.getOriginalFilename();
            File filepath = new File(path,filename);//新建文件存储路径
            System.out.println(filepath);
            if(!filepath.getParentFile().mkdirs()){
                filepath.getParentFile().mkdirs();
            }
            file.transferTo(new File(path+File.separator+filename));
           //想要返回可直接访问的链接还要配置 映射，具体请看下面链接
            return &quot;你的IP地址&quot;+&quot;/images/&quot;+type+&quot;/&quot;+filename;
        }else {
            return &quot;error&quot;;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置访问映射&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/masterchd/p/12171492.html&quot;&gt;文件访问映射&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3 云开发文件上传&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;微信小程序支持云开发，其文件上传接口有一些差异，但是不需要自己再构建后台。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;wx.cloud.uploadFile({
  cloudPath: 'file/' + '你的文件名字（带格式后缀）', // 在云端存储的路径
  filePath: '', // 就是选择文件返回的路径
}).then(res =&amp;gt; {
  // get resource ID
  console.log(res.fileID)
}).catch(error =&amp;gt; {
  // handle error
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以根据返回的fileID 置换 真实的文件访问地址。&lt;/p&gt;
&lt;p&gt;其置换方式参见官方文档：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;wx.cloud.getTempFileURL({
  fileList: ['cloud://xxx', 'cloud://yyy'],
  success: res =&amp;gt; {
    // get temp file URL
    console.log(res.fileList)
  },
  fail: err =&amp;gt; {
    // handle error
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;TIPS：关于云开发文件上传的建议&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果没有保密需求，为了方便后续开发，存储到数据库中的最好是可以直接访问的文件链接。&lt;/li&gt;
&lt;li&gt;置换真实文件地址，不要每次上传一次文件就置换一次，先把返回的fileID 存放在数组中，到该事务所有上传完成后，再使用fileID 数组置换真实文件访问链接数组。&lt;/li&gt;
&lt;li&gt;要考虑文件名重复的可能，建议使用时间戳在 wx.cloud.uploadFile 中的 cloudPath 中对存储到云环境中的文件命名进行格式化。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;总的来说就是先上传文件，再向数据库中写入记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.4 多文件同时上传的处理方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;uploadFile 每次只能上传一个文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如何处理这个问题？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;A.不考虑文件的上传次序问题，可以采用遍历上传的方式，采用精确的时间戳和遍历index对文件名进行格式化。通过定时触发检测函数判断是否全部上传完成。这种方式考虑的是并发能力。&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;upSeveralfiles() {
      wx.showLoading({
        title: '上传中~',
        mask: true
      })
      var that = this;
      var timecode = sev.vcode(new Date()); // 这是时间戳编码函数
      var files = this.data.fileList;       // 这是 选择文件中返回的 res.tempFilePath 数组
      var len = files.length;
      var i = 0;
      for (i = 0; i &amp;lt; len; i++) {
        var str = files[i].name;
        wx.cloud.uploadFile({
          cloudPath: 'file/' + '(' + sev.getformatTime(new Date()) + ')' + str,
          filePath: files[i].path,
          success(res) {
            console.log(res)
            that.setData({
              cloudlist: that.data.cloudlist.concat([res.fileID]),

            })
             // cloudlist 是存放 文件链接置换id 的数组 , 非云开发存储的就是真实可访问的链接数组
             // 如果使用的不是云开发 那么 可以返回真实的 访问地址
          },
          fail(res) {
            console.log(res)
          }
        })
      }
    // 使用定时器检测文件是否全部上传完成 , 并 判断是否进行下一步 操作
      var timer = setInterval(function () {
        if (that.data.cloudlist.length == len) {
          // 只有全部上传成功了 长度才会相等
          clearInterval(timer);
          // 继续执行下一步 ，根据 cloudlist 置换真实地址 并存放到数据库
          //　如果使用的非云开发，那么就继续执行　存储至数据库的操作
        }
      }, 1000)
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;补充文件编码函数 sev.js 中的根据时间编码部分 , 可以根据实际流量自定义。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function getformatTime(date) {
  var year = date.getFullYear()
  var month = date.getMonth() + 1
  var day = date.getDate()

  var hour = date.getHours()
  var minute = date.getMinutes()
  var second = date.getSeconds()

  return [year, month, day].map(formatNumber).join('-');
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;B.考虑文件的上传次序问题,采用回调方式进行文件上传(更推荐使用这种方式)&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;data: {
    fileList: [],
    realList: [],//云端地址链接列表
    fileid: 0,
 },
upSeveralfiles() {
    var that = this;
    var files = this.data.fileList;       // 这是 选择文件中返回的 res.tempFilePath 数组
    var len = files.length;
    var uid = this.data.fileid;
    wx.uploadFile({
      url: '你的服务器文件接收函数请求地址',
      name: 'file',
      filePath: files[uid],
      header: {
        &quot;Content-Type&quot;: &quot;multipart/form-data&quot;
      },
      success(res) {
        that.setData({
          fileid: uid + 1,
          realList: that.data.realList.concat([res.data])
        }, () =&amp;gt; {
          if (that.data.fileid == len) {
            // 上传完成 ,执行下一步操作
              
          } else {
              //上传完一个文件 递归执行 下次上传
            that.upSeveralfiles();
          }
        })
      }, fail(res) {
        console.log(res.data)
      }
    })

  },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是提供的两种思路 , 无论是不是云开发 , 两种思路都是共通的,适用于多文件上传.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;文件的下载&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;这个地方唯一值得注意的是云开发的一种下载方式 可以通过fileID进行download , 当然只能下载存储在自己云环境中的文件.&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;wx.cloud.downloadFile({
  fileID: '',
  success: res =&amp;gt; {
    console.log(res.tempFilePath)
  },
  fail: err =&amp;gt; {
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;wx.downloadFile({
  url: '', //仅为示例，并非真实的资源
  success (res) {
     //res.tempFilePath
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载进度监控 , 用于下载进度条绘制等功能实现&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const downloadTask = wx.cloud.downloadFile({ *** }) // wx.downloadFile 同理
downloadTask.onProgressUpdate((res) =&amp;gt; {
    //res.progress 为下载进度
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载下来的文件支持直接打开,就像是在微信聊天中打开一样，需要下载插件。&lt;/p&gt;
&lt;p&gt;其使用方式为:&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;wx.openDocument({
     filePath: res.tempFilePath //为文件路径 非数组 , 可使用回调函数 success 等
})&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;文件的移动&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;这个一般情况下是用不到的, 也不建议使用移动文件的方法作为功能实现手段 ,必然有更好的替代方式,比如修改数据库路径 和 真实文件路径的映射, 效率更高一些.&lt;/p&gt;
&lt;p&gt;这里仅讲云开发移动文件方式。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const cloud = require('wx-server-sdk')
const fs = require('fs')
const path = require('path')

cloud.init({
  env: cloud.DYNAMIC_CURRENT_ENV
})

exports.main = async (event, context) =&amp;gt; {
  const fileStream = fs.createReadStream(path.join(__dirname, 'demo.jpg'))
  //这个可以读取 云存储 中的文件 ， 所谓删除 就是复制 然后 删除原位置文件
  return await cloud.uploadFile({
    cloudPath: 'demo.jpg',
    fileContent: fileStream,
  })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/wxcloud/reference-sdk-api/storage/uploadFile/server.uploadFile.html&quot;&gt;具体开发文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;建议在数据库中修改映射路径最好。&lt;/p&gt;
&lt;p&gt;需要小程序开发的请联系我QQ ： &lt;strong&gt;1025584691&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 16 Feb 2020 15:25:00 +0000</pubDate>
<dc:creator>Kindear_chen</dc:creator>
<og:description>微信小程序开发技巧总结（二） 文件的选取、移动、上传和下载 1.不同类型文件的选取 1.1 常用的图片 视频 对于大部分开发者来说，需要上传的文件形式主要为图片，微信为此提供了接口。 ~~~javas</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/masterchd/p/12319440.html</dc:identifier>
</item>
<item>
<title>技术|Android安装包优化 - 赵裕(vimerzhao)</title>
<link>http://www.cnblogs.com/zhaoyu1995/p/12319360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaoyu1995/p/12319360.html</guid>
<description>&lt;blockquote readability=&quot;7.7546583850932&quot;&gt;
&lt;p&gt;版权声明&lt;/p&gt;&lt;p&gt;1.本文版权归原作者所有，转载需注明作者信息及原文出处。&lt;/p&gt;&lt;p&gt;2.本文作者：赵裕(vimerzhao),永久链接：&lt;a href=&quot;https://github.com/vimerzhao/vimerzhao.github.io/blob/master/android/2020-02-11-apk-size-opt.md&quot; class=&quot;uri&quot;&gt;https://github.com/vimerzhao/vimerzhao.github.io/blob/master/android/2020-02-11-apk-size-opt.md&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;3.作者公众号：&lt;strong&gt;V大师在一号线&lt;/strong&gt; 。联系邮箱：&lt;code&gt;vimerzhao@foxmail.com&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;h3 id=&quot;安装包膨胀的原因&quot;&gt;安装包膨胀的原因&lt;/h3&gt;
&lt;p&gt;业务的增加、产品的演进是安装包大小增加的本质原因。但是在演进之路上，由于一些所谓的技术债务，如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用的资源未经裁剪（如全量字体文件、分辨率过大的图片）&lt;/li&gt;
&lt;li&gt;不合理的大资源（如大的视频、音频可以在线拉取）&lt;/li&gt;
&lt;li&gt;已下线业务没有及时清理相关代码、资源&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正是由于这些疏忽，安装包有了不必要的增加，这也是我们需要优化的部分。&lt;/p&gt;
&lt;h3 id=&quot;安装包优化的价值&quot;&gt;安装包优化的价值&lt;/h3&gt;
&lt;p&gt;可能有的人觉得，现在基本是4G、WiFi的网络环境，手机设备的性能和存储空间也非常充足，所以用户对安装包大小应该不是十分敏感。但是，这其实是一种错觉，更多的时候应该看自己的目标市场，如果是一二线城市当然没问题，但如果是三四线城市、农村等下沉市场或者印度、巴西等海外市场，上述假设显然不成立了。&lt;/p&gt;
&lt;p&gt;一般来说，安装包大小会影响以下指标：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;下载转化率&lt;/li&gt;
&lt;li&gt;安装成功率&lt;/li&gt;
&lt;li&gt;推广成本&lt;/li&gt;
&lt;li&gt;运行内存、空间占用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综上，对于一个“有余力”的团队，安装包大小的优化还是很有必要的。&lt;/p&gt;
&lt;h3 id=&quot;安装包优化的套路&quot;&gt;安装包优化的套路&lt;/h3&gt;
&lt;p&gt;由前面的原因可知，从业务层面来看，安装包大小的优化是“解铃还须系铃人”，即：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;压缩资源&lt;/li&gt;
&lt;li&gt;大资源转成在线拉取&lt;/li&gt;
&lt;li&gt;排查无用业务并下线&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些方法都比较常规，更像是对症下药，下面梳理一些技术上&lt;strong&gt;普适的方法&lt;/strong&gt;，独立于业务，在上面那些方法都尝试后，还可以使安装包大小“更下一层楼”。&lt;/p&gt;
&lt;p&gt;安装包的主要构成就是代码和资源，所以优化也是从这两个方面着手。&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;h3 id=&quot;混淆&quot;&gt;混淆&lt;/h3&gt;
&lt;p&gt;一般是通过&lt;code&gt;ProGuard&lt;/code&gt;，但很多用不好，且存在管理问题。最后一看项目，很多类被Keep住了，也不知道历史背景是啥。&lt;/p&gt;
&lt;h3 id=&quot;dex优化&quot;&gt;Dex优化&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;通过工具移除行号信息，带来的问题是无法回溯Crash位置，但可以解决&lt;/li&gt;
&lt;li&gt;多Dex时，通过重排Dex避免交叉索引，实现起来比较复杂&lt;/li&gt;
&lt;li&gt;Dex压缩，把实际的Dex压缩，首次启动通过一个壳去加载，会影响启动速度，但是可以解决，也比较复杂&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;so优化&quot;&gt;so优化&lt;/h3&gt;
&lt;p&gt;so的优化手段和Java代码其实比较类似，核心还是通过机制化的手段去裁剪、压缩。&lt;/p&gt;
&lt;h2 id=&quot;资源&quot;&gt;资源&lt;/h2&gt;
&lt;h2 id=&quot;资源本身&quot;&gt;资源本身&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;通过工具扫描无用资源，有些由于项目自身原因，可能没有显式引用，但外置的编译脚本会修改项目自身脚本，这就很坑了&lt;/li&gt;
&lt;li&gt;资源格式的优化，如PNG转JPG（除去alpha通道），转webp格式等&lt;/li&gt;
&lt;li&gt;字体文件只保留使用的，资源自身的二次优化&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;资源索引&quot;&gt;资源索引&lt;/h2&gt;
&lt;p&gt;通过&lt;code&gt;AndResGuard&lt;/code&gt;工具压缩资源名称，进而降低索引文件的大小。&lt;/p&gt;
&lt;h2 id=&quot;感悟&quot;&gt;感悟&lt;/h2&gt;
&lt;h3 id=&quot;核心思想&quot;&gt;核心思想&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;删除不用的（显而易见）&lt;/li&gt;
&lt;li&gt;压缩/转移有用的（如图片、字体文件，如大资源的转移，混淆信息的map表也是一种转移）&lt;/li&gt;
&lt;li&gt;精简系统产生的（dex重排）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常规的手段很容易到达瓶颈，高深的手段又有复杂、兼容性等诸多问题，但综合来看，还是两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;深刻理解&lt;strong&gt;底层&lt;/strong&gt;：apk编译流程、dex格式、资源引用、启动流程、加载流程原理等&lt;/li&gt;
&lt;li&gt;深刻理解&lt;strong&gt;工具&lt;/strong&gt;：ProGuard（很多人的ProGuard配置都是Copy修改），ReDex，AndResGuard等&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;权衡之道&quot;&gt;权衡之道&lt;/h3&gt;
&lt;p&gt;很多时候，优化就是权衡，重要的是取舍：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;压缩了Dex，就增加了启动速度&lt;/li&gt;
&lt;li&gt;拿掉了行号，就增加了恢复Crash堆栈的难度&lt;/li&gt;
&lt;li&gt;混淆了代码，就增加了编译脚本的复杂度&lt;/li&gt;
&lt;li&gt;等等&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;根本出路&quot;&gt;根本出路&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;建立监控&lt;/strong&gt;：团队每年都会优化一次安装包大小，尤其是删除、压缩资源的时候，总是一头雾水，不明白这个资源引入的目的，也不敢轻举妄动。最后有一套系统，让增量时有记录，让下线时有提醒，及时解决，而不是每到年底还一次技术债。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;制定标准&lt;/strong&gt;：某种意义上上，安装包大小的优化不是某个人的事情，而是团队的事情，最好有相关的实践指南或CodeReview标准。当有人不合理地引入资源，又或者业务下线后对无效逻辑置之不顾时，能有规则来约束这种行为。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;以上&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;欢迎扫码关注作者公众号，及时获取最新信息。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;https://github.com/vimerzhao/images/raw/master/common/ad-5.jpg&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sun, 16 Feb 2020 15:07:00 +0000</pubDate>
<dc:creator>赵裕(vimerzhao)</dc:creator>
<og:description>版权声明 1.本文版权归原作者所有，转载需注明作者信息及原文出处。 2.本文作者：赵裕(vimerzhao),永久链接： &amp;quot;https://github.com/vimerzhao/vime</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhaoyu1995/p/12319360.html</dc:identifier>
</item>
<item>
<title>centos7 手把手从零搭建深度学习环境 (以TensorFlow2.0为例) - chandlertu</title>
<link>http://www.cnblogs.com/learn-the-hard-way/p/12318980.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learn-the-hard-way/p/12318980.html</guid>
<description>&lt;p&gt;最近因为疫情的影响，笔者一直宅在家里办公。办公之余琢磨着把之前自己组装的电脑搭建一套深度学习环境，方便学习。下面就记录下这次折腾的成果。标题是从零开始，手把手搭建，但是需要读者具备基础的Linux操作知识和命令行交互习惯。当然，读者如果初入Linux也没关系，每个人都是从新手开始的。笔者在搭建深度学习环境的过程，也重装了好几次，换了很多系统。所以，挫败不可避免，只需勇往直前。&lt;/p&gt;
&lt;p&gt;本文以TensorFlow2.0为例，但是Pytorch和MXNet等框架都可以按照本文介绍的方法搭建配置。&lt;/p&gt;
&lt;p&gt;Let's Go!&lt;/p&gt;
&lt;p&gt;&lt;em&gt;心急的读者可直接从 &lt;strong&gt;二.安装系统&lt;/strong&gt; 开始阅读。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;=====================================================&lt;/p&gt;

&lt;p&gt;1.为什么需要自己搭建&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;云主机太贵。一般地，AWS机器学习便宜且算力恰当的实例也要0.9美元/时。国内同样算力的阿里云、腾讯云只会更贵。&lt;/li&gt;
&lt;li&gt;Colab这类免费平台不稳定，可以跑跑玩具实例，不宜作为严肃的学习和打比赛用途。最常见的问题是：有较高机率分配不到GPU；或者训练过程连接超时；需要翻墙。&lt;/li&gt;
&lt;li&gt;搭建这样一个平台，不仅可以用作深度学习，还可以搭建大数据环境(纵使单机版也足以满足学习目的）。&lt;/li&gt;
&lt;li&gt;经济宽裕后还可以再升级配置&lt;/li&gt;
&lt;li&gt;强化自己的折腾能力。不开玩笑的，组装硬件+环境配置可以提高动手能力&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.应该如何挑选显卡&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;GTX1080Ti 11G 版本目前价位在 3800 ~ 4500 元左右，虽然性价比非常高，但是非常非常高的机率买到矿卡（别人挖矿后淘汰的二手卡），慎重选择&lt;/li&gt;
&lt;li&gt;RTX2070 SUPER 8G 目前价位在3500元左右，综合算力和性价比考虑，值得推荐。&lt;/li&gt;
&lt;li&gt;RTX2060 和 GTX1080 等 6G 版本的显卡，不是非常推荐。考虑一个问题：如果是6G的显卡，配两块才12G，升级的空间和价值不大。&lt;/li&gt;
&lt;li&gt;RTX2080Ti 和 Titan 系列的显卡，如果预算非常充裕可以直接选购，算力非常强劲。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.操作系统比较&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ubuntu系列：笔者接触过16.04，18.04，19.04，19.10. ubuntu是深度学习领域非常流行的一个Linux发行版，好处很多，比如容易上手。但是，我个人认为，最好远离ubuntu，这个系统太容易崩溃了。也许有读者会说为什么我就没有遇到崩溃的事情呢？笔者不置可否，但是为了稳妥起见，如果您希望在一番辛苦配置之后的一年甚至两年后还想使用这套环境，请避免使用ubuntu。&lt;/li&gt;
&lt;li&gt;archlinux系列: 笔者接触过原生的archlinux和manjaro发行版。该系列的系统非常先锋，犀利。安装任何东西都非常容易，往往一行 pacman -S xxx 搞定。但是滚动更新犯了稳定的大忌，建议读者也避免选用。&lt;/li&gt;
&lt;li&gt;deepin系列：这是国内的一个发行版，虽是Linux，使用起来和windows其实差不多，尤其是自带Wine使得很多windows软件可以直接安装使用。但鉴于此系列的系统有很多bug（个人体验），不推荐选用它搭建我们的深度学习平台。&lt;/li&gt;
&lt;li&gt;centos系列：这是笔者接触过的&lt;strong&gt;最稳定&lt;/strong&gt;的版本。这套系统脱胎于RedHat——企业级系统，主打稳定性。当然批评centos的用户不在少数，但是我们的目的就是搭好一套环境，然后不再折腾操作系统方面的事情。centos正合适。&lt;strong&gt;注意，不要选用最新的centos8&lt;/strong&gt;，会出现一些不兼容现象，比如臭名昭著的libappindicator丢失问题。笔者建议选择&lt;strong&gt;centos7-1908&lt;/strong&gt;就可以了，这是centos7最后一个版本，足够新了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4.为什么非要使用Linux并且安装在真实机器上&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;windows是最容易用的系统，但是对于需要运行深度学习等任务的人来说却不是这样。首先，很多深度学习框架都优先支持Linux；其次，优秀的并行计算框架，比如Ray目前仍只支持Linux；再次，如果读者需要在运行tensorflow等框架的同时，还要和sparkmlib等组件交互，使用linux系统是最省精力的选择。&lt;/li&gt;
&lt;li&gt;虚拟机不是个好的选择。如果只是利用CPU训练神经网络，虚拟机是个好选择。如果读者已经有一块非常不错的显卡，虚拟机就是个坏的选择。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;5.笔者的机器配置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CPU：I7-9700K&lt;/li&gt;
&lt;li&gt;显卡：RTX2070 SUPER 8G&lt;/li&gt;
&lt;li&gt;内存：32G&lt;/li&gt;
&lt;li&gt;主硬盘：500G SSD&lt;/li&gt;
&lt;li&gt;次硬盘：4T 机械硬盘&lt;/li&gt;
&lt;li&gt;电源：650W&lt;/li&gt;
&lt;li&gt;操作系统：centos7-1908&lt;/li&gt;
&lt;li&gt;客户机：一台安装Win10操作系统的笔记本电脑&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;6.安装的大致流程&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-0.5&quot;&gt;
&lt;p&gt;安装系统&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;注意，笔者安装的是&lt;strong&gt;无桌面客户端&lt;/strong&gt;的版本，然后远程登陆去操作的。这样的好处是，可以把机器当作专门的学习平台，省去了一大堆不必要的配置（比如安装搜狗输入法、网易云音乐... 😀）；而且一块好显卡和Steam相遇注定要荒废学业 😀。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;安装NVIDA显卡驱动&lt;/li&gt;
&lt;li&gt;安装CUDA&lt;/li&gt;
&lt;li&gt;安装CuDNN&lt;/li&gt;
&lt;li&gt;安装Anaconda&lt;/li&gt;
&lt;li&gt;安装深度学习框架，以 TensorFlow2.0 为例&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置远程访问&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;=====================================================&lt;/p&gt;
&lt;p&gt;下面笔者就根据自己的实际操作情况，来介绍如何从零搭建一台深度学习机器。&lt;/p&gt;

&lt;p&gt;1.制作启动盘（在windows操作上完成下列步骤）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从清华源上下载&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/centos/7.7.1908/isos/x86_64/CentOS-7-x86_64-Minimal-1908.iso&quot;&gt;CentOS-7-x86_64-Minimal-1908&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;从deepin社区下载&lt;a href=&quot;http://cdimage.deepin.com/applications/deepin-boot-maker/windows/deepin-boot-maker.exe&quot;&gt;bootmaker&lt;/a&gt;工具 （非常好用的U盘启动器制作工作）&lt;/li&gt;
&lt;li&gt;运行bootmaker，插入一只容易4G以上的U盘，根据bootmaker的界面选择下载好的操作系统，然后选择这只U盘，注意勾选格式化选项，然后制作启动盘&lt;/li&gt;
&lt;li&gt;将下载的iso镜像文件复制一份到启动盘&lt;/li&gt;
&lt;li&gt;修改U盘的名称，比如修改为CENTOS这类好记的名称&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.安装系统&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;插入U盘到需要安装系统的机器上&lt;/li&gt;
&lt;li&gt;开机后进入boot界面，选择从U盘启动&lt;/li&gt;
&lt;li&gt;不出意外，应该能看到下面界面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342077/202002/1342077-20200216200704911-1071198893.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用上下键把高亮光标移动到第一项，按 e 键，把下面红色区域删除，然后输入前面命名的CENTOS，格式为 &lt;code&gt;LABEL=CENTOS quiet&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342077/202002/1342077-20200216200947302-1526979015.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;按组合键 ctrl + x 开始安装&lt;/li&gt;
&lt;li&gt;接下来就是选择系统语言，笔者选择了英文，读者酌情选择&lt;/li&gt;
&lt;li&gt;后面就是一些常规配置，根据读者自己的需要选择即可。如果不熟悉Linux分区操作的，可以选择自动划分，一般根目录有50G足够。&lt;/li&gt;
&lt;li&gt;囿于篇幅，操作系统的安装就介绍到这里。系统安装完成后，读者可以配置一下软件源，目的是为了安装新软件的时候能使用国内的仓库（速度快）。具体操作请搜索，关键词为：centos7更换阿里源&lt;/li&gt;
&lt;li&gt;另外，centos还需要配置一下打开终端的快捷键，搜索关键词：centos7 添加终端快捷键&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.安装CUDA&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CUDA又叫cuda-toolkit，是NVIDA公司专门开发的一套接口，方便利用GPU做高速计算。主流的深度学习框架都面向CUDA做了兼容。&lt;/li&gt;
&lt;li&gt;CUDA的版本适配非常重要。目前TensorFlow2.0在CUDA上最稳妥的选择是10.0，如果选择10.1以上，有机率不识别GPU&lt;/li&gt;
&lt;li&gt;从&lt;a href=&quot;https://developer.nvidia.com/cuda-10.0-download-archive&quot;&gt;CUDA仓库&lt;/a&gt;下载CUDA10.0，按照下图选择&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342077/202002/1342077-20200216202842487-356074981.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.安装CuDNN&lt;/p&gt;
&lt;ul readability=&quot;-0.94041867954911&quot;&gt;&lt;li&gt;CuDNN是深度神经网络库，和CUDA搭配使用，专门用于深度学习任务&lt;/li&gt;
&lt;li&gt;从&lt;a href=&quot;https://developer.nvidia.com/rdp/form/cudnn-download-survey&quot;&gt;CuDNN仓库&lt;/a&gt;下载适配CUDA版本的安装包，注意认准CUDA10.0版本号（下载CuDNN前需要注册，推荐使用微信注册）&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在存放CuDNN包的路径下运行下列命令&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tar xzvf cudnn-10.0-linux-x64-v7.6.5.32.tgz&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo cp -P cuda/include/cudnn.h /usr/local/cuda/include&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo cp -P cuda/lib64/lib* /usr/local/cuda/lib64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo chmod a+r /usr/local/cuda/include/cudnn.h&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo chmod a+r /usr/local/cuda/lib64/lib*&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo ldconfig&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.72916666666667&quot;&gt;
&lt;p&gt;推荐一篇NVIDA官方写的文档，详细介绍了CuDNN的安装：&lt;a href=&quot;https://docs.nvidia.com/deeplearning/sdk/cudnn-install/&quot;&gt;DEEP LEARNING SDK DOCUMENT&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.安装NVIDA显卡驱动&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;显卡驱动有一个安装原则：装最新的驱动。&lt;/li&gt;
&lt;li&gt;读者可以去&lt;a href=&quot;https://www.nvidia.cn/Download/index.aspx?lang=cn&quot;&gt;NVIDA官网&lt;/a&gt;根据自己的显卡型号搜索合适的驱动，注意notebook是指笔记本，不是给台式机用的。&lt;/li&gt;
&lt;li&gt;点击搜索后会跳转到一个下载页面，右键复制这个下载路径&lt;/li&gt;
&lt;li&gt;在cenots的终端输入 wget 下载路径，就可以直接把驱动下到本地硬盘上&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;echo -e &quot;blacklist nouveau\noptions nouveau modeset=0&quot; &amp;gt; /etc/modprobe.d/blacklist.conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入 &lt;code&gt;lsmod | grep nouveau&lt;/code&gt; 如果没有输入任何内容，说明成功禁止了nouveau&lt;/li&gt;
&lt;li&gt;安装这个驱动，输入 &lt;code&gt;./NVIDIA-Linux-x86_64-440.59.run&lt;/code&gt; (读者根据自己下载的驱动名修改；根据提示安装）&lt;/li&gt;
&lt;li&gt;重启机器后输入 &lt;code&gt;nvidia-smi&lt;/code&gt;，如果看到下面画面，说明已经成功安装&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342077/202002/1342077-20200216204734907-1737079336.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;1.关于Anaconda&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Anaconda是python领域比较流行的包管理器，类似的有virtualenv等。Anaconda的特色是，会自动帮助安装需要的依赖项；并且使用方便，文档详尽。&lt;/li&gt;
&lt;li&gt;没必要安装完整版的Anaconda，安装Miniconda即可，因为我们会在虚拟环境中搭建需要的各种深度学习环境。例如在A环境围绕TensorFlow搭建，在B环境围绕Pytorch搭建，两套环境互相不会污染。如果读者将两个框架安装在一个环境里，会有严重的冲突。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2.安装Anaconda&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-latest-Linux-x86_64.sh&quot;&gt;清华源仓库&lt;/a&gt;下载Miniconda&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;sh&lt;/code&gt; 命令直接安装，使用默认选项即可&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.创建虚拟环境并激活&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;conda create --name tensorflow&lt;/code&gt; (也可使用其他名称，如 tf）&lt;/li&gt;
&lt;li&gt;激活环境 &lt;code&gt;conda activate tensorflow&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4.安装 TensorFlow2.0&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;conda install tensorflow-gpu==2.0.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请严格输入这条命令，conda会下载安装所需的全部依赖，其中包括cudatoolkit-10.0.130和cudnn-7.6.5，虽然前面安装了这两个包，但是不冲突，可以默认执行；如果在训练神经网络时发现冲突，可以回头再删除这两个包&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;5.补充两条常用的conda命令&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;conda deactivate 退出当前环境&lt;/li&gt;
&lt;li&gt;conda info --env 查看本机上安装的环境&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;1.安装&lt;a href=&quot;https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html&quot;&gt;PUTTY远程客户端&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;XShell虽然好用，但它是收费软件。Putty基本可满足使用需要&lt;/li&gt;
&lt;li&gt;按照下图进行配置&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342077/202002/1342077-20200216214452864-1120553042.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.安装 &lt;a href=&quot;https://winscp.net/eng/download.php&quot;&gt;WinSCP&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;WinSCP是一款免费的传输软件，方便客户机和终端机之前互传文件&lt;/li&gt;
&lt;li&gt;配置过程简单直白，文件支持拖拽，这里不再赘述。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3.安装jupyter notebook并配置远程访问&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;conda install jupyter notebook&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;jupyter notebook --generate-config&lt;/code&gt; 生成一份默认配置文件&lt;/li&gt;
&lt;li&gt;输入python，进入ipython交互环境，如下图所示输入代码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342077/202002/1342077-20200216210106760-893381544.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.开放端口&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;推荐使用 iptables 工具，首先要关闭 firewall 服务&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;systemctl stop firewalld.service&lt;/li&gt;
&lt;li&gt;systemctl disable firewalld.service&lt;/li&gt;
&lt;li&gt;systemctl mask firewalld.service&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;安装 iptables 防火墙&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;sudo yum install iptables-services -y&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 iptables&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;systemctl enable iptables&lt;/li&gt;
&lt;li&gt;systemctl start iptables&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编辑防火墙文件&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;sudo vim /etc/sysconfig/iptables&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;添加端口(添加下述配置)&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;-A INPUT -m state --state NEW -m tcp -p tcp --dport 8888 -j ACCEPT&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;重启 iptables 使新端口生效&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;systemctl restart iptables.service&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;设置防火墙开机启动&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;systemctl enable iptables.service&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;=====================================================&lt;/p&gt;

&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;激活tensorflow环境&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;conda activate tensorflow&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;开启jupyter notebook （可以添加禁止挂起和后台执行命令）&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;nohup jupyter notebook &amp;amp;&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;在远程客户机（读者的另外一台电脑，比如笔记本）浏览器输入 192.168.1.100:8888 (实际IP地址根据读者机器的地址修改），输入前面设置的密码后即可连接成功&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;验证是否成功安装了tensoflow，以及成功识别GPU设备&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342077/202002/1342077-20200216212050967-247029629.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果在使用 tensorflow 过程中出现&lt;strong&gt;Error : Failed to get convolution algorithm&lt;/strong&gt;，这是因为显卡内存被耗尽了（按照本文档安装可以排除cuda版本冲突的可能）。可以在代码的最开始输入下面两行配置&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;physical_device = tf.config.experimental.list_physical_devices(&quot;GPU&quot;)&lt;/li&gt;
&lt;li&gt;tf.config.experimental.set_memory_growth(physical_device[0], True)&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;=====================================================&lt;/p&gt;
&lt;p&gt;至此，我们就完成了从零开始搭建一套深度学习主机的全部工作。希望这篇教程可以帮助读者顺利地搭建好自己的深度学习平台。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;如果有任何纰漏差错，欢迎评论互动。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1342077/201911/1342077-20191107100823586-1535079588.jpg&quot; alt=&quot;drawing&quot; width=&quot;200&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 16 Feb 2020 15:04:00 +0000</pubDate>
<dc:creator>chandlertu</dc:creator>
<og:description>[toc] 最近因为疫情的影响，笔者一直宅在家里办公。办公之余琢磨着把之前自己组装的电脑搭建一套深度学习环境，方便学习。下面就记录下这次折腾的成果。标题是从零开始，手把手搭建，但是需要读者具备基础的L</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/learn-the-hard-way/p/12318980.html</dc:identifier>
</item>
<item>
<title>java代码之美（15）---Java8 Function、Consumer、Supplier - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/12050701.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/12050701.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;有关JDK8新特性之前写了三篇博客：&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/9393724.html&quot;&gt;java代码之美（1）---Java8 Lambda&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/9399015.html&quot;&gt;java代码之美（2）---Java8 Stream&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3、&lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/11323595.html&quot;&gt;java代码之美（13）--- Predicate详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这一篇我们来了解JDK8已经定义好的几个函数式接口。&lt;/p&gt;
&lt;h2 id=&quot;一概述&quot;&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;Jdk8之后新增的一个重要的包 : &lt;strong&gt;java.util.function&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该包下所有的接口都是函数式接口, 按分类主要分为四大接口类型: &lt;code&gt;Function&lt;/code&gt;、&lt;code&gt;Consumer&lt;/code&gt;、&lt;code&gt;Predicate&lt;/code&gt;、&lt;code&gt;Supplier&lt;/code&gt;。有关Predicate这里不再讲解，因为上面有单独写过一篇博客。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191216190024258-463349888.jpg&quot; width=&quot;700&quot; height=&quot;180&quot;/&gt;&lt;/p&gt;
&lt;p&gt;延伸如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191216190111553-251022017.jpg&quot; width=&quot;700&quot; height=&quot;210&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里也仅仅是展示一部分，我们看看java.util.function包下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191216190211633-1473355636.jpg&quot; width=&quot;600&quot; height=&quot;500&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;二consumer&quot;&gt;&lt;span&gt;二、Consumer&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;作用&lt;/code&gt; 一听这名字就知道是消费某个对象，没有返回值。&lt;/p&gt;
&lt;h4 id=&quot;源码&quot;&gt;1、源码&lt;/h4&gt;
&lt;p&gt;在源码中只有两个方法，一个抽象方法，一个默认方法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface Consumer&amp;lt;T&amp;gt; {

    /**
     * 抽象方法：传入一个指定泛型的参数，无返回值
     */
    void accept(T t);

    /**
     * 如同方法名字一样andThen,类似一种相加的功能（下面会举例说明）
     */
    default Consumer&amp;lt;T&amp;gt; andThen(Consumer&amp;lt;? super T&amp;gt; after) {
        Objects.requireNonNull(after);
        return (T t) -&amp;gt; { accept(t); after.accept(t); };
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用示例&quot;&gt;2、使用示例&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) {
        testConsumer();
        testAndThen();
    }
    /**
     * 一个简单的平方计算
     */
    public static void testConsumer() {
        //设置好Consumer实现方法
        Consumer&amp;lt;Integer&amp;gt; square = x -&amp;gt; System.out.println(&quot;平方计算 : &quot; + x * x);
        //传入值
        square.accept(2);
    }
    /**
     * 定义3个Consumer并按顺序进行调用andThen方法
     */
    public static void testAndThen() {
        //当前值
        Consumer&amp;lt;Integer&amp;gt; consumer1 = x -&amp;gt; System.out.println(&quot;当前值 : &quot; + x);
        //相加
        Consumer&amp;lt;Integer&amp;gt; consumer2 = x -&amp;gt; { System.out.println(&quot;相加 : &quot; + (x + x)); };
        //相乘
        Consumer&amp;lt;Integer&amp;gt; consumer3 = x -&amp;gt; System.out.println(&quot;相乘 : &quot; + x * x);
        //andThen拼接
        consumer1.andThen(consumer2).andThen(consumer3).accept(1);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;运行结果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201912/1090617-20191216190252957-1768982616.jpg&quot; width=&quot;600&quot; height=&quot;100&quot;/&gt;&lt;/p&gt;
&lt;p&gt;单个这样消费看去并没啥意义,但如果是集合操作就有意义了，所以Jdk8的Iterator接口就引入了Consumer。&lt;/p&gt;
&lt;h4 id=&quot;jdk8使用&quot;&gt;3、JDK8使用&lt;/h4&gt;
&lt;p&gt;Iterable接口的forEach方法需要传入Consumer，大部分集合类都实现了该接口，用于返回Iterator对象进行迭代。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Iterable&amp;lt;T&amp;gt; {
    //forEach方法传入的就是Consumer
    default void forEach(Consumer&amp;lt;? super T&amp;gt; action) {
        Objects.requireNonNull(action);
        for (T t : this) {
            action.accept(t);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在看给我们带来的便利&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    public static void main(String[] args) {
        //假设这里有个集合,集合里的对象有个status属性,现在我想对这个属性赋值一个固定值
        List&amp;lt;Pension&amp;gt; pensionList = new ArrayList&amp;lt;&amp;gt;();
        //1、传统的通过for循环添加
        for (Pension pension : pensionList) {
            pension.setStatus(1);
        }
        //2、通过forEach的Consumer添加
        pensionList.forEach(x -&amp;gt; x.setStatus(1));
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样一比较是不是代码简洁了点，这就是Consumer是我们代码带来简洁的地方。&lt;/p&gt;

&lt;h2 id=&quot;三supplier&quot;&gt;&lt;span&gt;三、Supplier&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;作用&lt;/code&gt; 提前定义可能返回的一个指定类型结果，等需要调用的时候再获取结果。&lt;/p&gt;
&lt;h4 id=&quot;源码-1&quot;&gt;1、源码&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
public interface Supplier&amp;lt;T&amp;gt; {

    /**
     * 只有这一个抽象类
     */
    T get();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码非常简单。&lt;/p&gt;
&lt;h4 id=&quot;jdk8使用-1&quot;&gt;2、JDK8使用&lt;/h4&gt;
&lt;p&gt;在JDK8中Optional对象有使用到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Optional.orElseGet(Supplier&amp;lt;? extends T&amp;gt;) //当this对象为null，就通过传入supplier创建一个T返回。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看下源码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public &amp;lt;X extends Throwable&amp;gt; T orElseThrow(Supplier&amp;lt;? extends X&amp;gt; exceptionSupplier) throws X {
        if (value != null) {
            return value;
        } else {
            throw exceptionSupplier.get();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;使用示例&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public static void main(String[] args) {
        Person son = null;
        //先判断son是否为null,如果为不为null则返回当前对象,如果为null则返回新创建的对象
        BrandDTO optional = Optional.ofNullable(son).orElseGet(() -&amp;gt; new Person());

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样代码是不是又简单了。有关Optional这里就不多说,接下来会单独写一篇博客。&lt;/p&gt;

&lt;h2 id=&quot;四function&quot;&gt;&lt;span&gt;四、Function&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;作用&lt;/code&gt; 实现一个”一元函数“，即传入一个值经过函数的计算返回另一个值。&lt;/p&gt;
&lt;h4 id=&quot;源码-2&quot;&gt;1、源码&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @FunctionalInterface
    public interface Function&amp;lt;T, R&amp;gt; {
        
        /**
         * 抽象方法: 根据一个数据类型T加工得到一个数据类型R
         */
        R apply(T t);

        /**
         * 组合函数，调用当前function之前调用
         */
        default &amp;lt;V&amp;gt; java.util.function.Function&amp;lt;V, R&amp;gt; compose(java.util.function.Function&amp;lt;? super V, ? extends T&amp;gt; before) {
            Objects.requireNonNull(before);
            return (V v) -&amp;gt; apply(before.apply(v));
        }

        /**
         * 组合函数，调用当前function之后调用
         */
        default &amp;lt;V&amp;gt; java.util.function.Function&amp;lt;T, V&amp;gt; andThen(java.util.function.Function&amp;lt;? super R, ? extends V&amp;gt; after) {
            Objects.requireNonNull(after);
            return (T t) -&amp;gt; after.apply(apply(t));
        }

        /**
         *  静态方法，返回与原函数参数一致的结果。x=y
         */
        static &amp;lt;T&amp;gt; java.util.function.Function&amp;lt;T, T&amp;gt; identity() {
            return t -&amp;gt; t;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;使用示例-1&quot;&gt;2、使用示例&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
        applyTest();
        andThenTest();
        composeTest();
        test();
    }

    /**
     * 1、apply 示例
     */
    private static void applyTest() {
        //示例1：定义一个funciton,实现将String转换为Integer
        Function&amp;lt;String, Integer&amp;gt; function = x -&amp;gt; Integer.parseInt(x);
        Integer a = function.apply(&quot;100&quot;);
        System.out.println(a.getClass());
        // 结果：class java.lang.Integer
    }

    /**
     * 2、andThen 示例
     */
    private static void andThenTest() {
        //示例2：使用andThen() 实现一个函数 y=10x + 10;
        //先执行 10 * x
        Function&amp;lt;Integer, Integer&amp;gt; function2 = x -&amp;gt; 10 * x;
        //通过andThen在执行 这里的x就等于上面的10 * x的值
        function2 = function2.andThen(x -&amp;gt; x + 10);
        System.out.println(function2.apply(2));
        //结果：30

    }

    /**
     * 3、compose 示例
     */
    private static void composeTest() {
        //示例3：使用compose() 实现一个函数 y=(10+x)2;
        Function&amp;lt;Integer, Integer&amp;gt; function3 = x -&amp;gt; x * 2;
        //先执行 x+10 在执行(x+10)*2顺序与上面相反
        function3 = function3.compose(x -&amp;gt; x + 10);
        System.out.println(function3.apply(3));
        //结果：26
    }

    /**
     * 4、综合示例
     */
    private static void test() {

//示例4：使用使用compose()、andThen()实现一个函数 y=(10+x)*2+10;
        //执行第二步
        Function&amp;lt;Integer, Integer&amp;gt; function4 = x -&amp;gt; x * 2;
        //执行第一步
        function4 = function4.compose(x -&amp;gt; x + 10);
        //执行第三步
        function4 = function4.andThen(x -&amp;gt; x + 10);
        System.out.println(function4.apply(3));
       //结果：36

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;jdk8使用-2&quot;&gt;3、JDK8使用&lt;/h4&gt;
&lt;p&gt;有两个地方很常用&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;1、V HashMap.computeIfAbsent(K , Function&amp;lt;K, V&amp;gt;) // 简化代码，如果指定的键尚未与值关联或与null关联，使用函数返回值替换。
2、&amp;lt;R&amp;gt; Stream&amp;lt;R&amp;gt; map(Function&amp;lt;? super T, ? extends R&amp;gt; mapper); // 转换流&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;computeIfAbsent使用示例&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Map&amp;lt;String, List&amp;lt;String&amp;gt;&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
List&amp;lt;String&amp;gt; list;

// java8之前写法
list = map.get(&quot;key&quot;);
if (list == null) {
    list = new LinkedList&amp;lt;&amp;gt;();
    map.put(&quot;key&quot;, list);
}
list.add(&quot;11&quot;);

// 使用 computeIfAbsent 可以这样写 如果key返回部位空则返回该集合 ，为空则创建集合后返回
list = map.computeIfAbsent(&quot;key&quot;, k -&amp;gt; new ArrayList&amp;lt;&amp;gt;());
list.add(&quot;11&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;stream中map使用示例&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;  public static void main(String[] args) {
        List&amp;lt;Person&amp;gt; persionList = new ArrayList&amp;lt;Person&amp;gt;();
        persionList.add(new Person(1,&quot;张三&quot;,&quot;男&quot;,38));
        persionList.add(new Person(2,&quot;小小&quot;,&quot;女&quot;,2));
        persionList.add(new Person(3,&quot;李四&quot;,&quot;男&quot;,65));

        //1、只取出该集合中所有姓名组成一个新集合（将Person对象转为String对象）
        List&amp;lt;String&amp;gt; nameList=persionList.stream().map(Person::getName).collect(Collectors.toList());
        System.out.println(nameList.toString());
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码是不是又简洁了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;总结&lt;/code&gt; 这些函数式接口作用在我看来，就是定义一个方法,方法中有个参数是函数式接口，这样的话函数的具体实现则由调用者来实现。这就是函数式接口的意义所在。&lt;/p&gt;
&lt;p&gt;一般我们也会很少去定义一个方法，方法参数包含函数接口。我们更重要的是学会使用JDk8中带有函数式接口参数的方法，来简化我们的代码。&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://www.jianshu.com/p/9b6396a889e4&quot;&gt;JDK1.8函数式接口Function、Consumer、Predicate、Supplier&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://www.cnblogs.com/linzhanfly/p/9686941.html&quot;&gt;JAVA 8 函数式接口&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;你如果愿意有所作为，就必须有始有终。(25)&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 16 Feb 2020 15:04:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>Java8 Function、Consumer、Supplier 有关JDK8新特性之前写了三篇博客： 1、 &amp;quot;java代码之美（1） Java8 Lambda&amp;quot; 2、 &amp;quot</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qdhxhz/p/12050701.html</dc:identifier>
</item>
<item>
<title>【从0到1学算法】 数组和链表 - KENDOEVERTHING</title>
<link>http://www.cnblogs.com/KEN-DO-EVERTHING/p/12319324.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KEN-DO-EVERTHING/p/12319324.html</guid>
<description>&lt;p&gt;今天讲最基本的数据结构，数组和链表。如果你已经滚瓜烂熟，可以跳过本文或选择查缺补漏。&lt;/p&gt;
&lt;h4 id=&quot;内存的工作原理&quot;&gt;内存的工作原理&lt;/h4&gt;
&lt;p&gt;假设你正要去超市，需要寄存两样东西。这个超市的寄存柜，一个抽屉只能放一个东西，所以你需要两个抽屉。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13046507-5fe0e7e7f184fda2?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将东西分别放到了1号和2号抽屉里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13046507-6e747d2d13fb96d0?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务员将号码牌给你后，就可以去shopping了，购物完，凭号码牌拿东西即可。这大致就是计算机内存的工作原理，计算机内存就像很多抽屉，各个抽屉都有地址，根据地址存储和访问数据。&lt;/p&gt;
&lt;p&gt;存储单项数据时，只需要计算机提供一个存储地址即可。当需要存储多项数据时，会用到两种基本方式---&lt;strong&gt;数组&lt;/strong&gt;和&lt;strong&gt;链表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设你要编写一个管理待办事项的应用，需要将这些待办事项存储到内存中，用数组还是链表？&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;数组&quot;&gt;数组&lt;/h4&gt;
&lt;p&gt;使用数组，就意味着所有待办事项在内存中都是相连的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13046507-d072c3222e7a4197?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果你现在想添加第4个待办事项，但后面那个抽屉放着别人的东西，这就难办了。这种情况只能请求计算机重新分配内存（可容纳4个待办事项），再将所有事项移到那里。&lt;/p&gt;
&lt;p&gt;这里还有个权宜之计“&lt;strong&gt;预留位置&lt;/strong&gt;”：预先申请10个连续位置，以防需要添加待办事项。这样，只要不超过10个，就无需转移。但它有两个缺点:&lt;/p&gt;
&lt;p&gt;1.请求额外内存可能用不上，导致浪费；&lt;/p&gt;
&lt;p&gt;2.超过10个后，还是得转移。&lt;/p&gt;
&lt;p&gt;这是一个不错的措施，但不是完美的方案。对于这种问题，我们可以用链表解决。&lt;/p&gt;
&lt;h4 id=&quot;链表&quot;&gt;链表&lt;/h4&gt;
&lt;p&gt;使用链表，元素则可以存储在内存的任何位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13046507-ecfd7b0d9659e198?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个元素都会存储下一个元素的内存地址。比如，&quot;吃午饭&quot;存储下一个元素“玩滚地球”的内存地址13，而“玩滚地球”会存储下一个元素“喝茶”的地址22，这样便能将这几项数据串在一块了。&lt;/p&gt;
&lt;p&gt;使用链表，根本不需要移动元素，元素随便放哪都行。添加新元素时，也不需要”预留位置“，只要内存足够，就能为链表分配内存。&lt;/p&gt;
&lt;h4 id=&quot;索引&quot;&gt;索引&lt;/h4&gt;
&lt;p&gt;使用数组和链表存储数据，我们都会给元素编号，编号从0开始，这些元素的编号位置成为索引。&lt;/p&gt;
&lt;p&gt;例如，下面的数组，元素20在索引1处&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13046507-86cb956b3da89469?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;读取&quot;&gt;读取&lt;/h4&gt;
&lt;h5 id=&quot;数组-随机访问&quot;&gt;数组-随机访问&lt;/h5&gt;
&lt;p&gt;正因为数组是顺序存储的，当知道起始地址，便能知道数组中所有元素的地址，支持随机访问（可随机读取任意索引位置的值）&lt;/p&gt;
&lt;p&gt;假设有一个数组，包含5个元素，起始地址为00，那么我们便能简单推算出第5个元素的地址是04&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13046507-e0da9f6787d5bb67?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;链表-顺序访问&quot;&gt;链表-顺序访问&lt;/h5&gt;
&lt;p&gt;而链表呢?元素是分开存储的，无法推算出任意位置元素的地址，不支持随机访问，只能顺序访问（从第一个元素开始逐个读取元素）。&lt;/p&gt;
&lt;p&gt;假设有一个链表，存储数值和位置如下，知道起始地址为01，但无法直接知道第5个元素的位置，因为不是顺序存储且每个元素只存储了下一个元素的地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13046507-898175b743e88649?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;必须从头遍历，直到找到第5个位置的元素01&amp;gt;03&amp;gt;05&amp;gt;07&amp;gt;08。&lt;/p&gt;
&lt;p&gt;所以，当需要&lt;strong&gt;随机访问&lt;/strong&gt;，&lt;strong&gt;数组&lt;/strong&gt;是更好的选择。&lt;/p&gt;
&lt;h4 id=&quot;插入元素&quot;&gt;插入元素&lt;/h4&gt;
&lt;p&gt;数组插入数据，必须将后面的元素后移（保持顺序存储），且有可能出现连续内存不足，这就得将整个数组复制到其他地方&lt;/p&gt;
&lt;p&gt;例如，插入“卖茶叶”到第3个位置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13046507-8838efcf10792bcd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用链表时，插入元素很简单，只需修改它前一个元素的指向地址即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13046507-499034306d723591?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，当需要&lt;strong&gt;频繁插入元素&lt;/strong&gt;，&lt;strong&gt;链表&lt;/strong&gt;是更好的选择。&lt;/p&gt;
&lt;h4 id=&quot;删除&quot;&gt;删除&lt;/h4&gt;
&lt;p&gt;删除元素呢？链表是更好的选，因为只需修改它前一个元素的指向地址即可。&lt;/p&gt;
&lt;p&gt;而使用数组时，删除元素后，必须将后面的元素都向前移（保持顺序存储）。&lt;/p&gt;
&lt;h4 id=&quot;常见操作的运行时间&quot;&gt;常见操作的运行时间&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13046507-fd8f08c014f36d23?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要注意的是，链表删除元素时，当能够立即删除元素时，运行时间才为O(1), 因为通常我们都记录了链表的第一个和最后一个元素。其他情况均为O(n)，因为需要通过顺序遍历再删除。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;h5 id=&quot;数组-1&quot;&gt;数组&lt;/h5&gt;
&lt;p&gt;存储位置：顺序储存。&lt;/p&gt;
&lt;p&gt;优点：支持随机访问，读取速度快。&lt;/p&gt;
&lt;p&gt;缺点：插入和删除数据较慢，需要移动元素。&lt;/p&gt;
&lt;h5 id=&quot;链表-1&quot;&gt;链表&lt;/h5&gt;
&lt;p&gt;存储位置：分开储存，每个元素都存储了下一个元素的地址。&lt;/p&gt;
&lt;p&gt;优点：插入和删除数据快，无需移动元素，只需修改它前面元素的指向地址即可。&lt;/p&gt;
&lt;p&gt;缺点：只支持顺序访问，读取速度较慢。&lt;/p&gt;
&lt;p&gt;读取多，插入少，用数组。&lt;/p&gt;
&lt;p&gt;读取少，插入多，用链表。&lt;/p&gt;
&lt;p&gt;但在实际应用中，数组用的更多一，因为它支持随机读取。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;文章首发于公众号【KEN DO EVERTHING】&lt;br/&gt;本公众号专注于java相关技术,但不限于java、mysql、python、面试技巧、生活感悟等。分享优质博文,技术干货，学习资源等优质内容。&lt;br/&gt;欢迎关注，一起学习，共成长！&lt;/p&gt;
</description>
<pubDate>Sun, 16 Feb 2020 14:59:00 +0000</pubDate>
<dc:creator>KENDOEVERTHING</dc:creator>
<og:description>今天讲最基本的数据结构，数组和链表。如果你已经滚瓜烂熟，可以跳过本文或选择查缺补漏。 内存的工作原理 假设你正要去超市，需要寄存两样东西。这个超市的寄存柜，一个抽屉只能放一个东西，所以你需要两个抽屉。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/KEN-DO-EVERTHING/p/12319324.html</dc:identifier>
</item>
</channel>
</rss>