<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>libuv中实现tcp服务器 - sherlock_lin</title>
<link>http://www.cnblogs.com/sherlock-lin/p/14337912.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sherlock-lin/p/14337912.html</guid>
<description>&lt;p&gt;libuv 中实现 tcp server 的步骤和原生 socket 步骤类似，回忆一下 linux 下原生 socket 实现 tcp server 的步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化 socket 环境，获取 socket 套接字；&lt;/li&gt;
&lt;li&gt;bind() 方法绑定套接字到本地IP；&lt;/li&gt;
&lt;li&gt;listen() 方法监听 socket，获取新连接；&lt;/li&gt;
&lt;li&gt;accept() 方法接受客户端连接，返回客户端套接字；&lt;/li&gt;
&lt;li&gt;recv() 方法接受客户端的数据；&lt;/li&gt;
&lt;li&gt;send() 方法向客户端发送数据；&lt;/li&gt;
&lt;li&gt;closesocket() 方法关闭套接字；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;libuv 和原生 socket 编程类似，步骤和API与原生 socket 编程步骤类似，但是使用却变得简单了，处处使用回调函数使得编程变得简单了。&lt;/p&gt;

&lt;p&gt;libuv 对于 tcp 消息的处理，同样是基于 stream 的，步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;uv_tcp_init() 建立 tcp 句柄；&lt;/li&gt;
&lt;li&gt;uv_tcp_bind() 方法绑定ip；&lt;/li&gt;
&lt;li&gt;uv_listen() 方法监听，有新连接时，调用回调函数；&lt;/li&gt;
&lt;li&gt;uv_accept() 方法获取客户端套接字；&lt;/li&gt;
&lt;li&gt;uv_read_start() 方法读取客户端数据；&lt;/li&gt;
&lt;li&gt;uv_write() 方法想客户端发送数据；&lt;/li&gt;
&lt;li&gt;uv_close() 关闭套接字；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;附录是整个 tcp server 的源代码，其中涉及到的一些 API 如下：&lt;/p&gt;
&lt;h2 id=&quot;31、uv_tcp_init&quot;&gt;3.1、uv_tcp_init&lt;/h2&gt;
&lt;p&gt;初始化 tcp 对象&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;uv_tcp_t server;
uv_tcp_init(loop, &amp;amp;server);//初始化tcp server对象
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;32、uv_ip4_addr&quot;&gt;3.2、uv_ip4_addr&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct sockaddr_in addr;
uv_ip4_addr(&quot;0.0.0.0&quot;, DEFAULT_PORT, &amp;amp;addr);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将给定的ip地址和端口转换成sockaddr_in结构体，原生编程的时候，设置ip和端口需要至少五行，用这个方法可以简化操作&lt;/p&gt;
&lt;h2 id=&quot;33、uv_tcp_bind&quot;&gt;3.3、uv_tcp_bind&lt;/h2&gt;
&lt;p&gt;等同于原生API的 bind() 方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;uv_tcp_bind(&amp;amp;server, (const struct sockaddr *) &amp;amp;addr, 0);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;uv_tcp_bind() 的第三个参数 flag 一般是0，如果想使用IP6，可以使用 UV_TCP_IPV6ONLY&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;enum uv_tcp_flags {
  /* Used with uv_tcp_bind, when an IPv6 address is used. */
  UV_TCP_IPV6ONLY = 1
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;34、uv_listen&quot;&gt;3.4、uv_listen&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;uv_listen((uv_stream_t *) &amp;amp;server, 128, on_new_connection);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;类似 listen() ，开始监听&lt;/p&gt;
&lt;p&gt;第二个参数表明内核的排队数，最后指定有新连接时的回调函数&lt;/p&gt;
&lt;p&gt;当有新的连接进来时，就会触发 on_new_connection 回调&lt;/p&gt;
&lt;h2 id=&quot;35、uv_connection_cb&quot;&gt;3.5、uv_connection_cb&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;uv_connection_cb&lt;/strong&gt; 是 uv_listen 的回调函数，其声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef void (*uv_connection_cb)(uv_stream_t* server, int status);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;server&lt;/strong&gt; 参数为服务器句柄&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;status&lt;/strong&gt; 表示状态，小于0表示新连接有误&lt;/p&gt;
&lt;h2 id=&quot;36、uv_accept&quot;&gt;3.6、uv_accept&lt;/h2&gt;
&lt;p&gt;新连接触发回调函数之后，按照一般流程，需要使用 accept() 方法获取客户端句柄，libuv 中使用 uv_accept()，其声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int uv_accept(uv_stream_t* server, uv_stream_t* client)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在调用之前，&lt;strong&gt;client&lt;/strong&gt; 参数必须被初始化&lt;/p&gt;
&lt;p&gt;返回值 &amp;lt;0 表示有误&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;uv_tcp_t *client = (uv_tcp_t *) malloc(sizeof(uv_tcp_t));//为tcp client申请资源
uv_tcp_init(loop, client);//初始化tcp client句柄
if (uv_accept(server, (uv_stream_t *) client) == 0) {
        do_some_thind();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;37、uv_read_start&quot;&gt;3.7、uv_read_start&lt;/h2&gt;
&lt;p&gt;libuv 中使用 uv_read_start() 方法从传入的 stream 中读取数据，声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int uv_read_start(uv_stream_t* stream, uv_alloc_cb alloc_cb, uv_read_cb read_cb)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;read_cb&lt;/strong&gt; 会被多次调用，直到数据读完，或者主动调用 uv_read_stop() 方法停止&lt;/p&gt;
&lt;p&gt;该函数有两个回调函数，&lt;strong&gt;alloc_cb&lt;/strong&gt; 用于为新来的数据申请空间，申请的资源需要在 &lt;strong&gt;read_cb&lt;/strong&gt; 中释放&lt;/p&gt;
&lt;p&gt;这两个回调的声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef void (*uv_alloc_cb)(uv_handle_t* handle, size_t suggested_size, uv_buf_t* buf);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef void (*uv_read_cb)(uv_stream_t* stream, ssize_t nread, const uv_buf_t* buf);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例代码：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;//负责为新来的消息申请空间
void alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf) {
  buf-&amp;gt;len = suggested_size;
  buf-&amp;gt;base = static_cast&amp;lt;char *&amp;gt;(malloc(suggested_size));
}
/**
 * @brief: 负责处理新来的消息
 * @param: client
 * @param: nread&amp;gt;0表示有数据就绪，nread&amp;lt;0表示异常，nread是有可能为0的，但是这并不是异常或者结束
 */
void read_cb(uv_stream_t *client, ssize_t nread, const uv_buf_t *buf) {
        do_somt_thing();
    //释放之前申请的资源
  if (buf-&amp;gt;base != NULL) {
    free(buf-&amp;gt;base);
  }
}

uv_read_start((uv_stream_t *) client, alloc_buffer, read_cb);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;38、uv_buf_t-和-uv_buf_init&quot;&gt;3.8、uv_buf_t 和 uv_buf_init&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;uv_buf_t&lt;/strong&gt; 是libuv 中的一种特殊的数据类型，和 Redis 的 SDS 有一点相似度，声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct uv_buf_t {
  char* base;
  size_t len;
} uv_buf_t;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;uv_buf_t&lt;/strong&gt; 可以使用 &lt;strong&gt;uv_buf_init&lt;/strong&gt; 初始化&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;uv_buf_t uvBuf = uv_buf_init(buf-&amp;gt;base, nread);//初始化write的uv_buf_t
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;39、uv_close&quot;&gt;3.9、uv_close&lt;/h2&gt;
&lt;p&gt;libuv 中使用 uv_close() 方法关闭句柄，声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void uv_close(uv_handle_t* handle, uv_close_cb close_cb)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;close_cb&lt;/strong&gt; 为关闭之后的回调，声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef void (*uv_close_cb)(uv_handle_t* handle);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;代码示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;void on_close(uv_handle_t *handle) {
  if (handle != NULL)
    free(handle);
}
...
uv_close((uv_handle_t *) client, on_close);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;310、uv_write&quot;&gt;3.10、uv_write&lt;/h2&gt;
&lt;p&gt;libuv 中使用 uv_write() 方法发送数据，声明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int uv_write(uv_write_t* req, uv_stream_t* handle, const uv_buf_t bufs[],
                       unsigned int nbufs, uv_write_cb cb);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;req&lt;/strong&gt; 是需要传递给回调函数的数据，发送需要申请资源，并在回调函数中释放&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;handle&lt;/strong&gt; 是接受的客户端&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;bufs[]&lt;/strong&gt; 是一个 &lt;strong&gt;uv_buf_t&lt;/strong&gt; 数组，可以一次添加多组数据，最终按照顺序发送&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nbufs&lt;/strong&gt; 表示需要发送的数组元素个数，一般小于等于 bufs 的大小&lt;/p&gt;
&lt;h2 id=&quot;311、uv_strerror&quot;&gt;3.11、uv_strerror&lt;/h2&gt;
&lt;p&gt;有些函数会有错误码，使用 uv_strerror() 方法获取错误码对应的描述&lt;/p&gt;

&lt;p&gt;源代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;uv.h&amp;gt;
#include &amp;lt;stdlib.h&amp;gt;

uv_loop_t *loop;
#define DEFAULT_PORT 7000

//连接队列最大长度
#define DEFAULT_BACKLOG 128

//负责为新来的消息申请空间
void alloc_buffer(uv_handle_t *handle, size_t suggested_size, uv_buf_t *buf) {
  buf-&amp;gt;len = suggested_size;
  buf-&amp;gt;base = static_cast&amp;lt;char *&amp;gt;(malloc(suggested_size));
}

void on_close(uv_handle_t *handle) {
  if (handle != NULL)
    free(handle);
}

void echo_write(uv_write_t *req, int status) {
  if (status) {
    fprintf(stderr, &quot;Write error %s\n&quot;, uv_strerror(status));
  }

  free(req);
}

/**
 * @brief: 负责处理新来的消息
 * @param: client
 * @param: nread&amp;gt;0表示有数据就绪，nread&amp;lt;0表示异常，nread是有可能为0的，但是这并不是异常或者结束
 * @author: sherlock
 */
void read_cb(uv_stream_t *client, ssize_t nread, const uv_buf_t *buf) {
  if (nread &amp;gt; 0) {
//    buf-&amp;gt;base[nread] = 0;
    fprintf(stdout, &quot;recv:%s\n&quot;, buf-&amp;gt;base);
    fflush(stdout);

    uv_write_t* req = (uv_write_t*)malloc(sizeof(uv_write_t));

    uv_buf_t uvBuf = uv_buf_init(buf-&amp;gt;base, nread);//初始化write的uv_buf_t

    //发送buffer数组，第四个参数表示数组大小
    uv_write(req, client, &amp;amp;uvBuf, 1, echo_write);

    return;
  } else if (nread &amp;lt; 0) {
    if (nread != UV_EOF) {
      fprintf(stderr, &quot;Read error %s\n&quot;, uv_err_name(nread));
    } else {
      fprintf(stderr, &quot;client disconnect\n&quot;);
    }
    uv_close((uv_handle_t *) client, on_close);
  }

  //释放之前申请的资源
  if (buf-&amp;gt;base != NULL) {
    free(buf-&amp;gt;base);
  }
}

/**
 *
 * @param:  server  libuv的tcp server对象
 * @param:  status  状态，小于0表示新连接有误
 * @author: sherlock
 */
void on_new_connection(uv_stream_t *server, int status) {
  if (status &amp;lt; 0) {
    fprintf(stderr, &quot;New connection error %s\n&quot;, uv_strerror(status));
    return;
  }

  uv_tcp_t *client = (uv_tcp_t *) malloc(sizeof(uv_tcp_t));//为tcp client申请资源

  uv_tcp_init(loop, client);//初始化tcp client句柄

  //判断accept是否成功
  if (uv_accept(server, (uv_stream_t *) client) == 0) {
    //从传入的stream中读取数据，read_cb会被多次调用，直到数据读完，或者主动调用uv_read_stop方法停止
    uv_read_start((uv_stream_t *) client, alloc_buffer, read_cb);
  } else {
    uv_close((uv_handle_t *) client, NULL);
  }
}

int main(int argc, char **argv) {
  loop = uv_default_loop();

  uv_tcp_t server;
  uv_tcp_init(loop, &amp;amp;server);//初始化tcp server对象

  struct sockaddr_in addr;

  uv_ip4_addr(&quot;0.0.0.0&quot;, DEFAULT_PORT, &amp;amp;addr);//将ip和port数据填充到sockaddr_in结构体中

  uv_tcp_bind(&amp;amp;server, (const struct sockaddr *) &amp;amp;addr, 0);//bind

  int r = uv_listen((uv_stream_t * ) &amp;amp; server, DEFAULT_BACKLOG, on_new_connection);//listen

  if (r) {
    fprintf(stderr, &quot;Listen error %s\n&quot;, uv_strerror(r));
    return 1;
  }

  return uv_run(loop, UV_RUN_DEFAULT);
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 28 Jan 2021 00:29:00 +0000</pubDate>
<dc:creator>sherlock_lin</dc:creator>
<og:description>1、说明 libuv 中实现 tcp server 的步骤和原生 socket 步骤类似，回忆一下 linux 下原生 socket 实现 tcp server 的步骤： 初始化 socket 环境，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sherlock-lin/p/14337912.html</dc:identifier>
</item>
<item>
<title>如何编写优秀的测试代码|单元测试 - 老于`</title>
<link>http://www.cnblogs.com/hunternet/p/14337896.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hunternet/p/14337896.html</guid>
<description>&lt;p&gt;无论如何组织测试,无论有多少测试,如果你不能信任、维护以及阅读它们,这些测试就几乎没有价值。要成为优秀的测试,它们应该同时具有如下三个属性。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;可靠性****。&lt;/strong&gt;开发人员希望运行的測试可靠,能够对测试结果有信心。可靠的测试没有缺陷而且测试正确的事情&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可维护&lt;/strong&gt;。性无法维护的測试是梦,它们会拖延项目计划,或者当项目日程紧张时被搁置一旁。如果修改测试花费时间过多,或者经常需要为很小的产品代码频繁变更修改测试,开发人员会直接停止测试的维护和修复工作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可读性&lt;/strong&gt;。人们不仅要能够阅读测试,还要在测试出问题时找出症结所在。失去可读性另外两个支柱很快也会倒塌。如果无法理解测试,测试的维护工作就会变得困难,也无法得到人们的信任。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;1-可靠性&quot;&gt;1. 可靠性&lt;/h3&gt;
&lt;h4 id=&quot;11-及时维护测试代码&quot;&gt;1.1 及时维护测试代码&lt;/h4&gt;
&lt;p&gt;测试代码与产品代码一样需要不断进行维护，一旦测试写好了并且通过了,通常是不应该修改或删除这些测试的。这些测试是你的保护网告诉你修改的代码是否破坏了已有的功能。虽说如此,有时可能还是需要修改或者删除已有的测试。要理解什么情况下修改或删除测试会带来问题,什么情况下这么做是合理的。&lt;br/&gt;删除一个测试的主要的理由是这个测试失败了。如果一个测试突然开始失败,可能有如下原因&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;产品缺陷    被测试的产品代码有缺陷。&lt;/li&gt;
&lt;li&gt;测试缺陷    测试中有缺陷。&lt;/li&gt;
&lt;li&gt;语义或者AP变更    被测试代码的语义发生变化,但是功能不变&lt;/li&gt;
&lt;li&gt;冲突或者无效的测试    和测试相关的产品需求发生变化,产品代码随之变更&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果测试或代码没有任何问题,修改或删除测试的原因有:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;重命名或者重构测试&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不可读的测试带来的麻烦比解决的问题更多。它会影响代码的可读性,妨碍你理解测试发现的问题&lt;br/&gt;如果你看到测试名含义不清或者令人误解,或者测试的可维护性有待提高,就应该修改测试代码(但是不要改变测试的基本功能)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;去除重复代码&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;12-避免测试代码中的逻辑&quot;&gt;1.2 避免测试代码中的逻辑&lt;/h4&gt;
&lt;p&gt;如果单元测试中有下列任何一种语句,你的测试就包含了不应该有的逻辑:*&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;switch、if或e1se语句;*&lt;/li&gt;
&lt;li&gt;foreach、for或whi1e循环。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;包含逻辑的测试通常会一次测试多个东西,我们不推荐这种做法,因为这样的测试可读性较也比较脆弱。而且测试逻辑也增加了代码复杂度,可能包含隐藏的缺陷通常来说,一个单元测试应该是一系列的方法调用和断言,但是不包含控制流语句,甚至不应将断言语句包含在try- catch中。任何更复杂的语句都可能导致如下问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试难以阅读和理解&lt;/li&gt;
&lt;li&gt;测试难以重现。(设想一下,如果一个多线程测试或者使用随机数的测试突然失败了,该如何处理。)&lt;/li&gt;
&lt;li&gt;测试较容易包含缺陷或者测试错误的事情&lt;/li&gt;
&lt;li&gt;难以命名测试,因为它执行多件任务&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;13-只测一个关注点&quot;&gt;1.3 只测一个关注点&lt;/h4&gt;
&lt;p&gt;如前所述,一个关注点是一个工作单元的一个最终结果:一个返回值、系统状态的一个改变或者对第三方对象的一个调用。例如:如果你的单元测试对多个对象进行了断言,那么这个测试有可能测试了多个关注点。另一种情况是,它既测试了一个对象返回正确的值,又验证系统状态改变导致这个对象的行为发生变化,那么这个测试也可能测试了多个关注点。&lt;br/&gt;测试多个关注点听起来没什么,但是等到你要命名测试,或者考虑第一个对象的断言失败该如何处理时,就会遇到问题。&lt;br/&gt;命名测试看似简单,但是如果同时测试了多个东西,就几乎不可能给测试起一个能说明测试内容的好名字。你最后起的名字可能非常通用,使得读者不得不去阅读测试代码(本章的可读性节详细对此进行讨论)。如果一次只测试一个关注点,测试命名就很简单&lt;/p&gt;
&lt;h4 id=&quot;14-单元测试与集成测试分离&quot;&gt;1.4 单元测试与集成测试分离&lt;/h4&gt;
&lt;p&gt;把集成混在单元测试里放在测试项目中会导致很多方面的问题。这种测试难以运行,会让人们误以为代码有问题,浪费时间和精力进行检查,最后导致开发人员不再信任这组测试。混在单元测试里的集成测试就像筐里的烂苹果连累了其他的测试。如果下一次再发生类似的事情,开发人员甚至都不会去调查失败原因,直接就说:“哦,那个测试有时候就是会失败,没事的。”要避免这样的事情发生,就要建一个绿色安全区把集成测试和单元测试分开。&lt;br/&gt;绿色安全区里只包含单元测试。运行绿色安全区里的所有测试测试结果应该全部是绿色的，如果有测试失败，就说明出现了真正的代码问题，而不是因为某些配置或外部依赖倒置的假警报。&lt;/p&gt;
&lt;h4 id=&quot;15-代码审查与覆盖率结合&quot;&gt;1.5 代码审查与覆盖率结合&lt;/h4&gt;
&lt;p&gt;代码覆盖率100%说明什么呢?如果没有做代码审查,这个覆盖率不能说明什么。你的团队可能会要求所有人的测试“达到95%以上的代码覆盖率”,大家可能也确实做到了。但是也许这些测试连断言都没有。人们通常会选择做最少的事情达到某个指定的目标。&lt;br/&gt;那么代码覆盖率100%再加上测试和代码审查能说明什么呢?这说明整个世界都是你的。如果你做了代码审查和测试审查,确保测试优秀而且覆盖了所有代码,那么你就拥有了一个安全网,可以避免愚蠢的错误,同时团队也获得了分享的知识,从持续的学习中获益&lt;/p&gt;
&lt;h3 id=&quot;2-可维护性&quot;&gt;2. 可维护性&lt;/h3&gt;

&lt;p&gt;作为开发者,单元测试中的重复代码和产品代码中的重复一样(如果不是更加)有害。DRY原则应该同样适用于测试代码。重复代码意味测试对象某方面改变时要修改更多的测试代码。如果测试中有大量重复代码,构造函数变更或者使用类的语义变化会产生极大的影响&lt;/p&gt;
&lt;h4 id=&quot;22-测试隔离&quot;&gt;2.2 测试隔离&lt;/h4&gt;
&lt;p&gt;测试隔离的基本概念是:一个测试应该总是在它自己的小世界中运行,与其他进行类似或不同的工作的测试隔离甚至不知道其他测试的存在。&lt;br/&gt;如果没有很好地隔离测试,它们会互相影响,使你非常悲惨,后悔在项目中尝试单元测试决心以后再也不做单元测试了。我见过这种情况。开发人员不愿费心检查测试中的问题,因此当出现问题时,需要花很多时间才能找到原因有些测试同样存在着一些坏味道能够提示测试隔离可能有问题。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强制的测试顺序    测试需要以某种特定顺序执行,或者需要来自其他测试结果的信息&lt;/li&gt;
&lt;li&gt;隐藏的测试调用    测试调用其他测试。&lt;/li&gt;
&lt;li&gt;共享状态损坏    测试共享内存里的状态,却没有回滚状态。&lt;/li&gt;
&lt;li&gt;外部共享状态损坏    集成测试共享资源,却没有回滚资源。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;23-避免对不同的关注点多次断言使用参数化测试&quot;&gt;2.3 避免对不同的关注点多次断言(使用参数化测试)&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;Assert.AreEqual(2,Sum(1,2));
Assert.AreEqual(5,Sum(2,2));
Assert.AreEqual(6,Sum(5,2));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上示例，这个测试方法中使用了三个断言，进行了三个测试。这样看起来在实际过程中会节省一些写代码的时间，但会有一些问题。如果第一个断言失败，则后续断言就不会在执行。而在这个示例中我们是进行了三个测试。第一个断言失败就会导致我们无法得知另外两个测试的测试结果。对于这种情况我们可以采取别的方式进行测试&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;给每个断言创建一个单独的测试&lt;/li&gt;
&lt;li&gt;使用参数化测试&lt;/li&gt;
&lt;li&gt;把断言代码放在一个try-catch块中&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;24-避免过度指定&quot;&gt;2.4 避免过度指定&lt;/h4&gt;
&lt;p&gt;过度指定的测试对一个具体的被测试单元如何实现其内部行为进行了假设,而不是只检查其最终行为的正确性单元测试中过度指定主要有以下几种情况&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试对一个被测试对象的纯内部状态进行了断言&lt;/li&gt;
&lt;li&gt;测试使用多个模拟对象&lt;/li&gt;
&lt;li&gt;测试在需要存根时使用模拟对象&lt;/li&gt;
&lt;li&gt;测试在不必要的情况下指定顺序或使用了精确匹配。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;3-可读性&quot;&gt;3. 可读性&lt;/h3&gt;
&lt;p&gt;不可读的测试几乎没有任何意义。可读性这条线连接着编写测试的人和几个月后阅读测试的人。测试是你向项目的下一代开发者讲述的故事,帮助开发者理解一个应用程序的组成及其开端。&lt;br/&gt;测试可读性有如下几个方面&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命名单元测试&lt;/li&gt;
&lt;li&gt;命名变量&lt;/li&gt;
&lt;li&gt;使用好的断言信息&lt;/li&gt;
&lt;li&gt;把断言和操作分离&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;31-单元测试命名&quot;&gt;3.1 单元测试命名&lt;/h4&gt;
&lt;p&gt;命名标准非常重要,提供了合理的规则和模板,列出应该包括的测试信息。测试名一般包括三部分。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;**被测试方法名    **非常关键,指明了被测试逻辑的位置。把被测试方法名放在测试方法开头,可以很容易地在测试类中浏览测试和使用智能感知(如果IDE支持)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试场景&lt;/strong&gt;     说明了测试使用的条件:“如果我用一个nu11值调用方法x,那么它应该执行Y。”&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;预期行为&lt;/strong&gt;    基于当前场景,方法应该产生的行为结果或者返回值,或者行为方式:“如果用一个null值调用方法X,那么它应该执行Y。”如果测试名缺少上面列出的任何一部分,测试的读者就会疑惑测试究竟在做什么,需要阅读测试代码。合理地命名测试,主要目的就是为了使后来的开发者从为了理解测试而阅读代码的负担中解脱出来。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void IsValidFileName(){
        ...
}

[Test]
public void IsValidFileName_WhenPNG_ReturnFalse(){
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上示例，通过测试的方法命名我们就可以大概知道要测试的是方法是IsValidFileName当输入参数是PNG的时候，预期返回False。&lt;/p&gt;
&lt;p&gt;当然，你的团队也可以有适合自己的命名方式，但重要的是如果一个团队中都有统一的有意义命名规范，那么单元测试的可读性将大大提升，并且有利于后来者快速进入项目，理解测试。&lt;/p&gt;
&lt;h4 id=&quot;32-变量命名&quot;&gt;3.2 变量命名&lt;/h4&gt;
&lt;p&gt;测试中的变量命名和产品代码中的命名规范同样重要，通过合理的变量命名，我们可以确保阅读测试的人可以尽快的理解你要验证什么。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// 反例
Assert.AreEqual(100,actual);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上示例，我们经常会看到测试中出现&quot;100&quot;这样的魔法数字。因为测试中没有描述性的名字，也许你在刚刚写完的时候还知道它是什么意思，但是一周后，一月后，一年后呢？甚至你未来的继任者看到这样的测试代码也是一头雾水。&lt;/p&gt;
&lt;h4 id=&quot;34-断言和操作分离&quot;&gt;3.4 断言和操作分离&lt;/h4&gt;
&lt;p&gt;很多人为了“偷懒”经常会把断言和方法调用卸载同一行里，但这是一个很不好的习惯，它会大大降低代码的可读性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// 反例
    Assert.AreEqual(true,fileManger.IsValidName())

// 正例
    bool expect=true;
    bool actual=fileManger.IsValidName();
    Assert.AreEqual(expect,actual)

&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 28 Jan 2021 00:07:00 +0000</pubDate>
<dc:creator>老于`</dc:creator>
<og:description>无论如何组织测试,无论有多少测试,如果你不能信任、维护以及阅读它们,这些测试就几乎没有价值。要成为优秀的测试,它们应该同时具有如下三个属性。 可靠性**。**开发人员希望运行的測试可靠,能够对测试结果</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hunternet/p/14337896.html</dc:identifier>
</item>
<item>
<title>jackson学习之三：常用API操作 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14337888.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14337888.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;系列文章汇总&quot;&gt;系列文章汇总&lt;/h3&gt;
&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;jacksondemo&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210128075328530-139775265.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;p&gt;本文是《jackson学习》系列的第三篇，前面咱们学习了jackson的低阶API，知道了底层原理，本篇开始学习平时最常用的基本功能，涉及内容如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;体验最常用的操作，内容如下图所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210128075329253-1405421599.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;介绍常用的可配置属性，以便按需要来设置；&lt;/li&gt;
&lt;li&gt;接下来进入快速浏览的环节，咱们一起先把各个API过一遍；&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;单个对象序列化&quot;&gt;单个对象序列化&lt;/h3&gt;
&lt;p&gt;先看常用的序列化API：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对象转字符串：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String jsonStr = mapper.writeValueAsString(twitterEntry);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;对象转文件：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.writeValue(new File(&quot;twitter.json&quot;), twitterEntry);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;对象转byte数组：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;byte[] array = mapper.writeValueAsBytes(twitterEntry);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;单个对象反序列化&quot;&gt;单个对象反序列化&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;字符串转对象：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TwitterEntry tFromStr = mapper.readValue(objectJsonStr, TwitterEntry.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;文件转对象：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TwitterEntry tFromFile = mapper.readValue(new File(&quot;twitter.json&quot;), TwitterEntry.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;byte数组转对象：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TwitterEntry tFromBytes = mapper.readValue(array, TwitterEntry.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;字符串网络地址转对象：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String testJsonDataUrl = &quot;https://raw.githubusercontent.com/zq2599/blog_demos/master/files/twitteer_message.json&quot;;

TwitterEntry tFromUrl = mapper.readValue(new URL(testJsonDataUrl), TwitterEntry.class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;集合序列化&quot;&gt;集合序列化&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;HashMap转字符串：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String mapJsonStr = mapper.writeValueAsString(map);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;集合反序列化&quot;&gt;集合反序列化&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;字符串转HashMap：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Map&amp;lt;String, Object&amp;gt; mapFromStr = mapper.readValue(mapJsonStr, new TypeReference&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;() {});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;jsonnode&quot;&gt;JsonNode&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想使用XXX.class来做反序列化，也能使用JsonNode来操作：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;JsonNode jsonNode = mapper.readTree(mapJsonStr);
String name = jsonNode.get(&quot;name&quot;).asText();
int age = jsonNode.get(&quot;age&quot;).asInt();
String city = jsonNode.get(&quot;addr&quot;).get(&quot;city&quot;).asText();
String street = jsonNode.get(&quot;addr&quot;).get(&quot;street&quot;).asText();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;时间字段格式化&quot;&gt;时间字段格式化&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;对于Date字段，默认的反序列化是时间戳，可以修改配置：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;));
dateMapStr = mapper.writeValueAsString(dateMap);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;json数组的反序列化&quot;&gt;JSON数组的反序列化&lt;/h3&gt;
&lt;p&gt;假设jsonArrayStr是个json数组格式的字符串：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;JSON数组转对象数组：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;TwitterEntry[] twitterEntryArray = mapper.readValue(jsonArrayStr, TwitterEntry[].class);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;JSON数组转对象集合(ArrayList)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;TwitterEntry&amp;gt; twitterEntryList = mapper.readValue(jsonArrayStr, new TypeReference&amp;lt;List&amp;lt;TwitterEntry&amp;gt;&amp;gt;() {});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;完整代码&quot;&gt;完整代码&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;上述所有常用API用法的完整代码如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.jacksondemo.databind;

import com.bolingcavalry.jacksondemo.beans.TwitterEntry;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import java.io.File;
import java.net.URL;
import java.text.SimpleDateFormat;
import java.util.*;

public class SimpleDemo {

    private static final Logger logger = LoggerFactory.getLogger(SimpleDemo.class);

    public static void main(String[] args) throws Exception {
        ObjectMapper mapper = new ObjectMapper();

        logger.info(&quot;以下是序列化操作&quot;);

        // 对象 -&amp;gt; 字符串
        TwitterEntry twitterEntry = new TwitterEntry();
        twitterEntry.setId(123456L);
        twitterEntry.setFromUserId(101);
        twitterEntry.setToUserId(102);
        twitterEntry.setText(&quot;this is a message for serializer test&quot;);
        twitterEntry.setLanguageCode(&quot;zh&quot;);

        String jsonStr = mapper.writeValueAsString(twitterEntry);
        logger.info(&quot;序列化的字符串：{}&quot;, jsonStr);

        // 对象 -&amp;gt; 文件
        mapper.writeValue(new File(&quot;twitter.json&quot;), twitterEntry);

        // 对象 -&amp;gt; byte数组
        byte[] array = mapper.writeValueAsBytes(twitterEntry);

        logger.info(&quot;\n\n以下是反序列化操作&quot;);

        // 字符串 -&amp;gt; 对象
        String objectJsonStr = &quot;{\n&quot; +
                &quot;  \&quot;id\&quot;:1125687077,\n&quot; +
                &quot;  \&quot;text\&quot;:\&quot;@stroughtonsmith You need to add a \\\&quot;Favourites\\\&quot; tab to TC/iPhone. Like what TwitterFon did. I can't WAIT for your Twitter App!! :) Any ETA?\&quot;,\n&quot; +
                &quot;  \&quot;fromUserId\&quot;:855523, \n&quot; +
                &quot;  \&quot;toUserId\&quot;:815309,\n&quot; +
                &quot;  \&quot;languageCode\&quot;:\&quot;en\&quot;\n&quot; +
                &quot;}&quot;;


        TwitterEntry tFromStr = mapper.readValue(objectJsonStr, TwitterEntry.class);
        logger.info(&quot;从字符串反序列化的对象：{}&quot;, tFromStr);

        // 文件 -&amp;gt; 对象
        TwitterEntry tFromFile = mapper.readValue(new File(&quot;twitter.json&quot;), TwitterEntry.class);
        logger.info(&quot;从文件反序列化的对象：{}&quot;, tFromStr);

        // byte数组 -&amp;gt; 对象
        TwitterEntry tFromBytes = mapper.readValue(array, TwitterEntry.class);
        logger.info(&quot;从byte数组反序列化的对象：{}&quot;, tFromBytes);

        // 字符串网络地址 -&amp;gt; 对象
        String testJsonDataUrl = &quot;https://raw.githubusercontent.com/zq2599/blog_demos/master/files/twitteer_message.json&quot;;

        TwitterEntry tFromUrl = mapper.readValue(new URL(testJsonDataUrl), TwitterEntry.class);
        logger.info(&quot;从网络地址反序列化的对象：{}&quot;, tFromUrl);


        logger.info(&quot;\n\n以下是集合序列化操作&quot;);

        Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        map.put(&quot;name&quot;, &quot;tom&quot;);
        map.put(&quot;age&quot;, 11);

        Map&amp;lt;String, String&amp;gt; addr = new HashMap&amp;lt;&amp;gt;();
        addr.put(&quot;city&quot;,&quot;深圳&quot;);
        addr.put(&quot;street&quot;, &quot;粤海&quot;);

        map.put(&quot;addr&quot;, addr);

        String mapJsonStr = mapper.writeValueAsString(map);
        logger.info(&quot;HashMap序列化的字符串：{}&quot;, mapJsonStr);

        logger.info(&quot;\n\n以下是集合反序列化操作&quot;);
        Map&amp;lt;String, Object&amp;gt; mapFromStr = mapper.readValue(mapJsonStr, new TypeReference&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt;() {});
        logger.info(&quot;从字符串反序列化的HashMap对象：{}&quot;, mapFromStr);

        // JsonNode类型操作
        JsonNode jsonNode = mapper.readTree(mapJsonStr);
        String name = jsonNode.get(&quot;name&quot;).asText();
        int age = jsonNode.get(&quot;age&quot;).asInt();
        String city = jsonNode.get(&quot;addr&quot;).get(&quot;city&quot;).asText();
        String street = jsonNode.get(&quot;addr&quot;).get(&quot;street&quot;).asText();

        logger.info(&quot;用JsonNode对象和API反序列化得到的数：name[{}]、age[{}]、city[{}]、street[{}]&quot;, name, age, city, street);

        // 时间类型格式

        Map&amp;lt;String, Object&amp;gt; dateMap = new HashMap&amp;lt;&amp;gt;();
        dateMap.put(&quot;today&quot;, new Date());

        String dateMapStr = mapper.writeValueAsString(dateMap);
        logger.info(&quot;默认的时间序列化：{}&quot;, dateMapStr);

        // 设置时间格式
        mapper.setDateFormat(new SimpleDateFormat(&quot;yyyy-MM-dd hh:mm:ss&quot;));
        dateMapStr = mapper.writeValueAsString(dateMap);
        logger.info(&quot;自定义的时间序列化：{}&quot;, dateMapStr);

        System.out.println(objectJsonStr);

        // json数组
        String jsonArrayStr = &quot;[{\n&quot; +
                &quot;  \&quot;id\&quot;:1,\n&quot; +
                &quot;  \&quot;text\&quot;:\&quot;text1\&quot;,\n&quot; +
                &quot;  \&quot;fromUserId\&quot;:11, \n&quot; +
                &quot;  \&quot;toUserId\&quot;:111,\n&quot; +
                &quot;  \&quot;languageCode\&quot;:\&quot;en\&quot;\n&quot; +
                &quot;},\n&quot; +
                &quot;{\n&quot; +
                &quot;  \&quot;id\&quot;:2,\n&quot; +
                &quot;  \&quot;text\&quot;:\&quot;text2\&quot;,\n&quot; +
                &quot;  \&quot;fromUserId\&quot;:22, \n&quot; +
                &quot;  \&quot;toUserId\&quot;:222,\n&quot; +
                &quot;  \&quot;languageCode\&quot;:\&quot;zh\&quot;\n&quot; +
                &quot;},\n&quot; +
                &quot;{\n&quot; +
                &quot;  \&quot;id\&quot;:3,\n&quot; +
                &quot;  \&quot;text\&quot;:\&quot;text3\&quot;,\n&quot; +
                &quot;  \&quot;fromUserId\&quot;:33, \n&quot; +
                &quot;  \&quot;toUserId\&quot;:333,\n&quot; +
                &quot;  \&quot;languageCode\&quot;:\&quot;en\&quot;\n&quot; +
                &quot;}]&quot;;

        // json数组 -&amp;gt; 对象数组
        TwitterEntry[] twitterEntryArray = mapper.readValue(jsonArrayStr, TwitterEntry[].class);
        logger.info(&quot;json数组反序列化成对象数组：{}&quot;, Arrays.toString(twitterEntryArray));

        // json数组 -&amp;gt; 对象集合
        List&amp;lt;TwitterEntry&amp;gt; twitterEntryList = mapper.readValue(jsonArrayStr, new TypeReference&amp;lt;List&amp;lt;TwitterEntry&amp;gt;&amp;gt;() {});
        logger.info(&quot;json数组反序列化成对象集合：{}&quot;, twitterEntryList);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;执行结果如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;C:\jdk\bin\java.exe -javaagent:C:\sofware\JetBrains\IntelliJIDEA\lib\idea_rt.jar=64570:C:\sofware\JetBrains\IntelliJIDEA\bin -Dfile.encoding=UTF-8 -classpath C:\jdk\jre\lib\charsets.jar;C:\jdk\jre\lib\deploy.jar;C:\jdk\jre\lib\ext\access-bridge-64.jar;C:\jdk\jre\lib\ext\cldrdata.jar;C:\jdk\jre\lib\ext\dnsns.jar;C:\jdk\jre\lib\ext\jaccess.jar;C:\jdk\jre\lib\ext\jfxrt.jar;C:\jdk\jre\lib\ext\localedata.jar;C:\jdk\jre\lib\ext\nashorn.jar;C:\jdk\jre\lib\ext\sunec.jar;C:\jdk\jre\lib\ext\sunjce_provider.jar;C:\jdk\jre\lib\ext\sunmscapi.jar;C:\jdk\jre\lib\ext\sunpkcs11.jar;C:\jdk\jre\lib\ext\zipfs.jar;C:\jdk\jre\lib\javaws.jar;C:\jdk\jre\lib\jce.jar;C:\jdk\jre\lib\jfr.jar;C:\jdk\jre\lib\jfxswt.jar;C:\jdk\jre\lib\jsse.jar;C:\jdk\jre\lib\management-agent.jar;C:\jdk\jre\lib\plugin.jar;C:\jdk\jre\lib\resources.jar;C:\jdk\jre\lib\rt.jar;D:\github\blog_demos\jacksondemo\databind\target\classes;C:\Users\12167\.m2\repository\com\fasterxml\jackson\core\jackson-databind\2.11.0\jackson-databind-2.11.0.jar;C:\Users\12167\.m2\repository\com\fasterxml\jackson\core\jackson-annotations\2.11.0\jackson-annotations-2.11.0.jar;C:\Users\12167\.m2\repository\com\fasterxml\jackson\core\jackson-core\2.11.0\jackson-core-2.11.0.jar;C:\Users\12167\.m2\repository\org\slf4j\slf4j-log4j12\1.7.25\slf4j-log4j12-1.7.25.jar;C:\Users\12167\.m2\repository\org\slf4j\slf4j-api\1.7.25\slf4j-api-1.7.25.jar;C:\Users\12167\.m2\repository\log4j\log4j\1.2.17\log4j-1.2.17.jar;C:\Users\12167\.m2\repository\commons-io\commons-io\2.7\commons-io-2.7.jar;C:\Users\12167\.m2\repository\org\apache\commons\commons-lang3\3.10\commons-lang3-3.10.jar;D:\github\blog_demos\jacksondemo\beans\target\classes com.bolingcavalry.jacksondemo.databind.SimpleDemo
2020-08-28 07:53:01 INFO  SimpleDemo:27 - 以下是序列化操作
2020-08-28 07:53:01 INFO  SimpleDemo:38 - 序列化的字符串：{&quot;id&quot;:123456,&quot;text&quot;:&quot;this is a message for serializer test&quot;,&quot;fromUserId&quot;:101,&quot;toUserId&quot;:102,&quot;languageCode&quot;:&quot;zh&quot;}
2020-08-28 07:53:01 INFO  SimpleDemo:47 - 

以下是反序列化操作
2020-08-28 07:53:01 INFO  SimpleDemo:60 - 从字符串反序列化的对象：[Tweet, id: 1125687077, text='@stroughtonsmith You need to add a &quot;Favourites&quot; tab to TC/iPhone. Like what TwitterFon did. I can't WAIT for your Twitter App!! :) Any ETA?', from: 855523, to: 815309, lang: en]
2020-08-28 07:53:01 INFO  SimpleDemo:64 - 从文件反序列化的对象：[Tweet, id: 1125687077, text='@stroughtonsmith You need to add a &quot;Favourites&quot; tab to TC/iPhone. Like what TwitterFon did. I can't WAIT for your Twitter App!! :) Any ETA?', from: 855523, to: 815309, lang: en]
2020-08-28 07:53:01 INFO  SimpleDemo:68 - 从byte数组反序列化的对象：[Tweet, id: 123456, text='this is a message for serializer test', from: 101, to: 102, lang: zh]
2020-08-28 07:53:04 INFO  SimpleDemo:74 - 从网络地址反序列化的对象：[Tweet, id: 112233445566, text='this is a message from zq2599's github', from: 201, to: 202, lang: en]
2020-08-28 07:53:04 INFO  SimpleDemo:77 - 

以下是集合序列化操作
2020-08-28 07:53:04 INFO  SimpleDemo:90 - HashMap序列化的字符串：{&quot;name&quot;:&quot;tom&quot;,&quot;addr&quot;:{&quot;city&quot;:&quot;深圳&quot;,&quot;street&quot;:&quot;粤海&quot;},&quot;age&quot;:11}
2020-08-28 07:53:04 INFO  SimpleDemo:92 - 

以下是集合反序列化操作
2020-08-28 07:53:04 INFO  SimpleDemo:94 - 从字符串反序列化的HashMap对象：{name=tom, addr={city=深圳, street=粤海}, age=11}
2020-08-28 07:53:04 INFO  SimpleDemo:103 - 用JsonNode对象和API反序列化得到的数：name[tom]、age[11]、city[深圳]、street[粤海]
2020-08-28 07:53:04 INFO  SimpleDemo:111 - 默认的时间序列化：{&quot;today&quot;:1598572384838}
2020-08-28 07:53:04 INFO  SimpleDemo:116 - 自定义的时间序列化：{&quot;today&quot;:&quot;2020-08-28 07:53:04&quot;}
{
  &quot;id&quot;:1125687077,
  &quot;text&quot;:&quot;@stroughtonsmith You need to add a \&quot;Favourites\&quot; tab to TC/iPhone. Like what TwitterFon did. I can't WAIT for your Twitter App!! :) Any ETA?&quot;,
  &quot;fromUserId&quot;:855523, 
  &quot;toUserId&quot;:815309,
  &quot;languageCode&quot;:&quot;en&quot;
}
2020-08-28 07:53:04 INFO  SimpleDemo:145 - json数组反序列化成对象数组：[[Tweet, id: 1, text='text1', from: 11, to: 111, lang: en], [Tweet, id: 2, text='text2', from: 22, to: 222, lang: zh], [Tweet, id: 3, text='text3', from: 33, to: 333, lang: en]]
2020-08-28 07:53:04 INFO  SimpleDemo:149 - json数组反序列化成对象集合：[[Tweet, id: 1, text='text1', from: 11, to: 111, lang: en], [Tweet, id: 2, text='text2', from: 22, to: 222, lang: zh], [Tweet, id: 3, text='text3', from: 33, to: 333, lang: en]]

Process finished with exit code 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;还会产生名为twitter.json的文件，内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;{&quot;id&quot;:123456,&quot;text&quot;:&quot;this is a message for serializer test&quot;,&quot;fromUserId&quot;:101,&quot;toUserId&quot;:102,&quot;languageCode&quot;:&quot;zh&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;常用配置&quot;&gt;常用配置&lt;/h3&gt;
&lt;p&gt;下面是平时可能用到的自定义配置项目：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;序列化结果格式化：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.enable(SerializationFeature.INDENT_OUTPUT);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;空对象不要抛出异常：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.disable(SerializationFeature.FAIL_ON_EMPTY_BEANS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Date、Calendar等序列化为时间格式的字符串(如果不执行以下设置，就会序列化成时间戳格式)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;反序列化时，遇到未知属性不要抛出异常：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;反序列化时，空字符串对于的实例属性为null：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.enable(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;允许C和C++样式注释：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;7&quot;&gt;&lt;li&gt;允许字段名没有引号（可以进一步减小json体积）：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot;&gt;&lt;li&gt;允许单引号：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;特殊配置：在json对象最外层再包裹一层&quot;&gt;特殊配置：在json对象最外层再包裹一层&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;最后要说的是个特殊配置，先来看看正常情况一个普通的序列化结果：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;id&quot; : 1,
  &quot;text&quot; : &quot;aabbcc&quot;,
  &quot;fromUserId&quot; : 456,
  &quot;toUserId&quot; : 0,
  &quot;languageCode&quot; : &quot;zh&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;接下来咱们做两件事，首先，是给上述json对应的实例类添加一个注解，如下图红框：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210128075329560-1064412499.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;3. 其次，执行以下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.enable(SerializationFeature.WRAP_ROOT_VALUE);
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;然后再次执行TwitterEntry实例的序列化，得到的结果如下，可见和之前的序列化结果相比，之前的整个json都变成了一个value，此value对应的key就是注解JsonRootName的value属性：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;{
  &quot;aaa&quot; : {
    &quot;id&quot; : 1,
    &quot;text&quot; : &quot;aabbcc&quot;,
    &quot;fromUserId&quot; : 456,
    &quot;toUserId&quot; : 0,
    &quot;languageCode&quot; : &quot;zh&quot;
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;至此，开发中常用的API和配置都已经介绍完成，希望能给您带来一些参考，接下来的章节，咱们一起去了解另一个常用操作：&lt;span&gt;jackson注解&lt;/span&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 27 Jan 2021 23:53:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14337888.html</dc:identifier>
</item>
<item>
<title> Soul 网关 Nacos 数据同步源码解析 - 编程我的一切</title>
<link>http://www.cnblogs.com/qishun/p/14337879.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qishun/p/14337879.html</guid>
<description>&lt;p&gt;学习&lt;a title=&quot;http://www.dtmao.cc/news_show_647023.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_647023.shtml&quot; target=&quot;_blank&quot;&gt;Soul&lt;/a&gt; 网关 Nacos 数据同步源码解析&lt;/p&gt;

&lt;ol&gt;&lt;li&gt;环境配置&lt;/li&gt;
&lt;li&gt;&lt;a title=&quot;http://www.dtmao.cc/news_show_647023.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_647023.shtml&quot; target=&quot;_blank&quot;&gt;Soul&lt;/a&gt; 网关 Nacos 数据同步基本概念&lt;/li&gt;
&lt;li&gt;源码分析&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;环境配置：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;引入依赖&lt;br/&gt;在 &lt;a title=&quot;http://www.qishunwang.net/news_show_10488.aspx&quot; href=&quot;http://www.qishunwang.net/news_show_10488.aspx&quot; target=&quot;_blank&quot;&gt;soul-bootstrap&lt;/a&gt; 项目的 pom.xml 文件中引入了 soul-spring-boot-starter-sync-data-nacos 这个 starter 。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;  &amp;lt;dependency&amp;gt;
          &amp;lt;groupId&amp;gt;org.dromara&amp;lt;/groupId&amp;gt;
           &amp;lt;artifactId&amp;gt;soul-spring-boot-starter-sync-data-nacos&amp;lt;/artifactId&amp;gt;
           &amp;lt;version&amp;gt;${last.version}&amp;lt;/version&amp;gt;
     &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;环境配置&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在 &lt;a title=&quot;http://www.qishunwang.net/news_show_10488.aspx&quot; href=&quot;http://www.qishunwang.net/news_show_10488.aspx&quot; target=&quot;_blank&quot;&gt;soul-bootstrap&lt;/a&gt; 项目的 application-local.yml 文件中，配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;soul :
         sync:
            nacos:
                 url: localhost:8848
                 namespace: 1c10d748-af86-43b9-8265-75f487d20c6c
                 acm:
                   enabled: false
                   endpoint: acm.aliyun.com
                   namespace:
                   accessKey:
                   secretKey:
                   #url: 配置成你的nacos地址，集群环境请使用（,）分隔。
                
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 soul-admin 项目中的 application.yml 文件中配置 nacos 同步的相关配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;soul:
  sync:
    nacos:
      url: localhost:8848
      namespace: 7aba82c9-426b-4d72-89c9-060d9af63e14
       # 此处为前文中提到的命名空间ID或命名空间名称 soul
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Nacos 的关键特性&lt;br/&gt;服务发现和服务健康监测&lt;br/&gt;动态配置服务&lt;br/&gt;动态 DNS 服务&lt;br/&gt;服务及其元数据管理&lt;br/&gt;Nacos 中的几个概念&lt;br/&gt;命名空间(Namespace)： 不同环境的配置隔离&lt;br/&gt;配置分组(Group)： 不同的服务可以归类到同一分组。一般将一个项目的配置分到一组&lt;br/&gt;配置集(Data ID) ： 一个配置文件通常就是一个配置集&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;nacos同步策略-源码追踪&lt;br/&gt;从 soul-bootstrap 开始追踪&lt;br/&gt;NacosSyncDataConfiguration 这个类加载了 soul.sync.nacos 这段配置。该类创建了 nacosSyncDataService 。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;@Bean
public SyncDataService nacosSyncDataService(final ObjectProvider&amp;lt;ConfigService&amp;gt; configService, final ObjectProvider&amp;lt;PluginDataSubscriber&amp;gt; pluginSubscriber,
                                            final ObjectProvider&amp;lt;List&amp;lt;MetaDataSubscriber&amp;gt;&amp;gt; metaSubscribers, final ObjectProvider&amp;lt;List&amp;lt;AuthDataSubscriber&amp;gt;&amp;gt; authSubscribers) {
    log.info(&quot;you use nacos sync soul data.......&quot;);
    return new NacosSyncDataService(configService.getIfAvailable(), pluginSubscriber.getIfAvailable(),
                                metaSubscribers.getIfAvailable(Collections::emptyList), authSubscribers.getIfAvailable(Collections::emptyList));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public NacosSyncDataService(final ConfigService configService, final PluginDataSubscriber pluginDataSubscriber,
                            final List&amp;lt;MetaDataSubscriber&amp;gt; metaDataSubscribers, final List&amp;lt;AuthDataSubscriber&amp;gt; authDataSubscribers) {
    super(configService, pluginDataSubscriber, metaDataSubscribers, authDataSubscribers);
    start();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public void start() {
    watcherData(PLUGIN_DATA_ID, this::updatePluginMap);
    watcherData(SELECTOR_DATA_ID, this::updateSelectorMap);
    watcherData(RULE_DATA_ID, this::updateRuleMap);
    watcherData(META_DATA_ID, this::updateMetaDataMap);
    watcherData(AUTH_DATA_ID, this::updateAuthMap);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入 watcherData 方法，此时我们会进入一个重要的类 NacosCacheHandler 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 即便对 lambda 不熟悉，我们也可以大致推测，这里的功能应该是通过调用updateXxxMap方法，对元数据、插件、选择器等进行监听
protected void watcherData(final String dataId, final OnChange oc) {
    Listener listener = new Listener() {
        @Override
        public void receiveConfigInfo(final String configInfo) {
            oc.change(configInfo);
        }

        @Override
        public Executor getExecutor() {
            return null;
        }
    };
    oc.change(getConfigAndSignListener(dataId, listener));
    LISTENERS.computeIfAbsent(dataId, key -&amp;gt; new ArrayList&amp;lt;&amp;gt;()).add(listener);
}

protected interface OnChange {
    void change(String changeData);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;updatePluginMap 方法:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected void updatePluginMap(final String configInfo) {
    try {
        // Fix bug #656(https://github.com/dromara/soul/issues/656) 此处解决了一个 nacos data sync error 的 bug
        List&amp;lt;PluginData&amp;gt; pluginDataList = new ArrayList&amp;lt;&amp;gt;(GsonUtils.getInstance().toObjectMap(configInfo, PluginData.class).values());
        pluginDataList.forEach(pluginData -&amp;gt; Optional.ofNullable(pluginDataSubscriber).ifPresent(subscriber -&amp;gt; {
            subscriber.unSubscribe(pluginData);
            subscriber.onSubscribe(pluginData);
        }));
    } catch (JsonParseException e) {
        log.error(&quot;sync plugin data have error:&quot;, e);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;追踪一下 unSubscribe(pluginData) 和 onSubscribe(pluginData) ，进入 CommonPluginDataSubscriber 中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void onSubscribe(final PluginData pluginData) {
    subscribeDataHandler(pluginData, DataEventTypeEnum.UPDATE);
}

@Override
public void unSubscribe(final PluginData pluginData) {
    subscribeDataHandler(pluginData, DataEventTypeEnum.DELETE);
}

// 根据传入的数据类型ID，和数据处理类型，调用相应的处理函数，看具体是执行update更新还是delete删除
private &amp;lt;T&amp;gt; void subscribeDataHandler(final T classData, final DataEventTypeEnum dataType) {
    Optional.ofNullable(classData).ifPresent(data -&amp;gt; {
        if (data instanceof PluginData) {
            PluginData pluginData = (PluginData) data;
            if (dataType == DataEventTypeEnum.UPDATE) {
                BaseDataCache.getInstance().cachePluginData(pluginData);
                Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&amp;gt; handler.handlerPlugin(pluginData));
            } else if (dataType == DataEventTypeEnum.DELETE) {
                BaseDataCache.getInstance().removePluginData(pluginData);
                Optional.ofNullable(handlerMap.get(pluginData.getName())).ifPresent(handler -&amp;gt; handler.removePlugin(pluginData));
            }
        } else if (data instanceof SelectorData) {
            SelectorData selectorData = (SelectorData) data;
            if (dataType == DataEventTypeEnum.UPDATE) {
                BaseDataCache.getInstance().cacheSelectData(selectorData);
                Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&amp;gt; handler.handlerSelector(selectorData));
            } else if (dataType == DataEventTypeEnum.DELETE) {
                BaseDataCache.getInstance().removeSelectData(selectorData);
                Optional.ofNullable(handlerMap.get(selectorData.getPluginName())).ifPresent(handler -&amp;gt; handler.removeSelector(selectorData));
            }
        } else if (data instanceof RuleData) {
            RuleData ruleData = (RuleData) data;
            if (dataType == DataEventTypeEnum.UPDATE) {
                BaseDataCache.getInstance().cacheRuleData(ruleData);
                Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&amp;gt; handler.handlerRule(ruleData));
            } else if (dataType == DataEventTypeEnum.DELETE) {
                BaseDataCache.getInstance().removeRuleData(ruleData);
                Optional.ofNullable(handlerMap.get(ruleData.getPluginName())).ifPresent(handler -&amp;gt; handler.removeRule(ruleData));
            }
        }
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;admin追踪：&lt;br/&gt;是 DataSyncConfiguration 这个类加载了 soul.sync.nacos 这段配置。该类创建了 NacosDataChangedListener 。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * The type Nacos listener.
 */
@Configuration
@ConditionalOnProperty(prefix = &quot;soul.sync.nacos&quot;, name = &quot;url&quot;)
@Import(NacosConfiguration.class)
static class NacosListener {

    /**
         * Data changed listener data changed listener.
         *
         * @param configService the config service
         * @return the data changed listener
         */
    @Bean
    @ConditionalOnMissingBean(NacosDataChangedListener.class)
    public DataChangedListener nacosDataChangedListener(final ConfigService configService) {
        return new NacosDataChangedListener(configService);
    }

    /**
         * Nacos data init zookeeper data init.
         *
         * @param configService the config service
         * @param syncDataService the sync data service
         * @return the nacos data init
         */
    @Bean
    @ConditionalOnMissingBean(NacosDataInit.class)
    public NacosDataInit nacosDataInit(final ConfigService configService, final SyncDataService syncDataService) {
        return new NacosDataInit(configService, syncDataService);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;@Override
public void run(final String... args) {
    String pluginDataId = NacosPathConstants.PLUGIN_DATA_ID;
    String authDataId = NacosPathConstants.AUTH_DATA_ID;
    String metaDataId = NacosPathConstants.META_DATA_ID;
    if (dataIdNotExist(pluginDataId) &amp;amp;&amp;amp; dataIdNotExist(authDataId) &amp;amp;&amp;amp; dataIdNotExist(metaDataId)) {
        syncDataService.syncAll(DataEventTypeEnum.REFRESH);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// type 是 REFRESH
@Override
public boolean syncAll(final DataEventTypeEnum type) {
    appAuthService.syncData();
    List&amp;lt;PluginData&amp;gt; pluginDataList = pluginService.listAll();
    eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.PLUGIN, type, pluginDataList));
    List&amp;lt;SelectorData&amp;gt; selectorDataList = selectorService.listAll();
    eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.SELECTOR, type, selectorDataList));
    List&amp;lt;RuleData&amp;gt; ruleDataList = ruleService.listAll();
    eventPublisher.publishEvent(new DataChangedEvent(ConfigGroupEnum.RULE, type, ruleDataList));
    metaDataService.syncData();
    return true;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public static void send(final String message, final DataEventTypeEnum type) {
    if (StringUtils.isNotBlank(message)) {
        if (DataEventTypeEnum.MYSELF == type) {
            Session session = (Session) ThreadLocalUtil.get(SESSION_KEY);
            if (session != null) {
                sendMessageBySession(session, message);
            }
        } else {
            SESSION_SET.forEach(session -&amp;gt; sendMessageBySession(session, message));
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 27 Jan 2021 23:35:00 +0000</pubDate>
<dc:creator>编程我的一切</dc:creator>
<og:description>学习目标： 学习Soul 网关 Nacos 数据同步源码解析 学习内容： 环境配置 Soul 网关 Nacos 数据同步基本概念 源码分析 学习时间：2020年1月28号 早7点 学习产出： 环境配置</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qishun/p/14337879.html</dc:identifier>
</item>
<item>
<title>SharePoint Online 站点模板中权限的设置 - 老王717</title>
<link>http://www.cnblogs.com/sharepointonline/p/14337826.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sharepointonline/p/14337826.html</guid>
<description>&lt;p&gt;SharePoint Online可以使用PnP引擎部署站点模板。这个模板的功能非常强大，除了可以定制主题，外观以外，还可以生成list并导入数据，生成文档库，导入文档等等。&lt;/p&gt;
&lt;p&gt;今天重点说一下其中的站点权限部分。目前最新的Schema版本是202002，完整版可以参考 https://github.com/pnp/PnP-Provisioning-Schema/blob/master/OfficeDevPnP.ProvisioningSchema/ProvisioningSchema-2020-02.xsd。另外还有一个非常详细的样例文件，链接是：https://github.com/pnp/PnP-Provisioning-Schema/blob/master/Samples/ProvisioningSchema-2020-02-FullSample-01.xml。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:Security &lt;/span&gt;&lt;span&gt;BreakRoleInheritance&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;                    CopyRoleAssignments&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;                    ClearSubscopes&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                    AssociatedGroups&lt;/span&gt;&lt;span&gt;=&quot;Test Value&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                    AssociatedMemberGroup&lt;/span&gt;&lt;span&gt;=&quot;{parameter:AssociatedMemberGroup}&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                    AssociatedOwnerGroup&lt;/span&gt;&lt;span&gt;=&quot;{parameter:AssociatedOwnerGroup}&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                    AssociatedVisitorGroup&lt;/span&gt;&lt;span&gt;=&quot;{parameter:AssociatedVisitorGroup}&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                    RemoveExistingUniqueRoleAssignments&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;                    ResetRoleInheritance&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:AdditionalAdministrators &lt;/span&gt;&lt;span&gt;ClearExistingItems&lt;/span&gt;&lt;span&gt;=&quot;false&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:User &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;user@contoso.com&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:User &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;U_SHAREPOINT_ADMINS&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:AdditionalAdministrators&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:AdditionalOwners &lt;/span&gt;&lt;span&gt;ClearExistingItems&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:User &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;user@contoso.com&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:User &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;U_SHAREPOINT_ADMINS&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:AdditionalOwners&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:AdditionalMembers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:User &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;user@contoso.com&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:User &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;U_SHAREPOINT_ADMINS&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:AdditionalMembers&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:AdditionalVisitors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:User &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;user@contoso.com&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:User &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;U_SHAREPOINT_ADMINS&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:AdditionalVisitors&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:SiteGroups&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:SiteGroup
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;               &lt;span&gt;Title&lt;/span&gt;&lt;span&gt;=&quot;Power Users&quot;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;              Description&lt;/span&gt;&lt;span&gt;=&quot;Group of Power Users&quot;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;              Owner&lt;/span&gt;&lt;span&gt;=&quot;admin@contoso.com&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:Members &lt;/span&gt;&lt;span&gt;ClearExistingItems&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:User &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;user1@contoso.com&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:User &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;user2@contoso.com&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:User &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;user3@contoso.com&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:Members&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;           &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:SiteGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:SiteGroups&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:Permissions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:RoleDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:RoleDefinition &lt;/span&gt;&lt;span&gt;Name&lt;/span&gt;&lt;span&gt;=&quot;Manage List Items&quot;&lt;/span&gt;&lt;span&gt; Description&lt;/span&gt;&lt;span&gt;=&quot;Allows a user to manage list items&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;               &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:Permissions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:Permission&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;ViewListItems&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:Permission&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:Permission&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;AddListItems&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:Permission&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:Permission&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;EditListItems&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:Permission&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:Permission&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;DeleteListItems&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:Permission&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;               &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:Permissions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:RoleDefinition&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;           &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:RoleDefinitions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;           &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:RoleAssignments&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:RoleAssignment &lt;/span&gt;&lt;span&gt;Principal&lt;/span&gt;&lt;span&gt;=&quot;Power Users&quot;&lt;/span&gt;&lt;span&gt; RoleDefinition&lt;/span&gt;&lt;span&gt;=&quot;Manage List Items&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:RoleAssignment &lt;/span&gt;&lt;span&gt;Principal&lt;/span&gt;&lt;span&gt;=&quot;user1@contoso.com&quot;&lt;/span&gt;&lt;span&gt; RoleDefinition&lt;/span&gt;&lt;span&gt;=&quot;Manage List Items&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:RoleAssignment &lt;/span&gt;&lt;span&gt;Principal&lt;/span&gt;&lt;span&gt;=&quot;user2@contoso.com&quot;&lt;/span&gt;&lt;span&gt; RoleDefinition&lt;/span&gt;&lt;span&gt;=&quot;Full Control&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:RoleAssignment &lt;/span&gt;&lt;span&gt;Principal&lt;/span&gt;&lt;span&gt;=&quot;user3@contoso.com&quot;&lt;/span&gt;&lt;span&gt; RoleDefinition&lt;/span&gt;&lt;span&gt;=&quot;Full Control&quot;&lt;/span&gt;&lt;span&gt; Remove&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;           &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:RoleAssignments&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:Permissions&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;       &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:Security&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们从中截取&amp;lt;pnp:Security&amp;gt;部分来看看如何自定义站点权限。&lt;/p&gt;
&lt;p&gt;代码第10行到第13行，可以指定site collection的管理员。&lt;/p&gt;
&lt;p&gt;14行到17行，指定站点的管理员，要注意的是这个和site collection管理员是不一样的。&lt;/p&gt;
&lt;p&gt;18-25行，指定站点的成员和访问者。&lt;/p&gt;
&lt;p&gt;26-37行创建一个新的SharePoint Group，并且添加用户和其他组到这个新组之中。&lt;/p&gt;
&lt;p&gt;39-48行创建的新的permission level.&lt;/p&gt;
&lt;p&gt;49-54行指定权限到user或group。指定Group的时候，要使用“c:0t.c|tenant|{groupID}”作为Principal的参数，另外特别需要注意的是，Full Control，Edit，Read权限像样例填写是不能正确应用的，需要分别改成Administrator，Editor和Reader。&lt;/p&gt;
&lt;p&gt;另外可以针对列表和文档库单独设置权限。在&amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;pnp&lt;span class=&quot;pl-ent&quot;&gt;:&lt;span class=&quot;pl-ent&quot;&gt;ListInstance&amp;gt;下面，可以找到如下单独的权限设置部分。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:Security&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;                 &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:BreakRoleInheritance &lt;/span&gt;&lt;span&gt;CopyRoleAssignments&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt; ClearSubscopes&lt;/span&gt;&lt;span&gt;=&quot;true&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:RoleAssignment &lt;/span&gt;&lt;span&gt;Principal&lt;/span&gt;&lt;span&gt;=&quot;user1@contoso.com&quot;&lt;/span&gt;&lt;span&gt; RoleDefinition&lt;/span&gt;&lt;span&gt;=&quot;Full Control&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:RoleAssignment &lt;/span&gt;&lt;span&gt;Principal&lt;/span&gt;&lt;span&gt;=&quot;user2@contoso.com&quot;&lt;/span&gt;&lt;span&gt; RoleDefinition&lt;/span&gt;&lt;span&gt;=&quot;Edit&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;                   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;pnp:RoleAssignment &lt;/span&gt;&lt;span&gt;Principal&lt;/span&gt;&lt;span&gt;=&quot;user3@contoso.com&quot;&lt;/span&gt;&lt;span&gt; RoleDefinition&lt;/span&gt;&lt;span&gt;=&quot;View Only&quot;&lt;/span&gt;&lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;                 &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:BreakRoleInheritance&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;               &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;pnp:Security&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在设置好模板文件后，可以使用powershell 进行测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Apply-PnPProvisioningTemplate -&lt;span&gt;Path template.xml #部署全部模板

or

Apply&lt;/span&gt;-PnPProvisioningTemplate -Path template.xml -Handlers SiteSecurity #只部署&amp;lt;pnp:Security&amp;gt;部分
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 27 Jan 2021 20:22:00 +0000</pubDate>
<dc:creator>老王717</dc:creator>
<og:description>SharePoint Online可以使用PnP引擎部署站点模板。这个模板的功能非常强大，除了可以定制主题，外观以外，还可以生成list并导入数据，生成文档库，导入文档等等。 今天重点说一下其中的站点</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sharepointonline/p/14337826.html</dc:identifier>
</item>
<item>
<title>记一次坏道在分区边界的硬盘修复 - z0gSh1u</title>
<link>http://www.cnblogs.com/zxuuu/p/14337791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zxuuu/p/14337791.html</guid>
<description>&lt;h2 id=&quot;问题&quot;&gt;问题&lt;/h2&gt;
&lt;p&gt;一块东芝 1TB 机械硬盘，在近期日常使用中不时出现开机无法正常引导、打开分区时需大量时间等问题，最后彻底无法引导操作系统。&lt;/p&gt;
&lt;h2 id=&quot;前期尝试&quot;&gt;前期尝试&lt;/h2&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;尝试使用 PE 引导系统，基于 Win10 的 PE 卡死在“初始化”界面无法进入，基于 Win2003 的 PE 能够引导，但进入后资源管理器和 DiskGenius （下称 DG）都看不到盘&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;尝试修改 BIOS 的 SATA 控制器模式，修改为 AHCI 和 IDE 模式，均失败&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;尝试使用 PE 的不加载 SRS 驱动的兼容模式来引导，以及加载 SRS 驱动的兼容模式来引导，均失败&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用 DOS 版 DG 可以看到盘本身&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;ul readability=&quot;12&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在 DOS 版 DG 下，扫描丢失的分区，重建分区表后，结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/28/XfhmzqlVoGgte9U.png&quot; alt=&quot;image-20210128010705093&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可见，找到了三个分区。但该盘上原本有 4 个分区，布局中的 411.5GB 空闲处的分区完全丢失，无法被扫描出。记 350GB 分区尾部、411.5GB 空闲头部的柱面号为 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;先将目前扫出的三个分区文件全部借助 DG 导出到稳定的介质上，再尝试进行后续的修复。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在 DOS 版 DG 下，扫描坏道。结果发现，&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 附近（即 350GB 分区和 411.5GB 空闲的衔接边界处）存在一定数量坏道。这些坏道即是导致 PE 无法正常加载、无法正常认盘的根本原因。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;启动到 DOS 下的磁盘再生器（HDD Regenerator），选中该盘，直接使用“扫描并修复”模式，扫描全盘并修复坏道。相比起 DG 自带的坏道修复工具和 MHDD 等工具，HDDReg 有概率修复坏道处不可读取的受损信息，使用起来也更简单。&lt;/p&gt;
&lt;p&gt;运行完成后，HDDReg 顺利修复了 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 附近的 16 个坏扇。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/28/Vf4AxgEOmW7uQdB.png&quot; alt=&quot;image-20210128011651512&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;磁道和扇区密不可分，HDDReg 使用扇区一词，其他地方使用磁道一词，实际上讲的是一回事。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/28/Vo8qimt9yhQzgKd.png&quot; alt=&quot;image-20210128011536719&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;重新尝试引导到 PE，这时，基于 Win2003 的 PE 可以成功引导，并且资源管理器和 DG 都可以看到盘了。DG 中，&lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 位置以后的状态不再是“空闲”，而是变为“未格式化”状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;右击该部分，使用 DG 的“恢复被删除和格式化的文件”功能扫描这片区域（这个功能在 DOS 版 DG 下没有）。扫描结束后，原先此处的 411.5GB 分区的内容大部分都被找回了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/01/28/6wcFbRftq1TagGz.png&quot; alt=&quot;image-20210128012154754&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;位于 &lt;span class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt; 附近坏道处的数据发生了部分丢失，未能全部找回&lt;/li&gt;
&lt;li&gt;PE 卡在初始化的原因，不排除硬盘坏道导致&lt;/li&gt;
&lt;li&gt;DOS 能够对硬盘进行更底层的操作，在无法使用高级 PE 的情况下，可考虑在 DOS 下先解决部分问题&lt;/li&gt;
&lt;li&gt;坏道恰好发生在分区边界时导致的分区丢失，使用 DG 扫描全盘、重建分区表时，可能无法扫出该分区&lt;/li&gt;
&lt;li&gt;坏道恰好发生在分区边界时，特殊之处在于，操作系统无法在位于 (cylinder 0, head 0, sector 1) 的分区表所指示的位置找到有效的分区（因为那里有坏道）&lt;/li&gt;
&lt;li&gt;注意到在 HDDReg 完成修复后，原先“空闲”的 411.5GB 与最后的一小块分区发生了合并，成为“未格式化”状态。因此，为避免丢失分区的后续分区丢失，务必在完成分区表重建后，将能够找到的数据都备份稳妥后，再进行后续操作&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 27 Jan 2021 17:31:00 +0000</pubDate>
<dc:creator>z0gSh1u</dc:creator>
<og:description>问题 一块东芝 1TB 机械硬盘，在近期日常使用中不时出现开机无法正常引导、打开分区时需大量时间等问题，最后彻底无法引导操作系统。 前期尝试 尝试使用 PE 引导系统，基于 Win10 的 PE 卡死</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zxuuu/p/14337791.html</dc:identifier>
</item>
<item>
<title>图解计算机中的数值范围和浮点运算 - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/14337767.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/14337767.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;p&gt;在【程序员进阶系列】专题的《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg4MjU0OTM1OA==&amp;amp;mid=2247490388&amp;amp;idx=1&amp;amp;sn=1805a62814452c598c567e65de274c67&amp;amp;chksm=cf55ac55f8222543d1506fb48dcc22c3d5be0a458e3b11a224fd98248e11f86d17468204fcfc&amp;amp;token=1733172899&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;图解计算机中数据的表示形式&lt;/a&gt;》一文中，我们详细的说明了在计算机中数据的表示形式。今天，我们继续来说计算机中的数值范围和浮点运算相关的知识。走起，继续，我们一起进阶，一起牛逼。&lt;/p&gt;
&lt;p&gt;文章已收录到：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/sunshinelyz/technology-binghe&quot; target=&quot;_blank&quot;&gt;https://github.com/sunshinelyz/technology-binghe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/binghe001/technology-binghe&quot; target=&quot;_blank&quot;&gt;https://gitee.com/binghe001/technology-binghe&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;数值的表示范围&quot;&gt;数值的表示范围&lt;/h2&gt;
&lt;p&gt;在计算机中，码制所表示的范围，可以分为定点整数和定点小数。在定点数中，小数点是固定的。定点整数就是说小数点在最低位的后面，也就是在最右面，此时的小数点可以忽略不写。定点小数就是小数点在最高位的前面，也就是在最左边。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得注意的是：在定点整数和定点小数中，小数点都不占位数。所以，小数点在定点整数和定点小数中不会影响数值的范围。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以将定点整数和定点小数的取值范围总结成下表所示。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;码制&lt;/th&gt;
&lt;th&gt;定点整数&lt;/th&gt;
&lt;th&gt;定点小数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;原码&lt;/td&gt;
&lt;td&gt;-(2&lt;sup&gt;n-1&lt;/sup&gt; -1) ~ +(2&lt;sup&gt;n-1&lt;/sup&gt; -1)&lt;/td&gt;
&lt;td&gt;-(1-2&lt;sup&gt;-(n-1)&lt;/sup&gt;) ~ +(1-2&lt;sup&gt;-(n-1)&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;反码&lt;/td&gt;
&lt;td&gt;-(2&lt;sup&gt;n-1&lt;/sup&gt; -1) ~ +(2&lt;sup&gt;n-1&lt;/sup&gt; -1)&lt;/td&gt;
&lt;td&gt;-(1-2&lt;sup&gt;-(n-1)&lt;/sup&gt;) ~ +(1-2&lt;sup&gt;-(n-1)&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;补码&lt;/td&gt;
&lt;td&gt;-2&lt;sup&gt;n-1&lt;/sup&gt; ~ +(2&lt;sup&gt;n-1&lt;/sup&gt; -1)&lt;/td&gt;
&lt;td&gt;-1~ +(1-2&lt;sup&gt;-(n-1)&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;移码&lt;/td&gt;
&lt;td&gt;-2&lt;sup&gt;n-1&lt;/sup&gt; ~ +(2&lt;sup&gt;n-1&lt;/sup&gt; -1)&lt;/td&gt;
&lt;td&gt;-1~ +(1-2&lt;sup&gt;-(n-1)&lt;/sup&gt;)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;表格中的n表示机器的字长，也就是用多少位二进制数表示。&lt;/p&gt;
&lt;p&gt;这张表小伙伴们不用死记硬背，说白了，这张表，冰河也记不住，那我们怎么办呢？不慌，这里，我给大家举一个例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210124010846912.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，我们这里使用4位机器字长来表示，为了理解方便，这里我用四个方框来表示4位二进制数。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210124010855758.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认最高位为符号位，如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210124010903765.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们先用4位二进制数表示定点整数，则最小值为1111，最大值为0111。&lt;/p&gt;
&lt;p&gt;最小值1111表示如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021012401091398.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其转换成10进制数为-7。&lt;/p&gt;
&lt;p&gt;最大值0111表示如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210124010921884.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其转换为10进制数为7。&lt;/p&gt;
&lt;p&gt;这样，我们使用4位二进制数表示的范围，则可以计算出结果为：-7 ~ 7。也就是 -(2&lt;sup&gt;4-1&lt;/sup&gt; - 1) ~ +(2&lt;sup&gt;4-1&lt;/sup&gt; -1)，所以，当使用n位二进制数表示数值的范围时，我们可以得出数据的表示范围为： -(2&lt;sup&gt;n-1&lt;/sup&gt; - 1) ~ +(2&lt;sup&gt;n-1&lt;/sup&gt; -1)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，我们根本就不需要记住定点整数和定点小数的取值范围表，只需要简单的使用一个实际的二进制位进行验算即可得出正确的结果数据。比如，我这里以4位二进制位进行验算举例。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有一点需要注意的是：补码和移码比原码和反码少一个数，就是-0。另外，验证定点小数和验证定点整数的方式相同，小伙伴们可自行验证定点小数的值，这里，我就不再赘述。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果我们使用8位二进制数表示，则定点整数的取值范围为：&lt;/p&gt;
&lt;p&gt;1111 1111 ~ 0111 1111 转换为十进制数就是： -127 ~ 127，将二进制数转换为补码为：1000 0000 ~ 0111 1111。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中，-128的补码为1000 0000是人为规定的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果使用8位二进制数表示，则定点小数的取值范围为：&lt;/p&gt;
&lt;p&gt;-0.1111 1111 ~ +0.11111111，补码的范围为： -1~ + +0.11111111。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其中，-1的补码为1000 0000是人为规定的。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;浮点数的运算&quot;&gt;浮点数的运算&lt;/h2&gt;
&lt;h3 id=&quot;浮点数的表示&quot;&gt;浮点数的表示&lt;/h3&gt;
&lt;p&gt;首先，我们先来看下浮点数的表示形式，浮点数的表示形式如下，&lt;/p&gt;
&lt;p&gt;N = 尾数 * 基数&lt;sup&gt;指数&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;对于浮点数来说，我们最常说的就是圆周率 π，数学上常使用3.14来表示π的值，如果使用科学计算法的话，我们可以使用形如3.14 * 10&lt;sup&gt;3&lt;/sup&gt; 这样的数来表示。其中，在3.14 * 10&lt;sup&gt;3&lt;/sup&gt;中，3.14表示尾数，10表示基数，3表示指数。&lt;/p&gt;
&lt;p&gt;另外，3.14 * 10&lt;sup&gt;3&lt;/sup&gt; 可以写成多种形式，比如可以写成 0.314 * 10&lt;sup&gt;4&lt;/sup&gt;，也可以写成0.0314 * 10&lt;sup&gt;5&lt;/sup&gt;。&lt;/p&gt;
&lt;h3 id=&quot;浮点数的存储格式&quot;&gt;浮点数的存储格式&lt;/h3&gt;
&lt;p&gt;浮点数在计算机中的表示中，阶码是带符号的纯整数，尾数为带符号的纯小数。浮点数的表示格式如下所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210124010944650.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个数的浮点数表示不是唯一的。当小数点的位置发生改变时，阶码也会相应的改变。可以使用多个浮点形式表示同一个浮点数。浮点数的数值范围主要由阶码决定，数值的精度则是由尾数决定的。&lt;/p&gt;
&lt;h3 id=&quot;浮点数的运算过程&quot;&gt;浮点数的运算过程&lt;/h3&gt;
&lt;p&gt;运算的过程要依次经历对阶、尾数计算和结果格式化三个阶段。&lt;/p&gt;
&lt;p&gt;例如计算：3.14 * 10&lt;sup&gt;3&lt;/sup&gt; + 1.5 * 10&lt;sup&gt;5&lt;/sup&gt;的结果数据。&lt;/p&gt;
&lt;p&gt;首先，我们需要先进行对阶操作，这里有个原则就是小数向大树看齐，这里我们需要将3.14 * 10&lt;sup&gt;3&lt;/sup&gt;进行对阶操作，转化成0.0314 * 10&lt;sup&gt;5&lt;/sup&gt;，然后与1.5 * 10&lt;sup&gt;5&lt;/sup&gt;进行相加操作，得出结果数据1.5314 * 10&lt;sup&gt;5&lt;/sup&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210124011055734.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们再来看看浮点数的特点。&lt;/p&gt;
&lt;h3 id=&quot;浮点数的特点&quot;&gt;浮点数的特点&lt;/h3&gt;
&lt;p&gt;浮点数的主要特点如下所示。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一般尾数使用补码表示，阶码使用移码表示。&lt;/li&gt;
&lt;li&gt;阶码的位数决定数的表示范围，位数越多范围越大。&lt;/li&gt;
&lt;li&gt;尾数的位数决定数的有效精度，位数越多精度越高。&lt;/li&gt;
&lt;li&gt;对阶时，小数向大数看齐。&lt;/li&gt;
&lt;li&gt;对阶是通过较小数的尾数右移实现的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;好了，今天就到这儿吧，我是冰河，大家有啥问题可以在下方留言，也可以加我微信：sun_shine_lyz，我拉你进群，一起交流技术，一起进阶，一起牛逼~~&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 27 Jan 2021 16:58:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 在【程序员进阶系列】专题的《图解计算机中数据的表示形式》一文中，我们详细的说明了在计算机中数据的表示形式。今天，我们继续来说计算机中的数值范围和浮点运算相关的知识。走起，继续，我们一起进阶，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/14337767.html</dc:identifier>
</item>
<item>
<title>Linux 三剑客之 grep 使用详解 - 肖邦linux</title>
<link>http://www.cnblogs.com/liwei0526vip/p/14337738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liwei0526vip/p/14337738.html</guid>
<description>&lt;div class=&quot;output_wrapper&quot; id=&quot;output_wrapper_id&quot; readability=&quot;47.364310816087&quot;&gt;
&lt;p&gt;Linux 最重要的三个命令在业界被称为&lt;strong&gt;三剑客&lt;/strong&gt;，它们是：&lt;code&gt;awk&lt;/code&gt;、&lt;code&gt;sed&lt;/code&gt;、&lt;code&gt;grep&lt;/code&gt;。sed 已经在&lt;strong&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/XvTrfKfYZHnG-ZQ1O1K9lg&quot;&gt;上篇&lt;/a&gt;&lt;/strong&gt;中讲过，本文要讲的是 &lt;code&gt;grep&lt;/code&gt; 命令。&lt;/p&gt;
&lt;p&gt;我们在使用 Linux 系统中，grep 命令的使用尤为频繁，熟练掌握 grep 的常见用法，能够极大地提高你的工作效率。&lt;/p&gt;
&lt;p&gt;grep 命令是一种强大的文本搜索工具，它能使用正则表达式，按照指定的模式去匹配，并把匹配的行打印出来。需要注意的是，grep 只支持匹配而不能替换匹配的内容，替换的功能可以由 sed 来完成。&lt;/p&gt;
&lt;p&gt;整体上 grep 还是比较简单的，文中不会详细列举所有的选项和参数，会以多个具体示例来说明 grep 的使用方法和场景，帮助你快速学会 grep 的常见用法。&lt;/p&gt;
&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;示例实战&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;废话不说了，直接实战。文章中的示例 需要一个样例文件，文件内容如下：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/grep-000.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;em&gt;1.&lt;/em&gt; 把包含 syslog 的行过滤出来&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/grep-001.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;em&gt;2.&lt;/em&gt; 把以 ntp 开头的行过虑出来&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/grep-002.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;em&gt;3.&lt;/em&gt; 把匹配 ntp 的行以及下边的两行过滤出来&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/grep-003.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;em&gt;4.&lt;/em&gt; 把包含 syslog 及上边的一行过滤出来&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/grep-004.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;em&gt;5.&lt;/em&gt; 把包含 syslog 以及上、下一行内容过滤出来&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/grep-005.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;em&gt;6.&lt;/em&gt; 过滤某个关键词，并输出行号&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/grep-006.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;em&gt;7.&lt;/em&gt; 过滤&lt;strong&gt;不包含&lt;/strong&gt;某关键词，并输出行号&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/grep-007.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;em&gt;8.&lt;/em&gt; 删除掉空行&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/grep-008.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;em&gt;9.&lt;/em&gt; 过滤包含 root 或 syslog 的行&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/grep-009.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;&lt;em&gt;10.&lt;/em&gt; 查看当前目录中包含某关键词的所有文件（这个很有用）&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/grep-010.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;简单总结&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;通过了一些简单案例操作，我们应该已经熟悉了 grep 的常见用法，下边再来简单总结 grep 的常见选项，相信在实战练习后再来总结应该会有更好的学习效果。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;-A&lt;/code&gt;：除了匹配行，额外显示该行之&lt;strong&gt;后&lt;/strong&gt;的N行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-B&lt;/code&gt;：除了匹配行，额外显示该行之&lt;strong&gt;前&lt;/strong&gt;的N行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-C&lt;/code&gt;：除了匹配行，额外显示该行&lt;strong&gt;前后&lt;/strong&gt;的N行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-c&lt;/code&gt;：统计匹配的行数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-e&lt;/code&gt;：&lt;strong&gt;实现多个选项间的逻辑 or 关系&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-E&lt;/code&gt;：&lt;strong&gt;支持扩展的正则表达式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-F&lt;/code&gt;：相当于 fgrep&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-i&lt;/code&gt;：忽略大小写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;：显示匹配的行号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-o&lt;/code&gt;：仅显示匹配到的字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-q&lt;/code&gt;：安静模式，不输出任何信息，脚本中常用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-s&lt;/code&gt;：不显示错误信息&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-v&lt;/code&gt;：&lt;strong&gt;显示不被匹配到的行&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-w&lt;/code&gt;：显示整个&lt;strong&gt;单词&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;--color&lt;/code&gt;：以颜色突出显示匹配到的字符串&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与 grep 相似的工具还有 &lt;code&gt;egrep&lt;/code&gt;、&lt;code&gt;fgrep&lt;/code&gt;，实用性并不强，其功能完全可以通过 grep 的扩展参数来实现，所以就不再扩展。&lt;/p&gt;
&lt;p&gt;好了，本次分享就到这里了！谢谢大家，我是&lt;strong&gt;肖邦&lt;/strong&gt;，欢迎关注后续的精彩内容。&lt;/p&gt;
&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/chopin11/image001/bcxy-001.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 27 Jan 2021 16:36:00 +0000</pubDate>
<dc:creator>肖邦linux</dc:creator>
<og:description>Linux 最重要的三个命令在业界被称为三剑客，它们是：awk、sed、grep。sed 已经在上篇中讲过，本文要讲的是 grep 命令。 我们在使用 Linux 系统中，grep 命令的使用尤为频繁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liwei0526vip/p/14337738.html</dc:identifier>
</item>
<item>
<title>三. SpringCloud服务注册与发现 - MPolaris</title>
<link>http://www.cnblogs.com/mpolaris/p/14328293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mpolaris/p/14328293.html</guid>
<description>&lt;h4 id=&quot;1-eureka&quot;&gt;1. Eureka&lt;/h4&gt;
&lt;h5 id=&quot;11-eureka理解&quot;&gt;1.1 Eureka理解&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;什么是服务治理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Cloud封装了&lt;code&gt;Netflix&lt;/code&gt;公司开发的Eurkeka模块来实现服务治理&lt;/p&gt;
&lt;p&gt;在传统的&lt;code&gt;rpc远程调用&lt;/code&gt;框架中，管理每个服务与服务之间依赖关系比较复杂。管理比较复杂服务之间的依赖关系可以实现服务调用，负载均衡，容错等，实现服务发现与注册。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;什么是服务注册与发现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Eureka采用了CS的设计架构，&lt;code&gt;Eureka Server&lt;/code&gt;作为服务注册功能的服务器，它是服务注册中心，而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持 &lt;span&gt;&lt;strong&gt;心跳链接&lt;/strong&gt;&lt;/span&gt; 。这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。&lt;/p&gt;
&lt;p&gt;在服务注册与发现中，有一个注册中心。当服务器启动的时候会把当前自己服务器的信息（比如：服务地址、通讯地址等）以别名方式注册到注册中心中。另一方（消费者/服务提供者）以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用。RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的依赖关系（服务治理概念）。在任何RPC远程框架中，都会有一个注册中心（存放服务地址相关信息（接口地址））&lt;/p&gt;
&lt;p&gt;下图左边是Eureka系统架构，右边是Dubbo系统架构&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210125231142.png&quot; alt=&quot;image-20210125231142531&quot;/&gt;&lt;p&gt;&lt;strong&gt;Eureka包含两个组件：Eureka Server 和 Eureka Client&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;code&gt;Eureka Server&lt;/code&gt; 提供服务注册中心&lt;/p&gt;
&lt;p&gt;各个微服务节点通过配置启动后，会在EurekaServer中进行注册，这样EurekaServer中的服务注册表中将存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;Eureka Client&lt;/code&gt; 通过注册中心进行访问&lt;/p&gt;
&lt;p&gt;是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。在应用启动后将会向Eureka Server发送心跳（默认周期为30秒）。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，Eureka Server将会从服务注册表中表把这个服务节点移除（默认90秒）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;12-单机eureka构建步骤&quot;&gt;1.2 单机Eureka构建步骤&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;IDEA生成EurekaServer端服务注册中心&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;类似物业公司&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;建Module cloud-eureka-server7001&lt;/li&gt;
&lt;li&gt;pom.xml&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;!--eureka-server--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 公共模块 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.polaris&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;cloud-api-common&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- boot web actuator --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 通用配置 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;SpringBoot 1x 和 SpringBoot 2x对比&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- SpringBoot1.X对应的SpringCloud eureka，不要再用了！！！ --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-eureka&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- SpringBoot2.X对应的SpringCloud eureka --&amp;gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-server&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;yml配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 7001

eureka:
  instance:
    hostname: localhost  # eureka服务端的实例名称
  client:
    # false表示不向注册中心注册自己
    register-with-eureka: false
    # false表示自己端就是注册中心，我的职责就是维护服务实例，并不需要去检索服务
    fetch-registry: false     
    service-url:
      # 设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址
      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;主启动类&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableEurekaServer // 声明我是服务注册中心
public class EurekaMain7001 {
    public static void main(String[] args) {
        SpringApplication.run(EurekaMain.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;运行该Eureka Server主启动类，访问 localhost:7001，就会看到下面的服务注册中心，可以发现目前还没有任何服务入驻进服务注册中心中，在应用中显示：No instances available&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210125234200.png&quot; alt=&quot;image-20210125234159844&quot;/&gt;&lt;p&gt;&lt;strong&gt;EurekaClient端 服务提供者cloud-provider-payment8001修改&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pom.xml添加依赖&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 注意:与Eureka Server一样，这里SpringBoot2x不再使用spring-cloud-starter-eureka --&amp;gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;yml配置文件添加配置&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;spring:
  application:
    name: cloud-payment-service  # 入驻Eureka服务注册中心的服务名称

eureka:
  client:
    # 表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    # 是否从EurekaServer抓取已有的注册信息，默认为true。
    # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      # 单机版
      defaultZone: http://localhost:7001/eureka # 入驻的服务注册中心地址
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;主启动类添加注解&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableEurekaClient
public class PaymentMain {
    public static void main(String[] args) {
        SpringApplication.run(PaymentMain.class,args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;注意先要启动EurekaServer，因为有了服务注册中心具体的服务提供者才能后向其中注册自己的服务&lt;/p&gt;
&lt;p&gt;可以发现注册到服务注册中心的服务名（图中蓝框）即为我们在yml配置文件中设置的服务名，下面页面中出现的 红字 是Eureka的 &lt;span&gt;自我保护机制&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210125235021.png&quot; alt=&quot;image-20210125235021654&quot;/&gt;&lt;p&gt;&lt;strong&gt;EurekaClient端 服务消费者cloud-sonsumer-order80修改&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;与服务提供者cloud-provider-payment8001修改差不多，不再赘述&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;spring:
  application:
    name: cloud-order-service # 入驻Eureka服务注册中心的服务名称
eureka:
  client:
    # 表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    # 是否从EurekaServer抓取已有的注册信息，默认为true。
    # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      # 单机
      defaultZone: http://localhost:7001/eureka
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时再回看最开始的Eureka系统架构，在服务注册中心和服务提供者没有集群的情况下，7001端口的微服务就对应了服务注册中心，而该服务不需要向服务注册中心注册自己，8001端口的微服务作为服务提供方入住到服务注册中心，8002端口的微服务作为服务消费方也同样注册到服务注册中心&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126000301.png&quot; alt=&quot;image-20210126000301308&quot;/&gt;&lt;h5 id=&quot;13-集群eureka构建步骤&quot;&gt;1.3 集群Eureka构建步骤&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;集群Eureka原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务注册中心Eureka Server中分为 &lt;code&gt;服务注册&lt;/code&gt; 和 &lt;code&gt;服务发现&lt;/code&gt;，服务注册过程将服务信息注册进服务注册中心，服务发现过程从服务注册中心上获取服务信息，而这个过程的实质就是：&lt;span&gt;将服务名作为key存储，然后根据value取得服务的调用地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;整个Eureka的过程如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;先启动Eureka注册中心&lt;/li&gt;
&lt;li&gt;启动服务提供者服务&lt;/li&gt;
&lt;li&gt;服务提供者服务将自身信息（比如服务地址）以别名方式注册到Eureka注册中心&lt;/li&gt;
&lt;li&gt;消费者服务在需要调用接口时，使用服务别名到注册中心获取实际的RPC远程调用地址&lt;/li&gt;
&lt;li&gt;消费者获得调用地址后，底层实际是利用 &lt;span&gt;HttpClient&lt;/span&gt; 技术实现远程调用&lt;/li&gt;
&lt;li&gt;消费者获得服务地址后会缓存字本地JVM内存中，默认每间隔30秒更新一次服务调用地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么微服务RPC远程服务调用最核心的是什么呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;高可用！&lt;/span&gt;如果注册中心只有一个，而这个注册中心出现了故障那么整个微服务就直接GG了，整个微服务环境就不可用了，所以应该搭建Eureka注册中心集群， 实现 &lt;span&gt;负载均衡 + 故障容错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那怎么实现Eureka注册中心的集群呢？用一句话总结就是 - &lt;span&gt;互相注册，相互守望&lt;/span&gt;。如下图所示，服务注册中心实现相互注册让彼此都知道对方的存在，也就是注册中心集群中的每一个注册中心都知道整个集群中的其他注册中心，比如如果有三个注册服务中心7001，7002，7003，那么就将7002和7003注册给7001, 将7002和7001注册给7003, 将7003和7001注册给7002， 以此类推，而这些个注册服务中心 &lt;span&gt;作为一个整体对外看做一个注册服务中心。&lt;/span&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126001813.png&quot; alt=&quot;image-20210126001813038&quot;/&gt;&lt;p&gt;&lt;strong&gt;Eureaka集群环境构建&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;参考cloud-eureka-server7001新建一个服务注册中心cloud-eureka-server7002&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;修改pom.xml&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;copy复制cloud-eureka-server7001的POM文件即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;修改映射配置（域名映射），用不同的端口号来映射同一个地址&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;找到C:\Windows\System32\drivers\etc路径下的hosts文件，将其内容修改成如下内容：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# learn-spring-cloud
127.0.0.1 eureka7001.com
127.0.0.1 eureka7002.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;yml配置文件，7001与7002都修改一下（以前是单机）&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;以前是单机版配置，而现在已经有两个注册中心可以看做两台机器，显然 hostname 不能再叫localhost&lt;/p&gt;
&lt;p&gt;更改了服务端的实例名称后，最重要的是在defaultZone中将自己注册给其他注册中心&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 7001

eureka:
  instance:
    hostname: eureka7001.com  # eureka服务端的实例名称
  client:
    register-with-eureka: false
    fetch-registry: true
    service-url:
      # 互相注册，相互守望
      defaultZone: http://eureka7002.com:7002/eureka/
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 7002

eureka:
  instance:
    hostname: eureka7002.com
  client:
    register-with-eureka: false
    fetch-registry: true
    service-url:
      # 互相注册，相互守望
      defaultZone: http://eureka7001.com:7001/eureka/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;两个服务中心已经完成了互相注册。主页面DS Replicas下面的信息就表示是这个Eureka Server相邻节点且这些节点加上自己互为一个集群。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;将服务提供者8001和服务消费者80发布到2台Eureka集群配置中&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;修改其配置文件即可，就是将自己的微服务注册到每一个服务注册中心里去，见配置文件中的defaultZone。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;eureka:
  client:
    # 表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    # 是否从EurekaServer抓取已有的注册信息，默认为true。
    # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      # 集群版
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka 
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126005559.png&quot; alt=&quot;image-20210126005558365&quot;/&gt;&lt;p&gt;&lt;strong&gt;服务提供者集群环境构建&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;8002和8001的POM文件一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;yml配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;将端口改为8002，其他和8001相同，两个微服务 &lt;span&gt;对外暴露的服务名相同均为cloud-payment-service 从而构成集群。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 8002

spring:
  application:
    name: cloud-payment-service
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型
    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包
    url: jdbc:mysql://mpolaris.top:3306/cloud-test?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false
    username: root
    password: 123456

eureka:
  client:
    # 表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    # 是否从EurekaServer抓取已有的注册信息，默认为true。
    # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      # 集群版
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka

mybatis:
  mapperLocations: classpath:mapper/*.xml
  type-aliases-package: com.polaris.springcloud.entities    # 所有Entity别名类所在包
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;主启动类与业务类与8001基本一致&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;主启动类名字分别为PaymentMain8001与PaymentMain8002&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;controller&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;修改controller，添加端口号以区分这两个具体的微服务：读取配置文件中设置的端口号。8002的修改同8001。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@Slf4j
@RequestMapping(&quot;/payment&quot;)
public class PaymentController {
    @Resource
    private PaymentService paymentService;

    @Value(&quot;${server.port}&quot;)
    private String serverPort;

    @PostMapping(&quot;/save&quot;)
    public CommonResult save(@RequestBody Payment payment) {
        int result = paymentService.save(payment);
        log.info(&quot;===&amp;gt; result: &quot; + result);
        if(result &amp;gt; 0) {
            return new CommonResult(200,
                    &quot;保存到数据库成功,端口号：&quot; + serverPort,result);
        }
        return new CommonResult(400,&quot;保存到数据库失败&quot;,null);
    }

    @GetMapping(&quot;/get/{id}&quot;)
    public CommonResult&amp;lt;Payment&amp;gt; save(@PathVariable(&quot;id&quot;) Long id) {
        Payment paymentById = paymentService.getPaymentById(id);
        log.info(&quot;===&amp;gt; payment: &quot; + paymentById);
        if(paymentById != null) {
            return new CommonResult(200,
                    &quot;查询成功,端口号：&quot; + serverPort,paymentById);
        }
        return new CommonResult(400,&quot;查询失败&quot;,null);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如图可以看到此时服务注册中心构成集群，而相同名字的服务提供方的实际提供者已经出现了两个，分别是8001和8002，也就是说服务提供方微服务也实现了集群。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126013059.png&quot; alt=&quot;image-20210126013058983&quot;/&gt;&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发现问题：通过服务消费者80访问，只能访问到服务提供者8001&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126013402.png&quot; alt=&quot;image-20210126013401986&quot;/&gt;&lt;ul&gt;&lt;li&gt;也就是说每次访问的具体微服务都是8001端口的CLOUD-PAYMENT-SERVICE服务，这明显是不符合业务逻辑的，原因就是在消费方代码中我们将服务访问地址写死了，没有实现负载均衡，这显然是不对的，所以我们应该让80访问服务名而不是具体的服务，即应该将其改为服务提供者 &lt;span&gt;微服务名称！&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126014041.png&quot; alt=&quot;image-20210126014041933&quot;/&gt;&lt;ul&gt;&lt;li&gt;同时在配置文件中通过 &lt;code&gt;@LoadBalanced&lt;/code&gt; 注解赋予RestTemplate负载均衡能力，该负载均衡默认为轮询方式。所以将80服务的配置文件修改如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class ApplicationContextConfig {
    @Bean
    @LoadBalanced //使用该注解赋予RestTemplate负载均衡的能力
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后重启80端口，发现每次访问 &lt;code&gt;CLOUD-PAYMENT-SERVICE&lt;/code&gt; 服务时，具体的微服务在8001和8002之间进行轮询切换。&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126015506.gif&quot; alt=&quot;Video_2021-01-26_015202&quot;/&gt;&lt;ul&gt;&lt;li&gt;当然此时负载均衡我们还没有用到&lt;code&gt;Ribbon&lt;/code&gt;，在Ribbon和Eureka整合后，消费者可以直接调用服务而不用再关心地址和端口号，且该服务还有负载功能。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126020536.png&quot; alt=&quot;image-20210126020536213&quot;/&gt;&lt;h5 id=&quot;14-actuator微服务信息完善&quot;&gt;1.4 actuator微服务信息完善&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;主机名称：服务名称修改&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发现问题：在注册中心显示的微服务中，我们发现服务名含有主机名称，这显然不是我们希望看到的&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126225633.png&quot; alt=&quot;image-20210126225633299&quot;/&gt;&lt;p&gt;怎么能解决这个问题呢，只需要修改服务提供方（8001和8002）的配置文件，向其中的eureka部分加入&lt;code&gt;instance实例&lt;/code&gt;即可配置该服务显示的服务名称&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;instance:
  instance-id: payment8001
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终的整体配置文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 8001

spring:
  application:
    name: cloud-payment-service
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource            # 当前数据源操作类型
    driver-class-name: org.gjt.mm.mysql.Driver              # mysql驱动包
    url: jdbc:mysql://mpolaris.top:3306/cloud-test?useUnicode=true&amp;amp;characterEncoding=utf-8&amp;amp;useSSL=false
    username: root
    password: 1234321

eureka:
  client:
    # 表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    # 是否从EurekaServer抓取已有的注册信息，默认为true。
    # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      # 集群版
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
      # 单机版
      # defaultZone: http://localhost:7001/eureka
  instance:
    instance-id: payment8001

mybatis:
  mapperLocations: classpath:mapper/*.xml
  type-aliases-package: com.polaris.springcloud.entities
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8002服务的修改同上，此时再访问注册中心，看到的服务具体名称中就没有主机名了，而是我们配置好的服务名称：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126225535.png&quot; alt=&quot;image-20210126225527532&quot;/&gt;&lt;p&gt;&lt;strong&gt;访问信息有IP信息提示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发现问题：我们在鼠标移动到具体服务时，提示的地址信息中并没有服务所在具体主机的IP地址，这在开发中不方便定位具体微服务。&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126225852.png&quot; alt=&quot;image-20210126225852166&quot;/&gt;&lt;p&gt;解决方式仍然是通过配置文件，在配置文件中向其中的eureka部分加入&lt;code&gt;优先ip地址&lt;/code&gt;即可配置该服务访问路径可以显示IP地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;instance:
  prefer-ip-address: true  # 访问路径可以显示IP地址
&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126230236.png&quot; alt=&quot;image-20210126230236440&quot;/&gt;&lt;p&gt;最终的配置文件如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;eureka:
  client:
    # 表示是否将自己注册进EurekaServer默认为true。
    register-with-eureka: true
    # 是否从EurekaServer抓取已有的注册信息，默认为true。
    # 单节点无所谓，集群必须设置为true才能配合ribbon使用负载均衡
    fetchRegistry: true
    service-url:
      # 集群版
      defaultZone: http://eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka
  instance:
    instance-id: payment8001
    prefer-ip-address: true #访问路径可以显示IP地址
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;15-服务发现discovery&quot;&gt;1.5 服务发现Discovery&lt;/h5&gt;
&lt;p&gt;对于注册进Eureka服务注册中心的微服务，可以&lt;code&gt;通过服务发现来获取该服务的信息&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;修改微服务的Controller&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;向其中注入DiscoveryClient，并编写相应Controller方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;DiscoveryClient对象中的 &lt;code&gt;getServices&lt;/code&gt; 方法用于获取服务列表的信息，也就是有哪些服务，如cloud-payment-service服务， &lt;code&gt;getInstances&lt;/code&gt; 方法用于获取服务列表对应的具体服务实例，如cloud-payment-service服务对应的8001和8002服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import org.springframework.cloud.client.discovery.DiscoveryClient;
//...
@RestController
@Slf4j
@RequestMapping(&quot;/payment&quot;)
public class PaymentController {
        //...

    @Resource
    private DiscoveryClient discoveryClient;

    @GetMapping(&quot;/discovery&quot;)
    public Object discovery() {
        //获取服务列表的信息
        List&amp;lt;String&amp;gt; services = discoveryClient.getServices();
        for (String service : services) {
            log.info(&quot;===&amp;gt; service:&quot; + service);
        }

        //根据微服务名称获取具体服务实例
        List&amp;lt;ServiceInstance&amp;gt; instances = discoveryClient.getInstances(&quot;CLOUD-PAYMENT-SERVICE&quot;);
        for (ServiceInstance instance : instances) {
            log.info(&quot;===&amp;gt; &quot; + instance.getServiceId()
                    + &quot;\t&quot; + instance.getHost()
                    + &quot;\t&quot; + instance.getPort()
                    + &quot;\t&quot; + instance.getUri());
        }
        return this.discoveryClient;
    }
        //...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;修改主启动类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只需要在主启动类上添加注解&lt;code&gt;@EnableDiscoveryClient&lt;/code&gt;，修改后的主启动类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableEurekaClient
@EnableDiscoveryClient
public class PaymentMain8001 {
    public static void main(String[] args) {
        SpringApplication.run(PaymentMain8001.class,args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;br/&gt;访问地址http://localhost:8001/payment/discovery，我们可以看到获取的服务信息，即完成了服务发现：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126234422.png&quot; alt=&quot;image-20210126234422613&quot;/&gt;&lt;p&gt;后台也对服务列表进行了日志打印：&lt;/p&gt;
&lt;p&gt;&amp;lt;img src=&quot;&lt;a href=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126234348.png&quot; target=&quot;_blank&quot;&gt;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126234348.png&lt;/a&gt;&quot; alt=&quot;image-20210126234348515&quot; &lt;a href=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126234854.png&quot; target=&quot;_blank&quot;&gt;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126234854.png&lt;/a&gt; /&amp;gt;&lt;/p&gt;
&lt;h5 id=&quot;16-eureka自我保护（属于cap里面的ap分支）&quot;&gt;1.6 Eureka自我保护（属于CAP里面的AP分支）&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;自我保护机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;保护模式主要用于一组客户端和EurekaServer之间存在网络分区场景下的保护。一旦进入保护模式，Eureka Server将会尝试保护其服务注册表中的信息，不再删除服务注册表中的数据，也就是不会注销任何微服务。换句话说就是，某时刻某一个微服务不可用了，Eureka不会立刻清理，而是依旧会对该微服务的信息进行保存。&lt;/p&gt;
&lt;p&gt;如果在Eureka Server的首页看到以下提示，说明Eureka进入了保护模式&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210126234854.png&quot; alt=&quot;image-20210126234854836&quot;/&gt;&lt;p&gt;&lt;strong&gt;产生原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为什么会产生Eureka自我保护机制？ =&amp;gt; 为了防止 &lt;span&gt;EurekaClient可以正常运行，但是与EurekaServer网络不通情况下，EurekaServer不会立刻将EurekaClient服务剔除。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;什么是自我保护模式？ =&amp;gt; 默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该实例（默认90秒）。但是当网络分区故障发生（延时、卡顿、拥挤）时，微服务与EurekaServer之前无法正常通信，以上行为可能变得非常危险 - &lt;strong&gt;因为微服务本身是健康的，只是由于网络问题链接不到EurekaServer，此时本不应该注销这个微服务&lt;/strong&gt;。Eureka通过“自我保护模式”来解决这个问题 ：当EurekaServer节点在短时间内丢失过多客户端时（可能发生了网络分区故障，网络延时），那么这个节点就会进入自我保护模式。在自我保护模式中，EurekaServer会保护服务注册表中的信息，不再注销任何服务实例，宁可保留错误的服务注册信息，也不盲目注销任何可能健康的服务实例。使用自我保护模式，可以让Eureka集群更加的健壮、稳定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;怎么禁止自我保护&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先在EurekaServer端修改配置文件即可设置关闭自我保护机制&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;eureka：
  server:
    # 关闭自我保护机制，保证不可用服务被及时剔除。默认为true开启
    enable-self-preservation: false
    # 时间间隔，单位ms
    eviction-interval-time-in-ms: 2000 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在EurekaClient端修改配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;eureka:
  instance:
    instance-id: payment8001
    # Eureka客户单向服务端发送心跳的时间间隔，默然是30秒，这里改成1秒
    lease-renewal-interval-in-seconds: 1
    # Eureka服务端在收到最后一次心跳后等待时间上限，默然为90秒，超时将剔除服务，这里改成2秒
    lease-expiration-duration-in-seconds: 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就会使EurekaClient客户端的微服务很快死亡。&lt;/p&gt;
&lt;h4 id=&quot;2-zookeeper&quot;&gt;2. Zookeeper&lt;/h4&gt;
&lt;h5 id=&quot;21-eureka停止更新&quot;&gt;2.1 Eureka停止更新&lt;/h5&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Netflix/eureka/wiki&quot; target=&quot;_blank&quot;&gt;https://github.com/Netflix/eureka/wiki&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们可以使用SpringCloud整合Zookeeper替代Eureka&lt;/p&gt;
&lt;h5 id=&quot;22-zookeeper理解&quot;&gt;2.2 Zookeeper理解&lt;/h5&gt;
&lt;p&gt;Zookeeper是一个分布式协调工具，可以实现注册中心功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装Zookeeper&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 关闭Linux服务器防火墙（关闭默认端口2181也行）
# 2181  对Client端提供服务的端口
# 3888  选举Leader
# 2888  集群内的机器通讯使用。（Leader使用此端口）
systemctl stop firewalld
systemctl status firewalld

# 我这里使用的是zookeeper-3.4.11.tar.gz，解压即可

# bin目录下启动zookeeper服务器
./zkServer.sh start
 
# 连接zookeeper客户端
# 如果是连接同一台主机上的zk进程，那么直接运行bin/目录下的kCli.sh，即可连接上zk。
# 直接执行zkCli.sh命令默认以主机号 127.0.0.1，端口号 2181 来连接zk
# 如果要连接不同机器上的zk，可以使用 -server 参数，例如：
./zkCli.sh -server 192.168.0.1:2181
 
# 启动报错？
# grep: /usr/local/zookeeper-3.4.11/bin/../conf/zoo.cfg: No such file or directory
# 这里的原因是因为下载下来的zoo.cfg名字是zoo_sample.cfg,只需要改名字即可
mv zoo_sample.cfg zoo.cfg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Zookeeper服务器取代Eureka服务器，zk作为服务注册中心&lt;/p&gt;
&lt;h5 id=&quot;23-服务提供者&quot;&gt;2.3 服务提供者&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;新建cloud-provider-payment8004&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pom.xml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependencies&amp;gt;
        &amp;lt;!-- 公共模块 --&amp;gt;
        &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.polaris&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;cloud-api-common&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;!-- boot web actuator --&amp;gt;
        &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    
        &amp;lt;!--SpringBoot整合Zookeeper客户端--&amp;gt;
        &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-cloud-starter-zookeeper-discovery&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
    
        &amp;lt;!-- 通用配置 --&amp;gt;
        &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
                &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
                &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
                &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
                &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;yml配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:  
  # 8004表示注册到zookeeper服务器的支付服务提供者端口号
  port: 8004
spring:
  application:
    # 服务别名 - 注册zookeeper到注册中心的名称
    name: cloud-provider-payment
  cloud:
    zookeeper:
      # zookeeper访问地址
      connect-string: mpolaris.top:2181
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;主启动类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
//该注解用于向使用consul或zookeeper作为注册中心时注册服务
@EnableDiscoveryClient
public class PaymentMain8004 {
    public static void main(String[] args) {
        SpringApplication.run(PaymentMain8004.class,args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;controller&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@Slf4j
@RequestMapping(&quot;/payment&quot;)
public class PaymentController {
    @Value(&quot;${server.port}&quot;)
    private String serverPort;

    @RequestMapping(value = &quot;/zk&quot;)
    public String paymentZk() {
        return &quot;===&amp;gt; SpringCloud with zookeeper:&quot; 
                + serverPort 
                + &quot;\t&quot; 
                + UUID.randomUUID().toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启动8004注册进zookeeper&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动zk： zkServer.sh start&lt;/li&gt;
&lt;li&gt;启动8004后报错&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210127012233.png&quot; alt=&quot;image-20210127012232353&quot;/&gt;&lt;ul&gt;&lt;li&gt;
&lt;p&gt;why？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解决zookeeper版本jar包冲突问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210127012945.png&quot; alt=&quot;image-20210127012945364&quot;/&gt;&lt;ul&gt;&lt;li&gt;排除zk冲突后的新pom.xml&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--SpringBoot整合Zookeeper客户端--&amp;gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-zookeeper-discovery&amp;lt;/artifactId&amp;gt;
        &amp;lt;!-- 先排除自带的zookeeper3.5.3 --&amp;gt;
        &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                        &amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt;
                        &amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
        &amp;lt;/exclusions&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;!-- 添加zookeeper3.4.11版本zookeeper --&amp;gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.4.11&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;验证测试1&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210127013617.png&quot; alt=&quot;image-20210127013617048&quot;/&gt;&lt;p&gt;访问 &lt;a href=&quot;http://localhost:8004/payment/zk&quot; target=&quot;_blank&quot;&gt;http://localhost:8004/payment/zk&lt;/a&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210127014618.png&quot; alt=&quot;image-20210127014618342&quot;/&gt;&lt;p&gt;&lt;strong&gt;验证测试2&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210127014115.png&quot; alt=&quot;image-20210127014115054&quot;/&gt;&lt;p&gt;获得json串后用在线工具查看如下&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210127014501.png&quot; alt=&quot;image-20210127014501415&quot;/&gt;&lt;p&gt;&lt;strong&gt;思考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;服务节点是临时节点还是持久节点？ =&amp;gt; 临时节点&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210127015507.png&quot; alt=&quot;image-20210127015507188&quot;/&gt;&lt;h5 id=&quot;24-服务消费者&quot;&gt;2.4 服务消费者&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;新建cloud-consumerzk-order80&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pom.xml&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependencies&amp;gt;
    &amp;lt;!-- 公共模块 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;com.polaris&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;cloud-api-common&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;${project.version}&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- web --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--SpringBoot整合Zookeeper客户端--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-zookeeper-discovery&amp;lt;/artifactId&amp;gt;
        &amp;lt;exclusions&amp;gt;
            &amp;lt;!--先排除自带的zookeeper3.5.3--&amp;gt;
            &amp;lt;exclusion&amp;gt;
                &amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt;
            &amp;lt;/exclusion&amp;gt;
        &amp;lt;/exclusions&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!--添加zookeeper3.4.11版本--&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.zookeeper&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;zookeeper&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;3.4.11&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;!-- 通用配置 --&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-devtools&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
        &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;
        &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;/dependencies&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;yml配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 80
spring:
  application:
    # 服务别名
    name: cloud-consumer-order
  cloud:
    zookeeper:
      # 注册到zookeeper地址
      connect-string: mpolaris.top:2181
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;主启动类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableDiscoveryClient
public class OrderZkMain80 {
    public static void main(String[] args) {
        SpringApplication.run(OrderZkMain80.class, args);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;业务类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置类注入RestTemplate&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class ApplicationContextConfig {
    @Bean
    @LoadBalanced
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;controller&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@Slf4j
@RequestMapping(&quot;/consumer&quot;)
public class OrderZkController {

    public static final String INVOKE_URL = &quot;http://cloud-provider-payment&quot;;
    @Resource
    private RestTemplate restTemplate;


    /**
     * http://localhost/consumer/payment/zk
     * @return
     */
    @GetMapping(&quot;/payment/zk&quot;)
    public String paymentInfo() {
        return restTemplate.getForObject(INVOKE_URL 
                                         + &quot;/payment/zk&quot;, String.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试验证&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.3265306122449&quot;&gt;
&lt;p&gt;访问地址 &lt;a href=&quot;http://localhost/consumer/payment/zk&quot; target=&quot;_blank&quot;&gt;http://localhost/consumer/payment/zk&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;3-consul&quot;&gt;3. Consul&lt;/h4&gt;
&lt;h5 id=&quot;31-理解&quot;&gt;3.1 理解&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;什么是Consul&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Consul是一套开源的&lt;code&gt;分布式服务发现&lt;/code&gt;和&lt;code&gt;配置管理&lt;/code&gt;系统，由HashiCorp公司用&lt;code&gt;Go语言&lt;/code&gt;开发。提供了微服务系统中的 &lt;code&gt;服务治理&lt;/code&gt; 、&lt;code&gt;配置中心&lt;/code&gt; 、&lt;code&gt;控制总线&lt;/code&gt; 等功能。这些功能中的每一个都可以根据单独需要使用，也可以一起使用以构建全方位的服务网络，总之Consul提供了一种完整的服务网络解决方案。其官方介绍见&lt;a href=&quot;https://www.consul.io/intro&quot; target=&quot;_blank&quot;&gt;Consul官网&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;它具有很多优点。包括&lt;code&gt;基于raft协议&lt;/code&gt;，比较简洁；支持&lt;code&gt;健康检查&lt;/code&gt;，同时支持&lt;code&gt;HTTP&lt;/code&gt;和&lt;code&gt;DNS&lt;/code&gt;协议，支持跨数据中心的&lt;code&gt;WAN集群&lt;/code&gt;，提供图形界面，跨平台，支持Linux/Mac/Windows。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Consul作用&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;服务发现Service Discovery&lt;/code&gt;：提供HTTP和DNS两种发现方式。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;健康监测Health Checking&lt;/code&gt;：支持多张方式，HTTP、TCP、Docker、Shell脚本定制化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KV存储&lt;/code&gt;：Key、Value的存储方式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;多数据中心&lt;/code&gt;：Consul支持多数据中心&lt;/li&gt;
&lt;li&gt;&lt;code&gt;可视化Web界面&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;32-安装并运行consul&quot;&gt;3.2 安装并运行Consul&lt;/h5&gt;
&lt;p&gt;在&lt;a href=&quot;https://www.consul.io/downloads&quot; target=&quot;_blank&quot;&gt;官网下载&lt;/a&gt;Windows的64位版本Consul后下载的是zip压缩包，将压缩包解压后里面只有一个&lt;code&gt;consul.exe&lt;/code&gt;文件。在该路径下双击其exe文件就可以运行Consul，进入cmd命令行运行，输入以下命令查看Consul的版本号信息，我用的是1.7.3版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;consul --version
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然也可以不用有点low的双击Consul启动，可以在命令行中用开发模式启动，输入以下命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;consul agent -dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动后我们访问 localhost:8500 ，就可以看到Consul和Eureka一样，有一个前端可视化Web界面。这样的话Consul服务注册中心就已经启动了，且运行在8500端口&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210127234115.png&quot; alt=&quot;image-20210127234107809&quot;/&gt;&lt;h5 id=&quot;33-服务提供者&quot;&gt;3.3 服务提供者&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;新建cloud-provider-consul-payment8006&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pom.xml&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在Eureka的服务提供方中我们引入了如下的依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--eureka-client--&amp;gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-netflix-eureka-client&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而我们现在服务注册中心用的不再是Eureka而是Consul，只需要被Eureka Client的依赖更改为如下依赖，这样引入了让Consul服务注册中心发现自己微服务的相关jar包。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--SpringCloud consul-server --&amp;gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-consul-discovery&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;yml配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;server:
  port: 8006  # consul服务端口号

spring:
  application:
    name: consul-provider-payment
  # consul注册中心地址
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        #hostname: 127.0.0.1
        service-name: ${spring.application.name}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;主启动类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableDiscoveryClient
public class PaymentMain8006 {
    public static void main(String[] args) {
        SpringApplication.run(PaymentMain8006.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;业务类Controller&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@Slf4j
@RequestMapping(&quot;/payment&quot;)
public class PaymentController {

    @Value(&quot;${server.port}&quot;)
    private String serverPort;

    @RequestMapping(&quot;/consul&quot;)
    public String paymentConsul() {
        return &quot;springcloud with consul: &quot; 
            + serverPort 
            + &quot;\t&quot; 
            + UUID.randomUUID().toString();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;经过以上配置，我们会在Consul服务注册中心中发现入驻的 consul-provider-payment 服务&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210127235144.png&quot; alt=&quot;image-20210127235144150&quot;/&gt;&lt;h5 id=&quot;34-服务消费者&quot;&gt;3.4 服务消费者&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;新建cloud-consumer-consul-order80&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;pom.xml&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了可以将自己注册到Consul服务注册中心，和服务提供方一样，仍然是引入如下依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--SpringCloud consul-server --&amp;gt;
&amp;lt;dependency&amp;gt;
        &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;spring-cloud-starter-consul-discovery&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;yml配置文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;和服务提供方几乎完全相同，只需要修改下自己的端口号和自己的服务名称&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;# consul服务端口号
server:
  port: 80

spring:
  application:
    name: cloud-consumer-order
  # consul注册中心地址
  cloud:
    consul:
      host: localhost
      port: 8500
      discovery:
        # hostname: 127.0.0.1
        service-name: ${spring.application.name}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;主启动类&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@SpringBootApplication
@EnableDiscoveryClient //用于向使用Consul或Zookeeper作为注册中心时注册服务
public class OrderConsulMain80 {
    public static void main(String[] args) {
        SpringApplication.run(OrderConsulMain80.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;配置类注入RestTemplate&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Configuration
public class ApplicationContextConfig {
    @Bean
    @LoadBalanced  //使用该注解赋予RestTemplate负载均衡的能力
    public RestTemplate getRestTemplate() {
        return new RestTemplate();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;业务类Controller&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
@Slf4j
public class OrderConsulController {

    //要访问的服务提供方的微服务名称
    public static final String INVOKE_URL = &quot;http://consul-provider-payment&quot;;

    @Resource
    private RestTemplate restTemplate;

    @GetMapping(&quot;/consumer/payment/consul&quot;)
    public String paymentInfo() {
         return restTemplate.getForObject(INVOKE_URL
                + &quot;/payment/consul&quot;, String.class);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将服务消费方微服务启动后，在Consul服务注册中心我们可以发现同时有了提供者和消费者&lt;/p&gt;
&lt;p&gt;服务提供方自测是没有问题的，下面我们通过服务消费方来访问提供方服务，发现也可以正常访问&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210127235933.png&quot; alt=&quot;image-20210127235933366&quot;/&gt;&lt;h4 id=&quot;4-三者异同&quot;&gt;4. 三者异同&lt;/h4&gt;
&lt;h5 id=&quot;41-比较&quot;&gt;4.1 比较&lt;/h5&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;组件名&lt;/th&gt;
&lt;th&gt;编写语言&lt;/th&gt;
&lt;th&gt;CAP&lt;/th&gt;
&lt;th&gt;服务健康检查&lt;/th&gt;
&lt;th&gt;对外暴露接口&lt;/th&gt;
&lt;th&gt;SpringCloud集成&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Eureka&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;AP&lt;/td&gt;
&lt;td&gt;可配支持&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Consul&lt;/td&gt;
&lt;td&gt;Go&lt;/td&gt;
&lt;td&gt;CP&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;HTTP/DNS&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Zookeeper&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;CP&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;客户端&lt;/td&gt;
&lt;td&gt;已集成&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;42-什么是cap&quot;&gt;4.2 什么是CAP&lt;/h5&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;CAP理论：首先我们要知道CAP对应的都是什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;C&lt;/th&gt;
&lt;th&gt;A&lt;/th&gt;
&lt;th&gt;P&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Consistency&lt;/td&gt;
&lt;td&gt;Available&lt;/td&gt;
&lt;td&gt;Partition tolerance&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;强一致性&lt;/td&gt;
&lt;td&gt;可用性&lt;/td&gt;
&lt;td&gt;分区容错性&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所谓&lt;strong&gt;CAP原则&lt;/strong&gt;又称CAP定理，指的是在一个分布式系统中，一致性、可用性、分区容错性。CAP 原则指的是这三个要素 &lt;span&gt;最多只能同时实现两点，不可能三者兼顾。&lt;/span&gt;在分布式架构中，P永远要求被保证，所以当前的分布式架构只有AP和CP两种。因此根据CAP原理将NoSQL数据库分成了满足CA原则、满足CP原则和满足AP原则三大类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;CA&lt;/code&gt;：单点集群，满足一致性、可用性的系统，通长在可扩展性上不太强大。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CP&lt;/code&gt;：满足一致性、分许容错性的系统，通常性能不是特别高。&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210128000949.png&quot; alt=&quot;image-20210128000949795&quot;/&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;AP&lt;/code&gt;：满足可用性、分区容错性的系统，通常可能对一致性要求低一些。&lt;/li&gt;
&lt;/ul&gt;&lt;img src=&quot;https://gitee.com/mp2333/blog-img/raw/master/SpringCloud/20210128001046.png&quot; alt=&quot;image-20210128001046046&quot;/&gt;</description>
<pubDate>Wed, 27 Jan 2021 16:20:00 +0000</pubDate>
<dc:creator>MPolaris</dc:creator>
<og:description>1. Eureka 1.1 Eureka理解 什么是服务治理 Spring Cloud封装了Netflix公司开发的Eurkeka模块来实现服务治理 在传统的rpc远程调用框架中，管理每个服务与服务之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mpolaris/p/14328293.html</dc:identifier>
</item>
<item>
<title>Python Tornado系列(甩锅版) - 云崖先生</title>
<link>http://www.cnblogs.com/Yunya-Cnblogs/p/14337673.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yunya-Cnblogs/p/14337673.html</guid>
<description>&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;是&lt;code&gt;Python&lt;/code&gt;界中非常出名的一款&lt;code&gt;Web&lt;/code&gt;框架，和&lt;code&gt;Flask&lt;/code&gt;一样它也属于轻量级的&lt;code&gt;Web&lt;/code&gt;框架。&lt;/p&gt;
&lt;p&gt;　　 但是从性能而言&lt;code&gt;tornado&lt;/code&gt;由于其支持异步非阻塞的特性所以对于一些高并发的场景显得更为适用。&lt;/p&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;简洁，高效，能够支持&lt;code&gt;WebSocket&lt;/code&gt;，其&lt;code&gt;I/O&lt;/code&gt;多路复用采用&lt;code&gt;epoll&lt;/code&gt;模式来实现异步，并且还有&lt;code&gt;Future&lt;/code&gt;期程对象来实现非阻塞。&lt;/p&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;与&lt;code&gt;Django&lt;/code&gt;和&lt;code&gt;Flask&lt;/code&gt;等基于&lt;code&gt;WSGI&lt;/code&gt;的框架有一个根本的区别，就是它实现&lt;code&gt;socket&lt;/code&gt;的模块是自己写的，并不是用其他模块。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt; &lt;/th&gt;
&lt;th&gt;A : socket部分&lt;/th&gt;
&lt;th&gt;B: 路由与视图函数对应关系(路由匹配)&lt;/th&gt;
&lt;th&gt;C: 模版语法&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;django&lt;/td&gt;
&lt;td&gt;别人的wsgiref模块&lt;/td&gt;
&lt;td&gt;自己写&lt;/td&gt;
&lt;td&gt;自己的(没有jinja2好用 但是也很方便)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;flask&lt;/td&gt;
&lt;td&gt;别人的werkzeug(内部还是wsgiref模块)&lt;/td&gt;
&lt;td&gt;自己写&lt;/td&gt;
&lt;td&gt;别人的(jinja2)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;tornado&lt;/td&gt;
&lt;td&gt;自己写的&lt;/td&gt;
&lt;td&gt;自己写&lt;/td&gt;
&lt;td&gt;自己写&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;起步介绍&lt;/h2&gt;
&lt;p&gt;　　 如何编写一个最简单的&lt;code&gt;tornado&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import os

import tornado.ioloop
import tornado.web

BASE_DIR = os.path.dirname(__file__)


class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.render(&quot;index.html&quot;)


settings = {
    &quot;debug&quot;: True,
    &quot;template_path&quot;: os.path.join(BASE_DIR, &quot;views&quot;),  # 存放模板的文件夹
    &quot;static_path&quot;: os.path.join(BASE_DIR, &quot;static&quot;),  # 存放静态文件的文件夹
}

application = tornado.web.Application(
    [
        (r&quot;/index&quot;, IndexHandler),  # 正则匹配，路由规则
    ],
    **settings)  # 配置项

if __name__ == '__main__':
        # 1.新增socket Server端，并将fp描述符添加至select或者epoll中
    application.listen(8888)
    # 2.循环epoll进行监听
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 模板文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;INDEX&amp;lt;/title&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;{{static_url('common.css')}}&quot;&amp;gt;
&amp;lt;!--    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/static/common.css&quot;&amp;gt;--&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;INDEX&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;HTTP请求处理方式&lt;/h2&gt;
&lt;p&gt;　　 下面将来探究&lt;code&gt;Django/Flask/tornado&lt;/code&gt;如何处理一次&lt;code&gt;HTTP&lt;/code&gt;请求：&lt;/p&gt;
&lt;p&gt;　　 &lt;code&gt;Django&lt;/code&gt;中处理一次&lt;code&gt;HTTP&lt;/code&gt;请求默认是以多线程模式完成。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;　　在DJnago1.x版本之后，默认启动都是多线程形式，如果要启用单线程模式：&lt;/p&gt;
&lt;p&gt;　　python manage.py runserver --nothreading&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;from django.shortcuts import HttpResponse
from threading import get_ident

def api1(request):
    print(get_ident())  # 13246
    return HttpResponse(&quot;api1&quot;)

def api2(request):
    print(get_ident())  # 13824
    return HttpResponse(&quot;api2&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 &lt;code&gt;Flask&lt;/code&gt;的底层其实也是&lt;code&gt;wsgiref&lt;/code&gt;模块实现，所以处理一次&lt;code&gt;HTTP&lt;/code&gt;请求也是以多线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import flask
from threading import get_ident

app = flask.Flask(__name__)

@app.route('/api1')
def api1():
    print(get_ident())  # 15952
    return &quot;api1&quot;

@app.route('/api2')
def api2():
    print(get_ident())  # 15236
    return &quot;api2&quot;

if __name__ == '__main__':
    app.run()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;的处理方式是单线程+&lt;code&gt;I/O&lt;/code&gt;多路复用，这意味着必须挨个挨个排队处理每一个&lt;code&gt;HTTP&lt;/code&gt;请求：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web
from threading import get_ident


class Api1Handler(tornado.web.RequestHandler):
    def get(self):
        print(get_ident())  # 10168
        self.write(&quot;api1&quot;)

class Api2Handler(tornado.web.RequestHandler):
    def get(self):
        print(get_ident())  # 10168
        self.write(&quot;api2&quot;)

application = tornado.web.Application([
    (r&quot;/api1&quot;,Api1Handler),
    (r&quot;/api2&quot;,Api2Handler),
])

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;tornado的异步&lt;/h2&gt;
&lt;p&gt;　　 要想了解&lt;code&gt;tornado&lt;/code&gt;的异步，就结合前面请求处理方式来看。&lt;/p&gt;
&lt;p&gt;　　 同步&lt;code&gt;Web&lt;/code&gt;框架与异步&lt;code&gt;Web&lt;/code&gt;框架的区别，这里有一篇文章写的不错：&lt;/p&gt;
&lt;p&gt;　　 &lt;a href=&quot;https://www.cnblogs.com/shuchongzeishuai/p/14014756.html&quot;&gt;同步与异步 Python 有何不同？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　 上面文章的一句话来概括就是说同步大多数都是监听一个&lt;code&gt;socket&lt;/code&gt;对象（服务器），当服务器对象的描述符状态（可读）发生改变后，就会创建一个新的线程来处理本次请求，&lt;code&gt;Django/Flask&lt;/code&gt;内部其实都是通过&lt;code&gt;wsgiref&lt;/code&gt;模块实现，并且&lt;code&gt;wsgiref&lt;/code&gt;依赖于&lt;code&gt;socketserver&lt;/code&gt;模块。如果想了解他们如何启动多线程进行服务监听，可参照早期文章（调用方式一模一样）：&lt;/p&gt;
&lt;p&gt;　　 &lt;a href=&quot;https://www.cnblogs.com/Yunya-Cnblogs/p/13205917.html&quot;&gt;socketserver使用及源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　 而对于&lt;code&gt;tornado&lt;/code&gt;来说，它不会创建多线程，而是将&lt;code&gt;conn&lt;/code&gt;双向连接对象放入事件循环中予以监听。&lt;/p&gt;
&lt;p&gt;　　 得益于&lt;code&gt;epoll&lt;/code&gt;的主动性，&lt;code&gt;tornado&lt;/code&gt;的速度非常快，而在处理完&lt;code&gt;conn&lt;/code&gt;（本次会话后），则会将&lt;code&gt;conn&lt;/code&gt;（&lt;code&gt;Socket&lt;/code&gt;）进行断开。 （&lt;code&gt;HTTP&lt;/code&gt;短链接）&lt;/p&gt;
&lt;h2&gt;tornado的非阻塞&lt;/h2&gt;
&lt;p&gt;　　 拿&lt;code&gt;Django&lt;/code&gt;的单线程举例，当一个&lt;code&gt;HTTP&lt;/code&gt;请求到来并未完成时，下一个&lt;code&gt;HTTP&lt;/code&gt;请求将会被阻塞。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;python manage.py runserver --nothreading
# 尝试以单线程的方式运行...对比tornado的单线程
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from django.shortcuts import HttpResponse
import time

def api1(request):
    time.sleep(5)
    return HttpResponse(&quot;api1&quot;)

def api2(request):
    return HttpResponse(&quot;api2&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 而如果是&lt;code&gt;tornado&lt;/code&gt;的非阻塞方式，单线程模式下即使第一个视图阻塞了，第二个视图依旧能够进行访问.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import time

import tornado.ioloop
import tornado.web
from tornado import gen
from tornado.concurrent import Future


class Api1Handler(tornado.web.RequestHandler):
    @gen.coroutine
    def get(self):
        future = Future()
        # 方式一：添加回调 五秒后执行该异步任务 
        tornado.ioloop.IOLoop.current().add_timeout(time.time() + 5, self.done)
        # 方式二：添加future
        # tornado.ioloop.IOLoop.current().add_future(future,self.done)
        # 方式三：添加回调
        # future.add_done_callback(self.doing)
        yield future

    def done(self, *args, **kwargs):
        self.write('api1')
        self.finish()  # 完成本次HTTP请求，将future的result状态改变


class Api2Handler(tornado.web.RequestHandler):
    def get(self):
        self.write(&quot;api2&quot;)


application = tornado.web.Application([
    (r&quot;/api1&quot;, Api1Handler),
    (r&quot;/api2&quot;, Api2Handler),
])

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 有关于&lt;code&gt;Future&lt;/code&gt;对象如何实现异步，下面会进行详细的探讨。&lt;/p&gt;
&lt;h2&gt;如何了解tornado&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;实现异步的根本技术点：&lt;code&gt;I/O&lt;/code&gt;多路复用的&lt;code&gt;epoll&lt;/code&gt;模式&lt;/p&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;实现非阻塞的根本技术点：&lt;code&gt;Future&lt;/code&gt;期程(未来)对象&lt;/p&gt;

&lt;p&gt;　　 仔细看起步介绍中，&lt;code&gt;tornado&lt;/code&gt;的配置，它是作为关键字传参传入&lt;code&gt;Application&lt;/code&gt;这个类中。&lt;/p&gt;
&lt;p&gt;　　 所以我们可以使用&lt;code&gt;**{k1:v1}&lt;/code&gt;的方式来设定配置项，下面举例一些常见的配置项。&lt;/p&gt;
&lt;h2&gt;常规设置&lt;/h2&gt;
&lt;p&gt;　　 常规配置项：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设置项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15.237804878049&quot;&gt;&lt;tr readability=&quot;2.3823529411765&quot;&gt;&lt;td&gt;autoreload&lt;/td&gt;
&lt;td&gt;如果True，任何源文件更改时服务器进程将重新启动，如&lt;a href=&quot;http://www.tornadoweb.org/en/stable/guide/running.html#debug-mode&quot;&gt;调试模式和自动重新加载中所述&lt;/a&gt;。此选项是Tornado 3.2中的新选项; 以前此功能由debug设置控制&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3.3175355450237&quot;&gt;&lt;td&gt;debug&lt;/td&gt;
&lt;td&gt;几种调试模式设置的简写，在&lt;a href=&quot;http://www.tornadoweb.org/en/stable/guide/running.html#debug-mode&quot;&gt;调试模式和自动重新加载中&lt;/a&gt;描述。设置debug=True相当于autoreload=True，compiled_template_cache=False，static_hash_cache=False，serve_traceback=True&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;default_handler_class|default_handler_args&lt;/td&gt;
&lt;td&gt;如果没有找到其他匹配项，将使用此处理程序; 使用它来实现自定义404页面（Tornado 3.2中的新增功能）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;compress_response&lt;/td&gt;
&lt;td&gt;如果True，文本格式的响应将自动压缩。Tornado 4.0的新功能&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;gzip&lt;/td&gt;
&lt;td&gt;compress_response自Tornado 4.0以来已弃用的别名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3.2380952380952&quot;&gt;&lt;td&gt;log_function&lt;/td&gt;
&lt;td&gt;此函数将在每个记录结果的请求结束时调用（使用一个参数，即&lt;a href=&quot;http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler&quot;&gt;&lt;code&gt;RequestHandler&lt;/code&gt;&lt;/a&gt;对象）。默认实现将写入&lt;a href=&quot;https://docs.python.org/3.6/library/logging.html#module-logging&quot;&gt;logging&lt;/a&gt;模块的根记录器。也可以通过覆盖来定制&lt;a href=&quot;http://www.tornadoweb.org/en/stable/web.html#tornado.web.Application.log_request&quot;&gt;Application.log_request&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;serve_traceback&lt;/td&gt;
&lt;td&gt;如果True，默认错误页面将包含错误的回溯。此选项是Tornado 3.2中的新选项; 以前此功能由debug设置控制&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.741935483871&quot;&gt;&lt;td&gt;ui_modules | ui_methods&lt;/td&gt;
&lt;td&gt;可以设置为&lt;a href=&quot;http://www.tornadoweb.org/en/stable/web.html#tornado.web.UIModule&quot;&gt;UIModule&lt;/a&gt;可用于模板的映射或UI方法。可以设置为模块，字典或模块和/或dicts列表。有关详细信息，请参阅&lt;a href=&quot;http://www.tornadoweb.org/en/stable/guide/templates.html#ui-modules&quot;&gt;UI模块&lt;/a&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;websocket_ping_interval&lt;/td&gt;
&lt;td&gt;如果设置为数字，则每n秒钟将对所有websockets进行ping操作。这有助于通过关闭空闲连接的某些代理服务器保持连接活动，并且它可以检测websocket是否在未正确关闭的情况下发生故障。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;websocket_ping_timeout&lt;/td&gt;
&lt;td&gt;如果设置了ping间隔，并且服务器在这么多秒内没有收到“pong”，它将关闭websocket。默认值是ping间隔的三倍，最少30秒。如果未设置ping间隔，则忽略。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 说点人话，&lt;code&gt;debug&lt;/code&gt;或者&lt;code&gt;autoreload&lt;/code&gt;为&lt;code&gt;True&lt;/code&gt;时，修改源文件代码将会自动重启服务，相当于&lt;code&gt;Django&lt;/code&gt;的重启功能。&lt;/p&gt;
&lt;p&gt;　　 而&lt;code&gt;log_function&lt;/code&gt;则可以自定制日志的输出格式，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def log_func(handler):
    if handler.get_status() &amp;lt; 400:
        log_method = access_log.info
    elif handler.get_status() &amp;lt; 500:
        log_method = access_log.warning
    else:
        log_method = access_log.error
        
    request_time = 1000.0 * handler.request.request_time()
    log_method(&quot;%d %s %s (%s) %s %s %.2fms&quot;,
               handler.get_status(), handler.request.method,
               handler.request.uri, handler.request.remote_ip,
               handler.request.headers[&quot;User-Agent&quot;],
               handler.request.arguments,

settings = {&quot;log_function&quot;:log_func}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;身份/验证/安全&lt;/h2&gt;
&lt;p&gt;　　 关于身份、验证、安全的配置项：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设置项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8.6213070725157&quot;&gt;&lt;tr readability=&quot;0.84705882352941&quot;&gt;&lt;td&gt;cookie_secret&lt;/td&gt;
&lt;td&gt;用于&lt;a href=&quot;http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.get_secure_cookie&quot;&gt;RequestHandler.get_secure_cookie&lt;/a&gt; 和&lt;a href=&quot;http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.set_secure_cookie&quot;&gt;set_secure_cookie&lt;/a&gt;签署cookie&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;key_version&lt;/td&gt;
&lt;td&gt;set_secure_cooki 当cookie_secret是密钥字典时，requestHandler 使用特定密钥对cookie进行签名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.1458333333333&quot;&gt;&lt;td&gt;login_url&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;http://www.tornadoweb.org/en/stable/web.html#tornado.web.authenticated&quot;&gt;authenticated&lt;/a&gt;如果用户未登录，装饰器将重定向到此URL。可以通过覆盖进一步自定义&lt;a href=&quot;http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.get_login_url&quot;&gt;RequestHandler.get_login_url&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.1290322580645&quot;&gt;&lt;td&gt;xsrf_cookies&lt;/td&gt;
&lt;td&gt;如果&lt;code&gt;True&lt;/code&gt;，将启用&lt;a href=&quot;http://www.tornadoweb.org/en/stable/guide/security.html#xsrf&quot;&gt;跨站点请求伪造保护&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;xsrf_cookie_version&lt;/td&gt;
&lt;td&gt;控制此服务器生成的新XSRF cookie的版本。通常应该保留默认值（它始终是支持的最高版本），但可以在版本转换期间临时设置为较低的值。Tornado 3.2.2中的新功能，它引入了XSRF cookie版本2&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.537037037037&quot;&gt;&lt;td&gt;xsrf_cookie_kwargs&lt;/td&gt;
&lt;td&gt;可以设置为要传递给&lt;a href=&quot;http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.set_cookie&quot;&gt;RequestHandler.set_cookie&lt;/a&gt; XSRF cookie 的其他参数的字典&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.7913043478261&quot;&gt;&lt;td&gt;twitter_consumer_key&lt;/td&gt;
&lt;td&gt;所用的 &lt;a href=&quot;http://www.tornadoweb.org/en/stable/auth.html#module-tornado.auth&quot;&gt;tornado.auth&lt;/a&gt;模块来验证各种API，如检测这些种类账号是否登录等...&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;twitter_consumer_secret&lt;/td&gt;
&lt;td&gt;同上..&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;friendfeed_consumer_key&lt;/td&gt;
&lt;td&gt;同上..&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;friendfeed_consumer_secret&lt;/td&gt;
&lt;td&gt;同上..&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;google_consumer_key&lt;/td&gt;
&lt;td&gt;同上..&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;google_consumer_secret&lt;/td&gt;
&lt;td&gt;同上..&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;facebook_api_key&lt;/td&gt;
&lt;td&gt;同上..&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;facebook_secret&lt;/td&gt;
&lt;td&gt;同上..&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;模板设置&lt;/h2&gt;
&lt;p&gt;　　 模板设置项：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设置项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.8087056128293&quot;&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;autoescape&lt;/td&gt;
&lt;td&gt;控制模板的自动转义。可以设置为None禁用转义，或者设置 应该传递所有输出的函数的&lt;em&gt;名称&lt;/em&gt;。默认为&quot;xhtml_escape&quot;。可以使用该指令在每个模板的基础上进行更改。{% autoescape %}&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;compiled_template_cache&lt;/td&gt;
&lt;td&gt;默认是True; 如果False每个请求都会重新编译模板。此选项是Tornado 3.2中的新选项; 以前此功能由debug设置控制&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;1.4128440366972&quot;&gt;&lt;td&gt;template_path&lt;/td&gt;
&lt;td&gt;包含模板文件的目录。可以通过覆盖进一步定制&lt;a href=&quot;http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.get_template_path&quot;&gt;RequestHandler.get_template_path&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.8622222222222&quot;&gt;&lt;td&gt;template_loader&lt;/td&gt;
&lt;td&gt;分配给&lt;a href=&quot;http://www.tornadoweb.org/en/stable/template.html#tornado.template.BaseLoader&quot;&gt;tornado.template.BaseLoader&lt;/a&gt;自定义模板加载的实例 。如果使用此 设置，则忽略template_path和autoescape设置。可以通过覆盖进一步定制&lt;a href=&quot;http://www.tornadoweb.org/en/stable/web.html#tornado.web.RequestHandler.create_template_loader&quot;&gt;RequestHandler.create_template_loader&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2.2330827067669&quot;&gt;&lt;td&gt;template_whitespace&lt;/td&gt;
&lt;td&gt;控制模板中空格的处理; 查看&lt;a href=&quot;http://www.tornadoweb.org/en/stable/template.html#tornado.template.filter_whitespace&quot;&gt;tornado.template.filter_whitespace&lt;/a&gt;允许的值。Tornado 4.3中的新功能&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;静态文件&lt;/h2&gt;
&lt;p&gt;　　 静态文件相关设置：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;设置项&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6.1547619047619&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;static_hash_cache&lt;/td&gt;
&lt;td&gt;默认是True; 如果False 每次请求都会重新计算静态网址。此选项是Tornado 3.2中的新选项; 以前此功能由debug设置控制&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;static_path&lt;/td&gt;
&lt;td&gt;将从中提供静态文件的目录&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;static_url_prefix&lt;/td&gt;
&lt;td&gt;静态文件的Url前缀，默认为/static/&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5.3507462686567&quot;&gt;&lt;td&gt;static_handler_class | static_handler_args&lt;/td&gt;
&lt;td&gt;可以设置为静态文件而不是默认文件使用不同的处理程序 &lt;a href=&quot;http://www.tornadoweb.org/en/stable/web.html#tornado.web.StaticFileHandler&quot;&gt;tornado.web.StaticFileHandler&lt;/a&gt;。 static_handler_args如果设置，则应该是要传递给处理程序initialize方法的关键字参数的字典。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;h2&gt;正则匹配&lt;/h2&gt;
&lt;p&gt;　　 在&lt;code&gt;tornado&lt;/code&gt;中，一个&lt;code&gt;url&lt;/code&gt;对应一个类。&lt;/p&gt;
&lt;p&gt;　　 匹配方式为正则匹配，因此要注意使用&lt;code&gt;^&lt;/code&gt;与&lt;code&gt;$&lt;/code&gt;的使用。&lt;/p&gt;
&lt;p&gt;　　　由于匹配行为是从上至下，所以在定义时一定要注意顺序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web

# http://127.0.0.1:8888/admin
class APIHandler(tornado.web.RequestHandler):
    def get(self):
        self.write(&quot;...&quot;)


settings = {&quot;debug&quot;: True}

application = tornado.web.Application([
    (r&quot;^/a.{4}$&quot;, APIHandler),
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;无名分组&lt;/h2&gt;
&lt;p&gt;　　 使用正则分组&lt;code&gt;()&lt;/code&gt;解析出资源请求地址的一些参数。&lt;/p&gt;
&lt;p&gt;　　 匹配到的参数会通过位置传参的形式传递给控制器处理函数，所以接收参数可以任意命名，因此你可以通过&lt;code&gt;*args&lt;/code&gt;接收到所有匹配的参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web

# http://127.0.0.1:8888/register/yunya
class RegisterHandler(tornado.web.RequestHandler):
    def get(self,*args):
        self.write(str(args))  # ('yunya',)


settings = {&quot;debug&quot;: True}

application = tornado.web.Application([
    (r&quot;^/register/(\w+)&quot;, RegisterHandler),
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如果确定这一被捕捉参数将被使用，则可指定形参进行接收：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web

# http://127.0.0.1:8888/register/yunya
class RegisterHandler(tornado.web.RequestHandler):
    def get(self,params):
        self.write(params)   # 'yunya'


settings = {&quot;debug&quot;: True}

application = tornado.web.Application([
    (r&quot;^/register/(\w+)&quot;, RegisterHandler),
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;有命分组&lt;/h2&gt;
&lt;p&gt;　　 使用正则的有命分组&lt;code&gt;(?P&amp;lt;组名&amp;gt;规则)&lt;/code&gt;解析出资源请求地址的一些参数。&lt;/p&gt;
&lt;p&gt;　　 匹配到的参数会通过关键字传参的形式传递给控制器处理函数，所以接收参数必须与组名相同，因此你可以通过&lt;code&gt;**kwargs&lt;/code&gt;接收到所有匹配的参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web

# http://127.0.0.1:8888/register/yunya
class RegisterHandler(tornado.web.RequestHandler):
    def get(self,**kwargs):
        self.write(str(kwargs))  # {'username': 'yunya'}


settings = {&quot;debug&quot;: True}

application = tornado.web.Application([
    (r&quot;^/register/(?P&amp;lt;username&amp;gt;\w+)&quot;, RegisterHandler),
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如果确定这一被捕捉参数将被使用，则可指定形参进行接收（形参命名必须与正则匹配的组名相同）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web

# http://127.0.0.1:8888/register/yunya
class RegisterHandler(tornado.web.RequestHandler):
    def get(self,username):
        self.write(username)  # 'yunya'


settings = {&quot;debug&quot;: True}

application = tornado.web.Application([
    (r&quot;^/register/(?P&amp;lt;username&amp;gt;\w+)&quot;, RegisterHandler),
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;混合使用&lt;/h2&gt;
&lt;p&gt;　　 在&lt;code&gt;tornado&lt;/code&gt;中，路由匹配的参数捕捉不允许无名分组和有名分组的混合使用，这会引发一个异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;application = tornado.web.Application([
    (r&quot;^/register/(/d+)/(?P&amp;lt;username&amp;gt;\w+)&quot;, RegisterHandler),
], **settings)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 抛出的错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;AssertionError: groups in url regexes must either be all named or all positional: '^/register/(/d+)/(?P&amp;lt;username&amp;gt;\\w+)$'
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 分组必须全部使用位置、或者使用命名。&lt;/p&gt;
&lt;h2&gt;反向解析&lt;/h2&gt;
&lt;p&gt;　　 反向解析要与路由命名同时使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web


# http://127.0.0.1:8888/register
class RegisterHandler(tornado.web.RequestHandler):
    def get(self):
        print(self.reverse_url(&quot;reg&quot;))  # /register
        self.write(&quot;注册页面&quot;)


settings = {&quot;debug&quot;: True}

# 使用tornado.web.url来进行添加路由规则
application = tornado.web.Application([
    tornado.web.url(r'/register', RegisterHandler, name=&quot;reg&quot;)
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 前端模板中的反向解析（必须注册名字）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{{reverse_url('reg')}}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;p&gt;　　 在&lt;code&gt;MCV&lt;/code&gt;模型中，&lt;code&gt;C&lt;/code&gt;代表&lt;code&gt;Controller&lt;/code&gt;即为控制器，类似于&lt;code&gt;Django&lt;/code&gt;中的&lt;code&gt;views&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　 我们可以看见在&lt;code&gt;tornado&lt;/code&gt;中，控制器处理函数都毫不意外的继承了一个叫做&lt;code&gt;tornado.web.RequestHandler&lt;/code&gt;的对象，所有的方法都是从&lt;code&gt;self&lt;/code&gt;中进行调用，所以你可以查看它的源码获取所有方法，或者使用&lt;code&gt;help()&lt;/code&gt;函数获得它的&lt;code&gt;DOC&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　 下面我将例举出一些常用的方法。&lt;/p&gt;
&lt;h2&gt;获取相关&lt;/h2&gt;
&lt;p&gt;　　 以下是常用的获取相关属性以及方法，基本是&lt;code&gt;RequestHandler&lt;/code&gt;中的属性、方法与&lt;code&gt;self.request&lt;/code&gt;对象中封装的方法和属性：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;属性/方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self.request&lt;/td&gt;
&lt;td&gt;获取用户请求相关信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self._headers&lt;/td&gt;
&lt;td&gt;获取请求头信息，基本请求头被过滤&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self.request.headers&lt;/td&gt;
&lt;td&gt;获取请求头信息，包含基本请求头&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;slef.request.body&lt;/td&gt;
&lt;td&gt;获取请求体信息，bytes格式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;self.request.remote_ip&lt;/td&gt;
&lt;td&gt;获取客户端IP&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;self.request.method&lt;/td&gt;
&lt;td&gt;获取请求方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self.request.version&lt;/td&gt;
&lt;td&gt;获取所使用的HTTP版本&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;self.get_query_argument()&lt;/td&gt;
&lt;td&gt;获取单个GET中传递过来的参数，如果多个参数同名，获取最后一个&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;slef.get_query_arguments()&lt;/td&gt;
&lt;td&gt;获取所有GET中传递过来的参数，返回列表的形式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self.get_body_argument()&lt;/td&gt;
&lt;td&gt;获取单个POST中传递过来的参数，如果多个参数同名，获取最后一个&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;self.get_body_arguments()&lt;/td&gt;
&lt;td&gt;获取所有POST中传递过来的参数，返回列表的形式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self.get_argument()&lt;/td&gt;
&lt;td&gt;获取单个GET/POST中传递过来的参数，如果多个参数同名，获取最后一个&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self.get_arguments()&lt;/td&gt;
&lt;td&gt;获取所有GET/POST中传递过来的参数，返回列表的形式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self.request.files&lt;/td&gt;
&lt;td&gt;获取所有通过 multipart/form-data POST 请求上传的文件&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;self.request.host&lt;/td&gt;
&lt;td&gt;获取主机名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self.request.uri&lt;/td&gt;
&lt;td&gt;获取请求的完整资源标识，包括路径和查询字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self.request.query&lt;/td&gt;
&lt;td&gt;获取查询字符串的部分&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self.request.path&lt;/td&gt;
&lt;td&gt;获取请求的路径（ ?之前的所有内容）&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 示例演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web


# http://127.0.0.1:8888/register?name=yunya&amp;amp;hobby=%E7%AF%AE%E7%90%83&amp;amp;hobby=%E8%B6%B3%E7%90%83
class RegisterHandler(tornado.web.RequestHandler):
    def get(self):
        # 获取客户端IP
        print(self.request.remote_ip)  # 127.0.0.1
        # 查看请求方式
        print(self.request.method)  # GET
        # 获取单个GET/POST传递的参数
        print(self.get_query_argument(&quot;name&quot;))  # yunya
        # 获取多个GET/POST传递的参数、list形式
        print(self.get_query_arguments(&quot;hobby&quot;))  # ['篮球', '足球']
        
        print(self.request.host) # 127.0.0.1:8888
        print(self.request.uri)  # register?name=yunya&amp;amp;hobby=%E7%AF%AE%E7%90%83&amp;amp;hobby=%E8%B6%B3%E7%90%83
        print(self.request.path)  # /register
        print(self.request.query)  # name=yunya&amp;amp;hobby=%E7%AF%AE%E7%90%83&amp;amp;hobby=%E8%B6%B3%E7%90%83
        
        self.write(&quot;OK&quot;)

settings = {&quot;debug&quot;:True}
application = tornado.web.Application([
    tornado.web.url(r'/register', RegisterHandler, name=&quot;reg&quot;)
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 文件上传案例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web

class APIHandler(tornado.web.RequestHandler):
    def post(self):
        # step01:获取所有名为img的文件对象，返回一个列表 [img,img,img]
        file_obj_list = self.request.files.get(&quot;img&quot;)
        # step02:获取第一个对象
        file_obj = file_obj_list[0]
        # step03:获取文件名称
        file_name = file_obj.filename
        # step04:获取文件数据
        file_body = file_obj.body
        # step05:获取文件类型
        file_type = file_obj.content_type

        with open(f&quot;./{file_name}&quot;,mode=&quot;wb&quot;) as f:
            f.write(file_body)

        self.write(&quot;OK&quot;)

settings = {&quot;debug&quot;:True}
application = tornado.web.Application([
    tornado.web.url(r'/api', APIHandler)
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;响应相关&lt;/h2&gt;
&lt;p&gt;　　 响应一般就分为以下几种，返回单纯的字符串，返回一个模板页面，返回&lt;code&gt;JSON&lt;/code&gt;格式数据，返回一个错误，以及重定向：&lt;/p&gt;
&lt;p&gt;　　 返回单纯字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;self.write(&quot;OK&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 返回一个模板页面：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;self.render(&quot;templatePath&quot;,**kwargs)  # 传递给模板的数据
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 返回&lt;code&gt;JSON&lt;/code&gt;格式数据（手动&lt;code&gt;JSON&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import json
json_data = json.dumps({&quot;k1&quot;:&quot;v1&quot;})
self.write(json_data)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 返回一个错误（直接&lt;code&gt;raise&lt;/code&gt;引发异常即可）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;raise tornado.web.HTTPError(403) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 重定向：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;self.redirect(&quot;/&quot;,status=301)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 响应头相关的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;self.set_header(&quot;k1&quot;, 1)
self.add_header(&quot;k2&quot;, 2)
self.clear_header(&quot;k1&quot;) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;钩子函数&lt;/h2&gt;
&lt;p&gt;　　 我们可以在控制器中定义一个钩子函数&lt;code&gt;initialize()&lt;/code&gt;，并且可以在&lt;code&gt;url&lt;/code&gt;中对他进行一些参数传递：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web


class APIHandler(tornado.web.RequestHandler):
    def initialize(self, *args, **kwargs) -&amp;gt; None:
        print(kwargs)  # {k1:v1}
        self.data = &quot;某个数据&quot;

    def post(self):
        print(self.data)  # 某个数据
        self.write(&quot;ok&quot;)


settings = {&quot;debug&quot;: True}
application = tornado.web.Application([
    tornado.web.url(r'/api', APIHandler, {&quot;k1&quot;: &quot;v1&quot;}),  # dict -&amp;gt; **kwargs
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 所有的钩子函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class APIHandler(tornado.web.RequestHandler):
    def set_default_headers(self):
        print(&quot;first--设置headers&quot;)

    def initialize(self):
        print(&quot;second--初始化&quot;)

    def prepare(self):
        print(&quot;third--准备工作&quot;)

    def get(self):
        print(&quot;fourth--处理get请求&quot;)

    def post(self):
        print('fourth--处理post请求')

    def write_error(self, status_code, **kwargs):
        print(&quot;fifth--处理错误&quot;)

    def on_finish(self):
        print(&quot;sixth--处理结束,释放资源--&quot;)
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;指定目录&lt;/h2&gt;
&lt;p&gt;　　 在&lt;code&gt;settings&lt;/code&gt;中指定模板所在目录，如不指定，默认在当前文件夹下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web


class APIHandler(tornado.web.RequestHandler):
    def get(self):
        # 找当前目录下的views文件夹，到views下去找api.html模板文件
        self.render(&quot;api.html&quot;)


settings = {
    &quot;debug&quot;: True,
    &quot;template_path&quot;: &quot;views&quot;,  # 指定模板目录
    &quot;static_path&quot;: &quot;static&quot;,  # 指定静态文件目录
}

application = tornado.web.Application([
    tornado.web.url(r'/api', APIHandler),
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;模板传参&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;中的模板传参与&lt;code&gt;Flask&lt;/code&gt;相同。&lt;/p&gt;
&lt;p&gt;　　 模板传参可以通过&lt;code&gt;k=v&lt;/code&gt;的方式传递，也可以通过&lt;code&gt;**dict&lt;/code&gt;的方式进行解包传递：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class APIHandler(tornado.web.RequestHandler):
    def get(self):
        context = {
            &quot;name&quot;: &quot;云崖&quot;,
            &quot;age&quot;: 18,
            &quot;hobby&quot;: [&quot;篮球&quot;, &quot;足球&quot;]
        }
        self.render(&quot;api.html&quot;,**context)
        # self.render(&quot;api.html&quot;,name=&quot;云崖&quot;,age=18,hobby=[&quot;篮球&quot;, &quot;足球&quot;])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 渲染，通过&lt;code&gt;{{}}&lt;/code&gt;进行，注意：&lt;code&gt;trdtmp&lt;/code&gt;中不支持&lt;code&gt;.&lt;/code&gt;的深度查询访问，这点与&lt;code&gt;DTL&lt;/code&gt;和&lt;code&gt;JinJa2&lt;/code&gt;不同：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
    &amp;lt;p&amp;gt;{{name}}&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;{{age}}&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;{{hobby[0]}}-{{hobby[1]}}&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;模板形式&lt;/h2&gt;
&lt;p&gt;　　 模板中有两种表现形式，一种是表达式形式以&lt;code&gt;{{}}&lt;/code&gt;进行包裹，另一种是命令形式以&lt;code&gt;{% 命令 %}&lt;/code&gt;包裹。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;　　注意：tornado的模板语法的结束标识是{% end %}，不是Django或jinja2的{% endblock %}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 举例表达式形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 渲染控制器函数传入的变量
&amp;lt;body&amp;gt;
欢迎{{ username }}登录
&amp;lt;/body&amp;gt;

# 进行Python表达式
{{ 1 + 1 }}
# 导入模块并使用
{{ time.time() }}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 举例命令形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% if 1 %}
    this is if
{% end %}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如果想对命令进行注释，则可以使用&lt;code&gt;{# #}&lt;/code&gt;，如果不想执行内容，则可以使用&lt;code&gt;{{! {%! {#&lt;/code&gt;为前缀，如下示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{{! 1 + 1}}

{%! if 1 %}
    this is if
{%! end %}

{#! time.time() #}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;导入模块&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;中的模板语言允许导入&lt;code&gt;Python&lt;/code&gt;包、模块：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% import time %}
{{ time.time() }}

{% from util.modify import mul %}
{{mul(6,6)}}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;模板功能&lt;/h2&gt;
&lt;p&gt;　　 模板中提供一些功能，可以在&lt;code&gt;{{}}&lt;/code&gt;或者&lt;code&gt;{% %}&lt;/code&gt;中进行使用：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;模板调用的方法/功能/模块&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;escape&lt;/td&gt;
&lt;td&gt;tornado.escape.xhtml_escape的别名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;xhtml_escape&lt;/td&gt;
&lt;td&gt;tornado.escape.xhtml_escape的别名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;url_escape&lt;/td&gt;
&lt;td&gt;tornado.escape.url_escape的别名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;json_encode&lt;/td&gt;
&lt;td&gt;tornado.escape.json_encode的别名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;squeeze&lt;/td&gt;
&lt;td&gt;tornado.escape.squeeze的别名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;linkify&lt;/td&gt;
&lt;td&gt;tornado.escape.linkify的别名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;datetime&lt;/td&gt;
&lt;td&gt;Python 的 datetime模组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;handler&lt;/td&gt;
&lt;td&gt;当前的 RequestHandler对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;request&lt;/td&gt;
&lt;td&gt;handler.request的別名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;current_user&lt;/td&gt;
&lt;td&gt;handler.current_user的别名&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;locale&lt;/td&gt;
&lt;td&gt;handler.locale`的別名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;_&lt;/td&gt;
&lt;td&gt;handler.locale.translate 的別名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;static_url&lt;/td&gt;
&lt;td&gt;for handler.static_url 的別名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;xsrf_form_html&lt;/td&gt;
&lt;td&gt;handler.xsrf_form_html 的別名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;reverse_url&lt;/td&gt;
&lt;td&gt;Application.reverse_url 的別名&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Application&lt;/td&gt;
&lt;td&gt;设置中ui_methods和 ui_modules下面的所有项目&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;分支循环&lt;/h2&gt;
&lt;p&gt;　　 模板中的&lt;code&gt;if&lt;/code&gt;判断：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% if username != 'no' %}
    欢迎{{ username }}登录
{% else %}
    请登录
{% end %}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 &lt;code&gt;for&lt;/code&gt;循环：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;body&amp;gt;
    {% for item in range(10) %}
        {% if item == 0%}
            &amp;lt;p&amp;gt;start&amp;lt;/p&amp;gt;
        {% elif item == len(range(10))-1 %}
            &amp;lt;p&amp;gt;end&amp;lt;/p&amp;gt;
        {% else %}
            &amp;lt;p&amp;gt;{{item}}&amp;lt;/p&amp;gt;
        {% end %}
    {% end %}
&amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 &lt;code&gt;while&lt;/code&gt;循环：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% set a = 0 %}

{% while a&amp;lt;5 %}
    {{ a }}&amp;lt;br&amp;gt;
    {% set a += 1 %}
{% end %}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;模板转义&lt;/h2&gt;
&lt;p&gt;　　 默认的模板在渲染时都会将&lt;code&gt;&amp;lt;&lt;/code&gt;与&lt;code&gt;&amp;gt;&lt;/code&gt;以及空格等特殊字符替换为&lt;code&gt;HTML&lt;/code&gt;内容，如&lt;code&gt;&amp;amp;lt;&lt;/code&gt;，&lt;code&gt;&amp;amp;gt;&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;　　 关于模板转义的方式有以下几种。&lt;/p&gt;
&lt;p&gt;　　 1.单变量去除转义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{{'&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;'}}           # &amp;amp;lt;b&amp;amp;gt;你好&amp;amp;lt;/b&amp;amp;gt;
{% raw '&amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;' %}  # &amp;lt;b&amp;gt;你好&amp;lt;/b&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 2.当前模板全局去除转义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% autoescape None %}  # 模板首行加入
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 3.整个项目去掉转义，为当前的&lt;code&gt;application&lt;/code&gt;进行配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;settings = {
    &quot;autoescape&quot;:None, # 禁用转义
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;模板继承&lt;/h2&gt;
&lt;p&gt;　　 使用&lt;code&gt;{% extends %}&lt;/code&gt;引入一个定义好的模板。&lt;/p&gt;
&lt;p&gt;　　　使用&lt;code&gt;{% blocak %}&lt;/code&gt;和&lt;code&gt;{% end %}&lt;/code&gt;定义并替换块。&lt;/p&gt;
&lt;p&gt;　　 定义主模板：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# views/base.html

&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot;
          content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&amp;gt;
    &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&amp;gt;
    &amp;lt;title&amp;gt;{% block title %}Document{% end %}&amp;lt;/title&amp;gt;
    {% block css %}
    {% end %}
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    {% block main %}
    {% end %}
&amp;lt;/body&amp;gt;
{% block js %}
{% end %}
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 继承与使用模板：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% extends  'base.html'%}

{% block title %}
API
{% end %}

{% block css %}
&amp;lt;style&amp;gt;
    body{
        background-color: red;
    }
&amp;lt;/style&amp;gt;
{% end %}

{% block main %}
&amp;lt;p&amp;gt;HELLO&amp;lt;/p&amp;gt;
{% end %}

{% block js %}
&amp;lt;script&amp;gt;
    alert(&quot;HELLO&quot;)
&amp;lt;/script&amp;gt;
{% end %}
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;模板引入&lt;/h2&gt;
&lt;p&gt;　　 如果一个地方需要一块完整的模板文件，则使用模板引入即可：&lt;/p&gt;
&lt;p&gt;　　 &lt;code&gt;{include 'templateName'}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;　　 定义公用模板：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# views/common.html

&amp;lt;h1&amp;gt;公用内容&amp;lt;/h1&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 引入公用模板：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% extends  'base.html'%}
{% block main %}
    {% include 'common.html' %}  &amp;lt;!-- 模板引入 --&amp;gt;
{% end %}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;静态资源&lt;/h2&gt;
&lt;p&gt;　　 模板中访问静态资源方式有两种，但首先你需要在&lt;code&gt;application&lt;/code&gt;的配置项中对其进行配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;settings = {
    'template_path': 'views',
    'static_path': 'static',  # 指定静态文件目录
    'static_url_prefix': '/static/', # 如果使用静态导入，则这个是前缀
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 推荐动态导入的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;head lang=&quot;en&quot;&amp;gt;
    &amp;lt;link href={{static_url(&quot;common.css&quot;)}} rel=&quot;stylesheet&quot; /&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 也可进行静态导入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;head lang=&quot;en&quot;&amp;gt;
    &amp;lt;link href=&quot;/static/common.css&quot; rel=&quot;stylesheet&quot; /&amp;gt;
&amp;lt;/head&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;ui_methods&lt;/h2&gt;
&lt;p&gt;　　 允许定义全局可用的方法，以便在模板中进行调用。&lt;/p&gt;
&lt;p&gt;　　 第一步，创建独立的一个&lt;code&gt;.py&lt;/code&gt;文件，并且书写函数即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ./templates_methods 
# 所有模板公用函数一定有self
def add(self, x, y):
    return x + y

# 如果方法中返回的是html字符串，则会被转义掉
def input(self, type, name):
    return f&quot;&amp;lt;input type={type} name={name}&amp;gt;&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 第二步，在&lt;code&gt;appliction&lt;/code&gt;注册&lt;code&gt;ui_methods&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web
# 导入自定义的py文件
import templates_methods


class APIHandler(tornado.web.RequestHandler):
    def get(self):
        self.render(&quot;api.html&quot;)


settings = {
    &quot;debug&quot;: True,
    &quot;template_path&quot;: &quot;views&quot;,  # 指定模板目录
    &quot;static_path&quot;: &quot;static&quot;,  # 指定静态文件目录
    &quot;ui_methods&quot;: templates_methods,  # 注册
}

application = tornado.web.Application([
    tornado.web.url(r'/api', APIHandler),
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 第三步，在模板中使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    {{ add(1,2) }}
    {% raw input('text','username') %}
    # 受限于ui_methods中返回字符串会经过转义的设定，所以在前端上我们选择用raw来做转义
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;ui_modules&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;ui_modules&lt;/code&gt;定义一些公用的组件，在这里返回的字符串将默认关闭&lt;code&gt;HTML&lt;/code&gt;字符转义功能。&lt;/p&gt;
&lt;p&gt;　　 比如有一个多页面网站，我们希望对该网站中每一个页面都加上一则广告窗口，就可以使用&lt;code&gt;ui_modules&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　 首先第一步，广告弹窗肯定是一个独立的组件，需要有&lt;code&gt;HTML&lt;/code&gt;代码，&lt;code&gt;CSS&lt;/code&gt;样式，&lt;code&gt;JS&lt;/code&gt;脚本，所以我们可以看一下&lt;code&gt;ui_modules&lt;/code&gt;中到底提供了什么方法让我们对其进行实现。&lt;/p&gt;
&lt;p&gt;　　 简单的做一下说明：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;需要覆写的方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;render()&lt;/td&gt;
&lt;td&gt;覆写该方法，返回该UI模块的输出&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;embedded_javascript()&lt;/td&gt;
&lt;td&gt;覆写该方法，返回一段JavaScript代码字符串，它将会在模板中自动添加script标签，并且该script标签内部会填入该方法返回的JavaScript代码字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;javascript_files()&lt;/td&gt;
&lt;td&gt;覆写该方法，返回值应当是str，它将会在模板中自动添加script标签并且该script标签的src属性会指向该方法所返回的字符串，如果返回值是一个相对路径，则会去application的settings中寻找静态资源的path做拼接&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;embedded_css()&lt;/td&gt;
&lt;td&gt;覆写该方法，返回一段CSS代码字符串，它将会在模板中自动添加style标签，并且该style标签内部会填入该方法返回的CSS代码字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;css_files()&lt;/td&gt;
&lt;td&gt;覆写该方法，返回值应当是str，它将会在模板中自动添加link标签并且该link标签的href属性会指向该方法所返回的字符串，如果返回值是一个相对路径，则会去application的settings中寻找静态资源的path做拼接&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;html_head()&lt;/td&gt;
&lt;td&gt;重写该方法，返回值将放置在&amp;lt;head /&amp;gt;元素中的HTML字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;html_body()&lt;/td&gt;
&lt;td&gt;重写该方法，返回值将放置在&amp;lt;body /&amp;gt;元素末尾的HTML字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;render_string()&lt;/td&gt;
&lt;td&gt;渲染模板并将其作为字符串返回。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 下面我们来写一个非常简单的广告组件，新建一个叫&lt;code&gt;ui_modules.py&lt;/code&gt;的文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from tornado.web import UIModule


class AD(UIModule):
    def render(self, *args, **kwargs):
        &quot;&quot;&quot;
                模板调用时传递的参数分别放入args以及kwargs中
        &quot;&quot;&quot;
        return &quot;&amp;lt;div id='ad'&amp;gt;这是一段广告&amp;lt;/div&amp;gt;&quot;

    def embedded_css(self):
        &quot;&quot;&quot;
                注意：配置的CSS或者JS代码是全局生效的，所以我们应该只对AD组件做一个约束
        &quot;&quot;&quot;
        return &quot;&quot;&quot;
            #ad{
                width: 200px;
                height: 200px;
                position: fixed;
                left: 25%;
                line-height: 200px;
                text-align: center;
                background: red;
            }
        &quot;&quot;&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 需要为&lt;code&gt;application&lt;/code&gt;注册一下这个&lt;code&gt;ui_modules&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web
# 导入
import ui_modules

class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.render(&quot;index.html&quot;)

class HomeHandler(tornado.web.RequestHandler):
    def get(self):
        self.render(&quot;home.html&quot;)

settings = {
    &quot;debug&quot;: True,
    &quot;template_path&quot;: &quot;views&quot;,  # 指定模板目录
    &quot;static_path&quot;: &quot;static&quot;,  # 指定静态文件目录
    &quot;ui_modules&quot;:ui_modules, # 注册
}


application = tornado.web.Application([
    tornado.web.url(r'^/index/', IndexHandler, name=&quot;index&quot;),
    tornado.web.url(r'^/home/', HomeHandler, name=&quot;home&quot;),
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 然后只需要在模板中进行使用即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# views/index.html

{% extends 'base.html' %}
{% block title %}
    主页
{% end %}

{% block main %}
    &amp;lt;h1&amp;gt;欢迎来到主页&amp;lt;/h1&amp;gt;
    {% module AD() %}

{% end %}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 现在我们的&lt;code&gt;index&lt;/code&gt;就有这个组件了：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210119234518053.png&quot; alt=&quot;image-20210119234518053&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　 如果想在&lt;code&gt;home&lt;/code&gt;页面中也加入这个组件，直接使用&lt;code&gt;{% module AD() %}&lt;/code&gt;即可。&lt;/p&gt;
&lt;h2&gt;模板原理&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;使用内置的open函数读取Html文件中的内容&lt;/li&gt;
&lt;li&gt;根据模板语言的标签分割Html文件的内容，例如：{{}} 或 {%%}&lt;/li&gt;
&lt;li&gt;将分割后的部分数据块格式化成特殊的字符串（表达式）&lt;/li&gt;
&lt;li&gt;通过python的内置函数执行字符串表达式，即：将html文件的内容和嵌套的数据整合&lt;/li&gt;
&lt;li&gt;将数据返回给请求客户端&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　 也就是说，它会将一个文件进行读取，以&lt;code&gt;{{}}&lt;/code&gt;或者&lt;code&gt;{%%}&lt;/code&gt;作为分隔符，拿到其中的内容并进行替换。&lt;/p&gt;
&lt;p&gt;　　 举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;h1&amp;gt;大家好，我是{{username}}&amp;lt;/h1&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 它内部会这样进行拆分：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&quot;&amp;lt;h1&amp;gt;大家好，我是&quot;,&quot;username&quot;,&quot;&amp;lt;/h1&amp;gt;&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 然后将&lt;code&gt;username&lt;/code&gt;这一部分替换为控制器视图中的对应变量，假设&lt;code&gt;username='yunya'&lt;/code&gt;，最后就会变为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[&quot;&amp;lt;h1&amp;gt;大家好，我是&quot;,&quot;yunya&quot;,&quot;&amp;lt;/h1&amp;gt;&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 当然在替换的时候也会进行模板字符串转义的检测，如果检测出有字符&lt;code&gt;&amp;lt;&lt;/code&gt;或者&lt;code&gt;&amp;gt;&lt;/code&gt;等，则特换为&lt;code&gt;&amp;amp;lt;&lt;/code&gt;与&lt;code&gt;&amp;amp;gt;&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;　　 所以最后的结果就是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;h1&amp;gt;大家好，我是yunya&amp;lt;/h1&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;基本操作&lt;/h2&gt;
&lt;p&gt;　　 操作&lt;code&gt;cookie&lt;/code&gt;有两个最基本的方法：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;self.get_cookie()&lt;/td&gt;
&lt;td&gt;获取cookie键值对&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;self.set_cookie()&lt;/td&gt;
&lt;td&gt;设置cookie键值对，参数expires可设置过期时间（日期：datetime/time，默认30天），expires_day设置过期天数（优先级更高），示例：expirse = time.time() + 60 * 60 * 24 * 7&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 简单示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class APIHandler(tornado.web.RequestHandler):
    def get(self):
        if self.get_cookie(&quot;access&quot;):
            self.write(&quot;你来访问过了&quot;)
        else:
            self.set_cookie(&quot;access&quot;,&quot;yes&quot;)
            self.write(&quot;七天内可再次访问&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;加密cookies&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;cookies&lt;/code&gt;是明文存储在了用户的浏览器中，因此可能会产生不安全的因素。&lt;/p&gt;
&lt;p&gt;　　 使用加密的&lt;code&gt;cookies&lt;/code&gt;来让用户隐私更加安全，你需要在&lt;code&gt;application&lt;/code&gt;的配置项中设定一个加密的盐&lt;code&gt;cookie_secret&lt;/code&gt;，然后使用下面的两个方法进行加密&lt;code&gt;cookies&lt;/code&gt;的操作：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self.get_secure_cookie()&lt;/td&gt;
&lt;td&gt;获取cookie键值对，并对其进行解密&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;self.set_secure_cookie()&lt;/td&gt;
&lt;td&gt;设置cookie键值对，将其与cookie_secret进行结合加密&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 简单示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class APIHandler(tornado.web.RequestHandler):
    def get(self):
        if self.get_secure_cookie(&quot;access&quot;):
            self.write(&quot;你来访问过了&quot;)
        else:
            self.set_secure_cookie(&quot;access&quot;, &quot;yes&quot;)
            self.write(&quot;七天内可再次访问&quot;)


settings = {
    &quot;debug&quot;: True,
    &quot;template_path&quot;: &quot;views&quot;,  # 指定模板目录
    &quot;static_path&quot;: &quot;static&quot;,  # 指定静态文件目录
    &quot;cookie_secret&quot;: &quot;0dsa0D9d0a%39433**das9))|ddsa&quot;,  # cookie加密的盐
}

application = tornado.web.Application([
    tornado.web.url(r'/api', APIHandler),
], **settings)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;用户认证&lt;/h2&gt;
&lt;p&gt;　　 当前已经认证的用户信息被保存在每一个请求处理器的 &lt;code&gt;self.current_user&lt;/code&gt; 当中， 同时在模板的 &lt;code&gt;current_user&lt;/code&gt; 中也是。默认情况下，&lt;code&gt;current_user&lt;/code&gt; 为 &lt;code&gt;None&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　 要在应用程序实现用户认证的功能，你需要复写请求处理中 &lt;code&gt;get_current_user()&lt;/code&gt; 这 个方法，在其中判定当前用户的状态，比如通过 &lt;code&gt;cookie&lt;/code&gt;。下面的例子让用户简单地使用一个 &lt;code&gt;nickname&lt;/code&gt;登陆应用，该登陆信息将被保存到 &lt;code&gt;cookie&lt;/code&gt;中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class BaseHandler(tornado.web.RequestHandler):
    def get_current_user(self):
        return self.get_secure_cookie(&quot;user&quot;)

class MainHandler(BaseHandler):
    def get(self):
        if not self.current_user:
            self.redirect(&quot;/login&quot;)
            return
        name = tornado.escape.xhtml_escape(self.current_user)
        self.write(&quot;Hello, &quot; + name)

class LoginHandler(BaseHandler):
    def get(self):
        self.write('&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;form action=&quot;/login&quot; method=&quot;post&quot;&amp;gt;'
                   'Name: &amp;lt;input type=&quot;text&quot; name=&quot;name&quot;&amp;gt;'
                   '&amp;lt;input type=&quot;submit&quot; value=&quot;Sign in&quot;&amp;gt;'
                   '&amp;lt;/form&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;')

    def post(self):
        self.set_secure_cookie(&quot;user&quot;, self.get_argument(&quot;name&quot;))
        self.redirect(&quot;/&quot;)

application = tornado.web.Application([
    (r&quot;/&quot;, MainHandler),
    (r&quot;/login&quot;, LoginHandler),
], cookie_secret=&quot;61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o/Vo=&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 对于那些必须要求用户登陆的操作，可以使用装饰器 &lt;code&gt;tornado.web.authenticated&lt;/code&gt;。 如果一个方法套上了这个装饰器，但是当前用户并没有登陆的话，页面会被重定向到 &lt;code&gt;login_url&lt;/code&gt;（应用配置中的一个选项），上面的例子可以被改写成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class MainHandler(BaseHandler):
    @tornado.web.authenticated
    def get(self):
        name = tornado.escape.xhtml_escape(self.current_user)
        self.write(&quot;Hello, &quot; + name)

settings = {
    &quot;cookie_secret&quot;: &quot;61oETzKXQAGaYdkL5gEmGeJJFuYh7EQnp2XdTP1o/Vo=&quot;,
    &quot;login_url&quot;: &quot;/login&quot;,
}
application = tornado.web.Application([
    (r&quot;/&quot;, MainHandler),
    (r&quot;/login&quot;, LoginHandler),
], **settings)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如果你使用 &lt;code&gt;authenticated&lt;/code&gt; 装饰器来装饰 &lt;code&gt;post()&lt;/code&gt; 方法，那么在用户没有登陆的状态下， 服务器会返回 403 错误。&lt;/p&gt;
&lt;p&gt;　　&lt;code&gt;Tornado&lt;/code&gt;内部集成了对第三方认证形式的支持，比如&lt;code&gt;Google&lt;/code&gt;的&lt;code&gt;OAuth&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;　　 参阅 &lt;a href=&quot;http://github.com/facebook/tornado/blob/master/tornado/auth.py&quot;&gt;&lt;code&gt;auth&lt;/code&gt; 模块&lt;/a&gt; 的代码文档以了解更多信息。 for more details. Check&lt;code&gt;auth&lt;/code&gt; 模块以了解更多的细节。在&lt;code&gt;Tornado&lt;/code&gt;的源码中有一个 &lt;code&gt;Blog&lt;/code&gt;的例子，你也可以从那里看到 用户认证的方法（以及如何在 MySQL 数据库中保存用户数据）。&lt;/p&gt;
&lt;h2&gt;内部原理&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;的&lt;code&gt;cookies&lt;/code&gt;操作相关原理非常简单，以加密&lt;code&gt;cookies&lt;/code&gt;为例：&lt;/p&gt;
&lt;p&gt;　　 写&lt;code&gt;cookie&lt;/code&gt;过程：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;　　 将值进行base64加密&lt;/p&gt;
&lt;p&gt;　　 对除值以外的内容进行签名，哈希算法（无法逆向解析）&lt;/p&gt;
&lt;p&gt;　　 拼接 签名 + 加密值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 读&lt;code&gt;cookie&lt;/code&gt;过程：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;　　读取 签名 + 加密值&lt;/p&gt;
&lt;p&gt;　　对签名进行验证&lt;/p&gt;
&lt;p&gt;　　base64解密，获取值内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;基本介绍&lt;/h2&gt;
&lt;p&gt;　　 跨域请求伪造被称为&lt;code&gt;CSRF&lt;/code&gt;或者是&lt;code&gt;XSRF&lt;/code&gt;（&lt;code&gt;Django&lt;/code&gt;中称其为&lt;code&gt;CSRF&lt;/code&gt;，&lt;code&gt;tornado&lt;/code&gt;中称其为&lt;code&gt;XSRF&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;　　 &lt;a href=&quot;https://www.cnblogs.com/Yunya-Cnblogs/p/13711629.html&quot;&gt;Django中间件与CSRF跨域请求伪造&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　 如何防止跨域请求伪造就是对该站发出的网页添加上一个随机字符串（随机的&lt;code&gt;cookie&lt;/code&gt;），所有的向本网站后端提交的&lt;code&gt;POST/PUT/PATCH/DELETE&lt;/code&gt;请求都需要带上这一随机字符串，如果随机字符串不是本网站后端发出或者压根没有，就认为该次提交是一个伪造的请求。&lt;/p&gt;
&lt;p&gt;　　 验证时&lt;code&gt;tornado&lt;/code&gt;会检查这两个点，满足任意一个点即可：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;请求头中有没有X-XSRFToken的请求头，如果有就检查值&lt;/li&gt;
&lt;li&gt;携带的参数中，有没有_xsrf命名的键值对，如果有就检查值&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;中如何开启跨域请求伪造呢？只需要在&lt;code&gt;application&lt;/code&gt;的配置项中打开即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;settings = {
    &quot;xsrf_cookies&quot;: True,
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如果提交数据时没有携带这个&lt;code&gt;xsrf_cookies&lt;/code&gt;，就会提示异常：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210120154712426.png&quot; alt=&quot;image-20210120154712426&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;form表单提交&lt;/h2&gt;
&lt;p&gt;　　 如果是&lt;code&gt;form&lt;/code&gt;表单提交，只需要在表单中添加&lt;code&gt;{{ xsrf_form_html() }}&lt;/code&gt;即可，这样会满足第二种检查机制：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;form action=&quot;/api&quot; method=&quot;post&quot;&amp;gt;
        {% raw xsrf_form_html() %}
        &amp;lt;p&amp;gt;&amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;p&amp;gt;&amp;lt;button type=&quot;submit&quot;&amp;gt;提交&amp;lt;/button&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;/form&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 它其实是会返回给你一个&lt;code&gt;hidden&lt;/code&gt;的&lt;code&gt;input&lt;/code&gt;，在表单提交的时候也一起发送了过去：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;input type=&quot;hidden&quot; name=&quot;_xsrf&quot; value=&quot;2|5a04ca78|fe6c8cdc75a4b2e304a9b2e3da98c7a4|1611128917&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 表单发送数据时的参数数据是会进行&lt;code&gt;url&lt;/code&gt;编码的，所以它的编码格式就会变成下面这个样子，而&lt;code&gt;tornado&lt;/code&gt;就检查有没有&lt;code&gt;_xsrf&lt;/code&gt;这个键值对以及值是否正确：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;usernmae=xxx&amp;amp;_xsrf=xxx
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;AJAX请求提交&lt;/h2&gt;
&lt;p&gt;　　 如果是&lt;code&gt;AJAX&lt;/code&gt;异步提交&lt;code&gt;POST/PUT/PATCH/DELETE&lt;/code&gt;请求，则你需要在提交数据的请求头中添加&lt;code&gt;X-XSRFToken&lt;/code&gt;的一组键值对，这样会满足第一种检查机制：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{% block main %}
&amp;lt;form id=&quot;form&quot;&amp;gt;
    &amp;lt;p&amp;gt;&amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;&amp;lt;/p&amp;gt;
    &amp;lt;p&amp;gt;
        &amp;lt;button type=&quot;button&quot;&amp;gt;提交&amp;lt;/button&amp;gt;
    &amp;lt;/p&amp;gt;
&amp;lt;/form&amp;gt;
{% end %}

{% block js %}
&amp;lt;script src=&quot;https://code.jquery.com/jquery-3.1.1.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    // step01:定义获取_xsrf值的函数
    function getCookie(name) {
        var r = document.cookie.match(&quot;\\b&quot; + name + &quot;=([^;]*)\\b&quot;);
        return r ? r[1] : undefined;
    }
    // step02:进行赋值
    let xsrf = getCookie(&quot;_xsrf&quot;)

    // step03:在请求头中设置X-XSRFToken的请求头
    $(&quot;button&quot;).on(&quot;click&quot;, function () {
        $.ajax({
            type: &quot;post&quot;,
            url:&quot;/api&quot;,
            headers: {&quot;X-XSRFToken&quot;: xsrf},
            data: $(&quot;#form&quot;).serialize(),
            dataType: &quot;text&quot;,
            success: ((res) =&amp;gt; {
                console.log(res)
            })
        })
    })


&amp;lt;/script&amp;gt;

{% end %}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 或者你也可以按照第二种检查机制来做，&lt;code&gt;$.(form).serialize()&lt;/code&gt;实际上会将数据进行&lt;code&gt;url&lt;/code&gt;编码，你需要添加后面的&lt;code&gt;_xsrf&lt;/code&gt;与其对应值即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// step01:获取_xsrf的值
    function getCookie(name) {
        var r = document.cookie.match(&quot;\\b&quot; + name + &quot;=([^;]*)\\b&quot;);
        return r ? r[1] : undefined;
    }

// step02:在提交的数据中添加_xsrf与其值
    $(&quot;button&quot;).on(&quot;click&quot;, function () {
        $.ajax({
            type: &quot;post&quot;,
            url:&quot;/api&quot;,
            // url编码中，&amp;amp;代表与，你可以理解为分割符，后面就是一组新的键值对
            data: $(&quot;#form&quot;).serialize() + `&amp;amp;_xsrf=${getCookie('_xsrf')}`,
            dataType: &quot;text&quot;,
            success: ((res) =&amp;gt; {
                console.log(res)
            })
        })
    })

&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;基本概念&lt;/h2&gt;
&lt;p&gt;　　 在&lt;code&gt;tornado&lt;/code&gt;中，异步非阻塞是其代言词。&lt;/p&gt;
&lt;p&gt;　　 我们知道&lt;code&gt;tornado&lt;/code&gt;处理一次&lt;code&gt;HTTP&lt;/code&gt;请求是以单线程加&lt;code&gt;I/O&lt;/code&gt;多路复用的&lt;code&gt;epoll&lt;/code&gt;模式实现的，所以在一次&lt;code&gt;HTTP&lt;/code&gt;请求中，你可以发现&lt;code&gt;Tornado&lt;/code&gt;的控制器处理函数里并没有&lt;code&gt;return&lt;/code&gt;响应的写法（当然你也可以手动进行&lt;code&gt;return None&lt;/code&gt;），它内部会自己进行&lt;code&gt;return&lt;/code&gt;响应，这是一个非常关键的点，用下面这张图进行一下说明，如何实现异步非阻塞（其实还是有一些问题的）：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210127231705066.png&quot; alt=&quot;image-20210127231705066&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;tornado.gen.coroutine&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;tornado.gen.coroutine&lt;/code&gt;协程模式装饰器，使用&lt;code&gt;yield&lt;/code&gt;关键字来将任务包装成协程任务。&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;　　 1.这种方式一定要确保协程任务中不存在同步方法&lt;/p&gt;
&lt;p&gt;　　 2.如果控制器函数没有进行gen.coroutine装饰器进行修饰，单纯使用yield时将不会具有非阻塞的效果&lt;/p&gt;
&lt;p&gt;　　 3.究其内部原因，yield的一个控制器处理函数头顶上如果具有gen.coroutine装饰器，则内部会创建Future对象用于实现非阻塞，如果不具有gen.coroutine则不会创建Future对象&lt;/p&gt;
&lt;p&gt;　　 4.一言以蔽之，tornado.gen.coroutine必须与yield同时出现&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　 如下所示，使用&lt;code&gt;request&lt;/code&gt;同步库对谷歌发起请求（不可能成功返回），将产生阻塞：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web
from tornado import gen
import requests

class Api1Handler(tornado.web.RequestHandler):
    # 通过async和await进行异步网络请求

    @gen.coroutine
    def get(self):
        result = yield self.callback()
        self.write(result)

    def callback(self):
        response = requests.request(method=&quot;GET&quot;,url=&quot;http://www.google.com&quot;)
        response_text = response.text
        return response_text

class Api2Handler(tornado.web.RequestHandler):
    def get(self):
        self.write(&quot;api2&quot;)


application = tornado.web.Application([
    (r&quot;/api1&quot;, Api1Handler),
    (r&quot;/api2&quot;, Api2Handler),
])

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如果采用异步网络库&lt;code&gt;aiohttp&lt;/code&gt;，就不会出现这样的问题了，其还是异步调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  @gen.coroutine
    def get(self):
        response_text = yield self.callback()
        self.write(response_text)

    async def callback(self):
        async with aiohttp.ClientSession() as session:
            async with await session.get(&quot;http://www.google.com&quot;) as response:
                response_text = await response.text()
        return response_text
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;async await&lt;/h2&gt;
&lt;p&gt;　　 新版的&lt;code&gt;tornado&lt;/code&gt;全面依赖于&lt;code&gt;asyncio&lt;/code&gt;模块，所以我们只需要使用&lt;code&gt;async&lt;/code&gt;与&lt;code&gt;await&lt;/code&gt;即可开启异步编程。&lt;/p&gt;
&lt;p&gt;　　 按照第一个协程模式装饰器的示例，其实我们可以对其进行简写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web
import aiohttp

class Api1Handler(tornado.web.RequestHandler):
    # 通过async和await进行异步网络请求，如果替换成http://www.google.com
    # 这依旧不影响api2的访问
    async def get(self):
        async with aiohttp.ClientSession() as session:
            async with await session.get(&quot;http://www.cnblogs.com&quot;) as response:
                result = await response.text()
                self.write(result)

class Api2Handler(tornado.web.RequestHandler):
    def get(self):
        self.write(&quot;api2&quot;)


application = tornado.web.Application([
    (r&quot;/api1&quot;, Api1Handler),
    (r&quot;/api2&quot;, Api2Handler),
])

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;tornado.web.asynchronous&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;tornado.web.asynchronous&lt;/code&gt;装饰器，将本次&lt;code&gt;HTTP&lt;/code&gt;请求转变为长连接的方式。&lt;/p&gt;
&lt;p&gt;　　 如果要断开本次长连接，则必须使用&lt;code&gt;self.finish()&lt;/code&gt;方法：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　经测试、6.0版本已移除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web


class Api1Handler(tornado.web.RequestHandler):
    @tornado.web.asynchronous  # step01:添加该装饰器，本次HTTP请求将变为长连接状态
    def get(self):
        with open(file=&quot;testDocument.text&quot;, mode=&quot;rb&quot;) as f:
            file_context = f.read()
        self.write(file_context)
        self.finish()  # 手动结束本次长连接


class Api2Handler(tornado.web.RequestHandler):
    def get(self):
        self.write(&quot;api2&quot;)


application = tornado.web.Application([
    (r&quot;/api1&quot;, Api1Handler),
    (r&quot;/api2&quot;, Api2Handler),
])

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;HttpClient库&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;的协程任务中必须是异步方法，因此&lt;code&gt;tornado&lt;/code&gt;内置一些异步组件。&lt;/p&gt;
&lt;p&gt;　　 比如自带的异步发送网络请求的&lt;code&gt;HttpClient&lt;/code&gt;库。&lt;/p&gt;
&lt;p&gt;　　 另外还有一些第三方的异步模块，如&lt;code&gt;tornado-mysql&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;　　 &lt;a href=&quot;https://www.osgeo.cn/tornado/httpclient.html&quot;&gt;tornadoHttpClient官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　 以下是基本使用方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web
import tornado.gen
from tornado import httpclient

class Api1Handler(tornado.web.RequestHandler):
    @tornado.gen.coroutine
    def get(self):
       client = httpclient.AsyncHTTPClient()
       response = yield client.fetch(&quot;http://www.cnblogs.com&quot;)
       self.write(response.body)


application = tornado.web.Application([
    (r&quot;/api1&quot;, Api1Handler),
])

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 如果&lt;code&gt;tornado&lt;/code&gt;是新版，则也可以使用下面的方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Api1Handler(tornado.web.RequestHandler):
    # 新版：6.01测试通过
    async def get(self):
        client = httpclient.AsyncHTTPClient()
        try:
            response = await client.fetch(&quot;http://www.cnblogs.com&quot;)
        except Exception as e:
            print(e)
        else:
            self.write(response.body)
&lt;/code&gt;
&lt;/pre&gt;


&lt;h2&gt;基础介绍&lt;/h2&gt;
&lt;p&gt;　　 我们都知道，&lt;code&gt;HTTP/WebSocket&lt;/code&gt;都属于应用层的协议，其本身是对&lt;code&gt;TCP&lt;/code&gt;协议的封装。&lt;/p&gt;
&lt;p&gt;　　 那么&lt;code&gt;WebSocket&lt;/code&gt;对于&lt;code&gt;HTTP&lt;/code&gt;协议来说有什么不同呢？首先要从&lt;code&gt;HTTP&lt;/code&gt;协议特性入手。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;　　HTTP协议是一种单主动协议，即只能由Browser端主动发送请求，而Server端只能被动回应Browser端的请求，无法主动向Browser端发送请求&lt;/p&gt;
&lt;p&gt;　　WebSocket则是一种双主动协议，Server端也能够主动向Browser端发送请求，该请求一般被称之为推送&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 &lt;code&gt;WebSocket&lt;/code&gt;必须要浏览器支持。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img-blog.csdnimg.cn/20200527233246458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;握手流程&lt;/h2&gt;
&lt;p&gt;　　 以下是&lt;code&gt;WebSocket&lt;/code&gt;的握手流程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1.服务端开启监听
2.客户端发送请求企图建立连接
3.服务端进行三次握手，确认连接建立
4.客户端生成一个随机字符串，在请求头中添加随机字符串，超服务器发送过去（请求头名字：Sec-WebSocket-Key）
5.服务端接收到请求，decode解码出随机字符串，通过sha1进行加密，并且把魔法字符串当盐添加进去，然后通过base64编码，将编码完成后的数据超客户端发送回去
6.客户端进行验证，将服务端返回的内容首先通过base64解码，然后进行sha1+本地随机字符串+魔法字符串进行比对，如果相同则代表websocket服务建立完成
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 魔法字符串是一个固定的值，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;258EAFA5-E914-47DA-95CA-C5AB0DC85B11
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 看&lt;code&gt;Server&lt;/code&gt;端代码，理解上面的步骤：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import socket
import base64
import hashlib
 
def get_headers(data):
    &quot;&quot;&quot;
    将请求头格式化成字典
    :param data:
    :return:
    &quot;&quot;&quot;
    header_dict = {}
    data = str(data, encoding='utf-8')
 
    for i in data.split('\r\n'):
        print(i)
    header, body = data.split('\r\n\r\n', 1)
    header_list = header.split('\r\n')
    for i in range(0, len(header_list)):
        if i == 0:
            if len(header_list[i].split(' ')) == 3:
                header_dict['method'], header_dict['url'], header_dict['protocol'] = header_list[i].split(' ')
        else:
            k, v = header_list[i].split(':', 1)
            header_dict[k] = v.strip()
    return header_dict
 
 
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock.bind(('127.0.0.1', 8002))
sock.listen(5)
 
conn, address = sock.accept()
data = conn.recv(1024)
headers = get_headers(data) # 提取请求头信息
# 对请求头中的sec-websocket-key进行加密
response_tpl = &quot;HTTP/1.1 101 Switching Protocols\r\n&quot; \
      &quot;Upgrade:websocket\r\n&quot; \
      &quot;Connection: Upgrade\r\n&quot; \
      &quot;Sec-WebSocket-Accept: %s\r\n&quot; \
      &quot;WebSocket-Location: ws://%s%s\r\n\r\n&quot;
magic_string = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
value = headers['Sec-WebSocket-Key'] + magic_string
ac = base64.b64encode(hashlib.sha1(value.encode('utf-8')).digest())
response_str = response_tpl % (ac.decode('utf-8'), headers['Host'], headers['url'])
# 响应【握手】信息
conn.send(bytes(response_str, encoding='utf-8'))
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;请求解析&lt;/h2&gt;
&lt;p&gt;　　 当一个&lt;code&gt;WebSocket&lt;/code&gt;请求到来时，接收到请求的一方（server/browser）要对他的数据进行解析，如何进行数据解析是一个非常有趣的话题。&lt;/p&gt;
&lt;p&gt;　　 首先，一个&lt;code&gt;WebSocket&lt;/code&gt;的数据帧会大体上分为三部分，（头部、&lt;code&gt;MASK&lt;/code&gt;、数据体），我们要研究的是如何区分这三部分。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img-blog.csdnimg.cn/20200527233345809.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xMODQ1ODc2NDI1,size_16,color_FFFFFF,t_70&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;　　 1.将接收到的数据第1个字节进行提取，并且与b00001111做&amp;amp;运算（与），得到一个数值。&lt;/p&gt;
&lt;p&gt;　　 2.如果该数值等于126，则头部信息占2个字节（第2字节和第3字节），MASK数据则是第4字节至第7字节，从第8字节开始均为数据体部分。&lt;/p&gt;
&lt;p&gt;　　 3.如果该数值等于127，则头部信息占8个字节（第2字节至第9字节），MASK数据则是第10字节至第13字节，从第14字节开始均为数据体部分。&lt;/p&gt;
&lt;p&gt;　　 4.如果该数值等于125，则无头部信息，Mask数据是第2字节至第5字节，从第6字节开始均为数据体部分。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;　　 而对数据体进行解析时，则会用到&lt;code&gt;^&lt;/code&gt;异或运算。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;　　^ 按位异或运算符：当两对应的二进位相异时，结果为1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　 简单的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a = 0011 1100

b = 0000 1101

a^b = 0011 0001
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 下面是官网中提供的&lt;code&gt;Js&lt;/code&gt;解析数据体示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var DECODED = &quot;&quot;;
for (var i = 0; i &amp;lt; ENCODED.length; i++) {
    DECODED[i] = ENCODED[i] ^ MASK[i % 4];
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 用&lt;code&gt;Python&lt;/code&gt;代码进行实现 （&lt;code&gt;Broswer&lt;/code&gt;端已自动做好，但是如果我们手动写服务端，这些逻辑都需要自己搞明白）：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;info = conn.recv(8096)  # 读取数据

        # step01:提取第一个字节的数据，与00001111（十进制127）进行与运算
    payload_len = info[1] &amp;amp; 127
    
    # step02：解析头部、MASK部、体部信息
    if payload_len == 126:
        extend_payload_len = info[2:4]
        mask = info[4:8]
        decoded = info[8:]
    elif payload_len == 127:
        extend_payload_len = info[2:10]
        mask = info[10:14]
        decoded = info[14:]
    else:
        extend_payload_len = None
        mask = info[2:6]
        decoded = info[6:]
        
        # step03：读取数据体信息（官网示例）
    bytes_list = bytearray()
    for i in range(len(decoded)):
    
        # 核心代码，数据体解析，异或运算
        chunk = decoded[i] ^ mask[i % 4]
        bytes_list.append(chunk)
        
    body = str(bytes_list, encoding='utf-8')
    print(body)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 其他的一些知识点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FIN：1bit
Websocket不可一次接收过长的消息。所以用FIN来区分是否分片接收一条长消息。
如果是1代表这是单条消息，没有后续分片了。而如果是0代表，代表此数据帧是不是一个完整的消息，而是一个消息的分片，并且不是最后一个分片后面还有其他分片

RSV1, RSV2, RSV3: 1 bit each
必须是0，除非客户端和服务端使用WS扩展时，可以为非0。

Opcode: 4bit
这个为操作码，表示对后面的有效数据荷载的具体操作，如果未知接收端需要断开连接

％x0：表示连续帧

％x1：表示文本帧

％x2：表示二进制帧

％x3-7：保留用于其他非控制帧

％x8：表示连接关闭

％x9：表示ping操作

％xA：表示pong操作

％xB-F：保留用于其他控制帧

Mask: 1bit
是否进行过掩码，比如客户端给服务端发送消息，需要进行掩码操作。而服务端到客户端不需要

Payload Length: 7 bits, 7+16 bits, or 7+64 bits（上面已经写过了）
“有效载荷数据”的长度（以字节为单位）：如果为0-125，则为有效载荷长度。 如果为126，则以下2个字节解释为16位无符号整数是有效载荷长度。 如果是127，以下8个字节解释为64位无符号整数（最高有效位必须为0）是有效载荷长度。 多字节长度数量以网络字节顺序表示。 注意在所有情况下，必须使用最小字节数进行编码长度，例如124字节长的字符串的长度不能编码为序列126、0、124。有效载荷长度是“扩展数据”的长度+“应用程序数据”。 “扩展数据”的长度可以是零，在这种情况下，有效负载长度是 “应用程序数据”。

Masking-key: 0 or 4 bytes (32bit)
所有从客户端传送到服务端的数据帧，数据载荷都进行了掩码操作，Mask为1，且携带了4字节的Masking-key。如果Mask为0，则没有Masking-key。

Payload data: (x+y) bytes
“有效载荷数据”定义为串联的“Extension data”与“Application data”。

Extension data: x bytes
如果没有协商使用扩展的话，扩展数据数据为0字节。所有的扩展都必须声明扩展数据的长度，或者可以如何计算出扩展数据的长度。此外，扩展如何使用必须在握手阶段就协商好。如果扩展数据存在，那么载荷数据长度必须将扩展数据的长度包含在内。

Application data: y bytes
任意的应用数据，在扩展数据之后（如果存在扩展数据），占据了数据帧剩余的位置。载荷数据长度 减去 扩展数据长度，就得到应用数据的长度。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;请求发送&lt;/h2&gt;
&lt;p&gt;　　 当发送一个请求时，我们需要对数据进行封装。&lt;/p&gt;
&lt;p&gt;　　 以下是&lt;code&gt;WebSocket&lt;/code&gt;协议规定：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def send_msg(conn, msg_bytes):
    
    import struct 

    token = b&quot;\x81&quot;  # 协议规定，第一个字节必须是x81
    length = len(msg_bytes)
    # 判断长度
    if length &amp;lt; 126:
        token += struct.pack(&quot;B&quot;, length)
    elif length &amp;lt;= 0xFFFF:
        token += struct.pack(&quot;!BH&quot;, 126, length)
    else:
        token += struct.pack(&quot;!BQ&quot;, 127, length)

    msg = token + msg_bytes
    
    conn.send(msg)
    
    return True
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;js演示&lt;/h2&gt;
&lt;p&gt;　　 在&lt;code&gt;JavaScript&lt;/code&gt;中，启用&lt;code&gt;WebSocket&lt;/code&gt;非常简单，并且它已经将数据解析、数据发送都做好了。&lt;/p&gt;
&lt;p&gt;　　 直接用即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var ws = new WebSocket('ws://localhost:8080');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 &lt;code&gt;webSocket.readyState&lt;/code&gt;用于查看当前的连接状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;switch (ws.readyState) {
  case WebSocket.CONNECTING: 
    // do something  值是0，未连接
    break;
  case WebSocket.OPEN:
    // do something  值为1，表示连接成功，可以通信了。
    break;
  case WebSocket.CLOSING:
    // do something  值为2，表示连接正在关闭。
    break;
  case WebSocket.CLOSED:
    // do something  值为3，表示连接已经关闭，或者打开连接失败。
    break;
  default:
    // this never happens
    break;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 回调函数系列：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;函数名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;onopen&lt;/td&gt;
&lt;td&gt;用于指定连接成功后的回调函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;onclose&lt;/td&gt;
&lt;td&gt;用于指定连接关闭后的回调函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;onmessage&lt;/td&gt;
&lt;td&gt;用于指定收到服务器数据后的回调函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;onerror&lt;/td&gt;
&lt;td&gt;用于指定报错时的回调函数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 两个基本方法：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法名称&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;send()&lt;/td&gt;
&lt;td&gt;用于向服务器发送数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;close()&lt;/td&gt;
&lt;td&gt;关闭连接&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　 基本演示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var ws = new WebSocket(&quot;ws://localhost:8080&quot;); 
//申请一个WebSocket对象，参数是服务端地址，同http协议使用http://开头一样，WebSocket协议的url使用ws://开头，另外安全的
WebSocket协议使用wss://开头

ws.onopen = function(){
　　//当WebSocket创建成功时，触发onopen事件
   console.log(&quot;open&quot;);
　　ws.send(&quot;hello&quot;); //将消息发送到服务端
}

ws.onmessage = function(e){
　　//当客户端收到服务端发来的消息时，触发onmessage事件，参数e.data包含server传递过来的数据
　　console.log(e.data);
}

ws.onclose = function(e){
　　//当客户端收到服务端发送的关闭连接请求时，触发onclose事件
　　console.log(&quot;close&quot;);
}

ws.onerror = function(e){
　　//如果出现连接、处理、接收、发送数据失败的时候触发onerror事件
　　console.log(error);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　&lt;code&gt;onmessage&lt;/code&gt;回调函数之接收二进制数据或字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ws.onmessage = function(event){
  if(typeOf event.data === String) {  // 字符串
    console.log(&quot;Received data string&quot;);
  }

  if(event.data instanceof ArrayBuffer){  // 二进制
    var buffer = event.data;
    console.log(&quot;Received arraybuffer&quot;);
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 &lt;code&gt;send()&lt;/code&gt;方法之发送文本、发送文件、发送二进制数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 发送文本
ws.send('your message');

// 发送文件
var file = document
  .querySelector('input[type=&quot;file&quot;]')
  .files[0];
ws.send(file);

// ArrayBuffer 二进制数据

// Sending canvas ImageData as ArrayBuffer
var img = canvas_context.getImageData(0, 0, 400, 320);
var binary = new Uint8Array(img.data.length);
for (var i = 0; i &amp;lt; img.data.length; i++) {
  binary[i] = img.data[i];
}
ws.send(binary.buffer);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;socket服务端&lt;/h2&gt;
&lt;p&gt;　　 手动用&lt;code&gt;socket&lt;/code&gt;实现&lt;code&gt;websocket&lt;/code&gt;服务端：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
import socket
import base64
import hashlib
 
 
def get_headers(data):
    &quot;&quot;&quot;
    将请求头格式化成字典
    :param data:
    :return:
    &quot;&quot;&quot;
    header_dict = {}
    data = str(data, encoding='utf-8')
 
    header, body = data.split('\r\n\r\n', 1)
    header_list = header.split('\r\n')
    for i in range(0, len(header_list)):
        if i == 0:
            if len(header_list[i].split(' ')) == 3:
                header_dict['method'], header_dict['url'], header_dict['protocol'] = header_list[i].split(' ')
        else:
            k, v = header_list[i].split(':', 1)
            header_dict[k] = v.strip()
    return header_dict
 
 
def send_msg(conn, msg_bytes):
    &quot;&quot;&quot;
    WebSocket服务端向客户端发送消息
    :param conn: 客户端连接到服务器端的socket对象,即： conn,address = socket.accept()
    :param msg_bytes: 向客户端发送的字节
    :return:
    &quot;&quot;&quot;
    import struct
 
    token = b&quot;\x81&quot;
    length = len(msg_bytes)
    if length &amp;lt; 126:
        token += struct.pack(&quot;B&quot;, length)
    elif length &amp;lt;= 0xFFFF:
        token += struct.pack(&quot;!BH&quot;, 126, length)
    else:
        token += struct.pack(&quot;!BQ&quot;, 127, length)
 
    msg = token + msg_bytes
    conn.send(msg)
    return True
 
 
def run():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind(('127.0.0.1', 8003))
    sock.listen(5)
 
    conn, address = sock.accept()
    data = conn.recv(1024)
    headers = get_headers(data)
    response_tpl = &quot;HTTP/1.1 101 Switching Protocols\r\n&quot; \
                   &quot;Upgrade:websocket\r\n&quot; \
                   &quot;Connection:Upgrade\r\n&quot; \
                   &quot;Sec-WebSocket-Accept:%s\r\n&quot; \
                   &quot;WebSocket-Location:ws://%s%s\r\n\r\n&quot;
 
    value = headers['Sec-WebSocket-Key'] + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'
    ac = base64.b64encode(hashlib.sha1(value.encode('utf-8')).digest())
    response_str = response_tpl % (ac.decode('utf-8'), headers['Host'], headers['url'])
    conn.send(bytes(response_str, encoding='utf-8'))
 
    while True:
        try:
            info = conn.recv(8096)
        except Exception as e:
            info = None
        if not info:
            break
        payload_len = info[1] &amp;amp; 127
        if payload_len == 126:
            extend_payload_len = info[2:4]
            mask = info[4:8]
            decoded = info[8:]
        elif payload_len == 127:
            extend_payload_len = info[2:10]
            mask = info[10:14]
            decoded = info[14:]
        else:
            extend_payload_len = None
            mask = info[2:6]
            decoded = info[6:]
 
        bytes_list = bytearray()
        for i in range(len(decoded)):
            chunk = decoded[i] ^ mask[i % 4]
            bytes_list.append(chunk)
        body = str(bytes_list, encoding='utf-8')
        send_msg(conn,body.encode('utf-8'))
 
    sock.close()
 
if __name__ == '__main__':
    run()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;tornado示例&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;服务端：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web
import tornado.websocket


class WsHandler(tornado.websocket.WebSocketHandler):
    # 该类继承RequestHandler类
    def open(self):
        &quot;&quot;&quot;
        连接成功后、自动执行
        :return:
        &quot;&quot;&quot;
        # 超客户端发送信息
        self.write_message(&quot;连接成功&quot;)

    def on_message(self, message):
        &quot;&quot;&quot;
        客户端发送消息时，自动执行
        :return:
        &quot;&quot;&quot;
        print(message)

    def on_close(self):
        &quot;&quot;&quot;
        客户端关闭连接时，，自动执行
        :return:
        &quot;&quot;&quot;
        print(&quot;连接已关闭&quot;)


class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.render(&quot;index.html&quot;)


settings = {
    &quot;template_path&quot;: &quot;views&quot;,
}

application = tornado.web.Application([
    (r&quot;/ws/&quot;, WsHandler),
    (r&quot;/index/&quot;, IndexHandler),
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 模板文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;script&amp;gt;
    let ws = new WebSocket(&quot;ws://127.0.0.1:8888/ws/&quot;);
    ws.onmessage = Event=&amp;gt;{
        console.log(Event.data);
        ws.send(&quot;你好&quot;);
        ws.close();
    }
    
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;tornado聊天室&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;本身支持&lt;code&gt;WebSocket&lt;/code&gt;，（&lt;code&gt;Django&amp;amp;Flask&lt;/code&gt;原生不支持）。&lt;/p&gt;
&lt;p&gt;　　 利用&lt;code&gt;WebSocket&lt;/code&gt;，构建网络聊天室：&lt;/p&gt;
&lt;p&gt;　　 后端代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-
import uuid
import json
import tornado.ioloop
import tornado.web
import tornado.websocket


class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        self.render('index.html')


class ChatHandler(tornado.websocket.WebSocketHandler):
    # 用户存储当前聊天室用户
    waiters = set()
    # 用于存储历时消息
    messages = []

    def open(self):
        &quot;&quot;&quot;
        客户端连接成功时，自动执行，加载聊天记录
        :return: 
        &quot;&quot;&quot;
        ChatHandler.waiters.add(self)
        uid = str(uuid.uuid4())
        self.write_message(uid)

        for msg in ChatHandler.messages:
            self.write_message(msg)

    def on_message(self, message):
        &quot;&quot;&quot;
        客户端连发送消息时，自动执行，群转发消息
        :param message: 
        :return: 
        &quot;&quot;&quot;
        msg = message
        ChatHandler.messages.append(msg)
        for client in ChatHandler.waiters:
            client.write_message(msg)

    def on_close(self):
        &quot;&quot;&quot;
        客户端关闭连接时，，自动执行
        :return: 
        &quot;&quot;&quot;
        ChatHandler.waiters.remove(self)


def run():
    settings = {
        'template_path': 'views',
        'static_path': 'static',
    }
    application = tornado.web.Application([
        (r&quot;/&quot;, IndexHandler),
        (r&quot;/chat&quot;, ChatHandler),
    ], **settings)
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()


if __name__ == &quot;__main__&quot;:
    run()

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 模板：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Python聊天室&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;div&amp;gt;
    &amp;lt;input type=&quot;text&quot; id=&quot;txt&quot;&amp;gt;
    &amp;lt;input type=&quot;button&quot; id=&quot;btn&quot; value=&quot;提交&quot; onclick=&quot;sendMsg();&quot;/&amp;gt;
    &amp;lt;input type=&quot;button&quot; id=&quot;close&quot; value=&quot;关闭连接&quot; onclick=&quot;closeConn();&quot;/&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;div id=&quot;container&quot; style=&quot;border: 1px solid #dddddd;margin: 20px;min-height: 500px;&quot;&amp;gt;

&amp;lt;/div&amp;gt;

&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;

    window.onload = () =&amp;gt; {
        wsUpdater.start();
    }

    var wsUpdater = {
        socket: null,
        uid: null,
        start: function () {
            var url = &quot;ws://127.0.0.1:8888/chat&quot;;
            wsUpdater.socket = new WebSocket(url);
            wsUpdater.socket.onmessage = function (event) {
                if (wsUpdater.uid) {
                    // 解析信息
                    wsUpdater.showMessage(event.data);
                } else {
                    // 第一次，获取uid
                    wsUpdater.uid = event.data;
                }
            }
        },
        showMessage: function (content) {
            content = JSON.parse(content);
            let article = document.createElement(&quot;article&quot;);
            let p_name = document.createElement(&quot;p&quot;);
            let p_context = document.createElement(&quot;p&quot;)

            article.append(p_name);
            article.append(p_context);
            p_name.append(`${content.uid}`)
            p_name.style.textIndent = &quot;2rem&quot;;
            p_context.append(`${content.message}`)
            p_context.style.textIndent = &quot;2rem&quot;;

            document.querySelector(&quot;#container&quot;).append(article);
        }
    };

    function sendMsg() {
        var msg = {
            uid: wsUpdater.uid,
            message: document.querySelector(&quot;#txt&quot;).value,
        };
        wsUpdater.socket.send(JSON.stringify(msg));
    }

&amp;lt;/script&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;

&lt;h2&gt;自定义Session&lt;/h2&gt;
&lt;p&gt;　　 &lt;code&gt;Session&lt;/code&gt;是将用户存储的信息保存在服务器上，然后发送给用户一段随机字符串。&lt;/p&gt;
&lt;p&gt;　　 当用户下次来时如果带有该随机字符串，则能获取到保存的信息（代表已登录），否则就获取不到保存的信息（代表未登录）。&lt;/p&gt;
&lt;p&gt;　　 其实本质还是对&lt;code&gt;cookie&lt;/code&gt;的一次升级操作。&lt;/p&gt;
&lt;p&gt;　　 原生&lt;code&gt;tronado&lt;/code&gt;中未提供&lt;code&gt;Seesion&lt;/code&gt;操作，但是我们可以自己写一个：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://images-1302522496.cos.ap-nanjing.myqcloud.com/img/image-20210127220319215.png&quot; alt=&quot;image-20210127220319215&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　以下是最基础的示例，将&lt;code&gt;Session&lt;/code&gt;放置在内存中。（&lt;code&gt;Session&lt;/code&gt;存储时未进行加密，可对此做优化）&lt;/p&gt;
&lt;p&gt;　　如果想放置在&lt;code&gt;Redis&lt;/code&gt;、&lt;code&gt;File&lt;/code&gt;等地方，原理也是一样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/usr/bin/env python
# -*- coding:utf-8 -*-

import uuid

import tornado.ioloop
import tornado.web


class Session(object):
    container = {
        # 用户1-nid : {}
    }

    def __init__(self, handler):
        # 获取用户cookie，如果有，不操作，否则，给用户生成随即字符串
        # - 写给用户
        # - 保存在session
        nid = handler.get_cookie('session_id')
        if nid:
            if nid in Session.container:
                pass
            else:
                nid = str(uuid.uuid4())
                Session.container[nid] = {}
        else:
            nid = str(uuid.uuid4())
            Session.container[nid] = {}

        handler.set_cookie('session_id', nid)
        # nid当前访问用户的随即字符串
        self.nid = nid
        # 封装了所有用户请求信息
        self.handler = handler

    def __setitem__(self, key, value):
        self.set(key, value)

    def __getitem__(self, item):
        return self.get(item)

    def __delitem__(self, key):
        self.delete(key)

    def get(self, item):
        return Session.container[self.nid].get(item)

    def set(self, key, value):
        Session.container[self.nid][key] = value

    def delete(self, key):
        del Session.container[self.nid][key]


class MyHandler(tornado.web.RequestHandler):

    def initialize(self):
        self.session = Session(self)


class IndexHandler(MyHandler):
    def get(self):
        if self.session.get(&quot;access&quot;):
            self.write(&quot;你来访问过了&quot;)
        else:
            self.session.set(&quot;access&quot;, &quot;yes&quot;)
            self.write(&quot;七天内可再次访问&quot;)


settings = {
    'template_path': 'views',
    'static_path': 'statics',
}

application = tornado.web.Application([
    (r'/index', IndexHandler),
], **settings)

if __name__ == '__main__':
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;Futer探究&lt;/h2&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;　　普通同步(单线程)阻塞服务器框架原理&lt;/p&gt;
&lt;p&gt;　　通过&lt;code&gt;select&lt;/code&gt;与&lt;code&gt;socket&lt;/code&gt;我们可以开发一个微型的框架，使用&lt;code&gt;select&lt;/code&gt;实现&lt;code&gt;I/O&lt;/code&gt;多路复用监听本地服务端&lt;code&gt;socket&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;　　当有客户端发送请求时，&lt;code&gt;select&lt;/code&gt;（Linux下为&lt;code&gt;epoll&lt;/code&gt;）监听的本地&lt;code&gt;socket&lt;/code&gt;发生变化，通过&lt;code&gt;socket.accept()&lt;/code&gt;得到客户端发送来的&lt;code&gt;conn&lt;/code&gt;(也是一个socket)，并将&lt;code&gt;conn&lt;/code&gt;也添加到&lt;code&gt;select&lt;/code&gt;监听列表里。当客户端通过&lt;code&gt;conn&lt;/code&gt;发送数据时，服务端&lt;code&gt;select&lt;/code&gt;监听列表的&lt;code&gt;conn&lt;/code&gt;发生变化，我们将&lt;code&gt;conn&lt;/code&gt;发送的数据(请求数据)接收保存并处理得到&lt;code&gt;request_header&lt;/code&gt;与&lt;code&gt;request_body&lt;/code&gt;，然后可以根据&lt;code&gt;request_header&lt;/code&gt;中的&lt;code&gt;url&lt;/code&gt;来匹配本地路由中的&lt;code&gt;url&lt;/code&gt;，然后得到对应的控制器处理函数，然后将控制器处理函数的返回值(一般为字符串)通过&lt;code&gt;conn&lt;/code&gt;发送回请求客户端，然后将&lt;code&gt;conn&lt;/code&gt;关闭，并且移除&lt;code&gt;select&lt;/code&gt;监听列表中的&lt;code&gt;conn&lt;/code&gt;，这样一次网络&lt;code&gt;I/O&lt;/code&gt;请求便算结束。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;import socket
import select

class HttpRequest(object):
    &quot;&quot;&quot;
    用户封装用户请求信息
    &quot;&quot;&quot;
    def __init__(self, content):
        &quot;&quot;&quot;

        :param content:用户发送的请求数据：请求头和请求体
        &quot;&quot;&quot;
        self.content = content

        self.header_bytes = bytes()
        self.body_bytes = bytes()

        self.header_dict = {}

        self.method = &quot;&quot;
        self.url = &quot;&quot;
        self.protocol = &quot;&quot;

        self.initialize()
        self.initialize_headers()

    def initialize(self):

        temp = self.content.split(b'\r\n\r\n', 1)
        if len(temp) == 1:
            self.header_bytes += temp
        else:
            h, b = temp
            self.header_bytes += h
            self.body_bytes += b

    @property
    def header_str(self):
        return str(self.header_bytes, encoding='utf-8')

    def initialize_headers(self):
        headers = self.header_str.split('\r\n')
        first_line = headers[0].split(' ')
        if len(first_line) == 3:
            self.method, self.url, self.protocol = headers[0].split(' ')
            for line in headers:
                kv = line.split(':')
                if len(kv) == 2:
                    k, v = kv
                    self.header_dict[k] = v

# class Future(object):
#     def __init__(self):
#         self.result = None

def main(request):
    return &quot;main&quot;

def index(request):
    return &quot;indexasdfasdfasdf&quot;


routers = [
    ('/main/',main),
    ('/index/',index),
]

def run():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((&quot;127.0.0.1&quot;, 9999,))
    sock.setblocking(False)
    sock.listen(128)

    inputs = []
    inputs.append(sock)
    while True:
        rlist,wlist,elist = select.select(inputs,[],[],0.05)
        for r in rlist:
            if r == sock:
                &quot;&quot;&quot;新请求到来&quot;&quot;&quot;
                conn,addr = sock.accept()
                conn.setblocking(False)
                inputs.append(conn)
            else:
                &quot;&quot;&quot;客户端发来数据&quot;&quot;&quot;
                data = b&quot;&quot;
                while True:
                    try:
                        chunk = r.recv(1024)
                        data = data + chunk
                    except Exception as e:
                        chunk = None
                    if not chunk:
                        break
                # data进行处理：请求头和请求体
                request = HttpRequest(data)
                # 1. 请求头中获取url
                # 2. 去路由中匹配，获取指定的函数
                # 3. 执行函数，获取返回值
                # 4. 将返回值 r.sendall(b'alskdjalksdjf;asfd')
                import re
                flag = False
                func = None
                for route in routers:
                    if re.match(route[0],request.url):
                        flag = True
                        func = route[1]
                        break
                if flag:
                    result = func(request)
                    r.sendall(bytes(result,encoding='utf-8'))
                else:
                    r.sendall(b&quot;404&quot;)

                inputs.remove(r)
                r.close()

if __name__ == '__main__':
    run()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　2、&lt;code&gt;Tornado&lt;/code&gt;异步非阻塞实现原理&lt;/p&gt;
&lt;p&gt;　　 &lt;code&gt;tornado&lt;/code&gt;通过装饰器 + &lt;code&gt;Future&lt;/code&gt;从而实现异步非阻塞。在控制器处理函数中如果加上&lt;code&gt;gen.coroutine&lt;/code&gt;且进行&lt;code&gt;yield&lt;/code&gt;时，会产生一个&lt;code&gt;Future&lt;/code&gt;对象，此时控制函数的类型是一个生成器，如果是&lt;code&gt;self.write()&lt;/code&gt;等操作将会直接返回，如果是&lt;code&gt;Future&lt;/code&gt;生成器对象的话将会把返回来的&lt;code&gt;Future&lt;/code&gt;对象添加到&lt;code&gt;async_request_dict&lt;/code&gt;中，先不给客户端返回响应数据(此时可以处理其他客户端的连接请求)，等&lt;code&gt;Future&lt;/code&gt;对象的&lt;code&gt;result&lt;/code&gt;有值时再返回，还可以设置超时时间，在规定的时间过后返回响应数据。 ！！ 关键是&lt;code&gt;future&lt;/code&gt;对象，&lt;code&gt;future&lt;/code&gt;对象里有&lt;code&gt;result&lt;/code&gt;属性，默认为&lt;code&gt;None&lt;/code&gt;，当&lt;code&gt;result&lt;/code&gt;有值时再返回数据。&lt;/p&gt;
&lt;p&gt;　　 我们看一下&lt;code&gt;gen.coroutine&lt;/code&gt;装饰器的源码，注释里有句话写的很明了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   Functions with this decorator return a `.Future`.
   # 使用此函数作为装饰器将返回一个Future
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 虽然使用&lt;code&gt;gen.coroutine&lt;/code&gt;装饰器会自动生成&lt;code&gt;Future&lt;/code&gt;，但是你任然可以手动创建一个&lt;code&gt;Future&lt;/code&gt;并进行返回。&lt;/p&gt;
&lt;p&gt;　　 以下示例将展示&lt;code&gt;Future&lt;/code&gt;是依赖于&lt;code&gt;result&lt;/code&gt;，如果&lt;code&gt;result&lt;/code&gt;未设置值，则&lt;code&gt;HTTP&lt;/code&gt;请求不结束。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tornado.ioloop
import tornado.web
from tornado import gen
from tornado.concurrent import Future

future = None  # 全局变量

class MainHandler(tornado.web.RequestHandler):
    @gen.coroutine
    def get(self):
        global future
        future = Future()
        future.add_done_callback(self.done)
                # 自己返回future
        yield future

    def done(self, *args, **kwargs):
        self.write('Main')  # 立马写入
        self.finish()  # 该请求完成！

class IndexHandler(tornado.web.RequestHandler):
    def get(self):
        global future
        # 改变结果，
        future.set_result(None)
        self.write(&quot;Index&quot;)

application = tornado.web.Application([
    (r&quot;/main&quot;, MainHandler),
    (r&quot;/index&quot;, IndexHandler),
])

if __name__ == &quot;__main__&quot;:
    application.listen(8888)
    tornado.ioloop.IOLoop.instance().start()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;　　 下面是手动实现异步非阻塞框架（自我感觉还是和&lt;code&gt;tornado&lt;/code&gt;有一些差异，下面这个代码是必须要有&lt;code&gt;HTTP&lt;/code&gt;请求来才会循环检测&lt;code&gt;Future&lt;/code&gt;任务列表，&lt;code&gt;tornado&lt;/code&gt;中其实是任务完成后自动就返回了，暂时也没往深处研究....）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import socket
import select
import time

class HttpRequest(object):
    &quot;&quot;&quot;
    用户封装用户请求信息
    &quot;&quot;&quot;
    def __init__(self, content):
        &quot;&quot;&quot;

        :param content:用户发送的请求数据：请求头和请求体
        &quot;&quot;&quot;
        self.content = content

        self.header_bytes = bytes()
        self.body_bytes = bytes()

        self.header_dict = {}

        self.method = &quot;&quot;
        self.url = &quot;&quot;
        self.protocol = &quot;&quot;

        self.initialize()
        self.initialize_headers()

    def initialize(self):

        temp = self.content.split(b'\r\n\r\n', 1)
        if len(temp) == 1:
            self.header_bytes += temp
        else:
            h, b = temp
            self.header_bytes += h
            self.body_bytes += b

    @property
    def header_str(self):
        return str(self.header_bytes, encoding='utf-8')

    def initialize_headers(self):
        headers = self.header_str.split('\r\n')
        first_line = headers[0].split(' ')
        if len(first_line) == 3:
            self.method, self.url, self.protocol = headers[0].split(' ')
            for line in headers:
                kv = line.split(':')
                if len(kv) == 2:
                    k, v = kv
                    self.header_dict[k] = v

class Future(object):
    def __init__(self,timeout=0):
        self.result = None
        self.timeout = timeout
        self.start = time.time()
def main(request):
    f = Future(5)
    return f

def index(request):
    return &quot;indexasdfasdfasdf&quot;


routers = [
    ('/main/',main),
    ('/index/',index),
]

def run():
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sock.bind((&quot;127.0.0.1&quot;, 9999,))
    sock.setblocking(False)
    sock.listen(128)

    inputs = []
    inputs.append(sock)

    async_request_dict = {
        # 'socket': futrue
    }

    while True:
        rlist,wlist,elist = select.select(inputs,[],[],0.05)
        for r in rlist:
            if r == sock:
                &quot;&quot;&quot;新请求到来&quot;&quot;&quot;
                conn,addr = sock.accept()
                conn.setblocking(False)
                inputs.append(conn)
            else:
                &quot;&quot;&quot;客户端发来数据&quot;&quot;&quot;
                data = b&quot;&quot;
                while True:
                    try:
                        chunk = r.recv(1024)
                        data = data + chunk
                    except Exception as e:
                        chunk = None
                    if not chunk:
                        break
                # data进行处理：请求头和请求体
                request = HttpRequest(data)
                # 1. 请求头中获取url
                # 2. 去路由中匹配，获取指定的函数
                # 3. 执行函数，获取返回值
                # 4. 将返回值 r.sendall(b'alskdjalksdjf;asfd')
                import re
                flag = False
                func = None
                for route in routers:
                    if re.match(route[0],request.url):
                        flag = True
                        func = route[1]
                        break
                if flag:
                    result = func(request)
                    if isinstance(result,Future):
                        async_request_dict[r] = result
                    else:
                        r.sendall(bytes(result,encoding='utf-8'))
                        inputs.remove(r)
                        r.close()
                else:
                    r.sendall(b&quot;404&quot;)
                    inputs.remove(r)
                    r.close()

        for conn in async_request_dict.keys():
            future = async_request_dict[conn]
            start = future.start
            timeout = future.timeout
            ctime = time.time()
            if (start + timeout) &amp;lt;= ctime :
                future.result = b&quot;timeout&quot;
            if future.result:
                conn.sendall(future.result)
                conn.close()
                del async_request_dict[conn]
                inputs.remove(conn)

if __name__ == '__main__':
    run()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;tornado源码流程图示&lt;/h2&gt;

&lt;p&gt;　　&lt;img src=&quot;https://images0.cnblogs.com/blog2015/425762/201506/211916272795074.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　 本文内容主要来源于网络、一些代码等都是手动测一遍结合自己想法就写上去了。&lt;/p&gt;
&lt;p&gt;　　 另外，很多知识点都摘自武&lt;code&gt;Sir&lt;/code&gt;博客。&lt;/p&gt;
&lt;p&gt;　　 &lt;a href=&quot;https://www.cnblogs.com/wupeiqi&quot;&gt;欢迎访问武Sir博客地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　 其实从异步非阻塞开始，我写的就有点心虚了，因为大多数资料都是从网上找的本身也没翻看过&lt;code&gt;tornado&lt;/code&gt;源码，所以有一些地方深入解读会有一些冲突。&lt;/p&gt;
&lt;p&gt;　　 如果想了解底层可能会有误差，甩个锅先，但是基本上新版&lt;code&gt;tornado&lt;/code&gt;你要单纯使用异步就简单粗暴的&lt;code&gt;async await&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;　　 以后有空再看源码回来填坑吧、^(*￣(oo)￣)^，感谢您的阅读。&lt;/p&gt;
&lt;p&gt;　　 2021年1月28日凌晨12.01&lt;/p&gt;
</description>
<pubDate>Wed, 27 Jan 2021 16:06:00 +0000</pubDate>
<dc:creator>云崖先生</dc:creator>
<og:description>tornado简介 tornado是Python界中非常出名的一款Web框架，和Flask一样它也属于轻量级的Web框架。 但是从性能而言tornado由于其支持异步非阻塞的特性所以对于一些高并发的场</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yunya-Cnblogs/p/14337673.html</dc:identifier>
</item>
</channel>
</rss>