<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>关于我学XSS躺过的那些坑 - Yunen的博客</title>
<link>http://www.cnblogs.com/yunen/p/10586696.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunen/p/10586696.html</guid>
<description>&lt;p&gt;在学习编码绕过时由于数量多，类型相似，不太容易记得住，记得全，故做此记录。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;x01-html标签属性中执行&quot;&gt;0x01 Html标签属性中执行&lt;/h2&gt;
&lt;p&gt;简单了解：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Html标签属性中的XSS问题多属于javascript伪协议&lt;br/&gt;常见的属性有：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;src&lt;/li&gt;
&lt;li&gt;lowsrc&lt;/li&gt;
&lt;li&gt;dynsrc&lt;/li&gt;
&lt;li&gt;url&lt;/li&gt;
&lt;li&gt;href&lt;/li&gt;
&lt;li&gt;action&lt;/li&gt;
&lt;li&gt;onload&lt;/li&gt;
&lt;li&gt;onunload&lt;/li&gt;
&lt;li&gt;onmouseover&lt;/li&gt;
&lt;li&gt;onerror&lt;/li&gt;
&lt;li&gt;各种on开头的事件&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PS：此处可不加括号，如&lt;code&gt;onclick=javascript:alert(1)&lt;/code&gt;,各类教程里常见的&lt;code&gt;&amp;lt;img src=javascript:alert(1)&amp;gt;&amp;lt;/img&amp;gt;&lt;/code&gt;Chrome、Firfox已失效，IE测试成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;在Html标签中，许多标签具有执行javascript的权利，当服务器存在过滤时，我们可以尝试通过以下编码方法绕过：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;8/10/16进制转换(&lt;code&gt;[.][&amp;amp;#][&amp;amp;#x]&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;javascript:String.fromCharCode(xx,xx,xx......)&lt;/code&gt; &lt;strong&gt;[xx为编码的字符串的ASCII码]&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;JScript Encode &lt;strong&gt;[IE]&lt;/strong&gt; JS fuck等&lt;/li&gt;
&lt;li&gt;&lt;code&gt;data:text/html;bbase64,xxxxxxx&lt;/code&gt; &lt;strong&gt;[IE下无效，Chorme、Firefox下均属于空白域，无法获取信息，不过可用作CVE攻击]&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;x02-在scriptscript&quot;&gt;0x02 在&lt;code&gt;&amp;lt;script&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;直接在script标签里执行的情况，我们通常分为以下几种利用方式：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;直接导入远程XSS平台脚本&lt;/li&gt;
&lt;li&gt;直接在&lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt;中写上自定义攻击脚本，如生成img标签&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于&lt;code&gt;&amp;lt;&amp;gt;&amp;lt;/&amp;gt;&lt;/code&gt;中可用：&lt;/p&gt;
&lt;h3 id=&quot;单个拆开编码成ascii&quot;&gt;1) 单个拆开编码成ASCII&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;eval(String.fromCharCode())&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用eval执行16进制转换后的代码&quot;&gt;2) 使用eval()执行16进制转换后的代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;eval(\u0064\u0078......)
eval(\x64\x78......)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;x03-在样式表中的编码&quot;&gt;0x03 在样式表中的编码&lt;/h2&gt;
&lt;p&gt;样式表中可用expression和@import来执行js代码,此方法可进行适当的编码转换。&lt;br/&gt;PS:仅在IE8.0之前的版本。&lt;/p&gt;
&lt;h3 id=&quot;expression&quot;&gt;1) expression&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;全角字符：
&amp;lt;div style=xss:ｅｘｐｒｅｓｓｉｏｎ(alert(1))&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;十六进制
&amp;lt;div style=xss:\0065ｘｐｒｅｓｓｉｏｎ(alert(1))&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/**/注释 [Javascript中也行]
&amp;lt;div sty/**/le=x/**/ss:\0065ｘｐｒｅ/**/ｓｓｉｏ/**/ｎ(al/**/ert(1))&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;import&quot;&gt;2) @import&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;\和结束符\0会被浏览器忽略
@im\po\rt jav\ascr\ipt:al\ert(1)
@im\00po\0rt jav\00asc\0000ript:a\00lert(1)&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;简单记录常见的浏览器差异造成的XSS&lt;/p&gt;
&lt;h2 id=&quot;x01-引号的差异&quot;&gt;0x01 引号的差异&lt;/h2&gt;
&lt;p&gt;只有IE支持反引号`` &lt;code&gt;## 0x02 标签的差异 + data协议执行代码是在Chrome下执行 + Chrome下srcdoc利用：&lt;/code&gt;&lt;code&gt;+ IE下&lt;/code&gt;&lt;img src=&quot;javascript:alert(1)&quot;/&gt;`&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只要火狐支持E4X&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;x03-过滤器差异&quot;&gt;0x03 过滤器差异&lt;/h2&gt;
&lt;p&gt;Chrome能拦截大多数反射型XSS，Firefox次之，IE最次&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2019/03/23/5c964e6f476d6.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在刚开始学习XSS的时候总是想千方百计的想用javascript调用dom对象，比如document.cookie，却不知这个只能在javascript域[伪协议或标签内]范围内。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一、src等属性在引入时如果漏洞网站协议名于xss平台相同，即可省略去，如：&lt;code&gt;&amp;lt;img src=//www.baidu.com /&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;二、svg标签属于xml而不属于html&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;三、关于Cors跨域：使用Ajax跨域时默认是不允许带上会话数据的，不过可以在XSS平台通过设置返回的请求头&lt;code&gt;Access-Control-Allow-Credentials: true&lt;/code&gt;，并且需要设置xhr的&lt;code&gt;withCreadential&lt;/code&gt;属性值为true，注意此时返回的&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;不能设置为通配符true。&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;四、优先级：&lt;code&gt;function xxx(){}形式定义的函数 -&amp;gt; == -&amp;gt; &amp;amp;&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;五、使用img等合法标签跨域可以带上会话信息&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;六、除javascript外还有vbscript、actionscript等&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;七、P3P协议仅仅是IE浏览器支持,通常是Hacker域名通过iframe或script等载入存在XSS漏洞的网站&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;XSS的恶意请求伪造与CSRF极为相似，两者的差别为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;后者发出的伪造请求可为其他站点发出的，而前者都是存在XSS漏洞的站点发出的&lt;/li&gt;
&lt;li&gt;CSRF是XSS无法替代的&lt;/li&gt;
&lt;li&gt;CSRF可以无Javascript参与，及在黑客的网站上使用img等标签发送带Cookie(自带)的跨域请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;x01-输出html标签属性&quot;&gt;0x01 输出Html标签属性&lt;/h2&gt;
&lt;p&gt;如：&lt;code&gt;&amp;lt;input class='xxx' value=&quot;{输出}&quot;&amp;gt;&lt;/code&gt; 这里的输出如果过滤/转义了&lt;code&gt;&quot;&lt;/code&gt;，便不存在XSS漏洞了，因为这里的value属性不能执行js代码。&lt;/p&gt;
&lt;h2 id=&quot;x02-输出在注释&quot;&gt;0x02 输出在注释&lt;/h2&gt;
&lt;p&gt;一定要过滤换行符！！&lt;/p&gt;
&lt;h2 id=&quot;x03-输出在样式表&quot;&gt;0x03 输出在样式表&lt;/h2&gt;
&lt;p&gt;过滤expression和@import还有外部图片的引用&lt;/p&gt;
&lt;h2 id=&quot;x04-字符集&quot;&gt;0x04 字符集&lt;/h2&gt;
&lt;p&gt;开头设定好字符集为 UTF-8&lt;/p&gt;
&lt;h2 id=&quot;x05-cookie盗取&quot;&gt;0x05 Cookie盗取&lt;/h2&gt;
&lt;p&gt;设置好path、开启http_only、防止调试信息泄露和Apache400漏洞、使用Session&lt;/p&gt;
</description>
<pubDate>Sat, 23 Mar 2019 17:48:00 +0000</pubDate>
<dc:creator>Yunen的博客</dc:creator>
<og:description>XSS字符编码 在学习编码绕过时由于数量多，类型相似，不太容易记得住，记得全，故做此记录。 &lt;! more 0x01 Html标签属性中执行 简单了解： Html标签属性中的XSS问题多属于javas</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yunen/p/10586696.html</dc:identifier>
</item>
<item>
<title>从0到1：使用Caliburn.Micro(WPF和MVVM)开发简单的计算器 - Enjoy233</title>
<link>http://www.cnblogs.com/enjoy233/p/10586651.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/enjoy233/p/10586651.html</guid>
<description>&lt;h2 id=&quot;从0到1使用caliburn.microwpf和mvvm开发简单的计算器&quot;&gt;从0到1：使用Caliburn.Micro(WPF和MVVM)开发简单的计算器&lt;/h2&gt;
&lt;p&gt;之前时间一直在使用Caliburn.Micro这种应用了MVVM模式的WPF框架做开发，是时候总结一下了。&lt;/p&gt;
&lt;p&gt;Caliburn.Micro(Caliburn.Micro框架概述 - &lt;a href=&quot;https://blog.csdn.net/lzuacm/article/details/78886436&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/lzuacm/article/details/78886436&lt;/a&gt;) 是一个轻量级的WPF框架，简化了WPF中的不少用法，推荐做WPF开发时优先使用。&lt;/p&gt;
&lt;p&gt;真正快速而熟练地掌握一门技术就可以尝试着用最快的速度去构建一个玩具项目(Toy project)，然后不断地优化、重构之。比如本文将介绍如何使用Caliburn.Micro v3.2开发出一个简单的计算器，里面用到了C#中的async异步技术，Caliburn.Micro中的Conductor等等~&lt;/p&gt;
&lt;h3 id=&quot;step-1-在vs中创建wpf项目&quot;&gt;Step 1: 在VS中创建WPF项目&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201903/436938-20190324010953551-1224926541.png&quot; alt=&quot;create_project&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;step-2-使用nuget包管理工具为当前项目安装caliburn.micro&quot;&gt;Step 2: 使用NuGet包管理工具为当前项目安装Caliburn.Micro&lt;/h3&gt;
&lt;p&gt;对于Caliburn.Micro 1.x和2.x版，只能使用.dll，需手动给项目加Reference。而3.0以后的版本可使用NuGet包管理工具来管理，安装和卸载既方便又彻底，推荐使用。(ps: NuGet之于Visual Studio(C++, C#等), 犹pip之于Python, npm之于node, maven之于Java, gem之于Ruby等等)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201903/436938-20190324005855423-424717537.png&quot; alt=&quot;Install CM&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;step-3-框架搭建&quot;&gt;Step 3: 框架搭建&lt;/h3&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;删除项目根目录下的MainWindow.xaml&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;按下图调整App.xaml&lt;br/&gt;删除语句StartupUri=&quot;MainWindow.xmal&quot;。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/436938/201903/436938-20190324005959001-1435534729.png&quot; alt=&quot;config1&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;填充Application.Resources&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;xaml&quot;&gt;
&lt;code&gt;    &amp;lt;Application.Resources&amp;gt;
         &amp;lt;ResourceDictionary&amp;gt;
             &amp;lt;ResourceDictionary.MergedDictionaries&amp;gt;
                 &amp;lt;ResourceDictionary&amp;gt;
                     &amp;lt;local:Bootstrapper x:Key=&quot;bootstrapper&quot;/&amp;gt;
                 &amp;lt;/ResourceDictionary&amp;gt;
             &amp;lt;/ResourceDictionary.MergedDictionaries&amp;gt;
         &amp;lt;/ResourceDictionary&amp;gt;
    &amp;lt;/Application.Resources&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;   4 . 创建Bootstrapper类&lt;br/&gt;然后让其继承自BootstrapperBase类，并加上构造函数，另外再重写函数OnStartup即可。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System.Windows;
using Caliburn.Micro;
using CaliburnMicro_Calculator.ViewModels;

namespace CaliburnMicro_Calculator
{
    public class Bootstrapper : BootstrapperBase
    {
        public Bootstrapper()
        {
            Initialize();
        }

        protected override void OnStartup(object obj, StartupEventArgs e)
        {
            DisplayRootViewFor&amp;lt;ShellViewModel&amp;gt;();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;   5 . 在项目目录下新建Models, ViewModels, Views这3个文件夹&lt;br/&gt;在ViewModel文件夹中添加ShellViewModel.cs，并创建Left, Right和Result这3个属性。&lt;/p&gt;
&lt;p&gt;需要注意的是 ShellViewModel.cs需要继承类 &lt;strong&gt;Screen 和 INotifyPropertyChanged&lt;/strong&gt; (用于感知并同步所绑定属性的变化)，ShellViewModel具体代码为:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System.ComponentModel;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using Caliburn.Micro;

namespace CaliburnMicro_Calculator.ViewModels
{
    public class ShellViewModel : Screen, INotifyPropertyChanged
    {
        private double _left;
        private double _right;
        private double _result;

        public double Left
        {
            get { return _left; }
            set
            {
                _left = value;
                NotifyOfPropertyChange();
            }
        }

        public double Right
        {
            get { return _right; }
            set
            {
                _right = value;
                NotifyOfPropertyChange();
            }
        }

        public double Result
        {
            get { return _result; }
            set
            {
                _result = value;
                NotifyOfPropertyChange();
            }
        }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 最开始布局xaml时，设计位置时采用的是左(operand 1), 中(operand 2), 右(result)，于是属性值使用了Left, Right和Result。&lt;/p&gt;
&lt;h3 id=&quot;step-4-设计xaml并绑定属性&quot;&gt;Step 4: 设计XAML并绑定属性&lt;/h3&gt;
&lt;p&gt;在Views文件夹中创建Window，命名为ShellView.xaml，在Views文件夹下创建子文件夹Images，用于存放+,-,*,/这4种操作对应的小图标，其具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;xmal&quot;&gt;
&lt;code&gt;&amp;lt;Window x:Class=&quot;CaliburnMicro_Calculator.Views.ShellView&quot;
        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;
        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;
        xmlns:local=&quot;clr-namespace:CaliburnMicro_Calculator.Views&quot;
        xmlns:cal=&quot;http://www.caliburnproject.org&quot;
        mc:Ignorable=&quot;d&quot;
        Title=&quot;Calculator&quot; SizeToContent=&quot;Height&quot; Width=&quot;240&quot;&amp;gt;

    &amp;lt;StackPanel Background=&quot;Beige&quot;&amp;gt;
        &amp;lt;StackPanel Orientation=&quot;Horizontal&quot;&amp;gt;
            &amp;lt;Label Margin=&quot;10&quot;
                   Target=&quot;{Binding ElementName=left}&quot;&amp;gt;
                Operand _1:
            &amp;lt;/Label&amp;gt;
            &amp;lt;TextBox Margin=&quot;10&quot;
                     Width=&quot;72&quot;
                     x:Name=&quot;left&quot;/&amp;gt;
        &amp;lt;/StackPanel&amp;gt;
        &amp;lt;StackPanel Orientation=&quot;Horizontal&quot;&amp;gt;
            &amp;lt;Label Margin=&quot;10&quot;
                   Target=&quot;{Binding ElementName=right}&quot;&amp;gt;
                Operand _2:
            &amp;lt;/Label&amp;gt;
            &amp;lt;TextBox Margin=&quot;10&quot;
                     Width=&quot;72&quot;
                     x:Name=&quot;right&quot;/&amp;gt;
        &amp;lt;/StackPanel&amp;gt;
        &amp;lt;StackPanel Orientation=&quot;Horizontal&quot;&amp;gt;
            &amp;lt;Button Margin=&quot;10&quot;
                    x:Name=&quot;btnPlus&quot; 
                    cal:Message.Attach=&quot;[Event Click]=[Action Plus(left.Text, right.Text):result.Text]&quot;&amp;gt;
                &amp;lt;Image Source=&quot;Images/op1.ICO&quot;/&amp;gt;
            &amp;lt;/Button&amp;gt;

            &amp;lt;Button Margin=&quot;10&quot;
                    x:Name=&quot;btnMinus&quot; 
                    cal:Message.Attach=&quot;[Event Click]=[Action Minus(left.Text, right.Text):result.Text]&quot;&amp;gt;
                &amp;lt;Image Source=&quot;Images/op2.ICO&quot;/&amp;gt;
            &amp;lt;/Button&amp;gt;

            &amp;lt;Button Margin=&quot;10&quot;
                    x:Name=&quot;btnMultiply&quot; 
                    cal:Message.Attach=&quot;[Event Click]=[Action Multipy(left.Text, right.Text):result.Text]&quot;&amp;gt;
                &amp;lt;Image Source=&quot;Images/op3.ICO&quot;/&amp;gt;
            &amp;lt;/Button&amp;gt;

            &amp;lt;Button Margin=&quot;10&quot;
                    x:Name=&quot;btnDivide&quot; IsEnabled=&quot;{Binding Path=CanDivide}&quot;
                    cal:Message.Attach=&quot;[Event Click]=[Action Divide(left.Text, right.Text):result.Text]&quot;&amp;gt;
                &amp;lt;Image Source=&quot;Images/op4.ICO&quot;/&amp;gt;
            &amp;lt;/Button&amp;gt;

        &amp;lt;/StackPanel&amp;gt;
        &amp;lt;StackPanel Orientation=&quot;Horizontal&quot;&amp;gt;
            &amp;lt;Label Margin=&quot;10&quot;&amp;gt;
                Answer:
            &amp;lt;/Label&amp;gt;
            &amp;lt;TextBox Margin=&quot;10&quot;
                     Width=&quot;72&quot;
                     Text =&quot;{Binding Path=Result, StringFormat={}{0:F4}}&quot; IsReadOnly=&quot;True&quot; /&amp;gt;
        &amp;lt;/StackPanel&amp;gt;
    &amp;lt;/StackPanel&amp;gt;
&amp;lt;/Window&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;说明：&lt;/strong&gt;对操作数Operand _1和Operand _2，按Alt键+数字可以选中该处，这是WPF的一个特殊用法。由于计算结果不希望被修改，于是加上了属性&lt;code&gt;IsReadOnly=&quot;True&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;step-5-设计并绑定事件&quot;&gt;Step 5: 设计并绑定事件&lt;/h3&gt;
&lt;p&gt;由于暂时只打算实现+, -, *, /四种操作，于是我们只需创建相应的4个函数即可，由于除数是0这个操作不允许，于是需再加个判断函数CanDivide。&lt;/p&gt;
&lt;p&gt;Caliburn.Micro中绑定事件的写法是:&lt;br/&gt;&lt;code&gt;cal:Message.Attach=&quot;[Event E]=[Action A]&quot;&lt;/code&gt;(E是操作，比如Click, MouseDown, KeyDown等等，A是ViewModel中具体的函数。)&lt;/p&gt;
&lt;p&gt;向ShellViewModel中加入事件中要做的事，此时ShellViewModel为：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System.ComponentModel;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using Caliburn.Micro;

namespace CaliburnMicro_Calculator.ViewModels
{
    public class ShellViewModel : Screen, INotifyPropertyChanged
    {
        private double _left;
        private double _right;
        private double _result;

        public double Left
        {
            get { return _left; }
            set
            {
                _left = value;
                NotifyOfPropertyChange();
            }
        }

        public double Right
        {
            get { return _right; }
            set
            {
                _right = value;
                NotifyOfPropertyChange();
            }
        }

        public double Result
        {
            get { return _result; }
            set
            {
                _result = value;
                NotifyOfPropertyChange();
            }
        }
                public bool CanDivide(double left, double right)
        {
            return right != 0;
        }

        public async void Divide(double left, double right)
        {
            Thread.Sleep(600);
            if (CanDivide(left, right) == true)
                Result = left / right;
            else MessageBox.Show(&quot;Divider cannot be zero.&quot;, &quot;Warning&quot;, MessageBoxButton.OK, MessageBoxImage.Warning);
        }

        public async void Plus(double left, double right)
        {
            Result = left + right;
        }

        public async void Minus(double left, double right)
        {
            Result = left - right;
        }

        public async void Multipy(double left, double right)
        {
            Result = left * right;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时计算器的功能已基本完成，但我们可以对ViewModel进行适当的调整：&lt;br/&gt;1.创建新的ViewModel - CalculatorViewModel，将原来的ShellViewModel中具体的计算逻辑移入到CalculatorViewModel中；&lt;br/&gt;2.此时让ShellViewModel继承&lt;strong&gt;Conductor&amp;lt;Object&amp;gt;&lt;/strong&gt;，于是ShellViewModel拥有了管理Screen实例的功能(ViewModel中使用ActivateItem函数，而View中使用X:Name=&quot;ActivateItem&quot;标签)，其具体代码为:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System.ComponentModel;
using System.Threading;
using System.Windows;
using System.Windows.Controls;
using Caliburn.Micro;

namespace CaliburnMicro_Calculator.ViewModels
{
    public class ShellViewModel : Conductor&amp;lt;object&amp;gt;
    {
        public ShellViewModel()
        {
        }
        public void ShowCalculator()
        {
            ActivateItem(new CalculatorViewModel());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，CalculatorViewModel的具体代码为：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System.ComponentModel;
using System.Threading;
using System.Windows;
using Caliburn.Micro;

namespace CaliburnMicro_Calculator.ViewModels
{
    public class CalculatorViewModel: Screen, INotifyPropertyChanged
    {
        private double _left;
        private double _right;
        private double _result;

        public double Left
        {
            get { return _left; }
            set
            {
                _left = value;
                NotifyOfPropertyChange();
            }
        }

        public double Right
        {
            get { return _right; }
            set
            {
                _right = value;
                NotifyOfPropertyChange();
            }
        }

        public double Result
        {
            get { return _result; }
            set
            {
                _result = value;
                NotifyOfPropertyChange();
            }
        }

        public CalculatorViewModel()
        {
        }

        public bool CanDivide(double left, double right)
        {
            return right != 0;
        }

        public async void Divide(double left, double right)
        {
            Thread.Sleep(600);
            if (CanDivide(left, right) == true)
                Result = left / right;
            else MessageBox.Show(&quot;Divider cannot be zero.&quot;, &quot;Warning&quot;, MessageBoxButton.OK, MessageBoxImage.Warning);
        }

        public async void Plus(double left, double right)
        {
            Result = left + right;
        }

        public async void Minus(double left, double right)
        {
            Result = left - right;
        }

        public async void Multipy(double left, double right)
        {
            Result = left * right;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  3 . 对于View，只需把CalculatorViewModel对应的CalculatorView作为ContentControl控件嵌入ShellView即可。此时ShellView的代码调整为:&lt;/p&gt;
&lt;pre class=&quot;xaml&quot;&gt;
&lt;code&gt;&amp;lt;Window x:Class=&quot;CaliburnMicro_Calculator.Views.ShellView&quot;
        xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
        xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
        xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;
        xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;
        xmlns:local=&quot;clr-namespace:CaliburnMicro_Calculator.Views&quot;
        xmlns:cal=&quot;http://www.caliburnproject.org&quot;
        mc:Ignorable=&quot;d&quot;
        Title=&quot;Calculator&quot; SizeToContent=&quot;Height&quot; Width=&quot;240&quot;&amp;gt;

    &amp;lt;Grid MinHeight=&quot;200&quot;&amp;gt;
        &amp;lt;Button Content=&quot;Show Calculator&quot; x:Name=&quot;ShowCalculator&quot; Grid.Row=&quot;0&quot;&amp;gt;&amp;lt;/Button&amp;gt;
        &amp;lt;ContentControl x:Name=&quot;ActiveItem&quot;&amp;gt;&amp;lt;/ContentControl&amp;gt;        
    &amp;lt;/Grid&amp;gt;
&amp;lt;/Window&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;另外提一点&lt;/strong&gt;，向ViewModel A中嵌入ViewModel B，一般来说需要做的操作是：&lt;br/&gt;在A的view中使用ContentControl，绑定B的ViewModel只需使用语句cal:View.Model=&quot;{Binding BViewModel}&quot;即可，而B的view是UserControl就可以啦。&lt;/p&gt;
&lt;p&gt;此时CalculatorView是一个UserControl，其代码为:&lt;/p&gt;
&lt;pre class=&quot;xaml&quot;&gt;
&lt;code&gt;&amp;lt;UserControl x:Class=&quot;CaliburnMicro_Calculator.Views.CalculatorView&quot;
             xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot;
             xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot;
             xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot;
             xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot;
             xmlns:local=&quot;clr-namespace:CaliburnMicro_Calculator.Views&quot;
             xmlns:cal=&quot;http://www.caliburnproject.org&quot;
             mc:Ignorable=&quot;d&quot;
             Width=&quot;240&quot;&amp;gt;

    &amp;lt;StackPanel Background=&quot;Beige&quot;&amp;gt;
        &amp;lt;StackPanel Orientation=&quot;Horizontal&quot;&amp;gt;
            &amp;lt;Label Margin=&quot;10&quot;
                   Target=&quot;{Binding ElementName=left}&quot;&amp;gt;
                Operand _1:
            &amp;lt;/Label&amp;gt;
            &amp;lt;TextBox Margin=&quot;10&quot;
                     Width=&quot;72&quot;
                     x:Name=&quot;left&quot;/&amp;gt;
        &amp;lt;/StackPanel&amp;gt;
        &amp;lt;StackPanel Orientation=&quot;Horizontal&quot;&amp;gt;
            &amp;lt;Label Margin=&quot;10&quot;
                   Target=&quot;{Binding ElementName=right}&quot;&amp;gt;
                Operand _2:
            &amp;lt;/Label&amp;gt;
            &amp;lt;TextBox Margin=&quot;10&quot;
                     Width=&quot;72&quot;
                     x:Name=&quot;right&quot;/&amp;gt;
        &amp;lt;/StackPanel&amp;gt;
        &amp;lt;StackPanel Orientation=&quot;Horizontal&quot; HorizontalAlignment=&quot;Center&quot;&amp;gt;
            &amp;lt;Button Margin=&quot;10&quot;
                    x:Name=&quot;btnPlus&quot; 
                    cal:Message.Attach=&quot;[Event Click]=[Action Plus(left.Text, right.Text):result.Text]&quot;&amp;gt;
                &amp;lt;Image Source=&quot;Images/op1.ICO&quot;/&amp;gt;
            &amp;lt;/Button&amp;gt;

            &amp;lt;Button Margin=&quot;10&quot;
                    x:Name=&quot;btnMinus&quot; 
                    cal:Message.Attach=&quot;[Event Click]=[Action Minus(left.Text, right.Text):result.Text]&quot;&amp;gt;
                &amp;lt;Image Source=&quot;Images/op2.ICO&quot;/&amp;gt;
            &amp;lt;/Button&amp;gt;

            &amp;lt;Button Margin=&quot;10&quot;
                    x:Name=&quot;btnMultiply&quot; 
                    cal:Message.Attach=&quot;[Event Click]=[Action Multipy(left.Text, right.Text):result.Text]&quot;&amp;gt;
                &amp;lt;Image Source=&quot;Images/op3.ICO&quot;/&amp;gt;
            &amp;lt;/Button&amp;gt;

            &amp;lt;Button Margin=&quot;10&quot;
                    x:Name=&quot;btnDivide&quot; IsEnabled=&quot;{Binding Path=CanDivide}&quot;
                    cal:Message.Attach=&quot;[Event Click]=[Action Divide(left.Text, right.Text):result.Text]&quot;&amp;gt;
                &amp;lt;Image Source=&quot;Images/op4.ICO&quot;/&amp;gt;
            &amp;lt;/Button&amp;gt;

        &amp;lt;/StackPanel&amp;gt;
        &amp;lt;StackPanel Orientation=&quot;Horizontal&quot;&amp;gt;
            &amp;lt;Label Margin=&quot;10&quot;&amp;gt;
                Answer:
            &amp;lt;/Label&amp;gt;
            &amp;lt;TextBox Margin=&quot;10&quot;
                     Width=&quot;72&quot;
                     Text =&quot;{Binding Path=Result, StringFormat={}{0:F4}, UpdateSourceTrigger=PropertyChanged}&quot; IsReadOnly=&quot;True&quot; /&amp;gt;
        &amp;lt;/StackPanel&amp;gt;
    &amp;lt;/StackPanel&amp;gt;
&amp;lt;/UserControl&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好啦，就酱，由于本例中逻辑并不复杂，Model暂时用不上，对于复杂一点的项目，Model主要负责数据的读取，如文件操作、数据库操作、service调用等，以后有机会举例具体来说。&lt;/p&gt;
&lt;p&gt;如果需要持久化(persistent)，则还需给给每对M-VM(Model和ViewModel)加入State，这个实际工程中也用得特别多。&lt;/p&gt;
&lt;h3 id=&quot;part-6-功能举例&quot;&gt;Part 6: 功能举例&lt;/h3&gt;
&lt;p&gt;Calculator主页：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yanglr/CaliburnMicro-Calculator/master/screenshots/p1.png&quot; alt=&quot;Main Page&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击按钮“ShowCalculator”即可看到具体的计算器~&lt;/p&gt;
&lt;p&gt;乘法举例：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yanglr/CaliburnMicro-Calculator/master/screenshots/p2.png&quot; alt=&quot;Multiply&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除法举例：&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/yanglr/CaliburnMicro-Calculator/master/screenshots/p3.png&quot; alt=&quot;Divide&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后附上代码：&lt;/strong&gt;&lt;br/&gt;CaliburnMicro-Calculator: A simple Calculator using Caliburn.Micro&lt;br/&gt;&lt;a href=&quot;https://github.com/yanglr/CaliburnMicro-Calculator&quot; class=&quot;uri&quot;&gt;https://github.com/yanglr/CaliburnMicro-Calculator&lt;/a&gt;，&lt;br/&gt;欢迎fork和star，如有改进意见欢迎提交pull request~&lt;/p&gt;
</description>
<pubDate>Sat, 23 Mar 2019 16:53:00 +0000</pubDate>
<dc:creator>Enjoy233</dc:creator>
<og:description>从0到1：使用Caliburn.Micro(WPF和MVVM)开发简单的计算器 之前时间一直在使用Caliburn.Micro这种应用了MVVM模式的WPF框架做开发，是时候总结一下了。 Calibu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/enjoy233/p/10586651.html</dc:identifier>
</item>
<item>
<title>this 相关 - zhanghaiyu</title>
<link>http://www.cnblogs.com/zhanghaiyu-Jade/p/10586650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanghaiyu-Jade/p/10586650.html</guid>
<description>&lt;p&gt;对于前端程序媛（员）来说，this这个机制应用的地方是很多的，所以搞懂是必要的，不熟练使用this将遇到一些困惑，下面是一些关于this的学习心得分享，希望大家可以一起学习：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1，this并不是指向自身&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先来看一段代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(num) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         console.log(&quot;foo:&quot; + num); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0 1 2 3 4 &lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;window对象   &lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.count++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录foo被调用的次数&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     foo.count = 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;count 属于foo的属性  并不属于window&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;lt; 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            foo(i);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     console.log(foo.count) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很多人认为 ：函数内部的this指向当前这个函数，这是错误的&lt;/p&gt;
&lt;p&gt;对于这个例子来说，一种解决方法是使用foo标识符代替this来指向自身&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(num) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         console.log(&quot;foo:&quot; + num); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0 1 2 3 4 &lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;window对象   &lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         foo.count++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录foo被调用的次数&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     foo.count = 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;count 属于foo的属性  并不属于window&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt;&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;lt; 5&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            foo(i);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     console.log(foo.count) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另一种方法是没有规避了this使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(num) {
        console.log(&lt;/span&gt;&quot;foo:&quot; + num); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;0 1 2 3 4 &lt;/span&gt;
        console.log(&lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;window对象   &lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;.count++; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;记录foo被调用的次数&lt;/span&gt;
&lt;span&gt;    }
    foo.count &lt;/span&gt;= 0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;count 属于foo的属性  并不属于window&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt;&lt;span&gt; i;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i = 0; i &amp;lt; 10; i++&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;lt; 5&lt;span&gt;) {
            foo.call(foo, i) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用call() 确保this 指向函数foo&lt;/span&gt;
&lt;span&gt;        }
    }
    console.log(foo.count) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2，this指向函数作用域(并不是一直都是对的）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 需要知道的一点是this在任何情况都不会指向函数的词法作用域，因为作用域是无法通过js代码访问到的，它存在于引擎内部&lt;/p&gt;
&lt;p&gt;下面这个代码很好的说明了这个问题&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.bar(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this是window&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;
        console.log(&lt;span&gt;this&lt;/span&gt;.a); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;span&gt;    }
    foo();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; this究竟是指向什么呢？this是在运行时进行绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的各种条件，this绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。&lt;/p&gt;
&lt;p&gt;当函数调用时，会创建一个执行上下文，这个上下文会记录函数在哪里调用了，函数的调用方法，函数参数等信息，this就是该上下文的一个属性，会在函数执行的过程中用到。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3，函数在执行过程中this是如何绑定的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;寻找函数的调用位置，其实有的很明显，而某些编程模式会因此函数的真正的调用位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析调用栈&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; baz() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前的调用栈是baz&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因此，当前的调用位置是全局作用域&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         console.log(&quot;baz&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         bar(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;bar的调用位置&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; bar() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前的调用栈是baz-&amp;gt;bar&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因此，当前的调用位置是baz&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         console.log(&quot;bar&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         foo(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;foo的调用位置&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前的调用栈是baz-&amp;gt;bar-&amp;gt;foo&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;因此，当前的调用位置是bar&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         console.log(&quot;foo&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     baz(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;baz的调用位置&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析调用栈是，决定了this的绑定&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 4，this的绑定规则&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;①默认绑定：独立函数调用  ，在下面的代码中，foo（）是直接使用不带任何修饰符的函数引用进行调用的，因此只能使用默认绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;.a); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;this指向window&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     foo(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是在严格模式下，全局对象将无法使用默认绑定，因此this会绑定到undefined&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         'use strict'
&lt;span&gt;3&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;undefined&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;.a); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;报错&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     foo(); 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是有个微妙的非常重要的情况，虽然this的邦定规则完全取决于调用位置，但是只有foo运行在非严格模式下是默认绑定才能绑定到全局对象，但在严格模式下，于foo的调用位置无关了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;window&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;.a); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     (&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         'use strict'
&lt;span&gt; 9&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);//undefined
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        foo();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     })()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;②隐式绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;obj &lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;.a); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         a: 2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;        foo: foo
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     obj.foo();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当foo被调用的时候，它的落脚点确实指向obj对象，当函数引用有上下文对象时，隐式绑定规则会把函数调用中的this邦定到这个上下文对象中，因此，调用foo()时，this被绑定到obj，因此，this.a和obj.a是一样的&lt;/p&gt;
&lt;p&gt;③显示绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;obj &lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         console.log(&lt;span&gt;this&lt;/span&gt;.a); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; obj =&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         a: 2
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     foo.call(obj)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;.call(...)和apply(...)方法实现显示绑定&lt;/p&gt;
&lt;p&gt;他们的第一个参数是一个对象，不是对象的会利用自己的包装对象转换成对象（new Number()  ，new String() ，new Boolen()等），他们会把这个对象绑定到this，接着在调用函数时指定这个this,因为你可以直接指定this的绑定对象，因此我们称为显式绑定&lt;/p&gt;
&lt;p&gt;④new绑定&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(a) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.a =&lt;span&gt; a;
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; bar = &lt;span&gt;new&lt;/span&gt; foo(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     console.log(bar.a);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;构造函数是使用new操作时会被调用的函数。他们并不属于类，也不会实例化一个类，实际上，甚至不能说他们是一直特殊的函数类型，他们只是用new操作费调用的普通函数而已。&lt;/p&gt;
&lt;p&gt;使用new来调用函数，会自动执行下面操作：&lt;/p&gt;
&lt;p&gt;1，创建（或者构造一个）全新的对象&lt;/p&gt;
&lt;p&gt;2，这个对象会被执行【原型】连接&lt;/p&gt;
&lt;p&gt;3，这个新对象会被绑定到函数调用的this,&lt;/p&gt;
&lt;p&gt;4，如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象&lt;/p&gt;
&lt;p&gt;上面的代码，使用new调用foo()时，我们会构造一个新的对象并把它绑定到foo()调用中的this上，new是最后一个可以影响函数调用时this邦定行为的方法，我们称之为new绑定&lt;/p&gt;
</description>
<pubDate>Sat, 23 Mar 2019 16:52:00 +0000</pubDate>
<dc:creator>zhanghaiyu</dc:creator>
<og:description>对于前端程序媛（员）来说，this这个机制应用的地方是很多的，所以搞懂是必要的，不熟练使用this将遇到一些困惑，下面是一些关于this的学习心得分享，希望大家可以一起学习： 1，this并不是指向自</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhanghaiyu-Jade/p/10586650.html</dc:identifier>
</item>
<item>
<title>【Spark调优】小表join大表数据倾斜解决方案 - wwcom123</title>
<link>http://www.cnblogs.com/wwcom123/p/10586607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wwcom123/p/10586607.html</guid>
<description>&lt;h3&gt;&lt;span&gt;【使用场景】　　&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　对RDD使用join类操作，或者是在Spark SQL中使用join语句时，而且&lt;strong&gt;join操作中的一个RDD或表的数据量比较小（例如几百MB或者1~2GB），比较适用此方案。&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;【解决方案】&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　小表join大表转为小表broadcast+map大表实现&lt;/strong&gt;。具体为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;普通的join是会shuffle的，而一旦shuffle，就相当于会将相同key的数据拉取到一个shuffle read task中再进行join，此时就是reduce join，此时如果发生数据倾斜，影响处理性&lt;span&gt;能，而此时恰好一个RDD是比较小的，则可以采用广播小RDD全量数据+map算子来实现与join同样的效果，也就是map join，因为这样不会发生shuffle，也就不会发生数据倾斜。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　也就是说，不使用join算子进行连接操作，而使用Broadcast变量与map类算子实现join操作，进而完全规避掉shuffle类的操作，彻底避免数据倾斜的发生和出现。&lt;strong&gt;将较小RDD中的数据直接通过collect算子拉取到Driver端的内存中来，然后对其创建一个Broadcast变量&lt;/strong&gt;；接着对另外一个RDD执行map类算子，在算子函数内，从Broadcast变量中获取较小RDD的全量数据，与当前RDD的每一条数据按照连接key进行比对，如果连接key相同的话，那么就将两个RDD的数据需要的方式连接起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;【方案优点】&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;&lt;strong&gt;对&lt;/strong&gt;&lt;strong&gt;join操作导致的数据倾斜，效果非常好，因为根本就不会发生shuffle，也就根本不会发生数据倾斜，是一种治标治本的解决方案。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;【方案局限&lt;span&gt;】&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　这个方案只适用于一个大表和一个小表join的情况。因为解决方案是需要&lt;strong&gt;将小表进行广播，此时会比较消耗内存资源&lt;/strong&gt;，&lt;strong&gt;driver和每个Executor内存中都会驻留一份小RDD的全量数据&lt;/strong&gt;。如果广播出去的RDD数据比较大，比如10G以上，那么就可能发生内存溢出了。因此并不适合两个都是大表的情况。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;【代码实现】&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　我对上述方案做了代码实现，见我的github：https://github.com/wwcom614/Spark&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a title=&quot;BroadcastMapJoin&quot; href=&quot;https://github.com/wwcom614/Spark/blob/master/src/main/java/com/ww/rdd/performance_optimize/BroadcastMapJoin.java&quot; target=&quot;_blank&quot;&gt;Java版实现&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;a title=&quot;BroadcastMapJoin&quot; href=&quot;https://github.com/wwcom614/Spark/blob/master/src/main/scala/com/ww/rdd/performance_optimize/BroadcastMapJoins.scala&quot; target=&quot;_blank&quot;&gt;Scala版实现&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　   下一篇：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上一篇：&lt;/span&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/wwcom123/p/10582146.html&quot;&gt;【Spark调优】聚合操作数据倾斜解决方案&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Mar 2019 16:23:00 +0000</pubDate>
<dc:creator>wwcom123</dc:creator>
<og:description>【使用场景】 对RDD使用join类操作，或者是在Spark SQL中使用join语句时，而且join操作中的一个RDD或表的数据量比较小（例如几百MB或者1~2GB），比较适用此方案。。 【解决方案</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wwcom123/p/10586607.html</dc:identifier>
</item>
<item>
<title>java EE中的hello1.java及Annotation(注解) - 绿水青山蓝天白云</title>
<link>http://www.cnblogs.com/cd123/p/10586528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cd123/p/10586528.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、Annotation(注解)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注解（Annotation）很重要，未来的开发模式都需要注解，注解是java.lang.annotation包，Annotation是从java5引入的，它提供一些不属于应用程序的数据，比如：一段代码的作者或者告诉编辑器禁止一些特殊的错误。Anannotation 对代码的执行没有什么影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;JDK内部提供的三个注解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       1、@Deprecated 意思是“&lt;strong&gt;废弃的，过时的&lt;/strong&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       2、@Override 意思是“&lt;strong&gt;重写、覆盖&lt;/strong&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       3、@SuppressWarnings 意思是“&lt;strong&gt;压缩警告&lt;/strong&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面主要讲解下以上的三种注解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们都知道，java中接口名、类名、属性名和方法名等的命名是有讲究的，一般类名首字母大写，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而方法名第一个字母的首字母小写，而后的其余每个单词的首字母都大写，例如&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;以AnnotationTest作为类名和以TestAnnotation作为类名是有区别的，
前者是注解的测试，符合名词的特征，后者是测试注解，听起来就是一个动作名称，是方法的命名特征&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;public class AnnotationTest {
     @SuppressWarnings(&quot;:deprecation&quot;)
    //这里就是注解，称为压缩警告，这是JDK内部自带的一个注解，一个注解就是一个类，在这里使用了这个注解就是创建了SuppressWarnings类的一个实例对象&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     @Deprecated //这也是JDK内部自带的一个注解，意思就是说这个方法已经废弃了，不建议使用了&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     public static void sayHello(){&lt;/span&gt;&lt;br/&gt;&lt;span&gt;         System.out.println(&quot;Hello World!&quot;);
     }
     @Override //这也是JDK1.5之后内部提供的一个注解，意思就是要重写(覆盖)JDK内部的toString()方法
     public String toString(){ 
         return &quot;Hello World!&quot;;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;     }
 }&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;我认为Annotation(注解)，就是给一个程序作出某一种标记，可以通过标记找到对用的程序，可以注解在类名，方法名，属性名上。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;二：javaEE官方文档上的hello1.java项目&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;hello1.java项目作为学习java web的第一个项目，我尝试着跟着官方文档，自己尝试着运行hello1,下面主要记录我运行hello1项目的过程，&lt;/span&gt;&lt;br/&gt;&lt;span&gt;该&lt;code&gt;hello1&lt;/code&gt;应用程序是一个Web模块，它使用JavaServer Faces技术来显示问候语和响应，这里我使用的是&lt;a title=&quot;NetBeans&quot; href=&quot;https://netbeans.org/&quot; target=&quot;_blank&quot;&gt;NetBeans IDE&lt;/a&gt;。此应用程序的源代码位于 &lt;code&gt;&lt;em&gt;tut-install&lt;/em&gt;/examples/web/jsf/hello1/&lt;/code&gt;目录中。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这里主要跟着官网讨论一下内容：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;1、如何使用NetBeans IDE查看hello1 Web模板&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  2、怎样打包部署hello1 web 模块&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  3、如何查看hello1&lt;/span&gt;&lt;br/&gt;&lt;span&gt;  4、运行hello1和取消hello1模块&lt;br/&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;1、如何使用NetBeans IDE查看hello1 Web模板&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;使用NetBeans IDE查看hello1的主要步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一步：从“文件”菜单中，选择“打开项目”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二步：在“打开项目”对话框中，导航至：tut-install/examples/web/jsf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code class=&quot;language-oac_no_warn&quot; data-lang=&quot;oac_no_warn&quot;&gt;第三步：&lt;/code&gt;选择&lt;code&gt;hello1&lt;/code&gt;文件夹并单击“打开项目”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第四步：展开“Web页”节点，然后双击该&lt;code&gt;index.xhtml&lt;/code&gt;文件以在编辑器中查看它。&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;strong&gt;&lt;span&gt;2、怎样打包部署hello1 web 模块&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;启动GlassFish Server。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;从“文件”菜单中，选择“打开项目”。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在“打开项目”对话框中，导航至：&lt;/span&gt;tut-install/examples/web/jsf&lt;/li&gt;
&lt;li&gt;&lt;span&gt;选择&lt;code&gt;hello1&lt;/code&gt;文件夹&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;单击打开项目。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在“项目”选项卡中，右键单击&lt;code&gt;hello1&lt;/code&gt;项目，然后选择“生成”。此命令将项目部署到服务器。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;3、如何查看hello1&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用NetBeans IDE查看已部署的Web模块：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;在“服务”选项卡中，展开“服务器”节点，然后展开“GlassFish Server”节点&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;展开“应用程序”节点以查看已部署的模块。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;要使用NetBeans IDE查看已部署的Web模块：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在“服务”选项卡中，展开“服务器”节点，然后展开“GlassFish Server”节点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;展开“应用程序”节点以查看已部署的模块。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、运行hello1和取消hello1模块&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行hello1&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;运行已部署的&lt;code&gt;hello1&lt;/code&gt;Web模块：&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot; readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;打开Web浏览器。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;输入以下URL：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;listingblock&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;content&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;prettyprint highlight&quot;&gt;
&lt;span&gt;&lt;code class=&quot;language-oac_no_warn&quot; data-lang=&quot;oac_no_warn&quot;&gt;http://localhost:8080/hello1/&lt;/code&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;在该字段中，输入您的姓名，然后单击“提交”。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;响应页面显示您提交的名称。单击“上一步”再试一次。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用NetBeans IDE取消部署hello1 Web模块，步骤如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;在“服务”选项卡中，展开“服务器”节点，然后展开“GlassFish Server”节点。 &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;展开Applications节点。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;右键单击该&lt;code&gt;hello1&lt;/code&gt;模块，然后选择“取消部署”。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;要删除类文件和其他构建工件，请返回“项目”选项卡，右键单击项目，然后选择“清理”。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;以上主要描述了什么是Annotation(注解)和讲解了怎样部署hello1项目，描述得不够深入，读者可以查看&lt;a title=&quot;Java EE官方网站文档&quot; href=&quot;https://javaee.github.io/tutorial/toc.html&quot; target=&quot;_blank&quot;&gt;java EE官方网站文档&lt;/a&gt;。&lt;/span&gt;&lt;/pre&gt;

</description>
<pubDate>Sat, 23 Mar 2019 15:52:00 +0000</pubDate>
<dc:creator>绿水青山蓝天白云</dc:creator>
<og:description>一、Annotation(注解) 注解（Annotation）很重要，未来的开发模式都需要注解，注解是java.lang.annotation包，Annotation是从java5引入的，它提供一些不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cd123/p/10586528.html</dc:identifier>
</item>
<item>
<title>Python 元祖 - 柒哥哥</title>
<link>http://www.cnblogs.com/qiyuanqiang/p/10586290.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiyuanqiang/p/10586290.html</guid>
<description>&lt;h2&gt;元祖(&lt;em&gt;&lt;em&gt;不可修改的序列&lt;/em&gt;&lt;/em&gt;)&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;&lt;span&gt;与列表一样，元祖也是序列，唯一的差别在于元祖是不能修改的。(不能修改元祖中元素指定的地址)&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;em&gt;&lt;em&gt;空元祖()&lt;/em&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;em&gt;　　&lt;span&gt;只有一个元素的元祖(23,)       注意逗号必须要&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　&lt;span&gt;tuple函数，将一个序列作为参数，并将其转换为元祖。如果参数已经是元祖，就原封不动的返回。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　str1 = tuple(['java','js'])&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;　　print(str1)　　——&amp;gt; ('java','js')&lt;/em&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 23 Mar 2019 15:38:00 +0000</pubDate>
<dc:creator>柒哥哥</dc:creator>
<og:description>元祖(不可修改的序列) 与列表一样，元祖也是序列，唯一的差别在于元祖是不能修改的。(不能修改元祖中元素指定的地址) 空元祖() 只有一个元素的元祖(23,) 注意逗号必须要 tuple函数，将一个序列</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qiyuanqiang/p/10586290.html</dc:identifier>
</item>
<item>
<title>4-2 父子组件的数据传递 - 如花红茶</title>
<link>http://www.cnblogs.com/ytraister/p/10585744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ytraister/p/10585744.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;在Vue中，父组件向子组件传值都是靠属性的形式决定的&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;编写如下代码：&lt;/span&gt;　　　　&lt;em&gt;这次用局部的形式来编写组件&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190323224230786-1310565146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;//在控制台上显示效果如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190323222233749-194065066.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; //如上，可以发现——尽管页面上的数据点击后有发生改变，可是却报了错误！！！&lt;/p&gt;
&lt;p&gt;//原因在于，我们这样的写法直接修改了从父组件传递过来的数据　　即&lt;strong&gt;单向数据流的概念：&lt;/strong&gt;父组件可以向子组件传递参数（通过属性的形式传递），传递的参数可以在父组件中随意的更改；但是，子组件却不能反过来直接去修改父组件传递过来的参数，只能去用这个传递过来的内容&lt;/p&gt;
&lt;p&gt;//修改上面的代码后，新代码如下：　　　　可以完整的实现数据点击后值变化的效果　　即定义一个data，把父组件传递过来的参数放到data中，然后再用data中的数据去引用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190323230011410-498881659.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;&lt;strong&gt;接下来，讲解一下子组件向父组件传递参数的另外一种写法：（上一章也有提及到的计数器方法）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; //代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190323232127265-339949313.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 23 Mar 2019 15:33:00 +0000</pubDate>
<dc:creator>如花红茶</dc:creator>
<og:description>在Vue中，父组件向子组件传值都是靠属性的形式决定的 编写如下代码： 这次用局部的形式来编写组件 //在控制台上显示效果如下： //如上，可以发现——尽管页面上的数据点击后有发生改变，可是却报了错误！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ytraister/p/10585744.html</dc:identifier>
</item>
<item>
<title>git 入门教程之变基合并 - 雪之梦技术驿站</title>
<link>http://www.cnblogs.com/snowdreams1006/p/10586260.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowdreams1006/p/10586260.html</guid>
<description>&lt;p&gt;&lt;code&gt;git&lt;/code&gt; 鼓励大量使用分支---&lt;strong&gt;&quot;早建分支!多用分支!&quot;&lt;/strong&gt;,这是因为即便创建再多的分支也不会造成存储或内存开销,并且分支的作用有助于我们分解逻辑工作,这样一样其实比维护单一臃肿分支要简单得多!&lt;/p&gt;
&lt;p&gt;正因如此,每个新功能会创建合并分支,修复 &lt;code&gt;bug&lt;/code&gt; 会创建合并分支等等,一段时间后再次回顾整个版本库的提交历史就会发现分支错综复杂,难以理清!&lt;/p&gt;
&lt;p&gt;虽然&quot;条条大路通罗马&quot;,但错综复杂的道路容易让人迷失方向,如果不使用分支,当然就不存在&quot;分叉问题&quot;,所以在某些情况下我们希望寻求一种替代方案来&lt;strong&gt;解决分支合并&lt;/strong&gt;带来的&lt;strong&gt;&quot;分叉问题&quot;&lt;/strong&gt;!&lt;/p&gt;
&lt;h2 id=&quot;回顾提交历史&quot;&gt;回顾提交历史&lt;/h2&gt;
&lt;p&gt;查看提交历史: &lt;code&gt;git log --pretty=oneline --graph --abbrev-commit&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 查看提交历史
$ git log --pretty=oneline --graph --abbrev-commit
* e60c8ad (HEAD -&amp;gt; dev, origin/master, origin/HEAD, master) fix bug about issue-110
* 3fe94c0 fast forward
*   22fbef7 git merge --no-ff dev
|\  
| * 44d68f6 git checkout -b dev
|/  
*   3b8f434 fix conflict
|\  
| * 0fe95f8 git commit c2
* | 0949cc3 git commit c3
|/  
* 5c482cd git commit c1
* 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html
* 9c30e50 learn git branch
* b3d8193 see https://snowdreams1006.github.io/git/usage/remote-repository.html
* 8e62564 add test.txt
* 9b196aa Initial commit&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅仅是简单的演示项目的提交历史都已经出现&quot;分叉问题&quot;,更何况真实的企业级开发项目呢?如果真的是多分支多人合作开发的话,&quot;分叉现象&quot;将更加明显,模拟效果图大概长这样:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-8e6e0f1cd3d1306d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-branch-multiple.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;整理提交历史&quot;&gt;整理提交历史&lt;/h2&gt;
&lt;p&gt;如果想要一条直路直达罗马,那我们必须规划好路径,摒弃小道,坚持主干道.&lt;code&gt;git&lt;/code&gt; 的各种 &lt;code&gt;dev&lt;/code&gt;,&lt;code&gt;feature&lt;/code&gt;等分支就是需要治理的一条条分叉小道,而 &lt;code&gt;master&lt;/code&gt; 主分支就是我们的大道.&lt;/p&gt;
&lt;p&gt;演示项目有三个分支,主干&lt;code&gt;master&lt;/code&gt;,开发&lt;code&gt;dev&lt;/code&gt;,自定义&lt;code&gt;snow&lt;/code&gt;,目标是将自定义 &lt;code&gt;snow&lt;/code&gt; 分支的工作成功整理合并到主干分支,从而解决&quot;分叉问题&quot;,&lt;code&gt;dev&lt;/code&gt; 分支与项目演示无关,无需更改.&lt;/p&gt;
&lt;p&gt;(1). 切换到 &lt;code&gt;snow&lt;/code&gt; 分支并提交一个版本(&lt;code&gt;learn git rebase&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 切换到 `snow` 分支
$ git checkout snow
Switched to branch 'snow'

# 追加新内容到 `test.txt` 文件
$ echo &quot;learn git rebase&quot; &amp;gt;&amp;gt; test.txt

# 提交到版本库
$ git commit -am &quot;learn git rebase&quot;
[snow 7d21e80] learn git rebase
 1 file changed, 1 insertion(+)
$ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-f1e1b7fcf5fb63ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-branch-rebase-snow.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(2). 切换到 &lt;code&gt;master&lt;/code&gt; 分支也提交一个版本(&lt;code&gt;modify README&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 切换回 `master` 分支
$ git checkout master
Switched to branch 'master'
Your branch is up to date with 'origin/master'.

# 追加新内容到 `README.md` 文件
$ echo &quot;learn git ,share git&quot; &amp;gt;&amp;gt; README.md

# 提交到版本库
$ git add README.md
$ git commit -m &quot;modify README&quot;
[master 3931d48] modify README
 1 file changed, 1 insertion(+)
$ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-5e9232018e0043fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-branch-rebase-master.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(3). 切换回 &lt;code&gt;snow&lt;/code&gt; 分支,整理提交历史(&lt;strong&gt;&lt;code&gt;git rebase&lt;/code&gt;&lt;/strong&gt;)到 &lt;code&gt;master&lt;/code&gt; 分支&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 切换到 `snow` 分支
$ git checkout snow
Switched to branch 'snow'

# 改变基础版本(父版本),简称&quot;变基&quot;
$ git rebase master
HEAD is up to date.

# 当前提交历史线
$ git log --pretty=oneline --graph --abbrev-commit
* e92f068 (HEAD) rebase
* 72f4c01 fix confict about happy coding
* 3931d48 (master) modify README
* e60c8ad (origin/master, origin/HEAD, dev) fix bug about issue-110
* 3fe94c0 fast forward
*   22fbef7 git merge --no-ff dev
|\  
| * 44d68f6 git checkout -b dev
|/  
*   3b8f434 fix conflict
|\  
| * 0fe95f8 git commit c2
* | 0949cc3 git commit c3
|/  
* 5c482cd git commit c1
* 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html
* 9c30e50 learn git branch
* b3d8193 see https://snowdreams1006.github.io/git/usage/remote-repository.html
* 8e62564 add test.txt
* 9b196aa Initial commit
$ &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-45507c0c6329268a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-branch-rebase.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(4). 切换回 &lt;code&gt;master&lt;/code&gt; 主干分支再次&lt;strong&gt;变基&lt;/strong&gt;合并 &lt;code&gt;snow&lt;/code&gt; 分支&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 切换回 `master` 分支
$ git checkout master
Warning: you are leaving 2 commits behind, not connected to
any of your branches:

  e92f068 rebase
  72f4c01 fix confict about happy coding

If you want to keep them by creating a new branch, this may be a good time
to do so with:

 git branch &amp;lt;new-branch-name&amp;gt; e92f068

Switched to branch 'master'
Your branch is ahead of 'origin/master' by 1 commit.
  (use &quot;git push&quot; to publish your local commits)

# 改变父版本为 `snow` 分支指向的版本  
$ git rebase snow
First, rewinding head to replay your work on top of it...
Applying: modify README
$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-7919d0c7e8b03ef4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;git-branch-rebase-back-master.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(5). 整理分支完成,最终主干分支是一条直线&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 查看提交历史线
$ git log --pretty=oneline --graph --abbrev-commit

# `modify README` 是 `master` 分支提交的版本
* dcce09c (HEAD -&amp;gt; master) modify README

# `learn git rebase` 是 `snow` 分支提交的版本
* 7d21e80 (snow) learn git rebase
*   a06a866 fix conflict
|\  
| * e60c8ad (origin/master, origin/HEAD, dev) fix bug about issue-110
* | ab846f9 learn git stash
* | 93227ba Happy coding
|/  
* 3fe94c0 fast forward
*   22fbef7 git merge --no-ff dev
|\  
| * 44d68f6 git checkout -b dev
|/  
*   3b8f434 fix conflict
|\  
| * 0fe95f8 git commit c2
* | 0949cc3 git commit c3
|/  
* 5c482cd git commit c1
* 413a4d1 see https://snowdreams1006.github.io/git/usage/branch-overview.html
* 9c30e50 learn git branch
* b3d8193 see https://snowdreams1006.github.io/git/usage/remote-repository.html
* 8e62564 add test.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一次我们没有使用 &lt;code&gt;git merge&lt;/code&gt; 而是采用 &lt;code&gt;git rebase&lt;/code&gt; 方式完成了分支的合并,优点是提交历史更清晰,缺点是丢失了分支信息.&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;git rebase&lt;/code&gt; 变基合并分支,实际上就是取出一系列的提交版本并“复制”到目标版本,从而形成一条新的提交历史线.&lt;br/&gt;比如我们想要把 &lt;code&gt;bugFix&lt;/code&gt; 分支里的工作直接移到 &lt;code&gt;master&lt;/code&gt; 分支上,移动以后会使得两个分支的功能&lt;strong&gt;看起来像&lt;/strong&gt;是按顺序开发,但实际上它们是&lt;strong&gt;并行开发&lt;/strong&gt;的,这就是 &lt;code&gt;git rebase&lt;/code&gt; 的作用.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;git rebase&lt;/code&gt; 的优势是创造更线性的提交历史,使得代码库的提交历史变得异常清晰,劣势是缺失了分支信息,好像从没存在过该分支一样.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将目标分支上的工作成果转移到到主干分支 : &lt;code&gt;git rebase master&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主干分支接收已转移好的目标分支工作成果 : &lt;code&gt;git rebase &amp;lt;branch&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 23 Mar 2019 15:29:00 +0000</pubDate>
<dc:creator>雪之梦技术驿站</dc:creator>
<og:description>`git` 鼓励大量使用分支 '早建分支!多用分支!' ,这是因为即便创建再多的分支也不会造成存储或内存开销,并且分支的作用有助于我们分解逻辑工作,这样一样其实比维护单一臃肿分支要简单得多! 正因如此</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowdreams1006/p/10586260.html</dc:identifier>
</item>
<item>
<title>es6 Promise事件执行机制 - Mr郝123</title>
<link>http://www.cnblogs.com/loveless9425/p/10586232.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/loveless9425/p/10586232.html</guid>
<description>&lt;p&gt;     最近在学习es6的Promise，其中涉及到了Promsie的事件执行机制，因此总结了关于Promise的执行机制，若有错误，欢迎纠错和讨论。&lt;/p&gt;
&lt;p&gt;     在阮一峰老师的书中《es6 标准入门》对Promise的基础知识做出了详细的介绍，在此就不一一介绍了，直接开始整体，将Promsie中关于事件执行机制的问题与大家分享。&lt;/p&gt;
&lt;h2&gt;    1.Promsie对象的创建以及执行顺序&lt;/h2&gt;
&lt;p&gt;     创建方式：new Promise(function(resolve,reject){ //...}&lt;/p&gt;
&lt;p&gt;     这种方式在阮老师的书中指出该函数一旦创建，其内部的匿名函数会自动执行，在这里我们可以认为这种方式相当于同步任务会直接执行。以下代码亦可证明。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve,reject){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     console.log('1'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; console.log('2');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609315/201903/1609315-20190323210914529-822193284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结论：从结果的顺序来看，的确new Promise会立即执行，执行完后再继续执行后面的同步任务。&lt;/p&gt;

&lt;h2&gt;    2.Promsie对象中的then()方法&lt;/h2&gt;
&lt;p&gt;     Promise中的then()会根据Promsie的状态执行相应的回调函数，方法中有两个参数，分别是回调成功和回调失败时执行的函数。该函数是个&lt;span&gt;异步任务&lt;/span&gt;。在此补充下关于JS内部的机制。众所周知，JS是单线程的，也就意味着无法同时做好几件事情，只能一件一件的做。代码执行时分为同步任务和异步任务，同步任务会在当前主线程中完成，执行中将变量和对象放入堆中，方法调用运行压入执行栈，需要变量时从堆中获取。而异步任务又可以分为microtask(微任务)和macrotask(宏任务),可以简单的理解为任务队列，通常将键盘事件和鼠标事件以及setTimeout()等归为宏任务，而我们的Promsie的then()归为微任务，执行中遇到他们会将他们放入相应的任务队列中。&lt;/p&gt;
&lt;p&gt;      在主线程的任务完成后会立即查看microtask是否有任务需要执行，若有则会执行直到队列为空队列，若本身为空则会查看macrotask任务队列，执行该队列中的第一个命令，当执行完第一条命令后会再次查看microtask是否有代码需要执行，同理，有则执行至空队列否则再次查看macrotask。&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;注意：这里的过程相当于macrotask任务队列的任务执行一次，则microtask任务队列的任务会全部执行。microtask全部任务执行完才会再去执行macrotask的下一条命令。&lt;/span&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve,reject){
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     resolve('1'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(value){
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    console.log(value);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }).&lt;span&gt;catch&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(error){
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     console.log('出错了,'&lt;span&gt;,error);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; console.log('2');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609315/201903/1609315-20190323212509522-1064575753.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;结论:从上述结果来看，代码会立即执行new Promise中的代码，此时Prosmie状态改为resolved,而后调用then()方法，此时将该函数放入mircotask队列中，向下继续执行同步任务，待同步任务执行完后再回来执行mircotask中的函数。&lt;/p&gt;

&lt;h2&gt;     3.Promsie和setTimeout的执行机制分析&lt;/h2&gt;
&lt;p&gt;      此处直接引入一个例子作为介绍&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     console.log('1111111'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     setTimeout(() =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;       console.log('4----'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;       &lt;span&gt;new&lt;/span&gt; Promise((resolve) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         console.log('5-----'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        resolve();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;       }).then(() =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         console.log('6----'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;      })
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;new&lt;/span&gt; Promise((resolve) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;       console.log('22222'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;      resolve();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     }).then(() =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       console.log('33333-----'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    })
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     setTimeout(() =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       console.log('77777'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       &lt;span&gt;new&lt;/span&gt; Promise((resolve) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         console.log('888'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        resolve();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;       }).then(() =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         console.log('9999999'&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;      })
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     })
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码分析：&lt;/p&gt;
&lt;p&gt;     分析之前我们可以先在自己的小本本上写2列事件任务分类，分别是microtask微任务和macrotask宏任务，等下我们在分析代码时候可以模拟引擎的执行顺序将其写入小本子上，便于我们分析。&lt;/p&gt;
&lt;p&gt;回归正题，1.首先第一行执行输出打印任务，这个是同步任务没什么说的，直接输出；&lt;/p&gt;
&lt;p&gt;               2.下一行遇到了setTimeout()事件，先不管内部是什么函数，先将这个函数放入到我们的macrotask任务队列中第一行的位置等待执行；&lt;/p&gt;
&lt;p&gt;               3.又遇到了new  Promise，之前我们讲到，可以把它看成是同步任务所以直接执行其内部的代码，首先打印输出，之后遇到resovle()，此时Promsie的状态改为resolved,并且值为‘22222’，之后调用then(),该方法是个异步任务，所以同样不管内部代码是什么，将其放入我们的microtask任务队列的第一行中等待执行；&lt;/p&gt;
&lt;p&gt;               4.之后又遇到了setTimeout()，同样不管其内部代码直接加入macrotask任务中；&lt;/p&gt;
&lt;p&gt;       此时我们的同步任务执行完毕，我们整理下我们刚刚写下的2个任务队列中都有什么函数，在microtask中，有一个then()方法的函数，在macrotask任务队列中有2个按照执行顺序加入的setTimeout()。&lt;/p&gt;
&lt;p&gt;       主线程任务执行后会直接去执行microtask的任务，所以下一步开始执行microtask任务队列中的函数，输出打印‘33333-----’，此时microtask任务队列中的任务队列执行完毕并且后面没有其他任务了，此时队列为空，这个时候会去执行macrotask的第一个函数，首先输出打印，遇到Promise对象直接执行，并且状态改为resolved,执行then()，将其函数加入到microtask中，此时该setTImeout执行完毕，这个时候会去再去看microtask是否为空，这个时候发现我们刚刚加入了一个指令，所以直接执行，执行完后microtask又没有任务了，这个时候再去执行macrotask的下一条任务，同样执行完再去执行我们刚刚再次向microtask加入的新任务，至此执行完毕。&lt;/p&gt;
&lt;p&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1609315/201903/1609315-20190323215930513-1822511801.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家可以看看是否和大家推到的一样。&lt;/p&gt;
&lt;h2&gt;       4.关于resolve()参数的问题&lt;/h2&gt;
&lt;p&gt;               在这里参数是非promise对象就不探讨了，调用resolve()和reject()就决定了promise对象的状态了。这里讨论下参数是promise对象的问题。首先，给出一段代码。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; p1=&lt;span&gt;Promise.resolve();
 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p2=Promise.reject('出错了'&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p3=&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve,reject){
              resolve(p1);
 }).then(()&lt;/span&gt;=&amp;gt;console.log('p3状态为resolved'),()=&amp;gt;console.log('p3状态为reject'&lt;span&gt;));
 &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; p4=&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve,reject){
              resolve(p2);
 }).then(()&lt;/span&gt;=&amp;gt;console.log('p3状态为resolved'),()=&amp;gt;console.log('p3状态为reject'));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609315/201903/1609315-20190323222032074-1790303248.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     阮老师在书中指出传入参数为Promsie对象时p1的状态会决定p2的状态。从上面的代码中可以看到，p1和p2直接决定了p3和p4的状态，不会管resolve(),也验证了阮老师的说法。另外，当resolve()改为reject()方法时，我们发现不管参数的状态是什么最后Promise对象的状态都会变为reject。&lt;/p&gt;
&lt;p&gt;    &lt;span&gt; 另外，参数为Promise对象时，引擎会先去获取参数的状态，获得状态在返回决定当前Promise对象的状态，而获取Promsie对象状态的过程我们可以认为是异步，也就是将此过程直接加入到microtask任务队列中。当参数是thenable对象时，会调用其中的then方法，该过程也可以看成是异步的。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;var&lt;/span&gt; p1=&lt;span&gt;Promise.resolve();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;    &lt;span&gt;var&lt;/span&gt; p2=&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve,reject){
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;          resolve(p1);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;   });
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; p2.then(()=&amp;gt;console.log(2));&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;console.log(p2);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; setTimeout(()=&amp;gt;console.log(p2),3000);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609315/201903/1609315-20190323224817977-534778770.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　我们发现此时p2的状态并没有直接变为resolved，而是pending,在延迟3s后再判断p2的状态，此时已经变成了resolved,这样证实了我们的想法。参数为thenable对象时也表现出同样的结果。下面代码。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; p1=&lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;       then(resolve,reject){
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;           resolve();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;       }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;   }
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;    &lt;span&gt;var&lt;/span&gt; p2=&lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve,reject){
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;          resolve(p1);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;   });
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;console.log(p2);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; setTimeout(()=&amp;gt;console.log(p2),3000);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609315/201903/1609315-20190323225248619-441822256.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;     5.关于resovle(Promise.resolve())的异步执行机制&lt;/h2&gt;
&lt;p&gt;          此处问题也是困扰我好久的一个问题。这里首先需要验证下Promise.resolve()是否是同步的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;    &lt;span&gt;var&lt;/span&gt; p1=&lt;span&gt;Promise.resolve();
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;console.log(p1);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; setTimeout(()=&amp;gt;console.log(p1),3000);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609315/201903/1609315-20190323230158964-76913324.png&quot; alt=&quot;&quot;/&gt;      &lt;/p&gt;
&lt;p&gt;从结果来看，p1确实是同步执行的。并且该方法会返回一个新的Promise对象。回到正题，前面讲到resolve()参数是Promsie对象时候去查询参数状态是个异步的，但这个时候我们发现在查询之前参数的状态其实已经确定了，引擎只是去获取状态，而此时我们的resolve(Promise.resolve()),内部并非一个已经确定的Promise对象，而是一个待执行的命令，因此这里会分两步走，第一步，异步执行执行Promise.resolve()命令，此时将新产生的Promsie对象的状态确定下来，name这个时候该函数就变成了前面我们讲到的那个样式，这个时候再执行异步操作获取参数的状态。&lt;/p&gt;
&lt;p&gt;下面分析下之前困扰我好久的那个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   console.log(&quot;async1 start&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   console.log(&quot;async2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  resolve(Promise.resolve());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; }).then(() =&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   console.log(&quot;async1 end&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(resolve) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;   console.log(&quot;promise1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  resolve();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   console.log(&quot;promise2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   console.log(&quot;promise3&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }).then(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   console.log(&quot;promise4&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1609315/201903/1609315-20190323230922284-1848737735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  除IE外均测试，其结果一致。这里按照我们刚才的思维分析，首先输出async1和async2，此时将Promise.resolve()压入microtask,继续向后执行，遇到新的Promise，输出promise1，改变状态此时将then()的函数压入microtask,这个时候主线程执行完毕，开始执行microtask,Promise.resolve()执行完毕，得到确定状态的新的Promise对象，此时resolve()为获取该Promsie状态将该过程加入到刚才的microtask任务队列中，这个时候任务队列有2个，一个是输出promise2的命令，其后面紧跟获取状态的命令，所以执行输出Promise2的命令，执行完毕后又将下一个then()方法中的Promise3命令添加到获取状态的后面，这个时候再去执行获取状态的命令，得到了状态执行resolve()，触发then()，将输出async end的命令添加到Promise3输出的后面，下一步执行输出Promise3，触发then()，将Promise4输出命令加入到输出async end命令后面，这个时候执行async end输出和Promise4输出，执行完毕。&lt;/p&gt;

&lt;p&gt;至此，Promise中的异步机制总结完了，欢迎大家留言指正和批评，和大家一起进步。&lt;/p&gt;
</description>
<pubDate>Sat, 23 Mar 2019 15:24:00 +0000</pubDate>
<dc:creator>Mr郝123</dc:creator>
<og:description>最近在学习es6的Promise，其中涉及到了Promsie的事件执行机制，因此总结了关于Promise的执行机制，若有错误，欢迎纠错和讨论。 在阮一峰老师的书中《es6 标准入门》对Promise的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/loveless9425/p/10586232.html</dc:identifier>
</item>
<item>
<title>李宏毅机器学习笔记3：Classification、Logistic Regression - 控球强迫症</title>
<link>http://www.cnblogs.com/XDU-Lakers/p/10574955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/XDU-Lakers/p/10574955.html</guid>
<description>&lt;p&gt;&lt;span&gt;李宏毅老师的机器学习课程和吴恩达老师的机器学习课程都是都是ML和DL非常好的入门资料，在YouTube、网易云课堂、B站都能观看到相应的课程视频，接下来这一系列的博客我都将记录老师上课的笔记以及自己对这些知识内容的理解与补充。(本笔记配合李宏毅老师的视频一起使用效果更佳！）&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt;&lt;span&gt;ML Lecture 4:Classification：Probabilistic Generative Model&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在这堂课中，老师主要根据宝可梦各属性值预测其类型为例说明分类问题，其训练数据为若干宝可梦的各属性值及其类型。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.分类问题不能当成回归问题来处理。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设还不了解怎么做，但之前已经学过了regression。就把分类当作回归硬解。举一个二分类的例子：假设输入xx 属于类别1，或者类别2，把这个当作回归问题：类别1就当作target是1，类别2就当作target是-1。训进行训练：因为是个数值，如果数值比较接近1，就当作类别1，如果数值接近-1，就当做类别2。这样做遇到什么问题？如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190321202703327-760521543.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;左边绿色的线是分界线，绿色线左边红色点就是-1的，绿色线右边蓝色点就是1的。但是如果训练集有很多的距离远大于1的点，比如有图右下角所示，这样用回归的方式硬训练可能会得到紫色的这条。直观上就是将绿色的线偏移一点到紫色的时候，就能让右下角的那部分的值不是那么大了。但实际是绿色的才是比较好的，用回归硬训练并不会得到好结果。此时可以得出用回归的方式定义，对于分类问题来说是不适用的。还有另外一个问题：比如多分类，类别1当作target1，类别2当作target2，类别3当作target3…如果这样做的话，就会认为类别2和类别3是比较接近的，认为它们是有某种关系的；认为类别1和类别2也是有某种关系的，比较接近的。但是实际上这种关系不存在，它们之间并不存在某种特殊的关系。这样是没有办法得到好的结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.Ideal Alternatives（理想替代品）-- Generative Model&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设现在宝可梦只有两类，要预测x属于哪类，若P(C1|x)&amp;gt;0.5则属于第一类，否则属于第二类。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;计算P(C1|x)要用到贝叶斯公式，对Generative Model，P(x)=P(x|C1)P(C1)+P(x|C2)P(C2)是可算的，从训练数据中估计P(C1)、P(C2)、P(x|C1)、P(x|C2)这四个值。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; P(C1)、P(C2)容易估计，算一下训练数据里两类各占多少就可以了。 要估计P(x|C1)、P(x|C2)就需要做一些假设。 我们假设训练数据中所有的第一类/第二类数据，都是分别从两类对应的高斯分布产生的。 理论上任何参数（μ,∑）的高斯分布都可以产生训练数据，只是likelihood不同。 用&lt;strong&gt;最大似然的方法&lt;/strong&gt;可以得出，使得似然函数最大的参数（μ∗,∑∗）分别是训练数据中该类数据的平均值和协方差矩阵。 这样就可以求得P(C1|x)了。&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;maximum-likelihood最大似然估计&quot;&gt;Maximum Likelihood（最大似然估计）&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190321210740807-615844122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将使得 L(μ,Σ)最大的 (μ,Σ)记做 (μ∗,Σ∗)，(μ∗,Σ∗)就是所有 (μ,Σ) 的 Maximum Likelihood（最大似然估计)!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190321210906480-1139918481.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这些解法很直接，直接对&lt;span id=&quot;MathJax-Element-32-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;L&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03BC;&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi mathvariant=&amp;quot;normal&amp;quot;&amp;gt;&amp;amp;#x03A3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-296&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-297&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-298&quot; class=&quot;mi&quot;&gt;L&lt;span id=&quot;MathJax-Span-299&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-300&quot; class=&quot;mi&quot;&gt;μ&lt;span id=&quot;MathJax-Span-301&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-302&quot; class=&quot;mi&quot;&gt;Σ&lt;span id=&quot;MathJax-Span-303&quot; class=&quot;mo&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;L(μ,Σ) 求两个偏微分，求偏微分是0的点。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后应用最大似然估计，在考虑了宝可梦的7种特征的情况下，这样的分类方法在测试集上的正确率只有54%。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Generative Model整个模型流程：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）要预测x属于哪类，若P(C1|x)&amp;gt;0.5则属于第一类，否则属于第二类。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）计算P(C1|x)要用到贝叶斯公式，对Generative Model，P(C1|x)=P(x|C1)P(C1)+P(x|C2)P(C2)是可算的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（3）理论上任何参数（μ,∑）的高斯分布都可以产生训练数据，所以可以估计P(x|C1)、P(x|C2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（4）利用&lt;strong&gt;最大似然的方法&lt;/strong&gt;，可以求出让似然函数最大的参数（μ∗,∑∗），这两个参数分别是训练数据中该类数据的平均值和协方差矩阵。 这样就可以求得P(C1|x)了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;也就是第一节课说的三大步：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190321212518256-165449392.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 3.模型修改&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通常来说，不会给每个高斯分布都计算出一套不同的最大似然估计，协方差矩阵是和输入feature大小的平方成正比，所以当feature很大的时候，协方差矩阵是可以增长很快的。此时考虑到model参数过多，容易Overfitting，为了有效减少参数，给描述这两个类别的高斯分布相同的协方差矩阵，如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190321212225603-818461707.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时修改似然函数为 &lt;span id=&quot;MathJax-Element-36-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;L&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03BC;&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03BC;&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi mathvariant=&amp;quot;normal&amp;quot;&amp;gt;&amp;amp;#x03A3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-324&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-325&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-326&quot; class=&quot;mi&quot;&gt;L&lt;span id=&quot;MathJax-Span-327&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-328&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-329&quot; class=&quot;mi&quot;&gt;μ&lt;span id=&quot;MathJax-Span-330&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-331&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-332&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-333&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-334&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-335&quot; class=&quot;mi&quot;&gt;μ&lt;span id=&quot;MathJax-Span-336&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-337&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-338&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-339&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-340&quot; class=&quot;mi&quot;&gt;Σ&lt;span id=&quot;MathJax-Span-341&quot; class=&quot;mo&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;。&lt;span id=&quot;MathJax-Element-37-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03BC;&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;msup&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03BC;&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msup&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-342&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-343&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-344&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-345&quot; class=&quot;mi&quot;&gt;μ&lt;span id=&quot;MathJax-Span-346&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-347&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-348&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-349&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-350&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-351&quot; class=&quot;mi&quot;&gt;μ&lt;span id=&quot;MathJax-Span-352&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-353&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-354&quot; class=&quot;mn&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt; 计算方法和上面相同，分别加起来平均即可；而&lt;span id=&quot;MathJax-Element-38-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi mathvariant=&amp;quot;normal&amp;quot;&amp;gt;&amp;amp;#x03A3;&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-355&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-356&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-357&quot; class=&quot;mi&quot;&gt;Σ&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;的计算有所不同，&lt;span id=&quot;MathJax-Span-25&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-26&quot; class=&quot;mo&quot;&gt;∑&lt;span id=&quot;MathJax-Span-27&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-28&quot; class=&quot;mi&quot;&gt;P&lt;span id=&quot;MathJax-Span-29&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-30&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-31&quot; class=&quot;mi&quot;&gt;C&lt;span id=&quot;MathJax-Span-32&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-33&quot; class=&quot;mo&quot;&gt;)&lt;span id=&quot;MathJax-Span-34&quot; class=&quot;munderover&quot;&gt;&lt;span id=&quot;MathJax-Span-35&quot; class=&quot;mo&quot;&gt;∑&lt;span id=&quot;MathJax-Span-36&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-37&quot; class=&quot;mo&quot;&gt;+&lt;span id=&quot;MathJax-Span-38&quot; class=&quot;mi&quot;&gt;P&lt;span id=&quot;MathJax-Span-39&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-40&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-41&quot; class=&quot;mi&quot;&gt;C&lt;span id=&quot;MathJax-Span-42&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-43&quot; class=&quot;mo&quot;&gt;)&lt;span id=&quot;MathJax-Span-44&quot; class=&quot;munderover&quot;&gt;&lt;span id=&quot;MathJax-Span-45&quot; class=&quot;mo&quot;&gt;∑&lt;span id=&quot;MathJax-Span-46&quot; class=&quot;mn&quot;&gt;2&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最终的分类结果为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;右图新的结果，分类的boundary是线性的，所以也将这种分类叫做 linear model。如果考虑所有的属性，发现正确率提高到了73%&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190321212353830-1611529413.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; 4.Warning：数学推导&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么当两个类别拥有相同的协方差矩阵的高斯分布时，分界线是一条直线呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;将 &lt;span id=&quot;MathJax-Element-42-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;P&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;C&amp;lt;/mi&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-404&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-405&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-406&quot; class=&quot;mi&quot;&gt;P&lt;span id=&quot;MathJax-Span-407&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-408&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-409&quot; class=&quot;mi&quot;&gt;C&lt;span id=&quot;MathJax-Span-410&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-411&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-412&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-413&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-414&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-415&quot; class=&quot;mo&quot;&gt;|&lt;span id=&quot;MathJax-Span-416&quot; class=&quot;mi&quot;&gt;x&lt;span id=&quot;MathJax-Span-417&quot; class=&quot;mo&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;P(C1|x)整理，得到一个 &lt;span id=&quot;MathJax-Element-43-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03C3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;z&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-418&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-419&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-420&quot; class=&quot;mi&quot;&gt;σ&lt;span id=&quot;MathJax-Span-421&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-422&quot; class=&quot;mi&quot;&gt;z&lt;span id=&quot;MathJax-Span-423&quot; class=&quot;mo&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;σ(z)，这叫做Sigmoid function。如下图所示：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190321214852880-1739973360.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接下去一步一步推导出Z：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190321215033465-1416999025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190321215043834-2089525079.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190321215052215-1280994087.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190321215134311-1397506821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;化简x的系数记做向量wT，后面3项结果都是标量，所以三个数字加起来记做b。最后P(C1|x)=σ(w⋅x+b)。从这个式子也可以看出上述当共用协方差矩阵的时候，为什么分界线是线性的。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;lecture-5-logistic-regression&quot;&gt;&lt;span&gt;Lecture 5: Logistic Regression&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;1.在Lecture 4中我们提到，当w、b取任意值的时候，&lt;span id=&quot;MathJax-Element-15-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;P&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;C&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03C3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;z&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03C3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#xB7;&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;+&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-125&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-126&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-127&quot; class=&quot;mi&quot;&gt;P&lt;span id=&quot;MathJax-Span-128&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-129&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-130&quot; class=&quot;mi&quot;&gt;C&lt;span id=&quot;MathJax-Span-131&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-132&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-133&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-134&quot; class=&quot;mo&quot;&gt;|&lt;span id=&quot;MathJax-Span-135&quot; class=&quot;mi&quot;&gt;x&lt;span id=&quot;MathJax-Span-136&quot; class=&quot;mo&quot;&gt;)&lt;span id=&quot;MathJax-Span-137&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-138&quot; class=&quot;mi&quot;&gt;σ&lt;span id=&quot;MathJax-Span-139&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-140&quot; class=&quot;mi&quot;&gt;z&lt;span id=&quot;MathJax-Span-141&quot; class=&quot;mo&quot;&gt;)&lt;span id=&quot;MathJax-Span-142&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-143&quot; class=&quot;mi&quot;&gt;σ&lt;span id=&quot;MathJax-Span-144&quot; class=&quot;mo&quot;&gt;(&lt;span id=&quot;MathJax-Span-145&quot; class=&quot;mi&quot;&gt;w&lt;span id=&quot;MathJax-Span-146&quot; class=&quot;mo&quot;&gt;⋅&lt;span id=&quot;MathJax-Span-147&quot; class=&quot;mi&quot;&gt;x&lt;span id=&quot;MathJax-Span-148&quot; class=&quot;mo&quot;&gt;+&lt;span id=&quot;MathJax-Span-149&quot; class=&quot;mi&quot;&gt;b&lt;span id=&quot;MathJax-Span-150&quot; class=&quot;mo&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span id=&quot;MathJax-Element-15-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;P&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;C&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03C3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;z&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03C3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#xB7;&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;+&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-125&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-126&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-127&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-128&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-129&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-130&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-131&quot; class=&quot;mn&quot;&gt;&lt;span id=&quot;MathJax-Span-132&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-133&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-134&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-135&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-136&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-137&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-138&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-139&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-140&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-141&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-142&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-143&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-144&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-145&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-146&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-147&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-148&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-149&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-150&quot; class=&quot;mo&quot;&gt;就构成了function set。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span id=&quot;MathJax-Element-15-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;P&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;C&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03C3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;z&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03C3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#xB7;&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;+&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-125&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-126&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-127&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-128&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-129&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-130&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-131&quot; class=&quot;mn&quot;&gt;&lt;span id=&quot;MathJax-Span-132&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-133&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-134&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-135&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-136&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-137&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-138&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-139&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-140&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-141&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-142&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-143&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-144&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-145&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-146&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-147&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-148&quot; class=&quot;mo&quot;&gt;&lt;span id=&quot;MathJax-Span-149&quot; class=&quot;mi&quot;&gt;&lt;span id=&quot;MathJax-Span-150&quot; class=&quot;mo&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;P&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;C&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03C3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;z&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03C3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#xB7;&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;+&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;math&quot;&gt;&lt;span class=&quot;mrow&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mo&quot;&gt;&lt;span class=&quot;msubsup&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mn&quot;&gt;&lt;span class=&quot;texatom&quot;&gt;&lt;span class=&quot;mrow&quot;&gt;&lt;span class=&quot;mo&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mo&quot;&gt;&lt;span class=&quot;mo&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mo&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mo&quot;&gt;&lt;span class=&quot;mo&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mo&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mo&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mo&quot;&gt;&lt;span class=&quot;mi&quot;&gt;&lt;span class=&quot;mo&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190323213603090-522482544.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.逻辑回归Logistic Regression与线性回归Linear Regression的区别&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;（1）Step1：选择model&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190323213736810-622711339.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（2）评价函数好坏（（第二行等号右侧缺少一个负号） ）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190323213942212-335370877.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对训练数据(x1,C1)(x2,C1)(x3,C2)……用&lt;span id=&quot;MathJax-Element-17-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mover&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;&amp;amp;#x005E;&amp;lt;/mo&amp;gt;&amp;lt;/mover&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-156&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-157&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-158&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-159&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-160&quot; class=&quot;munderover&quot;&gt;&lt;span id=&quot;MathJax-Span-161&quot; class=&quot;mi&quot;&gt;y&lt;span id=&quot;MathJax-Span-162&quot; class=&quot;mo&quot;&gt;^&lt;span id=&quot;MathJax-Span-163&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-164&quot; class=&quot;mn&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt; 表示C1，用&lt;span id=&quot;MathJax-Element-18-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mover&amp;gt;&amp;lt;mi&amp;gt;y&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;&amp;amp;#x005E;&amp;lt;/mo&amp;gt;&amp;lt;/mover&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mn&amp;gt;0&amp;lt;/mn&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-165&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-166&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-167&quot; class=&quot;texatom&quot;&gt;&lt;span id=&quot;MathJax-Span-168&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-169&quot; class=&quot;munderover&quot;&gt;&lt;span id=&quot;MathJax-Span-170&quot; class=&quot;mi&quot;&gt;y&lt;span id=&quot;MathJax-Span-171&quot; class=&quot;mo&quot;&gt;^&lt;span id=&quot;MathJax-Span-172&quot; class=&quot;mo&quot;&gt;=&lt;span id=&quot;MathJax-Span-173&quot; class=&quot;mn&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;表示C2。那么逻辑回归的似然函数可以表示为 ：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190323214026725-2019187577.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最大化似然函数即是最小化交叉熵。交叉熵代表两个分布有多接近，若两个分布完全一样则交叉熵等于0。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;逻辑回归Logistic Regression：评价function采用交叉熵损失&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线性回归Linear Regression：评价function采用平方误差损失&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;（3） find the best function，都采用梯度下降&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;逻辑回归Logistic Regression与线性回归Linear Regression在用梯度下降法更新参数时公式相同。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190323214222713-2013895935.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.Logistic Regression损失函数的选取&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;到目前为止，肯定很多人和我一样有个疑惑？为什么Logistic Regression用交叉熵损失而不用平方误差损失呢？ 接下来就让我为你解惑：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果用平方误差损失，在计算&lt;/span&gt;Logistic Regression&lt;span&gt;损失函数对参数的微分时会出现如下情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190323214414780-323194220.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上图充分表明了：&lt;span&gt;在我们得出的结果far from target 时，微分很小。微分很小就代码的梯度下降变的很慢，甚至会出现错误。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 为了更形象的说明问题，将交叉熵损失/平方误差损失与参数之间的关系画出来： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190323214548552-763341026.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 总结:&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.离目标远，cross entropy微分大，square error微分小。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.离目标近，cross entropy微分小，square error微分小。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.不管离目标远还是近，square error微分都小。所以微分小的时候，不知道离目标远还是近。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.用cross entropy可以让training顺利很多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.Discriminative model(判别方法) VS Generative model(生成方法)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（1）通过这次学习，我们可以发现判别方法和生成方法的模型是一样的：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190323220320753-260893961.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;（2）区别在于：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;判别方法，通过梯度下降，直接找到&lt;span id=&quot;MathJax-Element-19-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-174&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-175&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-176&quot; class=&quot;mi&quot;&gt;w&lt;span id=&quot;MathJax-Span-177&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-178&quot; class=&quot;mi&quot;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;w,b。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span id=&quot;MathJax-Element-19-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;生成方法，通过估计&lt;span id=&quot;MathJax-Element-20-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;N&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;N&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03BC;&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03BC;&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;2&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#x2211;&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-179&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-180&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-181&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-182&quot; class=&quot;mi&quot;&gt;N&lt;span id=&quot;MathJax-Span-183&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-184&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-185&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-186&quot; class=&quot;mi&quot;&gt;N&lt;span id=&quot;MathJax-Span-187&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-188&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-189&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-190&quot; class=&quot;mi&quot;&gt;μ&lt;span id=&quot;MathJax-Span-191&quot; class=&quot;mn&quot;&gt;1&lt;span id=&quot;MathJax-Span-192&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-193&quot; class=&quot;msubsup&quot;&gt;&lt;span id=&quot;MathJax-Span-194&quot; class=&quot;mi&quot;&gt;μ&lt;span id=&quot;MathJax-Span-195&quot; class=&quot;mn&quot;&gt;2&lt;span id=&quot;MathJax-Span-196&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-197&quot; class=&quot;mo&quot;&gt;∑&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt; 来得到&lt;span id=&quot;MathJax-Element-21-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-198&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-199&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-200&quot; class=&quot;mi&quot;&gt;w&lt;span id=&quot;MathJax-Span-201&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-202&quot; class=&quot;mi&quot;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;w,b 。 &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么问题来了，我们该如何选择模型呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样的模型，同样的训练数据，采用两种方法所得结果（&lt;span id=&quot;MathJax-Element-22-Frame&quot; class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span id=&quot;MathJax-Span-203&quot; class=&quot;math&quot;&gt;&lt;span id=&quot;MathJax-Span-204&quot; class=&quot;mrow&quot;&gt;&lt;span id=&quot;MathJax-Span-205&quot; class=&quot;mi&quot;&gt;w&lt;span id=&quot;MathJax-Span-206&quot; class=&quot;mo&quot;&gt;,&lt;span id=&quot;MathJax-Span-207&quot; class=&quot;mi&quot;&gt;b&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;）不同。因为生成方法对概率分布做了假设。 &lt;span&gt;通常来说Discriminative model 比Generative model表现更好。&lt;span&gt;下面看一个例子&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;,&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190323220859355-1391505849.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们能明显看出Testing Data应该属于class1,Discriminative model的结果也是class 1,然而朴素贝叶斯的结果是Class 2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;虽然生成模型的效果没有那么出色，那是不是生成模型就没有自己的优势呢？答案并不是。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （3）生成模型在一些情况下相对判别模型是有优势的： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1)、训练数据较少时。判别模型的表现受数据量影响较大，而生成模型受数据量影响较小。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2)、label有噪声时。生成模型的假设（“脑补”）反而可以把数据中的问题忽视掉。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;3)、判别模型直接求后验概率，而生成模型将后验概率拆成先验和似然，而先验和似然可能来自不同来源。以语音识别（生成模型）为例，DNN只是其中一部分，还需要从大量文本（不需要语音）中计算一句话说出来的先验概率。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;5.&lt;/span&gt;&lt;/span&gt;&lt;span&gt;Multi-class Classification&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在做Multi-class Classification时，需要softmax。原因可参考Bishop P209-210，或Google “maximum entropy”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190323221611196-800725968.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.到目前为止，我们了解的Logistic Regression是完美的，但它有没有局限性呢?答案是肯定有的，接下来让我们一起看看它的局限性。(&lt;span&gt;说点题外话，在学到这的时候，我是非常佩服李宏毅老师，它完美的在此基础上引入了神经网络的概念！！！同时老师上课给的例子我觉得也是非常perfect&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; （1）不能表示XOR。（边界是直线。） &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解决方法：做&lt;span&gt;feature transformation&lt;/span&gt;. (Not always easy to find a good transformation.) &lt;/span&gt;&lt;br/&gt;&lt;span&gt;希望机器自己找到 transformation：&lt;span&gt;把多个Logistic Regression接起来。 &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190323222036621-1045461748.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一个Logistic Regression的input可以是其它Logistic Regression的output；一个Logistic Regression的output可以是其它Logistic Regression的input。这样，我们就完成了feature transformation。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如下图所示：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1179840/201903/1179840-20190323222352022-695931333.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这样我们就得到了Neural Network，把其中每个Logistic Regression叫做一个Neuron.&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;参考：&lt;a href=&quot;https://blog.csdn.net/zyq522376829/article/details/69216876&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/zyq522376829/article/details/69216876&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　    &lt;a href=&quot;https://blog.csdn.net/xzy_thu/article/details/68067631&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/xzy_thu/article/details/68067631&lt;/a&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;以上就是本节课的心得体会，欢迎交流！ &lt;/p&gt;

&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;MathJax&quot; data-mathml=&quot;&amp;lt;math xmlns=&amp;quot;http://www.w3.org/1998/Math/MathML&amp;quot;&amp;gt;&amp;lt;mi&amp;gt;P&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;msub&amp;gt;&amp;lt;mi&amp;gt;C&amp;lt;/mi&amp;gt;&amp;lt;mn&amp;gt;1&amp;lt;/mn&amp;gt;&amp;lt;/msub&amp;gt;&amp;lt;mrow class=&amp;quot;MJX-TeXAtom-ORD&amp;quot;&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;|&amp;lt;/mo&amp;gt;&amp;lt;/mrow&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03C3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;z&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;mo&amp;gt;=&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;&amp;amp;#x03C3;&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;(&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;w&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;&amp;amp;#xB7;&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;x&amp;lt;/mi&amp;gt;&amp;lt;mo&amp;gt;+&amp;lt;/mo&amp;gt;&amp;lt;mi&amp;gt;b&amp;lt;/mi&amp;gt;&amp;lt;mo stretchy=&amp;quot;false&amp;quot;&amp;gt;)&amp;lt;/mo&amp;gt;&amp;lt;/math&amp;gt;&quot;&gt;&lt;span class=&quot;MJX_Assistive_MathML&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 23 Mar 2019 14:27:00 +0000</pubDate>
<dc:creator>控球强迫症</dc:creator>
<og:description>李宏毅老师的机器学习课程和吴恩达老师的机器学习课程都是都是ML和DL非常好的入门资料，在YouTube、网易云课堂、B站都能观看到相应的课程视频，接下来这一系列的博客我都将记录老师上课的笔记以及自己对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/XDU-Lakers/p/10574955.html</dc:identifier>
</item>
</channel>
</rss>