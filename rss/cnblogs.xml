<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spark第一周 - shayue111</title>
<link>http://www.cnblogs.com/shayue/p/week1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shayue/p/week1.html</guid>
<description>&lt;h2 id=&quot;why-scala&quot;&gt;Why Scala&lt;/h2&gt;
&lt;p&gt;在数据集不是很大的时候，开发人员可以使用python、R、MATLAB等语言在单机上处理数据集。但是在大数据时代，数据集少说都是TB、PB级别，此时便需要分布式地处理。相较于上述语言，Scala有着现成的框架即Spark能分布式地处理问题，Scala中有着丰富的Spark API，开发时只需要进行函数的编写就能轻松解决各种需求。虽然其他语言也有Spark的API，比如python的pySpark，但是逊色于Spark对Scala的支持，毕竟Spark是用Scala开发出来的。&lt;/p&gt;
&lt;h2 id=&quot;spark和hadoop&quot;&gt;Spark和Hadoop&lt;/h2&gt;
&lt;p&gt;Spark和Hadoop是Apache下的两个不同开源项目，但是有着很强的关联性。简单理解，Spark是一个能在Hadoop生态圈中使用的计算框架，Hadoop本身也有计算框架MapReduce。Spark对比Hadoop中的MapReduce有以下优势：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Spark is more expressive（实现方式）. Spark's APIs are modeled after Scala's collections, which mean distributed computations in Spark are like immutable lists in Scala. You can use higher-order functions like map, flatMap, filter, and reduce, to build up rich pipelines of computation that are distributed in a very concise way. Whereas Hadoop on the other hand is much more rigid（不灵活）. It forces map then reduce computations without all of these cool combinators, like flatMap and filter, and it requires a lot more boilerplate to build up interesting computation pipelines.&lt;/li&gt;
&lt;li&gt;The second reason is performance（性能）. By now, I'm sure you've heard of Spark as being super fast. After all, Spark's tagline is Lightning-Fast Cluster Computing. Performance brings something very important to the table that we haven't had until Spark came along which is interactivity. Now it's possible to query your very large distributed data set interactively（交互式）. So that's a really big deal. And also Spark is so much faster that Hadoop in some cases that jobs that would take tens of minutes to run, now only take a few seconds. This allows data scientists to interactively explore and experiment with their data, which in turn allows for data scientists to discover richer insights from their data faster. MapReduce job results need to be stored in HDFS before they can be used by another job.&lt;/li&gt;
&lt;li&gt;And finally, Spark is good for data science. It's much better for data science than Hadoop and it's not just due to performance reasons. Iteration is required by most algorithms in the data scientist's toolbox. That is, most analysis tasks require multiple passes over the same set of data. And while iteration is indeed possible in Hadoop with really quite a lot of effort, you have a bunch of boilerplate that you have to do and a required external libraries and frameworks that just degenerate a bunch of extra map reduce phases in order to simulate iteration. It's really, on the other hand, the downright simple to do in Spark. There's no boilerplate required whatsoever, you just write what feels like a normal program, which includes a few passes over the same dataset. You just have basically, something that looks like a for loop and say hey, until this condition is met iterate. Which is night and day when compared with Hadoop, because it's almost not possible in Hadoop.&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;why-spark-is-causing-such-a-shift-in-handling-data&quot;&gt;Why Spark is causing such a shift in handling data&lt;/h2&gt;
&lt;p&gt;Spark对于数据的实时处理被人津津乐道，那么这个分布式计算框架为什么能如此优秀？&lt;/p&gt;
&lt;p&gt;对于一个分布式计算框架，有两个问题始终难以回避：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Partial failure（某些节点崩溃，难以工作）: crash failures of a subset of the machines involved in distributed computation&lt;/li&gt;
&lt;li&gt;Latency（延迟）: certain opeartions have a much higher latency than other operations due to the network communication&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;在实际开发中，Latency是难以规避的。虽然Spark是很优秀的框架，但是如何编写出更好的代码尽量降低Latency也是开发人员的工作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一些延迟时间：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531067/201907/1531067-20190720075427594-911160333.jpg&quot; alt=&quot;-w840&quot;/&gt;￼&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;蓝色：与内存读写有关&lt;/li&gt;
&lt;li&gt;橙色：与磁盘读写有关&lt;/li&gt;
&lt;li&gt;紫色：与网络传输有关&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在继承Hadoop对于节点崩溃的容错性的同时，Spark在处理时效上有了巨大突破。原因在于&lt;br/&gt;如果计算不涉及与其他节点进行数据交换，Spark可以在内存中一次性完成这些操作，也就是中间结果无须落盘（MR则需要存到HDFS先），减少了磁盘IO的操作。&lt;/p&gt;
&lt;h2 id=&quot;rddresilient-distributed-dataset&quot;&gt;RDD(resilient distributed dataset)&lt;/h2&gt;
&lt;p&gt;在scala-REPL中敲出下列代码可以查看Spark根目录中的LICENSE有几行，并且可以打印其中有几行包含“BSD”。&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// sc是Spark Context类
scala&amp;gt; val licLines = sc.textFile(&quot;/Users/shayue/env/spark/spark-2.4.2-bin-hadoop2.7/LICENSE&quot;)
licLines: org.apache.spark.rdd.RDD[String] = /Users/shayue/env/spark/spark-2.4.2-bin-hadoop2.7/LICENSE MapPartitionsRDD[1] at textFile at &amp;lt;console&amp;gt;:24

scala&amp;gt; val lineCnt = licLines.count
[Stage 0:&amp;gt;   
lineCnt: Long = 518

scala&amp;gt; val bsdLines = licLines.filter(line =&amp;gt; line.contains(&quot;BSD&quot;)) 
bsdLines: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[2] at filter at &amp;lt;console&amp;gt;:25

scala&amp;gt; bsdLines.count
res1: Long = 3

scala&amp;gt; bsdLines.foreach(bsdLine =&amp;gt; println(bsdLine))
BSD 2-Clause
BSD 3-Clause
is distributed under the 3-Clause BSD license.

// 简化写法
scala&amp;gt; bsdLines.foreach(println)
BSD 2-Clause
BSD 3-Clause
is distributed under the 3-Clause BSD license.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里代码中用到的&lt;code&gt;filter&lt;/code&gt;和&lt;code&gt;contains&lt;/code&gt;在scala的一些collection中也有。不过，&lt;code&gt;licLines&lt;/code&gt;和&lt;code&gt;bsdLines&lt;/code&gt;并不是scala的collection结构。它们时分布式的collection结构，在Spark中被称为RDDs。&lt;/p&gt;
&lt;p&gt;RDD的特性如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Immutable (read-only) ，只读类型&lt;/li&gt;
&lt;li&gt;Resilient (fault-tolerant) ，高容错性&lt;/li&gt;
&lt;li&gt;Distributed (dataset spread out to more than one node)，分布式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;RDDs能执行很多数据转化操作，但结束后总是产生一个新的RDD实例。一旦创建，RDD永远不会改变，这也是上面提到的&lt;code&gt;Immutable&lt;/code&gt;特性。因为&lt;code&gt;Mutable&lt;/code&gt;会增加框架的复杂性，除此之外，&lt;code&gt;immutable collections&lt;/code&gt;使得Spark更具有容错性。&lt;/p&gt;
&lt;p&gt;一个RDD实例是分布在各台机器上的总和，但是Spark仅仅暴露一个接口给用户，使得用户感觉就像在单机上操作。RDDs使得将一个任务部署到多个机器上执行变得简单了。&lt;/p&gt;
&lt;p&gt;其他分布式计算框架通过将数据复制到多台机器来保持容错，一旦节点出现故障就可以从正常的节点复制恢复。RDD的机制不同的，它们会记录&lt;code&gt;如何在某个工作节点上生成一些数据的方式，称为RDD运算图(RDD lineage)&lt;/code&gt;，如果哪个工作节点发生故障，则只需根据记录重新生成数据即可。&lt;/p&gt;
&lt;p&gt;下面以上述代码为例：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;加载文本文件的过程生成了licLines RDD&lt;/li&gt;
&lt;li&gt;对licLines使用&lt;code&gt;filter&lt;/code&gt;方法，生成新的bsdLines RDD&lt;/li&gt;
&lt;li&gt;步骤1和步骤2一起构成了一个&lt;code&gt;RDD运算图(RDD lineage)&lt;/code&gt;。它记录了&lt;code&gt;如何从头到尾创建bsdLines RDD&lt;/code&gt;。也就是说，即使某个节点当掉，可以根据&lt;code&gt;RDD lineage&lt;/code&gt;重新生成必要的数据。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;基本的rdd操作&quot;&gt;基本的RDD操作&lt;/h2&gt;
&lt;p&gt;分为两种方式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Transformations(转换): 比如&lt;code&gt;filter&lt;/code&gt;，&lt;code&gt;map&lt;/code&gt;，可以发现transformations操作一般会通过原RDD进行更改，进而产生新的RDD实例&lt;/li&gt;
&lt;li&gt;Actions(执行): 比如&lt;code&gt;count&lt;/code&gt;，&lt;code&gt;foreach&lt;/code&gt;，进行action操作主要是希望得到一些关于RDD实例性质的结果。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;值得注意的是：&lt;/strong&gt;&lt;br/&gt;Spark的&lt;code&gt;Transformations&lt;/code&gt;操作是&lt;code&gt;Lazily&lt;/code&gt;的，即仅在执行某些&lt;code&gt;Actions&lt;/code&gt;操作以输出一些想要的结果时，&lt;code&gt;Transformations&lt;/code&gt;操作才会进行。&lt;/p&gt;
&lt;p&gt;在RDD上触发&lt;code&gt;action&lt;/code&gt;操作后，Spark会检查&lt;code&gt;RDD lineage&lt;/code&gt;，并使用该信息构建需要执行的&lt;code&gt;graph of operations(操作图)&lt;/code&gt;以计算操作。它告诉Spark需要执行哪些&lt;code&gt;transformations&lt;/code&gt;，以及将以何种顺序执行。&lt;/p&gt;
&lt;p&gt;“操作图”可以理解为在一些RDDs上接了许多带箭头的线，每条线代表一个&lt;code&gt;transformation&lt;/code&gt;，只有最后点击&lt;code&gt;Actions&lt;/code&gt;时，这些线上才会有数据流动。&lt;/p&gt;
&lt;h3 id=&quot;transformations实践&quot;&gt;Transformations实践&lt;/h3&gt;
&lt;h4 id=&quot;map&quot;&gt;map&lt;/h4&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// sc.parallelize是一个创建RDD的方式，用本地的scala collect创建。makeRDD也可；(10 to 50 by 10)是生成Scala Range类型写法
// scala&amp;gt; List(10 to 50 by 10)
// res6: List[scala.collection.immutable.Range] = List(Range 10 to 50 by 10)

scala&amp;gt; val numbers = sc.parallelize(10 to 50 by 10)
numbers: org.apache.spark.rdd.RDD[Int] = ParallelCollectionRDD[3] at parallelize at &amp;lt;console&amp;gt;:24

scala&amp;gt; numbers.foreach(println)
20
30
40
50
10

// map操作，计算平方
scala&amp;gt; val numberSquared = numbers.map(num =&amp;gt; num * num)
numberSquared: org.apache.spark.rdd.RDD[Int] = MapPartitionsRDD[4] at map at &amp;lt;console&amp;gt;:25

scala&amp;gt; numberSquared.foreach(println)
100
1600
400
900
2500

// 对于平方数，转成string，再反转
scala&amp;gt; val reversed = numberSquared.map(num =&amp;gt; num.toString.reverse) 
reversed: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[5] at map at &amp;lt;console&amp;gt;:25

scala&amp;gt; reversed.foreach(println)
001
004
009
0061
0052

// 上述方式的简写
scala&amp;gt; val alsoReversed = numberSquared.map(_.toString.reverse) 
alsoReversed: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[6] at map at &amp;lt;console&amp;gt;:25&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;distinct-and-flatmap&quot;&gt;distinct and flatMap&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;.collect方法能获得RDDs实例中的scala collection类型&lt;/li&gt;
&lt;li&gt;.distinct获得不同的元素&lt;/li&gt;
&lt;li&gt;.flatMap对于&lt;code&gt;def flatMap[U](f: (T) =&amp;gt; TraversableOnce[U]): RDD[U]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;scala&amp;gt; val lines = sc.textFile(&quot;/Users/shayue/client-ids.log&quot;)
lines: org.apache.spark.rdd.RDD[String] = /Users/shayue/client-ids.log MapPartitionsRDD[1] at textFile at &amp;lt;console&amp;gt;:24

scala&amp;gt; val idsStr = lines.flatMap(_.split(&quot;,&quot;))
idsStr: org.apache.spark.rdd.RDD[String] = MapPartitionsRDD[2] at flatMap at &amp;lt;console&amp;gt;:25

scala&amp;gt; idsStr.collect
res0: Array[String] = Array(15, 16, 20, 20, 77, 80, 94, 94, 98, 16, 31, 31, 15, 20)

scala&amp;gt; idsStr.first
res2: String = 15

scala&amp;gt; val idsInt = idsStr.map(_.toInt)
idsInt: org.apache.spark.rdd.RDD[Int] = MapPartitionsRDD[3] at map at &amp;lt;console&amp;gt;:25

// idsInt.collect是Array[Int]
scala&amp;gt; idsInt.collect
res4: Array[Int] = Array(15, 16, 20, 20, 77, 80, 94, 94, 98, 16, 31, 31, 15, 20)

scala&amp;gt; idsInt.distinct
res5: org.apache.spark.rdd.RDD[Int] = MapPartitionsRDD[6] at distinct at &amp;lt;console&amp;gt;:26

// res5指代idsInt.distinct生成的RDD实例
scala&amp;gt; res5
res6: org.apache.spark.rdd.RDD[Int] = MapPartitionsRDD[6] at distinct at &amp;lt;console&amp;gt;:26

// 仅包含不同元素
scala&amp;gt; res5.collect
res8: Array[Int] = Array(16, 80, 98, 20, 94, 15, 77, 31)

// 由Array[String]到String，并且加上特定格式“；”
scala&amp;gt; idsStr.collect.mkString(&quot;;&quot;)
res9: String = 15;16;20;20;77;80;94;94;98;16;31;31;15;20&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;sampletakesampletake&quot;&gt;sample\takeSample\take&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;def sample(withReplacement: Boolean, fraction: Double, seed: Long = Utils.random.nextLong): RDD[T]&lt;/code&gt;&lt;br/&gt;用于对一个RDD实例中的元素取样，Boolean是True的话就是有放回的取样；False就是无放回&lt;/p&gt;
&lt;h4 id=&quot;统计量&quot;&gt;统计量&lt;/h4&gt;
&lt;p&gt;mean\sum\histogram\variance\stdv&lt;/p&gt;
&lt;p&gt;PPT 总结：赖得手打了&lt;/p&gt;
&lt;p&gt;常用Transformations：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531067/201907/1531067-20190720075427203-195400749.jpg&quot; alt=&quot;-w515&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;常用Actions：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531067/201907/1531067-20190720075427332-161844104.jpg&quot; alt=&quot;-w513&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;其他：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531067/201907/1531067-20190720075440282-554818136.jpg&quot; alt=&quot;-w508&quot;/&gt;￼&lt;/p&gt;
&lt;h2 id=&quot;why-spark-is-good-for-data-analysis&quot;&gt;Why Spark is good for Data Analysis&lt;/h2&gt;
&lt;p&gt;先来回顾一下Spark的特性：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Transformtions is Lazy&lt;/li&gt;
&lt;li&gt;Actions is Eager&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;数据处理中做的最多的事情是迭代：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531067/201907/1531067-20190720075437302-1619249518.jpg&quot; alt=&quot;-w697&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;从上图看来，不像Hadoop需要重复地将数据写回File System中，Spark有能力直接在内存中读取数据进行迭代。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Spark allows us to control what is cached in memory. What we do is just simply call persist() or cache() on RDDs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;举例：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531067/201907/1531067-20190720075438565-82674621.jpg&quot; alt=&quot;-w693&quot;/&gt;￼&lt;br/&gt;倘若不在第二行生成&lt;code&gt;logsWithErrors&lt;/code&gt;时加上&lt;code&gt;.persist()&lt;/code&gt;。由于&lt;code&gt;filter()和contains()&lt;/code&gt;是Lazy的，在第4行执行&lt;code&gt;Actions&lt;/code&gt;操作&lt;code&gt;count&lt;/code&gt;时，需要重新执行&lt;code&gt;.filter(_.contains(&quot;ERROR&quot;))&lt;/code&gt;这个操作；但是加上&lt;code&gt;.persist()&lt;/code&gt;就可以不用重复计算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然，既然是将数据保存在内存中，那显然很吃内存的容量。Spark有以下如下几种方式，配置保存在内存中的数据格式。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531067/201907/1531067-20190720075444834-177932213.jpg&quot; alt=&quot;-w652&quot;/&gt;￼&lt;/p&gt;
&lt;h4 id=&quot;rdds和collection的区别&quot;&gt;RDDs和collection的区别&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;Lazy和Eager&lt;/li&gt;
&lt;li&gt;Spark更加聪明，比如：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531067/201907/1531067-20190720075445097-1786666096.jpg&quot; alt=&quot;-w646&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;取完10个元素之后，Spark便停止工作了；又或者：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531067/201907/1531067-20190720075438896-2054861678.jpg&quot; alt=&quot;-w627&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;collction中要先走完map再走filter再走count，RDDs中一次遍历时这些操作同时进行。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jul 2019 23:55:00 +0000</pubDate>
<dc:creator>shayue111</dc:creator>
<og:description>## Why Scala在数据集不是很大的时候，开发人员可以使用python、R、MATLAB等语言在单机上处理数据集。但是在大数据时代，数据集少说都是TB、PB级别，此时便需要分布式地处理。相较于上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shayue/p/week1.html</dc:identifier>
</item>
<item>
<title>Code Review最佳实践 - 宝玉</title>
<link>http://www.cnblogs.com/dotey/p/11216430.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dotey/p/11216430.html</guid>
<description>&lt;p align=&quot;justify&quot;&gt;我一直认为Code Review（代码审查）是软件开发中的最佳实践之一，可以有效提高整体代码质量，及时发现代码中可能存在的问题。包括像Google、微软这些公司，Code Review都是基本要求，代码合并之前必须要有人审查通过才行。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;然而对于我观察到的大部分软件开发团队来说，认真做Code Review的很少，有的流于形式，有的可能根本就没有Code Review的环节，代码质量只依赖于事后的测试。也有些团队想做好代码审查，但不知道怎么做比较好。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; 网上关于如何做Code Review的文章已经有很多了，这里我结合自己的一些经验，也总结整理了一下Code Review的最佳实践，希望能对大家做好Code Review有所帮助。&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;很多团队或个人不做Code Review，根源还是不觉得这是一件有意义的事情，不觉得有什么好处。这个问题要从几个角度来看。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;首先是团队知识共享的角度&lt;/strong&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt;一个开发团队中，水平有高有低，每个人侧重的领域也有不同。怎么让高水平的帮助新人成长？怎么让大家都对自己侧重领域之外的知识保持了解？怎么能有人离职后其他人能快速接手？这些都是团队管理者关心的问题。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;而代码审查，就是一个很好的知识共享的方式。通过代码审查，高手可以直接指出新手代码中的问题，新手可以马上从高手的反馈中学习到好的实践，得到更快的成长；通过代码审查，前端也可以去学习后端的代码，做功能模块A的可以去了解功能模块B的。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;可能有些高手觉得给新手代码审查浪费时间，自己也没收获。其实不然，新人成长了，就可以更多的帮高手分担繁重的任务；代码审查中花时间，就少一些帮新人填坑擦屁股的时间；良好的沟通能力、发现问题的能力、帮助其他人成长，都是技术转管理或技术上更上一层楼必不可少的能力，而通过代码审查可以有效的去练习这些方面的能力。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;然后是代码质量的角度&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt;现实中的项目总是人手缺进度紧，所以被压缩的往往就是自动化测试和代码审查，结果影响代码质量，欠下技术债务，最后还是要加倍偿还。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;也有人寄希望于开发后的人工测试，然而对于代码质量来说，很多问题通过测试是测试不出来的，只能通过代码审查。比如说代码的可读性可维护性，比如代码的结构，比如一些特定条件才触发的死循环、逻辑算法错误，还有一些安全上的漏洞也更容易通过代码审查发现和预防。 &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;也有人觉得自己水平高就不需要代码审查了。对于高手来说，让别人审查自己的代码，可以让其他人学习到好的实践；在让其他人审查的同时，在给别人说明自己代码的时候，也等于自己对自己的代码进行了一次审查。这其实就跟我们上学时做数学题一样，真正能拿高分的往往是那些做完后还会认真检查的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;还有团队规范的角度&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt;每个团队都有自己的代码规范，有自己的基于架构设计的开发规范，然而时间一长，就会发现代码中出现很多不遵守代码规范的情况，有很多绕过架构设计的代码。比如难以理解和不规范的命名，比如三层架构里面UI层绕过业务逻辑层直接调用数据访问层代码。 &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;如果这些违反规范的代码被纠正的晚了，后面再要修改就成本很高了，而且团队的规范也会慢慢的形同虚设。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;通过代码审查，就可以及时的去发现和纠正这些问题，保证团队规范的执行。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;关于代码审查的好处，还有很多，也不一一列举。还是希望能认识到&lt;strong&gt;Code Review和写自动化测试一样，都是属于磨刀不误砍柴工的工作，在上面投入一点点时间，未来会收获代码质量，会节约整体的开发时间。&lt;/strong&gt;&lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;现在很多人都已经有意识到Code Review的重要性了，只是苦于不知道如何去实践，不知道怎么样算是好的Code Review实践。&lt;/p&gt;
&lt;h2&gt;把Code Review作为开发流程的必选项而不是可选项&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;在很早以前，我就尝试过将代码审查作为代码流程的一部分，但只是一个可选项，没有Code Review也可以把代码合并到master。这样的结果就是想起来才会去做Code Review，去检查的时候已经有了太多的代码变更，审查起来非常困难，另外就算审查出问题，也很难得以修改。 &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;我们现在对代码的审查则是作为开发流程的一个必选项，每次开发新功能或者修复Bug，开一个新的分支，分支要合并到master有两个必要条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;所有的自动化测试通过&lt;/li&gt;
&lt;li&gt;有至少一个人Code Review通过，如果是新手的PR，还必须有资深程序员Code Review通过&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/564/201907/564-20190720013237180-1803130612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图片来源：How to Do Code Reviews Like a Human&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;这样把Code Review作为开发流程的一个必选项后，就很好的保证了代码在合并之前有过Code Review。而且这样合并前要求代码审查的流程，好处也很明显：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于每一次合并前都要做代码审查，这样一般一次审查的代码量也不会太大，对于审查者来说压力也不会太大&lt;/li&gt;
&lt;li&gt;如果在Code Review时发现问题，被审查者希望代码能尽快合并，也会积极的对审查出来的问题进行修改，不至于对审查结果太过抵触&lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt;如果你觉得Code Review难以推行，不妨先尝试着把Code Review变成你开发流程的一个必选项。&lt;/p&gt;
&lt;h2&gt;把Code Review变成一种开发文化而不仅仅是一种制度&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;把Code Review 作为开发流程的必选项后，不代表Code Review这件事就可以执行的很好，因为Code Review 的执行，很大部分程度上依赖于审查者的认真审查，以及被审查者的积极配合，两者缺一不可！&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;如果仅仅只是当作一个流程制度，那么就可能会流于形式。最终结果就是看起来有Code Review，但没有人认真审查，随便看下就通过了，或者发现问题也不愿意修改。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;真要把Code Review这件事做好，必须让Code Review变成团队的一种文化，开发人员从心底接受这件事，并认真执行这件事。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;要形成这样的文化，不那么容易，也没有想象的那么难，比如这些方面可以参考：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，得让开发人员认识到Code Review这件事为自己、为团队带来的好处&lt;/li&gt;
&lt;li&gt;然后，得要有几个人做好表率作用，榜样的力量很重要&lt;/li&gt;
&lt;li&gt;还有，对于管理者来说，你激励什么，往往就会得到什么&lt;/li&gt;
&lt;li&gt;最后，像写自动化测试一样，&lt;strong&gt;把Code Review要作为开发任务的一部分，给审查者和被审查者都留出专门的时间去做这件事&lt;/strong&gt;，不能光想着马儿跑得快又舍不得给马儿吃草 &lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt;如何形成这样的文化，有心的话，还有很多方法可以尝试。只有真正让大家都认同和践行，才可能去做好Code Review这件事。&lt;/p&gt;
&lt;h2&gt;一些Code Review的经验技巧&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;在做好Code Review这件事上，还有一些经验技巧可以参考。&lt;/p&gt;
&lt;h2&gt;选什么工具辅助做CODE REVIEW？&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;现在很多源代码管理工具都自带Code Review工具，典型的像Github、Gitlab、微软的Azure DevOps，尤其是像Gitlab，还可以自己在本地搭建环境，根据自己的需要灵活配置。 &lt;/p&gt;
&lt;h2&gt;配合什么样的开发流程比较好？&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;像&lt;a href=&quot;https://guides.github.com/introduction/flow/&quot;&gt;Github Flow&lt;/a&gt;这样基于分支开发的流程是特别适合搭配Code Review的。其实不管什么样的开发流程，关键点在于代码合并到master（主干）之前，要先做Code Review。&lt;/p&gt;
&lt;h2&gt;真遇到紧急情况，来不及代码审查怎么办？ &lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;虽然原则上，必须要Code Review才能合并，但有时候确实会存在一些紧急情况，比如说线上故障补丁，而又没有其他人在线，那么这种情况下，最好是在任务管理系统中，创建一个Ticket，用来后续跟踪，确保后续补上Code Review，并对Code Review结果有后续的代码更新。&lt;/p&gt;
&lt;h2&gt;先设计再编码&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;有些新人发现自己的代码提交PR（Pull Request）后，会收到一堆的Code Review意见，必须要做大量的改动。这多半是因为在开始做之前，没有做好设计，做出来后才发现问题很多。 &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;建议在做一个新功能之前，写一个简单的设计文档，表达清楚自己的设计思路，找资深的先帮你做一下设计的审查，发现设计上的问题。设计上没问题了，再着手开发，那么到Review的时候，相对问题就会少很多。&lt;/p&gt;
&lt;h2&gt;代码在提交CODE REVIEW之前，作者要自己先REVIEW和测试一遍 &lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;我在做代码审查的时候，有时候会发现一些非常明显的问题，有些甚至自己都没有测试过，就等着别人Code Review和测试帮助发现问题。这种依赖心理无论是对自己还是对团队都是很不负责任的。 &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;一个好的开发人员，代码在提交Code Review之前，肯定是要自己先Review一遍，把该写的自动化测试代码写上，自己把基本的测试用例跑一遍的。&lt;/strong&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;我对于团队提交的PR，有个要求就是要在PR的描述中增加截图或者录屏，就是为了通过截图或者录屏，确保提交PR的人自己是先测试过的。这也是一个有效的辅助手段。&lt;/p&gt;
&lt;h2&gt;PR要小 &lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;在做Code Review的时候，如果有大量的文件修改，那么Review起来是很困难的，但如果PR比较小，相对就比较容易Review，也容易发现代码中可能存在的问题。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;所以在提交PR时，PR要小，如果是比较大的改动，那么最好分批提交，以减轻审查者的压力。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/564/201907/564-20190720013159632-1726452152.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;对评论进行分级&lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;在做Code Review时，需要针对审查出有问题的代码行添加评论，如果只是评论，有时候对于被审查者比较难甄别评论所代表的含义，是不是必须要修改。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;建议可以对Review的评论进行分级，不同级别的结果可以打上不同的Tag，比如说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[blocker]: 在评论前面加上一个[blocker]标记，表示这个代码行的问题必须要修改&lt;/li&gt;
&lt;li&gt;[optional]：在评论前面加上一个[optional]标记，表示这个代码行的问题可改可不改&lt;/li&gt;
&lt;li&gt;[question]：在评论前面加上一个[question]标记，表示对这个代码行不理解，有问题需要问，被审查者需要针对问题进行回复澄清 &lt;/li&gt;
&lt;/ul&gt;&lt;p align=&quot;justify&quot;&gt;类似这样的分级可以帮助被审查者直观了解Review结果，提高Review效率。&lt;/p&gt;
&lt;h2&gt;评论要友好，避免负面词汇；有说不清楚的问题当面沟通 &lt;/h2&gt;
&lt;p align=&quot;justify&quot;&gt;虽然评论是主要的Code Review沟通方式，但也不要过于依赖，有时候面对面的沟通效率更高，也容易消除误解。&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;另外文明用语，不要用一些负面的词汇。 &lt;/p&gt;

&lt;p align=&quot;justify&quot;&gt;Code Review是一种非常好的开发实践，如果你还没开始，不妨逐步实践起来；如果已经做了效果不好，不妨对照一下，看有没有把Code Review作为开发流程的必选项而不是可选项？有没有把Code Review变成一种开发文化而不仅仅是一种制度？&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jul 2019 17:35:00 +0000</pubDate>
<dc:creator>宝玉</dc:creator>
<og:description>我一直认为Code Review（代码审查）是软件开发中的最佳实践之一，可以有效提高整体代码质量，及时发现代码中可能存在的问题。包括像Google、微软这些公司，Code Review都是基本要求，代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dotey/p/11216430.html</dc:identifier>
</item>
<item>
<title>《ElasticSearch6.x实战教程》之分词 - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/11216377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/11216377.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;下雨天留客天留我不留&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本打算先介绍“简单搜索”，对ES的搜索有一个直观的感受。但在写的过程中发现分词无论如何都绕不过去。&lt;code&gt;term&lt;/code&gt;查询，&lt;code&gt;match&lt;/code&gt;查询都与分词息息相关，索性先介绍分词。&lt;/p&gt;
&lt;p&gt;ES作为一个开源的搜索引擎，其核心自然在于搜索，而搜索不同于我们在MySQL中的&lt;code&gt;select&lt;/code&gt;查询语句，无论我们在百度搜索一个关键字，或者在京东搜索一个商品时，常常无法很准确的给出一个关键字，例如我们在百度希望搜索“Java教程”，我们希望结果是“Java教程”、“Java”、“Java基础教程”，甚至是“教程Java”。MySQL虽然能满足前三种查询结果，但却无法满足最后一种搜索结果。&lt;/p&gt;
&lt;p&gt;虽然我们很难做到对于百度或者京东的搜索（这甚至需要了解Lucene和搜索的底层原理），但我们能借助ES做出一款不错的搜索产品。&lt;/p&gt;
&lt;p&gt;ES的搜索中，分词是非常重要的概念。掌握分词原理，对待一个不甚满意的搜索结果我们能定位是哪里出了问题，从而做出相应的调整。&lt;/p&gt;
&lt;p&gt;ES中，只对&lt;strong&gt;字符串&lt;/strong&gt;进行分词，在ElasticSearch2.x版本中，字符串类型只有&lt;code&gt;string&lt;/code&gt;，ElasticSearch5.x版本后字符串类型分为了&lt;code&gt;text&lt;/code&gt;和&lt;code&gt;keyword&lt;/code&gt;类型，需要明确的分词只在&lt;code&gt;text&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;ES的默认分词器是&lt;code&gt;standard&lt;/code&gt;，对于英文搜索它没有问题，但对于中文搜索它会将所有的中文字符串挨个拆分，也就是它会将“中国”拆分为“中”和“国”两个单词，这带来的问题会是搜索关键字为“中国”时，将不会有任何结果，ES会将搜索字段进行拆分后搜索。当然，你可以指定让搜索的字段不进行分词，例如设置为&lt;code&gt;keyword&lt;/code&gt;字段。&lt;/p&gt;
&lt;h2 id=&quot;分词体验&quot;&gt;分词体验&lt;/h2&gt;
&lt;p&gt;前面说到ES的默认分词器是&lt;code&gt;standard&lt;/code&gt;,可直接通过API指定分词器以及字符串查看分词结果。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;standard&lt;/code&gt;进行英文分词：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST http://localhost:9200/_analyze
{
    &quot;analyzer&quot;:&quot;standard&quot;,
    &quot;text&quot;:&quot;hello world&quot; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ES响应：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;tokens&quot;: [
        {
            &quot;token&quot;: &quot;hello&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 5,
            &quot;type&quot;: &quot;&amp;lt;ALPHANUM&amp;gt;&quot;,
            &quot;position&quot;: 0
        },
        {
            &quot;token&quot;: &quot;world&quot;,
            &quot;start_offset&quot;: 6,
            &quot;end_offset&quot;: 11,
            &quot;type&quot;: &quot;&amp;lt;ALPHANUM&amp;gt;&quot;,
            &quot;position&quot;: 1
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们对“helloword”进行分词，结果将只有“helloword”一个词，&lt;code&gt;standsard&lt;/code&gt;对英文按照空格进行分词。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;standard&lt;/code&gt;进行中文分词：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST http://localhost:9200/_analyze
{
    &quot;analyzer&quot;:&quot;standard&quot;,
    &quot;text&quot;:&quot;学生&quot; 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ES响应：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;tokens&quot;: [
        {
            &quot;token&quot;: &quot;学&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 1,
            &quot;type&quot;: &quot;&amp;lt;IDEOGRAPHIC&amp;gt;&quot;,
            &quot;position&quot;: 0
        },
        {
            &quot;token&quot;: &quot;生&quot;,
            &quot;start_offset&quot;: 1,
            &quot;end_offset&quot;: 2,
            &quot;type&quot;: &quot;&amp;lt;IDEOGRAPHIC&amp;gt;&quot;,
            &quot;position&quot;: 1
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;“学生”显然应该是一个词，不应该被拆分。也就是说如果字符串中是中文，默认的&lt;code&gt;standard&lt;/code&gt;不符合我们的需求。幸运地是， ES支持第三方分词插件。在ES中的中文分词插件使用最为广泛的是ik插件。&lt;/p&gt;
&lt;h2 id=&quot;ik插件&quot;&gt;ik插件&lt;/h2&gt;
&lt;p&gt;既然是插件，就需要安装。注意，版本5.0.0起，ik插件已经不包含名为&lt;code&gt;ik&lt;/code&gt;的分词器，只含&lt;code&gt;ik_smart&lt;/code&gt;和&lt;code&gt;ik_max_word&lt;/code&gt;，事实上后两者使用得也最多。&lt;/p&gt;
&lt;h3 id=&quot;ik插件安装&quot;&gt;ik插件安装&lt;/h3&gt;
&lt;p&gt;ik下载地址（直接下载编译好了的zip文件，需要和ES版本一致）：&lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v6.3.2&quot; class=&quot;uri&quot;&gt;https://github.com/medcl/elasticsearch-analysis-ik/releases/tag/v6.3.2&lt;/a&gt;。ik历史版本下载页面：&lt;a href=&quot;https://github.com/medcl/elasticsearch-analysis-ik/releases&quot; class=&quot;uri&quot;&gt;https://github.com/medcl/elasticsearch-analysis-ik/releases&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;下载完成后解压&lt;code&gt;elasticsearch-analysis-ik-6.3.2.zip&lt;/code&gt;将解压后的文件夹直接放入ES安装目录下的&lt;code&gt;plugins&lt;/code&gt;文件夹中，重启ES。&lt;/p&gt;
&lt;p&gt;使用ik插件的&lt;code&gt;ik_smart&lt;/code&gt;分词器：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;POST http://localhost:9200/_analyze
{
  &quot;analyzer&quot;:&quot;ik_smart&quot;,
  &quot;text&quot;:&quot;学生&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ES响应：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;tokens&quot;: [
        {
            &quot;token&quot;: &quot;学生&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 2,
            &quot;type&quot;: &quot;CN_WORD&quot;,
            &quot;position&quot;: 0
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这才符合我们的预期。那么ik插件中的&lt;code&gt;ik_smart&lt;/code&gt;和&lt;code&gt;ik_max_word&lt;/code&gt;有什么区别呢？简单来讲，&lt;code&gt;ik_smart&lt;/code&gt;会按照关键字的&lt;strong&gt;最粗粒度进行分词&lt;/strong&gt;，比如搜索“北京大学”时，我们知道“北京大学”是一个特定的词汇，它并不是指“北京的大学”，我们不希望搜索出“四川大学”，“重庆大学”等其他学校，此时“北京大学”不会被分词。而&lt;code&gt;ik_max_word&lt;/code&gt;则会按照&lt;strong&gt;最细粒度进行分词&lt;/strong&gt;，同样搜索“北京大学”时，我们也知道“北京”和“大学”都是一个词汇，所以它将会被分词为“北京大学”，“北京大”，“北京”，“大学”，显然如果搜索出现后三者相关结果，这会给我们带来更多无用的信息。&lt;/p&gt;
&lt;p&gt;所以我们在进行搜索时，常常指定&lt;code&gt;ik_smart&lt;/code&gt;为分词器。&lt;/p&gt;
&lt;p&gt;有时候一个词并不在ik插件的词库中，例如很多网络用语等。我们希望搜索“小米手机”的时候，只出现“小米的手机”而不会出现“华为手机”、“OPPO手机”，但“小米手机”并不在ik词库中，此时我们可以将“小米手机”添加到ik插件的自定义词库中。&lt;/p&gt;
&lt;p&gt;“小米手机”使用&lt;code&gt;ik_smart&lt;/code&gt;的分词结果：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;tokens&quot;: [
        {
            &quot;token&quot;: &quot;小米&quot;,
            &quot;start_offset&quot;: 0,
            &quot;end_offset&quot;: 2,
            &quot;type&quot;: &quot;CN_WORD&quot;,
            &quot;position&quot;: 0
        },
        {
            &quot;token&quot;: &quot;手机&quot;,
            &quot;start_offset&quot;: 2,
            &quot;end_offset&quot;: 4,
            &quot;type&quot;: &quot;CN_WORD&quot;,
            &quot;position&quot;: 1
        }
    ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进入ik插件安装目录&lt;code&gt;elasticsearch-5.6.0/plugins/elasticsearch/config&lt;/code&gt;，创建名为&lt;code&gt;custom.dic&lt;/code&gt;的自定义词库，向文件中添加“小米手机”并保存。仍然是此目录，修改&lt;code&gt;IKAnalyzer.cfg.xml&lt;/code&gt;文件，如下所示：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE properties SYSTEM &quot;http://java.sun.com/dtd/properties.dtd&quot;&amp;gt;
&amp;lt;properties&amp;gt;
        &amp;lt;comment&amp;gt;IK Analyzer 扩展配置&amp;lt;/comment&amp;gt;
        &amp;lt;!--用户可以在这里配置自己的扩展字典 --&amp;gt;
        &amp;lt;entry key=&quot;ext_dict&quot;&amp;gt;custom.dic&amp;lt;/entry&amp;gt;
         &amp;lt;!--用户可以在这里配置自己的扩展停止词字典--&amp;gt;
        &amp;lt;entry key=&quot;ext_stopwords&quot;&amp;gt;&amp;lt;/entry&amp;gt;
        &amp;lt;!--用户可以在这里配置远程扩展字典 --&amp;gt;
        &amp;lt;!-- &amp;lt;entry key=&quot;remote_ext_dict&quot;&amp;gt;words_location&amp;lt;/entry&amp;gt; --&amp;gt;
        &amp;lt;!--用户可以在这里配置远程扩展停止词字典--&amp;gt;
        &amp;lt;!-- &amp;lt;entry key=&quot;remote_ext_stopwords&quot;&amp;gt;words_location&amp;lt;/entry&amp;gt; --&amp;gt;
&amp;lt;/properties&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启ES后，再次通过&lt;code&gt;ik_smart&lt;/code&gt;对“小米手机”进行分词，发现“小米手机”不再被分词。&lt;/p&gt;
&lt;h3 id=&quot;创建映射指定分词器&quot;&gt;创建映射指定分词器&lt;/h3&gt;
&lt;p&gt;在创建映射时，我们可以指定字段采用哪种分词器，避免我们在每次搜索时都指定。&lt;/p&gt;
&lt;ol readability=&quot;8.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建word索引 &lt;code&gt;PUT http://localhost:9200/word&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;创建analyzer_demo类型已经定义映射Mapping&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;PUT http://localhost:9200/word/analyzer_demo/_mapping
{
 &quot;properties&quot;:{
     &quot;name&quot;:{
         &quot;type&quot;:&quot;text&quot;,
      &quot;analyzer&quot;:&quot;ik_smart&quot;
     }
 }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;12&quot;&gt;
&lt;p&gt;查看word索引结构 &lt;code&gt;GET http://localhost:9200/word&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;ES响应：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;word&quot;: {
        &quot;aliases&quot;: {},
        &quot;mappings&quot;: {
            &quot;analyzer_demo&quot;: {
                &quot;properties&quot;: {
                    &quot;name&quot;: {
                        &quot;type&quot;: &quot;text&quot;,
                        &quot;analyzer&quot;: &quot;ik_smart&quot;
                    }
                }
            }
        },
        &quot;settings&quot;: {
            &quot;index&quot;: {
                &quot;creation_date&quot;: &quot;1561304920088&quot;,
                &quot;number_of_shards&quot;: &quot;5&quot;,
                &quot;number_of_replicas&quot;: &quot;1&quot;,
                &quot;uuid&quot;: &quot;A2YO9GpzRrGAIm2Q6rCoWA&quot;,
                &quot;version&quot;: {
                    &quot;created&quot;: &quot;5060099&quot;
                },
                &quot;provided_name&quot;: &quot;word&quot;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;可以看到ES在对name字段进行分词时会采用&lt;code&gt;ik_smart&lt;/code&gt;分词器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号：CoderBuff，回复“es”获取《ElasticSearch6.x实战教程》完整版PDF，回复“抽奖”参与《从Lucene到Elasticsearch：全文检索实战》图书抽奖活动（7.17-7.21）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个能给程序员加buff的公众号 （CoderBuff）&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201907/630246-20190717223740465-1981496921.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 19 Jul 2019 16:52:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<og:description>第四章 分词 下雨天留客天留我不留 本打算先介绍“简单搜索”，对ES的搜索有一个直观的感受。但在写的过程中发现分词无论如何都绕不过去。 查询， 查询都与分词息息相关，索性先介绍分词。 ES作为一个开源</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yulinfeng/p/11216377.html</dc:identifier>
</item>
<item>
<title>.NET CORE 多语言实现方案 - roadflow工作流引擎</title>
<link>http://www.cnblogs.com/roadflow/p/11216173.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/roadflow/p/11216173.html</guid>
<description>&lt;p&gt;根据市场需求，基于.NET CORE平台开发的&lt;a href=&quot;http://roadflow.net&quot; target=&quot;_blank&quot;&gt;RoadFlow工作流平台&lt;/a&gt;需要实现多语言版本。经过方案讨论和比对，决定采用.NET自带的本地化功能来实现多语言。话不多说，直接上实现方式。&lt;/p&gt;
&lt;p&gt;首先修改Startup.cs&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1502179/201907/1502179-20190719230910710-1185264153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在public void ConfigureServices(IServiceCollection services)方法中加入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置语言包文件夹名称&lt;/span&gt;
services.AddLocalization(o =&amp;gt;&lt;span&gt;
{
　　o.ResourcesPath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Language&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span readability=&quot;3&quot;&gt;;
});&lt;p&gt;services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_1).AddViewLocalization(LanguageViewLocationExpanderFormat.Suffix);&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;这里指定语言包所在目录，相对于项目根目录下。从上图中看到项目根目录下有一个Language文件夹。&lt;br/&gt;在public void Configure(IApplicationBuilder app, IHostingEnvironment env)方法中加入：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
IList&amp;lt;CultureInfo&amp;gt; supportedCultures = &lt;span&gt;new&lt;/span&gt; List&amp;lt;CultureInfo&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CultureInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zh-CN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CultureInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; CultureInfo(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en-US&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            };
            app.UseRequestLocalization(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestLocalizationOptions
            {&lt;br/&gt;　　　　　　　　　　//这里指定默认语言包
                DefaultRequestCulture &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RequestCulture(&quot;zh-CN&quot;),
                SupportedCultures &lt;/span&gt;=&lt;span&gt; supportedCultures,
                SupportedUICultures &lt;/span&gt;=&lt;span&gt; supportedCultures
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到这里启动文件就设置好了。&lt;/p&gt;
&lt;p&gt;在根目录下新建Language目录，用于存放语言包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1502179/201907/1502179-20190719231330865-1891873623.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 语言包下的目录结构和MVC对应，控制器对应控制器，视图对应视图。&lt;/p&gt;
&lt;p&gt; 目录下新建资源文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1502179/201907/1502179-20190719232814746-187656561.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; CORE加载资源文件的方式有三种:URL,Cookie,请求头。我们这里采用Cookie。所以在打开首页的时候写了一个Cookie：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Response.Cookies.Append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.AspNetCore.Culture&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;c=en-US|uic=en-US&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
.AspNetCore.Culture为Cookie key。接下来就可以开始使用语言包了。&lt;p&gt;&lt;span&gt;&lt;strong&gt;控制器中使用：&lt;/strong&gt;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1502179/201907/1502179-20190719231743753-33784530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在控制器中加入：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IStringLocalizer&amp;lt;HomeController&amp;gt;&lt;span&gt; _localizer;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; HomeController(IStringLocalizer&amp;lt;HomeController&amp;gt;&lt;span&gt; localizer)
        {
            _localizer &lt;/span&gt;=&lt;span&gt; localizer;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来在使用语言的地方：&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1502179/201907/1502179-20190719231839380-918108035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; _localizer[&quot;资源文件中定义的名称&quot;]就可以读取到相应的语言了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;在视图中使用：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1502179/201907/1502179-20190719231958614-1951509823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;视图顶部引用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@using Microsoft.AspNetCore.Mvc.Localization
@inject IViewLocalizer Localizer&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在要使用语言的地方就可以使用了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1502179/201907/1502179-20190719232044270-180516525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
Localizer[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Welcome&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 19 Jul 2019 15:24:00 +0000</pubDate>
<dc:creator>roadflow工作流引擎</dc:creator>
<og:description>根据市场需求，基于.NET CORE平台开发的RoadFlow工作流平台需要实现多语言版本。经过方案讨论和比对，决定采用.NET自带的本地化功能来实现多语言。话不多说，直接上实现方式。 首先修改Sta</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/roadflow/p/11216173.html</dc:identifier>
</item>
<item>
<title>Netty使用Google Protocol Buffer完成服务器高性能数据传输 - monkjavaer</title>
<link>http://www.cnblogs.com/monkjavaer/p/11216084.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/monkjavaer/p/11216084.html</guid>
<description>&lt;h3 id=&quot;一什么是google-protocol-bufferprotobuf官方网站&quot;&gt;一、什么是Google Protocol Buffer（&lt;a href=&quot;https://developers.google.cn/protocol-buffers/&quot;&gt;protobuf官方网站&lt;/a&gt;）&lt;/h3&gt;
&lt;p&gt;下面是官网给的解释：&lt;br/&gt;Protocol buffers are a language-neutral, platform-neutral extensible mechanism for serializing structured data. – think XML, but smaller, faster, and simpler.&lt;br/&gt;协议缓冲区是一种和语言无关、平台无关的可扩展机制，用于序列化结构化的数据。相比于xml，它更小，更快，更简单。数据缓冲区常用语通信协议和数据存储。&lt;/p&gt;
&lt;h3 id=&quot;二protobuf的性能&quot;&gt;二、ProtoBuf的性能&lt;/h3&gt;
&lt;p&gt;序列化测试对比：&lt;br/&gt;Ser Time + Deser Time（ns）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/a6ff4f1d4e0f38b37c8a5f09827b7f66cd7fc367/68747470733a2f2f63686172742e676f6f676c65617069732e636f6d2f63686172743f6368743d626873266368733d36303078333134266368643d743a3639312c3737322c313438302c313531312c323437302c323834322c353534372c343430342c333533382c383532342c353539352c31303836392c353530312c31373136332c343335347c3735302c3739392c313333302c313331392c313735332c343632322c353839342c393431382c32303032352c31393137382c32333134342c31383530372c32363236332c32353433362c313431333332266368636f3d3564393966392c346438396639266368646c703d7426636862683d313526636864733d302c31343536383626636878723d312c302c31343536383626636878743d792c78266368786c3d303a7c786d6c2532464a4158427c79616d6c2532466a61636b736f6e2532466461746162696e647c6a6176612d6275696c742d696e2d73657269616c697a65727c6a736f6e253246666c65786a736f6e2532466461746162696e647c7374657068656e657269616c697a6174696f6e7c6a626f73732d6d61727368616c6c696e672d73657269616c7c6a626f73732d6d61727368616c6c696e672d72697665727c786d6c2532464a41584225324661616c746f7c6a626f73732d73657269616c697a6174696f6e7c6865737369616e7c6a626f73732d6d61727368616c6c696e672d72697665722d63747c6673747c6b72796f2d73657269616c697a65727c70726f746f73747566662d67726170682d72756e74696d657c70726f746f73747566662d6772617068&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面两个网站是效率测试实验：&lt;/p&gt;
&lt;h3 id=&quot;三使用intellij-idea插件自动生成java类&quot;&gt;三、使用Intellij IDEA插件自动生成Java类&lt;/h3&gt;
&lt;p&gt;参考我的另一篇文章：&lt;a href=&quot;https://www.cnblogs.com/monkjavaer/p/10222918.html&quot;&gt;Google Protocol Buffer 的使用(一)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;四netty和protobuf整合&quot;&gt;四、Netty和protobuf整合&lt;/h3&gt;
&lt;h4 id=&quot;准备我们的proto文件&quot;&gt;准备我们的proto文件&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;syntax = &quot;proto3&quot;;
package com.netty.protobuf;
option java_outer_classname = &quot;UserInfoProto&quot;;

//用户信息
message UserInfo{
    //姓名
    string name = 1;
    //住址
    repeated Address address= 2;
    //年龄
    uint32 age = 3;
}

//用户常用住址
message Address{
    string addressname = 1;
    uint32 adressno = 2;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;服务器中设置protobuf编码器和解码器&quot;&gt;服务器中设置protobuf编码器和解码器&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@Override
protected void initChannel(SocketChannel ch) throws Exception {
    ChannelPipeline pipeline = ch.pipeline();
    //protobuf解码器
    pipeline.addLast(new ProtobufVarint32FrameDecoder());
    pipeline.addLast(new ProtobufDecoder(UserInfoProto.UserInfo.getDefaultInstance()));
    //protobuf编码器
    pipeline.addLast(new ProtobufVarint32LengthFieldPrepender());
    pipeline.addLast(new ProtobufEncoder());
    pipeline.addLast(new NettyServerHandler());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;ProtobufVarint32FrameDecoder是protobuf方式的解码器，用于解决TCP粘包和拆包问题&lt;/li&gt;
&lt;li&gt;ProtobufDecoder 中设置我们的proto文件生成的实例，其实就是我们的目标Java类，设置方式为：UserInfoProto.UserInfo.getDefaultInstance()&lt;/li&gt;
&lt;li&gt;ProtobufVarint32LengthFieldPrepender和ProtobufEncoder是protobuf方式的编码器&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;处理类中写protobuf数据&quot;&gt;处理类中写protobuf数据&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    @Override
    public void channelActive(ChannelHandlerContext ctx) throws Exception {
        LOGGER.info(&quot;client {} connected.&quot;, ctx.channel().remoteAddress());
        UserInfoProto.UserInfo user = UserInfoProto.UserInfo.newBuilder()
                .setName(&quot;server&quot;)
                .setAge(18)
                .addAddress(
                        UserInfoProto.Address.newBuilder()
                                .setAddressname(&quot;beijing 001&quot;)
                                .setAdressno(911))
                .build();
        ctx.writeAndFlush(user);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;这里通过UserInfoProto.UserInfo.newBuilder()使用的时间其类的建造者模式设置用户相关信息。&lt;/li&gt;
&lt;li&gt;再通过ChannelHandlerContext的writeAndFlush方法写用户数据。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;处理器中读protobuf数据&quot;&gt;处理器中读protobuf数据&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    private int count = 0;
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        UserInfoProto.UserInfo message = (UserInfoProto.UserInfo) msg;
        LOGGER.info(&quot;server received message {}：{}&quot;, ++count, message);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;channelRead中的Object对象通过解码之后就是一个protobuf类对象，所以可以强转：UserInfoProto.UserInfo message = (UserInfoProto.UserInfo) msg;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;五注意事项tcp读半包处理&quot;&gt;五、注意事项（TCP读半包处理）&lt;/h3&gt;
&lt;p&gt;这里我们只是简单使用了netty自带的ProtobufVarint32FrameDecoder解码器来处理读半包问题，我们还可以自己继承ByteToMessageDecoder类实现一个定制化的解码器。比如我们使用Java客户端和C++服务器通过protobuf协议来通信时，就需要自己实现，同时还需要考虑大端、小端模式的转换问题。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jul 2019 14:41:00 +0000</pubDate>
<dc:creator>monkjavaer</dc:creator>
<og:description>一、什么是Google Protocol Buffer（ 'protobuf官方网站' ） 下面是官网给的解释： Protocol buffers are a language neutral, pl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/monkjavaer/p/11216084.html</dc:identifier>
</item>
<item>
<title>大厂程序员的一天是如何度过的？ - 黄小斜</title>
<link>http://www.cnblogs.com/xll1025/p/11216005.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xll1025/p/11216005.html</guid>
<description>&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;6i4h8-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6i4h8-0-0&quot;&gt;阅读本回答大概需要 5 分钟。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/50/v2-78a46bf34ac2572975c2b0173b9e9cf7_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;327&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic3.zhimg.com/50/v2-78a46bf34ac2572975c2b0173b9e9cf7_b.jpg&quot; data-watermark-src=&quot;https://pic2.zhimg.com/50/v2-a71d8f9dcc46d8e0df2398d0ee3624b9_b.jpg&quot; data-private-watermark-src=&quot;https://pic4.zhimg.com/50/v2-8d306c0cefea81d92b9f0ae510452b91_b.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;


&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;esd7r-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;esd7r-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;小李是一位大公司里的程序员，虽然已经在公司上班一年了，但也只能算是个新人，毕竟 title 摆在那里。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;cf652-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;cf652-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;小李做的项目不算核心项目，但是至少在技术栈上还是比较有有深度的，所以小李对现在的工作还算满意，就是工作压力大了点。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;9fg1n-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;9fg1n-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这一天早上，小李照常准时起床，因为家里离公司有半小时的车程，所以他不得不在七点多就匆忙地从床上爬起来，很熟练地完成了洗漱、吃早餐、换衣服等动作，然后踏上挤地铁的上班之路。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;ebith-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ebith-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;每天这个时候，小李都要从熙熙攘攘的人群中穿过，直到最终的目的地，那就是公司。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;fqsmq-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fqsmq-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;在路上奔波了半天的小李，终于到达了公司，进公司第一件事就是排队等电梯。每天九点是电梯的高峰期，小李，看着前面长长的队伍，心里不由得叹一口气：唉，又要迟到了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;7r68v-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7r68v-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;好不容易挤上了电梯，来到了自己所在的工位，小李扔下双肩包，往椅子上一坐，差点就来了个葛优躺。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic2.zhimg.com/50/v2-46e9a79acafb8db027ecd8c68375c7de_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;359&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic2.zhimg.com/50/v2-46e9a79acafb8db027ecd8c68375c7de_b.jpg&quot; data-watermark-src=&quot;https://pic2.zhimg.com/50/v2-13d12e8dd8094b7378fb3c87f12ef977_b.jpg&quot; data-private-watermark-src=&quot;https://pic1.zhimg.com/50/v2-4ab62f240270277058b3f6ae966d8861_b.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;f32oo-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;f32oo-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;“小李，来开早会了&quot;，主管喊到，于是十几个人围成一圈，大家开始讨论今天的工作进度，以及昨天的工作情况。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;bhtkm-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bhtkm-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;轮到小李来讲了，小李好像还没睡醒，犹豫了半天，赶紧说到：今天我打算做a项目的xx开发工作，目前完成了百分之多少，测试了完成了百分之多少，什么时候准备发布上线。诸如此类的话，小李每天都要说。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;6a9p1-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;6a9p1-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;开完早会，小李回到了自己的工位上，开始吭哧吭哧的写代码。小李有个好习惯，就是喜欢在工作之前把今天的任务清单列出来，排个优先级，这样子他的一天的效率会更高。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;221pr-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;221pr-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;今天先做什么呢？小李想，a项目下周就要发布了，果断应该先做a项目呀。B项目要有产品经理在催，耽误了也不好呀，那么b项目就放在第二位吧。对了，今天还有一个会议，别忘记了，上次开会迟到，被领导当众点名，让小李臊得慌。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;1u5ib-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;1u5ib-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;于是今天的工作清单就这么出来了，当然小李也不是每天都会列工作清单，有时候工作一忙就忘记了，有时候光是修一个 bug ，小李就要花上一天的时间。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;90edd-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;90edd-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;完成了早上的工作之后，终于熬到了中午。同事们喊小李一起吃饭：今天再去上次那家店吧！小李，连忙答应，吃饭的时间应该是程序员一天中最轻松的时间了，大家纷纷把手机掏出来，做着和工作毫不相关的事情。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;fjlpr-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fjlpr-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;只不过轻松的时间总是短暂的，吃完午饭回来，小李拖着疲惫的身躯继续写代码，看着旁边午休的同事，小李不由得心生羡慕：唉，我也想午睡啊，可惜工作还没做完，还是算了吧。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;4kj8k-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4kj8k-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;于是，小李继续下午的代码工作，下午的时间比早上时间要长得多，于是小李开始感觉到疲惫和困倦。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;658ed-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;658ed-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;脖子怎么又酸了？腰也不太舒服，我是不是不太适合程序员这个工作，小李经常这么问自己。好不容易熬到晚上，本想吃个饭就走人的，结果同事们不约而同地都回到工位上，似乎没有要走的意思。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;ecgkk-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ecgkk-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;于是小李只好返回工位。继续兢兢业业的写代码，总不能自己一个人先走吧，多不合群呀，实在不合适呀。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Image-resizerContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;
&lt;div class=&quot;Image-captionContainer&quot; data-size=&quot;normal&quot;&gt;
&lt;div&gt;&lt;img class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; src=&quot;https://pic3.zhimg.com/50/v2-274179d92fad6a9898b18be17db9a48e_b.jpg&quot; alt=&quot;&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;500&quot; data-rawheight=&quot;366&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic3.zhimg.com/50/v2-274179d92fad6a9898b18be17db9a48e_b.jpg&quot; data-watermark-src=&quot;https://pic2.zhimg.com/50/v2-c5d914e5bb1c78cd759d2a524002f4dc_b.jpg&quot; data-private-watermark-src=&quot;https://pic4.zhimg.com/50/v2-e111d03fcc26d6ae1e2e6bc111f4b4ea_b.jpg&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;28c04-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;28c04-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;晚上把这部分工作做完就走吧，小李心里想。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;eqbh6-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;eqbh6-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;时间来到了九点，小李发现手头上还有一一样工作还没做。于是小李苦恼地摇摇头，看来今天又要加班了，于是硬着头皮又写了一会代码。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;dtetr-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;dtetr-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;终于把手头上的工作搞定的，一看手机，已经十点半了，整个人疲惫的不行，一看同事们也打算走了，于是小李拿起书包，和大家一起离开了公司。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;f19a9-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;f19a9-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;小李回到家已经是11点多了，他甚至连看电视的力气都没有了，洗漱完倒头躺在床上，没过多久，他便睡着了，在睡梦里，小李非常轻松，没有工作的压力，没有生活的负担，只有单调的呼噜声。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;ept1v-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ept1v-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;没过多久，闹钟又响了，小李非常不情愿地睁开眼睛，一看闹钟，已经七点半了。好想再睡一会儿啊，小李心里想，可是谁让公司要打卡签到呢，于是小李的小梦想又破灭了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;370f8-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;370f8-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;这是一个悲伤的故事吗？似乎不是，这是一个令人向往的故事吗？似乎也不是，互联网公司就如一个围城，外面的人想进来，里面的人想出去，当然也有更多人想在里面继续修行，也许这就是大公司的魅力所在吧。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;3s7k6-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3s7k6-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;职场也是一种修行，只不过在大公司里，不管你愿不愿意，你都会离舒适区更远，也会成长得更快。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;blockquote class=&quot;Editable-styled&quot; data-block=&quot;true&quot; data-editor=&quot;4rk4g&quot; data-offset-key=&quot;3fg1i-0-0&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3fg1i-0-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;文章作者 黄小斜 &lt;span data-offset-key=&quot;3fg1i-0-1&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;3fg1i-0-2&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;大厂程序员，互联网职场新知，终身学习践行者，懂技术，懂职场，更想懂你。据说，每个上进又好看的互联网人都关注我了&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 19 Jul 2019 14:16:00 +0000</pubDate>
<dc:creator>黄小斜</dc:creator>
<og:description>阅读本回答大概需要 5 分钟。 阅读本回答大概需要 5 分钟。 小李是一位大公司里的程序员，虽然已经在公司上班一年了，但也只能算是个新人，毕竟 title 摆在那里。 小李是一位大公司里的程序员，虽然</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xll1025/p/11216005.html</dc:identifier>
</item>
<item>
<title>Django基础五之django模型层(一)单表操作 - 爱文飞翔</title>
<link>http://www.cnblogs.com/an-wen/p/11215898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/an-wen/p/11215898.html</guid>
<description>&lt;h3 id=&quot;一-orm简介&quot;&gt;一 ORM简介&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;MVC或者MVC框架中包括一个重要的部分，就是ORM，它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通过简单的配置就可以轻松更换数据库，这极大的减轻了开发人员的工作量，不需要面对因数据库变更而导致的无效劳动&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ORM是“对象-关系-映射”的简称&lt;/strong&gt;。&lt;strong&gt;（Object Relational Mapping，简称ORM）&lt;/strong&gt;(将来会学一个sqlalchemy，是和他很像的，但是django的orm没有独立出来让别人去使用，虽然功能比sqlalchemy更强大，但是别人用不了)&lt;/li&gt;
&lt;li&gt;类对象---&amp;gt;sql---&amp;gt;pymysql---&amp;gt;mysql服务端---&amp;gt;磁盘，orm其实就是将类对象的语法翻译成sql语句的一个引擎，明白orm是什么了，剩下的就是怎么使用orm，怎么来写类对象关系语句。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1680442/201907/1680442-20190719214803886-529200792.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;| &lt;strong&gt;原生sql和python的orm代码对比&lt;/strong&gt; |&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#sql中的表                                                      
 #创建表:
     CREATE TABLE employee(                                     
                id INT PRIMARY KEY auto_increment ,                    
                name VARCHAR (20),                                      
                gender BIT default 1,                                  
                birthday DATA ,                                         
                department VARCHAR (20),                                
                salary DECIMAL (8,2) unsigned,                          
              );

  #sql中的表纪录                                                  
  #添加一条表纪录:                                                          
      INSERT employee (name,gender,birthday,salary,department)            
             VALUES   (&quot;alex&quot;,1,&quot;1985-12-12&quot;,8000,&quot;保洁部&quot;);               

  #查询一条表纪录:                                                           
      SELECT * FROM employee WHERE age=24;                               

  #更新一条表纪录:                                                           
      UPDATE employee SET birthday=&quot;1989-10-24&quot; WHERE id=1;              

  #删除一条表纪录:                                                          
      DELETE FROM employee WHERE name=&quot;alex&quot;                             


#python的类
class Employee(models.Model):
     id=models.AutoField(primary_key=True)
     name=models.CharField(max_length=32)
     gender=models.BooleanField()
     birthday=models.DateField()
     department=models.CharField(max_length=32)
     salary=models.DecimalField(max_digits=8,decimal_places=2)

 #python的类对象
      #添加一条表纪录:
          emp=Employee(name=&quot;alex&quot;,gender=True,birthday=&quot;1985-12-12&quot;,epartment=&quot;保洁部&quot;)
          emp.save()
      #查询一条表纪录:
          Employee.objects.filter(age=24)
      #更新一条表纪录:
          Employee.objects.filter(id=1).update(birthday=&quot;1989-10-24&quot;)
      #删除一条表纪录:
          Employee.objects.filter(name=&quot;alex&quot;).delete()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二-单表操作&quot;&gt;二 单表操作&lt;/h3&gt;
&lt;h2 id=&quot;一创建表&quot;&gt;一、创建表&lt;/h2&gt;
&lt;h3 id=&quot;创建模型&quot;&gt;创建模型&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1680442/201907/1680442-20190719214839836-1038179668.jpg&quot;/&gt;&lt;br/&gt;| 创建名为app01的app，在app01下的models.py中创建模型： |&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from django.db import models

# Create your models here.
class UserInfo(models.Model):
    id = models.AutoField(primary_key=True)#如果表里面没有写主键，表里面会自动生成一个自增主键字段，叫做id字段，orm要求每个表里面必须要写一个主键
    name = models.CharField(max_length=16)#和varchar(16)是一样的，16个字符
    age = models.IntegerField() #int
    current_date = models.DateField()#必须存这种格式&quot;2018-12-12&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 接下来要创建对应的数据，连接上对应的数据库，然后执行创建表的命令，翻译成相应的sql，然后到数据库里面执行，从而创建对应的表。多了一步orm翻译成sql的过程，效率低了，但是没有太大的损伤，还能忍受，当你不能忍的时候，你可以自己写原生sql语句，一般的场景orm都够用了，开发起来速度更快，写法更贴近应用程序开发，还有一点就是数据库升级或者变更，那么你之前用sql语句写的数据库操作，那么就需要将sql语句全部修改，但是如果你用orm，就不需要担心这个问题，不管是你从mysql变更到oracle还是从oracle更换到mysql，你如果用的是orm来搞的，你只需要修改一下orm的引擎（配置文件里面改一些配置就搞定）就可以了，你之前写的那些orm语句还是会自动翻译成对应数据库的sql语句。&lt;/p&gt;
&lt;p&gt;简单提一下sqlite数据库：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1680442/201907/1680442-20190719215006601-2125605691.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1680442/201907/1680442-20190719215046076-1106420899.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;不连接mysql的话默认连接的是sqlite数据库&quot;&gt;不连接mysql的话,默认连接的是sqlite数据库&lt;/h3&gt;
&lt;h3 id=&quot;settings配置&quot;&gt;2 .settings配置&lt;/h3&gt;
&lt;p&gt;　　　若想将模型转为mysql数据库中的表，需要在settings中配置：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#settings.py 文件中找DATABASES这个配置,改为
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME':'bms',     　　 　  # 要连接的数据库，连接前需要创建好
        'USER':'root',　　　　　　  # 连接数据库的用户名
        'PASSWORD':'',　　　　　　  # 连接数据库的密码
        'HOST':'127.0.0.1',       # 连接主机，默认本级
        'PORT'：3306    　　　     #  端口 默认3306
    }，
    'app01': { #可以为每个app都配置自己的数据，并且数据库还可以指定别的，也就是不一定就是mysql，也可以指定sqlite等其他的数据库
        'ENGINE': 'django.db.backends.mysql',
        'NAME':'bms',     　　 　  # 要连接的数据库，连接前需要创建好
        'USER':'root',　　　　　　  # 连接数据库的用户名
        'PASSWORD':'',　　　　　　  # 连接数据库的密码
        'HOST':'127.0.0.1',       # 连接主机，默认本级
        'PORT'：3306    　　　     #  端口 默认3306
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意1：&lt;/strong&gt;NAME即数据库的名字，在mysql连接前该数据库必须已经创建，而上面的sqlite数据库下的db.sqlite3则是项目自动创建 USER和PASSWORD分别是数据库的用户名和密码。&lt;strong&gt;设置完后，再启动我们的Django项目前，我们需要激活我们的mysql&lt;/strong&gt;。然后，启动项目，会报错：no module named MySQLdb 。这是因为django默认你导入的驱动是MySQLdb，可是MySQLdb 对于py3有很大问题，所以我们需要的驱动是PyMySQL 所以，我们只需要找到项目名文件下的__init__,在里面写入：　　&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pymysql
pymysql.install_as_MySQLdb()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;最后通过两条数据库迁移命令即可在指定的数据库中创建表&lt;/strong&gt; ：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;python manage.py makemigrations  #生成记录，每次修改了models里面的内容或者添加了新的app，新的app里面写了models里面的内容，都要执行这两条
python manage.py migrate         #执行上面这个语句的记录来创建表，生成的表名字前面会自带应用的名字，例如：你的userinfo表在mysql里面叫做app01_userinfo表&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;关于同步指令的执行简单原理&quot;&gt;关于同步指令的执行简单原理：&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;在执行 python manager.py magrations 时django 会在相应的 app 的migration文件夹下面生成 一个python脚本文件 
    在执行 python manager.py migrte 时 django才会生成数据库表，那么django是如何生成数据库表的呢，
    django是根据 migration下面的脚本文件来生成数据表的
    每个migration文件夹下面有多个脚本，那么django是如何知道该执行那个文件的呢，django有一张django-migrations表，表中记录了已经执行的脚本，那么表中没有的就是还没执行的脚本，则 执行migrate的时候就只执行表中没有记录的那些脚本。
    有时在执行 migrate 的时候如果发现没有生成相应的表，可以看看在 django-migrations表中看看 脚本是否已经执行了，
    可以删除 django-migrations 表中的记录 和 数据库中相应的 表 ， 然后重新 执行&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;通过pycharm提供的功能来执行manage.py相关的指令&quot;&gt;通过pycharm提供的功能来执行manage.py相关的指令：&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1680442/201907/1680442-20190719215117587-239015511.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;更多字段和参数&quot;&gt;3.更多字段和参数&lt;/h3&gt;
&lt;p&gt;​ 每个字段有一些特有的参数，例如，CharField需要max_length参数来指定&lt;code&gt;VARCHAR&lt;/code&gt;数据库字段的大小。还有一些适用于所有字段的通用参数。 这些参数在文档中有详细定义，这里我们只简单介绍一些最常用的：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多字段：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;lt;1&amp;gt; CharField 字符串字段, 用于较短的字符串.
    CharField 要求必须有一个参数 maxlength, 用于从数据库层和Django校验层限制该字段所允许的最大字符数.
 
&amp;lt;2&amp;gt; IntegerField    #用于保存一个整数.
 
&amp;lt;3&amp;gt; DecimalField    #一个浮点数. 必须 提供两个参数:
        参数    描述
     max_digits    总位数(不包括小数点和符号)
     decimal_places    小数位数
     举例来说, 要保存最大值为 999 (小数点后保存2位),你要这样定义字段:
     models.DecimalField(..., max_digits=5, decimal_places=2)
     要保存最大值一百万(小数点后保存10位)的话,你要这样定义:
     models.DecimalField(..., max_digits=17, decimal_places=10) #max_digits大于等于17就能存储百万以上的数了
     admin 用一个文本框(&amp;lt;input type=&quot;text&quot;&amp;gt;)表示该字段保存的数据.
 
&amp;lt;4&amp;gt; AutoField
        一个 IntegerField, 添加记录时它会自动增长. 你通常不需要直接使用这个字段;
        自定义一个主键：my_id=models.AutoField(primary_key=True)
        如果你不指定主键的话,系统会自动添加一个主键字段到你的 model.
 
&amp;lt;5&amp;gt; BooleanField
        A true/false field. admin 用 checkbox 来表示此类字段.
 
&amp;lt;6&amp;gt; TextField   #一个容量很大的文本字段.
        admin 用一个 &amp;lt;textarea&amp;gt; (文本区域)表示该字段数据.(一个多行编辑框).
 
&amp;lt;7&amp;gt; EmailField
        一个带有检查Email合法性的 CharField,不接受 maxlength 参数.
 
&amp;lt;8&amp;gt; DateField       #一个日期字段. 共有下列额外的可选参数:
        Argument    描述
        auto_now    当对象被保存时(更新或者添加都行),自动将该字段的值设置为当前时间.通常用于表示 &quot;last-modified&quot; 时间戳.
        auto_now_add    当对象首次被创建时,自动将该字段的值设置为当前时间.通常用于表示对象创建时间.
        （仅仅在admin中有意义...)
 
&amp;lt;9&amp;gt; DateTimeField
         一个日期时间字段. 类似 DateField 支持同样的附加选项.
 
&amp;lt;10&amp;gt; ImageField
        类似 FileField, 不过要校验上传对象是否是一个合法图片.#它有两个可选参数:height_field和width_field,
        如果提供这两个参数,则图片将按提供的高度和宽度规格保存.    
&amp;lt;11&amp;gt; FileField
     一个文件上传字段.
     要求一个必须有的参数: upload_to, 一个用于保存上载文件的本地文件系统路径. 这个路径必须包含 strftime #formatting,
     该格式将被上载文件的 date/time
     替换(so that uploaded files don't fill up the given directory).
     admin 用一个&amp;lt;input type=&quot;file&quot;&amp;gt;部件表示该字段保存的数据(一个文件上传部件) .
 
     注意：在一个 model 中使用 FileField 或 ImageField 需要以下步骤:
            （1）在你的 settings 文件中, 定义一个完整路径给 MEDIA_ROOT 以便让 Django在此处保存上传文件.
            (出于性能考虑,这些文件并不保存到数据库.) 定义MEDIA_URL 作为该目录的公共 URL. 要确保该目录对
             WEB服务器用户帐号是可写的.
            （2） 在你的 model 中添加 FileField 或 ImageField, 并确保定义了 upload_to 选项,以告诉 Django
             使用 MEDIA_ROOT 的哪个子目录保存上传文件.你的数据库中要保存的只是文件的路径(相对于 MEDIA_ROOT).
             出于习惯你一定很想使用 Django 提供的 get_&amp;lt;#fieldname&amp;gt;_url 函数.举例来说,如果你的 ImageField
             叫作 mug_shot, 你就可以在模板中以 {{ object.#get_mug_shot_url }} 这样的方式得到图像的绝对路径.
 
&amp;lt;12&amp;gt; URLField
      用于保存 URL. 若 verify_exists 参数为 True (默认), 给定的 URL 会预先检查是否存在( 即URL是否被有效装入且
      没有返回404响应).
      admin 用一个 &amp;lt;input type=&quot;text&quot;&amp;gt; 文本框表示该字段保存的数据(一个单行编辑框)
 
&amp;lt;13&amp;gt; NullBooleanField
       类似 BooleanField, 不过允许 NULL 作为其中一个选项. 推荐使用这个字段而不要用 BooleanField 加 null=True 选项
       admin 用一个选择框 &amp;lt;select&amp;gt; (三个可选择的值: &quot;Unknown&quot;, &quot;Yes&quot; 和 &quot;No&quot; ) 来表示这种字段数据.
 
&amp;lt;14&amp;gt; SlugField
       &quot;Slug&quot; 是一个报纸术语. slug 是某个东西的小小标记(短签), 只包含字母,数字,下划线和连字符.#它们通常用于URLs
       若你使用 Django 开发版本,你可以指定 maxlength. 若 maxlength 未指定, Django 会使用默认长度: 50.  #在
       以前的 Django 版本,没有任何办法改变50 这个长度.
       这暗示了 db_index=True.
       它接受一个额外的参数: prepopulate_from, which is a list of fields from which to auto-#populate
       the slug, via JavaScript,in the object's admin form: models.SlugField
       (prepopulate_from=(&quot;pre_name&quot;, &quot;name&quot;))prepopulate_from 不接受 DateTimeFields.
 
&amp;lt;13&amp;gt; XMLField
        一个校验值是否为合法XML的 TextField,必须提供参数: schema_path, 它是一个用来校验文本的 RelaxNG schema #的文件系统路径.
 
&amp;lt;14&amp;gt; FilePathField
        可选项目为某个特定目录下的文件名. 支持三个特殊的参数, 其中第一个是必须提供的.
        参数    描述
        path    必需参数. 一个目录的绝对文件系统路径. FilePathField 据此得到可选项目.
        Example: &quot;/home/images&quot;.
        match    可选参数. 一个正则表达式, 作为一个字符串, FilePathField 将使用它过滤文件名. 
        注意这个正则表达式只会应用到 base filename 而不是
        路径全名. Example: &quot;foo.*\.txt^&quot;, 将匹配文件 foo23.txt 却不匹配 bar.txt 或 foo23.gif.
        recursive可选参数.要么 True 要么 False. 默认值是 False. 是否包括 path 下面的全部子目录.
        这三个参数可以同时使用.
        match 仅应用于 base filename, 而不是路径全名. 那么,这个例子:
        FilePathField(path=&quot;/home/images&quot;, match=&quot;foo.*&quot;, recursive=True)
        ...会匹配 /home/images/foo.gif 而不匹配 /home/images/foo/bar.gif
 
&amp;lt;15&amp;gt; IPAddressField
        一个字符串形式的 IP 地址, (i.e. &quot;24.124.1.30&quot;).
&amp;lt;16&amp;gt; CommaSeparatedIntegerField
        用于存放逗号分隔的整数值. 类似 CharField, 必须要有maxlength参数.
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;更多参数：&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;(1)null
如果为True，Django 将用NULL 来在数据库中存储空值。 默认值是 False.
 
(1)blank
如果为True，该字段允许不填。默认为False。
要注意，这与 null 不同。null纯粹是数据库范畴的，而 blank 是数据验证范畴的。
如果一个字段的blank=True，表单的验证将允许该字段是空值。如果字段的blank=False，该字段就是必填的。
 
(2)default
字段的默认值。可以是一个值或者可调用对象。如果可调用 ，每有新对象被创建它都会被调用，如果你的字段没有设置可以为空，那么将来如果我们后添加一个字段，这个字段就要给一个default值
 
(3)primary_key
如果为True，那么这个字段就是模型的主键。如果你没有指定任何一个字段的primary_key=True，
Django 就会自动添加一个IntegerField字段做为主键，所以除非你想覆盖默认的主键行为，
否则没必要设置任何一个字段的primary_key=True。
 
(4)unique
如果该值设置为 True, 这个数据字段的值在整张表中必须是唯一的
 
(5)choices
由二元组组成的一个可迭代对象（例如，列表或元组），用来给字段提供选择项。 如果设置了choices ，默认的表单将是一个选择框而不是标准的文本框，&amp;lt;br&amp;gt;而且这个选择框的选项就是choices 中的选项。
(6)db_index
　　如果db_index=True 则代表着为此字段设置数据库索引。
DatetimeField、DateField、TimeField这个三个时间字段，都可以设置如下属性。

(7)auto_now_add
    配置auto_now_add=True，创建数据记录的时候会把当前时间添加到数据库。

(8)auto_now
    配置上auto_now=True，每次更新数据记录的时候会更新该字段，标识这条记录最后一次的修改时间。&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;orm单表操作&quot;&gt;ORM单表操作&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;在python中orm的对应关系有三种：
　　　　类    ----------&amp;gt;表
　　　　类对象 ----------&amp;gt;行(记录)
　　　　类属性 ----------&amp;gt;表的字段（重点）&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;添加表纪录&quot;&gt;添加表纪录&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;创建记录方式1
    student_obj = models.Student(
        name='anwen',
        age=23,
    )
    student_obj.save()
创建记录方式2
    new_obj = models.Student.objects.create(name='anwen2',age=6) #写成 **{'name':'xx'}
    print(new_obj)  #Student object --  model对象
    print(new_obj.name)  #点属性,可以获取对应字段的数据
    print(new_obj.age)

创建方式3 批量创建
    objs_list = []
    for i in range(100,3000000):
        obj = models.Student(
            name='xiangxixxx',
            age = 10,
        )
        objs_list.append(obj)

    models.Student.objects.bulk_create(objs_list)

创建方法4 update_or_create 有就更新,没有就创建
    models.Student.objects.update_or_create(
        name='妹妹2',
        defaults={
            'age':38,
        }
    )

添加日期数据
    import datetime
    current_date = datetime.datetime.now()
    # print(current_date) #2019-07-19 12:19:26.385654
    # 两种方式
    # models.Brithday.objects.create(name='anwen',date=current_date)
    # models.Brithday.objects.create(name='yage',date='2000-12-08')
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;删除表纪录&quot;&gt;删除表纪录&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt; 删除  delete  queryset 和model对象都可以调用
    models.Student.objects.get(id=3).delete()  #model对象来调用的delete方法
    models.Student.objects.filter(name='anwen').delete() #
    models.Student.objects.all().delete() #删除所有&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;修改表纪录&quot;&gt;修改表纪录&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;更新 update方法 model对象不能调用更新方法 报错信息'Student' object has no attribute 'update'
    只能queryset调用,如果
    models.Student.objects.get(name='anwen').update(age=38)
    models.Student.objects.filter(name='anwen').update(age=38)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查询表纪录&quot;&gt;查询表纪录&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;查询所有的数据  .all方法 返回的是queryset集合
    all_objs = models.Student.objects.all()
    #&amp;lt;QuerySet [&amp;lt;Student: Student object&amp;gt;, &amp;lt;Student: Student object&amp;gt;, &amp;lt;Student: Student object&amp;gt;]&amp;gt; -- 类似于列表  --  queryset集合
    # for i in all_objs:
    #     print(i.name)
    print(all_objs)

条件查询  .filter方法,返回的也是queryset集合,查询不到内容,不会 报错,返回一个&amp;lt;QuerySet []&amp;gt;空的queryset
    objs = models.Student.objects.filter(id=2)  #找id为2的那条记录
    print(objs) #&amp;lt;QuerySet [&amp;lt;Student: anwne&amp;gt;]&amp;gt;
    objs = models.Student.objects.filter(name='anwen')
    print(objs) #&amp;lt;QuerySet [&amp;lt;Student: anwen&amp;gt;]&amp;gt;

条件查询 get方法,返回的是model对象,而且get方法有且必须只有1个结果
    obj = models.Student.objects.get(id=3)  #找id为3的那条记录
    print(obj)  #anwen&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查询接口都是重点&quot;&gt;查询接口（都是重点）&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&amp;lt;1&amp;gt; all():      查询所有结果，结果是queryset类型
  
&amp;lt;2&amp;gt; filter(**kwargs):       它包含了与所给筛选条件相匹配的对象，结果也是queryset类型 Book.objects.filter(title='linux',price=100) #里面的多个条件用逗号分开，并且这几个条件必须都成立，是and的关系，or关系的我们后面再学，直接在这里写是搞不定or的
    models.Student.objects.filter(id=7,name='anwen',age=78).update(
        name='anwen',
        age=78
    )
    #打伞形式传参
    models.Student.objects.filter(**{'id':7,'name':'anwen'}).update(age=100)
    models.Student.objects.all().filter(id=7)  queryset类型可以调用fitler在过滤
  
&amp;lt;3&amp;gt; get(**kwargs):          返回与所给筛选条件相匹配的对象，不是queryset类型，是行记录对象，返回结果有且只有一个，如果符合筛选条件的对象超过一个或者没有都会抛出错误。捕获异常try。Book.objects.get(id=1)
  
&amp;lt;4&amp;gt; exclude(**kwargs):      排除的意思，它包含了与所给筛选条件不匹配的对象，没有不等于的操作昂，用这个exclude，返回值是queryset类型 Book.objects.exclude(id=6)，返回id不等于6的所有的对象，或者在queryset基础上调用，Book.objects.all().exclude(id=6)
    # exclude(**kwargs): 排除,objects控制器和queryset集合都可以调用,返回结果是queryset类型
    # query = models.Student.objects.exclude(id=1)
    # print(query)
    # query = models.Student.objects.filter(age=38).exclude(id=6)
    # print(query)
 　　　　　　　　　　　　　　　　
&amp;lt;5&amp;gt; order_by(*field):       queryset类型的数据来调用，对查询结果排序,默认是按照id来升序排列的，返回值还是queryset类型models.Book.objects.all().order_by('price','id') #直接写price，默认是按照price升序排列，按照字段降序排列，就写个负号就行了order_by('-price'),order_by('price','id')是多条件排序，按照price进行升序，price相同的数据，按照id进行升序
        
        
&amp;lt;6&amp;gt; reverse():      queryset类型的数据来调用，对查询结果反向排序，返回值还是queryset类型
            # 排序之后反转
            # query = models.Student.objects.all().order_by('id').reverse()
            # print(query)

&amp;lt;7&amp;gt; count():        queryset类型的数据来调用，返回数据库中匹配查询(QuerySet)的对象数量。
  
&amp;lt;8&amp;gt; first():        queryset类型的数据来调用，返回第一条记录 Book.objects.all()[0] = Book.objects.all().first()，得到的都是model对象，不是queryset
  
&amp;lt;9&amp;gt; last():         queryset类型的数据来调用，返回最后一条记录,结果为model对象类型
  
&amp;lt;10&amp;gt; exists():      queryset类型的数据来调用，如果QuerySet包含数据，就返回True，否则返回False
空的queryset类型数据也有布尔值True和False，但是一般不用它来判断数据库里面是不是有数据，如果有大量的数据，你用它来判断，那么就需要查询出所有的数据，效率太差了，用count或者exits
　　　　　　　　　　　　　　　　 例：all_books = models.Book.objects.all().exists() #翻译成的sql是SELECT (1) AS `a` FROM `app01_book` LIMIT 1，就是通过limit 1，取一条来看看是不是有数据

&amp;lt;11&amp;gt; values(*field):        用的比较多，queryset类型的数据来调用，返回一个ValueQuerySet——一个特殊的QuerySet，运行后得到的并不是一系列,model的实例化对象，而是一个可迭代的字典序列,只要是返回的queryset类型，就可以继续链式调用queryset类型的其他的查找方法，其他方法也是一样的。
&amp;lt;12&amp;gt; values_list(*field):   它与values()非常相似，它返回的是一个元组序列，values返回的是一个字典序列
 
&amp;lt;13&amp;gt; distinct():      values和values_list得到的queryset类型的数据来调用，从返回结果中剔除重复纪录,结果还是queryset
    query = models.Student.objects.all().values('age').distinct()
    print(query)
    
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基于双下划线的模糊查询&quot;&gt;基于双下划线的模糊查询　&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;Book.objects.filter(price__in=[100,200,300]) #price值等于这三个里面的任意一个的对象
Book.objects.filter(price__gt=100)  #大于，大于等于是price__gte=100，别写price&amp;gt;100，这种参数不支持
Book.objects.filter(price__lt=100)
Book.objects.filter(price__range=[100,200])  #sql的between and，大于等于100，小于等于200
Book.objects.filter(title__contains=&quot;python&quot;)  #title值中包含python的
Book.objects.filter(title__icontains=&quot;python&quot;) #不区分大小写
Book.objects.filter(title__startswith=&quot;py&quot;) #以什么开头，istartswith  不区分大小写
Book.objects.filter(pub_date__year=2012)

# all_books = models.Book.objects.filter(pub_date__year=2012) #找2012年的所有书籍
    # all_books = models.Book.objects.filter(pub_date__year__gt=2012)#找大于2012年的所有书籍
    all_books = models.Book.objects.filter(pub_date__year=2019,pub_date__month=2)#找2019年月份的所有书籍，如果明明有结果，你却查不出结果，是因为mysql数据库的时区和咱们django的时区不同导致的，了解一下就行了，你需要做的就是将django中的settings配置文件里面的USE_TZ = True改为False，就可以查到结果了，以后这个值就改为False，而且就是因为咱们用的mysql数据库才会有这个问题，其他数据库没有这个问题。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;补充&quot;&gt;补充&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#关于django连接mysql的时指定严格模式的配置
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'mxshop',
        'HOST': '127.0.0.1',
        'PORT': '3306',
        'USER': 'root',
        'PASSWORD': '123',
        'OPTIONS': {
            &quot;init_command&quot;: &quot;SET default_storage_engine='INNODB'&quot;,
　　　　　　　#'init_command': &quot;SET sql_mode='STRICT_TRANS_TABLES'&quot;,
        }
    }
}
DATABASES['default']['OPTIONS']['init_command'] = &quot;SET sql_mode='STRICT_TRANS_TABLES'&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;附orm字段与数据库实际字段的对应关系&quot;&gt;&lt;strong&gt;附ORM字段与数据库实际字段的对应关系:&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;'AutoField': 'integer AUTO_INCREMENT',
    'BigAutoField': 'bigint AUTO_INCREMENT',
    'BinaryField': 'longblob',
    'BooleanField': 'bool',
    'CharField': 'varchar(%(max_length)s)',
    'CommaSeparatedIntegerField': 'varchar(%(max_length)s)',
    'DateField': 'date',
    'DateTimeField': 'datetime',
    'DecimalField': 'numeric(%(max_digits)s, %(decimal_places)s)',
    'DurationField': 'bigint',
    'FileField': 'varchar(%(max_length)s)',
    'FilePathField': 'varchar(%(max_length)s)',
    'FloatField': 'double precision',
    'IntegerField': 'integer',
    'BigIntegerField': 'bigint',
    'IPAddressField': 'char(15)',
    'GenericIPAddressField': 'char(39)',
    'NullBooleanField': 'bool',
    'OneToOneField': 'integer',
    'PositiveIntegerField': 'integer UNSIGNED',
    'PositiveSmallIntegerField': 'smallint UNSIGNED',
    'SlugField': 'varchar(%(max_length)s)',
    'SmallIntegerField': 'smallint',
    'TextField': 'longtext',
    'TimeField': 'time',
    'UUIDField': 'char(32)',&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如果想打印orm转换过程中的sql需要在settings中进行如下配置学了增加记录的语句在过来配置吧&quot;&gt;如果想打印orm转换过程中的sql，需要在settings中进行如下配置：（学了增加记录的语句在过来配置吧）&lt;/h3&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'handlers': {
        'console':{
            'level':'DEBUG',
            'class':'logging.StreamHandler',
        },
    },
    'loggers': {
        'django.db.backends': {
            'handlers': ['console'],
            'propagate': True,
            'level':'DEBUG',
        },
    }
}　　&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 19 Jul 2019 13:52:00 +0000</pubDate>
<dc:creator>爱文飞翔</dc:creator>
<og:description>Django基础五之django模型层(一)单表操作 一 ORM简介 MVC或者MVC框架中包括一个重要的部分，就是ORM，它实现了数据模型与数据库的解耦，即数据模型的设计不需要依赖于特定的数据库，通</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/an-wen/p/11215898.html</dc:identifier>
</item>
<item>
<title>优水•智能水箱系统（项目） - 东小东</title>
<link>http://www.cnblogs.com/dongxiaodong/p/11214461.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxiaodong/p/11214461.html</guid>
<description>&lt;p&gt;&lt;strong&gt;时间：2018年6月&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阶段：大二下学期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;背景：自动化检测系统设计课设&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;名称：优水•智能水箱系统&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;摘要&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;优水•智能水箱系统定位于定制型楼顶水箱的管理。系统使用有WiFi组网技术、水位检测技术、霍尔接近开关技术、安卓编程技术等技术相互结合，实现多级控制台管理和控制水箱功能，使家庭水箱的管理更加便捷及人性化。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在信息化迅速发展的今天,我国许多地区水塔水箱供水系统的硬件设施和软件技术落后,在水井距离用水点较远的场合,或者用水高峰期时，通常需要水塔水箱来供应生产、生活用水,然而,人工启动水泵的上水效率低,而且难以把握水位,而国内一般的解决方案是用浮动开关来用控制水箱的抽水和停止抽水，这样倒是解决了其中难以把握水位的问题，但在这个物联网的世界里，解决这个问题是远远不够的，怎样建立一个好的用户管理水箱交互界面是必须要加于考虑的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;关键词&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;智能；水箱；无线；安全；控制&lt;/p&gt;
&lt;h2&gt; 概述&lt;/h2&gt;
&lt;h3&gt;1.1  课题描述&lt;/h3&gt;
&lt;p&gt;楼顶水箱是家庭及工业用水必不可少的利器，传统的水箱管理系统较为单一，其控制管理平台是固定的不可移动的，交互界面较差。&lt;/p&gt;
&lt;p&gt;拥有一个稳定可靠的水位检测，多控制台监测管理，手机随时开即可监测和控制水箱的系统是技术发展的必须。&lt;/p&gt;
&lt;h3&gt;1.2  系统目标&lt;/h3&gt;
&lt;p align=&quot;left&quot;&gt;优水•智能水箱系统定位于楼顶水箱的管理。系统使用有WiFi组网技术、水位检测技术、霍尔接近开关技术、安卓编程技术等技术相互结合，实现多级控制台管理和控制水箱功能，使家庭水箱的管理更加便捷及人性化。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;系统实时监测水箱水位，在水位较低时可开启继电器进而启动水泵抽水，当水箱水位达到一定水位高度是会停止水泵抽水。另外还建立有良好的人机交互界面，多个控制台可实时显示水箱的水位，多个控制台都带有一个抽水按键，当水位较低时也可手动按下按键控制水箱进行抽水，安全方面是考虑到水箱盖子在恶劣天气时会脱离水箱，其可能会造成其它问题，系统可检测检测水箱盖是否有脱离水箱，当水箱盖脱离水箱多个控制台会启动蜂鸣器报警，以达到用户警告。&lt;/p&gt;
&lt;h3&gt;1.3  环境&lt;/h3&gt;
&lt;p&gt;      a)  操作系统：&lt;/p&gt;
&lt;p&gt;             Windows10家庭版 64位&lt;/p&gt;
&lt;p&gt;      b) 使用软件：&lt;/p&gt;
&lt;p&gt;             安卓开发：Android Studio2.0&lt;/p&gt;
&lt;p&gt;            WiFi开发：ESP8266IDE&lt;/p&gt;
&lt;p&gt;            STM32开发：Keil uVision4&lt;/p&gt;
&lt;p&gt;            文档编写：Microsoft Word 2016&lt;/p&gt;
&lt;p&gt;      c)  开发语言：&lt;/p&gt;
&lt;p&gt;             Java 语言&lt;/p&gt;
&lt;p&gt;             C 语言&lt;/p&gt;
&lt;h2&gt; 系统需求分析&lt;/h2&gt;
&lt;p&gt;在信息化迅速发展的今天,我国许多地区水塔水箱供水系统的硬件设施和软件技术落后,在水井距离用水点较远的场合,或者用水高峰期时，&lt;/p&gt;
&lt;p&gt;通常需要水塔水箱来供应生产、生活用水,然而,人工启动水泵的上水效率低,而且难以把握水位,而国内一般的解决方案是用浮动开关来用控制水箱的抽水和停止抽水，&lt;/p&gt;
&lt;p&gt;这样倒是解决了其中难以把握水位的问题，但在这个物联网的世界里，解决这个问题是远远不够的，怎样建立一个好的用户管理水箱交互界面是必须要加于考虑的。&lt;/p&gt;

&lt;h2&gt;系统总体设计&lt;/h2&gt;
&lt;h3&gt;3.1系统总设计框图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190719205822750-874687076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3.1 系统总设计框图&lt;/p&gt;
&lt;h3&gt;3.2系统功能&lt;/h3&gt;
&lt;p&gt;1)   实时水位监测：系统水位传感器模块拥有4个水位触点，可达到5级水位监测，且实时可靠；&lt;/p&gt;
&lt;p&gt;2)   水箱盖实时监控：通过制作的霍尔传感器和磁钢的作用，可实时监测到水箱盖是否有脱离水箱；&lt;/p&gt;
&lt;p&gt;3)   水泵自动供水：水泵开关是继电器，当水位较低时继电器会吸合，水泵开始抽水，当水位达到高度时，继电器停止吸合，水泵停止抽水；&lt;/p&gt;
&lt;p&gt;4)   无线多控制台管理：用户可以自定义无线控制台的数量及位置，系统可扩展多个控制台，多控制带有蜂鸣器模块、显示模块和按键模块，其中蜂鸣器是用于报警提示，显示模块为显示水位及警报信息，按键模块可在水箱水位较低时手动按下抽水 ；&lt;/p&gt;
&lt;p&gt;5)   安卓客户端：用户可以使用系统安卓客户端连接到系统局域网内监测水箱的水位及水箱盖子的情况，也可以通过安卓端控制水泵的工作。&lt;/p&gt;
&lt;h3&gt;3.3系统特点&lt;/h3&gt;
&lt;p&gt;1)   无线技术：通过WiFi组网，进行数据的无线传输；&lt;/p&gt;
&lt;p&gt;2)   实时性：所有的数据都是实时传输和显示的，尽可能的去减少时间延时，使系统所得的数据更加准确；&lt;/p&gt;
&lt;p&gt;3)   系统安全：在恶劣的天气里，水箱盖可能会脱离水箱，进而可能会造成水箱无盖保护或者飞物砸人的危险情况，及时发现可减少危险的发生，系统可在水箱盖脱离水箱时进行多级报警，其无线控制台和一级控制台蜂鸣器模块会鸣响，安卓客户端也会有相应警告提示；&lt;/p&gt;
&lt;p&gt;4)   方便性：用户可通过无线多级控制台和安卓客户端实时监测水箱水位及水箱盖子的情况，和控制水箱水泵的抽水等。&lt;/p&gt;
&lt;h2&gt; 详细设计&lt;/h2&gt;
&lt;h3&gt;4.1水位检测及自动供水实现&lt;/h3&gt;
&lt;p&gt;如图4.1为系统水位监测及自动供水部分原理图，水位传感器为自己设计和焊接，水位传感器模块拥有4个水位触点（可扩展），可达到5级水位监测， 其4个水位触点通过放大电路连接到STM32单片机模块IO口，STM32单片机模块IO设置为输入检测模式，即可检测到对应IO口的电平变化，从而判断出水箱水位，再通过输出模式IO口控制继电器的吸合与断开，进而控制水泵的工作状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190719210218936-169019993.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4.1水位检测及自动供水实现原理图 &lt;/p&gt;
&lt;h3&gt;4.2水箱盖监控实现&lt;/h3&gt;
&lt;p&gt;如图4.2为系统水箱盖监控实现原理图，其使用的传霍尔传感器为自己设计和焊接，霍尔传感器可用作接近开关，其中使用霍尔片A3144通过或者不通过放大电路将霍尔片输出引脚接到STM32单片机模块输入IO口，在磁钢S极接近时可输出低电平，STM32检测相应电平判断水箱盖是否有脱离水箱，若判断到水箱盖脱离水箱即会立即让蜂鸣器鸣响，并会将预警信息通过串口发送到WiFi AP网关，进而让WiFi AP 网关将预警信息传递到相应接收模块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190719210327246-1299600319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4.2水箱盖监控实现原理图&lt;/p&gt;
&lt;h3&gt;4.3信息实时传输实现&lt;/h3&gt;
&lt;p&gt; 如图4.3为系统信息实时传输实现原理图，系统的无线传输实现时通过局域网。其中STM32单片机模块和WiFi AP网关组成了系统的一级控制台，其主要为系统数据信息的来源，连接有多传感器和多人机交互模块。水位传感器和霍尔传感器数据通过串口传递给WiFi AP网关，AP网关再将数据转发给同一局域网内的控制台和安卓客户端，无线控制台和安卓端的控制指令（如控制水泵的开启指令）也是通过WiFi AP网关将数据发至STM32进行数据处理的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190719210520603-1397133870.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4.3 信息实时传输实现原理图&lt;/p&gt;
&lt;h3&gt;4.4安卓客户端实现&lt;/h3&gt;
&lt;p&gt;如图4.4为系统安卓客户端实现原理图，安卓客户端的信息接收是在局域网中的，所有先要连接到局域网，然后接入到局域网中的socket服务器，接着将等待服务器的实时消息，当接收到消息后将其判断后进行图形化显示，安卓客户端还可在水箱水位较低时一键开启水箱抽水。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190719210631344-299046134.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4.4安卓客户端实现原理图&lt;/p&gt;
&lt;h2&gt; 测试&lt;/h2&gt;
&lt;h3&gt;5.1系统硬件&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190719210915910-1435236993.jpg&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.1系统硬件整体图&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190719211215269-553762584.jpg&quot; alt=&quot;&quot; width=&quot;508&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.2 系统硬件水箱部分&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190719211401033-1986915357.jpg&quot; alt=&quot;&quot; width=&quot;508&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.3 系统一级控制台部分&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190719211515604-871702561.jpg&quot; alt=&quot;&quot; width=&quot;508&quot; height=&quot;381&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5.4 系统可扩展的无线二级控制台部分&lt;/p&gt;
&lt;h3&gt;6.2系统软件&lt;/h3&gt;
&lt;p&gt;                                                                                                                                                     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190719211731407-616809263.png&quot; alt=&quot;&quot; width=&quot;266&quot; height=&quot;472&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        图5.5 显示水满且水箱盖脱离图     &lt;/p&gt;
&lt;p&gt;       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1485202/201907/1485202-20190719211650646-1973830755.png&quot; alt=&quot;&quot; width=&quot;265&quot; height=&quot;473&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     图5.6 显示水位为1且水箱盖正常图 &lt;/p&gt;
&lt;h2&gt;课程设计总结或结论&lt;/h2&gt;
&lt;p&gt;      系统有经过长时间运行，其稳定性和实时性较高。水位传感器模块是自制的，其简单的只需要三极管、LED灯和电阻，霍尔传感器电路也是自制的，其只需要一个霍尔元件和三极管、  电阻，另外供电电源、蜂鸣器和继电器模块电路也是自己焊接的，自制电路可以大幅度减少成本，也可通过修改电路元件以达到系统最优。&lt;/p&gt;
&lt;p&gt;      水位监测是系统的核心功能，但水位传感器其原理是利用了水的导电性，如果将水箱的容量或者水箱的整体高度变化必然会影响传感器的检测，所以打算将系统定位为定制型楼顶水箱的管理系统，系统可与制作水箱公司合作，制作对应容量和高度的水箱水位传感器模块，匹配使用，效果更佳。&lt;/p&gt;
&lt;p&gt;      水位传感器的4个水位探头，可以通过重物将其拉直，以减少因水箱水波动引起的水位探头的位置偏移而造成的测量错误，水箱部分的水位传感器及霍尔传感器是要与水箱接近的，搭建好的电路保护箱是防止传感器及电路故障发生的必须，今后将会进一步研究。&lt;/p&gt;
</description>
<pubDate>Fri, 19 Jul 2019 13:32:00 +0000</pubDate>
<dc:creator>东小东</dc:creator>
<og:description>时间：2018年6月 阶段：大二下学期 背景：自动化检测系统设计课设 名称：优水•智能水箱系统 摘要： 优水•智能水箱系统定位于定制型楼顶水箱的管理。系统使用有WiFi组网技术、水位检测技术、霍尔接近</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dongxiaodong/p/11214461.html</dc:identifier>
</item>
<item>
<title>python 之 并发编程（守护进程、互斥锁、IPC通信机制） - small_white-</title>
<link>http://www.cnblogs.com/mylu/p/11215797.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mylu/p/11215797.html</guid>
<description>&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;9.5 守护进程&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;主进程创建守护进程&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　其一：守护进程会在主进程代码执行结束后就立即终止&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;　　其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic processes are not allowed to have children&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process
​
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; task(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s is running&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt; name)
    time.sleep(&lt;/span&gt;3&lt;span&gt;)
​
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    obj &lt;/span&gt;= Process(target=task, args=(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,))
    obj.daemon&lt;/span&gt;=True         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;设置obj为守护进程,并且父进程代码执行结束,obj即终止运行&lt;/span&gt;
    obj.start()             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发送信号给操作系统&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;主&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;9.6 互斥锁&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;互斥锁用来将并发编程串行，牺牲了效率而保证了数据安全&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;强调：必须是lock.acquire()一次，然后 lock.release()释放一次，才能继续lock.acquire()，不能连续的lock.acquire()&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;互斥锁和 join的区别：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;二者的原理都是一样，都是将并发变成串行，从而保证有序&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;区别一：join是按照人为指定的顺序执行，而互斥锁是进程平等地竞争，谁先抢到谁执行，一个人拿到锁，其余人都等待&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process,Lock
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
​
mutex&lt;/span&gt;=&lt;span&gt;Lock()
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; task1(lock):
    lock.acquire() 
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task1:名字是egon&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task1:性别是male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    lock.release()
    
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; task2(lock):
    lock.acquire()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task2:名字是alex&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task2:性别是male&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    lock.release()
    
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; task3(lock):
    lock.acquire()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task3:名字是lxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;task3:性别是female&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    lock.release()
    
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    p1&lt;/span&gt;=Process(target=task1,args=&lt;span&gt;(mutex,))
    p2&lt;/span&gt;=Process(target=task2,args=&lt;span&gt;(mutex,))
    p3&lt;/span&gt;=Process(target=task3,args=&lt;span&gt;(mutex,))
    p1.start()&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; p1.start()&lt;/span&gt;
    p2.start()&lt;span&gt;#&lt;/span&gt;&lt;span&gt; p1.join()&lt;/span&gt;
    p3.start()&lt;span&gt;#&lt;/span&gt;&lt;span&gt; p2.start()&lt;/span&gt;
             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; p2.join()&lt;/span&gt;
             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; p3.start()&lt;/span&gt;
             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; p3.join()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;9.61 模拟抢票&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;互斥锁和 join的区别二：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;互斥锁可以让一部分代码（修改共享数据的代码）串行，而join只能将代码整体串行&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; json
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process,Lock
​
mutex&lt;/span&gt;=&lt;span&gt;Lock()
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; search():
    time.sleep(random.randint(&lt;/span&gt;1,3&lt;span&gt;))
    with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
        dic&lt;/span&gt;=&lt;span&gt;json.load(f)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s 剩余票数:%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %(os.getpid(),dic[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]))
​
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get():
    with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
        dic&lt;/span&gt;=&lt;span&gt;json.load(f)
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; dic[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] &amp;gt;&lt;span&gt; 0:
        dic[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]-=1&lt;span&gt;
        with open(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;db.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f:
            json.dump(dic,f)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%s 购票成功&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; %&lt;span&gt;os.getpid())
​
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; task(lock):
    search()
    lock.acquire()
    get()
    lock.release()
​
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        p&lt;/span&gt;=Process(target=task,args=&lt;span&gt;(mutex,))
        p.start()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; p.join()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;9.7 IPC通信机制&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;进程彼此之间互相隔离，要实现进程间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;进程之间通信必须找到一种介质，该介质必须满足: &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1、是所有进程共享的 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2、必须是内存空间 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;附加：帮我们自动处理好锁的问题&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Process,Manager,Lock
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
​
mutex&lt;/span&gt;=&lt;span&gt;Lock()
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; task(dic,lock):
    lock.acquire()
    temp&lt;/span&gt;=dic[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    time.sleep(&lt;/span&gt;0.1&lt;span&gt;)
    dic[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=temp-1&lt;span&gt;
    lock.release()
​
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    m&lt;/span&gt;=&lt;span&gt;Manager()
    dic&lt;/span&gt;=m.dict({&lt;span&gt;'&lt;/span&gt;&lt;span&gt;num&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:10&lt;span&gt;})
    l&lt;/span&gt;=&lt;span&gt;[]
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        p&lt;/span&gt;=Process(target=task,args=&lt;span&gt;(dic,mutex))
        l.append(p)
        p.start()
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; l:
        p.join()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(dic)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;{'num': 0}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;9.71创建队列的类Queue&lt;/span&gt;&lt;/h4&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;底层就是以管道和锁定的方式实现：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;队列 (管道+锁) ：1、共享的空间 2、是内存空间 3、自动帮我们处理好锁定问题&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;-0.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;Queue([maxsize]):创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;maxsize是队列中允许最大项数，省略则无大小限制。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; multiprocessing &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Queue
q&lt;/span&gt;=Queue(3)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;maxsize=3&lt;/span&gt;
q.put(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
q.put({&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;second&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:None})
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
​
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; q.put(4) #阻塞&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(q.get())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(q.get())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;{'second': None}&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(q.get())  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;三&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;强调：&lt;/strong&gt; &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1、队列用来存成进程之间沟通的消息，数据量不应该过大 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2、maxsize的值超过的内存限制就变得毫无意义&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;了解：block=True(默认值)、timeout&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
q=Queue(1&lt;span&gt;)
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,block=False)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;q.put方法用以插入数据到队列中&lt;/span&gt;
q.put(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fourth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,block=False/True)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;queue.Full/一直等&lt;/span&gt;
&lt;span&gt;​
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;first&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,block=&lt;span&gt;True)
q.put(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;fourth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,block=True,timeout=3)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;等3秒后报错queue.Full&lt;/span&gt;
&lt;span&gt;​
q.get(block&lt;/span&gt;=False)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;q.get方法可以从队列读取并且删除一个元素&lt;/span&gt;
q.get(block=False)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;queue.Empty&lt;/span&gt;
&lt;span&gt;​
q.get(block&lt;/span&gt;=&lt;span&gt;True)
q.get(block&lt;/span&gt;=True,timeout=2)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;等2秒后报错queue.Empty&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Fri, 19 Jul 2019 13:22:00 +0000</pubDate>
<dc:creator>small_white-</dc:creator>
<og:description>9.5 守护进程 主进程创建守护进程 其一：守护进程会在主进程代码执行结束后就立即终止 其二：守护进程内无法再开启子进程,否则抛出异常：AssertionError: daemonic process</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mylu/p/11215797.html</dc:identifier>
</item>
<item>
<title>spring mvc 拦截器的使用 - 周二</title>
<link>http://www.cnblogs.com/jojop/p/11215766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jojop/p/11215766.html</guid>
<description>&lt;h2 id=&quot;拦截器简介&quot;&gt;拦截器简介&lt;/h2&gt;
&lt;p&gt;Spring MVC 中的拦截器(Interceptor)类似于 Servler 中的过滤器(Filter)。用于对处理器进行预处理和后处理。常用于日志记录、权限管理、性能监控、通用行为等。&lt;/p&gt;
&lt;h2 id=&quot;拦截器的实现&quot;&gt;拦截器的实现&lt;/h2&gt;
&lt;p&gt;Spring MVC 中的拦截器需要我们手动实现和配置。拦截器可以通过以下两种方式定义&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实现 &lt;code&gt;HandleInterceptor&lt;/code&gt; 接口，或者继承该接口的实现类如 &lt;code&gt;HandleInterceptorAdapter&lt;/code&gt; 来定义一个拦截器；&lt;/li&gt;
&lt;li&gt;实现 &lt;code&gt;WebRequestInterceptor&lt;/code&gt; 接口来定义一个拦截器;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;handleinterceptor-接口&quot;&gt;HandleInterceptor 接口&lt;/h2&gt;
&lt;p&gt;我们主要讲解下实现 &lt;code&gt;HandleInterceptor&lt;/code&gt; 接口来创建拦截器。&lt;code&gt;HandleInterceptor&lt;/code&gt; 接口定义了三个方法，分别为 &lt;code&gt;preHandle()&lt;/code&gt; , &lt;code&gt;postHandle()&lt;/code&gt; , &lt;code&gt;afterCompletion()&lt;/code&gt;，我们需要重写这三个方法，从而来实现我们定义拦截器的目的。&lt;/p&gt;
&lt;ul readability=&quot;8&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;preHandle(HttpServletRequest request, HttpServletResponse response, Object handle)&lt;/code&gt;：该方法在请求处理前调用。Spring MVC 中的拦截器是链式调用的，一个请求可以被多个拦截器拦截，但是 Interceptor 会根据被声明的次序依次被调用执行，而不会同时去拦截。而且所有 Interceptor 中的 &lt;code&gt;preHandle&lt;/code&gt; 函数都会最先被调用，所以这个方法中可以进行一些前置初始化操作或者是对当前请求的预处理，或者设置一些判断来决定该请求是否执行下去。该方法的返回值是布尔值，当它返回 &lt;code&gt;true&lt;/code&gt; 时，之后的 Interceptor 和 controller 都不会执行下去了；当它返回 &lt;code&gt;false&lt;/code&gt; 时，就会继续调用下一个 Interceptor 的 &lt;code&gt;preHandle&lt;/code&gt; 方法或者处理当前请求的 &lt;code&gt;Controller&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;postHandle(HttpServletRequest request, HttpServletResponse response, Object handle, ModelAndView modelAndView)&lt;/code&gt;：该方法只有在 &lt;code&gt;perHandle&lt;/code&gt; 方法返回值为 &lt;code&gt;true&lt;/code&gt; 时，在 Controller 执行完当前请求后才会执行。咋一看好像和之后要介绍的 afterCompletion 方法没有不同，但是这个方法会在 &lt;code&gt;DispatcherServlet&lt;/code&gt; 进行视图渲染之前被调用，所以咱们可以在这个方法中对 Controller 处理之后的 &lt;code&gt;ModelAndView&lt;/code&gt; 对象进行操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;code&gt;afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handle, Exception ex)&lt;/code&gt;：该方法在整个请求结束后，也就是 &lt;code&gt;DispatcherServlet&lt;/code&gt; 渲染了对应视图之后执行，这个方法的主要作用是用于进行资源清理的工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假设我们现在定义了两个拦截器，xml 配置文件中配置顺序如下内容如下：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;!-- 拦截器1 --&amp;gt;
&amp;lt;mvc:interceptor&amp;gt;
    &amp;lt;!--配置拦截器的作用路径--&amp;gt;
    &amp;lt;mvc:mapping path=&quot;/**&quot;/&amp;gt;
    &amp;lt;bean class=&quot;com.jojo.test.interceptor.Intercptor1&quot;/&amp;gt;
&amp;lt;/mvc:interceptor&amp;gt;
&amp;lt;!--拦截器2--&amp;gt;
&amp;lt;mvc:interceptor&amp;gt;
    &amp;lt;mvc:mapping path=&quot;/hello&quot;/&amp;gt;
    &amp;lt;bean class=&quot;com.jojo.test.interceptor.Interceptor2&quot;/&amp;gt;
&amp;lt;/mvc:interceptor&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这两个拦截器中的处理方法和请求的处理方法的顺序如下图：&lt;br/&gt;&lt;img src=&quot;http://puroyj7ls.bkt.clouddn.com/image/blog/spring-mvc/img1.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实际应用举例&quot;&gt;实际应用举例&lt;/h2&gt;
&lt;p&gt;实现开发中，我们会要求一些页面需要登录后才能访问。未登录状态是无法得到访问权限的。这一小功能我们可以直接通过安全框架，类似 Spring Security 或者 shiro 来实现，不过我们现在利用 Spring MVC 这一功能来实现一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LoginInterceptor implements HandlerInterceptor {
    
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
        
        User user = (User) httpServletRequest.getSession().getAttribute(&quot;user&quot;);

        if (user == null) {
            // 用户未登录，重定向到登录页
            httpServletResponse.sendRedirect(&quot;/login&quot;);
            return false;
        }

        return true;
    }

    public void postHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, ModelAndView modelAndView) throws Exception {
        
        }
    }

    public void afterCompletion(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e) throws Exception {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们还需要在 &lt;code&gt;spring-mvc&lt;/code&gt; 中配置拦截器&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;mvc:interceptors&amp;gt;
    &amp;lt;mvc:interceptor&amp;gt;
        &amp;lt;mvc:mapping path=&quot;/**&quot;/&amp;gt;
        &amp;lt;mvc:exclude-mapping path=&quot;/static/**&quot;/&amp;gt;
        &amp;lt;mvc:exclude-mapping path=&quot;/login&quot;/&amp;gt;
        &amp;lt;bean class=&quot;com.jojo.test.interceptor.LoginInterceptor&quot;/&amp;gt;
    &amp;lt;/mvc:interceptor&amp;gt;
&amp;lt;/mvc:interceptors&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;相关配置说明：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;mvc:interceptor&lt;/code&gt;：定义一个拦截器
&lt;ul&gt;&lt;li&gt;&lt;code&gt;mvc:mapping&lt;/code&gt;：定义需要被拦截的路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mvc:exclude-mapping&lt;/code&gt;：定义需要排除拦截的请求路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bean class&lt;/code&gt;：指定拦截器对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 19 Jul 2019 13:14:00 +0000</pubDate>
<dc:creator>周二</dc:creator>
<og:description>Spring MVC 拦截器的使用 拦截器简介 Spring MVC 中的拦截器(Interceptor)类似于 Servler 中的过滤器(Filter)。用于对处理器进行预处理和后处理。常用于日志</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jojop/p/11215766.html</dc:identifier>
</item>
</channel>
</rss>