<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>.NET 开源项目 StreamJsonRpc 介绍 - 精致码农</title>
<link>http://www.cnblogs.com/willick/p/13233704.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13233704.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/191097/202007/191097-20200704084537965-1435244998.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;StreamJsonRpc 是一个实现了 JSON-RPC 通信协议的开源 .NET 库，在介绍 StreamJsonRpc 之前，我们先来了解一下 JSON-RPC。&lt;/p&gt;
&lt;h2 id=&quot;json-rpc-介绍&quot;&gt;JSON-RPC 介绍&lt;/h2&gt;
&lt;p&gt;JSON-RPC 是一个无状态且轻量级的远程过程调用（RPC）协议，其使用 JSON（RFC 4627）作为数据格式。&lt;/p&gt;
&lt;p&gt;目前 JSON-RPC 的版本已发展到 2.0，JSON-RPC 2.0 与 1.0 的约定规范是不一样的。2.0 包含一个名为 &lt;code&gt;jsonrpc&lt;/code&gt; 且值为 &lt;code&gt;2.0&lt;/code&gt; 的成员，而 1.0 版本是不包含的。所以我们可以很容易在两个版本间区分出 2.0。&lt;/p&gt;
&lt;p&gt;JSON-RPC 在客户端与服务端之间交换的所有成员名应是区分大小写的，函数、方法、过程都认为是可互换的。客户端被定义为请求对象的来源及响应对象的处理程序；服务端被定义为响应对象的起源和请求对象的处理程序。&lt;/p&gt;
&lt;h3 id=&quot;请求对象&quot;&gt;请求对象&lt;/h3&gt;
&lt;p&gt;发送一个请求对象至服务端代表一个 RPC 调用，JSON-RPC 2.0 规定一个请求对象包含下列成员：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;jsonrpc：指定 JSON-RPC 协议版本的字符串，必须准确写为“2.0”。&lt;/li&gt;
&lt;li&gt;method：包含所要调用方法名称的字符串，以 rpc 开头的方法名，用英文句号连接的为预留给 rpc 内部的方法名及扩展名，且不能在其他地方使用。&lt;/li&gt;
&lt;li&gt;params：调用方法所需要的结构化参数值，该成员参数可以被省略。&lt;/li&gt;
&lt;li&gt;id：已建立客户端的唯一标识，值必须包含一个字符串、数值或 NULL 空值。如果不包含该成员则被认定为是一个通知。该值一般不为 NULL，若为数值则不应该包含小数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;没有包含 &lt;code&gt;id&lt;/code&gt; 成员的请求对象为通知，作为通知的请求对象表明客户端对服务端响应不感兴趣，服务端可以不响应请求对象给客户端。&lt;/p&gt;
&lt;p&gt;下面是几个请求对象的 JSON 结构示例（“--&amp;gt;”表示发送，“&amp;lt;--”表示响应，下同）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;--&amp;gt; { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;subtract&quot;, &quot;params&quot;: [42, 23], &quot;id&quot;: 1 }
--&amp;gt; { &quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;subtract&quot;, &quot;params&quot;: {&quot;minuend&quot;: 42, &quot;subtrahend&quot;: 23}, &quot;id&quot;: 4}
--&amp;gt; {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;update&quot;, &quot;params&quot;: [1,2,3,4,5]} // 通知
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;响应对象&quot;&gt;响应对象&lt;/h3&gt;
&lt;p&gt;当客户端发起一个 RPC 调用时，除通知之外，服务端都必须回复响应。响应也表示为一个 JSON 对象，使用以下成员：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;jsonrpc：指定 JSON-RPC 协议版本的字符串，必须准确写为“2.0”。&lt;/li&gt;
&lt;li&gt;result：调用成功时响应给客户端的结果，当调用发生错误时可以不包含该成员。&lt;/li&gt;
&lt;li&gt;error：调用发生错误时返回给客户端的错误信息，在调用失败时必须包含该成员。&lt;/li&gt;
&lt;li&gt;id：对应请求对象的“id”，其值必须与请求对象中的“id”值一致。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;响应对象必须包含 result 或 error 成员之一。&lt;/p&gt;
&lt;p&gt;响应对象的 error 成员的结构包含下列成员：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;code：使用数值表示该异常的错误类型，必须为整数。、&lt;/li&gt;
&lt;li&gt;message：对该错误的简单描述字符串，该描述应尽量限定在简短的一句话。&lt;/li&gt;
&lt;li&gt;data：包含关于错误的附加信息，可忽略。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中 -32768 至 -32000 为保留的预定义错误代码，各保留错误代码的含义请查看文末参考链接[1]。&lt;/p&gt;
&lt;p&gt;下面是几个响应对象的 JSON 结构示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;&amp;lt;-- {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 19, &quot;id&quot;: 1}
&amp;lt;-- {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;error&quot;: {&quot;code&quot;: -32601, &quot;message&quot;: &quot;Method not found&quot;}, &quot;id&quot;: &quot;1&quot;}
&amp;lt;-- {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;error&quot;: {&quot;code&quot;: -32700, &quot;message&quot;: &quot;Parse error&quot;}, &quot;id&quot;: null} // 无效调用
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;批量调用&quot;&gt;批量调用&lt;/h3&gt;
&lt;p&gt;当需要同时发送多个请求对象时，客户端可以发送一个包含所有请求对象的数组。&lt;/p&gt;
&lt;p&gt;当批量调用的所有请求对象处理完成时，服务端则需要返回一个包含相对应的响应对象数组。每个响应对象都应对应每个请求对象，除非是通知的请求对象。服务端可以并发的，可以以任意顺序和任意宽度并行处理这些批量调用。而客户端应该是基于各个响应对象中的 id 成员来匹配对应的请求对象。&lt;/p&gt;
&lt;p&gt;若批量调用没有需要返回的响应对象，则服务端不需要返回任何结果。&lt;/p&gt;
&lt;p&gt;下面是一个批量请求及响应的 JSON 结构示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;--&amp;gt; [
      {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;sum&quot;, &quot;params&quot;: [1,2,4], &quot;id&quot;: &quot;1&quot;},
      {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;notify_hello&quot;, &quot;params&quot;: [7]},
      {&quot;foo&quot;: &quot;boo&quot;},
      {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;foo.get&quot;, &quot;params&quot;: {&quot;name&quot;: &quot;myself&quot;}, &quot;id&quot;: &quot;5&quot;},
      {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;method&quot;: &quot;get_data&quot;, &quot;id&quot;: &quot;9&quot;}
    ]
&amp;lt;-- [
      {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: 7, &quot;id&quot;: &quot;1&quot;},
      {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;error&quot;: {&quot;code&quot;: -32600, &quot;message&quot;: &quot;Invalid Request&quot;}, &quot;id&quot;: null},
      {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;error&quot;: {&quot;code&quot;: -32601, &quot;message&quot;: &quot;Method not found&quot;}, &quot;id&quot;: &quot;5&quot;},
      {&quot;jsonrpc&quot;: &quot;2.0&quot;, &quot;result&quot;: [&quot;hello&quot;, 5], &quot;id&quot;: &quot;9&quot;}
    ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当批量请求对象都是通知时，服务端不需要返回结果。&lt;/p&gt;
&lt;h2 id=&quot;streamjsonrpc-库介绍&quot;&gt;StreamJsonRpc 库介绍&lt;/h2&gt;
&lt;p&gt;StreamJsonRpc 是一个实现了 JSON-RPC 通信协议的 .NET 库，支持 .NET Core。它把 RPC 的调用封装为公开的 .NET API，可以很方便的进行 RPC 请求的发送和接收操作。StreamJsonRpc 是微软官方的一个开源库，目前 Star 数接近 300，貌似知道的人不多或者用的人不多。GitHub 地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/microsoft/vs-streamjsonrpc&quot;&gt;github.com/microsoft/vs-streamjsonrpc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;StreamJsonRpc 可以在 Stream、WebSocket 或 System.IO.Pipelines 管道上工作，独立于底层传输。除了包含 JSON-RPC 规范所需的特性外，它额外还有如下优点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请求取消&lt;/li&gt;
&lt;li&gt;.NET 事件作为通知&lt;/li&gt;
&lt;li&gt;动态客户端代理生成&lt;/li&gt;
&lt;li&gt;支持紧凑的 MessagePack 二进制序列化&lt;/li&gt;
&lt;li&gt;易于实现插件式架构的消息处理和格式化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用 StreamJsonRpc 主要有四个基本步骤：建立 JSON-RPC 连接、发送 RPC 请求、接收 RPC 请求、断开连接。&lt;/p&gt;
&lt;p&gt;这一篇主要介绍一些预备知识，下一篇将通过示例演示并详细介绍 StreamJsonRpc 的使用，敬请期待！&lt;/p&gt;
&lt;p&gt;参考：&lt;br/&gt;[1].&lt;a href=&quot;https://www.jsonrpc.org/specification&quot;&gt;jsonrpc.org/specification&lt;/a&gt;&lt;br/&gt;[2].&lt;a href=&quot;https://github.com/microsoft/vs-streamjsonrpc&quot;&gt;github.com/microsoft/vs-streamjsonrpc&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Jul 2020 00:47:00 +0000</pubDate>
<dc:creator>精致码农</dc:creator>
<og:description>StreamJsonRpc 是一个实现了 JSON-RPC 通信协议的开源 .NET 库，在介绍 StreamJsonRpc 之前，我们先来了解一下 JSON-RPC。 JSON-RPC 介绍 JSO</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13233704.html</dc:identifier>
</item>
<item>
<title>composer更新命令及常用命令 - 神兵小将2016</title>
<link>http://www.cnblogs.com/wjcms/p/13233676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wjcms/p/13233676.html</guid>
<description>&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;p&gt;composer作为php的包依赖管理工具，开发者将开发的工具包上传，然后使用者能很方便的使用,今天就总结一下。&lt;/p&gt;
&lt;h2 id=&quot;composer安装&quot;&gt;composer安装&lt;/h2&gt;
&lt;p&gt;官方地址：&lt;a href=&quot;https://getcomposer.org/download/&quot;&gt;https://getcomposer.org/download/&lt;/a&gt;&lt;br/&gt;下载地址：&lt;a href=&quot;https://getcomposer.org/Composer-Setup.exe&quot;&gt;https://getcomposer.org/Composer-Setup.exe&lt;/a&gt;&lt;br/&gt;下载后直接安装即可。&lt;/p&gt;
&lt;h3 id=&quot;检查是否安装完成&quot;&gt;检查是否安装完成&lt;/h3&gt;
&lt;p&gt;使用命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer --version
#注意这里要大写
composer -V
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1918908/202007/1918908-20200704082008690-12802414.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;如果如上图一样显示版本号，则说明已经安装成功。&lt;br/&gt;同时，还可以使用新增的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer -vvv
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;命令查看更详细的信息，及帮助。&lt;/p&gt;
&lt;h2 id=&quot;composer升级&quot;&gt;composer升级&lt;/h2&gt;
&lt;p&gt;如果composer版本升级了该怎么办呢？不要慌，安排。&lt;br/&gt;使用命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer self-update
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1918908/202007/1918908-20200704082009585-1844642653.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;composer配置镜像&quot;&gt;composer配置镜像&lt;/h2&gt;
&lt;p&gt;因为composer是国外地址，访问起来特别慢，所以使用的时候很容易出现安装失败的情况，这里的解决办法就是使用镜像，使用composer config命令配置镜像地址即可。这里推荐使用阿里云composer镜像源，优点是快速稳定更新快&lt;/p&gt;
&lt;h3 id=&quot;全局配置（推荐）&quot;&gt;全局配置（推荐）&lt;/h3&gt;
&lt;p&gt;所有项目都会使用该镜像地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer config -g repo.packagist composer https://mirrors.aliyun.com/composer/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;取消配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer config -g --unset repos.packagist
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;当前项目配置&quot;&gt;当前项目配置&lt;/h3&gt;
&lt;p&gt;仅修改当前工程配置，仅当前工程可使用该镜像地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer config repo.packagist composer https://mirrors.aliyun.com/composer/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;取消配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer config --unset repos.packagist
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;composer使用&quot;&gt;composer使用&lt;/h2&gt;
&lt;h3 id=&quot;install命令&quot;&gt;install命令&lt;/h3&gt;
&lt;p&gt;install 命令可以用于项目初始化后，初次安装依赖，且会优先读取composer.lock中的版本号，以尽可能的保证协作开发中包版本的一致性。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer install
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;require命令&quot;&gt;require命令&lt;/h3&gt;
&lt;p&gt;require 命令,添加新的依赖包到composer.json文件中并执行更新；&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer require laravel/ui x.0.0 #下载指定版本,可指定 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;update命令&quot;&gt;update命令&lt;/h3&gt;
&lt;p&gt;update命令无法在命令行中指定包版本号，需要手动修改composer.json文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer update
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;其他常用命令&quot;&gt;其他常用命令&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;composer list：获取帮助信息；
composer init：以交互方式填写composer.json文件信息；
composer search：在当前项目中搜索依赖包；
composer show：列举所有可用的资源包；
composer validate：检测composer.json文件是否有效；
composer create-project：基于composer创建一个新的项目；
composer dump-autoload：在添加新的类和目录映射是更新autoloader
composer remove laravel/ui ：删除依赖后还需要去vender文件夹里，手动删除
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1918908/202007/1918908-20200704082054101-759965846.png&quot; alt=&quot;关注我更多精彩&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 04 Jul 2020 00:21:00 +0000</pubDate>
<dc:creator>神兵小将2016</dc:creator>
<og:description>原文地址：https://www.wjcms.net/archives/composer%E6%9B%B4%E6%96%B0%E5%91%BD%E4%BB%A4%E5%8F%8A%E5%B8%B8%E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wjcms/p/13233676.html</dc:identifier>
</item>
<item>
<title>并查集 - Eleven谦</title>
<link>http://www.cnblogs.com/Eleven-Qian-Shan/p/13233659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Eleven-Qian-Shan/p/13233659.html</guid>
<description>&lt;h4 id=&quot;前言：&quot;&gt;前言：&lt;/h4&gt;
&lt;p&gt;因为是学习记录，所以知识讲解+例题推荐+练习题解都是放在一起的qvq&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;目录&quot;&gt;目录&lt;/h4&gt;
&lt;hr/&gt;&lt;h4 id=&quot;并查集基础：&quot;&gt;并查集基础：&lt;/h4&gt;
&lt;p&gt;普通的并查集+路径压缩相信大家还是会的，就主要是两个操作：&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查询某个元素属于哪个集合&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;合并两个集合成为一个大集合&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;提出一点，就是&lt;strong&gt;求最小生成树的Kruskal&lt;/strong&gt;算法也是在使用并查集后才是完整的Kruskal&lt;/p&gt;
&lt;h4 id=&quot;并查集基础题目：&quot;&gt;并查集基础题目：&lt;/h4&gt;
&lt;p&gt;通过“程序自动分析”这道题，我们能够看到，并查集能在&lt;strong&gt;一张无向图中维护节点之间的连通性&lt;/strong&gt;，这是它的基本用途之一&lt;/p&gt;
&lt;p&gt;实际上，&lt;strong&gt;并查集擅长动态维护许多具有传递性的关系&lt;/strong&gt;，如这道题中：“等于”就是一种传递关系，但是“不等于”显然不具有传递性&lt;/p&gt;
&lt;p&gt;但在某些问题中，“传递关系”不止一种，并且这些“传递关系”能够互相导出，此时可以使用以下的&lt;strong&gt;扩展域或者边带权的并查集&lt;/strong&gt;来解决&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;种类并查集：&quot;&gt;种类并查集：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;写在前面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你在洛谷或其他OJ上独立做过了几道并查集的题，那么可以接触升级版的并查集了：&lt;strong&gt;带权并查集、种类并查集&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;知识搬运&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;种类并查集：即在普通并查集“&lt;strong&gt;亲戚的亲戚也是亲戚&lt;/strong&gt;”的基础上再进行一些“&lt;strong&gt;分类&lt;/strong&gt;”，但是这个分类呢并不是根据物品的种类来进行分类，而是类似“&lt;strong&gt;敌人的敌人是朋友&lt;/strong&gt;”的分类（&lt;strong&gt;并没有说明“朋友的敌人是我的敌人”！要根据具体题目分析&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;种类并查集常规套路：不是开多个或多维并查集数组，而是&lt;strong&gt;扩大并查集规模&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个栗子：我们要维护朋友和敌人这两个关系，则将普通并查集的规模扩大两倍，&lt;strong&gt;原来的1~n还是存放朋友关系，但是n+1~2n则是存放敌人关系&lt;/strong&gt;，然后每次操作都&lt;strong&gt;分别维护&lt;/strong&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;种类并查集加强版：上面举的例子是针对&lt;strong&gt;两种对立关系&lt;/strong&gt;，但是有些题目会涉及&lt;strong&gt;三种循环关系&lt;/strong&gt;，怎么做呢？其实就是将扩大两倍规模变为&lt;strong&gt;扩大三倍规模&lt;/strong&gt;（下面有例题会讲到）&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;h4 id=&quot;种类并查集题目：&quot;&gt;种类并查集题目：&lt;/h4&gt;
&lt;hr/&gt;&lt;h4 id=&quot;并查集种类并查集题解：&quot;&gt;并查集&amp;amp;种类并查集题解：&lt;/h4&gt;
&lt;p&gt;题目请大家直接点开看，因为描述很清晰就不再赘述了，直接来讲思路（这题就是思维难度大，容易绕晕QAQ）&lt;/p&gt;
&lt;ol readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;判断是否是假话，其实就是判断当前给出的条件是否与之前构建的并查集关系树冲突，冲突则是假话（于是转换了题目后，就变成&lt;strong&gt;维护种类并查集&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们需要维护三种关系：“同类”、“猎物”、“天敌”，所以&lt;strong&gt;扩大三倍规模，第一倍维护同类、第二倍维护猎物、第三倍维护天敌&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;搞清楚三种关系的传递：&lt;strong&gt;猎物的猎物是天敌&lt;/strong&gt;、天敌的猎物是同类、同类的猎物是猎物、同类的天敌是天敌（反正就是&lt;strong&gt;A吃B，B吃C，C吃B&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;判断是假话的三条规则：①当前给出x、y是同类，但前面已经构建x、y是天敌关系，是假话；②当前给出x是y的天敌，但前面已经构建x、y是同类或y是x的天敌，是假话；③x、y的编号超出了食物链的最大编号（简单明了）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好了，思路如上，我们可以开始敲代码了quq：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,k,u,v,op,ans,fa[150010];

inline int find(int x) {
        if(fa[x]==x) return x;
        return fa[x]=find(fa[x]);
}

int main() {
        scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;k);
        for(register int i=1;i&amp;lt;=3*n;i++) fa[i]=i; //扩大三倍规模 
        for(register int i=1;i&amp;lt;=k;i++) {
                scanf(&quot;%d%d%d&quot;,&amp;amp;op,&amp;amp;u,&amp;amp;v);
                if(u&amp;gt;n||v&amp;gt;n) { //不存在于食物链中，假话 
                        ans++;
                        continue;
                }
                if(op==1) { //如果两者是同类 
                        if(find(u)==find(v+n)||find(u+n)==find(v)) { //如果两者已经是天敌关系，假话 
                                ans++;
                                continue;
                        }
                        fa[find(u)]=find(v); //合并 
                        fa[find(u+n)]=find(v+n);
                        fa[find(u+n+n)]=find(v+n+n);
                }
                else { //如果x是y天敌 
                        if(find(u)==find(v)||find(u)==find(v+n)) { //如果两者已经是同类或y是x天敌，假话 
                                ans++;
                                continue;
                        }
                        fa[find(u)]=find(v+n+n); //注意一下对应关系！
                        fa[find(u+n)]=find(v);
                        fa[find(u+n+n)]=find(v+n);
                }
        }
        printf(&quot;%d&quot;,ans);
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;题目简述一下：给定n个罪犯，m个关系；对于每个关系给出两个罪犯在同一所监狱中的怨气值；要求将所有罪犯分到两所监狱，要让这两所监狱中所有怨气值的&lt;strong&gt;最大值最小&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在来讲思路：&lt;/p&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;首先我们可以想到&lt;strong&gt;贪心&lt;/strong&gt;，怎么贪？即将所有怨气值&lt;strong&gt;从大到小&lt;/strong&gt;排序，然后首先将怨气值大的分开，直到不能这么干&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;但我们始终需要维护两所监狱中的怨气值，所以我们不妨&lt;strong&gt;将种类并查集作为解题主体再加上排序作为辅助&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;怎么种类并查集？首先还是先排序，&lt;strong&gt;如果当前罪犯x的敌人为空，则将当前关系对应的罪犯y设为x的敌人；之后再遇到罪犯x与其他罪犯z有怨气关系时，就将罪犯z与罪犯y建立朋友关系（“敌人的敌人是朋友”的思想）&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;你可能会疑惑，&lt;strong&gt;罪犯y和罪犯z也有可能是互相的敌人啊，怎么就构建朋友关系了呢&lt;/strong&gt;？可如果全部处理成敌人关系我们将无法解决这道题，但是转换一下思路，我们已经将怨气值从大到小排序，所以怨气值大的看做敌人，之后再遇到敌人就&lt;strong&gt;将两个敌人合并为朋友&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这并不与在m个关系的描述中罪犯y与罪犯z是敌人相冲突，因为y与z的怨气值小于x与y的怨气值，&lt;strong&gt;不会妨碍&lt;/strong&gt;我们最终求得怨气值的最大值最小&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果在处理过程中&lt;strong&gt;找到了一组罪犯u和罪犯v，满足两人在同一集合中，就直接输出u和v的怨气值&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果处理完所有关系都没有输出，则&lt;strong&gt;输出0&lt;/strong&gt;（题目要求的，因为忘了写，白白WA了一个点）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;感觉讲得有点绕QAQ，大家在草稿本上手模一下样例应该就懂了，下面给出代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,m,fa[400010];

struct node {
        int u,v,w;
} a[400010];

inline bool cmp(node x,node y) {
        return x.w&amp;gt;y.w;
}

inline int find(int x) {
        if(fa[x]==x) return x;
        return fa[x]=find(fa[x]);
}

int main() {
        scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
        for(register int i=1;i&amp;lt;=2*n;i++) fa[i]=i; //扩大两倍规模：一倍存朋友，二倍存敌人 
        for(register int i=1;i&amp;lt;=m;i++) {
                scanf(&quot;%d%d%d&quot;,&amp;amp;a[i].u,&amp;amp;a[i].v,&amp;amp;a[i].w);
        }
        sort(a+1,a+1+m,cmp); //怨气值从大到小排序 
        for(register int i=1;i&amp;lt;=m;i++) {
                if(find(a[i].u)==find(a[i].v)) { //找到了最大值最小的怨气值 
                        printf(&quot;%d&quot;,a[i].w);
                        return 0;
                }
                if(find(a[i].u+n)==a[i].u) { //如果还没有敌人，将当前关系对应的罪犯标记为敌人 
                        fa[a[i].u+n]=a[i].v;
                }
                else if(find(a[i].u+n)!=a[i].u) { //如果有敌人了，则将之前的敌人与现在的敌人合并为朋友 
                        fa[find(a[i].u+n)]=find(a[i].v);
                }
                if(find(a[i].v+n)==a[i].v) { //双向的 
                        fa[a[i].v+n]=a[i].u;
                }
                else if(find(a[i].v+n)!=a[i].v) {
                        fa[find(a[i].v+n)]=find(a[i].u);
                }
        }
        puts(&quot;0&quot;);  //没有找到，输出0 
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说在前面：&lt;/p&gt;
&lt;p&gt;&lt;s&gt;这道题因为蒟蒻只会map实现离散化，但是这道题第二个点还是会T，只有90pts（吸氧倒是能A掉）所以各位dalao可以跳过这道题的题解，以下讲的是90pts 的做法，抱歉啊！（咕咕咕）&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;更新于2020.6.18 蒟蒻下午去学习了一下离散化及其实现，写了&lt;a href=&quot;https://www.cnblogs.com/Eleven-Qian-Shan/p/13157949.html&quot;&gt;学习记录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;题目请大家直接点击题目链接查看，不多赘述，直接讲思路&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;这题就是普通的并查集，但是&lt;strong&gt;数据太大&lt;/strong&gt;了，直接存放肯定炸得体无完肤，所以我们需要引入“&lt;strong&gt;离散化&lt;/strong&gt;”来存放数据&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;离散化大致有两种：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;（1）去重（可以用到unique去重函数）+ 排序 +二分索引（可以用到lower_bound函数）&lt;/p&gt;
&lt;p&gt;（2）Hash表（散列表）：如果维护的好，可以实现O(1)的查询&lt;/p&gt;
&lt;p&gt;下面给出&lt;s&gt;蒟蒻的90pts代码&lt;/s&gt;满分代码（更新啦~使用STL实现离散化，具体可见上面的“学习记录”）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
bool flag;
int t,n,tot,res,fa[2000010],b[6000010];

struct node {
        int u,v,e;
} a[2000010];

inline bool cmp(node x,node y) {
        return x.e&amp;gt;y.e;
}

inline int find(int x) {
        if(fa[x]==x) return x;
        return fa[x]=find(fa[x]);
}

int main() {
        scanf(&quot;%d&quot;,&amp;amp;t);
        while(t--) {
                scanf(&quot;%d&quot;,&amp;amp;n);
                tot=0;
                memset(a,0,sizeof(a));  //记得清空啊
                memset(b,0,sizeof(b));
                memset(fa,0,sizeof(fa));
                for(register int i=1;i&amp;lt;=n;i++) {
                        scanf(&quot;%d%d%d&quot;,&amp;amp;a[i].u,&amp;amp;a[i].v,&amp;amp;a[i].e);
                        b[++tot]=a[i].u;
                        b[++tot]=a[i].v;
                }
                sort(b+1,b+1+tot);  //第一步，排序
                res=unique(b+1,b+1+tot)-(b+1);   //第二步，去重
                for(register int i=1;i&amp;lt;=n;i++) {   //第三步，二分索引
                        a[i].u=lower_bound(b+1,b+res+1,a[i].u)-b;
                        a[i].v=lower_bound(b+1,b+res+1,a[i].v)-b;
                }
                for(register int i=1;i&amp;lt;=res;i++) fa[i]=i;
                sort(a+1,a+1+n,cmp);  //先处理所有合并的情况
                flag=true;
                for(register int i=1;i&amp;lt;=n;i++) {
                        if(a[i].e==1) {
                                fa[find(a[i].u)]=find(a[i].v);
                        }
                        else {
                                if(find(a[i].u)==find(a[i].v)) {
                                        puts(&quot;NO&quot;);
                                        flag=false;   //打上标记
                                        break;
                                }
                        }
                }
                if(flag==true) puts(&quot;YES&quot;);
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P6121&quot;&gt;洛谷P6121 [USACO16OPEN]Closing the Farm G&lt;/a&gt; （此为加强版）&lt;/p&gt;
&lt;p&gt;直接讲加强版的思路（其实都差不多啦）：&lt;/p&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;题目要求按顺序关闭谷仓，每次关闭都要判断&lt;strong&gt;当前剩余所有谷仓&lt;/strong&gt;是否联通&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我们转换一下，&lt;strong&gt;将顺序关闭改为倒序开启！&lt;/strong&gt;，每一次开启就相当于插入一个点，然后&lt;strong&gt;用并查集维护联通块&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;但是跟其他并查集不一样，我们的fa数组不能直接初始化，而是应该开u号仓就将fa[u]赋成u，联通块++&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对于现在开的u号仓，我们遍历与u号仓有路径相连的其他仓库，进行判断&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;判断：如果遍历到的v号仓库还没有开仓（即fa[v]=0）则跳过不管&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果已经开过仓了，再判断i和v是否在一个集合，如果不在就将u、v合并再将联通块--&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;处理完所有与u相连的仓库后，将当前的联通块个数保存在ans[u]中，最后循环判断如果ans[i]==1就输出YES，反之输出NO&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面给出加强版代码（终于没有咕咕咕了，更新于2020.6.18）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int n,m,u,v,tot,sum,fa[2000010],ans[2000010],head[2000010],order[2000010]; //开大一点

struct node {
        int to,net;
} a[2000010];

inline void add(int x,int y) { //链式前向星存边
        a[++tot].to=y;
        a[tot].net=head[x];
        head[x]=tot;
}

inline int find(int x) {
        if(fa[x]==x) return x;
        return fa[x]=find(fa[x]);
} 

int main() {
        scanf(&quot;%d%d&quot;,&amp;amp;n,&amp;amp;m);
        for(register int i=1;i&amp;lt;=m;i++) {
                scanf(&quot;%d%d&quot;,&amp;amp;u,&amp;amp;v);
                add(u,v); //双向边
                add(v,u);
        }
        for(register int i=1;i&amp;lt;=n;i++) {
                scanf(&quot;%d&quot;,&amp;amp;order[i]);
        }
        for(register int i=n;i&amp;gt;=1;i--) { //倒叙开仓
                sum++;  //联通块个数
                fa[order[i]]=order[i];
                for(register int j=head[order[i]];j;j=a[j].net) { //遍历与order[i]相连的v仓库
                        int v=a[j].to;
                        if(fa[find(v)]!=0) { //v号仓库已经开过
                                if(find(v)!=find(order[i])) { //不在一个集合就合并，联通块--
                                        sum--;
                                        fa[find(v)]=find(order[i]);
                                }
                        }
                }
                ans[i]=sum;
        }
        for(register int i=1;i&amp;lt;=n;i++) { //判断输出
                if(ans[i]==1) puts(&quot;YES&quot;);
                else puts(&quot;NO&quot;);
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;带权并查集：&quot;&gt;带权并查集：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;写在前面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于这个带权并查集，蒟蒻做了两道题，但貌似树的形态都是链，所以和同学还在讨论其他情况需不需要维护size数组（size数组在下面会讲）和一些其他问题&lt;/p&gt;
&lt;p&gt;所以现在&lt;strong&gt;只讲解链的情况&lt;/strong&gt;，请见谅（有dalao给讲讲嘛？）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;知识搬运&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;并查集实际上是由若干棵树构成的森林，我们可以在树中的每条边上记录一个权值，即维护一个数组d，&lt;strong&gt;用d[i]保存节点i到父节点fa[i]之间的边权&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在每次&lt;strong&gt;路径压缩&lt;/strong&gt;后，每个访问过的节点都会直接指向树根，如果我们&lt;strong&gt;同时更新这些节点的d值&lt;/strong&gt;，就可以利用路径压缩过程来统计每个节点到树根之间的路径信息&lt;/p&gt;
&lt;p&gt;题型一般就是给出点之间的合并，然后询问两个点之间的距离&lt;/p&gt;
&lt;p&gt;下面给出在路径压缩时维护d值的代码（注意一下写法哦！建议照下面这样规范敲代码quq）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;inline int find(int x) {
        if(fa[x]==x) return x;
        int root=find(fa[x]); //注意一下写法，先将find(fa[x])存放在root中，否则会出错 
        d[x]+=d[fa[x]];
        return fa[x]=root;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;带权并查集题目：&quot;&gt;带权并查集题目：&lt;/h4&gt;
&lt;p&gt;再次&lt;s&gt;温馨&lt;/s&gt;提示：以下例题都是链的情况（应该是维护点权）&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;带权并查集题解：&quot;&gt;带权并查集题解：&lt;/h4&gt;
&lt;p&gt;题目转换思路：&lt;/p&gt;
&lt;p&gt;一共有30000列，每列一艘战舰（摆明了是链的形态）&lt;/p&gt;
&lt;p&gt;给定T组对于u、v进行合并或查询，合并时将u这一列移动到v这一列后面；查询时输出u和v之间的战舰数（所以战舰数就是权值）&lt;/p&gt;
&lt;p&gt;所以我们开三个数组，一个fa[i]表示i的父亲节点，一个d[i]表示i到其父节点的边权，一个size[i]表示i所在子树的大小&lt;/p&gt;
&lt;p&gt;下面给出代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include  &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
char op;
int T,u,v,d[30010],fa[30010],size[30010];

inline int find(int x) {
        if(fa[x]==x) return x;
        int root=find(fa[x]); //注意一下写法，先将find(fa[x])存放在root中，否则会出错 
        d[x]+=d[fa[x]];
        return fa[x]=root;
}

int main () {
        scanf(&quot;%d&quot;,&amp;amp;T);
        for(register int i=1;i&amp;lt;=30001;i++) {
                fa[i]=i;
                size[i]=1; //每棵子树的大小初始都为1 
        }
        for(register int i=1;i&amp;lt;=T;i++) {
                cin&amp;gt;&amp;gt;op;
                scanf(&quot;%d%d&quot;,&amp;amp;u,&amp;amp;v);
                if(op=='M') {
                        int uu=find(u);
                        int vv=find(v);
                        fa[uu]=vv; //把u这棵树全部搬到v这棵树下面，成为v这棵树的子树 
                        d[uu]+=size[vv]; //更新u这棵子树的祖先到v这棵树的距离 
                        size[vv]+=size[uu]; //更新v这棵树的大小 
                }
                else {
                        if(find(u)!=find(v)) puts(&quot;-1&quot;);
                        else printf(&quot;%d\n&quot;,abs(d[u]-d[v])-1);
                }
                
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这道题跟“银河英雄传说”几乎一模一样，就是合并和查询的方式有点差别，现在来讲思路转换：&lt;/p&gt;
&lt;p&gt;合并时给出u、v，要将u移到v上面（转换一下，就是将v移到u下面！这就跟“银河英雄传说”一样了啊）&lt;/p&gt;
&lt;p&gt;查询时只给出z，要求输出z之下的积木数（积木数=战舰数=权值）&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include  &amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
char op;
int T,u,v,d[30010],fa[30010],size[30010];

inline int find(int x) {
        if(fa[x]==x) return x;
        int root=find(fa[x]);
        d[x]+=d[fa[x]];
        return fa[x]=root;
}

int main () {
        scanf(&quot;%d&quot;,&amp;amp;T);
        for(register int i=1;i&amp;lt;=30000;i++) {
                fa[i]=i;
                size[i]=1;
        }
        for(register int i=1;i&amp;lt;=T;i++) {
                cin&amp;gt;&amp;gt;op;
                if(op=='M') {
                        scanf(&quot;%d%d&quot;,&amp;amp;u,&amp;amp;v); 
                        int uu=find(u);
                        int vv=find(v);
                        fa[vv]=uu; //注意一下这里与“银河英雄传说”合并的区别 
                        d[vv]+=size[uu];
                        size[uu]+=size[vv];
                }
                else {
                        scanf(&quot;%d&quot;,&amp;amp;u);
                        printf(&quot;%d\n&quot;,size[find(u)]-d[u]-1); //注意是u的根节点的size-d[u]，不能直接写成u的size-d[u] 
                }
                
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;带权并查集的一点讨论：&quot;&gt;带权并查集的一点讨论：&lt;/h4&gt;
&lt;p&gt;讨论：什么时候需要维护size数组和dis数组&lt;/p&gt;
&lt;p&gt;现在给出一个不维护size数组的小程序，处理的是边权（就直接维护dis），上面的例题是点权（都要维护）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using namespace std;
int fa[30010],dis[30010];
inline int find(int x) {
        if(x==a[x]) return x;
        int root=find(fa[x]);
        dis[x]+=dis[fa[x]];
        return fa[x]=root;
}

inline void un(int x,int y) {
        int xx=find(x),yy=find(y);
        if(xx==yy) return;
        dis[xx]+=dis[y]+1; //这里的1指的是xx到y的边权值 
        fa[xx]=yy;
}

int x,y;

int main() {
        for(register int i=1;i&amp;lt;=100;i++) fa[i]=i;
        while(cin&amp;gt;&amp;gt;x&amp;gt;&amp;gt;y) {
                un(x,y);
                for(register int i=1;i&amp;lt;=5;i++) find(i); //每合并一次就要全部更新i到根节点的距离 
                for(register int i=1;i&amp;lt;=5;i++) cout&amp;lt;&amp;lt;dis[i]&amp;lt;&amp;lt;&quot; &quot;; //输出i到根节点的距离 
                cout&amp;lt;&amp;lt;endl;
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h4 id=&quot;后序：&quot;&gt;后序：&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;如果大家的理解和以上我的理解有任何出入，欢迎大家留言，我们一起讨论啊！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;to-be-continue&quot;&gt;To be continue....&lt;/h2&gt;
</description>
<pubDate>Sat, 04 Jul 2020 00:09:00 +0000</pubDate>
<dc:creator>Eleven谦</dc:creator>
<og:description>并查集&amp;amp;amp;种类并查集&amp;amp;amp;带权并查集 前言： 因为是学习记录，所以知识讲解+例题推荐+练习题解都是放在一起的qvq 目录 并查集基础知识 并查集基础题目 种类并查集知识 种类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Eleven-Qian-Shan/p/13233659.html</dc:identifier>
</item>
<item>
<title>[Python] list vs tupple - leetao94</title>
<link>http://www.cnblogs.com/leetao94/p/13233657.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leetao94/p/13233657.html</guid>
<description>&lt;p&gt;列表（list）和　元组（tupple） 是 Python 中常见的两种数据结构．这两者使用方法有一定的相似，俩者都是 Python 内置类型，都可以保存数据集合，都可以保存复合数据，我们同样可以通过索引去访问它们．&lt;/p&gt;
&lt;p&gt;那么问题来了，俩者究竟有区别吗？？？&lt;/p&gt;

&lt;p&gt;首先回答问题.list 和 tupple 有区别吗?答案是肯定的,两者有区别. list 和 tupple 的本质区别在于，前者是一个可变对象而后者是一个不可变对象。&lt;/p&gt;
&lt;p&gt;什么是可变对象和不可变对象呢？&lt;strong&gt;简单地来说，可变对象就是创建之后可以修改，而不可变对象则是创建之后不允许在修改。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/627405/202007/627405-20200704080357206-1128037820.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没关系，让我们看一下例子&lt;/p&gt;
&lt;p&gt;首先创建一个 &lt;code&gt;list&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着我们试着修改一下上面的 &lt;code&gt;list&lt;/code&gt; , 将 &lt;code&gt;b&lt;/code&gt; 改成 &lt;code&gt;e&lt;/code&gt;，看看会发生什么&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a[1] = &quot;e&quot;
&amp;gt;&amp;gt;&amp;gt; a
['a', 'e', 'c', 'd']
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好像什么都没有发生~~&lt;/p&gt;
&lt;p&gt;没关系，我们再来创建一个 &lt;code&gt;tupple&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; b=(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样地，让我们将 &lt;code&gt;tupple&lt;/code&gt; 中的 &lt;code&gt;b&lt;/code&gt; 改成 &lt;code&gt;e&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; b[1]=&quot;2&quot;
Traceback (most recent call last):
  File &quot;&amp;lt;stdin&amp;gt;&quot;, line 1, in &amp;lt;module&amp;gt;
TypeError: 'tuple' object does not support item assignment
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么同样的赋值操作，在 &lt;code&gt;tupple&lt;/code&gt; 中会出现错误呢？原因就是我们上面说到的 &lt;strong&gt;&lt;code&gt;tupple&lt;/code&gt; 是不可变对象，创建之后不能修改&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;有个小伙伴看见了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/627405/202007/627405-20200704080423251-768050157.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后给我写了一段下面的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; b=(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)
&amp;gt;&amp;gt;&amp;gt; b=(&quot;a&quot;,&quot;e&quot;,&quot;c&quot;,&quot;d&quot;)
&amp;gt;&amp;gt;&amp;gt;b
&amp;gt;&amp;gt;&amp;gt;(&quot;a&quot;,&quot;e&quot;,&quot;c&quot;,&quot;d&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样子是不是做到了修改 &lt;code&gt;tupple&lt;/code&gt; 中的第2个元素呢？答案是否定的，为什么呢？别着急往下看&lt;/p&gt;

&lt;p&gt;在开始下面的内容之前，需要牢记一句话，&lt;strong&gt;Python 中的变量是对在内存中 Python 对象的引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以我们上面的列表 &lt;code&gt;a&lt;/code&gt; 为例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它在内存中实际表现如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/627405/202007/627405-20200704080431674-316985774.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果需要获取列表 &lt;code&gt;list&lt;/code&gt; 在内存的实际位置，我们可以借用内置函数 &lt;code&gt;id()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a=[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]
&amp;gt;&amp;gt;&amp;gt; id(a)
4557552456
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们去修改一下 a[1] 的值，然后再用 &lt;code&gt;id()&lt;/code&gt; 这个函数去获取 a 在内存的地址，你会发现它的值没有改变，仍然指向相同位置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a[1] = &quot;e&quot;
&amp;gt;&amp;gt;&amp;gt; id(a)
4557552456
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个过程如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/627405/202007/627405-20200704080459712-2033887495.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们看一下对 &lt;code&gt;tupple&lt;/code&gt; 进行同样的操作会有什么变化&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a=(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;)
&amp;gt;&amp;gt;&amp;gt; id(a)
4557412296
&amp;gt;&amp;gt;&amp;gt; a=(&quot;a&quot;,&quot;e&quot;,&quot;c&quot;,&quot;d&quot;)
&amp;gt;&amp;gt;&amp;gt; id(a)
4557586504
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不难发现，再修改之后指向内存中的地址发生了改变，这意味着这个时候变量 &lt;code&gt;a&lt;/code&gt; 指向了一个全新的对象。&lt;/p&gt;
&lt;p&gt;如果觉得难以理解，没有关系，看下面的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/627405/202007/627405-20200704080506179-9711428.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候如果没有其它变量指向之前的 &lt;code&gt;tupple&lt;/code&gt;,Python 的 GC 将会把旧的 &lt;code&gt;tupple&lt;/code&gt; 从内存中完全删除.&lt;/p&gt;

&lt;p&gt;其实更贴切的应该问，为什么需要可变对象和不可变对象呢？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;添加元素效率&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从上面的内容，我们知道一旦创建了 tupple，这个时候任何修改操作都会去创建新的对象，然后变量重新指向新的对象，假设添加的元素足够多，其效率可想而知。这里的添加是指如下的操作( tupple 本身没有添加的方法)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;a = ()
for i in range(num):
    a = a + (i,)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;debugger 难度&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在之前的 [直接赋值，深拷贝和浅拷贝] 中提到可变对象,修改赋值后的变量,会对原有的变量造成影响,会导致其 &lt;code&gt;value&lt;/code&gt; 值的改变,在实际开发过程中很容易被忽略&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;gt;&amp;gt;&amp;gt; a = [1, 3, 5, 7]
&amp;gt;&amp;gt;&amp;gt; b = a
&amp;gt;&amp;gt;&amp;gt; b[0] = -10
&amp;gt;&amp;gt;&amp;gt; a
[-10, 3, 5, 7]
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;总结一下，list 和 tupple 的使用场景&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;tupple 不存在添加和删除的操作，更不存在修改的操作，如果有这些需求，不用使用 tupple，去用 list&lt;/li&gt;
&lt;li&gt;如果只是遍历的话， tupple 的速度是比 list 要快的&lt;/li&gt;
&lt;li&gt;如果你有些数据是需要写保护，不希望在运行过程中被修改的话，用 tupple&lt;/li&gt;
&lt;li&gt;tupple 可以用来做 dict 的 key 的，准确的说，所有不可变对象都可以，而 list 不可以&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://learnbatta.com/blog/why-tuple-is-faster-than-list-in-python-22/&quot;&gt;https://learnbatta.com/blog/why-tuple-is-faster-than-list-in-python-22/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.afternerd.com/blog/difference-between-list-tuple/&quot;&gt;https://www.afternerd.com/blog/difference-between-list-tuple/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.programiz.com/python-programming/list-vs-tuples&quot;&gt;https://www.programiz.com/python-programming/list-vs-tuples&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 04 Jul 2020 00:07:00 +0000</pubDate>
<dc:creator>leetao94</dc:creator>
<og:description>前言 列表（list）和　元组（tupple） 是 Python 中常见的两种数据结构．这两者使用方法有一定的相似，俩者都是 Python 内置类型，都可以保存数据集合，都可以保存复合数据，我们同样可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leetao94/p/13233657.html</dc:identifier>
</item>
<item>
<title>JavaScript图形实例：SierPinski三角形 - aTeacher</title>
<link>http://www.cnblogs.com/cs-whut/p/13233655.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cs-whut/p/13233655.html</guid>
<description>&lt;h4&gt;&lt;span&gt;1．SierPinski三角形&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      Sierpinski三角形是一种分形，由波兰数学家谢尔宾斯基在1915年提出，它是一种典型的自相似集。其生成过程为：&lt;/p&gt;
&lt;p&gt;（1）取一个三角形（多数使用等边三角形）；&lt;/p&gt;
&lt;p&gt;（2）沿三边中点连线，将它分成四个小三角形；&lt;/p&gt;
&lt;p&gt;（3）对上、左、右这三个小三角形重复这一过程。&lt;/p&gt;
&lt;p&gt;SierPinski三角形的生成示意如图1所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200704075511683-426066333.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图1  SierPinski三角形的生成&lt;/p&gt;
&lt;p&gt;      SierPinski三角形采用递归过程易于实现，编写如下的HTML代码。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;SierPinski三角形&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;600&quot; height=&quot;600&quot; style=&quot;border:3px double #996633;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/canvas&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;   var canvas = document.getElementById('myCanvas');&lt;/p&gt;
&lt;p&gt;   var ctx = canvas.getContext('2d');&lt;/p&gt;
&lt;p&gt;   var depth =5;&lt;/p&gt;
&lt;p&gt;   ctx.strokeStyle = &quot;red&quot;;&lt;/p&gt;
&lt;p&gt;   ctx.lineWidth = 3;&lt;/p&gt;
&lt;p&gt;   function sierpinski(x1,y1,x2,y2,x3,y3,n)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;        if (n&amp;lt;0)  return;&lt;/p&gt;
&lt;p&gt;        ctx.beginPath();&lt;/p&gt;
&lt;p&gt;        ctx.moveTo(x1,y1);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x2,y2);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x3,y3);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x1,y1);&lt;/p&gt;
&lt;p&gt;        ctx.closePath();&lt;/p&gt;
&lt;p&gt;        ctx.stroke();&lt;/p&gt;
&lt;p&gt;        var x4 = (x1 + x2) / 2;&lt;/p&gt;
&lt;p&gt;        var y4 = (y1 + y2) / 2;&lt;/p&gt;
&lt;p&gt;        var x5 = (x2 + x3) / 2;&lt;/p&gt;
&lt;p&gt;        var y5 = (y2 + y3) / 2;&lt;/p&gt;
&lt;p&gt;        var x6 = (x1 + x3) / 2;&lt;/p&gt;
&lt;p&gt;        var y6 = (y1 + y3) / 2;&lt;/p&gt;
&lt;p&gt;        sierpinski(x1,y1,x4,y4,x6,y6,n-1);&lt;/p&gt;
&lt;p&gt;        sierpinski(x6,y6,x5,y5,x3,y3,n-1);&lt;/p&gt;
&lt;p&gt;        sierpinski(x4,y4,x2,y2,x5,y5,n-1);&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;   sierpinski(300, 500-500*Math.sqrt(3)/2, 50, 500, 550, 500,depth);&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;      在浏览器中打开包含这段HTML代码的html文件，可以看到在浏览器窗口中绘制出的SierPinski三角形，如图2所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200704075542225-2132986145.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图2  递归深度depth =5的SierPinski三角形&lt;/p&gt;
&lt;h4&gt;2．SierPinski垫片&lt;/h4&gt;
&lt;p&gt;SierPinski垫片的生成过程为：&lt;/p&gt;
&lt;p&gt;（1）取一个实心的三角形（多数使用等边三角形）；&lt;/p&gt;
&lt;p&gt;（2）沿三边中点连线，将它分成四个小三角形，&lt;/p&gt;
&lt;p&gt;（3）去掉中间的那一个小三角形；&lt;/p&gt;
&lt;p&gt;（4）对其余三个小三角形重复这一过程。&lt;/p&gt;
&lt;p&gt;SierPinski垫片的生成示意如图3所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200704075604273-2079123870.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图3  SierPinski垫片的生成&lt;/p&gt;
&lt;p&gt;      SierPinski垫片采用递归过程易于实现，编写如下的HTML代码。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;SierPinski垫片&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;600&quot; height=&quot;600&quot; style=&quot;border:3px double #996633;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/canvas&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;   var canvas = document.getElementById('myCanvas');&lt;/p&gt;
&lt;p&gt;   var ctx = canvas.getContext('2d');&lt;/p&gt;
&lt;p&gt;   ctx.beginPath();&lt;/p&gt;
&lt;p&gt;   ctx.moveTo(300, 500-500*Math.sqrt(3)/2);&lt;/p&gt;
&lt;p&gt;   ctx.lineTo(50,500);&lt;/p&gt;
&lt;p&gt;   ctx.lineTo(550,500);&lt;/p&gt;
&lt;p&gt;   ctx.closePath();&lt;/p&gt;
&lt;p&gt;   ctx.fillStyle=&quot;black&quot;;&lt;/p&gt;
&lt;p&gt;   ctx.fill();&lt;/p&gt;
&lt;p&gt;   var depth =5;&lt;/p&gt;
&lt;p&gt;   ctx.fillStyle = &quot;white&quot;;&lt;/p&gt;
&lt;p&gt;   function sierpinski(x1,y1,x2,y2,x3,y3,n)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;        if (n&amp;lt;=0)  return;&lt;/p&gt;
&lt;p&gt;        var x4 = (x1 + x2) / 2;&lt;/p&gt;
&lt;p&gt;        var y4 = (y1 + y2) / 2;&lt;/p&gt;
&lt;p&gt;        var x5 = (x2 + x3) / 2;&lt;/p&gt;
&lt;p&gt;        var y5 = (y2 + y3) / 2;&lt;/p&gt;
&lt;p&gt;        var x6 = (x1 + x3) / 2;&lt;/p&gt;
&lt;p&gt;        var y6 = (y1 + y3) / 2;&lt;/p&gt;
&lt;p&gt;        ctx.beginPath();&lt;/p&gt;
&lt;p&gt;        ctx.moveTo(x4,y4);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x5,y5);&lt;/p&gt;
&lt;p&gt;        ctx.lineTo(x6,y6);&lt;/p&gt;
&lt;p&gt;        ctx.closePath();&lt;/p&gt;
&lt;p&gt;        ctx.fill();&lt;/p&gt;
&lt;p&gt;        sierpinski(x1,y1,x4,y4,x6,y6,n-1);&lt;/p&gt;
&lt;p&gt;        sierpinski(x6,y6,x5,y5,x3,y3,n-1);&lt;/p&gt;
&lt;p&gt;        sierpinski(x4,y4,x2,y2,x5,y5,n-1);&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;   sierpinski(300, 500-500*Math.sqrt(3)/2, 50, 500, 550, 500,depth);&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p&gt;      在浏览器中打开包含这段HTML代码的html文件，可以看到在浏览器窗口中绘制出的SierPinski垫片，如图4所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200704075636008-1365486119.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图4  递归深度depth =5的SierPinski垫片&lt;/p&gt;
&lt;h4&gt;3．SierPinski地毯&lt;/h4&gt;
&lt;p&gt;      SierPinski垫片的初始图形是三角形，如果将初始图形改成正方形，便可以得到称为SierPinski地毯的图形。它的生成过程为：&lt;/p&gt;
&lt;p&gt;     （1）取一个实心的正方形；&lt;/p&gt;
&lt;p&gt;      （2）将正方形的每边三等分，并连接相应的等分点，从而将原正方形等分为面积相等的9个小正方形；&lt;/p&gt;
&lt;p&gt;      （3）去掉中间的那一个小正方形；&lt;/p&gt;
&lt;p&gt;      （4）对其余的8个小正方形重复这一过程。&lt;/p&gt;
&lt;p&gt;       SierPinski垫片的生成示意如图5所示。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200704075732069-1098323137.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图5  SierPinski地毯的生成&lt;/p&gt;
&lt;p&gt;      设正方形的左上角坐标为(x,y)，边长为L，则中间正方形的左上角坐标和边长分别为(x+L/3,y+L/3)和L/3，其余8个小正方形的边长均为L/3，左上角坐标分别为(x,y)、（x+L/3,y）、(x+2*L/3,y)、(x,y+L/3)、(x+2*L/3,y+L/3)、(x,y+2*L/3)、(x+L/3,y+2*L/3)和(x+2*L/3,y+2*L/3)。&lt;/p&gt;
&lt;p&gt;      为了绘制SierPinski地毯，可以编写如下的HTML代码。&lt;/p&gt;
&lt;p&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;title&amp;gt;SierPinski地毯&amp;lt;/title&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/head&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;canvas id=&quot;myCanvas&quot; width=&quot;600&quot; height=&quot;600&quot; style=&quot;border:3px double #996633;&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/canvas&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;   var canvas = document.getElementById('myCanvas');&lt;/p&gt;
&lt;p&gt;   var ctx = canvas.getContext('2d');&lt;/p&gt;
&lt;p&gt;   ctx.fillStyle=&quot;black&quot;;&lt;/p&gt;
&lt;p&gt;   ctx.fillRect(50,50,450,450);&lt;/p&gt;
&lt;p&gt;   var depth =5;&lt;/p&gt;
&lt;p&gt;   ctx.fillStyle = &quot;white&quot;;&lt;/p&gt;
&lt;p&gt;   function sierpinski(x,y,L,n)&lt;/p&gt;
&lt;p&gt;   {&lt;/p&gt;
&lt;p&gt;        if (n&amp;lt;=0)  return;&lt;/p&gt;
&lt;p&gt;        ctx.fillRect(x+L/3,y+L/3,L/3,L/3);&lt;/p&gt;
&lt;p&gt;        sierpinski(x,y,L/3,n-1);&lt;/p&gt;
&lt;p&gt;        sierpinski(x+L/3,y,L/3,n-1);&lt;/p&gt;
&lt;p&gt;        sierpinski(x+2*L/3,y,L/3,n-1);&lt;/p&gt;
&lt;p&gt;        sierpinski(x,y+L/3,L/3,n-1);&lt;/p&gt;
&lt;p&gt;        sierpinski(x+2*L/3,y+L/3,L/3,n-1);&lt;/p&gt;
&lt;p&gt;        sierpinski(x,y+2*L/3,L/3,n-1);&lt;/p&gt;
&lt;p&gt;        sierpinski(x+L/3,y+2*L/3,L/3,n-1);&lt;/p&gt;
&lt;p&gt;        sierpinski(x+2*L/3,y+2*L/3,L/3,n-1);&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;   sierpinski(50,50,450,depth);&lt;/p&gt;
&lt;p&gt;&amp;lt;/script&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/body&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/html&amp;gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       在浏览器中打开包含这段HTML代码的html文件，可以看到在浏览器窗口中绘制出SierPinski垫片，如图6所示。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1485495/202007/1485495-20200704075802159-1775104175.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;图6  递归深度depth =5的SierPinski地毯 &lt;/p&gt;
</description>
<pubDate>Fri, 03 Jul 2020 23:59:00 +0000</pubDate>
<dc:creator>aTeacher</dc:creator>
<og:description>1．SierPinski三角形 Sierpinski三角形是一种分形，由波兰数学家谢尔宾斯基在1915年提出，它是一种典型的自相似集。其生成过程为： （1）取一个三角形（多数使用等边三角形）； （2）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cs-whut/p/13233655.html</dc:identifier>
</item>
<item>
<title>Alink漫谈(九) ：特征工程 之 特征哈希/标准化缩放 - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/13233067.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/13233067.html</guid>
<description>&lt;p&gt;Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文将剖析Alink “特征工程” 部分对应代码实现。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;510.072348334&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文将剖析Alink “特征工程” 部分对应代码实现。&lt;/p&gt;
&lt;h2 id=&quot;0x01-相关概念&quot;&gt;0x01 相关概念&lt;/h2&gt;
&lt;h3 id=&quot;11-特征工程&quot;&gt;1.1 特征工程&lt;/h3&gt;
&lt;p&gt;机器学习的特征工程是将原始的输入数据转换成特征，以便于更好的表示潜在的问题，并有助于提高预测模型准确性的过程。&lt;/p&gt;
&lt;p&gt;找出合适的特征是很困难且耗时的工作，它需要专家知识，而应用机器学习基本也可以理解成特征工程。但是，特征工程对机器学习模型的应用有很大影响，有句俗话叫做“数据和特征决定了机器学习模型的性能上限”。&lt;/p&gt;
&lt;p&gt;机器学习的输入特征包括几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数值特征：包括整形、浮点型等，可以有顺序意义，或者无序数据。&lt;/li&gt;
&lt;li&gt;分类特征：如ID、性别等。&lt;/li&gt;
&lt;li&gt;时间特征：时间序列如月份、年份、季度、日期、小时等。&lt;/li&gt;
&lt;li&gt;空间特征：经纬度等，可以转换成邮编，城市等。&lt;/li&gt;
&lt;li&gt;文本特征：文档，自然语言，语句等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;特征工程处理技巧大概有：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li&gt;
&lt;p&gt;分箱（Binning）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;独热编码（One-Hot Encoding）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;特征哈希（Hashing Trick）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;嵌套法（Embedding）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;取对数（Log Transformation）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;特征缩放（Scaling）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;标准化（Normalization）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;特征交互（Feature Interaction）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文将为大家讲解特征缩放和特征哈希的实现。&lt;/p&gt;
&lt;h3 id=&quot;12-特征缩放（scaling）&quot;&gt;1.2 特征缩放（Scaling）&lt;/h3&gt;
&lt;p&gt;特征缩放是一种用于标准化独立变量或数据特征范围的方法。 在数据处理中，它也称为数据标准化，并且通常在数据预处理步骤期间执行。特征缩放可以将很大范围的数据限定在指定范围内。由于原始数据的值范围变化很大，在一些机器学习算法中，如果没有标准化，目标函数将无法正常工作。 例如，大多数分类器按欧几里德距离计算两点之间的距离。 如果其中一个要素具有宽范围的值，则距离将受此特定要素的控制。 因此，应对所有特征的范围进行归一化，以使每个特征大致与最终距离成比例。&lt;/p&gt;
&lt;p&gt;应用特征缩放的另一个原因是梯度下降与特征缩放比没有它时收敛得快得多。特征缩放主要包括两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最大最小缩放（Min-max Scaling）&lt;/li&gt;
&lt;li&gt;标准化缩放（Standard(Z) Scaling）&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;13-特征哈希（hashing-trick）&quot;&gt;1.3 特征哈希（Hashing Trick）&lt;/h3&gt;
&lt;p&gt;大多数机器学习算法的输入要求都是实数矩阵，将原始数据转换成实数矩阵就是所谓的特征工程，而特征哈希（feature hashing，也称哈希技巧，hashing trick）就是一种特征工程技术。&lt;/p&gt;
&lt;p&gt;特征哈希的目标就是将一个数据点转换成一个向量 或者 把原始的高维特征向量压缩成较低维特征向量，且尽量不损失原始特征的表达能力。&lt;/p&gt;
&lt;p&gt;特征哈希利用的是哈希函数将原始数据转换成指定范围内的散列值，相比较独热模型具有很多优点，如支持在线学习，维度减小很多。&lt;/p&gt;
&lt;p&gt;比如我们将梁山好汉进行特征哈希，以关胜为例:&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;姓 名：关胜&lt;br/&gt;排 名：坐第5把交椅&lt;br/&gt;籍 贯：运城（今山西省-运城市）&lt;br/&gt;绰 号：大刀&lt;br/&gt;武 器：青龙偃月刀&lt;br/&gt;星 号：天勇星&lt;br/&gt;相 貌：堂堂八尺五六身躯，细细三柳髭髯，两眉入鬓，凤眼朝天，面如重枣，唇若涂朱。&lt;br/&gt;原 型：南宋初，刘豫任济南知府，金军攻济南。刘豫受金人利诱，杀守将关胜，降金。这段故事被清陈忱加以演义，写入了《水浒后传》。此关胜可能就是小说中的原型。&lt;br/&gt;出场回合：第063回&lt;br/&gt;后 代：关铃，在《说岳全传》出场，岳云的义弟。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面都是原始的输入数据，包括数值特征，分类特征，文本特征等等，计算机无法识别，必须用特征哈希转换成计算机可以识别的数据。&lt;/p&gt;
&lt;p&gt;转换之后如下（虚构，只是展示使用 ^_^）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 假设结果是一个 30000 大小的稀疏向量，下面格式是：&quot;index&quot;:&quot;value&quot;

&quot;725&quot;:&quot;0.8223484445229384&quot; //姓 名
&quot;1000&quot;:&quot;0.8444219609970856&quot; //排 名
&quot;4995&quot;:&quot;-0.18307661612028242 &quot; //籍 贯
&quot;8049&quot;:&quot;0.060151616110215377&quot; //绰 号
&quot;8517&quot;:&quot;-0.7340742756048447 &quot; //武 器
&quot;26798&quot;:&quot;:-0.734299689415312&quot; //星 号
&quot;24390&quot;:&quot;0.545435&quot; //相 貌
&quot;25083&quot;:&quot;0.4543543&quot; //原 型
&quot;25435&quot;:&quot;-0.243432&quot; //出场回合
&quot;25721&quot;:&quot;-0.7340742756048447&quot; //后 代
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样关胜就变成了一个可以被程序处理的向量。&lt;/p&gt;
&lt;h2 id=&quot;0x02-数据集&quot;&gt;0x02 数据集&lt;/h2&gt;
&lt;p&gt;我们的数据集和示例代码都是从FTRLExample获取到的。&lt;/p&gt;
&lt;p&gt;首先看数据集。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String schemaStr 
                = &quot;id string, click string, dt string, C1 string, banner_pos int, site_id string, site_domain string, &quot;
                + &quot;site_category string, app_id string, app_domain string, app_category string, device_id string, &quot;
                + &quot;device_ip string, device_model string, device_type string, device_conn_type string, C14 int, C15 int, &quot;
                + &quot;C16 int, C17 int, C18 int, C19 int, C20 int, C21 int&quot;;
                
//打印出前面几列看看
trainBatchData.firstN(5).print();

id|click|dt|C1|banner_pos|site_id|site_domain|site_category|app_id|app_domain|app_category|device_id|device_ip|device_model|device_type|device_conn_type|C14|C15|C16|C17|C18|C19|C20|C21
--|-----|--|--|----------|-------|-----------|-------------|------|----------|------------|---------|---------|------------|-----------|----------------|---|---|---|---|---|---|---|---
3199889859719711212|0|14102101|1005|0|1fbe01fe|f3845767|28905ebd|ecad2386|7801e8d9|07d7df22|a99f214a|cfa82746|c6263d8a|1|0|15708|320|50|1722|0|35|-1|79
3200127078337687811|0|14102101|1005|1|e5c60a05|7256c623|f028772b|ecad2386|7801e8d9|07d7df22|a99f214a|ffb0e59a|83ca6fdb|1|0|19771|320|50|2227|0|687|100075|48
3200382705425230287|1|14102101|1005|0|85f751fd|c4e18dd6|50e219e0|98fed791|d9b5648e|0f2161f8|a99f214a|f69683cc|f51246a7|1|0|20984|320|50|2371|0|551|-1|46
320073658191290816|0|14102101|1005|0|1fbe01fe|f3845767|28905ebd|ecad2386|7801e8d9|07d7df22|a99f214a|8e5b1a31|711ee120|1|0|15706|320|50|1722|0|35|100083|79
3200823995473818776|0|14102101|1005|0|f282ab5a|61eb5bc4|f028772b|ecad2386|7801e8d9|07d7df22|a99f214a|9cf693b4|8a4875bd|1|0|18993|320|50|2161|0|35|-1|157
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x03-示例代码&quot;&gt;0x03 示例代码&lt;/h2&gt;
&lt;p&gt;从示例代码可以看到，首先做特征缩放，然后做特征哈希。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String[] selectedColNames = new String[]{
                &quot;C1&quot;, &quot;banner_pos&quot;, &quot;site_category&quot;, &quot;app_domain&quot;,
                &quot;app_category&quot;, &quot;device_type&quot;, &quot;device_conn_type&quot;,
                &quot;C14&quot;, &quot;C15&quot;, &quot;C16&quot;, &quot;C17&quot;, &quot;C18&quot;, &quot;C19&quot;, &quot;C20&quot;, &quot;C21&quot;,
                &quot;site_id&quot;, &quot;site_domain&quot;, &quot;device_id&quot;, &quot;device_model&quot;};
String[] categoryColNames = new String[]{
                &quot;C1&quot;, &quot;banner_pos&quot;, &quot;site_category&quot;, &quot;app_domain&quot;,
                &quot;app_category&quot;, &quot;device_type&quot;, &quot;device_conn_type&quot;,
                &quot;site_id&quot;, &quot;site_domain&quot;, &quot;device_id&quot;, &quot;device_model&quot;};
String[] numericalColNames = new String[]{
                &quot;C14&quot;, &quot;C15&quot;, &quot;C16&quot;, &quot;C17&quot;, &quot;C18&quot;, &quot;C19&quot;, &quot;C20&quot;, &quot;C21&quot;};

// setup feature engineering pipeline
Pipeline featurePipeline = new Pipeline()
        .add(   // 特征缩放  
                new StandardScaler()
                        .setSelectedCols(numericalColNames) // 对Double类型的列做变换
        )
        .add(   // 特征哈希
                new FeatureHasher()
                        .setSelectedCols(selectedColNames)
                        .setCategoricalCols(categoryColNames)
                        .setOutputCol(vecColName)
                        .setNumFeatures(numHashFeatures)
        );
// fit feature pipeline model
PipelineModel featurePipelineModel = featurePipeline.fit(trainBatchData);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x04-标准化缩放-standardscaler&quot;&gt;0x04 标准化缩放 StandardScaler&lt;/h2&gt;
&lt;p&gt;StandardScaler的作用是把数据集的每一个特征进行标准差（standard deviation）转换 和/或 零均值化（zero mean）。transforms a dataset, normalizing each feature to have unit standard deviation and/or zero mean.&lt;/p&gt;
&lt;p&gt;对于做特征缩放的好处，网上文章说的挺好：&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;当x全为正或者全为负时，每次返回的梯度都只会沿着一个方向发生变化，即梯度变化的方向就会向图中红色箭头所示，一会向上太多，一会向下太多。这样就会使得权重收敛效率很低。&lt;/p&gt;
&lt;p&gt;但当x正负数量“差不多”时，就能对梯度变化方向进行“修正”，加速了权重的收敛。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们想想如果做标准化缩放，具体需要怎么做：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要把需要处理的列的means, stdEnv这样的都计算出来，这就需要遍历整个表。所以这个是训练过程。&lt;/li&gt;
&lt;li&gt;需要根据上述训练出来的means, stdEnv等数值，遍历整个表中的每个数据，应用means, stdEnv结果逐一计算。所以这个是mapper过程。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;41-standardscalertrainbatchop&quot;&gt;4.1 StandardScalerTrainBatchOp&lt;/h3&gt;
&lt;p&gt;StandardScalerTrainBatchOp 类做了标准化缩放相关工作。这里只对数字类型的列做转换。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/* StandardScaler transforms a dataset, normalizing each feature to have unit standard deviation and/or zero mean. */
public class StandardScalerTrainBatchOp extends BatchOperator&amp;lt;StandardScalerTrainBatchOp&amp;gt;
    implements StandardTrainParams&amp;lt;StandardScalerTrainBatchOp&amp;gt; {

    @Override
    public StandardScalerTrainBatchOp linkFrom(BatchOperator&amp;lt;?&amp;gt;... inputs) {
        BatchOperator&amp;lt;?&amp;gt; in = checkAndGetFirst(inputs);
        String[] selectedColNames = getSelectedCols();

        StandardScalerModelDataConverter converter = new StandardScalerModelDataConverter();
        converter.selectedColNames = selectedColNames;
        converter.selectedColTypes = new TypeInformation[selectedColNames.length];

        // 获取需要转换的列
        for (int i = 0; i &amp;lt; selectedColNames.length; i++) {
            converter.selectedColTypes[i] = Types.DOUBLE;
        }

//得到变量如下      
converter = {StandardScalerModelDataConverter@9229} 
 selectedColNames = {String[8]@9228} 
  0 = &quot;C14&quot;
  1 = &quot;C15&quot;
  2 = &quot;C16&quot;
  3 = &quot;C17&quot;
  4 = &quot;C18&quot;
  5 = &quot;C19&quot;
  6 = &quot;C20&quot;
  7 = &quot;C21&quot;
 selectedColTypes = {TypeInformation[8]@9231} 
  0 = {FractionalTypeInfo@9269} &quot;Double&quot;
  1 = {FractionalTypeInfo@9269} &quot;Double&quot;
  2 = {FractionalTypeInfo@9269} &quot;Double&quot;
  3 = {FractionalTypeInfo@9269} &quot;Double&quot;
  4 = {FractionalTypeInfo@9269} &quot;Double&quot;
  5 = {FractionalTypeInfo@9269} &quot;Double&quot;
  6 = {FractionalTypeInfo@9269} &quot;Double&quot;
  7 = {FractionalTypeInfo@9269} &quot;Double&quot;      
      
        // 用获取到的列信息通过 StatisticsHelper.summary 做总结，然后通过 BuildStandardScalerModel 进行操作
        DataSet&amp;lt;Row&amp;gt; rows = StatisticsHelper.summary(in, selectedColNames)
            .flatMap(new BuildStandardScalerModel(converter.selectedColNames,
                converter.selectedColTypes,
                getWithMean(),
                getWithStd()));

        this.setOutput(rows, converter.getModelSchema());

        return this;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里调用一环套一环，所以先打印出构建执行计划时候的调用栈给大家看看。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;summarizer:277, StatisticsHelper (com.alibaba.alink.operator.common.statistics)
summarizer:240, StatisticsHelper (com.alibaba.alink.operator.common.statistics)
summary:71, StatisticsHelper (com.alibaba.alink.operator.common.statistics)
linkFrom:49, StandardScalerTrainBatchOp (com.alibaba.alink.operator.batch.dataproc)
train:22, StandardScaler (com.alibaba.alink.pipeline.dataproc)
fit:34, Trainer (com.alibaba.alink.pipeline)
fit:117, Pipeline (com.alibaba.alink.pipeline)
main:59, FTRLExample (com.alibaba.alink)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;u&gt;&lt;strong&gt;StandardScalerTrainBatchOp.linkFrom 构建出来的执行计划从逻辑上讲是&lt;/strong&gt;&lt;/u&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1)获取需要转换的列信息&lt;/li&gt;
&lt;li&gt;2)用获取到的列信息通过 StatisticsHelper.summary (StatisticsHelper类是batch statistical calculation的工具类) 做总结
&lt;ul&gt;&lt;li&gt;2.1)用 summarizer 获取table统计信息
&lt;ul&gt;&lt;li&gt;2.1.1)用in = in.select(selectedColNames);获取输入数据中需要调整的列 所对应的数据&lt;/li&gt;
&lt;li&gt;2.1.2)调用同名 summarizer 函数对in做操作进行统计
&lt;ul&gt;&lt;li&gt;2.1.2.1)调用 TableSummarizerPartition 对每个partition数据进行统计。
&lt;ul&gt;&lt;li&gt;2.1.2.1.1) 调用 TableSummarizer.visit 对本 partition 传入的Row(就是上面in的每个数据)进行计算，得出统计数据比如 squareSum，min, max, normL1。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2.1.2.2)回到 summarizer 函数，调用reduce 对所有partition得的统计数据进行汇总。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;2.2)对 summarizer 的结果调用 summarizer.toSummary() 进行map，得到 TableSummary，其就是一个简单统计。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3)对 StatisticsHelper.summary 的结果 通过flatMap( BuildStandardScalerModel ) 进行生成模型 / 存储操作
&lt;ul&gt;&lt;li&gt;3.1)BuildStandardScalerModel.flatMap调用 StandardScalerModelDataConverter.save
&lt;ul&gt;&lt;li&gt;3.1.1)data.add(JsonConverter.toJson(means)); 存means&lt;/li&gt;
&lt;li&gt;3.1.2)data.add(JsonConverter.toJson(stdDevs)); 存 stdDevs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体结合代码如下&lt;/p&gt;
&lt;h3 id=&quot;42-statisticshelpersummary&quot;&gt;4.2 StatisticsHelper.summary&lt;/h3&gt;
&lt;p&gt;StatisticsHelper.summary 首先调用summarizer对原始输入table做总结，对应代码 2)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/* table summary, selectedColNames must be set. */
public static DataSet&amp;lt;TableSummary&amp;gt; summary(BatchOperator in, String[] selectedColNames) {
    return summarizer(in, selectedColNames, false) // 将会调用代码 2.1)  
        .map(new MapFunction&amp;lt;TableSummarizer, TableSummary&amp;gt;() {
            @Override
            public TableSummary map(TableSummarizer summarizer) throws Exception {
                return summarizer.toSummary(); // 对应代码 2.2)
            }
        }).name(&quot;toSummary&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;summarizer(in, selectedColNames, false)&lt;/code&gt; 从原始输入中获取到那些选中的列，然后继续调用另外同名函数summarizer。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * table stat
 */
private static DataSet&amp;lt;TableSummarizer&amp;gt; summarizer(BatchOperator in, String[]  selectedColNames, boolean calculateOuterProduct) { // 对应代码 2.1)
    in = in.select(selectedColNames); // 对应代码2.1.1)  
    return summarizer(in.getDataSet(), calculateOuterProduct, getNumericalColIndices(in.getColTypes()), selectedColNames); //对应代码2.1.2) 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同名函数summarizer调用 TableSummarizerPartition 对每个partition处理，当然大家知道现在只是把执行计划搭建起来，不是真正的执行。&lt;u&gt;当对每个partition处理完成之后，会回到这里的reduce函数进行merge&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/* given data, return summary. numberIndices is the indices of cols which are number type in selected cols. */
private static DataSet&amp;lt;TableSummarizer&amp;gt; summarizer(DataSet&amp;lt;Row&amp;gt; data, boolean bCov, int[] numberIndices, String[] selectedColNames) {
    return data // mapPartition 对应代码 2.1.2.1)
        .mapPartition(new TableSummarizerPartition(bCov, numberIndices, selectedColNames))
        .reduce(new ReduceFunction&amp;lt;TableSummarizer&amp;gt;() { // reduce对应代码 2.1.2.2)
            @Override
            public TableSummarizer reduce(TableSummarizer left, TableSummarizer right) {
                return TableSummarizer.merge(left, right); //最终会merge所有的partition处理结果
            }
        });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TableSummarizerPartition针对每个partition，让每个worker用来TableSummarizer.visit来做table summary，以后会合并。对应代码 2.1.2.1.1) 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/* It is table summary partition of one worker, will merge result later. */
public static class TableSummarizerPartition implements MapPartitionFunction&amp;lt;Row, TableSummarizer&amp;gt; {
    @Override
    public void mapPartition(Iterable&amp;lt;Row&amp;gt; iterable, Collector&amp;lt;TableSummarizer&amp;gt; collector) {
        TableSummarizer srt = new TableSummarizer(selectedColNames, numericalIndices, outerProduct);
        srt.colNames = selectedColNames;
        for (Row sv : iterable) {
            srt = (TableSummarizer) srt.visit(sv);
        }
        collector.collect(srt);
    }
}

// 变量如下
srt = {TableSummarizer@10742} &quot;count: 0\n&quot;
sv = {Row@10764} &quot;15708,320,50,1722,0,35,-1,79&quot;
srt.colNames = {String[8]@10733} 
 0 = &quot;C14&quot;
 1 = &quot;C15&quot;
 2 = &quot;C16&quot;
 3 = &quot;C17&quot;
 4 = &quot;C18&quot;
 5 = &quot;C19&quot;
 6 = &quot;C20&quot;
 7 = &quot;C21&quot;  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，上面代码中会对 iterable 做循环调用 TableSummarizer.visit函数。即通过&lt;code&gt;visit&lt;/code&gt;来对输入的每个item（这个item就是srt.colNames对应的那些列集合起来做了一个Row）做累积计算，算出比如squareSum，min, max, normL1等等，具体在下面的变量中有体现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;this = {TableSummarizer@10742} &quot;count: 1\nsum: 15708.0 320.0 50.0 1722.0 0.0 35.0 -1.0 79.0\nsquareSum: 2.46741264E8 102400.0 2500.0 2965284.0 0.0 1225.0 1.0 6241.0\nmin: 15708.0 320.0 50.0 1722.0 0.0 35.0 -1.0 79.0\nmax: 15708.0 320.0 50.0 1722.0 0.0 35.0 -1.0 79.0&quot;
 colNames = {String[8]@10733} 
 xSum = null
 xSquareSum = null
 xyCount = null
 numericalColIndices = {int[8]@10734} 
 numMissingValue = {DenseVector@10791} &quot;0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0&quot;
 sum = {DenseVector@10792} &quot;15708.0 320.0 50.0 1722.0 0.0 35.0 -1.0 79.0&quot;
 squareSum = {DenseVector@10793} &quot;2.46741264E8 102400.0 2500.0 2965284.0 0.0 1225.0 1.0 6241.0&quot;
 min = {DenseVector@10794} &quot;15708.0 320.0 50.0 1722.0 0.0 35.0 -1.0 79.0&quot;
 max = {DenseVector@10795} &quot;15708.0 320.0 50.0 1722.0 0.0 35.0 -1.0 79.0&quot;
 normL1 = {DenseVector@10796} &quot;15708.0 320.0 50.0 1722.0 0.0 35.0 1.0 79.0&quot;
 vals = {Double[8]@10797} 
 outerProduct = null
 count = 1
 calculateOuterProduct = false
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;43-buildstandardscalermodel&quot;&gt;4.3 BuildStandardScalerModel&lt;/h3&gt;
&lt;p&gt;这里的功能是生成模型 / 存储。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/* table summary build model. */
public static class BuildStandardScalerModel implements FlatMapFunction&amp;lt;TableSummary, Row&amp;gt; {
    private String[] selectedColNames;
    private TypeInformation[] selectedColTypes;
    private boolean withMean;
    private boolean withStdDevs;

    @Override
    public void flatMap(TableSummary srt, Collector&amp;lt;Row&amp;gt; collector) throws Exception {
        if (null != srt) {
            StandardScalerModelDataConverter converter = new StandardScalerModelDataConverter();
            converter.selectedColNames = selectedColNames;
            converter.selectedColTypes = selectedColTypes;
            // 业务
            converter.save(new Tuple3&amp;lt;&amp;gt;(this.withMean, this.withStdDevs, srt), collector);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;save函数调用的是StandardScalerModelDataConverter.save，逻辑比较清晰：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;存储mean&lt;/li&gt;
&lt;li&gt;存储stdDevs&lt;/li&gt;
&lt;li&gt;构建元数据Params&lt;/li&gt;
&lt;li&gt;序列化&lt;/li&gt;
&lt;li&gt;发送序列化结果&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/*
 * Serialize the model data to &quot;Tuple3&amp;lt;Params, List&amp;lt;String&amp;gt;, List&amp;lt;Row&amp;gt;&amp;gt;&quot;.
 *
 * @param modelData The model data to serialize.
 * @return The serialization result.
 */
@Override
public Tuple3&amp;lt;Params, Iterable&amp;lt;String&amp;gt;, Iterable&amp;lt;Row&amp;gt;&amp;gt; serializeModel(Tuple3&amp;lt;Boolean, Boolean, TableSummary&amp;gt; modelData) {
    Boolean withMean = modelData.f0;
    Boolean withStandarDeviation = modelData.f1;
    TableSummary summary = modelData.f2;

    String[] colNames = summary.getColNames();
    double[] means = new double[colNames.length];
    double[] stdDevs = new double[colNames.length];

    for (int i = 0; i &amp;lt; colNames.length; i++) {
        means[i] = summary.mean(colNames[i]); // 1. 存储mean
        stdDevs[i] = summary.standardDeviation(colNames[i]); // 2. 存储stdDevs
    }

    for (int i = 0; i &amp;lt; colNames.length; i++) {
        if (!withMean) {
            means[i] = 0;
        }
        if (!withStandarDeviation) {
            stdDevs[i] = 1;
        }
    }

    // 3. 构建元数据Params
    Params meta = new Params()
        .set(StandardTrainParams.WITH_MEAN, withMean)
        .set(StandardTrainParams.WITH_STD, withStandarDeviation);

    // 4. 序列化
    List&amp;lt;String&amp;gt; data = new ArrayList&amp;lt;&amp;gt;();
    data.add(JsonConverter.toJson(means));
    data.add(JsonConverter.toJson(stdDevs));

    return new Tuple3&amp;lt;&amp;gt;(meta, data, new ArrayList&amp;lt;&amp;gt;());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用栈和变量如下，我们可以看出来模型是如何构建的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;save:68, RichModelDataConverter (com.alibaba.alink.common.model)
flatMap:84, StandardScalerTrainBatchOp$BuildStandardScalerModel (com.alibaba.alink.operator.batch.dataproc)
flatMap:63, StandardScalerTrainBatchOp$BuildStandardScalerModel (com.alibaba.alink.operator.batch.dataproc)
collect:80, ChainedFlatMapDriver (org.apache.flink.runtime.operators.chaining)
collect:35, CountingCollector (org.apache.flink.runtime.operators.util.metrics)
collect:79, ChainedMapDriver (org.apache.flink.runtime.operators.chaining)
collect:35, CountingCollector (org.apache.flink.runtime.operators.util.metrics)
run:152, AllReduceDriver (org.apache.flink.runtime.operators)
run:504, BatchTask (org.apache.flink.runtime.operators)
invoke:369, BatchTask (org.apache.flink.runtime.operators)
doRun:707, Task (org.apache.flink.runtime.taskmanager)
run:532, Task (org.apache.flink.runtime.taskmanager)
run:748, Thread (java.lang)
  
// 以下是输入  
modelData = {Tuple3@10723} 
 f0 = {Boolean@10726} true
 f1 = {Boolean@10726} true
 f2 = {TableSummary@10707} &quot;colName|count|numMissingValue|numValidValue|sum|mean|variance|standardDeviation|min|max|normL1|normL2\r\n-------|-----|---------------|-------------|---|----|--------|-----------------|---|---|------|------\nC14|399999|0.0000|399999.0000|7257042877.0000|18142.6525|10993280.1107|3315.6116|375.0000|21705.0000|7257042877.0000|11664445.8724\nC15|399999|0.0000|399999.0000|127629988.0000|319.0758|411.3345|20.2814|120.0000|1024.0000|127629988.0000|202208.2328\nC16|399999|0.0000|399999.0000|22663266.0000|56.6583|1322.7015|36.3690|20.0000|768.0000|22663266.0000|42580.9842\nC17|399999|0.0000|399999.0000|809923879.0000|2024.8148|170166.5008|412.5124|112.0000|2497.0000|809923879.0000|1306909.3634\nC18|399999|0.0000|399999.0000|414396.0000|1.0360|1.5871|1.2598|0.0000|3.0000|414396.0000|1031.5736\nC19|399999|0.0000|399999.0000|77641159.0000|194.1034|73786.4929|271.6367|33.0000|1835.0000|77641159.0000|211151.2756\nC20|399999|0.0000|399999.0000|16665597769.0000|41664.0986|2434589745.2799|49341.5620|-1.0000|100&quot;
  colNames = {String[8]@10728} 
  numMissingValue = {DenseVector@10729} &quot;0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0&quot;
  sum = {DenseVector@10730} &quot;7.257042877E9 1.27629988E8 2.2663266E7 8.09923879E8 414396.0 7.7641159E7 1.6665597769E10 3.0589982E7&quot;
  squareSum = {DenseVector@10731} &quot;1.36059297509295E14 4.0888169392E10 1.813140212E9 1.708012084269E12 1064144.0 4.4584861175E10 1.668188137320503E15 3.044124336E9&quot;
  min = {DenseVector@10732} &quot;375.0 120.0 20.0 112.0 0.0 33.0 -1.0 13.0&quot;
  max = {DenseVector@10733} &quot;21705.0 1024.0 768.0 2497.0 3.0 1835.0 100248.0 195.0&quot;
  normL1 = {DenseVector@10734} &quot;7.257042877E9 1.27629988E8 2.2663266E7 8.09923879E8 414396.0 7.7641159E7 1.6666064771E10 3.0589982E7&quot;
  numericalColIndices = {int[8]@10735} 
  count = 399999  
  
// 这是输出    
model = {Tuple3@10816} &quot;(Params {withMean=true, withStd=true},[[18142.652549131373,319.07576768941925,56.658306645766615,2024.814759536899,1.035992589981475,194.1033827584569,41664.098582746454,76.47514618786548], [3315.6115741652725,20.281383913437733,36.36896282478844,412.51242496870356,1.259797591740416,271.6366927754722,49341.56204742555,41.974829196745965]],[])&quot;
 f0 = {Params@10817} &quot;Params {withMean=true, withStd=true}&quot;
 f1 = {ArrayList@10820}  size = 2
  0 = &quot;[18142.652549131373,319.07576768941925,56.658306645766615,2024.814759536899,1.035992589981475,194.1033827584569,41664.098582746454,76.47514618786548]&quot;
  1 = &quot;[3315.6115741652725,20.281383913437733,36.36896282478844,412.51242496870356,1.259797591740416,271.6366927754722,49341.56204742555,41.974829196745965]&quot;
 f2 = {ArrayList@10818}  size = 0  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;44-转换-mapper&quot;&gt;4.4 转换 mapper&lt;/h3&gt;
&lt;p&gt;训练好之后，当转换时候，会对每个item row进行map，这里面使用之前计算出来的 means/stdDevs 进行具体标准化。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public Row map(Row row) throws Exception {
    Row r = new Row(this.selectedColIndices.length);
    for (int i = 0; i &amp;lt; this.selectedColIndices.length; i++) {
        Object obj = row.getField(this.selectedColIndices[i]);
        if (null != obj) {
            if (this.stddevs[i] &amp;gt; 0) {
                double d = (((Number) obj).doubleValue() - this.means[i]) / this.stddevs[i];
                r.setField(i, d);
            } else {
                r.setField(i, 0.0);
            }
        }
    }
    return this.predResultColsHelper.getResultRow(row, r);
}

// means，stddevs 是对应那几列之前统计出来的总体数值，是根据这些来进行转换的。
this = {StandardScalerModelMapper@10909} 
 selectedColNames = {String[8]@10873} 
 selectedColTypes = {TypeInformation[8]@10874} 
 selectedColIndices = {int[8]@10912} 
 means = {double[8]@10913} 
  0 = 18142.652549131373
...
  7 = 76.47514618786548
 stddevs = {double[8]@10914} 
  0 = 3315.6115741652725
...
  7 = 41.974829196745965
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;变量如下，Row是输入数据，r 是对那几个需要转换的数据进行转换之后，生成的数据。&lt;/p&gt;
&lt;p&gt;标准化之后，用 OutputColsHelper.getResultRow把 Row 和 r 归并起来。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;row = {Row@10865} &quot;3200382705425230287,1,14102101,1005,0,85f751fd,c4e18dd6,50e219e0,98fed791,d9b5648e,0f2161f8,a99f214a,f69683cc,f51246a7,1,0,20984,320,50,2371,0,551,-1,46&quot;
其中 &quot;20984,320,50,2371,0,551,-1,46&quot; 是需要转换的数据。
    
r = {Row@10866} &quot;0.8569602884149525,0.04557047559108551,-0.18307661612028242,0.8392116685682023,-0.8223484445229384,1.313874843618953,-0.8444219609970856,-0.7260338343491822&quot;
这里是上面需要转换的数据进行标准化之后的结果
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;堆栈如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;getResultRow:177, OutputColsHelper (com.alibaba.alink.common.utils)
map:88, StandardScalerModelMapper (com.alibaba.alink.operator.common.dataproc)
map:43, ModelMapperAdapter (com.alibaba.alink.common.mapper)
map:18, ModelMapperAdapter (com.alibaba.alink.common.mapper)
run:103, MapDriver (org.apache.flink.runtime.operators)
run:504, BatchTask (org.apache.flink.runtime.operators)
invoke:369, BatchTask (org.apache.flink.runtime.operators)
doRun:707, Task (org.apache.flink.runtime.taskmanager)
run:532, Task (org.apache.flink.runtime.taskmanager)
run:748, Thread (java.lang)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x05-特征哈希-featurehasher&quot;&gt;0x05 特征哈希 FeatureHasher&lt;/h2&gt;
&lt;p&gt;FeatureHasher完成了特征哈希功能，这个没有训练，就是mapper。具体细节是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把 categorical特征 或者 数值特征 投射到给定领域的特征向量上。&lt;/li&gt;
&lt;li&gt;使用 MurMurHash3 算法。&lt;/li&gt;
&lt;li&gt;对于categorical特征，使用&quot;colName=value&quot;进行哈希。colName是特征列名，value是特征值。相关哈希值是 1.0&lt;/li&gt;
&lt;li&gt;对于数值特征，使用&quot;colName&quot;做哈希。相关哈希值就是特征值&lt;/li&gt;
&lt;li&gt;categorical特征 或者 数值特征 是自动发现的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对应代码看。&lt;/p&gt;
&lt;h3 id=&quot;51-稀疏矩阵&quot;&gt;5.1 稀疏矩阵&lt;/h3&gt;
&lt;p&gt;最终生成了一个30000大小的，最后名字是&quot;vec&quot;的特征矩阵。这里是稀疏矩阵。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String vecColName = &quot;vec&quot;;
int numHashFeatures = 30000;
// setup feature engineering pipeline
Pipeline featurePipeline = new Pipeline()
        .add(
                new StandardScaler()
                        .setSelectedCols(numericalColNames)
        )
        .add(
                new FeatureHasher()
                        .setSelectedCols(selectedColNames)
                        .setCategoricalCols(categoryColNames)
                        .setOutputCol(vecColName)
                        .setNumFeatures(numHashFeatures)
        );
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;52-featurehashermapper&quot;&gt;5.2 FeatureHasherMapper&lt;/h3&gt;
&lt;p&gt;传入map函数时候，Row就是 “原始数据经过标准化处理之后的数据”。&lt;/p&gt;
&lt;p&gt;遍历数值特征列，进行哈希变换；遍历categorical特征列，进行哈希转换。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FeatureHasherMapper extends Mapper {
    /**
     * Projects a number of categorical or numerical features into a feature vector of a specified dimension.
     *
     * @param row the input Row type data
     * @return the output row.
     */
    @Override
    public Row map(Row row) {
        TreeMap&amp;lt;Integer, Double&amp;gt; feature = new TreeMap&amp;lt;&amp;gt;();
        // 遍历数值特征列，进行哈希变换；
        for (int key : numericColIndexes) {
            if (null != row.getField(key)) {
                double value = ((Number)row.getField(key)).doubleValue();
                String colName = colNames[key];
                updateMap(colName, value, feature, numFeature);
            }
        }
        // 遍历categorical特征列，进行哈希转换
        for (int key : categoricalColIndexes) {
            if (null != row.getField(key)) {
                String colName = colNames[key];
                updateMap(colName + &quot;=&quot; + row.getField(key).toString(), 1.0, feature, numFeature);
            }
        }

        return outputColsHelper.getResultRow(row, Row.of(new SparseVector(numFeature, feature)));
    }  
}

//运行时候打印变量如下
selectedCols = {String[19]@9817} 
 0 = &quot;C1&quot;
 1 = &quot;banner_pos&quot;
 2 = &quot;site_category&quot;
 3 = &quot;app_domain&quot;
 4 = &quot;app_category&quot;
 5 = &quot;device_type&quot;
 6 = &quot;device_conn_type&quot;
 7 = &quot;C14&quot;
 8 = &quot;C15&quot;
 9 = &quot;C16&quot;
 10 = &quot;C17&quot;
 11 = &quot;C18&quot;
 12 = &quot;C19&quot;
 13 = &quot;C20&quot;
 14 = &quot;C21&quot;
 15 = &quot;site_id&quot;
 16 = &quot;site_domain&quot;
 17 = &quot;device_id&quot;
 18 = &quot;device_model&quot;
   
numericColIndexes = {int[8]@10789} 
 0 = 16
 1 = 17
 2 = 18
 3 = 19
 4 = 20
 5 = 21
 6 = 22
 7 = 23
   
categoricalColIndexes = {int[11]@10791} 
 0 = 3
 1 = 4
 2 = 7
 3 = 9
 4 = 10
 5 = 14
 6 = 15
 7 = 5
 8 = 6
 9 = 11
 10 = 13   
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;53-哈希操作-updatemap&quot;&gt;5.3 哈希操作 updateMap&lt;/h3&gt;
&lt;p&gt;updateMap完成了具体哈希操作，用哈希函数生成了稀疏矩阵的index，然后把value放入对应的index中。&lt;/p&gt;
&lt;p&gt;具体哈希函数使用 &lt;code&gt;org.apache.flink.shaded.guava18.com.google.common.hash&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/* Update the treeMap which saves the key-value pair of the final vector, use the hash value of the string as key
 * and the accumulate the corresponding value.
 *
 * @param s     the string to hash
 * @param value the accumulated value */
private static void updateMap(String s, double value, TreeMap&amp;lt;Integer, Double&amp;gt; feature, int numFeature) {
    // HASH = {Murmur3_32HashFunction@10755} &quot;Hashing.murmur3_32(0)&quot; 
    int hashValue = Math.abs(HASH.hashUnencodedChars(s).asInt());

    int index = Math.floorMod(hashValue, numFeature);
    if (feature.containsKey(index)) {
        feature.put(index, feature.get(index) + value);
    } else {
        feature.put(index, value);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如当如下输入时候，得到index是26798，所以会在vec中的 26798 中设置Value&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;s = &quot;C14&quot;
value = 0.33428145187593655
feature = {TreeMap@10836}  size = 1
 {Integer@10895} 26798 -&amp;gt; {Double@10896} 0.33428145187593655
numFeature = 30000
hashValue = 23306798
index = 26798
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终特征哈希之后，&lt;u&gt;得到的vec会附加在原始Row上的第25项&lt;/u&gt;（原来是24项，现在在最后附加一项），就是下面的 &lt;code&gt;24 = {SparseVector@10932}&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;row = {Row@10901} 
 fields = {Object[25]@10907} 
  0 = &quot;3199889859719711212&quot;
  1 = &quot;0&quot;
  2 = &quot;14102101&quot;
  3 = &quot;1005&quot;
  4 = {Integer@10912} 0
  5 = &quot;1fbe01fe&quot; // &quot;device_type&quot; 是这个数值，这个是原始输入，大家如果遗忘可以回头看看示例代码输出。
  6 = &quot;f3845767&quot;
  7 = &quot;28905ebd&quot;
  8 = &quot;ecad2386&quot;
  9 = &quot;7801e8d9&quot;
  10 = &quot;07d7df22&quot;
  11 = &quot;a99f214a&quot;
  12 = &quot;cfa82746&quot;
  13 = &quot;c6263d8a&quot;
  14 = &quot;1&quot;
  15 = &quot;0&quot;
  16 = {Double@10924} -0.734299689415312
  17 = {Double@10925} 0.04557047559108551
  18 = {Double@10926} -0.18307661612028242
  19 = {Double@10927} -0.7340742756048447
  20 = {Double@10928} -0.8223484445229384
  21 = {Double@10929} -0.5857212482334542
  22 = {Double@10930} -0.8444219609970856
  23 = {Double@10931} 0.060151616110215377
  24 = {SparseVector@10932} &quot;$30000$725:-0.8223484445229384 1000:1.0 3044:-0.8444219609970856 4995:-0.18307661612028242 8049:0.060151616110215377 8517:1.0 10962:1.0 17954:1.0 18556:1.0 21430:1.0 23250:1.0 24010:1.0 24390:1.0 25083:0.04557047559108551 25435:-0.5857212482334542 25721:-0.7340742756048447 26169:1.0 26798:-0.734299689415312 29671:1.0&quot;
    
// 30000 表示一共是30000大小的稀疏向量
// 725:-0.8223484445229384 表示第725的item中的数值是-0.8223484445229384，依次类推。    
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/mooneve/article/details/81943904&quot;&gt;深度学习图像预处理中为什么使用零均值化(zero-mean)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.datalearner.com/blog/1051537932880901&quot;&gt;数据特征处理之特征哈希（Feature Hashing）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/rossiXYZ/p/datalearner.com/blog/1051538986119321&quot;&gt;特征工程相关技术简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/chenpe32cp/article/details/79753209&quot;&gt;特征哈希（Feature Hashing）&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 03 Jul 2020 22:42:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>Alink 是阿里巴巴基于实时计算引擎 Flink 研发的新一代机器学习算法平台，是业界首个同时支持批式算法、流式算法的机器学习平台。本文将剖析Alink “特征工程” 部分对应代码实现。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/13233067.html</dc:identifier>
</item>
<item>
<title>Spring事务的传播级别 - 一条路上的咸鱼</title>
<link>http://www.cnblogs.com/jack1995/p/13233540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jack1995/p/13233540.html</guid>
<description>&lt;h3 id=&quot;一、简单说明&quot;&gt;一、简单说明&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;传播属性&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PROPAGATION_REQUIRED&lt;/td&gt;
&lt;td&gt;如果当前没有事务，就创建一个事务，如果当前存在事务，就加入该事务。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PROPAGATION_REQUIRED_NEW&lt;/td&gt;
&lt;td&gt;当前的方法必须启动新事务，并在它自己的事务内运行，不管是否存着事务，都开启新事务。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PROPAGATION_SUPPORTS&lt;/td&gt;
&lt;td&gt;如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务的方式执行。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;PROPAGATION_NOT_SUPPORTED&lt;/td&gt;
&lt;td&gt;当前的方法不应该运行在事务中，如果有运行的事务，将它挂起&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PROPAGATION_MANDATORY&lt;/td&gt;
&lt;td&gt;如果当前存在事务，就加入当前事务，如果当前不存在事务，就抛出异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;PROPAGATION_NEVER&lt;/td&gt;
&lt;td&gt;当前的方法不应该运行在事务中，如果当前存在事务，就抛出异常&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;PROPAGATION_NESTED&lt;/td&gt;
&lt;td&gt;如果有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行，否则，就启动一个新的事务，并在它自己的事务内运行。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;二、具体案例描述&quot;&gt;二、具体案例描述&lt;/h3&gt;
&lt;p&gt;1.PROPAGATION_REQUIRED&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Transactional(propagation=PROPAGATION_REQUIRED)
pubilc void methodA(){
        doPreSomething;
        methodB();
        doSufSomething;
}

@Transactional(propagation=PROPAGATION_REQUIRED)
pubilc void methodB(){
        doSomething;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在两个方法的事务传播级别都是PROPAGATION_REQURIED的时候。&lt;br/&gt;如果调用方法A，会开启一个事务，在方法A内部调用方法B，由于方法A已经存在开启尚未提交的事务，方法B不会就不会再开启一个新的事务，方法B会直接加入方法A的事务中执行，这样如果在执行方法B的时候出了异常导致事务回滚，则B的方法和A的方法都会回滚。如果A的doPreSomething()和方法B都执行成功了，但是在执行doSufSomething()方法的时候抛出了异常导致事务回滚，则doSufSomething()、methodB()和doPreSomething()都会回滚。&lt;br/&gt;如果不通过方法A而单独调用方法B，则会开启一个事务。&lt;br/&gt;PROPAGATION_REQURIED所有方法公用一个事务，要么一起成功提交，要么一起失败回滚。&lt;br/&gt;&lt;strong&gt;如果嵌套执行的方法要求一起执行成功或者一起回滚，则选择该事物传播级别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行逻辑：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;开启事务&lt;br/&gt;执行方法Ａ的doPreSomething&lt;br/&gt;执行方法B&lt;br/&gt;执行方法A的doSufSomething&lt;br/&gt;提交或回滚事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.PROPAGATION_REQUIRED_NEW&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Transactional(propagation=PROPAGATION_REQUIRED)
pubilc void methodA(){
        doPreSomething;
        methodB();
        dosufSomething;
}

@Transactional(propagation=PROPAGATION_REQUIRED_NEW)
pubilc void methodB(){
       doSomething;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在事务的隔离级别是PROPAGATION_REQUIRED_NEW的时候。&lt;br/&gt;如果调用方法A，会开启一个事务，在方法内部调用方法B，方法B会自己再开启一个事务，然后方法B在自己的事务内部执行，如果方法B执行失败抛出异常，那么事务B会进行回滚，事务A不会受到影响可以继续执行，如果在方法B执行成功，方法B的事务会单独进行提交；B提交事务之后接着执行A的doSufSomething()方法，如果执行成功提交A的事务，如果抛出异常，则只回滚A的事务，对B的事务不会进行影响，也就说B的事务不会进行回滚。&lt;br/&gt;如果不通过方法A而单独调用方法B，则会开启一个事务。&lt;br/&gt;PROPAGATION_REQURIED_NEW所有方法使用各自的事务，各自提交或者回滚各自的事务，相互之间不会造成影响。&lt;br/&gt;&lt;strong&gt;如果嵌套执行的方法要求各自事务独立，不能进行相互影响，则选择本事务传播级别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行逻辑&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;开启事务&lt;br/&gt;执行方法Ａ的doPreSomething&lt;br/&gt;开启另一个事务2&lt;br/&gt;执行方法B&lt;br/&gt;提交或者回滚事务2&lt;br/&gt;执行方法A的doSufSomething&lt;br/&gt;提交或回滚事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;3.PROPAGATION_SUPPORTS&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Transactional(propagation=PROPAGATION_REQUIRED)
pubilc void methodA(){
        doPreSomething;
        methodB();
        doSufSomething;
}

@Transactional(propagation=PROPAGATION_SUPPORTS)
pubilc void methodB(){
       doSomething;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在事务的隔离级别是PROPAGATION_SUPPORTS的时候。&lt;br/&gt;如果调用方法A，会开启一个事务，在方法A内部调用方法B，由于方法A已经存在开启尚未提交的事务，方法B会直接加入方法A的事务中执行，这样如果在执行方法B的时候出了异常导致事务回滚，则B的方法和A的方法都会回滚。如果A的doPreSomething()和方法B都执行成功了，但是在执行doSufSomething()方法的时候抛出了异常导致事务回滚，则doSufSomething()、methodB()和doPreSomething()都会回滚。&lt;br/&gt;如果不通过方法A而单独调用方法B，则方法B不会开启事务，直接会以非事务的方式执行。&lt;br/&gt;PROPAGATION_SUPPORTS如果存着事务就加入和PROPAGATION_REQUIRED传播级别一致，如果当前不存在事务，则不会创建新的事务，以非事务的方式执行。&lt;br/&gt;&lt;strong&gt;如果嵌套执行的方法要求一起执行成功或者一起回滚，单独执行时候以非事务方式执行，则选择该事物传播级别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行逻辑：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;开启事务&lt;br/&gt;执行方法Ａ的doPreSomething&lt;br/&gt;执行方法B&lt;br/&gt;执行方法A的doSufSomething&lt;br/&gt;提交或回滚事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;4.PROPAGATION_NOT_SUPPORTED&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Transactional(propagation=PROPAGATION_REQUIRED)
pubilc void methodA(){
        doPreSomething;
        methodB();
        doSufSomething;
}

@Transactional(propagation=PROPAGATION_NOT_SUPPORTED)
pubilc void methodB(){
        doSomething;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在事务的隔离级别是PROPAGATION_NOT_SUPPORTED的时候。&lt;br/&gt;如果调用方法A，会开启一个事务，在方法A内部调用方法B，由于方法A已经存在开启尚未提交的事务，方法B不允许在事务内部执行，这时候事务就会挂起，在非事务的状态中执行方法B，不管方法B是执行成功还是执行失败，都不会对当前事务造成影响。如果A的doPreSomething()和方法B都执行成功了，但是在执行doSufSomething()方法的时候抛出了异常导致事务回滚，则doSufSomething()和doPreSomething()会回滚，而方法B不会受到任何影响，因为它是在非事务中执行的。&lt;br/&gt;如果不通过方法A而单独调用方法B，则方法B不会开启事务，直接会以非事务的方式执行。&lt;br/&gt;PROPAGATION_NOT_SUPPORTED如果存着事务就挂起当前事务，以非事务的方式运行自己，如果当前不存在事务，则不会创建新的事务，以非事务的方式执行。&lt;br/&gt;&lt;strong&gt;如果嵌套执行的方法要求内部嵌套方法不会对外部方法事务造成影响并且内部方法不需要事务，单独执行时候以非事务方式执行，则选择该事物传播级别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行逻辑：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;开启事务&lt;br/&gt;执行方法Ａ的doPreSomething&lt;br/&gt;挂起事务&lt;br/&gt;执行方法B&lt;br/&gt;重新启用挂起的事务&lt;br/&gt;执行方法A的doSufSomething&lt;br/&gt;提交或回滚事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;5.PROPAGATION_MANDATORY&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Transactional(propagation=PROPAGATION_REQUIRED)
pubilc void methodA(){
        doPreSomething;
        methodB();
        doSufSomething;
}

@Transactional(propagation=PROPAGATION_MANDATORY)
pubilc void methodB(){
       doSomething;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在事务的隔离级别是PROPAGATION_MANDATORY的时候。&lt;br/&gt;如果调用方法A，会开启一个事务，在方法A内部调用方法B，由于方法A已经存在开启尚未提交的事务，方法B会直接加入方法A的事务中执行，这样如果在执行方法B的时候出了异常导致事务回滚，则B的方法和A的方法都会回滚。如果A的doPreSomething()和方法B都执行成功了，但是在执行doSufSomething()方法的时候抛出了异常导致事务回滚，则doSufSomething()、methodB()和doPreSomething()都会回滚。&lt;br/&gt;如果不通过方法A而单独调用方法B，则方法B会直接报错，因为方法B的事务传播级别是PROPAGATION_MANDATORY,而其不允许在没有事务的环境下执行。&lt;br/&gt;PROPAGATION_SUPPORTS如果存着事务就加入和PROPAGATION_REQUIRED传播级别一致，如果当前不存在事务，会直接进行报错，不允许以非事务的方式执行。&lt;br/&gt;&lt;strong&gt;如果嵌套执行的方法要求一起执行成功或者一起回滚，单独执行时候不允许以非事务方式执行，则选择该事物传播级别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行逻辑：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;开启事务&lt;br/&gt;执行方法Ａ的doPreSomething&lt;br/&gt;执行方法B&lt;br/&gt;执行方法A的doSufSomething&lt;br/&gt;提交或回滚事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;6.PROPAGATION_NEVER&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Transactional(propagation=PROPAGATION_REQUIRED)
pubilc void methodA(){
        doPreSomething;
        methodB();
        doSufSomething;
}

@Transactional(propagation=PROPAGATION_NEVER)
pubilc void methodB(){
        doSomething;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在事务的隔离级别是PROPAGATION_NERVR的时候。&lt;br/&gt;如果调用方法A，会开启一个事务，在方法A内部调用方法B，由于方法A已经存在开启尚未提交的事务，方法B的传播级别为PROPAGATION_NEVER，其不允许在事务内部执行，所以这时候就会直接报错。&lt;br/&gt;如果不通过方法A而单独调用方法B，则方法B会直接在没有事务的环境中执行。&lt;br/&gt;PROPAGATION_NERVER如果存着事务就直接报错，如果当前不存在事务，会以非事务的方式执行。&lt;br/&gt;&lt;strong&gt;如果嵌套执行的方法要求内部方法不允许在事务中执行，单独执行时候必须以非事务方式执行，则选择该事物传播级别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行逻辑：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;开启事务&lt;br/&gt;执行方法Ａ的doPreSomething&lt;br/&gt;执行方法B，直接报错&lt;br/&gt;回滚事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;7.PROPAGATION_NESTED&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Transactional(propagation=PROPAGATION_REQUIRED)
pubilc void methodA(){
        doPreSomething;
        methodB();
        doSufSomething;
}

@Transactional(propagation=PROPAGATION_NESTED)
pubilc void methodB(){
        doSomething;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在事务的隔离级别是PROPAGATION_NESTED的时候。&lt;br/&gt;如果调用方法A，会开启一个事务，在方法A内部调用方法B，由于方法A已经存在开启尚未提交的事务，方法B的传播级别为PROPAGATION_NESTED，会加入这个事务当中，但是在执行到方法B之前会创建一个事务的回滚点(savepoint),然后执行方法B，如果方法B执行失败了，事务会进行回滚，但是这时指挥回滚到回滚点，也就是之后回滚B的操作，外部方法的操作不会回滚；如果B执行成功了，接着执行A的doSufSomething()方法，如果执行出错，则会回滚整个事务，也就是doSufSomething()、methodB()和doPreSomething()的执行都会进行回滚。&lt;br/&gt;如果直接调用方法B，则会开启一个事务，和PROPAGATION_REQUIRED传播级别一致。&lt;br/&gt;&lt;strong&gt;如果嵌套执行的方法要求内部方法出错只回滚自己，外部方法执行失败回滚所有，单独执行时候自动开启一个执行，则选择该事物传播级别。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;执行逻辑：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;开启事务&lt;br/&gt;执行方法Ａ的doPreSomething&lt;br/&gt;创建回滚点savepoint&lt;br/&gt;执行方法B，失败只回滚到savepoint&lt;br/&gt;执行方法A的doSufSomething&lt;br/&gt;提交或回滚事务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;三、总结&quot;&gt;三、总结&lt;/h3&gt;
&lt;p&gt;1、PROPAGATION_REQUIRED&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;是否开启事务&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;是否回滚&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;doPreSomething&lt;/td&gt;
&lt;td&gt;开启事务&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;methodB&lt;/td&gt;
&lt;td&gt;A内部直接加入事务，不单独开启，单独调用开启&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;doSufSomething&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所有方法在同一个事务中运行，要么一起成功提交事务，要么一起回滚事务，如果单独执行，各自单独开启各自事务。&lt;/p&gt;
&lt;p&gt;2、PROPAGATION_REQUIRED_NEW&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;是否开启事务&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;是否回滚&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;doPreSomething&lt;/td&gt;
&lt;td&gt;开启事务&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;只回滚方法A自己&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;methodB&lt;/td&gt;
&lt;td&gt;开启事务&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;只回滚方法B自己&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;doSufSomething&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;值回滚方法A自己&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;PROPAGATION_REQURIED_NEW所有方法使用各自的事务，各自提交或者回滚各自的事务，相互之间不会造成影响。&lt;br/&gt;如果嵌套执行的方法要求各自事务独立，不能进行相互影响，则选择本事务传播级别。&lt;/p&gt;
&lt;p&gt;3、PROPAGATION_SUPPORTS|&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;是否开启事务&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;是否回滚&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;doPreSomething&lt;/td&gt;
&lt;td&gt;开启事务&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;methodB&lt;/td&gt;
&lt;td&gt;A内部加入事务不单独开启，单独调用不开启&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;doSufSomething&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果嵌套执行的方法要求一起执行成功或者一起回滚，单独执行时候以非事务方式执行，则选择该事物传播级别。&lt;/p&gt;
&lt;p&gt;4、PROPAGATION_NOT_SUPPORTED&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;是否开启事务&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;是否回滚&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;doPreSomething&lt;/td&gt;
&lt;td&gt;开启事务&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;只回滚A自己&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;methodB&lt;/td&gt;
&lt;td&gt;A内部挂起A的事务状态执行事务以非，不单独开启，单独调用不开启&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;不做任何回滚&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;doSufSomething&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;只回滚A自己&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果嵌套执行的方法要求内部嵌套方法不会对外部方法事务造成影响并且内部方法不需要事务，单独执行时候以非事务方式执行，则选择该事物传播级别。&lt;/p&gt;
&lt;p&gt;5、PROPAGATION_MANDATORY&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;是否开启事务&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;是否回滚&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;doPreSomething&lt;/td&gt;
&lt;td&gt;开启事务&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;methodB&lt;/td&gt;
&lt;td&gt;A内部加入A的事务，不单独开启，单独调用跑错&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;doSufSomething&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果嵌套执行的方法要求一起执行成功或者一起回滚，单独执行时候不允许以非事务方式执行，则选择该事物传播级别。&lt;/p&gt;
&lt;p&gt;6、PROPAGATION_NEVER&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;是否开启事务&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;是否回滚&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;doPreSomething&lt;/td&gt;
&lt;td&gt;开启事务&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;methodB&lt;/td&gt;
&lt;td&gt;A存着事务直接抛错，不单独开启&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;doSufSomething&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果嵌套执行的方法要求内部方法不允许在事务中执行，单独执行时候必须以非事务方式执行，则选择该事物传播级别。&lt;/p&gt;
&lt;p&gt;7、PROPAGATION_NESTED&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;是否开启事务&lt;/th&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;是否回滚&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;doPreSomething&lt;/td&gt;
&lt;td&gt;开启事务&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;methodB&lt;/td&gt;
&lt;td&gt;A存着事务就直接加入Ａ事务，不存在开启事务&lt;/td&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;只回滚Ｂ自己&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;doSufSomething&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;失败&lt;/td&gt;
&lt;td&gt;全部回滚&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果嵌套执行的方法要求内部方法出错只回滚自己，外部方法执行失败回滚所有，单独执行时候自动开启一个执行，则选择该事物传播级别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8494967-a2fd98bc84e60e02.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;timg.jpeg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Jul 2020 18:51:00 +0000</pubDate>
<dc:creator>一条路上的咸鱼</dc:creator>
<og:description>一、简单说明 传播属性 描述 PROPAGATION_REQUIRED 如果当前没有事务，就创建一个事务，如果当前存在事务，就加入该事务。 PROPAGATION_REQUIRED_NEW 当前的方法</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jack1995/p/13233540.html</dc:identifier>
</item>
<item>
<title>mmdetection源码剖析(1)--NMS - ManWingloeng</title>
<link>http://www.cnblogs.com/ManWingloeng/p/13233469.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ManWingloeng/p/13233469.html</guid>
<description>&lt;p&gt;熟悉目标检测的应该都清楚&lt;strong&gt;NMS&lt;/strong&gt;是什么算法，但是如果我们要与C++和cuda结合直接写成Pytorch的操作你们清楚怎么写吗？最近在看&lt;strong&gt;mmdetection&lt;/strong&gt;的源码，发现其实原来写C++和cuda的扩展也不难，下面给大家讲一下。&lt;/p&gt;
&lt;p&gt;C ++的扩展是允许用户来创建自定义PyTorch框架外的操作（operators ）的，即从PyTorch后端分离。此方法&lt;em&gt;与&lt;/em&gt;实现本地PyTorch操作的方式&lt;em&gt;不同&lt;/em&gt;。C ++扩展旨在为您节省大量与将操作与PyTorch后端集成在一起相关的样板，同时为基于PyTorch的项目提供高度的灵活性。&lt;/p&gt;
&lt;p&gt;官方给出了一个&lt;a href=&quot;https://pytorch.org/tutorials/advanced/cpp_extension.html&quot;&gt;LLTM的例子&lt;/a&gt;，大家也可以看一下。&lt;/p&gt;
&lt;h2 id=&quot;nms算法&quot;&gt;NMS算法&lt;/h2&gt;
&lt;p&gt;先复习一下NMS的算法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;（1）将所有框的得分排序，选中最高分及其对应的框&lt;/li&gt;
&lt;li&gt;（2）遍历其余的框，如果和当前最高分框的重叠面积(IOU)大于一定阈值，我们就将框删除。&lt;/li&gt;
&lt;li&gt;（3）从未处理的框中继续选一个得分最高的，重复上述过程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里我给出一份纯numpy的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def nms(bounding_boxes, Nt):
    if len(bounding_boxes) == 0:
        return [], []
    bboxes = np.array(bounding_boxes) 
    x1 = bboxes[:, 0]
    y1 = bboxes[:, 1]
    x2 = bboxes[:, 2]
    y2 = bboxes[:, 3]
    scores = bboxes[:, 4]
    areas = (x2 - x1 + 1) * (y2 - y1 + 1)
    order = np.argsort(scores)
    picked_boxes = []  
    while order.size &amp;gt; 0:
        index = order[-1]
        picked_boxes.append(bounding_boxes[index])
        x11 = np.maximum(x1[index], x1[order[:-1]])
        y11 = np.maximum(y1[index], y1[order[:-1]])
        x22 = np.minimum(x2[index], x2[order[:-1]])
        y22 = np.minimum(y2[index], y2[order[:-1]])
        w = np.maximum(0.0, x22 - x11 + 1)
        h = np.maximum(0.0, y22 - y11 + 1)
        intersection = w * h
        ious = intersection / (areas[index] + areas[order[:-1]] - intersection)
        left = np.where(ious &amp;lt; Nt)
        order = order[left]
    return picked_boxes
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编写pytorch-c扩展的步骤&quot;&gt;编写Pytorch C++扩展的步骤&lt;/h2&gt;
&lt;p&gt;需要编写下面5个文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;nms_kernel.cu&lt;/li&gt;
&lt;li&gt;nms_cuda.cpp&lt;/li&gt;
&lt;li&gt;nms_ext.cpp&lt;/li&gt;
&lt;li&gt;setup.py&lt;/li&gt;
&lt;li&gt;nms_wrapper.py&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;(1) nms_kernel.cu 主要使用ATen和THC库编写nms_cuda_forward的函数，使用C++编写，涉及一些lazyInitCUDA，THCudaFree，THCCeilDiv 的操作，算法跟我们前面写的numpy差不太多。&lt;/p&gt;
&lt;p&gt;(2) nms_cuda.cpp 是调用了nms_kernel.cu文件的nms_cuda_forward封装了一下变成nms_cuda函数。&lt;/p&gt;
&lt;p&gt;(3) nms_ext.cpp 进一步封装nms_cuda函数为nms，并且通过PYBIND11_MODULE绑定成python可调用的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;PYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {
  m.def(&quot;nms&quot;, &amp;amp;nms, &quot;non-maximum suppression&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面那样就相当于告诉python函数名定义为nms了。&lt;/p&gt;
&lt;p&gt;(4) setup.py 就是编译一遍nms_ext，至此你就可以通过nms_ext.nms调用cpp extension作为pytorch的操作了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;make_cuda_ext(
    name='nms_ext',
    module='mmdet.ops.nms',
    sources=['src/nms_ext.cpp', 'src/cpu/nms_cpu.cpp'],
    sources_cuda=[
    'src/cuda/nms_cuda.cpp', 'src/cuda/nms_kernel.cu'
    ]),
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(5) nms_wrapper.py 再次封装 nms_ext.nms，方便使用，使用实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from . import nms_ext
inds = nms_ext.nms(dets_th, iou_thr)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;稍微完整的代码如下，但是我也删减了一些，只剩下nms相关的代码，想要看完整代码可以点击下面的文件名。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/open-mmlab/mmdetection/blob/e903b5c109dc9ee5bb06c35fbe3b9c1f88ba6367/mmdet/ops/nms/src/cuda/nms_kernel.cu&quot;&gt;&lt;strong&gt;nms_kernel.cu&lt;/strong&gt;&lt;/a&gt; (这个估计有部分是Facebook写的)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;// Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
#include &amp;lt;ATen/ATen.h&amp;gt;
#include &amp;lt;ATen/cuda/CUDAContext.h&amp;gt;
#include &amp;lt;ATen/DeviceGuard.h&amp;gt;
#include &amp;lt;THC/THC.h&amp;gt;
#include &amp;lt;THC/THCDeviceUtils.cuh&amp;gt;
#include &amp;lt;vector&amp;gt;
#include &amp;lt;iostream&amp;gt;

int const threadsPerBlock = sizeof(unsigned long long) * 8;

__device__ inline float devIoU(float const * const a, float const * const b) {
  float left = max(a[0], b[0]), right = min(a[2], b[2]);
  float top = max(a[1], b[1]), bottom = min(a[3], b[3]);
  float width = max(right - left, 0.f), height = max(bottom - top, 0.f);
  float interS = width * height;
  float Sa = (a[2] - a[0]) * (a[3] - a[1]);
  float Sb = (b[2] - b[0]) * (b[3] - b[1]);
  return interS / (Sa + Sb - interS);
}

__global__ void nms_kernel(const int n_boxes, const float nms_overlap_thresh,
                           const float *dev_boxes, unsigned long long *dev_mask) {
  const int row_start = blockIdx.y;
  const int col_start = blockIdx.x;
  // if (row_start &amp;gt; col_start) return;
  const int row_size =
        min(n_boxes - row_start * threadsPerBlock, threadsPerBlock);
  const int col_size =
        min(n_boxes - col_start * threadsPerBlock, threadsPerBlock);

  __shared__ float block_boxes[threadsPerBlock * 5];
  if (threadIdx.x &amp;lt; col_size) {
    block_boxes[threadIdx.x * 5 + 0] =
        dev_boxes[(threadsPerBlock * col_start + threadIdx.x) * 5 + 0];
    block_boxes[threadIdx.x * 5 + 1] =
        dev_boxes[(threadsPerBlock * col_start + threadIdx.x) * 5 + 1];
    block_boxes[threadIdx.x * 5 + 2] =
        dev_boxes[(threadsPerBlock * col_start + threadIdx.x) * 5 + 2];
    block_boxes[threadIdx.x * 5 + 3] =
        dev_boxes[(threadsPerBlock * col_start + threadIdx.x) * 5 + 3];
    block_boxes[threadIdx.x * 5 + 4] =
        dev_boxes[(threadsPerBlock * col_start + threadIdx.x) * 5 + 4];
  }
  __syncthreads();

  if (threadIdx.x &amp;lt; row_size) {
    const int cur_box_idx = threadsPerBlock * row_start + threadIdx.x;
    const float *cur_box = dev_boxes + cur_box_idx * 5;
    int i = 0;
    unsigned long long t = 0;
    int start = 0;
    if (row_start == col_start) {
      start = threadIdx.x + 1;
    }
    for (i = start; i &amp;lt; col_size; i++) {
      if (devIoU(cur_box, block_boxes + i * 5) &amp;gt; nms_overlap_thresh) {
        t |= 1ULL &amp;lt;&amp;lt; i;
      }
    }
    const int col_blocks = THCCeilDiv(n_boxes, threadsPerBlock);
    dev_mask[cur_box_idx * col_blocks + col_start] = t;
  }
}
// boxes is a N x 5 tensor
at::Tensor nms_cuda_forward(const at::Tensor boxes, float nms_overlap_thresh) {
  // Ensure CUDA uses the input tensor device.
  at::DeviceGuard guard(boxes.device());
  using scalar_t = float;
  AT_ASSERTM(boxes.device().is_cuda(), &quot;boxes must be a CUDA tensor&quot;);
  auto scores = boxes.select(1, 4);
  auto order_t = std::get&amp;lt;1&amp;gt;(scores.sort(0, /* descending=*/true));
  auto boxes_sorted = boxes.index_select(0, order_t);

  int boxes_num = boxes.size(0);

  const int col_blocks = THCCeilDiv(boxes_num, threadsPerBlock);

  scalar_t* boxes_dev = boxes_sorted.data_ptr&amp;lt;scalar_t&amp;gt;();

  THCState *state = at::globalContext().lazyInitCUDA(); // TODO replace with getTHCState

  unsigned long long* mask_dev = NULL;
  //THCudaCheck(THCudaMalloc(state, (void**) &amp;amp;mask_dev,
  //                      boxes_num * col_blocks * sizeof(unsigned long long)));

  mask_dev = (unsigned long long*) THCudaMalloc(state, boxes_num * col_blocks * sizeof(unsigned long long));

  dim3 blocks(THCCeilDiv(boxes_num, threadsPerBlock),
              THCCeilDiv(boxes_num, threadsPerBlock));
  dim3 threads(threadsPerBlock);
  nms_kernel&amp;lt;&amp;lt;&amp;lt;blocks, threads, 0, at::cuda::getCurrentCUDAStream()&amp;gt;&amp;gt;&amp;gt;(boxes_num,
                                  nms_overlap_thresh,
                                  boxes_dev,
                                  mask_dev);

  std::vector&amp;lt;unsigned long long&amp;gt; mask_host(boxes_num * col_blocks);
  THCudaCheck(cudaMemcpyAsync(
                          &amp;amp;mask_host[0],
                          mask_dev,
                          sizeof(unsigned long long) * boxes_num * col_blocks,
                          cudaMemcpyDeviceToHost,
                          at::cuda::getCurrentCUDAStream()
                          ));

  std::vector&amp;lt;unsigned long long&amp;gt; remv(col_blocks);
  memset(&amp;amp;remv[0], 0, sizeof(unsigned long long) * col_blocks);

  at::Tensor keep = at::empty({boxes_num}, boxes.options().dtype(at::kLong).device(at::kCPU));
  int64_t* keep_out = keep.data_ptr&amp;lt;int64_t&amp;gt;();

  int num_to_keep = 0;
  for (int i = 0; i &amp;lt; boxes_num; i++) {
    int nblock = i / threadsPerBlock;
    int inblock = i % threadsPerBlock;

    if (!(remv[nblock] &amp;amp; (1ULL &amp;lt;&amp;lt; inblock))) {
      keep_out[num_to_keep++] = i;
      unsigned long long *p = &amp;amp;mask_host[0] + i * col_blocks;
      for (int j = nblock; j &amp;lt; col_blocks; j++) {
        remv[j] |= p[j];
      }
    }
  }
  THCudaFree(state, mask_dev);
  // TODO improve this part
  return order_t.index({
      keep.narrow(/*dim=*/0, /*start=*/0, /*length=*/num_to_keep).to(
          order_t.device(), keep.scalar_type())});
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/open-mmlab/mmdetection/blob/e903b5c109dc9ee5bb06c35fbe3b9c1f88ba6367/mmdet/ops/nms/src/cuda/nms_cuda.cpp&quot;&gt;&lt;strong&gt;nms_cuda.cpp&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#include &amp;lt;torch/extension.h&amp;gt;
#define CHECK_CUDA(x) TORCH_CHECK(x.device().is_cuda(), #x, &quot; must be a CUDAtensor &quot;)
at::Tensor nms_cuda_forward(const at::Tensor boxes, float nms_overlap_thresh);
at::Tensor nms_cuda(const at::Tensor&amp;amp; dets, const float threshold) {
  CHECK_CUDA(dets);
  if (dets.numel() == 0)
    return at::empty({0}, dets.options().dtype(at::kLong).device(at::kCPU));
  return nms_cuda_forward(dets, threshold);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/open-mmlab/mmdetection/blob/e903b5c109dc9ee5bb06c35fbe3b9c1f88ba6367/mmdet/ops/nms/src/nms_ext.cpp&quot;&gt;&lt;strong&gt;nms_ext.cpp&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#include &amp;lt;torch/extension.h&amp;gt;
#ifdef WITH_CUDA
at::Tensor nms_cuda(const at::Tensor&amp;amp; dets, const float threshold);
#endif
at::Tensor nms(const at::Tensor&amp;amp; dets, const float threshold){
  if (dets.device().is_cuda()) {
#ifdef WITH_CUDA
    return nms_cuda(dets, threshold);
#else
    AT_ERROR(&quot;nms is not compiled with GPU support&quot;);
#endif
  }
#  return nms_cpu(dets, threshold);
}
PYBIND11_MODULE(TORCH_EXTENSION_NAME, m) {
  m.def(&quot;nms&quot;, &amp;amp;nms, &quot;non-maximum suppression&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/open-mmlab/mmdetection/blob/32fcb5872af512c1822caa739ec9fa35d43c938b/setup.py&quot;&gt;&lt;strong&gt;setup.py&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def make_cuda_ext(name, module, sources, sources_cuda=[]):

    define_macros = []
    extra_compile_args = {'cxx': []}

    if torch.cuda.is_available() or os.getenv('FORCE_CUDA', '0') == '1':
        define_macros += [('WITH_CUDA', None)]
        extension = CUDAExtension
        extra_compile_args['nvcc'] = [
            '-D__CUDA_NO_HALF_OPERATORS__',
            '-D__CUDA_NO_HALF_CONVERSIONS__',
            '-D__CUDA_NO_HALF2_OPERATORS__',
        ]
        sources += sources_cuda
    else:
        print(f'Compiling {name} without CUDA')
        extension = CppExtension
        # raise EnvironmentError('CUDA is required to compile MMDetection!')

    return extension(
        name=f'{module}.{name}',
        sources=[os.path.join(*module.split('.'), p) for p in sources],
        define_macros=define_macros,
        extra_compile_args=extra_compile_args)

if __name__ == '__main__':
    write_version_py()
    setup(
        name='mmdet',
        version=get_version(),
        description='Open MMLab Detection Toolbox and Benchmark',
        long_description=readme(),
        author='OpenMMLab',
        author_email='chenkaidev@gmail.com',
        keywords='computer vision, object detection',
        url='https://github.com/open-mmlab/mmdetection',
        packages=find_packages(exclude=('configs', 'tools', 'demo')),
        package_data={'mmdet.ops': ['*/*.so']},
        classifiers=[
            'Development Status :: 4 - Beta',
            'License :: OSI Approved :: Apache Software License',
            'Operating System :: OS Independent',
            'Programming Language :: Python :: 3',
            'Programming Language :: Python :: 3.5',
            'Programming Language :: Python :: 3.6',
            'Programming Language :: Python :: 3.7',
        ],
        license='Apache License 2.0',
        setup_requires=parse_requirements('requirements/build.txt'),
        tests_require=parse_requirements('requirements/tests.txt'),
        install_requires=parse_requirements('requirements/runtime.txt'),
        extras_require={
            'all': parse_requirements('requirements.txt'),
            'tests': parse_requirements('requirements/tests.txt'),
            'build': parse_requirements('requirements/build.txt'),
            'optional': parse_requirements('requirements/optional.txt'),
        },
        ext_modules=[
            make_cuda_ext(
                name='compiling_info',
                module='mmdet.ops.utils',
                sources=['src/compiling_info.cpp']),
            make_cuda_ext(
                name='nms_ext',
                module='mmdet.ops.nms',
                sources=['src/nms_ext.cpp', 'src/cpu/nms_cpu.cpp'],
                sources_cuda=[
                    'src/cuda/nms_cuda.cpp', 'src/cuda/nms_kernel.cu'
                ]),
        ],
        cmdclass={'build_ext': BuildExtension},
        zip_safe=False)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/open-mmlab/mmdetection/blob/e903b5c109dc9ee5bb06c35fbe3b9c1f88ba6367/mmdet/ops/nms/nms_wrapper.py&quot;&gt;&lt;strong&gt;nms_wrapper.py&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from . import nms_ext
def nms(dets, iou_thr, device_id=None):
    # convert dets (tensor or numpy array) to tensor
    if isinstance(dets, torch.Tensor):
        is_numpy = False
        dets_th = dets
    elif isinstance(dets, np.ndarray):
        is_numpy = True
        device = 'cpu' if device_id is None else f'cuda:{device_id}'
        dets_th = torch.from_numpy(dets).to(device)
    else:
        raise TypeError('dets must be either a Tensor or numpy array, '
                        f'but got {type(dets)}')
    # execute cpu or cuda nms
    if dets_th.shape[0] == 0:
        inds = dets_th.new_zeros(0, dtype=torch.long)
    else:
        if dets_th.is_cuda:
            inds = nms_ext.nms(dets_th, iou_thr)
        else:
            inds = nms_ext.nms(dets_th, iou_thr)

    if is_numpy:
        inds = inds.cpu().numpy()
    return dets[inds, :], inds
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;想要编写一个c++和cuda的扩展给Pytorch使用，其实主要就4步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用ATEN和THC编写前向代码cu文件A&lt;/li&gt;
&lt;li&gt;封装成一个cpp文件B&lt;/li&gt;
&lt;li&gt;再把B封装一遍并且使用PYBIND11_MODULE绑定函数名function&lt;/li&gt;
&lt;li&gt;通过make_cuda_ext（这个是mmdetection自定义的函数）把组件setup一遍&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过绑定的函数名function就可以在Pytorch中调用了。&lt;/p&gt;
</description>
<pubDate>Fri, 03 Jul 2020 17:00:00 +0000</pubDate>
<dc:creator>ManWingloeng</dc:creator>
<og:description>C++和Cuda与Pytorch结合，NMS举例。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ManWingloeng/p/13233469.html</dc:identifier>
</item>
<item>
<title>一个可屏蔽长短链接的网络模块 - 游子陈</title>
<link>http://www.cnblogs.com/cgw0827/p/13233388.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgw0827/p/13233388.html</guid>
<description>&lt;p&gt;游戏开发中最复杂的模块，没有之一。其实我也不想写这篇文章，怎奈框架代码卖出去了，得给我的用户一个交代。&lt;br/&gt;网络模块都需要实现哪些功能呢？按我以往的开发经验总结如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;消息的正常发送与接收&lt;/li&gt;
&lt;li&gt;长链接的断线重连&lt;/li&gt;
&lt;li&gt;消息发送失败与尝试&lt;/li&gt;
&lt;li&gt;长链接的心跳处理&lt;/li&gt;
&lt;li&gt;适应各种服务器定义的协议格式&lt;/li&gt;
&lt;li&gt;适应各种数据传输格式&lt;/li&gt;
&lt;li&gt;屏蔽长短链接的差异&lt;/li&gt;
&lt;li&gt;长链接支持发送协议号与接收协议号不同的情况。&lt;/li&gt;
&lt;li&gt;让短链接也可以像长链接一样更新数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个看需求吧&lt;br/&gt;有没有开发过程中将长链接改成短链接的情况呢？你客户端不支持，服务器可是支持的。&lt;br/&gt;如果一个团队有很多开发人员，作为主程的你是否要屏蔽底层逻辑，提供统一的调用接口给其他开发人员使用呢？&lt;br/&gt;如果你一个人做一款游戏，你就随便来吧，随便什么样的方式只要你开心就好。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001340126-269100161.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Service 实现ServiceInterface接口负责屏蔽链接类型&lt;/li&gt;
&lt;li&gt;Message 负责封装发送和接收的消息。&lt;/li&gt;
&lt;li&gt;MessageHander 负责编解码处理。&lt;/li&gt;
&lt;li&gt;ServiceInfo 保存服务器信息。例如 ip 端口，协议号映射等信息。&lt;/li&gt;
&lt;li&gt;RemoteProxy 负责调用Service发送消息，接收Service返回的消息并通过事件派发给监听者。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;ServiceInfo&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001340421-738780131.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;ServiceInterface&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001340735-1948857970.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Service&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001340917-213073719.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;MessageHandler&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001341050-726741968.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;Message&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001341259-1998438871.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;RemoteProxy&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001341450-1865103040.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;定义一个类来处理链接的监听&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001341638-584809098.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;定义一个地址和开发环境相关的数据类&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001341989-520637884.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;实现编解码处理类&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001342179-1204032222.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;定义协议号常量类&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001342326-785505277.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;定义一个链接&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001342478-1410933036.png&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;使用方式&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;export default class LoginController extends LogicController {

    constructor(){
        super(LoginProxy.instance());
    }

    private static ins:LoginController;

    static instance():LoginController{
        if(!this.ins){
            this.ins = new LoginController();
        }
        return this.ins;
    }

    //注册协议号与回调函数
    getProtoList(){
        return [
            [NetConfig.OPEN,this.netOpen],
            [LoginProtocolIDs.LOGIN,this.loginRsp],
        ];
    }

    netOpen(){
        cc.log(' 链接成功 ')
        this.pushView('Prefab/LoginView','LoginView',null,ModuleManager.getLoader(),UIIndex.STACK)
    }
    //进入模块 先链接服务 当然也可以先弹出界面，再推送链接结果。
    intoLayer(){
        ModuleManager.setModuleID(ModuleID.LOGIN)
        //进入此模块，先进行链接操作，如果链接成功 会走loginRsp 函数
        this.remoteProxy.connect(new ServiceInfo(NetConfig.HTTP,AddressConfig.getAdress(AddressConfig.LOGIN,0)));
    }

    // 点击登陆按钮发送请求。
    loginReq(name:string){
        cc.log(&quot; loginReq &quot;,name);
        this.sendMessage(LoginProtocolIDs.LOGIN,{name:name,channel:'crazy'});
    }

    //登陆成功
    loginRsp(msg:ReceiveMessage){
        cc.log(&quot; loginRsp msg &quot;,msg);
        //由于服务器已经关闭，所以不会被调用，正常内容返回时会走这里。
    }

}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;细节代码太多了，如果都粘贴上来无法忍受。其实网络那些事论坛里已经有人说的很详细了。使用方式也很多，就好像都是用xxgl，每个引擎实现的方式都不同。我只是从框架和封装的角度整理一下具体的使用方式，其实细节的东西，你没有遇到的时候也是没办法理解的，代码里都是经验。有想法的同学留言吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/330473/202007/330473-20200704001342645-2001276807.jpg&quot; alt=&quot;微信图片_20190904220029.jpg&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;欢迎扫码关注公众号《微笑游戏》，浏览更多内容。&lt;/p&gt;
</description>
<pubDate>Fri, 03 Jul 2020 16:14:00 +0000</pubDate>
<dc:creator>游子陈</dc:creator>
<og:description>前言 游戏开发中最复杂的模块，没有之一。其实我也不想写这篇文章，怎奈框架代码卖出去了，得给我的用户一个交代。 网络模块都需要实现哪些功能呢？按我以往的开发经验总结如下： 消息的正常发送与接收 长链接的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cgw0827/p/13233388.html</dc:identifier>
</item>
<item>
<title>MySQL函数索引及优化 - 懂点IT的耿小厨</title>
<link>http://www.cnblogs.com/gjc592/p/13233377.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gjc592/p/13233377.html</guid>
<description>&lt;p&gt;很多开发人员在使用MySQL时经常会在部分列上进行函数计算等，导致无法走索引，在数据量大的时候，查询效率低下。针对此种情况本文从MySQL5.7 及MySQL8.0中分别进行不同方式的优化。&lt;/p&gt;

&lt;p&gt;MySQL5.7版本中不支持函数索引，因此 遇到函数索引的时候需要进行修改，否则即使查询的字段上有索引，执行时也无法使用索引而进行全表扫描，数据量大的表查询时间会比较长。具体案例如下：&lt;/p&gt;
&lt;h2&gt;1.1 创建测试表及数据&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;use&lt;/span&gt;&lt;span&gt; testdb;
&lt;/span&gt;&lt;span&gt;Database&lt;/span&gt;&lt;span&gt; changed
mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;create&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;   tb_function(id &lt;span&gt;int&lt;/span&gt; &lt;span&gt;primary&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; auto_increment,name  &lt;span&gt;varchar&lt;/span&gt;(&lt;span&gt;100&lt;/span&gt;),create_time &lt;span&gt;datetime&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;  tb_function(name,creatE_time) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;anniuadaOAIFAPUHIA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-01 12:00:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.02&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;  tb_function(name,creatE_time) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;CWQSsar3qcssg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-01 15:00:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;  tb_function(name,creatE_time) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vxfqrt2adafz&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-01 21:30:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;  tb_function(name,creatE_time) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;etxzwrwbdhegqgaheqhag&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-02 01:30:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;  tb_function(name,creatE_time) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;awrs433fsgvsfwtwg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-02 03:30:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;  tb_function(name,creatE_time) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;awrs433fsgvsfwtwg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-02 07:32:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;  tb_function(name,creatE_time) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;awrs433fsgvsfwtwg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-02 10:32:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;  tb_function(name,creatE_time) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tuilklmdadq&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-02 15:32:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;  tb_function(name,creatE_time) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wesv2wqdshehq&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-02 20:32:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;  tb_function(name,creatE_time) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;89yoijnlkwr1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-03 02:56:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.00&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;  tb_function(name,creatE_time) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;olj;nsaaq&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-03 08:41:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;insert&lt;/span&gt; &lt;span&gt;into&lt;/span&gt;  tb_function(name,creatE_time) &lt;span&gt;values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ygo;jkdsaq&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-03 16:20:00&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;); 
Query OK, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt; row affected (&lt;span&gt;0.01&lt;/span&gt;&lt;span&gt; sec)

mysql&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; tb_function;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-----------------------+---------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; name                  &lt;span&gt;|&lt;/span&gt; create_time         &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-----------------------+---------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; anniuadaOAIFAPUHIA    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; CWQSsar3qcssg         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; vxfqrt2adafz          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;30&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; etxzwrwbdhegqgaheqhag &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;02&lt;/span&gt; &lt;span&gt;01&lt;/span&gt;:&lt;span&gt;30&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; awrs433fsgvsfwtwg     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;02&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;30&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; awrs433fsgvsfwtwg     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;02&lt;/span&gt; &lt;span&gt;07&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;7&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; awrs433fsgvsfwtwg     &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;02&lt;/span&gt; &lt;span&gt;10&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;8&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; tuilklmdadq           &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;02&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;9&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; wesv2wqdshehq         &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;02&lt;/span&gt; &lt;span&gt;20&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; 89yoijnlkwr1          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;56&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;11&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; olj;nsaaq             &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt; &lt;span&gt;08&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; &lt;span&gt;12&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; ygo;jkdsaq            &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;03&lt;/span&gt; &lt;span&gt;16&lt;/span&gt;:&lt;span&gt;20&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-----------------------+---------------------+&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.2  创建索引&lt;/h2&gt;
&lt;p&gt;在create_time字段上创建索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt;  &lt;span&gt;table&lt;/span&gt; tb_function &lt;span&gt;add&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;&lt;span&gt; idx_create_time(create_time);
Query OK, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.13&lt;/span&gt;&lt;span&gt; sec)
Records: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  Duplicates: &lt;span&gt;0&lt;/span&gt;  Warnings: &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.3  按时间查询&lt;/h2&gt;
&lt;p&gt;查询创建时间是2020-07-01那天的所有记录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt;  tb_function  &lt;span&gt;where&lt;/span&gt;   date(create_time)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------------------+---------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; name               &lt;span&gt;|&lt;/span&gt; create_time         &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------------------+---------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; anniuadaOAIFAPUHIA &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; CWQSsar3qcssg      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; vxfqrt2adafz       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;30&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------------------+---------------------+&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;执行计划如下&lt;/strong&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt;  tb_function  &lt;span&gt;where&lt;/span&gt;   date(create_time)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra       &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; tb_function &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;ALL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;          &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;    &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;12&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;where&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; warning (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行计划中可以看出是进行了全面扫描&lt;/p&gt;
&lt;h2&gt;1.4  优化&lt;/h2&gt;
&lt;p&gt;因MySQL5.7不支持函数索引，所以需要修改SQL写法来实现走索引（或者使用虚拟列的方式），上述SQL可以修改为&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt;  tb_function  &lt;span&gt;where&lt;/span&gt;   create_time&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; create_time&lt;span&gt;&amp;lt;&lt;/span&gt;date_add(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,INTERVAL &lt;span&gt;1&lt;/span&gt; &lt;span&gt;day&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------------------+---------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; name               &lt;span&gt;|&lt;/span&gt; create_time         &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------------------+---------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; anniuadaOAIFAPUHIA &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; CWQSsar3qcssg      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; vxfqrt2adafz       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;30&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------------------+---------------------+&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行计划如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt;  tb_function  &lt;span&gt;where&lt;/span&gt;   create_time&lt;span&gt;&amp;gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; create_time&lt;span&gt;&amp;lt;&lt;/span&gt;date_add(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,INTERVAL &lt;span&gt;1&lt;/span&gt; &lt;span&gt;day&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type  &lt;span&gt;|&lt;/span&gt; possible_keys   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;             &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra                 &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; tb_function &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; range &lt;span&gt;|&lt;/span&gt; idx_create_time &lt;span&gt;|&lt;/span&gt; idx_create_time &lt;span&gt;|&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; Using &lt;span&gt;index&lt;/span&gt; condition &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------------+------------+-------+-----------------+-----------------+---------+------+------+----------+-----------------------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; warning (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见，修改后，使用了索引。&lt;/p&gt;

&lt;p&gt;MySQL8.0的索引特性增加了函数索引。其实MySQL5.7中推出了虚拟列的功能，而MySQL8.0的函数索引也是依据虚拟列来实现的。将上述的案例在MySQL8.0中实现情况如下文所述。&lt;/p&gt;
&lt;h2&gt;2.1  创建函数索引&lt;/h2&gt;
&lt;p&gt;在将上述的表及数据在MySQL8.0的实例上创建，然后创建create_time的函数索引，SQL如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;alter&lt;/span&gt;  &lt;span&gt;table&lt;/span&gt; tb_function &lt;span&gt;add&lt;/span&gt; &lt;span&gt;key&lt;/span&gt; idx_create_time((date(create_time))); &lt;span&gt;--&lt;/span&gt;&lt;span&gt;   注意里面字段的括号&lt;/span&gt;
Query OK, &lt;span&gt;0&lt;/span&gt; rows affected (&lt;span&gt;0.10&lt;/span&gt;&lt;span&gt; sec)
Records: &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;  Duplicates: &lt;span&gt;0&lt;/span&gt;  Warnings: &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2  按时间查询&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt;  tb_function  &lt;span&gt;where&lt;/span&gt;   date(create_time)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------------------+---------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; name               &lt;span&gt;|&lt;/span&gt; create_time         &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------------------+---------------------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; anniuadaOAIFAPUHIA &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt; &lt;span&gt;12&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; CWQSsar3qcssg      &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt; &lt;span&gt;15&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; vxfqrt2adafz       &lt;span&gt;|&lt;/span&gt; &lt;span&gt;2020&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;07&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;01&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;30&lt;/span&gt;:&lt;span&gt;00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+--------------------+---------------------+&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;执行计划如下&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; explain &lt;span&gt;select&lt;/span&gt;  &lt;span&gt;*&lt;/span&gt;  &lt;span&gt;from&lt;/span&gt;  tb_function  &lt;span&gt;where&lt;/span&gt;   date(create_time)&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2020-07-01&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt; id &lt;span&gt;|&lt;/span&gt; select_type &lt;span&gt;|&lt;/span&gt; &lt;span&gt;table&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; partitions &lt;span&gt;|&lt;/span&gt; type &lt;span&gt;|&lt;/span&gt; possible_keys   &lt;span&gt;|&lt;/span&gt; &lt;span&gt;key&lt;/span&gt;             &lt;span&gt;|&lt;/span&gt; key_len &lt;span&gt;|&lt;/span&gt; ref   &lt;span&gt;|&lt;/span&gt; rows &lt;span&gt;|&lt;/span&gt; filtered &lt;span&gt;|&lt;/span&gt; Extra &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------+&lt;/span&gt;
&lt;span&gt;|&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; SIMPLE      &lt;span&gt;|&lt;/span&gt; tb_function &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; ref  &lt;span&gt;|&lt;/span&gt; idx_create_time &lt;span&gt;|&lt;/span&gt; idx_create_time &lt;span&gt;|&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;       &lt;span&gt;|&lt;/span&gt; const &lt;span&gt;|&lt;/span&gt;    &lt;span&gt;3&lt;/span&gt; &lt;span&gt;|&lt;/span&gt;   &lt;span&gt;100.00&lt;/span&gt; &lt;span&gt;|&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;  &lt;span&gt;|&lt;/span&gt;
&lt;span&gt;+&lt;/span&gt;&lt;span&gt;--&lt;/span&gt;&lt;span&gt;--+-------------+-------------+------------+------+-----------------+-----------------+---------+-------+------+----------+-------+&lt;/span&gt;
&lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt; warning (&lt;span&gt;0.00&lt;/span&gt; sec)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见，在MySQL8.0 创建对应的函数索引后，不改变SQL写法的前提下，查询的列上进行对应的函数计算后也可以走索引。&lt;/p&gt;
&lt;p&gt;关于MySQL函数索引的优化及MySQL8.0函数索引还可以有更多的场景进行测试，建议大家多动手试试，提高SQL改写及优化的能力。&lt;/p&gt;
&lt;p&gt;想了解更多内容或参与技术交流可以关注微信公众号【数据库干货铺】或进技术交流群沟通。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1318551/202004/1318551-20200425152347896-1582481254.png&quot; alt=&quot;&quot; width=&quot;490&quot; height=&quot;169&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 03 Jul 2020 16:11:00 +0000</pubDate>
<dc:creator>懂点IT的耿小厨</dc:creator>
<og:description>很多开发人员在使用MySQL时经常会在部分列上进行函数计算等，导致无法走索引，在数据量大的时候，查询效率低下。针对此种情况本文从MySQL5.7 及MySQL8.0中分别进行不同方式的优化。 1、 M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gjc592/p/13233377.html</dc:identifier>
</item>
</channel>
</rss>