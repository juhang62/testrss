<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[安卓] 20、基于蓝牙BLE的广播包高频快速搜索 - beautifulzzzz</title>
<link>http://www.cnblogs.com/zjutlitao/p/10100212.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zjutlitao/p/10100212.html</guid>
<description>&lt;h4 id=&quot;前言&quot;&gt;前言：&lt;/h4&gt;
&lt;p&gt;之前介绍过很多蓝牙beacon、搜索、连接、通讯的文章。不过最近我发现：之前写的蓝牙广播包搜索的工程，搜索频率太慢，而且不能一直保持搜索状态。因此，这里探讨下高频蓝牙广播包扫描 —— 蓝牙BLE扫描。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt;本文将从对比之前慢的和现在快的两个工程进行展开&lt;/p&gt;

&lt;h4 id=&quot;初始化-oncreate&quot;&gt;1、初始化-onCreate&lt;/h4&gt;
&lt;p&gt;新的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Get the local Bluetooth adapter
// Initializes Bluetooth adapter.
final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
mBluetoothAdapter = bluetoothManager.getAdapter();

// Ensures Bluetooth is available on the device and it is enabled. If not,
// displays a dialog requesting user permission to enable Bluetooth.
if (mBluetoothAdapter == null || !mBluetoothAdapter.isEnabled()) {
    Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
    startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;老的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Register for broadcasts when a device is discovered
IntentFilter filter = new IntentFilter(BluetoothDevice.ACTION_FOUND);
this.registerReceiver(mReceiver, filter);
// Register for broadcasts when discovery has finished
filter = new IntentFilter(BluetoothAdapter.ACTION_DISCOVERY_FINISHED);
this.registerReceiver(mReceiver, filter);

// Get the local Bluetooth adapter
mBtAdapter = BluetoothAdapter.getDefaultAdapter();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;可见：&lt;/strong&gt;老的是通过注册广播过滤条件&lt;code&gt;BluetoothDevice.ACTION_FOUND&lt;/code&gt;和&lt;code&gt;BluetoothAdapter.ACTION_DISCOVERY_FINISHED&lt;/code&gt;，来实现监听蓝牙设备扫描的发现和停止扫描事件。而mReceiver则是回调函数，接下来会介绍；新的暂时看不出啥头绪，仅仅获得&lt;code&gt;bluetoothManager&lt;/code&gt;和&lt;code&gt;mBluetoothAdapter&lt;/code&gt;，接下来会用到。&lt;/p&gt;

&lt;h4 id=&quot;开始扫描-dodiscovery&quot;&gt;2、开始扫描-doDiscovery&lt;/h4&gt;
&lt;p&gt;新的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Start device discover with the BluetoothAdapter
private void doDiscovery() {
    // If we're already discovering, stop it
    if (mBluetoothAdapter.isDiscovering()) {
        mBluetoothAdapter.stopLeScan(mLeScanCallback);
    }
    // Request discover from BluetoothAdapter
    //use filter not work!!!!!!!!!!
    //UUID[] uuid_arrays = new UUID[1];
    //uuid_arrays[0] = ParcelUuid.fromString(UUID_SERVICE).getUuid();
    //mBluetoothAdapter.startLeScan(uuid_arrays,mLeScanCallback);
    //Log.d(&quot;RSSI&quot;,uuid_arrays[0].toString() + &quot;  &quot; + UUID.randomUUID().toString());
    mBluetoothAdapter.startLeScan(mLeScanCallback);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;老的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Start device discover with the BluetoothAdapter
private void doDiscovery() {
    // If we're already discovering, stop it
    if (mBtAdapter.isDiscovering()) {
        mBtAdapter.cancelDiscovery();
    }
    // Request discover from BluetoothAdapter
    mBtAdapter.startDiscovery();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;可见：&lt;/strong&gt;区别在于一个是BLE操作、一个是普通蓝牙操作。&lt;/p&gt;

&lt;h4 id=&quot;监听&quot;&gt;3、监听&lt;/h4&gt;
&lt;p&gt;新的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Device scan callback.
private BluetoothAdapter.LeScanCallback mLeScanCallback =
    new BluetoothAdapter.LeScanCallback() {
        @Override
        public void onLeScan(final BluetoothDevice device, int rssi,
            byte[] scanRecord) {
                runOnUiThread(new Runnable() {
                    @Override
            public void run() {
                if(device_filter(device)){
                    //mDevicesNameVector.add(device.getName());
                    //mDevicesAddrVector.add(device.getAddress());
                    //mRSSIVector.add((short)rssi);
                    Log.d(&quot;RSSI&quot;,device.getAddress() + &quot; &quot; + device.getName() + &quot; &quot; + String.valueOf(rssi));
                    ...
                }
            }
        });
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;老的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// The BroadcastReceiver that listens for discovered devices and
// changes the title when discovery is finished
//【查找蓝牙设备】
private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
    @Override
    public void onReceive(Context context, Intent intent) {
        Log.d(&quot;onReceive&quot;,&quot;OK&quot;);
        String action = intent.getAction();
        // When discovery finds a device
        if (BluetoothDevice.ACTION_FOUND.equals(action)) {
            // Get the BluetoothDevice object from the Intent
            BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
            mDevicesNameVector.add(device.getName());
            mDevicesAddrVector.add(device.getAddress());
            short rssi = intent.getExtras().getShort(BluetoothDevice.EXTRA_RSSI);
            mRSSIVector.add(rssi);
            Log.d(&quot;RSSI&quot;,device.getName()+&quot;  &quot;+String.valueOf(rssi));
            // When discovery is finished, change the Activity title
        } else if (BluetoothAdapter.ACTION_DISCOVERY_FINISHED.equals(action)) {
            setProgressBarIndeterminateVisibility(false);
            if (mDevicesNameVector.size() != 0) {
                Message msg = new Message();//消息
                Bundle bundle = new Bundle();
                bundle.clear();Log.d(&quot;onReceive&quot;,&quot;1&quot;);
                msg.what = 0x01;//消息类别
                bundle.putShort(&quot;msg&quot;,(short) 0);Log.d(&quot;onReceive&quot;,&quot;2&quot;);
                    msg.setData(bundle);Log.d(&quot;onReceive&quot;,&quot;3&quot;);
                    myHandler.sendMessage(msg);Log.d(&quot;onReceive&quot;,&quot;4&quot;);
            }
        }
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;可见：&lt;/strong&gt;新的相对比较简单、可以持续不断的扫描获取（同一个设备会被不断的扫描到）；老的则分为两步：第一步是每次扫描到一次新设备都会有一个FOUND事件、最后停止扫描了还有个FINISH事件，这里我在FINISH事件结束时发出一个msg来通知进行其他操作。&lt;/p&gt;

&lt;h4 id=&quot;权限文件配置&quot;&gt;4、权限文件配置&lt;/h4&gt;
&lt;p&gt;新的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;uses-permission a:name=&quot;android.permission.ACCESS_FINE_LOCATION&quot;/&amp;gt;
&amp;lt;uses-permission a:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot;/&amp;gt;
&amp;lt;uses-permission a:name=&quot;android.permission.BLUETOOTH&quot;/&amp;gt;
&amp;lt;uses-permission a:name=&quot;android.permission.BLUETOOTH_ADMIN&quot;/&amp;gt;
&amp;lt;uses-feature a:name=&quot;android.hardware.bluetooth_le&quot; a:required=&quot;true&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;老的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;uses-permission a:name=&quot;android.permission.BLUETOOTH&quot; /&amp;gt;
&amp;lt;uses-permission a:name=&quot;android.permission.BLUETOOTH_ADMIN&quot; /&amp;gt;
&amp;lt;uses-permission a:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;可见：&lt;/strong&gt;相差不大，新的比老的多了bluetooth_le说明。&lt;/p&gt;

&lt;h4 id=&quot;最后说明&quot;&gt;5、最后说明&lt;/h4&gt;
&lt;p&gt;当你尝试使用BLE SCAN之后，你会感觉有一种飞一般的感觉，几乎同一个设备每一秒都会被扫描到多次。拿这些高频扫描的大量数据，就可以做类似beacon、距离估算、定位等小应用了！效果会比老的scan方法要好很多～&lt;/p&gt;

&lt;h3 id=&quot;links&quot;&gt;LINKS&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nbtool/android_app_linux_tool&quot;&gt;[1]. 本项目GITHUB链接地址&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/zjutlitao/p/9672376.html&quot;&gt;[2]. 在Linux下搭建安卓APP的开发烧写环境（makefile版）—— 在Linux上用命令行+VIM开发安卓APP&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.android.com/reference/android/widget/TextView&quot;&gt;[3]. android developer TextView&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.android.com/reference/java/util/Vector&quot;&gt;[4]. android developer Vector&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.android.com/reference/java/lang/String&quot;&gt;[5]. android developer String&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.android.com/reference/java/util/Formatter&quot;&gt;[6]. android developer Formatter&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.android.com/reference/java/util/regex/Matcher&quot;&gt;[7]. android developer Matcher&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.android.com/reference/java/util/regex/Pattern&quot;&gt;[8]. android developer Pattern&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/legend12300/article/details/69875816&quot;&gt;[9]. 等宽字体-Android 设置字体的三种方法（TypeFace）&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/whu_zhangmin/article/details/29808339&quot;&gt;[10]. Android 设置TextView滑动滚动条和滑动效果&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;@beautifulzzzz
智能硬件、物联网，热爱技术，关注产品
博客：http://blog.beautifulzzzz.com
园友交流群：414948975&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 10 Dec 2018 18:13:00 +0000</pubDate>
<dc:creator>beautifulzzzz</dc:creator>
<og:description>前言： 之前介绍过很多蓝牙beacon、搜索、连接、通讯的文章。不过最近我发现：之前写的蓝牙广播包搜索的工程，搜索频率太慢，而且不能一直保持搜索状态。因此，这里探讨下高频蓝牙广播包扫描 —— 蓝牙BL</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zjutlitao/p/10100212.html</dc:identifier>
</item>
<item>
<title>netty源码解解析(4.0)-6 线程模型-IO线程EventLoopGroup和NIO实现(一) - 自带buff</title>
<link>http://www.cnblogs.com/brandonli/p/10100139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brandonli/p/10100139.html</guid>
<description>&lt;p&gt;&lt;span&gt;接口定义&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;io.netty.channel.EventLoopGroup extends EventExecutorGroup&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;3741-1543222893814-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3741-1543222893814-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td data-cell-id=&quot;3741-1543222893814-cell-1-0&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;ChannelFuture register(Channel channel)&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3741-1543222893814-cell-1-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;把一个channel注册到一个EventLoop&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td data-cell-id=&quot;3741-1543222893814-cell-2-0&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;ChannelFuture register(Channel channel, ChannelPromise promise);&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;3741-1543222893814-cell-2-1&quot;&gt;
&lt;p&gt;&lt;span&gt;同上&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;io.netty.channel.EventLoop extends OrderedEventExecutor, EventLoopGroup&lt;/p&gt;
&lt;div&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col/&gt;&lt;col/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td data-cell-id=&quot;2082-1543222893814-cell-0-0&quot;&gt;
&lt;p&gt;&lt;span&gt;方法&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;2082-1543222893814-cell-0-1&quot;&gt;
&lt;p&gt;&lt;span&gt;说明&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td data-cell-id=&quot;2082-1543222893814-cell-1-0&quot;&gt;
&lt;p&gt;&lt;span&gt;EventLoopGroup parent()&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td data-cell-id=&quot;2082-1543222893814-cell-1-1&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;得到创建这个eventLoop的EventLoopGroup&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;EventLoopGroup定义的主要方法是register, 这个方法的语义是把channel和eventLoop绑定在一起。一个channel对应一个eventLoop, 一个eventLoop会持有多个channel。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;I/O线程EventLoopGroup的抽象实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;io.netty.channel.MultithreadEventLoopGroup extends MultithreadEventExecutorGroup implements EventLoopGroup&lt;/p&gt;
&lt;p&gt;io.netty.channel.SingleThreadEventLoop extends SingleThreadEventExecutor implements EventLoop&lt;/p&gt;
&lt;p&gt;两个类主功能都是实现了EventLoopGroup定义的register方法&lt;/p&gt;
&lt;p&gt;MultithreadEventLoopGroup&lt;/p&gt;
&lt;p&gt;public ChannelFuture register(Channel channel) {&lt;/p&gt;
&lt;p&gt;return next().register(channel);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;public ChannelFuture register(Channel channel, ChannelPromise promise) {&lt;/p&gt;
&lt;p&gt;return next().register(channel, promise);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;SingleThreadEventLoop&lt;/p&gt;
&lt;p&gt;public ChannelFuture register(Channel channel) {&lt;/p&gt;
&lt;p&gt;return register(channel, new DefaultChannelPromise(channel, this));&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;public ChannelFuture register(final Channel channel, final ChannelPromise promise) {&lt;/p&gt;
&lt;p&gt;channel.unsafe().register(this, promise);&lt;/p&gt;
&lt;p&gt;return promise;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;register的实现主要是为了调用Channel.Unsafe实例的register方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;NIO实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;io.netty.channel.nio.NioEventLoopGroup extends MultithreadEventLoopGroup&lt;/p&gt;
&lt;p&gt;io.netty.channel.nio.NioEventLoop extends SingleThreadEventLoop&lt;/p&gt;
&lt;p&gt;NioEventLoopGroup是在MultithreadEventLoopGroup基础上实现了对JDK NIO Selector的封装, 它实现以下几个功能:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建selector&lt;/li&gt;
&lt;li&gt;在selector上注册channel感兴趣的NIO事件&lt;/li&gt;
&lt;li&gt;实现EventExecutor的run方法，定义NIO事件和Executor任务的处理流程。&lt;/li&gt;
&lt;li&gt;把NIO事件转换成对channel unsafe的调用或NioTask的调用&lt;/li&gt;
&lt;li&gt;控制线程执行I/O操作和排队任务的用时比例&lt;/li&gt;
&lt;li&gt;处理epoll selector cpu 100%的bug&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面来具体分析这几个功能的实现。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;创建Selector&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;NioEventLoop#openSelector()实现了创建selector的功能，默认情况下，使用SelectorProvider#openSelector()方法创建一个新个selector:&lt;/p&gt;
&lt;p&gt;final Selector unwrappedSelector = provider.openSelector();&lt;/p&gt;
&lt;p&gt;如果设置环境变量io.netty.noKeySetOptimization=true, 会创建一个selectedKeySet = new SelectedSelectionKeySet(), 然后使用java的反射机制把selector的selectedKeys和publicSelectedKeys替换成selectedKeySet，具体步骤是:&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.得到selector的真正类型: sun.nio.ch.SelectorImpl&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Object maybeSelectorImplClass = AccessController.doPrivileged(new PrivilegedAction&amp;lt;Object&amp;gt;() {&lt;/p&gt;
&lt;p&gt;@Override&lt;/p&gt;
&lt;p&gt;public Object run() {&lt;/p&gt;
&lt;p&gt;try {&lt;/p&gt;
&lt;p&gt;return Class.forName(&lt;/p&gt;
&lt;p&gt;&quot;&lt;span&gt;sun.nio.ch.SelectorImpl&lt;/span&gt;&quot;,&lt;/p&gt;
&lt;p&gt;false,&lt;/p&gt;
&lt;p&gt;PlatformDependent.getSystemClassLoader());&lt;/p&gt;
&lt;p&gt;} catch (Throwable cause) {&lt;/p&gt;
&lt;p&gt;return cause;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;});&lt;/p&gt;
&lt;p&gt;final Class&amp;lt;?&amp;gt; selectorImplClass = (Class&amp;lt;?&amp;gt;) maybeSelectorImplClass;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.替换selector是属性unwrappedSelector&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Field selectedKeysField = selectorImplClass.getDeclaredField(&quot;&lt;span&gt;selectedKeys&lt;/span&gt;&quot;);&lt;/p&gt;
&lt;p&gt;Field publicSelectedKeysField = selectorImplClass.getDeclaredField(&quot;&lt;span&gt;publicSelectedKeys&lt;/span&gt;&quot;);&lt;/p&gt;
&lt;p&gt;selectedKeysField.set(unwrappedSelector, selectedKeySet);&lt;/p&gt;
&lt;p&gt;publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);&lt;/p&gt;
&lt;p&gt;之所以会设计一个这样的优化选项，是因为一般情况下调用完selector的select或selectNow方法后需要调用Selector#selectedKeys()得到触发NIO事件的的SelectableChannel，这样优化之后，可以直接从selectedKeySet中得到已经触发了NIO事件的SelectableChannel。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;在selector上注册channel感兴趣的NIO事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;NioEventLoop提供了unwrappedSelector方法，这个方法返回了它创建好的Selector实例。这样任何的外部类都可以把任意的SelectableChannel注册到这selector上。在AbstractNioChannel中， doRegister方法的实现就是使用了这个方法:&lt;/p&gt;
&lt;p&gt;selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);&lt;/p&gt;
&lt;p&gt;另外，它还提供了一个register方法:&lt;/p&gt;
&lt;p&gt;public void register(final SelectableChannel ch, final int interestOps, final NioTask&amp;lt;?&amp;gt; task)&lt;/p&gt;
&lt;p&gt;这个方法会把task当成SelectableChannel的附件注册到selector上:&lt;/p&gt;
&lt;p&gt;ch.register(selector, interestOps, task);&lt;/p&gt;


&lt;p&gt;&lt;span&gt;实现EventExecutor的run方法，定义NIO事件和Executor任务的处理流程&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在NioEventLoop的run方法中实现NIO事件和EventExecutor的任务处理逻辑，这个run方法在io.netty.util.concurrent.SingleThreadEventExecutor中定义。在上一章中，我们看到了DefaultEventExecutor中是如何实现这个run方法的，这里我们将要看到这run方法的另一个实现。和SingleThreadEventExecutor中的run方法相比，NioEventLoop的run方法不仅要及时地执行taskQueue中的任务，还要能及时地处理NIO事件，因此它会同时检查selector中的NIO事件和和taskQueue队列，任何一个中有事件需要处理或有任务需要执行，它不会阻塞线程。同时它也保证了在没有NIO事件和任务的情况下线程不会无谓的空转浪费CUP资源。&lt;/p&gt;
&lt;p&gt;run主要实现如下，为了更清晰的说明它的主要功能，我对原来的代码进行了一些删减。&lt;/p&gt;
&lt;p&gt;for(;;){&lt;/p&gt;
&lt;p&gt;try{&lt;/p&gt;
&lt;p&gt;/&lt;span&gt;/phase1: 同时检查NIO事件和任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {&lt;/p&gt;
&lt;p&gt;case SelectStrategy.CONTINUE:&lt;/p&gt;
&lt;p&gt;continue;&lt;/p&gt;
&lt;p&gt;case SelectStrategy.SELECT:&lt;/p&gt;
&lt;p&gt;select(wakenUp.getAndSet(false)); //&lt;span&gt;在taskQueue中没有任务的时候执行select&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;//&lt;span&gt;phase2: 进入处理NIO事件，执行executor任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;try{&lt;/p&gt;
&lt;p&gt;//&lt;span&gt;处理NIO事件&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;processSelectedKeys();&lt;/p&gt;
&lt;p&gt;}finally{&lt;/p&gt;
&lt;p&gt;//&lt;span&gt;处理taskQueu中的任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;runAllTasks();&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}catch(Throwable t){&lt;/p&gt;
&lt;p&gt;handleLoopException(t);&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;run方法有两个阶段构成：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;phase1: 检查NIO事件或executor任务，如果有任何的NIO事件或executor任务进入phase2。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这样阶段的主要工作在selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())和select中完成。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;selectStrategy.calculateStrategy实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())&lt;/p&gt;
&lt;p&gt;这行代码的含义是: 如果hasTasks() == true, 调用以下selector#selectNow, 然后进入phase2。 否则调用select。这里使用了strategy模式，默认的strategy实现是io.netty.channe.DefaultSelectStrategy implements SelectStrategy&lt;/p&gt;
&lt;p&gt;@Override&lt;/p&gt;
&lt;p&gt;public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception {&lt;/p&gt;
&lt;p&gt;return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;DefaultSelectStrategy实现了SelectStrategy接口，这接口定义了两个常量:&lt;/p&gt;
&lt;p&gt;int SELECT = -1;&lt;/p&gt;
&lt;p&gt;int CONTINUE = -2;&lt;/p&gt;
&lt;p&gt;运行时selectSuppler参数传入的是selectNowSupplier, 它的实现如下：&lt;/p&gt;
&lt;p&gt;private final IntSupplier selectNowSupplier = new IntSupplier() {&lt;/p&gt;
&lt;p&gt;@Override&lt;/p&gt;
&lt;p&gt;public int get() throws Exception {&lt;/p&gt;
&lt;p&gt;return selectNow();&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;};&lt;/p&gt;
&lt;p&gt;这里的get方法调用了selectNow, selectNow调用的是Selector#selectNew方法，这个方法的返回值是&amp;gt;=0。&lt;/p&gt;
&lt;p&gt;hashTasks的传入的参数是hasTask()的返回值: return !taskQueue.isEmpty();&lt;/p&gt;
&lt;p&gt;代码读到这里就会发现，使用默认的的SelectStrategy实现，calculateStrategy在hasTasks()==true时返回值&amp;gt;=0, hasTasks() == false时返回值是SelectStrategy.SELECT，不会返回SelectStrategy.CONTINUE。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;select实现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;select的执行逻辑是:&lt;/p&gt;
&lt;p&gt;1. 计算超select方法的结束时间selectDeadLineNanos&lt;/p&gt;
&lt;p&gt;long currentTimeNanos = System.nanoTime();&lt;/p&gt;
&lt;p&gt;long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);&lt;/p&gt;
&lt;p&gt;2. 进入循环，检查超时--超时跳出循环。&lt;/p&gt;
&lt;p&gt;long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;&lt;/p&gt;
&lt;p&gt;if (timeoutMillis &amp;lt;= 0) {&lt;/p&gt;
&lt;p&gt;if (selectCnt == 0) {&lt;/p&gt;
&lt;p&gt;selector.selectNow();&lt;/p&gt;
&lt;p&gt;selectCnt = 1;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;break;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;3. 如果在select执行过程中有executor任务提交或可以当前的wakeUp由false变成true, 跳出循环&lt;/p&gt;
&lt;p&gt;if (hasTasks() &amp;amp;&amp;amp; wakenUp.compareAndSet(false, true)) {&lt;/p&gt;
&lt;p&gt;selector.selectNow();&lt;/p&gt;
&lt;p&gt;selectCnt = 1;&lt;/p&gt;
&lt;p&gt;break;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;4. 调用selector#select等待NIO事件。&lt;/p&gt;
&lt;p&gt;int selectedKeys = selector.select(timeoutMillis);&lt;/p&gt;
&lt;p&gt;selectCnt ++;&lt;/p&gt;
&lt;p&gt;5. 如果满足这些条件的任何一个，跳出循环: 有NIO事件、wakeUp的新旧值都是true、taskQueue中有任务、有定时任务到期。&lt;/p&gt;
&lt;p&gt;if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {&lt;/p&gt;
&lt;p&gt;break;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;6. 如果线程被中断，跳出循环。&lt;/p&gt;
&lt;p&gt;if (Thread.interrupted()) {&lt;/p&gt;
&lt;p&gt;break;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;7. 如果selector.select超时，没有检查到任何NIO事件, 会在下次循环开始时跳出循环。 如果每次超时，跳到第2步继续下一次循环。&lt;/p&gt;
&lt;p&gt;long time = System.nanoTime();&lt;/p&gt;
&lt;p&gt;if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &amp;gt;= currentTimeNanos) {&lt;/p&gt;
&lt;p&gt;selectCnt = 1;&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;currentTimeNanos = time;&lt;/p&gt;

&lt;p&gt;select 最迟会在当前时间&amp;gt;= selectDeadLineNanos时返回，这个时间是最近一个到期的定时任务执行的时间，换言之如果没有任何的NIO事件或executor任务，select会在定时任务到期时返回。如果没有定时任务，delayNanos(currentTimeNanos)返回的值是 TimeUnit.SECONDS.toNanos(1)，即1秒。 select会在检查到任何NIO事件或executor任务时返回，为了保证这点，在selector.select(timeoutMillis)前后都会调用hasTasks检查executor任务，为了能在调用executet提交任务时唤醒selector.select，NioEventLoop覆盖了SingleThreadEventExecutor的wake方法:&lt;/p&gt;
&lt;p&gt;protected void wakeup(boolean inEventLoop) {&lt;/p&gt;
&lt;p&gt;if (!inEventLoop &amp;amp;&amp;amp; wakenUp.compareAndSet(false, true)) {&lt;/p&gt;
&lt;p&gt;selector.wakeup();&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;这个方法会及时的唤醒selector.select, 保证新提交的任务可以得到及时的执行。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;phase2: 进入处理NIO事件，执行executor任务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个阶段是先调用processSelectedKeys()处理NIO事件，然后掉用 runAllTasks()处理所有已经到期的定时任务和已经在排队的任务。这个阶段还实现了NIO事件和executor任务的用时比例管理，这个特性稍后会详细分析。&lt;/p&gt;

</description>
<pubDate>Mon, 10 Dec 2018 16:45:00 +0000</pubDate>
<dc:creator>自带buff</dc:creator>
<og:description>接口定义 io.netty.channel.EventLoopGroup extends EventExecutorGroup 方法 说明 ChannelFuture register(Channel</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brandonli/p/10100139.html</dc:identifier>
</item>
<item>
<title>消息队列中间件（二）使用 ActiveMQ - 雪漫士兵</title>
<link>http://www.cnblogs.com/niumoo/p/10099942.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/10099942.html</guid>
<description>&lt;h2 id=&quot;activemq-介绍&quot;&gt;ActiveMQ 介绍&lt;/h2&gt;
&lt;p&gt;Active MQ 是由 Apache 出品的一款流行的功能强大的开源消息中间件，它速度快，支持跨语言的客户端，具有易于使用的企业集成模式和许多的高级功能，同时完全支持 &lt;a href=&quot;https://www.oracle.com/technetwork/java/jms/index.html&quot;&gt;JSM1.1&lt;/a&gt; 和 J2EE1.4 。&lt;/p&gt;
&lt;h2 id=&quot;activemq-特点&quot;&gt;ActiveMQ 特点&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;支持Java，C，C ++，C＃，Ruby，Perl，Python，PHP等各种跨语言客户端和协议，如 OpenWire , Stomp , AMQP , MQTT.&lt;/li&gt;
&lt;li&gt;完全支持JMS 1.1和 J2EE 1.4，支持瞬态，持久，事务和XA消息传递。&lt;/li&gt;
&lt;li&gt;对 Spring 框架的支持以便ActiveMQ可以轻松嵌入到Spring应用程序中。&lt;/li&gt;
&lt;li&gt;通过了常见的 J2EE 服务器测试，如 TomEE，Geronimo，JBoss，GlassFish 和 WebLogic 。&lt;/li&gt;
&lt;li&gt;连接方式的多样化，ActiveMQ 提供了多种连接模式，例如 in-VM、TCP、SSL、NIO、UDP、多播、JGroups、JXTA。&lt;/li&gt;
&lt;li&gt;可以通过使用 JDBC 和 journal 实现消息的快速持久化。&lt;/li&gt;
&lt;li&gt;专为高性能群集，客户端 - 服务器，点对点通信而设计。&lt;/li&gt;
&lt;li&gt;提供与语言无关的 REST API。&lt;/li&gt;
&lt;li&gt;支持 Ajax 方式调用 ActiveMQ。&lt;/li&gt;
&lt;li&gt;ActiveMQ 可以轻松地与 CXF、Axis 等 Web Service 技术整合，以提供可靠的消息传递。&lt;/li&gt;
&lt;li&gt;可用作为内存中的 JMS 提供者，非常适合 JMS 单元测试。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;activemq-消息&quot;&gt;ActiveMQ 消息&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;点对点队列模式&lt;br/&gt;消息到达消息系统，被保留在消息队列中，然后由一个或者多个消费者消费队列中的消息，一个消息只能被一个消费者消费，然后就会被移除。例如订单处理系统。&lt;/li&gt;
&lt;li&gt;发布-订阅模式&lt;br/&gt;消息发送时指定主题（或者说通道），消息被保留在指定的主题中，消费者可以订阅多个主题，并使用主题中的所有的消息，例如现实中的电视与电视频道。所有客户端包括发布者和订阅者，主题中的消息可以被所有的订阅者消费，消费者只能消费订阅之后发送到主题中的消息。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;activemq-概念&quot;&gt;ActiveMQ 概念&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Broker，消息代理，表示消息队列服务器实体，接受客户端连接，提供消息通信的核心服务。&lt;/li&gt;
&lt;li&gt;Producer，消息生产者，业务的发起方，负责生产消息并传输给 Broker 。&lt;/li&gt;
&lt;li&gt;Consumer，消息消费者，业务的处理方，负责从 Broker 获取消息并进行业务逻辑处理。&lt;/li&gt;
&lt;li&gt;Topic，主题，发布订阅模式下的消息统一汇集地，不同生产者向 Topic 发送消息，由 Broker 分发到不同的订阅者，实现消息的广播。&lt;/li&gt;
&lt;li&gt;Queue，队列，点对点模式下特定生产者向特定队列发送消息，消费者订阅特定队列接收消息并进行业务逻辑处理。&lt;/li&gt;
&lt;li&gt;Message，消息体，根据不同通信协议定义的固定格式进行编码的数据包，来封装业务 数据，实现消息的传输。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;activemq-工程实例&quot;&gt;ActiveMQ 工程实例&lt;/h2&gt;
&lt;p&gt;下面是使用 ActiveMQ 的队列模式和发布-订阅模式的 Java 代码示例。&lt;/p&gt;
&lt;h3 id=&quot;pom-依赖&quot;&gt;POM 依赖&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;        &amp;lt;!-- Active-MQ --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;activemq-all&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.15.5&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;队列模式消费者&quot;&gt;队列模式消费者&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.apache.activemq.ActiveMQConnectionFactory;
import javax.jms.*;

/**
 * &amp;lt;p&amp;gt;
 * 消息消费者，用于消费消息
 *
 * @Author niujinpeng
 * @Date 2018/9/4 23:45
 */
public class AppConsumer {

    private static final String url = &quot;tcp://127.0.0.1:61616&quot;;
    private static final String queueName = &quot;queue-test&quot;;

    public static void main(String[] args) throws JMSException {
        // 1.创建ConnectionFactory
        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory();
        // 2.创建Connection
        Connection connection = connectionFactory.createConnection();
        // 3.启动连接
        connection.start();

        // 4.创建会话,false，不使用事务，自动应答模式
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        // 5.创建一个目标
        Destination destination = session.createQueue(queueName);
        // 6.创建消费者
        MessageConsumer consumer = session.createConsumer(destination);

        // 7.创建一个监听器
        consumer.setMessageListener(new MessageListener() {
            public void onMessage(Message message) {
                TextMessage textMessage = (TextMessage) message;
                try {
                    System.out.println(&quot;接收消息：&quot; + textMessage.getText());
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        });

        // 8.关闭连接
        //connection.close();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;队列模式生产者&quot;&gt;队列模式生产者&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.apache.activemq.ActiveMQConnectionFactory;
import javax.jms.*;

/**
 * &amp;lt;p&amp;gt;
 * 消息提供者，用于向消息中间件发送消息
 *
 * @Author niujinpeng
 * @Date 2018/9/4 23:28
 */
public class AppProducer {

    private static final String url = &quot;tcp://127.0.0.1:61616&quot;;
    private static final String queueName = &quot;queue-test&quot;;

    public static void main(String[] args) throws JMSException {
        // 1.创建ConnectionFactory
        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory();
        // 2.创建Connection
        Connection connection = connectionFactory.createConnection();
        // 3.启动连接
        connection.start();

        // 4.创建会话,false，不使用事务，自动应答模式
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        // 5.创建一个目标
        Destination destination = session.createQueue(queueName);
        // 6.创建生产者
        MessageProducer producer = session.createProducer(destination);

        // 7.创建消息并发送
        for (int i = 0; i &amp;lt; 10; i++) {
            // 创建消息
            TextMessage textMessage = session.createTextMessage(&quot;textMessage&quot; + i);
            // 发布消息
            producer.send(textMessage);
            System.out.println(&quot;发送消息：&quot; + textMessage.getText());
        }

        // 8.关闭连接
        connection.close();

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;发布订阅模式生产者&quot;&gt;发布订阅模式生产者&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.apache.activemq.ActiveMQConnectionFactory;
import javax.jms.*;

/**
 * &amp;lt;p&amp;gt;
 * 主题模式
 * 消息消费者，用于消费消息
 *
 * @Author niujinpeng
 * @Date 2018/9/4 23:45
 */
public class AppConsumer {

    private static final String url = &quot;tcp://127.0.0.1:61616&quot;;
    private static final String topicName = &quot;topic-test&quot;;

    public static void main(String[] args) throws JMSException {
        // 1.创建ConnectionFactory
        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory();
        // 2.创建Connection
        Connection connection = connectionFactory.createConnection();
        // 3.启动连接
        connection.start();

        // 4.创建会话,false，不使用事务，自动应答模式
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        // 5.创建一个目标
        Destination destination = session.createTopic(topicName);
        // 6.创建消费者
        MessageConsumer consumer = session.createConsumer(destination);

        // 7.创建一个监听器
        consumer.setMessageListener(new MessageListener() {
            public void onMessage(Message message) {
                TextMessage textMessage = (TextMessage) message;
                try {
                    System.out.println(&quot;接收消息：&quot; + textMessage.getText());
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        });

        // 8.关闭连接
        //connection.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;发布订阅模式生产者-1&quot;&gt;发布订阅模式生产者&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.apache.activemq.ActiveMQConnectionFactory;
import javax.jms.*;

/**
 * &amp;lt;p&amp;gt;
 * 主题模式
 * 消息提供者，用于向消息中间件发送消息
 *
 * @Author niujinpeng
 * @Date 2018/9/4 23:28
 */
public class AppProducer {

    private static final String url = &quot;tcp://127.0.0.1:61616&quot;;
    private static final String topicName = &quot;topic-test&quot;;

    public static void main(String[] args) throws JMSException {
        // 1.创建ConnectionFactory
        ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory();
        // 2.创建Connection
        Connection connection = connectionFactory.createConnection();
        // 3.启动连接
        connection.start();

        // 4.创建会话,false，不使用事务，自动应答模式
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        // 5.创建一个目标
        Destination destination = session.createTopic(topicName);
        // 6.创建生产者
        MessageProducer producer = session.createProducer(destination);

        // 7.创建消息并发送
        for (int i = 0; i &amp;lt; 10; i++) {
            // 创建消息
            TextMessage textMessage = session.createTextMessage(&quot;textMessage&quot; + i);
            // 发布消息
            producer.send(textMessage);
            System.out.println(&quot;发送消息：&quot; + textMessage.getText());
        }

        // 8.关闭连接
        connection.close();

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;GitHub源码：&lt;/strong&gt;&lt;a href=&quot;https://github.com/niumoo/message-queue/tree/master/mq-activemq&quot;&gt;https://github.com/niumoo/message-queue&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;spring-整合-activemq&quot;&gt;Spring 整合 ActiveMQ&lt;/h2&gt;
&lt;p&gt;在 Spring 中配置 Active MQ 就像Spring 整合其他功能一样，我们需要在 XML 配置中配置几个关键的实例即可。在 Active MQ 中有几个对象的实例是至关重要的，如 Active MQ jms 连接工厂，为了减少连接断开性能时间消耗的 jms 连接池以及生产者消费者等。&lt;/p&gt;
&lt;p&gt;下面是一些详细说明。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConnectionFactory 用于管理连接的连接工厂（Spring提供）。
&lt;ul&gt;&lt;li&gt;一个 Spring 为我们提供的连接池。&lt;/li&gt;
&lt;li&gt;JmsTemplate 每次发送都会重新创建连接，会话和 Productor。&lt;/li&gt;
&lt;li&gt;Spring 中提供了SingleConnectionFactory 和CachingConnectionFactory（增加了缓存功能）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;JmsTemplate 是用于发送和接收消息的模板类。
&lt;ul&gt;&lt;li&gt;是spring提供的，只需要向Spring 容器内注册这个类就可以使用 JmsTemplate 方便的操作jms。&lt;/li&gt;
&lt;li&gt;JmsTemplate 类是线程安全的，可以在整个应用范围使用。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;MessageListerner 消息监听器
&lt;ul&gt;&lt;li&gt;使用一个onMessage方法，该方法只接收一个Message参数。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;pom-依赖-1&quot;&gt;POM 依赖&lt;/h3&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;properties&amp;gt;
        &amp;lt;spring.version&amp;gt;5.0.4.RELEASE&amp;lt;/spring.version&amp;gt;
    &amp;lt;/properties&amp;gt;
    &amp;lt;dependencies&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.11&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-jms&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.1.1.RELEASE&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-test&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;${spring.version}&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;!-- 这个版本的Spring需要使用JMS 2.0版本，但spring-jms的依赖没有自动导入JMS 2.0，而activemq-core会导入JMS 1.1的依赖 --&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;javax.jms&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;javax.jms-api&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;2.0.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.apache.activemq&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;activemq-core&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.7.0&amp;lt;/version&amp;gt;
            &amp;lt;exclusions&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;artifactId&amp;gt;spring-context&amp;lt;/artifactId&amp;gt;
                    &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
                &amp;lt;exclusion&amp;gt;
                    &amp;lt;groupId&amp;gt;org.apache.geronimo.specs&amp;lt;/groupId&amp;gt;
                    &amp;lt;artifactId&amp;gt;geronimo-jms_1.1_spec&amp;lt;/artifactId&amp;gt;
                &amp;lt;/exclusion&amp;gt;
            &amp;lt;/exclusions&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;xml-配置&quot;&gt;XML 配置&lt;/h3&gt;
&lt;h4 id=&quot;xml-公共配置&quot;&gt;XML 公共配置&lt;/h4&gt;
&lt;p&gt;为了份文件配置方便管理，下面是提取出来的公共配置，为了在独立配置生产者和消费者 XML文件时引入，当然也可以直接把生产者和消费者以及所有的 XML bean 配置在一个文件里。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:content=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;

    &amp;lt;content:annotation-config/&amp;gt;

    &amp;lt;!-- ActiveMQ为我们提供的connection factory --&amp;gt;
    &amp;lt;bean id=&quot;targerConnectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&amp;gt;
        &amp;lt;property name=&quot;brokerURL&quot; value=&quot;tcp://127.0.0.1:61616&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- spring jms为我们提供的连接池 --&amp;gt;
    &amp;lt;bean id=&quot;connectionFactory&quot; class=&quot;org.springframework.jms.connection.SingleConnectionFactory&quot;&amp;gt;
        &amp;lt;property name=&quot;targetConnectionFactory&quot; ref=&quot;targerConnectionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 一个队列模式目的地（队列名称），点对点的消息模式 --&amp;gt;
    &amp;lt;bean id=&quot;queueDestination&quot; class=&quot;org.apache.activemq.command.ActiveMQQueue&quot;&amp;gt;
        &amp;lt;constructor-arg value=&quot;queue-spring&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!-- 一个主题模式目的地（主题名称），发布订阅消息模式 --&amp;gt;
    &amp;lt;bean id=&quot;topicDestination&quot; class=&quot;org.apache.activemq.command.ActiveMQTopic&quot;&amp;gt;
        &amp;lt;constructor-arg value=&quot;topic-spring&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;xml-消费者&quot;&gt;XML 消费者&lt;/h4&gt;
&lt;p&gt;消费者主要是一个消息监听器，监听指定的队列或者主题的消息信息，来有消息时调用回调监听处理方法。这里我注释掉了监听的队列模式，指定了主题模式。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:content=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;

    &amp;lt;!-- 导入公共配置 --&amp;gt;
    &amp;lt;import resource=&quot;common.xml&quot;/&amp;gt;

    &amp;lt;!-- 配置消息监听器 --&amp;gt;
    &amp;lt;bean id=&quot;consumerMessageListener&quot; class=&quot;net.codingme.jms.consumer.ConsumerMessageListener&quot;/&amp;gt;

    &amp;lt;!-- 配置消息监听容器 --&amp;gt;
    &amp;lt;bean id=&quot;jmsContainer&quot; class=&quot;org.springframework.jms.listener.DefaultMessageListenerContainer&quot;&amp;gt;
        &amp;lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&amp;gt;
        &amp;lt;!-- 队列模式 --&amp;gt;
        &amp;lt;!--&amp;lt;property name=&quot;destination&quot; ref=&quot;queueDestination&quot;/&amp;gt;--&amp;gt;
        &amp;lt;!-- 主题模式 --&amp;gt;
        &amp;lt;property name=&quot;destination&quot; ref=&quot;topicDestination&quot;/&amp;gt;
        &amp;lt;property name=&quot;messageListener&quot; ref=&quot;consumerMessageListener&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;xml-生产者&quot;&gt;XML 生产者&lt;/h4&gt;
&lt;p&gt;生成者的配置主要是使用 spring jms 模版对象，创建生产者实例用于生产消息。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:content=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;

    &amp;lt;!-- 导入公共配置 --&amp;gt;
    &amp;lt;import resource=&quot;common.xml&quot;/&amp;gt;

    &amp;lt;!-- jms模版--&amp;gt;
    &amp;lt;bean id=&quot;jmsTemplate&quot; class=&quot;org.springframework.jms.core.JmsTemplate&quot;&amp;gt;
        &amp;lt;property name=&quot;connectionFactory&quot; ref=&quot;connectionFactory&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;bean class=&quot;net.codingme.jms.producer.ProducerServiceImpl&quot;&amp;gt;&amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;生产者编写&quot;&gt;生产者编写&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 定义接口&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package net.codingme.jms.producer;

/**
 * &amp;lt;p&amp;gt;
 *
 * @Author niujinpeng
 * @Date 2018/11/2518:19
 */
public interface ProducerService {
    public void sendMessage(String message);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. 主题模式生产者&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package net.codingme.jms.producer;


import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.MessageCreator;

import javax.annotation.Resource;
import javax.jms.*;


/**
 * &amp;lt;p&amp;gt;
 *
 * @Author niujinpeng
 * @Date 2018/11/25 19:24
 */
public class ProducerServiceImpl implements ProducerService {

    @Autowired
    JmsTemplate jmsTemplate;
    /**
     * 主题模式
     */
    @Resource(name = &quot;topicDestination&quot;)
    Destination destination;

    @Override
    public void sendMessage(String message) {
        // 使用jmsTemplate发送消息
        jmsTemplate.send(destination, new MessageCreator() {
            // 创建消息
            @Override
            public Message createMessage(Session session) throws JMSException {
                TextMessage textMessage = session.createTextMessage(message);
                return textMessage;
            }
        });
        System.out.println(&quot;发送消息：&quot; + message);

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. Spring 启动 生产者&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package net.codingme.jms.producer;

import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * &amp;lt;p&amp;gt;
 * 启动器
 *
 * @Author niujinpeng
 * @Date 2018/11/25 21:48
 */
public class AppProducer {

    public static void main(String[] args) {
        // 装载配置文件
        ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(&quot;classpath:producer.xml&quot;);
        ProducerService service = context.getBean(ProducerService.class);

        for (int i = 0; i &amp;lt; 10; i++) {
            service.sendMessage(&quot;test&quot; + i);
        }
        context.close();
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;消费者编写&quot;&gt;消费者编写&lt;/h3&gt;
&lt;p&gt;Spring启动和生产者类似。下面是消费者监听器的实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package net.codingme.jms.consumer;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

/**
 * &amp;lt;p&amp;gt;
 * 消息监听器
 *
 * @Author niujinpeng
 * @Date 2018/11/25 22:28
 */
public class ConsumerMessageListener implements MessageListener {
    @Override
    public void onMessage(Message message) {
        TextMessage textMessage = (TextMessage) message;
        try {
            System.out.println(&quot;接收消息：&quot; + textMessage.getText());
        } catch (JMSException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行测试&quot;&gt;运行测试&lt;/h3&gt;
&lt;p&gt;首先主题模式下启动两个消费者，使用生产者推送10条消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/niumoo/notes/master/assets/1543592342762.png&quot; alt=&quot;测试&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在每个消费者下面都可以看到推送的完整消息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/niumoo/notes/master/assets/1543592531937.png&quot; alt=&quot;测试&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文中代码已经上传到GitHub：&lt;a href=&quot;https://github.com/niumoo/message-queue&quot; class=&quot;uri&quot;&gt;https://github.com/niumoo/message-queue&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;完&amp;gt;&lt;br/&gt;本文原发于个人博客：&lt;a href=&quot;https://www.codingme.net/&quot; class=&quot;uri&quot;&gt;https://www.codingme.net&lt;/a&gt; 转载请注明出处&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-e1b06fdf782b78e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 16:23:00 +0000</pubDate>
<dc:creator>雪漫士兵</dc:creator>
<og:description>ActiveMQ 介绍 Active MQ 是由 Apache 出品的一款流行的功能强大的开源消息中间件，它速度快，支持跨语言的客户端，具有易于使用的企业集成模式和许多的高级功能，同时完全支持</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niumoo/p/10099942.html</dc:identifier>
</item>
<item>
<title>线程与进程，如兄如父如homie？ - 马叉虫啊</title>
<link>http://www.cnblogs.com/machach/p/10100100.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/machach/p/10100100.html</guid>
<description>&lt;p&gt;显然这是一个在面试中的高频问题，每次碰上，第一反应都是欣喜，心想这题我见过，进程就是一个程序嘛，可以由一个或多个线程组成。然后和面试官尴尬对视三十秒，七零八落说一通，脑海里很多想法，却没法有条理的串在一起，自己也觉得不满意。还是沉下心，好好整理一下。&lt;/p&gt;


&lt;p&gt;在此之前，先明白几个概念。&lt;/p&gt;
&lt;p&gt; 并行与并发：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;并行：多个cpu实例或者多台机器同时执行一段处理逻辑，是真正的同时。&lt;/li&gt;
&lt;li&gt;并发：通过cpu调度算法，让用户看上去同时执行，实际上从cpu操作层面不是真正的同时。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上下文切换&lt;/p&gt;
&lt;p&gt;即使是单核CPU也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程时同时执行的，时间片一般是几十毫秒（ms）。&lt;/p&gt;
&lt;p&gt;CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再次加载这个任务的状态，&lt;strong&gt;从任务保存到再加载的过程就是一次上下文切换&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、个人定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;教科书上最经典的一句话是“进程是资源分配的最小单位，线程是CPU调度的最小单位”，但是理解起来还是抽象。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先想一想，他俩是因为什么出现并‘’狼狈为奸‘’的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程的出现是为了更好的利用CPU资源使到并发成为可能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;线程的出现是为了降低上下文切换的消耗，提高系统的并发性，并突破一个进程只能干一样事的缺陷，使到进程内并发成为可能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;他们的终极目标都是为了进一步提高cpu的利用率，类比于内存与缓存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、具体差异&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1，&lt;span&gt;&lt;strong&gt;拥有系统资源的差异：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每个进程都拥有自己独立的内存空间，但是同一个进程内部的不同线程间是内存共享的，线程不拥有系统资源，只拥有运行中必不可少的信息（如一组寄存器、堆栈和程序计数器）。&lt;/span&gt;由此拥有系统资源的&lt;strong&gt;根本性差别&lt;/strong&gt;，产生了几个子区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;可靠性差异&lt;/span&gt;：进程更加稳定，一个进程崩溃，其余不受影响，因为其内存空间是独立的。但是一个子线程崩溃，拥有它的整个进程都崩溃了。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通信方式差异&lt;/span&gt;：每个进程有自己的地址空间。两个进程中的地址即使值相同，实际指向的位置也不同。进程间通信（IPC）一般通过操作系统的公共区进行，是系统调用，如管道pipe、信号signal、共享内存shared memory、信号量semophore。&lt;br/&gt;同一进程中的线程因属同一地址空间，可直接通信（不必通过操作系统(内核)调度）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2，&lt;span&gt;&lt;strong&gt;上下文切换的差异：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;原则上讲，一个CPU只能分配给一个进程，要实现多任务，就必须要使用并发技术。通过cpu时间片轮转进程调度算法，完成多任务。（线程中，多线程的实现也和进程同理），在时间片轮转调度过程中，线程进程差异化从上下文切换环节上表现出来。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;进程上下文切换包括三步。a.切换页目录以及使用新的地址空间。b.切换内核线。c.切换硬件上下文。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而对于线程来讲，由于是共享内存空间（好像根本原因又回到了第一点），第一步是不需要的。只要bc就能完成上下文切换，节省了大量的损耗。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;一直想把他们抽象的关系找到生活里的映射，无奈实在找不到如此完美的模型。&lt;/p&gt;
&lt;p&gt;起源上，进程是爹，有时计划生育，有时野性繁殖。线程们兄弟情深，一人失恋，剩下的也悲痛欲绝，怎么也理解不了父辈之间的冷漠交情，其实道理也简单，兄弟们都生活在一个大house里，相依为gay，聊起天来也方便，感情自然铁。&lt;/p&gt;
&lt;p&gt;直到有一天他们爱上了一个同一个小姑娘，大哥把人约到了家里，拉小姑娘进小房间里锁门谈心，弟弟们门外排队等候，虽然迫不及待，但也恪守交规，二弟排在第一位，每隔几秒就去检查门开了没有。。。&lt;/p&gt;
&lt;p&gt;再写就变态了，到此为止！&lt;/p&gt;

&lt;p&gt;最后贴一个：&lt;/p&gt;
&lt;p&gt;http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html&lt;/p&gt;
&lt;p&gt;来自阮一峰的博客，将CPU，线程，进程分别类比于工厂和其中的车间和工人，有一点点瑕疵但是很深动。&lt;/p&gt;
&lt;p&gt;1.计算机的核心是CPU，它承担了所有的计算任务。它就像一座工厂，时刻在运行。&lt;/p&gt;
&lt;p&gt;2.假定工厂的电力有限，一次只能供给一个车间使用。也就是说，一个车间开工的时候，其他车间都必须停工。背后的含义就是，单个CPU一次只能运行一个任务。（这句话没有问题，但是这里没有解释单cpu处理多任务的情况，需要完善）&lt;/p&gt;
&lt;p&gt;3.进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。&lt;/p&gt;
&lt;p&gt;4.一个车间里，可以有很多工人。他们协同完成一个任务。&lt;/p&gt;
&lt;p&gt;5.线程就好比车间里的工人。一个进程可以包括多个线程。&lt;/p&gt;
&lt;p&gt;6.车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。（前提是在一个进程里的每一个线程）&lt;/p&gt;
&lt;p&gt;7.可是，每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。&lt;/p&gt;
&lt;p&gt;8.一个防止他人进入的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫&lt;a href=&quot;http://zh.wikipedia.org/wiki/%E4%BA%92%E6%96%A5%E9%94%81&quot; target=&quot;_blank&quot;&gt;&quot;互斥锁&quot;&lt;/a&gt;（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。&lt;/p&gt;
&lt;p&gt;9.还有些房间，可以同时容纳n个人，比如厨房。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。&lt;/p&gt;
&lt;p&gt;10.这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做&lt;a href=&quot;http://en.wikipedia.org/wiki/Semaphore_(programming)&quot; target=&quot;_blank&quot;&gt;&quot;信号量&quot;&lt;/a&gt;（Semaphore），用来保证多个线程不会互相冲突。&lt;/p&gt;
&lt;p&gt;不难看出，mutex是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为mutex较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。（既然讲到互斥锁，其实还可以具体化一下偏向锁和轻量级锁）&lt;/p&gt;
&lt;p&gt;11.操作系统的设计归结为三点：&lt;/p&gt;
&lt;p&gt;（1）以多进程形式，允许多个任务同时运行；&lt;/p&gt;
&lt;p&gt;（2）以多线程形式，允许单个任务分成不同的部分运行；&lt;/p&gt;
&lt;p&gt;（3）提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。&lt;/p&gt;


&lt;p&gt; 参考的博客：&lt;/p&gt;
&lt;p&gt;1.https://www.cnblogs.com/xh0102/p/5710074.html   通信方式的区别&lt;/p&gt;
&lt;p&gt;2.https://blog.csdn.net/bxw1992/article/details/78115860  上下文的区别&lt;/p&gt;
&lt;p&gt;3.https://www.jianshu.com/p/f11724034d50 不错的定义&lt;/p&gt;
&lt;p&gt;4.http://www.ruanyifeng.com/blog/2013/04/processes_and_threads.html  有趣的类比&lt;/p&gt;
&lt;p&gt;5.https://www.zhihu.com/question/25532384  独特的概括，膜拜&lt;/p&gt;

</description>
<pubDate>Mon, 10 Dec 2018 16:22:00 +0000</pubDate>
<dc:creator>马叉虫啊</dc:creator>
<og:description>显然这是一个在面试中的高频问题，每次碰上，第一反应都是欣喜，心想这题我见过，进程就是一个程序嘛，可以由一个或多个线程组成。然后和面试官尴尬对视三十秒，七零八落说一通，脑海里很多想法，却没法有条理的串在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/machach/p/10100100.html</dc:identifier>
</item>
<item>
<title>Oracle 10g使用amdu抽取数据文件 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/10100032.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/10100032.html</guid>
<description>&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;OEL 5.7 + Oracle 10.2.0.5 RAC&lt;br/&gt;&lt;strong&gt;需求：&lt;/strong&gt;实验在Oracle 10g环境使用amdu抽取数据库文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文主要目的是介绍3个知识点：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Oracle 10g环境，并没有自带amdu工具，需要自行去下载：&lt;br/&gt;具体可以参考MOS文档：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Placeholder for AMDU binaries and using with ASM 10g, 11g, 12c (文档 ID 553639.1)&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;&amp;gt; $cd &amp;lt;your directory&amp;gt;
&amp;gt; $export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:`pwd`   
&amp;gt; or $setenv LD_LIBRARY_PATH ${LD_LIBRARY_PATH}:`pwd`
&amp;gt; $export PATH=$PATH:`pwd`  or setenv PATH ${PATH}:`pwd`
&amp;gt; 
&amp;gt; or 
&amp;gt; 
&amp;gt; $cd &amp;lt;your directory&amp;gt;
&amp;gt; $export LIBPATH=$LIBPATH:`pwd` 
&amp;gt; or $setenv LIBPATH ${LIBPATH}:`pwd`
&amp;gt; $export PATH=$PATH:`pwd` or setenv PATH ${PATH}:`pwd`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：如果是AIX平台，则对应的是设置LIBPATH环境变量。我这里是Linux，所以设置LD_LIBRARY_PATH环境变量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;unzip /tmp/amdu_X86-64.zip 
export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:`pwd` 
export PATH=$PATH:`pwd`&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在Oracle 10g环境kfed需要编译：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ASM tools used by Support : KFOD, KFED, AMDU (文档 ID 1485597.1)&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;KFED executable comes with installation from 11.1 onwards; for the older version you must build it.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编译方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$cd $ORACLE_HOME/rdbms/lib
$make -f ins_rdbms.mk ikfed&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;在ASM磁盘组损坏时，如何使用amdu工具来抽取数据库文件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;How to Restore the Database Using AMDU after Diskgroup Corruption (文档 ID 1597581.1)&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;1. Create pfile of lost database , from database alert.log startup messages.

2. Startup database in nomount

3. Get the controlfile number from db alert log , it will show while starting the database here in this eg. its 256
eg., control_files='+DATA/orcl/controlfile/current.256.709676643'

If you have controlfile backup already in non-asm location edit the pfile to point to location of non-asm and then mount the database
If you dont have controlfile backup then go to step 4 after determining the file# from step 3

4. $ amdu -diskstring &amp;lt;asm_diskstring&amp;gt; -extract DATA.256 

5. shutdown the database and change the control_file location to point to the extracted file location

6. startup mount the database

7. once mounted, get the datafile file numbers using &quot;select name from v$datafile&quot;
  And get online redo logfile from &quot;select * from v$logfile&quot;.

8. Extract all datafiles and redolog files in similar manner

9. alter database rename &amp;lt;datafile 1&amp;gt; to &amp;lt; newly extracte location&amp;gt;

10. open the database&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实际可以做实验去验证下MOS这个步骤的可行性：&lt;/strong&gt;&lt;br/&gt;1.创建参数文件&lt;br/&gt;2.启动数据库到nomount状态&lt;br/&gt;3.获取到控制文件的number&lt;br/&gt;4.抽出控制文件&lt;br/&gt;5.关闭数据库，修改control_file值&lt;br/&gt;6.启动数据库到mount状态&lt;br/&gt;7.获取到数据文件、日志文件的number&lt;br/&gt;8.抽取数据文件和redo日志文件&lt;br/&gt;9.重命名数据库文件到新位置&lt;br/&gt;10.打开数据库&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 16:05:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>环境： OEL 5.7 + Oracle 10.2.0.5 RAC 需求： 实验在Oracle 10g环境使用amdu抽取数据库文件 本文主要目的是介绍3个知识点：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/10100032.html</dc:identifier>
</item>
<item>
<title>5 手写Java Stack 核心源码 - 九路313</title>
<link>http://www.cnblogs.com/start1225/p/10099988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/start1225/p/10099988.html</guid>
<description>&lt;p&gt;Stack是Java中常用的数据结构之一，Stack具有&quot;后进先出(LIFO)&quot;的性质。&lt;br/&gt;只能在一端进行插入或者删除，即压栈与出栈&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈的实现比较简单，性质也简单。可以用一个数组来实现栈结构。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;入栈的时候，只在数组尾部插入&lt;/li&gt;
&lt;li&gt;出栈的时候，只在数组尾部删除**&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们来看一下Stack的用法 ：如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  public static void main(String[] args){

        //新建一个栈
        Stack&amp;lt;String&amp;gt; stack = new Stack&amp;lt;&amp;gt;();

        //分别向栈中添加不同的元素
        stack.push(&quot;tom&quot;);
        stack.push(&quot;jim&quot;);
        stack.push(&quot;wendy&quot;);
        stack.push(&quot;natasha&quot;);

        //分别弹栈
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;natasha
wendy
jim
tom&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出可以看到，最后入栈的，最先出栈&lt;/p&gt;
&lt;p&gt;下面我们底层用数组也来实现这样一个栈，在数组的尾部插入和删除。&lt;br/&gt;也就是入栈和出栈。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/594516/201812/594516-20181210233810623-1924032077.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;完整的源码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class QStack&amp;lt;E&amp;gt; {
    //数组的默认大小为10
    private static final int DEFAULT_INIT_CAPACITY = 10;

    //底层的数组
    private Object[] elements;

    //栈中的个数
    private int size;

    public QStack() {
        this(DEFAULT_INIT_CAPACITY);
    }


    public QStack(int capacity) {
        //capacity条件检查 ，这里我们直接抛出异常
        if (capacity &amp;lt;= 0) {
            throw new IllegalArgumentException(&quot;capacity &amp;lt;= 0&quot;);
        }

        if (capacity &amp;gt; Integer.MAX_VALUE) {
            throw new IllegalArgumentException(&quot;capacity &amp;gt; Integer.MAX_VALUE&quot;);
        }

        //新建一个capacity大小的数组
        elements = new Object[capacity];

        //初始个数为0
        size = 0;
    }

    //栈是否为空
    public boolean isEmpty() {
        return size == 0;
    }

    //返回栈中的元素个数
    public int size() {
        return size;
    }

    //将一个元素压入栈中
    public E push(E e) {
        //如果栈已满，进行扩容
        if (size &amp;gt;= elements.length) {
            grow();
        }

        //扩容完后将元素e压入栈中
        elements[size] = e;

        //别忘了size需要加 1
        size++;

        return e;
    }

    //出栈，就是将数组最后一个元素弹出
    public E pop() {
        //如果栈为空就返回null
        if (isEmpty()) {
            return null;
        }

        //拿到栈的大小
        int len = size();

        //把数组中最后一个元素保存起来
        E e = peek();
        //个数别忘了减1
        size--;

        //将最后一个元素置null
        elements[len - 1] = null;

        //返回e
        return e;
    }

    //返回最后一个元素
    public E peek() {
        int len = size();

        if (len == 0)
            throw new RuntimeException(&quot;stack is empty&quot;);

        return (E) elements[len - 1];
    }

    //扩容
    private void grow() {
        //将之前的数组保存
        int oldCapacity = elements.length;
        Object[] old = elements;

        //新的数组大小为原来数组大小的2倍
        int newCapacity = oldCapacity * 2;
        //再新建一个大小为原来数组2倍的新数组
        elements = new Object[newCapacity];

        //把以前的老的数组中的元素都移动新数组中
        for (int i = 0; i &amp;lt; oldCapacity; i++) {
            elements[i] = old[i];
        }

        //释放以前的内存空间
        old = null;
    }

}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上面可知：用数组实现栈结构，主要需要注意以下 2 点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在数组的尾部插入和删除，也就是压栈和弹栈&lt;/li&gt;
&lt;li&gt;由于是用数组实现栈结构，数组满的时候，需要扩容&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们写一段测试代码来测试,如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public static void main(String[] args){
        //创建一个栈
        QStack&amp;lt;String&amp;gt; stack = new QStack&amp;lt;&amp;gt;();
        
        //分别向栈中压入4个不同的元素
        stack.push(&quot;tom&quot;);
        stack.push(&quot;jim&quot;);
        stack.push(&quot;wendy&quot;);
        stack.push(&quot;natasha&quot;);

        //分别弹栈
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;natasha
wendy
jim
tom&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 10 Dec 2018 15:37:00 +0000</pubDate>
<dc:creator>九路313</dc:creator>
<og:description>Stack是Java中常用的数据结构之一，Stack具有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/start1225/p/10099988.html</dc:identifier>
</item>
<item>
<title>tomcat源码 Connector - xuanm</title>
<link>http://www.cnblogs.com/grasp/p/10099897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grasp/p/10099897.html</guid>
<description>&lt;p&gt;Connector容器主要负责解析socket请求，在tomcat中的源码位于org.apache.catalina.connector和org.apache.coyote包路径下；通过上两节的分析，我们知道了Connector是Service的子容器，而Service又是Server的子容器。在server.xml文件中配置，然后在Catalina类中通过Digester完成实例化。在server.xml中默认配置了两种Connector的实现，分别用来处理Http请求和AJP请求。&lt;br/&gt;Connector的实现一共有以下三种：&lt;/p&gt;
&lt;p&gt;1、Http Connector：解析HTTP请求，又分为BIO Http Connector和NIO Http Connector，即阻塞IO Connector和非阻塞IO Connector。本文主要分析NIO Http Connector的实现过程。&lt;/p&gt;
&lt;p&gt;2、AJP：基于AJP协议，用于Tomcat与HTTP服务器通信定制的协议，能提供较高的通信速度和效率。如与Apache服务器集成时，采用这个协议。&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;3、APR HTTP Connector：用C实现，通过JNI调用的。主要提升对静态资源（如HTML、图片、CSS、JS等）的访问性能。&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;具体要使用哪种Connector可以在server.xml文件中通过protocol属性配置如下：&lt;/em&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Connector &lt;/span&gt;&lt;span&gt;port&lt;/span&gt;&lt;span&gt;=&quot;8080&quot;&lt;/span&gt;&lt;span&gt; protocol&lt;/span&gt;&lt;span&gt;=&quot;HTTP/1.1&quot;&lt;/span&gt;&lt;span&gt;
               connectionTimeout&lt;/span&gt;&lt;span&gt;=&quot;20000&quot;&lt;/span&gt;&lt;span&gt;
               redirectPort&lt;/span&gt;&lt;span&gt;=&quot;8443&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后看一下Connector的构造器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Connector(String protocol) {
    setProtocol(protocol);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Instantiate protocol handler&lt;/span&gt;
    ProtocolHandler p = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        Class&lt;/span&gt;&amp;lt;?&amp;gt; clazz =&lt;span&gt; Class.forName(protocolHandlerClassName);
        p &lt;/span&gt;=&lt;span&gt; (ProtocolHandler) clazz.getConstructor().newInstance();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
        log.error(sm.getString(
                &lt;/span&gt;&quot;coyoteConnector.protocolHandlerInstantiationFailed&quot;&lt;span&gt;), e);
    } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.protocolHandler =&lt;span&gt; p;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (Globals.STRICT_SERVLET_COMPLIANCE) {
        uriCharset &lt;/span&gt;=&lt;span&gt; StandardCharsets.ISO_8859_1;
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        uriCharset &lt;/span&gt;=&lt;span&gt; StandardCharsets.UTF_8;
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setProtocol(String protocol) {

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; aprConnector = AprLifecycleListener.isAprAvailable() &amp;amp;&amp;amp;&lt;span&gt;
            AprLifecycleListener.getUseAprConnector();

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;HTTP/1.1&quot;.equals(protocol) || protocol == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (aprConnector) {
            setProtocolHandlerClassName(&lt;/span&gt;&quot;org.apache.coyote.http11.Http11AprProtocol&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            setProtocolHandlerClassName(&lt;/span&gt;&quot;org.apache.coyote.http11.Http11NioProtocol&quot;&lt;span&gt;);
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;AJP/1.3&quot;&lt;span&gt;.equals(protocol)) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (aprConnector) {
            setProtocolHandlerClassName(&lt;/span&gt;&quot;org.apache.coyote.ajp.AjpAprProtocol&quot;&lt;span&gt;);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            setProtocolHandlerClassName(&lt;/span&gt;&quot;org.apache.coyote.ajp.AjpNioProtocol&quot;&lt;span&gt;);
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        setProtocolHandlerClassName(protocol);
    }
&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过分析Connector构造器的源码可以知道，每一个Connector对应了一个protocolHandler，一个protocolHandler被设计用来监听服务器某个端口的网络请求，但并不负责处理请求(处理请求由Container组件完成)。下面就以Http11NioProtocol为例分析Http请求的解析过程。&lt;br/&gt;在Connector的startInterval方法中启动了protocolHandler,代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; startInternal() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; LifecycleException {

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Validate settings before starting&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (getPort() &amp;lt; 0&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LifecycleException(sm.getString(
                &lt;/span&gt;&quot;coyoteConnector.invalidPort&quot;&lt;span&gt;, Integer.valueOf(getPort())));
    }

    setState(LifecycleState.STARTING);

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        protocolHandler.start();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LifecycleException(
                sm.getString(&lt;/span&gt;&quot;coyoteConnector.protocolHandlerStartFailed&quot;&lt;span&gt;), e);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Http11NioProtocol创建一个org.apache.tomcat.util.net.NioEndpoint实例,然后将监听端口并解析请求的工作全被委托给NioEndpoint实现。tomcat在使用Http11NioProtocol解析HTTP请求时一共设计了三种线程，分别为Acceptor，Poller和Worker。&lt;/p&gt;

&lt;p&gt;Acceptor实现了Runnable接口，根据其命名就知道它是一个接收器，负责接收socket，其接收方法是serverSocket.accept()方式，获得SocketChannel对象，然后封装成tomcat自定义的org.apache.tomcat.util.net.NioChannel。虽然是Nio，但在接收socket时仍然使用传统的方法，使用阻塞方式实现。Acceptor以线程池的方式被创建和管理，在NioEndpoint的startInternal()方法中完成Acceptor的启动，源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; startInternal() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;running) {
        running &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        paused &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        processorCache &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SynchronizedStack&amp;lt;&amp;gt;&lt;span&gt;(SynchronizedStack.DEFAULT_SIZE,
                socketProperties.getProcessorCache());
        eventCache &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SynchronizedStack&amp;lt;&amp;gt;&lt;span&gt;(SynchronizedStack.DEFAULT_SIZE,
                        socketProperties.getEventCache());
        nioChannels &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SynchronizedStack&amp;lt;&amp;gt;&lt;span&gt;(SynchronizedStack.DEFAULT_SIZE,
                socketProperties.getBufferPool());

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create worker collection&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ( getExecutor() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt; ) {
            createExecutor();
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置最大连接数,默认值为maxConnections = 10000，通过同步器AQS实现。&lt;/span&gt;
&lt;span&gt;        initializeConnectionLatch();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;默认是2个，Math.min(2,Runtime.getRuntime().availableProcessors());和虚拟机处理器个数比较
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start poller threads&lt;/span&gt;
        pollers = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Poller[getPollerThreadCount()];
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i=0; i&amp;lt;pollers.length; i++&lt;span&gt;) {
            pollers[i] &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Poller();
            Thread pollerThread &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Thread(pollers[i], getName() + &quot;-ClientPoller-&quot;+&lt;span&gt;i);
            pollerThread.setPriority(threadPriority);
            pollerThread.setDaemon(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            pollerThread.start();
        }
&lt;/span&gt;
&lt;span&gt;        startAcceptorThreads();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续追踪startAcceptorThreads的源码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; startAcceptorThreads() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;启动Acceptor线程，默认是1个&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; count =&lt;span&gt; getAcceptorThreadCount();
    acceptors &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Acceptor[count];

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; count; i++&lt;span&gt;) {
        acceptors[i] &lt;/span&gt;=&lt;span&gt; createAcceptor();
        String threadName &lt;/span&gt;= getName() + &quot;-Acceptor-&quot; +&lt;span&gt; i;
        acceptors[i].setThreadName(threadName);
        Thread t &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread(acceptors[i], threadName);
        t.setPriority(getAcceptorThreadPriority());
        t.setDaemon(getDaemon());
        t.start();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Acceptor线程的核心代码在它的run方法中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Acceptor &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; AbstractEndpoint.Acceptor {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; errorDelay = 0&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Loop until we receive a shutdown command&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt;&lt;span&gt; (running) {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Loop if endpoint is paused&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (paused &amp;amp;&amp;amp;&lt;span&gt; running) {
                state &lt;/span&gt;=&lt;span&gt; AcceptorState.PAUSED;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    Thread.sleep(&lt;/span&gt;50&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Ignore&lt;/span&gt;
&lt;span&gt;                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;running) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
            state &lt;/span&gt;=&lt;span&gt; AcceptorState.RUNNING;

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if we have reached max connections, wait&lt;/span&gt;
&lt;span&gt;                countUpOrAwaitConnection();

                SocketChannel socket &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Accept the next incoming connection from the server
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; socket
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收socket请求&lt;/span&gt;
                    socket =&lt;span&gt; serverSock.accept();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; We didn't get a socket&lt;/span&gt;
&lt;span&gt;                    countDownConnection();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (running) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Introduce delay if necessary&lt;/span&gt;
                        errorDelay =&lt;span&gt; handleExceptionWithDelay(errorDelay);
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; re-throw&lt;/span&gt;
                        &lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ioe;
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Successful accept, reset the error delay&lt;/span&gt;
                errorDelay = 0&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Configure the socket&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (running &amp;amp;&amp;amp; !&lt;span&gt;paused) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; setSocketOptions() will hand the socket off to
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; an appropriate processor if successful&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;setSocketOptions(socket)) {
                        closeSocket(socket);
                    }
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    closeSocket(socket);
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
                ExceptionUtils.handleThrowable(t);
                log.error(sm.getString(&lt;/span&gt;&quot;endpoint.accept.fail&quot;&lt;span&gt;), t);
            }
        }
        state &lt;/span&gt;=&lt;span&gt; AcceptorState.ENDED;
    }


    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; closeSocket(SocketChannel socket) {
        countDownConnection();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            socket.socket().close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe)  {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (log.isDebugEnabled()) {
                log.debug(sm.getString(&lt;/span&gt;&quot;endpoint.err.close&quot;&lt;span&gt;), ioe);
            }
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            socket.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (log.isDebugEnabled()) {
                log.debug(sm.getString(&lt;/span&gt;&quot;endpoint.err.close&quot;&lt;span&gt;), ioe);
            }
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Acceptor完成了socket请求的接收，然后交给NioEndpoint 进行配置，继续追踪Endpoint的setSocketOptions方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; setSocketOptions(SocketChannel socket) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Process the connection&lt;/span&gt;
    &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;disable blocking, APR style, we are gonna be polling it
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置为非阻塞&lt;/span&gt;
        socket.configureBlocking(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        Socket sock &lt;/span&gt;=&lt;span&gt; socket.socket();
        socketProperties.setProperties(sock);

        NioChannel channel &lt;/span&gt;=&lt;span&gt; nioChannels.pop();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (channel == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            SocketBufferHandler bufhandler &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketBufferHandler(
                    socketProperties.getAppReadBufSize(),
                    socketProperties.getAppWriteBufSize(),
                    socketProperties.getDirectBuffer());
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isSSLEnabled()) {
                channel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; SecureNioChannel(socket, bufhandler, selectorPool, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                channel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NioChannel(socket, bufhandler);
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            channel.setIOChannel(socket);
            channel.reset();
        }
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;轮训pollers数组元素，调用Poller的register方法，完成channel的注册。&lt;/span&gt;
&lt;span&gt;        getPoller0().register(channel);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            log.error(&lt;/span&gt;&quot;&quot;&lt;span&gt;,t);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable tt) {
            ExceptionUtils.handleThrowable(tt);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Tell to close the socket&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分析setSocketOptions的源码可以知道，该方法的主要功能是利用传入的SocketChannel参数生成SecureNioChannel或者NioChannel，然后注册到Poller线程的selector中，可以进一步了解Java nio的相关知识，对这一块内容有更深的理解。&lt;/p&gt;

&lt;p&gt; Poller同样实现了Runnable接口，是NioEndpoint类的内部类。在Endpoint的startInterval方法中创建、配置并启动了Poller线程，见代码清单4。Poller主要职责是不断轮询其selector，检查准备就绪的socket(有数据可读或可写)，实现io的多路复用。其构造其中初始化了selector。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Poller() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.selector =&lt;span&gt; Selector.open();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在分析Acceptor的时候，提到了Acceptor接受到一个socket请求后，调用NioEndpoint的setSocketOptions方法(代码清单6),该方法生成了NioChannel后调用Poller的register方法生成PoolorEvent后加入到Eventqueue，register方法的源码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; register(&lt;span&gt;final&lt;/span&gt;&lt;span&gt; NioChannel socket) {
    socket.setPoller(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    NioSocketWrapper ka &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; NioSocketWrapper(socket, NioEndpoint.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    socket.setSocketWrapper(ka);
    ka.setPoller(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    ka.setReadTimeout(getSocketProperties().getSoTimeout());
    ka.setWriteTimeout(getSocketProperties().getSoTimeout());
    ka.setKeepAliveLeft(NioEndpoint.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getMaxKeepAliveRequests());
    ka.setSecure(isSSLEnabled());
    ka.setReadTimeout(getConnectionTimeout());
    ka.setWriteTimeout(getConnectionTimeout());
    PollerEvent r &lt;/span&gt;=&lt;span&gt; eventCache.pop();
    ka.interestOps(SelectionKey.OP_READ);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;this is what OP_REGISTER turns into.
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成PoolorEvent并加入到Eventqueue&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; ( r==&lt;span&gt;null&lt;/span&gt;) r = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PollerEvent(socket,ka,OP_REGISTER);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; r.reset(socket,ka,OP_REGISTER);
    addEvent(r);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Poller的核心代码也在其run方法中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Loop until destroy() is called
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用了destroy()方法后终止此循环&lt;/span&gt;
    &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; hasEvents = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;close) {
                hasEvents &lt;/span&gt;=&lt;span&gt; events();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (wakeupCounter.getAndSet(-1) &amp;gt; 0&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if we are here, means we have other stuff to do
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do a non blocking select
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非阻塞的 select&lt;/span&gt;
                    keyCount =&lt;span&gt; selector.selectNow();
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;阻塞selector，直到有准备就绪的socket&lt;/span&gt;
                    keyCount =&lt;span&gt; selector.select(selectorTimeout);
                }
                wakeupCounter.set(&lt;/span&gt;0&lt;span&gt;);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (close) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法遍历了eventqueue中的所有PollerEvent，然后依次调用PollerEvent的run，将socket注册到selector中。&lt;/span&gt;
&lt;span&gt;                events();
                timeout(&lt;/span&gt;0, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    selector.close();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException ioe) {
                    log.error(sm.getString(&lt;/span&gt;&quot;endpoint.nio.selectorCloseFail&quot;&lt;span&gt;), ioe);
                }
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable x) {
            ExceptionUtils.handleThrowable(x);
            log.error(&lt;/span&gt;&quot;&quot;&lt;span&gt;,x);
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;either we timed out or we woke up, process events first&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; ( keyCount == 0 ) hasEvents = (hasEvents |&lt;span&gt; events());

        Iterator&lt;/span&gt;&amp;lt;SelectionKey&amp;gt; iterator =&lt;span&gt;
            keyCount &lt;/span&gt;&amp;gt; 0 ? selector.selectedKeys().iterator() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Walk through the collection of ready keys and dispatch
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; any active event.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历就绪的socket事件&lt;/span&gt;
        &lt;span&gt;while&lt;/span&gt; (iterator != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp;&lt;span&gt; iterator.hasNext()) {
            SelectionKey sk &lt;/span&gt;=&lt;span&gt; iterator.next();
            NioSocketWrapper attachment &lt;/span&gt;=&lt;span&gt; (NioSocketWrapper)sk.attachment();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Attachment may be null if another thread has called
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; cancelledKey()&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (attachment == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                iterator.remove();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                iterator.remove();
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用processKey方法对有数据读写的socket进行处理，在分析Worker线程时会分析该方法&lt;/span&gt;
&lt;span&gt;                processKey(sk, attachment);
            }
        }&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;while

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;process timeouts&lt;/span&gt;
&lt;span&gt;        timeout(keyCount,hasEvents);
    }&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;
&lt;span&gt;
    getStopLatch().countDown();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;run方法中调用了events方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; events() {
    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    PollerEvent pe &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0, size = events.size(); i &amp;lt; size &amp;amp;&amp;amp; (pe = events.poll()) != &lt;span&gt;null&lt;/span&gt;; i++&lt;span&gt; ) {
        result &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将pollerEvent中的每个socketChannel注册到selector中&lt;/span&gt;
&lt;span&gt;            pe.run();
            pe.reset();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (running &amp;amp;&amp;amp; !&lt;span&gt;paused) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将注册了的pollerEvent加到endPoint.eventCache&lt;/span&gt;
&lt;span&gt;                eventCache.push(pe);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; ( Throwable x ) {
            log.error(&lt;/span&gt;&quot;&quot;&lt;span&gt;,x);
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续跟进PollerEvent的run方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (interestOps ==&lt;span&gt; OP_REGISTER) {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将SocketChannel注册到selector中,注册时间为SelectionKey.OP_READ读事件&lt;/span&gt;
&lt;span&gt;            socket.getIOChannel().register(
                    socket.getPoller().getSelector(), SelectionKey.OP_READ, socketWrapper);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception x) {
            log.error(sm.getString(&lt;/span&gt;&quot;endpoint.nio.registerFail&quot;&lt;span&gt;), x);
        }
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; SelectionKey key =&lt;span&gt; socket.getIOChannel().keyFor(socket.getPoller().getSelector());
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (key == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The key was cancelled (e.g. due to socket closure)
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; and removed from the selector while it was being
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; processed. Count down the connections at this point
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; since it won't have been counted down when the socket
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; closed.&lt;/span&gt;
&lt;span&gt;                socket.socketWrapper.getEndpoint().countDownConnection();
                ((NioSocketWrapper) socket.socketWrapper).closed &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; NioSocketWrapper socketWrapper =&lt;span&gt; (NioSocketWrapper) key.attachment();
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (socketWrapper != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;we are registering the key to start with, reset the fairness counter.&lt;/span&gt;
                    &lt;span&gt;int&lt;/span&gt; ops = key.interestOps() |&lt;span&gt; interestOps;
                    socketWrapper.interestOps(ops);
                    key.interestOps(ops);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    socket.getPoller().cancelledKey(key);
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (CancelledKeyException ckx) {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                socket.getPoller().cancelledKey(key);
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ignore) {}
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Worker线程即SocketProcessor是用来处理Socket请求的。SocketProcessor也同样是Endpoint的内部类。在Poller的run方法中(代码清单8)监听到准备就绪的socket时会调用processKey方法进行处理：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; processKey(SelectionKey sk, NioSocketWrapper attachment) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; ( close ) {
            cancelledKey(sk);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; ( sk.isValid() &amp;amp;&amp;amp; attachment != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; ) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;有读写事件就绪时&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (sk.isReadable() ||&lt;span&gt; sk.isWritable() ) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; ( attachment.getSendfileData() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt; ) {
                    processSendfile(sk,attachment, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    unreg(sk, attachment, sk.readyOps());
                    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; closeSocket = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Read goes before write
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; socket可读时，先处理读事件&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (sk.isReadable()) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用processSocket方法进一步处理&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (!processSocket(attachment, SocketEvent.OPEN_READ, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
                            closeSocket &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;写事件&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (!closeSocket &amp;amp;&amp;amp;&lt;span&gt; sk.isWritable()) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用processSocket方法进一步处理&lt;/span&gt;
                        &lt;span&gt;if&lt;/span&gt; (!processSocket(attachment, SocketEvent.OPEN_WRITE, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
                            closeSocket &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                        }
                    }
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (closeSocket) {
                        cancelledKey(sk);
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;invalid key&lt;/span&gt;
&lt;span&gt;            cancelledKey(sk);
        }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; ( CancelledKeyException ckx ) {
        cancelledKey(sk);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        log.error(&lt;/span&gt;&quot;&quot;&lt;span&gt;,t);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;继续跟踪processSocket方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; processSocket(SocketWrapperBase&amp;lt;S&amp;gt;&lt;span&gt; socketWrapper,
        SocketEvent event, &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; dispatch) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (socketWrapper == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 尝试循环利用之前回收的SocketProcessor对象，如果没有可回收利用的则创建新的SocketProcessor对象&lt;/span&gt;
        SocketProcessorBase&amp;lt;S&amp;gt; sc =&lt;span&gt; processorCache.pop();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (sc == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            sc &lt;/span&gt;=&lt;span&gt; createSocketProcessor(socketWrapper, event);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 循环利用回收的SocketProcessor对象&lt;/span&gt;
&lt;span&gt;            sc.reset(socketWrapper, event);
        }
        Executor executor &lt;/span&gt;=&lt;span&gt; getExecutor();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dispatch &amp;amp;&amp;amp; executor != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;SocketProcessor实现了Runneble接口，可以直接传入execute方法进行处理&lt;/span&gt;
&lt;span&gt;            executor.execute(sc);
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            sc.run();
        }
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RejectedExecutionException ree) {
        getLog().warn(sm.getString(&lt;/span&gt;&quot;endpoint.executor.fail&quot;&lt;span&gt;, socketWrapper) , ree);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
        ExceptionUtils.handleThrowable(t);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This means we got an OOM or similar creating a thread, or that
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the pool and its queue are full&lt;/span&gt;
        getLog().error(sm.getString(&quot;endpoint.process.fail&quot;&lt;span&gt;), t);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;NioEndpoint中createSocketProcessor创建一个SocketProcessor。&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; SocketProcessorBase&amp;lt;NioChannel&amp;gt;&lt;span&gt; createSocketProcessor(
        SocketWrapperBase&lt;/span&gt;&amp;lt;NioChannel&amp;gt;&lt;span&gt; socketWrapper, SocketEvent event) {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SocketProcessor(socketWrapper, event);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;Http11NioProtocol是基于Java Nio实现的，创建了Acceptor、Poller和Worker线程实现多路io的复用。三类线程之间的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/738818/201812/738818-20181210233329983-329796945.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Acceptor和Poller之间是生产者消费者模式的关系，Acceptor不断向EventQueue中添加PollerEvent，Pollor轮询检查EventQueue中就绪的PollerEvent，然后发送给Work线程进行处理。&lt;/p&gt;

</description>
<pubDate>Mon, 10 Dec 2018 15:35:00 +0000</pubDate>
<dc:creator>xuanm</dc:creator>
<og:description>Connector容器主要负责解析socket请求，在tomcat中的源码位于org.apache.catalina.connector和org.apache.coyote包路径下；通过上两节的分析，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/grasp/p/10099897.html</dc:identifier>
</item>
<item>
<title>你真的了解回流和重绘吗 - 陈陈jg</title>
<link>http://www.cnblogs.com/chenjg/p/10099886.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenjg/p/10099886.html</guid>
<description>&lt;p&gt;回流和重绘可以说是每一个web开发者都经常听到的两个词语，我也不例外，可是一直不是很清楚这两步具体做了什么事情。最近由于部门内部要做分享，所以对其进行了一些研究，看了一些博客和书籍，整理了一些内容并且结合自己的体会，写了这篇文章，希望可以帮助到大家。&lt;/p&gt;
&lt;h2 id=&quot;浏览器的渲染过程&quot;&gt;浏览器的渲染过程&lt;/h2&gt;
&lt;p&gt;本文先从浏览器的渲染过程来从头到尾的讲解一下回流重绘，如果大家想直接看如何减少回流和重绘，可以跳到后面。（这个渲染过程来自&lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn&quot;&gt;MDN&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/97293716a8b6dd2fcfc4ae5364e37f8f55affaa4/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f332f313635396462313465373733663963633f773d36323426683d32383926663d706e6726733d3431303537&quot; alt=&quot;webkit渲染过程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面这个图上，我们可以看到，浏览器渲染过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解析HTML，生成DOM树，解析CSS，生成CSSOM树&lt;/li&gt;
&lt;li&gt;将DOM树和CSSOM树结合，生成渲染树(Render Tree)&lt;/li&gt;
&lt;li&gt;Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）&lt;/li&gt;
&lt;li&gt;Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素&lt;/li&gt;
&lt;li&gt;Display:将像素发送给GPU，展示在页面上。（这一步其实还有很多内容，比如会在GPU将多个合成层合并为同一个层，并展示在页面中。而css3硬件加速的原理则是新建合成层，这里我们不展开，之后有机会会写一篇博客）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;渲染过程看起来很简单，让我们来具体了解下每一步具体做了什么。&lt;/p&gt;
&lt;h3 id=&quot;生成渲染树&quot;&gt;生成渲染树&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/993343/201812/993343-20181210231250620-1709964320.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为了构建渲染树，浏览器主要完成了以下工作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从DOM树的根节点开始遍历每个可见节点。&lt;/li&gt;
&lt;li&gt;对于每个可见的节点，找到CSSOM树中对应的规则，并应用它们。&lt;/li&gt;
&lt;li&gt;根据每个可见节点以及其对应的样式，组合生成渲染树。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一步中，既然说到了要遍历可见的节点，那么我们得先知道，什么节点是不可见的。不可见的节点包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一些不会渲染输出的节点，比如script、meta、link等。&lt;/li&gt;
&lt;li&gt;一些通过css进行隐藏的节点。比如display:none。注意，利用visibility和opacity隐藏的节点，还是会显示在渲染树上的。只有display:none的节点才不会显示在渲染树上。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意：渲染树只包含可见的节点&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;回流&quot;&gt;回流&lt;/h3&gt;
&lt;p&gt;前面我们通过构造渲染树，我们将可见DOM节点以及它对应的样式结合起来，可是我们还需要计算它们在设备视口(viewport)内的确切位置和大小，这个计算的阶段就是回流。&lt;/p&gt;
&lt;p&gt;为了弄清每个对象在网站上的确切大小和位置，浏览器从渲染树的根节点开始遍历，我们可以以下面这个实例来表示：&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&amp;gt;
    &amp;lt;title&amp;gt;Critial Path: Hello world!&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div style=&quot;width: 50%&quot;&amp;gt;
      &amp;lt;div style=&quot;width: 50%&quot;&amp;gt;Hello world!&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，第一个div将节点的显示尺寸设置为视口宽度的50%，第二个div将其尺寸设置为父节点的50%。而在回流这个阶段，我们就需要根据视口具体的宽度，将其转为实际的像素值。（如下图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/993343/201812/993343-20181210231232605-889405024.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;重绘&quot;&gt;重绘&lt;/h3&gt;
&lt;p&gt;最终，我们通过构造渲染树和回流阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(位置、大小)，那么我们就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘节点。&lt;/p&gt;
&lt;p&gt;既然知道了浏览器的渲染过程后，我们就来探讨下，何时会发生回流重绘。&lt;/p&gt;
&lt;h2 id=&quot;何时发生回流重绘&quot;&gt;何时发生回流重绘&lt;/h2&gt;
&lt;p&gt;我们前面知道了，回流这一阶段主要是计算节点的位置和几何信息，那么当页面布局和几何信息发生变化的时候，就需要回流。比如以下情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加或删除可见的DOM元素&lt;/li&gt;
&lt;li&gt;元素的位置发生变化&lt;/li&gt;
&lt;li&gt;元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）&lt;/li&gt;
&lt;li&gt;内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。&lt;/li&gt;
&lt;li&gt;页面一开始渲染的时候（这肯定避免不了）&lt;/li&gt;
&lt;li&gt;浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意：回流一定会触发重绘，而重绘不一定会回流&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据改变的范围和程度，渲染树中或大或小的部分需要重新计算，有些改变会触发整个页面的重排，比如，滚动条出现的时候或者修改了根节点。&lt;/p&gt;
&lt;h2 id=&quot;浏览器的优化机制&quot;&gt;浏览器的优化机制&lt;/h2&gt;
&lt;p&gt;现代的浏览器都是很聪明的，由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！&lt;strong&gt;当你获取布局信息的操作的时候，会强制队列刷新&lt;/strong&gt;，比如当你访问以下属性或者使用以下方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;offsetTop、offsetLeft、offsetWidth、offsetHeight&lt;/li&gt;
&lt;li&gt;scrollTop、scrollLeft、scrollWidth、scrollHeight&lt;/li&gt;
&lt;li&gt;clientTop、clientLeft、clientWidth、clientHeight&lt;/li&gt;
&lt;li&gt;getComputedStyle()&lt;/li&gt;
&lt;li&gt;getBoundingClientRect&lt;/li&gt;
&lt;li&gt;具体可以访问这个网站：&lt;a href=&quot;https://gist.github.com/paulirish/5d52fb081b3570c81e3a&quot; class=&quot;uri&quot;&gt;https://gist.github.com/paulirish/5d52fb081b3570c81e3a&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，&lt;strong&gt;最好避免使用上面列出的属性，他们都会刷新渲染队列。&lt;/strong&gt;如果要使用它们，最好将值缓存起来。&lt;/p&gt;
&lt;h2 id=&quot;减少回流和重绘&quot;&gt;减少回流和重绘&lt;/h2&gt;
&lt;p&gt;好了，到了我们今天的重头戏，前面说了这么多背景和理论知识，接下来让我们谈谈如何减少回流和重绘。&lt;/p&gt;
&lt;h3 id=&quot;最小化重绘和重排&quot;&gt;最小化重绘和重排&lt;/h3&gt;
&lt;p&gt;由于重绘和重排可能代价比较昂贵，因此最好就是可以减少它的发生次数。为了减少发生次数，我们可以合并多次对DOM和样式的修改，然后一次处理掉。考虑这个例子&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const el = document.getElementById('test');
el.style.padding = '5px';
el.style.borderLeft = '1px';
el.style.borderRight = '2px';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子中，有三个样式属性被修改了，每一个都会影响元素的几何结构，引起回流。当然，大部分现代浏览器都对其做了优化，因此，只会触发一次重排。但是如果在旧版的浏览器或者在上面代码执行的时候，有其他代码访问了布局信息(上文中的会触发回流的布局信息)，那么就会导致三次重排。&lt;/p&gt;
&lt;p&gt;因此，我们可以合并所有的改变然后依次处理，比如我们可以采取以下的方式：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;使用cssText&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const el = document.getElementById('test');
el.style.cssText += 'border-left: 1px; border-right: 2px; padding: 5px;';&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;修改CSS的class&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const el = document.getElementById('test');
el.className += ' active';&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;批量修改dom&quot;&gt;批量修改DOM&lt;/h3&gt;
&lt;p&gt;当我们需要对DOM对一系列修改的时候，可以通过以下步骤减少回流重绘次数：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使元素脱离文档流&lt;/li&gt;
&lt;li&gt;对其进行多次修改&lt;/li&gt;
&lt;li&gt;将元素带回到文档中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;该过程的第一步和第三步可能会引起回流，但是经过第一步之后，对DOM的所有修改都不会引起回流，因为它已经不在渲染树了。&lt;/p&gt;
&lt;p&gt;有三种方式可以让DOM脱离文档流：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;隐藏元素，应用修改，重新显示&lt;/li&gt;
&lt;li&gt;使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档。&lt;/li&gt;
&lt;li&gt;将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;考虑我们要执行一段批量插入节点的代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function appendDataToElement(appendToElement, data) {
    let li;
    for (let i = 0; i &amp;lt; data.length; i++) {
        li = document.createElement('li');
        li.textContent = 'text';
        appendToElement.appendChild(li);
    }
}

const ul = document.getElementById('list');
appendDataToElement(ul, data);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果我们直接这样执行的话，由于每次循环都会插入一个新的节点，会导致浏览器回流一次。&lt;/p&gt;
&lt;p&gt;我们可以使用这三种方式进行优化:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐藏元素，应用修改，重新显示&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个会在展示和隐藏节点的时候，产生两次重绘&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function appendDataToElement(appendToElement, data) {
    let li;
    for (let i = 0; i &amp;lt; data.length; i++) {
        li = document.createElement('li');
        li.textContent = 'text';
        appendToElement.appendChild(li);
    }
}
const ul = document.getElementById('list');
ul.style.display = 'none';
appendDataToElement(ul, data);
ul.style.display = 'block';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用文档片段(document fragment)在当前DOM之外构建一个子树，再把它拷贝回文档&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const ul = document.getElementById('list');
const fragment = document.createDocumentFragment();
appendDataToElement(fragment, data);
ul.appendChild(fragment);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;将原始元素拷贝到一个脱离文档的节点中，修改节点后，再替换原始的元素。&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const ul = document.getElementById('list');
const clone = ul.cloneNode(true);
appendDataToElement(clone, data);
ul.parentNode.replaceChild(clone, ul);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于上述那种情况，我写了一个&lt;a href=&quot;https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E6%89%B9%E9%87%8F%E4%BF%AE%E6%94%B9DOM.html&quot;&gt;demo&lt;/a&gt;来测试修改前和修改后的性能。然而实验结果不是很理想。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原因：原因其实上面也说过了，浏览器会使用队列来储存多次修改，进行优化，所以对这个优化方案，我们其实不用优先考虑。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;避免触发同步布局事件&quot;&gt;避免触发同步布局事件&lt;/h3&gt;
&lt;p&gt;上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列，进行强制同步布局。举个例子，比如说我们想将一个p标签数组的宽度赋值为一个元素的宽度，我们可能写出这样的代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function initP() {
    for (let i = 0; i &amp;lt; paragraphs.length; i++) {
        paragraphs[i].style.width = box.offsetWidth + 'px';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码看上去是没有什么问题，可是其实会造成很大的性能问题。在每次循环的时候，都读取了box的一个offsetWidth属性值，然后利用它来更新p标签的width属性。这就导致了每一次循环的时候，浏览器都必须先使上一次循环中的样式更新操作生效，才能响应本次循环的样式读取操作。每一次循环都会强制浏览器刷新队列。我们可以优化为:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const width = box.offsetWidth;
function initP() {
    for (let i = 0; i &amp;lt; paragraphs.length; i++) {
        paragraphs[i].style.width = width + 'px';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样，我也写了个&lt;a&gt;demo&lt;/a&gt;来比较两者的性能差异。你可以自己点开这个demo体验下。这个对比差距就比较明显。&lt;/p&gt;
&lt;h3 id=&quot;对于复杂动画效果使用绝对定位让其脱离文档流&quot;&gt;对于复杂动画效果,使用绝对定位让其脱离文档流&lt;/h3&gt;
&lt;p&gt;对于复杂动画效果，由于会经常的引起回流重绘，因此，我们可以使用绝对定位，让它脱离文档流。否则会引起父元素以及后续元素频繁的回流。这个我们就直接上个&lt;a href=&quot;https://chenjigeng.github.io/example/share/%E9%81%BF%E5%85%8D%E5%9B%9E%E6%B5%81%E9%87%8D%E7%BB%98/%E5%B0%86%E5%A4%8D%E6%9D%82%E5%8A%A8%E7%94%BB%E6%B5%AE%E5%8A%A8%E5%8C%96.html&quot;&gt;例子&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;打开这个例子后，我们可以打开控制台，控制台上会输出当前的帧数(虽然不准)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/993343/201812/993343-20181210231048609-619022494.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中，我们可以看到，帧数一直都没到60。这个时候，只要我们点击一下那个按钮，把这个元素设置为绝对定位，帧数就可以稳定60。&lt;/p&gt;
&lt;h3 id=&quot;css3硬件加速gpu加速&quot;&gt;css3硬件加速（GPU加速）&lt;/h3&gt;
&lt;p&gt;比起考虑如何减少回流重绘，我们更期望的是，根本不要回流重绘。这个时候，css3硬件加速就闪亮登场啦！！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;划重点：使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘 。但是对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;本篇文章只讨论如何使用，暂不考虑其原理，之后有空会另外开篇文章说明。&lt;/p&gt;
&lt;h4 id=&quot;如何使用&quot;&gt;如何使用&lt;/h4&gt;
&lt;p&gt;常见的触发硬件加速的css属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;transform&lt;/li&gt;
&lt;li&gt;opacity&lt;/li&gt;
&lt;li&gt;filters&lt;/li&gt;
&lt;li&gt;Will-change&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;效果&quot;&gt;效果&lt;/h4&gt;
&lt;p&gt;我们可以先看个&lt;a href=&quot;https://chenjigeng.github.io/example/share/%E5%AF%B9%E6%AF%94gpu%E5%8A%A0%E9%80%9F/gpu%E5%8A%A0%E9%80%9F-transform.html&quot;&gt;例子&lt;/a&gt;。我通过使用chrome的Performance捕获了一段时间的回流重绘情况，实际结果如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/993343/201812/993343-20181210230959987-1419348644.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中我们可以看出，在动画进行的时候，没有发生任何的回流重绘。如果感兴趣你也可以自己做下实验。&lt;/p&gt;
&lt;h4 id=&quot;重点&quot;&gt;重点&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;使用css3硬件加速，可以让transform、opacity、filters这些动画不会引起回流重绘&lt;/li&gt;
&lt;li&gt;对于动画的其它属性，比如background-color这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;css3硬件加速的坑&quot;&gt;css3硬件加速的坑&lt;/h4&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果你为太多元素使用css3硬件加速，会导致内存占用较大，会有性能问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在GPU渲染字体会导致抗锯齿无效。这是因为GPU和CPU的算法不同。因此如果你不在动画结束的时候关闭硬件加速，会产生字体模糊。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文主要讲了浏览器的渲染过程、浏览器的优化机制以及如何减少甚至避免回流和重绘，希望可以帮助大家更好的理解回流重绘。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;本文地址在-&amp;gt;&lt;a href=&quot;https://github.com/chenjigeng/blog&quot;&gt;本人博客地址&lt;/a&gt;, 欢迎给个 start 或 follow&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 15:14:00 +0000</pubDate>
<dc:creator>陈陈jg</dc:creator>
<og:description>回流和重绘可以说是每一个web开发者都经常听到的两个词语，我也不例外，可是一直不是很清楚这两步具体做了什么事情。最近由于部门内部要做分享，所以对其进行了一些研究，看了一些博客和书籍，整理了一些内容并且</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenjg/p/10099886.html</dc:identifier>
</item>
<item>
<title>Python时间日期格式化之time与datetime模块总结 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/10099766.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/10099766.html</guid>
<description>&lt;h3&gt;1 引言&lt;/h3&gt;
&lt;h3&gt;2 理论准备&lt;/h3&gt;
&lt;h3&gt;3 time模块&lt;/h3&gt;
&lt;h3&gt;4 timedate模块&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;　　4.1 date类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4.2 time类&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　4.3 datetime类&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;　　4.4 datedelta类&lt;/h4&gt;

&lt;p&gt;　　在实际开发过程中，我们经常会用到日期或者时间，那么在Python中我们怎么获取时间，以及如何将时间转换为我们需要的格式呢？在之前的开发中，也曾遇到time、datetime等模块下的不同函数，这些函数名又很是相似，几次下来头都昏了，今天来彻底总结梳理一下Python中日期时间获取与格式化。&lt;/p&gt;

&lt;p&gt;         首先必须做一点理论准备，不然待会都不知道为什么会有这些函数。介绍3个概念：&lt;/p&gt;
&lt;p&gt;UTC time Coordinated Universal Time，世界协调时，又称格林尼治天文时间、世界标准时间。与UTC time对应的是各个时区的local time，也就是本地时间，例如我们的北京时间。&lt;/p&gt;
&lt;p&gt;　　epoch time表示时间开始的起点；它是一个特定的时间，不同平台上这个时间点的值不太相同，对于Unix而言，epoch time为 1970-01-01 00:00:00 UTC。&lt;/p&gt;
&lt;p&gt;　　timestamp（时间戳） 也称为Unix时间 或 POSIX时间；它是一种时间表示方式，表示从格林尼治时间1970年1月1日0时0分0秒开始到现在所经过的毫秒数，其值为float类型。 但是有些编程语言的相关方法返回的是秒数，例如我们的天下第一编程语言-Python大法就是这样（请不要反驳我）。所谓的时间戳timestamp就是当前时间与格林尼治时间1970年1月1日0时0分0秒之间过了多少秒。&lt;/p&gt;
&lt;p&gt;　　相应的，日期时间就有三种表示方法：&lt;/p&gt;
&lt;p&gt;　　1）stamptime时间戳，时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量。stamptime表现为一个float类型数据。&lt;/p&gt;
&lt;p&gt;　　2）struct_time时间元组，共有九个元素组。stamptime时间戳和格式化时间字符串之间的转化必须通过struct_time才行，所以struct_time时间元组时3中时间表示的中心。&lt;/p&gt;
&lt;p&gt;　　3）format time 格式化时间，已格式化的结构字符串使时间更具可读性。包括自定义格式和固定格式。&lt;/p&gt;
&lt;p&gt;　　那么，下面要说的就是怎么获取这三个时间，并进行这三个时间之间的转化。先总结一下time模块。&lt;/p&gt;

&lt;p&gt;　　先放两个图：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1539768/201812/1539768-20181210223546138-1495614145.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　time模块中，几乎所有时间获取与格式转化的函数都在上图中了，只要理清了这幅图的关系，那么time模块就不再是问题。图中，蓝色方块表示那三种时间格式，箭头表示时间的转化。下面，重点来了：&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1）获取当前时间的方法只有一个，那就是通过上图中的函数1——time.time()。&lt;/strong&gt;也就是说，要想获取当前时间，只能通过这个方法，而且获取的是时间戳格式的时间。想直接获取当前时间的时间元组格式或格式化字符串？没门，只能老老实实转化。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2）当传入默认参数时，指的是使用当前时间作为参数值。&lt;/strong&gt;图中带黄色底纹的都是设有默认值的参数（虽然默认值为None），函数2、3不传入该参数时，系统会自动获取当前时间的时间戳作为该参数值。而函数5则是系统会自动获取当前时间的时间元组作为该参数值，不是不能直接获取当前时间的时间元组吗？是的，但系统会先获取当前时间的时间戳，然后转化为时间元组。上图中只有向左的箭头所代表的函数才有默认值，就是因为向右才能由时间戳转化得到需要的时间格式。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3） localtime（函数2）和gmtime（函数3）都可以实现将时间戳转化为时间元组，但是，localtime转化的是本地时间，gmtime转为的是世界标准时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4）asctime（函数7）和ctime（函数8）只能转为为%a %b %d %H:%M:%S %Y格式的字符串时间。不传入参数时，用的也是当前时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　5）struct_time元组元素结构：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;下标/索引&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;属性名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;0&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_year&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot;&gt;
&lt;p align=&quot;left&quot;&gt;年份，如 2018&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_mon&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;月份，取值范围为[1, 12]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_mday&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一个月中的第几天，取值范围为[1-31]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;3&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_hour&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;小时， 取值范围为[0-23]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;4&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_min&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;分钟，取值范围为[0, 59]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;5&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_sec&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;秒，取值范围为[0, 61]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;6&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_wday&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一个星期中的第几天，取值范围为[0-6]，0表示星期一&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;7&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_yday&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一年中的第几天，取值范围为[1, 366]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;85&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;8&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;95&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tm_isdst&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;369&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;是否为夏令时，可取值为：0 , 1 或 -1，默认值为-1&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;left&quot;&gt;　　struct_time属性值的获取方式有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;　　可以把它当做一种特殊的有序不可变序列通过 &lt;strong&gt;&lt;em&gt;下标&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;/&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;索引&lt;/em&gt;&lt;/strong&gt; 获取各个元素的值，如t[0]&lt;/li&gt;
&lt;li&gt;　　也可以通过对象名 “t&lt;strong&gt;&lt;em&gt;.&lt;/em&gt;&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;属性名&lt;/em&gt;&lt;/strong&gt;” 的方式来获取各个元素的值，如t.tm_year。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　6）format time结构化表示：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;格式&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;含义&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%a&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地（locale）简化星期名称&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%A&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地完整星期名称&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%b&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地简化月份名称&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%B&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地完整月份名称&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%c&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地相应的日期和时间表示&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%d&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一个月中的第几天（01 - 31）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%H&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一天中的第几个小时（24小时制，00 - 23）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%I&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;第几个小时（12小时制，01 - 12）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%j&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一年中的第几天（001 - 366）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%m&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;月份（01 - 12）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%M&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;分钟数（00 - 59）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%p&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地am或者pm的相应符&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%S&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;秒（01 - 61）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%U&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一年中的星期数。（00 - 53星期天是一个星期的开始。）第一个星期天之前的所有天数都放在第0周。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%w&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;一个星期中的第几天（0 - 6，0是星期天）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%W&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;和%U基本相同，不同的是%W以星期一为一个星期的开始。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%x&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地相应日期&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%X&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;本地相应时间&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%y&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;去掉世纪的年份（00 - 99）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%Y&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;完整的年份&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%Z&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;时区的名字（如果不存在为空字符）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;%%&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;‘%’字符&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　在代码中实践一下上面的内容：&lt;/p&gt;
&lt;p&gt;　　1）time.time()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; time.time()

&lt;/span&gt;1544278402.1804464
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2）time.localtime()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; time.localtime() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不传入参数&lt;/span&gt;
&lt;span&gt;
time.struct_time(tm_year&lt;/span&gt;=2018, tm_mon=12, tm_mday=8, tm_hour=22, tm_min=14, tm_sec=58, tm_wday=5, tm_yday=342, tm_isdst=&lt;span&gt;0)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; time.localtime(time.time()) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 传入当前时间&lt;/span&gt;
&lt;span&gt;
time.struct_time(tm_year&lt;/span&gt;=2018, tm_mon=12, tm_mday=8, tm_hour=22, tm_min=15, tm_sec=33, tm_wday=5, tm_yday=342, tm_isdst=&lt;span&gt;0)

&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; time.localtime(1544200000.1232) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 传入其他时间戳&lt;/span&gt;
&lt;span&gt;
time.struct_time(tm_year&lt;/span&gt;=2018, tm_mon=12, tm_mday=8, tm_hour=0, tm_min=26, tm_sec=40, tm_wday=5, tm_yday=342, tm_isdst=0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3）time.gctime()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; time.gmtime()

time.struct_time(tm_year&lt;/span&gt;=2018, tm_mon=12, tm_mday=8, tm_hour=14, tm_min=18, tm_sec=38, tm_wday=5, tm_yday=342, tm_isdst=0)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4）time.mktime()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt;&lt;span&gt; time.mktime(time.localtime())

&lt;/span&gt;1544279024.0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5）strftime(format, p_tuple=None)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%y-%m-%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; , time.localtime())

&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;18-12-08&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt; time.strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y-%m-%d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , time.localtime())&lt;p&gt;'2018-12-08'
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;&amp;gt;&amp;gt;&amp;gt; time.strftime('%Y年%m月%d日 %M时%I分%S秒' , time.localtime())&lt;/p&gt;
&lt;p&gt;'2018年12月08日 34时10分04秒'&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;　　6）strptime(string, format)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; time.strptime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;2018年12月08日 34时10分04秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; , &lt;span&gt;'&lt;/span&gt;&lt;span&gt;%Y年%m月%d日 %M时%I分%S秒&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

time.struct_time(tm_year&lt;/span&gt;=2018, tm_mon=12, tm_mday=8, tm_hour=10, tm_min=34, tm_sec=4, tm_wday=5, tm_yday=342, tm_isdst=-1)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7）asctime(p_tuple=None)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; time.asctime() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不传入参数，默认是当前时间&lt;/span&gt;

&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sat Dec  8 22:42:46 2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt; time.asctime(time.localtime(1544278402.1804464&lt;span&gt;))

&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sat Dec  8 22:13:22 2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8）ctime(seconds=None)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; time.ctime() &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不传入参数&lt;/span&gt;

&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sat Dec  8 22:45:58 2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;

&amp;gt;&amp;gt;&amp;gt; time.ctime(1544278402.1804464&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Sat Dec  8 22:13:22 2018&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　datetime模块是time模块的进一步封装，对用户更加友好，在时间各属性的获取上回更加方便一些，当然，在效率上会略微低一些。datetime模块的功能主要都几种在datetime、date、time、timedelta、tzinfo五个类中。这五个类功能如下表所示：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;类名&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;421&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;date&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;421&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;提供日期（年、月、日）的处理&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;time&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;421&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;提供时间（时、分、秒）的处理&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;datetime&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;421&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;同时提供对日期和时间的处理&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;timedelta&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;421&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;两个date、time、datetime实例之间的时间间隔（时间加减运算）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;132&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;tzinfo&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;421&quot;&gt;
&lt;p&gt;时区信息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;4.1 date类&lt;/h2&gt;
&lt;p&gt;　　先来说说date类，其定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; datetime.date(year, month, day)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;strong&gt;year, month 和 day都是是必须参数，各参数的取值范围为：&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;参数名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;取值范围&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;year&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;[MINYEAR, MAXYEAR]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;month&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;[1, 12]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;day&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;[1, 指定年份的月份中的天数]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;　　类方法和属性&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;类方法/属性名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;date.max&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;date对象所能表示的最大日期：9999-12-31&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;date.min&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;date对象所能表示的最小日志：00001-01-01&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;date.resoluation&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;date对象表示的日期的最小单位：天&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;date.today()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回一个表示当前本地日期的date对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;date.fromtimestamp(timestamp)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;根据跟定的时间戳，返回一个date对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;　　对象方法和属性&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;14&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;对象方法/属性名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.year&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot;&gt;
&lt;p&gt;年&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.month&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot;&gt;
&lt;p&gt;月&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.day&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot;&gt;
&lt;p&gt;日&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.replace(year[, month[, day]])&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;生成并返回一个新的日期对象，原日期对象不变&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.timetuple()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回日期对应的time.struct_time对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.toordinal()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回日期是是自 0001-01-01 开始的第多少天&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.weekday()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;返回日期是星期几，[0, 6]，0表示星期一&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.isoweekday()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;返回日期是星期几，[1, 7], 1表示星期一&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.isocalendar()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;返回一个元组，格式为：(year, weekday, isoweekday)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.isoformat()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回‘YYYY-MM-DD’格式的日期字符串&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;207&quot;&gt;
&lt;p&gt;&lt;strong&gt;d.strftime(format)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;645&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;返回指定格式的日期字符串，与time模块的strftime(format, struct_time)功能相同&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;4.2 time类&lt;/h2&gt;
&lt;p&gt;　　定义格式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; datetime.time(hour, [minute[, second, [microsecond[, tzinfo]]]])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　hour为必须参数，其他为可选参数。各参数的取值范围为：&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;参数名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;取值范围&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;hour&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;[0, 23]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;minute&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;[0, 59]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;second&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;[0, 59]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;microsecond&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;[0, 1000000]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;tzinfo&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;tzinfo的子类对象，如timezone类的实例&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;　　类方法和属性&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;类方法/属性名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;time.max&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;time类所能表示的最大时间：time(23, 59, 59, 999999)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;time.min&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;time类所能表示的最小时间：time(0, 0, 0, 0)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;time.resolution&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;时间的最小单位，即两个不同时间的最小差值：1微秒&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;　　对象方法和属性&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;8.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;center&quot;&gt;对象方法/属性名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;center&quot;&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.hour&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;时&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.minute&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;分&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.second&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;秒&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.microsecond&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;微秒&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.tzinfo&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回传递给time构造方法的tzinfo对象，如果该参数未给出，则返回None&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.replace(hour[, minute[, second[, microsecond[, tzinfo]]]])&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;生成并返回一个新的时间对象，原时间对象不变&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.isoformat()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;返回一个‘HH:MM:SS.%f’格式的时间字符串&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;t.strftime()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;返回指定格式的时间字符串，与time模块的strftime(format, struct_time)功能相同&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;4.3 datetime类&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;　　datetime类的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; datetime.datetime(year, month, day, hour=0, minute=0, second=0, microsecond=0, tzinfo=None)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　year, month 和 day是必须要传递的参数， tzinfo可以是None或tzinfo子类的实例。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;各参数的取值范围为：&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;参数名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;取值范围&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;year&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[MINYEAR, MAXYEAR]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;month&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[1, 12]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;day&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[1, 指定年份的月份中的天数]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;hour&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[0, 23]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;minute&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[0, 59]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;second&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[0, 59]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;microsecond&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;[0, 1000000]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;tzinfo&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;tzinfo的子类对象，如timezone类的实例&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;left&quot;&gt;　　如果一个参数超出了这些范围，会引起ValueError异常。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;　　类方法和属性:&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;类方法/&lt;/strong&gt;&lt;strong&gt;属性名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.today()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回一个表示当前本期日期时间的datetime对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.now([tz])&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回指定时区日期时间的datetime对象，如果不指定tz参数则结果同上&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.utcnow()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回当前utc日期时间的datetime对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.fromtimestamp(timestamp[, tz])&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;根据指定的时间戳创建一个datetime对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.utcfromtimestamp(timestamp)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;根据指定的时间戳创建一个datetime对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.combine(date, time)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;把指定的date和time对象整合成一个datetime对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;datetime.strptime(date_str, format)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;将时间字符串转换为datetime对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;对象方法和属性:&lt;/strong&gt;&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;对象方法/&lt;/strong&gt;&lt;strong&gt;属性名称&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.year, dt.month, dt.day&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;年、月、日&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.hour, dt.minute, dt.second&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;时、分、秒&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.microsecond, dt.tzinfo&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;微秒、时区信息&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.date()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;获取datetime对象对应的date对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.time()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;获取datetime对象对应的time对象， tzinfo 为None&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.timetz()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;获取datetime对象对应的time对象，tzinfo与datetime对象的tzinfo相同&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;18&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;12&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.replace([year[, month[, day[, hour[, minute[, second[, microsecond[, tzinfo]]]]]]]])&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p align=&quot;left&quot;&gt;生成并返回一个新的datetime对象，如果所有参数都没有指定，则返回一个与原datetime对象相同的对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.timetuple()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回datetime对象对应的tuple（不包括tzinfo）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.utctimetuple()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回datetime对象对应的utc时间的tuple（不包括tzinfo）&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.toordinal()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;同date对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.weekday()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;同date对象&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.isocalendar()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;同date独享&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.isoformat([sep])&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回一个‘%Y-%m-%d&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.ctime()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;等价于time模块的time.ctime(time.mktime(d.timetuple()))&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;dt.strftime(format)&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;返回指定格式的时间字符串&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;　　上面是date、time、datetime三个类的方法和属性，关于这三个类，使用方法上基本与time模块差不多，看方法名基本就一目了然，实在忘记，直接查表就好，本文不在过多介绍。&lt;/p&gt;
&lt;h2&gt;4.4 timedelta类&lt;/h2&gt;
&lt;p&gt;　　timedelta可以方便实现日期（date实例、time实例、datetime实例）之间的加减运算。&lt;/p&gt;
&lt;p&gt;　　datetime.timedelta类的定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, hours=0, weeks=0)
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
　　所有参数都是默认参数，因此都是可选参数。参数的值可以是整数或浮点数，也可以是正数或负数。内部值存储days、seconds 和 microseconds，其他所有参数都将被转换成这3个单位：
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;1毫秒转换为1000微秒&lt;/li&gt;
&lt;li&gt;1分钟转换为60秒&lt;/li&gt;
&lt;li&gt;1小时转换为3600秒&lt;/li&gt;
&lt;li&gt;1周转换为7天&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　然后对这3个值进行标准化，使得它们的表示是唯一的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;microseconds : [0, 999999]&lt;/li&gt;
&lt;li&gt;seconds : [0, 86399]&lt;/li&gt;
&lt;li&gt;days : [-999999999, 999999999]&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;　　类属性:&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;类属性名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;timedelta.min&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;timedelta(-999999999)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;timedelta.max&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;timedelta(days=999999999, hours=23, minutes=59, seconds=59, microseconds=999999)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;timedelta.resolution&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;timedelta(microseconds=1)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4&gt;　　实例方法和属性:&lt;/h4&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;实例方法/属性名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;描述&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4.5&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;td.days&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;天 [-999999999, 999999999]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;td.seconds&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;秒 [0, 86399]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;td.microseconds&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;微秒 [0, 999999]&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot;&gt;
&lt;p&gt;&lt;strong&gt;td.total_seconds()&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;时间差中包含的总秒数，等价于: td / timedelta(seconds=1)&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;　　对于Python中时间、日期模块的应用主要集中在time模块和datetime模块中，其中涉及到的方法和属性有些多容易混淆，可以以time模块为出发点，只要理清time模块中3种时间格式之间的关系，就容易记忆了。&lt;/p&gt;
&lt;p&gt;　　参考资料：&lt;/p&gt;
&lt;p&gt;　　https://blog.csdn.net/p9bl5bxp/article/details/54945920&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 14:53:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>在实际开发过程中，我们经常会用到日期或者时间，那么在Python中我们怎么获取时间，以及如何将时间装换位我们需要的格式呢？在之前的开发中，也曾遇到time、datetime等模块下的不同函数，这些函数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenhuabin/p/10099766.html</dc:identifier>
</item>
<item>
<title>Python面向对象基础：编码细节和注意事项 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10099735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10099735.html</guid>
<description>&lt;p&gt;在前面，我用了3篇文章解释python的面向对象：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9965110.html&quot;&gt;面向对象：从代码复用开始&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/10091181.html&quot;&gt;面向对象：设置对象属性&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/10094021.html&quot;&gt;类和对象的名称空间&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;本篇是第4篇，用一个完整的示例来解释面向对象的一些细节。&lt;/p&gt;
&lt;p&gt;例子的模型是父类Employe和子类Manager，从类的定义开始，一步步完善直到类变得完整。&lt;/p&gt;

&lt;h2 id=&quot;定义person类&quot;&gt;定义Person类&lt;/h2&gt;
&lt;p&gt;现在，假设Employe类有3个属性：名字name、职称job和月薪水pay。&lt;/p&gt;
&lt;p&gt;定义这个类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Employe():
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里为&lt;code&gt;__init__()&lt;/code&gt;的job参数提供了默认值：None，表示这个员工目前没有职称。对于没有职称的人，pay当然也应该是0。这样创建Employe对象的时候，可以只给参数name。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if __name__ == &quot;__main__&quot;:
    longshuai = Employe(&quot;Ma Longshuai&quot;)
    xiaofang = Employe(&quot;Gao Xiaofang&quot;, job=&quot;accountant&quot;, pay=15000)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的if判断表示这个py文件如果当作可执行程序而不是模块，则执行if内的语句，如果是以模块的方式导入这个文件，则if内的语句不执行。这种用法在测试模块代码的时候非常方便。&lt;/p&gt;
&lt;p&gt;运行该py文件，得到结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;__main__.Employe object at 0x01321690&amp;gt;
&amp;lt;__main__.Employe object at 0x01321610&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;添加方法&quot;&gt;添加方法&lt;/h2&gt;
&lt;p&gt;每个Employe对象的name属性由姓、名组成，中间空格分隔，现在想取出每个对象的名。对于普通的&lt;code&gt;姓 名&lt;/code&gt;字符串，可以使用字符串工具的split()函数来处理。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; name = &quot;Ma Longshuai&quot;
&amp;gt;&amp;gt;&amp;gt; name.split()[-1]
'Longshuai'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是可以在longshuai和xiaofang这两个Employe对象上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(longshuai.name.split()[-1])
print(xiaofang.name.split()[-1])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Longshuai
Xiaofang&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与之类似的，如果想要为员工按10%加薪水，可以在每个Employe对象上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;xiaofang.pay *= 1.1
print(xiaofang.pay)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论是截取name的名部分，还是加薪水的操作，都是Employe共用的，每个员工都可以这样来操作。所以，更合理的方式是将它们定义为类的方法，以便后续的代码复用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Employe():
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay

    def lastName(self):
        return self.name.split()[-1]

    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))

if __name__ == &quot;__main__&quot;:
    longshuai = Employe(&quot;Ma Longshuai&quot;)
    xiaofang = Employe(&quot;Gao Xiaofang&quot;, job=&quot;accountant&quot;, pay=15000)
    
    print(longshuai.lastName())
    print(xiaofang.lastName())
    xiaofang.giveRaise(0.10)
    print(xiaofang.pay)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的giveRaise()方法中使用了int()进行类型转换，因为整数乘以一个小数，返回结果会是一个小数(例如&lt;code&gt;15000 * 0.1 = 1500.0&lt;/code&gt;)。这里我们不想要这个小数，所以使用int()转换成整数。&lt;/p&gt;

&lt;h2 id=&quot;定义子类并重写父类方法&quot;&gt;定义子类并重写父类方法&lt;/h2&gt;
&lt;p&gt;现在定义Employe的子类Manager。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Manager(Employe):&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Manager的薪水计算方式是在原有薪水上再加一个奖金白分别，所以要重写父类的giveRaise()方法。有两种方式可以重写：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;完全否定父类方法&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;在父类方法的基础上进行扩展&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;虽然有了父类的方法，拷贝修改很方便，但第一种重写方式仍然是不合理的。合理的方式是采用第二种。&lt;/p&gt;
&lt;p&gt;下面是第一种方式重写：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Manager(Employe):
    def giveRaise(self, percent, bonus=0.10):
        self.pay = int(self.pay * (1 + percent + bonus))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种重写方式逻辑很简单，但是完全否定了父类的giveRaise()方法，完完全全地重新定义了自己的方法。这种方式不合理，因为如果修改了Employe中的giveRaise()计算方法，Manager中的giveRaise()方法也要修改。&lt;/p&gt;
&lt;p&gt;下面是第二种在父类方法基础上扩展，这是合理的重写方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Manager(Employe):
    def giveRaise(self, percent, bonus=0.10):
        Employe.giveRaise(self, percent + bonus)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二种方式是在自己的giveRaise()方法中调用父类的giveRaise()方法。这样的的好处是在需要修改薪水计算方式时，要么只需修改Employe中的，要么只需修改Manager中的，不会同时修改多个。&lt;/p&gt;
&lt;p&gt;另外注意，上面是通过硬编码的类名Employe来调用父类方法的，python中没有其它方法，只能通过这种硬编码的方式。但好在并没有任何影响。因为调用时明确指定了第一个参数为self，而self代表的是对象自身，所以逻辑上仍然是对本对象的属性self.pay进行修改。&lt;/p&gt;
&lt;p&gt;测试下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if __name__ == &quot;__main__&quot;:
    wugui = Manager(&quot;Wu Xiaogui&quot;, &quot;mgr&quot;, 15000)
    wugui.giveRaise(0.1, 0.1)
    print(wugui.pay)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般在重写方法的时候，只要允许，就应该选择在父类基础上进行扩展重写。如果真的需要定义完全不同的方法，可以不要重写，而是在子类中定义新的方法。当然，如果真的有需求要重写，且又要否定父类方法，那也没办法，不过这种情况基本上都是因为在类的设计上不合理。&lt;/p&gt;

&lt;h2 id=&quot;定制子类构造方法&quot;&gt;定制子类构造方法&lt;/h2&gt;
&lt;p&gt;对于子类Manager，每次创建对象的时候其实没有必要去传递一个参数&quot;job=mgr&quot;的参数，因为这是这个子类自然具备的。于是，在构造Manager对象的时候，可以让它自动设置&quot;job=mgr&quot;。&lt;/p&gt;
&lt;p&gt;所以，在Manager类中重写&lt;code&gt;__init__()&lt;/code&gt;。既然涉及到了重写，就有两种方式：(1)完全否定父类方法，(2)在父类方法上扩展。无论何时，总应当选第二种。&lt;/p&gt;
&lt;p&gt;以下是Manager类的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Manager(Employe):
    def __init__(self, name, pay):
        Employe.__init__(self, name, &quot;mgr&quot;, pay)

    def giveRaise(self, percent, bonus=0.10):
        Employe.giveRaise(self, percent + bonus)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在构造Manager对象的时候，只需给name和pay就可以：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if __name__ == &quot;__main__&quot;:
    wugui = Manager(&quot;Wu Xiaogui&quot;, 15000)
    wugui.giveRaise(0.1, 0.1)
    print(wugui.pay)&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;子类必须重写方法&quot;&gt;子类必须重写方法&lt;/h2&gt;
&lt;p&gt;有些父类中的方法可能会要求子类必须重写。&lt;/p&gt;
&lt;p&gt;本文的这个示例不好解释这一点。下面简单用父类Animal、子类Horse、子类Sheep、子类Cow来说明，这个例子来源于我写的面向对象相关的第一篇文章：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9965110.html&quot;&gt;从代码复用开始&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;现在要为动物定义叫声speak()方法，方法的作用是输出&quot;谁发出了什么声音&quot;。看代码即可理解：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Animal:
    def __init__(self, name):
        self.name = name
    def speak(self):
        print(self.name + &quot; speak &quot; + self.sound())
    def sound(self):
        raise NotImplementedError(&quot;you must override this method&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这段代码中，speak()方法调用了sound()方法，但Animal类中的sound()方法却明确抛出异常&quot;你必须自己实现这个方法&quot;。&lt;/p&gt;
&lt;p&gt;为什么呢？因为每种动物发出的叫声不同，而这里又是通过方法来返回叫声的，不是通过属性来表示叫声的，所以每个子类必须定义自己的叫声。如果子类不定义sound()，子类对象调用&lt;code&gt;self.sound()&lt;/code&gt;就会搜索到父类Animal的名称空间上，而父类的sound()会抛出错误。&lt;/p&gt;
&lt;p&gt;现在在子类中重写sound()，但是Cow不重写。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Horse(Animal):
    def sound(self):
        return &quot;neigh&quot;

class Sheep(Animal):
    def sound(self):
        return &quot;baaaah&quot;

class Cow(Animal):
    pass&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;h = Horse(&quot;horseA&quot;)
h.speak()

s = Sheep(&quot;sheepA&quot;)
s.speak()

c = Cow(&quot;cowA&quot;)
c.speak()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果正如预期，h.speak()和s.speak()都正常输出，但c.speak()会抛出&quot;you must override this method&quot;的异常。&lt;/p&gt;
&lt;p&gt;再考虑一下，如果父类中不定义sound()会如何？同样会在c.speak()时抛出错误。虽然都会终止程序，但是这已经脱离了面向对象的代码复用原则：对于对象公有的属性，都应该抽取到类中，对于类所公有的属性，都应该抽取到父类中。sound()显然是每种动物都应该具备的属性，要么定义为子类变量，要么通过类方法来返回。&lt;/p&gt;
&lt;p&gt;之前也提到过，如果可以，尽量不要定义类变量，因为这破坏了面向对象的封装原则，打开了&quot;黑匣子&quot;。所以最合理的方法，还是每个子类重写父类的sound()，且父类中的sound()强制要求子类重写。&lt;/p&gt;

&lt;h2 id=&quot;运算符重载&quot;&gt;运算符重载&lt;/h2&gt;
&lt;p&gt;如果用print()去输出我们自定义的类的对象，比如Employe对象，得到的都是一个元数据信息，比如包括类型和地址。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(longshuai)
print(xiaofang)

## 结果：
&amp;lt;__main__.Employe object at 0x01321690&amp;gt;
&amp;lt;__main__.Employe object at 0x01321610&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以自定义print()如何输出对象，只需定义类的&lt;code&gt;__str__()&lt;/code&gt;方法即可。只要在类中自定义了这个方法，print()输出对象的时候，就会自动调用这个&lt;code&gt;__str__()&lt;/code&gt;取得返回值，并将返回值输出。&lt;/p&gt;
&lt;p&gt;例如，在输出每个Employe对象的时候，都输出它的name、job、pay，并以一种自定义的格式输出。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Employe():
    def __init__(self, name, job=None, pay=0):
        self.name = name
        self.job = job
        self.pay = pay

    def lastName(self):
        return self.name.split()[-1]

    def giveRaise(self, percent):
        self.pay = int(self.pay * (1 + percent))

    ## 重载__str__()方法
    def __str__(self):
        return &quot;[Employe: %s, %s, %s]&quot; % (self.name, self.job, self.pay)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在再print()输出对象，将得到这个对象的信息，而不是这个对象的元数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(longshuai)
print(xiaofang)

## 结果：
[Employe: Ma Longshuai, None, 0]
[Employe: Gao Xiaofang, accountant, 15000]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，print()总是会调用对象的&lt;code&gt;__str__()&lt;/code&gt;，如果类中没有定义&lt;code&gt;__str__()&lt;/code&gt;，就会查找父类中的&lt;code&gt;__str__()&lt;/code&gt;。这里Employe的父类是祖先类object，它正好有一个&lt;code&gt;__str__()&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; object.__dict__[&quot;__str__&quot;]
&amp;lt;slot wrapper '__str__' of 'object' objects&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;换句话说，当Employe中定义了&lt;code&gt;__str__()&lt;/code&gt;，就意味着重载了父类object的&lt;code&gt;__str__()&lt;/code&gt;方法。而这个方法正好是被print()调用的，于是将这种行为称之为&quot;&lt;strong&gt;运算符重载&lt;/strong&gt;&quot;。&lt;/p&gt;
&lt;p&gt;可能从print()上感受不到为什么是运算符，换一个例子就很好理解了。&lt;code&gt;__add__()&lt;/code&gt;是决定加号&lt;code&gt;+&lt;/code&gt;运算模式的，比如&lt;code&gt;3 + 2&lt;/code&gt;之所以是5，是因为int类中定义了&lt;code&gt;__add__()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; a=3
&amp;gt;&amp;gt;&amp;gt; type(a)
&amp;lt;class 'int'&amp;gt;

&amp;gt;&amp;gt;&amp;gt; int.__dict__[&quot;__add__&quot;]
&amp;lt;slot wrapper '__add__' of 'int' objects&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这使得每次做数值加法运算的时候，都会调用这个&lt;code&gt;__add__()&lt;/code&gt;来决定如何做加法：&lt;/p&gt;
&lt;p&gt;实际上在类中定义构造函数&lt;code&gt;__init__()&lt;/code&gt;也是运算符重载，它在每次创建对象的时候被调用。&lt;/p&gt;
&lt;p&gt;还有很多运算符可以重载，加减乘除、字符串串联、大小比较等等和运算符有关、无关的都可以被重载。在后面，会专门用一篇文章来介绍运算符重载。&lt;/p&gt;

&lt;h2 id=&quot;序列化&quot;&gt;序列化&lt;/h2&gt;
&lt;p&gt;对象也是一种数据结构，数据结构可以进行序列化。通过将对象序列化，可以实现对象的本地持久性存储，还可以通过网络套接字发送给网络对端，然后通过反序列化可以还原得到完全相同的原始数据。&lt;/p&gt;
&lt;p&gt;序列化非本文内容，此处仅是介绍一下该功能，后面我会写几篇专门介绍python序列化的文章。&lt;/p&gt;
</description>
<pubDate>Mon, 10 Dec 2018 14:48:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>在前面，我用了3篇文章解释python的面向对象： 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10099735.html</dc:identifier>
</item>
</channel>
</rss>