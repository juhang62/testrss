<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用存储过程向数据库添加大量数据【mysql】 - fyter</title>
<link>http://www.cnblogs.com/fyter/p/stored_procedure_gen_much_data.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fyter/p/stored_procedure_gen_much_data.html</guid>
<description>&lt;p&gt;预分配ID的设计，需要先为数据库生成大量的数据。比如对用户ID有要求的系统，那么用户ID就要预先生成。&lt;/p&gt;

&lt;p&gt;通过python，php，c/c++/c#，js等程序生成也是可以，但需要这些程序环境，而且单条插入太慢，又因为数据包大小问题，需要切割INSERT语句。还要写连接字符串，安装组件等等，比较麻烦。&lt;/p&gt;
&lt;p&gt;我写了一个通过存储过程即可实现大批量插入的代码，虽然也是要切割，但减少了很多环节，使数据库部分更完整，更容易分发与部署。&lt;/p&gt;
&lt;p&gt;其核心思想是拼接字符串concat，执行execute，大于1万行则分开执行。&lt;/p&gt;
&lt;p&gt;首先创建测试用的表:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;TABLE&lt;/span&gt;&lt;span&gt; `map` (
  `id` &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;(&lt;span&gt;11&lt;/span&gt;) &lt;span&gt;NOT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt; AUTO_INCREMENT,
  `gp` point &lt;/span&gt;&lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;NULL&lt;/span&gt;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;PRIMARY&lt;/span&gt; &lt;span&gt;KEY&lt;/span&gt;&lt;span&gt; (`id`)
) ENGINE&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;InnoDB;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后是存储过程:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CREATE&lt;/span&gt; &lt;span&gt;PROCEDURE&lt;/span&gt; `init_map`(&lt;span&gt;in&lt;/span&gt; &lt;span&gt;count&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;BEGIN&lt;/span&gt;
    &lt;span&gt;declare&lt;/span&gt; jump &lt;span&gt;int&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;count&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;WHILE&lt;/span&gt; jump&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt; DO &lt;span&gt;BEGIN&lt;/span&gt;
        &lt;span&gt;DECLARE&lt;/span&gt; i &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;DECLARE&lt;/span&gt; c &lt;span&gt;INT&lt;/span&gt; &lt;span&gt;DEFAULT&lt;/span&gt;&lt;span&gt; jump;
        &lt;/span&gt;&lt;span&gt;IF&lt;/span&gt; c&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt; &lt;span&gt;THEN&lt;/span&gt;
            &lt;span&gt;SET&lt;/span&gt; c&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;END&lt;/span&gt; &lt;span&gt;IF&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@sq&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;concat(&quot;&lt;span&gt;INSERT&lt;/span&gt; &lt;span&gt;INTO&lt;/span&gt; map(gp) &lt;span&gt;VALUES&lt;/span&gt; (st_geomfromtext(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POINT(&quot;,(rand()*50+75),&quot; &quot;,(rand()*50+75),&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))&quot;);
        &lt;/span&gt;&lt;span&gt;WHILE&lt;/span&gt; i&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;c DO
          &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; &lt;span&gt;@sq&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;concat(&lt;span&gt;@sq&lt;/span&gt;,&quot;,(st_geomfromtext(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;POINT(&quot;,(rand()*50+75),&quot; &quot;,(rand()*50+75),&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))&quot;);
          &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; i&lt;span&gt;=&lt;/span&gt;i&lt;span&gt;+&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;END&lt;/span&gt; &lt;span&gt;WHILE&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;@sq&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;PREPARE&lt;/span&gt; s &lt;span&gt;FROM&lt;/span&gt; &lt;span&gt;@sq&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;EXECUTE&lt;/span&gt;&lt;span&gt; s;
        &lt;/span&gt;&lt;span&gt;DEALLOCATE&lt;/span&gt; &lt;span&gt;PREPARE&lt;/span&gt;&lt;span&gt; s;
        &lt;/span&gt;&lt;span&gt;SET&lt;/span&gt; jump&lt;span&gt;=&lt;/span&gt;jump&lt;span&gt;-&lt;/span&gt;&lt;span&gt;c;
    &lt;/span&gt;&lt;span&gt;END&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;END&lt;/span&gt; &lt;span&gt;WHILE&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;END&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 然后是执行存储过程，10万行，观察时间，当然是很快的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;CALL&lt;/span&gt; init_map(&lt;span&gt;100000&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 21 Dec 2018 07:36:00 +0000</pubDate>
<dc:creator>fyter</dc:creator>
<og:description>预分配ID的设计，需要先为数据库生成大量的数据。比如对用户ID有要求的系统，那么用户ID就要预先生成。 通过python，php，c/c++/c#，js等程序生成也是可以，但需要这些程序环境，而且单条</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fyter/p/stored_procedure_gen_much_data.html</dc:identifier>
</item>
<item>
<title>Git Hooks、GitLab CI持续集成以及使用Jenkins实现自动化任务 - 我们家的小常客</title>
<link>http://www.cnblogs.com/mycognos/p/10155978.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mycognos/p/10155978.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在一个共享项目（或者说多人协同开发的项目）的开发过程中，为有效确保团队成员编码风格的统一，确保部署方式的统一，等等（git的用户经常会涉及到此类场景），常常会使用类似 &lt;a href=&quot;http://flc.io/2015/12/381.html&quot;&gt;Git Flow&lt;/a&gt; 这种比较复杂的工作流开发模式。在较大型的项目中，虽然这种工作流模式比较成熟，但在分支处理方面，这种工作流就会造成较多的重复劳动。&lt;/p&gt;
&lt;p&gt;因此，如果能借助某些工具来&lt;strong&gt;自动化处理这些重复性事务&lt;/strong&gt;，比如&lt;strong&gt;自动合并分支&lt;/strong&gt;，那么对于提升我们的工作效率，将会有很大的帮助。&lt;/p&gt;
&lt;p&gt;本文将从以下三种方法对&lt;strong&gt;自动化任务处理&lt;/strong&gt;做介绍，并对每一种方法的优缺点做个简单的总结，以及在实际工作中我们该如何做出选择。&lt;/p&gt;
&lt;h4 id=&quot;三种实现方法&quot;&gt;三种实现方法：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;客户端与服务端 Git hooks&lt;/li&gt;
&lt;li&gt;GitLab-Runner 以及编写 .gitlab-ci.yml 文件&lt;/li&gt;
&lt;li&gt;GitLab Webhooks 与 Jenkins 的配合使用&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;git-钩子&quot;&gt;Git 钩子&lt;/h2&gt;
&lt;p&gt;Git hooks是基于事件的。当你执行特定的git指令时，该软件会从git仓库下的hooks目录下检查是否有相对应的脚本，如果有就执行。&lt;/p&gt;
&lt;p&gt;有些脚本是在动作执行之前被执行的，这种“先行脚本”可用于实现代码规范的统一、完整性检查、环境搭建等功能。有些脚本则在事件之后被执行，这种“后行脚本”可用于实现代码的部署、权限错误纠正（git在这方面的功能有点欠缺）等功能。&lt;/p&gt;
&lt;h3 id=&quot;安装一个钩子&quot;&gt;安装一个钩子&lt;/h3&gt;
&lt;p&gt;钩子都被存储在Git目录下的hooks子目录中。也即绝大部分项目中的.git/hooks。当你用git init初始化一个新版本库时，Git 默认会在这个目录中放置一些示例脚本。这些脚本除了本身可以被调用外，它们还暴露了被触发时所传入的参数。这些示例的名字都是以 .sample 结尾，如果想启用它们，移除这个后缀即可。&lt;/p&gt;
&lt;p&gt;把一个正确命名且可执行的文件放入 Git 目录下的 hooks 子目录中，即可激活该钩子脚本。这样一来，它就能 被 Git 调用。&lt;/p&gt;
&lt;h3 id=&quot;客户端和服务器端-git-hooks&quot;&gt;客户端和服务器端 Git hooks&lt;/h3&gt;
&lt;p&gt;git hooks 采用 事件机制, 在相应的操作(比如 git commit / git merge)下触发, 分为 2 种:&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;服务端 hooks, github 的 webhooks 就是在此基础上建立起来的；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;客户端 hooks, 每个 git 版本库的 .git/hooks/ 文件夹下就有可以使用的例子。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意: 客户端 hooks 并不会同步到版本库中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;客户端钩子由诸如提交和合并这样的操作所调用，而服务器端钩子作用于诸如接收被推送的提交这样的联网操作。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;客户端钩子位于项目根目录 your_project/.git/hooks 文件夹下&lt;/p&gt;
&lt;p&gt;服务端钩子则位于 your_project.git 文件夹下的 hooks 和 custom_hooks&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;hooks与custom_hooks文件夹&quot;&gt;hooks与custom_hooks文件夹&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414425/201812/1414425-20181221152123396-1023631782.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414425/201812/1414425-20181221152130647-151700382.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到GitLab为我们创建了一个软连接连接到了GitLab自定义的钩子目录,这样所有创建的项目都可以使用同一个脚本规则，减少了维护成本。&lt;/p&gt;
&lt;p&gt;那我们如何结合GitLab定制自己的脚本呢？git会首先触发GitLab的脚本，然后GitLab执行完自己的脚本文件后会再调用掉用户放在custom_hooks下的脚本，所以我们只需要将我们定制好的脚本放在custom_hooks下即可，脚本名称和之前一样。例如：touch post-receive，这个脚本理论上可以使用任何脚本语言例如Perl、Python、Ruby等，不过执行这个脚本的用户将是git，要注意git用户对系统的操作权限，还要注意post-receive这个脚本需要能够有执行权限。&lt;/p&gt;
&lt;h3 id=&quot;客户端与服务端钩子图示&quot;&gt;客户端与服务端钩子图示&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414425/201812/1414425-20181221152153512-1700902063.png&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;图片来自于网络&quot;&gt;（图片来自于网络）&lt;/h6&gt;
&lt;h3 id=&quot;示例&quot;&gt;示例&lt;/h3&gt;
&lt;h4 id=&quot;post-receive-推送代码后自动部署&quot;&gt;post-receive 推送代码后自动部署&lt;/h4&gt;
&lt;p&gt;将目录切换至 ../BRIDGE_REPO.git/hooks，用 cp post-receive.sample post-receive 复制并重命名文件后用 vim post-receive 修改。其内容大致如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/sh

unset GIT_DIR

NowPath=`pwd`
DeployPath=&quot;../../www&quot;

cd $DeployPath
git pull origin master

cd $NowPath
exit 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 chmod +x post-receive 改变一下权限即可，服务器端的配置就基本完成了。&lt;/p&gt;
&lt;h2 id=&quot;gitlab-ci与gitlab-runner&quot;&gt;GitLab-CI与GitLab-Runner&lt;/h2&gt;
&lt;h3 id=&quot;持续集成continuous-integration&quot;&gt;持续集成（Continuous Integration）&lt;/h3&gt;
&lt;p&gt;要了解GitLab-CI与GitLab Runner，我们得先了解持续集成是什么。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;持续集成是一种软件开发实践，即团队开发成员经常集成他们的工作，通常每个成员每天至少集成一次，也就意味着每天可能会发生多次集成。每次集成都通过自动化的构建（包括编译，发布，自动化测试)来验证，从而尽快地发现集成错误。许多团队发现这个过程可以大大减少集成的问题，让团队能够更快的开发内聚的软件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;gitlab-ci&quot;&gt;GitLab-CI&lt;/h3&gt;
&lt;p&gt;GitLab-CI就是一套配合GitLab使用的持续集成系统（当然，还有其它的持续集成系统，同样可以配合GitLab使用，比如接下来要说的Jenkins）。&lt;/p&gt;
&lt;p&gt;持续集成，我们通常使用CI来做一些自动化工作，比如程序的打包，单元测试，部署等，这种构建方式避免了打包环境差异引起的错误，提高了工作效率。Gitlab-CI是Gitlab官方提供的持续集成服务，我们可以在仓库的根目录下新建.gitlab-ci.yml文件，自己定义&lt;strong&gt;持续集成流程模板&lt;/strong&gt;，并且在Gitlab中配置runner，在之后的每次提交或合并中将会触发构建，并且可以通过Gitlab的hook, 在代码提交的各个环节自动地完成一系列的构建工作，总之对于一些非复杂性的集成需求，都是可以满足的。&lt;/p&gt;
&lt;p&gt;实际上，GitLab-CI中有一个概念叫 &lt;strong&gt;Pipeline&lt;/strong&gt; ，一次 Pipeline 其实相当于一次构建任务，里面可以包含多个流程，如安装依赖、运行测试、编译、部署测试服务器、部署生产服务器等流程。任何提交或者 Merge Request 的合并都可以触发 Pipeline。&lt;/p&gt;
&lt;p&gt;思考：&lt;br/&gt;为什么不是 GitLab CI 来运行那些构建任务？&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;一般来说，构建任务都会占用很多的系统资源 (譬如编译代码)，而 GitLab CI 又是 GitLab 的一部分，如果由 GitLab CI 来运行构建任务的话，在执行构建任务的时候，GitLab 的性能会大幅下降。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;GitLab CI 最大的作用是管理各个项目的构建状态，因此，运行构建任务这种浪费资源的事情就交给 GitLab Runner 来做了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为 GitLab Runner 可以安装到不同的机器上，所以在构建任务运行期间并不会影响到 GitLab 的性能~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;gitlab-runner&quot;&gt;GitLab-Runner&lt;/h3&gt;
&lt;p&gt;GitLab-Runner是配合GitLab-CI进行使用的。一般地，GitLab里面的每一个工程都会定义一个属于这个工程的软件集成脚本，用来自动化地完成一些软件集成工作。当这个工程的仓库代码发生变动时，比如有人push了代码，GitLab就会将这个变动通知GitLab-CI。这时GitLab-CI会找出与这个工程相关联的Runner，并通知这些Runner把代码更新到本地并执行预定义好的执行脚本。&lt;/p&gt;
&lt;p&gt;所以，GitLab-Runner就是一个用来执行软件集成脚本的东西。你可以想象一下：Runner就像一个个的工人，而GitLab-CI就是这些工人的一个管理中心，所有工人都要在GitLab-CI里面登记注册，并且表明自己是为哪个工程服务的。当相应的工程发生变化时，GitLab-CI就会通知相应的工人执行软件集成脚本。&lt;/p&gt;
&lt;h4 id=&quot;runner一共有三种类型&quot;&gt;Runner一共有三种类型&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;本地Runner&lt;/li&gt;
&lt;li&gt;普通的服务器上的Runner&lt;/li&gt;
&lt;li&gt;基于Docker的Runner&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;mac环境安装gitlab-ci-multi-runner&quot;&gt;MAC环境安装gitlab-ci-multi-runner&lt;/h3&gt;
&lt;h6 id=&quot;具体说下gitlab-runner-register&quot;&gt;具体说下gitlab-runner register&lt;/h6&gt;
&lt;blockquote readability=&quot;4.5428571428571&quot;&gt;
&lt;p&gt;Please enter the gitlab-ci coordinator URL (e.g. &lt;a href=&quot;https://gitlab.com/ci&quot; class=&quot;uri&quot;&gt;https://gitlab.com/ci&lt;/a&gt;):&lt;br/&gt;&lt;a href=&quot;http://xxxxxx&quot; class=&quot;uri&quot;&gt;http://xxxxxx&lt;/a&gt; // 在这里输入gitlab安装的服务器ip/ci 即可&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Please enter the gitlab-ci token for this runner:&lt;br/&gt;xxxxxxxxxxxxxxxxxx // 这里的token可通过Gitlab上的项目Runners选项查看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Please enter the gitlab-ci description for this runner:[E5]:demo&lt;br/&gt;// 这里填写一个描述信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Please enter the gitlab-ci tags for this runner (comma separated):&lt;br/&gt;demo // 在这里填写tag信息，多个tag可通过逗号,分割。&lt;br/&gt;tag：一个项目可能有多个runner，是根据tag来区别runner的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Registering runner... succeeded. runner=eaYyokc5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;Please enter the executor: docker, docker-ssh, parallels, shell, ssh, virtualbox, docker+machine, docker-ssh+machine:&lt;br/&gt;shell // 在这里需要输入runner的执行方式，直接输入shell&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded! // 出现这样信息表示服务端的配置就已经成功结束了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;如何编写-.gitlab-ci.yml-文件&quot;&gt;如何编写 .gitlab-ci.yml 文件&lt;/h4&gt;
&lt;p&gt;如果你在项目仓库里面加入.gitlab-ci.yml文件，同时给项目配置了gitlab-runner, 那么每次提交代码或者合并 mr , 都会触发你的 CI Pipeline （持续集成管道）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414425/201812/1414425-20181221152214009-162997384.png&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;stages:
  - deploy
deploy:
    stage: deploy
    script:
      - echo &quot;start deploy.....&quot;
      - deploy
    only:
      - master
    tags:
      - shell&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中deploy是编写的shell脚本，可以实现将要发布的内容自动部署到发布目录下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/bash
deploy_path=&quot;xxx&quot;
project_path=&quot;xxx;
judge_path = &quot;$deploy_path/$project_path&quot;
if [ ! -d &quot;$judge_path&quot; ]
then
   project_url=&quot;xxx.git&quot;
   git clone $project_path $deploy_path
else
   cd $deploy_path
   git pull
fi&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;gitlab-ci.yml配置详解请参考&quot;&gt;.gitlab-ci.yml配置详解请参考：&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://fennay.github.io/gitlab-ci-cn/gitlab-ci-yaml.html&quot;&gt;gitlab ci/cd .gitlab-ci.yml配置详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.gitlab.com/ce/ci/yaml/README.html&quot;&gt;官方GitLab文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Fennay/gitlab-ci-cn&quot;&gt;官方GitLab文档翻译&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;gitlab-webhooks&quot;&gt;Gitlab Webhooks&lt;/h2&gt;
&lt;p&gt;Webhooks 允许第三方应用监听 GitLab 上的特定事件，在这些事件发生时通过 HTTP POST 方式通知( 超时5秒) 到第三方应用指定的 Web URL。 例如项目有新的内容 Push，或是 Merge Request 有更新等。 WebHooks 可方便用户实现自动部署，自动测试，自动打包，监控项目变化等。&lt;/p&gt;
&lt;p&gt;webhooks, 可以在 pull request / merge master 等几个场景下, 设置异步回调通知(http 请求)。这个背后就是 git hooks 在起作用。&lt;/p&gt;
&lt;p&gt;因此，利用 WebHooks 的特性，可配合 Jenkins 实现一系列的自动化任务。&lt;/p&gt;
&lt;h2 id=&quot;jenkins&quot;&gt;Jenkins&lt;/h2&gt;
&lt;p&gt;Jenkins是一个用Java编写的开源的持续集成工具，可以与Git打通，监听Git的merge, push事件，触发执行Jenkins的指定任务(job)。例如发布的任何一个环节都可自动完成，无需太多的人工干预，有利于减少重复过程以节省时间和工作量等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1414425/201812/1414425-20181221152230490-531786834.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;实例jenkinsgitlab-webhooks实现开发分支自动合并&quot;&gt;实例：Jenkins、Gitlab webhooks实现开发分支自动合并&lt;/h3&gt;
&lt;h4 id=&quot;步骤梳理&quot;&gt;步骤梳理&lt;/h4&gt;
&lt;ol&gt;&lt;li&gt;GitLab上准备一个web工程；&lt;/li&gt;
&lt;li&gt;GitLab上配置Jenkins的webhook地址；&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Jenkins安装GitLab Plugin插件；&lt;/li&gt;
&lt;li&gt;Jenkins配置GitLab访问权限；&lt;/li&gt;
&lt;li&gt;Jenkins上创建一个构建项目，对应的源码是步骤1中的web工程；&lt;/li&gt;
&lt;li&gt;修改web工程的源码，并提交到GitLab上；&lt;/li&gt;
&lt;li&gt;检查Jenkins的构建项目是否会触发自动任务脚本。&lt;/li&gt;
&lt;/ol&gt;&lt;h6 id=&quot;jenkins-job-和-gitlab-的关联在网上已经有许多完善的文档了在这里就不赘述了&quot;&gt;（Jenkins Job 和 GitLab 的关联，在网上已经有许多完善的文档了，在这里就不赘述了）&lt;/h6&gt;
&lt;h5 id=&quot;以下为开发分支develop自动合并master分支的脚本示例仅供参考&quot;&gt;以下为开发分支develop自动合并master分支的脚本示例，仅供参考：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;#!/bin/sh
echo *****************Start*****************
date
# 获取最近一次提交的 commit id
sha1=`git rev-parse HEAD`
# 获取姓名及邮箱，来配置git提交者信息
name=`git show $sha1 | grep 'Author:' | cut -d' ' -f2`
email=`git show $sha1 | grep 'Author:' | cut -d' ' -f3 | sed -e 's/&amp;lt;//g' | sed -e 's/&amp;gt;//g'`
echo '当前提交人信息:'
echo $name 
echo $email 
git config --global user.name $name
git config --global user.email $email
echo '***************** git checkout develop &amp;amp; git pull:'
git checkout develop
git pull
# develop合并master
echo '***************** git merge origin/master:'
conflict=`git merge origin/master`
echo $conflict | grep 'CONFLICT'
if [ $? -ne 0 ]; then
    echo '***************** git push origin HEAD:'
    git push origin HEAD
    echo '***************** git status:'
    git status
else
    git status
    echo 'Automatic merge failed...'
    echo 'Please fix conflicts and then commit the result...'
    exit 1
fi
echo *****************End*****************
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;三种实现方法的优缺点对比&quot;&gt;三种实现方法的优缺点对比：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;客户端与服务端 Git hooks ：如果仅涉及客户端钩子，用这种方法比较好，比如 husky 这个插件；但如果是服务端钩子，就必须在服务端配置才可使用，比如 post-receive 钩子；&lt;/li&gt;
&lt;li&gt;GitLab-Runner 以及编写 .gitlab-ci.yml 文件：需服务端安装 gitlab-runner 来支持自动化脚本的执行；&lt;/li&gt;
&lt;li&gt;GitLab Webhooks 与 Jenkins 的配合使用：Jenkins是比较成熟的第三方持续集成系统，可与GitLab完美的结合使用，但配置过程仍是稍显复杂，但在自动化任务处理方面，Jenkins无疑是个较好的选择。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://git.oschina.net/progit/&quot;&gt;Pro Git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.gitlab.com/ce/ci/yaml/README.html&quot;&gt;GitLab 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000356487&quot;&gt;Git Hooks&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/cnundefined/p/7095368.html&quot;&gt;GitLab-CI 与 GitLab-Runner&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;转载请标注出处谢谢httpswww.cnblogs.commycognosp10155978.html&quot;&gt;转载请标注出处，谢谢！&lt;a href=&quot;https://www.cnblogs.com/mycognos/p/10155978.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/mycognos/p/10155978.html&lt;/a&gt;&lt;/h4&gt;
</description>
<pubDate>Fri, 21 Dec 2018 07:25:00 +0000</pubDate>
<dc:creator>我们家的小常客</dc:creator>
<og:description>Git Hooks、GitLab CI持续集成以及使用Jenkins实现自动化任务 前言 在一个共享项目（或者说多人协同开发的项目）的开发过程中，为有效确保团队成员编码风格的统一，确保部署方式的统一，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mycognos/p/10155978.html</dc:identifier>
</item>
<item>
<title>通俗讲解：PoW共识机制与以太坊的关系、Ghost协议 及 PoS共识机制的变种---Casper - 指尖下的幽灵</title>
<link>http://www.cnblogs.com/linguanh/p/10155828.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/linguanh/p/10155828.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：林冠宏 / 指尖下的幽灵&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;0.80357142857143&quot;&gt;
&lt;p&gt;掘金：&lt;a href=&quot;https://juejin.im/user/587f0dfe128fe100570ce2d8&quot; class=&quot;uri&quot;&gt;https://juejin.im/user/587f0dfe128fe100570ce2d8&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.0975609756098&quot;&gt;
&lt;p&gt;博客：&lt;a href=&quot;http://www.cnblogs.com/linguanh/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/linguanh/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.3095238095238&quot;&gt;
&lt;p&gt;GitHub ： &lt;a href=&quot;https://github.com/af913337456/&quot; class=&quot;uri&quot;&gt;https://github.com/af913337456/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.2179487179487&quot;&gt;
&lt;p&gt;腾讯云专栏： &lt;a href=&quot;https://cloud.tencent.com/developer/user/1148436/activities&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/developer/user/1148436/activities&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;1.4814814814815&quot;&gt;
&lt;p&gt;虫洞区块链专栏：&lt;a href=&quot;https://www.chongdongshequ.com/article/1536563643883.html&quot; class=&quot;uri&quot;&gt;https://www.chongdongshequ.com/article/1536563643883.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;h2 id=&quot;前序&quot;&gt;前序&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;本人版暂名为&lt;code&gt;《区块链以太坊DApp实战开发》&lt;/code&gt;一书，即将完成，是一本废话少、讲解通俗、实操性强的技术书籍。本文为书中的小节的部分内容。想涉足这个区块链领域技术开发的同僚可以留意我的博客，届时会发布。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;PoW 共识机制&lt;/li&gt;
&lt;li&gt;以太坊目前所使用的共识算法&lt;/li&gt;
&lt;li&gt;Chost 协议
&lt;ul&gt;&lt;li&gt;选择最长链&lt;/li&gt;
&lt;li&gt;分叉块处理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Casper PoS变种共识机制
&lt;ul&gt;&lt;li&gt;如何成为验证人&lt;/li&gt;
&lt;li&gt;验证人如何获取保证金&lt;/li&gt;
&lt;li&gt;候选区块如何产生&lt;/li&gt;
&lt;li&gt;按照什么规则轮着出块&lt;/li&gt;
&lt;li&gt;如何判断胜出区块&lt;/li&gt;
&lt;li&gt;验证人联盟投注的作弊问题&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;pow-与-pos-共识机制&quot;&gt;PoW 与 PoS 共识机制&lt;/h3&gt;
&lt;p&gt;如果对&lt;code&gt;PoW共识机制&lt;/code&gt;还不了解的朋友，可以看下我之前的一篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5b78f6e46fb9a019e8227162&quot;&gt;PoW共识机制通俗讲解&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5b95d052f265da0a914527e4&quot;&gt;PoS共识机制通俗讲解&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;以太坊目前所使用的共识算法&quot;&gt;以太坊目前所使用的共识算法&lt;/h3&gt;
&lt;p&gt;如果别人问你“&lt;code&gt;以太坊&lt;/code&gt;目前所使用的共识算法”是什么？如果你此时去浏览器搜索发现有些文章说是&lt;code&gt;PoS&lt;/code&gt;，又有些说是&lt;code&gt;PoW&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;完整且正确的说法应该是这样的，这其实也是&lt;code&gt;PoW共识机制&lt;/code&gt;与&lt;code&gt;以太坊&lt;/code&gt;的关系。首先以太坊的源码是分有阶段，不同阶段所使用的共识算法要分开来说。所分的阶段有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Frontier&lt;/code&gt;（前沿）。这个阶段的版本是以太坊的基础，此时的以太坊具备了&lt;code&gt;挖矿&lt;/code&gt;、&lt;code&gt;交易&lt;/code&gt;以及&lt;code&gt;智能合约&lt;/code&gt;功能模块。但是没有供普通用户使用的&lt;code&gt;图形化界面&lt;/code&gt;，仅适合于开发者使用。所使用的共识算法是“PoW”。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Homestead&lt;/code&gt;（家园）。这个阶段的以太坊网络变得更加稳定，且具备了图形界面的钱包软件。所使用的共识算法还是是“PoW”。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Metropolis&lt;/code&gt;（大都会）。分有下面两个子版本：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;拜占庭&lt;/code&gt;。发布了集合钱包功能以及合约发布等丰富功能的图形化界面软件“&lt;code&gt;Mist&lt;/code&gt;”，同时也引入了很多新的技术，例如&lt;code&gt;零知识证明&lt;/code&gt;，抽象账号等。使用的共识算法仍然是“PoW”。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;君士坦丁堡&lt;/code&gt;。使用混合共识算法“PoW + PoS”，为“宁静”做铺垫。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Serenity&lt;/code&gt;（宁静）。将把以太坊的共识算法全部换成基于“PoS”的变种算法--“&lt;code&gt;Casper投注共识&lt;/code&gt;”，它属于&lt;code&gt;PoS&lt;/code&gt;系列。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;截至&lt;code&gt;2018-12-14&lt;/code&gt;，目前以太坊的最新发布版本是&lt;code&gt;Metropolis&lt;/code&gt;大都会的&lt;code&gt;拜占庭&lt;/code&gt;。由上述可知，在以太坊发展的过程中，它的共识算法对于不同的阶段，分别是：&lt;code&gt;PoW共识&lt;/code&gt;,&lt;code&gt;PoW + PoS 共识&lt;/code&gt;和&lt;code&gt;PoS&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;chost-协议&quot;&gt;Chost 协议&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Chost 协议&lt;/code&gt;的全称是“&lt;code&gt;Greedy Heaviest-Observed Sub-Tree protocol&lt;/code&gt;”，贪婪子树协议，又称&lt;code&gt;幽灵协议&lt;/code&gt;，它属于&lt;code&gt;主链选择协议&lt;/code&gt;范畴。&lt;/p&gt;
&lt;p&gt;首先在&lt;code&gt;比特币公链&lt;/code&gt;中，它是根据&lt;code&gt;最长链规则&lt;/code&gt;来解决区块链分叉问题的。请注意，并不是所有的区块链公链解决分叉问题都是使用&lt;code&gt;最长链规则&lt;/code&gt;，以太坊就不是。&lt;/p&gt;
&lt;h4 id=&quot;选择最长链&quot;&gt;选择最长链&lt;/h4&gt;
&lt;p&gt;以太坊解决区块链分叉问题目前所使用的 是&lt;code&gt;Ghost 协议&lt;/code&gt;，所以&lt;code&gt;Ghost&lt;/code&gt;协议的真实作用是用来&lt;code&gt;进行主链选择&lt;/code&gt;的。不同于比特币的&lt;code&gt;最长链规则&lt;/code&gt;，它在选择最长链的时候不以哪条链区块连续最长为标准，而是将&lt;code&gt;分叉区块&lt;/code&gt;也考虑了进去，选择出一条包含了分叉区块在内区块数目最多的链作为最长链。例如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/14/167ac7f3facfc873?w=790&amp;amp;h=406&amp;amp;f=png&amp;amp;s=37134&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图的分叉情况中，在比特币公链中，最终胜出的是链：0 &amp;lt;- 1A &amp;lt;- 2C &amp;lt;- 3F &amp;lt;- 4B &amp;lt;- 5A，一条由&lt;code&gt;最长链规则&lt;/code&gt;选择的链。而在以太坊公链中，由幽灵协议得出的最终胜出的是：0 &amp;lt;- 1A &amp;lt;- 2B &amp;lt;- 3D &amp;lt;- 4A 。&lt;/p&gt;
&lt;p&gt;原因就是在上面的分叉情况中，幽灵协议把&lt;code&gt;分叉区块&lt;/code&gt;也考虑进去了，统计总的区块数，发现在包含了区块: 0，1A，2B，3E，3D，3C，4A 的链是含有区块数最多的。因此该链胜出，这就是幽灵协议选择最初链的机制。&lt;/p&gt;
&lt;h4 id=&quot;分叉块处理&quot;&gt;分叉块处理&lt;/h4&gt;
&lt;p&gt;此外，对于在&lt;code&gt;最长链中&lt;/code&gt;被包含进去了的&lt;code&gt;造成链分叉&lt;/code&gt;的块，例如上图中的&lt;code&gt;3E&lt;/code&gt;和&lt;code&gt;3C&lt;/code&gt;，&lt;code&gt;Ghost 协议&lt;/code&gt;对它们也有一套对应的处理机制，这些区块会被根据规则处理为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;孤块，完全没用的块，挖出的矿工没任何收益。&lt;code&gt;比特币链中的分叉块都是孤块&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;叔块，被一定范围内的后续子块所打包收纳的块，挖出叔块的矿工会按照一定算法给予收益。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;关于叔块方方面面的通俗详细介绍，在我书里，这里就不展开说了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们总结一下，&lt;code&gt;Ghost&lt;/code&gt;幽灵协议在以太坊中主要起到了下面两点作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选择出最长链&lt;/li&gt;
&lt;li&gt;对最长链中分叉块进行处理&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;casper-pos变种共识机制&quot;&gt;Casper PoS变种共识机制&lt;/h3&gt;
&lt;p&gt;前提：Casper 目前还没完全公布，还处于开发中，下面内容是根据目前现有的知识总结出的。&lt;/p&gt;
&lt;p&gt;作为以太坊第四阶段版本的共识机制，&lt;code&gt;Casper投注共识&lt;/code&gt;增加了&lt;code&gt;惩罚机制&lt;/code&gt;，并基于&lt;code&gt;PoS&lt;/code&gt;的思想在记账节点中选取&lt;code&gt;验证人&lt;/code&gt;，能够投注的角色是：&lt;code&gt;验证人&lt;/code&gt;。可以将这类角色理解为新一代以太坊矿工。&lt;/p&gt;
&lt;p&gt;在casper共识机制中，&lt;code&gt;验证人&lt;/code&gt;要拿出&lt;code&gt;保证金&lt;/code&gt;的一部分对它认为的大概率胜出的区块进行下注：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果赌对了，它们就可以拿回保证金外加区块中的交易费用，也许还会有一些新发的货币；&lt;/li&gt;
&lt;li&gt;如果下注没有迅速达成一致，下注太慢，它们只能拿回部分下注金，相当于损失了一些下注金；&lt;/li&gt;
&lt;li&gt;因此数个回合之后下注的结果出来，那些选错了的验证人就会输掉它们的下注金；&lt;/li&gt;
&lt;li&gt;此外如果验证人过于显著的改变下注，例如先是赌某个块有很高概率胜出，然后又改赌另外一个块有高概率胜出，它将被惩罚。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;如何成为验证人&quot;&gt;如何成为验证人&lt;/h4&gt;
&lt;p&gt;想成为验证人，是要进行交&lt;code&gt;保证金&lt;/code&gt;进行申请的，同时也可以在进入后选择退出，加入和退出都会将是以太坊网络中的一种&lt;code&gt;特殊的交易类型&lt;/code&gt;，目前最常见的交易就是&lt;code&gt;转账ETH代币&lt;/code&gt;。也就是说，到时候可能要调用一定的以太坊接口来进行申请成为&lt;code&gt;验证人&lt;/code&gt;。保证金很有可能就是以太坊ETH代币，它将会被用来投注，或被因被以太坊惩罚而没收掉。&lt;/p&gt;
&lt;p&gt;目前&lt;code&gt;Casper&lt;/code&gt;的验证人逻辑将会通过一个名称为&lt;code&gt;Casper合约&lt;/code&gt;的东西来实现，合约它提供投注，加入，取款和获取共识信息等一系列功能，因此通过简单的调用Casper合约我们就能提交投注或者进行其他操作。Casper合约的内部状态如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/14/167aca3b493df3d4?w=749&amp;amp;h=257&amp;amp;f=png&amp;amp;s=45158&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个&lt;code&gt;合约&lt;/code&gt;会记录当前的验证人集合，对于每位验证人的6项主要字段解析如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Return address&lt;/code&gt;，验证人保证金的返还地址&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Deposit size&lt;/code&gt;，当前验证人保证金的数量（注意验证人的投注会使这个值增加或减少）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Validation code&lt;/code&gt;，验证人的验证代码&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Seq&lt;/code&gt;，最近一次投注的序号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Prevhash&lt;/code&gt;，最近一次投注的hash&lt;/li&gt;
&lt;li&gt;验证人的每次投注的表格&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;验证人如何获取保证金&quot;&gt;验证人如何获取保证金&lt;/h4&gt;
&lt;p&gt;别人转账给验证人的钱包地址，或者在早期版本基于&lt;code&gt;PoW&lt;/code&gt;挖矿收获。&lt;/p&gt;
&lt;h4 id=&quot;候选区块如何产生&quot;&gt;候选区块如何产生&lt;/h4&gt;
&lt;p&gt;验证人出块，出块是一个独立于其它所有事件而发生的过程：验证人收集交易，当&lt;code&gt;轮到&lt;/code&gt;他们的出块时间时，他们就制造一个区块，签名，然后发送到网络上。&lt;/p&gt;
&lt;h4 id=&quot;按照什么规则轮着出块&quot;&gt;按照什么规则轮着出块&lt;/h4&gt;
&lt;p&gt;由&lt;code&gt;Casper&lt;/code&gt;机制提供规则。&lt;/p&gt;
&lt;h4 id=&quot;如何判断胜出区块&quot;&gt;如何判断胜出区块&lt;/h4&gt;
&lt;p&gt;当验证人中的绝大多数，满足协议定义阈值的一群验证人的总保证金比例达到67%到90%之间某个百分比以非常高的概率，下注某个块胜出的时候，此区块胜出。&lt;/p&gt;
&lt;h4 id=&quot;验证人联盟投注的作弊问题&quot;&gt;验证人联盟投注的作弊问题&lt;/h4&gt;
&lt;p&gt;不难看出&lt;code&gt;Casper&lt;/code&gt;投注方式是存在有验证人联盟在一起，共同投注某个区块使之胜出的问题的，对于这个问题的解决方案，目前以太坊还没完整公布，处于进一步的研究之中。&lt;/p&gt;
&lt;p&gt;完&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 07:07:00 +0000</pubDate>
<dc:creator>指尖下的幽灵</dc:creator>
<og:description>作者：林冠宏 / 指尖下的幽灵 掘金：https://juejin.im/user/587f0dfe128fe100570ce2d8 博客：http://www.cnblogs.com/linguan</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/linguanh/p/10155828.html</dc:identifier>
</item>
<item>
<title>设计模式第三篇-装饰者模式 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10155806.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10155806.html</guid>
<description>&lt;h2&gt;一、引言&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;先看一个开发问题，很多人都玩过英雄联盟这款游戏：里面有各种英雄，每个英雄都有各自的技能（一般是4个主动技能），每升一级可以升级一个技能，但是可升级的技能不固定。我们需要通过技能状态来计算伤害，这个时候组合就非常多了（理论上是英雄数*技能数）。如果用继承来解决的话，那么子类就爆炸多了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;除了继承还有一种设计，就是在基类上增加布尔变量，如Q，E等，然后提供一些has(get)和set方法来设置这些布尔值，子类里通过扩展计算伤害值，这个看起来是一个可行的设计，但这个设计也会有一些问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.每个技能可以多次加点，单纯靠布尔值是处理不了的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.技能有可能会进行调整，那么我们就必须通过修改基类来处理。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.游戏里面还有装备这种情况，增加装备也是相当于多了技能（貌似用装备来做例子更合适）。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们用更好的方法来解决这个问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个问题的本质是扩展，我们想要扩展一些功能，但是不想用继承。装饰者模式可以解决这个问题&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、&lt;span&gt;装饰者模式&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;定义：&lt;/strong&gt;动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;意图：&lt;/strong&gt;动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要解决：&lt;/strong&gt;一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;何时使用：&lt;/strong&gt;在不想增加很多子类的情况下扩展类。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何解决：&lt;/strong&gt;将具体功能职责划分，同时继承装饰者模式。&lt;/p&gt;
&lt;p&gt;装饰者通用类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201812/1113901-20181221144528864-1478391568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;三、实现&lt;/h2&gt;
&lt;p&gt;英雄联盟游戏实现&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抽象基类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Hero {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;学习技能&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; learnSkills();
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体英雄兰博，需要被扩展的类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Lanbo &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Hero {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;英雄属性&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String name;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Lanbo(String name){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; learnSkills() {
        System.out.println(name &lt;/span&gt;+ &quot;学习了以上技能！&quot;&lt;span&gt;);
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;抽象技能类，装饰者的抽象基类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Skills &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Hero {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Hero hero;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Skills(Hero hero){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.hero =&lt;span&gt; hero;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; learnSkills() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(hero!=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;){
            hero.learnSkills();
        }
    }
}

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体装饰子类，用来装饰 Q技能&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Skill_Q &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Skills {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  String skillName;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Skill_Q(Hero hero,String skillName) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hero);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.skillName=&lt;span&gt;skillName;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; learnSkills() {
        System.out.println(&lt;/span&gt;&quot;学习了技能Q:&quot; +&lt;span&gt;skillName);
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.learnSkills();
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体装饰子类，用来装饰 W技能&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Skill_W &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Skills {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  String skillName;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Skill_W(Hero hero,String skillName) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hero);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.skillName=&lt;span&gt;skillName;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; learnSkills() {
        System.out.println(&lt;/span&gt;&quot;学习了技能W:&quot; +&lt;span&gt;skillName);
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.learnSkills();
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体装饰子类，用来装饰E技能&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Skill_E &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Skills {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  String skillName;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Skill_E(Hero hero,String skillName) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hero);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.skillName=&lt;span&gt;skillName;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; learnSkills() {
        System.out.println(&lt;/span&gt;&quot;学习了技能E:&quot; +&lt;span&gt;skillName);
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.learnSkills();
    }
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;具体装饰子类，用来装饰R技能&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Skill_R &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Skills {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;  String skillName;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Skill_R(Hero hero,String skillName) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(hero);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.skillName=&lt;span&gt;skillName;
    }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; learnSkills() {
        System.out.println(&lt;/span&gt;&quot;学习了技能R:&quot; +&lt;span&gt;skillName);
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.learnSkills();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选择英雄&lt;/span&gt;
        Hero hero = &lt;span&gt;new&lt;/span&gt; Lanbo(&quot;兰博&quot;&lt;span&gt;);
        Skills q &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Skill_Q(hero,&quot;纵火盛宴&quot;&lt;span&gt;);
        Skills w &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Skill_W(q,&quot;破碎护盾&quot;&lt;span&gt;);
        Skills e &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Skill_E(w,&quot;电子鱼叉&quot;&lt;span&gt;);
        Skills r &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Skill_R(e,&quot;恒温灼烧&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;学习技能&lt;/span&gt;
        r.learnSkills();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201812/1113901-20181221145055618-982725789.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;装饰这模式和继承的目的都是扩展对象的功能，但装饰者模式比继承更灵活&lt;/li&gt;
&lt;li&gt;通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合&lt;/li&gt;
&lt;li&gt;装饰者模式有很好地可扩展性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变的更复杂。并且更多的对象会是的差错变得困难，特别是这些对象看上去都很像。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;java.io类就是用的装饰者模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201812/1113901-20181221145610107-925328559.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt; 相关代码：&lt;a title=&quot;源码地址&quot; href=&quot;https://gitee.com/yuanqinnan/pattern&quot; target=&quot;_blank&quot;&gt;https://gitee.com/yuanqinnan/pattern&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 21 Dec 2018 07:04:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、引言 先看一个开发问题，很多人都玩过英雄联盟这款游戏：里面有各种英雄，每个英雄都有各自的技能（一般是4个主动技能），每升一级可以升级一个技能，但是可升级的技能不固定。我们需要通过技能状态来计算伤害</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10155806.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core使用SignalR进行服务间调用 - 饭勺oO</title>
<link>http://www.cnblogs.com/fanshaoO/p/10155735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanshaoO/p/10155735.html</guid>
<description>&lt;p&gt;&lt;strong&gt;网上查询过很多关于ASP.NET core使用SignalR的简单例子，但是大部分都是简易聊天功能，今天心血来潮就搞了个使用SignalR进行服务间调用的简单DEMO。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;至于SignalR是什么我就不多说了，微软官方文档也不少。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-0&quot;&gt;第一步新建项目&lt;/h2&gt;
&lt;p&gt;所有VS开发第一步都是新建一个解决方案哈，这里我就不多介绍如何新建项目啦~~&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开发环境，VS2017,.NET CORE 2.1&lt;/li&gt;
&lt;li&gt;新建两个asp.net core项目 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201812/1313665-20181221150244357-1665293812.png&quot; alt=&quot;&quot;/&gt;
如此简单的操作大家都懂的&lt;/li&gt;
&lt;/ul&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-1&quot;&gt;注入SignalR&lt;/h2&gt;
&lt;p&gt;在被调用的服务端的Startup.cs中注入SignalR &lt;a href=&quot;https://link.juejin.im/?target=http%3A%2F%2Fxn--asp-lp6e.net&quot; rel=&quot;nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;在asp.net&lt;/a&gt; core2.1中已经默认包含了SignalR的库，直接在&lt;code&gt;ConfigureServices&lt;/code&gt;方法中添加如下代码：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;services.AddSignalR().AddMessagePackProtocol()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AddMessagePackProtocol()&lt;/code&gt;表示启用 MessagePack 支持在服务器上&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-2&quot;&gt;新建一个继承Hub类的类&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public class ServerHub : Hub
{
    
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;里面可以实现需要被客户端执行的方法。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-3&quot;&gt;配置Hub连接URL&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;Startup.cs&lt;/code&gt;的&lt;code&gt;Configure&lt;/code&gt;添加下面代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    app.UseSignalR(routes =&amp;gt;
    {
        routes.MapHub&amp;lt;ServerHub&amp;gt;(&quot;/myserver&quot;);
    });
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-4&quot;&gt;添加服务&lt;/h2&gt;
&lt;p&gt;新建一个Services文件夹，添加我们的服务接口和接口实现类。&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201812/1313665-20181221150256705-557562043.png&quot; alt=&quot;&quot;/&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
public interface IMyService
{
    Task&amp;lt;string&amp;gt; SayHello();
    Task Sleep();
}
public class MyService : IMyService
{
    public async Task&amp;lt;string&amp;gt; SayHello()
    {
        return await Task.Factory.StartNew(() =&amp;gt; &quot;Hello&quot;);
    }

    public async Task Sleep()
    {
        await Task.Delay(3000);            
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Startup.cs中的&lt;code&gt;ConfigureServices&lt;/code&gt;方法中进行依赖注入，注意需要在&lt;code&gt;AddSignalR()&lt;/code&gt;之前注入。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;services.AddScoped&amp;lt;IMyService, MyService&amp;gt;();&lt;/code&gt;&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-5&quot;&gt;在ServerHub添加依赖注入&lt;/h2&gt;
&lt;p&gt;在ServerHub中添加如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
　　private readonly IServiceProvider _serviceProvider;
    public ServerHub(IServiceProvider serviceProvider)
    {
        _serviceProvider = serviceProvider;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为我们需要使用到依赖注入获取指定Service，所以只注入&lt;code&gt;IServiceProvider&lt;/code&gt;，使用&lt;code&gt;IServiceProvider&lt;/code&gt;动态获取服务接口。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-6&quot;&gt;使用反射动态获取服务接口并执行指定方法&lt;/h2&gt;
&lt;p&gt;为了可以动态的选择服务并且执行服务相应的方法，我们使用反射来动态获取。 这里我们添加两个方法，一个有返回值，一个没有返回值&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public async Task&amp;lt;dynamic&amp;gt; Excute(string serverName,string functionName,object[] parameters)
    {
        return await Task.Factory.StartNew(() =&amp;gt;
        {
            var type = Type.GetType(serverName);
            var service = _serviceProvider.GetRequiredService(type);
            var method = type.GetMethod(functionName);
            var resultTask = method.Invoke(service, new object[] { }) as Task;
            dynamic result = resultTask.GetType().GetProperty(&quot;Result&quot;).GetValue(resultTask, null);
            return result;
        });
    }

    public async Task ExcuteWithoutResult(string serverName, string functionName, object[] parameters)
    {
        var type = Type.GetType(serverName);
        var service = _serviceProvider.GetRequiredService(type);
        var method = type.GetMethod(functionName);
        var resultTask = method.Invoke(service, new object[] { }) as Task;
        await resultTask;
        var msg = &quot;task done&quot;;
        await Clients.Caller.SendAsync(&quot;callback&quot;,msg);
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;方法中传入三个参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;serverName：服务接口名称（完整的命名空间）&lt;/li&gt;
&lt;li&gt;functionName：方法的名称&lt;/li&gt;
&lt;li&gt;parameters: 方法所需的参数&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;Type.GetType(serverName)&lt;/code&gt;获取服务接口的Type。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;_serviceProvider.GetRequiredService(type)&lt;/code&gt;从依赖注入中获取对应服务。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;type.GetMethod(functionName)&lt;/code&gt;获取需要执行的方法。&lt;/li&gt;
&lt;li&gt;执行方法&lt;code&gt;method.Invoke(service, new object[] { })&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;由于我们的服务是异步方法，&lt;code&gt;method.Invoke()&lt;/code&gt;返回的是一个&lt;code&gt;object&lt;/code&gt;对象，所以在将&lt;code&gt;method.Invoke()&lt;/code&gt;返回类型转为&lt;code&gt;Task&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;resultTask.GetType().GetProperty(&quot;Result&quot;).GetValue(resultTask, null)&lt;/code&gt;是通过反射获取&lt;code&gt;Task&lt;/code&gt;的&lt;code&gt;Result&lt;/code&gt;属性来回去相应的返回结果。&lt;/p&gt;
&lt;p&gt;因为我们不知道方法返回的&lt;code&gt;Task&lt;/code&gt;中返回的结果类型是什么，所以我们依旧使用反射来获取&lt;code&gt;Task&lt;/code&gt;的结果并使用&lt;code&gt;dynamic&lt;/code&gt;接收。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;无返回值的我们使用&lt;code&gt;Clients.Caller.SendAsync()&lt;/code&gt;在任务处理结束后给调用方返回一条消息。&lt;/p&gt;
&lt;hr/&gt;&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-7&quot;&gt;在调用方添加一个SingalRClient类&lt;/h2&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class SignalRClient
    {
        private readonly HubConnection connection;
        public SignalRClient()
        {
            connection = new HubConnectionBuilder()
                   .WithUrl(&quot;http://localhost:5000/myserver&quot;)
                   .AddMessagePackProtocol()
                   .Build();

            connection.Closed += async (error) =&amp;gt;
            {
                await Task.Delay(new Random().Next(0, 5) * 1000);
                await connection.StartAsync();
            };
            InitOnMethod();
            connection.StartAsync().ConfigureAwait(false).GetAwaiter().GetResult();
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在构造函数中初始化SignalR连接&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WithUrl(&quot;http://localhost:5000/myserver&quot;)&lt;/code&gt;是连接被调用方的URL&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AddMessagePackProtocol()&lt;/code&gt;是使用快速和精简的二进制序列化格式进行传输。 在&lt;code&gt;connection.Closed&lt;/code&gt;加入连接关闭事件，关闭后自动重新连接。 &lt;code&gt;InitOnMethod&lt;/code&gt;初始化服务方回调的监听事件&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    private void InitOnMethod()
    {
        connection.On&amp;lt;string&amp;gt;(&quot;callback&quot;,(msg)=&amp;gt; {
            Console.WriteLine($&quot;------------{msg}----------&quot;);
        });
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;connection.StartAsync()&lt;/code&gt;启动连接。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-8&quot;&gt;添加两个请求服务端的方法&lt;/h2&gt;
&lt;p&gt;一个有返回值，一个无返回值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public async Task&amp;lt;dynamic&amp;gt; RequestServer1()
    {
        var result = await connection.InvokeAsync&amp;lt;dynamic&amp;gt;(&quot;Excute&quot;, &quot;SignalRServer1.Services.IMyService&quot;, &quot;SayHello&quot;,new object[] { });
        
        return result;
    }

    public async Task RequestWithoutResult()
    {
        await connection.SendAsync(&quot;ExcuteWithoutResult&quot;, &quot;SignalRServer1.Services.IMyService&quot;, &quot;Sleep&quot;, new object[] { });
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要返回值的我们使用&lt;code&gt;connection.InvokeAsync()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;不需要返回值的我们使用&lt;code&gt;connection.SendAsync()&lt;/code&gt;方法&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-9&quot;&gt;将SignalRClient以单例形式注册依赖注入&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;Startup.cs&lt;/code&gt;中的&lt;code&gt;ConfigureServices&lt;/code&gt;方法中添加&lt;code&gt;services.AddSingleton&amp;lt;SignalRClient&amp;gt;()&lt;/code&gt;。&lt;/p&gt;
&lt;h2 class=&quot;heading&quot; data-id=&quot;heading-10&quot;&gt;使用SignalRClient请求服务&lt;/h2&gt;
&lt;p&gt;在控制器中将SignalRClient注入&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    private readonly SignalRClient _signalRClient;

    public ValuesController(SignalRClient signalRClient)
    {
        _signalRClient = signalRClient;
    }
    // GET api/values
    [HttpGet]
    public async Task&amp;lt;ActionResult&amp;lt;IEnumerable&amp;lt;string&amp;gt;&amp;gt;&amp;gt; Get()
    {
        var str = await _signalRClient.RequestServer1().ConfigureAwait(false);
        await _signalRClient.RequestWithoutResult().ConfigureAwait(false);
        return new string[] { str };
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在请求中同时调用一个有返回值，一个无返回值的方法。无返回值的方法在任务执行完后执行一个回调。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;启动服务&lt;/p&gt;

&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201812/1313665-20181221150353116-1816561420.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201812/1313665-20181221150404500-1030781414.png&quot; alt=&quot;&quot;/&gt;


&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313665/201812/1313665-20181221150422013-1593247237.png&quot; alt=&quot;&quot;/&gt;
可以看到服务调用已经成功 task done是我们无返回值调用那个方法中接收到回调时的输出.

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
connection.On&amp;lt;string&amp;gt;(&quot;callback&quot;,(msg)=&amp;gt; {
            Console.WriteLine($&quot;------------{msg}----------&quot;);
        });
&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;
&lt;code class=&quot;hljs bash copyable&quot; lang=&quot;bash&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt;&lt;span class=&quot;hljs-string&quot;&gt; &lt;span class=&quot;copy-code-btn&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;以上就是我简单做的一个DEMO。如有不足之处，请多多指点。基本没写过文章，写的不好请谅解哈哈~~~&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 06:56:00 +0000</pubDate>
<dc:creator>饭勺oO</dc:creator>
<og:description>网上查询过很多关于ASP.NET core使用SignalR的简单例子，但是大部分都是简易聊天功能，今天心血来潮就搞了个使用SignalR进行服务间调用的简单DEMO。 至于SignalR是什么我就不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanshaoO/p/10155735.html</dc:identifier>
</item>
<item>
<title>AJAX请求中出现OPTIONS请求 - Cousoulis</title>
<link>http://www.cnblogs.com/wanghuijie/p/preflighted_request.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wanghuijie/p/preflighted_request.html</guid>
<description>&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;有一个前后端分离的VUE项目来发送&lt;code&gt;ajax&lt;/code&gt;请求, 查看&lt;code&gt;Nginx&lt;/code&gt;日志或使用&lt;code&gt;Chrome Dev Tools&lt;/code&gt;查看请求发送情况时, 会看到每次调后台API的请求之前, 都会发送一个OPTIONS请求, 无论API要求请求的方法是GET或POST.&lt;/p&gt;
&lt;p&gt;为什么会发送这个OPTIONS请求? 困扰了项目组的前端同学和后端同学很久，今天正好听他们说起这个问题，就研究了一下原理。&lt;/p&gt;
&lt;h2 id=&quot;过程&quot;&gt;过程&lt;/h2&gt;
&lt;p&gt;首先, 在js代码里是没写要发送OPTIONS请求的, 后台API要的请求方法不是GET就是POST, 也只发送过这两种类型的请求.&lt;/p&gt;
&lt;p&gt;那么, 我就以为是前台调用方式的问题, 于是去看了看代码. 发现并没有什么很特殊的地方。然后直接看&lt;code&gt;ajax.js&lt;/code&gt;文件. 结果, 发现一切正常, 并没有这种逻辑: &lt;strong&gt;发送GET/POST请求之前, 先发送一个OPTIONS请求&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;看来就不是前端同学写法的问题，也不是ajax的问题，仔细对比了一下之前的代码，发现唯一的区别就是ajax中用到了自定义的header头。&lt;/p&gt;
&lt;h2 id=&quot;解惑&quot;&gt;解惑&lt;/h2&gt;
&lt;p&gt;众所周知, ajax请求是由&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象实现的(部分低版本ID浏览器不是), 而&lt;code&gt;XMLHttpRequest&lt;/code&gt;会遵守同源策略(&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;same-origin policy&lt;/a&gt;). 也即脚本只能访问相同协议/相同主机名/相同端口的资源, 如果要突破这个限制, 那就是所谓的跨域, 此时需要遵守CORS(&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&quot; rel=&quot;external&quot; target=&quot;_blank&quot;&gt;Cross-Origin Resource Sharing&lt;/a&gt;)机制。&lt;/p&gt;
&lt;p&gt;那么, 允许跨域, 不就是服务端(例如Nginx或者后端代码)设置&lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt;就可以了吗?&lt;/p&gt;
&lt;p&gt;普通的请求确实是这样子的, 除此之外, 还一种叫请求叫Preflighted Request（带预检的跨域请求）&lt;/p&gt;
&lt;p&gt;Preflighted Request在发送真正的请求前, 会先发送一个方法为OPTIONS的预请求(Preflighted Request), 用于试探服务端是否能接受真正的请求.&lt;/p&gt;
&lt;p&gt;如果options获得的回应是拒绝性质的，比如404\403\500等http状态，就会停止post、get等请求的发出。&lt;/p&gt;
&lt;p&gt;那么, 什么情况下请求会变成Preflighted Request呢? 翻看了MDN的文档发现如下：(文档地址：https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS#The_HTTP_request_headers)&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;请求方法不是GET/HEAD/POST&lt;/li&gt;
&lt;li&gt;POST请求的&lt;code&gt;Content-Type&lt;/code&gt;并非&lt;code&gt;application/x-www-form-urlencoded&lt;/code&gt;, &lt;code&gt;multipart/form-data&lt;/code&gt;, 或&lt;code&gt;text/plain&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;请求设置了自定义的&lt;code&gt;header&lt;/code&gt;字段&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个例子, 如果POST请求要传输的数据为 XML文档, &lt;code&gt;Content-Type&lt;/code&gt;为&lt;code&gt;application/xml&lt;/code&gt;或&lt;code&gt;text/xml&lt;/code&gt;, 则发送这个请求前会发送一个预请求，或者自定义的header字段也是一样的道理。&lt;/p&gt;

&lt;p&gt;有了上面的知识点, 再去看项目中ajax调用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1166714/201812/1166714-20181221144736735-1735815849.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出, 跨域请求中设置了自定义的&lt;code&gt;header&lt;/code&gt;字段, 所以该请求是&lt;code&gt;preflighted request&lt;/code&gt;, 则请求前一定会发送一个OPTIONS作为预请求.&lt;/p&gt;
&lt;p&gt;所以说, 在项目中ajax对后台API的调用, OPTIONS请求是没办法去掉的, 除非后台接口不再需要在请求&lt;code&gt;header&lt;/code&gt;中设置&lt;code&gt;openId&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;但是由于该项目中用户信息是采用的JWT的方式，所以只好作罢。&lt;/p&gt;

&lt;p&gt;但是由于该项目在后台中自定义了请求频率限制的拦截器，例如限制同一个客户端一秒内对某一个接口只能访问1次。如果超过限制，则第二次会返回状态码500，不予处理。如果每次请求前都带着一次OPTIONS请求，则该拦截器无法正常实现功能，反正会导致大批接口调用失败的情况。&lt;/p&gt;
&lt;p&gt;鉴于上述分析，既然前端发起请求时OPTIONS请求没有办法去除，那么是否可以考虑从后台拦截器进行改造。&lt;/p&gt;
&lt;p&gt;改造后的代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1166714/201812/1166714-20181221145153174-1914831764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果拦截到的请求不是项目中常规的GET或者POST请求，则该拦截器直接放行。至此，问题完美解决。希望可以帮到有类似问题的小伙伴~&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 06:55:00 +0000</pubDate>
<dc:creator>Cousoulis</dc:creator>
<og:description>背景 有一个前后端分离的VUE项目来发送ajax请求, 查看Nginx日志或使用Chrome Dev Tools查看请求发送情况时, 会看到每次调后台API的请求之前, 都会发送一个OPTIONS请求</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wanghuijie/p/preflighted_request.html</dc:identifier>
</item>
<item>
<title>R语言学习 第十篇：包 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/5781367.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/5781367.html</guid>
<description>&lt;p&gt;包（Package）是实现特定功能的、预先写好的代码库（library），通俗地说，包是含有函数、数据等的功能模块。R拥有大量的软件包，许多包都是由某一领域的专家编写的，但并不是所有的包都有很高的质量。在使用包之前，最好到社区中了解其他网友的反馈。R预先安装了一系列的基础包，包括base、datasets、utils、grDevices、graphics、stats、以及methods，由于已经预先安装，因此，可以直接使用，提供了系统默认的函数和数据集。&lt;/p&gt;
&lt;h2&gt;一，包操作&lt;/h2&gt;
&lt;p&gt;在使用包之前，用户必须把包安装到本地的R引擎中；把包安装到本地之后，只有在包被引用之后，才可以引用包中的函数。&lt;/p&gt;
&lt;p&gt;通常情况下，用户只需要知道如何安装包和引用包，就可以用R编程了，安装包和引用包的命令分别是：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
install.packages(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;package-name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
library(package&lt;/span&gt;-&lt;span&gt;name)&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;1，安装包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在使用包之前，必须把包安装到R引擎中，install.packages()函数用于从CRAN或本地下载和安装包：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
install.packages(pkgs=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;package_name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, lib)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pkgs：包的名称，使用字符串来表示；&lt;/li&gt;
&lt;li&gt;lib：安装包的库路径，如果省略，那么默认值是函数 .libPaths()返回的第一个元素&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意，&lt;strong&gt;R将反斜杠视为一个转义字符，表示路径，要么使用&quot;D:\\mydata“，要么使用&quot;D:/mydata&quot;。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，把包ggplot2安装到默认的库路径中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
install.packages(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ggplot2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2，引用包和分离包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在安装包之后，若要使用包中的数据和函数，则必须把包载入（引用）到R会话中。R使用library()载入包，参数是包的名称，或是名称的字符串。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
library(package_name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当包被载入之后，R引擎把该包添加到包的搜索路径中。可以使用search()函数查看当前R会话搜索路劲。&lt;/p&gt;

&lt;p&gt;当把包载入后，可以使用search()函数查看当前R脚本可以直接应用搜索路径中的所有包。如果要把包从当前的搜索路径中移除，可以使用detach()函数，detach()是library()的逆操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;detach(package:plyr)
detach(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;package:plyr&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,character.only = TRUE)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当把包从搜索路径中移除后，当前的R脚本不能直接引用该包。如果想要重新引用包中的函数或数据，必须使用library()函数重新引用该包。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，查看已经安装的包&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果要查看已经安装到本地的包，可以使用installed.packages()，该函数返回一个矩阵（Matrix），列名主要有：包名（Package Name）、引用路径（Library Path）和版本号（Version Number），行名是包的名称（Package Name）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
installed.packages(lib.loc = NULL)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数 lib.loc 是指要搜索的 R 库的路径。默认值是NULL，表示 libPaths()下面的所有路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;gt; installed.packages(lib.loc =&lt;span&gt; NULL)
                 Package            LibPath                                                Version      
assertthat       &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;assertthat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;       &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Users/xxx/Documents/R/win-library/3.3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0.1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;      
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4，包的移除&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果把已安装的包从本地移除，可以使用remove.packages()函数，它是install.packages()的逆向操作。如果想要再次使用该包，那么必须重新把包安装到本地。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
remove.packages(pkgs, lib)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数注释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pkgs：用于指定包的名称；&lt;/li&gt;
&lt;li&gt;lib：用于指定要搜索的R库的的路径，从该路径下搜索要移除的包；如果不指定，那么lib 是 .libPaths() 返回的第一个元素。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;二，查看包安装的路径&lt;/h2&gt;
&lt;p&gt;使用path.packages()函数可以直接查看包安装的路径，参数是包的名字（字符串）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; library(ggplot2)
&lt;/span&gt;&amp;gt; path.package(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ggplot2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
[&lt;/span&gt;1] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Users/xxx/Documents/R/win-library/3.5/ggplot2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三，库路径&lt;/h2&gt;
&lt;p&gt;存储包的目录称作库（library），库的路径（也叫library tree）就是搜索包的位置。在本地中，库的路径不是唯一的，通过base包中的函数 .libPaths()查看库的所有路径：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; .libPaths()
[&lt;/span&gt;1] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Users/xxx/Documents/R/win-library/3.5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Program Files/R/R-3.5.1/library&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该函数返回的库路径，用于安装用户通过执行函数 install.packages() 安装的包。&lt;/p&gt;
&lt;p&gt;R中预装的默认库的路径，和用户安装的库的路径是不相同的，默认库的安装路径的通过base包中的变量 .library 查看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;gt;&lt;span&gt; .Library
[&lt;/span&gt;1] &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/PROGRA~1/R/R-35~1.1/library&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该变量 .Library 表示默认库的路径。&lt;/p&gt;

</description>
<pubDate>Fri, 21 Dec 2018 06:47:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>包（Package）是实现特定功能的、预先写好的代码库（library），通俗地说，包是含有函数、数据等的功能模块。R拥有大量的软件包，许多包都是由某一领域的专家编写的，但并不是所有的包都有很高的质量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ljhdo/p/5781367.html</dc:identifier>
</item>
<item>
<title>开发必备知识点---根据字符串导入模块并且找到类 - 爬呀爬Xjm</title>
<link>http://www.cnblogs.com/xjmlove/p/10155547.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjmlove/p/10155547.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; importlib
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据字符串 找到导入的模块和类&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在同级目录下创建xxx.py文件，然后通过python的importlib模块导入&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; m = importlib.import_module(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入过来后执行了xxx.py文件的print()   根据字符串导入模块&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(m)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;module 'xxx' from 'D:\\学习历程\\老男孩\\第七模块\\pro_crm\\rbac\\xxx.py'&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; cls = getattr(m, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;(cls)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;class 'xxx.Foo'&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实例化一个对象&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; obj = cls(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;江子牙&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行对象的方法&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; obj.func()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 江子牙&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据path导入该模块&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; RBAC_USER_MODEL_CLASS = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;x.xxx.X&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取模块名称和类的名称&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; module_path, model_class_name = RBAC_USER_MODEL_CLASS.rsplit(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, maxsplit=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(module_path, model_class_name)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; m =&lt;span&gt; importlib.import_module(module_path)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; cls = getattr(m, model_class_name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;django也有个模块有这个功能，其实内部就是通过上面实现的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; django.utils.module_loading &lt;span&gt;import&lt;/span&gt;&lt;span&gt; import_string
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; m = import_string(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;xxx.Foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(m)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 根据字符串导入模块&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; &amp;lt;class 'xxx.Foo'&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这个功能强大之处就是遵循了开放封闭原则。&lt;/p&gt;
&lt;p&gt;对代码封闭、对配置开放。&lt;/p&gt;
&lt;p&gt;可以通过配置文件。&lt;/p&gt;
&lt;p&gt;djang的配置文件就是这样做的&lt;/p&gt;
&lt;p&gt;如果公司需要开发一个短信提醒功能，但是目前只支持三种，通过配置字符串，就可以不修改源代码，来扩展短信提醒的方式。&lt;/p&gt;
&lt;p&gt;创建run.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;! /usr/bin/env python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; __author__ = &quot;ziya&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Date: 2018-12-21&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; settings, importlib
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; excute():
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    消息提醒功能
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    :return: 
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; path &lt;span&gt;in&lt;/span&gt;&lt;span&gt; settings.SEND_MSG_LIST:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         module_path, class_name = path.rsplit(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, maxsplit=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         m =&lt;span&gt; importlib.import_module(module_path)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         cls =&lt;span&gt; getattr(m, class_name)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         obj =&lt;span&gt; cls()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        obj.send()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     excute()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同级目录下创建settings.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt;! /usr/bin/env python&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; -*- coding: utf-8 -*-&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; __author__ = &quot;ziya&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; Date: 2018-12-21&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; SEND_MSG_LIST =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message.email.Email&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message.weixin.WeChat&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message.duanxin.MobileMsg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再创建一个包存放各个消息提醒的模块&lt;/p&gt;
&lt;p&gt;message\xxx.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; email.py&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Email(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; send(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发送邮件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; weixin.py&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; WeChat(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; send(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发送微信&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; duanxin.py&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; MobileMsg(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; send(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发送短信&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行run文件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1392812/201812/1392812-20181221145927176-634941550.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时加钉钉消息提醒功能的话，去包里写好钉钉这个功能的模块。&lt;/p&gt;
&lt;p&gt;dingding.py&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DingDing(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; send(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;发送钉钉&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也只需再配置文件里配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; SEND_MSG_LIST =&lt;span&gt; [
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;message.dingding.DingDing&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; ]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; run的源代码并没有修改，但是执行的时候，功能却扩展了。如果不想要哪个功能，在配置文件里注释即可。遵循了开放封闭原则。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1392812/201812/1392812-20181221150340291-919617937.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 21 Dec 2018 06:29:00 +0000</pubDate>
<dc:creator>爬呀爬Xjm</dc:creator>
<og:description>django也有个模块有这个功能，其实内部就是通过上面实现的。 这个功能强大之处就是遵循了开放封闭原则。 对代码封闭、对配置开放。 可以通过配置文件。 djang的配置文件就是这样做的 如果公司需要开</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xjmlove/p/10155547.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 入门教程 7、ASP.NET Core MVC 分部视图入门 - ken-io</title>
<link>http://www.cnblogs.com/ken-io/p/aspnet-core-tutorial-mvc-view-partial.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ken-io/p/aspnet-core-tutorial-mvc-view-partial.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;h3&gt;1、本教程主要内容&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;ASP.NET Core MVC (Razor)分部视图简介&lt;/li&gt;
&lt;li&gt;ASP.NET Core MVC (Razor)分部视图基础教程&lt;/li&gt;
&lt;li&gt;ASP.NET Core MVC (Razor)强类型分部视图教程&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2、本教程环境信息&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;软件/环境&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;操作系统&lt;/td&gt;
&lt;td&gt;Windows 10&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SDK&lt;/td&gt;
&lt;td&gt;2.1.401&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ASP.NET Core&lt;/td&gt;
&lt;td&gt;2.1.3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;IDE&lt;/td&gt;
&lt;td&gt;Visual Studio Code 1.30&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;浏览器&lt;/td&gt;
&lt;td&gt;Chrome 70&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;本篇代码以下代码进行调整：&lt;a href=&quot;https://github.com/ken-io/asp.net-core-tutorial/tree/master/chapter-06&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/ken-io/asp.net-core-tutorial/tree/master/chapter-06&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;3、准备工作&lt;/h3&gt;
&lt;p&gt;VS Code 本身不提供 ASP.NET Core MVC 视图引擎（Razor）的智能感知。&lt;br/&gt;幸运的是，&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ms-vscode.csharp&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;VS Code C#扩展&lt;/a&gt; 从 1.17.0 版本开始支持Razor视图引擎的智能感知。&lt;/p&gt;
&lt;p&gt;所以，我们要将&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ms-vscode.csharp&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;VS Code C#扩展&lt;/a&gt;升级到最新版本。&lt;/p&gt;
&lt;p&gt;另外，要特意说明的是，在VS Code 1.30版本，解决方案（Solution）视图的视图入口改到了侧边工具栏&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;680&quot; data-height=&quot;612&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13570814-849a334b27ab5289.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/13570814-849a334b27ab5289.png&quot; data-original-width=&quot;680&quot; data-original-height=&quot;612&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;34203&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;二、ASP.NET Core MVC (Razor)分部视图简介&lt;/h2&gt;
&lt;h3&gt;1、Razor分部视图概述&lt;/h3&gt;
&lt;p&gt;在Razor视图引擎中，我们可以定义.cshtml文件作为“视图”来渲染需要呈现给用户的内容。对于所有页面共用的部分，我们可以定义母版页（Layout）让视图继承共用的部分。当有些公共的部分我们只在某些页面用到，不需要每个页面都用到。或者这个公共的内容需要作为模板使用多次，母版页就不适合承担这样的作用。这时候我们可以使用分部视图来实现。&lt;/p&gt;
&lt;h3&gt;2、Razor分部视图定义与引用&lt;/h3&gt;
&lt;h4&gt;Razor分部视图定义&lt;/h4&gt;
&lt;p&gt;视图与分部视图在定义上并没有本质的不同，均是创建.cshtml文件作为视图使用，只是在渲染的时候作为分部视图来渲染/加载。&lt;/p&gt;
&lt;p&gt;在之前提到过，通常公共的Razor视图文件名都以_开头并放在&lt;code&gt;/Views/Shared&lt;/code&gt;文件夹中，分部视图也不例外。&lt;/p&gt;
&lt;p&gt;例如:&lt;code&gt;/Views/Shared/_PartialViewTest.cshtml&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果分部视图只在某个控制器返回的视图中引用，也可以创建在该控制器对应的视图目录。&lt;/p&gt;
&lt;p&gt;例如：&lt;code&gt;/Views/Home/_PartialViewTest.cshtml&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;Razor分部视图引用&lt;/h4&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;微软官方更推荐使用异步加载的方式，因为同步加载可能会出现程序死锁的情况&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果没有使用异步方式，会收到编译器警告：warning MVC1000: Use of IHtmlHelper.Partial may result in application deadlocks. Consider using &amp;lt;partial&amp;gt; Tag Helper or IHtmlHelper.PartialAsync.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你非常在意性能，也可以使用 &lt;code&gt;Html.RenderPartialAsync&lt;/code&gt; 呈现分部视图。 这种方式会直接呈现分部视图的内容，而不会组装成 &lt;code&gt;IHtmlContent&lt;/code&gt; 对象放回。&lt;/p&gt;
&lt;pre class=&quot;hljs python&quot;&gt;
&lt;code class=&quot;python&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@{
    &lt;span class=&quot;hljs-keyword&quot;&gt;await Html.RenderPartialAsync(&lt;span class=&quot;hljs-string&quot;&gt;&quot;_PartialViewTest&quot;);
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 &lt;code&gt;Html.RenderPartialAsync&lt;/code&gt;并不会返回任何内容，所以需要在Razor语句块中调用&lt;/p&gt;
&lt;p&gt;Razor分部视图查找顺序同视图相同：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Views/[ControllerName]/[PartialViewName].cshtml&lt;/li&gt;
&lt;li&gt;Views/Shared/[PartialViewName].cshtml&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，你也可以直接指定完整路径，例如：&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@await Html.PartialAsync(&lt;span class=&quot;hljs-string&quot;&gt;&quot;/Views/Home/_PartialViewTest.cshtml&quot;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2&gt;三、 Razor分部视图基础使用&lt;/h2&gt;
&lt;h3&gt;1、定义分部视图&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;/Views/Shared&lt;/code&gt;目录下创建视图 '_DateTimeInfo.cshtml'&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;当前时间：&lt;span class=&quot;hljs-meta&quot;&gt;@DateTime.Now.ToString(&lt;span class=&quot;hljs-string&quot;&gt;&quot;yyyy-MM-dd HH:mm:ss:fff&quot;) 
当前星期：&lt;span class=&quot;hljs-meta&quot;&gt;@DateTime.Now.DayOfWeek
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;2、创建视图并引用分部视图&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;/Views&lt;/code&gt;目录下创建目录&lt;code&gt;Partial&lt;/code&gt;，并在&lt;code&gt;/Views/Partial&lt;/code&gt; 目录下创建文件 &lt;code&gt;Demo.cshtml&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;@{
    ViewBag.Title = &quot;PartialView Demo&quot;;
}
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;h3&amp;gt;@ViewBag.Title&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;h3&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&amp;gt;PartialView Demo by ken.io&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&amp;gt;

@Html.Partial(&quot;_DateTimeInfo&quot;)

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;hr/&amp;gt;

@await Html.PartialAsync(&quot;_DateTimeInfo&quot;)

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;3、创建控制器&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;/Controllers&lt;/code&gt; 目录下创建&lt;code&gt;PartialController.cs&lt;/code&gt;并创建对应Action&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using System;
&lt;span class=&quot;hljs-keyword&quot;&gt;using Microsoft.AspNetCore.Mvc;

&lt;span class=&quot;hljs-keyword&quot;&gt;namespace Ken.Tutorial.Web.Controllers
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;PartialController : Controller
    {
        &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;Demo&lt;span class=&quot;hljs-params&quot;&gt;()
        {
            &lt;span class=&quot;hljs-keyword&quot;&gt;return View();
        }
    }
}

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;4、访问测试&lt;/h3&gt;
&lt;p&gt;启动项目，访问 &lt;code&gt;/partial/demo&lt;/code&gt; ，将会看到&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1150&quot; data-height=&quot;740&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13570814-161fc985fae2dda2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/13570814-161fc985fae2dda2.png&quot; data-original-width=&quot;1150&quot; data-original-height=&quot;740&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;43725&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;h2&gt;四、带参数的Razor分部视图&lt;/h2&gt;
&lt;h3&gt;1、视图对象准备&lt;/h3&gt;
&lt;p&gt;在项目根目录中创建模型目录&lt;code&gt;Models&lt;/code&gt;，并在下面创建对象&lt;code&gt;NoteViewModel.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using System;

&lt;span class=&quot;hljs-keyword&quot;&gt;namespace Ken.Tutorial.Web.Models
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;NoteViewModel
    {
        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-built_in&quot;&gt;string Title { get; &lt;span class=&quot;hljs-built_in&quot;&gt;set; }

        &lt;span class=&quot;hljs-keyword&quot;&gt;public DateTime PublishTime { get; &lt;span class=&quot;hljs-built_in&quot;&gt;set; }

        &lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-built_in&quot;&gt;string Body { get; &lt;span class=&quot;hljs-built_in&quot;&gt;set; }
    }
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;2、定义分部视图&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;/Views/Shared&lt;/code&gt;目录下创建视图 '_NoteInfo.cshtml'&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;@model Ken.Tutorial.Web.Models.NoteViewModel;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;h3&amp;gt;@Model.Title&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;h3&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;span&amp;gt;@Model.PublishTime.ToString(&quot;yyyy-MM-dd&quot;)&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;span&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;p&amp;gt;@Model.Body&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;p&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上就是创建强类型分部视图:-D&lt;/p&gt;
&lt;h3&gt;3、创建视图并引用分部视图&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;/Views/Partial&lt;/code&gt; 目录下创建文件 &lt;code&gt;DemoWithParams.cshtml&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;hljs php&quot;&gt;
&lt;code class=&quot;php&quot;&gt;@using Ken.Tutorial.Web.Models;
@{
    ViewBag.Title = &lt;span class=&quot;hljs-string&quot;&gt;&quot;PartialView With Params Demo&quot;;
}
&amp;lt;h3&amp;gt;@ViewBag.Title&amp;lt;/h3&amp;gt;
&amp;lt;p&amp;gt;PartialView With Params Demo by ken.io&amp;lt;/p&amp;gt;

@await Html.PartialAsync(&lt;span class=&quot;hljs-string&quot;&gt;&quot;_NoteInfo&quot;, &lt;span class=&quot;hljs-keyword&quot;&gt;new NoteViewModel() { Title = &lt;span class=&quot;hljs-string&quot;&gt;&quot;这是一个分部视图测试笔记&quot;, PublishTime = DateTime.Now, Body = &lt;span class=&quot;hljs-string&quot;&gt;&quot;这是笔记的内容&quot;  })

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;4、在控制器中编写对应Action&lt;/h3&gt;
&lt;p&gt;在控制器 &lt;code&gt;PartialController.cs&lt;/code&gt; 中增加以下 Action：&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public IActionResult &lt;span class=&quot;hljs-title&quot;&gt;DemoWithParams&lt;span class=&quot;hljs-params&quot;&gt;()
{
    &lt;span class=&quot;hljs-keyword&quot;&gt;return View();
}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;5、访问测试&lt;/h3&gt;
&lt;p&gt;启动项目，访问 &lt;code&gt;/partial/demowithparams&lt;/code&gt; ，将会看到&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1078&quot; data-height=&quot;712&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/13570814-8e57942c8a3f1447.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/13570814-8e57942c8a3f1447.png&quot; data-original-width=&quot;1078&quot; data-original-height=&quot;712&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;42403&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;image&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;如果是文章列表页，用起来会显得更方便。&lt;/p&gt;
&lt;h2&gt;五、备注&lt;/h2&gt;
&lt;h3&gt;1、附录&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;本文代码示例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ken-io/asp.net-core-tutorial/tree/master/chapter-07&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://github.com/ken-io/asp.net-core-tutorial/tree/master/chapter-07&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文参考&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/partial?view=aspnetcore-2.1&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core/mvc/views/partial?view=aspnetcore-2.1&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;本文首发于我的独立博客：&lt;a href=&quot;https://ken.io/note/asp.net-core-tutorial-mvc-view-partial&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://ken.io/note/asp.net-core-tutorial-mvc-view-partial&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Dec 2018 06:12:00 +0000</pubDate>
<dc:creator>ken-io</dc:creator>
<og:description>一、前言 1、本教程主要内容 ASP.NET Core MVC (Razor)分部视图简介 ASP.NET Core MVC (Razor)分部视图基础教程 ASP.NET Core MVC (Raz</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ken-io/p/aspnet-core-tutorial-mvc-view-partial.html</dc:identifier>
</item>
<item>
<title>spring-data-redis的事务操作深度解析--原来客户端库还可以攒够了事务命令再发？ - 三国梦回</title>
<link>http://www.cnblogs.com/grey-wolf/p/10142937.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/grey-wolf/p/10142937.html</guid>
<description>&lt;p&gt;简单介绍下redis的几个事务命令：&lt;/p&gt;
&lt;p&gt;redis事务四大指令: MULTI、EXEC、DISCARD、WATCH。&lt;/p&gt;
&lt;p&gt;这四个指令构成了redis事务处理的基础。&lt;/p&gt;
&lt;p&gt;1.MULTI用来组装一个事务；&lt;br/&gt;2.EXEC用来执行一个事务；&lt;br/&gt;3.DISCARD用来取消一个事务；&lt;/p&gt;
&lt;p&gt;4.WATCH类似于乐观锁机制里的版本号。&lt;/p&gt;
&lt;p&gt;被WATCH的key如果在事务执行过程中被并发修改，则事务失败。需要重试或取消。&lt;/p&gt;
&lt;p&gt;以后单独介绍。&lt;/p&gt;

&lt;p&gt;下面是最新版本的spring-data-redis（2.1.3）的官方手册。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-data/redis/docs/2.1.3.RELEASE/reference/html/#tx&quot; target=&quot;_blank&quot;&gt;https://docs.spring.io/spring-data/redis/docs/2.1.3.RELEASE/reference/html/#tx&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这里，我们注意这么一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;6.1976744186047&quot;&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;11.441860465116&quot;&gt;
&lt;p&gt;Redis provides support for &lt;a href=&quot;http://redis.io/topics/transactions&quot;&gt;transactions&lt;/a&gt; through the &lt;code&gt;multi&lt;/code&gt;, &lt;code&gt;exec&lt;/code&gt;, and &lt;code&gt;discard&lt;/code&gt; commands. These operations are available on &lt;code&gt;RedisTemplate&lt;/code&gt;. However, &lt;code&gt;RedisTemplate&lt;/code&gt; is not guaranteed to execute all operations in the transaction with the same connection.&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思是redis服务器通过multi，exec，discard提供事务支持。这些操作在RedisTemplate中已经实现。然而，RedisTemplate不保证在同一个连接中执行所有的这些一个事务中的操作。&lt;/p&gt;

&lt;p&gt;另外一句话：&lt;/p&gt;
&lt;blockquote readability=&quot;5.5&quot;&gt;
&lt;div class=&quot;paragraph&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;Spring Data Redis provides the &lt;code&gt;SessionCallback&lt;/code&gt; interface for use when multiple operations need to be performed with the same &lt;code&gt;connection&lt;/code&gt;, such as when using Redis transactions. The following example uses the &lt;code&gt;multi&lt;/code&gt; method:&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思是：spring-data-redis也提供另外一种方式，这种方式可以保证多个操作（比如使用redis事务）可以在同一个连接中进行。示例如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;execute a transaction&lt;/span&gt;
List&amp;lt;Object&amp;gt; txResults = redisTemplate.execute(&lt;span&gt;new&lt;/span&gt; SessionCallback&amp;lt;List&amp;lt;Object&amp;gt;&amp;gt;&lt;span&gt;() {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Object&amp;gt; execute(RedisOperations operations) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; DataAccessException {
    operations.multi();
    operations.opsForSet().add(&lt;/span&gt;&quot;key&quot;, &quot;value1&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; This will contain the results of all operations in the transaction&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; operations.exec();
  }
});
System.out.println(&lt;/span&gt;&quot;Number of items added to set: &quot; + txResults.get(0));
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在前言中我们说，通过RedisTemplate直接调用multi，exec，discard，不能保证在同一个连接中进行。&lt;/p&gt;
&lt;p&gt;这几个操作都会调用RedisTemplate#execute(RedisCallback&amp;lt;T&amp;gt;, boolean)，比如multi：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; multi() {
        execute(connection &lt;/span&gt;-&amp;gt;&lt;span&gt; {
            connection.multi();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们看看RedisTemplate的execute方法的源码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt; T execute(RedisCallback&amp;lt;T&amp;gt; action, &lt;span&gt;boolean&lt;/span&gt; exposeConnection, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; pipeline) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;         Assert.isTrue(initialized, &quot;template not initialized; call afterPropertiesSet() before using it&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         Assert.notNull(action, &quot;Callback object must not be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         RedisConnectionFactory factory =&lt;span&gt; getRequiredConnectionFactory();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         RedisConnection conn = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9             --开启了enableTransactionSupport选项，则会将获取到的连接绑定到当前线程
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (enableTransactionSupport) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; only bind resources in case of potential transaction synchronization&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;                 conn =&lt;span&gt; RedisConnectionUtils.bindConnection(factory, enableTransactionSupport);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {&lt;br/&gt;&lt;span&gt;               -- 未开启，就会去获取新的连接
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 conn =&lt;span&gt; RedisConnectionUtils.getConnection(factory);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; existingConnection =&lt;span&gt; TransactionSynchronizationManager.hasResource(factory);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;             RedisConnection connToUse =&lt;span&gt; preProcessConnection(conn, existingConnection);&lt;br/&gt;。。。忽略无关代码。。。&lt;br/&gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;             RedisConnection connToExpose = (exposeConnection ?&lt;span&gt; connToUse : createRedisConnectionProxy(connToUse));
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             T result =&lt;span&gt; action.doInRedis(connToExpose); &lt;span&gt;-- 使用获取到的连接，执行定义在业务回调中的代码
&lt;/span&gt;&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;               。。。忽略无关代码。。。
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO: any other connection processing?&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; postProcessResult(result, connToUse, existingConnection);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            RedisConnectionUtils.releaseConnection(conn, factory);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;查看以上源码，我们发现，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不启用enableTransactionSupport，默认每次获取新连接，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
RedisTemplate&amp;lt;String, Object&amp;gt; template = &lt;span&gt;new&lt;/span&gt; RedisTemplate&amp;lt;&amp;gt;&lt;span&gt;();
template.multi();

template.opsForValue().set(&lt;/span&gt;&quot;test_long&quot;, 1&lt;span&gt;);

template.opsForValue().increment(&lt;/span&gt;&quot;test_long&quot;, 1&lt;span&gt;);

template.exec();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;ul&gt;&lt;li&gt;启用enableTransactionSupport，每次获取与当前线程绑定的连接，代码如下：&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
RedisTemplate&amp;lt;String, Object&amp;gt; template = &lt;span&gt;new&lt;/span&gt; RedisTemplate&amp;lt;&amp;gt;&lt;span&gt;();

&lt;span&gt;template.setEnableTransactionSupport(&lt;/span&gt;&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;&lt;span&gt;);
&lt;/span&gt;
template.multi();

template.opsForValue().set(&lt;/span&gt;&quot;test_long&quot;, 1&lt;span&gt;);

template.opsForValue().increment(&lt;/span&gt;&quot;test_long&quot;, 1&lt;span&gt;);

template.exec();&lt;/span&gt;　　
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt; 采用这种方式，默认就会将所有操作放在同一个连接，因为在execute(SessionCallback&amp;lt;T&amp;gt; session)（注意，这里是重载函数，参数和上面不一样）源码中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
   public &amp;lt;T&amp;gt; T execute(SessionCallback&amp;lt;T&amp;gt; session) {

                Assert.isTrue(initialized, &quot;template not initialized; call afterPropertiesSet() before using it&quot;);
                Assert.notNull(session, &quot;Callback object must not be null&quot;);

                RedisConnectionFactory factory = getRequiredConnectionFactory();
&lt;span&gt;          //在执行业务回调前，手动进行了绑定
                RedisConnectionUtils.bindConnection(factory, enableTransactionSupport);
&lt;/span&gt;         try {   &lt;span&gt;// 业务回调&lt;/span&gt;
                        return session.execute(this);
                } finally {
                        RedisConnectionUtils.unbindConnection(factory);
                }
        }
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         RedisStandaloneConfiguration configuration = &lt;span&gt;new&lt;/span&gt; RedisStandaloneConfiguration(&quot;192.168.19.90&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         JedisConnectionFactory factory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JedisConnectionFactory(configuration);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        factory.afterPropertiesSet();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;         RedisTemplate&amp;lt;String, Object&amp;gt; template = &lt;span&gt;new&lt;/span&gt; RedisTemplate&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        template.setConnectionFactory(factory);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         template.setDefaultSerializer(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; GenericFastJsonRedisSerializer());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         StringRedisSerializer serializer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringRedisSerializer();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        template.setKeySerializer(serializer);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        template.setHashKeySerializer(serializer);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        template.afterPropertiesSet();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             List&amp;lt;Object&amp;gt; txResults = template.execute(&lt;span&gt;new&lt;/span&gt; SessionCallback&amp;lt;List&amp;lt;Object&amp;gt;&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt; List&amp;lt;Object&amp;gt; execute(RedisOperations operations) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; DataAccessException {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                    operations.multi();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;                     operations.opsForValue().set(&quot;test_long&quot;, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;int&lt;/span&gt; i = 1/0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     operations.opsForValue().increment(&quot;test_long&quot;, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This will contain the results of all ops in the transaction&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; operations.exec();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             System.out.println(&quot;error&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            e.printStackTrace();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;有几个值得注意的点：&lt;/p&gt;
&lt;h2&gt;1、为什么加try catch&lt;/h2&gt;
&lt;p&gt;先说结论：只是为了防止调用的主线程失败。&lt;/p&gt;

&lt;p&gt;因为事务里运行到23行，（int i = 1/0）时，会抛出异常。&lt;/p&gt;
&lt;p&gt;但是在 template.execute(SessionCallback&amp;lt;T&amp;gt; session)中未对其进行捕获，只在finally块进行了连接释放。&lt;/p&gt;
&lt;p&gt;所以会导致调用线程（这里是main线程）中断。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201812/519126-20181219141026435-1510667332.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt; 2.try-catch了，事务到底得到保证了没&lt;/h2&gt;
&lt;p&gt;我们来测试下，测试需要，省略非关键代码&lt;/p&gt;
&lt;h3&gt;2.1 事务执行过程，抛出异常的情况：&lt;/h3&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
            List&amp;lt;Object&amp;gt; txResults = template.execute(new SessionCallback&amp;lt;List&amp;lt;Object&amp;gt;&amp;gt;() {
                @Override
                public List&amp;lt;Object&amp;gt; execute(RedisOperations operations) throws DataAccessException {

                    operations.multi();

                    operations.opsForValue().set(&quot;test_long&quot;, 1);
&lt;span&gt;                    int i = 1/0;
&lt;/span&gt;                    operations.opsForValue().increment(&quot;test_long&quot;, 1);

                    // This will contain the results of all ops in the transaction
                    return operations.exec();
                }
            });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　执行上述代码，执行到int i = 1/0时，会抛出异常。我们需要检查，抛出异常后，是否发送了“discard”命令给redis 服务器？&lt;/p&gt;
&lt;p&gt;下面是我的执行结果，从最后的抓包可以看到，是发送了discard命令的：　　　　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201812/519126-20181220103139297-1558238308.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;2.2 事务执行过程，不抛出异常的情况：&lt;/h3&gt;
&lt;p&gt; 这次我们注释了抛错的那行，可以看到“EXEC”命令已经发出去了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201812/519126-20181220104256692-1321734579.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3 抛出异常，不捕获异常的情况：&lt;/h2&gt;
&lt;p&gt;有些同学可能比较奇怪，为啥网上那么多教程，都是没有捕获异常的，我这里要捕获呢？&lt;/p&gt;
&lt;p&gt;其实我也奇怪，但在我目前测试来看，不捕获的话，执行线程就中断了，因为template.execute是同步执行的。&lt;/p&gt;
&lt;p&gt;来，看看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201812/519126-20181220104756025-1354608174.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;从上图可以看到，主线程被未捕获的异常给中断了，但是，查看网络抓包，发现“DISCARD”命令还是发出去了的。&lt;/p&gt;

&lt;h2&gt;4.总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;从上面可以看出来，不管捕获异常没，事务都能得到保证。只是不捕获异常，会导致主线程中断。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不保证所有版本如此，在我这，spring-data-redis 2.1.3是这样的。&lt;/p&gt;
&lt;p&gt;我跟了n趟代码，发现：&lt;/p&gt;
&lt;p&gt;1、在执行sessionCallBack中的代码时，我们一般会先执行multi命令。&lt;/p&gt;
&lt;p&gt;multi命令的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; multi() {
        execute(connection &lt;/span&gt;-&amp;gt;&lt;span&gt; {
&lt;span&gt;            connection.multi();
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;即调用了当前线程绑定的connection的multi方法。&lt;/p&gt;
&lt;p&gt;进入JedisConnection的multi方法，可以看到：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
private @Nullable Transaction &lt;span&gt;transaction&lt;/span&gt;;
&lt;/pre&gt;
&lt;pre&gt;
&lt;br/&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; multi() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isQueueing()) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isPipelined()) {
                getRequiredPipeline().multi();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }&lt;br/&gt;//赋值给了connection的实例变量
            &lt;/span&gt;&lt;span&gt;this.transaction =&lt;/span&gt;&lt;span&gt;&lt;span&gt; jedis.multi();
&lt;/span&gt;        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; convertJedisAccessException(ex);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;2、在有异常抛出时，直接进入finally块，会去关闭connection，当然，这里的关闭只是还回到连接池。&lt;/p&gt;
&lt;p&gt;大概的逻辑如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201812/519126-20181221133932157-916184394.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3.在没有异常抛出时，执行exec，在exec中会先将状态变量修改，后边进入finally的时候，就不会发送discard命令了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201812/519126-20181221134357387-332576947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; 最后的结论就是：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所有这一切的前提是，共有同一个连接。（使用SessionCallBack的方式就能保证，总是共用同一个连接），否则multi用到的连接1里transcation是有值的，但是后面获取到的其他连接2,3,4，里面的transaction是空的，&lt;/p&gt;
&lt;p&gt;还怎么保证事务呢？&lt;/p&gt;


&lt;p&gt;在不开启redisTemplate的enableTransactionSupport选项时，每执行一次redis操作，就会向服务器发送相应的命令。&lt;/p&gt;
&lt;p&gt;但是，在开启了redisTemplate的enableTransactionSupport选项，或者使用SessionCallback方式时，会像下面这样发送命令：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201812/519126-20181221134702830-12880858.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 后来，我在《redis实战》这本书里的4.4节，Redis事务这一节里，找到了答案：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/519126/201812/519126-20181221134944979-1061274003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;归根到底呢，因为重用同一个连接，所以可以延迟发；如果每次都不一样的连接，只能马上发了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 这里另外说一句，不是所有客户端都这样，redis自带的redis-cli是不会延迟发送的。&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://github.com/cctvckl/work_util/tree/master/spring-redis-template-2.1.3&quot; target=&quot;_blank&quot;&gt;https://github.com/cctvckl/work_util/tree/master/spring-redis-template-2.1.3&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 21 Dec 2018 05:56:00 +0000</pubDate>
<dc:creator>三国梦回</dc:creator>
<og:description>一、官方文档 简单介绍下redis的几个事务命令： redis事务四大指令: MULTI、EXEC、DISCARD、WATCH。 这四个指令构成了redis事务处理的基础。 1.MULTI用来组装一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/grey-wolf/p/10142937.html</dc:identifier>
</item>
</channel>
</rss>