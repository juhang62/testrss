<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【一起学源码-微服务】Ribbon 源码一：Ribbon概念理解及Demo调试 - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/12151486.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/12151486.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;h4 id=&quot;前情回顾&quot;&gt;前情回顾&lt;/h4&gt;
&lt;p&gt;前面文章已经梳理清楚了Eureka相关的概念及源码，接下来开始研究下Ribbon的实现原理。&lt;/p&gt;
&lt;p&gt;我们都知道Ribbon在spring cloud中担当&lt;strong&gt;负载均衡&lt;/strong&gt;的角色， 当两个Eureka Client互相调用的时候，Ribbon能够做到调用时的负载，保证多节点的客户端均匀接收请求。(这个有点类似于前端调用后端时Nginx做的负载均衡)&lt;/p&gt;
&lt;h4 id=&quot;本讲目录&quot;&gt;本讲目录&lt;/h4&gt;
&lt;p&gt;本讲主通过一个简单的demo来了解ribbon内部实现，这里主要是对ribbon有个宏观的认识，后续篇章会一步步通过debug的方式对ribbon的细节做一个全面的讲解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目录如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一个demo来看看ribbon是做什么的&lt;/li&gt;
&lt;li&gt;@LoadBalanced初探&lt;/li&gt;
&lt;li&gt;LoadBalancerAutoConfiguration初探&lt;/li&gt;
&lt;li&gt;RibbonLoadBalancerClient初探&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;说明&quot;&gt;说明&lt;/h4&gt;
&lt;p&gt;原创不易，如若转载 请标明来源！&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;一枝花算不算浪漫&lt;/a&gt;&lt;br/&gt;微信公众号：壹枝花算不算浪漫 （文章底部有公众号二维码）&lt;/p&gt;
&lt;h3 id=&quot;ribbon正文&quot;&gt;Ribbon正文&lt;/h3&gt;
&lt;h4 id=&quot;一个demo来看看ribbon是做什么的&quot;&gt;一个demo来看看ribbon是做什么的&lt;/h4&gt;
&lt;p&gt;首先看下我们这里的demo，目录结构如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pic.downk.cc/item/5e0eac8f76085c32897e7ab3.png&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082029929-1729026027.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这里有3个模块，eurekaServer作为注册中心，serviceA和serviceB分别作为EurekaClient。&lt;/p&gt;
&lt;p&gt;代码地址上传到了自己的git：&lt;br/&gt;https://github.com/barrywangmeng/spring-cloud-learn&lt;/p&gt;
&lt;h4 id=&quot;ribbon相关的类结构信息&quot;&gt;ribbon相关的类结构信息&lt;/h4&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;启动了eureka client如下：&lt;br/&gt;&lt;strong&gt;服务A 2个&lt;/strong&gt;： 一个端口号为8087，另一个为8088&lt;br/&gt;&lt;strong&gt;服务B 1个&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082033179-443484132.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查看注册中心Dashboard&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082033567-1400489503.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务B调用服务A中的接口&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082034121-82344400.jpg&quot; alt=&quot;调用&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;查看负载均衡情况&lt;br/&gt;第一次调用服务B的greeting方法：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082036089-380230309.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;第二次调用服务A的greeting方法：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082037662-612781460.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里可以看到服务A调用的时候加了一个注解: &lt;code&gt;@LoadBalanced&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;服务B第一次调用到了服务A的&lt;strong&gt;8088&lt;/strong&gt;那个节点&lt;br/&gt;服务B第二次调用到了服务A的&lt;strong&gt;8087&lt;/strong&gt;那个节点&lt;/p&gt;
&lt;p&gt;这里就可以证明使用&lt;code&gt;@LoadBalanced&lt;/code&gt; 自动对我们的http请求加了负载均衡，接下来我们就用&lt;code&gt;@LoadBalanced&lt;/code&gt;来一步步往下看。&lt;/p&gt;
&lt;h4 id=&quot;loadbalanced初探&quot;&gt;@LoadBalanced初探&lt;/h4&gt;
&lt;p&gt;接下来看下&lt;code&gt;@LoadBalanced&lt;/code&gt;的源码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** * Annotation to mark a RestTemplate bean to be configured to use 
a LoadBalancerClient * @author Spencer Gibb */@Target({ ElementType.FIELD, ElementType.PARAMETER, 
ElementType.METHOD })@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Qualifierpublic @interface LoadBalanced {}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要看注释，这里意思是使用这个注解后可以将普通的&lt;code&gt;RestTemplate&lt;/code&gt; 使用 &lt;code&gt;LoadBalanceClient&lt;/code&gt; 这个类去处理。&lt;/p&gt;
&lt;p&gt;接着我们看下&lt;code&gt;LoadBalanced&lt;/code&gt;相关的配置。&lt;/p&gt;
&lt;h4 id=&quot;loadbalancerautoconfiguration初探&quot;&gt;LoadBalancerAutoConfiguration初探&lt;/h4&gt;
&lt;p&gt;我们知道，springboot + springcloud 对应的组件都会有相应的XXXAutoConfigure配置类，同理，我们在&lt;code&gt;LoadBalanced&lt;/code&gt;同级包下可以找到对应的AutoConfigure类：&lt;code&gt;LoadBalancerAutoConfiguration&lt;/code&gt;, 先看下类的定义：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@ConditionalOnClass(RestTemplate.class)
@ConditionalOnBean(LoadBalancerClient.class)
@EnableConfigurationProperties(LoadBalancerRetryProperties.class)
public class LoadBalancerAutoConfiguration {

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里有个 &lt;code&gt;@ConditionalOnClass(RestTemplate.class)&lt;/code&gt;，这个含义是 只有存在&lt;code&gt;RestTemplate&lt;/code&gt; 这个类的时该配置才会生效。&lt;/p&gt;
&lt;p&gt;接着看&lt;code&gt;LoadBalancerAutoConfiguration&lt;/code&gt;中的一些方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LoadBalancerAutoConfiguration {    
    @LoadBalanced
    @Autowired(required = false)
    private List&amp;lt;RestTemplate&amp;gt; restTemplates = Collections.emptyList();

    @Bean
    public SmartInitializingSingleton loadBalancedRestTemplateInitializer(
            final List&amp;lt;RestTemplateCustomizer&amp;gt; customizers) {
        return new SmartInitializingSingleton() {
            @Override
            public void afterSingletonsInstantiated() {
                for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) {
                    for (RestTemplateCustomizer customizer : customizers) {
                        customizer.customize(restTemplate);
                    }
                }
            }
        };
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看下&lt;code&gt;loadBalancedRestTemplateInitializer&lt;/code&gt; 方法，这个里面会遍历&lt;code&gt;restTemplates&lt;/code&gt;然后调用&lt;code&gt;customize()&lt;/code&gt; 方法进行特殊处理。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LoadBalancerAutoConfiguration {    
    @LoadBalanced
    @Autowired(required = false)
    private List&amp;lt;RestTemplate&amp;gt; restTemplates = Collections.emptyList();

    @Configuration
    @ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;)
    static class LoadBalancerInterceptorConfig {
        @Bean
        public LoadBalancerInterceptor ribbonInterceptor(
                LoadBalancerClient loadBalancerClient,
                LoadBalancerRequestFactory requestFactory) {
            return new LoadBalancerInterceptor(loadBalancerClient, requestFactory);
        }

        @Bean
        @ConditionalOnMissingBean
        public RestTemplateCustomizer restTemplateCustomizer(
                final LoadBalancerInterceptor loadBalancerInterceptor) {
            return new RestTemplateCustomizer() {
                @Override
                public void customize(RestTemplate restTemplate) {
                    List&amp;lt;ClientHttpRequestInterceptor&amp;gt; list = new ArrayList&amp;lt;&amp;gt;(
                            restTemplate.getInterceptors());
                    list.add(loadBalancerInterceptor);
                    restTemplate.setInterceptors(list);
                }
            };
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面是为每一个&lt;code&gt;restTemplate&lt;/code&gt; 添加一个&lt;code&gt;loadBalancerInterceptor&lt;/code&gt; 拦截器，紧接着看一下&lt;code&gt;LoadBalancerInterceptor.java&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class LoadBalancerInterceptor implements ClientHttpRequestInterceptor {

    private LoadBalancerClient loadBalancer;
    private LoadBalancerRequestFactory requestFactory;

    @Override
    public ClientHttpResponse intercept(final HttpRequest request, final byte[] body,
            final ClientHttpRequestExecution execution) throws IOException {
        final URI originalUri = request.getURI();
        String serviceName = originalUri.getHost();
        Assert.state(serviceName != null, &quot;Request URI does not contain a valid hostname: &quot; + originalUri);
        return this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面就很简单了，将serviceName(这里就是对应我们demo中的：ServiceA)和request、body、excution等组成的新的request传递给&lt;code&gt;LoadBalancerClient&lt;/code&gt;，然后调用其中的&lt;code&gt;execute&lt;/code&gt;,这个方法的实现继续往下看&lt;code&gt;RibbonLoadBalancerClient&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;ribbonloadbalancerclient初探&quot;&gt;RibbonLoadBalancerClient初探&lt;/h4&gt;
&lt;p&gt;接下来再看一下 &lt;code&gt;LoadBalanceClient&lt;/code&gt; ：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface LoadBalancerClient extends ServiceInstanceChooser {

    &amp;lt;T&amp;gt; T execute(String serviceId, LoadBalancerRequest&amp;lt;T&amp;gt; request) throws IOException;

    &amp;lt;T&amp;gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&amp;lt;T&amp;gt; request) throws IOException;

    URI reconstructURI(ServiceInstance instance, URI original);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个接口只有一个实现类：&lt;code&gt;RibbonLoadBalancerClient&lt;/code&gt;， 那么我们继续看实现类中的execute方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public &amp;lt;T&amp;gt; T execute(String serviceId, LoadBalancerRequest&amp;lt;T&amp;gt; request) throws IOException {
    ILoadBalancer loadBalancer = getLoadBalancer(serviceId);
    Server server = getServer(loadBalancer);
    if (server == null) {
        throw new IllegalStateException(&quot;No instances available for &quot; + serviceId);
    }
    RibbonServer ribbonServer = new RibbonServer(serviceId, server, isSecure(server,
            serviceId), serverIntrospector(serviceId).getMetadata(server));

    return execute(serviceId, ribbonServer, request);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着就可以在这个方法上愉快的debug了，我们先看看&lt;code&gt;ILoadBalancer&lt;/code&gt; 是干嘛的：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pic.downk.cc/item/5e0eb24e76085c32897f94fb.jpg&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082039639-1582989998.jpg&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们通过debug可以看到 获取的&lt;code&gt;ILoadBalancer&lt;/code&gt; 已经获取到服务A所有的节点信息了，这一章就先不延伸下去了，后面会详细来说&lt;code&gt;ILoadBalancer&lt;/code&gt;处理的细节。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;这一篇主要讲解了一个&lt;code&gt;RestTemplate&lt;/code&gt; 加上&lt;code&gt;@LoadBalanced&lt;/code&gt; 注解后是如何获取到请求服务的多个节点信息的，通过debug 我们可以很清晰的看到请求流程，最后画一个图来总结一下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pic.downk.cc/item/5e0eb7c876085c328980ebe1.png&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082040226-3881986.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;申明&quot;&gt;申明&lt;/h3&gt;
&lt;p&gt;本文章首发自本人博客：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;https://www.cnblogs.com/wang-meng&lt;/a&gt; 和公众号：&lt;strong&gt;壹枝花算不算浪漫&lt;/strong&gt;，如若转载请标明来源!&lt;/p&gt;
&lt;p&gt;感兴趣的小伙伴可关注个人公众号：壹枝花算不算浪漫&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200105082040495-390264547.jpg&quot; alt=&quot;22.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 05 Jan 2020 00:21:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>前言 前情回顾 前面文章已经梳理清楚了Eureka相关的概念及源码，接下来开始研究下Ribbon的实现原理。 我们都知道Ribbon在spring cloud中担当 负载均衡 的角色， 当两个Eure</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/12151486.html</dc:identifier>
</item>
<item>
<title>JVM探秘：GC日志收集与分析 - Cellei</title>
<link>http://www.cnblogs.com/cellei/p/12151478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cellei/p/12151478.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本系列笔记主要基于《深入理解Java虚拟机：JVM高级特性与最佳实践 第2版》，是这本书的读书笔记。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;收集gc日志&quot;&gt;收集GC日志&lt;/h2&gt;
&lt;p&gt;不同的垃圾收集器，输出的日志格式各不相同，但也有一些相同的特征。熟悉各个常用垃圾收集器的GC日志，是进行JVM调优的必备一步。&lt;br/&gt;解析GC日志，首先需要收集日志，常用的有以下JVM参数用来打印输出日志信息：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;-XX:+PrintGCDetails&lt;/td&gt;
&lt;td&gt;打印GC详细信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-XX:+PrintGCTimeStamps&lt;/td&gt;
&lt;td&gt;输出GC的时间戳（以基准时间的形式）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-XX:+PrintGCDateStamps&lt;/td&gt;
&lt;td&gt;输出GC的时间戳（以日期的形式）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;-XX:+PrintHeapAtGC&lt;/td&gt;
&lt;td&gt;在进行GC的前后打印出堆的信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;-XX:+PrintTenuringDistribution&lt;/td&gt;
&lt;td&gt;在进行GC时打印survivor中的对象年龄分布信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;-Xloggc:$CATALINA_HOME/logs/gc.log&lt;/td&gt;
&lt;td&gt;指定输出路径收集日志到日志文件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;例如，我使用如下参数启动：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-Xms28m
-Xmx28m
-XX:PermSize=14M
-XX:MaxNewSize=14m
-XX:MaxPermSize=14m
-XX:+PrintGCDetails
-XX:+PrintGCDateStamps
-Xloggc:E:/logs/gc.log&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要指定垃圾收集器，还需要添加对应的JVM参数，例如&lt;code&gt;-XX:+UseG1GC&lt;/code&gt;、&lt;code&gt;-XX:+UseConcMarkSweepGC&lt;/code&gt;等&lt;/p&gt;
&lt;h2 id=&quot;xxuseparallelgc日志解析&quot;&gt;-XX:+UseParallelGC日志解析&lt;/h2&gt;
&lt;p&gt;JDK1.8的默认收集器为Parallel收集器+Serial Old收集器组合（-XX:+UseParallelGC），日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Java HotSpot(TM) 64-Bit Server VM (25.131-b11) for windows-amd64 JRE (1.8.0_131-b11), built on Mar 15 2017 01:23:53 by &quot;java_re&quot; with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 8303556k(2789672k free), swap 16215992k(6967912k free)
CommandLine flags: -XX:InitialHeapSize=29360128 -XX:MaxHeapSize=29360128 -XX:MaxNewSize=14680064 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 
2018-05-08T19:23:01.815+0800: 0.574: [GC (Allocation Failure) [PSYoungGen: 11264K-&amp;gt;1531K(12800K)] 11264K-&amp;gt;2283K(27136K), 0.0039021 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-08T19:23:01.906+0800: 0.664: [GC (System.gc()) [PSYoungGen: 6560K-&amp;gt;1516K(12800K)] 7311K-&amp;gt;2625K(27136K), 0.0030390 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-08T19:23:01.908+0800: 0.667: [Full GC (System.gc()) [PSYoungGen: 1516K-&amp;gt;0K(12800K)] [ParOldGen: 1109K-&amp;gt;2005K(14336K)] 2625K-&amp;gt;2005K(27136K), [Metaspace: 5955K-&amp;gt;5955K(1056768K)], 0.0102082 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
2018-05-08T19:23:01.954+0800: 0.714: [GC (Allocation Failure) [PSYoungGen: 11263K-&amp;gt;64K(12800K)] 13269K-&amp;gt;2069K(27136K), 0.0005071 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-08T19:23:01.988+0800: 0.748: [GC (Allocation Failure) [PSYoungGen: 11327K-&amp;gt;64K(12800K)] 13333K-&amp;gt;2069K(27136K), 0.0003509 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-08T19:23:02.019+0800: 0.779: [GC (Allocation Failure) [PSYoungGen: 11328K-&amp;gt;128K(12800K)] 13333K-&amp;gt;2133K(27136K), 0.0003730 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-08T19:23:02.049+0800: 0.809: [GC (Allocation Failure) [PSYoungGen: 11391K-&amp;gt;64K(9728K)] 13397K-&amp;gt;2077K(24064K), 0.0003454 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-08T19:24:28.365+0800: 87.124: [GC (System.gc()) [PSYoungGen: 306K-&amp;gt;32K(11264K)] 2320K-&amp;gt;2045K(25600K), 0.0005228 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-08T19:24:28.365+0800: 87.124: [Full GC (System.gc()) [PSYoungGen: 32K-&amp;gt;0K(11264K)] [ParOldGen: 2013K-&amp;gt;1706K(14336K)] 2045K-&amp;gt;1706K(25600K), [Metaspace: 6027K-&amp;gt;6021K(1056768K)], 0.0135435 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 11264K, used 324K [0x00000000ff200000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 3% used [0x00000000ff200000,0x00000000ff2513a0,0x00000000ffa00000)
  from space 3072K, 0% used [0x00000000ffa00000,0x00000000ffa00000,0x00000000ffd00000)
  to   space 3072K, 0% used [0x00000000ffd00000,0x00000000ffd00000,0x0000000100000000)
 ParOldGen       total 14336K, used 1706K [0x00000000fe400000, 0x00000000ff200000, 0x00000000ff200000)
  object space 14336K, 11% used [0x00000000fe400000,0x00000000fe5aa8f8,0x00000000ff200000)
 Metaspace       used 6032K, capacity 6242K, committed 6400K, reserved 1056768K
  class space    used 688K, capacity 756K, committed 768K, reserved 1048576K
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三行把当前使用的JVM参数打印了出来，初始化了堆大小，设置了最大堆，最后打印出来GC参数-XX:+UseParallelGC。&lt;/p&gt;
&lt;p&gt;第四行开始是垃圾收集记录，首先是垃圾收集的时间。然后是发生GC的原因，&lt;code&gt;GC (Allocation Failure)&lt;/code&gt;对象分配失败，&lt;code&gt;GC&lt;/code&gt;表示新生代Young区的GC，&lt;code&gt;Full GC&lt;/code&gt;则包含老年代。&lt;code&gt;[PSYoungGen: 11264K-&amp;gt;1531K(12800K)]&lt;/code&gt;表示Young区回收前大小是11264K，回收后是1531K，总大小是12800K。紧接着中括号外，&lt;code&gt;11264K-&amp;gt;2283K(27136K)&lt;/code&gt;表示回收前整个堆大小是11264K，回收后堆大小2283K，堆总大小27136K。&lt;code&gt;0.0039021 secs&lt;/code&gt;是垃圾回收用的时间。可以看出，新生代由11M变为了约1.5M，而整个堆由11M变为了约2.2M，也就是这次GC后，老年代约为0.7M。&lt;/p&gt;
&lt;p&gt;后面的格式都是类似的，再看第六行Full GC的日志。&lt;/p&gt;
&lt;p&gt;第六行，首先也是GC发生的时间。然后是发生GC的原因，&lt;code&gt;Full GC (System.gc())&lt;/code&gt;由于代码System.gc()发起了Full GC。&lt;code&gt;[PSYoungGen: 1516K-&amp;gt;0K(12800K)]&lt;/code&gt;表示回收前新生代是1516K，回收后0K，新生代总大小是12800K。&lt;code&gt;[ParOldGen: 1109K-&amp;gt;2005K(14336K)]&lt;/code&gt;表示回收前老年代是1109K，回收后2005K，老年代总大小14336K。紧接着中括号外，&lt;code&gt;2625K-&amp;gt;2005K(27136K)&lt;/code&gt;回收前堆大小2625K，回收后2005K，堆总大小27136K。&lt;code&gt;[Metaspace: 5955K-&amp;gt;5955K(1056768K)]&lt;/code&gt;回收前元空间大小5955K，回收后5955K，总大小1056768K。这次GC用时0.0102082 secs。&lt;/p&gt;
&lt;p&gt;日志的最后打印出了堆的信息，新生代总大小11264K，已使用324K，新生代中的eden区大小8192K，已用3%，两个survivor区都是3072K。老年代总大小14336K，已使用1706K。元空间已使用6032K。&lt;/p&gt;
&lt;h2 id=&quot;xxuseserialgc日志解析&quot;&gt;-XX:+UseSerialGC日志解析&lt;/h2&gt;
&lt;p&gt;Serial收集器+Serial Old收集器组合（-XX:+UseSerialGC）的日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Java HotSpot(TM) 64-Bit Server VM (25.131-b11) for windows-amd64 JRE (1.8.0_131-b11), built on Mar 15 2017 01:23:53 by &quot;java_re&quot; with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 8303556k(2575660k free), swap 16215992k(7063788k free)
CommandLine flags: -XX:InitialHeapSize=29360128 -XX:MaxHeapSize=29360128 -XX:MaxNewSize=14680064 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseSerialGC 
2018-05-08T19:31:03.644+0800: 0.676: [GC (Allocation Failure) 2018-08-08T19:31:03.644+0800: 0.676: [DefNew: 11520K-&amp;gt;1408K(12928K), 0.0049897 secs] 11520K-&amp;gt;2234K(27264K), 0.0051851 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-08T19:31:03.744+0800: 0.775: [Full GC (System.gc()) 2018-08-08T19:31:03.744+0800: 0.775: [Tenured: 826K-&amp;gt;2569K(14336K), 0.0292213 secs] 7147K-&amp;gt;2569K(27264K), [Metaspace: 5939K-&amp;gt;5939K(1056768K)], 0.0292829 secs] [Times: user=0.02 sys=0.00, real=0.03 secs] 
2018-05-08T19:31:03.811+0800: 0.843: [GC (Allocation Failure) 2018-08-08T19:31:03.811+0800: 0.843: [DefNew: 11519K-&amp;gt;4K(12928K), 0.0009580 secs] 14088K-&amp;gt;2573K(27264K), 0.0010026 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-08T19:31:03.878+0800: 0.909: [GC (Allocation Failure) 2018-08-08T19:31:03.878+0800: 0.909: [DefNew: 11523K-&amp;gt;3K(12928K), 0.0003602 secs] 14092K-&amp;gt;2572K(27264K), 0.0004109 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-08T19:31:03.935+0800: 0.967: [GC (Allocation Failure) 2018-08-08T19:31:03.935+0800: 0.967: [DefNew: 11523K-&amp;gt;3K(12928K), 0.0004648 secs] 14092K-&amp;gt;2572K(27264K), 0.0005109 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 
2018-05-08T19:32:31.148+0800: 88.179: [Full GC (System.gc()) 2018-08-08T19:32:31.148+0800: 88.179: [Tenured: 2569K-&amp;gt;2540K(14336K), 0.0078915 secs] 13176K-&amp;gt;2540K(27264K), [Metaspace: 6017K-&amp;gt;6017K(1056768K)], 0.0079582 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
Heap
 def new generation   total 12928K, used 458K [0x00000000fe400000, 0x00000000ff200000, 0x00000000ff200000)
  eden space 11520K,   3% used [0x00000000fe400000, 0x00000000fe472838, 0x00000000fef40000)
  from space 1408K,   0% used [0x00000000fef40000, 0x00000000fef40000, 0x00000000ff0a0000)
  to   space 1408K,   0% used [0x00000000ff0a0000, 0x00000000ff0a0000, 0x00000000ff200000)
 tenured generation   total 14336K, used 2540K [0x00000000ff200000, 0x0000000100000000, 0x0000000100000000)
   the space 14336K,  17% used [0x00000000ff200000, 0x00000000ff47b1e8, 0x00000000ff47b200, 0x0000000100000000)
 Metaspace       used 6029K, capacity 6252K, committed 6400K, reserved 1056768K
  class space    used 691K, capacity 761K, committed 768K, reserved 1048576K
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Serial收集器已经很少使用，GC日志的格式也是大同小异，&lt;code&gt;[GC&lt;/code&gt;开头的是新生代GC，DefNew表示新生代。会打印GC发生时间，GC原因，新生代回收前大小、回收后大小、以及新生代总大小。打印堆的回收前大小、回收后大小、及总大小，打印GC耗时。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;[Full GC&lt;/code&gt;开头的是老年代GC，Tenured表示老年代。会打印GC发生时间，GC原因，老年代回收前大小、回收后大小、以及老年代总大小。打印堆的回收前大小、回收后大小、及堆的总大小。打印元空间的回收前、回收后、及总大小，打印GC耗时。&lt;/p&gt;
&lt;p&gt;最后打印出整个堆的使用情况。&lt;/p&gt;
&lt;h2 id=&quot;xxuseparnewgc日志解析&quot;&gt;-XX:+UseParNewGC日志解析&lt;/h2&gt;
&lt;p&gt;ParNew收集器+Serilal Old组合（-XX:+UseParNewGC）的日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Java HotSpot(TM) 64-Bit Server VM (25.131-b11) for windows-amd64 JRE (1.8.0_131-b11), built on Mar 15 2017 01:23:53 by &quot;java_re&quot; with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 8303556k(2874368k free), swap 16215992k(9448728k free)
CommandLine flags: -XX:InitialHeapSize=29360128 -XX:MaxHeapSize=29360128 -XX:MaxNewSize=14680064 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC 
2018-05-09T20:41:34.699+0800: 4.632: [GC (Allocation Failure) 2018-08-09T08:41:34.711+0800: 4.633: [ParNew: 11520K-&amp;gt;1408K(12928K), 0.0149096 secs] 11520K-&amp;gt;2265K(27264K), 0.0271137 secs] [Times: user=0.08 sys=0.00, real=0.03 secs] 
2018-05-09T20:41:34.886+0800: 4.808: [Full GC (System.gc()) 2018-08-09T08:41:34.886+0800: 4.808: [Tenured: 857K-&amp;gt;2567K(14336K), 0.0091055 secs] 6992K-&amp;gt;2567K(27264K), [Metaspace: 5940K-&amp;gt;5940K(1056768K)], 0.0091703 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
2018-05-09T20:41:34.964+0800: 4.887: [GC (Allocation Failure) 2018-08-09T08:41:34.964+0800: 4.887: [ParNew: 11519K-&amp;gt;1214K(12928K), 0.0132311 secs] 14086K-&amp;gt;3781K(27264K), 0.0132796 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
2018-05-09T20:41:35.024+0800: 4.946: [GC (Allocation Failure) 2018-08-09T08:41:35.024+0800: 4.946: [ParNew: 12734K-&amp;gt;151K(12928K), 0.0004635 secs] 15301K-&amp;gt;2719K(27264K), 0.0005408 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-09T20:41:35.057+0800: 4.979: [GC (Allocation Failure) 2018-08-09T08:41:35.057+0800: 4.979: [ParNew: 11671K-&amp;gt;38K(12928K), 0.0003371 secs] 14239K-&amp;gt;2605K(27264K), 0.0003801 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-09T20:42:59.030+0800: 88.953: [Full GC (System.gc()) 2018-08-09T08:42:59.030+0800: 88.953: [Tenured: 2567K-&amp;gt;2536K(14336K), 0.0086218 secs] 13341K-&amp;gt;2536K(27264K), [Metaspace: 6012K-&amp;gt;6012K(1056768K)], 0.0086850 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
Heap
 par new generation   total 12928K, used 227K [0x00000000fe400000, 0x00000000ff200000, 0x00000000ff200000)
  eden space 11520K,   1% used [0x00000000fe400000, 0x00000000fe438f88, 0x00000000fef40000)
  from space 1408K,   0% used [0x00000000fef40000, 0x00000000fef40000, 0x00000000ff0a0000)
  to   space 1408K,   0% used [0x00000000ff0a0000, 0x00000000ff0a0000, 0x00000000ff200000)
 tenured generation   total 14336K, used 2536K [0x00000000ff200000, 0x0000000100000000, 0x0000000100000000)
   the space 14336K,  17% used [0x00000000ff200000, 0x00000000ff47a1e8, 0x00000000ff47a200, 0x0000000100000000)
 Metaspace       used 6023K, capacity 6252K, committed 6400K, reserved 1056768K
  class space    used 691K, capacity 761K, committed 768K, reserved 1048576K
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是ParNew收集器+Serilal Old组合的GC日志，格式大同小异。&lt;/p&gt;
&lt;h2 id=&quot;xxuseparalleloldgc日志解析&quot;&gt;-XX:+UseParallelOldGC日志解析&lt;/h2&gt;
&lt;p&gt;Parallel收集器+Parallel Old收集器组合（-XX:+UseParallelOldGC）的日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Java HotSpot(TM) 64-Bit Server VM (25.131-b11) for windows-amd64 JRE (1.8.0_131-b11), built on Mar 15 2017 01:23:53 by &quot;java_re&quot; with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 8303556k(2759076k free), swap 16215992k(7616208k free)
CommandLine flags: -XX:InitialHeapSize=29360128 -XX:MaxHeapSize=29360128 -XX:MaxNewSize=14680064 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelOldGC 
2018-05-09T20:44:49.341+0800: 0.618: [GC (Allocation Failure) [PSYoungGen: 11264K-&amp;gt;1531K(12800K)] 11264K-&amp;gt;2274K(27136K), 0.0043755 secs] [Times: user=0.05 sys=0.00, real=0.00 secs] 
2018-05-09T20:44:49.478+0800: 0.754: [GC (System.gc()) [PSYoungGen: 6544K-&amp;gt;1531K(12800K)] 7286K-&amp;gt;2626K(27136K), 0.0064927 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
2018-05-09T20:44:49.484+0800: 0.761: [Full GC (System.gc()) [PSYoungGen: 1531K-&amp;gt;0K(12800K)] [ParOldGen: 1094K-&amp;gt;1917K(14336K)] 2626K-&amp;gt;1917K(27136K), [Metaspace: 5968K-&amp;gt;5968K(1056768K)], 0.0125897 secs] [Times: user=0.03 sys=0.00, real=0.01 secs] 
2018-05-09T20:44:49.624+0800: 0.901: [GC (Allocation Failure) [PSYoungGen: 11263K-&amp;gt;64K(12800K)] 13181K-&amp;gt;1981K(27136K), 0.0227273 secs] [Times: user=0.00 sys=0.00, real=0.02 secs] 
2018-05-09T20:44:49.690+0800: 0.967: [GC (Allocation Failure) [PSYoungGen: 11327K-&amp;gt;64K(12800K)] 13245K-&amp;gt;1981K(27136K), 0.0004702 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-09T20:44:49.729+0800: 1.007: [GC (Allocation Failure) [PSYoungGen: 11328K-&amp;gt;64K(12800K)] 13245K-&amp;gt;1981K(27136K), 0.0080092 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
2018-05-09T20:44:49.774+0800: 1.052: [GC (Allocation Failure) [PSYoungGen: 11327K-&amp;gt;64K(9728K)] 13245K-&amp;gt;1989K(24064K), 0.0019594 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-09T20:46:15.771+0800: 87.048: [GC (System.gc()) [PSYoungGen: 302K-&amp;gt;64K(11264K)] 2227K-&amp;gt;1989K(25600K), 0.0004195 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-09T20:46:15.771+0800: 87.048: [Full GC (System.gc()) [PSYoungGen: 64K-&amp;gt;0K(11264K)] [ParOldGen: 1925K-&amp;gt;1704K(14336K)] 1989K-&amp;gt;1704K(25600K), [Metaspace: 6039K-&amp;gt;6033K(1056768K)], 0.0126567 secs] [Times: user=0.05 sys=0.00, real=0.01 secs] 
Heap
 PSYoungGen      total 11264K, used 324K [0x00000000ff200000, 0x0000000100000000, 0x0000000100000000)
  eden space 8192K, 3% used [0x00000000ff200000,0x00000000ff2513a0,0x00000000ffa00000)
  from space 3072K, 0% used [0x00000000ffa00000,0x00000000ffa00000,0x00000000ffd00000)
  to   space 3072K, 0% used [0x00000000ffd00000,0x00000000ffd00000,0x0000000100000000)
 ParOldGen       total 14336K, used 1704K [0x00000000fe400000, 0x00000000ff200000, 0x00000000ff200000)
  object space 14336K, 11% used [0x00000000fe400000,0x00000000fe5aa360,0x00000000ff200000)
 Metaspace       used 6044K, capacity 6242K, committed 6400K, reserved 1056768K
  class space    used 688K, capacity 756K, committed 768K, reserved 1048576K
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是Parallel收集器+Parallel Old收集器组合的GC日志，格式跟JDK1.8默认的&lt;code&gt;-XX:+UseParallelGC&lt;/code&gt;大同小异。&lt;/p&gt;
&lt;h2 id=&quot;xxuseconcmarksweepgc日志解析&quot;&gt;-XX:+UseConcMarkSweepGC日志解析&lt;/h2&gt;
&lt;p&gt;-XX:+UseConcMarkSweepGC会指定CMS收集器+ParNew收集器+Serial Old收集器组合，优先使用ParNew收集器+CMS收集器的组合，当出现ConcurrentMode Fail或者Promotion Failed时，则采用ParNew收集器+Serial Old收集器的组合。日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Java HotSpot(TM) 64-Bit Server VM (25.131-b11) for windows-amd64 JRE (1.8.0_131-b11), built on Mar 15 2017 01:23:53 by &quot;java_re&quot; with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 8303556k(2846816k free), swap 16215992k(7664596k free)
CommandLine flags: -XX:InitialHeapSize=29360128 -XX:MaxHeapSize=29360128 -XX:MaxNewSize=14680064 -XX:MaxTenuringThreshold=6 -XX:OldPLABSize=16 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC 
2018-05-09T20:53:14.086+0800: 0.590: [GC (Allocation Failure) 2018-08-09T11:53:14.086+0800: 0.590: [ParNew: 11520K-&amp;gt;1407K(12928K), 0.0034803 secs] 11520K-&amp;gt;2254K(27264K), 0.0039082 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-09T20:53:14.247+0800: 0.751: [Full GC (System.gc()) 2018-08-09T11:53:14.247+0800: 0.751: [CMS: 846K-&amp;gt;1930K(14336K), 0.0103698 secs] 7165K-&amp;gt;1930K(27264K), [Metaspace: 5963K-&amp;gt;5963K(1056768K)], 0.0104529 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
2018-05-09T20:53:14.292+0800: 0.795: [GC (Allocation Failure) 2018-08-09T11:53:14.292+0800: 0.795: [ParNew: 11519K-&amp;gt;1199K(12928K), 0.0085679 secs] 13450K-&amp;gt;3129K(27264K), 0.0086244 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
2018-05-09T20:53:14.333+0800: 0.836: [GC (Allocation Failure) 2018-08-09T11:53:14.333+0800: 0.836: [ParNew: 12719K-&amp;gt;300K(12928K), 0.0002620 secs] 14649K-&amp;gt;2230K(27264K), 0.0003041 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-09T20:53:14.364+0800: 0.867: [GC (Allocation Failure) 2018-08-09T11:53:14.364+0800: 0.867: [ParNew: 11820K-&amp;gt;75K(12928K), 0.0002787 secs] 13750K-&amp;gt;2005K(27264K), 0.0003223 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
# 并发标记周期开始，根区域扫描
2018-05-09T20:59:47.982+0800: 9.634: [GC concurrent-root-region-scan-start]
2018-05-09T20:59:47.982+0800: 9.652: [GC concurrent-root-region-scan-end, 0.0184308 secs]
# 并发标记
2018-05-09T20:59:47.982+0800: 9.652: [GC concurrent-mark-start]
2018-05-09T20:59:47.982+0800: 9.693: [GC concurrent-mark-end, 0.0406187 secs]
# 重新标记
2018-05-09T20:59:47.982+0800: 9.695: [GC remark 9.695: [Finalize Marking, 0.0005100 secs] 9.695: [GC ref-proc, 0.0003461 secs] 9.696: [Unloading, 0.0069466 secs], 0.0082011 secs]
 [Times: user=0.02 sys=0.00, real=0.01 secs] 
# 独占清理
2018-05-09T20:59:47.982+0800: 9.703: [GC cleanup 25M-&amp;gt;21M(1024M), 0.0027119 secs]
 [Times: user=0.00 sys=0.01, real=0.00 secs] 
# 并发清理
2018-05-09T20:59:47.982+0800: 9.706: [GC concurrent-cleanup-start]
2018-05-09T20:59:47.982+0800: 9.706: [GC concurrent-cleanup-end, 0.0000167 secs]
2018-05-09T20:54:39.299+0800: 85.803: [Full GC (System.gc()) 2018-08-09T11:54:39.299+0800: 85.803: [CMS: 1930K-&amp;gt;1832K(14336K), 0.0089015 secs] 12748K-&amp;gt;1832K(27264K), [Metaspace: 6035K-&amp;gt;6035K(1056768K)], 0.0089724 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 

Heap
 par new generation   total 12928K, used 227K [0x00000000fe400000, 0x00000000ff200000, 0x00000000ff200000)
  eden space 11520K,   1% used [0x00000000fe400000, 0x00000000fe438cd8, 0x00000000fef40000)
  from space 1408K,   0% used [0x00000000fef40000, 0x00000000fef40000, 0x00000000ff0a0000)
  to   space 1408K,   0% used [0x00000000ff0a0000, 0x00000000ff0a0000, 0x00000000ff200000)
 concurrent mark-sweep generation total 14336K, used 1832K [0x00000000ff200000, 0x0000000100000000, 0x0000000100000000)
 Metaspace       used 6045K, capacity 6252K, committed 6400K, reserved 1056768K
  class space    used 691K, capacity 761K, committed 768K, reserved 1048576K
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三行把当前使用的JVM参数打印出来，其中，&lt;code&gt;-XX:MaxTenuringThreshold=6&lt;/code&gt;是指对象从新生代晋升到老年代需要对象年龄达到6岁，即经过6次GC。&lt;/p&gt;
&lt;p&gt;第四行是新生代Young区的GC，首先是GC发生的时间。然后是GC发生的原因&lt;code&gt;GC (Allocation Failure)&lt;/code&gt;，对象分配失败。&lt;code&gt;[ParNew: 11520K-&amp;gt;1407K(12928K), 0.0034803 secs]&lt;/code&gt;表示新生代回收前是11520K，回收后是1407K，新生代总大小12928K，回收耗时0.0034803 secs。&lt;code&gt;11520K-&amp;gt;2254K(27264K), 0.0039082 secs&lt;/code&gt;表示回收前堆大小11520K，回收后堆大小2254K，堆的总大小27264K。&lt;/p&gt;
&lt;p&gt;第五行是老年代Old区的GC，首先是GC发生的时间。然后是GC发生的原因&lt;code&gt;System.gc()&lt;/code&gt;，由于代码调用。&lt;code&gt;[CMS: 846K-&amp;gt;1930K(14336K), 0.0103698 secs]&lt;/code&gt;表示回收前老年代是846K，回收后1930K，老年代总大小14336K，回收耗时0.0103698 secs。&lt;code&gt;7165K-&amp;gt;1930K(27264K)&lt;/code&gt;表示回收前堆大小7165K，回收后堆大小1930K，堆的总大小27264K。&lt;/p&gt;
&lt;p&gt;后面有一次并发标记周期，设置参数&lt;code&gt;-XX:InitiatingHeapOccupancyPercent&lt;/code&gt;的值，可以指定堆占有率达到百分之多少时，触发并发标记，默认值是45%。&lt;/p&gt;
&lt;p&gt;最后打印出了堆的整体使用情况，分为新生代、老年代、元空间。&lt;/p&gt;
&lt;h2 id=&quot;xxuseg1gc日志解析&quot;&gt;-XX:+UseG1GC日志解析&lt;/h2&gt;
&lt;p&gt;G1是JDK1.9中的默认收集器，指定G1收集器并发、并行执行内存回收（-XX:+UseG1GC），它的格式差异较大，日志如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Java HotSpot(TM) 64-Bit Server VM (25.131-b11) for windows-amd64 JRE (1.8.0_131-b11), built on Mar 15 2017 01:23:53 by &quot;java_re&quot; with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 8303556k(2436164k free), swap 16215992k(7422076k free)
CommandLine flags: -XX:InitialHeapSize=29360128 -XX:MaxHeapSize=29360128 -XX:MaxNewSize=14680064 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseLargePagesIndividualAllocation 
# 新生代GC，young区，暂停0.0022375秒
2018-05-09T20:59:47.639+0800: 0.484: [GC pause (G1 Evacuation Pause) (young), 0.0022375 secs]
   # 并行时间1.7ms，4个GC线程
   [Parallel Time: 1.7 ms, GC Workers: 4]
      # 开始时刻，相对开始时间点，4个线程的最小值、平均值、最大值
      [GC Worker Start (ms): Min: 484.4, Avg: 484.4, Max: 484.5, Diff: 0.0]
      # 根节点扫描耗时
      [Ext Root Scanning (ms): Min: 0.4, Avg: 0.7, Max: 1.6, Diff: 1.2, Sum: 2.7]
      # 更新记忆集（RS, Remembered Set）耗时G1中每块区域都有一个RS与之对应，RS记录了该区域被其他区域引用的对象。回收时，就把RS作为根集的一部分，从而加快回收。
      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
         # Processed Buffers就是记录引用变化的缓存空间
         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]
      # 扫描RS耗时
      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      # 根扫描耗时
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.1]
      # 对象拷贝（疏散回收的区域）
      [Object Copy (ms): Min: 0.0, Avg: 0.8, Max: 1.1, Diff: 1.1, Sum: 3.3]
      # 线程在终止阶段的耗时，线程在终止前，会检查其他线程的队列，看是否有未清理完的Reference。如有则帮助其他线程清理，之后再尝试终止
      [Termination (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.3]
         # 尝试终止次数
         [Termination Attempts: Min: 1, Avg: 1.8, Max: 2, Diff: 1, Sum: 7]
      # GC线程花在其他任务中的耗时
      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]
      # GC线程耗时
      [GC Worker Total (ms): Min: 1.6, Avg: 1.6, Max: 1.6, Diff: 0.0, Sum: 6.5]
      # 完成时刻
      [GC Worker End (ms): Min: 486.1, Avg: 486.1, Max: 486.1, Diff: 0.0]
   [Code Root Fixup: 0.0 ms]
   [Code Root Purge: 0.0 ms]
   # 清空CardTable耗时，RS是依赖CardTable记录区域存活对象的
   [Clear CT: 0.0 ms]
   # 其他任务耗时
   [Other: 0.5 ms]
      # 选取将要被回收的区域的集合耗时
      [Choose CSet: 0.0 ms]
      # 弱引用、软引用的处理耗时
      [Ref Proc: 0.4 ms]
      # 弱引用、软引用的入队耗时
      [Ref Enq: 0.0 ms]
      [Redirty Cards: 0.0 ms]
      [Humongous Register: 0.0 ms]
      [Humongous Reclaim: 0.0 ms]
      # 释放被回收区域的耗时（包含他们的RS）
      [Free CSet: 0.0 ms]
   # Eden区、Survivor区、堆的回收前大小、回收后大小、以及总大小
   [Eden: 5120.0K(5120.0K)-&amp;gt;0.0B(11.0M) Survivors: 0.0B-&amp;gt;1024.0K Heap: 5120.0K(28.0M)-&amp;gt;1631.5K(28.0M)]
 [Times: user=0.00 sys=0.00, real=0.00 secs]
# 并发标记周期开始，根区域扫描
2018-05-09T20:59:47.982+0800: 9.634: [GC concurrent-root-region-scan-start]
2018-05-09T20:59:47.982+0800: 9.652: [GC concurrent-root-region-scan-end, 0.0184308 secs]
# 并发标记
2018-05-09T20:59:47.982+0800: 9.652: [GC concurrent-mark-start]
2018-05-09T20:59:47.982+0800: 9.693: [GC concurrent-mark-end, 0.0406187 secs]
# 重新标记
2018-05-09T20:59:47.982+0800: 9.695: [GC remark 9.695: [Finalize Marking, 0.0005100 secs] 9.695: [GC ref-proc, 0.0003461 secs] 9.696: [Unloading, 0.0069466 secs], 0.0082011 secs]
 [Times: user=0.02 sys=0.00, real=0.01 secs] 
# 独占清理
2018-05-09T20:59:47.982+0800: 9.703: [GC cleanup 25M-&amp;gt;21M(1024M), 0.0027119 secs]
 [Times: user=0.00 sys=0.01, real=0.00 secs] 
# 并发清理
2018-05-09T20:59:47.982+0800: 9.706: [GC concurrent-cleanup-start]
2018-05-09T20:59:47.982+0800: 9.706: [GC concurrent-cleanup-end, 0.0000167 secs]
# 下一轮回收，FullGC，堆的回收前、回收后、以及总大小。Eden、Survivor、元空间的大小。
2018-05-09T20:59:47.982+0800: 0.828: [Full GC (System.gc())  12M-&amp;gt;2223K(28M), 0.0128065 secs]
   [Eden: 11.0M(11.0M)-&amp;gt;0.0B(12.0M) Survivors: 1024.0K-&amp;gt;0.0B Heap: 12.2M(28.0M)-&amp;gt;2223.0K(28.0M)], [Metaspace: 5951K-&amp;gt;5951K(1056768K)]
 [Times: user=0.02 sys=0.00, real=0.01 secs] 
# 新生代GC
2018-05-09T20:59:48.040+0800: 0.886: [GC pause (G1 Evacuation Pause) (young), 0.0005693 secs]
   [Parallel Time: 0.4 ms, GC Workers: 4]
      [GC Worker Start (ms): Min: 886.1, Avg: 886.1, Max: 886.1, Diff: 0.0]
      [Ext Root Scanning (ms): Min: 0.2, Avg: 0.2, Max: 0.2, Diff: 0.0, Sum: 0.8]
      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.2]
         [Processed Buffers: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]
      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Object Copy (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]
      [Termination (ms): Min: 0.0, Avg: 0.1, Max: 0.1, Diff: 0.1, Sum: 0.3]
         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]
      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [GC Worker Total (ms): Min: 0.3, Avg: 0.3, Max: 0.4, Diff: 0.0, Sum: 1.4]
      [GC Worker End (ms): Min: 886.5, Avg: 886.5, Max: 886.5, Diff: 0.0]
   [Code Root Fixup: 0.0 ms]
   [Code Root Purge: 0.0 ms]
   [Clear CT: 0.0 ms]
   [Other: 0.1 ms]
      [Choose CSet: 0.0 ms]
      [Ref Proc: 0.0 ms]
      [Ref Enq: 0.0 ms]
      [Redirty Cards: 0.0 ms]
      [Humongous Register: 0.0 ms]
      [Humongous Reclaim: 0.0 ms]
      [Free CSet: 0.0 ms]
   [Eden: 12.0M(12.0M)-&amp;gt;0.0B(12.0M) Survivors: 0.0B-&amp;gt;2048.0K Heap: 14.2M(28.0M)-&amp;gt;3460.3K(28.0M)]
 [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-09T20:59:48.103+0800: 0.949: [GC pause (G1 Evacuation Pause) (young), 0.0004664 secs]
   [Parallel Time: 0.3 ms, GC Workers: 4]
      [GC Worker Start (ms): Min: 949.2, Avg: 949.3, Max: 949.5, Diff: 0.3]
      [Ext Root Scanning (ms): Min: 0.0, Avg: 0.2, Max: 0.2, Diff: 0.2, Sum: 0.6]
      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
         [Processed Buffers: Min: 0, Avg: 1.0, Max: 2, Diff: 2, Sum: 4]
      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Object Copy (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.1]
         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]
      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [GC Worker Total (ms): Min: 0.0, Avg: 0.2, Max: 0.3, Diff: 0.3, Sum: 0.8]
      [GC Worker End (ms): Min: 949.5, Avg: 949.5, Max: 949.5, Diff: 0.0]
   [Code Root Fixup: 0.0 ms]
   [Code Root Purge: 0.0 ms]
   [Clear CT: 0.0 ms]
   [Other: 0.1 ms]
      [Choose CSet: 0.0 ms]
      [Ref Proc: 0.1 ms]
      [Ref Enq: 0.0 ms]
      [Redirty Cards: 0.0 ms]
      [Humongous Register: 0.0 ms]
      [Humongous Reclaim: 0.0 ms]
      [Free CSet: 0.0 ms]
   [Eden: 12.0M(12.0M)-&amp;gt;0.0B(13.0M) Survivors: 2048.0K-&amp;gt;1024.0K Heap: 15.4M(28.0M)-&amp;gt;2383.6K(28.0M)]
 [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-09T20:59:48.146+0800: 0.992: [GC pause (G1 Evacuation Pause) (young), 0.0004067 secs]
   [Parallel Time: 0.3 ms, GC Workers: 4]
      [GC Worker Start (ms): Min: 991.9, Avg: 991.9, Max: 991.9, Diff: 0.0]
      [Ext Root Scanning (ms): Min: 0.2, Avg: 0.2, Max: 0.2, Diff: 0.0, Sum: 0.8]
      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
         [Processed Buffers: Min: 1, Avg: 1.3, Max: 2, Diff: 1, Sum: 5]
      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Object Copy (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]
      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [GC Worker Total (ms): Min: 0.2, Avg: 0.2, Max: 0.2, Diff: 0.0, Sum: 0.9]
      [GC Worker End (ms): Min: 992.2, Avg: 992.2, Max: 992.2, Diff: 0.0]
   [Code Root Fixup: 0.0 ms]
   [Code Root Purge: 0.0 ms]
   [Clear CT: 0.0 ms]
   [Other: 0.1 ms]
      [Choose CSet: 0.0 ms]
      [Ref Proc: 0.0 ms]
      [Ref Enq: 0.0 ms]
      [Redirty Cards: 0.0 ms]
      [Humongous Register: 0.0 ms]
      [Humongous Reclaim: 0.0 ms]
      [Free CSet: 0.0 ms]
   [Eden: 13.0M(13.0M)-&amp;gt;0.0B(13.0M) Survivors: 1024.0K-&amp;gt;1024.0K Heap: 15.3M(28.0M)-&amp;gt;2277.1K(28.0M)]
 [Times: user=0.00 sys=0.00, real=0.00 secs] 
2018-05-09T21:01:18.300+0800: 91.146: [Full GC (System.gc())  9971K-&amp;gt;1815K(28M), 0.0099218 secs]
   [Eden: 8192.0K(13.0M)-&amp;gt;0.0B(14.0M) Survivors: 1024.0K-&amp;gt;0.0B Heap: 9971.7K(28.0M)-&amp;gt;1815.8K(28.0M)], [Metaspace: 6026K-&amp;gt;6026K(1056768K)]
 [Times: user=0.00 sys=0.00, real=0.01 secs] 
Heap
 garbage-first heap   total 28672K, used 1815K [0x00000000fe400000, 0x00000000fe5000e0, 0x0000000100000000)
  region size 1024K, 1 young (1024K), 0 survivors (0K)
 Metaspace       used 6038K, capacity 6252K, committed 6400K, reserved 1056768K
  class space    used 691K, capacity 761K, committed 768K, reserved 1048576K
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;G1日志分析详见上面代码中的注释，G1的垃圾收集比之前的收集器稍微复杂一些。&lt;/p&gt;
</description>
<pubDate>Sat, 04 Jan 2020 23:55:00 +0000</pubDate>
<dc:creator>Cellei</dc:creator>
<og:description>本系列笔记主要基于《深入理解Java虚拟机：JVM高级特性与最佳实践 第2版》，是这本书的读书笔记。 收集GC日志 不同的垃圾收集器，输出的日志格式各不相同，但也有一些相同的特征。熟悉各个常用垃圾收集</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cellei/p/12151478.html</dc:identifier>
</item>
<item>
<title>Python 线性回归（Linear Regression) - 到底什么是 regression？ - 不忘初心mao</title>
<link>http://www.cnblogs.com/learnbydoing/p/12151475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/learnbydoing/p/12151475.html</guid>
<description>&lt;p&gt;学习 &lt;a href=&quot;https://realpython.com/linear-regression-in-python/&quot;&gt;Linear Regression in Python – Real Python&lt;/a&gt;，对 regression 一词比较疑惑.&lt;/p&gt;
&lt;p&gt;这个 linear Regression 中的 Regression 是什么意思，字面上 Regression 是衰退的意思，线性衰退？相信理解了这个词，对线性回归可能印象深刻些。&lt;/p&gt;

&lt;p&gt;搜了一番，原来是为了纪念生物统计学家高尔顿的发现，他是达尔文的表兄，一直想从进化论来研究为何人各有不同。&lt;/p&gt;
&lt;p&gt;他的一个重大发现是，父母的身高与子女的身高之间有某种关系。&lt;/p&gt;
&lt;p&gt;平时生活中我们也经常纳闷，为啥有的父母个子都很高，子女却比较矮，相反，有的父母都很矮，孩子却很高。高尔顿的解释是，子代的平均身高向中心回归了。正是这种子代身高向同龄人平均身高回归的趋势，使得人类身高没有两极分化。&lt;/p&gt;
&lt;p&gt;所以他用“回归”这个词来描述父辈身高 y 和子代身高 x 之间的关系。&lt;/p&gt;
&lt;p&gt;还有一个有趣的解释，是从词源来解，regression 中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&quot;re&quot; ：向后，往回，相反，相对&lt;/li&gt;
&lt;li&gt;gress = walk， 走&lt;/li&gt;
&lt;li&gt;ion ：表名词：行动，状态等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/30123729/answer/205476&quot;&gt;回归分析中的“回归”是什么意思？ - 我是观察员的回答 - 知乎&lt;/a&gt; 这个答案用炒菜来比喻，很有意思：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;炒菜的体验。假设你炒西红柿鸡蛋，要放盐等调料才觉得好吃，你放了一小撮，不够，再加点，结果多了；那就加点水，味道淡了。你感觉有点太淡了，那就再加点盐，直到你炒好了菜，你加盐的过程才结束。 对你来说是美味吧？这就是回归的感觉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思就是，不断的调整影响菜的口味的各种调料（盐，水，等）,直至找到一个均衡的比例。这个调整的过程中有不断的“回退”。&lt;/p&gt;
&lt;p&gt;至此终于理解 regression 的含义了。不过，统计学上的 y 与 x 之间的关系并不总是“回归”的含义。&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;研究变量之间的关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;变量是指什么？关系是指什么样的关系？&lt;/p&gt;
&lt;p&gt;先拿一个具体的线性回归的例子来说：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;你想知道，为啥同是 dev，某同事 A 比你年轻，工资却比你高？&lt;br/&gt;换句话说，影响你们工资的因素有哪些？&lt;br/&gt;你想了想，A 虽然年轻，但比你来公司早一点，学历比你高，会说话（可能刚来的时候谈的工资就高？），等等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对应上面的问题，这个例子中，&lt;/p&gt;
&lt;p&gt;用统计学来表达，就是要找寻一个函-=数 y = f(x), where x: x1....xn.&lt;/p&gt;
&lt;p&gt;这里，y (工资) 是因变量，x1...xn(影响 y 的因素) 是自变量。&lt;/p&gt;
&lt;p&gt;再举一个例子：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;某领导要求下属去考察某市的房地产状况&lt;br/&gt;房价(y)是他要做的考察之一&lt;br/&gt;他要研究哪些因素(x1...xn)影响着该市的房价走向&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有很多其他例子。&lt;/p&gt;
&lt;p&gt;重点在于：线性回归研究这两点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x1...xn 是否有影响 y&lt;/li&gt;
&lt;li&gt;如影响，则在多大程度上影响 y&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote readability=&quot;4.1509433962264&quot;&gt;
&lt;p&gt;本文由博客一文多发平台 &lt;a href=&quot;https://openwrite.cn?from=article_bottom&quot;&gt;OpenWrite&lt;/a&gt; 发布！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 04 Jan 2020 23:46:00 +0000</pubDate>
<dc:creator>不忘初心mao</dc:creator>
<og:description>背景 学习 &amp;quot;Linear Regression in Python – Real Python&amp;quot; ，对 regression 一词比较疑惑. 这个 linear Regressi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/learnbydoing/p/12151475.html</dc:identifier>
</item>
<item>
<title>The Annual Summary Of 2019 - 牧云云</title>
<link>http://www.cnblogs.com/MuYunyun/p/12151042.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MuYunyun/p/12151042.html</guid>
<description>&lt;p&gt;Time is flying, it arrives at the end of year again. This is my first year working in PinDuoDuo inc and it seems I arrive in the company yesterday. This point is a good chance to talk with(recognize) myself again. I try to conclude from &lt;code&gt;work&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;life&lt;/code&gt; and &lt;code&gt;destination&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;learn-from-work&quot;&gt;Learn from work&lt;/h3&gt;
&lt;p&gt;The first course I learn from my team is about &lt;code&gt;starting with the end&lt;/code&gt;. It means everything we do today is prepared for the tomorrow. In the other word, we should realize witch period the thing we're doing is in, and our team write summary every week to make sure the established goals become closer and closer.&lt;/p&gt;
&lt;p&gt;The second course I learn from the work is to try to &lt;code&gt;use English more&lt;/code&gt;. There are so much rich resource in Medium, MDN, Frontend Masters and even in twitter. It's the first time I met with so many foreigners engineer in the JSConf but I can't talk with them fluently. It's obviously using English skillfully will open your eyes and improve efficiency looking for some information.&lt;/p&gt;
&lt;p&gt;The last but most important is &lt;code&gt;how to communicate&lt;/code&gt;. It's artistic to describe something easily to make others understand. When arriving at our team at first, one of my leader's advice is the best way to join in the team is to share —— sharing ideas, knowledge and feeling. My colleagues are so excellent I learn a lot from them in these technical sharing parties every week. At the meanwhile I also share some ideas in it.&lt;/p&gt;
&lt;h3 id=&quot;output-of-the-article&quot;&gt;Output of the article&lt;/h3&gt;
&lt;p&gt;There are ten new articles added to &lt;a href=&quot;https://github.com/MuYunyun/blog&quot;&gt;my blog&lt;/a&gt;, the direction is to talk about React, JavaScript, CSS and so on. If there are mistakes in it, welcome &lt;a href=&quot;https://github.com/MuYunyun/blog/issues/new&quot;&gt;point out&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;There will be more creative articles to add in the future. Let's grow up together.&lt;/p&gt;
&lt;h3 id=&quot;life&quot;&gt;Life&lt;/h3&gt;
&lt;p&gt;I enjoy the quiet time sitting in the Cafe the whole day in Saturday and it's also nice to chat with friends or family there.&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://with.muyunyun.cn/65758e96048af8ff1fd619ba1abc834a.jpg-400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;And in other some weekend days, I take part in some FE conferences this year —— &lt;code&gt;FDConf&lt;/code&gt;, &lt;code&gt;VUE Conf&lt;/code&gt;, &lt;code&gt;D2&lt;/code&gt;, &lt;code&gt;SEE Conf&lt;/code&gt; and so on. From these activities I learn some some new knowledge. For example, the article &lt;a href=&quot;http://muyunyun.cn/posts/a1be1d41/&quot;&gt;How to make page run smoothly&lt;/a&gt; is written after listening the sharing of Liu Bowen in FDConf. And luckily, I get the chance to take photo with &lt;a href=&quot;https://twitter.com/youyuxi&quot;&gt;Evan You&lt;/a&gt; and get the&lt;br/&gt;signature from him.&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://with.muyunyun.cn/27a9372dcab28c9c15e1b273096b2680.jpg-300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;At the same time, it's happy to meet with old friends and make with new friends in these activities.&lt;/p&gt;
&lt;h3 id=&quot;checklist-destination&quot;&gt;Checklist &amp;amp;&amp;amp; Destination&lt;/h3&gt;
&lt;p&gt;Checking the plan of last year before making plans in new year.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Reading &lt;code&gt;five&lt;/code&gt; technical books and a not technical book, &lt;del&gt;learn Functional Programming&lt;/del&gt;: It is a shame not achieve this target. Instead of reading the whole books, I read more single posts or chapters partly in the last year.&lt;/li&gt;
&lt;li&gt;Finishing &lt;del&gt;a valuable project&lt;/del&gt;: There are some valuable projects in my daily work, they're still in progress.&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Deep into &lt;code&gt;React&lt;/code&gt; community&lt;/del&gt;, submit a pr: There is some deep analyze in React this year, however it still needs making extra effort for making a pr;&lt;/li&gt;
&lt;li&gt;Deep &lt;del&gt;into the document of &lt;code&gt;Node.Js&lt;/code&gt;&lt;/del&gt;: the work of this year is connected with UI and component more closely, so the document of Node.Js has no much chance reading in practice;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Improving the skill of communication, do a sharing in a party&lt;/del&gt;: The communication skill gets some improved, however it still needs be strengthened;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Invite friends fro coffee(at least 12)&lt;/del&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Keeping going on in the new year. Here lists some direction.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Keeping reading and writing. Creating more personal thoughts;&lt;/li&gt;
&lt;li&gt;Improving listening/writing skill in English continually;
&lt;ul&gt;&lt;li&gt;Way: watching ten+ english movies and try to write some english posts.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Improving the basic skills in data structure and composition principle continually;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 04 Jan 2020 16:39:00 +0000</pubDate>
<dc:creator>牧云云</dc:creator>
<og:description>Time is flying, it arrives at the end of year again. This is my first year working in PinDuoDuo inc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MuYunyun/p/12151042.html</dc:identifier>
</item>
<item>
<title>【趣味设计模式系列】之【状态模式】 - 小猪爸爸</title>
<link>http://www.cnblogs.com/father-of-little-pig/p/12130821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/father-of-little-pig/p/12130821.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;1. 简介&lt;/h2&gt;
&lt;p&gt;状态模式（State Pattern），当一个对象内在&lt;code&gt;状态改变&lt;/code&gt;时允许其&lt;code&gt;改变行为&lt;/code&gt;，这个对象看起来像改变了其类。简而言之，就是&lt;code&gt;状态的变更引起了行为的变更&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;图解&quot;&gt;2. 图解&lt;/h2&gt;
&lt;p&gt;下图四辆汽车，分别代表汽车日常的四种状态。&lt;br/&gt;开门状态：&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765702/202001/1765702-20200101225554954-34902455.png&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;关门状态：&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765702/202001/1765702-20200101225620768-276037730.png&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;飞奔状态：&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765702/202001/1765702-20200101225638147-2086142266.jpg&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;停止状态：&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765702/202001/1765702-20200101225704335-1033391974.png&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;其中，某种特定状态下，都有四个可执行操作，分别是open，close，run，stop，然后做对应的处理得下图所示。&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765702/202001/1765702-20200104223940515-1011256235.jpg&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;h2 id=&quot;案例实现&quot;&gt;3. 案例实现&lt;/h2&gt;
&lt;p&gt;类图如下：&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765702/202001/1765702-20200104230906651-2117316863.jpg&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;ul&gt;&lt;li&gt;定义汽车抽象状态类&lt;code&gt;CarState&lt;/code&gt;，持有类型为&lt;code&gt;Context&lt;/code&gt;的属性，同时持有四个可执行操作，&lt;code&gt;open&lt;/code&gt;，&lt;code&gt;close&lt;/code&gt;，&lt;code&gt;run&lt;/code&gt;，&lt;code&gt;stop&lt;/code&gt;方法；&lt;/li&gt;
&lt;li&gt;定义汽车抽象状态类的子类&lt;code&gt;OpenningState&lt;/code&gt;，&lt;code&gt;ClosingState&lt;/code&gt;，&lt;code&gt;RunningState&lt;/code&gt;，&lt;code&gt;StoppingState&lt;/code&gt;，分别代表开门状态，关门状态，飞奔状态，停止状态；&lt;/li&gt;
&lt;li&gt;定义环境角色类&lt;code&gt;Context&lt;/code&gt;，把状态对象声明为静态常量，有几个状态对象就声明几个静态常量，环境角色具有状态抽象角色定义的所有行为，具体执行使用委托方式。具体环境角色有两个职责：处理本状态必须完成的任务，决定是否可以过渡到其他状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.state.example1;

/**
 * @Author: wzj
 * @Date: 2019/11/3 20:10
 * @Desc: 汽车状态抽象类
 */
public abstract class CarState {
    //环境角色，封装状态变化引起的行为变化
    protected Context context;

    public void setContext(Context context) {
        this.context = context;
    }

    //汽车开门动作
    public abstract void open();

    //汽车关门动作
    public abstract void close();

    //汽车飞奔动作
    public abstract void run();

    //汽车停止动作
    public abstract void stop();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.state.example1;

/**
 * @Author: wzj
 * @Date: 2019/11/3 20:23
 * @Desc: 汽车开门状态类
 */
public class OpenningState extends CarState {

    //打开汽车门
    public void open() {
        System.out.println(&quot;汽车门已开&quot;);
    }

    //关闭汽车门
    public void close() {
        //状态修改
        super.context.setCarState(Context.closingState);
        //动作委托为ClosingState来执行
        super.context.getCarState().close();
    }

    //门开着时汽车一般不奔跑
    public void run() {
        System.out.println(&quot;汽车开门状态，不能奔跑&quot;);
    }

    //车门开着时，切换不到停止状态，因为没有四种状态中，没有开门且停止这个状态
    public void stop() {
        System.out.println(&quot;汽车开门状态，不能长时间开着门且处于停止状态&quot;);

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.state.example1;

/**
 * @Author: wzj
 * @Date: 2019/11/3 20:23
 * @Desc: 汽车飞奔状态类
 */
public class RunningState extends CarState {

    //打开奔跑时不开门
    public void open() {
        System.out.println(&quot;车在飞奔，不能打开&quot;);
    }

    //奔跑时肯定是关门的
    public void close() {
        System.out.println(&quot;车在飞奔，已经关闭，不能再次关闭&quot;);
    }

    //汽车在飞奔
    public void run() {
        System.out.println(&quot;汽车在飞奔&quot;);
    }

    //汽车可以停下来
    public void stop() {
        //修改汽车为停止状态
        super.context.setCarState(Context.stoppingState);
        //停止动作委托为StoppingState类来执行
        super.context.getCarState().stop();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.state.example1;

/**
 * @Author: wzj
 * @Date: 2019/11/3 20:23
 * @Desc: 汽车关门状态类
 */
public class ClosingState extends CarState {

    //打开汽车门
    public void open() {
        //修改汽车为开门状态
        super.context.setCarState(Context.openningState);
        //动作委托为OpenningState类来执行
        super.context.getCarState().open();
    }

    //关闭汽车门
    public void close() {
        System.out.println(&quot;汽车门已关&quot;);
    }

    //汽车在飞奔
    public void run() {
        //修改汽车为飞奔状态
        super.context.setCarState(Context.runningState);
        //动作委托为RunningState类来执行
        super.context.getCarState().run();

    }

    //汽车在停止
    public void stop() {
        //设置汽车状态为停止状态
        super.context.setCarState(Context.stoppingState);
        //动作委托为StoppingState类来执行
        super.context.getCarState().stop();

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.state.example1;

/**
 * @Author: wzj
 * @Date: 2019/11/3 20:19
 * @Desc: 上下文环境类
 */
public class Context {

    /**列出汽车所有状态
     * openningState-开门状态 closingState-关门状态
     * runningState-奔驰状态 stoppingState-停止状态
     */
    public static final OpenningState openningState = new OpenningState();
    public static final ClosingState closingState = new ClosingState();
    public static final RunningState runningState = new RunningState();
    public static final StoppingState stoppingState = new StoppingState();

    //定义汽车当前状态
    private CarState carState;

    public CarState getCarState() {
        return  carState;
    }

    public void setCarState(CarState carState) {
        this.carState = carState;
        //切换状态
        this.carState.setContext(this);
    }

    //汽车开门
    public void open() {
        this.carState.open();
    }

    //汽车关门
    public void close(){
        this.carState.close();
    }

    //汽车飞奔
    public void run(){
        this.carState.run();
    }

    //汽车停止
    public void stop(){
        this.carState.stop();
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端类如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.wzj.state.example1;

/**
 * @Author: wzj
 * @Date: 2019/11/3 21:06
 * @Desc:
 */
public class Client {
    public static void main(String[] args) {
        Context context = new Context();
        context.setCarState(new OpenningState());
//        context.setCarState(new ClosingState());
//        context.setCarState(new RunningState());
//        context.setCarState(new StoppingState());
        context.open();
//        context.close();
//        context.run();
//        context.stop();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果如下：&lt;br/&gt;当只打开&lt;code&gt;Client&lt;/code&gt;15行的时候，分别打开11,12,13,14行的代码，会得到如下结果：&lt;br/&gt;汽车为开门状态时，执行open&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765702/202001/1765702-20200104235942069-260377116.png&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;汽车为关门状态时，执行open&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765702/202001/1765702-20200104235953413-1075672315.png&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;汽车为飞奔状态时，执行open&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765702/202001/1765702-20200105000002430-1937078993.png&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;汽车为停止状态时，执行open&lt;br/&gt;&lt;/p&gt;
&lt;center&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1765702/202001/1765702-20200105000013588-1984373709.png&quot;/&gt;&lt;/p&gt;
&lt;/center&gt;
&lt;p&gt;上述结果可以看出，同样执行一个&lt;code&gt;open&lt;/code&gt;方法，当状态的变化时导致行为的变化。&lt;/p&gt;
&lt;h2 id=&quot;状态模式总结&quot;&gt;4. 状态模式总结&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;结构清晰&lt;br/&gt;避免了过多的switch...case或者if...else语句的使用，避免了程序的复杂性，提高系统的可维护性；&lt;/li&gt;
&lt;li&gt;遵循设计原则&lt;br/&gt;很好地体现了开闭原则和单一职责原则，每个状态都是一个子类，你要增加状态就要增加子类，你要修改状态，你只修改一个子类就可以了。&lt;/li&gt;
&lt;li&gt;封装性非常好&lt;br/&gt;这也是状态模式的基本要求，状态变换放置到类的内部来实现，外部的调用不用知道类内部如何实现状态和行为的变换。&lt;br/&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;br/&gt;状态模式既然有优点，那当然有缺点了。但只有一个缺点，子类会太多，也就是类膨胀。如果一个事物有很多个状态也不稀奇，如果完全使用状态模式就会有太多的子类，不好管理，这个需要大家在项目中自己衡量。其实有很多方式可以解决这个状态问题，如在数据库中建立一个状态表，然后根据状态执行相应的操作，这个也不复杂，看大家的习惯和嗜好了。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 04 Jan 2020 16:13:00 +0000</pubDate>
<dc:creator>小猪爸爸</dc:creator>
<og:description>1. 简介 状态模式（State Pattern），当一个对象内在 时允许其 ，这个对象看起来像改变了其类。简而言之，就是 。 2. 图解 下图四辆汽车，分别代表汽车日常的四种状态。 开门状态： 关门</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/father-of-little-pig/p/12130821.html</dc:identifier>
</item>
<item>
<title>C# async await 死锁问题总结 - Bob1227</title>
<link>http://www.cnblogs.com/sdBob/p/12151013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdBob/p/12151013.html</guid>
<description>&lt;p&gt;&lt;strong&gt;可能发生死锁的程序类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、WPF/WinForm程序&lt;/p&gt;
&lt;p&gt;2、asp.net (不包括asp.net mvc)程序&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;死锁的产生原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对异步方法返回的Task调用Wait()或访问Result属性时，可能会产生死锁。&lt;/p&gt;
&lt;p&gt;下面的WPF代码会出现死锁：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Button_Click_7(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            Method1().Wait();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Method1()
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);

            txtLog.AppendText(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;后续代码&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的asp.net mvc代码也会出现死锁：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; ActionResult Index()
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; s=&lt;span&gt;Method1().Result;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Method1()
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以WPF代码为例，事件处理器调用Method1，得到Task对象，然后调用Task的Wait方法，阻塞自己所在的线程，即主线程，直到Task对象“完成”。而返回的Task对象要想“完成”，必须在主线程上执行await之后的代码。而主线程早就处于阻塞状态，它在等待Task对象完成！于是死锁就产生了。&lt;/p&gt;
&lt;p&gt;asp.net mvc代码是同样的道理。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如何避免死锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;可以试验一下，下面的代码是不会有问题的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Button_Click_8(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            HttpClient httpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            httpClient.BaseAddress &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; html = httpClient.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Result;

            txtLog.AppendText(html);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的代码也不会有问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Button_Click_8(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; html =&lt;span&gt; GetHtml();

            txtLog.AppendText(html);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetHtml()
        {
            HttpClient httpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            httpClient.BaseAddress &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; httpClient.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Result;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面的却会产生死锁：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Button_Click_8(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; html =&lt;span&gt; GetHtml().Result;

            txtLog.AppendText(html);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetHtml()
        {
            HttpClient httpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            httpClient.BaseAddress &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; httpClient.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为什么在HttpClient的GetStringAsync()返回的Task上访问Resut不会产生死锁，而自己写的代码就出现了死锁？&lt;/p&gt;
&lt;p&gt;从&lt;a href=&quot;https://github.com/mono/mono/blob/a44db72a1cf9a9d7d70270cefded64deb0c4b827/mcs/class/System.Net.Http/System.Net.Http/HttpClient.cs&quot; target=&quot;_blank&quot;&gt;mono的HttpClient源代码&lt;/a&gt;上，可以找到一些端倪：&lt;/p&gt;
&lt;p&gt;所有await 表达式后面，都加了ConfigureAwait (&lt;span class=&quot;pl-c1&quot;&gt;false)&lt;/span&gt;，如&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;pl-k&quot;&gt;return &lt;span class=&quot;pl-k&quot;&gt;await &lt;span class=&quot;pl-smi&quot;&gt;resp.&lt;span class=&quot;pl-smi&quot;&gt;Content.&lt;span class=&quot;pl-en&quot;&gt;ReadAsStringAsync ().&lt;span class=&quot;pl-en&quot;&gt;ConfigureAwait (&lt;span class=&quot;pl-c1&quot;&gt;false);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而由&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.threading.tasks.task-1.configureawait?f1url=https%3A%2F%2Fmsdn.microsoft.com%2Fquery%2Fdev16.query%3FappId%3DDev16IDEF1%26l%3DEN-US%26k%3Dk(System.Threading.Tasks.Task%601.ConfigureAwait);k(TargetFrameworkMoniker-.NETFramework,Version%3Dv4.6.2);k(DevLang-csharp)%26rd%3Dtrue&amp;amp;view=netframework-4.8&quot; target=&quot;_blank&quot;&gt;Task的msdn文档&lt;/a&gt;可以知，ConfigureAwait (&lt;span class=&quot;pl-c1&quot;&gt;false)会指示await之后的代码不在原先的context （可理解为线程）上运行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-c1&quot;&gt;这样，问题就迎刃而解了：以最初的WPF代码为例，主线程阻塞，等待Task对象“完成”；Method1被调用100ms后，在另外的线程上执行了await的之后的代码，于是Task对象完成。主线程恢复执行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-c1&quot;&gt;把使用HttpClient造成死锁的代码改成如下形式：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Button_Click_8(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; html =&lt;span&gt; GetHtml().Result;

            txtLog.AppendText(html);
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; GetHtml()
        {
            HttpClient httpClient &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
            httpClient.BaseAddress &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://www.baidu.com/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; httpClient.GetStringAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).ConfigureAwait(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以发现，死锁不会出现了&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;后话&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在异步工具方法中，尽可能的加上ConfigureAwait(false)，可以防止方法的使用者在异步方法返回的Task上调用Wait()或访问Result属性而造成死锁&lt;/li&gt;
&lt;li&gt;在一些场景中，我们是需要让await之后的代码返回原先的context执行的。如，在await之后，需要访问UI控件。所以，ConfigureAwait(false)不能滥用&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Sat, 04 Jan 2020 16:12:00 +0000</pubDate>
<dc:creator>Bob1227</dc:creator>
<og:description>可能发生死锁的程序类型 1、WPF/WinForm程序 2、asp.net (不包括asp.net mvc)程序 死锁的产生原理 对异步方法返回的Task调用Wait()或访问Result属性时，可能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdBob/p/12151013.html</dc:identifier>
</item>
<item>
<title>js的class基础 - 买辣椒也用券</title>
<link>http://www.cnblogs.com/Juaoie/p/12151011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Juaoie/p/12151011.html</guid>
<description>&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    let log = console.log;
    class people {
        constructor(name, age) {
            this.name = name;
            this.age = age;
        }
    }
    let aa = new people('张三', '22');
    log(aa);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/202001/1370048-20200105000954318-2093194543.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类的数据类型是函数&lt;/li&gt;
&lt;li&gt;类本身就是指向构造函数的&lt;/li&gt;
&lt;li&gt;类的方法之前不需要逗号分隔&lt;/li&gt;
&lt;li&gt;类中所有的方法都是不可枚举的&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;每个类都会有一个constructor方法，该方法属于构造方法。&lt;/li&gt;
&lt;li&gt;在new这个对象的时候会执行该方法&lt;/li&gt;
&lt;li&gt;该构造方法默认返回实例对象（this）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    let log = console.log;
    let PeopleClass= class people {
        getName(){
            return people.name;
        }
    }
    let aa = new PeopleClass();
    log(aa.getName());&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;此处的class类名是people，而不是PeopleClass&lt;/li&gt;
&lt;li&gt;如果内部没有用到类名，也可以省略类名&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/202001/1370048-20200105001006920-1974790692.png&quot;/&gt;&lt;/p&gt;

&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    let log = console.log;
    class people {
        get name() {
            log(&quot;小明&quot;);
        }
        set name(res) {
            log(&quot;设置名字叫：&quot; + res);
        }
    }
    let aa = new people();
    aa.name = 123;
    aa.name;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/202001/1370048-20200105001019737-1010557472.png&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;静态属性就是不会被实例继承的属性，同理，还会有一种叫实例属性&lt;/li&gt;
&lt;li&gt;目前es6只有静态方法，没有静态属性&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    let log = console.log;
    class people {
        static sayName() {
            log(&quot;小明&quot;);
        }
        sayAge(){
            log(&quot;22&quot;)
        }
    }
    let aa = new people();
    log(aa);
    aa.sayAge()
    people.sayName();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/202001/1370048-20200105001032643-1735473643.png&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;该属性用来获取当前构造函数是通过什么方式调用的&lt;/li&gt;
&lt;li&gt;子类继承父类时，调用子类的构造函数时，在父类中的new.target属性会返回子类的类名&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;    let log = console.log;
    class people {
        constructor() {
            log(new.target)
            log(new.target === people)
        }
    }
    class Speople extends people {
        constructor() {
            super()
        }
    }
    let aa = new Speople();
    let bb = new people();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1370048/202001/1370048-20200105001047580-925421501.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;利用此特点，可以写出只能用new命令调用的class&lt;/li&gt;
&lt;li&gt;还可以写出不能独立使用，必须要被继承才能用的class，反之同理。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 04 Jan 2020 16:11:00 +0000</pubDate>
<dc:creator>买辣椒也用券</dc:creator>
<og:description>基本写法 ~~~javascript let log = console.log; class people { constructor(name, age) { this.name = name;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Juaoie/p/12151011.html</dc:identifier>
</item>
<item>
<title>利用selenium库自动执行滑动验证码模拟登陆 - tomjoy</title>
<link>http://www.cnblogs.com/guapitomjoy/p/12150997.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guapitomjoy/p/12150997.html</guid>
<description>&lt;p&gt;破解流程&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#1、输入账号、密码，然后点击登陆
#2、点击按钮，弹出没有缺口的图
#3、针对没有缺口的图片进行截图
#4、点击滑动按钮，弹出有缺口的图
#5、针对有缺口的图片进行截图
#6、对比两张图片，找出缺口，即滑动的位移
#7、按照人的行为行为习惯，把总位移切成一段段小的位移
#8、按照位移移动
#9、完成登录&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模拟登陆案例一：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from selenium import webdriver
from selenium.webdriver import ActionChains
from PIL import Image
import time
import random
option = webdriver.ChromeOptions()
# 添加启动参数 (add_argument)
option.add_argument('disable-infobars')  # 禁用浏览器正在被自动化程序控制的提示

driver = webdriver.Chrome(chrome_options=option)


def get_snap(driver):
    # selenium自带的截图网页全屏图片
    driver.save_screenshot('snap.png')
    # 拿到验证图片所在的标签，方便确认位置
    img = driver.find_element_by_class_name('geetest_canvas_img')
    # location 代表该图片在整个页面所在的位置（x, y）,x：距离左边多长，y:距离上面多长
    # print(img.location)
    # size 代表该图片的大小
    # print(img.size)

    left = img.location.get('x')
    upper = img.location.get('y')

    right = left + img.size.get('width')
    lower = upper + img.size.get('height')

    # 拿到图片四个边的位置，就可以进行裁剪图片了
    # print(left, upper, right, lower)
    img_obj = Image.open('snap.png')

    # 对屏幕进行裁剪，获取滑动验证码图片
    image = img_obj.crop((left, upper, right, lower))
    # image.show()

    return image

# 获取完整图片
def get_img1(driver):
    time.sleep(0.2)
    js_code = &quot;&quot;&quot;
        var x = document.getElementsByClassName('geetest_canvas_fullbg')[0].style.display=&quot;block&quot;;
        console.log(x)
    &quot;&quot;&quot;

    # 执行js代码
    driver.execute_script(js_code)
    time.sleep(1)
    # 截取图片
    img_obj = get_snap(driver)

    return img_obj

# 获取有缺口的图片
def get_img2(driver):
    time.sleep(0.2)
    js_code = &quot;&quot;&quot;
        var x = document.getElementsByClassName('geetest_canvas_fullbg')[0].style.display=&quot;none&quot;;
        console.log(x)
    &quot;&quot;&quot;

    # 执行js代码
    driver.execute_script(js_code)
    time.sleep(1)
    # 截取图片
    img_obj = get_snap(driver)

    return img_obj


def get_distance(img1, img2):
    # 初始值
    start = 60

    # 模块色差
    color_num = 60
    for x in range(start, img1.size[0]):
        for y in range(img1.size[1]):
            rgb1 = img1.load()[x, y]
            rgb2 = img2.load()[x, y]

            # abs 获取绝对值
            r = abs(rgb1[0] - rgb2[0])
            g = abs(rgb1[1] - rgb2[1])
            b = abs(rgb1[2] - rgb2[2])

            if not (r &amp;lt; color_num and g &amp;lt; color_num and b &amp;lt; color_num):
                return x - 7  # 误差值大概为7



def get_stacks(distance):
    distance += 20
    '''
        拿到移动轨迹，模仿人的滑动行为，先匀加速后匀减速
        变速运动基本公式：
        ① v=v0+at       匀加速\减速运行
        ② s=v0t+½at²    位移
        ③ v²-v0²=2as    
     '''
    # 初速度
    v0 = 0

    # 加减速度列表
    a_list = [50, 65, 80]

    # 时间
    t = 0.2

    # 初始位置
    s = 0

    # 向前滑动轨迹
    forward_stacks = []

    mid = distance * 3 / 5

    while s &amp;lt; distance:

        if s &amp;lt; mid:
            a = a_list[random.randint(0, 2)]

        else:
            a = -a_list[random.randint(0, 2)]

        v = v0

        stack = v * t + 0.5 * a * (t ** 2)

        # 每次拿到的位移
        stack = round(stack)

        s += stack

        v0 = v + a * t

        forward_stacks.append(stack)

    # 往后返回20距离，因为之前distance向前多走了20
    back_stacks = [-5, -5, -5, -5,]

    return {'forward_stacks': forward_stacks, 'back_stacks': back_stacks}


if __name__ == '__main__':
    try:
        driver.get('https://account.cnblogs.com/signin')
        # 隐式等待
        driver.implicitly_wait(5)

        # 步骤一：找到输入账户框
        user_input = driver.find_element_by_id('LoginName')

        # 步骤二：找到输入密码框
        pwd_input = driver.find_element_by_id('Password')

        user_input.send_keys('123456@qq.com')
        time.sleep(1)
        pwd_input.send_keys('123456')
        # 步骤三：找到确认登录按钮,并点击
        login_btn = driver.find_element_by_id('submitBtn')
        time.sleep(1)
        login_btn.click()
        time.sleep(3)

        # 步骤四： 拿到没有缺口的图片并截取
        img1 = get_img1(driver)

        # 步骤五： 拿到有缺口的图片并截取
        img2 = get_img2(driver)

        # 步骤六： 对比两张图片，获取滑动距离
        distance = get_distance(img1, img2)

        # 步骤七： 模拟人为滑动轨迹
        stacks = get_stacks(distance)

        # 步骤八： 根据滑动轨迹进行滑动
        forward_stacks = stacks['forward_stacks']
        back_stacks = stacks['back_stacks']

        # 步骤九：找到滑动按钮，并点击与hole住
        slider_btn = driver.find_element_by_class_name('geetest_slider_button')
        time.sleep(0.2)
        ActionChains(driver).click_and_hold(slider_btn).perform()
        time.sleep(0.2)

        # 步骤十：开始循环向前滑动
        for forward_stack in forward_stacks:
            ActionChains(driver).move_by_offset(xoffset=forward_stack, yoffset=0).perform()
            time.sleep(0.1)
        # 步骤十一：开始循环向后滑动20
        for back_stack in back_stacks:
            ActionChains(driver).move_by_offset(xoffset=back_stack, yoffset=0).perform()
            time.sleep(0.1)

        time.sleep(0.2)


        # 步骤十二：为了防止极验检测到，再将滑块前后小浮动5位置，再释放

        ActionChains(driver).move_by_offset(xoffset=5, yoffset=0).perform()
        time.sleep(0.2)
        ActionChains(driver).move_by_offset(xoffset=-5, yoffset=0).perform()

        # 可能会出现识别不了，说图片被怪物吃了，上面模拟人的行为都不要了，拿到距离后，直接执行下面代码，一步滑到缺口处即可
        # ActionChains(driver).move_by_offset(xoffset=distance, yoffset=0).perform()

        ActionChains(driver).release().perform()

        time.sleep(50)

    finally:
        driver.close()&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 04 Jan 2020 16:06:00 +0000</pubDate>
<dc:creator>tomjoy</dc:creator>
<og:description>破解流程 模拟登陆案例一：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guapitomjoy/p/12150997.html</dc:identifier>
</item>
<item>
<title>Electron-forge应用（打包填坑） - 弹琴不谈情</title>
<link>http://www.cnblogs.com/lrj1009IRET/p/Electron.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lrj1009IRET/p/Electron.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;Electron-forge&lt;/strong&gt;&lt;strong&gt;应用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;一、 &lt;/strong&gt; &lt;strong&gt;使用Electron-Forge做应用的缘由&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;最近遇到一个需求，Web应用登录时要校验用户的登录Mac地址，以确定该用户是在授权过的电脑设备上登录的。没错我傻了，没多想就直接开始做，后面卡到了，这管理端是获取不到的啊，浏览器也限制了获取客户端电脑信息（除了IE）。然后想了很多方法都不行，最后决定做个桌面应用，然后将电脑的信息通过接口给浏览器调用，之后看网上的大佬分析，这款是最适合的，方便快捷，上手快，只要有点前端基础都用得起来，本人是个后端，也用得挺舒服的。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;二、 &lt;/strong&gt; &lt;strong&gt;Electron-Forge&lt;/strong&gt;&lt;strong&gt;的应用&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;1、   &lt;/strong&gt; &lt;strong&gt;使用electron-forge的准备&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1333070/202001/1333070-20200104235707564-1455812411.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1）    装vscode，极力推荐vscode，轻量、上手快，vscode的社区氛围也很好，插件多。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2）    装git, &lt;strong&gt;electron-forge&lt;/strong&gt;打包时会检测系统，没有装git是打不了包的&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3）    接下来打开vscode，全局装上electron-forge。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;网上的文档都有，我就不多说了；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;官网：https://www.worldlink.com.cn/osdir/electron-forge.html&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;2、   &lt;/strong&gt; &lt;strong&gt;起步&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;npm install -g electron-forge

electron-forge init my-&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;-app

cd my-&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt;-app

npm start&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p align=&quot;left&quot;&gt;　　做完这上面几步，你能看到一个应用的窗体显示在桌面&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1333070/202001/1333070-20200104235744290-484611921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;em&gt;　　如果没有跑不起来，请直接打开package.json,复制命令直接运行&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1333070/202001/1333070-20200104235822490-1977186468.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　有没有一种超级简单的感觉&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;三、 &lt;/strong&gt; &lt;strong&gt;使用&lt;/strong&gt;&lt;strong&gt;Electron&lt;/strong&gt; &lt;strong&gt;-forge&lt;/strong&gt;&lt;strong&gt;遇到坑&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;接下来就是本人遇到的坑了：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1、    关于package.json文件的配置electronPackagerConfig，配置icon的时候，不能加后缀，因为electron-forge这个脚手架会帮你自动检测系统，自动帮你加上适合系统的icon&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1333070/202001/1333070-20200104235837317-1644277051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2、    引入的包，开发环境和正式环境都要，不然打包不成功&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1333070/202001/1333070-20200104235844793-2089855775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3、    最坑的来了，就是打包成安装包的时候，项目名称不能是中文，就是运行electron-forge make，成功后安装不了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1333070/202001/1333070-20200104235854913-754427441.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1333070/202001/1333070-20200104235901670-463297862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;四、 &lt;/strong&gt; &lt;strong&gt;一个Demo，已经放上码云了&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;a title=&quot;electron-forge demo&quot; href=&quot;https://gitee.com/aliyunjie/electron-forge-mac&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;https://gitee.com/aliyunjie/electron-forge-mac&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;五、 &lt;/strong&gt; &lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;1、    学习到了点新东西，不过用的还是很不熟悉，花了半天入门，然后后面都是跳坑里浪费时间，感觉网上资料还是有点少，很多东西都得自己去搞清楚。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;2、　详细的解释可以看我发在码云上的demo&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;3、    转发请注明出处，谢谢！&lt;/p&gt;
</description>
<pubDate>Sat, 04 Jan 2020 16:03:00 +0000</pubDate>
<dc:creator>弹琴不谈情</dc:creator>
<og:description>Electron-forge应用（打包避坑向）</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lrj1009IRET/p/Electron.html</dc:identifier>
</item>
<item>
<title>Jenkins构建Vue项目 - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/12131604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/12131604.html</guid>
<description>&lt;p&gt;一、Jenkins Job相关配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1271786/202001/1271786-20200102093824169-1515540762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1271786/202001/1271786-20200102094011078-289783091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、发布脚本&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@data-05 nps]# cat nps_web-page.sh 
#!/bin/sh

USER_IP=172.168.168.109
USER_NAME=root
DST_DIR=/fs01/nps-web/web-page-manage/BOOT-INF/classes/static
cd /fs01/.jenkins/workspace/web-page-manage/pageSrc/dist

ssh ${USER_NAME}@${USER_IP} rm -rf /fs01/nps-web/web-page-manage/BOOT-INF/classes/static/*

/usr/bin/scp -r ./* ${USER_NAME}@${USER_IP}:${DST_DIR}
ssh ${USER_NAME}@${USER_IP} mv ${DST_DIR}/index.html /fs01/nps-web/web-page-manage/BOOT-INF/classes/templates
ssh ${USER_NAME}@${USER_IP} &quot;source /etc/profile &amp;amp;&amp;amp; /fs01/nps-web/web-page-manage/stop.sh&quot;
ssh ${USER_NAME}@${USER_IP} &quot;source /etc/profile &amp;amp;&amp;amp; cd /fs01/nps-web/web-page-manage &amp;amp;&amp;amp; ./start.sh 2&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 三、Jenkins服务器安装node.js环境&lt;/p&gt;
&lt;p&gt;方法一：从EPEL库安装Node.js&lt;br/&gt;安装Node.js的一个有效且简单的方法就是从官方库下载安装，首先确保您可以访问到EPEL库，您可以通过运行以下命令来安装。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
sudo yum install epel-release
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在可以使用yum命令安装Node.js了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
sudo yum install nodejs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为在开发过程中我需要管理节点包，我还要安装新公共管理的软件包管理器，使用以下命令。&lt;br/&gt;（注意：由于新版的nodejs已经集成了npm，所以这一步可以忽略。）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
sudo yum install npm
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
# node --version
v6.12.2
# npm --version
3.10.10
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到，用这种方法安装的话，版本比较旧。&lt;/p&gt;
&lt;p&gt;方法二：下载源代码，编译安装&lt;br/&gt;去官网找到最新的或者是您想要的node.js版本，复制url，在CentOS中用wget下载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
wget https://nodejs.org/dist/v8.9.4/node-v8.9.4.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解压：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
tar zxvf node-v8.9.4.tar.gz
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;进入目录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
cd node-v8.9.4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
./configure
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;编译：&lt;/p&gt;

&lt;p&gt;安装：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
sudo make install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;检查：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
# node --version
v8.9.4
# npm --version
5.6.0
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 04 Jan 2020 15:54:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<og:description>一、Jenkins Job相关配置 二、发布脚本 [root@data-05 nps]# cat nps_web-page.sh #!/bin/sh USER_IP=172.168.168.109 U</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dev0ps/p/12131604.html</dc:identifier>
</item>
</channel>
</rss>