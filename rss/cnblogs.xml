<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据可视化系列--svg入门基础（一） - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/10887650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/10887650.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、SVG(Scalable Vector Graphics)可伸缩矢量图形&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;p&gt;（1）使用xml格式来定义图形；&lt;/p&gt;
&lt;p&gt;（2）用来定义web上的使用的矢量图；&lt;/p&gt;
&lt;p&gt;（3）改变图像尺寸，图片质量不受损；&lt;/p&gt;
&lt;p&gt;（4）所有元素属性可以使用动画；&lt;/p&gt;
&lt;p&gt;（5）继承了W3C标准，在html中使用方式，html直接嵌入svg内容，或者直接引入svg文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;em&gt;/* svg标签，这里的rect为矩形，在后面的图形元素中会详细说明  */&lt;/em&gt;
&amp;lt;svg width=&quot;200&quot; height=&quot;200&quot;&amp;gt;
  &amp;lt;rect width=&quot;20&quot; height=&quot;20&quot; fill=&quot;red&quot;&amp;gt;&amp;lt;/rect&amp;gt;
&amp;lt;/svg&amp;gt;

/* 引入后缀名为.svg的文件 */
&amp;lt;img src=&quot;demo.svg&quot; alt=&quot;测试svg图片&quot;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：svg为inline水平元素。且需要绘制的所有图形都应被包含在&lt;code&gt;&amp;lt;svg&amp;gt;&amp;lt;/svg&amp;gt;&lt;/code&gt;标签内。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、SVG坐标系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特点:（1）y轴向下；（2）顺时针方向的角度是正值。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;13&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/249R9U5xCcwmn5kOmraBiZ9lYW.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/249R9U5xCcwmn5kOmraBiZ9lYW.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/249R9U5xCcwmn5kOmraBiZ9lYW.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;注意：元素的所有操作都是相对自身坐标系进行的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、颜色RGB和HSL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RGB: 三个分量：红色、绿色、蓝色，每个分量的取值范围[0, 255]，优点是显示器更容易解析。&lt;/p&gt;
&lt;p&gt;HSL: 三个分量：颜色h、饱和度s%、亮度l%，每个分量的取值范围分别是[0, 359], [0, 100%], [0, 100%],，其中，h=0表示红色， h=0表示120绿色，h=0表示240 蓝色。&lt;/p&gt;
&lt;p&gt;基于HSL的配色方案：&lt;a href=&quot;http://paletton.com/&quot; data-cke-saved-href=&quot;http://paletton.com/&quot;&gt;http://paletton.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;二、特殊元素&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、foreignObject&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;foreignObject元素通常被用来在svg代码中嵌入html节点。注意：该属性对IE不支持。&lt;code&gt;&amp;lt;foreignObject&amp;gt;&lt;/code&gt;元素的作用是可以在其中使用具有其它XML命名空间的XML元素，换句话说借助&lt;code&gt;&amp;lt;foreignObject&amp;gt;&lt;/code&gt;标签，我们可以&lt;strong&gt;直接在SVG内部嵌入XHTML元素。&lt;/strong&gt;通常会与&lt;strong&gt;标签&lt;/strong&gt;一起使用，在用户浏览器不支持时，告知用户。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&amp;gt;
  &amp;lt;foreignObject width=&quot;120&quot; height=&quot;50&quot;&amp;gt;
      &amp;lt;body xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
        &amp;lt;p&amp;gt;文字测试foreignObject的功能&amp;lt;/p&amp;gt;
      &amp;lt;/body&amp;gt;
    &amp;lt;/foreignObject&amp;gt;
&amp;lt;/svg&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到&lt;code&gt;&amp;lt;foreignObject&amp;gt;&lt;/code&gt;标签里面有一个设置了&lt;code&gt;xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&lt;/code&gt;命名空间的&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;标签，此时&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;标签及其子标签都会按照XHTML标准渲染，实现了SVG和XHTML的混合使用。&lt;/p&gt;
&lt;p&gt;这种混合特性有什么作用呢？作用很多，其中之一就是轻松实现&lt;strong&gt;SVG内的文本自动换行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.1文本自动换行&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SVG要实现文本换行，往往需要手动阻断&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&amp;gt;
  &amp;lt;text font-size=&quot;12&quot;&amp;gt;
    &amp;lt;tspan x=&quot;0&quot; y=&quot;10&quot;&amp;gt;一段需要word wrap&amp;lt;/tspan&amp;gt;
    &amp;lt;tspan x=&quot;0&quot; y=&quot;26&quot;&amp;gt;的文字。&amp;lt;/tspan&amp;gt;
  &amp;lt;/text&amp;gt;
&amp;lt;/svg&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要&lt;code&gt;2&lt;/code&gt;个&lt;code&gt;&amp;lt;tspan&amp;gt;&lt;/code&gt;元素，这一点都不工程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是如果使用&lt;code&gt;&amp;lt;foreignObject&amp;gt;&lt;/code&gt;元素，则自动换行就是小菜：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&amp;gt;
  &amp;lt;foreignObject width=&quot;120&quot; height=&quot;50&quot;&amp;gt;
      &amp;lt;body xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
        &amp;lt;p style=&quot;font-size:12px;margin:0;&quot;&amp;gt;一段需要word wrap的文字。&amp;lt;/p&amp;gt;
      &amp;lt;/body&amp;gt;
    &amp;lt;/foreignObject&amp;gt;
&amp;lt;/svg&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;12&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/24hBZ18ZoIi6obgrpTgsXk6m_Q.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/24hBZ18ZoIi6obgrpTgsXk6m_Q.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/24hBZ18ZoIi6obgrpTgsXk6m_Q.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2将页面上的DOM元素轻松变成图片&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SVG &lt;code&gt;&amp;lt;foreignObject&amp;gt;&lt;/code&gt;元素还有其他更高级的应用，就是可以将页面上的DOM元素轻松变成图片。&lt;/p&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;p&gt;1、获取对应DOM元素的outerHTML代码；&lt;/p&gt;
&lt;p&gt;2、放在&amp;lt;foreignObject&amp;gt;元素中；&lt;/p&gt;
&lt;p&gt;3、图片方式显示我们的SVG图形；&lt;/p&gt;
&lt;p&gt;4、上一步的图片本质还是SVG，我们可以借助&lt;code&gt;canvas&lt;/code&gt; &lt;code&gt;drawImage()&lt;/code&gt;方法将图片放在画布上，然后使用&lt;code&gt;canvas.toDataURL()&lt;/code&gt;方法转换成&lt;code&gt;png&lt;/code&gt;或&lt;code&gt;jpg&lt;/code&gt;图片。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;三、作用于svg标签的属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、viewport&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表示svg的可见区域的大小：width和height，&lt;/strong&gt;控制svg的宽度和高度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、viewBox&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义用户视野的位置以及大小，即定义用来观察SVG视图一个矩形区域，更形象的解释就是：SVG就像是我们的显示器屏幕，viewBox就是截屏工具选中的那个框框，最终的呈现就是把框框中的截屏内容再次在显示器中全屏显示！&lt;/p&gt;
&lt;p&gt;如：viewBox ='20 20 100 100'，前两个参数表示viewBox视野相对svg视图的x y坐标，后两个参数表示viewBox的大小。&lt;/p&gt;
&lt;p&gt;与svg实际大小的关系如下：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;11&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/24nWi0VrnpZG2UYzje7qmqN4B3.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/24nWi0VrnpZG2UYzje7qmqN4B3.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/24nWi0VrnpZG2UYzje7qmqN4B3.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，用户可以看到的部分是蓝色的星星，而星星的另一侧是看不到的。&lt;/p&gt;
&lt;p&gt;viewBox的使用案例：&lt;/p&gt;
&lt;p&gt;1、绘制矩形&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;svg width=&quot;200&quot; height=&quot;200&quot; style=&quot;border: 2px solid #58a&quot;&amp;gt;
  &amp;lt;rect x=&quot;30&quot; y=&quot;30&quot; width=&quot;100&quot; height=&quot;100&quot; fill=&quot;#fb3&quot; stroke=&quot;none&quot;&amp;gt;&amp;lt;/rect&amp;gt;
&amp;lt;/svg&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;10&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/24ctVzQRmAWA8cn4KeAGcxnYo7.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/24ctVzQRmAWA8cn4KeAGcxnYo7.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/24ctVzQRmAWA8cn4KeAGcxnYo7.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2、增加视野viewBox viewBox='0 0 100 100'，相当于用户只能看到SVG视图中viewBox定义的区域，即下图红色框内区域：&lt;/p&gt;
&lt;p&gt;viewBox=&quot;x, y, width, height&quot; // x:左上角横坐标，y:左上角纵坐标，width:宽度，height:高度&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;body&amp;gt;
   &amp;lt;svg width=&quot;200&quot; height=&quot;200&quot; style=&quot;border:2px solid #58a&quot; viewBox='0 0 100 100'&amp;gt;
        &amp;lt;rect x=&quot;30&quot; y=&quot;30&quot; width=&quot;200&quot; height=&quot;200&quot; fill=&quot;#fb3&quot; stroke=&quot;none&quot;&amp;gt;&amp;lt;/rect&amp;gt;
   &amp;lt;/svg&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;9&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/24kQQloAq3zjWPoHPvpY4Wi_Fn.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/24kQQloAq3zjWPoHPvpY4Wi_Fn.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/24kQQloAq3zjWPoHPvpY4Wi_Fn.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最终效果图：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;8&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/24rQvLxMzEDwx2OpQ8LacpTObM.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/24rQvLxMzEDwx2OpQ8LacpTObM.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/24rQvLxMzEDwx2OpQ8LacpTObM.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、preserveAspectRatio属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个属性也是作用于&amp;lt;svg&amp;gt;元素上，且作用对象都是viewBox。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;preserveAspectRatio=&quot;xMidYMid meet&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;属性值为空格分隔的两个值组合而成。第一个值表示：viewBox如何viePort对齐；第二个值表示：如何维持高宽比（可以为空）。&lt;/p&gt;
&lt;p&gt;其中，第一个值又分为两个部分组成。前半部分表示x方向的对齐。后半部分表示y方向对齐。&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td&gt; 值&lt;/td&gt;
&lt;td&gt; 含义&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; xMin&lt;/td&gt;
&lt;td&gt; viewport和viewBox左边对齐&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; xMid&lt;/td&gt;
&lt;td&gt; viewport和viewBox的x轴中心对齐&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; xMax&lt;/td&gt;
&lt;td&gt; viewport和vieBox右边对齐&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; YMin&lt;/td&gt;
&lt;td&gt; viewport和viewBox上边缘对齐。注意：Y是大写&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; YMid&lt;/td&gt;
&lt;td&gt; viewport和viewBox的y轴中心点对齐。注意：Y是大写&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; YMax&lt;/td&gt;
&lt;td&gt;viewport和viewBox下边缘对齐。注意：Y是大写 &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;xMaxYMax表示右-下&lt;/p&gt;
&lt;p&gt;xMidYMid表示中-中&lt;/p&gt;
&lt;p&gt;第二个值属性值支持&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt; 值&lt;/td&gt;
&lt;td&gt; 含义&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; meet&lt;/td&gt;
&lt;td&gt; 保持纵横比缩放viewBox适应viewport，受&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; slice&lt;/td&gt;
&lt;td&gt; 保持纵横比，同时比例小的方向放大填满viewport，攻&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; none&lt;/td&gt;
&lt;td&gt;扭曲纵横比，充分适应viewport，变态 &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;7&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25xdywDVdT8-NieEZanAnzSBXW.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25xdywDVdT8-NieEZanAnzSBXW.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/25xdywDVdT8-NieEZanAnzSBXW.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、图1：红色区域为不设置preserveaspectRatio时的可视区域；&lt;/p&gt;
&lt;p&gt;2、图2: 采用与x轴左边对齐、与y轴上边缘对齐的方式，保持纵横比缩放；&lt;/p&gt;
&lt;p&gt;3、图3：保持纵横比的同时，以比例小的方向即x轴等比放大，填充svg区域&lt;/p&gt;
&lt;p&gt;4、图4：preserveaspectRatio=&quot;none&quot;，变形充分适应svg&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;四、作用于svg内部元素的样式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;svg支持css选择器给元素添加样式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&lt;em&gt;/* 定义样式 */&lt;/em&gt;
.rectStyle {
  fill: yellow;
}
&amp;lt;svg width=&quot;200&quot; height=&quot;200&quot;&amp;gt;
  &amp;lt;rect class=&quot;rectStyle&quot; width=&quot;20&quot; height=&quot;20&quot;&amp;gt;&amp;lt;/rect&amp;gt;
&amp;lt;/svg&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以直接在元素中设置样式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;svg width=&quot;200&quot; height=&quot;200&quot;&amp;gt;
  &amp;lt;rect width=&quot;20&quot; height=&quot;20&quot; fill=&quot;yellow&quot;&amp;gt;&amp;lt;/rect&amp;gt;
&amp;lt;/svg&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者写成style&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;svg width=&quot;200&quot; height=&quot;200&quot;&amp;gt;
  &amp;lt;rect style=&quot;fill: yellow;&quot; width=&quot;20&quot; height=&quot;20&quot;&amp;gt;&amp;lt;/rect&amp;gt;
&amp;lt;/svg&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常见的样式说明：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、填充&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）fill：定义填充颜色和文字颜色；&lt;/p&gt;
&lt;p&gt;（2）fill-opacity：定义填充颜色的透明度；&lt;/p&gt;
&lt;p&gt;（3）fill-rule：指定填充规则，符合填充规则才可被填充，取值：&lt;code&gt;[nonzero | evenodd | inherit]&lt;/code&gt;，默认值为&lt;code&gt;nonzero。 &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;nonzero： 该规则判断点任意方向的射线与图形路径的相交情况，默认为数值0，射线从左到右时，每穿过一条路径，数值加1；从右到左时，每穿过一条路径，数值减1，最后结果若为0，则表示点不在图形内部，不能填充。&lt;/p&gt;
&lt;p&gt;evenodd：该规则判断点任意方向的射线与图形路径的相交情况，相交个数为奇数，则点在图形内部，可进行填充；反之在外部，不进行填充。&lt;/p&gt;
&lt;p&gt;好像比较难理解这个，fill-rule到底是为了解决什么问题？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;6&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25ZLqMCClYZR65QulyjRbgZQuU.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25ZLqMCClYZR65QulyjRbgZQuU.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/25ZLqMCClYZR65QulyjRbgZQuU.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们看上图，图中有一个路径A-B-C-D-E-F-G-H-I，当我们用fill填充它的时候，我们会发现其中有一个重叠的区域S，那么这个重叠的区域到底填不填充呢？这，就是fill-rule所干的事。&lt;/p&gt;
&lt;p&gt;分析：沿着A-B-C-D-E-F-G-H-I方向走，我们会发现重叠区域&lt;strong&gt;S外部为A-B-C-D-A&lt;/strong&gt;，形成方向为&lt;strong&gt;顺时针&lt;/strong&gt;方向。重叠外部区域S的形成方向为&lt;strong&gt;逆时针&lt;/strong&gt;H-I-A，所以重叠区域S不显示。这个和fill-rule设置无关，这是默认的。&lt;/p&gt;
&lt;p&gt;来看一下经典的五角星问题：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;5&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25gU_4K714QBbeFquZDoLL5C__.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25gU_4K714QBbeFquZDoLL5C__.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/25gU_4K714QBbeFquZDoLL5C__.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;相同的，这里有一个重叠区域S，不过如何才能知道是重叠区域呢？其实很简单，就是重叠区域的外面还有东西，而它们都还在整个形状之内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以发现五角星的重叠区域S的形成方向和外部是一样的，这种情况下，fill-rule就起作用了，如果是nonzero，区域S是显示的，如果是evenodd，区域S则不显示。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、边框&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）stroke：边框颜色；&lt;/p&gt;
&lt;p&gt;（2）stroke-width：边框宽度；&lt;/p&gt;
&lt;p&gt;（3）stroke-opacity：边框透明，取值[0,1]；&lt;/p&gt;
&lt;p&gt;（4）stroke-linecap：单条线端点样式，一般应用于直线或者路径，取值：&lt;code&gt;[ butt | square | round ]&lt;/code&gt;，分别是对接、方形和圆形&lt;/p&gt;
&lt;p&gt;（5）stroke-dasharray：虚线边框，可以设置每段虚线的长度和间隔，之间使用逗号分隔或者空格分隔，如：&lt;/p&gt;
&lt;p&gt;stroke-dasharray=&quot;10, 5, 5, 10&quot;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;4&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/259GgikbS_kcbg4VKT7C7Rv8LU.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/259GgikbS_kcbg4VKT7C7Rv8LU.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/259GgikbS_kcbg4VKT7C7Rv8LU.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（6）stroke-dashoffset：设置虚线描边偏移量，使图案向前移动&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;svg width=&quot;200&quot; height=&quot;200&quot; viewBox='0 0 300 300'&amp;gt;
    &amp;lt;line x1=&quot;20&quot; y1=&quot;20&quot; x2=&quot;120&quot; y2=&quot;20&quot;
        stroke=&quot;red&quot; stroke-width=&quot;5&quot; stroke-linecap=&quot;butt&quot;
        stroke-dasharray=&quot;20 5 5 10&quot;&amp;gt;
    &amp;lt;/line&amp;gt;
    &amp;lt;line x1=&quot;20&quot; y1=&quot;60&quot; x2=&quot;120&quot; y2=&quot;60&quot;
        stroke=&quot;red&quot; stroke-width=&quot;5&quot; stroke-linecap=&quot;butt&quot;
        stroke-dasharray=&quot;20 5 5 10&quot; stroke-dashoffset=&quot;10&quot;&amp;gt;
    &amp;lt;/line&amp;gt;
   &amp;lt;/svg&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25gh1pKOni4LvKxwGiPpAVPfUK.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25gh1pKOni4LvKxwGiPpAVPfUK.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/25gh1pKOni4LvKxwGiPpAVPfUK.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虚线的样式为&lt;code&gt; 20 5 5 10&lt;/code&gt;，偏移量为&lt;code&gt;10&lt;/code&gt;，根据下图可发现第二个虚线，整体向前移动了10个单位&lt;/p&gt;
&lt;p&gt;（7）sroke-linejoin：两条线段之间衔接点的样式，取值：&lt;code&gt;[ miter | round | bevel ]&lt;/code&gt;，分别是尖角(图左一)、圆角(图左二)和斜角(图左三)&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25-YF5poZsk0JnriD4KSLQgGU3.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25-YF5poZsk0JnriD4KSLQgGU3.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/25-YF5poZsk0JnriD4KSLQgGU3.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（8）sroke-miterlimit：默认值4，当&lt;code&gt;miterLength / stroke-width &amp;lt; stroke-miterlimit&lt;/code&gt;时，&lt;code&gt;stroke-linejoin&lt;/code&gt;值会变成换成&lt;code&gt;bevel&lt;/code&gt;斜角。如下图中，stroke-width为15，根据计算公式，miterLength ／ stroke-width 约等于5.2，即当&lt;code&gt;stroke-miterlimit&lt;/code&gt;小于6时，stroke-linejoin值会变成bevel斜角。&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25ajn2QaX9VnJGzK1ukeWlGOCC.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25ajn2QaX9VnJGzK1ukeWlGOCC.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/25ajn2QaX9VnJGzK1ukeWlGOCC.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、透明度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;opacity：定义整个图形的透明度&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、字体&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（1）font-size：字体大小；&lt;/p&gt;
&lt;p&gt;（2）font-family：字体系列的名称；&lt;/p&gt;
&lt;p&gt;（3）font-weight：字体粗细；&lt;/p&gt;
&lt;p&gt;（4）font-style：字体样式，斜体和正常；&lt;/p&gt;
&lt;p&gt;（5）text-decoration：下划线样式；&lt;/p&gt;
&lt;p&gt;（6）text-anchor：设置文本的排列属性，属性值&lt;code&gt;[start | middle | end | inherit]&lt;/code&gt;，如：middle表示，将文字定位原点移动至文字中心。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、变换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基础概念同css。&lt;/p&gt;
&lt;p&gt;（1）transform：同css，默认是&lt;strong&gt;左上角为旋转中心&lt;/strong&gt;，如：transform=&quot;rotate(30)&quot;；&lt;/p&gt;
&lt;p&gt;（2）transform-origin：同css，设置旋转的操作中心；&lt;/p&gt;
&lt;p&gt;（3）rotate：设置文字元素的旋转角度，正值为顺时针旋转，注意区分rotate和transform中的rotate，如rotate=&quot;30&quot;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img class=&quot;has cke_widget_element&quot; src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25g8JtKurhaCmC47JWzl4EtmVH.png&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://www.mwcxs.top/static/upload/pics/2019/2/25g8JtKurhaCmC47JWzl4EtmVH.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://www.mwcxs.top/static/upload/pics/2019/2/25g8JtKurhaCmC47JWzl4EtmVH.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:{&amp;amp;quot;has&amp;amp;quot;:1}}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; alt=&quot;&quot; width=&quot;15&quot; height=&quot;15&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;而transform中的rotate是对整个元素进行旋转操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;svg width=&quot;200&quot; height=&quot;200&quot;&amp;gt;
    &amp;lt;text x=&quot;10&quot; y=&quot;10&quot; dx=&quot;10&quot; dy=&quot;10&quot; textLength=&quot;100&quot; rotate=&quot;20&quot;&amp;gt;示例文字1&amp;lt;/text&amp;gt;
   &amp;lt;/svg&amp;gt;
   &amp;lt;svg width=&quot;200&quot; height=&quot;200&quot;&amp;gt;
    &amp;lt;text x=&quot;10&quot; y=&quot;10&quot; dx=&quot;10&quot; dy=&quot;10&quot; textLength=&quot;100&quot; transform=&quot;rotate(20)&quot;&amp;gt;示例文字2&amp;lt;/text&amp;gt;
   &amp;lt;/svg&amp;gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;五、参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、&lt;a href=&quot;http://www.runoob.com/svg/svg-stroke.html&quot; data-cke-saved-href=&quot;http://www.runoob.com/svg/svg-stroke.html&quot;&gt;http://www.runoob.&lt;/a&gt;&lt;a href=&quot;http://www.runoob.com/svg/svg-tutorial.html&quot; data-cke-saved-href=&quot;http://www.runoob.com/svg/svg-tutorial.html&quot;&gt;http://www.runoob.com/svg/svg-tutorial.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;http://qiutianaimeili.com/html/page/2018/04/08sh1vbv35yr.html&quot; data-cke-saved-href=&quot;http://qiutianaimeili.com/html/page/2018/04/08sh1vbv35yr.html&quot;&gt;http://qiutianaimeili.com/html/page/2018/04/08sh1vbv35yr.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 15:18:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>一、前言 1、SVG(Scalable Vector Graphics)可伸缩矢量图形 特点： （1）使用xml格式来定义图形； （2）用来定义web上的使用的矢量图； （3）改变图像尺寸，图片质量不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chengxs/p/10887650.html</dc:identifier>
</item>
<item>
<title>Netty入门系列(3) --使用Netty进行编解码的操作 - 正号先生</title>
<link>http://www.cnblogs.com/zhxiansheng/p/10887604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxiansheng/p/10887604.html</guid>
<description>&lt;p&gt;何为编解码，通俗的来说，我们需要将一串文本信息从A发送到B并且将这段文本进行加工处理，如：A将信息文本信息&lt;strong&gt;编码&lt;/strong&gt;为2进制信息进行传输。B接受到的消息是一串2进制信息，需要将其&lt;strong&gt;解码&lt;/strong&gt;为文本信息才能正常进行处理。&lt;/p&gt;
&lt;p&gt;上章我们介绍的Netty如何解决拆包和粘包问题，就是运用了解码的这一功能。&lt;/p&gt;

&lt;p&gt;使用Netty大多是java程序猿，我们基于一切都是对象的原则，经常会将对象进行网络传输，那么对于序列化操作肯定大家都是非常熟悉的。&lt;/p&gt;
&lt;p&gt;一个对象是不能直接进行网络I/O传输的，jdk默认是将对象转换为可存储的字节数组来进行网络操作。基于JDK默认的序列化机制可以避免操作底层的字节数组，从而提升开发效率。&lt;/p&gt;
&lt;p&gt;jdk默认的序列化机制虽然能给程序猿带来极大的方便，但是它也带来了许多问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;无法跨语言。&lt;/li&gt;
&lt;li&gt;序列化后的码流太大，会给网络传输带来极大的开销。&lt;/li&gt;
&lt;li&gt;序列化的性能太低，对于高性能的网络架构是极其不友好的。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;Google的Protobuf。&lt;/li&gt;
&lt;li&gt;Facebok的Thrift。&lt;/li&gt;
&lt;li&gt;Jboss Marshalling&lt;/li&gt;
&lt;li&gt;MessagePack&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这几类编解码框架都有各自的特点，有兴趣的童鞋可以自己对其进行研究。&lt;/p&gt;
&lt;p&gt;我们这里主要对MessagePack进行讲解。&lt;/p&gt;

&lt;p&gt;MessagePack是一个高效的二进制序列化框架，它像JSON一样支持不同的语言间的数据交换，并且它的性能更快，序列化之后的码流也更小。&lt;/p&gt;
&lt;p&gt;它的特点如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;编解码高效，性能高&lt;/li&gt;
&lt;li&gt;序列化之后的码流小，利于网络传输或存储&lt;/li&gt;
&lt;li&gt;支持跨语言&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;首先导包&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- https://mvnrepository.com/artifact/org.msgpack/msgpack --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.msgpack&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;msgpack&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.6.12&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;使用API进行编码和解码&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;List&amp;lt;String&amp;gt; nameList = new ArrayList&amp;lt;String&amp;gt;();
nameList.add(&quot;Tom&quot;);
nameList.add(&quot;Jack&quot;);
MessagePack messagePack = new MessagePack();
//开始序列化
byte[] raw = messagePack.write(nameList);
//使用MessagePack的模版，来接序列化后的字节数组转换为List
List&amp;lt;String&amp;gt; deNameList = messagePack.read(raw,Templates.tList(Templates.TString));
System.out.println(deNameList.get(0));
System.out.println(deNameList.get(1));
System.out.println(deNameList.get(2));&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;编码器的实现&quot;&gt;编码器的实现&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class MsgpackEncoder extends MessageToByteEncoder {

    @Override
    protected void encode(ChannelHandlerContext ctx, Object msg, ByteBuf out) throws Exception {
        MessagePack msgpack = new MessagePack();
        //使用MessagePack对要发送的数据进行序列化
        byte[] raw = msgpack.write(msg);
        out.writeBytes(raw);
        
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;解码器的实现&quot;&gt;解码器的实现&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class MsgpackDecoder extends MessageToMessageDecoder&amp;lt;ByteBuf&amp;gt; {

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List&amp;lt;Object&amp;gt; out) throws Exception {
        //从msg中获取需要解码的byte数组
        final int length = msg.readableBytes();
        byte[] b = new byte[length];
        msg.getBytes(msg.readerIndex(), b,0,length);
        //使用MessagePack的read方法将其反序列化成Object对象，并加入到解码列表out中
        MessagePack msgpack = new MessagePack();
        out.add(msgpack.read(b));
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现该编码器和解码器的netty服务端&quot;&gt;实现该编码器和解码器的Netty服务端&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class NettyServer {
    public void bind(int port) throws Exception {
        EventLoopGroup bossGruop = new NioEventLoopGroup();
        EventLoopGroup workGroup = new NioEventLoopGroup();
        ServerBootstrap bootstrap = new ServerBootstrap();
        bootstrap.group(bossGruop, workGroup)
                .channel(NioServerSocketChannel.class)
                .option(ChannelOption.SO_BACKLOG, 1024)
                .childHandler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;() {
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        // TODO Auto-generated method stub
                        socketChannel.pipeline()
                         //添加支持粘包、拆包解码器，意义：从头两个字节解析出数据的长度，并且长度不超过1024个字节
                        .addLast(&quot;frameDecoder&quot;,new LengthFieldBasedFrameDecoder(1024, 0, 2,0,2))
                         //反序列化解码器
                        .addLast(&quot;msgpack decoder&quot;,new MsgpackDecoder())
                         //添加支持粘包、拆包编码器，发送的每个数据都在头部增加两个字节表消息长度
                        .addLast(&quot;frameEncoder&quot;,new LengthFieldPrepender(2))
                         //序列化编码器
                        .addLast(&quot;msgpack encoder&quot;,new MsgpackEncoder()
                         //后续自己的业务逻辑
                        .addLast(new ServerHandler());
                    }
                });
        try {
            ChannelFuture future = bootstrap.bind(port).sync();
            future.channel().closeFuture().sync();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            bossGruop.shutdownGracefully();
            workGroup.shutdownGracefully();
        }
    }
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实现该编码器和解码器的netty客户端&quot;&gt;实现该编码器和解码器的Netty客户端&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;public class NettyClient {
    private void bind(int port, String host) {
        EventLoopGroup group = new NioEventLoopGroup();
        Bootstrap b = new Bootstrap();
        b.group(group)
                .channel(NioSocketChannel.class)
                .option(ChannelOption.TCP_NODELAY, true)
                .handler(new ChannelInitializer&amp;lt;SocketChannel&amp;gt;(){
                    @Override
                    protected void initChannel(SocketChannel socketChannel) throws Exception {
                        // TODO Auto-generated method stub
                        socketChannel.pipeline()
                        .addLast(&quot;frameDecoder&quot;, new LengthFieldBasedFrameDecoder(1024, 0, 2, 0, 2))
                        .addLast(&quot;msgpack decoder&quot;, new MsgpackDecoder())
                        .addLast(&quot;frameEncoder&quot;, new LengthFieldPrepender(2))
                        .addLast(&quot;msgpack encoder&quot;, new MsgpackEncoder())
                        .addLast(new ClientHandler());
                    }
                });
        try {
            ChannelFuture f = b.connect(host, port).sync();
            f.channel().closeFuture().sync();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            group.shutdownGracefully();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出客户端的代码与服务端基本相同，所以啊，如果能熟练掌握Netty，今后在自己的项目中运用上定制化编解码的传输，将会是一件十分简单的活路。&lt;/p&gt;

&lt;p&gt;无论是之前解决粘包拆包问题，还是这里的使用序列化框架来进行编解码。我相信读者学习到这里，对于Netty的使用都有了较为全面的了解。其实Netty帮我们解决了很多底层棘手问题，如客户端断连、句柄泄漏和消息丢失等等。所以我们才能十分简单开发出一个稳定的网络通讯项目。&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 15:10:00 +0000</pubDate>
<dc:creator>正号先生</dc:creator>
<og:description>前言 何为编解码，通俗的来说，我们需要将一串文本信息从A发送到B并且将这段文本进行加工处理，如：A将信息文本信息 编码 为2进制信息进行传输。B接受到的消息是一串2进制信息，需要将其 解码 为文本信息</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhxiansheng/p/10887604.html</dc:identifier>
</item>
<item>
<title>SynchronousQueue原理详解-非公平模式 - BattleHeart</title>
<link>http://www.cnblogs.com/dwlsxj/p/synchronousqueue-unfair-pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dwlsxj/p/synchronousqueue-unfair-pattern.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;说明：本文分析采用的是jdk1.8&lt;/p&gt;
&lt;p&gt;约定：下面内容中Ref-xxx代表的是引用地址，引用对应的节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面已经讲解了公平模式的内容，今天来讲解下关于非公平模式下的SynchronousQueue是如何进行工作的，在源码分析的时候，先来简单看一下非公平模式的简单原理，它采用的栈这种FILO先进后出的方式进行非公平处理，它内部有三种状态，分别是REQUEST，DATA，FULFILLING，其中REQUEST代表的数据请求的操作也就是take操作，而DATA表示的是数据也就是Put操作将数据存放到栈中，用于消费者进行获取操作，而FULFILLING代表的是可以进行互补操作的状态，其实和前面讲的公平模式也很类似。&lt;/p&gt;
&lt;p&gt;当有相同模式情况下进行入栈操作，相同操作指的是REQUEST和DATA两种类型中任意一种进行操作时，模式相同则进行入栈操作，如下图所示：&lt;/p&gt;
&lt;p&gt;同REQUEST进行获取数据时的入栈情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458325/201905/458325-20190518230144900-845492232.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样的put的操作，进行数据操作时为DATA类型的操作，此时队列情况为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458325/201905/458325-20190518230153189-386099573.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同模式下又是如何进行操作的？当有不同模式进来的时候，他不是将当前的模式压入栈顶，而是将FullFill模式和当前模式进行按位或之后压入栈顶，也就是压入一个进行FullFill请求的模式进入栈顶，请求配对操作，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458325/201905/458325-20190518230203366-349891783.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图可见，本来栈中有一个DATA模式的数据等待消费者进行消费，这时候来了一个REQUEST模式的请求操作来进行消费数据，这时候并没有将REQUEST模式直接压入栈顶，而是将其转换为FULLFILLING模式，并且保留了原有的类型，这是进行FULLFILLING的请求，请求和栈顶下方元素进行匹配，当匹配成功后将栈顶和匹配元素同时进行出栈操作，详细请见下文分析：&lt;/p&gt;
&lt;h2 id=&quot;transferstack&quot;&gt;TransferStack&lt;/h2&gt;
&lt;h3 id=&quot;字段信息&quot;&gt;字段信息&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/** 消费者模式 */
static final int REQUEST    = 0;
/** 提供者模式 */
static final int DATA       = 1;
/** 互补模式 */
static final int FULFILLING = 2;
/** 栈顶指针 */
volatile SNode head;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方法&quot;&gt;方法&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;isFulfilling&lt;/td&gt;
&lt;td&gt;判断指定类型是否是互补模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;casHead&lt;/td&gt;
&lt;td&gt;替换当前头结点&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;snode&lt;/td&gt;
&lt;td&gt;生成SNode节点对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;transfer&lt;/td&gt;
&lt;td&gt;主要处理逻辑&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;awaitFulfill&lt;/td&gt;
&lt;td&gt;等待fulfill操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;shouldSpin&lt;/td&gt;
&lt;td&gt;判断节点s是头结点或是fulfill节点则返回true&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;snode内容&quot;&gt;SNode内容&lt;/h3&gt;
&lt;h4 id=&quot;字段信息-1&quot;&gt;字段信息&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;volatile SNode next;        // 栈下一个元素
volatile SNode match;       // 匹配的节点
volatile Thread waiter;     // 控制park/unpark的线程
Object item;                // 数据或请求
int mode;                                       // 模式，上面介绍的三种模式&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方法-1&quot;&gt;方法&lt;/h4&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;casNext&lt;/td&gt;
&lt;td&gt;判断指定类型是否是互补模式&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;tryMatch&lt;/td&gt;
&lt;td&gt;尝试匹配节点，如果存在匹配节点则判断是否是当前节点，直接返回判断结果，如果没有则替换match内容并且唤醒线程&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;tryCancel&lt;/td&gt;
&lt;td&gt;生成SNode节点对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;isCancelled&lt;/td&gt;
&lt;td&gt;主要处理逻辑&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;经过上面内容的分析，接下来就进入正题，让我们整体先看一下下transfer都为我们做了些什么内容，下面是transfer源码内容:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;E transfer(E e, boolean timed, long nanos) {
    /*
     * Basic algorithm is to loop trying one of three actions:
     *
     * 1. If apparently empty or already containing nodes of same
     *    mode, try to push node on stack and wait for a match,
     *    returning it, or null if cancelled.
     *
     * 2. If apparently containing node of complementary mode,
     *    try to push a fulfilling node on to stack, match
     *    with corresponding waiting node, pop both from
     *    stack, and return matched item. The matching or
     *    unlinking might not actually be necessary because of
     *    other threads performing action 3:
     *
     * 3. If top of stack already holds another fulfilling node,
     *    help it out by doing its match and/or pop
     *    operations, and then continue. The code for helping
     *    is essentially the same as for fulfilling, except
     *    that it doesn't return the item.
     */

    SNode s = null; // constructed/reused as needed
    int mode = (e == null) ? REQUEST : DATA;

    for (;;) {
        SNode h = head;
        if (h == null || h.mode == mode) {  // 栈顶指针为空或者是模式相同
            if (timed &amp;amp;&amp;amp; nanos &amp;lt;= 0) {      // 制定了timed并且时间小于等于0则取消操作。
                if (h != null &amp;amp;&amp;amp; h.isCancelled())
                    casHead(h, h.next);     // 判断头结点是否被取消了取消了就弹出队列，将头结点指向下一个节点
                else
                    return null;
            } else if (casHead(h, s = snode(s, e, h, mode))) {// 初始化新节点并且修改栈顶指针
                SNode m = awaitFulfill(s, timed, nanos);            // 进行等待操作
                if (m == s) {               // 返回内容是本身则进行清理操作
                    clean(s);
                    return null;
                }
                if ((h = head) != null &amp;amp;&amp;amp; h.next == s)
                    casHead(h, s.next);     // help s's fulfiller
                return (E) ((mode == REQUEST) ? m.item : s.item);
            }
        } else if (!isFulfilling(h.mode)) { // 尝试去匹配
            if (h.isCancelled())            // 判断是否已经被取消了
                casHead(h, h.next);         // 弹出取消的节点并且从新进入主循环
            else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {//新建一个Full节点压入栈顶
                for (;;) { // 循环直到匹配
                    SNode m = s.next;       // s的下一个节点为匹配节点
                    if (m == null) {        // 代表没有等待内容了
                        casHead(s, null);   // 弹出full节点
                        s = null;           // 设置为null用于下次生成新的节点
                        break;              // 退回到主循环中
                    }
                    SNode mn = m.next;
                    if (m.tryMatch(s)) {
                        casHead(s, mn);     // 弹出s节点和m节点两个节点
                        return (E) ((mode == REQUEST) ? m.item : s.item);
                    } else                  // 如果失去了匹配
                        s.casNext(m, mn);   // 帮助取消连接
                }
            }
        } else {                            // 这里是帮助进行fillull
            SNode m = h.next;               // m是头结点的匹配节点
            if (m == null)                  // 如果m不存在则直接将头节点赋值为nll
                casHead(h, null);           // 弹出fulfill节点
            else {
                SNode mn = m.next;
                if (m.tryMatch(h))          // h节点尝试匹配m节点
                    casHead(h, mn);         // 弹出h和m节点
                else                        // 丢失匹配则直接将头结点的下一个节点赋值为头结点的下下节点
                    h.casNext(m, mn);       
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;模式相同的时候则进行等待操作，入队等待操作&lt;/li&gt;
&lt;li&gt;当模式不相同时，首先判断头结点是否是fulfill节点如果不是则进行匹配操作，如果是fulfill节点先帮助头结点的fulfill节点进行匹配操作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来再来看一下&lt;code&gt;awaitFulfill&lt;/code&gt;方法内容&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SNode awaitFulfill(SNode s, boolean timed, long nanos) {
    final long deadline = timed ? System.nanoTime() + nanos : 0L;
    // 等待线程
    Thread w = Thread.currentThread();
    // 等待时间设置
    int spins = (shouldSpin(s) ?
                 (timed ? maxTimedSpins : maxUntimedSpins) : 0);
    for (;;) {
        if (w.isInterrupted())          // 判断当前线程是否被中断 
            s.tryCancel();                  // 尝试取消操作 
        SNode m = s.match;                  // 获取当前节点的匹配节点，如果节点不为null代表匹配或取消操作，则返回
        if (m != null)
            return m;
        if (timed) {
            nanos = deadline - System.nanoTime();
            if (nanos &amp;lt;= 0L) {
                s.tryCancel();
                continue;
            }
        }
        if (spins &amp;gt; 0)
            spins = shouldSpin(s) ? (spins-1) : 0;
        else if (s.waiter == null)
            s.waiter = w; // establish waiter so can park next iter
        else if (!timed)
            LockSupport.park(this);
        else if (nanos &amp;gt; spinForTimeoutThreshold)
            LockSupport.parkNanos(this, nanos);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的源码，其实我们之前分析同步模式的时候差不太多，变化的地方其中包括返回内容判断这里判断的是match节点是否为null，还有就是spins时间设置这里发现了&lt;code&gt;shoudSpin&lt;/code&gt;用来判断是否进行轮训，来看一下&lt;code&gt;shouldSpin&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 判断节点是否是fulfill节点，或者是头结点为空再或者是头结点和当前节点相等时则不需要进行轮训操作
 */
boolean shouldSpin(SNode s) {
    SNode h = head;
    return (h == s || h == null || isFulfilling(h.mode));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上就是判断节点是否是fulfill节点，或者是头结点为空再或者是头结点和当前节点相等时则不需要进行轮训操作，如果满足上述条件就不小进行轮训等到操作了直接进行等待就行了。&lt;/p&gt;
&lt;p&gt;接下来我们来用例子一点点解析原理：&lt;/p&gt;
&lt;p&gt;首先先进行一个put操作，这样可以简单分析下内部信息。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * SynchronousQueue原理内容
 *
 * @author battleheart
 */
public class SynchronousQueueDemo1 {
    public static void main(String[] args) throws Exception {
        SynchronousQueue&amp;lt;Integer&amp;gt; queue = new SynchronousQueue&amp;lt;&amp;gt;();

        Thread thread1 = new Thread(() -&amp;gt; {
            try {
                queue.put(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread1.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先它会进入到transfer方法中，进行第一步的判断他的类型信息，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SNode s = null; // constructed/reused as needed
int mode = (e == null) ? REQUEST : DATA;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面代码可以看到e=1所以是DATA类型，接下来进行判断是如何进行操作，当前堆栈是空的，如何判断堆栈为空呢？上面也讲到了&lt;code&gt;head&lt;/code&gt;节点为空时则代表堆栈为空，接下来就要判断如果head节点为空或head指向的节点和当前操作内容模式相同，则进行等待操作，如下代码所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SNode h = head;
if (h == null || h.mode == mode) {  // empty or same-mode
    if (timed &amp;amp;&amp;amp; nanos &amp;lt;= 0) {      // can't wait
        if (h != null &amp;amp;&amp;amp; h.isCancelled())
            casHead(h, h.next);     // pop cancelled node
        else
            return null;
    } else if (casHead(h, s = snode(s, e, h, mode))) {
        SNode m = awaitFulfill(s, timed, nanos);
        if (m == s) {               // wait was cancelled
            clean(s);
            return null;
        }
        if ((h = head) != null &amp;amp;&amp;amp; h.next == s)
            casHead(h, s.next);     // help s's fulfiller
        return (E) ((mode == REQUEST) ? m.item : s.item);
    }
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然头结点是空的，所以进入到第一个fi语句中执行等待操作，如果指定了timed则判断时间是否小于0，如果小于0则直接null，反之判断当前节点是否不是头结点以及头结点是否取消，潘祖条件弹出头结点，并将下一个节点设置为头结点，上述条件在当前例子中都不满足，所以要进入到下面这段代码中，首先进行对s进行初始化值，并且进行入栈操作，&lt;code&gt;casHead(h, s = snode(s, e, h, mode))&lt;/code&gt;，下面看一下栈中的情况如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458325/201905/458325-20190518230224461-493625785.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当执行完了入栈操作之后接下来要执行&lt;code&gt;awaitFulfill&lt;/code&gt;这里的操作就是轮训以及将当前节点的线程赋值，并且挂起当前线程。此时的栈的情况如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458325/201905/458325-20190518230232772-1996684537.png&quot;/&gt;&lt;br/&gt;当有同样的模式进行操作时候也是重复上述的操作内容，我们这里模拟两次put操作，让让我们看一下栈中的情况如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458325/201905/458325-20190518230245822-2140625975.png&quot;/&gt;&lt;br/&gt;通过上图可以看到，其实就是将头结点移动到了新的节点上，然后新节点的next节点维护这下一个节点的引用，好了，上述内容分析是同模式的操作，接下来我们试着进行take操作时，这时候会发什么内容呢？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * SynchronousQueue例子二进行两次put操作和一次take操作
 *
 * @author battleheart
 */
public class SynchronousQueueDemo1 {
    public static void main(String[] args) throws Exception {
        SynchronousQueue&amp;lt;Integer&amp;gt; queue = new SynchronousQueue&amp;lt;&amp;gt;();

        Thread thread1 = new Thread(() -&amp;gt; {
            try {
                queue.put(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread1.start();
        Thread.sleep(2000);
        Thread thread2 = new Thread(() -&amp;gt; {
            try {
                queue.put(2);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread2.start();

        Thread.sleep(2000);
        Thread thread6 = new Thread(() -&amp;gt; {
            try {
                queue.take();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        });
        thread6.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面例子正好符合上面例子两次put操作的截图，进行两次put操作过后再进行take操作，接下来我们来看一下take操作是如何进行操作的，换句话说当有不同模式的操作时又是如何进行处理呢？上面分析的内容是同种操作模式下的，当有不同操作则会走下面内容：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; else if (!isFulfilling(h.mode)) { // try to fulfill
    if (h.isCancelled())            // already cancelled
        casHead(h, h.next);         // pop and retry
    else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) {
        for (;;) { // loop until matched or waiters disappear
            SNode m = s.next;       // m is s's match
            if (m == null) {        // all waiters are gone
                casHead(s, null);   // pop fulfill node
                s = null;           // use new node next time
                break;              // restart main loop
            }
            SNode mn = m.next;
            if (m.tryMatch(s)) {
                casHead(s, mn);     // pop both s and m
                return (E) ((mode == REQUEST) ? m.item : s.item);
            } else                  // lost match
                s.casNext(m, mn);   // help unlink
        }
    }
} else {                            // help a fulfiller
    SNode m = h.next;               // m is h's match
    if (m == null)                  // waiter is gone
        casHead(h, null);           // pop fulfilling node
    else {
        SNode mn = m.next;
        if (m.tryMatch(h))          // help match
            casHead(h, mn);         // pop both h and m
        else                        // lost match
            h.casNext(m, mn);       // help unlink
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最下面的else我们等会来进行分析，我们看到如果不是同模式的话，则会先判断是否是fulfill模式，如果不是fulfill模式，则进入到第一个if语句中，显然通过&lt;code&gt;图示6&lt;/code&gt;可以得出，头结点&lt;code&gt;head&lt;/code&gt;模式并不是fillfull模式，则进入到该if语句中，上来首先判断当前头结点是否被取消了，如果被取消则将头结点移动到栈顶下一个节点，反之则将s节点赋值为fulfill模式按位或当前节点模式，个人认为目的是既保留了原有模式也变成了fulfill模式，我们开篇就讲到了，REQUEST=0，二进制则是00，而DATA=1，其二进制为01，而FULFILLING=2，其二进制表示10，也就是说如果当前节点是REQUEST的话那么节点的内容值时00|10=10，如果节点是DATA模式则s节点的模式时01|10=11，这样的话11既保留了原有模式也是FULFILLING模式，然后将头节点移动到当前s节点，也就是将FULFILLING模式节点入栈操作，目前分析到这里时&lt;code&gt;casHead(h, s=snode(s, e, h, FULFILLING|mode)&lt;/code&gt;，栈的情况如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458325/201905/458325-20190518230257442-1235765910.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来运行for循环里面内容，先运行如下内容：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SNode m = s.next;       // m is s's match
if (m == null) {        // all waiters are gone
    casHead(s, null);   // pop fulfill node
    s = null;           // use new node next time
    break;              // restart main loop
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先判断当前节点也就是头结点s的下一个节点上图中head=s节点，所以s.next节点代表的是&lt;code&gt;Ref-750&lt;/code&gt;，判断当前节点是否为空，如果为空的话代表没有可匹配的节点，先对head进行替换为null代表堆栈为空，然后将当前s节点设置为null，退出fulfill匹配模式进入到主循环中，会重新进行对当前节点进行操作，是消费还是匹配，显然本例子中m节点是不为空的，所以这里不会运行，跳过之后运行下面内容：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SNode mn = m.next;
if (m.tryMatch(s)) {
    casHead(s, mn);     // pop both s and m
    return (E) ((mode == REQUEST) ? m.item : s.item);
} else                  // lost match
    s.casNext(m, mn);   // help unlink&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mn节点在上图中对应的是&lt;code&gt;Ref-681&lt;/code&gt;，这里是重点，&lt;code&gt;m.tryMatch(s)&lt;/code&gt;，m节点尝试匹配s节点，进入到方法里，到这一步是我们再来看一下头结点的元素的内容：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458325/201905/458325-20190518230314780-152596993.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;并且唤醒m节点的，告诉m节点，你现在有匹配的对象了你可以被唤醒了，这里唤醒之后就会进入到&lt;code&gt;awaitFulfill&lt;/code&gt;下面的操作&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SNode m = awaitFulfill(s, timed, nanos);
if (m == s) {               // wait was cancelled
    clean(s);
    return null;
}
if ((h = head) != null &amp;amp;&amp;amp; h.next == s)
    casHead(h, s.next);     // help s's fulfiller
return (E) ((mode == REQUEST) ? m.item : s.item);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行这里的线程显然是上图中的m节点，因为m节点被唤醒了，m==s代表的是取消了节点，显然没有进行该操作，然后就是帮助头结点进行fulfill操作，这里重点说一下这段代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;if ((h = head) != null &amp;amp;&amp;amp; h.next == s)
    casHead(h, s.next);  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获取当前头结点，也就是上图中的头结点如果不为空而且h.next节点为m节点正好是m节点进行操作时的s节点，也就是说这个语句是成立的，直接将头节点指向了上图的mn节点，这里的操作和take中的下面操作是一样的，也就是帮助fulfill操作弹出栈顶和栈顶匹配的节点内容，下面代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;SNode mn = m.next;
if (m.tryMatch(s)) {
    casHead(s, mn);     // pop both s and m
    return (E) ((mode == REQUEST) ? m.item : s.item);
} else                  // lost match
    s.casNext(m, mn);   // help unlink&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点是casHead的代码，弹出s和m两个节点，此时栈中内容如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458325/201905/458325-20190518230324609-1351428031.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要的流程分析完毕了，但是细心的朋友会发现，最后面还有一个帮助fulfill的操作，（transfer中）代码如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;else {                            // help a fulfiller
    SNode m = h.next;               // m is h's match
    if (m == null)                  // waiter is gone
        casHead(h, null);           // pop fulfilling node
    else {
        SNode mn = m.next;
        if (m.tryMatch(h))          // help match
            casHead(h, mn);         // pop both h and m
        else                        // lost match
            h.casNext(m, mn);       // help unlink
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;个人理解是这样的，我们上面也分析到了如果模式是相同模式情况和如果是不同模式且模式不为匹配模式的情况，但是还会有另外一种情况就是如果是不同模式并且头结点是匹配模式的就会进入到帮助去fullfill的情况，我来画图说明一下该情况：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/458325/201905/458325-20190518230335617-1750679886.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，上一个匹配操作没有进行完然后又来了一个请求操作，他就会帮助head进行匹配操作，也就是运行上面的代码逻辑，逻辑和匹配内容是一样的。&lt;/p&gt;
&lt;p&gt;接下来让我们看一下取消的clean方法内容:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void clean(SNode s) {
    s.item = null;   // 将item值设置为null
    s.waiter = null; // 将线程设置为null

    SNode past = s.next;   // s节点下一个节点如果不为空，并且节点是取消节点则指向下下个节点，这里是结束的标识，代表没有了。
    if (past != null &amp;amp;&amp;amp; past.isCancelled())
        past = past.next;

    // 如果取消的是头节点则运行下面的清理操作，操作逻辑很简单就是判断头结点是不是取消节点，如果是则将节点一定到下一个节点
    SNode p;
    while ((p = head) != null &amp;amp;&amp;amp; p != past &amp;amp;&amp;amp; p.isCancelled())
        casHead(p, p.next);

    // 取消不是头结点的嵌套节点。
    while (p != null &amp;amp;&amp;amp; p != past) {
        SNode n = p.next;
        if (n != null &amp;amp;&amp;amp; n.isCancelled())
            p.casNext(n, n.next);
        else
            p = n;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过源码可以看到首先是先找到一个可以结束的标识past，也就说到这里就结束了，判断是否不是头节点被取消了，如果是头节点被取消了则进行第一个while语句，操作也很简单就是将头节点替换头结点的下一个节点，如果不是头节点被取消了则进行下面的while语句操作，其实就是将取消的上一个节点的下一个节点指定为被取消节点的下一个节点，到此分析完毕了。&lt;/p&gt;

&lt;p&gt;如果有分析不正确的请各位指正，我这边改正~&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 15:06:00 +0000</pubDate>
<dc:creator>BattleHeart</dc:creator>
<og:description>前面已经讲解了公平模式的内容，今天来讲解下关于非公平模式下的SynchronousQueue是如何进行工作的，在源码分析的时候，先来简单看一下非公平模式的简单原理，它采用的栈这种FILO先进后出的方式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dwlsxj/p/synchronousqueue-unfair-pattern.html</dc:identifier>
</item>
<item>
<title>初识Kotlin之集合 - ITDragon龙</title>
<link>http://www.cnblogs.com/itdragon/p/10887579.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itdragon/p/10887579.html</guid>
<description>&lt;p&gt;Kotlin的集合是让我为之心动的地方，丰富的高阶函数帮助我们高效开发。今天介绍Kotlin的基础集合用法、获取集合元素的函数、过滤元素的函数、元素排序的函数、元素统计的函数、集合元素映射的函数、集合的交差并补集的函数。还有一些工作中的经验。&lt;/p&gt;

&lt;p&gt;和Java集合不同的是，Kotlin的集合分可变和不可变两种集合。同时也支持两种集合相互切换。&lt;/p&gt;
&lt;h3 id=&quot;list集合&quot;&gt;List集合&lt;/h3&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;// 声明并初始化不可变List集合
val list: List&amp;lt;Any&amp;gt; = listOf&amp;lt;Any&amp;gt;(1, &quot;2&quot;, 3)
// 声明并初始化可变MutableList集合
val mutableList: MutableList&amp;lt;Any&amp;gt; = mutableListOf&amp;lt;Any&amp;gt;(4, &quot;5&quot;, 6)
mutableList.add(&quot;7&quot;)
list.map { print(&quot;$it \t&quot;) }
mutableList.map { print(&quot;$it \t&quot;) }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;set集合&quot;&gt;Set集合&lt;/h3&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;// 声明并初始化不可变Set集合
val set: Set&amp;lt;Any&amp;gt; = setOf&amp;lt;Any&amp;gt;(1, &quot;2&quot;, 3, &quot;3&quot;)
// 声明并初始化可变MutableSet集合
val mutableSet: MutableSet&amp;lt;Any&amp;gt; = mutableSetOf&amp;lt;Any&amp;gt;(4, &quot;5&quot;, 6)
mutableSet.add(6)
set.map { print(&quot;$it \t&quot;) }
mutableSet.map { print(&quot;$it \t&quot;) }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;map集合&quot;&gt;Map集合&lt;/h3&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;// 声明并初始化不可变Map集合
val map: Map&amp;lt;String, Any&amp;gt; = mapOf(&quot;k1&quot; to &quot;v1&quot; , &quot;k2&quot; to 3)
// 声明并初始化可变MutableMap集合
val mutableMap: MutableMap&amp;lt;String, Any&amp;gt; = mutableMapOf(&quot;k1&quot; to &quot;v1&quot; , &quot;k1&quot; to 3)
map.map { println(&quot;key : ${it.key} \t value : ${it.value}&quot;) }
mutableMap.map { println(&quot;key : ${it.key} \t value : ${it.value}&quot;) }&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;获取集合元素&quot;&gt;获取集合元素&lt;/h2&gt;
&lt;p&gt;用Java语言开发时，我们通常用循环遍历集合的每个元素。有时候也会通过下标直接获取指定元素。此时原则上时需要我们先考虑集合元素的长度，以避免下标越界的异常问题。但往往我们会抱着侥幸的心态直接通过&lt;code&gt;get(index)&lt;/code&gt;方法获取元素。一般情况下我们会在黑盒自测中发现越界问题（有部分朋友从不黑盒，直接白盒测试，并反问：测试的工作难道不就是发现问题？）。即便是在运行中出现越界问题，也可以甩锅给数据库。但不管怎么样，因为越界导致系统不稳定是不合理的。&lt;/p&gt;
&lt;p&gt;用Kotlin语言开发时，我们会发现有很多带有&quot;Or&quot;字样的方法。比如我常用的&lt;code&gt;getOrElse&lt;/code&gt;，&lt;code&gt;firstOrNull&lt;/code&gt; 等方法。分别表示：通过下标如果没有获取到值，则返回自定的值。和获取集合的第一个元素，若集合为空则返回null。正因为Kotlin提供了很多类似&lt;code&gt;getOrElse&lt;/code&gt;，&lt;code&gt;firstOrNull&lt;/code&gt; 的方法。很大程度上提高了我们的开发效率，和减少了一些低级错误发生的概率。接下来我们学习一下Kotlin具体有哪些获取集合元素的方法（single方法没怎么用过）&lt;/p&gt;
&lt;h3 id=&quot;常用函数&quot;&gt;常用函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;get(index)&lt;/code&gt; : List的函数，通过下标获取指定元素。若找不到值（下标越界），会抛出&lt;code&gt;IndexOutOfBoundsException&lt;/code&gt;异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getOrElse(index, {...})&lt;/code&gt; : List的扩展函数，通过下标获取指定元素。找不到值则返回默认值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;getOrNull(index)&lt;/code&gt; : List的扩展函数，通过下标获取指定元素。找不到值则返回null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;elementAtOrElse(index, {...})&lt;/code&gt; : Iterable接口的扩展函数，功能同&lt;code&gt;getOrElse&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;elementAtOrNull(index)&lt;/code&gt; : Iterable接口的扩展函数，功能同&lt;code&gt;getOrNull&lt;/code&gt; 方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意get方法是List独有，其他集合可以用element方法。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;first()&lt;/code&gt; : 获取集合第一个元素。若没有返回值，则抛出&lt;code&gt;NoSuchElementException&lt;/code&gt;异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;first{}&lt;/code&gt; : 获取集合中指定元素的第一个元素。若没有返回值，则抛出&lt;code&gt;NoSuchElementException&lt;/code&gt;异常&lt;/li&gt;
&lt;li&gt;&lt;code&gt;firstOrNull()&lt;/code&gt; : 获取集合第一个元素。若没有返回值，返回null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;firstOrNull{}&lt;/code&gt; : 获取集合指定元素的第一个元素。若没有返回值，返回null&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;看到这里，是不是有点明白Kotlin获取元素的规则：如果没有则怎么样&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;last()&lt;/code&gt; : 与&lt;code&gt;first()&lt;/code&gt;相反&lt;/li&gt;
&lt;li&gt;&lt;code&gt;last{}&lt;/code&gt; : 与&lt;code&gt;first{}&lt;/code&gt;相反&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lastOrNull{}&lt;/code&gt; : 与&lt;code&gt;firstOrNull()&lt;/code&gt;相反&lt;/li&gt;
&lt;li&gt;&lt;code&gt;lastOrNull()&lt;/code&gt; : 与&lt;code&gt;firstOrNull{}&lt;/code&gt;相反&lt;/li&gt;
&lt;li&gt;&lt;code&gt;indexOfFirst{...}&lt;/code&gt; : 返回集合中第一个满足条件元素的下标&lt;/li&gt;
&lt;li&gt;&lt;code&gt;indexOfLast{...}&lt;/code&gt; : 返回集合中最后一个满足条件元素的下标&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;咋也不知道single方法设计的初衷，咋也不敢问&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;single()&lt;/code&gt; : Returns the single element, or throws an exception if the collection is empty or has more than one element. &lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/single.html&quot;&gt;官方api文档地址&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;single{}&lt;/code&gt; : 按照条件返回单个元素，若集合为空或者有多个元素满足条件，则报错&lt;/li&gt;
&lt;li&gt;&lt;code&gt;singleOrNull()&lt;/code&gt; : 返回单个元素，若集合为空或者有多个元素，则返回null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;singleOrNull{}&lt;/code&gt; : 按照条件返回单个元素，若集合为空或者有多个元素满足条件，则返回null&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用建议&quot;&gt;使用建议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;在使用获取元素的方法时，推荐方法名中带有&quot;Or&quot;字样的方法&lt;/strong&gt;，可以减少很多不必要的报错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;List集合通过下标获取元素可以用get,getOrElse,getOrNull函数&lt;/strong&gt;，但其他集合没有这些方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;笔者单方面认为single函数和数据库的唯一约束的功能有点类似&lt;/strong&gt;，在使用Kotlin的过程中，你会发现它有很多和数据库类似的功能。&lt;/p&gt;
&lt;h3 id=&quot;基础用法&quot;&gt;基础用法&lt;/h3&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;val list: MutableList&amp;lt;Int&amp;gt; = mutableListOf(1,2,3,4,5)
println(&quot;getOrElse : ${list.getOrElse(10,{ 20 })}&quot;)
println(&quot;getOrNull : ${list.getOrNull(10)}&quot;)
println(&quot;firstOrNull : ${list.firstOrNull()}&quot;)
println(&quot;firstOrNull : ${list.firstOrNull { it &amp;gt; 3 }}&quot;)
println(&quot;indexOfFirst : ${list.indexOfFirst { it &amp;gt; 3 }}&quot;)
println(&quot;indexOfLast : ${list.indexOfLast { it &amp;gt; 3 }}&quot;)
-----------------------------------------------------
getOrElse : 20
getOrNull : null
firstOrNull : 1
firstOrNull : 4
indexOfFirst : 3
indexOfLast : 4&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;集合元素排序&quot;&gt;集合元素排序&lt;/h2&gt;
&lt;p&gt;用Java语言开发时，给对象集合做排序是常有的业务逻辑。（Java8之后的写法不太了解）按照我之前工作中排序的代码其实也并不复杂，十行代码基本可以搞定一个排序逻辑。注意是一个，一个。业务中存在大量的排序需求，这种代码会反复出现。对于我这种佛系程序员兼CV高手而言，早已经习以为常了。但自从用了Kotlin的&lt;code&gt;sortedBy&lt;/code&gt;方法后。突然觉得Kotlin用起来倍儿爽！&lt;/p&gt;
&lt;p&gt;用Java7开发了几年，Java8只接触了一点皮毛，现在Java12都已经出来了。经常看到一些文章为了突出某个语言的强大，而去踩其他语言。我只想问：who are you？每个语言都有自己独特的一面.神仙打架，我们负责吃瓜就好。就懂点皮毛的人，瞎掺和啥？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Collections.sort(list,new Comparator () {
    @Override
    public int compare(Object o1, Object o2) {
        return o1.compareTo(e2);
    }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用Kotlin语言开发时，我们不需要重复写类似上面的排序代码，Kotlin已经帮我们封装好了，只需要我们写需要排序的字段即可。其底层也是通过Java 的Collections.sort实现的。所有我们就放心大胆的用吧。&lt;/p&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;public inline fun &amp;lt;T, R : Comparable&amp;lt;R&amp;gt;&amp;gt; MutableList&amp;lt;T&amp;gt;.sortBy(crossinline selector: (T) -&amp;gt; R?): Unit {
    if (size &amp;gt; 1) sortWith(compareBy(selector))
}

@kotlin.jvm.JvmVersion
public fun &amp;lt;T&amp;gt; MutableList&amp;lt;T&amp;gt;.sortWith(comparator: Comparator&amp;lt;in T&amp;gt;): Unit {
    if (size &amp;gt; 1) java.util.Collections.sort(this, comparator)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;常用函数-1&quot;&gt;常用函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;sortedBy{}&lt;/code&gt; : 根据条件给集合升序，常用与给对象集合的某个字段排序，并返回排序后的集合，原集合顺序不变&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reversed()&lt;/code&gt; : 集合反序。与降序不同，反序指的是和初始化的顺序相反&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sorted()&lt;/code&gt; : 自然升序，常用于给普通集合排序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sortedDescending()&lt;/code&gt; : 自然降序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sortedByDescending{}&lt;/code&gt; : 根据条件给集合降序&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ed结尾的排序方法，是不会对原集合进行修改，而是返回一个排序后的新集合。没有以ed结尾的方法恰恰相反&lt;/strong&gt; ---来自一个不严谨的总结&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sortBy{}&lt;/code&gt; : 根据条件给原集合升序，常用与给对象集合的某个字段排序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sortByDescending{}&lt;/code&gt; : 根据条件给原集合降序&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reverse()&lt;/code&gt; : 原集合反序&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用建议-1&quot;&gt;使用建议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;千万不要把反序理解成了倒序&lt;/strong&gt;，前车之鉴&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;sortBy方法是对原集合做排序操作，而sortedBy方法是返回一个排序后的新集合&lt;/strong&gt;，原集合排序没有变&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;kotlin排序方法中可以用and，or 组装多个条件&lt;/strong&gt;，但效果并不理想&lt;/p&gt;
&lt;h3 id=&quot;基础用法-1&quot;&gt;基础用法&lt;/h3&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;data class Person(
    var name: String = &quot;&quot;,
    var age: Int = 0,
    var salary: Double = 0.0
)

val persons = mutableListOf(Person(&quot;n1&quot;, 20, 2000.0),
    Person(&quot;n2&quot;, 24, 4000.0),
    Person(&quot;n3&quot;, 28, 6000.0),
    Person(&quot;n4&quot;, 26, 8000.0),
    Person(&quot;n5&quot;, 34, 7000.0),
    Person(&quot;n6&quot;, 44, 5000.0))
persons.sortedBy { it.age }.map { println(it) }
persons.map { it.age }.sorted()
persons.sortBy { it.age }
persons.reversed()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;过滤元素&quot;&gt;过滤元素&lt;/h2&gt;
&lt;p&gt;Java8也提供了Map和Filter函数用于转换和过滤对象，使开发变得更轻松，遥想当年在for循环里面加if语句。慢慢成了过去式。集合遍历之前先filter一下，已经成了我开发过程中不可或缺的一步。虽然 &lt;code&gt;filter&lt;/code&gt; 函数相对于Kotlin的 &lt;code&gt;getOrNull&lt;/code&gt; 和 &lt;code&gt;sortedBy&lt;/code&gt; 函数，并没有给人一种眼前一亮的感觉。但它提高了代码的可读性和美观性。&lt;/p&gt;
&lt;h3 id=&quot;常用函数-2&quot;&gt;常用函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;filter{...}&lt;/code&gt; : 过滤不满足条件的元素，返回只满足条件元素列表，不影响原集合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filterNot{...}&lt;/code&gt; : 和&lt;code&gt;filter{}&lt;/code&gt;函数的功能相反&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filterNotNull()&lt;/code&gt; : 过滤掉集合中为null的元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filterIndexed{...}&lt;/code&gt; : 在&lt;code&gt;filter{}&lt;/code&gt;函数上多了一个下标功能，可以通过索引进一步过滤&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Kotlin的函数是见名知意，非常好用，上手也快，弄明白一个方法，其他方法都没大的问题&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;distinct()&lt;/code&gt; : 去除重复元素，返回元素的顺序和原集合顺序一致&lt;/li&gt;
&lt;li&gt;&lt;code&gt;distinctBy{...}&lt;/code&gt; : 根据操作元素后的结果去去重，去除的是操作前的元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;take(num)&lt;/code&gt; : 返回集合中前num个元素组成的集合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;takeWhile{...}&lt;/code&gt; : 从第一个元素开始遍历集合，当出现第一个不满足条件元素时退出循环。返回所有满足条件的元素集合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;takeLast(num)&lt;/code&gt; : 和&lt;code&gt;take&lt;/code&gt; 函数相反，返回集合中后num个元素组成的集合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;takeLastWhile{...}&lt;/code&gt; : 从最后一个元素开始遍历集合，当出现第一个不满足条件元素时退出循环。返回所有满足条件的元素集合&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要被这么多方法吓到，学了take函数的用法，takeLast、drop、dropLast的用法都可以猜到&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;drop(num)&lt;/code&gt; : 过滤集合中前num个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dropWhile{...}&lt;/code&gt; : 和执行&lt;code&gt;takeWhile{...}&lt;/code&gt;函数后得到的结果相反&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dropLast(num)&lt;/code&gt; : 过滤集合中后num个元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dropLastWhile{...}&lt;/code&gt; : 和执行&lt;code&gt;takeLastWhile{...}&lt;/code&gt;函数后得到的结果相反&lt;/li&gt;
&lt;li&gt;&lt;code&gt;slice(...)&lt;/code&gt; : 过滤掉所有不满足执行下标的元素。参数是下标集合或者是下标区间。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用建议-2&quot;&gt;使用建议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;以上Filter、Distinct、Take、Drop、Slice方法都返回一个处理后的新集合，不影响原集合&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Kotlin提供了丰富的函数供我们使用，同时也吓退了很多朋友，别怕！&lt;strong&gt;Kotlin的函数都是买一送一的，学会一个，不愁另一个&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;基础用法-2&quot;&gt;基础用法&lt;/h3&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;val list = listOf(-3,-2,1,3,5,3,7,2,10,9)
println(&quot;filter : ${list.filter { it &amp;gt; 1 }}&quot;)
println(&quot;filterIndexed : ${list.filterIndexed { index, result -&amp;gt;
        index % 2 == 0 &amp;amp;&amp;amp; result &amp;gt; 5
        }}&quot;)
println(&quot;take : ${list.take(5)}&quot;)
println(&quot;takeWhile : ${list.takeWhile { it &amp;lt; 5 }}&quot;)
println(&quot;drop : ${list.drop(5)}&quot;)
println(&quot;distinct : ${list.distinct()}&quot;)
println(&quot;distinctBy : ${list.distinctBy { it % 2 }}&quot;)
println(&quot;slice : ${list.slice(IntRange(1,5))}&quot;)
-----------------------------------------------------
filter : [3, 5, 3, 7, 2, 10, 9]
filterIndexed : [7, 10]
take : [-3, -2, 1, 3, 5]
takeWhile : [-3, -2, 1, 3]
drop : [3, 7, 2, 10, 9]
distinct : [-3, -2, 1, 3, 5, 7, 2, 10, 9]
distinctBy : [-3, -2, 1]
slice : [-2, 1, 3, 5, 3]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;统计元素&quot;&gt;统计元素&lt;/h2&gt;
&lt;p&gt;在用Java8和Kotlin之前。和排序一样，在实现求最大值、平均值、求和等操作时，都要写很多冗余的代码。现在好了，Kotlin已经封装了这些方法。朋友们，&lt;strong&gt;千万不要过于依赖这些方法&lt;/strong&gt;。有些一条sql能解决的问题，就不要把统计的逻辑留给代码完成。这里的方法更适合在业务处理过程中，对一些简单集合的统计处理。如果是统计报表的功能，就不要有什么歪心思了。分享一篇关于统计的文章：&lt;a href=&quot;https://www.cnblogs.com/itdragon/p/9372229.html&quot;&gt;常见的统计解决方案&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;常用函数-3&quot;&gt;常用函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;max()&lt;/code&gt; : 获取集合中最大的元素，若为空元素集合，则返回null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;maxBy{...}&lt;/code&gt; : 获取方法处理后返回结果最大值对应那个元素的初始值，如果没有则返回null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;min()&lt;/code&gt; : 获取集合中最小的元素，若为空元素集合，则返回null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minBy{...}&lt;/code&gt; : 获取方法处理后返回结果最小值对应那个元素的初始值，如果没有则返回null&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sum()&lt;/code&gt; : 对集合原元素数据进行累加，返回值类型是Int&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sumBy{...}&lt;/code&gt; : 根据元素运算操作后的结果进行累加，返回值类型是Int&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sumByDouble{...}&lt;/code&gt; : 和&lt;code&gt;sumBy{}&lt;/code&gt;相似，但返回值类型是Double&lt;/li&gt;
&lt;li&gt;&lt;code&gt;average()&lt;/code&gt; : 对集合求平均数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reduce{...}&lt;/code&gt; : 从集合中的第一个元素到最后一个元素的累计操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reduceIndexed{...}&lt;/code&gt; : 在&lt;code&gt;reduce{}&lt;/code&gt;函数基础上多了一个下标功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reduceRight{...}&lt;/code&gt; : 与&lt;code&gt;reduce{...}&lt;/code&gt; 相反，该方法是从最后一个元素开始&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reduceRightIndexed{...}&lt;/code&gt; : 在&lt;code&gt;reduceRight{}&lt;/code&gt;函数基础上多了一个下标功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fold{...}&lt;/code&gt; : 和&lt;code&gt;reduce{}&lt;/code&gt;类似，但是&lt;code&gt;fold{}&lt;/code&gt;有一个初始值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;foldIndexed{...}&lt;/code&gt; : 和&lt;code&gt;reduceIndexed{}&lt;/code&gt;类似，但是&lt;code&gt;foldIndexed{}&lt;/code&gt;有一个初始值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;foldRight{...}&lt;/code&gt; : 和&lt;code&gt;reduceRight{}&lt;/code&gt;类似，但是&lt;code&gt;foldRight{}&lt;/code&gt;有一个初始值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;foldRightIndexed{...}&lt;/code&gt; : 和&lt;code&gt;reduceRightIndexed{}&lt;/code&gt;类似，但是&lt;code&gt;foldRightIndexed{}&lt;/code&gt;有一个初始值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;any{...}&lt;/code&gt; : 判断集合中是否存在满足条件的元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;all{...}&lt;/code&gt; : 判断集合中的所有元素是否都满足条件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;none{...}&lt;/code&gt; : 和&lt;code&gt;all{...}&lt;/code&gt;函数的作用相反&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用建议-3&quot;&gt;使用建议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;不能过于依赖Kotlin的统计方法，这些方法更适合一些业务逻辑上的简单统计处理&lt;/strong&gt;，不适合数据统计功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意sum函数返回结果是Int类型&lt;/strong&gt;，如果是Double则需要用sumByDouble方法。&lt;/p&gt;
&lt;h3 id=&quot;基础用法-3&quot;&gt;基础用法&lt;/h3&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;val persons = mutableListOf(Person(&quot;n1&quot;, 20, 2000.0),
    Person(&quot;n2&quot;, 24, 4000.0),
    Person(&quot;n3&quot;, 28, 6000.0),
    Person(&quot;n4&quot;, 26, 8000.0),
    Person(&quot;n5&quot;, 34, 7000.0),
    Person(&quot;n6&quot;, 44, 5000.0))
println(&quot;maxBy : ${persons.maxBy { it.age }}&quot;)
println(&quot;sumByDouble : ${persons.sumByDouble { it.salary }}&quot;)
println(&quot;average : ${persons.map { it.salary }.average()}&quot;)
println(&quot;any : ${persons.any { it.salary &amp;lt; 1000 }}&quot;)
-----------------------------------------------------
maxBy : Person(name=n6, age=44, salary=5000.0)
sumByDouble : 32000.0
average : 5333.333333333333
any : false&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;元素映射&quot;&gt;元素映射&lt;/h2&gt;
&lt;p&gt;Kotlin提供了一个遍历集合的forEach方法，也提供了对集合每个元素都进行指定操作并返回一个新集合的map方法。map方法是可以遍历集合，但如果误将其认为遍历集合的方法，同样会将mapNotNull方法误以为成遍历非null元素的方法。&lt;/p&gt;
&lt;h3 id=&quot;常用方法&quot;&gt;常用方法&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;map{...}&lt;/code&gt; : 把每个元素按照特定的方法进行转换，并返回一个新的集合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mapNotNull{...}&lt;/code&gt; : 同&lt;code&gt;map{}&lt;/code&gt;相同，过滤掉转换之后为null的元素&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mapIndexed{index,result}&lt;/code&gt; : 在&lt;code&gt;map{}&lt;/code&gt; 函数上多了一个下标功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mapIndexedNotNull{index,result}&lt;/code&gt; : 在&lt;code&gt;mapNotNull{}&lt;/code&gt;函数上多了一个下标功能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flatMap{...}&lt;/code&gt; : 根据条件合并两个集合，组成一个新的集合&lt;/li&gt;
&lt;li&gt;&lt;code&gt;groupBy{...}&lt;/code&gt; : 分组。即根据条件把集合拆分为为一个&lt;code&gt;Map&amp;lt;K,List&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt;类型的集合&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用建议-4&quot;&gt;使用建议&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;map方法不是集合遍历，集合遍历的方法是forEach&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;mapNotNull方法不是遍历集合不为null的方法，而是过滤转换后为null的元素&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;调用string.split()函数，无论用forEach还是map，即使没有内容还是会遍历一次&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;基础用法-4&quot;&gt;基础用法&lt;/h3&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;val list = listOf(-3,-2,1,3,5,3,7,2,10,9)
list.map { it + 1 }.forEach { print(&quot;$it \t&quot;) }
list.mapIndexedNotNull { index, value -&amp;gt;
       if (index % 2 == 0) value else null
}.forEach { print(&quot;$it \t&quot;) }
println(&quot;flatMap : ${list.flatMap { listOf(it, it + 1,&quot;n$it&quot;) }}&quot;)
println(&quot;groupBy : ${list.groupBy { if (it % 2 == 0) &quot;偶数&quot; else &quot;奇数&quot; }}&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;集合的交差并补操作&quot;&gt;集合的交差并补操作&lt;/h2&gt;
&lt;p&gt;对集合的求交差集是一个常用的方法。比如前端需要将更新，创建，删除的逻辑用一个接口完成。我们可以通过旧数据与新数据求差集找出需要删除的数据。通过新数据和旧数据求差集找出需要创建的数据。通过求交集找出需要更新的数据。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;intersect(...)&lt;/code&gt; : 返回一个集合，其中包含此集合和指定集合所包含的所有元素，交集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subtract(...)&lt;/code&gt; : 返回一个集合，其中包含此数组包含但未包含在指定集合中的所有元素，差集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;union(...)&lt;/code&gt; : 返回包含两个集合中所有不同元素的集合，并集&lt;/li&gt;
&lt;li&gt;&lt;code&gt;minus(...)&lt;/code&gt; : 返回包含原始集合的所有元素的列表，但给定的数组中包含的元素除外，补集&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;基础用法-5&quot;&gt;基础用法&lt;/h3&gt;
&lt;pre class=&quot;kotlin&quot;&gt;
&lt;code&gt;val list1 = mutableListOf(1,2,3,4,5)
val list2 = mutableListOf(4,5,6,7)
println(&quot;intersect : ${list1.intersect(list2)}&quot;)
println(&quot;subtract : ${list1.subtract(list2)}&quot;)
println(&quot;union : ${list1.union(list2)}&quot;)
println(&quot;minus : ${list1.minus(list2)}&quot;)
-----------------------------------------------------
intersect : [4, 5]
subtract : [1, 2, 3]
union : [1, 2, 3, 4, 5, 6, 7]
minus : [1, 2, 3]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;官网地址：&lt;a href=&quot;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/&quot; class=&quot;uri&quot;&gt;https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;到这里文章就结束了。如果用好集合的高阶函数，可以让我们的开发效率有明显的提高，bug的数量也会锐减。文章还有一部分内容没有介绍。我在工作用中集合就用MutableList、MutableSet、MutableMap，可Java中还有ArrayList，LinkedList，HashMap，HashSet等集合Kotlin中也有这些。一直都没有好好研究，这个坑先挖好，后来再补上。&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 14:58:00 +0000</pubDate>
<dc:creator>ITDragon龙</dc:creator>
<og:description>Kotlin的集合是让我为之心动的地方，丰富的高阶函数帮助我们高效开发。今天介绍Kotlin的基础集合用法、获取集合元素的函数、过滤元素的函数、元素排序的函数、元素统计的函数、集合元素映射的函数、集合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itdragon/p/10887579.html</dc:identifier>
</item>
<item>
<title>四个类搞定分层自动化测试框架 - Refain</title>
<link>http://www.cnblogs.com/longronglang/p/10887442.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longronglang/p/10887442.html</guid>
<description>&lt;h3&gt;写在前面&lt;/h3&gt;
&lt;p&gt;我们刚开始做自动化测试，可能写的代码都是基于原生写的代码，看起来特别不美观，而且感觉特别生硬。&lt;/p&gt;
&lt;p&gt;来看下面一段代码：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190518224509686-1914060077.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体表现如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;driver对象在测试类中显示&lt;/li&gt;
&lt;li&gt;定位元素的value值在测试类中显示&lt;/li&gt;
&lt;li&gt;定位元素的方式在测试类中显示&lt;/li&gt;
&lt;li&gt;线程方式硬等待sleep几秒&lt;/li&gt;
&lt;li&gt;代码一报错，还要去测试类里面找是哪段代码报错，当代吗行数好多时，不好定位&lt;/li&gt;
&lt;li&gt;好多测试脚本组装批量执行后，报错后，定位问题，很吃力&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有命中的小伙伴嘛，有的话，请在文末下方留言，其他现象就不一一列举了。&lt;/p&gt;
&lt;h3&gt;为什么要写框架？&lt;/h3&gt;
&lt;p&gt;从个人方面来说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;逼格高，让别人感觉你好厉害，技术强&lt;/li&gt;
&lt;li&gt;面试是加分项，会写框架，可以作为谈资硬性指标&lt;/li&gt;
&lt;li&gt;一个组内，要是妹纸多，你可以秀技能，吸引妹纸也说不定呢&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从实际方面来说：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;好的测试框架，可以稳定性，健壮性强，可降低代码维护成本&lt;/li&gt;
&lt;li&gt;方便定位问题，失败定位问题会比较方便&lt;/li&gt;
&lt;li&gt;可以提升测试效率，编写脚本成本，拿来就用，直接点方法就行&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;如何编写框架&lt;/h3&gt;
&lt;p&gt;下面我们将进入大家都比较关注的话题了，这里我只分享思路哈，跟上步伐，别掉队哦，&lt;/p&gt;
&lt;p&gt;看我如何四个类搞定测试框架的&lt;/p&gt;
&lt;p&gt;其实就是体现在封装上，先说下要封装的部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;driver.findElement()&lt;/li&gt;
&lt;li&gt;By.xpath() ，即用什么方式定位&lt;/li&gt;
&lt;li&gt;driver.get()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;好了，那么现在我们开始，部分代码我会附截图，开始了&lt;/p&gt;
&lt;p&gt;整体工程如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190518221135930-239438548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;1、日志部分&lt;/h4&gt;
&lt;p&gt;log4j详细配置，百度就好了，这里不做介绍&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190518213356954-1904936812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2、数据源设计&lt;/h4&gt;
&lt;p&gt;一般书上流行的Excel，我肯定是不用的，至于为什么，私聊我即可，这只提供思路，数据源如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190518213908549-1036811039.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3、解析Excel类&lt;/h4&gt;
&lt;p&gt; 第一个类，解析数据源，返回元素对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190518214757347-2076819696.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190518215004196-2036432565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;4、页面api部分&lt;/h4&gt;
&lt;p&gt; 第二个类，页面api操作&lt;/p&gt;
&lt;p&gt;元素和定位方式的分离&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190518215343685-372003141.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; api部分截图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190518215944578-730862539.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 5、页面对象&lt;/p&gt;
&lt;p&gt;第三个类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190518220153763-1280596727.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;6、读取配置文件信息&lt;/h4&gt;
&lt;p&gt;第四个类，获取配置文件信息&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190518220612752-1452237766.png&quot; alt=&quot;&quot; width=&quot;884&quot; height=&quot;613&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;7、测试类如下&lt;/h4&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190518221226213-583432665.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;8、运行效果&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/718867/201905/718867-20190518222612581-637592340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;看上去是不是很整洁呢，还不动手试试！！&lt;/p&gt;

</description>
<pubDate>Sat, 18 May 2019 14:27:00 +0000</pubDate>
<dc:creator>Refain</dc:creator>
<og:description>写在前面 我们刚开始做自动化测试，可能写的代码都是基于原生写的代码，看起来特别不美观，而且感觉特别生硬。 来看下面一段代码： 具体表现如下： driver对象在测试类中显示 定位元素的value值在测</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longronglang/p/10887442.html</dc:identifier>
</item>
<item>
<title>Linux之facl----设置文件访问控制列表（详解） - 记忆流年</title>
<link>http://www.cnblogs.com/fengdejiyixx/p/10887223.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fengdejiyixx/p/10887223.html</guid>
<description>&lt;p id=&quot;setfacl&quot;&gt;&lt;span&gt;&lt;strong&gt;setfacl命令&lt;/strong&gt; 是用来在命令行里设置ACL（访问控制列表）&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;选项&quot;&gt;选项&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;-b,--remove-all：删除所有扩展的acl规则，基本的acl规则(所有者，群组，其他）将被保留。
-k,--remove-default：删除缺省的acl规则。如果没有缺省规则，将不提示。
-n，--no-mask：不要重新计算有效权限。setfacl默认会重新计算ACL mask，除非mask被明确的制定。
--mask：重新计算有效权限，即使ACL mask被明确指定。
&lt;span class=&quot;hljs-_&quot;&gt;-d，--default：设定默认的acl规则。
--restore=file：从文件恢复备份的acl规则（这些文件可由getfacl -R产生）。通过这种机制可以恢复整个目录树的acl规则。此参数不能和除--test以外的任何参数一同执行。
--test：测试模式，不会改变任何文件的acl规则，操作后的acl规格将被列出。
-R，--recursive：递归的对所有文件及目录进行操作。
-L，--logical：跟踪符号链接，默认情况下只跟踪符号链接文件，跳过符号链接目录。
-P，--physical：跳过所有符号链接，包括符号链接文件。
--version：输出setfacl的版本号并退出。
--help：输出帮助信息。
--：标识命令行参数结束，其后的所有参数都将被认为是文件名
-：如果文件名是-，则setfacl将从标准输入读取文件名。
&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;选项&lt;code&gt;-m&lt;/code&gt;和&lt;code&gt;-x&lt;/code&gt;后边跟以acl规则。多条acl规则以逗号(,)隔开。选项&lt;code&gt;-M&lt;/code&gt;和&lt;code&gt;-X&lt;/code&gt;用来从文件或标准输入读取acl规则。&lt;/li&gt;
&lt;li&gt;选项&lt;code&gt;--set&lt;/code&gt;和&lt;code&gt;--set-file&lt;/code&gt;用来设置文件或目录的acl规则，先前的设定将被覆盖。&lt;/li&gt;
&lt;li&gt;选项&lt;code&gt;-m(--modify)&lt;/code&gt;和&lt;code&gt;-M(--modify-file)&lt;/code&gt;选项修改文件或目录的acl规则。&lt;/li&gt;
&lt;li&gt;选项&lt;code&gt;-x(--remove)&lt;/code&gt;和&lt;code&gt;-X(--remove-file)&lt;/code&gt;选项删除acl规则。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当使用-M，-X选项从文件中读取规则时，setfacl接受getfacl命令输出的格式。每行至少一条规则，以#开始的行将被视为注释。&lt;/p&gt;
&lt;p&gt;当在不支持ACLs的文件系统上使用setfacl命令时，setfacl将修改文件权限位。如果acl规则并不完全匹配文件权限位，setfacl将会修改文件权限位使其尽可能的反应acl规则，并会向standard error发送错误消息，以大于0的状态返回。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;权限&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;文件的所有者以及有&lt;code&gt;CAP_FOWNER&lt;/code&gt;的用户进程可以设置一个文件的acl。（在目前的linux系统上，root用户是唯一有&lt;code&gt;CAP_FOWNER&lt;/code&gt;能力的用户）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACL规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;setfacl命令可以识别以下的规则格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[d[efault]:] [u[ser]:]uid [:perms]  指定用户的权限，文件所有者的权限（如果uid没有指定）。
[d[efault]:] g[roup]:gid [:perms]   指定群组的权限，文件所有群组的权限（如果gid未指定）
[d[efault]:] m[ask][:] [:perms]     有效权限掩码
[d[efault]:] o[ther] [:perms]       其他的权限
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;恰当的acl规则被用在修改和设定的操作中，对于uid和gid，可以指定一个数字，也可指定一个名字。perms域是一个代表各种权限的字母的组合：读&lt;code&gt;-r&lt;/code&gt;写&lt;code&gt;-w&lt;/code&gt;执行&lt;code&gt;-x&lt;/code&gt;，执行只适合目录和一些可执行的文件。pers域也可设置为八进制格式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动创建的规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最初的，文件目录仅包含3个基本的acl规则。为了使规则能正常执行，需要满足以下规则。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;3个基本规则不能被删除。&lt;/li&gt;
&lt;li&gt;任何一条包含指定的用户名或群组名的规则必须包含有效的权限组合。&lt;/li&gt;
&lt;li&gt;任何一条包含缺省规则的规则在使用时，缺省规则必须存在。
&lt;p&gt;&lt;strong&gt;ACL的名词定义&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;先来看看在ACL里面每一个名词的定义，这些名词我大多从man page上摘下来虽然有些枯燥,但是对于理解下面的内容还是很有帮助的。&lt;/p&gt;
&lt;p&gt;ACL是由一系列的Access Entry所组成的，每一条Access Entry定义了特定的类别可以对文件拥有的操作权限。Access Entry有三个组成部分：Entry tag type, qualifier (optional), permission。&lt;/p&gt;
&lt;p&gt;我们先来看一下最重要的Entry tag type，它有以下几个类型：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ACL_USER_OBJ：相当于Linux里file_owner的permission
ACL_USER：定义了额外的用户可以对此文件拥有的permission
ACL_GROUP_OBJ：相当于Linux里group的permission
ACL_GROUP：定义了额外的组可以对此文件拥有的permission
ACL_MASK：定义了ACL_USER, ACL_GROUP_OBJ和ACL_GROUP的最大权限 (这个我下面还会专门讨论)
ACL_OTHER：相当于Linux里other的permission
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们来据个例子说明一下，下面我们就用getfacl命令来查看一个定义好了的ACL文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前面三个以#开头的定义了文件名，file owner和group。这些信息没有太大的作用，接下来我们可以用&lt;code&gt;--omit-header&lt;/code&gt;来省略掉。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user::rw-       定义了ACL_USER_OBJ, 说明file owner拥有&lt;span class=&quot;hljs-built_in&quot;&gt;read and write permission
user:john:rw-   定义了ACL_USER,这样用户john就拥有了对文件的读写权限,实现了我们一开始要达到的目的
group::rw-      定义了ACL_GROUP_OBJ,说明文件的group拥有&lt;span class=&quot;hljs-built_in&quot;&gt;read and write permission
group:dev:r--   定义了ACL_GROUP,使得dev组拥有了对文件的&lt;span class=&quot;hljs-built_in&quot;&gt;read permission
mask::rw-       定义了ACL_MASK的权限为&lt;span class=&quot;hljs-built_in&quot;&gt;read and write
other::r--      定义了ACL_OTHER的权限为&lt;span class=&quot;hljs-built_in&quot;&gt;read
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这里我们就可以看出ACL提供了我们可以定义特定用户和用户组的功能，那么接下来我们就来看一下如何设置一个文件的ACL：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如何设置ACL文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先我们还是要讲一下设置ACL文件的格式，从上面的例子中我们可以看到每一个Access Entry都是由三个被：号分隔开的字段所组成，第一个就是Entry tag type。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;user   对应了ACL_USER_OBJ和ACL_USER
group  对应了ACL_GROUP_OBJ和ACL_GROUP
mask   对应了ACL_MASK
other  对应了ACL_OTHER
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个字段称之为qualifier，也就是上面例子中的john和dev组，它定义了特定用户和拥护组对于文件的权限。这里我们也可以发现只有user和group才有qualifier，其他的都为空。第三个字段就是我们熟悉的permission了。它和Linux的permission一样定义，这里就不多讲了。&lt;/p&gt;
&lt;p&gt;下面我们就来看一下怎么设置test.txt这个文件的ACL让它来达到我们上面的要求。&lt;/p&gt;
&lt;p&gt;一开始文件没有ACL的额外属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们先让用户john拥有对test.txt文件的读写权限：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时我们就可以看到john用户在ACL里面已经拥有了对文件的读写权。这个时候如果我们查看一下linux的permission我们还会发现一个不一样的地方。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在文件permission的最后多了一个+号，当任何一个文件拥有了ACL_USER或者ACL_GROUP的值以后我们就可以称它为ACL文件，这个+号就是用来提示我们的。我们还可以发现当一个文件拥有了&lt;code&gt;ACL_USER&lt;/code&gt;或者&lt;code&gt;ACL_GROUP&lt;/code&gt;的值时&lt;code&gt;ACL_MASK&lt;/code&gt;同时也会被定义。&lt;/p&gt;
&lt;p&gt;接下来我们来设置dev组拥有read permission：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里就完成了我们上面讲到的要求，是不是很简单呢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACL_MASK和Effective permission&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里需要重点讲一下&lt;code&gt;ACL_MASK&lt;/code&gt;，因为这是掌握ACL的另一个关键，在Linux file permission里面大家都知道比如对于&lt;code&gt;rw-rw-r--&lt;/code&gt;来说, 当中的那个&lt;code&gt;rw-&lt;/code&gt;是指文件组的permission. 但是在ACL里面这种情况只是在&lt;code&gt;ACL_MASK&lt;/code&gt;不存在的情况下成立。如果文件有ACL_MASK值，那么当中那个&lt;code&gt;rw-&lt;/code&gt;代表的就是mask值而不再是group permission了。&lt;/p&gt;
&lt;p&gt;让我们来看下面这个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里说明test.sh文件只有file owner: root拥有read, write, execute/search permission。admin组只有read and write permission，现在我们想让用户john也对test.sh具有和root一样的permission。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们看到john已经拥有了rwx的permission，mask值也被设定为rwx，那是因为它规定了&lt;code&gt;ACL_USER&lt;/code&gt;，&lt;code&gt;ACL_GROUP&lt;/code&gt;和&lt;code&gt;ACL_GROUP_OBJ&lt;/code&gt;的最大值，现在我们再来看test.sh的Linux permission，它已经变成了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么如果现在admin组的用户想要执行test.sh的程序会发生什么情况呢？它会被permission deny。原因在于实际上admin组的用户只有read and write permission，这里当中显示的rwx是&lt;code&gt;ACL_MASK&lt;/code&gt;的值而不是group的permission。&lt;/p&gt;
&lt;p&gt;所以从这里我们就可以知道，如果一个文件后面有+标记，我们都需要用getfacl来确认它的permission，以免发生混淆。&lt;/p&gt;
&lt;p&gt;下面我们再来继续看一个例子，假如现在我们设置test.sh的mask为read only，那么admin组的用户还会有write permission吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候我们可以看到ACL_USER和ACL_GROUP_OBJ旁边多了个#effective:r–，这是什么意思呢？让我们再来回顾一下&lt;code&gt;ACL_MASK&lt;/code&gt;的定义。它规定了&lt;code&gt;ACL_USER&lt;/code&gt;，&lt;code&gt;ACL_GROUP_OBJ&lt;/code&gt;和&lt;code&gt;ACL_GROUP&lt;/code&gt;的最大权限。那么在我们这个例子中他们的最大权限也就是read only。虽然我们这里给&lt;code&gt;ACL_USER&lt;/code&gt;和&lt;code&gt;ACL_GROUP_OBJ&lt;/code&gt;设置了其他权限，但是他们真正有效果的只有read权限。&lt;/p&gt;
&lt;p&gt;这时我们再来查看test.sh的Linux file permission时它的group permission也会显示其mask的值(i.e. r–)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Default ACL&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面我们所有讲的都是Access ACL，也就是对文件而言。下面我简单讲一下Default ACL。Default ACL是指对于一个目录进行Default ACL设置，并且在此目录下建立的文件都将继承此目录的ACL。&lt;/p&gt;
&lt;p&gt;同样我们来做一个试验说明，比如现在root用户建立了一个dir目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;他希望所有在此目录下建立的文件都可以被john用户所访问，那么我们就应该对dir目录设置Default ACL。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们可以看到ACL定义了default选项，john用户拥有了default的read, write, excute/search permission。所有没有定义的default都将从file permission里copy过来，现在root用户在dir下建立一个test.txt文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@localhost ~]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们看到在dir下建立的文件john用户自动就有了read and write permission，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ACL相关命令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面的例子中我们都注意到了getfacl命令是用来读取文件的ACL，setfacl是用来设定文件的Acess ACL。这里还有一个chacl是用来改变文件和目录的Access ACL and Default ACL，它的具体参数大家可以去看man page。我只想提及一下&lt;code&gt;chacl -B&lt;/code&gt;。它可以彻底删除文件或者目录的ACL属性(包括Default ACL)，比如你即使用了&lt;code&gt;setfacl -x&lt;/code&gt;删除了所有文件的ACL属性，那个+号还是会出现在文件的末尾，所以正确的删除方法应该是用&lt;code&gt;chacl -B&lt;/code&gt;用cp来复制文件的时候我们现在可以加上&lt;code&gt;-p&lt;/code&gt;选项。这样在拷贝文件的时候也将拷贝文件的ACL属性，对于不能拷贝的ACL属性将给出警告。&lt;/p&gt;
&lt;p&gt;mv命令将会默认地移动文件的ACL属性，同样如果操作不允许的情况下会给出警告。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需要注意的几点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你的文件系统不支持ACL的话，你也许需要重新mount你的file system：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mount -o remount, acl [mount point]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果用chmod命令改变Linux file permission的时候相应的ACL值也会改变，反之改变ACL的值，相应的file permission也会改变。&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 13:43:00 +0000</pubDate>
<dc:creator>记忆流年</dc:creator>
<og:description>setfacl命令 是用来在命令行里设置ACL（访问控制列表） 选项 选项-m和-x后边跟以acl规则。多条acl规则以逗号(,)隔开。选项-M和-X用来从文件或标准输入读取acl规则。 选</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fengdejiyixx/p/10887223.html</dc:identifier>
</item>
<item>
<title>Vue+Electron下Vuex的Dispatch没有效果的解决方案 - jxtxzzw</title>
<link>http://www.cnblogs.com/jxtxzzw/p/10887180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jxtxzzw/p/10887180.html</guid>
<description>&lt;div class=&quot;markdown-here-wrapper&quot; data-md-url=&quot;https://i.cnblogs.com/EditPosts.aspx?opt=1&quot; readability=&quot;77.474087426769&quot;&gt;
&lt;p&gt;&lt;strong&gt;这个问题是解决基于 vue 和 electron 的开发中使用 vuex 的 dispatch 无效的问题，即解决了 &lt;code&gt;Please, don't use direct commit's, use dispatch instead of this.&lt;/code&gt; 问题。&lt;/strong&gt;&lt;br/&gt;先允许我梳理一下目录结构，以便阅读的时候不会一头雾水，你到底说的这个文件是哪个……&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1558185192156.png&quot; alt=&quot;1558185192156&quot;/&gt;&lt;br/&gt;其中 &lt;code&gt;/src/main&lt;/code&gt; 是存放主配置文件的，&lt;code&gt;/src/render&lt;/code&gt; 下面有 &lt;code&gt;store&lt;/code&gt;、&lt;code&gt;router&lt;/code&gt;、&lt;code&gt;components&lt;/code&gt; 等。&lt;br/&gt;&lt;code&gt;components&lt;/code&gt; 下面就是很多 &lt;code&gt;.vue&lt;/code&gt; 文件，&lt;code&gt;router&lt;/code&gt; 下面就是一些路由配置的 &lt;code&gt;js&lt;/code&gt; 文件和一些拦截器的 &lt;code&gt;js&lt;/code&gt;。&lt;br/&gt;关键是 &lt;code&gt;store&lt;/code&gt;，&lt;code&gt;store&lt;/code&gt; 下面有一个 &lt;code&gt;index.js&lt;/code&gt; 的主配置文件 &lt;code&gt;index.js&lt;/code&gt;，和一个 &lt;code&gt;modules&lt;/code&gt; 文件夹。&lt;br/&gt;&lt;code&gt;index.js&lt;/code&gt; 里面写的是（记住这句话，后面会用到）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-js&quot;&gt;import Vue from &lt;span class=&quot;hljs-string&quot;&gt;'vue'&lt;/span&gt;
import Vuex from &lt;span class=&quot;hljs-string&quot;&gt;'vuex'&lt;/span&gt;
import { createPersistedState, createSharedMutations } from &lt;span class=&quot;hljs-string&quot;&gt;'vuex-electron'&lt;/span&gt;
import modules from &lt;span class=&quot;hljs-string&quot;&gt;'./modules'&lt;/span&gt;
Vue.use(Vuex)
export &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Vuex.Store({
  modules,
  plugins: [
    createPersistedState(),
    createSharedMutations()
  ],
  strict: process.env.NODE_ENV !== &lt;span class=&quot;hljs-string&quot;&gt;'production'&lt;/span&gt;
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而 &lt;code&gt;modules/&lt;/code&gt; 下面存放各个实体，例如上图中的 &lt;code&gt;Auth.js&lt;/code&gt; 和 &lt;code&gt;Counter.js&lt;/code&gt;，并通过 &lt;code&gt;index.js&lt;/code&gt; 全部引入。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-js&quot;&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; files = &lt;span class=&quot;hljs-built_in&quot;&gt;require&lt;/span&gt;.context(&lt;span class=&quot;hljs-string&quot;&gt;'.'&lt;/span&gt;, &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;, &lt;span class=&quot;hljs-regexp&quot;&gt;/\.js$/&lt;/span&gt;)
&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; modules = {}
files.keys().forEach(key =&amp;gt; {
  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (key === &lt;span class=&quot;hljs-string&quot;&gt;'./index.js'&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;
  modules[key.replace(&lt;span class=&quot;hljs-regexp&quot;&gt;/(\.\/|\.js)/g&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;''&lt;/span&gt;)] = files(key).default
})
export &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; modules
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后来看一个 vuex 的官方样例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-js&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; state = {
  main: &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
}
&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; mutations = {
  DECREMENT_MAIN_COUNTER (state) {
    state.main--
  },
  INCREMENT_MAIN_COUNTER (state) {
    state.main++
  }
}
&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; actions = {
  someAsyncTask ({ commit }) {
    
    commit(&lt;span class=&quot;hljs-string&quot;&gt;'INCREMENT_MAIN_COUNTER'&lt;/span&gt;)
  }
}
export &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; {
  state,
  mutations,
  actions
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后很显然的，我想要在 Vue 的组件调用 &lt;code&gt;INCREMENT_MAIN_COUNTER&lt;/code&gt; 对计数器加 1。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-js&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.$store.commit(&lt;span class=&quot;hljs-string&quot;&gt;'INCREMENT_MAIN_COUNTER'&lt;/span&gt;);

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是一般的 vue，就 OK 了，但是，我遇到了报错，说，&lt;code&gt;Please, don't use direct commit's, use dispatch instead of this.&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1558184959796.png&quot; alt=&quot;1558184959796&quot;/&gt;&lt;br/&gt;那好吧，没事，不就是不然用 Commit，非要用 Dispatch 嘛，那我就写一个 Action，里面直接调用 Mutation，就像这个样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-js&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;const&lt;/span&gt; actions = {
  JUST_INCREASE ({ commit }) {
    commit(&lt;span class=&quot;hljs-string&quot;&gt;'INCREMENT_MAIN_COUNTER'&lt;/span&gt;)
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而奇怪的事情是，&lt;code&gt;this.$store.dispatch('JUST_INCREASE')&lt;/code&gt; 并不能运行，没反应，计数器还是 0，不能赋值，就像是这个函数没有被执行一样。没有报错，没有任何异常，查也查不出什么问题。&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1558184998501.png&quot; alt=&quot;1558184998501&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1558184982642.png&quot; alt=&quot;1558184982642&quot;/&gt;&lt;br/&gt;网上的资料似乎也挺少。&lt;br/&gt;折腾了很久，后来发现是 vuex-electron 里面一个插件的锅。&lt;br/&gt;解决方法有两个。&lt;br/&gt;方法一：&lt;br/&gt;在 &lt;code&gt;store/index.js&lt;/code&gt; 里面，就是上文特别强调了的那个文件，去掉 &lt;code&gt;createSharedMutations&lt;/code&gt; 插件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-js&quot;&gt;import Vue from &lt;span class=&quot;hljs-string&quot;&gt;'vue'&lt;/span&gt;
import Vuex from &lt;span class=&quot;hljs-string&quot;&gt;'vuex'&lt;/span&gt;
import { createPersistedState, createSharedMutations } from &lt;span class=&quot;hljs-string&quot;&gt;'vuex-electron'&lt;/span&gt;
import modules from &lt;span class=&quot;hljs-string&quot;&gt;'./modules'&lt;/span&gt;
Vue.use(Vuex)
export &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Vuex.Store({
  modules,
  plugins: [
    createPersistedState(),
    createSharedMutations() 
  ],
  strict: process.env.NODE_ENV !== &lt;span class=&quot;hljs-string&quot;&gt;'production'&lt;/span&gt;
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是因为 &lt;code&gt;vuex-electron&lt;/code&gt; 引入了一个用于多进程间共享 Vuex Store 的状态的插件。如果没有多进程交互的需求，完全可以&lt;strong&gt;不引入&lt;/strong&gt;这个插件。&lt;br/&gt;注释掉以后重启项目，用 &lt;code&gt;this.$store.commit('XXX')&lt;/code&gt; 就可以使用了。&lt;br/&gt;然而，如果需要多进程来处理怎么办？&lt;br/&gt;方法二：&lt;br/&gt;&lt;a href=&quot;https://github.com/vue-electron/vuex-electron#installation&quot;&gt;https://github.com/vue-electron/vuex-electron#installation&lt;/a&gt;&lt;br/&gt;看第 3 条：&lt;/p&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;In case if you enabled &lt;code&gt;createSharedMutations()&lt;/code&gt; plugin you need to create an instance of store in the main process. To do it just add this line into your main process (for example &lt;code&gt;src/main.js&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-js&quot;&gt;  import &lt;span class=&quot;hljs-string&quot;&gt;'./path/to/your/store'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种时候就不能用第一种方法来解决问题了。&lt;br/&gt;好在文档也说了，加上一行导入。&lt;br/&gt;找到 &lt;code&gt;/src/main/index.js&lt;/code&gt;，在前面加上一句：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs language-js&quot;&gt;import &lt;span class=&quot;hljs-string&quot;&gt;'../renderer/store'&lt;/span&gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1558185071126.png&quot; alt=&quot;1558185071126&quot;/&gt;&lt;br/&gt;之后一切正常，可以使用 Dispatch 来进行操作了。&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1558185678300.png&quot; alt=&quot;1558185678300&quot;/&gt;&lt;br/&gt;最后还有一个比较奇怪的问题：&lt;br/&gt;&lt;img src=&quot;https://dl.jxtxzzw.com/dl/attach/1558185917570.png&quot; alt=&quot;1558185917570&quot;/&gt;&lt;br/&gt;在直接调用 &lt;code&gt;state&lt;/code&gt; 的时候，这样写 &lt;code&gt;this.$store.state.loginStatus&lt;/code&gt; 是不行的，会 undefined，必须写成 &lt;code&gt;this.$store.state.Auth.loginStatus&lt;/code&gt;，就像是 &lt;code&gt;this.$store.state.Counter.main&lt;/code&gt; 一样，似乎可以解释为，不同的模块不指定名字的话就找不到。&lt;br/&gt;但是，在写 Dispatch 的时候又不需要指定名字了，直接 &lt;code&gt;dispatch('changeLoginStatus')&lt;/code&gt; 就行了，不然难道不应该是也按照 &lt;code&gt;dispatch('Auth/changeLoginStatus')&lt;/code&gt; 这样子来写嘛……&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Sat, 18 May 2019 13:32:00 +0000</pubDate>
<dc:creator>jxtxzzw</dc:creator>
<og:description>这个问题是解决基于 vue 和 electron 的开发中使用 vuex 的 dispatch 无效的问题，即解决了 Please, don't use direct commit's</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jxtxzzw/p/10887180.html</dc:identifier>
</item>
<item>
<title>Vue实现一个MarkDown编辑器 - 九路313</title>
<link>http://www.cnblogs.com/start1225/p/10887061.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/start1225/p/10887061.html</guid>
<description>&lt;p&gt;前段时间做项目的时候，需要一个Markdown编辑器，在网上找了一些开源的实现，但是都不满足需求&lt;br/&gt;说实话，这些开源项目也很难满足需求公司项目的需求，与其实现一个大而全的项目，倒不如实现一个&lt;br/&gt;简单的，易于在源码上修改的项目，核心功能都有的，以供修改使用&lt;br/&gt;本文的源码地址如下&lt;br/&gt;&lt;a href=&quot;https://github.com/jiulu313/HelloMarkDown&quot; class=&quot;uri&quot;&gt;https://github.com/jiulu313/HelloMarkDown&lt;/a&gt;&lt;br/&gt;喜欢的朋友可以帮忙star一下，欢迎交流学习&lt;/p&gt;
&lt;p&gt;先看一下本项目的效果图（图片经过压缩）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/594516/201905/594516-20190518210000803-1940997684.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;本文的目的就是实现一个有核心功能的，简单，易于修改的项目&lt;/strong&gt;&lt;br/&gt;话不多说，来看思路&lt;/p&gt;
&lt;h3 id=&quot;markdown内容如何转换成-html&quot;&gt;1 markdown内容如何转换成 html？&lt;/h3&gt;
&lt;p&gt;网上有一个开源的库叫 marked，地址如下：&lt;br/&gt;&lt;a href=&quot;https://github.com/markedjs/marked.git&quot; class=&quot;uri&quot;&gt;https://github.com/markedjs/marked.git&lt;/a&gt;&lt;br/&gt;我们可以安装这个库，使用很简单，就一个函数，传进去markdown内容，就返回了html内容&lt;/p&gt;
&lt;h3 id=&quot;markdown内容转换成了html如何进行语法高亮&quot;&gt;2 markdown内容转换成了html，如何进行语法高亮？&lt;/h3&gt;
&lt;p&gt;网上也有一个开源的库，地址如下 ：&lt;br/&gt;&lt;a href=&quot;https://highlightjs.org/&quot; class=&quot;uri&quot;&gt;https://highlightjs.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用这两个库&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先把markdown内容解析成html内容&lt;/li&gt;
&lt;li&gt;把html内容进行语法高亮&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们来一步一步实现代码&lt;/p&gt;
&lt;h3 id=&quot;代码实现&quot;&gt;3 代码实现&lt;/h3&gt;
&lt;p&gt;默认你已经创建好了vue的项目 ， 创建vue项目 &lt;code&gt;vue init webpack demo&lt;/code&gt;&lt;br/&gt;这里面不多讲。&lt;/p&gt;
&lt;p&gt;3.1 安装两个库，分别执行下面两条命令&lt;br/&gt;&lt;code&gt;npm install marked --save&lt;/code&gt;&lt;br/&gt;&lt;code&gt;npm install highlight.js --save&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3.2 首先创建一个 &lt;code&gt;HelloMarkDown&lt;/code&gt; 的 &lt;code&gt;Vue&lt;/code&gt;组件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;布局文件的代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;md_root_content&quot; v-bind:style=&quot;{width:this.width,height: this.height}&quot;&amp;gt;

    &amp;lt;!--功能按钮区--&amp;gt;
    &amp;lt;div class=&quot;button_bar&quot;&amp;gt;
      &amp;lt;span v-on:click=&quot;addBold&quot;&amp;gt;&amp;lt;B&amp;gt;B&amp;lt;/B&amp;gt;&amp;lt;/span&amp;gt;
      &amp;lt;span v-on:click=&quot;addUnderline&quot;&amp;gt;&amp;lt;B&amp;gt;U&amp;lt;/B&amp;gt;&amp;lt;/span&amp;gt;
      &amp;lt;span v-on:click=&quot;addItalic&quot;&amp;gt;&amp;lt;B&amp;gt;I&amp;lt;/B&amp;gt;&amp;lt;/span&amp;gt;
    &amp;lt;/div&amp;gt;

    &amp;lt;!--主要内容区--&amp;gt;
    &amp;lt;div class=&quot;content_bar&quot;&amp;gt;

      &amp;lt;!--markdown编辑器区--&amp;gt;
      &amp;lt;div class=&quot;markdown_body&quot;&amp;gt;
        &amp;lt;textarea ref=&quot;ref_md_edit&quot; class=&quot;md_textarea_content&quot; v-model=&quot;markString&quot;&amp;gt;
        &amp;lt;/textarea&amp;gt;
      &amp;lt;/div&amp;gt;

      &amp;lt;!--解析成html区--&amp;gt;
      &amp;lt;div class=&quot;html_body&quot;&amp;gt;
        &amp;lt;p v-html=&quot;htmlString&quot;&amp;gt;&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;

    &amp;lt;/div&amp;gt;

  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要分为上下两块，上面是功能区的布局&lt;br/&gt;下面一块，分左右两部分，左边是markdown，右边是显示html部分&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对应的样式代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;style scoped&amp;gt;

  .md_root_content {
    display: flex;
    display: -webkit-flex;
    flex-direction: column;
  }

  .button_bar {
    width: 100%;
    height: 40px;
    background-color: #d4d4d4;
    display: flex;
    display: -webkit-flex;
    align-items: center;
  }

  div.button_bar span {
    width: 30px;
    line-height: 40px;
    text-align: center;
    color: orange;
    cursor: pointer;
  }

  .content_bar {
    display: flex;
    display: -webkit-flex;
    width: 100%;
    height: 100%;
  }

  .markdown_body {
    width: 50%;
    height: 100%;
    display: flex;
    display: -webkit-flex;
  }

  .html_body {
    width: 50%;
    height: 100%;
    display: flex;
    display: -webkit-flex;
    background-color: #dfe9f1;
  }

  .md_textarea_content {
    flex: 1;
    height: 100%;
    padding: 12px;
    overflow: auto;
    box-sizing: border-box;
    resize: none;
    outline: none;
    border: none;
    background-color: #f4f4f4;
    font-size: 14px;
    color: #232323;
    line-height: 24px;
  }


&amp;lt;/style&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;业务逻辑部分的代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;script&amp;gt;
  import marked from 'marked'     //解析mardown语法的库
  import hljs from 'highlight.js' //对代码进行语法高亮的库


  import testData from '../testData'  //测试数据


  export default {
    name: &quot;HelloMarkDown&quot;,

    props: {
      width: {
        type: String,
        default: '1000px'
      },

      height: {
        type: String,
        default: '600px'
      }
    },

    data() {
      return {
        markString: '',
        htmlString: '',
      }
    },

    mounted(){
      this.markString = testData
    },

    methods: {
      //加粗
      addBold() {
        this.changeSelectedText(&quot;**&quot;,&quot;**&quot;)
      },

      //斜体
      addItalic() {
        this.changeSelectedText(&quot;***&quot;,&quot;***&quot;)
      },

      addUnderline() {
        this.changeSelectedText(&quot;&amp;lt;u&amp;gt;&quot;,&quot;&amp;lt;/u&amp;gt;&quot;)
      },

      changeSelectedText(startString,endString){
        let t = this.$refs.ref_md_edit
        if (window.getSelection) {
          if (t.selectionStart != undefined &amp;amp;&amp;amp; t.selectionEnd != undefined) {

            let str1 = t.value.substring(0, t.selectionStart)
            let str2 = t.value.substring(t.selectionStart, t.selectionEnd)
            let str3 = t.value.substring(t.selectionEnd)

            let result = str1 + startString + str2 + endString + str3
            t.value = result
            this.markString = t.value
          }
        }
      }
    },

    watch: {

      //监听markString变化
      markString: function (value) {
        marked.setOptions({
          renderer: new marked.Renderer(),
          gfm: true,
          tables: true,
          breaks: true,
          pedantic: false,
          sanitize: false,
          smartLists: true,
          smartypants: false
        })

        this.htmlString = marked(value)
      },

      //监听htmlString并对其高亮
      htmlString: function (value) {
        this.$nextTick(() =&amp;gt; {
          const codes = document.querySelectorAll(&quot;.html_body pre code&quot;);

          // elem 是一个 object
          codes.forEach(elem =&amp;gt; {
            elem.innerHTML = &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot; + elem.innerHTML.replace(/\n/g, &quot;\n&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;&quot;) + &quot;\n&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;
            hljs.highlightBlock(elem);
          });
        });
      }
    }

  }
&amp;lt;/script&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;script中的代码解释&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    props: {
      width: {
        type: String,
        default: '1000px'
      },

      height: {
        type: String,
        default: '600px'
      }
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;width: 组件的宽度&lt;br/&gt;height:组件的高度&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; data() {
      return {
        markString: '',
        htmlString: '',
      }
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;markString：保存我们输入的markdown内容&lt;br/&gt;htmlString：保存markdown内容转换成的html内容，也就是通过marked函数转换过来的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   mounted(){
      this.markString = testData
    },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显示默认数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   //加粗
      addBold() {
        this.changeSelectedText(&quot;**&quot;,&quot;**&quot;)
      },

      //斜体
      addItalic() {
        this.changeSelectedText(&quot;***&quot;,&quot;***&quot;)
      },

      //加下划线
      addUnderline() {
        this.changeSelectedText(&quot;&amp;lt;u&amp;gt;&quot;,&quot;&amp;lt;/u&amp;gt;&quot;)
      },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三个函数都是调用了 changeSelectedText 函数&lt;br/&gt;主要是对鼠标选中的内容进行改变，比如加粗效果，是在选中文本的两边分别添加 **&lt;/p&gt;
&lt;p&gt;所以changeSelectedText函数的作用就是在选中的文本两边添加不同的md的符号&lt;br/&gt;比如&lt;br/&gt;this.changeSelectedText(&quot;&lt;strong&gt;&quot;,&quot;&lt;/strong&gt;&quot;) ，就是在选中的文本左边和右边都添加**&lt;br/&gt;然后再把最新的内容赋值给 this.$refs.ref_md_edit.value，同时也两会给markString&lt;br/&gt;这样就可以做到选中文本加粗效果了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; //监听markString变化
      markString: function (value) {
        marked.setOptions({
          renderer: new marked.Renderer(),
          gfm: true,
          tables: true,
          breaks: true,
          pedantic: false,
          sanitize: false,
          smartLists: true,
          smartypants: false
        })

        this.htmlString = marked(value)
      },&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时是监听markString的变化&lt;br/&gt;然后调用marked函数进行转换成html内容，并赋值给htmlString&lt;br/&gt;marked.setOptions 是设置一些配置，有兴趣的可以查一下这些配置的作用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   //监听htmlString并对其高亮
      htmlString: function (value) {
        this.$nextTick(() =&amp;gt; {
          const codes = document.querySelectorAll(&quot;.html_body pre code&quot;);

          // elem 是一个 object
          codes.forEach(elem =&amp;gt; {
            elem.innerHTML = &quot;&amp;lt;ul&amp;gt;&amp;lt;li&amp;gt;&quot; + elem.innerHTML.replace(/\n/g, &quot;\n&amp;lt;/li&amp;gt;&amp;lt;li&amp;gt;&quot;) + &quot;\n&amp;lt;/li&amp;gt;&amp;lt;/ul&amp;gt;&quot;
            hljs.highlightBlock(elem);
          });
        });
      }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原本通过 highlight.js这个库在显示语法高亮的时候，是没有行号的。这里我进行了扩展&lt;br/&gt;通过 document.querySelectorAll(&quot;.html_body pre code&quot;) 找到nodeList&lt;br/&gt;然后对其循环，动态添加 ul , li, 这样就可以显示行号了&lt;br/&gt;不过这需要对 highlight的css文件添加几个样式&lt;br/&gt;源码里面我把highlight中的css文件全部copy到项目中了，使用的是github.css&lt;br/&gt;具体位置是在项目中的 assets/markdown/styles/github.css&lt;br/&gt;如果想使用其它的主题，可以自己修改其它的对应的css文件，这里使用了github的主题，所以只修改了github.css这一个文件&lt;br/&gt;有兴趣的可以查看一下&lt;br/&gt;github.css文件的提交记录&lt;/p&gt;
&lt;p&gt;具体的思路就是这些，水平有限，难免有bug，如有发现，欢迎提出&lt;/p&gt;
</description>
<pubDate>Sat, 18 May 2019 13:01:00 +0000</pubDate>
<dc:creator>九路313</dc:creator>
<og:description>Vue实现一个markdown编辑器 前段时间做项目的时候，需要一个Markdown编辑器，在网上找了一些开源的实现，但是都不满足需求 说实话，这些开源项目也很难满足需求公司项目的需求，与其实现一个大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/start1225/p/10887061.html</dc:identifier>
</item>
<item>
<title>权限框架之Shiro详解 - 故事爱人</title>
<link>http://www.cnblogs.com/WUXIAOCHANG/p/10886534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WUXIAOCHANG/p/10886534.html</guid>
<description>&lt;h2&gt;文章大纲&lt;/h2&gt;
&lt;p&gt;一、权限框架介绍&lt;br data-filtered=&quot;filtered&quot;/&gt;
二、Shiro基础介绍&lt;br data-filtered=&quot;filtered&quot;/&gt;
三、Spring Boot整合Shiro代码实战&lt;br data-filtered=&quot;filtered&quot;/&gt;
四、项目源码与资料下载&lt;br data-filtered=&quot;filtered&quot;/&gt;
五、参考文章&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;881&quot; data-height=&quot;829&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-4f9c1dc823b27cab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/881/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-4f9c1dc823b27cab.png&quot; data-original-width=&quot;881&quot; data-original-height=&quot;829&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;91559&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;一、权限框架介绍&lt;/h2&gt;
&lt;h3&gt;1. 什么是权限管理&lt;/h3&gt;
&lt;p&gt;  权限管理属于系统安全的范畴，权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  权限管理包括用户身份认证和授权两部分，简称认证授权。对于需要访问控制的资源用户首先经过身份认证，认证通过后用户具有该资源的访问权限方可访问。&lt;br data-filtered=&quot;filtered&quot;/&gt;
1.1 用户身份认证&lt;br data-filtered=&quot;filtered&quot;/&gt;
  身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确。对于采用指纹等系统，则出示指纹；对于硬件Key等刷卡系统，则需要刷卡。&lt;/p&gt;
&lt;p&gt;用户名密码身份认证流程：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;601&quot; data-height=&quot;569&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-e69524dc1b2a7478.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/601/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-e69524dc1b2a7478.png&quot; data-original-width=&quot;601&quot; data-original-height=&quot;569&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;114415&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;1.2 授权流程&lt;br data-filtered=&quot;filtered&quot;/&gt;
  授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的。&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;633&quot; data-height=&quot;514&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-fbb265c89b760333.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/633/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-fbb265c89b760333.png&quot; data-original-width=&quot;633&quot; data-original-height=&quot;514&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;27970&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;2. 常见权限框架&lt;/h3&gt;
&lt;p&gt;2.1 Shiro简介&lt;br data-filtered=&quot;filtered&quot;/&gt;
  Apache Shiro是Java的一个安全框架。目前，使用Apache Shiro的人越来越多，因为它相当简单，对比Spring Security，可能没有Spring Security做的功能强大，但是在实际工作时可能并不需要那么复杂的东西，所以使用小而简单的Shiro就足够了。对于它俩到底哪个好，这个不必纠结，能更简单的解决项目问题就好了。&lt;/p&gt;
&lt;p&gt;2.2 Spring Security&lt;br data-filtered=&quot;filtered&quot;/&gt;
  Spring Security是一个能够为基于Spring的企业应用系统提供声明式的安全访问控制解决方案的安全框架。它提供了一组可以在Spring应用上下文中配置的Bean，充分利用了Spring IoC，DI（控制反转Inversion of Control ,DI:Dependency Injection 依赖注入）和AOP（面向切面编程）功能，为应用系统提供声明式的安全访问控制功能，减少了为企业系统安全控制编写大量重复代码的工作。它是一个轻量级的安全框架，它确保基于Spring的应用程序提供身份验证和授权支持。它与Spring MVC有很好地集成，并配备了流行的安全算法实现捆绑在一起。安全主要包括两个操作“认证”与“验证”（有时候也会叫做权限控制）。“认证”是为用户建立一个其声明的角色的过程，这个角色可以一个用户、一个设备或者一个系统。“验证”指的是一个用户在你的应用中能够执行某个操作。在到达授权判断之前，角色已经在身份认证过程中建立了。&lt;/p&gt;
&lt;p&gt;2.3 Shiro和Spring Security比较&lt;br data-filtered=&quot;filtered&quot;/&gt;
（1）Shiro比Spring更容易使用，实现和最重要的理解&lt;br data-filtered=&quot;filtered&quot;/&gt;
（2）Spring Security更加知名的唯一原因是因为品牌名称&lt;br data-filtered=&quot;filtered&quot;/&gt;
（3）“Spring”以简单而闻名，但讽刺的是很多人发现安装Spring Security很难&lt;br data-filtered=&quot;filtered&quot;/&gt;
（4）Spring Security却有更好的社区支持&lt;br data-filtered=&quot;filtered&quot;/&gt;
（5）Apache Shiro在Spring Security处理密码学方面有一个额外的模块&lt;br data-filtered=&quot;filtered&quot;/&gt;
（6）Spring-security 对spring 结合较好，如果项目用的springmvc ，使用起来很方便。但是如果项目中没有用到spring，那就不要考虑它了。&lt;br data-filtered=&quot;filtered&quot;/&gt;
（7）Shiro 功能强大、且 简单、灵活。是Apache 下的项目比较可靠，且不跟任何的框架或者容器绑定，可以独立运行&lt;/p&gt;
&lt;h2&gt;二、Shiro基础介绍&lt;/h2&gt;
&lt;h3&gt;1. Shiro三个核心组件&lt;/h3&gt;
&lt;p&gt;1.1 Subject&lt;br data-filtered=&quot;filtered&quot;/&gt;
  Subject：即“当前操作用发户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是Shiro的“用户”概念。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。&lt;/p&gt;
&lt;p&gt;1.2 SecurityManager&lt;br data-filtered=&quot;filtered&quot;/&gt;
  SecurityManager：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。&lt;/p&gt;
&lt;p&gt;1.3 Realm&lt;br data-filtered=&quot;filtered&quot;/&gt;
  Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。&lt;br data-filtered=&quot;filtered&quot;/&gt;
  Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。&lt;/p&gt;
&lt;h3&gt;2. Shiro相关类介绍&lt;/h3&gt;
&lt;p&gt;（1）Authentication 认证 ---- 用户登录&lt;br data-filtered=&quot;filtered&quot;/&gt;
（2）Authorization 授权 --- 用户具有哪些权限&lt;br data-filtered=&quot;filtered&quot;/&gt;
（3）Cryptography 安全数据加密&lt;br data-filtered=&quot;filtered&quot;/&gt;
（4）Session Management 会话管理&lt;br data-filtered=&quot;filtered&quot;/&gt;
（5）Web Integration web系统集成&lt;br data-filtered=&quot;filtered&quot;/&gt;
（6）Interations 集成其它应用，spring、缓存框架&lt;/p&gt;
&lt;h3&gt;3. Shiro 特点&lt;/h3&gt;
&lt;p&gt;（1）易于理解的 Java Security API；&lt;br data-filtered=&quot;filtered&quot;/&gt;
（2）简单的身份认证（登录），支持多种数据源（LDAP，JDBC，Kerberos，ActiveDirectory 等）；&lt;br data-filtered=&quot;filtered&quot;/&gt;
（3）对角色的简单的签权（访问控制），支持细粒度的签权；&lt;br data-filtered=&quot;filtered&quot;/&gt;
（4）支持一级缓存，以提升应用程序的性能；&lt;br data-filtered=&quot;filtered&quot;/&gt;
（5）内置的基于 POJO 企业会话管理，适用于 Web 以及非 Web 的环境；&lt;br data-filtered=&quot;filtered&quot;/&gt;
（6）异构客户端会话访问；&lt;br data-filtered=&quot;filtered&quot;/&gt;
（7）非常简单的加密 API；&lt;br data-filtered=&quot;filtered&quot;/&gt;
（8）不跟任何的框架或者容器捆绑，可以独立运行&lt;/p&gt;
&lt;h2&gt;三、Spring Boot整合Shiro代码实战&lt;/h2&gt;
&lt;h3&gt;1. Spring Boot基础&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fwww.cnblogs.com%2FWUXIAOCHANG%2Fp%2F10877266.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/WUXIAOCHANG/p/10877266.html&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2. 创建Spring Boot的基础项目&lt;/h3&gt;
&lt;p&gt;2.1 新建maven项目&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1343&quot; data-height=&quot;922&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-d9aeef71da8c7138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-d9aeef71da8c7138.png&quot; data-original-width=&quot;1343&quot; data-original-height=&quot;922&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;237833&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;845&quot; data-height=&quot;776&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-434d86eb3b020ac6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/845/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-434d86eb3b020ac6.png&quot; data-original-width=&quot;845&quot; data-original-height=&quot;776&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;114746&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;876&quot; data-height=&quot;808&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-8bb3a2845a3ca11f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/876/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-8bb3a2845a3ca11f.png&quot; data-original-width=&quot;876&quot; data-original-height=&quot;808&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;27287&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;创建后项目结构如下：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;485&quot; data-height=&quot;484&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-54de11843db0b447.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/485/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-54de11843db0b447.png&quot; data-original-width=&quot;485&quot; data-original-height=&quot;484&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;29672&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.2 pom.xml中添加依赖&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;project &lt;span class=&quot;hljs-attr&quot;&gt;xmlns=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:xsi=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    &lt;span class=&quot;hljs-attr&quot;&gt;xsi:schemaLocation=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;modelVersion&amp;gt;4.0.0&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;modelVersion&amp;gt;

    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.3 编写测试Controller类&lt;br data-filtered=&quot;filtered&quot;/&gt;
com.itheima.controller包下新建UserController.java&lt;/p&gt;
&lt;pre class=&quot;hljs css&quot;&gt;
&lt;code class=&quot;css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;package &lt;span class=&quot;hljs-selector-tag&quot;&gt;com&lt;span class=&quot;hljs-selector-class&quot;&gt;.itheima&lt;span class=&quot;hljs-selector-class&quot;&gt;.controller;

&lt;span class=&quot;hljs-selector-tag&quot;&gt;import &lt;span class=&quot;hljs-selector-tag&quot;&gt;org&lt;span class=&quot;hljs-selector-class&quot;&gt;.springframework&lt;span class=&quot;hljs-selector-class&quot;&gt;.stereotype&lt;span class=&quot;hljs-selector-class&quot;&gt;.Controller;
&lt;span class=&quot;hljs-selector-tag&quot;&gt;import &lt;span class=&quot;hljs-selector-tag&quot;&gt;org&lt;span class=&quot;hljs-selector-class&quot;&gt;.springframework&lt;span class=&quot;hljs-selector-class&quot;&gt;.web&lt;span class=&quot;hljs-selector-class&quot;&gt;.bind&lt;span class=&quot;hljs-selector-class&quot;&gt;.annotation&lt;span class=&quot;hljs-selector-class&quot;&gt;.RequestMapping;
&lt;span class=&quot;hljs-selector-tag&quot;&gt;import &lt;span class=&quot;hljs-selector-tag&quot;&gt;org&lt;span class=&quot;hljs-selector-class&quot;&gt;.springframework&lt;span class=&quot;hljs-selector-class&quot;&gt;.web&lt;span class=&quot;hljs-selector-class&quot;&gt;.bind&lt;span class=&quot;hljs-selector-class&quot;&gt;.annotation&lt;span class=&quot;hljs-selector-class&quot;&gt;.ResponseBody;

@&lt;span class=&quot;hljs-keyword&quot;&gt;Controller
public class UserController {

    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.4 导入thymeleaf页面模块&lt;br data-filtered=&quot;filtered&quot;/&gt;
pom.xml文件中添加依赖&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;UserController.java类中添加测试方法&lt;/p&gt;
&lt;pre class=&quot;hljs cpp&quot;&gt;
&lt;code class=&quot;cpp&quot;&gt;    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.5 添加thymeleaf页面模块&lt;br data-filtered=&quot;filtered&quot;/&gt;
在src/main/resource目录下创建templates目录，然后创建test.html页面&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;html&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;head&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta &lt;span class=&quot;hljs-attr&quot;&gt;charset=&lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot;&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;title&amp;gt;测试Thymeleaf的使用&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;title&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;head&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;body&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;h3 &lt;span class=&quot;hljs-attr&quot;&gt;th:text=&lt;span class=&quot;hljs-string&quot;&gt;&quot;${name}&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;h3&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;body&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;492&quot; data-height=&quot;463&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-44b7abcc4fce5605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/492/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-44b7abcc4fce5605.png&quot; data-original-width=&quot;492&quot; data-original-height=&quot;463&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;27954&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.6 运行项目并访问&lt;br data-filtered=&quot;filtered&quot;/&gt;
运行项目&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1744&quot; data-height=&quot;526&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-71d6bfdc95670c54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-71d6bfdc95670c54.png&quot; data-original-width=&quot;1744&quot; data-original-height=&quot;526&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;82505&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;访问项目&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;850&quot; data-height=&quot;154&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-bf1174ff25ddeee5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/850/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-bf1174ff25ddeee5.png&quot; data-original-width=&quot;850&quot; data-original-height=&quot;154&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;23771&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1047&quot; data-height=&quot;201&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-44ef13b0de15bf4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-44ef13b0de15bf4c.png&quot; data-original-width=&quot;1047&quot; data-original-height=&quot;201&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;29790&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;3. Spring Boot与Shiro整合实现用户认证&lt;/h3&gt;
&lt;p&gt;3.1 分析Shiro的核心API&lt;br data-filtered=&quot;filtered&quot;/&gt;
Subject： 用户主体（把操作交给SecurityManager）&lt;br data-filtered=&quot;filtered&quot;/&gt;
SecurityManager：安全管理器（关联Realm）&lt;br data-filtered=&quot;filtered&quot;/&gt;
Realm：Shiro连接数据的桥梁&lt;/p&gt;
&lt;p&gt;3.2 导入shiro与spring整合依赖&lt;br data-filtered=&quot;filtered&quot;/&gt;
pom.xml文件中添加依赖&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;project &lt;span class=&quot;hljs-attr&quot;&gt;xmlns=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0&quot; &lt;span class=&quot;hljs-attr&quot;&gt;xmlns:xsi=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    &lt;span class=&quot;hljs-attr&quot;&gt;xsi:schemaLocation=&lt;span class=&quot;hljs-string&quot;&gt;&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;modelVersion&amp;gt;4.0.0&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;modelVersion&amp;gt;

    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.3 resources下配置&lt;br data-filtered=&quot;filtered&quot;/&gt;
新建application.properties文件&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;spring.datasource.driverClassName=com.mysql.jdbc.Driver
spring.datasource.url=jdbc:mysql:&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;templates文件夹下加入相关模板页面&lt;/p&gt;
&lt;p&gt;add.html&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;html&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;head&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta &lt;span class=&quot;hljs-attr&quot;&gt;charset=&lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot;&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;title&amp;gt;用户添加页面&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;title&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;head&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;body&amp;gt;
用户添加
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;body&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;update.html&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;html&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;head&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta &lt;span class=&quot;hljs-attr&quot;&gt;charset=&lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot;&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;title&amp;gt;用户更新页面&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;title&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;head&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;body&amp;gt;
用户更新
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;body&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;login.html&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;html&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;head&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta &lt;span class=&quot;hljs-attr&quot;&gt;charset=&lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot;&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;title&amp;gt;登录页面&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;title&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;head&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;body&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;h3&amp;gt;登录&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;h3&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;h3 &lt;span class=&quot;hljs-attr&quot;&gt;th:text=&lt;span class=&quot;hljs-string&quot;&gt;&quot;${msg}&quot; &lt;span class=&quot;hljs-attr&quot;&gt;style=&lt;span class=&quot;hljs-string&quot;&gt;&quot;color: red&quot;&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;h3&amp;gt;

&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;form &lt;span class=&quot;hljs-attr&quot;&gt;method=&lt;span class=&quot;hljs-string&quot;&gt;&quot;post&quot; &lt;span class=&quot;hljs-attr&quot;&gt;action=&lt;span class=&quot;hljs-string&quot;&gt;&quot;login&quot;&amp;gt;
    用户名:&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input &lt;span class=&quot;hljs-attr&quot;&gt;type=&lt;span class=&quot;hljs-string&quot;&gt;&quot;text&quot; &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;name&quot;/&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;br/&amp;gt;
    密码：&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input &lt;span class=&quot;hljs-attr&quot;&gt;type=&lt;span class=&quot;hljs-string&quot;&gt;&quot;password&quot; &lt;span class=&quot;hljs-attr&quot;&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;password&quot;/&amp;gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;br/&amp;gt;
    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;input &lt;span class=&quot;hljs-attr&quot;&gt;type=&lt;span class=&quot;hljs-string&quot;&gt;&quot;submit&quot; &lt;span class=&quot;hljs-attr&quot;&gt;value=&lt;span class=&quot;hljs-string&quot;&gt;&quot;登录&quot;/&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;form&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;body&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;noAuth.html&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;html&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;head&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;meta &lt;span class=&quot;hljs-attr&quot;&gt;charset=&lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot;&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;title&amp;gt;未授权提示页面&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;title&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;head&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;body&amp;gt;
亲，你未经授权访问该页面
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;body&amp;gt;
&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;html&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;434&quot; data-height=&quot;218&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-3a63edb2dac4e5cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/434/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-3a63edb2dac4e5cb.png&quot; data-original-width=&quot;434&quot; data-original-height=&quot;218&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;11021&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3.4 新建shiro相关配置&lt;br data-filtered=&quot;filtered&quot;/&gt;
com.itheima.shiro包下新建ShiroConfig.java类&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.itheima.shiro;

&lt;span class=&quot;hljs-keyword&quot;&gt;import java.util.LinkedHashMap;
&lt;span class=&quot;hljs-keyword&quot;&gt;import java.util.Map;

&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.beans.factory.annotation.Qualifier;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.context.annotation.Bean;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.context.annotation.Configuration;

&lt;span class=&quot;hljs-keyword&quot;&gt;import at.pollux.thymeleaf.shiro.dialect.ShiroDialect;

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;com.itheima.shiro包下新建UserRealm.java类&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.itheima.shiro;

&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.SecurityUtils;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.authc.AuthenticationException;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.authc.AuthenticationInfo;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.authc.AuthenticationToken;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.authc.SimpleAuthenticationInfo;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.authc.UsernamePasswordToken;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.authz.AuthorizationInfo;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.authz.SimpleAuthorizationInfo;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.realm.AuthorizingRealm;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.subject.PrincipalCollection;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.subject.Subject;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;

&lt;span class=&quot;hljs-keyword&quot;&gt;import com.itheima.domain.User;
&lt;span class=&quot;hljs-keyword&quot;&gt;import com.itheima.service.UserService;

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.5 新建实体类&lt;br data-filtered=&quot;filtered&quot;/&gt;
com.itheima.domain包下新建User.java&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.itheima.domain;

&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;User {
    &lt;span class=&quot;hljs-keyword&quot;&gt;private Integer id;
    &lt;span class=&quot;hljs-keyword&quot;&gt;private String name;
    &lt;span class=&quot;hljs-keyword&quot;&gt;private String password;
    &lt;span class=&quot;hljs-keyword&quot;&gt;private String perms;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getPerms&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return perms;
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setPerms&lt;span class=&quot;hljs-params&quot;&gt;(String perms) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.perms = perms;
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public Integer &lt;span class=&quot;hljs-title&quot;&gt;getId&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return id;
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setId&lt;span class=&quot;hljs-params&quot;&gt;(Integer id) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.id = id;
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getName&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return name;
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setName&lt;span class=&quot;hljs-params&quot;&gt;(String name) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.name = name;
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public String &lt;span class=&quot;hljs-title&quot;&gt;getPassword&lt;span class=&quot;hljs-params&quot;&gt;() {
        &lt;span class=&quot;hljs-keyword&quot;&gt;return password;
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;setPassword&lt;span class=&quot;hljs-params&quot;&gt;(String password) {
        &lt;span class=&quot;hljs-keyword&quot;&gt;this.password = password;
    }
    
}

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.6 创建mapper相关内容&lt;br data-filtered=&quot;filtered&quot;/&gt;
com.itheima.mapper包下新建UserMapper.java&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.itheima.mapper;

&lt;span class=&quot;hljs-keyword&quot;&gt;import com.itheima.domain.User;

&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface &lt;span class=&quot;hljs-title&quot;&gt;UserMapper {

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public User &lt;span class=&quot;hljs-title&quot;&gt;findByName&lt;span class=&quot;hljs-params&quot;&gt;(String name);
    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public User &lt;span class=&quot;hljs-title&quot;&gt;findById&lt;span class=&quot;hljs-params&quot;&gt;(Integer id);
}

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;com.itheima.mapper包下新建UserMapper.xml&lt;/p&gt;
&lt;pre class=&quot;hljs xml&quot;&gt;
&lt;code class=&quot;xml&quot;&gt;&lt;span class=&quot;php&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;?xml version=&lt;span class=&quot;hljs-string&quot;&gt;&quot;1.0&quot; encoding=&lt;span class=&quot;hljs-string&quot;&gt;&quot;UTF-8&quot; &lt;span class=&quot;hljs-meta&quot;&gt;?&amp;gt;
&lt;span class=&quot;hljs-meta&quot;&gt;&amp;lt;!DOCTYPE mapper
PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.7 创建业务逻辑相关内容&lt;br data-filtered=&quot;filtered&quot;/&gt;
com.itheima.service下新建UserService.java&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.itheima.service;

&lt;span class=&quot;hljs-keyword&quot;&gt;import com.itheima.domain.User;

&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;interface &lt;span class=&quot;hljs-title&quot;&gt;UserService {

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public User &lt;span class=&quot;hljs-title&quot;&gt;findByName&lt;span class=&quot;hljs-params&quot;&gt;(String name);
    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public User &lt;span class=&quot;hljs-title&quot;&gt;findById&lt;span class=&quot;hljs-params&quot;&gt;(Integer id);
}

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;com.itheima.service.impl下新建UserServiceImpl.java&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.itheima.service.impl;

&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.tomcat.util.net.openssl.ciphers.Authentication;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.stereotype.Service;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.transaction.annotation.Transactional;

&lt;span class=&quot;hljs-keyword&quot;&gt;import com.itheima.domain.User;
&lt;span class=&quot;hljs-keyword&quot;&gt;import com.itheima.mapper.UserMapper;
&lt;span class=&quot;hljs-keyword&quot;&gt;import com.itheima.service.UserService;

&lt;span class=&quot;hljs-meta&quot;&gt;@Service
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;UserServiceImpl &lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;UserService{

    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.8 新建Controller相关内容&lt;br data-filtered=&quot;filtered&quot;/&gt;
UserController.java添加相关代码，最终内容如下：&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.itheima.controller;

&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.SecurityUtils;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.authc.AuthenticationException;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.authc.IncorrectCredentialsException;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.authc.UnknownAccountException;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.authc.UsernamePasswordToken;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.shiro.subject.Subject;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.beans.factory.annotation.Autowired;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.stereotype.Controller;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.ui.Model;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.web.bind.annotation.RequestMapping;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.web.bind.annotation.ResponseBody;

&lt;span class=&quot;hljs-keyword&quot;&gt;import com.itheima.service.UserService;

&lt;span class=&quot;hljs-meta&quot;&gt;@Controller
&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;UserController {

    &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.9 Application启动类配置&lt;/p&gt;
&lt;pre class=&quot;hljs java&quot;&gt;
&lt;code class=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package com.itheima;

&lt;span class=&quot;hljs-keyword&quot;&gt;import org.mybatis.spring.annotation.MapperScan;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.boot.SpringApplication;
&lt;span class=&quot;hljs-keyword&quot;&gt;import org.springframework.boot.autoconfigure.SpringBootApplication;

&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.10 创建后项目结构&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;481&quot; data-height=&quot;703&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-084c6c6087237a3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/481/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-084c6c6087237a3e.png&quot; data-original-width=&quot;481&quot; data-original-height=&quot;703&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;41171&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3.11 数据库配置&lt;br data-filtered=&quot;filtered&quot;/&gt;
数据库的sql文件可以在项目源码与资料下载中获取，我们创建的数据库名字为shiro_test,具体字段参数如下图所示：&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1147&quot; data-height=&quot;504&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-890346dbe8e90586.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-890346dbe8e90586.png&quot; data-original-width=&quot;1147&quot; data-original-height=&quot;504&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;56323&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;往数据库插入一条数据&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;501&quot; data-height=&quot;70&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-ea5a3cf63f60eb7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/501/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-ea5a3cf63f60eb7c.png&quot; data-original-width=&quot;501&quot; data-original-height=&quot;70&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;4809&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3.12 运行项目并访问&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1350&quot; data-height=&quot;687&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-a115b9dde67a7feb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-a115b9dde67a7feb.png&quot; data-original-width=&quot;1350&quot; data-original-height=&quot;687&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;106347&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;访问&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A8080%2Fadd&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/add&lt;/a&gt;或者&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A8080%2Fupdate&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/update&lt;/a&gt;，可以看到被拦截了，重定向到了登录页面&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;919&quot; data-height=&quot;271&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-e9d6c9b7297f453f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/919/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-e9d6c9b7297f453f.png&quot; data-original-width=&quot;919&quot; data-original-height=&quot;271&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;34123&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;980&quot; data-height=&quot;325&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-527c4839afe83090.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/980/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-527c4839afe83090.png&quot; data-original-width=&quot;980&quot; data-original-height=&quot;325&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;33310&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;访问&lt;a href=&quot;https://links.jianshu.com/go?to=http%3A%2F%2Flocalhost%3A8080%2Flogin&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;http://localhost:8080/login&lt;/a&gt;，进行登录&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;905&quot; data-height=&quot;258&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-4a840001b1c6a717.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/905/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-4a840001b1c6a717.png&quot; data-original-width=&quot;905&quot; data-original-height=&quot;258&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;33045&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;登录成功&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;844&quot; data-height=&quot;275&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-e6f97566286ae305.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/844/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-e6f97566286ae305.png&quot; data-original-width=&quot;844&quot; data-original-height=&quot;275&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;32165&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们在数据库添加的权限是修改的，我们试试登录后，访问添加页面&lt;/p&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;738&quot; data-height=&quot;151&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16598307-6b93c9a95353a1a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/738/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16598307-6b93c9a95353a1a0.png&quot; data-original-width=&quot;738&quot; data-original-height=&quot;151&quot; data-original-format=&quot;image/png&quot; data-original-filesize=&quot;23621&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看到，已经被拦截了&lt;/p&gt;
&lt;h2&gt;四、项目源码与资料下载&lt;/h2&gt;
&lt;p&gt;链接：&lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fpan.baidu.com%2Fs%2F12yTMozR6oFG6cYcVmnBwog&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/12yTMozR6oFG6cYcVmnBwog&lt;/a&gt;&lt;br data-filtered=&quot;filtered&quot;/&gt;
提取码：yswz&lt;/p&gt;
&lt;h2&gt;五、参考文章&lt;/h2&gt;

</description>
<pubDate>Sat, 18 May 2019 11:25:00 +0000</pubDate>
<dc:creator>故事爱人</dc:creator>
<og:description>文章大纲 一、权限框架介绍二、Shiro基础介绍三、Spring Boot整合Shiro代码实战四、项目源码与资料下载五、参考文章 一、权限框架介绍 1. 什么是权限管理 权限管理属于系统安全的范畴，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/WUXIAOCHANG/p/10886534.html</dc:identifier>
</item>
<item>
<title>JDBC的初步了解及使用 - Eden-Xie</title>
<link>http://www.cnblogs.com/xym15079750872/p/10886738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xym15079750872/p/10886738.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、概念&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1、什么是JDBC？&lt;/p&gt;
&lt;p&gt;　　JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据&lt;/p&gt;
&lt;p&gt;此可以构建更高级的工具和接口，使数据库开发者能够编写数据库的程序。简单地说，JDBC 可做三件事：与数据库建立连接、发送 操作数据库的语句并处理结果。&lt;/p&gt;
&lt;p&gt;2、JDBC有什么用呢？&lt;/p&gt;
&lt;p&gt;　　我们用JAVA就能连接到数据库；创建SQL或者MYSQL语句；执行SQL或MYSQL的查询数据库；查看和修改结果记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201905/1635146-20190518170510325-1137914670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、连接常用的接口&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　提供的接口包括：JAVA API：提供对JDBC的管理链接；JAVA Driver API：支持JDBC管理到驱动器连接。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 1、DriverManager ：这个类管理数据库驱动程序的列表。内容是否符合从Java应用程序使用的通信子协议正确的数据&lt;/p&gt;
&lt;p&gt; 库驱动程序的连接请求。识别JDBC在一定子协议的第一个驱动器被用来建立数据库连接。&lt;/p&gt;
&lt;p&gt;2、Driver ：此接口处理与数据库服务器通信。很少直接与驱动程序对象。相反，使用DriverManager中的对象，它管理&lt;/p&gt;
&lt;p&gt;此类型的对象。它也抽象的与驱动程序对象工作相关的详细信息。&lt;/p&gt;
&lt;p&gt;3、Connection ：此接口与接触数据库的所有方法。连接对象表示通信上下文，即，与数据库中的所有的通信是通过唯一的连接对象。&lt;/p&gt;
&lt;p&gt; 4、Statement ：可以使用这个接口创建的对象的SQL语句提交到数据库。一些派生的接口接受除执行存储过程的参数。&lt;/p&gt;
&lt;p&gt; 5、ResultSet  ：这些对象保存从数据库后，执行使用Statement对象的&lt;a href=&quot;http://www.yiibai.com/sql/&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;SQL&lt;/a&gt;查询中检索数据。它作为一个迭代器，让你可以通过移动它的数据。&lt;/p&gt;

&lt;p&gt;创建JDBC的七大步骤：&lt;/p&gt;
&lt;p&gt;第一步：导入工具包：&lt;/p&gt;
&lt;p&gt;import java.sql.*；&lt;/p&gt;
&lt;p&gt;import javax.sql.*；&lt;/p&gt;
&lt;p&gt;第二步：注册jdbc驱动程序&lt;/p&gt;
&lt;p&gt;第三步：Class.forName( ....);&lt;/p&gt;
&lt;p&gt;第四步：使用DriverManager.getConnection();方法来创建一个Connection对象，它代表一个物理连接的数据库。&lt;/p&gt;
&lt;p&gt;第五步：执行查询：使用一个对象类型Statement或PreparedStatement()构建，并提交一个SQL语句到数据库。&lt;/p&gt;
&lt;p&gt;第六步：从结果集中提取数据;这一步是必需的情况下，从数据库中获取数据。可以使用适当的ResultSet.getXXX()方法来检索&lt;/p&gt;
&lt;p&gt;第七步：清理环境：关闭使用的数据库资源。&lt;/p&gt;

&lt;p&gt;我们用代码简单的来实现数据库的连接 代码如下：&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; pkg1;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; java.sql.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt; javax.sql.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test{
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Driver类全名&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DRIVER = &quot;com.microsoft.sqlserver.jdbc.SQLServerDriver&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;jdbc协议:子协议:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;ip:端口号/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String URL = &quot;jdbc:sqlserver://localhost:1433;databasename=&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库名&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String DATABASE_NAME = &quot;oa&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库用户名&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String USER_NAME = &quot;sa&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据库密码&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String PASSWORD = &quot;123456&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String args[]){
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载驱动程序：它通过反射创建一个driver对象。&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            Class.forName( DRIVER );
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.打开Miccorsoft SQL Server  Managerment Studio 并且连接&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             Connection conn = DriverManager.getConnection( URL+&lt;span&gt;DATABASE_NAME,USER_NAME,PASSWORD);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;2.新建一个查询&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             Statement stmt =&lt;span&gt; conn.createStatement();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.执行查询---&amp;gt;返回结果集&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             ResultSet rs = stmt.executeQuery(&quot;select * from tt2&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; k = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                String g,d;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;&lt;span&gt; ( rs.next() ){
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     k = rs.getInt(&quot;id&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     g = rs.getString(&quot;name&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     d = rs.getString(&quot;sex&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     System.out.println(&quot;编号:&quot;+k+&quot; &quot;+&quot;姓名:&quot;+g+&quot; &quot;+&quot;性别:&quot;+&lt;span&gt;d);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                     count++&lt;span&gt;;    
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     
&lt;span&gt;39&lt;/span&gt;                 }&lt;span&gt;if&lt;/span&gt;(k==0&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     System.out.println(&quot;查找正常，但没有记录&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                }                
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭Microsoft SQL Server  Managerment Studio连接&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            rs.close();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            stmt.close();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            conn.close();
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             
&lt;span&gt;48&lt;/span&gt;             
&lt;span&gt;49&lt;/span&gt;             System.out.println(&quot;连接的数据库是&quot;+&lt;span&gt;conn);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(ClassNotFoundException e){
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             System.out.println(&quot;找不到驱动&quot;+&lt;span&gt;e.getMessage());
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;catch&lt;/span&gt;&lt;span&gt;(Exception e){
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             System.out.println(&quot;驱动已经加载成功，发生其他异常&quot;+&lt;span&gt;e.getMessage());
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201905/1635146-20190518174236860-359042610.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们现在在oa数据库里面建了一张tt2的数据库表，插上了数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201905/1635146-20190518174347998-1291415832.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在对代码进行编译&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1635146/201905/1635146-20190518174814678-2057732791.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到已经把数据库里的内容读取出来了。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;1、JDBC结果集中为什么.next();?&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将光标从当前位置向下移动一行。结果集光标最初位于第一行之前；对方法的第一次调用接着使第一行成为当前行；第二次调用使第二行成为当前行，依此类推。&lt;/p&gt;
&lt;p&gt;如果当前行的输入流是打开的，那么对方法next的调用将隐式关闭它。读取新行时，ResultSet对象的警告链接清除。&lt;/p&gt;
&lt;p&gt;至于返回值，如果新的当前行有效，则为true；如果没有更多行，则为false.&lt;/p&gt;
&lt;p&gt;但是要&lt;span&gt;特别注意&lt;/span&gt;，next()方法用一次，游标就往后移了一位，此时再使用next()来获取结果就是结果集中的第二个记录了。&lt;/p&gt;

</description>
<pubDate>Sat, 18 May 2019 11:05:00 +0000</pubDate>
<dc:creator>Eden-Xie</dc:creator>
<og:description>一、概念 1、什么是JDBC？ JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xym15079750872/p/10886738.html</dc:identifier>
</item>
</channel>
</rss>