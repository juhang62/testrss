<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《k8s-1.13版本源码分析》- Scheduler启动前逻辑 - CloudGeek</title>
<link>http://www.cnblogs.com/cloudgeek/p/10418626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cloudgeek/p/10418626.html</guid>
<description>&lt;h2 id=&quot;概述&quot;&gt;1. 概述&lt;/h2&gt;
&lt;p&gt;前面提到过scheduler程序可以分为三层，第一层是调度器启动前的逻辑，包括命令行参数解析、参数校验、调度器初始化等一系列逻辑。这个部分我不会太详细地介绍，因为这些代码位于调度框架之前，相对比较枯燥无趣，讲多了磨灭大伙对源码的兴趣～&lt;/p&gt;
&lt;h2 id=&quot;cobra和main&quot;&gt;2. cobra和main&lt;/h2&gt;
&lt;p&gt;剧透一下先，如果你之前没有用过cobra，那么在第一次见到cobra之后，很可能以后你自己写的程序，开发的小工具会全部变成cobra风格。我最近半年写的命令行程序就全部是基于cobra+pflag的。cobra有多优雅呢，且听我慢慢道来～&lt;/p&gt;
&lt;h3 id=&quot;cobra是啥&quot;&gt;2.1. cobra是啥&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://farmer-hutao.github.io/k8s-source-code-analysis/core/scheduler/image/1550801313662.png&quot; alt=&quot;1550801313662&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从github上我们可以找到这个项目，截至今天已经有上万个star，一百多个contributors，可见来头不小！Cobra官方描述是：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Cobra is both a library for creating powerful modern CLI applications as well as a program to generate applications and command files.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;也就是这个意思：Cobra既是一个创建强大的现代化命令行程序的库，又是一个用于生成应用和命令行文件的程序。有很多流行的Go项目用了Cobra，其中当然包括我们最最熟知的k8s和docker，大致列出来有这些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Kubernetes&lt;/li&gt;
&lt;li&gt;Hugo&lt;/li&gt;
&lt;li&gt;rkt&lt;/li&gt;
&lt;li&gt;etcd&lt;/li&gt;
&lt;li&gt;Moby (former Docker)&lt;/li&gt;
&lt;li&gt;Docker (distribution)&lt;/li&gt;
&lt;li&gt;OpenShift&lt;/li&gt;
&lt;li&gt;Delve&lt;/li&gt;
&lt;li&gt;GopherJS&lt;/li&gt;
&lt;li&gt;CockroachDB&lt;/li&gt;
&lt;li&gt;Bleve&lt;/li&gt;
&lt;li&gt;ProjectAtomic (enterprise)&lt;/li&gt;
&lt;li&gt;Giant Swarm's gsctl&lt;/li&gt;
&lt;li&gt;Nanobox/Nanopack&lt;/li&gt;
&lt;li&gt;rclone&lt;/li&gt;
&lt;li&gt;nehm&lt;/li&gt;
&lt;li&gt;Pouch&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果你是云计算方向的攻城狮，上面半数项目应该都耳熟能详～&lt;/p&gt;
&lt;h3 id=&quot;使用cobra&quot;&gt;2.2. 使用cobra&lt;/h3&gt;
&lt;p&gt;下面我们实践一下cobra，先下载这个项目编译一下：&lt;/p&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-shell&quot;/&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;于是我们得到了这样一个可执行文件及项目源码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://farmer-hutao.github.io/k8s-source-code-analysis/core/scheduler/image/1550805176140.png&quot; alt=&quot;1550805176140&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们试一下这个命令：&lt;code&gt;cobra init ${project-name}&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-shell&quot;&gt;&lt;span class=&quot;token punctuation&quot;&gt;[root@farmer-hutao src&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;如上，本地可以看到一个main.go和一个cmd目录，这个cmd和k8s源码里的cmd是不是很像～&lt;/p&gt;
&lt;p&gt;main.go里面的代码很精简，如下：&lt;/p&gt;

&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;package main

&lt;span class=&quot;token keyword&quot;&gt;import &lt;span class=&quot;token string&quot;&gt;&quot;myapp/cmd&quot;

&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token function&quot;&gt;main&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
        cmd&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;Execute&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;这里注意到调用了一个cmd的Execute()方法，我们继续看cmd是什么：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://farmer-hutao.github.io/k8s-source-code-analysis/core/scheduler/image/1550806123357.png&quot; alt=&quot;1550806123357&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，在&lt;code&gt;main.go&lt;/code&gt;里面import了&lt;code&gt;myapp/cmd&lt;/code&gt;，也就是这个&lt;code&gt;root.go&lt;/code&gt;文件。所以Execute()函数就很好找了。在&lt;code&gt;Execute&lt;/code&gt;里面调用了&lt;code&gt;rootCmd.Execute()&lt;/code&gt;方法，这个&lt;code&gt;rootCmd&lt;/code&gt;是&lt;code&gt;*cobra.Command&lt;/code&gt;类型的。我们关注一下这个类型。&lt;/p&gt;
&lt;p&gt;下面我们继续使用cobra命令给myapp添加一个子命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://farmer-hutao.github.io/k8s-source-code-analysis/core/scheduler/image/1550809296691.png&quot; alt=&quot;1550809296691&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，我们的程序可以使用version子命令了！我们看一下源码发生了什么变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://farmer-hutao.github.io/k8s-source-code-analysis/core/scheduler/image/1550809447903.png&quot; alt=&quot;1550809447903&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多了一个&lt;code&gt;version.go&lt;/code&gt;，在这个源文件的init()函数里面调用了一个&lt;code&gt;rootCmd.AddCommand(versionCmd)&lt;/code&gt;，这里可以猜到是根命令下添加一个子命令的意思，根命令表示的就是我们直接执行这个可执行文件，子命令就是version，放在一起的感觉就类似大家使用&lt;code&gt;kubectl version&lt;/code&gt;的感觉。&lt;/p&gt;
&lt;p&gt;另外注意到这里的Run属性是一个匿名函数，这个函数中输出了“version called”字样，也就是说我们执行version子命令的时候其实是调用到了这里的Run.&lt;/p&gt;
&lt;p&gt;最后我们实践一下多级子命令：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://farmer-hutao.github.io/k8s-source-code-analysis/core/scheduler/image/1550809980172.png&quot; alt=&quot;1550809980172&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://farmer-hutao.github.io/k8s-source-code-analysis/core/scheduler/image/1550810044678.png&quot; alt=&quot;1550810044678&quot;/&gt;&lt;/p&gt;
&lt;p&gt;套路也就这样，通过&lt;code&gt;serverCmd.AddCommand(createCmd)&lt;/code&gt;调用后就能够把&lt;code&gt;*cobra.Command&lt;/code&gt;类型的createCmd变成serverCmd的子命令了，这个时候我们玩起来就像&lt;code&gt;kubectl get pods&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;行，看到这里我们回头看一下scheduler的源码就能找到main的逻辑了。&lt;/p&gt;
&lt;h2 id=&quot;Scheduler的main&quot;&gt;3. Scheduler的main&lt;/h2&gt;
&lt;p&gt;我们打开文件：&lt;code&gt;cmd/kube-scheduler/scheduler.go&lt;/code&gt;可以找到scheduler的main()函数，很简短，去掉枝干后如下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;cmd/kube-scheduler/scheduler.go:34&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token function&quot;&gt;main&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
    command &lt;span class=&quot;token operator&quot;&gt;:= app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;NewSchedulerCommand&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)
    &lt;span class=&quot;token keyword&quot;&gt;if err &lt;span class=&quot;token operator&quot;&gt;:= command&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;Execute&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;; err &lt;span class=&quot;token operator&quot;&gt;!= &lt;span class=&quot;token boolean&quot;&gt;nil &lt;span class=&quot;token punctuation&quot;&gt;{
        fmt&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;Fprintf&lt;span class=&quot;token punctuation&quot;&gt;(os&lt;span class=&quot;token punctuation&quot;&gt;.Stderr&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token string&quot;&gt;&quot;%v\n&quot;&lt;span class=&quot;token punctuation&quot;&gt;, err&lt;span class=&quot;token punctuation&quot;&gt;)
        os&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;Exit&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token number&quot;&gt;1&lt;span class=&quot;token punctuation&quot;&gt;)
    &lt;span class=&quot;token punctuation&quot;&gt;}
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;看到这里猜都能猜到&lt;code&gt;kube-scheduler&lt;/code&gt;这个二进制文件在运行的时候是调用了&lt;code&gt;command.Execute()&lt;/code&gt;函数背后的那个Run，那个Run躲在&lt;code&gt;command := app.NewSchedulerCommand()&lt;/code&gt;这行代码调用的&lt;code&gt;NewSchedulerCommand()&lt;/code&gt;方法里，这个方法一定返回了一个&lt;code&gt;*cobra.Command&lt;/code&gt;类型的对象。我们跟进去这个函数，看一下是不是这个样子：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;cmd/kube-scheduler/app/server.go:70&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;&gt;&lt;span class=&quot;token operator&quot;&gt;/ NewSchedulerCommand creates a &lt;span class=&quot;token operator&quot;&gt;*cobra&lt;span class=&quot;token punctuation&quot;&gt;.Command object with &lt;span class=&quot;token keyword&quot;&gt;default parameters
&lt;span class=&quot;token keyword&quot;&gt;func &lt;span class=&quot;token function&quot;&gt;NewSchedulerCommand&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token operator&quot;&gt;*cobra&lt;span class=&quot;token punctuation&quot;&gt;.Command &lt;span class=&quot;token punctuation&quot;&gt;{
    cmd &lt;span class=&quot;token operator&quot;&gt;:= &lt;span class=&quot;token operator&quot;&gt;&amp;amp;cobra&lt;span class=&quot;token punctuation&quot;&gt;.Command&lt;span class=&quot;token punctuation&quot;&gt;{
        Use&lt;span class=&quot;token punctuation&quot;&gt;: &lt;span class=&quot;token string&quot;&gt;&quot;kube-scheduler&quot;&lt;span class=&quot;token punctuation&quot;&gt;,
        Long&lt;span class=&quot;token punctuation&quot;&gt;: &lt;span class=&quot;token string&quot;&gt;`The Kubernetes scheduler is a policy-rich, topology-aware,
workload-specific function that significantly impacts availability, performance,
and capacity. The scheduler needs to take into account individual and collective
resource requirements, quality of service requirements, hardware/software/policy
constraints, affinity and anti-affinity specifications, data locality, inter-workload
interference, deadlines, and so on. Workload-specific requirements will be exposed
through the API as necessary.`&lt;span class=&quot;token punctuation&quot;&gt;,
        Run&lt;span class=&quot;token punctuation&quot;&gt;: &lt;span class=&quot;token keyword&quot;&gt;func&lt;span class=&quot;token punctuation&quot;&gt;(cmd &lt;span class=&quot;token operator&quot;&gt;*cobra&lt;span class=&quot;token punctuation&quot;&gt;.Command&lt;span class=&quot;token punctuation&quot;&gt;, args &lt;span class=&quot;token punctuation&quot;&gt;[&lt;span class=&quot;token punctuation&quot;&gt;]&lt;span class=&quot;token builtin&quot;&gt;string&lt;span class=&quot;token punctuation&quot;&gt;) &lt;span class=&quot;token punctuation&quot;&gt;{
            &lt;span class=&quot;token keyword&quot;&gt;if err &lt;span class=&quot;token operator&quot;&gt;:= &lt;span class=&quot;token function&quot;&gt;runCommand&lt;span class=&quot;token punctuation&quot;&gt;(cmd&lt;span class=&quot;token punctuation&quot;&gt;, args&lt;span class=&quot;token punctuation&quot;&gt;, opts&lt;span class=&quot;token punctuation&quot;&gt;)&lt;span class=&quot;token punctuation&quot;&gt;; err &lt;span class=&quot;token operator&quot;&gt;!= &lt;span class=&quot;token boolean&quot;&gt;nil &lt;span class=&quot;token punctuation&quot;&gt;{
                fmt&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;Fprintf&lt;span class=&quot;token punctuation&quot;&gt;(os&lt;span class=&quot;token punctuation&quot;&gt;.Stderr&lt;span class=&quot;token punctuation&quot;&gt;, &lt;span class=&quot;token string&quot;&gt;&quot;%v\n&quot;&lt;span class=&quot;token punctuation&quot;&gt;, err&lt;span class=&quot;token punctuation&quot;&gt;)
                os&lt;span class=&quot;token punctuation&quot;&gt;.&lt;span class=&quot;token function&quot;&gt;Exit&lt;span class=&quot;token punctuation&quot;&gt;(&lt;span class=&quot;token number&quot;&gt;1&lt;span class=&quot;token punctuation&quot;&gt;)
            &lt;span class=&quot;token punctuation&quot;&gt;}
        &lt;span class=&quot;token punctuation&quot;&gt;}&lt;span class=&quot;token punctuation&quot;&gt;,
    &lt;span class=&quot;token punctuation&quot;&gt;}
    &lt;span class=&quot;token keyword&quot;&gt;return cmd
&lt;span class=&quot;token punctuation&quot;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;如上，同样我先删掉了一些枝干代码，剩下的可以很清楚地看到，schduler启动时调用了&lt;code&gt;runCommand(cmd, args, opts)&lt;/code&gt;，这个函数在哪里呢，继续跟一下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;cmd/kube-scheduler/app/server.go:117&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;/&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;如上，可以看到这里是处理配置问题后调用了一个Run()函数，Run()的作用是基于给定的配置启动scheduler，它只会在出错时或者channel stopCh被关闭时才退出，代码主要部分如下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;cmd/kube-scheduler/app/server.go:167&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;/&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这里最终是要跑&lt;code&gt;sched.Run()&lt;/code&gt;这个方法来启动scheduler，&lt;code&gt;sched.Run()&lt;/code&gt;方法已经在pkg下，具体位置是&lt;code&gt;pkg/scheduler/scheduler.go:276&lt;/code&gt;，也就是scheduler框架真正运行的逻辑了。于是我们已经从main出发，找到了scheduler主框架的入口，具体的scheduler逻辑我们下一讲再来仔细分析。&lt;/p&gt;
&lt;p&gt;最后我们来看一下sched的定义，在linux里我们经常会看到一些软件叫做什么什么d，d也就是daemon，守护进程的意思，也就是一直跑在后台的一个程序。这里的sched也就是“scheduler daemon”的意思。sched的其实是&lt;code&gt;*Scheduler&lt;/code&gt;类型，定义在：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;pkg/scheduler/scheduler.go:58&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;/&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;如上，注释也很清晰，说Scheduler watch新创建的未被调度的pods，然后尝试寻找合适的node，回写一个绑定关系到api server.这里也可以体会到daemon的感觉，我们平时搭建的k8s集群中运行着一个daemon进程叫做kube-scheduler，这个一直跑着的进程做的就是上面注释里说的事情，在程序里面也就对应这样一个对象：Scheduler.&lt;/p&gt;
&lt;p&gt;Scheduler结构体中的Config对象我们再简单看一下：&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p class=&quot;code-filename&quot;&gt;pkg/scheduler/factory/factory.go:96&lt;/p&gt;
&lt;/div&gt;
&lt;pre class=&quot;language-&quot;&gt;
&lt;code class=&quot;lang-go&quot;/&gt;&lt;button class=&quot;copy-code-button&quot;&gt;Copy&lt;/button&gt;
&lt;/pre&gt;
&lt;p&gt;如上，同样我只保留了一些好理解的字段，我们随便扫一下可以看到譬如：SchedulingQueue、NextPod、NodeLister这些很容易从字面上理解的字段，也就是Scheduler对象在工作（完成调度这件事）中需要用到的一些对象。&lt;/p&gt;
&lt;p&gt;ok，下一讲我们开始聊Scheduler的工作过程！&lt;/p&gt;
</description>
<pubDate>Fri, 22 Feb 2019 07:29:00 +0000</pubDate>
<dc:creator>CloudGeek</dc:creator>
<og:description>本文原始地址（gitbook格式）：https://farmer-hutao.github.io/k8s-source-code-analysis/core/scheduler/before-sche</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cloudgeek/p/10418626.html</dc:identifier>
</item>
<item>
<title>使用Rotativa在ASP.NET Core MVC中创建PDF - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/10417056.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/10417056.html</guid>
<description>&lt;p&gt;&lt;span&gt;在本文中，我们将学习如何使用Rotativa.AspNetCore工具从ASP.NET Core中的视图创建PDF。&lt;/span&gt;&lt;span&gt;如果您使用ASP.NET MVC，那么Rot​​ativa工具已经可用，我们可以使用它来生成pdf。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建一个MVC项目，无论您是core或不core，都可以nuget下包.命令如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Install-&lt;span&gt;Package Rotativa
#或者
Install&lt;/span&gt;-Package Rotativa.AspNetCore
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个工具由意大利人Giorgio Bozio创建。&lt;/span&gt;&lt;span&gt;他需要在ASP.NET MVC中生成pdf，并且重复的任务是设置一种方法来创建PDF文档，用于业务流程或报告，下面废话不多说，我们开始吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;在startup.cs类中&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;配置&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;Rotativa.AspNetCore设置&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在Configure方法内的startup.cs类中添加此设置，以设置要访问的wkhtmltopdf.exe文件的相对路径。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            RotativaConfiguration.Setup(env);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 我们需要在wwwroot中添加Rotativa文件夹，然后放入这两个exe，我把这两个文件已经放到了百度云盘。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201902/1366751-20190222142342419-1077014226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我们添加一个Demo控制器，定义一个Get方法，其定义如下，通过ViewAsPdf方法，就可以通过pdf的形式去套住cshtml，也就达到了pdf的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoController : Controller
    {
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult DemoViewAsPdf()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ViewAsPdf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DemoViewAsPdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 就现在，我们需要通过控制器去创建一个视图，然后在视图中有如下定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    ViewData[&quot;Title&quot;] = &quot;DemoViewAsPdf&quot;;
}
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;meta &lt;/span&gt;&lt;span&gt;charset&lt;/span&gt;&lt;span&gt;=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Demo&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;title&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Hello AspNetCore！！&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;body&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在，我们把页面重定与&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
http://localhost:55999/Demo/DemoViewAsPdf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201902/1366751-20190222144819976-381479815.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;边距&lt;/h2&gt;
&lt;p&gt;除了普通的展示pdf，我们还可以进行操作，例如下载，打印。当然如果宽和高不太满意，你可以对视图进行设置，其中有一个类是对视图进行配置的，其定义如下，有四大配置值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Margins
    {
        [OptionFlag(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-B&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;?&lt;span&gt; Bottom;
        [OptionFlag(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-L&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;?&lt;span&gt; Left;
        [OptionFlag(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-R&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;?&lt;span&gt; Right;
        [OptionFlag(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-T&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;?&lt;span&gt; Top;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Margins();
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Margins(&lt;span&gt;int&lt;/span&gt; top, &lt;span&gt;int&lt;/span&gt; right, &lt;span&gt;int&lt;/span&gt; bottom, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; left);

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在控制器中直接new出它，然后直接return，和上面类似，现在你可以将html中的p标签添加一些内容，然后看一下效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult DemoViewAsPdf()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ViewAsPdf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DemoPageMarginsPDF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                PageMargins &lt;/span&gt;= { Left = &lt;span&gt;20&lt;/span&gt;, Bottom = &lt;span&gt;20&lt;/span&gt;, Right = &lt;span&gt;20&lt;/span&gt;, Top = &lt;span&gt;20&lt;/span&gt;&lt;span&gt; },
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 就这样，我们再次启动，可见已经有了外边距！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201902/1366751-20190222145511859-236711881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;横向与纵向&lt;/h2&gt;
&lt;p&gt;它还给我们提供了横向还是竖向的pdf效果，如以下定义：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult DemoViewAsPdf(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; Orientation)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (Orientation == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Portrait&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; demoViewPortrait = &lt;span&gt;new&lt;/span&gt; ViewAsPdf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DemoViewAsPDF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    FileName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invoice.pdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    PageOrientation &lt;/span&gt;=&lt;span&gt; Rotativa.AspNetCore.Options.Orientation.Portrait,
                };
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; demoViewPortrait;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; demoViewLandscape = &lt;span&gt;new&lt;/span&gt; ViewAsPdf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DemoViewAsPDF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                {
                    FileName &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invoice.pdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    PageOrientation &lt;/span&gt;=&lt;span&gt; Rotativa.AspNetCore.Options.Orientation.Landscape,
                };
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; demoViewLandscape;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过 &lt;span class=&quot;cnblogs_code&quot;&gt;http&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:60042/demo/DemoOrientationPDF?Orientation=Portrait&lt;/span&gt;&lt;/span&gt; 或者其它路由进行访问，你对比以下就可以看到效果。&lt;/p&gt;
&lt;h2&gt;设置PDF大小&lt;/h2&gt;
&lt;p&gt; 基本上都是A4,枚举里很多值，自己看~&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult DemoViewAsPdf(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; Orientation)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ViewAsPdf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DemoPageSizePDF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {
                PageSize &lt;/span&gt;=&lt;span&gt; Rotativa.AspNetCore.Options.Size.A4
            };
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;小案例&lt;/h2&gt;
&lt;p&gt; 创建一个模型，这是一个非常简单的模型，定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Customer
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; CustomerID { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Country { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; City { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Phoneno { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在控制器中new几个对象，然后返回pdf。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult DemoViewAsPdf()
        {
            List&lt;/span&gt;&amp;lt;Customer&amp;gt; customerList = &lt;span&gt;new&lt;/span&gt; List&amp;lt;Customer&amp;gt;&lt;span&gt;() {
                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Customer { CustomerID = &lt;span&gt;1&lt;/span&gt;, Address = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Taj Lands Ends 1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, City = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mumbai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , Country =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;India&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Phoneno =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9000000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Customer { CustomerID = &lt;span&gt;2&lt;/span&gt;, Address = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Taj Lands Ends 2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, City = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mumbai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , Country =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;India&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Ram&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Phoneno =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9000000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Customer { CustomerID = &lt;span&gt;3&lt;/span&gt;, Address = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Taj Lands Ends 3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, City = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mumbai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , Country =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;India&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sainesh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Phoneno =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9000000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Customer { CustomerID = &lt;span&gt;4&lt;/span&gt;, Address = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Taj Lands Ends 4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, City = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mumbai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , Country =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;India&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Saineshwar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Phoneno =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9000000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
                 &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Customer { CustomerID = &lt;span&gt;5&lt;/span&gt;, Address = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Taj Lands Ends 5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, City = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mumbai&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; , Country =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;India&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Name =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Saibags&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, Phoneno =&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9000000000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
            };
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ViewAsPdf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DemoModelPDF&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, customerList);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在视图中，我们只是迭代集合，渲染页面。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
@model List&amp;lt;MvcHtmlToPdf.Models.Customer&amp;gt;&lt;span&gt;
@{
    Layout &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Bootstrap Example&amp;lt;/title&amp;gt;
    &amp;lt;meta charset=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;meta name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;viewport&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;width=device-width, initial-scale=1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;div &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;container&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;h2&amp;gt;Customer&amp;lt;/h2&amp;gt;
        &amp;lt;p&amp;gt;Customer Details&amp;lt;/p&amp;gt;
        &amp;lt;table &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;table table-bordered&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;thead&amp;gt;
                &amp;lt;tr&amp;gt;
                    &amp;lt;th&amp;gt;CustomerID&amp;lt;/th&amp;gt;
                    &amp;lt;th&amp;gt;Name&amp;lt;/th&amp;gt;
                    &amp;lt;th&amp;gt;Address&amp;lt;/th&amp;gt;
                    &amp;lt;th&amp;gt;Country&amp;lt;/th&amp;gt;
                    &amp;lt;th&amp;gt;City&amp;lt;/th&amp;gt;
                    &amp;lt;th&amp;gt;Phoneno&amp;lt;/th&amp;gt;
                &amp;lt;/tr&amp;gt;
            &amp;lt;/thead&amp;gt;
            &amp;lt;tbody&amp;gt;&lt;span&gt;

                @foreach (&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; Model)
                {
                    &lt;/span&gt;&amp;lt;tr&amp;gt;
                        &amp;lt;td&amp;gt;@item.CustomerID&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;@item.Name&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;@item.Address&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;@item.Country&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;@item.City&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;@item.Phoneno&amp;lt;/td&amp;gt;
                    &amp;lt;/tr&amp;gt;&lt;span&gt;
                }

            &lt;/span&gt;&amp;lt;/tbody&amp;gt;
        &amp;lt;/table&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201902/1366751-20190222152318052-469625431.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 22 Feb 2019 07:24:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>在本文中，我们将学习如何使用Rotativa.AspNetCore工具从ASP.NET Core中的视图创建PDF。如果您使用ASP.NET MVC，那么Rot​​ativa工具已经可用，我们可以使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/10417056.html</dc:identifier>
</item>
<item>
<title>Mysql数据备份恢复及主从同步 - hwff</title>
<link>http://www.cnblogs.com/fllf/p/10417431.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fllf/p/10417431.html</guid>
<description>&lt;h2 id=&quot;mysql备份&quot;&gt;Mysql备份&lt;/h2&gt;
&lt;h3 id=&quot;mysqldump全量备份&quot;&gt;1. mysqldump全量备份&lt;/h3&gt;
&lt;h4 id=&quot;mysqldump备份原理&quot;&gt;1.1 mysqldump备份原理&lt;/h4&gt;
&lt;p&gt;mysqldump备份数据的过程，实际上就是把数据库从mysql库里以sql语句的形式直接输出并保存成文件的过程,备份的文件/* 到 */都是注释,其余都是sql语句，故备份恢复就相当于把所有sql语句执行一遍&lt;/p&gt;
&lt;h4 id=&quot;msyqldump命令详解&quot;&gt;1.2 msyqldump命令详解&lt;/h4&gt;
&lt;p&gt;语法：mysqldump -u username -p 数据库名 [表名]... &amp;gt; 文件路径&lt;br/&gt;常用选项：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-A 备份所有数据库&lt;/li&gt;
&lt;li&gt;-B DBNAME... #能接多个库，并添加创建库和切换库的语句（使用-B备份的sql文件恢复时不需要指定库，也不用手动创建库）&lt;/li&gt;
&lt;li&gt;-F 切割binlog&lt;/li&gt;
&lt;li&gt;--master-data=1 #1表示执行从库从主库某位置的binlog恢复 ，2表示注释执行语句&lt;/li&gt;
&lt;li&gt;-x #锁表&lt;/li&gt;
&lt;li&gt;-d DBNAME #只备份表结构&lt;/li&gt;
&lt;li&gt;--compact #输出内容减少，用于调试&lt;/li&gt;
&lt;li&gt;--no-create-info|-t #只备份数据&lt;/li&gt;
&lt;li&gt;--single-transaction # 适合innodb事务数据库备份&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;mysqldump备份示例&quot;&gt;1.2 mysqldump备份示例&lt;/h4&gt;
&lt;p&gt;1.备份所有库并压缩&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqldump -u root -p -A   &amp;gt; xx.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.备份某个库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqldump -u root -p -B DBNAME &amp;gt; xx.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.备份多个库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqldump -u root -p -B DBNAME1 DBNAME2 &amp;gt; xx.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;备份恢复&quot;&gt;1.3 备份恢复&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;mysql -uroot -p  &amp;lt; xxx.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;log_bin增量备份&quot;&gt;2.log_bin增量备份&lt;/h3&gt;
&lt;h4 id=&quot;开启log_bin功能&quot;&gt;2.1 开启log_bin功能&lt;/h4&gt;
&lt;p&gt;修改my.cnf中的[mysqld]：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#添加该选项
[mysqld]
log_bin=mysqlbin&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;生成的日志文件存放的是该功能开启后的mysql内部增删改等对数据库有更新内容的sql语句。&lt;/p&gt;
&lt;p&gt;该功能开启前的数据并不能通过这个恢复。所以通常先是使用mysqldump全量备份，之后的数据通过log_bin生成的日志文件来恢复&lt;/p&gt;
&lt;p&gt;若在mysqldump备份时指定了--master-data=1，会将备份数据最后的位置记录下来，则数据恢复时将大大方便log_bin从合理的位置恢复&lt;/p&gt;
&lt;h4 id=&quot;利用mysqlbinlog命令导出sql文件&quot;&gt;2.2 利用mysqlbinlog命令导出sql文件&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;mysqlbinlog  mysql-bin.00001 &amp;gt; 1.sql
#-d DB #只导出指定库sql语句，默认binlog会保存所有库的操作
mysqlbinlog -d test mysql-bin.00001  &amp;gt; 1.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于指定位置导出sql语句：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqlbinlog mysqlbin.00001 --start-position=106 &amp;gt;1.sql #导出从位置106开始到文件结束的sql语句
mysqlbinlog mysqlbin.00001 --stop-position=500 &amp;gt;2.sql #导出从文件开始到位置为500处的sql语句
mysqlbinlog mysqlbin.00001 --start-position=106 --stop-position=500 &amp;gt;3.sql #导出从位置106到500的sql语句&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基于指定时间导出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mysqlbinlog --start-datetime=&quot;2019-02-22 16:52:06&quot; mysqlbin.000001 &amp;gt; 1.sql 
mysqlbinlog --stop-datetime=&quot;2019-02-22 16:52:06&quot; mysqlbin.000001 &amp;gt; 2.sql
mysqlbinlog --start-datetime=&quot;2019-02-22 16:52:06&quot; --stop-datetime=&quot;2019-02-22 17:52:06&quot; mysqlbin.000001 &amp;gt; 3.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;备份恢复-1&quot;&gt;2.3 备份恢复&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;mysql -uroot -p  &amp;lt; 1.sql #通常先将全量备份的数据恢复，然后用msyqlbinlog导出的文件接着全量的恢复后面的数据&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mysql主从同步配置&quot;&gt;Mysql主从同步配置&lt;/h2&gt;
&lt;h3 id=&quot;主从同步过程&quot;&gt;1.1主从同步过程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;1.从库IO线程连接上主库，并请求从指定日志文件的指定位置之后的日志内容&lt;/li&gt;
&lt;li&gt;2.主库收到来自从库的请求后，负责复制的IO线程根据请求信息读取指定日志指定位置之后的日志内容，并返回给从库的IO线程&lt;/li&gt;
&lt;li&gt;3.从库接收到信息后，将接收到的内容依次写到从库的Relaylog文件的最末端，并读取其中主库的bin-log文件名和位置记录到master-info文件中，以便下次读取时能清楚的告诉主库&quot;我需要从bin-log文件的哪个位置开始往后的内容&quot;&lt;/li&gt;
&lt;li&gt;4.从库的SQL进程检测到Relaylog中新增的内容后，会马上解析该文件中的内容，形成SQL语句并执行，从而完成同步&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;配置&quot;&gt;1.2 配置&lt;/h3&gt;
&lt;h4 id=&quot;主库配置&quot;&gt;主库配置&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1.主库开启log_bin 功能，并设置server_id&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[mysqld]
server_id=1111
log_bin=mysqlbin&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2.主库创建主从同步的mysql账号，并授予replication，slave权限&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mysql -e &quot;GRANT replication slave  *.* to 'repl'@'192.168.139.0/255.255.255.0' identified by 'repl'&quot; -uroot -p&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3.主库整库锁表，然后备份已有数据生成sql文件，并拷贝至从库服务器，完成后解锁主库&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mysql -e &quot; flush table with read lock &quot; -uroot -p123456
mysqldump -uroot -p123456 -A --master-data=1 &amp;gt; repl.sql 
scp  repl.sql   root@192.168.139.106:~
mysql -e &quot; unlock   tables &quot; -uroot -p123456&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;从库配置&quot;&gt;从库配置&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;1.设置server_id, 从库一般不需要开启log_bin功能，除非做级联，即同时还作为其他库的主库&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;[mysqld]
server_id=2222 #需要跟主库不一致&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2.先手动复制主库的数据到从库&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mysql -uroot -p123456 &amp;lt; repl.sql&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;3.如果主库配置第三步中，备份数据时没有指定--master-data=1 ，则需要在从库中指定主库信息&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mysql -e  &quot;change master to \
master_host='192.168.139.105', \
master_log_file='mysqlbin.000004',\
master_user='repl',master_password='repl',\
master_log_pos=326 &quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;4.从库开启同步开关&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;mysql -uroot -p123456 -e &quot; start slave;&quot; &lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 22 Feb 2019 07:12:00 +0000</pubDate>
<dc:creator>hwff</dc:creator>
<og:description>[TOC] Mysql备份及主从同步 Mysql备份 1. mysqldump全量备份 1.1 mysqldump备份原理 mysqldump备份数据的过程，实际上就是把数据库从mysql库里以sql</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fllf/p/10417431.html</dc:identifier>
</item>
<item>
<title>面向对象的七大基本原则和实例详解 - 俗的太不一样</title>
<link>http://www.cnblogs.com/qisi007/p/10400652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qisi007/p/10400652.html</guid>
<description>&lt;p&gt;&lt;strong&gt;单一职责原则&lt;/strong&gt;    定义：一个类只负责一个领域的相应职责。&lt;br/&gt;&lt;strong&gt;开闭原则&lt;/strong&gt; 定义：软件实体应对扩展开放，而对修改关闭。&lt;br/&gt;&lt;strong&gt;里氏替换原则&lt;/strong&gt;   定义：所有引用基类的对象能够透明的使用其子类的对象。&lt;br/&gt;&lt;strong&gt;依赖倒转原则&lt;/strong&gt;   定义：抽象不应该依赖于细节，细节依赖于抽象。&lt;br/&gt;&lt;strong&gt;接口隔离原则&lt;/strong&gt;   定义：使用多个专门的接口，而不是使用单一总接口。&lt;br/&gt;&lt;strong&gt;合成复用原则&lt;/strong&gt;   定义：尽量使用对象组合，而不是继承来达到复合目的。&lt;br/&gt;&lt;strong&gt;迪米特法则&lt;/strong&gt;   定义：一个软件实体应当尽可能少的与其它实体发生相互作用。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;1.单一职责原则 ：&lt;/strong&gt; 每个类型（包括接口和抽象）功能要求单一，只对外负责一件事情，应该仅有一个原因引起类的变更。不要让一个类存在多个改变的理由。只应该做和一个任务相关的业务，不应该把过多的业务放在一个类中完成。单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412010/201902/1412010-20190219114531027-733932675.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;把不同类型的文件放在不同的文件夹里做区分，不同功能的文件的划分，文件之间相互引用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;56&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * @author 刘贵生
     * @date:2018-11-2
     * @information:页面初始化数据
     * @param: model 搜索条件
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    pageInit: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ({dispatch},model) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回一个promise，先去请求表头数据，成功之后去请求表格数据和三个考勤率&lt;/span&gt;
       &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise ((resolve,reject) =&amp;gt;&lt;span&gt; {
            dispatch(&lt;/span&gt;'getHeaderData'&lt;span&gt;)
            resolve()
        }).then (() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            let p1 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Promise ((resolve,reject) =&amp;gt;&lt;span&gt; {
                dispatch(&lt;/span&gt;'getTableData'&lt;span&gt;,model)
                resolve()
            })        
            let p2 &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Promise ((resolve,reject) =&amp;gt;&lt;span&gt; {
                dispatch(&lt;/span&gt;'searchPercentage'&lt;span&gt;,model)
                resolve()
            })
            Promise.all([p1,p2])
        })
    },
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * @author 刘贵生
     * @date:2018-11-8
     * @infromation: 请求表头数据
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    getHeaderData: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ({commit}) {
        request.searchTableHeader().then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            commit(type.TABLEHEADER,res.data.result)
        })
    },
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * @author 刘贵生
     * @date:2018-11-2
     * @information: 请求表格数据
     * @param: model 查询的条件
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    getTableData: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ({state,commit},model) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打开正在加载&lt;/span&gt;
        state.loading = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
        let obj &lt;/span&gt;=&lt;span&gt; {
            query:model,
            pages:state.pages,
            sort: state.sort
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; request.searchTableData(obj).then(res =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表格数据和总条数&lt;/span&gt;
            let { data, totalSize } =&lt;span&gt; res.data.result
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取每页请求多少条&lt;/span&gt;
            let { size } =&lt;span&gt; state.pages
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存数据的总长度&lt;/span&gt;
            let num =&lt;span&gt; data.length
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果数据大于0条并且小于每页显示条数，用空数据补齐&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(num &amp;gt; 0 &amp;amp;&amp;amp; num &amp;lt;&lt;span&gt; size) {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(let i = 0;i&amp;lt;size-num;i++&lt;span&gt;) data.push({})
            }     
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向mutation提交状态&lt;/span&gt;
&lt;span&gt;            commit(type.TABLEDATA, data)
            commit(type.TOTALSIZE, totalSize)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关闭正在加载&lt;/span&gt;
            state.loading = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        })
    },

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * @author 刘贵生
     * @date:2018-11-06
     * @information: 查询三个考勤率
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    searchPercentage: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; ({ commit },model) {
        request.searchPercentage(model).then(res &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            commit(type.PERCENTAGE,res.data.result)
        })
    },&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;按照&lt;strong&gt;最小单位&lt;/strong&gt;，拆分不同功能的发法，方法之间项目调用&lt;/p&gt;

&lt;p&gt;原因：这也是灵活的前提，类被修改的几率很大，因此应该专注于单一的功能。如果你把多个功能放在同一个类中，功能之间就形成了关联，改变其中一个功能，有可能中止另一个功能，这时就需要新一轮的测试来避免可能出现的问题。&lt;br/&gt;核心：拆分到最小单位，解决复用和组合问题，封装的优良体现，即解耦和增强内聚性（高内聚，低耦合）。&lt;br/&gt;优点： 降低了类的复杂度，明确了对应的职责、可读性和维护性变高、如果接口单一职责做得好，修改接口影响的仅仅是相应的实现类。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;2.开闭原则&lt;/strong&gt;：一个软件实体应该对扩展开发，对修改关闭。即在设计一个模块的时候，应当使这个模块可以在不被修改的前提下被扩展。开闭原则是设计原则的核心原则，其他的设计原则都是开闭原则表现和补充。实现开闭原则的方法就是抽象。 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
import { CanvasFun } from './canvas.js'&lt;span&gt;
export class CanvasFun {
  constructor (ctx) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ctx =&lt;span&gt; ctx
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 画图片&lt;/span&gt;
&lt;span&gt;  drawImg(param) {
    let { url, left, top, width, height} &lt;/span&gt;=&lt;span&gt; param
     &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ctx.drawImage(url, left, top, width, height)
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 画文字&lt;/span&gt;
&lt;span&gt;  setFont (param) {
    let { color,size,words,x,y } &lt;/span&gt;=&lt;span&gt; param
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ctx.setFillStyle(color)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ctx.setFontSize(size)
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ctx.fillText(words,x,y)
  }
  
}


// 执行命令

export class Commond {
  constructor (ctx) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ctx =&lt;span&gt; ctx
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; []
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将所有的命令添加到一个列表&lt;/span&gt;
&lt;span&gt;  addStep (step) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.list.push(step)
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据不同的类型执行不同的命令&lt;/span&gt;
&lt;span&gt;  run () {
    let { ctx, list} &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;
    let canvas &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CanvasFun (ctx)
    list.map (el &lt;/span&gt;=&amp;gt;&lt;span&gt; {
      canvas[el.type](el.param)
    })
  }
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;commond.addStep({type: &quot;drawImg&quot;,param: {url: that.data.peoplePhote,left: 0,top: 0,width: 600,height: 880}})&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 解决：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;61.5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export class CanvasFun {
  constructor (ctx) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ctx =&lt;span&gt; ctx
  }
}
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 画图片&lt;/span&gt;
&lt;span&gt;class DrawImg extends CanvasFun {
  constructor (url,left,top,width,height) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.url =&lt;span&gt; url
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.left =&lt;span&gt; left 
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.top =&lt;span&gt; top
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width =&lt;span&gt; width
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height
  }
  draw (ctx) {
    ctx.drawImage(url, left, top, width, height)
  }
}
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 画文字&lt;/span&gt;
&lt;span&gt;class DrawText extends CanvasFun {
  constructor(color, size, words, x, y) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.color =&lt;span&gt; color
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.size =&lt;span&gt; size
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.words =&lt;span&gt; words
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.x =&lt;span&gt; x
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.y =&lt;span&gt; y
  }
  draw(ctx) {
    ctx.setFillStyle(color)
    ctx.setFontSize(size)
    ctx.fillText(words, x, y)
  }
}&lt;/span&gt;
&lt;/pre&gt;
&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;export class Commond {&lt;/p&gt;
&lt;p&gt;　　constructor (ctx) {&lt;/p&gt;
&lt;p&gt;　　this.ctx = ctx&lt;/p&gt;
&lt;p&gt;　　this.list = []&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;　　// 将所有的命令添加到一个列表&lt;/p&gt;
&lt;p&gt;　　addStep (step) {&lt;/p&gt;
&lt;p&gt;　　　　this.list.push(step)&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;　　// 根据不同的类型执行不同的命令&lt;/p&gt;
&lt;p&gt;　　run () {&lt;/p&gt;
&lt;p&gt;　　　　let { ctx, list} = this&lt;/p&gt;
&lt;p&gt;　　　　list.map (el =&amp;gt; {&lt;/p&gt;
&lt;p&gt;　　　　el.draw(ctx)&lt;/p&gt;

&lt;p&gt;　　})&lt;/p&gt;
&lt;p&gt;　　　　ctx.draw()&lt;/p&gt;
&lt;p&gt;　　}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span/&gt;
&lt;/pre&gt;
&lt;p&gt;commond.addStep(new DrawImg('../../assets/line_two.png', 0, 0, 750, 550))&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;原因：软件系统的功能上的可扩展性要求模块是扩展开放的，软件系统的功能上的稳定性，持续性要求是修改关闭的。根本控制需求变动风险，缩小维护成本。&lt;br/&gt;核心：用抽象构建框架，用实现类实现扩展，在不修改原有模块的基础上能扩展其功能。&lt;br/&gt;优点： 增加稳定性、可扩展性高。&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;3.替换原则（里氏代换原则）&lt;/strong&gt;：子类能够替换父类，出现在父类能够出现的任何地方，子类必须完全实现父类的方法。在类中调用其他类是务必要使用父类或接口，如果不能使用父类或接口，则说明类的设计已经违背了原则。覆盖或实现父类的方法时输入参数可以被放大。即子类可以重载父类的方法，但输入参数应比父类方法中的大，这样在子类代替父类的时候，调用的仍然是父类的方法。里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的方法应该保持不变，不被子类重新定义。如果继承是为了多态那么，而多态的前提是子类覆盖父类的方法所以将父类定义为抽象类，抽象类不能够实例化对象也就不存在替换这一说。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Rectangle {
  constructor() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height = 0&lt;span&gt;;
  }

  setColor(color) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  }

  render(area) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  }

  setWidth(width) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width =&lt;span&gt; width;
  }

  setHeight(height) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height;
  }

  getArea() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.width * &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.height;
  }
}

class Square extends Rectangle {
  constructor() {
    super();
  }

  setWidth(width) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width =&lt;span&gt; width;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; width;
  }

  setHeight(height) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width =&lt;span&gt; height;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height;
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; renderLargeRectangles(rectangles) {
  rectangles.forEach((rectangle) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    rectangle.setWidth(&lt;/span&gt;4&lt;span&gt;);
    rectangle.setHeight(&lt;/span&gt;5&lt;span&gt;);
    let area &lt;/span&gt;= rectangle.getArea(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; BAD: Will return 25 for Square. Should be 20.&lt;/span&gt;
&lt;span&gt;    rectangle.render(area);
  })
}

let rectangles &lt;/span&gt;= [&lt;span&gt;new&lt;/span&gt; Rectangle(), &lt;span&gt;new&lt;/span&gt; Rectangle(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Square()];
renderLargeRectangles(rectangles);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;解决：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Shape {
  constructor() {}

  setColor(color) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  }

  render(area) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  }
}

class Rectangle extends Shape {
  constructor() {
    super();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height = 0&lt;span&gt;;
  }

  setWidth(width) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.width =&lt;span&gt; width;
  }

  setHeight(height) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.height =&lt;span&gt; height;
  }

  getArea() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.width * &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.height;
  }
}

class Square extends Shape {
  constructor() {
    super();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.length = 0&lt;span&gt;;
  }

  setLength(length) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.length =&lt;span&gt; length;
  }

  getArea() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.length * &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.length;
  }
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; renderLargeShapes(shapes) {
  shapes.forEach((shape) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (shape.constructor.name) {
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'Square'&lt;span&gt;:
        shape.setLength(&lt;/span&gt;5&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 'Rectangle'&lt;span&gt;:
        shape.setWidth(&lt;/span&gt;4&lt;span&gt;);
        shape.setHeight(&lt;/span&gt;5&lt;span&gt;);
    }

    let area &lt;/span&gt;=&lt;span&gt; shape.getArea();
    shape.render(area);
  })
}

let shapes &lt;/span&gt;= [&lt;span&gt;new&lt;/span&gt; Rectangle(), &lt;span&gt;new&lt;/span&gt; Rectangle(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Square()];
renderLargeShapes(shapes);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原因：这是多态的前提，要保证父类的方法不被覆盖。&lt;br/&gt;核心：从开闭原则可以看出，设计模式一个重要的部分是抽象化，里氏代换原则从另一个角度描述了抽象（父类）和具体（子类）之间的关系&lt;br/&gt;优点：总感觉只要是面向对象这个原则是默认遵守的。&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;4.依赖倒转原则：&lt;/strong&gt;具体依赖抽象，上层不依赖于下层。两个模块之间依赖的应该是抽象（接口或抽象类）而不是细节（实现类）。细节（实现类）依赖于抽象（接口或抽象类）。相对于实现类的多变性，抽象的东西要稳定得多，基于抽象的构架也比基于实现的架构更加稳定，且扩展性更高。通过构造函数、setter方法传递依赖对象，接口声明实现依赖对象。要根据接口隔离原则分拆接口时，必须满足单一职责原则。想要理解依赖倒置原则，必须先理解传统的解决方案。面相对象的初期的程序，被调用者依赖于调用者。也就是调用者决定被调用者有什么方法，有什么样的实现方式，这种结构在需求变更的时候，会付出很大的代价，甚至推翻重写。依赖倒置原则就是要求调用者和被调用者都依赖抽象，这样两者没有直接的关联和接触，在变动的时候，一方的变动不会影响另一方的变动。&lt;/p&gt;
&lt;p&gt;下面看一个实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
import ElementUI from 'element-ui' &lt;span&gt;//&lt;/span&gt;&lt;span&gt; vue的ui组件-（饿了么-ui）element-ui&lt;/span&gt;
Vue.use(ElementUI)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实就是我们的需要的模块依赖vue模块，main.js就是vue模块抽象出来的接口，这里使用Vue.use()，把我们需要的模块vue注入进来，然后我们就可以用它了。&lt;/p&gt;

&lt;p&gt;实例2：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36.5&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Tracker {
        constructor (item) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item =&lt;span&gt; item
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.requester = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; request ()
        }
        requestItems () {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item.forEach(el =&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requester.requestItem(item)
            });
        }
    }

    class Request {
        constructor () {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type = [&quot;HTTP&quot;]&lt;span&gt;
        }
        requestItem () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;        }
    }&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;let useTracker = new Tracker(['apples',&quot;banans&quot;])&lt;/p&gt;
&lt;p&gt;useTracker.requestItems()&lt;/p&gt;
&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt; &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很显然Tracker的构造器中有一段错误的代码，this.requester只实现了&lt;strong&gt;对特定的请求&lt;/strong&gt;，我们再来改造一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    class Tracker {
        constructor (item,res) {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item =&lt;span&gt; item
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.requester =&lt;span&gt; res
        }
        requestItems () {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.item.forEach(el =&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.requester.requestItem(item)
            });
        }
    }

    class Request1 {
        constructor () {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type = &quot;HTTP&quot;&lt;span&gt;
        }
        requestItem () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;        }
    }

    class Request2 {
        constructor () {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type = ['ws'&lt;span&gt;]
        }
        requestItem () {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;        }
    }
    let useTracker &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Tracker (['apples','banbans'],&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Request2)
    useTracker.requestItems()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;原因：依赖抽象的接口可以适应变化的需求。防止需求变化时对被依赖者的改变过大。&lt;br/&gt;核心：要依赖于抽象，面向抽象编程，不要依赖于具体的实现，思想是面向接口编程。高层模块不应该依赖低层模块，两者都应该依赖其抽象（抽象类或接口）。解耦调用和被调用者。&lt;br/&gt;优点：采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，减少并行开发引起的风险，提高代码的可读性和可维护性。从大局看Java的多态就属于这个原则。&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.接口隔离原则：&lt;/strong&gt;模块间要通过具体接口分离开，而不是通过类强耦合。一个接口不需要提供太多的行为，一个接口应该只提供一种对外的功能，不应该把所有的操作都封装到一个接口当中。分离接口的两种实现方法：使用委托分离接口和使用多重继承分离接口。例如A类对B类的依赖，可以抽象接口I，B实现I，A类依赖I来实现。但是抽象接口必须功能最小化（与单一功能原则有点不谋而合）。建立单一接口，不要建立庞大的接口，尽量细化接口，接口中的方法尽量少。也就是要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的约定，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。&lt;/p&gt;
&lt;p&gt;原因：是单一职责的必要手段，尽量使用职能单一的接口，而不使用职能复杂、全面的接口。接口是为了让子类实现的，如果想达到职能单一那么接口也必须满足职能单一。如果接口融合了多个不相关的方法，那子类就被迫实现所有方法，尽管有些方法是根本用不到的。这就是接口污染。&lt;br/&gt;核心：拆分，从接口开始。不应该强迫客户程序依赖他们不需要使用的接口，一个类对另一个类的依赖应该建立在最小的接口上。 使用专门的接口，比用统一的接口要好。&lt;br/&gt;优点：降低耦合性、提升代码可读性、影藏实现细节。&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.合成复用原则&lt;/strong&gt;：复用的种类： 继承、合成聚合，在复用时应优先考虑使用合成聚合而不是继承。尽量使用对象组合，而不是继承来达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。为了达到代码复用的目的，尽量使用组合与聚合，而不是继承。组合聚合只是引用其他的类的方法，而不会受引用的类的继承而改变血统。&lt;/p&gt;
&lt;p&gt;原因：继承的耦合性更大，比如一个父类后来添加实现一个接口或者去掉一个接口，那子类可能会遭到毁灭性的编译错误，但如果只是组合聚合，只是引用类的方法，就不会有这种巨大的风险，同时也实现了复用。&lt;br/&gt;核心：多使用聚合/组合达到代码的重用，少使用继承复用。 &lt;br/&gt;优点：组合/聚合复用原则可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;7.迪米特原则：&lt;/strong&gt;最小依赖原则又叫最少知识原则，一个类对其他类尽可能少的了解。在模块之间只通过接口来通信，而不理会模块的内部工作原理，可以使各个模块的耦合成都降到最低，促进软件的复用在类的划分上，应该创建有弱耦合的类；在类的结构设计上，每一个类都应当尽量降低成员的访问权限；在类的设计上，只要有可能，一个类应当设计成不变；在对其他类的引用上，一个对象对其它对象的引用应当降到最低；尽量降低类的访问权限；谨慎使用序列化功能；不要暴露类成员，而应该提供相应的访问器(属性)。要求类之间的直接联系尽量的少，两个类的访问，通过第三个中介类来实现。每个对象都会与其他对象有耦合关系，出现成员变量、方法参数、方法返回值中的类为直接的耦合依赖，而出现在局部变量中的类则不是直接耦合依赖，也就是说不是直接耦合依赖的类最好不要作为局部变量的形式出现在类的内部。&lt;/p&gt;
&lt;p&gt;原因：一个类如果暴露太多私用的方法和字段，会让调用者很茫然。并且会给类造成不必要的判断代码。所以，我们使用尽量低的访问修饰符，让外界不知道我们的内部。这也是面向对象的基本思路。这是迪米特原则的一个特性，无法了解类更多的私有信息。&lt;br/&gt;核心：一个对象应当对其他对象有尽可能少的了解，软件实体应当尽可能少的与其他实体发生相互作用。意思就是降低各个对象之间的耦合，要求尽量的封装，尽量的独立，尽量的使用低级别的访问修饰符以提高系统的可维护性。&lt;br/&gt;优点：降低耦合度、增加稳定性。&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1) 高内聚、低耦合和单一职能的“冲突”：实际上，这两者是一回事。内聚，要求一个类把所有相关的方法放在一起，初看是职能多，但有个“高”，就是要求把联系非常紧密的功能放在一起，从整体看是一个职能的才能放在一起，所以两者是不同的表述而已。&lt;br/&gt; &lt;br/&gt;2)多个单一职能接口的灵活性和声明类型问题：如果一个类实现多个接口，那么这个类应该用哪个接口类型声明呢？应该是用一个抽象类来继承多个接口，而实现类来继承这个接口。声明的时候，类型是抽象类。&lt;br/&gt; &lt;br/&gt;3)最少知识原则和中介类泛滥两种极端情况：这是另一种设计的失误。迪米特原则要求类之间要用中介来通讯，但类多了以后，会造成中介类泛滥的情况，这种情况，我们可以考虑中介模式，用一个总的中介类来实现。当然，设计模式都有自己的缺陷，迪米特原则也不是十全十美，交互类非常繁多的情况下，要适当的牺牲设计原则。&lt;br/&gt; &lt;br/&gt;4)继承和组合聚合复用原则的“冲突”：继承也能实现复用，那这个原则是不是要抛弃继承了？不是的。继承更注重的是“血统”，也就是什么类型的。而组合聚合更注重的是借用“技能”。并且，组合聚合中，两个类是部分与整体的关系，组合聚合可以由多个类的技能组成。这个原则不是告诉我们不用继承了都用组合聚合，而是在“复用”这个点上，我们优先使用组合聚合。&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;所以可以看出前辈们给定我们这些原则，实际上是为了1、降低耦合度；2、提高稳定性；3、增加可读和可维护性；4、提高扩展性。同时发现，上面的原则的根本就是让我们尽量在定义好核心类之后用相应的接口去实现核心类的其他方法，在引入时尽量引入接口。所以面向对象变成的精髓之一就是面向接口编程。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Feb 2019 07:07:00 +0000</pubDate>
<dc:creator>俗的太不一样</dc:creator>
<og:description>单一职责原则 定义：一个类只负责一个领域的相应职责。开闭原则 定义：软件实体应对扩展开放，而对修改关闭。里氏替换原则 定义：所有引用基类的对象能够透明的使用其子类的对象。依赖倒转原则 定义：抽象不应该</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qisi007/p/10400652.html</dc:identifier>
</item>
<item>
<title>#3   Python面向对象（二） - MinuteSheep</title>
<link>http://www.cnblogs.com/minutesheep/p/10416283.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/minutesheep/p/10416283.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;上一节主要记录面向对象编程的思想以及Python类的简单创建，这节继续深入类中变量的相关知识，Here we go！&lt;/p&gt;
&lt;h3&gt;Python中类的各种变量&lt;/h3&gt;
&lt;h4&gt;1.1 类变量&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;类变量定义：&lt;/strong&gt;在类中，在函数体（方法）外的变量称为类变量。类变量在整个类中是公用的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;类变量初始化：&lt;/strong&gt;按照以上定义，类变量的初始化如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    类变量的初始化
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     salary = 100  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; salary为类变量&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk():
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am a doctor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;类变量访问：&lt;/strong&gt;因为类变量在整个类中是公用的，所以在不同的环境下都能访问。在&lt;span&gt;类中函数体&lt;/span&gt;外直接使用 &lt;span class=&quot;cnblogs_code&quot;&gt;类变量&lt;/span&gt; 访问；在&lt;span&gt;类中函数体内&lt;/span&gt;使用 &lt;span class=&quot;cnblogs_code&quot;&gt;类.类变量&lt;/span&gt; 或者 &lt;span class=&quot;cnblogs_code&quot;&gt;实例.类变量&lt;/span&gt; 访问；在&lt;span&gt;类外&lt;/span&gt;使用 &lt;span class=&quot;cnblogs_code&quot;&gt;类.类变量&lt;/span&gt; 或者 &lt;span class=&quot;cnblogs_code&quot;&gt;实例.类变量&lt;/span&gt;访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    在类中函数体外访问类变量salary
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    salary &lt;/span&gt;= 100
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am a doctor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


lisi &lt;/span&gt;= Doctor()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一旦实例化后，就会自动按顺序执行类中函数体外的代码&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
100
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    在类中函数体内访问类变量salary
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    salary &lt;/span&gt;= 100

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk0(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        使用类.类变量访问
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;My salary is {0}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(Doctor.salary))

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk1(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        使用实例.类变量访问
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;My salary is {0}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.format(self.salary))


lisi &lt;/span&gt;=&lt;span&gt; Doctor()

lisi.talk0()
lisi.talk1()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
My salary &lt;span&gt;is&lt;/span&gt; 100&lt;span&gt;
My salary &lt;/span&gt;&lt;span&gt;is&lt;/span&gt; 100
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    在类外访问类变量salary
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    salary &lt;/span&gt;= 100

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am a doctor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


lisi &lt;/span&gt;=&lt;span&gt; Doctor()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(Doctor.salary)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用 类.类变量 访问&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(lisi.salary)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用 实例.类变量 访问&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
100
100
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.2 实例变量&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;实例变量定义：&lt;/strong&gt;在类中，在函数体（方法）内的变量称为实例变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例变量初始化：&lt;/strong&gt;按照上面定义，实例变量的初始化如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;    初始化实例变量
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         self.sentence = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am man&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; self.sentence 为实例变量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;实例变量访问：&lt;/strong&gt;实例变量在整个类中并不是公用的，所以其访问范围有限。在&lt;span&gt;类中函数体内&lt;/span&gt;使用 &lt;span class=&quot;cnblogs_code&quot;&gt;实例.实例变量&lt;/span&gt; 访问；在&lt;span&gt;类外&lt;/span&gt;使用 &lt;span class=&quot;cnblogs_code&quot;&gt;实例.实例变量&lt;/span&gt; 访问&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    类中函数体内的访问
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        self.sentence &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am man&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化实例变量self.sentence&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.sentence)   &lt;span&gt;# 访问实例变量&lt;/span&gt;


lisi &lt;/span&gt;=&lt;span&gt; Doctor()

lisi.talk()  &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 调用talk方法&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
I am man
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
    类外访问实例变量
    &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        self.sentence &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am man&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化实例变量self.sentence&lt;/span&gt;
&lt;span&gt;

lisi &lt;/span&gt;=&lt;span&gt; Doctor()

lisi.talk()  &lt;/span&gt;&lt;span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 必须先执行talk方法才能访问talk方法里面的实例变量&lt;/span&gt;&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(lisi.sentence)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 类外访问实例变量&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.3 类变量、实例变量与全局变量、局部变量的异同点&lt;/h4&gt;
&lt;p&gt;在Python基础教程中讲解了&lt;a href=&quot;https://www.cnblogs.com/minutesheep/p/10337404.html&quot;&gt;全局变量与局部变量&lt;/a&gt;的相关知识，本节提到的两个变量与它们有什么异同呢？&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;绝对来说，类变量与实例变量都是局部变量&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;相对来说，在类中，类变量相当于全局变量，但实例变量并不相当于局部变量，更不相当于全局变量&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;相对来说，在实例中，类变量和实例变量都相当于全局变量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;相对来说，在类中的方法里，才有局部变量，初始化的时候不是定义 &lt;span class=&quot;cnblogs_code&quot;&gt;实例.实例变量&lt;/span&gt; ，而是直接定义 &lt;span class=&quot;cnblogs_code&quot;&gt;变量&lt;/span&gt; &lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 一下子说的这么复杂难以理解，举个栗子🌰就明白了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
    salary &lt;/span&gt;= 100

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
    ¦   &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;I am a doctor&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)


&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; salary是Doctor的类变量，在类中定义&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 但在主程序中并不能被正确访问&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 因为salary变量是局部变量&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt;Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 8, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary)
NameError: name &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; defined

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 抛出变量未定义异常&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        self.salary &lt;/span&gt;= 100


&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 同样，实例变量self.salary也是局部变量&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt;Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 6, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary)
NameError: name &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; defined

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 抛出变量未定义异常&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        self.salary &lt;/span&gt;= 100
&lt;span&gt;

Doctor().talk()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 即使执行了talk方法，也不能正确访问&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 因为它至始至终都是局部变量&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
&lt;span&gt;Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;9.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 12, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary)
NameError: name &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; defined
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
    salary &lt;/span&gt;= 100
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(Doctor.salary)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(Doctor.salary)


lisi &lt;/span&gt;=&lt;span&gt; Doctor()
lisi.talk()
lisi.eat()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因为类变量在整个类中都是共有的&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 因此类变量能被类中的方法访问&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 换句话说，在类中类变量相当于全局变量&lt;p&gt;# 运行结果：&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;  100&lt;br/&gt;  100&lt;br/&gt;  100&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
    salary &lt;/span&gt;= 100
    &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        self.food &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;BaoZi&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(Doctor.salary)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.food)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(Doctor.salary)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(self.food)


lisi &lt;/span&gt;=&lt;span&gt; Doctor()
lisi.talk()
lisi.eat()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在talk方法里面定义实例变量self.food&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 但是在eat方法里面却可以访问self.food这个实例变量&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;（前提是必须先运行talk方法，就相当于初始化self.food）&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 因此，在实例中，类变量和实例变量都相当于全局变量&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;  100&lt;br/&gt;  100&lt;br/&gt;  BaoZi&lt;br/&gt;  100&lt;br/&gt;  BaoZi&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk(self):
        salary &lt;/span&gt;= 100
        &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary)

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; eat(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary)


lisi &lt;/span&gt;=&lt;span&gt; Doctor()
lisi.talk()
lisi.eat()

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 在类中talk方法里定义局部变量salary&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 在其他方法中是不能被访问的&lt;/span&gt;


&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
100&lt;span&gt;
Traceback (most recent call last):
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;12.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 13, &lt;span&gt;in&lt;/span&gt; &amp;lt;module&amp;gt;&lt;span&gt;
    lisi.eat()
  File &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;12.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, line 8, &lt;span&gt;in&lt;/span&gt;&lt;span&gt; eat
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(salary)
NameError: name &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;salary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; defined
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;1.4 类变量和实例变量注意事项&lt;/h4&gt;
&lt;p&gt;「类变量在类中函数体内有两种访问方式： &lt;span class=&quot;cnblogs_code&quot;&gt;类.类变量&lt;/span&gt; 和 &lt;span class=&quot;cnblogs_code&quot;&gt;实例.类变量&lt;/span&gt; ，这两种方式会带来不同的后果。使用 &lt;span class=&quot;cnblogs_code&quot;&gt;实例.类变量&lt;/span&gt; 访问类变量后，其实是重新创建了一个新的实例变量： &lt;span class=&quot;cnblogs_code&quot;&gt;实例.实例变量&lt;/span&gt; ，与类变量已经无关了」&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Doctor:
    salary &lt;/span&gt;= 100  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 初始化类变量salary&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk0(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;talk0:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, Doctor.salary)
        Doctor.salary &lt;/span&gt;= 200   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改类变量salary的值为200&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk1(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;talk1:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, Doctor.salary)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;talk1:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self.salary)
        self.salary &lt;/span&gt;= 300   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 修改self.salary的值为300&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; talk2(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;talk2:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self.salary)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;talk2:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, Doctor.salary)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出的类变量并没有被改变为300&lt;/span&gt;
&lt;span&gt;

lisi &lt;/span&gt;=&lt;span&gt; Doctor()

lisi.talk0()
lisi.talk1()
lisi.talk2()


&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 运行结果：&lt;/span&gt;
talk0: 100&lt;span&gt;
talk1: &lt;/span&gt;200&lt;span&gt;
talk1: &lt;/span&gt;200&lt;span&gt;
talk2: &lt;/span&gt;300&lt;span&gt;
talk2: &lt;/span&gt;200
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;强烈建议：类变量的访问方法用 &lt;span class=&quot;cnblogs_code&quot;&gt;类.类变量&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;本小节介绍了Python中类的各种变量知识，在实际使用中要有深刻的理解才行。之后会记录类的传参、类的性质、类的属性方法等，拜拜～～&lt;/p&gt;
</description>
<pubDate>Fri, 22 Feb 2019 07:04:00 +0000</pubDate>
<dc:creator>MinuteSheep</dc:creator>
<og:description>本篇博文主要记录Python中类的各种变量</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/minutesheep/p/10416283.html</dc:identifier>
</item>
<item>
<title>Springboot 系列（七）Spring Boot web 开发之异常错误处理机制剖析 - 雪漫士兵</title>
<link>http://www.cnblogs.com/niumoo/p/10418173.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/10418173.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;相信大家在刚开始体验 Springboot 的时候一定会经常碰到这个页面，也就是访问一个不存在的页面的默认返回页面。&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-d8abfb5a716d8f3a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Spring Boot 默认错误页面&quot;/&gt;&lt;/div&gt;
如果是其他客户端请求，如接口测试工具，会默认返回JSON数据。
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
        &quot;timestamp&quot;:&quot;2019-01-06 22:26:16&quot;,
        &quot;status&quot;:404,
        &quot;error&quot;:&quot;Not Found&quot;,
        &quot;message&quot;:&quot;No message available&quot;,
        &quot;path&quot;:&quot;/asdad&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显，SpringBoot 根据 HTTP 的请求头信息进行了不同的响应处理。&lt;a href=&quot;https://www.codingme.net/2018/07/computer/protocol-http/&quot;&gt;HTTP 相关知识可以参考此处&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;springboot-异常处理机制&quot;&gt;1. SpringBoot 异常处理机制&lt;/h2&gt;
&lt;p&gt;追随 SpringBoot 源码可以分析出默认的错误处理机制。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration
// 绑定一些错误信息 记为 1
    @Bean
    @ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)
    public DefaultErrorAttributes errorAttributes() {
        return new DefaultErrorAttributes(
                this.serverProperties.getError().isIncludeException());
    }
// 默认处理 /error 记为 2
    @Bean
    @ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)
    public BasicErrorController basicErrorController(ErrorAttributes errorAttributes) {
        return new BasicErrorController(errorAttributes, this.serverProperties.getError(),
                this.errorViewResolvers);
    }
// 错误处理页面 记为3
    @Bean
    public ErrorPageCustomizer errorPageCustomizer() {
        return new ErrorPageCustomizer(this.serverProperties, this.dispatcherServletPath);
    }
    @Configuration
    static class DefaultErrorViewResolverConfiguration {

        private final ApplicationContext applicationContext;

        private final ResourceProperties resourceProperties;

        DefaultErrorViewResolverConfiguration(ApplicationContext applicationContext,
                ResourceProperties resourceProperties) {
            this.applicationContext = applicationContext;
            this.resourceProperties = resourceProperties;
        }
// 决定去哪个错误页面 记为4
        @Bean
        @ConditionalOnBean(DispatcherServlet.class)
        @ConditionalOnMissingBean
        public DefaultErrorViewResolver conventionErrorViewResolver() {
            return new DefaultErrorViewResolver(this.applicationContext,
                    this.resourceProperties);
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结合上面的注释，上面代码里的四个方法就是 Springboot 实现默认返回错误页面主要部分。&lt;/p&gt;
&lt;h3 id=&quot;errorattributes&quot;&gt;1.1. errorAttributes&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;errorAttributes&lt;/code&gt;直译为错误属性，这个方法确实如此，直接追踪源代码。&lt;br/&gt;代码位于：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// org.springframework.boot.web.servlet.error.DefaultErrorAttributes&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类里为错误情况共享很多错误信息，如。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;errorAttributes.put(&quot;timestamp&quot;, new Date());
errorAttributes.put(&quot;status&quot;, status);
errorAttributes.put(&quot;error&quot;, HttpStatus.valueOf(status).getReasonPhrase());
errorAttributes.put(&quot;errors&quot;, result.getAllErrors());
errorAttributes.put(&quot;exception&quot;, error.getClass().getName());
errorAttributes.put(&quot;message&quot;, error.getMessage());
errorAttributes.put(&quot;trace&quot;, stackTrace.toString());
errorAttributes.put(&quot;path&quot;, path);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些信息用作共享信息返回，所以当我们使用模版引擎时，也可以像取出其他参数一样轻松取出。&lt;/p&gt;
&lt;h3 id=&quot;basicerrorcontroll&quot;&gt;1.2. basicErrorControll&lt;/h3&gt;
&lt;p&gt;直接追踪 &lt;code&gt;BasicErrorController&lt;/code&gt; 的源码内容可以发现下面的一段代码。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController
@Controller
// 定义请求路径，如果没有error.path路径，则路径为/error
@RequestMapping(&quot;${server.error.path:${error.path:/error}}&quot;)
public class BasicErrorController extends AbstractErrorController {
  
    // 如果支持的格式 text/html
    @RequestMapping(produces = MediaType.TEXT_HTML_VALUE)
    public ModelAndView errorHtml(HttpServletRequest request,
            HttpServletResponse response) {
        HttpStatus status = getStatus(request);
        // 获取要返回的值
        Map&amp;lt;String, Object&amp;gt; model = Collections.unmodifiableMap(getErrorAttributes(
                request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));
        response.setStatus(status.value());
        // 解析错误视图信息，也就是下面1.4中的逻辑
        ModelAndView modelAndView = resolveErrorView(request, response, status, model);
        // 返回视图，如果没有存在的页面模版，则使用默认错误视图模版
        return (modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model);
    }

    @RequestMapping
    public ResponseEntity&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; error(HttpServletRequest request) {
        // 如果是接受所有格式的HTTP请求
        Map&amp;lt;String, Object&amp;gt; body = getErrorAttributes(request,
                isIncludeStackTrace(request, MediaType.ALL));
        HttpStatus status = getStatus(request);
        // 响应HttpEntity
        return new ResponseEntity&amp;lt;&amp;gt;(body, status);
    }  
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上可知，&lt;code&gt;basicErrorControll&lt;/code&gt; 用于创建用于请求返回的 &lt;code&gt;controller&lt;/code&gt;类，并根据HTTP请求可接受的格式不同返回对应的信息，所以在使用浏览器和接口测试工具测试时返回结果存在差异。&lt;/p&gt;
&lt;h3 id=&quot;ererrorpagecustomizer&quot;&gt;1.3. ererrorPageCustomizer&lt;/h3&gt;
&lt;p&gt;直接查看方法里的&lt;code&gt;new ErrorPageCustomizer(this.serverProperties, this.dispatcherServletPath);&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration.ErrorPageCustomizer
    /**
     * {@link WebServerFactoryCustomizer} that configures the server's error pages.
     */
    private static class ErrorPageCustomizer implements ErrorPageRegistrar, Ordered {

        private final ServerProperties properties;

        private final DispatcherServletPath dispatcherServletPath;

        protected ErrorPageCustomizer(ServerProperties properties,
                DispatcherServletPath dispatcherServletPath) {
            this.properties = properties;
            this.dispatcherServletPath = dispatcherServletPath;
        }
        // 注册错误页面
        // this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath())
        @Override
        public void registerErrorPages(ErrorPageRegistry errorPageRegistry) {
            //getPath()得到如下地址，如果没有自定义error.path属性，则去/error位置
            //@Value(&quot;${error.path:/error}&quot;)
            //private String path = &quot;/error&quot;;
            ErrorPage errorPage = new ErrorPage(this.dispatcherServletPath
                    .getRelativePath(this.properties.getError().getPath()));
            errorPageRegistry.addErrorPages(errorPage);
        }

        @Override
        public int getOrder() {
            return 0;
        }

    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上可知，当遇到错误时，如果没有自定义 &lt;code&gt;error.path&lt;/code&gt; 属性，则请求转发至 &lt;code&gt;/error&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&quot;conventionerrorviewresolver&quot;&gt;1.4. conventionErrorViewResolver&lt;/h3&gt;
&lt;p&gt;根据上面的代码，一步步深入查看 SpringBoot 的默认错误处理实现，查看看 &lt;code&gt;conventionErrorViewResolver&lt;/code&gt;方法。下面是 DefaultErrorViewResolver 类的部分代码，注释解析。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// org.springframework.boot.autoconfigure.web.servlet.error.DefaultErrorViewResolver
    
// 初始化参数，key 是HTTP状态码第一位。
    static {
        Map&amp;lt;Series, String&amp;gt; views = new EnumMap&amp;lt;&amp;gt;(Series.class);
        views.put(Series.CLIENT_ERROR, &quot;4xx&quot;);
        views.put(Series.SERVER_ERROR, &quot;5xx&quot;);
        SERIES_VIEWS = Collections.unmodifiableMap(views);
    }
    @Override
    public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status,
            Map&amp;lt;String, Object&amp;gt; model) {
        // 使用HTTP完整状态码检查是否有页面可以匹配
        ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);
        if (modelAndView == null &amp;amp;&amp;amp; SERIES_VIEWS.containsKey(status.series())) {
            // 使用 HTTP 状态码第一位匹配初始化中的参数创建视图对象
            modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);
        }
        return modelAndView;
    }

    
    private ModelAndView resolve(String viewName, Map&amp;lt;String, Object&amp;gt; model) {
        // 拼接错误视图路径 /eroor/[viewname]
        String errorViewName = &quot;error/&quot; + viewName;
        // 使用模版引擎尝试创建视图对象
        TemplateAvailabilityProvider provider = this.templateAvailabilityProviders
                .getProvider(errorViewName, this.applicationContext);
        if (provider != null) {
            return new ModelAndView(errorViewName, model);
        }
        // 没有模版引擎，使用静态资源文件夹解析视图
        return resolveResource(errorViewName, model);
    }

    private ModelAndView resolveResource(String viewName, Map&amp;lt;String, Object&amp;gt; model) {
        // 遍历静态资源文件夹,检查是否有存在视图
        for (String location : this.resourceProperties.getStaticLocations()) {
            try {
                Resource resource = this.applicationContext.getResource(location);
                resource = resource.createRelative(viewName + &quot;.html&quot;);
                if (resource.exists()) {
                    return new ModelAndView(new HtmlResourceView(resource), model);
                }
            }
            catch (Exception ex) {
            }
        }
        return null;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而 Thymeleaf 对于错误页面的解析实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider
public class ThymeleafTemplateAvailabilityProvider
        implements TemplateAvailabilityProvider {
    @Override
    public boolean isTemplateAvailable(String view, Environment environment,
            ClassLoader classLoader, ResourceLoader resourceLoader) {
        if (ClassUtils.isPresent(&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;,
                classLoader)) {
            String prefix = environment.getProperty(&quot;spring.thymeleaf.prefix&quot;,
                    ThymeleafProperties.DEFAULT_PREFIX);
            String suffix = environment.getProperty(&quot;spring.thymeleaf.suffix&quot;,
                    ThymeleafProperties.DEFAULT_SUFFIX);
            return resourceLoader.getResource(prefix + view + suffix).exists();
        }
        return false;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从而我们可以得知，错误页面首先会检查&lt;code&gt;模版引擎&lt;/code&gt;文件夹下的 &lt;code&gt;/error/HTTP状态码&lt;/code&gt; 文件，如果不存在，则检查去模版引擎下的&lt;code&gt;/error/4xx&lt;/code&gt;或者 &lt;code&gt;/error/5xx&lt;/code&gt; 文件，如果还不存在，则检查&lt;code&gt;静态资源&lt;/code&gt;文件夹下对应的上述文件。&lt;/p&gt;
&lt;h2 id=&quot;自定义异常页面&quot;&gt;2. 自定义异常页面&lt;/h2&gt;
&lt;p&gt;经过上面的 SpringBoot 错误机制源码分析，知道当遇到错误情况时候，SpringBoot 会首先返回到&lt;code&gt;模版引擎&lt;/code&gt;文件夹下的 &lt;code&gt;/error/HTTP&lt;/code&gt;状态码 文件，如果不存在，则检查去模版引擎下的&lt;code&gt;/error/4xx&lt;/code&gt;或者 &lt;code&gt;/error/5xx&lt;/code&gt; 文件，如果还不存在，则检查&lt;code&gt;静态资源&lt;/code&gt;文件夹下对应的上述文件。并且在返回时会共享一些错误信息，这些错误信息可以在模版引擎中直接使用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;errorAttributes.put(&quot;timestamp&quot;, new Date());
errorAttributes.put(&quot;status&quot;, status);
errorAttributes.put(&quot;error&quot;, HttpStatus.valueOf(status).getReasonPhrase());
errorAttributes.put(&quot;errors&quot;, result.getAllErrors());
errorAttributes.put(&quot;exception&quot;, error.getClass().getName());
errorAttributes.put(&quot;message&quot;, error.getMessage());
errorAttributes.put(&quot;trace&quot;, stackTrace.toString());
errorAttributes.put(&quot;path&quot;, path);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此，需要自定义错误页面，只需要在模版文件夹下的 error 文件夹下防止4xx 或者 5xx 文件即可。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&amp;gt;
    &amp;lt;title&amp;gt;[[${status}]]&amp;lt;/title&amp;gt;
    &amp;lt;!-- Bootstrap core CSS --&amp;gt;
    &amp;lt;link href=&quot;/webjars/bootstrap/4.1.3/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body &amp;gt;
&amp;lt;div class=&quot;m-5&quot; &amp;gt;
    &amp;lt;p&amp;gt;错误码：[[${status}]]&amp;lt;/p&amp;gt;
    &amp;lt;p &amp;gt;信息：[[${message}]]&amp;lt;/p&amp;gt;
    &amp;lt;p &amp;gt;时间：[[${#dates.format(timestamp,'yyyy-MM-dd hh:mm:ss ')}]]&amp;lt;/p&amp;gt;
    &amp;lt;p &amp;gt;请求路径：[[${path}]]&amp;lt;/p&amp;gt;
&amp;lt;/div&amp;gt;

&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随意访问不存在路径得到。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-1ca4988478680154.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Spring Boot 自定义错误页面&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;自定义错误json&quot;&gt;3. 自定义错误JSON&lt;/h2&gt;
&lt;p&gt;根据上面的 SpringBoot 错误处理原理分析，得知最终返回的 JSON 信息是从一个 map 对象中转换出来的，那么，只要能自定义 map 中的值，就可以自定义错误信息的 json 格式了。直接重写 &lt;code&gt;DefaultErrorAttributes&lt;/code&gt;类的 &lt;code&gt;getErrorAttributes&lt;/code&gt; 方法即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.boot.web.servlet.error.DefaultErrorAttributes;
import org.springframework.stereotype.Component;
import org.springframework.web.context.request.WebRequest;

import java.util.HashMap;
import java.util.Map;

/**
 * &amp;lt;p&amp;gt;
 * 自定义错误信息JSON值
 *
 * @Author niujinpeng
 * @Date 2019/1/7 15:21
 */
@Component
public class ErrorAttributesCustom extends DefaultErrorAttributes {

    @Override
    public Map&amp;lt;String, Object&amp;gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) {
        Map&amp;lt;String, Object&amp;gt; map = super.getErrorAttributes(webRequest, includeStackTrace);
        String code = map.get(&quot;status&quot;).toString();
        String message = map.get(&quot;error&quot;).toString();
        HashMap&amp;lt;String, Object&amp;gt; hashMap = new HashMap&amp;lt;&amp;gt;();
        hashMap.put(&quot;code&quot;, code);
        hashMap.put(&quot;message&quot;, message);
        return hashMap;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 postman 请求测试。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-d0c6992337171dad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;统一异常处理&quot;&gt;4. 统一异常处理&lt;/h2&gt;
&lt;p&gt;使用 &lt;code&gt;@ControllerAdvice&lt;/code&gt; 结合&lt;code&gt;@ExceptionHandler&lt;/code&gt; 注解可以实现统一的异常处理，&lt;code&gt;@ExceptionHandler&lt;/code&gt;注解的类会自动应用在每一个被 &lt;code&gt;@RequestMapping&lt;/code&gt; 注解的方法。当程序中出现异常时会层层上抛&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import lombok.extern.slf4j.Slf4j;
import net.codingme.boot.domain.Response;
import net.codingme.boot.enums.ResponseEnum;
import net.codingme.boot.utils.ResponseUtill;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import javax.servlet.http.HttpServletRequest;

/**
 * &amp;lt;p&amp;gt;
 * 统一的异常处理
 *
 * @Author niujinpeng
 * @Date 2019/1/7 14:26
 */

@Slf4j
@ControllerAdvice
public class ExceptionHandle {

    @ResponseBody
    @ExceptionHandler(Exception.class)
    public Response handleException(Exception e) {
        log.info(&quot;异常 {}&quot;, e);
        if (e instanceof BaseException) {
            BaseException exception = (BaseException) e;
            String code = exception.getCode();
            String message = exception.getMessage();
            return ResponseUtill.error(code, message);
        }
        return ResponseUtill.error(ResponseEnum.UNKNOW_ERROR);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求异常页面得到响应如下。&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
 &quot;code&quot;: &quot;-1&quot;,
 &quot;data&quot;: [],
 &quot;message&quot;: &quot;未知错误&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文章代码已经上传到 GitHub &lt;a href=&quot;https://github.com/niumoo/springboot/tree/master/springboot-web-error&quot;&gt;Spring Boot Web开发 - 错误机制&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&amp;lt;完&amp;gt;&lt;br/&gt;本文原发于个人博客：&lt;a href=&quot;https://www.codingme.net/&quot; class=&quot;uri&quot;&gt;https://www.codingme.net&lt;/a&gt; 转载请注明出处&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-e1b06fdf782b78e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 22 Feb 2019 06:52:00 +0000</pubDate>
<dc:creator>雪漫士兵</dc:creator>
<og:description>前言 相信大家在刚开始体验 Springboot 的时候一定会经常碰到这个页面，也就是访问一个不存在的页面的默认返回页面。 &lt;! more 如果是其他客户端请求，如接口测试工具，会默认返回JSON数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niumoo/p/10418173.html</dc:identifier>
</item>
<item>
<title>如何探测网络设备ACL规则 - 白桦林_HK</title>
<link>http://www.cnblogs.com/baihualin/p/10418316.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/baihualin/p/10418316.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;背景：&lt;/strong&gt;在互联网企业的生产网络中，往往在网络入口处的网络设备上会有成千上万条ACL策略，这么多的ACL导致了网络管理员很难彻底梳理清楚其中的逻辑关系，从而不知道到底对外开放了哪些IP和哪些端口。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;解决手段：&lt;/strong&gt;编写ACL规则探测程序，从公网扫描该网络设备的ACL规则&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;工作原理：&lt;/strong&gt;不管是交换机还是路由器或防火墙，在处理数据包时ACL规则总是优先于ICMP规则。即：当网络设备收到一个TTL为0的报文时会先匹配ACL规则之后再向发送者发送 ICMP time exceeded消息，基于此原理就可以在公网发送以IDC内地址为目的IP且TTL到被探测设备时刚好减为0的数据包，如果被探测设备返回了ICMP time exceeded消息则说明它的ACL策略针对此IP及port开放，如果没有返回包则说明数据包被它的ACL阻拦&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;131&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; coding:utf-8&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; itertools &lt;span&gt;import&lt;/span&gt;&lt;span&gt; groupby
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; scapy.all &lt;span&gt;import&lt;/span&gt; *
&lt;span&gt;  5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; re
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; sys
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; IPy
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; 
&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RangeException(Exception):
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; InputType(Exception):
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; 
&lt;span&gt; 18&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TargetNotSupport(Exception):
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; 
&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OptionError(Exception):
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     &lt;span&gt;pass&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt; 
&lt;span&gt; 26&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PortScan(object):
&lt;/span&gt;&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, speed=3&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;         self.open_port =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;         self.speed =&lt;span&gt; speed
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__str__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;         speed_statement = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;使用PortScan(*)创建对象时可以在*处指定扫描速率,默认为3,数值越小扫描速度越快\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;                           &lt;span&gt;'&lt;/span&gt;&lt;span&gt;注意:随着扫描速度的增加准确率会相应降低!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; speed_statement
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从本地文件读取IP资源&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__target&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt;             open_file = input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入要导入资源的文件名字:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             address_file = open(open_file, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             address_list =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; address_file.readlines():
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt;                 i = i.replace(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;                address_list.append(i)
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; FileNotFoundError:
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请先在本地创建对应名字的IP列表文本文件!!!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;            self.scan()
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; 
&lt;span&gt; 51&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; KeyboardInterrupt:
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;            sys.exit()
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; 
&lt;span&gt; 55&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as error:
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;打开本地文件有误!!!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(error)
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;            self.scan()
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; address_list
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; 
&lt;span&gt; 62&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取IP资源&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入1从一个文件读取IP,输入2从屏幕输入获取IP&lt;/span&gt;
&lt;span&gt; 64&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取的IP信息可以是单个IP地址(例:220.12.12.12),也可以是一个地址段(例:192.168.1.0/24)&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 最终返回一个IP地址列表,此列表包含了输入的所有单个IP地址以及地址段中的可用IP&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_ip(self, option, string):
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt;         address_store = []  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; IP资源存储&lt;/span&gt;
&lt;span&gt; 69&lt;/span&gt; 
&lt;span&gt; 70&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果选1则从文件读取IP资源&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; option == 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 得到打开IP表文件名字及其IP表&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;             address_list = self.&lt;span&gt;__target&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果选2则手动输入IP资源&lt;/span&gt;
&lt;span&gt; 76&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; option == 2&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 接收IP数据&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;             address_list = input(string)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.1.1,2.2.2.0/24&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;             address_list = address_list.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; 
&lt;span&gt; 81&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.1.1/24 的正则&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt;         ip_range_re = r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;( *(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                       r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                       r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                       r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d))/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                       r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(3[012]|[12][0-9]|[1-9]) *&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.1.1,2.2.2.2,3.3.3.3 的正则&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt;         ip_address_re = r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;( *(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                         r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                         r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d)\.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; \
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                         r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(25[0-5]|2[0-4]\d|[0-1]\d{2}|[1-9]?\d))&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; 
&lt;span&gt; 93&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对输入的值进行便利,提取其中的IP地址&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; address_list:
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;             range_re_result = re.match(ip_range_re, i)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.1.1/24的正则匹配结果&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt;             ip_re_result = re.match(ip_address_re, i)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.1.1.1,2.2.2.2,3.3.3.3 的正则匹配结果&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; range_re_result:
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 subnet_mask = range_re_result.group(6&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 network_number = re.sub(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^0+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;, range_re_result.group(1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 address_string = network_number + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + subnet_mask   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果输入1.1.1.1/24类型则address_store为字符串&lt;/span&gt;
&lt;span&gt;101&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取网段内所有可用IP地址并加表&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt;                     address_subset =&lt;span&gt; IPy.IP(address_string)
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; address_subset:
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; i == address_subset[len(address_subset)-1] &lt;span&gt;or&lt;/span&gt; i ==&lt;span&gt; address_subset[0]:
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                             &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;                            address_store.append(str(i))
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt;                 &lt;span&gt;except&lt;/span&gt;&lt;span&gt; ValueError:
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;输入有误,请按&quot;网络号/掩码&quot;或&quot;IP地址&quot;格式输入&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;                    self.scan()
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;             &lt;span&gt;elif&lt;/span&gt;&lt;span&gt; ip_re_result:
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;                 ii = re.sub(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;^0+&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;''&lt;/span&gt;&lt;span&gt;, ip_re_result.group())
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;                 address_store.append(ii)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt;对单个IP地址形式的输入直接加表&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;输入有误,请输入正确的IP地址(e.g:1.1.1.1,192.168.1.0/24)！！！&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; &lt;span&gt;                self.get_ip(option)
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; address_store
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; 
&lt;span&gt;121&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 通过从屏幕输入获取端口资源&lt;/span&gt;
&lt;span&gt;122&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入形式可以为单个端口号(例:3389),也可以是一个端口范围(例:22-25)&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回数据为一个列表,其中每个元素都以元组形式存在.  每个元组包含两个整数元素,第一个为端口范围的最小值,第二个为端口范围的最大值&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意: 单个端口号形式的输入最后也将以范围形式输出,其最大值与最小值都为他本身&lt;/span&gt;
&lt;span&gt;125&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回数据举例: [(22-25),(3389,3389)]&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_port(self):
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;         port_range = input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入要扫描端口范围(e.g: 3389,20-25):&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;         target_port = []  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 端口资源存储&lt;/span&gt;
&lt;span&gt;129&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;             port_range = port_range.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 例:['1', '2', '3-10', '11-20']&lt;/span&gt;
&lt;span&gt;131&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; port_range:
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; re.match(&lt;span&gt;'&lt;/span&gt;&lt;span&gt; *(\d+)-(\d+).*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, i):
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; for ii in range(len(open_port_list)):&lt;/span&gt;
&lt;span&gt;134&lt;/span&gt;                     low_port = int(re.match(&lt;span&gt;'&lt;/span&gt;&lt;span&gt; *(\d+)-(\d+).*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, i).group(1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                     high_port = int(re.match(&lt;span&gt;'&lt;/span&gt;&lt;span&gt; *(\d+)-(\d+).*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, i).group(2&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; low_port &amp;gt;= high_port &lt;span&gt;or&lt;/span&gt; low_port &amp;lt;= 0 &lt;span&gt;or&lt;/span&gt; low_port &amp;gt; 65535 &lt;span&gt;or&lt;/span&gt; high_port &amp;lt;= 0 &lt;span&gt;or&lt;/span&gt; high_port &amp;gt; 65535&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;                         &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; RangeException
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt;                         target_port.append((low_port, high_port))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果是范围则把最小值和最大值以元组形式加表&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt;                 &lt;span&gt;elif&lt;/span&gt; re.match(&lt;span&gt;'&lt;/span&gt;&lt;span&gt; *\d+ *&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, i):
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;                     singular = int(re.match(&lt;span&gt;'&lt;/span&gt;&lt;span&gt; *(\d+) *&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, i).group(1&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; 0 &amp;lt; singular &amp;lt;= 65535&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt;                         target_port.append((singular, singular))   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果是单整数则把它当作范围一样处理,最大值和最小值均为它自己&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt;                         &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; RangeException
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;147&lt;/span&gt;                     &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; InputType
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; RangeException:
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;端口应为1-65535之间的整数,且输入范围格式应当为从小到大&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; &lt;span&gt;            self.get_port()
&lt;/span&gt;&lt;span&gt;151&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; InputType:
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;端口类型应为整数&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt; &lt;span&gt;            self.get_port()
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; KeyboardInterrupt:
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt; &lt;span&gt;            sys.exit()
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as unusual:
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;输入有误!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(unusual)
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;            self.get_port()
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; target_port  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 返回经过处理的目标端口列表&lt;/span&gt;
&lt;span&gt;162&lt;/span&gt; 
&lt;span&gt;163&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对纯数字的列表进行排序且范围切块&lt;/span&gt;
&lt;span&gt;164&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 例:导入[11,22,33,1,2,3,4,5]-----&amp;gt;导出[1-5,11,22,33]&lt;/span&gt;
&lt;span&gt;165&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; int_single_to_range(original):
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;         original.sort()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 先排序&lt;/span&gt;
&lt;span&gt;168&lt;/span&gt;         open_port_range =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt;         fun = &lt;span&gt;lambda&lt;/span&gt; x: x[1] -&lt;span&gt; x[0]
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; k, g &lt;span&gt;in&lt;/span&gt;&lt;span&gt; groupby(enumerate(original), fun):
&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;             l1 = [j &lt;span&gt;for&lt;/span&gt; i, j &lt;span&gt;in&lt;/span&gt; g]  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 连续数字的列表&lt;/span&gt;
&lt;span&gt;172&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; len(l1) &amp;gt; 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;173&lt;/span&gt;                 scop = str(min(l1)) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(max(l1))  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将连续数字范围用&quot;-&quot;连接&lt;/span&gt;
&lt;span&gt;174&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt;                 scop =&lt;span&gt; l1[0]
&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;             open_port_range.append(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.format(scop))
&lt;/span&gt;&lt;span&gt;177&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; open_port_range
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt; 
&lt;span&gt;179&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; TTL自动检测&lt;/span&gt;
&lt;span&gt;180&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入一个被探测设备IP列表,返回一个被探测设备IP与相应TTL的字典,例:{'220.2.2.2':15}&lt;/span&gt;
&lt;span&gt;181&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; ttl_check(self, address_list):
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;准备中...&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt;         probe_device_ttl =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;184&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; switch = 0    # 检测返回数据包的源IP是否为被探测设备&lt;/span&gt;
&lt;span&gt;185&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;186&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; address_list:
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; ii &lt;span&gt;in&lt;/span&gt; range(1, 129&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i, ii)
&lt;/span&gt;&lt;span&gt;189&lt;/span&gt;                     scan_packet = IP(dst=i, ttl=ii) / TCP(dport=8080, flags=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;                     ttl_source = sr1(scan_packet, timeout=3, verbose=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;while 1:&lt;/span&gt;
&lt;span&gt;192&lt;/span&gt;                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;    time.sleep(0.001)&lt;/span&gt;
&lt;span&gt;193&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ttl_source:
&lt;/span&gt;&lt;span&gt;194&lt;/span&gt;                         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt; ttl_source[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;IP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].fields[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] ==&lt;span&gt; i:
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt;                                 probe_device_ttl[i] =&lt;span&gt; ii
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt;                                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; switch = 1&lt;/span&gt;
&lt;span&gt;198&lt;/span&gt;                                 &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;199&lt;/span&gt;                             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt;                                 &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;201&lt;/span&gt;                         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as receive_error:
&lt;/span&gt;&lt;span&gt;202&lt;/span&gt;                             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(receive_error)
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;                             &lt;span&gt;raise&lt;/span&gt;
&lt;span&gt;204&lt;/span&gt;                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; if switch == 1:&lt;/span&gt;
&lt;span&gt;205&lt;/span&gt;                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;     break&lt;/span&gt;
&lt;span&gt;206&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TTL超时!!!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; 
&lt;span&gt;209&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; KeyboardInterrupt:
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;211&lt;/span&gt; &lt;span&gt;            sys.exit()
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt; 
&lt;span&gt;213&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as error:
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;程序出现错误!!!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(error)
&lt;/span&gt;&lt;span&gt;216&lt;/span&gt; &lt;span&gt;            self.scan()
&lt;/span&gt;&lt;span&gt;217&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;准备完毕&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; probe_device_ttl
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; 
&lt;span&gt;221&lt;/span&gt; &lt;span&gt;    @staticmethod
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; option():
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请选择导入被扫描信息方式:\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;224&lt;/span&gt;               &lt;span&gt;'&lt;/span&gt;&lt;span&gt;1 从文件导入\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;225&lt;/span&gt;               &lt;span&gt;'&lt;/span&gt;&lt;span&gt;2 在程序中手动输入\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt; 
&lt;span&gt;227&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; scan(self):
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 功能选择&lt;/span&gt;
&lt;span&gt;229&lt;/span&gt; &lt;span&gt;        self.option()
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;231&lt;/span&gt;             option = int(input(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;我选择: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;232&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(option)
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; option != 2 &lt;span&gt;and&lt;/span&gt; option != 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt;                 &lt;span&gt;raise&lt;/span&gt;&lt;span&gt; OptionError
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt; OptionError:
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入功能标号!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt; &lt;span&gt;            self.scan()
&lt;/span&gt;&lt;span&gt;238&lt;/span&gt; 
&lt;span&gt;239&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取要扫描IP列表&lt;/span&gt;
&lt;span&gt;240&lt;/span&gt;         address_store = self.get_ip(option, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入被探测IP资源:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt; 
&lt;span&gt;242&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 获取要扫描的端口列表&lt;/span&gt;
&lt;span&gt;243&lt;/span&gt;         port_range =&lt;span&gt; self.get_port()
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; 
&lt;span&gt;245&lt;/span&gt;         probe_device = self.get_ip(2, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;请输入被探测的安全设备IP地址:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt; 
&lt;span&gt;247&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自动检测到探测设备的TTL值,该值为一个字典,key为被探测安全设备IP,value为到该设备的TTL值&lt;/span&gt;
&lt;span&gt;248&lt;/span&gt;         ttl =&lt;span&gt; self.ttl_check(probe_device)
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt; 
&lt;span&gt;250&lt;/span&gt;         count = 0  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用作进度百分比的分子.  以每个IP的每个端口为单位进行计数,总数为IP个数*端口个数&lt;/span&gt;
&lt;span&gt;251&lt;/span&gt; 
&lt;span&gt;252&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; ttl:
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 挨个儿朝被探测设备发送端口探测包&lt;/span&gt;
&lt;span&gt;254&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; probe_device_ip, ttl &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ttl.items():
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt; 
&lt;span&gt;256&lt;/span&gt;                 &lt;span&gt;print&lt;/span&gt;(probe_device_ip + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;端口开放情况:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;257&lt;/span&gt; 
&lt;span&gt;258&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建一个新文件,准备导入结果&lt;/span&gt;
&lt;span&gt;259&lt;/span&gt;                 write_file = open(probe_device_ip + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-result.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt; 
&lt;span&gt;261&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;262&lt;/span&gt;                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为每个被探测设备计算IP资源池中所有的IP资源&lt;/span&gt;
&lt;span&gt;263&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; address_store:
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt; 
&lt;span&gt;265&lt;/span&gt;                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 为每个IP计算各个输入IP端口范围开放情况&lt;/span&gt;
&lt;span&gt;266&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt; port &lt;span&gt;in&lt;/span&gt;&lt;span&gt; port_range:
&lt;/span&gt;&lt;span&gt;267&lt;/span&gt;                             (low_port, high_port) =&lt;span&gt; port
&lt;/span&gt;&lt;span&gt;268&lt;/span&gt;                             scan_packets = IP(dst=i, ttl=ttl) / TCP(dport=(low_port, high_port), flags=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;S&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 构造检测包&lt;/span&gt;
&lt;span&gt;269&lt;/span&gt;                             replay_packets_total = sr(scan_packets, timeout=self.speed, verbose=False)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 发送检测包及接收返回包&lt;/span&gt;
&lt;span&gt;270&lt;/span&gt;                             open_port_list = replay_packets_total[0].res  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开放端口原始对象列表(一个IP不同端口范围回包的集合)&lt;/span&gt;
&lt;span&gt;271&lt;/span&gt; 
&lt;span&gt;272&lt;/span&gt;                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一个IP有几个端口开放就有几个回包(如果端口被ACL干掉则不会回包),以下遍历回包来读取开放的端口&lt;/span&gt;
&lt;span&gt;273&lt;/span&gt;                             &lt;span&gt;for&lt;/span&gt; ii &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(open_port_list)):
&lt;/span&gt;&lt;span&gt;274&lt;/span&gt;                                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;275&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; open_port_list[ii][1][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ICMP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].fields[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] == 11:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; ICMP类型为11时为TTL超时包&lt;/span&gt;
&lt;span&gt;276&lt;/span&gt;                                         self.open_port.append(open_port_list[ii][0][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].fields[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dport&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; TTL超时则为开放端口,将开放端口进行加表&lt;/span&gt;
&lt;span&gt;277&lt;/span&gt;                                         &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;278&lt;/span&gt;                                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;279&lt;/span&gt;                                         &lt;span&gt;if&lt;/span&gt; open_port_list[ii][1][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ICMP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].fields[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;type&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] == 3:  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不知为啥有时候会返回类型为3的ICMP包(即:端口不可达包)&lt;/span&gt;
&lt;span&gt;280&lt;/span&gt;                                             &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;281&lt;/span&gt;                                         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;282&lt;/span&gt;                                             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 除11和3外其他类型的ICMP回包,需进行人工排查&lt;/span&gt;
&lt;span&gt;283&lt;/span&gt;                                             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ICMP返回类型不对&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;284&lt;/span&gt;                                             &lt;span&gt;print&lt;/span&gt;(open_port_list[ii][1][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ICMP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].fields)
&lt;/span&gt;&lt;span&gt;285&lt;/span&gt;                                             &lt;span&gt;print&lt;/span&gt;(open_port_list[ii][0][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].fields)
&lt;/span&gt;&lt;span&gt;286&lt;/span&gt;                                 &lt;span&gt;except&lt;/span&gt;&lt;span&gt; IndexError:
&lt;/span&gt;&lt;span&gt;287&lt;/span&gt; 
&lt;span&gt;288&lt;/span&gt;                                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果探测设备IP刚好为要扫描的IP时,开放端口会返回SYN,ACK包&lt;/span&gt;
&lt;span&gt;289&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; open_port_list[ii][1][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].fields[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;flags&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;SA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;290&lt;/span&gt;                                         self.open_port.append(open_port_list[ii][0][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].fields[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dport&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;291&lt;/span&gt;                                         &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;292&lt;/span&gt; 
&lt;span&gt;293&lt;/span&gt;                                     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 不知为啥有时候交换机会返回RST ACK的包&lt;/span&gt;
&lt;span&gt;294&lt;/span&gt;                                     &lt;span&gt;if&lt;/span&gt; open_port_list[ii][1][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].fields[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;flags&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;RA&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;295&lt;/span&gt;                                         &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;296&lt;/span&gt;                                     &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;297&lt;/span&gt;                                         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;返回未知TCP包,需人工分析&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;298&lt;/span&gt;                                         &lt;span&gt;print&lt;/span&gt;(open_port_list[ii][1][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].fields,
&lt;/span&gt;&lt;span&gt;299&lt;/span&gt;                                               open_port_list[ii][1][&lt;span&gt;'&lt;/span&gt;&lt;span&gt;TCP&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;].fields[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;flags&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;300&lt;/span&gt;                                         &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(open_port_list[ii])
&lt;/span&gt;&lt;span&gt;301&lt;/span&gt; 
&lt;span&gt;302&lt;/span&gt;                                 count += 1  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行进度+1(每计算完一个IP进度+1)&lt;/span&gt;
&lt;span&gt;303&lt;/span&gt;                                 &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(count)
&lt;/span&gt;&lt;span&gt;304&lt;/span&gt; 
&lt;span&gt;305&lt;/span&gt;                                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 进度统计&lt;/span&gt;
&lt;span&gt;306&lt;/span&gt;                                 speed_to_progress = count / len(address_list) * len(port_range) * len(ttl) * 100
&lt;span&gt;307&lt;/span&gt;                                 &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\r已完成:%.2f%% &lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % speed_to_progress, end=&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;308&lt;/span&gt; 
&lt;span&gt;309&lt;/span&gt;                         self.open_port = self.int_single_to_range(self.open_port)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 对开放端口列表进行排序和范围化&lt;/span&gt;
&lt;span&gt;310&lt;/span&gt;                         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;针对&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + i + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;开放端口: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, self.open_port)
&lt;/span&gt;&lt;span&gt;311&lt;/span&gt;                         write_file.write(str(i) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(self.open_port) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 每扫描完一个IP就把该IP结果写入文件&lt;/span&gt;
&lt;span&gt;312&lt;/span&gt;                         self.open_port = []  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 扫尾工作,为下个IP扫描准备一个干净的开放端口列表&lt;/span&gt;
&lt;span&gt;313&lt;/span&gt; 
&lt;span&gt;314&lt;/span&gt; &lt;span&gt;                    write_file.close()
&lt;/span&gt;&lt;span&gt;315&lt;/span&gt; 
&lt;span&gt;316&lt;/span&gt;                 &lt;span&gt;except&lt;/span&gt;&lt;span&gt; KeyboardInterrupt:
&lt;/span&gt;&lt;span&gt;317&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;318&lt;/span&gt; &lt;span&gt;                    write_file.close()
&lt;/span&gt;&lt;span&gt;319&lt;/span&gt; &lt;span&gt;                    sys.exit()
&lt;/span&gt;&lt;span&gt;320&lt;/span&gt;                 &lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as error:
&lt;/span&gt;&lt;span&gt;321&lt;/span&gt; &lt;span&gt;                    write_file.close()
&lt;/span&gt;&lt;span&gt;322&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;程序异常退出!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;323&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(error)
&lt;/span&gt;&lt;span&gt;324&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;325&lt;/span&gt; &lt;span&gt;                    write_file.close()
&lt;/span&gt;&lt;span&gt;326&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;''&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;327&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; option == 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;328&lt;/span&gt;                         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;被探测设备%s已完成,结果已导入当前路径&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;\'%s\'&lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;文件中&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (probe_device_ip, probe_device_ip + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-result.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;329&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; option == 2&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;330&lt;/span&gt;                         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;扫描已完成!&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;331&lt;/span&gt; 
&lt;span&gt;332&lt;/span&gt; 
&lt;span&gt;333&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;334&lt;/span&gt; 
&lt;span&gt;335&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; banner():
&lt;/span&gt;&lt;span&gt;336&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;337&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;============================================&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;338&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;339&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;340&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;           ACL有效性探测系统v1.0             &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;341&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;342&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;343&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;============================================&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;344&lt;/span&gt;         &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;345&lt;/span&gt; 
&lt;span&gt;346&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; main():
&lt;/span&gt;&lt;span&gt;347&lt;/span&gt; &lt;span&gt;        banner()
&lt;/span&gt;&lt;span&gt;348&lt;/span&gt;         a =&lt;span&gt; PortScan()
&lt;/span&gt;&lt;span&gt;349&lt;/span&gt; &lt;span&gt;        a.scan()
&lt;/span&gt;&lt;span&gt;350&lt;/span&gt; 
&lt;span&gt;351&lt;/span&gt;     main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Fri, 22 Feb 2019 06:45:00 +0000</pubDate>
<dc:creator>白桦林_HK</dc:creator>
<og:description>探测网络设备ACL规则 背景：在互联网企业的生产网络中，往往在网络入口处的网络设备上会有成千上万条ACL策略，这么多的ACL导致了网络管理员很难彻底梳理清楚其中的逻辑关系，从而不知道到底对外开放了哪些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/baihualin/p/10418316.html</dc:identifier>
</item>
<item>
<title>“挑三拣四”地学一学Java I/O - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/10418303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/10418303.html</guid>
<description>&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-9481ec30e9d32c49.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;古人云：“读书破万卷，下笔如有神”。也就是说，只有大量的阅读，写作的时候才能风生水起——写作意味着输出（我的知识传播给他人），而读书意味着输入（从他人的知识中汲取营养）。&lt;/p&gt;
&lt;p&gt;对于Java I/O来说，I意味着Input（输入），O意味着Output（输出）。读书写作并非易事，而创建一个好的I/O系统更是一项艰难的任务。&lt;/p&gt;
&lt;h3 id=&quot;h01&quot;&gt;01、数据流之字节与字符&lt;/h3&gt;
&lt;p&gt;Java所有的I/O机制都是基于&lt;strong&gt;数据流&lt;/strong&gt;进行的输入输出。数据流可分为两种：&lt;/p&gt;
&lt;p&gt;1）字节流，未经加工的原始二进制数据，最小的数据单元是&lt;strong&gt;字节&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;2）字符流，经过一定编码处理后符合某种格式规定的数据，最小的数据单元是&lt;strong&gt;字符&lt;/strong&gt;——占用两个字节。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OutputStream&lt;/code&gt;和&lt;code&gt;InputStream&lt;/code&gt;用来处理字节流；&lt;code&gt;Writer&lt;/code&gt;和&lt;code&gt;Reader&lt;/code&gt;用来处理字符流；&lt;code&gt;OutputStreamWriter&lt;/code&gt;可以把&lt;code&gt;OutputStream&lt;/code&gt;转换为&lt;code&gt;Writer&lt;/code&gt;，&lt;code&gt;InputStreamReader&lt;/code&gt;可以把&lt;code&gt;InputStream&lt;/code&gt;转换为&lt;code&gt;Reader&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;Java的设计者为此设计了众多的类，见下图。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;InputStream、OutputStream及Reader、Writer类&quot; src=&quot;http://upload-images.jianshu.io/upload_images/1752522-ee60b12bd1f9a3dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;InputStream、OutputStream及Reader、Writer类&quot;/&gt;InputStream、OutputStream及Reader、Writer类&lt;/p&gt;
&lt;p&gt;看到这么多类，你一定感觉头晕目眩。反正我已经看得不耐烦了。搞这么多类，看起来头真的大——这也从侧面说明实际的应用场景各有各的不同——你也完全不用担心，因为实际项目当中，根本就不可能全用到（我就没用过&lt;code&gt;SequenceOutputStream&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;我建议你在&lt;strong&gt;学习的时候要掌握一种“挑三拣四”的能力&lt;/strong&gt;——学习自己感兴趣的、必须掌握的、对能力有所提升的知识。切不可囫囵吞枣，强迫自己什么都学。什么都学，最后的结果可能是什么都不会。&lt;/p&gt;
&lt;p&gt;字符流是基于字节流的，因此，我们先来学习一下字节流的两个最基础的类——&lt;code&gt;OutputStream&lt;/code&gt;和&lt;code&gt;InputStream&lt;/code&gt;，它们是必须要掌握的。&lt;/p&gt;
&lt;p&gt;1）OutputStream&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OutputStream&lt;/code&gt;提供了4个非常有用的方法，如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public void write(byte b[])&lt;/code&gt;：将数组b中的字节写到输出流。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public void write(byte b[], int off, int len)&lt;/code&gt;：将数组b的从偏移量off开始的len个字节写到输出流。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public void flush()&lt;/code&gt; : 将数据缓冲区中数据全部输出，并清空缓冲区。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public void close()&lt;/code&gt; : 关闭输出流并释放与流相关的系统资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其子类&lt;code&gt;ByteArrayOutputStream&lt;/code&gt;和&lt;code&gt;BufferedOuputStream&lt;/code&gt;最为常用（File相关类放在下个小节）。&lt;/p&gt;
&lt;p&gt;①、&lt;code&gt;ByteArrayOutputStream&lt;/code&gt;通常用于在内存中创建一个字节数组缓冲区，数据被“临时”放在此缓冲区中，并不会输出到文件或者网络套接字中——就好像一个中转站，负责把输入流中的数据读入到内存缓冲区中，你可以调用它的&lt;code&gt;toByteArray()&lt;/code&gt;方法来获取字节数组。&lt;/p&gt;
&lt;p&gt;来看下例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;byte[] readBytes(InputStream in, &lt;span class=&quot;hljs-keyword&quot;&gt;long length) &lt;span class=&quot;hljs-keyword&quot;&gt;throws IOException {&lt;br/&gt;ByteArrayOutputStream bo = &lt;span class=&quot;hljs-keyword&quot;&gt;new ByteArrayOutputStream();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;byte[] buffer = &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-keyword&quot;&gt;byte[&lt;span class=&quot;hljs-number&quot;&gt;1024];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int read = &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while (read &amp;lt; length) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int cur = in.read(buffer, &lt;span class=&quot;hljs-number&quot;&gt;0, (&lt;span class=&quot;hljs-keyword&quot;&gt;int) Math.min(&lt;span class=&quot;hljs-number&quot;&gt;1024, length - read));&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (cur &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;0) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;}&lt;br/&gt;read += cur;&lt;br/&gt;bo.write(buffer, &lt;span class=&quot;hljs-number&quot;&gt;0, cur);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return bo.toByteArray();&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ByteArrayOutputStream&lt;/code&gt;的责任就是把&lt;code&gt;InputStream&lt;/code&gt;中的字节流“一字不差”的读出来——这个工具方法很重要，很重要，很重要——可以解决粘包的问题。&lt;/p&gt;
&lt;p&gt;②、&lt;code&gt;BufferedOuputStream&lt;/code&gt;实现了一个缓冲输出流，可以将很多小的数据缓存为一个大块的数据，然后一次性地输出到文件或者网络套接字中——这里的“缓冲”和&lt;code&gt;ByteArrayOutputStream&lt;/code&gt;的“缓冲”有着很大的不同——前者是为了下一次的一次性输出，后者就是单纯的为了缓冲，不存在输出。&lt;/p&gt;
&lt;p&gt;来看下例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;protected &lt;span class=&quot;hljs-keyword&quot;&gt;void &lt;span class=&quot;hljs-title&quot;&gt;write&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot; readability=&quot;1.5&quot;&gt;byte[] data) &lt;span class=&quot;hljs-keyword&quot; readability=&quot;3&quot;&gt;throws IOException {&lt;br/&gt;out.write(intToByte(data.length));&lt;br/&gt;out.write(data);&lt;br/&gt;out.flush();&lt;br/&gt;out.close();&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;byte[] intToByte(&lt;span class=&quot;hljs-keyword&quot;&gt;int num)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;byte[] data = &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-keyword&quot;&gt;byte[&lt;span class=&quot;hljs-number&quot;&gt;4];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; data.length; i++)&lt;br/&gt;{&lt;br/&gt;data[&lt;span class=&quot;hljs-number&quot;&gt;3-i] = (&lt;span class=&quot;hljs-keyword&quot;&gt;byte)(num % &lt;span class=&quot;hljs-number&quot;&gt;256);&lt;br/&gt;num = num / &lt;span class=&quot;hljs-number&quot;&gt;256;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return data;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;BufferedOuputStream&lt;/code&gt;的时候，一定要记得调用&lt;code&gt;flush()&lt;/code&gt;方法将数据从缓冲区中全部输出。使用完毕后，调用&lt;code&gt;close()&lt;/code&gt;方法关闭输出流，释放与流相关的系统资源。&lt;/p&gt;
&lt;p&gt;2）InputStream&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InputStream&lt;/code&gt;也提供了4个非常有用的方法，如下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public int read(byte b[])&lt;/code&gt;：读取b.length个字节的数据放到数组b中，返回值是读取的字节数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public int read(byte b[], int off, int len)&lt;/code&gt;：从输入流中最多读取len个字节的数据，存放到偏移量为off的数组b中。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public int available()&lt;/code&gt;：返回输入流中可以读取的字节数。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public int close()&lt;/code&gt; ：使用完后，对打开的流进行关闭。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其子类&lt;code&gt;BufferedInputStream&lt;/code&gt;（缓冲输入流）最为常用，效率最高（当我们不确定读入的是大数据还是小数据）。&lt;/p&gt;
&lt;p&gt;无缓冲流上的每个读取请求通常会导致对操作系统的调用以读取所请求的字节数——进行系统调用的开销非常大。但缓冲输入流就不一样了，它通过对内部缓冲区执行（例如）高达8k字节的大量读取，然后针对缓冲区的大小再分配字节来减少系统调用的开销——性能会提高很多。&lt;/p&gt;
&lt;p&gt;使用示例如下。&lt;/p&gt;
&lt;p&gt;先来看一个辅助方法&lt;code&gt;byteToInt&lt;/code&gt;，把字节转换成int。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;int &lt;span class=&quot;hljs-title&quot;&gt;byteToInt&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;byte[] b) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int num = &lt;span class=&quot;hljs-number&quot;&gt;0;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; b.length; i++) {&lt;br/&gt;num*=&lt;span class=&quot;hljs-number&quot;&gt;256;&lt;br/&gt;num+=(b[i]+&lt;span class=&quot;hljs-number&quot;&gt;256)%&lt;span class=&quot;hljs-number&quot;&gt;256;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return num;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再来看如何从输入流中，根据指定的长度contentLength来读取数据。&lt;code&gt;readBytes()&lt;/code&gt;方法在之前已经提到过。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;BufferedInputStream in = &lt;span class=&quot;hljs-keyword&quot; readability=&quot;4&quot;&gt;new BufferedInputStream(socket.getInputStream());&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;byte[] tmpByte = &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-keyword&quot;&gt;byte[&lt;span class=&quot;hljs-number&quot;&gt;4];&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;byte[] buf = &lt;span class=&quot;hljs-keyword&quot;&gt;null;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (contentLength &amp;gt; in.available()) {&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我敢保证，只要你搞懂了字节流，字符流也就不在话下——所以，我们在此略过字符流。&lt;/p&gt;
&lt;h3 id=&quot;h02file&quot;&gt;02、File类&lt;/h3&gt;
&lt;p&gt;前面我们了解到，数据有两种格式：字节与字符。那么这些数据从哪里来，又存往何处呢？&lt;/p&gt;
&lt;p&gt;一个主要的方式就是从物理磁盘上进行读取和存储，磁盘的唯一最小描述就是文件。也就是说上层应用程序只能通过文件来操作磁盘上的数据，文件也是操作系统和磁盘驱动器交互的一个最小单元。&lt;/p&gt;
&lt;p&gt;在Java中，通常用&lt;code&gt;File&lt;/code&gt;类来操作文件。当然了，File不止是文件，它也是文件夹（目录）。File类保存了文件或目录的各种元数据信息（文件名、文件长度、最后修改时间、是否可读、当前文件的路径名等等）。&lt;/p&gt;
&lt;p&gt;通过File类以及文件输入输出流（&lt;code&gt;FileInputStream&lt;/code&gt;、&lt;code&gt;FileOutputStream&lt;/code&gt;），可以轻松地创建、删除、复制文件或者目录。&lt;/p&gt;
&lt;p&gt;这里，我提供给你一个实用的文件工具类——FileUtils。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;8&quot;&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;16&quot;&gt;package com.cmower.common.util;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.io.File;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.io.FileInputStream;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.io.FileOutputStream;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.io.IOException;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.io.InputStream;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.io.OutputStream;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.util.Enumeration;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.util.List;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.apache.commons.lang3.StringUtils;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.slf4j.Logger;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import org.slf4j.LoggerFactory;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import com.google.common.collect.Lists;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private &lt;span class=&quot;hljs-keyword&quot;&gt;static Logger logger = LoggerFactory.getLogger(FileUtils.class);&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean flag = &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (!flag) {&lt;br/&gt;logger.debug(&lt;span class=&quot;hljs-string&quot;&gt;&quot;复制目录 &quot; + srcDirName + &lt;span class=&quot;hljs-string&quot;&gt;&quot; 到 &quot; + descDirName + &lt;span class=&quot;hljs-string&quot;&gt;&quot; 失败!&quot;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;}&lt;br/&gt;logger.debug(&lt;span class=&quot;hljs-string&quot;&gt;&quot;复制目录 &quot; + srcDirName + &lt;span class=&quot;hljs-string&quot;&gt;&quot; 到 &quot; + descDirName + &lt;span class=&quot;hljs-string&quot;&gt;&quot; 成功!&quot;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;true;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (!flag) {&lt;br/&gt;logger.debug(&lt;span class=&quot;hljs-string&quot;&gt;&quot;删除目录失败!&quot;);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return &lt;span class=&quot;hljs-keyword&quot;&gt;false;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;public static boolean createFile(String descFileName)&lt;/code&gt;：创建文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static boolean createDirectory(String descDirName)&lt;/code&gt;：创建目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static boolean copyFile(String srcFileName, String descFileName)&lt;/code&gt;：复制文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static boolean copyDirectory(String srcDirName, String descDirName)&lt;/code&gt;：复制目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static boolean deleteFile(String fileName)&lt;/code&gt;：删除文件。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static boolean deleteDirectory(String dirName)&lt;/code&gt;：删除目录。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;public static void writeToFile(String fileName, String content, boolean append)&lt;/code&gt;：向文件中写入内容。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h03socket&quot;&gt;03、网络套接字——Socket&lt;/h3&gt;
&lt;p&gt;虽然网络套接字（&lt;code&gt;Socket&lt;/code&gt;）并不在java.io包下，但它和输入输出流密切相关。&lt;code&gt;File&lt;/code&gt;和&lt;code&gt;Socket&lt;/code&gt;是两组主要的数据传输方式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;是描述计算机之间完成相互通信的一种抽象。可以把 &lt;code&gt;Socket&lt;/code&gt;比作为两个城市之间的交通工具，有了交通工具（高铁、汽车），就可以在城市之间来回穿梭了。交通工具有多种，每种交通工具也有相应的交通规则。&lt;code&gt;Socket&lt;/code&gt;也一样，也有多种。大部分情况下，我们使用的都是基于&lt;code&gt;TCP/IP&lt;/code&gt;的套接字——一种稳定的通信协议。&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;Socket 通信示例&quot; src=&quot;http://upload-images.jianshu.io/upload_images/1179389-f3a88dacdc073eb6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Socket 通信示例&quot;/&gt;Socket 通信示例&lt;/p&gt;
&lt;p&gt;假设主机A是客户端，主机B是服务器端。客户端要与服务器端通信，客户端首先要创建一个&lt;code&gt;Socket&lt;/code&gt;实例，操作系统将为这个&lt;code&gt;Socket&lt;/code&gt;实例分配一个没有被使用的本地端口号，并创建一个套接字数据结构，直到这个连接关闭。&lt;/p&gt;
&lt;p&gt;示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Socket socket = &lt;span class=&quot;hljs-keyword&quot;&gt;new Socket(serverIp, serverPort);&lt;br/&gt;BufferedInputStream in = &lt;span class=&quot;hljs-keyword&quot;&gt;new BufferedInputStream(socket.getInputStream());&lt;br/&gt;BufferedOutputStream out = &lt;span class=&quot;hljs-keyword&quot;&gt;new BufferedOutputStream(socket.getOutputStream());&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与之对应的，服务端需要创建一个&lt;code&gt;ServerSocket&lt;/code&gt;实例，之后调用&lt;code&gt;accept()&lt;/code&gt;方法进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构。&lt;/p&gt;
&lt;p&gt;示例如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;ServerSocket server = &lt;span class=&quot;hljs-keyword&quot;&gt;new ServerSocket(port);&lt;br/&gt;Socket socket = server.accept();&lt;br/&gt;InputStream in = &lt;span class=&quot;hljs-keyword&quot;&gt;new BufferedInputStream(socket.getInputStream());&lt;br/&gt;OutputStream out = &lt;span class=&quot;hljs-keyword&quot;&gt;new BufferedOutputStream(socket.getOutputStream());&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Socket&lt;/code&gt;一旦打通，就可以通过&lt;code&gt;InputStream&lt;/code&gt;和&lt;code&gt;OutputStream&lt;/code&gt;进行数据传输了。&lt;/p&gt;
&lt;h3 id=&quot;h04&quot;&gt;04、压缩&lt;/h3&gt;
&lt;p&gt;Java I/O 支持压缩格式的数据流。在&lt;code&gt;Socket&lt;/code&gt;通信中，我常用&lt;code&gt;GZIPOutputStream&lt;/code&gt;和&lt;code&gt;GZIPInputStream&lt;/code&gt;来对数据流进行简单地压缩和解压。&lt;/p&gt;
&lt;p&gt;压缩的好处就在于能够减小网络传输中数据的体积。代码如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-keyword&quot; readability=&quot;20&quot;&gt;package com.cmower.common.util;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.io.ByteArrayInputStream;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.io.ByteArrayOutputStream;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.io.IOException;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.util.zip.GZIPInputStream;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;import java.util.zip.GZIPOutputStream;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;ByteArrayOutputStream bos = &lt;span class=&quot;hljs-keyword&quot;&gt;new ByteArrayOutputStream();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;byte[] result = &lt;span class=&quot;hljs-keyword&quot;&gt;null;&lt;br/&gt;GZIPOutputStream zos = &lt;span class=&quot;hljs-keyword&quot;&gt;new GZIPOutputStream(bos);&lt;br/&gt;zos.write(data);&lt;br/&gt;zos.finish();&lt;br/&gt;zos.flush();&lt;br/&gt;result = bos.toByteArray();&lt;br/&gt;zos.close();&lt;br/&gt;bos.close();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return result;&lt;br/&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static &lt;span class=&quot;hljs-keyword&quot;&gt;byte[] deCompress(&lt;span class=&quot;hljs-keyword&quot;&gt;byte[] in) &lt;span class=&quot;hljs-keyword&quot;&gt;throws IOException {&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;ByteArrayOutputStream outStream = &lt;span class=&quot;hljs-keyword&quot;&gt;new ByteArrayOutputStream();&lt;br/&gt;GZIPInputStream inStream = &lt;span class=&quot;hljs-keyword&quot;&gt;new GZIPInputStream(&lt;span class=&quot;hljs-keyword&quot;&gt;new ByteArrayInputStream(in));&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;byte[] buf = &lt;span class=&quot;hljs-keyword&quot;&gt;new &lt;span class=&quot;hljs-keyword&quot;&gt;byte[&lt;span class=&quot;hljs-number&quot;&gt;1024];&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while (&lt;span class=&quot;hljs-keyword&quot;&gt;true) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int size = inStream.read(buf);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if (size &amp;lt;= &lt;span class=&quot;hljs-number&quot;&gt;0)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;outStream.write(buf, &lt;span class=&quot;hljs-number&quot;&gt;0, size);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch (Exception e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;break;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;inStream.close();&lt;br/&gt;outStream.close();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return outStream.toByteArray();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.qingmiaokeji.cn/article/27&quot;&gt;张嘴，深入浅出一下Java的HashMap&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.qingmiaokeji.cn/article/24&quot;&gt;Java中食之无味弃之可惜的数组&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 22 Feb 2019 06:43:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>古人云：“读书破万卷，下笔如有神”。也就是说，只有大量的阅读，写作的时候才能风生水起——写作意味着输出（我的知识传播给他人），而读书意味着输入（从他人的知识中汲取营养）。 对于Java I/O来说，I</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing-gee/p/10418303.html</dc:identifier>
</item>
<item>
<title>Service Worker - Worktile</title>
<link>http://www.cnblogs.com/worktile/p/10418283.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/worktile/p/10418283.html</guid>
<description>&lt;p&gt;随着前端快速发展，应用的性能已经变得至关重要，关于这一点大佬做了很多统计。你可以&lt;a href=&quot;https://developers.google.cn/web/fundamentals/performance/why-performance-matters/&quot; rel=&quot;nofollow&quot;&gt;去看看&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如何降低一个页面的网络请求成本从而缩短页面加载资源的时间并降低用户可感知的延时是非常重要的一部分。对于提升应用的加载速度常用的手段有Http Cache、异步加载、304缓存、文件压缩、CDN、CSS Sprite、开启GZIP等等。这些手段无非是在做一件事情，就是让资源更快速的下载到浏览器端。但是除了这些方法，其实还有更加强大的Service Worker线程。&lt;/p&gt;
&lt;h2 id=&quot;-service-worker-pwa-&quot;&gt;Service Worker与PWA的现状&lt;/h2&gt;
&lt;p&gt;说起service worker就不得不提起PWA了，service worker做为PWA的核心技术之一，多年来一直被Google大力推广，这里简单介绍一下。&lt;/p&gt;
&lt;p&gt;通俗来说，PWA就是渐进式web应用(Progressive Web App)。早在16年初，Google便提出PWA，希望提供更强大的web体验，引导开发者回归开放互联网。它弥补了web对比Native App急缺的几个能力，比如离线使用、后台加载、添加到主屏和消息推送等，同时它还具备了小程序标榜的“无需安装、用完即走”的特性。&lt;/p&gt;
&lt;p&gt;虽然PWA技术已经被W3C列为标准，但是其落地情况一直以来是很让人失望的，始终受到苹果的阻碍，最重要的原因在于PWA绕过Apple Store审核，直接推给用户。如果普及，这将威胁到苹果的平台权威，也就意味着苹果与开发者的三七分成生意将会落空。&lt;/p&gt;
&lt;p&gt;所以一直以来safrai不支持mainfest以及service worker这两项关键技术，即使在18年开始支持了，但是对PWA的支持力度也远远低于安卓，具体体现在service worker缓存无法永久保存，以及service worker的API支持不够完善，一个最明显的不同在于安卓版本的PWA会保留你的登录状态，并且会系统级推送消息。而在苹果上，这两点都做不到。也就是说，iPhone上的微博PWA，每次打开都要重新登录，而且不会收到任何推送信息。&lt;/p&gt;
&lt;p&gt;另外由于某些不可描述的原因，在国内无法使用Service Worker的推送功能，虽然国内已经有两家公司做了service worker的浏览器推送，但是成熟度还有待调研。&lt;br/&gt;由于目前各版本手机浏览器对service worker的支持度都不太相同，同一个接口也存在差异化还有待统一，之于我们来说，也只能用Service Worker做一做PC浏览器的缓存了。&lt;/p&gt;
&lt;h2 id=&quot;-service-worker-&quot;&gt;Service Worker的由来&lt;/h2&gt;
&lt;p&gt;Service Worker（以下简称sw）是基于WEB Worker而来的。&lt;/p&gt;
&lt;p&gt;众所周知，javaScript 是单线程的，随着web业务的复杂化，开发者逐渐在js中做了许多耗费资源的运算过程，这使得单线程的弊端更加凹显。web worker正是基于此被创造出来，它是脱离在主线程之外的，我们可以将复杂耗费时间的事情交给web worker来做。但是web worker作为一个独立的线程，他的功能应当不仅于此。sw便是在web worker的基础上增加了离线缓存的能力。当然在 Service Worker 之前也有在 HTML5 上做离线缓存的 API 叫 AppCache, 但是 AppCache 存在很多缺点，你可以&lt;a href=&quot;https://alistapart.com/article/application-cache-is-a-douchebag&quot; rel=&quot;nofollow&quot;&gt;亲自看看&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;sw是由事件驱动的,具有生命周期，可以拦截处理页面的所有网络请求(fetch)，可以访问cache和indexDB，支持推送，并且可以让开发者自己控制管理缓存的内容以及版本，为离线弱网环境下的 web 的运行提供了可能，让 web 在体验上更加贴近 native。换句话说他可以把你应用里的所有静态动态资源根据不同策略缓存起来，在你下次打开时不再需要去服务器请求，这样一来就减少了网络耗时，使得web应用可以秒开，并且在离线环境下也变得可用。做到这一切你只需要增加一个sw文件，不会对原有的代码产生任何侵入，是不是很perfect？&lt;/p&gt;
&lt;h2 id=&quot;-service-worker-&quot;&gt;Service Worker基本特征&lt;/h2&gt;
&lt;p&gt;service worker是事件驱动的worker，生命周期与页面无关。 关联页面未关闭时，它也可以退出，没有关联页面时，它也可以启动。&lt;/p&gt;
&lt;p&gt;Dedicated Worker以及Shared Worker与Service Worker三者非常重要的区别在于不同的生命周期。对于Service Worker来说文档无关的生命周期，是它能提供可靠Web服务的一个重要基础。&lt;/p&gt;
&lt;h2 id=&quot;-service-worker-&quot;&gt;Service Worker生命周期&lt;/h2&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img title=&quot;service worker生命周期&quot; src=&quot;https://wt-box.worktile.com/public/27780397-9040-486e-9299-074471c31d89&quot; alt=&quot;service worker生命周期&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;ul&gt;&lt;li&gt;register 这个是由 client 端发起，注册一个 serviceWorker，这需要一个专门处理sw逻辑的文件&lt;/li&gt;
&lt;li&gt;Parsed 注册完成，解析成功，尚未安装&lt;/li&gt;
&lt;li&gt;installing 注册中，此时 sw 中会触发 install 事件， 需知 sw 中都是事件触发的方式进行的逻辑调用，如果事件里有 event.waitUntil() 则会等待传入的 Promise 完成才会成功&lt;/li&gt;
&lt;li&gt;installed(waiting) 注册完成，但是页面被旧的 Service Worker 脚本控制, 所以当前的脚本尚未激活处于等待中，可以通过 self.skipWaiting() 跳过等待。&lt;/li&gt;
&lt;li&gt;activating 安装后要等待激活，也就是 activated 事件，只要 register 成功后就会触发 install ，但不会立即触发 activated，如果事件里有 event.waitUntil() 则会等待这个 Promise 完成才会成功，这时可以调用 Clients.claim() 接管所有页面。&lt;/li&gt;
&lt;li&gt;activated 在 activated 之后就可以开始对 client 的请求进行拦截处理，sw 发起请求用的是 fetch api，XHR无法使用&lt;/li&gt;
&lt;li&gt;fetch 激活以后开始对网页中发起的请求进行拦截处理&lt;br/&gt;terminate 这一步是浏览器自身的判断处理，当 sw 长时间不用之后，处于闲置状态，浏览器会把该 sw 暂停，直到再次使用&lt;/li&gt;
&lt;li&gt;update 浏览器会自动检测 sw 文件的更新，当有更新时会下载并 install，但页面中还是老的 sw 在控制，只有当用户新开窗口后新的 sw 才能激活控制页面&lt;/li&gt;
&lt;li&gt;redundant 安装失败, 或者激活失败, 或者被新的 Service Worker 替代掉&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Service Worker 脚本最常用的功能是截获请求和缓存资源文件, 这些行为可以绑定在下面这些事件上:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;install 事件中, 抓取资源进行缓存&lt;/li&gt;
&lt;li&gt;activate 事件中, 遍历缓存, 清除过期的资源&lt;/li&gt;
&lt;li&gt;fetch 事件中, 拦截请求, 查询缓存或者网络, 返回请求的资源&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;-service-worker-&quot;&gt;Service Worker实践&lt;/h2&gt;
&lt;p&gt;在这之前你可以先看看&lt;a href=&quot;https://github.com/GoogleChrome/samples/tree/gh-pages/service-worker/basic&quot; rel=&quot;nofollow&quot;&gt;Google的demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们先从sw的注册开始，官方给的demo里的注册是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('service-worker.js');
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这样做会有一些问题，页面在首次打开的时候就进行缓存sw的资源，因为sw内预缓存资源是需要下载的，sw线程一旦在首次打开时下载资源，将会占用主线程的带宽，以及加剧对cpu和内存的使用，而且Service worker 启动之前，它必须先向浏览器 UI 线程申请分派一个线程，再回到 IO 线程继续执行 service worker 线程的启动流程，并且在随后多次在ui线程和io线程之间切换，所以在启动过程中会存在一定的性能开销，在手机端尤其严重。&lt;/p&gt;
&lt;p&gt;况且首次打开各种资源都非常宝贵，完全没有必要争第一次打开页面就要缓存资源。正确的做法是，页面加载完以后sw的事。&lt;/p&gt;
&lt;p&gt;正确的姿势：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;if ('serviceWorker' in navigator) {
  window.addEventListener('load', function() {
    navigator.serviceWorker.register('/sw.js');
  });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是仅仅是这样就够了吗？只有注册，那么发生问题的时候怎么注销sw呢？注销以后缓存如何处理？这些是要提前考虑好的&lt;/p&gt;
&lt;p&gt;另外使用 sw 进行注册时，还有一个很重要的特性，即，sw的作用域不同，监听的 fetch 请求也是不一样的。假设你的sw文件放在根目录下位于/sw/sw.js路径的话，那么你的sw就只能监听/sw/*下面的请求，如果想要监听所有请求有两个办法，一个是将sw.js放在根目录下，或者是在注册是时候设置scope。&lt;/p&gt;
&lt;p&gt;一个考虑了出错降级的简易注册demo:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;  window.addEventListener('load', function() {
    const sw = window.navigator.serviceWorker
    const killSW = window.killSW || false
    if (!sw) {
        return
    }

    if (!!killSW) {
        sw.getRegistration('/serviceWorker').then(registration =&amp;gt; {
            // 手动注销
            registration.unregister();
            // 清除缓存
            window.caches &amp;amp;&amp;amp; caches.keys &amp;amp;&amp;amp; caches.keys().then(function(keys) {
                keys.forEach(function(key) {
                 caches.delete(key);
                });
            });
        })
    } else {
        // 表示该 sw 监听的是根域名下的请求
        sw.register('/serviceWorker.js',{scope: '/'}).then(registration =&amp;gt; {
            // 注册成功后会进入回调
            console.log('Registered events at scope: ', registration.scope);
        }).catch(err =&amp;gt; {
            console.error(err)
        })
    }
  });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面部分是sw.js文件中要做的事情，在上面注册的步骤成功以后我们首先要在sw.js文件中监听注册成功以后抛出的install事件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;self.addEventListener('install', function(e) {
  // ...
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常来说，当我们监听到这个事件的时候要做的事情就是缓存所有静态文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;self.addEventListener('install', function(event) {
  event.waitUntil(
    caches.open('cache-v1').then(function(cache) {
      return cache.addAll([
        '/',
        &quot;index.html&quot;,
        &quot;main.css&quot;,
      ]);
    })
  );
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里首先执行了一个event.waitUntil函数，该函数是service worker标准提供的函数，接收一个promise参数，并且监听函数内所有的promise,只要有一个promise的结果是reject，那么这次安装就会失败。比如说cache.addAll 时，有一个资源下载不回来，即视为整个安装失败，那么后面的操作都不会执行，只能等待sw下一次重新注册。另外waitUntil还有一个重要的特性，那就是延长事件生命周期的时间，由于浏览器会随时睡眠 sw，所以为了防止执行中断就需要使用 event.waitUntil 进行捕获，当所有加载都成功时，那么 sw 就可以下一步。&lt;/p&gt;
&lt;p&gt;另外这里的缓存文件的列表通常来说我们应当使用webpack的插件或者其他工具在构建的时候自动生成。缓存的版本号也应当独立出来修改，这里我们将每一次的构建视作一个新的版本。&lt;/p&gt;
&lt;p&gt;安装成功后就会等待进入activate阶段，这里要注意的是，并不是install一旦成功就会立即抛出activate事件，如果当前页面已经存在service worker进程，那么就需要等待页面下一次被打开时新的sw才会被激活，或者使用 self.skipWaiting() 跳过等待。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;const cacheStorageKey = 'testCache1';
self.addEventListener('activate', event =&amp;gt; {
  event.waitUntil(
    caches.keys().then(cacheNames =&amp;gt; {
      return cacheNames.filter(cacheName =&amp;gt; cacheStorageKey !== cacheName);
    }).then(cachesToDelete =&amp;gt; {
      return Promise.all(cachesToDelete.map(cacheToDelete =&amp;gt; {
        return caches.delete(cacheToDelete);
      }));
    }).then(() =&amp;gt; {
      // 立即接管所有页面
      self.clients.claim()
    })
  );
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在activate中通常我们要检查并删除旧缓存，如果事件里有 event.waitUntil() 则会等待这个 Promise 完成才会成功。这时可以调用 Clients.claim() 接管所有页面，注意这会导致新版的sw接管旧版本页面。&lt;/p&gt;
&lt;p&gt;当激活完毕后就可以在fetch事件中对站点作用范围下的所有请求进行拦截处理了，你可以在这个阶段灵活的使用indexDB以及caches等api制定你的缓存规则。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;// 发起请求时去根据uri去匹配缓存，无法命中缓存则发起请求，并且缓存请求
self.addEventListener('fetch', function(event) {
  event.respondWith(
    caches.match(event.request).then(function(resp) {
      return resp || fetch(event.request).then(function(response) {
        return caches.open('v1').then(function(cache) {
          cache.put(event.request, response.clone());
          return response;
        });  
      });
    })
  );
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;event.respondWith： 接收的是一个 promise 参数，把其结果返回到受控制的 client 中，内容可以是任何自定义的响应生成代码。&lt;/p&gt;
&lt;p&gt;另外这里有一些问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;默认发起的fetch好像不会携带cookie，需要设置{ credential: 'include' }&lt;/li&gt;
&lt;li&gt;对于跨域的资源，需要设置 { mode: 'cors' } ，否则 response 中拿不到对应的数据&lt;/li&gt;
&lt;li&gt;对于缓存请求时，Request &amp;amp; Response 中的 body 只能被读取一次，因为请求和响应流只能被读取一次，其中包含 bodyUsed 属性，当使用过后，这个属性值就会变为 true， 不能再次读取，解决方法是，把 Request &amp;amp; Response clone 下来： request.clone() || response.clone()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然这只是一个demo，实际情况是不可能像这样缓存所有请求的。如果你使用工具来实现sw的话，比如sw-toolbox，通常有如下几种缓存策略：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;networkFirst：首先尝试通过网络来处理请求，如果成功就将响应存储在缓存中，否则返回缓存中的资源来回应请求。它适用于以下类型的API请求，即你总是希望返回的数据是最新的，但是如果无法获取最新数据，则返回一个可用的旧数据。&lt;/li&gt;
&lt;li&gt;cacheFirst：如果缓存中存在与网络请求相匹配的资源，则返回相应资源，否则尝试从网络获取资源。 同时，如果网络请求成功则更新缓存。此选项适用于那些不常发生变化的资源，或者有其它更新机制的资源。&lt;/li&gt;
&lt;li&gt;fastest：从缓存和网络并行请求资源，并以首先返回的数据作为响应，通常这意味着缓存版本则优先响应。一方面，这个策略总会产生网络请求，即使资源已经被缓存了。另一方面，当网络请求完成时，现有缓存将被更新，从而使得下次读取的缓存将是最新的。&lt;/li&gt;
&lt;li&gt;cacheOnly：从缓存中解析请求，如果没有对应缓存则请求失败。此选项适用于需要保证不会发出网络请求的情况，例如在移动设备上节省电量。&lt;/li&gt;
&lt;li&gt;networkOnly：尝试从网络获取网址来处理请求。如果获取资源失败，则请求失败，这基本上与不使用service worker的效果相同。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;或者根据不同的请求类型或者文件类型给予不同的策略亦或者更加复杂的策略：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;self.addEventListener('fetch', function (event) {
    var request = event.request;

    // 非 GET 请求
    if (request.method !== 'GET') {
        event.respondWith(
        ... 
        );
        return;
    }


    // HTML 页面请求
    if (request.headers.get('Accept').indexOf('text/html') !== -1) {
        event.respondWith(
        ...
        );
        return;
    }


    // get 接口请求
    if (request.headers.get('Accept').indexOf('application/json') !== -1) {
        event.respondWith(
        ...
        );
        return;
    }

    // GET 请求 且 非页面请求时 且 非 get 接口请求（一般请求静态资源）
    event.respondWith(
        ...
    );
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;-service-worker-&quot;&gt;Service Worker的更新&lt;/h2&gt;
&lt;p&gt;用户首次访问sw控制的网站或页面时，sw会立刻被下载。&lt;/p&gt;
&lt;p&gt;之后至少每24小时它会被下载一次。它可能被更频繁地下载，不过每24小时一定会被下载一次，以避免不良脚本长时间生效，这个是浏览器自己的行为。&lt;/p&gt;
&lt;p&gt;浏览器会将每一次下载回来的sw与现有的sw进行逐字节的对比，一旦发现不同就会进行安装。但是此时已经处于激活状态的旧的 sw还在运行，新的 sw 完成安装后会进入 waiting 状态。直到所有已打开的页面都关闭，旧的sw自动停止，新的sw才会在接下来重新打开的页面里生效。&lt;/p&gt;
&lt;p&gt;在 SW 中的更新可以分为两种，基本静态资源的更新和SW.js 文件自身的更新。但是不管是哪种更新，你都必须要对sw文件进行改动，也就是说要重新安装一个新的sw。&lt;/p&gt;
&lt;p&gt;首先假设一种情况，站点现有的sw缓存使用v1来进行命名，即在install的时候，我们使用caches.open('v1')来进行预缓存，这时候旧的资源会全部存在caches里的v1下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;self.addEventListener('install', function(e) {
  e.waitUntil(
    caches.open('v1').then(function(cache) {
      return cache.addAll([
       &quot;index.html&quot;
      ])
    })
  )
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在站点更新了，我们可以简单的把chache里的v1改名为v2，这个时候由于我们修改了sw文件，浏览器会自发的更新sw.js文件并触发install事件去下载最新的文件（更新缓存可以发生在任何地方），这时新的站点会存在于v2缓存下，待到新的sw被激活之后，就会启用v2缓存。&lt;/p&gt;
&lt;p&gt;这是一种很简单并且安全的方式，相当于旧版本的自然淘汰，但毕竟关闭所有页面是用户的选择而不是程序员能控制的。另外我们还需注意一点：由于浏览器的内部实现原理，当页面切换或者自身刷新时，浏览器是等到新的页面完成渲染之后再销毁旧的页面。这表示新旧两个页面中间有共同存在的交叉时间，因此简单的切换页面或者刷新是不能使得sw进行更新的，老的sw依然接管页面，新的sw依然在等待。也就是说，即使用户知道你的站点更新了，用户自行在浏览器端做f5操作，这时，由于旧的sw还未死亡，所以用户看到的还是旧版本的页面。那么我们如何能让新的sw尽快接管页面呢？&lt;/p&gt;
&lt;p&gt;那就是在sw内部使用 self.skipWaiting() 方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;self.addEventListener('install', function(e) {
  e.waitUntil(
    caches.open(cacheStorageKey).then(function(cache) {
      return cache.addAll(cacheList)
    }).then(function() {
      // 注册成功跳过等待，酌情处理
      return self.skipWaiting()
    })
  )
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是很明显，同一个页面，前半部分的请求是由旧的sw控制，而后半部分是由新的sw控制。这两者的不一致性很容易导致问题，除非你能保证同一个页面在两个版本的sw相继处理的情况下依然能够正常工作，才能够这样做。&lt;/p&gt;
&lt;p&gt;也就是说，我们最好能够保证页面从头到尾都是由一个sw来处理的，其实也很简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;navigator.serviceWorker.addEventListener('controllerchange', () =&amp;gt; {
  window.location.reload();
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以在注册sw的地方监听 controllerchange 事件来得知控制当前页面的sw是否发生了改变，然后刷新站点，让自己从头到尾都被新的sw控制，就能避免sw新旧交替的问题了。但是sw的变更就发生在加载页面后的几秒内，用户刚打开站点就遇上了莫名的刷新，如果你不想被用户拍砖的话我们再来考虑考虑更好的方式。&lt;/p&gt;
&lt;p&gt;毫无征兆的刷新页面的确不可接受，让我们来看看百度的lavas框架是怎么做的&lt;/p&gt;
&lt;p&gt;当检测到有新的sw被安装之后弹出一个提示栏来告诉用户站点已更新，并且让用户点击更新按钮，不过lavas这个通知栏非常简单（丑），实际应用的话我们可以在上面丰富内容，比如增加更新日志之类的东西，另外这个按钮也不够突出，我曾多次以为我按f5起到的作用和他是相同的，直到我理解了它的原理才发现只能通过点击这个按钮来完成新旧sw的更换。&lt;/p&gt;

&lt;center class=&quot;unindent&quot;&gt;&lt;img src=&quot;https://wt-box.worktile.com/public/f119a2a3-d551-4716-9cdf-99d347c15a6a&quot; alt=&quot;&quot; width=&quot;750px&quot;/&gt;&lt;/center&gt;

&lt;p&gt;新的sw安装完成时会触发onupdatefound的方法，通过监听这个方法来弹出一个提示栏让用户去点击按钮。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;navigator.serviceWorker.register('/service-worker.js').then(function (reg) {
   // Registration.waiting 会返回已安装的sw的状态，初始值为null
   // 这里是为了解决当用户没有点击按钮时却主动刷新了页面，但是onupdatefound事件却不会再次发生
   // 具体可以参考 https://github.com/lavas-project/lavas/issues/212
   if (reg.waiting) {
     // 通知提示栏显示
     return;
   }
   // 每当Registration.Installing属性获取新的sw时都会调用该方法
   reg.onupdatefound = function () {
     const installingWorker = reg.installing;
     // 
     installingWorker.onstatechange = function () {
       switch (installingWorker.state) {
         case 'installed':
           // 应为在sw第一次安装的时候也会调用onupdatefound，所以要检查是否已经被sw控制
           if (navigator.serviceWorker.controller) {
             // 通知提示栏显示
           }
           break;
       }
     };
   };
 }).catch(function(e) {
   console.error('Error during service worker registration:', e);
 });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就是处理通知栏点击事件之后的事情，这里只写和sw交互的部分，向等待中的sw发送消息。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;try {
  navigator.serviceWorker.getRegistration().then(reg =&amp;gt; {
    reg.waiting.postMessage('skipWaiting');
  });
} catch (e) {
  window.location.reload();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当sw接收到消息以后，执行跳过等待操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;lang-javascript&quot;&gt;// service-worker.js
// SW 不再在 install 阶段执行 skipWaiting 了
self.addEventListener('message', event =&amp;gt; {
  if (event.data === 'skipWaiting') {
    self.skipWaiting();
  }
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就是通过navigator.serviceWorker监听controllerchange事件来执行刷新操作。好了，这样一来问题就解决了，但是这种方式只能通过去点击更新按钮而无法通过用户刷新浏览器来更新。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nanianqiumo/pwa&quot; rel=&quot;nofollow&quot;&gt;完整demo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;-service-worker-&quot;&gt;Service Worker库&lt;/h2&gt;
&lt;p&gt;谷歌在早期有两个pwa的轮子：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sw-precache&lt;/li&gt;
&lt;li&gt;sw-toolbox&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;都有对应的webpack插件，但是请注意，这两个从2016年开始已经不在维护了，因为有了更好的&lt;a href=&quot;https://github.com/GoogleChrome/workbox&quot; rel=&quot;nofollow&quot;&gt;GoogleChrome/workbox&lt;/a&gt;，google官方也推荐大家使用workbox，百度的lavas现在也是在使用该轮子。&lt;/p&gt;
&lt;p&gt;另外还有同时支持AppCache的&lt;a href=&quot;https://github.com/NekR/offline-plugin&quot; rel=&quot;nofollow&quot;&gt;NekR/offline-plugin&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;本文作者：闫冬&lt;/p&gt;
&lt;p&gt;文章来源：&lt;a href=&quot;https://worktile.com/blog/tech?utm_medium=meiyang&quot; target=&quot;_blank&quot;&gt;Worktile技术博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;欢迎访问交流更多关于技术及协作的问题。&lt;/p&gt;
&lt;p&gt;文章转载请注明出处。&lt;/p&gt;
</description>
<pubDate>Fri, 22 Feb 2019 06:41:00 +0000</pubDate>
<dc:creator>Worktile</dc:creator>
<og:description>Service Worker 随着前端快速发展，应用的性能已经变得至关重要，关于这一点大佬做了很多统计。你可以去看看。 如何降低一个页面的网络请求成本从而缩短页面加载资源的时间并降低用户可感知的延时是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/worktile/p/10418283.html</dc:identifier>
</item>
<item>
<title>SpringBoot集成rabbitmq（二） - garfieldzf</title>
<link>http://www.cnblogs.com/sword-successful/p/10418288.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sword-successful/p/10418288.html</guid>
<description>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;         在使用rabbitmq时，我们可以通过消息持久化来解决服务器因异常崩溃而造成的消息丢失。除此之外，我们还会遇到一个问题，当消息生产者发消息发送出去后，消息到底有没有正确到达服务器呢？如果不进行特殊配置，默认情况下发送的消息是不会给生产者返回任何响应的，也就是默认情况下生产者并不知道消息是否正常到达了服务器。对于数据必达的需求，你肯定对消息的来龙去脉都有个了接，这种情况下就需要用到rabbitmq消息确认。&lt;/p&gt;

&lt;h3&gt;消息确认&lt;/h3&gt;
&lt;p&gt;      rabbitmq消息确认分为生产者确认和消费者确认。&lt;/p&gt;
&lt;h4&gt;      生产者消费确认提供了两种机制：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;      通过事务机制实现&lt;/li&gt;
&lt;li&gt;      通过confirm机制实现&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;     事务机制则用到channel.txSelect、channel.txCommit、channel.txRollback。可以参考下面AMQP协议流转过程（参考Rabbitmq实战指南）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/115511/201902/115511-20190222141049386-1405858703.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     事务机制在一条消息发送之后会阻塞发送端，以等待rabbitmq回应，之后才继续发送下一条消息。所以相对来说事务机制的性能要差一些。事务机制会降低rabbitmq的吞吐量，所以又引入了另一种轻量级的方式：&lt;span&gt;&lt;strong&gt;confirm机制。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;     &lt;/strong&gt;&lt;/span&gt;生产者通过调用channel.confirmSelect将信道设置为confirm模式，之后Rabbitmq会返回Confirm.Select-Ok命令表示同意生产者将当前信道设置为confirm模式。所有被发送的后续消息都被ack或nack一次。类似如下代码：&lt;/p&gt;
&lt;p&gt;     channel.confirmSelect()&lt;/p&gt;
&lt;p&gt;     channel.basicPublish(&quot;exchange&quot;,&quot;routingkey&quot;,null,&quot;test&quot;.getBytes())&lt;/p&gt;
&lt;p&gt;     confirm机制流转过程参考下图（参考Rabbitmq实战指南）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/115511/201902/115511-20190222142115894-2096309295.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;   消费者确认&lt;/h4&gt;
&lt;p&gt;        消费者在订阅消息队列时指定&lt;span&gt;&lt;strong&gt;autoAck&lt;/strong&gt;&lt;/span&gt;参数。当参数设置为false时rabbitmq会等待消费者显式回复确认信号才会从内存或者磁盘种删除这条消息。参数默认为true。当autoAck设置为false时，对于rabbitmq服务器而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息、一部分是已经投递给消费者的消息但是还没有收到确认信号的消息。可通过RabbitMQ Web平台查看队列中Ready和UnAck对应的数量。&lt;/p&gt;
&lt;p&gt;       消费者消息确认涉及到3个方法：channel.basicAck、channel.basicNack、channel.basicReject&lt;/p&gt;

&lt;h3&gt;SpringBoot集成rabbitmq下实现消息确认&lt;/h3&gt;
&lt;p&gt;       springboot集成rabbitmq实现消息确认主要涉及两个回调方法（ReturnCallback、ConfirmCallback）。这里消费者部分我用两种方式来实现。一种是基于SimpleMessageListenerContainer。 另一种就是用RabbitListener注解实现。&lt;/p&gt;
&lt;h4&gt;1、application.yml&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
spring:
  rabbitmq:
    host: 192.168.80.128
    port: 5672
    username: admin
    password: admin
    virtual-host: /
    publisher-confirms: true
    publisher-returns: true
    listener:
      simple:
        acknowledge-mode: manual
        concurrency: 1
        max-concurrency: 10
        retry:
          enabled: true
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;2、配置文件（这里实现ReturnCallback、ConfirmCallback）&lt;/h4&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;55&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import com.rabbitmq.client.Channel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.connection.ConnectionFactory;
import org.springframework.amqp.core.*;
import org.springframework.amqp.rabbit.connection.CorrelationData;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;
import org.springframework.amqp.rabbit.listener.api.ChannelAwareMessageListener;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.lang.Nullable;


@Configuration
public class MqConfig {

    private Logger logger= LoggerFactory.getLogger(MqConfig.class);

    @Autowired
    RabbitTemplate rabbitTemplate;

    @Autowired
    ConnectionFactory connectionFactory;

    @Bean
    public Queue queue(){
        return new Queue(&quot;testMq&quot;,true); //持久化队列（默认值也是true）
    }

    @Bean
    public DirectExchange directExchange(){
        return new DirectExchange(&quot;testMq&quot;,true,false);
    }

    @Bean
    Binding binding(Queue queue,DirectExchange directExchange){
        return BindingBuilder.bind(queue).to(directExchange).with(&quot;testMq&quot;);
    }

    /**
     * i-&amp;gt;replyCode
     * s-&amp;gt;replyText
     * s1-&amp;gt;exchange
     * s2-&amp;gt;routingKey
     * **/
    //消息从交换器发送到队列失败时触发
    RabbitTemplate.ReturnCallback msgReturnCallback=new RabbitTemplate.ReturnCallback() {
        @Override
        public void returnedMessage(Message message, int i, String s, String s1, String s2) {

            logger.info(&quot;消息：{}，错误码：{}，失败原因：{}，交换器：{}，路由key：{}&quot;,message.getMessageProperties().getCorrelationId(),i,s,s1,s2);
        }
    };

    //消息发送到交换器时触发
    RabbitTemplate.ConfirmCallback msgConfirmCallback=new RabbitTemplate.ConfirmCallback() {
        @Override
        public void confirm(@Nullable CorrelationData correlationData, boolean b, @Nullable String s) {
            if(b){
                logger.info(&quot;消息{}发送exchange成功&quot;,correlationData.getId());
            }else{
                logger.info(&quot;消息发送到exchange失败，原因：{}&quot;,s);
            }
        }
    };

    /***
     * 消费者确认（方式二）
     * **/
    @Bean
    public SimpleMessageListenerContainer listenerContainer(){
        SimpleMessageListenerContainer container=new SimpleMessageListenerContainer();
        container.setConnectionFactory(connectionFactory);
        container.setQueueNames(&quot;testMq&quot;);
        container.setExposeListenerChannel(true);
        container.setMaxConcurrentConsumers(10);
        container.setConcurrentConsumers(1);
        container.setAcknowledgeMode(AcknowledgeMode.MANUAL);
        container.setMessageListener(new ChannelAwareMessageListener() {
            @Override
            public void onMessage(Message message, Channel channel) throws Exception {
                try{
                    channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);
                    logger.info(&quot;接收消息：{}&quot;,new String(message.getBody()));
                }catch (Exception ex){

                    //channel.basicReject
                    //channel.basicNack

                }

            }
        });

        return container;
    }


    /**
     * 生产者的回调都在这里
     * **/
    @Autowired
    public RabbitTemplate rabbitTemplate(){
        //消息发送失败后返回到队列中
        rabbitTemplate.setMandatory(true);

        rabbitTemplate.setReturnCallback(msgReturnCallback);
        rabbitTemplate.setConfirmCallback(msgConfirmCallback);

        return rabbitTemplate;
    }


}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　另一种消费端实现方式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import com.rabbitmq.client.Channel;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.core.Message;
import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.stereotype.Component;

import java.io.IOException;

@Component
public class MqConsumer {

    private Logger logger= LoggerFactory.getLogger(MqConsumer.class);
    @RabbitListener(queues = &quot;testMq&quot;)
    public void handler(Message message,Channel channel){
        try {
            channel.basicAck(message.getMessageProperties().getDeliveryTag(),false);
            logger.info(&quot;接收消息：{}&quot;,new String(message.getBody()));
        } catch (IOException e) {


            e.printStackTrace();
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;3、消息生产者&lt;/h4&gt;
&lt;p&gt;     消息发送时注意生成一个消息id。一开始没用到这个参数，在消息接收时消费者会抛空指针异常&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.amqp.rabbit.connection.CorrelationData;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.UUID;


@Controller
@RequestMapping(&quot;/rabbitMq&quot;)
public class MqController {

    private Logger logger= LoggerFactory.getLogger(MqController.class);

    @Autowired
    RabbitTemplate rabbitTemplate;

    @RequestMapping(&quot;/sendMq&quot;)
    @ResponseBody
    public String sendMq(){

        /**
         * 这里exchange、routingkey都叫testMq
         * **/
        Object message=null;
        for(int i=0;i&amp;lt;10;i++){
            logger.info(&quot;生产者：第{}条消息&quot;,i);
            CorrelationData correlationId=new CorrelationData(UUID.randomUUID().toString());
            message=&quot;第&quot;+i+&quot;条消息&quot;;
            rabbitTemplate.convertAndSend(&quot;testMq&quot;,&quot;testMq&quot;,message,correlationId);
        }

        return &quot;sending...&quot;;

    }



}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/115511/201902/115511-20190222143805891-605645663.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    从运行截图中可以看到生产者和消费者都收到对应的回调消息。&lt;/p&gt;

</description>
<pubDate>Fri, 22 Feb 2019 06:41:00 +0000</pubDate>
<dc:creator>garfieldzf</dc:creator>
<og:description>前言 在使用rabbitmq时，我们可以通过消息持久化来解决服务器因异常崩溃而造成的消息丢失。除此之外，我们还会遇到一个问题，当消息生产者发消息发送出去后，消息到底有没有正确到达服务器呢？如果不进行特</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sword-successful/p/10418288.html</dc:identifier>
</item>
</channel>
</rss>