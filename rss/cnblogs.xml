<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>深入理解JDK中的Reference原理和源码实现 - throwable</title>
<link>http://www.cnblogs.com/throwable/p/12271653.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/throwable/p/12271653.html</guid>
<description>&lt;h2 id=&quot;前提&quot;&gt;前提&lt;/h2&gt;
&lt;p&gt;这篇文章主要基于JDK11的源码和最近翻看的《深入理解Java虚拟机-2nd》一书的部分内容，对JDK11中的&lt;code&gt;Reference&lt;/code&gt;(引用)做一些总结。值得注意的是，通过笔者对比一下JDK11和JDK8对于&lt;code&gt;java.lang.ref&lt;/code&gt;包的相关实现，发现代码变化比较大，&lt;strong&gt;因此本文的源码分析可能并不适合于JDK11之外的JDK版本&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;reference的简介和分类&quot;&gt;Reference的简介和分类&lt;/h2&gt;
&lt;p&gt;在JDK1.2之前，Java中的引用的定义是十分传统的：如果reference类型的数据中存储的数值代表的是另一块内存的起始地址，就称这块内存代表着一个引用。在这种定义之下，一个对象只有被引用和没有被引用两种状态。&lt;/p&gt;
&lt;p&gt;实际上，我们更希望存在这样的一类对象：当内存空间还足够的时候，这些对象能够保留在内存空间中；如果当内存空间在进行了垃圾收集之后还是非常紧张，则可以抛弃这些对象。基于这种特性，可以满足很多系统的缓存功能的使用场景。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;java.lang.ref&lt;/code&gt;包是JDK1.2引入的，包结构和类分布如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;- java.lang.ref
  - Cleaner.class
  - Finalizer.class
  - FinalizerHistogram.class
  - FinalReference.class
  - PhantomReference.class
  - Reference.class
  - ReferenceQueue.class
  - SoftReference.classs
  - WeakReference.class&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;引入此包的作用是对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)四种类型的引用，还有一种比较特殊的引用是析构引用(Final Reference)，它是一种特化的虚引用。四种引用的强度按照下面的次序依次减弱：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;StrongReference &amp;gt; SoftReference &amp;gt; WeakReference &amp;gt; PhantomReference&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;值得注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;强引用没有对应的类型表示，也就是说强引用是普遍存在的，如&lt;code&gt;Object object = new Object();&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;软引用、弱引用和虚引用都是&lt;code&gt;java.lang.ref.Reference&lt;/code&gt;的直接子类。&lt;/li&gt;
&lt;li&gt;直到JDK11为止，只存在四种引用，这些引用是由JVM创建，因此直接继承&lt;code&gt;java.lang.ref.Reference&lt;/code&gt;创建自定义的引用类型是无效的，但是可以直接继承已经存在的引用类型，如&lt;code&gt;java.lang.ref.Cleaner&lt;/code&gt;就是继承自&lt;code&gt;java.lang.ref.PhantomReference&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;特殊的&lt;code&gt;java.lang.ref.Reference&lt;/code&gt;的子类&lt;code&gt;java.lang.ref.FinalReference&lt;/code&gt;和&lt;code&gt;Object#finalize()&lt;/code&gt;有关，&lt;code&gt;java.lang.ref.Finalizer&lt;/code&gt;是&lt;code&gt;java.lang.ref.FinalReference&lt;/code&gt;子类，下文会详细分析这些内容。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Reference&lt;/code&gt;就是引用，对JVM的垃圾收集活动敏感(当然，强引用可能对垃圾收集活动是不敏感的)，&lt;code&gt;Reference&lt;/code&gt;的继承关系或者实现是由JDK定制，引用实例是由JVM创建，所以自行继承&lt;code&gt;Reference&lt;/code&gt;实现自定义的引用类型是无意义的，但是可以继承已经存在的引用类型，如&lt;code&gt;SoftReference&lt;/code&gt;等。&lt;code&gt;Reference&lt;/code&gt;类文件的注释也比较简短，但是方法和变量的注释十分详细，特别是用图表表明了状态跃迁的过程，这里先看类文件头注释：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Abstract base class for reference objects. This class defines the operations common to all reference objects. Because reference objects are implemented in close cooperation with the garbage collector, this class may not be subclassed directly.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译一下大意是：&lt;code&gt;Reference&lt;/code&gt;是所有引用对象的基类。这个类定义了所有引用对象的通用操作。因为引用对象是与垃圾收集器紧密协作而实现的，所以这个类可能不能直接子类化。&lt;/p&gt;
&lt;h3 id=&quot;reference的状态集合&quot;&gt;Reference的状态集合&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Reference&lt;/code&gt;源码中并不存在一个成员变量用于描述&lt;code&gt;Reference&lt;/code&gt;的状态，它是通过组合判断referent、discovered、queue、next成员的存在性或者顺序&quot;拼凑出&quot;对应的状态，注释中描述如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;一个引用对象可以同时存在两种状态：
- 第一组状态：&quot;active&quot;, &quot;pending&quot;, or &quot;inactive&quot;
- 第二组状态：&quot;registered&quot;, &quot;enqueued&quot;, &quot;dequeued&quot;, or &quot;unregistered&quot;

Active：

当前引用实例处于Active状态，会收到垃圾收集器的特殊处理。在垃圾收集器检测到referent的可达性已更改为适当状态之后的某个时间，垃圾收集器会&quot;通知&quot;当前引用实例改变其状态为&quot;pending&quot;或者&quot;inactive&quot;。此时的判断条件是：referent != null; discovered = null或者实例位于GC的discovered列表中。

Pending：

当前的引用实例是pending-Reference列表的一个元素，等待被ReferenceHandler线程处理。pending-Reference列表通过应用实例的discovered字段进行关联。此时的判断条件是：referent = null; discovered = pending-Reference列表中的下一个元素

Inactive：

当前的引用实例处于非Active和非Pending状态。此时的判断条件是：referent = null (同时discovered = null)

Registered：

当前的引用实例创建的时候关联到一个引用队列实例，但是引用实例暂未加入到队列中。此时的判断条件是：queue = 传入的ReferenceQueue实例

Enqueued：

当前的引用实例已经添加到和它关联的引用队列中但是尚未移除(remove)，也就是调用了ReferenceQueue.enqueued()后的Reference实例就会处于这个状态。此时的判断条件是：queue = ReferenceQueue.ENQUEUE; next = 引用列表中的下一个引用实例，或者如果当前引用实例是引用列表中的最后一个元素，则它会进入Inactive状态

Dequeued：

当前的引用实例曾经添加到和它关联的引用队列中并且已经移除(remove)。此时的判断条件是：queue = ReferenceQueue.NULL; next = 当前的引用实例

Unregistered：

当前的引用实例不存在关联的引用队列，也就是创建引用实例的时候传入的queue为null。此时的判断条件是：queue = ReferenceQueue.NULL&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;状态跃迁的时序图如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;     * Initial states:
     *   [active/registered]
     *   [active/unregistered] [1]
     *
     * Transitions:
     *                            clear
     *   [active/registered]     -------&amp;gt;   [inactive/registered]
     *          |                                 |
     *          |                                 | enqueue [2]
     *          | GC              enqueue [2]     |
     *          |                -----------------|
     *          |                                 |
     *          v                                 |
     *   [pending/registered]    ---              v
     *          |                   | ReferenceHandler
     *          | enqueue [2]       |---&amp;gt;   [inactive/enqueued]
     *          v                   |             |
     *   [pending/enqueued]      ---              |
     *          |                                 | poll/remove
     *          | poll/remove                     |
     *          |                                 |
     *          v            ReferenceHandler     v
     *   [pending/dequeued]      ------&amp;gt;    [inactive/dequeued]
     *
     *
     *                           clear/enqueue/GC [3]
     *   [active/unregistered]   ------
     *          |                      |
     *          | GC                   |
     *          |                      |--&amp;gt; [inactive/unregistered]
     *          v                      |
     *   [pending/unregistered]  ------
     *                           ReferenceHandler
     *
     * Terminal states:
     *   [inactive/dequeued]
     *   [inactive/unregistered]
     *
     * Unreachable states (because enqueue also clears):
     *   [active/enqeued]
     *   [active/dequeued]
     *
     * [1] Unregistered is not permitted for FinalReferences.
     *
     * [2] These transitions are not possible for FinalReferences, making
     * [pending/enqueued] and [pending/dequeued] unreachable, and
     * [inactive/registered] terminal.
     *
     * [3] The garbage collector may directly transition a Reference
     * from [active/unregistered] to [inactive/unregistered],
     * bypassing the pending-Reference list.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注释中还强调了几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;初始化状态：&lt;code&gt;[active/registered]&lt;/code&gt;和&lt;code&gt;[active/unregistered](这种情况只限于FinalReferences)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;终结状态：&lt;code&gt;[inactive/dequeued]&lt;/code&gt;和&lt;code&gt;[inactive/unregistered]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;不可能出现的状态：&lt;code&gt;[active/enqeued]&lt;/code&gt;和&lt;code&gt;[active/dequeued]&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面的图看起来可能比较抽象，&lt;code&gt;ReferenceHandler&lt;/code&gt;其实是&lt;code&gt;Reference&lt;/code&gt;中静态代码块中初始化的线程实例，主要作用是：处理pending状态的引用实例，使它们入队列并走向&lt;code&gt;[inactive/dequeued]&lt;/code&gt;状态。另外，上面的线框图是分两部分，其中上半部分是使用了&lt;code&gt;ReferenceQueue&lt;/code&gt;，后半部分是没有使用&lt;code&gt;ReferenceQueue&lt;/code&gt;(或者说使用了&lt;code&gt;ReferenceQueue.NULL&lt;/code&gt;)。这里尝试用PPT画一下简化的状态跃迁图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412331/202002/1412331-20200207000857194-1169555854.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412331/202002/1412331-20200207000902415-1750522157.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;reference源码分析&quot;&gt;Reference源码分析&lt;/h3&gt;
&lt;p&gt;先看&lt;code&gt;Reference&lt;/code&gt;的构造函数和成员变量：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public abstract class Reference&amp;lt;T&amp;gt; {
   private T referent;
   volatile ReferenceQueue&amp;lt;? super T&amp;gt; queue;
   volatile Reference next;
   private transient Reference&amp;lt;T&amp;gt; discovered;

   Reference(T referent) {
        this(referent, null);
   }

   Reference(T referent, ReferenceQueue&amp;lt;? super T&amp;gt; queue) {
        this.referent = referent;
        this.queue = (queue == null) ? ReferenceQueue.NULL : queue;
   }
}  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;构造描述&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;构造函数依赖于一个泛型的referent成员以及一个&lt;code&gt;ReferenceQueue&amp;lt;? super T&amp;gt;&lt;/code&gt;的队列，如果&lt;code&gt;ReferenceQueue&lt;/code&gt;实例为null，则使用&lt;code&gt;ReferenceQueue.NULL&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成员变量描述&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;referent：&lt;code&gt;Reference&lt;/code&gt;保存的引用指向的对象，下面直接称为referent。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// GC特殊处理的对象
private T referent;         /* Treated specially by GC */&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;queue：&lt;code&gt;Reference&lt;/code&gt;对象关联的队列，也就是引用队列，对象如果即将被垃圾收集器回收，此队列作为通知的回调队列，也就是当&lt;code&gt;Reference&lt;/code&gt;实例持有的对象referent要被回收的时候，&lt;code&gt;Reference&lt;/code&gt;实例会被放入引用队列，那么程序执行的时候可以从引用队列得到或者监控相应的&lt;code&gt;Reference&lt;/code&gt;实例。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /* The queue this reference gets enqueued to by GC notification or by
     * calling enqueue().
     *
     * When registered: the queue with which this reference is registered.
     *        enqueued: ReferenceQueue.ENQUEUE
     *        dequeued: ReferenceQueue.NULL
     *    unregistered: ReferenceQueue.NULL
     */
    volatile ReferenceQueue&amp;lt;? super T&amp;gt; queue;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;next：下一个&lt;code&gt;Reference&lt;/code&gt;实例的引用，&lt;code&gt;Reference&lt;/code&gt;实例通过此构造单向的链表。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    /* The link in a ReferenceQueue's list of Reference objects.
     *
     * When registered: null
     *        enqueued: next element in queue (or this if last)
     *        dequeued: this (marking FinalReferences as inactive)
     *    unregistered: null
     */
    @SuppressWarnings(&quot;rawtypes&quot;)
    volatile Reference next;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;discovered：注意这个属性由transient修饰，基于状态表示不同链表中的下一个待处理的对象，主要是pending-reference列表的下一个元素，通过JVM直接调用赋值。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/* When active:  next element in a discovered reference list maintained by GC (or this if last)
*     pending:   next element in the pending list (or null if last)
*     otherwise:   NULL
*/
transient private Reference&amp;lt;T&amp;gt; discovered;  /* used by VM */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;实例方法(和ReferenceHandler线程不相关的方法)&lt;/strong&gt;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 获取持有的referent实例
@HotSpotIntrinsicCandidate
public T get() {
     return this.referent;
}

// 把持有的referent实例置为null
public void clear() {
     this.referent = null;
}

// 判断是否处于enqeued状态
public boolean isEnqueued() {
     return (this.queue == ReferenceQueue.ENQUEUED);
}

// 入队参数，同时会把referent置为null
public boolean enqueue() {
     this.referent = null;
     return this.queue.enqueue(this);
}

// 覆盖clone方法并且抛出异常，也就是禁止clone
@Override
protected Object clone() throws CloneNotSupportedException {
     throw new CloneNotSupportedException();
}

// 确保给定的引用实例是强可达的
@ForceInline
public static void reachabilityFence(Object ref) {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;referencehandler线程&quot;&gt;ReferenceHandler线程&lt;/h3&gt;
&lt;p&gt;ReferenceHandler线程是由&lt;code&gt;Reference&lt;/code&gt;静态代码块中建立并且运行的线程，它的运行方法中依赖了比较多的本地(native)方法，ReferenceHandler线程的主要功能是处理pending链表中的引用对象：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    // ReferenceHandler直接继承于Thread覆盖了run方法
    private static class ReferenceHandler extends Thread {
        
        // 静态工具方法用于确保对应的类型已经初始化
        private static void ensureClassInitialized(Class&amp;lt;?&amp;gt; clazz) {
            try {
                Class.forName(clazz.getName(), true, clazz.getClassLoader());
            } catch (ClassNotFoundException e) {
                throw (Error) new NoClassDefFoundError(e.getMessage()).initCause(e);
            }
        }

        static {
            // 确保Cleaner这个类已经初始化
            // pre-load and initialize Cleaner class so that we don't
            // get into trouble later in the run loop if there's
            // memory shortage while loading/initializing it lazily.
            ensureClassInitialized(Cleaner.class);
        }

        ReferenceHandler(ThreadGroup g, String name) {
            super(g, null, name, 0, false);
        }
        
        // 注意run方法是一个死循环执行processPendingReferences
        public void run() {
            while (true) {
                processPendingReferences();
            }
        }
    }

    /* 原子获取(后)并且清理VM中的pending引用链表
     * Atomically get and clear (set to null) the VM's pending-Reference list.
     */
    private static native Reference&amp;lt;Object&amp;gt; getAndClearReferencePendingList();

    /* 检验VM中的pending引用对象链表是否有剩余元素
     * Test whether the VM's pending-Reference list contains any entries.
     */
    private static native boolean hasReferencePendingList();

    /* 等待直到pending引用对象链表不为null，此方法阻塞的具体实现又VM实现
     * Wait until the VM's pending-Reference list may be non-null.
     */
    private static native void waitForReferencePendingList();

    // 锁对象，用于控制等待pending对象时候的加锁和开始处理这些对象时候的解锁
    private static final Object processPendingLock = new Object();
    // 正在处理pending对象的时候，这个变量会更新为true，处理完毕或者初始化状态为false，用于避免重复处理或者重复等待
    private static boolean processPendingActive = false;

    // 这个是死循环中的核心方法，功能是处理pending链表中的引用元素
    private static void processPendingReferences() {
        // Only the singleton reference processing thread calls
        // waitForReferencePendingList() and getAndClearReferencePendingList().
        // These are separate operations to avoid a race with other threads
        // that are calling waitForReferenceProcessing().
        // （1）等待
        waitForReferencePendingList();
        Reference&amp;lt;Object&amp;gt; pendingList;
        synchronized (processPendingLock) {
            // （2）获取并清理，标记处理中状态
            pendingList = getAndClearReferencePendingList();
            processPendingActive = true;
        }
        // （3）通过discovered(下一个元素)遍历pending链表进行处理
        while (pendingList != null) {
            Reference&amp;lt;Object&amp;gt; ref = pendingList;
            pendingList = ref.discovered;
            ref.discovered = null;
            // 如果是Cleaner类型执行执行clean方法并且对锁对象processPendingLock进行唤醒所有阻塞的线程
            if (ref instanceof Cleaner) {
                ((Cleaner)ref).clean();
                // Notify any waiters that progress has been made.
                // This improves latency for nio.Bits waiters, which
                // are the only important ones.
                synchronized (processPendingLock) {
                    processPendingLock.notifyAll();
                }
            } else {
                // 非Cleaner类型并且引用队列不为ReferenceQueue.NULL则进行入队操作
                ReferenceQueue&amp;lt;? super Object&amp;gt; q = ref.queue;
                if (q != ReferenceQueue.NULL) q.enqueue(ref);
            }
        }
        // （4）当次循环结束之前再次唤醒锁对象processPendingLock上阻塞的所有线程
        // Notify any waiters of completion of current round.
        synchronized (processPendingLock) {
            processPendingActive = false;
            processPendingLock.notifyAll();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ReferenceHandler线程启动的静态代码块如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    static {
        // ThreadGroup继承当前执行线程(一般是主线程)的线程组
        ThreadGroup tg = Thread.currentThread().getThreadGroup();
        for (ThreadGroup tgn = tg;
             tgn != null;
             tg = tgn, tgn = tg.getParent());
        // 创建线程实例，命名为Reference Handler，配置最高优先级和后台运行(守护线程)，然后启动
        Thread handler = new ReferenceHandler(tg, &quot;Reference Handler&quot;);
        /* If there were a special system-only priority greater than
         * MAX_PRIORITY, it would be used here
         */
        handler.setPriority(Thread.MAX_PRIORITY);
        handler.setDaemon(true);
        handler.start();
        // 注意这里覆盖了全局的jdk.internal.misc.JavaLangRefAccess实现
        // provide access in SharedSecrets
        SharedSecrets.setJavaLangRefAccess(new JavaLangRefAccess() {
            @Override
            public boolean waitForReferenceProcessing()
                throws InterruptedException{
                return Reference.waitForReferenceProcessing();
            }

            @Override
            public void runFinalization() {
                Finalizer.runFinalization();
            }
        });
    }

    // 如果正在处理pending链表中的引用对象或者监测到VM中的pending链表中还有剩余元素则基于锁对象processPendingLock进行等待
    private static boolean waitForReferenceProcessing()
        throws InterruptedException{
        synchronized (processPendingLock) {
            if (processPendingActive || hasReferencePendingList()) {
                // Wait for progress, not necessarily completion.
                processPendingLock.wait();
                return true;
            } else {
                return false;
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于ReferenceHandler线程是&lt;code&gt;Reference&lt;/code&gt;的静态代码创建的，所以只要&lt;code&gt;Reference&lt;/code&gt;这个父类被初始化，该线程就会创建和运行，由于它是守护线程，除非JVM进程终结，否则它会一直在后台运行(注意它的&lt;code&gt;run()&lt;/code&gt;方法里面使用了死循环)。&lt;/p&gt;
&lt;h2 id=&quot;referencequeue&quot;&gt;ReferenceQueue&lt;/h2&gt;
&lt;p&gt;JDK中对&lt;code&gt;ReferenceQueue&lt;/code&gt;的文档描述是比较少的，类文件只有一句简单的注释：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;翻译一下大意为：引用队列，垃圾收集器在检测到适当的可达性更改后将已注册的引用对象追加到该队列。&lt;/p&gt;
&lt;p&gt;从源码上看，实际上&lt;code&gt;ReferenceQueue&lt;/code&gt;只是名义上的引用队列，它只保存了&lt;code&gt;Reference&lt;/code&gt;链表的头(&lt;strong&gt;head&lt;/strong&gt;)节点，并且提供了出队、入队和移除等操作，而&lt;code&gt;Reference&lt;/code&gt;实际上本身提供单向链表的功能，&lt;strong&gt;也就是&lt;code&gt;Reference&lt;/code&gt;通过成员属性next构建单向链表，而链表的操作是委托给&lt;code&gt;ReferenceQueue&lt;/code&gt;完成，这里的逻辑有点绕&lt;/strong&gt;。&lt;code&gt;ReferenceQueue&lt;/code&gt;的源码比较少，这里全量贴出标注一下注释：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ReferenceQueue&amp;lt;T&amp;gt; {

    public ReferenceQueue() { }
    
    // 内部类Null类继承自ReferenceQueue，覆盖了enqueue方法返回false
    private static class Null extends ReferenceQueue&amp;lt;Object&amp;gt; {
        boolean enqueue(Reference&amp;lt;?&amp;gt; r) {
            return false;
        }
    }
    
    // ReferenceQueue.NULL和ReferenceQueue.ENQUEUED都是内部类Null的新实例
    static final ReferenceQueue&amp;lt;Object&amp;gt; NULL = new Null();
    static final ReferenceQueue&amp;lt;Object&amp;gt; ENQUEUED = new Null();
    
    // 静态内部类，作为锁对象
    private static class Lock { };
    // 锁实例
    private final Lock lock = new Lock();
    // 引用链表的头节点
    private volatile Reference&amp;lt;? extends T&amp;gt; head;
    // 引用队列长度，入队则增加1，出队则减少1
    private long queueLength = 0;  

    // 入队操作，只会被Reference实例调用
    boolean enqueue(Reference&amp;lt;? extends T&amp;gt; r) { /* Called only by Reference class */
        // 加锁
        synchronized (lock) {
            // Check that since getting the lock this reference hasn't already been
            // enqueued (and even then removed)
            // 如果引用实例持有的队列为ReferenceQueue.NULL或者ReferenceQueue.ENQUEUED则入队失败返回false
            ReferenceQueue&amp;lt;?&amp;gt; queue = r.queue;
            if ((queue == NULL) || (queue == ENQUEUED)) {
                return false;
            }
            assert queue == this;
            // Self-loop end, so if a FinalReference it remains inactive.
            // 如果链表没有元素，则此引用实例直接作为头节点，否则把前一个引用实例作为下一个节点
            r.next = (head == null) ? r : head;
            // 当前实例更新为头节点，也就是每一个新入队的引用实例都是作为头节点，已有的引用实例会作为后继节点
            head = r;
            // 队列长度增加1
            queueLength++;
            // Update r.queue *after* adding to list, to avoid race
            // with concurrent enqueued checks and fast-path poll().
            // Volatiles ensure ordering.
            // 当前引用实例已经入队，那么它本身持有的引用队列实例置为ReferenceQueue.ENQUEUED
            r.queue = ENQUEUED;
            // 特殊处理FinalReference，VM进行计数
            if (r instanceof FinalReference) {
                VM.addFinalRefCount(1);
            }
            // 唤醒所有等待的线程
            lock.notifyAll();
            return true;
        }
    }

    // 引用队列的poll操作，此方法必须在加锁情况下调用
    private Reference&amp;lt;? extends T&amp;gt; reallyPoll() {       /* Must hold lock */
        Reference&amp;lt;? extends T&amp;gt; r = head;
        if (r != null) {
            r.queue = NULL;
            // Update r.queue *before* removing from list, to avoid
            // race with concurrent enqueued checks and fast-path
            // poll().  Volatiles ensure ordering.
            @SuppressWarnings(&quot;unchecked&quot;)
            Reference&amp;lt;? extends T&amp;gt; rn = r.next;
            // Handle self-looped next as end of list designator.
            // 更新next节点为头节点，如果next节点为自身，说明已经走过一次出队，则返回null
            head = (rn == r) ? null : rn;
            // Self-loop next rather than setting to null, so if a
            // FinalReference it remains inactive.
            // 当前头节点变更为环状队列，考虑到FinalReference尚为inactive和避免重复出队的问题
            r.next = r;
            // 队列长度减少1
            queueLength--;
            // 特殊处理FinalReference，VM进行计数
            if (r instanceof FinalReference) {
                VM.addFinalRefCount(-1);
            }
            return r;
        }
        return null;
    }

    // 队列的公有poll操作，主要是加锁后调用reallyPoll
    public Reference&amp;lt;? extends T&amp;gt; poll() {
        if (head == null)
            return null;
        synchronized (lock) {
            return reallyPoll();
        }
    }
    
    // 移除引用队列中的下一个引用元素，实际上也是依赖于reallyPoll的Object提供的阻塞机制
    public Reference&amp;lt;? extends T&amp;gt; remove(long timeout)
        throws IllegalArgumentException, InterruptedException{
        if (timeout &amp;lt; 0) {
            throw new IllegalArgumentException(&quot;Negative timeout value&quot;);
        }
        synchronized (lock) {
            Reference&amp;lt;? extends T&amp;gt; r = reallyPoll();
            if (r != null) return r;
            long start = (timeout == 0) ? 0 : System.nanoTime();
            for (;;) {
                lock.wait(timeout);
                r = reallyPoll();
                if (r != null) return r;
                if (timeout != 0) {
                    long end = System.nanoTime();
                    timeout -= (end - start) / 1000_000;
                    if (timeout &amp;lt;= 0) return null;
                    start = end;
                }
            }
        }
    }
    
    // remove，超时时间为0，实际上就是lock.wait(0)就是永久阻塞直至唤醒
    public Reference&amp;lt;? extends T&amp;gt; remove() throws InterruptedException {
        return remove(0);
    } 

    // foreach
    void forEach(Consumer&amp;lt;? super Reference&amp;lt;? extends T&amp;gt;&amp;gt; action) {
        for (Reference&amp;lt;? extends T&amp;gt; r = head; r != null;) {
            action.accept(r);
            @SuppressWarnings(&quot;unchecked&quot;)
            Reference&amp;lt;? extends T&amp;gt; rn = r.next;
            if (rn == r) {
                if (r.queue == ENQUEUED) {
                    // still enqueued -&amp;gt; we reached end of chain
                    r = null;
                } else {
                    // already dequeued: r.queue == NULL; -&amp;gt;
                    // restart from head when overtaken by queue poller(s)
                    r = head;
                }
            } else {
                // next in chain
                r = rn;
            }
        }
    }       
}    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ReferenceQueue&lt;/code&gt;的源码十分简单，还是重新提一下，它只存储了&lt;code&gt;Reference&lt;/code&gt;链表的头节点，真正的&lt;code&gt;Reference&lt;/code&gt;链表的所有节点是存储在&lt;code&gt;Reference&lt;/code&gt;实例本身，通过属性next拼接的，&lt;code&gt;ReferenceQueue&lt;/code&gt;提供了对&lt;code&gt;Reference&lt;/code&gt;链表的入队、poll、remove等操作。&lt;/p&gt;
&lt;h2 id=&quot;判断对象的可达性和对象是否存活&quot;&gt;判断对象的可达性和对象是否存活&lt;/h2&gt;
&lt;p&gt;判断对象的可达性和对象是否存活是两个比较困难的问题，笔者C语言学得比较烂，否则会重点翻看一下JVM的实现，目前只能参考一些资料来说明这个问题。&lt;/p&gt;
&lt;h3 id=&quot;可达性算法&quot;&gt;可达性算法&lt;/h3&gt;
&lt;p&gt;主流商用语言包括Java都是使用可达性分析(Reachability Analysis)算法来判定对象是否存活的。这个算法的基本思路是通过一系列的称为&quot;GC Roots&quot;(GC根集)的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链(Reference Chain)，当一个对象到GC根集没有任何引用链相连(从图论的角度看，也就是从GC根集到这个对象是不可达的)时，则证明此对象是不可用的。不可用的对象&quot;&lt;strong&gt;有机会&lt;/strong&gt;&quot;被判定为可以回收的对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1412331/202002/1412331-20200207000916651-1838662563.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Java语言中，可以作为GC根集的对象包括下面几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟机栈(栈帧中的本地变量表)中引用的对象。&lt;/li&gt;
&lt;li&gt;方法区中常量引用的对象(在JDK1.8之后不存在方法区，也就是有可能是metaspace中常量引用的对象)。&lt;/li&gt;
&lt;li&gt;本地方法栈中JNI(即一般常说的Native方法)引用的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;finalize函数&quot;&gt;finalize函数&lt;/h3&gt;
&lt;p&gt;即使在可达性分析算法中判定为不可达的对象，也并非一定会判定为可以被回收的&quot;死亡&quot;对象。一个对象判定为&quot;死亡&quot;至少需要经历&lt;strong&gt;两次标记&lt;/strong&gt;的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一次标记&lt;/strong&gt;：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那么它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行&lt;code&gt;finalize()&lt;/code&gt;方法。JVM会把以下两种情况认为对象没有必要执行&lt;code&gt;finalize()&lt;/code&gt;方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对象没有覆盖继承自Object类的&lt;code&gt;finalize()&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;对象的&lt;code&gt;finalize()&lt;/code&gt;方法已经被JVM调用过。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果一个对象被判定为有必要执行&lt;code&gt;finalize()&lt;/code&gt;方法，那么这个对象将会被放置在一个叫&lt;code&gt;F-Queue&lt;/code&gt;的队列之中，并且稍后由一个优先级低的Finalizer线程去取该队列的元素，&quot;尝试执行&quot;元素的&lt;code&gt;finalize()&lt;/code&gt;方法。这里之所以叫尝试执行是因为JVM会保证触发满足条件的对象的&lt;code&gt;finalize()&lt;/code&gt;方法，但是并不承诺会等待它执行结束，这是因为：如果一个对象在执行&lt;code&gt;finalize()&lt;/code&gt;方法耗时较长，甚至发生了死循环，将会导致&lt;code&gt;F-Queue&lt;/code&gt;的队列中的其他元素永远处于等待状态，&lt;strong&gt;极端情况下有可能导致整个内存回收系统崩溃&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;finalize()&lt;/code&gt;方法是对象逃脱死亡命运的最后一次机会，因为稍后的GC将会对&lt;code&gt;F-Queue&lt;/code&gt;队列中的对象进行&lt;strong&gt;第二次小规模的标记&lt;/strong&gt;，如果对象在&lt;code&gt;finalize()&lt;/code&gt;方法执行过程中成功拯救自己--也就是对象自身重新与引用链的任何一个对象建立关联即可，最常见的就是把自身(this关键字)赋值给某个类变量或者对象的成员属性，那么在第二次小规模的标记时候将会把&quot;自我拯救&quot;成功的对象移出&quot;即将回收&quot;的集合。如果对象在&lt;code&gt;finalize()&lt;/code&gt;方法执行过程中没有&quot;逃逸&quot;，那么它最终就会被回收。参考《深入理解Java虚拟机-2nd》的&quot;对象自我拯救的例子&quot;：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class FinalizeEscapeGc {

    private static FinalizeEscapeGc SAVE_HOOK = null;

    public void isAlive() {
        System.out.println(&quot;Yes,I am still alive :)&quot;);
    }

    public static void main(String[] args) throws Exception {
        SAVE_HOOK = new FinalizeEscapeGc();

        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println(&quot;No,I am not alive :(&quot;);
        }
                // 下面的这段代码和上面的一致
        SAVE_HOOK = null;
        System.gc();
        Thread.sleep(500);
        if (SAVE_HOOK != null) {
            SAVE_HOOK.isAlive();
        } else {
            System.out.println(&quot;No,I am not alive :(&quot;);
        }
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println(&quot;FinalizeEscapeGc finalize invoke...&quot;);
        FinalizeEscapeGc.SAVE_HOOK = this;
    }
}
// 输出结果
FinalizeEscapeGc finalize invoke...
Yes,I am still alive :)
No,I am not alive :(&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;finalize()&lt;/code&gt;方法的错误使用有可能是内存回收系统崩溃的根源，一般情况下谨慎思考是否真的需要覆盖此方法。&lt;/li&gt;
&lt;li&gt;任意一个对象只能通过&lt;code&gt;finalize()&lt;/code&gt;方法自我拯救一次。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;finalizer守护线程&quot;&gt;Finalizer守护线程&lt;/h3&gt;
&lt;p&gt;前面提到的&lt;code&gt;Finalizer&lt;/code&gt;守护线程和&lt;code&gt;F-Queue&lt;/code&gt;队列其实在JDK中有具体的实现类&lt;code&gt;java.lang.ref.Finalizer&lt;/code&gt;。&lt;code&gt;F-Queue&lt;/code&gt;队列只是《深入理解Java虚拟机-2nd》中的一个名词描述，实际上笔者没有找到相关的资料，这里我们通过分析JDK和JVM相关的源码去理解这个&lt;code&gt;F-Queue&lt;/code&gt;队列吧。先看&lt;code&gt;java.lang.ref.Finalizer&lt;/code&gt;的源码，代码比较少全量贴出：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;final class Finalizer extends FinalReference&amp;lt;Object&amp;gt; { /* Package-private; must be in
                                                          same package as the Reference
                                                          class */
    // Finalizer关联的ReferenceQueue，其实Finalizer是一个特殊的Reference实现
    private static ReferenceQueue&amp;lt;Object&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;();

    /** Head of doubly linked list of Finalizers awaiting finalization. */
    // 等待finalization的所有Finalizer实例链表的头节点，这里称此链表为unfinalized链表
    private static Finalizer unfinalized = null;

    /** Lock guarding access to unfinalized list. */
    // unfinalized链表的锁，静态final，全局的锁实例
    private static final Object lock = new Object();
    
    // 中间变量，分别记录unfinalized链表中当前执行元素的下一个节点和前一个节点
    private Finalizer next, prev;

    private Finalizer(Object finalizee) {
        super(finalizee, queue);
        // push onto unfinalized
        // 这里主要是更新unfinalized链表的头节点，新增的元素总是会变成头节点
        synchronized (lock) {
            if (unfinalized != null) {
                this.next = unfinalized;
                unfinalized.prev = this;
            }
            unfinalized = this;
        }
    }

    static ReferenceQueue&amp;lt;Object&amp;gt; getQueue() {
        return queue;
    }

    /* Invoked by VM */ 这个方法由JVM激活，也就是链表的元素入队是由JVM控制的，见下文分析
    static void register(Object finalizee) {
        new Finalizer(finalizee);
    }

    private void runFinalizer(JavaLangAccess jla) {
        synchronized (lock) {
            // 当前元素已经处理过，直接返回
            if (this.next == this)      // already finalized
                return;
            // unlink from unfinalized
            // 下面的逻辑是当前需要执行的元素从链表中移除，并且更新prev和next的值，相当于重建链表的部分节点
            if (unfinalized == this)
                unfinalized = this.next;
            else
                this.prev.next = this.next;
            if (this.next != null)
                this.next.prev = this.prev;
            this.prev = null;
            this.next = this;           // mark as finalized
        }

        try {
            // 获取对象执行一次finalize方法
            Object finalizee = this.get();
            if (finalizee != null &amp;amp;&amp;amp; !(finalizee instanceof java.lang.Enum)) {
                jla.invokeFinalize(finalizee);

                // Clear stack slot containing this variable, to decrease
                // the chances of false retention with a conservative GC
                // 清空变量引用从而减少保守GC导致变量保留的可能性
                finalizee = null;
            }
        } catch (Throwable x) { }
        // 执行完毕会做一次情况防止重复执行
        super.clear();
    }

    /* Create a privileged secondary finalizer thread in the system thread
     * group for the given Runnable, and wait for it to complete.
     *
     * This method is used by runFinalization.
     *
     * It could have been implemented by offloading the work to the
     * regular finalizer thread and waiting for that thread to finish.
     * The advantage of creating a fresh thread, however, is that it insulates
     * invokers of that method from a stalled or deadlocked finalizer thread.
     */
    // 这里其实不用畏惧注释太多，它只是一个候选方法，新建一个线程直接调用包裹在Runnable的runFinalization方法，主要是提供给主动调用的上层方法调用的
    private static void forkSecondaryFinalizer(final Runnable proc) {
        AccessController.doPrivileged(
            new PrivilegedAction&amp;lt;&amp;gt;() {
                public Void run() {
                    ThreadGroup tg = Thread.currentThread().getThreadGroup();
                    for (ThreadGroup tgn = tg;
                         tgn != null;
                         tg = tgn, tgn = tg.getParent());
                    Thread sft = new Thread(tg, proc, &quot;Secondary finalizer&quot;, 0, false);
                    sft.start();
                    try {
                        sft.join();
                    } catch (InterruptedException x) {
                        Thread.currentThread().interrupt();
                    }
                    return null;
                }});
    }

    /* Called by Runtime.runFinalization() */
    // 这个方法是给Runtime.runFinalization()委托调用的，其实就是主动取出queue的元素强制调用其finalize方法
    static void runFinalization() {
        if (VM.initLevel() == 0) {
            return;
        }
        forkSecondaryFinalizer(new Runnable() {
            private volatile boolean running;
            public void run() {
                // in case of recursive call to run()
                if (running)
                    return;
                final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
                running = true;
                for (Finalizer f; (f = (Finalizer)queue.poll()) != null;)
                    f.runFinalizer(jla);
            }
        });
    }
    
    // 真正的Finalizer线程
    private static class FinalizerThread extends Thread {
        private volatile boolean running;
        FinalizerThread(ThreadGroup g) {
            super(g, null, &quot;Finalizer&quot;, 0, false);
        }
        public void run() {
            // in case of recursive call to run()
            if (running)
                return;

            // Finalizer thread starts before System.initializeSystemClass
            // is called.  Wait until JavaLangAccess is available
            while (VM.initLevel() == 0) {
                // delay until VM completes initialization
                try {
                    VM.awaitInitLevel(1);
                } catch (InterruptedException x) {
                    // ignore and continue
                }
            }
            final JavaLangAccess jla = SharedSecrets.getJavaLangAccess();
            running = true;
            // 注意这里是死循环
            for (;;) {
                try {
                    // 注意这里是调用`Reference#remove()`的永久阻塞版本，只有`Reference#enqueue()`被调用才会解除阻塞
                    // `Reference#remove()`解除阻塞说明元素已经完成入队，由ReferenceHandler线程完成
                    Finalizer f = (Finalizer)queue.remove();
                    // 实际上就是调用对象的finalize方法
                    f.runFinalizer(jla);
                } catch (InterruptedException x) {
                    // ignore and continue
                }
            }
        }
    }

    static {
        ThreadGroup tg = Thread.currentThread().getThreadGroup();
        for (ThreadGroup tgn = tg;
             tgn != null;
             tg = tgn, tgn = tg.getParent());
        // 静态代码块中声明线程，优先级是最高优先级-2，守护线程，实际上这里优先级不一定会生效
        Thread finalizer = new FinalizerThread(tg);
        finalizer.setPriority(Thread.MAX_PRIORITY - 2);
        finalizer.setDaemon(true);
        finalizer.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的注释已经很明显标注出来，这里小结一下内容。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Finalizer&lt;/code&gt;是&lt;code&gt;FinalReference&lt;/code&gt;的子类，而&lt;code&gt;FinalReference&lt;/code&gt;是&lt;code&gt;Reference&lt;/code&gt;的实现，所以它的工作原理和其他引用类似，对象的状态更变和由ReferenceHandler线程密切相关。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Finalizer&lt;/code&gt;内部维护了一个链表，每当JVM调用静态注册方法就会新建一个&lt;code&gt;Finalizer&lt;/code&gt;实例加入到链表的头节点中，头节点元素为unfinalized，这里称此链表为unfinalized链表。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Finalizer&lt;/code&gt;线程由&lt;code&gt;Finalizer&lt;/code&gt;静态代码块构建并且运行，它是守护线程，优先级是最高优先级-2，它的作用就是提取unfinalized链表的元素并且执行元素对象的&lt;code&gt;finalize()&lt;/code&gt;方法，过程中还会涉及到线程的阻塞、唤醒，以及unfinalized链表的重建等工作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于静态方法&lt;code&gt;Finalizer#register(Object finalizee)&lt;/code&gt;是由JVM调用的，所以我们必须要分析一些JVM的源码，参考的是OpenJDK主分支的代码，文件是&lt;code&gt;instanceKlass.cpp&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;instanceOop InstanceKlass::register_finalizer(instanceOop i, TRAPS) {
  if (TraceFinalizerRegistration) {
    tty-&amp;gt;print(&quot;Registered &quot;);
    i-&amp;gt;print_value_on(tty);
    tty-&amp;gt;print_cr(&quot; (&quot; INTPTR_FORMAT &quot;) as finalizable&quot;, p2i(i));
  }
  instanceHandle h_i(THREAD, i);
  // Pass the handle as argument, JavaCalls::call expects oop as jobjects
  JavaValue result(T_VOID);
  JavaCallArguments args(h_i);
  // 这里Universe::finalizer_register_method()获取到的就是Finalizer#register方法句柄
  methodHandle mh (THREAD, Universe::finalizer_register_method());
  JavaCalls::call(&amp;amp;result, mh, &amp;amp;args, CHECK_NULL);
  return h_i();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后调用的是&lt;code&gt;javaCalls.cpp&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void JavaCalls::call(JavaValue* result, const methodHandle&amp;amp; method, JavaCallArguments* args, TRAPS) {
  // Check if we need to wrap a potential OS exception handler around thread
  // This is used for e.g. Win32 structured exception handlers
  assert(THREAD-&amp;gt;is_Java_thread(), &quot;only JavaThreads can make JavaCalls&quot;);
  // Need to wrap each and every time, since there might be native code down the
  // stack that has installed its own exception handlers
  os::os_exception_wrapper(call_helper, result, method, args, THREAD);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单来看就是把创建对象过程中，如果有必要注册&lt;code&gt;Finalizer&lt;/code&gt;(一般是覆盖了&lt;code&gt;finalize()&lt;/code&gt;方法)，则基于当前线程通过&lt;code&gt;Finalizer#register(Object finalizee)&lt;/code&gt;把当前新建的实例注册到&lt;code&gt;Finalizer&lt;/code&gt;自身维护的链表中(如果没理解错，所谓的&lt;code&gt;F-Queue&lt;/code&gt;就是这个链表了)，等待后台&lt;code&gt;Finalizer&lt;/code&gt;线程轮询并且执行链表中对象的&lt;code&gt;finalize()&lt;/code&gt;方法。&lt;/p&gt;
&lt;h2 id=&quot;各类引用以及它们的使用场景&quot;&gt;各类引用以及它们的使用场景&lt;/h2&gt;
&lt;p&gt;这里提到的各类引用目前就是四种：强引用(StrongReference)、软引用(SoftReference)、弱引用(WeakReference)和虚引用(PhantomReference)。其实还有特殊的引用类型&lt;code&gt;FinalReference&lt;/code&gt;，它是包私有的，并且只有一个子类型&lt;code&gt;Finalizer&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;strongreference&quot;&gt;StrongReference&lt;/h3&gt;
&lt;p&gt;StrongReference也就是强引用，它是使用最普遍的一种引用，&lt;code&gt;java.lang.ref&lt;/code&gt;包下没有强引用对应的类型。一个比较明确的强引用定义就是：所有和GC Root之间存在引用链的对象都具备强引用。举个简单例子：形如&lt;code&gt;Object o = new Object();&lt;/code&gt;在方法体中使用new关键字声明的对象一般就是强引用。如果一个对象具备强引用，垃圾回收器绝不会回收它。当内存空间不足，JVM宁愿抛出&lt;code&gt;OutOfMemoryError&lt;/code&gt;错误，使程序异常终止，也不会出现回收具有强引用的对象来解决内存不足的情况。当然，如果有共享的成员变量在方法退出之前置为null，相当于断绝成员变量和GC Root的引用链，在合适的时机是有利于GC后具备强引用的对象的回收，例如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private Object shareValue = XXX;

public void methodA(){
    //do something
    shareValue = null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后来有人过度信奉类似上面的这个实践，出现了一条比较诡异的编码实践：强引用使用完毕后都要置为null方便对象回收。但是实际上，这个实践并不是在任何场景都是合理的。&lt;/p&gt;
&lt;h3 id=&quot;softreference&quot;&gt;SoftReference&lt;/h3&gt;
&lt;p&gt;SoftReference也就是软引用，它是用来描述一些&quot;还有用但是非必须&quot;的对象。对于软引用关联着的对象，在JVM应用即将发生内存溢出异常之前，将会把这些软引用关联的对象列进去回收对象范围之中进行第二次回收。如果这次回收之后还是没有足够的内存，才会抛出内存溢出异常。简单来说就是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果内存空间足够，垃圾回收器就不会回收软引用关联着的对象。&lt;/li&gt;
&lt;li&gt;如果内存空间不足，垃圾回收器在将要抛出内存溢出异常之前会回收软引用关联着的对象。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举个简单的使用例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// VM参数：-Xmx4m -Xms4m
public class SoftReferenceMain {

    public static void main(String[] args) throws Exception {
        ReferenceQueue&amp;lt;SoftReferenceObject&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;();
        SoftReferenceObject object = new SoftReferenceObject();
        SoftReference&amp;lt;SoftReferenceObject&amp;gt; reference = new SoftReference&amp;lt;&amp;gt;(object, queue);
        object = null;
        System.gc();
        Thread.sleep(500);
        System.out.println(reference.get());
    }

    private static class SoftReferenceObject {

        int[] array = new int[120_000];

        @Override
        public String toString() {
            return &quot;SoftReferenceObject&quot;;
        }
    }
}
// 运行后输出结果
null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子故意把JVM的启动的最大Heap内存和初始Heap内存设置为4MB，使用这个对象初始化一个比较大的整型数组并且关系到一个软引用对象中，GC之后，发现软引用关联的对象被回收了。&lt;/p&gt;
&lt;h3 id=&quot;weakreference&quot;&gt;WeakReference&lt;/h3&gt;
&lt;p&gt;WeakReference也就是弱引用，弱引用和软引用类似，它是用来描述&quot;非必须&quot;的对象的，它的强度比软引用要更弱一些。被弱引用关联的对象只能生存到下一次垃圾收集发生之前，简言之就是：一旦发生GC必定回收被弱引用关联的对象，不管当前的内存是否足够。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class WeakReferenceMain {

    public static void main(String[] args) throws Exception {
        ReferenceQueue&amp;lt;WeakReferenceObject&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;();
        WeakReferenceObject object = new WeakReferenceObject();
        System.out.println(object);
        WeakReference&amp;lt;WeakReferenceObject&amp;gt; reference = new WeakReference&amp;lt;&amp;gt;(object, queue);
        object = null;
        System.gc();
        Thread.sleep(500);
        System.out.println(reference.get());
    }

    private static class WeakReferenceObject {

        @Override
        public String toString() {
            return &quot;WeakReferenceObject&quot;;
        }
    }
}
// 运行后输出结果
WeakReferenceObject
null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中没有设定JVM的堆内存，因此不存在内存不足的情况，可见弱引用关联的对象在GC之后被回收了。弱引用适合用来做对内存敏感的缓存，很常用的&lt;code&gt;WeakHashMap&lt;/code&gt;就是基于弱引用实现的。&lt;/p&gt;
&lt;h3 id=&quot;phantomreference&quot;&gt;PhantomReference&lt;/h3&gt;
&lt;p&gt;PhantomReference也就是虚引用，也叫幽灵引用或者幻影引用，它是所有引用类型中最弱的一种。一个对象是否关联到虚引用，完全不会影响该对象的生命周期，也无法通过虚引用来获取一个对象的实例(&lt;code&gt;PhantomReference&lt;/code&gt;覆盖了&lt;code&gt;Reference#get()&lt;/code&gt;并且总是返回null)。为对象设置一个虚引用的唯一目的是：能在此对象被垃圾收集器回收的时候收到一个&lt;strong&gt;系统通知&lt;/strong&gt;。&lt;code&gt;PhantomReference&lt;/code&gt;有两个比较常用的子类是&lt;code&gt;java.lang.ref.Cleaner&lt;/code&gt;和&lt;code&gt;jdk.internal.ref.Cleaner&lt;/code&gt;，其中前者提供的功能是开发者用于在引用对象回收的时候触发一个动作(&lt;code&gt;java.lang.ref.Cleaner$Cleanable&lt;/code&gt;)，后者用于&lt;code&gt;DirectByteBuffer&lt;/code&gt;对象回收的时候对于堆外内存的回收，可以翻看前面描述&lt;code&gt;java.lang.ref.Reference#processPendingReferences()&lt;/code&gt;源码的时候，ReferenceHandler线程会对pending链表中的&lt;code&gt;jdk.internal.ref.Cleaner&lt;/code&gt;类型引用对象调用其&lt;code&gt;clean()&lt;/code&gt;方法。&lt;code&gt;PhantomReference&lt;/code&gt;本身使用场景比较少，这里举一下&lt;code&gt;java.lang.ref.Cleaner&lt;/code&gt;注释中的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class PhantomReferenceMain {

    public static void main(String[] args) throws Exception {
        try (CleaningExample o = new CleaningExample(11)){

        }
        CleaningExample o2 = new CleaningExample(22);
        System.gc();
        Thread.sleep(300);
    }

}

class CleaningExample implements AutoCloseable {

    private Cleaner cleaner = Cleaner.create();
    private final State state;
    private final Cleaner.Cleanable cleanable;

    public CleaningExample(int s) {
        state = new State(s);
        cleanable = cleaner.register(this, state);
    }

    class State implements Runnable {

        private final int s;

        public State(int s) {
            this.s = s;
        }

        @Override
        public void run() {
            System.out.println(&quot;State runnable in action.State value = &quot; + s);
        }
    }

    @Override
    public void close() throws Exception {
        cleanable.clean();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上，沙面的代码执行完毕只会输出&quot;State runnable in action.State value = 11&quot;，并没有输出&quot;State runnable in action.State value = 22&quot;，这是因为无法预测强引用对象被回收的时机。&lt;code&gt;java.lang.ref.Cleaner&lt;/code&gt;主要是用于预防实现了&lt;code&gt;AutoCloseable&lt;/code&gt;接口的实例忘记调用&lt;code&gt;close()&lt;/code&gt;方法在对象被垃圾收集器回收的时候(内存回收)做一个兜底的清理工作，在JDK9之后，&lt;code&gt;java.lang.ref.Cleaner&lt;/code&gt;主要是为了替代已经标识为过期的&lt;code&gt;Object#finalize()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;扩展阅读：可以注意阅读一下《Effective Java 3rd》的第8小节，摘抄部分内容如下：终结方法（Finalizer）是不可预知的，很多时候是危险的，而且一般情况下是不必要的。...在Java 9中，终结方法已经被遗弃了，但它们仍被Java类库使用，相应用来替代终结方法的是清理方法（cleaner）。比起终结方法，清理方法相对安全点，但仍是不可以预知的，运行慢的，而且一般情况下是不必要的。&lt;/p&gt;
&lt;p&gt;JDK9中有很多原来使用覆盖&lt;code&gt;Object#finalize()&lt;/code&gt;方法的清理工作实现都替换为&lt;code&gt;java.lang.ref.Cleaner&lt;/code&gt;，但是仍然不鼓励使用这种方式。&lt;/p&gt;
&lt;h2 id=&quot;reference和referencequeue配合使用&quot;&gt;Reference和ReferenceQueue配合使用&lt;/h2&gt;
&lt;p&gt;前面基本介绍完了所有类型引用以及相关的源码，但是尚未提供例子说明&lt;code&gt;Reference&lt;/code&gt;和&lt;code&gt;ReferenceQueue&lt;/code&gt;是怎么配合使用的。举个例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ReferenceQueueMain {

    public static void main(String[] args) throws Exception {
        ReferenceQueue&amp;lt;WeakReferenceObject&amp;gt; queue = new ReferenceQueue&amp;lt;&amp;gt;();
        WeakReferenceObject object = new WeakReferenceObject();
        WeakReference&amp;lt;WeakReferenceObject&amp;gt; weakReference = new WeakReference&amp;lt;&amp;gt;(object, queue);
        System.out.println(weakReference);
        object = null;
        System.gc();
        Thread.sleep(500);
        while (true) {
            Reference&amp;lt;? extends WeakReferenceObject&amp;gt; reference = queue.poll();
            if (null == reference) {
                Thread.sleep(100);
            } else {
                System.out.println(reference);
                System.out.println(reference.get());
                break;
            }
        }
    }

    private static class WeakReferenceObject {

        @Override
        public String toString() {
            return &quot;WeakReferenceObject&quot;;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后输出结果是：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;java.lang.ref.WeakReference@6537cf78
java.lang.ref.WeakReference@6537cf78
null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见轮询&lt;code&gt;ReferenceQueue&lt;/code&gt;实例得到的弱引用实例和创建的是一致的，只是它持有的关联的对象已经被回收，得到null。上面的&lt;code&gt;ReferenceQueue#poll()&lt;/code&gt;方法也可以替换为&lt;code&gt;ReferenceQueue#remove()&lt;/code&gt;，这样子就不用写在死循环中，因为&lt;code&gt;ReferenceQueue#remove()&lt;/code&gt;会阻塞到有元素可以出队。通过轮询绑定到&lt;code&gt;Reference&lt;/code&gt;实例的&lt;code&gt;ReferenceQueue&lt;/code&gt;实例，就可以得知&lt;code&gt;Reference&lt;/code&gt;实例当前的状态并且判断它关联的我们真正关注的对象是否被回收。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Reference&lt;/code&gt;是&lt;strong&gt;非强引用&lt;/strong&gt;的其他三种引用的共同父类。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ReferenceQueue&lt;/code&gt;只存储了引用链表的头节点，提供了引用链表的操作，实际上，引用链表是&lt;code&gt;Reference&lt;/code&gt;实例内部变量存储的。&lt;/li&gt;
&lt;li&gt;ReferenceHandler守护线程线程由&lt;code&gt;Reference&lt;/code&gt;的静态代码块创建和运行，作用是处理pending链表的引用元素使之状态变更，伴随着&lt;code&gt;ReferenceQueue&lt;/code&gt;的相关操作。&lt;/li&gt;
&lt;li&gt;Finalizer守护线程是由&lt;code&gt;Finalizer&lt;/code&gt;类的静态代码块创建和运行的，作用是处理&lt;code&gt;Finalizer&lt;/code&gt;类内部维护的F-Queue链表(链表元素入队操作由JVM实现)的元素调用关联对象的&lt;code&gt;finalize()&lt;/code&gt;方法。&lt;/li&gt;
&lt;li&gt;ReferenceHandler守护线程线和Finalizer守护线程共同协作才能使引用类型对象内存回收系统的工作能够正常进行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;四种引用类型的总结&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;强引用&lt;/td&gt;
&lt;td&gt;直到内存溢出也不会回收&lt;/td&gt;
&lt;td&gt;普遍对象的状态&lt;/td&gt;
&lt;td&gt;从创建到JVM实例终止运行&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;软引用&lt;/td&gt;
&lt;td&gt;垃圾回收并且内存不足时&lt;/td&gt;
&lt;td&gt;有用但非必须的对象缓存&lt;/td&gt;
&lt;td&gt;从创建到垃圾回收并且内存不足时&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;弱引用&lt;/td&gt;
&lt;td&gt;垃圾回收时&lt;/td&gt;
&lt;td&gt;非必须的对象缓存&lt;/td&gt;
&lt;td&gt;上一次垃圾回收结束到下一次垃圾回收开始&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;虚引用&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;关联的对象被垃圾收集器回收时候得到一个系统通知&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JDK11部分源码。&lt;/li&gt;
&lt;li&gt;《深入理解Java虚拟机-2nd》- 这本书算是国内书籍写得比较良心的一本了，不过有很多小的问题或者笔误之处，需要自行发现和修正。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;个人博客&quot;&gt;个人博客&lt;/h2&gt;
&lt;p&gt;(过年比较懒，很久没发文 e-a-20190215 c-14-d)&lt;/p&gt;
</description>
<pubDate>Thu, 06 Feb 2020 16:10:00 +0000</pubDate>
<dc:creator>throwable</dc:creator>
<og:description>前提 这篇文章主要基于JDK11的源码和最近翻看的《深入理解Java虚拟机 2nd》一书的部分内容，对JDK11中的 (引用)做一些总结。值得注意的是，通过笔者对比一下JDK11和JDK8对于 包的相</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/throwable/p/12271653.html</dc:identifier>
</item>
<item>
<title>混沌工程-初识 - 老_张</title>
<link>http://www.cnblogs.com/imyalost/p/12271620.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imyalost/p/12271620.html</guid>
<description>&lt;p&gt;&lt;span&gt;公司新成立了一个稳定性团队，20年的重要目标之一就是开展混沌工程。为了后续更好的开展工作，记录关于“混沌工程”相关的知识以及工程实践。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;内容来源：《混沌工程：Netflix系统稳定性之道》摘录以及个人思考总结。。。。。。&lt;/p&gt;
&lt;p id=&quot;Qw9WS&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;概要&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;定义&lt;/strong&gt;：主动发现系统中脆弱点的一整套方法论。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;目的&lt;/strong&gt;：如何让系统在不确定性中获益？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;接受“系统越复杂，越脆弱”的事实，让系统在每一次失败中获益，然后不断进化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实践中，用一系列的实验来真实的验证系统在各类故障场景下的表现，通过频繁大量的实验，使得系统本身的“反脆弱性”持续增强，让组织建立对系统抵御生产环境中失控条件的能力以及信心。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;初衷&lt;/strong&gt;：通过实验性的方法，让人们建立复杂分布式系统能够在生产中抵御事件能力的信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;出现&lt;/strong&gt;：最早由Netflix的技术团队提出，现已经演变成计算机科学的一门新兴学科，即“混沌工程”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;现状&lt;/strong&gt;：目前业内的认知和实践积累较少，但它实际上是一种提高技术架构弹性能力的复杂技术手段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;挑战&lt;/strong&gt;：服务规模不断增长，服务间依赖带来的不确定性指数级增长。软件可用性面临两大挑战：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  1）自身复杂度激增；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  2）开发者引入复杂性的同时对风险的低估和忽视；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;方法&lt;/strong&gt;：通过一系列可控实验和执行实验原则，揭示出系统中随时发生的各类事件是如何逐步导致系统整体不可用的。&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;书籍&lt;/strong&gt;：《混沌工程：Netflix系统稳定性之道》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/983980/202002/983980-20200206235337518-1502330941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;工具&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Chaos Dingo：支持在Azure相关服务上进行实验。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Chaos-http-proxy：向http注入故障的代理服务工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Tugbot：可在基于docker的生产环境中进行测试的框架。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Chaos Lambda：办公期间可随机关闭AWS ASG节点的工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Blockade：基于docker，可测试网络故障和网络分区的工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Pumba：基于docker的混沌工程测试工具以及网络模拟工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Simoorg：LinkedIn开发的故障注入工具，以扩展，很多关键组件可插拔。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Chaos Lemur：测试高可用性系统弹性的工具，可本地部署，允许随机关闭BOSH虚拟机。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Monkey-Ops：Go语言实现，可在OpenShift V3.X上部署并在其中生成混沌工程实验。可随机停止OpenShift组件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/chaosblade-io/chaosblade/blob/master/README_CN.md&quot; target=&quot;_blank&quot;&gt;ChaosBlade&lt;/a&gt;：阿里开源的一款遵循混沌工程原理和混沌实验模型的实验注入工具，是内部MonkeyKing对外开源的项目，结合了阿里各业务的最佳创意和实践。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;4DIYl&quot;&gt;&lt;span&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由很多微服务组成的分布式系统中，永远难以全面掌握什么事件会导致系统局部不可用，甚至全面崩溃。主要因素：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）系统架构演进：服务集群→分布式→微服务→容器化（K8S&amp;amp;docker）→上云；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）版本迭代增速：CICD、敏捷、devops、ABtest；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）用户需求变更：复杂化、多样化、快速化、小众化；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;对系统的要求：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;扩展性、稳定性、弹性能力、容错灾备能力；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;软件系统现状：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;系统复杂性提高、问题定位成本高；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;要解决的问题：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;生产环境下的分布式系统在面对失控条件时依然具备较强的“可观测性”和故障恢复能力；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;主要验证方式：&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;故障注入；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-11&quot;&gt;&lt;strong&gt;开展“混沌工程”的意义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-11&quot;&gt;开发者的能力和认知水平有边界，不可能所有的细节都可以预估到，系统很脆弱，各种潜在不可预期的突发事件在所难免。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-11&quot;&gt;我们需要在异常触发之前，尽可能地去筛选出会导致出现有异常问题的、容易造成故障的、系统中明显裂痕的环节，这也是混沌工程所肩负的意义。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-11&quot;&gt;能让复杂系统中根深蒂固的混乱和不稳定性浮出水面，让我们更全面了解系统中固有的现象，然后进行及时修复、加固和防患于未然，才能打造更具弹性的软件工程系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;lake-fontsize-11&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p id=&quot;SJAuT&quot;&gt;&lt;strong&gt;&lt;span&gt;思考&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1、设计良好的系统，需要考虑哪些因素？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可靠性、安全性、可扩展性、可定制化、可伸缩性、可维护性、用户体验等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2、混沌工程解决什么问题？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;生产环境下，分布式系统在面对失控条件时是否具备较强的“可观测性”和故障恢复能力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3、开展混沌工程要考虑的维度有哪些？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）建立稳定状态的假设（清晰可衡量的指标）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）用多样的生产事件做验证（多样性降低误差）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）在生产环境做验证（真实场景）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4）自动化开展实验（持续运行）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5）控制最小化爆炸半径（影响范围）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4、Netflix开展混沌工程总结的三点经验&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1）建立面向失败设计和拥抱失败的技术文化（技术文化）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  思想上，引入混沌工程的核心是通过引入一些风险去暴露已有的不易发现的问题，而不是创造问题。这样有助于问题的发现和处理，降低潜在故障带来的影响。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2）定义一个清晰可度量的目标（定义目标）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  前期：对历史故障的复现率以及解决率，确保故障改进的有效性；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  中期：监控发现率，验证故障发现能力的全面性和监控的完备程度；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  后期：故障的“发现-定位-恢复”市场这种综合性指标；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3）在控制风险的前提下不断提升混沌工程效率（技术推广）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  先从简单的场景开始尝试，逐渐增加组织对系统的信心（要明白准备工作比落地执行更重要）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;混沌工程是一种实践思想，方法论，本身不绑定任何工具或者技术。不过在进行推广和实施时，考虑到真实性、容错性、开发成本、运维效率等因素，建议复用成熟的开源组件或者商业化工具。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Feb 2020 15:57:00 +0000</pubDate>
<dc:creator>老_张</dc:creator>
<og:description>公司新成立了一个稳定性团队，20年的重要目标之一就是开展混沌工程。为了后续更好的开展工作，记录关于“混沌工程”相关的知识以及工程实践。 内容来源：《混沌工程：Netflix系统稳定性之道》摘录以及个人</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/imyalost/p/12271620.html</dc:identifier>
</item>
<item>
<title>.net core 认证与授权（二）  - 族语1996</title>
<link>http://www.cnblogs.com/aoximin/p/12271471.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aoximin/p/12271471.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;这篇紧接着一来写的，在第一篇中介绍了认证与授权，同时提出了这套机制其实就是模拟现实中的认证与授权。&lt;br/&gt;同样这篇介绍在这套机制下，用户信息管理机制？这里就会问了，上一篇中认证和授权不是都ok了吗，怎么会有一个管理机制呢？当然并不一定要使用下面这套机制，但是给了我们很大的启发。&lt;br/&gt;在上一结中我们颁发证书是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public IActionResult Authenticate()
{
    var SchoolClaims = new List&amp;lt;Claim&amp;gt;()
    {
        new Claim(ClaimTypes.Name,&quot;Jack&quot;),
        new Claim(ClaimTypes.Email,&quot;Jack@fmail.com&quot;)
    };

    var LicensClaims = new List&amp;lt;Claim&amp;gt;()
    {
        new Claim(ClaimTypes.Name,&quot;Jack.li&quot;),
        new Claim(ClaimTypes.Email,&quot;Jack@fmail.com&quot;),
        new Claim(&quot;begin&quot;,&quot;2000.10.1&quot;)
    };
    var SchoolIdentity = new ClaimsIdentity(SchoolClaims,&quot;Student Identity&quot;);
    var CarManagerIdentity = new ClaimsIdentity(LicensClaims, &quot;Licens Identity&quot;);
    var userPrincipal = new ClaimsPrincipal(new[] { SchoolIdentity, CarManagerIdentity });
    
    HttpContext.SignInAsync(userPrincipal);
    return RedirectToAction(&quot;Index&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有没有发现new Claim(ClaimTypes.Name,&quot;Jack&quot;) 写死了？我的信息是要从数据库里面查啊。&lt;br/&gt;这时候微软的框架就跳出来了，说用我的这套机制，帮你搞定，到底是什么机制呢？请看正文。小声逼逼一句，微软就喜欢搞全包工程。&lt;br/&gt;正文均为个人理解，如有不对请指出。&lt;/p&gt;
&lt;h3 id=&quot;正文&quot;&gt;正文&lt;/h3&gt;
&lt;p&gt;首先提及到一个结构，IdentityUser，这东西是真的博大精深，但是感觉有点臃肿，这很微软。&lt;br/&gt;IdentityUser 这里可以简单说明一下，就是存储用户信息的地方。&lt;br/&gt;既然说到用户存储，那么就要提及到数据库了。&lt;br/&gt;创建了一个AppDbContext:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class AppDbContext:IdentityDbContext
{
    public AppDbContext(DbContextOptions&amp;lt;AppDbContext&amp;gt; options):base(options)
    {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以前我们一般是继承DbContext，DbContext是Ef的上下文。&lt;br/&gt;这里IdentityDbContext，是Ef的扩展，看下我添加了什么。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202002/1289794-20200206223249606-454705011.png&quot;/&gt;&lt;br/&gt;红色框内是我添加的。&lt;br/&gt;在这里我为了演示使用内存数据库memory，所以我多加了一个库。&lt;br/&gt;然后我在startup中配置使用memory数据库。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; services.AddDbContext&amp;lt;AppDbContext&amp;gt;(config =&amp;gt;{
                config.UseInMemoryDatabase(&quot;Memery&quot;);
            });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就配置了，现在就解决了数据库的问题。&lt;br/&gt;同样需要配置identity:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.AddIdentity&amp;lt;IdentityUser, IdentityRole&amp;gt;(config=&amp;gt; {
                config.Password.RequiredLength = 4;
                config.Password.RequireDigit = false;
                config.Password.RequireNonAlphanumeric = false;
                config.Password.RequireLowercase = false;
                config.Password.RequireUppercase = false;
            }).AddEntityFrameworkStores&amp;lt;AppDbContext&amp;gt;().AddDefaultTokenProviders();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有几个关键的地方，就是config.Password.RequiredLength = 4;等几个password的配置，&lt;br/&gt;因为identetyUser 有默认的机制就是密码必须要大写，然后不小于6位密码等，我们在这里全部去掉。&lt;br/&gt;AddEntityFrameworkStores() 添加EF 存储实现。&lt;br/&gt;AddDefaultTokenProviders() 默认提供生成token。这种token 用来干啥呢？当然是用来证明用户的了。比如我们修改密码的时候，我们发现链接上有一个token，异曲同工之妙哈。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;services.ConfigureApplicationCookie(config =&amp;gt;
{
    config.Cookie.Name = &quot;Identity.Cooke&quot;;
    config.LoginPath = &quot;/Home/Login&quot;;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上验证，当没有登陆的时候去到登陆页面。&lt;br/&gt;好的配置我们基本完成了。&lt;br/&gt;接下来就是去实现登陆与注册。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public IActionResult Index()
{
    return View();
}
public IActionResult Secret()
{
    return View();
}

public IActionResult Login()
{
    return View();
}

public IActionResult Register()
{
    return View();
}
[HttpPost]
public async Task&amp;lt;IActionResult&amp;gt; Login(string username, string password)
{
    var user = await _userManager.FindByNameAsync(username);
    if (user != null)
    {
        //sign in
       var Signresult= await  _signInManager.PasswordSignInAsync(user,password,false,false);
        if (Signresult.Succeeded)
        {
            return RedirectToAction(&quot;Secret&quot;);
        }
    }
    return RedirectToAction(&quot;Index&quot;);
}
[HttpPost]
public async Task&amp;lt;IActionResult&amp;gt;  Register(string username,string password)
{

    var user = new IdentityUser
    {
        UserName = username,
        Email = &quot;&quot;
    };

    var result=await _userManager.CreateAsync(user,password);
    if (result.Succeeded)
    {
        var Signresult = await _signInManager.PasswordSignInAsync(user, password, false, false);
        if (Signresult.Succeeded)
        {
            return RedirectToAction(&quot;Index&quot;);
        }
    }
    return RedirectToAction(&quot;Index&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到两个http post：&lt;br/&gt;先看Register:&lt;br/&gt;创建了IdentityUser，用来存储用户信息。&lt;br/&gt;_userManager 是用来管理user用户的，比如说创建，删除，修改，是identetyUser 内部机制。&lt;br/&gt;创建过程如下:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public HomeController(UserManager&amp;lt;IdentityUser&amp;gt; userManager,SignInManager&amp;lt;IdentityUser&amp;gt; signInManager)
{
    _userManager = userManager;
    _signInManager = signInManager;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;var result=await _userManager.CreateAsync(user,password); 如果创建用户成功，那么就进行登陆如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var Signresult = await _signInManager.PasswordSignInAsync(user, password, false, false);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意PasswordSignInAsync登陆的话会产生token，用于验证我们是否登陆。&lt;br/&gt;当我注册后，产生了token，如下:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1289794/202002/1289794-20200206225120905-832057086.png&quot;/&gt;&lt;br/&gt;看下登陆，其实我们在注册部分就已经介绍了登陆了。&lt;br/&gt;我重新把代码放下了:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var user = await _userManager.FindByNameAsync(username);
if (user != null)
{
    //sign in
   var Signresult= await  _signInManager.PasswordSignInAsync(user,password,false,false);
    if (Signresult.Succeeded)
    {
        return RedirectToAction(&quot;Secret&quot;);
    }
}
return RedirectToAction(&quot;Index&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;发现就多了一步，根据名字去查找user，如果有这个user，然后去比较密码。和平时写code 差不多。&lt;br/&gt;然后登陆后就可以进入了我们想进入的页面。&lt;br/&gt;如果我们想loginout:&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public async Task&amp;lt;IActionResult&amp;gt; Logout()
{
    await _signInManager.SignOutAsync();
    return RedirectToAction(&quot;Index&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把登陆和注册的页面贴下：&lt;br/&gt;login:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;form action=&quot;/Home/Login&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; /&amp;gt;
    &amp;lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot; /&amp;gt;
    &amp;lt;button type=&quot;submit&quot;&amp;gt;登陆&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注册:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;form action=&quot;/Home/Register&quot; method=&quot;post&quot;&amp;gt;
    &amp;lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; /&amp;gt;
    &amp;lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot; /&amp;gt;
    &amp;lt;button type=&quot;submit&quot;&amp;gt;注册&amp;lt;/button&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上一篇中，就很疑问了，上一篇没有登录啊。&lt;br/&gt;真的没有登录吗?只是用证书去登录了，不然怎么能过的了检查呢。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HttpContext.SignInAsync(&quot;CookieAuth&quot;, userPrincipal);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;现在我们的流程更加的明显了，先要验证用户信息，比如说是否登录了，这个过程相当于什么呢？我们用我们的名字和指纹(password)，去获取到了我们的身份证。有了这张身份证后我们才有其他的证书，然后才有根据证书去获取一些权限。&lt;br/&gt;后续介绍基本的配置，与原理。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Feb 2020 15:43:00 +0000</pubDate>
<dc:creator>族语1996</dc:creator>
<og:description>前言 这篇紧接着一来写的，在第一篇中介绍了认证与授权，同时提出了这套机制其实就是模拟现实中的认证与授权。 同样这篇介绍在这套机制下，用户信息管理机制？这里就会问了，上一篇中认证和授权不是都ok了吗，怎</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aoximin/p/12271471.html</dc:identifier>
</item>
<item>
<title>Docker深入浅出系列 | 单节点多容器网络通信 - EvanLeung</title>
<link>http://www.cnblogs.com/evan-liang/p/12271468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/evan-liang/p/12271468.html</guid>
<description>&lt;blockquote readability=&quot;10.029411764706&quot;&gt;
&lt;p&gt;Docker已经上市很多年，不是什么新鲜事物了，很多企业或者开发同学以前也不多不少有所接触，但是有实操经验的人不多，本系列教程主要偏重实战，尽量讲干货，会根据本人理解去做阐述，具体官方概念可以查阅官方教程，本章目标如下&lt;/p&gt;
&lt;p&gt;本系列教程导航:&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/evan-liang/p/12237400.html&quot;&gt;Docker深入浅出系列 | 容器初体验&lt;/a&gt;&lt;br/&gt;[Docker深入浅出系列 | 容器初体验(https://www.cnblogs.com/evan-liang/p/12237400.html)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;&lt;li&gt;了解Docker容器网络通信原理&lt;/li&gt;
&lt;li&gt;了解Linux网络虚拟化技术的原理&lt;/li&gt;
&lt;li&gt;了解容器在Linux上怎么进行网络隔离&lt;/li&gt;
&lt;li&gt;了解Docker端口映射配置&lt;/li&gt;
&lt;li&gt;了解Docker的网络模式&lt;/li&gt;
&lt;li&gt;了解如何在Docker使用自定义网络&lt;/li&gt;
&lt;li&gt;了解Docker网络操作的一些常用指令&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;p&gt;本教程是基于第一章创建的虚拟机、操作系统和Docker演示&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;虚拟机 - VirtualBox-6.0.14-133895-OSX.dmg&lt;/li&gt;
&lt;li&gt;虚拟机管理工具 - Vagrant_2.2.6_x86_64.dmg&lt;/li&gt;
&lt;li&gt;操作系统 - Centos7&lt;/li&gt;
&lt;li&gt;容器技术 - Docker&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;
&lt;h2 id=&quot;同一主机两个容器如何相互通信&quot;&gt;&lt;strong&gt;同一主机两个容器如何相互通信?&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;在同一台主机内的两个容器是怎么通信的呢？&lt;br/&gt;两个容器是怎么做到网络隔离的呢?&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206225343734.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;怎么从服务器外访问容器&quot;&gt;&lt;strong&gt;怎么从服务器外访问容器&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我怎样才能在服务器外通过浏览器访问到服务器里的端口为8080的容器的资源?&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206225409534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;docker的三种网络模式是什么&quot;&gt;&lt;strong&gt;Docker的三种网络模式是什么&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;Docker的三种网络模式是什么，都有什么特点呢?&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206225518654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;计算机网络模型回顾&quot;&gt;&lt;strong&gt;计算机网络模型回顾&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206225551425.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在互联网世界，两台主机要进行通信，是通过两个网卡/网络接口连接起来，接收和发送数据包都经过网卡，两个网卡之间相当于建立了一条通信管道。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206225619331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux中的网卡&quot;&gt;&lt;strong&gt;Linux中的网卡&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;查看网卡接口信息&quot;&gt;&lt;strong&gt;查看网卡接口信息&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;1.查看链路层网卡信息&lt;br/&gt;&lt;code&gt;ip link show&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip link show
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 52:54:00:8a:fe:e6 brd ff:ff:ff:ff:ff:ff
3: eth1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:ba:0a:28 brd ff:ff:ff:ff:ff:ff
4: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default 
    link/ether 02:42:12:9a:b1:a7 brd ff:ff:ff:ff:ff:ff&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.显示应用层网卡信息,可以看到更多详细信息，例如ip地址&lt;br/&gt;&lt;code&gt;ip a&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 52:54:00:8a:fe:e6 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic eth0
       valid_lft 57001sec preferred_lft 57001sec
    inet6 fe80::5054:ff:fe8a:fee6/64 scope link 
       valid_lft forever preferred_lft forever
3: eth1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:ba:0a:28 brd ff:ff:ff:ff:ff:ff
    inet 192.168.100.12/24 brd 192.168.100.255 scope global noprefixroute dynamic eth1
       valid_lft 143401sec preferred_lft 143401sec
    inet6 fe80::a00:27ff:feba:a28/64 scope link 
       valid_lft forever preferred_lft forever
4: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:12:9a:b1:a7 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.显示系统所有的网卡&lt;br/&gt;&lt;code&gt;ls /sys/class/net&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ls /sys/class/net
docker0  eth0  eth1  lo&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;网卡的操作&quot;&gt;&lt;strong&gt;网卡的操作&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;ip-a核心信息详解&quot;&gt;&lt;strong&gt;&lt;code&gt;ip a&lt;/code&gt;核心信息详解&lt;/strong&gt;&lt;/h3&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;3: eth1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:ba:0a:28 brd ff:ff:ff:ff:ff:ff
    inet 192.168.100.12/24 brd 192.168.100.255 scope global noprefixroute dynamic eth1
       valid_lft 143401sec preferred_lft 143401sec
    inet6 fe80::a00:27ff:feba:a28/64 scope link 
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt;&lt;/code&gt;这个配置串告诉我们：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;BROADCAST 该接口支持广播&lt;br/&gt;MULTICAST 该接口支持多播&lt;br/&gt;UP 网络接口已启用&lt;br/&gt;LOWER_UP 网络电缆已插入，设备已连接至网络&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;其他配置信息:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;mtu 1500 最大传输单位（数据包大小）为1,500字节&lt;br/&gt;qdisc pfifo_fast 用于数据包排队&lt;br/&gt;state UP 网络接口已启用&lt;br/&gt;group default 接口组&lt;br/&gt;qlen 1000 传输队列长度&lt;br/&gt;link/ether 08:00:27:ba:0a:28 接口的 MAC（硬件）地址&lt;br/&gt;brd ff:ff:ff:ff:ff:ff 广播地址&lt;br/&gt;inet 192.168.100.12/24 绑定的IPv4 地址&lt;br/&gt;brd 192.168.0.255 广播地址&lt;br/&gt;scope global 全局有效&lt;br/&gt;dynamic eth1 地址是动态分配的&lt;br/&gt;valid_lft 143401sec IPv4 地址的有效使用期限&lt;br/&gt;preferred_lft 143401sec IPv4 地址的首选生存期&lt;br/&gt;inet6 fe80::a00:27ff:feba:a28/64 IPv6 地址&lt;br/&gt;scope link 仅在此设备上有效&lt;br/&gt;valid_lft forever IPv6 地址的有效使用期限&lt;br/&gt;preferred_lft forever IPv6 地址的首选生存期&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;网卡的配置文件&quot;&gt;&lt;strong&gt;网卡的配置文件&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;通过以下命令，可以查看对应网卡的配置信息，ifcfg-*文件&lt;br/&gt;&lt;code&gt;cat /etc/sysconfig/network-scripts/ifcfg-eth0&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;修改网卡配置绑定一个新ip地址&quot;&gt;&lt;strong&gt;修改网卡配置，绑定一个新ip地址&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;这里可以修改配置文件ifcfg-*直接复制一份新的ip配置添加，但是我默认网络用的是动态ip，通过命令会更方便&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip addr add 192.168.0.100/24 dev eth0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从下面可以看到，通过&lt;code&gt;ip a&lt;/code&gt;查看，新的ip已经成功绑定&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 52:54:00:8a:fe:e6 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic eth0
       valid_lft 54131sec preferred_lft 54131sec
    inet 192.168.0.100/24 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::5054:ff:fe8a:fee6/64 scope link 
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过以下指定，把新增的ip清理掉&lt;br/&gt;&lt;code&gt;ip addr delete 192.168.0.100/24 dev eth0&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;网卡的重启与启动&quot;&gt;&lt;strong&gt;网卡的重启与启动&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;重启网卡&lt;br/&gt;&lt;code&gt;service network restart / systemctl restart network&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;启动或者关闭网卡&lt;br/&gt;&lt;code&gt;ifup/ifdown eth0 or ip link set eth0 up/down&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;linux网络虚拟化技术&quot;&gt;&lt;strong&gt;Linux网络虚拟化技术&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;从上文我们可以知道，两个主机通信是通过两个网卡连接起来，那在同一个Linux系统，怎么模拟多个网络环境，两个容器是怎么做到网络隔离呢？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206225657748.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Linux系统中，是通过network namespace来进行网络隔离，Docker也是利用该技术，创建一个完全隔离的新网络环境，这个环境包括一个独立的网卡空间，路由表，ARP表，ip地址表，iptables，ebtables，等等。总之，与网络有关的组件都是独立的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ip&lt;/code&gt;命令提供了&lt;code&gt;ip netns exec&lt;/code&gt;子命令可以在对应的network namesapce进行操作，要执行的可以是任何命令，不只是和网络相关的，创建network namesapce后可以通过&lt;code&gt;ip ntns exec&lt;/code&gt;+namespace名+shell指令进行操作。例如在对应namespace查看网卡信息&lt;code&gt;ip ntns exec nsn1 ip a&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;创建虚拟网络环境&quot;&gt;&lt;strong&gt;创建虚拟网络环境&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;常用的一些network namespace指令如下:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ip netns list #查看network namespace 
ip netns add ns1 #添加network namespace 
ip netns delete ns1 #删除network namespace&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;创建namespace---ns1&quot;&gt;&lt;strong&gt;创建namespace - ns1&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;1.创建network namespace - ns1&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns add ns1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.查看ns1网卡信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns1 ip a
1: lo: &amp;lt;LOOPBACK&amp;gt; mtu 65536 qdisc noop state DOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这时候网卡状态是Down，此时只有一个lo网卡&lt;/p&gt;
&lt;p&gt;3.启动ns1上的lo网卡&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns1 ifup lo&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.查看网卡状态&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns1 ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state unk group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时网卡状态已经变成UNKOWN，lo网卡上也绑定了一个本地回环地址&lt;code&gt;127.0.0.1/8&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;创建namespace---ns2&quot;&gt;&lt;strong&gt;创建namespace - ns2&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;重复上面步骤，按照上面的指令把ns1改为ns2执行一边，最后可以看到网卡状态也为UNKOWN&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns2 ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过上面的一系列步骤，两个network namespace的网络结构如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206225754506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;此时两个Network Namespace只有lo设备，互相之间是没有关联，无法通信，只能同一Network Namesapce内的应用访问。&lt;/p&gt;
&lt;h3 id=&quot;连通两个network-namespace&quot;&gt;&lt;strong&gt;连通两个Network Namespace&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;Linux提供&lt;code&gt;Virtual Ethernet Pair&lt;/code&gt;技术，分别在两个namespace建立一对网络接口，类似在两个name space之间建立一条pipe，好像拉一条网线一样，让彼此之间可以通信，简称&lt;code&gt;veth pair&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;veth pair&lt;/code&gt;是成对出现，删除其中一个，另一个也会自动消失。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206225822566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.创建连一对veth虚拟网卡，类似pipe，发给veth-ns1的数据包veth-ns2那边会收到，发给veth2的数据包veth0会收到。就相当于给机器安装了两个网卡，并且之间用网线连接起来了，两个虚拟网卡分别为veth-ns1、veth-ns2&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip link add veth-ns1 type veth peer name veth-ns2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.查看link，可以看到连接已经建立&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip link
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 52:54:00:8a:fe:e6 brd ff:ff:ff:ff:ff:ff
3: eth1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:ba:0a:28 brd ff:ff:ff:ff:ff:ff
4: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default 
    link/ether 02:42:12:9a:b1:a7 brd ff:ff:ff:ff:ff:ff
5: veth-ns2@veth-ns1: &amp;lt;BROADCAST,MULTICAST,M-DOWN&amp;gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 2a:96:f4:e3:00:d2 brd ff:ff:ff:ff:ff:ff
6: veth-ns1@veth-ns2: &amp;lt;BROADCAST,MULTICAST,M-DOWN&amp;gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether da:89:0e:56:03:3f brd ff:ff:ff:ff:ff:ff&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.把两个虚拟网卡分别加到两个network name space ns1、ns2中&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip link set veth-ns1 netns ns1
[root@10 /]# ip link set veth-ns2 netns ns2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.分别查看宿主机器和两个network namesapce的情况&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ip link ip netns exec ns1 ip link ip netns exec ns2 ip link&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ns1上的虚拟网卡信息&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;6: veth-ns1@if5: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether da:89:0e:56:03:3f brd ff:ff:ff:ff:ff:ff link-netnsid 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ns2上的虚拟网卡信息&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;5: veth-ns2@if6: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 2a:96:f4:e3:00:d2 brd ff:ff:ff:ff:ff:ff link-netnsid 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面指令执行结果可以看到原来宿主机的一对虚拟网卡已经移到两个network namespace那，当前的网卡状态还是DOWN，两个网卡的序列号是按顺序成对的@if5、@if6&lt;/p&gt;
&lt;p&gt;5.分别启动这两个虚拟网卡&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns1 ip link set veth-ns1 up
[root@10 /]# ip netns exec ns2 ip link set veth-ns2 up&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果分别如下:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;6: veth-ns1@if5: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000
    link/ether da:89:0e:56:03:3f brd ff:ff:ff:ff:ff:ff link-netnsid 1&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;5: veth-ns2@if6: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP mode DEFAULT group default qlen 1000
    link/ether 2a:96:f4:e3:00:d2 brd ff:ff:ff:ff:ff:ff link-netnsid 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到此时两个虚拟网卡状态为UP，都已经启动，但还没有IP地址，因此还不能通信&lt;/p&gt;
&lt;p&gt;6.给虚拟网卡配置IP地址&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns1 ip addr add 192.168.0.11/24 dev veth-ns1
[root@10 /]# ip netns exec ns2 ip addr add 192.168.0.12/24 dev veth-ns2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;7.通过&lt;code&gt;ip a&lt;/code&gt;查看ip地址是否配置成功&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;root@10 /]# ip netns exec ns1 ip a&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;root@10 /]# ip netns exec ns2 ip a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8.测试ns1和ns2是否可以互相连通&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns1 ping 192.168.0.12
PING 192.168.0.12 (192.168.0.12) 56(84) bytes of data.
64 bytes from 192.168.0.12: icmp_seq=1 ttl=64 time=0.048 ms &lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns2 ping 192.168.0.11
PING 192.168.0.11 (192.168.0.11) 56(84) bytes of data.
64 bytes from 192.168.0.11: icmp_seq=1 ttl=64 time=0.041 ms
64 bytes from 192.168.0.11: icmp_seq=2 ttl=64 time=0.039 ms
64 bytes from 192.168.0.11: icmp_seq=3 ttl=64 time=0.041 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时候，两个network namespace已经成功连通了&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020020622591475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;通过bridege建立多个namesapce通信&quot;&gt;&lt;strong&gt;通过Bridege建立多个namesapce通信&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;以上的&lt;code&gt;veth pair&lt;/code&gt;只能解决两个namesapce之间的通信问题，但是多个namesapce是不能直接互相通信，因为处于不同的网络，在日常生活中，我们会用到交换机去连接不同的网络，而在Linux，我们可以通过bridege去实现。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206225943162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;在上图可以看到，这时候连个namespace ns3、ns4并不是直接通过&lt;code&gt;veth pair&lt;/code&gt;连接，而是通过bridge间接连接，接下来我会一步步教大家怎么按照上图设置&lt;/p&gt;
&lt;p&gt;1.创建Network Space&lt;br/&gt;为了避免跟上面混淆，我们重新创建新的namespace&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns add ns3
[root@10 /]# ip netns add ns4
[root@10 /]# ip netns add bridge&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.创建一对&lt;code&gt;veth pair&lt;/code&gt;网卡&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip link add type veth&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.查看宿主机上生成的一对虚拟网卡&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip link
...
7: veth0@veth1: &amp;lt;BROADCAST,MULTICAST,M-DOWN&amp;gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 36:8e:bc:43:f0:4a brd ff:ff:ff:ff:ff:ff
8: veth1@veth0: &amp;lt;BROADCAST,MULTICAST,M-DOWN&amp;gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000
    link/ether 92:c0:44:18:64:93 brd ff:ff:ff:ff:ff:ff&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，宿主机已经存在一对网卡veth1、veth0&lt;/p&gt;
&lt;p&gt;4.让veth0加入到ns3中，让veth1加入到bridge中，并分别把虚拟网卡重命名为ns3-bridge、bridge-ns3&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip link set dev veth0 name ns3-bridge netns ns3
[root@10 /]# ip link set dev veth1 name bridge-ns3 netns bridge&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.在创建一对&lt;code&gt;veth pair&lt;/code&gt;，让veth0加入到ns4中，让veth1加入到bridge中，并分别把虚拟网卡重命名为ns4-bridge、bridge-ns4&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip link add type veth
[root@10 /]# ip link set dev veth0 name ns4-bridge netns ns4
[root@10 /]# ip link set dev veth1 name bridge-ns4 netns bridge&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6.分别进入各个namespace查看网卡信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns4 ip a
...
9: ns4-bridge@if10: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether ea:53:ea:e6:2e:2e brd ff:ff:ff:ff:ff:ff link-netnsid 1&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns3 ip a
...
7: ns3-bridge@if8: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether 36:8e:bc:43:f0:4a brd ff:ff:ff:ff:ff:ff link-netnsid 1&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec bridge ip a
...
8: bridge-ns3@if7: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether 92:c0:44:18:64:93 brd ff:ff:ff:ff:ff:ff link-netnsid 0
10: bridge-ns4@if9: &amp;lt;BROADCAST,MULTICAST&amp;gt; mtu 1500 qdisc noop state DOWN group default qlen 1000
    link/ether 9e:f4:57:43:2e:2b brd ff:ff:ff:ff:ff:ff link-netnsid 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到ns3与bridge、ns4与bridge的网卡序号是连续的，证明是同一对&lt;code&gt;veth pair&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;7.在bridge namespace中创建br设备(网桥)&lt;/p&gt;
&lt;p&gt;在对bridge进行操作，需要用到&lt;code&gt;bridge-utils&lt;/code&gt;，可以通过以下命令安装&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;yum install bridge-utils&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来创建br设备&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec bridge brctl addbr br&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8.启动br设备&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec bridge ip link set dev br up&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;9.启动bridge中的两个虚拟网卡&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec bridge ip link set dev bridge-ns3 up
[root@10 /]# ip netns exec bridge ip link set dev bridge-ns4 up&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;10.把bridge中两个虚拟网卡加入到br设备中&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec bridge brctl addif br bridge-ns3
[root@10 /]# ip netns exec bridge brctl addif br bridge-ns4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;11.启动ns3、ns4中的虚拟网卡，并加入ip&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns3 ip link set dev ns3-bridge up
[root@10 /]# ip netns exec ns3 ip address add 192.168.0.13/24 dev ns3-bridge

[root@10 /]# ip netns exec ns4 ip link set dev ns4-bridge up
[root@10 /]# ip netns exec ns4 ip address add 192.168.0.14/24 dev ns4-bridge&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;12.测试两个namespace的连通性&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns3 ping 192.168.0.14
PING 192.168.0.14 (192.168.0.14) 56(84) bytes of data.
64 bytes from 192.168.0.14: icmp_seq=1 ttl=64 time=0.061 ms
64 bytes from 192.168.0.14: icmp_seq=2 ttl=64 time=0.047 ms
64 bytes from 192.168.0.14: icmp_seq=3 ttl=64 time=0.042 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip netns exec ns4 ping 192.168.0.13
PING 192.168.0.13 (192.168.0.13) 56(84) bytes of data.
64 bytes from 192.168.0.13: icmp_seq=1 ttl=64 time=0.046 ms
64 bytes from 192.168.0.13: icmp_seq=2 ttl=64 time=0.076 ms
64 bytes from 192.168.0.13: icmp_seq=3 ttl=64 time=0.081 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;docker容器的网络&quot;&gt;&lt;strong&gt;Docker容器的网络&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206230035481.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;Docker常见的网络模式有三种bridge、none和host&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;bridge - Docker的默认网络模式，有独立的命名空间，能够支持各种自定义网络， 以及实现网络隔离，能够满足容器网络隔离的要求&lt;/li&gt;
&lt;li&gt;host - 容器与主机在相同的网络命名空间下面，使用相同的网络协议栈，容器可以直接使用主机的所有网络接口，最简单和最低延迟的模式&lt;/li&gt;
&lt;li&gt;none - 使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置，即Docker容器没有网卡、IP、路由等信息，让开发者可以自由按需定制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Docker网络相关指令&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;docker network ls - 查询可用网络&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;docker network create - 新建一个网络&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;docker network rm - 移除一个网络&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;docker network inspect - 查看一个网络&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;docker network connect - 连接容器到一个网络&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;docker network disconnect - 把容器从一个网络断开&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;bridge网络模式实现&quot;&gt;&lt;strong&gt;bridge网络模式实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;bridge是docker容器默认的网络模式，它的实现原理跟我们网络虚拟化的多namespace例子一样，通过&lt;code&gt;veth pair&lt;/code&gt;和bridge进行间接连接，当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发，创建了在主机和所有容器之间一个虚拟共享网络&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206230105550.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来，我们以上图tomcat容器为例，来展示下bridge模式的操作&lt;/p&gt;
&lt;p&gt;1.启动两个tomcat容器(使用我们在第一章创建的tomcat镜像)&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 vagrant]# docker run -d --name tomcat01 -p 8081:8080 tomcat
[root@10 /]# docker run -d --name tomcat03 -p 8082:8080 tomcat&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.查看两个tomcat容器的网络接口信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat01 ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
11: eth0@if12: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat03 ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
15: eth0@if16: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:11:00:03 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.17.0.3/16 brd 172.17.255.255 scope global eth0
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到tomcat01和tomcat03的ip分别为&lt;code&gt;172.17.0.2/16&lt;/code&gt;、&lt;code&gt;172.17.0.3/16&lt;/code&gt;，并且有一对不连续的基于&lt;code&gt;veth pair&lt;/code&gt;创建的虚拟网卡&lt;code&gt;eth0@if12&lt;/code&gt;、&lt;code&gt;eth0@if16&lt;/code&gt;，很明显，根据我们上面学过的内容，这两个不是成对出现的虚拟网卡不能直接通信，应该是通过bridge来进行连接&lt;/p&gt;
&lt;p&gt;3.查看宿主机centos系统的网卡信息，验证是否存在与tomcat容器对应的虚拟网卡&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]#  ip a
...
4: docker0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:12:9a:b1:a7 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:12ff:fe9a:b1a7/64 scope link 
       valid_lft forever preferred_lft forever
12: veth068cc5c@if11: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue master docker0 state UP group default 
    link/ether 66:1c:13:cd:b4:78 brd ff:ff:ff:ff:ff:ff link-netnsid 5
    inet6 fe80::641c:13ff:fecd:b478/64 scope link 
       valid_lft forever preferred_lft forever
16: veth92816fa@if15: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue master docker0 state UP group default 
    link/ether 0a:cf:a0:8e:78:7f brd ff:ff:ff:ff:ff:ff link-netnsid 6
    inet6 fe80::8cf:a0ff:fe8e:787f/64 scope link 
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;果然，我们可以看到宿主机上确实存在与两个tomcat容器相对应的虚拟网卡，并且还有一个虚拟网桥docker0的网络接口，这种连接方法叫bridge模式&lt;/p&gt;
&lt;p&gt;4.通过&lt;code&gt;docker network inspect bridge&lt;/code&gt;命令查看下bridge的配置&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker network inspect 
 ...
        &quot;Containers&quot;: {
            &quot;2f3c3081b8bd409334f21da3441f3b457e243293f3180d54cfc12d5902ad4dbc&quot;: {
                &quot;Name&quot;: &quot;tomcat03&quot;,
                &quot;EndpointID&quot;: &quot;2375535cefdbccd3434d563ef567a1032694bdfb4356876bd9d8c4e07b1f222b&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,
                &quot;IPv4Address&quot;: &quot;172.17.0.3/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;c13db4614a49c302121e467d8aa8ea4f008ab55f83461430d3dd46e59085937f&quot;: {
                &quot;Name&quot;: &quot;tomcat01&quot;,
                &quot;EndpointID&quot;: &quot;99a04efa9c7bdb0232f98d25f490682b065de1ce076b31487778fa257552a2ba&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,
                &quot;IPv4Address&quot;: &quot;172.17.0.2/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            }
        },
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到两个container已经绑定到bridge中&lt;/p&gt;
&lt;p&gt;5.分别测试两个tomcat容器相互连通&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat01 ping 172.17.0.3
PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data.
64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.054 ms
64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.040 ms
64 bytes from 172.17.0.3: icmp_seq=3 ttl=64 time=0.039 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat03 ping 172.17.0.2
PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.
64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.046 ms
64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.042 ms
64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.039 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这两个容器可以互相访问&lt;/p&gt;
&lt;p&gt;6.在容器访问互联网网站&lt;/p&gt;
&lt;p&gt;docker容器是可以通过brige与host主机网络连通，因此可以间接通过iptables实现NAT转发进行互联网访问，能够让多个内网用户通过一个外网地址上网，解决了IP资源匮乏的问题&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206230153337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来选择其中刚才其中一个tomcat容器进行测试，如果发现不能访问互联网，可能需要重启下docker服务&lt;code&gt;systemctl restart docker&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat01 curl -I https://www.baidu.com
HTTP/1.1 200 OK
Accept-Ranges: bytes
Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
Connection: keep-alive
Content-Length: 277
Content-Type: text/html
Date: Thu, 06 Feb 2020 06:03:48 GMT
Etag: &quot;575e1f72-115&quot;
Last-Modified: Mon, 13 Jun 2016 02:50:26 GMT
Pragma: no-cache
Server: bfe/1.0.8.18&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面返回信息可以看到，容器成功访问百度网站&lt;/p&gt;
&lt;h3 id=&quot;host网络模式实现&quot;&gt;&lt;strong&gt;host网络模式实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;host模式是共享宿主机器网络，因此使用的是同一个network namespace&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206230218167.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.创建一个容器，命名为tomcat-host，网络模式选择host&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker run -d --name tomcat-host --network host tomcat
ee3c6d2a5f61caa371088f40bc0c5d11101d12845cdee24466322a323b11ee11&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.查看容器的网络接口信息会发现跟宿主centos的一样&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat-host ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 52:54:00:8a:fe:e6 brd ff:ff:ff:ff:ff:ff
    inet 10.0.2.15/24 brd 10.0.2.255 scope global noprefixroute dynamic eth0
       valid_lft 50028sec preferred_lft 50028sec
    inet6 fe80::5054:ff:fe8a:fee6/64 scope link 
       valid_lft forever preferred_lft forever
3: eth1: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 08:00:27:ba:0a:28 brd ff:ff:ff:ff:ff:ff
    inet 192.168.100.12/24 brd 192.168.100.255 scope global noprefixroute dynamic eth1
       valid_lft 156886sec preferred_lft 156886sec
    inet6 fe80::a00:27ff:feba:a28/64 scope link 
       valid_lft forever preferred_lft forever
4: docker0: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc noqueue state DOWN group default 
    link/ether 02:42:12:9a:b1:a7 brd ff:ff:ff:ff:ff:ff
    inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0
       valid_lft forever preferred_lft forever
    inet6 fe80::42:12ff:fe9a:b1a7/64 scope link 
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.查看容器的网络信息，会发现容器没有被单独分配ip地址&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;        &quot;Containers&quot;: {
            &quot;ee3c6d2a5f61caa371088f40bc0c5d11101d12845cdee24466322a323b11ee11&quot;: {
                &quot;Name&quot;: &quot;tomcat-host&quot;,
                &quot;EndpointID&quot;: &quot;53565ff879878bfd10fc5843582577d54eb68b14b29f4b1ff2e213d38e2af7ce&quot;,
                &quot;MacAddress&quot;: &quot;&quot;,
                &quot;IPv4Address&quot;: &quot;&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;none网络模式实现&quot;&gt;&lt;strong&gt;none网络模式实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;上面提到，none网络模式是有一个独立的namesapce，默认情况下没有任何初始化网络配置，与外界网络隔离，需要自己去定制&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206230243139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.创建容器tomcat-none，并设置网络为none&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker run -d --name tomcat-none --network none tomcat
d90808e0b7455c2f375c3d88fa18a1872b4a03e2112bff3db0b3996d16523b1a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.查看网络接口信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat-none ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里只有lo设备，没有其他网卡，只有本地回环ip地址&lt;/p&gt;
&lt;p&gt;3.查看docker网络信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;        &quot;Containers&quot;: {
            &quot;d90808e0b7455c2f375c3d88fa18a1872b4a03e2112bff3db0b3996d16523b1a&quot;: {
                &quot;Name&quot;: &quot;tomcat-none&quot;,
                &quot;EndpointID&quot;: &quot;4ea757bbd108ac783bd1257d33499b7b77cd7ea529d4e6c761923eb596dc446c&quot;,
                &quot;MacAddress&quot;: &quot;&quot;,
                &quot;IPv4Address&quot;: &quot;&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;容器没有被分配任何地址&lt;/p&gt;
&lt;h3 id=&quot;自定义网络模式custom实现&quot;&gt;&lt;strong&gt;自定义网络模式custom实现&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;我们可以创建自己的网络模式，这里默认是bridge模式，接下来我们演示如何让不同网络的容器连通起来&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206230317174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.创建一个新网络，名字为custom，默认模式是bridge&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker network create custom
af392e4739d810b2e12219c21f505135537e95ea0afcb5075b3b1a5622a66112&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.查看下当前docker网络列表&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker network ls
NETWORK ID          NAME                DRIVER              SCOPE
ce20377e3f10        bridge              bridge              local
af392e4739d8        custom              bridge              local
afc6ca3cf515        host                host                local
94cfa528d194        none                null                local&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.查看下自定义网络的一些信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;94cfa528d194        none                null                local
[root@10 /]# docker network inspect custom
[
    {
        &quot;Name&quot;: &quot;custom&quot;,
        &quot;Id&quot;: &quot;af392e4739d810b2e12219c21f505135537e95ea0afcb5075b3b1a5622a66112&quot;,
        &quot;Created&quot;: &quot;2020-02-05T23:49:08.321895241Z&quot;,
        &quot;Scope&quot;: &quot;local&quot;,
        &quot;Driver&quot;: &quot;bridge&quot;,
        &quot;EnableIPv6&quot;: false,
        &quot;IPAM&quot;: {
            &quot;Driver&quot;: &quot;default&quot;,
            &quot;Options&quot;: {},
            &quot;Config&quot;: [
                {
                    &quot;Subnet&quot;: &quot;172.18.0.0/16&quot;,
                    &quot;Gateway&quot;: &quot;172.18.0.1&quot;
                }
            ]
        },
        &quot;Internal&quot;: false,
        &quot;Attachable&quot;: false,
        &quot;Ingress&quot;: false,
        &quot;ConfigFrom&quot;: {
            &quot;Network&quot;: &quot;&quot;
        },
        &quot;ConfigOnly&quot;: false,
        &quot;Containers&quot;: {},
        &quot;Options&quot;: {},
        &quot;Labels&quot;: {}
    }
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.创建一个容器tomcat-custom，容器网络模式为custom&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker run -d --name tomcat-custom --network custom tomcat
2e77115f42e36827646fd6e3abacc0594ff71cd1847f6fbffda28e22fb55e9ea&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.查看tomcat-custom的网络接口信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat-custom ip a
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
22: eth0@if23: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue state UP group default 
    link/ether 02:42:ac:12:00:02 brd ff:ff:ff:ff:ff:ff link-netnsid 0
    inet 172.18.0.2/16 brd 172.18.255.255 scope global eth0
       valid_lft forever preferred_lft forever&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6.测试tomcat-custom去连接上面我们创建的tomcat01容器&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat-custom ping 192.17.0.2
PING 192.17.0.2 (192.17.0.2) 56(84) bytes of data.
--- 192.17.0.2 ping statistics ---
4 packets transmitted, 0 received, 100% packet loss, time 3001ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面执行结果可以看出，默认情况下，tomcat-custom跟tomcat01是不能连通，因为处于不同的网络custom、bridge。&lt;/p&gt;
&lt;p&gt;7.把tomcat01加到自定义网络custom&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker network connect custom tomcat01&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;8.查看当前custom网络信息&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt; &quot;Containers&quot;: {
            &quot;2e77115f42e36827646fd6e3abacc0594ff71cd1847f6fbffda28e22fb55e9ea&quot;: {
                &quot;Name&quot;: &quot;tomcat-custom&quot;,
                &quot;EndpointID&quot;: &quot;bf2b94f3b580b9df0ca9f6ce2383198961711d1b3d19d33bbcf578d81157e47f&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:02&quot;,
                &quot;IPv4Address&quot;: &quot;172.18.0.2/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            },
            &quot;c13db4614a49c302121e467d8aa8ea4f008ab55f83461430d3dd46e59085937f&quot;: {
                &quot;Name&quot;: &quot;tomcat01&quot;,
                &quot;EndpointID&quot;: &quot;f97305672ae617f207dfef1b3dc250d2b8d6a9ec9b36b1b0115e2456f18c44c6&quot;,
                &quot;MacAddress&quot;: &quot;02:42:ac:12:00:03&quot;,
                &quot;IPv4Address&quot;: &quot;172.18.0.3/16&quot;,
                &quot;IPv6Address&quot;: &quot;&quot;
            }
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到两个容器都已经配置到custom网络中,tomcat-custom &lt;code&gt;172.18.0.2/16&lt;/code&gt;，tomcat01 &lt;code&gt;172.18.0.3/16&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;9.配置完网络后，在用tomcat01尝试连接tomcat-custom&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat01 ping 172.18.0.3
PING 172.18.0.3 (172.18.0.3) 56(84) bytes of data.
64 bytes from 172.18.0.3: icmp_seq=1 ttl=64 time=0.032 ms
64 bytes from 172.18.0.3: icmp_seq=2 ttl=64 time=0.080 ms
64 bytes from 172.18.0.3: icmp_seq=3 ttl=64 time=0.055 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从执行结果可以看到，现在tomcat01已经可以跟tomcat-custom通信了，因为处于同一个网络中&lt;/p&gt;
&lt;p&gt;10.此时查看centos中的网络接口信息，可以看到存在对应的虚拟网卡&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# ip a
...
23: vethc30bd52@if22: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue master br-af392e4739d8 state UP group default 
    link/ether 2e:a1:c8:a2:e5:83 brd ff:ff:ff:ff:ff:ff link-netnsid 5
    inet6 fe80::2ca1:c8ff:fea2:e583/64 scope link 
       valid_lft forever preferred_lft forever
25: veth69ea87b@if24: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue master docker0 state UP group default 
    link/ether 92:eb:8f:65:fe:7a brd ff:ff:ff:ff:ff:ff link-netnsid 6
    inet6 fe80::90eb:8fff:fe65:fe7a/64 scope link 
       valid_lft forever preferred_lft forever
27: veth068cc5c@if11: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc noqueue master br-af392e4739d8 state UP group default 
    link/ether ea:44:90:6c:0d:49 brd ff:ff:ff:ff:ff:ff link-netnsid 6
    inet6 fe80::e844:90ff:fe6c:d49/64 scope link 
       valid_lft forever preferred_lft forever
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;自定义网络中的嵌入式dns&quot;&gt;&lt;strong&gt;自定义网络中的嵌入式DNS&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;当用户创建了自定义网络，docker引擎默认会对加入该网络的容器启动嵌入式DNS，因此同一网络的容器可以互相通过容器名称进行通信，避免因下游系统有ip需要重新发布&lt;/p&gt;
&lt;p&gt;对于非自定义网络，具体配置，可以查阅官网&lt;a href=&quot;https://docs.docker.com/v17.09/engine/userguide/networking/default_network/configure-dns/&quot;&gt;配置容器DNS&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206230349631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.通过上面我们创建号的自定义网络和容器进行测试&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat01 ping tomcat-custom
PING tomcat-custom (172.18.0.2) 56(84) bytes of data.
64 bytes from tomcat-custom.custom (172.18.0.2): icmp_seq=1 ttl=64 time=0.031 ms
64 bytes from tomcat-custom.custom (172.18.0.2): icmp_seq=2 ttl=64 time=0.038 ms
64 bytes from tomcat-custom.custom (172.18.0.2): icmp_seq=3 ttl=64 time=0.040 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat-custom ping tomcat01
PING tomcat01 (172.18.0.3) 56(84) bytes of data.
64 bytes from tomcat01.custom (172.18.0.3): icmp_seq=1 ttl=64 time=0.031 ms
64 bytes from tomcat01.custom (172.18.0.3): icmp_seq=2 ttl=64 time=0.038 ms
64 bytes from tomcat01.custom (172.18.0.3): icmp_seq=3 ttl=64 time=0.040 ms&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到tomcat01和tomcat-custom可以互相通过容器名进行通信&lt;/p&gt;
&lt;h3 id=&quot;docker端口映射&quot;&gt;&lt;strong&gt;Docker端口映射&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;端口映射对于我们来说不陌生，平时访问服务，例如tomcat，都是通过ip+服务端口进行访问，如:localhost:8080，但是容器是寄生在宿主机器上，因此，如果我们想被外部访问，还需要映射到宿主的端口上，通过宿主的ip+port进行访问，如下如图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200206230419674.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V2YW5fTGV1bmc=,size_16,color_FFFFFF,t_70&quot;/&gt;&lt;br/&gt;接下来我们来实践下docker端口映射相关操作&lt;/p&gt;
&lt;p&gt;1.创建一个tomcat-port容器，指定宿主端口映射8999&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker run -d --name tomcat-port -p 8999:8080 tomcat
0b5b014ae2552b85aff55b385ba20518b38509b5670a95ad9eea09475ea26629&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.进入容器，在容器中访问&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# docker exec -it tomcat-port curl -i localhost:8080
HTTP/1.1 404 
Content-Type: text/html;charset=utf-8
Content-Language: en
Content-Length: 713
Date: Thu, 06 Feb 2020 07:43:59 GMT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面结果可以看到，实际上已经访问成功，但是由于我没有配置tomcat管理页面，所以这里是报404&lt;/p&gt;
&lt;p&gt;3.在centos访问容器&lt;br/&gt;这时候我们就需要通过容器ip+port的方式进行访问&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[root@10 /]# curl -I 172.17.0.4:8080
HTTP/1.1 404 
Content-Type: text/html;charset=utf-8
Content-Language: en
Transfer-Encoding: chunked
Date: Thu, 06 Feb 2020 07:49:41 GMT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里也访问成功&lt;/p&gt;
&lt;p&gt;4.在主体机器访问，也就是我的主机MacOS操作系统上访问&lt;/p&gt;
&lt;p&gt;这时候需要用虚拟机上centos IP+映射端口 进行访问&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;192:centos7 evan$ curl -I 192.168.100.12:8999
HTTP/1.1 404 
Content-Type: text/html;charset=utf-8
Content-Language: en
Transfer-Encoding: chunked
Date: Thu, 06 Feb 2020 07:52:52 GMT&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，这里也能正常访问&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;上文讲解了Docker的单机网络通信原理以及Linux虚拟化技术，最后我们回顾下一开始的那几个问题，相信大家心中都已经有答案了&lt;/p&gt;
&lt;p&gt;1.同一个主机两个容器如何通信？&lt;/p&gt;
&lt;p&gt;Docker基于&lt;code&gt;Virtual Ethernet Pair&lt;/code&gt;技术实现了容器之间的通信，但并非直接端对端对接，在默认网络bridge模式下，Docker引擎会分别在每个容器和宿主网络建立一对虚拟网卡&lt;code&gt;veth pair&lt;/code&gt;，通过bridge间接实现通信，通过network namespace实现网络隔离。&lt;/p&gt;
&lt;p&gt;2.怎么从服务器外访问容器？&lt;/p&gt;
&lt;p&gt;从服务器外访问容器是通过端口映射方式，访问的IP地址和端口并非容器的真实IP和端口，而是宿主机器的端口映射，所以要从服务器外部访问容器，需要通过宿主机器的IP/域名+宿主端口进行访问。&lt;/p&gt;
&lt;p&gt;3.Docker的三种网络模式是什么？&lt;/p&gt;
&lt;p&gt;Docker常见的网络模式有三种bridge、none和host&lt;/p&gt;
&lt;p&gt;bridge - Docker的默认网络模式，有独立的命名空间，能够支持各种自定义网络， 以及实现网络隔离，能够满足容器网络隔离的要求&lt;br/&gt;host - 容器与主机在相同的网络命名空间下面，使用相同的网络协议栈，容器可以直接使用主机的所有网络接口，最简单和最低延迟的模式&lt;br/&gt;none - 使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置，即Docker容器没有网卡、IP、路由等信息，让开发者可以自由按需定制&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://cizixs.com/2017/02/10/network-virtualization-network-namespace/&quot;&gt;linux 网络虚拟化： network namespace 简介&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.kghost.info/2013/03/01/linux-network-emulator/&quot;&gt;网络虚拟化技术（一）: Linux网络虚拟化&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Feb 2020 15:11:00 +0000</pubDate>
<dc:creator>EvanLeung</dc:creator>
<og:description>[toc] Docker已经上市很多年，不是什么新鲜事物了，很多企业或者开发同学以前也不多不少有所接触，但是有实操经验的人不多，本系列教程主要偏重实战，尽量讲干货，会根据本人理解去做阐述，具体官方概念</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/evan-liang/p/12271468.html</dc:identifier>
</item>
<item>
<title>SpringMVC 入门 - CoderJerry</title>
<link>http://www.cnblogs.com/yangyuanhu/p/12271415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyuanhu/p/12271415.html</guid>
<description>&lt;p&gt;Spring Web MVC是基于Servlet API构建的传统Web框架，并且从一开始就已包含在Spring框架中&lt;/p&gt;
&lt;p&gt;与Spring Web MVC并行，Spring Framework 5.0引入了一个新的反应式Web框架，其名称“ Spring WebFlux;&lt;/p&gt;
&lt;p&gt;理解:&lt;/p&gt;
&lt;p&gt;首先SpringMVC 是一个MVC构架模式的web框架,是基于Servlet的,从Spring第一个版本就一起推出了,&lt;/p&gt;
&lt;p&gt;传统web框架,指的是SpringMVC依然使用多线程同步并发的方式来处理请求,现如今大家都在鼓吹异步并发多么多么好,从测试数据来看异步并发效率的确更好,但是其并不成熟,极大多数公司项目还没有更新到异步技术,盲目的进行重构可能会引发更多的问题, 并且异步编程在代码结构上会产生较大的变化,对于初学者而言,掌握难度是较大的;&lt;/p&gt;
&lt;p&gt;构架图:&lt;br/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gbmkdyzjjcj30mj0euq3e.jpg&quot; alt=&quot;image-20200206122121806&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gbmk8rad3pj30mn0f7wg6.jpg&quot; alt=&quot;image-20200206122121806&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出&lt;/p&gt;
&lt;p&gt;SpringMVC 并没有代替Servlet,它只是在Servlet上提供了一套封装好的组件,提高开发效率;&lt;/p&gt;
&lt;p&gt;还使得开发出的项目更加规范;否则每个人可能有每个人不同的MVC;&lt;/p&gt;

&lt;p&gt;思考:&lt;/p&gt;
&lt;p&gt;若没有SpringMVC框架,我们该如何去编写一个较大的web项目呢,可以发现在选课系统中出现了大量的Servlet,因为一个请求地址就需要一个Servlet,使得项目体积变大,且Servlet是长期存在内存的;&lt;/p&gt;
&lt;p&gt;第一步,我们希望用一个Servlet来处理多个请求甚至是所有请求,就需要实现能根据请求路径查找处理请求方法的逻辑，这也是SpringMVC要做的第一件事情；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;DispatcherServlet：前端控制器&lt;br/&gt;用户请求首先到达前端控制器，它就相当于mvc模式中的c，DispatcherServlet是整个流程控制的调度中心，由它调用其它组件处理用户的请求，DispatcherServlet的存在降低了组件之间的耦合性。&lt;/li&gt;
&lt;li&gt;Handler：处理器&lt;br/&gt;Handler是继DispatcherServlet前端控制器的后端控制器，DispatcherServlet会将请求发送至对应的Handler来进行处理。&lt;strong&gt;Handler是处理业务逻辑的地方，需要我们自己来编写具体代码，等同于之前的Service层&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;HandlerMapping：处理器映射器&lt;br/&gt;HandlerMapping负责根据用户请求路径找到Handler，springmvc提供了不同的映射器实现不同的映射方式，例如：BeanName映射，配置文件映射，注解映射等。&lt;/li&gt;
&lt;li&gt;HandlAdapter：处理器适配器&lt;br/&gt;通过HandlerAdapter来执行Handler，因为Handler有不同形式，意味着调用方式是不同的，这是适配器模式的应用，我们也可以扩展适配器来实现新的Handler；&lt;/li&gt;
&lt;li&gt;ViewResolver：视图解析器&lt;br/&gt;ViewResolver负责从Handler中获取数据和视图，根据逻辑视名称查找物理视图文件，并查找View对象，再生成View对象；&lt;/li&gt;
&lt;li&gt;View：视图&lt;br/&gt;View的职责就是装配数据，SpringMVC框架提供了很多的View视图类型的支持，包括：jstlView、freemarkerView、pdfView等。常用视图就是jsp。&lt;strong&gt;我们需要根据业务需求，通过页面标签或页面模版技术将模型数据展示给用户&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然还有一些其他的&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440878/202002/1440878-20200206230010466-1677968779.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;pom依赖&quot;&gt;pom依赖&lt;/h2&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
  &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

  &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;MVC01&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
  &amp;lt;packaging&amp;gt;war&amp;lt;/packaging&amp;gt;

  &amp;lt;name&amp;gt;MVC01 Maven Webapp&amp;lt;/name&amp;gt;
  &amp;lt;!-- FIXME change it to the project's website --&amp;gt;
  &amp;lt;url&amp;gt;http://www.example.com&amp;lt;/url&amp;gt;

  &amp;lt;properties&amp;gt;
    &amp;lt;project.build.sourceEncoding&amp;gt;UTF-8&amp;lt;/project.build.sourceEncoding&amp;gt;
    &amp;lt;maven.compiler.source&amp;gt;1.7&amp;lt;/maven.compiler.source&amp;gt;
    &amp;lt;maven.compiler.target&amp;gt;1.7&amp;lt;/maven.compiler.target&amp;gt;
  &amp;lt;/properties&amp;gt;

  &amp;lt;dependencies&amp;gt;
    &amp;lt;!--   SpringMVC --&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;5.2.2.RELEASE&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;

    &amp;lt;!--JEE相关的--&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jstl&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.2&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;javax.servlet.jsp-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.3.3&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;4.0.1&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
  &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;web.xml配置&quot;&gt;web.xml配置&lt;/h2&gt;
&lt;p&gt;与在web项目中使用Spring中相同的是，我们也需要让SpringMVC随着web项目启动，SpringMVC的做法是利用DIspatcherServlet;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;
         version=&quot;4.0&quot;&amp;gt;

    &amp;lt;servlet&amp;gt;
        &amp;lt;servlet-name&amp;gt;DispatcherServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
&amp;lt;!--        初始化参数指定配置文件--&amp;gt;
        &amp;lt;init-param&amp;gt;
            &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
            &amp;lt;param-value&amp;gt;classpath:springmvc.xml&amp;lt;/param-value&amp;gt;
        &amp;lt;/init-param&amp;gt;
        &amp;lt;load-on-startup&amp;gt;&amp;lt;/load-on-startup&amp;gt;
    &amp;lt;/servlet&amp;gt;

&amp;lt;!--    要交给SpringMVC处理的请求--&amp;gt;
    &amp;lt;servlet-mapping&amp;gt;
        &amp;lt;servlet-name&amp;gt;DispatcherServlet&amp;lt;/servlet-name&amp;gt;
        &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
    &amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/web-app&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DispatcherServlet做了两个事情，1：初始化一个Spring容器，2：注册一个Servlet&lt;/p&gt;
&lt;p&gt;SpringMVC本质上也是一个Spring容器，在不涉及WEB时使用方法和Spring没有任何区别；ß&lt;/p&gt;
&lt;h3 id=&quot;url-pattern&quot;&gt;url-pattern&lt;/h3&gt;
&lt;p&gt;只有请求地址能够匹配到到被DispatcherServlet的url-pattern的请求才会被SpringMVC处理，那么那些请求要交给SpringMVC处理呢，通常是除静态资源以外的请求；&lt;/p&gt;
&lt;p&gt;常用pattern：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;除了.jsp 以外的所有请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;/*&lt;/td&gt;
&lt;td&gt;所有请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;*.action&lt;/td&gt;
&lt;td&gt;所有 以action结尾的请求&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;需要说明的是action并不是固定的不同公司可能不同，但无论是点什么，其目的都是为了和静态资源加以区分&lt;/p&gt;
&lt;h2 id=&quot;创建控制器类&quot;&gt;创建控制器类&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import org.springframework.web.servlet.ModelAndView;
import org.springframework.web.servlet.mvc.Controller;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

public class TestController implements Controller {

    @Override
    public ModelAndView handleRequest(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception {
        ModelAndView modelAndView = new ModelAndView();//创建一个表示模型和视图的对象
        modelAndView.setViewName(&quot;index.jsp&quot;);//设置视图名称
        modelAndView.addObject(&quot;msg&quot;,&quot;hello springMVC&quot;);//添加视图需要的数据
        //httpServletRequest.setAttribute(&quot;msg&quot;,&quot;hello SpringMVC&quot;); //等同于上面一行
        return modelAndView; //返回模型和视图给dispatcherServlet
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ModelAndView,其实就是把视图资源和数据打包到一起,然后视图名称交给视图解析器,Object放到请求中;&lt;/p&gt;
&lt;h2 id=&quot;注册控制器到容器中&quot;&gt;注册控制器到容器中&lt;/h2&gt;
&lt;p&gt;springmvc.xml&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&amp;gt;

    &amp;lt;bean name=&quot;/testController&quot; class=&quot;com.yh.controller.TestController&quot;/&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DispatcherServlet是按照请求路径来查找Handler,我们必须告诉SpringMVC,这个控制器是用来处理哪个请求地址的,默认情况下,SpringMVC会查找beanName与请求地址相同的Handler来处理;&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;测试:&lt;/h2&gt;
&lt;p&gt;打开浏览器输入地址:http://localhost:8080/MVC01_war_exploded/testController&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006tNbRwgy1gbmoba5pl3j307b039jrc.jpg&quot; alt=&quot;image-20200206143953076&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们在Request中添加了key为msg的字符内容&lt;code&gt;hello SpringMVC&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看到上述内容说明SpringMVC以及成功处理了请求;&lt;/p&gt;

&lt;p&gt;上述方法每个Controller只能处理一个请求地址,不够灵活,且需要Controller实现指定接口,这是就需要使用注解来配置Controller了;&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;@Controller&lt;/p&gt;
&lt;p&gt;该注解写在类上,用于注册控制器bean到容器中,这是之前以及学习过的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;@RequestMapping(&quot;url&quot;)&lt;/p&gt;
&lt;p&gt;该注解写在方法上时,用于为方法指定要匹配的url,该url是相对根路径的&lt;/p&gt;
&lt;p&gt;写在类上时类上的url是相对于根路径,而类中方法则相对于类的url&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;案列&quot;&gt;案列:&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller
//@RequestMapping(&quot;/user&quot;)
public class UserController {
    @RequestMapping(&quot;/getMsg&quot;)
    public ModelAndView getMsg(){
        ModelAndView modelAndView = new ModelAndView();
        modelAndView.setViewName(&quot;/index.jsp&quot;);
        modelAndView.addObject(&quot;msg&quot;,&quot;hello SpringMVC annotation!&quot;);
        return modelAndView;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求地址:http://localhost:8080/MVC01_war_exploded/getMsg,可正常访问&lt;/p&gt;
&lt;p&gt;当把类上注释的url打开时,上面的地址404了&lt;/p&gt;
&lt;p&gt;正确地址:http://localhost:8080/MVC01_war_exploded/user/getMsg&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要注意的是:&lt;br/&gt;viewName路径若不带/时则从当前请求的位置查找文件,带/则表示从根路径查找&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们完成了一个简单的入门案例,但是你会发现除了DispatcherServlet之外没有出现其他上面提到过的组件,那么它们是不是没有作用呢?&lt;/p&gt;
&lt;p&gt;其实SpringMVC提供了很多默认配置,使我们可以快速的开项目,而无需繁琐的配置,在SpringMVC的包下可以找到一个&lt;code&gt;DispatcherServlet.properties&lt;/code&gt;配置,这便是默认的配置文件了;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440878/202002/1440878-20200206230050489-1685749158.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;RouterFunctionMapping和HandlerFunctionAdapter都是webFlux中的这里不多关注;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;BeanNameUrlHandlerMapping&lt;/td&gt;
&lt;td&gt;用beanName作为url&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RequestMappingHandlerMapping&lt;/td&gt;
&lt;td&gt;使用注解配置url&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;HttpRequestHandlerAdapter&lt;/td&gt;
&lt;td&gt;实现HttpRequestHandler的处理器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;SimpleControllerHandlerAdapter&lt;/td&gt;
&lt;td&gt;实现Controller的处理器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;RequestMappingHandlerAdapter&lt;/td&gt;
&lt;td&gt;使用注解的handler,无需实现接口&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;SimpleServletHandlerAdapter&lt;/td&gt;
&lt;td&gt;Servlet类Handler,需继承HttpServlet&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;SimpleServletHandlerAdapter&lt;/code&gt;默认是没有的,当需要使用Servlet相关API时使用,需要在配置文件中声明&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleServletHandlerAdapter&quot;/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;注意:当手动添加了适配器后,系统就不会自动添加任何其他适配器了;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;SimpleServletHandlerAdapter案例:&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Controller(&quot;/servletController&quot;)
public class YouController extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.getWriter().println(&quot;servlet API&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求地址:http://localhost:8080/MVC01_war_exploded/servletController,记得注册Adapter到容器中;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在上述4中handler中最常用的是使用注解形式的;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;视图解析器用于查找视图文件,及生成视图对象,我们不用过多关注,唯一会用到的就是,为视图名称配置前缀和后缀从而简化,Handler中的书写&lt;/p&gt;
&lt;p&gt;在一个实际项目中页面文件可能比较多,可以用文件夹管理,但是这导致我们在编写视图名称时更加繁琐,例如:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440878/202002/1440878-20200206230231562-2020727870.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;handler中:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1440878/202002/1440878-20200206230307791-1455648089.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时就可在配置中对视图解析器进行相关设置;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&amp;gt;
  &amp;lt;!--指定视图类型--&amp;gt;
    &amp;lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&amp;gt;
  &amp;lt;!--指定前缀--&amp;gt;
    &amp;lt;property name=&quot;prefix&quot; value=&quot;/pages/jsp/&quot;/&amp;gt;
  &amp;lt;!--指定后缀--&amp;gt;
    &amp;lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;处理器中:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RequestMapping(&quot;/getMsg&quot;)
public ModelAndView getMsg(){
    ModelAndView modelAndView = new ModelAndView();
    modelAndView.setViewName(&quot;index&quot;);
    modelAndView.addObject(&quot;msg&quot;,&quot;hello SpringMVC annotation!&quot;);
    return modelAndView;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;视图解析器会自动在viewName前后分别拼接前缀和后缀;如:&lt;code&gt;/pages/jsp/index.jsp&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;启用mvc-配置&quot;&gt;启用MVC 配置&lt;/h2&gt;
&lt;p&gt;上面提到,SpringMVC默认会加载&lt;code&gt;DispatcherServlet.properties&lt;/code&gt;中的配置作为默认配置,当我们需要添加额外的自定义配置时该怎么办呢?这是我们需要启用MVC配置,通过在配置文件中添加以下标签&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;mvc:annotation-driven/&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了减少配置项,该标签向容器中添加了提供MVC基础服务的Bean,并添加了json,xml,的转换器&lt;/p&gt;
&lt;p&gt;有兴趣可以源码位置:web包下的AnnotationDrivenBeanDefinitionParser,&lt;/p&gt;
&lt;p&gt;此时看不出该标签对系统有什么影响,但在后续自定义验证器,转换器时就不得不使用到该标签了&lt;/p&gt;
&lt;p&gt;官方原话:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;in XML configuration, you can use the `&amp;lt;mvc:annotation-driven/&amp;gt;` element to enable MVC configuration, the preceding example registers a number of Spring MVC infrastructure beans and adapts to dependencies available on the classpath (for example, payload converters for JSON, XML, and others)&quot;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 06 Feb 2020 15:04:00 +0000</pubDate>
<dc:creator>CoderJerry</dc:creator>
<og:description>SpringMVC 框架概述 Spring Web MVC是基于Servlet API构建的传统Web框架，并且从一开始就已包含在Spring框架中 与Spring Web MVC并行，Spring</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yangyuanhu/p/12271415.html</dc:identifier>
</item>
<item>
<title>【WPF学习】第三十章 元素绑定——绑定到非元素对象 - Peter.Luo</title>
<link>http://www.cnblogs.com/Peter-Luo/p/12271243.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Peter-Luo/p/12271243.html</guid>
<description>&lt;p&gt;　　前面章节一直都在讨论如何添加链接两个各元素的绑定。但在数据驱动的应用程序中，更常见的情况是创建从不可见对象中提取数据的绑定表达式。唯一的要求是希望显示的信息必须存储在公有属性中。WPF数据绑定数据结构不能获取私有信息或公有字段。&lt;/p&gt;
&lt;p&gt;　　当绑定到非元素对象时，需要放弃Binding.ElementName属性，并使用以下属性中的一个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;　　&lt;strong&gt;Source&lt;/strong&gt;:该属性是指向源对象的引用——换句话说，是提供数据的对象。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;RelativeSource&lt;/strong&gt;:这是引用，使用RelateSource对象指向源对象。有了这个附加层，可在当前元素（包含绑定表达式的元素）的基础上构建引用。这似乎无谓地增加了复杂程度。但实际上，RelativeSource属性是一种特殊工具，当编写控件模板以及数据模板时很方便的。&lt;/li&gt;
&lt;li&gt;　　&lt;strong&gt;DataContext&lt;/strong&gt;：如果没有使用Source或RelativeSource属性指定源，WPF就从当前元素开始在元素树中向上查找。检查每个元素的DataContext属性，并使用第一个非空的DataContext属性。当我要将同一个对象的多个属性绑定到不同的元素时，DataContext属性是非常有用的，因为可在更高层次的容器对象上（而不是直接在目标元素上）设置DataContext属性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;一、Source属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　Source属性非常简单。唯一的问题是为了进行绑定，需要具有数据对象。在稍后将看到可使用集中方法获取数据对象。可从资源中提取数据对象，可通过编写代码生成数据对象，也可在数据提供的帮助下获取数据对象。&lt;/p&gt;
&lt;p&gt;　　最简单的选择是将Source属性指向一些已经准备好了的静态对象。例如，可在代码中创建一个静态对象并使用该对象。或者，可使用来自.NET类库的组件。如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=Source}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个绑定表达式获取由静态属性SystemFonts.IconFontFamily提供的FontFamily对象（注意，为了设置Binding.Source属性，需要借助静态标记扩展）。然后将Binding.Path属性设置为FontFamily.Source属性，给属性给出了字体家族的名称。结果是一行文本。在Windows Vista或Windows 7中，显示的字体名称segoe UI。&lt;/p&gt;
&lt;p&gt;　　另一种选择是绑定到先前作为资源创建的对象。例如，下面的标记创建指向Calibri字体的FontFamily对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Window.Resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;FontFamily &lt;/span&gt;&lt;span&gt;x:Key&lt;/span&gt;&lt;span&gt;=&quot;CustomFont&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;Calibri&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;FontFamily&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Window.Resources&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　并且下面的TextBlock元素会被绑定到该资源：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Source={StaticResource CustomFont}, Path=Source}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在将会看到文本Calibri。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;二、RelativeSource属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　通过RelativeSource属性可根据相对于目标对象的关系指向源对象。例如，可使用RelativeSource属性将元素绑定到自身或其父元素(不知道在元素树中从当前元素到绑定的父元素到绑定的父元素之间有多少代)。&lt;/p&gt;
&lt;p&gt;　　为设置Binding.RelativeSource属性，需要使用RelativeSource对象，这会使语法变得更加复杂，因为出了需要创建Binding对象外，还需要在其中创建嵌套的RelativeSource对象。一种选择是使用属性设置语法而不是使用Binding标识扩展。例如，下面的代码为TextBlock.Text属性创建了一个Binding对象，这个Binding对象时候用查找父窗口并显示窗口标题的RelativeSource对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock.Text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Binding &lt;/span&gt;&lt;span&gt;Path&lt;/span&gt;&lt;span&gt;=&quot;Title&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Binding.RelativeSource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                                &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;RelativeSource &lt;/span&gt;&lt;span&gt;Mode&lt;/span&gt;&lt;span&gt;=&quot;Findncestor&quot;&lt;/span&gt;&lt;span&gt; AncestorType&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Type Window}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
                        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Binding.RelativeSource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
                &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Binding&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock.Text&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　RelativeSource对象使用FindAncestor模式，该模式告知查找元素树直到发现AncestorType属性定义的元素类型。&lt;/p&gt;
&lt;p&gt;　　编写绑定更常用的方法是使用Binding和RelativeSource标记扩展，将其合并到一个字符串中，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Path=Title,RelativeSource={RelativeSource FindAncestor,AncestorType={x:Type Window}} }&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当创建RelativeSource对象时，FindAncestor模式有4中，下表列出了所有4中模式。&lt;/p&gt;
&lt;p&gt;表 RelativeSourceMode枚举值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/263728/202002/263728-20200206220210950-1310969010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 　　RelativeSource属性看似多余，并且会标记变得复杂。毕竟，为什么不使用Source或Element属性直接绑定到希望使用的源呢？然而，并不总是可以使用Source或ElementName属性，这通常是因为源对象和目标对象在不同的标记块中。当创建控件模板和数据模板时会出现这种情况。例如，如果正在构建改变列表项显示方式的数据模块，可能需要访问顶级ListBox对象以读取属性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三、DataContext属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在某些情况下，会将大量元素绑定到同一个对象。例如，分析下面的一组TextBlock元素，每个TextBlock元素都使用类似的绑定表达式提取与默认图标字体相关的不同细节，包括行间距，以及第一个字体的样式和粗细（这两个都是简单的正则表达式）。可为每个TextBlock元素使用Source属性，但这会使标记变得非常长：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=LineSpacing}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=FamilyTypefaces[0].Style}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Source={x:Static SystemFonts.IconFontFamily}, Path=FamilyTypefaces[0].Weight}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对于这种情况，使用FrameworkElement.DataContext属性一次性定义绑定源会更清晰，也更灵活。在这个示例中，为包含所有TextBlock元素的StackPanel面板设置DataContext属性是合理的（甚至还可在更高层次上设置DataContext属性——例如整个窗口——但是为了使意图更清晰，在尽可能小的范围内进行定义效果更好）。&lt;/p&gt;
&lt;p&gt;　　可使用和设置Binding.Source属性相同的方法设置元素的DataContext属性。换句话说，可提供内联对象，从静态属性中提取，或从资源中提取，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;StackPanel &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;10&quot;&lt;/span&gt;&lt;span&gt; DataContext&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{x:Static SystemFonts.IconFontFamily}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在可通过省略源信息来精简绑定表达式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextBlock &lt;/span&gt;&lt;span&gt;Margin&lt;/span&gt;&lt;span&gt;=&quot;5&quot;&lt;/span&gt;&lt;span&gt; Text&lt;/span&gt;&lt;span&gt;=&quot;&lt;/span&gt;&lt;span&gt;{Binding Path=Source}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;TextBlock&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当在绑定表达式中省略源信息时，WPF会检查元素的DataContext属性。如果属性值为null，WPF会继续向上在元素树中查找第一个不为null的数据上下文（最初，所有元素的DataContext属性都是null）。如果找到了一个数据上下文，就为绑定使用找到的数据上下文。如果没有找到，绑定表达式不会为目标属性应用任何值。&lt;/p&gt;


</description>
<pubDate>Thu, 06 Feb 2020 15:01:00 +0000</pubDate>
<dc:creator>Peter.Luo</dc:creator>
<og:description>前面章节一直都在讨论如何添加链接两个各元素的绑定。但在数据驱动的应用程序中，更常见的情况是创建从不可见对象中提取数据的绑定表达式。唯一的要求是希望显示的信息必须存储在公有属性中。WPF数据绑定数据结构</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Peter-Luo/p/12271243.html</dc:identifier>
</item>
<item>
<title>多线程之CountDownLatch的用法及原理笔记 - 独行侠梦</title>
<link>http://www.cnblogs.com/hyq0823/p/12271402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hyq0823/p/12271402.html</guid>
<description>&lt;h4 id=&quot;前言-countdownlatch是什么&quot;&gt;前言-CountDownLatch是什么？&lt;/h4&gt;
&lt;p&gt;CountDownLatch是具有synchronized机制的一个工具，目的是让一个或者多个线程等待，直到其他线程的一系列操作完成。&lt;/p&gt;
&lt;p&gt;CountDownLatch初始化的时候，需要提供一个整形数字，数字代表着线程需要调用countDown()方法的次数，当计数为0时，线程才会继续执行await()方法后的其他内容。&lt;br/&gt;CountDownLatch(int count);&lt;/p&gt;
&lt;h4 id=&quot;对象中的方法&quot;&gt;对象中的方法&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;getCount：
返回当前的计数count值，&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public void countDown()
调用此方法后，会减少计数count的值。
递减后如果为0，则会释放所有等待的线程&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public void await()
           throws InterruptedException
调用CountDownLatch对象的await方法后。
会让当前线程阻塞，直到计数count递减至0。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果当前线程数大于0，则当前线程在线程调度中将变得不可用，并处于休眠状态，直到发生以下两种情况之一：&lt;/p&gt;
&lt;p&gt;1、调用countDown()方法，将计数count递减至0。&lt;/p&gt;
&lt;p&gt;2、当前线程被其他线程打断。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public boolean await(long timeout,
            TimeUnit unit)
              throws InterruptedException&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时await还提供一个带参数和返回值的方法。&lt;/p&gt;
&lt;p&gt;如果计数count正常递减，返回0后，await方法会返回true并继续执行后续逻辑。&lt;/p&gt;
&lt;p&gt;或是，尚未递减到0，而到达了指定的时间间隔后，方法返回false。&lt;/p&gt;
&lt;p&gt;如果时间小于等于0，则此方法不执行等待。&lt;/p&gt;
&lt;h4 id=&quot;实际案例&quot;&gt;实际案例&lt;/h4&gt;
&lt;h5 id=&quot;join阻塞等待线程完成&quot;&gt;join阻塞等待线程完成&lt;/h5&gt;
&lt;p&gt;首先建立3个线程。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Worker1 implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;-线程1启动&quot;);
        try {
            Thread.sleep(13_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;线程1完成--我休眠13秒\r\n&quot;);
    }
}

public class Worker2 implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;-线程2启动&quot;);
        try {
            Thread.sleep(3_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;线程2完成--我休眠3秒\r\n&quot;);
    }
}

public class Worker3 implements Runnable {
    @Override
    public void run() {
        System.out.println(&quot;-线程3启动&quot;);
        try {
            Thread.sleep(3_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }


        try {
            Thread.sleep(3_000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println(&quot;线程3完成--我休眠6秒\r\n&quot;);
        System.out.println();
    }
}


public class Main {
    public static void main(String[] args) throws InterruptedException {
        Worker1 worker1 = new Worker1();
        Worker2 worker2 = new Worker2();
        Worker3 worker3 = new Worker3();

        Thread thread1 = new Thread(worker1,&quot;线程1&quot;);
        Thread thread2 = new Thread(worker2,&quot;线程2&quot;);
        Thread thread3 = new Thread(worker3,&quot;线程3&quot;);

        thread1.start();
        thread2.start();
        thread3.start();

        thread1.join();
        thread2.join();
        thread3.join();
        System.out.println(&quot;主线程结束....&quot;);

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-线程3启动
-线程2启动
-线程1启动
线程2完成--我休眠3秒
线程3完成--我休眠6秒

线程1完成--我休眠13秒

主线程结束....
Process finished with exit code 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出三个线程是并行执行的。启动顺序，并不和执行完毕的顺序一致，但可以明确的是，主线程为一直阻塞，直到三个线程执行完毕。&lt;/p&gt;
&lt;h5 id=&quot;countdownlatch用法&quot;&gt;CountDownLatch用法&lt;/h5&gt;
&lt;p&gt;阿里巴巴的数据库连接池Druid中也用了countDownLatch来保证初始化。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/894494/202002/894494-20200206225515796-1081561499.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 开启创建连接的线程，如果线程池createScheduler为null，
//则开启单个创建连接的线程
createAndStartCreatorThread();  

 // 开启销毁过期连接的线程
createAndStartDestroyThread(); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;自己编写一个例子：&lt;br/&gt;这里模拟一种情况：&lt;br/&gt;主线程 依赖 线程A初始化三个数据，才能继续加载后续逻辑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/894494/202002/894494-20200206225516044-1472967540.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class CountDownArticle {
    /**
     * 模拟 主线程 依赖 线程A初始化一个数据，才能继续加载后续逻辑
     */
    public static void main(String[] args) throws InterruptedException {
        AtomicReference&amp;lt;String&amp;gt; key = new AtomicReference&amp;lt;&amp;gt;(&quot;&quot;);
        CountDownLatch countDownLatch = new CountDownLatch(3);
            Thread t = new Thread(() -&amp;gt; {
            try {

                //休眠5秒，模拟数据的初始化
                TimeUnit.SECONDS.sleep(5);

                key.set(&quot;核心秘钥123456&quot;);
                System.out.println(&quot;数据1初始化完毕&quot;);

                //释放---此处可以在任何位置调用，很灵活
                countDownLatch.countDown();

                System.out.println(&quot;数据2初始化完毕&quot;);
                countDownLatch.countDown();

                System.out.println(&quot;数据3初始化完毕&quot;);
                countDownLatch.countDown();

            } catch (InterruptedException e) {
                e.printStackTrace();
            }

        });
        t.start();

        //等待数据初始化，阻塞
        countDownLatch.await();
        System.out.println(&quot;key：&quot; + key.get());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;数据1初始化完毕
数据2初始化完毕
数据3初始化完毕
key：核心秘钥123456&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;countdownlatch和join用法的区别&quot;&gt;CountDownLatch和Join用法的区别？&lt;/h4&gt;
&lt;p&gt;在使用join()中，多个线程只有在执行完毕之后欧才能被解除阻塞，而在CountDownLatch中，线程可以在任何时候任何位置调用countdown方法减少计数，通过这种方式，我们可以更好地控制线程的解除阻塞，而不是仅仅依赖于连接线程的完成。&lt;/p&gt;
&lt;p&gt;join()方法的执行逻辑如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/894494/202002/894494-20200206225516296-1156962999.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;原理&quot;&gt;原理&lt;/h4&gt;
&lt;p&gt;从源码可以看出，CountDownLatch是依赖于AbstractQueuedSynchronizer来实现这一系列逻辑的。&lt;/p&gt;
&lt;p&gt;队列同步器AbstractQueuedSynchronizer&lt;br/&gt;是一个用来构建锁和同步器的框架,它在内部定义了一个被标识为volatile的名为state的变量,用来表示同步状态。&lt;/p&gt;
&lt;p&gt;多个线程之间可以通过AQS来独占式或共享式的抢占资源。&lt;/p&gt;
&lt;p&gt;并且它通过内置的FIFO队列来完成线程的排队工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/894494/202002/894494-20200206225516552-399095779.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CountDownLatch中的Sync会优先尝试修改state的值，来获取同步状态。例如，如果某个线程成功的将state的值从0修改为1，表示成功的获取了同步状态。 这个修改的过程是通过CAS完成的，所以可以保证线程安全。&lt;/p&gt;
&lt;p&gt;反之，如果修改state失败，则会将当前线程加入到AQS的队列中，并阻塞线程。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;总结&lt;/h4&gt;
&lt;p&gt;CountDownLatch(int N) 中的计数器，可以让我们支持最多等待N个线程的操作完成，或是一个线程操作N次。&lt;/p&gt;
&lt;p&gt;如果仅仅只需要等待线程的执行完毕，那么join可能就能满足。但是如果需要灵活的控制线程，使用CountDownLatch。&lt;/p&gt;
&lt;h4 id=&quot;注意事项&quot;&gt;注意事项&lt;/h4&gt;
&lt;p&gt;countDownLatch.countDown();&lt;/p&gt;
&lt;p&gt;这一句话尽量写在finally中，或是保证此行代码前的逻辑正常运行，因为在一些情况下，出现异常会导致无法减一，然后出现死锁。&lt;/p&gt;
&lt;p&gt;CountDownLatch 是一次性使用的，当计数值在构造函数中初始化后，就不能再对其设置任何值，当 CountDownLatch 使用完毕，也不能再次被使用。&lt;/p&gt;
&lt;h4 id=&quot;写在最后&quot;&gt;写在最后&lt;/h4&gt;
&lt;p&gt;为了方便大家学习讨论，我创建了一个java疑难攻坚互助大家庭，和其他传统的学习交流不同。本群主要致力于解决项目中的疑难问题，在遇到项目难以解决的&lt;br/&gt;问题时，都可以在这个大家庭里寻求帮助。&lt;/p&gt;
&lt;p&gt;公众号回复【问题的答案】进入：java中Integer包装类的基本数据类型是？&lt;br/&gt;如果你也经历过遇到项目难题，无从下手，&lt;br/&gt;他人有可能可以给你提供一些思路和看法，一百个人就有一百种思路，&lt;br/&gt;同样，如果你也乐于帮助别人，那解决别人遇到的问题，也同样对你是一种锻炼。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;欢迎来公众号【侠梦的开发笔记】，回复干货，领取精选学习视频一份&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Thu, 06 Feb 2020 14:55:00 +0000</pubDate>
<dc:creator>独行侠梦</dc:creator>
<og:description>前言 CountDownLatch是什么？ CountDownLatch是具有synchronized机制的一个工具，目的是让一个或者多个线程等待，直到其他线程的一系列操作完成。 CountDownL</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hyq0823/p/12271402.html</dc:identifier>
</item>
<item>
<title>关于2D渲染的一些小想法 - 落单的毛毛虫</title>
<link>http://www.cnblogs.com/mmc1206x/p/12271307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mmc1206x/p/12271307.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/mmc1993/editor&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;这个项目最初的目的是为了尝试解析现有的ui编辑器mygui导出的ui布局信息通过imgui还原ui渲染但是在开发过程中我发现可以借此实现一个编辑器一个我不断的寻找但始终没有找到的简单易用容易扩展的几何编辑器几何编辑器这个名字可能不太准确我也不知道它应该叫什么我主要用它来实现和验证各种几何相关的图形算法因为它是个人兴趣所致所以前后实现的两个功能可能完全没有关联毕竟我是一个兴趣广泛的人由于这个编辑器的主要目的并不是实现编辑器本身而是在它的基础上实现各种几何算法因此编辑器本身还比较粗糙其实整体都比较粗糙---值得一提的是这个项目没有引入任何第三方渲染库底层的渲染管道是基于opengl纯手工编码&quot;&gt;.　　这个项目最初的目的是为了尝试解析现有的UI编辑器（MyGUI）导出的UI布局信息，通过ImGUI还原UI渲染。但是在开发过程中，我发现可以借此实现一个编辑器，一个我不断的寻找，但始终没有找到的简单易用容易扩展的几何编辑器。“几何编辑器”这个名字可能不太准确，我也不知道它应该叫什么，我主要用它来实现和验证各种几何相关的图形算法，因为它是个人兴趣所致，所以前后实现的两个功能可能完全没有关联，毕竟我是一个兴趣广泛的人。由于这个编辑器的主要目的并不是实现编辑器本身，而是在它的基础上实现各种几何算法，因此编辑器本身还比较粗糙（其实整体都比较粗糙- -|||）。值得一提的是，这个项目没有引入任何第三方渲染库，底层的渲染管道是基于OpenGL纯手工编码。&lt;/h3&gt;
&lt;h3 id=&quot;依赖&quot;&gt;依赖：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;编程语言：C++17&lt;/li&gt;
&lt;li&gt;编译环境：Visual Studio 2019&lt;/li&gt;
&lt;li&gt;第三方库：GLM，ImGUI，stb_image&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;模块&quot;&gt;模块：&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Tips：配置的读取和写入，目前仅支持Json格式&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips：当前支持图片（.jpg，.png），图集（.atlas），Tilemap地图（.map），着色器（.program），SDF字体（.fnt），可序列化对象。资源管理是基于std::weak_ptr/std::share_ptr实现，尽可能的简单易用。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips：全局事件模块&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips：基于ImGUI实现的UI模块，当前已实现控件有：容器框，文本框，输入框，选择框，下拉框，树形框，按钮，菜单，画布。通过UI布局文件自动生成UI对象，统一管理UI事件（包括拖放事件），可动态调整容器大小，支持皮肤更换。其中画布提供了渲染功能，即舞台对象的渲染都将在画布中实现。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips：组件模块和渲染对象都包含在界面中，因为它们都依赖画布，但组件模块占比较高，所以单独提出，它的设计理念可参考Unity3D。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;换肤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206221622798-734292450.gif&quot; alt=&quot;换肤.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;资源搜索&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206221640991-1666935130.gif&quot; alt=&quot;资源搜索.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;舞台基本操作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206221655513-1881788557.gif&quot; alt=&quot;舞台基本操作.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件-文本渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206221711543-558620338.gif&quot; alt=&quot;组件-文本渲染.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件-精灵渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206221757149-2108799923.gif&quot; alt=&quot;组件-精灵渲染.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件-光源渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206221822530-1403113227.gif&quot; alt=&quot;组件-光源渲染.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件-地图渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206221836954-1763755494.png&quot; alt=&quot;组件-地图渲染.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件-曲线渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206221850089-1004494347.gif&quot; alt=&quot;组件-曲线渲染.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件-闪电渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206221908939-499029833.gif&quot; alt=&quot;组件-闪电渲染.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件-精灵变形渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206221934358-456620282.gif&quot; alt=&quot;组件-精灵变形渲染.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件-后期处理渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206222316385-992381645.gif&quot; alt=&quot;组件-后期处理渲染-扭曲.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206222342658-1120119596.gif&quot; alt=&quot;组件-后期处理渲染-漩涡.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件-遮挡剔除渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206222358423-328397802.gif&quot; alt=&quot;组件-遮挡剔除渲染.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件-地形擦出渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/596122/202002/596122-20200206222417568-822937175.gif&quot; alt=&quot;组件-地形擦出渲染.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你对某个实现感兴趣，你可以尝试在这里找到相对详细的细节分析（其实也不太详细）&amp;gt;&amp;gt;&amp;gt; &lt;a href=&quot;https://www.cnblogs.com/mmc1206x/&quot;&gt;博客：落单的毛毛虫&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 06 Feb 2020 14:32:00 +0000</pubDate>
<dc:creator>落单的毛毛虫</dc:creator>
<og:description>&amp;quot;原文地址&amp;quot; 概述 . 这个项目最初的目的是为了尝试解析现有的UI编辑器（MyGUI）导出的UI布局信息，通过ImGUI还原UI渲染。但是在开发过程中，我发现可以借此实现一个编辑器</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mmc1206x/p/12271307.html</dc:identifier>
</item>
<item>
<title>2019年，我花了3个月时间备考PMP - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/12271119.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/12271119.html</guid>
<description>&lt;p&gt;​ 经过几个月的准备，终于在2019年12月7日完成了PMP的考试，并于过年前（过了个好年）查到了成绩，喜获5A,意料之中，总结这次考试的具体情况：涉及题型虽然都没有超出大纲的范围，但是原题出现的概率似乎不高，还有一些原来未曾见过的题目，例如矩阵型组织或弱矩阵型组织等，以及造一个能够能飞三米的纸飞机，存在5%的废品，该如何处理，这样的题目让人有点摸不着头脑，还有一些原题，虽然是模拟题上的题目，但是。。我居然到了考试的时候居然忘记答案了，这有点过于尴尬。&lt;/p&gt;
&lt;h2 id=&quot;为什么考pmp&quot;&gt;为什么考PMP&lt;/h2&gt;
&lt;p&gt;​ 回顾职场，我是在参加工作的第二年成为项目经理的，当时还是啥都不同的毛头小伙，就被公司指派担任一个十几万小项目的项目经理，并和两位老鸟一起共同参与项目的研发，每天都出入XX勘测设计院的大门之中，基本上都认识了这些勘测院的机关工作人员，还好这个项目本身技术并不复杂，加上有足够的资源和不急的时间需求，做出的成果也符合了甲方的需求，所以这个项目总体上处理的还算不错；&lt;/p&gt;
&lt;p&gt;​ 随后又参加了另外一个几十万的小项目，并在其中担任项目经理和技术负责人，由于有了一位资深工程师、一位资深从业者（虽然对编程技术不够了解，但是沟通能力很强）所以这个项目也能如鱼得水。&lt;/p&gt;
&lt;p&gt;​ 再后来同时带了两个项目，一个是XXX规划局的XX信息平台，一个是地下管线系统，同时带两个项目的压力确实很大，而且公司的技术水平其实并不好，这两个都是研发型项目，作为一个开发出生的我，难免很难同时兼顾两个项目，加上地下管线系统其实是有老鸟参与研发设计，而我基本上只用跟需求，而空间信息平台则是我带一些没有工作经验的新手，所以我对于管线系统也就没太放在心上，精力也就全部放在空间信息平台上，所以当项目结项时，虽然两个项目都完成了，但是差别却特别大，空间信息平台广受赞誉，为后来接下数百万的合同奠定了基础，而地下管线系统（其实合同额更高）中的老程序员们却由于被过度放权，反而疏于管理，虽然软件做出来了，但是却没能派上用场，到后来被尘封，只能成为一个经费项目。&lt;/p&gt;
&lt;p&gt;​ 再后来，公司内部组织结构发生了变更，我也进入了一个的高光时期，被选为部门的项目主管，同时兼顾多个项目，负责管理了超过20位项目团队成员，管了3个项目经理。当时的我一度以为是自己的优秀打动了领导，其实是因为公司确实是没人了，才让我临时暂代，然而我还以此为骄傲，最终什么事情都没搞好。&lt;/p&gt;
&lt;p&gt;​ 后来就从这家公司离职，开始了新的职场过程，前前后后也陆陆续续带了不少项目，有大有小，成功或失败，也或多或少有一些。总体上来评价，差强人意，虽然试图做好项目，但是却总感觉阻塞颇多，无论是人员上的，还是技术上，或者沟通上的，总觉得没有特别完美。尤其是做互联网项目时，花了许多时间去打磨产品，却依然没能做出令人眼前一亮的东西，固然与产品有一定的关系，其实也与未能管理领导的预期有更大的关系。&lt;/p&gt;
&lt;p&gt;​ 确实如此，一个成功的项目，首先要管好客户的预期，其次得做好资源的调配。真正好的项目经理，一定是那些看起来很闲的项目经理，因为他们把什么事情都能很好的规划，只是做好任务分配、任务审查、和任务总结以及汇报就够了，而像过去的我那样的渣项目经理，不仅事无巨细、连代码要管，衣食住行要管，还让大家累死累活下来也根本没赚到多少钱。&lt;/p&gt;
&lt;p&gt;​ 在IT领域，不仅软件开发有德雷福斯的能力成熟度模型，连项目经理也同样具备，同样必须经过一万小时，经过从新手到高级新手，到胜任者，精通者，到专家的蜕变，而这个过程，要么必须吃了很多亏（意味着要花费公司大量的人力物力财力来培养），要么就是能够真正自发成为专业的项目管理者。&lt;/p&gt;
&lt;p&gt;​ 事实上专业的项目管理者比开发者或许更困难，在我从业的这十年中，也遇到了个别优秀的项目经理，他们善于运用领导力的强大魄力，在项目各方间游刃有余，而更多的项目经理，都像我一样，运用程序员的沟通技巧，与各方沟通，往往会吃尽苦头。&lt;/p&gt;
&lt;p&gt;​ 技术出生的管理者，往往都具备类似的毛病：例如过度在意过程和实现；忽略沟通的力量；渴望全局掌控；缺乏领导艺术；缺乏政治敏感度；藐视人情世故等。好吧，在后来的项目过程中，我已经逐步掌握了沟通、政治敏感度和人情世故这样的法宝，并通过这种手段获得过各方的认同，但是还是或多或少在乎细节、在乎流程的完备性，反而忽略了对于客户预期的把控，最终依然造出了几个不太成果的项目。&lt;/p&gt;
&lt;p&gt;​ 一个人的成长，大概就是得经历从失败的挫折、吸取教训、逐渐成长的过程，无论是哪个岗位都大体类似。优秀的项目管理能力一定是开发者的必备基础技能，唯有灵活的掌握项目管理技能的多个方面，才能让软件项目能够高效、快速的契合各方的需求，实现组织从一种状态到另外一种状态。&lt;/p&gt;
&lt;p&gt;​ 如果说以前带的项目，基本上已经到了胜任者的层级，那么大概这种层级，其实是自封的，如何来真正证明自己具备\胜任相关岗位呢，我觉得大概需要一个纸质证明了。这就是我打算考PMP的原因。&lt;/p&gt;
&lt;h2 id=&quot;为什么选择培训班&quot;&gt;为什么选择培训班&lt;/h2&gt;
&lt;p&gt;​ 不过考PMP有很多种方式，而且PMP本身也不是一种特别困难的资格证，在我的身边已经有许多人考了PMP，并获得了证书，甚至有许多人拿到了5A证书，例如我参加的培训班，5A率已经超过70%了。&lt;/p&gt;
&lt;p&gt;​ 而在国内，每种证书最常见的质疑是，考这个有用么？我倒是觉得，有没有用先不管，至少学到知识的过程就一定值得花这点钱。知识的价值，也并非那些可以用直接卖多少钱来衡量，他其实是一点一滴深入你的骨肉，并最终构成你的灵魂，并且在需要体现价值的时候，一点一点的凸显出来。&lt;/p&gt;
&lt;p&gt;​ 除此之外，我也感觉虽然考试范围就是在PMBOOK这本书，而且只考前538页，但是书本上有太多内容了，每一个点都能够写出许多许多的故事出来，甚至而言，把五大过程，四十九过程组中，任意抽出一个过程组出来专精，都可以成为一个称职的专家，所以纯粹看书其实并不能提高自己对于项目管理技能的领悟力，而那些能够给我们提供培训的老师，他们往往首先是真正优秀的项目经理。其次不仅对项目管理这一本砖头书要烂熟于心，也需要能够用自己的语言把枯燥无味、干涩的知识讲出花来，这更需要本事。&lt;/p&gt;
&lt;p&gt;​ 再加上项目管理这种管理体系，其实更是一种团队技能，靠自己看书，往往找不到重点，而借助于培训机构，反而能够跟其他具有相同爱好的人一起学习，也算是一段不错的过程。&lt;/p&gt;
&lt;p&gt;​ 选择现代卓越面授班对我来说确实是个非常明智的决定，因为面授班确实是这样的好地方，大家一起讨论项目管理方面的问题，着实是一种不错的体验。&lt;/p&gt;
&lt;h2 id=&quot;通过培训获得的收获&quot;&gt;通过培训获得的收获&lt;/h2&gt;
&lt;p&gt;​ 近年来随着离软件公司越来越远，离各种行业软件越来越近，觉得自己的项目管理能力的某些方面诸如沟通表达能力和领导力有所提升，但是对于项目管理过层中的计划管理能力反而已经越来越差了。毕竟原来一直从事IT技术研发+项目管理，对于时间的计划安排，无外乎就是按照自己的经验去套、或者借助于模仿，这是初学者的典型惯例。&lt;/p&gt;
&lt;p&gt;​ 除此之外，在项目中，虽然用到了瀑布模型这种预测性生命周期来管理项目，但是又接触到许多敏捷的项目管理方法，所以技能点反而不纯粹了，总结就是，什么都懂一点，却什么都只懂一点，所以专业级项目经理是如何做项目的？这确实是一个值得仔细讨论的问题。而这也是参加培训最大的收获。&lt;/p&gt;
&lt;p&gt;​ 总结一下可以为我未来做项目提供指导的一些点：&lt;/p&gt;
&lt;p&gt;1、需求的重要-紧急矩阵：评估需求时，先把重要紧急矩阵画好，然后再来指导工作。以前难道不知道么，确实没这么系统的学习这套理论吧。&lt;/p&gt;
&lt;p&gt;2、权力-利益方格、相关方认知模型、相关方参与度评估矩阵：&lt;/p&gt;
&lt;p&gt;3、能力-欲望矩阵：有能力有欲望、有能力没欲望、没能力有欲望、没能力没欲望，你在哪个象限？值得深思。&lt;/p&gt;
&lt;p&gt;4、成本管理：老板的钱来之不易，成本管理得做好。&lt;/p&gt;
&lt;p&gt;6、三大管理学原理：彼得原理、帕金森定律和墨菲定律，大概可以好好讲一天。&lt;/p&gt;
&lt;p&gt;7、如何做好团队激励和团队建设：哪些是保健因素，哪些是激励因素，如何打造一支优秀的团队？知易行难啊。&lt;/p&gt;
&lt;p&gt;9、风险责任矩阵RBS:提前做好风险评估和责任人分配，让风险防范于未然很有必要。&lt;/p&gt;
&lt;p&gt;10、问题日志、经验教训登记册、风险登记册和营造积极分享的氛围。&lt;/p&gt;
&lt;p&gt;11、会议管理：罗伯特议事规则。开会太长确实需要规则。&lt;/p&gt;
&lt;p&gt;12、关键链法：盲目的设定项目工作包或活动其实没什么意义，倒不如先做好关键链，然后再逐步的实现里程碑，只要关键链做好了，往往也离项目做完不远了。毕竟一个项目是花有限的资源做有限的事，而不是无穷尽的盲目的投入。&lt;/p&gt;
&lt;p&gt;13、挣值分析技术：虽然挣值分析技术是一种数学评估方法，看起来有点不太精准，但是将这种技术高效的运用到项目中，也许会给项目管理带来不少便利。&lt;/p&gt;
&lt;p&gt;14、责任分解矩阵：做好工作分解和责任分解固然重要，更要给责任人指派明确的责任，而不是口头上的任命，做到有根有据，有考核指标和评价依据非常重要。&lt;/p&gt;
&lt;p&gt;15、塔克曼团队发展阶段理论：一个团队的成长早期，往往是相互独立、甚至互相提防的，只有互相磨合，经历开诚布公，才能打造成熟稳定的团队。&lt;/p&gt;
&lt;p&gt;16、TEAM团队理论：Today Everyone Achive More。没有完美的个人，只有完美的团队。团队并非一个人、而是大家彼此拿出自己最擅长的方面，共同打造一个完美的群体。&lt;/p&gt;
&lt;p&gt;17、冲突管理：团队中适度的沟通反而能够促进团队关系的更加融洽。而没有冲突的团队往往是一滩死水，有了冲突，各方才能更好的理解对方的思维模式和思考方式，进而促进团队的进一步完善。&lt;/p&gt;
&lt;p&gt;18、沟通的漏斗效应：是沟通就一定会衰减，但是如何让衰减尽可能的减小、控制在一定的范围呢。这大概需要更加重视沟通相关方的影响力。&lt;/p&gt;
&lt;p&gt;​ 当然，实际上还有更多内容，只是以上几点特别熟悉，整个PMP的考试过程确实给我带来了不少启发，我也希望以后能够逐步的把pmp中学到的一些知识应用到项目和团队管理中，并渴望能够带来效率上的提升。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;​ 好吧， 说那么多，我尽力了，是真的尽力了么，我完全还可以更努力啊。&lt;/p&gt;
&lt;p&gt;​ 当然，深受帕金森定律的影响，能够提前学的东西，到最后一天才学，不过庆幸自己的努力没有白费，相信一份付出，总有一份回报。&lt;/p&gt;
</description>
<pubDate>Thu, 06 Feb 2020 13:57:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>引子​ ​ 经过几个月的准备，终于在2019年12月7日完成了PMP的考试，并于过年前（过了个好年）查到了成绩，喜获5A,意料之中，总结这次考试的具体情况：涉及题型虽然都没有超出大纲的范围，但是原题出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/12271119.html</dc:identifier>
</item>
<item>
<title>从O365中获取users到D365中  使用flow - TheMiao</title>
<link>http://www.cnblogs.com/TheMiao/p/12270949.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TheMiao/p/12270949.html</guid>
<description>&lt;p&gt;在我上篇blog中讲解到了怎么用代码把O365 users 获取到D365中. &lt;a class=&quot;entry&quot; href=&quot;https://www.cnblogs.com/TheMiao/p/12249074.html&quot; target=&quot;_blank&quot;&gt;从O365中获取users到D365中&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;这几天一直在研究flow, 发现flow可以更简单的完成这个功能. 一开始没有考虑用flow是因为flow获取所有用户的方式比较困难, 需要有个workaround (首先需要把所有用户添加到一个group当中,然后获取group member list)&lt;/p&gt;

&lt;p&gt;首先我们需要使用Search for users (v2) &lt;/p&gt;
&lt;p&gt;只有V2 版本可以直接获取所有的users 在一个list当中.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/961194/202002/961194-20200206210130439-1422308713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;下面我们需要对这个action做下设置, 打开pagination. 在web api中, 一个user request最多只能显示999条数据. 所以打开pagination 可以获取到大于999的数据.&lt;/p&gt;
&lt;p&gt;在下面的threshold我们需要设置显示多少条数据的数字.  这个数字需要大于所有的O365用户数.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/961194/202002/961194-20200206210202028-1628301934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/961194/202002/961194-20200206210218482-1247104443.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;我们create record之前, 我们需要做个检查. 如果用户信息已经保存在CRM中,则不需要再次保存,所以我们需要做一个检查.&lt;/p&gt;
&lt;p&gt;这里我们不用选apply to each 这个action, 选择 dynamics 365 -&amp;gt; List records 之后会直接生成apply to each. 我们需要在list records 选择 Org, entity.&lt;/p&gt;
&lt;p&gt;下一步我们要做检查, 我们这里可以使用 user principle name(UPN)来做检查. emailaddress 是在 entity中对应 UPN的字段, 所以在filter query中 我们需要些 emailaddress eq 'UPN'  这里要注意,  UPN需要从Dynamic content中选中, 并且需要单引号括住. &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/961194/202002/961194-20200206211208480-1741221871.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;




&lt;p&gt;接下来我们需要用一个condition的action来判断是否需要创建 new record&lt;/p&gt;
&lt;p&gt;判断条件可以用empty() formula来检查List records 是否为空,&lt;/p&gt;
&lt;p&gt;如果为空&lt;/p&gt;
&lt;p&gt;　　 则创建新record&lt;/p&gt;
&lt;p&gt;如果不为空&lt;/p&gt;
&lt;p&gt;　　则不创建新record&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/961194/202002/961194-20200206211659433-1180510108.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 06 Feb 2020 13:19:00 +0000</pubDate>
<dc:creator>TheMiao</dc:creator>
<og:description>在我上篇blog中讲解到了怎么用代码把O365 users 获取到D365中.&amp;#160;从O365中获取users到D365中 这几天一直在研究flow, 发现flow可以更简单的完成这个功能. 一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/TheMiao/p/12270949.html</dc:identifier>
</item>
</channel>
</rss>