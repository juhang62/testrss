<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title> 哇咔咔干货来啦：PowerJob 原理剖析之 Akka Toolkit - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13394122.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13394122.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文适合有 Java 基础知识的人群&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200728215603789-477620477.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：HelloGitHub-&lt;strong&gt;Salieri&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HelloGitHub 推出的&lt;a href=&quot;https://github.com/HelloGitHub-Team/Article&quot;&gt;《讲解开源项目》&lt;/a&gt;系列。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Akka is a toolkit for building highly concurrent, distributed, and resilient message-driven applications for Java and Scala.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这段文字摘抄自 Akka 官网（akka.io），翻译成中文也就是：“Akka 是一个为 Java 和 Scala 构建高并发、分布式和弹性消息驱动应用程序的工具包”。而 Akka 具有的一切特性，其实都源自于一个用于处理并发计算问题的模型——Actor 模型。&lt;/p&gt;
&lt;blockquote readability=&quot;2.0833333333333&quot;&gt;
&lt;p&gt;PowerJob 项目地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/KFCFans/PowerJob&quot;&gt;https://github.com/KFCFans/PowerJob&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、actor-模型&quot;&gt;一、Actor 模型&lt;/h2&gt;
&lt;p&gt;Actor 模型在 1973 年于 Carl Hewitt、Peter Bishop 及 Richard Steiger 的论文中提出，现在已经被用作并发计算的理论理解框架和并发系统的实际实现基础。&lt;/p&gt;
&lt;p&gt;在计算机科学中，Actor 模型是一种并发运算上的模型。Actor 是一种程序上的抽象概念，被视为并发运算的基本单元：当一个 Actor 接收到一则消息，它可以做出一些决策、创建更多的 Actor 、发送更多的消息、决定要如何处理接下来的消息。Actors 可以修改它们自己的私有状态，但是只能通过消息间接的相互影响（避免了基于锁的同步）。&lt;/p&gt;
&lt;p&gt;每一个 Actor 都由状态（State）、行为（Behavior）和邮箱（MailBox，其实就是一个消息队列）三部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态：Actor 中的状态指 Actor 对象的变量信息，状态由 Actor 自己管理，避免了并发环境下的锁和内存原子性等问题。&lt;/li&gt;
&lt;li&gt;行为：Actor 中的计算逻辑，通过 Actor 接收到的消息来改变 Actor 的状态。&lt;/li&gt;
&lt;li&gt;邮箱：邮箱是 Actor 和 Actor 之间的通信桥梁，邮箱内部通过 FIFO（先入先出）消息队列来存储发送方 Actor 消息，接受方 Actor 从邮箱队列中获取消息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200728215618731-1227365102.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面说了一大堆晦涩难懂的概念，相信大家看的也都云里雾里的。这里结合我自己的理解用白话文讲一下：其实 Actor 模型的设计思想就是事件驱动，可以简单理解为线程级的消息中间件。所有 Actor 之间不共享数据，只通过消息沟通，因此不用关心传统并发程序编写过程中的并发安全问题（因为根本没有共享的数据）。同时，得益于 Actor 底层轻巧的设计（这部分其实属于具体实现了，不过目前所有的实现 Actor 设计都很轻量），使得单机可以存在百万量级的 Actor，因此能够带来极好的并发性能。&lt;/p&gt;
&lt;p&gt;此外，由于 Actor 模型中万物都是 Actor，所以它是天然支持分布式的，即不同机器之间的 Actor 通讯和本地 Actor 之间的通讯没有实质上的区别。&lt;/p&gt;
&lt;p&gt;因此，只要你掌握了事件驱动的编程思想，利用 Actor 模型，结合具体的实现框架（比如 JVM 系的 Akka），能够轻松编写出高性能的分布式应用。&lt;/p&gt;

&lt;p&gt;Akka Toolkit 也就是 Akka 工具包，其实就是 JVM 平台上对 Actor 模型的一种实现。Akka 本身提供了完整的 Actor 模型支持，包括对并发/并行程序的简单的、高级别的抽象、异步、非阻塞、高性能的事件驱动编程模型和非常轻量的事件驱动处理。同时，作为一个“工具包”，Akka 还额外提供了许多功能，由于篇幅有限，这里就简单介绍几个包，有兴趣可以前往官网（见参考文档）详细了解～&lt;/p&gt;
&lt;ul readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;akka-streams：流处理组件，提供直观、安全的方式来进行异步、非阻塞的背压流处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;akka-http：HTTP 组件，现代、快速、异步、流媒体优先的 HTTP 服务器和客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;akka-cluster：集群组件，包括集群成员管理、弹性路由等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;akka-remote(artery-remoting)：通讯组件，也是 PowerJob 所使用的核心组件，然而官网并不推荐直接使用（直接使用 remote 启动还会警告使用了过于底层的 API），普通分布式应用推荐直接使用 cluster。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;akka-persistence：持久化组件，提供“至少投递一次”的能力来保证消息的可靠送达。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、akka-简单使用&quot;&gt;三、Akka 简单使用&lt;/h2&gt;
&lt;p&gt;接下来是关于 Akka 的一个超简明教程，帮助大家初步理解并入门 Akka，其内容涵盖了所有 PowerJob 中用到的 API，也就是说，看懂这部分，源码中的 Akka 就不再可怕喽～&lt;/p&gt;
&lt;h3 id=&quot;31-开发-actor&quot;&gt;3.1 开发 Actor&lt;/h3&gt;
&lt;p&gt;首先，不得不提的一点是，Akka 从 2.6 版本开始，维护了 2 套 API（算上 Scala 和 Java 版本就 4 套了...看着IDE的智能提示就头大...），分别叫 classic 和 typed。typed 与原先的 classic 相比，最大的特色就是其具有了类型（Java 范型）。每一个 Actor 处理的消息类型可以直接由范型规定，从而有效限制程序 bug（将错误从运行期提前到了编译期）。然而，对于复杂系统要处理的消息不胜枚举，强类型就限制了一个 Actor 只能处理一种类型的消息。虽然从逻辑上来讲确实清晰，但实际工程实现中，必然导致代码阅读困难，整体结构松散（个人感觉这一点也是计算机科学与工程之间存在分歧的表现，当然也可能是我学艺不精，不了解正确的用法）。解释了那么多，终于可以点明主旨了～作者比较喜欢 classic，因此 PowerJob 只使用 AKKA classic API，本文也只涉及 AKKA classic API，反正官网说了会长期维护～&lt;/p&gt;
&lt;p&gt;前面说过，对于 Actor 模型个人认为最简单的理解方式就是消息中间件。Actor 的本质是事件驱动，即接收消息并处理。反映到编程上，Actor 的开发也类似于消息中间件 consumer 的开发，无非是换了个接口、多几个功能罢了。&lt;/p&gt;
&lt;p&gt;话不多说，看代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class FriendActor extends AbstractActor {
  
    @Override
    public Receive createReceive() {
        return receiveBuilder()
                .match(Ping.class, this::onReceivePing)
                .matchAny(obj -&amp;gt; log.warn(&quot;unknown request: {}.&quot;, obj))
                .build();
    }

    private void onReceivePing(Ping ping) {
        getSender().tell(AskResponse.succeed(null), getSelf());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先自然是新建类并实现接口 &lt;code&gt;AbstractActor&lt;/code&gt;，该接口需要重写 &lt;code&gt;createReceive&lt;/code&gt; 方法，该方法需要一个 &lt;code&gt;Receive&lt;/code&gt; 对象作为返回值。对于开发者而言，需要做的就是构建这个 &lt;code&gt;Receive&lt;/code&gt; 对象，也就是指明该 Actor 接受到什么类型的消息时进行什么样的处理。&lt;/p&gt;
&lt;h3 id=&quot;32-初始化-actorsystem&quot;&gt;3.2 初始化 ActorSystem&lt;/h3&gt;
&lt;p&gt;Actor 作为处理消息的“角色”，就像工厂中的一个个工人，每个人各司其职，兢兢业业地接收指令完成任务。然而群龙不能无首，就像现实生活中工人需要由工厂来组织管理一样，Actor 也需要自己的工厂—— ActorSystem。为此，创建 Actor 之前，首先需要创建 ActorSystem。&lt;/p&gt;
&lt;p&gt;PowerJob 使用以下方法创建 ActorSystem。其中，第一个参数指明了该 ActorSystem 的名称，第二个参数则传入了该 ActorSystem 所使用的配置信息，包括工作端口、序列化方式、日志级别等。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;actorSystem = ActorSystem.create(&quot;powerjob-server&quot;, akkaConfig);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完成 ActorSystem 这个“工厂”的创建后，就可以正式开始创建 Actor 了，代码如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;actorSystem.actorOf(Props.create(FriendActor.class), &quot;friend_actor&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，第一个参数Props是一个用来在创建 Actor 时指定选项的配置类；&lt;/p&gt;
&lt;p&gt;第二个参数则指定了该 Actor 的名称，通过该 Actor 的名称和其 ActorSystem 的名称，我们就可以构建出路径 &lt;code&gt;akka://powerjob-server/user/server_actor&lt;/code&gt;（本地路径，远程路径需要变更协议并添加地址），然后轻松得根据该路径找到该 Actor，实现通信。&lt;/p&gt;
&lt;h3 id=&quot;33-信息交互&quot;&gt;3.3 信息交互&lt;/h3&gt;
&lt;p&gt;完成 ActorSystem 的初始化和 Actor 的创建后，就可以正式使用 Akka 框架了。PowerJob 主要使用 Akka 框架的 remote 组件，用于完成系统中各个分布式节点的通讯。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;String actorPath = &quot;akka://powerjob-server@192.168.1.1/user/friend_actor&quot;;
ActorSelection actorSelect = actorSystem.actorSelection(actorPath);
actorSelect.tell(startTaskReq, null);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和其他通讯方式一样，进行通讯前，需要首先获取目标地址。根据 akka-remote 的语法规范，指定目标 Actor 的名称、其所在的 ActorSystem 名称和目标机器地址，即可获取用于通讯的 URI。得到 URI 后，便可通过 &lt;code&gt;actorselection()&lt;/code&gt; 方法获取 Actorselection 对象。通过 Actorselection 对象，调用 tell 方法就可以向目标 Actor 发送消息了。&lt;/p&gt;
&lt;p&gt;那么细心的小伙伴肯定要问了，PowerJob 之所以采用 akka-remote 作为底层通讯框架，是看上了它极简的通讯 API，看到这里，也没发现有多简单啊。发送一个 HTTP 请求，用高层封装库其实也就差不多三行代码的样子，你这用个 Akka 前置准备工作还那么多，说好的简单呢？那么下面就带大家来一探究竟，akka-remote 到底简单在哪里～&lt;/p&gt;
&lt;p&gt;首先，如果不选择现有的协议，自己用 Netty 造轮子，那光 server、client、listener、codec 就一大堆代码了。如果使用现有协议如 HTTP，发送也许 3 行代码能搞定，但接收一定远不止三行。HTTP 全称超文本传输协议，那么传输的自然已经是经过序列化的文本数据了，所以接收方需要自行进行解码、解析，更别提异常处理、失败重试等功能了。而 akka-remote 呢？从刚刚 Actor 的代码中可以看出，match 方法后面跟的是一个具体的类，也就是说 Akka 自动帮你完成了反序列化，作为消息的接收方，是真正的拿到就能用，没有任何多余代码。同时，Akka 已经帮你搞定了各种异常后的处理。也就是说，使用 akka-remote，可以让数据接收方非常的简单，只专注逻辑的实现。&lt;/p&gt;
&lt;p&gt;其次，在分布式环境中，通讯往往不是单向的。尤其是 PowerJob 这种追求高可用的框架，有时候为了确认消息送达，往往需要应答机制。akka-remote 提供了难以置信的 API 来回复请求：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;AskResponse response = new AskResponse(true, &quot;success&quot;);
getSender().tell(response, getSelf());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;getSender()&lt;/code&gt; 方法，就能获取到消息发送方的 Actor 引用对象，并通过该对象回复信息。&lt;/p&gt;
&lt;h2 id=&quot;四、最后&quot;&gt;四、最后&lt;/h2&gt;
&lt;p&gt;那么以上就是本篇文章全部的内容啦～&lt;/p&gt;
&lt;p&gt;通过本篇文章，我相信大家已经了解了 Actor 模型的基础概念，同时掌握了 JVM 上 Actor 模型的实现——Akka 框架的简单使用。&lt;/p&gt;
&lt;p&gt;下一篇文章，就是万众期待的 PowerJob 调度层原理分析啦（小伙伴进群必问榜 TOP 1）～我将会为大家揭秘是什么支撑着 PowerJob 的调度，让我能放肆“吹牛”说调度性能秒杀现有一切框架～&lt;/p&gt;
&lt;p&gt;那我们下期再见喽～拜拜～&lt;/p&gt;
&lt;h2 id=&quot;五、参考文献&quot;&gt;五、参考文献&lt;/h2&gt;
&lt;h2 id=&quot;作者游记&quot;&gt;作者游记&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/xueweihan/p/2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200728215645808-2049670671.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放（作者在 Java 群），添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202007/759200-20200706214622307-1765002891.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 29 Jul 2020 00:18:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>本文适合有 Java 基础知识的人群 作者：HelloGitHub-Salieri HelloGitHub 推出的《讲解开源项目》系列。 Akka is a toolkit for building</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13394122.html</dc:identifier>
</item>
<item>
<title>优先队列和堆排序 - Ruby_Lu</title>
<link>http://www.cnblogs.com/afei-24/p/13375584.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/afei-24/p/13375584.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　优先队列&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将它们排序。很多情况下是收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素。这种情况下，需要的数据结构支持两种操作：删除最大的元素和插入元素。这种数据结构类型叫优先队列。&lt;/p&gt;

&lt;p&gt;　　这里，优先队列基于二叉堆数据结构实现，用数组保存元素并按照一定条件排序，以实现对数级别的删除和插入操作。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 　　1.API&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　优先队列是一种抽象数据类型，它表示了一组值和对这些值的操作，抽象层使应用和实现隔离开来。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202007/984232-20200726100050195-1733495804.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　2.初级实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　1.无序数组实现&lt;/p&gt;
&lt;p&gt;　　　　　　优先队列的 insert 方法和下压栈的 push 方法一样。删除最大元素时，遍历数组找出最大元素，和边界元素交换。&lt;/p&gt;
&lt;p&gt;　　　　2.有序数组实现&lt;/p&gt;
&lt;p&gt;　　　　　　插入元素时，将较大的元素向右移一格（和插入排序一样）。这样删除时，就可以直接 pop。&lt;/p&gt;
&lt;p&gt;　　　　使用链接也是一样的逻辑。&lt;/p&gt;
&lt;p&gt;　　这些实现总有一种操作需要线性级别的时间复杂度。使用二叉堆可以保证操作在对数级别的时间完成。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　3.堆的定义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　数据结构二叉堆可以很好地实现优先队列地基本操作。在二叉堆数组中，每个元素都要保证大于等于另两个特定位置地元素。同样，这两个位置地元素又至少要大于等于数组中另外两个元素，以此类推。用二叉树表示：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202007/984232-20200726103247175-1966500748.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当一棵二叉树的每个结点都大于等于它的两个子节点时，它被成为堆有序。从任意结点向上，都能得到一列非递减的元素；从任意结点向下，都能得到一列非递增的元素。根结点是堆有序的二叉树中最大的结点。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　二叉堆表示法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这里使用完全二叉树表示：将二叉树的结点按照层级顺序（从上到下，从左往右）放入数组中，不使用数组的第一个位置（为了方便计算），根结点在位置 1 ，它的子结点在位置 2 和 3，子结点的子结点分别在位置 4，5，6，7，一次类推。&lt;/p&gt;
&lt;p&gt;　　在一个二叉堆中，位置 k 的结点的父节点位置在 k/2，而它的两个子结点在 2k 和 2k + 1。可以通过计算数组的索引而不是指针就可以在树中上下移动。&lt;/p&gt;
&lt;p&gt;　　一棵大小为 N 的完全二叉树的高度为 lgN。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　4.堆的算法&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　用长度为 N+1 的私有数组 pq[ ]  表示一个大小为 N 的堆。&lt;/p&gt;
&lt;p&gt;　　堆在进行插入或删除操作时，会打破堆的状态，需要遍历堆并按照要求将堆的状态恢复。这个过程称为 堆的有序化。&lt;/p&gt;
&lt;p&gt;　　堆的有序化分为两种情况：当某个结点的优先级上升（或在堆底加入一个新的元素）时，需要由下至上恢复堆的顺序；当某个结点的优先级下降（例如将根节点替换为一个较小的元素），需要由上至下恢复堆的顺序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　上浮（由下至上的堆的有序化）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当某个结点比它的父结点更大时，交换它和它的父节点，这个结点交换到它父节点的位置。但有可能比它现在的父节点大，需要继续上浮，直到遇到比它大的父节点。（这里不需要比较这个子结点和同级的另一个子结点，因为另一个子结点比它们的父结点小）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上浮&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Swim(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
        {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (n &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; Less(n / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;, n))
            {
                Exch(n&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,n);
                n &lt;/span&gt;= n / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202007/984232-20200727075702145-1647789596.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　下沉（由上至下的堆的有序化）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　当某个结点  k 变得比它的两个子结点（2k 和 2k+1）更小时，可以通过将它和它的两个子结点较大者交换来恢复堆有序。交换后在子结点处可能继续打破堆有序，需要继续重复下沉，直到它的子结点都比它小或到达底部。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;下沉&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Sink(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k)
        {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;2&lt;/span&gt; * k &amp;lt;=&lt;span&gt; N)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; k;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取最大的子节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (j &amp;lt; N &amp;amp;&amp;amp; Less(j, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
                    j&lt;/span&gt;++&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果父节点不小子节点，退出循环&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Less(k,j))
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则交换，继续下沉&lt;/span&gt;
&lt;span&gt;                Exch(j,k);
                k &lt;/span&gt;=&lt;span&gt; j;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202007/984232-20200728073333381-683056103.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　知道了上浮和下沉的逻辑，就可以很好理解在二叉堆中插入和删除元素的逻辑。&lt;/p&gt;
&lt;p&gt;　　插入元素：将新元素加到数组末尾，增加堆的大小并让这个新元素上浮到合适的位置。&lt;/p&gt;
&lt;p&gt;　　删除最大元素：从数组顶端（即 pq[1]）删除最大元素，并将数组最后一个元素放到顶端，减少数组大小并让这个元素下沉到合适位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MaxPriorityQueue
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IComparable[] pq;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; N;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MaxPriorityQueue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxN)
        {
            pq &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; IComparable[maxN+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsEmpty()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; N == &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Insert(IComparable value)
        {
            pq[&lt;/span&gt;++N] =&lt;span&gt; value;
            Swim(N);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IComparable DeleteMax()
        {
            IComparable max &lt;/span&gt;= pq[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            Exch(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,N--&lt;span&gt;);
            pq[N &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            Sink(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下沉&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Sink(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; k)
        {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;2&lt;/span&gt; * k &amp;lt;=&lt;span&gt; N)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; k;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取最大的子节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (j &amp;lt; N &amp;amp;&amp;amp; Less(j, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
                    j&lt;/span&gt;++&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果父节点不小子节点，退出循环&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Less(k,j))
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则交换，继续下沉&lt;/span&gt;
&lt;span&gt;                Exch(j,k);
                k &lt;/span&gt;=&lt;span&gt; j;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上浮&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Swim(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
        {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (n &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; Less(n / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;, n))
            {
                Exch(n&lt;/span&gt;/&lt;span&gt;2&lt;/span&gt;&lt;span&gt;,n);
                n &lt;/span&gt;= n / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Exch(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j)
        {
            IComparable temp &lt;/span&gt;=&lt;span&gt; pq[i];
            pq[i] &lt;/span&gt;=&lt;span&gt; pq[j];
            pq[j] &lt;/span&gt;=&lt;span&gt; temp;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Less(&lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; pq[i].CompareTo(pq[j]) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202007/984232-20200728074047990-2140574841.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　上述算法对优先队列的实现能够保证插入和删除最大元素这两个操作的用时和队列的大小成对数关系。&lt;/strong&gt;这里省略了动态调整数组大小的代码，可以参考&lt;a href=&quot;https://www.cnblogs.com/afei-24/p/13168660.html&quot; target=&quot;_blank&quot;&gt;下压栈&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;　　对于一个含有 N 个元素的基于堆的优先队列，插入元素操作只需要不超过（lgN + 1）次比较，因为 N 可能不是 2 的幂。删除最大元素的操作需要不超过 2lgN次比较（两个子结点的比较和父结点与较大子节点的比较）。&lt;/p&gt;
&lt;p&gt;　　对于需要大量混杂插入和删除最大元素的操作，优先队列很适合。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　改进&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　&lt;/strong&gt;1. 多叉堆&lt;/p&gt;
&lt;p&gt;　　　　基于数组表示的完全三叉树：对于数组 1 至 N 的 N 个元素，位置 k 的结点大于等于位于 3k-1, 3k ,3k +1 的结点，小于等于位于 （k+1）/ 3 的结点。&lt;/p&gt;

&lt;p&gt;　　　　2.调整数组大小&lt;/p&gt;
&lt;p&gt;　　　　使用动态数组，可以构造一个无需关注队列大小的优先队列。可以参考&lt;a href=&quot;https://www.cnblogs.com/afei-24/p/13168660.html&quot; target=&quot;_blank&quot;&gt;下压栈&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;　　　　&lt;span&gt;3.索引优先队列&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;span&gt;在许多应用程序中，允许客户端引用优先级队列中已经存在的项目是有意义的。&lt;/span&gt;&lt;span&gt;一种简单的方法是将唯一的整数索引与每个项目相关联。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202007/984232-20200728200612997-1207338860.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　堆排序&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们可以把任意优先队列变成一种排序方法：先将所有元素插入一个查找最小元素的优先队列，再重复调用删除操作删除最小元素来将它们按顺序删除。这种排序成为&lt;strong&gt;堆排序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　　堆排序的第一步是堆的构造，第二步是下沉排序阶段。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　1.堆的构造&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　简单的方法是利用前面优先队列插入元素的方法，从左到右遍历数组调用 Swim 方法（由上算法所需时间和 N logN 成正比）。一个更聪明高效的方法是，从右（中间位置）到左调用 Sink 方法，只需遍历一半数组，因为另一半是大小为 1 的堆。&lt;strong&gt;这种方法只需少于 2N 次比较和 少于 N 次交换。&lt;/strong&gt;（堆的构造过程中处理的堆都比较小。例如，要构造一个 127 个元素的数组，需要处理 32 个大小为 3 的堆， 16 个大小为 7 的堆，8 个大小为 15 的堆， 4 个大小为 31 的堆， 2 个大小为 63 的堆和 1 个大小为127的堆，因此在最坏情况下，需要 32*1 + 16*2 + 8*3 + 4*4 + 2*5 + 1*6 = 120 次交换，以及两倍的比较）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;　　2.下沉排序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　堆排序的主要工作在第二阶段。将堆中最大元素和堆底元素交换，并下沉至 N--。相当于删除最大元素并将堆底元素放至堆顶（优先队列删除操作），将删除的最大元素放入空出的数组位置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MaxPriorityQueueSort
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Sort(IComparable[] pq)
        {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; pq.Length;

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; k = n / &lt;span&gt;2&lt;/span&gt;; k &amp;gt;= &lt;span&gt;1&lt;/span&gt;; k--&lt;span&gt;)
            {
                Sink(pq, k, n);
            }

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上浮需要遍历全部
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;for (var k = n; k &amp;gt;= 1; k--)
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Swim(pq, k);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;}&lt;/span&gt;

            &lt;span&gt;while&lt;/span&gt; (n &amp;gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
            {
                Exch(pq,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;,n--&lt;span&gt;);
                Sink(pq,&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;,n);
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Swim(IComparable[] pq, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n)
        {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (n &amp;gt; &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; Less(pq,n / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;, n))
            {
                Exch(pq,n &lt;/span&gt;/ &lt;span&gt;2&lt;/span&gt;&lt;span&gt;, n);
                n &lt;/span&gt;= n / &lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下沉&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Sink(IComparable[] pq,&lt;span&gt;int&lt;/span&gt; k, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; N)
        {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;2&lt;/span&gt; * k &amp;lt;=&lt;span&gt; N)
            {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; k;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取最大的子节点&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (j &amp;lt; N &amp;amp;&amp;amp; Less(pq,j, j + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
                    j&lt;/span&gt;++&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果父节点不小子节点，退出循环&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Less(pq, k,j))
                    &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;否则交换，继续下沉&lt;/span&gt;
&lt;span&gt;                Exch(pq, j,k);
                k &lt;/span&gt;=&lt;span&gt; j;
            }
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Exch(IComparable[] pq, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j)
        {
            IComparable temp &lt;/span&gt;= pq[i-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            pq[i &lt;/span&gt;- &lt;span&gt;1&lt;/span&gt;] = pq[j - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            pq[j &lt;/span&gt;- &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; temp;
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Less(IComparable[] pq, &lt;span&gt;int&lt;/span&gt; i, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; j)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; pq[i - &lt;span&gt;1&lt;/span&gt;].CompareTo(pq[j - &lt;span&gt;1&lt;/span&gt;]) &amp;lt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Show(IComparable[] a)
        {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; a.Length; i++&lt;span&gt;)
                Console.WriteLine(a[i]);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　堆排序的轨迹&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/984232/202007/984232-20200729073714995-1685956270.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　将 N 个元素排序，堆排序只需少于 （2N lgN + 2N）次比较以及一半次数的交换。2N 来自堆的构造，2N lgN 是每次下沉操作最多需要  2lgN 次比较。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;先下沉后上浮&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;在排序过程中，大多数重新插入堆中的项目都会一直到达底部。&lt;/span&gt;&lt;span&gt;因此，通过避免检查元素是否已到达其位置，可以简单地提升两个子结点中的较大者直到到达底部，然后上浮到适当位置，从而节省时间。&lt;/span&gt;&lt;span&gt;这个方法将比较数减少了2倍，但需要额外的簿空间。只有当比较操作代价较高时可以使用这种方法。（例如将字符串或其他键值较长类型的元素排序）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　堆排序是能够同时最优利用空间和时间的方法，在最坏情况下也能保证 ~2N lgN 次比较和恒定的额外空间。当空间紧张时，可以使用堆排序。但堆排序无法利用缓存。因为它的数组元素很少喝相邻的其他元素比较，因此缓存未命中的次数要远高于大多数比较都在相邻元素之间进行的算法。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 28 Jul 2020 23:50:00 +0000</pubDate>
<dc:creator>Ruby_Lu</dc:creator>
<og:description>优先队列 许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将它们排序。很多情况下是收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素。这</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/afei-24/p/13375584.html</dc:identifier>
</item>
<item>
<title>个人珍藏的80道多线程并发面试题（1-10答案解析） - Jay_huaxiao</title>
<link>http://www.cnblogs.com/jay-huaxiao/p/13394928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jay-huaxiao/p/13394928.html</guid>
<description>&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;个人珍藏的80道Java多线程/并发经典面试题，因为篇幅太长，现在先给出1-10的答案解析哈，后面一起完善，并且上传github哈~&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;https://github.com/whx123/JavaHome&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;公众号：捡田螺的小男孩&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1. synchronized的实现原理以及锁优化？&lt;/span&gt;&lt;/h3&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;synchronized的实现原理&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;synchronized作用于&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;方法&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;或者&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;代码块&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，保证被修饰的代码在同一时间只能被一个线程访问。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;synchronized修饰代码块时，JVM采用&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;monitorenter、monitorexit&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;两个指令来实现同步&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;synchronized修饰同步方法时，JVM采用&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;ACC_SYNCHRONIZED&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;标记符来实现同步&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;monitorenter、monitorexit或者ACC_SYNCHRONIZED都是&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;基于Monitor实现&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;实例对象里有对象头，对象头里面有Mark Word，Mark Word指针指向了&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;monitor&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Monitor其实是一种&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;同步工具&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，也可以说是一种&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;同步机制&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;在Java虚拟机（HotSpot）中，Monitor是由&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;ObjectMonitor实现&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;的。ObjectMonitor体现出Monitor的工作原理~&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;ObjectMonitor&lt;/span&gt;&lt;/span&gt;() {
    _header       = NULL;
    _count        = 0; // 记录线程获取锁的次数
    _waiters      = 0,
    _recursions   = 0;  //锁的重入次数
    _object       = NULL;
    _owner        = NULL;  // 指向持有ObjectMonitor对象的线程
    _WaitSet      = NULL;  // 处于&lt;span class=&quot;hljs-built_in&quot;&gt;wait&lt;/span&gt;状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ;  // 处于等待锁block状态的线程，会被加入到该列表
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ObjectMonitor的几个关键属性 _count、_recursions、_owner、_WaitSet、 _EntryList 体现了monitor的工作原理 &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/24/1738189a4358965a?w=1280&amp;amp;h=765&amp;amp;f=png&amp;amp;s=271126&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;锁优化&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在讨论锁优化前，先看看JAVA对象头(32位JVM)中Mark Word的结构图吧~&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/25/173840a59e8cb91a?w=1406&amp;amp;h=583&amp;amp;f=png&amp;amp;s=101991&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Mark Word存储对象自身的运行数据，如&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;哈希码、GC分代年龄、锁状态标志、偏向时间戳（Epoch）&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; 等，为什么区分&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;偏向锁、轻量级锁、重量级锁&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;等几种锁状态呢？&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在JDK1.6之前，synchronized的实现直接调用ObjectMonitor的enter和exit，这种锁被称之为&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;重量级锁&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。从JDK6开始，HotSpot虚拟机开发团队对Java中的锁进行优化，如增加了适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁等优化策略。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;偏向锁：在无竞争的情况下，把整个同步都消除掉，CAS操作都不做。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;轻量级锁：在没有多线程竞争时，相对重量级锁，减少操作系统互斥量带来的性能消耗。但是，如果存在锁竞争，除了互斥量本身开销，还额外有CAS操作的开销。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;自旋锁：减少不必要的CPU上下文切换。在轻量级锁升级为重量级锁时，就使用了自旋加锁的方式&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;锁粗化：将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;举个例子，买门票进动物园。老师带一群小朋友去参观，验票员如果知道他们是个集体，就可以把他们看成一个整体（锁租化），一次性验票过，而不需要一个个找他们验票。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;锁消除:虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有兴趣的朋友们可以看看我这篇文章： &lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. ThreadLocal原理，使用注意点，应用场景有哪些？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;回答四个主要点：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;ThreadLocal是什么?&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;ThreadLocal原理&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;ThreadLocal使用注意点&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;ThreadLocal的应用场景&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;ThreadLocal是什么?&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal，即线程本地变量。如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地拷贝，多个线程操作这个变量的时候，实际是操作自己本地内存里面的变量，从而起到线程隔离的作用，避免了线程安全问题。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;//创建一个ThreadLocal变量
static ThreadLocal&amp;lt;String&amp;gt; localVariable = new ThreadLocal&amp;lt;&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;ThreadLocal原理&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal内存结构图：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/26/1738a130b3c6e020?w=1211&amp;amp;h=982&amp;amp;f=png&amp;amp;s=257051&quot; alt=&quot;&quot;/&gt; 由结构图是可以看出：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;Thread对象中持有一个ThreadLocal.ThreadLocalMap的成员变量。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;ThreadLocalMap内部维护了Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型值。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对照着几段关键源码来看，更容易理解一点哈~&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;public class Thread implements Runnable {
   //ThreadLocal.ThreadLocalMap是Thread的属性
   ThreadLocal.ThreadLocalMap threadLocals = null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocal中的关键方法set()和get()&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    public void &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;(T value) {
        Thread t = Thread.currentThread(); //获取当前线程t
        ThreadLocalMap map = getMap(t);  //根据当前线程获取到ThreadLocalMap
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (map != null)
            map.set(this, value); //K，V设置到ThreadLocalMap中
        &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;
            createMap(t, value); //创建一个新的ThreadLocalMap
    }

    public T &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;get&lt;/span&gt;&lt;/span&gt;() {
        Thread t = Thread.currentThread();//获取当前线程t
        ThreadLocalMap map = getMap(t);//根据当前线程获取到ThreadLocalMap
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (map != null) {
            //由this（即ThreadLoca对象）得到对应的Value，即ThreadLocal的泛型值
            ThreadLocalMap.Entry e = map.getEntry(this);
            &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (e != null) {
                @SuppressWarnings(&lt;span class=&quot;hljs-string&quot;&gt;&quot;unchecked&quot;&lt;/span&gt;)
                T result = (T)e.value; 
                &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; result;
            }
        }
        &lt;span class=&quot;hljs-built_in&quot;&gt;return&lt;/span&gt; setInitialValue();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap的Entry数组&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;static class ThreadLocalMap {
    static class Entry extends WeakReference&amp;lt;ThreadLocal&amp;lt;?&amp;gt;&amp;gt; {
        /** The value associated with this ThreadLocal. */
        Object value;

        Entry(ThreadLocal&amp;lt;?&amp;gt; k, Object v) {
            super(k);
            value = v;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以怎么回答&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;ThreadLocal的实现原理&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;？如下，最好是能结合以上结构图一起说明哈~&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，即每个线程都有一个属于自己的ThreadLocalMap。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;ThreadLocalMap内部维护着Entry数组，每个Entry代表一个完整的对象，key是ThreadLocal本身，value是ThreadLocal的泛型值。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;每个线程在往ThreadLocal里设置值的时候，都是往自己的ThreadLocalMap里存，读也是以某个ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;ThreadLocal 内存泄露问题&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先看看一下的TreadLocal的引用示意图哈，&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/26/1738b3cf19130e19?w=1804&amp;amp;h=741&amp;amp;f=png&amp;amp;s=99228&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;ThreadLocalMap中使用的 key 为 ThreadLocal 的弱引用，如下 &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/26/1738b1a2f8978e47?w=1052&amp;amp;h=498&amp;amp;f=png&amp;amp;s=48612&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;弱引用：只要垃圾回收机制一运行，不管JVM的内存空间是否充足，都会回收该对象占用的内存。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;弱引用比较容易被回收。因此，如果ThreadLocal（ThreadLocalMap的Key）被垃圾回收器回收了，但是因为ThreadLocalMap生命周期和Thread是一样的，它这时候如果不被回收，就会出现这种情况：ThreadLocalMap的key没了，value还在，这就会&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;造成了内存泄漏问题&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如何&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;解决内存泄漏问题&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;？使用完ThreadLocal后，及时调用remove()方法释放内存空间。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;ThreadLocal的应用场景&lt;/span&gt;&lt;/h4&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;数据库连接池&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;会话管理中使用&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. synchronized和ReentrantLock的区别？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我记得校招的时候，这道面试题出现的频率还是挺高的~可以从锁的实现、功能特点、性能等几个维度去回答这个问题，&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;锁的实现：&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; synchronized是Java语言的关键字，基于JVM实现。而ReentrantLock是基于JDK的API层面实现的（一般是lock()和unlock()方法配合try/finally 语句块来完成。）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;性能：&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; 在JDK1.6锁优化以前，synchronized的性能比ReenTrantLock差很多。但是JDK6开始，增加了适应性自旋、锁消除等，两者性能就差不多了。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;功能特点：&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; ReentrantLock 比 synchronized 增加了一些高级功能，如等待可中断、可实现公平锁、可实现选择性通知。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;ReentrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;ReentrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;synchronized与wait()和notify()/notifyAll()方法结合实现等待/通知机制，ReentrantLock类借助Condition接口与newCondition()方法实现。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;ReentrantLock需要手工声明来加锁和释放锁，一般跟finally配合释放锁。而synchronized不用手动释放锁。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4. 说说CountDownLatch与CyclicBarrier区别&lt;/span&gt;&lt;/h3&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;CountDownLatch：一个或者多个线程，等待其他多个线程完成某件事情之后才能执行;&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;CyclicBarrier：多个线程互相等待，直到到达同一个同步点，再继续一起执行。 &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/27/1738d9ab805c995c?w=1165&amp;amp;h=785&amp;amp;f=png&amp;amp;s=104903&quot; alt=&quot;&quot;/&gt;&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子吧：&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;CountDownLatch：假设老师跟同学约定周末在公园门口集合，等人齐了再发门票。那么，发门票（这个主线程），需要等各位同学都到齐（多个其他线程都完成），才能执行。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;CyclicBarrier:多名短跑运动员要开始田径比赛，只有等所有运动员准备好，裁判才会鸣枪开始，这时候所有的运动员才会疾步如飞。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5. Fork/Join框架的理解&lt;/span&gt;&lt;/h3&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Fork/Join框架是Java7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Fork/Join框架需要理解两个点，&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;分而治之&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;工作窃取算法&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;分而治之&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上Fork/Join框架的定义，就是分而治之思想的体现啦 &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/27/17390bea64fadb1f?w=1295&amp;amp;h=1006&amp;amp;f=png&amp;amp;s=69986&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;工作窃取算法&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;把大任务拆分成小任务，放到不同队列执行，交由不同的线程分别执行时。有的线程优先把自己负责的任务执行完了，其他线程还在慢慢悠悠处理自己的任务，这时候为了充分提高效率，就需要工作盗窃算法啦~&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/27/17390d4b199b668a?w=813&amp;amp;h=576&amp;amp;f=png&amp;amp;s=65266&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;工作盗窃算法就是，&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;某个线程从其他队列中窃取任务进行执行的过程&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;。一般就是指做得快的线程（盗窃线程）抢慢的线程的任务来做，同时为了减少锁竞争，通常使用双端队列，即快线程和慢线程各在一端。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;6. 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看看Thread的start方法说明哈~&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;    /**
     * Causes this thread to begin execution; the Java Virtual Machine
     * calls the &amp;lt;code&amp;gt;run&amp;lt;/code&amp;gt; method of this thread.
     * &amp;lt;p&amp;gt;
     * The result is that two threads are running concurrently: the
     * current thread (&lt;span class=&quot;hljs-built_in&quot;&gt;which&lt;/span&gt; returns from the call to the
     * &amp;lt;code&amp;gt;start&amp;lt;/code&amp;gt; method) and the other thread (&lt;span class=&quot;hljs-built_in&quot;&gt;which&lt;/span&gt; executes its
     * &amp;lt;code&amp;gt;run&amp;lt;/code&amp;gt; method).
     * &amp;lt;p&amp;gt;
     * It is never legal to start a thread more than once.
     * In particular, a thread may not be restarted once it has completed
     * execution.
     *
     * @exception  IllegalThreadStateException  &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; the thread was already
     *               started.
     * @see        
     * @see        
     */
    public synchronized void &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-title&quot;&gt;start&lt;/span&gt;&lt;/span&gt;() {
     ......
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;JVM执行start方法，会另起一条线程执行thread的run方法，这才起到多线程的效果~ &lt;strong&gt;&lt;span&gt;「&lt;/span&gt;为什么我们不能直接调用run()方法？&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt; 如果直接调用Thread的run()方法，其方法还是运行在主线程中，没有起到多线程效果。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;7. CAS？CAS 有什么缺陷，如何解决？&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS,Compare and Swap，比较并交换；&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CAS 涉及3个操作数，内存地址值V，预期原值A，新值B； 如果内存位置的值V与预期原A值相匹配，就更新为新值B，否则不更新&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;CAS有什么缺陷？&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/28/17392a38b3e75683?w=804&amp;amp;h=431&amp;amp;f=png&amp;amp;s=46436&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;ABA 问题&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;并发环境下，假设初始条件是A，去修改数据时，发现是A就会执行修改。但是看到的虽然是A，中间可能发生了A变B，B又变回A的情况。此时A已经非彼A，数据即使成功修改，也可能有问题。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过AtomicStampedReference&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;解决ABA问题&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;，它，一个带有标记的原子引用类，通过控制变量值的版本来保证CAS的正确性。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;循环时间长开销&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;自旋CAS，如果一直循环执行，一直不成功，会给CPU带来非常大的执行开销。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;很多时候，CAS思想体现，是有个自旋次数的，就是为了避开这个耗时问题~&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;只能保证一个变量的原子操作。&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CAS 保证的是对一个变量执行操作的原子性，如果对多个变量操作时，CAS 目前无法直接保证操作的原子性的。&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以通过这两个方式解决这个问题：&lt;/p&gt;
&lt;blockquote data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;section&gt;使用互斥锁来保证原子性；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;将多个变量封装成对象，通过AtomicReference来保证原子性。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;有兴趣的朋友可以看看我之前的这篇实战文章哈~ &lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;9. 如何保证多线程下i++ 结果正确？&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/28/17392b5e8436976e?w=935&amp;amp;h=464&amp;amp;f=png&amp;amp;s=55515&quot; alt=&quot;&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;使用循环CAS，实现i++原子操作&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;使用锁机制，实现i++原子操作&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;使用synchronized，实现i++原子操作&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没有代码demo，感觉是没有灵魂的~ 如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;/**
 *  @Author 捡田螺的小男孩
 */
public class AtomicIntegerTest {

    private static AtomicInteger atomicInteger = new AtomicInteger(0);

    public static void main(String[] args) throws InterruptedException {
        testIAdd();
    }

    private static void testIAdd() throws InterruptedException {
        //创建线程池
        ExecutorService executorService = Executors.newFixedThreadPool(2);
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (int i = 0; i &amp;lt; 1000; i++) {
            executorService.execute(() -&amp;gt; {
                &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; (int j = 0; j &amp;lt; 2; j++) {
                    //自增并返回当前值
                    int andIncrement = atomicInteger.incrementAndGet();
                    System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;线程:&quot;&lt;/span&gt; + Thread.currentThread().getName() + &lt;span class=&quot;hljs-string&quot;&gt;&quot; count=&quot;&lt;/span&gt; + andIncrement);
                }
            });
        }
        executorService.shutdown();
        Thread.sleep(100);
        System.out.println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;最终结果是 ：&quot;&lt;/span&gt; + atomicInteger.get());
    }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;...
线程:pool-1-thread-1 count=1997
线程:pool-1-thread-1 count=1998
线程:pool-1-thread-1 count=1999
线程:pool-1-thread-2 count=315
线程:pool-1-thread-2 count=2000
最终结果是 ：2000
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;10. 如何检测死锁？怎么预防死锁？死锁四个必要条件&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;死锁是指多个线程因竞争资源而造成的一种互相等待的僵局。如图感受一下： &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/28/17392c9774168d4c?w=1250&amp;amp;h=830&amp;amp;f=png&amp;amp;s=186643&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;死锁的四个必要条件：&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;互斥：一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;占有且等待：当一个进程在等待分配得到其他资源时，其继续占有已分配得到的资源。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;非抢占：不能强行抢占进程中已占有的资源。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;循环等待：存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;&lt;span&gt;「&lt;/span&gt;如何预防死锁？&lt;span&gt;」&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;加锁顺序（线程按顺序办事）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;加锁时限 （线程请求所加上权限，超时就放弃，同时释放自己占有的锁）&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;死锁检测&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;参考与感谢&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;牛顿说，我之所以看得远，是因为我站在巨人的肩膀上~ 谢谢以下各位前辈哈~&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;个人公众号&lt;/span&gt;&lt;/h3&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/12/172066fcb54c1643?w=900&amp;amp;h=500&amp;amp;f=png&amp;amp;s=133410&quot; alt=&quot;&quot;/&gt;&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;觉得写得好的小伙伴给个点赞+关注啦，谢谢~&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;如果有写得不正确的地方，麻烦指出，感激不尽。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;同时非常期待小伙伴们能够关注我公众号，后面慢慢推出更好的干货~嘻嘻&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;github地址：https://github.com/whx123/JavaHome&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
<pubDate>Tue, 28 Jul 2020 23:13:00 +0000</pubDate>
<dc:creator>Jay_huaxiao</dc:creator>
<og:description>前言 个人珍藏的80道Java多线程/并发经典面试题，因为篇幅太长，现在先给出1-10的答案解析哈，后面一起完善，并且上传github哈~ ❝ https://github.com/whx123/Ja</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jay-huaxiao/p/13394928.html</dc:identifier>
</item>
<item>
<title>如何阅读一本书——分析阅读Pre - 卡斯特梅的雨伞</title>
<link>http://www.cnblogs.com/castamere/p/13394791.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/castamere/p/13394791.html</guid>
<description>&lt;p&gt;如何阅读一本书——分析阅读Pre&lt;/p&gt;
&lt;p&gt;前情介绍&lt;/p&gt;
&lt;p&gt;作者： 莫提默.艾德勒 查尔斯.范多伦&lt;/p&gt;
&lt;p&gt;初版：1940年，一出版就是全美畅销书榜首一年多。钢铁侠Elon.Musk学过。&lt;/p&gt;
&lt;p&gt;需要注意的句子：&lt;/p&gt;
&lt;p&gt;成功的阅读牵涉到读者与作者达成共识。&lt;/p&gt;
&lt;p&gt;实用性的书，要以目标结果为导向去学习。没有目的的学习是毫无效率和意义的。&lt;/p&gt;
&lt;p&gt;如果一本书不能启发一个人时，读者只有一个解决办法，就是自己亲身体验以获得必要的特殊经验。即上手操作。&lt;/p&gt;
&lt;p&gt;只有当我们解决了基础的层次问题，即基础阅读中遇到的如不认识的字或语法句法问题时，我们的阅读能力才能更上一层楼。&lt;/p&gt;
&lt;p&gt;要达到阅读的所有目的，就必须在阅读不同书籍的时候，运用适当的不同速度。&lt;/p&gt;
&lt;p&gt;阅读越主动，效果越好。&lt;/p&gt;
&lt;p&gt;阅读的规则是：努力越多，效果越好。&lt;/p&gt;
&lt;p&gt;无限制的受教育机会是一个社会能提供给人民最有价值的服务——或说得正确一点，只有当一个人的自我期许，能力与需要受限制时，教育机会才会受到限制。&lt;/p&gt;
&lt;p&gt;一个人如果不够灵活，不能够集中精神来阅读，就没法进行检视阅读。&lt;/p&gt;
&lt;p&gt;依照读完的性质与复杂程度，用不同的速度来阅读。在阅读一本书的时候，慢不该慢到不值得，快不该快到有损满足于理解。&lt;/p&gt;
&lt;p&gt;粗浅的阅读规则：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不用停下来查询或思索。&lt;/p&gt;
&lt;p&gt;在阅读的时候想要保持清醒，或昏昏欲睡，注意看阅读的目标是什么。&lt;/p&gt;
&lt;p&gt;人们在读一本好书的时候会打瞌睡，并不是他们不想努力，而是因为他们不知道要如何努力。&lt;/p&gt;
&lt;p&gt;一个人如果说他知道他在想些什么，却说不出来，通常是他其实并不知道自己在想些什么。&lt;/p&gt;
&lt;p&gt;阅读一本书应该像是你与作者之间的对话。&lt;/p&gt;
&lt;p&gt;要养成阅读习惯，除了不断地运作练习之外，别无他法。俗话说，熟能生巧。一开始做不好的事，慢慢就会得心应手，像是自然天生一样。&lt;/p&gt;
&lt;p&gt;一个人只要学习过一种复杂的技巧，就会知道要学习一项新技巧，一开始的复杂过程是不足为惧的。也知道他用不着担心这些个别的行动，因为只有当他精通这些个别的行动时，才能完成一个整体的行动。&lt;/p&gt;
&lt;p&gt;如果你对一篇文章连一个问题也提不出来，那么你就不可能期望一本书能给你一些你原本就没有的视野。&lt;/p&gt;
&lt;p&gt;一个读得很广泛，却读不精的人，与其值得赞美，不然值得同情。就像霍布斯所说：“如果我像一般人一样读那么多书，我就跟他们一样愚蠢了。”&lt;/p&gt;
&lt;p&gt;目标&lt;/p&gt;
&lt;p&gt;实用性的书，特别如技术书，要以目标为导向去学习阅读。阅读这本书的目标其实是为了能更好更快更高效地学习技术书以迅速提高技术水平和能力为目的来阅读的，之前已经阅读过了一次，不过只能算检视阅读中的略读。希望通过深入分析阅读这本书，能够让我在技术上，乃至后面的其他方面书籍的阅读上能够如臂使指，迅速地得到知识。这是本开局必学书。&lt;/p&gt;
&lt;p&gt;产出：要整理个分析阅读实用性技术书所要提问和做的步骤的模板。&lt;/p&gt;
&lt;p&gt;检视阅读模板——必须&lt;/p&gt;
&lt;p&gt;分析阅读模板——必须&lt;/p&gt;
&lt;p&gt;主题阅读模板——待定&lt;/p&gt;
&lt;p&gt;后记&lt;/p&gt;
&lt;p&gt;每本书都有一套自己的骨架，作为一个分析阅读的读者，其责任就是要找出这个骨架。要有X光般的透视眼来看这本书，因为这是我们了解一本书，掌握其骨架的基础。&lt;/p&gt;
&lt;p&gt;作者序&lt;/p&gt;
&lt;p&gt;本书目的：&lt;/p&gt;
&lt;p&gt;让读者懂得如何让书本来教导我们继续学习与发现。&lt;/p&gt;
&lt;p&gt;要达到阅读的所有目的，就必须在阅读不同书籍的时候，运用适当的不同速度。&lt;/p&gt;
&lt;p&gt;读得太快或者太慢，都一无所获。&lt;/p&gt;
&lt;p&gt;读书应如金字塔，基础厚实，顶端尖锐。&lt;/p&gt;
&lt;p&gt;骨架：&lt;/p&gt;
&lt;p&gt;阅读的四个层次及以不同阅读方法接触不同读物之道。&lt;/p&gt;
&lt;p&gt;疑问&lt;/p&gt;
&lt;p&gt;Q:读书应如金字塔，基础厚实，顶端尖锐。这句话怎么理解？&lt;/p&gt;
&lt;p&gt;A:我想是阅读的四个层次吧。每个阅读都要基于前一个阶段，在保证基础阅读的能力后，才能进行检视阅读。而只有进行检视阅读，我们才能知道一本书大体讲的是什么，值不值得我们进行分析阅读，值得的话，则在检视阅读的基础上进行分析阅读。而主题阅读，则更需要依赖检视阅读来筛选出不同的书，以及书中我们研究的主题的关联章节，在有必要深入了解的书中，进行分析阅读。&lt;/p&gt;
&lt;p&gt;分以下4个方面展开说明：&lt;/p&gt;
&lt;p&gt;一、阅读的活力与艺术&lt;/p&gt;
&lt;p&gt;面向对象：把读书的主要目的当作是增进理解能力的人而写的。&lt;/p&gt;
&lt;p&gt;太多的资讯就如同太少的资讯一样，都是一种对理解力的阻碍。这么说是因为：电视收音机观众、杂志读者所面对的是一种复杂的组成——从独创的华丽辞藻到经过审慎挑选的资料与统计——目的都在让人不需要面对困难或努力，就能整理出“自己”的情绪，让观众用不着自己做结论。&lt;/p&gt;
&lt;p&gt;评语：难怪我看了无数的电视剧、电影，以为尝尽了人间百味，不过是别人的投食而已，我并没有因此提高自己的理解力，也难怪自己想理解总结些什么却无从下手，就是因为这些都是导演或者说别人咀嚼烂了喂给我们的，而不是自己采摘的果实。&lt;/p&gt;
&lt;p&gt;阅读越主动，效果越好。读者对他自己，以及自己面前的书籍，要求的越多，获得的就越多。&lt;/p&gt;
&lt;p&gt;作者（阅读的书的作者）与读者的关系就像棒球运动中的投手和捕手的关系一样，只有密切合作时，才能接球成功。&lt;/p&gt;
&lt;p&gt;主动的阅读包含两个条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;阅读时特别主动。&lt;/li&gt;
&lt;li&gt;在阅读时使用技巧。（这本书提到的方法论）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;成功地阅读一本书，完全看你能接获多少作者想要传达的讯息。&lt;/p&gt;
&lt;p&gt;真正地在阅读指的是没有任何外力的帮助，自己把这本书读懂。（请教别人或者别的参考书教科书都不算真正的阅读）&lt;/p&gt;
&lt;p&gt;所谓的阅读艺术的定义：这是一个凭借着头脑运作，除了玩味读物中的一些字句之外，不假任何外助，以一己之力来提升自我的过程。&lt;/p&gt;
&lt;p&gt;阅读的两种不同意义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为获得资讯(知识)而阅读&lt;/li&gt;
&lt;li&gt;为增进理解而阅读&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;吸收资讯（知识）知道某件事发生了。想要被启发，就要去理解，搞清楚这到底是怎么回事：为什么会发生，与其他的事实有什么关联，有什么类似的情况，同类的差异在哪里等。&lt;/p&gt;
&lt;p&gt;初学者的无知在于未学，而学者的无知在于学后。——蒙田&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一种无知是文盲，无法阅读。&lt;/li&gt;
&lt;li&gt;第二种无知却是读错了很多书。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第二种无知的人读得太广却读不通，好读书却读不懂的人叫书呆子或者半瓶醋。&lt;/p&gt;
&lt;p&gt;注意：要避免读得多就是读得好的错误。&lt;/p&gt;
&lt;p&gt;学习分两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;指导型学习。通过阅读或倾听&lt;/li&gt;
&lt;li&gt;自我发现型学习。通过立足于自然或世界，是阅读自我或世界的学习。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;自我发现学习的技巧：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;敏锐的观察&lt;/li&gt;
&lt;li&gt;灵敏可靠的记忆&lt;/li&gt;
&lt;li&gt;想象的空间&lt;/li&gt;
&lt;li&gt;训练有素的分析&lt;/li&gt;
&lt;li&gt;省思能力&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;思考只是主动阅读的一部分，一个人还必须运用他的感觉与想象力。&lt;/p&gt;
&lt;p&gt;疑问：&lt;/p&gt;
&lt;p&gt;Q:如何将知识分子的态度与观点包装起来，是当今最有才智的人在做的最活跃的事业之一。这指的是什么？新闻媒体杂志么？像布隆博格做的彭博网？&lt;/p&gt;
&lt;p&gt;A:指通过新闻媒体、电影电视等传媒及小说、文学等形式来传达自己的观点的活动，像美国好莱坞等。&lt;/p&gt;
&lt;p&gt;Q:真正地在阅读指的是没有任何外力的帮助，自己把这本书读懂。（请教别人或者别的参考书教科书都不算真正的阅读）为什么不能参考其他书呢？作者后面的主题阅读不也要求我们对不同的观点的书籍作出总结么？再说不通过别人或者参考书解释会不会让自己陷入死胡同里？特别是读技术类的书，不同与哲学类的？&lt;/p&gt;
&lt;p&gt;A:作者的意思是尽量地能通过自己阅读这本书，与作者对话，达成共识，这才能更好地增加理解力。对于一些生词或者像哲学、历史等需要了解作者的生平历史反而能更加地让我们读好作者的书。作者的意思是尽量靠自己阅读，但没说要排斥其他的参考帮助学习，一把尺子自己把握好，原则就是尽量自己解决疑惑问题。&lt;/p&gt;
&lt;p&gt;Q:自我发现型学习。通过立足于自然或世界，是阅读自我或世界的学习。怎么叫通过立足于自然或世界？&lt;/p&gt;
&lt;p&gt;A:我想通过作者的这句话可以解释什么是自然和世界。——如果你问一本书一个问题，你就必须自己回答这个问题。在这样的情况下，这本书就跟自然或世界一样。当你提出问题时，只有等你自己作了思考和分析之后，才会在书本上找到答案。所以，就是立足于自力更生，自我提问和解答的意思。&lt;/p&gt;
&lt;p&gt;二、阅读的层次（重点方法论）&lt;/p&gt;
&lt;p&gt;决定阅读方式的是：一个读者要追求的目标——为了消遣，获得资讯或增进理解力。&lt;/p&gt;
&lt;p&gt;决定阅读效果的是：读者在阅读上花了多少努力与技巧。&lt;/p&gt;
&lt;p&gt;阅读的规则是：努力越多，效果越好。&lt;/p&gt;
&lt;p&gt;阅读的层次:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;基础阅读。并不关心意义，只关心语言。&lt;/li&gt;
&lt;li&gt;检视阅读。特点在强调时间。在一定的时间内，抓住一本书的重点。&lt;/li&gt;
&lt;li&gt;分析阅读。全盘、完整的阅读。&lt;/li&gt;
&lt;li&gt;主题阅读。阅读很多书，列举出这些书直接的相关之处，提出一个所有书都谈到的主题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基础阅读的提问：这个句子 在说什么？&lt;/p&gt;
&lt;p&gt;检视阅读的提问：这本书在谈什么？或者这本书的架构如何？这本书包含哪些部分？&lt;/p&gt;
&lt;p&gt;检视阅读的价值：减少阅读的困难，减少阅读理解一本书的时间。&lt;/p&gt;
&lt;p&gt;检视阅读与分析阅读的区别：&lt;/p&gt;
&lt;p&gt;检视阅读是在有限的时间内，最好也最完整的阅读；分析阅读是在无限的时间里，最好也最完整的阅读。&lt;/p&gt;
&lt;p&gt;有些书可以浅尝即止，有些书是要生吞活剥，只有少数的书是要咀嚼和消化的。——弗朗西斯.培根&lt;/p&gt;
&lt;p&gt;分析阅读就是要咀嚼和消化一本书。&lt;/p&gt;
&lt;p&gt;分析阅读是特别在追寻理解的那一类。&lt;/p&gt;
&lt;p&gt;分析阅读的前提是要有相当程度的分析阅读的技巧。&lt;/p&gt;
&lt;p&gt;评语：对于要阅读的英文技术文档或者著作，就要在基础阅读上先下功夫了，如果连书本中的字面意思或者单词都不懂的话，又何谈理解呢？所有在后面的日子里，除了当务之急的技术提升外，在有可能或者空闲的时间里就要把英语的基础水平提升上来，做到能基础阅读才行。还有，在阅读基础阅读这一章时，要代入如何学习英语的基础阅读的提问来看。&lt;/p&gt;
&lt;p&gt;评语：四种阅读的层次之间是包含关系的，只有掌握基础阅读，才能进行后面的阅读；而阅读的次序最好也按顺序来，先做检视阅读，然后有必要地进行分析阅读，如果需要，才进行最后的主题阅读，按节奏来。阅读一本书的时候就按这这个次序来。&lt;/p&gt;
&lt;p&gt;疑问：&lt;/p&gt;
&lt;p&gt;Q:那生吞活剥的书指的是哪些，哪一层级的阅读？检视阅读么？&lt;/p&gt;
&lt;p&gt;A:没错，就是检视阅读。当我们想了解一本书时，首先要先进行检视阅读，看下这本书主要讲的是什么？真本书的架构是怎样的？是不是对这本书感兴趣？大部分的书只走到了这一步就停了，没有分析阅读的必要。&lt;/p&gt;
&lt;p&gt;1、基础阅读&lt;/p&gt;
&lt;p&gt;作者的观点：因材施教。&lt;/p&gt;
&lt;p&gt;要教育爱好学习的孩子阅读，和教育没有学习动机的孩子的阅读是完全不同的两码事。&lt;/p&gt;
&lt;p&gt;评语：所以如果小孩资质优秀，爱好学习，那么提供一个好的教育环境是特别重要的。&lt;/p&gt;
&lt;p&gt;一个不懂得如何阅读的年轻男子或年轻女子，在他追求美国梦的途中就会受到阻碍。&lt;/p&gt;
&lt;p&gt;中国英语教育：ABC教学法——改良版发音法&lt;/p&gt;
&lt;p&gt;默读理解的阅读法：强调在注意到每一个字母或发音之前，先以视觉认知整个单词。先看整个句子与其中的含义，然后才学习认识单词，最后才是字母。&lt;/p&gt;
&lt;p&gt;在美国，批判学校是一种传统。&lt;/p&gt;
&lt;p&gt;基础阅读的四个阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;阅读准备阶段。相当于学前教育或幼儿园学习经验。&lt;/li&gt;
&lt;li&gt;认字，读写能力——一年级学生学习经验。阅读看图识字等简单的读物。&lt;/li&gt;
&lt;li&gt;功能性读写能力。词汇的增长及对课文的运用——快速建立词汇的能力，四年级学习经验。&lt;/li&gt;
&lt;li&gt;精炼与增进前面所学的技巧。小学到初中毕业的学习能力。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：在阅读准备阶段，一个孩子如果还没准备好就要教他阅读，他可能会不喜欢这样的学习经验，以后的学校教育甚至成人阶段都会受到影响。&lt;/p&gt;
&lt;p&gt;懂得发现一些符号的意义，是人类所表现出的最惊人的聪明技巧，而大多数人在7岁之前就已经表现出来这样的智能了。&lt;/p&gt;
&lt;p&gt;一个人文素养优良的高中，就算什么也没做，也该培养出能达到分析阅读的读者。一个优秀的大学，就算什么也没贡献，也该培育出能进行主题阅读的读者。&lt;/p&gt;
&lt;p&gt;义务教育的目标，或者说全民教育的目标：&lt;/p&gt;
&lt;p&gt;无限制的受教育机会是一个社会能提供给人民最有价值的服务——或说得正确一点，只有当一个人的自我期许，能力与需要受限制时，教育机会才会受到限制。&lt;/p&gt;
&lt;p&gt;疑问：&lt;/p&gt;
&lt;p&gt;Q:在美国，批判学校是一种传统。不是学校批判政府政策么？&lt;/p&gt;
&lt;p&gt;A:学校批判政府政策是另外一回事。批判学校是为了学校能更好地育人。比较下一代的培养是通过学校进行的，而父母乃至整个社会都关系学校培养出来的下一代接班人不能是花瓶吧，所以学校有什么不是，不对的，就会受到批判。&lt;/p&gt;
&lt;p&gt;Q:如果我高中就达到分析阅读的水平，那我现在是什么样的智慧啊？&lt;/p&gt;
&lt;p&gt;A:种一棵树最好的时候是十年前，其次是现在。不要妄自菲薄，多多用功努力。&lt;/p&gt;
&lt;p&gt;2、检视阅读&lt;/p&gt;
&lt;p&gt;阅读的层次是渐进积累的。基础阅读是包含在检视阅读中的，而检视阅读又包含在分析阅读中，分析阅读则包含在主题阅读中。&lt;/p&gt;
&lt;p&gt;除非能精通基础阅读，否则你无法进入检视阅读的层次。&lt;/p&gt;
&lt;p&gt;评语：在英语技术文档或者文学阅读中就是基础阅读不过关，所以常常卡主，无法顺利地阅读下去。这便需要我在攻关技术瓶颈之后，有了一定的空闲时间后开始注意平时增加词汇量，增进英语的基础阅读能力，直到达到了基础阅读的水平后才能进入增进理解力的领域。&lt;/p&gt;
&lt;p&gt;检视阅读有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一，有系统的略读或粗读。&lt;/li&gt;
&lt;li&gt;二，粗浅的阅读。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;略读(skim)或粗读(pre-read)是检视阅读的第一个子层次。我们脑子中的目标是要发现这本书值不值得多花时间仔细阅读。其次就算决定了不再多花时间仔细阅读这本书，略读也能告诉你许多跟这本书有关的事。&lt;/p&gt;
&lt;p&gt;有系统的略读或粗读建议：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先看书名页，然后如果有序就先看序。（将这本书归类）&lt;/li&gt;
&lt;li&gt;研究目录页。（对这本书的基本架构做概括性的理解）&lt;/li&gt;
&lt;li&gt;如果书中附有索引，也要检阅一下。（快速评估这本书涵盖了哪些议题的范围，以及所提到的书籍种类与作者）&lt;/li&gt;
&lt;li&gt;读一下出版者的介绍。（一般会有书中主旨的摘要）&lt;/li&gt;
&lt;li&gt;从目录中开始挑几个看起来跟主题息息相关的篇章来看。（仔细阅读开头结尾的摘要说明）&lt;/li&gt;
&lt;li&gt;最后一步，把书打开来，东翻翻西翻翻，念一两段，有时候连续读几页，但不要太多。（随时寻找主要论点的讯号，留意主题的基本脉动，且不要忽略最后的两三页，因为作者会吧自己的观点在此重新整理一遍）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;前面四个步骤可以让我们有足够的资讯去判断是否想要更仔细地读这本书，还是根本不想读下去了。&lt;/p&gt;
&lt;p&gt;一个人如果不够灵活，不能够集中精神来阅读，就没法进行检视阅读。&lt;/p&gt;
&lt;p&gt;上面六点建议是依循作者思路的来制定的。&lt;/p&gt;
&lt;p&gt;许多作者花了很多时间来创作目录页。&lt;/p&gt;
&lt;p&gt;评语：这对于写过论文之类的人来说深有体会。&lt;/p&gt;
&lt;p&gt;建议：&lt;/p&gt;
&lt;p&gt;把自己想象成一个侦探，在寻找一本书主题或思想的线索。&lt;/p&gt;
&lt;p&gt;粗浅的阅读&lt;/p&gt;
&lt;p&gt;每个人都有这样的经验：对一本难读的书抱有高度的期望，以为它能启发我们，结果却只是在徒劳无益地挣扎而已。&lt;/p&gt;
&lt;p&gt;其实，在阅读一本难读的书时不能期望过高，只要找到对的方向，不论多难读的书，只要原来就是想写给大众读者看的，那就不该有望而却步的理由。&lt;/p&gt;
&lt;p&gt;粗浅的阅读规则：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不用停下来查询或思索。&lt;/p&gt;
&lt;p&gt;评语：一口气吃不成一个胖子，我很多时候感觉自己就是太浮躁，期望过高，以为把那本书读了之后自己的境界又提升了一个变化，其实很多时候读完却忘了很多内容，这其中有两个因素导致：一个是学而不思，没有总结，没有写个自己的读后感；另外一个便是很多时候这种书是难读的书，读一遍是不够的，仔细认真地读完一遍也是不够的，这不仅仅是因为自己没有过目不忘的本领，还有每次的阅读都是一次理解的增进。所以，一开始粗浅的阅读的很好的建议。&lt;/p&gt;
&lt;p&gt;建议：&lt;/p&gt;
&lt;p&gt;集中精神在直接能理解，看得懂的地方，不用为一些没法立即了解的东西（常是作者的主旨）而停顿。将全书读完，不用被一个看不懂的章节、注解、评论或参考资料阻挠或泄气。如果让自己被困住了，容许自己被某个顽固的段落绑住了，这样就是被打败了。&lt;/p&gt;
&lt;p&gt;从头到尾读一遍后，可以帮补后来重读增进理解；也比让自己一碰到困难的地方就停住，最后对这本书一无所知好。（阅读中的博弈论）&lt;/p&gt;
&lt;p&gt;粗浅的阅读是要把眼光注意在自己懂的地方，而不是不懂的地方。如果时候不到就做下面这些事情，只会妨碍我们的阅读，而非帮助。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要碰到生字就去查字典。&lt;/li&gt;
&lt;li&gt;不要看的不明白的隐喻或论说就去查百科全书或相关资料。&lt;/li&gt;
&lt;li&gt;不要看到不懂的名词或句子就去百度。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举例：&lt;/p&gt;
&lt;p&gt;在读莎士比亚的戏剧或者国富论时，不用试图去了解一些细微或者不清楚的点，而应该快速读完全部，然后讨论第一次快速阅读中所获得的东西。&lt;/p&gt;
&lt;p&gt;评语：就像我们工作中在阅读需求文档时，第一遍看下来是没法全部弄懂的，特别是新的领域知识的时候，这时候只能大概地过一遍，大概了解一下，然后再重复地阅读与理解。&lt;/p&gt;
&lt;p&gt;阅读的速度&lt;/p&gt;
&lt;p&gt;一个熟练的检视阅读者想要读一本书时，不论碰到多难读或多长的书，都能够很快地运用这两种方式读完。&lt;/p&gt;
&lt;p&gt;依照读完的性质与复杂程度，用不同的速度来阅读。在阅读一本书的时候，慢不该慢到不值得，快不该快到有损于满足于理解。&lt;/p&gt;
&lt;p&gt;注：当我们拿一本书做分析阅读时，不该用同样的速度读完全书。每一本书，不论多么难读的书，在无关紧要的间隙部分就可以读快一点。&lt;/p&gt;
&lt;p&gt;快速阅读能力&lt;/p&gt;
&lt;p&gt;快速阅读的障碍在于：逗留与倒退。&lt;/p&gt;
&lt;p&gt;逗留指眼睛在阅读一行字时会在其中五六个地方发生逗留现象。&lt;/p&gt;
&lt;p&gt;倒退指阅读两三行后眼睛倒退到之前读过的那一行去了。&lt;/p&gt;
&lt;p&gt;快速阅读是建立在我们的头脑与眼睛不一样，不需要一次只读一个字或一个句子。我们的头脑可以在一瞥之间掌握一个句子或段落。——只要眼睛能提供足够的资讯。&lt;/p&gt;
&lt;p&gt;因此快速阅读能力其实是矫正眼睛阅读时的逗留与倒退，让我们跟着大脑的运作的快速度来阅读，而不是跟着眼睛的慢动作阅读。&lt;/p&gt;
&lt;p&gt;矫正方法：&lt;/p&gt;
&lt;p&gt;利用双手训练自己的眼睛，跟着章节段落移动得越来越快。强迫自己的眼睛跟着手部在书本上的动作移动。一旦眼睛能跟着手移动时，我们就能读到那些句子了。继续练习下去，继续增快手的动作，等到我们发觉之前，阅读速度已经比以前快两三倍了。&lt;/p&gt;
&lt;p&gt;理解力的问题&lt;/p&gt;
&lt;p&gt;没有经过分析阅读，就无法理解一本书。分析阅读是想要理解一本书的基本要件。&lt;/p&gt;
&lt;p&gt;评语：也就是说检视阅读只能增进对这本书的了解，要想真正理解一本书，一定要进入下一个阅读层次，分析阅读?&lt;/p&gt;
&lt;p&gt;在第一次阅读一本难读的书时，不用企图了解每一个字句。这是最最重要的一个规则。&lt;/p&gt;
&lt;p&gt;检视阅读的两个步骤都可以当作是要开始做分析阅读之前的预备动作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有系统略读，就是准备要了解这本书的架构。&lt;/li&gt;
&lt;li&gt;粗浅的阅读，是阅读者想要了解全书内容的一个必要步骤。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;疑问：&lt;/p&gt;
&lt;p&gt;Q:略读的习惯应该是用不着花太多的时间。对于略读应该花多少时间算合适的呢？如技术文档的阅读时间又如何定量呢？&lt;/p&gt;
&lt;p&gt;A:几分钟，最多不过2-3个小时。这个看情况而定，原则上就是要慢不该慢到不值得，快不该快到有损于满足于理解。选个合适的时间，主动投入地最好能完整地把一本书检视阅读完，中间不要逗留停顿。一本书最多也不会超过2-3个小时吧。&lt;/p&gt;
&lt;p&gt;Q:什么是对的阅读方向？&lt;/p&gt;
&lt;p&gt;A:就是粗浅的阅读规则：头一次面对一本难读的书的时候，从头到尾先读完一遍，碰到不懂的地方不用停下来查询或思索。&lt;/p&gt;
&lt;p&gt;Q:怎么依照读完的性质与复杂程度，来决定用什么样的速度检视阅读呢？&lt;/p&gt;
&lt;p&gt;A:这个完全看读者的理解能力和阅读技巧了，总之原则上就是要限时，尽快得读完，当然，是在能理解的速度上去读，而不是哗啦啦就翻过去了，什么都没看懂。&lt;/p&gt;
&lt;p&gt;Q:训练自己的快速阅读能力，目前我是读得太慢了，有什么技巧么？战术技巧。&lt;/p&gt;
&lt;p&gt;A:参见逗留与倒退。有意识地通过手指训练自己的快速阅读能力。&lt;/p&gt;
&lt;p&gt;3、分析阅读&lt;/p&gt;
&lt;p&gt;分析阅读的规则：第一阶段&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;知道自己在读的是哪一类书（依照书本的种类与主题作分类）。&lt;/li&gt;
&lt;li&gt;使用一个单一的句子，或一段话来叙述整本书的内容。（整体性，用最简短的句子说出整本书在谈些什么）&lt;/li&gt;
&lt;li&gt;将书中重要篇章列举出来，说明它们如何按照顺序组成一个整体的架构。（强调复杂度，按照顺序与关系，列出全书的重要部分。将全书的纲要拟出来，再将各个部分的纲要也一一列出）&lt;/li&gt;
&lt;li&gt;发现作者的意图，即找出作者要问的问题。（找出作者在问的问题，或作者想要解决的问题）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分析阅读的规则：第二阶段&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;找出关键字，与作者达成共识【遇到不了解的字词需要深思、做记号】&lt;/li&gt;
&lt;li&gt;将一本书中最重要的句子圈出来，找出其中的主旨。&lt;/li&gt;
&lt;li&gt;找出作者的论述，重新架构这些论述的前因后果，以明白作者的主张。&lt;/li&gt;
&lt;li&gt;找出作者的解答。【确认作者解决了哪些问题，还有哪些是未解决的。未解决的中哪些是作者认为自己无法解决的】&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分析阅读的规则：第三阶段&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;要求读者先完整地了解一本书，不要急着开始评论（赞同、反对）。&lt;/li&gt;
&lt;li&gt;不要争强好辩或盲目反对&lt;/li&gt;
&lt;li&gt;将知识上的不同意见看作是大体上可以解决的问题，要为自己不同的意见找到理论基础。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;书籍的分类&lt;/p&gt;
&lt;p&gt;论说性的书：主要目的是传达知识。主要内容是由一些观点、理论、假设、推断所组成。&lt;/p&gt;
&lt;p&gt;理论性的作品是在教你这是什么，实用性的作品在教你如何去做你想要做的事，或者你认为应该做的事。&lt;/p&gt;
&lt;p&gt;历史的本质就是口述的故事，历史家在描述历史时，通常会带有个人色彩——个人的评论、观察或意见。&lt;/p&gt;
&lt;p&gt;哲学老师会觉得以前没有被其他哲学老师教过的学生比较好教，而科学老师会希望学生已经被其他科学老师有所训练过。&lt;/p&gt;
&lt;p&gt;注：哲学的思考方式不同，思考方式固化的不好理解哲学；而科学需要试验训练，需要基础，没有基础科学知识实践训练的学生一片空白，则需要从头教起。&lt;/p&gt;
&lt;p&gt;疑问：&lt;/p&gt;
&lt;p&gt;Q:如何判断自己再读的是哪一类书呢？通过书的上架建议？&lt;/p&gt;
&lt;p&gt;A:严格来讲，任何一本教我们如何生活，该做什么，不该做什么，同时说明做了会有什么奖赏，不做会有什么惩罚的伦理的书，不论我们是否同意他的结论，都得认定这是实用的书。&lt;/p&gt;
&lt;p&gt;拿经济学来说，经济行为报告，数据分析研究这类是理论性的，而讲到我们如何认知经济生活环境，如何用经济学判断做事的，则是实用的书。&lt;/p&gt;
&lt;p&gt;再比如康德的《纯粹理性批判》是理论性的，告诉我们关于知，为什么知；而《实践理性批判》则是如何自我管理，怎么做的实用性的书。&lt;/p&gt;
&lt;p&gt;任何分析讨论的书都是理论的书，而关于政府的问题的书呢，政府问题是实际问题，因此是实际的书。&lt;/p&gt;
&lt;p&gt;质疑某件事的有效性是理论，而质疑任何事的目的，是实用。&lt;/p&gt;
&lt;p&gt;实用的书内容常出现——应该、应当、好、坏、结果、意义等字眼，而理论性作品常说是，没有应该，应当。&lt;/p&gt;
&lt;p&gt;Q:质疑某件事的有效性是理论，而质疑任何事的目的，是实用。这句话怎么理解？为什么这么说呢？&lt;/p&gt;
&lt;p&gt;A:某件事的有效性讨论的是对不对，存不存在的问题，没讨论这件事该不该做。而质疑任何事的目的是实用的，因为它质疑的是目的，应该这样，不应该那样，希望改变目的，改变行为，是实用的。&lt;/p&gt;
&lt;p&gt;Q:如何理解这句话——如果一本理论的书所强调的内容，超乎你日常、例行、正常生活的经验，那就是科学的书，否则就是一本哲学的书？&lt;/p&gt;
&lt;p&gt;A:科学一般会有特殊经验，如实验室实验，特定环境下实验等，需要发挥想象力。而哲学家所提出来的事实或观察，不会超越一般人的生活经验。&lt;/p&gt;
&lt;p&gt;科学家是以实验为基础，或仰赖精确的观察研究，而哲学家只是坐在摇椅上的思考者。&lt;/p&gt;
&lt;p&gt;科学家会从他特殊经验实验的结果作举证，哲学家却会议人类的共通性作例证。&lt;/p&gt;
&lt;p&gt;透视一本书——找出书的整体性组织架构&lt;/p&gt;
&lt;p&gt;一本书组成的各个部分之间没有有机的关联，一定不会形成一个整体（充其量只是集合体，注意整体和集合体的区别）。这就像是一堆砖头，跟一栋由砖头建造起来的房子是有区别的。一本好书，就像一栋好房子，每个部分都要很有秩序地排列起来。这也是为什么最好的书，也是可读性最高的书的理由之一。&lt;/p&gt;
&lt;p&gt;论说性的书开宗明义就会将要点写在第一段文字中。&lt;/p&gt;
&lt;p&gt;找出架构是读者的责任，设计架构是作者的责任。&lt;/p&gt;
&lt;p&gt;作者拟定了纲要，以写出一本好书。而读者拟定自己的纲要，才能读得明白。&lt;/p&gt;
&lt;p&gt;所有精彩绝伦的细节，都是为了烘托他的高潮而准备的，在找出结构大纲中，大可删去。&lt;/p&gt;
&lt;p&gt;注：这一点我需要特别注意，本末倒置，我们知道高潮的精彩，但在做阅读理解或者总结故事整体结构时并不需要加入，那都是细节，要懂得提炼整体架构。&lt;/p&gt;
&lt;p&gt;一个作者，特别是好的作者，会经常想要帮助你整理出他书中的重点。&lt;/p&gt;
&lt;p&gt;注：这个可以从《论持久战》中经常地体会到，特别是毛喜欢用设问句来让读者更清晰地理解他的观点和论述，通过设问也把读者会遇到的困惑很好地解答出来。&lt;/p&gt;
&lt;p&gt;一本书的整体精神可以有各种不同的阐释，没有哪一种一定对。&lt;/p&gt;
&lt;p&gt;注：一千个人眼中有一千种哈姆雷特。但对于技术类的来说则比较唯一，因为客观可实验。&lt;/p&gt;
&lt;p&gt;内容大纲模板（优秀的书才适用）：&lt;/p&gt;
&lt;p&gt;全书分为X个部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第一部分&lt;br/&gt;这部分又分为X段落：
&lt;ol&gt;&lt;li&gt;第一段落&lt;br/&gt;该段落又有X个重点：
&lt;ol&gt;&lt;li&gt;第一个重点&lt;/li&gt;
&lt;li&gt;第二个重点&lt;/li&gt;
&lt;li&gt;第X个重点&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;第二段落&lt;/li&gt;
&lt;li&gt;第X段落&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;第二部分&lt;/li&gt;
&lt;li&gt;第X部分&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一本书的作者在开始写作时，都是有一个问题或一连串的问题（主要、次要等），而这本书的内容就是一个答案，或许多答案。&lt;/p&gt;
&lt;p&gt;扩展举例：&lt;/p&gt;
&lt;p&gt;使用一个单一的句子，或一段话来叙述整本书的内容。&lt;/p&gt;
&lt;p&gt;A:以国富论为例，国富论是在探讨国家财富的资源。任何一个以劳力分工为主的经济体制，都要考虑到薪资的给付，资本利润的回收，积欠地主的租金等关系，这些就是物品架构的基本因素。本书讨论到如何更多元化地有效运用资本，并从金钱的起源和使用，谈到积累资本及使用资本。本书借着检验不同国家在不同状况下的富裕发展，比较了不同的政经系统，讨论了自由贸易的好处。&lt;/p&gt;
&lt;p&gt;阅读与写作的互惠技巧&lt;/p&gt;
&lt;p&gt;A:写作与阅读是一体两面的事，就像教书与被教一样。&lt;/p&gt;
&lt;p&gt;与作者找出共通的词义&lt;/p&gt;
&lt;p&gt;找出词义——阅读理解中的选择题——生词的意思&lt;/p&gt;
&lt;p&gt;A:利用上下文自己已经了解的所有子句，来推敲出你所不了解的那个字的意义。关键字列清单，并在旁边一栏列出这些字词的重要意义，发现用语与专业术语之间的关系。&lt;/p&gt;
&lt;p&gt;同义字：两个词表示相同意义。如启发和领悟在文中都表示理解力的增进。&lt;/p&gt;
&lt;p&gt;一个字词可能有好几种词义，而一个词义也可能有好几个字词的表达方式。&lt;/p&gt;
&lt;p&gt;判断作者的主旨&lt;/p&gt;
&lt;p&gt;找出关键句：&lt;/p&gt;
&lt;p&gt;当我们碰到作者认为最重要的地方时，应该会特别吃力。在读这些部分时应该特别仔细才好。&lt;/p&gt;
&lt;p&gt;有些作者会帮助我们找出关键句，在这些字句下画下划线或标粗等强调重点。&lt;/p&gt;
&lt;p&gt;有少数书会将主旨写在前面，用很明显的位置来加以说明——欧几里得。&lt;/p&gt;
&lt;p&gt;有些作者会用提出问题的方式，设问句来突出重点，如毛的论持久战。&lt;/p&gt;
&lt;p&gt;错误的阅读者会为了一个自己感兴趣的句子而暂停，却不会为了感到困扰的句子而暂停，这是不对的。&lt;/p&gt;
&lt;p&gt;找出主旨：&lt;/p&gt;
&lt;p&gt;“用你自己的话来说”，是测验你懂不懂一个句子的主旨的最佳方法。理想上，你应该能用完全不同的用语说出同样的意义。而不是只会重复作者的话，或在前后顺序上作一些小小的改变，这时你最好怀疑自己是否真的了解了这句话。可以用翻译成外语的方法测试自己的理解是否达到。&lt;/p&gt;
&lt;p&gt;注：费曼技巧。能用自己的话向别人表达出作者的意思，并能使他听得懂，理解得了，这样除了能让别人理解，也加深了自己的理解和记忆。在面对科学题数学题等阅读时，最好能举一反三（举例），融会贯通。才能避免知道2+2=4却不知道4-2=2的尴尬。&lt;/p&gt;
&lt;p&gt;一个读者如果不能经由文字语言看出意思与主旨，就永远不能作相关作品的比较（主题阅读）。&lt;/p&gt;
&lt;p&gt;找出论述：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，要记住所有的论述都包含了一些声明（理由和结论）。&lt;/li&gt;
&lt;li&gt;其次，要区别出两种论述的不同之处（归纳法和演绎法）。&lt;/li&gt;
&lt;li&gt;找出作者认为哪些事情是假设，哪些是能证实的话有根据的，以及哪些是不需要证实的自明之理。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Q:怀疑是智慧的开始，从书本上学习跟从大自然学习是一样的。这句话怎么理解？&lt;/p&gt;
&lt;p&gt;A:有怀疑，有疑问，去探索，寻找答案。就像沙漠中的仙人掌能在如此缺水的环境下生存的原因？有疑问，去追寻，就有答案。&lt;/p&gt;
&lt;p&gt;扩展阅读：&lt;/p&gt;
&lt;p&gt;归纳法是以一个或多个特殊的事实证明某种共通的概念，而演绎法是以连串的通则来证明更进一步的共通概念。两种的区别在于作者是用推论来证实主张（演绎法），还是用实验来证实主张（归纳法）。&lt;/p&gt;
&lt;p&gt;每个论述的开端有两种开始的方法或地方：一种是作者和读者都同意的假设，一种是不论作者和读者都无法否认的自明之理（公理、定理）。&lt;/p&gt;
&lt;p&gt;公正地评断一本书&lt;/p&gt;
&lt;p&gt;一个人如果不能自动自发地运用独立的判断力，他根本就不能学习到任何东西。或许他可以受训练，却不能受教。&lt;/p&gt;
&lt;p&gt;Q:最能学习的读者，也就是最能批评的读者。如何理解这句话？&lt;/p&gt;
&lt;p&gt;A:因为这样的读者有用心在阅读，而阅读时会提问，会产生疑惑，会质疑，读者会根据作者的述说和自己的独立判断，对作者的主旨和论述做出评价。&lt;/p&gt;
&lt;p&gt;Q:光是努力，并不足以称得上受教，读者必须懂得如何评断一本书,读者必需懂得如何才能了解一本书的内容。这句话的意思是指在能完全了解一本书时，还要能做出自己的评判？&lt;/p&gt;
&lt;p&gt;A:对，读完完全理解了作者的意思还不够，还要对此做出评价。作者说的是真实的么？认可作者所说的么？是全部认可，还是部分认可，都要哪些？展开说说。&lt;/p&gt;
&lt;p&gt;扩展阅读：&lt;/p&gt;
&lt;p&gt;Q:一个人在台上演讲，台下的人冒出来说你错了，提出尖锐的问题,而他并不知道你在说什么。这时候要怎么处理？&lt;/p&gt;
&lt;p&gt;A:对于这样的批评，你唯一能做的便是有礼貌地请他们重述你的论点，再说明他们对你的非难之处。如果他们做不到，或者是不能用他们自己的话重述你的观点，你就知道他们其实并不了解你在说什么。这时你不理会他们的批评是绝对有道理的。他们的意见无关紧要，因为那些只是毫无理解的批评而已。（应对喷子，愤青，键盘侠之道）&lt;/p&gt;
&lt;p&gt;一个人在与别人对话时，就算有不同的意见，最后还是有希望达成共识。他应该准备好改变自己的想法，才能改变别人的想法。他永远要先想到自己可能误解了，或是在某一个问题上有盲点。在争论之中，一个人绝不能忘了这是教导别人，也是自己受教的一个机会。&lt;/p&gt;
&lt;p&gt;赞同或反对作者&lt;/p&gt;
&lt;p&gt;理想化的辩论需要满足三个条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;不带情绪争论，就事论事，避免争论流于情绪化。&lt;/li&gt;
&lt;li&gt;把自己的前提或假设说出来，要在设定的假设中提出异议。&lt;/li&gt;
&lt;li&gt;尽力尝试不偏不倚，避免派别之争。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现实中的辩论需要遵循的四个声明（向作者声明）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;你的知识不足。&lt;/li&gt;
&lt;li&gt;你的知识有错误。&lt;/li&gt;
&lt;li&gt;你的推论不合逻辑，无法令人信服。&lt;/li&gt;
&lt;li&gt;你的分析不够完整。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;教你如何辩论反驳。&lt;/p&gt;
&lt;p&gt;通常，在科学和历史中，前人缺乏的知识都是由后来的人发掘出来的。科技的进步与时间的延长，使得大部分的研究调查都能做到这一点。（科研都是站在巨人的肩膀上）但在哲学领域中，状况却可能相反。似乎时间越久远，知识似乎只有衰退，而毫无增进。&lt;/p&gt;
&lt;p&gt;有许多书值得精读，但有更多的书只要浏览一下就行了。要成为一个好读者，就要懂得依照一本书的特质，运用不同的阅读技巧来阅读。&lt;/p&gt;
&lt;p&gt;Q:一个读得很广泛，却读不精的人，与其值得赞美，不然值得同情。就像霍布斯所说：“如果我像一般人一样读那么多书，我就跟他们一样愚蠢了。”&lt;/p&gt;
&lt;p&gt;意思是不是说要学习某样东西，关键并不在读多，而在于选一本好书来读精才是王道？就像我中学时图书馆借了一本化学书日夜研究，后面把化学成绩直线提高了一样？还有，霍布斯是哲学家、政治家、社会学家 ，是不是哲学才这样，科学研究不是？&lt;/p&gt;
&lt;p&gt;A:无论是什么学科，都是这样。当然，在科学研究中，我们也在意知识的广度，首先要像检视阅读一样了解技术中的知识，前沿方向，而在运用中则除了用，还需要知道为什么要用这项技术，怎么更好地用，这项技术的优势背后的原理是什么，这些是需要精读、仔细了解的。&lt;/p&gt;
&lt;p&gt;辅助阅读&lt;/p&gt;
&lt;p&gt;所谓的“内在阅读”指的是阅读书籍的本身，除了书籍本身之外，任何辅助阅读我们都可以称作是“外在的阅读”。&lt;/p&gt;
&lt;p&gt;在寻找外力帮助之前，最好自己一个人阅读。如果你经常这么做，最后你会发现越来越不需要外界的助力了。（在尽力依照内在阅读的规则读完一本书后，还有不理解的部分时才去寻找外在的帮助）&lt;/p&gt;
&lt;p&gt;外在的辅助来源：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;相关经验&lt;/li&gt;
&lt;li&gt;其他的书&lt;/li&gt;
&lt;li&gt;导读与摘要&lt;/li&gt;
&lt;li&gt;工具书&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;相关经验&lt;/p&gt;
&lt;p&gt;两种形态的经验：一般经验和特殊经验（特殊经验只有当一个人遇到困难时才会用得上，如特殊实验室试验，生产bug，原始部落生活经验等）。&lt;/p&gt;
&lt;p&gt;其他的书辅助阅读：&lt;/p&gt;
&lt;p&gt;后人的作品总是受到前人的影响。如果我们先读前一位的作品，他可能会帮助你了解后人的作品。阅读彼此相关的书籍，依照写作的时间顺序来读，对你了解最后写的作品有很大帮助。&lt;/p&gt;
&lt;p&gt;比起科学和小说类的书，历史与哲学笔记需要阅读相关的书籍。&lt;/p&gt;
&lt;p&gt;导读与摘要：&lt;/p&gt;
&lt;p&gt;导读要在读者阅读完全书有不理解的部分时才能去看；而摘要这可以关注书的主题和确定这是不是你想要读的书。&lt;/p&gt;
&lt;p&gt;工具书:&lt;/p&gt;
&lt;p&gt;字典和百科全书，互联网搜索。&lt;/p&gt;
&lt;p&gt;明白工具书或搜索引擎能回答哪些问题，不能回答哪些问题时，这本工具书对你才是有用的。【什么是幸福？】&lt;/p&gt;
&lt;p&gt;对一无所知的人来说，工具书可说是毫无用处。工具书并不是茫然无知的指南。&lt;/p&gt;
&lt;p&gt;注：这一点说到命门了:就简单的说在技术上，大家对于同一个bug都使用搜索引擎去寻找问题产生的原因和解决办法，可有的人很快就能找到，而有的人怎么都找不到，甚至连看都看不懂，导致看不下去。这其中还是因为自身的知识储备太少了，不知道如何向搜索引擎提问，也不知道如何取寻找答案，不知道自己想问的是什么，也不知道如何去海量的查询结果中寻找自己想要的答案，心急，看不下去，其实本质还是基础不够扎实，知识量太低，到哪都是门槛，怎么夸得过去？&lt;/p&gt;
&lt;p&gt;如果一开始阅读就要查很多生字的话，你就一定会跟不上整本书的条理。&lt;/p&gt;
&lt;p&gt;注：这就像看一篇技术文章或者学习一项技术时，里面有一堆的技术词汇看不懂，严重阻碍了学习的热情和进度，极度地打击自信心，导致看不下去，这就是基础知识不够全面，平时不注意积累基础知识。&lt;/p&gt;
&lt;p&gt;百科全书不是追求知识最理想的途径。&lt;/p&gt;
&lt;p&gt;注：因为只表述一些客观事实，或者一些科普性知识、历史等，无法使人获得理解力，启发性有限。&lt;/p&gt;
&lt;p&gt;如何使用工具书：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;问一个明智的问题&lt;/li&gt;
&lt;li&gt;知道在哪里找到你要找的答案。【知道自己问的是哪一类问题，在哪一类的工具书或技术领域里取找答案】&lt;/li&gt;
&lt;li&gt;如何使用工具书或搜索引擎&lt;/li&gt;
&lt;li&gt;知道自己想要找的是什么，在哪一种工具书中能找到这样的东西。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;11章结尾有分析阅读的总结&lt;/p&gt;
&lt;p&gt;扩展阅读：&lt;/p&gt;
&lt;p&gt;读联邦党人文集前要先看美国的邦联条例和美国宪法，而读这两个之前要先看孟德斯鸠的论法的精神和卢梭的社会契约论。——辅助阅读的需要，就像想学spring需要先学java语言一样。&lt;/p&gt;
&lt;p&gt;4、主题阅读&lt;/p&gt;
&lt;p&gt;主题阅读的要求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;要知道对一个特定的问题来说，所牵涉的绝对不是一本书而已。&lt;/li&gt;
&lt;li&gt;要知道就总的来说，应该读的是哪些书？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第二个要求比第一个要求难做到。&lt;/p&gt;
&lt;p&gt;阅读的主题也是跟着阅读走的，而不是事前就能定出来的。&lt;/p&gt;
&lt;p&gt;注：这是因为当要确定一个主题时，会在选定的时候发现范围越来越广，因此有必要重新审视和确定主题的目标和范围，特别是对于像爱等比较泛的主题的确定。&lt;/p&gt;
&lt;p&gt;检视阅读是读者在做主题阅读时的主要的工具和手段。在为主题阅读收集好书单后，第一件事便是检视书单上所有的书。这样做的作用有二：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;让我们对自己想要研究的主题有个清晰的概念，有利于后面针对性地做分析阅读。&lt;/li&gt;
&lt;li&gt;能帮我们简化书单到一个合理的程度。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主题阅读是最主动的一种阅读法。&lt;/p&gt;
&lt;p&gt;主题阅读的目的是为了解决自己的问题（研究、课题、运用）才阅读，而不是为了读这本书而阅读。&lt;/p&gt;
&lt;p&gt;在做主题阅读中，是书在服务你，而不是你在服务书。分析阅读一本书时，是把书当作主人，供他使唤；而做主题阅读时，却一定要做书的主人。&lt;/p&gt;
&lt;p&gt;主题阅读的五个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;找到相关的章节。【在主题阅读中，你关心的主题才是基本的重点，而不是你阅读的书】&lt;/li&gt;
&lt;li&gt;带引作者与你达成共识。【创建一组词汇，强迫作者使用你的语言来描述观点论证，拒绝作者描述观点的词汇】&lt;/li&gt;
&lt;li&gt;厘清问题。【建立一组不偏不倚的主旨，列出可以说得明白的问题，让书单作者来回答】&lt;/li&gt;
&lt;li&gt;界定议题。【人对一个主题有不同的观点，因而产生争议】&lt;/li&gt;
&lt;li&gt;分析讨论。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;问题的提出：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首选确定作者是否确定我们在研究的概念或现象的存在，或者这种概念有一种特质有关的问题。&lt;/li&gt;
&lt;li&gt;如果确定，这进一步问，这个现象是如何被发现，或这个概念是如何表现出来的有关的问题。&lt;/li&gt;
&lt;li&gt;与回答问题所产生的影响有关的问题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;主题阅读追求的是绝对客观又公正的，或者说是辩证的客管，简单的说，就是要能面面俱到，而自己并不预设立场（中立：方法——不断回头参阅诸多作者的原文，重新再阅读相关的章节）。&lt;/p&gt;
&lt;p&gt;主题阅读有两个阶段。一个是准备阶段，另一个是主题阅读本身。&lt;/p&gt;
&lt;p&gt;一、主题阅读的准备阶段&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;针对要研究的主题，设计一份实验性的书目。可以参考图书馆目录、专家的建议与书中的书目索引。&lt;/li&gt;
&lt;li&gt;浏览这份书目上所有的书，确定哪些与主题相关，并对主题建立起清楚的概念。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一、主题阅读：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;浏览所有在第一阶段被认定与主题相关的书，找出最相关的章节。&lt;/li&gt;
&lt;li&gt;根据主题创造出一套中立的词汇，带引作者与你达成共识——无论作者是否实际用到这些词汇，几乎所有作者观点论述都可以用这套词汇来诠释。&lt;/li&gt;
&lt;li&gt;建立一个中立的主旨，列出一连串的问题——无论作者是否明白谈过这些问题，所有或大多数的作者都要能解读为针对这些问题提供了他们的回答。&lt;/li&gt;
&lt;li&gt;界定主要及次要的议题。然后将作者针对各个问题的不同意见整理陈列在各个议题之旁。要记住，各个作者之间，不见得一定存在着某些议题。有时候，需要针对一些不是作者主要关心范围的事情，把他的观点解读，才能建构出这种议题。&lt;/li&gt;
&lt;li&gt;分析这些讨论。把问题和议题按顺序排列，以求突显主题。比较有共通性的议题，要放在比较没有共通性的议题之前。各个议题之间的关系也要清楚地界定出来。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意：理想上，要一直保持对话式的梳离与客观。每当要解读某个作家对一个议题的观点时，必须从他自己的文章中引一段话来并列。（即除了用自己的词义表达作者的观点外，还要引述原文佐证）&lt;/p&gt;
&lt;p&gt;疑问：&lt;/p&gt;
&lt;p&gt;Q:为什么在做研究学习时要做主题阅读？&lt;/p&gt;
&lt;p&gt;A:做主题阅读才能知道如何比别人读得快一点。如果阅读每一本书或每一篇文章都花上同样的时间与努力，结果可能是该花精神好好阅读的书却没有读好，倒把时间花在那些不太值得注意的书上了。在做主题阅读时，我们可以通过熟练使用检视阅读，用非常短的时间发现，这本书谈的内容对我们研究的主题到底重不重要。判断一本书是否需要回头再读一遍，以获得启发；或者虽然有趣丰富，但毫无启发性，不值得重读。&lt;/p&gt;
&lt;p&gt;Q:分析阅读的目标与主题阅读的目标有什么不同？&lt;/p&gt;
&lt;p&gt;A:分析阅读的主要目标是了解要读的这本书，其技巧只适用于单一的作品；而主题阅读的目标是我们研究的主题，我们会从大量相关的书中检视阅读乃至对必要的书进行分析阅读找出主旨，论述进行讨论分析。&lt;/p&gt;
&lt;p&gt;Q:主题阅读要如何知道应该读的是哪些书？&lt;/p&gt;
&lt;p&gt;A:主题工具书，搜索引擎，相关课题或研究，朋友的建议。&lt;/p&gt;
&lt;p&gt;Q:主题阅读提问的问题。这些问题怎么整理呢？才能便于说明主题的本身与讨论的内容。&lt;/p&gt;
&lt;p&gt;A:问题的提出：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首选确定作者是否确定我们在研究的概念或现象的存在，或者这种概念有一种特质有关的问题。&lt;/li&gt;
&lt;li&gt;如果确定，这进一步问，这个现象是如何被发现，或这个概念是如何表现出来的有关的问题。&lt;/li&gt;
&lt;li&gt;与回答问题所产生的影响有关的问题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Q:主题阅读其实就是读者自己通过想要研究的主题来进行自己设置的分析阅读，只是阅读从一本书，变成自己从众多的书单中找出问题答案编排出自己的一本书的或文章的分析阅读。是么？&lt;/p&gt;
&lt;p&gt;A:分析阅读的所有规则，只要照分析阅读的最后一章所述略加调整，就同样适用于主题阅读。&lt;/p&gt;
&lt;p&gt;三、阅读不同读物的方法（重点方法论）&lt;/p&gt;
&lt;p&gt;如何阅读实用型的书&lt;/p&gt;
&lt;p&gt;作者前面谈过的分析阅读的规则，一般来说是适用于论说性的作品——也就是一种传达知识的书。&lt;/p&gt;
&lt;p&gt;任何实用型的书都不能解决该书所关心的实际问题。&lt;/p&gt;
&lt;p&gt;注：因为实际的问题只能靠行动来解决。也就是说，想要学习和理解作者所想传达的知识，必须动手实践，正映那句——纸上得来终觉浅，绝知此事要躬行。所以，对于目前我最要紧要学习的技术书，一定要动手，不动手无法深入理解领会这些知识，难怪我学完之后就忘了，一部分是因为没有复习，另一部分便是我操作实践太少。（理论性的作品可以解决资金提出的问题）&lt;/p&gt;
&lt;p&gt;只有行动能解决问题。Only action can solve the problem 。&lt;/p&gt;
&lt;p&gt;实用型的书分为两种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种是说明规则的，如烹饪书、驾驶指南。无论其中谈论到什么问题，都是为了说明规则而来的。&lt;/li&gt;
&lt;li&gt;一种是阐述形成规则的原理，许多伟大的经济、政治、道德巨著属于这一类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在评断一本理论性的书时，读者必须观察他自己与作者之间的原理与假设的一致性或差异性。&lt;/p&gt;
&lt;p&gt;在评断一本实用性的书时，所有的事都与结果及目标有关。因此，如果所达到的目的是我们不关心或不期望的结果，我们是不会有半点兴趣的。&lt;/p&gt;
&lt;p&gt;评论：这里说的实用性的书对于我们来说就是目标导向型的书或知识，如果我们用不到或者学了不知道干什么，那么在缺失目标的情况下我们其实是不关心结果如何的，也变很容易半途而废或者失去兴趣，没有学到知识。所以，对于实用性的知识，一定要以目标为导向地去学习，这样才能事半功倍。这里我深有体会，平时一开始想学个比如设计模式的知识，但是学着学着因为只是为了学而学，而不是去用，需要用，或者说要求有学习成果，所以学到不懂的或者学到一半更或者打开设计模式的书时心思总是飘忽到别的地方去，也就不能深入地理解设计模式的知识。而当我看reids时说redis可以用来保证订单的唯一性时，忽然之间想到想了解一个东西——我们是如何保证订单的唯一性时，于是乎便去深究代码，发现就是用redis来实现的，也发现了其实就是通过redis的原子性和单线程的特性来实现的。具体的实现就是在创建订单时通过时间和今天的订单count增加（redis的increment）来组合出订单号。&lt;/p&gt;
&lt;p&gt;阅读任何一种实用书时，一定要问自己的两个主要问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一，作者的目的是什么？&lt;/li&gt;
&lt;li&gt;第二，他建议用什么方法达到这个目的？&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以原理为主的书要比以规则为主的书还要难回答这两个问题。&lt;/p&gt;
&lt;p&gt;实用书的作者多少都是个雄辩家或宣传家。因为他必须要能打动你的心智，激起你的情绪反应，左右你的意志。&lt;/p&gt;
&lt;p&gt;实际的思考与行动除了需要理智以外，情感也是重要的因素。没有人可以不受到感动，却认真采取实际评论或行动的。&lt;/p&gt;
&lt;p&gt;作者的“性格”在实用书中比理论书中还要来得重要，像要了解与评断一本道德的论述、政治论文或经济论著，需要了解一点作者的人格、生活与时代背景。&lt;/p&gt;
&lt;p&gt;实用型的书：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;整体来说，这本书到底在谈些什么？&lt;/li&gt;
&lt;li&gt;作者细部说了什么，怎么说的？找出主要的想法、声明与论点，这些作者想要传达的信息。（作者要表达的主题框架列出来，检视阅读必答）&lt;/li&gt;
&lt;li&gt;这本书说得有道理么？真实么？是全部有道理，还是部分有道理？（对这本书做出自己的判断，分析阅读必答）&lt;/li&gt;
&lt;li&gt;这本书跟你有什么关系？采取行动。实用型的书在认可作者观点时，这时候表示会采取行动，按照作者希望的方式来行动。（就如同我认可如何阅读一本书而采取行动）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;重要更改：&lt;/p&gt;
&lt;p&gt;规则四：了解作者的目的是什么，找出作者想要你做什么？&lt;/p&gt;
&lt;p&gt;规则八：了解他要你这么做的目的。&lt;/p&gt;
&lt;p&gt;疑问&lt;/p&gt;
&lt;p&gt;Q:理论性的原则会归纳出出色的行事规则。指理论指导实践？&lt;/p&gt;
&lt;p&gt;A:对。&lt;/p&gt;
&lt;p&gt;Q：实用性的书的具体分类，都包含哪些？书籍的分类？&lt;/p&gt;
&lt;p&gt;实用型的书分为两种类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种是说明规则的，如烹饪书、驾驶指南。无论其中谈论到什么问题，都是为了说明规则而来的。&lt;/li&gt;
&lt;li&gt;一种是阐述形成规则的原理，许多伟大的经济、政治、道德巨著属于这一类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Q：如何辨别一本谈实用原理的书？&lt;/p&gt;
&lt;p&gt;A:谈实用原理的书所谈的总是人类行为领域中，怎样可能做得更好或更糟。&lt;/p&gt;
&lt;p&gt;如何阅读想象文学（小说）&lt;/p&gt;
&lt;p&gt;小说主要是运用想象力。&lt;/p&gt;
&lt;p&gt;想象文学会尽量使用文字潜藏的多重定义，好让这些字特有的多元性增加文章的丰富性与渲染力。想象文学依赖文字中的言外之意。&lt;/p&gt;
&lt;p&gt;论说性作品要传达的是知识，而想象文学是在阐述一个经验本身。&lt;/p&gt;
&lt;p&gt;论说性作品教导我们基本的原理，而想象文学则藉由创造我们可以参照学习的经验，教导我们衍生的意义。&lt;/p&gt;
&lt;p&gt;阅读想象文学时不要做：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要抗拒想象文学带给你的影响力。&lt;/li&gt;
&lt;li&gt;在想象文学中，不要去找共识、主旨或论述。&lt;/li&gt;
&lt;li&gt;不要用适用于传递知识的，与真理一致的标准来批评小说。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;调整分析阅读的规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将想象文学作品分类——抒情诗、小说、戏剧&lt;/li&gt;
&lt;li&gt;抓住整本书的大意——简要地说明剧情&lt;/li&gt;
&lt;li&gt;发现整本书各个部分是如何架构起来的，想象文学的各个部分不能单独阅读&lt;/li&gt;
&lt;li&gt;在你衷心感激作者试着为你创造的经验之前，不要批评一本想象的作品（即对于小说，我们不应该反对或赞成，而是喜欢或不喜欢，为什么喜欢/不喜欢【客观地指出书中某些事件造成你的反感，哪些地方好，哪些地方不好】）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;小说的要素是插曲、事件、角色与他们的思想、言语、感觉及行动。&lt;/p&gt;
&lt;p&gt;阅读小说要想亲临现场一样，变成其中的一个成员，愿意与其中的角色做朋友，运用同情心与洞察力参与事件的发生，就像你会为朋友的遭遇所做的事一样。&lt;/p&gt;
&lt;p&gt;阅读故事、戏剧与诗的一些建议&lt;/p&gt;
&lt;p&gt;如何阅读故事书：&lt;/p&gt;
&lt;p&gt;快读，并且全心全意地读。理想上说，一个故事应该一口气读完。尽量试着活在作者的故事中。&lt;/p&gt;
&lt;p&gt;我们不期望记住每一个名字，许多人不过是背景人物，好衬托出主角的行动而已，我们主要记住重要的人物，就像我们接触聊了一个小时的人，或者约好约会的妹子。就算一开始不太清楚，也不要焦虑，待全部读完在回顾时，就会了解事件的关联与活动的前后顺序了。&lt;/p&gt;
&lt;p&gt;小说能满足我们潜意识或意识中许多的需要。&lt;/p&gt;
&lt;p&gt;关于一个坏故事最惹人讨厌的一点是，一个人受奖励或惩罚一点都不合情合理。&lt;/p&gt;
&lt;p&gt;如何阅读戏剧：&lt;/p&gt;
&lt;p&gt;假装看到演出的实景。&lt;/p&gt;
&lt;p&gt;把剧本大声地读出来。——慢慢读，带有感情读，就像观众在听一样。&lt;/p&gt;
&lt;p&gt;悲剧的精髓在时间，即缺乏时间，没有时间去思考，衡量轻重。时间不等人。&lt;/p&gt;
&lt;p&gt;如何阅读抒情诗：&lt;/p&gt;
&lt;p&gt;关于诗有一种很古老的观念，那就是诗人要向内心深处探索，才能创造出他们的诗句。从这个角度来看，任何人在任何时间，只要处于孤独又敏感的状态，都可以创造出诗句来。&lt;/p&gt;
&lt;p&gt;大部分好的抒情诗中，都存在着一些冲突。如爱与时间、生与死、短暂与永恒等。&lt;/p&gt;
&lt;p&gt;规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不论你觉得自己懂不懂，都要一口气读完，不要停。&lt;/li&gt;
&lt;li&gt;重读一遍，并大声地读出来（基本，一定要的）&lt;/li&gt;
&lt;li&gt;了解作者及这首诗的创作背景&lt;/li&gt;
&lt;li&gt;一遍又一遍地读，品位。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Q:为什么问一个人为什么喜欢小说时,回答不出来？&lt;/p&gt;
&lt;p&gt;A:人们可能是好的小说读者，却不是好的评论者。这些说不出他们喜欢小说的理由的人，可能只是阅读了表象，而没有深入内里。&lt;/p&gt;
&lt;p&gt;Q:艾默生说：“美的本身就是存在的唯一理由。怎么理解这句话？&lt;/p&gt;
&lt;p&gt;A:美是稀缺资源，人人趋之若鹜。&lt;/p&gt;
&lt;p&gt;如何阅读历史书&lt;/p&gt;
&lt;p&gt;托尔斯泰对历史有这样的理论：造成人类行为的原因很多，又太复杂，而且动机又深深隐藏在潜意识中，因此我们无法知道为什么会发生某些事。&lt;/p&gt;
&lt;p&gt;为了追求真相，我们必须从更多不同的角度来观察才行。&lt;/p&gt;
&lt;p&gt;阅读历史书，不是因为历史书上描述的世界有多么的精准，而是因为它对后代发生的事有一定的影响力。阅读历史是为了想要了解目前发生的事。（世界是在循环？）&lt;/p&gt;
&lt;p&gt;Q:阅读历史是为了想要了解目前发生的事。这句话怎么理解，世界是在循环中么？我们通过阅读历史来发现目前发生的一切与历史的相像之处，从而指导行为？&lt;/p&gt;
&lt;p&gt;A:读历史，如果只想指导当时真正发生了什么事，那就不会从任何一个好的历史学家手中学到东西。读历史的原因就像修昔底德说的。他写历史的原因是：希望经由他所观察到的错误，以及个人受到的灾难与国家所受到的苦楚，将来的人们不会重蹈覆辙。二千五百年前，雅典人与斯巴达人所犯的错误，今天人们仍然同样在犯——或至少是非常接近的错误——修昔底德以降，这样的戏码一再上演。&lt;/p&gt;
&lt;p&gt;所以读历史是为了以史为鉴，指导今天的人们不要犯相同的错误。&lt;/p&gt;
&lt;p&gt;阅读历史的两个要点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对感兴趣的事件或时期，尽可能阅读一种以上的历史书&lt;/li&gt;
&lt;li&gt;阅读历史时，不只要关心在过去某个时间、地点真正发生了什么事，还要读懂在任何时空之中，尤其是现在，人们为什么会有如此这般行动的原因。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如何阅读传记和自传&lt;/p&gt;
&lt;p&gt;按历史类阅读&lt;/p&gt;
&lt;p&gt;传记类型有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定案本（不能是活着的人）&lt;/li&gt;
&lt;li&gt;授权本传记（继承人或重要的朋友所写）&lt;/li&gt;
&lt;li&gt;一般传记&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;阅读当代事件&lt;/p&gt;
&lt;p&gt;要了解记者心中戴着什么样的过滤器（立场），要提出的问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;作者想要证明什么？&lt;/li&gt;
&lt;li&gt;作者想要说服谁？&lt;/li&gt;
&lt;li&gt;作者具有的特殊知识是什么？&lt;/li&gt;
&lt;li&gt;作者真的知道自己在说些什么吗？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;阅读当代事件（新闻报道等记者写作）写作时要注意：读者要擦亮眼睛！因为写作当代事件的作者可能在希望我们用某一种方式了解这件事的过程中，有他自己的利益考虑。就算他不这么想，他的消息来源也会这么想。要搞清楚他们的利益考虑，阅读任何东西都要小心翼翼。&lt;/p&gt;
&lt;p&gt;如何阅读科学与数学&lt;/p&gt;
&lt;p&gt;作者限定讨论范围：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种是传统中伟大的科学与数学的经典之作。&lt;/li&gt;
&lt;li&gt;一种是现代科普著作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;作者认为19世纪末之前，如牛顿达尔文伽利略他们的的科学著作对于一般读者并不排斥，而大多数现代科学著作并不关心门外汉读者的想法和是否理解。科学论文已经变成专家写给专家看的东西了，好处是这使科学的进步更加快速，因为专家之间彼此交换专业知识，能快速达到重点。&lt;/p&gt;
&lt;p&gt;评语：这就像设计模式的作者所说的那样，设计模式的科普有利于技术人员与专家之间通过术语快速地交流达成一致。通过约定来提高效率。&lt;/p&gt;
&lt;p&gt;注：这也就是一些讲原理的IT文章对于不懂这些技术及其背后的IT基础知识的读者来说无疑天书，是其不友好的根本原因。读者必须掌握必要的专业知识才行。&lt;/p&gt;
&lt;p&gt;作者的目的：&lt;/p&gt;
&lt;p&gt;对于这一类科学与数学阅读的普通读者，如果不是该领域的专家，退一步阅读流行的科普书，要如何辨别哪些是好的哪些是坏的，最重要的是还要能在阅读好书时达到充分的理解。&lt;/p&gt;
&lt;p&gt;用萧伯纳的名言概括从事科学的人的分类：&lt;/p&gt;
&lt;p&gt;有能力的人，就去做。没有能力的人，就去教。&lt;/p&gt;
&lt;p&gt;作者推荐我们最少要阅读一些伟大的科学经典巨著，运用阅读论说性作品的规则，透过怀疑的训练，而释放出一个自由开放的心灵。&lt;/p&gt;
&lt;p&gt;要注意作者最初的假设，然后把他的假设与经过论证之后的结论作个区别。科学的客观不在于没有最初的偏见，而在于坦白承认。&lt;/p&gt;
&lt;p&gt;寻找主旨：科学作品的主要词汇通常都是一些不常见的科技用语。并经由这些词语找到主旨，主旨通常是很一般性的。&lt;/p&gt;
&lt;p&gt;科学方法分类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;归纳法。实验或观察得来的。&lt;/li&gt;
&lt;li&gt;演绎法。通过一家证明过的理论推导出新的理论。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;科学方法的重要性（动手实践）&lt;/p&gt;
&lt;p&gt;如果一本书不能启发一个人时，读者只有一个解决办法，就是自己亲身体验以获得必要的特殊经验。&lt;/p&gt;
&lt;p&gt;亲自动手做出伟大科学家所形容的实验，那也是他获得内心洞察力的来源，那么对于这本科学经典巨著，你就会有更深入的理解。&lt;/p&gt;
&lt;p&gt;评语：想要获得深入的理解，很多时候，特别是卡主或者迷惑不清的时候，更要亲自动手实践作者或者书本或者想学的知识所提到的技术的使用或者实验。跟着代码的思路去理解这个原理或者技术的由来。&lt;/p&gt;
&lt;p&gt;面对数学的问题&lt;/p&gt;
&lt;p&gt;数学其实是一种语言。&lt;/p&gt;
&lt;p&gt;学习语言时，我们要学习两次：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一次是学习如何说话&lt;/li&gt;
&lt;li&gt;第二次是学习如何阅读&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;只有当我们解决了基础的层次问题，即基础阅读中遇到的如不认识的字或语法句法问题时，我们的阅读能力才能更上一层楼。（生词，语法等基础一定要弄懂）&lt;/p&gt;
&lt;p&gt;评语：不积跬步无以至千里，所以在学习技术的时候基础一定要打好，学习某个技术如果需要哪些技术基础知识或者说在学习过程中发现有很多生僻的知识名词不懂，那说明基础太差了需要先补习补习好才能有效地阅读下去。&lt;/p&gt;
&lt;p&gt;当我们沟通的话题牵涉到情绪时，我们很难理解一些言外之意。数学却能让我们避免这样的问题。&lt;/p&gt;
&lt;p&gt;作者建议：花几个晚上把欧几里得的《几何原理》读好，就能克服对数学的恐惧心理。读完欧几里得，可以进一步，看看其他景点的希腊数学大师的作品——阿基米德、阿波罗尼乌斯，尼科马科斯。&lt;/p&gt;
&lt;p&gt;我们阅读的企图如果不是了解数学本身，而是想读一本有数学在内的科学书那么跳着略读反而是比较聪明的。&lt;/p&gt;
&lt;p&gt;当我们记住自己的责任不是成为这个主题的专家，而是去了解相关的问题，在阅读时就会轻松很多。&lt;/p&gt;
&lt;p&gt;评语：了解新的技术知识时一开始要抱着轻松了解的的心态去学习，而不是一入门就想着自己要成为这个领域的专家，这样就会让自己学习的时候轻松很多。&lt;/p&gt;
&lt;p&gt;阅读原创性科学巨著的两个难题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;他们只谈论一点相关的实验内容，即他们只报告出实验的结果。&lt;/li&gt;
&lt;li&gt;内容只包括一点数学。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;疑问&lt;/p&gt;
&lt;p&gt;Q:像对于一些新的技术,就像阅读科学著作一样，比如zookeeper，一直在用，但就是看不明白他的原理，那么我该通过怎样的阅读来理解它呢？&lt;/p&gt;
&lt;p&gt;A:看文章，看源码，看别人的分析。不是看不懂，是没有认真看。可以先大概地看一遍，对于zookeeper中用到的不懂的技术，词汇，可以在大概理解了后，如果有必要，则先去看这些技术，因为这是有连续性的，如果这些关键技术你不懂，那除了去学，没有别的办法？想要更好地了解这项技术，就要更好地了解这项技术使用的核心技术。&lt;/p&gt;
&lt;p&gt;Q:主旨通常是很一般性的？什么意思？&lt;/p&gt;
&lt;p&gt;A:举个例子：等腰三角形的内角相等。科学、数学的一般性表示这是个一般性结论，定理。复杂在于推导过程。&lt;/p&gt;
&lt;p&gt;Q:三段论法？&lt;/p&gt;
&lt;p&gt;A:所有的动物终有一死；所有的人都是动物；因此，所有的人终有一死。用包含关系推导结果。&lt;/p&gt;
&lt;p&gt;Q:拉瓦锡说：任何自然科学的分支都要包含三个部分：在这个科学主题中的连续事实，呈现这些事实的想法，以及表达这些事实的语言。怎么理解这句话？&lt;/p&gt;
&lt;p&gt;A:连续事实是举例，特殊的实验，而这些事实的想法就是推导出来的结论，表达这些事实的语言就是用一个定理或者公理表达出这种特性或结论。&lt;/p&gt;
&lt;p&gt;如何阅读哲学书&lt;/p&gt;
&lt;p&gt;亚里士多德：哲学来自怀疑。&lt;/p&gt;
&lt;p&gt;最伟大的哲学家所提出来的深刻问题。正是孩子们所提出的问题。能够保留孩子看世界的眼光，又能成熟地了解到保留这些问题的意义，确实是非常稀有的能力——拥有这种能力的人也才可能对我们的思想有重大的贡献。&lt;/p&gt;
&lt;p&gt;成人复杂的生活阻碍了寻找真理的途径，伟大的哲学家总能厘清生活的复杂，看出简单的差别。&lt;/p&gt;
&lt;p&gt;哲学领域区分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;理论或思辨型哲学（例如关于存在与变化的的问题）&lt;br/&gt;理论哲学分类：
&lt;ul&gt;&lt;li&gt;形而上学——探讨存在的问题&lt;/li&gt;
&lt;li&gt;自然哲学——探讨变化、演变的问题&lt;/li&gt;
&lt;li&gt;认知论——知识、认知，确定与不确定的问题&lt;/li&gt;
&lt;li&gt;伦理学&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;实用或规范的哲学（关于善于恶，好与坏，和我们应该做或探寻的事有关）
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;哲学思考的问题：&lt;/p&gt;
&lt;p&gt;第一顺位问题：世上存在及发生了什么事，或人类该做该追求的问题。&lt;/p&gt;
&lt;p&gt;第二顺位问题：关于我们在第一顺位问题中的知识，我们在回答第一顺位问题是的思考模式，我们如何用语言将思想表达出来等问题。&lt;/p&gt;
&lt;p&gt;第一顺位问题是一般读者门外汉感兴趣的，而第二顺位问题则像科学研究一样是专家之间的交流，不适合门外汉。&lt;/p&gt;
&lt;p&gt;哲学就是一种思考，别无他物。&lt;/p&gt;
&lt;p&gt;真正好的哲学并不是“纯”思维——脱离现实经验的思考。&lt;/p&gt;
&lt;p&gt;哲学家所提出来与回答的问题，并非全部都是真正哲学的问题。&lt;/p&gt;
&lt;p&gt;注：要区分哲学家回答的问题中哪些是哲学，哪些不是，不是的可以通过科学研究实验去验证出来。比如天体与地体的关系，天体运动。在没有望远镜宇宙物理的发展前，是个哲学问题。&lt;/p&gt;
&lt;p&gt;人们该过什么样的生活是个哲学问题。&lt;/p&gt;
&lt;p&gt;哲学的论述风格：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;哲学对话【由立场与观点的冲突来表达论说】&lt;/li&gt;
&lt;li&gt;哲学论文或散文【由哲学家直接叙述自己的观点】&lt;/li&gt;
&lt;li&gt;面对异议【从对立与冲突中，展现不同的观点，提出自己的解决方案】&lt;/li&gt;
&lt;li&gt;哲学系统化【用数学组织的方式整理哲学，不好】&lt;/li&gt;
&lt;li&gt;格言形式【名言警句类型】&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在阅读任何哲学作品时，最重要的就是要发现问题，或是找到书中想要回答的问题。&lt;/p&gt;
&lt;p&gt;作者会如何回答这些问题，完全受他的中心思想与原则的控制。&lt;/p&gt;
&lt;p&gt;柏拉图的中心思想与原则——有关哲学主题的对话，可能是人类所有活动中最重要的一个活动。一个人不论是为了任何理由而拒绝参与追求真理，都是人性最深沉的背叛。&lt;/p&gt;
&lt;p&gt;亚里士多德的中心思想与原则——幸福是善的完整，而不是最高的善，因为如果是那样，那就只有一种善了。&lt;/p&gt;
&lt;p&gt;康德的中心思想与原则——人类心智的局限。反对教条主义——只要凭着思考，用不着考虑本身的局限性，人类的知性就可以掌握最重要的真理。&lt;/p&gt;
&lt;p&gt;哲学作品几乎不陈述一些作者认为不证自明的主旨，这些主旨直接来自人类共有的经验。（生活经验）&lt;/p&gt;
&lt;p&gt;疑问&lt;/p&gt;
&lt;p&gt;Q:成人复杂的生活阻碍了寻找真理的途径，伟大的哲学家总能厘清生活的复杂，看出简单的差别。这句话怎么理解？&lt;/p&gt;
&lt;p&gt;A:哲学家能厘清生活的复杂，看出简单的差别。清官难断家务事相同的意思，被生活的繁杂所困扰，看不出其本质。&lt;/p&gt;
&lt;p&gt;Q:回答哲学问题，有严格的检验，以确认答案是否合乎逻辑。但这样的检验纯粹是来自一般的经验——你身而为人就有的经验，而不是哲学家才有的经验。如何通过这句话去验证他说的正确性，举个例子，如何检验呢？&lt;/p&gt;
&lt;p&gt;A:毛在论持久战中说抗战的优势与劣势的变化：虽然抗日战争中我们损失了人员，土地、文化被破坏等，损失了质和量；但我们的人员素质提升了，作战的经验增加了，全国人民更坚持抗日统一战线了，更多的人民动员起来了等等，这是我们提升的质和量。这是我们作为人就能理解的，他说的是对的，合乎逻辑，不需要懂得哲学才能分辨。&lt;/p&gt;
&lt;p&gt;Q:假装相信一些其实你并不相信的事，是很好的心智训练。当你越清楚自己的偏见时，你就越不会误判别人的偏见了。为什么这么说？&lt;/p&gt;
&lt;p&gt;A:假装相信一些其实你并不相信的事,比如相信人可以永生，这时候我们就会想象人可以永生是什么样的？为什么要获得永生，怎么达到永生？这其中头脑便会制造出可能的想象，赞同的论述；而本能中又会反驳自己，与自己展开论述，反驳，得到思维的锻炼，不断地思考对峙。&lt;/p&gt;
&lt;p&gt;而对于偏见，我们知道歧视外地人是偏见，如果别人也歧视外地人，那我们知道他们也带有偏见。三段论。&lt;/p&gt;
&lt;p&gt;事实：&lt;/p&gt;
&lt;p&gt;柏拉图和苏格拉底对哲学该讨论的问题都整理提问过了。&lt;/p&gt;
&lt;p&gt;康德受柏拉图的影响很大，他的书中会先谈到主要问题，然后有条不紊地从方方面面完整地讨论主题，最后，顺便再讨论一些特殊的问题。&lt;/p&gt;
&lt;p&gt;如何阅读社会科学（与人有关的科学）&lt;/p&gt;
&lt;p&gt;社会科学定义：诸如人类学、经济学、政治学、社会学的学科，都是组成社会科学的核心，几乎所有的社会科学家都会将这些学科归纳起来。大部分有关法律、教育、公共行政的作品，及一部分商业、社会服务的作品，再加上大量的心理学作品，都适合社会科学的定义。&lt;/p&gt;
&lt;p&gt;社会科学阅读的难点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作者任意引用社会科学的属于及观点，导致意义模糊不清。&lt;/li&gt;
&lt;li&gt;作者没有约定用语说明，导致词义不明。&lt;/li&gt;
&lt;li&gt;作品混杂，不是纯粹的论说性作品（最困难）&lt;/li&gt;
&lt;li&gt;需要掌握主题阅读能力。【因为阅读社会科学的着眼点是一个特殊事件或问题上，而非一个特殊的作者或一本书】&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;四、阅读与心智的成长&lt;/p&gt;
&lt;p&gt;所谓主动的阅读，就是能提出问题来。&lt;/p&gt;
&lt;p&gt;并不是所有的书或文章都读，像消遣、娱乐或讯息这类的阅读，无法增进阅读的技巧，也无法帮助我们心智的成长。而除非能增长心智，否则我们学不到东西。&lt;/p&gt;
&lt;p&gt;事实上，一本烂书根本不值得你花时间去努力，甚至根本不值得作这样的尝试，因为你努力半天还是一无所获。&lt;/p&gt;
&lt;p&gt;读一本好书会让你的努力有所回报，回馈分两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;阅读技巧的增进&lt;/li&gt;
&lt;li&gt;一本好书能教你了解这个世界及你自己&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;书的金字塔分类：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;百分之九十九的都是娱乐消遣、资讯类的书，只适合扫描一下就够了&lt;/li&gt;
&lt;li&gt;让你学习的书——学习如何阅读，如何生活——值得做一次分析阅读&lt;/li&gt;
&lt;li&gt;与你一起成长的书——书可以适应不同层次的需求。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;成功完成分析阅读后的书，重读后会发现书中的内容好像比记忆中的少了很多。原因是在这个阶段中你的心智成长了许多，头脑充实了，理解力也增进了。书籍本身并没有改变，改变是你自己。&lt;/p&gt;
&lt;p&gt;生命与心智的成长&lt;/p&gt;
&lt;p&gt;找出对你最有意义的书目：如果你将在一个无人荒岛中度过余生，可以带十本书，会选哪十本？&lt;/p&gt;
&lt;p&gt;找出内在的资源，过更美好的人类生活的挑战。&lt;/p&gt;
&lt;p&gt;我们的身体是有限制的，心智却没有限制。在力量与技巧上，身体不能无限制地成长，而我们的头脑却能无限地成长与发展下去。心智就跟肌肉一样，如果不常运用就会萎缩，心智的萎缩就是在惩罚我们不经常用脑。&lt;/p&gt;
&lt;p&gt;好的阅读，不只对我们的工作事业有帮助，更能帮助我们的心智保持活力与成长。&lt;/p&gt;
&lt;p&gt;工作（被动工作）、电视、收音机等围绕我们身边的娱乐资讯，这些都是心智的人为支撑物，它们会让我们觉得自己在动脑，因为我们要对外界的刺激作出反应。就像药品一样，一旦习惯后，需要的量就会越来越大。&lt;/p&gt;
&lt;p&gt;注：所以这就是我之前刷视频，看剧停不下来的原因。其实也有经济学的边际效用递减了的作用。&lt;/p&gt;
&lt;p&gt;五、自我要求的读者&lt;/p&gt;
&lt;p&gt;在阅读的时候想要保持清醒，或昏昏欲睡，注意看阅读的目标是什么。如果阅读的目标是获得利益——不论是心灵或精神上的成长——那就要保持清醒。&lt;/p&gt;
&lt;p&gt;Q:阅读完后猛然发现自己总结不出什么收获或者不知道自己获得了什么，得到了什么。感觉这本书读完好像收获很少或者付出没有回报的多？原因见下面作者的原话：&lt;/p&gt;
&lt;p&gt;A:悲哀的是，许多人尽管可以区分出阅读的获益与取乐之不同——其中一方是理解力的增进，另一方则是娱乐或只是满足一点点的好奇心——最后仍然无法完成他们的阅读目标。就算他们知道那本书该用什么样的方式来阅读，还是失败。原因就在他们不知道做个自我要求的阅读者，如何将精神集中在他们所做的事情上，而不会一无所获。&lt;/p&gt;
&lt;p&gt;评语：我就是这许多人之一，往往读一本书，在读的过程中总有很多感慨或者觉得很有意思或者道理或者深刻的话或故事或现象，但读完后让我写个总结，我就全忘光了，或者忘记了该如何下手，又或者忘记了重要的一些故事或论据，没法很好地总结出来。这其中之一就是我没有抱有目标目的去阅读。还有就是我没有做好笔记或者带着问题或疑问去寻求解答，寻求到解答后应该记下来。&lt;/p&gt;
&lt;p&gt;如果你的阅读目标是获得利益——不论是心灵或精神上的成长——你就得保持清醒，这也意味着在阅读时要尽可能地保持主动，同时还要做一番努力——而这番努力是会有回馈的。&lt;/p&gt;
&lt;p&gt;如果不能做一个自我要求的读者，那么即便有阅读方法，也会失败？原因就在他们不知道如何做个自我要求的阅读者，如何将精神集中在他们所做的事情上，而不会一无所获。&lt;/p&gt;
&lt;p&gt;主动阅读的核心：在阅读过程中要提出问题，并尝试去回答提出的问题。&lt;/p&gt;
&lt;p&gt;阅读原则：阅读的艺术就是要以适当的顺序提出适当的问题。&lt;/p&gt;
&lt;p&gt;关于一本书，一定要提出的四个主要问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;整体来说，这本书到底在谈些什么？找出书的主题，作者如何依次发展这个主题，如何逐步从核心主题分解出从属的关键议题来。（一句话或者简要概括主题，检视阅读必答）&lt;/li&gt;
&lt;li&gt;作者细部说了什么，怎么说的？找出注要的想法、声明与论点这些作者想要传达的信息。（作者要表达的主题框架列出来，检视阅读必答）&lt;/li&gt;
&lt;li&gt;这本书说得有道理么？是全部有道理，还是部分有道理？（对这本书做出自己的判断，分析阅读必答）&lt;/li&gt;
&lt;li&gt;这本书跟你有什么关系？从这本书中获得的知识或信息对读者你有什么意义？为什么要了解这些知识信息，有什么重要性或意义么？有必要了解么？（这本书与自己的联系，作用力，读了这本书的作用？以自己的判断来掌握这本书的整体或部分道理与意义，分析阅读必答）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为什么我们在阅读时会走神，注意力不集中，打瞌睡？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们不知道该如何努力阅读一本书。&lt;/li&gt;
&lt;li&gt;自身层次不够，欠缺有效运用自我提升的技巧，在挫折中产生了沮丧。&lt;/li&gt;
&lt;li&gt;能力不足，在阅读的时候就很吃力，需要提升自己的能力。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而除非我们能真正起身接触它们，把自己提升到同样的层次，否则你所挂念的这些好书只会使你厌倦而已。要保持主动的阅读，不只是要有意愿这么做而已，还要有技巧——能战胜最初觉得自己能力不足部分，进而自我提升的艺术。&lt;/p&gt;
&lt;p&gt;Q:都有哪些技巧来提升自己能力，提供阅读层次，让阅读的时候不会因吃力挫折太多弄不懂而退却？&lt;/p&gt;
&lt;p&gt;仅仅提出问题还不够，还要试着去回答这些问题。&lt;/p&gt;
&lt;p&gt;必须读（写）出言外之意，才会有更大的收获。&lt;/p&gt;
&lt;p&gt;为什么对阅读来说，在书上做笔记是不可或缺的事？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;这样会让你保持清醒。&lt;/li&gt;
&lt;li&gt;主动阅读是一种思考，而思考倾向于用语言表达出来。&lt;/li&gt;
&lt;li&gt;把阅读的感想写下来，有助于记住作者的思想。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;做笔记的方法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;画底线、括号。&lt;/li&gt;
&lt;li&gt;对段落或章节加星号（重要的10处内的地方）。&lt;/li&gt;
&lt;li&gt;对论证等顺序编号1,2,3,4.&lt;/li&gt;
&lt;li&gt;首页或尾页空白处记下重要论点或要点页码，记录个人的索引页码。&lt;/li&gt;
&lt;li&gt;空白页做笔记。对疑问章节段落空白处写来疑问问题和笔记答案等。&lt;/li&gt;
&lt;li&gt;首页或尾页空白处列出书中基本大纲与整体架构。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;分阅读层次记笔记：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检视阅读：结构笔记。提出重要问题，最后能记下答案（整体架构，不是细节）。&lt;/li&gt;
&lt;li&gt;分析阅读：概念笔记。&lt;/li&gt;
&lt;li&gt;主题阅读：概念笔记 + 辩证笔记（ 一场情境讨论的笔记）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;顺便一提，并不是每个人都清楚做一个艺术家是要照规则不断练习的。&lt;/p&gt;
&lt;p&gt;注：无论哪一项技术，技能，艺术，作品，领域，新的知识等等，在刚入行的时候对于普遍的规则和基本的原理我们是要记下来并熟练掌握的，这没有什么技巧可言，就是要知道，一定要牢记，哪怕一开始背下来。因为这是公理，就像化学一样，如果不掌握最基本的元素周期表，不能被下来，那根本就无从下手，犹记得自己高中化学一开始是那样的差，但后面我自己自学时，还是地不断地练习，背诵基本的知识，没有捷径可走，在过了基础期后，经过不断地学习训练，高中化学在后面班级里都是名列前茅，让我倍感欣慰。现在想想，之前学java其实也是如此，入门难，入门难，因为要掌握必要的基础，才能弄清楚编程，也才能为后面的学习做铺垫，没有基本知识的记忆和积累训练，如空中阁楼，无源之水无本之木，是入门不了的。所以，不要觉得基础难，入门难，新知识难，这是一个过程，没有入门知识的积累，是做不了的。&lt;/p&gt;
&lt;p&gt;疑问：&lt;/p&gt;
&lt;p&gt;Q:如何做一个自我要求的阅读者？&lt;/p&gt;
&lt;p&gt;A:主动阅读,而主动阅读的核心：在阅读过程中要提出问题，并尝试去回答提出的问题。&lt;/p&gt;
&lt;p&gt;一、提问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;整体来说，这本书到底在谈些什么？找出书的主题，作者如何依次发展这个主题，如何逐步从核心主题分解出从属的关键议题来。（一句话或者简要概括主题，检视阅读必答）&lt;/li&gt;
&lt;li&gt;作者细部说了什么，怎么说的？找出注要的想法、声明与论点这些作者想要传达的信息。（作者要表达的主题框架列出来，检视阅读必答）&lt;/li&gt;
&lt;li&gt;这本书说得有道理么？是全部有道理，还是部分有道理？（对这本书做出自己的判断，分析阅读必答）&lt;/li&gt;
&lt;li&gt;这本书跟你有什么关系？从这本书中获得的知识或信息对读者你有什么意义？为什么要了解这些知识信息，有什么重要性或意义么？有必要了解么？（这本书与自己的联系，作用力，读了这本书的作用？以自己的判断来掌握这本书的整体或部分道理与意义，分析阅读必答）&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;二、回答问题，必须读出言外之意，才会有更大的收获。&lt;/p&gt;
&lt;p&gt;三、做笔记。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;画底线、括号。&lt;/li&gt;
&lt;li&gt;对段落或章节加星号（重要的10处内的地方）。&lt;/li&gt;
&lt;li&gt;对论证等顺序编号1,2,3,4.&lt;/li&gt;
&lt;li&gt;首页或尾页空白处记下重要论点或要点页码，记录个人的索引页码。&lt;/li&gt;
&lt;li&gt;空白页做笔记。对疑问章节段落空白处写来疑问问题和笔记答案等。&lt;/li&gt;
&lt;li&gt;首页或尾页空白处列出书中基本大纲与整体架构。&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;如何阅读一本书思维导图&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/14404316-0f3414fb5ff446c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;如何阅读一本书.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 Jul 2020 17:01:00 +0000</pubDate>
<dc:creator>卡斯特梅的雨伞</dc:creator>
<og:description>如何阅读一本书——分析阅读Pre 前情介绍 作者： 莫提默.艾德勒 查尔斯.范多伦 初版：1940年，一出版就是全美畅销书榜首一年多。钢铁侠Elon.Musk学过。 需要注意的句子： 成功的阅读牵涉到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/castamere/p/13394791.html</dc:identifier>
</item>
<item>
<title>PHP入门之函数 - 雪痕*</title>
<link>http://www.cnblogs.com/lxfweb/p/13394763.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxfweb/p/13394763.html</guid>
<description>&lt;p&gt;之前对PHP的类型、运算符和流程控制简单说了一下。想了解的，这是地址。&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/lxfweb/p/13379841.html&quot;&gt;PHP入门之类型与运算符&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/lxfweb/p/13380271.html&quot;&gt;PHP入门之流程控制&lt;/a&gt;&lt;br/&gt;下面对函数简单说一下。&lt;/p&gt;

&lt;p&gt;为完成某一个功能的程序指令的合集，称为函数。函数分为自定义函数和系统函数。&lt;/p&gt;

&lt;p&gt;function 函数名(参数列表){&lt;br/&gt;语句；//函数(方法)主体&lt;br/&gt;return语句; //返回值&lt;br/&gt;}&lt;br/&gt;函数的使用，可以增加程序的复用性，如果一个应用程序的功能，需要反复使用，如果不使用函数，那么就是一直复制粘贴，复用性太差，如果使用函数，将这个功能封装，想用这个功能，直接调用这个函数，方便多了。&lt;br/&gt;举个例子。&lt;br/&gt;第一个页面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
function jisuan($sum1,$sum2,$oper){
    $res=0;
    switch ($oper){
        case &quot;+&quot;:
            echo $res=$sum1+$sum2;
            break;
        case &quot;-&quot;:
            echo $res=$sum1-$sum2;
            break;
        case &quot;*&quot;:
            echo $res=$sum1*$sum2;
            break;
        case &quot;/&quot;:
            echo $res=$sum1/$sum2;
            break;
        default:
            echo '输入有误';
            break;
            return $res;
    }
}
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个页面&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
require &quot;1.php&quot;;
$sum1=20;
$sum2=30;
$oper=&quot;+&quot;;
$res=jisuan($sum1,$sum2,$oper);   #这里可以直接用实参，比如 $res=jisuan(2,3,'*')  结果等于6。
echo $res;
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这里需要了解四个函数&lt;br/&gt;&lt;strong&gt;require()、require_once()&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;include()、include_once()&lt;/strong&gt;&lt;br/&gt;上面的两个不同之处是require只要包含就引入，而require_once是先判断有没有，有就不包含了，没有才包含。&lt;br/&gt;include和include_once的不同和require的不同一样。&lt;br/&gt;那么require的include的不同是什么呢？&lt;br/&gt;require遇到错误会报一个致命错误，终止程序。而include遇到错误会给一个警告，继续执行程序。&lt;br/&gt;举个例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a.php
&amp;lt;?php
   echo 'ok!';
}
?&amp;gt;
b.php                     #两个ok!都会输出。如果改为require_once,就只会输出一个ok!
&amp;lt;?php
 require 'a.php';
 require 'a.php';
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; a.php
&amp;lt;?php
   echo 'ok!';
}
?&amp;gt;
b.php                 #因为c不存在，所以会给一个警告，但是最后的hahaha还是会输出。如果改为require就会终止程序。
&amp;lt;?php
 include 'c.php';
 include 'a.php';
 echo 'hahaha'
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;深入理解函数调用，碰到函数就会 调用一个新栈。拿一段代码举例。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?php
function abc($n){
if($n&amp;gt;2){
abc(--$n);
}
echo '$n='.$n.'&amp;lt;br/&amp;gt;';    #输出结果是$n=2 $n=2 $n=3
}
abc(4);
?&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;函数的参数列表可以是多个，并且数据类型可以是任意的类型。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;函数的命名跟自定义变量一样，首字母只能使用_或者a_z或者A_Z。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;一个自定义函数中的变量是局部的，函数外不生效。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用global全局变量的时候，可使用函数外的变量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 28 Jul 2020 16:38:00 +0000</pubDate>
<dc:creator>雪痕*</dc:creator>
<og:description>#前言 之前对PHP的类型、运算符和流程控制简单说了一下。想了解的，这是地址。 PHP入门之类型与运算符 PHP入门之流程控制 下面对函数简单说一下。 #函数的基本概念 为完成某一个功能的程序指令的合</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lxfweb/p/13394763.html</dc:identifier>
</item>
<item>
<title>【高并发】如何实现亿级流量下的分布式限流？这些理论你必须掌握！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13394751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13394751.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;11.136738056013&quot;&gt;
&lt;p&gt;在互联网应用中，高并发系统会面临一个重大的挑战，那就是大量流高并发访问，比如：天猫的双十一、京东618、秒杀、抢购促销等，这些都是典型的大流量高并发场景。关于秒杀，小伙伴们可以参见我的另一篇文章《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MzE1NTIzNA==&amp;amp;mid=2247484357&amp;amp;idx=1&amp;amp;sn=23e6e38143704db0fa4588186b534e13&amp;amp;chksm=cee51c08f992951e5b883c55b788588f9cbc822e41694b5b4a334ea5d2dc0ae62a5d64e39dc2&amp;amp;token=1388808518&amp;amp;lang=zh_CN#rd&quot;&gt;【高并发】高并发秒杀系统架构解密，不是所有的秒杀都是秒杀！&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;关注【冰河技术】微信公众号，解锁更多【高并发】专题文章。&lt;/p&gt;
&lt;p&gt;注意：由于原文篇幅比较长，所以被拆分为：&lt;strong&gt;理论、算法、实战（HTTP接口实战+分布式限流实战）&lt;/strong&gt;三大部分。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;高并发系统限流&quot;&gt;高并发系统限流&lt;/h2&gt;
&lt;p&gt;短时间内巨大的访问流量，我们如何让系统在处理高并发的同时还能保证自身系统的稳定性？有人会说，增加机器就可以了，因为我的系统是分布式的，所以可以只需要增加机器就可以解决问题了。但是，如果你通过增加机器还是不能解决这个问题怎么办呢？而且这种情况下又不能无限制的增加机器，服务器的硬件资源始终都是有限的，在有限的资源下，我们要应对这种大流量高并发的访问，就不得不采取一些其他的措施来保护我们的后端服务系统了，比如：缓存、异步、降级、限流、静态化等。&lt;/p&gt;
&lt;p&gt;这里，我们先说说如何实现限流。&lt;/p&gt;
&lt;h2 id=&quot;什么是限流？&quot;&gt;什么是限流？&lt;/h2&gt;
&lt;p&gt;在高并发系统中，限流通常指的是：对高并发访问或者请求进行限速或者对一个时间内的请求进行限速来保护我们的系统，一旦达到系统的限速规则（比如系统限制的请求速度），则可以采用下面的方式来处理这些请求。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拒绝服务（友好提示或者跳转到错误页面）。&lt;/li&gt;
&lt;li&gt;排队或等待（比如秒杀系统）。&lt;/li&gt;
&lt;li&gt;服务降级（返回默认的兜底数据）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实，就是对请求进行限速，比如10r/s，即每秒只允许10个请求，这样就限制了请求的速度。从某种意义上说，限流，其实就是在一定频率上进行量的限制。&lt;/p&gt;
&lt;p&gt;限流一般用来控制系统服务请求的速率，比如：天猫双十一的限流，京东618的限流，12306的抢票等。&lt;/p&gt;
&lt;h2 id=&quot;限流有哪些使用场景？&quot;&gt;限流有哪些使用场景？&lt;/h2&gt;
&lt;p&gt;这里，我们来举一个例子，假设你做了一个商城系统，某个节假日的时候，突然发现提交订单的接口请求比平时请求量突然上涨了将近50倍，没多久提交订单的接口就超时并且抛出了异常，几乎不可用了。而且，因为订单接口超时不可用，还导致了系统其它服务出现故障。&lt;/p&gt;
&lt;p&gt;我们该如何应对这种大流量场景呢？一种典型的处理方案就是限流。当然了，除了限流之外，还有其他的处理方案，我们这篇文章就主要讲限流。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对稀缺资源的秒杀、抢购；&lt;/li&gt;
&lt;li&gt;对数据库的高并发读写操作，比如提交订单，瞬间往数据库插入大量的数据；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;限流可以说是处理高并发问题的利器，有了限流就可以不用担心瞬间高峰流量压垮系统服务或者服务雪崩，最终做到有损服务而不是不服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用限流同样需要注意的是：限流要评估好，测试好，否则会导致正常的访问被限流。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，后台回复 “&lt;strong&gt;设计模式&lt;/strong&gt;” 关键字领取《&lt;strong&gt;深入浅出Java 23种设计模式&lt;/strong&gt;》PDF文档。回复“&lt;strong&gt;Java8&lt;/strong&gt;”关键字领取《&lt;strong&gt;Java8新特性教程&lt;/strong&gt;》PDF文档。两本PDF均是由冰河原创并整理的超硬核教程，面试必备！！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，今天就聊到这儿吧！别忘了点个赞，给个在看和转发，让更多的人看到，一起学习，一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200716220443647.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 Jul 2020 16:35:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 在互联网应用中，高并发系统会面临一个重大的挑战，那就是大量流高并发访问，比如：天猫的双十一、京东618、秒杀、抢购促销等，这些都是典型的大流量高并发场景。关于秒杀，小伙伴们可以参见我的另一篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13394751.html</dc:identifier>
</item>
<item>
<title>数据分析2020年全国各省高考成绩分布情况 - SChen1024</title>
<link>http://www.cnblogs.com/hugochen1024/p/gaokao.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hugochen1024/p/gaokao.html</guid>
<description>&lt;p&gt;各个省份的高考题目不尽相同，成绩也是个人发挥，但是如果我将各个省市的成绩统一到100分，北京的平均成绩居然是最高的，最低的成绩居然是广西&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;217.61044845739&quot;&gt;
&lt;h2 id=&quot;开始&quot;&gt;开始&lt;/h2&gt;
&lt;p&gt;突发奇想， 想看下高考成绩的分布， 如果把每个省市的成绩划线成0-100 分会怎么样，简单的来说， 认为最高分的考了100分，最低分考了0分， 计算一下各个分数段的人数就好了，&lt;/p&gt;
&lt;p&gt;顺便可以用这个数据看每个省市的一本线划分比率，还有其他相关的数据，&lt;/p&gt;
&lt;p&gt;看起来还是比较简单的， 动手试试&lt;/p&gt;
&lt;h2 id=&quot;数据收集&quot;&gt;数据收集&lt;/h2&gt;
&lt;p&gt;网上找了一下， 每年的高考人数， 现在已经超过千万人高考了，河南更是超过了100万，&lt;br/&gt;数据来源：新浪教育 &lt;a href=&quot;https://edu.sina.cn/zt_d/gkbm&quot;&gt;https://edu.sina.cn/zt_d/gkbm&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;省/市&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2020年&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2019年&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2018年&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2017年&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2016年&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2015年&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2014年&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2013年&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;2012年&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;全国&lt;/td&gt;
&lt;td&gt;1071万↑&lt;/td&gt;
&lt;td&gt;1031万↑&lt;/td&gt;
&lt;td&gt;975万↑&lt;/td&gt;
&lt;td&gt;940万&lt;/td&gt;
&lt;td&gt;940万↓&lt;/td&gt;
&lt;td&gt;942万↑&lt;/td&gt;
&lt;td&gt;939万↑&lt;/td&gt;
&lt;td&gt;912万↓&lt;/td&gt;
&lt;td&gt;915万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;河南&lt;/td&gt;
&lt;td&gt;115.8万↑&lt;/td&gt;
&lt;td&gt;100万+↑&lt;/td&gt;
&lt;td&gt;98.3万↑&lt;/td&gt;
&lt;td&gt;86.3万↑&lt;/td&gt;
&lt;td&gt;82万↑&lt;/td&gt;
&lt;td&gt;77.2万↑&lt;/td&gt;
&lt;td&gt;72.4万↓&lt;/td&gt;
&lt;td&gt;71.63万↓&lt;/td&gt;
&lt;td&gt;80.5万↑&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;广东&lt;/td&gt;
&lt;td&gt;78.8万↑&lt;/td&gt;
&lt;td&gt;76.8万↑&lt;/td&gt;
&lt;td&gt;75.8万↑&lt;/td&gt;
&lt;td&gt;75.7万↑&lt;/td&gt;
&lt;td&gt;73.3万↓&lt;/td&gt;
&lt;td&gt;75.4万↓&lt;/td&gt;
&lt;td&gt;75.6万↑&lt;/td&gt;
&lt;td&gt;72.7万↑&lt;/td&gt;
&lt;td&gt;69.2万↑&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;四川&lt;/td&gt;
&lt;td&gt;67万↑&lt;/td&gt;
&lt;td&gt;65万↑&lt;/td&gt;
&lt;td&gt;62万↑&lt;/td&gt;
&lt;td&gt;58.3万↑&lt;/td&gt;
&lt;td&gt;57.13万&lt;/td&gt;
&lt;td&gt;超57万&lt;/td&gt;
&lt;td&gt;57.17万↑&lt;/td&gt;
&lt;td&gt;54万↑&lt;/td&gt;
&lt;td&gt;53.8万↑&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;河北&lt;/td&gt;
&lt;td&gt;62.48万↑&lt;/td&gt;
&lt;td&gt;55.96万↑&lt;/td&gt;
&lt;td&gt;48.6万↑&lt;/td&gt;
&lt;td&gt;43.6万↑&lt;/td&gt;
&lt;td&gt;42.31万↑&lt;/td&gt;
&lt;td&gt;40.48万↓&lt;/td&gt;
&lt;td&gt;41.82万↓&lt;/td&gt;
&lt;td&gt;44.98万↓&lt;/td&gt;
&lt;td&gt;45.93万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;安徽&lt;/td&gt;
&lt;td&gt;52.38万↑&lt;/td&gt;
&lt;td&gt;51.3万↑&lt;/td&gt;
&lt;td&gt;49.9万&lt;/td&gt;
&lt;td&gt;49.9万↓&lt;/td&gt;
&lt;td&gt;50.99万↓&lt;/td&gt;
&lt;td&gt;54.6万↑&lt;/td&gt;
&lt;td&gt;52.7万↑&lt;/td&gt;
&lt;td&gt;51.1万↑&lt;/td&gt;
&lt;td&gt;50.6万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;湖南&lt;/td&gt;
&lt;td&gt;53.7万↑&lt;/td&gt;
&lt;td&gt;50万↑&lt;/td&gt;
&lt;td&gt;45.2万↑&lt;/td&gt;
&lt;td&gt;41.1万↑&lt;/td&gt;
&lt;td&gt;40.16万↑&lt;/td&gt;
&lt;td&gt;38.99万↑&lt;/td&gt;
&lt;td&gt;37.8万↑&lt;/td&gt;
&lt;td&gt;37.3万↑&lt;/td&gt;
&lt;td&gt;35.2万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;山东&lt;/td&gt;
&lt;td&gt;53万↓&lt;/td&gt;
&lt;td&gt;55.99万↑&lt;/td&gt;
&lt;td&gt;59.2万↑&lt;/td&gt;
&lt;td&gt;58.3万↓&lt;/td&gt;
&lt;td&gt;60.2万↑&lt;/td&gt;
&lt;td&gt;69.61万↑&lt;/td&gt;
&lt;td&gt;55.8万↑&lt;/td&gt;
&lt;td&gt;50万↓&lt;/td&gt;
&lt;td&gt;51万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;广西&lt;/td&gt;
&lt;td&gt;50.7万↑&lt;/td&gt;
&lt;td&gt;46万↑&lt;/td&gt;
&lt;td&gt;40万↑&lt;/td&gt;
&lt;td&gt;36.5万↑&lt;/td&gt;
&lt;td&gt;33万余↑&lt;/td&gt;
&lt;td&gt;近31万↓&lt;/td&gt;
&lt;td&gt;31.5万↑&lt;/td&gt;
&lt;td&gt;29.8万↑&lt;/td&gt;
&lt;td&gt;28.5万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;贵州&lt;/td&gt;
&lt;td&gt;47万↑&lt;/td&gt;
&lt;td&gt;45.8万↑&lt;/td&gt;
&lt;td&gt;44.1万↑&lt;/td&gt;
&lt;td&gt;41.2万↑&lt;/td&gt;
&lt;td&gt;37.38万↑&lt;/td&gt;
&lt;td&gt;33.05万↑&lt;/td&gt;
&lt;td&gt;29.27万↑&lt;/td&gt;
&lt;td&gt;24.78万↓&lt;/td&gt;
&lt;td&gt;24.8万↑&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;江西&lt;/td&gt;
&lt;td&gt;38.94万↓&lt;/td&gt;
&lt;td&gt;42.1万↑&lt;/td&gt;
&lt;td&gt;38万↑&lt;/td&gt;
&lt;td&gt;36.5万↑&lt;/td&gt;
&lt;td&gt;36.06万↑&lt;/td&gt;
&lt;td&gt;35.46万↑&lt;/td&gt;
&lt;td&gt;32.59万↑&lt;/td&gt;
&lt;td&gt;27.43万↑&lt;/td&gt;
&lt;td&gt;26.9万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;湖北&lt;/td&gt;
&lt;td&gt;39.48万↑&lt;/td&gt;
&lt;td&gt;38.4万↑&lt;/td&gt;
&lt;td&gt;37.4万↑&lt;/td&gt;
&lt;td&gt;36.2万↑&lt;/td&gt;
&lt;td&gt;36.14万↓&lt;/td&gt;
&lt;td&gt;36.84万↓&lt;/td&gt;
&lt;td&gt;40.27万↓&lt;/td&gt;
&lt;td&gt;43.8万↓&lt;/td&gt;
&lt;td&gt;45.7万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;江苏&lt;/td&gt;
&lt;td&gt;34.89万↑&lt;/td&gt;
&lt;td&gt;33.9万↑&lt;/td&gt;
&lt;td&gt;33万&lt;/td&gt;
&lt;td&gt;33万↓&lt;/td&gt;
&lt;td&gt;36.04万↓&lt;/td&gt;
&lt;td&gt;39.29万↓&lt;/td&gt;
&lt;td&gt;42.57万↓&lt;/td&gt;
&lt;td&gt;45.1万↓&lt;/td&gt;
&lt;td&gt;47.4万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;山西&lt;/td&gt;
&lt;td&gt;32.6万↑&lt;/td&gt;
&lt;td&gt;31.4万↑&lt;/td&gt;
&lt;td&gt;30.5万↓&lt;/td&gt;
&lt;td&gt;31.7万↓&lt;/td&gt;
&lt;td&gt;33.9万↓&lt;/td&gt;
&lt;td&gt;34.22万↑&lt;/td&gt;
&lt;td&gt;34.16万↓&lt;/td&gt;
&lt;td&gt;35.8万↓&lt;/td&gt;
&lt;td&gt;36.1万↑&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;云南&lt;/td&gt;
&lt;td&gt;34.3万↑&lt;/td&gt;
&lt;td&gt;32.6万↑&lt;/td&gt;
&lt;td&gt;30万↑&lt;/td&gt;
&lt;td&gt;29.3万↑&lt;/td&gt;
&lt;td&gt;28万↑&lt;/td&gt;
&lt;td&gt;27.21万↑&lt;/td&gt;
&lt;td&gt;25.59万↑&lt;/td&gt;
&lt;td&gt;23.6万↑&lt;/td&gt;
&lt;td&gt;21万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;陕西&lt;/td&gt;
&lt;td&gt;32.23万↓&lt;/td&gt;
&lt;td&gt;32.59万↑&lt;/td&gt;
&lt;td&gt;31.9万&lt;/td&gt;
&lt;td&gt;31.9万↓&lt;/td&gt;
&lt;td&gt;32.8万余↓&lt;/td&gt;
&lt;td&gt;34.4万↓&lt;/td&gt;
&lt;td&gt;35.3万↓&lt;/td&gt;
&lt;td&gt;36.65万↓&lt;/td&gt;
&lt;td&gt;37.53万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;浙江&lt;/td&gt;
&lt;td&gt;32.57万↑&lt;/td&gt;
&lt;td&gt;31.5万↑&lt;/td&gt;
&lt;td&gt;30.6万↑&lt;/td&gt;
&lt;td&gt;29.1万↓&lt;/td&gt;
&lt;td&gt;30.74万↓&lt;/td&gt;
&lt;td&gt;31.79万↑&lt;/td&gt;
&lt;td&gt;30.86万↓&lt;/td&gt;
&lt;td&gt;31.3万↓&lt;/td&gt;
&lt;td&gt;31.6万↑&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;重庆&lt;/td&gt;
&lt;td&gt;28.3万↑&lt;/td&gt;
&lt;td&gt;26.4万↑&lt;/td&gt;
&lt;td&gt;25万↑&lt;/td&gt;
&lt;td&gt;24.7万↓&lt;/td&gt;
&lt;td&gt;24.88万↓&lt;/td&gt;
&lt;td&gt;25.54万↑&lt;/td&gt;
&lt;td&gt;25.06万↑&lt;/td&gt;
&lt;td&gt;23.5万↑&lt;/td&gt;
&lt;td&gt;23万↑&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;辽宁&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;24.4万↑&lt;/td&gt;
&lt;td&gt;18.5万↓&lt;/td&gt;
&lt;td&gt;20.8万↓&lt;/td&gt;
&lt;td&gt;21.82万↓&lt;/td&gt;
&lt;td&gt;22.51万↓&lt;/td&gt;
&lt;td&gt;23.9万↓&lt;/td&gt;
&lt;td&gt;25.4万↓&lt;/td&gt;
&lt;td&gt;25.6万↑&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;甘肃&lt;/td&gt;
&lt;td&gt;26.31万↑&lt;/td&gt;
&lt;td&gt;21.8万↓&lt;/td&gt;
&lt;td&gt;27.3万↓&lt;/td&gt;
&lt;td&gt;28.5万↓&lt;/td&gt;
&lt;td&gt;29.6万余↓&lt;/td&gt;
&lt;td&gt;30.38万↑&lt;/td&gt;
&lt;td&gt;29.7万↑&lt;/td&gt;
&lt;td&gt;28.3万↓&lt;/td&gt;
&lt;td&gt;29.6↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;黑龙江&lt;/td&gt;
&lt;td&gt;21.1万↑&lt;/td&gt;
&lt;td&gt;20.6万↑&lt;/td&gt;
&lt;td&gt;16.9万↓&lt;/td&gt;
&lt;td&gt;18.8万↓&lt;/td&gt;
&lt;td&gt;19.7万↓&lt;/td&gt;
&lt;td&gt;19.8万↓&lt;/td&gt;
&lt;td&gt;20.4万↓&lt;/td&gt;
&lt;td&gt;20.8万↓&lt;/td&gt;
&lt;td&gt;21万↑&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;福建&lt;/td&gt;
&lt;td&gt;20.26万↓&lt;/td&gt;
&lt;td&gt;20.78万↑&lt;/td&gt;
&lt;td&gt;20万↑&lt;/td&gt;
&lt;td&gt;18.8万↑&lt;/td&gt;
&lt;td&gt;17.5万↓&lt;/td&gt;
&lt;td&gt;18.93万↓&lt;/td&gt;
&lt;td&gt;25.5万&lt;/td&gt;
&lt;td&gt;25.5万↑&lt;/td&gt;
&lt;td&gt;25万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;内蒙古&lt;/td&gt;
&lt;td&gt;197901↑&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;19.5万↓&lt;/td&gt;
&lt;td&gt;19.8万↓&lt;/td&gt;
&lt;td&gt;20.11万↓&lt;/td&gt;
&lt;td&gt;18.4万↓&lt;/td&gt;
&lt;td&gt;18.8万↓&lt;/td&gt;
&lt;td&gt;19.3万↑&lt;/td&gt;
&lt;td&gt;18.95万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;新疆&lt;/td&gt;
&lt;td&gt;22.93万↑&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;20.7万↑&lt;/td&gt;
&lt;td&gt;18.4万↑&lt;/td&gt;
&lt;td&gt;16.61万↑&lt;/td&gt;
&lt;td&gt;16.05万↓&lt;/td&gt;
&lt;td&gt;16.26万↑&lt;/td&gt;
&lt;td&gt;15.87万↑&lt;/td&gt;
&lt;td&gt;15.47万↑&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;吉林&lt;/td&gt;
&lt;td&gt;15万余↑&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;15万↑&lt;/td&gt;
&lt;td&gt;14.3万↓&lt;/td&gt;
&lt;td&gt;14.85万↓&lt;/td&gt;
&lt;td&gt;13.76万↓&lt;/td&gt;
&lt;td&gt;16.02万↑&lt;/td&gt;
&lt;td&gt;15.9万↓&lt;/td&gt;
&lt;td&gt;16.2万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;宁夏&lt;/td&gt;
&lt;td&gt;60298↓&lt;/td&gt;
&lt;td&gt;7.17万↑&lt;/td&gt;
&lt;td&gt;6.9万&lt;/td&gt;
&lt;td&gt;6.9万&lt;/td&gt;
&lt;td&gt;6.9万↑&lt;/td&gt;
&lt;td&gt;6.7万↑&lt;/td&gt;
&lt;td&gt;6.4万↑&lt;/td&gt;
&lt;td&gt;5.87万↓&lt;/td&gt;
&lt;td&gt;6.02万↑&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;海南&lt;/td&gt;
&lt;td&gt;57336↓&lt;/td&gt;
&lt;td&gt;5.9万↑&lt;/td&gt;
&lt;td&gt;5.8万↑&lt;/td&gt;
&lt;td&gt;5.7万↓&lt;/td&gt;
&lt;td&gt;6.04万↓&lt;/td&gt;
&lt;td&gt;6.2万↑&lt;/td&gt;
&lt;td&gt;6.1万↑&lt;/td&gt;
&lt;td&gt;5.6万↑&lt;/td&gt;
&lt;td&gt;5.5万↑&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;北京&lt;/td&gt;
&lt;td&gt;49225↓&lt;/td&gt;
&lt;td&gt;5.9万↓&lt;/td&gt;
&lt;td&gt;6.3万↑&lt;/td&gt;
&lt;td&gt;6万↓&lt;/td&gt;
&lt;td&gt;6.12万↓&lt;/td&gt;
&lt;td&gt;6.8万↓&lt;/td&gt;
&lt;td&gt;7.05万↓&lt;/td&gt;
&lt;td&gt;7.27万↓&lt;/td&gt;
&lt;td&gt;7.3万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;青海&lt;/td&gt;
&lt;td&gt;46620↑&lt;/td&gt;
&lt;td&gt;44313↑&lt;/td&gt;
&lt;td&gt;4.2万↓&lt;/td&gt;
&lt;td&gt;4.6万↑&lt;/td&gt;
&lt;td&gt;4.5万↑&lt;/td&gt;
&lt;td&gt;4.2万↑&lt;/td&gt;
&lt;td&gt;3.97万↓&lt;/td&gt;
&lt;td&gt;4.06万↑&lt;/td&gt;
&lt;td&gt;3.8万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;天津&lt;/td&gt;
&lt;td&gt;56258↑&lt;/td&gt;
&lt;td&gt;5.5万&lt;/td&gt;
&lt;td&gt;5.5万↓&lt;/td&gt;
&lt;td&gt;5.7万↓&lt;/td&gt;
&lt;td&gt;约6万↓&lt;/td&gt;
&lt;td&gt;6.1万↓&lt;/td&gt;
&lt;td&gt;约6万&lt;/td&gt;
&lt;td&gt;6.3万↓&lt;/td&gt;
&lt;td&gt;6.4万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;上海&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;5万&lt;/td&gt;
&lt;td&gt;5万+&lt;/td&gt;
&lt;td&gt;约5.1万&lt;/td&gt;
&lt;td&gt;5.1万↓&lt;/td&gt;
&lt;td&gt;5.2万↓&lt;/td&gt;
&lt;td&gt;5.3万↓&lt;/td&gt;
&lt;td&gt;5.5万↓&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;西藏&lt;/td&gt;
&lt;td&gt;32973↑&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;2.5万↓&lt;/td&gt;
&lt;td&gt;2.8万↑&lt;/td&gt;
&lt;td&gt;2.4万↑&lt;/td&gt;
&lt;td&gt;2.1万↑&lt;/td&gt;
&lt;td&gt;1.96万↑&lt;/td&gt;
&lt;td&gt;1.89万↓&lt;/td&gt;
&lt;td&gt;1.9万↑&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;hr/&gt;&lt;p&gt;这个表的数据是统计的全国各个省市（除港澳台）之外的数据， 各个省市在出成绩之后会出各自的一分一段表， 统计每一分的成绩的人数， 我们以这个数据为准， 由于个人还是没有太多精力去收集数据的，网上找到了 &lt;a href=&quot;https://www.gk100.com/zhiyuan/list_2003.htm&quot;&gt;高考100-一分一段表&lt;/a&gt;&lt;br/&gt;这个网站， 给出了各个省市的一分一段表， excel 版本， 稍微检查了一下， 数据应该是对的，我就暂时以这个数据为准，&lt;/p&gt;
&lt;p&gt;数据太多， 我暂时只做 35万 以上人的省市，只有11个省市，加上 北京上海两个城市的数据，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;河南&lt;/li&gt;
&lt;li&gt;河北&lt;/li&gt;
&lt;li&gt;广东&lt;/li&gt;
&lt;li&gt;广西&lt;/li&gt;
&lt;li&gt;湖南&lt;/li&gt;
&lt;li&gt;湖北&lt;/li&gt;
&lt;li&gt;江西&lt;/li&gt;
&lt;li&gt;贵州&lt;/li&gt;
&lt;li&gt;安徽&lt;/li&gt;
&lt;li&gt;四川&lt;/li&gt;
&lt;li&gt;山东&lt;/li&gt;
&lt;li&gt;北京&lt;/li&gt;
&lt;li&gt;上海&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其中北京上海不分科，山东是选择一门考试进行考核， 所以 一共23个数据表，后续的话，我尽量将数据也一并上传了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1595952537078.png&quot; alt=&quot;35万人以上省市+北京上海&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据整理&quot;&gt;数据整理&lt;/h2&gt;
&lt;p&gt;上面也提到了北京上海山东的分科比较特殊， 我们就按文理一起算，每个省都是给出最高分及以上的数据， 然后给出100分及以下的数据，但是不是每个省都是100分以下，所以还要特殊考虑，&lt;/p&gt;
&lt;h3 id=&quot;不同高考政策与分类&quot;&gt;不同高考政策与分类&lt;/h3&gt;
&lt;p&gt;山东的高考政策具体不清楚， 但是似乎是考生是在6门副科中任选3门，从&lt;a href=&quot;https://www.eol.cn/e_html/gk/tj/sd.shtml&quot;&gt;一图了解山东高考改革要点&lt;/a&gt;&lt;br/&gt;这里查到的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1595952537876.png&quot; alt=&quot;山东高考政策&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们就不做分科了， 直接看山东的全体成绩即可。&lt;/p&gt;
&lt;h3 id=&quot;不同统计方式&quot;&gt;不同统计方式&lt;/h3&gt;
&lt;p&gt;北京的人数更少，在400分以下每10分段给出人数，我们为了便于方便 默认每个分数平均人数， 比如 390-399分段的人有813人，我们认为每个分段都有81.3人，暂时这么处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1595952537080.png&quot; alt=&quot;北京400以下10分一段&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不同省市对于最高分数的表示都是 最高分数及以上， 但是对于最低分数的处理就不太一样了， 这里不做评价&lt;br/&gt;比如很多省市是合并在一起 100分以下总计， 有些则只是100分的成绩， 100分以下的成绩是没有给出的，这里最后处理的时候， 我们把0分的人都删除了， 只计算1-100 的人，反正不影响整个曲线&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1595952537082.png&quot; alt=&quot;最低分数人数表示&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最终我们整理得到数据表， 每个Sheet 表示一个省市的文理科目，然后最上面一行数据分别对应 总分，人数， 累计人数，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1595952537084.png&quot; alt=&quot;数据清整理&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据处理&quot;&gt;数据处理&lt;/h2&gt;
&lt;h3 id=&quot;数据处理思路&quot;&gt;数据处理思路&lt;/h3&gt;
&lt;p&gt;这里为了方便 顺手用 Python 来做的， 使用的 pandas 读取的 excel 文件，&lt;br/&gt;我们统计所有的数据的目标就是 将成绩化为 0-100分&lt;br/&gt;那么&lt;/p&gt;
&lt;p&gt;\[变换后分数 = \frac{当前分数-最低分}{最高分-最低分} \times 100 \]&lt;/p&gt;
&lt;p&gt;对于每个省的成绩将其调整到 [0,100], 这里使用的是 四舍五入， 导致实际在计算过程中的数据会重叠，比如相邻的两个成绩一个舍去，一个入上，在统一分数，导致数据噪声较大， 这是使用 一维的中值滤波平滑一下数据就好了，&lt;/p&gt;
&lt;p&gt;以河南文科为例， 我们直接绘制归一化之后的成绩并进行中值滤波之后对比，&lt;br/&gt;（图为测试过程中归一化到500分的图像，不影响理解）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1595952537089.png&quot; alt=&quot;河南文科成绩归一化与中值平滑对比&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;各省市分数分布&quot;&gt;各省市分数分布&lt;/h3&gt;
&lt;p&gt;我们在之前已经整理得到的数据， 然后我们 就要动手做了，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;
# 整理数据，将各省市的成绩归一到100分之后的分布比率

# 引入 pandas
import pandas as pd
import matplotlib
import matplotlib.pyplot as plt
import scipy.signal as ss

# 设定中文字体
plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签
plt.rcParams['axes.unicode_minus']=False #用来正常显示负号
# 设定图像尺寸 与分辨率
plt.rcParams['figure.figsize'] = (8.0, 4.0) # 设置figure_size尺寸
plt.rcParams['image.interpolation'] = 'nearest' # 设置 interpolation style
plt.rcParams['savefig.dpi'] = 300 #图片像素
plt.rcParams['figure.dpi'] = 300 #分辨率

# 将成绩统一到 [0，] 区间
MAX_SCORE = 100
MIN_SCORE = 0

data_file = 'Data/data.xlsx'
res_file = 'Data/res-'+str(MAX_SCORE-MIN_SCORE)+'.xlsx'

# 读取excel , 获取所有表单名字
excel_info = pd.ExcelFile(data_file)

all_data = {}
all_data_ratio = {}
# 获取表中的每一个数据文件 并将数据归一化到 0-500
for index in range(len(excel_info.sheet_names)):
    # 读取每一个表单
    cur_sheetname = excel_info.sheet_names[index]
    df_sheet = pd.read_excel(data_file, sheet_name=cur_sheetname)

    # 获取每一个表中的 总分数 和对应分数的人数
    scores = df_sheet[df_sheet.columns.values[0]]
    nums = df_sheet[df_sheet.columns.values[1]]

    # 数据 对应 每个分数的人数 表
    ROWS = MAX_SCORE - MIN_SCORE + 1
    trans_scores_nums = [0] * ROWS

    rows = len(scores)
    cur_max_score = scores[0]
    cur_min_score = scores[rows - 1]

    cur_index = 0;
    for s in scores:
        # 计算 变换之后的分数 四舍五入
        trans_score = (int)(round((s - cur_min_score) / (cur_max_score - cur_min_score) * (MAX_SCORE - MIN_SCORE)))

        # 在计算分数的位置上 加上对应分数的人数
        trans_scores_nums[trans_score - 1] += nums[cur_index];
        cur_index += 1

    # 数据稍微处理一下， 做简单的平滑处理, 去除最低分数据
    except0data = [0] * (ROWS - 1)
    for i in range(ROWS - 1):
        except0data[i] = trans_scores_nums[i + 1];

    # 中值滤波去除噪点
    smooth_trans = ss.medfilt(except0data, 7)

    # 将数据转换成比例， 更具有一般性
    sum = 0
    smooth_trans_ratio = [0] * (ROWS - 1)
    for i in range(ROWS - 1):
        sum += smooth_trans[i]

    for i in range(ROWS - 1):
        smooth_trans_ratio[i] = smooth_trans[i] / sum

    all_data[cur_sheetname] = smooth_trans
    all_data_ratio[cur_sheetname] = smooth_trans_ratio

    print('正在进行 {0}/{1}， 表名：{2}'.format(index + 1, len(excel_info.sheet_names), cur_sheetname))

    # plt.plot(smooth_trans2)
# write_data = pd.DataFrame(all_data)
# write_data.to_excel(res_file,sheet_name='res')
write_data_ratio = pd.DataFrame(all_data_ratio)
write_data_ratio.to_excel(res_file, sheet_name='ratio')

print('已经完成，存储文件：{0}'.format(res_file))

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在这个程序里面主要是 将数据提取出来， 计算成 100分制之后，重新存入 excel 表中，其中人数部分换成了各省市的人数比率，也方便查阅后续的数据&lt;br/&gt;（ 因为我感觉 plt 绘制图像不好看，这边使用了MATLAB 进行图像的绘制过程）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-matlab&quot;&gt;% 将 原始数据绘制出来 并计算平均值和中值

% 读取 excel 数据  获取名称以及各列名称
data_file = 'Data/res-100.xlsx';
res_ratio = xlsread(data_file,1,'B2:X501');
res_name = {'河南文科',        '河南理科',          '北京',           '上海',    '河北文科',    '河北理科',    '山东',    '广东文科'    '广东理科'    '湖北文科',    '湖北理科',    '湖南文科',    '湖南理科',    '四川文科',    '四川理科',    '安徽文科',    '安徽理科',    '广西文科',    '广西理科',    '贵州文科',    '贵州理科',    '江西文科',    '江西理科'};

figure()
hold on
[rows,cols] = size(res_ratio);
avg = zeros(cols,1);
media =zeros(cols,1);
for i=1:cols
    % 绘制百分比率图
    plot(res_ratio(:,i)*100);
    
    % 计算平均值  中值
    media_l = 0.5;
    media_find_flg = 0;
    for j = 1:rows
        avg(i) = avg(i) + j*res_ratio(j,i);
        
        % 统计比率超过一半的 数之后就是中值 找到后就不更新了
        if(media_find_flg ==0)
              if(media_l &amp;gt;0)
                  media_l = media_l - res_ratio(j,i);
              else
                  media(i) = j;
                  media_find_flg = 1;
            end
        end
    end
end
legend(res_name);

% 创建 xlabel
xlabel({'归一化到100分后成绩'});

% 创建 title
title({'各省市归一化成绩分布比率'});

% 创建 ylabel
ylabel({'单位成绩分布比率'});

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终我们得到了这样的一副图， 细节部分比较多，且数据噪声较大，但是数据的整体趋势大概明白了，噪声较大的黄色的线是北京的，暂时不做过多分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1595952537365.png&quot; alt=&quot;各省市成绩分布比率&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;各省市分数平均值与中值&quot;&gt;各省市分数平均值与中值&lt;/h3&gt;
&lt;p&gt;我们这里的计算平均值就是 每分段人数乘以该分段的比例，最终得到的结果，&lt;br/&gt;然后， 中值这里简单除暴， 找到中间比率所在的区间就好了， 代码没有去过多处理， 能跑出来结果就好&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;****&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;平均数&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;中数&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;众数&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;河南文科&lt;/td&gt;
&lt;td&gt;49.48792233&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;河南理科&lt;/td&gt;
&lt;td&gt;54.58292813&lt;/td&gt;
&lt;td&gt;58&lt;/td&gt;
&lt;td&gt;65&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;北京&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;68.04792125&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;70&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;70&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;上海&lt;/td&gt;
&lt;td&gt;57.56537197&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;62&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;河北文科&lt;/td&gt;
&lt;td&gt;51.23109382&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;td&gt;37&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;河北理科&lt;/td&gt;
&lt;td&gt;58.00918618&lt;/td&gt;
&lt;td&gt;61&lt;/td&gt;
&lt;td&gt;66&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;山东&lt;/td&gt;
&lt;td&gt;53.14176529&lt;/td&gt;
&lt;td&gt;56&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;广东文科&lt;/td&gt;
&lt;td&gt;47.7185653&lt;/td&gt;
&lt;td&gt;49&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;广东理科&lt;/td&gt;
&lt;td&gt;48.64707915&lt;/td&gt;
&lt;td&gt;51&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;湖北文科&lt;/td&gt;
&lt;td&gt;48.50952865&lt;/td&gt;
&lt;td&gt;49&lt;/td&gt;
&lt;td&gt;37&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;湖北理科&lt;/td&gt;
&lt;td&gt;51.9093088&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;湖南文科&lt;/td&gt;
&lt;td&gt;60.26081026&lt;/td&gt;
&lt;td&gt;62&lt;/td&gt;
&lt;td&gt;72&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;湖南理科&lt;/td&gt;
&lt;td&gt;59.09632919&lt;/td&gt;
&lt;td&gt;62&lt;/td&gt;
&lt;td&gt;65&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;四川文科&lt;/td&gt;
&lt;td&gt;54.82215427&lt;/td&gt;
&lt;td&gt;57&lt;/td&gt;
&lt;td&gt;59&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;四川理科&lt;/td&gt;
&lt;td&gt;61.59698771&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;安徽文科&lt;/td&gt;
&lt;td&gt;51.95829486&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;td&gt;69&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;安徽理科&lt;/td&gt;
&lt;td&gt;54.62690506&lt;/td&gt;
&lt;td&gt;57&lt;/td&gt;
&lt;td&gt;56&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;广西文科&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;37.84799656&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;37&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;31&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;广西理科&lt;/td&gt;
&lt;td&gt;41.46558284&lt;/td&gt;
&lt;td&gt;41&lt;/td&gt;
&lt;td&gt;33&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;贵州文科&lt;/td&gt;
&lt;td&gt;63.48516406&lt;/td&gt;
&lt;td&gt;65&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;贵州理科&lt;/td&gt;
&lt;td&gt;57.96584346&lt;/td&gt;
&lt;td&gt;58&lt;/td&gt;
&lt;td&gt;56&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;江西文科&lt;/td&gt;
&lt;td&gt;53.35740184&lt;/td&gt;
&lt;td&gt;55&lt;/td&gt;
&lt;td&gt;71&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;江西理科&lt;/td&gt;
&lt;td&gt;56.85982591&lt;/td&gt;
&lt;td&gt;61&lt;/td&gt;
&lt;td&gt;62&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;数据简单分析&quot;&gt;数据简单分析&lt;/h3&gt;
&lt;p&gt;我们在上一章节给出了一张图， matlab 绘制的图的颜色比较接近， 建议下载原图观看，给出了分布图，&lt;br/&gt;我们把数据最为特殊的几条线单独绘制一下，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最偏右的 黄色 北京&lt;/li&gt;
&lt;li&gt;最偏左的 紫色 广西文科&lt;/li&gt;
&lt;li&gt;最高的 浅蓝色 贵州文科&lt;/li&gt;
&lt;li&gt;最平均的 浅紫色 湖北理科&lt;/li&gt;
&lt;li&gt;双峰的 蓝色 江西文科&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1595952537254.png&quot; alt=&quot;明显数据分析&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实这些形态是有独特的意义的，理论上的曲线是正太分布的，但是由于各种原因，我们以实际曲线为主，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;靠右表示 数据整体偏大&lt;/li&gt;
&lt;li&gt;靠左整体偏小&lt;/li&gt;
&lt;li&gt;最高的表示数据比较集中，&lt;/li&gt;
&lt;li&gt;最低的表示数据分布均匀&lt;/li&gt;
&lt;li&gt;双峰的表示数据割裂严重（我瞎编的）。。。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;就总体而言， 各个省市的成绩的峰值（众数）也主页也分为两个部分，部分省市的峰值在40分左右，主要包括河南文科，河北文科，湖北文科，广西文科，广西理科&lt;br/&gt;剩下的分数的众数都集中在60分多一点的位置，&lt;/p&gt;
&lt;p&gt;emmm， 就这么多了， 再多的分析也没有太多用， 毕竟北京NB&lt;/p&gt;
&lt;p&gt;剩下的部分就是 高考本科上线率这种数据了， 但是各省对于本科的分数线真是不同&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1595952537182.png&quot; alt=&quot;本科分数线&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我给出的数据是我在&lt;a href=&quot;http://www.eol.cn/e_html/gk/fsx/&quot;&gt;各地高考历年分数线(批次线)&lt;/a&gt; 这个网页上能看到2020 年各省高考批次线， 一般的省市都是划分 1本2本专科， 除了北京，上海，河北，山东，广东&lt;br/&gt;后面想办法再做吧， 估计会不做了&lt;/p&gt;
&lt;h3 id=&quot;高考大省与高考小省&quot;&gt;高考大省与高考小省&lt;/h3&gt;
&lt;p&gt;我们拿高考大省河南河北然后对比上海和北京， 看下数据&lt;br/&gt;其实这里应该去找数据轴上的最明显特征的线， 具体数据自己分析好了&lt;/p&gt;
&lt;p&gt;但是我们暂时只看这几个数据,&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1595952537355.png&quot; alt=&quot;四省市数据对比&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;****&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;平均数&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;中数&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;&lt;strong&gt;众数&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;河南文科&lt;/td&gt;
&lt;td&gt;49.48792233&lt;/td&gt;
&lt;td&gt;50&lt;/td&gt;
&lt;td&gt;46&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;河南理科&lt;/td&gt;
&lt;td&gt;54.58292813&lt;/td&gt;
&lt;td&gt;58&lt;/td&gt;
&lt;td&gt;65&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;北京&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;68.04792125&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;70&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;70&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;上海&lt;/td&gt;
&lt;td&gt;57.56537197&lt;/td&gt;
&lt;td&gt;60&lt;/td&gt;
&lt;td&gt;62&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;河北文科&lt;/td&gt;
&lt;td&gt;51.23109382&lt;/td&gt;
&lt;td&gt;52&lt;/td&gt;
&lt;td&gt;37&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;河北理科&lt;/td&gt;
&lt;td&gt;58.00918618&lt;/td&gt;
&lt;td&gt;61&lt;/td&gt;
&lt;td&gt;66&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;都是前面给出的数据， 我们绘制出来了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/schen00/BlogImage/raw/master/image/1595952537360.png&quot; alt=&quot;四省市对比&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;北京的成绩是明显优于河北的，河南和上海的数据其实是一直的，即使是在全部曲线图上也算比较中间的类型了，&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;搞了半天， 屁用没有，就是手痒然后就搞了一大堆， 越搞越多， 后续还有一堆要做的，&lt;/p&gt;
&lt;p&gt;根据本篇数据而言， 北京的成绩是比全国各个省市的成绩要好的，可能与培养方式不同吧，&lt;/p&gt;
&lt;p&gt;其实这种分数分布并不一定是培养造成的， 还有部分是各省考试情况不同导致的，所以数据仅供参考， 北京NB&lt;/p&gt;
&lt;h2 id=&quot;备注&quot;&gt;备注&lt;/h2&gt;
&lt;p&gt;我将所有的数据都存在了 Github 上&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/SChen1024/GaoKao&quot;&gt;https://github.com/SChen1024/GaoKao&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有兴趣的可随便拿数据进行分析， 后续还会做完最后一点&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 28 Jul 2020 16:19:00 +0000</pubDate>
<dc:creator>SChen1024</dc:creator>
<og:description>各个省份的高考题目不尽相同，成绩也是个人发挥，但是如果我将各个省市的成绩统一到100分，北京的平均成绩居然是最高的，最低的成绩居然是广西</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hugochen1024/p/gaokao.html</dc:identifier>
</item>
<item>
<title>工作中常用的方法(思维模型) - 九卷</title>
<link>http://www.cnblogs.com/jiujuan/p/13394703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jiujuan/p/13394703.html</guid>
<description>&lt;h2 id=&quot;一、每日工作清单&quot;&gt;一、每日工作清单&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;清单列表&lt;/strong&gt; + &lt;strong&gt;四象限法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;清单列表：列出今天要做的所有事情，可以用一些todo软件。&lt;br/&gt;四象限法：按照事情轻重缓急，重要紧急程度分为4个象限，把列表清单上的工作内容分别归类到这4个象限中，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;重要紧急&lt;/li&gt;
&lt;li&gt;重要不紧急&lt;/li&gt;
&lt;li&gt;不重要但紧急&lt;/li&gt;
&lt;li&gt;不重要也不紧急&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;还有一种：每日例行事项&lt;/p&gt;
&lt;h2 id=&quot;二、制定目标方法&quot;&gt;二、制定目标方法&lt;/h2&gt;
&lt;h3 id=&quot;grow法&quot;&gt;GROW法&lt;/h3&gt;
&lt;p&gt;这个应该是给下属怎么制定目标的方法，不过可以扩展下，给自己制定目标的方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;G - Goal，目标&lt;/strong&gt;：&lt;br/&gt;找出合适的目标。&lt;br/&gt;怎么找？不断的问自己，自己需要什么，内心渴望什么，自己喜欢什么，自己的优势是什么，劣势是什么，自己担心什么？？可以用清单方法写出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;R - Reality ， 事实&lt;/strong&gt;：&lt;br/&gt;围绕目标搜索相关事实，目前资源、困难、成本、自身目前条件，都有哪些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;O - Option，方案的选择&lt;/strong&gt;：&lt;br/&gt;上面的分析完成后，就要探索相关解决方案了，然后对比解决方案，找出最适合你的方案。最后是计划和实施。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;W - Wrap-up，具体行动和总结&lt;/strong&gt;：&lt;br/&gt;最后就是根据方案，拟定具体的实施计划，再把计划分解为每天可以完成的任务，放入日事清单中，每天去执行。&lt;/p&gt;
&lt;p&gt;检查调整：可以一个星期或者半个月检查一次执行的结果，实时调整。这时候就可以用PDCA方法了，后面有讲这个方法。&lt;/p&gt;
&lt;h2 id=&quot;三、制定工作计划原则&quot;&gt;三、制定工作计划原则&lt;/h2&gt;
&lt;h3 id=&quot;smart原则&quot;&gt;SMART原则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;S - Specific，具体的&lt;/strong&gt;：&lt;br/&gt;做项目，要有衡量的标准，完成期限以及资源要求，清晰的看到该做哪些事情，做了哪些事情，正在做的事情，完成了哪些事情。&lt;br/&gt;看板工具可以完成这个事情。计划任务图。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;M - Measureable，可衡量的&lt;/strong&gt;：&lt;br/&gt;要设定一个可度量的标准。不能衡量的就制定流程工作，流程化，可视化的看到做到哪一步。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A - Achievable，可达成的&lt;/strong&gt;：&lt;br/&gt;要制定那种跳一跳，可以摘到“桃子”的目标，不要好高骛远，制定那种近期无法达成的目标。比如那种“手可摘星辰”的目标。仰望星空可以，要有这种理想，但是制定目标一定要可达成，可衡量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;R - Relevant，相关的&lt;/strong&gt;：&lt;br/&gt;制定的目标要和其他目标相关联，要和公司的战略目标、部门的整体目标、小组目标、个人工作职责相关联。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T - Time-based，一定时限的&lt;/strong&gt;：&lt;br/&gt;根据目标任务的重要紧急程序，权重，拟出完成任务的时间列表，定期检查任务完成情况，及时调整工作计划。这个就用到了PDCA循环。&lt;/p&gt;
&lt;h2 id=&quot;四、执行计划工作的方法&quot;&gt;四、执行计划/工作的方法&lt;/h2&gt;
&lt;h3 id=&quot;pdca循环&quot;&gt;PDCA循环&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;P - Plan&lt;/strong&gt;，把要做的事情列一个计划列表。把一个大的任务分解为小的任务，然后把小任务布置到每天需要完成的任务清单中（用到了上面的清单方法），积完成小任务成大任务，从而完成目标。&lt;br/&gt;&lt;strong&gt;D - Do&lt;/strong&gt;，实施事情&lt;br/&gt;&lt;strong&gt;C - Check&lt;/strong&gt;，做完了之后进行检查，反思，核对，调整。过一段时间检查效果，实时调整。&lt;br/&gt;&lt;strong&gt;A - Action&lt;/strong&gt;，行动。接着继续做任务。&lt;/p&gt;
&lt;p&gt;然后不断的循环。&lt;/p&gt;
&lt;p&gt;PDCA 8大步骤：&lt;br/&gt;1：分析现状找出问题-&amp;gt;2：分析产生问题的原因-&amp;gt;3：要因确认-&amp;gt;4：拟定措施，制定计划-&amp;gt;5：执行措施执行计划-&amp;gt;6：检查验证，评估效果-&amp;gt;7：标准化，固定成绩-&amp;gt;8：处理遗留问题&lt;/p&gt;
&lt;h2 id=&quot;五、分析问题方法：5w2h&quot;&gt;五、分析问题方法：5w2h&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;W - Why&lt;/strong&gt;，为什么？为什么要这样做？理由何在，原因是什么？为什么会造成这样的结果？&lt;br/&gt;不断的提问，直到找到正在的原因所在，丰田公司的一种方法&lt;br/&gt;&lt;strong&gt;W - Who&lt;/strong&gt;，谁？由谁来完成，谁来负担？谁负责？&lt;br/&gt;&lt;strong&gt;W - When&lt;/strong&gt;，何时？什么时间完成？什么时机最成熟？&lt;br/&gt;&lt;strong&gt;W - Where&lt;/strong&gt;，何处？从哪里做？从哪里入手？&lt;br/&gt;&lt;strong&gt;W - What&lt;/strong&gt;，是什么？目的是什么？这个工作是什么，解决什么问题？&lt;br/&gt;&lt;strong&gt;H - How&lt;/strong&gt;，怎么做？用什么方法做？怎么高效率的实施？&lt;br/&gt;&lt;strong&gt;H - How much&lt;/strong&gt;，多少？做到什么程度？数量如何？质量水平如何？费用是多少？产出是多少？&lt;/p&gt;
&lt;p&gt;不断的追问，要有打破砂锅问到底的精神。当然不是为了问而问，更不是为了刁难而问，我们的目的是要分析问题出现的原因，找出发生问题的内在本质，从而想出有用的解决问题方法，进而能做出解决方案出来。&lt;/p&gt;
&lt;h2 id=&quot;六、汇报工作的方法：star法&quot;&gt;六、汇报工作的方法：STAR法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;S - Situation，情景&lt;/strong&gt;：&lt;br/&gt;你做这件事情的背景是什么？为什么要做这件事情？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;T - Task，任务&lt;/strong&gt;：&lt;br/&gt;为了做这件事情，计划了哪些任务，怎么计划的原因是什么？完成了什么任务，怎么完成？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A - Action，行动&lt;/strong&gt;：&lt;br/&gt;完成这些任务采取了哪些行动，做了什么事情？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;R - Result， 结果&lt;/strong&gt;：&lt;br/&gt;做完后，取得了什么效果，有什么结果？有数据说明吗？&lt;/p&gt;
&lt;p&gt;这个方法是一个汇报工作的模板，可以让你把做过的工作在汇报的时候，更有条理，清晰和具有逻辑性。&lt;br/&gt;简叙事情的时候，也可以用这个方法。&lt;/p&gt;
&lt;h2 id=&quot;七、总结&quot;&gt;七、总结&lt;/h2&gt;
&lt;p&gt;上面的一些方法，彼此之间可以相互交融，渗透，比如找出目标的GROW方法，找出来之后执行就可以用PDCA循环方法来执行。&lt;br/&gt;当然应该有更多融合方法，等着大家去思考探索总结。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;后续有遇到更好方法，会不断更新。也希望大家多多评论，提出好的方法。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 28 Jul 2020 16:16:00 +0000</pubDate>
<dc:creator>九卷</dc:creator>
<og:description>一、每日工作清单 清单列表 + 四象限法 清单列表：列出今天要做的所有事情，可以用一些todo软件。 四象限法：按照事情轻重缓急，重要紧急程度分为4个象限，把列表清单上的工作内容分别归类到这4个象限中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jiujuan/p/13394703.html</dc:identifier>
</item>
<item>
<title>Redis服务之常用配置（二）  - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13394411.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13394411.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200410174925redis.jpg&quot; class=&quot;desc_img&quot;/&gt; 从上面的日志中可以了解到redis做快照存储时，它会启动一个线程去存储快照，即便发生错误它也会每隔几秒去重复的执行存储快照的操作；其实上面的错误的原因是我们开启了stop-writes-on-bgsave-error这个选项，所以为了避免这种错误发生，我们可以把stop-writes-on-bgsave-error这个选项设置为no，但是这样设置以后我们还需要，通过监控来监控redis的日志，及时发现问题避免丢失数据；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;155.58207897999&quot;&gt;
&lt;p&gt;　　上一篇博客我们聊了下redis的INCLUDE、NETWORK、GENERAL配置段相关配置和说明，回顾请参考：&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13383166.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13383166.html&lt;/a&gt;；今天我们继续来说redis的其他配置段相关配置和说明；&lt;/p&gt;
&lt;p&gt;　　SNAPSHOTTING相关配置&lt;/p&gt;
&lt;p&gt;　　save：该指令用于指定在多少时间内，至少发生了多少写操作，就触发一次快照；配置语法 save &amp;lt;seconds&amp;gt; &amp;lt;changes&amp;gt;；其中save是指令，seconds表示时间单位是秒，changes表示数据发生变化的次数（写操作的次数）；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202007/1503305-20200728210321274-1556808055.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示在900秒以内如果数据至少发生了一次变化就做一次快照，或者在300秒内数据发生了至少10次变化，就做一次快照或者在60秒内，数据发生了至少10000次变化就做一次快照；save可以多次配置，他们之间是或的关系，只要满足其中一条就会触发快照操作；&lt;/p&gt;
&lt;p&gt;　　stop-writes-on-bgsave-error：该指令用于指定是否开启当做快照时发生错误停止服务器写入数据；默认是yes，表示开启当做快照时发生错误而停止redis服务器的写入；在生产环境中不建议开启，因为这个选项一旦开启，当作快照时如果发生错误，会导致整个redis服务器写操作不可用；&lt;/p&gt;
&lt;p&gt;　　rdbcompression：该指令用于指定是否对快照文件rdb做压缩，默认是yes，开启压缩；&lt;/p&gt;
&lt;p&gt;　　rdbchecksum：该指令用于指定是否对RDB文件做校验，默认是yes，开启校验rdb文件功能；&lt;/p&gt;
&lt;p&gt;　　dbfilename：该指令用于指定快照文件的名称，默认是dump.rdb&lt;/p&gt;
&lt;p&gt;　　dir：该指令用于指定rdb存储目录路径；默认编译安装，如果是用systemctl启动，默认是/；如果是用redis-server +配置文件路径来启动，默认就在当前执行命令的路径下；这里需要注意所在路径的权限要对应启动用户有写入权限，否则快照时会发生错误，提示没有权限在指定路径下创建快照文件；如果是yum安装默认是在/var/lib/redis/目录下；&lt;/p&gt;
&lt;p&gt;　　示例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202007/1503305-20200728222441257-399446867.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示配置redis如果在3秒钟内至少有1次数就变化就触发做一次快照；当在做快照时发生错误，停止redis的写操作；启用对快照文件rdb做压缩和校验；快照文件存储到/var/lib/redis目录下，名为dump_6379.rdb;&lt;/p&gt;
&lt;p&gt;　　验证：重启redis服务，用redis-cli连接，在其命令行插入数据，看看是否会在对应目录下产生rdb文件？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202007/1503305-20200728222937503-940640204.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在使用redis用户启动redis时，是能够在对应目录下生成快照文件，说明我们配置的快照策略生效了；&lt;/p&gt;
&lt;p&gt;　　验证：重启redis，看看数据是否还在？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202007/1503305-20200728223321261-667631888.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到我们重启了redis后，之前写入的数据都还在，说明redis在启动重启时会把rdb中的文件数据加载到内存；&lt;/p&gt;
&lt;p&gt;　　验证：修改/var/lib/redis/目录的属主和属组为root，然后往redis里写数据，看看会发生什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202007/1503305-20200728230653305-841171165.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：修改了/var/lib/redis/目录的属主/组为root后，再次连接redis读取数据是可以正常读取，但是写入数据报错，它告诉我们存储快照时发生错误；&lt;/p&gt;
&lt;p&gt;　　查看日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202007/1503305-20200728231212789-1738615995.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的日志中可以了解到redis做快照存储时，它会启动一个线程去存储快照，即便发生错误它也会每隔几秒去重复的执行存储快照的操作；其实上面的错误的原因是我们开启了stop-writes-on-bgsave-error这个选项，所以为了避免这种错误发生，我们可以把stop-writes-on-bgsave-error这个选项设置为no，但是这样设置以后我们还需要，通过监控来监控redis的日志，及时发现问题避免丢失数据；&lt;/p&gt;
&lt;p&gt;　　SECURITY相关配置&lt;/p&gt;
&lt;p&gt;　　requirepass：该指令用于指定连接redis服务端所需的密码；默认情况没有启用，生产中一定要设置密码；&lt;/p&gt;
&lt;p&gt;　　示例：设置连接redis密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202007/1503305-20200728232250283-893515456.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示给redis设置密码为admin123.com;&lt;/p&gt;
&lt;p&gt;　　验证：重启redis，不使用密码是否能够连接，操作redis?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202007/1503305-20200728232447480-1210578607.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：重启redis后，可以连接到redis，但是没法操作redis；&lt;/p&gt;
&lt;p&gt;　　提供密码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202007/1503305-20200728232644032-597256094.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：连接redis时可以使用-a来指定密码；也可以连接到redis后使用auth 命令来指定密码；&lt;/p&gt;
&lt;p&gt;　　rename-command：该命令用于重写那些高危命令，相当于给对应命令重命名；&lt;/p&gt;
&lt;p&gt;　　示例：重写flushall 为aaaa&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202007/1503305-20200728233234561-406242695.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：以上配置表示把flushall替换成aaaa；这意味着在客户端执行FLUSHALL就不生效了；&lt;/p&gt;
&lt;p&gt;　　验证：重启redis，使用flushall看看会发生什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202007/1503305-20200728233638041-86538116.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到使用flushall命令就会报错命令没找到；使用aaaa就相当于使用flushall，这样做的好处就是规避客户端使用高危命令，造成不要的数据丢失；&lt;/p&gt;
&lt;p&gt;　　LIMITS相关配置&lt;/p&gt;
&lt;p&gt;　　maxclients：该指令用于指定最大客户端连接数；默认是10000；&lt;/p&gt;
&lt;p&gt;　　maxmemory：该指令用于指定最大内存，单位是字节，这个选项一般不建议配置过大，过大极易触发oom；&lt;/p&gt;
&lt;p&gt;　　maxmemory-policy：该指令用于指定当最大内满了以后，该怎么清除里面的数据；volatile-lru表示对有过期时长的数据进行LRU算法淘汰；allkeys-lru表示对所有键基于LRU算法淘汰；volatile-random对有过期时长的键进行随机淘汰；allkeys-random对所有键进行随机淘汰；noeviction不淘汰任何以存在的数据，如果有新数据来了，就错误提示；默认是noevicton&lt;/p&gt;
&lt;p&gt;　　maxmemory-samples：该指令用于指定一次采样key数量，默认是5个；基于采样的5个键里做LRU;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 28 Jul 2020 16:00:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>上一篇博客我们聊了下redis的INCLUDE、NETWORK、GENERAL配置段相关配置和说明，回顾请参考：https://www.cnblogs.com/qiuhom-1874/p/133831</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13394411.html</dc:identifier>
</item>
<item>
<title>Redis一站式管理平台工具,支持集群创建,管理,监控,报警 - you-men</title>
<link>http://www.cnblogs.com/you-men/p/13394652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/you-men/p/13394652.html</guid>
<description>&lt;h4 id=&quot;简介&quot;&gt;简介&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Redis Manager 是 Redis 一站式管理平台，支持集群的创建、管理、监控和报警。&lt;br/&gt;&lt;strong&gt;集群创建：&lt;/strong&gt;包含了三种方式 Docker、Machine、Humpback；&lt;br/&gt;&lt;strong&gt;集群管理：&lt;/strong&gt;支持节点扩容、缩容、Slots迁移、BeMaster、BeSlave、Memory Purge、配置修改等功能；&lt;br/&gt;&lt;strong&gt;集群监控：&lt;/strong&gt;Redis 集群重要监控指标，如Memory、Clients、命中率等；可实时查看Redis Info、Redis Config、Slow Log等信息；Query 功能可查询任何类型的Key。&lt;br/&gt;&lt;strong&gt;集群报警：&lt;/strong&gt;支持used_memory、clients等监控，并默认实现了邮件报警，用户可自己对报警接口进行其他实现，如微信、短信报警等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;github项目地址&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ngbdf/redis-manager&quot;&gt;https://github.com/ngbdf/redis-manager&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;部署redis-manager&quot;&gt;部署redis-manager&lt;/h4&gt;
&lt;h5 id=&quot;下载解压源码包&quot;&gt;下载解压源码包&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 系统环境：
# LINUX
# JDK1.8

# Releases
https://github.com/ngbdf/redis-manager/releases

#当前最新版本 1.1
wget https://github.com/ngbdf/redis-manager/releases/download/redismanager-1.1-release/redis-manager-1.1-release.tar.gz
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;部署java环境&quot;&gt;部署java环境&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;rpm -ivh jdk-8u121-linux-x64.rpm 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;部署mysql&quot;&gt;部署mysql&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;init_mysql() {
rpm -e mariadb-libs --nodeps
rm -rf /var/lib/mysql
rm -rf /etc/my.cnf
tar xvf /root/mysql-5.7.23-1.el7.x86_64.rpm-bundle.tar -C /usr/local/
cd /usr/local
rpm -ivh mysql-community-server-5.7.23-1.el7.x86_64.rpm \
mysql-community-client-5.7.23-1.el7.x86_64.rpm \
mysql-community-common-5.7.23-1.el7.x86_64.rpm \
mysql-community-libs-5.7.23-1.el7.x86_64.rpm 
rm -rf mysql-community-* 
}
changepass() {
sed -i '/\[mysqld]/ a skip-grant-tables' /etc/my.cnf
systemctl restart mysqld
mysql &amp;lt;&amp;lt;EOF
        update mysql.user set authentication_string='' where user='root' and Host='localhost';
        flush privileges;
EOF
sed -i '/skip-grant/d' /etc/my.cnf
systemctl restart mysqld
yum -y install expect 

expect &amp;lt;&amp;lt;-EOF
spawn  mysqladmin -uroot -p password &quot;ZHOUjian.20&quot;
        expect {
                &quot;password&quot; { send &quot;\r&quot;  }
}
        expect eof
EOF
systemctl restart mysqld
}
main() {
init_mysql
changepass
}
main

create database redismanager default character set utf8mb4 collate utf8mb4_general_ci;

grant all on redismanager.* to youmen@'%' identified by 'ZHOUjian.20';
flush privileges;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;部署配置redis-manager&quot;&gt;部署配置redis-manager&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;tar xf redis-manager-1.1-release.tar.gz 
cd redis-manager-1.1/
cd conf/
vim application.yml 
server:
  tomcat.uri-encoding: UTF-8
  port: 8182

spring:
  application:
      name: redis-manager
  http:
      encoding:
        enabled: true
        force: true
        charset: UTF-8
  # 改成自己的数据库，仅需自己创建数据库即可，相关表会自动生成
  datasource:
      name: serverbase
      driver-class-name: com.mysql.jdbc.Driver
      url: jdbc:mysql://192.168.43.205:3306/redismanager?useUnicode=true&amp;amp;characterEncoding=utf-8
      username: root
      password: ZHOUjian.20
# 如果使用微信报警，填写微信企业号相关信息(用户自定义扩展)
  wechat:

  # 如果使用邮件报警，在此处开启开关并配置log4j邮件相关信息
  mail:
     alarm: true
     SMTPHost: 127.0.0.1
     SMTPUsername:
     SMTPPassword:
     mailFrom: mail@newegg.com
     mailTo: mail@newegg.com
      

&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;启动访问&quot;&gt;启动访问&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#执行bin目录下的start.sh脚本
./bin/start.sh 

[root@redis-manager redis-manager-1.1]# ps -ef |grep java
root       2142      1 42 23:21 pts/2    00:00:14 java -cp conf/:lib/accessors-smart-1.1.jar:lib/activation-1.1.1.jar:lib/android-json-0.0.20131108.vaadin1.jar:lib/animal-sniffer-annotations-1.14.jar:lib/asm-5.0.3.jar:lib/aspectjrt-1.6.11.jar:lib/aspectjweaver-1.6.11.jar:lib/assertj-core-2.6.0.jar:lib/bootstrap-3.3.7.jar:lib/checker-compat-qual-2.0.0.jar:lib/classmate-1.3.3.jar:lib/commons-beanutils-1.9.3.jar:lib/commons-codec-1.10.jar:lib/commons-collections-3.2.2.jar:lib/commons-compress-1.9.jar:lib/commons-lang-2.5.jar:lib/commons-lang3-3.7.jar:lib/commons-logging-1.1.1.jar:lib/commons-pool2-2.4.2.jar:lib/error_prone_annotations-2.1.3.jar:lib/ezmorph-1.0.6.jar:lib/ganymed-ssh2-build209.jar:lib/groovy-2.4.9.jar:lib/guava-24.0-jre.jar:lib/hamcrest-core-1.3.jar:lib/hamcrest-library-1.3.jar:lib/hibernate-validator-5.3.4.Final.jar:lib/httpclient-4.4.1.jar:lib/httpcore-4.4.1.jar:lib/j2objc-annotations-1.1.jar:lib/jackson-annotations-2.8.0.jar:lib/jackson-core-2.8.7.jar:lib/jackson-databind-2.8.7.jar:lib/javassist-3.21.0-GA.jar:lib/jboss-logging-3.3.0.Final.jar:lib/jedis-2.9.0.jar:lib/jquery-3.1.0.jar:lib/jsonassert-1.4.0.jar:lib/json-lib-2.4-jdk15.jar:lib/json-path-2.2.0.jar:lib/json-smart-2.2.1.jar:lib/jsr305-1.3.9.jar:lib/junit-4.12.jar:lib/log4j-1.2.17.jar:lib/mail-1.4.jar:lib/mockito-core-1.10.19.jar:lib/mybatis-3.4.0.jar:lib/mybatis-spring-1.3.0.jar:lib/mybatis-spring-boot-autoconfigure-1.1.1.jar:lib/mybatis-spring-boot-starter-1.1.1.jar:lib/mysql-connector-java-5.1.41.jar:lib/objenesis-2.1.jar:lib/ognl-3.0.8.jar:lib/slf4j-api-1.7.24.jar:lib/slf4j-log4j12-1.7.24.jar:lib/snakeyaml-1.17.jar:lib/sockjs-client-1.0.2.jar:lib/spring-aop-4.3.7.RELEASE.jar:lib/spring-beans-4.3.7.RELEASE.jar:lib/spring-boot-1.5.2.RELEASE.jar:lib/spring-boot-autoconfigure-1.5.2.RELEASE.jar:lib/spring-boot-starter-1.5.2.RELEASE.jar:lib/spring-boot-starter-jdbc-1.5.2.RELEASE.jar:lib/spring-boot-starter-test-1.5.2.RELEASE.jar:lib/spring-boot-starter-thymeleaf-1.5.2.RELEASE.jar:lib/spring-boot-starter-tomcat-1.5.2.RELEASE.jar:lib/spring-boot-starter-web-1.5.2.RELEASE.jar:lib/spring-boot-starter-websocket-1.5.2.RELEASE.jar:lib/spring-boot-test-1.5.2.RELEASE.jar:lib/spring-boot-test-autoconfigure-1.5.2.RELEASE.jar:lib/spring-context-4.3.7.RELEASE.jar:lib/spring-core-4.3.7.RELEASE.jar:lib/spring-expression-4.3.7.RELEASE.jar:lib/spring-jdbc-4.3.7.RELEASE.jar:lib/spring-messaging-4.3.7.RELEASE.jar:lib/spring-test-4.3.7.RELEASE.jar:lib/spring-tx-4.3.7.RELEASE.jar:lib/spring-web-4.3.7.RELEASE.jar:lib/spring-webmvc-4.3.7.RELEASE.jar:lib/spring-websocket-4.3.7.RELEASE.jar:lib/stomp-websocket-2.3.3.jar:lib/thymeleaf-2.1.5.RELEASE.jar:lib/thymeleaf-layout-dialect-1.4.0.jar:lib/thymeleaf-spring4-2.1.5.RELEASE.jar:lib/tomcat-embed-core-8.5.11.jar:lib/tomcat-embed-el-8.5.11.jar:lib/tomcat-embed-websocket-8.5.11.jar:lib/tomcat-jdbc-8.5.11.jar:lib/tomcat-juli-8.5.11.jar:lib/unbescape-1.1.0.RELEASE.jar:lib/validation-api-1.1.0.Final.jar:lib/webjars-locator-0.32.jar:lib/webjars-locator-core-0.30.jar:redis-manager-1.1-SNAPSHOT.jar com.newegg.ec.cache.Application
root       2174   1936  0 23:21 pts/2    00:00:00 grep --color=auto java
      
      
      
# 验证端口
lsof -i:8182
COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
java    2389 root  127u  IPv4  26140      0t0  TCP *:vmware-fdm (LISTEN)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;redis-manager使用&quot;&gt;Redis-Manager使用&lt;/h4&gt;
&lt;h5 id=&quot;登录&quot;&gt;登录&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;admin/admin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200728235610590-2111496153.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;主界面&quot;&gt;主界面&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200728235636574-326270673.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;创建集群&quot;&gt;创建集群&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200728235647335-807378172.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200728235658048-596602104.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;查看监控&quot;&gt;查看监控&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200728235713956-458389747.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200728235724433-1301016324.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200728235739159-311630143.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;查看节点详细配置&quot;&gt;查看节点详细配置&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200728235752837-924924117.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;查询key&quot;&gt;查询key&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1871335/202007/1871335-20200729000426402-1870711945.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 Jul 2020 15:58:00 +0000</pubDate>
<dc:creator>you-men</dc:creator>
<og:description>简介 Redis Manager 是 Redis 一站式管理平台，支持集群的创建、管理、监控和报警。 **集群创建：**包含了三种方式 Docker、Machine、Humpback； **集群管理：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/you-men/p/13394652.html</dc:identifier>
</item>
</channel>
</rss>