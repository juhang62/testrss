<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>大数据技术之_16_Scala学习_06_面向对象编程-高级+隐式转换和隐式值 - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10627366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10627366.html</guid>
<description>&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h&quot;&gt;第八章 面向对象编程-高级&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h81&quot;&gt;8.1 静态属性和静态方法&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h811&quot;&gt;8.1.1 静态属性-提出问题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h812&quot;&gt;8.1.2 基本介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h813&quot;&gt;8.1.3 伴生对象的快速入门&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h814&quot;&gt;8.1.4 伴生对象的小结&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h815&quot;&gt;8.1.5 最佳实践-使用伴生对象解决小孩游戏问题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h816apply&quot;&gt;8.1.6 伴生对象-apply 方法&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h82&quot;&gt;8.2 单列对象&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h83&quot;&gt;8.3 接口&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h831java&quot;&gt;8.3.1 回顾 Java 接口&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h832scala&quot;&gt;8.3.2 Scala 接口的介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h833trait&quot;&gt;8.3.3 trait 的声明&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h834scalatrait&quot;&gt;8.3.4 Scala 中 trait 的使用&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h84trait&quot;&gt;8.4 特质 trait&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h841&quot;&gt;8.4.1 特质的快速入门案例分析&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h842&quot;&gt;8.4.2 代码完成&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h843trait&quot;&gt;8.4.3 特质 trait 的再说明&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h844&quot;&gt;8.4.4 带有具体实现的特质&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h845mixin&quot;&gt;8.4.5 带有特质的对象：动态混入(mixin)&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h846&quot;&gt;8.4.6 叠加特质&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h847&quot;&gt;8.4.7 在特质中重写抽象方法特例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h848&quot;&gt;8.4.8 当作富接口使用的特质&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h849&quot;&gt;8.4.9 特质中的具体字段&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h8410&quot;&gt;8.4.10 特质中的抽象字段&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h8411&quot;&gt;8.4.11 特质的构造顺序&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h8412&quot;&gt;8.4.12 扩展类的特质&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h8413&quot;&gt;8.4.13 自身类型&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h85&quot;&gt;8.5 嵌套类&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h851scala1&quot;&gt;8.5.1 Scala 嵌套类的使用1&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h852scala2&quot;&gt;8.5.2 Scala 嵌套类的使用2&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h853&quot;&gt;8.5.3 类型投影&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h8605&quot;&gt;8.6 作业05&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h861&quot;&gt;8.6.1 对象作业&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h862&quot;&gt;8.6.2 继承作业&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h-1&quot;&gt;第九章 隐式转换和隐式值&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h91&quot;&gt;9.1 隐式转换&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h911&quot;&gt;9.1.1 提出问题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h912&quot;&gt;9.1.2 隐式函数基本介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h913&quot;&gt;9.1.3 隐式函数快速入门&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h914&quot;&gt;9.1.4 隐式转换的注意事项和细节&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h92&quot;&gt;9.2 隐式转换丰富类库功能&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h921&quot;&gt;9.2.1 快速入门案例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h922&quot;&gt;9.2.2 案例代码&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h93&quot;&gt;9.3 隐式值&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h931&quot;&gt;9.3.1 基本介绍+快速入门案例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h932&quot;&gt;9.3.2 测试题&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h933&quot;&gt;9.3.3 一个案例说明 隐式值、隐式参数默认值 的优先级&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h94&quot;&gt;9.4 隐式类&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h941&quot;&gt;9.4.1 基本介绍&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h942&quot;&gt;9.4.2 应用案例&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h95&quot;&gt;9.5 隐式的转换时机&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h96&quot;&gt;9.6 隐式解析机制&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h97&quot;&gt;9.7 在进行隐式转换时，需要遵守两个基本的前提&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10627366.html#h9806&quot;&gt;9.8 作业06&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;&lt;strong&gt;第八章 面向对象编程-高级&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h81&quot;&gt;&lt;span&gt;&lt;strong&gt;8.1 静态属性和静态方法&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h811&quot;&gt;&lt;span&gt;&lt;strong&gt;8.1.1 静态属性-提出问题&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABI6c8.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h812&quot;&gt;&lt;span&gt;&lt;strong&gt;8.1.2 基本介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIcjS.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h813&quot;&gt;&lt;span&gt;&lt;strong&gt;8.1.3 伴生对象的快速入门&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;8&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter08.test&lt;p&gt;object AccompanyObjectDemo {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args: Array[String])&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;println(ScalaPerson.sex) &lt;br/&gt;ScalaPerson.sayHi() &lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;ScalaPerson&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;var name: String = _&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;object ScalaPerson {&lt;br/&gt;var sex: Boolean = &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;&lt;br/&gt;def &lt;span class=&quot;hljs-title&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;:Unit &lt;/span&gt;= {&lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;object ScalaPerson sayHi&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;&lt;br/&gt;object ScalaPerson sayHi&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;伴生对象的快速入门源码分析图解&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABI2ng.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h814&quot;&gt;&lt;span&gt;&lt;strong&gt;8.1.4 伴生对象的小结&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIhAs.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h815&quot;&gt;&lt;span&gt;&lt;strong&gt;8.1.5 最佳实践-使用伴生对象解决小孩游戏问题&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  设计一个 var total Int 表示总人数，我们在创建一个小孩时，就把 total 加1,并且 total 是所有对象共享的就 ok 了。我们使用伴生对象来解决。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;11.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;17&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter08.test&lt;p&gt;object ChildGameTest {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args: Array[String])&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;val child01 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Child(&lt;span class=&quot;hljs-string&quot;&gt;&quot;白骨精&quot;&lt;/span&gt;)&lt;br/&gt;val child02 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Child(&lt;span class=&quot;hljs-string&quot;&gt;&quot;银角大王&quot;&lt;/span&gt;)&lt;br/&gt;val child03 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Child(&lt;span class=&quot;hljs-string&quot;&gt;&quot;牛魔王&quot;&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;Child.joinGame(child01)&lt;br/&gt;Child.joinGame(child02)&lt;br/&gt;Child.joinGame(child03)&lt;/p&gt;&lt;p&gt;Child.showNum()&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Child&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;cName&lt;/span&gt;: &lt;span class=&quot;hljs-title&quot;&gt;String&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;var name = cName&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;object Child {&lt;br/&gt;var total: Int = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;joinGame&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(child: Child)&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;%s 小朋友加入游戏\n&quot;&lt;/span&gt;, child.name)&lt;br/&gt;total += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;showNum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;printf(&lt;span class=&quot;hljs-string&quot;&gt;&quot;当前有 %d 个小朋友在玩游戏\n&quot;&lt;/span&gt;, total)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;白骨精 小朋友加入游戏&lt;br/&gt;银角大王 小朋友加入游戏&lt;br/&gt;牛魔王 小朋友加入游戏&lt;br/&gt;当前有 &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; 个小朋友在玩游戏&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h816apply&quot;&gt;&lt;span&gt;&lt;strong&gt;8.1.6 伴生对象-apply 方法&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  在伴生对象中定义 apply 方法，可以实现： &lt;code&gt;类名(参数)&lt;/code&gt; 方式 来创建对象实例。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;11&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;16&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter08.apply&lt;p&gt;object ApplayDemo01 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args: Array[String])&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;val list = List(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)&lt;br/&gt;println(list) &lt;/p&gt;&lt;p&gt;&lt;br/&gt;val p1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Pig(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小花猪&quot;&lt;/span&gt;)&lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;p1.name=&quot;&lt;/span&gt;+p1.name)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;val p2 = Pig(&lt;span class=&quot;hljs-string&quot;&gt;&quot;小黑猪&quot;&lt;/span&gt;) &lt;br/&gt;val p3 = Pig() &lt;/p&gt;&lt;p&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;p2.name=&quot;&lt;/span&gt;+p2.name)&lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;p3.name=&quot;&lt;/span&gt;+p3.name)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Pig&lt;/span&gt;(&lt;span class=&quot;hljs-title&quot;&gt;pName&lt;/span&gt;: &lt;span class=&quot;hljs-title&quot;&gt;String&lt;/span&gt;) &lt;/span&gt;{&lt;br/&gt;var name: String = pName&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;object Pig {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(pName: String)&lt;/span&gt;: Pig &lt;/span&gt;= &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Pig(pName)&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;apply&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;: Pig &lt;/span&gt;= &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Pig(&lt;span class=&quot;hljs-string&quot;&gt;&quot;默认同名猪猪&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;List(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;)&lt;br/&gt;p1.name=小花猪&lt;br/&gt;p2.name=小黑猪&lt;br/&gt;p3.name=默认同名猪猪&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h82&quot;&gt;&lt;span&gt;&lt;strong&gt;8.2 单列对象&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  这个部分我们放在【第十七章 scala 设计模式】专题进行讲解。&lt;/p&gt;
&lt;h3 id=&quot;h83&quot;&gt;&lt;span&gt;&lt;strong&gt;8.3 接口&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h831java&quot;&gt;&lt;span&gt;&lt;strong&gt;8.3.1 回顾 Java 接口&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIy1f.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h832scala&quot;&gt;&lt;span&gt;&lt;strong&gt;8.3.2 Scala 接口的介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIRBQ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;trait 原理示意图如下：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIW7j.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h833trait&quot;&gt;&lt;span&gt;&lt;strong&gt;8.3.3 trait 的声明&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABI4Nn.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter08.mytrait&lt;p&gt;object TraitDemo01 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args: Array[String])&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;object T1 extends Serializable {&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;object T2 extends Cloneable {&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h834scalatrait&quot;&gt;&lt;span&gt;&lt;strong&gt;8.3.4 Scala 中 trait 的使用&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABI5hq.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h84trait&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4 特质 trait&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h841&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.1 特质的快速入门案例分析&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABI7cT.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h842&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.2 代码完成&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;13.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;21&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter08.mytrait&lt;p&gt;object TraitDemo02 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args: Array[String])&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;val c1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; C()&lt;br/&gt;val e1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; E()&lt;br/&gt;c1.getConnect()&lt;br/&gt;e1.getConnect()&lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;----------&quot;&lt;/span&gt;)&lt;br/&gt;c1.getConnect(&lt;span class=&quot;hljs-string&quot;&gt;&quot;张三&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;123456&quot;&lt;/span&gt;)&lt;br/&gt;e1.getConnect(&lt;span class=&quot;hljs-string&quot;&gt;&quot;李四&quot;&lt;/span&gt;, &lt;span class=&quot;hljs-string&quot;&gt;&quot;000000&quot;&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;trait trait02 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;getConnect&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;def &lt;span class=&quot;hljs-title&quot;&gt;getConnect&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(user: String, pwd: String)&lt;/span&gt;: Unit&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;class A {}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;B&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;/span&gt;{}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;C&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;trait02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;override def &lt;span class=&quot;hljs-title&quot;&gt;getConnect&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;c 连接mysql&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;override def &lt;span class=&quot;hljs-title&quot;&gt;getConnect&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(user: String, pwd: String)&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;println(user +&lt;span class=&quot;hljs-string&quot;&gt;&quot; 用户连接mysql&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;D&lt;/span&gt; &lt;/span&gt;{}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;E&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;D&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;trait02&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;override def &lt;span class=&quot;hljs-title&quot;&gt;getConnect&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;e 连接oracle&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;getConnect&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(user: String, pwd: String)&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;println(user +&lt;span class=&quot;hljs-string&quot;&gt;&quot; 用户连接oracle&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;F&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;D&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;c 连接mysql&lt;br/&gt;e 连接oracle&lt;br/&gt;----------&lt;br/&gt;张三 用户连接mysql&lt;br/&gt;李四 用户连接oracle&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h843trait&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.3 特质 trait 的再说明&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  1、Scala 提供了特质（trait），特质可以同时拥有抽象方法和具体方法，一个类可以实现/继承多个特质。&lt;br/&gt;  2、特质中没有实现的方法就是抽象方法。类通过 extends 继承特质，通过 with 可以继承多个特质。&lt;br/&gt;  3、所有的 java 接口都可以当做 Scala 特质使用。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;7&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter08.mytrait&lt;p&gt;object TraitDemo03 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args: Array[String])&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;val s1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Sheep&lt;br/&gt;s1.sayHi()&lt;br/&gt;s1.sayHello()&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;trait Trait03 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;def &lt;span class=&quot;hljs-title&quot;&gt;sayHello&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;say hello&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Sheep&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Trait03&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;override def &lt;span class=&quot;hljs-title&quot;&gt;sayHi&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;say hi&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;say hi&lt;br/&gt;say hello&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例代码的底层源码分析图解：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIT3V.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;演示一个类继承多个特质的语法：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIo90.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h844&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.4 带有具体实现的特质&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  说明：和 Java 中的接口不太一样的是特质中的方法并不一定是抽象的，也可以有非抽象方法(即：实现了的方法)。实现了的方法的术语: 默认实现。提示：在 jdk1.8 中接口也可以有默认实现，就是 scala 的 trait 的带来的特性。&lt;br/&gt;示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter08.mytrait&lt;p&gt;&lt;br/&gt;object TraitDemo04 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args: Array[String])&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;val mysql = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MySQL0&lt;br/&gt;mysql.insert(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;trait Operate0 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id: Int)&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;保存数据=&quot;&lt;/span&gt; + id)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;trait DB0 extends Operate0 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;override def &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id: Int)&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;向数据库中&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt;.insert(id)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MySQL0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;DB0&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;向数据库中保存数据=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h845mixin&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.5 带有特质的对象：动态混入(mixin)&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIquF.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter08.mixin&lt;p&gt;&lt;br/&gt;object MixinDemo01 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args: Array[String])&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;val oracle = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; OracleDB1 with Operate1 &lt;br/&gt;oracle.insert(&lt;span class=&quot;hljs-number&quot;&gt;999&lt;/span&gt;)&lt;br/&gt;val mysql = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MySQL1 with Operate1&lt;br/&gt;mysql.insert(&lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;val mysql11 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MySQL11 with Operate1 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;override def &lt;span class=&quot;hljs-title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;say&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;mysql11.insert(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;)&lt;br/&gt;mysql11.say()&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;trait Operate1 { &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id: Int)&lt;/span&gt;: Unit &lt;/span&gt;= { &lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;插入数据=&quot;&lt;/span&gt; + id)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;OracleDB1&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MySQL1&lt;/span&gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MySQL11&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;插入数据=&lt;span class=&quot;hljs-number&quot;&gt;999&lt;/span&gt;&lt;br/&gt;插入数据=&lt;span class=&quot;hljs-number&quot;&gt;400&lt;/span&gt;&lt;br/&gt;插入数据=&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;&lt;br/&gt;say&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;练习：在 Scala 中创建对象共有几种方式/形式？&lt;/strong&gt;&lt;br/&gt;  1、new 对象&lt;br/&gt;  2、apply 创建&lt;br/&gt;  3、匿名子类方式&lt;br/&gt;  4、动态混入方式&lt;/p&gt;
&lt;h4 id=&quot;h846&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.6 叠加特质&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIvNR.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;12.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;19&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter08.mixin&lt;p&gt;&lt;br/&gt;object AddTraitsDemo02 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args: Array[String])&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;val mysql1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;MySQL2 with DB2 with File2&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(mysql1)&lt;/span&gt;&lt;br/&gt;mysql1.&lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;888&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-title&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;----------&quot;&lt;/span&gt;)&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;val mysql2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;hljs-function&quot;&gt;MySQL2 with File2 with DB2&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(mysql2)&lt;/span&gt;&lt;br/&gt;mysql2.&lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-number&quot;&gt;999&lt;/span&gt;)&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;trait Operate2 { &lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Operate2&quot;&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id: Int)&lt;/span&gt; &lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;trait Data2 extends Operate2 { &lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Data2&quot;&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;override def &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id: Int)&lt;/span&gt;: Unit &lt;/span&gt;= { &lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;插入数据=&quot;&lt;/span&gt; + id)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;trait DB2 extends Data2 { &lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;DB2&quot;&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;override def &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id: Int)&lt;/span&gt;: Unit &lt;/span&gt;= { &lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;向数据库 &quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt;.insert(id)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;trait File2 extends Data2 { &lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;File2&quot;&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;override def &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id: Int)&lt;/span&gt;: Unit &lt;/span&gt;= { &lt;br/&gt;print(&lt;span class=&quot;hljs-string&quot;&gt;&quot;向文件 &quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt;.insert(id)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MySQL2&lt;/span&gt; &lt;/span&gt;{} &lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;Operate2&lt;br/&gt;Data2&lt;br/&gt;DB2&lt;br/&gt;File2&lt;br/&gt;com.atguigu.chapter08.mixin.AddTraitsDemo02$$anon$&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;@&lt;span class=&quot;hljs-number&quot;&gt;23223&lt;/span&gt;dd8&lt;br/&gt;向文件 向数据库 插入数据=&lt;span class=&quot;hljs-number&quot;&gt;888&lt;/span&gt;&lt;br/&gt;----------&lt;br/&gt;Operate2&lt;br/&gt;Data2&lt;br/&gt;File2&lt;br/&gt;DB2&lt;br/&gt;com.atguigu.chapter08.mixin.AddTraitsDemo02$$anon$&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;@&lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt;dc36524&lt;br/&gt;向数据库 向文件 插入数据=&lt;span class=&quot;hljs-number&quot;&gt;999&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;叠加特质注意事项和细节&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABILB4.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h847&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.7 在特质中重写抽象方法特例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIHjU.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;解决问题方式&lt;/strong&gt;&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIOHJ.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;9&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;12&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter08.mixin&lt;p&gt;object MixinSpecialCaseDemo03 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args: Array[String])&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;val mysql5 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MySQL3 with DB3 with File3    &lt;br/&gt;mysql5.insert(&lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;trait Operate3 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id: Int)&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;trait File3 extends Operate3 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;abstract&lt;/span&gt; override def &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id: Int)&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;将数据保存到文件中&quot;&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;super&lt;/span&gt;.insert(id)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;trait DB3 extends Operate3 { &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(id: Int)&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;将数据保存到数据库中&quot;&lt;/span&gt;)&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MySQL3&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;将数据保存到文件中&lt;br/&gt;将数据保存到数据库中&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在特质中重写抽象方法理解 abstract override 的小技巧分享：&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIjE9.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h848&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.8 当作富接口使用的特质&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABIx41.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h849&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.9 特质中的具体字段&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABop36.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;6.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;7&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter08.mixin&lt;p&gt;object MixinFieldDemo04 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args: Array[String])&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;var mysql = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MySQL4 with DB4 {&lt;br/&gt;override var i = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;println(mysql.s) &lt;br/&gt;println(mysql.i) &lt;/p&gt;&lt;p&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;trait Operate4 {&lt;br/&gt;var i: Int &lt;br/&gt;var s: String &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;br/&gt;}&lt;/span&gt;&lt;/p&gt;&lt;p&gt;trait DB4 extends Operate4 {&lt;br/&gt;var s: String = &lt;span class=&quot;hljs-string&quot;&gt;&quot;insert&quot;&lt;/span&gt; &lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;insert&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;}&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MySQL4&lt;/span&gt; &lt;/span&gt;{}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图解如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABoS9x.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h8410&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.10 特质中的抽象字段&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  特质中未被初始化的字段在具体的子类中必须被重写。&lt;/p&gt;
&lt;h4 id=&quot;h8411&quot;&gt;&lt;span&gt;&lt;strong&gt;8.4.11 特质的构造顺序&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;第 1 种特质的构造顺序(声明类的同时混入特质)&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABo9gK.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;第 2 种特质的构造顺序(在构建对象时，动态混入特质)&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABoCjO.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;分析两种方式对构造顺序的影响&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/30/ABoEEd.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;示例代码如下：
&lt;pre readability=&quot;5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;4&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;package&lt;/span&gt; com.atguigu.chapter08.mixin&lt;p&gt;object MixinSequenceDemo05 {&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;def &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(args: Array[String])&lt;/span&gt;: Unit &lt;/span&gt;= {&lt;br/&gt;val ff1 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; FF()&lt;br/&gt;println(ff1)&lt;br/&gt;&lt;/p&gt;&lt;p&gt;println(&lt;span class=&quot;hljs-string&quot;&gt;&quot;----------&quot;&lt;/span&gt;)&lt;/p&gt;&lt;p&gt;&lt;br/&gt;val ff2 = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; KK() &lt;span class=&quot;hljs-function&quot;&gt;with CC with DD&lt;br/&gt;&lt;span class=&quot;hljs-title&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ff2)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 30 Mar 2019 06:58:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>第八章 面向对象编程-高级8.1 静态属性和静态方法8.1.1 静态属性-提出问题8.1.2 基本介绍8.1.3 伴生对象的快速入门8.1.4 伴生对象的小结8.1.5 最佳实践-使用伴生对象解决小孩</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10627366.html</dc:identifier>
</item>
<item>
<title>Python3+Selenium2完整的自动化测试实现之旅（七）：完整的轻量级自动化框架实现 - 苍穹之颠</title>
<link>http://www.cnblogs.com/tdp0108/p/10595004.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tdp0108/p/10595004.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        前面系列Python3+Selenium2自动化系列博文，陆陆续续总结了自动化环境最基础环境的搭建、IE和Chrome浏览器驱动配置、selenium下的webdriver模块提供的元素定位和操作鼠标、键盘、警示框、浏览器cookie、多窗口切换等场景的方法、web自动化测试框架、python面向对象和POM设计模型以及python下的单元测试模块unittest模块。本来计划陆续循序渐进的继续写一些篇章总结python面向对象编程、python下的logging日志模块、os.path路径处理模块、time模块处理时间，如格式化时间输出以及一些第三方模块如读取和向excel文件中写入数据的模块：xlrd和xlwt，写完这些后，再开始写本篇的终极目标：编写一个轻量级的自动化测试框架。最终放弃这样做，原因：楼主发现python面向对象编程、python的这些标准库模块或者第三方模块其实很多博客已经做了很好的总结，总之，会学习的人，百度后总能从一大堆的文章中，查看并甄选出对自己解决问题或者思考有帮助和收获的文章，如百度python logging模块使用，多看博文就一定能找到对自己有帮助的文章。曾经楼主也是在学习实践中遇到很多坑，也是根据IDE输出上提示的错误自己先思考解决，还是不行就百度一下或者看书，并深度学习下这块的内容，然后再去解决问题，从这些博文以及自己买的python类的书籍中也是受益良多，这也是楼主一直以来自己的学习方式。这里，每个人都有自己的学习和思考问题的方式，找准适合自己的学习方式并执行它，完成一个阶段目标，然后设置下一个新目标，并为之努力。因此，在写这个轻量级的自动化web测试框架前，我跳过了上述诸多内容，包括且不限于：python面向对象编程、python常用标准库loggging、time、os.path运用等等，在后面的轻量级框架代码中会有部分注释，对于这些python相关的内容学习，大家根据自己的情况去充实，坚持学习并持之以恒。在楼主身边，有太多类似的人学习总是三天晒鱼、两天打网的，完全沉不下心来学习东西，浅尝辄止，没有积淀，如果认定一个东西就去想办法搞定，加油！楼主也在为自己新的目标fighting中，当然目标是广义的，可以是生活方面、工作方面、情感方面.......，好像跑偏题了O(∩_∩)O，这些人生鸡汤似的废话就不说了，看看下面这个web自动化测试框架是如何实现的吧~&lt;/p&gt;
&lt;p&gt; 二&lt;strong&gt;、项目架构说明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt;该项目架构基于楼主公司的一款B/S软件设计，大家也可以根据自己的被测软件来构建适合自己的架构层级，当然也可以参考楼主的。做自动化测试项目，当搞懂了思想和方法，其实都是万变不离其宗，就跟写代码一样，语言万千种，唯一不变的就是语言中殊途同归的思想，因此，玩会了套路自然就能凌驾于套路之上，运用并加入自己的东西。在PyCharm中新建如下的项目层级：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582177/201903/1582177-20190326143156305-1986378567.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       有过开发经历的小伙伴都知道，有个好的交互式开发工具对于我们创建和管理清晰的项目架构很方便，PyCharm就是一款交互良好的python开发工具。楼主上面的项目层级中部分目录和目录下的文件没展开，下面显示一个完整的目录结构，并说明每个目录是用来干嘛？放什么东西？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582177/201903/1582177-20190326145902233-725195362.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        当然这个项目层级设计，不是楼主一时间就固定下来的，也是在不断的摸索和采坑中，不断调整出的一个适合自己的框架目录层级。项目框架设计好了后，接下来就是慢慢补充内容一步步实现上面每个目录需要的东西。来吧，开始造轮子~&lt;/p&gt;
&lt;p&gt; 三&lt;strong&gt;、配置文件设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       首先，对于上面的config.ini的配置文件进行配置。说到配置文件，不管是开发人员还是测试人员都不会陌生，还有xml、txt等格式的配置文件，配置文件就是用来配置一些参数和固定的变量值，一般是程序固定不变的东西我们就放这里面，用于程序直接调用，如果修改配置文件中变量的值，程序调用该变量就会产生不同的输出行为。如在做自动化测试时，我们可以将测试的不同浏览器写入到该文件中，当我们需要调用firefox浏览器时，将参数设置成firefox即可，测试脚本将会在火狐浏览器进行。如下图，在配置文件中设置了浏览器参数、测试url、邮件服务器、邮件发送和接收者等参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582177/201903/1582177-20190326152656817-2035753075.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于为什么这个ini配置文件需要编辑成【###】然后下面是参数或者变量的赋值，自己百度学习：ini配置文件格式，看下是怎么编辑的？都有哪些要素？&lt;/p&gt;
&lt;p&gt;四&lt;strong&gt;、日志类模块的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       说到日志，大家都明白日志的作用，最明显的作用就是在程序的关键位置或者步骤节点下设置日志输出，当程序运行时，会输出日志，日志是我们查看程序运行情况和查找错误的重要手段。因此，对于自动化测试也是如此，我们需要知道自动化执行的情况以及执行错误的情况发生了什么，那就需要给你的自动化测试项目封装一个日志类的功能模块，用于输出日志。python语言封装了一个叫logging的标准库模块，能够设置日志等级以及怎么输出、输出到哪里。对于logging模块，大家可以自己针对性去学习该模块的使用。&lt;/p&gt;
&lt;p&gt;       我们在上面的项目层级的models目录下创建log.py文件，在这个模块文件下定义一个叫做Logger的日志类，完成日志类的封装，编辑如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
'''
  Code description：封装日志类，定义日志文件输出格式和日志输出级别
  Create time：2018-11-8
  Developer：
'''
# -*- coding: utf-8 -*-
import logging
import time
import os.path
class Logger(object):
    def __init__(self,logger,CmdLevel = logging.INFO,FileLevel = logging.INFO):
        self.logger = logging.getLogger(logger)
        self.logger.setLevel(logging.DEBUG)   # 设置日志默认级别为DEBUG
        fmt = logging.Formatter('%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s - %(message)s') # 设置日志输出格式
        currTime = time.strftime('%Y%m%d%H%M',time.localtime(time.time()))  # 格式化当前时间
        log_path = os.path.dirname(os.path.abspath('E:\V2200_AutoTest\\testcase')) + '/log/logs/'  # 设置日志文件保存路径
        # log_path = os.path.dirname(os.path.abspath('.')) + '/log/logs/'      # 相对路径写法
        # print(os.path.dirname(os.path.abspath('E:\V2200_AutoTest\\testcase')))
        print('得到的日志路径为：', log_path)
        log_name = log_path + currTime + '.log'  # 设置日志文件名称

        # 设置由文件输出
        fh = logging.FileHandler(log_name,encoding='utf-8')  # 采用utf-8字符集格式防止出现中文乱码
        fh.setFormatter(fmt)
        fh.setLevel(FileLevel)  # 日志级别为INFO

        # 设置日志由控制台输出
        # sh = logging.StreamHandler(log_name)
        # sh.setFormatter(fmt)
        # sh.setLevel(CmdLevel)
        self.logger.addHandler(fh)  # 添加handler
    def getlog(self):
        return self.logger
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;     这样我们就自定义封装了一个简单的日志类模块，设置了日志输出级别、输出格式以及输出日志的位置，后面其他模块需要输出日志时，就可以调用引入该日志类。&lt;/p&gt;
&lt;p&gt; 五&lt;strong&gt;、浏览器模块的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;/strong&gt;日志类实现简单封装后，继续造轮子~。此部分用于封装浏览器模块，主要实现打开和关闭不同浏览器的方法，这里就用到了POM的思想，咱们封装了浏览器的类型和打开关闭方法，那么后面每条测试脚本就可以直接调用打开和关闭浏览器方法，脚本只需要专注具体的测试业务逻辑的实现即可。在models目录下新建broser_engine.py文件，自定义一个叫做BrowserEngine类，实现浏览器模块的封装，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
'''
  Code description：封装浏览器引擎类，读取配置文件实现浏览器类型的选择，并封装打开浏览器和退出的方法
  Create time：2018-11-12
  Developer：
'''
# -*- coding: utf-8 -*-
import configparser          # python解析配置文件模块
import os.path
from selenium import webdriver
from V2200.test.models.log import Logger     # 引入日志类模块

logger = Logger(logger=&quot;BrowserEngine&quot;).getlog()    # 实例化对象logger

class BrowserEngine(object):
    def __init__(self, driver):
        self.driver = driver   # 初始化构造函数，将参数driver self化便于后面创建的方法直接自动调用
    def open_browser(self, driver):
        '''
        :param driver: 读取配置文件，返回driver
        :return:
        '''
        config = configparser.ConfigParser()
        file_path = os.path.abspath('E:\V2200_AutoTest\V2200\config\config.ini')   # 绝对路径写法
        #print('得到的读取config文件的路径：',file_path)
        config.read(file_path,encoding='UTF-8')    # 读取配置文件
        browser = config.get(&quot;browserType&quot;, &quot;browserName&quot;)
        logger.info(&quot;选择的浏览器是： %s .&quot; % browser)
        url = config.get(&quot;testServer&quot;, &quot;URL&quot;)
        logger.info(&quot;测试的平台URL是: %s&quot; % url)

        if browser == &quot;Firefox&quot;:
            driver = webdriver.Firefox()
            logger.info(&quot;Starting firefox browser.&quot;)
        elif browser == &quot;Chrome&quot;:
            driver = webdriver.Chrome()
            logger.info(&quot;Starting Chrome browser.&quot;)
        elif browser == &quot;Ie&quot;:
            driver = webdriver.Ie()
            logger.info(&quot;Starting IE browser.&quot;)

        driver.get(url)                        # 得到测试的url
        logger.info(&quot;浏览器的版本为：%s&quot; % driver.capabilities['version'])  # 获取浏览器版本
        driver.maximize_window()
        logger.info(&quot;最大化浏览器窗口.&quot;)
        driver.implicitly_wait(10)
        return driver

    def quit_browser(self):
        self.driver.quit()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　六&lt;strong&gt;、页面基类的实现&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        此部分用于封装页面基类，主要用于封装一些常用的公共方法，如截图方法、元素定位方法、元素通用操作方法、警示框处理方法等等，只要软件页面一些常用的操作都可以写在该页面基类中，这个页面基础类就类似于一个公共函数库一样，封装这些方法，后面有需要的地方直接调用即可。如下代码，已经封装了8大元素定位方法、截图方法、鼠标点击方法、警示框处理方法等，后续根据自己的需要自行补充丰富一些常用的功能函数或者方法。这里可以着重看下8大元素定位方法的封装~&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;51&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
'''
  Code description：页面基类，封装所有页面共用的方法
  Create time：2018-11-13
  Developer：
'''
# -*- coding: utf-8 -*-
import time
import os.path
from V2200.test.models.log import Logger
from selenium.common.exceptions import NoSuchElementException    # selenium下封装的判断元素是否存在的模块
logger = Logger(logger='BasePage').getlog()
class BasePage(object):
    # 构造方法,初始化参数driver,用于后面的方法直接调用
    def __init__(self,driver):
        self.driver = driver
    # 浏览器前进
    def forward_browser(self):
        self.driver.forward()
        logger.info(&quot;在当前页面中点击浏览器前进.&quot;)
    # 浏览器后退
    def back_browser(self):
        self.driver.back()
        logger.info(&quot;在当前页面中点击浏览器后退.&quot;)
    # 设置隐式等待时间
    def wait(self,seconds):
        self.driver.implicitly_wait(seconds)
        logger.info(&quot;设置隐式时间：%d 秒.&quot; % seconds)
    # 关闭当前窗口
    def close_window(self):
        try:
            self.driver.close()
            logger.info(&quot;关闭当前窗口.&quot;)
        except NameError as e:
            logger.error(&quot;关闭当前窗口出错，抛出错误提示：%s.&quot; % e)
    # 截图功能:得到截图并保存图片到项目image目录下
    def get_window_img(self):
        file_path = os.path.dirname(os.path.abspath('.')) + '/image/'  # 设置存放截图的路径
        # print('截图保存路径为：%s' % file_path)
        timeset = time.strftime('%Y%m%d%H%M%S',time.localtime(time.time()))       # 格式化时间
        pic_name = file_path + timeset + '.png'                                   # 定义截图文件名称
        try:
            self.driver.get_screenshot_as_file(pic_name)
            logger.info('截图成功，图片保存路径为：/image.')
        except Exception as e :
            logger.error('截图出现异常',format(e))
            self.get_window_img()

    # 8大页面元素（对象）定位方法的封装
    def find_element(self,selector):
        '''
        使用‘=&amp;gt;’作为字符串分割符，后续实际测试用例根据输入的元素selector_by和selector_value 进行选择元素的定位类型
        :param selector:
        :return: element
        '''
        element = ''
        if '=&amp;gt;' not in selector:
            return self.driver.find_element_by_id(selector)
        selector_by = selector.split('=&amp;gt;')[0]   # 按=&amp;gt;分割符进行切割字符串，返回一个列表，得到列表的第一个元素，即元素的定位方法
        selector_value = selector.split('=&amp;gt;')[1]  # 得到列表的第二个元素，即元素定位的值

        if selector_by == 'i' or selector_by == 'id':
            try:
                element = self.driver.find_element_by_id(selector_value)
                logger.info(&quot;定位元素OK，实际定位元素方法：%s ,定位的元素的属性值：%s&quot; % (selector_by,selector_value))
            except NoSuchElementException as e:
                logger.error(&quot;没找到元素，抛出异常：%s&quot; % e)
                self.get_window_img()  # 截取当前窗口
        elif selector_by == 'n' or selector_by == 'name':
            element = self.driver.find_element_by_name(selector_value)
        elif selector_by == 'c' or selector_by == 'class_name':
            element = self.driver.find_element_by_class_name(selector_value)
        elif selector_by == 'l' or selector_by == 'link_text':
            element = self.driver.find_element_by_link_text(selector_value)
        elif selector_by == 'p' or selector_by == 'partial_link_text':
            element = self.driver.find_element_by_partial_link_text(selector_value)
        elif selector_by == 't' or selector_by == 'tag_name':
            element = self.driver.find_element_by_tag_name(selector_value)
        elif selector_by == 'x' or selector_by == 'xpath':
            try:
                element = self.driver.find_element_by_xpath(selector_value)
                logger.info(&quot;定位元素OK，实际定位元素方法：%s ,定位的元素的属性值：%s&quot; % (selector_by, selector_value))
            except NoSuchElementException as e:
                logger.error(&quot;没找到元素，抛出异常：%s&quot; % e)
                self.get_window_img()  # 截取当前窗口
        elif selector_by == 'c' or selector_by == 'css_selector':
            element = self.driver.find_element_by_css_selector(selector_value)
        else:
            raise NameError(&quot;请输入正确的目标元素类型.&quot;)
        return element  # 返回变量element

    # 封装输入框方法
    def type(self,selector,text):
        el = self.find_element(selector)
        el.clear()
        try:
            el.send_keys(text)
            logger.info(&quot;输入的文本内容为：%s&quot; % text)
        except NameError as e:
            logger.error(&quot;输入的内容异常，抛出异常：%s&quot; % e)
            self.get_window_img()

    # 清除文本内容
    def clear(self,selector):
        el = self.find_element(selector)
        try:
            el.clear()
            logger.info(&quot;清除输入框文本信息OK&quot;)
        except NameError as e:
            logger.error(&quot;清除输入框内容失败：抛出异常: %s&quot; % e)
            self.get_window_img()
    # 封装点击元素的动作
    def click(self,selector):
        el = self.find_element(selector)
        try:
            el.click()
            logger.info(&quot;点击元素动作完成&quot;)
        except NameError as e:
            logger.error(&quot;点击事件失败，抛出异常：%s&quot; % e)
    # 获取打开的url地址标题
    def get_page_title(self):
        logger.info(&quot;当前打开的url地址标题为：%s&quot; % self.driver.title)
        return self.driver.title

    # 获取警示框，并得到提示框信息和关闭提示框
    def get_alert(self):
        el = self.driver.switch_to.alert    # 获取窗口弹窗的方法
        try:
            assert '用户名或者密码错误' in el.text    # el.text方法获取提示框内容
            logger.info(&quot;弹窗提示正确&quot;)
            el.accept()                              # 点击弹窗确认按钮
        except Exception as e:
            print('弹窗提示错误', format(e))

    @staticmethod        #  静态方法：不强制要求传递参数，类可以不用实例化就能调用该方法
    def sleep(seconds):
        time.sleep(seconds)
        logger.info(&quot;等待时间是：%s 秒&quot; % seconds)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　七&lt;strong&gt;、登陆页面元素的封装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;        在上面我们实现了页面基类的封装，下图为楼主公司的一个软件登陆页面，在page_obj目录下新建home_page.py实现这个登陆页面元素定位和元素操作方法的封装&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582177/201903/1582177-20190330103816553-987847198.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;46&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
'''
  Code description： 继承基类，封装登陆页面所有的元素和元素的操作方法
  Create time：2018-11-16
  Developer：
'''
# -*- coding: utf-8 -*-
from V2200.test.models.base_page import BasePage
import xlrd                                    # excel操作相关的模块
from V2200.test.models.log import Logger
excelfile_path = 'E:\V2200_AutoTest\V2200\data\\testdata\elementData.xlsx'
workbook = xlrd.open_workbook(excelfile_path)
table_sheetName = workbook.sheet_by_name('登陆页面业务组件')
logger = Logger(logger='HomePage').getlog()
class HomePage(BasePage):
    def __init__(self,driver):
        BasePage.__init__(self,driver)        # 继承父类，并调用父类的初始化方法
        self.input_username = table_sheetName.cell(1,1).value   # 读取excel表中用户名输入框元素
        self.input_password = table_sheetName.cell(2,1).value   # 读取excel表中密码输入元素
        self.rempwd = table_sheetName.cell(3,1).value           # 读取excel表中是否记住密码按钮元素
        self.loginBtn = table_sheetName.cell(4,1).value         # 读取excel表中登陆按钮元素
        self.centerBtn = table_sheetName.cell(6,1).value        # 读取excel表中切换到中心用户的按钮
        logger.info(&quot;读取excel文件中登陆页面相关元素数据完成&quot;)
    def center_user(self):
        self.click(self.centerBtn)
    def user(self,text):
        self.type(self.input_username,text)
    def pwd(self,text):
        self.type(self.input_password,text)
    def ifrempwd(self):
        self.click(self.rempwd)
    def login(self):
        self.click(self.loginBtn)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这里引入了第三方的xlrd模块，用于读取excel文件中的数据，当然还有xlwt模块用于向excel写数据，说白了这两个模块就是实现操作excel，上面代码只用到了xlrd模块，在编写上面登陆页面的封装前，咱们先将登陆页面定位的元素和元素属性写到对应的excel表中，这样做的好处就是实现测试数据和测试脚本的分离，如果页面元素发生变化，那么我们就只需要修改excel中的元素属性而不需要修改代码，在data/testdata目录下新建名称为elementData.xlsx的文件，excel编辑内容如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582177/201903/1582177-20190330105302077-436717852.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;    后续各个页面的元素都是定位以及元素的数据都是可以写在不同的sheet中，至于xlrd模块具体向excel中读数据的方法以及使用，这里也是不做介绍，自己百度学习练习下就知道了。&lt;/p&gt;
&lt;p&gt;软件其他页面的封装也是类似，按照上面的思想来就OK了。&lt;/p&gt;
&lt;p&gt; 八&lt;strong&gt;、登陆页面测试脚本的编写&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    通过上面封装的基类和登陆页面类，在unittest框架下开始编写具体的测试脚本。测试脚本在testcase下，如登陆功能的脚本我们写在：testcase/login_page_case目录下，其他页面的脚本写在对应的目录下。在testcase/login_page_case目录下创建：test_login_success.py和test_login_unsuccess.py分别表示登陆成功的脚本和登陆不成功的脚本。如下代码：&lt;/p&gt;
&lt;p&gt;登陆成功代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
'''
  Code description：测试登陆  Create time：2018-11-20  Developer：
'''
# -*- coding: utf-8 -*-
import unittest
# unittest执行测试用例，默认是根据ASCII码的顺序加载测试用例，数字与字母的顺序为：0-9，A-Z，a-z。
import time
from V2200.test.models.browser_engine import BrowserEngine
from V2200.test.page_obj.home_page import HomePage
import xlrd
excelfile_path = 'E:\V2200_AutoTest\V2200\data\\testdata\elementData.xlsx'
workbook = xlrd.open_workbook(excelfile_path)
table_sheetName = workbook.sheet_by_name('登陆页面业务组件')
class Login(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # 测试前置条件
        browser = BrowserEngine(cls)
        cls.driver = browser.open_browser(cls)
    @classmethod
    def tearDownClass(cls):
        # 测试结束后环境的复原
        cls.driver.quit()
# case1:正确的用户密码登陆
    def test_1_login_sucess(self):
        homepage = HomePage(self.driver)
        homepage.user(table_sheetName.cell(1,2).value)     # 读取excel中的数据
        homepage.pwd(table_sheetName.cell(2,2).value)
        homepage.ifrempwd()
        homepage.login()
        time.sleep(2)
        try:
            assert '视频监控' in homepage.get_page_title()
            print('test title success')
            homepage.get_window_img()  # 调用Basepage类封装的截图方法
        except Exception as e:
            print('test title error', format(e))

if  __name__  ==  '__main__':
    unittest.main()            # 将一个单元测试模块变成可以直接运行的测试脚本
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　登陆不成功代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
'''
  Code description：测试登陆  Create time：2018-11-20  Developer：
'''
# -*- coding: utf-8 -*-
import unittest
# unittest执行测试用例，默认是根据ASCII码的顺序加载测试用例，数字与字母的顺序为：0-9，A-Z，a-z。
import time
from V2200.test.models.browser_engine import BrowserEngine
from V2200.test.page_obj.home_page import HomePage
import xlrd
# from V2200.test.page_obj.link_page import LinkPage
excelfile_path = 'E:\V2200_AutoTest\V2200\data\\testdata\elementData.xlsx'
workbook = xlrd.open_workbook(excelfile_path)
table_sheetName = workbook.sheet_by_name('登陆页面业务组件')
class LoginUnsuccess(unittest.TestCase):
    @classmethod
    def setUpClass(cls):
        # 测试前置条件
        browser = BrowserEngine(cls)
        cls.driver = browser.open_browser(cls)
    @classmethod
    def tearDownClass(cls):
        # 测试结束后环境的复原
        cls.driver.quit()
# case2:错误的用户+正确的密码登陆
    def test_2_login_erroruser(self):
        homepage = HomePage(self.driver)
        homepage.user(table_sheetName.cell(1, 3).value)     # 读取excel中的数据
        homepage.pwd(table_sheetName.cell(2, 3).value)
        homepage.ifrempwd()
        homepage.login()
        time.sleep(2)
        try:
            assert '视频监控' in homepage.get_page_title()
            print('test title success')
            homepage.get_window_img()  # 调用Basepage类封装的截图方法
        except Exception as e:
            print('test title error',format(e))

# case3:正确的用户+错误的密码登陆
    def test_3_login_errorpasswd(self):
        homepage = HomePage(self.driver)
        homepage.user(table_sheetName.cell(1, 4).value)     # 读取excel中的数据
        homepage.pwd(table_sheetName.cell(2, 4).value)
        homepage.ifrempwd()
        homepage.login()
        time.sleep(2)
        try:
            assert '视频监控' in homepage.get_page_title()
            print('test title success')
            homepage.get_window_img()  # 调用Basepage类封装的截图方法
        except Exception as e:
            print('test title error', format(e))
# case4:错误的用户+错误的密码登陆
    def test_4_login_erroruser_errorpasswd(self):
        homepage = HomePage(self.driver)
        homepage.user(table_sheetName.cell(1, 5).value)     # 读取excel中的数据
        homepage.pwd(table_sheetName.cell(2, 5).value)
        homepage.ifrempwd()
        homepage.login()
        time.sleep(2)
        try:
            assert '视频监控' in homepage.get_page_title()
            print('test title success')
            homepage.get_window_img()  # 调用Basepage类封装的截图方法
        except Exception as e:
            print('test title error', format(e))

if  __name__  ==  '__main__':
    unittest.main()            # 将一个单元测试模块变成可以直接运行的测试脚本
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　九&lt;strong&gt;、测试执行控制模块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      完成上面的测试脚本编写后，对于自动化测试还需要有一个测试执行控制的部分，用来控制执行哪些用例集，生成HTML可视化的测试报告，并实现测试报告邮件发送。&lt;/p&gt;
&lt;p&gt;在runtest目录下新建run_all_case.py，编辑如下代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;58&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
'''
  Code description： TestLoader测试case,并执行得到的所有测试集，生成html文件的测试报告并邮件发送测试报告
  Create time：2018-11-20
  Developer：
'''
# -*- coding: utf-8 -*-
import HTMLTestRunner1     # 导入开源的测试报告生成HTML格式的模块
import os.path
import time
import unittest
import configparser        # 解析配置文件模块
from email.mime.text import MIMEText
from email.header import Header
import smtplib
&quot;&quot;&quot;
发邮件需要用到python两个模块，smtplib和email，这俩模块是python自带的，只需import即可使用。
smtplib模块主要负责发送邮件，email模块主要负责构造邮件。
其中MIMEText()定义邮件正文，Header()定义邮件标题。MIMEMulipart模块构造带附件

&quot;&quot;&quot;
# ===============定义邮件发送============
def send_mail(file_new):

    config = configparser.ConfigParser()
    file_path = os.path.dirname(os.path.abspath('.')) + '/V2200/config/config.ini'
    config.read(file_path, encoding='UTF-8')                 # 读取config配置文件
    emailserver = config.get(&quot;emailserver&quot;, &quot;emailservice&quot;)
    from_user = config.get(&quot;emailfrom_user&quot;, &quot;from_user&quot;)
    from_passwd = config.get(&quot;emailfrom_passwd&quot;, &quot;from_passwd&quot;)
    to_user = config.get(&quot;emailto&quot;, &quot;to_user&quot;)

    f = open(file_new,'rb')
    mail_boy = f.read()
    f.close()
    msg = MIMEText(mail_boy,'html','utf-8')        # 定义邮件正文
    msg['Subject'] = Header('V2200自动化测试报告','utf-8')  # 定义邮件标题
    smtp = smtplib.SMTP()
    smtp.connect(emailserver)                     #  连接邮箱服务器
    smtp.login(from_user,from_passwd)   #  邮件发送方登陆
    smtp.sendmail(from_user,to_user,msg.as_string())  # 邮件发送者和接收者
    smtp.quit()
    print(&quot;邮件已经发送，请注意查收！&quot;)

# ==============找到最新生成的测试报告文件===========
def new_report(report_path):
    lists = os.listdir(report_path)   # 得到项目目录下所有的文件和文件夹
    lists.sort(key=lambda fn:os.path.getmtime(report_path + '\\' + fn))  # 将得到的文件和文件夹按创建时间排序
    file_new = os.path.join(report_path,lists[-1])  # 获取最新创建的文件
    print(file_new)
    return file_new
# 测试用例路径
# case_path = os.path.join(os.getcwd(),'testcase')
case_path = os.path.abspath('E:\V2200_AutoTest\\testcase')
print(case_path)
# 测试报告路径
report_path = os.path.abspath('E:\V2200_AutoTest\\testreport')
print(report_path)
def all_case():
    '''
    找到case_path路径下所有以test_login开头的测试用例文件,保证每个子目录都是一个包文件，即该目录下
    有__init__.py文件，才能获取到多个目录下的所有test*.py的文件下的所有测试用例
    '''
    all_case = unittest.defaultTestLoader.discover(case_path,pattern=&quot;test_login*.py&quot;,top_level_dir=None)
    print(all_case)
    return all_case
if __name__ == '__main__':
    # 获取当前时间，并格式化时间
    now_time = time.strftime(&quot;%Y-%m-%d-%H_%M_%S&quot;,time.localtime(time.time()))
    # html测试报告路径
    report_html = os.path.join(report_path,&quot;result_&quot;+now_time+&quot;.html&quot;)
    fp = open(report_html,'wb')     # 打开一个文件，将测试结果写入该文件中
    '''
    wb:以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，
    即原有内容会被删除。如果该文件不存在，创建新文件
    '''
    runner = HTMLTestRunner1.HTMLTestRunner(stream=fp,
                                           title=u'V2200自动化测试报告，测试结果如下：',
                                           description=u'用例执行情况：')

    runner.run(all_case())   # 执行所有测试case
    fp.close()
    mail_report = new_report(report_path)
    send_mail(mail_report)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　该代码，编写了怎么获取需要执行的测试用例脚本和引入生成可视化测试报告的模块和发送邮件模块等，对于这几个模块自己多学习下就能掌握。&lt;/p&gt;
&lt;p&gt;十&lt;strong&gt;、测试执行效果&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   &lt;/strong&gt; 通过上面这些类的封装以及测试脚本的编写，算是完成了我们自动化测试框架的基本具备的东西。忙活了这么久，是时候来看看咱们的效果了。PyCharm中运行run_all_case.py，运行完成后的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582177/201903/1582177-20190330135406831-1896876785.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　咱们再看看log/logs路径下生成的日志，就如下图这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582177/201903/1582177-20190330135505464-1028500050.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 同时执行完成后，在testreport目录下会生成HTML格式的可视化测试报告文件，用浏览器打开效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582177/201903/1582177-20190330135659146-259999654.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　这报告是不是很酷炫啊，O(∩_∩)O哈哈~&lt;/p&gt;
&lt;p&gt;     还有测试报告发送邮件给到指定的邮箱哦，如果你的自动化测试执行完了，可以把该自动化测试报告自动邮件发给你的leader，领导看到了是不是对你另眼相看？楼主上面的代码设置发送的是楼主公司内网使用的邮箱：foxmail，效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1582177/201903/1582177-20190330140045280-935749461.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里算是完成了咱们自动化测试框架，并取得了一定的成果~~&lt;/p&gt;
&lt;p&gt;十一&lt;strong&gt;、整个自动化测试框架的总结和反思&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       &lt;/strong&gt; 其实到第十节的介绍，楼主算是成功的做出了一个轻量级的测试框架，but，回过头来继续思考，还是有诸多需要优化和待下一步解决的问题：&lt;/p&gt;
&lt;p&gt;1.页面基类还需要补充更多的公共函数或者方法；&lt;/p&gt;
&lt;p&gt;2.可视化HTML测试报告内容还不够丰富，没有完善的测试执行失败的用例的详细描述和测试截图附件显示；&lt;/p&gt;
&lt;p&gt;3.整个框架的部分逻辑还需要优化和改进；&lt;/p&gt;
&lt;p&gt;4.待解决的问题：没实现测试脚本的持续集成和定时执行，现在想到的是配合jenkins持续集成来达到自动构建测试执行任务；&lt;/p&gt;
&lt;p&gt;5.想独立开发一个web测试平台，现在想到的是学习Django的web框架来开发一个自动化测试平台；&lt;/p&gt;
&lt;p&gt;    对于这样不足和构想，楼主也是会继续学习相关的知识，并一步步实现它，对于看到该博客的朋友们也可以给楼主一些好的建议和指出错误，希望有对自动化测试有兴趣的朋友，大家共同学习和进步哦。&lt;/p&gt;

</description>
<pubDate>Sat, 30 Mar 2019 06:21:00 +0000</pubDate>
<dc:creator>苍穹之颠</dc:creator>
<og:description>一、前言 前面系列Python3+Selenium2自动化系列博文，陆陆续续总结了自动化环境最基础环境的搭建、IE和Chrome浏览器驱动配置、selenium下的webdriver模块提供的元素定位</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tdp0108/p/10595004.html</dc:identifier>
</item>
<item>
<title>最简单易懂的Spring Security 身份认证流程讲解 - 曾俊杰的专栏</title>
<link>http://www.cnblogs.com/ymstars/p/10626786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ymstars/p/10626786.html</guid>
<description>&lt;p&gt;最简单易懂的Spring Security 身份认证流程讲解&lt;/p&gt;
&lt;h3 id=&quot;导言&quot;&gt;导言&lt;/h3&gt;
&lt;p&gt;相信大伙对Spring Security这个框架又爱又恨，爱它的强大，恨它的繁琐，其实这是一个误区，Spring Security确实非常繁琐，繁琐到让人生厌。讨厌也木有办法呀，作为JavaEE的工程师们还是要面对的，在开始之前，先打一下比方（比方好可怜）：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Spring Security 就像一个行政服务中心，如果我们去里面办事，可以办啥事呢？可以小到咨询简单问题、查询社保信息，也可以户籍登记、补办身份证，同样也可以大到企业事项、各种复杂的资质办理。但是我们并不需要跑一次行政服务中心，就挨个把业务全部办理一遍，现实中没有这样的人吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;啥意思呢，就是说选择您需要的服务（功能），无视那些不需要的，等有需要的时候再了解不迟。这也是给众多工程师们的一个建议，特别是体系异常庞大的Java系，别动不动就精通，撸遍源码之类的，真没啥意义，我大脑的存储比较小，人生苦短，没必要。&lt;/p&gt;
&lt;p&gt;回到正题！本文会以一种比较轻松的方式展开，不会是堆代码。&lt;/p&gt;
&lt;h3 id=&quot;关于身份认证&quot;&gt;关于身份认证&lt;/h3&gt;
&lt;p&gt;Web 身份认证是一个后端工程师永远无法避开的领域，身份认证Authentication，和授权Authorization是不同的，Authentication指的是用户身份的认证，并不介入这个用户能够做什么，不能够做什么，仅仅是确认存在这个用户而已。而Authorization授权是建立的认证的基础上的，存在这个用户了，再来约定这个用户能补能够做一件事，这点大家要区分开。本文讲的是Authentication的故事，并不会关注权限。&lt;/p&gt;
&lt;p&gt;热热身，让我们来温习一下身份认证的方式演变：&lt;/p&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;先是最著名的入门留言板程序，相信很多做后端的工程师都做过留言板，那是一个基本没有框架的阶段，回想一下是怎么认证的。表单输入用户名密码Submit，然后后端取到数据数据库查询，查不到的话无情地抛出一个异常，哦，密码错了；查到了，愉快的将用户ID和相关信息加密写入到Session标识中存起来，响应写入Cookie，后续的请求都解密后验证就行了，对吧。是的，身认证真可以简单到仅仅是匹配Session标识而已。令人沮丧的是现代互联网的发展早已经过了 Web2.0 的时代，客户端的出现让身份认证更加复杂。我们继续&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;随着移动端的崛起，Android和ios占据主导，同样是用户登录认证，取到用户信息，正准备按图索骥写入Session回写Cookie的时候，等等！啥？Android不支持Cookie？这听起来不科学是吧，有点反人类是吧，有点手足无措是吧。&lt;/p&gt;
&lt;p&gt;嘿嘿，聪明的人儿也许想到了办法，嗯，Android客户端不是有本地存储吗？把回传的数据存起来不就行了吗？又要抱歉了，Android本地存储并没有浏览器Cookie那么人性化，不会自动过期。没事，再注明过期时间，每次读取的时候判断就行啦，貌似可以了。&lt;/p&gt;
&lt;p&gt;等等。客户端的Api接口要求轻量级，某一天一个队友想实现个性化的事情，竟然往Cookie了回传了一串字符串，貌似很方便，嗯。于是其他队友也效仿，然后Cookie变得更加复杂。此时Android队友一声吼，你们够了！STOP！我只要一个认证标识而已，够简单你们知道吗？还有Cookie过期了就要重新登陆，用户体验极差，产品经理都找我谈了几十次了，用户都快跑光了，你们还在往Cookie里加一些奇怪的东西。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Oauth 2.0来了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有问题总要想办法解决是吧。客户端不是浏览器，有自己特有的交互约定，Cookie还是放弃掉了。这里就要解决五个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[ ] 只需要简单的一个字符串标识，不需要遵守Cookie的规则&lt;/li&gt;
&lt;li&gt;[ ] 服务器端需要能够轻松认证这个标识，最好是做成标准化&lt;/li&gt;
&lt;li&gt;[ ] 不要让用户反复输入密码登录，能够自动刷新&lt;/li&gt;
&lt;li&gt;[ ] 这段秘钥要安全，从网络传输链路层到客户端本地层都要是安全的，就算被中途捕获，也可以让其失效&lt;/li&gt;
&lt;li&gt;[ ] 多个子系统的客户端需要独立的认证标识，让他们能够独立存在（例如淘宝的认证状态不会影响到阿里旺旺的登录认证状态）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需求一旦确定，方案呼之欲出，让我们来简单构思一下。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;[x] 首先是标识，这个最简单了，将用户标识数据进行可逆加密，OK，这个搞定。&lt;/li&gt;
&lt;li&gt;[x] 然后是标识认证的标准化，最好轻量级，并且让她不干扰请求的表现方式，例如Get和Post数据，聪明的你想到了吧，没错，就是Header，我们暂且就统一成 &lt;code&gt;Userkey&lt;/code&gt; 为Header名，值就是那个加密过的标识，够简洁粗暴吧，后端对每一个请求都拦截处理，如果能够解密成功并且表示有效，就告诉后边排队的小伙伴，这个家伙是自己人，叫xxx，兜里有100块钱。这个也搞定了。&lt;/li&gt;
&lt;li&gt;[x] 自动刷新，因为加密标识每次请求都要传输，不能放在一起了，而且他们的作用也不一样，那就颁发加密标识的时候顺便再颁发一个刷新的秘钥吧，相当于入职的时候给你一张门禁卡，这个卡需要随身携带，开门签到少不了它，此外还有一张身份证明，这证明就不需要随身携带了，放家里都行，门禁卡掉了，没关系，拿着证明到保安大哥那里再领一张门禁卡，证明一次有效，领的时候保安大哥贴心的再给你一张证明。&lt;/li&gt;
&lt;li&gt;[x] 安全问题，加密可以加强一部分安全性。传输链路还用说吗？上Https传输加密哟。至于客户端本地的安全是一个哲学问题，嗯嗯嗯。哈哈。我们暂时认为本地私有空间存储是安全的的，俗话说得好，计算机都被人破解了，还谈个鸡毛安全呀（所以大家没事还是不要去ROOT手机了，ROOT之后私有存储可以被访问侬造吗）&lt;/li&gt;
&lt;li&gt;[x] 子系统独立问题，这个好办了。身份认证过程再加入一个因子，暂且叫 Client 吧。这样标识就互不影响了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;打完收工，要开始实现这套系统了。先别急呀，难道没觉得似曾相识吗？没错就是 Oauth 2.0 的 password Grant 模式！&lt;/p&gt;
&lt;h3 id=&quot;spring-security-是怎么认证的&quot;&gt;Spring Security 是怎么认证的&lt;/h3&gt;
&lt;p&gt;先来一段大家很熟悉的代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;http.formLogin()
                    .loginPage(&quot;/auth/login&quot;)
                    .permitAll()
                    .failureHandler(loginFailureHandler)
                    .successHandler(loginSuccessHandler);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Spring Security 就像一个害羞的大姑娘，就这么一段鬼知道他是怎么认证的，封装的有点过哈。不着急先看一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/3/30/169cd1de055b3e18?w=675&amp;amp;h=707&amp;amp;f=png&amp;amp;s=40266&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里做了一个简化，&lt;/p&gt;
&lt;p&gt;根据JavaEE的流程，本质就是Filter过滤请求，转发到不同处理模块处理，最后经过业务逻辑处理，返回Response的过程。&lt;/p&gt;
&lt;p&gt;当请求匹配了我们定义的Security Filter的时候，就会导向Security 模块进行处理，例如UsernamePasswordAuthenticationFilter，源码献上:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {
    public static final String SPRING_SECURITY_FORM_USERNAME_KEY = &quot;username&quot;;
    public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = &quot;password&quot;;
    private String usernameParameter = &quot;username&quot;;
    private String passwordParameter = &quot;password&quot;;
    private boolean postOnly = true;

    public UsernamePasswordAuthenticationFilter() {
        super(new AntPathRequestMatcher(&quot;/login&quot;, &quot;POST&quot;));
    }

    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        if (this.postOnly &amp;amp;&amp;amp; !request.getMethod().equals(&quot;POST&quot;)) {
            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());
        } else {
            String username = this.obtainUsername(request);
            String password = this.obtainPassword(request);
            if (username == null) {
                username = &quot;&quot;;
            }

            if (password == null) {
                password = &quot;&quot;;
            }

            username = username.trim();
            UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password);
            this.setDetails(request, authRequest);
            return this.getAuthenticationManager().authenticate(authRequest);
        }
    }

    protected String obtainPassword(HttpServletRequest request) {
        return request.getParameter(this.passwordParameter);
    }

    protected String obtainUsername(HttpServletRequest request) {
        return request.getParameter(this.usernameParameter);
    }

    protected void setDetails(HttpServletRequest request, UsernamePasswordAuthenticationToken authRequest) {
        authRequest.setDetails(this.authenticationDetailsSource.buildDetails(request));
    }

    public void setUsernameParameter(String usernameParameter) {
        Assert.hasText(usernameParameter, &quot;Username parameter must not be empty or null&quot;);
        this.usernameParameter = usernameParameter;
    }

    public void setPasswordParameter(String passwordParameter) {
        Assert.hasText(passwordParameter, &quot;Password parameter must not be empty or null&quot;);
        this.passwordParameter = passwordParameter;
    }

    public void setPostOnly(boolean postOnly) {
        this.postOnly = postOnly;
    }

    public final String getUsernameParameter() {
        return this.usernameParameter;
    }

    public final String getPasswordParameter() {
        return this.passwordParameter;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有点复杂是吧，不用担心，我来做一些伪代码，让他看起来更友善，更好理解。注意我写的单行注释&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UsernamePasswordAuthenticationFilter extends AbstractAuthenticationProcessingFilter {
    public static final String SPRING_SECURITY_FORM_USERNAME_KEY = &quot;username&quot;;
    public static final String SPRING_SECURITY_FORM_PASSWORD_KEY = &quot;password&quot;;
    private String usernameParameter = &quot;username&quot;;
    private String passwordParameter = &quot;password&quot;;
    private boolean postOnly = true;

    public UsernamePasswordAuthenticationFilter() {
        //1.匹配URL和Method
        super(new AntPathRequestMatcher(&quot;/login&quot;, &quot;POST&quot;));
    }

    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {
        if (this.postOnly &amp;amp;&amp;amp; !request.getMethod().equals(&quot;POST&quot;)) {
            //啥？你没有用POST方法，给你一个异常，自己反思去
            throw new AuthenticationServiceException(&quot;Authentication method not supported: &quot; + request.getMethod());
        } else {
            //从请求中获取参数
            String username = this.obtainUsername(request);
            String password = this.obtainPassword(request);
            //我不知道用户名密码是不是对的，所以构造一个未认证的Token先
            UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(username, password);
            //顺便把请求和Token存起来
            this.setDetails(request, token);
            //Token给谁处理呢？当然是给当前的AuthenticationManager喽
            return this.getAuthenticationManager().authenticate(token);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是不是很清晰，问题又来了，Token是什么鬼？为啥还有已认证和未认证的区别？别着急，咱们顺藤摸瓜，来看看Token长啥样。上UsernamePasswordAuthenticationToken:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken {
    private static final long serialVersionUID = 510L;
    private final Object principal;
    private Object credentials;

    public UsernamePasswordAuthenticationToken(Object principal, Object credentials) {
        super((Collection)null);
        this.principal = principal;
        this.credentials = credentials;
        this.setAuthenticated(false);
    }

    public UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection&amp;lt;? extends GrantedAuthority&amp;gt; authorities) {
        super(authorities);
        this.principal = principal;
        this.credentials = credentials;
        super.setAuthenticated(true);
    }

    public Object getCredentials() {
        return this.credentials;
    }

    public Object getPrincipal() {
        return this.principal;
    }

    public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException {
        if (isAuthenticated) {
            throw new IllegalArgumentException(&quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;);
        } else {
            super.setAuthenticated(false);
        }
    }

    public void eraseCredentials() {
        super.eraseCredentials();
        this.credentials = null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一坨坨的真闹心，我再备注一下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class UsernamePasswordAuthenticationToken extends AbstractAuthenticationToken {
    private static final long serialVersionUID = 510L;
    //随便怎么理解吧，暂且理解为认证标识吧，没看到是一个Object么
    private final Object principal;
    //同上
    private Object credentials;

    //这个构造方法用来初始化一个没有认证的Token实例
    public UsernamePasswordAuthenticationToken(Object principal, Object credentials) {
        super((Collection)null);
        this.principal = principal;
        this.credentials = credentials;
        this.setAuthenticated(false);
    }
    //这个构造方法用来初始化一个已经认证的Token实例，为啥要多此一举，不能直接Set状态么，不着急，往后看
    public UsernamePasswordAuthenticationToken(Object principal, Object credentials, Collection&amp;lt;? extends GrantedAuthority&amp;gt; authorities) {
        super(authorities);
        this.principal = principal;
        this.credentials = credentials;
        super.setAuthenticated(true);
    }
    //便于理解无视他
    public Object getCredentials() {
        return this.credentials;
    }
    //便于理解无视他
    public Object getPrincipal() {
        return this.principal;
    }

    public void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException {
        if (isAuthenticated) {
            //如果是Set认证状态，就无情的给一个异常，意思是：
            //不要在这里设置已认证，不要在这里设置已认证，不要在这里设置已认证
            //应该从构造方法里创建，别忘了要带上用户信息和权限列表哦
            //原来如此，是避免犯错吧
            throw new IllegalArgumentException(&quot;Cannot set this token to trusted - use constructor which takes a GrantedAuthority list instead&quot;);
        } else {
            super.setAuthenticated(false);
        }
    }

    public void eraseCredentials() {
        super.eraseCredentials();
        this.credentials = null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;搞清楚了Token是什么鬼，其实只是一个载体而已啦。接下来进入核心环节，AuthenticationManager是怎么处理的。这里我简单的过渡一下，但是会让你明白。&lt;/p&gt;
&lt;p&gt;AuthenticationManager会注册多种AuthenticationProvider，例如UsernamePassword对应的DaoAuthenticationProvider，既然有多种选择，那怎么确定使用哪个Provider呢？我截取了一段源码，大家一看便知：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface AuthenticationProvider {
    Authentication authenticate(Authentication var1) throws AuthenticationException;

    boolean supports(Class&amp;lt;?&amp;gt; var1);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一个接口，我喜欢接口，简洁明了。里面有一个supports方法，返回时一个boolean值，参数是一个Class，没错，这里就是根据Token的类来确定用什么Provider来处理，大家还记得前面的那段代码吗？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; //Token给谁处理呢？当然是给当前的AuthenticationManager喽
 return this.getAuthenticationManager().authenticate(token);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此我们进入下一步，DaoAuthenticationProvider，继承了AbstractUserDetailsAuthenticationProvider，恭喜您再坚持一会就到曙光啦。这个比较复杂，为了不让你跑掉，我将两个复杂的类合并，摘取直接触达接口核心的逻辑，直接上代码，会有所删减，让你看得更清楚，注意看注释：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DaoAuthenticationProvider extends AbstractUserDetailsAuthenticationProvider {
    //熟悉的supports，需要UsernamePasswordAuthenticationToken
    public boolean supports(Class&amp;lt;?&amp;gt; authentication) {
            return UsernamePasswordAuthenticationToken.class.isAssignableFrom(authentication);
        }

    public Authentication authenticate(Authentication authentication) throws AuthenticationException {
            //取出Token里保存的值
            String username = authentication.getPrincipal() == null ? &quot;NONE_PROVIDED&quot; : authentication.getName();
            boolean cacheWasUsed = true;
            //从缓存取
            UserDetails user = this.userCache.getUserFromCache(username);
            if (user == null) {
                cacheWasUsed = false;

                //啥，没缓存？使用retrieveUser方法获取呀
                user = this.retrieveUser(username, (UsernamePasswordAuthenticationToken)authentication);
            }
            //...删减了一大部分，这样更简洁
            Object principalToReturn = user;
            if (this.forcePrincipalAsString) {
                principalToReturn = user.getUsername();
            }

            return this.createSuccessAuthentication(principalToReturn, authentication, user);
        }
         protected final UserDetails retrieveUser(String username, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
        try {
            //熟悉的loadUserByUsername
            UserDetails loadedUser = this.getUserDetailsService().loadUserByUsername(username);
            if (loadedUser == null) {
                throw new InternalAuthenticationServiceException(&quot;UserDetailsService returned null, which is an interface contract violation&quot;);
            } else {
                return loadedUser;
            }
        } catch (UsernameNotFoundException var4) {
            this.mitigateAgainstTimingAttack(authentication);
            throw var4;
        } catch (InternalAuthenticationServiceException var5) {
            throw var5;
        } catch (Exception var6) {
            throw new InternalAuthenticationServiceException(var6.getMessage(), var6);
        }
    }
    //检验密码
    protected void additionalAuthenticationChecks(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication) throws AuthenticationException {
        if (authentication.getCredentials() == null) {
            this.logger.debug(&quot;Authentication failed: no credentials provided&quot;);
            throw new BadCredentialsException(this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;));
        } else {
            String presentedPassword = authentication.getCredentials().toString();
            if (!this.passwordEncoder.matches(presentedPassword, userDetails.getPassword())) {
                this.logger.debug(&quot;Authentication failed: password does not match stored value&quot;);
                throw new BadCredentialsException(this.messages.getMessage(&quot;AbstractUserDetailsAuthenticationProvider.badCredentials&quot;, &quot;Bad credentials&quot;));
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到此为止，就完成了用户名密码的认证校验逻辑，根据认证用户的信息，系统做相应的Session持久化和Cookie回写操作。&lt;/p&gt;
&lt;p&gt;Spring Security的基本认证流程先写到这里，其实复杂的背后是一些预定，熟悉了之后就不难了。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Filter-&amp;gt;构造Token-&amp;gt;AuthenticationManager-&amp;gt;转给Provider处理-&amp;gt;认证处理成功后续操作或者不通过抛异常&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了这些基础，后面我们再来扩展短信验证码登录，以及基于Oauth 2.0 的短信验证码登录。&lt;/p&gt;
</description>
<pubDate>Sat, 30 Mar 2019 05:45:00 +0000</pubDate>
<dc:creator>曾俊杰的专栏</dc:creator>
<og:description>最简单易懂的Spring Security 身份认证流程讲解 导言 相信大伙对Spring Security这个框架又爱又恨，爱它的强大，恨它的繁琐，其实这是一个误区，Spring Security确</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ymstars/p/10626786.html</dc:identifier>
</item>
<item>
<title>Java 集合系列（三）—— LinkedList - 那一叶随风</title>
<link>http://www.cnblogs.com/phpstudy2015-6/p/10626564.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/phpstudy2015-6/p/10626564.html</guid>
<description>&lt;p&gt;以脑图的形式来展示Java集合知识，让零碎知识点形成体系&lt;/p&gt;
&lt;h4&gt;LinkedList&lt;/h4&gt;
&lt;p&gt;   LinkedList是一种可以在任何位置进行高效地插入和删除操作的有序序列。&lt;br/&gt;   它的最基本存储结构是一个节点：每个节点将存储对象，以及前后节点的引用。&lt;/p&gt;
&lt;h4&gt;结构图&lt;/h4&gt;
&lt;div class=&quot;image-package&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;898&quot; data-height=&quot;552&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16970596-65fe53f1349f0317.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/898/format/webp&quot; alt=&quot;&quot; width=&quot;730&quot; height=&quot;449&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16970596-65fe53f1349f0317.jpg&quot; data-original-width=&quot;898&quot; data-original-height=&quot;552&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;83807&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;LinkedList 结构体&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;   从上面的结构图中，我们可以了解到 ListedList 底层是基于双向链表实现的。&lt;br/&gt;   围起来的可以看成 LinkedList 类，它定义了三个 transient 成员变量：first、last、size。这三个变量是整个 LinkedList 类的关键点。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;由于是双向链表（每个node都有保存前后节点的引用），因此我们不管是由 first 还是 last 节点开始迭代，都可以将整个链表的数据找出来；&lt;/li&gt;
&lt;li&gt;在查询、随机插入以及set等操作都有涉及 size 判断；&lt;/li&gt;
&lt;li&gt;由于 LinkedList 是双向链表，类中只存储了首尾两个节点，因此查询第n个元素都要从头遍历进行查找。&lt;/li&gt;
&lt;/ol&gt;&lt;h4&gt;源码分析&lt;/h4&gt;
&lt;h4&gt;　　add(E e)  源码分析&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Appends the specified element to the end of this list.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * &amp;lt;p&amp;gt;This method is equivalent to {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; #addLast}.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; e element to be appended to this list
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt; {&lt;/span&gt;&lt;span&gt;@code&lt;/span&gt;&lt;span&gt; true} (as specified by {&lt;/span&gt;&lt;span&gt;@link&lt;/span&gt;&lt;span&gt; Collection#add})
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; add(E e) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        linkLast(e);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * Links e as last element.
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; linkLast(E e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; l = last;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将当前最后一个元素寄存在 l&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; Node&amp;lt;E&amp;gt; newNode = &lt;span&gt;new&lt;/span&gt; Node&amp;lt;&amp;gt;(l, e, &lt;span&gt;null&lt;/span&gt;);     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; new 一个新节点：pre的引用为l；存储元素为e；next的引用为null&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         last = newNode;                                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将新节点引用覆盖成员变量 last&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (l == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)                                      
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             first = newNode;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 若l为null，说明之前链表为空，此时新节点为首个元素&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;             l.next = newNode;                               &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 否则，更新l的next引用&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         size++;                                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; size+1&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         modCount++;                                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 非查询操作 modCount 都会 +1&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;　　add(int index, E element) 方法分析&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;     * Inserts the specified element at the specified position in this list.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;     * Shifts the element currently at that position (if any) and any
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;     * subsequent elements to the right (adds one to their indices).
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;     *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; index index at which the specified element is to be inserted
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; element element to be inserted
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException {&lt;/span&gt;&lt;span&gt;@inheritDoc&lt;/span&gt;&lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; add(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index, E element) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         checkPositionIndex(index);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查 index 是否大于 size&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (index ==&lt;span&gt; size)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             linkLast(element);      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接在链表末尾追加&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             linkBefore(element, node(index));   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 插入index 节点前面&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     
&lt;span&gt;19&lt;/span&gt;     
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查 index 是否超出范围 超出则抛出 IndexOutOfBoundsException&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; checkPositionIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;isPositionIndex(index))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IndexOutOfBoundsException(outOfBoundsMsg(index));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;     * Tells if the argument is the index of a valid position for an
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * iterator or an add operation.
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; isPositionIndex(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; index &amp;gt;= 0 &amp;amp;&amp;amp; index &amp;lt;=&lt;span&gt; size;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     
&lt;span&gt;34&lt;/span&gt;     
&lt;span&gt;35&lt;/span&gt;     
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;     * 根据 index 查找 node
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;     * 该方法利用了双向链表的特性，index 距离哪个链表头近就从哪边开始开始遍历
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;     * 时间复杂度为 O(n/2)；
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;     * 当 index 接近 size 的中间值时，效率最低
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;     * Returns the (non-null) Node at the specified element index.
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     Node&amp;lt;E&amp;gt; node(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; index) {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; assert isElementIndex(index);&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (index &amp;lt; (size &amp;gt;&amp;gt; 1)) {          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; size 右移一位（除以2）&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;             Node&amp;lt;E&amp;gt; x =&lt;span&gt; first;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; index; i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 x =&lt;span&gt; x.next;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             Node&amp;lt;E&amp;gt; x =&lt;span&gt; last;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = size - 1; i &amp;gt; index; i--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 x =&lt;span&gt; x.prev;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;&lt;strong&gt;优缺点&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增删元素效率高（只需要更新节点附近的引用即可）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;由于查询需要进行遍历，因此效率低&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt; &lt;/h3&gt;
&lt;h4&gt;知识脑图&lt;/h4&gt;
&lt;p&gt;From &lt;a href=&quot;https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsuifeng412%2FJCKTree&quot; target=&quot;_blank&quot;&gt;Java Core Knowledge Tree&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;image-package&quot; readability=&quot;7.9454545454545&quot;&gt;
&lt;div class=&quot;image-container&quot;&gt;

&lt;div class=&quot;image-view&quot; data-width=&quot;1277&quot; data-height=&quot;451&quot;&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16970596-d363cef841888daf.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp&quot; alt=&quot;&quot; data-original-src=&quot;//upload-images.jianshu.io/upload_images/16970596-d363cef841888daf.jpg&quot; data-original-width=&quot;1277&quot; data-original-height=&quot;451&quot; data-original-format=&quot;image/jpeg&quot; data-original-filesize=&quot;113596&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;LinkedList 脑图&lt;/strong&gt;&lt;/p&gt;


&lt;/div&gt;
</description>
<pubDate>Sat, 30 Mar 2019 05:20:00 +0000</pubDate>
<dc:creator>那一叶随风</dc:creator>
<og:description>以脑图的形式来展示Java集合知识，让零碎知识点形成体系 LinkedList LinkedList是一种可以在任何位置进行高效地插入和删除操作的有序序列。 它的最基本存储结构是一个节点：每个节点将存</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/phpstudy2015-6/p/10626564.html</dc:identifier>
</item>
<item>
<title>[Python Debug]Kernel Crash While Running Neural Network with Keras|Jupyter Notebook运行Keras服务器宕机原因及解决方法 - Sherrrry</title>
<link>http://www.cnblogs.com/sherrydatascience/p/10626474.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sherrydatascience/p/10626474.html</guid>
<description>&lt;p&gt;最近做Machine Learning作业，要在Jupyter Notebook上用Keras搭建Neural Network。结果连最简单的一层神经网络都运行不了，更奇怪的是我先用iris数据集跑了一遍并没有任何问题，但是用老师给的fashion mnist一运行服务器就提示挂掉重启。更更奇怪的是同样的code在同学的电脑上跑也是一点问题都没有，让我一度以为是我的macbook年代久远配置太低什么的，差点要买新电脑了&amp;gt;_&amp;lt;&lt;/p&gt;
&lt;p&gt;今天上课经ML老师几番调试，竟然完美解决了，不愧是CMU大神！（这里给Prof强烈打call，虽然他看不懂中文&amp;gt;&amp;lt;）因为刚学python没多久，还很不熟悉，经过这次又学会好多新技能✌️&lt;/p&gt;
&lt;p&gt;出问题的完整code如下，就是用Keras实现logistic regression，是一个简单的一层网络，但是每次运行到最后一行server就挂掉，然后重启kernel。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
%&lt;span&gt;matplotlib inline
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.decomposition &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PCA, FastICA
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.linear_model &lt;span&gt;import&lt;/span&gt;&lt;span&gt; LogisticRegression
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.models &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Sequential
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.layers &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Dense, Activation, Conv2D
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.utils &lt;span&gt;import&lt;/span&gt;&lt;span&gt; to_categorical
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; keras.datasets &lt;span&gt;import&lt;/span&gt;&lt;span&gt; fashion_mnist

(x3_train, y_train), (x3_test, y_test) &lt;/span&gt;=&lt;span&gt; fashion_mnist.load_data()
n_classes &lt;/span&gt;= np.max(y_train) + 1

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Vectorize image arrays, since most methods expect this format&lt;/span&gt;
x_train = x3_train.reshape(x3_train.shape[0], np.prod(x3_train.shape[1&lt;span&gt;:]))
x_test &lt;/span&gt;= x3_test.reshape(x3_test.shape[0], np.prod(x3_test.shape[1&lt;span&gt;:]))

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; Binary vector representation of targets (for one-hot or multinomial output networks)&lt;/span&gt;
y3_train =&lt;span&gt; to_categorical(y_train)
y3_test &lt;/span&gt;=&lt;span&gt; to_categorical(y_test)

&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn &lt;span&gt;import&lt;/span&gt;&lt;span&gt; preprocessing
scaler &lt;/span&gt;=&lt;span&gt; preprocessing.StandardScaler()
x_train_scaled &lt;/span&gt;=&lt;span&gt; scaler.fit_transform(x_train)     
x_test_scaled &lt;/span&gt;=&lt;span&gt; scaler.fit_transform(x_test) 

n_output &lt;/span&gt;= y3_train.shape[1&lt;span&gt;]
n_input &lt;/span&gt;= x_train_scaled.shape[1&lt;span&gt;]

nn_lr &lt;/span&gt;=&lt;span&gt; Sequential() 
nn_lr.add(Dense(units&lt;/span&gt;=n_output, input_dim= n_input, activation = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
nn_lr.compile(optimizer &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;sgd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, loss = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;categorical_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, metrics = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;accuracy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于Jupyter Notebook只是一直重启kernel，并没有任何错误提示，所以让人无从下手。但是经老师提示原来启动Jupyter Notebook时自动打开的terminal上会记录运行的信息（小白第一次发现。。），包括了kerter中止及重启的详细过程及原因：&lt;/p&gt;
&lt;blockquote readability=&quot;34&quot;&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;[I 22:11:54.603 NotebookApp] &lt;span class=&quot;s2&quot;&gt;Kernel interrupted: 7e7f6646-97b0-4ec7-951c-1dce783f60c4&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;[I 22:13:49.160 NotebookApp] &lt;span class=&quot;s2&quot;&gt;Saving file at /Documents/[Rutgers]Study/2019Spring/MACHINE LEARNING W APPLCTN LARGE DATASET/hw/Untitled1.ipynb&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s2&quot;&gt;2019-03-28 22:13:49.829246: I tensorflow/core/platform/cpu_feature_guard.cc:141] Your CPU supports instructions that this TensorFlow binary was not compiled to use: SSE4.1 SSE4.2 AVX AVX2 FMA&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s2&quot;&gt;2019-03-28 22:13:49.829534: I tensorflow/core/common_runtime/process_util.cc:69] Creating new thread pool with default inter op setting: 4. Tune using inter_op_parallelism_threads for best performance.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s2&quot;&gt;OMP: Error #15: Initializing libiomp5.dylib, but found libiomp5.dylib already initialized.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s2&quot;&gt;OMP: Hint: This means that multiple copies of the OpenMP runtime have been linked into the program. That is dangerous, since it can degrade performance or cause incorrect results. The best thing to do is to ensure that only a single OpenMP runtime is linked into the process, e.g. by avoiding static linking of the OpenMP runtime in any library. As an unsafe, unsupported, undocumented workaround you can set the environment variable KMP_DUPLICATE_LIB_OK=TRUE to allow the program to continue to execute, but that may cause crashes or silently produce incorrect results. For more information, please see http://www.intel.com/software/products/support/.&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;[I 22:13:51.049 NotebookApp] &lt;span class=&quot;s2&quot;&gt;KernelRestarter: restarting kernel (1/5), keep random ports&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s2&quot;&gt;kernel c1114f5a-3829-432f-a26a-c2db6c330352 restarted&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;还有另外一个方法，把代码copy到ipython中，也可以得到类似的信息，所以最后定位的错误是：&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s2&quot;&gt;OMP: Error #15: Initializing libiomp5.dylib, but found libiomp5.dylib already initialized.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s2&quot;&gt;谷歌了一下，github上有一个很详细的&lt;a href=&quot;https://github.com/dmlc/xgboost/issues/1715&quot; target=&quot;_blank&quot;&gt;讨论帖&lt;/a&gt;，但是楼主是运行XGBoost时遇到了这个问题，让我联想到寒假安装XGBoost确实经过了很曲折的过程，可能不小心把某个文件重复下载到了不同路径，于是程序加载package时出现了冲突。帖子里提供了几种可能的原因及解决方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;s2&quot;&gt;1. 卸载clang-omp&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.7577639751553&quot;&gt;
&lt;p&gt;&lt;span&gt;brew uninstall libiomp clang-omp&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;as long as u got gcc v5 from brew it come with openmp&lt;/p&gt;
&lt;p&gt;follow steps in:&lt;br/&gt;&lt;a href=&quot;https://github.com/dmlc/xgboost/tree/master/python-package&quot;&gt;https://github.com/dmlc/xgboost/tree/master/python-package&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;尝试了卸载xgboost再安装，然后卸载clang-omp，得到错误提示&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;No such keg: /usr/local/Cellar/libiomp&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;pip uninstall xbgoost
pip install xgboost
brew uninstall libiomp clang&lt;/span&gt;-omp
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;2. 直接在jupyter notebook里运行：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; DANGER! DANGER!&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
os.environ[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;KMP_DUPLICATE_LIB_OK&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;True&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;老师说这行命令可以让系统忽略package冲突的问题，自行选择一个package使用。试了一下这个方法确实有效，但&lt;span&gt;这是非常危险的做法，极度不推荐&lt;/span&gt;！&lt;/p&gt;

&lt;p&gt;3. 找到重复的libiomp5.dylib文件，删除其中一个&lt;/p&gt;
&lt;p&gt;在Finder中确实找到了两个文件，分别在~/⁨anaconda3⁩/lib⁩和~/anaconda3⁩/⁨lib⁩/⁨python3.6⁩/⁨site-packages⁩/⁨_solib_darwin⁩/⁨_U@mkl_Udarwin_S_S_Cmkl_Ulibs_Udarwin___Uexternal_Smkl_Udarwin_Slib⁩ （？？？？）可是不太确定应该删除哪一个，感觉这种做法也蛮危险的，删错了整个跑不起来了。&lt;/p&gt;

&lt;p&gt;4. OpenMP冲突&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Hint: This means that multiple copies of the OpenMP runtime have been linked into the program &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据提示信息里的Hint，搜了下TensorFlow OpenMP。OpenMP是一个多线程并行编程的平台，TensorFlow似乎有自己的并行计算架构，并用不上OpenMP（see &lt;a href=&quot;https://github.com/tensorflow/tensorflow/issues/12434&quot;&gt;https://github.com/tensorflow/tensorflow/issues/12434&lt;/a&gt;）&lt;/p&gt;

&lt;p&gt;5. 卸载nomkl&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;I had the same error on my Mac with a python program using numpy, keras, and matplotlib. I solved it with 'conda install nomkl'.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是最后有效的做法！nomkl全称是Math Kernel Library (MKL) Optimization，是Interl开发的用来加速数学运算的模块，通过conda安装package可以自动使用mkl，更详细的信息可以看这个&lt;a href=&quot;https://docs.anaconda.com/mkl-optimizations/&quot; target=&quot;_blank&quot;&gt;Anaconda的官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;To opt out, run &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;conda &lt;span class=&quot;pre&quot;&gt;install &lt;span class=&quot;pre&quot;&gt;nomkl&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; and then use &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;conda &lt;span class=&quot;pre&quot;&gt;install&lt;/span&gt;&lt;/span&gt;&lt;/code&gt; to install packages that would normally include MKL or depend on packages that include MKL, such as &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;scipy&lt;/span&gt;&lt;/code&gt;, &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;numpy&lt;/span&gt;&lt;/code&gt;, and &lt;code class=&quot;docutils literal notranslate&quot;&gt;&lt;span class=&quot;pre&quot;&gt;pandas&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可能是numpy之类的package更新时出现了一些冲突，安装nomkl之后竟然神奇地解决了，后来又尝试把MKL卸载了，程序依然正常运行。。卸载命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
conda remove mkl mkl-service
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;1. 老师好厉害呀，三下五除二就把问题解决了&amp;gt;&amp;lt;&lt;/p&gt;
&lt;p&gt;2. 经大神提醒，运行python之前创建一个虚拟环境可以很好避免package冲突之类的问题，具体方法：&lt;a href=&quot;https://www.jianshu.com/p/d8e7135dca40&quot;&gt;https://www.jianshu.com/p/d8e7135dca40&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Sat, 30 Mar 2019 04:31:00 +0000</pubDate>
<dc:creator>Sherrrry</dc:creator>
<og:description>最近做Machine Learning作业，要在Jupyter Notebook上用Keras搭建Neural Network。结果连最简单的一层神经网络都运行不了，更奇怪的是我先用iris数据集跑了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sherrydatascience/p/10626474.html</dc:identifier>
</item>
<item>
<title>构建现代Web应用时究竟是选择传统web应用还是SPA - 依乐祝</title>
<link>http://www.cnblogs.com/yilezhu/p/10626459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yilezhu/p/10626459.html</guid>
<description>&lt;p&gt;在大前端盛行的今天，似乎前后端分离的开发模式才是大势所趋，而SPA的概念更是应运而生。现在随便构建一个web应用程序如果你不是使用SPA的话，就会感觉有点low，但是真的是这样吗？今天这篇文章我们就来一起探讨下，构建现代web应用时该如何进行选择。&lt;/p&gt;
&lt;p&gt;目前大伙都知道的是可通过两种通用方法来构建 Web 应用程序：在服务器上执行大部分应用程序逻辑的传统 Web 应用程序，以及在 Web 浏览器中执行大部分用户界面逻辑的单页应用程序 (SPA)，后者主要使用 Web API 与 Web 服务器通信。 也可以将两种方法混合使用，最简单的方法是在更大型的传统 Web 应用程序中承载一个或多个丰富 SPA 类子应用程序。&lt;br/&gt;但合适使用传统 Web 应用程序，何时使用SPA呢？针对这个问题最近在看微软《使用 ASP.NET Core 和 Azure 构建新式 Web 应用程序》白皮书的时候。里面如是说：&lt;/p&gt;
&lt;p&gt;何时应使用传统 Web 应用程序：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用程序的客户端要求简单，甚至要求只读。&lt;/li&gt;
&lt;li&gt;应用程序需在不支持 JavaScript 的浏览器中工作。&lt;/li&gt;
&lt;li&gt;团队不熟悉 JavaScript 或 TypeScript 开发技术。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;何时应使用 SPA：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;应用程序必须公开具有许多功能的丰富的用户界面。&lt;/li&gt;
&lt;li&gt;团队熟悉 JavaScript 或 TypeScript 开发。&lt;/li&gt;
&lt;li&gt;应用程序已为其他（内部或公共）客户端公开 API。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外，SPA 框架还需要更强的体系结构和安全专业知识。 相较于传统 Web 应用程序，SPA 框架需要进行频繁的更新和使用新框架，因此改动更大。 相较于传统 Web 应用，SPA 应用程序在配置自动化生成和部署过程以及利用部署选项（如容器）方面的难度更大。&lt;/p&gt;
&lt;p&gt;所以如果你要使用 SPA 模型改进用户体验时必须权衡这些注意事项。&lt;/p&gt;
&lt;h2 id=&quot;razor-组件&quot;&gt;Razor 组件&lt;/h2&gt;
&lt;p&gt;ASP.NET Core 3.0 引入了一种新模型，用于构建称为 Razor 组件的丰富的、交互式和可组合的 UI。 Razor 组件允许开发者在服务器上使用 Razor 构建 UI，并使用名为 WebAssembly 的 JavaScript 库将此代码传递到浏览器和执行客户端。 ASP.NET Core 3.0 仍在开发中，但你应该会期望在本电子书的 3.0 更新中看到有关此技术的详细信息。 有关 Razor 组件（名为 Blazor 的代码）的详细信息，请参阅 &lt;a href=&quot;https://blazor.net/docs/get-started.html&quot;&gt;Blazor 入门&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;何时选择传统-web-应用&quot;&gt;何时选择传统 Web 应用&lt;/h2&gt;
&lt;p&gt;以下内容详细介绍前面提到的选择传统 Web 应用程序的原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用程序的客户端要求简单，可能要求只读&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对许多 Web 应用程序而言，其大部分用户的主要使用方式是只读。 只读（或以读取为主）应用程序往往比那些维护和操作大量状态的应用程序简单得多。 例如，搜索引擎可能由一个带有文本框的入口点和用于显示搜索结果的第二页组成。 匿名用户可以轻松提出请求，并且很少需要使用客户端逻辑。 同样，一般而言，博客或内容管理系统中面向公众的应用程序主要包含的内容与客户端行为关系不大。 此类应用程序容易构建为基于服务器的传统 Web 应用程序，在 Web 服务器上执行逻辑，并呈现要在浏览器中显示的 HTML。事实上，网站的每个独特页面都有自己的 URL，搜索引擎可以将其存为书签和编入索引（默认设置，无需将其添加为应用程序的单独功能），这也是此类情况的一个明显优势。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用程序需在不支持 JavaScript 的浏览器中工作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如需在有限或不支持 JavaScript 的浏览器中工作的 Web 应用程序，则应使用传统的 Web 应用工作流编写（或至少可以回退到此类行为）。 SPA 需要客户端 JavaScript 才能正常工作；如果没有客户端 JavaScript，SPA 不是好的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;团队不熟悉 JavaScript 或 TypeScript 开发技术&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果团队不熟悉 JavaScript 或 TypeScript，但熟悉服务器端 Web 应用程序开发，那相较于 SPA，他们交付传统 Web 应用的速度可能更快。 除非以学习 SPA 编程为目的，或需要 SPA 提供用户体验，否则对已经熟悉构建传统 Web 应用的团队而言，选择传统 Web 应用的工作效率更高。&lt;/p&gt;
&lt;h2 id=&quot;何时选择-spa&quot;&gt;何时选择 SPA&lt;/h2&gt;
&lt;p&gt;以下内容详细介绍何时为 Web 应用选择单页应用程序开发样式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应用程序必须公开具有许多功能的丰富用户界面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SPA 可支持丰富客户端功能，当用户执行操作或在应用的各区域间导航时无需重新加载页面。 SPA 很少需要重新加载整个页面，因此加载速度更快，可在后台提取数据，并且对单个用户操作的响应更快。 SPA 支持增量更新，可保存尚未完成的窗体或文档，而无需用户单击按钮提交窗体。 SPA 支持丰富的客户端行为，例如拖放，比传统应用程序更容易操作。 可以将 SPA 设计为在断开连接的模式下运行，对客户端模型进行更新，并在重新建立连接后将更新最终同步回服务器。 如果应用要求包括丰富的功能，且超出了典型 HTML 窗体提供的功能，则应选择 SPA 样式应用程序。&lt;/p&gt;
&lt;p&gt;请注意，SPA 通常需要实现内置于传统 Web 应用中的功能，例如在反映当前操作的地址栏中显示有意义的 URL（并允许用户将此 URL 存为书签或对其进行深层链接以便返回此 URL）。 SPA 还应允许用户使用浏览器的后退和前进按钮寻找用户意料之中的结果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;团队熟悉 JavaScript 和/或 TypeScript 开发&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;编写 SPA 需要熟悉 JavaScript 和/或 TypeScript 以及客户端编程技术和库。 团队应有能力像使用 Angular 一样使用 SPA 框架编写新式 JavaScript。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h3 id=&quot;参考---spa-框架&quot;&gt;参考 - SPA 框架&lt;/h3&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;应用程序已为其他（内部或公共）客户端公开 API&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果已提供一个 Web API 供其他客户端使用，则相较于在服务器端窗体中复制逻辑，创建一个利用这些 API 的 SPA 实现更加容易。用户与应用程序交互时，SPA 广泛使用 Web API 来查询和更新数据。&lt;/p&gt;
&lt;h2 id=&quot;决策表---选传统-web-或-spa&quot;&gt;决策表 - 选传统 Web 或 SPA&lt;/h2&gt;
&lt;p&gt;下面的决策表总结了在传统 Web 应用程序和 SPA 之间进行选择时要考虑的一些基本因素。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;需要团队熟悉 JavaScript/TypeScript&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;最低&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;必需&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;支持不带脚本的浏览器&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;支持&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不支持&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;客户端应用程序行为极少&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;适合&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;不必要&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;丰富而复杂的用户界面要求&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;受限&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;适合&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天给大家介绍了在构建现代Web应用时究竟是选择传统web应用还是spa的一些参考，希望对大家在进行现代web开发时技术选型时有所帮助。如果你有不同的看法可以在下面留言。&lt;/p&gt;
</description>
<pubDate>Sat, 30 Mar 2019 04:22:00 +0000</pubDate>
<dc:creator>依乐祝</dc:creator>
<og:description>在大前端盛行的今天，似乎前后端分离的开发模式才是大势所趋，而SPA的概念更是应运而生。现在随便构建一个web应用程序如果你不是使用SPA的话，就会感觉有点low，但是真的是这样吗？今天这篇文章我们就来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yilezhu/p/10626459.html</dc:identifier>
</item>
<item>
<title>zabbix server优化与迁移 - 过去的我</title>
<link>http://www.cnblogs.com/gqdw/p/10625534.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gqdw/p/10625534.html</guid>
<description>&lt;h3 id=&quot;zabbix-server优化与迁移&quot;&gt;zabbix server优化与迁移&lt;/h3&gt;
&lt;h4 id=&quot;概述&quot;&gt;1. 概述&lt;/h4&gt;
&lt;p&gt;zabbix 系统其实分3个大部分，一个是server本身，另一个是php的httpd服务，第三个是非常需要优化的数据库。公司的zabbix监控主机在3000不到的体量，不优化真的不行。主要说说mysql，其他几个略了，结合zabbix自身的监控数据，参数该调大就调大。&lt;/p&gt;
&lt;h4 id=&quot;mysql-优化导表&quot;&gt;2. mysql 优化导表&lt;/h4&gt;
&lt;h5 id=&quot;tokudb引擎&quot;&gt;2.1 tokudb引擎&lt;/h5&gt;
&lt;p&gt;重点是这个数据库，设计原因，造成几个表过大。每次insert时间过长造成性能问题，我目前的实践发现tokudb引擎是很好的解决方案，有关tokudb的原理可看&lt;a href=&quot;https://www.percona.com/software/mysql-database/percona-tokudb&quot; class=&quot;uri&quot;&gt;https://www.percona.com/software/mysql-database/percona-tokudb&lt;/a&gt; 。mysql官方的包是不支持tokudb引擎的，可以下载percona的包，或者是alisql的。我的选择是percona 源码包编译，percona其实是提供rpm安装方式的，但是好像网络有问题总会下载不下来。&lt;/p&gt;
&lt;p&gt;有关mysql安装可以参考我之前的文章 &lt;a href=&quot;https://gqdw.github.io/2017/01/17/mysql-5-7-install/&quot; class=&quot;uri&quot;&gt;https://gqdw.github.io/2017/01/17/mysql-5-7-install/&lt;/a&gt; ,有些不同之处在于percona的包没有带boost ，我是从官网mysql源码包上下载了以后拷过去的，可以用。&lt;br/&gt;先要在系统里设置2个内核参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/enabled
echo never &amp;gt; /sys/kernel/mm/transparent_hugepage/defrag&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后要在mysql中激活一下tokudb引擎,&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;INSTALL PLUGIN tokudb SONAME 'ha_tokudb.so';
INSTALL PLUGIN tokudb_file_map SONAME 'ha_tokudb.so';
INSTALL PLUGIN tokudb_fractal_tree_info SONAME 'ha_tokudb.so';
INSTALL PLUGIN tokudb_fractal_tree_block_map SONAME 'ha_tokudb.so';
INSTALL PLUGIN tokudb_trx SONAME 'ha_tokudb.so';
INSTALL PLUGIN tokudb_locks SONAME 'ha_tokudb.so';
INSTALL PLUGIN tokudb_lock_waits SONAME 'ha_tokudb.so';
INSTALL PLUGIN tokudb_background_job_status SONAME 'ha_tokudb.so';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完了SHOW ENGINES 一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;+--------------------+---------+----------------------------------------------------------------------------+--------------+------+------------+
| Engine             | Support | Comment                                                                    | Transactions | XA   | Savepoints |
+--------------------+---------+----------------------------------------------------------------------------+--------------+------+------------+
| MyISAM             | YES     | MyISAM storage engine                                                      | NO           | NO   | NO         |
| MRG_MYISAM         | YES     | Collection of identical MyISAM tables                                      | NO           | NO   | NO         |
| CSV                | YES     | CSV storage engine                                                         | NO           | NO   | NO         |
| BLACKHOLE          | YES     | /dev/null storage engine (anything you write to it disappears)             | NO           | NO   | NO         |
| InnoDB             | DEFAULT | Percona-XtraDB, Supports transactions, row-level locking, and foreign keys | YES          | YES  | YES        |
| TokuDB             | YES     | Percona TokuDB Storage Engine with Fractal Tree(tm) Technology             | YES          | YES  | YES        |
| PERFORMANCE_SCHEMA | YES     | Performance Schema                                                         | NO           | NO   | NO         |
| ARCHIVE            | YES     | Archive storage engine                                                     | NO           | NO   | NO         |
| MEMORY             | YES     | Hash based, stored in memory, useful for temporary tables                  | NO           | NO   | NO         |
| FEDERATED          | NO      | Federated MySQL storage engine                                             | NULL         | NULL | NULL       |
+--------------------+---------+----------------------------------------------------------------------------+--------------+------+------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到tokudb完美的支持Transactions , XA ,Savepoints ，可以放心使用。早些年其实tokudb还是有明显bug的，用用会崩溃，但是2019年这些不存在了，感谢开源老哥的无私奉献。&lt;br/&gt;另外说一下，硬件需要选择ssd，普通的盘io真的跟不上。&lt;/p&gt;
&lt;h5 id=&quot;导数据&quot;&gt;2.2 导数据&lt;/h5&gt;
&lt;p&gt;之后是导数据，我的做法是跳过几个大表，把小库导入，之后在导2个大表。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;trends&lt;/li&gt;
&lt;li&gt;trends_uint&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;history的几个表不用导，但是表结构需要建好，而且这几个表一定要做表分区，不然管理的时候会有些麻烦。&lt;br/&gt;导出表需要写几个小脚本，写个for,done ,so easy:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;day=0329
mkdir $day
for t in `cat tabs`
do
    echo &quot;mysqldump zabbix $t &amp;gt; $day/$t.sql&quot;
    mysqldump --set-gtid-purged=OFF zabbix $t &amp;gt; $day/$t.sql 
done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我这里加了--set-gtid-purged=OFF，不然会把gtid给带上。&lt;/p&gt;
&lt;p&gt;恢复的时候就是这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;for t in `cat tabs`
do
    echo &quot;mysql  zabbix &amp;lt;  0329/$t.sql&quot; 
    mysql -uzabbix -pzabbixpass zabbix &amp;lt;  0329/$t.sql
done&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mysqldump只导表结构的参数是-d 。&lt;/p&gt;
&lt;p&gt;导历史数据的时候也有个技巧，把dump出来的sql修改一下，去掉&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DROP TABLE IF EXISTS `trends`;
LOCK TABLES `trends` WRITE;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;去掉lock table可以在线导。总不能停服务导吧~&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;3. 总结&lt;/h4&gt;
&lt;p&gt;细节是魔鬼,mysql这块虽然是比oracle操作要简单不少，但是做起来还是一个熟练度问题，搞不好很多时候就要重头搞，可能数据也给搞没了，所以做的时候需要思路很清醒，很多细节问题需要注意。&lt;/p&gt;
</description>
<pubDate>Sat, 30 Mar 2019 02:27:00 +0000</pubDate>
<dc:creator>过去的我</dc:creator>
<og:description>zabbix server优化与迁移 1. 概述 zabbix 系统其实分3个大部分，一个是server本身，另一个是php的httpd服务，第三个是非常需要优化的数据库。公司的zabbix监控主机在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gqdw/p/10625534.html</dc:identifier>
</item>
<item>
<title>Akka-CQRS（4）- CQRS Writer Actor 示范 - 雪川大虫</title>
<link>http://www.cnblogs.com/tiger-xc/p/10622046.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-xc/p/10622046.html</guid>
<description>&lt;p&gt;&lt;span&gt;   我觉着，CQRS的写部分最核心、最复杂的部分应该是Writer-Actor了。其它的监管（supervising）、分片部署等都比较规范，没太多的变动。几乎Writer-Actor所有的业务逻辑都在Receive函数里，这个地方应该算是最复杂的地方。我的想法是搭建一个标准框架，保证可以运行Writer-Actor。然后因应业务需求变化在这个Receive函数里用一种标准写法加功能。这就要求Receive函数能够做到代码简洁、逻辑清晰。Receive函数是一个执行Command的地方。在执行之前需要对指令的可执行性进行判断，这样就可能在函数内部造成臃肿的重复代码。比如，大部分指令需要用户登陆后才容许执行、又或者很多指令都需要超级用户权限、又或者开始支付后不容许除支付之外的任何操作，等等。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，我们可以有一个前置操作，里面包括了大部分对指令可执行性判断逻辑，这样我们可以把许多重复代码从Receive函数中移走，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;helper functions&lt;/span&gt;
  &lt;span&gt;object&lt;/span&gt;&lt;span&gt; RunPOSCommand {
    def unapply(arg: POSCommand) &lt;/span&gt;= &lt;span&gt;if&lt;/span&gt; (cmdFilter(persistenceId,arg,vchState,vchItems,sender())) Some(arg) &lt;span&gt;else&lt;/span&gt;&lt;span&gt; None
  }

  def cmdFilter(terminalid: String, cmd: POSCommand, state: VchStates, txns: VchItems, router: ActorRef): Boolean &lt;/span&gt;=&lt;span&gt; cmd match {
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; LogOn(opr, passwd) =&amp;gt;      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;only allowed in logOffState&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (!txns.txnitems.isEmpty) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;in the middle of process&lt;/span&gt;
        router ! POSResponse(STATUS.FAIL, s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;禁止用户登陆！终端 ${terminalid} 有未完成单据。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, state, List())
        &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (validateUser(opr, passwd).isDefined) &lt;span&gt;true&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          router &lt;/span&gt;! POSResponse(STATUS.FAIL, s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;终端-$terminalid： 用户 ${opr} 登陆失败！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, state, List())
          &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        }
      }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; LogOff =&amp;gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;only allowed in logOnState&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (!txns.txnitems.isEmpty) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;in the middle of process&lt;/span&gt;
        router ! POSResponse(STATUS.FAIL, s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;禁止用户退出！终端 ${terminalid} 有未完成单据。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, state, List())
        &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;

    &lt;span&gt;case&lt;/span&gt; VoidAll =&amp;gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;allowed in logOnState and paymentState&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (txns.txnitems.isEmpty) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;no valid sales&lt;/span&gt;
        router ! POSResponse(STATUS.FAIL, s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;全单取消失败！终端 ${terminalid} 本单无任何有效销售记录。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, state, txns.txnitems)
        &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;

    &lt;span&gt;case&lt;/span&gt; OfflinePay(acct,num,amt) =&amp;gt;
      &lt;span&gt;if&lt;/span&gt; (txns.totalSales.abs == &lt;span&gt;0&lt;/span&gt;) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no valid sales. void,refund neg values could produce zero&lt;/span&gt;
        router ! POSResponse(STATUS.FAIL, s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;支付失败！终端 ${terminalid} 应付金额为零。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, state, List())
        &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(validateAcct(acct).isDefined) &lt;span&gt;true&lt;/span&gt;
        &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          router &lt;/span&gt;! POSResponse(STATUS.FAIL, s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;支付失败！终端 ${terminalid} 账号{$acct}不存在。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, state, List())
          &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
        }
      }
    &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; Subtotal =&amp;gt;
      &lt;span&gt;if&lt;/span&gt; (txns.txnitems.isEmpty) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;in the middle of process&lt;/span&gt;
        router ! POSResponse(STATUS.FAIL, s&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;小计操作失败！终端 ${terminalid} 无任何销售记录。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, state, List())
        &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
      } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt; VCBalance(_,_,_) =&amp;gt; &lt;span&gt;true&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt; MemberOn(_,_) =&amp;gt; &lt;span&gt;true&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt; MemberOff =&amp;gt; &lt;span&gt;true&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt; VoucherNum(_) =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
...
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上，前期的判断逻辑都移到cmdFilter(...)里了，然后可以用RunPOSCommand(command)方式来实现对command的执行性判断。现在我们可以在Receive函数里通过调用RunPOSCommand来节省一大截重复代码了，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt; private def logOffState: Receive = {
    case RunPOSCommand(LogOn(opr, _)) =&amp;gt;
          persistEvent(LogOned(opr,vchState)) { evt =&amp;gt;
            val sts = updateState(evt, vchState, vchItems)
//starting seqenceNr for any voucher. no action logged before login
            vchState = sts._1.copy(jseq = lastSequenceNr + 1);
            vchItems = sts._2
            sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 用户{$opr}成功登陆。&quot;, vchState, List(vchItems.txnitems.head))
            context.become(logOnState)
          }
    case PassivatePOS =&amp;gt;
      log.info(s&quot;**********${persistenceId} got passivate message and stopping  ... ***********&quot;)
      context.parent ! PoisonPill

    case _ =&amp;gt;
      sender() ! POSResponse(STATUS.FAIL, s&quot;操作失败！终端 ${persistenceId} 用户未登陆。&quot;, vchState, List())
  }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;另外，我把所有指令分成三个可执行类别，分别是：登陆前、已登陆、支付中。这三种状态的行为分别用logOffState,logOnState,paymentState三个Receive函数代表： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;99&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;  private def logOnState: Receive = {
    case RunPOSCommand(LogOff) =&amp;gt;
          persistEvent(LogOffed(vchState)) { evt =&amp;gt;
            val user = vchState.opr
            val sts = updateState(evt,vchState,vchItems)
            vchState = sts._1; vchItems = sts._2
            saveSnapshot(vchState)     //state of last voucher
          //手工passivate         shard ! ShardRegion.Passivate(PassivatePOS)
            sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 用户 $user 成功退出。&quot;, vchState, List(vchItems.txnitems.head))
            context.unbecome()    //switch to logOffState
          }

    case RunPOSCommand(SuperOn(su,_)) =&amp;gt;
      persistEvent(SuperOned(su,vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 转到管理模式{$su}。&quot;, vchState, List(vchItems.txnitems.head))
      }
  private def logOnState: Receive = {
    case RunPOSCommand(LogOff) =&amp;gt;
          persistEvent(LogOffed(vchState)) { evt =&amp;gt;
            val user = vchState.opr
            val sts = updateState(evt,vchState,vchItems)
            vchState = sts._1; vchItems = sts._2
            saveSnapshot(vchState)     //state of last voucher
          //手工passivate         shard ! ShardRegion.Passivate(PassivatePOS)
            sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 用户 $user 成功退出。&quot;, vchState, List(vchItems.txnitems.head))
            context.unbecome()    //switch to logOffState
          }

    case RunPOSCommand(SuperOn(su,_)) =&amp;gt;
      persistEvent(SuperOned(su,vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 转到管理模式{$su}。&quot;, vchState, List(vchItems.txnitems.head))
      }
  private def logOnState: Receive = {
    case RunPOSCommand(LogOff) =&amp;gt;
          persistEvent(LogOffed(vchState)) { evt =&amp;gt;
            val user = vchState.opr
            val sts = updateState(evt,vchState,vchItems)
            vchState = sts._1; vchItems = sts._2
            saveSnapshot(vchState)     //state of last voucher
          //手工passivate         shard ! ShardRegion.Passivate(PassivatePOS)
            sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 用户 $user 成功退出。&quot;, vchState, List(vchItems.txnitems.head))
            context.unbecome()    //switch to logOffState
          }

    case RunPOSCommand(SuperOn(su,_)) =&amp;gt;
      persistEvent(SuperOned(su,vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 转到管理模式{$su}。&quot;, vchState, List(vchItems.txnitems.head))
      }
    //first payment in a voucher
    case RunPOSCommand(OfflinePay(acct,num, amount)) =&amp;gt;
      persistEvent(Payment(acct,num,vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        if (vchItems.totalSales &amp;gt; 0)
          sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}支付。&quot;, vchState, List(vchItems.txnitems.head))
        else
          sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}退款。&quot;, vchState, List(vchItems.txnitems.head))
        if (!vchState.due) {  //completed voucher. mark end of voucher and move next. stay in logOnState
          persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
            val sts = updateState(evt, vchState, vchItems)
            vchState = sts._1
            vchItems = sts._2
            saveSnapshot(vchState)     //recovery to next voucher
          }
        }
        else context.become(paymentState)     //switch into paymentState
      }
...
}

 private def paymentState: Receive = {
    case RunPOSCommand(OfflinePay(acct,num, amount)) =&amp;gt;
           persistEvent(Payment(acct,num,vchState)) { evt =&amp;gt;
             val sts = updateState(evt, vchState, vchItems)
             vchState = sts._1
             vchItems = sts._2
             if (vchItems.totalSales &amp;gt; 0)
               sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}支付。&quot;, vchState, List(vchItems.txnitems.head))
             else
               sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}退款。&quot;, vchState, List(vchItems.txnitems.head))

             if (!vchState.due) {  //completed voucher. mark end of voucher and move next. return to logOnState
               persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
                 val sts = updateState(evt, vchState, vchItems)
                 vchState = sts._1
                 vchItems = sts._2
                 saveSnapshot(vchState)     //recovery to next voucher
                 context.unbecome()    //logOnState
               }
             }
             // else wait for other payments and stay in logOnState
           }
...
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;注意上面代码里的context.become,saveSnapshot, 它们分别代表状态转换及一单的终结。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实现写端时不得不考虑读端Reader-Actor的一些实现方式：这是个收银机软件，以一张销售单为单元，单中有多条交易记录（在例子里是多条收银动作记录），后面的操作记录可能会影响前面记录的状态，如：后面的冲销前面的、后面输入一条折扣指令等，不过单与单之间没有任何瓜葛。前面提到过：我们不想在写端来处理任何业务逻辑，所以对每单中项目状态处理就移到了读端。具体做法是这样的：写端完成一单操作后通知Reader-Actor,并把本单的开始sequenceNr和结束sequenceNr传给Reader-Actor, Reader用静态流方式读取事件，维护本单状态并对单内所有项目状态进行更新并恢复到规定的交易记录格式，最终把所有交易项目写到目标数据库表。假设有一个POSRouter负责派送指令给Writer-Actor，我们同样可以把完成写单据的信息传送给这个POSRouter, 然后由它分配调度Reader-Actor。POSRouter+Reader-Actor可以是cluster-loadbalance模式的。写端存入日志的数据包括每一个动作的类型和详细的数据，如SalesLogged(txnitem), SalesLogged是事件类型，txnItem是事件数据：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;54&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;  case class TxnItem(
                      txndate: String = LocalDate.now.format(DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;))
                      ,txntime: String = LocalDateTime.now.format(dateTimeFormatter).substring(11)
                      ,opr: String = &quot;&quot;//工号
                      ,num: Int = 0 //销售单号
                      ,seq: Int = 1 //交易序号
                      ,txntype: Int = TXNTYPE.sales//交易类型
                      ,salestype: Int = SALESTYPE.plu //销售类型
                      ,qty: Int =  1 //交易数量
                      ,price: Int = 0 //单价（分）
                      ,amount: Int = 0 //码洋（分）
                      ,dscamt: Int = 0 //折扣：负值  net实洋 = amount + dscamt
                      ,member: String = &quot;&quot; //会员卡号
                      ,code: String = &quot;&quot; //编号（商品、账号...）
                      ,desc: String = &quot;&quot; //项目名称
                      ,dpt: String = &quot;&quot;
                      ,department: String = &quot;&quot;
                      ,cat: String = &quot;&quot;
                      ,category: String = &quot;&quot;
                      ,brd: String = &quot;&quot;
                      ,brand: String = &quot;&quot;
                    )
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;首先，我们需要这个TxnItem使Read-Actor能把事件恢复成规定格式的交易记录。也可以用这个结构返回给前端用来显示或者打印交易明细。下面是这些Command和Event的定义代码：&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;87&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;object Commands {

  case object PassivatePOS    //passivate message
  case class DebugMode(debug: Boolean)

  sealed trait POSCommand {}

  case class LogOn(opr: String, passwd: String) extends POSCommand
  case object LogOff extends POSCommand
  case class SuperOn(su: String, passwd: String) extends POSCommand
  case object SuperOff extends POSCommand
  case class MemberOn(cardnum: String, passwd: String) extends POSCommand
  case object MemberOff extends POSCommand   //remove member status for the voucher
  case object RefundOn extends POSCommand
  case object RefundOff extends POSCommand
  case object VoidOn extends POSCommand
  case object VoidOff extends POSCommand
  case object VoidAll extends POSCommand
  case object Suspend extends POSCommand

  case class VoucherNum(vnum: Int) extends POSCommand


  case class LogSales(salesType: Int, dpt: String, code: String, qty: Int, price: Int) extends POSCommand
  case object Subtotal extends POSCommand
  case class Discount(code: String, percent: Int) extends POSCommand

  case class OfflinePay(acct: String, num: String, amount: Int) extends POSCommand          //settlement   结算支付
 //read only command, no event process
  case class VCBalance(acct: String, num: String, passwd: String) extends POSCommand
  case class VCPay(acct: String, num: String, passwd: String, amount: Int) extends POSCommand
  case class AliPay(acct: String, num: String, amount: Int) extends POSCommand
  case class WxPay(acct: String, num: String, amount: Int) extends POSCommand


  // read only command, no update event
  case class Plu(itemCode: String) extends POSCommand  //read only


}


object Events {

  sealed trait POSEvent {}

  case class LogOned(txnItem: TxnItem) extends POSEvent
  object LogOned {
    def apply(op: String, vs: VchStates): LogOned = LogOned(TxnItem(vs).copy(
      txntype = TXNTYPE.logon,
      salestype = SALESTYPE.crd,
      opr = op,
      code = op
    ))
  }
  case class LogOffed(txnItem: TxnItem) extends POSEvent
  object LogOffed {
    def apply(vs: VchStates): LogOffed = LogOffed(TxnItem(vs).copy(
      txntype = TXNTYPE.logon,
      salestype = SALESTYPE.crd,
    ))
  }
  case class SuperOned(txnItem: TxnItem) extends POSEvent
  object SuperOned {
    def apply(su: String, vs: VchStates): SuperOned = SuperOned(TxnItem(vs).copy(
      txntype = TXNTYPE.supon,
      salestype = SALESTYPE.crd,
      code = su
    ))
  }
  case class SuperOffed(txnItem: TxnItem) extends POSEvent
  object SuperOffed {
    def apply(vs: VchStates): SuperOffed = SuperOffed(TxnItem(vs).copy(
      txntype = TXNTYPE.supon,
      salestype = SALESTYPE.crd
    ))
  }
  case class MemberOned(txnItem: TxnItem) extends POSEvent
  object MemberOned {
    def apply(cardnum: String,vs: VchStates): MemberOned = MemberOned(TxnItem(vs).copy(
      txntype = TXNTYPE.sales,
      salestype = SALESTYPE.crd,
      member = cardnum
    ))
  }
  case class MemberOffed(txnItem: TxnItem) extends POSEvent   //remove member status for the voucher
  object MemberOffed {
    def apply(vs: VchStates): MemberOffed = MemberOffed(TxnItem(vs).copy(
      txntype = TXNTYPE.sales,
      salestype = SALESTYPE.crd,
      member = vs.mbr
    ))
  }
  case class RefundOned(txnItem: TxnItem) extends POSEvent
  object RefundOned {
    def apply(vs: VchStates): RefundOned = RefundOned(TxnItem(vs).copy(
      txntype = TXNTYPE.refund
    ))
  }
  case class RefundOffed(txnItem: TxnItem) extends POSEvent
  object RefundOffed {
    def apply(vs: VchStates): RefundOffed = RefundOffed(TxnItem(vs).copy(
      txntype = TXNTYPE.refund
    ))
  }
  case class VoidOned(txnItem: TxnItem) extends POSEvent
  object VoidOned {
    def apply(vs: VchStates): VoidOned = VoidOned(TxnItem(vs).copy(
      txntype = TXNTYPE.void
    ))
  }
  case class VoidOffed(txnItem: TxnItem) extends POSEvent
  object VoidOffed {
    def apply(vs: VchStates): VoidOffed = VoidOffed(TxnItem(vs).copy(
      txntype = TXNTYPE.void
    ))
  }

  case class NewVoucher(vnum: Int) extends POSEvent     //新单, reminder for read-side to set new vnum
  case class EndVoucher(vnum: Int) extends POSEvent     //单据终结标示
  case class VoidVoucher(txnItem: TxnItem) extends POSEvent
  object VoidVoucher {
    def apply(vs: VchStates): VoidVoucher = VoidVoucher(TxnItem(vs).copy(
      txntype = TXNTYPE.voidall
    ))
  }
  case class SuspVoucher(txnItem: TxnItem) extends POSEvent
  object SuspVoucher {
    def apply(vs: VchStates): SuspVoucher = SuspVoucher(TxnItem(vs).copy(
      txntype = TXNTYPE.suspend
    ))
  }

  case class VoucherNumed(fnum: Int, tnum: Int) extends POSEvent

  case class SalesLogged(txnItem: TxnItem) extends POSEvent
  case class Subtotaled(txnItem: TxnItem) extends POSEvent
  object Subtotaled {
    def apply(vs: VchStates, vi: VchItems): Subtotaled = {
      val (cnt,tqty,tamt,tdsc) = vi.subTotal

      Subtotaled(TxnItem(vs).copy(
        txntype = TXNTYPE.sales,
        salestype = SALESTYPE.sub,
        qty = tqty,
        amount = tamt,
        dscamt = tdsc,
        price = cnt
      ))
    }
  }
  case class Discounted(txnItem: TxnItem) extends POSEvent
  case class Payment(txnItem: TxnItem) extends POSEvent          //settlement   结算支付
  object Payment {
    def apply(acct: String, num: String, vs: VchStates): Payment = Payment(TxnItem(vs).copy(
      txntype = TXNTYPE.sales,
      salestype = SALESTYPE.ttl,
      dpt = acct,
      code = num
    ))
  }


}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以看到，在构建Event的同时也构建了TxnItem结构。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回前端数据格式如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;object Responses {

  object STATUS {
    val OK: Int = 0
    val FAIL: Int = -1
  }

  case class POSResponse (sts: Int, msg: String, voucher: VchStates, txnItems: List[TxnItem])
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;为了便于debug，我们构建了一个虚拟的数据库环节： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;115&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;package pos.dao

import java.time.LocalDate
import java.time.format.DateTimeFormatter


case class Item(
                 brd: String
                 ,dpt: String
                 ,cat: String
                 ,code: String
                 ,name: String
                 ,price: Int

               )
object Items {
  val apple = Item(&quot;01&quot;,&quot;02&quot;,&quot;01&quot;,&quot;001&quot;, &quot;green apple&quot;, 820)
  val grape = Item(&quot;01&quot;,&quot;02&quot;,&quot;01&quot;,&quot;002&quot;, &quot;red grape&quot;, 1050)
  val orage = Item(&quot;01&quot;,&quot;02&quot;,&quot;01&quot;,&quot;003&quot;, &quot;sunkist orage&quot;, 350)
  val banana = Item(&quot;01&quot;,&quot;02&quot;,&quot;01&quot;,&quot;004&quot;, &quot;demon banana&quot;, 300)
  val pineapple = Item(&quot;01&quot;,&quot;02&quot;,&quot;01&quot;,&quot;005&quot;, &quot;hainan pineapple&quot;, 1300)
  val peach = Item(&quot;01&quot;,&quot;02&quot;,&quot;01&quot;,&quot;006&quot;, &quot;xinjiang peach&quot;, 2390)

  val tblItems = List(apple, grape, orage, banana, pineapple, peach)

  sealed trait QueryItemsResult {}

  case class QueryItemsOK(items: List[Item]) extends QueryItemsResult

  case class QueryItemsFail(msg: String) extends QueryItemsResult

}


object Codes {
  case class User(code: String, name: String, passwd: String)
  case class Department(code: String, name: String)
  case class Category(code: String, name: String)
  case class Brand(code: String, name: String)
  case class Ra(code: String, name: String)
  case class Account(code: String, name: String)
  case class Disc(code: String, best: Boolean, aggr: Boolean, group: Boolean)

  val ras = List(Ra(&quot;01&quot;,&quot;Delivery&quot;),Ra(&quot;02&quot;,&quot;Cooking&quot;))
  val dpts = List(Department(&quot;01&quot;,&quot;Fruit&quot;),Department(&quot;02&quot;,&quot;Grocery&quot;))
  val cats = List(Category(&quot;0101&quot;,&quot;Fresh Fruit&quot;),Category(&quot;0201&quot;,&quot;Dry Grocery&quot;))
  val brds = List(Brand(&quot;01&quot;,&quot;Sunkist&quot;),Brand(&quot;02&quot;,&quot;Demon&quot;))
  val accts = List(Account(&quot;001&quot;,&quot;Cash&quot;),Account(&quot;002&quot;,&quot;Value Card&quot;), Account(&quot;003&quot;, &quot;Visa&quot;)
    ,Account(&quot;004&quot;,&quot;Alipay&quot;),Account(&quot;005&quot;,&quot;WXPay&quot;))

  val users = List(User(&quot;1001&quot;,&quot;Tiger&quot;, &quot;123&quot;),User(&quot;1002&quot;,&quot;John&quot;, &quot;123&quot;),User(&quot;1003&quot;,&quot;Maria&quot;, &quot;123&quot;))

  def getDpt(code: String) = dpts.find(d =&amp;gt; d.code == code)
  def getCat(code: String) = cats.find(d =&amp;gt; d.code == code)
  def getBrd(code: String) = brds.find(b =&amp;gt; b.code == code)
  def getAcct(code: String) = accts.find(a =&amp;gt; a.code == code)
  def getRa(code: String) = ras.find(a =&amp;gt; a.code == code)
}

object DAO {
  import Items._
  import Codes._

  def getItem(code: String): QueryItemsResult = {
    val optItem = tblItems.find(it =&amp;gt; it.code == code)
    optItem match {
      case Some(item) =&amp;gt; QueryItemsOK(List(item))
      case None =&amp;gt; QueryItemsFail(&quot;Invalid item code!&quot;)
    }
  }

  def validateDpt(code: String) = dpts.find(d =&amp;gt; d.code == code)
  def validateCat(code: String) = cats.find(d =&amp;gt; d.code == code)
  def validateBrd(code: String) = brds.find(b =&amp;gt; b.code == code)
  def validateRa(code: String) = ras.find(ac =&amp;gt; ac.code == code)
  def validateAcct(code: String) = accts.find(ac =&amp;gt; ac.code == code)

  def validateUser(userid: String, passwd: String) = users.find(u =&amp;gt; (u.code == userid &amp;amp;&amp;amp; u.passwd == passwd))

  def lastSecOfDateStr(ldate: LocalDate): String = {
    ldate.format(DateTimeFormatter.ofPattern( &quot;yyyy-MM-dd&quot;))+&quot; 23:59:59&quot;
  }


}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个库主要是用来验证和提供TxnItem里的字段值。&lt;/p&gt;
&lt;p&gt;好了，回到WriterActor：同样为了方便集群分片监控跟踪和debug，增加了debugMode和重写了persist：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;class WriterActor extends PersistentActor with LogSupport {
  val cluster = Cluster(context.system)
  // shopdptId-posId
  // self.path.parent.name is the type name (utf-8 URL-encoded)
  // self.path.name is the entry identifier (utf-8 URL-encoded)  but entity has a supervisor
  // override def persistenceId: String = self.path.parent.parent.name + &quot;-&quot; + self.path.parent.name
  override def persistenceId: String = self.path.parent.name

  override def preRestart(reason: Throwable, message: Option[Any]): Unit = {
    super.preRestart(reason, message)
    log.info(s&quot;Restarting terminal $persistenceId on ${cluster.selfAddress} for $message&quot;)
  }

  override def postRestart(reason: Throwable): Unit = {
    super.postRestart(reason)
    log.info(s&quot;terminal $persistenceId on ${cluster.selfAddress} restarted for ${reason.getMessage}&quot;)
  }

  override def postStop(): Unit = {
    log.info(s&quot;terminal $persistenceId on ${cluster.selfAddress} stopped!&quot;)
  }

  override def preStart(): Unit = {
    log.info(s&quot;terminal $persistenceId on ${cluster.selfAddress} starting...&quot;)
  }

  //helper functions
  object RunPOSCommand {
    def unapply(arg: POSCommand) = if (cmdFilter(persistenceId,arg,vchState,vchItems,sender())) Some(arg) else None
  }

  def persistEvent[E](evt: E)(f: E =&amp;gt; Unit)(implicit dm: DebugMode) = {
    if (dm.debug)
      log.info(s&quot;********** $persistenceId: persisted event: {$evt} **********&quot;)
    else {
      try {
        persist(evt)(f)
        log.debug(s&quot;终端-$persistenceId：event: [$evt] state: [$vchState] : [${vchItems.txnitems.reverse}]&quot;)
      }
      catch {
        case err: Throwable =&amp;gt;
          sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 操作失败！[${err.getMessage}]。&quot;, vchState, vchItems.txnitems.reverse)
          log.error(s&quot;终端-$persistenceId： 操作失败！[${err.getMessage}] current state: [$vchState],[${vchItems.txnitems.reverse}]&quot;)
      }
    }
  }

  var debugConfig: com.typesafe.config.Config = _
  var debug: Boolean = _
  try {

    debugConfig = ConfigFactory.load(&quot;pos.conf&quot;).getConfig(&quot;pos.server&quot;)
    debug = debugConfig.getBoolean(&quot;debug&quot;)
  }
  catch {
    case _ : Throwable =&amp;gt; debug = false
  }

  log.info(s&quot;********** $persistenceId: debug mode = $debug **********&quot;)

  implicit val debugMode = DebugMode(debug)

//actor state
  var vchState = VchStates()
  var vchItems = VchItems()


  override def receiveRecover: Receive = {
    case evt: POSEvent =&amp;gt;    //incompleted voucher play back events
      val (vs,vi) =  updateState(evt,vchState,vchItems)
      vchState = vs; vchItems = vi
    case SnapshotOffer(_,vs: VchStates) =&amp;gt; vchState = vs  //restore num,seq ...
  }
  
  override def receiveCommand: Receive = logOffState
...
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;Receive函数在WriteActor启动时默认为logOffState  &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;  private def logOffState: Receive = {
    case RunPOSCommand(LogOn(opr, _)) =&amp;gt;
          persistEvent(LogOned(opr,vchState)) { evt =&amp;gt;
            val sts = updateState(evt, vchState, vchItems)
//starting seqenceNr for any voucher. no action logged before login
            vchState = sts._1.copy(jseq = lastSequenceNr + 1);
            vchItems = sts._2
            sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 用户{$opr}成功登陆。&quot;, vchState, List(vchItems.txnitems.head))
            context.become(logOnState)
          }
      
    case PassivatePOS =&amp;gt;
      log.info(s&quot;**********${persistenceId} got passivate message and stopping  ... ***********&quot;)
      context.parent ! PoisonPill

    case _ =&amp;gt;
      sender() ! POSResponse(STATUS.FAIL, s&quot;操作失败！终端 ${persistenceId} 用户未登陆。&quot;, vchState, List())
  }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;除LogOn指令外不接受任何其它指令，一旦接到指令立即通过context.become(logOnState)转状态。passivation只会在这个状态下发挥作用。这也可以理解：即先是没有处理中的单据，又有一段时间的空转，可以passivate了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在logOnState里可以进行支付操作，如果支付金额小于应付金额则代表部分付款操作，需要转入paymentState：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;49&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;  private def logOnState: Receive = {
...
    //first payment in a voucher
    case RunPOSCommand(OfflinePay(acct,num, amount)) =&amp;gt;
      persistEvent(Payment(acct,num,vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        if (vchItems.totalSales &amp;gt; 0)
          sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}支付。&quot;, vchState, List(vchItems.txnitems.head))
        else
          sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}退款。&quot;, vchState, List(vchItems.txnitems.head))
        if (!vchState.due) {  //completed voucher. mark end of voucher and move next. stay in logOnState
          persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
            val sts = updateState(evt, vchState, vchItems)
            vchState = sts._1
            vchItems = sts._2
            saveSnapshot(vchState)     //recovery to next voucher
          }
        }
        else context.become(paymentState)     //switch into paymentState
      }
...
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;支付操作可能出现两种情况：整单完成，存入EndVoucher标示，saveSnapshot，或者转入paymentState。同样，在paymentState状态，只接受支付指令，直到应付金额耗尽，转回logOnState: &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;113&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt; private def paymentState: Receive = {
    case RunPOSCommand(OfflinePay(acct,num, amount)) =&amp;gt;
           persistEvent(Payment(acct,num,vchState)) { evt =&amp;gt;
             val sts = updateState(evt, vchState, vchItems)
             vchState = sts._1
             vchItems = sts._2
             if (vchItems.totalSales &amp;gt; 0)
               sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}支付。&quot;, vchState, List(vchItems.txnitems.head))
             else
               sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}退款。&quot;, vchState, List(vchItems.txnitems.head))

             if (!vchState.due) {  //completed voucher. mark end of voucher and move next. return to logOnState
               persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
                 val sts = updateState(evt, vchState, vchItems, lastSeqenceNr)
                 vchState = sts._1
                 vchItems = sts._2
                 saveSnapshot(vchState)     //recovery to next voucher
                 context.unbecome()    //logOnState
               }
             }
             // else wait for other payments and stay in logOnState
           }
 /* strictly disallow any action other than payment till completion
    case RunPOSCommand(VoidAll) =&amp;gt;
      persistEvent(VoidVoucher(vchState)) { _ =&amp;gt;
        persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
          updateState(evt,vchState,vchItems)
          context.unbecome()    //in paymentState, switch to logOnState
        }
      }
    case RunPOSCommand(Suspend) =&amp;gt;
      persistEvent(SuspVoucher(vchState)) { _ =&amp;gt;
        persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
          updateState(evt,vchState,vchItems)
          context.unbecome()    //in paymentState, switch to logOnState
        }
      }
*/
    case RunPOSCommand(SuperOn(su,_)) =&amp;gt;
      persistEvent(SuperOned(su,vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
      }
    case RunPOSCommand(SuperOff) =&amp;gt;
      persistEvent(SuperOffed(vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
      }

    case RunPOSCommand(VCBalance(acct,num,passwd)) =&amp;gt;
      if (POSInterfaces.validateVC(acct,num,passwd)) {
        val res = POSInterfaces.getVCBalance(acct,num)
        if (res.sts == POSInterfaces.VCRESULT.OK)
          sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 储值卡余额{${res.amt}}。&quot;, vchState, List(TxnItem(vchState).copy(
            amount = (res.amt * 100).toInt,
            dpt = acct,
            code = num
          )))
        else
          sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]余额读取错误！[${res.msg}]&quot;, vchState, List())
      } else {
        sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]验证信息错误！&quot;, vchState, List())
      }

    case RunPOSCommand(VCPay(acct,num, passwd,amount)) =&amp;gt;
      if (POSInterfaces.validateVC(acct,num,passwd)) {
        val res = POSInterfaces.getVCBalance(acct,num)
        if (res.sts == POSInterfaces.VCRESULT.OK) {
          if ((res.amt * 100).toInt &amp;lt; amount)
            sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]余额不足！&quot;, vchState,List(TxnItem(vchState).copy(
              amount = (res.amt * 100).toInt,
              dpt = acct,
              code = num
            )))
          else {
            val res = POSInterfaces.payByVC(acct,num,amount/100.00)
            if (res.sts == POSInterfaces.VCRESULT.OK) {
              persistEvent(Payment(acct,num,vchState)) { evt =&amp;gt;
                val sts = updateState(evt, vchState, vchItems)
                vchState = sts._1
                vchItems = sts._2
                if (vchItems.totalSales &amp;gt; 0)
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}支付。&quot;, vchState, List(vchItems.txnitems.head))
                else
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}退款。&quot;, vchState, List(vchItems.txnitems.head))
                if (!vchState.due) {  //completed voucher. mark end of voucher and move next. stay in logOnState
                  persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
                    val sts = updateState(evt, vchState, vchItems, lastSeqenceNr)
                    vchState = sts._1
                    vchItems = sts._2
                    saveSnapshot(vchState)     //recovery to next voucher
                    context.unbecome()         //switch to logOnState
                  }
                }
              }

            }
          }

        }
        else
          sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]余额读取错误！[${res.msg}]&quot;, vchState, List())
      } else {
        sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]验证信息错误！&quot;, vchState, List())
      }
    case _ =&amp;gt;
      sender() ! POSResponse(STATUS.FAIL, s&quot;操作失败！终端 ${persistenceId} 结算中不容许其它非支付操作！&quot;, vchState, List(vchItems.txnitems.head))

  }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;目前支付部分只处理了线下支付和储值卡支付两个流程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;每单结束时会进行单据处理状态快照存储 saveSnapShot(vchState)，真正意义在新一单从零的重新开始。 VchState是在updateState函数里维护的：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt;  case class VchStates(
                        opr: String = &quot;&quot;,      //收款员
                        jseq: BigInt = 0,      //begin journal sequence for read-side replay
                        num: Int = 0,          //当前单号
                        seq: Int = 1,          //当前序号
                        void: Boolean = false, //取消模式
                        refd: Boolean = false, //退款模式
                        due: Boolean = true,   //当前余额
                        su: String = &quot;&quot;,
                        mbr: String = &quot;&quot;
                      ) {

    def nextVoucher : VchStates = VchStates().copy(
      opr = this.opr,
      jseq = this.jseq + 1,
      num = this.num + 1
    )
  }
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;也就是说每次saveSnapShot会把当前单号、操作员存入snapshot方便恢复当前单状态。另外jseq是本单事件存入时的写序号lastSeqenceNr，我们用来通知Reader-Actor从那里开始读journal。这个jseq是如下维护的： &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&lt;span&gt; def updateState(evt: POSEvent, state: VchStates, items: VchItems, lastSeqNr: BigInt = 0): (VchStates, VchItems) = evt match {
    case LogOned(txn) =&amp;gt; (state.copy(seq = txn.seq + 1,opr = txn.opr,jseq = lastSeqNr), items)

...
   case EndVoucher(vnum) =&amp;gt; (state.nextVoucher.copy(jseq = lastSeqNr), VchItems())

...
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如上所述，只在登陆时或者结单时需要标示jseq。注意：登陆指令只能在完成单据的情况下处理，而lastSeqenceNr是一单的结束序号，+1就是新单开始序号了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面把这次示范的完整源代码提供在下面。这是一个只通过了编译的版本。完整可运行的cluster-sharding版本放在下篇中提供：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;build.sbt&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
name := &quot;akka-cluster-pos&quot;

version := &quot;0.2&quot;

scalaVersion := &quot;2.12.8&quot;

libraryDependencies := Seq(
  &quot;com.typesafe.akka&quot; %% &quot;akka-cluster-sharding&quot; % &quot;2.5.21&quot;,
  &quot;com.typesafe.akka&quot; %% &quot;akka-persistence&quot; % &quot;2.5.21&quot;,
  &quot;com.typesafe.akka&quot; %% &quot;akka-persistence-cassandra&quot; % &quot;0.92&quot;,
  &quot;com.typesafe.akka&quot; %% &quot;akka-persistence-cassandra-launcher&quot; % &quot;0.92&quot; % Test,
  &quot;ch.qos.logback&quot;  %  &quot;logback-classic&quot;   % &quot;1.2.3&quot;
)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;resources/application.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
akka.actor.warn-about-java-serializer-usage = off
akka.log-dead-letters-during-shutdown = off
akka.log-dead-letters = off

akka {
  loglevel = INFO
  actor {
    provider = &quot;cluster&quot;
  }

  remote {
    log-remote-lifecycle-events = off
    netty.tcp {
      hostname = &quot;127.0.0.1&quot;
      port = 0
    }
  }

  cluster {
    seed-nodes = [
      &quot;akka.tcp://posSystem@127.0.0.1:2551&quot;]
    log-info = off
    sharding {
      role = &quot;shard&quot;
      passivate-idle-entity-after = 10 s
    }
  }

  persistence {
    journal.plugin = &quot;cassandra-journal&quot;
    snapshot-store.plugin = &quot;cassandra-snapshot-store&quot;
  }

}

cassandra-journal {
  contact-points = [&quot;192.168.1.18&quot;]
}

cassandra-snapshot-store {
  contact-points = [&quot;192.168.1.18&quot;]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;pos.conf&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
pos {
  server {
    debug = false
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; logback.xml&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;configuration&amp;gt;

    &amp;lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&amp;gt;
        &amp;lt;layout class=&quot;ch.qos.logback.classic.PatternLayout&quot;&amp;gt;
            &amp;lt;Pattern&amp;gt;
                %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n
            &amp;lt;/Pattern&amp;gt;
        &amp;lt;/layout&amp;gt;
    &amp;lt;/appender&amp;gt;

    &amp;lt;logger name=&quot;sdp.cql&quot; level=&quot;info&quot;
            additivity=&quot;false&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;STDOUT&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;

    &amp;lt;logger name=&quot;demo.sdp.grpc.cql&quot; level=&quot;info&quot;
            additivity=&quot;false&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;STDOUT&quot; /&amp;gt;
    &amp;lt;/logger&amp;gt;

    &amp;lt;root level=&quot;error&quot;&amp;gt;
        &amp;lt;appender-ref ref=&quot;STDOUT&quot; /&amp;gt;
    &amp;lt;/root&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;logging/Log.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
package sdp.logging

import org.slf4j.Logger

/**
  * Logger which just wraps org.slf4j.Logger internally.
  *
  * @param logger logger
  */
class Log(logger: Logger) {

  // use var consciously to enable squeezing later
  var isDebugEnabled: Boolean = logger.isDebugEnabled
  var isInfoEnabled: Boolean = logger.isInfoEnabled
  var isWarnEnabled: Boolean = logger.isWarnEnabled
  var isErrorEnabled: Boolean = logger.isErrorEnabled

  def withLevel(level: Symbol)(msg: =&amp;gt; String, e: Throwable = null): Unit = {
    level match {
      case 'debug | 'DEBUG =&amp;gt; debug(msg)
      case 'info | 'INFO =&amp;gt; info(msg)
      case 'warn | 'WARN =&amp;gt; warn(msg)
      case 'error | 'ERROR =&amp;gt; error(msg)
      case _ =&amp;gt; // nothing to do
    }
  }

  def debug(msg: =&amp;gt; String): Unit = {
    if (isDebugEnabled &amp;amp;&amp;amp; logger.isDebugEnabled) {
      logger.debug(msg)
    }
  }

  def debug(msg: =&amp;gt; String, e: Throwable): Unit = {
    if (isDebugEnabled &amp;amp;&amp;amp; logger.isDebugEnabled) {
      logger.debug(msg, e)
    }
  }

  def info(msg: =&amp;gt; String): Unit = {
    if (isInfoEnabled &amp;amp;&amp;amp; logger.isInfoEnabled) {
      logger.info(msg)
    }
  }

  def info(msg: =&amp;gt; String, e: Throwable): Unit = {
    if (isInfoEnabled &amp;amp;&amp;amp; logger.isInfoEnabled) {
      logger.info(msg, e)
    }
  }

  def warn(msg: =&amp;gt; String): Unit = {
    if (isWarnEnabled &amp;amp;&amp;amp; logger.isWarnEnabled) {
      logger.warn(msg)
    }
  }

  def warn(msg: =&amp;gt; String, e: Throwable): Unit = {
    if (isWarnEnabled &amp;amp;&amp;amp; logger.isWarnEnabled) {
      logger.warn(msg, e)
    }
  }

  def error(msg: =&amp;gt; String): Unit = {
    if (isErrorEnabled &amp;amp;&amp;amp; logger.isErrorEnabled) {
      logger.error(msg)
    }
  }

  def error(msg: =&amp;gt; String, e: Throwable): Unit = {
    if (isErrorEnabled &amp;amp;&amp;amp; logger.isErrorEnabled) {
      logger.error(msg, e)
    }
  }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;logging/LogSupport.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
package sdp.logging

import org.slf4j.LoggerFactory

trait LogSupport {

  /**
    * Logger
    */
  protected val log = new Log(LoggerFactory.getLogger(this.getClass))

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Commands.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;90&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
package pos.commands
import pos.states.States._

object Commands {

  case object PassivatePOS    //passivate message
  case class DebugMode(debug: Boolean)

  sealed trait POSCommand {}

  case class LogOn(opr: String, passwd: String) extends POSCommand
  case object LogOff extends POSCommand
  case class SuperOn(su: String, passwd: String) extends POSCommand
  case object SuperOff extends POSCommand
  case class MemberOn(cardnum: String, passwd: String) extends POSCommand
  case object MemberOff extends POSCommand   //remove member status for the voucher
  case object RefundOn extends POSCommand
  case object RefundOff extends POSCommand
  case object VoidOn extends POSCommand
  case object VoidOff extends POSCommand
  case object VoidAll extends POSCommand
  case object Suspend extends POSCommand

  case class VoucherNum(vnum: Int) extends POSCommand


  case class LogSales(salesType: Int, dpt: String, code: String, qty: Int, price: Int) extends POSCommand
  case object Subtotal extends POSCommand
  case class Discount(code: String, percent: Int) extends POSCommand

  case class OfflinePay(acct: String, num: String, amount: Int) extends POSCommand          //settlement   结算支付
 //read only command, no event process
  case class VCBalance(acct: String, num: String, passwd: String) extends POSCommand
  case class VCPay(acct: String, num: String, passwd: String, amount: Int) extends POSCommand
  case class AliPay(acct: String, num: String, amount: Int) extends POSCommand
  case class WxPay(acct: String, num: String, amount: Int) extends POSCommand


  // read only command, no update event
  case class Plu(itemCode: String) extends POSCommand  //read only


}


object Events {

  sealed trait POSEvent {}

  case class LogOned(txnItem: TxnItem) extends POSEvent
  object LogOned {
    def apply(op: String, vs: VchStates): LogOned = LogOned(TxnItem(vs).copy(
      txntype = TXNTYPE.logon,
      salestype = SALESTYPE.crd,
      opr = op,
      code = op
    ))
  }
  case class LogOffed(txnItem: TxnItem) extends POSEvent
  object LogOffed {
    def apply(vs: VchStates): LogOffed = LogOffed(TxnItem(vs).copy(
      txntype = TXNTYPE.logon,
      salestype = SALESTYPE.crd,
    ))
  }
  case class SuperOned(txnItem: TxnItem) extends POSEvent
  object SuperOned {
    def apply(su: String, vs: VchStates): SuperOned = SuperOned(TxnItem(vs).copy(
      txntype = TXNTYPE.supon,
      salestype = SALESTYPE.crd,
      code = su
    ))
  }
  case class SuperOffed(txnItem: TxnItem) extends POSEvent
  object SuperOffed {
    def apply(vs: VchStates): SuperOffed = SuperOffed(TxnItem(vs).copy(
      txntype = TXNTYPE.supon,
      salestype = SALESTYPE.crd
    ))
  }
  case class MemberOned(txnItem: TxnItem) extends POSEvent
  object MemberOned {
    def apply(cardnum: String,vs: VchStates): MemberOned = MemberOned(TxnItem(vs).copy(
      txntype = TXNTYPE.sales,
      salestype = SALESTYPE.crd,
      member = cardnum
    ))
  }
  case class MemberOffed(txnItem: TxnItem) extends POSEvent   //remove member status for the voucher
  object MemberOffed {
    def apply(vs: VchStates): MemberOffed = MemberOffed(TxnItem(vs).copy(
      txntype = TXNTYPE.sales,
      salestype = SALESTYPE.crd,
      member = vs.mbr
    ))
  }
  case class RefundOned(txnItem: TxnItem) extends POSEvent
  object RefundOned {
    def apply(vs: VchStates): RefundOned = RefundOned(TxnItem(vs).copy(
      txntype = TXNTYPE.refund
    ))
  }
  case class RefundOffed(txnItem: TxnItem) extends POSEvent
  object RefundOffed {
    def apply(vs: VchStates): RefundOffed = RefundOffed(TxnItem(vs).copy(
      txntype = TXNTYPE.refund
    ))
  }
  case class VoidOned(txnItem: TxnItem) extends POSEvent
  object VoidOned {
    def apply(vs: VchStates): VoidOned = VoidOned(TxnItem(vs).copy(
      txntype = TXNTYPE.void
    ))
  }
  case class VoidOffed(txnItem: TxnItem) extends POSEvent
  object VoidOffed {
    def apply(vs: VchStates): VoidOffed = VoidOffed(TxnItem(vs).copy(
      txntype = TXNTYPE.void
    ))
  }

  case class NewVoucher(vnum: Int) extends POSEvent     //新单, reminder for read-side to set new vnum
  case class EndVoucher(vnum: Int) extends POSEvent     //单据终结标示
  case class VoidVoucher(txnItem: TxnItem) extends POSEvent
  object VoidVoucher {
    def apply(vs: VchStates): VoidVoucher = VoidVoucher(TxnItem(vs).copy(
      txntype = TXNTYPE.voidall
    ))
  }
  case class SuspVoucher(txnItem: TxnItem) extends POSEvent
  object SuspVoucher {
    def apply(vs: VchStates): SuspVoucher = SuspVoucher(TxnItem(vs).copy(
      txntype = TXNTYPE.suspend
    ))
  }

  case class VoucherNumed(fnum: Int, tnum: Int) extends POSEvent

  case class SalesLogged(txnItem: TxnItem) extends POSEvent
  case class Subtotaled(txnItem: TxnItem) extends POSEvent
  object Subtotaled {
    def apply(vs: VchStates, vi: VchItems): Subtotaled = {
      val (cnt,tqty,tamt,tdsc) = vi.subTotal

      Subtotaled(TxnItem(vs).copy(
        txntype = TXNTYPE.sales,
        salestype = SALESTYPE.sub,
        qty = tqty,
        amount = tamt,
        dscamt = tdsc,
        price = cnt
      ))
    }
  }
  case class Discounted(txnItem: TxnItem) extends POSEvent
  case class Payment(txnItem: TxnItem) extends POSEvent          //settlement   结算支付
  object Payment {
    def apply(acct: String, num: String, vs: VchStates): Payment = Payment(TxnItem(vs).copy(
      txntype = TXNTYPE.sales,
      salestype = SALESTYPE.ttl,
      dpt = acct,
      code = num
    ))
  }


}

object Responses {

  object STATUS {
    val OK: Int = 0
    val FAIL: Int = -1
  }

  case class POSResponse (sts: Int, msg: String, voucher: VchStates, txnItems: List[TxnItem])
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;states.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;170&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
package pos.states
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter
import java.util.Locale

import pos.commands.Events._
import pos.commands.Commands._
import akka.actor._
import pos.dao.DAO._
import pos.dao.Codes._
import pos.commands.Responses._

object States {

  val  dateTimeFormatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.CHINA)


  object TXNTYPE {
    val sales: Int = 0
    val refund: Int = 1
    val void: Int = 2
    val voided: Int = 3
    val voidall: Int = 4
    val subtotal: Int = 5
    val logon: Int = 6
    val supon: Int = 7       // super user on/off
    val suspend: Int = 8

  }

  object SALESTYPE {
    val plu: Int = 0
    val dpt: Int = 1
    val cat: Int = 2
    val brd: Int = 3
    val ra:  Int = 4
    val sub: Int = 5
    val ttl: Int = 6
    val dsc: Int = 7
    val crd: Int = 8
  }


  case class TxnItem(
                      txndate: String = LocalDate.now.format(DateTimeFormatter.ofPattern(&quot;yyyyMMdd&quot;))
                      ,txntime: String = LocalDateTime.now.format(dateTimeFormatter).substring(11)
                      ,opr: String = &quot;&quot;//工号
                      ,num: Int = 0 //销售单号
                      ,seq: Int = 1 //交易序号
                      ,txntype: Int = TXNTYPE.sales//交易类型
                      ,salestype: Int = SALESTYPE.plu //销售类型
                      ,qty: Int =  1 //交易数量
                      ,price: Int = 0 //单价（分）
                      ,amount: Int = 0 //码洋（分）
                      ,dscamt: Int = 0 //折扣：负值  net实洋 = amount + dscamt
                      ,member: String = &quot;&quot; //会员卡号
                      ,code: String = &quot;&quot; //编号（商品、账号...）
                      ,desc: String = &quot;&quot; //项目名称
                      ,dpt: String = &quot;&quot;
                      ,department: String = &quot;&quot;
                      ,cat: String = &quot;&quot;
                      ,category: String = &quot;&quot;
                      ,brd: String = &quot;&quot;
                      ,brand: String = &quot;&quot;
                    )
  object TxnItem {
    def apply(vs: VchStates): TxnItem = TxnItem().copy(
      opr = vs.opr,
      num = vs.num,
      seq = vs.seq,
      member = vs.mbr
    )
  }

  case class VchStatus( //操作状态锁留给前端维护
                        qty: Int = 1,
                        refund: Boolean = false,
                        void: Boolean = false)

  case class VchStates(
                        opr: String = &quot;&quot;,      //收款员
                        jseq: BigInt = 0,      //begin journal sequence for read-side replay
                        num: Int = 0,          //当前单号
                        seq: Int = 1,          //当前序号
                        void: Boolean = false, //取消模式
                        refd: Boolean = false, //退款模式
                        due: Boolean = true,   //当前余额
                        su: String = &quot;&quot;,
                        mbr: String = &quot;&quot;
                      ) {

    def nextVoucher : VchStates = VchStates().copy(
      opr = this.opr,
      jseq = this.jseq + 1,
      num = this.num + 1
    )
  }

  case class VchItems(txnitems: List[TxnItem] = Nil) {
    def subTotal: (Int,Int,Int,Int) = txnitems.foldRight((0,0,0,0)) { case (txn,b) =&amp;gt;
      if (txn.salestype &amp;lt; SALESTYPE.sub &amp;amp;&amp;amp; txn.txntype == TXNTYPE.sales)
        b.copy(_1 = b._1 + 1, _2 = b._2 + txn.qty, _3 = b._3 + txn.amount, _4 = b._4 + txn.dscamt)
      else b
    }
    def totalSales: Int = txnitems.foldRight(0) { case (txn, b) =&amp;gt;
      if ( txn.salestype &amp;lt;= SALESTYPE.ra)
        (txn.amount + txn.dscamt) + b
      else  b

/*
      val amt: Int = txn.salestype match {
        case (SALESTYPE.plu | SALESTYPE.cat | SALESTYPE.brd | SALESTYPE.ra) =&amp;gt; txn.amount + txn.dscamt
        case _ =&amp;gt; 0
      }
      amt + b */
    }
    def totalPaid: Int = txnitems.foldRight(0) { case (txn, b) =&amp;gt;
      if (txn.txntype == TXNTYPE.sales &amp;amp;&amp;amp; txn.salestype == SALESTYPE.ttl)
         txn.amount + b
      else b
      /*
      val amt: Int = txn.salestype match {
        case SALESTYPE.ttl =&amp;gt; txn.amount
        case _ =&amp;gt; 0
      }
      amt + b */
    }
    def addItem(item: TxnItem): VchItems = VchItems((item :: txnitems))   //.reverse)

  }

  def LastSecOfDate(ldate: LocalDate): LocalDateTime = {
    val dtStr = ldate.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;)) + &quot; 23:59:59&quot;
    LocalDateTime.parse(dtStr, DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;))
  }

  def dateStr(dt: LocalDate): String = dt.format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;))

  def updateState(evt: POSEvent, state: VchStates, items: VchItems, lastSeqNr: BigInt = 0): (VchStates, VchItems) = evt match {
    case LogOned(txn) =&amp;gt; (state.copy(seq = txn.seq + 1,opr = txn.opr,jseq = lastSeqNr), items)
    case LogOffed(txn)  =&amp;gt; (state.copy(seq = state.seq + 1,opr = &quot;&quot;), items)
    case RefundOned(txn) =&amp;gt; (state.copy(seq = txn.seq + 1,refd = true), items)
    case RefundOffed(txn) =&amp;gt;  (state.copy(seq = txn.seq + 1,refd = false), items)
    case VoidOned(txn) =&amp;gt; (state.copy(seq = txn.seq + 1,void = true), items)
    case VoidOffed(txn) =&amp;gt; (state.copy(seq = txn.seq + 1,void = false), items)
    case SuperOned(txn) =&amp;gt; (state.copy(seq = txn.seq + 1, su = txn.code), items)
    case SuperOffed(txn) =&amp;gt; (state.copy(seq = txn.seq + 1, su = &quot;&quot;), items)
    case MemberOned(txn) =&amp;gt; (state.copy(seq = txn.seq + 1, mbr = txn.member), items)
    case MemberOffed(txn) =&amp;gt; (state.copy(seq = txn.seq + 1, mbr=&quot;&quot;), items)


    case SalesLogged(txnitem) =&amp;gt; (state.copy(
      seq = state.seq + 1)
    , items.addItem(txnitem))

    case Subtotaled(txnitem) =&amp;gt; (state.copy(
      seq = state.seq + 1)
      , items.addItem(txnitem))

    case Payment(txnItem) =&amp;gt;
      val due = if(items.totalSales &amp;gt; 0) items.totalSales -  items.totalPaid else items.totalSales + items.totalPaid
      val bal = if(items.totalSales &amp;gt; 0) due - txnItem.amount else due + txnItem.amount
        (state.copy(
          seq = state.seq + 1,
          due = (if( (txnItem.amount.abs + items.totalPaid.abs) &amp;gt;= items.totalSales.abs) false else true)
        )
        ,items.addItem(txnItem.copy(
          salestype = SALESTYPE.ttl,
          price = due,
          amount = txnItem.amount,
          dscamt = bal,
          department = getAcct(txnItem.dpt).getOrElse(Account(&quot;&quot;,&quot;&quot;)).name
        )))

    case VoucherNumed(_,tnum) =&amp;gt;
      val vi = items.copy(txnitems = items.txnitems.map {it =&amp;gt; it.copy(num = tnum)})
      (state.copy(seq = state.seq + 1, num = tnum), vi)
/*
    case VoidVoucher(vnum) =&amp;gt; (state.nextVoucher, VchItems())
    case SuspVoucher(vnum) =&amp;gt; (state.nextVoucher, VchItems())   //represented by EndVoucher
    */
    case EndVoucher(vnum) =&amp;gt; (state.nextVoucher.copy(jseq = lastSeqNr), VchItems())

    case _ =&amp;gt; (state, items)
  }

  def cmdFilter(terminalid: String, cmd: POSCommand, state: VchStates, txns: VchItems, router: ActorRef): Boolean = cmd match {
    case LogOn(opr, passwd) =&amp;gt;      //only allowed in logOffState
      if (!txns.txnitems.isEmpty) { //in the middle of process
        router ! POSResponse(STATUS.FAIL, s&quot;禁止用户登陆！终端 ${terminalid} 有未完成单据。&quot;, state, List())
        false
      } else{
        if (validateUser(opr, passwd).isDefined) true
        else {
          router ! POSResponse(STATUS.FAIL, s&quot;终端-$terminalid： 用户 ${opr} 登陆失败！&quot;, state, List())
          false
        }
      }
    case LogOff =&amp;gt;       //only allowed in logOnState
      if (!txns.txnitems.isEmpty) { //in the middle of process
        router ! POSResponse(STATUS.FAIL, s&quot;禁止用户退出！终端 ${terminalid} 有未完成单据。&quot;, state, List())
        false
      } else true

    case VoidAll =&amp;gt;   //allowed in logOnState and paymentState
      if (txns.txnitems.isEmpty) { //no valid sales
        router ! POSResponse(STATUS.FAIL, s&quot;全单取消失败！终端 ${terminalid} 本单无任何有效销售记录。&quot;, state, txns.txnitems)
        false
      } else true

    case OfflinePay(acct,num,amt) =&amp;gt;
      if (txns.totalSales.abs == 0) { // no valid sales. void,refund neg values could produce zero
        router ! POSResponse(STATUS.FAIL, s&quot;支付失败！终端 ${terminalid} 应付金额为零。&quot;, state, List())
        false
      } else {
        if(validateAcct(acct).isDefined) true
        else {
          router ! POSResponse(STATUS.FAIL, s&quot;支付失败！终端 ${terminalid} 账号{$acct}不存在。&quot;, state, List())
          false
        }
      }
    case Subtotal =&amp;gt;
      if (txns.txnitems.isEmpty) { //in the middle of process
        router ! POSResponse(STATUS.FAIL, s&quot;小计操作失败！终端 ${terminalid} 无任何销售记录。&quot;, state, List())
        false
      } else true
    case VCBalance(_,_,_) =&amp;gt; true
    case MemberOn(_,_) =&amp;gt; true
    case MemberOff =&amp;gt; true
    case VoucherNum(_) =&amp;gt; true

    case LogSales(salesType,sdpt,scode,sqty,sprice) =&amp;gt;
      if (state.void) {
        txns.txnitems.find(ti =&amp;gt; (ti.txntype == TXNTYPE.sales &amp;amp;&amp;amp; ti.salestype == salesType &amp;amp;&amp;amp;
          ti.dpt == sdpt &amp;amp;&amp;amp; ti.code == scode &amp;amp;&amp;amp; ti.qty == sqty &amp;amp;&amp;amp; ti.price == sprice)) match {
          case Some(_) =&amp;gt; true
          case None =&amp;gt;
            router ! POSResponse(STATUS.FAIL, s&quot;取消交易失败！终端 ${terminalid} 销售记录不存在。&quot;, state, List(TxnItem(state).copy(
              salestype = salesType,
              dpt = sdpt,
              code = scode,
              price = sprice
            )))
            false
        }

      } else true

    case c @ _ =&amp;gt;
      router ! POSResponse(STATUS.FAIL, s&quot;终端 ${terminalid} 不支持操作 {$c}&quot;, state, List())
      false
  }


}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;POSHandler.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;374&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
package pos.handler
import akka.actor._
import akka.persistence._
import akka.cluster._
import pos.commands.Events._
import pos.commands.Commands._
import pos.states._
import States._
import pos.dao.Items._
import pos.dao.DAO._
import pos.dao.Codes._
import com.typesafe.config.ConfigFactory
import sdp.logging.LogSupport
import pos.commands.Responses._
import pos.interface.POSInterfaces


class WriterActor extends PersistentActor with LogSupport {
  val cluster = Cluster(context.system)
  // shopdptId-posId
  // self.path.parent.name is the type name (utf-8 URL-encoded)
  // self.path.name is the entry identifier (utf-8 URL-encoded)  but entity has a supervisor
  // override def persistenceId: String = self.path.parent.parent.name + &quot;-&quot; + self.path.parent.name
  override def persistenceId: String = self.path.parent.name

  override def preRestart(reason: Throwable, message: Option[Any]): Unit = {
    super.preRestart(reason, message)
    log.info(s&quot;Restarting terminal $persistenceId on ${cluster.selfAddress} for $message&quot;)
  }

  override def postRestart(reason: Throwable): Unit = {
    super.postRestart(reason)
    log.info(s&quot;terminal $persistenceId on ${cluster.selfAddress} restarted for ${reason.getMessage}&quot;)
  }

  override def postStop(): Unit = {
    log.info(s&quot;terminal $persistenceId on ${cluster.selfAddress} stopped!&quot;)
  }

  override def preStart(): Unit = {
    log.info(s&quot;terminal $persistenceId on ${cluster.selfAddress} starting...&quot;)
  }

  //helper functions
  object RunPOSCommand {
    def unapply(arg: POSCommand) = if (cmdFilter(persistenceId,arg,vchState,vchItems,sender())) Some(arg) else None
  }

  def persistEvent[E](evt: E)(f: E =&amp;gt; Unit)(implicit dm: DebugMode) = {
    if (dm.debug)
      log.info(s&quot;********** $persistenceId: persisted event: {$evt} **********&quot;)
    else {
      try {
        persist(evt)(f)
        log.debug(s&quot;终端-$persistenceId：event: [$evt] state: [$vchState] : [${vchItems.txnitems.reverse}]&quot;)
      }
      catch {
        case err: Throwable =&amp;gt;
          sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 操作失败！[${err.getMessage}]。&quot;, vchState, vchItems.txnitems.reverse)
          log.error(s&quot;终端-$persistenceId： 操作失败！[${err.getMessage}] current state: [$vchState],[${vchItems.txnitems.reverse}]&quot;)
      }
    }
  }

  var debugConfig: com.typesafe.config.Config = _
  var debug: Boolean = _
  try {

    debugConfig = ConfigFactory.load(&quot;pos.conf&quot;).getConfig(&quot;pos.server&quot;)
    debug = debugConfig.getBoolean(&quot;debug&quot;)
  }
  catch {
    case _ : Throwable =&amp;gt; debug = false
  }

  log.info(s&quot;********** $persistenceId: debug mode = $debug **********&quot;)

  implicit val debugMode = DebugMode(debug)

//actor state
  var vchState = VchStates()
  var vchItems = VchItems()


  override def receiveRecover: Receive = {
    case evt: POSEvent =&amp;gt;    //incompleted voucher play back events
      val (vs,vi) =  updateState(evt,vchState,vchItems)
      vchState = vs; vchItems = vi
    case SnapshotOffer(_,vs: VchStates) =&amp;gt; vchState = vs  //restore num,seq ...
  }

  override def receiveCommand: Receive = logOffState

  private def logOffState: Receive = {
    case RunPOSCommand(LogOn(opr, _)) =&amp;gt;
          persistEvent(LogOned(opr,vchState)) { evt =&amp;gt;
            val sts = updateState(evt, vchState, vchItems,lastSequenceNr)
//starting seqenceNr for any voucher. no action logged before login
            vchState = sts._1
            vchItems = sts._2
            sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 用户{$opr}成功登陆。&quot;, vchState, List(vchItems.txnitems.head))
            context.become(logOnState)
          }

    case PassivatePOS =&amp;gt;
      log.info(s&quot;**********${persistenceId} got passivate message and stopping  ... ***********&quot;)
      context.parent ! PoisonPill

    case _ =&amp;gt;
      sender() ! POSResponse(STATUS.FAIL, s&quot;操作失败！终端 ${persistenceId} 用户未登陆。&quot;, vchState, List())
  }


  private def paymentState: Receive = {
    case RunPOSCommand(OfflinePay(acct,num, amount)) =&amp;gt;
           persistEvent(Payment(acct,num,vchState)) { evt =&amp;gt;
             val sts = updateState(evt, vchState, vchItems)
             vchState = sts._1
             vchItems = sts._2
             if (vchItems.totalSales &amp;gt; 0)
               sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}支付。&quot;, vchState, List(vchItems.txnitems.head))
             else
               sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}退款。&quot;, vchState, List(vchItems.txnitems.head))

             if (!vchState.due) {  //completed voucher. mark end of voucher and move next. return to logOnState
               persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
                 val sts = updateState(evt, vchState, vchItems, lastSequenceNr)
                 vchState = sts._1.copy(jseq = lastSequenceNr + 1)
                 vchItems = sts._2
                 saveSnapshot(vchState)     //recovery to next voucher
                 context.unbecome()    //logOnState
               }
             }
             // else wait for other payments and stay in logOnState
           }
 /* strictly disallow any action other than payment till completion
    case RunPOSCommand(VoidAll) =&amp;gt;
      persistEvent(VoidVoucher(vchState)) { _ =&amp;gt;
        persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
          updateState(evt,vchState,vchItems)
          context.unbecome()    //in paymentState, switch to logOnState
        }
      }
    case RunPOSCommand(Suspend) =&amp;gt;
      persistEvent(SuspVoucher(vchState)) { _ =&amp;gt;
        persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
          updateState(evt,vchState,vchItems)
          context.unbecome()    //in paymentState, switch to logOnState
        }
      }
*/
    case RunPOSCommand(SuperOn(su,_)) =&amp;gt;
      persistEvent(SuperOned(su,vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
      }
    case RunPOSCommand(SuperOff) =&amp;gt;
      persistEvent(SuperOffed(vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
      }

    case RunPOSCommand(VCBalance(acct,num,passwd)) =&amp;gt;
      if (POSInterfaces.validateVC(acct,num,passwd)) {
        val res = POSInterfaces.getVCBalance(acct,num)
        if (res.sts == POSInterfaces.VCRESULT.OK)
          sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 储值卡余额{${res.amt}}。&quot;, vchState, List(TxnItem(vchState).copy(
            amount = (res.amt * 100).toInt,
            dpt = acct,
            code = num
          )))
        else
          sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]余额读取错误！[${res.msg}]&quot;, vchState, List())
      } else {
        sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]验证信息错误！&quot;, vchState, List())
      }

    case RunPOSCommand(VCPay(acct,num, passwd,amount)) =&amp;gt;
      if (POSInterfaces.validateVC(acct,num,passwd)) {
        val res = POSInterfaces.getVCBalance(acct,num)
        if (res.sts == POSInterfaces.VCRESULT.OK) {
          if ((res.amt * 100).toInt &amp;lt; amount)
            sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]余额不足！&quot;, vchState,List(TxnItem(vchState).copy(
              amount = (res.amt * 100).toInt,
              dpt = acct,
              code = num
            )))
          else {
            val res = POSInterfaces.payByVC(acct,num,amount/100.00)
            if (res.sts == POSInterfaces.VCRESULT.OK) {
              persistEvent(Payment(acct,num,vchState)) { evt =&amp;gt;
                val sts = updateState(evt, vchState, vchItems)
                vchState = sts._1
                vchItems = sts._2
                if (vchItems.totalSales &amp;gt; 0)
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}支付。&quot;, vchState, List(vchItems.txnitems.head))
                else
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}退款。&quot;, vchState, List(vchItems.txnitems.head))
                if (!vchState.due) {  //completed voucher. mark end of voucher and move next. stay in logOnState
                  persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
                    val sts = updateState(evt, vchState, vchItems,lastSequenceNr)
                    vchState = sts._1
                    vchItems = sts._2
                    saveSnapshot(vchState)     //recovery to next voucher
                    context.unbecome()         //switch to logOnState
                  }
                }
              }

            }
          }

        }
        else
          sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]余额读取错误！[${res.msg}]&quot;, vchState, List())
      } else {
        sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]验证信息错误！&quot;, vchState, List())
      }
    case _ =&amp;gt;
      sender() ! POSResponse(STATUS.FAIL, s&quot;操作失败！终端 ${persistenceId} 结算中不容许其它非支付操作！&quot;, vchState, List(vchItems.txnitems.head))

  }

   private def logOnState: Receive = {
    case RunPOSCommand(LogOff) =&amp;gt;
          persistEvent(LogOffed(vchState)) { evt =&amp;gt;
            val user = vchState.opr
            val sts = updateState(evt,vchState,vchItems)
            vchState = sts._1; vchItems = sts._2
            saveSnapshot(vchState)     //state of last voucher
          //手工passivate         shard ! ShardRegion.Passivate(PassivatePOS)
            sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 用户 $user 成功退出。&quot;, vchState, List(vchItems.txnitems.head))
            context.unbecome()    //switch to logOffState
          }

    case RunPOSCommand(SuperOn(su,_)) =&amp;gt;
      persistEvent(SuperOned(su,vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 转到管理模式{$su}。&quot;, vchState, List(vchItems.txnitems.head))
      }
    case RunPOSCommand(SuperOff) =&amp;gt;
      persistEvent(SuperOffed(vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 退出管理模式。&quot;, vchState, List(vchItems.txnitems.head))
      }
    case RunPOSCommand(RefundOn) =&amp;gt;
      persistEvent(RefundOned(vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 进入退款模式。&quot;, vchState, List(vchItems.txnitems.head))
      }
    case RunPOSCommand(RefundOff) =&amp;gt;
      persistEvent(RefundOffed(vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 退出退款模式。&quot;, vchState, List(vchItems.txnitems.head))
      }
    case RunPOSCommand(VoidOn) =&amp;gt;
      persistEvent(VoidOned(vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 进入取消模式。&quot;, vchState, List(vchItems.txnitems.head))
      }
    case RunPOSCommand(VoidOff) =&amp;gt;
      persistEvent(VoidOffed(vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 退出取消模式。&quot;, vchState, List(vchItems.txnitems.head))
      }
    case RunPOSCommand(MemberOn(cardnum, _)) =&amp;gt;
      persistEvent(MemberOned(cardnum,vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 进入会员模式，卡号{$cardnum}。&quot;, vchState, List(vchItems.txnitems.head))
      }
    case RunPOSCommand(MemberOff) =&amp;gt;
      val cardnum = vchState.mbr
      persistEvent(MemberOffed(vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 退出会员模式，卡号{$cardnum}。&quot;, vchState, List(vchItems.txnitems.head))
      }

    case RunPOSCommand(VoucherNum(tnum)) =&amp;gt;
      val fnum = vchState.num
      persistEvent(VoucherNumed(fnum,tnum)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功设定单号{$fnum -&amp;gt; $tnum}。&quot;, vchState, List())
      }

    case RunPOSCommand(Subtotal) =&amp;gt;
      persistEvent(Subtotaled(vchState,vchItems)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 小计：${vchItems.txnitems.head.price} 条项目。&quot;, vchState, List(vchItems.txnitems.head))
      }
    //first payment in a voucher
    case RunPOSCommand(OfflinePay(acct,num, amount)) =&amp;gt;
      persistEvent(Payment(acct,num,vchState)) { evt =&amp;gt;
        val sts = updateState(evt, vchState, vchItems)
        vchState = sts._1
        vchItems = sts._2
        if (vchItems.totalSales &amp;gt; 0)
          sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}支付。&quot;, vchState, List(vchItems.txnitems.head))
        else
          sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}退款。&quot;, vchState, List(vchItems.txnitems.head))
        if (!vchState.due) {  //completed voucher. mark end of voucher and move next. stay in logOnState
          persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
            val sts = updateState(evt, vchState, vchItems,lastSequenceNr)
            vchState = sts._1
            vchItems = sts._2
            saveSnapshot(vchState)     //recovery to next voucher
          }
        }
        else context.become(paymentState)     //switch into paymentState
      }
    case RunPOSCommand(VCBalance(acct,num,passwd)) =&amp;gt;
      if (POSInterfaces.validateVC(acct,num,passwd)) {
        val res = POSInterfaces.getVCBalance(acct,num)
        if (res.sts == POSInterfaces.VCRESULT.OK)
          sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 储值卡余额{${res.amt}}。&quot;, vchState, List(TxnItem(vchState).copy(
            amount = (res.amt * 100).toInt,
            dpt = acct,
            code = num
          )))
        else
          sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]余额读取错误！[${res.msg}]&quot;, vchState, List())
      } else {
        sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]验证信息错误！&quot;, vchState, List())
      }

    case RunPOSCommand(VCPay(acct,num, passwd,amount)) =&amp;gt;
      if (POSInterfaces.validateVC(acct,num,passwd)) {
        val res = POSInterfaces.getVCBalance(acct,num)
        if (res.sts == POSInterfaces.VCRESULT.OK) {
          if ((res.amt * 100).toInt &amp;lt; amount)
            sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]余额不足！&quot;, vchState,List(TxnItem(vchState).copy(
              amount = (res.amt * 100).toInt,
              dpt = acct,
              code = num
            )))
          else {
            val res = POSInterfaces.payByVC(acct,num,amount/100.00)
            if (res.sts == POSInterfaces.VCRESULT.OK) {
              persistEvent(Payment(acct,num,vchState)) { evt =&amp;gt;
                val sts = updateState(evt, vchState, vchItems)
                vchState = sts._1
                vchItems = sts._2
                if (vchItems.totalSales &amp;gt; 0)
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}支付。&quot;, vchState, List(vchItems.txnitems.head))
                else
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功完成{${vchItems.txnitems.head.category} ${amount/100.0}退款。&quot;, vchState, List(vchItems.txnitems.head))
                if (!vchState.due) {  //completed voucher. mark end of voucher and move next. stay in logOnState
                  persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
                    val sts = updateState(evt, vchState, vchItems,lastSequenceNr)
                    vchState = sts._1
                    vchItems = sts._2
                    saveSnapshot(vchState)     //recovery to next voucher
                  }
                }
                else context.become(paymentState)     //switch into paymentState
              }

            }
          }

        }
        else
          sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]余额读取错误！[${res.msg}]&quot;, vchState, List())
      } else {
        sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 储值卡[$num]验证信息错误！&quot;, vchState, List())
      }

    case RunPOSCommand(VoidAll) =&amp;gt;
      val vnum = vchState.num
      persistEvent(VoidVoucher(vchState)) { _ =&amp;gt;
        persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
          val sts = updateState(evt, vchState, vchItems,lastSequenceNr)
          vchState = sts._1
          vchItems = sts._2
          saveSnapshot(vchState)     //recovery to next voucher
          sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 完成全单取消{${vnum}}。&quot;, vchState, List(vchItems.txnitems.head))
        }
      }
    case RunPOSCommand(Suspend) =&amp;gt;
      val vnum = vchState.num
      persistEvent(SuspVoucher(vchState)) { _ =&amp;gt;
        persistEvent(EndVoucher(vchState.num)) { evt =&amp;gt;
          val sts = updateState(evt, vchState, vchItems,lastSequenceNr)
          vchState = sts._1
          vchItems = sts._2
          saveSnapshot(vchState)     //recovery to next voucher
          sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 完成挂单{${vnum}}。&quot;, vchState, List(vchItems.txnitems.head))
        }
      }



    case RunPOSCommand(LogSales(salesType,sdpt,scode,sqty,sprice)) =&amp;gt; {
      var pqty = 0
      if (vchState.void) {
        vchItems.txnitems.find(ti =&amp;gt; (ti.txntype == TXNTYPE.sales &amp;amp;&amp;amp; ti.salestype == salesType &amp;amp;&amp;amp;
          ti.dpt == sdpt &amp;amp;&amp;amp; ti.code == scode &amp;amp;&amp;amp; ti.qty == sqty &amp;amp;&amp;amp; ti.price == sprice)) match {
          case Some(ti) =&amp;gt; pqty = -ti.qty
          case None =&amp;gt; pqty = sqty
        }
      }
      salesType match {
        case SALESTYPE.plu =&amp;gt;
          getItem(scode) match {
            case QueryItemsOK(items) =&amp;gt;
              val pr = if (sprice &amp;gt; 0) sprice else items.head.price
              val evt = SalesLogged(TxnItem(vchState).copy(
                txntype = if (vchState.void) TXNTYPE.void else TXNTYPE.sales,
                salestype = salesType,
                price = pr,
                qty = pqty,
                amount = pr * pqty,
                code = scode,
                desc = items.head.name,
                dpt = items.head.dpt,
                cat = items.head.cat,
                brd = items.head.brd,
                department = (getDpt(items.head.dpt).getOrElse(Department(&quot;&quot;, &quot;&quot;))).name,
                category = (getCat(items.head.brd).getOrElse(Category(&quot;&quot;, &quot;&quot;))).name,
                brand = (getBrd(items.head.brd).getOrElse(Brand(&quot;&quot;, &quot;&quot;))).name
              ))
              persistEvent(evt) { evt =&amp;gt;
                val sts = updateState(evt, vchState, vchItems)
                vchState = sts._1
                vchItems = sts._2
                if (vchState.void) {
                  vchItems = vchItems.copy(
                    txnitems = vchItems.txnitems.map { ti =&amp;gt;
                      if (ti.txntype == TXNTYPE.sales &amp;amp;&amp;amp; ti.salestype == salesType &amp;amp;&amp;amp;
                        ti.dpt == sdpt &amp;amp;&amp;amp; ti.code == scode &amp;amp;&amp;amp; ti.qty == sqty &amp;amp;&amp;amp; ti.price == sprice)
                        ti.copy(txntype = TXNTYPE.voided)
                      else
                        ti
                    })
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功冲销商品销售。&quot;, vchState, List(vchItems.txnitems.head))
                } else {
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 商品销售操作成功。&quot;, vchState, List(vchItems.txnitems.head))
                }

              }
            case QueryItemsFail(msg) =&amp;gt;
              sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 商品编号错误！[$msg]&quot;, vchState, List())
          }
        case SALESTYPE.dpt =&amp;gt;
          validateDpt(sdpt) match {
            case Some(dpt) =&amp;gt;
              val evt = SalesLogged(TxnItem(vchState).copy(
                txntype = if (vchState.void) TXNTYPE.void else TXNTYPE.sales,
                salestype = salesType,
                price = sprice,
                qty = pqty,
                amount = sprice * pqty,
                dpt = sdpt,
                department = dpt.name
              ))
              persistEvent(evt) { evt =&amp;gt;
                val sts = updateState(evt, vchState, vchItems)
                vchState = sts._1
                vchItems = sts._2
                if (vchState.void) {
                  vchItems = vchItems.copy(
                    txnitems = vchItems.txnitems.map { ti =&amp;gt;
                      if (ti.txntype == TXNTYPE.sales &amp;amp;&amp;amp; ti.salestype == salesType &amp;amp;&amp;amp;
                        ti.dpt == sdpt &amp;amp;&amp;amp; ti.code == scode &amp;amp;&amp;amp; ti.qty == sqty &amp;amp;&amp;amp; ti.price == sprice)
                        ti.copy(txntype = TXNTYPE.voided)
                      else
                        ti
                    })
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功冲销部门销售。&quot;, vchState, List(vchItems.txnitems.head))
                } else {
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 部门销售操作成功。&quot;, vchState, List(vchItems.txnitems.head))
                }
              }
            case None =&amp;gt;
              sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 部门编号[$sdpt]错误！&quot;, vchState, List())
          }
        case SALESTYPE.brd =&amp;gt;
          validateBrd(sdpt) match {
            case Some(brd) =&amp;gt;
              val evt = SalesLogged(TxnItem(vchState).copy(
                txntype = if (vchState.void) TXNTYPE.void else TXNTYPE.sales,
                salestype = salesType,
                price = sprice,
                qty = pqty,
                amount = sprice * pqty,
                brd = sdpt,
                brand = brd.name
              ))
              persistEvent(evt) { evt =&amp;gt;
                val sts = updateState(evt, vchState, vchItems)
                vchState = sts._1
                vchItems = sts._2
                if (vchState.void) {
                  vchItems = vchItems.copy(
                    txnitems = vchItems.txnitems.map { ti =&amp;gt;
                      if (ti.txntype == TXNTYPE.sales &amp;amp;&amp;amp; ti.salestype == salesType &amp;amp;&amp;amp;
                        ti.dpt == sdpt &amp;amp;&amp;amp; ti.code == scode &amp;amp;&amp;amp; ti.qty == sqty &amp;amp;&amp;amp; ti.price == sprice)
                        ti.copy(txntype = TXNTYPE.voided)
                      else
                        ti
                    })
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功冲销品牌销售。&quot;, vchState, List(vchItems.txnitems.head))
                } else {
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 品牌销售操作成功。&quot;, vchState, List(vchItems.txnitems.head))
                }
              }
            case None =&amp;gt;
              sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 品牌编号[$sdpt]错误！&quot;, vchState, List())
          }
        case SALESTYPE.cat =&amp;gt;
          validateCat(sdpt) match {
            case Some(cat) =&amp;gt;
              val evt = SalesLogged(TxnItem(vchState).copy(
                txntype = if (vchState.void) TXNTYPE.void else TXNTYPE.sales,
                salestype = salesType,
                price = sprice,
                qty = pqty,
                amount = sprice * pqty,
                cat = sdpt,
                category = cat.name
              ))
              persistEvent(evt) { evt =&amp;gt;
                val sts = updateState(evt, vchState, vchItems)
                vchState = sts._1
                vchItems = sts._2
                if (vchState.void) {
                  vchItems = vchItems.copy(
                    txnitems = vchItems.txnitems.map { ti =&amp;gt;
                      if (ti.txntype == TXNTYPE.sales &amp;amp;&amp;amp; ti.salestype == salesType &amp;amp;&amp;amp;
                        ti.dpt == sdpt &amp;amp;&amp;amp; ti.code == scode &amp;amp;&amp;amp; ti.qty == sqty &amp;amp;&amp;amp; ti.price == sprice)
                        ti.copy(txntype = TXNTYPE.voided)
                      else
                        ti
                    })
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功冲销分类销售。&quot;, vchState, List(vchItems.txnitems.head))
                } else {
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 分类销售操作成功。&quot;, vchState, List(vchItems.txnitems.head))
                }
              }
            case None =&amp;gt;
              sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 分类编号[$sdpt]错误！&quot;, vchState, List())
          }
        case SALESTYPE.ra =&amp;gt;
          validateCat(sdpt) match {
            case Some(ra) =&amp;gt;
              val evt = SalesLogged(TxnItem(vchState).copy(
                txntype = if (vchState.void) TXNTYPE.void else TXNTYPE.sales,
                salestype = salesType,
                price = sprice,
                qty = pqty,
                amount = sprice * pqty,
                dpt = sdpt,
                code = scode,
                department = ra.name
              ))
              persistEvent(evt) { evt =&amp;gt;
                val sts = updateState(evt, vchState, vchItems)
                vchState = sts._1
                vchItems = sts._2
                if (vchState.void) {
                  vchItems = vchItems.copy(
                    txnitems = vchItems.txnitems.map { ti =&amp;gt;
                      if (ti.txntype == TXNTYPE.sales &amp;amp;&amp;amp; ti.salestype == salesType &amp;amp;&amp;amp;
                        ti.dpt == sdpt &amp;amp;&amp;amp; ti.code == scode &amp;amp;&amp;amp; ti.qty == sqty &amp;amp;&amp;amp; ti.price == sprice)
                        ti.copy(txntype = TXNTYPE.voided)
                      else
                        ti
                    })
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 成功冲销代收。&quot;, vchState, List(vchItems.txnitems.head))
                } else {
                  sender() ! POSResponse(STATUS.OK, s&quot;终端-$persistenceId： 代收操作成功。&quot;, vchState, List(vchItems.txnitems.head))
                }
              }
            case None =&amp;gt;
              sender() ! POSResponse(STATUS.FAIL, s&quot;终端-$persistenceId： 代收编号[$sdpt]错误！&quot;, vchState, List())
          }

      }
    }

  }



}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;POSDataAccess.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;115&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
package pos.dao

import java.time.LocalDate
import java.time.format.DateTimeFormatter


case class Item(
                 brd: String
                 ,dpt: String
                 ,cat: String
                 ,code: String
                 ,name: String
                 ,price: Int

               )
object Items {
  val apple = Item(&quot;01&quot;,&quot;02&quot;,&quot;01&quot;,&quot;001&quot;, &quot;green apple&quot;, 820)
  val grape = Item(&quot;01&quot;,&quot;02&quot;,&quot;01&quot;,&quot;002&quot;, &quot;red grape&quot;, 1050)
  val orage = Item(&quot;01&quot;,&quot;02&quot;,&quot;01&quot;,&quot;003&quot;, &quot;sunkist orage&quot;, 350)
  val banana = Item(&quot;01&quot;,&quot;02&quot;,&quot;01&quot;,&quot;004&quot;, &quot;demon banana&quot;, 300)
  val pineapple = Item(&quot;01&quot;,&quot;02&quot;,&quot;01&quot;,&quot;005&quot;, &quot;hainan pineapple&quot;, 1300)
  val peach = Item(&quot;01&quot;,&quot;02&quot;,&quot;01&quot;,&quot;006&quot;, &quot;xinjiang peach&quot;, 2390)

  val tblItems = List(apple, grape, orage, banana, pineapple, peach)

  sealed trait QueryItemsResult {}

  case class QueryItemsOK(items: List[Item]) extends QueryItemsResult

  case class QueryItemsFail(msg: String) extends QueryItemsResult

}


object Codes {
  case class User(code: String, name: String, passwd: String)
  case class Department(code: String, name: String)
  case class Category(code: String, name: String)
  case class Brand(code: String, name: String)
  case class Ra(code: String, name: String)
  case class Account(code: String, name: String)
  case class Disc(code: String, best: Boolean, aggr: Boolean, group: Boolean)

  val ras = List(Ra(&quot;01&quot;,&quot;Delivery&quot;),Ra(&quot;02&quot;,&quot;Cooking&quot;))
  val dpts = List(Department(&quot;01&quot;,&quot;Fruit&quot;),Department(&quot;02&quot;,&quot;Grocery&quot;))
  val cats = List(Category(&quot;0101&quot;,&quot;Fresh Fruit&quot;),Category(&quot;0201&quot;,&quot;Dry Grocery&quot;))
  val brds = List(Brand(&quot;01&quot;,&quot;Sunkist&quot;),Brand(&quot;02&quot;,&quot;Demon&quot;))
  val accts = List(Account(&quot;001&quot;,&quot;Cash&quot;),Account(&quot;002&quot;,&quot;Value Card&quot;), Account(&quot;003&quot;, &quot;Visa&quot;)
    ,Account(&quot;004&quot;,&quot;Alipay&quot;),Account(&quot;005&quot;,&quot;WXPay&quot;))

  val users = List(User(&quot;1001&quot;,&quot;Tiger&quot;, &quot;123&quot;),User(&quot;1002&quot;,&quot;John&quot;, &quot;123&quot;),User(&quot;1003&quot;,&quot;Maria&quot;, &quot;123&quot;))

  def getDpt(code: String) = dpts.find(d =&amp;gt; d.code == code)
  def getCat(code: String) = cats.find(d =&amp;gt; d.code == code)
  def getBrd(code: String) = brds.find(b =&amp;gt; b.code == code)
  def getAcct(code: String) = accts.find(a =&amp;gt; a.code == code)
  def getRa(code: String) = ras.find(a =&amp;gt; a.code == code)
}

object DAO {
  import Items._
  import Codes._

  def getItem(code: String): QueryItemsResult = {
    val optItem = tblItems.find(it =&amp;gt; it.code == code)
    optItem match {
      case Some(item) =&amp;gt; QueryItemsOK(List(item))
      case None =&amp;gt; QueryItemsFail(&quot;Invalid item code!&quot;)
    }
  }

  def validateDpt(code: String) = dpts.find(d =&amp;gt; d.code == code)
  def validateCat(code: String) = cats.find(d =&amp;gt; d.code == code)
  def validateBrd(code: String) = brds.find(b =&amp;gt; b.code == code)
  def validateRa(code: String) = ras.find(ac =&amp;gt; ac.code == code)
  def validateAcct(code: String) = accts.find(ac =&amp;gt; ac.code == code)

  def validateUser(userid: String, passwd: String) = users.find(u =&amp;gt; (u.code == userid &amp;amp;&amp;amp; u.passwd == passwd))

  def lastSecOfDateStr(ldate: LocalDate): String = {
    ldate.format(DateTimeFormatter.ofPattern( &quot;yyyy-MM-dd&quot;))+&quot; 23:59:59&quot;
  }


}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ClusterMonitor.scala&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
package pos.cluster

import akka.actor._
import akka.cluster.ClusterEvent._
import akka.cluster._
import sdp.logging.LogSupport

class ClusterMonitor extends Actor with LogSupport {
  val cluster = Cluster(context.system)
  override def preStart(): Unit = {
    cluster.subscribe(self,initialStateMode = InitialStateAsEvents
      ,classOf[MemberEvent],classOf[UnreachableMember])  //订阅集群状态转换信息
    super.preStart()
  }

  override def postStop(): Unit = {
    cluster.unsubscribe(self)    //取消订阅
    super.postStop()
  }

  override def receive: Receive = {
    case MemberJoined(member) =&amp;gt;
      log.info(s&quot;Member is Joining: {${member.address}}&quot;)
    case MemberUp(member) =&amp;gt;
      log.info(s&quot;Member is Up: {${member.address}}&quot;)
    case MemberLeft(member) =&amp;gt;
      log.info(s&quot;Member is Leaving: {${member.address}}&quot;)
    case MemberExited(member) =&amp;gt;
      log.info(s&quot;Member is Exiting: {${member.address}}&quot;)
    case MemberRemoved(member, previousStatus) =&amp;gt;
      log.info(
        s&quot;Member is Removed: {${member.address}} after {${previousStatus}&quot;)
    case UnreachableMember(member) =&amp;gt;
      log.info(s&quot;Member detected as unreachable: {${member.address}}&quot;)
      cluster.down(member.address)      //手工驱除，不用auto-down
    case _: MemberEvent =&amp;gt; // ignore
  }

}
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sat, 30 Mar 2019 01:47:00 +0000</pubDate>
<dc:creator>雪川大虫</dc:creator>
<og:description>我觉着，CQRS的写部分最核心、最复杂的部分应该是Writer-Actor了。其它的监管（supervising）、分片部署等都比较规范，没太多的变动。几乎Writer-Actor所有的业务逻辑都在R</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/tiger-xc/p/10622046.html</dc:identifier>
</item>
<item>
<title>记一次生产请求耗时的问题 - 飞翔码农</title>
<link>http://www.cnblogs.com/feixiangmanon/p/10625227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixiangmanon/p/10625227.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;最近发现lb上记录的request_time比upstream_response_time大的比较多，例如upstream_response_time记录是0.062，request_time记录的就是5.064等等。整个耗时很反常。而且出现这个问题基本上都是一个返回值比较大的接口，基本上返回值是100K左右。领导让定位一下这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先说下我们的架构的背景，是这样的&lt;br/&gt;&lt;strong&gt;阿里云的SLB-------我们自己的LB----------WEB机器&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;定位方向错误&quot;&gt;定位方向错误&lt;/h3&gt;
&lt;p&gt;跟踪这个问题之后，一直觉得 LB上记录的upstream_response_time的时间有问题，个人觉得100K的请求0.0xx秒无法完成，从这个入口查了一段时间，没有任何结果。当然也是收获的，协助WEB的同事发现有些请求的CACHE没有使用上。后来觉得应该钻牛角了，第一个Nginx的upstream_response_time肯定是没有问题的；第二个LB到WEB是都是内网访问，快是必然的。后来抓包也确实证明了LB到WEB特别快，upstream_response_time的时间是正确无误的。&lt;/p&gt;
&lt;h4 id=&quot;nagle-算法的问题&quot;&gt;Nagle 算法的问题？&lt;/h4&gt;
&lt;p&gt;排除掉upstream_response_time记录错误之后，一直没有发现。就看了些资料，学习了下课程。看了下极客时间&lt;br/&gt;Linux性能优化实战 课程，40 | 案例篇：网络请求延迟变大了，我该怎么办？&lt;br/&gt;看完之后，觉得可能真的是Nagle 算法的问题。解释下Nagle 算法，Nagle 算法，是 TCP 协议中用于减少小包发送数量的一种优化算法，目的是为了提高实际带宽的利用率。大概意思就是，合并TCP的小包，提高网络带宽的利用率。觉得可能是Nagle 算法的问题，就把一台LB的tcp_nodelay 打开了几小时，发现问题依然存在。那基本就排除Nagle 算法的问题。&lt;br/&gt;后来仔细琢磨了一下，跟Nagle 算法应该没有关系，Nagle 算法的延迟是40ms才对，我们这个基本上是5秒。&lt;/p&gt;
&lt;h4 id=&quot;lingering-close-的问题&quot;&gt;lingering close 的问题&lt;/h4&gt;
&lt;p&gt;排除掉Nagle 算法的问题之后，又没有任何方向了。不知道怎么追查了。后来又抓包查看，没有发现有价值的线索。但是确定没有延迟4秒的，都是延迟5秒的。这是一个特别重要的线索。当时觉得应该有一个默认的配置是5秒。&lt;a href=&quot;http://nginx.org/en/docs/http/ngx_http_core_module.html#&quot; class=&quot;uri&quot;&gt;http://nginx.org/en/docs/http/ngx_http_core_module.html#&lt;/a&gt;&lt;br/&gt;nginx http_core_module里面搜索下5s，发现了lingering_timeout 5s; lingering_timeout是个什么鬼？后来找到一篇跟我们很类似的问题的文章。文章里面很详细的解释了lingering_timeout。&lt;br/&gt;&lt;a href=&quot;http://shibing.github.io/2016/11/18/nginx%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%85%B3%E9%97%AD-lingering-close/&quot;&gt;http://shibing.github.io/2016/11/18/nginx%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%85%B3%E9%97%AD-lingering-close/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下面的这些解释都来自上面的文章&lt;br/&gt;该问题是由 Nginx 的延迟关闭（lingering close）连接导致的。Nginx 为了能够平滑关闭连接，采用了延迟关闭，它的工作方式如下：Nginx 在给客户端发送完最后一个数据包后会首先关闭 TCP 连接的写端（TCP 是全双工协议，任何一端都即可读也可写），表示服务端不会再向客户端发送任何数据，但是不会立即关闭 TCP 连接的读端，而是等待一个超时，在超时到达后如果客户端还没有数据发来，Nginx 才会关闭TCP的读端，从而关闭整个连接，然后再输出日志。另一方面，Nginx 是在关闭连接后才输出日志，所以在输出日志之前响应早就发送给了用户，因此对业务几乎没有影响。但是这也会导致 requset_time 值变得不准确，使其失去统计意义，开启 Keep-Alive 可以部分解决这一问题。&lt;/p&gt;
&lt;p&gt;在 Nginx 发送完数据包并进入延迟关闭连接流程后，如果客户端在 lingering_timeout 时间内没有进行任何操作，那么就会关闭与客户端的连接然后输出日志，这就会导致导致访问日志滞后 lingering_timeout 才输出。我们线上并没有对该参数进行配置，那么会采用默认值，正好是5秒，与实际情况吻合。另外如果使用长连接，Nignx 在请求结束后不需要关闭连接而直接输出日志，那么就不会有这个问题，这也就解释了为什么开启 Keep-Alive 后问题消失。&lt;/p&gt;
&lt;p&gt;基本上是可以确定是lingering_timeout的问题，把生产的一台的lingering_timeout的参数改为4s，发现5s的消失，4s的出现。知道这个原因之后，就能确定，其实真正的耗时有可能是2S 3S，只不过延迟关闭了，写日志的时间是5S。文章也介绍了只要客户端设置keep-alive长连接，Nginx就不会关闭连接，写日志时间就会快很多。但是阿里云的SLB不能开启长连接，因为这个问题，对我们来说是无解的，我们可以将lingering_timeout设置短一点，但是延时关闭的问题是不可避免的。好在是我们知道了原因，并不是真正的处理慢了，只不过是延时关闭导致日志时间有误。&lt;/p&gt;
&lt;p&gt;------------------------------------end&lt;br/&gt;一起学习后端技术，关注公众号&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1557931/201903/1557931-20190330083400278-527849835.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 30 Mar 2019 00:34:00 +0000</pubDate>
<dc:creator>飞翔码农</dc:creator>
<og:description>最近发现lb上记录的request_time比upstream_response_time大的比较多，例如upstream_response_time记录是0.062，request_time记录的就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/feixiangmanon/p/10625227.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 共享第三方依赖库部署的正常打开方式 - 路过秋天</title>
<link>http://www.cnblogs.com/cyq1162/p/10625151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cyq1162/p/10625151.html</guid>
<description>&lt;p&gt;写了一篇：&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/cyq1162/p/10542832.html&quot;&gt;ASP.Net Core on Linux (CentOS7) 共享第三方依赖库部署&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当第二次想做相同的事，却遇上了Bug，于是有了第二篇：&lt;/p&gt;
&lt;p&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/cyq1162/p/10612508.html&quot;&gt;ASP.NET Core 共享第三方依赖库部署的Bug(*.deps.json on 2.2.0 or 4.6.0 版本)&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;就报告到Github上去了，来来回回和人家交涉了几天：&lt;/p&gt;

&lt;p&gt;截几个图，给大伙学习一下英文：&lt;/p&gt;
&lt;p&gt;我以强悍的中英文双版提交了问题：&lt;/p&gt;
&lt;h2&gt;Steps to reproduce&lt;/h2&gt;
&lt;p&gt;I try to put the Microsoft.&lt;em&gt;.dll and System.&lt;/em&gt;.dll togather to a new folder.&lt;br/&gt;以便把(第三方或）系统的和应用的dll分开。&lt;br/&gt;之前花了很长的一段时间研究之后：&lt;br/&gt;I find xxx.deps.json can make it work.&lt;br/&gt;之后我还特意写了篇文章介绍它：&lt;a href=&quot;https://www.cnblogs.com/cyq1162/p/10542832.html&quot; rel=&quot;nofollow&quot;&gt;https://www.cnblogs.com/cyq1162/p/10542832.html&lt;/a&gt;&lt;br/&gt;but today,when i update the Microsoft. Aspnetcore to 2.2.0 version.&lt;br/&gt;it dose not work, and make me crazy.&lt;/p&gt;
&lt;p&gt;because it always show me the msg like this:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;F:\Code\OpenSource\Aries-GitHub\trunk\Aries.DevFramework\Web.UI_NetCore\bin\Rele ase\PublishOutput&amp;gt;dotnet Web.UI.dll Error: **An assembly specified in the application dependencies manifest (Web.UI.deps.js on) was not found**: package: 'Microsoft.AspNetCore.Authentication.Abstractions', version: '2.2.0 ' path: 'lib/netstandard2.0/Microsoft.AspNetCore.Authentication.Abstractions.d ll'&lt;/code&gt;&lt;br/&gt;and the json like this:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;Microsoft.AspNetCore.Authentication.Abstractions/2.2.0&quot;: {
        &quot;dependencies&quot;: {
          &quot;Microsoft.AspNetCore.Http.Abstractions&quot;: &quot;2.2.0&quot;,
          &quot;Microsoft.Extensions.Logging.Abstractions&quot;: &quot;2.2.0&quot;,
          &quot;Microsoft.Extensions.Options&quot;: &quot;2.2.0&quot;
        },
        &quot;runtime&quot;: {
          &quot;lib/netstandard2.0/Microsoft.AspNetCore.Authentication.Abstractions.dll&quot;: {
            &quot;fileVersion&quot;: &quot;2.2.0.18316&quot;
          }
        }
      }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我花了N长的时间在检测配置和确定路径的正确性，但结果，却依旧很悲催。&lt;br/&gt;it take me much time to find out the question what it's.&lt;br/&gt;when i try to maike it like this:&lt;br/&gt;Microsoft.AspNetCore.Authentication.Abstractions&lt;br/&gt;Microsoft.AspNetCore.Authentication.Abstractions/2.2.xxx&lt;br/&gt;it work.&lt;br/&gt;就是这样，只要版本号不是2.2.0，它就一切正常。&lt;br/&gt;之后又几次测试，发现版本号是4.6.0也同样有问题。&lt;br/&gt;and then i find the version on /4.6.0 ,it does not work also.&lt;br/&gt;就是这样，版本号三位数，尾数是0的，就提示找不到dll。&lt;br/&gt;how ugly this bug it's.&lt;/p&gt;
&lt;p&gt;中英文双语版汇报之后，老外回消息了，它估计看到中文就头大：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330044450156-2000437026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我看了半天，也是一脸头大，于是，我努力再描述一下问题，并打算用截图说明问题：&lt;/p&gt;
&lt;p&gt;ok,i try it again.&lt;br/&gt;1、I have a mvc website：&lt;a href=&quot;http://mvc.taurus.cyqdata.com/&quot; rel=&quot;nofollow&quot;&gt;http://mvc.taurus.cyqdata.com&lt;/a&gt;, it run on CentOS7，at first it deploy like this :&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/2a951962b186abf491a1a5e39695d5163b1675bf/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383138353533313238382d39373131363638302e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/2a951962b186abf491a1a5e39695d5163b1675bf/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383138353533313238382d39373131363638302e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328185531288-97116680.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;and now it make it like this by *.deps.json:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/b0c11b9cbfc3319a153b9236092ad644e30959c7/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383138353035323539382d323037383838343138382e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/b0c11b9cbfc3319a153b9236092ad644e30959c7/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383138353035323539382d323037383838343138382e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328185052598-2078884188.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;I put the Microsoft.xxx.dll or System.xxx.dll to another folder like package.&lt;br/&gt;how I do that ? I replace all the path lib/netstardardxxxx to my path.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/713d2d9a613b672624216ba19f9ac394b9e78bb2/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383139303735343139322d3730383838313338392e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/713d2d9a613b672624216ba19f9ac394b9e78bb2/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383139303735343139322d3730383838313338392e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328190754192-708881389.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;so it work well at Microsoft.AspNetCore.All 2.0.3 version.&lt;br/&gt;but my question is ：when i update to 2.2.0 version，it dose not work.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/7a662bc172d68cb9afe705aed043304f49a77657/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383139303932303233382d313637323630323732382e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/7a662bc172d68cb9afe705aed043304f49a77657/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383139303932303233382d313637323630323732382e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328190920238-1672602728.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;if i change the version to anything like 2.2.x,it will work well.&lt;br/&gt;I find it have the same bug on linux and windows. now ,you kown what i say ?&lt;/p&gt;
&lt;p&gt;忙碌中，对方又回了一条消息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330044641735-1586855358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;他说他随便折腾一下，没发现问题啊。&lt;/p&gt;
&lt;p&gt;我能怎么办？只能把demo双手奉上：&lt;/p&gt;
&lt;p&gt;OK，I try it again.&lt;br/&gt;I make a SourceCode and Demo,you can download on (5M) : &lt;a href=&quot;http://mvc.taurus.cyqdata.com/WebPublish.rar&quot; rel=&quot;nofollow&quot;&gt;http://mvc.taurus.cyqdata.com/WebPublish.rar&lt;/a&gt;&lt;br/&gt;unrar and &quot;dotnet Taurus.View.dll&quot; on cmd，you will get the error message like:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/31e6c3a5637ac8c38afcdb264bb0e32a6e1ae6d9/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383232333630383232372d323037323531323936382e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/31e6c3a5637ac8c38afcdb264bb0e32a6e1ae6d9/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383232333630383232372d323037323531323936382e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328223608227-2072512968.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;and you replace 2.2.0 to 2.2.1 at Taurus.View.deps.json like this,and run again,it will be ok.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://camo.githubusercontent.com/98df0acbb4447bd17bd2b439ddae125dbb8c13de/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383232333832303834332d323032343139323339342e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/98df0acbb4447bd17bd2b439ddae125dbb8c13de/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383232333832303834332d323032343139323339342e706e67&quot; alt=&quot;&quot; data-canonical-src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190328223820843-2024192394.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;you you need the source code for building, you can download on (917K) : http://mvc.taurus.cyqdata.com/SourceCode.rar&lt;/p&gt;
&lt;p&gt; 对方告诉我，没啥问题，本来就是找不到路径文件，另外至于改版本号就变好了的问题，可能真是个bug，然后给我推荐升级到2.2版本：&lt;/p&gt;
&lt;p&gt;Thanks a lot.&lt;/p&gt;
&lt;p&gt;The immediate failure is caused by a missing file. The &lt;code&gt;Microsoft.AspNetCore.Authentication.Abstraction.dll&lt;/code&gt; is in fact not there. So it fails correctly.&lt;/p&gt;
&lt;p&gt;If you change the version you effectively corrupt the &lt;code&gt;.deps.json&lt;/code&gt;. The entire string &lt;code&gt;Microsoft.AspNetCore.Authentication.Abstraction/2.2.0&lt;/code&gt; is a package identifier, which should exist in the &lt;code&gt;libraries&lt;/code&gt; section near the end of the &lt;code&gt;.deps.json&lt;/code&gt; file. As is the package section exists. If you change the version it won't find the package. I guess it's a bug that it won't fail in that case, in fact it simply ignores the assembly if it can't find the matching package section. This is definitely not expected, but I doubt we can fix it (if somebody relies on this behavior we would break them).&lt;/p&gt;
&lt;p&gt;The app runs without the assembly just fine, at least the startup as I assume it doesn't need it. If it would run into code which needs it, it would fail at runtime.&lt;/p&gt;
&lt;p&gt;Note that when I built it from source, it worked without any modifications (as the file was present).&lt;/p&gt;
&lt;p&gt;As for the number of additional files in the app. I took your solution, changed all projects to target netcoreapp2.2 (since you're trying to use ASP.NET Core 2.2, it makes sense to target 2.2 for everything). And then I added this line to the &lt;code&gt;Taurus.View_NetCore.csproj&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlight highlight-text-xml&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
  &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;ItemGroup&amp;gt;
    &amp;lt;&lt;span class=&quot;pl-ent&quot;&gt;PackageReference &lt;span class=&quot;pl-e&quot;&gt;Include=&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&quot;Microsoft.AspNetCore.App&lt;span class=&quot;pl-pds&quot;&gt;&quot; /&amp;gt;
  &amp;lt;/&lt;span class=&quot;pl-ent&quot;&gt;ItemGroup&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now when I publish the solution, I get only about 20 files in the output. Basically just the application plus 2 additional System.* assemblies.&lt;/p&gt;
&lt;p&gt;我感觉它没发现我说的重点，于是用翻译快速上了一段文字：&lt;/p&gt;
&lt;p&gt;To facilitate the presentation of the problem,&lt;br/&gt;I put Microsoft. AspNetCore. Authentication. Abstraction. dll in the Lib directory, and then the path of the configuration file was modified to point to it, so the file is supposed to exist, even if it is not used in the project, but the direction of the path is right, I don't know if you notice it.&lt;/p&gt;
&lt;p&gt;Version number is no problem, after all, it is automatically generated by the system.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;In addition, the 2.2.0 I mentioned above refers to the Nuget version package of ASPNET Core. It is not. NetApp version upgraded to 2.2. App version is still using 2.1.&lt;/p&gt;
&lt;p&gt;对方开始慒B了，说了一堆，然后还是推荐我上2.2版本：&lt;/p&gt;
&lt;p&gt;I'm sorry - I don't understand your comment about the version number not being a problem. It is by design that the run fails if &lt;code&gt;.deps.json&lt;/code&gt; refers to a file which it can't find, so in your repro, the fact that it fails is expected.&lt;br/&gt;I do agree that the fact that if the version number is changed (and thus doesn't match the package in the libraries section) the run will simply ignore the problem and the file and just continue is a bug. I have my doubts we would fix it though as it might break people.&lt;br/&gt;By doing this the &lt;code&gt;.deps.json&lt;/code&gt; becomes invalid, and the current error checking is somewhat simplistic on &lt;code&gt;.deps.json&lt;/code&gt; - this is basically expected, as the &lt;code&gt;.deps.json&lt;/code&gt; is not meant to be used by humans - it is meant to be machine generated, and thus it's reasonable to expect correct input.&lt;/p&gt;
&lt;p&gt;As for ASPNET Core versioning - I'm honestly surprised you can even run ASP.NET 2.2 on .NET Core 2.1, but I'm no expert in ASP.NET deployment.&lt;/p&gt;
&lt;p&gt;To explain why you get so many files in the output:&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;Normally .NET Core apps rely on &quot;shared frameworks&quot; which live in the global installed location. These are referenced from the &lt;code&gt;.runtimeconfig.json&lt;/code&gt;. You can see that your app references &lt;code&gt;Microsoft.NETCore.App&lt;/code&gt; there, which is the root framework (contains CoreCLR and CoreFX).&lt;/li&gt;
&lt;li&gt;ASP.NET itself contains lot of assemblies. Again by default this will be recognized as a &quot;shared framework&quot; and you would get a reference to &lt;code&gt;Microsoft.AspNet.Core.App&lt;/code&gt; in your &lt;code&gt;.runtimeconfig.json&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If one of the referenced shared frameworks contains the required assembly, then that assembly is not included in the output of the app. So by default you don't get pretty much any &quot;Microsoft.&lt;em&gt;&quot; or &quot;System.&lt;/em&gt;&quot; assemblies in the app as those are all in the shared frameworks.&lt;/li&gt;
&lt;li&gt;In your case I can only assume the build system is confused a bit - you require ASPNET Core 2.2 on .NET Core 2.1. Since no such shared framework exists, it probably just brings all the ASP.NET assemblies into the app. By migrating all projects to .NET Core 2.2 you give the build system a way to rely on shared frameworks instead. For some reason the PackageReference to ASPNET also has to be in the main project for this to work (no idea why).&lt;/li&gt;
&lt;li&gt;Once that is done, your app should have a reference to &lt;code&gt;Microsoft.AspNet.Core.App&lt;/code&gt; version 2.2 which in turn has a reference to &lt;code&gt;Microsoft.NETCore.App&lt;/code&gt; version 2.2. And so the build system will be able to avoid all the system assemblies in the app and solely rely on the shared frameworks.&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;我感觉这问题似乎要无解，又要重新描述问题了：&lt;/p&gt;
&lt;p&gt;i mean,when you down from &lt;a href=&quot;http://mvc.taurus.cyqdata.com/WebPublish.rar&quot; rel=&quot;nofollow&quot;&gt;http://mvc.taurus.cyqdata.com/WebPublish.rar&lt;/a&gt;&lt;br/&gt;and unrar , you will find lib/Microsoft. AspNetCore. Authentication. Abstraction. dll and this dll version is 2.2.0. the file is exists.&lt;br/&gt;and the Taurus.View.deps.json , you look,it point to the same path.&lt;br/&gt;&lt;a href=&quot;https://camo.githubusercontent.com/98df0acbb4447bd17bd2b439ddae125dbb8c13de/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383232333832303834332d323032343139323339342e706e67&quot; rel=&quot;noopener noreferrer&quot; target=&quot;_blank&quot;&gt;&lt;img src=&quot;https://camo.githubusercontent.com/98df0acbb4447bd17bd2b439ddae125dbb8c13de/68747470733a2f2f696d67323031382e636e626c6f67732e636f6d2f626c6f672f31373430382f3230313930332f31373430382d32303139303332383232333832303834332d323032343139323339342e706e67&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;br/&gt;so,tell me ,why can't find it ,the related path is error ? &lt;/p&gt;
&lt;p&gt;这此，对方终于知道我要表达或关注点在什么地方了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330045621608-233630530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不过它始终没Get到我的点，或者我没有Get到它的点，我只能强调，我上一版本V2.0.3是OK的，要不要弄个正常的Demo过去？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330045807192-1444795170.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;它想让我把正常的.runtimeconfig.json文件发给它看看&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330045908286-137491800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;于是，我转身向服务器走去，我Down下了2.0.3那个运行正常的runtimeconfig.json文件，打开一看，what X，什么时候多了一行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330050124362-772790316.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这不是我当年研究失败时留下的东西么，难道它是关键？&lt;/p&gt;
&lt;p&gt;于是通过把这个属性加上和关掉，重新运行了一下，XYZ，还真是它的问题，&lt;span&gt;&lt;strong&gt;只有配置了这个路径，deps.json上的路径才能生效&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;

&lt;p&gt;感觉要分手了，给它回了最后一段话：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330050342432-2033732094.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;好聚好散，但它还是坚持让我升级到NetCore 2.2版本：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/17408/201903/17408-20190330050432221-1169776643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 交涉地址：&lt;a href=&quot;https://github.com/dotnet/core-setup/issues/5588&quot;&gt;https://github.com/dotnet/core-setup/issues/5588&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最后，发现在Github留下问题，还是有点乐趣的~~~&lt;/p&gt;
</description>
<pubDate>Fri, 29 Mar 2019 21:16:00 +0000</pubDate>
<dc:creator>路过秋天</dc:creator>
<og:description>通过在Github上几天的交流，这个Bug的问题，终于找到关键的点了，今天就给大伙说说~~~</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cyq1162/p/10625151.html</dc:identifier>
</item>
</channel>
</rss>