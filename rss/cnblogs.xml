<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>VMware 虚拟机开机黑屏解决方法 - bajie_new</title>
<link>http://www.cnblogs.com/zhoulangshunxinyangfan/p/13407691.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhoulangshunxinyangfan/p/13407691.html</guid>
<description>&lt;p&gt;# 调整VMware硬盘启动优先级&lt;/p&gt;

&lt;p&gt;第一步：打开电源时进入固件，也就是BIOS 设置界面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1793280/202007/1793280-20200731080951287-367914913.png&quot; alt=&quot;&quot; width=&quot;558&quot; height=&quot;374&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1793280/202007/1793280-20200731081017383-479859811.png&quot; alt=&quot;&quot; width=&quot;638&quot; height=&quot;359&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 第二步：找到Main-最下面的Boot-time Diagnostic Screen，敲“Enter”，弹出菜单，通过↑↓键把它调整为“Enabled”。&lt;br/&gt;此选项作用是显示平面诊断。更改为Enable之后，会显示硬件自检信息。此选项和其他功能无关。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1793280/202007/1793280-20200731081458354-692323277.png&quot; alt=&quot;&quot; width=&quot;592&quot; height=&quot;440&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;第三步：调整虚拟机启动优先级，找到Boot-Hard Drive，敲“Enter”，它会弹出下拉菜单，找到Vmware Virtual SCSI Hard Drive，通过敲“+”“-”来将Vmware Virtual SCSI Hard Drive调到第一位。&lt;br/&gt;Vmware Virtual SCSI Hard Drive是硬盘启动&lt;br/&gt;Bootable Add-in Cards是扩展卡上的硬盘&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1793280/202007/1793280-20200731081759370-775768420.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;461&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;第四步：保存刚刚的设置，看步骤，点完yes就可以完美启动了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1793280/202007/1793280-20200731081944914-1507927359.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最后，这个方法自己亲测有效，每次启动都正常，如有问题，请留言！&lt;/p&gt;

</description>
<pubDate>Fri, 31 Jul 2020 00:22:00 +0000</pubDate>
<dc:creator>bajie_new</dc:creator>
<og:description># 调整VMware硬盘启动优先级 第一步：打开电源时进入固件，也就是BIOS 设置界面。 第二步：找到Main-最下面的Boot-time Diagnostic Screen，敲“Enter”，弹出</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhoulangshunxinyangfan/p/13407691.html</dc:identifier>
</item>
<item>
<title>小白测试系列:接口测试与性能测试的区别 - 测试生财</title>
<link>http://www.cnblogs.com/Mrchaishome/p/13407659.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Mrchaishome/p/13407659.html</guid>
<description>&lt;p&gt;       最近我在一个论坛上看到了一个关于性能测试和接口测试的经典问题，问题如下：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;问题：后端性能测试，一个功能其实都是由后台多个接口组成的。&lt;/p&gt;
&lt;p&gt;例如一个单据的保存，可能后台需要调用几个接口。用LR录制这个功能做性能测试。和把它这个功能调用的几个接口连接起来一起做接口性能测试有什么区别呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;        相信很多开始测试自动化的测试同学的入门都是从一些培训班或者网上课程开始的。很多培训在讲授接口测试或者性能测试的时候往往是拿LoadRunner或者jmeter去演示测试过程的。通常的课程安排一般先拿LoadRunner（或者jmeter）讲接口测试，然后继续使用LoadRunner（或者jmeter）去讲性能测试。&lt;/p&gt;
&lt;p&gt;        无论是接口测试还是性能测试，貌似老湿们讲的步骤好像都差不多，先录制接口，然后配置场景，然后执行测试场景，给人感觉好像没啥差别。感觉好晕。。那到底两者差别在哪里呢？我们从入门者的角度来谈谈差别吧！&lt;/p&gt;
&lt;p&gt;        这里我准备从三个部分去阐述两者的关联和区别：&lt;/p&gt;
&lt;p&gt;        1. 至关重要的观念：测试与工具的关系。&lt;/p&gt;
&lt;p&gt;        2. 接口测试和性能测试的侧重点。&lt;/p&gt;
&lt;p&gt;        3. 在实际场景中二者的配置区别。&lt;/p&gt;
&lt;p&gt;        首先我们要正试一个理念，LoadRunner和Jmeter只是一个工具，而培训班大力推崇的都是工具培训，容易让我们落入一种XXX就是性能测试的赶脚，其实不然（差别蛮多，后面会单独去写文章分享），性能测试包含了工具（LoadRunner和Jmeter），工具仅仅是扮演了性能测试中的一个执行环节而已。&lt;/p&gt;
&lt;p&gt;        我们可以拿LoadRunner（Jmeter）做接口测试，当然也可以拿到做性能测试。所以工具是什么不重要，关键在于我们怎么去使用它，例如下面一个生活中的例子：铁锹。我们可以拿铁锹来铲土，也可以用铁锹来炒大锅饭，是不是就像LoadRunner既能做接口测试，又能做性能测试一样？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82OTg2ODMyLTAyMDRiNDliNDJmMjBlNDEucG5n?x-oss-process=image/format,png&quot; alt=&quot;&quot; width=&quot;260&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;挖土的铁锹&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy82OTg2ODMyLTc3NWRmM2YyODlhMWZlYjcucG5n?x-oss-process=image/format,png&quot; alt=&quot;&quot; width=&quot;265&quot; height=&quot;174&quot;/&gt;&lt;/p&gt;
&lt;p&gt;炒饭的铁锹&lt;/p&gt;
&lt;p&gt;        梳理清楚了第一个概念：工具和测试没有完全对等的关系后，我们来说第二个，性能测试和接口测试的区别。&lt;/p&gt;
&lt;p&gt;        测试分很多种，如果细细罗列，从单测，接口，功能，性能，UI，至少有五层，那其实区分这些测试类型的关键点就在于测试的侧重点不一样，接口测试是针对后端开发的接口（不一定是http的，也有可能是tcp的），而性能测试是偏重于产品的各方面各阶段性能（接口的性能，页面的性能，app的性能），可以说性能测试的覆盖度比接口更大一些。那我们就拿http类型的接口测试和性能测试举例，有啥侧重点区别呢？&lt;/p&gt;
&lt;p&gt;        简单来说，它俩区别就在于性能测试有多用户（并发）的概念，而接口测试只是单用户场景。我们做接口测试是是用于验证接口的请求和返回是否匹配（其实可以理解成接口测试也是一种功能测试）；而性能测试则是很多人同时在做这种接口测试，更侧重于真实的用户场景。因为我们研发完的产品投入市场后，不会就专门给某一个人使用功能，肯定是会有很多人同时在用我们的产品功能。那在这里，很多人同时在用其实就是性能的一个关键点。&lt;/p&gt;
&lt;p&gt;        所以总结第二点：性能测试近乎等同于很多用户同时在做接口测试。&lt;/p&gt;
&lt;p&gt;        第三部分，也是回答本文最初抛出的问题，在实际的应用过程中，二者是否存在什么联系与区别？&lt;/p&gt;
&lt;p&gt;        我们就简单地拿LR做接口测试和性能测试的过程为例吧，拿LR执行测试对于大多数人来说就三步：录制接口（或者接口抓包），配置场景，执行测试场景。&lt;/p&gt;
&lt;p&gt;        录制接口这一步是没有区别的，因为我们刚才讲到过，性能测试其实也是一种特殊的接口测试。那配置场景这一步有区别吗？可能很多人也说没有区别，但其实是有的，我们举例几个区别。如果是性能测试，首先要配置多用户（或者说多线程），而接口测试不用；其次如果是性能测试，建议关掉断言（否则可能压不上去，因为断言会耗费LR或者Jmeter自身的性能）；最后如果是性能测试，如果压测不上去，还可能需要做分布式（简单来说，就是多台机器同时执行性能测试）。&lt;/p&gt;
&lt;p&gt;        那第三步：执行测试场景的时候有什么区别吗？刚才说到，接口测试一般是用断言来验证接口的正确性，那性能测试怎么去验证呢？在执行性能测试场景的时候，我们抛弃断言，要加入另外的校验方式：&lt;/p&gt;
&lt;p&gt;        1. 最基本的三个：多用户下接口的响应时间，qps/tps（每秒请求量）,出错率。&lt;/p&gt;
&lt;p&gt;        2.服务器上的资源监控（cpu，内存，io）。&lt;/p&gt;
&lt;p&gt;        3.被测服务的资源监控（多个服务的cpu，内存，io）以及错误日志。&lt;/p&gt;
&lt;p&gt;        以上三点都是衡量性能测试的标准，也是当执行性能测试场景出问题时候，用于定位问题的重要证据，所以我们可以知道，当接口测试出了问题，我们可以通过断言迅速知道出了问题；而性能测试出了问题，需要从多个方面多个维度去调试定位，性能测试对于系统架构的理解能力要求更高！&lt;/p&gt;
&lt;p&gt;        以上就是我从入门角度，对接口测试和性能测试的区别的一些知识分享，希望对一些即将入门或者刚入门的你有帮助！有任何疑问请直接在文末留言，你的留言是对我原创最大的鼓励，谢谢！&lt;/p&gt;
</description>
<pubDate>Fri, 31 Jul 2020 00:07:00 +0000</pubDate>
<dc:creator>测试生财</dc:creator>
<og:description>最近我在一个论坛上看到了一个关于性能测试和接口测试的经典问题，问题如下： 问题：后端性能测试，一个功能其实都是由后台多个接口组成的。 例如一个单据的保存，可能后台需要调用几个接口。用LR录制这个功能做</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Mrchaishome/p/13407659.html</dc:identifier>
</item>
<item>
<title>精讲RestTemplate第1篇-在Spring或非Spring环境下如何使用 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13407638.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13407638.html</guid>
<description>&lt;h2 id=&quot;一、什么是-resttemplate&quot;&gt;一、什么是 RestTemplate?&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;RestTemplate&lt;/code&gt;是执行HTTP请求的同步阻塞式的客户端，它在HTTP客户端库（例如JDK HttpURLConnection，Apache HttpComponents，okHttp等）基础封装了更加简单易用的模板方法API。也就是说RestTemplate是一个封装，底层的实现还是java应用开发中常用的一些HTTP客户端。但是相对于直接使用底层的HTTP客户端库，它的操作更加方便、快捷，能很大程度上提升我们的开发效率。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;RestTemplate&lt;/code&gt;作为spring-web项目的一部分，在Spring 3.0版本开始被引入。RestTemplate类通过为HTTP方法（例如GET，POST，PUT，DELETE等）提供重载的方法，提供了一种非常方便的方法访问基于HTTP的Web服务。如果你的Web服务API基于标准的RESTful风格设计，使用效果将更加的完美。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;根据Spring官方文档及源码中的介绍，RestTemplate在将来的版本中它可能会被弃用，因为他们已在Spring 5中引入了WebClient作为非阻塞式Reactive HTTP客户端。但是RestTemplate目前在Spring 社区内还是很多项目的“重度依赖”，比如说Spring Cloud。另外，RestTemplate说白了是一个客户端API封装，和服务端相比，非阻塞Reactive 编程的需求并没有那么高。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200731075743661-478675712.png&quot; alt=&quot;RestTemplate在将来的版本中它可能会被弃用&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;二、非spring环境下使用resttemplate&quot;&gt;二、非Spring环境下使用RestTemplate&lt;/h2&gt;
&lt;blockquote readability=&quot;7.6214511041009&quot;&gt;
&lt;p&gt;为了方便后续开发测试，首先介绍一个网站给大家。&lt;a href=&quot;http://jsonplaceholder.typicode.com/&quot;&gt;JSONPlaceholder&lt;/a&gt;是一个提供免费的在线REST API的网站，我们在开发时可以使用它提供的url地址测试下网络请求以及请求参数。或者当我们程序需要获取一些模拟数据、模拟图片时也可以使用它。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;RestTemplate是spring的一个rest客户端，在spring-web这个包下。这个包虽然叫做spring-web，但是它的RestTemplate可以脱离Spring 环境使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
  &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt;
  &amp;lt;artifactId&amp;gt;spring-web&amp;lt;/artifactId&amp;gt;
  &amp;lt;version&amp;gt;5.2.6.RELEASE&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试一下Hello world，使用RestTemplate发送一个GET请求，并把请求得到的JSON数据结果打印出来。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Test
public void simpleTest()
{
    RestTemplate restTemplate = new RestTemplate();
    String url = &quot;http://jsonplaceholder.typicode.com/posts/1&quot;;
    String str = restTemplate.getForObject(url, String.class);
    System.out.println(str);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;服务端是JSONPlaceholder网站，帮我们提供的服务端API。需要注意的是：&quot;&lt;a href=&quot;http://jsonplaceholder.typicode.com/posts/1&quot;&gt;http://jsonplaceholder.typicode.com/posts/1&lt;/a&gt;&quot;服务URL，虽然URL里面有posts这个单词，但是它的英文含义是：帖子或者公告，而不是我们的HTTP Post协议。所以说&quot;&lt;a href=&quot;http://jsonplaceholder.typicode.com/posts/1&quot;&gt;http://jsonplaceholder.typicode.com/posts/1&lt;/a&gt;&quot;，请求的数据是：id为1的Post公告资源。打印结果如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1815316/202007/1815316-20200731075744262-1972907750.png&quot; alt=&quot;jsonplaceholder&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我们只是演示了RestTemplate 最基础的用法，RestTemplate 会写成一个系列的文章，请大家关注。&lt;/p&gt;
&lt;h2 id=&quot;三、spring环境下使用resttemplate&quot;&gt;三、Spring环境下使用RestTemplate&lt;/h2&gt;
&lt;p&gt;将maven坐标从spring-web换成spring-boot-starter-web&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将RestTemplate配置初始化为一个Bean。这种初始化方法，是使用了JDK 自带的HttpURLConnection作为底层HTTP客户端实现。我们还可以把底层实现切换为Apache HttpComponents，okHttp等，我们后续章节会为大家介绍。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
public class ContextConfig {

    //默认使用JDK 自带的HttpURLConnection作为底层实现
    @Bean
    public RestTemplate restTemplate(){
        RestTemplate restTemplate = new RestTemplate();
        return restTemplate;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在需要使用RestTemplate 的位置，注入并使用即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  @Resource //@AutoWired
  private RestTemplate restTemplate;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Jul 2020 23:58:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、什么是 RestTemplate? RestTemplate是执行HTTP请求的同步阻塞式的客户端，它在HTTP客户端库（例如JDK HttpURLConnection，Apache HttpCo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13407638.html</dc:identifier>
</item>
<item>
<title>JavaScript Function对象 - 云崖先生</title>
<link>http://www.cnblogs.com/Yunya-Cnblogs/p/13407441.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yunya-Cnblogs/p/13407441.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;前言&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Js&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;中的函数其实相较于其他语言是比较复杂的，光函数类型就分了好几种，其中&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;指向更是让很多初学者摸不到头脑。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;那么本篇文章将着重介绍一下函数的基本使用，关于&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;this&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;指向的详解将放在下一章。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;函数的作用其实就是将一段可重复利用的代码进行整合，方便多次使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;一定要注意，先声明定义函数而后再进行使用。这是一种规范。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;函数定义&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;实例定义&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Js&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;中函数是&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Fuction&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类的实例对象，因此我们可以用实例化的方式来定义函数，这也能充分理解函数也是对象这一概念。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
        &quot;use strict&quot;&lt;span&gt;;
​
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 参数1：形参，参数2：函数代码体&lt;/span&gt;
&lt;span&gt;​
        let func &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Function(&quot;title&quot;,&quot;console.log(title)&quot;&lt;span&gt;);
​
        func(&lt;/span&gt;&quot;云崖先生的博客&quot;&lt;span&gt;);
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;标准定义&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Function&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;类的方式定义函数太过麻烦，因此推荐使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;function&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;标准语法进行定义。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;
        
        &quot;use strict&quot;&lt;span&gt;;
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func(title){
                console.log(title);
        }
​
        func(&lt;/span&gt;&quot;云崖先生的博客&quot;&lt;span&gt;);
 
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对象字面量&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;我们可以在一个对象中定义函数，这通常会被称之为对象方法。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        let obj &lt;/span&gt;=&lt;span&gt; {
​
                description:&lt;/span&gt;&quot;这是一个对象属性&quot;&lt;span&gt;,
​
                show:&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(title){
                        console.log(&lt;/span&gt;&quot;这是一个对象方法，传入的参数是:&quot;&lt;span&gt;,title);
                },
                
        }
​
        obj.show(&lt;/span&gt;&quot;云崖&quot;&lt;span&gt;);
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;匿名函数&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;全局声明的标准定义函数会被存入&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;对象中，这样做会产生很多弊端。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;因为我们的函数名如果不恰当的话可能造成&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;方法缺失。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func(title){
                console.log(title);
        }
​
        func(&lt;/span&gt;&quot;云崖先生的博客&quot;&lt;span&gt;);
 
        console.log(window.func); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有的&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;因此，可以通过赋值来进行匿名函数的定义，定义前使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;let/const&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;进行声明，这样就不会压入至&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;对象中，注意后面要以&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;;&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;结束。 &lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-plain&quot;&gt;注意：以&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;声明的匿名函数会压入至&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;对象中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        let func &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (title) {
                console.log(title);
        };
​
        func(&lt;/span&gt;&quot;云崖先生的博客&quot;&lt;span&gt;);
​
        console.log(window.func);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  undefined&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;函数执行&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;函数提升&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;标准定义的函数会进行函数提升，可以先使用后定义，这是不符合规范的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;但是匿名函数不会进行函数提升。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;函数的提升是排在&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;变量提升之前的，因此如果函数名与用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;定义的变量重复那么该名字会被变量拿到，函数则会被当做垃圾回收。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;即使使用了&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;var&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;来定义匿名函数，也不会进行函数提升， 但是会将该函数压入&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;window&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;对象中，所以建议使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;let/const&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;来对匿名函数进行接收。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;标准声明函数会进行提升&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        func(&lt;/span&gt;&quot;云崖先生的博客&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行了&lt;/span&gt;
&lt;span&gt;​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; func (title) {
                console.log(title);
        }
​
        console.log(window.func);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有的&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;匿名函数不会进行提升&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        func(&lt;/span&gt;&quot;云崖先生的博客&quot;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Uncaught ReferenceError: Cannot access 'func' before initialization&lt;/span&gt;
&lt;span&gt;​
        let func &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (title) {
                console.log(title);
        }
​
        console.log(window.func);  
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;自执行函数&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;在很早之前，如果你写了一个&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Js&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;模块，为了防止全局作用域的污染，你会将代码放入一个自执行函数里面。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;但是现在不用了，因为&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;let/const&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;具有块作用域，它们的出现决定我们今后写的模块不用再拿自执行函数来进行封装了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;首先来看一下自执行函数怎么使用。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
​
        (&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (title) {
​
                console.log(title);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自己执行&lt;/span&gt;
&lt;span&gt;​
        })(&lt;/span&gt;&quot;云崖先生的博客&quot;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这里调用&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;自执行函数封装&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show() {
                console.log(&lt;/span&gt;&quot;执行了show功能&quot;&lt;span&gt;);
        }
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test() {
                console.log(&lt;/span&gt;&quot;执行了test功能&quot;&lt;span&gt;);
        }
​
        window.module &lt;/span&gt;=&lt;span&gt; { show, test };
​
})();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;let&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;作用域封装&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
​
        let show &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                console.log(&lt;/span&gt;&quot;执行了show功能&quot;&lt;span&gt;);
        }
​
        let test &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
                console.log(&lt;/span&gt;&quot;执行了test功能&quot;&lt;span&gt;);
        }
​
        window.module &lt;/span&gt;=&lt;span&gt; { show, test };
​
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-pair-s&quot;&gt;&lt;strong&gt;调用&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&quot;JavaScript.js&quot;&amp;gt;&amp;lt;/script&amp;gt; 
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意上面要引入模块&lt;/span&gt;
    
        &quot;use strict&quot;&lt;span&gt;;
​
        module.show();
        module.test();
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;参数相关&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;形参实参&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;形参是在函数声明时设置的参数，实参指在调用函数时传递的值，注意，传参时必须一一对应！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;形参数量大于实参时，没有传参的形参值为 &lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;实参数量大于形参时，多于的实参将忽略并不会报错&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;函数名.length&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;可获取需要传递形参的数量&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test(f1, f2, f3) {
​
                console.log(f1);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个&lt;/span&gt;
                console.log(f2);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个&lt;/span&gt;
                console.log(f3);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; undefined&lt;/span&gt;
&lt;span&gt;​
        }
​
        test(&lt;/span&gt;&quot;第一个&quot;,&quot;第二个&quot;&lt;span&gt;);
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;默认形参&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;默认形参要放在最后，当没有实参传递时采用默认形参的值，当有实参传递时采用实参传递的值。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; test(f1, f2, f3) {
​
                f3 &lt;/span&gt;= f3 || &quot;默认形参&quot;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 老版设置默认形参的方式&lt;/span&gt;
                console.log(f1);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个&lt;/span&gt;
                console.log(f2);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个&lt;/span&gt;
                console.log(f3);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认形参&lt;/span&gt;
&lt;span&gt;                
        }
​
        test(&lt;/span&gt;&quot;第一个&quot;,&quot;第二个&quot;&lt;span&gt;);
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 新版设置默认形参的方式&lt;/span&gt;
        &lt;span&gt;function&lt;/span&gt; test(f1, f2, f3=&quot;默认形参&quot;&lt;span&gt;) { 
​
                console.log(f1);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一个&lt;/span&gt;
                console.log(f2);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二个&lt;/span&gt;
                console.log(f3);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 默认形参&lt;/span&gt;
&lt;span&gt;​
        }
​
        test(&lt;/span&gt;&quot;第一个&quot;,&quot;第二个&quot;&lt;span&gt;);
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;函数参数&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;函数本身也可当做一个参数传递给另一个函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f1(func) {
                console.log(&lt;/span&gt;&quot;f1...&quot;&lt;span&gt;);
                console.log(&lt;/span&gt;&quot;参数:&quot;&lt;span&gt;,func);
                func(&lt;/span&gt;&quot;给f2传递的参数&quot;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行f2&lt;/span&gt;
&lt;span&gt;        }
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; f2(y) { 
                console.log(&lt;/span&gt;&quot;f2&quot;&lt;span&gt;);
                console.log(&lt;/span&gt;&quot;参数:&quot;&lt;span&gt;,y);
         }
​
         f1(f2);
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;arguments&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;当某个函数要接收无限多的参数时，可不指定形参，使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;arguments&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;来进行接收（必须是这个名字）。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;注意：&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;arguments&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;是&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Arguments&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;对象，并不是一个数组。但是我们可以将它转换为数组再进行操作&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show() {
​
                console.log(arguments );
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Arguments(6) [1, 2, 3, 4, 5, 6, callee: (...), Symbol(Symbol.iterator): ƒ]&lt;/span&gt;
&lt;span&gt;​
        }
​
        show(&lt;/span&gt;1,2,3,4,5,6&lt;span&gt;);
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;...语法&lt;/span&gt;&lt;/h3&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;当形参要接收无限多的参数时，可在形参名前加入&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;...&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;，使用进行接收。该形参会作为一个&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;Array&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;对象接收无限多的参数。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;这个是更推荐使用的方式&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(...args) {
​
                console.log(args );
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (6) [1, 2, 3, 4, 5, 6]&lt;/span&gt;
&lt;span&gt;        }
​
        show(&lt;/span&gt;1,2,3,4,5,6&lt;span&gt;);
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;当实参是一个数组或者类数组的数据类型时，可以使用&lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;...&lt;/code&gt;&lt;span class=&quot;md-plain&quot;&gt;语法来为形参一一对应传参。但是要注意，严格模式下不允许这样做。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;use strict&quot;; 严格模式下不能这么做&lt;/span&gt;
&lt;span&gt;​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(f1,f2,f3,f4,f5,f5) {
​
                console.log(f1);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
                console.log(f2);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;
                console.log(f3);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;
                console.log(f4);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;
                console.log(f5);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;
&lt;span&gt;        }
​
        show(...[&lt;/span&gt;1,2,3,4,5,6&lt;span&gt;]);
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;箭头函数&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;箭头函数是函数声明的简写形式，在使用递归调用、构造函数、事件处理器时不建议使用箭头函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;无参数时使用空扩号即可，代码块过于简短可省略花括号。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;函数体为单一表达式时不需要 &lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;return&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;返回处理，系统会自动返回表达式计算结果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;多参数传递与普通声明函数一样使用逗号分隔&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;只有一个参数时可以省略参数括号。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;无参数时使用空扩号即可，代码块过于简短可省略花括号。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        let show &lt;/span&gt;= () =&amp;gt; console.log(&quot;执行了&quot;&lt;span&gt;);
​
        show();
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;函数体为单一表达式时不需要 &lt;span class=&quot;md-pair-s&quot;&gt;&lt;code&gt;return&lt;/code&gt; &lt;span class=&quot;md-plain&quot;&gt;返回处理，系统会自动返回表达式计算结果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        let show &lt;/span&gt;= () =&amp;gt; &quot;你真帅&quot;&lt;span&gt;;
​
        const res &lt;/span&gt;=&lt;span&gt; show();
 
        console.log(res);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 你真帅&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;多参数传递与普通声明函数一样使用逗号分隔&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        let show &lt;/span&gt;= (f1, f2, f3) =&amp;gt;&lt;span&gt; {
​
                console.log(f1);
                console.log(f2);
                console.log(f3);
​
        };  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意加分号&lt;/span&gt;
&lt;span&gt;​
        show(&lt;/span&gt;&quot;第一&quot;, &quot;第二&quot;, &quot;第三&quot;&lt;span&gt;)
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;只有一个参数时可以省略参数括号。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        let show &lt;/span&gt;= f1 =&amp;gt;&lt;span&gt; console.log(f1);
​
        show(&lt;/span&gt;&quot;第一&quot;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;递归调用&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;递归指函数内部调用自身的方式。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;主要用于数量不确定的循环操作&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;要有退出时机否则会陷入死循环&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;以下示例将展示使用递归进行累加操作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(num) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;num) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; num + show(num - 1&lt;span&gt;);
        }
​
        let res &lt;/span&gt;= show(100&lt;span&gt;);
        console.log(res);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5050&lt;/span&gt;
&lt;span&gt;​
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;以下示例将展示使用递归打印倒三角。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(num) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;num) {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ;
                }
​
                console.log(&lt;/span&gt;&quot;*&quot;&lt;span&gt;.repeat(num));
                show(num &lt;/span&gt;- 1&lt;span&gt;);
        }
​
        show(&lt;/span&gt;5&lt;span&gt;);
     
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;回调函数&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;回调函数是指在某一特定情况下会被其他函数所调用的函数，比如处理鼠标事件，键盘事件的函数都是回调函数。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
                                                                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 回调函数&lt;/span&gt;
        document.querySelector(&quot;div&quot;).addEventListener(&quot;click&quot;,(event)=&amp;gt; console.log(event.target));  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 由于this指向不同，所以我们使用event.target进行打印&lt;/span&gt;
     
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;标签函数&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;当使用模板字面量对字符串进行格式化时，可指定一个标签函数。第一个参数是字符串值的数组，其余的参数为标签变量。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;　　&lt;span class=&quot;md-plain&quot;&gt;注意！标签函数会自动执行！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;script&amp;gt;&lt;span&gt;
​
        &lt;/span&gt;&quot;use strict&quot;&lt;span&gt;;
​
        &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; show(str, ...args) {
​
                console.log(str);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; (3) [&quot;姓名是:&quot;, &quot;↵年龄是:&quot;, &quot;&quot;, raw: Array(3)]&lt;/span&gt;
                console.log(args);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (2) [&quot;云崖&quot;, 18]&lt;/span&gt;
&lt;span&gt;                
        }
​
        let username &lt;/span&gt;= &quot;云崖&quot;&lt;span&gt;;
        let age &lt;/span&gt;= 18&lt;span&gt;;
​
        let str &lt;/span&gt;=&lt;span&gt; show`姓名是:${username}\n年龄是:${age}`;
​
&lt;/span&gt;&amp;lt;/script&amp;gt;
 
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 30 Jul 2020 16:26:00 +0000</pubDate>
<dc:creator>云崖先生</dc:creator>
<og:description>JavaScript Function对象 前言 Js中的函数其实相较于其他语言是比较复杂的，光函数类型就分了好几种，其中this指向更是让很多初学者摸不到头脑。 那么本篇文章将着重介绍一下函数的基本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Yunya-Cnblogs/p/13407441.html</dc:identifier>
</item>
<item>
<title>Python代码规范性检测 - Yabea</title>
<link>http://www.cnblogs.com/ybjourney/p/13407406.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ybjourney/p/13407406.html</guid>
<description>&lt;p&gt;一定要注重代码规范，按照平时的代码管理，可以将Python代码规范检测分为两种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;静态本地检测：可以借助静态检查工具，比如：Flake8，Pylint等，调研了一下，用Flake8的相对较多，功能满足，本文将使用Flake8&lt;/li&gt;
&lt;li&gt;git：可借助git hooks，本文推荐使用pre-commit。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;静态本地检测&quot;&gt;静态本地检测&lt;/h2&gt;
&lt;p&gt;Flake8包装了Pyflakes、Pycodestyle和McCabe，也可以自定义插件。功能包括：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检查代码是否符合PEP8&lt;/li&gt;
&lt;li&gt;检查是否包含语法错误和未使用的变量和导入&lt;/li&gt;
&lt;li&gt;检查代码的复杂度&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install flake8&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;推荐在pycharm中配置flake8:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/771535/202007/771535-20200731000832685-1233503744.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参数说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Program中填写Flake可执行文件的具体路径&lt;/li&gt;
&lt;li&gt;arguments中可添加自定义参数，比如设置每行的最大字符数，过滤某些文件（夹）等。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;安装完了之后单击就可以检测了：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/771535/202007/771535-20200731000858136-1457959134.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行检测之后，如果出现 &lt;code&gt;exit code 0&lt;/code&gt; 就说明代码规范，否则可按照提示进行整改。&lt;/p&gt;
&lt;h2 id=&quot;pre-commit&quot;&gt;pre-commit&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;官网&lt;/strong&gt;： &lt;a href=&quot;https://pre-commit.com/&quot;&gt;https://pre-commit.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;介绍&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;使用git的话，可以使用pre-commit钩子，在调用&lt;code&gt;git commit&lt;/code&gt; 命令时会自动执行脚本进行检测，若代码出错，则不会commit成功。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在&lt;code&gt;git commit&lt;/code&gt;命令之前对代码进行规范性检测&lt;/li&gt;
&lt;li&gt;按照配置，对一些不符合规范的代码自动更新为规范的（比如：填充空格、更新import等）&lt;/li&gt;
&lt;li&gt;提示更新之后仍不符合规范的代码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pip install pre-commit&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Linux中安装完成即可执行pre-commit命令，Windows中需将.exe的路径添加至环境变量，方可执行pre-commit命令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在项目根目录下添加.pre-commit-config.yaml文件。&lt;/p&gt;
&lt;p&gt;可参考官网样例,：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;repos:
-   repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v2.3.0
    hooks:
    -   id: check-yaml
    -   id: end-of-file-fixer
    -   id: trailing-whitespace
-   repo: https://github.com/psf/black
    rev: 19.3b0
    hooks:
    -   id: black
-   repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v2.3.0
    hooks:
    -   id: flake8
        args:
        - --max-line-length=120
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体的配置可结合官网或github中的说明文档进行相关配置更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;br/&gt;执行&lt;code&gt;pre-commit install&lt;/code&gt;命令，会在.git/hook路径下生成pre-commit文件，这样就保证了pre-commit安装成功，可以正常使用了。&lt;/p&gt;
&lt;p&gt;然后执行：&lt;/p&gt;
&lt;p&gt;更新配置文件只需要执行&lt;code&gt;pre-commit install&lt;/code&gt;即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置完成之后，在&lt;code&gt;git commit&lt;/code&gt;之前都会执行刚才的配置，可根据执行的结果来更新或者提交代码。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Jul 2020 16:10:00 +0000</pubDate>
<dc:creator>Yabea</dc:creator>
<og:description>本文介绍Python代码规范检测。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ybjourney/p/13407406.html</dc:identifier>
</item>
<item>
<title>设计模式之外观模式 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/facade-pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/facade-pattern.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;外观模式（Facade），为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;prototype&quot;&gt;Prototype&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Facade: 外观类，知道哪些子系统类负责处理请求，将请求代理给对应的子系统对象&lt;/li&gt;
&lt;li&gt;SubSystem Classes，实现子系统中的功能，处理 Facade 指派的任务，和 Facade 没有关联关系，没有继承，也不会引用 Facade&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class SubSystem1
{
    public void MethodA()
    {
        Console.WriteLine(&quot;MethodA in SubSystem1&quot;);
    }

    public void MethodB()
    {
        Console.WriteLine(&quot;MethodB in SubSystem1&quot;);
    }
}
public class SubSystem2
{
    public void MethodA()
    {
        Console.WriteLine(&quot;MethodA in SubSystem2&quot;);
    }

    public void MethodB()
    {
        Console.WriteLine(&quot;MethodB in SubSystem2&quot;);
    }
}
public class SubSystem3
{
    public void MethodA()
    {
        Console.WriteLine(&quot;MethodA in SubSystem3&quot;);
    }

    public void MethodB()
    {
        Console.WriteLine(&quot;MethodB in SubSystem3&quot;);
    }
}

public class Facade
{
    private readonly SubSystem1 _subSystem1 = new SubSystem1();
    private readonly SubSystem2 _subSystem2 = new SubSystem2();
    private readonly SubSystem3 _subSystem3 = new SubSystem3();

    public void MethodA()
    {
        _subSystem1.MethodA();
        _subSystem2.MethodA();
        _subSystem3.MethodA();
        Console.WriteLine();
    }

    public void MethodB()
    {
        _subSystem1.MethodB();
        _subSystem2.MethodB();
        _subSystem3.MethodB();
        Console.WriteLine();
    }
}

var facade = new Facade();
facade.MethodA();
facade.MethodB();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;应用场景&quot;&gt;应用场景&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;解决易用性问题，可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。&lt;/li&gt;
&lt;li&gt;解决性能问题，通过将多个接口调用替换为一个门面接口调用，减少网络通信成本，提高 App 客户端的响应速度。API 聚合就是属于这种，也是属于外观模式的应用&lt;/li&gt;
&lt;li&gt;解决事务问题，通过门面模式可以方便的使得原本多个操作可以在一个事务内完成，如果中间某一个环节操作失败，可以回滚事务，撤销变更&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;接口设计的好坏，直接影响到类、模块、系统是否好用。所以，我们要多花点心思在接口设计上。&lt;/p&gt;
&lt;p&gt;完成接口设计，就相当于完成了一半的开发任务。只要接口设计得好，那代码就差不到哪里去。接口粒度设计得太大，太小都不好。太大会导致接口不可复用，太小会导致接口不易用。&lt;/p&gt;
&lt;p&gt;在实际的开发中，接口的可复用性和易用性需要“微妙”的权衡。针对这个问题，我的一个基本的处理原则是，尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Thu, 30 Jul 2020 16:09:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>定义一组高层接口让子系统更易用，外观模式、门面模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/facade-pattern.html</dc:identifier>
</item>
<item>
<title>数字电路一：绪论—信息—编码 - 浅草寺的光影</title>
<link>http://www.cnblogs.com/Shade-of-Greenland/p/13398854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Shade-of-Greenland/p/13398854.html</guid>
<description>&lt;p&gt; 写在前面的话：&lt;/p&gt;

&lt;p&gt;大二上学期初修该课程，本以为相对于通信而言该课程不重要，学的并不扎实，好多重要的知识点没有搞明白，但是随着学习的进展，发现该课程是一切硬件电路的基础，如芒在背，所以于大二下学期暑假中重新学习，有幸在b站上找到王红主讲的清华大学《数字电子技术》 50讲视频教程，特此整理听课笔记及回忆一些重点提醒后来者。&lt;/p&gt;
&lt;p&gt;视频课程链接(视频质量挺高的记得给作者投个币)：https://www.bilibili.com/video/BV16x411i7FW &lt;/p&gt;
&lt;blockquote&gt;
&lt;h2&gt;绪论&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; 进入正题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先&lt;/p&gt;
&lt;p&gt;电子电路的作用→处理信息&lt;/p&gt;
&lt;p&gt;             ↓ &lt;/p&gt;
&lt;p&gt;       能量转换&lt;/p&gt;


&lt;p&gt; 其中信号可以由数字信号与模拟信号构成，分别对应数电与模电。(郑益慧老师的模电有机会也整个专题，讲的也真的好)&lt;/p&gt;
&lt;p&gt;从而数电是用离散电压来表示信息，以实现信息传递与控制。&lt;/p&gt;

&lt;blockquote&gt;
&lt;h2&gt;编码&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;一：编码的规范&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;遵循：唯一性，效率性（如数据结构中的哈夫曼编码），可靠性，安全性。&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 二：编码的数制与码制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;数制：表示数量的规则（十进制，二进制，八进制，十六进制等等）&lt;/p&gt;
&lt;p&gt;如:（重点问题：进制之间的转化规则）&lt;/p&gt;

&lt;p&gt;部分捷径：&lt;/p&gt;
&lt;p&gt;十进制下2000的二进制表示为：011111010000&lt;/p&gt;
&lt;p&gt;011/111/010/000每三位读取换算为八进制：3720&lt;/p&gt;
&lt;p&gt;0111/1101/0000每四位读取换算为十六进制：7d0（也写作0x7d0）&lt;/p&gt;
&lt;p&gt;可以直接利用位数读取，以此类推每5位读取对应32进制，每6位读取对应64进制等等（只适合二的倍数进制间的转化）&lt;/p&gt;

&lt;p&gt;而十进制的99对应1/100/011对应八进制的143可以一眼看出，十六进制也可一眼看出，但从二进制返回十进制只能一位一位加公式为：D=ΣK&lt;sub&gt;i&lt;/sub&gt;•N&lt;sup&gt;i&lt;/sup&gt;   &lt;/p&gt;

&lt;p&gt;&lt;span&gt;再着重强调一类特殊情况：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;不同进制间小数的转化：&lt;/p&gt;

&lt;p&gt;十进制小数转换成N进制小数采用“乘N取整”法。具体做法为：&lt;/p&gt;
&lt;p&gt;用N乘以十进制小数，可以得到一个积，这个积分整数部分和小数部分；&lt;/p&gt;
&lt;p&gt;将积的整数部分取出写好，再用N乘以余下的小数部分，又得到一个新的积；&lt;/p&gt;
&lt;p&gt;再将积的整数部分取出，继续用N乘以余下的小数部分；&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;如此反复进行，每次都取出整数部分写到小数点后，再用N接着乘以小数部分，直到积中的小数部分为0，或者达到所需要的精度为止。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2103484/202007/2103484-20200729180833249-1981475301.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;537&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 图源网络，侵删。&lt;/p&gt;

&lt;p&gt;我们已经了解到进制的事项&lt;/p&gt;
&lt;p&gt;那么如何直接进行二进制间的计算呢?&lt;/p&gt;

&lt;p&gt;首先介绍三种编码方式：原码，反码，补码。&lt;/p&gt;

&lt;p&gt;一：原码&lt;/p&gt;
&lt;p&gt;                 ■               ■■■......■■■&lt;/p&gt;
&lt;p&gt;                 ↓                       ↓ &lt;/p&gt;
&lt;p&gt;            符号位             数值部分&lt;/p&gt;
&lt;p&gt;比如：[14]&lt;sub&gt;10&lt;/sub&gt;=[1110]&lt;sub&gt;2&lt;/sub&gt;=&lt;span&gt;0  1110&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         [-14]&lt;sub&gt;10&lt;/sub&gt;=[-1110]&lt;sub&gt;2&lt;/sub&gt;=&lt;span&gt;1  1110&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;(其中正数符号位为0，负数符号位则为1) &lt;/p&gt;

&lt;p&gt;原码的两大缺点：&lt;/p&gt;
&lt;p&gt;第一：0的表示有两种表示方法，正零与负零表示方式不同，这会导致有一个码位被浪费，且不符合常理。&lt;/p&gt;
&lt;p&gt;第二：不方便计算，如-5+5的结果为&lt;span&gt;0 101&lt;/span&gt;+&lt;span&gt;1 101&lt;/span&gt;=&lt;span&gt;0 010&lt;/span&gt; 与实际情况不符，所以确实不方便直接计算。&lt;/p&gt;

&lt;p&gt;为了解决这两个缺点，我们先铺垫一种码制——反码。&lt;/p&gt;

&lt;p&gt;二：反码&lt;/p&gt;
&lt;p&gt;                 ■               ■■■......■■■&lt;/p&gt;
&lt;p&gt;                 ↓                       ↓ &lt;/p&gt;
&lt;p&gt;            符号位             数值部分：其中正数不变，负数每一位一次取反。&lt;/p&gt;
&lt;p&gt;比如：[14]&lt;sub&gt;10&lt;/sub&gt;=[1110]&lt;sub&gt;2&lt;/sub&gt;=&lt;span&gt;0  1110&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;         [-14]&lt;sub&gt;10&lt;/sub&gt;=[-1110]&lt;sub&gt;2&lt;/sub&gt;=&lt;span&gt;1  0001&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这便是反码，同样存在两个设计缺陷：正零与负零表示方式不同及无法直接计算的问题。&lt;/p&gt;


&lt;p&gt;我们为了解决这两大缺陷重新设计了码制————&lt;span&gt;补码(核心的核心)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;三：补码&lt;/p&gt;
&lt;p&gt;                 ■               ■■■......■■■&lt;/p&gt;
&lt;p&gt;                 ↓                       ↓ &lt;/p&gt;
&lt;p&gt;            符号位             数值部分：其中正数采用原码设计方式，负数取反后加一。&lt;/p&gt;
&lt;p&gt;比如：[7]&lt;sub&gt;10&lt;/sub&gt;=[0111]&lt;sub&gt;2&lt;/sub&gt;=&lt;span&gt;0  0111&lt;/span&gt;(正数与原码一致)&lt;/p&gt;
&lt;p&gt;         [-7]&lt;sub&gt;10&lt;/sub&gt;=[-0111]&lt;sub&gt;2&lt;/sub&gt;=&lt;span&gt;1  1001&lt;/span&gt;(为7的原码取反加一)&lt;/p&gt;

&lt;p&gt;从而我们发现，7与-7相加，进位产生了溢出，使得7-7=0，解决了缺陷二&lt;/p&gt;
&lt;p&gt;对于缺陷一：不论是正零还是负零，补码表示均为&lt;span&gt;0   00....00&lt;/span&gt; 同样解决了缺陷一&lt;/p&gt;
&lt;p&gt;一种近乎完美的编码法则，至此出现。&lt;/p&gt;

&lt;p&gt;这是通过人类设计得到的，巧妙地解决了两大缺陷，从而广泛应用。&lt;/p&gt;



&lt;p&gt;由于0的码为补码表示为&lt;span&gt;0   00....00&lt;/span&gt;，相对于负数而言，正数编码位减少了一个。&lt;/p&gt;
&lt;p&gt;这也就是c++中，int整型中的-2147483648~2147483647负数比正数范围多了一个的原因，可见补码用处范围之广，同样也是挺有意思的。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;码制：表示事物的规则&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 用不同数码表示不同事物时遵循的规则。(比如学号，车牌号等等)&lt;/p&gt;
&lt;p&gt; 对于不同的实际问题选取不同的编码规则来表示事物。&lt;/p&gt;

&lt;p&gt;常见的编码规则有一种叫BCD码的&lt;/p&gt;
&lt;p&gt;BCD码也称二进码十进数，BCD码可分为有权码和无权码两类。其中，常见的有权BCD码有8421码、2421码、5421码，无权BCD码有余3码、余3循环码、格雷码。&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/2103484/202007/2103484-20200730124207060-380019804.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt;这些编码规则各有用途，每一种均有长处，当然我们知道，每获取一些新的性能时，需要牺牲原有的部分优良性能，从而对于不同问题选择不同编码方式才是硬道理。&lt;/p&gt;




&lt;blockquote&gt;
&lt;h2&gt;新的问题&lt;/h2&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;问题一：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们已经知道了补码的样子，那么补码的小数怎么表示呢。&lt;/p&gt;
&lt;p&gt;同样是采取，取反加一的口诀。&lt;/p&gt;
&lt;p&gt;如-2.625的补码为：&lt;/p&gt;
&lt;p&gt;首先将-2.625换算成小数样子，&lt;span&gt;1  010.101&lt;/span&gt;，除了符号位取反得&lt;span&gt;1  101.010&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在该列数的末尾加一即可得到补码&lt;span&gt;1  101.011&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可见 ' 1 ' 不是数值上的1 ，而是为了使得与对应正数相加为零时，补的1。&lt;/p&gt;


&lt;p&gt;P.S 补码还有另外一种理解方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2103484/202007/2103484-20200730113704055-1416325404.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;符号位为负数，依次从该负数中减去每一位的数值含义，也可以得到换算关系。&lt;/p&gt;


&lt;p&gt;如果想再深入思考补码蕴含的数学原理，则可参考张子秋的    &lt;a href=&quot;https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中对数学规则同余的讲解。&lt;/p&gt;

&lt;p&gt;原创不易，转载请注明出处 https://www.cnblogs.com/Shade-of-Greenland/p/13398854.html。&lt;/p&gt;

</description>
<pubDate>Thu, 30 Jul 2020 15:57:00 +0000</pubDate>
<dc:creator>浅草寺的光影</dc:creator>
<og:description>写在前面的话： 大二上学期初修该课程，本以为相对于通信而言该课程不重要，学的并不扎实，好多重要的知识点没有搞明白，但是随着学习的进展，发现该课程是一切硬件电路的基础，如芒在背，所以于大二下学期暑假中重</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Shade-of-Greenland/p/13398854.html</dc:identifier>
</item>
<item>
<title>用大白话的方式讲明白Java的StringBuilder、StringBuffer的扩容机制 - DMingO</title>
<link>http://www.cnblogs.com/DMingO/p/13407303.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DMingO/p/13407303.html</guid>
<description>&lt;p&gt;了解一下？StringBuilder、StringBuffer调用append后的扩容机制？为什么还要+2？&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;78&quot;&gt;
&lt;p&gt;&lt;code&gt;StringBuffer&lt;/code&gt;和&lt;code&gt;StringBuilder&lt;/code&gt;,都是继承了&lt;code&gt;AbstractStringBuilder&lt;/code&gt;，它们的底层char数组&lt;code&gt;value&lt;/code&gt;默认的初始化容量是&lt;strong&gt;16&lt;/strong&gt;，扩容只需要修改底层的char数组，两者的扩容最终都会调用到&lt;code&gt;AbstractStringBuilder&lt;/code&gt;类相同的方法：&lt;/p&gt;
&lt;p&gt;直入正题，扩容的步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;新的字符串的长度超过了底层原char数组&lt;code&gt;value&lt;/code&gt;的大小，才需要进行扩容&lt;/li&gt;
&lt;li&gt;先尝试默认扩容，将新容量变成 (&lt;strong&gt;value&lt;/strong&gt;.&lt;strong&gt;length&lt;/strong&gt; &amp;lt;&amp;lt; 1) + 2 ，也就是两倍的原数组长度再加二&lt;/li&gt;
&lt;li&gt;若默认扩充后的值还是小于至少容量的值，直接扩充到当前需要的至少容量大小；&lt;/li&gt;
&lt;li&gt;经过前两步骤确定的新数组大小，若大于Interger.MAX_VALUE,则报异常，若小于等于0，则新数组大小改为&lt;code&gt;Interger.MAX_VALUE -8&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;确定了新数组的值后，通过&lt;code&gt;Arrays.copy(value,newCapactity)&lt;/code&gt;进行复制。最终给value数组完成扩容。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样扩容的目的，宏观上是尽可能地减少扩容次数，提高效率。&lt;/p&gt;
&lt;p&gt;肯定有同学会问，&lt;strong&gt;默认扩容为什么是两倍的原数组长度 + 2 ？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因为源码并无说明这样设计的原因，所以根据我找到的资料结合我的推测，可能的原因有这些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;考虑到在创建Sf，Sb设置的初始长度不大时（例如1），+2 可以很大地提升扩容的效率，减少扩容的次数&lt;/li&gt;
&lt;li&gt;在旧版本的JDK扩容语句是 &lt;code&gt;(value.length + 1) * 2&lt;/code&gt; 先加一再乘2，推测原意思是扩容的话至少增添一个空间再乘2，兼顾到扩容的次数和要减少扩容过大浪费的空间&lt;/li&gt;
&lt;li&gt;&lt;code&gt;newCapacity(int)&lt;/code&gt;的传入参数有可能是0，那么在参数是0的情况下，&lt;code&gt;0&amp;lt;&amp;lt;1&lt;/code&gt;运算结果也是0，如果没+2，那么在创建数组的时候会创建出&lt;code&gt;MAX_ARRAY_SIZE&lt;/code&gt;大小，所以作为设计的安全性考虑，选择了+2。（本人认为除了反射调用&lt;code&gt;newCapacity&lt;/code&gt;，其他情况应该不会出现&lt;code&gt;newCapacity(int)&lt;/code&gt;可以传入0为参数）&lt;/li&gt;
&lt;li&gt;append(str)后需补充分隔符所预留的位置，为了减少扩容次数 (个人感觉这点不太靠谱)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是在JDK1.8中&lt;code&gt;AbstractStringBuilder&lt;/code&gt;有关计算扩容的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//AbstractStringBuilder.java 

   private void ensureCapacityInternal(int minimumCapacity) {
    //若所需长度大于已有长度，才继续进行扩容
    if (minimumCapacity - value.length &amp;gt; 0) {
        //通过Arrays.copyOf(),将旧value数组内容先复制到newCapacity大小的数组，再赋值给新value
        value = Arrays.copyOf(value,
                newCapacity(minimumCapacity));
        }
        }
    private int newCapacity(int minCapacity) {
        // 默认扩容：newCapacity = 两倍的原长度 + 2
        int newCapacity = (value.length &amp;lt;&amp;lt; 1) + 2;
        if (newCapacity - minCapacity &amp;lt; 0) {//默认扩容后还是小于所需长度
            newCapacity = minCapacity;//直接补充至所需长度
        }
        return (newCapacity &amp;lt;= 0 || MAX_ARRAY_SIZE - newCapacity &amp;lt; 0)
            ? hugeCapacity(minCapacity)//newCapacity＞MAX_ARRAY_SIZE 或者≤0会调用
            : newCapacity;
    }

    MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
    private int hugeCapacity(int minCapacity) {
        if (Integer.MAX_VALUE - minCapacity &amp;lt; 0) { //大小超出Integer范围爆异常
            throw new OutOfMemoryError();
        }
        return (minCapacity &amp;gt; MAX_ARRAY_SIZE) //返回minCapacity与MAX_ARRAY_SIZE最大值
            ? minCapacity : MAX_ARRAY_SIZE;
    }   
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Thu, 30 Jul 2020 15:40:00 +0000</pubDate>
<dc:creator>DMingO</dc:creator>
<og:description>了解一下？StringBuilder、StringBuffer调用append后的扩容机制？为什么还要+2？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/DMingO/p/13407303.html</dc:identifier>
</item>
<item>
<title>3.深入k8s：Deployment控制器 - luozhiyun</title>
<link>http://www.cnblogs.com/luozhiyun/p/13407284.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/luozhiyun/p/13407284.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20200726183429.png&quot; alt=&quot;01d4985f180a37a8012066214a289c.png@1280w_1l_2o_100sh&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;Deployment可以做到很便捷的管理Pod，只需要在Deployment中描述一下希望的Pod状态时什么，包括定义Pod副本数、滚动升级和回滚应用、扩容和缩容、暂停和继续Deployment等，然后Deployment Controller就可以帮我们实现我们想要达到的状态。&lt;/p&gt;
&lt;p&gt;我们从一个例子入手：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.7.9
        ports:
        - containerPort: 80
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子中：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;我们定义了一个Deployment，名字叫nginx-deployment；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过spec.replicas字段定义了Pod的副本数是2；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过spec.selector字段定义了被打上app: nginx的标签的Pod才会被管理；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;tmplate字段定义了这个Deployment管理的Pod应该是怎样的，具有怎样的属性；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总的来说一个Deploymet控制器可以由两部分组成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.luozhiyun.com/20200726182710.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;replicaset&quot;&gt;ReplicaSet&lt;/h3&gt;
&lt;p&gt;ReplicaSet是一个副本控制器，ReplicaSet可以用selector来控制Pod的数量，而Deployments是一个更高层次的概念，它管理ReplicaSets，并提供对pod的声明性更新以及许多其他的功能。&lt;/p&gt;
&lt;p&gt;Deployment通过控制ReplicaSet的个数来和属性，进而实现“水平扩展 / 收缩”和“滚动更新”这两个编排动作。&lt;/p&gt;
&lt;h3 id=&quot;水平扩展与滚动更新&quot;&gt;水平扩展与滚动更新&lt;/h3&gt;
&lt;p&gt;我们可以通过下面这个命令来创建Deployment：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl create -f nginx-deployment.yaml --record
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里–record 参数作用是记录下你每次操作所执行的命令，以方便后面查看。&lt;/p&gt;
&lt;p&gt;检查一下Deployment状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl get deployments

NAME               READY   UP-TO-DATE   AVAILABLE   AGE
nginx-deployment   2/2     2            2           33m
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;NAME：列举出Deployments 的名字；&lt;/li&gt;
&lt;li&gt;READY：显示了多少个应用的副本是可用的，目前副本数/期望副本数；&lt;/li&gt;
&lt;li&gt;UP-TO-DATE：显示了副本更新的次数，这里显示为2，说明已经做过2此更新；&lt;/li&gt;
&lt;li&gt;AVAILABLE：显示了多少个应用的副本是可用的；&lt;/li&gt;
&lt;li&gt;AGE：显示了应用运行的时间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;现在我们使用kubectl scale来做一个水平扩展：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl scale deployment nginx-deployment --replicas=4

deployment.apps/nginx-deployment scaled
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们可以使用rollout status来查看滚动更新的状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl rollout status deployment/nginx-deployment


Waiting for deployment &quot;nginx-deployment&quot; rollout to finish: 2 of 4 updated replicas are available...
Waiting for deployment &quot;nginx-deployment&quot; rollout to finish: 3 of 4 updated replicas are available...
deployment &quot;nginx-deployment&quot; successfully rolled out
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的3 of 4 updated replicas are available表示已经有3个Pod进入了UP-TO-DATE 状态。&lt;/p&gt;
&lt;p&gt;然后我们还可以查看一下ReplicaSet状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl get rs

NAME                         DESIRED   CURRENT   READY   AGE
nginx-deployment-9754ccbdf   4         4         4       44m
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在运行了一个Deployment修改后，Deployment Controller会创建一个副本为ReplicaSet，并会生成一串随机字符，ReplicaSet 会把这个随机字符串加在它所控制的所有 Pod 的标签里，从而保证这些 Pod 不会与集群里的其他 Pod 混淆。&lt;/p&gt;
&lt;p&gt;我们可以通过 kubectl get pods --show-labels来查看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NAME                               READY   STATUS    RESTARTS   AGE    LABELS
nginx-deployment-9754ccbdf-5pl2j   1/1     Running   0          5m4s   app=nginx,pod-template-hash=9754ccbdf
nginx-deployment-9754ccbdf-67d4g   1/1     Running   0          48m    app=nginx,pod-template-hash=9754ccbdf
nginx-deployment-9754ccbdf-9drgb   1/1     Running   0          48m    app=nginx,pod-template-hash=9754ccbdf
nginx-deployment-9754ccbdf-fdmrx   1/1     Running   0          5m4s   app=nginx,pod-template-hash=9754ccbdf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们看看Deployment的滚动更新是如何做的：&lt;/p&gt;
&lt;p&gt;我们使用set image 来修改deployment中的镜像&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1 --record

deployment.apps/nginx-deployment image updated
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们可以通过kubectl describe查看滚动更新的过程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 
$ kubectl describe deployment nginx-deployment
...
Events:
  Type    Reason             Age   From                   Message
  ----    ------             ----  ----                   -------
...
 Normal  ScalingReplicaSet  29s                 deployment-controller  Scaled down replica set nginx-deployment-9754ccbdf to 3
  Normal  ScalingReplicaSet  29s                 deployment-controller  Scaled up replica set nginx-deployment-dc46b5ffc to 2
  Normal  ScalingReplicaSet  12s (x2 over 11m)   deployment-controller  Scaled down replica set nginx-deployment-9754ccbdf to 2
  Normal  ScalingReplicaSet  12s                 deployment-controller  Scaled up replica set nginx-deployment-dc46b5ffc to 3
  Normal  ScalingReplicaSet  11s                 deployment-controller  Scaled down replica set nginx-deployment-9754ccbdf to 1
  Normal  ScalingReplicaSet  11s                 deployment-controller  Scaled up replica set nginx-deployment-dc46b5ffc to 4
  Normal  ScalingReplicaSet  11s                 deployment-controller  Scaled down replica set nginx-deployment-9754ccbdf to 0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到Deployment Controller控制ReplicaSet将旧的Pod 副本数一个个减少，并创建一个新的ReplicaSet：nginx-deployment-dc46b5ffc，并将其控制的Pod副本数一个个增加。&lt;/p&gt;
&lt;p&gt;在这个“滚动更新”过程完成之后，你可以查看一下新、旧两个 ReplicaSet 的最终状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl get rs

NAME                         DESIRED   CURRENT   READY   AGE
nginx-deployment-9754ccbdf   0         0         0       57m
nginx-deployment-dc46b5ffc   4         4         4       5m9s
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认的情况下，Deployment 会保至少有75%的Pod还是可用的，所以我们的例子中，会保证至少有3个Pod是出于可用的状态。&lt;/p&gt;
&lt;p&gt;这个策略，是 Deployment 对象的一个字段，名叫 RollingUpdateStrategy，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; kubectl describe deployment
 
 
Name:                   nginx-deployment
...
Selector:               app=nginx
Replicas:               4 desired | 4 updated | 4 total | 4 available | 0 unavailable
StrategyType:           RollingUpdate
MinReadySeconds:        0
RollingUpdateStrategy:  25% max unavailable, 25% max surge
...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;25% max unavailable表示最大25%不可用；25% max surge表示最多可以创建多少个新的Pod。&lt;/p&gt;
&lt;h3 id=&quot;版本控制与回滚&quot;&gt;版本控制与回滚&lt;/h3&gt;
&lt;p&gt;在上面的操作中，我们将nginx的版本设置成了1.16.1，现在我们可以通过rollout undo来进行版本的回滚：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl rollout undo deployment/nginx-deployment

deployment.apps/nginx-deployment rolled back
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然除了这个命令以外由于我们使用了--record，所以我们可以通过kubectl rollout history 来查看版本信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl rollout history deployment/nginx-deployment

deployment.apps/nginx-deployment
REVISION  CHANGE-CAUSE
2         kubectl set image deployment/nginx-deployment nginx=nginx:1.16.1 --record=true
3         kubectl apply --filename=nginx-deployment.yaml --record=true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过kubectl rollout history来看到相应版本的具体信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl rollout history deployment/nginx-deployment --revision=2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过kubectl rollout undo命令来回滚到相应的版本：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl rollout undo deployment/nginx-deployment --to-revision=2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;pausing-和resuming-一个deployment&quot;&gt;Pausing 和Resuming 一个Deployment&lt;/h3&gt;
&lt;p&gt;我们在上面的操作中，每进行一步操作都会进行一次滚动更新，如果我们想一次性执行多条命令然后再一次性滚动更新，那么可以先pause Deployment然后操作完之后再resume 它。&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl rollout pause deployment/nginx-deployment

deployment.apps/nginx-deployment paused
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以随意的修改这个 Deployment 的内容了。由于此时 Deployment 正处于“暂停”状态，所以我们对 Deployment 的所有修改，都不会触发新的“滚动更新”，也不会创建新的 ReplicaSet。&lt;/p&gt;
&lt;p&gt;操作完之后再执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;kubectl rollout resume deployment/nginx-deployment

deployment.apps/nginx-deployment resumed
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 kubectl rollout pause 指令之后的这段时间里，我们对 Deployment 进行的所有修改，最后只会触发一次“滚动更新”。&lt;/p&gt;
</description>
<pubDate>Thu, 30 Jul 2020 15:35:00 +0000</pubDate>
<dc:creator>luozhiyun</dc:creator>
<og:description>Deployment可以做到很便捷的管理Pod，只需要在Deployment中描述一下希望的Pod状态时什么，包括定义Pod副本数、滚动升级和回滚应用、扩容和缩容、暂停和继续Deployment等，然</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/luozhiyun/p/13407284.html</dc:identifier>
</item>
<item>
<title>使用jsdelivr + GitHub + PicGo搭建免费图床 - Sean2Y</title>
<link>http://www.cnblogs.com/SeanYoung/p/13407250.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SeanYoung/p/13407250.html</guid>
<description>&lt;p&gt;分享一个免费的图床搭建教程，使用jsdelivr + GitHub + PicGo搭建免费图床&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;66.224121557455&quot;&gt;

&lt;p&gt;之前一直有开通有道云笔记会员，主要是为了会员markdown图片可以在线保存的功能，前一阵子会员到期，考虑这个功能可不可以自己单独实现，从而替代使用有道云会员。&lt;/p&gt;
&lt;p&gt;通过网上搜索的方式，查询到了几种搭建图床的方案，但最终考虑图床的稳定性，我选择了GitHub作为图床。&lt;/p&gt;
&lt;p&gt;使用到的资源链接：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. 登陆GitHub创建库&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sean2y/markdown-pics/images/20200730221918.png&quot;/&gt;&lt;p&gt;&lt;strong&gt;2. 随便起个名字，点击创建库，记住创建的库名&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sean2y/markdown-pics/images/20200730222048.png&quot;/&gt;&lt;p&gt;&lt;strong&gt;3. 创建成功后，获取GitHub的token，为之后的PicGo使用&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;10&quot;&gt;&lt;li&gt;
&lt;p&gt;点击账户的设置&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sean2y/markdown-pics/images/20200730223018.png&quot;/&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入开发者设置&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sean2y/markdown-pics/images/20200730223329.png&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;选择生成新的token（这里我已经生成了，所以显示有过记录）&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sean2y/markdown-pics/images/20200730223505.png&quot;/&gt;&lt;/li&gt;
&lt;li readability=&quot;22.5&quot;&gt;
&lt;p&gt;这是随便输入就好，权限选择这里所有选项全部选中（截图没有截全），点击最下方生成按钮，并将token保存&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sean2y/markdown-pics/images/20200730233240.png&quot;/&gt;
&lt;p&gt;&lt;strong&gt;1. 根据地址下载符合自己系统的PicGo工具，并打开&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 点击左侧图床设置，选择GitHub图床&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sean2y/markdown-pics/images/20200730225215.png&quot;/&gt;&lt;p&gt;&lt;strong&gt;3. 进行GitHub图床设置&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sean2y/markdown-pics/images/20200730225408.png&quot;/&gt;&lt;ul&gt;&lt;li&gt;仓库名：用户名/之前设置的库名&lt;/li&gt;
&lt;li&gt;分支名：master&lt;/li&gt;
&lt;li&gt;设定Token：之前获取到的token&lt;/li&gt;
&lt;li&gt;指定存储路径：可以随便写，设置之后，上传的图片会保存到库下的该目录下&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;点击确定和设定默认图床&lt;/p&gt;

&lt;p&gt;由于GitHub国内访问速度慢，所以可以考虑使用CDN优化加速进行访问，这里选择免费的jsdeliver进行CDN优化。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;jsDelivr 是一个免费开源的 CDN 解决方案，用于帮助开发者和站长。包含 JavaScript 库、jQuery 插件、CSS 框架、字体等等 Web 上常用的静态资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这里在自定义域名设置jsdeliver前缀&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;https://cdn.jsdelivr.net/gh/用户名/库名&lt;/code&gt;&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sean2y/markdown-pics/images/20200730230412.png&quot;/&gt;&lt;hr/&gt;&lt;p&gt;至此，配置已完成，可以点击PicGo的上传区，上传图片测试一下，成功后，图片会保存到GitHub，软件的相册中也会存在上传的图片；&lt;/p&gt;
&lt;p&gt;也可使用截图软件进行截图，同时截图完成后会在软件的快捷栏中存在，点击上传后，会自动上传至图床，同时图片链接会保存在剪切板中。&lt;/p&gt;
&lt;img src=&quot;https://cdn.jsdelivr.net/gh/Sean2y/markdown-pics/images/20200730232148.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;</description>
<pubDate>Thu, 30 Jul 2020 15:24:00 +0000</pubDate>
<dc:creator>Sean2Y</dc:creator>
<og:description>分享一个免费的图床搭建教程，使用jsdelivr + GitHub + PicGo搭建免费图床</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/SeanYoung/p/13407250.html</dc:identifier>
</item>
</channel>
</rss>