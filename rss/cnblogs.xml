<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C# 9.0 新特性之目标类型推导 new 表达式 - LiamWang</title>
<link>http://www.cnblogs.com/willick/p/13139093.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13139093.html</guid>
<description>&lt;p&gt;阅读本文大概需要 2 分钟。&lt;/p&gt;
&lt;p&gt;呼~~，每次过完一个周末，写作就失去了动力，一两天才能缓过来。尽管如此，还是要坚持写好每一篇文章的。宁缺毋滥嘛，宁愿发文的频率低一点，也要保证文章的质量，至少排版不能差，行文要流畅，错别字不能有。&lt;/p&gt;
&lt;p&gt;关于&lt;strong&gt;类型推导&lt;/strong&gt;想必大家都很熟悉，它是在 var 关键字引入的时候引入 C# 的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;var i = 10;
var u = new User();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译器会通过右边的字面量自动推导左边变量的类型，这种推导方式可以归纳为：从上下文右边推导出左边的类型。我们不妨把它称为&lt;strong&gt;源类型推导&lt;/strong&gt;（Source-typed inferring，参考 Target-typed 自创的术语）。&lt;/p&gt;
&lt;p&gt;相应的，有源类型推导就有&lt;strong&gt;目标类型推导&lt;/strong&gt; (Target-typed inferring)，它是指从上下文左边推导出右边的类型。比如数组的初始化和 Lambda 表达式常常是目标类型推导的表达式。举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;// 没有使用类型推导
string[] s = new string[] { &quot;a&quot;, &quot;b&quot; };
// 目标类型推导（左推右）
string[] s = new { &quot;a&quot;, &quot;b&quot; };
string[] s = new [] { &quot;a&quot;, &quot;b&quot; };

// 没有使用类型推导
Users.FirstOrDefault&amp;lt;User&amp;gt;(u =&amp;gt; u.id = 123);
// 目标类型推导（左推右）
Users.FirstOrDefault(u =&amp;gt; u.id = 123);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次在 C# 9 中，增加了用户定义类型 new 表达式的目标类型推导，即通过上下文左边自动推导 new 表达式的类型，从而在使用 new 构造时省略类型的指定，请看示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;// C# 9 之前
Point p = new Point(3, 5);

// C# 9
Point p = new (3, 5);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除此之外，C# 9 也增加了操作符 &lt;code&gt;??&lt;/code&gt; 和 &lt;code&gt;?:&lt;/code&gt; 的目标类型推导支持。之前这两个操作符必须要求两边的操作对象都是相同的类型，否则会编译报错。而在 C# 9 中，只要目标类型是操作对象共同的基类就不再会编译报错了，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;// Student 和 Customer 拥有共同的父类 Person
Person person = (Person)(student ?? customer); // C# 9 之前
Person person = student ?? customer; // C# 9

// 可空类型，0 和 null 都可以隐式转换为 int? 类型
int? result = b ? 0 : (int?)null; // C# 9 之前
int? result = b ? 0 : null; // C# 9
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实本文的核心就一句代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cs&quot;&gt;Point p = new (3, 5);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;却一不小心啰嗦了这么一堆。但讲真，学习新的知识不是要死记硬背，而要学会归类推理，举一反三，经常思考，最好能形成自己的一种思维习惯，这样学习才会变成一件水到渠成的事。多看我的文章，希望你能学到的不仅仅是生硬的编程知识点，也希望我的行文风格和思维习惯对你有所启发。&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jun 2020 00:55:00 +0000</pubDate>
<dc:creator>LiamWang</dc:creator>
<og:description>阅读本文大概需要 2 分钟。 呼~~，每次过完一个周末，写作就失去了动力，一两天才能缓过来。尽管如此，还是要坚持写好每一篇文章的。宁缺毋滥嘛，宁愿发文的频率低一点，也要保证文章的质量，至少排版不能差，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13139093.html</dc:identifier>
</item>
<item>
<title>基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（七） - 阿星Plus</title>
<link>http://www.cnblogs.com/meowv/p/13124533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/meowv/p/13124533.html</guid>
<description>&lt;h2 id=&quot;系列文章&quot;&gt;系列文章&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12896177.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12896898.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12909558.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 完善与美化，Swagger登场&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12913676.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 数据访问和代码优先&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12916613.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 自定义仓储之增删改查&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12924409.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 统一规范API，包装返回模型&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12924859.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 再说Swagger，分组、描述、小绿锁&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12935693.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 接入GitHub，用JWT保护你的API&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12943699.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 异常处理和日志记录&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12956696.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 使用Redis缓存数据&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12961014.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 集成Hangfire实现定时任务处理&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12966092.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 用AutoMapper搞定对象映射&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12971041.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12974439.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12980301.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 定时任务最佳实战（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12987623.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/12994914.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13039883.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13043084.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（四）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13046603.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - 博客接口实战篇（五）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13061975.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（一）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13065295.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（二）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13081035.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（三）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13088303.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（四）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13096000.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（五）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/meowv/p/13124303.html&quot;&gt;基于 abp vNext 和 .NET Core 开发博客项目 - Blazor 实战系列（六）&lt;/a&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;hr/&gt;&lt;p&gt;上一篇完成了后台分类模块的所有功能，本篇继续将标签模块和友情链接模块的增删改查完成。&lt;/p&gt;
&lt;h2 id=&quot;标签管理&quot;&gt;标签管理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/891843/202006/891843-20200614140152811-948105756.png&quot; alt=&quot;1&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现方式和之前的分类管理是一样的，在Admin文件夹下面添加&lt;code&gt;Tags.razor&lt;/code&gt;组件，设置路由&lt;code&gt;@page &quot;/admin/tags&quot;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同样的内容也需要放在&lt;code&gt;AdminLayout&lt;/code&gt;组件下面，添加几个参数：弹窗状态&lt;code&gt;bool Open&lt;/code&gt;、新增或更新时标签字段&lt;code&gt;string tagName, displayName&lt;/code&gt;、更新时的标签Id&lt;code&gt;int id&lt;/code&gt;、API返回的标签列表接收参数&lt;code&gt;ServiceResult&amp;lt;IEnumerable&amp;lt;QueryTagForAdminDto&amp;gt;&amp;gt; tags&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 默认隐藏Box
/// &amp;lt;/summary&amp;gt;
private bool Open { get; set; } = false;

/// &amp;lt;summary&amp;gt;
/// 新增或者更新时候的标签字段值
/// &amp;lt;/summary&amp;gt;
private string tagName, displayName;

/// &amp;lt;summary&amp;gt;
/// 更新标签的Id值
/// &amp;lt;/summary&amp;gt;
private int id;

/// &amp;lt;summary&amp;gt;
/// API返回的标签列表数据
/// &amp;lt;/summary&amp;gt;
private ServiceResult&amp;lt;IEnumerable&amp;lt;QueryTagForAdminDto&amp;gt;&amp;gt; tags;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;//QueryTagForAdminDto.cs
namespace Meowv.Blog.BlazorApp.Response.Blog
{
    public class QueryTagForAdminDto : QueryTagDto
    {
        /// &amp;lt;summary&amp;gt;
        /// 主键
        /// &amp;lt;/summary&amp;gt;
        public int Id { get; set; }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在初始化方法&lt;code&gt;OnInitializedAsync()&lt;/code&gt;中获取数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 初始化
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
protected override async Task OnInitializedAsync()
{
    var token = await Common.GetStorageAsync(&quot;token&quot;);
    Http.DefaultRequestHeaders.Add(&quot;Authorization&quot;, $&quot;Bearer {token}&quot;);

    tags = await FetchData();
}

/// &amp;lt;summary&amp;gt;
/// 获取数据
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
private async Task&amp;lt;ServiceResult&amp;lt;IEnumerable&amp;lt;QueryTagForAdminDto&amp;gt;&amp;gt;&amp;gt; FetchData()
{
    return await Http.GetFromJsonAsync&amp;lt;ServiceResult&amp;lt;IEnumerable&amp;lt;QueryTagForAdminDto&amp;gt;&amp;gt;&amp;gt;(&quot;/blog/admin/tags&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意需要设置请求头，进行授权访问，然后页面上绑定数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;AdminLayout&amp;gt;
    @if (tags == null)
    {
        &amp;lt;Loading /&amp;gt;
    }
    else
    {
        &amp;lt;div class=&quot;post-wrap tags&quot;&amp;gt;
            &amp;lt;h2 class=&quot;post-title&quot;&amp;gt;-&amp;amp;nbsp;Tags&amp;amp;nbsp;-&amp;lt;/h2&amp;gt;
            @if (tags.Success &amp;amp;&amp;amp; tags.Result.Any())
            {
                &amp;lt;div class=&quot;categories-card&quot;&amp;gt;
                    @foreach (var item in tags.Result)
                    {
                        &amp;lt;div class=&quot;card-item&quot;&amp;gt;
                            &amp;lt;div class=&quot;categories&quot;&amp;gt;
                                &amp;lt;NavLink title=&quot;❌删除&quot; @onclick=&quot;@(async () =&amp;gt; await DeleteAsync(item.Id))&quot;&amp;gt;❌&amp;lt;/NavLink&amp;gt;
                                &amp;lt;NavLink title=&quot;📝编辑&quot; @onclick=&quot;@(() =&amp;gt; ShowBox(item))&quot;&amp;gt;📝&amp;lt;/NavLink&amp;gt;
                                &amp;lt;NavLink target=&quot;_blank&quot; href=&quot;@($&quot;/tag/{item.DisplayName}&quot;)&quot;&amp;gt;
                                    &amp;lt;h3&amp;gt;@item.TagName&amp;lt;/h3&amp;gt;
                                    &amp;lt;small&amp;gt;(@item.Count)&amp;lt;/small&amp;gt;
                                &amp;lt;/NavLink&amp;gt;
                            &amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;
                    }
                    &amp;lt;div class=&quot;card-item&quot;&amp;gt;
                        &amp;lt;div class=&quot;categories&quot;&amp;gt;
                            &amp;lt;NavLink&amp;gt;&amp;lt;h3 @onclick=&quot;@(() =&amp;gt; ShowBox())&quot;&amp;gt;📘~~~ 新增标签 ~~~📘&amp;lt;/h3&amp;gt;&amp;lt;/NavLink&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
            }
            else
            {
                &amp;lt;ErrorTip /&amp;gt;
            }
        &amp;lt;/div&amp;gt;

        &amp;lt;Box OnClickCallback=&quot;@SubmitAsync&quot; Open=&quot;@Open&quot;&amp;gt;
            &amp;lt;div class=&quot;box-item&quot;&amp;gt;
                &amp;lt;b&amp;gt;DisplayName：&amp;lt;/b&amp;gt;&amp;lt;input type=&quot;text&quot; @bind=&quot;@displayName&quot; @bind:event=&quot;oninput&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;box-item&quot;&amp;gt;
                &amp;lt;b&amp;gt;TagName：&amp;lt;/b&amp;gt;&amp;lt;input type=&quot;text&quot; @bind=&quot;@tagName&quot; @bind:event=&quot;oninput&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/Box&amp;gt;
    }
&amp;lt;/AdminLayout&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;tags&lt;/code&gt;没获取到数据的时候显示&lt;code&gt;&amp;lt;Loading /&amp;gt;&lt;/code&gt;组件内容，循环遍历数据进行绑定，删除按钮绑定点击事件调用&lt;code&gt;DeleteAsync()&lt;/code&gt;方法。新增和编辑按钮点击事件调用&lt;code&gt;ShowBox()&lt;/code&gt;方法显示弹窗。新增的时候不需要传递参数，编辑的时候需要将当前item即&lt;code&gt;QueryTagForAdminDto&lt;/code&gt;传递进去。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;Box&amp;gt;&lt;/code&gt;组件中绑定了标签的两个参数，是否打开参数&lt;code&gt;Opne&lt;/code&gt;和确认按钮回调事件方法&lt;code&gt;SubmitAsync()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;删除标签的方法&lt;code&gt;DeleteAsync(...)&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// 弹窗确认
bool confirmed = await Common.InvokeAsync&amp;lt;bool&amp;gt;(&quot;confirm&quot;, &quot;\n💥💢真的要干掉这个该死的标签吗💢💥&quot;);

if (confirmed)
{
    var response = await Http.DeleteAsync($&quot;/blog/tag?id={id}&quot;);

    var result = await response.Content.ReadFromJsonAsync&amp;lt;ServiceResult&amp;gt;();

    if (result.Success)
    {
        tags = await FetchData();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;删除之前进行二次确认，避免误伤，删除成功重新加载一遍数据。&lt;/p&gt;
&lt;p&gt;弹窗的方法&lt;code&gt;ShowBox(...)&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 显示box，绑定字段
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;param name=&quot;dto&quot;&amp;gt;&amp;lt;/param&amp;gt;
private void ShowBox(QueryTagForAdminDto dto = null)
{
    Open = true;
    id = 0;

    // 新增
    if (dto == null)
    {
        displayName = null;
        tagName = null;
    }
    else // 更新
    {
        id = dto.Id;
        displayName = dto.DisplayName;
        tagName = dto.TagName;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后在弹窗中确认按钮的回调事件方法&lt;code&gt;SubmitAsync()&lt;/code&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 确认按钮点击事件
/// &amp;lt;/summary&amp;gt;
/// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
private async Task SubmitAsync()
{
    var input = new EditTagInput()
    {
        DisplayName = displayName.Trim(),
        TagName = tagName.Trim()
    };

    if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.TagName))
    {
        return;
    }

    var responseMessage = new HttpResponseMessage();

    if (id &amp;gt; 0)
        responseMessage = await Http.PutAsJsonAsync($&quot;/blog/tag?id={id}&quot;, input);
    else
        responseMessage = await Http.PostAsJsonAsync(&quot;/blog/tag&quot;, input);

    var result = await responseMessage.Content.ReadFromJsonAsync&amp;lt;ServiceResult&amp;gt;();
    if (result.Success)
    {
        tags = await FetchData();
        Open = false;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输入参数&lt;code&gt;EditTagInput&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;namespace Meowv.Blog.BlazorApp.Response.Blog
{
    public class EditTagInput : TagDto
    {
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终执行新增或者更新数据都在点击事件中进行，将变量的值赋值给&lt;code&gt;EditTagInput&lt;/code&gt;，根据id判断走新增还是更新，成功后重新加载数据，关掉弹窗。&lt;/p&gt;
&lt;p&gt;标签管理页面全部代码如下：&lt;/p&gt;
&lt;details readability=&quot;11&quot;&gt;点击查看代码
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;@page &quot;/admin/categories&quot;

&amp;lt;AdminLayout&amp;gt;
    @if (categories == null)
    {
        &amp;lt;Loading /&amp;gt;
    }
    else
    {
        &amp;lt;div class=&quot;post-wrap categories&quot;&amp;gt;
            &amp;lt;h2 class=&quot;post-title&quot;&amp;gt;-&amp;amp;nbsp;Categories&amp;amp;nbsp;-&amp;lt;/h2&amp;gt;
            @if (categories.Success &amp;amp;&amp;amp; categories.Result.Any())
            {
                &amp;lt;div class=&quot;categories-card&quot;&amp;gt;
                    @foreach (var item in categories.Result)
                    {
                        &amp;lt;div class=&quot;card-item&quot;&amp;gt;
                            &amp;lt;div class=&quot;categories&quot;&amp;gt;
                                &amp;lt;NavLink title=&quot;❌删除&quot; @onclick=&quot;@(async () =&amp;gt; await DeleteAsync(item.Id))&quot;&amp;gt;❌&amp;lt;/NavLink&amp;gt;
                                &amp;lt;NavLink title=&quot;📝编辑&quot; @onclick=&quot;@(() =&amp;gt; ShowBox(item))&quot;&amp;gt;📝&amp;lt;/NavLink&amp;gt;
                                &amp;lt;NavLink target=&quot;_blank&quot; href=&quot;@($&quot;/category/{item.DisplayName}&quot;)&quot;&amp;gt;
                                    &amp;lt;h3&amp;gt;@item.CategoryName&amp;lt;/h3&amp;gt;
                                    &amp;lt;small&amp;gt;(@item.Count)&amp;lt;/small&amp;gt;
                                &amp;lt;/NavLink&amp;gt;
                            &amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;
                    }
                    &amp;lt;div class=&quot;card-item&quot;&amp;gt;
                        &amp;lt;div class=&quot;categories&quot;&amp;gt;
                            &amp;lt;NavLink&amp;gt;&amp;lt;h3 @onclick=&quot;@(() =&amp;gt; ShowBox())&quot;&amp;gt;📕~~~ 新增分类 ~~~📕&amp;lt;/h3&amp;gt;&amp;lt;/NavLink&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
            }
            else
            {
                &amp;lt;ErrorTip /&amp;gt;
            }
        &amp;lt;/div&amp;gt;

        &amp;lt;Box OnClickCallback=&quot;@SubmitAsync&quot; Open=&quot;@Open&quot;&amp;gt;
            &amp;lt;div class=&quot;box-item&quot;&amp;gt;
                &amp;lt;b&amp;gt;DisplayName：&amp;lt;/b&amp;gt;&amp;lt;input type=&quot;text&quot; @bind=&quot;@displayName&quot; @bind:event=&quot;oninput&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;box-item&quot;&amp;gt;
                &amp;lt;b&amp;gt;CategoryName：&amp;lt;/b&amp;gt;&amp;lt;input type=&quot;text&quot; @bind=&quot;@categoryName&quot; @bind:event=&quot;oninput&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/Box&amp;gt;
    }
&amp;lt;/AdminLayout&amp;gt;

@code {
    /// &amp;lt;summary&amp;gt;
    /// 默认隐藏Box
    /// &amp;lt;/summary&amp;gt;
    private bool Open { get; set; } = false;

    /// &amp;lt;summary&amp;gt;
    /// 新增或者更新时候的分类字段值
    /// &amp;lt;/summary&amp;gt;
    private string categoryName, displayName;

    /// &amp;lt;summary&amp;gt;
    /// 更新分类的Id值
    /// &amp;lt;/summary&amp;gt;
    private int id;

    /// &amp;lt;summary&amp;gt;
    /// API返回的分类列表数据
    /// &amp;lt;/summary&amp;gt;
    private ServiceResult&amp;lt;IEnumerable&amp;lt;QueryCategoryForAdminDto&amp;gt;&amp;gt; categories;

    /// &amp;lt;summary&amp;gt;
    /// 初始化
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    protected override async Task OnInitializedAsync()
    {
        var token = await Common.GetStorageAsync(&quot;token&quot;);
        Http.DefaultRequestHeaders.Add(&quot;Authorization&quot;, $&quot;Bearer {token}&quot;);

        categories = await FetchData();
    }

    /// &amp;lt;summary&amp;gt;
    /// 获取数据
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private async Task&amp;lt;ServiceResult&amp;lt;IEnumerable&amp;lt;QueryCategoryForAdminDto&amp;gt;&amp;gt;&amp;gt; FetchData()
    {
        return await Http.GetFromJsonAsync&amp;lt;ServiceResult&amp;lt;IEnumerable&amp;lt;QueryCategoryForAdminDto&amp;gt;&amp;gt;&amp;gt;(&quot;/blog/admin/categories&quot;);
    }

    /// &amp;lt;summary&amp;gt;
    /// 删除分类
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private async Task DeleteAsync(int id)
    {
        Open = false;

        // 弹窗确认
        bool confirmed = await Common.InvokeAsync&amp;lt;bool&amp;gt;(&quot;confirm&quot;, &quot;\n💥💢真的要干掉这个该死的分类吗💢💥&quot;);

        if (confirmed)
        {
            var response = await Http.DeleteAsync($&quot;/blog/category?id={id}&quot;);

            var result = await response.Content.ReadFromJsonAsync&amp;lt;ServiceResult&amp;gt;();

            if (result.Success)
            {
                categories = await FetchData();
            }
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 显示box，绑定字段
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;dto&quot;&amp;gt;&amp;lt;/param&amp;gt;
    private void ShowBox(QueryCategoryForAdminDto dto = null)
    {
        Open = true;
        id = 0;

        // 新增
        if (dto == null)
        {
            displayName = null;
            categoryName = null;
        }
        else // 更新
        {
            id = dto.Id;
            displayName = dto.DisplayName;
            categoryName = dto.CategoryName;
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 确认按钮点击事件
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private async Task SubmitAsync()
    {
        var input = new EditCategoryInput()
        {
            DisplayName = displayName.Trim(),
            CategoryName = categoryName.Trim()
        };

        if (string.IsNullOrEmpty(input.DisplayName) || string.IsNullOrEmpty(input.CategoryName))
        {
            return;
        }

        var responseMessage = new HttpResponseMessage();

        if (id &amp;gt; 0)
            responseMessage = await Http.PutAsJsonAsync($&quot;/blog/category?id={id}&quot;, input);
        else
            responseMessage = await Http.PostAsJsonAsync(&quot;/blog/category&quot;, input);

        var result = await responseMessage.Content.ReadFromJsonAsync&amp;lt;ServiceResult&amp;gt;();
        if (result.Success)
        {
            categories = await FetchData();
            Open = false;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/details&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/891843/202006/891843-20200614140618426-215255984.gif&quot; alt=&quot;2&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;友链管理&quot;&gt;友链管理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/891843/202006/891843-20200614141515594-754366555.png&quot; alt=&quot;3&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现方式都是一样的，这个就不多说了，直接上代码。&lt;/p&gt;
&lt;p&gt;先将API返回的接收参数和新增编辑的输入参数添加一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;//QueryFriendLinkForAdminDto.cs
namespace Meowv.Blog.BlazorApp.Response.Blog
{
    public class QueryFriendLinkForAdminDto : FriendLinkDto
    {
        /// &amp;lt;summary&amp;gt;
        /// 主键
        /// &amp;lt;/summary&amp;gt;
        public int Id { get; set; }
    }
}

//EditFriendLinkInput.cs
namespace Meowv.Blog.BlazorApp.Response.Blog
{
    public class EditFriendLinkInput : FriendLinkDto
    {
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;@page &quot;/admin/friendlinks&quot;

&amp;lt;AdminLayout&amp;gt;
    @if (friendlinks == null)
    {
        &amp;lt;Loading /&amp;gt;
    }
    else
    {
        &amp;lt;div class=&quot;post-wrap categories&quot;&amp;gt;
            &amp;lt;h2 class=&quot;post-title&quot;&amp;gt;-&amp;amp;nbsp;FriendLinks&amp;amp;nbsp;-&amp;lt;/h2&amp;gt;
            @if (friendlinks.Success &amp;amp;&amp;amp; friendlinks.Result.Any())
            {
                &amp;lt;div class=&quot;categories-card&quot;&amp;gt;
                    @foreach (var item in friendlinks.Result)
                    {
                        &amp;lt;div class=&quot;card-item&quot;&amp;gt;
                            &amp;lt;div class=&quot;categories&quot;&amp;gt;
                                &amp;lt;NavLink title=&quot;❌删除&quot; @onclick=&quot;@(async () =&amp;gt; await DeleteAsync(item.Id))&quot;&amp;gt;❌&amp;lt;/NavLink&amp;gt;
                                &amp;lt;NavLink title=&quot;📝编辑&quot; @onclick=&quot;@(() =&amp;gt; ShowBox(item))&quot;&amp;gt;📝&amp;lt;/NavLink&amp;gt;
                                &amp;lt;NavLink target=&quot;_blank&quot; href=&quot;@item.LinkUrl&quot;&amp;gt;
                                    &amp;lt;h3&amp;gt;@item.Title&amp;lt;/h3&amp;gt;
                                &amp;lt;/NavLink&amp;gt;
                            &amp;lt;/div&amp;gt;
                        &amp;lt;/div&amp;gt;
                    }
                    &amp;lt;div class=&quot;card-item&quot;&amp;gt;
                        &amp;lt;div class=&quot;categories&quot;&amp;gt;
                            &amp;lt;NavLink&amp;gt;&amp;lt;h3 @onclick=&quot;@(() =&amp;gt; ShowBox())&quot;&amp;gt;📒~~~ 新增友链 ~~~📒&amp;lt;/h3&amp;gt;&amp;lt;/NavLink&amp;gt;
                        &amp;lt;/div&amp;gt;
                    &amp;lt;/div&amp;gt;
                &amp;lt;/div&amp;gt;
            }
            else
            {
                &amp;lt;ErrorTip /&amp;gt;
            }
        &amp;lt;/div&amp;gt;

        &amp;lt;Box OnClickCallback=&quot;@SubmitAsync&quot; Open=&quot;@Open&quot;&amp;gt;
            &amp;lt;div class=&quot;box-item&quot;&amp;gt;
                &amp;lt;b&amp;gt;Title：&amp;lt;/b&amp;gt;&amp;lt;input type=&quot;text&quot; @bind=&quot;@title&quot; @bind:event=&quot;oninput&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;div class=&quot;box-item&quot;&amp;gt;
                &amp;lt;b&amp;gt;LinkUrl：&amp;lt;/b&amp;gt;&amp;lt;input type=&quot;text&quot; @bind=&quot;@linkUrl&quot; @bind:event=&quot;oninput&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/Box&amp;gt;
    }
&amp;lt;/AdminLayout&amp;gt;

@code {
    /// &amp;lt;summary&amp;gt;
    /// 默认隐藏Box
    /// &amp;lt;/summary&amp;gt;
    private bool Open { get; set; } = false;

    /// &amp;lt;summary&amp;gt;
    /// 新增或者更新时候的友链字段值
    /// &amp;lt;/summary&amp;gt;
    private string title, linkUrl;

    /// &amp;lt;summary&amp;gt;
    /// 更新友链的Id值
    /// &amp;lt;/summary&amp;gt;
    private int id;

    /// &amp;lt;summary&amp;gt;
    /// API返回的友链列表数据
    /// &amp;lt;/summary&amp;gt;
    private ServiceResult&amp;lt;IEnumerable&amp;lt;QueryFriendLinkForAdminDto&amp;gt;&amp;gt; friendlinks;

    /// &amp;lt;summary&amp;gt;
    /// 初始化
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    protected override async Task OnInitializedAsync()
    {
        var token = await Common.GetStorageAsync(&quot;token&quot;);
        Http.DefaultRequestHeaders.Add(&quot;Authorization&quot;, $&quot;Bearer {token}&quot;);

        friendlinks = await FetchData();
    }

    /// &amp;lt;summary&amp;gt;
    /// 获取数据
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private async Task&amp;lt;ServiceResult&amp;lt;IEnumerable&amp;lt;QueryFriendLinkForAdminDto&amp;gt;&amp;gt;&amp;gt; FetchData()
    {
        return await Http.GetFromJsonAsync&amp;lt;ServiceResult&amp;lt;IEnumerable&amp;lt;QueryFriendLinkForAdminDto&amp;gt;&amp;gt;&amp;gt;(&quot;/blog/admin/friendlinks&quot;);
    }

    /// &amp;lt;summary&amp;gt;
    /// 删除分类
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;id&quot;&amp;gt;&amp;lt;/param&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private async Task DeleteAsync(int id)
    {
        Open = false;

        // 弹窗确认
        bool confirmed = await Common.InvokeAsync&amp;lt;bool&amp;gt;(&quot;confirm&quot;, &quot;\n💥💢真的要干掉这个该死的分类吗💢💥&quot;);

        if (confirmed)
        {
            var response = await Http.DeleteAsync($&quot;/blog/friendlink?id={id}&quot;);

            var result = await response.Content.ReadFromJsonAsync&amp;lt;ServiceResult&amp;gt;();

            if (result.Success)
            {
                friendlinks = await FetchData();
            }
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 显示box，绑定字段
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;param name=&quot;dto&quot;&amp;gt;&amp;lt;/param&amp;gt;
    private void ShowBox(QueryFriendLinkForAdminDto dto = null)
    {
        Open = true;
        id = 0;

        // 新增
        if (dto == null)
        {
            title = null;
            linkUrl = null;
        }
        else // 更新
        {
            id = dto.Id;
            title = dto.Title;
            linkUrl = dto.LinkUrl;
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// 确认按钮点击事件
    /// &amp;lt;/summary&amp;gt;
    /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
    private async Task SubmitAsync()
    {
        var input = new EditFriendLinkInput()
        {
            Title = title.Trim(),
            LinkUrl = linkUrl.Trim()
        };

        if (string.IsNullOrEmpty(input.Title) || string.IsNullOrEmpty(input.LinkUrl))
        {
            return;
        }

        var responseMessage = new HttpResponseMessage();

        if (id &amp;gt; 0)
            responseMessage = await Http.PutAsJsonAsync($&quot;/blog/friendlink?id={id}&quot;, input);
        else
            responseMessage = await Http.PostAsJsonAsync(&quot;/blog/friendlink&quot;, input);

        var result = await responseMessage.Content.ReadFromJsonAsync&amp;lt;ServiceResult&amp;gt;();
        if (result.Success)
        {
            friendlinks = await FetchData();
            Open = false;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/891843/202006/891843-20200614143211653-1904701328.gif&quot; alt=&quot;3&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;截至目前为止，还剩下文章模块的功能还没做了，今天到这里吧，明天继续刚，未完待续...&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/Meowv/Blog/tree/blog_tutorial&quot;&gt;https://github.com/Meowv/Blog/tree/blog_tutorial&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jun 2020 00:54:00 +0000</pubDate>
<dc:creator>阿星Plus</dc:creator>
<og:description>系列文章 基于 abp vNext 和 .NET Core 开发博客项目 - 使用 abp cli 搭建项目 基于 abp vNext 和 .NET Core 开发博客项目 - 给项目瘦身，让它跑起来</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/meowv/p/13124533.html</dc:identifier>
</item>
<item>
<title>c#泛型是什么 - 大写的shyman</title>
<link>http://www.cnblogs.com/igqx/p/13139077.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/igqx/p/13139077.html</guid>
<description>&lt;!--[if IE]&gt;
    &lt;div class=&quot;unsupported-browser&quot;&gt;
        &amp;#35813;&amp;#39029;&amp;#38754;&amp;#19981;&amp;#25903;&amp;#25345; Internet Explorer &amp;#27983;&amp;#35272;&amp;#22120;&amp;#65292;&amp;#24314;&amp;#35758;&amp;#20351;&amp;#29992;
        &lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/&quot;&gt;Google Chrome&lt;/a&gt;,
        &lt;a href=&quot;https://www.mozilla.org/zh-CN/firefox/&quot;&gt;Firefox&lt;/a&gt; &amp;#25110;
        &lt;a href=&quot;https://www.microsoftedgeinsider.com/zh-CN/&quot;&gt;Microsoft Edge&lt;/a&gt;
    &lt;/div&gt;
&lt;![endif]--&gt;
    &lt;div class=&quot;center-container &quot;&gt;
        &lt;div class=&quot;center-body card  h-sm-100&quot;&gt;
            &lt;div class=&quot;card-body&quot;&gt;
                


&lt;div class=&quot;login-top text-center&quot;&gt;
    &lt;span class=&quot;login-title&quot;&gt;博客园用户登录&lt;/span&gt;
    &lt;a href=&quot;https://www.cnblogs.com/&quot;&gt;
        &lt;svg class=&quot;login-sign&quot;&gt;&lt;use xlink:href=&quot;#icon-login-sign&quot;/&gt;&lt;/svg&gt;&lt;/a&gt;
    &lt;p&gt;代码改变世界&lt;/p&gt;
&lt;/div&gt;
&lt;form id=&quot;loginForm&quot; method=&quot;post&quot; onsubmit=&quot;return false&quot;&gt;
    
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;1&quot; class=&quot;form-control&quot; placeholder=&quot;登录用户名 / 邮箱&quot; autofocus=&quot;&quot; type=&quot;text&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入登录用户名&quot; id=&quot;LoginName&quot; name=&quot;LoginName&quot; value=&quot;&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;LoginName&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/forgotloginname&quot;&gt;忘记登录用户名&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;form-group&quot;&gt;
            &lt;input tabindex=&quot;2&quot; class=&quot;form-control&quot; placeholder=&quot;密码&quot; type=&quot;password&quot; data-val=&quot;true&quot; data-val-required=&quot;请输入密码&quot; id=&quot;Password&quot; name=&quot;Password&quot;/&gt;&lt;span class=&quot;invalid-feedback field-validation-valid&quot; data-valmsg-for=&quot;Password&quot; data-valmsg-replace=&quot;true&quot;/&gt;
            &lt;a class=&quot;txt-forget-sign&quot; href=&quot;https://account.cnblogs.com/resetpassword&quot;&gt;忘记密码&lt;/a&gt;
        &lt;/div&gt;
        &lt;p&gt;
            &lt;input tabindex=&quot;3&quot; type=&quot;checkbox&quot; id=&quot;IsRemember&quot; name=&quot;IsRemember&quot; value=&quot;true&quot; class=&quot;custom-control-input&quot;/&gt;&lt;label class=&quot;custom-control-label&quot; for=&quot;IsRemember&quot;&gt;记住我&lt;/label&gt;
        &lt;/p&gt;

        &lt;button tabindex=&quot;4&quot; id=&quot;submitBtn&quot; type=&quot;submit&quot; class=&quot;btn-login btn btn-primary btn-sm ladda-button px-4&quot; data-style=&quot;slide-down&quot;&gt;
            &lt;span class=&quot;ladda-label&quot;&gt;登录&lt;/span&gt;
        &lt;/button&gt;
        &lt;div class=&quot;login-footer&quot;&gt;
            &lt;div class=&quot;ajax-error-box&quot;&gt;
                
            &lt;/div&gt;
            &lt;span&gt;没有账户，&lt;a href=&quot;https://account.cnblogs.com/signup&quot;&gt;立即注册&lt;/a&gt;&lt;/span&gt;
        &lt;/div&gt;
    
&lt;input name=&quot;__RequestVerificationToken&quot; type=&quot;hidden&quot; value=&quot;CfDJ8B9DwO68dQFBg9xIizKsC6SI-tOB6c2_LA41IkE2haSn3Cb_S5vAD30t6g3i41ugIEnIEH6fWUFK6UWkoK-p05Ch1RTK79l0zIRx80XWyLToTbvlcIviDexRy9titqD3eULK0suk8Gzof_Lpj6c8Bvw&quot;/&gt;&lt;/form&gt;

&lt;input type=&quot;hidden&quot; id=&quot;PublicKey&quot; name=&quot;PublicKey&quot; value=&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCp0wHYbg/NOPO3nzMD3dndwS0MccuMeXCHgVlGOoYyFwLdS24Im2e7YyhB0wrUsyYf0/nhzCzBK8ZC9eCWqd0aHbdgOQT6CuFQBMjbyGYvlVYU2ZP7kG9Ft6YV6oc9ambuO7nPZh+bvXH0zDKfi02prknrScAKC0XhadTHT3Al0QIDAQAB&quot;/&gt;&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    </description>
<pubDate>Tue, 16 Jun 2020 00:50:00 +0000</pubDate>
<dc:creator>大写的shyman</dc:creator>
<dc:language>zh</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Figqx%2Fp%2F13139077.html</dc:identifier>
</item>
<item>
<title>GitHub 热点速览 Vol.24：程序员自我增值，优雅赚零花钱 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/13137971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/13137971.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200615211823791-1910022897.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;摘要：升职加薪，出任 CTO，迎娶白富美/高帅富，走向人生巅峰是很多人的梦想。在本期的热点速览中你将了解自由作者 Easy 如何优雅赚取零花钱的方法，以及定投改变命运 —— 让时间陪你慢慢变富。说到程序员自我增值，除了优雅赚钱之外，还可以研究下各种生活中小工具的代码实现，例如，收录 20+ Web 小应用的 vanillawebprojects。将技术应用在生活中点滴，展现你的技术辅助日常“肝”口袋妖精，或者偶尔用技术给自己生活添加点小乐趣，用遗传算法制作一个绘制图像过程的小玩具。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以下内容摘录自微博&lt;a href=&quot;https://www.weibo.com/hellogithub/&quot;&gt;@HelloGitHub&lt;/a&gt; 的 GitHub Trending，选项标准：&lt;code&gt;新发布&lt;/code&gt; | &lt;code&gt;实用&lt;/code&gt; | &lt;code&gt;有趣&lt;/code&gt;，根据项目 release 时间分类，发布时间不超过 7 day 的项目会标注 &lt;code&gt;New&lt;/code&gt;，无该标志则说明项目 release 超过一周。由于本文篇幅有限，还有部分项目未能在本文展示，望周知 🌝&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;本文目录
&lt;ul&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;本周特推&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;1.1 遗传算法玩具：genetic-drawing&lt;/li&gt;
&lt;li&gt;1.2 马斯克火箭：SpaceX-API&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;GitHub Trending 周榜&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;2.1 Go 语法书：go-ast-book&lt;/li&gt;
&lt;li&gt;2.2 数据库好搭档：xgenecloud&lt;/li&gt;
&lt;li&gt;2.3 前端小玩意：vanillawebprojects&lt;/li&gt;
&lt;li&gt;2.4 统计代码：lihang-code&lt;/li&gt;
&lt;li&gt;2.5 Poke 辅助工具：Pokedex&lt;/li&gt;
&lt;li&gt;2.6 高性能框架：Fastapi&lt;/li&gt;
&lt;li&gt;2.7 JS 面经：javascript-questions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;本周 GitHub Trending #程序员增值# 主题的主力军&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;3.1 优雅赚钱：howto-make-more-money&lt;/li&gt;
&lt;li&gt;3.2 定投改变命运：regular-investing-in-box&lt;/li&gt;
&lt;li&gt;3.3 机器学习课程个人笔记：Coursera-ML-AndrewNg-Notes&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;推荐阅读&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200615211843518-71149058.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-本周特推&quot;&gt;1. 本周特推&lt;/h2&gt;
&lt;h3 id=&quot;11-遗传算法玩具：genetic-drawing&quot;&gt;1.1 遗传算法玩具：genetic-drawing&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1200+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt;genetic-drawing 作者在 2017 年做的模仿给定目标图像的绘制过程的玩具项目，效果见下图。项目受到互联网上许多基因绘制示例的启发，由于项目深受欢迎，作者便在近日将其开源。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/anopara/genetic-drawing&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200615211855054-193111616.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;12-马斯克火箭：spacex-api&quot;&gt;1.2 马斯克火箭：SpaceX-API&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：900+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SpaceX-API 是一个用于火箭、核心舱、太空舱、发射台和发射数据的开源 REST API。技术栈&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;部署在美国中部 Linode 服务器上&lt;/li&gt;
&lt;li&gt;使用了 Nodejs 的 Koa 框架&lt;/li&gt;
&lt;li&gt;使用了 Redis、Nginx 和 Cloudflare 进行内容缓存&lt;/li&gt;
&lt;li&gt;使用了 Jest 和 Supertest 做测试&lt;/li&gt;
&lt;li&gt;使用了 Circle CI 进行持续集成/部署&lt;/li&gt;
&lt;li&gt;所有的数据存储在 MongoDB Atlas 3 节点的副本集集群中&lt;/li&gt;
&lt;li&gt;使用 mongodump 在晚上进行数据备份&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/r-spacex/SpaceX-API&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2-github-trending-周榜&quot;&gt;2. GitHub Trending 周榜&lt;/h2&gt;
&lt;h3 id=&quot;21-go-语法书：go-ast-book&quot;&gt;2.1 Go 语法书：go-ast-book&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1000+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;go-ast-book 是一个 Go 语法树入门项目。让我们语法树这个维度重新审视 Go 语言程序，我们将得到创建Go语言本身的技术。本书简单介绍语法树相关包的使用。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/chai2010/go-ast-book&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200615211907854-354976929.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;22-数据库好搭档：xgenecloud&quot;&gt;2.2 数据库好搭档：xgenecloud&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt; xgenecloud 是一个能即时生成任何数据库上的 REST 和 GraphQL API 工具，它支持 MySQL、PostgreSQL、MsSQL、SQLite、MariaDB。特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为现有数据库生成 REST API&lt;/li&gt;
&lt;li&gt;提供用于调试的 GUI&lt;/li&gt;
&lt;li&gt;生成的 API 均可基于 Serverless 部署在任意云平台&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/xgenecloud/xgenecloud&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200615211921878-1244627212.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;23-前端小玩意：vanillawebprojects&quot;&gt;2.3 前端小玩意：vanillawebprojects&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1100+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;vanillawebprojects 收录了用前端技术（Javascript、CSS、HTML5）开发的 20+ 款小应用，包括：表单验证、汇率计算、打字游戏、语音阅读、新年倒计时等等。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/bradtraversy/vanillawebprojects&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200615211943119-1652356059.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;24-统计代码：lihang-code&quot;&gt;2.4 统计代码：lihang-code&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：10900+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;《统计学习方法》可以说是机器学习的入门宝典，许多机器学习培训班、互联网企业的面试、笔试题目，很多都参考这本书。本项目收录了该书的所有代码实现，特别是监督学习方法，包括感知机、k 近邻法、朴素贝叶斯法、决策树、逻辑斯谛回归与支持向量机、提升方法、em 算法、隐马尔可夫模型和条件随机场等。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/fengdu78/lihang-code&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200615211954170-1216784097.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;25-poke-辅助工具：pokedex&quot;&gt;2.5 Poke 辅助工具：Pokedex&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：500+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;New&lt;/code&gt;Pokedex 使用基于 MVVM 架构的 Dagger Hilt、Motion、Coroutines、Jetpack 开发的 Poke（口袋妖精）辅助工具。这个项目专注实现依赖注入的新库，支持从网络获取数据，并通过存储库模式集成数据库中的持久化数据。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/skydoves/Pokedex&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200615212006944-1809407407.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;26-高性能框架：fastapi&quot;&gt;2.6 高性能框架：Fastapi&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：1300+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fastapi 是一个基于 python 的框架，该框架鼓励使用 Pydantic 和 OpenAPI 进行文档编制，使用 Docker 进行快速开发和部署以及基于 Starlette 框架进行的简单测试。特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高性能&lt;/li&gt;
&lt;li&gt;快速编写代码：将功能开发的速度提高大约 200％ 至 300％&lt;/li&gt;
&lt;li&gt;错误更少：减少约40％的人为错误（开发人员）&lt;/li&gt;
&lt;li&gt;直观：强大的编辑器支持。完成无处不在。调试时间更少&lt;/li&gt;
&lt;li&gt;简易：旨在易于使用和学习。减少阅读文档的时间&lt;/li&gt;
&lt;li&gt;短：最小化代码重复。每个参数声明中的多个功能，更少的错误&lt;/li&gt;
&lt;li&gt;健壮：获取可用于生产的代码，具有自动交互式文档。&lt;/li&gt;
&lt;li&gt;基于标准：基于（并完全兼容）API的开放标准&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/tiangolo/fastapi&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200615212018260-226047600.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;27-js-面经：javascript-questions&quot;&gt;2.7 JS 面经：javascript-questions&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;本周 star 增长数：800+&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从基础到高级，JavaScript Questions 收录了 JS 相关的面试题及解法。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/lydiahallie/javascript-questions&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;3-本周-github-trending-程序员增值主题的主力军&quot;&gt;3. 本周 GitHub Trending #程序员增值#主题的主力军&lt;/h2&gt;
&lt;p&gt;在本期主题模块，小鱼干这里选取了 3 个和增值相关的小工具，希望能提高你生活、工作的幸福值。&lt;/p&gt;
&lt;h3 id=&quot;31-优雅赚钱：howto-make-more-money&quot;&gt;3.1 优雅赚钱：howto-make-more-money&lt;/h3&gt;
&lt;p&gt;howto-make-more-money 是一个程序员@Easy 现身讲述优雅的挣零花钱的项目，虽然是一个教你如何赚零花钱的项目，但是通过阅读本赚零花钱小书你可理清自己的核心资源，以及如何创造资产。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/easychen/howto-make-more-money&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200615212031348-589476222.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;32-定投改变命运：regular-investing-in-box&quot;&gt;3.2 定投改变命运：regular-investing-in-box&lt;/h3&gt;
&lt;p&gt;定投改变命运 —— 让时间陪你慢慢变富。regular-investing-in-box 这本书要讲的是普通人摆脱阶层固化的路径 —— 绝对可行，毫无水分，并且全靠你自己。这里所说的普通人，不分国界、不分地域、不分种族、不分性别、不分年龄、不分高矮胖瘦美丑、不分何种性取向…… 关键在于，甚至压根不分智商和学历！换言之，这个解决方案，甚至对在北京跑腿送外卖的小哥都适用……&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/xiaolai/regular-investing-in-box&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;33-机器学习课程个人笔记：coursera-ml-andrewng-notes&quot;&gt;3.3 机器学习课程个人笔记：Coursera-ML-AndrewNg-Notes&lt;/h3&gt;
&lt;p&gt;Coursera-ML-AndrewNg-Notes 是吴恩达老师的机器学习课程个人笔记，旨在提供了一个广泛的介绍机器学习、数据挖掘、统计模式识别的课程。主题包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;监督学习（参数/非参数算法，支持向量机，核函数，神经网络）。&lt;/li&gt;
&lt;li&gt;无监督学习（聚类，降维，推荐系统，深入学习推荐）。&lt;/li&gt;
&lt;li&gt;在机器学习的最佳实践（偏差/方差理论；在机器学习和人工智能创新过程）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;项目还将使用大量的案例研究，你可学习到如何运用学习算法构建智能机器人（感知，控制），文本的理解（Web 搜索，反垃圾邮件），计算机视觉，医疗信息，音频，数据挖掘，和其他领域。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;GitHub 地址→https://github.com/fengdu78/Coursera-ML-AndrewNg-Notes&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;p&gt;以上为 2020 年第 23 个工作周的 GitHub Trending 🎉如果你 Pick 其他好玩、实用的 GitHub 项目，记得来 HelloGitHub issue 区和我们分享下哟 🌝&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;HelloGitHub 交流群现已全面开放，添加微信号：HelloGitHub 为好友入群，可同前端、Java、Go 等各界大佬谈笑风生、切磋技术~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/759200/202006/759200-20200615212215777-1337141319.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 16 Jun 2020 00:34:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>摘要：升职加薪，出任 CTO，迎娶白富美/高帅富，走向人生巅峰是很多人的梦想。在本期的热点速览中你将了解自由作者 Easy 如何优雅赚取零花钱的方法，以及定投改变命运 —— 让时间陪你慢慢变富。说到程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/13137971.html</dc:identifier>
</item>
<item>
<title>python工业互联网应用实战2—从需求开始 - wuch</title>
<link>http://www.cnblogs.com/haozi0804/p/13138939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haozi0804/p/13138939.html</guid>
<description>&lt;p&gt;随着国家工业2025战略的推进，工业互联网发展将会提速，将迎来一个新的发展时期，越来越多的企业开始逐步的把产线自动化，去年年底投产的小米亦庄的智能工厂就是一个热议的新闻。小米/华为智能工厂只能说是中国制造2025的一个代表，产业转型和制造升级，笔者从事的企业领域就越到越来越多的（制造）企业开始悄悄的自动化/智能化。这里肯定有国家政策推动的大背景，同时，也有着企业自身不断提高生产率的“刚需”。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;125.48872858431&quot;&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span class=&quot;15&quot;&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;随着国家工业2025战略的推进，工业互联网发展将会提速，将迎来一个新的发展时期，越来越多的企业开始逐步的把产线自动化，去年年底投产的小米亦庄的智能工厂就是一个热议的新闻。小米/华为智能工厂只能说是中国制造2025的一个代表，产业转型和制造升级，笔者从事的企业领域就越到越来越多的（制造）企业开始悄悄的自动化/智能化。这里肯定有国家政策推动的大背景，同时，也有着企业自身不断提高生产率的“刚需”。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　本序列我们也从一个需求问题开始；然后，拆解需求（问题）；其次，解决拆解需求（问题）的点；再次，通过的不断技术摸索和迭代&lt;/span&gt;&lt;span&gt;过程&lt;/span&gt;&lt;span&gt;找到一个个合理的解决需求的方法和手段，最终，完成了这个需求（问题）的项目实战。我们会在文中描述演化过程、方法论、过程保证机制和实用的工具等，最终带着大家完成这样一个实际项目需求的&lt;/span&gt;&lt;span&gt;项目过程&lt;/span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;项目涉及的&lt;/span&gt;Django的&lt;span&gt;更&lt;/span&gt;&lt;span&gt;多基础知识请大家阅读笔者早期的《&lt;/span&gt;&lt;a href=&quot;https://www.cnblogs.com/haozi0804/p/4481020.html&quot;&gt;&lt;span&gt;&lt;span class=&quot;15&quot;&gt;Python开发入门与实战&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span&gt;&lt;span&gt;系列&lt;/span&gt;&lt;/span&gt;&lt;span&gt;》。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;　　本文的过程采用&lt;/span&gt;python3.6和django2.1版本&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;strong&gt;&lt;span&gt;项目需求&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：这是一个简版物流自动化仓库实例，仓库控制系统（以下简称&lt;/span&gt;WCS）需要调度AGV小车运送一个实托盘（搬运单元）从1楼入库站台经由提升机搬运到2&lt;span&gt;楼指定的仓库货位。&lt;/span&gt; &lt;/p&gt;
&lt;h3&gt;1.&lt;strong&gt;需求分析&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;&lt;span&gt;仓库控制系统（以下简称&lt;/span&gt;WCS&lt;span&gt;）需要调度&lt;/span&gt;&lt;span&gt;AGV&lt;/span&gt;&lt;span&gt;小车运送一个实托盘（搬运单元）从&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;楼入库站台经由提升机搬运到&lt;/span&gt;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&lt;span&gt;楼指定的仓库货位。&lt;/span&gt;&lt;/span&gt;&lt;span&gt;这句简要&lt;/span&gt;&lt;span&gt;描述常常是我们在项目&lt;/span&gt;URS&lt;span&gt;看到的需求描述，接下来我们需要对拿到的需求进行分析，形成一个个可度量的开发功能点。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;1.1.&lt;strong&gt;用例说明&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;　　需求用例说明文档能够很好的对需求进行详细的分析，主要的包含内容包括：前置条件、事件流程和后置条件（执行结果）用例描述如下表，通过用例分析我们能够很好的把握需求的具体事件执行流程，并通过文档清晰的描述出来，便于后期设计编码时作为开发设计人员的指导。&lt;/p&gt;
&lt;p&gt;　　经过团队头脑风暴讨论，大家基本上达成了如下表的需求用例说明，我们把这个调度设备的搬运过程设计成一个序列顺序执行的步骤（子任务），这些子任务对应着设备的执行分解动作。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;16.3000%&quot;&gt;
&lt;p&gt;&lt;strong&gt;用例编码&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;40.8200%&quot;&gt;
&lt;p&gt;&lt;strong&gt;1.1&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;16.3200%&quot;&gt;
&lt;p&gt;&lt;strong&gt;执行角色&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;center&quot; width=&quot;26.5600%&quot;&gt;
&lt;p&gt;&lt;strong&gt;WCS&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;16.3000%&quot;&gt;
&lt;p&gt;用例名称&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;83.7000%&quot;&gt;
&lt;p&gt;托盘入库用例&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;16.3000%&quot;&gt;
&lt;p&gt;前提条件&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;83.7000%&quot;&gt;
&lt;ol&gt;&lt;li&gt;WMS已完成任务货位的分配，任务核心信息：托盘条码、源地址、目标地址；&lt;/li&gt;
&lt;li&gt;AGV不能跨楼层作业，1楼与2楼分别是不同的AGV小车执行任务；&lt;/li&gt;
&lt;/ol&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;13&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;16.3000%&quot;&gt;
&lt;p&gt;需求描述&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;83.7000%&quot; readability=&quot;19&quot;&gt;
&lt;p class=&quot;17&quot;&gt;1 WCS&lt;span&gt;分解搬运任务成&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;个设备作业&lt;/span&gt;；&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;2 调度AGV&lt;span&gt;从&lt;/span&gt;入库站台搬运托盘到提升机&lt;span&gt;1&lt;/span&gt;&lt;span&gt;楼门口工位；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;3 调度提升机到&lt;span&gt;1&lt;/span&gt;&lt;span&gt;楼并打开廊门&lt;/span&gt;；&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;4 调度AGV&lt;span&gt;从&lt;/span&gt;提升机&lt;span&gt;1&lt;/span&gt;&lt;span&gt;楼门口工位到提升机并卸货，返回提升机门口工位；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;5 调度提升机&lt;span&gt;1&lt;/span&gt;&lt;span&gt;楼提升到&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;楼并开门；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;6 调度AGV进入提升机并载货搬运到&lt;span&gt;2&lt;/span&gt;&lt;span&gt;楼门口工位；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;7 调度提升机关门；&lt;/p&gt;
&lt;p class=&quot;17&quot;&gt;8 调度AGV从&lt;span&gt;2&lt;/span&gt;&lt;span&gt;楼门口工位搬运到库存货位。&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;16.3000%&quot;&gt;
&lt;p&gt;备选过程&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;83.7000%&quot;&gt;

&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;16.3000%&quot;&gt;
&lt;p&gt;扩展过程&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;3&quot; valign=&quot;top&quot; width=&quot;83.7000%&quot;&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;16.3000%&quot;&gt;
&lt;p&gt;原始需求描述&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;83.7000%&quot;&gt;
&lt;p&gt;参见 《XXX URS》&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;center&quot; width=&quot;16.3000%&quot;&gt;
&lt;p&gt;特殊需求&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;83.7000%&quot;&gt;
&lt;p class=&quot;16&quot;&gt;无&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;center&quot; width=&quot;16.3000%&quot;&gt;
&lt;p&gt;后置条件&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;3&quot; valign=&quot;center&quot; width=&quot;83.7000%&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;WCS调度相关设备完成实托盘从入库站台搬运到库存货位，反馈结果给WMS &lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h3&gt;2. &lt;strong&gt;需求功能点&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;　　从上面的用例说明的需求描述事件流程来看，我们需要先把这一趟搬运任务分解成设备子任务，并串行的方式顺序下达到设备执行，任务清单如下表：&lt;/p&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot;&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;序号&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;407&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;作业描述&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;114&quot;&gt;
&lt;p align=&quot;center&quot;&gt;&lt;strong&gt;执行设备&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;407&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;调度AGV&lt;span&gt;从&lt;/span&gt;入库站台搬运托盘到提升机&lt;span&gt;1&lt;/span&gt;&lt;span&gt;楼门口工位&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;114&quot;&gt;
&lt;p&gt;1&lt;span&gt;楼&lt;/span&gt;&lt;span&gt;AGV&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;407&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;调度提升机到&lt;span&gt;1&lt;/span&gt;&lt;span&gt;楼并打开门&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;114&quot;&gt;
&lt;p&gt;提升机&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;407&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;调度AGV&lt;span&gt;从&lt;/span&gt;提升机&lt;span&gt;1&lt;/span&gt;&lt;span&gt;楼门口工位到提升机并卸货，返回提升机门口工位&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;114&quot;&gt;
&lt;p&gt;1&lt;span&gt;楼&lt;/span&gt;&lt;span&gt;AGV&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;4&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;407&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;调度提升机&lt;span&gt;1&lt;/span&gt;&lt;span&gt;楼提升到&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;楼并开门&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;114&quot;&gt;
&lt;p&gt;提升机&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;5&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;407&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;调度AGV进入提升机并载货搬运到&lt;span&gt;2&lt;/span&gt;&lt;span&gt;楼门口工位&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;114&quot;&gt;
&lt;p&gt;2&lt;span&gt;楼&lt;/span&gt;&lt;span&gt;AGV&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;6&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;407&quot;&gt;
&lt;p&gt;调度提升机关门&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;114&quot;&gt;
&lt;p&gt;提升机&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td valign=&quot;top&quot; width=&quot;47&quot;&gt;
&lt;p&gt;7&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;407&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;调度AGV从&lt;span&gt;2&lt;/span&gt;&lt;span&gt;楼门口工位搬运到库存货位&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&quot;top&quot; width=&quot;114&quot;&gt;
&lt;p&gt;2&lt;span&gt;楼&lt;/span&gt;&lt;span&gt;AGV&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;　　也就是说这一趟搬运任务，&lt;/span&gt;WCS&lt;span&gt;需要分解成&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;个设备作业子任务，并顺序下达给相应的执行设备执行，最终完成任务的执行（当前的任务划分粒度实际对接AGV和提升机厂家来说会有调整，最终以上步骤会依赖与实际对接的情况，但是主流程不会有太大变化）。&lt;/span&gt; &lt;/p&gt;
&lt;p&gt; &lt;span&gt;　　经过分析从&lt;/span&gt;1&lt;span&gt;楼入库站台运送托盘到二楼某个指定货位这样一个任务，系统需要分解成&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;个子任务，下达给设备顺序执行。系统活动图如下：&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;3. &lt;strong&gt;活动图&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　经过分析从&lt;/span&gt;1&lt;span&gt;楼入库站台运送托盘到2楼某个指定货位这样一个任务，系统需要分解成&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;&lt;span&gt;个子任务，下达给设备顺序执行。我们还可以通过&lt;/span&gt;&lt;span&gt;UML&lt;/span&gt;&lt;span&gt;活动图来进一步详细的描述作业的执行顺序如下图：&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/67400/202006/67400-20200616074235095-1392612523.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  　　&lt;span&gt;从图中我们可以看出来一次入库任务，系统分解为&lt;/span&gt;7&lt;span&gt;个设备子任务（作业）来执行完整的托盘入库流程，只有所有子任务（作业）执行完成，托盘的入库才算完成。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; 4. &lt;strong&gt;功能模块&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　对于这样一个看似简单的需求来说，包含两大主要功能模块&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;任务分解：依据物理设备处理任务的条件，对任务进行分解，任务分解的粒度是设备能够识别并执行（动作）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;任务调度：任务调度就是按照顺序执行的逻辑，把任务顺序和逐一下达给设备 &lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　这里也有几个基本逻辑就是，设备在某一个时间点上只能执行一个子任务，只有这个任务执行完毕后方能下达新的子任务。多重任务逻辑只会导致设备无法完成任务（不知道到底该执行那个动作）。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt; 4.1. &lt;strong&gt;实体关系&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;　　我们从上面需求分析整理当前至少包括&lt;/span&gt;2&lt;span&gt;个实体，包含的属性（字段）如下：&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;任务&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;任务&lt;/span&gt;ID，任务号，源地址（从哪儿），目标地址（到哪儿），开始时间，结束时间，状态 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;子任务：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;子任务ID，任务ID，源地址(从哪儿 上一个子任务的目标地址）， 目标地址（到哪儿 下一个子任务的源地址）， 执行机构，开始时间，结束时间，状态&lt;/p&gt;
&lt;h3&gt;5. &lt;strong&gt;小节&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　本章我们从一个需求问题开始，然后经过需求分析，把需求问题分解为功能点和数据实体，实体是下一步我们设计表或&lt;/span&gt;ORM model&lt;span&gt;的基础原型，上面的实体只是一个初步的需求分析主要字段要求，实体属性（字段）会设计时会增加特定的其它属性（字段）。 下一章节我们将描绘如何把这个需求逐步演化到模型设计。&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 16 Jun 2020 00:26:00 +0000</pubDate>
<dc:creator>wuch</dc:creator>
<og:description>随着国家工业2025战略的推进，工业互联网发展将会提速，将迎来一个新的发展时期，越来越多的企业开始逐步的把产线自动化，去年年底投产的小米亦庄的智能工厂就是一个热议的新闻。小米/华为智能工厂只能说是中国</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haozi0804/p/13138939.html</dc:identifier>
</item>
<item>
<title>Node.js躬行记（4）——自建前端监控系统 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12883160.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12883160.html</guid>
<description>&lt;p&gt;　　这套前端监控系统用到的技术栈是：React+MongoDB+Node.js+Koa2。将性能和错误量化。因为自己平时喜欢吃菠萝，所以就取名叫&lt;span&gt;&lt;a href=&quot;https://github.com/pwstrick/pineapple&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;菠萝系统&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。其实在很早以前就有这个想法，当时已经实现了&lt;span&gt;&lt;a href=&quot;https://github.com/pwstrick/Primus&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;前端的参数搜集&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，只是后台迟迟没有动手，也就拖着。&lt;/p&gt;
&lt;ul readability=&quot;1.4512195121951&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;目前完成的还只是个雏形，仅仅是搜集了错误和相关的性能参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;后台样式采用了封装过的matrix。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;分析功能还很薄弱，只是做了简单的演示，并且各种基础功能还有待完善。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;后面打算强化数据分析，并且还要实现错误的回放机制，思路的话以前也调研过，参考之前的&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/12206766.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;一篇文章&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　现在的这个系统还只能算是个玩具，后期还需要雕琢雕琢。下面是这套系统的目录结构。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
├── pingapple ---------------------------------&lt;span&gt; 菠萝监控系统
│   ├── client &lt;/span&gt;--------------------------------&lt;span&gt; 系统的前端部分
│   ├── sdk &lt;/span&gt;-----------------------------------&lt;span&gt; 信息搜集代码库
│   ├── server &lt;/span&gt;-------------------------------- 系统的后端部分
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）primus.js&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在之前的《&lt;span&gt;&lt;a href=&quot;https://www.cnblogs.com/strick/p/5750022.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;前端页面性能参数搜集&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》一文中，详细记载了各类性能指标的计算规则，并整理到了&lt;span&gt;&lt;a href=&quot;https://github.com/pwstrick/Primus/blob/master/js/primus.js&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;primus.js&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;中。&lt;/p&gt;
&lt;p&gt;　　本次将在primus.js的基础上做适当的修改，包括删除代理、测速、资源信息等功能，改变部分性能指标的计算规则，例如从浏览器发起HTTP请求算起，忽略浏览器重定向的时间等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）错误处理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　完善错误处理，将错误分成三类：runtime、load和Promise。在window的error事件中，处理前两种错误。像img元素载入的图片地址不存在，就会执行formatLoadError()函数；像变量未定义，就会执行formatRuntimerError()函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
window.addEventListener(&quot;error&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; errorTarget =&lt;span&gt; event.target;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤 target 为 window 的异常&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (
      errorTarget &lt;/span&gt;!== window &amp;amp;&amp;amp;&lt;span&gt;
      errorTarget.nodeName &lt;/span&gt;&amp;amp;&amp;amp;&lt;span&gt;
      LOAD_ERROR_TYPE[errorTarget.nodeName.toUpperCase()]
    ) {
      handleError(formatLoadError(errorTarget));
    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      handleError(
        formatRuntimerError(
          event.message,
          event.filename,
          event.lineno,
          event.colno,
          event.error
        )
      );
    }
  }, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　将window绑定&lt;span&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/Events/unhandledrejection&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;unhandledrejection&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;事件后，就会在Promise被拒绝且没有reject的回调函数时触发。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;window.addEventListener(
  &lt;/span&gt;&quot;unhandledrejection&quot;&lt;span&gt;,
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; (event) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; console.log('Unhandled Rejection at:', event.promise, 'reason:', event.reason);&lt;/span&gt;
&lt;span&gt;    handleError({
      type: ERROR_PROMISE,
      desc: event.reason,
      stack: &lt;/span&gt;&quot;no stack&quot;&lt;span&gt;
    });
  },
  &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;
);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）初始化&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　由于要计算白屏时间，DOM时间等，所以位置不能随便放，得要放在head的最后面。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    window.pineapple &lt;/span&gt;&lt;span&gt;||&lt;/span&gt;&lt;span&gt; (pineapple &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {});
    pineapple.param &lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt; {
      &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dsadasd2323dsad23dsada&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    };
  &lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;script &lt;/span&gt;&lt;span&gt;src&lt;/span&gt;&lt;span&gt;=&quot;js/pineapple.js&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;script&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;head&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）Koa&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://koa.bootcss.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Koa&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;是由Express原班人马打造的Web轻量框架，通过组合各种中间件来避免繁琐的回调函数嵌套，当前使用的版本是V2。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install --save koa
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用的Koa脚手架：koa-generator，创建项目的结构，并且在此基础上做了调整（目录如下所示）。暂时还不会用到静态资源和视图层。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install -g koa-generator
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
├── server ---------------------------------&lt;span&gt; 服务端
│   ├── bin &lt;/span&gt;--------------------------------&lt;span&gt; 命令
│   ├── config &lt;/span&gt;-----------------------------&lt;span&gt; 配置目录
│   ├── controllers &lt;/span&gt;------------------------&lt;span&gt; MVC中的逻辑层
│   ├── db &lt;/span&gt;---------------------------------&lt;span&gt; MVC中的数据层
│   ├── public &lt;/span&gt;-----------------------------&lt;span&gt; 静态资源
│   ├── routes &lt;/span&gt;-----------------------------&lt;span&gt; 路由
│   ├── utils &lt;/span&gt;------------------------------&lt;span&gt; 工具库
│   ├── views &lt;/span&gt;------------------------------&lt;span&gt; MVC中的视图层
│   ├── app.js &lt;/span&gt;----------------------------- 入口文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了区分开发环境和生产环境，通过cross-env统一不同系统设置环境变量的方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save cross-env
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　package.json中的命令如下，添加了环境配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&quot;scripts&quot;&lt;span&gt;: {
  &lt;/span&gt;&quot;start&quot;: &quot;node bin/www&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;dev&quot;: &quot;cross-env NODE_ENV=development ./node_modules/.bin/nodemon bin/www&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;prd&quot;: &quot;cross-env NODE_ENV=production pm2 start bin/www&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　prd按字面意思应该是生产环境的命令，其中使用了pm2，默认没有安装。还没部署过Node.js，还不清楚里面有多少坑。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install --save pm2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）MongoDB&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　MongoDB是一个开源的非关系型数据库（图1是&lt;span&gt;&lt;a href=&quot;https://www.mongodb.com/download-center/community&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;下载界面&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;），既没有表、行等概念，也没有固定的模式和结构，所有的数据以文档（一个对象）的形式存储。但其使用方式和关系型数据库相似，并且还支持对数据建立索引，适用于高并发读写、海量数据存储和实时分析等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202005/211606-20200513162416287-1317654581.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图1&lt;/p&gt;
&lt;p&gt;　　注意，在安装时默认会下载&lt;span&gt;&lt;a href=&quot;https://www.mongodb.com/download-center/compass&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;MongoDB Compress&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（一个可视化的MongoDB工具），默认下载会非常慢，建议自行下载，该工具的界面还是蛮清爽的，如图2所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202005/211606-20200513162624402-1162349350.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图2&lt;/p&gt;
&lt;p&gt;　　在Mac上配置MongoDB比较麻烦，不像Windows那样一件安装，需要一些步骤，废了点力气才装好，下面是执行的命令。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
sudo mongod --dbpath=/Users/pw/data
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）Mongoose&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://mongoosejs.com/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Mongoose&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;是MongoDB的一个ORM（Object-Document Mapper，对象文档映射）工具，可在Node.js环境中执行，封装了MongoDB操作文档的&lt;span&gt;&lt;a href=&quot;https://mongoosedoc.top/docs/index.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;常用方法&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，包括引入数据库连接（connect），定义模型（model），声明文档结构（scheme），实例化模型等操作数据库的方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save mongoose
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　借鉴了以前PHP数据分层的思想，单独分离出数据库的连接，并抽象通用的Model层（如下所示）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
const mongoose = require(&quot;./db&quot;&lt;span&gt;);
class Mongodb {
  constructor(name, schema) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明结构&lt;/span&gt;
    const mySchema = &lt;span&gt;new&lt;/span&gt; mongoose.Schema(schema, { typeKey: &quot;$type&quot;&lt;span&gt; });
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.model =&lt;span&gt; mongoose.model(name, mySchema);
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存&lt;/span&gt;
&lt;span&gt;  save(obj) {
    obj.created &lt;/span&gt;= Date.now();         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;日期&lt;/span&gt;
    const doc = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.model(obj);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
      doc.save((err, row) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
          reject(err);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        resolve(row);
      });
    });
  }
}
module.exports &lt;/span&gt;=&lt;span&gt; {
  model: Mongodb,
  mongoose
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）路由&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　由于发送的地址是一张gif图片，因此在处理路由时，返回本地的一张gif图，如下所示，图像地址得是绝对路径，否则无法读取。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
router.get('/pa.gif', async (ctx, next) =&amp;gt;&lt;span&gt; {
  const ctr &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; indexController();
  ctr.collect(ctx);
  const url &lt;/span&gt;= path.resolve(__dirname, &quot;../public/images/blank.gif&quot;&lt;span&gt;);
  ctx.body &lt;/span&gt;= fs.readFileSync(url);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;空白gif图&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）代理分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在接收参数的时候分析代理所带的信息，例如浏览器、操作系统、设备等。使用的是一个第三方库：&lt;span&gt;&lt;a href=&quot;http://faisalman.github.io/ua-parser-js/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;UAParser.js&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，四年前就关注过，当时GitHub上只有1K多个关注量，现在已经翻了4倍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save ua-parser-js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6）假数据&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　制作一套合适的假数据，新增命令“npm run data”，初始化数据，便于展示。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）UI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　后台模板采用了之前封装过的&lt;span&gt;&lt;a href=&quot;https://github.com/pwstrick/grape-skin&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Matrix&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，但不会依赖Bootstrap框架。&lt;/p&gt;
&lt;p&gt;　　将整个页面分成五块，分别是导航、侧边栏、面包屑、底部栏以及主体。&lt;/p&gt;
&lt;p&gt;　　安装react-router的history，用于路由。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save history
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　期间也会安装各类依赖包，例如不支持在类中直接声明属性等。&lt;/p&gt;
&lt;p&gt;　　在使用的过程中，ESLint会不时的弹出各种错误和警告，期间就不停的修改问题或查找相关配置忽略部分限制。&lt;/p&gt;
&lt;p&gt;　　后台的侧边栏和面包屑等部分，会随着URL的不同而发生状态变化，本来想用多页实现，但配置要改很多，就依然做成一个SPA，只是稍微做了些改动。&lt;/p&gt;
&lt;p&gt;　　组件库采用了流行的&lt;span&gt;&lt;a href=&quot;https://ant.design/components/button-cn/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Ant Design&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，调用了按钮、单选框、日期等组件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm install --save antd
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　图表库使用的是&lt;span&gt;&lt;a href=&quot;https://www.echartsjs.com/zh/index.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;ECharts&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，目前只用到了折线图和饼图。在引用图表时，为了优化构建，采取了按需引用的手段。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save echarts
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）项目管理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　首先建立一个项目，然后才能分析该项目的性能和错误，如图3所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202005/211606-20200513163430206-1389597847.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图3&lt;/p&gt;
&lt;p&gt;　　用弹框的形式来创建项目，使用了Ant Design的Model、Form等组件，如图4所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202005/211606-20200513163516406-463117542.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图4&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）性能分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　在第一个折线图标签中的过滤条件包括项目、字段、日期等，性能指标按平均值呈现，可看到每个性能指标的趋势，如图5所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202005/211606-20200513164437781-22289380.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图5&lt;/p&gt;
&lt;p&gt;　　按分时日统计性能平均数，在MongoDB中计算。原先创建日期是以时间戳的形式存储的，为了便于使用Aggregate，改成字符串形式。碰到一个坑，MongoDB中的Date类型采用的是格林尼治时间，而不是当前时区的时间，也就是说存在数据库中的时间会比当前时间早8小时。&lt;/p&gt;
&lt;p&gt;　　在第二个列表标签中，可以详细看到每条记录的信息，包括代理、网络等，便于在了解趋势的前提下，获悉更为细节的内容，如图6所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202005/211606-20200513164126996-971736854.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图6&lt;/p&gt;
&lt;p&gt;　　点击ajax那一列，可弹出具体的异步请求信息，如图7所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202005/211606-20200513164207697-511110309.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图7&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）错误分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　有三个标签，第一个也是折线图，描绘的是某个时间的错误个数；第二个是错误列表，会给出具体的错误信息，如图8所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202005/211606-20200513164630926-2023296636.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图8&lt;/p&gt;
&lt;p&gt;　　第三个是饼图，饼图主要体现的是发生错误的浏览器分布情况（如图9所示），点击某一块可查看浏览器的具体版本（如图10所示）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202005/211606-20200513164525415-713360048.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图9&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202005/211606-20200513164547690-1438044966.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图10&lt;/p&gt;


&lt;p&gt;【参考资料】&lt;br/&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/PerformanceTiming&quot; target=&quot;_blank&quot;&gt;PerformanceTiming&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/justjavac/the-front-end-knowledge-you-may-not-know/issues/7&quot; target=&quot;_blank&quot;&gt;unhandledrejection 处理没有显式捕获的 Promise 异常&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://book.douban.com/subject/34933584/&quot; target=&quot;_blank&quot;&gt;狼书（卷2）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5cd4fe3e6fb9a0321141c9ba&quot; target=&quot;_blank&quot;&gt;Node-区分环境&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.bingshangroup.com/blog/2019/07/22/zhangyue/pm2/&quot; target=&quot;_blank&quot;&gt;Koa从零搭建到Api实现—项目部署&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/62bfb3a4b4bb&quot; target=&quot;_blank&quot;&gt;koa如何连接MongoDB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://chenshenhai.github.io/koa2-note/&quot; target=&quot;_blank&quot;&gt;Koa2进阶学习笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitai.me/2018/04/fp/&quot; target=&quot;_blank&quot;&gt;如何计算首屏加载时间&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/33846939/mongoose-schema-error-cast-to-string-failed-for-value-when-pushing-object-to&quot; target=&quot;_blank&quot;&gt;Mongoose Schema Error: “Cast to string failed for value” when pushing object to empty array&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/52237855/support-for-the-experimental-syntax-classproperties-isnt-currently-enabled&quot; target=&quot;_blank&quot;&gt;Support for the experimental syntax 'classProperties' isn't currently enabled&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/babel/babel-eslint/issues/799&quot; target=&quot;_blank&quot;&gt;Template string failing with Cannot read property 'range' of null&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-props-no-spreading.md&quot; target=&quot;_blank&quot;&gt;Disallow JSX props spreading (react/jsx-props-no-spreading)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.bountysource.com/issues/50363567-typeerror-cannot-read-property-range-of-null-from-template-curly-spacing&quot; target=&quot;_blank&quot;&gt;TypeError: Cannot read property 'range' of null from template-curly-spacing&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5b0033c9518825056508075f&quot; target=&quot;_blank&quot;&gt;echarts项目的优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c6e0c3a518825621f2a6f45&quot; target=&quot;_blank&quot;&gt;使用 happypack 提升 Webpack 项目构建速度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d9c2bca51882560a8306bb4&quot; target=&quot;_blank&quot;&gt;mac下的mongoDB的安装和启动&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/shine_a/article/details/104201167&quot; target=&quot;_blank&quot;&gt;安装MongoDB报错 mkdir: /data/db: Read-only file system&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/operator/aggregation/sum/&quot; target=&quot;_blank&quot;&gt;$sum mongoose&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 15 Jun 2020 23:45:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>这套前端监控系统用到的技术栈是：React+MongoDB+Node.js+Koa2。将性能和错误量化。因为自己平时喜欢吃菠萝，所以就取名叫菠萝系统。其实在很早以前就有这个想法，当时已经实现了前端的参</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12883160.html</dc:identifier>
</item>
<item>
<title>小师妹学JVM之:GC的垃圾回收算法 - flydean</title>
<link>http://www.cnblogs.com/flydean/p/jvm-gc-algorithms.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/jvm-gc-algorithms.html</guid>
<description>&lt;p&gt;JVM的重要性不言而喻了，如果把java的应用程序比作一辆跑车，那么JVM就是这辆车的发动机，没有它，java程序就成了空中楼阁，无根浮萍。而在JVM中有一块内存区域叫做运行时数据区域，存储了运行时所需要的所有对象，而Heap Area则是其中最大的一块。&lt;/p&gt;
&lt;p&gt;内存毕竟不是无限的，所以就需要一种机制来将不再使用的对象进行回收，这种机制就是今天我们要讲的GC。&lt;/p&gt;
&lt;p&gt;更多精彩内容且看：&lt;/p&gt;

&lt;p&gt;小师妹:F师兄，你相信这个世界有轮回吗？&lt;/p&gt;
&lt;p&gt;师兄我是一个坚定的无神论者，活在当下就好了，何必操心后面的轮回呢？&lt;/p&gt;
&lt;p&gt;小师妹:F师兄，这个你就不懂了，意识是组成脑的原子群的一种组合模式，我们大脑的物质基础和一块石头没有什么不同。当我们掌握大脑的组合方式，然后重构，我们的意识就重现了，这就是轮回。这可是量子理论中提到的观念哦。&lt;/p&gt;
&lt;p&gt;哇，小师妹什么时候这么厉害了，都开始探讨这么高深的话题了。F师兄我实在是跟不上节奏啊。&lt;/p&gt;
&lt;p&gt;小师妹，F师兄，我是怕你尴尬，想引出java对象的生命周期这个话题嘛。&lt;/p&gt;
&lt;p&gt;量子理论我不熟，java对象我还没怕过谁。&lt;/p&gt;
&lt;p&gt;对象的生命周期其实很简单：创建，使用中，最后被销毁。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举个最简单的创建对象的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Object obj = new Object();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对象创建的时候，将会为该对象分配特定的空间。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;使用对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对象创建之后，就可以被其他的对象使用，如果其他的对象有使用该对象，那么我们成为该对象被引用了。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;对象销毁&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;当一个对象没有被其他对象引用的时候，我们就称为该对象可以被回收了。在Java中，对象的回收是由GC来负责的。&lt;/p&gt;

&lt;p&gt;小师妹：F师兄，我觉得垃圾回收好像挺简单的，我们为每个对象维持一个指针计数器，每引用一次就加一，这样不就可以实现垃圾回收器了吗？&lt;/p&gt;
&lt;p&gt;底层原理是这么一个道理，但是JVM需要一种更加高效的算法来保证垃圾回收的效率，同时也不会影响正在运行的程序。&lt;/p&gt;
&lt;p&gt;接下来我们将会介绍一下，在JVM中比较常用几个垃圾回收算法：&lt;/p&gt;
&lt;h2 id=&quot;mark-and-sweep&quot;&gt;Mark and sweep&lt;/h2&gt;
&lt;p&gt;Mark and sweep是最最简单的垃圾回收算法，简单点讲，它可以分为两个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;标记live对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;标记live对象听起来很简单，就是扫描堆中的对象，看这些对象是否被引入。&lt;/p&gt;
&lt;p&gt;但是这里有一个问题，如果是两个对象互相引用的时候，而这两个对象实际上并没有被外部的对象所引用，那么这两个对象其实是应该被回收的。所以我们还需要解决一个关键性的问题：从哪里开始扫描的问题。&lt;/p&gt;
&lt;p&gt;JVM定义了一些Root对象，从这些对象开始，找出他们引用的对象，组成一个对象图。所有在这个图里面的对象都是有效的对象，反之不在对象图中的对象就应该被回收。有效的对象将会被Mark为alive。&lt;/p&gt;
&lt;p&gt;这些Root对象包括：正在执行的方法中的本地对象和输入参数。活动的线程，加载类中的static字段和JNI引用。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意，这种遍历其实是有个缺点的，因为为了找到对象图中哪些对象是live的，必须暂停整个应用程序，让对象变成静止状态，这样才能构建有效的对象图。后面我们会介绍更加有效的垃圾回收算法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;删除对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;扫描对象之后，我们就可以将未标记的对象删除了。&lt;/p&gt;
&lt;p&gt;删除有三种方式，第一种方式是正常删除。但是正常删除会导致内存碎片的产生。所以第二种方式就是删除之后进行压缩，以减少内存碎片。还有一种方式叫做删除拷贝，也就是说将alive的对象拷贝到新的内存区域，这样同样可以解决内存碎片的问题。&lt;/p&gt;
&lt;h2 id=&quot;concurrent-mark-sweep-cms&quot;&gt;Concurrent mark sweep (CMS)&lt;/h2&gt;
&lt;p&gt;在讲CMS之前，我们先讲一下垃圾回收器中的Eden，Old和Survivor space几个大家应该都很熟悉的分代技术。&lt;/p&gt;
&lt;p&gt;Young Gen被划分为1个Eden Space和2个Suvivor Space。当对象刚刚被创建的时候，是放在Eden space。垃圾回收的时候，会扫描Eden Space和一个Suvivor Space。如果在垃圾回收的时候发现Eden Space中的对象仍然有效，则会将其复制到另外一个Suvivor Space。&lt;/p&gt;
&lt;p&gt;就这样不断的扫描，最后经过多次扫描发现任然有效的对象会被放入Old Gen表示其生命周期比较长，可以减少垃圾回收时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200525214231730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;之后要将的几个垃圾回收器，除了ZGC，其他都使用的是分代的技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好了，现在继续讲CMS，CMS是mark and swap的升级版本，它使用多个线程来对heap区域进行扫描，从而提升效率。&lt;/p&gt;
&lt;p&gt;CMS在Young Generation中使用的是mark-copy，而在Old Generation主要使用的是mark-sweep。&lt;/p&gt;
&lt;p&gt;使用CMS的命令很简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:+UseConcMarkSweepGC
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200525221146596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_35,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面是列出的一些CMS的调优参数。&lt;/p&gt;
&lt;h2 id=&quot;serial-garbage-collection&quot;&gt;Serial garbage collection&lt;/h2&gt;
&lt;p&gt;Serial garbage collection使用单一的线程来进行垃圾回收操作，其好处就是不需要和其他的线程进行交互。如果你是单核的CPU，那么最好就是选择Serial garbage collection，因为你不能充分利用多核的好处。同样的它也常常用在比较小型的项目中。&lt;/p&gt;
&lt;p&gt;Serial garbage collection在Young Generation中使用的是mark-copy，而在Old Generation主要使用的是 mark-sweep-compact。&lt;/p&gt;
&lt;p&gt;下面是开启命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:+UseSerialGC
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;parallel-garbage-collection&quot;&gt;Parallel garbage collection&lt;/h2&gt;
&lt;p&gt;和serial GC类似，它在Young Generation中使用的是mark-copy，而在Old Generation主要使用的是 mark-sweep-compact。不同的是它是并行的。&lt;/p&gt;
&lt;p&gt;可以通过下面的命令来指定并发的线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:ParallelGCThreads=N
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你是多核处理器，那么Parallel GC可能是你的选择。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Parallel GC是JDK8中的默认GC。而在JDK9之后， G1是默认的GC。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用下面的命令来开启Parallel GC：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:+UseParallelGC
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;g1-garbage-collection&quot;&gt;G1 garbage collection&lt;/h2&gt;
&lt;p&gt;为什么叫G1呢，G1=Garbage First，它是为替换CMS而生的，最早出现在java7中。&lt;/p&gt;
&lt;p&gt;G1将heap区域划分成为多个更小的区域，每个小区域都被标记成为young generation 或者old generation。从而运行GC在更小的范围里运行，而不是影响整个heap区域。&lt;/p&gt;
&lt;p&gt;可以使用下面的命令来开启：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;-XX:+UseG1GC 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;z-garbage-collection&quot;&gt;Z Garbage Collection&lt;/h2&gt;
&lt;p&gt;ZGC是一个可扩展的，低延迟的GC。ZGC是并发的，而且不需要停止正在运行的线程。&lt;/p&gt;
&lt;p&gt;使用下面的命令来开启：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; -XX:+UseZGC 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ZGC是在JDK11中被引入的。&lt;/p&gt;

&lt;p&gt;小师妹：F师兄，你讲了这么多个GC，到底我该用哪个呢？&lt;/p&gt;
&lt;p&gt;高射炮不能用来打蚊子，所以选择合适的GC才是最终要的。这里F师兄给你几个建议：&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;如果你的应用程序内存本来就很小，那么使用serial collector ： -XX:+UseSerialGC.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果你的程序运行在单核的CPU上，并且也没有程序暂停时间的限制，那么还是使用serial collector ： -XX:+UseSerialGC.&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果对峰值期的性能要求比较高，但是对程序暂停时间没多大的要求，那么可以使用 parallel collector： -XX:+UseParallelGC。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果更加关注响应时间，并且GC的对程序的暂停时间必须要小，那么可以使用-XX:+UseG1GC。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果响应时间非常重要，并且你在使用大容量的heap空间，那么可以考虑使用ZGC： -XX:UseZGC。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文介绍了几种GC的算法，大家可以根据需要选用。&lt;/p&gt;
&lt;blockquote readability=&quot;8.7106598984772&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/jvm-gc-algorithms/&quot;&gt;http://www.flydean.com/jvm-gc-algorithms/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:程序那些事，更多精彩等着您！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 15 Jun 2020 23:16:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 JVM的重要性不言而喻了，如果把java的应用程序比作一辆跑车，那么JVM就是这辆车的发动机，没有它，java程序就成了空中楼阁，无根浮萍。而在JVM中有一块内存区域叫做运行时数据区域，存储了运</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/jvm-gc-algorithms.html</dc:identifier>
</item>
<item>
<title>基础拾遗---委托，匿名函数，lambda  - 王延领</title>
<link>http://www.cnblogs.com/wyl1924/p/13138793.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyl1924/p/13138793.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;  C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。委托（Delegate）特别用于实现事件和回调方法。所有的委托都派生自 System.Delegate 类。把一个方法当作参数传递,让其它方法进行调用执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;委托声明决定了可由该委托引用的方法。委托可指向一个与其具有相同标签的方法。&lt;/p&gt;
&lt;h2&gt;1.1.delegate&lt;/h2&gt;
&lt;h3&gt;1.1.1. &lt;strong&gt;0-23&lt;/strong&gt;个参数,可以有返回值也可以没有返回值&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MyDelegateEventHandler (&lt;span&gt;string&lt;/span&gt; parm);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：(1).此委托指向的方法必须是参数为string类型，返回类型为int类型的。其他声明类比所得。&lt;/p&gt;
&lt;p&gt;　　(2).&lt;span&gt;&lt;span&gt;EventHandler&lt;/span&gt;&lt;/span&gt;是c# 命名规范，当然我理解规范就是可以随意啦。&lt;/p&gt;
&lt;p&gt;       (3).委托调用时必须判断是否为null不然会报异常&lt;/p&gt;
&lt;p&gt;       (4).事件也是一种委托&lt;/p&gt;
&lt;h3&gt;1.1.2.委托的调用&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
MyDelegateEventHandler fun=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyDelegateEventHandler(method);
or
MyDelegateEventHandler fun&lt;/span&gt;=&lt;span&gt;method;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; fun不为空，则调用回调方法&lt;/span&gt;
 &lt;span&gt;if&lt;/span&gt; (fun!= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
    {
         fun(val);
     }
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;fun?.Invoke(val); 简化版本调用 &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.1.3.委托的多播&lt;/h3&gt;
&lt;p&gt;每个委托都只包含一个方法调用，如果调用多个方法，就需要多次显示调用这个委托。如果同一个委托调用多个方法，我们就可以用多播委托&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public &lt;span&gt;delegate &lt;span&gt;void&lt;span&gt; MyDelegate ();

&lt;span&gt;public&lt;span&gt; voidMyMethod()
{
    &lt;span&gt;//&lt;span&gt;#
&lt;span&gt;}
&lt;span&gt;public &lt;span&gt;void&lt;span&gt; MyMethod1()
{
    &lt;span&gt;//&lt;span&gt;#
&lt;span&gt;}
&lt;span&gt;public &lt;span&gt;void&lt;span&gt; MyMethod2()
{
    &lt;span&gt;//&lt;span&gt;#
&lt;span&gt;}
MyDelegateEnventHander myDelegate；
myDelegate=&lt;span&gt;new&lt;span&gt; MyDelegateEventHander(MyMethod);
myDelegate+=&lt;span&gt;new&lt;span&gt; MyDelegateEventHander(MyMethod1);
...........
&lt;span&gt;//&lt;span&gt;调用&lt;span&gt;
myDelegate();&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 注：&lt;/p&gt;
&lt;p&gt;　　1.委托对象可使用 &quot;+&quot; 运算符进行合并；&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2.&quot;-&quot; 运算符可用于从合并的委托中移除组件委托；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　3.委托指定方法类型必须一致；&lt;/p&gt;
&lt;p&gt;　　4.返回类型一般为void,但非必须；&lt;/p&gt;
&lt;p&gt;　　5.GetInvocationList获取委托索引&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (MyDelegate != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
    System.Delegate[] dels &lt;/span&gt;=&lt;span&gt; MyDelegate .GetInvocationList(); 
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; dels.Length; i++&lt;span&gt;) 
　　{
      MyDelegate  &lt;/span&gt;-= dels[i] &lt;span&gt;as&lt;/span&gt;&lt;span&gt; MethodDelegate;
 　 }     &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上是利用GetInvocationList获取委托索引的一个简单应用。&lt;/p&gt;
&lt;h2&gt;1.2.Action&lt;/h2&gt;
&lt;p&gt; &lt;span&gt;Action至少0个参数，至多16个参数，无返回值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Action 表示无参，无返回值的委托
Action&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; 表示有传入参数int,string无返回值的委托
Action&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;bool&lt;/span&gt;&amp;gt; 表示有传入参数int,&lt;span&gt;string&lt;/span&gt;&lt;span&gt;,bool无返回值的委托
Action&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; 表示有传入4个int型参数，无返回值的委托
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Test&amp;lt;T&amp;gt;(Action&amp;lt;T&amp;gt;&lt;span&gt; action,T p)
        {
            action(p);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.3.Func&lt;/h2&gt;
&lt;p&gt; Func至少0个参数，至多16个参数，根据返回值泛型返回。必须有返回值，不可void&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Func是无返回值的泛型委托
Func&lt;/span&gt;&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; 表示无参，返回值为int的委托
Func&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&amp;gt; 表示传入参数为object, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; 返回值为int的委托
Func&lt;/span&gt;&amp;lt;&lt;span&gt;object&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&amp;gt; 表示传入参数为object, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; 返回值为int的委托
Func&lt;/span&gt;&amp;lt;T1,T2,,T3,&lt;span&gt;int&lt;/span&gt;&amp;gt; 表示传入参数为T1,T2,,T3(泛型)返回值为int的委托
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;1.4.predicate&lt;/h2&gt;
&lt;p&gt;1.4.1.predicate 是返回bool型的泛型委托;&lt;/p&gt;
&lt;p&gt;1.4.2.predicate&amp;lt;int&amp;gt; 表示传入参数为int 返回bool的委托;&lt;/p&gt;
&lt;p&gt;1.4.3.Predicate有且只有一个参数，返回值固定为bool;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Predicate&amp;lt;T&amp;gt; (T obj)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;2.1.d&lt;span&gt;elegate&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MyDelegateEventHandler (&lt;span&gt;string&lt;/span&gt;&lt;span&gt; parm)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; MyMethod(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; parm)
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;
&lt;span&gt;}
MyDelegateEventHandler MyDelegate&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; MyDelegateEventHandler(MyMethod)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注：委托实例化的时候，委托对象必须使用 &lt;strong&gt;new&lt;/strong&gt; 关键字来创建，且与一个特定的方法有关。委托参数中的方法不含参数。&lt;/p&gt;
&lt;h2&gt;2.2.Action的使用&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Test&amp;lt;T&amp;gt;(Action&amp;lt;T&amp;gt;&lt;span&gt; action, T p)
  {
    action(p);
  }
 &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Action(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; s)
 {
  #
 }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用&lt;/span&gt;&lt;span&gt;
Test&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(Action,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.3.Func的使用&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Test&amp;lt;T1, T2&amp;gt;(Func&amp;lt;T1, T2, &lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt; func, T1 a, T2 b)
{
 &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func(a, b);
}
&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Fun(&lt;span&gt;int&lt;/span&gt; a, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; b)
{
  #
}
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用&lt;/span&gt;
Test&amp;lt;&lt;span&gt;int&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt;&amp;gt;(Fun,&lt;span&gt;100&lt;/span&gt;,&lt;span&gt;200&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.4 委托实现冒泡排序&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义对象&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Scores{ &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Student(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;decimal&lt;/span&gt;&lt;span&gt; scores)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Name = name; &lt;span&gt;this&lt;/span&gt;.Scores=&lt;span&gt; scores;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; ToString()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;.Format(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0},{1:C}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,Name,Scores);
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CompareScores(Student e1,Student e2)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; e1.Scores&amp;lt;&lt;span&gt; e2.Scores;
        }
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用委托实现冒泡&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; BubbleScores
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Sort&amp;lt;T&amp;gt;(IList&amp;lt;T&amp;gt; sortArray, Func&amp;lt;T, T, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt; comparison)
        {
            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; swapped = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt;
            {
                swapped &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; sortArray.Count - &lt;span&gt;1&lt;/span&gt;; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (comparison(sortArray[i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;], sortArray[i]))
                    {
                        T temp &lt;/span&gt;=&lt;span&gt; sortArray[i];
                        sortArray[i] &lt;/span&gt;= sortArray[i + &lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
                        sortArray[i &lt;/span&gt;+ &lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; temp;
                        swapped &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    }
                }
            } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (swapped);
        }
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用&lt;/span&gt;
Student[] students=&lt;span&gt;{&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Student(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wyl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;100&lt;/span&gt;&lt;span&gt;),#};
BubbleSorter.Sort(students, Student.CompareScores);
&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; student &lt;span&gt;in&lt;/span&gt;&lt;span&gt; students)
    Console.WriteLine(student);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;3.1什么是匿名函数&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;匿名函数是一个“内联”语句或表达式，可在需要委托类型的任何地方使用。&lt;/p&gt;
&lt;p&gt;可以使用匿名函数来初始化命名委托（无需取名字的委托），或传递命名委托（而不是命名委托类型,传递一个方法块，而不是委托类型）[callback的方式]作为方法参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
MyDelegate funDelegate = &lt;span&gt;delegate&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; s) { Console.WriteLine(s); };
funDelegate (&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;this is anonymous delegate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3.2.lambda&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;lambda表达式实际上是一个匿名函数&lt;/span&gt;。编译器在看到lambda之后会在类中自动定义一个新的私有方法。lambda必须匹配委托！其中lambda是从c#3.0后引用的&lt;/p&gt;
&lt;p&gt;lambda的语法：&lt;/p&gt;
&lt;p&gt;参数 =&amp;gt; 方法体。&lt;/p&gt;
&lt;p&gt;=&amp;gt;左边是要传入的参数，本例中是传入一个Int类型的变量，=&amp;gt;右边是具体的代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不传递参数：&lt;/span&gt;
()=&amp;gt;Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Hello World!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递一个参数：&lt;/span&gt;
(&lt;span&gt;int&lt;/span&gt; n)=&amp;gt;&lt;span&gt;Console.WriteLine(n.ToString())   
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者去掉（）和int  编译器会自己推断类型：&lt;/span&gt;
n=&amp;gt;&lt;span&gt;Console.WriteLine(n.ToString())
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;传递多个参数：&lt;/span&gt;
(&lt;span&gt;int&lt;/span&gt; n ,&lt;span&gt;int&lt;/span&gt; m)=&amp;gt;Console.WriteLine(n+&lt;span&gt;m) 
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;或者编译器自己推断类型：&lt;/span&gt;
(n , m）=&amp;gt;Console.WriteLine(m+n)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Mon, 15 Jun 2020 16:51:00 +0000</pubDate>
<dc:creator>王延领</dc:creator>
<og:description>前言： C# 中的委托（Delegate）类似于 C 或 C++ 中函数的指针。委托是存有对某个方法的引用的一种引用类型变量。引用可在运行时被改变。委托（Delegate）特别用于实现事件和回调方法。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyl1924/p/13138793.html</dc:identifier>
</item>
<item>
<title>【Spring注解驱动开发】面试官：如何将Service注入到Servlet中？朋友又栽了！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13138757.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13138757.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;9.2118226600985&quot;&gt;
&lt;p&gt;最近，一位读者出去面试前准备了很久，信心满满的去面试。没想到面试官的一个问题把他难住了。面试官的问题是这样的：如何使用Spring将Service注入到Servlet中呢？这位读者平时也是很努力的，看什么源码啊、多线程啊、高并发啊、设计模式啊等等。没想到却在一个很简单的问题上栽了跟头，这就说明学习知识要系统化，要有条理，切忌东学一点，西记一点，否则，到头来，啥也学不到。&lt;/p&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;如何实现将service注入到servlet中？？&quot;&gt;如何实现将Service注入到Servlet中？？&lt;/h2&gt;
&lt;p&gt;这里，我们列举两种解决方法（推荐使用第二种）&lt;/p&gt;
&lt;h3 id=&quot;方法一：&quot;&gt;方法一：&lt;/h3&gt;
&lt;p&gt;直接重写Servlet的Init()方法，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void init(ServletConfig servletConfig) throws ServletException {
        ServletContext servletContext = servletConfig.getServletContext();
        WebApplicationContext webApplicationContext = WebApplicationContextUtils
                        .getWebApplicationContext(servletContext);
        AutowireCapableBeanFactory autowireCapableBeanFactory = webApplicationContext
                        .getAutowireCapableBeanFactory();
        autowireCapableBeanFactory.configureBean(this, BEAN_NAME);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的BEAN_NAME即为我们需要注入到Spring容器中的服务，但这并不是一个好的方法，因为我们需要在每一个Servlet中都进行这样的操作。&lt;/p&gt;
&lt;h3 id=&quot;方法二：&quot;&gt;方法二：&lt;/h3&gt;
&lt;p&gt;我们可以写一个类似于“org.springframework.web.struts.DelegatingRequestProcessor”的委托的Bean，然后通过配置的方法把我们的服务注入到servlet中，具体方法如下，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 1：编写委托类DelegatingServletProxy&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.telek.pba.base.util;

import java.io.IOException;
import javax.servlet.GenericServlet;
import javax.servlet.Servlet;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import org.springframework.web.context.WebApplicationContext;
import org.springframework.web.context.support.WebApplicationContextUtils;

/**
 * 以下是类似org.springframework.web.struts.DelegatingRequestProcessor的一个委托
 * 用于通过配置的方法，在Servlet中注入Service
 * @author binghe
 * */
public class DelegatingServletProxy extends GenericServlet{
    private static final long serialVersionUID = 1L;
    private String targetBean;
    private Servlet proxy;

   @Override
   public void service(ServletRequest req, ServletResponse res) throws ServletException, IOException{
                proxy.service(req, res);
   }
     /**
      * 初始化
      */
      public void init() throws ServletException {
          this.targetBean = getServletName();
          getServletBean();
          proxy.init(getServletConfig());
      }

     /**
      * 获取Bean
      */
      private void getServletBean() {
          WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(getServletContext());
          this.proxy = (Servlet) wac.getBean(targetBean);
      }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Step 2：修改Web.xml配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在纯Servlet模式下，我们的配置方式如下（以下由于代码高亮插件的问题，请将代码中的#替换成尖括号）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;servlet&amp;gt;
  &amp;lt;description&amp;gt;活动发起模块活动查询分页Servlet&amp;lt;/description&amp;gt;
  &amp;lt;display-name&amp;gt;launchActivityQueryServlet&amp;lt;/display&amp;gt;
  &amp;lt;servlet-name&amp;gt;LaunchActivityQueryServlet&amp;lt;/servlet-name&amp;gt;
  &amp;lt;servlet-class&amp;gt;com.telek.pba.launch.servlet.LaunchActivityQueryServlet&amp;lt;/servlet-class&amp;gt;
&amp;lt;servlet&amp;gt;

&amp;lt;servlet-mapping&amp;gt;
  &amp;lt;servlet-name&amp;gt;LaunchActivityQueryServlet&amp;lt;/servlet-name&amp;gt;
  &amp;lt;url-pattern&amp;gt;/servlet/launch/LaunchActivityQueryServlet&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/servlet&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果采用我们这种代理的方法，则配置应该修改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;servlet&amp;gt;
  &amp;lt;description&amp;gt;活动发起模块活动查询分页Servlet&amp;lt;/description&amp;gt;
  &amp;lt;display-name&amp;gt;launchActivityQueryServlet&amp;lt;/display&amp;gt;
  &amp;lt;servlet-name&amp;gt;launchActivityQueryServlet&amp;lt;/servlet-name&amp;gt;
  &amp;lt;servlet-class&amp;gt;com.telek.pba.base.util.DelegatingServletProxy&amp;lt;/servlet-class&amp;gt;
&amp;lt;servlet&amp;gt;

&amp;lt;servlet-mapping&amp;gt;
  &amp;lt;servlet-name&amp;gt;launchActivityQuery&amp;lt;/servlet-name&amp;gt;
  &amp;lt;url-pattern&amp;gt;/servlet/launch/LaunchActivityQueryServlet&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&amp;lt;/servlet&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：默认情况下，Servlet的配置中，LaunchActivityQuery的首字母一般为大写，而我们的标题中已注明，我们采用Spring的注解模式，如果是自动扫描注解的话，默认情况下，注解的value值为首字母小写，即：launchActivityQuery，因此，在我们新的配置中，要注意将首字母改为小写，否则会报无法找到Bean的错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Step 3：至此，我们就可以像SSH的注入方式一样，注入Servlet了，以下是个小示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.telek.pba.launch.servlet;

import java.io.IOException;
import javax.annotation.Resource;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import org.springframework.stereotype.Component;
import com.telek.pba.base.model.PbaUserInfo;
import com.telek.pba.launch.dao.IPbaActivityInfoCurrentDAO;

@Component
public class LaunchActivityQueryServlet extends HttpServlet {
        private static final long serialVersionUID = 1L;
         
        //注入IPbaActivityInfoCurrentDAO
        @Resource
        private IPbaActivityInfoCurrentDAO pbaActivityInfoCurrentDAO;

        public LaunchActivityQueryServlet() {
                super();
        }
         
        public void destroy() {
                super.destroy(); // Just puts &quot;destroy&quot; string in log
                // Put your code here
        }
         
        public void doGet(HttpServletRequest request, HttpServletResponse response)
                        throws ServletException, IOException {
                //sth to do
        }
         
        public void doPost(HttpServletRequest request, HttpServletResponse response)
                        throws ServletException, IOException {
                //sth to do
        }
         
        public void init() throws ServletException {
                // Put your code here
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，请留心在Spring配置文件中，配置上自动扫描包的路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;context:component-scan base-package=&quot;com.telek.pba.*.dao.impl,
                                        com.telek.pba.*.service.impl,
                                        com.telek.pba.*.servlet&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;大功告成！&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，咱们今天就聊到这儿吧！别忘了给个在看和转发，让更多的人看到，一起学习一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.3333333333333&quot;&gt;
&lt;p&gt;项目工程源码已经提交到GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/spring-annotation&quot;&gt;https://github.com/sunshinelyz/spring-annotation&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索并关注「 冰河技术 」微信公众号，跟冰河学习Spring注解驱动开发。公众号回复“spring注解”关键字，领取Spring注解驱动开发核心知识图，让Spring注解驱动开发不再迷茫。&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 15 Jun 2020 16:33:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 最近，一位读者出去面试前准备了很久，信心满满的去面试。没想到面试官的一个问题把他难住了。面试官的问题是这样的：如何使用Spring将Service注入到Servlet中呢？这位读者平时也是很</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13138757.html</dc:identifier>
</item>
<item>
<title>容器技术之Docker资源限制 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/13138725.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/13138725.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/qiuhom-1874/1655970/o_200227045925docker.png&quot; class=&quot;desc_img&quot;/&gt; 所谓OOM就是当系统上的应用申请内存资源时，发现申请不到内存，这个时候Linux内核就会启动OOM，内核将给系统上的所有进程进行评分，通过评分得分最高的进程就会被系统第一个干掉，从而腾出一些内存空间，如果腾出的内存空间还是不够该应用使用，它会继续杀得分第二高的，直到应用有足够的内存使用；一旦发生OOM，任何进程都有可能被杀死，包括docker daemon在内，为此，docker特定调整了docker daemon的oom优先级，以免发生oom被内核杀死，但是容器的oom优先级并未做任何调整；&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;121.00939340869&quot;&gt;
&lt;p&gt;　　上一篇我们聊到了docker容器的单机编排工具docker-compose的简单使用，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/13121678.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/13121678.html&lt;/a&gt;；今天我们主要来聊一聊docker容器的资源限制；通常情况下我们启动一个docker容器，其内存和CPU都是同宿主机一样大，这意味着该容器和宿主机共享相同大小的内存和CPU资源；这样一来容器正常情况下没有什么问题，假如容器里运行的进程特别爱吃内存，很可能存在把宿主机上的内存全部吃掉，触发内核OOM，从而导致docker daemon直接被内核杀死；为了避免这样的尴尬局面，对启动容器我们有必要对容器的资源进行限制；&lt;/p&gt;
&lt;p&gt;　　所谓OOM就是当系统上的应用申请内存资源时，发现申请不到内存，这个时候Linux内核就会启动OOM，内核将给系统上的所有进程进行评分，通过评分得分最高的进程就会被系统第一个干掉，从而腾出一些内存空间，如果腾出的内存空间还是不够该应用使用，它会继续杀得分第二高的，直到应用有足够的内存使用；一旦发生OOM，任何进程都有可能被杀死，包括docker daemon在内，为此，docker特定调整了docker daemon的oom优先级，以免发生oom被内核杀死，但是容器的oom优先级并未做任何调整；&lt;/p&gt;
&lt;p&gt;　　那么对于内存资源来讲，在启动为容器时，我们可以通过一些选项来指定容器的内存相关设置；如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200615221521511-1022389329.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：-m 或 --memory 用来指定容器最大能够使用的内存大小，默认情况不指定表示共享物理宿主机的内存大小；--memory-swap 用来指定容器的内存和交换内存的总大小；对于这个参数的取值比较诡异；待会在说吧；--memory-swappiness该选项用来指定容器使用交换内存的倾向性，swap启用有个好处就是在内存不够使用的情况，它可以临时顶替一部分，但是性能会急剧下降；所以数字越大越早使用交换内存，数字越小越晚使用交换内存，取值在0-100之间；0不代表不是用交换内存，0表示能不用交换内存，则不用，但是在迫不得已的情况还是会使用的，100表示只要有一丝可以使用交换内存的希望，就使用交换内存；通常情况在运行容器的主机上不建议使用swap设备；swap交换分区如果一旦被激活，系统性能会急剧下降，建议直接禁用；--memory-reservation该选项用来指定给系统保留的内存空间大小；--kernel-memory用来指定给内核保留的内存大小；--oom-kill-disable该选项用于指定当发生oom时，是否禁用因oom而杀死该容器进程；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200615223552178-1755489743.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：通常情况--memory-swap这个选项必须同--memory选项一起使用，不可用单独使用；&lt;/p&gt;
&lt;p&gt;　　示例：限制容器使用最大内存为256M&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@docker_registry ~]# docker run --name test --rm -m 256M lorel/docker-stress-ng --vm 2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上命令表示启动一个名为test的容器，限制该容器最大使用内存大小为256M；lorel/docker-stress-ng这个进行用来压测容器；--vm表示同时使用多少进程来做压测；&lt;/p&gt;
&lt;p&gt;　　验证：用docker stats看看我们启动test容器是否只能使用256M内存？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200615224807896-979565777.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的结果可以看到，在我们启动容器时，使用-m指定内存大小的容器limit的值就是我们指定的值，而对于没有用-m指定的容器，默认就是同宿主机内存大小一样；&lt;/p&gt;
&lt;p&gt;　　对于CPU来讲，默认情况启动容器时，不限制CPU的资源，此时容器是共享宿主机的CPU资源，也就是说默认情况宿主机上有几颗cpu核心，启动的容器就有多少颗核心；对于CPU这种可压缩资源，不会像内存那样，如果CPU满载，也不会导致某个容器崩溃，原因是因为cpu是可压缩资源；而不同于内存，内存属于不可压缩资源，如果申请不到内存，就会出现异常，出现oom；对启动容器来限制cpu资源，通常也是使用选项来限定；如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200615230200990-674180642.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：--cpus用来指定容器能够使用的最大cpu核心数，例如--cpus=1.5,就表示该容器最大能够使用1.5核的CPU资源，如果宿主机上有4颗CPU核心，那么该容器最多可把1.5颗核心跑满；这样说吧，如果宿主机上有4颗核心，那么该容器如果使用--cpus限定为1.5，那么该容器就只能使用宿主机上的百分之150的核心；--cpu-period 和--cpu-quota该选项在docker1.13以后基本废弃；--cpuset-cpus该选项用于指定容器能够在哪些CPU上运行；如果宿主机上有4颗CPU，--cpuset-cpus=2,3就表示该容器只能使用第2号cpu和第3号cpu;--cpu-shares该选项用于指定容器使用cpu的比例；比如宿主机上只有一个容器，而该容器启动时指定--cpu-shares=1024，则表示，如果没有其他容器，则它可以使用宿主机上的所有cpu资源，如果有第二个容器启动时，指定cpu-shares=512，那么第一个容器会从原来使用整个宿主机的cpu变为使用整个宿主机的cpu的2/3；以此类推，如果有第三个，第四个，他们使用cpu资源都是按照给定的比例动态调整；&lt;/p&gt;
&lt;p&gt;　　示例：第一个容器使用--cpu-shares=256;第二个容器使用--cpu-shares=512，看看当第一个容器启动后，看看cpu使用情况，然后第二个容器启动后再看看cpu使用情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200616001227516-2092501521.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到当第一个容器启动时，虽然设置的cpu-shares=256，但是它还是把所有核心几乎都跑满了；我们在跑一个容器看看，看看第二个容器启动后，第一个容器的cpu使用情况是否有变化？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200616001426674-2031750902.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的结果看，t1和t2的cpu使用比例大概是1比2；总量还是400%并没有变化；&lt;/p&gt;
&lt;p&gt;　　示例：设置容器使用1.5个CPU核心&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200616001631045-875636000.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的结果可以看到使用--cpus来限定容器使用的CPU资源，默认它会在每颗黑核心上都要使用一部分，但是重量不会超过150%；&lt;/p&gt;
&lt;p&gt;　　示例：限定容器使用CPU核心，只能在0号和3号核心上使用；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202006/1503305-20200616001934276-79041209.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：从上面的结果可以看到，限定t1容器只能使用0号和3号CPU后，1号和2号就基本不会被使用，总量也不会增加；&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 15 Jun 2020 16:29:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>上一篇我们聊到了docker容器的单机编排工具docker-compose的简单使用，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/13121678.html；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/13138725.html</dc:identifier>
</item>
</channel>
</rss>