<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[ASP.NET Core 3框架揭秘] 文件系统[4]：程序集内嵌文件系统 - Artech</title>
<link>http://www.cnblogs.com/artech/p/inside-asp-net-core-04-04.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/inside-asp-net-core-04-04.html</guid>
<description>&lt;p&gt;一个物理文件可以直接作为资源内嵌到编译生成的程序集中。借助于EmbeddedFileProvider，我们可以采用统一的编程方式来读取内嵌的资源文件，该类型定义在 “Microsoft.Extensions.FileProviders.Embedded”这个NuGet包中。在正式介绍EmbeddedFileProvider之前，我们必须知道如何将一个项目文件作为资源内嵌入到编译生成的程序集中。&lt;/p&gt;

&lt;p&gt;在默认情况下，我们添加到一个.NET Core项目中的静态文件并不会成为目标程序集的内嵌资源文件。如果需要将静态文件作为目标程序集的内嵌文件，我们需要修改当前项目对应的.csproj文件。具体来说，我们需要按照前面实例演示的方式在.csproj文件中添加&amp;lt;ItemGroup&amp;gt;/&amp;lt;EmbeddedResource&amp;gt;元素，并利用Include属性显式地将对应的资源文件包含进来。当我们直接利用Visual Studio将资源文件的Build Action属性设置为“Embedded resource”，IDE会自动帮助我们修改项目文件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191125083424836-85673831.png&quot;&gt;&lt;img width=&quot;205&quot; height=&quot;239&quot; title=&quot;5-6&quot; alt=&quot;5-6&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191125083426168-1763590946.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;EmbeddedResource&amp;gt;的Include属性可以设置多个路径，路径之间采用分号（“；”）作为分隔符。以上图所示的目录结构为例，如果我们需要将root目录下的四个文件作为程序集的内嵌文件，我们可以修改.csproj文件并按照如下的形式将四个文件的路径包含进来。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Project &lt;/span&gt;&lt;span&gt;Sdk&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.NET.Sdk&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    ...
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EmbeddedResource  
            &lt;/span&gt;&lt;span&gt;Include&lt;/span&gt;&lt;span&gt;=&quot;root/dir1/foobar/foo.txt;root/dir1/foobar/bar.txt;root/dir1/baz.txt;root/dir2/qux.txt&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;EmbeddedResource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了指定每个需要内嵌的资源文件的路径之外，我们还可以采用基于通配符“*”和“**”的Globbing Pattern表达式将一组匹配的文件批量包含进来。同样是将root目录下的所有文件作为程序集的内嵌文件，如下的定义方式就会简洁得多。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Project &lt;/span&gt;&lt;span&gt;Sdk&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.NET.Sdk&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    ...
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EmbeddedResource  &lt;/span&gt;&lt;span&gt;Include&lt;/span&gt;&lt;span&gt;=&quot;root/**&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;EmbeddedResource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&amp;lt;EmbeddedResource&amp;gt;除了具有一个Include属性用来添加内嵌资源文件之外，它还具有另一个Exclude属性负责将不符合要求的文件排除出去。还是以前面这个项目为例，对于root目录下的四个文件，如果我们不希望文件baz.txt作为内嵌资源文件，我们可以按照如下的方式将它排除。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Project &lt;/span&gt;&lt;span&gt;Sdk&lt;/span&gt;&lt;span&gt;=&quot;Microsoft.NET.Sdk&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
    ...
    &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ItemGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;EmbeddedResource  &lt;/span&gt;&lt;span&gt;Include&lt;/span&gt;&lt;span&gt;=&quot;root/**&quot;&lt;/span&gt;&lt;span&gt; Exclude&lt;/span&gt;&lt;span&gt;=&quot;root/dir1/baz.txt&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;EmbeddedResource&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt; 
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ItemGroup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Project&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每个程序集都有一个清单文件（Manifest），它的一个重要作用就是记录组成程序集的所有文件成员。总的来说，一个程序集主要由两种类型的文件构成，它们分别是承载IL代码的托管模块文件和编译时内嵌的资源文件。针对上图所示的项目结构，如果我们将四个文本文件以资源文件的形式内嵌到生成的程序集（App.dll）中，程序集的清单文件将会采用如下所示的形式来记录它们。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.mresource public App.root.dir1.baz.txt
{
  // Offset: 0x00000000 Length: 0x0000000C
}
.mresource public App.root.dir1.foobar.bar.txt
{
  // Offset: 0x00000010 Length: 0x0000000C
}
.mresource public App.root.dir1.foobar.foo.txt
{
  // Offset: 0x00000020 Length: 0x0000000C
}
.mresource public App.root.dir2.qgux.txt
{
  // Offset: 0x00000030 Length: 0x0000000C
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;虽然文件在原始的项目中具有层次化的目录结构，但是当它们成功转移到编译生成的程序集中之后，目录结构将不复存在，所有的内嵌文件将统一存放在同一个容器中。如果我们通过Reflector打开程序集，资源文件的扁平化存储将会一目了然。为了避免命名冲突，编译器将会根据原始文件所在的路径来对资源文件重新命名，具体的规则是“&lt;span&gt;{BaseNamespace}.{Path}&lt;/span&gt;”，目录分隔符将统一转换成“.”。值得强调的是资源文件名称的前缀不是程序集的名称，而是我们为项目设置的&lt;span&gt;基础命名空间&lt;/span&gt;的名称。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191125083426444-1263089430.png&quot;&gt;&lt;img width=&quot;408&quot; height=&quot;286&quot; title=&quot;5-7&quot; alt=&quot;5-7&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201911/19327-20191125083426841-1579188475.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;表示程序集的Assembly对象定义了如下几个方法来提取内嵌资源的文件的相关信息和读取指定资源文件的内容。&lt;span&gt;GetManifestResourceNames&lt;/span&gt;方法帮助我们获取记录在程序集清单文件中的资源文件名，而另一个方法GetManifestResourceInfo则用于获取指定资源文件的描述信息。如果我们需要读取某个资源文件的内容，我们可以将资源文件名称作为参数调用&lt;span&gt;GetManifestResourceStream&lt;/span&gt;方法，该方法会返回一个读取文件内容的Stream对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Assembly
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] GetManifestResourceNames();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; ManifestResourceInfo GetManifestResourceInfo(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; resourceName);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Stream GetManifestResourceStream(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; name);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同样是针对前面这个演示项目对应的目录结构，当四个文件作为内嵌文件被成功转移到编译生成的程序集中后，我们可以调用程序集对象的GetManifestResourceNames方法获取这四个内嵌文件的资源名称。如果以资源名称（“App.root.dir1.foobar.foo.txt”）作为参数调用GetManifestResourceStream方法，我们可以读取资源文件的内容，具体的演示如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; assembly = &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Program).Assembly;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; resourceNames =&lt;span&gt; assembly.GetManifestResourceNames();
        Debug.Assert(resourceNames.Contains(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App.root.dir1.foobar.foo.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        Debug.Assert(resourceNames.Contains(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App.root.dir1.foobar.bar.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        Debug.Assert(resourceNames.Contains(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App.root.dir1.baz.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        Debug.Assert(resourceNames.Contains(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App.root.dir2.qgux.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)); 

        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; stream = assembly.GetManifestResourceStream(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App.root.dir1.foobar.foo.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; buffer = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[stream.Length];
        stream.Read(buffer, &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, buffer.Length);
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; content =&lt;span&gt; Encoding.Default.GetString(buffer);  
        Debug.Assert(content &lt;/span&gt;== File.ReadAllText(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;App/root/dir1/foobar/foo.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在对内嵌于程序集的资源文件有了大致的了解之后，针对EmbeddedFileProvider的实现原理就很好理解了。由于内嵌于程序集的资源文件采用扁平化存储形式，所以在通过 EmbeddedFileProvider构建的文件系统中并没有目录层级的概念。我们可以认为所有的资源文件都保存在程序集的“根目录”下。对于EmbeddedFileProvider构建的文件系统来说，它提供的IFileInfo对象总是对一个具体资源文件的描述，这是一个具有如下定义的EmbeddedResourceFileInfo对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EmbeddedResourceFileInfo : IFileInfo
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; Assembly     _assembly;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;?&lt;span&gt; _length;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;  _resourcePath;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; EmbeddedResourceFileInfo(Assembly assembly, &lt;span&gt;string&lt;/span&gt; resourcePath, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; name, DateTimeOffset lastModified)
    {
        _assembly &lt;/span&gt;=&lt;span&gt; assembly;
        _resourcePath &lt;/span&gt;=&lt;span&gt; resourcePath;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.LastModified =&lt;span&gt; lastModified;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Stream CreateReadStream()
    {
        Stream stream &lt;/span&gt;=&lt;span&gt; _assembly.GetManifestResourceStream(_resourcePath);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._length.HasValue)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._length = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;?&lt;span&gt;(stream.Length);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; stream;
    }
    
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; Exists =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsDirectory =&amp;gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTimeOffset LastModified { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }    

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; PhysicalPath =&amp;gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; Length
    {
        &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_length.HasValue)
            {
                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (Stream stream =_assembly.GetManifestResourceStream(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._resourcePath))
                {
                    _length &lt;/span&gt;=&lt;span&gt; stream.Length;
                }
            }
            rReturn _length.Value;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上面的代码片段所示，我们在创建一个EmbeddedResourceFileInfo对象的时候需要指定内嵌资源文件在清单文件的中的路径（resourcePath）、所在的程序集、资源文件的名称（name）和作为文件最后修改时间的DateTimeOffset对象。由于一个EmbeddedResourceFileInfo对象总是对应着一个具体的内嵌资源文件，所以它的Exists属性总是返回True，IsDirectory属性则返回False。由于资源文件系统并不具有层次化的目录结构，它所谓的物理路径毫无意义，所以PhysicalPath属性直接返回Null。CreateReadStream方法返回的是调用程序集的GetManifestResourceStream方法返回的输出流，而表示文件长度的Length返回的是这个Stream对象的长度。&lt;/p&gt;
&lt;p&gt;如下所示的是 EmbeddedFileProvider的定义。当我们在创建一个EmbeddedFileProvider对象的时候，除了指定资源文件所在的程序集之外，还可以指定一个基础命名空间。如果该命名空间没作显式设置，默认情况下会将程序集的名称作为命名空间，也就是说如果我们为项目指定了一个不同于程序集名称的基础命名空间，那么当创建这个EmbeddedFileProvider对象的时候必须指定这个命名空间。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EmbeddedFileProvider : IFileProvider
{   
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EmbeddedFileProvider(Assembly assembly);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; EmbeddedFileProvider(Assembly assembly, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; baseNamespace);

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IDirectoryContents GetDirectoryContents(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; subpath);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IFileInfo GetFileInfo(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; subpath);
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IChangeToken Watch(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; pattern);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们调用EmbeddedFileProvider的GetFileInfo方法并指定资源文件的逻辑名称时，该方法会将它与命名空间一起组成资源文件在程序集清单的名称（路径分隔符会被替换成“.”）。如果对应的资源文件存在，那么一个EmbeddedResourceFileInfo会被创建并返回，否则返回的将是一个NotFoundFileInfo对象。对于内嵌资源文件系统来说，根本就不存在所谓的文件更新的问题，所以它的Watch方法会返回一个HasChanged属性总是False的IChangeToken对象。&lt;/p&gt;
&lt;p&gt;由于内嵌于程序集的资源文件总是只读的，它所谓的最后修改时间实际上是程序集的生成日期，所以EmbeddedFileProvider在提供EmbeddedResourceFileInfo对象的时候会采用程序集文件的最后更新时间作为资源文件的最后更新时间。如果不能正确地解析出这个时间，EmbeddedResourceFileInfo的LastModified属性将被设置为当前UTC时间。&lt;/p&gt;
&lt;p&gt;由于 EmbeddedFileProvider构建的内嵌资源文件系统不存在层次化的目录结构，所有的资源文件可以视为统统存储在程序集的“根目录”下，所以它的GetDirectoryContents方法只有在我们指定一个空字符串或者“/”（空字符串和“/”都表示“根目录”）时才会返回一个描述这个“根目录”的DirectoryContents对象，该对象实际上是一组EmbeddedResourceFileInfo对象的集合。在其他情况下，EmbeddedFileProvider的GetDirectoryContents方法总是返回一个NotFoundDirectoryContents对象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-04-01.html&quot;&gt;[ASP.NET Core 3框架揭秘] 文件系统[1]：抽象的“文件系统”&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-04-02.html&quot;&gt;[ASP.NET Core 3框架揭秘] 文件系统[2]：总体设计&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-04-03.html&quot;&gt;[ASP.NET Core 3框架揭秘] 文件系统[3]：物理文件系统&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-04-04.html&quot;&gt;[ASP.NET Core 3框架揭秘] 文件系统[4]：程序集内嵌文件系统&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Nov 2019 00:34:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>一个物理文件可以直接作为资源内嵌到编译生成的程序集中。借助于EmbeddedFileProvider，我们可以采用统一的编程方式来读取内嵌的资源文件，该类型定义在 “Microsoft.Extensi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/inside-asp-net-core-04-04.html</dc:identifier>
</item>
<item>
<title>SpringBoot系列教程Web篇之开启GZIP数据压缩 - 一灰灰Blog</title>
<link>http://www.cnblogs.com/yihuihui/p/11925743.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yihuihui/p/11925743.html</guid>
<description>&lt;p&gt;本篇可以归纳在性能调优篇，虽然内容非常简单，但效果可能出乎预料的好；&lt;/p&gt;
&lt;p&gt;分享一个真实案例，我们的服务部署在海外，国内访问时访问服务时，响应有点夸张；某些返回数据比较大的接口，耗时在 600ms+上，然而我们的服务 rt 却是在 20ms 以下，绝大部分的开销都花在了网络传输上&lt;/p&gt;
&lt;p&gt;针对这样的场景，除了买云服务商的网络通道之外，另外一个直观的想法就是减少数据包的大小，直接在 nginx 层配置 gzip 压缩是一个方案，本文主要介绍下，SpringBoot 如何开启 gzip 压缩&lt;/p&gt;
&lt;h2 id=&quot;i.-gizp-压缩配置&quot;&gt;I. gizp 压缩配置&lt;/h2&gt;
&lt;h3 id=&quot;配置&quot;&gt;1. 配置&lt;/h3&gt;
&lt;p&gt;SpringBoot 默认是不开启 gzip 压缩的，需要我们手动开启，在配置文件中添加两行&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;server:
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/plain,text/css,application/x-javascript&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意下上面配置中的&lt;code&gt;mime-types&lt;/code&gt;，在 spring2.0+的版本中，默认值如下，所以一般我们不需要特意添加这个配置&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// org.springframework.boot.web.server.Compression#mimeTypes
/**
 * Comma-separated list of MIME types that should be compressed.
 */
private String[] mimeTypes = new String[] { &quot;text/html&quot;, &quot;text/xml&quot;, &quot;text/plain&quot;,
        &quot;text/css&quot;, &quot;text/javascript&quot;, &quot;application/javascript&quot;, &quot;application/json&quot;,
        &quot;application/xml&quot; };&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;测试&quot;&gt;2. 测试&lt;/h3&gt;
&lt;p&gt;写一个测试的 demo&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
public class HelloRest {
    @GetMapping(&quot;bigReq&quot;)
    public String bigReqList() {
        List&amp;lt;String&amp;gt; result = new ArrayList&amp;lt;&amp;gt;(2048);
        for (int i = 0; i &amp;lt; 2048; i++) {
            result.add(UUID.randomUUID().toString());
        }
        return JSON.toJSONString(result);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://spring.hhui.top/spring-blog/imgs/191120/00.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是开启压缩前后的数据报对比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://spring.hhui.top/spring-blog/imgs/191120/01.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;说明&quot;&gt;3. 说明&lt;/h3&gt;
&lt;p&gt;虽然加上了上面的配置，开启了 gzip 压缩，但是需要注意并不是说所有的接口都会使用 gzip 压缩，默认情况下，仅会压缩 2048 字节以上的内容&lt;/p&gt;
&lt;p&gt;如果我们需要修改这个值，通过修改配置即可&lt;/p&gt;
&lt;pre class=&quot;yaml&quot;&gt;
&lt;code&gt;server:
  compression:
    min-response-size: 1024&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ii.-其他&quot;&gt;II. 其他&lt;/h2&gt;
&lt;h3 id=&quot;项目&quot;&gt;0. 项目&lt;/h3&gt;
&lt;h4 id=&quot;web-系列博文&quot;&gt;web 系列博文&lt;/h4&gt;
&lt;h4 id=&quot;项目源码&quot;&gt;项目源码&lt;/h4&gt;
&lt;h3 id=&quot;一灰灰-blog&quot;&gt;1. 一灰灰 Blog&lt;/h3&gt;
&lt;p&gt;尽信书则不如，以上内容，纯属一家之言，因个人能力有限，难免有疏漏和错误之处，如发现 bug 或者有更好的建议，欢迎批评指正，不吝感激&lt;/p&gt;
&lt;p&gt;下面一灰灰的个人博客，记录所有学习和工作中的博文，欢迎大家前去逛逛&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://spring.hhui.top/spring-blog/imgs/info/info.png&quot; alt=&quot;一灰灰blog&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Nov 2019 00:32:00 +0000</pubDate>
<dc:creator>一灰灰Blog</dc:creator>
<og:description>本篇可以归纳在性能调优篇，虽然内容非常简单，但效果可能出乎预料的好； 分享一个真实案例，我们的服务部署在海外，国内访问时访问服务时，响应有点夸张；某些返回数据比较大的接口，耗时在 600ms+上，然而</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yihuihui/p/11925743.html</dc:identifier>
</item>
<item>
<title>十年风雨，一个普通程序员的成长之路（八）不想做技术总监的项目经理，不是好程序员 - 姚毛毛</title>
<link>http://www.cnblogs.com/yaomaomao/p/11925744.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yaomaomao/p/11925744.html</guid>
<description>&lt;hr/&gt;&lt;h3 id=&quot;技术总监写不写代码&quot;&gt;01 技术总监写不写代码？&lt;/h3&gt;
&lt;p&gt;曾在IT界掀起腥风血雨的一个问题：技术总监要不要了解技术细节？&lt;/p&gt;
&lt;p&gt;归根到底的问题就是：技术总监还要不要写代码了？&lt;/p&gt;
&lt;p&gt;在18年12月前后，我给你的回答可能截然不同。&lt;/p&gt;
&lt;p&gt;18年12月，我离开了相伴多年的公司，换了一个东家。&lt;/p&gt;
&lt;p&gt;“我要写代码&quot;，五个大字映在我的胸腔。&lt;/p&gt;
&lt;p&gt;就在前段时间，老东家的上司还问我要不要回去。&lt;/p&gt;
&lt;p&gt;我想了下，回复如下：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;回去的话，不想带项目，不做项目经理，可以做售前、架构把控，写代码也可以；可以找人做项目经理，我前期可以带一程，或者协助。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我觉得XXX（我当前公司）这边的组织架构还可以，有总工、架构师、项目经理，架构师负责规划项目或者核心代码实现，项目经理负责项目进度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么这样说？&lt;/p&gt;
&lt;p&gt;请看我上文&lt;a href=&quot;https://www.cnblogs.com/yaomaomao/p/11075231.html&quot;&gt;十年风雨，一个普通程序员的成长之路（七）膨胀、骄傲，程序员转项目经理的原罪&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;两年的项目经理做下来，感觉在代码修炼、程序设计上没有任何的长进。&lt;/p&gt;
&lt;p&gt;在组建大数据项目组的时候，本以为自己可以投身项目，写一些核心代码，弄一弄Hadoop、hbase、jstorm、kafka、spark、kylin这些我们项目中用到的大数据技术。&lt;/p&gt;
&lt;p&gt;但是事与愿违，承担了一个项目经理的职责后，需求对接、项目里程碑跟进、对领导与客户的进度汇报、资源协调……等等等等，都成了不得不去关心、烦心、投入精力的事儿。&lt;/p&gt;
&lt;p&gt;如此下来，当18年结束大数据项目，我转岗成为技术经理，不想再做项目经理。&lt;/p&gt;
&lt;p&gt;可是又跟进了一个跨政府部门合作交换平台的项目，此时我唯一的要求就是给我配一个项目经理，我来负责这个项目的需求设计、架构选型与核心框架搭建。&lt;/p&gt;
&lt;p&gt;结果领导答应的好好的，原本要做这个项目经理的同事，却因为手头的事迟迟交接不掉，最终还是让我接手了。而那个同事因为不满于当前的工作状况，最终也是离职了。&lt;/p&gt;
&lt;p&gt;我觉得，这样的决策算是一种双输吧。&lt;/p&gt;
&lt;p&gt;因此，这让我萌生了一个念头，我是不是也该出去看看了。&lt;/p&gt;
&lt;p&gt;在18年12月前，我给你说上面那个问题（技术总监到底要不要写代码）的回答是，技术总监把控大方向就行了，写啥代码？哪来的时间给你？你又不是只负责这一个项目。&lt;/p&gt;
&lt;p&gt;【我最多的时候，担任了5个项目的管理工作、2个项目以上的系统架构与技术评审。】&lt;/p&gt;
&lt;p&gt;在18年12月后，我深深地跟你说，写代码吧兄弟。除非你想在这个公司养老。&lt;/p&gt;
&lt;p&gt;不写代码则不了解技术细节，不了解技术细节一出去面试就一个接一个的懵逼。&lt;/p&gt;
&lt;p&gt;关于这段经历的得到与思考：&lt;/p&gt;
&lt;p&gt;对于技术能力还没达到一定程度的程序员，我的建议是，还是先暂且放一放管理性的工作。&lt;/p&gt;
&lt;p&gt;可以做一做项目的研发leader，但是还是千万不要做事务型的项目管理工作，除非你对管理很感兴趣，那就走这条路吧。&lt;/p&gt;
&lt;h3 id=&quot;面试的坎坷与杯具&quot;&gt;02 面试的坎坷与杯具&lt;/h3&gt;
&lt;p&gt;在18年11月的时候，结束了跨部门交换平台的工作。于是闲了下来，便把51 job上的简历给更新了下。&lt;/p&gt;
&lt;p&gt;基本上每天都会有一个电话过来，约面试。&lt;/p&gt;
&lt;p&gt;可笑的是，当时真的是什么都没准备，两手空空，脑袋也是空空。&lt;/p&gt;
&lt;p&gt;没有去leetcode刷刷题，没有去把一些基本的java知识复习下，没有去好好返场熟悉下分布式、高并发。&lt;/p&gt;
&lt;p&gt;估计当时也是没做好离职的思想准备吧。&lt;/p&gt;
&lt;p&gt;很随意地去面试了几家，发先自己连很多基础知识都给忘了。&lt;/p&gt;
&lt;p&gt;有次印象深刻的面试，是一个年轻面试官拿了一份卷子出来，让我做笔试题。&lt;/p&gt;
&lt;p&gt;笔试题？&lt;/p&gt;
&lt;p&gt;Oh，No，我都好久没碰过这个玩意儿了。基本上都是面试聊一聊就结束了。&lt;/p&gt;
&lt;p&gt;然后这个面试官问了一个让我至今都还记得的问题：“什么是对象？”&lt;/p&gt;
&lt;p&gt;我特么直接懵逼了。什么是对象？要不要new一个给你？&lt;/p&gt;
&lt;p&gt;这个问题不是学习毕业第一年问的问题吗？&lt;/p&gt;
&lt;p&gt;我还真没答上来，脑子一片空白。&lt;/p&gt;
&lt;p&gt;我笑着说：“我懵逼了，你能给我点提示吗？”&lt;/p&gt;
&lt;p&gt;这次的面试经历应该是在我11月到12月这个阶段，多次面试经历中最糟糕的一次。&lt;/p&gt;
&lt;p&gt;因为感觉这个公司或是不尊重，或是招人、面试的制度、流程有问题。&lt;/p&gt;
&lt;p&gt;像是在进行校招似的。&lt;/p&gt;
&lt;p&gt;（当然，我自身也有问题，连这些基础知识都给忘得干干净净。）&lt;/p&gt;
&lt;p&gt;还有家公司的面试项目经理、项目总监、运维经理齐上阵面试我，结果问了一堆项目管理、数据库设计的问题，可是又说不到点上。&lt;/p&gt;
&lt;p&gt;我问他们到底是需要什么岗位的人才？他们说岗位很多，都需要，看面试人的能力情况。&lt;/p&gt;
&lt;p&gt;我了个去，你不说你招啥样的，我十八般武艺卖哪种呢？&lt;/p&gt;
&lt;p&gt;面试的倒数第二家就是我现在所在的公司。&lt;/p&gt;
&lt;p&gt;一面主要问的是对于性能有什么看法？&lt;/p&gt;
&lt;p&gt;我说了下QPS、TPS相关的一些概念，基本就过了。&lt;/p&gt;
&lt;p&gt;二面问了nginx、ES以及让我描述下性能优化的过程。&lt;/p&gt;
&lt;p&gt;nginx说实话我是交换平台项目才用的，并不熟悉，熟悉的是weblogic。&lt;/p&gt;
&lt;p&gt;面试官问我nginx有哪些负载策略？我挺懵逼的，还真没研究过，我说你能提示下吗？&lt;/p&gt;
&lt;p&gt;他笑了笑，说例如轮询。&lt;/p&gt;
&lt;p&gt;我想了下，回答说是配置upstream吗？&lt;/p&gt;
&lt;p&gt;之后回去看了下，nginx是可以配置轮询、ipHash、平均负载、权重负载多种负载策略。&lt;/p&gt;
&lt;p&gt;ES，即elasticSearch，我是真的没用过。这个东西我是知道的，但是遗憾的是面试时脑子有点糨糊，竟然说没听过这个玩意儿。&lt;/p&gt;
&lt;p&gt;【这个没听说过在广度上减分很大。】&lt;/p&gt;
&lt;p&gt;关于性能优化，我说了这样大致一个流程。&lt;br/&gt;因为跟数据库、数据仓库、查询打交道比较多，所以着重说了下数据查询的优化过程。&lt;/p&gt;
&lt;p&gt;（1）先找出慢SQL，以Oracle为例，可以通过AWR报表的方式查看。&lt;/p&gt;
&lt;p&gt;（2）查看慢SQL的执行计划，看看查询的关键字段是不是缺失索引，添加索引。&lt;/p&gt;
&lt;p&gt;（3）有索引，但是查看执行计划，并没有走索引。此时有两种方法，一是用hint，二是可能数据表最近被大批量的删除、新增过，需要手动收集数据表的统计信息，让SQL优化器正常解析SQL。&lt;/p&gt;
&lt;p&gt;（4）数据表太大，没有合适的全局索引。可不可以建设分区表？按照时间、地区进行分区操作。&lt;/p&gt;
&lt;p&gt;（5）不能分区，或者分区效果也不显著，需要考虑改动表结构了，有些字段是不是可以拆出去？做成维表、扩展表？&lt;/p&gt;
&lt;p&gt;【这是垂直拆分。缺点是查询时如果要查询扩展表字段，需要join操作，插入修改时要考虑多表，事物复杂。单表数据量还是太大。】&lt;/p&gt;
&lt;p&gt;（6）或者可以考虑进行分库分表操作。对于Oracle来说单张1亿以下数据分区就够了，不需要分库分表。&lt;br/&gt;【水平拆分。缺点是会导致事物一致性更为复杂，还需引入分库分表的管理中间件。】&lt;/p&gt;
&lt;p&gt;（7）进行历史数据分离。将一些不常用的数据，例如两年前的数据都拆分到历史表中。&lt;/p&gt;
&lt;p&gt;【即冷热数据分离。】&lt;/p&gt;
&lt;p&gt;（8）增加数据库性能，升级硬件，例如磁盘换上SSD。这个方法是被验证过了的，尤其是查询批量数据，无高效索引的时候。&lt;/p&gt;
&lt;p&gt;（9）从数据库层面已经无法优化了，我们可以考虑在应用端使用并行查询的方法爬出数据，然后再行合并。&lt;/p&gt;
&lt;p&gt;【事实上，很多报表工具都是这么做的。】&lt;/p&gt;
&lt;p&gt;（10）从业务上去优化，看看这样查询是不是有道理，这些字段是不是确实需要？需不需要这么精细？需不需要这么频繁？大数据量报表每月一出就行了？那这样就无所谓时效性了。&lt;/p&gt;
&lt;p&gt;面试最后，面试官问我对他们公司还有什么问题？&lt;/p&gt;
&lt;p&gt;我问了下如果入职后，将从事什么样的工作。回答的是一些中间件、平台的开发。&lt;/p&gt;
&lt;p&gt;我觉得还是比较契合我当前迷茫期的目标的。&lt;/p&gt;
&lt;p&gt;【真的是迷茫期，不知道干什么了。在老东家那里，最多也不过就是升个总监，养老罢了。技术上就完全与主流脱节、荒废了。】&lt;/p&gt;
&lt;p&gt;这个offer拿到后，便没有怎么再去面试了。&lt;/p&gt;
&lt;p&gt;关于这个offer，其实我再认真刷两天面试题，拿到的级别跟工资应该会更高点，但是这可能是我，或者也是很多程序员的一个通病吧。拿到了offer便不想去面试了，麻烦。&lt;/p&gt;
&lt;p&gt;其实还是应该再多看看的。&lt;/p&gt;
&lt;p&gt;关于面试的思考与得到：&lt;/p&gt;
&lt;p&gt;对于被面试者而言，应该准备充分点。因为时间太短，很多工作中可贵的品质没法在短短的半小时、一小时内展现出来。不要让自己遗憾，不要让面试你的公司错过你遗憾。&lt;/p&gt;
&lt;p&gt;对于面试官而言，我认为在面试、考查一个人的能力时，应该是去着重发现他的优点，而不是努力找出他的不足。&lt;/p&gt;
&lt;p&gt;每个人都有自己不擅长的一面。&lt;/p&gt;
&lt;p&gt;我们是来挖掘人才为公司增长业绩的，而不是显示自己能力来玩找茬游戏的。&lt;/p&gt;
&lt;h3 id=&quot;新的开始-旧的结束&quot;&gt;03 新的开始 &amp;amp; 旧的结束&lt;/h3&gt;
&lt;p&gt;在入职新公司后，第一周就是领个电脑，装些IDE工具，熟悉熟悉公司的规章，熟悉下同事，熟悉下工作范畴。&lt;/p&gt;
&lt;p&gt;第二周便来活了，是写个小工具，可以自动将spring项目中针对Oracle、mysql的SQL语句转换为适配国产数据库（达梦）。&lt;/p&gt;
&lt;p&gt;前期已有一个架构师做了初步调研，我喊他荣哥。荣哥搭了个架子，读入了mybatis的XML，我便开始解析、匹配、转换xml中的sql，按照插件模式做了个扩展接口，总共花了一周写好了这个demo。其中转换mysql的merge方法比较麻烦，花了有两天时间。&lt;/p&gt;
&lt;p&gt;这个demo可以转换大部门的SQL语句，对于无法转换的，则输出log，予以提示，多少行什么方法需要人工去转换。&lt;/p&gt;
&lt;p&gt;后续又调研技术专家，业务侧人员，做了这个工具的扩展方案，提炼了一个SQL辅助工具集。&lt;/p&gt;
&lt;p&gt;规划了一些扩展功能。如可以连接JDBC，利用jdbc数据库连接池收集SQL的执行次数、消耗时间，生成慢日志、错误日志文件，开发导入SQL的检测功能，通过分析每条SQL的执行时间、表的索引、主外键关联等数据，发现SQL错误、警告，获取SQL执行计划，提供建议，如SQL是否存在全表扫描、笛卡尔积等？&lt;/p&gt;
&lt;p&gt;当然，后续就没有后续了。&lt;/p&gt;
&lt;p&gt;因为业务的调整，这个项目后续并没有展开。&lt;/p&gt;
&lt;p&gt;而我，也开始投入下一个项目了。&lt;/p&gt;
&lt;p&gt;但是通过这样一个项目，我却觉得，这，的确是我想做的工作。&lt;/p&gt;
&lt;p&gt;2019，我来了。&lt;/p&gt;
&lt;p&gt;---------------我的成长之路系列---------------&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yaomaomao/p/10971161.html&quot;&gt;十年风雨，一个普通程序员的成长之路（一）怀念：西安的小黑屋&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yaomaomao/p/10971707.html&quot;&gt;十年风雨，一个普通程序员的成长之路（二）外包：颠沛与流离&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yaomaomao/p/10977067.html&quot;&gt;十年风雨，一个普通程序员的成长之路（三）铜陵：大雪与加班&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yaomaomao/p/10982898.html&quot;&gt;十年风雨，一个普通程序员的成长之路（四）深圳：积累与转折&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yaomaomao/p/10995613.html&quot;&gt;十年风雨，一个普通程序员的成长之路（五） 成长：得到与教训&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yaomaomao/p/11006186.html&quot;&gt;十年风雨，一个普通程序员的成长之路（六）抉择与出发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/yaomaomao/p/11075231.html&quot;&gt;十年风雨，一个普通程序员的成长之路（七）膨胀、骄傲，程序员转项目经理的原罪&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;欢迎关注我的公众号：姚毛毛的博客&lt;/p&gt;
&lt;p&gt;这里有我的编程生涯感悟与总结，有Java、Linux、Oracle、mysql的相关技术，有工作中进行的架构设计实践和读书理论，有JVM、Linux、数据库的性能调优，有……&lt;/p&gt;
&lt;p&gt;有技术，有情怀，有温度&lt;/p&gt;
&lt;p&gt;欢迎关注我：姚毛毛&amp;amp; 妖生&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/yaomaomao/1499288/o_191118063357gzh12cm.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 25 Nov 2019 00:32:00 +0000</pubDate>
<dc:creator>姚毛毛</dc:creator>
<og:description>十年风雨，一个普通程序员的成长之路（八）不想做技术总监的项目经理，不是好程序员 [TOC] 01 技术总监写不写代码？ 曾在IT界掀起腥风血雨的一个问题：技术总监要不要了解技术细节？ 归根到底的问题就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yaomaomao/p/11925744.html</dc:identifier>
</item>
<item>
<title>你真的会用JavaScript中的sort方法吗 - Peerless1029</title>
<link>http://www.cnblogs.com/peerless1029/p/11925580.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peerless1029/p/11925580.html</guid>
<description>&lt;p&gt;  在平时的业务开发中，&lt;strong&gt;数组(Array)&lt;/strong&gt; 是我们经常用到的数据类型，那么对数组的排序也很常见，除去使用循环遍历数组的方法来排列数据，使用JS数组中原生的方法 &lt;strong&gt;sort&lt;/strong&gt; 来排列（没错，比较崇尚JS原生的力量）。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/peerless1029/p/9950005.html&quot;&gt;面试题-如何判断一个对象是不是数组类型原文链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;举个栗子&quot;&gt;1、举个栗子&lt;/h2&gt;
&lt;p&gt;  数组中能够直接用来排序的方法有：reverse() 和 sort(),由于 reverse()方法不够灵活，才有了sort()方法。在默认情况下，sort()方法按升序排列数组。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var arr=[1,3,5,9,4];
console.log(arr.sort());
// 输出: [1, 3, 4, 5, 9]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时发现数据按照从小到大排列，没问题；于是再把数组改成：&lt;code&gt;var arr=[101,1,3,5,9,4,11];&lt;/code&gt;，再调用sort()方法打印排序结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var arr=[101,1,3,5,9,4,11];
console.log(arr.sort());
// 输出: [1, 101, 11, 3, 4, 5, 9]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候发现数组101,11都排在3前面，是因为 &lt;strong&gt;sort() 方法会调用数组的toString()转型方法，然后比较得到的字符串，确定如何排序，即使数组中的每一项都是数值，sort()方法比较的也是字符串。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么字符串又是怎么排序的呢，是根据字符串的unicode编码从小到大排序的。下面我们尝试打印出数组每一项的unicode编码看一下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;...
// 转码方法
function getUnicode (charCode) {
    return charCode.charCodeAt(0).toString(16);
}
// 打印转码
arr.forEach((n)=&amp;gt;{
  console.log(getUnicode(String(n)))
});

// 输出: 31 31 31 33 34 35 39
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;惊奇地发现，1,101,11的字符串unicode编码都是31&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;传入比较函数以指定顺序&quot;&gt;2、传入比较函数以指定顺序&lt;/h2&gt;
&lt;p&gt;  以上发现sort()方法不是按照我们想要的顺序排序的，那么，怎么解决呢，&lt;strong&gt;sort()方法可以接收一个比较函数作为参数，以便指定哪个值位于哪个值前面&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;比较函数(compare)接收两个参数，如果第一个参数位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数位于第二个之后则返回一个整数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;function compare(value1,value2){
  if (value1 &amp;lt; value2){
    return -1;
  } else if (value1 &amp;gt; value2){
    return 1;
  } else{
    return 0;
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把比较函数传递给sort()方法，在对arr数组进行排列，打印结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var arr=[101,1,3,5,9,4,11];
console.log(arr.sort(compare));
// 输出: [1, 3, 4, 5, 9, 11, 101];&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现排序从小到大没有什么问题。&lt;/p&gt;
&lt;h2 id=&quot;对象数组的排序&quot;&gt;3、对象数组的排序&lt;/h2&gt;
&lt;p&gt;  sort() 方法通过传入一个比较函数来排序数字数组，但是在开发中，我们会对一个对象数组的某个属性进行排序，例如id，年龄等等，那么怎么解决呢？&lt;/p&gt;
&lt;p&gt;要解决这个问题：我们可以定义一个函数，让它接收一个属性名，然后根据这个属性名来创建一个比较函数并作为返回值返回来（JS中函数可以作为值来使用，不仅可以像传递参数一样把一个函数传递给另一个函数，也可以将一个函数作为另一个函数的结果返回，&lt;strong&gt;函数作为JS中的第一等公民&lt;/strong&gt;不是没有原因的，确实很灵活。），代码如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function compareFunc(prop){
  return function (obj1,obj2){
    var value1=obj1[prop];
    var value2=obj2[prop];
    if (value1 &amp;lt; value2){
        return -1;
    } else if (value1 &amp;gt; value2){
        return 1;
    } else{
        return 0;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义一个数组users，调用sort()方法传入compareFunc(prop)打印输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;var users=[
    {name:'tom',age:18},
    {name:'lucy',age:24},
    {name:'jhon',age:17},
];
console.log(users.sort(compareFunc('age')));
// 输出结果
[{name: &quot;jhon&quot;, age: 17},
{name: &quot;tom&quot;, age: 18},
{name: &quot;lucy&quot;, age: 24}]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在默认情况下，调用sort()方法不传入比较函数时，sort()方法会调用每个对象的toString()方法来确定他们的次序，当我们调用compareFunc('age')方法创建一个比较函数，排序是按照对象的age属性排序的。&lt;/p&gt;
&lt;h2 id=&quot;xml节点的排序&quot;&gt;4、XML节点的排序&lt;/h2&gt;
&lt;p&gt;  尽管现在很多后台返回数据就是JSON格式的，很轻量又方便解析。但是之前有个项目因为后台返回的都是XML字符串，前端拿到数据后还得进行序列化，有些需要排序，之前的排序都是把XML转换成数组对象进行排序的，这样做没有什么问题，只不过感觉代码写的很冗余麻烦。后来就突发奇想，xml获取得到也是类数组对象，把类数组对象转换成数组不就可以直接排序了么。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 1.模拟后端返回的XML字符串
var str=`
&amp;lt;root&amp;gt;
  &amp;lt;user&amp;gt;
    &amp;lt;name&amp;gt;tom&amp;lt;/name&amp;gt;
    &amp;lt;age&amp;gt;18&amp;lt;/age&amp;gt;
  &amp;lt;/user&amp;gt;
  &amp;lt;user&amp;gt;
    &amp;lt;name&amp;gt;lucy&amp;lt;/name&amp;gt;
    &amp;lt;age&amp;gt;24&amp;lt;/age&amp;gt;
  &amp;lt;/user&amp;gt;
  &amp;lt;user&amp;gt;
    &amp;lt;name&amp;gt;jhon&amp;lt;/name&amp;gt;
    &amp;lt;age&amp;gt;17&amp;lt;/age&amp;gt;
  &amp;lt;/user&amp;gt;
&amp;lt;root&amp;gt;
`   
// 2.定义比较函数
function compareFunction(prop){
  return function (a, b) {
      var value1= a.getElementsByTagName(prop)[0].textContent;
      var value2= b.getElementsByTagName(prop)[0].textContent;
      if (value1 &amp;lt; value2){
        return -1;
      } else if (value1 &amp;gt; value2){
        return 1;
      } else{
        return 0;
    }
  }
}
// 3.xml字符串转换成xml对象
var domParser = new DOMParser();
var xmlDoc = domParser.parseFromString(str, 'text/xml');
var userElements=xmlDoc.getElementsByTagName('user'));
// 4.userElements类数组对象转换成数组再排序
var userElements=Array.prototype.slice.call(xmlDoc.getElementsByTagName('user'));
var _userElements=userElements.sort(compareFunction('age'));
// 5.打印排序后的结果
_userElements.forEach((user)=&amp;gt;{
  console.log(user.innerHTML);
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打印排序后的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1103967/201911/1103967-20191125015444972-1944678981.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以发现，XML节点已经按照age从小到大排序了。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;5、总结&lt;/h2&gt;
&lt;p&gt;  JS数组的sort方法因为有了传入比较函数使得排序灵活了许多，还有根据时间，汉字拼音首字母排序等等，我们只要牢记&lt;strong&gt;通过传入比较函数明确比较两个对象属性值，通过比较属性值来决定对象的排序顺序&lt;/strong&gt;即可。自己也是在工作中遇到问题从而发现解决问题的新思路，以上就简单总结这么多了，如有不足，多多指正。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;参考资料：&lt;br/&gt;《JavaScript高级教程》&lt;/p&gt;
</description>
<pubDate>Mon, 25 Nov 2019 00:10:00 +0000</pubDate>
<dc:creator>Peerless1029</dc:creator>
<og:description>&amp;emsp;&amp;emsp;在平时的业务开发中， 数组(Array) 是我们经常用到的数据类型，那么对数组的排序也很常见，除去使用循环遍历数组的方法来排列数据，使用JS数组中原生的方法 sort 来排列（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/peerless1029/p/11925580.html</dc:identifier>
</item>
<item>
<title>java中的transient关键字详解 - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11923126.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11923126.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;br/&gt;说实话学了一段时间java的朋友对于&lt;code&gt;transient&lt;/code&gt;这个关键字依旧很陌生基本没怎么用过，但是&lt;code&gt;transient&lt;/code&gt;关键字在java中却起到了不可或缺的地位！如果要说讲到，我觉得最可能出现的地方是IO流中对象流（也叫序列化流）的时候会讲到！&lt;/p&gt;
&lt;p&gt;相信很多人都是直到自己碰到才会关心这个关键字，记得博主第一次碰到&lt;code&gt;transient&lt;/code&gt;关键字是在阅读JDK源码的时候。在学习java的过程中&lt;code&gt;transient&lt;/code&gt;关键字少见的原因其实离不开它的作用：&lt;code&gt;transient&lt;/code&gt;关键字的主要作用就是让某些&lt;span&gt;&lt;strong&gt;被transient关键字修饰的成员属性变量不被序列化&lt;/strong&gt;&lt;/span&gt;。实际上也正是因此，在学习过程中很少用得上序列化操作，一般都是在实际开发中！至于序列化，相信有很多小白童鞋一直迷迷糊糊或者没有具体的概念，这都不是事，下面博主会很清楚的让你记住啥是序列化，保证你这辈子忘不了（貌似有点夸张，有点装b，感觉要被打）&lt;/p&gt;
&lt;p&gt;@&lt;/p&gt;
&lt;h2 id=&quot;何谓序列化&quot;&gt;1、何谓序列化？&lt;/h2&gt;
&lt;p&gt;说起序列化，随之而来的另一个概念就是反序列化，小白童鞋不要慌，记住了序列化就相当于记住了反序列化，因为反序列化就是序列化反过来，所以博主建议只记住序列化概念即可，省的搞晕自己。&lt;/p&gt;
&lt;p&gt;专业术语定义的序列化：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Java提供了一种对象序列化的机制。用一个字节序列可以表示一个对象，该字节序列包含该对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。反之，该字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。对象的数据、对象的类型和对象中存储的数据信息，都可以用来在内存中创建对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;宜春的术语定义序列化：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;序列化： &lt;strong&gt;字节 ——&amp;gt; 对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实，我总结的就是上面的结论，如果不理解，直接参照专业术语的定义，理解之后就记住我的话就行了，记不住，请打死我（我踢m简直就是个天才）&lt;/p&gt;
&lt;p&gt;图理解序列化：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191123212206463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;啥？你不懂啥是字节？其实，我在一篇IO流的文章里就已经介绍了序列化，放心，绝对特别详细~光看文章名字就知道了~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102831084&quot;&gt;史上最骚最全最详细的IO流教程，小白都能看懂！&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;为何要序列化&quot;&gt;2、为何要序列化？&lt;/h2&gt;
&lt;p&gt;从上一节提到序列化的概念，知道概念之后，我们就必须要知道 为何要序列化了。&lt;/p&gt;
&lt;p&gt;讲为何要序列化原因之前，博主我举个栗子：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;就像你去街上买菜，一般操作都是用塑料袋给包装起来，直到回家要做菜的时候就把菜给拿出来。而这一系列操作就像极了序列化和反序列化！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Java中对象的序列化指的是将对象转换成以字节序列的形式来表示，这些字节序列包含了对象的数据和信息，一个序列化后的对象 &lt;span&gt;&lt;strong&gt;可以被写到数据库或文件中&lt;/strong&gt;&lt;/span&gt;，也可用于 &lt;span&gt;&lt;strong&gt;网络传输&lt;/strong&gt;&lt;/span&gt;，一般当我们使用 &lt;span&gt;&lt;strong&gt;缓存cache&lt;/strong&gt;&lt;/span&gt;（内存空间不够有可能会本地存储到硬盘）或 &lt;span&gt;&lt;strong&gt;远程调用rpc&lt;/strong&gt;&lt;/span&gt;（网络传输）的时候，经常需要让我们的实体类实现&lt;code&gt;Serializable&lt;/code&gt;接口，目的就是为了让其可序列化。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在开发过程中&lt;strong&gt;要使用transient&lt;/strong&gt;关键字修饰的栗子：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;如果一个用户有一些密码等信息，为了安全起见，不希望在网络操作中被传输，这些信息对应的变量就可以加上transient关键字。&lt;/strong&gt;&lt;/span&gt;换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;在开发过程中&lt;strong&gt;不需要transient&lt;/strong&gt;关键字修饰的栗子：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1、类中的字段值可以根据其它字段推导出来。&lt;br/&gt;2、看具体业务需求，哪些字段不想被序列化；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不知道各位有木有想过为什么要不被序列化呢？其实主要是为了节省存储空间。优化程序！&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;PS：记得之前看&lt;code&gt;HashMap&lt;/code&gt;源码的时候，发现有个字段是用&lt;code&gt;transient&lt;/code&gt;修饰的，我觉得还是有道理的，确实没必要对这个modCount字段进行序列化，因为没有意义，modCount主要用于判断HashMap是否被修改（像put、remove操作的时候，&lt;code&gt;modCount&lt;/code&gt;都会自增），对于这种变量，一开始可以为任何值，0当然也是可以（new出来、反序列化出来、或者克隆clone出来的时候都是为0的），没必要持久化其值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，序列化后的最终目的是为了反序列化，恢复成原先的Java对象，要不然序列化后干嘛呢，就像买菜一样，用塑料袋包裹最后还是为了方便安全到家再去掉塑料袋，所以序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。&lt;/p&gt;
&lt;h2 id=&quot;序列化与transient的使用&quot;&gt;3、序列化与transient的使用&lt;/h2&gt;
&lt;p&gt;　1、&lt;span&gt;&lt;strong&gt;需要做序列化的对象的类，必须实现序列化接口：Java.lang.Serializable 接口&lt;/strong&gt;&lt;/span&gt;（一个标志接口，没有任何抽象方法），Java 中大多数类都实现了该接口，比如：&lt;code&gt;String&lt;/code&gt;，&lt;code&gt;Integer&lt;/code&gt;类等，不实现此接口的类将不会使任何状态序列化或反序列化，会抛&lt;code&gt;NotSerializableException&lt;/code&gt;异常 。&lt;/p&gt;
&lt;p&gt;　　2、底层会判断，如果当前对象是 &lt;code&gt;Serializable&lt;/code&gt; 的实例，才允许做序列化，Java对象 &lt;code&gt;instanceof Serializable&lt;/code&gt; 来判断。&lt;/p&gt;
&lt;p&gt;　　3、&lt;span&gt;&lt;strong&gt;在 Java 中使用对象流&lt;code&gt;ObjectOutputStream&lt;/code&gt;来完成序列化以及&lt;code&gt;ObjectInputStream&lt;/code&gt;流反序列化&lt;/strong&gt;&lt;/span&gt;　　　&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;==ObjectOutputStream:通过 writeObject()方法做序列化操作==　&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;==ObjectInputStream:通过 readObject() 方法做反序列化操作==&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;4、该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用&lt;code&gt;transient&lt;/code&gt; 关键字修饰。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112409532332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;由于字节嘛所以肯定要涉及流的操作，也就是对象流也叫序列化流ObjectOutputstream，下面进行多种情况分析序列化的操作代码！&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在这里，我真的强烈建议看宜春博客的读者朋友，请试着去敲，切记一眼带过或者复制过去运行就完事了，特别是小白童鞋，相信我！你一定会有不一样的收获。千万不要觉得浪费时间，有时候慢就是快，宜春亲身体会！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;没有实现serializable接口进行序列化情况&quot;&gt;3.1、没有实现Serializable接口进行序列化情况&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package TransientTest;
import java.io.*;

class UserInfo {  //================================注意这里没有实现Serializable接口
    private String name;
    private transient String password;

    public UserInfo(String name,String psw) {
        this.name = name;
        this.password=psw;
    }

    @Override
    public String toString() {
        return &quot;UserInfo{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, password='&quot; + password + '\'' +
                '}';
    }
}

public class TransientDemo {
    public static void main(String[] args) {

        UserInfo userInfo=new UserInfo(&quot;老王&quot;,&quot;123&quot;);
        System.out.println(&quot;序列化之前信息：&quot;+userInfo);

        try {
            ObjectOutputStream output=new ObjectOutputStream(new FileOutputStream(&quot;userinfo.txt&quot;));
            output.writeObject(new UserInfo(&quot;老王&quot;,&quot;123&quot;));
            output.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124104254420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;实现serializable接口序列化情况&quot;&gt;3.2、实现Serializable接口序列化情况&lt;/h4&gt;
&lt;p&gt;当我们加上实现Serializable接口再运行会发现，项目中出现的&lt;code&gt;userinfo.txt&lt;/code&gt;文件内容是这样的:&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124104817776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;其实这都不是重点，重点是序列化操作成功了！&lt;/p&gt;
&lt;h4 id=&quot;普通序列化情况&quot;&gt;3.3、普通序列化情况&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package TransientTest;
import java.io.*;

class UserInfo implements Serializable{  //第一步实现Serializable接口
    private String name;
    private String password;//都是普通属性==============================

    public UserInfo(String name,String psw) {
        this.name = name;
        this.password=psw;
    }

    @Override
    public String toString() {
        return &quot;UserInfo{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, password='&quot; + password + '\'' +
                '}';
    }
}

public class TransientDemo {
    public static void main(String[] args) throws ClassNotFoundException {

        UserInfo userInfo=new UserInfo(&quot;程序员老王&quot;,&quot;123&quot;);
        System.out.println(&quot;序列化之前信息：&quot;+userInfo);

        try {
            ObjectOutputStream output=new ObjectOutputStream(new FileOutputStream(&quot;userinfo.txt&quot;)); //第二步开始序列化操作
            output.writeObject(new UserInfo(&quot;程序员老王&quot;,&quot;123&quot;));
            output.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            ObjectInputStream input=new ObjectInputStream(new FileInputStream(&quot;userinfo.txt&quot;));//第三步开始反序列化操作
            Object o = input.readObject();//ObjectInputStream的readObject方法会抛出ClassNotFoundException
            System.out.println(&quot;序列化之后信息：&quot;+o);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;序列化之前信息：UserInfo{name='程序员老王', password='123'}
序列化之后信息：UserInfo{name='程序员老王', password='123'}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;transient序列化情况&quot;&gt;3.4、transient序列化情况&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package TransientTest;
import java.io.*;

class UserInfo implements Serializable{  //第一步实现Serializable接口
    private String name;
    private transient String password; //特别注意：属性由transient关键字修饰===========

    public UserInfo(String name,String psw) {
        this.name = name;
        this.password=psw;
    }

    @Override
    public String toString() {
        return &quot;UserInfo{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, password='&quot; + password + '\'' +
                '}';
    }
}

public class TransientDemo {
    public static void main(String[] args) throws ClassNotFoundException {

        UserInfo userInfo=new UserInfo(&quot;程序员老王&quot;,&quot;123&quot;);
        System.out.println(&quot;序列化之前信息：&quot;+userInfo);

        try {
            ObjectOutputStream output=new ObjectOutputStream(new FileOutputStream(&quot;userinfo.txt&quot;)); //第二步开始序列化操作
            output.writeObject(new UserInfo(&quot;程序员老王&quot;,&quot;123&quot;));
            output.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            ObjectInputStream input=new ObjectInputStream(new FileInputStream(&quot;userinfo.txt&quot;));//第三步开始反序列化操作
            Object o = input.readObject();//ObjectInputStream的readObject方法会抛出ClassNotFoundException
            System.out.println(&quot;序列化之后信息：&quot;+o);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;序列化之前信息：UserInfo{name='程序员老王', password='123'}
序列化之后信息：UserInfo{name='程序员老王', password='null'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特别注意结果，添加transient修饰的属性值为默认值&lt;code&gt;null&lt;/code&gt;！如果被transient修饰的属性为int类型，那它被序列化之后值一定是0，当然各位可以去试试，这能说明什么呢？说明被标记为&lt;code&gt;transient&lt;/code&gt;的属性在对象被序列化的时候不会被保存(或者说变量不会持久化)&lt;/p&gt;
&lt;h4 id=&quot;static序列化情况&quot;&gt;3.5、static序列化情况&lt;/h4&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package TransientTest;
import java.io.*;

class UserInfo implements Serializable{  //第一步实现Serializable接口
    private String name;
    private static String password; //特别注意：属性由static关键字修饰==============

    public UserInfo(String name, String psw) {
        this.name = name;
        this.password=psw;
    }

    @Override
    public String toString() {
        return &quot;UserInfo{&quot; +
                &quot;name='&quot; + name + '\'' +
                &quot;, password='&quot; + password + '\'' +
                '}';
    }
}

public class TransientDemo {
    public static void main(String[] args) throws ClassNotFoundException {

        UserInfo userInfo=new UserInfo(&quot;程序员老王&quot;,&quot;123&quot;);
        System.out.println(&quot;序列化之前信息：&quot;+userInfo);

        try {
            ObjectOutputStream output=new ObjectOutputStream(new FileOutputStream(&quot;userinfo.txt&quot;)); //第二步开始序列化操作
            output.writeObject(new UserInfo(&quot;程序员老王&quot;,&quot;123&quot;));
            output.close();
        } catch (IOException e) {
            e.printStackTrace();
        }

        try {
            ObjectInputStream input=new ObjectInputStream(new FileInputStream(&quot;userinfo.txt&quot;));//第三步开始反序列化操作
            Object o = input.readObject();//ObjectInputStream的readObject方法会抛出ClassNotFoundException
            System.out.println(&quot;序列化之后信息：&quot;+o);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;序列化之前信息：UserInfo{name='程序员老王', password='123'}
序列化之后信息：UserInfo{name='程序员老王', password='123'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个时候，你就会错误的认为static修饰的也被序列化了，其实不然，实际上这里很容易被搞晕！明明取出&lt;code&gt;null&lt;/code&gt;（默认值）就可以说明不会被序列化，这里明明没有变成默认值，为何还要说&lt;code&gt;static&lt;/code&gt;不会被序列化呢？&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;实际上，反序列化后类中static型变量name的值实际上是当前JVM中对应static变量的值，这个值是JVM中的并不是反序列化得出的。&lt;/strong&gt;&lt;/span&gt;也就是说被static修饰的变量并没有参与序列化！但是咱也不能口说无凭啊，是的，那我们就来看两个程序对比一下就明白了！&lt;/p&gt;
&lt;p&gt;第一个程序：这是一个没有被static修饰的name属性程序：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Thread;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

class UserInfo implements Serializable {
    private String name;
    private transient String psw;

    public UserInfo(String name, String psw) {
        this.name = name;
        this.psw = psw;
    }

    public  String getName() {
        return name;
    }

    public  void setName(String name) {
        this.name = name;
    }

    public String getPsw() {
        return psw;
    }

    public void setPsw(String psw) {
        this.psw = psw;
    }

    public String toString() {
        return &quot;name=&quot; + name + &quot;, psw=&quot; + psw;
    }
}
public class TestTransient {
    public static void main(String[] args) {
        UserInfo userInfo = new UserInfo(&quot;程序员老过&quot;, &quot;456&quot;);
        System.out.println(userInfo);
        try {
            // 序列化，被设置为transient的属性没有被序列化
            ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(&quot;UserInfo.txt&quot;));
            o.writeObject(userInfo);
            o.close();
        } catch (Exception e) {
            // TODO: handle exception
            e.printStackTrace();
        }
        try {
            //在反序列化之前改变name的值 =================================注意这里的代码
            userInfo.setName(&quot;程序员老改&quot;);
            // 重新读取内容
            ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;UserInfo.txt&quot;));
            UserInfo readUserInfo = (UserInfo) in.readObject();
            //读取后psw的内容为null
            System.out.println(readUserInfo.toString());
        } catch (Exception e) {
            // TODO: handle exception
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;name=程序员老过, psw=456
name=程序员老过, psw=null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从程序运行结果中可以看出，在反序列化之前试着改变name的值为程序员老改，结果是没有成功的！&lt;/p&gt;
&lt;p&gt;第二个程序：这是一个被static修饰的name属性程序：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Thread;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;

class UserInfo implements Serializable {
    private static final long serialVersionUID = 996890129747019948L;
    private static String name;
    private transient String psw;

    public UserInfo(String name, String psw) {
        this.name = name;
        this.psw = psw;
    }

    public  String getName() {
        return name;
    }

    public  void setName(String name) {
        this.name = name;
    }

    public String getPsw() {
        return psw;
    }

    public void setPsw(String psw) {
        this.psw = psw;
    }

    public String toString() {
        return &quot;name=&quot; + name + &quot;, psw=&quot; + psw;
    }
}
public class TestTransient {
    public static void main(String[] args) {
        UserInfo userInfo = new UserInfo(&quot;程序员老过&quot;, &quot;456&quot;);
        System.out.println(userInfo);
        try {
            // 序列化，被设置为transient的属性没有被序列化
            ObjectOutputStream o = new ObjectOutputStream(new FileOutputStream(&quot;UserInfo.txt&quot;));
            o.writeObject(userInfo);
            o.close();
        } catch (Exception e) {
            // TODO: handle exception
            e.printStackTrace();
        }
        try {
            //在反序列化之前改变name的值
            userInfo.setName(&quot;程序员老改&quot;);
            // 重新读取内容
            ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;UserInfo.txt&quot;));
            UserInfo readUserInfo = (UserInfo) in.readObject();
            //读取后psw的内容为null
            System.out.println(readUserInfo.toString());
        } catch (Exception e) {
            // TODO: handle exception
            e.printStackTrace();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;name=程序员老过, psw=456
name=程序员老改, psw=null&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从程序运行结果中可以看出，在反序列化之前试着改变name的值为程序员老改，结果是成功的！现在对比一下两个程序是不是就很清晰了？&lt;/p&gt;
&lt;p&gt;static关键字修饰的成员属性优于非静态成员属性加载到内存中，同时静态也优于对象进入到内存中，被static修饰的成员变量不能被序列化，序列化的都是对象，静态变量不是对象状态的一部分，因此它不参与序列化。所以将静态变量声明为transient变量是没有用处的。因此，反序列化后类中static型变量name的值实际上是当前JVM中对应static变量的值，这个值是JVM中的并不是反序列化得出的。&lt;/p&gt;
&lt;p&gt;如果对static关键字还是不太清楚理解的童鞋可以参考这篇文章，应该算是不错的：&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102736466&quot;&gt;深入理解static关键字&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;final序列化情况&quot;&gt;3.6、final序列化情况&lt;/h4&gt;
&lt;p&gt;对于final关键字来讲，final变量将直接通过值参与序列化，至于代码程序我就不再贴出来了，大家可以试着用final修饰验证一下！&lt;/p&gt;
&lt;p&gt;主要注意的是final 和transient可以同时修饰同一个变量，结果也是一样的，对transient没有影响，这里主要提一下，希望各位以后在开发中遇到这些情况不会满头雾水！&lt;/p&gt;
&lt;h2 id=&quot;java类中serialversionuid作用&quot;&gt;4、java类中serialVersionUID作用&lt;/h2&gt;
&lt;p&gt;既然提到了transient关键字就不得不提到序列化，既然提到了序列化，就不得不提到&lt;code&gt;serialVersionUID&lt;/code&gt;了，它是啥呢？基本上有序列化就会存在这个serialVersionUID。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124165557139.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;code&gt;serialVersionUID&lt;/code&gt;适用于Java的序列化机制。简单来说，Java的序列化机制是通过判断类的&lt;code&gt;serialVersionUID&lt;/code&gt;来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的&lt;code&gt;serialVersionUID&lt;/code&gt;与本地相应实体类的&lt;code&gt;serialVersionUID&lt;/code&gt;进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常，即是&lt;code&gt;InvalidCastException&lt;/code&gt;，在开发中有时候可写可不写，建议最好还是写上比较好。&lt;/p&gt;
&lt;h2 id=&quot;transient关键字小结&quot;&gt;5、transient关键字小结&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1、变量被transient修饰，变量将不会被序列化&lt;br/&gt;2、transient关键字只能修饰变量，而不能修饰方法和类。&lt;br/&gt;3、被static关键字修饰的变量不参与序列化，一个静态static变量不管是否被transient修饰，均不能被序列化。&lt;br/&gt;4、final变量值参与序列化，final transient同时修饰变量，final不会影响transient，一样不会参与序列化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第二点需要注意的是：本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口&lt;/p&gt;
&lt;p&gt;第三点需要注意的是：反序列化后类中static型变量的值实际上是当前JVM中对应static变量的值，这个值是JVM中的并不是反序列化得出的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结语：&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;被transient关键字修饰导致不被序列化，其优点是可以节省存储空间。优化程序！随之而来的是会导致被transient修饰的字段会重新计算，初始化！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，欢迎各位关注宜春的公众号，一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191028085725979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;　　&lt;/p&gt;
</description>
<pubDate>Mon, 25 Nov 2019 00:03:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>前言 说实话学了一段时间java的朋友对于 这个关键字依旧很陌生基本没怎么用过，但是 关键字在java中却起到了不可或缺的地位！如果要说讲到，我觉得最可能出现的地方是IO流中对象流（也叫序列化流）的时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11923126.html</dc:identifier>
</item>
<item>
<title>SpringSecurity退出功能实现的正确方式 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11925681.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11925681.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201911/1815316-20191125074928596-1941813760.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本文将介绍在Spring Security框架下如何实现用户的&quot;退出&quot;logout的功能。其实这是一个非常简单的功能，我见过很多的程序员在使用了Spring Security之后，仍然去自己写controller方法实现logout功能，这种做法就好像耕地，你有机械设备你不用，你非要用牛。&lt;/p&gt;
&lt;h2 id=&quot;一logout最简及最佳实践&quot;&gt;一、logout最简及最佳实践&lt;/h2&gt;
&lt;p&gt;其实使用Spring Security进行logout非常简单，只需要在spring Security配置类配置项上加上这样一行代码:http.logout()。关于spring Security配置类的其他很多实现、如：HttpBasic模式、formLogin模式、自定义登录验证结果、使用权限表达式、session会话管理，在本号的之前的文章已经都写过了。本节的核心内容就是在原有配置的基础上，加上这样一行代码:http.logout()。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableWebSecurity
public class SecSecurityConfig extends WebSecurityConfigurerAdapter {
 
    @Override
    protected void configure(final HttpSecurity http) throws Exception {
        http.logout();
   }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;加上logout配置之后，在你的“退出”按钮上使用/logtou作为请求登出的路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;a href=&quot;/logout&quot; &amp;gt;退出&amp;lt;/a&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;logout功能我们就完成了。实际上的核心代码只有两行。&lt;/p&gt;
&lt;h2 id=&quot;二默认的logout做了什么&quot;&gt;二、默认的logout做了什么？&lt;/h2&gt;
&lt;p&gt;虽然我们简简单单的实现了logout功能，是不是还不足够放心？我们下面就来看一下Spring Security默认在logout过程中帮我们做了哪些动作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当前session失效，即：logout的核心需求，session失效就是访问权限的回收。&lt;/li&gt;
&lt;li&gt;删除当前用户的 remember-me“记住我”功能信息&lt;/li&gt;
&lt;li&gt;clear清除当前的 SecurityContext&lt;/li&gt;
&lt;li&gt;重定向到登录页面，loginPage配置项指定的页面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常对于一个应用来讲，以上动作就是logout功能所需要具备的功能了。&lt;/p&gt;
&lt;h2 id=&quot;三个性化配置&quot;&gt;三、个性化配置&lt;/h2&gt;
&lt;p&gt;虽然Spring Security默认使用了/logout作为退出处理请求路径，登录页面作为退出之后的跳转页面。这符合绝大多数的应用的开发逻辑，但有的时候我们需要一些个性化设置，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; http.logout()
     .logoutUrl(&quot;/signout&quot;)
     .logoutSuccessUrl(&quot;/aftersignout.html&quot;)
     .deleteCookies(&quot;JSESSIONID&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;通过指定logoutUrl配置改变退出请求的默认路径，当然html退出按钮的请求url也要修改&lt;/li&gt;
&lt;li&gt;通过指定logoutSuccessUrl配置，来显式指定退出之后的跳转页面&lt;/li&gt;
&lt;li&gt;还可以使用deleteCookies删除指定的cookie，参数为cookie的名称&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四logoutsuccesshandler&quot;&gt;四、LogoutSuccessHandler&lt;/h2&gt;
&lt;p&gt;如果上面的个性化配置，仍然满足不了您的应用需求。可能您的应用需要在logout的时候，做一些特殊动作，比如登录时长计算，清理业务相关的数据等等。你可以通过实现LogoutSuccessHandler 接口来实现你的业务逻辑。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Component
public class MyLogoutSuccessHandler implements LogoutSuccessHandler {
    
    @Override
    public void onLogoutSuccess(HttpServletRequest request, 
                                HttpServletResponse response, 
                                Authentication authentication) 
                                throws IOException, ServletException {
        //这里书写你自己的退出业务逻辑
        
        // 重定向到登录页
        response.sendRedirect(&quot;/login.html&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后进行配置使其生效，核心代码就是一行logoutSuccessHandler。注意logoutSuccessUrl不要与logoutSuccessHandler一起使用，否则logoutSuccessHandler将失效。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Configuration
@EnableWebSecurity
public class SecSecurityConfig extends WebSecurityConfigurerAdapter {
    
@Autowired
    private MyLogoutSuccessHandler myLogoutSuccessHandler;

    @Override
    protected void configure(final HttpSecurity http) throws Exception {
         http.logout()
             .logoutUrl(&quot;/signout&quot;)
             //.logoutSuccessUrl(``&quot;/aftersignout.html&quot;``)
             .deleteCookies(&quot;JSESSIONID&quot;)
              //自定义logoutSuccessHandler
             .logoutSuccessHandler(myLogoutSuccessHandler);   
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Sun, 24 Nov 2019 23:49:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>本文将介绍在Spring Security框架下如何实现用户的'退出'logout的功能。其实这是一个非常简单的功能，我见过很多的程序员在使用了Spring Security之后，仍然去自己写cont</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11925681.html</dc:identifier>
</item>
<item>
<title>three.js使用gpu选取物体并计算交点位置 - tengge</title>
<link>http://www.cnblogs.com/tengge/p/11924663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tengge/p/11924663.html</guid>
<description>&lt;p&gt;使用three.js自带的光线投射器(Raycaster)选取物体非常简单，代码如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; raycaster = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Raycaster();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; mouse = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Vector2();

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; onMouseMove(event) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算鼠标所在位置的设备坐标&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 三个坐标分量都是-1到1&lt;/span&gt;
    mouse.x = event.clientX / window.innerWidth * 2 - 1&lt;span&gt;;
    mouse.y &lt;/span&gt;= - (event.clientY / window.innerHeight) * 2 + 1&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; pick() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用相机和鼠标位置更新选取光线&lt;/span&gt;
&lt;span&gt;    raycaster.setFromCamera(mouse, camera);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 计算与选取光线相交的物体&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; intersects =&lt;span&gt; raycaster.intersectObjects(scene.children);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;它是采用包围盒过滤，计算投射光线与每个三角面元是否相交实现的。&lt;/p&gt;
&lt;p&gt;但是，&lt;strong&gt;当模型非常大，比如说有40万个面，通过遍历的方法选取物体和计算碰撞点位置将非常慢&lt;/strong&gt;，用户体验不好。&lt;/p&gt;
&lt;p&gt;但是使用gpu选取物体不存在这个问题。无论场景和模型有多大，都可以在一帧内获取到鼠标所在点的物体和交点的位置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现方法很简单：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.  创建选取材质，将场景中的每个模型的材质替换成不同的颜色。&lt;/p&gt;
&lt;p&gt;2. 读取鼠标位置像素颜色，根据颜色判断鼠标位置的物体。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体实现代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 创建选取材质，遍历场景，将场景中每个模型替换为不同的颜色。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
let maxHexColor = 1&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更换选取材质&lt;/span&gt;
scene.traverseVisible(n =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(n &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; THREE.Mesh)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    n.oldMaterial &lt;/span&gt;=&lt;span&gt; n.material;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n.pickMaterial) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 已经创建过选取材质了&lt;/span&gt;
        n.material =&lt;span&gt; n.pickMaterial;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    let material &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.ShaderMaterial({
        vertexShader: PickVertexShader,
        fragmentShader: PickFragmentShader,
        uniforms: {
            pickColor: {
                value: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.Color(maxHexColor)
            }
        }
    });
    n.pickColor &lt;/span&gt;=&lt;span&gt; maxHexColor;
    maxHexColor&lt;/span&gt;++&lt;span&gt;;
    n.material &lt;/span&gt;= n.pickMaterial =&lt;span&gt; material;
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.  将场景绘制在WebGLRenderTarget上，读取鼠标所在位置的颜色，判断选取的物体。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
let renderTarget = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.WebGLRenderTarget(width, height);
let pixel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uint8Array(4&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 绘制并读取像素&lt;/span&gt;
&lt;span&gt;renderer.setRenderTarget(renderTarget);
renderer.clear();
renderer.render(scene, camera);
renderer.readRenderTargetPixels(renderTarget, offsetX, height &lt;/span&gt;- offsetY, 1, 1, pixel); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 读取鼠标所在位置颜色&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 还原原来材质，并获取选中物体&lt;/span&gt;
const currentColor = pixel[0] * 0xffff + pixel[1] * 0xff + pixel[2&lt;span&gt;];

let selected &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

scene.traverseVisible(n &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!(n &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; THREE.Mesh)) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (n.pickMaterial &amp;amp;&amp;amp; n.pickColor === currentColor) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 颜色相同&lt;/span&gt;
        selected = n; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 鼠标所在位置的物体&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (n.oldMaterial) {
        n.material &lt;/span&gt;=&lt;span&gt; n.oldMaterial;
        &lt;/span&gt;&lt;span&gt;delete&lt;/span&gt;&lt;span&gt; n.oldMaterial;
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：offsetX和offsetY是鼠标位置，height是画布高度。readRenderTargetPixels一行的含义是选取鼠标所在位置（offsetX, height - offsetY），宽度为1，高度为1的像素的颜色。&lt;/p&gt;
&lt;p&gt;pixel是Uint8Array(4)，分别保存rgba颜色的四个通道，每个通道取值范围是0~255。&lt;/p&gt;
&lt;p&gt;完整实现代码：&lt;a href=&quot;https://gitee.com/tengge1/ShadowEditor/blob/master/ShadowEditor.Web/src/event/GPUPickEvent.js&quot;&gt;https://gitee.com/tengge1/ShadowEditor/blob/master/ShadowEditor.Web/src/event/GPUPickEvent.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;实现方法也很简单：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 创建深度着色器材质，将场景深度渲染到WebGLRenderTarget上。&lt;/p&gt;
&lt;p&gt;2. 计算鼠标所在位置的深度，根据鼠标位置和深度计算交点位置。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体实现代码：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 创建深度着色器材质，将深度信息以一定的方式编码，渲染到WebGLRenderTarget上。&lt;/p&gt;
&lt;p&gt;深度材质：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
const depthMaterial = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.ShaderMaterial({
    vertexShader: DepthVertexShader,
    fragmentShader: DepthFragmentShader,
    uniforms: {
        far: {
            value: camera.far
        }
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DepthVertexShader：&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
precision highp &lt;span&gt;float&lt;/span&gt;&lt;span&gt;;

uniform &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; far;

varying &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; depth;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    gl_Position &lt;/span&gt;= projectionMatrix * modelViewMatrix * vec4(position, 1.0&lt;span&gt;);
    depth &lt;/span&gt;= gl_Position.z /&lt;span&gt; far;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;DepthFragmentShader：&lt;/p&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
precision highp &lt;span&gt;float&lt;/span&gt;&lt;span&gt;;

varying &lt;/span&gt;&lt;span&gt;float&lt;/span&gt;&lt;span&gt; depth;

&lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; main() {
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; hex = abs(depth) * 16777215.0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 0xffffff&lt;/span&gt;

    &lt;span&gt;float&lt;/span&gt; r = floor(hex / 65535.0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; g = floor((hex - r * 65535.0) / 255.0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; b = floor(hex - r * 65535.0 - g * 255.0&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;float&lt;/span&gt; a = sign(depth) &amp;gt;= 0.0 ? 1.0 : 0.0; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; depth大于等于0，为1.0；小于0，为0.0。&lt;/span&gt;
&lt;span&gt;
    gl_FragColor &lt;/span&gt;= vec4(r / 255.0, g / 255.0, b / 255.0&lt;span&gt;, a);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;重要说明：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a. gl_Position.z是&lt;strong&gt;相机空间中的深度，是线性的，&lt;/strong&gt;范围从cameraNear到cameraFar。可以直接使用着色器varying变量进行插值。&lt;/p&gt;
&lt;p&gt;b. gl_Position.z / far的原因是，将值转换到0~1范围内，便于作为颜色输出。&lt;/p&gt;
&lt;p&gt;c. 不能使用屏幕空间中的深度，透视投影后，深度变为-1~1，大部分非常接近1（0.9多），不是线性的，几乎不变，输出的颜色几乎不变，非常不准确。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;d. 在片元着色器中获取深度方法：相机空间深度为&lt;strong&gt;gl_FragCoord.z&lt;/strong&gt;，屏幕空间深度为&lt;strong&gt;gl_FragCoord.z /  gl_FragCoord.w&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;e. &lt;strong&gt;上述描述都是针对透视投影&lt;/strong&gt;，正投影中gl_Position.w为1，使用相机空间和屏幕空间深度都是一样的。&lt;/p&gt;
&lt;p&gt;f. 为了尽可能准确输出深度，采用rgb三个分量输出深度。gl_Position.z/far范围在0~1，乘以0xffffff，转换为一个rgb颜色值，r分量1表示65535，g分量1表示255，b分量1表示1。&lt;/p&gt;

&lt;p&gt;完整实现代码：&lt;a href=&quot;https://gitee.com/tengge1/ShadowEditor/blob/master/ShadowEditor.Web/src/event/GPUPickEvent.js&quot;&gt;https://gitee.com/tengge1/ShadowEditor/blob/master/ShadowEditor.Web/src/event/GPUPickEvent.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. 读取鼠标所在位置的颜色，将读取到的颜色值还原为相机空间深度值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a. 将“加密”处理后的深度绘制在WebGLRenderTarget上。读取颜色方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
let renderTarget = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; THREE.WebGLRenderTarget(width, height);
let pixel &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uint8Array(4&lt;span&gt;);

scene.overrideMaterial &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.depthMaterial;

renderer.setRenderTarget(renderTarget);

renderer.clear();
renderer.render(scene, camera);
renderer.readRenderTargetPixels(renderTarget, offsetX, height &lt;/span&gt;- offsetY, 1, 1, pixel);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;说明：offsetX和offsetY是鼠标位置，height是画布高度。readRenderTargetPixels一行的含义是选取鼠标所在位置（offsetX, height - offsetY），宽度为1，高度为1的像素的颜色。&lt;/p&gt;
&lt;p&gt;pixel是Uint8Array(4)，分别保存rgba颜色的四个通道，每个通道取值范围是0~255。&lt;/p&gt;

&lt;p&gt;b. 将“加密”后的相机空间深度值“解密”，得到正确的相机空间深度值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;if&lt;/span&gt; (pixel[2] !== 0 || pixel[1] !== 0 || pixel[0] !== 0&lt;span&gt;) {
    let hex &lt;/span&gt;= (&lt;span&gt;this&lt;/span&gt;.pixel[0] * 65535 + &lt;span&gt;this&lt;/span&gt;.pixel[1] * 255 + &lt;span&gt;this&lt;/span&gt;.pixel[2]) / 0xffffff&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.pixel[3] === 0&lt;span&gt;) {
        hex &lt;/span&gt;= -&lt;span&gt;hex;
    }

    cameraDepth &lt;/span&gt;= -hex * camera.far; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 相机坐标系中鼠标所在点的深度（注意：相机坐标系中的深度值为负值）&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;3. 根据鼠标在屏幕上的位置和相机空间深度，插值反算交点世界坐标系中的坐标。&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
let nearPosition = &lt;span&gt;new&lt;/span&gt; THREE.Vector3(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 鼠标屏幕位置在near处的相机坐标系中的坐标&lt;/span&gt;
let farPosition = &lt;span&gt;new&lt;/span&gt; THREE.Vector3(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 鼠标屏幕位置在far处的相机坐标系中的坐标&lt;/span&gt;
let world = &lt;span&gt;new&lt;/span&gt; THREE.Vector3(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 通过插值计算世界坐标&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设备坐标&lt;/span&gt;
const deviceX = &lt;span&gt;this&lt;/span&gt;.offsetX / width * 2 - 1&lt;span&gt;;
const deviceY &lt;/span&gt;= - &lt;span&gt;this&lt;/span&gt;.offsetY / height * 2 + 1&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 近点&lt;/span&gt;
nearPosition.set(deviceX, deviceY, 1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 屏幕坐标系：(0, 0, 1)&lt;/span&gt;
nearPosition.applyMatrix4(camera.projectionMatrixInverse); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 相机坐标系：(0, 0, -far)&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 远点&lt;/span&gt;
farPosition.set(deviceX, deviceY, -1); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 屏幕坐标系：(0, 0, -1)&lt;/span&gt;
farPosition.applyMatrix4(camera.projectionMatrixInverse); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 相机坐标系：(0, 0, -near)&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在相机空间，根据深度，按比例计算出相机空间x和y值。&lt;/span&gt;
const t = (cameraDepth - nearPosition.z) / (farPosition.z -&lt;span&gt; nearPosition.z);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将交点从相机空间中的坐标，转换到世界坐标系坐标。&lt;/span&gt;
&lt;span&gt;world.set(
    nearPosition.x &lt;/span&gt;+ (farPosition.x - nearPosition.x) *&lt;span&gt; t,
    nearPosition.y &lt;/span&gt;+ (farPosition.y - nearPosition.y) *&lt;span&gt; t,
    cameraDepth
);
world.applyMatrix4(camera.matrixWorld);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;完整代码：&lt;a href=&quot;https://gitee.com/tengge1/ShadowEditor/blob/master/ShadowEditor.Web/src/event/GPUPickEvent.js&quot;&gt;https://gitee.com/tengge1/ShadowEditor/blob/master/ShadowEditor.Web/src/event/GPUPickEvent.js&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;使用gpu选取物体并计算交点位置，多用于需要性能非常高的情况。例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 鼠标移动到三维模型上的hover效果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 添加模型时，模型随着鼠标移动，实时预览模型放到场景中的效果。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 距离测量、面积测量等工具，线条和多边形随着鼠标在平面上移动，实时预览效果，并计算长度和面积。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 场景和模型非常大，光线投射法选取速度很慢，用户体验非常不好。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里给一个使用gpu选取物体和实现鼠标hover效果的图片。红色边框是选取效果，黄色半透明效果是鼠标hover效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/724270/201911/724270-20191124221857126-947231603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;看不明白？可能你不太熟悉three.js中的各种投影运算。下面给出three.js中的投影运算公式。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;1. modelViewMatrix = camera.matrixWorldInverse * object.matrixWorld&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. viewMatrix = camera.matrixWorldInverse&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. modelMatrix = object.matrixWorld&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. project = applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. unproject = applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. gl_Position = projectionMatrix * modelViewMatrix * position&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;                      = projectionMatrix * camera.matrixWorldInverse * matrixWorld * position&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;                      = projectionMatrix * viewMatrix * modelMatrix * position&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;参考资料：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 完整实现代码：&lt;a href=&quot;https://gitee.com/tengge1/ShadowEditor/blob/master/ShadowEditor.Web/src/event/GPUPickEvent.js&quot;&gt;https://gitee.com/tengge1/ShadowEditor/blob/master/ShadowEditor.Web/src/event/GPUPickEvent.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2. OpenGL中使用着色器绘制深度值：https://stackoverflow.com/questions/6408851/draw-the-depth-value-in-opengl-using-shaders&lt;/p&gt;
&lt;p&gt;3. 在glsl中，获取真实的片元着色器深度值：https://gamedev.stackexchange.com/questions/93055/getting-the-real-fragment-depth-in-glsl&lt;/p&gt;

</description>
<pubDate>Sun, 24 Nov 2019 22:28:00 +0000</pubDate>
<dc:creator>tengge</dc:creator>
<og:description>光线投射法 使用three.js自带的光线投射器(Raycaster)选取物体非常简单，代码如下所示： 它是采用包围盒过滤，计算投射光线与每个三角面元是否相交实现的。 但是，当模型非常大，比如说有40</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tengge/p/11924663.html</dc:identifier>
</item>
<item>
<title>程序员一般通过什么途径接私活？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/11925649.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/11925649.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;二哥，你好，我想知道一般程序猿都如何接私活，我也想接，能告诉我一些方法吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面是一个读者“烦不烦”问我的一个问题。其实不止是“烦不烦”，还有很多读者问过我类似这样的问题。&lt;/p&gt;
&lt;p&gt;我接的私活不算多，挣到的钱也没有多少，加起来不到 20W。说实话，这个数目说出来我是有点心虚的，毕竟太少了，大家轻喷。但我想，恰好配得上“一般程序员”这个称号啊。毕竟苍蝇再小也是肉，我也算是有经验的人了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;唾弃接私活、做外包的程序员有很多很多，曾经高傲的我也嫌弃过&lt;/strong&gt;。但没办法，为了挣点零花钱，我垂下了高昂的头。记得有位朋友曾说过，当年沈从文为了生计，写了很多称不上他自己喜欢的文字给报刊。&lt;/p&gt;
&lt;p&gt;听朋友这么一说，我也不再觉得“接私活”是多么一件值得羞愧的事情了。人首先要活着，才有体力讲情怀啊。好了，言归正传，我来替“烦不烦”同学介绍几个容易上手的操作。&lt;/p&gt;
&lt;h3 id=&quot;朋友介绍&quot;&gt;01、朋友介绍&lt;/h3&gt;
&lt;p&gt;大体上，天底下做生意都只有一条捷径：从熟人下手。&lt;/p&gt;
&lt;p&gt;“哥们，听说你有个朋友是做程序员的，我这有台电脑不知道为啥黑屏了，能问问他知道什么原因吗？要是能修好，保准请你吃顿大餐。”&lt;/p&gt;
&lt;p&gt;“老弟啊，我有一个朋友说最近流行炒鞋，我想你不是程序员嘛，找你最合适了，要不我把他推荐给你，谈成的话给我发个红包就行了。”&lt;/p&gt;
&lt;p&gt;我的第一个私活，就是之前在苏州的一个同事介绍的。不过最后黄了。我搞了两周时间（技术框架用的 JEPF），同事说甲方换方案了，没把我气坏。&lt;/p&gt;
&lt;p&gt;同事碍于情面，说有机会请我吃顿饭。这一等就是 3 年，3 年过去了，饭还是没有吃到。主要是因为我这位朋友在苏州，我在洛阳，吃饭是没办法远程完成啊。&lt;/p&gt;
&lt;p&gt;第二个私活，是之前在苏州的一个领导介绍的。由同事升级为领导，多少靠谱了点。这次做的是苏州相城区的一个电子商务网站。前后做了三个多月，最后拿到手的钱也就不到一万块钱。&lt;/p&gt;
&lt;p&gt;现在感觉自己当时是在出售廉价劳动力，何止是廉价，简直是公益事业。不过，第一次接私活，拿到钱买了个华为的 MateBook，真香。&lt;/p&gt;
&lt;p&gt;第二个私活做完后，领导可能觉得亏待了我，良心难安，就介绍了第三个私活给我。这次蛮轻松的，一个月搞定，还不累，两万块到手。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;既然是私活，当然都是利用业余时间做的。这个投入的成本和实际得到的回报是一定要考虑的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我第一个私活打了水漂，辛苦了两周，零回报。不过，这也是接私活常有的事，需要用平常心来对待。&lt;/p&gt;
&lt;p&gt;第二个私活说实话非常辛苦，有几次熬到半夜两三点，当时觉得太不划算了。但当初自己接了，就只能忍着拼到底。毕竟咱是敬业爱岗的好同志。&lt;/p&gt;
&lt;p&gt;第三个私活就相对轻松多了，单位时间内的收益非常高，算下来一个小时有 500 的工时费吧，就仿佛是对前两个的补偿。&lt;/p&gt;
&lt;p&gt;总结一下，朋友介绍的项目相对来说还是比较靠谱的，前提条件是要有一定的“人情世故”原始成本积累。如果我当时在苏州表现得不够优异，和同事、领导的关系相处的不够融洽，那自然他们也不会时隔多年后再找到我。&lt;/p&gt;
&lt;p&gt;记住一点，做事的同时要好好的做人。&lt;strong&gt;当你既有能力，又值得信任的时候，私活就会找上门来&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;个人品牌&quot;&gt;02、个人品牌&lt;/h3&gt;
&lt;p&gt;既然是朋友，自然就不会有很多。也就意味着，单纯依赖朋友介绍的私活来源是有限度的。那如果想接更多的私活，该怎么办呢？&lt;/p&gt;
&lt;p&gt;这就需要个人品牌了。&lt;/p&gt;
&lt;p&gt;我平常不是喜欢写作嘛，分享了很多技术文章在各大平台上，浏览量还算不错。博客园上的排名和浏览量都能拿得出手。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117051/201911/1117051-20191125045246496-145518326.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://www.cnblogs.com/qing-gee/&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/qing-gee/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当你做了一件事，并且一直在坚持，况且还做出了一定的成绩，自然就会有生意主动找上门来——花香蜂自来嘛&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;写博客的好处有很多，比如说吸引一批忠实的读者，他们追随你的文字，喜欢你的风格；再比如说勾引一些出版社，他们欣赏你的文字，愿意合作互利共赢。&lt;/p&gt;
&lt;p&gt;最后，还会有一些做私活的甲方。以前，我总觉得这是不可能发生的事情，他们是怎么找到我的？很不可思议，但互联网就是这么神奇，你觉得不可能，它却悄悄地发生着。&lt;/p&gt;
&lt;p&gt;第一个通过这个途径找到我的甲方，姓康。康哥找到我后，一上来就对我一顿吹捧（甭管是真是假）。信任建立起来后，他就说自己在酝酿一个很牛逼的项目，看我有没有意向一起做。&lt;/p&gt;
&lt;p&gt;然后呢，承诺项目成功后，再给我一定数额的奖励金，并且写到了合同里。吃完他这个大饼，我很饱，忍不住打了好几个嗝。&lt;/p&gt;
&lt;p&gt;再然后，我们就开始整理需求，然后我出报价，他再砍价；他再提需求，我再加价。最后呢，项目总款谈到 7.5 万，两个多月的工期。合同的细节也敲定的差不多了。&lt;/p&gt;
&lt;p&gt;结果，黄了。和我合伙的一个开发人员小何觉得甲方新提的需求需要再追加 600 块，甲方觉得这点钱搁不住再追加了。总之呢，7.5W 的项目就因为这个细节黄了，很遗憾。&lt;/p&gt;
&lt;p&gt;第二个通过这个途径找到我的甲方，叫鹏哥。开发一个网站，总价一万多，吃了上次的亏后，我自己就不想参与了，就找了一个读者（小李）做。&lt;/p&gt;
&lt;p&gt;结果这个项目烂尾了。小李交付的产物我自己都觉得不好意思，bug 非常多。在我看来，既然项目的订金已经收了，作为开发人员，至少应该交付一个说得过去的产物——负责任吧。&lt;/p&gt;
&lt;p&gt;很遗憾，个人品牌招揽来的前两个私活最后都搞砸了。这里有必要总结一下：&lt;strong&gt;作为程序员，既然打定主意要接私活，那么接到的时候一定要珍惜。如果一开始觉得价钱低，就趁早拒绝，免得因为需求变动等等原因砸了招牌&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然了，通过这个途径也做成了四单，每单的价格差不多两万。这里就不再详谈了。&lt;/p&gt;
&lt;p&gt;个人品牌的确可以引流来更多的私活，但与此同时，也会浪费很多时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.itwanger.com/assets/images/2019/11/life-jiesihuo-2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;像这种泛泛之谈的意向客户有很多。话说，我啥时候变成“社会王”了，我特么是正儿八经的“王老师”好不好？&lt;/p&gt;
&lt;h3 id=&quot;外包平台&quot;&gt;03、外包平台&lt;/h3&gt;
&lt;p&gt;外包平台有很多，我就不再一一列举了。只说几个我认为还不错的平台，也不打算细说，免得有些读者“夸我”良苦用心地在打广告。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.itwanger.com/life/2019/10/27/programmer-sihuo-pingtai.html&quot;&gt;程序员一般可以从什么平台接私活&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;一点忠告&quot;&gt;04、一点忠告&lt;/h3&gt;
&lt;p&gt;在我写这篇文章的时候，突然收到朋友的一条信息，说她们公司刚刚辞退了一位员工，还通报批评了，就因为接私活被举报了——她们公司一般不辞退员工，这下子相当于铁饭碗丢了。&lt;/p&gt;
&lt;p&gt;所以说呢，接私活是有风险的。并且在我看来，如果主业没有遇到瓶颈，强烈不建议接私活。就好比一个小孩子走路还不会，就要求他要跑起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间对于一个程序员来说很宝贵，尤其是一个正在成长中的程序员。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你确实急用钱，价格又合适，那就去做。如果不怎么缺钱，我再强调一次，别去接私活。私活的钱不好挣是一个方面，更重要的是如果你把做私活的时间花在提升自己上，产生的价值就要大得多。等你提升了自己，提升了固定薪水，远比拿的这点私活的钱划算。千万不要“捡了芝麻丢了西瓜”。&lt;/p&gt;
&lt;p&gt;如果你像我，主业上遇到了瓶颈，平时的时间比较充分，想有一些额外的收入，同时为了保持技术的熟练度，这种情况下，是可以考虑接一些私活的。对于那种投入时间巨大，回报很可怜的项目，千万不要接！&lt;/p&gt;
&lt;p&gt;另外呢，如果甲方只提供几个简单的想法，甚至几张图片，更或者发一个参照的效果网站，就可以直接忽视了，这类通通不靠谱！&lt;/p&gt;
&lt;p&gt;最后呢，还要说一句，如果订金都收了，自己就算是觉得吃了亏，也应该有点职业素质，把像样的产品交付，千万别应付。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;谢谢大家的阅读，原创不易，喜欢就随手点个赞，这将是我最强的写作动力。&lt;/p&gt;
</description>
<pubDate>Sun, 24 Nov 2019 20:54:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>二哥，你好，我想知道一般程序猿都如何接私活，我也想接，能告诉我一些方法吗？ 上面是一个读者“烦不烦”问我的一个问题。其实不止是“烦不烦”，还有很多读者问过我类似这样的问题。 我接的私活不算多，挣到的钱</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/11925649.html</dc:identifier>
</item>
<item>
<title>SpringBoot系列之i18n集成教程 - smileNicky</title>
<link>http://www.cnblogs.com/mzq123/p/11925325.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/11925325.html</guid>
<description>&lt;p&gt;SpringBoot系统之i18n国际化语言集成教程&lt;br/&gt;@&lt;/p&gt;
&lt;h3 id=&quot;环境搭建&quot;&gt;1、环境搭建&lt;/h3&gt;
&lt;p&gt;本博客介绍一下SpringBoot集成i18n，实现系统语言国际化处理，ok，先创建一个SpringBoot项目，具体的参考我的博客专栏：&lt;a href=&quot;https://blog.csdn.net/u014427391/category_9195353.html&quot;&gt;SpringBoot系列博客专栏链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;环境准备：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IntelliJ IDEA&lt;/li&gt;
&lt;li&gt;Maven&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;项目集成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Thymeleaf(模板引擎，也可以选jsp或者freemark)&lt;/li&gt;
&lt;li&gt;SpringBoot2.2.1.RELEASE&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;resource-bundle资源配置&quot;&gt;2、resource bundle资源配置&lt;/h3&gt;
&lt;p&gt;ok，要实现国际化语言，先要创建resource bundle文件：&lt;br/&gt;在resources文件夹下面创建一个i18n的文件夹，其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;messages.properties是默认的配置&lt;/li&gt;
&lt;li&gt;messages_zh_CN.properties是（中文/中国）&lt;/li&gt;
&lt;li&gt;messages_en_US.properties是（英文/美国）&lt;/li&gt;
&lt;li&gt;etc.&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124174259318.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;IDEA工具就提供了很简便的自动配置功能，如图，只要点击新增按钮，手动输入，各配置文件都会自动生成属性&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112417471286.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;messages.properties：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;messages.loginBtnName=登录~
messages.password=密码~
messages.rememberMe=记住我~
messages.tip=请登录~
messages.username=用户名~&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;messages_zh_CN.properties：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;messages.loginBtnName=登录
messages.password=密码
messages.rememberMe=记住我
messages.tip=请登录
messages.username=用户名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;messages_en_US.properties：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;messages.loginBtnName=login
messages.password=password
messages.rememberMe=Remember me
messages.tip=Please login in
messages.username=userName
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在项目的application.properties修改默认配置，让SpringBoot的自动配置能读取到resource bundle资源文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;## 配置i18n
# 默认是i18n（中文/中国）
spring.mvc.locale=zh_CN
# 配置resource bundle资源文件的前缀名eg:i18n是文件夹名，messages是资源文件名，支持的符号有.号或者/
spring.messages.basename=i18n.messages
# 设置缓存时间，2.2.1是s为单位，之前版本才是毫秒
spring.messages.cache-duration=1
# 设置资源文件编码格式为utf8
spring.messages.encoding=utf-8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意要点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring.messages.basename必须配置，否则SpringBoot的自动配置将失效&lt;br/&gt;MessageSourceAutoConfiguration.ResourceBundleCondition 源码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected static class ResourceBundleCondition extends SpringBootCondition {
        //定义一个map缓存池
        private static ConcurrentReferenceHashMap&amp;lt;String, ConditionOutcome&amp;gt; cache = new ConcurrentReferenceHashMap&amp;lt;&amp;gt;();

        @Override
        public ConditionOutcome getMatchOutcome(ConditionContext context, AnnotatedTypeMetadata metadata) {
            String basename = context.getEnvironment().getProperty(&quot;spring.messages.basename&quot;, &quot;messages&quot;);
            ConditionOutcome outcome = cache.get(basename);//缓存拿得到，直接从缓存池读取
            if (outcome == null) {//缓存拿不到，重新读取
                outcome = getMatchOutcomeForBasename(context, basename);
                cache.put(basename, outcome);
            }
            return outcome;
        }

        private ConditionOutcome getMatchOutcomeForBasename(ConditionContext context, String basename) {
            ConditionMessage.Builder message = ConditionMessage.forCondition(&quot;ResourceBundle&quot;);
            for (String name : StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(basename))) {
                for (Resource resource : getResources(context.getClassLoader(), name)) {
                    if (resource.exists()) {
                    //匹配resource bundle资源
                        return ConditionOutcome.match(message.found(&quot;bundle&quot;).items(resource));
                    }
                }
            }
            return ConditionOutcome.noMatch(message.didNotFind(&quot;bundle with basename &quot; + basename).atAll());
        }
        //解析资源文件
        private Resource[] getResources(ClassLoader classLoader, String name) {
            String target = name.replace('.', '/');//spring.messages.basename参数值的点号换成斜杆
            try {
                return new PathMatchingResourcePatternResolver(classLoader)
                        .getResources(&quot;classpath*:&quot; + target + &quot;.properties&quot;);
            }
            catch (Exception ex) {
                return NO_RESOURCES;
            }
        }

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;cache-duration在2.2.1版本，指定的是s为单位，找到SpringBoot的MessageSourceAutoConfiguration自动配置类&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124191550125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;localeresolver类&quot;&gt;3、LocaleResolver类&lt;/h3&gt;
&lt;p&gt;SpringBoot默认采用AcceptHeaderLocaleResolver类作为默认LocaleResolver，LocaleResolver类的作用就是作为i18n的分析器，获取对应的i18n配置，当然也可以自定义LocaleResolver类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.lang.Nullable;
import org.springframework.util.StringUtils;
import org.springframework.web.servlet.LocaleResolver;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.util.Locale;

/**
 * &amp;lt;pre&amp;gt;
 *  自定义LocaleResolver类
 * &amp;lt;/pre&amp;gt;
 * @author nicky
 * &amp;lt;pre&amp;gt;
 * 修改记录
 *    修改后版本:     修改人：  修改日期: 2019年11月23日  修改内容:
 * &amp;lt;/pre&amp;gt;
 */
public class CustomLocalResolver implements LocaleResolver {

    Logger LOG = LoggerFactory.getLogger(this.getClass());

    @Nullable
    private Locale defaultLocale;

    public void setDefaultLocale(@Nullable Locale defaultLocale) {
        this.defaultLocale = defaultLocale;
    }

    @Nullable
    public Locale getDefaultLocale() {
        return this.defaultLocale;
    }

    @Override
    public Locale resolveLocale(HttpServletRequest request) {
        Locale defaultLocale = this.getDefaultLocale();//获取application.properties默认的配置
        if(defaultLocale != null &amp;amp;&amp;amp; request.getHeader(&quot;Accept-Language&quot;) == null) {
            return defaultLocale;//http请求头没获取到Accept-Language才采用默认配置
        } else {//request.getHeader(&quot;Accept-Language&quot;)获取得到的情况
            Locale requestLocale = request.getLocale();//获取request.getHeader(&quot;Accept-Language&quot;)的值
            String localeFlag = request.getParameter(&quot;locale&quot;);//从URL获取的locale值
            //LOG.info(&quot;localeFlag:{}&quot;,localeFlag);
            //url链接有传locale参数的情况，eg:zh_CN
            if (!StringUtils.isEmpty(localeFlag)) {
                String[] split = localeFlag.split(&quot;_&quot;);
                requestLocale = new Locale(split[0], split[1]);
            }
            //没传的情况，默认返回request.getHeader(&quot;Accept-Language&quot;)的值
            return requestLocale;
        }
    }

    @Override
    public void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;i18n配置类&quot;&gt;4、I18n配置类&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;I18n还是要继承WebMvcConfigurer，注意，2.2.1版本才是实现接口就可以，之前1.+版本是要实现WebMvcConfigurerAdapter适配器类的&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;import com.example.springboot.i18n.component.CustomLocalResolver;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.web.servlet.WebMvcProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.LocaleResolver;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.i18n.LocaleChangeInterceptor;

/**
 * &amp;lt;pre&amp;gt;
 *  I18nConfig配置类
 * &amp;lt;/pre&amp;gt;
 * &amp;lt;p&amp;gt;
 * &amp;lt;pre&amp;gt;
 * @author nicky.ma
 * 修改记录
 *    修改后版本:     修改人：  修改日期: 2019/11/24 11:15  修改内容:
 * &amp;lt;/pre&amp;gt;
 */
 //Configuration必须加上，不然不能加载到Spring容器
@Configuration
//使WebMvcProperties配置类可用，这个可以不加上，本博客例子才用
@EnableConfigurationProperties({ WebMvcProperties.class})
public class I18nConfig implements WebMvcConfigurer{
    
    //装载WebMvcProperties 属性
    @Autowired
    WebMvcProperties webMvcProperties;
    /**
     * 定义SessionLocaleResolver
     * @Author nicky.ma
     * @Date 2019/11/24 13:52
     * @return org.springframework.web.servlet.LocaleResolver
     */
//    @Bean
//    public LocaleResolver localeResolver() {
//        SessionLocaleResolver sessionLocaleResolver = new SessionLocaleResolver();
//        // set default locale
//        sessionLocaleResolver.setDefaultLocale(Locale.US);
//        return sessionLocaleResolver;
//    }

    /**
     * 定义CookieLocaleResolver
     * @Author nicky.ma
     * @Date 2019/11/24 13:51
     * @return org.springframework.web.servlet.LocaleResolver
     */
//    @Bean
//    public LocaleResolver localeResolver() {
//        CookieLocaleResolver cookieLocaleResolver = new CookieLocaleResolver();
//        cookieLocaleResolver.setCookieName(&quot;Language&quot;);
//        cookieLocaleResolver.setCookieMaxAge(1000);
//        return cookieLocaleResolver;
//    }

    /**
     * 自定义LocalResolver
     * @Author nicky.ma
     * @Date 2019/11/24 13:45
     * @return org.springframework.web.servlet.LocaleResolver
     */
    @Bean
    public LocaleResolver localeResolver(){
        CustomLocalResolver localResolver = new CustomLocalResolver();
        localResolver.setDefaultLocale(webMvcProperties.getLocale());
        return localResolver;
    }

    /**
     * 定义localeChangeInterceptor
     * @Author nicky.ma
     * @Date 2019/11/24 13:45
     * @return org.springframework.web.servlet.i18n.LocaleChangeInterceptor
     */
    @Bean
    public LocaleChangeInterceptor localeChangeInterceptor(){
        LocaleChangeInterceptor localeChangeInterceptor = new LocaleChangeInterceptor();
        //默认的请求参数为locale，eg: login?locale=zh_CN
        localeChangeInterceptor.setParamName(LocaleChangeInterceptor.DEFAULT_PARAM_NAME);
        return localeChangeInterceptor;
    }

    /**
     * 注册拦截器
     * @Author nicky.ma
     * @Date 2019/11/24 13:47
     * @Param [registry]
     * @return void
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
     registry.addInterceptor(localeChangeInterceptor()).addPathPatterns(&quot;/**&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意要点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;旧版代码可以不加LocaleChangeInterceptor 拦截器，2.2.1版本必须通过拦截器&lt;/li&gt;
&lt;li&gt;如下代码，bean的方法名必须为localeResolver，否则会报错&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
    public LocaleResolver localeResolver(){
        CustomLocalResolver localResolver = new CustomLocalResolver();
        localResolver.setDefaultLocale(webMvcProperties.getLocale());
        return localResolver;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;原理：&lt;br/&gt;跟一下源码，点进LocaleChangeInterceptor类&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124193029452.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112419322959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;DispatcherServlet是Spring一个很重要的分发器类，在DispatcherServlet的一个init方法里找到这个LocaleResolver的init方法&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124193508742.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;strong&gt;这个IOC获取的bean类名固定为localeResolver，写例子的时候，我就因为改了bean类名，导致一直报错，跟了源码才知道Bean类名要固定为localeResolver&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124193647136.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;抛异常的时候，也是会获取默认的LocaleResolver的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124193926753.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124193952223.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124194025637.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;找到资源文件，确认，还是默认为AcceptHeaderLocaleResolver&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124194052217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;配置了locale属性的时候，还是选用AcceptHeaderLocaleResolver作为默认的LocaleResolver&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;spring.mvc.locale=zh_CN&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;WebMvcAutoConfiguration.localeResolver方法源码，ConditionalOnMissingBean主键的意思是LocaleResolver没有自定义的时候，才作用，ConditionalOnProperty的意思，有配了属性才走这里的逻辑&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124194217184.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;拦截器拦截的请求参数默认为locale，要使用其它参数，必须通过拦截器设置 ,eg：&lt;code&gt;localeChangeInterceptor.setParamName(&quot;lang&quot;);&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124193121260.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;LocalResolver种类有：CookieLocaleResolver(Cookie)、SessionLocaleResolver(会话)、FixedLocaleResolver、AcceptHeaderLocaleResolver(默认)、.etc&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;thymeleaf集成&quot;&gt;5、Thymeleaf集成&lt;/h3&gt;
&lt;p&gt;本博客的模板引擎采用Thymeleaf的，所以新增项目时候就要加上maven相关依赖，没有的话，自己加上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-thymeleaf&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ok，然后去找个bootstrap的登录页面，本博客已尚硅谷老师的例子为例，进行拓展，引入静态资源文件：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124180539499.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Thymeleaf的i18n支持是采用#符号的&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&amp;gt;
        &amp;lt;meta name=&quot;description&quot; content=&quot;&quot;&amp;gt;
        &amp;lt;meta name=&quot;author&quot; content=&quot;&quot;&amp;gt;
        &amp;lt;title&amp;gt;SpringBoot i18n example&amp;lt;/title&amp;gt;
        &amp;lt;!-- Bootstrap core CSS --&amp;gt;
        &amp;lt;link href=&quot;asserts/css/bootstrap.min.css&quot; th:href=&quot;@{asserts/css/bootstrap.min.css}&quot; rel=&quot;stylesheet&quot;&amp;gt;
        &amp;lt;!-- Custom styles for this template --&amp;gt;
        &amp;lt;link href=&quot;asserts/css/signin.css&quot; th:href=&quot;@{asserts/css/signin.css}&quot; rel=&quot;stylesheet&quot;&amp;gt;
    &amp;lt;/head&amp;gt;

    &amp;lt;body class=&quot;text-center&quot;&amp;gt;
        &amp;lt;form class=&quot;form-signin&quot; action=&quot;dashboard.html&quot;&amp;gt;
            &amp;lt;img class=&quot;mb-4&quot; th:src=&quot;@{asserts/img/bootstrap-solid.svg}&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;72&quot;&amp;gt;
            &amp;lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot; th:text=&quot;#{messages.tip}&quot;&amp;gt;Please sign in&amp;lt;/h1&amp;gt;
            &amp;lt;label class=&quot;sr-only&quot; th:text=&quot;#{messages.username}&quot;&amp;gt;Username&amp;lt;/label&amp;gt;
            &amp;lt;input type=&quot;text&quot; class=&quot;form-control&quot; th:placeholder=&quot;#{messages.username}&quot; required=&quot;&quot; autofocus=&quot;&quot;&amp;gt;
            &amp;lt;label class=&quot;sr-only&quot; th:text=&quot;#{messages.password} &quot;&amp;gt;Password&amp;lt;/label&amp;gt;
            &amp;lt;input type=&quot;password&quot; class=&quot;form-control&quot; th:placeholder=&quot;#{messages.password}&quot; required=&quot;&quot;&amp;gt;
            &amp;lt;div class=&quot;checkbox mb-3&quot;&amp;gt;
                &amp;lt;label&amp;gt;
          &amp;lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot; &amp;gt; [[#{messages.rememberMe}]]
        &amp;lt;/label&amp;gt;
            &amp;lt;/div&amp;gt;
            &amp;lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; th:text=&quot;#{messages.loginBtnName}&quot;&amp;gt;Sign in&amp;lt;/button&amp;gt;
            &amp;lt;p class=&quot;mt-5 mb-3 text-muted&quot;&amp;gt;© 2019&amp;lt;/p&amp;gt;
            &amp;lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@{/login(locale='zh_CN')} &quot;&amp;gt;中文&amp;lt;/a&amp;gt;
            &amp;lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@{/login(locale='en_US')} &quot;&amp;gt;English&amp;lt;/a&amp;gt;
        &amp;lt;/form&amp;gt;

    &amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;切换中文网页：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124190802576.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;切换英文网页：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124190833284.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然不点链接传locale的方式也是可以自动切换的，浏览器设置语言：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124191042387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原理localeResolver类会获取Accept language参数&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20191124191200847.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9zbWlsZW5pY2t5LmJsb2cuY3Nkbi5uZXQ=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附录：&lt;/strong&gt;&lt;br/&gt;logging manual：&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/2.2.1.RELEASE/reference/html/spring-boot-features.html&quot;&gt;SpringBoot官方手册&lt;/a&gt;&lt;br/&gt;example source：&lt;a href=&quot;https://github.com/u014427391/springbootexamples&quot;&gt;例子代码下载链接&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 24 Nov 2019 16:06:00 +0000</pubDate>
<dc:creator>smileNicky</dc:creator>
<og:description>SpringBoot系统之i18n国际化语言集成教程 @[toc] 1、环境搭建 本博客介绍一下SpringBoot集成i18n，实现系统语言国际化处理，ok，先创建一个SpringBoot项目，具体</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mzq123/p/11925325.html</dc:identifier>
</item>
<item>
<title>x86汇编分页模式实验 --《ORANGE'S一个操作系统的实现》中 pmtest8.asm解析 - Vizdl</title>
<link>http://www.cnblogs.com/vizdl/p/11925205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vizdl/p/11925205.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;序言(废话) : 在看书的过程中发现一开始不是很能理解pmtest8的目的,以及书上说得很抽象..于是在自己阅读过源代码后,将一些自己的心得写在这里。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　正文 : &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　讲解顺序依然按照书上贴代码的顺序来。但是是几乎逐句解释的。可能会稍微有点啰嗦。废话就不多说了直接贴代码。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;LABEL_DESC_FLAT_C:&lt;/span&gt;  Descriptor &lt;span&gt;0&lt;/span&gt;,        0fffffh, DA_CR|DA_32|DA_LIMIT_4K&lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0~4G&lt;/span&gt;
&lt;span&gt;LABEL_DESC_FLAT_RW:&lt;/span&gt; Descriptor &lt;span&gt;0&lt;/span&gt;,        0fffffh, DA_DRW|DA_LIMIT_4K     &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0~4G&lt;/span&gt;
&lt;span&gt;SelectorFlatC 　　　　　　equ 　　 LABEL_DESC_FLAT_C - LABEL_GDT 　　　　　　　　　　　　　　　
SelectorFlatRW        equ    LABEL_DESC_FLAT_RW - LABEL_GDT&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　显然,两个分别是 FLAT_C 和  FLAT_RW 的描述符和选择子。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　问题 : 为什么要有这两个东西?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　解释 : FLAT_C是用来执行的非一致性32位代码段,粒度为4k,也就是 limit(段限长) =&lt;/span&gt; &lt;span&gt;(0xfffff + 1)  * 4k = 4G&lt;/span&gt;,FLAT_RW &lt;span&gt;是用来修改数据的,因为需要利用这个描述符的权限(可写)来将代码写入到目的地(这个目的地允许在 0 - 4G区间内)。&lt;/span&gt;&lt;span&gt;之所以要分两个选择符,是防止在执行的时候修改代码(所以FLAT_C不能给写的权限),但是又必须在执行之前进行复制,所以一定要有一个入口能提供写入的方式,于是设置两个描述符来进行。这样既安全又有章法。&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SetupPaging:&lt;/span&gt;
    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 根据内存大小计算应初始化多少PDE以及多少页表&lt;/span&gt;
    &lt;span&gt;xor&lt;/span&gt;&lt;span&gt;    edx, edx
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    eax, [dwMemSize]
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;    ebx, 400000h    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 400000h = 4M = 4096 * 1024, 一个页表对应的内存大小&lt;/span&gt;
    &lt;span&gt;div&lt;/span&gt;&lt;span&gt;    ebx
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;    ecx, eax    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 此时 ecx 为页表的个数，也即 PDE 应该的个数&lt;/span&gt;
    &lt;span&gt;test&lt;/span&gt;&lt;span&gt;    edx, edx
    &lt;/span&gt;&lt;span&gt;jz&lt;/span&gt;&lt;span&gt;    .no_remainder
    &lt;/span&gt;&lt;span&gt;inc&lt;/span&gt;    ecx        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 如果余数不为 0 就需增加一个页表&lt;/span&gt;
.&lt;span&gt;no_remainder:&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    [PageTableNumber], ecx    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 暂存页表个数&lt;/span&gt;

    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 为简化处理, 所有线性地址对应相等的物理地址. 并且不考虑内存空洞.&lt;/span&gt;

    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 首先初始化页目录&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, SelectorFlatRW
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;    edi, PageDirBase0    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 此段首地址为 PageDirBase0&lt;/span&gt;
    &lt;span&gt;xor&lt;/span&gt;&lt;span&gt;    eax, eax
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    eax, PageTblBase0 | PG_P  | PG_USU | PG_RWW
.&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;:    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; es:edi 初始等于 PageDirBase0 (当前页目录表项), eax 初始基地址等于 PageTblBase0&lt;/span&gt;
    &lt;span&gt;stosd&lt;/span&gt;
    &lt;span&gt;add&lt;/span&gt;    eax, &lt;span&gt;4096&lt;/span&gt;        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 为了简化, 所有页表在内存中是连续的.&lt;/span&gt;
    loop    .&lt;span&gt;1&lt;/span&gt;

    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 再初始化所有页表&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    eax, [PageTableNumber]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 页表个数&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    ebx, &lt;span&gt;1024&lt;/span&gt;        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 每个页表 1024 个 PTE&lt;/span&gt;
    &lt;span&gt;mul&lt;/span&gt;&lt;span&gt;    ebx
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;    ecx, eax        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; PTE个数 = 页表个数 * 1024&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    edi, PageTblBase0    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 此段首地址为 PageTblBase0&lt;/span&gt;
    &lt;span&gt;xor&lt;/span&gt;&lt;span&gt;    eax, eax
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    eax, PG_P  | PG_USU | PG_RWW
.&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;:    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; es:edi 初始等于 PageTblBase0 (当前页表项), eax = 0 (线性地址 = 物理地址)&lt;/span&gt;
    &lt;span&gt;stosd&lt;/span&gt;
    &lt;span&gt;add&lt;/span&gt;    eax, &lt;span&gt;4096&lt;/span&gt;        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 每一页指向 4K 的空间&lt;/span&gt;
    loop    .&lt;span&gt;2&lt;/span&gt;

    &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    eax, PageDirBase0
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    cr3, eax
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    eax, cr0
    &lt;/span&gt;&lt;span&gt;or&lt;/span&gt;&lt;span&gt;    eax, 80000000h
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    cr0, eax
    &lt;/span&gt;&lt;span&gt;jmp&lt;/span&gt;    short .&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
.&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;nop&lt;/span&gt;

    &lt;span&gt;ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;这段代码我加注了两句注释 分别在 .1 和 .2 这两个标签那行,其实这里和之前的setPaging并没有很大的区别,需要注意的就是 这里的 页目录表 的地址是  PageDirBase0, 页表的地址是PageTblBase0,强调这点的原因在于之后的  PSwitch 这个函数中则是 PageDirBase1 和 PageTblBase1。也就是说实际上数据中有两个页面管理的数据结构(页目录表和页表合起来相当于一个管理页面的数据结构)。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;PagingDemo:&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, cs
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ds, ax
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ax, SelectorFlatRW        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 设置es为基地址为0的可读写的段(便于复制代码)&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    LenFoo
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    OffsetFoo
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;    ProcFoo            &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 00401000h&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    MemCpy        
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    esp, &lt;span&gt;12&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;    LenBar            &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 被复制代码段(但是以ds为段基址)的长度 &lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;    OffsetBar        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 被复制代码段(但是以ds为段基址)的段偏移量&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;    ProcBar            &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 目的代码段的物理空间地址 00501000h&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    MemCpy
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    esp, &lt;span&gt;12&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    LenPagingDemoAll
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;&lt;span&gt;    OffsetPagingDemoProc    
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;push&lt;/span&gt;    ProcPagingDemo            &lt;span&gt;;&lt;/span&gt;&lt;span&gt; [es:ProcPagingDemo] = ProcPagingDemo = 00301000h&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;&lt;span&gt;    MemCpy
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    esp, &lt;span&gt;12&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, SelectorData
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ds, ax            &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 数据段选择子&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;    SetupPaging        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 启动分页&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 当前线性地址依然等于物理地址&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;    &lt;span&gt;SelectorFlatC:&lt;/span&gt;ProcPagingDemo    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 访问的线性地址为 00301000h,物理地址也是 00301000h&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;    PSwitch            &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 切换页目录，改变地址映射关系&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;call&lt;/span&gt;    &lt;span&gt;SelectorFlatC:&lt;/span&gt;ProcPagingDemo    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 访问的线性地址为 00301000h&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;在这里首先要说明的是 MemCpy函数,这个函数有三个参数分别表示 : &lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;　　　1）被复制段(但是以ds为段基址)的 长度 &lt;/span&gt;&lt;br/&gt;&lt;span&gt;　　　2）被复制段(但是以ds为段基址)的 段偏移量&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;span&gt;　　　3）目的地的物理空间地址(之所以说是物理空间是因为当前线性地址等于物理地址,以es为段基址,但是es的段基址为0)&lt;br/&gt;功能则是 将被复制段 的数据复制 参数1)的长度字节 去目的地去(简单说就是利用三个参数复制数据)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我们可以知道的是在上面代码中三次调用 MemCpy 都没有进入分页模式,也就是说当下线性地址等于物理地址。那么根据我上面的注释就可以知道三个代码分别复制到哪里去了。&lt;br/&gt;之后就是恢复数据段(之前将ds = cs,是为了复制代码),然后启动分页(上面已经讲了),然后启动分页后当前线性地址依然等于物理地址。&lt;br/&gt;这个时候第一次调用 call SelectorFlatC:ProcPagingDemo,也就是访问的线性地址为 00301000h,物理地址也是 00301000h的代码(之前移动过去的)。&lt;br/&gt;　下面这段代码就是被移动到00301000h的代码,这段代码只做了一件事那就是调用 [cs:LinearAddrDemo]的代码,但请注意,由于 call SelectorFlatC:ProcPagingDemo &lt;br/&gt;所以此时的 cs = SelectorFlatC,也就是说段基址等于0,于是实际上这段代码的功能就是访问 物理地址为00401000h处的代码。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;PagingDemoProc:&lt;/span&gt;&lt;span&gt;
OffsetPagingDemoProc    equ    PagingDemoProc - $$
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    eax, LinearAddrDemo
    &lt;/span&gt;&lt;span&gt;call&lt;/span&gt;    eax        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 未开始PSwitch前, eax = ProcFoo = 00401000h (cs 的段基址 = 0)&lt;/span&gt;
    &lt;span&gt;retf&lt;/span&gt;&lt;span&gt;
LenPagingDemoAll    equ    $ - PagingDemoProc&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;而物理地址00401000h处就是ProcFoo的代码(第一次调用MemCpy拷贝的代码)。被拷贝的代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;foo:&lt;/span&gt;&lt;span&gt;
OffsetFoo        equ    foo - $$
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;    ah, 0Ch            &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0000: 黑底    1100: 红字&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    al, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;F&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    [&lt;span&gt;gs:&lt;/span&gt;((&lt;span&gt;80&lt;/span&gt; * &lt;span&gt;17&lt;/span&gt; + &lt;span&gt;0&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt;)], ax    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 屏幕第 17 行, 第 0 列。&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    al, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;o&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    [&lt;span&gt;gs:&lt;/span&gt;((&lt;span&gt;80&lt;/span&gt; * &lt;span&gt;17&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt;)], ax    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 屏幕第 17 行, 第 1 列。&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    [&lt;span&gt;gs:&lt;/span&gt;((&lt;span&gt;80&lt;/span&gt; * &lt;span&gt;17&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt;)], ax    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 屏幕第 17 行, 第 2 列。&lt;/span&gt;
    &lt;span&gt;ret&lt;/span&gt;&lt;span&gt;
LenFoo            equ    $ - foo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;功能很明显就是现实一个字符串 Foo而已。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;总结第一次分页后的动作:&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　就是拷贝三份代码分别到ProcFoo, ProcBar, ProcPagingDemo 处(这四个都是物理内存哦,并且后面因为段基址是0(FLAT_C 段基址)于是很容易地就访问到了物理地址)。然后开启分页模式(其实几乎没什么影响 因为仍然和分段一样 线性地址 = 物理地址)。然后调用 被拷贝的函数 ProcPagingDemo ,ProcPagingDemo 函数调用 ProcFoo函数,显示字符 &quot;Foo&quot;然后两次返&lt;/span&gt;回。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二次分页 : call PSwitch&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;被调用代码如下 :&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;67&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;PSwitch:&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 初始化页目录&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ax, SelectorFlatRW
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    es, ax
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    edi, PageDirBase1    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 此段首地址为 PageDirBase1&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;xor&lt;/span&gt;&lt;span&gt;    eax, eax
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    eax, PageTblBase1 | PG_P  | PG_USU | PG_RWW
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    ecx, [PageTableNumber]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; .&lt;span&gt;1&lt;/span&gt;:    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; es:edi 初始等于 PageDirBase1 (当前页目录表项), eax 初始基地址等于 PageTblBase1&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;stosd&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    eax, &lt;span&gt;4096&lt;/span&gt;        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 为了简化, 所有页表在内存中是连续的.&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     loop    .&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 再初始化所有页表&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    eax, [PageTableNumber]    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 页表个数&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ebx, &lt;span&gt;1024&lt;/span&gt;        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 每个页表 1024 个 PTE&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;mul&lt;/span&gt;&lt;span&gt;    ebx
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ecx, eax        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; PTE个数 = 页表个数 * 1024&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    edi, PageTblBase1    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 此段首地址为 PageTblBase1&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;xor&lt;/span&gt;&lt;span&gt;    eax, eax
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    eax, PG_P  | PG_USU | PG_RWW
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; .&lt;span&gt;2&lt;/span&gt;: &lt;span&gt;;&lt;/span&gt;&lt;span&gt; es:edi 初始等于 PageTblBase1 (当前页表项), eax 初始基地址等于 0(线性地址等于物理地址)&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;stosd&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    eax, &lt;span&gt;4096&lt;/span&gt;        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 每一页指向 4K 的空间&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;     loop    .&lt;span&gt;2&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 在此假设内存是大于 8M 的&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 下列代码将LinearAddrDemo所处的页表的相对第一个页表的偏移地址放入ecx中&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    eax, LinearAddrDemo
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;shr&lt;/span&gt;    eax, &lt;span&gt;22&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ebx, &lt;span&gt;4096&lt;/span&gt;        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; (LinearAddrDemo / 4M)表示第几个页表&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;mul&lt;/span&gt;    ebx                &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 第几个页表 * 4k (1024(一个页表项的数量) * 4(一个页表项的字节))&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ecx, eax        &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 也就是对应页表的偏移地址&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     
&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 下列代码将LinearAddrDemo所处的页表项相对第一个页表项的偏移地址放入eax中&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    eax, LinearAddrDemo
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;shr&lt;/span&gt;    eax, &lt;span&gt;12&lt;/span&gt;            &lt;span&gt;;&lt;/span&gt;&lt;span&gt; LinearAddrDemo / 4k,表示第几个页表项&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;and&lt;/span&gt;    eax, 03FFh    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 1111111111b (10 bits)    ; 取低10位,也就是余下的零散页表项(一个页表有2^10个页表项)&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    ebx, &lt;span&gt;4&lt;/span&gt;                                
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;mul&lt;/span&gt;    ebx                                    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; * 4 表示的是具体偏移字节数&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    eax, ecx                            &lt;span&gt;;&lt;/span&gt;&lt;span&gt; eax = (((LinearAddrDemo / 2^12) &amp;amp; 03FFh) * 4) + (4k * (LinearAddrDemo / 2^22))&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     
&lt;span&gt;43&lt;/span&gt;     
&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;add&lt;/span&gt;    eax, PageTblBase1                    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 第一个页表的第一个页表项&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;    dword [&lt;span&gt;es:&lt;/span&gt;&lt;span&gt;eax], ProcBar | PG_P | PG_USU | PG_RWW
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    eax, PageDirBase1
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;    cr3, eax
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     &lt;span&gt;jmp&lt;/span&gt;    short .&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt; .&lt;span&gt;3&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;nop&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;ret&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;在这里我加了几个比较重要的注释分别在第 9, 22, 28,35处。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这段代码做了什么?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　首先是设置页面管理的数据结构(页表和页目录表),但是需要注意的是,这里设置页表和页目录表除了不是之前的页面管理结构之外,其实内容是差不多的,也就是说当前(第25行)这里的状态也是 线性地址 = 物理地址 ！！！&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;　但是在第27行做了一个操作,就是将LinearAddrDemo对应的 页表项的地址 换成了&lt;/span&gt; ProcBar(00501000h) 的地址。(具体如何实现的请看27-45行我写的注释)。&lt;br/&gt;　 &lt;span&gt;在做完这些之后就返回第二次执行 call SelectorFlatC:ProcPagingDemo 了,在这个时候 cs = SelectorFlatC (段基址等于0), eip = ProcPagingDemo = 00301000h,也就是说访问了 &lt;br/&gt;线性地址 = 00301000h处,但是这里已经被修改,除了这个页面之外,其他页面都是 线性地址 = 物理地址,但是这里 线性地址 = 00301000h ,映射的物理地址是 ProcBar(00501000h)&lt;br/&gt;于是便调用了 ProcBar 段的代码,而这段的代码是第二次调用MemCpy时候复制过去的。被复制的具体代码是:&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bar:&lt;/span&gt;&lt;span&gt;
OffsetBar        equ    bar - $$
    &lt;/span&gt;&lt;span&gt;mov&lt;/span&gt;    ah, 0Ch            &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 0000: 黑底    1100: 红字&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    al, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    [&lt;span&gt;gs:&lt;/span&gt;((&lt;span&gt;80&lt;/span&gt; * &lt;span&gt;18&lt;/span&gt; + &lt;span&gt;0&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt;)], ax    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 屏幕第 18 行, 第 0 列。&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    al, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    [&lt;span&gt;gs:&lt;/span&gt;((&lt;span&gt;80&lt;/span&gt; * &lt;span&gt;18&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt;)], ax    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 屏幕第 18 行, 第 1 列。&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    al, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
    &lt;span&gt;mov&lt;/span&gt;    [&lt;span&gt;gs:&lt;/span&gt;((&lt;span&gt;80&lt;/span&gt; * &lt;span&gt;18&lt;/span&gt; + &lt;span&gt;2&lt;/span&gt;) * &lt;span&gt;2&lt;/span&gt;)], ax    &lt;span&gt;;&lt;/span&gt;&lt;span&gt; 屏幕第 18 行, 第 2 列。&lt;/span&gt;
    &lt;span&gt;ret&lt;/span&gt;&lt;span&gt;
LenBar            equ    $ - bar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;也就是显示一个字符串 &quot;Bar&quot;, 然后返回到PagingDemo的最后一句 ret,再次返回。于是这段代码也就结束了。&lt;br/&gt;第二次代码是如何实现调用 ProcBar的？&lt;br/&gt;　　通过将线性地址 = ProcPaging(00301000h)对应的页表项的地址值给修改成了 PaocBar(00501000h)的物理地址,于是从 00301000h 的线性地址 映射到 00501000h的物理地址上去了,&lt;br/&gt;但是其实其他地方(除了这个页之外)的线性地址 = 物理地址依然成立。也是上面这段代码很小,一定是小于 4k(一页的大小)，于是只需要修改一个页表项就可以了！&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 24 Nov 2019 15:37:00 +0000</pubDate>
<dc:creator>Vizdl</dc:creator>
<og:description>序言(废话) : 在看书的过程中发现一开始不是很能理解pmtest8的目的,以及书上说得很抽象..于是在自己阅读过源代码后,将一些自己的心得写在这里。 正文 : 讲解顺序依然按照书上贴代码的顺序来。但</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vizdl/p/11925205.html</dc:identifier>
</item>
</channel>
</rss>