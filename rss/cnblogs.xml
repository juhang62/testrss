<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>C# 图片打印杂谈 - zlyxm</title>
<link>http://www.cnblogs.com/zlyxm/p/10937940.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zlyxm/p/10937940.html</guid>
<description>&lt;p&gt;日常开头水一下，看了下上次博客，一年零八天了，啧啧，奢侈。&lt;/p&gt;
&lt;p&gt;最近这个工作挺满意的，是我想要的发展方向，后续要做机器学习，现在得先把公司之前堆积的问题解决了。&lt;/p&gt;
&lt;p&gt;谈人生到此结束，还是说正题吧。（感觉这标题吸引不了人啊）&lt;/p&gt;


&lt;p&gt;打印：PrintDocument&lt;/p&gt;
&lt;p&gt;环境：WPF and Winform&lt;/p&gt;
&lt;p&gt;要求：排版并打印图片&lt;/p&gt;
&lt;p&gt;之前一直不明白很多参数的问题，现在想清楚了，随手记录一下。&lt;/p&gt;
&lt;p&gt;WPF暂放一边，把winform先解决了，跟百度烂大街的一样是 PrintPage事件Graphics绘制来打印的。其它部分参考&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a title=&quot;C# 利用PrintDocument定制打印单据&quot; href=&quot;https://www.cnblogs.com/hsiang/p/6921817.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/hsiang/p/6921817.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先用Graphics绘制一直不明白的是该怎么绘制，纸张的大小是多少，怎么样才能按照指定尺寸打印。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们先聊聊纸张大小，看纸张大小可以在开始文件打印&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
 &lt;span&gt; PrintDocument.Print(); &lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre&gt;
并选好打印机后，在 PrintPage事件里绘制要打印的数据
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; pdControl_PrintPage(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, PrintPageEventArgs e)
{&lt;br/&gt;　　　　var printDocument = (PrintDocument)sender;&lt;br/&gt;&lt;/span&gt;　　　　//纸张的高和宽&lt;br/&gt;　　　　var paper_h = printDocument.DefaultPageSettings.PaperSize.Height;&lt;br/&gt;　　　　var paper_w = printDocument.DefaultPageSettings.PaperSize.Width;&lt;br/&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然而知道高和宽但不知道单位啊，这高和宽到底是像素还是英寸还是其它的什么鬼。&lt;/p&gt;
&lt;p&gt;在实例化new PaperSize就看得到注释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1143688/201905/1143688-20190528141011823-621092800.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;百分之一英寸为单位&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 这样第一个问题就解决了，纸张的大小是 printDocument.DefaultPageSettings.PaperSize，并且单位是百分之一英寸。&lt;/p&gt;
&lt;p&gt;不过不要太相信这个，比如我要打印的图片是6寸的（特地量了），但给出是尺寸宽多了0.15In,高多了0.13In。好歹win自带的PDF打印A4纸也就相差0.002以下好吧。这个为什么有误差待大神解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1143688/201905/1143688-20190528141417485-1908907608.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;那么第二个问题（第三个）：该怎么绘制才能按照指定尺寸打印&lt;/p&gt;
&lt;p&gt;既然我们知道了打印的范围也就避免了绘制超出纸张。那么我们就要绘制内容了，咱这只讲图片，其它的也差不多。&lt;/p&gt;
&lt;p&gt;我做的是根据图片的大小铺满整个打印纸。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们先建个类,来记录要图片大小及纸张大小&lt;br/&gt;&lt;/span&gt;   //这个类只是方便调试转换度量单位，实际应用只选一种计算单位就行了
    &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PrintUnit
    {&lt;br/&gt;　　　　 //图片大小，这里图片其实是一寸的照片
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; unit_w = &lt;span&gt;259&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; unit_h = &lt;span&gt;377&lt;/span&gt;&lt;span&gt;;&lt;br/&gt;　　　　 //纸张大小300dpi 6*300 4*300
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; PaperSize paperSize = &lt;span&gt;new&lt;/span&gt; PaperSize(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1800&lt;/span&gt;, &lt;span&gt;1200&lt;/span&gt;&lt;span&gt;);&lt;br/&gt;　　　　 //度量单位
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; GraphicsUnit unit =&lt;span&gt; GraphicsUnit.Pixel;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; GraphicsUnit Unit
        {
            &lt;/span&gt;&lt;span&gt;get&lt;/span&gt; =&amp;gt;&lt;span&gt; unit;
            &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
            {
                unit &lt;/span&gt;=&lt;span&gt; value;&lt;br/&gt;　　　　　　　　　 //如果度量单位为毫米
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (unit ==&lt;span&gt; GraphicsUnit.Millimeter)
                {&lt;br/&gt;　　　　　　　　　　　 //具体换算为 1200/300*25.4 约等于 102&lt;br/&gt;　                  paperSize.Height &lt;/span&gt;= &lt;span&gt;102&lt;/span&gt;&lt;span&gt;;
                    paperSize.Width &lt;/span&gt;= &lt;span&gt;152&lt;/span&gt;&lt;span&gt; ;&lt;br/&gt;unit_w &lt;/span&gt;= &lt;span&gt;22&lt;/span&gt;&lt;span&gt;;
                    unit_h &lt;/span&gt;= &lt;span&gt;32&lt;/span&gt;&lt;span&gt;;
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在 PrintPage事件里得到计算打印纸可以铺满多少图片&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
            PrintUnit printUnit = new PrintUnit();&lt;br/&gt;　　　　　　  g.PageUnit = printUnit.Unit;&lt;br/&gt;　　　　　　  column = printUnit.paperSize.Width /&lt;span&gt; printUnit.unit_w;
            row &lt;/span&gt;= printUnit.paperSize.Height /&lt;span&gt; printUnit.unit_h;

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; row; i++&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;0&lt;/span&gt;; j &amp;lt; column; j++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;g.DrawImage(
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    Resources._1,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    new Rectangle(j * printUnit.unit_w, i * printUnit.unit_h, printUnit.unit_w, printUnit.unit_h),
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    new Rectangle(0, 0, Resources._1.Width, Resources._1.Height),
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    g.PageUnit);&lt;/span&gt;
                    g.DrawImage(Resources._1, j * printUnit.unit_w, i *&lt;span&gt; printUnit.unit_h, printUnit.unit_w, printUnit.unit_h);
                }
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　有趣的是在DrawImage(Image image, Rectangle destRect, Rectangle srcRect, GraphicsUnit srcUnit);的重载方法里图片有误差，原因不明。&lt;/p&gt;
&lt;p&gt; 有点乱了，来强行解释一波。&lt;/p&gt;
&lt;p&gt;在打印事件里PrintPageEventArgs.PageUnit 是设置度量单位，就是你要绘制的单位是按照像素还是毫米或其它，默认是百分之一英寸。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//比如你要打印A4纸210mm×297mm ，打印&lt;/span&gt;PrintPage事件&lt;span&gt;里设置度量单位为&lt;/span&gt;Millimeter&lt;br/&gt;&lt;span&gt;g.PageUnit=GraphicsUnit.Millimeter；&lt;br/&gt;//铺满整个A4纸&lt;br/&gt;&lt;/span&gt;&lt;span&gt;g.DrawImage(image, 0, 0, 210, 297);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 就是这么简单，不过不建议用毫米为单位，因为这样图片容易误差，这是因为绘制时会将毫米转换成像素。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1143688/201905/1143688-20190528154118177-208983763.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很明显用毫米来绘制时会有间隙&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; 懒得排版，事多，溜了溜了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1143688/201905/1143688-20190528154902128-1514516827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt; 前方高能提醒，代码很乱，不用谢。&lt;/p&gt;
&lt;p&gt; https://files.cnblogs.com/files/zlyxm/DemoPrint_zlyxm.rar&lt;/p&gt;



</description>
<pubDate>Tue, 28 May 2019 07:56:00 +0000</pubDate>
<dc:creator>zlyxm</dc:creator>
<og:description>日常开头水一下，看了下上次博客，一年零八天了，啧啧，奢侈。 最近这个工作挺满意的，是我想要的发展方向，后续要做机器学习，现在得先把公司之前堆积的问题解决了。 谈人生到此结束，还是说正题吧。（感觉这标题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zlyxm/p/10937940.html</dc:identifier>
</item>
<item>
<title>Pandas读取较大数据量级的处理方法 - chunk - 冻雨冷雾</title>
<link>http://www.cnblogs.com/techs-wenzhe/p/10937903.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techs-wenzhe/p/10937903.html</guid>
<description>
&lt;p&gt;&lt;span&gt;前情提要: &lt;/span&gt;  &lt;/p&gt;
&lt;p&gt;工作原因需要处理一批约30G左右的CSV数据，数据量级不需要使用hadoop的使用，同时由于办公的本本内存较低的缘故，需要解读取数据时内存不足的原因。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;操作流程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;方法与方式:首先是读取数据，常见的csv格式读取时一次性全部读取进来， 面对数据量较大(本次3亿条实车数据)时，需要 &lt;strong&gt;分批 &lt;/strong&gt;并且有 &lt;strong&gt;选择性 &lt;/strong&gt;的读取后 提取有效信息 删除冗余信息并清理内存。&lt;/p&gt;
&lt;p&gt;同时，为了使处理数据时效率更高，将整理好的数据实时读取进来以后，&lt;strong&gt;保存成快速且可读的数据形式另行存储&lt;/strong&gt;。然后&lt;strong&gt;释放内存&lt;/strong&gt;并读取下一批数据直到整个流程结束&lt;/p&gt;

&lt;p&gt;下面是操作代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('e11b46a2-4a31-4111-b368-afd5c259ba91')&quot; readability=&quot;41.5&quot;&gt;&lt;img id=&quot;code_img_closed_e11b46a2-4a31-4111-b368-afd5c259ba91&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_e11b46a2-4a31-4111-b368-afd5c259ba91&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('e11b46a2-4a31-4111-b368-afd5c259ba91',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_e11b46a2-4a31-4111-b368-afd5c259ba91&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;78&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;import pickle # pkl存储与 hdf5存储&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pandas as pd
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 释放内存&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; gc
reader &lt;/span&gt;= pd.read_csv(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\VEH_GBK_2019-01-01.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,iterator=True,low_memory=False,usecols=[0,1,2,4&lt;span&gt;])
title_mc&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;vid&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;上报时间&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;充电状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

loop &lt;/span&gt;=&lt;span&gt; True
chunkSize &lt;/span&gt;= 1000000&lt;span&gt;
ans_vid&lt;/span&gt;=&lt;span&gt;{}
location_list&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;上海&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;重庆&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;广东&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北京&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; location_list:
    ans_vid[i]&lt;/span&gt;=&lt;span&gt;[]


&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; loop:
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
        chunk &lt;/span&gt;=&lt;span&gt; reader.get_chunk(chunkSize)
        chunk.columns&lt;/span&gt;=&lt;span&gt;title_mc;
        chunk[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;充电状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=chunk[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;充电状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].astype(str)
        chunk[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]=chunk[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].astype(str)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; location_list:
            temp&lt;/span&gt;=chunk[chunk[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;location&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;].str.contains(i)]
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; temp[(temp[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;充电状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) | (temp[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;充电状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;4.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)].empty==&lt;span&gt;False:
                ans_vid[i].append(temp[(temp[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;充电状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) | (temp[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;充电状态&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;4.0&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)])
                &lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; temp
                gc.collect()
            
        &lt;/span&gt;&lt;span&gt;del&lt;/span&gt;&lt;span&gt; chunk
        gc.collect()
        
    &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; StopIteration:
        loop &lt;/span&gt;=&lt;span&gt; False
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt; (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Iteration is stopped.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; location_list:
    ans_vid[i]&lt;/span&gt;=&lt;span&gt;pd.concat(ans_vid[i])
    
location_list&lt;/span&gt;=[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;shanghai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;chongqing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;guangdong&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;beijing&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; location_list:
    ans_vid[i].to_hdf(i&lt;/span&gt;+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_charging.h5&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,key=ans_vid[i],encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;gc.collect()放在del 参数的后面用以及时释放内存。&lt;/p&gt;
&lt;p&gt;读取的核心代码是:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
reader = pd.read_csv(r&lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:\VEH_GBK_2019-01-01.csv&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,iterator=True,low_memory=False,usecols=[0,1,2,4]) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; usecols是读取原数据的某几列  chunkSize是分批读取的量级&lt;/span&gt;
&lt;span&gt;
chunk &lt;/span&gt;= reader.get_chunk(chunkSize)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本次读取的存储格式采用的是h5格式即hdf，该种格式易于读取较大数据量级，同时也有一些数据格式可以保存较大的数据量级: pkl ,npy等&lt;/p&gt;
&lt;p&gt;推荐h5（保存dataframe）与pkl（保存字典格式），其读取速度更快.易于使用&lt;/p&gt;

</description>
<pubDate>Tue, 28 May 2019 07:53:00 +0000</pubDate>
<dc:creator>冻雨冷雾</dc:creator>
<og:description>前情提要: 工作原因需要处理一批约30G左右的CSV数据，数据量级不需要使用hadoop的使用，同时由于办公的本本内存较低的缘故，需要解读取数据时内存不足的原因。 操作流程： 方法与方式:首先是读取数</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techs-wenzhe/p/10937903.html</dc:identifier>
</item>
<item>
<title>.NET Core微服务 权限系统+工作流（一）权限系统 - Jade_K</title>
<link>http://www.cnblogs.com/wms01/p/10903646.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wms01/p/10903646.html</guid>
<description>&lt;h3&gt;一、前言&lt;/h3&gt;
&lt;p&gt;实际上权限系统老早之前我就在一直开发，大概在刚毕业没多久就想一个人写一个系统，断断续续一直坚持到现在，毕竟自己亲动手自写的系统才有收获，本篇仅介绍权限。&lt;/p&gt;
&lt;p&gt;　　小小系统上不了台面，&lt;strong&gt;望各位大神勿喷。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;二、系统介绍&lt;/h3&gt;
&lt;p&gt;目前采用的是.Net Core微服务的方式实现，本文不讨论具体的中间件主要是（ocelot + consul等），一直参考微软的  &lt;a href=&quot;https://github.com/dotnet-architecture/eShopOnContainers&quot; target=&quot;_blank&quot;&gt;eShopOnContainers&lt;/a&gt; ，进行简单的实现，但是ORM是用的Dapper，并简单进行封装  &lt;a href=&quot;https://www.nuget.org/packages/JadeFramework.Dapper/&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt; ，当然自己也封装了一些简单的插件进行复用：&lt;a href=&quot;https://github.com/wangmaosheng/JadeFramework&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651757/201905/651757-20190522095600508-790511925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;三、权限系统&lt;/h3&gt;
&lt;p&gt;权限系统实现很简单，权限的划分我觉得可以分为三种：&lt;/p&gt;
&lt;p&gt;1、菜单权限2、按钮权限3、数据权限&lt;/p&gt;
&lt;p&gt;简单介绍下：1、菜单权限。表示用户是否能够访问该页面（角色挂钩）&lt;/p&gt;
&lt;p&gt;　　　　　　2、按钮权限。表示用户是否能够操作该页面上的功能（角色挂钩）&lt;/p&gt;
&lt;p&gt;　　　　　　3、数据权限。表示用户访问页面时进行数据筛选（该功能暂未实现，这个要与具体的业务结合才能写），与部门挂钩，这个不太好理解，当然一般的权限系统这个功能也不会做，举个简单例子，OA系统里面我查看我的工资条，我应该只能看到我自己的数据，但是我的部门经理，他可以有权限看到该部门的全部数据，这个就是数据权限。&lt;/p&gt;
&lt;p&gt;为什么写这个系统？&lt;/p&gt;
&lt;p&gt;　　之前待过好几家公司，发现他们的系统都是对菜单进行分配，当然了，业务需求只要这个就当我没说，我只是觉得这样做太不安全并且我觉得之前系统的实现方式可以进行一些优化，所以就一直写到现在，可能代码质量不如哪些大神的优秀，系统在我看来太小，就简单搭了个框架实现。你过条小水沟，没必要造条桥。&lt;/p&gt;
&lt;p&gt;要使用该系统前提条件：前端：Sea.js和Vue，对于sea.js，在前端这块感觉已经没多少人用了，但是这中CMD思想是不会被淘汰的，你看最近比较火的layerui也是的，对于Vues只是简单的应用，也就用到双向绑定而已，开发复杂的页面确实比较方便，但是简单的页面就得不偿失了。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　后端：consul、rabbitmq ，具体怎么安装不在描述&lt;/p&gt;
&lt;p&gt;大概的用户访问流程描述如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户登录    　　=====》　　获取该用户角色 　　===》　　通过角色获取该角色对应的权限 &lt;span&gt;并集&lt;/span&gt;  ===&amp;gt;返回相应数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　　　　　sys_user_role　　　　　　sys_role_resource&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;系统关系图如下（MySQL）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651757/201905/651757-20190522091149452-1791681191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;具体功能实现请看代码，这里不做阐述，菜单权限的分配通过角色表和菜单表的关联表操作即可，但是按钮的权限分配如何实现？我的实现方式是：把按钮的操作也看成一种菜单的资源分配，只不过比较特殊，我这里不仅仅是对按钮的显示进行控制，我做的比较绝，也对后台方法访问权限也做了控制，这样比较安全，对于按钮权限的控制，实际上是明确的，比方说，一个删除按钮，它只能对应后台的一个删除方法，这个方法是明确的，对于页面的按钮的类型和个数是固定的，不然你没办法分配，基于这个前提，我对菜单的生成进行代码控制从而达到控制目的，因此，菜单和按钮和在一起称之为资源表 sys_resource 。具体的实现代码也不是很复杂，一层一层判断即可，权限过滤器如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PermissionAuthorizationRequirement : IAuthorizationRequirement
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; UrlAndButtonType UrlAndButtonType { &lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; 
&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; PermissionAuthorizationRequirement(&lt;span&gt;string&lt;/span&gt; url, ButtonType buttonType, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isPage)
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;             UrlAndButtonType = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UrlAndButtonType()
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;                 Url =&lt;span&gt; url,
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;                 ButtonType = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)buttonType,
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;                 IsPage =&lt;span&gt; isPage
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; PermissionAuthorizationRequirement(&lt;span&gt;string&lt;/span&gt; url, &lt;span&gt;byte&lt;/span&gt; buttonType, &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; isPage)
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;             UrlAndButtonType = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UrlAndButtonType()
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;                 Url =&lt;span&gt; url,
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;                 ButtonType =&lt;span&gt; buttonType,
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;                 IsPage =&lt;span&gt; isPage
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 权限过滤器
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt;     &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    [Authorize]
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     [AttributeUsage(AttributeTargets.Method, AllowMultiple = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;sealed&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PermissionAttribute : TypeFilterAttribute
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构造器
&lt;/span&gt;&lt;span&gt; 33&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;url&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buttonType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;isPage&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否是页面&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; PermissionAttribute(&lt;span&gt;string&lt;/span&gt; url = &lt;span&gt;default&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;), ButtonType buttonType = ButtonType.View, &lt;span&gt;bool&lt;/span&gt; isPage = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;) :
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt;             &lt;span&gt;base&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(RequiresPermissionAttributeExecutor))
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;             Arguments = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PermissionAuthorizationRequirement(url, buttonType, isPage) };
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 43&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 构造器
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;url&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;地址&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;buttonType&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮类型&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;isPage&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;是否是页面&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; PermissionAttribute(&lt;span&gt;string&lt;/span&gt; url, &lt;span&gt;byte&lt;/span&gt; buttonType, &lt;span&gt;bool&lt;/span&gt; isPage = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;) :
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;             &lt;span&gt;base&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(RequiresPermissionAttributeExecutor))
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;             Arguments = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;[] { &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PermissionAuthorizationRequirement(url, buttonType, isPage) };
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;         &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RequiresPermissionAttributeExecutor : Attribute, IAsyncResourceFilter
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt;&lt;span&gt; IPermissionStorageContainer _permissionStorage;
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;             &lt;span&gt;private&lt;/span&gt;&lt;span&gt; PermissionAuthorizationRequirement _requiredPermissions;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RequiresPermissionAttributeExecutor(
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;                IPermissionStorageContainer permissionStorage, PermissionAuthorizationRequirement requiredPermissions)
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                 _permissionStorage =&lt;span&gt; permissionStorage;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt;                 _requiredPermissions =&lt;span&gt; requiredPermissions;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt; 
&lt;span&gt; 66&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task OnResourceExecutionAsync(ResourceExecutingContext context, ResourceExecutionDelegate next)
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                 &lt;span&gt;string&lt;/span&gt; menuUrl =&lt;span&gt; _requiredPermissions.UrlAndButtonType.Url;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断用户权限&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(menuUrl))
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;区域判断&lt;/span&gt;
&lt;span&gt; 73&lt;/span&gt;                     &lt;span&gt;string&lt;/span&gt; area = context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;area&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;].ToString();
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(area))
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                         menuUrl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                         menuUrl = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + area + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;controller&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + context.RouteData.Values[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;action&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                 menuUrl =&lt;span&gt; menuUrl.Trim().ToLower();
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; dbpermission = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _permissionStorage.GetPermissionAsync();
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; menu = dbpermission.Menus.FirstOrDefault(m =&amp;gt; m.MenuUrl != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; m.MenuUrl.Trim().ToLower() ==&lt;span&gt; menuUrl);
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (menu != &lt;span&gt;null&lt;/span&gt;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地址存在&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt; (_requiredPermissions.UrlAndButtonType.ButtonType == &lt;span&gt;default&lt;/span&gt;(&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                         &lt;span&gt;await&lt;/span&gt;&lt;span&gt; next();
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                         &lt;span&gt;byte&lt;/span&gt; buttonType = (&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;)_requiredPermissions.UrlAndButtonType.ButtonType;
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (menu.MenuButton.Select(m =&amp;gt; m.ButtonType).Contains(buttonType))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拥有操作权限&lt;/span&gt;
&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; next();
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有操作权限&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_requiredPermissions.UrlAndButtonType.IsPage)
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;                                 context.Result = &lt;span&gt;new&lt;/span&gt; RedirectResult(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/error/noauth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt;                             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;                                 context.Result = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContentResult()
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;                                {
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;                                     Content =&lt;span&gt; PermissionStatusCodes.Status2Unauthorized.ToString()
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt; &lt;span&gt;                                };
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;                             &lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.Result.ExecuteResultAsync(context);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有操作权限&lt;/span&gt;
&lt;span&gt;120&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_requiredPermissions.UrlAndButtonType.IsPage)
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;                         context.Result = &lt;span&gt;new&lt;/span&gt; RedirectResult(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/error/noauth&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;125&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;                         context.Result = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContentResult()
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt;                             Content =&lt;span&gt; PermissionStatusCodes.Status2Unauthorized.ToString()
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;                        };
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt;                     &lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.Result.ExecuteResultAsync(context);
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; 
&lt;span&gt;136&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在对于的页面添加过滤器即可，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;        [HttpGet]
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        [Permission]
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; Index(&lt;span&gt;int&lt;/span&gt; pageIndex=&lt;span&gt;1&lt;/span&gt;,&lt;span&gt;int&lt;/span&gt; pageSize=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; res = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _messageService.GetPageAsync(pageIndex, pageSize);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View(res);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        [HttpGet]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         [Permission(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Sys/Message/Index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ButtonType.View)]
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Show()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; View();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 系统界面展示图：后台模板是之前从网上找的并自己简单改了一下，将就能看吧，实在不想花功夫在前端上面了@-^-@&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651757/201905/651757-20190528145752261-407766018.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651757/201905/651757-20190528145809991-790315183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651757/201905/651757-20190528145824271-1934578686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651757/201905/651757-20190528145925786-673534689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651757/201905/651757-20190528145940546-1906575940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行步骤：1、确保数据库mssystem和mssystemlog存在 github文档中&lt;/p&gt;
&lt;p&gt;　　　　　2、consul服务启动，如下回车运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651757/201905/651757-20190528154344017-1391436892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　3、VS项目启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/651757/201905/651757-20190528154549604-916436926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;管理员登录账号wms，密码：所有账号密码都是123&lt;/p&gt;
&lt;p&gt;代码地址:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wangmaosheng/MsSystem-BPM-ServiceAndWebApps&quot;&gt;https://github.com/wangmaosheng/MsSystem-BPM-ServiceAndWebApps&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果觉得有点作用的话，可以 start 下，后续会持续更新&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 07:52:00 +0000</pubDate>
<dc:creator>Jade_K</dc:creator>
<og:description>一、前言 实际上权限系统老早之前我就在一直开发，大概在刚毕业没多久就想一个人写一个系统，断断续续一直坚持到现在，毕竟自己亲动手自写的系统才有收获，本篇仅介绍权限。 小小系统上不了台面，望各位大神勿喷。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wms01/p/10903646.html</dc:identifier>
</item>
<item>
<title>BitMap与RoaringBitmap、JavaEWAH - MichaelFang</title>
<link>http://www.cnblogs.com/fonxian/p/10937882.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fonxian/p/10937882.html</guid>
<description>&lt;p&gt;本文主要介绍BitMap的算法思想，以及开源工具类JavaEWAH、RoaringBitmap的简单用法。&lt;/p&gt;
&lt;h2 id=&quot;一bitmap&quot;&gt;一、BitMap&lt;/h2&gt;
&lt;h4 id=&quot;介绍&quot;&gt;介绍&lt;/h4&gt;
&lt;p&gt;BitMap使用&lt;code&gt;bit位&lt;/code&gt;，来标记元素对应的Value。该算法能够&lt;code&gt;节省存储空间&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;假设一个场景，要存0-7以内的数字[3,5,6,1,2]，尽可能的节省空间。&lt;br/&gt;一种思路就是单纯使用数组存储，但如果数据量放大百万倍甚至千万倍呢，数组的所占用的内存会非常大。&lt;br/&gt;另一种思路是&lt;code&gt;使用BitMap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;表示[3,5,7,1,2]，我们可以用8bit的空间来存储，每个数字都在对应的位置中以1的方式表示。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;若将上述BitMap看作是存储&lt;code&gt;用户的标签&lt;/code&gt;，如&lt;code&gt;信用卡逾期&lt;/code&gt;标签，位置看成&lt;code&gt;用户ID&lt;/code&gt;，则若需要查询哪些用户有信用卡逾期的行为（标签），就非常容易查询统计了。&lt;/p&gt;
&lt;h2 id=&quot;二roaringbitmap&quot;&gt;二、RoaringBitmap&lt;/h2&gt;
&lt;h4 id=&quot;文档中怎么说&quot;&gt;文档中怎么说？&lt;/h4&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;Bitsets, also called bitmaps, are commonly used as fast data structures. Unfortunately, they can use too much memory. To compensate, we often use compressed bitmaps.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;BitMap通常被用作快速查询的数据结构，但它太占内存了。解决方案是，&lt;code&gt;对BitMap进行压缩&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Roaring bitmaps are compressed bitmaps which tend to outperform conventional compressed bitmaps such as WAH, EWAH or Concise. In some instances, roaring bitmaps can be hundreds of times faster and they often offer significantly better compression. They can even be faster than uncompressed bitmaps.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Roaring bitmaps是一种超常规的压缩BitMap。它的速度比&lt;code&gt;未压缩的BitMap&lt;/code&gt;快上百倍。&lt;/p&gt;
&lt;h4 id=&quot;简单使用&quot;&gt;简单使用&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;引入依赖&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.roaringbitmap&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;RoaringBitmap&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;0.8.1&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
@SpringBootTest
@RunWith(SpringRunner.class)
public class TestRoaringbitmap {

    @Test
    public void test(){
        
        //向rr中添加1、2、3、1000四个数字
        RoaringBitmap rr = RoaringBitmap.bitmapOf(1,2,3,1000);
        //创建RoaringBitmap rr2
        RoaringBitmap rr2 = new RoaringBitmap();
        //向rr2中添加10000-12000共2000个数字
        rr2.add(10000L,12000L);
        //返回第3个数字是1000，第0个数字是1，第1个数字是2，则第3个数字是1000
        rr.select(3); 
        //返回value = 2 时的索引为 1。value = 1 时，索引是 0 ，value=3的索引为2
        rr.rank(2); 
        //判断是否包含1000
        rr.contains(1000); // will return true
        //判断是否包含7
        rr.contains(7); // will return false
        
        //两个RoaringBitmap进行or操作，数值进行合并，合并后产生新的RoaringBitmap叫rror
        RoaringBitmap rror = RoaringBitmap.or(rr, rr2);
        //rr与rr2进行位运算，并将值赋值给rr
        rr.or(rr2); 
        //判断rror与rr是否相等，显然是相等的
        boolean equals = rror.equals(rr);
        if(!equals) throw new RuntimeException(&quot;bug&quot;);
        // 查看rr中存储了多少个值，1,2,3,1000和10000-12000，共2004个数字
        long cardinality = rr.getLongCardinality();
        System.out.println(cardinality);
        //遍历rr中的value
        for(int i : rr) {
            System.out.println(i);
        }
        //这种方式的遍历比上面的方式更快
        rr.forEach((Consumer&amp;lt;? super Integer&amp;gt;) i -&amp;gt; {
            System.out.println(i.intValue());
        });

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三javaewah&quot;&gt;三、JavaEWAH&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;引入依赖&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;
            &amp;lt;dependency&amp;gt;
                &amp;lt;groupId&amp;gt;com.googlecode.javaewah&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;JavaEWAH&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;1.1.6&amp;lt;/version&amp;gt;
            &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;测试代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
@SpringBootTest
@RunWith(SpringRunner.class)
public class TestJavaEWAH {

    @Test
    public void test(){
    
        EWAHCompressedBitmap ewahBitmap1 = EWAHCompressedBitmap.bitmapOf(0, 2, 55, 64, 1 &amp;lt;&amp;lt; 30);
        EWAHCompressedBitmap ewahBitmap2 = EWAHCompressedBitmap.bitmapOf(1, 3, 64,1 &amp;lt;&amp;lt; 30);
        //bitmap 1: {0,2,55,64,1073741824}
        System.out.println(&quot;bitmap 1: &quot; + ewahBitmap1);
        //bitmap 2: {1,3,64,1073741824}
        System.out.println(&quot;bitmap 2: &quot; + ewahBitmap2);

        //是否包含value=64，返回为true
        System.out.println(ewahBitmap1.get(64));

        //获取value的个数，个数为5
        System.out.println(ewahBitmap1.cardinality());
        
        //遍历所有value
        ewahBitmap1.forEach(integer -&amp;gt; {
            System.out.println(integer);
        });


        //进行位或运算
        EWAHCompressedBitmap orbitmap = ewahBitmap1.or(ewahBitmap2);
        //返回bitmap 1 OR bitmap 2: {0,1,2,3,55,64,1073741824}
        System.out.println(&quot;bitmap 1 OR bitmap 2: &quot; + orbitmap);
        //memory usage: 40 bytes
        System.out.println(&quot;memory usage: &quot; + orbitmap.sizeInBytes() + &quot; bytes&quot;);

        //进行位与运算
        EWAHCompressedBitmap andbitmap = ewahBitmap1.and(ewahBitmap2);
        //返回bitmap 1 AND bitmap 2: {64,1073741824}
        System.out.println(&quot;bitmap 1 AND bitmap 2: &quot; + andbitmap);
        //memory usage: 32 bytes
        System.out.println(&quot;memory usage: &quot; + andbitmap.sizeInBytes() + &quot; bytes&quot;);

        //序列化与反序列化
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ewahBitmap1.serialize(new DataOutputStream(bos));
            EWAHCompressedBitmap ewahBitmap1new = new EWAHCompressedBitmap();
            byte[] bout = bos.toByteArray();
            ewahBitmap1new.deserialize(new DataInputStream(new ByteArrayInputStream(bout)));
            System.out.println(&quot;bitmap 1 (recovered) : &quot; + ewahBitmap1new);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;[1]: &lt;a href=&quot;https://www.cnblogs.com/senlinyang/p/7885685.html&quot; target=&quot;_blank&quot;&gt;BitMap算法详解&lt;/a&gt;&lt;br/&gt;[2]: &lt;a href=&quot;https://blog.csdn.net/moakun/article/details/79927791&quot; target=&quot;_blank&quot;&gt;漫画：Bitmap算法 整合版&lt;/a&gt;&lt;br/&gt;[3]: &lt;a href=&quot;https://github.com/RoaringBitmap/RoaringBitmap&quot; target=&quot;_blank&quot;&gt;RoaringBitmap GitHub项目文档&lt;/a&gt;&lt;br/&gt;[4]: &lt;a href=&quot;https://github.com/lemire/javaewahl&quot; target=&quot;_blank&quot;&gt;JavaEWAH GitHub项目文档&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 07:51:00 +0000</pubDate>
<dc:creator>MichaelFang</dc:creator>
<og:description>本文主要介绍BitMap的算法思想，以及开源工具类JavaEWAH、RoaringBitmap的简单用法。 一、BitMap 介绍 BitMap使用 ，来标记元素对应的Value。该算法能够 。 假设</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fonxian/p/10937882.html</dc:identifier>
</item>
<item>
<title>逻辑回归 - Harvard_Fly</title>
<link>http://www.cnblogs.com/FG123/p/10787776.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FG123/p/10787776.html</guid>
<description>&lt;p&gt;&lt;span&gt;逻辑回归是一种分类算法，虽然名字中带有回归。但是它与回归之间有一定的联系。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;逻辑回归的原理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;输入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201905/739231-20190528094349247-417833499.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;逻辑回归的输入就是一个线性回归的结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;sigmoid函数（激活函数）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201905/739231-20190528094432906-1922294050.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;回归的结果输入到sigmoid函数当中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;输出结果：[0, 1]区间中的一个概率值，默认为0.5为阈值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;逻辑回归最终的分类是通过属于某个类别的概率值来判断是否属于某个类别，并且这个类别默认标记为1(正例),另外的一个类别会标记为0(反例)。（方便损失计算）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设有两个类别A，B，并且假设我们的概率值为属于A(1)这个类别的概率值。现在有一个样本的输入到逻辑回归输出结果0.6，那么这个概率值超过0.5，意味着我们训练或者预测的结果就是A(1)类别。那么反之，如果得出结果为0.3那么，训练或者预测结果就为B(0)类别。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;衡量逻辑回归的预测结果与真实结果的差异衡量逻辑回归的预测结果与真实结果的差异&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;损失，称之为对数似然损失，公式如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201905/739231-20190528093435985-352300002.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当y=1时：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201905/739231-20190528093552390-168845900.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完整损失函数： &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201905/739231-20190528093720461-350036180.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用梯度下降优化算法，可以减少损失函数的值。更新逻辑回归前面对应算法的权重参数，提升原本属于1类别的概率，降低原本是0类别的概率。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;逻辑回归在sklearn中的API&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sklearn.linear_model.LogisticRegression(solver='liblinear', penalty=‘l2’, C = 1.0)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;solver:优化求解方式（默认开源的liblinear库实现，内部使用了坐标轴下降法来迭代优化损失函数）&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sag：根据数据集自动选择，随机平均梯度下降&lt;/span&gt;&lt;br/&gt;&lt;span&gt;penalty：正则化的种类&lt;/span&gt;&lt;br/&gt;&lt;span&gt;C：正则化力度&lt;/span&gt;&lt;br/&gt;&lt;span&gt;默认将类别数量少的当做正例&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;示例：癌症分类预测&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据集来源：&lt;a href=&quot;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/&quot; target=&quot;_blank&quot;&gt;breast-cancer-wisconsin&lt;/a&gt; :&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201905/739231-20190528113432687-614482851.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据描述：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;699条样本，共11列数据，第一列用于检索的id，后9列分别是与肿瘤相关的医学特征，最后一列表示肿瘤类型的数值；包含16个缺失值，用”?”标出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完整代码实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;57&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LogisticRegression


def logisticregression():
    &quot;&quot;&quot;
    逻辑回归进行癌症预测
    :return: None
    &quot;&quot;&quot;
    # 1、读取数据，处理缺失值以及标准化
    column_name = ['Sample code number', 'Clump Thickness', 'Uniformity of Cell Size', 'Uniformity of Cell Shape',
                   'Marginal Adhesion', 'Single Epithelial Cell Size', 'Bare Nuclei', 'Bland Chromatin',
                   'Normal Nucleoli', 'Mitoses', 'Class']

    data = pd.read_csv(
        &quot;https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data&quot;,
        names=column_name
    )

    # 删除缺失值
    data = data.replace(to_replace='?', value=np.nan)
    data = data.dropna()

    # 取出特征值
    x = data[column_name[1:10]]
    y = data[column_name[10]]

    # 分割数据集
    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)

    # 进行标准化
    std = StandardScaler()
    x_train = std.fit_transform(x_train)
    x_test = std.transform(x_test)

    # 使用逻辑回归
    lr = LogisticRegression()
    lr.fit(x_train, y_train)

    print(&quot;得出来的权重：&quot;, lr.coef_)

    # 预测类别
    print(&quot;预测的类别：&quot;, lr.predict(x_test))

    # 得出准确率
    print(&quot;预测的准确率:&quot;, lr.score(x_test, y_test))
    return None


logisticregression()
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;预测结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201905/739231-20190528113833377-290909280.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;分类评估报告&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sklearn.metrics.classification_report(y_true, y_pred, labels=[], target_names=None )&lt;/span&gt;&lt;br/&gt;&lt;span&gt;y_true：真实目标值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;y_pred：估计器预测目标值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;labels:指定类别对应的数字&lt;/span&gt;&lt;br/&gt;&lt;span&gt;target_names：目标类别名称&lt;/span&gt;&lt;br/&gt;&lt;span&gt;return：每个类别精确率与召回率&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;print(&quot;精确率和召回率为：&quot;, classification_report(y_test, lr.predict(x_test), labels=[2, 4], target_names=['良性', '恶性']))
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;评估报告结果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201905/739231-20190528153347728-768836863.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/739231/201905/739231-20190528153347728-768836863.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;



&lt;p&gt;&lt;span&gt;衡量样本不均衡下的评估---AUC指标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AUC的概率意义是随机取一对正负样本，正样本得分大于负样本的概率&lt;/span&gt;&lt;br/&gt;&lt;span&gt;AUC的最小值为0.5，最大值为1，取值越高越好&lt;/span&gt;&lt;br/&gt;&lt;span&gt;AUC=1，完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。绝大多数预测的场合，不存在完美分类器。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;0.5&amp;lt;AUC&amp;lt;1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;AUC=0.5，跟随机猜测一样（例：丢铜板），模型没有预测价值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;AUC&amp;lt;0.5，比随机猜测还差；但只要总是反预测而行，就优于随机猜测，因此不存在 AUC&amp;lt;0.5 的情况。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;最终AUC的范围在[0.5, 1]之间，并且越接近1越好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;AUC计算API&lt;/span&gt;&lt;br/&gt;&lt;span&gt;from sklearn.metrics import roc_auc_score&lt;/span&gt;&lt;br/&gt;&lt;span&gt;sklearn.metrics.roc_auc_score(y_true, y_score)&lt;/span&gt;&lt;br/&gt;&lt;span&gt;计算ROC曲线面积，即AUC值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;y_true:每个样本的真实类别，必须为0(反例),1(正例)标记&lt;/span&gt;&lt;br/&gt;&lt;span&gt;y_score:每个样本预测的概率值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;# 0.5~1之间，越接近于1约好&lt;/span&gt;&lt;br/&gt;&lt;span&gt;y_test = np.where(y_test &amp;gt; 2.5, 1, 0)&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
&lt;span&gt;print(&quot;AUC指标：&quot;, roc_auc_score(y_test, lr.predict(x_test)))
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; AUC指标： 0.959063378758382&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 07:41:00 +0000</pubDate>
<dc:creator>Harvard_Fly</dc:creator>
<og:description>逻辑回归是一种分类算法，虽然名字中带有回归。但是它与回归之间有一定的联系。 逻辑回归的原理： 输入 逻辑回归的输入就是一个线性回归的结果 sigmoid函数（激活函数） 回归的结果输入到sigmoid</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FG123/p/10787776.html</dc:identifier>
</item>
<item>
<title>聚类kmeans算法在yolov3中的应用 - sdu20112013</title>
<link>http://www.cnblogs.com/sdu20112013/p/10937717.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdu20112013/p/10937717.html</guid>
<description>&lt;h3 id=&quot;yolov3-kmeans&quot;&gt;yolov3 kmeans&lt;/h3&gt;
&lt;p&gt;yolov3在做boundingbox预测的时候,用到了anchor boxes.这个anchors的含义即最有可能的object的width,height.事先通过聚类得到.比如某一个像素单元,我想对这个像素单元预测出一个object,围绕这个像素单元,可以预测出无数种object的形状,并不是随便预测的,要参考anchor box的大小,即从已标注的数据中通过聚类统计到的最有可能的object的形状.&lt;/p&gt;
&lt;p&gt;.cfg文件内的配置如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[yolo]
mask = 3,4,5
anchors = 10,14,  23,27,  37,58,  81,82,  135,169,  344,319&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在用我们自己的数据做训练的时候,要先修改anchors,匹配我们自己的数据.anchors大小通过聚类得到.&lt;/p&gt;
&lt;p&gt;通俗地说,聚类就是把挨得近的数据点划分到一起.&lt;br/&gt;kmeans算法的思想很简单&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;随便指定k个cluster&lt;/li&gt;
&lt;li&gt;把点划分到与之最近的一个cluster&lt;/li&gt;
&lt;li&gt;上面得到的cluster肯定是不好的,因为一开始的cluster是乱选的嘛&lt;/li&gt;
&lt;li&gt;更新每个cluster为当前cluster的点的均值.&lt;br/&gt;这时候cluster肯定变准了,为什么呢?比如当前这个cluster里有3个点,2个点靠的很近,还有1个点离得稍微远点,那取均值的话,那相当于靠的很近的2个点有更多投票权,新算出来的cluster的中心会更加靠近这两个点.你要是非要抬杠:那万一一开始我随机指定的cluster中心点就特别准呢,重新取均值反而把中心点弄的不准了?事实上这是kmeans的一个缺陷:比较依赖初始的k个cluster的位置.选择不恰当的k值可能会导致糟糕的聚类结果。这也是为什么要进行特征检查来决定数据集的聚类数目了。&lt;/li&gt;
&lt;li&gt;重新执行上述过程
&lt;ul&gt;&lt;li&gt;把点划分到与之最近的一个cluster&lt;/li&gt;
&lt;li&gt;更新每个cluster为当前cluster的点的均值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;不断重复上述过程,直至cluster中心变化很小&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;yolov3要求的label文件格式&quot;&gt;yolov3要求的label文件格式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;object-class&amp;gt; &amp;lt;x_center&amp;gt; &amp;lt;y_center&amp;gt; &amp;lt;width&amp;gt; &amp;lt;height&amp;gt;
Where:
&amp;lt;object-class&amp;gt; - integer object number from 0 to (classes-1)
&amp;lt;x_center&amp;gt; &amp;lt;y_center&amp;gt; &amp;lt;width&amp;gt; &amp;lt;height&amp;gt; - float values relative to width and height of image, it can be equal from (0.0 to 1.0]
&amp;gt; for example: &amp;lt;x&amp;gt; = &amp;lt;absolute_x&amp;gt; / &amp;lt;image_width&amp;gt; or &amp;lt;height&amp;gt; = &amp;lt;absolute_height&amp;gt; / &amp;lt;image_height&amp;gt;
atention: &amp;lt;x_center&amp;gt; &amp;lt;y_center&amp;gt; - are center of rectangle (are not top-left corner)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举例:&lt;br/&gt;1 0.716797 0.395833 0.216406 0.147222&lt;br/&gt;所有的值都是比例.(中心点x,中心点y,目标宽,目标高)&lt;/p&gt;
&lt;h3 id=&quot;kmeans实现&quot;&gt;kmeans实现&lt;/h3&gt;
&lt;p&gt;一般来说,计算样本点到质心的距离的时候直接算的是两点之间的距离,然后将样本点划归为与之距离最近的一个质心.&lt;br/&gt;在yolov3中样本点的数据是有具体的业务上的含义的,我们其实最终目的是想知道最有可能的object对应的bounding box的形状是什么样子的. 所以这个距离的计算我们并不是直接算两点之间的距离,我们计算两个box的iou,即2个box的相似程度.d=1-iou(box1,box_cluster). 这样d越小,说明box1与box_cluster越类似.将box划归为box_cluster.&lt;/p&gt;
&lt;h4 id=&quot;数据加载&quot;&gt;数据加载&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;    f = open(args.filelist)
  
    lines = [line.rstrip('\n') for line in f.readlines()]
    
    annotation_dims = []

    size = np.zeros((1,1,3))
    for line in lines:
                    
        #line = line.replace('images','labels')
        #line = line.replace('img1','labels')
        line = line.replace('JPEGImages','labels')        
        

        line = line.replace('.jpg','.txt')
        line = line.replace('.png','.txt')
        print(line)
        f2 = open(line)
        for line in f2.readlines():
            line = line.rstrip('\n')
            w,h = line.split(' ')[3:]            
            #print(w,h)
            annotation_dims.append(tuple(map(float,(w,h))))
    annotation_dims = np.array(annotation_dims)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看着一大段,其实重点就一句&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;w,h = line.split(' ')[3:]            
annotation_dims.append(tuple(map(float,(w,h))))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里涉及到了python的语法,map用法https://www.runoob.com/python/python-func-map.html&lt;br/&gt;这样就生成了一个N*2矩阵. N代表你的样本个数.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义样本点到质心点的距离&lt;br/&gt;计算样本x代表的box和k个质心box的IOU.(即比较box之间的形状相似程度).&lt;br/&gt;这里涉及到一个IOU的概念:即交并集比例.交叉面积/总面积.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;def IOU(x,centroids):
    similarities = []
    k = len(centroids)
    for centroid in centroids:
        c_w,c_h = centroid
        w,h = x
        if c_w&amp;gt;=w and c_h&amp;gt;=h:     #box(c_w,c_h)完全包含box(w,h)
            similarity = w*h/(c_w*c_h)
        elif c_w&amp;gt;=w and c_h&amp;lt;=h:   #box(c_w,c_h)宽而扁平
            similarity = w*c_h/(w*h + (c_w-w)*c_h)
        elif c_w&amp;lt;=w and c_h&amp;gt;=h:
            similarity = c_w*h/(w*h + c_w*(c_h-h))
        else: #means both w,h are bigger than c_w and c_h respectively
            similarity = (c_w*c_h)/(w*h)
        similarities.append(similarity) # will become (k,) shape
    return np.array(similarities) &lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;kmeans实现-1&quot;&gt;kmeans实现&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;def kmeans(X,centroids,eps,anchor_file):
    
    N = X.shape[0]
    iterations = 0
    k,dim = centroids.shape
    prev_assignments = np.ones(N)*(-1)    
    iter = 0
    old_D = np.zeros((N,k)) #距离矩阵  N个点,每个点到k个质心 共计N*K个距离

    while True:
        D = [] 
        iter+=1           
        for i in range(N):
            d = 1 - IOU(X[i],centroids)  #d是一个k维的   
            D.append(d)   
        D = np.array(D) # D.shape = (N,k)
        
        print(&quot;iter {}: dists = {}&quot;.format(iter,np.sum(np.abs(old_D-D))))
            
        #assign samples to centroids 
        assignments = np.argmin(D,axis=1) #返回每一行的最小值的下标.即当前样本应该归为k个质心中的哪一个质心.
        
        if (assignments == prev_assignments).all() :  #质心已经不再变化
            print(&quot;Centroids = &quot;,centroids)
            write_anchors_to_file(centroids,X,anchor_file)
            return

        #calculate new centroids   
        centroid_sums=np.zeros((k,dim),np.float)  #(k,2)
        for i in range(N):
            centroid_sums[assignments[i]]+=X[i]        #将每一个样本划分到对应质心
        for j in range(k):            
            centroids[j] = centroid_sums[j]/(np.sum(assignments==j)) #更新质心
        
        prev_assignments = assignments.copy()     
        old_D = D.copy()  &lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;计算每个样本点到每一个cluster质心的距离 d = 1- IOU(X[i],centroids)表示样本点到每个cluster质心的距离.&lt;/li&gt;
&lt;li&gt;np.argmin(D,axis=1)得到每一个样本点离哪个cluster质心最近&lt;br/&gt;argmin函数用法参考https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmin.html&lt;/li&gt;
&lt;li&gt;计算每一个cluster中的样本点总和,取平均,更新cluster质心.&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;for i in range(N):
    centroid_sums[assignments[i]]+=X[i]        #将每一个样本划分到对应质心
for j in range(k):            
    centroids[j] = centroid_sums[j]/(np.sum(assignments==j)) #更新质心
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不断重复上述过程,直到质心不再变化 聚类完成.&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;保存聚类得到的anchor-box大小&quot;&gt;保存聚类得到的anchor box大小&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;def write_anchors_to_file(centroids,X,anchor_file):
    f = open(anchor_file,'w')
    
    anchors = centroids.copy()
    print(anchors.shape)

    for i in range(anchors.shape[0]):
        anchors[i][0]*=width_in_cfg_file/32.
        anchors[i][1]*=height_in_cfg_file/32.
         

    widths = anchors[:,0]
    sorted_indices = np.argsort(widths)

    print('Anchors = ', anchors[sorted_indices])
        
    for i in sorted_indices[:-1]:
        f.write('%0.2f,%0.2f, '%(anchors[i,0],anchors[i,1]))

    #there should not be comma after last anchor, that's why
    f.write('%0.2f,%0.2f\n'%(anchors[sorted_indices[-1:],0],anchors[sorted_indices[-1:],1]))
    
    f.write('%f\n'%(avg_IOU(X,centroids)))
    print()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于yolo要求的label文件中,填写的是相对于width,height的比例.所以得到的anchor box的大小要乘以模型输入图片的尺寸.&lt;br/&gt;上述代码里&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        anchors[i][0]*=width_in_cfg_file/32.
        anchors[i][1]*=height_in_cfg_file/32.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里除以32是yolov2的算法要求. yolov3实际上不需要.参见以下链接https://github.com/pjreddie/darknet/issues/911&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;for Yolo v2: width=704 height=576 in cfg-file&lt;br/&gt;./darknet detector calc_anchors data/hand.data -num_of_clusters 5 -width 22 -height 18 -show&lt;br/&gt;for Yolo v3: width=704 height=576 in cfg-file&lt;br/&gt;./darknet detector calc_anchors data/hand.data -num_of_clusters 9 -width 704 -height 576 -show&lt;br/&gt;And you can use any images with any sizes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;完整代码见https://github.com/AlexeyAB/darknet/tree/master/scripts&lt;br/&gt;用法:python3 gen_anchors.py -filelist ../build/darknet/x64/data/park_train.txt&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 07:39:00 +0000</pubDate>
<dc:creator>sdu20112013</dc:creator>
<og:description>yolov3 kmeans yolov3在做boundingbox预测的时候,用到了anchor boxes.这个anchors的含义即最有可能的object的width,height.事先通过聚类得</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdu20112013/p/10937717.html</dc:identifier>
</item>
<item>
<title>基于ASP.Net Core开发一套通用后台框架记录-(数据库设计(权限模块)) - 果冻栋吖</title>
<link>http://www.cnblogs.com/jellydong/p/10937619.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jellydong/p/10937619.html</guid>
<description>&lt;h3 id=&quot;写在前面&quot;&gt;写在前面&lt;/h3&gt;
&lt;p&gt;本系列博客是本人在学习的过程中搭建学习的记录，如果对你有所帮助那再好不过。如果您有发现错误，请告知我，我会第一时间修改。&lt;br/&gt;前期我不会公开源码，我想是一点点敲代码，不然&lt;code&gt;复制&lt;/code&gt;、&lt;code&gt;粘贴&lt;/code&gt;那就没意思了。而且很多代码(比如&lt;code&gt;Identity Server4&lt;/code&gt;)网上也有很多类似的教程及成熟的框架。这里只是想，知其然，知其所以然，并非重复的造轮子。因为这段时间我发现，自己闷很久写出来的代码，再去看看别人的，会有种恍然大悟的感觉。不是只会用，不知道为什么要这样用。&lt;br/&gt;真的，只看不敲，总是学不会。&lt;/p&gt;
&lt;blockquote readability=&quot;4.8545454545455&quot;&gt;
&lt;p&gt;Demo地址：&lt;a href=&quot;http://app.guoddy.com&quot; class=&quot;uri&quot;&gt;http://app.guoddy.com&lt;/a&gt;&lt;br/&gt;数据并不会真实保存，设定的为测试模式，所以免登录。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;本系列文章是计划做一个通用权限处理系统可以在此基础上去做拓展性开发其实本计划是继续增加流程管理和及时通讯的em...这个后续慢慢增加流程表单及设计还没研究透&quot;&gt;本系列文章是计划做一个通用权限处理系统，可以在此基础上去做拓展性开发&lt;code&gt;其实本计划是继续增加流程管理和及时通讯的,em...这个后续慢慢增加，流程表单及设计还没研究透&lt;/code&gt;。&lt;/h4&gt;
&lt;h3 id=&quot;记录内容&quot;&gt;记录内容&lt;/h3&gt;
&lt;blockquote readability=&quot;3.9310344827586&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/jellydong/p/10937469.html&quot;&gt;总述&lt;/a&gt;&lt;br/&gt;1.&lt;a href=&quot;https://www.cnblogs.com/jellydong/p/10937562.html&quot;&gt;项目的搭建&lt;/a&gt;&lt;br/&gt;2.&lt;a href=&quot;https://www.cnblogs.com/jellydong/p/10937619.html&quot;&gt;数据库设计(权限模块)&lt;/a&gt;&lt;br/&gt;3.EF的使用&lt;br/&gt;4.业务代码的实现&lt;br/&gt;5.依赖注入&lt;br/&gt;6.权限验证&lt;br/&gt;7.做个登录验证&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;数据库设计权限模块&quot;&gt;数据库设计(权限模块)&lt;/h2&gt;
&lt;p&gt;我先说下我参考的资料，后续是在自己理解的基础上做些修改。&lt;br/&gt;原文是参考&lt;a href=&quot;https://www.cnblogs.com/yukaizhao/archive/2007/04/15/user_role_action_permission.html&quot;&gt;应用程序权限设计&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;需求&quot;&gt;需求&lt;/h3&gt;
&lt;p&gt;需求不同，权限的控制粒度就不同。通常情况下分为三种情况&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;1.控制当前登录用户能够看到的菜单。&lt;br/&gt;2.控制当前登录用户能够看到的菜单，还要控制菜单下的操作按钮。&lt;br/&gt;3.数据和数据列权限：数据权限指普通用户只能看到自己发表的内容，而领导可以看到部门下所有用户发表的内容;数据列权限指比如金融系统 ，只有某种领导，才能看到用户的存款余额，而普通员工是无权限查看的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;我们要实现的是控制到按钮的粒度&quot;&gt;我们要实现的是控制到按钮的粒度。&lt;/h4&gt;
&lt;h3 id=&quot;权限设计why&quot;&gt;权限设计&amp;amp;Why&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1006210/201905/1006210-20190528151533634-274007299.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我这里主要涉及七个表，四个数据表，三个关联表。&lt;br/&gt;为什么这样设计，我觉得可能这是大多数系统的需求。&lt;br/&gt;1.用户和角色多对多，一个用户可以拥有多个角色，不然设计角色就没有了意义，实际可能一个人身兼数职。&lt;br/&gt;2.可以直接给用户授予或取消授予某个权限。这个可能会有人觉得没必要，所以如果不涉及这个，那就是五个表。但是我这里保留，因为很多情况下，这是很正常的需求。&lt;br/&gt;3.菜单可以无限级别，根据实际需求，修改系统配置参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;详细说明&quot;&gt;详细说明&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ObjectID&lt;/code&gt;、&lt;code&gt;Remark&lt;/code&gt;、&lt;code&gt;Status&lt;/code&gt;、&lt;code&gt;CreatedBy&lt;/code&gt;、&lt;code&gt;CreatedTime&lt;/code&gt;、&lt;code&gt;ModifiedBy&lt;/code&gt;、&lt;code&gt;ModifiedTime&lt;/code&gt;、&lt;code&gt;Sort&lt;/code&gt;是默认字段。&lt;/p&gt;
&lt;h5 id=&quot;sysuserinfo用户表&quot;&gt;SysUserInfo用户表&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;如果用户数据量大的话，实际这个表只需要保留&lt;code&gt;ObjectID&lt;/code&gt;、&lt;code&gt;ULoginName&lt;/code&gt;、&lt;code&gt;ULoginPWD&lt;/code&gt;就可以了，这样可以提高速度，没必要把所有信息都保存起来。&lt;/li&gt;
&lt;li&gt;用户和角色多对多 R_sysUserInfo_sysRole&lt;/li&gt;
&lt;li&gt;用户和权限项多对多(直接授权或禁止) R_UserPermissions&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ObjectID&lt;/td&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ULoginName&lt;/td&gt;
&lt;td&gt;用户名&lt;/td&gt;
&lt;td&gt;nvarchar(20)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ULoginPWD&lt;/td&gt;
&lt;td&gt;密码&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;URealName&lt;/td&gt;
&lt;td&gt;真实姓名&lt;/td&gt;
&lt;td&gt;nvarchar(10)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;UTelphone&lt;/td&gt;
&lt;td&gt;电话&lt;/td&gt;
&lt;td&gt;nvarchar(20)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;UMobile&lt;/td&gt;
&lt;td&gt;手机号&lt;/td&gt;
&lt;td&gt;nvarchar(11)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;UEmail&lt;/td&gt;
&lt;td&gt;Email&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;UQQ&lt;/td&gt;
&lt;td&gt;QQ&lt;/td&gt;
&lt;td&gt;nvarchar(20)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;UGender&lt;/td&gt;
&lt;td&gt;性别:0-女;1-男;2-保密&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;UDepID&lt;/td&gt;
&lt;td&gt;所属部门&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Remark&lt;/td&gt;
&lt;td&gt;备注&lt;/td&gt;
&lt;td&gt;nvarchar(500)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;状态:0-启用;1-禁用&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;CreatedBy&lt;/td&gt;
&lt;td&gt;创建人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;CreatedTime&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ModifiedBy&lt;/td&gt;
&lt;td&gt;修改人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ModifiedTime&lt;/td&gt;
&lt;td&gt;修改时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Sort&lt;/td&gt;
&lt;td&gt;排序值&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;sysrole角色表&quot;&gt;SysRole角色表&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;对角色的分类，比如管理员、普通用户等。&lt;/li&gt;
&lt;li&gt;角色用户多对多 R_sysUserInfo_sysRole&lt;/li&gt;
&lt;li&gt;角色权限多对多 R_RolePermission&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ObjectID&lt;/td&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;RName&lt;/td&gt;
&lt;td&gt;角色名称&lt;/td&gt;
&lt;td&gt;varchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Remark&lt;/td&gt;
&lt;td&gt;备注&lt;/td&gt;
&lt;td&gt;nvarchar(500)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;状态:0-启用;1-禁用&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;CreatedBy&lt;/td&gt;
&lt;td&gt;创建人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;CreatedTime&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ModifiedBy&lt;/td&gt;
&lt;td&gt;修改人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ModifiedTime&lt;/td&gt;
&lt;td&gt;修改时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Sort&lt;/td&gt;
&lt;td&gt;排序值&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;菜单表 是一开始设计好后，改动最多的一个表。后续在开发过程中增加了&lt;code&gt;IsLast&lt;/code&gt;、&lt;code&gt;Hierarchy&lt;/code&gt;;去除了&lt;code&gt;MAction&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;IsLast用来标记是不是最后一级，如果是最后一级我们给自动增加增删改等默认方法。&lt;/li&gt;
&lt;li&gt;Hierarchy用来标记层级，前面我们说可以做到无限极，但是通常情况下会是三级，所以这个需要根据实际设定系统参数，维护的时候检查限制即可。&lt;/li&gt;
&lt;li&gt;菜单角色多对多 R_RolePermission&lt;/li&gt;
&lt;li&gt;菜单权限项一对多&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ObjectID&lt;/td&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;MName&lt;/td&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;nvarchar(100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;MUrl&lt;/td&gt;
&lt;td&gt;URL&lt;/td&gt;
&lt;td&gt;nvarchar(100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;MArea&lt;/td&gt;
&lt;td&gt;区域&lt;/td&gt;
&lt;td&gt;nvarchar(100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;MController&lt;/td&gt;
&lt;td&gt;控制器&lt;/td&gt;
&lt;td&gt;nvarchar(100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;MIcon&lt;/td&gt;
&lt;td&gt;图标&lt;/td&gt;
&lt;td&gt;nvarchar(100)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;IsLast&lt;/td&gt;
&lt;td&gt;是不是最后一级菜单:0-是;1-否&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Remark&lt;/td&gt;
&lt;td&gt;备注&lt;/td&gt;
&lt;td&gt;nvarchar(500)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ParentID&lt;/td&gt;
&lt;td&gt;父ID&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;状态:0-启用;1-禁用&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Hierarchy&lt;/td&gt;
&lt;td&gt;层级&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;CreatedBy&lt;/td&gt;
&lt;td&gt;创建人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;CreatedTime&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ModifiedBy&lt;/td&gt;
&lt;td&gt;修改人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ModifiedTime&lt;/td&gt;
&lt;td&gt;修改时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Sort&lt;/td&gt;
&lt;td&gt;排序值&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;sysfunction-菜单按钮表-菜单权限项表&quot;&gt;SysFunction &lt;s&gt;&lt;em&gt;菜单按钮表&lt;/em&gt;&lt;/s&gt; (菜单权限项表)&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;SysFunction一开始我是叫菜单按钮表的，我计划是查询、新增编辑删除、其他权限这样控制，但后来发现这样不好，所以全都分开，每个方法都要记录。当然为了方便，通用的方法，在增加菜单的时候会自动添加上。&lt;/li&gt;
&lt;li&gt;菜单权限项菜单是多对一关系&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ObjectID&lt;/td&gt;
&lt;td&gt;主键&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td&gt;TRUE&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;FName&lt;/td&gt;
&lt;td&gt;名称&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;FFunction&lt;/td&gt;
&lt;td&gt;方法&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;FIcon&lt;/td&gt;
&lt;td&gt;图标&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ParentID&lt;/td&gt;
&lt;td&gt;所属菜单&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Remark&lt;/td&gt;
&lt;td&gt;备注&lt;/td&gt;
&lt;td&gt;nvarchar(500)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;Status&lt;/td&gt;
&lt;td&gt;状态:0-启用;1-禁用&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;CreatedBy&lt;/td&gt;
&lt;td&gt;创建人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;CreatedTime&lt;/td&gt;
&lt;td&gt;创建时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ModifiedBy&lt;/td&gt;
&lt;td&gt;修改人&lt;/td&gt;
&lt;td&gt;nvarchar(50)&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;ModifiedTime&lt;/td&gt;
&lt;td&gt;修改时间&lt;/td&gt;
&lt;td&gt;datetime&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;Sort&lt;/td&gt;
&lt;td&gt;排序值&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h5 id=&quot;r_sysuserinfo_sysrole用户和角色关联表记录用户和角色的对应关系&quot;&gt;R_sysUserInfo_sysRole用户和角色关联表，记录用户和角色的对应关系。&lt;/h5&gt;
&lt;h5 id=&quot;r_rolepermission-角色菜单权限项关联表&quot;&gt;R_RolePermission 角色菜单权限项关联表。&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;比如一个角色有用某菜单下的查询和删除权限，那么这个表应该是具有两条记录的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;r_userpermissions-用户菜单权限项关联表&quot;&gt;R_UserPermissions 用户菜单权限项关联表。&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;HavePermission&lt;/code&gt;记录该用户是 是否有权限:0-无权限;1-有权限&lt;br/&gt;后续处理的时候，要从获取的权限记录中排除直接无权限的记录，增加有权限的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;其实网上很多关于权限的文章，之前自己再看的时候，总是觉得迷迷糊糊，所以最后打算自己动手做。到做完的时候，才有所理解。我也不知道我这里叙述的是不是不清楚或者设计的是否合理，如果您觉得有问题，请告知我，我会立即改正！&lt;br/&gt;切勿眼高手低，动手敲，像Power Design我也是第一次用，也是第一次用MarkDown写博客。&lt;br/&gt;【如果帮助到你了，俺想要个推荐，嘻嘻】&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 07:37:00 +0000</pubDate>
<dc:creator>果冻栋吖</dc:creator>
<og:description>本系列博客是本人在学习的过程中搭建学习的记录，如果对你有所帮助那再好不过。如果您有发现错误，请告知我，我会第一时间修改。 前期我不会公开源码，我想是一点点敲代码，不然`复制`、`粘贴`那就没意思了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jellydong/p/10937619.html</dc:identifier>
</item>
<item>
<title>shell高级-----创建函数 - 秦广王</title>
<link>http://www.cnblogs.com/jinyuanliu/p/10913821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinyuanliu/p/10913821.html</guid>
<description>&lt;h2&gt;基本脚本函数&lt;/h2&gt;
&lt;h4&gt;1、创建函数&lt;/h4&gt;
&lt;p&gt;有两种格式可以用来在bash shell脚本中创建函数。&lt;br/&gt;第一种采用关键字function。后跟分配给该代码的函数名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    function name {
     commands
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; name属性定义了赋予函数唯一的名称。脚本中定义的每个函数都必须有一个唯一的名称。&lt;br/&gt;commands是构成函数的一条或多条bash shell命令。在调用该函数时，bash shell会按命令在函数中出现的顺序依次执行，就像在普通脚本中一样。&lt;/p&gt;
&lt;p&gt;在bash shell脚本中定义函数的第二种格式更接近于其他编程语言中定义函数的方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    name（）{
    conmmands
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 函数名后的空括号表明正在定义的是一个函数。这种格式的命名规则和之前定义shell脚本函数的格式一样。&lt;/p&gt;
&lt;h4&gt;2、使用函数&lt;/h4&gt;
&lt;p&gt;要在脚本中使用函数，只需要向其他shell命令一样，在行中指定函数名就行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more ceshi.sh 
#!/bin/bash
function func1 {
   echo &quot;hello everyone!&quot;
}
count=1
while [ $count -le 5 ]
do
 func1
 count=$[ $count + 1 ]
done
[root@node1 ljy]# sh ceshi.sh 
hello everyone!
hello everyone!
hello everyone!
hello everyone!
hello everyone!
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;返回值&lt;/h2&gt;
&lt;p&gt;有3种不同的方法来为函数生成退出状态码。&lt;/p&gt;
&lt;h4&gt;1、默认退出状态码&lt;/h4&gt;
&lt;p&gt;默认情况下，函数的退出状态码是函数中最后一条命令返回的退出状态码。&lt;/p&gt;
&lt;p&gt;如果之前命令有失败，但是最后一条命令是成功的，该函数的退出状态码也是0，所以使用默认退出状态码是很危险的。&lt;/p&gt;
&lt;h4&gt;2、使用return命令&lt;/h4&gt;
&lt;p&gt;return命令允许指定一个整数值来定义函数的退出状态码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more ceshi.sh 
#!/bin/bash
function db1 {
   read -p &quot;enter your value:&quot; value
   echo &quot;doubling the value&quot;
   return $[ $value * 2 ]
}
db1
echo &quot;the new value is $?&quot;
[root@node1 ljy]# sh ceshi.sh 
enter your value:3
doubling the value
the new value is 6
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果使用这种方式来获取返回码，需要注意&lt;/p&gt;
&lt;p&gt;（1）函数一结束就取返回值。&lt;/p&gt;
&lt;p&gt;（2）退出状态码必须是0~255&lt;/p&gt;
&lt;h4&gt;3、使用函数输出&lt;/h4&gt;
&lt;p&gt;可以将函数的结果输出保存在变量中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more ceshi.sh 
#!/bin/bash
function db1 {
   read -p &quot;enter your value:&quot; value
   echo $[ $value * 2 ]
}
result=$(db1)
echo &quot;the new value is $result&quot;
[root@node1 ljy]# sh ceshi.sh 
enter your value:2
the new value is 4
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;在函数中使用变量&lt;/h2&gt;
&lt;h4&gt;像函数传递参数&lt;/h4&gt;
&lt;p&gt;函数可以使用标准的参数环境变量来表示命令行上传给函数的参数。&lt;/p&gt;
&lt;p&gt;在脚本中指定函数时，必须将函数和参数放在同一行：funcl $valu1 10&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more ceshi.sh 
#!/bin/bash
function addem {
   if [ $# -eq 0 ] || [ $# -gt 2 ]
   then 
      echo &quot;-1&quot;
   elif [ $# -eq 1 ]
   then
      echo $[ $1 + $1 ]
   else
      echo $[ $1 + $2 ]
   fi
}
echo -n &quot;adding 10 and 5:  &quot;
value=$(addem 10 5)
echo $value
[root@node1 ljy]# sh ceshi.sh 
adding 10 and 5:  15
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以这么玩&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more ceshi.sh 
#!/bin/bash
function addem {
   if [ $# -eq 0 ] || [ $# -gt 2 ]
   then 
      echo &quot;-1&quot;
   elif [ $# -eq 1 ]
   then
      echo $[ $1 + $1 ]
   else
      echo $[ $1 + $2 ]
   fi
}
echo -n &quot;the result is:  &quot;
value=$(addem $1 $2)
echo $value
[root@node1 ljy]# sh ceshi.sh 1 2
the result is:  3
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;在函数中处理变量&lt;/h4&gt;
&lt;p&gt;函数使用两种类型的变量，全局变量和局部变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、全局变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，你在脚本中定义的任何变量都是全局变量。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more ceshi.sh 
#!/bin/bash
function func1 {
   temp=$[ $value + 5 ]
   value=$[ $temp + 1 ]

}
temp=2
value=3

func1

echo -n &quot;temp is :  &quot;
echo $temp
echo -n &quot;value is : &quot;
echo $value
[root@node1 ljy]# sh ceshi.sh 
temp is :  8
value is : 9
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;temp的数据就受到了影响。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、局部变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;local 关键字保证了变量只局限在该函数中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more ceshi.sh 
#!/bin/bash
function func1 {
   local temp=$[ $value + 5 ]
   value=$[ $temp + 1 ]

}
temp=2
value=3

func1

echo -n &quot;temp is :  &quot;
echo $temp
echo -n &quot;value is : &quot;
echo $value
[root@node1 ljy]# sh ceshi.sh 
temp is :  2
value is : 9
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;函数递归&lt;/h2&gt;
&lt;p&gt;函数可以调用自己来得到结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more ceshi.sh 
#!/bin/bash
function func1 {
   if [ $1 -eq 1  ]
   then
      echo 1
   else
      local temp=$[ $1 - 1 ]
      local result=$(func1 $temp)
      echo $[ $result * $1 ] 
   fi
}
read -p &quot;enter value: &quot; value
result=$(func1 $value)
echo &quot;the factorial 0f $value is : $result&quot;
[root@node1 ljy]# sh ceshi.sh 
enter value: 5
the factorial 0f 5 is : 120
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建库&lt;/h2&gt;
&lt;p&gt;bash shell允许创建函数库文件，然后在多个脚本中引用该库文件。&lt;/p&gt;
&lt;p&gt;1.创建一个包含脚本中所需函数的公用库文件&lt;/p&gt;
&lt;p&gt;2.在用到这些函数的脚本文件中包含库文件名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more myfuncs 
function addem {
   echo $[ $1 + $2 ]
}
[root@node1 ljy]# more ceshi.sh 
#!/bin/bash
. ./myfuncs
result=$(addem 1 2)
echo &quot;result is $result&quot;
[root@node1 ljy]# sh ceshi.sh 
result is 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用函数库的关键在于source命令。&lt;/p&gt;
&lt;p&gt;source命令有个快捷的别名，叫做点操作符。&lt;/p&gt;
&lt;p&gt;. ./name&lt;/p&gt;
&lt;h2&gt;在命令行上使用函数&lt;/h2&gt;
&lt;h4&gt;在命令行上创建函数&lt;/h4&gt;
&lt;p&gt;有两种方法：&lt;/p&gt;
&lt;p&gt;一、采用单行方式定义函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# function func1 { echo $[ $1 + $2 ]; }
[root@node1 ljy]# func1 1 2
3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;退出当前终端失效。&lt;/p&gt;
&lt;p&gt;二、采用多行方式定义函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ~]# function func1 {
&amp;gt; echo $[ $1 + $2 ]
&amp;gt; }
[root@node1 ~]# func1 1 3
4
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在函数的尾部使用花括号，shell就会知道你完成了函数的定义。&lt;/p&gt;
&lt;h4&gt;在.bashrc文件中定义函数&lt;/h4&gt;
&lt;p&gt;为了防止每次退出shell后函数失效，可以将函数写在.bashrc文件。bash shell在每次启动时都会在主目录下查找这个文件。&lt;/p&gt;
&lt;p&gt;1.直接定义函数&lt;/p&gt;
&lt;p&gt;把你的函数直接写在文件末尾&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ~]# more .bashrc 
# .bashrc

# User specific aliases and functions

alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi
#a test function
function func1 {
   echo $[ $1 + $2 ]
}
[root@node1 ~]# func1 2 3
5
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2.读取函数文件&lt;/p&gt;
&lt;p&gt;在shell脚本中可以用source命令将库文件的函数添加到你的.bashrc文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ~]# more .bashrc 
# .bashrc

# User specific aliases and functions

alias rm='rm -i'
alias cp='cp -i'
alias mv='mv -i'

# Source global definitions
if [ -f /etc/bashrc ]; then
        . /etc/bashrc
fi
#a test function
. /ljy/myfuncs
[root@node1 ~]# more /ljy/myfuncs 
function addem {
   echo $[ $1 + $2 ]
}
[root@node1 ~]# addem 1 3
4
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 28 May 2019 07:36:00 +0000</pubDate>
<dc:creator>秦广王</dc:creator>
<og:description>基本脚本函数 1、创建函数 有两种格式可以用来在bash shell脚本中创建函数。第一种采用关键字function。后跟分配给该代码的函数名。 name属性定义了赋予函数唯一的名称。脚本中定义的每个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jinyuanliu/p/10913821.html</dc:identifier>
</item>
<item>
<title>[开源] FreeSql AOP 功能模块 - FreeSql</title>
<link>http://www.cnblogs.com/FreeSql/p/10937631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FreeSql/p/10937631.html</guid>
<description>&lt;p&gt;FreeSql 是一个功能强大的 .NETStandard 库，用于对象关系映射程序(O/RM)，支持 .NETCore 2.1+ 或 .NETFramework 4.6.1+（QQ群：4336577）。&lt;/p&gt;
&lt;p&gt;据了解，用户使用很少问问题，编码过程中，因业务阻塞，情有可原；因框架使用问题阻塞，得不偿失。我们的口号：做 .net 最方便的 ORM！愿每一位开发者嘴角上扬😏！&lt;/p&gt;
&lt;h2 id=&quot;整体功能&quot;&gt;整体功能&lt;/h2&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;IFreeSql 是核心，提供原始用法；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;FreeSql.DbContext 是扩展包，提供面向对象的用法（像EF）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;FreeSql.Repository 也是扩展包，提供仓储+工作单元用法（实际上和 DbContext 是一个扩展包）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;FreeSql.Connection.Extensions 也是扩展包，提供像 Dapper 一样的用法；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/2881099/FreeSql&quot; class=&quot;uri&quot;&gt;https://github.com/2881099/FreeSql&lt;/a&gt;，可从这里链向上面介绍的各个仓库。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;fsql= new FreeSql.FreeSqlBuilder()
    .UseConnectionString(FreeSql.DataType.Sqlite, @&quot;Data Source=|DataDirectory|\document.db;Attachs=xxxtb.db;Pooling=true;Max Pool Size=10&quot;)
    .UseAutoSyncStructure(true) //自动迁移(CodeFirst)
    .Build();&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;今天上场的是 AOP 已有的功能介绍，未来为会根据用户需求不断增强。&lt;/p&gt;
&lt;h2 id=&quot;审计-crud&quot;&gt;审计 CRUD&lt;/h2&gt;
&lt;p&gt;马云说过，996是修福报。对于多数程序员来说，加班是好事。。。起码不是闲人，不会下岗。&lt;/p&gt;
&lt;p&gt;当如果因为某个 sql 骚操作耗时很高，没有一个相关的审计功能，排查起来可以说无从下手，福报与你紧紧相随（哈哈）。&lt;/p&gt;
&lt;p&gt;FreeSql 支持简单的类似功能：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;fsql.Aop.CurdAfter = (s, e) =&amp;gt; {
    if (e.ElapsedMilliseconds &amp;gt; 200) {
        //记录日志
        //发送短信给负责人
    }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;是的，只需要一个事件，就可以对全局起到作用。&lt;/p&gt;
&lt;p&gt;除了 CurdAfter，还有一个 CurdBefore （在执行 sql 之前触发）。&lt;/p&gt;
&lt;h2 id=&quot;审计迁移脚本&quot;&gt;审计迁移脚本&lt;/h2&gt;
&lt;p&gt;FreeSql 自带迁移功能，那么迁移的 SQL 语句长啥样，你可能会好奇。&lt;/p&gt;
&lt;p&gt;这些操作在 FreeSql.CodeFirst 实现下基本不需要理会，而且我们只推荐在开发环境使用自动迁移的功能，正式环境可使用其他工具替代此操作。&lt;/p&gt;
&lt;p&gt;但我们仍然可能需要对项目做完整的日志记录。&lt;/p&gt;
&lt;p&gt;fsql.Aop.SyncStructureBefore、fsql.Aop.SyncStructureAfter 这两个事件将排上用场。&lt;/p&gt;
&lt;h2 id=&quot;自定义实体特性&quot;&gt;自定义实体特性&lt;/h2&gt;
&lt;p&gt;比如项目内已经使用了其它 orm，如 efcore，这样意味着实体中可能存在 [Key]，但它与 FreeSql [Column(IsPrimary = true] 不同。&lt;/p&gt;
&lt;p&gt;Q： FreeSql 实体特性为啥这么别扭？&lt;/p&gt;
&lt;p&gt;A： 为了考虑一致性用法，全部封装在 ColumnAttribute 下，这样用户使用起来，不用到处 using 或者 回忆特性应该用哪个名字，如自增 [Column(IsIdentity = true)] 即可。&lt;/p&gt;
&lt;p&gt;FreeSql 提供 AOP 自定义特性功能，实现与多个 orm 共同拥有一套实体特性，可避免重复定义特性。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;fsql.Aop.ConfigEntity = (s, e) =&amp;gt; {
    var attr = e.EntityType.GetCustomAttributes(
        typeof(System.ComponentModel.DataAnnotations.Schema.TableAttribute), false).FirstOrDefault() 
        as System.ComponentModel.DataAnnotations.Schema.TableAttribute;
    if (attr != null)
        e.ModifyResult.Name = attr.Name; //表名
};

fsql.Aop.ConfigEntityProperty = (s, e) =&amp;gt; {
  if (e.Property.GetCustomAttributes(
    typeof(System.ComponentModel.DataAnnotations.KeyAttribute), false).Any())
        e.ModifyResult.IsPrimary = true; //主键
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就这样，FreeSql 的实体特性就可以和 EFCore 那样设定了。其他自增、乐观锁等，依葫芦画瓢便是。&lt;/p&gt;
&lt;h2 id=&quot;自定义表达式&quot;&gt;自定义表达式&lt;/h2&gt;
&lt;p&gt;FreeSql 内部表达式支持非常丰富，对各大数据库的兼容度也做得很好。&lt;/p&gt;
&lt;blockquote readability=&quot;2.5771812080537&quot;&gt;
&lt;p&gt;有关表达式支持到的程度，可点击查看详细wiki：&lt;a href=&quot;https://github.com/2881099/FreeSql/wiki/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0&quot;&gt;https://github.com/2881099/FreeSql/wiki/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%87%BD%E6%95%B0&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;即便如此丰富，也仍然无法满足用户需求，FreeSql 对外开放了自定义表达式解析接口：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;fsql.Aop.ParseExpression = (s, e) =&amp;gt; {
    if (e.Expression.NodeType == Call &amp;amp;&amp;amp; e.Expression.Name == &quot;get_Item&quot;)
        e.Result = &quot;1111&quot;;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个解析有点复杂，当 e.Expression 很复杂的时候，我们还提供了 e.FreeParse 方法，使用它相当于调用 FreeSql 内置表达式解析引擎，辅助您进行解析。&lt;/p&gt;
&lt;h2 id=&quot;aop.where&quot;&gt;Aop.Where&lt;/h2&gt;
&lt;p&gt;FreeSql 提供的 ISelect、IDelete、IUpdate 三大对象，都可以使用 .Where(lambda) 操作，也可以是 .Where(sql) 操作。&lt;/p&gt;
&lt;p&gt;Aop.Where 的定位是可拦截 Where 条件。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;fsql.Aop.Where = (s, e) =&amp;gt; {
    if (e.Parameter[0]?.ToString() == &quot;1&quot;)
        e.IsCancel = true;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;aop.tolist&quot;&gt;Aop.ToList&lt;/h2&gt;
&lt;p&gt;监控 ToList 返回的的数据，用于拦截重新装饰。&lt;/p&gt;
&lt;p&gt;所有通过 FreeSql.Select 查询返回的时候，都可以在这个事件上进行重新装饰。&lt;/p&gt;

&lt;p&gt;下载地址：&lt;a href=&quot;https://github.com/2881099/FreeSql&quot; class=&quot;uri&quot;&gt;https://github.com/2881099/FreeSql&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;优势：5种数据库支持彻底，1500+单元测试，文档功能齐全&lt;/p&gt;
&lt;p&gt;欢迎更多人加入我们阵营！我们一起做 .NETCore 最方便的 ORM！&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 07:18:00 +0000</pubDate>
<dc:creator>FreeSql</dc:creator>
<og:description>前言 FreeSql 是一个功能强大的 .NETStandard 库，用于对象关系映射程序(O/RM)，支持 .NETCore 2.1+ 或 .NETFramework 4.6.1+（QQ群：4336</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FreeSql/p/10937631.html</dc:identifier>
</item>
<item>
<title>关于自动化测试框架设计的几点思考 - 马蜂窝技术</title>
<link>http://www.cnblogs.com/mfwtech/p/10937571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mfwtech/p/10937571.html</guid>
<description>&lt;p&gt;对于自动化测试的好处和重要性，相信大家都已经了解。自动化测试可以让我们在有限的时间内尽可能多的覆盖所涉及到的测试场景，减少测试人员的的重复性工作，提高测试效率以及覆盖率。&lt;/p&gt;
&lt;p&gt;其实很多测试同学都非常积极尝试自动化，但最终又选择放弃，很重要的原因是没有感受到自动化带来的收益。&lt;/p&gt;
&lt;p&gt;实际上，自动化的效率高低很大程度上取决于你的自动化框架设计得是否合理，下面就以如何设计高效的自动化框架来谈谈自己的理解。&lt;/p&gt;
&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;&lt;strong&gt;什么是自动化测试框架&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;首先说说什么是自动化测试。自动化测试就是让被测试的软件自己可以运行起来，代替人去执行软件的功能；或者是让其他的工具自己运行起来，去检查软件的内部和外部。自动化测试可以看成是一个自动执行的过程。&lt;/p&gt;
&lt;p&gt;自动化测试框架则是可以让自动化测试实现的一系列组合封装的库或工具，来帮助我们进行自动化测试的配套设施。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;自动化测试框架的设计&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;实际上，不管是手工测试还是自动化测试，最核心的工作不外乎编写测试用例、执行测试用例、处理运行结果、维护用例。因此，如何提高自动化测试的效率，也就拆解成了如何提高自动化「编写、执行、维护」测试用例上效率的问题。&lt;/p&gt;
&lt;h3&gt;01 选择自动化测试方式&lt;/h3&gt;
&lt;p&gt;目前比较常见的自动化测试方式主要分为「数据驱动框架」和「关键字驱动框架」两种。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;a. 数据驱动 （DDT）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据驱动指的是从某个数据文件(例如Excel文件、Xml文件、Json文件等)中读取输入测试数据，然后通过变量传入编写的测试脚本中。&lt;/p&gt;
&lt;p&gt;在这个过程中， 数据文件的读取、测试状态和所有测试步骤都被编写进测试脚本里；测试数据只包含在数据文件中，而不是脚本里，测试脚本只是一个“驱动”，或者说是一个传送数据的机制。&lt;/p&gt;
&lt;p&gt;一般用来存放数据的文件有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;Excel 数据文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;XML 数据文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JSON 数据文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; Text 数据文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; YAML 数据文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt; 数据库等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;数据驱动的方法主要用于需要通过不同数据来保证测试覆盖率的场景，比如被测系统业务逻辑固定不变或变动较小，即测试用例步骤是固定的，但是所需要的测试数据是变化的情况。通常来说，数据都是保存在外面文件或数据库中，运行时自动获取。即测试框架中要支持数据与脚本分离，一个测试脚本可以驱动执行多个相似测试场景。&lt;/p&gt;
&lt;p&gt;那么，数据与脚本分离是自动化的必要因素，如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/60032a3c600d8492389e6ed742bc1567d2e.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/60032a3c600d8492389e6ed742bc1567d2e.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上图是将测试数据与脚本独立，页面元素与脚本独立，测试同学只需要独立维护测试数据与页面元素，且数据与页面元素是共享的，任何测试人员均可调用，减少了编写与维护的成本。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;b. 关键字驱动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关键字驱动是将数据与关键字结合来描述如何执行测试。也就是将测试用例脚本中的步骤提取出来，放在独立的数据文件中，变成简单编写的方式。这种方法具备数据驱动的优势，同时非编程人员也能建立测试。&lt;/p&gt;
&lt;p&gt;关键字驱动的模式是建立在数据驱动手段之上，关键字驱动文件包含指令(关键词)，而不只是数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/d6bace4afdfea204a7a38cf52f0962e5ff5.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/d6bace4afdfea204a7a38cf52f0962e5ff5.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;02 提高执行效率：分布式&lt;/h3&gt;
&lt;p&gt;测试用例的执行效率也是自动化测试需要注意的重点。设想一下，一个早晨，你手捧一杯咖啡，在电脑旁开启了一天的工作，这时收到一封提测邮件，首先你开启了自动化冒烟或回归当前需求，当你在本地开启运行UI自动化测试用例的时候，当前执行的用例已经占据了你整个电脑，你啥也干不了。&lt;/p&gt;
&lt;p&gt;如果通过一种简单的机制可以让测试用例在其他机器或手机上运行，不需要你本机，也不需要复杂的操作，在你忙碌其他事情的时候，而多台远程机器也在同时为你执行测试用例，不仅提高了你的工作效率，节省人工成本，也同时提高了测试用例的执行效率。&lt;/p&gt;
&lt;p&gt;这里我们说的分布式执行是指将数条测试用例在多台远程机器上执行：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/6cb3d3f1911374a75ba6e5a1616c68f4212.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/6cb3d3f1911374a75ba6e5a1616c68f4212.jpg&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;03 常见的自动化测试框架&lt;/h3&gt;
&lt;p&gt;不管是接口层也好，还是UI层也好，目前应用最多的工具或者语言如：&lt;/p&gt;
&lt;p&gt;①Java+Selenium/Appium+TestNG/Junit+Maven/Ant+Git+Jenkins&lt;/p&gt;
&lt;p&gt;②Python+Selenium/Appium+Unittest/Pytest+Git+Jenkins&lt;/p&gt;
&lt;p&gt;至于需要使用哪种选型，根据自己的团队需要而定，那种选型都可以搭建一个拥有好的设计模式的框架。目前在电商团队中的测试框架中支持的自动化主要有：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/46a1fef6dea25979deb47d104b64337ed3b.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/46a1fef6dea25979deb47d104b64337ed3b.jpg&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;小结&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;一个好的自动化的框架一定是灵活易用的，因为测试对象的不确定性以及多变性对于框架来说是一个最大的挑战。&lt;/p&gt;
&lt;p&gt;在未来的测试发展趋势中，也许可以有更加简便的方式去包容丰富多变的测试场景，可以自动生成自动化测试用例，其实近来也有人尝试机器学习（AI+大数据的方式）来识别GUI的对象，不管是创新性的技术还是传统技术，我们的目的是为了高效率的保证测试质量。&lt;/p&gt;
&lt;p&gt;以上是个人关于自动化测试框架的一些见解，欢迎各位测试小伙伴们一起探讨。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;本文作者：&lt;/strong&gt;徐彦卿 电商旅游测试负责人&lt;/p&gt;
</description>
<pubDate>Tue, 28 May 2019 07:10:00 +0000</pubDate>
<dc:creator>马蜂窝技术</dc:creator>
<og:description>对于自动化测试的好处和重要性，相信大家都已经了解。自动化测试可以让我们在有限的时间内尽可能多的覆盖所涉及到的测试场景，减少测试人员的的重复性工作，提高测试效率以及覆盖率。 其实很多测试同学都非常积极尝</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mfwtech/p/10937571.html</dc:identifier>
</item>
</channel>
</rss>