<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>领域驱动设计，让程序员心中有码（二） - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10085784.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10085784.html</guid>
<description>&lt;p&gt; 　　 　　　　　&lt;span&gt;&lt;strong&gt;　　　&lt;span&gt;引子，软件工程没有银弹&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;span&gt;  &lt;strong&gt;&lt;span&gt;&lt;code&gt;上一篇博文，抛出了一个问题，领域驱动设计真的是万能的良方吗？对于这个问题，大家的答案无疑是一致的，作为一种非常受软件行业欢迎的软件思想，领域驱动设计固然有很多优点，却并非万能。&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;code&gt;　　 &lt;/code&gt;&lt;code&gt;回到十年前，第一节软件工程学的课堂上，我们的老师就告诉了我们一句真理，软件工程没有银蛋，这句话说的是，软件工程领域，从来没有一种思想或理论能够带来成倍的效率提升。不知不觉，十年过去，我们大概可以看到，软件开发新技术日新月异，新语言层出不穷，但是无论哪种技术，都不见得相对于其所对标的技术取得了成倍的提升。技术尚且如此，理论就更不用说了。&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;code&gt;   &lt;/code&gt;&lt;code&gt;领域驱动设计，近年来受到技术圈的广泛追捧，主要得益于微服务技术的发展。一千个读者有一千个哈姆雷特，而不同的人往往对这种理论有不同的看法。如果问一个.net开发者领域驱动是什么，大概他会说是abp架构。ABP架构作为完全按照领域驱动设计思想构建的技术架构，目前得到了社区的广泛追捧。然而，领域驱动架构和领域驱动设计，依然是道和术的区别，开发者在学习领域驱动架构的同时，也应该了解领域驱动设计。那么领域驱动设计究竟是什么的东西？由于时间和篇幅有限，我无意通过代码介绍如何实现一个领域驱动的功能，而是希望把领域驱动设计的基本思路进行梳理，期待能通过我的梳理，抛砖引玉，给大家带来启迪&lt;/code&gt;&lt;code&gt;。&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　　　&lt;/code&gt;&lt;strong&gt;&lt;span&gt;&lt;code&gt;一，领域驱动设计，不错的选择&lt;/code&gt;&lt;/span&gt;&lt;/strong&gt;&lt;em&gt;　　&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;　&lt;span&gt;　&lt;span&gt;&lt;strong&gt;作为现代软件工业发展的产物，敏捷开发和极限编程，实现了生产力的解放，通过抛弃传统研发模式中留下的臃肿的设计文档，实现了劳动生产力的提升，无数互联网公司，依靠灵活的开发手段，为产品插上了快速开发的翅膀。开发者们不用加班，分分钟就把代码撸完，然后把产品质量关把好，发布，嗯，早早的就回家休息了。然而，随着产品功能的逐渐增加，团队自然而然也需要扩展。可是，团队成员越来越多，代码质量成为一个难以把控的问题。如何保证产品功能的一致性？如何保证功能符合产品的需求？管理者们不厌其烦，每天开会必须提开发质量，必须强调变量命名，注释，设计原则，设计模式，然后每天一次集成，代码审查估计已经不现实了。于是，作为面子的产品质量尚且有测试把关，而作为内脏的代码质量本身，成为上帝的骰子，好与坏全靠开发者们的自觉性和经验。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201812/191302-20181207230720889-64814954.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;code&gt;　　　　&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;code&gt;冰山，在软件产品华丽外表之下，究竟深藏着多少问题？&lt;/code&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201812/191302-20181207230819521-1478390122.png&quot; alt=&quot;&quot;/&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;一个复杂的数据库关系模型图&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;strong&gt;&lt;code&gt;　　&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;领域驱动设计在这样的场景下推出来的一种理念。软件系统的复杂度是开发者们没办法避免的客观情况，而根据领域的实际情况，建立模型是解决问题行之有效的方法。在实际过程中，我们需要领域专家与开发者一起，共同努力，以一种特殊的方式来进行沟通，并通过模型将实际生活中的问题抽象化。&lt;/code&gt;&lt;/strong&gt;&lt;strong&gt;&lt;code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;　　领域驱动设计的核心是建模，实际上对于大部分开发者而言，建模是一个基本技能，却并非每个人都能熟练的掌握。技术人员都普遍对他们工作领域有关的知识不感兴趣，而更愿意从事精细的框架工作，例如通过技术手段解决实际问题。而学习业务领域和领域建模的工作往往留给别人去做。然而，实际上，软件核心的复杂性，既包括需要直接面对的技术问题，而客观存在的业务问题却也是不可忽视的，过份重视技术，轻视建模，只会导致工作重心的偏离。甚至可以说，过份的重视领域驱动架构基础设施本身，而忽略了建模过程，在后期执行过程中可能会导致不可控制的风险。对于这一点大家都是容易理解的，以前的架构，简单反而容易维护，而系统架构复杂了，反而提高了学习成本导致不容易维护。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;　　软件设计的基本原则是“高内聚，低耦合”。作为一个复杂的软件工程，依靠领域驱动建模，将紧密联系在一起的业务设计成一个领域模型，让领域模型内部隐藏细节，这样让领域模型与领域模型之间的关系变得简单，将极大的降低复杂业务之间千丝万缕的耦合关系。&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span&gt;　　&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/201812/191302-20181207230931062-1996362501.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
　　　　　　　　　　　　　　　　　　　　　　　　面向领域设计的模型图&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;　　　　　　　　　　　　　&lt;span&gt;&lt;strong&gt;二，领域设计的要素，统一语言和建模及文档&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;br/&gt;　　&lt;span&gt; &lt;strong&gt;在进行设计之前，我们有必要建立基本的原则，那就是统一语言，模型，和设计文档。&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　1  统一语言&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　在日常讨论过程中，我们需要跟领域专家讨论，往往大家都是自己行业内的专家，也意味着大家都有自己的表达问题的方式和自己的理解，这有可能导致需求支离破碎。例如对对方表达的术语不了解，会形成鸡同鸭讲的情况。因此，需要建立一个能够互相沟通理解的语言环境，例如，互相的交流双方的术语，并试图利用双方都能理解的词语进行问题的分析。也许在最开始这样共同语言并不能很好的运作，但是却可以在后期逐渐完善。我们的开发者应该定期的了解领域所在行业的业务知识，扩充自己的知识面，这也有利于我们与领域专家的交流。&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　2  建模和画图&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　在我们工作过程中模型无处不在，不管是在纸上绘制的简单模型，或者使用专业软件绘制的各种模型，都是模型。领域驱动设计本身，依然依赖于模型驱动设计。学会建模对于广大开发者来说，都是一项基本技能。可以说，代码语言是为了与其他开发者进行沟通交流，那我们建立的各种软件设计模型将极大的方便不同领域的人员进行交流。建模也可以称之为语言的一部分利用uml建立类图，是一种可以比较易于接受的方式。我们可以采用以下手段来建立领域模型。&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　1)建立一个与实现绑定的模型。初版的模型也许很简陋，但是它可以成为一个基础，然后在后期逐渐完善。&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　2)建立一种基于模型的通用语言或表达形式和机制。通过通用语言让参与项目的所有人理解模型。&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　3)开发一个蕴含丰富知识的模型。模型不是单纯的数据结构，它更是各类知识的聚合体。&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　4)提炼模型，模型应该能在项目过程中动态改变，发现新的概念就加进来，过时的概念就适时移除，避免臃肿。&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　5)头脑风暴和实验。模型在于实践和应用，它需要项目参与者共同的努力，而头脑风暴是发挥集体智慧的良好方式。对模型进行实验或者进行场景的模拟，有利于让模型更符合需求。&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　当然，对于领域专家而言，不同类型的模型也许无法理解，例如类图可能过于复杂，可以使用画图的形式，通过解释性的图形或者模型，可以让不同层次的人都能获得一致的理解。&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　3  设计文档&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　设计文档依然是不可抛弃的重要资料，虽然设计文档可能不利于维护，却仍然不可抛弃。毕竟开发过程中，通过代码和模型，有可能会导致关键信息的丢失，而且有的不能直接参与讨论的领域专家需要通过文档才能了解之前讨论的情况，甚至可能画图会形成很多歧义，这也需要解释性的文档才能说清楚。为了让文档变得更加有效，不建议重复赘述已知的信息，而关键信息更改后，应该尽量保持最新。&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;完全依赖代码或架构的自解释特性目前似乎已经成为大家的普遍习惯，但是代码可能存在歧义，或者有的方法本身就无法表达方法的本质含义，最终导致代码成为无法理解的神之领域，这种问题已经不是一个单纯的领域驱动架构能够解决的。如果为了让代码来解释模型，我们所有人必须时刻抱着一丝不苟严于律己的态度，才能写出完全符合领域模型的代码，问题是这种方式现实吗？&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　4  概念总结：&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　1)领域就是问题域，有边界，领域中有很多问题；&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　2)任何一个系统要解决的那个大问题都对应一个领域；&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　3)通过建立领域模型来解决领域中的核心问题，模型驱动的思想；&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　4)领域建模的目标针对我们在领域中所关心的问题，即只针对核心关注点，而不是整个领域中的所有问题；&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　5)领域模型在设计时应考虑一定的抽象性、通用性，以及复用价值；&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　6)通过领域模型驱动代码的实现，确保代码让领域模型落地，代码最终能解决问题；&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　7)领域模型是系统的核心，是领域内的业务的直接沉淀，具有非常大的业务价值；&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　　8)技术架构设计或数据存储等是在领域模型的外围，帮助领域模型进行落地；&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; &lt;/span&gt;&lt;br/&gt;　　　　&lt;span&gt;三、问题思考&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;　&lt;span&gt;　掌握建模和基本的步骤，意味着一切刚刚开始。道阻且长，行则将至，领域驱动设计，不仅仅是一种简单的建模思想或技术架构，更是一种挑战。在选择之前，是否需要思考一下，这一套体系，真的适合在你的团队中运行么？如果要切实的运行，还需要付出多少代价？尤其是对于领域模型而言，如果缺乏合理有效、而且持续迭代的设计，你难道不觉得最终所有的模型仅仅只是一种数据结构设计吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;参考资料：&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;1.《领域驱动设计-软件核心复杂性应对之道》&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;2.&lt;a href=&quot;https://blog.csdn.net/three_bird/article/details/51336834&quot;&gt;https://blog.csdn.net/three_bird/article/details/51336834&lt;/a&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; &lt;br/&gt;3.&lt;a href=&quot;https://blog.csdn.net/heweimingming/article/details/78661540&quot;&gt;https://blog.csdn.net/heweimingming/article/details/78661540&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 07 Dec 2018 15:15:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>引子，软件工程没有银弹 上一篇博文，抛出了一个问题，领域驱动设计真的是万能的良方吗？对于这个问题，大家的答案无疑是一致的，作为一种非常受软件行业欢迎的软件思想，领域驱动设计固然有很多优点，却并非万能。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10085784.html</dc:identifier>
</item>
<item>
<title>php debug二三事 - freephp</title>
<link>http://www.cnblogs.com/freephp/p/10085724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freephp/p/10085724.html</guid>
<description>&lt;p&gt;最近php相关项目遇到了一些问题，处理起来让人感觉挺有意思，寥寥记下。&lt;/p&gt;
&lt;p&gt;1.&lt;span&gt;&lt;strong&gt;php执行后常驻内存里，需要&lt;span&gt;kill&lt;/span&gt;掉该进程再重启，才能让修改后的代码生效。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之前有一次组里小伙伴修改了一个长期后台进程运行的&lt;/span&gt;php脚本，增加了一些业务逻辑判断。之后我进行部署之时一直忘记将其php进程kill掉，测试的时候一直找不到未生效的原因。后面想到了后台持续run的脚本是从内存里面读取的代码块，而不是加载最新的代码脚本。对于php我们常常脑补无需重启（如node）或者编译（java）直接生效，但是对于一直运行的脚本不然。&lt;/p&gt;
&lt;p&gt;Tips 2 &lt;strong&gt;&lt;span&gt;如果使用&lt;/span&gt;ps aux | grep xxx来判断脚本是否运行，请尽量&lt;/strong&gt;&lt;strong&gt;精准&lt;/strong&gt;&lt;strong&gt;&lt;span&gt;地&lt;/span&gt;grep&lt;/strong&gt;&lt;strong&gt;。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;又是一次后台进程任务的添加，采用方式的是&lt;/span&gt;shell脚本监控php进程并维护其始终运行。这次我因为事情比较忙，让F君自己动手在测试服上写好shell去执行。后面发现一直没有成功run起来php任务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我先尝试了直接&lt;/span&gt;php&lt;span&gt;命令执行&lt;/span&gt;&lt;span&gt;php&lt;/span&gt;&lt;span&gt;脚本是没问题的，排查了脚本本身的问题。然后又仔细看了一下&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;发现也没什么问题，最后通过对比之前的写法，发现是因为在判断是否有&lt;/span&gt;&lt;span&gt;php&lt;/span&gt;&lt;span&gt;脚本进行的时候用的&lt;/span&gt;&lt;span&gt;grep&lt;/span&gt; &lt;span&gt;不够精准，如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/782095/201812/782095-20181207225551173-844104179.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;很凑巧的是，&lt;/span&gt;F&lt;span&gt;君写的&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;脚本的名字也是&lt;/span&gt;&lt;span&gt;new_notice&lt;/span&gt;&lt;span&gt;，和&lt;/span&gt;&lt;span&gt;php&lt;/span&gt;&lt;span&gt;脚本名撞名了。所有尽管&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;里面是&lt;/span&gt;&lt;span&gt;while true&lt;/span&gt;&lt;span&gt;的死循环，但是每次检查都会发现有叫&lt;/span&gt;&lt;span&gt;new_notice&lt;/span&gt;&lt;span&gt;的进程（因为同名&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;脚本一直保持运行），故而不会进行启动&lt;/span&gt;&lt;span&gt;php&lt;/span&gt;&lt;span&gt;进程的逻辑块，后台任务也永远无法执行。养成习惯精准&lt;/span&gt;&lt;span&gt;grep&lt;/span&gt;&lt;span&gt;或者将&lt;/span&gt;&lt;span&gt;shell&lt;/span&gt;&lt;span&gt;脚本名改为更抽象的名称都是不错的方法。但是本质是&lt;/span&gt;&lt;span&gt;grep&lt;/span&gt;&lt;span&gt;要精准到脚本全称，包括文件扩展后缀名。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;Tips 3 &lt;strong&gt;&lt;span&gt;报错要重视，框架要熟悉。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;为了减少老框架的束缚，我鼓励组内小伙伴在一些业务牵连不大的新项目中尝试使用新的框架来做业务。今天刚好是新的统计服务部署到线上的时间，我刚部署完后，&lt;/span&gt;F&lt;span&gt;君和我说&lt;/span&gt;&lt;span&gt;mongo&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;auth failed&lt;/span&gt;&lt;span&gt;。经过一顿&lt;/span&gt;&lt;span&gt;baidu&lt;/span&gt;&lt;span&gt;后，发现需要在&lt;/span&gt;&lt;span&gt;tp5&lt;/span&gt;&lt;span&gt;的&lt;/span&gt;&lt;span&gt;mongo driver&lt;/span&gt;&lt;span&gt;实现里面修改源码，把&lt;/span&gt;&lt;span&gt;MongoDB\Driver\Manager&lt;/span&gt;&lt;span&gt;的连接&lt;/span&gt;&lt;span&gt;URI&lt;/span&gt;&lt;span&gt;最后加上&lt;/span&gt;&lt;span&gt;database&lt;/span&gt;&lt;span&gt;参数。尝试添加后不再报&lt;/span&gt;&lt;span&gt;auth failed&lt;/span&gt;&lt;span&gt;的错误，却直接页面显示该网站永久性转移。去掉后又报&lt;/span&gt;&lt;span&gt;auth failed&lt;/span&gt;&lt;span&gt;，对比线上和测试服的代码和&lt;/span&gt;&lt;span&gt;mongo&lt;/span&gt;&lt;span&gt;扩展版本都没有什么问题，也曾怀疑过两个环境的&lt;/span&gt;&lt;span&gt;mongo sever&lt;/span&gt;&lt;span&gt;版本问题，发现差异也不大。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;经过一顿猛如虎的操作，最后发现是因为项目根目录下没有&lt;/span&gt;runtime&lt;span&gt;目录造成的。一边赶地铁回家，一边刷着知乎的我发誓以后一定要重视框架的细节，细节决定很多步，包括下一步。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 07 Dec 2018 14:57:00 +0000</pubDate>
<dc:creator>freephp</dc:creator>
<og:description>最近php相关项目遇到了一些问题，处理起来让人感觉挺有意思，寥寥记下。 1.php执行后常驻内存里，需要kill掉该进程再重启，才能让修改后的代码生效。 之前有一次组里小伙伴修改了一个长期后台进程运行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freephp/p/10085724.html</dc:identifier>
</item>
<item>
<title>Java Nested Classes(内部类~第一篇英文技术文档翻译) - 翎野</title>
<link>http://www.cnblogs.com/lingyejun/p/10085629.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lingyejun/p/10085629.html</guid>
<description>&lt;p&gt;&lt;span&gt;鄙人最近尝试着翻译了自己的第一篇英文技术文档。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Java Nested Classes Reference From &lt;a href=&quot;https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot;&gt;Oracle Documentation&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;在Java中我们可以在一个类的内部，再定义另外一个类，其中里面的那个类被称为嵌套类，示例如下。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
class OuterClass {
    ...
    class NestedClass {
        ...
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;术语：嵌套类有两种类型：静态和非静态，当嵌套类被static修饰时，被称为静态嵌套类（static nested classes），没有被static修饰时的嵌套类被称作内部类（inner classes）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
class OuterClass {
    ...
    static class StaticNestedClass {
        ...
    }
    class InnerClass {
        ...
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;嵌套类是外部基类(&lt;strong&gt;即外部类&lt;/strong&gt;)的成员，非静态嵌套类（内部类）可以获取到外围基类的其他成员，其中也包括被声明为private的成员。静态嵌套类则不可以获取基类的其他成员。当做为作为外部类的成员，嵌套类可以被定义为private,public,protected或者package private。如果我们需要在其他外部类中使用内部类，则一定要将嵌套类声明为public或者 package private。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;使用嵌套类有以下几个明显的优势：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;当仅会在一处用到某个类时，通过嵌套类可以在逻辑上与基类(外部类)保持一种紧密的联系关系：当一个类只会在另一个类中使用，那么就可以把这个类嵌入到另外一个类中，可以使得两者之间有着紧密的联系，嵌套类又称之为'辅助类'。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;通过合理的使用可以使得整个包下的类定义更加的简洁：更强的封装性：A和B两个类，B作为A类的嵌套类，如果不将其中B类B类设置为private的话，那么B类就拥有访问A类成员的权限。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;更好的可读性和更高的可维护性：在编码时内部的嵌套类总是需要和最外层类保持一种形式上的关联关系。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;静态嵌套类不能直接引用外部基类的实例变量和实例方法，对于这样的实例变量仅可以通过对象引用来获取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过使用外围基类名称来获取静态嵌套类&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
OuterClass.StaticNestedClass
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果我们想创建一个静态嵌套类的对象，则可以使用如下的方式&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;内部类可以通过外部类实例，直接获取基类对象的变量和方法，同理因为内部类是通过实例引用来和外部类建立关系的，所以在内部类中不能定义任何的静态成员。只有当外部类实例对象被创建出来之后，才可以实例化内部类。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
class OuterClass {
    ...
    class InnerClass {
        ...
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;内部类实例只能存在于外部类实例中，并且可以直接访问其外部类实例的方法和字段。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在实例化内部类前，要先实例化外部类实例。可以通过如下方式，通过外部对象实例来创建内部类对象。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
OuterClass.InnerClass innerObject = outerObject.new InnerClass();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;内部类有两种类型：局部类(local classes) 和 匿名类(anonymous classes).&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;articleHeader4&quot;&gt;局部类-Local Classes&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;局部类是一种被定义在代码块中的类，局部类通常时定义在方法体中。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;如何声明局部类：&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;可以在任何一个方法之中定义一个局部类，如for循环中，或者在if子句中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;下面的LocalClassExample，是用来验证两个手机号，在这个类的validatePhoneNumber方法中，定义了一个名为PhoneNumber的局部类。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class LocalClassExample {
  
    static String regularExpression = &quot;[^0-9]&quot;;
  
    public static void validatePhoneNumber(
        String phoneNumber1, String phoneNumber2) {
      
        final int numberLength = 10;
        
        // Valid in JDK 8 and later:
       
        // int numberLength = 10;
       
        class PhoneNumber {
            
            String formattedPhoneNumber = null;

            PhoneNumber(String phoneNumber){
                // numberLength = 7;
                String currentNumber = phoneNumber.replaceAll(
                  regularExpression, &quot;&quot;);
                if (currentNumber.length() == numberLength)
                    formattedPhoneNumber = currentNumber;
                else
                    formattedPhoneNumber = null;
            }

            public String getNumber() {
                return formattedPhoneNumber;
            }
            
            // Valid in JDK 8 and later:

//            public void printOriginalNumbers() {
//                System.out.println(&quot;Original numbers are &quot; + phoneNumber1 +
//                    &quot; and &quot; + phoneNumber2);
//            }
        }

        PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1);
        PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2);
        
        // Valid in JDK 8 and later:

//        myNumber1.printOriginalNumbers();

        if (myNumber1.getNumber() == null) 
            System.out.println(&quot;First number is invalid&quot;);
        else
            System.out.println(&quot;First number is &quot; + myNumber1.getNumber());
        if (myNumber2.getNumber() == null)
            System.out.println(&quot;Second number is invalid&quot;);
        else
            System.out.println(&quot;Second number is &quot; + myNumber2.getNumber());

    }

    public static void main(String... args) {
        validatePhoneNumber(&quot;123-456-7890&quot;, &quot;456-7890&quot;);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过删除原有手机号中除0-9之外的字符后，检查新的字符串中是否有十个数字，输出结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
First number is 1234567890
Second number is invalid
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;获取外部类成员&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;局部类可以获取外部类的成员信息，在上一个例子中，PhoneNumber局部类的构造方法里通过LocalClassExample.regularExpression，就拿到了外部类中的regularExpression成员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外，局部类中也能使用局部变量，但是在局部类中只能使用被final修饰后的变量，当一个局部类要使用定义在外部代码块中的局部变量或者参数时，他会俘获（这个变量就是他的了）这个变量或者参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如，PhoneNumber的构造方法中，能够/会，俘获numberLength，因为这个变量在外围块中被声明为final，这样的话numberLength 就成为了一个被俘获的变量了，有了主人。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但是在java 1.8版本中局部类能够使用定义在外部块中的final或者effectively final的变量或者参数，如果一个变量或者参数的值在初始化后便不会被改变，则被称为effectively final。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如在下面的代码中，变量numberLength没有被显示的声明为final,在初始化后有在方法中又将numberLength的值修改为7：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
PhoneNumber(String phoneNumber) {
    numberLength = 7;
    String currentNumber = phoneNumber.replaceAll(
        regularExpression, &quot;&quot;);
    if (currentNumber.length() == numberLength)
        formattedPhoneNumber = currentNumber;
    else
        formattedPhoneNumber = null;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;因为这个赋值语句numberLength = 7，变量numberLength 便不再是 effectively final了，在这种情形下，内部类尝试在&lt;code&gt;if (currentNumber.length() == numberLength)&lt;/code&gt;这行代码中获取numberLength时，编译器时会提示&lt;code&gt;&quot;local variables referenced from an inner class must be final or effectively final&quot;&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在java8中，如果在方法中声明了局部类，那么可以在局部类中拿到方法的入参，就像下面的方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void printOriginalNumbers() {
    System.out.println(&quot;Original numbers are &quot; + phoneNumber1 +
        &quot; and &quot; + phoneNumber2);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;局部类中的printOriginalNumbers方法获取到了方法validatePhoneNumber中的phoneNumber1 和phoneNumber2两个参数变量。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;局部类与内部类的相似点&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;局部类像内部类一样，二者都不能定义和声明静态成员，在静态方法validatePhoneNumber中定义的PhoneNumber局部类，只能引用外部类中的静态成员。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果将变量regularExpression定义为非静态，那么在java编译器编译的时候会提示&quot;non-static variable regularExpression cannot be referenced from a static context.&quot;错误信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为要获取外围代码块中的实例成员，所以局部类不能时静态的，所以在局部类中不能包含有静态声明。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不能在代码块中，尝试定义或者声明接口，因为接口本质上就是静态的，比如下面的代码是不能编译成功的，因为在greetInEnglish方法内部包含有HelloThere接口：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void greetInEnglish() {
    interface HelloThere {
       public void greet();
    }
    class EnglishHelloThere implements HelloThere {
        public void greet() {
            System.out.println(&quot;Hello &quot; + name);
        }
    }
    HelloThere myGreeting = new EnglishHelloThere();
    myGreeting.greet();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;当然在局部类中也不能声明静态方法，下面的代码同样，在编译时会报&lt;code&gt;&quot;modifier 'static' is only allowed in constant variable declaration&quot;&lt;/code&gt;，因为EnglishGoodbye.sayGoodbye这个方法被声明为静态方法了。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void sayGoodbyeInEnglish() {
    class EnglishGoodbye {
        public static void sayGoodbye() {
            System.out.println(&quot;Bye bye&quot;);
        }
    }
    EnglishGoodbye.sayGoodbye();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;局部类中只有变量时常量的时候，才可能会出现有静态成员变量的情况，下面的代码中有静态成员但也可以编译通过，因为静态变量EnglishGoodbye.farewell是常量。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public void sayGoodbyeInEnglish() {
    class EnglishGoodbye {
        public static final String farewell = &quot;Bye bye&quot;;
        public void sayGoodbye() {
            System.out.println(farewell);
        }
    }
    EnglishGoodbye myEnglishGoodbye = new EnglishGoodbye();
    myEnglishGoodbye.sayGoodbye();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;articleHeader5&quot;&gt;匿名类-Anonymous Classes&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;匿名类可以使你的代码看上去更加的精简，可以在声明一个匿名类的同时对它进行初始化，除了没有类名以外，它跟局部类很像，对于只会使用一次的局部类的场景我们可以用匿名类来代替。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;局部类就是一个类，而匿名类则更像是一个表达式，那么我们便可以在另外的表达式中使用匿名类。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;下面的例子中 HelloWorldAnonymousClasses通过使用匿名类创建局部变量frenchGreeting 和spanishGreeting，通过使用局部类来创建和初始化englishGreeting。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;widget-codetool&quot; readability=&quot;28&quot;&gt; 
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class HelloWorldAnonymousClasses {
  
    interface HelloWorld {
        public void greet();
        public void greetSomeone(String someone);
    }
  
    public void sayHello() {
        
        class EnglishGreeting implements HelloWorld {
            String name = &quot;world&quot;;
            public void greet() {
                greetSomeone(&quot;world&quot;);
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println(&quot;Hello &quot; + name);
            }
        }
      
        HelloWorld englishGreeting = new EnglishGreeting();
        
        HelloWorld frenchGreeting = new HelloWorld() {
            String name = &quot;tout le monde&quot;;
            public void greet() {
                greetSomeone(&quot;tout le monde&quot;);
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println(&quot;Salut &quot; + name);
            }
        };
        
        HelloWorld spanishGreeting = new HelloWorld() {
            String name = &quot;mundo&quot;;
            public void greet() {
                greetSomeone(&quot;mundo&quot;);
            }
            public void greetSomeone(String someone) {
                name = someone;
                System.out.println(&quot;Hola, &quot; + name);
            }
        };
        englishGreeting.greet();
        frenchGreeting.greetSomeone(&quot;Fred&quot;);
        spanishGreeting.greet();
    }

    public static void main(String... args) {
        HelloWorldAnonymousClasses myApp =
            new HelloWorldAnonymousClasses();
        myApp.sayHello();
    }            
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;如何使用和定义一个匿名类&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们可以通过frenchGreeting的创建过程来一探匿名类的组成。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
HelloWorld frenchGreeting = new HelloWorld() {
    String name = &quot;tout le monde&quot;;
    public void greet() {
        greetSomeone(&quot;tout le monde&quot;);
    }
    public void greetSomeone(String someone) {
        name = someone;
        System.out.println(&quot;Salut &quot; + name);
    }
};
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;匿名类的组成部分&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;new 操作符&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;要实现的接口名，或者要继承的父类的名称，在此例中匿名类实现了HelloWorld接口。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;括号，跟一般初始化一个类实例别无二致，需要填入构造方法中的构造参数，&lt;code&gt;注：用匿名类实现接口时，没有构造方法，那么括号中不需要填参数即可。&lt;/code&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;类主体，即匿名类的实现。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;因为匿名类被当做表达式一样被使用，如在定义frenchGreeting对象时，匿名类的全部定义都是该表达式的一部分， 这也解释了为什么匿名类定义的最后要以；结尾，因为表达式以分号；结尾。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;访问外部类的局部变量、声明和使用匿名类成员&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;像局部类一样，匿名类同样也可以俘获变量，对于外部区域的局部变量拥有一样的访问特性。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;匿名类可以访问外部其封闭类的成员&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;匿名类无法访问那些不是final或者effectively final的局部变量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;匿名类中的声明的类型变量，会覆盖掉外部区域中的同名的变量&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;对于匿名类中的成员，匿名类具有跟局部类相同的限制&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;不能在匿名类中声明静态代码块，或者再定义内部成员接口&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;匿名类中仅当变量为常量时，才可以出现静态成员&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;小结，在匿名类中可以声明如下内容&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;列表项目&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;字段&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;额外的方法（即使不实现任何父类的方法）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;实例代码块&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;局部类&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;但是，不可以在匿名类中声明构造方法&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;匿名类的一个实例&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;匿名类在java GUI中使用的较为频繁&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import javafx.event.ActionEvent;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.layout.StackPane;
import javafx.stage.Stage;
 
public class HelloWorld extends Application {
    public static void main(String[] args) {
        launch(args);
    }
    
    @Override
    public void start(Stage primaryStage) {
        primaryStage.setTitle(&quot;Hello World!&quot;);
        Button btn = new Button();
        btn.setText(&quot;Say 'Hello World'&quot;);
        btn.setOnAction(new EventHandler&amp;lt;ActionEvent&amp;gt;() {
 
            @Override
            public void handle(ActionEvent event) {
                System.out.println(&quot;Hello World!&quot;);
            }
        });
        
        StackPane root = new StackPane();
        root.getChildren().add(btn);
        primaryStage.setScene(new Scene(root, 300, 250));
        primaryStage.show();
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在内部类或者方法定义中声明的变量类型跟外围区域有相同的名称，那么内部的声明会覆盖掉外部区域中的声明，不能直接通过变量名拿到外部区域中定义的变量，如下所示：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class ShadowTest {

    public int x = 0;

    class FirstLevel {

        public int x = 1;

        void methodInFirstLevel(int x) {
            System.out.println(&quot;x = &quot; + x);
            System.out.println(&quot;this.x = &quot; + this.x);
            System.out.println(&quot;ShadowTest.this.x = &quot; + ShadowTest.this.x);
        }
    }

    public static void main(String... args) {
        ShadowTest st = new ShadowTest();
        ShadowTest.FirstLevel fl = st.new FirstLevel();
        fl.methodInFirstLevel(23);
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;输出如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
x = 23
this.x = 1
ShadowTest.this.x = 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;示例代码中定义了三个名为x的变量，ShadowTest中的成员变量，内部类FirstLevel中成员变量，以及方法methodInFirstLevel中的参数。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;方法methodInFirstLevel中的x会覆盖掉内部类FirstLevel中的x。因为当你在方法methodInFirstLevel中使用变量x时，实际上使用的的是方法参数的值。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果想引用内部类FirstLevel中的x,需要使用this关键字，来代表引用的时内部类中方法外围的x。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
System.out.println(&quot;this.x = &quot; + this.x);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;如果向引用最外面的基类变量x，则需要指明外部类的类名　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
System.out.println(&quot;ShadowTest.this.x = &quot; + ShadowTest.this.x);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们强烈&lt;strong&gt;不建议&lt;/strong&gt;对内部类、局部类及匿名类，实现序列化。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当Java编译器编译内部类的构造方法时，会生成synthetic constructs。即一些在源码中未曾出现过的类、方法、字段和其他的构造方法也会被编译出来。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;synthetic constructs方式，可以在不改变JVM的前提下，只通过java编译器就可以实现java的新特性。然而，不同的编译器实现synthetic constructs的方式有所不同，这也就意味着，&lt;strong&gt;对于同样的.java源码，不同的编译器会编译出来不同的.class文件。&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;因此，对于一个内部类序列化后，使用不同的JRE进行反序列化的话，可能会存在&lt;strong&gt;兼容性&lt;/strong&gt;的问题。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Fri, 07 Dec 2018 14:34:00 +0000</pubDate>
<dc:creator>翎野</dc:creator>
<og:description>鄙人最近尝试着翻译了自己的第一篇英文技术文档。Java Nested Classes Reference From Oracle Documentation 目录 嵌套类-Nested Cl</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lingyejun/p/10085629.html</dc:identifier>
</item>
<item>
<title>[逆向工程] 二进制拆弹Binary Bombs 快乐拆弹 详解 - Cherrison_Time</title>
<link>http://www.cnblogs.com/Cherrison-Time/p/10085616.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Cherrison-Time/p/10085616.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;二进制拆弹 binary bombs 教你最快速解题,成功拆弹&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;此处头发减n&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;我刚开始做的时候很是懵逼,首先对linux不熟悉,其次汇编嘛,本来就不简单,(&lt;span&gt;Python是世界上最好的语言)&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;首先在开始之前呐,先向大家推荐一个linux下的绘图软件 &lt;span&gt;&lt;span&gt;kolourPaint&lt;/span&gt; 这个有什么用,看我下面的图就知道了&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;把相同的地址标出来,方便自己查找.&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;还有推荐几个GDB 常用命令&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;x/nfq adress /&lt;span&gt;/&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt; &lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;查看地址 n是查看的个数 f 是格式 常用 x 16进制 u 10进制无符号 s 字符串 q 是查看几个字&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;b表示单字节，h表示双字节，w表示四字节，g表示八字节。当我们指定了字节长度后，GDB会从指内存定的内存地址开始，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读写指定字节，并把其当作一个值取出来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    　　　　　b //设置断点 这个很重要&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　ni 单步执行  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　　　info reg //查看寄存器的值&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这是用的比较多的 ,这个链接有更详细的 推荐大家学习一下&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　　　https://blog.csdn.net/delbboy/article/details/8080738&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;再来说一下拆弹的几个小技巧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;1.先看代码里的明码地址,查看一下说不定就是结果&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;2.然后找比较指令,尤其是什么像0xc(%ebp) 0x8(%ebp) 比较你输入的数的指令,有可能这个地方就告诉你结果了呐&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;3.再找输入判断指令,就是判断你输入的是不是符合要求,这样能缩小你要输入的值的范围,就算你不懂,拆答案也方便了&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;4.然后使跳转指令,要跳转到,bomb的指令,前面一般都会有比较指令,这个时候,就能查看相应的内存的数据,查到自己的结果&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了接下来进入正题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;&lt;span&gt;phase_1  :字符串比较&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;&lt;span&gt;这个实验是输入一个字符串，比较与程序里的是否相同，查询明码地址　&lt;/span&gt;0x8049ea4&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;得到字符串&lt;/span&gt;When I get angry, Mr. Bigglesworth gets upset.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;输入后结果正确 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这个实验比较简单,就不细说了&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207221724407-522919359.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;phase_2:  循环&lt;/strong&gt;（&lt;span&gt;图片使用&lt;/span&gt;linux下的KolourPaint制作)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207221733953-542947464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;phase_3:条件分支&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207221750142-1452756865.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;phase_4: &lt;span&gt;递归&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207221809569-846588418.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询地址　&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;０&lt;/span&gt;x804a06f&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以要输入两个参数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207221843722-1087308854.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;phase_5 : &lt;span&gt;指针&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207221852344-1075983356.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;查询地址　&lt;/span&gt;0x8049f20 &lt;span&gt;得到数组元素&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207221859645-438126487.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;phase_6: &lt;span&gt;链表指针结构&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;做前几关的时候还算比较顺利,可以说是运气比较好吧&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;但是在这一关,看到这个汇编代码几乎没有头绪&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;好不容易查出了 ,六个结构体,于是猜测,可能要输入的六个数应该是按照&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;节点值的大小进行排序的结果;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;可是我降序排列,升序排列输入了好几次都不对,???还有什么可能那&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;于是仔细查看了一下代码,发现有一个地方,把输入的数7-&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;5变成2 6变1 &lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;这就是这个的坑所在啊!&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;于是又把之前输入的数 7- 了一次 果然对了;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207221921558-332225413.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;到这里我们可以猜出结构体应该是这样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt; strutc asm{
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; num;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该处的值&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; no;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当前结构体的编号&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; 
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; *next;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;指向下一个元素&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt; 
&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207221932403-1458423998.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查询地址得到&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207221945235-505305917.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;降序排列&lt;/span&gt; 5 2 1 4 6 3 &lt;span&gt;分别&lt;/span&gt;&lt;span&gt;7-&lt;/span&gt; &lt;span&gt;得到&lt;/span&gt;&lt;span&gt;2 5 6 3 1 4&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;隐藏关&lt;/span&gt; &amp;lt;secret_phase&amp;gt;&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;这里终于迎来了我们的大BOSS&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;先来看看怎么进入吧&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207221954016-1178395161.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;进入&lt;/span&gt;phase_defused &lt;span&gt;查看&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;调用了一个判断输入了几个参数的输入函数&lt;/span&gt;,&lt;span&gt;为&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;且第三个参数正确就进入了隐藏关&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207222001488-567648696.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;查询得知&lt;/span&gt; &lt;span&gt;要在第四关&lt;/span&gt; &lt;span&gt;的后面附加的字符串&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207222009136-458801471.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;于是得到结果&lt;/span&gt;0x32 = 50&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入后结果正确&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1531462/201812/1531462-20181207222019583-1746330115.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;至此我们终于解决了我们的大boss,干杯 ,哈哈哈&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;最后说一下解题最强法宝------你的计算机基础课本&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为什么那, 这是你课程的实验,肯定和你所学相关,据我所知用这本书的都有这几个实验,可以说这个实验&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;和这门课这本书是配套的, 书中自有它的解题之道!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;好好看看第三章前40页,你再来做这个实验就会恍然大悟原来是这样啊!&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后希望大家好好学习,取得好成绩 ,一起加油吧!!!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本人水平有限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如有问题,欢迎指正&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 07 Dec 2018 14:27:00 +0000</pubDate>
<dc:creator>Cherrison_Time</dc:creator>
<og:description>二进制拆弹 binary bombs 教你最快速解题,成功拆弹 最近计算机基础课,的实验lab2,二进制拆弹,可以说是拆的我很快乐了(sub n, %hair) 此处头发减n 我刚开始做的时候很是懵逼</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Cherrison-Time/p/10085616.html</dc:identifier>
</item>
<item>
<title>传统的三种排序以及冒泡排序的优化算法 - 渴望成为大牛的男人</title>
<link>http://www.cnblogs.com/bai1218/p/10084571.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bai1218/p/10084571.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;/span&gt;&lt;span&gt;今天听到leader说面试的事，说问一个有两年工作经验的人，传统的三种排序可以手写吗都手写不出来。让我心中也是一颤，其实想想，工作了这么久，对于原生js这块儿真的有些淡忘了，在工作中平时都是用的框架来搞事情，直接拿来就可以用，想想当初刚入这行的时候，那时候就觉得js真的很神奇，可是随着工作时间越来越久，一些东西都是直接拿来用，对于底层的原理也不那么深究了，之前还好，还看看，现在都已经麻木了。今天leader说的这番话，其实你如果说让我手写这三种排序我还是可以写出来的，但是我觉得对于原生js这块儿确实忘了一些，学无止境，不是新的东西就是好的东西，不能忘记最底层的实现，嗯~，写博客写博客，不闲聊了。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;　　对于我们leader今天说的话，我也引入了另外一个知识点，多少和性能优化沾一点边，冒泡排序我们都知道，可你知不知道它还可以进行优化呢，今天我们就来聊一聊传统的三种基本排序算法(选择排序、快排、冒泡)以及关于冒泡排序如何进行优化的三种优化方案&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;&lt;span&gt;　&lt;span&gt;　因为这三种基本的排序算法原理都很简单，所以在思路这块我就不做过多的解释了，我们把重点放在最后的冒泡排序如何优化上面&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;　&lt;span&gt;一、选择排序&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;15.5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;选择排序的思路：比如一个数组arr=[9,6,2,5,10,20,1]进行从小到大排序，我们让每一个数字都和后面的数字进行比较，比自己小的就交换位置，比自己大的就进行下一个比较，将这个数放到相应的位置，下面是代码的实现：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; selectSort(arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; temp;　　　　　&lt;span&gt;//定义一个变量用来操作数字交换
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;arr.length-1;i++&lt;span&gt;){
         &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=i+1;j&amp;lt;arr.length;j++&lt;span&gt;){
             &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[i]&amp;gt;&lt;span&gt;arr[j]){　　　　　　&lt;span&gt;//简单的交换位置逻辑，相信你可以看的懂&lt;/span&gt;
                 temp &lt;/span&gt;=&lt;span&gt; arr[i];
                 arr[i] &lt;/span&gt;=&lt;span&gt; arr[j];
                 arr[j] &lt;/span&gt;=&lt;span&gt; temp;
             }
         }        
         
     }
     &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;h2&gt;　二、快速排序&lt;/h2&gt;
&lt;blockquote readability=&quot;10.5&quot;&gt;
&lt;p&gt;&lt;span&gt;　　快速排序的思路：从一个数组中任意的挑选一个元素（通常来说我们会选择中间的那个元素），将这个元素作为中轴元素，然后把剩下的元素以这个中轴元素的大小作为标准，比中轴元素小的放到左边，比中轴元素大的放到右边，然后把左边和右边的都作为一个数组，重复以上操作，知道子元素的元素个数小于等于1的时候，就证明全部的元素都已经从小到大排好序了（因为只有一个元素的数组一定是有序的，已经不需要再继续排序了），在这个算法中我们主要是用到了了一个递归算法（递归算法不了解的建议可以先去看下这方面的知识），以下是代码的实现：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; quickSort(arr){
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr.length&amp;lt;=1&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取下标&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; midIndex = arr.length%2 == 0?arr.length/2:(arr.length+1)/2&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取中间值&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; mid =&lt;span&gt; arr[midIndex];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义左边的数组&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; left =&lt;span&gt; [];
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义右边的数组&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; right =&lt;span&gt; [];

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;arr.length;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i != midIndex &amp;amp;&amp;amp; arr[i]&amp;lt;=&lt;span&gt;mid){
            left.push(arr[i]);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(i != midIndex &amp;amp;&amp;amp; arr[i]&amp;gt;&lt;span&gt;mid){
            right.push(arr[i]);
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; quickSort(left).concat(mid).concat(quickSort(right))
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;

&lt;h2&gt;    三、冒泡排序&lt;/h2&gt;
&lt;blockquote readability=&quot;7.5&quot;&gt;
&lt;p&gt;&lt;span&gt;　　冒泡排序的思路：顾名思义，冒泡排序，就像冒泡一样，从小往大冒，由于逻辑过于简单，在这里我就直接贴出代码了：&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bubbleSort(arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; temp;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;arr.length;i++&lt;span&gt;){
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;arr.length-i;j++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[j]&amp;gt;arr[j+1&lt;span&gt;]){
                temp &lt;/span&gt;=&lt;span&gt; arr[j];
                arr[j] &lt;/span&gt;= arr[j+1&lt;span&gt;];
                arr[j&lt;/span&gt;+1] =&lt;span&gt; temp;
            }
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;　　通过上面的代码可以看出来，通过两次简单的for循环，并且不加任何判断语句的形式的算法注定是低效的，以下是对冒泡排序算法的三种优化&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2&gt; （1）、当我们对一个数组arr=[9,1,2,3,4,5,6]进行排序的时候，我们正常冒泡排序的话，还是会每个数字都排一次，但事实上我们第一次排序进行完之后，数组就已经变成[1,2,3,4,5,6,9]，已经达到我们想要的效果了，所以已经不需要再进行其他元素的排序了，所以我们要对这种传统的冒泡排序算法做一个优化，思路大概是这样的：我们定义一个flag，当某一次排序中没有发生元素的交换的话，设置flag为false，当flag为false的时候直接结束后面的循环，这样的话数组就不会再进行后面的无意义的排序了，代码实现：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &lt;span&gt;var&lt;/span&gt; arr = [9,1,2,3,4,5,6&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bubbleSort(arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; temp;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; flag;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义flag，用来判断数组是否已经有序&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;arr.length;i++&lt;span&gt;){
        flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们设置flag初始值为true&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;arr.length-i;j++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[j]&amp;gt;arr[j+1&lt;span&gt;]){
                temp &lt;/span&gt;=&lt;span&gt; arr[j];
                arr[j] &lt;/span&gt;= arr[j+1&lt;span&gt;];
                arr[j&lt;/span&gt;+1] =&lt;span&gt; temp;
                flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们自己规定flag为false的时候说明数组需要继续排序&lt;/span&gt;
&lt;span&gt;            }
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们可以规定如果某次循环后flag依然为true的话，表明这次没有进行重新的元素交换，也就是说没有进行重新排序，那么此时数组中元素已经有序了，所以我们可以直接break跳出循环，return出数组&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;（2）、第二种优化是从另一个角度来考虑的，并且也是基于第一次优化的思想，我们每次排序后，数组的后面有一部分已经有序了，所以我们也不需要再和后面已经排好序的元素再进行比较了，我们可以这样做，用一个变量来记录下最后一次发生交换的位置，后面没有发生交换的其实已经有序了，所以可以用这个值来作为一一次我们比较结束时的位置，将会减少很多次没必要的排序过程，代码实现如下：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    &lt;span&gt;var&lt;/span&gt; arr = [9,1,10,5,6,3,0&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; bubbleSort(arr){
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt;&lt;span&gt; temp;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; flag;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义flag，用来判断数组是否已经有序&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; lastindex = 0;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义lastindex，用来判记录每次排好序时的最后一次交换的位置&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; k = arr.length-1;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来和lastindex配合，作为每次循环的边界值，实现不会进行没必要排序的效果&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;arr.length;i++&lt;span&gt;){
        flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们设置flag初始值为true&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;k;j++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(arr[j]&amp;gt;arr[j+1&lt;span&gt;]){
                temp &lt;/span&gt;=&lt;span&gt; arr[j];
                arr[j] &lt;/span&gt;= arr[j+1&lt;span&gt;];
                arr[j&lt;/span&gt;+1] =&lt;span&gt; temp;
                flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们自己规定flag为false的时候说明数组需要继续排序&lt;/span&gt;
                lastindex = j;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;来记录最后一次交换元素的下标&lt;/span&gt;
&lt;span&gt;            }
        }
        k &lt;/span&gt;=&lt;span&gt; lastindex
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(flag){   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;我们可以规定如果某次循环后flag依然为true的话，表明这次没有进行重新的元素交换，也就是说没有进行重新排序，那么此时数组中元素已经有序了，所以我们可以直接break跳出循环，return出数组&lt;/span&gt;
            &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr;
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;  　　在这里我只写了两种优化的方法，可我为什么说有三种呢，是我觉得肯定还会有第三种第四种等等很多，等待着我们后续的思考，做了前端也快三年了，性能优化这块儿在各个方面都有很多，还有原生js也不能丢，我就是说一说自己的一些想法:)，希望同行们（为梦想奋斗中的我们），在使用框架或者一些类库来工作的同时，最底层最原理的东西也不能丢，我自己都不知道我现在在说什么，就是感觉我们不能丢了最原始的东西，好了，今天就到这里了，各位晚安，勿忘初心，方得始终~~~&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 07 Dec 2018 14:23:00 +0000</pubDate>
<dc:creator>渴望成为大牛的男人</dc:creator>
<og:description>因为这三种基本的排序算法原理都很简单，所以在思路这块我就不做过多的解释了，我们把重点放在最后的冒泡排序如何优化上面 一、选择排序 选择排序的思路：比如一个数组arr=[9,6,2,5,10,20,1]</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bai1218/p/10084571.html</dc:identifier>
</item>
<item>
<title>python使用udp实现聊天器 - 张风闲</title>
<link>http://www.cnblogs.com/zhangfengxian/p/python-udp-simple-chat.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangfengxian/p/python-udp-simple-chat.html</guid>
<description>&lt;h2 id=&quot;聊天器简易版&quot;&gt;聊天器简易版&lt;/h2&gt;
&lt;p&gt;使用udp实现一个简单的聊天器程序，要求如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在一个电脑中编写1个程序，有2个功能&lt;/li&gt;
&lt;li&gt;1.获取键盘数据，并将其发送给对方&lt;/li&gt;
&lt;li&gt;2.接收数据并显示&lt;/li&gt;
&lt;li&gt;并且功能数据进行选择以上的2个功能调用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例子程序如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socket


def send_message(udp_socket):
    
        # 输入对方的ip/port
        dest_ip = input(&quot;请输入对方的ip：&quot;)
        dest_port = int(input(&quot;请输入对象的port：&quot;))
    
        # 读取输入的数据
        send_data = input('请输入要发送的数据：')
    
        # 发送数据
        dest_addr = (dest_ip, dest_port)
        udp_socket.sendto(send_data.encode('GBK'), dest_addr)


def recv_message(udp_socket):

        # 接收数据
        recv_data = udp_socket.recvfrom(1000)
        print(&quot;%s:%s&quot; % (recv_data[1], recv_data[0].decode(&quot;utf-8&quot;)))   


def main():
        # 创建套接字
        udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
        while True:
                send_message(udp_socket)
                recv_message(udp_socket)
    
        # 关闭
        udp_socket.close()
    


if __name__ == '__main__':
        main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181207215702429-1240458537.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在聊天助手中进行交互：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181207215342830-1645373684.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;聊天器灵活版&quot;&gt;聊天器灵活版&lt;/h2&gt;
&lt;p&gt;上面实现的聊天虽然可以使用，但是不太方便，我们希望是发送消息还是接受消息，可以自己选择，这样就方便的多。如下的程序运行输入三个命令来选择要执行的操作，程序如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1表示发送数据&lt;/li&gt;
&lt;li&gt;2表示接收数据&lt;/li&gt;
&lt;li&gt;0表示退出&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import socket


def send_message(udp_socket):
    
        # 输入对方的ip/port
        dest_ip = input(&quot;请输入对方的ip：&quot;)
        dest_port = int(input(&quot;请输入对象的port：&quot;))
    
        # 读取输入的数据
        send_data = input('请输入要发送的数据：')
    
        # 发送数据
        dest_addr = (dest_ip, dest_port)
        udp_socket.sendto(send_data.encode('GBK'), dest_addr)


def recv_message(udp_socket):

        # 接收数据
        recv_data = udp_socket.recvfrom(1000)
        print(&quot;%s:%s&quot; % (recv_data[1], recv_data[0].decode(&quot;utf-8&quot;)))   


def main():
        # 创建套接字
        udp_socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    
        while True:
    
                op = input(&quot;请输入您要执行的操作：&quot;)
    
                if op == &quot;1&quot;:
                        send_message(udp_socket)
                elif op == &quot;2&quot;:
                        recv_message(udp_socket)
                elif op == &quot;0&quot;:
                        break
                else:
                        print(&quot;您的输入有误！&quot;)
    
        # 关闭
        udp_socket.close()
    


if __name__ == '__main__':
        main()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;在ubuntu安装网络助手&quot;&gt;在ubuntu安装网络助手&lt;/h2&gt;
&lt;p&gt;将下载好的网络助手的安装包（mNetAssist-release-amd64.deb）拷贝到桌面，执行如下操作：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ cd ~/Desktop
$ sudo dpkg -i mNetAssist-release-amd64.deb
[sudo] password for xxxx:
Selecting previously unselected package mnetassist.
(Reading database ... 182763 files and directories currently installed.)
Preparing to unpack mNetAssist-release-amd64.deb ...
Unpacking mnetassist (0.1.1) ...
Setting up mnetassist (0.1.1) ...
Processing triggers for gnome-menus (3.13.3-6ubuntu3.1) ...
Processing triggers for desktop-file-utils (0.22-1ubuntu5.1) ...
Processing triggers for bamfdaemon (0.5.3~bzr0+16.04.20160824-0ubuntu1) ...
Rebuilding /usr/share/applications/bamf-2.index...
Processing triggers for mime-support (3.59ubuntu1) ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有抱错，安装成功，点击左上角的启动栏，输入&lt;code&gt;mnetAssist&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1156642/201812/1156642-20181207221152227-64727331.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击图标启动应用即可。&lt;/p&gt;
</description>
<pubDate>Fri, 07 Dec 2018 14:14:00 +0000</pubDate>
<dc:creator>张风闲</dc:creator>
<og:description>聊天器简易版 使用udp实现一个简单的聊天器程序，要求如下： 在一个电脑中编写1个程序，有2个功能 1.获取键盘数据，并将其发送给对方 2.接收数据并显示 并且功能数据进行选择以上的2个功能调用 例子</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangfengxian/p/python-udp-simple-chat.html</dc:identifier>
</item>
<item>
<title>Linux性能评估工具 - 流浪使者</title>
<link>http://www.cnblogs.com/dianel/p/10085454.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dianel/p/10085454.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;检测服务器当前的性能，主要检查的项目如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;负载：uptime&lt;/li&gt;
&lt;li&gt;内核信息： dmesg&lt;/li&gt;
&lt;li&gt;内存：vmstat、free&lt;/li&gt;
&lt;li&gt;CPU：top、mpstat、&lt;/li&gt;
&lt;li&gt;I/O：iostat&lt;/li&gt;
&lt;li&gt;网络：sar&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;有些命令需要安装sysstat包&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;负载uptime&quot;&gt;负载：uptime&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;$ uptime 
 22:37:31 up 65 days, 3:15, 1 user, load average: 40.00, 25.01, 10.05&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;uptime&lt;/code&gt;命令可以快速的查看当前的服务器的1分钟、5分钟、15分钟的平均负载情况，它对CPU运行状态和I/O数状态的资源负载的整体的展示。这三个数字几乎依次展示了系统的15分钟之内负载的变化，如上，1分钟的值比15分钟的高，就说明你的系统负载越来越高，此时就需要紧急排查系统的状况了。该工具只是快速查看健康状态的一种手段而已，真正需要确定需要下面的工具查看。&lt;/p&gt;
&lt;h2 id=&quot;查看内核的信息-dmesg&quot;&gt;查看内核的信息： dmesg&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;$ dmesg |tail
[ 2567.534310] IPv6: ADDRCONF(NETDEV_UP): em3: link is not ready
[ 2570.386536] tg3 0000:02:00.0 em3: Link is up at 1000 Mbps, full duplex
[ 2570.386550] tg3 0000:02:00.0 em3: Flow control is off for TX and off for RX
[ 2570.386555] tg3 0000:02:00.0 em3: EEE is disabled
[ 2570.386584] IPv6: ADDRCONF(NETDEV_CHANGE): em3: link becomes ready
[20907.774686] perf: interrupt took too long (2502 &amp;gt; 2500), lowering kernel.perf_event_max_sample_rate to 79000
[50276.167405] perf: interrupt took too long (3173 &amp;gt; 3127), lowering kernel.perf_event_max_sample_rate to 63000
[96662.454537] perf: interrupt took too long (4010 &amp;gt; 3966), lowering kernel.perf_event_max_sample_rate to 49000
[143249.558510] perf: interrupt took too long (5025 &amp;gt; 5012), lowering kernel.perf_event_max_sample_rate to 39000
[204028.503117] perf: interrupt took too long (6286 &amp;gt; 6281), lowering kernel.perf_event_max_sample_rate to 31000&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;dmesg&lt;/code&gt;可以查看设备的一些故障信息。如: TCP丢包，oom-killer错误等。&lt;/p&gt;
&lt;h2 id=&quot;查看内存状态-freevmstat&quot;&gt;查看内存状态： free、vmstat&lt;/h2&gt;
&lt;h3 id=&quot;free-查看内存已用内存剩余内存交换分区等&quot;&gt;free： 查看内存，已用内存，剩余内存、交换分区等&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;$ free -h
    total used free shared buff/cache available
Mem: 7.6G   697M   3.0G   23M   3.9G    6.5G
Swap: 8.0G   0B   8.0G&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过free命令可以查看系统内存的使用状况。要了解Linux对内存利用率，就必须了解Linux对buffer cache和page cache的处理。简单来说，Linux内核会将进程要读取或者写入的数据先保存在内存中形成缓存块，加快下次对该数据的操作，上图中&lt;code&gt;available&lt;/code&gt;更准确显示内存的剩余量。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;buffer cache是对块设备数据的缓存，page cache是对文件数据的缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;swap显示了swap分区的大小，通过调整&lt;code&gt;/proc/sys/vm/swappiness&lt;/code&gt;文件可以调整内存交换到磁盘的积极程度，值为0-100之间的值，值越高，交换就越频繁，如果交换太频繁就会影响系统的性能，默认是60，建议调整为0。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# cat /proc/sys/vm/swappiness 
60
# echo &quot;vm.swappiness = 10&quot; &amp;gt;&amp;gt;/etc/sysctl.conf
# sysctl -p&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;vmstat显示虚拟内存状况的信息&quot;&gt;vmstat：显示虚拟内存状况的信息。&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;$ vmstat 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r b swpd free buff cache si so bi bo in cs us sy id wa st
 0 0 0 3082644 2076 4156120 0 0 1 210 12 9 1 0 99 0 0
 0 0 0 3083180 2076 4156112 0 0 0 473 2231 2420 1 0 99 0 0
 0 0 0 3083212 2076 4156112 0 0 0 12510 3946 3945 1 2 97 0 0
 0 0 0 3083684 2076 4156096 0 0 0 1403 2333 1725 1 0 99 0 0
 1 0 0 3082868 2076 4156388 0 0 0 505 2307 1795 4 1 95 0 0
 0 0 0 3083508 2076 4156040 0 0 0 475 1888 1570 1 1 99 0 0
 0 0 0 3083152 2076 4156040 0 0 0 8090 1694 1910 1 1 99 0 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;vmstat报告有关进程，内存，分页，块IO和cpu活动的信息。&lt;br/&gt;procs:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;r：正在CPU上运行和等待运行的进程数量。    
b：阻塞的进程&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Memory:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;swpd：虚拟内存使用的大小
free：空闲的内存大小
buffer: 用作缓冲的内存大小
cache：用作缓存的内存大小&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Swap:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;si:每秒从交换区写到内存的大小
so:每秒写入到交换区的内存大小&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IO：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;bi:块设备每秒接收的块数量
bo:块设备每秒发送的块数量&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;System:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;in:每秒CPU中断次数
cs:每秒上下文切换的次数，这个值越小越好&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CPU :&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;us:用户的CPU时间
sy:系统内核运行CPU时间
id:空闲的CPU时间
wa:等待IO花费的时间
st:从虚拟机中偷走的时间&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看cpu&quot;&gt;查看CPU：&lt;/h2&gt;
&lt;h3 id=&quot;mpstat查看每个cpu的消耗信息&quot;&gt;mpstat：查看每个CPU的消耗信息&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;$ mpstat -P ALL 1 2
Linux 2.6.32-696.el6.x86_64 (DX_JQ_2) 12/07/2018 _x86_64_   (32 CPU)

01:52:00 PM CPU %usr %nice %sys %iowait %irq %soft %steal %guest %idle
01:52:01 PM all 0.00 0.00 0.03 0.00 0.00 0.00 0.00 0.00 99.97
01:52:01 PM 0 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00
01:52:01 PM 1 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00
01:52:01 PM 2 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00
01:52:01 PM 3 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00
01:52:01 PM 4 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00
01:52:01 PM 5 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00
01:52:01 PM 6 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00
01:52:01 PM 7 0.00 0.00 0.00 0.00 0.00 0.00 0.00 0.00 100.00&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;mpstat&lt;/code&gt;可以实时的查看每个CPU的消耗状况，可以查看每个CPU的分配不均衡的问题。&lt;/p&gt;
&lt;h3 id=&quot;top-查看linux任务信息&quot;&gt;top: 查看Linux任务信息&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;top&lt;/code&gt;命令可以实时的查看Linux系统运行状况，查看系统启动的时间，在线用户，负载，各个进程的状态，CPU，内存，交换分区的状态。可以通过查看top查看每个进程具体的状信息，如，进程的PID，优先级，进程需要的虚拟内存和进程当前使用的内存大小等。&lt;br/&gt;各个字段的含义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;PID:进程ID
PR：任务优先级
NI：nice值，数值越小表示优先级越高
VIRT：进程使用的虚拟内存总量
RES：进程使用的，没有换出的物理内存的大小
SHR：共享内存的大小
S：进程状态。D:不可中断的睡眠状态 R:运行 S:睡眠 T:跟踪/停止  Z:僵尸进程
%CPU: 占用的CPU时间比
%MEM：进程所使用的物理内存百分比
TIME+:进程使用的CPU时间总计
COMMAND:命令行&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看ioiostat&quot;&gt;查看IO：iostat&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# iostat -xz 1 
Linux 2.6.32-696.el6.x86_64 (DX_JQ_2) 12/07/2018 _x86_64_   (32 CPU)

avg-cpu: %user %nice %system %iowait %steal %idle
           0.05 0.00 0.07 0.01 0.00 99.87

Device: rrqm/s wrqm/s r/s w/s rsec/s wsec/s avgrq-sz avgqu-sz await r_await w_await svctm %util
sda 0.00 3.29 0.02 1.13 1.28 35.30 31.88 0.02 20.90 7.84 21.13 5.19 0.60
dm-0 0.00 0.00 0.02 4.41 1.27 35.29 8.25 0.07 14.68 8.78 14.70 1.34 0.60

avg-cpu: %user %nice %system %iowait %steal %idle
           0.06 0.00 0.06 0.00 0.00 99.87&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Linux中可以通过iostat查看系统的IO状态。r/s, w/s, rkB/s, wkB/s: 这些是该设备每秒读％、写％、读Kb、写Kb。可用于描述工作负荷。&lt;/p&gt;
&lt;h2 id=&quot;查看网卡sar&quot;&gt;查看网卡：sar&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;# sar -n DEV 1
Linux 2.6.32-696.el6.x86_64 (DX_JQ_2) 12/07/2018 _x86_64_   (32 CPU)

02:28:00 PM IFACE rxpck/s txpck/s rxkB/s txkB/s rxcmp/s txcmp/s rxmcst/s
02:28:01 PM lo 20.00 20.00 2.33 2.33 0.00 0.00 0.00
02:28:01 PM em1 21.00 39.00 1.47 9.24 0.00 0.00 4.00
02:28:01 PM em2 89.00 39.00 49.84 8.36 0.00 0.00 29.00
02:28:01 PM em3 0.00 0.00 0.00 0.00 0.00 0.00 0.00
02:28:01 PM em4 1.00 0.00 0.12 0.00 0.00 0.00 1.00
02:28:01 PM bond0 110.00 78.00 51.31 17.60 0.00 0.00 33.00
02:28:01 PM bond1 1.00 0.00 0.12 0.00 0.00 0.00 1.00&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用sar查看网络接口的吞吐量。通过 sar 命令可以全面的获取系统的 CPU、运行队列、磁盘 I/O、交换区、内存、 cpu 中断、网络等性能数据。&lt;br/&gt;|命令|说明|&lt;br/&gt;|---|---|&lt;br/&gt;|sar -u 1 3|查看CPU|&lt;br/&gt;|sar -r 1 3|查看内存和交互空间|&lt;br/&gt;|sar -B 1 3|查看内存分页|&lt;br/&gt;|sar -b 1 3|查看I/O速率|&lt;br/&gt;|sar -q 1 3|查看进程队列长度和平均负载状态|&lt;br/&gt;|sar -W 1 3|查看系统交互活动信息|&lt;/p&gt;
</description>
<pubDate>Fri, 07 Dec 2018 13:51:00 +0000</pubDate>
<dc:creator>流浪使者</dc:creator>
<og:description>[TOC] 介绍 检测服务器当前的性能，主要检查的项目如下： 负载：uptime 内核信息： dmesg 内存：vmstat、free CPU：top、mpstat、 I/O：iostat 网络：sa</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dianel/p/10085454.html</dc:identifier>
</item>
<item>
<title>数据清洗(一)：关联数据的替换 - Magic激流</title>
<link>http://www.cnblogs.com/magicxyx/p/10085440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/magicxyx/p/10085440.html</guid>
<description>&lt;p&gt;    有时我们的数据里充满了各种简写或标记，而在处理、展示数据的过程中，我们需要的是数据各字段的详细名称，因此就需要对我们的数据集进行清洗与处理。前些天遇到一个某图书馆借阅数据，给出的要求是统计借阅图书的类别，数据里有每次借阅书籍的&lt;a href=&quot;http://ztflh.xhma.com/&quot;&gt;中图分类号&lt;/a&gt;，如&quot;A122&quot;,'A'表示马列毛邓,'A1'表示马克思恩格斯著作,'A12'表示单行著作,'A122'表示1848~1863年间。每一本书都有一个独立的分类号，按照需求只需要对分类号的第一个字母，也即分类号一级索引进行统计，并将统计结果里的字母用中文替换。因此这是一个入门级别的小任务，用Python就可以轻易的实现。&lt;/p&gt;


&lt;h2&gt;    1.1 源文件&lt;/h2&gt;
&lt;p&gt;        源文件是一个80万行的Excel(囧)，索引号在某一列下，我需要处理的数据大概有四万行。将其导入至sourceData.csv文件，便于读取，数据格式如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201812/1219242-20181207214659283-1810055729.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;    1.2 分类号-中文映射文件&lt;/h2&gt;
&lt;p&gt;        在百度上查询得到各分类号与中文名称之间的对应关系，存放在'中图分类法.txt'文件中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201812/1219242-20181207214659702-1178366724.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;    1.3 源代码&lt;/h2&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;with open(&lt;span&gt;'&lt;/span&gt;&lt;/span&gt;&lt;span&gt;中图分类法&lt;/span&gt;&lt;span&gt;.txt'&lt;span&gt;, &lt;span&gt;'r'&lt;span&gt;,encoding=&lt;span&gt;'GBK'&lt;span&gt;, errors=&lt;span&gt;'ignore'&lt;span&gt;) as f:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    bookFile = f.readlines()  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;# print(bookFile)&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;with open(&lt;span&gt;'sourceData.csv'&lt;span&gt;, &lt;span&gt;'r'&lt;span&gt;,encoding=&lt;span&gt;'GBK'&lt;span&gt;, errors=&lt;span&gt;'ignore'&lt;span&gt;) as f:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    dataFile = f.readlines()  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;# print(dataFile)&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;    2.1 提取一级索引号&lt;/h2&gt;
&lt;p&gt;        我们按行读取的数据形如&quot;&lt;span&gt;I267/121&lt;/span&gt;&quot;，而我们只需要最开始的字母，因此提取每行第一个元素即可。统计词频我们可以声明一个字典变量，将每一个一级索引作为一个key,如果字典里有该key,则值+1，否则创建key.&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;newdict = {}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt; line &lt;span&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;span&gt; dataFile:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;# print(line[0])&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; line[0] &lt;span&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;span&gt; newdict:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        newdict[line[0]] += 1  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        newdict[line[0]] = 1  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;    2.2 字典排序&lt;/h2&gt;
&lt;p&gt;        为了后面能直观地看出各类别图书借阅数量的异同，我们在此将该字典按照值的大小降序排列。在此需要用上&lt;span&gt;&lt;span&gt;&lt;em&gt;sorted(dic,value,reverse)&lt;/em&gt;&lt;/span&gt;&lt;span&gt;函数。由于&lt;/span&gt;&lt;span&gt;sorted&lt;/span&gt;&lt;span&gt;函数并不改变原字典，所以需要接受该函数的返回值——排列后的列表。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;sortedDict = sorted(newdict.items(),key = &lt;span&gt;&lt;strong&gt;lambda&lt;/strong&gt;&lt;span&gt; x:x[1],reverse = True)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;    3.1 分类号数据字典化&lt;/h2&gt;
&lt;p&gt;        由于分类号及其对应关系的数据为一行以逗号','隔开的文本，所以需要将其转换成字典。该数据行形如'A,马列毛邓'，结尾还有一个换行符，为了将其变为字典，就需要在剔除换行符的情况下以逗号将其分隔为两个字符串。&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;dict = {}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt; line &lt;span&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;span&gt; bookFile:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;#print(line.strip().split(','))&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    dict[line.strip().split(&lt;span&gt;','&lt;span&gt;)[0]] = line.strip().split(&lt;span&gt;','&lt;span&gt;)[1]  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(dict)  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;    3.2 字符与文本的映射&lt;/h2&gt;
&lt;p&gt;        所以我们现在有两个变量，一个是存储了分类号与其对应中文的字典：{'A': '马列毛邓', 'B': '哲学宗教'...}，一个是排序好的列表，列表元素为索引号及出现次数。我们现在需要将索引号替换为字典中对应索引号的值，将结果用两个变量表示（方便后面画图）。&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;attr = []  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;v1 = []  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt; class2 &lt;span&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;span&gt; sortedDict:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;# print(class2[0]+str(class2[1]))&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt; class2[0] &lt;span&gt;&lt;strong&gt;in&lt;/strong&gt;&lt;span&gt; dict:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        attr.append(dict[class2[0]])  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        v1.append(class2[1])  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(attr)  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;&lt;span&gt;(v1)  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;        结果如下(部分)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201812/1219242-20181207214659933-908160210.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;    这里我用到了第三方库&lt;a href=&quot;http://pyecharts.org/&quot;&gt;pyecharts&lt;/a&gt;，这个库&lt;span&gt;是一个生成Echarts图表的python类库，功能强大，图表也美观。利用该库画图除了可参考&lt;a href=&quot;http://pyecharts.org/&quot;&gt;官方文档&lt;/a&gt;之外，还可参考&lt;a href=&quot;https://blog.csdn.net/qq_31967985/article/details/79975663&quot;&gt;这篇——各种图表的详细代码&lt;/a&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;bar = Bar(&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;条形图&lt;/span&gt;&lt;span&gt;&lt;span&gt;&quot;&lt;span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;各类别图书的教师借阅次数&lt;/span&gt;&lt;span&gt;&quot;&lt;span&gt;,width=1400, height=700)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;bar.add(&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;借阅次数统计图&lt;/span&gt;&lt;span&gt;&quot;&lt;span&gt;,attr,v1,mark_point=[&lt;span&gt;&quot;min&quot;&lt;span&gt;, &lt;span&gt;&quot;max&quot;&lt;span&gt;],is_label_show=True,xaxis_interval=0,xaxis_rotate=-30,is_more_utils=True)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;bar.render()  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;    第二、三个参数为坐标轴的值。运行后在源码所在目录生成一个网页，里面就是动态的可视化图表。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201812/1219242-20181207214700397-1596749117.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 07 Dec 2018 13:47:00 +0000</pubDate>
<dc:creator>Magic激流</dc:creator>
<og:description>有时我们的数据里充满了各种简写或标记，而在处理、展示数据的过程中，我们需要的是数据各字段的详细名称，因此就需要对我们的数据集进行清洗与处理。前些天遇到一个某图书馆借阅数据，给出的要求是统计借阅图书的类</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/magicxyx/p/10085440.html</dc:identifier>
</item>
<item>
<title>一起学爬虫——如何爬取通过ajax加载数据的网站 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/10085424.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/10085424.html</guid>
<description>&lt;p&gt;目前很多网站都使用ajax技术动态加载数据，和常规的网站不一样，数据时动态加载的，如果我们使用常规的方法爬取网页，得到的只是一堆html代码，没有任何的数据。&lt;/p&gt;
&lt;p&gt;请看下面的代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;url = 'https://www.toutiao.com/search/?keyword=美女'
headers = {&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0&quot;}

response = requests.get(url,headers=headers)
print(response.text)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码是爬取今日头条的一个网页，并打印出get方法返回的文本内容如下图所示，值现在一堆网页代码，并没有相关的头条新闻信息&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/pythonajax1.png&quot; title=&quot;python ajax&quot; alt=&quot;python ajax&quot;/&gt;&lt;/p&gt;
&lt;p&gt;内容过多，只截取部分内容，有兴趣的朋友可以执行上面的代码看下效果。&lt;/p&gt;
&lt;p&gt;对于使用ajax动态加载数据的网页要怎么爬取呢？我们先看下近日头条是如何使用ajax加载数据的。通过chrome的开发者工具来看数据加载过程。&lt;/p&gt;
&lt;p&gt;首先打开chrome浏览器，打开开发者工具，点击Network选项，点击XHR选项，然后输入网址：&lt;a href=&quot;https://www.toutiao.com/search/?keyword=%E7%BE%8E%E5%A5%B3&quot; class=&quot;uri&quot;&gt;https://www.toutiao.com/search/?keyword=美女&lt;/a&gt; ，点击Preview选项卡，就会看到通过ajax请求返回的数据，Name那一栏就是ajax请求，当鼠标向下滑动时，就会出现多条ajax请求：&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/pythonajax2.png&quot; title=&quot;python ajax&quot; alt=&quot;python ajax&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上图我们知道ajax请求返回的是json数据，我们继续分析ajax请求返回的json数据，点击data展开数据，接着点击0展开数据，发现有个title字段，内容刚好和网页的第一条数据匹配，可知这就是我们要爬取的数据。如下所示：&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/pythonajax3.png&quot; title=&quot;python ajax&quot; alt=&quot;python ajax&quot;/&gt;&lt;/p&gt;
&lt;p&gt;鼠标向下滚动到网页底部时就会触发一次ajax请求，下面是三次ajax请求：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://www.toutiao.com/search_content/?offset=0&amp;amp;format=json&amp;amp;keyword=%E7%BE%8E%E5%A5%B3&amp;amp;autoload=true&amp;amp;count=20&amp;amp;cur_tab=1&amp;amp;from=search_tab&amp;amp;pd=synthesis
https://www.toutiao.com/search_content/?offset=20&amp;amp;format=json&amp;amp;keyword=%E7%BE%8E%E5%A5%B3&amp;amp;autoload=true&amp;amp;count=20&amp;amp;cur_tab=1&amp;amp;from=search_tab&amp;amp;pd=synthesis
https://www.toutiao.com/search_content/?offset=40&amp;amp;format=json&amp;amp;keyword=%E7%BE%8E%E5%A5%B3&amp;amp;autoload=true&amp;amp;count=20&amp;amp;cur_tab=1&amp;amp;from=search_tab&amp;amp;pd=synthesis&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察每个ajax请求，发现每个ajax请求都有offset,format,keyword,autoload,count,cur_tab,from,pd参数，除了offset参数有变化之外，其他的都不变化。每次ajax请求offset的参数变化规律是0,20,40,60...，可以推测offset是偏移量，count参数是一次ajax请求返回数据的条数。&lt;/p&gt;
&lt;p&gt;为了防止爬虫被封，每次请求时要把请求时都要传递请求头信息，请求头信息中包含了浏览器的信息，如果请求没有浏览器信息，就认为是网络爬虫，直接拒绝访问。request header信息如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;headers = {
&quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0&quot;,
&quot;referer&quot;: &quot;https://www.toutiao.com/search/?keyword=%E7%BE%8E%E5%A5%B3&quot;,
'x-requested-with': 'XMLHttpRequest'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;完整代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import requests
from urllib.parse import urlencode

def parse_ajax_web(offset):
    url = 'https://www.toutiao.com/search_content/?'
    #请求头信息
    headers = {
        &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3029.110 Safari/537.36 SE 2.X MetaSr 1.0&quot;,
        &quot;referer&quot;: &quot;https://www.toutiao.com/search/&quot;,
        'x-requested-with': 'XMLHttpRequest'
    }
    #每个ajax请求要传递的参数
    parm = {
        'offset': offset,
        'format': 'json',
        'keyword': '美女',
        'autoload': 'true',
        'count': 20,
        'cur_tab': 1,
        'from': 'search_tab',
        'pd': 'synthesis'
    }
    #构造ajax请求url
    ajax_url = url + urlencode(parm)
    #调用ajax请求
    response = requests.get(ajax_url, headers=headers)
    #ajax请求返回的是json数据，通过调用json()方法得到json数据
    json = response.json()
    data = json.get('data')
    for item in data:
        if item.get('title') is not None:
            print(item.get('title'))

def main():
    #调用ajax的次数，这里调用5次。
    for offset in (range(0,5)):
        parse_ajax_web(offset*20)

if __name__ == '__main__':
    main()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面是爬取通过ajax请求加载数据网站的例子，如果想要其他的数据，可以动手自己写，这里只是搭了一个架子，各位可以尝试将数据写入到excel或者数据库中。&lt;/p&gt;
</description>
<pubDate>Fri, 07 Dec 2018 13:44:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>目前很多网站都使用ajax技术动态加载数据，和常规的网站不一样，数据时动态加载的，如果我们使用常规的方法爬取网页，得到的只是一堆html代码，没有任何的数据。 请看下面的代码： 上面的代码是爬取今日头</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/10085424.html</dc:identifier>
</item>
<item>
<title>用Emit技术替代反射 - Fode</title>
<link>http://www.cnblogs.com/fode/p/10085407.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fode/p/10085407.html</guid>
<description>&lt;p&gt;&lt;span&gt;　　之前在上篇博客说到用表达式来替代反射机制，可以获得较高的性能提升。这篇我们来说说用Emit技术来替代反射。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　System.Reflection.Emit命名空间类可用于动态发出Microsoft中间语言（MSIL）代码，以便生成的代码可以直接执行。反射也用于获取有关类及其成员的信息。换句话说，反射是一种技术，允许您检查描述类型及其成员的元数据，你可能以编&lt;/span&gt;&lt;span&gt;程方式访问过组件对象模型类型库， .NET中的反射非常相似，但功能强大且易于使用。使用.NET编译器编译源文件时，编译器会产生源文件中语句中的MSIL代码以及描述文件中定义的类型的元数据。正是这个元数据，.NET中的反射API使你能够检&lt;/span&gt;&lt;span&gt;查。在这个System.Reflection命名空间中，有一些类可用于帮助访问程序中固有的结构，比如类、类型、字段、结构、枚举、成员和方法。例如，您使用Type类来标识所反映的类的类型，FieldInfo类表示结构或枚举的字段。MemberInfo类表示反射类的成员，并使用MethodInfo类表示反射类的方法。PrimeRealFipe类表示反射类中的方法的参数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;span&gt;使用System.Reflection.Emit命名空间类在可以编译时创建代码，但前提是必须懂&lt;a href=&quot;https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.opcodes?view=netframework-4.7.2&quot;&gt;IL代码&lt;/a&gt;。(本文不做IL代码详解，因为我也不会。。。)事实上，你实际编写的是就是幕后的MSIL本身。你可以使用反射在内存中定义程序集，为该程序集创建类/模块，然后为该模块创建其他模块成员和新类型。你同样也可以使用Emit来构造程序集。Reflection.Emit是一个强大的命名空间，我们可以在运行时动态地发出瞬态和持久化程序集。Reflection.Emit产生一个低级，语言中立的MSIL。通常，我们通过将源代码保存到磁盘然后编译该源代码来创建程序集,然后我们调用我们需要从该程序集中使用的类的方法，该程序集是在磁盘上编译的。但是你可以想象，这涉及额外的磁盘写入和读取工作！使用反射生成代码，我们可以省略此开销并立即将操作代码直接发送到内存中。反射发射只不过是直接在代码中编写任何汇编代码，然后即时调用生成的代码。这也并不是说反射效率就是高，因为在运行期产生指令也是需要时间，各有优缺点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　System.Reflection.Emit命名空间提供用户动态创建.exe文件所需的类。它的类允许编译器或工具发出元数据和MSIL。因此，您可以动态地在磁盘上创建.exe文件，就像运行代码，保存代码并调用编译器来编译代码一样。大多数情况&lt;/span&gt;&lt;span&gt;下，您需要此功能和此命名空间用于自定义脚本引擎和编译器。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Reflection.Emit命名空间有许多可用于重要的的类。以下是两个最重要的：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;AssemblyBuilder类是在运行时发出代码并具有创建动态模块的方法的任何应用程序的起点。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ModuleBuilder类用作在运行时向动态程序集添加类和结构等类型的起点。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　生成MSIL指令的ILGenerator.OpCodes类包括其所需字段中的所有IL指令。MSIL是CLR或中间语言的基本汇编语言的无类型操作代码。当您编写任何C＃代码并对其进行编译时，它将首先转换为MSIL。然后，当您在MSIL中调用程序集时，它将以相应的机器语言进行转换和执行。学习MSIL的最简单方法是反汇编您编译的简单代码。您可以使用.NET SDK实用程序之一ILDasm.exe（IL反汇编程序）在Vs插件库下载即可，来反汇编任何已编译的.NET代码。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　本文通过Emit技术来提高后期绑定对象的性能，尽管您不能像硬绑定那样快速执行调用，但执行效果会比在运行时产生代码在绑定更好。代码基本与前篇博客&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_0&quot; href=&quot;https://www.cnblogs.com/fode/p/10079630.html&quot;&gt;用lambda表达式树替代反射&lt;/a&gt;基本一样，核心代码替换过来即可，如下：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;73&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
    public class PropertyEmit
    {

        private PropertySetterEmit setter;
        private PropertyGetterEmit getter;
        public String PropertyName { get; private set; }
        public PropertyInfo Info { get; private set; }

        public PropertyEmit(PropertyInfo propertyInfo)
        {
            if (propertyInfo == null)
            {
                throw new ArgumentNullException(&quot;属性不能为空&quot;);
            }

            if (propertyInfo.CanWrite)
            {
                setter = new PropertySetterEmit(propertyInfo);
            }

            if (propertyInfo.CanRead)
            {
                getter = new PropertyGetterEmit(propertyInfo);
            }

            this.PropertyName = propertyInfo.Name;
            this.Info = propertyInfo;
        }


        /// &amp;lt;summary&amp;gt;
        /// 属性赋值操作（Emit技术）
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;instance&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;value&quot;&amp;gt;&amp;lt;/param&amp;gt;
        public void SetValue(Object instance,Object value)
        {
            this.setter?.Invoke(instance, value);
        }

        /// &amp;lt;summary&amp;gt;
        /// 属性取值操作(Emit技术)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;instance&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public Object GetValue(Object instance)
        {
            return this.getter?.Invoke(instance);
        }

        private static readonly ConcurrentDictionary&amp;lt;Type, PropertyEmit[]&amp;gt; securityCache = new ConcurrentDictionary&amp;lt;Type, PropertyEmit[]&amp;gt;();

        /// &amp;lt;summary&amp;gt;
        /// 获取对象属性
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;type&quot;&amp;gt;对象类型&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static PropertyEmit[] GetProperties(Type type)
        {
            return securityCache.GetOrAdd(type, t =&amp;gt; t.GetProperties().Select(p =&amp;gt; new PropertyEmit(p)).ToArray());
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// Emit 动态构造 Get方法
    /// &amp;lt;/summary&amp;gt;
    public  class PropertyGetterEmit
    {

        private readonly Func&amp;lt;Object, Object&amp;gt; getter;
        public PropertyGetterEmit(PropertyInfo propertyInfo)
        {
            //Objcet value = Obj.GetValue(Object instance);
            if (propertyInfo == null)
            {
                throw new ArgumentNullException(&quot;propertyInfo&quot;);
            }
            this.getter = CreateGetterEmit(propertyInfo);

        }

        public Object Invoke(Object instance)
        {
            return getter?.Invoke(instance);
        }

        private Func&amp;lt;Object, Object&amp;gt; CreateGetterEmit(PropertyInfo property)
        {
            if (property == null)
                throw new ArgumentNullException(&quot;property&quot;);

            MethodInfo getMethod = property.GetGetMethod(true);

            DynamicMethod dm = new DynamicMethod(&quot;PropertyGetter&quot;, typeof(Object),
                new Type[] { typeof(Object) },
                property.DeclaringType, true);

            ILGenerator il = dm.GetILGenerator();

            if (!getMethod.IsStatic)
            {
                il.Emit(OpCodes.Ldarg_0);
                il.EmitCall(OpCodes.Callvirt, getMethod, null);
            }
            else
                il.EmitCall(OpCodes.Call, getMethod, null);

            if (property.PropertyType.IsValueType)
                il.Emit(OpCodes.Box, property.PropertyType);
            il.Emit(OpCodes.Ret);
            return (Func&amp;lt;Object, Object&amp;gt;)dm.CreateDelegate(typeof(Func&amp;lt;Object, Object&amp;gt;));
        }
    }

    /// &amp;lt;summary&amp;gt;
    /// Emit动态构造Set方法
    /// &amp;lt;/summary&amp;gt;
    public class PropertySetterEmit
    {
        private readonly Action&amp;lt;Object, Object&amp;gt; setFunc;
        public PropertySetterEmit(PropertyInfo propertyInfo)
        {
            //Obj.Set(Object instance,Object value)
            if (propertyInfo == null)
            {
                throw new ArgumentNullException(&quot;propertyInfo&quot;);
            }
            this.setFunc = CreatePropertySetter(propertyInfo);

        }

        private Action&amp;lt;Object, Object&amp;gt; CreatePropertySetter(PropertyInfo property)
        {
            if (property == null)
                throw new ArgumentNullException(&quot;property&quot;);

            MethodInfo setMethod = property.GetSetMethod(true);

            DynamicMethod dm = new DynamicMethod(&quot;PropertySetter&quot;, null,
                new Type[] { typeof(Object), typeof(Object) }, property.DeclaringType, true);

            ILGenerator il = dm.GetILGenerator();

            if (!setMethod.IsStatic)
            {
                il.Emit(OpCodes.Ldarg_0);
            }
            il.Emit(OpCodes.Ldarg_1);

            EmitCastToReference(il, property.PropertyType);
            if (!setMethod.IsStatic &amp;amp;&amp;amp; !property.DeclaringType.IsValueType)
            {
                il.EmitCall(OpCodes.Callvirt, setMethod, null);
            }
            else
                il.EmitCall(OpCodes.Call, setMethod, null);

            il.Emit(OpCodes.Ret);
            return (Action&amp;lt;Object, Object&amp;gt;)dm.CreateDelegate(typeof(Action&amp;lt;Object, Object&amp;gt;));
        }

        private static void EmitCastToReference(ILGenerator il, Type type)
        {
            if (type.IsValueType)
                il.Emit(OpCodes.Unbox_Any, type);
            else
                il.Emit(OpCodes.Castclass, type);
        }

        public void Invoke(Object instance,Object value)
        {
            this.setFunc?.Invoke(instance, value);
        }
    }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　与表达式一起对比，其测试代码如下：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
            Student student = &lt;span&gt;new&lt;/span&gt; Student(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;学生对象，里面有一个Name属性&lt;/span&gt;
            PropertyInfo propertyInfo =&lt;span&gt; student.GetType().GetProperty(nameof(student.Name));
            Property PropertyExp &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Property(propertyInfo);
            PropertyEmit propertyEmit &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyEmit(propertyInfo);

            Int32 loopCount &lt;/span&gt;= &lt;span&gt;1000000&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行次数&lt;/span&gt;
            CodeTimer.Initialize();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;测试环境初始化&lt;/span&gt;
&lt;span&gt;

            CodeTimer.Time(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;基础反射&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, loopCount, () =&amp;gt;&lt;span&gt; { 
                propertyInfo.SetValue(student, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
            });
            CodeTimer.Time(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;lambda表达式树&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, loopCount, () =&amp;gt;&lt;span&gt; {
                PropertyExp.SetValue(student, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
            CodeTimer.Time(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Emit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,loopCount,()=&amp;gt;&lt;span&gt; {
                propertyEmit.SetValue(student, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
            CodeTimer.Time(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;直接赋值&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, loopCount, () =&amp;gt;&lt;span&gt; {
                student.Name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Fode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            });
            Console.ReadKey();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;测试效果图如下：表达式与Emit速度基本相同，将我上述的方法CreatePropertySetter改成静态会比表达式快一点。在使用的过程中，最好将其封装成一个静态泛型类缓存起来，一直new PropertyEmit这个对象反而效率会很低。&lt;a href=&quot;https://pan.baidu.com/s/1vdVWJHMMAdxSvVv00saugw&quot;&gt;代码下载&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1492898/201812/1492898-20181207212438342-562301335.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文章结尾在分享几个我认为写得不错，可能对大家有帮助的文章：&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/vwxyzh/archive/2009/11/12/1601724.html&quot;&gt;从IDataReader中读取数据实体&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 07 Dec 2018 13:40:00 +0000</pubDate>
<dc:creator>Fode</dc:creator>
<og:description>之前在上篇博客说到用表达式来替代反射机制，可以获得较高的性能提升。这篇我们来说说用Emit技术来替代反射。 System.Reflection.Emit命名空间类可用于动态发出Microsoft中间语</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fode/p/10085407.html</dc:identifier>
</item>
</channel>
</rss>