<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Spring MVC源码——Root WebApplicationContext - 胡峻峥</title>
<link>http://www.cnblogs.com/hujunzheng/p/10819473.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/10819473.html</guid>
<description>&lt;h2 id=&quot;spring-mvc源码root-webapplicationcontext&quot;&gt;Spring MVC源码——Root WebApplicationContext&lt;/h2&gt;
&lt;p&gt;　　打算开始读一些框架的源码,先拿 Spring MVC 练练手,欢迎&lt;a href=&quot;https://github.com/FJHHH/spring-framework&quot;&gt;点击这里&lt;/a&gt;访问我的源码注释, SpringMVC&lt;a href=&quot;https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-servlet-context-hierarchy&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;一开始就给出了这样的两段示例:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MyWebApplicationInitializer &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; WebApplicationInitializer {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onStartup(ServletContext servletCxt) {

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Load Spring web application configuration&lt;/span&gt;
        AnnotationConfigWebApplicationContext ac = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AnnotationConfigWebApplicationContext();
        ac.register(AppConfig.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        ac.refresh();

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Create and register the DispatcherServlet&lt;/span&gt;
        DispatcherServlet servlet = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DispatcherServlet(ac);
        ServletRegistration.Dynamic registration &lt;/span&gt;= servletCxt.addServlet(&quot;app&quot;&lt;span&gt;, servlet);
        registration.setLoadOnStartup(&lt;/span&gt;1&lt;span&gt;);
        registration.addMapping(&lt;/span&gt;&quot;/app/*&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;web.xml 示例:&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;listener-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.context.ContextLoaderListener&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;listener-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;context-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/WEB-INF/app-context.xml&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;context-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;app&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.servlet.DispatcherServlet&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;contextConfigLocation&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;load-on-startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;load-on-startup&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;app&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/app/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;servlet-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;

&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;我们按照 web.xml 中的实例来看一下 Spring MVC 初始化过程.&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;上下文层次结构&quot;&gt;上下文层次结构&lt;/h2&gt;
&lt;p&gt;　　Spring MVC 的上下文有如下这样的层级:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://pics-1257963040.cos.ap-shanghai.myqcloud.com/20190429211301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图中的 &lt;code&gt;Servlet WebApplicationContext&lt;/code&gt; 是与 &lt;code&gt;DispatcherServlet&lt;/code&gt; 绑定的上下文, 其中还有 controllers、ViewResolver、HandlerMapping 等组件.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Root WebApplicationContext&lt;/code&gt; 不是必须的上下文, 在需要时,可以用来在多个 &lt;code&gt;DispatcherServlet&lt;/code&gt; 间共享一些 bean.&lt;/p&gt;
&lt;h2 id=&quot;root-webapplicationcontext-初始化和销毁&quot;&gt;Root WebApplicationContext 初始化和销毁&lt;/h2&gt;
&lt;h3 id=&quot;contextloaderlistener&quot;&gt;　　ContextLoaderListener&lt;/h3&gt;
&lt;p&gt;　　web.xml 中配置的 &lt;code&gt;ContextLoaderListener&lt;/code&gt; 用于启动和终止 Spring 的 root &lt;code&gt;WebApplicationContext&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://pics-1257963040.cos.ap-shanghai.myqcloud.com/20190429213409.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;　　 ContextLoaderListener&lt;/span&gt;&lt;/h3&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ContextLoaderListener &lt;span&gt;extends&lt;/span&gt; ContextLoader &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ServletContextListener {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ContextLoaderListener() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ContextLoaderListener(WebApplicationContext context) {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(context);
    }
    
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Initialize the root web application context.
     * Servlet 上下文初始化,调用父类的方法初始化 WebApplicationContext
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextInitialized(ServletContextEvent event) {
        initWebApplicationContext(event.getServletContext());
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Close the root web application context.
     * Servlet 上下文被销毁,调用父类的方法销毁 WebApplicationContext
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextDestroyed(ServletContextEvent event) {
        closeWebApplicationContext(event.getServletContext());
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 销毁 ServletContext 上实现了 DisposableBean 的属性并移除他们&lt;/span&gt;
&lt;span&gt;        ContextCleanupListener.cleanupAttributes(event.getServletContext());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;ContextLoaderListener&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;直接调用了父类&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;code&gt;ContextLoader&lt;/code&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;的方法来初始化和销毁上下文.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ContextLoaderListener&lt;/code&gt; 在创建上下文时,会尝试读取 &lt;code&gt;contextClass&lt;/code&gt; context-param 来指定上下文的类型,被指定的类需要实现 &lt;code&gt;ConfigurableWebApplicationContext&lt;/code&gt; 接口. 如果没有获取到,默认会使用 &lt;code&gt;WebApplicationContext&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;初始化上下文时,会尝试读取 &lt;code&gt;contextConfigLocation&lt;/code&gt; context-param, 作为 xml 文件的路径.&lt;/p&gt;
&lt;h3 id=&quot;初始化上下文&quot;&gt;　　初始化上下文&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;initWebApplicationContext()&lt;/code&gt; 方法如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; WebApplicationContext initWebApplicationContext(ServletContext servletContext) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查有没有绑定上下文&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (servletContext.getAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(
                &lt;/span&gt;&quot;Cannot initialize context because there is already a root application context present - &quot; +
                &quot;check whether you have multiple ContextLoader* definitions in your web.xml!&quot;&lt;span&gt;);
    }

    servletContext.log(&lt;/span&gt;&quot;Initializing Spring root WebApplicationContext&quot;&lt;span&gt;);
    Log logger &lt;/span&gt;= LogFactory.getLog(ContextLoader.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
        logger.info(&lt;/span&gt;&quot;Root WebApplicationContext: initialization started&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化开始时间&lt;/span&gt;
    &lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();

    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Store context in local instance variable, to guarantee that
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; it is available on ServletContext shutdown.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存上下文到本地实例变量中，保证上细纹能在 ServletContext 关闭时访问到&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.context == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建上下文&lt;/span&gt;
            &lt;span&gt;this&lt;/span&gt;.context =&lt;span&gt; createWebApplicationContext(servletContext);
        }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.context &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ConfigurableWebApplicationContext) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果上下文实现了 ConfigurableWebApplicationContext&lt;/span&gt;
            ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context;
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;cwac.isActive()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上下文还没有刷新，设置 父上下文（如果能找到），并且刷新
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The context has not yet been refreshed -&amp;gt; provide services such as
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; setting the parent context, setting the application context id, etc&lt;/span&gt;
                &lt;span&gt;if&lt;/span&gt; (cwac.getParent() == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The context instance was injected without an explicit parent -&amp;gt;
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; determine parent for root web application context, if any.&lt;/span&gt;
                    ApplicationContext parent =&lt;span&gt; loadParentContext(servletContext);
                    cwac.setParent(parent);
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置和刷新上下文&lt;/span&gt;
&lt;span&gt;                configureAndRefreshWebApplicationContext(cwac, servletContext);
            }
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将上下文绑定到 servletContext 的属性上&lt;/span&gt;
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context);

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取当前线程的上下文类加载器&lt;/span&gt;
        ClassLoader ccl =&lt;span&gt; Thread.currentThread().getContextClassLoader();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ccl == ContextLoader.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getClassLoader()) {
            currentContext &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ccl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果有线程上下文类加载器，而且不是 ContextLoader 本身的类加载器，放入到 currentContextPerThread 中。这是一个 static 的域&lt;/span&gt;
            currentContextPerThread.put(ccl, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context);
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (logger.isInfoEnabled()) {
            &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; elapsedTime = System.currentTimeMillis() -&lt;span&gt; startTime;
            logger.info(&lt;/span&gt;&quot;Root WebApplicationContext initialized in &quot; + elapsedTime + &quot; ms&quot;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (RuntimeException |&lt;span&gt; Error ex) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发生异常, 把异常绑定到上下文对应的属性上,之后不会再进行初始化&lt;/span&gt;
        logger.error(&quot;Context initialization failed&quot;&lt;span&gt;, ex);
        servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, ex);
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;initWebApplicationContext()&lt;/code&gt; 方法调用了 &lt;code&gt;createWebApplicationContext()&lt;/code&gt; 方法来创建上下文;调用了 &lt;code&gt;configureAndRefreshWebApplicationContext()&lt;/code&gt; 来对实现了 &lt;code&gt;ConfigurableWebApplicationContext&lt;/code&gt; 接口的上下文做初始化.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;createWebApplicationContext()&lt;/code&gt; 会调用 &lt;code&gt;determineContextClass()&lt;/code&gt; 来获取上下文类型的 Class 对象.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; WebApplicationContext createWebApplicationContext(ServletContext sc) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取上下文类型&lt;/span&gt;
    Class&amp;lt;?&amp;gt; contextClass =&lt;span&gt; determineContextClass(sc);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查是否实现了 ConfigurableWebApplicationContext&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (!ConfigurableWebApplicationContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.isAssignableFrom(contextClass)) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ApplicationContextException(&quot;Custom context class [&quot; + contextClass.getName() +
                &quot;] is not of type [&quot; + ConfigurableWebApplicationContext.&lt;span&gt;class&lt;/span&gt;.getName() + &quot;]&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例化&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass);
}

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Class&amp;lt;?&amp;gt;&lt;span&gt; determineContextClass(ServletContext servletContext) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 serveltContext 的 'contextClass' 初始化参数。&lt;/span&gt;
    String contextClassName =&lt;span&gt; servletContext.getInitParameter(CONTEXT_CLASS_PARAM);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (contextClassName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 指定过上下文类型，加载类&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ClassUtils.forName(contextClassName, ClassUtils.getDefaultClassLoader());
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApplicationContextException(
                    &lt;/span&gt;&quot;Failed to load custom context class [&quot; + contextClassName + &quot;]&quot;&lt;span&gt;, ex);
        }
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 去默认策略里获取默认的上下文类型名称&lt;/span&gt;
        contextClassName = defaultStrategies.getProperty(WebApplicationContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName());
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 加载类&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; ClassUtils.forName(contextClassName, ContextLoader.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getClassLoader());
        }
        &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException ex) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApplicationContextException(
                    &lt;/span&gt;&quot;Failed to load default context class [&quot; + contextClassName + &quot;]&quot;&lt;span&gt;, ex);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;configureAndRefreshWebApplicationContext()&lt;/code&gt;&lt;span&gt; 方法.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac, ServletContext sc) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 用可以获取到的信息，获取一个更有意义的上下文&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (ObjectUtils.identityToString(wac).equals(wac.getId())) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The application context id is still set to its original default value
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -&amp;gt; assign a more useful id based on available information
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取 ServletContext 的 'contextId' 初始化参数。&lt;/span&gt;
        String idParam =&lt;span&gt; sc.getInitParameter(CONTEXT_ID_PARAM);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (idParam != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            wac.setId(idParam);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Generate default id...
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 生成默认 id&lt;/span&gt;
            wac.setId(ConfigurableWebApplicationContext.APPLICATION_CONTEXT_ID_PREFIX +&lt;span&gt;
                    ObjectUtils.getDisplayString(sc.getContextPath()));
        }
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置 servletContext 属性&lt;/span&gt;
&lt;span&gt;    wac.setServletContext(sc);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置配置文件路径&lt;/span&gt;
    String configLocationParam =&lt;span&gt; sc.getInitParameter(CONFIG_LOCATION_PARAM);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (configLocationParam != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        wac.setConfigLocation(configLocationParam);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; The wac environment's #initPropertySources will be called in any case when the context
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; is refreshed; do it eagerly here to ensure servlet property sources are in place for
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; use in any post-processing or initialization that occurs below prior to #refresh
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化属性源， 确保 servlet 属性源到位并能够在任何 refresh 之前的后期处理和初始化中使用&lt;/span&gt;
    ConfigurableEnvironment env =&lt;span&gt; wac.getEnvironment();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (env &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ConfigurableWebEnvironment) {
        ((ConfigurableWebEnvironment) env).initPropertySources(sc, &lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 在设置了配置文件之后上下文刷新之前，自定义上下文&lt;/span&gt;
&lt;span&gt;    customizeContext(sc, wac);
    wac.refresh();
}

&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; customizeContext(ServletContext sc, ConfigurableWebApplicationContext wac) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据 ServletContext 的 'contextInitializerClasses' 和 'globalInitializerClasses' 初始化参数 加载 ApplicationContextInitializer 的 class&lt;/span&gt;
    List&amp;lt;Class&amp;lt;ApplicationContextInitializer&amp;lt;ConfigurableApplicationContext&amp;gt;&amp;gt;&amp;gt; initializerClasses =&lt;span&gt;
            determineContextInitializerClasses(sc);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (Class&amp;lt;ApplicationContextInitializer&amp;lt;ConfigurableApplicationContext&amp;gt;&amp;gt;&lt;span&gt; initializerClass : initializerClasses) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取范型参数类型&lt;/span&gt;
        Class&amp;lt;?&amp;gt; initializerContextClass =&lt;span&gt;
                GenericTypeResolver.resolveTypeArgument(initializerClass, ApplicationContextInitializer.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 检查 Initializer 是否适用于当前上下文对象&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (initializerContextClass != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;initializerContextClass.isInstance(wac)) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApplicationContextException(String.format(
                    &lt;/span&gt;&quot;Could not apply context initializer [%s] since its generic parameter [%s] &quot; +
                    &quot;is not assignable from the type of application context used by this &quot; +
                    &quot;context loader: [%s]&quot;&lt;span&gt;, initializerClass.getName(), initializerContextClass.getName(),
                    wac.getClass().getName()));
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 Initializer 实例，并添加到 contextInitializers&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contextInitializers.add(BeanUtils.instantiateClass(initializerClass));
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据 org.springframework.core.Ordered 和 org.springframework.core.annotation.Order 排序，如果没有实现或注解，会被排到最后&lt;/span&gt;
    AnnotationAwareOrderComparator.sort(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contextInitializers);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 执行每个 initializer 的 initialize() 方法&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (ApplicationContextInitializer&amp;lt;ConfigurableApplicationContext&amp;gt; initializer : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.contextInitializers) {
        initializer.initialize(wac);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;销毁上下文&quot;&gt;　　销毁上下文&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;closeWebApplicationContext()&lt;/code&gt; 方法如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; closeWebApplicationContext(ServletContext servletContext) {
    servletContext.log(&lt;/span&gt;&quot;Closing Spring root WebApplicationContext&quot;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果 context 是 ConfigurableWebApplicationContext 调用 close() 方法&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.context &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; ConfigurableWebApplicationContext) {
            ((ConfigurableWebApplicationContext) &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.context).close();
        }
    }
    &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
        ClassLoader ccl &lt;/span&gt;=&lt;span&gt; Thread.currentThread().getContextClassLoader();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ccl == ContextLoader.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getClassLoader()) {
            currentContext &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (ccl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            currentContextPerThread.remove(ccl);
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 移除 servletContext 中的 context 属性&lt;/span&gt;
&lt;span&gt;        servletContext.removeAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Servlet 3.0+ 中初始化&lt;/h2&gt;
&lt;p&gt;Servlet 3.0+ 中可以通过 &lt;code&gt;ServletContext&lt;/code&gt; 的 &lt;code&gt;addlistener()&lt;/code&gt; 方法来添加监听器.因此可以先把 Spring 容器先创建好,再传给 &lt;code&gt;ContextLoaderListener&lt;/code&gt; 的构造器.这里就不自己写例子了,选了单元测试中的 &lt;code&gt;ContextLoaderTests.testContextLoaderListenerWithDefaultContext()&lt;/code&gt; 方法:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testContextLoaderListenerWithDefaultContext() {
    MockServletContext sc &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; MockServletContext(&quot;&quot;&lt;span&gt;);
    sc.addInitParameter(ContextLoader.CONFIG_LOCATION_PARAM,
            &lt;/span&gt;&quot;/org/springframework/web/context/WEB-INF/applicationContext.xml &quot; +
            &quot;/org/springframework/web/context/WEB-INF/context-addition.xml&quot;&lt;span&gt;);
    ServletContextListener listener &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContextLoaderListener();
    ServletContextEvent event &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServletContextEvent(sc);
    listener.contextInitialized(event);
    String contextAttr &lt;/span&gt;=&lt;span&gt; WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE;
    WebApplicationContext context &lt;/span&gt;=&lt;span&gt; (WebApplicationContext) sc.getAttribute(contextAttr);
    assertTrue(&lt;/span&gt;&quot;Correct WebApplicationContext exposed in ServletContext&quot;, context &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; XmlWebApplicationContext);
    assertTrue(WebApplicationContextUtils.getRequiredWebApplicationContext(sc) &lt;/span&gt;&lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; XmlWebApplicationContext);
    LifecycleBean lb &lt;/span&gt;= (LifecycleBean) context.getBean(&quot;lifecycle&quot;&lt;span&gt;);
    assertTrue(&lt;/span&gt;&quot;Has father&quot;, context.containsBean(&quot;father&quot;&lt;span&gt;));
    assertTrue(&lt;/span&gt;&quot;Has rod&quot;, context.containsBean(&quot;rod&quot;&lt;span&gt;));
    assertTrue(&lt;/span&gt;&quot;Has kerry&quot;, context.containsBean(&quot;kerry&quot;&lt;span&gt;));
    assertTrue(&lt;/span&gt;&quot;Not destroyed&quot;, !&lt;span&gt;lb.isDestroyed());
    assertFalse(context.containsBean(&lt;/span&gt;&quot;beans1.bean1&quot;&lt;span&gt;));
    assertFalse(context.containsBean(&lt;/span&gt;&quot;beans1.bean2&quot;&lt;span&gt;));
    listener.contextDestroyed(event);
    assertTrue(&lt;/span&gt;&quot;Destroyed&quot;&lt;span&gt;, lb.isDestroyed());
    assertNull(sc.getAttribute(contextAttr));
    assertNull(WebApplicationContextUtils.getWebApplicationContext(sc));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 转自：https://www.cnblogs.com/FJH1994/p/10798028.html&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 07:22:00 +0000</pubDate>
<dc:creator>胡峻峥</dc:creator>
<og:description>Spring MVC源码——Root WebApplicationContext 打算开始读一些框架的源码,先拿 Spring MVC 练练手,欢迎点击这里访问我的源码注释, SpringMVC官方文</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/10819473.html</dc:identifier>
</item>
<item>
<title>SpringBoot 第一篇：入门篇 - 追梦1819</title>
<link>http://www.cnblogs.com/yanfei1819/p/10819728.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yanfei1819/p/10819728.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;  博主从去年开始，项目中使用的框架逐渐被 SpringBoot 取代。今年独立负责的两个项目也都是用 SpringBoot ，看过不少资料、博客。网上的资源，内容有长有短，参差不齐。有的内容甚至存在误导性，误导读者从另一个坑跳进另一个坑。另外，在项目中使用的 SpringBoot 的功能比较零散。&lt;/p&gt;
&lt;p&gt;  基于此，想系统整理其相关的知识点以及项目中踩得坑，并记录。一是作为自己的一个成长笔记，一是提醒后来的新人绕过已经踩过的坑。&lt;/p&gt;
&lt;p&gt;  此为本系列博客的写作初心。&lt;/p&gt;

&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;p&gt;  Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。&lt;/p&gt;
&lt;p&gt;  springboot 不是一门新技术。它是一个简化Spring应用开发的一个框架，整个Spring技术栈的一个大整合，更提供了J2EE开发的一站式解决方案。&lt;/p&gt;
&lt;p&gt;  博主更愿意把它理解为一个技术平台（不知道这样理解是否合适，欢迎大佬拍砖），几乎把所有的Java主流技术都整合进去，让开发者“随用随取”，不会陷入到繁杂的配置文件中无法自拔。&lt;/p&gt;

&lt;h2 id=&quot;优点&quot;&gt;优点&lt;/h2&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自动化配置（springboot的核心特性）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;简化spring的配置，无需xml配置文件；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;内嵌了Tomcat、Jetty等容器；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接运行jar包；&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;核心&quot;&gt;核心&lt;/h2&gt;
&lt;p&gt;spring 应用程序开发中，有四个核心：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;自动配置：针对很多Spring应用程序常见的应用功能，Spring Boot能自动提供相关配置&lt;/li&gt;
&lt;li&gt;起步依赖：告诉Spring Boot需要什么功能，它就能引入需要的库。&lt;/li&gt;
&lt;li&gt;命令行界面：这是Spring Boot的可选特性，借此你只需写代码就能完成完整的应用程序，无需传统项目构建。&lt;/li&gt;
&lt;li&gt;Actuator：让你能够深入运行中的Spring Boot应用程序，一套究竟。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于篇幅所限，此处先接触一下基本概念，不做深入讲解。后续会一一展开。&lt;/p&gt;

&lt;h2 id=&quot;快速构建项目&quot;&gt;快速构建项目&lt;/h2&gt;
&lt;h3 id=&quot;maven构建项目&quot;&gt;maven构建项目&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;进入SpringBoot 项目构建网站 &lt;a href=&quot;https://start.spring.io/&quot; class=&quot;uri&quot;&gt;https://start.spring.io/&lt;/a&gt; （如下）；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201905/1183871-20190506151012977-777838544.png&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;选择对应的工具、语言、版本、相关信息、依赖等，按住 &lt;code&gt;alt&lt;/code&gt; + &lt;code&gt;Enter&lt;/code&gt; 下载，然后解压，导入IDE。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;idea-构建项目&quot;&gt;IDEA 构建项目&lt;/h3&gt;
&lt;p&gt;  个人推荐使用 idea 构建， 方便，简洁，“傻瓜式”构建，直接 &lt;code&gt;下一步&lt;/code&gt; 即可。感兴趣的可以参照之前的博客：https://www.cnblogs.com/yanfei1819/p/7798499.html&lt;/p&gt;

&lt;h3 id=&quot;项目结构说明&quot;&gt;项目结构说明&lt;/h3&gt;
&lt;p&gt;如上图所示，Spring Boot项目的基础结构共三个文件:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;src/main/java 程序开发以及主程序入口&lt;/li&gt;
&lt;li&gt;src/main/resources 配置文件&lt;/li&gt;
&lt;li&gt;src/test/java 测试程序&lt;/li&gt;
&lt;li&gt;DemoApplication 类是程序入口&lt;/li&gt;
&lt;li&gt;application.properties 是程序配置文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在引入web模块后，src/main/resources/static 是静态资源文件放置路径；src/main/resources/template 是使用模板引擎时放置的 &lt;code&gt;.html&lt;/code&gt; 静态页面。还有其他的一些路径，后续会一一阐述。&lt;/p&gt;

&lt;h3 id=&quot;程序启动&quot;&gt;程序启动&lt;/h3&gt;
&lt;p&gt;  程序员的入门课一般都是 &lt;code&gt;Hello Word!&lt;/code&gt; ,下面我们演示 SpringBoot 版的 &lt;code&gt;Hello Word!&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;创建controller层：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package com.yanfei1819.demo.web.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;

/**
 * Created by 追梦1819 on 2019-05-06.
 */
@Controller
public class HelloWordController {
    @ResponseBody
    @GetMapping(&quot;/helloWord&quot;) // &amp;lt;===&amp;gt; @RequestMapping(value = &quot;/helloWord&quot;,method = RequestMethod.GET)
    public String helloWord(){
        return &quot;Hello Word,SpringBoot!&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意两点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;@GetMapping(&quot;/helloWord&quot;)&lt;/code&gt; 等价于 &lt;code&gt;@RequestMapping(value = &quot;/helloWord&quot;,method = RequestMethod.GET)&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;加上 &lt;code&gt;@ResponseBody&lt;/code&gt; 后，返回结果不会被解析为跳转路径，而是直接写入返回值中。如果不加，则会解析为跳转路径；&lt;/li&gt;
&lt;li&gt;程序默认的端口号是 8080，可以通过 application.properties 配置文件的 &lt;code&gt;server.port=&lt;/code&gt; 进行修改。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以上程序通过 postman 测试结果是：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201905/1183871-20190506151042075-2069286171.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;  SpringBoot 涉及的内容很多，如果没有一个系统的主线去学习，会感觉很零散。以上内容作为本系列博客的入门篇。后续会将 SpringBoot 的功能点一一展开。&lt;/p&gt;
&lt;p&gt;本文同步于公众号【技术和人生】，欢迎关注。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1183871/201905/1183871-20190506155148994-1723750747.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 07:14:00 +0000</pubDate>
<dc:creator>追梦1819</dc:creator>
<og:description>前言   博主从去年开始，项目中使用的框架逐渐被 SpringBoot 取代。今年独立负责的两个项目也都是用 SpringBoot ，看过不少资料、博客。网上的资源，内容有长有短，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yanfei1819/p/10819728.html</dc:identifier>
</item>
<item>
<title>Mysql（8）---轻松搞懂游标 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10818375.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10818375.html</guid>
<description>&lt;center&gt;

&lt;/center&gt;
&lt;p&gt;上一遍博客写了有关存储过程的语法知识 &lt;a href=&quot;https://www.cnblogs.com/qdhxhz/p/10816954.html&quot;&gt;Mysql（7）---存储过程&lt;/a&gt;&lt;br/&gt;&lt;code&gt;游标&lt;/code&gt;或许你在工作中很少用到，但用不到不代表不去了解它，但你真正需要它来解决问题的时候，再花时间去学习很可能会影响你的工作进度。&lt;br/&gt;&lt;code&gt;注意&lt;/code&gt;：MySQL游标只能用于存储过程(和函数)。游标主要用于交互式应用。&lt;/p&gt;
&lt;h2 id=&quot;一概述&quot;&gt;&lt;span&gt;一、概述&lt;/span&gt;&lt;/h2&gt;
&lt;h4 id=&quot;定义&quot;&gt;1、定义&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;游标是一个存储在MySQL服务器上的数据库查询，它不是一条select语句，而是被该语句所检索出来的结果集。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来会对这句话做出进一步解释。&lt;/p&gt;
&lt;h4 id=&quot;游标的作用&quot;&gt;2、游标的作用&lt;/h4&gt;
&lt;p&gt;比如有这么个语句&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;SELECT name,age from person where age&amp;gt;10;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个语句返回的很可能是多条语句,那么我如何遍历每一条数据呢，这个时候就需要游标，游标可以理解成java的List&amp;lt;Object&amp;gt;集合，存储了每一个含有&quot;name&quot;和&quot;age&quot;的对象。接下来我们就可以遍历集合中每一个对象获取&quot;name&quot;和&quot;age&quot;。&lt;/p&gt;
&lt;h4 id=&quot;使用游标&quot;&gt;3、使用游标&lt;/h4&gt;
&lt;p&gt;使用游标可以大致分为这么几步&lt;/p&gt;
&lt;p&gt;&lt;code&gt;声明游标&lt;/code&gt; ：这个过程实际上是没有遍历数据的，它只是定义要使用的select语句来获取数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;打开游标&lt;/code&gt; : 上面定义好后，那么这里就需要打开游标。这个过程用前面定义的select语句把数据实际检索出来。即这个步骤之后，我们就可以遍历游标中的数据了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;遍历数据&lt;/code&gt; : 对于有数据的游标，根据需要取出各行的数据来进行一定的操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;关闭游标&lt;/code&gt; : 使用完游标后，一定要关闭游标。&lt;/p&gt;
&lt;h4 id=&quot;游标语法&quot;&gt;4、游标语法&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1）声明游标&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;DECLARE cursor_name CURSOR FOR select_statement&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个语句声明一个游标。也可以在子程序中定义多个游标，但是一个块中的每一个游标必须有唯一的名字。声明游标后也是单条操作的，但是SELECT语句不能有INTO子句。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2) 打开游标&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;OPEN cursor_name ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个语句打开先前声明的游标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3) 遍历数据&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;FETCH cursor_name INTO var_name ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个语句用指定的打开游标读取下一行（如果有下一行的话），并且前进游标指针。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4) 关闭游标&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;CLOSE cursor_name ;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面会用一个详细的例子来说明,通过这个例子就能很明白游标是什么了。&lt;/p&gt;

&lt;h2 id=&quot;二举例&quot;&gt;&lt;span&gt;二、举例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;例子所需表&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;CREATE TABLE IF NOT EXISTS `store` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) NOT NULL,
  `count` int(11) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=latin1 AUTO_INCREMENT=7;
 
INSERT INTO `store` (`id`, `name`, `count`) VALUES
(1, 'android', 15),
(2, 'iphone', 14),
(3, 'iphone', 20),
(4, 'android', 5),
(5, 'android', 13),
(6, 'iphone', 13);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;例一&quot;&gt;1、例一&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;目的&lt;/code&gt;：我们现在要用存储过程做一个功能，统计iphone的总库存是多少，并把总数输出到控制台。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;delimiter $ # 申明结束标志
drop procedure if exists StatisticStore$ # 如果存储过程已经存在则删除
CREATE PROCEDURE StatisticStore()
BEGIN
    # 创建接收游标数据的变量
    declare c int;  # 获取单条纪录的数量
    declare n varchar(20); #获取名称
    # 创建总数变量
    declare total int default 0;
    # 创建结束标志变量
    declare done int default false;
    # 创建游标 获取name和count的集合
    declare cur cursor for select name,count from store where name = 'iphone';
    # 指定游标循环结束时的返回值
    declare continue HANDLER for not found set done = true;
    # 设置初始值
    set total = 0;
    # 打开游标
    open cur;
    # 开始循环游标里的数据
    read_loop:loop
    # 根据游标当前指向的一条数据 插入到上面申明的局部变量中
    fetch cur into n,c;
    # 判断游标的循环是否结束
    if done then
        leave read_loop;    # 跳出游标循环
    end if;
    # 获取一条数据时，将count值进行累加操作，这里可以做任意你想做的操作，
    set total = total + c;
    # 有loop 就一定要有end loop
    end loop;
    # 关闭游标
    close cur; 
    # 输出结果
    select total;
END $
# 调用存储过程
call StatisticStore()$
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看输出结果 完美&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190506112247107-554636609.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在啰嗦几句&lt;/p&gt;
&lt;p&gt;&lt;code&gt;fetch&lt;/code&gt;:是获取游标当前指向的数据行，并将指针指向下一行，当游标已经指向最后一行时继续执行会造成游标溢出。&lt;br/&gt;使用loop循环游标时，他本身是不会监控是否到最后一条数据了，像下面代码这种写法，就会造成死循环；&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;read_loop:loop
fetch cur into n,c;
set total = total+c;
end loop;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在MySql中，造成游标溢出时会引发mysql预定义的NOT FOUND错误，所以在上面使用下面的代码指定了当引发not found错误时定义一个continue 的事件，指定这个事件发生时修改done变量的值。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;declare continue HANDLER for not found set done = true;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以在循环时加上了下面这句代码：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;#判断游标的循环是否结束
if done then
    leave read_loop;    #跳出游标循环
end if;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果done的值是true，就结束循环。继续执行下面的代码。&lt;/p&gt;
&lt;h4 id=&quot;游标嵌套例子&quot;&gt;2、游标嵌套例子&lt;/h4&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;delimiter $ # 申明结束标志
drop procedure if exists StatisticStore3$
CREATE PROCEDURE StatisticStore3()
BEGIN
    declare _n varchar(20);
    declare done int default false;
    declare cur cursor for select name from store group by name; #其实就是获得了两个名称的集合[android,iphone]
    declare continue HANDLER for not found set done = true;
    open cur;
    read_loop:loop
    fetch cur into _n;
    if done then
        leave read_loop;
    end if;
    begin
        declare c int;
        declare n varchar(20);
        declare total int default 0;
        declare done1 int default false;
        declare cur cursor for select name,count from store where name = _n; 
        declare continue HANDLER for not found set done1 = true;
        set total = 0;
        open cur; # 这里游标名称和上面重复了，mysql默认就近原则 所以遍历的是最近的那么 但还是非常不建议取一样的名称
        iphone_loop:loop
        fetch cur into n,c;
        if done1 then
            leave iphone_loop;
        end if;
        set total = total + c;
        end loop;
        close cur;
        select _n,n,total; # select 只输出一次，而且是第一次遍历数据
    end;
    end loop;
    close cur;
END$
call StatisticStore3()$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果（select 只输出一次，而且是第一次遍历数据）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201905/1090617-20190506112257873-1272740086.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;&lt;span&gt;参考&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;1、&lt;a href=&quot;https://blog.csdn.net/lan12334321234/article/details/70049132&quot;&gt;mysql cursor概念&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2、&lt;a href=&quot;https://blog.csdn.net/liguo9860/article/details/50848216&quot;&gt;MySql中游标举例&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;只要自己变优秀了，其他的事情才会跟着好起来（少将10）
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 06 May 2019 07:01:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>Mysql（8）—游标 上一遍博客写了有关存储过程的语法知识 'Mysql（7） 存储过程' 或许你在工作中很少用到，但用不到不代表不去了解它，但你真正需要它来解决问题的时候，再花时间去学习很可能会影</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10818375.html</dc:identifier>
</item>
<item>
<title>Oracle备库宕机启动解决方案 - Halburt</title>
<link>http://www.cnblogs.com/Halburt/p/10819620.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Halburt/p/10819620.html</guid>
<description>&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;ORA-10458: standby database requires recovery&lt;br/&gt;ORA-01196: 文件 1 由于介质恢复会话失败而不一致&lt;br/&gt;ORA-01110: 数据文件 1: 'XXXXXXXXXXXXXXXXXX\XXXXX1.DBF'&lt;/p&gt;
&lt;p&gt;一个项目做了Oracle主从数据库同步，通过Dataguard实现，从库服务器宕机，再开机的时候，从库无法启动，报“ORA-01196: 文件 1 由于介质恢复会话失败而不一致”这个错误，具体日志信息如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ORA-10458: standby database requires recovery
ORA-01196: 文件 1 由于介质恢复会话失败而不一致
ORA-01110: 数据文件 1: 'XXXXXXXXXXXXXXXXXX\XXXXX1.DBF'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正常启动的顺序应该是先启动备库再启动主库。由于从库宕机导致有段时间日志未同步，主备不一致，从库无法启动。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;https://blog.csdn.net/linux_wang130/article/details/38870363&lt;/p&gt;
&lt;h3 id=&quot;恢复前准备&quot;&gt;恢复前准备&lt;/h3&gt;
&lt;h4 id=&quot;备份主库&quot;&gt;备份主库&lt;/h4&gt;
&lt;p&gt;备份主库数据【/home/oracle/backup/20190506/】&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mkdir /home/oracle/backup/20190506&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;   sqlplus / as sysdba
  SQL&amp;gt; create directory data_dir as '/home/oracle/backup/20190506';&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt; expdp SYSTEM/密码@orcl schemas=用户名 dumpfile=bak20190506.dmp directory=data_dir logfile=bak20190506.log;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;检查日志文件&quot;&gt;检查日志文件&lt;/h4&gt;
&lt;p&gt;恢复之前需要了解当前备库的数据库文件、日志文件，查看主备库是否一致【如不一致需要拷贝】。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; set linesize 300
SQL&amp;gt; col MEMBER for a60
SQL&amp;gt; select type,member from v$logfile;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-f37eb6e56b80a4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;检查数据库文件&quot;&gt;检查数据库文件&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; select name from v$datafile;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/231328-ed6df43d10dc092b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;备库恢复&quot;&gt;备库恢复&lt;/h3&gt;
&lt;p&gt;关闭备库，并启动了实例，加载数据库，但是数据库没有打开。打开日志进程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;shutdown immediate
startup mount;
alter database recover managed standby database using current logfile disconnect from session;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;主库操作&quot;&gt;主库操作&lt;/h3&gt;
&lt;p&gt;alter system switch logfile;&lt;br/&gt;强制日志切换，不一定就归档当前的重做日志文件（若自动归档打开，就归档前的重做日志，若自动归档没有打开，就不归档当前重做日志。）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter system switch logfile;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多操作几次，操作之后，稍等一段时间，时间视网速而定，过一段时间后，在主库上查询一下同步情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;select name,sequence#,archived,applied from v$archived_log order by sequence#;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果返回结果&quot;APPLIED&quot;都是“YES”或者只有最后一个是“NO”的话，说明全部归档日志全部已经归档完了&lt;br/&gt;，此时到备库上上操作&lt;/p&gt;
&lt;h3 id=&quot;启动备库&quot;&gt;启动备库&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;alter database recover managed standby database cancel;
alter database open;
alter database recover managed standby database using current logfile disconnect from session;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 06 May 2019 06:56:00 +0000</pubDate>
<dc:creator>Halburt</dc:creator>
<og:description>简介 ORA 10458: standby database requires recovery ORA 01196: 文件 1 由于介质恢复会话失败而不一致 ORA 01110: 数据文件 1: '</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Halburt/p/10819620.html</dc:identifier>
</item>
<item>
<title>性能篇（十）性能提示 - 宋者为王</title>
<link>http://www.cnblogs.com/andy-songwei/p/10819594.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/andy-songwei/p/10819594.html</guid>
<description>&lt;p&gt;       本文主要覆盖了细微的优化，虽然他们组合起来能够提高整个应用的性能，但是这些改变会导致显著的性能影响是不太可能的。选择正确的算法和数据结构应该始终是您优先要考虑的，但是这在本文的范围之外。您应该使用本文中的这些提示来作为常规的编码实践，这样为了常规的代码效率，您可以将这些编码实践融入您的习惯中。&lt;/p&gt;
&lt;p&gt;       这里有两个编写高效代码的基本规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不要做您不需要的工作。&lt;/li&gt;
&lt;li&gt;如果您可以避免，就不要分配内存。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       其中一个您在细微优化Android应用时要面对的棘手的问题是，您的应用确定在多种类型的硬件上运行。不同版本的虚拟机在不同的处理器上以不同的速度运行。一般来说，您甚至不能简单地说“设备X是一个比设备Y更快/慢的因素F”，并且将您的结果从一个设备缩放当另外一个设备。一般来说，模拟器上的测量机会不会告诉您任何关于设备的性能。同样，在拥有或者没有JIT的设备之间也存在着巨大的差异：有JIT的设备上最好的代码，在没有JIT的设备上并不总是最好的代码。&lt;/p&gt;
&lt;p&gt;       为了确保您的应用在各种各样的设备上都运行良好，请确保您的代码在所有级别中都是有效率的，并且积极地优化您的性能。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;避免创建不必要的对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       对象创建从来就不是免费的。一个带有为每个线程分配临时对象池的分代垃圾收集器可能让分配更加便宜，但是分配内存总是比不分配内存要更加昂贵。&lt;/p&gt;
&lt;p&gt;       当您在应用中分配更多的对象时，您将强制执行一个周期性的垃圾收集，从而在用户体验方面创建小的“打嗝”。在Android2.3中引入的并发垃圾收集器帮上了忙，但是应该避免不必要的工作。&lt;/p&gt;
&lt;p&gt;       这样，您应该避免创建您不需要的对象实例。如下一些实例可以帮到您：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果您有一个返回字符串的方法，并且您知道无论如何它的结果将总是被附加到StringBuffer，那么请改变您的签名和实现，从而让该函数直接附件，而不是创建一个短时间存在的临时对象。&lt;/li&gt;
&lt;li&gt;当从一个输入数据集合中提取字符串时，尝试返回原始数据的子字符串，而不是创建一个拷贝。您将创建一个新的字符串对象，但是它将和该数据共享char[]。（折衷的是，如果您只使用一小部分的原始输入，如果您采用这种方式，无论如何您都将把它保存在整个内存中）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       一个更加彻底的主意是将多维数组划分为并行的一维数组：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;int型的数组比Integer对象数组要好得多，但是这也可以归纳为一个事实，两个并行的int数组也比（int，int）数组对象要高效得多。任何原始类型的组合也一样。&lt;/li&gt;
&lt;li&gt;如果您需要实现一个存储（Foo，Bar）对象元组的容器，请记住，一般来说两个并行的Foo[]和Bar[]数组要比单一的自定义（Foo，Bar）对象数组要好得多。（当然，例外的是，当您正在为其它代码设计用于访问的API时。在这些情形下，通常情况下最好对速度做一个小小的折衷，从而实现好的API设计。但是在您自己的内部代码，您应该尝试尽可能高效。）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       一般来说，如果可以，请避免创建短期的临时对象。创建越少的对象意味着越低频率的垃圾收集，这对用户体验会有直接的影响。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;更喜欢静态的而不是虚拟的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       如果您无需访问对象的字段，让方法成为静态的。这样调用将会快15%-20%。这也是一个很好的实践，因为从方法签名可以辨别出调用该方法不会改变对象的状态。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;为常量使用static final&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在类的顶部考虑如下的声明：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; intVal = 42&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String strVal = &quot;Hello, world!&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       编译器产生了一个被称为&amp;lt;clinit&amp;gt;的类初始化器方法，当类第一次使用的时候它会被执行。这个方法将42存入intVal，并且从类文件字符串常量表中为strVal选取引用。当这些值稍后被引用时，它们会通过字段查找被访问。&lt;/p&gt;
&lt;p&gt;       我们可以使用“final”关键字来改善这些问题：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; intVal = 42&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String strVal = &quot;Hello, world!&quot;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       该类不再需要&amp;lt;clinit&amp;gt;方法，因为这些常量进入了dex文件中的静态字段初始化器。指向intVal的代码将直接使用整形值42，并且对strVal的访问将使用一个相对不那么贵的“字符串常量”指令，而不是字段查找。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;★ 注意：这个优化只提供了原始类型和String常量，而不是任意的引用类型。尽可能在任何时候声明常量为static final 仍然是一个很好的实践。&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;使用加强的for循环语法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       加强的for循环(有时也被称为“for-each”循环)可以用于实现了Iterable接口的集合和数组。对于集合，将分配迭代器对hasNext()和next()进行接口调用。对于ArrayList，手写的计数循环速度大约快3倍（有或者没有JIT），但是对于其它的集合，加强的for循环语法将完全等价于显示的迭代器使用。&lt;/p&gt;
&lt;p&gt;       对数组进行迭代有若干种选择：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foo {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; splat;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; Foo[] array =&lt;span&gt; ...
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; zero() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; sum = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; array.length; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         sum +=&lt;span&gt; array[i].splat;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; one() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; sum = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     Foo[] localArray =&lt;span&gt; array;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; len =&lt;span&gt; localArray.length;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; len; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         sum +=&lt;span&gt; localArray[i].splat;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; two() {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; sum = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Foo a : array) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         sum +=&lt;span&gt; a.splat;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       zero()方法是最慢的，因为JIT还不能优化循环中每一次迭代中获取数组长度的花费。&lt;/p&gt;
&lt;p&gt;       one()方法稍微快一些。它将一切都推入本地变量，从而避免了查找。只有数组长度提供了性能上的好处。&lt;/p&gt;
&lt;p&gt;       two()在没有JIT的设备上是最快的，在有JIT的设备上和one()没有区别。它使用了加强的for循环语法，其在Java编程语言的1.5版本中引入。&lt;/p&gt;
&lt;p&gt;       所以，您应该默认使用加强的for循环，但是为性能要求较高的ArrayList迭代考虑手写计数循环。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;★ 提示：也可以查阅 Josh Bloch 的 《Effective Java》，项目46。&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;考虑使用包而不是私有内部类的私有访问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       ......&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;避免使用浮点型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       根据经验，在Android驱动设备上，浮点型大约比整型慢两倍。&lt;/p&gt;
&lt;p&gt;       从速度方面看，在更现代的硬件上float和double之间没有区别。从空间上看，double是float的两倍大。和台式机一样，假设空间不是问题，您应该使用double而不是float。&lt;/p&gt;
&lt;p&gt;       即使是整型也一样，一些处理器有硬件乘法却没有硬件除法。在这些情况下，整数相除和模运算是在软件中执行的——如果您正在设计hash表或者处理大量数学问题，应该考虑这个问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;了解并使用库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       除了所有通用的更喜欢库代码而不是调用自己的代码的原因之外，请记住，系统可以自由地使用手动编码的汇编程序来取代库方法调用，这可能比JIT能够为等效于Java而生成的最好代码更好。这里一个典型的例子就是String.indexOf()以及相关的API，Dalvik使用内联的内部函数来取代它们。类似地，System.arraycopy()方法的速度大约是带有JIT的Nexus One上手动编码循环速度的9倍。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;★ 提示：也可以查阅 Josh Bloch 的 《Effective Java》，项目47。&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;慎重使用原生方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       使用Android NDK包含开发含有原生代码的应用不一定比使用Java语言编程更有效。首先，有一笔花费与java到原生的转移有关，并且JIT无法跨越边界进行优化。如果您正在分配原生资源（原生堆上的内存，文件描述符，或者其它），及时安排这些资源的收集可能是明显更加困难的。您也需要为每一个您希望在上面运行的架构编译代码（而不是依赖它拥有JIT）。您甚至可能不得不为那些您认为相同的架构编译多个版本：为G1中ARM处理器编译的原生代码不能充分利用Nexus One中的ARM，并且为Nexus One中ARM编译的代码在G1的ARM上也不会运行。&lt;/p&gt;
&lt;p&gt;       当您拥有已经存在的想移植到Android的原生代码库，而不是为了“加速”用Java语言编写的Android应用的部分功能时，原生代码主体上是有用的。&lt;/p&gt;
&lt;p&gt;       如果您确实需要使用原生代码，您应该阅读我们的【&lt;a href=&quot;https://developer.android.google.cn/training/articles/perf-jni&quot; target=&quot;_blank&quot;&gt;JNI提示&lt;/a&gt;】。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;em&gt;★ 提示：也可以查阅 Josh Bloch 的 《Effective Java》，项目54。&lt;/em&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;性能神话&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在没有JIT的设备上，通过具有准确类型而非接口的变量调用方法稍微更有效是个事实。（例如，在HashMap映射上调用方法比在Map映射上要便宜，虽然在这两种情况下映射都是HashMap。）这并不是变慢两倍的情形；实际的差别更有可能是慢6%。此外，JIT让这两者有效地没有区别。&lt;/p&gt;
&lt;p&gt;       没有JIT的设备，缓存字段访问大约比重复访问该字段快20%。有JIT的设备上，字段访问和本地访问花费大致相同，所以这不是有价值的优化，除非您感觉它让您的代码更容易阅读。（对于final，static和static final字段也是如此。）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总是测量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       在开始优化之前，确保您有问题需要解决。确保您可以准确测量存在的性能，否则您将不能测量到您所尝试的选择所带来的好处。&lt;/p&gt;
&lt;p&gt;       您也可能发现【&lt;a href=&quot;https://developer.android.google.cn/studio/profile/traceview&quot; target=&quot;_blank&quot;&gt;TraceView&lt;/a&gt;】对分析是有用的，但是意识到它让JIT当前不可使用是很重要的，这可能导致它错误地分配代码时间，而JIT可能会赢回来。尤为重要的是，在按照TraceView数据提供的建议更改后，确保实际上生成的代码在没有TraceView时运行得更快。&lt;/p&gt;
&lt;p&gt;       更多帮助分析和调试应用的信息，请查阅如下文档：&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 06:53:00 +0000</pubDate>
<dc:creator>宋者为王</dc:creator>
<og:description>性能优化是一个难点，也是一个重点。在面试时是一个经常遇到的考点，在平时工作中，也是考验一个程序员内功的地方。我们平时的一些编码习惯中包含了很多性能问题，但咱们往往容易忽略。本文中提供了一些良好的编码实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/andy-songwei/p/10819594.html</dc:identifier>
</item>
<item>
<title>LIine 算法与deepwalk的对比 和个人理解 - Earendil</title>
<link>http://www.cnblogs.com/earendil/p/10819394.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/earendil/p/10819394.html</guid>
<description>&lt;p&gt;用户的关注关系本身就是一个图结构，要从用户关注关系生成用户的embedding表示，其实就是做graph的emebding表示。&lt;/p&gt;
&lt;p&gt;deepwalk+word2vec 比较简单，效果也还可以。这种方法再此不再介绍。&lt;/p&gt;
&lt;p&gt;接下里记下我对line算法的一些理解。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;先说line算法要解决的问题。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、需要能够表示有向图。&lt;/p&gt;
&lt;p&gt;2、能够体现节点的权重，边的权重。节点的权重论文中使用了节点的出度作为节点的权重。&lt;/p&gt;
&lt;p&gt;3、能够体现节点的结构相似性，其实就是有相似的上下文。这个line算法分别提出了一阶相似和二阶相似。&lt;/p&gt;
&lt;p&gt;     接下来详细说说一阶和二阶相似性。&lt;/p&gt;
&lt;p&gt;     其中一阶相似是指直接有边相连的节点i,j 。用i节点的向量推出j节点向量的概率有多大。如果i和j没有边相连接，则一阶相似性为0。如果对应于用户的关注关系组成的图的话，这个其实就是好友间的相似。还需要指出的是一阶对于边直接认为是无向图的边，不考虑方向性。对于用户间一阶相似性的边权重可以通过用户间互动行为，统计出来一个亲密度。&lt;/p&gt;
&lt;p&gt;     二阶相似性，为了解决一阶相似没有考虑朋友的朋友间的相似性，而提出的。这种朋友的朋友之间的相似性是通过给每个顶点增加一个上下文向量来实现的。一个顶点有两个向量分别是上下文向量和本身的节点向量。上下文向量是说一个节点可以作为其相邻节点的上下文。两个不直接相连的节点越相似，也就是说他们的共同上下文节点越多，也就是他们的共同好友越多。&lt;/p&gt;
&lt;p&gt;       二阶相似性，会考虑边的权重，和节点的权重。论文中节点的权重使用节点的出度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;line算法与deepwalk的对比：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;line考虑了边的权重，二阶相似还会考虑有向图的情况，类似单向的关注关系。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;line算法在实现和训练过程中优化：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; line算法定义了一阶和二阶相似的经验概率，就是从i节点推出j节点的经验概率，如何算。然后对于一阶的话是直接i节点向量和j节点向量来算，但是对于二阶需要计算softmax,softmax分母需要计算所有节点的上下文向量与节点i向量的点乘概率，直接算复杂度高。&lt;/p&gt;
&lt;p&gt;line算法的代价函数是经验概率与计算的概率之间的KL散度，KL散度的优化其实等价于交叉熵。这一步存在的问题是代价函数会乘以权重。如果权重的方差比较大，那么这个训练就很成问题了。&lt;/p&gt;
&lt;p&gt;对于计算softmax的问题，当然还是和训练word2vec时候一样通过选一些负样本，对负样本做采样来解决。在采样的时候使用alias算法减少时间复杂度。&lt;/p&gt;
&lt;p&gt;解决权重系数对梯度传到的影响（乘系数之后会导致梯度特别大或者梯度特别小），通过对边按照权重进行采样来解决。采样之后就不需要乘权重了。&lt;/p&gt;
&lt;p&gt;其实负采样和过采样的采样比例其实也等同于对这种类型的样本乘以系数。&lt;strong&gt;不过我的疑问就是这样采样之后有些边就不参与训练了吧。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;存在的问题：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;line的一阶和二阶向量是分开训练的，一阶向量和二阶向量如何结合。论文给出的方法是直接拼接起来，然后给一阶和二阶不同的权重。&lt;/p&gt;
&lt;p&gt;line虽然考虑了一阶和二阶。但是也只是到邻居的邻居。对于有些节点边比较少，这种如何更好的训练。论文中提出了一个增加边的方式，构造些邻居的邻居之间的边，以及设置边权重的方式。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;算法效果：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在稀疏数据上 line的一阶比二阶要好，增加邻居到邻居的边之后对效果有所提升。边比较多的话，一阶和二阶结合比单独使用一阶和二阶效果要更好。&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 06:25:00 +0000</pubDate>
<dc:creator>Earendil</dc:creator>
<og:description>用户的关注关系本身就是一个图结构，要从用户关注关系生成用户的embedding表示，其实就是做graph的emebding表示。 deepwalk+word2vec 比较简单，效果也还可以。这种方法再</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/earendil/p/10819394.html</dc:identifier>
</item>
<item>
<title>python接口自动化（二十九）--html测试报告通过邮件发出去——上（详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10812533.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10812533.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　前边几篇，已经教小伙伴们掌握了如何生成HTML的测试报告，那么生成测试报告，我们也不能放在那里不管了，这样即使你报告在漂亮，领导也看不到。因此如果想向领导汇报工作，不仅需要提供更直观的测试报告。而是我们需要将生&lt;/p&gt;
&lt;p&gt;成测试报告发个相关的负责人，需要他们看一下测试结果，把控一下项目的接口有风险，会不会影响项目进度等等一些事吧。&lt;/p&gt;
&lt;p&gt;　　发邮件需要用到python两个模块，smtplib和email，这俩模块是python自带的，只需import即可使用。smtplib模块主要负责发送邮件，email模块主要负责构造邮件。其中MIMEText()定义邮件正文，Header()定义邮件标题。MIMEMulipart模块构造带附件。&lt;/p&gt;
&lt;h2&gt;大致思路流程&lt;/h2&gt;
&lt;p&gt;1、通过unittest框架的discover()找到匹配的测试用例，由HTMLTestRunner的run()方法执行测试用例并生成最新的测试报告。&lt;/p&gt;
&lt;p&gt;2、调用new_report()函数找到测试报告目录下最新生成的测试报告，返回测试报告的路径。&lt;/p&gt;
&lt;p&gt;3、将得到的最新测试报告的完整路径传给send_mail()函数，实现发邮件功能。&lt;/p&gt;
&lt;p&gt;4、第一步，前边几篇，我们都详细介绍了，所以这篇就不在赘述了，直接从第二步、第三步开始讲解。&lt;/p&gt;
&lt;h2&gt;查找最新测试报告 &lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506110256734-588764790.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;定义发送邮件&lt;/h2&gt;
&lt;p&gt;1、查看一下，源码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506134115515-1276667820.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、仿照源码进行改造&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506134252881-1879931191.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;参考代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
# coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行

#&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;5&lt;/span&gt;-&lt;span&gt;6&lt;/span&gt;&lt;span&gt;
@author: 北京&lt;/span&gt;-&lt;span&gt;宏哥
Project:学习和使用将测试报告通过邮件发出去
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;#&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入unittest模块
import unittest
import os
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; email.mime.text import MIMEText
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt; email.header import Header
import smtplib
#&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.编写测试用例和断言
def all_case():
    # 待执行用例的目录
    #case_dir &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\DELL\\PycharmProjects\\honggetest\\case&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    case_dir &lt;/span&gt;= os.path.join(os.getcwd(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    testcase &lt;/span&gt;=&lt;span&gt; unittest.TestSuite()
    discover &lt;/span&gt;=&lt;span&gt; unittest.defaultTestLoader.discover(case_dir,
                                                   pattern&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test*.py&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                                   top_level_dir&lt;/span&gt;=&lt;span&gt;None)
    # #discover方法筛选出用例，循环添加到测试套件中
    # &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; test_suit &lt;span&gt;in&lt;/span&gt;&lt;span&gt; discover:
    #     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; test_case &lt;span&gt;in&lt;/span&gt;&lt;span&gt; test_suit:
    #         #添加用力到testcase
    #         testcase.addTests(test_case)
    # print(testcase)

    testcase.addTests(discover)  # 直接加载 discover    可以兼容python2和3
    print(testcase)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; testcase


# &lt;/span&gt;==============定义发送邮件==========&lt;span&gt;
def send_mail(file_new):
    f &lt;/span&gt;= open(file_new, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    mail_body &lt;/span&gt;=&lt;span&gt; f.read()
    f.close()

    username &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;nXXply@ceXXx.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;  #发件箱用户名
    password &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;XXX@@123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;        #发件箱密码
    sender &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;noXXy@ceXXx.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;    #发件人邮箱
    receiver &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;hongge@XXX.cn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]  #收件人邮箱
    # 邮件正文是MIMEText
    msg &lt;/span&gt;= MIMEText(mail_body, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    # 邮件对象
    msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Subject&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = Header(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;自动化测试报告&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).encode()
    msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;From&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = Header(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试机 &amp;lt;%s&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;sender)
    msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;To&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = Header(u&lt;span&gt;'&lt;/span&gt;&lt;span&gt;测试负责人 &amp;lt;%s&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;receiver)
    msg[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;date&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%a,%d %b %Y %H:%M:%S %z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    #发送邮件
    smtp &lt;/span&gt;=&lt;span&gt; smtplib.SMTP()
    smtp.connect(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.mxhichina.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)  # 邮箱服务器
    smtp.login(username, password)  # 登录邮箱
    smtp.sendmail(sender, receiver, msg.as_string())  # 发送者和接收者
    smtp.quit()
    print(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;邮件已发出！注意查收。&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)


# &lt;/span&gt;======查找测试目录，找到最新生成的测试报告文件======&lt;span&gt;
def new_report(test_report):
    lists &lt;/span&gt;=&lt;span&gt; os.listdir(test_report)  # 列出目录的下所有文件和文件夹保存到lists
    lists.sort(key&lt;/span&gt;=lambda fn: os.path.getmtime(test_report + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; fn))  # 按时间排序
    file_new &lt;/span&gt;= os.path.join(test_report, lists[-&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])  # 获取最新的文件保存到file_new
    print(file_new)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; file_new

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    # 返回实例
    runner &lt;/span&gt;=&lt;span&gt; unittest.TextTestRunner()
    #导入第三方模块HTMLTestRunner
    import HTMLTestReportCN
    import time
    # 获取当前时间，这样便于下面的使用。
    now &lt;/span&gt;= time.strftime(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%Y-%m-%M-%H_%M_%S&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, time.localtime(time.time()))
    #保存生成报告的路径
    report_path &lt;/span&gt;=  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\DELL\\PycharmProjects\\honggetest\\report\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+now+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_result.html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    fp &lt;/span&gt;= open(report_path,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;wb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    runner &lt;/span&gt;= HTMLTestReportCN.HTMLTestRunner(stream=&lt;span&gt;fp,
                                           title&lt;/span&gt;=u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是我的自动化测试用例&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                           description&lt;/span&gt;=u&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用例执行情况&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                                           verbosity &lt;/span&gt;= &lt;span&gt;2&lt;/span&gt;&lt;span&gt;
                                           )
    # run 所有用例
    runner.run(all_case())
    #关闭文件，记住用open()打开文件后一定要记得关闭它，否则会占用系统的可打开文件句柄数。
    fp.close()
    #测试报告文件夹
    test_path &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\DELL\\PycharmProjects\\honggetest\\report\\&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    new_report &lt;/span&gt;=&lt;span&gt; new_report(test_path)
    send_mail(new_report)  # 发送测试报告&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;1、遇到的问题及解决方法&lt;/p&gt;
&lt;p&gt;（1）将生成的测试报告的保存路径和查找测试报告的路径混淆会报如下错误&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506103924189-992662445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）解决方法&lt;/p&gt;
&lt;p&gt;a、我们先来分析一下原因，刚开始我查了资料还觉得是不是数组越界，后来感觉不对，就复制粘贴到我的电脑报如下错误，确实找不到&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506104159395-1118007246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b、接着Ctrl+R复制进去，运行出现如下这是才知道查找最新的测试报告遍历的根本不是一个目录而是一个文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506104500599-1767031482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;c、解决办法不是文件夹修改成测试报告的文件夹是不是就可以，做如下简单地修改就可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506104808209-915136186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;d、完了把test_path拷贝在我电脑和运行处，两个界面一样分别定位到测试报告。这样就可以遍历，这是不用试 一定可以成功分别如下：&lt;/p&gt;
&lt;p&gt;我的电脑&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506105114358-260779565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506105215294-1464883342.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;e、代码运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506105410258-2132774264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;f、到收件箱可以看到测试报告&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506105509077-1235636861.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、发送的邮件看不到发件人和收件人，如图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506120144481-1992485559.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; a、解决办法：&lt;/p&gt;
&lt;p&gt;加两行代码即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506134816260-603909728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;b、再次运行收到邮件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201905/1232840-20190506134912693-521929684.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 06 May 2019 06:05:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 前边几篇，已经教小伙伴们掌握了如何生成HTML的测试报告，那么生成测试报告，我们也不能放在那里不管了，这样即使你报告在漂亮，领导也看不到。因此如果想向领导汇报工作，不仅需要提供更直观的测试报告。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10812533.html</dc:identifier>
</item>
<item>
<title>设计模式之单例模式（一） - 小酒窝</title>
<link>http://www.cnblogs.com/dimple91/p/10819163.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dimple91/p/10819163.html</guid>
<description>&lt;p&gt;这篇我们学习的是单例模式，相信很多朋友都或多或少使用过这个模式。很多设计模式的入门，都把单例模式作为第一个的，但是因为我们是跟着书本学习，所以放在了第五个里面。那么，你使用过的单例模式是怎么样的呢？懒汉式？饿汉式？双重校验？静态？&lt;/p&gt;
&lt;p&gt;先来看下定义，单例模式（Singleton Pattern）：&lt;strong&gt;用来创建独一无二的，只能有一个实例的对象的入场券&lt;/strong&gt;。而且，单例模式的类图是所有设计模式中最简单的，事实上只有一个类。但是，尽管从类的设计上来说简单，实现上还是会遇见相当多的波折噢。&lt;/p&gt;
&lt;h4 id=&quot;单例模式有什么用处&quot;&gt;单例模式有什么用处？&lt;/h4&gt;
&lt;p&gt;有些对象其实我们只需要一个，比方说：线程池、缓存、对话框、处理偏好设置和注册表对象、日志对象等。事实上，这些对象只能以一个实例，如果制造出多个实例，就会导致许多问题的产生，例如：程序的行为异常、资源使用过量，或者就是不一致的结果。&lt;/p&gt;
&lt;h4 id=&quot;剖析经典的单例模式实现&quot;&gt;剖析经典的单例模式实现&lt;/h4&gt;
&lt;p&gt;我们先来看下经典的单例模式的实现代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Singleton {

    private static Singleton uniqueInstance;
    
    private Singleton() {}
    
    public static Singleton getInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;利用一个静态变量来记录Singleton类的唯一实例&lt;/li&gt;
&lt;li&gt;把构造器声明为私有化，只有Singleton类才可以调用构造器&lt;/li&gt;
&lt;li&gt;用getInstance()方法实例化对象，并返回这个实例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;再仔细看下getInstance()方法，这里需要着重描述下。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;uniqueInstance 拥有一个“实例”，而且是一个静态变量&lt;/li&gt;
&lt;li&gt;如果uniqueInstance是空的，表示还没有创建实例&lt;/li&gt;
&lt;li&gt;如果不存在，我们就利用私有的构造器产生一个Singleton实例并把它赋值到uniqueInstance静态变量中。请注意，如果我们不需要这个实例，他就永远不会产生。这就是“延迟实例化”（lazy instaniaze）&lt;/li&gt;
&lt;li&gt;如果uniqueInstance不是null，就表示之前已经创建过对象，我们就直接返回&lt;/li&gt;
&lt;li&gt;当执行到return语句，表示我们已经有实例，并将uniqueInstance当返回值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果没有单例模式，这里有一个代码写的很小心的例子，看完你肯定会感受到单例模式的重要性。&lt;br/&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/mw690/62b02411ly1g2bc16mahoj20lp0pbk1m.jpg&quot; alt=&quot;巧克力工厂&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中的公司有意识地防止不好的事情发生，对吧。但是，如果防不胜防，同事存在两个ChocolateBoiler实例，可能将发生很糟糕的事情。那么，如果有过个ChocolateBoiler实例存在，可能发生什么严重的事情呢？咋这个例子上，就是会产生资源的浪费，原料的溢出等等。&lt;/p&gt;
&lt;p&gt;那么，你能根据经典的单例模式，写出这个巧克力工厂的单例模式吗？我们晚点揭晓。&lt;/p&gt;
&lt;h4 id=&quot;定义单例模式&quot;&gt;定义单例模式&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;单例模式&lt;/strong&gt;：确保一个类只有一个实例，并提供一个全局访问点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这定义一点儿都不让人吃惊，但是让我们更深入一点儿&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;到底怎么回事？我们正在把某个类设计成自己管理的一个单独实例，同时也避免其他类再自行产生实例。要想取得单例实例，通过单例类是唯一的途径&lt;/li&gt;
&lt;li&gt;我们也提供对这个实例的全局访问点：当你需要实例时，向类查询，他会返回单个实例。前面的例子利用延迟实例化的方式创建单例，这种做法对资源敏感的对象特别重要。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那我们来看看单例的类图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://wx1.sinaimg.cn/mw690/62b02411ly1g2bcnjh6ulj20l209sadh.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你看吧，之前就说过，这个单例模式只有一个类图，是不是很简单呢？仔细看看他吧。&lt;/p&gt;
&lt;p&gt;但是，这些都只是单线程模式下的单例模式，参考上面这个巧克力工厂，如果是多线程模式下的单例，那又会是什么样的呢？经典的单例模式，能确保你在单线程下不出问题，但是，我们想要让人家效率更高，产量更大，势必需要多线程？&lt;/p&gt;
&lt;p&gt;那么，请屏幕前的你，先好好想想，我们下次学习的时候，通过JVM原理，把这个烦恼给解决了。今天的学习就先到这里啦。&lt;/p&gt;
&lt;center&gt;爱生活，爱学习，爱感悟，爱挨踢&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;http://wx2.sinaimg.cn/mw690/62b02411ly1g1h6i45avyj207607674r.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 05:48:00 +0000</pubDate>
<dc:creator>小酒窝</dc:creator>
<og:description>这篇我们学习的是单例模式，相信很多朋友都或多或少使用过这个模式。很多设计模式的入门，都把单例模式作为第一个的，但是因为我们是跟着书本学习，所以放在了第五个里面。那么，你使用过的单例模式是怎么样的呢？懒</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dimple91/p/10819163.html</dc:identifier>
</item>
<item>
<title>精通Java中的volatile关键字 - 架构与我</title>
<link>http://www.cnblogs.com/atcloud/p/10819111.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/atcloud/p/10819111.html</guid>
<description>&lt;p&gt;在一些开源的框架的源码当中时不时都可以看到volatile这个关键字，最近特意学习一下volatile关键字的使用方法。&lt;/p&gt;
&lt;p&gt;很多资料中是这样介绍volatile关键字的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文字不太好理解，通过例子来理解。&lt;/p&gt;
&lt;h2 id=&quot;例子&quot;&gt;1、例子&lt;/h2&gt;
&lt;p&gt;首先看一个没有使用volatile关键字例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.swnote.java;

/**
 * volatile测试例子
 *
 * @author lzj
 * @date [2019-04-47]
 */
public class VolatileTest {

    private boolean flag;

    public static void main(String[] args) {
        VolatileTest test = new VolatileTest();
        test.test();
    }

    public void test() {
        new Thread(() -&amp;gt; {
            try {
                Thread.sleep(1000L);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            flag = true;
        }).start();

        new Thread(() -&amp;gt; {
            while (true) {
                if (flag) {
                    System.out.println(&quot;thread flag = &quot; + flag);
                }
            }
        }).start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该例子中定义了一个flag共享变量，test方法里面开启了两个线程，第一个线程在等待1秒中后修改共享变量flag的值为true，第二个线程通过循环判断flag的值，当flag的值为true时，输出内容。&lt;/p&gt;
&lt;p&gt;此时有两种猜想：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;执行后，可以看到输出内容，即说明第二个线程能够感知到第一个线程对共享变量flag的修改&lt;/li&gt;
&lt;li&gt;执行后，没有任务内容，即说明第二个线程无法感知到第一个线程对共享变量flag的修改&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后执行结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201905/840503-20190506133849948-1010637911.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;没有任务的输出内容，即证明了此时这样情况下第二个线程无法感知到第一个线程对共享变量flag的修改的&lt;/p&gt;
&lt;p&gt;现在修改一下例子，即为flag变量加上volatile关键字，即：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private volatile boolean flag;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再运行，此时结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201905/840503-20190506133840830-1101029547.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时就有内容输出了，说明加上volatile关键字后，第二个线程可以感知到第一个线程对共享变量flag的修改的，这就是上面概念中所说的volatile在多处理器开发中保证了共享变量的“可见性”。&lt;/p&gt;
&lt;h2 id=&quot;原理&quot;&gt;2、原理&lt;/h2&gt;
&lt;p&gt;通过上面的例子证明了volatile在多处理器开发中保证了共享变量的“可见性”，那它是怎么实现的呢？&lt;/p&gt;
&lt;p&gt;这时就得介绍一下Java的内存模型了，首先看如下示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201905/840503-20190506133830850-631825334.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java内存模型是如上面所示的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;共享变量存储在主内存中，每个线程都有一个私有的本地内存，本地内存保存了被该线程使用到的主内存的副本拷贝，线程对变量的所有操作都必须在自己的本地内存中进行，而不能直接读写主内存中的变量。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据此理解，上述例子的在没有加volatile时的情况是这样的：&lt;/p&gt;
&lt;p&gt;第一个线程从主内存中获取共享变量flag的值，此时值为false，将该值放到自己的本地内存中，然后对变量进行修改，将值改为true，此时也只是将本地内存中flag的值改为了true，此时还没有将值同步到主内存中，然后第二线程也是将共享变量flag的值放到自己的本地内存中，而此时flag的值还是为false，所以就是一直没有内容输出了。&lt;/p&gt;
&lt;p&gt;然而加上volatile关键字后，第一个线程对flag的修改会强制刷新到主内存中去，同时还会导致其他线程中的本地内存的值会无效，需要重新到主内存获取，这样就保证了第一个线程对flag修改后，第二线程能够感知到。&lt;/p&gt;
&lt;h2 id=&quot;注意点&quot;&gt;3、注意点&lt;/h2&gt;
&lt;p&gt;volatile是轻量级的synchronized，但是它是不能够代替synchronized的，因为volatile只能保证原子性操作的安全，对于复合操作，volatile是不能保证线程安全的。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.swnote.java;

/**
 * 复合操作例子
 *
 * @author lzj
 * @date [2019-04-27]
 */
public class StatisticTest {
    private volatile int num = 0;

    public static void main(String[] args) {
        StatisticTest test = new StatisticTest();
        test.statistic();
    }

    public void statistic() {
        for (int i = 0; i &amp;lt; 20; i++) {
            new Thread(() -&amp;gt; {
                num++;
            }).start();
        }

        System.out.println(&quot;num = &quot; + num);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;期望的运行结果是20，可是几乎每次运行结果都是不一样的，例如有的结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201905/840503-20190506133818297-1768436420.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是因为num++这个操作不是原子性的，所以即使使用了volatile关键字，也是不能保证安全的。&lt;/p&gt;
&lt;h2 id=&quot;关注我&quot;&gt;关注我&lt;/h2&gt;
&lt;p&gt;以你最方便的方式关注我：&lt;br/&gt;微信公众号：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/840503/201905/840503-20190506133802796-1590105091.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 05:39:00 +0000</pubDate>
<dc:creator>架构与我</dc:creator>
<og:description>在一些开源的框架的源码当中时不时都可以看到volatile这个关键字，最近特意学习一下volatile关键字的使用方法。 很多资料中是这样介绍volatile关键字的： 文字不太好理解，通过例子来理解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/atcloud/p/10819111.html</dc:identifier>
</item>
<item>
<title>WebGL学习之纹理盒 - Jeff.Zhong</title>
<link>http://www.cnblogs.com/edwardloveyou/p/10818894.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edwardloveyou/p/10818894.html</guid>
<description>&lt;p&gt;我们之前已经学习过二维纹理 &lt;strong&gt;gl.TEXTURE_2D&lt;/strong&gt;，而且还使用它实现了各种效果。但还有一种立方体纹理 &lt;strong&gt;gl.TEXTURE_CUBE_MAP&lt;/strong&gt;，它包含了6个纹理代表立方体的6个面。不像常规的纹理坐标有2个纬度，立方体纹理使用法向量，换句话说三维方向。本节实现的demo请看 &lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglskybox.html&quot;&gt;天空盒&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-21b5d76b44dbd274.gif&quot; width=&quot;400&quot; alt=&quot;sky box&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据法向量的朝向选取立方体6个面中的一个，这个面的像素用来采样生成颜色。这六个面通过他们相对于立方体中心的方向被引用。它们是分别是&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;gl.TEXTURE_CUBE_MAP_POSITIVE_X//右
gl.TEXTURE_CUBE_MAP_NEGATIVE_X//左
gl.TEXTURE_CUBE_MAP_POSITIVE_Y//上
gl.TEXTURE_CUBE_MAP_NEGATIVE_Y//下
gl.TEXTURE_CUBE_MAP_POSITIVE_Z//后
gl.TEXTURE_CUBE_MAP_NEGATIVE_Z//前&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;环境贴图&quot;&gt;环境贴图&lt;/h2&gt;
&lt;p&gt;其实我们更应该把cube map叫作纹理盒，通常纹理盒不是给立方体设置纹理用的，设置立方体纹理的标准用法其实是使用二维贴图，那么纹理盒用来做什么的呢？纹理盒最常见的用法是用来做环境贴图。在百度和google地图中的3D街景就是环境贴图应用的一个例子。&lt;/p&gt;
&lt;h3 id=&quot;纹理&quot;&gt;纹理&lt;/h3&gt;
&lt;p&gt;下面是6张红色峡谷图片&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-b7d177dc23ef4e0f.jpg&quot; alt=&quot;canyon&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-1e9ac45cf368861f.jpg&quot; alt=&quot;canyon&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将以上尺寸为512x512的图片填充到立方体的每个面，以下就是纹理的创建加载过程&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;// 创建纹理。
var texture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
 
const faceInfos = [
  {
    target: gl.TEXTURE_CUBE_MAP_POSITIVE_X, 
    url: '/img/sorbin_rt.jpg',
  },
  {
    target: gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 
    url: '/img/sorbin_lf.jpg',
  },
  {
    target: gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 
    url: '/img/sorbin_up.jpg',
  },
  {
    target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 
    url: '/img/sorbin_dn.jpg',
  },
  {
    target: gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 
    url: '/img/sorbin_bk.jpg',
  },
  {
    target: gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 
    url: '/img/sorbin_ft.jpg',
  },
];
faceInfos.forEach((faceInfo) =&amp;gt; {
  const {target, url} = faceInfo;
  // 上传画布到立方体贴图的每个面
  const level = 0;
  const format = gl.RGBA;
  const width = 512;
  const height = 512;
  const type = gl.UNSIGNED_BYTE;
  // 设置每个面，使其立即可渲染
  gl.texImage2D(target, level, format, width, height, 0, format, type, null);
 
  // 异步加载图片
  const image = new Image();
  image.src = url;
  image.onload = function() {
    // 图片加载完成将其拷贝到纹理
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, texture);
    gl.texImage2D(target, level, internalFormat, format, type, image);
    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
  };
});
gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;法向量&quot;&gt;法向量&lt;/h3&gt;
&lt;p&gt;标准立方体法向量 和 纹理盒法向量的区别&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-f3d6044f6ce65e08.jpg&quot; width=&quot;300&quot; alt=&quot;立方体向量&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3D立方体使用纹理盒有一个巨大的好处就是不需要额外指定纹理坐标。只要盒子是被放置在世界坐标系的原点，盒子本身的坐标就可以作为纹理坐标使用，因为在3D世界中位置本身就是一个向量，表示一个方向，我们要的就是这个方向。&lt;/p&gt;
&lt;p&gt;所以顶点着色器非常简单&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;attribute vec4 a_position;
uniform mat4 u_vpMatrix;
varying vec3 v_normal;

void main() {
    gl_Position = u_vpMatrix * a_position;
    //因为位置是以几何中心为原点的,可以用顶点坐标作为法向量
    v_normal = normalize(a_position.xyz);
} &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;片段着色器中我们需要用&lt;code&gt;samplerCube&lt;/code&gt; 代替 &lt;code&gt;sampler2D&lt;/code&gt; 用 &lt;code&gt;textureCube&lt;/code&gt;代替&lt;code&gt;texture2D&lt;/code&gt;。&lt;code&gt;textureCube&lt;/code&gt; 需要vec3类型的向量。 法向量从顶点着色器传递过来经过了插值处理，需要重新单位化。&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;precision mediump float; // 从顶点着色器传入。
varying vec3 v_normal; // 纹理。
uniform samplerCube u_texture; 

void main() {   
  gl_FragColor = textureCube(u_texture, normalize(v_normal));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实现&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;运行后得到如下的效果，很明显就能看出是个立方体，并不是我们想要的360度环绕的3D场景。&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-3baf35fcc34bedfd.jpg&quot; width=&quot;400&quot; alt=&quot;纹理盒&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实我们只需要将相机位置置于原点(0,0,0)，同时lookAt向其中的一个面就可以了。但是在原点有个问题，如果要旋转查看场景怎么办？我们可以通过旋转相机的位置，这其实就相当于立方体旋转，同时我们不需要矩阵位移相关的信息，只需要方向相关的信息就好了。同时还可以禁止写入深度缓存，造成背景在很远的假象，让效果更加真实。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;const viewPosition = new Vector3([0,0,1]);//相机位置
const lookAt = [0, 0, 0];//原点

//相机绕y轴旋转
cameraMatrix.rotate(0.2,0,1,0);
viewPoint = cameraMatrix.multiplyVector3(viewPosition);
vpMatrix.setPerspective( 30, canvas.width / canvas.height, 0.1, 5 );
vpMatrix.lookAt(...viewPoint.elements, ...lookAt, 0, 1, 0);

//重置位移
vpMatrix.elements[12] = 0;
vpMatrix.elements[13] = 0;
vpMatrix.elements[14] = 0;

// 禁止写入深度缓存，造成背景在很远的假象
gl.depthMask(false);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;环境贴图还有个更通俗的叫法-天空盒。接着我们还要实现一个非常帅气的效果，在天空盒三维场景中，让其中的物体反射场景周围的着色。这个操作就叫做环境纹理映射（environment mapping）。&lt;/p&gt;
&lt;h3 id=&quot;反射&quot;&gt;反射&lt;/h3&gt;
&lt;p&gt;如果物体的表面像光滑的镜子，那么我们就能看到物体反射出天空和周围的景色。反射的原理非常简单，那就是使用反射公式映射纹理盒对应的纹素：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-57795ea16284cdbd.jpg&quot; width=&quot;400&quot; alt=&quot;纹理映射&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相机位置(观察点)和 物体顶点的位置，顶点位置又包含着法线信息，通过GLSL的reflect函数就可以非常容易的计算反射向量R，进而确定看到的是哪一块表面的着色。&lt;/p&gt;
&lt;h3 id=&quot;实现-1&quot;&gt;实现&lt;/h3&gt;
&lt;p&gt;我们就在天空盒下面增加一个镜面立方体，那就需要增加一对着色器，首先顶点着色器需要增加法线，mvp矩阵&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;attribute vec4 a_position;
attribute vec4 a_normal;
uniform mat4 u_vpMatrix;
uniform mat4 u_modelMatrix;
varying vec3 v_position;
varying vec3 v_normal;

void main() {
    v_position = (u_modelMatrix * a_position).xyz;
    v_normal = vec3(u_modelMatrix * a_normal);
    gl_Position = u_vpMatrix * u_modelMatrix * a_position;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;片元着色器则需要添加相机位置，纹理以及顶点着色器传递过来的法线和顶点位置&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;precision highp float;
varying vec3 v_position;
varying vec3 v_normal;
uniform samplerCube u_texture;
uniform vec3 u_viewPosition;

void main() {
    vec3 normal = normalize(v_normal);
    vec3 eyeToSurfaceDir = normalize(v_position - u_viewPosition);
    vec3 direction = reflect(eyeToSurfaceDir,normal);
    gl_FragColor = textureCube(u_texture, direction);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们绘制的时候就要轮流切换着色器program&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function draw(){
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    //天空盒
    gl.useProgram(program.program);
        //绘制天空盒
    //...

    //立方体
    gl.useProgram(cProgram.program);
        //绘制立方体
    //...

    requestAnimationFrame(draw);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后实现如下效果，demo情况 &lt;strong&gt;&lt;a href=&quot;https://edwardzhong.github.io/sites/demo/dist/webglskybox.html&quot;&gt;天空盒&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/127924-4650febc8e130ca4.jpg&quot; width=&quot;400&quot; alt=&quot;天空盒&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;其实纹理盒除了可以做环境贴图，还可以结合光照，阴影贴图作出很多酷炫的效果。&lt;/p&gt;
</description>
<pubDate>Mon, 06 May 2019 04:40:00 +0000</pubDate>
<dc:creator>Jeff.Zhong</dc:creator>
<og:description>我们之前已经学习过二维纹理 gl.TEXTURE_2D ，而且还使用它实现了各种效果。但还有一种立方体纹理 gl.TEXTURE_CUBE_MAP ，它包含了6个纹理代表立方体的6个面。不像常规的纹理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edwardloveyou/p/10818894.html</dc:identifier>
</item>
</channel>
</rss>