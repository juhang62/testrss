<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>测试客户端连接12c ASM实例 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/10527450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/10527450.html</guid>
<description>&lt;p&gt;&lt;strong&gt;环境：&lt;/strong&gt;Oracle 12.2.0.1 RAC&lt;br/&gt;&lt;strong&gt;背景：&lt;/strong&gt;用户反映12c ASM创建的用户具备sysasm权限，但无法在客户端连接到ASM实例，且没有报错。&lt;/p&gt;

&lt;p&gt;sqlplus / as sysasm&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; create user infa identified by infa;
User created.
SQL&amp;gt; grant sysasm to infa;
Grant succeeded.&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;分别针对ASM实例1和实例2配置对应的信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ASM12c1 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.90)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = +ASM)
      (INSTANCE_NAME = +ASM1)
    )
  )
  
ASM12c2 =
  (DESCRIPTION =
    (ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.1.92)(PORT = 1521))
    (CONNECT_DATA =
      (SERVER = DEDICATED)
      (SERVICE_NAME = +ASM)
      (INSTANCE_NAME = +ASM2)
    )
  )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为是12c版本，无需配置UR=A，关于UR=A可参考之前的测试：&lt;/p&gt;

&lt;p&gt;客户端测试连接ASM12c1:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@db01 admin]$ sqlplus infa/infa@asm12c1 as sysasm

SQL*Plus: Release 11.2.0.4.0 Production on Wed Mar 13 22:45:53 2019

Copyright (c) 1982, 2013, Oracle.  All rights reserved.


Connected to:
Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production

SQL&amp;gt; show parameter instance_name

NAME                                 TYPE
------------------------------------ ----------------------
VALUE
------------------------------
instance_name                        string
+ASM1
SQL&amp;gt; exit
Disconnected from Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端测试连接ASM12c2:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[oracle@db01 admin]$ sqlplus infa/infa@asm12c2 as sysasm

SQL*Plus: Release 11.2.0.4.0 Production on Wed Mar 13 22:46:19 2019

Copyright (c) 1982, 2013, Oracle.  All rights reserved.


Connected to:
Oracle Database 12c Enterprise Edition Release 12.2.0.1.0 - 64bit Production

SQL&amp;gt; show parameter instance_name

NAME                                 TYPE
------------------------------------ ----------------------
VALUE
------------------------------
instance_name                        string
+ASM2
SQL&amp;gt; &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我测试是没有任何问题的，明天连接实际客户环境再进一步看具体情况。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 15:18:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>环境： Oracle 12.2.0.1 RAC 背景： 用户反映12c ASM创建的用户具备sysasm权限，但无法在客户端连接到ASM实例，且没有报错。 '1.ASM实例创建用户赋予sysasm权限</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/10527450.html</dc:identifier>
</item>
<item>
<title>MCD 机电一体化概念设计首选项 - jgh</title>
<link>http://www.cnblogs.com/cosimulation/p/10527436.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cosimulation/p/10527436.html</guid>
<description>&lt;p&gt;机电一体化概念设计首选项(机电概念首选项)可以更改默认的系统参数并将其应用到工作部件中，可以灵活地在工作部件中设置不同于用户默认设置的系统参数。在机电概念首选项中可以执行以下操作：&lt;/p&gt;
&lt;p&gt;1 设置重力、摩擦和阻尼属性。&lt;/p&gt;
&lt;p&gt;2 调整物理引擎。&lt;/p&gt;
&lt;p&gt;3 设置仿真刷新频率。&lt;/p&gt;
&lt;p&gt;4 更改仿真显示速度。&lt;/p&gt;
&lt;p&gt;5 设置联合仿真主机和时序设置。&lt;/p&gt;

&lt;p&gt;通常可以从两个地方对MCD的默认系统参数进行设置：用户默认设置（下图右）和机电概念首选项（下图左）。两者的区别在于：用户默认设置用于全局默认参数的设置，设置后需要重启NX才能生效。机电概念首选项设置的参数存储在工作部件中，只对当前工作部件有效，机电概念首选项设置的参数将会覆盖用户默认设置的参数。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1058890/201903/1058890-20190313231229928-1081489622.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;各参数具体含义如下：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;table border=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;tbody readability=&quot;23.5&quot;&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;常规选项&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;重力&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定重力在全局坐标系中的 X, Y, Z 分量。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;材料参数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定材料的碰撞参数，包括动摩擦/动摩擦/滑动摩擦系数，以及恢复系数。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;阻尼&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定线性或角度阻尼值，以降低振动幅度。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;碰撞高亮&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;当碰撞体接触相似的碰撞体时，高亮显示模型中的碰撞体。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;机电引擎选项&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12.5&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;运行时参数&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;18&quot;&gt;
&lt;p align=&quot;left&quot;&gt;设置以下默认的运行时参数：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;碰撞精度—&lt;/strong&gt;设置碰撞检测的精度。当两个碰撞体距离小于等于该值，可以认为两个对象发生了碰撞。距离达到该值时物体可以相互穿透。较大的值更有效，但会导致更大的穿透率。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;分布时间—&lt;/strong&gt;设置最小时间增量。每个时间步长进行一次物理计算。动作不会在时间步长之内发生。较大的值会提高系统性能，但会降低准确性。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;注意：步长过大可能会导致模拟不稳定，约束中断，物体获得无限能量。如果出现不稳定性，可以减小步长，使步长的倒数比系统中最快振荡的频率大10倍。默认步长为1毫秒，振荡频率低于100赫兹。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;弹力乘数—&lt;/strong&gt;指定在仿真过程中鼠标拖动对象时施加的力。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;12&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;物理引擎调整&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;17&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定物理引擎的默认值。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;公差—&lt;/strong&gt;设置关节允许变动量，该距离仍被视为关节对齐（关节位置未改变）。较大的值求解得更快，但会导致关节定位中有更多的间隙。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;误差减少量—&lt;/strong&gt;设置决定关节位置求解速度的因子。较大的值会导致解算器以较少的步骤将关节拉在一起，但过高的值会导致不稳定。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;最大迭代次数—&lt;/strong&gt;设置每个时间步长的最大迭代次数，求解器使用该次数求解关节的位置，并使其所有位置都在公差范围内。较大的值会让求解器有更多的时间将大量关节放置到位，但求解可能需要更长的时间。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;粘着力—&lt;/strong&gt;设置碰撞体之间的结合力，以抵消碰撞引起的排斥力。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;运行时控制选项&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;2&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;部件设置&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;显示多个零件时，这些设置仅适用于工作零件。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;刷新精度&lt;/strong&gt;&lt;strong&gt;( % )&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定查看器中值的刷新率，以确定是否更新UI中的属性值。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;步长&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定查看器的步长，指定仿真期间采样点的时间间隔。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;2&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;会话设置&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;当显示多个零件时，这些设置适用于整个仿真。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;默认缩放因子&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定仿真的显示速率。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;单步前进时间&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定仿真的时间增量，单步前进中仿真进行的时间量。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;协同仿真选项&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;使用时间同步&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;7&quot;&gt;
&lt;p align=&quot;left&quot;&gt;同步MCD信号的PLCSIM Adv信号&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;PLCSIM Adv处于冻结模式。MCD比较仿真时间并和PLCSIM Adv保持同步。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;启用&lt;/strong&gt;&lt;strong&gt;SIMIT&lt;/strong&gt;&lt;strong&gt;控制服务&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;设置运行启动SIMIT协同仿真。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;主导程序&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;指定MCD或SIMIT控制哪个是仿真主导软件。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;激活时间同步&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;当主机设置为MCD时可用。设置同步时间以设置数据传输间隔。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;序列编辑器选项&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;导出后调用时序图&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;允许导出后打开时序文件。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td colspan=&quot;2&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;系统导航选项&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;2&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;仅适用于集成到Teamcenter的NX。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;保存时加载&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;设置加载选项。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td width=&quot;14%&quot;&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;选择修订规则&lt;/strong&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td width=&quot;84%&quot; readability=&quot;5&quot;&gt;
&lt;p align=&quot;left&quot;&gt;从Teamcenter加载模型时，将修订规则设置为。&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1058890/201903/1058890-20190313231424266-899294276.jpg&quot; alt=&quot;&quot;/&gt;该公众号主要介绍工业仿真软件及虚拟调试技术，欢迎各位小伙伴们关注。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 15:16:00 +0000</pubDate>
<dc:creator>jgh</dc:creator>
<og:description>机电一体化概念设计首选项(机电概念首选项)可以更改默认的系统参数并将其应用到工作部件中，可以灵活地在工作部件中设置不同于用户默认设置的系统参数。在机电概念首选项中可以执行以下操作： 1 设置重力、摩擦</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cosimulation/p/10527436.html</dc:identifier>
</item>
<item>
<title>HBase连接的几种方式（二） - 牧梦者</title>
<link>http://www.cnblogs.com/swordfall/p/10517177.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/swordfall/p/10517177.html</guid>
<description>&lt;p&gt;主要分为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;纯Java API连接HBase的方式；&lt;/li&gt;
&lt;li&gt;Spark连接HBase的方式；&lt;/li&gt;
&lt;li&gt;Flink连接HBase的方式；&lt;/li&gt;
&lt;li&gt;HBase通过Phoenix连接的方式；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一种方式是HBase自身提供的比较原始的高效操作方式，而第二、第三则分别是Spark、Flink集成HBase的方式，最后一种是第三方插件Phoenix集成的JDBC方式，Phoenix集成的JDBC操作方式也能在Spark、Flink中调用。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;这里我们使用HBase2.1.2版本，以下代码都是基于该版本开发的。&lt;/p&gt;

&lt;p&gt; Spark上读写HBase主要分为新旧两种API，另外还有批量插入HBase的，通过Phoenix操作HBase的。&lt;/p&gt;
&lt;h2&gt;2.1 spark读写HBase的新旧API&lt;/h2&gt;
&lt;h3&gt;2.1.1 spark写数据到HBase&lt;/h3&gt;
&lt;p&gt;使用旧版本saveAsHadoopDataset保存数据到HBase上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * saveAsHadoopDataset
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
def writeToHBase(): Unit &lt;/span&gt;=&lt;span&gt;{
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 屏蔽不必要的日志显示在终端上&lt;/span&gt;
  Logger.getLogger(&quot;org.apache.spark&quot;&lt;span&gt;).setLevel(Level.WARN)

  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; spark2.0以前的写法
  val conf = new SparkConf().setAppName(&quot;SparkToHBase&quot;).setMaster(&quot;local&quot;)
  val sc = new SparkContext(conf)
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  val sparkSession &lt;/span&gt;= SparkSession.builder().appName(&quot;SparkToHBase&quot;).master(&quot;local[4]&quot;&lt;span&gt;).getOrCreate()
  val sc &lt;/span&gt;=&lt;span&gt; sparkSession.sparkContext

  val tableName &lt;/span&gt;= &quot;test&quot;

  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建HBase配置&lt;/span&gt;
  val hbaseConf =&lt;span&gt; HBaseConfiguration.create()
  hbaseConf.set(HConstants.ZOOKEEPER_QUORUM, &lt;/span&gt;&quot;192.168.187.201&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置zookeeper集群，也可以通过将hbase-site.xml导入classpath，但是建议在程序里这样设置&lt;/span&gt;
  hbaseConf.set(HConstants.ZOOKEEPER_CLIENT_PORT, &quot;2181&quot;) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置zookeeper连接端口，默认2181&lt;/span&gt;
&lt;span&gt;  hbaseConf.set(TableOutputFormat.OUTPUT_TABLE, tableName)

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化job，设置输出格式，TableOutputFormat 是 org.apache.hadoop.hbase.mapred 包下的&lt;/span&gt;
  val jobConf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JobConf(hbaseConf)
  jobConf.setOutputFormat(classOf[TableOutputFormat])

  val dataRDD &lt;/span&gt;= sc.makeRDD(Array(&quot;12,jack,16&quot;, &quot;11,Lucy,15&quot;, &quot;15,mike,17&quot;, &quot;13,Lily,14&quot;&lt;span&gt;))

  val data &lt;/span&gt;= dataRDD.map{ item =&amp;gt;&lt;span&gt;
      val Array(key, name, age) &lt;/span&gt;= item.split(&quot;,&quot;&lt;span&gt;)
      val rowKey &lt;/span&gt;=&lt;span&gt; key.reverse
      val put &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Put(Bytes.toBytes(rowKey))
      &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;一个Put对象就是一行记录，在构造方法中指定主键
       * 所有插入的数据 须用 org.apache.hadoop.hbase.util.Bytes.toBytes 转换
       * Put.addColumn 方法接收三个参数：列族，列名，数据&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
      put.addColumn(Bytes.toBytes(&lt;/span&gt;&quot;cf1&quot;), Bytes.toBytes(&quot;name&quot;&lt;span&gt;), Bytes.toBytes(name))
      put.addColumn(Bytes.toBytes(&lt;/span&gt;&quot;cf1&quot;), Bytes.toBytes(&quot;age&quot;&lt;span&gt;), Bytes.toBytes(age))
      (&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ImmutableBytesWritable(), put)
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存到HBase表&lt;/span&gt;
&lt;span&gt;  data.saveAsHadoopDataset(jobConf)
  sparkSession.stop()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 使用新版本saveAsNewAPIHadoopDataset保存数据到HBase上&lt;/p&gt;
&lt;p&gt;a.txt文件内容为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
100,hello,20
101,nice,24
102,beautiful,26
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * saveAsNewAPIHadoopDataset
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
 def writeToHBaseNewAPI(): Unit &lt;/span&gt;=&lt;span&gt;{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 屏蔽不必要的日志显示在终端上&lt;/span&gt;
   Logger.getLogger(&quot;org.apache.spark&quot;&lt;span&gt;).setLevel(Level.WARN)
   val sparkSession &lt;/span&gt;= SparkSession.builder().appName(&quot;SparkToHBase&quot;).master(&quot;local[4]&quot;&lt;span&gt;).getOrCreate()
   val sc &lt;/span&gt;=&lt;span&gt; sparkSession.sparkContext

   val tableName &lt;/span&gt;= &quot;test&quot;&lt;span&gt;
   val hbaseConf &lt;/span&gt;=&lt;span&gt; HBaseConfiguration.create()
   hbaseConf.set(HConstants.ZOOKEEPER_QUORUM, &lt;/span&gt;&quot;192.168.187.201&quot;&lt;span&gt;)
   hbaseConf.set(HConstants.ZOOKEEPER_CLIENT_PORT, &lt;/span&gt;&quot;2181&quot;&lt;span&gt;)
   hbaseConf.set(org.apache.hadoop.hbase.mapreduce.TableOutputFormat.OUTPUT_TABLE, tableName)

   val jobConf &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JobConf(hbaseConf)
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置job的输出格式&lt;/span&gt;
   val job =&lt;span&gt; Job.getInstance(jobConf)
   job.setOutputKeyClass(classOf[ImmutableBytesWritable])
   job.setOutputValueClass(classOf[Result])
   job.setOutputFormatClass(classOf[org.apache.hadoop.hbase.mapreduce.TableOutputFormat[ImmutableBytesWritable]])

   val input &lt;/span&gt;= sc.textFile(&quot;v2120/a.txt&quot;&lt;span&gt;)

   val data &lt;/span&gt;= input.map{item =&amp;gt;&lt;span&gt;
   val Array(key, name, age) &lt;/span&gt;= item.split(&quot;,&quot;&lt;span&gt;)
   val rowKey &lt;/span&gt;=&lt;span&gt; key.reverse
   val put &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Put(Bytes.toBytes(rowKey))
   put.addColumn(Bytes.toBytes(&lt;/span&gt;&quot;cf1&quot;), Bytes.toBytes(&quot;name&quot;&lt;span&gt;), Bytes.toBytes(name))
   put.addColumn(Bytes.toBytes(&lt;/span&gt;&quot;cf1&quot;), Bytes.toBytes(&quot;age&quot;&lt;span&gt;), Bytes.toBytes(age))
   (&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ImmutableBytesWritable, put)
   }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存到HBase表&lt;/span&gt;
&lt;span&gt;   data.saveAsNewAPIHadoopDataset(job.getConfiguration)
   sparkSession.stop()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.1.2 spark从HBase读取数据&lt;/h3&gt;
&lt;p&gt;使用newAPIHadoopRDD从hbase中读取数据，可以通过scan过滤数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * scan
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
 def readFromHBaseWithHBaseNewAPIScan(): Unit &lt;/span&gt;=&lt;span&gt;{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;屏蔽不必要的日志显示在终端上&lt;/span&gt;
   Logger.getLogger(&quot;org.apache.spark&quot;&lt;span&gt;).setLevel(Level.WARN)
   val sparkSession &lt;/span&gt;= SparkSession.builder().appName(&quot;SparkToHBase&quot;).master(&quot;local&quot;&lt;span&gt;).getOrCreate()
   val sc &lt;/span&gt;=&lt;span&gt; sparkSession.sparkContext

   val tableName &lt;/span&gt;= &quot;test&quot;&lt;span&gt;
   val hbaseConf &lt;/span&gt;=&lt;span&gt; HBaseConfiguration.create()
   hbaseConf.set(HConstants.ZOOKEEPER_QUORUM, &lt;/span&gt;&quot;192.168.187.201&quot;&lt;span&gt;)
   hbaseConf.set(HConstants.ZOOKEEPER_CLIENT_PORT, &lt;/span&gt;&quot;2181&quot;&lt;span&gt;)
   hbaseConf.set(org.apache.hadoop.hbase.mapreduce.TableInputFormat.INPUT_TABLE, tableName)

   val scan &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scan()
   scan.addFamily(Bytes.toBytes(&lt;/span&gt;&quot;cf1&quot;&lt;span&gt;))
   val proto &lt;/span&gt;=&lt;span&gt; ProtobufUtil.toScan(scan)
   val scanToString &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(Base64.getEncoder.encode(proto.toByteArray))
   hbaseConf.set(org.apache.hadoop.hbase.mapreduce.TableInputFormat.SCAN, scanToString)

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;读取数据并转化成rdd TableInputFormat是org.apache.hadoop.hbase.mapreduce包下的&lt;/span&gt;
   val hbaseRDD =&lt;span&gt; sc.newAPIHadoopRDD(hbaseConf, classOf[org.apache.hadoop.hbase.mapreduce.TableInputFormat], classOf[ImmutableBytesWritable], classOf[Result])

   val dataRDD &lt;/span&gt;=&lt;span&gt; hbaseRDD
     .map(x &lt;/span&gt;=&amp;gt;&lt;span&gt; x._2)
     .map{result &lt;/span&gt;=&amp;gt;&lt;span&gt;
       (result.getRow, result.getValue(Bytes.toBytes(&lt;/span&gt;&quot;cf1&quot;), Bytes.toBytes(&quot;name&quot;)), result.getValue(Bytes.toBytes(&quot;cf1&quot;), Bytes.toBytes(&quot;age&quot;&lt;span&gt;)))
     }.map(row &lt;/span&gt;=&amp;gt; (&lt;span&gt;new&lt;/span&gt; String(row._1), &lt;span&gt;new&lt;/span&gt; String(row._2), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(row._3)))
     .collect()
     .foreach(r &lt;/span&gt;=&amp;gt; (println(&quot;rowKey:&quot;+r._1 + &quot;, name:&quot; + r._2 + &quot;, age:&quot; +&lt;span&gt; r._3)))
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.2 spark利用BulkLoad往HBase批量插入数据&lt;/h2&gt;
&lt;p&gt;BulkLoad原理是先利用mapreduce在hdfs上生成相应的HFlie文件，然后再把HFile文件导入到HBase中，以此来达到高效批量插入数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 批量插入 多列
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
 def insertWithBulkLoadWithMulti(): Unit &lt;/span&gt;=&lt;span&gt;{

   val sparkSession &lt;/span&gt;= SparkSession.builder().appName(&quot;insertWithBulkLoad&quot;).master(&quot;local[4]&quot;&lt;span&gt;).getOrCreate()
   val sc &lt;/span&gt;=&lt;span&gt; sparkSession.sparkContext

   val tableName &lt;/span&gt;= &quot;test&quot;&lt;span&gt;
   val hbaseConf &lt;/span&gt;=&lt;span&gt; HBaseConfiguration.create()
   hbaseConf.set(HConstants.ZOOKEEPER_QUORUM, &lt;/span&gt;&quot;192.168.187.201&quot;&lt;span&gt;)
   hbaseConf.set(HConstants.ZOOKEEPER_CLIENT_PORT, &lt;/span&gt;&quot;2181&quot;&lt;span&gt;)
   hbaseConf.set(TableOutputFormat.OUTPUT_TABLE, tableName)

   val conn &lt;/span&gt;=&lt;span&gt; ConnectionFactory.createConnection(hbaseConf)
   val admin &lt;/span&gt;=&lt;span&gt; conn.getAdmin
   val table &lt;/span&gt;=&lt;span&gt; conn.getTable(TableName.valueOf(tableName))

   val job &lt;/span&gt;=&lt;span&gt; Job.getInstance(hbaseConf)
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置job的输出格式&lt;/span&gt;
&lt;span&gt;   job.setMapOutputKeyClass(classOf[ImmutableBytesWritable])
   job.setMapOutputValueClass(classOf[KeyValue])
   job.setOutputFormatClass(classOf[HFileOutputFormat2])
   HFileOutputFormat2.configureIncrementalLoad(job, table, conn.getRegionLocator(TableName.valueOf(tableName)))

   val rdd &lt;/span&gt;= sc.textFile(&quot;v2120/a.txt&quot;&lt;span&gt;)
     .map(_.split(&lt;/span&gt;&quot;,&quot;&lt;span&gt;))
     .map(x &lt;/span&gt;=&amp;gt; (DigestUtils.md5Hex(x(0)).substring(0, 3) + x(0), x(1), x(2&lt;span&gt;)))
     .sortBy(_._1)
     .flatMap(x &lt;/span&gt;=&amp;gt;&lt;span&gt;
       {
         val listBuffer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ListBuffer[(ImmutableBytesWritable, KeyValue)]
         val kv1: KeyValue &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; KeyValue(Bytes.toBytes(x._1), Bytes.toBytes(&quot;cf1&quot;), Bytes.toBytes(&quot;name&quot;), Bytes.toBytes(x._2 + &quot;&quot;&lt;span&gt;))
         val kv2: KeyValue &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; KeyValue(Bytes.toBytes(x._1), Bytes.toBytes(&quot;cf1&quot;), Bytes.toBytes(&quot;age&quot;), Bytes.toBytes(x._3 + &quot;&quot;&lt;span&gt;))
         listBuffer.append((&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ImmutableBytesWritable, kv2))
         listBuffer.append((&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ImmutableBytesWritable, kv1))
         listBuffer
       }
     )
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;多列的排序，要按照列名字母表大小来&lt;/span&gt;
&lt;span&gt;   
   isFileExist(&lt;/span&gt;&quot;hdfs://node1:9000/test&quot;&lt;span&gt;, sc)

   rdd.saveAsNewAPIHadoopFile(&lt;/span&gt;&quot;hdfs://node1:9000/test&quot;&lt;span&gt;, classOf[ImmutableBytesWritable], classOf[KeyValue], classOf[HFileOutputFormat2], job.getConfiguration)
   val bulkLoader &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LoadIncrementalHFiles(hbaseConf)
   bulkLoader.doBulkLoad(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Path(&quot;hdfs://node1:9000/test&quot;&lt;span&gt;), admin, table, conn.getRegionLocator(TableName.valueOf(tableName)))
}

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 判断hdfs上文件是否存在，存在则删除
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
def isFileExist(filePath: String, sc: SparkContext): Unit &lt;/span&gt;=&lt;span&gt;{
  val output &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Path(filePath)
  val hdfs &lt;/span&gt;= FileSystem.get(&lt;span&gt;new&lt;/span&gt; URI(filePath), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Configuration)
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hdfs.exists(output)){
    hdfs.delete(output, &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2.3 spark利用Phoenix往HBase读写数据&lt;/h2&gt;
&lt;p&gt;利用Phoenix，就如同msyql等关系型数据库的写法，需要写jdbc&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
def readFromHBaseWithPhoenix: Unit =&lt;span&gt;{
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;屏蔽不必要的日志显示在终端上&lt;/span&gt;
   Logger.getLogger(&quot;org.apache.spark&quot;&lt;span&gt;).setLevel(Level.WARN)

   val sparkSession &lt;/span&gt;= SparkSession.builder().appName(&quot;SparkHBaseDataFrame&quot;).master(&quot;local[4]&quot;&lt;span&gt;).getOrCreate()

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;表小写，需要加双引号，否则报错&lt;/span&gt;
   val dbTable = &quot;\&quot;test\&quot;&quot;

   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;spark 读取 phoenix 返回 DataFrame的第一种方式&lt;/span&gt;
   val rdf =&lt;span&gt; sparkSession.read
     .format(&lt;/span&gt;&quot;jdbc&quot;&lt;span&gt;)
     .option(&lt;/span&gt;&quot;driver&quot;, &quot;org.apache.phoenix.jdbc.PhoenixDriver&quot;&lt;span&gt;)
     .option(&lt;/span&gt;&quot;url&quot;, &quot;jdbc:phoenix:192.168.187.201:2181&quot;&lt;span&gt;)
     .option(&lt;/span&gt;&quot;dbtable&quot;&lt;span&gt;, dbTable)
     .load()

   val rdfList &lt;/span&gt;=&lt;span&gt; rdf.collect()
   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i &amp;lt;-&lt;span&gt; rdfList){
     println(i.getString(&lt;/span&gt;0) + &quot; &quot; + i.getString(1) + &quot; &quot; + i.getString(2&lt;span&gt;))
   }
   rdf.printSchema()

   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;spark 读取 phoenix 返回 DataFrame的第二种方式&lt;/span&gt;
   val df =&lt;span&gt; sparkSession.read
     .format(&lt;/span&gt;&quot;org.apache.phoenix.spark&quot;&lt;span&gt;)
     .options(Map(&lt;/span&gt;&quot;table&quot; -&amp;gt; dbTable, &quot;zkUrl&quot; -&amp;gt; &quot;192.168.187.201:2181&quot;&lt;span&gt;))
     .load()
   df.printSchema()
   val dfList &lt;/span&gt;=&lt;span&gt; df.collect()
   &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (i &amp;lt;-&lt;span&gt; dfList){
      println(i.getString(&lt;/span&gt;0) + &quot; &quot; + i.getString(1) + &quot; &quot; + i.getString(2&lt;span&gt;))
   }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;spark DataFrame 写入 phoenix，需要先建好表&lt;/span&gt;
   &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;df.write
     .format(&quot;org.apache.phoenix.spark&quot;)
     .mode(SaveMode.Overwrite)
     .options(Map(&quot;table&quot; -&amp;gt; &quot;PHOENIXTESTCOPY&quot;, &quot;zkUrl&quot; -&amp;gt; &quot;jdbc:phoenix:192.168.187.201:2181&quot;))
     .save()
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
   sparkSession.stop()
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;github地址：&lt;/p&gt;
&lt;p&gt;https://github.com/qiushangwenyue/HBaseDemo.git&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;https://my.oschina.net/uchihamadara/blog/2032481&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/simple-focus/p/6879971.html&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/MOBIN/p/5559575.html&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/Suubyy/article/details/80892023&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/b09283b14d84&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/8e3fdf70dc06&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/wumingcong/p/6044038.html&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/zhuyu_deng/article/details/43192271&lt;/p&gt;
&lt;p&gt;https://www.jianshu.com/p/4c908e419b60&lt;/p&gt;
&lt;p&gt;https://blog.csdn.net/Colton_Null/article/details/83387995&lt;/p&gt;

</description>
<pubDate>Wed, 13 Mar 2019 15:13:00 +0000</pubDate>
<dc:creator>牧梦者</dc:creator>
<og:description>1. HBase连接的方式概况 主要分为： 第一种方式是HBase自身提供的比较原始的高效操作方式，而第二、第三则分别是Spark、Flink集成HBase的方式，最后一种是第三方插件Phoenix集</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/swordfall/p/10517177.html</dc:identifier>
</item>
<item>
<title>【RAY TRACING THE REST OF YOUR LIFE 超详解】 光线追踪 3-5 random direction &amp; ONB - 林-兮</title>
<link>http://www.cnblogs.com/lv-anchoret/p/10518961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lv-anchoret/p/10518961.html</guid>
<description>&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;Preface&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;往后看了几章，对这本书有了新的理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上一篇，我们第一次尝试把MC积分运用到了Lambertian材质中，当然，第一次尝试是失败的，作者发现它的渲染效果和现实有些出入，所以结尾处声明要通过实践，改进当前的效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是乎，就有了后面的章节，几乎整本书都在讲，如何一步一步地改进上一篇的画质，使其更加符合现实，上一篇其实是抛砖引玉&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这本书的小标题名为the rest of your life&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过前面几章，我们可以更好地理解这句话：我们通过MC积分优化效果，采用的是pdf函数，之前说过，这就是一场游戏：寻找一个pdf函数，使得使用它进行重要性采样得到的渲染图形更加贴合实际，其实它是没有止境的，比如pdf是一次曲线、二次曲线、高次曲线、正态分布、高斯分布等等，对应的研究方法也是没有止境的，比如：你可以通过对光源进行pdf采样实现最终目的（比如在双向追踪中，光源也要发射光线），你也可以通过对不同材质表面的反射状态进行pdf采样，进而使得表面颜色变化更光滑更柔和更贴合实际。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上述为个人理解，可能有些出入，吾姑妄言之，汝姑妄听之，便罢。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;span&gt;Ready&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上述说到抛砖引玉，但是好像我们用的不是一张图，思量再三，还是先把砖整一个，毕竟之后都是围绕那块砖评说效果的，另辟蹊径可能不是明智之举&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，我们先把砖搞到手&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;造砖的代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;106&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt; Cornell(intersections** scene, camera**&lt;span&gt; cam, rtvar aspect)

{

      intersect &lt;/span&gt;** list = &lt;span&gt;new&lt;/span&gt; intersect*[&lt;span&gt;8&lt;/span&gt;&lt;span&gt;];

      size_t cnt &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;

      material &lt;/span&gt;* red = &lt;span&gt;new&lt;/span&gt; lambertian(&lt;span&gt;new&lt;/span&gt; constant_texture(rtvec(&lt;span&gt;0.65&lt;/span&gt;, &lt;span&gt;0.05&lt;/span&gt;, &lt;span&gt;0.05&lt;/span&gt;&lt;span&gt;)));

      material &lt;/span&gt;* white = &lt;span&gt;new&lt;/span&gt; lambertian(&lt;span&gt;new&lt;/span&gt; constant_texture(rtvec(&lt;span&gt;0.73&lt;/span&gt;, &lt;span&gt;0.73&lt;/span&gt;, &lt;span&gt;0.73&lt;/span&gt;&lt;span&gt;)));

      material &lt;/span&gt;* green = &lt;span&gt;new&lt;/span&gt; lambertian(&lt;span&gt;new&lt;/span&gt; constant_texture(rtvec(&lt;span&gt;0.12&lt;/span&gt;, &lt;span&gt;0.45&lt;/span&gt;, &lt;span&gt;0.15&lt;/span&gt;&lt;span&gt;)));

      material &lt;/span&gt;* light = &lt;span&gt;new&lt;/span&gt; areaLight(&lt;span&gt;new&lt;/span&gt; constant_texture(rtvec(&lt;span&gt;15&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;, &lt;span&gt;15&lt;/span&gt;&lt;span&gt;)));

 

      list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; flip_normal(&lt;span&gt;new&lt;/span&gt; yz_rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;&lt;span&gt;, green));

      list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; yz_rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, red);

      list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; xz_rect(&lt;span&gt;213&lt;/span&gt;, &lt;span&gt;343&lt;/span&gt;, &lt;span&gt;227&lt;/span&gt;, &lt;span&gt;332&lt;/span&gt;, &lt;span&gt;554&lt;/span&gt;&lt;span&gt;, light);

      list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; flip_normal(&lt;span&gt;new&lt;/span&gt; xz_rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;&lt;span&gt;, white));

      list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; xz_rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;, white);

      list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; flip_normal(&lt;span&gt;new&lt;/span&gt; xy_rect(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;, &lt;span&gt;555&lt;/span&gt;&lt;span&gt;, white));

      list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; translate(&lt;span&gt;new&lt;/span&gt; rotate_y(&lt;span&gt;new&lt;/span&gt; box(rtvec(), rtvec(&lt;span&gt;165&lt;/span&gt;, &lt;span&gt;165&lt;/span&gt;, &lt;span&gt;165&lt;/span&gt;), white), -&lt;span&gt;18&lt;/span&gt;), rtvec(&lt;span&gt;130&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;65&lt;/span&gt;&lt;span&gt;));

      list[cnt&lt;/span&gt;++] = &lt;span&gt;new&lt;/span&gt; translate(&lt;span&gt;new&lt;/span&gt; rotate_y(&lt;span&gt;new&lt;/span&gt; box(rtvec(), rtvec(&lt;span&gt;165&lt;/span&gt;, &lt;span&gt;330&lt;/span&gt;, &lt;span&gt;165&lt;/span&gt;), white), &lt;span&gt;15&lt;/span&gt;), rtvec(&lt;span&gt;265&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;295&lt;/span&gt;&lt;span&gt;));&lt;br/&gt;&lt;/span&gt;*scene =  &lt;span&gt;new&lt;/span&gt;&lt;span&gt; intersections(list, cnt);&lt;br/&gt;rtvec lookfrom(&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;, &lt;span&gt;278&lt;/span&gt;, -&lt;span&gt;800&lt;/span&gt;&lt;span&gt;);

      rtvec lookat(&lt;/span&gt;&lt;span&gt;278&lt;/span&gt;, &lt;span&gt;278&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);

      rtvar dist_to_focus &lt;/span&gt;= &lt;span&gt;10.0&lt;/span&gt;&lt;span&gt;;

      rtvar aperture &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;

      rtvar vfov &lt;/span&gt;= &lt;span&gt;40.0&lt;/span&gt;&lt;span&gt;;

      &lt;/span&gt;*cam = &lt;span&gt;new&lt;/span&gt; camera(lookfrom, lookat, rtvec(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;),

           vfov, &lt;/span&gt;&lt;span&gt;1&lt;/span&gt;, aperture, dist_to_focus, &lt;span&gt;0&lt;/span&gt;., &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;为了清晰点，sample改为了250，图片为200*200，为了方便重复做实验，所以参数就这样吧，能看清即可，&quot;高清大图&quot;实在是熬不起，都是夜啊，各位见谅~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;上一篇结束&lt;span&gt;之后&lt;/span&gt;的代码均不变，只是改一下Cornell 函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们得到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190312164148296-2047375551.png&quot; alt=&quot;&quot; width=&quot;208&quot; height=&quot;258&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;这就是上一篇最后得到的效果，没错&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们评说一下，这张图不仅没有减少噪点，而且高的长方体表面的颜色趋于均匀一致，与实际有偏差&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;评说好坏当然要有个参考，我们放上两张第二本书中得到的图形（未加入MC积分）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190312164426824-300059467.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190312164502510-292480399.png&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190312165246446-1152552085.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上面三张图，无论你看哪张图都能发现，正对我们的那个长方体表面是从上到下又黑到白渐变的，而且在正方体上表面高度处对应的长方体表面有一抹正方体上表面反射的白色光，而MC图形基本上呈均匀色调，甚至可能上面部分还稍白一些&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;所以我们进入今天的这一篇&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;Content&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天我们讲两章，第一章是讲三维随机方向向量的生成，这有什么用呢，它给我们的三维空间内进行重要性采样用，MC需要它！！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Chapter5 Generating Random Direction&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这一章和后续的两章，我们需要加强我们的理解和我们手中的工具，搞明白什么才是正确的Cornell Box&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;让我们首先从如何生成随机方向开始说起。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了方便，我们假定z轴为表面法线，之后再转换坐标系，与此同时，我们规定θ为从法线张开的角度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将仅仅处理关于z轴旋转对称的分布，所以其他相关的量，均设为&lt;strong&gt;&lt;span&gt;均匀分布&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;给定一个和方向相关的pdf，&lt;em&gt;&lt;strong&gt;&lt;span&gt;p(direction)&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt; &lt;span&gt;= f(θ)&lt;/span&gt;，一维pdf中θ 和 φ如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;g(φ) = 1/(2π)　　　(均匀分布)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;h(θ) = 2πf(θ)sinθ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于两个随机生成的均匀变量r1和r2，我们在&lt;a href=&quot;https://www.cnblogs.com/lv-anchoret/p/10500918.html&quot; target=&quot;_blank&quot;&gt;第三篇&lt;/a&gt;内容中推导出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;r&lt;sub&gt;1&lt;/sub&gt; = &lt;span&gt;∫&lt;span&gt;&lt;sub&gt;0-&amp;gt;φ&lt;/sub&gt;&lt;/span&gt; 1/(2π) dθ&lt;/span&gt; = φ/(2π)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得   φ = 2πr&lt;sub&gt;1&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;r&lt;sub&gt;2&lt;/sub&gt; =  &lt;span&gt;∫&lt;/span&gt;&lt;sub&gt;0-&amp;gt;θ &lt;/sub&gt;&lt;span&gt;2πf(t)sin(t) dt&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;t只是一个虚拟的量，用以代替变化的θ，然后辅助实现从0~θ对我们之前的被积函数f(θ)积分（变限积分量不能相同，所以引入t）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们从下面开始尝试不同的f()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，我们考虑球体上采取均匀密度采样，因为整个球面为4πsr，故单位球体表面均匀密度采样的pdf函数为：p(direction) = 1/(4π)，所以得到：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;r&lt;sub&gt;2&lt;/sub&gt; = &lt;span&gt;∫&lt;/span&gt;&lt;sub&gt;0-&amp;gt;θ &lt;/sub&gt;sin(t)/2 dt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 　= （-cos(t)/2）|&lt;sub&gt;0-&amp;gt;θ&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 = （1-cosθ）/2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cosθ = 1 - 2r&lt;sub&gt;2&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一般cosθ更常用一些，就不进一步求θ了，用的时候再acos()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了在笛卡尔坐标系下生成一个指向（θ，φ）的单位向量，这就涉及到我们的球坐标代换方程了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;x = cosφ sinθ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;y = sinφ sinθ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;z = cosθ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它对应的球坐标如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190312234713564-1949688934.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此处r为1&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们开始推导&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;把关于θ和φ的式子带入x,y,z中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;x = cos(2πr&lt;sub&gt;1&lt;/sub&gt;)*sqrt(1-cos&lt;sup&gt;2&lt;/sup&gt;θ)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;y = sin(2πr&lt;sub&gt;1&lt;/sub&gt;)*sqrt(1-cos&lt;sup&gt;2&lt;/sup&gt;θ)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;z = 1-2r&lt;sub&gt;2&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;解得：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;x = cos(2πr&lt;sub&gt;1&lt;/sub&gt;)*sqrt(r&lt;sub&gt;2&lt;/sub&gt;*(1-r&lt;sub&gt;2&lt;/sub&gt;))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;y = sin(2πr&lt;sub&gt;1&lt;/sub&gt;)*sqrt(r&lt;sub&gt;2&lt;/sub&gt;*(1-r&lt;sub&gt;2&lt;/sub&gt;))&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;z = 1-2r&lt;sub&gt;2&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后我们来做个图，验证一下它是否如我们所愿，生成的点聚拢为单位球面&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;作者给出的画图方法是plot.ly，可以在线画，但是它要求注册账号，流程还挺麻烦的，GitHub授权账号老是没响应（可能我网不好），如果有兴趣的可以直接到这里&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://plot.ly/create/?_ga=2.96417628.1330468440.1552244090-1882647589.1551273420#/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;直接可以载入数据使用的网址&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实matlab最好使了，对不对啊&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是乎，我们先写入txt,千万不要写入xls，还是比较麻烦的&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    stds ofstream outfile(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;random_direction.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;200&lt;/span&gt;; ++&lt;span&gt;i)
    {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; r1 =&lt;span&gt; lvgm::rand01();
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; r2 =&lt;span&gt; lvgm::rand01();
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; x = cos(&lt;span&gt;2&lt;/span&gt; * π * r1) * &lt;span&gt;2&lt;/span&gt; * sqrt(r2 * (&lt;span&gt;1&lt;/span&gt; -&lt;span&gt; r2));
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; y = sin(&lt;span&gt;2&lt;/span&gt; * π * r1) * &lt;span&gt;2&lt;/span&gt; * sqrt(r2 * (&lt;span&gt;1&lt;/span&gt; -&lt;span&gt; r2));
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; z = &lt;span&gt;1&lt;/span&gt; - &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; r2;
        outfile &lt;/span&gt;&amp;lt;&amp;lt; x &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; y &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; z &amp;lt;&amp;lt;&lt;span&gt; stds endl;
    }
    
    outfile.close();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;创建一个random_direction.xls的文件，点菜单栏中的数据-&amp;gt;自文本，选择random_direction.txt，一路回车就加载完毕了，可见xls加载文本容易多了&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假设你的路径是&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;E:\OpenGL\光线追踪\code\ray tracing 1-3\ray tracing 1-3\random_direction.xls&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据所在表的表名为sheet1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则matlab代码和效果如下图&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190312192636371-349318283.png&quot; alt=&quot;&quot; width=&quot;834&quot; height=&quot;580&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;效果还是很好的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们可以看到，它是均匀随机的，达到了我们的预期&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;呐，我们接下来试一下我们第二常用的pdf&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;即&lt;em&gt;&lt;strong&gt;&lt;span&gt;p(direction) = cosθ/π&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;r&lt;sub&gt;2 &lt;/sub&gt;= &lt;span&gt;∫&lt;/span&gt;&lt;sub&gt;0-&amp;gt;θ&lt;/sub&gt;&lt;span&gt;2π（cos(t)/π）sint&lt;/span&gt; dt&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   = (-cos&lt;sup&gt;2&lt;/sup&gt;t)|&lt;sub&gt;0-&amp;gt;θ&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   = 1 - cos&lt;sup&gt;2&lt;/sup&gt;θ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;cosθ = sqrt(1-r&lt;sub&gt;2&lt;/sub&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是乎我们得到下述的x,y,z&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;x = cos(2πr&lt;sub&gt;1&lt;/sub&gt;)*sqrt(r&lt;sub&gt;2&lt;/sub&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;y = sin(2πr&lt;sub&gt;1&lt;/sub&gt;)*sqrt(r&lt;sub&gt;2&lt;/sub&gt;)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;z = sqrt(1-r&lt;sub&gt;2)&lt;/sub&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面我们就生成随机向量&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;inline rtvec random_cosine_direction()
{
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; r1 =&lt;span&gt; lvgm::rand01();
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; r2 =&lt;span&gt; lvgm::rand01();
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; z = sqrt(&lt;span&gt;1&lt;/span&gt; -&lt;span&gt; r2);
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; φ = &lt;span&gt;2&lt;/span&gt; * π*&lt;span&gt;r1;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; x = cos(φ) * &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; sqrt(r2);
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; y = sin(φ) * &lt;span&gt;2&lt;/span&gt; *&lt;span&gt; sqrt(r2);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rtvec(x, y, z);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们按照原来的方法把第二个pdf函数产生的随机情况模拟一下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190313214127358-1391135577.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;那么我们用pdf做一个数值模拟&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; estimate2()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i)
    {
        rtvec v &lt;/span&gt;=&lt;span&gt; ::random_cosine_direction();
        sum &lt;/span&gt;+= pow(v.z(), &lt;span&gt;3&lt;/span&gt;) / (v.z() /&lt;span&gt; π);
    }
    stds cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;π/2 = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; π / &lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; stds endl;
    stds cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Estimate = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; sum / n &amp;lt;&amp;lt;&lt;span&gt; stds endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;还有一个模拟半球得到的近似，pdf = 1/（2π）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有兴趣的可以自己推一下，这里直接给代码，为了和上面做对比&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; estimate()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; n = &lt;span&gt;1000000&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; sum = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;.;
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i)
    {
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; r1 =&lt;span&gt; lvgm::rand01();
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; r2 =&lt;span&gt; lvgm::rand01();
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; x = cos(&lt;span&gt;2&lt;/span&gt; * π * r1) * &lt;span&gt;2&lt;/span&gt; * sqrt(r2 * (&lt;span&gt;1&lt;/span&gt; -&lt;span&gt; r2));
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; y = sin(&lt;span&gt;2&lt;/span&gt; * π * r1) * &lt;span&gt;2&lt;/span&gt; * sqrt(r2 * (&lt;span&gt;1&lt;/span&gt; -&lt;span&gt; r2));
        &lt;/span&gt;&lt;span&gt;double&lt;/span&gt; z = &lt;span&gt;1&lt;/span&gt; -&lt;span&gt; r2;
        sum &lt;/span&gt;+= z*z*z / (&lt;span&gt;1&lt;/span&gt;. / (&lt;span&gt;2&lt;/span&gt;.*&lt;span&gt;π));
    }
    stds cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;π/2 = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; π / &lt;span&gt;2&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; stds endl;
    stds cout &lt;/span&gt;&amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Estimate = &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; sum / n &amp;lt;&amp;lt;&lt;span&gt; stds endl;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;主函数&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;build_1_1();&lt;/span&gt;
&lt;span&gt;
    estimate();
    estimate2();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;结果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190313002602442-645391764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到模拟半球的pdf函数效果没有p() = cos/π 这个好&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这一章中所有的都是基于z轴的，而下一章我们真正基于物体表面法线进行&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;Chapter6 Ortho-normal Bases&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ONB是三个相互正交的单位向量集合，笛卡尔坐标系中的xyz轴也是一种ONB&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们这一章的目的就是把上一章基于z轴的随机方向转换到基于表面法线的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;假设，我们有一个原点&lt;em&gt;&lt;strong&gt;&lt;span&gt;o&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;和笛卡尔坐标系向量 &lt;em&gt;&lt;strong&gt;&lt;span&gt;x/y/z&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;，当我们描述一个位置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;比如：（3，-2,7）时，我们这样计算：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;location&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt; = &lt;em&gt;&lt;strong&gt;&lt;span&gt;o&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt; + 3&lt;strong&gt;&lt;em&gt;&lt;span&gt;x&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt; - 2&lt;em&gt;&lt;strong&gt;&lt;span&gt;y&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt; +7&lt;em&gt;&lt;strong&gt;&lt;span&gt;z&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;假如有另外一个坐标系，它的原点为&lt;em&gt;&lt;strong&gt;&lt;span&gt;o'&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;，基向量为 &lt;em&gt;&lt;strong&gt;&lt;span&gt;u/v/w&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们将要用如下方式表示（u，v，w）这个位置：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;em&gt;&lt;strong&gt;location&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt; = &lt;em&gt;&lt;strong&gt;&lt;span&gt;o'&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt; + u&lt;strong&gt;&lt;em&gt;&lt;span&gt;u&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt; + v&lt;strong&gt;&lt;em&gt;&lt;span&gt;v&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt; + w&lt;strong&gt;&lt;em&gt;&lt;span&gt;w&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如果学过计算机图形学，那么你就可以用矩阵变换去完成坐标系，但是我们这里不需要这种操作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们需要的是生成具有相对于表面法线的集合分布的随机方向。 我们不需要原点，因为向量无起点。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们引用&lt;a href=&quot;https://www.cnblogs.com/lv-anchoret/p/10221058.html&quot; target=&quot;_blank&quot;&gt;光线追踪1-8&lt;/a&gt;中所述的相机坐标来计算ONB的三个基向量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190313223257014-1408445676.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们现在拥有的是法向量n，我们可以把它看做是lookfrom-&amp;gt;lookat向量&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们需要一个vup,假设法向量n本身几乎平行于特定轴，那么vup就取和n垂直的基向量，反之，我们就使用特定轴作为vup&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码是描述思维最好的方式之一:(假设特定轴为x轴)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;if(fabs(n.x())&amp;gt;0.9)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　vup = (0,1,0)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;else&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　vup = (1,0,0)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们设ONB基向量由 &lt;span&gt;&lt;em&gt;&lt;strong&gt;s,t,n &lt;/strong&gt;&lt;/em&gt;&lt;/span&gt;组成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么 &lt;span&gt;&lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt; = cross(&lt;em&gt;&lt;strong&gt;vup&lt;/strong&gt;&lt;/em&gt;,&lt;em&gt;&lt;strong&gt;n&lt;/strong&gt;&lt;/em&gt;).单位化&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　 &lt;span&gt;&lt;em&gt;&lt;strong&gt;s&lt;/strong&gt;&lt;/em&gt;&lt;/span&gt; = cross(&lt;em&gt;&lt;strong&gt;t&lt;/strong&gt;&lt;/em&gt;,&lt;strong&gt;&lt;em&gt;n&lt;/em&gt;&lt;/strong&gt;)&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;理解可参考上图,t为图中的u, s为图中的v&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以我们的坐标系中的任一点（x,y,z）表示如下&lt;br/&gt;随机向量 = x&lt;span&gt;&lt;strong&gt;&lt;em&gt;s&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt; + y&lt;span&gt;&lt;strong&gt;&lt;em&gt;t&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt; + z&lt;span&gt;&lt;strong&gt;&lt;em&gt;n&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;至此，我们上代码：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; onb.hpp&lt;/span&gt;
&lt;span&gt;//&lt;/span&gt; 
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2019.3
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        ONB
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; onb
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    onb() {  }

    inline &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; &lt;span&gt;operator&lt;/span&gt;[](&lt;span&gt;int&lt;/span&gt; index)&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; axis[index]; }
        
    inline &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; u()&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; axis[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]; }
        
    inline &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; v()&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; axis[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;]; }

    inline &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; w()&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt; axis[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;]; }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:

    inline rtvec local(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a, &lt;span&gt;double&lt;/span&gt; b, &lt;span&gt;double&lt;/span&gt; c)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;;

    inline rtvec local(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; v)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; build_from_w(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
        
    rtvec axis[&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];

    };



inline rtvec onb::local(&lt;/span&gt;&lt;span&gt;double&lt;/span&gt; a, &lt;span&gt;double&lt;/span&gt; b, &lt;span&gt;double&lt;/span&gt; c)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a*u() + b*v() + c*&lt;span&gt;w();
    }

inline rtvec onb::local(&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; v)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; local(v.x(), v.y(), v.z());
    }

inline &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; onb::build_from_w(&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp;&lt;span&gt; V)
    {
    axis[&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;] =&lt;span&gt; V.ret_unitization();
    rtvec a;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fabs(w().x()) &amp;gt; &lt;span&gt;0.9&lt;/span&gt;&lt;span&gt;)
        a &lt;/span&gt;= rtvec(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        a &lt;/span&gt;= rtvec(&lt;span&gt;1&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
    axis[&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;] =&lt;span&gt; lvgm::cross(w(), a).ret_unitization();
    axis[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] =&lt;span&gt; lvgm::cross(w(), v());
    }

} &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; rt namespace&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;我们的Lambertian材质的scatter函数需要做相应的改动&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; lambertian::scatter(&lt;span&gt;const&lt;/span&gt; ray&amp;amp; rIn, &lt;span&gt;const&lt;/span&gt; hitInfo&amp;amp; info, rtvec&amp;amp; alb, ray&amp;amp; scattered, rtvar&amp;amp; pdf)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    onb uvw;
    uvw.build_from_w(info._n);
    &lt;/span&gt;&lt;span&gt;do&lt;/span&gt;&lt;span&gt; {
        rtvec direction &lt;/span&gt;=&lt;span&gt; uvw.local(random_cosine_direction());
        scattered &lt;/span&gt;=&lt;span&gt; ray(info._p, direction.ret_unitization(), rIn.time());
        pdf &lt;/span&gt;= dot(uvw.w(), scattered.direction()) /&lt;span&gt; π;
    } &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (pdf == rtvar(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;));
    alb &lt;/span&gt;= _albedo-&amp;gt;&lt;span&gt;value(info._u, info._v, info._p);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;然后我们跑一遍场景&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190313225035930-995081549.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感觉还不是很真实，好像和以前的差不多（正常，这不能算鸽~，因为第八章以后差不多才可以。。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;探索过程也是很值得借鉴的嘛，毕竟这是在一步一步引入新的技术，算是循循善诱~&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是原书结尾，下一篇我们讲牛逼的技术——直接光源采样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201903/1316111-20190313225458474-1173987367.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;感谢您的阅读，生活愉快~&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 15:11:00 +0000</pubDate>
<dc:creator>林-兮</dc:creator>
<og:description>ONB &amp;&amp; 三维随机方向分布</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lv-anchoret/p/10518961.html</dc:identifier>
</item>
<item>
<title>20190312_浅谈go&amp;java差异(一) - funnyZpC</title>
<link>http://www.cnblogs.com/funnyzpc/p/10527162.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/funnyzpc/p/10527162.html</guid>
<description>&lt;h4 id=&quot;多线程&quot;&gt;多线程&lt;/h4&gt;
&lt;p&gt;java中对于大量的比较耗时的任务多采用多线程对方式对任务进行处理，同时由于进程和线程&lt;br/&gt;本身是通过宿主机OS进行管理的，当在cpu核数较少或线程分配不当 会导致多线程的效果不佳的事常有发生&lt;/p&gt;
&lt;p&gt;代码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    //处理器核心数
    int processor = Runtime.getRuntime().availableProcessors();
    //XSSFWorkbook 一次只能写入六万多条数据，所以这里最好使用SXSSFWorkbook
    SXSSFWorkbook workBook = new SXSSFWorkbook();
    //创建格式
    CellStyle style = workBook.createCellStyle();
    //居中格式
    style.setAlignment(HorizontalAlignment.CENTER);
    //手工创建线程池
    ExecutorService executorService = new ThreadPoolExecutor(processor, processor, 1000, TimeUnit.MILLISECONDS, new LinkedBlockingDeque(),
            new ThreadFactoryBuilder().setNameFormat(&quot;poi-task-%d&quot;).build());
    //计数器 等待线程池中的线程执行完毕
    CountDownLatch countDownLatch = new CountDownLatch(processor);
    for (int i = 0; i &amp;lt; processor; i++) {
        int sheetId = i;
        //放入线程池中
        executorService.execute(() -&amp;gt; createSheet(workBook, style,sheetId, countDownLatch));
    }
    try {
        //等待所有线程执行完毕
        countDownLatch.await();
        executorService.shutdown();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;go&lt;/p&gt;
&lt;p&gt;由于进程和线程都是基于OS管理的，不可避免的产生开销；go区别与以上两者使用的是协程（goroutine），协程是线程的内的细颗粒化，&lt;br/&gt;同时它是被go自己管理的所以开销相当的小，同时一个go应用可以轻松构建上百万个goroutine，不仅如此，go也提供了通道（channel）方便&lt;br/&gt;对协程之间进行数据交互&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import (
    &quot;fmt&quot;
    &quot;sync&quot;
)

func says(s string, gw *sync.WaitGroup) {
    for i := 0; i &amp;lt; 5; i++ {
        fmt.Println(&quot;&amp;gt;&amp;gt;&amp;gt; &quot;, s)
    }
    gw.Done()
}
func main() {
    var gw sync.WaitGroup
    gw.Add(1)
    go says(&quot;Hello s&quot;, &amp;amp;gw)
    gw.Wait()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;函数参数传递&quot;&gt;函数参数传递&lt;/h4&gt;
&lt;p&gt;java对于函数值对传递采取对是值传递的方式，对于基本数据类型：传递前后值所在栈的位置是不一致的（也就是被拷贝了一份）&lt;br/&gt;对于非基本数据类型：虽然也会做拷贝，但实际上这前后的对象引用的是同一内存位置的值，这就造成了&quot;引用传递的假象&quot;&lt;/p&gt;
&lt;p&gt;代码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TransParams {

    public static void main(String[] args){
        Person p = new Person();
        p.setAge(99);
        p.setName(&quot;Lisa&quot;);

        System.out.println(p.getAge());
        System.out.println(p);
        System.out.println(&quot;======&amp;gt;split&amp;lt;=====&quot;);

        TransParams tp = new TransParams();
        tp.setValue(p);
        System.out.println(p.getAge());
        System.out.println(p);
    }

    public  void setValue(Person p){
        p.setAge(19);
    }
}
class Person {
    private Integer age;
    private String name;

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   99
   com.task.charset.Person@7e0b37bc
   ======&amp;gt;split&amp;lt;=====
   19
   com.task.charset.Person@7e0b37bc&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;import &quot;fmt&quot;

func main() {
    var s1 []string
    fmt.Println(&quot;拷贝传递前&amp;gt;&quot;, s1)
    tr01(s1)
    fmt.Println(&quot;拷贝传递后&amp;gt;&quot;, s1)

    fmt.Println(&quot;=====&amp;gt;&amp;lt;=====&quot;)

    var s2 []string
    fmt.Println(&quot;指针传递前&amp;gt;&quot;, s2)
    tr02(&amp;amp;s2)
    fmt.Println(&quot;指针传递后&amp;gt;&quot;, s2)
}

func tr01(m []string) {
    m = append(m, &quot;youth01&quot;)
}

func tr02(mm *[]string) {
    *mm = append(*mm, &quot;youth02&quot;)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;拷贝传递前&amp;gt; []
拷贝传递后&amp;gt; []
=====&amp;gt;&amp;lt;=====
指针传递前&amp;gt; []
指针传递后&amp;gt; [youth02]&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;日期格式处理&quot;&gt;日期格式处理&lt;/h4&gt;
&lt;p&gt;在java8之前jdk仅提供了Date类型的格式化，对应的日期处理类是SimpleDateFormat，&lt;br/&gt;在java8至java8之后Oracle提供了LocalDate与LocalDateTime的两种日期格式，对应的日期处理类是DateTimeFormat&lt;/p&gt;
&lt;p&gt;代码片段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Format2LocalDate {
    private static final Logger LOG = LoggerFactory.getLogger(Format2LocalDate.class);

    private static final DateTimeFormatter DATE_FORMAT_SHORT = DateTimeFormatter.ofPattern(&quot;yyyyMMdd HH:mm:ss&quot;);

    @Test
    public void transDate(){
        this.parse();
        this.format();
        LOG.info(&quot;.....................&quot;);
        this.parseD();
        this.formatD();
    }
    public void parse(){
        String str = &quot;20190116 12:12:22&quot;;
        Date today = Date.from(LocalDateTime.parse(str,DATE_FORMAT_SHORT).atZone(DateUtil.CHINA_ZONE_ID).toInstant());
        LOG.info(&quot;转换结果为&amp;gt; {}&quot;,today);
    }

    public void format(){
        LocalDateTime ldt = LocalDateTime.now();
        LOG.info(&quot;格式化字符串&amp;gt; {}&quot;,ldt.format(DATE_FORMAT_SHORT));

    }


    public final static String DATE_FORMAT = &quot;yyyy-MM-dd HH:mm:ss&quot;;


    public void parseD(){
        String dateStr = &quot;2019-01-01 12:22:33&quot;;
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(DATE_FORMAT);
        Date date = null;
        try {
             date =  simpleDateFormat.parse(dateStr);
        } catch (ParseException e) {
            e.printStackTrace();
        }
        LOG.info(&quot;转换结果为&amp;gt; {}&quot;,date);
    }

    public void formatD(){
        Date date = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(DATE_FORMAT);

        LOG.info(&quot;格式化结果为&amp;gt; {}&quot;,simpleDateFormat.format(date));

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;转换结果为&amp;gt; Wed Jan 16 12:12:22 CST 2019
格式化字符串&amp;gt; 20190313 21:20:23
.....................
转换结果为&amp;gt; Tue Jan 01 12:22:33 CST 2019
格式化结果为&amp;gt; 2019-03-13 21:20:23&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/**
  官方定义的不可更改
*/
const DATE_FORMAT string = &quot;2006-01-02 15:04:05&quot;

func main() {
    parse()
    format()
}

func parse() {
    tm := time.Now()
    strs := tm.Format(DATE_FORMAT)
    fmt.Println(&quot;日期转换为字符串&amp;gt; &quot;, strs)
}
func format() {
    tm, _ := time.Parse(DATE_FORMAT, &quot;2019-01-01 12:12:12&quot;)
    fmt.Println(&quot;字符串转换为日期&amp;gt; &quot;, tm)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;日期转换为字符串&amp;gt;  2019-03-13 21:29:30
字符串转换为日期&amp;gt;  2019-01-01 12:12:12 +0000 UTC&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;数学运算&quot;&gt;数学运算&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;//加减乘除都出现了对应的精度问题
public class MathCalcul {
    private static final Logger LOG = LoggerFactory.getLogger(MathCalcul.class);

    @Test
    public void calcul(){
        LOG.info(&quot;加： {}&quot;,0.1 + 0.2);
        LOG.info(&quot;减： {}&quot;,1.1 - 0.11);
        LOG.info(&quot;乘： {}&quot;,1.13 * 100);
        LOG.info(&quot;除： {}&quot;,100.13 / 100);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;加： 0.30000000000000004
减： 0.9900000000000001
乘： 112.99999999999999
除： 1.0012999999999999&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;func main() {
    fmt.Println(&quot;加: &quot;, 0.1+0.2)
    fmt.Println(&quot;减: &quot;, 1.1-0.11)
    fmt.Println(&quot;乘: &quot;, 1.13*100)
    fmt.Println(&quot;除: &quot;, 100.13/100)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;加:  0.3
减:  0.99
乘:  113
除:  1.0013&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;http-server&quot;&gt;http Server&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;class MyServlet extends HttpServlet{
    private static final ResourceBundle lStrings = ResourceBundle.getBundle(&quot;javax.servlet.http.LocalStrings&quot;);

    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String protocol = req.getProtocol();
        String msg = lStrings.getString(&quot;http.method_get_not_supported&quot;);
        if (protocol.endsWith(&quot;1.1&quot;)) {
            resp.sendError(405, msg);
        } else {
            resp.sendError(400, msg);
        }

    }

    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String protocol = req.getProtocol();
        String msg = lStrings.getString(&quot;http.method_post_not_supported&quot;);
        if (protocol.endsWith(&quot;1.1&quot;)) {
            resp.sendError(405, msg);
        } else {
            resp.sendError(400, msg);
        }

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;import (
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func index_handle(w http.ResponseWriter, r *http.Request) {
    fmt.Fprintf(w, &quot;Whoa,Go is cool!&quot;)
}
func main() {
    http.HandleFunc(&quot;/&quot;, index_handle)
    http.ListenAndServe(&quot;:8000&quot;, nil)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;常量与静态变量&quot;&gt;常量与静态变量&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;//静态
public static String str  = &quot;hello&quot;;
//常量
public final String str2 = &quot;hello2&quot;;
//不可变量(初始化后不可重新赋值)
public static final String str3 = &quot;hello3&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;const str string = &quot;hello&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;__本章就到这里吧，敬请期待下一讲。(^_^)__&lt;/p&gt;
&lt;p&gt;现在是 2019-03-13 22:29:50，各位晚安~&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 14:41:00 +0000</pubDate>
<dc:creator>funnyZpC</dc:creator>
<og:description>多线程 + java java中对于大量的比较耗时的任务多采用多线程对方式对任务进行处理，同时由于进程和线程 本身是通过宿主机OS进行管理的，当在cpu核数较少或线程分配不当 会导致多线程的效果不佳的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/funnyzpc/p/10527162.html</dc:identifier>
</item>
<item>
<title>SpringMvc @ResponseBody - 喜欢日向雏田一样的女子啊</title>
<link>http://www.cnblogs.com/lvbinbin2yujie/p/10513530.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lvbinbin2yujie/p/10513530.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2 id=&quot;Topic1&quot;&gt;一. @Response使用条件&lt;/h2&gt;
&lt;h3&gt;1.引入依赖jackson-databind 或者其他类型的json转换，比如gson、fastjson&lt;/h3&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: true;toolbar: true;gutter; false;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.fasterxml.jackson.core&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jackson-databind&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.8.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/pre&gt;
&lt;h3&gt;2.最小配置,&amp;lt;mvc:annotation-driven/&amp;gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;最低满足上面两个条件，即可在@RequestMapping的方法上添加注解@ResponseBody，将结果用JSON直接返回给客户端.&lt;/span&gt;&lt;/h4&gt;
&lt;hr/&gt;
&lt;h2 id=&quot;Topic2&quot;&gt;二. @Response在最小配置、jackson的jar包情况下，json中包含的日期类型字段都是以时间戳long类型返回&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;直接说结论，各位可以尽管测试，使用jackson的情况下,转换的json日期类型字段都会以时间戳long类型展示;&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;jackson最简单的API使用方式普及下，当然你也可以倒数第二行调用 writeValueAsString这样更加简单：&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: true;toolbar: true;gutter; false;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
   public static void main(String[] args) throws IOException {
        JsonEncoding encoding = JsonEncoding.UTF8;
        ObjectMapper mapper = new ObjectMapper();
        JsonGenerator generator =mapper.getFactory().createGenerator(new File(&quot;E:\\home\\1.txt&quot;),encoding);
        ObjectWriter writer = mapper.writer();
        Date date = new Date();
        writer.writeValue(generator,date);
        generator.flush();
    }
&lt;/pre&gt;
&lt;h4&gt;&lt;span&gt;查看输出文件的信息： Spring底层就是按照这个API 调用方式来生成JSON ，我们没有对ObjectMapper做任何配置，所以生成日期类型都是返回其时间戳；&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;SpringMvc 4.3中@ResponseBody时间类型是返回时间戳类型，至于其他版本测试就可以知道是否直接返回时间戳类型；&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  &lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215015924-386549831.png&quot; alt=&quot;image&quot; width=&quot;411&quot; height=&quot;94&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;二.1  Jackson Api层面记录如何取消这种时间类型生成方式&lt;/h3&gt;
&lt;h4&gt;下面用mapper代替你的new ObjectMapper()&lt;/h4&gt;
&lt;h4&gt;方式一. mapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS,false);&lt;/h4&gt;
&lt;h4&gt;                 说明：mapper  configure设置需要在 createGenerator  以及  获取writer之前才有效！&lt;/h4&gt;
&lt;h4&gt;方式二. mapper.setDateFormat(new SimpleDateFormat(&quot;yyyy--MM--dd HH:mm:ss&quot;));&lt;/h4&gt;
&lt;h4&gt;                  说明：这种方式扩展性更好，可以日期自定义格式化，相比较方式一更符合开发需求；&lt;/h4&gt;
&lt;h4&gt;方式三. 实体属性上标注注解 @JsonFormat&lt;/h4&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: true;toolbar: true;gutter; false;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
public static void main(String[] args) throws IOException {
        JsonEncoding encoding = JsonEncoding.UTF8;
        ObjectMapper mapper = new ObjectMapper();
        JsonGenerator generator =mapper.getFactory().createGenerator(new File(&quot;E:\\home\\1.txt&quot;),encoding);
        ObjectWriter writer = mapper.writer();
        PrivateMyDate date = new PrivateMyDate();
        writer.writeValue(generator,date);
        generator.flush();
}

static class PrivateMyDate{
  @JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;)
  public Date now=new Date();
}
&lt;/pre&gt;
&lt;h4&gt;&lt;span&gt;效果图如下：@JsonFormat是Jackson的，而不是Spring的！&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image_thumb31[1]&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215016648-2048155797.png&quot; alt=&quot;image_thumb31[1]&quot; width=&quot;581&quot; height=&quot;201&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;  说明：方式三应该是日常开发中最方便的，只需要在实体类上添加@JsonFormat，可以满足各种类型的日期格式&lt;/h4&gt;

&lt;hr/&gt;&lt;h2 id=&quot;Topic3&quot;&gt;三. Jack序列化对象转为JSON的限制条件&lt;/h2&gt;
&lt;h4&gt;三.1 Jackson API使用注意事项点：&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;之前偷懒, 属性修饰符、getter方法都没有写 , 误打误撞发现Jackson抛出异常&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;com.fasterxml.jackson.databind.JsonMappingException: No serializer found for class xxx and no properties discovered to create BeanSerializer (to avoid exception, disable SerializationFeature.FAIL_ON_EMPTY_BEANS)&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;当结合Spring @ResponseBody一起使用，那异常可能就是另外一种表现形式(当然下面这种异常不仅仅可能是这个Jackson Api使用注意事项引起的)&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;java.lang.IllegalArgumentException: No converter found for return value of type: class demo2.MyDate&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;h4&gt;三.1.1异常引起原因:比如尝试序列化Json这样一个实体类，就会抛出第一种异常，在Spring就会抛出第二种异常&lt;/h4&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: true;toolbar: true;gutter; false;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
public class PrivateMyDate {
    String name=&quot;123&quot;;
    int age=18;
}
&lt;/pre&gt;
&lt;h4&gt;三.1.2 异常原因说明:  Jackson2默认地序列化成JSON，实体类属性或者对应属性getter方法为 public类型，才能够将该属性成功转为Json ; 如果只是少数字段不为public类型，那这些少数字段就不会出现在转换后的Json中；如果所有字段都不是public且没有public的getter方法，就会抛出上面第一种异常 ;&lt;/h4&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h4&gt;三.1.3 异常解决方案:&lt;/h4&gt;
&lt;h4&gt;方案一.最直接的方案&lt;/h4&gt;
&lt;h3&gt;         &lt;span&gt;如果有权操作实体类，给对应实体类添加标准的getter方法(public类型，jackson默认是标准的)&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;方案二.全局级别方案&lt;/h4&gt;
&lt;h3&gt;          &lt;span&gt;obejctMapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;           说明:ANY 代表转换成JSON时候  FIELD即属性可以为任意类型，public、protected、default、private类型都可以&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;方案三.实体级别方案&lt;/h4&gt;
&lt;h4&gt;           &lt;span&gt;实体类上标注 @JsonAutoDetect(fieldVisibility = JsonAutoDetect.Visibility.ANY)即可&lt;/span&gt;&lt;/h4&gt;

&lt;h4&gt;三.1.4 Jackson2结合Spring4.x实现全局级别的@JsonFormat以及 @JsonAutoDetect&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;自己修改了下原来&amp;lt;mvc:annotation-driven/&amp;gt;达到了全局级别的效果，不用再在实体类上添加@JsonFormat以及@JsonAutoDetect; 简单说明下原理:新增了MappingJackson2HttpMessageConverter，自己配置了一个ObjectMapper，其中visibility属性篇幅较长，如果遇到第一种异常的话可以加上;&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: true;toolbar: true;gutter; false;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
&amp;lt;mvc:annotation-driven&amp;gt;
    &amp;lt;mvc:message-converters&amp;gt;
        &amp;lt;bean id=&quot;mappingJackson&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&amp;gt;
            &amp;lt;property name=&quot;objectMapper&quot;&amp;gt;
                &amp;lt;bean class=&quot;com.fasterxml.jackson.databind.ObjectMapper&quot;&amp;gt;
                    &amp;lt;property name=&quot;visibility&quot;&amp;gt;
                        &amp;lt;bean class=&quot;com.fasterxml.jackson.databind.introspect.VisibilityChecker$Std&quot;&amp;gt;
                            &amp;lt;constructor-arg name=&quot;getter&quot; value=&quot;DEFAULT&quot;/&amp;gt;   &amp;lt;!--getter方法级别的最低修饰符--&amp;gt;
                            &amp;lt;constructor-arg name=&quot;isGetter&quot; value=&quot;DEFAULT&quot;/&amp;gt;
                            &amp;lt;constructor-arg name=&quot;setter&quot; value=&quot;DEFAULT&quot;/&amp;gt;   &amp;lt;!--setter方法级别的最低修饰符--&amp;gt;
                            &amp;lt;constructor-arg name=&quot;creator&quot; value=&quot;DEFAULT&quot;/&amp;gt;  &amp;lt;!--构造器级别的最低修饰符--&amp;gt;
                            &amp;lt;constructor-arg name=&quot;field&quot; value=&quot;ANY&quot;/&amp;gt;       &amp;lt;!-- 属性级别的最低修饰符 ANY具体查看枚举Visibility--&amp;gt;
                        &amp;lt;/bean&amp;gt;
                    &amp;lt;/property&amp;gt;
                    &amp;lt;property name=&quot;dateFormat&quot;&amp;gt;
                        &amp;lt;bean class=&quot;java.text.SimpleDateFormat&quot;&amp;gt;
                            &amp;lt;constructor-arg name=&quot;pattern&quot; value=&quot;yyyy-MM-dd&quot;/&amp;gt;
                        &amp;lt;/bean&amp;gt;
                    &amp;lt;/property&amp;gt;
&lt;/pre&gt;
&lt;pre&gt;
                    &amp;lt;property name=&quot;serializationInclusion&quot; value=&quot;NON_NULL&quot;/&amp;gt; &amp;lt;!-- 如果不想序列化NULL的字段,配置这个属性 --&amp;gt;                
                &amp;lt;/bean&amp;gt;
            &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
    &amp;lt;/mvc:message-converters&amp;gt;
&amp;lt;/mvc:annotation-driven&amp;gt;
&lt;/pre&gt;
&lt;h4&gt;&lt;span&gt;基本上到这里，Spring以及Jackson2的配置都已经清楚了，用法也基本了解 @Response返回Json给客户端；这些都是&amp;lt;mvc:annotation-driven/&amp;gt;替我们完成的,下面深入了解下一些知识.&lt;/span&gt;&lt;/h4&gt;

&lt;hr/&gt;&lt;h2 id=&quot;Topic4&quot;&gt;四. @ResponseBody如何工作的&lt;/h2&gt;
&lt;h4&gt;&lt;span&gt;先说明下，这章比较无聊，我尽量记录详细些,就从调用完 Controller @RequestMapping方法开始记录&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;四.1 代码片段位于  &lt;span&gt;org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod#invokeAndHandle&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;this对象为ServletInvocableHandlerMethod, returnValueHandlers对象为HandlerMethodReturnValueHandlerComposite；returnValueHandlers顾名思义就是方法返回值处理器，&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;它持有一系列Spring为我们默默注册地HandlerMethodReturnValueHandler，专门用来针对不同@RequestMapping方法返回值，来决定怎么返回给客户端；&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;比如 ModelAndViewMethodReturnValueHandler用来处理ModelAndView的返回值，而RequestResponseBodyMethodProcessor就是用来处理 标注了@ResponseBody 的返回值；&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: true;toolbar: true;gutter; false;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
public void invokeAndHandle(ServletWebRequest webRequest,ModelAndViewContainer mavContainer, Object... providedArgs) throws Exception {
              //invokeForRequest反射执行了Controller的业务方法，还包括请求参数绑定
                Object returnValue = invokeForRequest(webRequest, mavContainer, providedArgs);
                setResponseStatus(webRequest);
               //业务方法返回值为空，不进一步判断了,设置请求处理标志位为true即可
                if (returnValue == null) {
                        if (isRequestNotModified(webRequest) || hasResponseStatus() || mavContainer.isRequestHandled()) {
                                mavContainer.setRequestHandled(true);
                                return;
                        }
                }
                else if (StringUtils.hasText(this.responseReason)) {
                        mavContainer.setRequestHandled(true);
                        return;
                }

                mavContainer.setRequestHandled(false);
                try {  
               //业务方法返回值不为null，判断如何返回响应
               //返回值处理器对象是HandlerMethodReturnValueHandlerComposite
        this.returnValueHandlers.handleReturnValue(
            returnValue, getReturnValueType(returnValue), mavContainer, webRequest);
                }
                catch (Exception ex) {
                        if (logger.isTraceEnabled()) {
                                logger.trace(getReturnValueHandlingErrorMessage(&quot;Error handling return value&quot;, returnValue), ex);
                        }
                        throw ex;
                }
        }
&lt;/pre&gt;
&lt;h4&gt;四.1.1 代码片段位于&lt;span&gt;org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#handleReturnValue&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;首先挑选上面说到的HandlerMethodReturnValueHandler，这个肯定不能随意挑选，肯定有条件的挑选，就像相亲？ 扯远了，挑选到合适的HandlerMethodReturnValueHandlers，它就知道该怎么做了，handleReturnValue处理返回值;&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: true;toolbar: true;gutter; false;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
public void handleReturnValue(Object returnValue, MethodParameter returnType,ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception {
                HandlerMethodReturnValueHandler handler = selectHandler(returnValue, returnType);
                if (handler == null) {
                        throw new IllegalArgumentException(&quot;Unknown return value type: &quot; + returnType.getParameterType().getName());
                }
                handler.handleReturnValue(returnValue, returnType, mavContainer, webRequest);
}
&lt;/pre&gt;
&lt;h4&gt;四.1.2 先看挑选的条件吧，代码位于&lt;span&gt;org.springframework.web.method.support.HandlerMethodReturnValueHandlerComposite#selectHandler&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;this指代HandlerMethodReturnValueHandlerComposite，上面说的Spring默默注册的HandlerMethodReturnValueHandler就是在returnValueHandlers集合中；遍历这个集合，挑选的条件就是：supportsReturnType，而returnType只需要知道是&lt;/span&gt;&lt;span&gt;&lt;span&gt;ReturnValueMethodParameter&lt;/span&gt;&lt;/span&gt;&lt;span&gt;类型，且持有方法的返回值即可；每个HandlerMethodReturnValueHandler的实现类肯定各自实现了supportsReturnType、以及handleReturnValue，这里只记录&lt;/span&gt; &lt;span&gt;&lt;span&gt;RequestResponseBodyMethodProcessor&lt;/span&gt;&lt;/span&gt; &lt;span&gt;就是下面会用到的用来解析 @Response 注解的HandlerMethodReturnValueHandler.&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: true;toolbar: true;gutter; false;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
private HandlerMethodReturnValueHandler selectHandler(Object value, MethodParameter returnType) {
                boolean isAsyncValue = isAsyncReturnValue(value, returnType);
                for (HandlerMethodReturnValueHandler handler : this.returnValueHandlers) {
                        if (isAsyncValue &amp;amp;&amp;amp; !(handler instanceof AsyncHandlerMethodReturnValueHandler)) {
                                continue;
                        }
                        if (handler.supportsReturnType(returnType)) {
                                return handler;
                        }
                }
                return null;
}
&lt;/pre&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h4&gt;代码片段位于&lt;span&gt;org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor#supportsReturnType&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;RequestResponseBodyMethodProcessor的supportsReturnType方法，可以看到符合条件是:@ReuqestMapping方法上标注@ResponseBody 或者 @Controller标注@ResponseBody，当然@RestController这种也是包含注解@ResponseBody;  满足条件就会直接返回这个HandlerMethodReturnValueHandler，然后使用HandlerMethodReturnValueHandler的handleReturnValue.&lt;/span&gt;&lt;/h4&gt;
&lt;h3&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215017821-745088898.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;109&quot; border=&quot;0&quot;/&gt;&lt;/h3&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h4&gt;四.1.3 挑选完毕之后，调用handleReturnValue方法；代码片段位于&lt;span&gt;org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor#handleReturnValue&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;inputMessage、outputMessage就是封装了的request以及response对象，最关键的步骤在 writeWithMessageConverters.&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: true;toolbar: true;gutter; false;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
public void handleReturnValue(Object returnValue, MethodParameter returnType,
                        ModelAndViewContainer mavContainer, NativeWebRequest webRequest)
                        throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {

                mavContainer.setRequestHandled(true);
                ServletServerHttpRequest inputMessage = createInputMessage(webRequest);
                ServletServerHttpResponse outputMessage = createOutputMessage(webRequest);

                // Try even with null return value. ResponseBodyAdvice could get involved.
                writeWithMessageConverters(returnValue, returnType, inputMessage, outputMessage);
        }
&lt;/pre&gt;
&lt;h4&gt;四.1.4 代码片段位于&lt;span&gt;org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#writeWithMessageConverters&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;writeWithMessageConverters方法省略无关重要部分后：clazz是@RequestMapping方法返回值类型，返回值为null取得是方法声明类型，type取方法声明类型；两者的区别：clazz可能用@RequestMapping方法method的getReturnType,而type是method的getGenericReturnType.   从inputMessage对象中获取原生request，并且getAcceptableMediaTypes方法，且看四.1.5 ，根据一定的策略来分析请求的MediaType ;  getProducibleMediaTypes方法且看四.1.6,  遍历请求头、请求后缀得到的MediaType，以及可以支持写回的MediaType, isCompatibleWith就是进行兼容性判断.   简单来说,比如 producibleMediaTypes 是application/json类型的,请求头或者请求后缀得出来的MediaType得是 application/json或者 */*这样的，才能叫做兼容吧.  兼容性的判断逻辑且看四.1.7 isCompatibleWith . 这里补充下，如果兼容的mediaType是*/*类型的,那就会以application/octet-stream这种形式写回.  选中了兼容的MediaType，后面的分析到四.1.8 记录.&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: true;toolbar: true;gutter; false;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
protected &amp;lt;T&amp;gt; void writeWithMessageConverters(T value, MethodParameter returnType,ServletServerHttpRequest inputMessage, ServletServerHttpResponse outputMessage)
                        throws IOException, HttpMediaTypeNotAcceptableException, HttpMessageNotWritableException {

                Class&amp;lt;?&amp;gt; clazz = getReturnValueType(value, returnType);
                Type type = getGenericType(returnType);

                HttpServletRequest servletRequest = inputMessage.getServletRequest();
                List&amp;lt;MediaType&amp;gt; requestedMediaTypes = getAcceptableMediaTypes(servletRequest);
                List&amp;lt;MediaType&amp;gt; producibleMediaTypes = getProducibleMediaTypes(servletRequest, clazz, type);

                //代码略...
                Set&amp;lt;MediaType&amp;gt; compatibleMediaTypes = new LinkedHashSet&amp;lt;MediaType&amp;gt;();
                for (MediaType requestedType : requestedMediaTypes) {
                        for (MediaType producibleType : producibleMediaTypes) {
                                if (requestedType.isCompatibleWith(producibleType)) {
                                        compatibleMediaTypes.add(getMostSpecificMediaType(requestedType, producibleType));
                                }
                        }
                }
                
                List&amp;lt;MediaType&amp;gt; mediaTypes = new ArrayList&amp;lt;MediaType&amp;gt;(compatibleMediaTypes);
                MediaType.sortBySpecificityAndQuality(mediaTypes);

                MediaType selectedMediaType = null;
                for (MediaType mediaType : mediaTypes) {
                        if (mediaType.isConcrete()) {
                                selectedMediaType = mediaType;
                                break;
                        }
                        else if (mediaType.equals(MediaType.ALL) || mediaType.equals(MEDIA_TYPE_APPLICATION)) {
                                selectedMediaType = MediaType.APPLICATION_OCTET_STREAM;
                                break;
                        }
                }
                
                //代码上部略.....
&lt;/pre&gt;
&lt;h4&gt;四.1.5 代码片段位于&lt;span&gt;org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#getAcceptableMediaTypes&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;调用了ContentNegotiationManager的resolveMediaTypes方法解析request，来判断请求的MediaType类型.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215018677-1555503248.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;86&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;代码片段位于&lt;span&gt;org.springframework.web.accept.ContentNegotiationManager#resolveMediaTypes&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;this对象指代ContentNegotiationManager，遍历其ContentNegotiationStrategy集合strategies, 调用接口的resolveMediaTypes来解析MediaType.  如果需要自定义解析请求策略，可以实现该接口ContentNegotiationStrategy.  &amp;lt;mvc:annotation-driven/&amp;gt; (spring4.x是这样) 默默为我们注册了两个PathExtensionContentNegotiationStrategy 、HeaderContentNegotiationStrategy，作用分别是用来解析 请求后缀形式、  Http  Accept的请求头.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215019429-1600135384.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;310&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;四.1.6 代码片段位于 &lt;span&gt;org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#getProducibleMediaTypes&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;首先调用request请求的getAttribute获取某些属性HandlerMapping.PRODUCIBLE_MEDIA_TYPES_ATTRIBUTE，这个属性在IDEA通过全局搜索,在RequestMappingInfoHandlerMapping中找到了setAttribute它, 这个设置是因为@RequestMapping(produce={xxxxx})这个时候保存的produce的属性.  this对象指代RequestResponseBodyMethodProcessor，其集合messageConverters也是Spring默默为我们注册的.  allSupportedMediaTypes在RequestResponseBodyMethodProcessor初始化的时候设置上的，当时就是遍历的messageConverters，调用HttpMessageConverter的getSupportedMediaTypes方法，一个个加入到allSupportedMediaTypes中的.    现在又遍历messageConverters，逐个调用canWrite方法，返回true代表符合条件,getSupportMediaTypes得到MediaType的集合，代表可以支持的响应媒体类型 ;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215020382-1512664757.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;422&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;当前messageConverter集合如下:大部分不是GenericHttpMessageConverters类型的，这类型的canWrite(returnValueClass,null)的具体逻辑两个，一支持返回值类型supports(clazz)，二可以写回null类型媒体类型MediaType;   比如ByteArrayHttpMessageConverter的supports方法就是 byte[].class == clazz，StringHttpMessageConverter的supports方法就是 String.class        == clazz  ; 另外 Jaxb2RootElementHttpMessageConverter的  supports方法就是  判断 返回值类型clazz 上面有注解 XmlRootElement ，而 MappingJackson2HttpMessageConverter       调用objectMapper.canSerialize方法判断能否序列化成JSON处理;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215021094-1056916978.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;250&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h4&gt;代码片段位于:&lt;span&gt;org.springframework.http.converter.AbstractHttpMessageConverter#canWrite(java.lang.Class&amp;lt;?&amp;gt;, org.springframework.http.MediaType)&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215021713-1025520808.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;105&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;代码片段位于:&lt;span&gt;org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter#canWrite&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image_thumb14[1]&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215022902-1099029538.png&quot; alt=&quot;image_thumb14[1]&quot; width=&quot;836&quot; height=&quot;701&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;代码片段位于:&lt;span&gt;org.springframework.http.converter.AbstractHttpMessageConverter#getSupportedMediaTypes&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;MappingJackson2HttpMessageConverter的getSupportedMediaTypes：默认初始化的时候就支持两种媒体类型了，application/json以及 application/*+json ；&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image_thumb18[1]&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215023614-655173797.png&quot; alt=&quot;image_thumb18[1]&quot; width=&quot;900&quot; height=&quot;101&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;这两种类型是初始化的时候就设置上去的，可以看到下面两种MediaType :application/json  以及 application/*+json&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image_thumb20[1]&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215024704-406636382.png&quot; alt=&quot;image_thumb20[1]&quot; width=&quot;900&quot; height=&quot;303&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;四.1.7 isCompatibleWith兼容性判断，代码片段位于:&lt;span&gt;org.springframework.util.MimeType#isCompatibleWith&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;MediaType是MimeType的子类，比如MediaType为 application/json类型的在MediaType中，application就是 type，而json就是 subType; 判断兼容性逻辑呢：this是请求中的Accpet，代表客户端接受的请求媒体类型,  other此时代表当前可以返回给你的媒体类型；this 对象或者 other对象的 type一方为 *，那两个媒体类型就是兼容的，比如 */subType1 就是兼容任何媒体类型 ； type相等的情况 , subType不存在 +号的情况下 ，有一方子类型为 * ，两个MediaType也是兼容的；两个MediaType subType一致那更不用说了是兼容的，两个媒体子类型不一致 如 application/json和 application/xml就是不兼容的 ； 子类型存在 + 号的情况下，比如application/json和 application/*+json也是不兼容的.&lt;/span&gt;&lt;/h4&gt;
&lt;pre class=&quot;brush: java;html-script: false;quick-code: true;smart-tabs: true;auto-links: true;toolbar: true;gutter; false;light: false;ruler: false;pad-line-numbers: 2;collapse: false;tab-size: 4;first-line: 1;&quot;&gt;
public boolean isCompatibleWith(MimeType other) {
                if (other == null) return false;
                if (isWildcardType() || other.isWildcardType()) {
                        return true;
                }
                else if (getType().equals(other.getType())) {
                        if (getSubtype().equals(other.getSubtype())) return true;
                        
                        // wildcard with suffix? e.g. application/*+xml
                        if (this.isWildcardSubtype() || other.isWildcardSubtype()) {

                                int thisPlusIdx = getSubtype().indexOf('+');
                                int otherPlusIdx = other.getSubtype().indexOf('+');

                                if (thisPlusIdx == -1 &amp;amp;&amp;amp; otherPlusIdx == -1) {
                                        return true;
                                }
                                else if (thisPlusIdx != -1 &amp;amp;&amp;amp; otherPlusIdx != -1) {
                                        String thisSubtypeNoSuffix = getSubtype().substring(0, thisPlusIdx);
                                        String otherSubtypeNoSuffix = other.getSubtype().substring(0, otherPlusIdx);

                                        String thisSubtypeSuffix = getSubtype().substring(thisPlusIdx + 1);
                                        String otherSubtypeSuffix = other.getSubtype().substring(otherPlusIdx + 1);

                                        if (thisSubtypeSuffix.equals(otherSubtypeSuffix) &amp;amp;&amp;amp;
                                                        (WILDCARD_TYPE.equals(thisSubtypeNoSuffix) || WILDCARD_TYPE.equals(otherSubtypeNoSuffix))) {
                                                return true;
                                        }
                                }
                        }
                }
                return false;
        }
&lt;/pre&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h4&gt;四.1.8 代码片段位于:&lt;span&gt;org.springframework.web.servlet.mvc.method.annotation.AbstractMessageConverterMethodProcessor#writeWithMessageConverters&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;指定了MediaType为application/json, 遍历messageConverters集合，分别调用canWrite方法判断是否支持将返回值写回Response,这次与四.1.5不同的是，指定了MediaType；&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;this指代RequestResponseBodyMethodProcessor对象，其advice属性为RequestResponseBodyAdviceChain，beforeBodyWrite方法用来处理@JsonView.&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;addContentDispositionHeader用来满足一定条件时设置Content-Disposition响应头.&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;准备工作都完成后,调用GenericHttpMessageConverter的write方法,这里完成JSON转换以及写到response、设置响应头的工作.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215025818-1610594664.png&quot; alt=&quot;image&quot; width=&quot;787&quot; height=&quot;637&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;四.1.9 代码片段位于:&lt;span&gt;org.springframework.http.converter.AbstractGenericHttpMessageConverter#write&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;这里并没有开始写回操作,响应头也没有写回,只是记录到HttpOutputMessage的HttpHeaders属性中.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image_thumb24[1]&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215027171-1694977076.png&quot; alt=&quot;image_thumb24[1]&quot; width=&quot;900&quot; height=&quot;527&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;代码片段位于:&lt;span&gt;org.springframework.http.converter.json.AbstractJackson2HttpMessageConverter#writeInternal&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;调用的是Jackson2的API, 其中 JsonGenerator generator = this.objectMapper.getFactory().createGenerator(outputMessage.getBody(), encoding);HttpOutputMessage.getBody方法，给response添加了响应头，并且获取了response的outputStream流， Jackson2转换的对象就在这里直接写到了响应输出流中；方法结束之后，直接调用response的flush，到这里@ResponseBody流程大致跑了一遍.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215028180-1925249884.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;680&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;四.2 请求json或者xml形式数据两种方式 (1)后缀名限制  (2)请求头限制&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;前面四.1.5提到支持请求后缀形式解析MediaType,&amp;lt;mvc:annotation-driven/&amp;gt; (spring4.x是这样) 默默为我们注册了两个PathExtensionContentNegotiationStrategy 、HeaderContentNegotiationStrategy. 这两个ContentNegotiationStrategy的实现类.   先看下这两个ContentNegotiationStrategy达到了什么样的效果?&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;效果图如下:  SpringMvc拦截 / 的所有请求, 但是可以根据  后缀名 .json  .xml来返回对应的结果, 这就是ContentNegotiationStrategy起到的作用;&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;首先要想实现这种效果,需要的条件有: 1.开启&amp;lt;mvc:annotation-driven /&amp;gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;2. 引入第三方json的jar, jackson 或者 gson就可以支持 json ,且不需要自己配置HttpMessageConverter，除此之外的 json 第三方jar需要自己配置 HttpMessageConverter;&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;3.不引入第三方xml的jar情况下，jdk自带的jaxb，实体类上标注@XmlRootElement即可支持xml ；pom依赖引入 jackson-dataformat-xml 即可使用jackson，将实体类转为xml;&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;这种情况使用方式: 1.后缀名请求：  url后跟上需要的类型.json 或者 .xml&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;                          2.请求头Accept：application/json 或者 application/xml&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;悄悄说下我的发现,假如不加后缀名请求, 如果Xml、Json都支持，那会先返回Xml结果&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215029431-378766089.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;280&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;四.2.1 HeaderContentNegotiationStrategy原理记录&lt;/h3&gt;
&lt;h4&gt;代码片段位置:&lt;span&gt;org.springframework.web.accept.HeaderContentNegotiationStrategy#resolveMediaTypes&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;根据request对象的Accept请求头字符串,转换为MediaType集合，也就是四.1.5的逻辑&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image_thumb15[1]&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215030733-1400283470.png&quot; alt=&quot;image_thumb15[1]&quot; width=&quot;899&quot; height=&quot;579&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;四.2.2 ServletPathExtensionContentNegotiationStrategy原理记录&lt;/h3&gt;
&lt;h4&gt;代码片段位于:&lt;span&gt;org.springframework.web.accept.PathExtensionContentNegotiationStrategy#getMediaTypeKey&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;&lt;span&gt;ServletPathExtensionContentNegotiationStrategy&lt;/span&gt;&lt;/span&gt;&lt;span&gt;父类AbstractMappingContentNegotiationStrategy实现resolveMediaTypes方法，resolveMediaTypes调用resolveMediaTypeKey方法，resolveMediaTypeKey调用getMediaTypeKey方法，其实就是解析了请求的后缀名，比如 json或者xml,  根据后缀名去mediaTypes集合查找对应的MediaType,ServletPathExtensionContentNegotiationStrategy的mediaTypes是解析&amp;lt;mvc:annotation-driven/&amp;gt;时候动态判断jar（jackson gson jaxb这些jar）包添加的，暂时只支持到json / xml这两个，不过也是支持扩展的;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image_thumb17[1]&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215031783-305384586.png&quot; alt=&quot;image_thumb17[1]&quot; width=&quot;900&quot; height=&quot;258&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h2 id=&quot;Topic5&quot;&gt;五. Spring偏底层记录.&lt;/h2&gt;
&lt;h4&gt;五.1 MappingJackson2HttpMessageConverter是如何创建，又如何加入到上面四.1的HandlerMethodReturnValueHandlerComposite中?&lt;/h4&gt;
&lt;h4&gt;代码片段位于:&lt;span&gt;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#afterPropertiesSet&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;HandlerMethodReturnValueHandlerComposite是RequestMappingHandlerAdapter的属性，其afterPropertiesSet方法最后, getDefaultReturnValueHandlers方法获取到的HandlerMethodReturnValueHandler集合，加入到了returnValueHandlers中；&lt;/span&gt;&lt;span&gt;&lt;span&gt;getDefaultReturnValueHandlers&lt;/span&gt;&lt;/span&gt;&lt;span&gt;有这样一句代码：&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(),this.contentNegotiationManager, this.requestResponseBodyAdvice));  &lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;这里可以看到RequestResponseBodyMethodProcessor的三个重要属性都已经赋值完毕，messageConverters、contentNegotiationManager、requestResponseBodyAdvice，而且都是直接引用的RequestMappingHandlerAdapter对象的属性.  问题就归结于RequestMappingHandlerAdapter的三个属性了.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image_thumb34[1]&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215032825-265596545.png&quot; alt=&quot;image_thumb34[1]&quot; width=&quot;900&quot; height=&quot;329&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;代码片段位于:&lt;span&gt;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#getDefaultReturnValueHandlers&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215034879-971543060.png&quot; alt=&quot;image&quot; width=&quot;900&quot; height=&quot;792&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;五.1.1 RequestMappingHandlerAdapter的messageConverters哪里来的？&lt;/h4&gt;
&lt;h4&gt;代码片段位于:&lt;span&gt;org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser#getMessageConverters&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;&amp;lt;mvc:annotation-driven/&amp;gt;开启之后, AnnotationDrivenBeanDefinitionParser的parse方法进行解析; 解析规则：mvc:annotation-driven下有message-converters子标签，就将这个messageConverter对象加入messageConverters集合,同时,如果message-converters这个子标签的register-defaults属性为true,那把Spring为我们默认创建的一起加入到messageConverters，该register-defaults属性默认为true;  这就意味着 上面我的那种写法其实是两个MappingJackson2HttpMessageConverter，但是自定义加入的HttpMessageConverter会在集合的前端.&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;没有message-converters子标签,那就直接使用Spring为我们默认创建的HttpMessageConverter对象,常见的ByteArrayHttpMessageConverter 这些都是Spring默认会添加的,下图就是几个比较复杂的, 比如当前引入了jackson-dataformat-xml这个包，那jackson2XmlPresent就为true,那默认就不会注册jaxb的JaxbRootElementHttpMessageConverter;&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;比如引入了jackson-databind以及相关jar,那注册的就是MappingJackson2HttpMessageConverter,而不会注册Gson相对应的HttpMessageConverter了;&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;这里也就看到了MappingJackson2HttpMessageConverter如何创建的,原来是我们引入了jackson-databind相关的jar包，&amp;lt;mvc:annotation-driven/&amp;gt;就会自动创建;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image_thumb40[1]&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215036381-1125468093.png&quot; alt=&quot;image_thumb40[1]&quot; width=&quot;900&quot; height=&quot;471&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;代码片段位于:&lt;span&gt;org.springframework.web.servlet.mvc.method.annotation.RequestResponseBodyMethodProcessor#RequestResponseBodyMethodProcessor&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;结合五.1来看，RequestResponseBodyMethodProcessor，验证了四.1.6,RequestResponseBodyMethodProcessor的allSupportedMediaTypes是遍历的messageConverters的getSupportedMediaTypes来的.&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;img title=&quot;image_thumb2[2]&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215037753-298810061.png&quot; alt=&quot;image_thumb2[2]&quot; width=&quot;900&quot; height=&quot;586&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;h4&gt;五.1.2 requestResponseBodyAdvice作用简单记录下.&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;requestResponseBodyAdvice 是Spring帮我们创建的，目前是为了支持@JsonView注解，定义上说是为了在@ResponseBody处理之前进行一些切面操作.&lt;/span&gt;&lt;/h4&gt;

&lt;h4&gt;五.1.3 contentNegotiationManager&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;contentNegotiationManager我想我们应该主要关心，什么时候注册的两个四.2的HeaderContentNegotiationStrategy以及ServletPathExtensionContentNegotiationStrategy?&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;代码片段位于:&lt;/span&gt;&lt;span&gt;&lt;span&gt;org.springframework.web.accept.ContentNegotiationManagerFactoryBean#afterPropertiesSet&lt;/span&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;ContentNegotiationManager是通过FactoryBean ContentNegotiationManagerFactoryBean来实现生成, 在这里就可以发现设置的两种ContentNegotiationStrategy.&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;img title=&quot;image_thumb61&quot; src=&quot;https://img2018.cnblogs.com/blog/1550387/201903/1550387-20190313215039108-425590519.png&quot; alt=&quot;image_thumb61&quot; width=&quot;900&quot; height=&quot;661&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;h3 id=&quot;Topic6&quot;&gt;六.参考文章&lt;/h3&gt;
&lt;h4&gt;六.1 推荐一个非常有用的网站，学习Jackson很有帮助的网站&lt;/h4&gt;
&lt;h4&gt;&lt;a title=&quot;https://www.baeldung.com/category/json/jackson/&quot; href=&quot;https://www.baeldung.com/category/json/jackson/&quot;&gt;https://www.baeldung.com/category/json/jackson/&lt;/a&gt;&lt;/h4&gt;

&lt;h4&gt;六.2 推荐一个Firefox上访问StackOverFlow起飞的插件&lt;/h4&gt;
&lt;h4&gt;&lt;span&gt;网站访问StackOverFlow，由于谷歌被墙,  安装插件Decentraleyes，2019.3.13仍在使用，访问到飞起,安装方式自行百度&lt;/span&gt;&lt;/h4&gt;
</description>
<pubDate>Wed, 13 Mar 2019 14:21:00 +0000</pubDate>
<dc:creator>喜欢日向雏田一样的女子啊</dc:creator>
<og:description>一.@Response使用条件 二. @Response在最小配置、jackson的jar包情况下，json中包含的日期类型字段都是以时间戳long类型返回 三. Jack序列化对象转为JSON的限制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lvbinbin2yujie/p/10513530.html</dc:identifier>
</item>
<item>
<title>[NewLife.XCode]反向工程（自动建表建库大杀器） - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/xcode_negative.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/xcode_negative.html</guid>
<description>&lt;p&gt;NewLife.XCode是一个有10多年历史的开源数据中间件，支持nfx/netstandard，由新生命团队(2002~2019)开发完成并维护至今，以下简称XCode。&lt;/p&gt;
&lt;p&gt;整个系列教程会大量结合示例代码和运行日志来进行深入分析，蕴含多年开发经验于其中，代表作有百亿级大数据实时计算项目。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/NewLifeX/X&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/X &lt;/a&gt;（求star, 656+）&lt;/p&gt;


&lt;p&gt;反向工程是XCode的大杀器，区别于其它ORM的最强功能！&lt;/p&gt;
&lt;p&gt;通俗理解：&lt;span&gt;&lt;strong&gt;基于XCode开发的应用，无需数据库安装脚本，连接字符串指向哪一台哪一种数据库，系统就自动在上面建库建表！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;正式定义：&lt;span&gt;&lt;strong&gt;基于实体类的表结构信息，在连接字符串指定的目标数据库上自动执行建库建表、添删改字段、创建索引等操作，支持各种数据库！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;应用系统首次启动完成的时候，也是自动建表建库并初始化完成的时候。&lt;/p&gt;
&lt;p&gt;反向工程是XCode数万级分表的主要倚仗！&lt;/p&gt;

&lt;p&gt;创建控制台项目，从Nuget引用NewLife.XCode&lt;/p&gt;
&lt;p&gt;创建实体类，模型如下（可参考前面几章来生成实体类）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190313213807944-161771297.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 测试代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190313212713873-494152546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 执行日志：&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190313213657847-1821578286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;自始至终，我们没有编写SQL脚本，没有去数据库创建数据表。&lt;/p&gt;
&lt;p&gt;代码写完就跑起来，测试通过就部署到正式库。&lt;/p&gt;
&lt;p&gt;从日志来看，程序自动下载SQLite驱动，因为我们并没有指定实体类使用哪一种数据库，XCode自动给我们配置了SQLite。（上一章连接字符串部分有讲解）&lt;/p&gt;

&lt;p&gt;加一行代码把数据库指向MySql：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190313214058609-672503395.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 执行日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190313214458012-326842231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样的首先下载MySql驱动，（当然也可以自己通过nuget引用）。&lt;/p&gt;
&lt;p&gt;首次连接数据库时，库名指定School报错，因为根本就不存在这个库。&lt;/p&gt;
&lt;p&gt;因此，XCode切换到系统库，开始创建数据库School，并创建数据表和索引。这里完全是MySql语法，不同于上面的SQLite建表语句。&lt;/p&gt;

&lt;p&gt;感兴趣的同学，还可以试试Oracle和SqlServer等数据库。&lt;/p&gt;


&lt;p&gt;正向工程就是从数据库读取表结构信息，生成模型信息。&lt;/p&gt;
&lt;p&gt;我们来试试写几行代码读取上面创建的数据表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190313215351491-1281961612.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行日志：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190313215445510-381268438.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面可以看到，读取dal.Tables得到了这个连接的所有表结构信息，输出为Xml时，跟前面用来创建实体类的模型文件极为相似。&lt;/p&gt;
&lt;p&gt;其实这就是一个模型文件，只是为了生成实体类的模型文件多增加了几个属性而已。&lt;/p&gt;
&lt;p&gt;新生命码神工具XCoder，（&lt;a href=&quot;https://github.com/NewLifeX/XCoder&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/XCoder&lt;/a&gt;），其中的数据建模工具，可以导出各种数据库的表结构信息，正是基于dal.Tables来实现。&lt;/p&gt;

&lt;p&gt;正向工程由3个基本接口构成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;IDataTable。数据表接口，dal.Tables就是IDataTable集合，包括名称、描述等&lt;/li&gt;
&lt;li&gt;IDataColumn。数据列接口，每张数据表有多个数据列，包括名称、类型、长度、描述等&lt;/li&gt;
&lt;li&gt;IDataIndex。数据索引接口，每张数据表没有或者有多个索引，索引指定包括哪些字段 ，是否唯一&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;有了IDataTable，我们就可以主动控制数据表结构。&lt;/p&gt;
&lt;p&gt;DAL.SetTables(IDataTable[] tables);&lt;/p&gt;
&lt;p&gt;这是反向工程高级用法，实际日常工作中用不到，各个实体类加载时，将会逐个连接进行反向工程检查，正是调用该方法。&lt;/p&gt;

&lt;p&gt;给上面的数据模型，增加一个字段Code和对应索引：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190313220935280-256684427.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;跑起来：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190313221022718-775691184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;程序自动为我们添加了字段，以及创建了索引！&lt;/p&gt;
&lt;p&gt;前面的几个SHOW，就是XCode的正向工程，取得数据库表结构，然后跟实体类结构对比，不相同时执行反向操作。&lt;/p&gt;


&lt;p&gt;大家还记得上一章系统设置中提到的Migration吗？&lt;/p&gt;
&lt;p&gt;XCode.config和连接字符串中都支持这个设置。&lt;/p&gt;
&lt;p&gt;可用设置项如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Off 关闭，不执行反向工程&lt;/li&gt;
&lt;li&gt;ReadOnly 只读不执行，异步执行反向工程检查，对比后生成变更DDL写入日志&lt;/li&gt;
&lt;li&gt;On 打开，仅新建，默认设置。新建表、增加字段、创建索引等可以执行，禁止修改字段长度类型，禁止删除字段，以免造成数据丢失&lt;/li&gt;
&lt;li&gt;Full 完全，修改删除。除了新建表、增加字段、创建索引外，还可以修改字段长度类型、删除字段等，极其危险，慎用&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;反向工程设计于2008年，10多年经验表明，默认On最合理，不仅满足开发需要，（随时加字段），还避免了字段改变而导致的数据丢失风险；&lt;/p&gt;

&lt;p&gt;反向工程如此神奇的功能，你想到了什么高端用法吗？我们将在数万级分表分库章节等你！&lt;/p&gt;


&lt;p&gt;NewLife.XCode教程系列[2019版]&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd.html&quot; target=&quot;_blank&quot;&gt;增删改查入门&lt;/a&gt;。快速展现用法，代码配置连接字符串&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_model.html&quot; target=&quot;_blank&quot;&gt;数据模型文件&lt;/a&gt;。建立表格字段和索引，名字以及数据类型规范，推荐字段（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html&quot; target=&quot;_blank&quot;&gt;实体类详解&lt;/a&gt;。数据类业务类，泛型基类，接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_setting.html&quot; target=&quot;_blank&quot;&gt;功能设置&lt;/a&gt;。连接字符串，调试开关，SQL日志，慢日志，参数化，执行超时。代码与配置文件设置，连接字符串局部设置&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_negative.html&quot; target=&quot;_blank&quot;&gt;反向工程&lt;/a&gt;。自动建立数据库数据表&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_initdata.html&quot; target=&quot;_blank&quot;&gt;数据初始化&lt;/a&gt;。InitData写入初始化数据&lt;/li&gt;
&lt;li&gt;高级增删改。重载拦截，自增字段，Valid验证，实体模型（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;脏数据。如何产生，怎么利用&lt;/li&gt;
&lt;li&gt;增量累加。高并发统计&lt;/li&gt;
&lt;li&gt;事务处理。单表和多表，不同连接，多种写法&lt;/li&gt;
&lt;li&gt;扩展属性。多表关联，Map映射&lt;/li&gt;
&lt;li&gt;高级查询。复杂条件，分页，自定义扩展FieldItem，查总记录数，查汇总统计&lt;/li&gt;
&lt;li&gt;数据层缓存。Sql缓存，更新机制&lt;/li&gt;
&lt;li&gt;实体缓存。全表整理缓存，更新机制&lt;/li&gt;
&lt;li&gt;对象缓存。字典缓存，适用用户等数据较多场景。&lt;/li&gt;
&lt;li&gt;百亿级性能。字段精炼，索引完备，合理查询，充分利用缓存&lt;/li&gt;
&lt;li&gt;实体工厂。元数据，通用处理程序&lt;/li&gt;
&lt;li&gt;角色权限。Membership&lt;/li&gt;
&lt;li&gt;导入导出。Xml，Json，二进制，网络或文件&lt;/li&gt;
&lt;li&gt;分表分库。常见拆分逻辑&lt;/li&gt;
&lt;li&gt;高级统计。聚合统计，分组统计&lt;/li&gt;
&lt;li&gt;批量写入。批量插入，批量Upsert，异步保存&lt;/li&gt;
&lt;li&gt;实体队列。写入级缓存，提升性能。&lt;/li&gt;
&lt;li&gt;备份同步。备份数据，恢复数据，同步数据&lt;/li&gt;
&lt;li&gt;数据服务。提供RPC接口服务，远程执行查询，例如SQLite网络版&lt;/li&gt;
&lt;li&gt;大数据分析。ETL抽取，调度计算处理，结果持久化&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Wed, 13 Mar 2019 14:19:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<og:description>反向工程是XCode的大杀器，区别于其它ORM的最强功能！ 通俗理解：基于XCode开发的应用，无需数据库安装脚本，连接字符串指向哪一台哪一种数据库，系统就自动在上面建库建表！ 正式定义：基于实体</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/xcode_negative.html</dc:identifier>
</item>
<item>
<title>面试官问我，Redis分布式锁如何续期？懵了。 - 手留余香·</title>
<link>http://www.cnblogs.com/yuxiang1/p/10527028.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuxiang1/p/10527028.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;上一篇[面试官问我，使用Dubbo有没有遇到一些坑？我笑了。]之后,又有一位粉丝和我说在面试过程中被虐了.鉴于这位粉丝是之前肥朝的&lt;strong&gt;&lt;code&gt;粉丝&lt;/code&gt;&lt;/strong&gt;,而且周一又要开启新一轮的面试,为了回馈他长期以来的支持,所以连夜写了本篇,希望能对他接下来的面试有所帮助.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;真实案例&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://pic2.zhimg.com/v2-0a22fe6160b129c6cfbfa05f701662e5_r.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://pic2.zhimg.com/v2-0a22fe6160b129c6cfbfa05f701662e5_r.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;Redis分布式锁的正确姿势&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;据肥朝了解,很多同学在用分布式锁时,都是直接百度搜索找一个Redis分布式锁工具类就直接用了.关键是该工具类中还充斥着很多&lt;code&gt;System.out.println();&lt;/code&gt;等语句.其实Redis分布式锁比较正确的姿势是采用&lt;code&gt;redisson&lt;/code&gt;这个客户端工具.具体介绍可以搜索最大的同性交友网站&lt;code&gt;github&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;如何回答&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;首先如果你之前用Redis的分布式锁的姿势正确,并且看过相应的官方文档的话,这个问题&lt;code&gt;So easy&lt;/code&gt;.我们来看&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://pic1.zhimg.com/v2-9fff60cb42e988da297297fa8e30414c_r.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://pic1.zhimg.com/v2-9fff60cb42e988da297297fa8e30414c_r.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;坦白说,如果你英文棒棒哒那么看英文文档可能更好理解&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;By default lock watchdog timeout is 30 seconds and can be changed through Config.lockWatchdogTimeout setting.&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;但是你如果看的是中文文档&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;看门狗检查锁的超时时间默认是30秒&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;这句话肥朝从语文角度分析就是一个歧义句,他有两个意思&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;1.看门狗默认30秒去检查一次锁的超时时间&lt;/span&gt;&lt;br/&gt;&lt;span&gt;2.看门狗会去检查锁的超时时间,锁的时间时间默认是30秒&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;看到这里,我希望大家不要黑我的小学体育老师,虽然他和语文老师是同个人.语文不行,我们可以源码来凑!&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;源码分析&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们根据官方文档给出的例子,写了一个最简单的demo,例子根据上面截图中&lt;code&gt;Ctr+C和Ctr+V&lt;/code&gt;一波操作,如下&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;create&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://oscimg.oschina.net/oscnet/7ae587167b2d09d72e1cee9e7857a39eab6.jpg&quot; alt=&quot;&quot; width=&quot;1080&quot; height=&quot;347&quot; data-cke-saved-src=&quot;https://oscimg.oschina.net/oscnet/7ae587167b2d09d72e1cee9e7857a39eab6.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从这里我们知道,&lt;code&gt;internalLockLeaseTime&lt;/code&gt; 和 &lt;code&gt;lockWatchdogTimeout&lt;/code&gt;这两个参数是相等的.&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;从&lt;code&gt;internalLockLeaseTime&lt;/code&gt;这个单词也可以看出,这个加的分布式锁的超时时间默认是30秒.但是还有一个问题,那就是这个看门狗,多久来延长一次有效期呢?我们往下看&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;lock&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-4da3977c00a892c54cd83abcaee62e13_r.jpg&quot; alt=&quot;&quot; data-cke-saved-src=&quot;https://pic4.zhimg.com/v2-4da3977c00a892c54cd83abcaee62e13_r.jpg&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从我图中框起来的地方我们就知道了,获取锁成功就会开启一个定时任务,也就是&lt;code&gt;watchdog&lt;/code&gt;,定时任务会定期检查去续期&lt;code&gt;renewExpirationAsync(threadId)&lt;/code&gt;.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里定时用的是&lt;code&gt;netty-common&lt;/code&gt;包中的&lt;code&gt;HashedWheelTimer&lt;/code&gt;,肥朝公众号已经和各大搜索引擎建立了密切的合作关系,你只需要把这个类在任何搜索引擎一搜,都能知道相关API参数的意义.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从图中我们明白,该定时调度每次调用的时间差是&lt;code&gt;internalLockLeaseTime / 3&lt;/code&gt;.也就10秒.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;真相大白&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;通过源码分析我们知道,默认情况下,加锁的时间是30秒.如果加锁的业务没有执行完,那么到 30-10 = 20秒的时候,就会进行一次续期,把锁重置成30秒.那这个时候可能又有同学问了,那业务的机器万一宕机了呢?宕机了定时任务跑不了,就续不了期,那自然30秒之后锁就解开了呗.&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;写在最后&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;如果你是肥朝公众号的老粉丝,并且在面试、工作过程中遇到了什么问题,欢迎来撩.但是肥朝是个正经的Java开发,我们只调接口,不调情!&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者：肥朝&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.6388888888889&quot;&gt;
&lt;p&gt;&lt;span&gt;免费Java资料领取，涵盖了Java、Redis、MongoDB、MySQL、Zookeeper、Spring Cloud、Dubbo/Kafka、Hadoop、Hbase、Flink等高并发分布式、大数据、机器学习等技术。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;传送门： &lt;a href=&quot;http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/JzddfH-7yNudmkjT0IRL8Q&quot; target=&quot;_blank&quot; data-cke-saved-href=&quot;http://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s/JzddfH-7yNudmkjT0IRL8Q&quot;&gt;https://mp.weixin.qq.com/s/JzddfH-7yNudmkjT0IRL8Q&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 13 Mar 2019 14:13:00 +0000</pubDate>
<dc:creator>手留余香&amp;#183;</dc:creator>
<og:description>前言 上一篇[面试官问我，使用Dubbo有没有遇到一些坑？我笑了。]之后,又有一位粉丝和我说在面试过程中被虐了.鉴于这位粉丝是之前肥朝的粉丝,而且周一又要开启新一轮的面试,为了回馈他长期以来的支持,所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuxiang1/p/10527028.html</dc:identifier>
</item>
<item>
<title>ARP和RARP协议详解 - wintrysec</title>
<link>http://www.cnblogs.com/wintrysec/p/10526967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wintrysec/p/10526967.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;为什么要用ARP？即ARP的作用&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;(1) &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;TCP/IP 的32bit的IP地址，仅知道主机的IP地址不能让内核发送数据帧给主机&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;(2) &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;网络接口的硬件地址，它是一个48bit的值，用来标识不同的以太网或令牌环网络接口&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;在硬件层次上，进行数据交换必须有正确的接口地址，内核必须知道目的端的硬件地址才能发送数据&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在以太网中，一台主机要把数据帧发送到同一局域网上的另一台主机时&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;设备驱动程序必须知道以太网地址才能发送数据&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;而我们只知道IP地址，这时就需要采用ARP协议将IP地址映射为以太网地址&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;( 以太网地址即：硬件地址 MAC )&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;ARP在OSI模型中的位置&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;OSI模型有七层，TCP在第4层传输层，IP在第3层网络层，而ARP在第2层数据链路层&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;高层对低层是有强依赖的，所以TCP的建立前要进行ARP的请求和应答&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ARP高速缓存表在IP层使用&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果每次建立TCP连接都发送ARP请求，会降低效率，因此在主机、交换机、路由器上都会有ARP缓存表&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;建立TCP连接时先查询ARP缓存表，如果有效，直接读取ARP表项的内容进行第二层数据包的发送；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;只有表失效时才进行ARP请求和应答进行MAC地址的获取，以建立TCP连接&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;ARP高速缓存&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;每个主机都有一个ARP高速缓存表，这样避免每次发包时都需要发送ARP请求来获取硬件地址&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;默认老化时间是20分钟，利用&lt;span&gt;&lt;code&gt;arp -a&lt;/code&gt;&lt;span&gt;命令可以查看显示系统中高速缓存的内容&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Windows下&lt;span&gt;&lt;code&gt;arp -d&lt;/code&gt;&lt;span&gt;命令可以清除arp高速缓存表&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1610491/201903/1610491-20190313215958416-1669934388.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5CAdministrator%5CDesktop%5C802212-20161126102714893-597098126.png&quot;&gt;&lt;img src=&quot;file://c/Users/Administrator/Desktop/802212-20161126102714893-597098126.png?lastModify=1552485372&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;字段1 &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;ARP请求的目的以太网地址，全1时代表广播地址&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;字段2 &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;发送ARP请求(源主机)的以太网地址&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;字段3 &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;以太网帧类型；于ARP协议，该字段为0x0806；对于RARP协议，该字段为0x8035&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;字段4 &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;硬件地址的类型，硬件地址不只以太网一种，是以太网类型时此值为1&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;字段5 &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;表示要映射的协议地址的类型，要对IPv4地址进行映射，此值为0x0800。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;字段6和7表示硬件地址长度和协议地址长度，MAC地址占6字节，IP地址占4字节。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;字段8 &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;操作类型字段，ARP请求（1），ARP应答（2），RARP请求（3），RARP应答（4）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;字段9 &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;发送端ARP请求或应答的硬件地址，这里是以太网地址，和字段2相同。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;字段10 &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;发送ARP请求或应答的IP地址&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;字段11和12是目的端的硬件地址和协议地址。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;下边两张图，分别是，ARP请求包和响应包&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1610491/201903/1610491-20190313220011084-788569771.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5CAdministrator%5CDesktop%5C1552483609005.png&quot;&gt;&lt;img src=&quot;file://c/Users/Administrator/Desktop/1552483609005.png?lastModify=1552485372&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5CAdministrator%5CDesktop%5C1552483652286.png&quot;&gt;&lt;img src=&quot;file://c/Users/Administrator/Desktop/1552483652286.png?lastModify=1552485372&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;代理ARP就是通过使用一个主机(通常为router)&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;来作为指定的设备使用自己的 MAC 地址来对另一设备的ARP请求作出应答&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;为什么要用代理ARP&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;先要了解，路由器的重要功能之一就是把局域网的广播包限制在该网内，阻止其扩散，否则会造成网络风暴。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ARP请求是个广播包，它询问的对象如果在同一个局域网内，就会收到应答&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但是如果询问的对象不在同一个局域网该如何处理？路由器就提供的代理ARP为这个问题提供了解决方案。&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;工作过程&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;两台主机A和B处于同一网段但不同的广播段时，主机A发送ARP请求主机B的MAC地址时&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;因为路由器不转发广播包的原因，ARP请求只能到达路由器&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;如果路由器启用了代理ARP功能，并知道主机B属于它连接的网络&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;那么路由器就用自己接口的MAC地址代替主机B的MAC地址来对主机A进行ARP应答&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;主机A接收ARP应答，但并不知道代理ARP的存在&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;优点：&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;代理ARP能在不影响路由表的情况下添加一个新的Router，使子网对该主机变得透明化&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;一般代理ARP应该使用在主机没有配置默认网关或没有任何路由策略的网络上&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;缺点：&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;从工作工程可以看到，这其实是一种ARP欺骗。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;而且，通过两个物理网络之间的路由器的代理ARP功能&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;其实互相隐藏了物理网络，这导致无法对网络拓扑进行网络概括。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;此外，代理ARP增加了使用它的那段网络的ARP流量，主机需要更大的ARP缓存空间&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;也不会为不使用ARP进行地址解析的网络工作&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;将局域网中某个主机的物理地址转换为IP地址&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;比如局域网中有一台主机只知道物理地址而不知道IP地址&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;那么可以通过RARP协议发出征求自身IP地址的广播请求，然后由RARP服务器负责回答&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;RARP协议广泛应用于无盘工作站引导时获取IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;RARP允许局域网的物理机器从网管服务器ARP表或者缓存上请求其IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;存在的问题&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;RARP通过非常精简的交互实现了IP地址的获取，但同时也暴露了一些问题：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;① &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;RARP Server必须提前将MAC和IP的映射静态绑定在本地；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;若没有提前绑定，则电脑用自己MAC询问时，Server也不会回应；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;② &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;RARP Server只能给电脑分配IP地址，不包括其他信息，包括网关、DNS等信息；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;③ &lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;RARP基于二层封装，只能运行在同一网段；每个网段分配地址，都需要一个RARP Server。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在RARP的基础上，后面又有了Bootp协议，直译过来便是&quot;启动协议&quot;，功能同RARP&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;也是用于电脑接入网络时，用来获取IP地址的&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;但是毕竟做了增强，Bootp协议能让电脑启动时不仅仅获取IP地址&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;而且能获取到网关地址从而让电脑实现跨网段通信&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;Bootp协议虽然让电脑能够获取到更多的信息，但是仍然没有解决最大的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;服务器仍然需要提前手工绑定MAC和IP地址，而对于现在的移动网络或者公共网络而言，这根本无法实现。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;因为用户什么时候接入，接入的MAC是多少，管理员没法提前知道。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这就有了后面的DHCP，DHCP通过动态分配的方式解决了这个诟病&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;并且通过DHCP中继技术实现了跨网段地址分配，实现了全网IP地址的统一管理。&lt;/span&gt;&lt;/p&gt;
&lt;h5 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;小结：&lt;/span&gt;&lt;/h5&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;RARP是一种逝去的地址分配技术，是Bootp和DHCP的鼻祖&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;目前我们的电脑基本不会用到这个协议，只有部分无盘工作站等情况需要用到&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;(Inverse Address Resolution Protocol)是DLCI到IP的映射，他应用的场景不是以太网，而是在帧中继网络里面&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;DLCI即数据链路连接标识（Data Link Connection Identifier）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;是帧中继网络里面的二层地址，好比以太网里面的MAC地址，用于标记帧中继里面的虚拟专线&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;帧中继协议是一种统计复用的协议，它在单一物理传输线路上能够提供多条虚电路&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;DLCI由SAPI和TEI组成，用来唯一的识别一个数据链路连接&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;DLCI只具有局部意义,即交换机上不同的端口可以使用相同的DLCI号&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5CAdministrator%5CDesktop%5C7986149-c5610f3935dc27af.webp&quot;&gt;&lt;img src=&quot;file://c/Users/Administrator/Desktop/7986149-c5610f3935dc27af.webp?lastModify=1552485372&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1610491/201903/1610491-20190313220331334-177726310.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;IARP不像ARP协议可以实时交互，它是周期性运行的&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通信双方若丢失IARP映射表，则需要等待到固定的时间交互才能重新生成并通信。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;另外不同厂商不同型号对IARP的兼容性也可能不同。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;基于这些原因，一般建议直接关闭IARP协议，采用静态绑定的方式生成映射表&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ARP是把IP地址转换为MAC地址的协议；一般ARP协议只适用于局域网&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;RARP用于实现MAC到IP的映射，本质就是为了获取IP地址，是Bootp和DHCP协议的鼻祖；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;IARP用于实现帧中继网络中DLCI到IP地址的映射，生成帧中继映射表（类似ARP表），实现数据封装与通信；&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;相比ARP、免费ARP、代理ARP、ARP攻防等技术，RARP和IARP随着技术的更新迭代正在退出历史舞台&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;成为&quot;被遗忘的兄弟协议&quot; （对于初学者来说，也算是个好事，因为终于不用&quot;翻转&quot;&quot;反向&quot;&quot;逆向&quot;各种分不清了）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;md-expand&quot;&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 14:04:00 +0000</pubDate>
<dc:creator>wintrysec</dc:creator>
<og:description>ARP概述 为什么要用ARP？即ARP的作用 (1) TCP/IP 的32bit的IP地址，仅知道主机的IP地址不能让内核发送数据帧给主机 (2) 网络接口的硬件地址，它是一个48bit的值，用来标识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wintrysec/p/10526967.html</dc:identifier>
</item>
<item>
<title>GDB调试指南-变量查看 - 守望先生</title>
<link>http://www.cnblogs.com/bianchengzhuji/p/10526176.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bianchengzhuji/p/10526176.html</guid>
<description>&lt;h2 id=&quot;h&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在启动调试以及设置断点之后，就到了我们非常关键的一步-查看变量。GDB调试最大的目的之一就是走查代码，查看运行结果是否符合预期。既然如此，我们就不得不了解一些查看各种类型变量的方法，以帮助我们进一步定位问题。&lt;/p&gt;

&lt;h2 id=&quot;h-1&quot;&gt;准备工作&lt;/h2&gt;
&lt;p&gt;在查看变量之前，需要先启动调试并设置断点，该部分内容可参考《&lt;a href=&quot;https://www.yanbinghu.com/2019/01/08/62137.html&quot;&gt;GDB调试指南－启动调试&lt;/a&gt;》和《&lt;a href=&quot;https://www.yanbinghu.com/2019/02/24/44483.html&quot;&gt;GDB调试指南－断点设置&lt;/a&gt;》。后面的内容都基于在某个位置已经断住。&lt;/p&gt;
&lt;p&gt;本文辅助说明程序如下:&lt;br/&gt;testGdb.c&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;/&gt;
&lt;/pre&gt;
&lt;p&gt;testGdb.h&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c language-c hljs cpp&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int a = &lt;span class=&quot;hljs-number&quot;&gt;11;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs php&quot;&gt;$ gcc -g -o testGdb testGdb.o&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-2&quot;&gt;变量查看&lt;/h2&gt;
&lt;h4 id=&quot;h-3&quot;&gt;打印基本类型变量，数组，字符数组&lt;/h4&gt;
&lt;p&gt;最常见的使用便是使用print（可简写为p）打印变量内容。&lt;br/&gt;例如，打印基本类型，数组，字符数组等直接使用p 变量名即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;(gdb) p a&lt;br/&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$1 = 10&lt;br/&gt;(gdb) p b&lt;br/&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$2 = {1, 2, 3, 5}&lt;br/&gt;(gdb) p c&lt;br/&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$3 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello,shouwang&quot;&lt;br/&gt;(gdb) &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然有时候，多个函数或者多个文件会有同一个变量名，这个时候可以在前面加上文件名或者函数名来区分：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;(gdb) p &lt;span class=&quot;hljs-string&quot;&gt;'testGdb.h'&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;span class=&quot;hljs-symbol&quot;&gt;:a&lt;br/&gt;$1 = &lt;span class=&quot;hljs-number&quot;&gt;11&lt;br/&gt;(gdb) p &lt;span class=&quot;hljs-string&quot;&gt;'main'&lt;span class=&quot;hljs-symbol&quot;&gt;:&lt;span class=&quot;hljs-symbol&quot;&gt;:b&lt;br/&gt;$2 = {&lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;2, &lt;span class=&quot;hljs-number&quot;&gt;3, &lt;span class=&quot;hljs-number&quot;&gt;5}&lt;br/&gt;(gdb) &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里所打印的a值是我们定义在testGdb.h文件里的，而b值是main函数中的b。&lt;/p&gt;
&lt;h4 id=&quot;h-4&quot;&gt;打印指针指向内容&lt;/h4&gt;
&lt;p&gt;如果还是使用上面的方式打印指针指向的内容，那么打印出来的只是指针地址而已，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;(gdb) p d&lt;br/&gt;$1 = (&lt;span class=&quot;hljs-keyword&quot;&gt;int *) &lt;span class=&quot;hljs-number&quot;&gt;0x602010&lt;br/&gt;(gdb) &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果想要打印指针指向的内容，需要解引用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;(gdb) p *d&lt;br/&gt;$2 = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;br/&gt;(gdb) p *d@10&lt;br/&gt;$3 = {&lt;span class=&quot;hljs-number&quot;&gt;0, &lt;span class=&quot;hljs-number&quot;&gt;1, &lt;span class=&quot;hljs-number&quot;&gt;2, &lt;span class=&quot;hljs-number&quot;&gt;3, &lt;span class=&quot;hljs-number&quot;&gt;4, &lt;span class=&quot;hljs-number&quot;&gt;5, &lt;span class=&quot;hljs-number&quot;&gt;6, &lt;span class=&quot;hljs-number&quot;&gt;7, &lt;span class=&quot;hljs-number&quot;&gt;8, &lt;span class=&quot;hljs-number&quot;&gt;9}&lt;br/&gt;(gdb) &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面可以看到，仅仅使用*只能打印第一个值，如果要打印多个值，后面跟上@并加上要打印的长度。&lt;br/&gt;或者@后面跟上变量值：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;(&lt;span class=&quot;hljs-selector-tag&quot;&gt;gdb) &lt;span class=&quot;hljs-selector-tag&quot;&gt;p *&lt;span class=&quot;hljs-selector-tag&quot;&gt;d@&lt;span class=&quot;hljs-keyword&quot;&gt;a&lt;br/&gt;$&lt;span class=&quot;hljs-number&quot;&gt;2 = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}&lt;br/&gt;(&lt;span class=&quot;hljs-selector-tag&quot;&gt;gdb) &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于a的值为10，并且是作为整型指针数据长度，因此后面可以直接跟着a，也可以打印出所有内容。&lt;/p&gt;
&lt;p&gt;另外值得一提的是，$可表示上一个变量，而假设此时有一个链表linkNode，它有next成员代表下一个节点，则可使用下面方式不断打印链表内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;(gdb) p *linkNode&lt;br/&gt;(这里显示linkNode节点内容)&lt;br/&gt;(gdb) p *$.&lt;span class=&quot;hljs-keyword&quot;&gt;next&lt;br/&gt;(这里显示linkNode节点下一个节点的内容)&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要查看前面数组的内容，你可以将下标一个一个累加，还可以定义一个类似UNIX环境变量，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;(gdb) &lt;span class=&quot;hljs-built_in&quot;&gt;set &lt;span class=&quot;hljs-variable&quot;&gt;$index=0&lt;br/&gt;(gdb) p b[&lt;span class=&quot;hljs-variable&quot;&gt;$index++]&lt;br/&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$11 = 1&lt;br/&gt;(gdb) p b[&lt;span class=&quot;hljs-variable&quot;&gt;$index++]&lt;br/&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$12 = 2&lt;br/&gt;(gdb) p b[&lt;span class=&quot;hljs-variable&quot;&gt;$index++]&lt;br/&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$13 = 3&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就不需要每次修改下标去打印啦。&lt;/p&gt;
&lt;h2 id=&quot;h-5&quot;&gt;按照特定格式打印变量&lt;/h2&gt;
&lt;p&gt;对于简单的数据，print默认的打印方式已经足够了，它会根据变量类型的格式打印出来，但是有时候这还不够，我们需要更多的格式控制。常见格式控制字符如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x 按十六进制格式显示变量。&lt;/li&gt;
&lt;li&gt;d 按十进制格式显示变量。&lt;/li&gt;
&lt;li&gt;u 按十六进制格式显示无符号整型。&lt;/li&gt;
&lt;li&gt;o 按八进制格式显示变量。&lt;/li&gt;
&lt;li&gt;t 按二进制格式显示变量。&lt;/li&gt;
&lt;li&gt;a 按十六进制格式显示变量。&lt;/li&gt;
&lt;li&gt;c 按字符格式显示变量。&lt;/li&gt;
&lt;li&gt;f 按浮点数格式显示变量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还是以辅助程序来说明，正常方式打印字符数组c：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;(gdb) p c&lt;br/&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$18 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;hello,shouwang&quot;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是如果我们要查看它的十六进制格式打印呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs go&quot;&gt;(gdb) p/x c&lt;br/&gt;$&lt;span class=&quot;hljs-number&quot;&gt;19 = {&lt;span class=&quot;hljs-number&quot;&gt;0x68, &lt;span class=&quot;hljs-number&quot;&gt;0x65, &lt;span class=&quot;hljs-number&quot;&gt;0x6c, &lt;span class=&quot;hljs-number&quot;&gt;0x6c, &lt;span class=&quot;hljs-number&quot;&gt;0x6f, &lt;span class=&quot;hljs-number&quot;&gt;0x2c, &lt;span class=&quot;hljs-number&quot;&gt;0x73, &lt;span class=&quot;hljs-number&quot;&gt;0x68, &lt;span class=&quot;hljs-number&quot;&gt;0x6f, &lt;span class=&quot;hljs-number&quot;&gt;0x75, &lt;span class=&quot;hljs-number&quot;&gt;0x77, &lt;span class=&quot;hljs-number&quot;&gt;0x61, &lt;br/&gt;&lt;span class=&quot;hljs-number&quot;&gt;0x6e, &lt;span class=&quot;hljs-number&quot;&gt;0x67, &lt;span class=&quot;hljs-number&quot;&gt;0x0}&lt;br/&gt;(gdb)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是如果我们想用这种方式查看浮点数的二进制格式是怎样的是不行的，因为直接打印它首先会被转换成整型，因此最终会得到8：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;(gdb) p e&lt;br/&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$1 = 8.5&lt;br/&gt;(gdb) p/t e&lt;br/&gt;&lt;span class=&quot;hljs-variable&quot;&gt;$2 = 1000&lt;br/&gt;(gdb) &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么就需要另外一种查看方式了。&lt;/p&gt;
&lt;h2 id=&quot;h-6&quot;&gt;查看内存内容&lt;/h2&gt;
&lt;p&gt;examine(简写为x)可以用来查看内存地址中的值。语法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs markdown&quot;&gt;x/[&lt;span class=&quot;hljs-string&quot;&gt;n][&lt;span class=&quot;hljs-symbol&quot;&gt;f][&lt;span class=&quot;hljs-string&quot;&gt;u] addr&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;n 表示要显示的内存单元数，默认值为1&lt;/li&gt;
&lt;li&gt;f 表示要打印的格式，前面已经提到了格式控制字符&lt;/li&gt;
&lt;li&gt;u 要打印的单元长度&lt;/li&gt;
&lt;li&gt;addr 内存地址&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;单元类型常见有如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;b 字节&lt;/li&gt;
&lt;li&gt;h 半字，即双字节&lt;/li&gt;
&lt;li&gt;w 字，即四字节&lt;/li&gt;
&lt;li&gt;g 八字节&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们通过一个实例来看，假如我们要把float变量e按照二进制方式打印，并且打印单位是一字节：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;(gdb) x/4tb &amp;amp;e&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;0x7fffffffdbd4:    00000000    00000000    00001000    01000001&lt;br/&gt;(gdb) &lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，变量e的四个字节都以二进制的方式打印出来了。&lt;/p&gt;
&lt;h2 id=&quot;h-7&quot;&gt;自动显示变量内容&lt;/h2&gt;
&lt;p&gt;假设我们希望程序断住时，就显示某个变量的值，可以使用display命令。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;(gdb) display e&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;1: e = 8.5&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么每次程序断住时，就会打印e的值。要查看哪些变量被设置了display，可以使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs makefile&quot;&gt;(gdb)info display&lt;br/&gt;Auto-display expressions now in effect:&lt;br/&gt;Num Enb Expression&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;1:   y  b&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;2:   y  e&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要清除可以使用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;delete display &lt;span class=&quot;hljs-keyword&quot;&gt;num &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者去使能：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs dart&quot;&gt;disable display &lt;span class=&quot;hljs-built_in&quot;&gt;num  #&lt;span class=&quot;hljs-built_in&quot;&gt;num为前面变量前的编号，不带&lt;span class=&quot;hljs-built_in&quot;&gt;num时去使能所有&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;微信公众号【编程珠玑】：专注但不限于分享计算机编程基础，Linux，C语言，C++，算法，数据库等编程相关[原创]技术文章，号内包含大量经典电子书和视频学习资源。欢迎一起交流学习，一起修炼计算机“内功”，知其然，更知其所以然。&lt;/p&gt;
&lt;img title=&quot;公众号编程珠玑&quot; src=&quot;https://www.yanbinghu.com/pictures/qrcode.jpg&quot; alt=&quot;公众号编程珠玑&quot;/&gt;公众号编程珠玑&lt;/blockquote&gt;
&lt;h2 id=&quot;h-8&quot;&gt;查看寄存器内容&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs go&quot;&gt;(gdb)info registers&lt;br/&gt;rax            &lt;span class=&quot;hljs-number&quot;&gt;0x0    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;br/&gt;rbx            &lt;span class=&quot;hljs-number&quot;&gt;0x0    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;br/&gt;rcx            &lt;span class=&quot;hljs-number&quot;&gt;0x7ffff7dd1b00    &lt;span class=&quot;hljs-number&quot;&gt;140737351850752&lt;br/&gt;rdx            &lt;span class=&quot;hljs-number&quot;&gt;0x0    &lt;span class=&quot;hljs-number&quot;&gt;0&lt;br/&gt;rsi            &lt;span class=&quot;hljs-number&quot;&gt;0x7ffff7dd1b30    &lt;span class=&quot;hljs-number&quot;&gt;140737351850800&lt;br/&gt;rdi            &lt;span class=&quot;hljs-number&quot;&gt;0xffffffff    &lt;span class=&quot;hljs-number&quot;&gt;4294967295&lt;br/&gt;rbp            &lt;span class=&quot;hljs-number&quot;&gt;0x7fffffffdc10    &lt;span class=&quot;hljs-number&quot;&gt;0x7fffffffdc10&lt;br/&gt;(内容过多未显示完全)&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-9&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过不同方式查看变量值或者内存值能够极大的帮助我们判断程序的运行是否符合我们的预期，如果发现观察的值不是我们预期的时候，就需要检查我们的代码了。&lt;/p&gt;
</description>
<pubDate>Wed, 13 Mar 2019 12:48:00 +0000</pubDate>
<dc:creator>守望先生</dc:creator>
<og:description>在启动调试以及设置断点之后，就到了我们非常关键的一步-查看变量。GDB调试最大的目的之一就是走查代码，查看运行结果是否符合预期。既然如此，我们就不得不了解一些查看各种类型变量的方法，以帮助我们进一步定</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bianchengzhuji/p/10526176.html</dc:identifier>
</item>
</channel>
</rss>