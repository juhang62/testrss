<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>HBase Filter 过滤器之 ValueFilter 详解 - 周蓬勃</title>
<link>http://www.cnblogs.com/zpb2016/p/12921416.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zpb2016/p/12921416.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言：&lt;/strong&gt;本文详细介绍了 HBase ValueFilter 过滤器 Java&amp;amp;Shell API 的使用，并贴出了相关示例代码以供参考。ValueFilter 基于列值进行过滤，在工作中涉及到需要通过HBase 列值进行数据过滤时可以考虑使用它。比较器细节及原理请参照之前的更文：&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzUwOTE3OTYwNA==&amp;amp;mid=2247484249&amp;amp;idx=1&amp;amp;sn=9627e6c1ef0761c199cf563aec3e0a8f&amp;amp;chksm=f91760e2ce60e9f4ba9b58982c9dfa761c1574c1d4275d913aebfe22856c80356bf00e5c5699&amp;amp;scene=21#wechat_redirect&quot;&gt;HBase Filter 过滤器之比较器 Comparator 原理及源码学习&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一。java-api&quot;&gt;一。Java Api&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;头部代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * 用于列值过滤。
 */
public class ValueFilterDemo {
    private static boolean isok = false;
    private static String tableName = &quot;test&quot;;
    private static String[] cfs = new String[]{&quot;f1&quot;,&quot;f2&quot;};
    private static String[] data = new String[]{
            &quot;row-1:f1:c1:abcdefg&quot;, 
                        &quot;row-2:f1:c2:abc&quot;, 
                        &quot;row-3:f2:c3:abc123456&quot;, 
                        &quot;row-4:f2:c4:1234abc567&quot;
    };
    public static void main(String[] args) throws IOException {

        MyBase myBase = new MyBase();
        Connection connection = myBase.createConnection();
        if (isok) {
            myBase.deleteTable(connection, tableName);
            myBase.createTable(connection, tableName, cfs);
            // 造数据
            myBase.putRows(connection, tableName, data);
        }
        Table table = connection.getTable(TableName.valueOf(tableName));
        Scan scan = new Scan();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;中部代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;向右滑动滚动条可查看输出结果。&lt;/p&gt;
&lt;h3 id=&quot;1-binarycomparator-构造过滤器&quot;&gt;1. BinaryComparator 构造过滤器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.EQUAL, new BinaryComparator(Bytes.toBytes(&quot;abc&quot;))); // [row-2:f1:c2:abc]
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.NOT_EQUAL, new BinaryComparator(Bytes.toBytes(&quot;abc&quot;))); // [row-1:f1:c1:abcdefg, row-3:f2:c3:abc123456, row-4:f2:c4:1234abc567]
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.GREATER, new BinaryComparator(Bytes.toBytes(&quot;abc&quot;))); // [row-1:f1:c1:abcdefg, row-3:f2:c3:abc123456]
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.GREATER_OR_EQUAL, new BinaryComparator(Bytes.toBytes(&quot;abc1&quot;))); // [row-1:f1:c1:abcdefg, row-3:f2:c3:abc123456]
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.LESS, new BinaryComparator(Bytes.toBytes(&quot;abc&quot;))); // [row-4:f2:c4:1234abc567]
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.LESS_OR_EQUAL, new BinaryComparator(Bytes.toBytes(&quot;abc&quot;))); // [row-2:f1:c2:abc, row-4:f2:c4:1234abc567]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-binaryprefixcomparator-构造过滤器&quot;&gt;2. BinaryPrefixComparator 构造过滤器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.EQUAL, new BinaryPrefixComparator(Bytes.toBytes(&quot;123&quot;))); // [row-4:f2:c4:1234abc567]
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.NOT_EQUAL, new BinaryPrefixComparator(Bytes.toBytes(&quot;ab&quot;))); // [row-4:f2:c4:1234abc567]
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.GREATER, new BinaryPrefixComparator(Bytes.toBytes(&quot;ab&quot;))); // [] 只比较prefix长度的字节
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.GREATER_OR_EQUAL, new BinaryPrefixComparator(Bytes.toBytes(&quot;ab&quot;))); // [row-1:f1:c1:abcdefg, row-2:f1:c2:abc, row-3:f2:c3:abc123456]
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.LESS, new BinaryPrefixComparator(Bytes.toBytes(&quot;abc&quot;))); // [row-4:f2:c4:1234abc567]
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.LESS_OR_EQUAL, new BinaryPrefixComparator(Bytes.toBytes(&quot;abc&quot;))); // [row-1:f1:c1:abcdefg, row-2:f1:c2:abc, row-3:f2:c3:abc123456, row-4:f2:c4:1234abc567]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-substringcomparator-构造过滤器&quot;&gt;3. SubstringComparator 构造过滤器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.EQUAL, new SubstringComparator(&quot;123&quot;)); // [row-3:f2:c3:abc123456, row-4:f2:c4:1234abc567]
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.NOT_EQUAL, new SubstringComparator(&quot;def&quot;)); // [row-2:f1:c2:abc, row-3:f2:c3:abc123456, row-4:f2:c4:1234abc567]```
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4-regexstringcomparator-构造过滤器&quot;&gt;4. RegexStringComparator 构造过滤器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.NOT_EQUAL, new RegexStringComparator(&quot;4[a-z]&quot;)); // [row-1:f1:c1:abcdefg, row-2:f1:c2:abc, row-3:f2:c3:abc123456]
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.EQUAL, new RegexStringComparator(&quot;4[a-z]&quot;)); // [row-4:f2:c4:1234abc567]
        ValueFilter valueFilter = new ValueFilter(CompareFilter.CompareOp.EQUAL, new RegexStringComparator(&quot;abc&quot;)); // [row-1:f1:c1:abcdefg, row-2:f1:c2:abc, row-3:f2:c3:abc123456, row-4:f2:c4:1234abc567]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;尾部代码&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;             scan.setFilter(valueFilter);
        ResultScanner scanner = table.getScanner(scan);
        Iterator&amp;lt;Result&amp;gt; iterator = scanner.iterator();
        LinkedList&amp;lt;String&amp;gt; keys = new LinkedList&amp;lt;&amp;gt;();
        while (iterator.hasNext()) {
            String key = &quot;&quot;;
            Result result = iterator.next();
            for (Cell cell : result.rawCells()) {
                byte[] rowkey = CellUtil.cloneRow(cell);
                byte[] family = CellUtil.cloneFamily(cell);
                byte[] column = CellUtil.cloneQualifier(cell);
                byte[] value = CellUtil.cloneValue(cell);
                key = Bytes.toString(rowkey) + &quot;:&quot; + Bytes.toString(family) + &quot;:&quot; + Bytes.toString(column) + &quot;:&quot; + Bytes.toString(value);
                keys.add(key);
            }
        }
        System.out.println(keys);
        scanner.close();
        table.close();
        connection.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二。shell-api&quot;&gt;二。Shell Api&lt;/h2&gt;
&lt;h3 id=&quot;1-binarycomparator-构造过滤器-2&quot;&gt;1. BinaryComparator 构造过滤器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;方式一：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hbase(main):006:0&amp;gt; scan 'test',{FILTER=&amp;gt;&quot;ValueFilter(=,'binary:abc')&quot;}
ROW                                              COLUMN+CELL                                                                                                                                   
 row-2                                           column=f1:c2, timestamp=1589453592471, value=abc                                                                                              
1 row(s) in 0.0240 seconds

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;支持的比较运算符：&lt;code&gt;= != &amp;gt; &amp;gt;= &amp;lt; &amp;lt;=&lt;/code&gt;，不再一一举例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式二：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import org.apache.hadoop.hbase.filter.CompareFilter
import org.apache.hadoop.hbase.filter.BinaryComparator
import org.apache.hadoop.hbase.filter.ValueFilter

hbase(main):010:0&amp;gt; scan 'test',{FILTER =&amp;gt; ValueFilter.new(CompareFilter::CompareOp.valueOf('EQUAL'), BinaryComparator.new(Bytes.toBytes('abc')))}
ROW                                              COLUMN+CELL                                                                                                                                   
 row-2                                           column=f1:c2, timestamp=1589453592471, value=abc                                                                                              
1 row(s) in 0.0230 seconds
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;支持的比较运算符：&lt;code&gt;LESS&lt;/code&gt;、&lt;code&gt;LESS_OR_EQUAL&lt;/code&gt;、&lt;code&gt;EQUAL&lt;/code&gt;、&lt;code&gt;NOT_EQUAL&lt;/code&gt;、&lt;code&gt;GREATER&lt;/code&gt;、&lt;code&gt;GREATER_OR_EQUAL&lt;/code&gt;，不再一一举例。&lt;/p&gt;
&lt;p&gt;推荐使用&lt;strong&gt;方式一&lt;/strong&gt;，更简洁方便。&lt;/p&gt;
&lt;h3 id=&quot;2-binaryprefixcomparator-构造过滤器-2&quot;&gt;2. BinaryPrefixComparator 构造过滤器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;方式一：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hbase(main):011:0&amp;gt; scan 'test',{FILTER=&amp;gt;&quot;ValueFilter(=,'binaryprefix:ab')&quot;}
ROW                                              COLUMN+CELL                                                                                                                                   
 row-1                                           column=f1:c1, timestamp=1589453592471, value=abcdefg                                                                                          
 row-2                                           column=f1:c2, timestamp=1589453592471, value=abc                                                                                              
 row-3                                           column=f2:c3, timestamp=1589453592471, value=abc123456                                                                                        
3 row(s) in 0.0430 seconds
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式二：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import org.apache.hadoop.hbase.filter.CompareFilter
import org.apache.hadoop.hbase.filter.BinaryPrefixComparator
import org.apache.hadoop.hbase.filter.ValueFilter

hbase(main):013:0&amp;gt; scan 'test',{FILTER =&amp;gt; ValueFilter.new(CompareFilter::CompareOp.valueOf('EQUAL'), BinaryPrefixComparator.new(Bytes.toBytes('ab')))}
ROW                                              COLUMN+CELL                                                                                                                                   
 row-1                                           column=f1:c1, timestamp=1589453592471, value=abcdefg                                                                                          
 row-2                                           column=f1:c2, timestamp=1589453592471, value=abc                                                                                              
 row-3                                           column=f2:c3, timestamp=1589453592471, value=abc123456                                                                                        
3 row(s) in 0.0440 seconds
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它同上。&lt;/p&gt;
&lt;h3 id=&quot;3-substringcomparator-构造过滤器-2&quot;&gt;3. SubstringComparator 构造过滤器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;方式一：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;hbase(main):014:0&amp;gt; scan 'test',{FILTER=&amp;gt;&quot;ValueFilter(=,'substring:123')&quot;}
ROW                                              COLUMN+CELL                                                                                                                                   
 row-3                                           column=f2:c3, timestamp=1589453592471, value=abc123456                                                                                        
 row-4                                           column=f2:c4, timestamp=1589453592471, value=1234abc567                                                                                       
2 row(s) in 0.0340 seconds
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式二：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import org.apache.hadoop.hbase.filter.CompareFilter
import org.apache.hadoop.hbase.filter.SubstringComparator
import org.apache.hadoop.hbase.filter.ValueFilter

hbase(main):016:0&amp;gt; scan 'test',{FILTER =&amp;gt; ValueFilter.new(CompareFilter::CompareOp.valueOf('EQUAL'), SubstringComparator.new('123'))}
ROW                                              COLUMN+CELL                                                                                                                                   
 row-3                                           column=f2:c3, timestamp=1589453592471, value=abc123456                                                                                        
 row-4                                           column=f2:c4, timestamp=1589453592471, value=1234abc567                                                                                       
2 row(s) in 0.0240 seconds
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;区别于上的是这里直接传入字符串进行比较，且只支持&lt;code&gt;EQUAL&lt;/code&gt;和&lt;code&gt;NOT_EQUAL&lt;/code&gt;两种比较符。&lt;/p&gt;
&lt;h3 id=&quot;4-regexstringcomparator-构造过滤器-2&quot;&gt;4. RegexStringComparator 构造过滤器&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import org.apache.hadoop.hbase.filter.CompareFilter
import org.apache.hadoop.hbase.filter.RegexStringComparator
import org.apache.hadoop.hbase.filter.ValueFilter

hbase(main):018:0&amp;gt; scan 'test',{FILTER =&amp;gt; ValueFilter.new(CompareFilter::CompareOp.valueOf('EQUAL'), RegexStringComparator.new('4[a-z]'))}
ROW                                              COLUMN+CELL                                                                                                                                   
 row-4                                           column=f2:c4, timestamp=1589453592471, value=1234abc567                                                                                       
1 row(s) in 0.0290 seconds
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该比较器直接传入字符串进行比较，且只支持&lt;code&gt;EQUAL&lt;/code&gt;和&lt;code&gt;NOT_EQUAL&lt;/code&gt;两种比较符。若想使用第一种方式可以传入&lt;code&gt;regexstring&lt;/code&gt;试一下，我的版本有点低暂时不支持，不再演示了。&lt;/p&gt;
&lt;p&gt;注意这里的正则匹配指包含关系，对应底层&lt;code&gt;find()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ValueFilter&lt;/code&gt; 不支持使用 &lt;code&gt;LongComparator&lt;/code&gt; 比较器，且 &lt;code&gt;BitComparator&lt;/code&gt;、&lt;code&gt;NullComparator&lt;/code&gt; 比较器用之甚少，也不再介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;查看文章全部源代码请访以下GitHub地址：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;https://github.com/zhoupengbo/demos-bigdata/blob/master/hbase/hbase-filters-demos/src/main/java/com/zpb/demos/ValueFilterDemo.java
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1001353/202005/1001353-20200520084849019-1581964871.png&quot; alt=&quot;扫描二维码关注博主公众号&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;转载请注明出处！欢迎关注本人微信公众号【HBase工作笔记】&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 20 May 2020 00:49:00 +0000</pubDate>
<dc:creator>周蓬勃</dc:creator>
<og:description>前言： 本文详细介绍了 HBase ValueFilter 过滤器 Java&amp;amp;Shell API 的使用，并贴出了相关示例代码以供参考。ValueFilter 基于列值进行过滤，在工作中涉及到</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zpb2016/p/12921416.html</dc:identifier>
</item>
<item>
<title>MyBatis 学习总结 - &quot;无问西东&quot;</title>
<link>http://www.cnblogs.com/csyh/p/12921396.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csyh/p/12921396.html</guid>
<description>&lt;p&gt;MyBatis 笔记&lt;/p&gt;
&lt;h2 id=&quot;一、入门&quot;&gt;一、入门&lt;/h2&gt;
&lt;h3 id=&quot;11-什么是-mybatis？&quot;&gt;1.1 什么是 MyBatis？&lt;/h3&gt;
&lt;ul readability=&quot;2.2584033613445&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;MyBatis 是一款持久层框架（ORM 编程思想）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;MyBatis 免除了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的过程；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的实体类（pojo：Plain Old Java Object 简单的 Java 对象）映射成数据库中的记录；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;MyBatis 前身为 iBatis（经常在控制台看见）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-0.32352941176471&quot;&gt;
&lt;p&gt;Mybatis官方文档 : &lt;a href=&quot;http://www.mybatis.org/mybatis-3/zh/index.html&quot;&gt;http://www.mybatis.org/mybatis-3/zh/index.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;12-持久化&quot;&gt;1.2 持久化&lt;/h3&gt;
&lt;p&gt;​ 持久化是将程序数据在持久状态和瞬时状态间转换的机制&lt;/p&gt;
&lt;p&gt;​ 通俗的讲，就是瞬时数据（比如内存中的数据，是不能永久保存的）&lt;strong&gt;持久化为&lt;/strong&gt;持久数据（比如持久化至数据库中，能够长久保存）&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;即把数据（如内存中的对象）保存到可永久保存的存储设备中（如磁盘）。持久化的主要应用是&lt;strong&gt;将内存中的对象存储到数据库中&lt;/strong&gt;，或存储在磁盘、XML 等文件中；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;JDBC就是一种持久化机制。文件IO也是一种持久化机制。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;持久化的意义：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 由于内存的存储特性，将数据从内存中持久化至数据库，从存储成本（容量、保存时长）看，都是必要的。&lt;/p&gt;
&lt;h3 id=&quot;13-持久层&quot;&gt;1.3 持久层&lt;/h3&gt;
&lt;p&gt;​ 即数据访问层（DAL 层），其功能主要是负责&lt;a href=&quot;https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%BA%93/103728&quot;&gt;数据库&lt;/a&gt;的访问，实现对数据表的 CEUD 等操作。&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;持久层的作用是将输入库中的数据映射成对象，则我们可以直接通过操作对象来操作数据库&lt;/strong&gt;，而对象如何和数据库发生关系，那就是框架的事情了。&lt;/p&gt;
&lt;h3 id=&quot;14-第一个-mybatis-程序&quot;&gt;1.4 第一个 MyBatis 程序&lt;/h3&gt;
&lt;p&gt;使用环境：&lt;/p&gt;
&lt;p&gt;​ jdk8&lt;/p&gt;
&lt;p&gt;​ MySql 5.7&lt;/p&gt;
&lt;p&gt;​ Maven 3.6.3&lt;/p&gt;
&lt;p&gt;​ IEDA&lt;/p&gt;
&lt;p&gt;项目结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520084003484-1671195971.png&quot; alt=&quot;image-20200513181536681&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置 pom.xml，添加必要的依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;
&amp;lt;!--父工程
        可以用idea根目录作为工程目录，也可以其为父工程，每个Module作为工程目录
        优点：父工程配置一次依赖，所有子工程受用
--&amp;gt;
    &amp;lt;groupId&amp;gt;org.example&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;Mybatis&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;modules&amp;gt;
        &amp;lt;module&amp;gt;mybatis_01&amp;lt;/module&amp;gt;
    &amp;lt;/modules&amp;gt;
    &amp;lt;!--    设置打包格式--&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mybatis&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;3.5.2&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;mysql&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;5.1.47&amp;lt;/version&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt;
            &amp;lt;version&amp;gt;4.10&amp;lt;/version&amp;gt;
            &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
        &amp;lt;/dependency&amp;gt;
    &amp;lt;/dependencies&amp;gt;
&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的，可通过SqlSessionFactoryBuilder 对象获得，而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先配置的 Configuration 实例来构建出 SqlSessionFactory 实例。&lt;/p&gt;
&lt;p&gt;第一步：新建 MyBatis 的核心配置文件 mybatis-config.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE configuration
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;environments default=&quot;development&quot;&amp;gt;
        &amp;lt;environment id=&quot;development&quot;&amp;gt;
            &amp;lt;transactionManager type=&quot;JDBC&quot;/&amp;gt;
            &amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
                &amp;lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&amp;gt;
                &amp;lt;property name=&quot;url&quot;
                          value=&quot;jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;amp;amp;useUnicode=true&amp;amp;amp;characterEncoding=utf8&quot;/&amp;gt;
                &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
                &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
            &amp;lt;/dataSource&amp;gt;
        &amp;lt;/environment&amp;gt;
    &amp;lt;/environments&amp;gt;
    &amp;lt;!-- 每一个Mapper.xml都要在项目的核心配置文件中注册映射--&amp;gt;
    &amp;lt;mappers&amp;gt;
        &amp;lt;mapper resource=&quot;yh/dao/UserMapper.xml&quot;/&amp;gt;
    &amp;lt;/mappers&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：编写获取 SqlSession 对象的工具类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package yh.utils;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

/**
 * 获取SqlSession对象的工具类
 *
 * @author YH
 * @create 2020-05-13 11:01
 */
public class MybatisUtils {
    //1.获取SqlSessionFactory对象

    private static SqlSessionFactory sqlSessionFactory;

    static {
        try {
            String resource = &quot;mybatis-config.xml&quot;;
            InputStream inputStream = Resources.getResourceAsStream(resource);
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }


    /**
     * 2.获取SqlSession对象
     *
     * @return
     */
    public static SqlSession getSqlSession() {
        return sqlSessionFactory.openSession();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步：创建对应数据表的实体类&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package yh.pojo;

/**
 * 实体类
 * pojo：简单的Java对象（Plain Old Java Object）
 *
 * @author YH
 * @create 2020-05-13 11:36
 */
public class User {
    private int id;
    private String name;
    private String pwd;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPwd() {
        return pwd;
    }

    public void setPwd(String pwd) {
        this.pwd = pwd;
    }

    public User(int id, String name, String pwd) {
        this.id = id;
        this.name = name;
        this.pwd = pwd;
    }

    @Override
    public String toString() {
        return &quot;User{&quot; +
                &quot;id=&quot; + id +
                &quot;, name='&quot; + name + '\'' +
                &quot;, pwd='&quot; + pwd + '\'' +
                '}';
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第四步：创建 Mapper 接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package yh.dao;

import yh.pojo.User;

import java.util.List;

/**
 * 持久层接口
 * 在MyBatis中用Mapper替换原来的Dao
 *
 * @author YH
 * @create 2020-05-13 11:35
 */
public interface IUserMapper {
    /**
     * 查询所有
     *
     * @return
     */
    List&amp;lt;User&amp;gt; selectUser();

    /**
     * 根据id查用户
     * @param id
     * @return
     */
    User selectUserById(int id);

    /**
     * 修改用户信息
     * @param user
     */
    int updateUser(User user);

    /**
     * 删除用户
     * @param id
     */
    int deleteUser(int id);

    int addUser(User user);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第五步：创建 Mapper.xml 文件（以前是实现类，显示是实现一个 source）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;!--namespace命名空间：指定持久层接口--&amp;gt;
&amp;lt;mapper namespace=&quot;yh.dao.IUserMapper&quot;&amp;gt;
    &amp;lt;!--select标签：表名是要执行查询操作，内部填写SQL语句
        id属性：指定接口中定义的方法
        resultType属性：指定实体类全类名
        这一对标签就像对应接口中的一个方法--&amp;gt;
    &amp;lt;select id=&quot;selectUser&quot; resultType=&quot;yh.pojo.User&quot;&amp;gt;
      select * from mybatis.user
    &amp;lt;/select&amp;gt;
&amp;lt;!-- #{} 就像以前的通配符，里面的id就是形参变量
     parameterType：设置参数类型--&amp;gt;
    &amp;lt;select id=&quot;selectUserById&quot; parameterType=&quot;int&quot; resultType=&quot;yh.pojo.User&quot;&amp;gt;
        select * from mybatis.user where id=#{id}
    &amp;lt;/select&amp;gt;

    &amp;lt;update id=&quot;updateUser&quot; parameterType=&quot;yh.pojo.User&quot;&amp;gt;
        update mybatis.user set name=#{name},pwd=#{pwd} where id=#{id}
    &amp;lt;/update&amp;gt;

    &amp;lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&amp;gt;
        delete from mybatis.user where id=#{id}
    &amp;lt;/delete&amp;gt;

    &amp;lt;insert id=&quot;addUser&quot; parameterType=&quot;yh.pojo.User&quot;&amp;gt;
        insert into mybatis.user values(#{id},#{name},#{pwd});
    &amp;lt;/insert&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;每一个 Mapper.xml 都需要在 mybatis 核心配置文件中注册&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第五步：编写测试类&lt;/p&gt;
&lt;p&gt;​ 按照规范，test 目录下测试类的结构要与 java 代码结构对应&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package yh.dao;

import org.apache.ibatis.session.SqlSession;
import org.junit.Test;
import yh.pojo.User;
import yh.utils.MybatisUtils;

import java.util.List;

/**
 * 测试类
 *
 * @author YH
 * @create 2020-05-13 12:13
 */
public class UserMapperTest {
    @Test
    public void selectUser() {
        //1.获取SqlSession对象（用来执行SQL，像以前用的ProperStatement）
        SqlSession session = MybatisUtils.getSqlSession();
        //通过反射从获取对象
        IUserMapper mapper = session.getMapper(IUserMapper.class);
        //调用实例方法
        List&amp;lt;User&amp;gt; users = mapper.selectUser();
        for (User u : users) {
            System.out.println(u);
        }
        session.close();
    }

    @Test
    public void selectUserById(){
        SqlSession session = MybatisUtils.getSqlSession();
        IUserMapper mapper = session.getMapper(IUserMapper.class);
        User user = mapper.selectUserById(2);
        System.out.println(user);
        session.close();
    }

    @Test
    public void updateUser(){
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        IUserMapper mapper = sqlSession.getMapper(IUserMapper.class);
        User user = new User(2, &quot;熊大&quot;, &quot;123&quot;);
        int i = mapper.updateUser(user);
        if(i &amp;gt; 0){
            System.out.println(&quot;修改成功&quot;);
        }
        //增删改查操作需要提交事务
        sqlSession.commit();
        sqlSession.close();
    }

    @Test
    public void deleteUser(){
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        IUserMapper mapper = sqlSession.getMapper(IUserMapper.class);
        int i = mapper.deleteUser(3);
        if(i &amp;gt; 0){
            System.out.println(&quot;删除成功&quot;);
        }
        //增删改查操作需要提交事务
        sqlSession.commit();
        sqlSession.close();
    }

    @Test
    public void insterUser(){
        SqlSession sqlSession = MybatisUtils.getSqlSession();
        IUserMapper mapper = sqlSession.getMapper(IUserMapper.class);
        User user = new User(5, &quot;熊二&quot;, &quot;321&quot;);
        int i = mapper.addUser(user);
        if(i &amp;gt; 0){
            System.out.println(&quot;插入成功&quot;);
        }
        //增删改查操作需要提交事务
        sqlSession.commit();
        sqlSession.close();
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询所有结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520084003160-34046796.png&quot; alt=&quot;image-20200513181313304&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据表数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520084002839-1575197054.png&quot; alt=&quot;image-20200513181405082&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;10&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;MyBatis 应用的增删增删改操作需要提交事务&lt;/strong&gt;，传统 JDBC 的增删改操操作中，连接对象被创建时，默认自动提交事务，在执行成功关闭数据库连接时，数据就会自动提交。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;strong&gt;万能 Map&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用 map 集合来保存执行 SQL 所需的参数，多个参数时也可用 Map 或使用注解。&lt;/p&gt;
&lt;p&gt;应用场景：假如通过 new 对象作为参数，调用修改方法，new一个对象需要填上构造器的所有参数，而我们可能只需要用到其中一个，就很麻烦，而使用 map 可制造任意参数，key 为参数名，value 为参数值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520084002427-1185358423.png&quot; alt=&quot;image-20200514152828420&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三种传参方式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 直接传值 如&lt;code&gt;...method(int id)&lt;/code&gt;，可以直接在 sql 中取&lt;code&gt;id&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;​ 对象作为参数传递 如&lt;code&gt;...method(User user)&lt;/code&gt;，直接在 sql 中去对象的属性即可；&lt;/p&gt;
&lt;p&gt;​ Map 作为参数 如&lt;code&gt;...method(Map&amp;lt;String,Object&amp;gt; map)&lt;/code&gt;，直接在 sql 中取出 key 即可&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;可能出现的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分析错误异常信息，从下往上读&lt;/li&gt;
&lt;li&gt;找不到资源异常：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520084001947-1620331449.png&quot; alt=&quot;image-20200513182310138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原因：Maven 会对静态资源过滤，即在&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520084001588-71898454.png&quot; alt=&quot;image-20200513182525296&quot;/&gt; java 目录下的非 java 代码都不编译&lt;/p&gt;
&lt;p&gt;解决：在 pom.xml 中配置resources：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- build中配置resources标签，针对无法找到java目录下的资源问题--&amp;gt;
&amp;lt;build&amp;gt;
    &amp;lt;resources&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/java&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
                &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
            &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
        &amp;lt;/resource&amp;gt;
        &amp;lt;resource&amp;gt;
            &amp;lt;directory&amp;gt;src/main/resources&amp;lt;/directory&amp;gt;
            &amp;lt;includes&amp;gt;
                &amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
                &amp;lt;include&amp;gt;**/*.xml&amp;lt;/include&amp;gt;
            &amp;lt;/includes&amp;gt;
            &amp;lt;filtering&amp;gt;false&amp;lt;/filtering&amp;gt;
        &amp;lt;/resource&amp;gt;
    &amp;lt;/resources&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Mapper.xml 没有在核心配置文件（mybatis-config.xml 中）注册，解决添加如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;mapper resource=&quot;yh/dao/UserMapper.xml&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其他问题往往是出现在与数据库连接的配置上，如 url 配置等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;p&gt;模糊查询写法：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在 Java 代码层面，传参数值的时候写通配符 % %&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;User&amp;gt; users = mapper.getUserLike(&quot;%李%&quot;);
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在 sql 拼接中使用通配符&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;select * from mybatis.user where name like &quot;%&quot;#{value}&quot;%&quot;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二、xml-配置&quot;&gt;二、XML 配置&lt;/h2&gt;
&lt;p&gt;MyBatis 核心配置文件顶层结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520084001303-444158145.png&quot; alt=&quot;image-20200514192454972&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 添加对应元素时需要按照顺序来（如配置 properties 元素，要将其放在最上面）；&lt;/p&gt;
&lt;h3 id=&quot;属性（properties）&quot;&gt;属性（properties）&lt;/h3&gt;
&lt;p&gt;​ 我们在配置数据源（DataSource）的时候设置的 driver、url、username 等都可以使用配置属性的形式获取（这样数据源就可以以一个固定模板呈现，数据源修改是方便些）。设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;properties resource=&quot;db.properties&quot;&amp;gt;
    &amp;lt;!--        同时可以在内部设置属性（隐私性更好）--&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;root&quot;/&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;root&quot;/&amp;gt;
&amp;lt;/properties&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;strong&gt;读取外部可动态改变的 properties文件，不用修改主配置类就可以实现动态配置&lt;/strong&gt;&lt;br/&gt;Mybatis读取配置的顺序：&lt;br/&gt;​ 先读取properties元素体内属性；再读取resources/url属性中指定属性文件；最后读取作为方法参数传递的属性；**&lt;br/&gt;​ 读取到同名属性时，先读取到的倍后读取到的覆盖；&lt;br/&gt;所以，这几个位置读取属性的&lt;strong&gt;优先级&lt;/strong&gt;：&lt;br/&gt;​ &lt;strong&gt;作为方法参数传递的属性 &amp;gt; resources/url属性中指定属性文件 &amp;gt; properties元素体内属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过标识被读取的数据，DataSource中可以直接通过name引用，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dataSource type=&quot;POOLED&quot;&amp;gt;
    &amp;lt;property name=&quot;driver&quot; value=&quot;${driver}&quot;/&amp;gt;
    &amp;lt;property name=&quot;url&quot; value=&quot;${url}&quot;/&amp;gt;
    &amp;lt;property name=&quot;username&quot; value=&quot;${username}&quot;/&amp;gt;
    &amp;lt;property name=&quot;password&quot; value=&quot;${password}&quot;/&amp;gt;
&amp;lt;/dataSource&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 配置 JDBC 连接所需参数值的都用变量代替了。&lt;/p&gt;
&lt;h3 id=&quot;设置（setting）&quot;&gt;设置（setting）&lt;/h3&gt;
&lt;h3 id=&quot;类型别名（typealiases&quot;&gt;类型别名（typeAliases)&lt;/h3&gt;
&lt;p&gt;​ 别名使用数据库都了解过，字符段太长了可使用别名代替；同理，Mybatis 中尝尝应用类的全限定类名（全类名），往往都很长，可以使用别名的形式让我们引用全类名更加便利：&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;类型别名的作用域：当前 xml 文件中&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;typeAliases&amp;gt;
    &amp;lt;!-- 给指定全类名的类其别名--&amp;gt;
    &amp;lt;typeAlias type=&quot;yh.pojo.User&quot; alias=&quot;User&quot;/&amp;gt;
    &amp;lt;!-- 给指定包下所有的JavaBean起别名，别名为其类名首字母小写-&amp;gt;
    &amp;lt;package name=&quot;yh.dao&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 配置后，使用全限定类名的地方都可以用别名替换（如，&lt;code&gt;User&lt;/code&gt; 可以使用在任何使用 &lt;code&gt;yh.pojo.User&lt;/code&gt; 的地方。&lt;/p&gt;
&lt;p&gt;注意：给包起别名，默认别名是包下JavaBean的首字母小写，如果这个JavaBean有注解的话，则别名为其注解值，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Alias(&quot;User1&quot;)
public class User {
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;Mybatis 中给常见的 Java 类型内建了别名，整体规律：基本类型别名为在前面加一个下划线 '_'；而包装类的别名为其对应的基本类型名（也就是说我们使用 int 作为 resultType 参数值时，实际使用的是 Integer，所以我们设置方法参数时，最好也是用 Integer，没报错应该是自动装箱的功劳）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;映射器（mappers）&quot;&gt;映射器（Mappers）&lt;/h3&gt;
&lt;p&gt;有四种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;!-- 指定相对于类路径的资源引用（推荐使用）--&amp;gt;
    &amp;lt;mapper resource=&quot;yh/dao/UserMapper.xml&quot;/&amp;gt;
    &amp;lt;!-- 使用完全限定资源定位符（URL） --&amp;gt;
    &amp;lt;mapper url=&quot;file:///var/mapper/UserMapper.xml&quot;/&amp;gt;
    &amp;lt;!-- 使用映射器接口实现类的完全限定类名 前提：接口名与xml文件名名相同--&amp;gt;
    &amp;lt;mapper class=&quot;yh.dao.IUserMapper&quot;/&amp;gt;
    &amp;lt;!-- 将包内的映射器接口实现全部注册为映射器 前提：接口名与xml文件名名相同--&amp;gt;
    &amp;lt;package name=&quot;yh.dao&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些配置会告诉 MyBatis 去哪里找映射文件，剩下的细节就应该是每个 SQL 映射文件了.&lt;/p&gt;
&lt;h3 id=&quot;生命周期-和-作用域（scope）&quot;&gt;生命周期 和 作用域（Scope）&lt;/h3&gt;
&lt;p&gt;作用域和生命周期类别至关重要，因为错误的使用会导致非常严重的&lt;strong&gt;并发问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一次完整的生命周期：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520084000945-280527745.png&quot; alt=&quot;image-20200515075608317&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;SqlSessionFactoryBuilder&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;一旦创建了 SQLSessionFactory 工厂对象，就不再需要了&lt;/li&gt;
&lt;li&gt;作用域：局部方法变量&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SqlSessionFactory&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;一旦被创建，在运行期间就一直存在&lt;/li&gt;
&lt;li&gt;作用域：全局（应用作用域）&lt;/li&gt;
&lt;li&gt;最简单的就是使用单例模式或者静态单例模式。&lt;/li&gt;
&lt;li&gt;就像数据库中的连接池，有请求就给一个连接。同理多线程时，有请求就创建一个 SqlSession，示意图如下：&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520084000628-177303485.png&quot; alt=&quot;image-20200515075721482&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SqlSession&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;每个线程都有独有的 SqlSession 实例，其线程时不安全的，因此不能被共享（多例）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;作用域：请求或方法作用域&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如在 web 中，一次请求就打开一个 SqlSession，返回一个响应后，就关闭它，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;try (SqlSession session = sqlSessionFactory.openSession()) {
  // 你的应用逻辑代码
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、xml-映射器&quot;&gt;三、XML 映射器&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;cache&lt;/code&gt; – 该命名空间的缓存配置。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cache-ref&lt;/code&gt; – 引用其它命名空间的缓存配置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;resultMap&lt;/code&gt; – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sql&lt;/code&gt; – 可被其它语句引用的可重用语句块。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;insert&lt;/code&gt; – 映射插入语句。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;update&lt;/code&gt; – 映射更新语句。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;delete&lt;/code&gt; – 映射删除语句。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select&lt;/code&gt; – 映射查询语句。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;结果映射（resultmap）&quot;&gt;结果映射（resultMap）&lt;/h3&gt;
&lt;p&gt;​ 解决列名与 JavaBean 属性名不匹配问题。&lt;/p&gt;
&lt;p&gt;​ ResultMap 设计思想：对简单语句做到&lt;strong&gt;零配置&lt;/strong&gt;，对复杂语句，只需要&lt;strong&gt;描述语句间的关系&lt;/strong&gt;就行了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式一：&lt;/strong&gt;零配置&lt;/p&gt;
&lt;p&gt;​ 如前面提到的万能 Map 将列映射到 &lt;code&gt;HashMap&lt;/code&gt; 的键上，由&lt;code&gt;resultType&lt;/code&gt; 属性指定以及直接映射到对象（即映射到 ResultSet ，如：&lt;code&gt;resultType=&quot;User&quot;&lt;/code&gt;）这些都是简单的映射，&lt;strong&gt;MyBatis 底层会自动创建一个 &lt;code&gt;ResultMap&lt;/code&gt;，再根据属性名来映射列到 JavaBean 的属性上&lt;/strong&gt;；&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通过 SQL 语句设置别名也可以实现匹配&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;方式二：&lt;/strong&gt;描述语句间的关系&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先在 &lt;code&gt;Mapper.xml&lt;/code&gt; 文件的 &lt;code&gt;mapper&lt;/code&gt; 标签内显示配置&lt;code&gt;resultMap&lt;/code&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--id属性：此resultMap的标识，供引用语句指定
type属性：映射JavaBean全类名（可用别名）--&amp;gt;
&amp;lt;resultMap id=&quot;userResultMap&quot; type=&quot;yh.pojo.User&quot;&amp;gt;
    &amp;lt;result column=&quot;id&quot; property=&quot;id&quot;/&amp;gt;
    &amp;lt;result column=&quot;name&quot; property=&quot;name&quot;/&amp;gt;
    &amp;lt;!-- 以上两条是匹配的可以省略。就写不匹配的那个属性，如下--&amp;gt;
    &amp;lt;result column=&quot;password&quot; property=&quot;pwd&quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;在引用它的语句中设置 &lt;code&gt;resultMap&lt;/code&gt; 属性即可：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;selectUsers&quot; resultMap=&quot;userResultMap&quot;&amp;gt;
  select id, name, password
  from user
  where id = #{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四、日志&quot;&gt;四、日志&lt;/h2&gt;
&lt;h3 id=&quot;日志工厂&quot;&gt;日志工厂&lt;/h3&gt;
&lt;p&gt;​ MyBatis 核心配置文件中的 &lt;code&gt;settings&lt;/code&gt; 元素的 &lt;code&gt;logImpl&lt;/code&gt; 属性用于 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。&lt;/p&gt;
&lt;p&gt;参数值：&lt;/p&gt;
&lt;p&gt;​ SLF4J | &lt;strong&gt;LOG4J&lt;/strong&gt; | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | &lt;strong&gt;STDOUT_LOGGING&lt;/strong&gt; | NO_LOGGING&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;STDOUT_LOGGING：标准日志输出&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在核心文件 mybatis-config.xml 中进行如下配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;settings&amp;gt;
&amp;lt;!--标准的日志工程实现--&amp;gt;
    &amp;lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;标准日志输出（STDOUT_LOGGING）测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520084000347-1063130453.png&quot; alt=&quot;image-20200515113141505&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;log4j&quot;&gt;LOG4J&lt;/h4&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Java 日志框架，通过它可以控制日志信息输送的目的地为控制台、文件还是 GUI 组件等；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以控制每一条日志的输出格式；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;配置：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;添加依赖&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;log4j&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;log4j&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;1.2.17&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;resource&lt;/code&gt;资源目录下新建 &lt;strong&gt;log4j.properties&lt;/strong&gt; 文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码
log4j.rootLogger=DEBUG,console,file

#控制台输出的相关设置
log4j.appender.console = org.apache.log4j.ConsoleAppender
log4j.appender.console.Target = System.out
log4j.appender.console.Threshold=DEBUG
log4j.appender.console.layout = org.apache.log4j.PatternLayout
log4j.appender.console.layout.ConversionPattern=[%c]-%m%n

#文件输出的相关设置
log4j.appender.file = org.apache.log4j.RollingFileAppender
log4j.appender.file.File=./log/yh.log
log4j.appender.file.MaxFileSize=10mb
log4j.appender.file.Threshold=DEBUG
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=[%p][%d{yy-MM-dd}][%c]%m%n

#日志输出级别
log4j.logger.org.mybatis=DEBUG
log4j.logger.java.sql=DEBUG
log4j.logger.java.sql.Statement=DEBUG
log4j.logger.java.sql.ResultSet=DEBUG
log4j.logger.java.sql.PreparedStatement=DEBUG
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;配置 log4j 为日志的实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;settings&amp;gt;
    &amp;lt;!-- log4j日志实现--&amp;gt;
    &amp;lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&amp;gt;
&amp;lt;/settings&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520084000017-562203539.png&quot; alt=&quot;image-20200515124238271&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五、分页&quot;&gt;五、分页&lt;/h2&gt;
&lt;h3 id=&quot;使用-limit-分页&quot;&gt;使用 Limit 分页&lt;/h3&gt;
&lt;p&gt;​ 分页核心由 SQL 完成。&lt;/p&gt;
&lt;ol readability=&quot;5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;接口中定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 查询结果集分页
 * @param map
 * @return
 */
List&amp;lt;User&amp;gt; selectUserLimit(Map&amp;lt;String,Integer&amp;gt; map);
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Mapper.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;selectUserLimit&quot; parameterType=&quot;map&quot; resultMap=&quot;userResultMap&quot;&amp;gt;
    select * from mybatis.user limit #{index},#{num}
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testLimit(){
    SqlSession session = MybatisUtils.getSqlSession();
    IUserMapper mapper = session.getMapper(IUserMapper.class);
    HashMap&amp;lt;String,Integer&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    map.put(&quot;index&quot;,1);
    map.put(&quot;num&quot;,2);
    List&amp;lt;User&amp;gt; users = mapper.selectUserLimit(map);
    for(User u : users){
        System.out.println(u.toString());
    }
    session.close();
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083958830-2080064026.png&quot; alt=&quot;image-20200516100937740&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;rowbounds-分页（了解）&quot;&gt;RowBounds 分页（了解）&lt;/h3&gt;
&lt;p&gt;​ 不使用 SQL 实现分页。&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;接口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 查询结果集分页
 * @param map
 * @return
 */
List&amp;lt;User&amp;gt; selectUserLimit(Map&amp;lt;String,Integer&amp;gt; map);
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;mybatis.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;selectUserLimit&quot; resultMap=&quot;userResultMap&quot;&amp;gt;
    select * from mybatis.user
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testRowBounds(){
    SqlSession session = MybatisUtils.getSqlSession();
    //RowBounds实现
    RowBounds rowBounds = new RowBounds(1,2);
    //通过java代码层面实现分页
    List&amp;lt;User&amp;gt; userList = session.selectList(&quot;yh.dao.IUserMapper.selectUserLimit&quot;,null,rowBounds);
    //遍历输出：略...
    session.clise();
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;分页插件&quot;&gt;分页插件&lt;/h3&gt;
&lt;p&gt;MyBatis 分页插件：PageHelper&lt;/p&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://pagehelper.github.io/&quot;&gt;https://pagehelper.github.io/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;五、使用注解&quot;&gt;五、使用注解&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;简单查询：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;MyBatis 中使用注解可以省去实现接口的 xml 文件，直接加一条注解语句，如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;public interface IUserMapper {
    @Select(&quot;select * from user&quot;)
    List&amp;lt;User&amp;gt; selectUser();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;而在 mybatis 核心配置文件中的 &lt;code&gt;mappers&lt;/code&gt; 元素中注册绑定接口：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;mapper class=&quot;yh.dao.IUserMapper&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;测试：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void testAnnSelect(){
    SqlSession session = MybatisUtils.getSqlSession();
    IUserMapper mapper = session.getMapper(IUserMapper.class);
    List&amp;lt;User&amp;gt; users = mapper.selectUser();
    for (User user : users) {
        System.out.println(user.toString());
    }
    session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083958456-228590838.png&quot; alt=&quot;image-20200516111507461&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;MyBatis 中，简单的 sql 语句可使用注解映射，复杂的最好用 xml 配置，否则难上加难；不要拘泥于某种方式，可两者配合着使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;注解实现简单-crud&quot;&gt;注解实现简单 CRUD&lt;/h3&gt;
&lt;p&gt;注意：&lt;code&gt;MybatisUtils&lt;/code&gt; 工具类做了以下修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 获取SqlSession对象
 * @return
 */
public static SqlSession getSqlSession(){
    //造对象并设置其自动提交事务
    return sqlSessionFactory.openSession(true);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;demo 的结构：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083958162-1263218702.png&quot; alt=&quot;image-20200516144455481&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;编写接口，使用注解&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package yh.dao;

import org.apache.ibatis.annotations.*;
import yh.pojo.User;

import java.util.List;

/**
 * @author YH
 * @create 2020-05-15 10:51
 */
public interface IUserMapper {
    /**
     * 添加用户
     * @param user
     */
    @Insert(&quot;insert into user(id,name,pwd) values(#{id},#{name},#{password})&quot;)
    int addUser(User user);

    /**
     * 删除用户
     * @param id
     * @return
     */
    @Delete(&quot;delete from user where id=#{id}&quot;)
    int seleteUser(@Param(&quot;id&quot;) int id);

    /**
     * 修改用户
     * @param user
     * @return
     */
    @Update(&quot;update user set name=#{name},pwd=#{password} where id=#{id}&quot;)
    int updateUser(User user);

    /**
     * 查询所有
     * @return
     */
    @Select(&quot;select * from user&quot;)
    List&amp;lt;User&amp;gt; selectUser();
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;关于-param-注解：&quot;&gt;关于 &lt;code&gt;@Param()&lt;/code&gt; 注解：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;基本类型的参数或者 String 类型需要加上&lt;/li&gt;
&lt;li&gt;引用类型不需要加&lt;/li&gt;
&lt;li&gt;如果只有一个基本类型，可以可以省略（建议加上）&lt;/li&gt;
&lt;li&gt;我们在 SQL 中引用的，以&lt;code&gt;@Param()&lt;/code&gt;中的设定为准（如参数变量与设定不同时）&lt;/li&gt;
&lt;/ul&gt;&lt;ol start=&quot;2&quot; readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;而在 mybatis 核心配置文件中的 &lt;code&gt;mappers&lt;/code&gt; 元素中注册绑定接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mappers&amp;gt;
    &amp;lt;mapper class=&quot;yh.dao.IUserMapper&quot;/&amp;gt;
&amp;lt;/mappers&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;

&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package yh.dao;

import org.apache.ibatis.session.SqlSession;
import org.junit.Test;
import yh.pojo.User;
import yh.utils.MybatisUtils;

import java.util.List;

/**
 * @author YH
 * @create 2020-05-16 10:39
 */
public class testAnn {
    @Test
    public void addUser(){
        SqlSession session = MybatisUtils.getSqlSession();
        IUserMapper mapper = session.getMapper(IUserMapper.class);
        int i = mapper.addUser(new User(6, &quot;葫芦娃&quot;, &quot;12333&quot;));
        //由于工具类中设置了自动提交事务，所以这边可以省略
        if (i &amp;gt; 0) {
            System.out.println(&quot;增加成功&quot;);
        }
        session.close();
    }

    @Test
    public void seleteUser(){
        SqlSession session = MybatisUtils.getSqlSession();
        IUserMapper mapper = session.getMapper(IUserMapper.class);
        int i = mapper.seleteUser(1);
        //由于工具类中设置了自动提交事务，所以这边可以省略
        if (i &amp;gt; 0) {
            System.out.println(&quot;删除成功&quot;);
        }
        session.close();
    }

    @Test
    public void updateUser(){
        SqlSession session = MybatisUtils.getSqlSession();
        IUserMapper mapper = session.getMapper(IUserMapper.class);
        int i = mapper.updateUser(new User(4, &quot;奥特曼&quot;, &quot;11111111&quot;));
        if(i &amp;gt; 0){
            System.out.println(&quot;修改成功&quot;);
        }
        session.close();
    }

    @Test
    public void testAnnSelect(){
        SqlSession session = MybatisUtils.getSqlSession();
        IUserMapper mapper = session.getMapper(IUserMapper.class);
        List&amp;lt;User&amp;gt; users = mapper.selectUser();
        for (User user : users) {
            System.out.println(user.toString());
        }
        session.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;复杂查询&quot;&gt;复杂查询&lt;/h2&gt;
&lt;h3 id=&quot;多对一&quot;&gt;多对一&lt;/h3&gt;
&lt;p&gt;​ 如多个学生被一个老师教，对学生而言是多对一的关系，那么怎么对它们进行查询呢？&lt;/p&gt;
&lt;p&gt;如何通过查询学生表，同时获取到他的老师的信息？&lt;/p&gt;
&lt;p&gt;​ 单纯用 sql 语句的话，连接查询、子查询很简单就可以实现，但是要怎么在 mybatis 中实现呢？两种方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083957884-1066536524.png&quot; alt=&quot;image-20200516221623474&quot;/&gt;&lt;/p&gt;
&lt;p&gt;多对一情况下，两个 JavaBean 的属性：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Student {
    private int id;
    private String name;
    /**
     * 多个学生同一个老师，即多对一
     */
    private Teacher teacher;
    //略...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Teacher {
    private int id;
    private String name;
        //略...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;方式一：按照查询嵌套处理（子查询）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 先查询出所有学生的信息，根据查询出来的tid（外键），寻找对应的老师。具体实现：&lt;/p&gt;
&lt;p&gt;学生接口的 Mapper.xml：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mapper namespace=&quot;yh.dao.IStudentMapper&quot;&amp;gt;
    &amp;lt;select id=&quot;selectStudents&quot; resultMap=&quot;StudentResultMap&quot;&amp;gt;
        select * from mybatis.student
    &amp;lt;/select&amp;gt;
    &amp;lt;resultMap id=&quot;StudentResultMap&quot; type=&quot;yh.pojo.Student&quot;&amp;gt;
        &amp;lt;result property=&quot;id&quot; column=&quot;id&quot;/&amp;gt;
        &amp;lt;result property=&quot;name&quot; column=&quot;name&quot;/&amp;gt;
        &amp;lt;!--上面的语句也可以省略（JavaBean的属性名和表的字段名可以匹配）
             复杂的属性需要单独处理：
                处理对象：association
                处理集合：collection
        --&amp;gt;
        &amp;lt;association property=&quot;teacher&quot; column=&quot;tid&quot; javaType=&quot;yh.pojo.Teacher&quot; select=&quot;selectTeachers&quot;/&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;select id=&quot;selectTeachers&quot; resultType=&quot;yh.pojo.Teacher&quot;&amp;gt;
        select * from mybatis.teacher where id=#{tid}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 使用子查询实现，自然需要两次查询，关键就是如何将两次查询关联起来，这就用到 &lt;code&gt;mpper&lt;/code&gt; 元素的子标签：&lt;code&gt;association&lt;/code&gt; 元素，&lt;code&gt;property&lt;/code&gt; 为实体类对应的属性，&lt;code&gt;column&lt;/code&gt; 为表中对应的字段（外键），&lt;code&gt;javaType&lt;/code&gt; ：查询结果对应的 JavaBean 全类名，&lt;code&gt;select&lt;/code&gt; 关联查询语句&lt;/p&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void selectStudent(){
    SqlSession session = MybatisUtils.getSqlSession();
    IStudentMapper mapperS = session.getMapper(IStudentMapper.class);
    List&amp;lt;Student&amp;gt; students = mapperS.selectStudents();
    for (Student student : students) {
        System.out.println(student.toString());
    }
    session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083957556-1412579395.png&quot; alt=&quot;image-20200517090758241&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式二：按照结果嵌套处理&lt;/strong&gt;（对连接查询的结果表进行处理）&lt;/p&gt;
&lt;p&gt;​ 先执行sql语句进行连接查询，获取结果（表），再通过对结果表的处理实现mybatis中多对一查询&lt;/p&gt;
&lt;p&gt;学生接口的 Mapper.xml 配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mapper namespace=&quot;yh.dao.IStudentMapper&quot;&amp;gt;
    &amp;lt;select id=&quot;selectStudents2&quot; resultMap=&quot;StudentResultMap2&quot;&amp;gt;
        select s.id sid,s.name sname,t.id tid,t.name tname
        from mybatis.student s
        join mybatis.teacher t on s.tid=t.id
    &amp;lt;/select&amp;gt;
    &amp;lt;!--通过上面查询的结果表进行处理--&amp;gt;
    &amp;lt;resultMap id=&quot;StudentResultMap2&quot; type=&quot;yh.pojo.Student&quot;&amp;gt;
        &amp;lt;result property=&quot;id&quot; column=&quot;sid&quot;/&amp;gt;
        &amp;lt;result property=&quot;name&quot; column=&quot;sname&quot;/&amp;gt;
        &amp;lt;!--这个属性为对象,所以进行复杂处理，在子标签中对该对象做相对表的映射--&amp;gt;
        &amp;lt;association property=&quot;teacher&quot; javaType=&quot;yh.pojo.Teacher&quot;&amp;gt;
            &amp;lt;!--注意：结果表就相当于对应的数据库表，column元素的值为结果表的字段--&amp;gt;
            &amp;lt;result property=&quot;id&quot; column=&quot;tid&quot;/&amp;gt;
            &amp;lt;result property=&quot;name&quot; column=&quot;tname&quot;/&amp;gt;
        &amp;lt;/association&amp;gt;
    &amp;lt;/resultMap&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要清楚的一个概念：&lt;/p&gt;
&lt;p&gt;​ &lt;strong&gt;java 程序处理数据库查询时，是相对于执行 sql 查询结果所产生结果表，而不是数据库中实际的表。&lt;/strong&gt;根据结果表中的字段（如起别名，则结果表对应字段就为该别名），mybatis 才能进行相关的映射。&lt;/p&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void selectStudent2(){
    SqlSession session = MybatisUtils.getSqlSession();
    IStudentMapper mapperS = session.getMapper(IStudentMapper.class);
    List&amp;lt;Student&amp;gt; students = mapperS.selectStudents2();
    for (Student student : students) {
        System.out.println(student.toString());
    }
    session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083957315-1426222146.png&quot; alt=&quot;image-20200517102101861&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在此说明：程序是相对于查询结果产生的表进行映射的。如果都没有查询某个字段，那么结果表中自然没有，对应的 JavaBean 实例也不能赋值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如上例，查询语句为：&lt;code&gt;select s.id sid,s.name sname,t.name tname&lt;/code&gt;（查询老师 id 的参数去掉了），那么结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083957025-131594367.png&quot; alt=&quot;image-20200517102541278&quot;/&gt;&lt;/p&gt;
&lt;p&gt;老师的 id 属性获取不到了（因为查询结果表中没有）。&lt;/p&gt;
&lt;h3 id=&quot;一对多&quot;&gt;一对多&lt;/h3&gt;
&lt;p&gt;​ 如一个老师教了多个学生，对于老师来说就是一对多的关系。&lt;/p&gt;
&lt;p&gt;​ 那么如何通过一个老师，去查询它对应学生的信息呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一对多情况下两个 JavaBean 的属性设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Teacher {
    private int id;
    private String name;
    /**
     * 一个老师拥有多个学生，一对多
     */
    private List&amp;lt;Student&amp;gt; students;
    //略...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Student {
    private int id;
    private String name;
    private int tid;
    //略...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与多对一类似，同样的两种方式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式一：嵌套查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 从 sql 查询角度看，实际采用的子查询方式，通过指定老师的编号去匹配学生信息。&lt;/p&gt;
&lt;p&gt;老师接口的 Mapper.xml 中的配置：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mapper namespace=&quot;yh.dao.ITeacherMapper&quot;&amp;gt;
    &amp;lt;select id=&quot;selectTeacherById2&quot; resultMap=&quot;TeacherResultMap2&quot;&amp;gt;
        select * from mybatis.teacher where id=#{id}
    &amp;lt;/select&amp;gt;
    &amp;lt;resultMap id=&quot;TeacherResultMap2&quot; type=&quot;Teacher&quot;&amp;gt;
        &amp;lt;id property=&quot;id&quot; column=&quot;id&quot;/&amp;gt;
        &amp;lt;collection property=&quot;students&quot; javaType=&quot;ArrayList&quot; ofType=&quot;Students&quot; column=&quot;id&quot; select=&quot;selectStudents&quot;/&amp;gt;
    &amp;lt;/resultMap&amp;gt;
    &amp;lt;select id=&quot;selectStudents&quot; resultType=&quot;Student&quot;&amp;gt;
        select *
        from mybatis.student
        where tid=#{id}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 在查询老师信息的结果集 &lt;code&gt;resultMap&lt;/code&gt; 元素中映射属性复杂类型（集合）时，再进行查询操作（嵌套），最终实现一对多查询。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方式二：按结果嵌套查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​ 使用连接查询获取一个带有对应学生信息结果表，从而实现映射处理。&lt;/p&gt;
&lt;p&gt;老师接口中定义的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 查询指定id的老师信息，以及其学生的信息
 * @param id
 * @return
 */
Teacher selectTeacherById(@Param(&quot;id&quot;) int id);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;老师接口的 Mapper.xml 中的配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mapper namespace=&quot;yh.dao.ITeacherMapper&quot;&amp;gt;
    &amp;lt;select id=&quot;selectTeacherById&quot; parameterType=&quot;int&quot; resultMap=&quot;TeacherResultMap&quot;&amp;gt;
        select t.id tid,t.name tname,s.id sid,s.name sname,s.tid tid
        from mybatis.teacher t
        inner join mybatis.student s
        on t.id=s.tid
        where t.id=#{id}
    &amp;lt;/select&amp;gt;
    &amp;lt;resultMap id=&quot;TeacherResultMap&quot; type=&quot;Teacher&quot;&amp;gt;
        &amp;lt;result property=&quot;id&quot; column=&quot;tid&quot;/&amp;gt;
        &amp;lt;result property=&quot;name&quot; column=&quot;tname&quot;/&amp;gt;
        &amp;lt;!--复杂的属性我们需要单独处理 对象：association 集合：collection
            javaType：用于指定所指类属性的类型
            ofType：用于指定类的集合属性中的泛型类型
        --&amp;gt;
        &amp;lt;collection property=&quot;students&quot; ofType=&quot;Student&quot;&amp;gt;
            &amp;lt;result property=&quot;id&quot; column=&quot;sid&quot;/&amp;gt;
            &amp;lt;result property=&quot;name&quot; column=&quot;sname&quot;/&amp;gt;
            &amp;lt;result property=&quot;tid&quot; column=&quot;tid&quot;/&amp;gt;
        &amp;lt;/collection&amp;gt;
    &amp;lt;/resultMap&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 一对多相对于多对一，用的集合，集合属性的映射处理需要用到 &lt;code&gt;collection&lt;/code&gt; 元素，且指定集合泛型类型使用 &lt;code&gt;ofType&lt;/code&gt; 属性，其他基本相同。&lt;/p&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void selectTeacher2(){
    SqlSession session = MybatisUtils.getSqlSession();
    ITeacherMapper mapper = session.getMapper(ITeacherMapper.class);
    Teacher teacher = mapper.selectTeacherById(1);
    System.out.println(teacher.toString());
    session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083956793-1948277828.png&quot; alt=&quot;image-20200517143705863&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;小结&quot;&gt;小结&lt;/h4&gt;
&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;resultMap 结果映射&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常用属性
&lt;ul&gt;&lt;li&gt;&lt;code&gt;id&lt;/code&gt; 属性：当前命名空间中的一个唯一标识，用于标识一个结果映射。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;type&lt;/code&gt; 属性：类的完全限定名, 或者一个类型别名&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;id&lt;/code&gt; 和&lt;code&gt;result&lt;/code&gt; 元素的属性：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;property&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;column&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;javaType&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;association&lt;/code&gt; ：关联 - 【多对一】
&lt;ul&gt;&lt;li&gt;javaType：用于指定所指类属性的类型（全类名或类型别名）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;collection&lt;/code&gt; ：集合 -【一对多】
&lt;ul&gt;&lt;li&gt;用于指定类的集合属性中的泛型所用类型（全类名或类型别名）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;慢 SQL：执行效率很低的 sql 语句。&lt;/p&gt;
&lt;p&gt;相关 MySQL 内容：MySQL 引擎、InnoDB 底层原理、索引及其优化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;六、动态-sql&quot;&gt;六、动态 SQL&lt;/h2&gt;
&lt;p&gt;​ 根据不同的条件，生成不同的 SQL 语句，在编译时无法确定，只有等程序运行起来，执行过程中才能确定的 SQL语句为&lt;strong&gt;动态 SQL&lt;/strong&gt;（在 SQL 层面执行一个逻辑代码）&lt;/p&gt;
&lt;p&gt;数据表如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083956468-1975601694.png&quot; alt=&quot;image-20200518203650704&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;if&quot;&gt;if&lt;/h3&gt;
&lt;p&gt;​ 常用于根据判断条件包含 where 子句的一部分，条件成立，被包含的部分得以执行，反之不执行。如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--使用if实现动态查询--&amp;gt;
&amp;lt;select id=&quot;getBlog&quot; parameterType=&quot;Map&quot; resultType=&quot;Blog&quot;&amp;gt;
    select *
    from mybatis.blog
    where 1=1
    &amp;lt;if test=&quot;title != null&quot;&amp;gt;
        and title=#{title}
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&quot;author != null&quot;&amp;gt;
        and author=#{author}
    &amp;lt;/if&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 根据是否传入参数控制是否增加筛选条件，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
    public void test2(){
        SqlSession session = MybatisUtils.getSqlSession();
        BlogMapper mapper = session.getMapper(BlogMapper.class);
        Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
        //控制参数的有无，实现动态SQL效果
//        map.put(&quot;title&quot;,&quot;Java如此简单&quot;);
        map.put(&quot;author&quot;,&quot;熊大&quot;);
        List&amp;lt;Blog&amp;gt; blogs = mapper.getBlog(map);
        for (Blog blog : blogs) {
            System.out.println(blog.toString());
        }
        //未提交事务是因为在MybatisUtils工具类中开启了自动提交
        session.close();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;choose、when、otherwise&quot;&gt;choose、when、otherwise&lt;/h3&gt;
&lt;p&gt;​ &lt;code&gt;choose&lt;/code&gt; &lt;code&gt;when&lt;/code&gt; &lt;code&gt;otherwise&lt;/code&gt; 类似于 java 中的 &lt;code&gt;switch&lt;/code&gt; &lt;code&gt;case&lt;/code&gt;，&lt;code&gt;otherwise&lt;/code&gt; ，不同的是这里判断条件设置在 &lt;code&gt;when&lt;/code&gt; 元素中，符合其条件的，就执行其所包含的 sql 语句。如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--使用choose、when、otherwise实现动态查询--&amp;gt;
&amp;lt;select id=&quot;findActiveBlogLike&quot; parameterType=&quot;Map&quot; resultType=&quot;Blog&quot;&amp;gt;
    select *
    from mybatis.blog
    where 1=1
    &amp;lt;choose&amp;gt;
        &amp;lt;when test=&quot;title != null&quot;&amp;gt;
            and title like #{title}
        &amp;lt;/when&amp;gt;
        &amp;lt;when test=&quot;author != null&quot;&amp;gt;
            and author like #{author}
        &amp;lt;/when&amp;gt;
    &amp;lt;otherwise&amp;gt;
        title=#{title}
    &amp;lt;/otherwise&amp;gt;
    &amp;lt;/choose&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 传入的 &lt;code&gt;title&lt;/code&gt; 就按照 &lt;code&gt;title&lt;/code&gt; 的查找，传入了 &lt;code&gt;author&lt;/code&gt; 就按 &lt;code&gt;author&lt;/code&gt; 查找，两者都没有就用 &lt;code&gt;otherwise&lt;/code&gt; 元素中的，如两个元素都传入了，那个 when 元素先执行就用哪个。如此例就是执行 &lt;code&gt;title&lt;/code&gt; 的查找，测试代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test3(){
    SqlSession session = MybatisUtils.getSqlSession();
    BlogMapper mapper = session.getMapper(BlogMapper.class);
    Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    //传入两个参数，也只执行先执行的那个
    map.put(&quot;title&quot;,&quot;Java%&quot;);
    map.put(&quot;author&quot;,&quot;熊%&quot;);
    List&amp;lt;Blog&amp;gt; blogs = mapper.findActiveBlogLike(map);
    for (Blog blog : blogs) {
        System.out.println(blog.toString());
    }
    //未提交事务是因为在MybatisUtils工具类中开启了自动提交
    session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;trim、where、set&quot;&gt;trim、where、set&lt;/h3&gt;
&lt;p&gt;​ &lt;em&gt;where&lt;/em&gt; 元素只会在子元素返回任何内容的情况下（有符合条件的子句时）才插入 “WHERE” 子句。且，若子句的开头为 “AND” 或 “OR”，&lt;em&gt;where&lt;/em&gt; 元素也会将它们去除。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;findActiveBlogLike2&quot; parameterType=&quot;Map&quot; resultType=&quot;Blog&quot;&amp;gt;
        select *
        from mybatis.blog
# 被包含的子元素成立的情况下，插入where以及子元素包含的条件，且去除and前缀
        &amp;lt;where&amp;gt;
            &amp;lt;if test=&quot;title != null&quot;&amp;gt;
                and title like #{title}
            &amp;lt;/if&amp;gt;
            &amp;lt;if test=&quot;author != null&quot;&amp;gt;
                and author like #{author}
            &amp;lt;/if&amp;gt;
        &amp;lt;/where&amp;gt;
    &amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;em&gt;set&lt;/em&gt; 元素用于动态包含需要更新的列（条件成立的列），忽略其它不更新的列（条件不成立的列）。在首行插入 &lt;code&gt;set&lt;/code&gt; 关键字，并会删掉额外的逗号（最后一个更新字段不要逗号），如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;update id=&quot;updateBlog&quot; parameterType=&quot;Map&quot;&amp;gt;
        update mybatis.blog
# 在首行插入 `set` 关键字，并会删掉额外的逗号
        &amp;lt;set&amp;gt;
            &amp;lt;if test=&quot;id != null&quot;&amp;gt;id=#{id},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&quot;author != null&quot;&amp;gt;author=#{author},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&quot;createTime != null&quot;&amp;gt;create_time=#{createTime},&amp;lt;/if&amp;gt;
            &amp;lt;if test=&quot;views != null&quot;&amp;gt;views=#{views}&amp;lt;/if&amp;gt;
        &amp;lt;/set&amp;gt;
        where title=#{title}
    &amp;lt;/update&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test5() {
    SqlSession session = MybatisUtils.getSqlSession();
    BlogMapper mapper = session.getMapper(BlogMapper.class);
    Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    map.put(&quot;title&quot;,&quot;Java如此简单&quot;);
    map.put(&quot;author&quot;,&quot;熊大&quot;);
    map.put(&quot;views&quot;,&quot;10000&quot;);
    map.put(&quot;createTime&quot;,new Date());
    int i = mapper.updateBlog(map);
    if (i &amp;gt; 0) {
        System.out.println(&quot;修改成功&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ &lt;em&gt;trim&lt;/em&gt; 元素用于自定义 where、set 的功能：&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;prefix&lt;/code&gt; 属性：用于覆盖的前缀&lt;/p&gt;
&lt;p&gt;​ &lt;code&gt;prefixOverride&lt;/code&gt; 属性：被覆盖的前缀&lt;/p&gt;
&lt;p&gt;与上面用到的 &lt;code&gt;where&lt;/code&gt; 等价的自定义 &lt;code&gt;trim&lt;/code&gt; 元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;trim prefix=&quot;WHERE&quot; prefixOverrides=&quot;AND |OR &quot;&amp;gt;
  ...
&amp;lt;/trim&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与上面用到的 &lt;code&gt;set&lt;/code&gt; 等价的自定义 &lt;code&gt;trim&lt;/code&gt; 元素：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&amp;gt;
  ...
&amp;lt;/trim&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：我们覆盖了后缀值设置，并且自定义了前缀值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;sql-片段&quot;&gt;SQL 片段&lt;/h3&gt;
&lt;p&gt;将 SQL 语句中一些功能的部分抽取出出来，方便复用&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;使用 &lt;code&gt;sql&lt;/code&gt; 标签抽取公共部分，如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;sql id=&quot;if-title-author&quot;&amp;gt;
        &amp;lt;if test=&quot;title != null&quot;&amp;gt;
        title = #{title}
    &amp;lt;/if&amp;gt;
    &amp;lt;if test=&quot;author != null&quot;&amp;gt;
        and author = #{author}
    &amp;lt;/if&amp;gt;
&amp;lt;/sql&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;在需要使用的地方使用 &lt;code&gt;Include&lt;/code&gt; 标签引用即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;select id=&quot;queryBlogIF&quot; parameterType=&quot;Map&quot; resyltType=&quot;Blog&quot;&amp;gt;
        select *
    from mybatis.blog
    &amp;lt;where&amp;gt;
        &amp;lt;include refid=&quot;if-title-author&quot;&amp;gt;&amp;lt;/include&amp;gt;
    &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;注意：1.最好基于表单来定义 SQL 片段；&lt;/p&gt;
&lt;p&gt;​ 2.片段中不要存在 where 标签；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;foreach&quot;&gt;foreach&lt;/h3&gt;
&lt;p&gt;用于指定一个集合进行遍历或指定开头与结尾的字符串以及集合项迭代之间的分隔符&lt;/p&gt;
&lt;p&gt;&lt;code&gt;coolection&lt;/code&gt; 属性：指示传递过来用于遍历的集合&lt;/p&gt;
&lt;p&gt;&lt;code&gt;item&lt;/code&gt; 属性：集合当前遍历出来的元素&lt;/p&gt;
&lt;p&gt;&lt;code&gt;index&lt;/code&gt; 属性：索引（当前迭代的序号）&lt;/p&gt;
&lt;p&gt;&lt;code&gt;open&lt;/code&gt; 属性：指定开始符号&lt;/p&gt;
&lt;p&gt;&lt;code&gt;close&lt;/code&gt; 属性：指定结束符号&lt;/p&gt;
&lt;p&gt;&lt;code&gt;separator&lt;/code&gt; 属性：指定分隔符&lt;/p&gt;
&lt;p&gt;元素内包裹的是通过遍历集合参数，之间用分隔符拼接，两头拼接开始结束符，说白了就是一个 sql 语句拼接的过程，拼接的 sql 长度，取决于所传递的集合长度。示例如下：&lt;/p&gt;
&lt;p&gt;Mapper.xml：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--foreach--&amp;gt;
&amp;lt;select id=&quot;findBlogForeach&quot; parameterType=&quot;Map&quot; resultType=&quot;Blog&quot;&amp;gt;
    select *
    from mybatis.blog
    &amp;lt;where&amp;gt;
        &amp;lt;foreach collection=&quot;ids&quot; item=&quot;id&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;or&quot;&amp;gt;
            id=#{id}
        &amp;lt;/foreach&amp;gt;
    &amp;lt;/where&amp;gt;
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test6(){
    SqlSession session = MybatisUtils.getSqlSession();
    BlogMapper mapper = session.getMapper(BlogMapper.class);
    Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    List&amp;lt;Integer&amp;gt; ids = new ArrayList&amp;lt;&amp;gt;();
    //要查询哪一条主句，就将它的id放进集合中，由foreach遍历，拼接成sql语句，实现动态SQL效果
    ids.add(1);
    ids.add(3);
    map.put(&quot;ids&quot;,ids);
    List&amp;lt;Blog&amp;gt; blogForeach = mapper.findBlogForeach(map);
    for (Blog foreach : blogForeach) {
        System.out.println(foreach.toString());
    }
    session.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试结果：&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083956206-1341230001.png&quot; alt=&quot;image-20200518205909960&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;​ 我们表中的 &lt;code&gt;id&lt;/code&gt; 字段是 varchar 类型的，而我们向集合中添加的数据是 &lt;code&gt;Integer&lt;/code&gt; 类型，但是也能作为判断条件，原因是： MySQL 会进行隐式类型转换（TypeHandler），但是需要注意，有些数据库不支持隐式转换，需要手动转换；&lt;/p&gt;
&lt;p&gt;​ 前面说了动态 SQL 实际就是一个拼接 SQL 的过程，我们只需按照 SQL 的格式，去排列组合就可以了，所以必要的一些空格也需要留意（新版本的 mybatis 貌似已经帮我们留意了）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;缓存&quot;&gt;缓存&lt;/h2&gt;
&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;什么是缓存？
&lt;ul&gt;&lt;li&gt;存在内存中的临时数据&lt;/li&gt;
&lt;li&gt;将用户经常查询的数据放在缓存（内存）中，用户查询数据就不用去磁盘（关系型数据库）上查询，而直接从缓存中查询，从而提高查询效率，提升高并发系统性能。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为什么使用缓存？
&lt;ul&gt;&lt;li&gt;提升读取数据的速度的同时，减少和数据库的交互次数，减少系统开销，提升了效率。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;什么样的数据能使用缓存
&lt;ul&gt;&lt;li&gt;经常查询并且不经常改变的数据。目的就是提高效率，如果数据经常变化还要去设置缓存，适得其反。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;mybatis-缓存&quot;&gt;Mybatis 缓存&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;MyBatis 中默认定义了：&lt;strong&gt;一级缓存&lt;/strong&gt;和&lt;strong&gt;二级缓存&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;一级缓存&lt;/em&gt;：&lt;code&gt;SqlSession&lt;/code&gt; 级别的缓存（也称为本地缓存），即从获取 SqlSession 到 SqlSession 被回收期间的缓存。默认情况下，只有有一级缓存开启。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;二级缓存&lt;/em&gt;：基于 namespace 级别的缓存，即当前 Mapper.xml 范围的缓存，需要手动开启配置。&lt;/li&gt;
&lt;li&gt;MyBatis 中定义了缓存接口 &lt;code&gt;Cache&lt;/code&gt;，可以通过实现 &lt;code&gt;Cache&lt;/code&gt; 接口来自定义二级缓存。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;一级缓存&quot;&gt;一级缓存&lt;/h4&gt;
&lt;p&gt;​ 与数据库同一次会话（SqlSession）期间查询到的数据会放在本地缓存中；再需要获取相同数据时，直接从缓存中拿。测试如下：&lt;/p&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;在 mybatisConfig.xml 中开启日志，方便观察执行过程&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--    配置设置--&amp;gt;
    &amp;lt;settings&amp;gt;
    &amp;lt;!--标准的日志工程实现--&amp;gt;
        &amp;lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&amp;gt;
    &amp;lt;!-- log4j实现--&amp;gt;
       &amp;lt;!-- &amp;lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&amp;gt;--&amp;gt;
    &amp;lt;/settings&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;接口中定义方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 根据id查用户
 * @param id
 * @return
 */
User findUserById(@Param(&quot;id&quot;) Integer id);
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Mapper.xml 配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&amp;gt;
&amp;lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;yh.dao.UserMapper&quot;&amp;gt;
    &amp;lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&amp;gt;
        select *
        from mybatis.user
        where id=#{id}
    &amp;lt;/select&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void test1(){
    SqlSession session = MybatisUtils.getSqlSession();
    UserMapper mapper = session.getMapper(UserMapper.class);
    //同一次会话（SqlSession）中，第一次执行查询
    User user1 = mapper.findUserById(2);
    System.out.println(&quot;user1&quot; + user1.toString());
    //同一次会话（SqlSession）中，第二次执行查询
    User user2 = mapper.findUserById(2);
    System.out.println(&quot;user2&quot; + user2.toString());
    //比较查询获取的JavaBean实例地址是否相同（是否是同一个对象）
    System.out.println(user1 == user2);
    session.close();
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;对结果日志进行分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083955900-1404921099.png&quot; alt=&quot;image-20200519121713815&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 从程序执行看，第二次调用查询时，没有与数据库进行交互，而两次查询所获的 JavaBean 对象实例地址比较结果为 &lt;code&gt;true&lt;/code&gt;，所以可断定第二次查询的数据不是从数据库获取的，而是从本地缓存（内存）获取的，这也就是一级缓存的作用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;缓存失效的情况：
&lt;ul&gt;&lt;li&gt;查询不同的数据&lt;/li&gt;
&lt;li&gt;进行了增删改操作，缓存会刷新（因为原来的数据可能发生了改变）&lt;/li&gt;
&lt;li&gt;手动清理缓存：&lt;code&gt;SqlSession.clearCache();&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;一级缓存默认是开启的，只在一次 SQLSession 中有效，也就是获取连接到关闭连接期间；一级缓存就是一个 Map（key 记录 sql，value 记录对应的查询结果）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;二级缓存&quot;&gt;二级缓存&lt;/h4&gt;
&lt;p&gt;​ 二级缓存也称为全局缓存，一级缓存作用域太低了（基于 &lt;code&gt;SqlSession&lt;/code&gt; 级别），所以诞生了二级缓存（基于 &lt;code&gt;namespace&lt;/code&gt; 级别的缓存），整个 Mapper ，对应一个二级缓存；&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;工作机制&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；如果当前会话关闭了，这个会话的一级缓存就没了；如开启了二级缓存，会话关闭时，一级缓存中的数据会被保存到二级缓存中；&lt;/li&gt;
&lt;li&gt;新的会话查询信息就可以从二级缓存中获取内容；&lt;/li&gt;
&lt;li&gt;不同 &lt;code&gt;mapper&lt;/code&gt; 查出的数据会放在自己对应的缓存中（同样是用 &lt;code&gt;Map&lt;/code&gt; 保存，&lt;code&gt;key&lt;/code&gt; 为 &lt;code&gt;mapper&lt;/code&gt; 标识，&lt;code&gt;value&lt;/code&gt; 为其二级缓存数据）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ol readability=&quot;7&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;开启全局缓存需要对 Mybatis 核心配置文件的 &lt;code&gt;settings&lt;/code&gt; 元素中进行如下配置 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--显示地开启全局缓存--&amp;gt;
    &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在要使用二级缓存的 SQL 映射（Mapper.xml）中添加一个标签：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;cache/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也可以在其中自定义一些参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;cache
  eviction=&quot;FIFO&quot;
  flushInterval=&quot;60000&quot;
  size=&quot;512&quot;
  readOnly=&quot;true&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试代码&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;结果分析&lt;/p&gt;
&lt;p&gt;给 mapper 开启二级缓存前查询结果可以清楚地看出两次从与数据库交互的过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083955610-1212957234.png&quot; alt=&quot;image-20200519172743825&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而开启了 mapper 缓存后：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083955311-1870416861.png&quot; alt=&quot;image-20200519174741542&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 只与数据库进行了一次交互，但是通过添加&lt;code&gt;&amp;lt;cache/&amp;gt;&lt;/code&gt; 标签的方式查询时，两个查询对象的比较结果确是 &lt;code&gt;false&lt;/code&gt;，因为使用无参 &lt;code&gt;&amp;lt;cache/&amp;gt;&lt;/code&gt; 标签时，未序列化就会报对象序列化异常，而序列化后对通过序列码比价对象肯定是不同的，所以结果为 &lt;code&gt;false&lt;/code&gt;。而使用自定义 &lt;code&gt;&amp;lt;cache/&amp;gt;&lt;/code&gt; 标签属性时，结果为 &lt;code&gt;true&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083955039-1428999864.png&quot; alt=&quot;image-20200519182757633&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;规范：实体类定义时需要实现序列化接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;缓存查询顺序&quot;&gt;缓存查询顺序&lt;/h4&gt;
&lt;p&gt;​ 用户进行查询，先先查询二级缓存中是否有对应缓存，有 返回查询结果，无 再去一级缓存查询，有 返回结果，无 去数据库查询；&lt;/p&gt;
&lt;p&gt;​ 在查询到数据返回结果时，存在一个缓存过程（将数据存入内存），从数据库查询会根据当前开启的缓存级别，将数据存入级别高的缓存中；在一级缓存中查询到结果时（说明在二级缓存中没有查到），返回数据时，一级缓存会将数据缓存进二级缓存，最后返回结果。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一级缓存提交前提是当前会话关闭，否则不会将缓存送入二级缓存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1778123/202005/1778123-20200520083954577-1331919558.png&quot; alt=&quot;image-20200519175805775&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果第一次会话的缓存没有提交，则第一次会话中查询的缓存都不能从二级缓存中查询出来，只有第一次缓存提交后，后续的会话查询才能使用二级缓存的结果。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 mapper 中可通过设置 &lt;code&gt;select&lt;/code&gt; 标签的 &lt;code&gt;useCache&lt;/code&gt; 属性确定是否需要缓存 ；CUD 标签则通过 &lt;code&gt;flush&lt;/code&gt; 属性指定执行后是否刷新缓存。&lt;/p&gt;
&lt;h3 id=&quot;自定义缓存与-ehcache&quot;&gt;自定义缓存与 EhCache&lt;/h3&gt;
&lt;p&gt;​ EhCache 是一种广泛使用的开源 Java 分布式缓存，主要面向通用缓存。&lt;/p&gt;
&lt;p&gt;​ 导入依赖使用，在 mapper 中指定我们使用的 ehcache 缓存实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!--在当前Mapper.xml中使用耳机缓存--&amp;gt;
&amp;lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot;
updateCheck=&quot;false&quot;&amp;gt;

&amp;lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&amp;gt;

&amp;lt;defaultCache
eternal=&quot;false&quot;
maxElementsInMemory=&quot;10000&quot;
overflowToDisk=&quot;false&quot;
diskPersistent=&quot;false&quot;
timeToIdleSeconds=&quot;1800&quot;
timeToLiveSeconds=&quot;259200&quot;
memoryStoreEvictionPolicy=&quot;LRU&quot;/&amp;gt;

&amp;lt;cache
name=&quot;cloud_user&quot;
eternal=&quot;false&quot;
maxElementsInMemory=&quot;5000&quot;
overflowToDisk=&quot;false&quot;
diskPersistent=&quot;false&quot;
timeToIdleSeconds=&quot;1800&quot;
timeToLiveSeconds=&quot;1800&quot;
memoryStoreEvictionPolicy=&quot;LRU&quot;/&amp;gt;
&amp;lt;/ehcache&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 20 May 2020 00:42:00 +0000</pubDate>
<dc:creator>&quot;无问西东&quot;</dc:creator>
<og:description>﻿MyBatis 笔记 一、入门 1.1 什么是 MyBatis？ MyBatis 是一款持久层框架（ORM 编程思想） MyBatis 免除了几乎所有的 JDBC 代码和手动设置参数以及获取结果集的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/csyh/p/12921396.html</dc:identifier>
</item>
<item>
<title>C# 数据操作系列 - 10 NHibernate初试 - 月影西下</title>
<link>http://www.cnblogs.com/c7jie/p/12921371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c7jie/p/12921371.html</guid>
<description>&lt;p&gt;在上一篇基本讲完了EF Core的入门级教程。从这一篇开始，我们试着去探索一下 .net core平台上更多的ORM框架。那么，这一篇开始我们就来试试NHibernate。&lt;/p&gt;

&lt;p&gt;NHibernate是Hibernate的C#版，众所周知Hibernate是Java 里ORM的顶梁柱（至少曾经）。Hibernate可以说开拓了Java的世界，当年SSH三驾马车风靡世界，至今Hibernate都发挥着举足轻重的作用。&lt;/p&gt;
&lt;p&gt;不过，与EntityFramework不同的地方是，Hibernate以配置文件为主，通过配置文件规范使用，Object/Relation 映射。而NHibernate这继承了这一点，也是以配置文件优先。下图是 NHibernate的工作原理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202005/1266612-20200520083316244-1809678615.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过读取App.config或者Web.config文件去读NHibernate的基本配置，然后加载映射文件，建立映射关系。在后续使用中，通过映射关系生成SQL语句（这一步跟EF是一致的），进而操作数据或者查询数据。&lt;/p&gt;

&lt;h2 id=&quot;21-准备&quot;&gt;2.1 准备&lt;/h2&gt;
&lt;p&gt;先来个控制台项目，我起名为dataprovider。然后安装NHibernate：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;NuGet：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;Install-Package NHibernate
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;dotnet core 命令行：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;dotnet add package NHibernate
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个文章中使用的NHibernate版本是 5.2.7&lt;/p&gt;
&lt;h2 id=&quot;22-配置&quot;&gt;2.2 配置&lt;/h2&gt;
&lt;p&gt;需要创建一个项目用的配置文件：App.config.&lt;/p&gt;
&lt;p&gt;C# 项目中，除了Web类型的项目，每个项目的主配置文件的名称都是App.config，这是一个固定名称。&lt;/p&gt;
&lt;p&gt;文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;configuration&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 configuration节点之间添加以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;configSections&amp;gt;
    &amp;lt;section name=&quot;hibernate-configuration&quot; type=&quot;NHibernate.Cfg.ConfigurationSectionHandler, NHibernate&quot;/&amp;gt;
  &amp;lt;/configSections&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的含义是，在config文件中添加一个 hibernate-configuration结点，结点的解析由类：NHibernate.Cfg.ConfigurationSectionHandler，所在包是NHibernate。&lt;/p&gt;
&lt;p&gt;在App.config文件configuration结点中添加以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;hibernate-configuration xmlns=&quot;urn:nhibernate-configuration-2.2&quot;&amp;gt;
    &amp;lt;session-factory&amp;gt;
        &amp;lt;property name=&quot;dialect&quot;&amp;gt;NHibernate.Dialect.MsSql2012Dialect&amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;connection.connection_string&quot;&amp;gt;
            Data Source=.;Initial Catalog=Demo;Integrated Security=True
        &amp;lt;/property&amp;gt;
        &amp;lt;property name=&quot;hbm2ddl.auto&quot;&amp;gt;create-drop&amp;lt;/property&amp;gt;
        &amp;lt;mapping assembly=&quot;dataprovider&quot; /&amp;gt;
    &amp;lt;/session-factory&amp;gt;
&amp;lt;/hibernate-configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是固定格式，其中dialect表示使用的数据库类型，connection.connection_string 表示连接字符串。mapping表示映射关系文件所在项目。&lt;/p&gt;
&lt;h2 id=&quot;23-获取isessionfactory&quot;&gt;2.3 获取ISessionFactory&lt;/h2&gt;
&lt;p&gt;然后获取一个ISessionFactory：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;Configuration cfg = new Configuration();
var sessionFactory = cfg.BuildSessionFactory();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，如果直接运行代码的话，会在 BuildSessionFactory这里报错。因为没有为SQL Server安装数据访问驱动：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;System.Data.SqlClient
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将数据访问驱动安装成功后，运行可以获得sessionFactory。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;sessionFactory用来创建一个访问数据库的Session&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;24-增删改查&quot;&gt;2.4 增删改查&lt;/h2&gt;
&lt;p&gt;先来个简单的示例类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public class Cat
{
    public virtual string Id { get; set; }
    public virtual string Name { get; set; }
    public virtual char Sex { get; set; }
    public virtual float Weight { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NHibernate的映射关系文件：Cat.hbm.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&amp;gt;
&amp;lt;hibernate-mapping xmlns=&quot;urn:nhibernate-mapping-2.2&quot; namespace=&quot;dataprovider&quot; assembly=&quot;dataprovider&quot;&amp;gt;
  &amp;lt;class name=&quot;Cat&quot; table=&quot;Cat&quot;&amp;gt;

    &amp;lt;!-- A 32 hex character is our surrogate key. It's automatically
            generated by NHibernate with the UUID pattern. --&amp;gt;
    &amp;lt;id name=&quot;Id&quot;&amp;gt;
      &amp;lt;column name=&quot;CatId&quot; sql-type=&quot;char(32)&quot; not-null=&quot;true&quot;/&amp;gt;
      &amp;lt;generator class=&quot;uuid.hex&quot; /&amp;gt;
    &amp;lt;/id&amp;gt;
    &amp;lt;!-- A cat has to have a name, but it shouldn't be too long. --&amp;gt;
    &amp;lt;property name=&quot;Name&quot;&amp;gt;
      &amp;lt;column name=&quot;Name&quot; length=&quot;16&quot; not-null=&quot;true&quot; /&amp;gt;
    &amp;lt;/property&amp;gt;
    &amp;lt;property name=&quot;Sex&quot; /&amp;gt;
    &amp;lt;property name=&quot;Weight&quot; /&amp;gt;
  &amp;lt;/class&amp;gt;
&amp;lt;/hibernate-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建完成后，右键选中文件，修改文件生成操作为&lt;strong&gt;嵌套的资源&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202005/1266612-20200520083316713-419425297.png&quot; alt=&quot;image-20200519000456989&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后编写实例代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;Configuration cfg = new Configuration().Configure();

using (var sessionFactory = cfg.BuildSessionFactory())
using (var session = sessionFactory.OpenSession())
{
// 通过session操作
    session.Close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新增一个Cat：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;var princess = new Cat
{
    Name = &quot;Princess&quot;,
    Sex = 'F',
    Weight = 7.4f
};
session.Save(princess);
session.Flush();//推送修改给数据库，不调用的话数据库里将没有数据
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询并修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;var cats = session.Query&amp;lt;Cat&amp;gt;().ToList();
var cat = cats.First();
cat.Name = &quot;xiao li&quot;;
session.Update(cat);
session.Flush();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查询并删除：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;var cats = session.Query&amp;lt;Cat&amp;gt;().ToList();
var cat = cats.First();
session.Delete(cat);
session.Flush();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是NHibernate的入门级的入门教程。嗯，给大家一个NHibernate的图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202005/1266612-20200520083316981-182803613.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;

&lt;p&gt;NHibernate延续了Hibernate的优点，如果之前了解过Hibernate的人上手不难。轻量简单，不过得需要配置文件。下一期将带领大家继续深入研究NHibernate。&lt;/p&gt;
&lt;blockquote readability=&quot;2.1052631578947&quot;&gt;
&lt;p&gt;更多内容烦请关注&lt;a href=&quot;https://www.attachie.club&quot;&gt;我的博客《高先生小屋》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202005/1266612-20200520083317542-1801652366.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 May 2020 00:33:00 +0000</pubDate>
<dc:creator>月影西下</dc:creator>
<og:description>0. 前言 在上一篇基本讲完了EF Core的入门级教程。从这一篇开始，我们试着去探索一下 .net core平台上更多的ORM框架。那么，这一篇开始我们就来试试NHibernate。 1. NHib</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c7jie/p/12921371.html</dc:identifier>
</item>
<item>
<title>我们为什么推荐在Json中使用string表示Number属性值？ - 有态度的小码甲</title>
<link>http://www.cnblogs.com/JulianHuang/p/12921366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JulianHuang/p/12921366.html</guid>
<description>&lt;p&gt;在这篇简短的文章中，我将解释在使用JSON传输数据时，为什么浮点数或大十进制值应表示为字符串&lt;br/&gt;。&lt;/p&gt;
&lt;h2 id=&quot;long类型引发的诡异情况&quot;&gt;long类型引发的诡异情况&lt;/h2&gt;
&lt;p&gt;长话短说，同事在利用swagger对接后端API时，诡异的发现swaggerUI中显示的json属性值并不是api返回的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[HttpGet]
public IActionResult QueryAsync()
{
   var testJson = new 
   {
       Id =  123123126964992223,
       Profile = &quot;Please attention on Id&quot;,
   };
   return new JsonResult(testJson);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该API在swagger输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{&quot;Id&quot;: 123123126964992220,
 &quot;Profile&quot;: &quot;Please attention on Id&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进一步从Chrome-&amp;gt;[Network]-&amp;gt;[Preview]、[Response payload]观察到该long属性值的差异。&lt;br/&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/f7f0d7c7-8a52-41c2-8a61-d44c32807de7.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;直接给结论：部分long类型值(最大值2&lt;sup&gt;63&lt;/sup&gt;-1)会超过Javascript的最大安全Number(2&lt;sup&gt;53&lt;/sup&gt;-1)， 浏览器/前端 使用JSON.parse(123123126964992223)将不再保证准确性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/4004524c-f359-4330-9ba8-e8287a0d0572.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;将json中的数字值作为字符串传输的是为了消除传输中的精度丢失或歧义性。&quot;&gt;将JSON中的数字值作为字符串传输的是为了消除传输中的精度丢失或歧义性。&lt;/h2&gt;
&lt;p&gt;JSON规范中未给数字指定精度，JSON解析器会自由选择合适的数值精度。如果您的应用程序具有特定的精度要求，那么在不同的JSON解析器可能不能正确表达精度。&lt;/p&gt;
&lt;p&gt;另外部分long类型值(最大值263-1)会超过Javascript的最大安全Number(253 -1)， 前端json反序列化时也会出现错误。&lt;/p&gt;
&lt;p&gt;stackoverflow有个解释很赞：&lt;br/&gt;&lt;img src=&quot;https://imgkr.cn-bj.ufileos.com/a5795e35-ba33-4257-95b0-33a5ad51e4cf.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;覆写net-core序列化框架，将long转化为string&quot;&gt;覆写.NET Core序列化框架，将long转化为string&lt;/h2&gt;
&lt;p&gt;针对NewtonsoftJson编写BigIntJsonConvert&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; public class BigIntJsonConverter : JsonConverter&amp;lt;long&amp;gt;
    {
        public override long ReadJson(JsonReader reader, Type objectType, [AllowNull] long existingValue, bool hasExistingValue, JsonSerializer serializer)
        {
            var flag = long.TryParse(reader.ReadAsString(), out long num);
            return flag == true ? num : 0;
        }

        public override void WriteJson(JsonWriter writer, [AllowNull] long value, JsonSerializer serializer)
        {
            writer.WriteValue(value.ToString());
        }
    }
    
// 截取自Startup.cs ConfigureServices函数    
  context.Services.AddMvc().AddNewtonsoftJson(options =&amp;gt;
{
    options.SerializerSettings.Converters.Add(new BigIntJsonConverter());
});
&lt;/code&gt;
&lt;/pre&gt;
</description>
<pubDate>Wed, 20 May 2020 00:32:00 +0000</pubDate>
<dc:creator>有态度的小码甲</dc:creator>
<og:description>在这篇简短的文章中，我将解释在使用JSON传输数据时，为什么浮点数或大十进制值应表示为字符串 。 long类型引发的诡异情况 长话短说，同事在利用swagger对接后端API时，诡异的发现swagge</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JulianHuang/p/12921366.html</dc:identifier>
</item>
<item>
<title>Docker 集成 Jenkins Gitlab 实现 CI/CD - 以终为始</title>
<link>http://www.cnblogs.com/michael9/p/12921363.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/michael9/p/12921363.html</guid>
<description>&lt;p&gt;首先介绍下环境部分，文章中共涉及到三台服务器，分别用 Gitlab，Jenkins，Deploy 三个名称代替，部署在内网环境，同时因为政策原因，服务器无法直接连通外网。下载 Jenkins 插件时需要添加代理，如服务器可直接联通外网，忽略即可。&lt;/p&gt;
&lt;p&gt;其中服务器详细信息如下：&lt;/p&gt;
&lt;p&gt;实现功能：&lt;/p&gt;
&lt;p&gt;Jenkins 通过监听 GItlab 分支变化，实时更新代码，并将编译后的代码部署在 UTC 环境。&lt;/p&gt;
&lt;p&gt;实现思路：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 Jenkins 所在服务器，使用 docker 安装 Jenkins，启动并下载所需插件。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;通过 Jenkins 提供的管理页面，创建管理员用户。并配置所需凭证。&lt;/p&gt;
&lt;p&gt;关于凭证这里详细说下，共需要配置如下凭证：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;配置用于访问 Gitlab 的凭证&lt;/li&gt;
&lt;li&gt;配置用于拉取 Gitlab 仓库代码的凭证&lt;/li&gt;
&lt;li&gt;配置用于访问 UTC 部署环境的凭证&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;创建任务，将三者连接起来。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;jenkins--安装&quot;&gt;Jenkins 安装&lt;/h2&gt;
&lt;p&gt;这里 docker 安装就不演示了，相关配置可参考&lt;a href=&quot;https://www.cnblogs.com/michael9/p/12787873.html&quot;&gt;这篇&lt;/a&gt;，使用 docker pull 镜像：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker pull jenkinsci/blueocean
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行 Jenkins ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run \
  -u root \
  -d \
  -p 50001:8080 \
  -p 50000:50000 \
  -v /etc/localtime:/etc/localtime \
  -v jenkins-data:/var/jenkins_home \
  -v /var/run/docker.sock:/var/run/docker.sock \
  --name jenkins \
  jenkinsci/blueocean
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;jenkins-插件安装&quot;&gt;Jenkins 插件安装&lt;/h2&gt;
&lt;p&gt;在浏览器输入 &lt;a href=&quot;http://10.124.205.60:50001&quot;&gt;http://10.124.205.60:50001&lt;/a&gt; 进入 jenkins 管理页面，之后会提示输入密码。&lt;/p&gt;
&lt;p&gt;jenkins 的初始登录密码可进入 docker 所在的容器中，可以通过 &lt;code&gt;cat /root/.jenkins/secrets/initialAdminPassword&lt;/code&gt; 获取。&lt;/p&gt;
&lt;h3 id=&quot;代理配置&quot;&gt;代理配置&lt;/h3&gt;
&lt;p&gt;由于公司 ACL 的限制，无法直接访问外网，这时会在页面上提示，当前 Jenkins 为离线版本，故需要配置代理：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在服务器输入框中输入代理地址：proxy.esl.cisco.com
端口：80
测试 URL：用于测试代理是否配置成功。
在下载插件后，可以将代理清掉，以免在内网访问时出现问题。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202005/1861307-20200520082318381-146566102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;插件安装&quot;&gt;插件安装&lt;/h3&gt;
&lt;p&gt;在配置代理成功后，会提示安装插件，这里选择推荐的插件选项安装。&lt;/p&gt;
&lt;p&gt;登录成功后，由于 Jenkins 自带的插件中，没有 Gitlab 和 Publish Over SSH ，需要我们手动安装下，在 &lt;code&gt;系统管理/插件管理/可选插件&lt;/code&gt;目录下 ，搜索关键字即可。其中 &lt;code&gt;GitLab Plugin&lt;/code&gt; 用于对 Gitlab 的访问，&lt;code&gt;Publish Over SSH&lt;/code&gt; 用于传输文件以及在目标服务器上执行命令。&lt;/p&gt;
&lt;h2 id=&quot;凭证配置&quot;&gt;凭证配置&lt;/h2&gt;
&lt;h3 id=&quot;配置-gitlab&quot;&gt;配置 Gitlab&lt;/h3&gt;
&lt;p&gt;在 &lt;code&gt;系统管理/系统配置&lt;/code&gt;页面，向下滑动，找到 gitlab 的选项，该配置用于访问 Gitlab.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Connection name: 随便起一个连接名称
Gitlab host URL： 为 Gitlab 的地址
Credentials：选择一个认证的方式。因为咱们是第一次，选择添加，类型为 Gitlab API token. 将 gitlab 的 token 粘贴到 API token 中。接着点击添加。最后通过，点击测试判断是否正常。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202005/1861307-20200520082432504-868171740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202005/1861307-20200520082527326-1598078215.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果不知道如何获取 gitlab 的 token，可以参考下图，在 Gitlab 管理页面创建：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202005/1861307-20200520082616607-724718591.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;git-配置&quot;&gt;Git 配置&lt;/h3&gt;
&lt;p&gt;向下滑动，找到 git plugin 配置，配置上用户名和邮箱即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202005/1861307-20200520082643926-2111538651.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;publish-over-ssh-配置&quot;&gt;Publish over SSH 配置&lt;/h3&gt;
&lt;p&gt;该插件的作用主要是通过 SSH 命令，操作目标服务器，实现自动部署。&lt;/p&gt;
&lt;p&gt;SSH 连接一般有两种方式，用户名密码或公私匙的方式，下面用公私匙的方式操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 首先进入 Jenkins 所在的 docker 容器
 docker exec -it jenkins /bin/bash
 
# 生成公私匙，需要注意的是新版本的格式 Jenkins 插件不支持，请使用 PEM 这种格式
ssh-keygen -t rsa -b 4096 -m PEM

# 将公匙拷贝至目标服务器 
ssh-copy-id -i .ssh/id_rsa.pub root@10.124.205.69
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面开始配置 Jenkins：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Passphrase: 这个是在生成 ssh key 时，输入的密码，不填写就行。
Path to key: 这个是 ssh 私匙文件所在的绝对位置，当填写下面的 Key 不填写即可。
Key：生成的私匙密码
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;SSH Server 配置：
Name：随便起名就可以
Username：ssh 登录的用户名
Remote Directory：这个一定要填写根路径，之后的操作都会基于该路径。

可点击 `Test Configuration` 是否配置成功，点击应用，保存即可。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202005/1861307-20200520082713089-1492305153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;jenins-job-配置&quot;&gt;Jenins Job 配置&lt;/h2&gt;
&lt;p&gt;在首页上，点击新建任务。输入任务名称，类型选择第一个，构建一个自由风格的软件项目，点击确定，任务就创建完成了。&lt;/p&gt;
&lt;p&gt;然后将鼠标放在名称这列，可以看到一个小三角，点击展开后，对任务进行配置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202005/1861307-20200520082734062-1707053159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码配置&quot;&gt;源码配置&lt;/h3&gt;
&lt;p&gt;选择源码管理，选择 Git，用于获取源代码。这里简单提一下，之前配置的 Gitlab 用于对 Gitlab 的访问，而这里配置的 GIt 用于对某个仓库进行访问。&lt;/p&gt;
&lt;p&gt;这里需要将之前生成 ssh 公匙放到 Gitlab 的 SSH Keys 中，将 ssh 私匙放在当前的 key 中。用于拉取代码。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202005/1861307-20200520082755252-2002135447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将公匙放入 Gitlab 中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202005/1861307-20200520082849154-1628803317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着点击应用和保存。&lt;/p&gt;
&lt;h3 id=&quot;构建触发器的配置&quot;&gt;构建触发器的配置&lt;/h3&gt;
&lt;p&gt;触发器的作用就是在什么情况下，会开始执行该任务。这里配置的是轮询 SCM 系统，也就是 Gitlab 分支的内容出现变化时，触发任务，轮询的时间为 1s.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202005/1861307-20200520082909222-1356887989.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;构建配置&quot;&gt;构建配置&lt;/h3&gt;
&lt;p&gt;构建的作用在获取 SCM 上的代码后，执行的操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;执行 shell: 注意这里编写的 shell 的运行环境是在 jenkins 所在容器内部的。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;选择添加 &lt;code&gt;Sendfiles or execute commands over SSH&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name: 这里选择，之前建好用于访问目标服务器的凭证
Source files: **/*.* 表示递归传输文件夹下的包含 . 的所有文件
Remote directory: 表示传送的目标目录
Exec command: 表示所有文件传输成功后，在目标服务器执行的 shell 命令。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202005/1861307-20200520082931540-1109979083.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是服务器中执行的脚本，用于编译代码以及重启服务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 注意添加可执行权限
chmod +x deploy_shell.sh
cat deploy_shell.sh

#!/bin/bash

# constant
containerName=&quot;ctg_backend&quot;
WORKING_DIR=&quot;/home/yuwzhang/docker-compose/project/temp_build&quot;
TODAY=`date +%Y-%m-%d.%H:%M:%S`

echo &quot;Enter deploy script...&quot;


echo &quot;\nStep1: Copy data to docker web container..&quot;
# delete old dir
if [ -d &quot;$WORKING_DIR&quot; ]; then rm -Rf $WORKING_DIR; fi
# cp new dir
cp -r /home/yuwzhang/jenkins/project /home/yuwzhang/docker-compose/project/temp_build


echo &quot;\nStep2: Enter web container and build py files to bytecode..&quot;
docker exec $containerName bash -c &quot;cd /src/temp_build  &amp;amp;&amp;amp; python -m compileall -b . &amp;amp;&amp;amp; find . -name '*.py' |xargs rm -rf &amp;amp;&amp;amp; find . -name 'pycache' |xargs rm -rf&quot;
cp /home/yuwzhang/docker-compose/project/gunicorn_config.py /home/yuwzhang/docker-compose/project/temp_build/gunicorn_config.py
cp -r /home/yuwzhang/docker-compose/project/frontend /home/yuwzhang/docker-compose/project/temp_build/frontend


echo &quot;\nStep3: Stop web services..&quot;
cd /home/yuwzhang/docker-compose
docker-compose stop web


echo &quot;\nStep4: replace new project dir to old project dir..&quot;
mv project/temp_build new_build
mv project project_`date +%Y-%m-%d.%H:%M:%S`
mv new_build project


echo &quot;\nStep5: Start web services..&quot;
docker-compose start web


echo &quot;\nStep6: check web services status..&quot;
sleep 20s
exist=`docker inspect --format '{{.State.Status}}' ${containerName}`
echo &quot;web status is $exist&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，一个基础版的 CI/CD 流程就搭建完了，可以通过 Blue Ocean 来观察任务的执行情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1861307/202005/1861307-20200520082956582-571094005.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;设置时间&quot;&gt;设置时间&lt;/h3&gt;
&lt;p&gt;在运行 Jenkins 容器时，已经挂载了宿主机的时间到容器内，可是发现 Jenkins 显示的时间还是不正确，在容器内查看时间是正常的，也许和 Jenkins 的配置有关，在&lt;code&gt;系统管理/脚本命令行&lt;/code&gt;中执行如下命令，时间就恢复正常了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;System.setProperty('org.apache.commons.jelly.tags.fmt.timeZone', 'Asia/Shanghai')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jenkins.io/zh/doc/book/installing/&quot;&gt;Jenkins Book&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 May 2020 00:31:00 +0000</pubDate>
<dc:creator>以终为始</dc:creator>
<og:description>首先介绍下环境部分，文章中共涉及到三台服务器，分别用 Gitlab，Jenkins，Deploy 三个名称代替，部署在内网环境，同时因为政策原因，服务器无法直接连通外网。下载 Jenkins 插件时需</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/michael9/p/12921363.html</dc:identifier>
</item>
<item>
<title>Kafka面试你不得不知道的基础知识 - 分布式编程</title>
<link>http://www.cnblogs.com/daichangya/p/12921340.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daichangya/p/12921340.html</guid>
<description>&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-memory-interview-1&quot;&gt;Java内存管理面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-basic-interview-1&quot;&gt;Java基础面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-basic-interview-2&quot;&gt;Java基础面试指南二&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-basic-interview-3&quot;&gt;Java基础面试指南三&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-basic-interview-4&quot;&gt;Java基础面试指南四&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-thread-interview-1&quot;&gt;Java线程面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/java-thread-interview-2&quot;&gt;Java线程面试指南二&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/redis-interview-1&quot;&gt;Redis面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/kafka-interview-1&quot;&gt;Kafka面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/spring-interview-1&quot;&gt;Spring面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/springboot-interview-1&quot;&gt;SpringBoot面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/microservice-interview-1&quot;&gt;微服务面试指南一&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;1-kafka消息传递系统与其他消息传递框架有何不同&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12921340.html#collapse-beginner-975&quot;&gt;1. Kafka消息传递系统与其他消息传递框架有何不同?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Kafka是由Apache基金会开发的消息传递框架,该框架将创建创建消息传递系统以及可提供容错群集以及低延迟系统,以确保端到端交付.&lt;/p&gt;
&lt;p&gt;以下是要点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Kafka是一个消息传递系统,它提供了容错功能以防止消息丢失.&lt;/li&gt;
&lt;li&gt;在public-subscribe 模型上进行设计.&lt;/li&gt;
&lt;li&gt;Kafka cab支持Java和Scala.&lt;/li&gt;
&lt;li&gt;Kafka起源于LinkedIn,后来在2011年成为开源Apache项目&lt;/li&gt;
&lt;li&gt;与Spark和其他大数据技术无缝协作.&lt;/li&gt;
&lt;li&gt;支持集群模式操作&lt;/li&gt;
&lt;li&gt;Kafka消息传递系统可以用于Web服务体系结构或大数据体系结构.&lt;/li&gt;
&lt;li&gt;与其他消息传递框架相比,Kafka易于编码和配置.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Kafka需要其他组件(例如zookeeper)来创建集群并充当协调服务器&lt;/p&gt;
&lt;h4 id=&quot;2-kafka的主要功能是什么&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12921340.html#collapse-beginner-976&quot;&gt;2. Kafka的主要功能是什么?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;除了具有其他关键功能之外,Kafka还为从生产者到消费者的信息提供了可靠的传递方式.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Kafka旨在实现高吞吐量和容错消息服务.&lt;/li&gt;
&lt;li&gt;Kafka提供了在Topic上构建patriation.&lt;/li&gt;
&lt;li&gt;还提供复制功能.&lt;/li&gt;
&lt;li&gt;Kafka提供了一个队列,该队列可以处理大量数据,并最终将消息从一个发送者传输到接收者.&lt;/li&gt;
&lt;li&gt;Kafka还将消息保留在磁盘中,并具有跨群集复制消息的功能&lt;/li&gt;
&lt;li&gt;Kafka与Zookeeper合作,与其他服务进行协调和同步.&lt;/li&gt;
&lt;li&gt;Kafka具有良好的内置支持Apache Spark.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要利用所有这些关键功能,我们需要与Zookeeper配置一起正确配置Kafka集群.&lt;/p&gt;
&lt;h4 id=&quot;3-使用kafka比不提供jmsrabbitmq等其他消息传递服务的好处&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12921340.html#collapse-beginner-977&quot;&gt;3. 使用Kafka比不提供JMS,RabbitMQ等其他消息传递服务的好处?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;如今,kafka是一个基于Key的消息传递框架,它有以下几个关键点.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;可靠性&lt;/strong&gt; -Kafka提供了从发布者到订阅者的可靠传递,而消息丢失为零.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可伸缩性&lt;/strong&gt; -Kafka通过与Zookeeper协调服务器一起使用群集来实现此功能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;耐用性&lt;/strong&gt; -通过使用分布式日志,消息可以保留在磁盘上.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能&lt;/strong&gt; -Kafka在发布和订阅应用程序中提供高吞吐量和低延迟.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;考虑到上述功能,Kafka是Bigdata Technologies用来处理大量消息以实现平稳传递的最佳选择之一.&lt;/p&gt;
&lt;h4 id=&quot;4-kafka的实际用例是什么它与其他消息传递框架有什么不同&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12921340.html#collapse-beginner-978&quot;&gt;4. Kafka的实际用例是什么,它与其他消息传递框架有什么不同?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;有很多用例,Kafka适合实际工作应用程序,但是下面列出的是经常使用的实际工作用例.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;指标&lt;/strong&gt;:用于监视操作数据,可用于分析或对从分布式系统中收集的数据进行统计操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;日志聚合解决方案&lt;/strong&gt;:可以在整个组织中使用,以收集来自多个服务的日志,消费者服务使用这些日志来执行分析操作.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;流处理&lt;/strong&gt;:Kafka的强大耐用性在流处理方面也非常有用.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步通信&lt;/strong&gt;:在微服务中,使这个庞大的系统保持同步是不希望的,因为它会使整个应用程序无响应. 而且,它一开始可能会破坏划分为微服务的整个目的. 因此,那时使用Kafka可使整个数据流变得更容易. 因为它是分布式的,所以具有很高的容错能力,并且可以通过Zookeeper等服务对代理节点进行持续监控. 因此,它使工作效率更高.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;聊天机器人&lt;/strong&gt;:当我们需要可靠的消息传递服务以顺利交付时,聊天机器人是最受欢迎的用例之一.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;多租户解决方案&lt;/strong&gt;. 通过配置哪些主题可以产生或使用数据来启用多租户. 配额也有运营支持&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面是主要需要Kafka框架的用例,除此之外,还有其他一些情况取决于需求和设计.&lt;/p&gt;
&lt;h4 id=&quot;5-为什么我们需要kafka而不是其他消息服务&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12921340.html#collapse-beginner-979&quot;&gt;5. 为什么我们需要Kafka而不是其他消息服务?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;现在让我们谈论一些现代的数据源,它是一种数据-诸如订单,库存和购物车之类的交易数据-诸如单击,点赞,推荐和在网页上的搜索之类的内容正在得到增强. 所有这些数据对于分析消费者的行为非常重要,并且可以提供一组预测分析引擎,这些引擎可以成为公司的与众不同之处.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持低延迟消息传递.&lt;/li&gt;
&lt;li&gt;处理实时流量.&lt;/li&gt;
&lt;li&gt;保证容错能力.&lt;/li&gt;
&lt;li&gt;易于与Spark应用程序集成,以处理大量消息数据.&lt;/li&gt;
&lt;li&gt;能够创建消息传递容器集群,该集群由诸如Zookeeper之类的协调服务器进行监视和监督.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因此,当我们需要处理这种数据量时,我们需要Kafka来解决此问题.&lt;/p&gt;
&lt;h4 id=&quot;6-带组件的kafka流程图&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12921340.html#collapse-beginner-980&quot;&gt;6. 带组件的Kafka流程图?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Kafka流程图包含以下基本组件,这是设置消息传递基础结构所必需的.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Topic&lt;/li&gt;
&lt;li&gt;Broker&lt;/li&gt;
&lt;li&gt;Zookeeper&lt;/li&gt;
&lt;li&gt;Partition&lt;/li&gt;
&lt;li&gt;Producer&lt;/li&gt;
&lt;li&gt;Consume&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.images.mdan.top/kafka_1589934064546.png&quot; alt=&quot;Kafka流程图&quot;/&gt;&lt;br/&gt;客户端和服务器之间的通信是通过简单,高性能,与语言无关的TCP协议完成的. 该协议已版本化,并与旧版本保持向后兼容性&lt;/p&gt;
&lt;h4 id=&quot;7什么是主题kafka如何使用该主题从生产者到消费者进行交流&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12921340.html#collapse-beginner-981&quot;&gt;7.什么是主题?Kafka如何使用该主题从生产者到消费者进行交流?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;主题是将记录发布到的逻辑名称. Kafka中的主题支持多用户模型,因此该主题可以有零个,一个或多个使用者来订阅写入该主题的数据.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;主题是保留消息流的特定类别.&lt;/li&gt;
&lt;li&gt;主题分为多个分区.&lt;/li&gt;
&lt;li&gt;对于每个Kafka,至少应有一个分区.&lt;/li&gt;
&lt;li&gt;每个分区均以未修改的有序顺序包含消息或有效负载.&lt;/li&gt;
&lt;li&gt;分区中的每个消息都有一个标识符,称为偏移量.&lt;/li&gt;
&lt;li&gt;主题具有名称,并且在整个集群中必须唯一.&lt;/li&gt;
&lt;li&gt;生产者需要主题来发布有效负载.&lt;/li&gt;
&lt;li&gt;消费者从消费者那里提取了相同的有效载荷.&lt;/li&gt;
&lt;li&gt;对于每个主题,群集维护的日志如下所示.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.images.mdan.top/partition_1589934143285.png&quot; alt=&quot;多订户模型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个分区都有一个有序且不可变的记录序列,该记录序列被连续附加到一个结构化的提交日志中. Kafka集群使用可配置的保留期限持久地保留所有已发布记录(无论是否已被使用).&lt;/p&gt;
&lt;h4 id=&quot;8-什么是分区&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12921340.html#collapse-beginner-982&quot;&gt;8. 什么是分区?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;Kafka主题被共享到分区中,该分区以不可修改的顺序包含消息.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分区是数据的逻辑分组.&lt;/li&gt;
&lt;li&gt;分区允许您通过跨多个代理将主题中的数据拆分来并行化主题.&lt;/li&gt;
&lt;li&gt;主题中可以分组有一个或多个分区.&lt;/li&gt;
&lt;li&gt;分区允许通过跨多个群集在多个主题中拆分数据来并行化主题.&lt;/li&gt;
&lt;li&gt;每个分区都有一个名为offset的标识符.&lt;/li&gt;
&lt;li&gt;每个分区都可以放置在单独的计算机上,以允许多个用户并行读取主题.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://www.images.mdan.top/topic_1589934221144.png&quot; alt=&quot;隔断&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;9-什么是分区偏移量&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12921340.html#collapse-beginner-983&quot;&gt;9. 什么是分区偏移量?&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;偏移量是分区内记录的唯一标识符. 它表示使用者在分区中的位置. 消费者可以从特定的偏移量开始读取消息,也可以从他们选择的任何偏移量点进行读取.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分区偏移具有唯一的序列ID,称为偏移.&lt;/li&gt;
&lt;li&gt;每个分区应具有一个分区偏移量.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主题还可以具有多个分区日志,如右侧图像中的click-topic一样. 这允许多个使用者并行地从一个主题中阅读.&lt;/p&gt;
&lt;h4 id=&quot;10-什么是brokerkafka如何利用broker进行交流&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/daichangya/p/12921340.html#collapse-beginner-984&quot;&gt;10. 什么是Broker?Kafka如何利用Broker进行交流?&lt;/a&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Broker是负责维护发布数据的系统.&lt;/li&gt;
&lt;li&gt;每个代理可以具有一个或多个分区.&lt;/li&gt;
&lt;li&gt;Kafka包含多个代理来维护负载均衡器.&lt;/li&gt;
&lt;li&gt;Kafka Broker是无状态的&lt;/li&gt;
&lt;li&gt;例如:假设一个主题中有N个分区,并且有N个代理,那么每个代理都有1个分区.&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Wed, 20 May 2020 00:25:00 +0000</pubDate>
<dc:creator>分布式编程</dc:creator>
<og:description>1. &amp;quot;Java内存管理面试指南一&amp;quot; 2. &amp;quot;Java基础面试指南一&amp;quot; 3. &amp;quot;Java基础面试指南二&amp;quot; 4. &amp;quot;Java基础面试</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/daichangya/p/12921340.html</dc:identifier>
</item>
<item>
<title>走向统一的 .NET 旅程 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/12921285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/12921285.html</guid>
<description>&lt;p&gt;这是微软第一次完全线上举办的Build大会，也是第一次完全属于开发者的大会。几乎所有的新产品都是属于开发者，开发者成为了唯一的主角。 现在的微软比以往任何时候都贴近开发者，重视开发者的作用，为他们打造平台和工具。因为没有开发者，就没有微软的生态平台，也就没有微软的一切, 今年的Build大会究竟都宣布了很多新产品，自然也少不了.NET, 两个Scott 在 &lt;a href=&quot;https://channel9.msdn.com/Events/Build/2020/BOD106&quot;&gt;统一 .NET 平台的旅程&lt;/a&gt; 视频里揭晓.NET 的发展现状和未来。 &lt;/p&gt;
&lt;p&gt;发布了.NET 5 Preview4 , Blazor WebAssembly RTM,  ML.NET Model Builder、云原生应用开发的tye 以及 docker 改进等。在dotnet团队的官方博客上连续发了好几篇篇文章：&lt;/p&gt;
&lt;h6&gt;&lt;span&gt;发布了很多的很丰富产品，有一些还属于画饼的，经常听到有同学说.NET再牛逼，也没有JAVA那么丰富的生态，为什么总是拿Java来参照呢，我们着眼未来的发展，IT技术的发展一直是螺旋向上发展，Java能够发展这么好也是脚步踏得准，反观.NET 是2014年才开始干本该2000年就开始干的事，足足耽误了15年黄金时间，经过五年时间的追赶，逐步在缩小差距，我们可以从下面的数据中看到发展的速度。&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202005/510-20200520075708317-515531539.png&quot;&gt;&lt;img width=&quot;900&quot; height=&quot;474&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202005/510-20200520075709088-1800829661.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;昨天正好看到&lt;a href=&quot;https://www.thoughtworks.com/cn/radar&quot;&gt;Technology Radar&lt;/a&gt; 在平台部分对.NET Core也是采纳，2018年开始进入采纳，.NET Core 在容器友好方面的改进是非常好的，这也是相对于Java在这方面的全面超越。 &lt;a title=&quot;https://www.thoughtworks.com/cn/radar/platforms/net-core&quot; href=&quot;https://www.thoughtworks.com/cn/radar/platforms/net-core&quot;&gt;https://www.thoughtworks.com/cn/radar/platforms/net-core&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202005/510-20200520075709887-748801377.png&quot;&gt;&lt;img width=&quot;671&quot; height=&quot;482&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202005/510-20200520075710430-1135828536.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 May 2020 00:10:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>这是微软第一次完全线上举办的Build大会，也是第一次完全属于开发者的大会。几乎所有的新产品都是属于开发者，开发者成为了唯一的主角。 现在的微软比以往任何时候都贴近开发者，重视开发者的作用，为他们打造</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/12921285.html</dc:identifier>
</item>
<item>
<title>[Abp vNext 入坑分享] - 7.Automapper与validation的使用 - 二B方案程序员</title>
<link>http://www.cnblogs.com/twoBcoder/p/12891164.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/twoBcoder/p/12891164.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://github.com/lcjyslqyy/AbpVnext.Learn&quot;&gt;【项目源码】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/twoBcoder/p/12747440.html&quot;&gt;【章节目录】&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文主要介绍Automapper与Validation的使用方法。首先使用Automapper的目的是引入组件完成entity与dto之间的转换以达到简化代码的目的。Abp vnext的项目中已经默认添加好此组件了&lt;a href=&quot;https://docs.abp.io/zh-Hans/abp/latest/Object-To-Object-Mapping&quot;&gt;【介绍】&lt;/a&gt;，本文只是说一些简单的用法，更进一步的使用需要到automapper的官网中查看文档&lt;br/&gt;其次是Validation主要是用于入参校验，通过对dto标注相应的属性达到入参校验的功能。&lt;a href=&quot;https://docs.abp.io/zh-Hans/abp/latest/Validation&quot;&gt;【abp介绍】&lt;/a&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/mvc/models/validation?view=aspnetcore-3.1&quot;&gt;【官方介绍】&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;1、Automapper的基础使用方法，在官方的文档中也有比较清晰的说明，所以就只是简单的根据官方文档写一次。然后试运行一下简单的效果即可。&lt;br/&gt;添加相应的mapper使用的Dto，如UserDto,定义好可以对外输出的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;public class UserDto: EntityDto&amp;lt;Guid&amp;gt;
    {
        /// &amp;lt;summary&amp;gt;
        /// 用户名称
        /// &amp;lt;/summary&amp;gt;
        public string user_name { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 用户手机号
        /// &amp;lt;/summary&amp;gt;
        public string user_phone { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 用户状态
        /// &amp;lt;/summary&amp;gt;
        public int user_status { get; set; }
 
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其次在AbpVnext.Learn.Application中找到LearnApplicationAutoMapperProfile类，添加我们需要的mapper，&lt;code&gt;CreateMap&amp;lt;User, UserDto&amp;gt;();&lt;/code&gt; 最后在UserAppServices里面添加以下代码，其中ObjectMapper.Map就是转换的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt; public async Task&amp;lt;UserDto&amp;gt; LoginByUserPhoneAndPwd(string user_phone,string pass_word)
        {
            var user= await _repository.FindAsync(a=&amp;gt;a.user_phone== user_phone&amp;amp;&amp;amp;a.pass_word== pass_word&amp;amp;&amp;amp;a.user_status==0);
            return ObjectMapper.Map&amp;lt;User, UserDto&amp;gt;(user);
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调试代码，输出结果如下,转换正常：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202005/1010868-20200519203721061-861669903.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、接下来主要介绍一下Validation的用法，官方的Validation是一个简单与轻量化的组件，主要用数据注解的方式对入参字段的合法性校验上。下面我们先来做一个简单的例子，原来登录接口的入参的参数增加以下[Required]&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt; /// &amp;lt;summary&amp;gt;
    /// 登录的Dto
    /// &amp;lt;/summary&amp;gt;
    public class LoginDto:
    {
        /// &amp;lt;summary&amp;gt;
        /// 用户手机号
        /// &amp;lt;/summary&amp;gt;
        [Required]
        public string user_phone { get; set; }
        /// &amp;lt;summary&amp;gt;
        /// 登录密码
        /// &amp;lt;/summary&amp;gt;
        [Required]
        public string pass_word { get; set; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后调试代码,测试相应接口，如下图抛出500异常，&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202005/1010868-20200519203752198-715509634.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再看日志，显示的是校验失败异常，则表明我们的注解生效了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202005/1010868-20200519203830105-1797470263.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、上面虽然显示我们的校验生效了，但是输出的结果明显不是我们想要的结果。一般我们需要为校验失败的入参输出统一的code和相应的字符串，让我们的提示比较清晰明了，同时也让前端开发的同事比较明确的知道这个是由于参数校验引起的问题，然后去修正相关参数。因此，我们需要替换掉abp的原有校验异常输出。&lt;/p&gt;
&lt;p&gt;首先我们查看官方文档有说明，校验异常统一为AbpValidationException 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202005/1010868-20200519203853197-2079412497.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因此我们在原来的LeanGlobalExceptionFilter中拦截此类型的异常，并将输出修改为code=100，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;  public void OnException(ExceptionContext context)
        {
            logger.LogError(new EventId(context.Exception.HResult),
           context.Exception,
           context.Exception.Message);
            if (context.Exception is AbpValidationException)
            {
                context.Result = new JsonResult(new  { ode = 100, msg = context.Exception.Message });
            }
            else
            {
                context.Result = new JsonResult(new { code = 500, msg = &quot;系统异常&quot; });
            }
            context.ExceptionHandled = true;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们再来看看调试接口的输出结果，如下，则表明我们的替换是成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202005/1010868-20200519203924019-2113912121.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、但是这样就算成功了吗？当然不是额，abp所有的校验失败输出都是输出这个：ModelState is not valid! See ValidationErrors for details.这样的输出，对我们前端或客户端同事是非常不友好的输出，都不知道错误原因与相应的字段，因此我们需要进一步去优化这些信息以达到最大程度的减少沟通成本的目的。下面我们来看看如何进行操作吧！&lt;/p&gt;
&lt;p&gt;4.1、首先我们看一下注解里面的ValidationAttribute，这个注解包含了字段ErrorMessage是用于输出校验错误的字段的，所以我们可以好好的利用一下这个ErrorMessage来达到我们的目的。把user_phone的[Required]修改成[Required(ErrorMessage =&quot;手机号码不能为空&quot;)]&lt;/p&gt;
&lt;p&gt;4.2、我们回到LeanGlobalExceptionFilter这里，看一下AbpValidationException里面包含了什么信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202005/1010868-20200519203954995-350664809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，我们看到了ValidationErrors这个字段是一个List,里面包含了我们这一个请求入参的整个dto里所有校验不通过的信息列表。这样就好办了，修改原来的拦截为以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;public void OnException(ExceptionContext context)
        {
            logger.LogError(new EventId(context.Exception.HResult),
           context.Exception,
           context.Exception.Message);
            if (context.Exception is AbpValidationException)
            {
                var validateerros = ((AbpValidationException)context.Exception).ValidationErrors;
                context.Result = new JsonResult(new  { ode = 100, msg = validateerros.Count &amp;gt; 0 ? validateerros[0].ErrorMessage : context.Exception.Message });
            }
            else
            {
                context.Result = new JsonResult(new { code = 500, msg = &quot;系统异常&quot; });
            }
            context.ExceptionHandled = true;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后调试代码，并测试相应的接口。现在则表示显示正常了。至于信息到底是显示第一个还是最后一个，自己判断，个人感觉都可以，因为都属于参数失败的校验&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202005/1010868-20200519204033275-2761773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.3、接下来我们使用一下进阶的判断，脱离于单纯的字段校验，如：假如user_phone等于pass_word的时候抛出不能相等提示。这个需要dto继承IValidatableObject然后增加Validate的实现方法，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C#&quot;&gt;public IEnumerable&amp;lt;ValidationResult&amp;gt; Validate(
            ValidationContext validationContext)
        {
            if (user_phone == pass_word)
            {
                yield return new ValidationResult(
                    &quot;手机号码与密码不能一样!&quot;,
                    new[] { &quot;user_phone&quot;, &quot;pass_word&quot; }
                );
            }
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后调试代码，并测试相应的接口，如下则表示替换成功了。。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202005/1010868-20200519204052195-826067620.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 20 May 2020 00:09:00 +0000</pubDate>
<dc:creator>二B方案程序员</dc:creator>
<og:description>简要说明 &amp;quot;【项目源码】&amp;quot; &amp;quot;【章节目录】&amp;quot; 本文主要介绍Automapper与Validation的使用方法。首先使用Automapper的目的是引入组件完成</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/twoBcoder/p/12891164.html</dc:identifier>
</item>
<item>
<title>缓存，确实很香，却也很受伤！ - WindWant</title>
<link>http://www.cnblogs.com/niejunlei/p/12914336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niejunlei/p/12914336.html</guid>
<description>&lt;p&gt;缓存的使用，是一个逐渐演进的过程。&lt;/p&gt;
&lt;p&gt;问一下你自己，最直接的使用缓存的原因是什么？&lt;/p&gt;
&lt;p&gt;无它，唯快而已！&lt;/p&gt;
&lt;p&gt;追溯一下自己最开始使用缓存的场景，一些数据库里存储的不变的配置信息，服务启动时，直接加载到本地公共模块，方便其它功能模块共享使用。这便是最基本，最简单的本地缓存应用。&lt;/p&gt;
&lt;h2&gt;一、服务与缓存&lt;/h2&gt;
&lt;p&gt;所谓的服务，简而言之，一层应用 + 一层数据，应用从数据层获取数据然后加工输出。&lt;/p&gt;
&lt;p&gt;数据层，通常我们指的是持久化介质上的持久化存储。它有多种形式的，可以是文件，或者数据库。&lt;/p&gt;
&lt;p&gt;数据存储在持久化介质上，而应用运行与内存中。内存和持久化介质是两个有着量级速度差别的不同介质，由此，应用和数据之间便有了“矛盾”。&lt;/p&gt;
&lt;p&gt;有了这“矛盾”的引子，便有了对缓存的迫切需求。&lt;/p&gt;
&lt;p&gt;我们说的缓存，必然要是存放于内存中的，这样它便能距离应用更近，更快的给出应用所需要的数据，以获得更快的服务响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200519013103268-1984234526.png&quot; alt=&quot;&quot; width=&quot;588&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，并不是缓存完全隔绝持久层数据。缓存，伴随而生的一个词叫做&lt;strong&gt;命中率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当我们查询的数据存在于缓存中的时候，我们称之为“命中”，此时，所需数据可以直接由缓存提供。&lt;/p&gt;
&lt;p&gt;而对于未“命中”的数据，则需要穿过缓存层，进一步去持久化数据层获取。此种情景，我们称之为&lt;strong&gt;缓存穿透&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数据获取之后，在返回给应用之前，我们需要重新填充缓存，以供下一次“命中”查询。&lt;/p&gt;
&lt;p&gt;当然，上述我们所述只是指“读”查询情景。&lt;/p&gt;
&lt;p&gt;当应用发生数据操作变更，我们则需要将变更同时更新到持久层及缓冲层。此时，我们又会面临另外一个问题，&lt;strong&gt;“先”与“后”&lt;/strong&gt;的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200519015529171-389258478.png&quot; alt=&quot;&quot; width=&quot;478&quot; height=&quot;273&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“先”与“后”的问题，我们也称之为&lt;strong&gt;缓存一致性&lt;/strong&gt;问题。&lt;/p&gt;
&lt;p&gt;如果先更新缓存，则可能面临持久层更新失败，产生缓存脏数据的问题。&lt;/p&gt;
&lt;p&gt;然则，假如先更新持久层，我们又不得不面对从持久层更新成功之后到缓存更新之前这个间期，缓存对外提供旧数据的窘境。&lt;/p&gt;
&lt;p&gt;缓存一致性问题，尤其在高并发环境，需要根据特定场景进行更精妙的控制。&lt;/p&gt;
&lt;p&gt;比如，并发修改的一致性锁；比如，异步刷新的延迟刷新等等。&lt;/p&gt;
&lt;h2&gt;二、缓存与更新&lt;/h2&gt;
&lt;p&gt;上面我们提到了缓存更新一致性的问题，从实际应用情景来讲，可以细分为强一致性需求，弱一致性需求及最终一致性需求。&lt;/p&gt;
&lt;h3&gt;1、强一致性需求&lt;/h3&gt;
&lt;p&gt;比如，交易状态信息，已下单、支付中，已支付等应用，需要我们主动及时进行关联更新并保证事务层面的一致性。&lt;/p&gt;
&lt;p&gt;应景而生的许多包括分布式事务等理论也为我们解决实际问题提供了很好的践行方案。&lt;/p&gt;
&lt;h3&gt;2、弱一致性需求&lt;/h3&gt;
&lt;p&gt;一些涉及不太重要的信息更新，能够容忍短时间（比如，几分钟）内持久层数据和缓存数据不一致的场景。比如不外显的描述信息，统计性的计数缓存信息等。通常可以采取异步处理的方式。&lt;/p&gt;
&lt;p&gt;一些一段短时间内（几秒，几分钟）输出固定信息的场景。比如每隔30s更新热点信息，票价信息等。可以通过设置缓存超时自动剔除的方式进行处理。&lt;/p&gt;
&lt;h3&gt;3、最终一致性需求&lt;/h3&gt;
&lt;p&gt;保障数据状态的最终一致性。&lt;/p&gt;
&lt;h2&gt;三、缓存的粒度&lt;/h2&gt;
&lt;p&gt;所谓粒度，也即缓存信息块层级，大小。选择何种粒度的缓存，取决于我们应用的整体架构，数据存储规划及具体的应用场景。&lt;/p&gt;
&lt;p&gt;拿用户信息来举例，是缓存活跃信息？还是相对静态的信息？是按单属性层级来缓存？还是按整个对象信息？&lt;/p&gt;
&lt;p&gt;不同的数据粒度，也决定着我们存储缓存的形式：整个对象的二进制序列化数据？更透明直观的json字符串？属性与值的一一映射？&lt;/p&gt;
&lt;p&gt;每种形式都有各自的使用优缺点，开发者可以从应用、存储及维护成本各方面进行全面性评估选择。&lt;/p&gt;
&lt;h2&gt;四、缓存穿透的危害&lt;/h2&gt;
&lt;p&gt;第一小节，我们提到过关于缓存穿透发生的原因：缓存未命中。那为什么会未命中呢？&lt;/p&gt;
&lt;h3&gt;1、数据暂时不存在于缓存中&lt;/h3&gt;
&lt;p&gt;所谓暂时，可以指数据初始尚未加载到缓存，lazy load 按需按时时事加载应用；&lt;/p&gt;
&lt;p&gt;也可以是缓存数据被我们特定的缓存过期策略自动或主动过期，通常使用的过期策略包括元素数量限制，内存占用限制及生存时间限制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200520000211653-1453225786.png&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;235&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其实，无论是初始未加载还是缓存过期，删除，这些都属于我们假定的正常应用场景，再次我们不予过多评论。&lt;/p&gt;
&lt;h3&gt;2、数据从来不存在&lt;/h3&gt;
&lt;p&gt;当一个查询不存在数据的请求到来，其必然会穿过缓存，达到持久化存储层。&lt;/p&gt;
&lt;p&gt;持久话存储的响应能力是有限的，当这种请求达到一定的量级，服务可能就要面临着宕机的危险。&lt;/p&gt;
&lt;p&gt;至此，我们对于缓存的作用认知，也需要进一步延伸：&lt;strong&gt;降低下层负载，保护后端资源&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200520001749447-1458454211.png&quot; alt=&quot;&quot; width=&quot;476&quot; height=&quot;213&quot;/&gt; &lt;/p&gt;
&lt;p&gt;造成这种缓存穿透的原因可以简单的分为内外两方面诱因：内部的应用逻辑问题及外部恶意攻击、爬虫干扰等。&lt;/p&gt;
&lt;p&gt;内部问题容易解决，内观可预知，良性优化即可；&lt;/p&gt;
&lt;p&gt;反而是外部的不可预料，可能需要更谨慎的进行多面的防御性处理。&lt;/p&gt;
&lt;p&gt;其实，不论内部还是外部，在缓存层面需要处理的就只有一件事：&lt;strong&gt;有效拦截穿透&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;到此，通常惯性的思维第一步，就是把造成缓存穿透的数据放置到缓存中，无论其是否存在在于持久化存储中。&lt;/p&gt;
&lt;p&gt;比如对于正常的已删除的用户数据，做缓存层面的软删除处理，以状态信息做标注（&lt;strong&gt;我存在，其实我不存在！&lt;/strong&gt;😳）。就可以很好的解决此类问题造成的穿透压力。&lt;/p&gt;
&lt;p&gt;但是，我们有也个清楚的认知就，就是真正能够造成危害的是那些非正常的入侵数据。比如，穷尽遍历的差别数据，一一存入缓存，唯一的结果就是缓存资源的溢满用尽。这是一种相当恐怖的场景。&lt;/p&gt;
&lt;p&gt;针对此种“大数据”型攻击，&lt;strong&gt;布隆过滤拦截&lt;/strong&gt;或许可以成为一个不错的选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200520003806411-690737555.png&quot; alt=&quot;&quot; width=&quot;686&quot; height=&quot;380&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;五、也谈缓存雪崩&lt;/h2&gt;
&lt;p&gt;上面一节中我们谈到了缓存的承载保护功能，一面快速响应，一面背负保护持久层数据。&lt;/p&gt;
&lt;p&gt;在某些以读为主的服务中，缓存几近承载近乎90%以上的请求。&lt;/p&gt;
&lt;p&gt;但是，如果缓存由于某些原因一时不能提供正常服务时，所有的请求就会穿透到持久存储层，造成存储层极端宕机情况发生。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200520010341364-331345062.png&quot; alt=&quot;&quot; width=&quot;569&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么，我们应该如何应对这种情况呢？ &lt;/p&gt;
&lt;h3&gt;1、高可用&lt;/h3&gt;
&lt;p&gt;缓存的高可用是应对缓存雪崩的首要保障：主从，读写分离，动态扩容，一致性均衡，异地容灾等。&lt;/p&gt;
&lt;p&gt;实际应用如Redis的哨兵模式，集群部署等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200520011546620-854932709.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;315&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、服务治理之限流、熔断降级&lt;/h3&gt;
&lt;p&gt;服务治理的目的是什么？服务的稳定性。&lt;/p&gt;
&lt;p&gt;限流即对异常流量的控制；熔断、降级标的核心服务资源的保护。&lt;/p&gt;
&lt;p&gt;笔者在 &lt;a href=&quot;https://www.cnblogs.com/niejunlei/p/12186734.html&quot; target=&quot;_blank&quot;&gt;轻量级熔断降级框架 alibaba sentinel 应用&lt;/a&gt; 介绍过当下流行的几种流控框架的使用。&lt;/p&gt;
&lt;p&gt;缓存、持久化数据存储都是资源，或者我们可以从对缓存的流控及对持久化数据存储的熔断、降级保护来着手应对缓存雪崩的情景发生。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/603942/202005/603942-20200520014943709-1223293744.png&quot; alt=&quot;&quot; width=&quot;561&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 19 May 2020 18:07:00 +0000</pubDate>
<dc:creator>WindWant</dc:creator>
<og:description>缓存的两面性，使用它并且要驾驭它！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niejunlei/p/12914336.html</dc:identifier>
</item>
<item>
<title>时间序列分析中预测类问题下的建模方案 - FinTecher</title>
<link>http://www.cnblogs.com/zhengzhicong/p/12916915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhengzhicong/p/12916915.html</guid>
<description>&lt;p&gt;时间序列分析主要有两个方向，一个通过是对历史数据的分析进行异常检测和分类，二是进行预测！ 本文主要对时间序列分析中预测类问题下的建模方案进行探讨，其他内容之后再分享！一、基于统计学模型 二、基于机器学习模型 三、基于深度学习模型 三种类型的模型各有所长和不足。一般来说，统计类模型适合于数据量较小同时工业化需求不高的情况，机器学习类模型更广泛适合于工业化情境，而深度学习模型在大数据量的预测上更具备优势。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;178.91468470434&quot;&gt;
&lt;p&gt;【说在前面】本人博客新手一枚，象牙塔的老白，职业场的小白。以下内容仅为个人见解，欢迎批评指正，不喜勿喷！[认真看图][认真看图]&lt;/p&gt;
&lt;p&gt;【补充说明】时间序列分析主要有两个方向，一个通过是对历史数据的分析进行异常检测和分类，二是进行预测！ &lt;/p&gt;
&lt;p&gt;【补充说明】回归分析假设每个数据点都是&lt;strong&gt;独立&lt;/strong&gt;的，而时间序列分析则是利用数据之间的&lt;strong&gt;相关性&lt;/strong&gt;进行预测！&lt;/p&gt;
&lt;p&gt;【多说一句】本文主要对时间序列分析中预测类问题下的建模方案进行探讨，其他内容之后再分享！&lt;/p&gt;
&lt;h2&gt;一、基于统计学模型&lt;/h2&gt;
&lt;h3&gt;1. 基本概念&lt;/h3&gt;
&lt;p&gt;一个时间序列可能存在的特征包括以下几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;趋势：时间序列在长时间内呈现出来的长期上升或下降的变动&lt;/li&gt;
&lt;li&gt;季节性：时间序列在一年内出现的周期性波动，例如销售淡季和销售旺季等&lt;/li&gt;
&lt;li&gt;&lt;span data-mce-=&quot;&quot;&gt;序列相关性：又称为自相关性。&lt;span data-mce-=&quot;&quot;&gt;即时间序列中数据点之间存在正相关或者负相关&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;随机噪声：时间序列中除去趋势、季节变化和自相关性之后的剩余随机扰动。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;时间序列中预测类问题的目标是利用统计建模来识别时间序列中潜在的&lt;strong&gt;趋势&lt;/strong&gt;、&lt;strong&gt;季节变化&lt;/strong&gt;和&lt;strong&gt;序列相关性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而衡量一个模型是否适合原始时间序列的标准正是考察原始值和拟合值之间的残差序列是否近似的为&lt;strong&gt;白噪声&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，首先要进行时间序列的自相关性分析，确定训练数据是符合时间序列要求：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用时滞图观察：时滞图是把时间序列的值及相同序列在时间轴上后延的值放在一起展示。&lt;/li&gt;
&lt;li&gt;Ljung-Box检验：是一种对平稳性检验的方法，判断一个序列是白噪声还是序列存在相关性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;时间序列建模的过程可以总结如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200519213233311-278642014.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;67&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2. 平稳性检验&lt;/h3&gt;
&lt;p&gt;如果想要对时间序列进行统计学模型分析，需要保证时间序列具有平稳性。&lt;/p&gt;
&lt;p&gt;在数学上，时间序列的严平稳有着更精确的定义：它要求时间序列中任意给定长度的两段子序列都满足相同的联合分布。这是一个很强的条件，在实际中几乎不可能被满足。因此还有弱平稳的定义，它要求时间序列满足均值平稳性和二阶平稳性（方差平稳性）。&lt;/p&gt;
&lt;p&gt;检验平稳性的方法有很多种：&lt;/p&gt;
&lt;p&gt;（1）图示法&lt;/p&gt;
&lt;p&gt;根据时序图粗略判断是否平稳：平稳时序图的特征为围绕均值波动，而非平稳时序图表现为在不同时间段具有不同的均值。&lt;/p&gt;
&lt;p&gt;即可以从两个特征进行判断：趋势（即均值随时间变化）、季节性（即方差随时间变化、自协方差随时间变化）。&lt;/p&gt;
&lt;p&gt;如图所示，图a为平稳时序图，图b为非平稳时序图。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic2.zhimg.com/80/v2-a115abc7156c7604f605c6b29ac6876d_720w.jpg&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;153&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; data-rawwidth=&quot;817&quot; data-rawheight=&quot;302&quot; data-original=&quot;https://pic2.zhimg.com/v2-a115abc7156c7604f605c6b29ac6876d_r.jpg&quot; data-actualsrc=&quot;https://pic2.zhimg.com/v2-a115abc7156c7604f605c6b29ac6876d_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）单位根检测法&lt;/p&gt;
&lt;p&gt;例如DF检验、ADF检验、KPSS、P-P等，具体不展开介绍。&lt;/p&gt;
&lt;h3&gt;3. 平稳化处理&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;变换：例如取对数、取平方等&lt;/li&gt;
&lt;li&gt;平滑处理：例如移动平均等&lt;/li&gt;
&lt;li&gt;差分&lt;/li&gt;
&lt;li&gt;分解&lt;/li&gt;
&lt;li&gt;多项式拟合：例如拟合回归等&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;4. 统计学模型：自回归模型 AR&lt;/h3&gt;
&lt;p&gt;数学上，满足如下关系的时间序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Br_t%5C%7D&quot; alt=&quot;[公式]&quot; data-formula=&quot;\{r_t\}&quot;/&gt; 被称为一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p&quot; alt=&quot;[公式]&quot; data-formula=&quot;p&quot;/&gt; 阶的自回归模型，记为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmbox%7BAR%7D%28p%29&quot; alt=&quot;[公式]&quot; data-formula=&quot;\mbox{AR}(p)&quot;/&gt; 模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cbegin%7Barray%7D%7Brll%7D+r_t%26%3D%26%5Calpha_1r_%7Bt-1%7D%2B%5Calpha_2r_%7Bt-2%7D%2B%5Ccdots%2B%5Calpha_pr_%7Bt-p%7D%2Bw_t%5C%5C+%26%3D%26%5Cdisplaystyle%5Csum_%7Bi%3D1%7D%5Ep%5Calpha_i+r_%7Bt-i%7D%2Bw_t+%5Cend%7Barray%7D&quot; alt=&quot;[公式]&quot; data-formula=&quot;\begin{array}{rll} r_t&amp;amp;=&amp;amp;\alpha_1r_{t-1}+\alpha_2r_{t-2}+\cdots+\alpha_pr_{t-p}+w_t\\ &amp;amp;=&amp;amp;\displaystyle\sum_{i=1}^p\alpha_i r_{t-i}+w_t \end{array}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=p&quot; alt=&quot;[公式]&quot; data-formula=&quot;p&quot;/&gt; 阶的意思是使用当前时刻 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t&quot; alt=&quot;[公式]&quot; data-formula=&quot;t&quot;/&gt; 之前的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p&quot; alt=&quot;[公式]&quot; data-formula=&quot;p&quot;/&gt; 个观测值作为自变量对 &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_t&quot; alt=&quot;[公式]&quot; data-formula=&quot;r_t&quot;/&gt; 建模。模型的含义是， &lt;img src=&quot;https://www.zhihu.com/equation?tex=r_t&quot; alt=&quot;[公式]&quot; data-formula=&quot;r_t&quot;/&gt; 可以表达为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t&quot; alt=&quot;[公式]&quot; data-formula=&quot;t&quot;/&gt; 时刻之前的 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p&quot; alt=&quot;[公式]&quot; data-formula=&quot;p&quot;/&gt; 个收益率观测值的线性组合以及一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=t&quot; alt=&quot;[公式]&quot; data-formula=&quot;t&quot;/&gt; 时刻的随机误差 &lt;img src=&quot;https://www.zhihu.com/equation?tex=w_t&quot; alt=&quot;[公式]&quot; data-formula=&quot;w_t&quot;/&gt; 。&lt;strong&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=p&quot; alt=&quot;[公式]&quot; data-formula=&quot;p&quot;/&gt;&lt;/strong&gt; 的取值可以是任何一个正整数，因此最简单的自回归模型就是 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmbox%7BAR%7D%281%29&quot; alt=&quot;[公式]&quot; data-formula=&quot;\mbox{AR}(1)&quot;/&gt; 模型（ &lt;img src=&quot;https://www.zhihu.com/equation?tex=p+%3D+1&quot; alt=&quot;[公式]&quot; data-formula=&quot;p = 1&quot;/&gt; ）。&lt;/p&gt;
&lt;p&gt;需要说明的是，自回归模型不一定都满足平稳性。&lt;/p&gt;
&lt;h3&gt;5. 统计学模型：滑动平均模型 MA&lt;/h3&gt;
&lt;p&gt;数学上，满足如下关系的时间序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Br_t%5C%7D&quot; alt=&quot;[公式]&quot; data-formula=&quot;\{r_t\}&quot;/&gt; 被称为一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q&quot; alt=&quot;[公式]&quot; data-formula=&quot;q&quot;/&gt; 阶的滑动平均模型，记为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmbox%7BMA%7D%28q%29&quot; alt=&quot;[公式]&quot; data-formula=&quot;\mbox{MA}(q)&quot;/&gt; 模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.zhihu.com/equation?tex=r_t%3D%5Comega_t%2B%5Cbeta_1%5Comega_%7Bt-1%7D%2B%5Cbeta_2%5Comega_%7Bt-2%7D%2B%5Ccdots%2B%5Cbeta_q%5Comega_%7Bt-q%7D&quot; alt=&quot;[公式]&quot; data-formula=&quot;r_t=\omega_t+\beta_1\omega_{t-1}+\beta_2\omega_{t-2}+\cdots+\beta_q\omega_{t-q}&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与自回归模型不同，滑动平均模型一定满足平稳性。&lt;/p&gt;
&lt;h3&gt;6. 统计学模型：自回归滑动平均模型 ARMA&lt;/h3&gt;
&lt;p&gt;ARMA模型是针对平稳时间序列建立的模型。将一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=p&quot; alt=&quot;[公式]&quot; data-formula=&quot;p&quot;/&gt; 阶的自回归模型和一个 &lt;img src=&quot;https://www.zhihu.com/equation?tex=q&quot; alt=&quot;[公式]&quot; data-formula=&quot;q&quot;/&gt; 阶的滑动平均模型组合在一起，将 AR 和 MA 模型的优势互补起来。由于 AR 和 MA 模型都是线性模型，因此它俩的线性组合，即 ARMA 模型，也是线性模型。&lt;/p&gt;
&lt;p&gt;数学上，满足如下关系的时间序列 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5C%7Br_t%5C%7D&quot; alt=&quot;[公式]&quot; data-formula=&quot;\{r_t\}&quot;/&gt; 被称为一个阶数为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=+%28p%2Cq%29+&quot; alt=&quot;[公式]&quot; data-formula=&quot; (p,q)&quot;/&gt; 的自回归滑动平均模型，记为 &lt;img src=&quot;https://www.zhihu.com/equation?tex=%5Cmbox%7BARMA%7D%28p%2Cq%29&quot; alt=&quot;[公式]&quot; data-formula=&quot;\mbox{ARMA}(p,q)&quot;/&gt; 模型：&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;origin_image zh-lightbox-thumb lazy&quot; src=&quot;https://pic1.zhimg.com/80/v2-e5958a94b785e506a0eb6592fa2395dc_720w.jpg&quot; alt=&quot;&quot; width=&quot;479&quot; height=&quot;72&quot; data-size=&quot;normal&quot; data-caption=&quot;&quot; data-rawwidth=&quot;592&quot; data-rawheight=&quot;89&quot; data-original=&quot;https://pic1.zhimg.com/v2-e5958a94b785e506a0eb6592fa2395dc_r.jpg&quot; data-actualsrc=&quot;https://pic1.zhimg.com/v2-e5958a94b785e506a0eb6592fa2395dc_b.jpg&quot; data-lazy-status=&quot;ok&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相比较单一的 AR 或者 MA 模型，ARMA 模型拥有更多的参数，出现过拟合的危险就更高。因此，在确定 AR、MA 以及 ARMA 模型的阶数时，常使用&lt;strong&gt;信息量准则&lt;/strong&gt;，包括赤池信息量准则（简称 AIC）以及贝叶斯信息量准则（简称 BIC）。这两个信息量准则的目的都是寻找可以最好地解释数据但包含最少自由参数的模型，均使用模型的似然函数、参数个数以及观测点个数来构建一个标量函数，以此作为评价模型好坏的标准，区别在于标量函数的表达式有所不同。&lt;/p&gt;
&lt;h3&gt;7. 统计学模型：差分整合移动平均自回归模型 ARIMA&lt;/h3&gt;
&lt;p&gt;ARIMA （p，d，q）模型是针对非平稳时间序列建模，在ARMA模型的基础上多了差分项（即前文提到的平稳化处理）。其中AR是“自回归”，p为自回归项数，MA为“滑动平均”，q为滑动平均项数，d为使之成为平稳序列所做的差分次数。其中，对于p，d，q的选择是通过ACF（自相关函数，描述了时间序列数据与其之后版本的相关性）与PACF（偏自相关函数，描述了各个序列的相关性）来确定的。&lt;/p&gt;
&lt;h3&gt;8. 统计学模型：季节性差分自回归滑动平均模型 SARIMA&lt;/h3&gt;
&lt;p&gt;在 ARIMA 模型的基础上进行了季节性调节。不同的是SARIMA的差分项有两个，分别是季节性差分与非季节性差分。&lt;/p&gt;
&lt;h3&gt;9. 模型检验：残差检验&lt;/h3&gt;
&lt;p&gt;如果一个模型和原时间序列的残差满足白噪声，那么该模型就是合适的。因此，只需要检验残差序列是否在任何间隔 k 上呈现出统计意义上显著的自相关性。在这方面，Ljung–Box 检验是一个很好的方法，它同时检验残差序列各间隔的自相关系数是否显著的不为 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，分享大佬总结的一些内容：时间序列分析常用统计模型&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单变量时间序列统计学模型：例如平均方法、平滑方法、有/无季节性条件的 ARIMA 模型等&lt;/li&gt;
&lt;li&gt;多变量时间序列统计学模型：例如外生回归变量、VAR等&lt;/li&gt;
&lt;li&gt;附加或组件模型：例如Facebook Prophet、ETS等&lt;/li&gt;
&lt;li&gt;结构化时间序列模型：例如贝叶斯结构化时间序列模型、分层时间序列模型等&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;二、基于机器学习模型&lt;/h2&gt;
&lt;p&gt;时间序列预测类问题被抽象为回归问题，从而可以使用机器学习的相关模型，不需要受到基本假设的限制，适用范围更广。&lt;/p&gt;
&lt;p&gt;具体方法包括但不限于线性回归、支持向量机、随机森林、xgboost等。&lt;/p&gt;
&lt;p&gt;关于机器学习/数据挖掘的全流程介绍，欢迎浏览我的另一篇博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12728491.html&quot;&gt;数据挖掘比赛/项目全流程介绍&lt;/a&gt;，这里不再赘述。&lt;/p&gt;
&lt;p&gt;值得一提的是，机器学习在特征工程阶段，可以提取时间截面特征/统计特征/滑窗特征等，也可以借助特征提取工具（例如tsfresh等）。&lt;/p&gt;
&lt;h2&gt;三、基于深度学习模型&lt;/h2&gt;
&lt;p&gt;具体方法包括但不限于卷积神经网络CNN、循环神经网络LSTM等，目前还有用生成对抗网络GAN等比较新的技术来实现时间序列预测。&lt;/p&gt;
&lt;p&gt;关于循环神经网络，欢迎浏览我的另一篇博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12890660.html&quot;&gt;深度学习中的序列模型演变及学习笔记&lt;/a&gt;，这里不再赘述。&lt;/p&gt;
&lt;p&gt;关于深度学习模型，欢迎浏览我的另一篇博客：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12900712.html&quot;&gt;深度学习中的一些组件及使用技巧&lt;/a&gt;，这里不再赘述。&lt;/p&gt;
&lt;p&gt;值得一提的是，深度学习在准备数据时，需要将时序数据通过时间滑窗进行时间步的拼接，从而作为训练集的输入与标签。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1998154/202005/1998154-20200519153249023-304077760.png&quot; alt=&quot;&quot; width=&quot;520&quot; height=&quot;122&quot;/&gt;&lt;/p&gt;
&lt;p&gt;综上所述，三种类型的模型各有所长和不足。一般来说，统计类模型适合于数据量较小同时工业化需求不高的情况，机器学习类模型更广泛适合于工业化情境，而深度学习模型在大数据量的预测上更具备优势。&lt;/p&gt;

&lt;p&gt;如果你对智能推荐感兴趣，欢迎浏览我的另一篇随笔：&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/zhengzhicong/p/12817941.html&quot;&gt;智能推荐算法演变及学习笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你对广告推荐感兴趣，欢迎浏览我的另一篇随笔：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12862816.html&quot;&gt;CTR预估模型演变及学习笔记&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果您对人工智能算法感兴趣，欢迎浏览我的另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12670260.html&quot;&gt;人工智能新手入门学习路线和学习资源合集（含AI综述/python/机器学习/深度学习/tensorflow）&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12875348.html&quot;&gt;人工智能领域常用的开源框架和库（含机器学习/深度学习/强化学习/知识图谱/图神经网络）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的应届毕业生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650878.html&quot;&gt;如果你是一个计算机领域的应届生，你如何准备求职面试？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的本科生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650191.html&quot;&gt;如果你是一个计算机领域的本科生，你可以选择学习什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你是计算机专业的研究生，欢迎浏览我的另外一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12650369.html&quot;&gt;如果你是一个计算机领域的研究生，你可以选择学习什么？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果你对金融科技感兴趣，欢迎浏览我的另一篇博客：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12657428.html&quot;&gt;如果你想了解金融科技，不妨先了解金融科技有哪些可能？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;之后博主将持续分享各大算法的学习思路和学习笔记：&lt;a href=&quot;https://www.cnblogs.com/zhengzhicong/p/12641421.html&quot;&gt;hello world: 我的博客写作思路&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 19 May 2020 17:21:00 +0000</pubDate>
<dc:creator>FinTecher</dc:creator>
<og:description>时间序列分析主要有两个方向，一个通过是对历史数据的分析进行异常检测和分类，二是进行预测！ 本文主要对时间序列分析中预测类问题下的建模方案进行探讨，其他内容之后再分享！一、基于统计学模型 二、基于机器学</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhengzhicong/p/12916915.html</dc:identifier>
</item>
</channel>
</rss>