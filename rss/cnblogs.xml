<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>让 K8S 在国内愉快的航行 - KAnts</title>
<link>http://www.cnblogs.com/ants/p/12663724.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ants/p/12663724.html</guid>
<description>&lt;p&gt;K8S(kubernetes) 日渐火爆，但由于出自Google，对国内的用户及其的不友好。&lt;br/&gt;&lt;strong&gt;而之前的 &lt;code&gt;*.azk8s.cn&lt;/code&gt; 全能镜像站，也于 2020年4月2日限制了对 Azure China 之外的 IP访问，无疑又是雪上加霜 (很多生产集群应该开始跳脚了)。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;2.7874015748031&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Azure/container-service-for-azure-china/issues/58&quot;&gt;https://github.com/Azure/container-service-for-azure-china/issues/58&lt;/a&gt;&lt;br/&gt;ps: 这么大的事件，居然没有提前公告。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;今天我们来梳理一下，K8S在国内如何愉快的航行。&lt;br/&gt;首先梳理一下国内 K8S 需要翻越的几座山。&lt;/p&gt;
&lt;h2 id=&quot;linux-source&quot;&gt;Linux Source&lt;/h2&gt;
&lt;p&gt;用于安装 docker、kubelet、kubectl、kubeadm 等软件。&lt;/p&gt;
&lt;h2 id=&quot;section-1&quot;&gt;容器镜像库&lt;/h2&gt;
&lt;p&gt;目前常用的K8S镜像库有&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;docker.io (docker hub公共镜像库)&lt;/li&gt;
&lt;li&gt;gcr.io (Google container registry)&lt;/li&gt;
&lt;li&gt;k8s.gcr.io (等同于 gcr.io/google-containers)&lt;/li&gt;
&lt;li&gt;quay.io (Red Hat运营的镜像库)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;linux-source-1&quot;&gt;Linux Source&lt;/h2&gt;
&lt;p&gt;Linux的源镜像比较简单,这边推荐阿里的镜像源。&lt;br/&gt;Docker CE: &lt;a href=&quot;https://developer.aliyun.com/mirror/docker-ce&quot;&gt;https://developer.aliyun.com/mirror/docker-ce&lt;/a&gt;&lt;br/&gt;Kubernetes: &lt;a href=&quot;https://developer.aliyun.com/mirror/kubernetes&quot;&gt;https://developer.aliyun.com/mirror/kubernetes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-3&quot;&gt;容器镜像库&lt;/h2&gt;
&lt;p&gt;镜像库是一个比较难找的资源，由于 &lt;code&gt;*.azk8s.cn&lt;/code&gt; 的关闭目前 &lt;code&gt;gcr.io&lt;/code&gt; 还没有可替代资源，如大家有相关资源可以联系我，我会添加到文章上。&lt;/p&gt;
&lt;h3 id=&quot;docker-hub&quot;&gt;Docker Hub&lt;/h3&gt;
&lt;p&gt;关于 Docker Hub 国内有比较多的加速镜像源。&lt;br/&gt;例如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;阿里云镜像加速器 (推荐, 需要注册用户)
&lt;/li&gt;
&lt;li&gt;DaoCloud镜像加速器
&lt;/li&gt;
&lt;li&gt;七牛云镜像加速器
&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;section-4&quot;&gt;使用方式&lt;/h4&gt;
&lt;p&gt;修改Docker的配置，为其添加 registry-mirrors ，需要重启docker。&lt;br/&gt;配置文件路径位于 &lt;code&gt;/etc/docker/daemon.json&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.25&quot;&gt;
&lt;p&gt;官方文档： &lt;a href=&quot;https://docs.docker.com/registry/recipes/mirror/&quot;&gt;https://docs.docker.com/registry/recipes/mirror/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
  &quot;registry-mirrors&quot;: [&quot;https://f1361db2.m.daocloud.io&quot;],
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;# 重启docker
systemctl daemon-reload &amp;amp;&amp;amp; systemctl restart docker
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;section-5&quot;&gt;说明&lt;/h4&gt;
&lt;p&gt;如果大家在生产环境使用，推荐优先使用阿里云的镜像加速器，虽然注册麻烦了一些。&lt;br/&gt;这是我目前用下来较为稳定的加速器 (此处极度怀念 dockerhub.azk8s.cn )。&lt;/p&gt;
&lt;h3 id=&quot;quay.io&quot;&gt;quay.io&lt;/h3&gt;
&lt;p&gt;关于 quay.io 可用源很少，目前有如下镜像站&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;quay-mirror.qiniu.com (七牛云, 推荐, 但没有找到长期支持的声明)&lt;/li&gt;
&lt;li&gt;quay.mirrors.ustc.edu.cn (中科大, 经常不可用, 不推荐)&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;section-6&quot;&gt;使用方式&lt;/h4&gt;
&lt;p&gt;将镜像中的 &lt;code&gt;quay.io&lt;/code&gt; 替换为 &lt;code&gt;quay-mirror.qiniu.com&lt;/code&gt;，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;quay.io/prometheus/node-exporter:v0.18.1
# 替换成如下格式
quay-mirror.qiniu.com/prometheus/node-exporter:v0.18.1
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;section-7&quot;&gt;说明&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;这两个源都不是长期稳定&lt;/strong&gt;&lt;br/&gt;七牛云目前可用, 但没有找到任何官方说明长期支持。&lt;br/&gt;中科大声明有维护, 但测试后基本呈现不可用状态。&lt;/p&gt;
&lt;h3 id=&quot;gcr.io-k8s.gcr.io&quot;&gt;gcr.io 和 k8s.gcr.io&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;先说结果，我没有找到这两个源的通用镜像站。&lt;/strong&gt;&lt;br/&gt;这是最难的一部分，也花费了我很多时间。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;k8s.gcr.io 是 gcr.io/google-containers 的别名，所以&lt;br/&gt;k8s.gcr.io/&amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt; == gcr.io/google-containers/&amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;目前只有折中方案可以曲线救国，但这在使用上还是造来的不变，没有稳定的镜像同步途径，如果你能FQ那么还好一些，如果不行很多K8S生态中的新兴技术你可能很难体验了 (tekton、knative)等，这种情况下你只能去国内镜像站找别人传上来的副本，如：阿里云第三方镜像、dockerhub等。&lt;/p&gt;
&lt;p&gt;目前我找到了如下镜像库：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;googlecontainersmirror (我自己从 gcr.io 同步到Docker Hub的镜像, 只包含核心的几个镜像和版本, 能保障K8S正常运行)
&lt;/li&gt;
&lt;li&gt;registry.aliyuncs.com/google_containers (阿里云第三方用户上传的镜像，镜像比较多)&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;section-8&quot;&gt;使用方式&lt;/h4&gt;
&lt;p&gt;将镜像中的 &lt;code&gt;k8s.gcr.io&lt;/code&gt; 或 &lt;code&gt;gcr.io/google-containers&lt;/code&gt; 替换为 &lt;code&gt;registry.aliyuncs.com/google_containers&lt;/code&gt; 或 &lt;code&gt;googlecontainersmirror&lt;/code&gt;，例如：&lt;/p&gt;
&lt;h5 id=&quot;registry.aliyuncs.comgoogle_containers&quot;&gt;registry.aliyuncs.com/google_containers&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;gcr.io/google-containers/kube-proxy:v1.18.0
# 替换为
registry.aliyuncs.com/google_containers/kube-proxy:v1.18.0

k8s.gcr.io/kube-proxy:v1.18.0
# 替换为
registry.aliyuncs.com/google_containers/kube-proxy:v1.18.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;googlecontainersmirror&quot;&gt;googlecontainersmirror&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;gcr.io/google-containers/kube-proxy:v1.18.0
# 替换为
googlecontainersmirror/kube-proxy:v1.18.0

k8s.gcr.io/kube-proxy:v1.18.0
# 替换为
googlecontainersmirror/kube-proxy:v1.18.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;宣称可以提供镜像的站点 (经测试全部不可用)：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;gcr.mirrors.ustc.edu.cn (经测试不可用)&lt;/li&gt;
&lt;li&gt;gcr-mirror.qiniu.com (经测试不可用)&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;section-9&quot;&gt;说明&lt;/h4&gt;
&lt;ol&gt;&lt;li readability=&quot;-0.5&quot;&gt;为什么要自己同步镜像而不直接使用现有的镜像库？
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;因为现有的镜像库我没找到任何官方认证，应该是个人传上去的，我们担心跑在生产的K8S集群遭遇到安全问题。&lt;br/&gt;对于大家来说都是第三方同步的镜像大家可以自行选择，如果是生产用还是推荐推到自己的镜像库来保障镜像安全。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1.5&quot;&gt;googlecontainersmirror 在Docker Hub上拉取速度会不会很慢？
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这边取巧的利用了DockerHub加速器，拉取速度取决于加速器的速度，一般情况下很快。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;linux&quot;&gt;Linux软件镜像源&lt;/h2&gt;
&lt;p&gt;Docker CE: &lt;a href=&quot;https://developer.aliyun.com/mirror/docker-ce&quot;&gt;https://developer.aliyun.com/mirror/docker-ce&lt;/a&gt;&lt;br/&gt;Kubernetes: &lt;a href=&quot;https://developer.aliyun.com/mirror/kubernetes&quot;&gt;https://developer.aliyun.com/mirror/kubernetes&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;section-11&quot;&gt;容器镜像源 (删除线为不可用)&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;源&lt;/th&gt;
&lt;th&gt;镜像&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5.8753462603878&quot;&gt;&lt;tr readability=&quot;3.3636363636364&quot;&gt;&lt;td&gt;Docker Hub&lt;/td&gt;
&lt;td&gt;https://&amp;lt;user_code&amp;gt;.mirror.aliyuncs.com, &lt;a href=&quot;https://f1361db2.m.daocloud.io&quot;&gt;https://f1361db2.m.daocloud.io&lt;/a&gt;, &lt;a href=&quot;https://reg-mirror.qiniu.com&quot;&gt;https://reg-mirror.qiniu.com&lt;/a&gt;, &lt;del&gt;dockerhub.azk8s.cn&lt;/del&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;del&gt;gcr.io&lt;/del&gt;&lt;/td&gt;
&lt;td&gt;&lt;del&gt;gcr.azk8s.cn&lt;/del&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;k8s.gcr.io&lt;/td&gt;
&lt;td&gt;googlecontainersmirror, registry.aliyuncs.com/google_containers, &lt;del&gt;gcr.azk8s.cn/google-containers&lt;/del&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;quay.io&lt;/td&gt;
&lt;td&gt;quay-mirror.qiniu.com, &lt;del&gt;quay.mirrors.ustc.edu.cn&lt;/del&gt;, &lt;del&gt;quay.azk8s.cn&lt;/del&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;del&gt;mcr.microsoft.com&lt;/del&gt;&lt;/td&gt;
&lt;td&gt;&lt;del&gt;mcr.azk8s.cn&lt;/del&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Thu, 09 Apr 2020 00:25:00 +0000</pubDate>
<dc:creator>KAnts</dc:creator>
<og:description>前言 K8S(kubernetes) 日渐火爆，但由于出自Google，对国内的用户及其的不友好。 而之前的 全能镜像站，也于 2020年4月2日限制了对 Azure China 之外的 IP访问，无</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ants/p/12663724.html</dc:identifier>
</item>
<item>
<title>惊呆了！不改一行 Java 代码竟然就能轻松解决敏感信息加解密|原创 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/12664339.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/12664339.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200409075311634-772044277.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;出于安全考虑，现需要将数据库的中敏感信息加密存储到数据库中，但是正常业务交互还是需要使用明文数据，所以查询返回我们还需要经过相应的解密才能返回给调用方。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps:日常开发中，我们要有一定的安全意识，对于密码，金融数据等敏感信息事实加密存储保护。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个需求说起来不是很难，我们只需要在执行 sql 之前，提前将指定数据进行加密。执行 sql 之后，获取返回结果，再进行的相应的解密。稍微改造下原有代码，很快完成需求。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200409075311871-376449559.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;现有加密算法如 RSA2 ，AES 等，密文长度将会是明文好几倍。上线加解密方案一定要评估数据库现有字段长度是否满足加密之后长度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果这是一张新建的表，上面的实现方案并没有什么问题。但是这次我们改造是几张已有已有&lt;strong&gt;千万级&lt;/strong&gt;的存量的数据的表，这些数据都未被加密存储。&lt;/p&gt;
&lt;p&gt;如果使用上述代码，使用加密之后的密文信息查询历史数据，当然查询不到任何结果。另外当查询返回的结果是明文，解密明文数据库也可能会导致相应的解密错误。&lt;/p&gt;
&lt;p&gt;所以为了兼容历史数据，需要进行如下改造：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增加新字段存放对应的加密数据，sql 等值条件查询修改成 in 查询&lt;/li&gt;
&lt;li&gt;查询返回的记录首先判断是否是密文，如果是密文再去解密&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码改造如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200409075312023-1369083441.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述代码虽然解决业务需求，但是这个解决方案不是很优雅，业务代码改动较大，加解密的代码不能通用，所有涉及到相关字段的方法都需要改动，且几乎都是重复代码，代码侵入性很强，不是很友好。&lt;/p&gt;
&lt;p&gt;有经验的同学可能会想到使用 Spring AOP 解决上述问题。&lt;/p&gt;
&lt;p&gt;在切面的前置方法（&lt;strong&gt;beforeMethod&lt;/strong&gt;）统一拦截查询参数，配合自定义的注解，加密指定的字段。&lt;/p&gt;
&lt;p&gt;然后在切面的后置方法（&lt;strong&gt;afterReturn&lt;/strong&gt;）拦截返回值，配合自定义注解，解密指定的字段。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Spring AOP 代码实现比较复杂，这里就不贴出具体的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是 Spring AOP 方案也并不通用，如果其他的应用也有相同的需求，同样的代码，又需要重复实现，还是很费时费力。&lt;/p&gt;
&lt;p&gt;最终我们参考一个 github 开源项目『&lt;a href=&quot;https://github.com/drtrang/typehandlers-encrypt&quot;&gt;&lt;strong&gt;typehandlers-encrypt&lt;/strong&gt;&lt;/a&gt;』，借助 mybatis 的 &lt;strong&gt;TypeHandler&lt;/strong&gt;，实现通用的数据加解密解决方案。使用方只需要引入相关依赖，&lt;strong&gt;无需改动一行业务代码&lt;/strong&gt;，仅需少量配置即可实现指定字段加解密操作，省时省力。&lt;/p&gt;
&lt;blockquote readability=&quot;2.202380952381&quot;&gt;
&lt;p&gt;&lt;strong&gt;typehandlers-encrypt&lt;/strong&gt; github 地址：&lt;a href=&quot;https://github.com/drtrang/typehandlers-encrypt&quot;&gt;https://github.com/drtrang/typehandlers-encrypt&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200409075312174-253152638.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现原理&quot;&gt;实现原理&lt;/h2&gt;
&lt;p&gt;mybatis 利用内置类型转换器（&lt;strong&gt;typeHandler&lt;/strong&gt;），实现 Java 类型与 JDBC 类型的相互转换，我们正好可以利用这个特性，在转换之前加入加解密步骤。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;typeHandler&lt;/code&gt; 底层原理不是复杂，如果我们没有使用 Mybatis，而是直接使用最原始的 JDBC 执行查询语句，相关代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200409075312302-1415965405.jpg&quot; alt=&quot;JDBC&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们需要手动判断 Java 类型，然后调用 &lt;code&gt;PreparedStatement&lt;/code&gt;设置合适类型参数。获取返回结果之后，又需要手动调用 &lt;code&gt;ResultSet&lt;/code&gt; 结果集获取相应类型的数据，这个过程十分繁琐。&lt;/p&gt;
&lt;p&gt;使用 mybatis 之后，上述步骤就无需我们再实现了。mybatis 可以通过识别 Java/JDBC 类型，调用相应&lt;code&gt;typeHandler&lt;/code&gt;，自动实现转换逻辑。&lt;/p&gt;
&lt;p&gt;下图为 mybatis 内置类型转换器，基本涵盖了所有 &lt;strong&gt;Java/JDBC&lt;/strong&gt; 数据类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200409075312451-950655551.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;通用解决方案&quot;&gt;通用解决方案&lt;/h2&gt;
&lt;h3 id=&quot;自定义-typehandler&quot;&gt;自定义 typeHandler&lt;/h3&gt;
&lt;p&gt;下面我们来实现带有加解密功能的类型转换器，实现方式也比较简单，只要继承 &lt;code&gt;org.apache.ibatis.type.BaseTypeHandler&lt;/code&gt;，重写相关方法。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简单起见，上述加解密仅使用了 Base64，大家可以替换成相应加解密算法即或者引入相应加解密服务。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200409075312654-1856912876.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中加密转换将在 &lt;code&gt;setNonNullParameter&lt;/code&gt; 中执行，解密转换将在 &lt;code&gt;getNullableResult&lt;/code&gt;中执行。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CryptTypeHandler&lt;/code&gt; 使用一个 &lt;code&gt;MappedTypes&lt;/code&gt; 注解，包含一个 &lt;code&gt;CryptType&lt;/code&gt; 类，这个类使用 mybatis 别名功能，可以极大简化 sqlmap 相关配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200409075312848-1461345213.jpg&quot; alt=&quot;alias&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;注册-typehandler&quot;&gt;注册 typeHandler&lt;/h3&gt;
&lt;p&gt;使用方必须将 &lt;code&gt;typeHandler&lt;/code&gt; 和 &lt;code&gt;alias&lt;/code&gt; 注册到 mybatis 中，否则无法生效。&lt;/p&gt;
&lt;p&gt;下面提供三种方式,可以根据项目情况选择其中一种即可：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;单独使用 mybatis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种场景需要在 &lt;strong&gt;mybatis-config.xml&lt;/strong&gt; 配置，mybatis 启动时将会加载该配置文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;typeHandlers&amp;gt;
  &amp;lt;!--类型转换器包路径--&amp;gt;
  &amp;lt;package name=&quot;com.xx.xx&quot;/&amp;gt;
&amp;lt;/typeHandlers&amp;gt;
  &amp;lt;!-- 别名定义 --&amp;gt;
&amp;lt;typeAliases&amp;gt;
                &amp;lt;!-- 针对单个别名定义 type:类型的路径 alias:别名 --&amp;gt;
                &amp;lt;typeAlias type=&quot;xx.xx.xx&quot; alias=&quot;xx&quot;/&amp;gt;
&amp;lt;/typeAliases&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;使用 Spring 配置 Mybatis Bean&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配合 Spring 使用时需要将 &lt;code&gt;typeHandler&lt;/code&gt; 注入 &lt;code&gt;SqlSessionFactoryBean&lt;/code&gt; ，配置方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- MyBatis 工厂 --&amp;gt;
&amp;lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&amp;gt;
    &amp;lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&amp;gt;

    &amp;lt;!--alias 注入--&amp;gt;
    &amp;lt;property name=&quot;typeAliasesPackage&quot; value=&quot;xx.xx.xx&quot;/&amp;gt;
    &amp;lt;!--  typeHandlers 注入   --&amp;gt;
    &amp;lt;property name=&quot;typeHandlersPackage&quot; value=&quot;xx.xx.xx&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;SpringBoot&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SpringBoot 方式就最简单了，只要引入 &lt;code&gt;mybatis-starter&lt;/code&gt;，配置文件加入如下配置即可:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-properties&quot;&gt;## mybatis 配置
# 类型转换器包路径
mybatis.type-handlers-package=com.xx.xx.x
mybatis.type-aliases-package=com.xx.xx
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;修改-mapper-sql-配置&quot;&gt;修改 mapper sql 配置&lt;/h3&gt;
&lt;p&gt;最后我们只要简单修改 mapper 中 &lt;code&gt;resultMap&lt;/code&gt; 或 sql s配置就可以实现加解密。&lt;/p&gt;
&lt;p&gt;假设我们对现有一张 &lt;strong&gt;bank_card&lt;/strong&gt; 表进行加解密，表结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;CREATE TABLE bank_card (
id int primary key auto_increment,
gmt_create timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP,
gmt_update timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
card_no varchar(256) NOT NULL DEFAULT '' COMMENT '卡号',
phone varchar(256) NOT NULL DEFAULT '' COMMENT '手机号',
name varchar(256) NOT NULL DEFAULT '' COMMENT '姓名',
id_no varchar(256) NOT NULL DEFAULT '' COMMENT '证件号'
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;insert 加密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现需要对 &lt;code&gt;card_no&lt;/code&gt;，&lt;code&gt;phone&lt;/code&gt;，&lt;code&gt;name&lt;/code&gt;，&lt;code&gt;id_no&lt;/code&gt; 进行加密，&lt;strong&gt;insert&lt;/strong&gt; 语句加密示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;insert id=&quot;insertBankCard&quot; keyProperty=&quot;id&quot; useGeneratedKeys=&quot;true&quot; parameterType=&quot;org.demo.pojo.BankCardDO&quot;&amp;gt;
    INSERT INTO bank_card (card_no, phone,name,id_no)
    VALUES
    (#{card_no,javaType=crypt},
    #{phone,typeHandler=org.demo.type.CryptTypeHandler},
    #{name,javaType=crypt},
    #{id_no,javaType=crypt})
&amp;lt;/insert&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只需要在 &lt;strong&gt;#{}&lt;/strong&gt; 指定 typeHandler，传入参数最后将被加密。使用 &lt;code&gt;typeHandler&lt;/code&gt;需要使用类的全路径，比较繁琐，我们可以使用 &lt;strong&gt;javaType&lt;/strong&gt; 属性，直接使用上面我们的定义别名 &lt;strong&gt;crypt&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;数据库最终执行sql 如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;INSERT INTO bank_card (card_no, phone,name,id_no) VALUES ('NjQzMjEyMzEyMzE=', 'MTM1Njc4OTEyMzQ=', '5rWL6K+V5Y2h', 'MTIzMTIzMTIzMQ==');
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps:推荐一款 IDEA 的插件 &lt;strong&gt;mybatis-log-plugin&lt;/strong&gt;，可以自动将 mybatis sql 日志还原成真实执行 sql&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;查询加解密&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;普通查询解密示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;resultMap id=&quot;bankCardXml&quot; type=&quot;org.demo.pojo.BankCardDO&quot;&amp;gt;
        &amp;lt;result property=&quot;card_no&quot; column=&quot;card_no&quot; typeHandler=&quot;org.demo.type.CryptTypeHandler&quot;/&amp;gt;
        &amp;lt;result property=&quot;name&quot; column=&quot;name&quot; typeHandler=&quot;org.demo.type.CryptTypeHandler&quot;/&amp;gt;
        &amp;lt;result property=&quot;id_no&quot; column=&quot;id_no&quot; typeHandler=&quot;org.demo.type.CryptTypeHandler&quot;/&amp;gt;
        &amp;lt;result property=&quot;phone&quot; column=&quot;phone&quot; typeHandler=&quot;org.demo.type.CryptTypeHandler&quot;/&amp;gt;
&amp;lt;/resultMap&amp;gt;
&amp;lt;select id=&quot;queryById&quot; resultMap=&quot;bankCardXml&quot;&amp;gt;
        select * from bank_card where id=#{id}
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们在 &lt;strong&gt;select&lt;/strong&gt; 配置中只能使用 &lt;code&gt;resultMap&lt;/code&gt; 属性，指定 &lt;code&gt;typeHandler&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;数据库明文、密文共存的情况，查询解密示例如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- resultMap 同上   --&amp;gt;
&amp;lt;select id=&quot;queryByPhone&quot; resultMap=&quot;bankCardXml&quot;&amp;gt;
      select * from bank_card where phone in(#{card_no,javaType=crypt},#{card_no})
&amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后我们可以将自定义的 &lt;code&gt;typeHandler&lt;/code&gt; 单独打包发布，其他业务方只需要引用，改造相关配置文件，即可完成数据加解密。&lt;/p&gt;
&lt;p&gt;上述代码示例已上传至 Github，地址：&lt;a href=&quot;https://github.com/9526xu/mybatis-encrypt&quot;&gt;https://github.com/9526xu/mybatis-encrypt&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;借助于自定义的 &lt;code&gt;typeHandler&lt;/code&gt;，我们实现了一个通用的加解密的方案，该方案对于使用方来说代码侵入性小，开箱即用，可以快速完成加解密的改造。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps:你们是否也有遇到同样的需求，可以在下方留言写下你们的方案，互相学习，一起成长！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后感谢一下&lt;strong&gt;@辉哥&lt;/strong&gt;提供解决思路。&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/9526xu/mybatis-encrypt&quot;&gt;https://github.com/9526xu/mybatis-encrypt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/drtrang/typehandlers-encrypt&quot;&gt;https://github.com/drtrang/typehandlers-encrypt&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;最后（求关注）&quot;&gt;最后（求关注）&lt;/h2&gt;
&lt;p&gt;看到这里，想必大家都累了，放一张趣图轻松一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200409075312988-2044992900.jpg&quot; alt=&quot;当你在 github 提交相关 issue 期待其他人回答解答问题时&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后再次感谢您的阅读，我是&lt;strong&gt;楼下小黑哥&lt;/strong&gt;，一位还未秃头的工具猿，下篇文章我们再见~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202004/1419561-20200409075313132-1719381599.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 08 Apr 2020 23:53:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>前言 出于安全考虑，现需要将数据库的中敏感信息加密存储到数据库中，但是正常业务交互还是需要使用明文数据，所以查询返回我们还需要经过相应的解密才能返回给调用方。 ps:日常开发中，我们要有一定的安全意识</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/12664339.html</dc:identifier>
</item>
<item>
<title>CSS躬行记（3）——CSS属性拾遗 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/12519570.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/12519570.html</guid>
<description>&lt;p&gt;　　粘滞定位（sticky）与相对定位类似，既不会脱离正常流，也不会改变元素盒类型，并且会保留原先所占的空间。它会相对于包含块偏移，它的包含块分为两种，第一种和绝对定位一样；第二种是最近的滚动祖先，即overflow属性是hidden、scroll、auto或overlay时。接下来用一个例子来介绍粘滞定位的用法，如下代码所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  div &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    overflow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; auto&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  span &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    position&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; sticky&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    top&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    left&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 20px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    width&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 70px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    height&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 50px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;
    background&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #CCC&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  改变粘滞定位的位置，改变
  &lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;粘滞定位的位置&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;span&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  ，改变粘滞定位的位置，改变粘滞定位的位置，
  改变粘滞定位的位置，改变粘滞定位的位置，
  改变粘滞定位的位置。
&lt;/span&gt;&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　span元素的包含块是div元素，下图描绘了页面滚动时，粘滞定位的效果。在中间图中可以看到偏移后的span元素所占的空间被保留了，在右边图中可以看到span元素粘滞在指定的偏移位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318192334920-1947370445.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　CSS3新增了一组属性，允许在边框中加载图像，接下来会逐个讲解。&lt;/p&gt;
&lt;p&gt;　　第一个是border-image-source属性，它能指定图像来源，如下所示。在下图中，会发现加载的图像位于div元素的四个角，而不是沿着边框绘制。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  border&lt;/span&gt;:&lt;span&gt; 40px solid&lt;/span&gt;;&lt;span&gt;
  border-image-source&lt;/span&gt;:&lt;span&gt; url(./star.png)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318192504554-1832544307.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意，边框宽度需要指定，并且其外观不能是none，否则将无法显示。&lt;/p&gt;
&lt;p&gt;　　第二个是border-image-slice属性，它包含四条裁剪线，可接收四个偏移值，分别距图像的上右下左四个边，下图演示了偏移33%时的裁剪线。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318192609051-4571636.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　执行下面的样式（效果如下图所示），在将circle.png分解成9块后，编号为1、2、3、4的四个圆位于div元素的四个角，而编号为5、6、7、8的四个圆则会被拉伸。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  border-image-source&lt;/span&gt;:&lt;span&gt; url(./circle.png)&lt;/span&gt;;&lt;span&gt;
  border-image-slice&lt;/span&gt;:&lt;span&gt; 33%&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318192724268-1031348351.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　border-image-slice属性还能接收一个fill关键字（如下图所示），可将编号为9的圆作为div元素的背景图。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  border-image-slice&lt;/span&gt;:&lt;span&gt; 33% fill&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318192813324-1203215031.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第三个是border-image-repeat属性，它能指定填充边框的方式，默认是拉伸，现在改成平铺（如下图所示），边界处的图像可能会被裁剪。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  border-image-repeat&lt;/span&gt;:&lt;span&gt; repeat&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318192857453-1254209877.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第四个是border-image-width属性，与border-image-slice属性类似，也有4条裁剪线，只是它裁剪的对象是边框。在下图中，左边是未定义border-image-width属性的div元素，右边是将该属性设为20px后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  border-image-width&lt;/span&gt;:&lt;span&gt; 20px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318192944525-1224883523.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第五个是border-image-outset属性，可声明图像超出边框的距离，即向外偏移。在下图中，左边是未定义border-image-outset属性的div元素，右边是将该属性设为10px后的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  border-image-outset&lt;/span&gt;:&lt;span&gt; 10px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318193033305-172143677.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　第六个是border-image属性，可将上述5个属性整合到一起，规定不同的值之间用斜杠（/）分隔，并且还指定了顺序：首先是border-image-slice，然后是border-image-width，最后是border-image-outset。而border-image-source和border-image-repeat两个属性可放在任意位置，但要注意，不能放置在其它属性值之中。下面是个整合示例，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  border-image&lt;/span&gt;:&lt;span&gt; url(./circle.png) 33% / 20px / 10px repeat&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318193124876-1752003538.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　letter-spacing属性可定义字符之间的距离，可以突出某段文本，例如为p元素定义10px的字符间距，如下图所示。 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  p &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    letter-spacing&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 10px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;字符间距是10px&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318193254377-51045543.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　text-shadow属性可为文本添加阴影，适用于标题或短文本。阴影值由四部分组成，分别是颜色、横向偏移、纵向偏移和模糊半径。下面的示例为一段文本添加了灰色的阴影，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
p &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
  text-shadow&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; #CCC 5px 10px 2px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;My name is Strick.&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;p&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318193421197-1718522483.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意，模糊半径越大，阴影就越模糊。妥善利用好text-shadow属性，还能创造出3D效果，下面的样式来源于网络，字体放大后，3D更明显，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;p &lt;/span&gt;{&lt;span&gt;
  font-size&lt;/span&gt;:&lt;span&gt; 48px&lt;/span&gt;;&lt;span&gt;
  text-shadow&lt;/span&gt;:&lt;span&gt; 0 1px 1px #BBB, 
    0 2px 0 #999, 
    0 3px 0 #888, 
    0 4px 0 #777,
    0 5px 0 #666, 
    0 6px 0 #555, 
    0 7px 0 #444, 
    0 8px 0 #333, 
    0 9px 7px #302314&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318193503654-147939423.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　CSS3支持多重背景，大部分背景属性都能通过逗号分隔多个值，包括简写的background属性也能接受多个值。在下面的示例中，为div元素声明了两个背景，先声明的star.png将会在lake.png之上，如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;div &lt;/span&gt;{&lt;span&gt;
  background-image&lt;/span&gt;:&lt;span&gt; url(./star.png), url(./lake.png)&lt;/span&gt;;&lt;span&gt;
  background-position&lt;/span&gt;:&lt;span&gt; left bottom, center&lt;/span&gt;;&lt;span&gt;
  background-repeat&lt;/span&gt;:&lt;span&gt; repeat-x, no-repeat&lt;/span&gt;;
}
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等价于 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
div &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; url(./star.png) left bottom repeat-x,
            url(./lake.png) center no-repeat&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200318193703513-902992098.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意，不能为background-color指定多个值。当用background属性声明多个背景时，颜色只能出现在最后一个背景层中，如下代码所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 错误 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
div &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; #FC0 url(./star.png) left bottom repeat-x,
            url(./lake.png) center no-repeat&lt;/span&gt;;
}
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 正确 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
div &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; url(./star.png) left bottom repeat-x,
            #FC0 url(./lake.png) center no-repeat&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在CSS中，矩阵函数是变形的基础，位移、缩放、倾斜和旋转四种变形都能用矩阵来实现，例如用矩阵函数来描述水平偏移10px，垂直偏移5px，代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.matrix &lt;/span&gt;{&lt;span&gt;
  transform&lt;/span&gt;:&lt;span&gt; matrix(1, 0, 0, 1, 10, 5)&lt;/span&gt;;
  &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 等同于 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  transform&lt;/span&gt;:&lt;span&gt; translate(10px, 5px)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　现在将矩阵函数的6个参数用小写字母来命名，如下所示，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;transform: matrix(a, b, c, d, e, f);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　对应的矩阵如下所示，注意观察6个参数的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200319105006445-1537643110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　矩阵函数的原理是通过变更元素的所有坐标，重新定位元素，从而实现各种变形。下面是矩阵的计算公式，其中x和y是元素的横坐标和纵坐标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200319105038426-1786394201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　ax+cy+e是变形后的横坐标，bx+dy+f是变形后的纵坐标。具体的计算过程如下所示，以矩阵的第一行为例，相同底色的变量会相乘，得到的积再相加。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200319105107673-1858672153.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在下图中，列出了与四类变形函数等效的矩阵符号（引用自《&lt;span&gt;&lt;a href=&quot;https://www.useragentman.com/blog/2011/01/07/css3-matrix-transform-for-the-mathematically-challenged/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;The CSS3 matrix() Transform for the Mathematically Challenged&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》一文），其中旋转和倾斜还用到了三角函数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200319105205399-1656774265.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在三维空间，也有一个对应的矩阵函数：matrix3d()，此处不再展开叙述，可以查看网上的相关资料。&lt;/p&gt;

&lt;p&gt;　　在三维空间中有三个轴，如下图所示，其中Z轴表示用户与平面的距离（即透视值）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200319105314966-889965613.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　perspective()是一个透视函数，它能接收一个非零正数透视值。在下面的示例中，会让四个元素围绕Y轴旋转30°，除了第一个元素，其它都调用了透视函数。通过下图的效果可知，当透视值越小时，变形效果越失真。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.rotate &lt;/span&gt;{&lt;span&gt;
  transform&lt;/span&gt;:&lt;span&gt; rotateY(30deg)&lt;/span&gt;;
}&lt;span&gt;
.perspective-200 &lt;/span&gt;{&lt;span&gt;
  transform&lt;/span&gt;:&lt;span&gt; perspective(200px) rotateY(30deg)&lt;/span&gt;;
}&lt;span&gt;
.perspective-600 &lt;/span&gt;{&lt;span&gt;
  transform&lt;/span&gt;:&lt;span&gt; perspective(600px) rotateY(30deg)&lt;/span&gt;;
}&lt;span&gt;
.perspective-1200 &lt;/span&gt;{&lt;span&gt;
  transform&lt;/span&gt;:&lt;span&gt; perspective(1200px) rotateY(30deg)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200319105414486-519535697.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意，透视函数需要声明在变形函数列表的首位，以免在透视前变形，呈现错误的效果。&lt;/p&gt;
&lt;p&gt;　　除了perspective()函数之外，CSS3还提供了一个perspective属性。前者只能为目标元素声明透视，而后者声明的透视能应用于其子元素。举个简单的例子，为父元素section声明perspective属性，子元素仍旧围绕Y轴旋转30°，代码如下所示，得到的效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .perspective &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    perspective&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; 200px&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .perspective &amp;gt; div &lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
    transform&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt; rotateY(30deg)&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;perspective&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;200px&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;200px&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200319105518439-915369945.png&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　perspective-origin属性可修改透视原点，也叫消失点，其取值与transform-origin类似。默认情况下，这个点位于元素的中心，接下来修改上例父元素的透视原点，样式如下，效果如下图所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.perspective &lt;/span&gt;{&lt;span&gt;
  perspective-origin&lt;/span&gt;:&lt;span&gt; top left&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200319105611682-448811490.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　backface-visibility属性可控制元素背面朝向用户时是否渲染，利用该属性可设计出3D翻转的特效。接下来会一步步的实现该功能，首先是创建HTML结构，如下所示，section是两个div的父元素。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;section &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;flip&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;positive&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;正面&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;reverse&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;反面&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;section&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后在父元素中添加过渡时间和透视，并将transform-style属性设为preserve-3d，这样才能让子元素和父元素处于同一个三维空间，样式如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.flip &lt;/span&gt;{&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; relative&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 100px&lt;/span&gt;;&lt;span&gt;
  transition&lt;/span&gt;:&lt;span&gt; 0.6s&lt;/span&gt;;&lt;span&gt;
  transform-style&lt;/span&gt;:&lt;span&gt; preserve-3d&lt;/span&gt;;&lt;span&gt;
  perspective&lt;/span&gt;:&lt;span&gt; 1000px&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　再将两个子元素的backface-visibility属性设为hidden，并且将第二个div元素围绕Y轴旋转180°，样式如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.flip &amp;gt; div &lt;/span&gt;{&lt;span&gt;
  position&lt;/span&gt;:&lt;span&gt; absolute&lt;/span&gt;;&lt;span&gt;
  left&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
  top&lt;/span&gt;:&lt;span&gt; 0&lt;/span&gt;;&lt;span&gt;
  width&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  height&lt;/span&gt;:&lt;span&gt; 100%&lt;/span&gt;;&lt;span&gt;
  backface-visibility&lt;/span&gt;:&lt;span&gt; hidden&lt;/span&gt;;
}&lt;span&gt;
.flip .positive &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; #FC0&lt;/span&gt;;
}&lt;span&gt;
.flip .reverse &lt;/span&gt;{&lt;span&gt;
  background&lt;/span&gt;:&lt;span&gt; #F60&lt;/span&gt;;&lt;span&gt;
  transform&lt;/span&gt;:&lt;span&gt; rotateY(180deg)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　最后为父元素定义:hover伪类，也就是在鼠标悬停时，自身也围绕Y轴旋转180°，隐藏第一个div元素，显示第二个div元素，样式如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.flip:hover &lt;/span&gt;{&lt;span&gt;
  transform&lt;/span&gt;:&lt;span&gt; rotateY(180deg)&lt;/span&gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　由于是动态的效果，因此需要用多张图来描绘翻转的过程，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/211606/202003/211606-20200319105800452-1371501816.png&quot; alt=&quot;&quot; width=&quot;800&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Apr 2020 23:08:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>一、粘滞定位 粘滞定位（sticky）与相对定位类似，既不会脱离正常流，也不会改变元素盒类型，并且会保留原先所占的空间。它会相对于包含块偏移，它的包含块分为两种，第一种和绝对定位一样；第二种是最近的滚</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/12519570.html</dc:identifier>
</item>
<item>
<title>深入解读ES6系列（二） - DDDZ</title>
<link>http://www.cnblogs.com/Three-Z/p/12664233.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Three-Z/p/12664233.html</guid>
<description>&lt;ul&gt;&lt;li&gt;哈喽小伙伴们，爱说‘废’话的Z又回来了，欢迎来到Super IT曾的博客时间，上一节说了es6的历史，变量，以及闭包，这一节我们继续我们知识的海洋，一起奋斗不秃头！不足的欢迎提问留言。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200408165341850.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;li&gt;今天一打开CSDN有被惊喜到哈哈被选热门超开心！看来要加更才行，当然注重基础是必须的！那我们继续~&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;箭头函数&quot;&gt;箭头函数&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;总结起来箭头函数也就那么回事儿，说白了就两点：
&lt;ol&gt;&lt;li&gt;如果只有一个参数，&lt;code&gt;()&lt;/code&gt;可以省。&lt;/li&gt;
&lt;li&gt;如果只有一个return，&lt;code&gt;{}&lt;/code&gt; 可以省。&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;好了，箭头函数说完了，我们说下一个...😀，开个玩笑，哈哈，上实例：比如来个数组排序，你先想想数组怎么排序的再看代码&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;       &amp;lt;body&amp;gt;
                &amp;lt;script&amp;gt;
                        let arr=[500,10,66,37,81,10011,999]
                        arr.sort(function(a,b){
                                return a-b;
                        });
                        console.log(arr)
                &amp;lt;/script&amp;gt;
        &amp;lt;/body&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;问我sort是什么的？或者问我为啥return a-b的同学，移步&lt;a href=&quot;https://www.w3school.com.cn/js/jsref_sort.asp&quot;&gt;W3school&lt;/a&gt;补补课，简言之这个就是一个排序函数输出结果如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200408165737558.png&quot; alt=&quot;从小到大排列&quot;/&gt;&lt;br/&gt;那么ES6怎么写呢？第一步去掉function，第二步加=&amp;gt;，就有了这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;arr.sort((a,b) =&amp;gt;{
        return a-b;
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再瞅瞅一个return，去掉{}好嘛？一行代码它不香嘛。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;arr.sort((a,b) =&amp;gt; (a-b));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200408170308747.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;再举一个例子帮你理解，你可以先思考一个函数返回传参的2倍？两行代码搞定。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let show = a =&amp;gt;a*2;
        alert(show(2));
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;函数的参数&quot;&gt;函数的参数&lt;/h2&gt;
&lt;h3 id=&quot;参数扩展展开&quot;&gt;参数扩展/展开&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;参数的扩展是个啥，就&lt;code&gt;...&lt;/code&gt;对就是这三个点平时我们的省略号，这么一想就好理解了，就是把省略号前面的东西说完，省略号就是后面所有的东西，要我说就是也就是所谓的剩余参数。看看下面代码想想输出啥？&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        function show(a,b,...args){
                console.log(a,b,args)
        }
        show(1,{&quot;2 name&quot;:&quot;王&quot;},&quot;string&quot;,234,{&quot;name&quot;:&quot;李&quot;})
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对的，args管你是啥全部装起来放出来就是了，所以就是1.收集，2.展开。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200408232436673.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;同时这里也很好理解，&lt;code&gt;...xxx&lt;/code&gt;要放在最后，毕竟都是省略号了省略的内容肯定在最后啊，这个很好理解，不行你可以试试在后面加参数输出是什么结果，我和你赌一包卫龙辣条，会报错。&lt;/p&gt;
&lt;p&gt;再来个例子帮你加深理解，输出两个数的和要求一个函数处理加法，一个函数用参数扩展接收传过来的值。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;script&amp;gt;
        function show(...args){
                fn(...args);
        }
        function fn(a,b){
                alert(a+b)
        }
        show(2,5);
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200408233431423.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;默认参数&quot;&gt;默认参数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;哇默认参数真的超级简单，但是说了我们是超级基础的！所以还是要写出来看看，我写个代码，你绝对秒懂，老司机你懂的嘿嘿嘿~代码和图放这里，自己品。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        function driveCar(b, y = 5, t = 9){
                console.log(b,y,t)
        }
        driveCar(99,999);
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200408233919569.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;到这里，函数完事儿~&lt;/p&gt;

&lt;h2 id=&quot;敲黑板（总结）：&quot;&gt;敲黑板（总结）：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;为啥每次上来就是总结，因为最精辟最重要的话，直接一巴掌呼的给你，后面给你糖糖，你品你细品，是不是会回味无穷记忆深刻，哈哈，我们继续。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要说解构赋值作重要的就三句话：&lt;br/&gt;1.左右两边结构必须一样&lt;br/&gt;2.右边必须是个东西&lt;br/&gt;3.声明和赋值不能分开（必须在一句话里完成）&lt;/p&gt;
&lt;h2 id=&quot;示例：&quot;&gt;示例：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;先说第一个，有个数组1，2，3，然后打印出每一项，想想之前怎么做？循环遍历？单个赋值打印？来看我的：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let arr = [1,2,3]
        let [a,b,c] = arr
        console.log(a,b,c)
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200408235027788.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;我感觉你懂了一点了，那你看看这个两个分别输出什么？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        // 1
        let {a1,b1,c1} = {a1:&quot;name&quot;, value:&quot;password&quot;, c1:&quot;class&quot; }
        console.log(a1,b1,c1)

        // 2
        let [{a,b},[n1,n2,n3],num,str] = [{a:123, b:&quot;first&quot;},[&quot;n1&quot;,999,{ff:&quot;数组n3&quot;}],17,&quot;string&quot;]
        console.log(a,b,n1,n2,n3,num,str)
        
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020040823542064.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200408235931995.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;怎么样爽不爽，左右两边结构必须一样，这句话有没有领悟了呢？那如果示例2中我不想{a,b},[n1,n2,n3]拆开，想输出一个整的数组或是对象怎么办，一样的道理，你先想想你怎么做，在看我的（不许偷看）。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let [json,arr,num,str] = [{a:123, b:&quot;first&quot;},[&quot;n1&quot;,999,{ff:&quot;数组n3&quot;}],17,&quot;string&quot;]
        console.log(json,arr,num,str)
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409000359474.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这样就输出了！有没有，顺便悄悄告诉你这叫粒度。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;我们来说第二个，右边必须是个东西，什么叫东西...你看这代码输出啥？&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let {a,b} = {12,5}
        console.log(a,b)
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两边结构一样吧但能输出出来才怪了，啥也不是啊哈哈，右边是json格式？key:value来教你做大哥，铁定报错。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409000841782.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;好了第三个来走你，上代码！老规矩先想输出啥。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let [a,b];
        [a,b] = [12,5]
        console.log(a,b)
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三句话怎么说的来着？声明和赋值不能分开，一句话完成。这铁定报错啊，还能单独整咋地？就哦豁报错了嘛。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409001213545.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;解构赋值这三句，完事儿~&lt;/p&gt;

&lt;h2 id=&quot;敲黑板（方法汇总）&quot;&gt;敲黑板（方法汇总）&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;俗称&lt;/th&gt;
&lt;th&gt;解释&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;map&lt;/td&gt;
&lt;td&gt;映射&lt;/td&gt;
&lt;td&gt;一个对一个&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;reduce&lt;/td&gt;
&lt;td&gt;汇总&lt;/td&gt;
&lt;td&gt;一堆出来一个&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;filter&lt;/td&gt;
&lt;td&gt;过滤器&lt;/td&gt;
&lt;td&gt;筛选你要的结果&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;forEach&lt;/td&gt;
&lt;td&gt;循环（迭代）&lt;/td&gt;
&lt;td&gt;item走天下&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;map&quot;&gt;map&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;什么叫一个对一个呢，打个比方就好比一个班的成绩[100,59,60,1]，对应就是[&quot;及格&quot;，“不及格”，“及格”，“不及格”]，哈哈所以考59真的很惨，考60真的很成功，特别是在大学哈哈，好了我们继续。&lt;/li&gt;
&lt;li&gt;想想现在依次alert这四个分数怎么做？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020040900272611.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let arr = [100,59,60,1]
        arr.map((item)=&amp;gt;{
                alert(item)
        })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;*想想alert一次但显示每个分数的两倍怎么做？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409003001356.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let arr = [100,59,60,1]
        let all = arr.map((item)=&amp;gt;{
                return item*2
        })
        alert(all)
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还记得之前的es6说过的嘛？一个return怎么？来优化代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let arr = [100,59,60,1]
        let all = arr.map((item)=&amp;gt;item*2)
        alert(all)
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;那现在不想看分数了，直接alert出来所有的及格不及格怎么搞？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409003434843.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;直接加判断嘛哎，上代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let arr = [100,59,60,1]
        let all = arr.map((item)=&amp;gt;item&amp;gt;59?&quot;及格&quot;:&quot;不及格&quot;)
        alert(all)
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;reduce&quot;&gt;reduce&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一堆出来一个什么个意思呢？就好比你求总数平均数等等，这么一想是不是好理解多了，那这个用来干嘛？商城购物车功能赛~对吧，来先看一段代码，你猜猜输出什么？&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let arr = [100,59,60,1]
        arr.reduce((a,b,c)=&amp;gt;{
                alert(a+','+b+','+c)
        })
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409012848165.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409012859617.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409012911374.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;惊不惊喜，意不意外，我第一次看到的时候也是那种，小朋友你是否有很多问号的感觉，心想？undefined？1,2，3？就算是下标也是从0开始的啊？由于折服于知识的石榴裙下，于是乎我就不得不继续学习了。&lt;/p&gt;
&lt;p&gt;这个reduce是一堆输出一个，小学的累加记得吧，白色就是我们的分数，右边都为中间结果，那这个和我们的reduce有什么关系呢？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409013915972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1oyNjk1NzE2Mjc=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当然有关系，我们reduce的第一个参数a，就是这个中间结果，由于第一次一来没有中间结果，于是就把arr[0]，拿来放到a的位置了也就是100，那么c自然就是从1开始了，那b相当于就是被加数，上一个的累加加的这一个数159+60，那么b就是60，来思考一下，输出总的分数怎么写代码？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409014904840.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let arr = [100,59,60,1]
        let result = arr.reduce((a,b,c)=&amp;gt;{
                console.log(a,b,c)
                return a+b;
        })
        alert(result)
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看控制台，打印的是不是正好就是我们说得这样？那必须啊，说这老半天了。竖着看对应a，b，c。平均数我就不放图了哈直接&lt;code&gt;alert(result/arr.length)&lt;/code&gt;,或者直接alert平均数，那么在上面对c和arr.length做判断if...else就好了。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409015041567.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;filter&quot;&gt;filter&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;过滤器，说到这个很是亲切，因为前面接手的小程序没少用这个东西，可以用来过滤啊格式化格式，我记得我用的最多的就是用它来处理时间，好了废话不多说直接干！&lt;/li&gt;
&lt;li&gt;我们还是用着四个具有代表性的分数来说代码，想想我现在要及格的返回true，不及格的返回false，直接alert出来的只有true的结果，怎么做？&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409020240438.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let arr = [100,59,60,1]
        let result = arr.filter(item=&amp;gt;{
                if(item&amp;gt;59){
                        return true
                }else{
                        return false
                }
        })
        alert(result)
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你觉得完事儿了？不，并没有哈哈哈我是一个懒人不太想写这么多代码，其实你看会发现&lt;code&gt;if(item&amp;gt;59)&lt;/code&gt;本来就返回true和false，那咱也不墨迹了，直接一行搞定不行吗？当然可以。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let arr = [100,59,60,1]
        let result = arr.filter(item=&amp;gt;item&amp;gt;59)
        alert(result)
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是乎简洁的代码就诞生了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最后再来个给你加深印象，看看代码结果是啥，你猜猜？&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let arr = [
                {name:&quot;学霸&quot;, value:&quot;100&quot;},
                {name:&quot;好惨一哥们儿&quot;, value:&quot;59&quot;},
                {name:&quot;运气吊炸天&quot;, value:&quot;60&quot;},
                {name:&quot;学渣&quot;, value:&quot;1&quot;},
        ]
        let result = arr.filter(item=&amp;gt;item.value&amp;gt;59)
        console.log(result)
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409021249733.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;啊，突然觉得学霸和运气王也差不多嘛~大家都及格了&lt;/p&gt;
&lt;h2 id=&quot;foreach&quot;&gt;forEach&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;谈到这个也是要不得不吐槽一下小程序的坑，我记得当时好像是去集合里面找一个记录然后记录里面有一个字段是数组，然后数组里面是还有个数组，每个最里面的数组包含的是json，要去改这个json里面的某一变量的值，哇当时搞了半天的for，同样都是遍历硬是不行，最后forEach教我分分钟做人，几行代码简洁明了，管你里面是什么，一个item把你搜刮的明明白白，好了好了，来看看代码再说其他的：&lt;/li&gt;
&lt;li&gt;现在什么个要求了呢？要你依次弹出四个人的序号，对应名字和分数，怎么搞？&lt;img src=&quot;https://img-blog.csdnimg.cn/20200409022333740.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;script&amp;gt;
        let arr = [
                {name:&quot;学霸&quot;, value:&quot;100&quot;},
                {name:&quot;好惨一哥们儿&quot;, value:&quot;59&quot;},
                {name:&quot;运气吊炸天&quot;, value:&quot;60&quot;},
                {name:&quot;学渣&quot;, value:&quot;1&quot;},
        ]
        arr.forEach((item,index)=&amp;gt;{
                alert(index+&quot;:&quot;+item.name+&quot; &quot;+item.value)
        })
        
&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就完事儿~&lt;br/&gt;———————————————————————分割线——————&lt;br/&gt;下节说字符串，面向对象及之后的内容&lt;/p&gt;
&lt;p&gt;放上我的，主要博客&lt;a href=&quot;https://www.cnblogs.com/Three-Z&quot;&gt;博客园&lt;/a&gt;，&lt;a href=&quot;https://blog.csdn.net/Z269571627&quot;&gt;CSDN&lt;/a&gt;，&lt;a href=&quot;https://github.com/269571627/MyGit/tree/web&quot;&gt;GitHub&lt;/a&gt;，&lt;a href=&quot;http://pipe.b3log.org/blogs/DDDZ&quot;&gt;pipe&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Apr 2020 18:33:00 +0000</pubDate>
<dc:creator>DDDZ</dc:creator>
<og:description>ES6函数 哈喽小伙伴们，爱说‘废’话的Z又回来了，欢迎来到Super IT曾的博客时间，上一节说了es6的历史，变量，以及闭包，这一节我们继续我们知识的海洋，一起奋斗不秃头！不足的欢迎提问留言。 今</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Three-Z/p/12664233.html</dc:identifier>
</item>
<item>
<title>玩转控件:封装Dev的SearchLookupEdit - [Stephen-kzx]</title>
<link>http://www.cnblogs.com/axing/p/12664139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/axing/p/12664139.html</guid>
<description>
&lt;p&gt;&lt;span&gt;&lt;strong&gt;鸣谢&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        随着前面几个章节对控件封装与扩展的分享，不少小伙伴儿们在作者公众号上反馈，并联系作者，表示通过这些系列和源码能学到不少细节上的东西，并运用到了自己的实际项目当中，也有不少伙伴儿反馈更好更优的处理方式。作者在此感谢大家的陪伴与探讨，希望能与大家一起学习，一起进步。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;工欲善其事必先利其器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        公众号反馈最多的是《玩转控件:封装Dev的LabelControl和TextEdit》，表示运用到自己实际项目后，确实大大减少了自己的工作量，并希望能有更多这种类型的博文。为了满足小伙伴儿的心愿，作者后续会分享更多自己实际项目运用到的小技巧，希望能对更多小伙伴儿有更多的帮助和启发。最后，也希望小伙伴儿们能从作者分享对不同类型控件的封装中举一反三，扩展满足自己实际业务的插件。有好的想法，别忘记分享给作者哦，三人行，必有我师嘛~&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;Talk is Cheap&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;          废话不多说，今天作者要分享的也是作者实际项目中遇到的问题——有数据源的下拉搜索框。不少大的企业反馈，公司职员比较多，数据量比较大，鼠标下拉寻找太过繁琐和耗时，能不能提供个更优的处理方式。经过作者一番思索，以迅雷不及掩耳盗铃响叮当之势就找到了符合客户的处理方式——就是Dev的SearchLookupEdit。&lt;/p&gt;
&lt;p&gt;          大家也可以直接用Dev的SearchLookupEdit控件，效果还不错，当然为了方便起见，减少自己的操作量，也可以模仿《玩转控件:封装Dev的LabelControl和TextEdit》一样，自己根据实际情况做个封装，来吧！作者陪大家一起重温下封装的乐趣。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong data-brushtype=&quot;text&quot;&gt;Show me the Code&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　和往常一样，新建一个类用来封装和扩展自己实际要用到的属性和事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;partial&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; KzxSearchComboboxEdit : KzxBaseControl
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        初始化的时候，就可以封装好自己要用到的事件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; KzxSearchComboboxEdit()
    {
        InitializeComponent();

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ValueControl.QueryPopUp += &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancelEventHandler(lookUpEdit_QueryPopUp);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ValueControl.Closed += &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClosedEventHandler(lookUpEdit_Closed);

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CaptionControl.AutoSizeMode =&lt;span&gt; LabelAutoSizeMode.Vertical;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CaptionControl.SizeChanged += &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventHandler(SetSize);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ValueControl.Enter -= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventHandler(ValueControl_Enter);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ValueControl.Enter += &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventHandler(ValueControl_Enter);

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._SearchLookUpEditView.FocusRectStyle =&lt;span&gt; DevExpress.XtraGrid.Views.Grid.DrawFocusRectStyle.RowFocus;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._SearchLookUpEditView.Name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;gridLookUpEdit1View&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._SearchLookUpEditView.OptionsSelection.EnableAppearanceFocusedCell = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._SearchLookUpEditView.OptionsView.ShowGroupPanel = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ValueControl.Properties.PopupFormSize = &lt;span&gt;new&lt;/span&gt; System.Drawing.Size((&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;this&lt;/span&gt;.ValueControl.Width * &lt;span&gt;2&lt;/span&gt;), (&lt;span&gt;int&lt;/span&gt;)(&lt;span&gt;this&lt;/span&gt;.ValueControl.Width * &lt;span&gt;1.5&lt;/span&gt;&lt;span&gt;));

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.DesignMode == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Size = &lt;span&gt;new&lt;/span&gt; Size(&lt;span&gt;284&lt;/span&gt;, &lt;span&gt;21&lt;/span&gt;&lt;span&gt;);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        把自己实际需要用到的属性做好封装，举个栗子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _ItemIndex = -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
  &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 选中项的下标
  &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
  [Category(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;自定义&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Description(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ItemIndex,选中项的下标&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Browsable(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
  [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
  [McDisplayName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ItemIndex&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; ItemIndex
  {
      &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
      {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._ItemIndex;
      }
      &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;
      {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._ItemIndex =&lt;span&gt; value;
      }
  }
  
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DataRow _CurrentItem = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
  &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 选中项的DataRow对象
  &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
  [Category(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;自定义&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Description(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentItem,选中项的DataRow对象&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Browsable(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
  [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
  [McDisplayName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CurrentItem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataRow CurrentItem
  {
      &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
      {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._CurrentItem;
      }
      &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;
      {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._CurrentItem =&lt;span&gt; value;
      }
  }
  
  
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; DataSet _BillDataSet = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataSet();
  &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
  &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 单据的数据源
  &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
  [Category(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;自定义&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Description(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BillDataSet,单据的数据源&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Browsable(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
  [DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
  [McDisplayName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BillDataSet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; DataSet BillDataSet
  {
      &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
      {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._BillDataSet;
      }
      &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
      {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._BillDataSet =&lt;span&gt; value;
      }
  }
  
  &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
  &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 没有多语言的情况下的默认显示标题
  &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
  [Category(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;多语言&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Description(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DesigeCaption,没有多语言的情况下的默认显示标题&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Browsable(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
  [McDisplayName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DesigeCaption&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; DesigeCaption
  {
      &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
      {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CaptionControl.Text.Trim();
      }
      &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
      {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.CaptionControl.Text =&lt;span&gt; value;
      }
  }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        也可以根据自己喜好（当然是符合客户习惯的），画蛇添足：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; _IsNull = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
  &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 可空性
  &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
  [Category(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;验证&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Description(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IsNull,可空性&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;), Browsable(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)]
  [McDisplayName(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;IsNull&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; IsNull
  {
      &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;
      {
          SetBackColor();
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._IsNull;
      }
      &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;
      {
          &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._IsNull =&lt;span&gt; value;
          SetBackColor();
      }
  }
  ...
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置背景色
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; SetBackColor()
    {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.ValueControl.Properties.ReadOnly == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ValueControl.BackColor = Color.FromArgb(&lt;span&gt;242&lt;/span&gt;, &lt;span&gt;242&lt;/span&gt;, &lt;span&gt;243&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;._IsNull.Equals(&lt;span&gt;true&lt;/span&gt;) == &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ValueControl.BackColor =&lt;span&gt; Color.Yellow;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ValueControl.BackColor = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._TextBackColor;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;        当设置控件必填的时候，设置控件的背景色用于区分，具体效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/116076/202004/116076-20200409005444729-1864931839.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        封装好控件取值，填充值的方法，以及控件数据源绑定的方法（具体根据自己实际项目应用为准，此处只是举个栗子）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 取控件的值
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;return&amp;gt;&lt;/span&gt;&lt;span&gt;Object&lt;/span&gt;&lt;span&gt;&amp;lt;/return&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; GetValue()
{
    DataRowView rowview &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    BindingSource bs &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;object&lt;/span&gt; v = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

    v &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.ValueControl.EditValue == &lt;span&gt;null&lt;/span&gt; || &lt;span&gt;this&lt;/span&gt;.ValueControl.EditValue == DBNull.Value ? &lt;span&gt;string&lt;/span&gt;.Empty : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.ValueControl.EditValue.ToString();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; v;
}

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置控件的值
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;控件的值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;return&amp;gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;&amp;lt;/return&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SetValue(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; value)
{
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ValueControl.EditValue = value == &lt;span&gt;null&lt;/span&gt; || value == DBNull.Value ? &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.Empty : value;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}


&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置数据绑定
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;binding&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;数据绑定对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;return&amp;gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;&amp;lt;/return&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SetDataBinding(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; binding)
{
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.BindingObject = &lt;span&gt;this&lt;/span&gt;.ValueControl.DataBindings.Add(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EditValue&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, binding, &lt;span&gt;this&lt;/span&gt;.Field, &lt;span&gt;true&lt;/span&gt;, DataSourceUpdateMode.OnValidation, &lt;span&gt;string&lt;/span&gt;.Empty, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.FormatString);
    SetColumnDisplayFormat();
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (binding &lt;span&gt;is&lt;/span&gt;&lt;span&gt; BindingSource)
    {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; maxlength = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (((BindingSource)binding).DataSource &lt;span&gt;is&lt;/span&gt;&lt;span&gt; DataView)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (((DataView)(((BindingSource)binding).DataSource)).Table.Columns[&lt;span&gt;this&lt;/span&gt;.Field].DataType == &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;))
            {
                maxlength &lt;/span&gt;= ((DataView)(((BindingSource)binding).DataSource)).Table.Columns[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Field].MaxLength;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (maxlength &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.MaxLength =&lt;span&gt; maxlength;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (((BindingSource)binding).DataSource &lt;span&gt;is&lt;/span&gt;&lt;span&gt; DataTable)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (((DataTable)(((BindingSource)binding).DataSource)).Columns[&lt;span&gt;this&lt;/span&gt;.Field].DataType == &lt;span&gt;typeof&lt;/span&gt;(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;))
            {
                maxlength &lt;/span&gt;= ((DataTable)(((BindingSource)binding).DataSource)).Columns[&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.Field].MaxLength;
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (maxlength &amp;gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.MaxLength =&lt;span&gt; maxlength;
                }
            }
        }
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}

&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设置下拉框的数据源
&lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;binding&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;下拉框的数据源&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;displayMember&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;显示值字段名&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;valueMember&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;实际值字段名&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; SetSourceTableBinding(&lt;span&gt;object&lt;/span&gt; binding, &lt;span&gt;string&lt;/span&gt; displayMember, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; valueMember)
{
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.DisplayMemberPath =&lt;span&gt; displayMember;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.SelectedValuePath =&lt;span&gt; valueMember;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ValueControl.Properties.DataSource =&lt;span&gt; binding;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._ResourceDataSource =&lt;span&gt; binding;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       完成！为测试效果，在窗体Load事件中造个测试数据，看看效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
DataTable dataTable = &lt;span&gt;new&lt;/span&gt; DataTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Student&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;); 
dataTable.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;编号&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(String));
dataTable.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;昵称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(String));
dataTable.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(String)); 
dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;James&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mary&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;李四&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;王五&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;joy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;赵六&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jay&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;钱七&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;});
dataTable.Rows.Add(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; String[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stephen&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;康忠鑫&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;});

kzxSearchCbbeSupperStar.SetSourceTableBinding(dataTable, &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;名称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;昵称&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/116076/202004/116076-20200409005538494-1523177201.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       和原始Dev控件一样，支持筛选功能，妈妈再也不用担心客户反馈因数据量大的问题查找不便了！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/116076/202004/116076-20200409005552744-874272613.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/116076/202004/116076-20200409005559139-947798336.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/116076/202004/116076-20200409005605209-399468764.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;结束语&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        由于后续所有重写/重绘控件都在同一个项目使用，而且Dev系统引用文件较多，压缩后源码文件仍然很大，如果有需要源码的朋友，可以微信公众号联系博主，源码可以免费赠予~！有疑问的也可以CALL我一起探讨。&lt;/p&gt;
&lt;p&gt;        最后，感谢您的耐心陪伴！如果觉得本篇博文对您或者身边朋友有帮助的，麻烦点个关注！赠人玫瑰，手留余香，您的支持就是我写作最大的动力，感谢您的关注，期待和您一起探讨！再会！&lt;/p&gt;
</description>
<pubDate>Wed, 08 Apr 2020 16:57:00 +0000</pubDate>
<dc:creator>[Stephen-kzx]</dc:creator>
<og:description>鸣谢 随着前面几个章节对控件封装与扩展的分享，不少小伙伴儿们在作者公众号上反馈，并联系作者，表示通过这些系列和源码能学到不少细节上的东西，并运用到了自己的实际项目当中，也有不少伙伴儿反馈更好更优的处理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/axing/p/12664139.html</dc:identifier>
</item>
<item>
<title>Bitmap之位图采样和内存计算详解 - 躬行之</title>
<link>http://www.cnblogs.com/jzmanu/p/12664096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jzmanu/p/12664096.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;原文首发于微信公众号：躬行之(jzman-blog)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Android 开发中经常考虑的一个问题就是 OOM(Out Of Memory)，也就是内存溢出，一方面大量加载图片时有可能出现 OOM， 通过采样压缩图片可避免 OOM，另一方面，如一张 1024 x 768 像素的图像被缩略显示在 128 x 96 的 ImageView 中，这种做法显然是不值得的，可通过采样加载一个合适的缩小版本到内存中，以减小内存的消耗，Bitmap 的优化主要有两个方面如下，一是有效的处理较大的位图，二是位图的缓存，其中位图缓存对应文章如下：&lt;/p&gt;
&lt;p&gt;这篇文章主要侧重于如何有效的处理较大的位图。&lt;/p&gt;
&lt;p&gt;此外，在 Android 中按照位图采样的方法加载一个缩小版本到内存中应该考虑因素？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;估计加载完整图像所需要的内存&lt;/li&gt;
&lt;li&gt;加载这个图片所需的空间带给其程序的其他内存需求&lt;/li&gt;
&lt;li&gt;加载图片的目标 ImageView 或 UI 组件的尺寸&lt;/li&gt;
&lt;li&gt;当前设备的屏幕尺寸或密度&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;位图采样&quot;&gt;位图采样&lt;/h3&gt;
&lt;p&gt;图像有不同的形状的和大小，读取较大的图片时会耗费内存。读取一个位图的尺寸和类型，为了从多种资源创建一个位图，BitmapFactory 类提供了许多解码的方法，根据图像数据资源选择最合适的解码方法，这些方法试图请求分配内存来构造位图，因此很容易导致 OOM 异常。每种类型的解码方法都有额外的特征可以让你通过 BitMapFactory.Options 类指定解码选项。当解码时设置 inJustDecodeBounds 为true，可在不分配内存之前读取图像的尺寸和类型，下面的代码实现了简单的位图采样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
  * 位图采样
  * @param res
  * @param resId
  * @return
  */
public Bitmap decodeSampleFromResource(Resources res, int resId){
    //BitmapFactory创建设置选项
    BitmapFactory.Options options = new BitmapFactory.Options();
    //设置采样比例
    options.inSampleSize = 200;
    Bitmap bitmap = BitmapFactory.decodeResource(res,resId,options);
    return bitmap;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;注意&lt;/em&gt;：其他 decode... 方法与 decodeResource 类似，这里都以 decodeRedource 为例。&lt;/p&gt;
&lt;p&gt;实际使用时，必须根据具体的宽高要求计算合适的 inSampleSize 来进行位图的采样，比如，将一个分辨率为 2048 x 1536 的图像使用 inSampleSize 值为 4 去编码产生一个 512 x 384 的图像，这里假设位图配置为 ARGB_8888，加载到内存中仅仅是 0.75M 而不是原来的 12M，关于图像所占内存的计算将在下文中介绍，下面是根据所需宽高进行计算采样比例的计算方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 1.计算位图采样比例
 *
 * @param option
 * @param reqWidth
 * @param reqHeight
 * @return
 */
public int calculateSampleSize(BitmapFactory.Options option, int reqWidth, int reqHeight) {
    //获得图片的原宽高
    int width = option.outWidth;
    int height = option.outHeight;

    int inSampleSize = 1;
    if (width &amp;gt; reqWidth || height &amp;gt; reqHeight) {
        if (width &amp;gt; height) {
            inSampleSize = Math.round((float) height / (float) reqHeight);
        } else {
            inSampleSize = Math.round((float) width / (float) reqWidth);
        }
    }
    return inSampleSize;
}

/**
 * 2.计算位图采样比例
 * @param options
 * @param reqWidth
 * @param reqHeight
 * @return
 */
public int calculateSampleSize1(BitmapFactory.Options options, int reqWidth, int reqHeight) {

    //获得图片的原宽高
    int height = options.outHeight;
    int width = options.outWidth;

    int inSampleSize = 1;
    if (height &amp;gt; reqHeight || width &amp;gt; reqWidth) {
        // 计算出实际宽高和目标宽高的比率
        final int heightRatio = Math.round((float) height / (float) reqHeight);
        final int widthRatio = Math.round((float) width / (float) reqWidth);
        /**
         * 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高
         * 一定都会大于等于目标的宽和高。
         */
        inSampleSize = heightRatio &amp;lt; widthRatio ? heightRatio : widthRatio;
    }
    return inSampleSize;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;获得采样比例之后就可以根据所需宽高处理较大的图片了，下面是根据所需宽高计算出来的 inSampleSize 对较大位图进行采样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 位图采样
 * @param resources
 * @param resId
 * @param reqWidth
 * @param reqHeight
 * @return
 */
public Bitmap decodeSampleFromBitmap(Resources resources, int resId, int reqWidth, int reqHeight) {
    //创建一个位图工厂的设置选项
    BitmapFactory.Options options = new BitmapFactory.Options();
    //设置该属性为true,解码时只能获取width、height、mimeType
    options.inJustDecodeBounds = true;
    //解码
    BitmapFactory.decodeResource(resources, resId, options);
    //计算采样比例
    int inSampleSize = options.inSampleSize = calculateSampleSize(options, reqWidth, reqHeight);
    //设置该属性为false，实现真正解码
    options.inJustDecodeBounds = false;
    //解码
    Bitmap bitmap = BitmapFactory.decodeResource(resources, resId, options);
    return bitmap;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在解码过程中使用了 BitmapFactory.decodeResource() 方法，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 解码指定id的资源文件
 */
public static Bitmap decodeResource(Resources res, int id, BitmapFactory.Options opts) {
    ...
    /**
     * 根据指定的id打开数据流读取资源，同时为TypeValue进行复制获取原始资源的density等信息
     * 如果图片在drawable-xxhdpi，那么density为480dpi
     */
    is = res.openRawResource(id, value);
    //从输入流解码出一个Bitmap对象，以便根据opts缩放相应的位图
    bm = decodeResourceStream(res, value, is, null, opts);
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然真正解码的方法应该是 decodeResourceStream() 方法，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 从输入流中解码出一个Bitmap，并对该Bitmap进行相应的缩放
 */
public static Bitmap decodeResourceStream(Resources res, TypedValue value,
                     InputStream is, Rect pad, BitmapFactory.Options opts) {

    if (opts == null) {
        //创建一个默认的Option对象
        opts = new BitmapFactory.Options();
    }

    /**
     * 如果设置了inDensity的值，则按照设置的inDensity来计算
     * 否则将资源文件夹所表示的density设置inDensity
     */
    if (opts.inDensity == 0 &amp;amp;&amp;amp; value != null) {
        final int density = value.density;
        if (density == TypedValue.DENSITY_DEFAULT) {
            opts.inDensity = DisplayMetrics.DENSITY_DEFAULT;
        } else if (density != TypedValue.DENSITY_NONE) {
            opts.inDensity = density;
        }
    }

    /**
     * 同理，也可以通过BitmapFactory.Option对象设置inTargetDensity
     * inTargetDensity 表示densityDpi，也就是手机的density
     * 使用DisplayMetrics对象.densityDpi获得
     */
    if (opts.inTargetDensity == 0 &amp;amp;&amp;amp; res != null) {
        opts.inTargetDensity = res.getDisplayMetrics().densityDpi;
    }
    //decodeStream()方法中调用了native方法
    return decodeStream(is, pad, opts);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;设置完 inDensity 和 inTargetDensity 之后调用了 decodeStream() 方法，该方法返回完全解码后的 Bitmap 对象，具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * 返回解码后的Bitmap,
 */
public static Bitmap decodeStream(InputStream is, Rect outPadding, BitmapFactory.Options opts) {
    ...
    bm = nativeDecodeAsset(asset, outPadding, opts);
    //调用了native方法：nativeDecodeStream(is, tempStorage, outPadding, opts);
    bm = decodeStreamInternal(is, outPadding, opts);
    Set the newly decoded bitmap's density based on the Options
    //根据Options设置最新解码的Bitmap
    setDensityFromOptions(bm, opts);
    ...
    return bm;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;显然，decodeStream() 方法主要调用了本地方法完成 Bitmap 的解码，跟踪源码发现 nativeDecodeAsset() 和 nativeDecodeStream() 方法都调用了 dodecode() 方法，doDecode 方法关键代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * BitmapFactory.cpp 源码
 */
static jobject doDecode(JNIEnv*env, SkStreamRewindable*stream, jobject padding, jobject options) {
    ...
    if (env -&amp;gt; GetBooleanField(options, gOptions_scaledFieldID)) {
        const int density = env -&amp;gt; GetIntField(options, gOptions_densityFieldID);
        const int targetDensity = env -&amp;gt; GetIntField(options, gOptions_targetDensityFieldID);
        const int screenDensity = env -&amp;gt; GetIntField(options, gOptions_screenDensityFieldID);
        if (density != 0 &amp;amp;&amp;amp; targetDensity != 0 &amp;amp;&amp;amp; density != screenDensity) {
            //计算缩放比例
            scale = (float) targetDensity / density;
        }
    }
    ...
    //原始Bitmap
    SkBitmap decodingBitmap;
    ...

    //原始位图的宽高
    int scaledWidth = decodingBitmap.width();
    int scaledHeight = decodingBitmap.height();

    //综合density和targetDensity计算最终宽高
    if (willScale &amp;amp;&amp;amp; decodeMode != SkImageDecoder::kDecodeBounds_Mode) {
        scaledWidth = int(scaledWidth * scale + 0.5f);
        scaledHeight = int(scaledHeight * scale + 0.5f);
    }
    ...
    //x、y方向上的缩放比例，大概与scale相等
    const float sx = scaledWidth / float(decodingBitmap.width());
    const float sy = scaledHeight / float(decodingBitmap.height());
    ...
    //将canvas放大scale，然后绘制Bitmap
    SkCanvas canvas (outputBitmap);
    canvas.scale(sx, sy);
    canvas.drawARGB(0x00, 0x00, 0x00, 0x00);
    canvas.drawBitmap(decodingBitmap, 0.0f, 0.0f, &amp;amp; paint);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码能看到缩放比例的计算，以及 density 与 targetDensity 对 Bitmap 宽高的影响，实际上间接影响了 Bitmap 在所占内存的大小，这个问题会在下文中举例说明，注意 density 与当前 Bitmap 所对应资源文件（图片）的目录有关，如有一张图片位于 drawable-xxhdpi 目录中，其对应的 Bitmap 的 density 为 480dpi，而 targetDensity 就是 DisPlayMetric 的 densityDpi，也就是手机屏幕代表的 density。那么怎么查看 Android 中本地的 native 方法的实现呢，链接如下：&lt;br/&gt;&lt;a href=&quot;http://androidxref.com/6.0.0_r1/xref/frameworks/base/core/jni/android/graphics/BitmapFactory.cpp#200&quot;&gt;BitmapFactory.cpp&lt;/a&gt;，直接搜索 native 方法的方法名即可，可以试一下咯。&lt;/p&gt;
&lt;h3 id=&quot;bitmap-内存计算&quot;&gt;Bitmap 内存计算&lt;/h3&gt;
&lt;p&gt;首先贡献一张大图 6000 x 4000 ,图片接近 12M，【可在公众号零点小筑索要】 当直接加载这张图片到内存中肯定会发生 OOM，当然通过适当的位图采样缩小图片可避免 OOM，那么 Bitmap 所占内存又如何计算呢，一般情况下这样计算：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-math&quot;&gt;Bitmap Memory = widthPix * heightPix * 4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可使用 bitmap.getConfig() 获取 Bitmap 的格式，这里是 ARGB_8888 ，这种 Bitmap 格式下一个像素点占 4 个字节，所以要 x 4，如果将图片放置在 Android 的资源文件夹中，计算方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-math&quot;&gt;scale = targetDensity / density
widthPix = originalWidth * scale
heightPix = orignalHeight * scale
Bitmap Memory = widthPix * scale * heightPix * scale * 4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述简单总结了一下 Bitmap 所占内存的计算方式，验证时可使用如下方法获取 Bitmap 所占内存大小：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-math&quot;&gt;BitmapMemory = bitmap.getByteCount()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于选择的这张图片直接加载会导致 OOM，所以下文的事例中都是先采样压缩，然后在进行 Bitmap 所占内存的计算。&lt;/p&gt;
&lt;h4 id=&quot;直接采样&quot;&gt;直接采样&lt;/h4&gt;
&lt;p&gt;这种方式就是直接指定采样比例 inSampleSize 的值，然后先采样然后计算采样后的内存，这里指定 inSampleSize 为200。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将该图片放在 drawable-xxhdpi 目录中，此时 drawable-xxhdpi 所代表的 density 为 480(density)，我的手机屏幕所代表的 density 是 480(targetDensity)，显然，此时 scale 为1，当然首先对图片进行采样，然后将图片加载到内存中， 此时 Bitmap 所占内存内存为：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-math&quot;&gt;inSampleSize = 200
scale = targetDensity / density} = 480 / 480 = 1
widthPix = orignalScale * scale = 6000 / 200 * 1 = 30 
heightPix = orignalHeight * scale = 4000 / 200 * 1 = 20
Bitmap Memory =  widthPix * heightPix * 4 = 30 * 20 * 4 = 2400(Byte)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;将图片放在 drawable-xhdpi 目录中，此时 drawable-xhdpi 所代表的 density 为 320，我的手机屏幕所代表的 density 是 480(targetDensity)，将图片加载到内存中，此时 Bitmap 所代表的内存为：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-math&quot;&gt;inSampleSize = 200
scale = targetDensity / density = 480 / 320
widthPix = orignalWidth * scale = 6000 / 200 * scale = 45
heightPix = orignalHeight * scale = 4000 / 200 * 480 / 320 = 30
Bitmap Memory =  widthPix * scale * heightPix * scale * 4 = 45 * 30 * 4 = 5400(Byte) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;计算采样&quot;&gt;计算采样&lt;/h4&gt;
&lt;p&gt;这种方式就是根据请求的宽高计算合适的 inSampleSize，而不是随意指定 inSampleSize，实际开发中这种方式最常用，这里请求宽高为100x100，具体 inSampleSize 计算在上文中已经说明。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将图片放在 drawable-xxhdpi 目录中，此时 drawable-xxhdpi 所代表的 density 为 480，我的手机屏幕所代表的 density 是 480(targetDensity)，将图片加载到内存中，此时 Bitmap 所代表的内存为：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-math&quot;&gt;inSampleSize = 4000 / 100 = 40
scale = targetDensity / density = 480 / 480 = 1
widthPix = orignalWidth * scale = 6000 / 40 * 1 = 150      
heightPix = orignalHeight * scale = 4000 / 40 * 1 = 100
BitmapMemory = widthPix * scale * heightPix * scale * 4 = 60000(Byte)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;将图片放在 drawable-xhdpi 目录中，此时 drawable-xhdpi 所代表的 density 为 320，我的手机屏幕所代表的 density 是 480(targetDensity)，将图片加载到内存中，此时 Bitmap 所代表的内存为：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-math&quot;&gt;inSampleSize = 4000 / 100 = 40
scale = targetDensity / density = 480 / 320
widthPix = orignalWidth * scale = 6000 / 40 * scale = 225
heightPix = orignalHeight * scale = 4000 / 40 * scale = 150
BitmapMemory = widthPix * heightPix * 4 = 225 * 150 * 4 = 135000(Byte)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;位图采样及 Bitmap 在不同情况下所占内存的计算大概过程如上所述。&lt;/p&gt;
&lt;h3 id=&quot;测试效果&quot;&gt;测试效果&lt;/h3&gt;
&lt;p&gt;测试效果图参考如下：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;drawable-xhdpi&lt;/th&gt;
&lt;th&gt;drawable-xxhdpi&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/758808/202004/758808-20200409002717534-1937264020.png&quot; alt=&quot;&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/758808/202004/758808-20200409002731222-574185981.png&quot; alt=&quot;&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果感兴趣，可以关注公众号：jzman-blog，一起交流学习。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/758808/202004/758808-20200409002615460-1245530996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 08 Apr 2020 16:31:00 +0000</pubDate>
<dc:creator>躬行之</dc:creator>
<og:description>原文首发于微信公众号：躬行之(jzman blog) Android 开发中经常考虑的一个问题就是 OOM(Out Of Memory)，也就是内存溢出，一方面大量加载图片时有可能出现 OOM， 通过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jzmanu/p/12664096.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 WebGL 的楼宇智能化集成系统（二） - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/12664019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/12664019.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/202002/1496396-20200225200053329-1065733339.jpg&quot; class=&quot;desc_img&quot;/&gt; 一套完整的可视化操作交互上，必不可少 2D/3D 的融合，在上期我们介绍了有关 3D 场景的环视漫游、巡视漫游以及动画效果，还包括了冷站场景、热站场景以及智慧末端的实现原理，本期主要介绍关于 2D 图纸面板的动画效果以及面板视频的嵌入。通过 2D/3D 融合的体验，达成场景数据可视化的直观体现以及面板动画交互体验的舒适体验。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;135.62091672046&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      一套完整的可视化操作交互上，必不可少 2D/3D 的融合，在上期我们介绍了有关 3D 场景的环视漫游、巡视漫游以及动画效果，还包括了冷站场景、热站场景以及智慧末端的实现原理，本期主要介绍关于 2D 图纸面板的动画效果以及面板视频的嵌入。通过 2D/3D 融合的体验，达成场景数据可视化的直观体现以及面板动画交互体验的舒适体验。&lt;/p&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;界面简介及效果预览&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;2D 面板缩放的动画切换过渡效果&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      主要通过加载图纸后缩放动画展示面板以及冷站场景和热站场景之间的切换，通过 2D 面板缩放的动画切换过渡效果来实现这一效果。&lt;/p&gt;
&lt;p&gt;加载图纸后缩放动画展示面板效果：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/202002/1496396-20200226000517708-20218675.gif&quot; alt=&quot;&quot; width=&quot;824&quot; height=&quot;408&quot;/&gt;&lt;/div&gt;

&lt;p&gt;      冷站场景和热站场景之间的切换效果：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/202002/1496396-20200226002150947-433427345.gif&quot; alt=&quot;&quot; width=&quot;821&quot; height=&quot;406&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;进度条展示效果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      在交互体验上，使得进度条的增减视效上有一种平滑的动画效果。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/202002/1496396-20200226001614372-920330029.gif&quot; alt=&quot;&quot;/&gt; &lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/202002/1496396-20200226001627114-948350803.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;视频嵌入效果&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      在智慧末端设备场景中点击摄像头交互后，弹出改设备场景的监控信息画面。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200405050103662-2082930263.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;一、 2D 面板缩放的动画切换过渡效果实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      面板缩放的动画切换过渡效果主要是通过设置该图元锚点固定到要缩放的一方，然后通过控制该图元的缩放值来实现缩放效果，图元里的字体则是通过透明度的变化来实现渐变呈现的效果。以下通过标题的缩放动画来讲解实现的方法。&lt;/p&gt;
&lt;p&gt;      首先将标题锚点设置为居中，即横锚点和纵锚点都为0：&lt;/p&gt;
&lt;div readability=&quot;30.385982732351&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
tittle.setAnchor(x, y | {x:0.5,y:0.5})
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       此时的标题图元就会达到锚点居中的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/202002/1496396-20200225204723307-600438842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      而此时我们只需把标题的横缩放值设置为0，而后再通过 HT 的动画对标题缩放值进行动画缩放，再通过动画改变标题名字的透明度，就会达到一种面板缩放的动画切换过渡效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
tittle.scaleX(0);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/202002/1496396-20200226164959739-361726128.gif&quot; alt=&quot;&quot; width=&quot;1141&quot; height=&quot;74&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      动画的实现主要还是通过 &lt;strong&gt;HT&lt;/strong&gt; 自带的 &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/beginners/ht-beginners-guide.html?search=ht.Default.startAnim&amp;amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0&quot; target=&quot;_blank&quot;&gt;ht.Default.startAnim&lt;/a&gt; &lt;code&gt;动画&lt;/code&gt;函数，支持 Frame-Based 和 Time-Based 两种方式的动画。这里的实现采用了 Time-Based 的动画方式，当中的 esting 参数是用于让用户定义函数，通过数学公式控制动画， 如匀速变化、先慢后快等效果，可参考&lt;a href=&quot;http://easings.net/&quot;&gt;http://easings.net/&lt;/a&gt;，本案例是采用的先慢后快的实现方式。&lt;/p&gt;
&lt;p&gt;      而具体的实现伪代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 标题动画
&lt;span data-mce-=&quot;&quot;&gt;tittleAnim() {
    const self = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;;
    const g2d =&lt;span data-mce-=&quot;&quot;&gt; self.g2d;
    const g2dDm =&lt;span data-mce-=&quot;&quot;&gt; g2d.dm();
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取标题图元的横缩放值
    let tittle_index = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.tittle.getScaleX();
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 缩放值动画执行入口
&lt;span data-mce-=&quot;&quot;&gt;    ht.Default.startAnim({
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 动画时间
        duration: 300&lt;span data-mce-=&quot;&quot;&gt;,
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 调用 Easing.js 里面 swing 的动画效果
&lt;span data-mce-=&quot;&quot;&gt;        easing: Easing.swing,
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 动画执行内容
        action: (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过修改标题横缩放值来实现动画效果
            &lt;span data-mce-=&quot;&quot;&gt;this.tittle.setScaleX(tittle_index + (1 - tittle_index) *&lt;span data-mce-=&quot;&quot;&gt; v);
        },
        finishFunc: () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 缩放值动画结束后执行标题名字透明度渐变显示动画
&lt;span data-mce-=&quot;&quot;&gt;            ht.Default.startAnim({
                duration: 1000&lt;span data-mce-=&quot;&quot;&gt;,
                easing: Easing.swing,
                action: (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过修改标题名字透明度来实现动画效果
                    &lt;span data-mce-=&quot;&quot;&gt;this.tittleName.eachChild(c =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                        c.s('opacity', c.s('opacity') + (1 - c.s('opacity')) *&lt;span data-mce-=&quot;&quot;&gt; v);
                    });
                },
                finishFunc: () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 结束后调用执行下一个缩放值动画以及字体透明度动画
&lt;span data-mce-=&quot;&quot;&gt;                }
            });
        }
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      Easing.js 是自己封装的动画效果，如 swing 是由慢到快的摆动动画效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const Easing =&lt;span data-mce-=&quot;&quot;&gt; {
    swing: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; (t) {
        &lt;span data-mce-=&quot;&quot;&gt;return ( -Math.cos(t * PI) / 2 ) + 0.5&lt;span data-mce-=&quot;&quot;&gt;;
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;二、进度条展示效果的实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过封装了一个 setValueWithAnimation 的进度条动画，主要通过参数 (node, name, value, format)：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;node：为进度条图元结点；&lt;/li&gt;
&lt;li&gt;name：传入的参数为进度条图元结点的属性名，一般为需要改变的进度值 precent, 取值范围为0~1；&lt;/li&gt;
&lt;li&gt;value：根据传入的 name, 去改变对应的数值；&lt;/li&gt;
&lt;li&gt;format：如有格式，则可改变新数值的格式；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;主要的实现方法还是采用 &lt;strong&gt;HT&lt;/strong&gt; 的 &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/beginners/ht-beginners-guide.html?search=ht.Default.startAnim&amp;amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0&quot; target=&quot;_blank&quot;&gt;ht.Default.startAnim&lt;/a&gt; &lt;code&gt;动画&lt;/code&gt;函数，来实现新值 newValue 与旧值 oldValue 的差额range 动画实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;setValueWithAnimation(node, name, value, format) {
    let oldValue =&lt;span data-mce-=&quot;&quot;&gt; node.a(name);
    value *= 1&lt;span data-mce-=&quot;&quot;&gt;;
    let range = value -&lt;span data-mce-=&quot;&quot;&gt; oldValue;

    ht.Default.startAnim({
        duration: 1000&lt;span data-mce-=&quot;&quot;&gt;,
        easing: Easing.easeOutStrong,
        action: (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            let newValue = oldValue + range *&lt;span data-mce-=&quot;&quot;&gt; v;
            &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (format) {
                newValue =&lt;span data-mce-=&quot;&quot;&gt; format(newValue);
            }
            node.a(name, newValue);
        }
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;div readability=&quot;9&quot;&gt;
&lt;p&gt;      同样的，这里的动画效果也是引用 Easing.js 里 easeOutStrong 逐渐加快的效果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
const Easing =&lt;span data-mce-=&quot;&quot;&gt; {
    easeOutStrong: &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; (t) {
        &lt;span data-mce-=&quot;&quot;&gt;return 1 - (--t) * t * t *&lt;span data-mce-=&quot;&quot;&gt; t;
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;三、视频嵌入效果的实现&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      在实时监控系统中，主要常用的流媒体传输协议有：&lt;strong&gt;RTMP&lt;/strong&gt;、&lt;strong&gt;RTSP&lt;/strong&gt;、&lt;strong&gt;HLS &lt;/strong&gt;和 &lt;strong&gt;HTTP-FLV&lt;/strong&gt;。&lt;/p&gt;
&lt;div readability=&quot;29.308130081301&quot;&gt;
&lt;p&gt;&lt;strong&gt;RTMP&lt;/strong&gt; (Real Time Messaging Protocol)：实时消息传输协议，RTMP 协议中，视频必须是 H264 编码，音频必须是 AAC 或 MP3 编码，且多以 flv 格式封包。因为 RTMP 协议传输的基本是 FLV 格式的流文件，必须使用 flash 播放器才能播放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RTSP&lt;/strong&gt; (Real-Time Stream Protocol)：RTSP 实时效果非常好，适合视频聊天、视频监控等方向。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HLS&lt;/strong&gt;(Http Live Streaming)：由 Apple 公司定义的基于 HTTP 的流媒体实时传输协议。传输内容包括两部分：1.M3U8 描述文件，2.TS 媒体文件。TS 媒体文件中的视频必须是H264编码，音频必须是 AAC 或 MP3 编码。数据通过 HTTP 协议传输。目前 video.js 库支持该格式文件的播放。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTTP-FLV&lt;/strong&gt;：本协议就是 http+flv，将音视频数据封装成FLV格式，然后通过http协议传输到客户端，这个协议大大方便了浏览器客户端播放直播视频流.目前 flv.js 库支持该格式的文件播放。&lt;/p&gt;
&lt;p&gt;      本实例中实现方式主要是双击 3D 场景中摄像机，弹出监控弹窗再载入本地资源的视频文件，而在实际应用项目场景中，我们可以灵活合理地运用以上的常用的流媒体传输协议来实现实时监控的效果。为了处理点击事件的交互，这里添加事件交互监听 mi 为 addInteractorListener的缩写，可了解 &lt;strong&gt;HT&lt;/strong&gt; &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/3d/ht-3d-guide.html?search=addInteractorListener&amp;amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0&quot; target=&quot;_blank&quot;&gt;交互监听&lt;/a&gt;的实现方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
g3d.mi(e =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    const kind =&lt;span data-mce-=&quot;&quot;&gt; e.kind;
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 双击结点的事件处理
    &lt;span data-mce-=&quot;&quot;&gt;if (kind === 'doubleClickData'&lt;span data-mce-=&quot;&quot;&gt;) {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 双击的结点
        let data =&lt;span data-mce-=&quot;&quot;&gt; e.data;
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取双击结点的标签
        let tag =&lt;span data-mce-=&quot;&quot;&gt; data.getTag();
        &lt;span data-mce-=&quot;&quot;&gt;if (!tag) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 如果结点标签为监控器
        &lt;span data-mce-=&quot;&quot;&gt;if (tag === 'monitor'&lt;span data-mce-=&quot;&quot;&gt;) {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 监控面板显示
            &lt;span data-mce-=&quot;&quot;&gt;this.intelligentMonitoring.s('2d.visible', &lt;span data-mce-=&quot;&quot;&gt;true&lt;span data-mce-=&quot;&quot;&gt;);
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 载入本地资源视频流
            &lt;span data-mce-=&quot;&quot;&gt;this.video.a('videoURL', './storage/assets/media/video.mp4'&lt;span data-mce-=&quot;&quot;&gt;);
        }
    }
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      IBMS 智能化集成系统管理通过 2D 面板与 3D 场景的联动交互中，使得整个系统内容结构更加地直观与拟真。通过 2D 面板的事件监听处理下，3D场景对应地执行环视漫游、巡视漫游以及场景的切换，使其更有具人性化的操作。再加上 3D 场景中各种有趣的动画和 2D面板中的面板缩放动画以及进度条动画，丰富了可视化操作的特点，这也是在工业互联网必不可少的一环。&lt;/p&gt;
&lt;p&gt;      介绍完 2D/3D 融合的IBMS 智能化集成系统场景以及面板的拟真直观的特点后，在本系统中最重要的两个要点：&lt;strong&gt;智慧楼宇管理系统、&lt;/strong&gt;电梯监控系统 以及 &lt;strong&gt;停车场管理系统 &lt;/strong&gt;将在下期的内容中为您详细的解读。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1496396/202002/1496396-20200225200053329-1065733339.jpg&quot; alt=&quot;&quot; width=&quot;1533&quot; height=&quot;862&quot;/&gt;&lt;/div&gt;



&lt;/div&gt;</description>
<pubDate>Wed, 08 Apr 2020 16:07:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 一套完整的可视化操作交互上，必不可少&amp;#160;2D/3D 的融合，在上期我们介绍了有关 3D 场景的环视漫游、巡视漫游以及动画效果，还包括了冷站场景、热站场景以及智慧末端的实现原理，本期主要介</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/12664019.html</dc:identifier>
</item>
<item>
<title>从线性回归案例理解深度学习思想 - 山河故人abin</title>
<link>http://www.cnblogs.com/sctb/p/12664011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sctb/p/12664011.html</guid>
<description>&lt;p&gt;我不是主攻人工智能、深度学习方向，但是作为计算机相关领域的学习者，如果不了解下，总觉得已经跟不上时代了，况且，人工智能真的是大势所趋，学会了，能够尝试用在不同领域。&lt;/p&gt;
&lt;p&gt;本文将使用回归的思想来求解二元一次方程的最佳解，理解深度学习的根本思想。&lt;/p&gt;
&lt;p&gt;假设，对于二元一次方程：&lt;/p&gt;
&lt;p&gt;y = a * x + b&lt;/p&gt;
&lt;p&gt;假设我们能够采集到一组数据（x，y），这些值都是满足以上等式的，但是，现实生活中往往不能这样顺利（如果采集的值是精确值，直接列方程组就能求出a和b），我们采集到的每组（x，y）都存在一定偏差，所以，现实中采集到的数据应表示为：&lt;/p&gt;
&lt;p&gt;y = a * x + b + r&lt;/p&gt;
&lt;p&gt;r表示偏差，这个时候，我们需要通过这一组数据，来找到一组a和b，使得 y = a * x + b 和理想的情况越接近。&lt;/p&gt;
&lt;p&gt;为了方便表示，将r表示为：&lt;/p&gt;
&lt;p&gt;r = y - （a * x +b）&lt;/p&gt;
&lt;p&gt;因为这个值可能为负数，所以用r的平方来表示这个偏差，记为：&lt;/p&gt;
&lt;p&gt;loss = [ y - （a * x + b）] &lt;sup&gt;2&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;这里用loss记，实际上就理解为模型训练过程中的“损失”，我们需要找到到一组a和b，使得loss最小。&lt;/p&gt;
&lt;p&gt;在数学中，我们会用到极限的思想求解最小值，但是，在深度学习中，是如何找到这个最小loss的呢？&lt;/p&gt;
&lt;p&gt;这里就需要提到梯度下降的思想（这些内容在 《计算方法》 这门学科中有详细的说明），通俗地理解，在本文的二元一次方程中，就是初始化一个a和b，然后进行一定次数的迭代，在每次迭代中，调整a和b的值。&lt;/p&gt;
&lt;p&gt;将loss表示的函数分别对a和b求偏导数：&lt;/p&gt;
&lt;p&gt;dei a = 2 * [ y - ( a * x + b ) ] * x&lt;/p&gt;
&lt;p&gt;dei b = 2 * [ y - ( a * x + b ) ]&lt;/p&gt;
&lt;p&gt;我们每次调整a和b的值使用如下方法：&lt;/p&gt;
&lt;p&gt;new a = a - dei a * learn_rate&lt;/p&gt;
&lt;p&gt;new b = b - dei b * learn_rate&lt;/p&gt;
&lt;p&gt;实际上，在每轮迭代中，我们将会用收集到的每组数据都来计算dei a和dei b，最终使用平均值，表示经过这一轮，参数a和b需要被调整的大小。&lt;/p&gt;
&lt;p&gt;但是，我们发现，调整参数的时候，dei a和dei b还分别乘以了一个learn_rate，这个learn_rate在深度学习模型训练中叫学习率，一般取一个比较小的值，0.001、0.01等，可以通过尝试找到最优的值。如果不乘以learn_rate，对a来说，每次需要调整dei a，这个值是很大的，而且会出现不能收敛的情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/sctb/abin_pictures/raw/master/imgs/20200408233315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图中可以看到，对同一个loss函数，如果使用0.05的learn_rate，会导致loss在最小值附近波动，不能找到最小值，而使用0.005的学习率，每次调整的范围更小，且能正确地找到loss的最小值。&lt;/p&gt;
&lt;p&gt;通过一定次数的迭代，我们就能找到一组a和b的值，这组a、b能够使得loss尽可能小，甚至为0，我们近似认为这个方程就是理想情况下的方程：&lt;/p&gt;
&lt;p&gt;y = a * x + b&lt;/p&gt;
&lt;p&gt;这时，如果给出一个值a1，就可以根据上式得到一个y1值，这就是我们所说的预测值。&lt;/p&gt;
&lt;p&gt;这个例子虽然比较简单，但是包含了深度学习的精髓思想。无论多大的网络模型、数据量，实际上都是对一组参数不断地进行调整，使得在这组参数的情况下，所得到的一个函数关系，能够让loss的值尽可能小（当然，这种标准可以根据不同需求进行修改），换句话说，就是找到一组参数，使得一个关系式尽可能趋近给定的一组数据中的每个映射关系（数据和标签的映射），然后再根据这个关系式，对新给定的值，给出相应计算结果，这就是就是预测值。&lt;/p&gt;
&lt;p&gt;附，本文涉及的代码和数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import numpy as np

'''
y = a*x+b + noise

loss = (a*x+b - y)**2

die a = 2(a*x+b-y)*x
die b = 2(a*x+b-y)

'''


# 计算损失loss，神经网络模型训练过程中，一般会在每一轮都输出一次，查看训练效果
def get_loss(a, b, points):
    sum = 0
    for i in points:
        x = i[0]
        y = i[1]

        t = (a * x + b - y) ** 2
        sum = sum + t

    # 因为有多组数据，这里求平均值，表示当前a，b情况下，表达式和这组数据的平均偏差
    average_loss = sum / float(len(points))

    return average_loss


# 求梯度，调整a，b的值，这是参数能够被“训练”的关键部分
def step_grad(a, b, learn_rate, points):
    da_sum, db_sum = 0, 0
    for i in points:
        x = i[0]
        y = i[1]
        da_sum = da_sum + 2 * (a * x + b - y) * x
        db_sum = db_sum + 2 * (a * x + b - y)

    num = len(points)
    da = da_sum / float(num)
    db = db_sum / float(num)

    # 返回新的a，b
    return a - learn_rate * da, b - learn_rate * db


# totalnum表示总共迭代次数
def loop(a, b, learn_rate, points, totalnum):
    for i in range(0, totalnum):
        # 每次迭代都会得到一组新的a，b，将其作为下一次迭代的初始值
        a, b = step_grad(a, b, learn_rate, points)

    loss = get_loss(a, b, points)
    print(&quot;after &quot;, totalnum, &quot;times, loss: &quot;, loss)
    print(&quot;a=&quot;, a, &quot; b=&quot;, b)


if __name__ == '__main__':
    points = np.genfromtxt(&quot;data.csv&quot;, delimiter=&quot;,&quot;)

    # a，b初始化为0，learn_rate设置为0.0001，迭代10000次，points理解为实际情况中，采集到的数据
    loop(0, 0, 0.0001, points, 10000)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;csv数据，网盘链接: &lt;a href=&quot;https://pan.baidu.com/s/1Sknt8dV7kA81IE2ij6bkYw&quot;&gt;https://pan.baidu.com/s/1Sknt8dV7kA81IE2ij6bkYw&lt;/a&gt; 提取码: exf2&lt;/p&gt;
&lt;p&gt;训练结果：&lt;/p&gt;
&lt;img src=&quot;https://gitee.com/sctb/abin_pictures/raw/master/imgs/20200409000854.png&quot;/&gt;</description>
<pubDate>Wed, 08 Apr 2020 16:04:00 +0000</pubDate>
<dc:creator>山河故人abin</dc:creator>
<og:description>我不是主攻人工智能、深度学习方向，但是作为计算机相关领域的学习者，如果不了解下，总觉得已经跟不上时代了，况且，人工智能真的是大势所趋，学会了，能够尝试用在不同领域。 本文将使用回归的思想来求解二元一次</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sctb/p/12664011.html</dc:identifier>
</item>
<item>
<title>使用Azure Functions 在web 应用中启用自动更新（一）分析基于轮询的 Web 应用的限制 - Grant_Allen</title>
<link>http://www.cnblogs.com/AllenMaster/p/12663751.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AllenMaster/p/12663751.html</guid>
<description>&lt;h2&gt;1，引言&lt;/h2&gt;
&lt;p&gt;上一篇介绍了使用使用 Visual Studio 开发 &quot;Azure Functions&quot; 函数，此篇介绍 “Azure Functions” 的测试以及直接从 Vistual Studio 在 Azure 上的部署 ”Azure Functions“应用。&lt;/p&gt;
&lt;p&gt;接着上一篇，本篇介绍在 “Azure Functions” 中实现一个函数，该函数仅在 Azure Cosmos DB 中的数据发生变化时运行。&lt;/p&gt;
&lt;p&gt;在基于计时器的轮询原型中，无论底层数据是否发生了更改，客户端应用程序都会联系服务器。 从服务器返回数据后，无论数据是否发生了任何更改。&lt;/p&gt;
&lt;p&gt;轮询机制是一种低效的解决方案&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202004/1996262-20200408212324354-1427738618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 2.1，分析基于轮询的 Web 应用的限制&lt;/h2&gt;
&lt;p&gt;  开发软件：&lt;/p&gt;
&lt;p&gt;  （1）&lt;a href=&quot;https://nodejs.org/en/&quot; target=&quot;_blank&quot;&gt;Node.js&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  （2）&lt;a href=&quot;https://code.visualstudio.com/&quot; target=&quot;_blank&quot;&gt;Vs Code&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  （3）Azure Functions Tools：是微软提供的一个用于创建开发，测试，调试Azure Functions的本地的工具，可以参考下面的github地址进行查看&lt;/p&gt;
&lt;p&gt;　　  github地址：&lt;a href=&quot;https://github.com/Azure/azure-functions-core-tools&quot;&gt;https://github.com/Azure/azure-functions-core-tools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  （4）Azure Functions，Azure Storage的两个插件&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202004/1996262-20200408214038679-935135950.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  注意  安装 “Azure Functions Core Tools” 的时候 ，笔者使用npm进行安装的时候，一直无法安装，所有我这里推荐使用  &lt;span&gt;&lt;strong&gt;“chocolatey” &lt;/strong&gt;&lt;span&gt;windows的一个包管理器&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　（1）chocolatey 安装说明地址：&lt;a href=&quot;https://chocolatey.org/install&quot;&gt;https://chocolatey.org/install&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　（2）&lt;/span&gt;&lt;/span&gt;azure-functions-core-tools 安装命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
choco &lt;span&gt;install&lt;/span&gt; azure-functions-core-tools --params &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'/x64'&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&lt;span&gt;  下载示例应用代码：这里使用的是微软提供的demo&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/MicrosoftDocs/mslearn-advocates.azure-functions-and-signalr.git serverless-demo&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&lt;span&gt;3，创建存储账户&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&lt;span class=&quot;pl-pds&quot;&gt;&lt;span&gt;　　Azure Functions 需要一个存储帐户，在Azure的门户的“Cloud Shell” 中执行：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;az storage account create \
  &lt;/span&gt;--&lt;span&gt;name storage-web-test \
  &lt;/span&gt;--resource-group xxxxxx-xxxxx-xxxxx-xxxx-xxx-xxxxxxxxxxxv &lt;span&gt;\ &lt;br/&gt;&lt;/span&gt;  --&lt;span&gt;kind StorageV2 \ &lt;/span&gt;--sku Standard_LRS
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202004/1996262-20200408225000179-400877794.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意  --resource-group 这里填写自己对应的 &quot;资源组的 id&quot;，而且 --name 参数我这里使用了变量来代替，这里不要去纠结。&lt;/p&gt;
&lt;h2&gt;4，创建Azure Cosmos DB 账户&lt;/h2&gt;
&lt;p&gt;　　将数据存储在Azure Cosmos DB 数据库中，继续在门户的“Cloud Shell”中执行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;az cosmosdb create  \
  &lt;/span&gt;--name msl-sigr-cosmos-test&lt;span&gt; \
  &lt;/span&gt;--resource-group xxxxxx-xxxxx-xxxxx-&lt;span&gt;xxxx&lt;/span&gt;-xxx-xxxxxxxxxxx
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;5，更新本地设置：&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;5.1，Visual Studio Code 中打开“&lt;strong&gt;start&lt;/strong&gt;”文件夹。 在编辑器中打开 &lt;strong&gt;local.settings.json&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 在 &lt;strong&gt;local.settings.json&lt;/strong&gt; 中，在 “Azure” 门户中找出对应的存储账户的 &lt;strong&gt;&lt;code&gt;AzureWebJobsStorage&lt;/code&gt;&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202004/1996262-20200408225949536-1404365894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;在 “Azure” 门户中找出对应的存储账户的  &lt;strong&gt;&lt;code&gt;AzureCosmosDBMasterKey&lt;/code&gt;&lt;/strong&gt;，和 &lt;strong&gt;&lt;code&gt;AzureCosmosDBConnectionString&lt;/code&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202004/1996262-20200408230310647-532631758.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  修改对应的key,并且保存文件&lt;/span&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;6，运行应用程序&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/span&gt;（1）安装依赖项，并且设置数据的种子数。     &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
npm &lt;span&gt;install&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;       （2）F5 开始调试，终端窗口中将显示函数应用启动。&lt;/p&gt;
&lt;p&gt;　　　　开始启用画面：&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202004/1996262-20200408222508887-1253618126.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;               启动完成画面：  &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202004/1996262-20200408222525966-1266297954.png&quot; alt=&quot;&quot;/&gt;&lt;span&gt;　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;   &lt;/span&gt;&lt;/span&gt; （3）启动第二个实例，并且启动web应用程序&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202004/1996262-20200408222634878-2084297623.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 　　　　脚本会自动打开浏览器，并且导航到http://localhost:8080&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202004/1996262-20200408222757869-300970174.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　（4）最后使用cmd'打开第三个实例,并且输入更新数据命令  &lt;span&gt;npm run update-data&lt;/span&gt;    来更新数据，观察页面数据在短时间内的变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202004/1996262-20200408224202603-1622619664.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　　　web页面的数据变化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202004/1996262-20200408224221460-1065635551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; ok，我们成功在本地使用轮询的方式测试 “Azure Functions” 在web应用程序中启动自动更新。&lt;/p&gt;
&lt;p&gt;以上也是自己的学习的过程，谢谢各位指点。太晚了，先睡了&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/AllenMaster&quot; target=&quot;_blank&quot;&gt;Allen&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;代码稍后也会传到 github&lt;/p&gt;
&lt;p&gt;版权：转载请在文章明显位置注明作者及出处。如发现错误，欢迎批评指正。&lt;/p&gt;
</description>
<pubDate>Wed, 08 Apr 2020 15:29:00 +0000</pubDate>
<dc:creator>Grant_Allen</dc:creator>
<og:description>1，引言 上一篇介绍了使用使用 Visual Studio 开发 &amp;quot;Azure Functions&amp;quot; 函数，此篇介绍 “Azure Functions” 的测试以及直接从 Vist</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AllenMaster/p/12663751.html</dc:identifier>
</item>
<item>
<title>Golang 实现 Redis(4): AOF 持久化与AOF重写 - -Finley-</title>
<link>http://www.cnblogs.com/Finley/p/12663636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Finley/p/12663636.html</guid>
<description>&lt;p&gt;本文是使用 golang 实现 redis 系列的第四篇文章，将介绍如何使用 golang 实现 Append Only File 持久化及 AOF 文件重写。&lt;/p&gt;
&lt;p&gt;本文完整源代码在作者Github&lt;a href=&quot;https://github.com/HDT3213/godis/blob/master/src/db/aof.go&quot;&gt;HDT3213/godis&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;AOF 持久化是典型的异步任务，主协程(goroutine) 可以使用 channel 将数据发送到异步协程由异步协程执行持久化操作。&lt;/p&gt;
&lt;p&gt;在 DB 中定义相关字段:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;type DB struct {
    // 主线程使用此channel将要持久化的命令发送到异步协程
    aofChan     chan *reply.MultiBulkReply 
    // append file 文件描述符
    aofFile     *os.File  
    // append file 路径
        aofFilename string 

    // aof 重写需要的缓冲区，将在AOF重写一节详细介绍
    aofRewriteChan chan *reply.MultiBulkReply 
    // 在必要的时候使用此字段暂停持久化操作
        pausingAof     sync.RWMutex 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在进行持久化时需要注意两个细节:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;get 之类的读命令并不需要进行持久化&lt;/li&gt;
&lt;li&gt;expire 命令要用等效的 expireat 命令替换。举例说明，10:00 执行 &lt;code&gt;expire a 3600&lt;/code&gt; 表示键 a 在 11:00 过期，在 10:30 载入AOF文件时执行 &lt;code&gt;expire a 3600&lt;/code&gt; 就成了 11:30 过期与原数据不符。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们在命令处理方法中返回 AOF 需要的额外信息：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;type extra struct {
    // 表示该命令是否需要持久化
    toPersist  bool 
    // 如上文所述 expire 之类的命令不能直接持久化
    // 若 specialAof == nil 则将命令原样持久化，否则持久化 specialAof 中的指令
        specialAof []*reply.MultiBulkReply 
}

type CmdFunc func(db *DB, args [][]byte) (redis.Reply, *extra)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以 SET 命令为例:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func Set(db *DB, args [][]byte) (redis.Reply, *extra) {
    //....
    var result int
    switch policy {
    case upsertPolicy:
        result = db.Put(key, entity)
    case insertPolicy:
        result = db.PutIfAbsent(key, entity)
    case updatePolicy:
        result = db.PutIfExists(key, entity)
    }
    extra := &amp;amp;extra{toPersist: result &amp;gt; 0} // 若实际写入了数据则toPresist=true, 若因为XX或NX选项没有实际写入数据则toPresist=false
    if result &amp;gt; 0 {
        if ttl != unlimitedTTL { // 使用了 EX 或 NX 选项
            expireTime := time.Now().Add(time.Duration(ttl) * time.Millisecond)
            db.Expire(key, expireTime)
            // 持久化时使用 set key value 和 pexpireat 命令代替 set key value EX ttl 命令
            extra.specialAof = []*reply.MultiBulkReply{ 
                reply.MakeMultiBulkReply([][]byte{
                    []byte(&quot;SET&quot;),
                    args[0],
                    args[1],
                }),
                makeExpireCmd(key, expireTime),
            }
        } else {
            db.Persist(key) // override ttl
        }
    }
    return &amp;amp;reply.OkReply{}, extra
}

var pExpireAtCmd = []byte(&quot;PEXPIREAT&quot;)

func makeExpireCmd(key string, expireAt time.Time) *reply.MultiBulkReply {
        args := make([][]byte, 3)
        args[0] = pExpireAtCmd
        args[1] = []byte(key)
        args[2] = []byte(strconv.FormatInt(expireAt.UnixNano()/1e6, 10))
        return reply.MakeMultiBulkReply(args)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在处理命令的调度方法中将 aof 命令发送到 channel:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func (db *DB) Exec(c redis.Client, args [][]byte) (result redis.Reply) {
        // ....
        // normal commands
        var extra *extra
        cmdFunc, ok := router[cmd] // 找到命令对应的处理函数
        if !ok {
                return reply.MakeErrReply(&quot;ERR unknown command '&quot; + cmd + &quot;'&quot;)
    }
    // 使用处理函数执行命令
        if len(args) &amp;gt; 1 {
                result, extra = cmdFunc(db, args[1:])
        } else {
                result, extra = cmdFunc(db, [][]byte{})
        }

        // AOF 持久化
        if config.Properties.AppendOnly {
                if extra != nil &amp;amp;&amp;amp; extra.toPersist {
            // 写入 specialAof
                        if extra.specialAof != nil &amp;amp;&amp;amp; len(extra.specialAof) &amp;gt; 0 {
                                for _, r := range extra.specialAof {
                                        db.addAof(r)
                                }
                        } else {
                // 写入原始命令
                                r := reply.MakeMultiBulkReply(args)
                                db.addAof(r)
                        }
                }
        }
        return
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在异步协程中写入命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func (db *DB) handleAof() {
        for cmd := range db.aofChan {
        // 异步协程在持久化之前会尝试获取锁，若其他协程持有锁则会暂停持久化操作
        // 锁也保证了每次写入完整的一条指令不会格式错误
                db.pausingAof.RLock() 
                if db.aofRewriteChan != nil {
                        db.aofRewriteChan &amp;lt;- cmd
                }
                _, err := db.aofFile.Write(cmd.ToBytes())
                if err != nil {
                        logger.Warn(err)
                }
                db.pausingAof.RUnlock()
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读取过程与&lt;a href=&quot;https://www.cnblogs.com/Finley/p/11923168.html&quot;&gt;协议解析器&lt;/a&gt;一节基本相同，不在正文中赘述：&lt;a href=&quot;https://github.com/HDT3213/godis/blob/master/src/db/aof.go&quot;&gt;loadAof&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;若我们对键a赋值100次会在AOF文件中产生100条指令但只有最后一条指令是有效的，为了减少持久化文件的大小需要进行AOF重写以删除无用的指令。&lt;/p&gt;
&lt;p&gt;重写必须在固定不变的数据集上进行，不能直接使用内存中的数据。Redis 重写的实现方式是进行 fork 并在子进程中遍历数据库内的数据重新生成AOF文件。由于 golang 不支持 fork 操作，我们只能采用读取AOF文件生成副本的方式来代替fork。&lt;/p&gt;
&lt;p&gt;在进行AOF重写操作时需要满足两个要求:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;若 AOF 重写失败或被中断，AOF 文件需保持重写之前的状态不能丢失数据&lt;/li&gt;
&lt;li&gt;进行 AOF 重写期间执行的命令必须保存到新的AOF文件中, 不能丢失&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此我们设计了一套比较复杂的流程：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;暂停AOF写入 -&amp;gt; 更改状态为重写中 -&amp;gt; 复制当前AOF文件 -&amp;gt; 恢复AOF写入&lt;/li&gt;
&lt;li&gt;在重写过程中，持久化协程在将命令写入文件的同时也将其写入内存中的重写缓存区&lt;/li&gt;
&lt;li&gt;重写协程读取AOF副本并将重写到临时文件（tmp.aof）中&lt;/li&gt;
&lt;li&gt;暂停AOF写入 -&amp;gt; 将重写缓冲区中的命令写入tmp.aof -&amp;gt; 使用临时文件tmp.aof覆盖AOF文件（使用文件系统的mv命令保证安全）-&amp;gt; 清空重写缓冲区 -&amp;gt; 恢复AOF写入&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;6.2533333333333&quot;&gt;
&lt;p&gt;在不阻塞在线服务的同时进行其它操作是一项必需的能力，AOF重写的思路在解决这类问题时具有重要的参考价值。比如&lt;a href=&quot;https://github.com/github/gh-ost&quot;&gt;Mysql Online DDL: gh-ost&lt;/a&gt;采用了类似的策略保证数据一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先准备开始重写操作:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func (db *DB) startRewrite() (*os.File, error) {
    // 暂停AOF写入， 数据会在 db.aofChan 中暂时堆积
        db.pausingAof.Lock() 
        defer db.pausingAof.Unlock()

        // 创建重写缓冲区
        db.aofRewriteChan = make(chan *reply.MultiBulkReply, aofQueueSize)

        // 创建临时文件
        file, err := ioutil.TempFile(&quot;&quot;, &quot;aof&quot;)
        if err != nil {
                logger.Warn(&quot;tmp file create failed&quot;)
                return nil, err
        }
        return file, nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在重写过程中，持久化协程进行双写：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func (db *DB) handleAof() {
        for cmd := range db.aofChan {
                db.pausingAof.RLock() 
                if db.aofRewriteChan != nil {
            // 数据写入重写缓冲区
                        db.aofRewriteChan &amp;lt;- cmd
                }
                _, err := db.aofFile.Write(cmd.ToBytes())
                if err != nil {
                        logger.Warn(err)
                }
                db.pausingAof.RUnlock()
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行重写:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func (db *DB) aofRewrite() {
        file, err := db.startRewrite()
        if err != nil {
                logger.Warn(err)
                return
        }

        // load aof file
        tmpDB := &amp;amp;DB{
                Data:     dict.MakeSimple(),
                TTLMap:   dict.MakeSimple(),
                Locker:   lock.Make(lockerSize),
                interval: 5 * time.Second,

                aofFilename: db.aofFilename,
        }
        tmpDB.loadAof()

        // rewrite aof file
        tmpDB.Data.ForEach(func(key string, raw interface{}) bool {
                var cmd *reply.MultiBulkReply
                entity, _ := raw.(*DataEntity)
                switch val := entity.Data.(type) {
                case []byte:
                        cmd = persistString(key, val)
                case *List.LinkedList:
                        cmd = persistList(key, val)
                case *set.Set:
                        cmd = persistSet(key, val)
                case dict.Dict:
                        cmd = persistHash(key, val)
                case *SortedSet.SortedSet:
                        cmd = persistZSet(key, val)

                }
                if cmd != nil {
                        _, _ = file.Write(cmd.ToBytes())
                }
                return true
        })
        tmpDB.TTLMap.ForEach(func(key string, raw interface{}) bool {
                expireTime, _ := raw.(time.Time)
                cmd := makeExpireCmd(key, expireTime)
                if cmd != nil {
                        _, _ = file.Write(cmd.ToBytes())
                }
                return true
        })

        db.finishRewrite(file)
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重写完毕后写入缓冲区中的数据并替换正式文件:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-golang&quot;&gt;func (db *DB) finishRewrite(tmpFile *os.File) {
    // 暂停AOF写入
        db.pausingAof.Lock() 
        defer db.pausingAof.Unlock()


    // 将重写缓冲区内的数据写入临时文件
        // 因为handleAof已被暂停，在遍历期间aofRewriteChan中不会有新数据
    loop:
        for {
                select {
                case cmd := &amp;lt;-db.aofRewriteChan:
                        _, err := tmpFile.Write(cmd.ToBytes())
                        if err != nil {
                                logger.Warn(err)
                        }
                default:
                        // 只有 channel 为空时才会进入此分支
                        break loop
                }
    }
    // 释放重写缓冲区
        close(db.aofRewriteChan)
        db.aofRewriteChan = nil

        // 使用临时文件代替aof文件
        _ = db.aofFile.Close()
        _ = os.Rename(tmpFile.Name(), db.aofFilename)

        // 重新打开文件描述符以保证正常写入
        aofFile, err := os.OpenFile(db.aofFilename, os.O_APPEND|os.O_CREATE|os.O_RDWR, 0600)
        if err != nil {
                panic(err)
        }
        db.aofFile = aofFile
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 08 Apr 2020 14:53:00 +0000</pubDate>
<dc:creator>-Finley-</dc:creator>
<og:description>AOF 持久化与AOF重写实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Finley/p/12663636.html</dc:identifier>
</item>
</channel>
</rss>