<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Sharding-JDBC 使用入门和基本配置 - 宜信技术</title>
<link>http://www.cnblogs.com/yixinjishu/p/10876071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yixinjishu/p/10876071.html</guid>
<description>&lt;h2 id=&quot;toc_1&quot;&gt;一、什么是Sharding-JDBC&lt;/h2&gt;
&lt;p&gt;Sharding-JDBC定位为轻量级Java框架，在Java的JDBC层提供的额外服务。它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。&lt;/p&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;二、Sharding-JDBC能做什么&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;分库 &amp;amp; 分表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读写分离&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式主键&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式事务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_3&quot;&gt;三、适用项目框架&lt;/h2&gt;
&lt;p&gt;Sharding-JDBC适用于：&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;支持任意实现JDBC规范的数据库，目前支持MySQL，Oracle，SQLServer和PostgreSQL。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;toc_4&quot;&gt;四、Maven依赖&lt;/h2&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- sharding jdbc 开始--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.shardingsphere&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sharding-core&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${sharding.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.shardingsphere&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sharding-jdbc-spring-&lt;span&gt;namespace&lt;/span&gt;&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${sharding.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!—如果不配置分布式事务的话配置上边两个就够了 --&amp;gt; 
&amp;lt;!--分布式事务引用依赖--&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.shardingsphere&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sharding-transaction-2pc-xa&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${sharding.version}&amp;lt;/version&amp;gt;

&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.shardingsphere&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sharding-transaction-spring&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${sharding.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;!-- sharding jdbc 结束--&amp;gt;
&amp;lt;!--AspectJ AOP支持 --&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${aspectjweaver.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;五、读写分离&lt;/h2&gt;
&lt;h3 id=&quot;toc_6&quot;&gt;5.1 数据源配置&lt;/h3&gt;
&lt;p&gt;先配置数据源&lt;/p&gt;
&lt;p&gt;也可以配置读写分离&lt;/p&gt;
&lt;p&gt;以下配置是&lt;code&gt;ds0&lt;/code&gt;和&lt;code&gt;ds1&lt;/code&gt;两个数据库的主和从一共四个数据源。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;parentDs&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 是数据源公共的配置，抽出去以免写重复代码。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- ds0的主--&amp;gt;
&amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds0_master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.alibaba.druid.pool.DruidDataSource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; destroy-method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; parent=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parentDs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; 
&amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;driverClassName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&quot;&lt;/span&gt;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;!-- ds0的从--&amp;gt;
&amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds0_slave&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.alibaba.druid.pool.DruidDataSource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; destroy-method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; parent=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parentDs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;driverClassName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${sharding.connection.url.0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;!-- ds1的主--&amp;gt;
&amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds1_master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.alibaba.druid.pool.DruidDataSource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; destroy-method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; parent=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parentDs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;driverClassName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${sharding.connection.url.1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;!-- ds1的从--&amp;gt;
&amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds1_slave&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;com.alibaba.druid.pool.DruidDataSource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; destroy-method=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;close&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; parent=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;parentDs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;driverClassName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&quot;&lt;/span&gt;/&amp;gt;
    &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;url&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; value=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${sharding.connection.url.1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3 id=&quot;toc_7&quot;&gt;5.2 读写分离配置&lt;/h3&gt;
&lt;p&gt;只配置主从不配置分库分表的情况如下，如果要配置分库分表则不需要下面这个配置。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;master-data-source-name&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 是主数据源ID&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slave-data-source-names&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 是从数据源ID&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;master-slave:data-source id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;masterSlaveDataSource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; master-data-source-name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds0_master, ds1_master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; slave-data-source-names=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds0_slave, ds1_slave &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt;
        &amp;lt;master-slave:props&amp;gt;
                &amp;lt;prop key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sql.show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;${sql_show}&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;executor.size&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;10&lt;/span&gt;&amp;lt;/prop&amp;gt;
                &amp;lt;prop key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;bar&amp;lt;/prop&amp;gt;
        &amp;lt;/master-slave:props&amp;gt;
&amp;lt;/master-slave:data-source&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3 id=&quot;toc_8&quot;&gt;5.3 读写分离和分库分表一起配置&lt;/h3&gt;
&lt;p&gt;如果读写分离和分库分表一起使用的话把主从路由配置到 shardingdata-source下就可以了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sharding:master-slave-rule&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 的 id 就是配置出来的逻辑的数据源的名称，如果多个从的话还可以通过配置strategy-ref来配置负载均衡。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;master-data-source&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 配置的是主库数据源ID 。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;slave-data-source&lt;/code&gt;&lt;span class=&quot;Apple-converted-space&quot;&gt; 配置的是从库数据源ID，多个以逗号分开。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- sharding数据源--&amp;gt;
&amp;lt;sharding:data-source id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shardingDataSource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;!-- 读写分离的话要把所有的主从数据源都写在这里--&amp;gt;
    &amp;lt;sharding:sharding-&lt;span&gt;rule
            data&lt;/span&gt;-source-names=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds0_master,ds0_slave,ds1_master,ds1_slave &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;!-- 读写分离的路由 一主一从配置 strategy-&lt;span&gt;ref&lt;/span&gt;  --&amp;gt;
        &amp;lt;sharding:master-slave-rules&amp;gt;
            &amp;lt;sharding:master-slave-rule id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; master-data-source-name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds0_master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                                        slave-data-source-names=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds0_slave&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
            &amp;lt;sharding:master-slave-rule id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; master-data-source-name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds1_master&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                                        slave-data-source-names=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ds1_slave&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
        &amp;lt;/sharding:master-slave-rules&amp;gt;
        &amp;lt;!-- 读写分离配置 结束--&amp;gt;

        &amp;lt;sharding:table-rules&amp;gt;
    &amp;lt;!— 这里是分库分表路由的配置 --&amp;gt;
        &amp;lt;/sharding:table-rules&amp;gt;
        &amp;lt;sharding:binding-table-rules&amp;gt;
    &amp;lt;!—- 绑定表的配置 --&amp;gt; 
        &amp;lt;/sharding:binding-table-rules&amp;gt;
 &amp;lt;/sharding:sharding-rule&amp;gt;
&amp;lt;sharding:props&amp;gt;
        &amp;lt;!-- 显示SQL --&amp;gt;
        &amp;lt;prop key=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sql.show&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;true&lt;/span&gt;&amp;lt;/prop&amp;gt;
    &amp;lt;/sharding:props&amp;gt;
&amp;lt;/sharding:data-source&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h2 id=&quot;toc_9&quot;&gt;六、数据分片&lt;/h2&gt;
&lt;h3 id=&quot;toc_10&quot;&gt;6.1 分片支持&lt;/h3&gt;
&lt;p&gt;Sharding-JDBC提供了5种分片策略。由于分片算法和业务实现紧密相关，因此Sharding-JDBC并未提供内置分片算法，而是通过分片策略将各种场景提炼出来，提供更高层级的抽象，并提供接口让应用开发者自行实现分片算法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StandardShardingStrategy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标准分片策略。提供对SQL语句中的=, IN和BETWEEN AND的分片操作支持。StandardShardingStrategy只支持单分片键，提供PreciseShardingAlgorithm和RangeShardingAlgorithm两个分片算法。PreciseShardingAlgorithm是必选的，用于处理=和IN的分片；RangeShardingAlgorithm是可选的，用于处理BETWEEN AND分片，如果不配置RangeShardingAlgorithm，SQL中的BETWEEN AND将按照全库路由处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ComplexShardingStrategy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;复合分片策略。提供对SQL语句中的=, IN和BETWEEN AND的分片操作支持。ComplexShardingStrategy支持多分片键，由于多分片键之间的关系复杂，因此Sharding-JDBC并未做过多的封装，而是直接将分片键值组合以及分片操作符交于算法接口，完全由应用开发者实现，提供最大的灵活度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;InlineShardingStrategy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Inline表达式分片策略。使用Groovy的Inline表达式，提供对SQL语句中的=和IN的分片操作支持。InlineShardingStrategy只支持单分片键，对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: tuser${user_id % 8} 表示t_user表按照user_id按8取模分成8个表，表名称为t_user_0到t_user_7。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HintShardingStrategy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过Hint而非SQL解析的方式分片的策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;NoneShardingStrategy&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不分片的策略。&lt;/p&gt;
&lt;h3 id=&quot;toc_11&quot;&gt;6.2 分片配置&lt;/h3&gt;
&lt;p&gt;标准分片配置&lt;/p&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 标准分片策略。--&amp;gt;
&amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demoUserStandardStrategy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shard.strategy.DemoUserStandardStrategy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&amp;lt;sharding:standard-strategy id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shardingDemoUserStandardStrategy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                            precise&lt;/span&gt;-algorithm-&lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demoUserStandardStrategy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; sharding-column=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;                            range-algorithm-&lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;DemoUserStandardStrategy标准分片要实现 PreciseShardingAlgorithm 接口，doSharding的两个参数一个是所有数据源的cllection.另一个参数是执行SQL时传过来的分片的值。&lt;/p&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 根据ID取
 * 标准分片策略
 * 用于处理=和IN的分片
 * @author yulonggao
 * @date 2019/1/31 14:35
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Slf4j
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DemoUserStandardStrategy implements PreciseShardingAlgorithm&amp;lt;Long&amp;gt;&lt;span&gt; {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String doSharding(Collection&amp;lt;String&amp;gt; collection, PreciseShardingValue&amp;lt;Long&amp;gt;&lt;span&gt; preciseShardingValue) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个里边有异常会被处理掉，然后导致拿不到分片。但出异常一般是业务代码写错了。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每条指定分片的操作都会调用此方法，如果是in 条件查询的话每个值会调用一次此方法，如果是批量插入也是每一条都要调用一次进行分片&lt;/span&gt;
        log.info(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DemoUserStandardStrategy_preciseShardingValue={}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, preciseShardingValue);
        Long suffix &lt;/span&gt;= preciseShardingValue.getValue() % &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;
        log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;suffix={}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, suffix);
        final String targetDb &lt;/span&gt;=&lt;span&gt; String.valueOf(Math.abs(suffix.intValue()));
        String shardingValue &lt;/span&gt;= collection.stream().filter(p -&amp;gt; p.endsWith(targetDb)).findFirst().&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();
        log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;preciseShardingValue={},shardingValue={}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, preciseShardingValue, shardingValue);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; shardingValue;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;强制分片&lt;/p&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&amp;lt;!-- 强制路由分片策略--&amp;gt;
&amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demoUserHintStrategy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shard.strategy.DemoUserHintStrategy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;

&amp;lt;!-- 强制路由例子使用--&amp;gt;
&amp;lt;sharding:hint-strategy id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shardingDemoUserHintStrategy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; algorithm-&lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;demoUserHintStrategy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;&lt;span&gt;

DemoUserHintStrategy 的Java 如下，强制分片要实现HintShardingAlgorithm接口。

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * DemoUserHint强制路由分片策略,其实可以共用，只是例子
 * @author yulonggao
 * @date 2019/1/31 14:35
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Slf4j
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoUserHintStrategy implements HintShardingAlgorithm {

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Collection&amp;lt;String&amp;gt; doSharding(Collection&amp;lt;String&amp;gt;&lt;span&gt; availableTargetNames, ShardingValue shardingValue) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;availableTargetNames 这个参数是所有的dataSource的集合，shardingValue是HintManager传过来的分片信息&lt;/span&gt;
        log.info(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DemoUserHintStrategy_availableTargetNames={}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, availableTargetNames);
        log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DemoUserHintStrategy_shardingValue={}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, shardingValue);
        ListShardingValue listShardingValue &lt;/span&gt;=&lt;span&gt; (ListShardingValue) shardingValue;
        Collection shardingValueList &lt;/span&gt;=&lt;span&gt; listShardingValue.getValues();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;因为调用的时候分片是直接传的 DataSource的名称，所以直接返回就可以了，如果传其它值则要加业务逻辑进行分片筛选
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回结果只能是availableTargetNames 里边所包含的&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; shardingValueList;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;生成分部式ID的配置，生成主键的类要实现KeyGenerator接口。&lt;/p&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;!—主键生成 --&amp;gt;
&amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;keyId&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shard.key.DefaultKeyGenerator&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190321/1553149272315099773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_12&quot;&gt;七、分布式事务&lt;/h2&gt;
&lt;p&gt;把下面这行代码配置在spring里，shardingTransaction.xml 是jar包里边带的。&lt;/p&gt;
&lt;p&gt;文件的源码只有两行配置：&lt;/p&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;bean id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;transactionManager&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
      &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;org.springframework.jdbc.datasource.DataSourceTransactionManager&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;property name=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dataSource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;ref&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;shardingDataSource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&amp;lt;tx:annotation-driven transaction-manager=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;transactionManager&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&amp;lt;!-- 事务支持--&amp;gt;
&amp;lt;import resource=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;classpath:META-INF/shardingTransaction.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;/&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;使用注解配置事务要同时使用ShardingTransactionType和Transactional两个注解。&lt;/p&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 注意：@ShardingTransactionType需要同Spring的@Transactional配套使用，事务才会生效。
 * @param param
 * @return
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@ShardingTransactionType(TransactionType.XA)
@Transactional(rollbackFor &lt;/span&gt;= Exception.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; addParam(DemoParam param) {
log.info(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;addParam-param={}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, param);
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; demoParamDao.addParam(param);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;h3 id=&quot;toc_13&quot;&gt;7.1 支持程度&lt;/h3&gt;
&lt;p&gt;完全支持非跨库事务，例如：仅分表或分库但是路由的结果在单库中。&lt;/p&gt;
&lt;p&gt;完全支持因逻辑异常导致的跨库事务。例如：同一事务中跨两个库更新，更新完毕后，抛出空指针，则两个库的内容都能回滚。&lt;/p&gt;
&lt;p&gt;支持数据库字段约束造成的回滚。&lt;/p&gt;
&lt;p&gt;不支持因网络、硬件异常导致的跨库事务。例如：同一事务中跨两个库更新，更新完毕后、未提交之前，第一个库死机，则只有第二个库数据提交。&lt;/p&gt;
&lt;h2 id=&quot;toc_14&quot;&gt;八、其他问题&lt;/h2&gt;
&lt;p&gt;关于order by 排序，如果排序的字段不在查询结果中，生成的SQL也会被带上，但结果不返回给你。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://college.creditease.cn/resources/upload/image/20190321/1553149258617053851.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;toc_15&quot;&gt;九、参考文档&lt;/h2&gt;
&lt;p&gt;https://shardingsphere.apache.org/document/current/cn/manual/sharding-jdbc/usage/sharding/&lt;/p&gt;
&lt;p&gt;作者：高玉珑&lt;/p&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://college.creditease.cn/&quot;&gt;宜信技术学院&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 07:51:00 +0000</pubDate>
<dc:creator>宜信技术</dc:creator>
<og:description>Sharding-JDBC使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，且完全兼容JDBC和各种ORM框架。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yixinjishu/p/10876071.html</dc:identifier>
</item>
<item>
<title>C# - char - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/10873357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/10873357.html</guid>
<description>&lt;p&gt;C#里面的char，其实就是System.Char类型的别名，它代表一个Unicode字符（是这样吗?），占用两个字节。&lt;/p&gt;
&lt;p&gt;例如：char c = ‘A’;&lt;/p&gt;
&lt;p&gt;char占用两个字节，也就是16位，其实本质上char其实就是16位的无符号整型数值，范围是0到65535，也就是和无符号short的范围是一样的。&lt;/p&gt;

&lt;h2&gt;转义字符&lt;/h2&gt;
&lt;p&gt;有一些字符无法通过字面的意思来进行解释，这时候就可以使用转义字符。&lt;/p&gt;
&lt;p&gt;转义字符是以 / 开始，后边跟着一个有特殊意义的字符。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;char newLine = '\n'; 这个表示换行&lt;/p&gt;
&lt;p&gt;char backSlash = '\\'; 这个就表示 \&lt;/p&gt;

&lt;p&gt;转义字符的列表如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201905/986268-20190516054751463-388072163.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;还有\u（\x）这两个转义字符可以让你通过4位16进制的形式来表示任意的Unicode字符，例如：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;char copyrightSymbol = '\u00A9'; // ©&lt;br/&gt;char omegaSymbol = '\u03A9'; // Ω&lt;br/&gt;char newLine = '\u000A'; // 换行&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;转换&lt;/h2&gt;
&lt;p&gt;char类型的变量可以隐式的转换到可容纳无符号short类型的数值类型，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201905/986268-20190516055344765-1180760908.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;char只能代表一个Unicode字符, 其实这句话不太准确。&lt;/p&gt;
&lt;p&gt;我们知道Unicode里 65 代表着字母 A，但其实65是A的Unicode代码点，通常是这样来表示的 U+0041，16进制的41就是10进制的65。&lt;/p&gt;

&lt;p&gt;而看这个例子，德语里面有个字符：ß，它的UniCode是 U+00DF，但就其本身而言，ß 不是一个字母，ß被认为等价于ss（也就是两个s），例如fußball就相当于fussball。&lt;/p&gt;
&lt;p&gt;而用在字符/字符串比较的时候，就不可以把ß当作一个字符来处理，而是把ß=ss。&lt;/p&gt;
&lt;p&gt;而ß所对应的U+00DF这个代码点就是字符扩展（&lt;strong&gt;Character expansion&lt;/strong&gt;）的一个例子，&lt;strong&gt;如果想正确的比较字符/串，那么这个代码点就必须先转化为其它的多个代码点&lt;/strong&gt;，这里就是 U+00DF -&amp;gt; U+0073 + U+0073，也就是ß -&amp;gt; ss，记住，这只是用于比较，而不是展示。&lt;/p&gt;


&lt;p&gt;字符代理（&lt;strong&gt;char surrogates&lt;/strong&gt;），和字符扩展正好相反。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符扩展是指，一个字符代表了多个实际的字符&lt;/strong&gt;；&lt;strong&gt;而字符代理呢，就是使用两个char的实例来表示一个实际的字符&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;字符代理之所以存在，是因为它的范围太小了（0-65535），所以根本无法代表世界上这么多语言的字符。实际上Unicode的代码点是从0到1114111（0x10FFFF），所以16位的存储远远不够用。&lt;/p&gt;
&lt;p&gt;正是因为这点，Unicode UTF16有一个可以表示所有字符的体系，就是使用两个连续的16位数值来表示，这就叫做代理对（surrogate pairs）。&lt;/p&gt;
&lt;p&gt;在这两个连续的16位数值里，第一个数的范围是U+D800到U+DBFF（55296到56319），所以如果您在解析字符/串的时候，解析出来的数值正好落在这个范围里，那么你就需要把这个char和它后边的char连在一起进行解析，才能得出真正要表示的字符。&lt;/p&gt;
&lt;p&gt;从术语上讲，第一个16位数叫做High Surrogate（高代理项），第二个数叫做Low Surrogate（低代理项）。&lt;/p&gt;

&lt;p&gt;例如：𝄞 它的Unicode 代码点是 U+1D11E，它包含一个High Surrogate：U+D834 和一个Low Surrogate：U+DD1E&lt;/p&gt;


&lt;p&gt;此外有一些代码点还会修改前一个字符，比如说 &lt;strong&gt;ä&lt;/strong&gt; 这个字符，它可以用U+00E4来表示。&lt;/p&gt;
&lt;p&gt;而我也可以使用 &lt;strong&gt;a +  ̈ &lt;/strong&gt; （U+0061 + U+0308）的形式来表示该字符，在这里U+0308就表示两个点，它会修改前一个字符。&lt;/p&gt;
&lt;p&gt;在Unicode的标准中，后边这个字符就叫做 Combining diaeresis（组合用分音符？）&lt;/p&gt;
&lt;p&gt;而在实际中字符/串比较的时候，你需要把这两个字符合并当作U+00E4才可以。&lt;/p&gt;


&lt;p&gt;char有ToUpper()和ToLower()两个方法可以变换大小写，它们首先会遵循用户的locale（区域设置），但是这就有可能引起一个bug：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;char.ToUpper ('i') == 'I'&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;这个表达式在土耳其语里面会返回false。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;在土耳其语里面 i 被 ToUpper()之后返回的是 &lt;span class=&quot;fontstyle0&quot;&gt;İ （看起来像大写的I上面还有一个点），所以与大写的 I 不等。&lt;br/&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;而char也提供了不依赖用户区域的版本：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;char.ToUpperInvariant ('i')&lt;/li&gt;
&lt;li&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;char.ToUpper ('i', CultureInfo.InvariantCulture) &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;这两种写法都可以。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;另外一点需要注意的是，从整型转换到char类型后，很有可能变成一个超出了Unicode范围的字符，这样的字符就是不合理的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;为了验证字符是否合理，我们可以使用 char.GetUnicodeCategory()方法，如果结果是&lt;span class=&quot;fontstyle0&quot;&gt;Unico&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;deCategory&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/em&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;OtherNotAssigned，那么该字符就不合理。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt;&lt;span class=&quot;fontstyle0&quot;&gt; &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 16 May 2019 07:37:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<og:description>Char C#里面的char，其实就是System.Char类型的别名，它代表一个Unicode字符（是这样吗?），占用两个字节。 例如：char c = ‘A’; char占用两个字节，也就是16位</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/10873357.html</dc:identifier>
</item>
<item>
<title>聊聊关于性能优化和其他（一） - 梁音</title>
<link>http://www.cnblogs.com/liangyin/p/10875915.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liangyin/p/10875915.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;隔了许久都没有更新博客，前一阵子是因为忙其他事去了，现在想写点什么，但是思前想后不知道该写些什么，这是这个系列的第一篇，这篇文章没有干货，只是聊聊关于前端优化，关于5G的到来，关于前端的未来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;关于为什么要优化&quot;&gt;关于为什么要优化&lt;/h2&gt;
&lt;p&gt;前端的大咖们在推动前端届蓬勃发展的同时，越来越多的人能抄起手上的工具（ &lt;code&gt;React&lt;/code&gt;、&lt;code&gt;Vue&lt;/code&gt;、&lt;code&gt;Angular&lt;/code&gt; ）加上各种 &lt;code&gt;CLI&lt;/code&gt; 一键生成， 再加上天然的 &lt;code&gt;UI&lt;/code&gt; 库（ &lt;code&gt;Antd&lt;/code&gt;、&lt;code&gt;Element-UI&lt;/code&gt;、&lt;code&gt;iView&lt;/code&gt;、&lt;code&gt;Bootstrap&lt;/code&gt; ）就能快速构建写出一个用户界面，加上在这个性能过剩的年代，非大厂能够投入人力优化前端性能，大部分网页能加载出来功能没问题就告之大吉，只要不是太 &lt;code&gt;过分&lt;/code&gt; 的代码编写，一般来说，电脑端的网页加载也就差个 &lt;code&gt;1~3&lt;/code&gt; 秒，更多的则是网络问题。&lt;/p&gt;
&lt;p&gt;这么一看，性能优化仿佛不是那么重要，但是由于前端圈的蓬勃发展，越来越多的功能实现放置在前端页面上，现代的网站拥有比以往多很多的功能，页面数量都是几倍的增长，甚至该网站是这个企业的核心业务，尤其是这几年移动设备的爆发式发展，如果这么多的功能放置在移动端时，轻微的性能问题可能只会导致轻微的延迟、等待，仅仅会给用户带来短暂的不便，但是严重的性能问题就会导致用户无法访问或者无法响应用户的动作之类，很多人意识到这个问题，可惜的是，大部分网站都将这个原因归结于网络条件不好或者用户设备太差，从而忽略真正的前端性能的优化。&lt;/p&gt;
&lt;p&gt;对于一般网站来说，用户进入浏览，关心的是自己的用户体验、网页浏览舒适度，他们很大一部分并不关心网络和设备问题，有很多数据表明，一个网站的舒适度决定了用户的去留。&lt;/p&gt;
&lt;h3 id=&quot;对不起我真的不想等优化和用户去留的关系&quot;&gt;对不起，我真的不想等（优化和用户去留的关系）&lt;/h3&gt;
&lt;p&gt;我们希望我们所构建的页面能和用户进行互动，而不是呆板的纯静态页面，一个可交互的页面可以留存很多的用户。&lt;/p&gt;
&lt;p&gt;如果我们构建的是博客，我们希望用户能顺畅的读完博文，并给予点评。&lt;/p&gt;
&lt;p&gt;如果我们构建的是商城系统，我们希望用户能快速精准的定位到需要购买的商品。&lt;/p&gt;
&lt;p&gt;如果我们构建的是社交系统，我们希望用户能快速找到对应的人并进行彼此的互动。&lt;/p&gt;
&lt;p&gt;而这一切，差异化是一条出路，但是差异化很容易就被抄袭、模仿，企业更多的这是面对同质化的红海竞争，与此同时，性能扮演着至关重要的角色。&lt;/p&gt;
&lt;p&gt;有几组数据来表明性能优化与用户留存的关系：&lt;/p&gt;
&lt;p&gt;根据 DoubleClick by Google 更多研究，如果一个网站加载时间越短，优势越大。&lt;/p&gt;
&lt;p&gt;根据大量测试发现，同一个页面，加载时间 19 秒和加载时间 5 秒是两种截然不同的结果，加载在 5 秒之内的网站，用户浏览率增长 70%，流失率下降 35%，广告可见率提升 25%。&lt;/p&gt;
&lt;p&gt;大家可以使用 &lt;a href=&quot;https://www.thinkwithgoogle.com/feature/mobile/&quot;&gt;Speed Scorecard&lt;/a&gt; 工具进行移动网站的加载速度测试，由于没有中国大陆节点，大家移步至香港节点进行测试。&lt;/p&gt;
&lt;p&gt;以下是我对一些常用网站4G加载的测试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/13/16a12999a0f2803b?w=1608&amp;amp;h=1200&amp;amp;f=png&amp;amp;s=105481&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;高优化和收入的关系&quot;&gt;高优化和收入的关系&lt;/h3&gt;
&lt;p&gt;从上一小节可以看出来，一个好的优化可以提升用户的转化率，反之流失率会大大增加。&lt;/p&gt;
&lt;p&gt;下面一些小栗子显示了一些优化对收入的影响：&lt;/p&gt;
&lt;h3 id=&quot;用户体验的哲学&quot;&gt;用户体验的哲学&lt;/h3&gt;
&lt;h4 id=&quot;关于加载速度&quot;&gt;关于加载速度&lt;/h4&gt;
&lt;p&gt;当用户在用移动设备访问某一个网站时，由于各种外在条件的因素（网速、设备硬件条件），打开同一网站的效果可能截然不同（某锤官网）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;Fast 3G&lt;/code&gt; 情况下大概使用了 34 秒全部加载完毕：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/13/16a1299a0de28a4d?w=3352&amp;amp;h=1749&amp;amp;f=jpeg&amp;amp;s=935568&quot;/&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;模拟 4G（5MB/s）&lt;/code&gt; 的速度下大概使用了 11 秒全部加载完毕：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/13/16a12999a2342b80?w=3354&amp;amp;h=1740&amp;amp;f=png&amp;amp;s=1266383&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然而，实际情况下，由于地理位置、人流量等环境因素，很少有移动设备能满速 &lt;code&gt;5MB&lt;/code&gt; 的下载。&lt;br/&gt;而用户体验的基础是在于已经看到显示的内容，在此之前就谈不上用户体验，如果网络较快可能还好点，如果网速不好，用户就不得不等待，还可能会遇到各种各样的问题，例如，&lt;code&gt;JS&lt;/code&gt; 加载不完整导致点击事件无效等。&lt;br/&gt;全部加载完毕之后的某锤网站使用感觉还可以，我们来看一下此次加载了多少 &lt;code&gt;JS&lt;/code&gt; 资源：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/13/16a12999b3437ce4?w=2686&amp;amp;h=1348&amp;amp;f=jpeg&amp;amp;s=591185&quot;/&gt;&lt;/p&gt;
&lt;p&gt;居然有一个 &lt;code&gt;JS&lt;/code&gt; 文件达到了 &lt;code&gt;2.3MB&lt;/code&gt;，这显然是不合理的，纵使网站优化再好，加载很慢就会导致用户的不耐烦。&lt;/p&gt;
&lt;h4 id=&quot;关于代码优化&quot;&gt;关于代码优化&lt;/h4&gt;
&lt;p&gt;得益于现在移动端 &lt;code&gt;CPU&lt;/code&gt; 的高速发展，甚至有些媲美桌面端处理器，但是用户不可能一直手持最新设备，所有现在不要高估了移动端的处理器，其计算能力和内存大小依旧有限。&lt;/p&gt;
&lt;p&gt;一些未经优化的代码，我们在 &lt;code&gt;Chrome&lt;/code&gt; 下调试可能没觉得有差，但是到移动设备上时，就会出现各种各样的问题，当问题多到一定程度时，用户必然忍受不了，将其抛弃。&lt;/p&gt;
&lt;p&gt;利用 Google 提供的 Lighthouse 插件，我们可以直观的分析一个网站的优劣，以及优化点，让我们有方向的去改进：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/13/16a12999a1026799?w=1760&amp;amp;h=1724&amp;amp;f=jpeg&amp;amp;s=275105&quot;/&gt;&lt;/p&gt;
&lt;p&gt;嗯，再看看我们的掘金（还是挺不错滴）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/13/16a12999b960bbd1?w=1742&amp;amp;h=1732&amp;amp;f=jpeg&amp;amp;s=282022&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;优化关乎用户成本&quot;&gt;优化关乎用户成本&lt;/h3&gt;
&lt;p&gt;这是一个最好的时代，所有的一切都在迅速发展；这是一个最坏的时代，渐渐地越来越多的人们跟不上时代的步伐（比如我们的父母，哎）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;未来一定是移动的世界。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;根据 &lt;a href=&quot;http://gs.statcounter.com/platform-market-share/desktop-mobile-tablet&quot;&gt;statcounter&lt;/a&gt; 统计，全球范围内，移动端设备占据了较大比例，这一比例在中国更大，甚至占到了 &lt;code&gt;70%-80%&lt;/code&gt;，我们要记住，绝大多数用户都是通过 &lt;code&gt;LTE、4G、3G&lt;/code&gt; 访问网络，在 2017 年，Ben Schwarz做出真实网络与优化的调查：&lt;a href=&quot;https://building.calibreapp.com/beyond-the-bubble-real-world-performance-9c991dcd5342&quot;&gt;Beyond the Bubble: Real world performance&lt;/a&gt;&lt;br/&gt;显示，愈加成熟的网络建设背后，用户数据流量的成本正在逐渐下滑，到了 5G 时代又是另一番景象，这个我们下面再讨论。&lt;/p&gt;
&lt;p&gt;这一现象表明，几乎任何用户都可以廉价的访问网络，在这个互通互联的时代，网络几乎成为我们生活的必需品。&lt;/p&gt;
&lt;p&gt;另一研究表明，从 2011 年起，网站页面数量就开始稳步增长，其中移动端的 URL 总数甚至超过了桌面端，更多统计数据点击 &lt;a href=&quot;https://beta.httparchive.org/reports/state-of-the-web?start=earliest&amp;amp;end=latest&amp;amp;view=list&quot;&gt;这里&lt;/a&gt; 查看：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/13/16a1299a0f1c14d3?w=2394&amp;amp;h=1410&amp;amp;f=jpeg&amp;amp;s=240456&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/4/13/16a12999b81442c3?w=2306&amp;amp;h=1348&amp;amp;f=jpeg&amp;amp;s=208594&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图统计发现，2011 年起，网站页面数量就开始稳步增长，尤其是近几年，得益于移动端的爆发式增长，桌面端也配套了对应的页面，但是增速仍然低于移动端。&lt;/p&gt;
&lt;p&gt;这一趋势发展下去，意味着我们需要花费更多的流量（貌似现在已经是这样了）。&lt;/p&gt;
&lt;h2 id=&quot;关于如何优化&quot;&gt;关于如何优化&lt;/h2&gt;
&lt;p&gt;性能优化并不是一件很难得事，但也绝对不轻松，做到以下几点便提升性能，这次没有具体的实施细节，只有一些建议。&lt;/p&gt;
&lt;h3 id=&quot;关于资源的加载&quot;&gt;关于资源的加载&lt;/h3&gt;
&lt;p&gt;构建一个高性能高效的 &lt;code&gt;WEBAPP&lt;/code&gt; 最为有效的一个注意点就是，检查用户在进入页面时，到底加载了多少有效的资源，又加载了多少无效的资源。尽管我们可以从 &lt;code&gt;Chrome DevTools&lt;/code&gt; 的 &lt;code&gt;Network&lt;/code&gt; 面板查看所有已加载的资源，但是如果开发者从未关注过，不知该如何下手，可以看看以下几个意见：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果使用网上开源的 &lt;code&gt;UI&lt;/code&gt; 库，例如：&lt;code&gt;Bootstrap&lt;/code&gt;、&lt;code&gt;Antd&lt;/code&gt; 来构建自己的界面，在做之前询问自己是不是一定要用，结合自身的项目需求，但至少应做到按需引入而不是在 &lt;code&gt;app.js&lt;/code&gt; 里全部引入这些样式和组件。另外，若使用 &lt;code&gt;link&lt;/code&gt; 标签来引入资源，这些资源在网站资源加载之前加载，可能会有些阻碍。&lt;/li&gt;
&lt;li&gt;多使用 &lt;code&gt;Flex&lt;/code&gt; 和 &lt;code&gt;Grid&lt;/code&gt; 来进行布局，这两种布局方式可以使用较少的代码来实现简单或复杂的布局。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CSS&lt;/code&gt; 加载是一种阻塞浏览器渲染的资源（以后会聊到），使用 &lt;code&gt;CSS&lt;/code&gt; 框架的消耗某些情况下会导致渲染延迟严重，最好视情况引用资源，加速渲染。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;JavaScript&lt;/code&gt; 库十分方便，但是不一定是必须的。例如 &lt;code&gt;JQuery&lt;/code&gt;，现代浏览器都支持了 &lt;code&gt;querySelector&lt;/code&gt; 和 &lt;code&gt;querySelectorAll&lt;/code&gt; 等，能够快捷的选择元素。&lt;code&gt;addEventListener&lt;/code&gt; 可以轻松的绑定事件。&lt;code&gt;classList&lt;/code&gt;、&lt;code&gt;setAttribute&lt;/code&gt; 和 &lt;code&gt;getAttribute&lt;/code&gt; 提供了类和元素属性的简便方法。如果不得已一定要使用库，请选择合适并且占用空间较小的替代产品，例如使用 &lt;code&gt;dayjs&lt;/code&gt; 来代替 &lt;code&gt;moment.js&lt;/code&gt;、&lt;code&gt;Zepto&lt;/code&gt; 代替 &lt;code&gt;JQuery&lt;/code&gt; 、 &lt;code&gt;Preact&lt;/code&gt; 代替 &lt;code&gt;React&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;得益于网络条件日益变好和 &lt;code&gt;WEBAPP&lt;/code&gt; 的迅猛发展，现在很多一部分企业选择 &lt;code&gt;SPA&lt;/code&gt; 作为首选，此类应用通常需要加载大量的&lt;code&gt;JavaScript&lt;/code&gt;，例如上面的某锤科技。根据 Addy Osmani 发布的文章 &lt;a href=&quot;https://medium.com/dev-channel/the-cost-of-javascript-84009f51e99e&quot;&gt;The Cost Of JavaScript&lt;/a&gt; 分析发现，此类资源必须经过下载、解析、编译和执行这一过程，浏览器会花费很长时间解析/编译代码，严重时会严重延迟用户与网站交互的时间。因此网站发送的 &lt;code&gt;JavaScript&lt;/code&gt; 越多，网站进行交互之前解析和编译它所需的时间就越长。但是这并不是说 &lt;code&gt;SPA&lt;/code&gt; 不可取，合理使用 &lt;code&gt;HTTP 缓存&lt;/code&gt;或者 &lt;code&gt;Service Worker&lt;/code&gt;，相比传统的多页面网站，经过优化的 &lt;code&gt;SPA&lt;/code&gt; 网站往往能提供更好的用户体验。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;关于资源的传输&quot;&gt;关于资源的传输&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;迁移至 &lt;code&gt;HTTP2&lt;/code&gt;，相比&lt;code&gt;HTTP1.1&lt;/code&gt;，&lt;code&gt;HTTP2&lt;/code&gt; 能够提升至少 50% 资源的获取速度，并解决 &lt;code&gt;HTTP1.1&lt;/code&gt; 固有的性能问题，例如并发请求数的限制、缺乏标头压缩。&lt;/li&gt;
&lt;li&gt;在上面用户成本那里统计图可以看出来，现代网站的大小也在逐渐增加，在 &lt;code&gt;HTTP1&lt;/code&gt; 中， 由于并发请求数量的限制（浏览器通常是 6 个），常见的做法是将 &lt;code&gt;CSS&lt;/code&gt; 和 &lt;code&gt;JavaScript&lt;/code&gt; 捆绑打包成较大的 &lt;code&gt;bundle&lt;/code&gt;，但是这么做及其影响资源的加载，对性能造成不利的影响。而在 &lt;code&gt;HTTP2&lt;/code&gt; 之后不需要考虑此问题，因为 &lt;code&gt;HTTP2&lt;/code&gt; 采用流传输，可以一次请求多个文件，极大的提升了性能，赶紧让后端小伙伴支持 &lt;code&gt;HTTP2&lt;/code&gt; 吧！&lt;/li&gt;
&lt;li&gt;采用 &lt;code&gt;Webpack&lt;/code&gt; 代码拆分技术，仅下载目前需要用到的脚本，合理的拆分模块并且合理利用 &lt;code&gt;HTTP1.1&lt;/code&gt; 协议传输，同样能够大幅提升加载速度。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;关于资源的大小&quot;&gt;关于资源的大小&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;压缩 &lt;code&gt;HTML&lt;/code&gt;，&lt;code&gt;CSS&lt;/code&gt;，&lt;code&gt;JS&lt;/code&gt;，充分利用 &lt;code&gt;Webpack&lt;/code&gt; 的能力，将各种资源打包压缩，这会大大减少资源的大小，而且不会影响功能。&lt;/li&gt;
&lt;li&gt;利用 &lt;a href=&quot;https://www.npmjs.com/package/uglify-js&quot;&gt;&lt;code&gt;UglifyJS&lt;/code&gt;&lt;/a&gt; 将 &lt;code&gt;JS&lt;/code&gt; 的内容丑化（变量名压缩），它会通过缩短变量名和函数名来节省空间。&lt;/li&gt;
&lt;li&gt;利用 &lt;a href=&quot;https://github.com/svg/svgo&quot;&gt;&lt;code&gt;SVGO&lt;/code&gt;&lt;/a&gt; 优化 &lt;code&gt;SVG&lt;/code&gt; 文件。&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;GZIP&lt;/code&gt; 方式进行资源再次压缩。但是请记住，压缩能只能加快资源加载速度，并不是解决性能问题的万能方法。&lt;/li&gt;
&lt;li&gt;如果有充足的时间，可以利用 &lt;code&gt;WebP&lt;/code&gt; 格式代替 &lt;code&gt;JPEG&lt;/code&gt; 或者 &lt;code&gt;PNG&lt;/code&gt;，它能使用及其少量的数据保持和传统图片格式一样的高质量水平。&lt;/li&gt;
&lt;li&gt;使用 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images&quot;&gt;自适应图片&lt;/a&gt;。最简单的，使用 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签中的 &lt;code&gt;srcset&lt;/code&gt; 属性，以指定浏览器可以选择的一组图像。&lt;/li&gt;
&lt;li&gt;使用视频而不是 &lt;code&gt;GIF&lt;/code&gt;。同等画质下，视频大小会比 &lt;code&gt;GIF&lt;/code&gt; 小 80% 左右。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;关于-5g-的到来&quot;&gt;关于 5G 的到来&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/5g%E7%BD%91%E7%BB%9C/11023660?fr=aladdin&quot;&gt;什么是 5G ？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;写下这篇文章的时候，第一批支持 5G 的手机已经发布了。&lt;/p&gt;
&lt;p&gt;在实验室测试结果上看，5G 的速度是 4G 的 65000 倍，能够直接实时传输 4K 流媒体，同时，5G 网络将具有接近零延迟。4G 的平均延迟 50 毫秒，当切割到 5G 后，只有 1 毫秒，这是 GSMA 设定的基准。&lt;/p&gt;
&lt;p&gt;5G 的来临能改变很多行业，例如，视频直播互动，云，虚拟现实、增强现实，前端等行业，同时同等流量下的资费肯定愈发变低，带宽问题也可能不再是问题了。&lt;/p&gt;
&lt;p&gt;随着技术的升级，&lt;code&gt;HTTP2&lt;/code&gt; 也一定会越来越普遍，文件大小和数量可能不再是问题，以后优化的重点可能就是对应于浏览器（客户端）的优化，如何提升用户的使用体验可能是那个时候最重要的吧。&lt;/p&gt;
&lt;p&gt;由于传输技术的巨大升级，一些很酷的客户端技术未来将可能在前端实现，随用随访问，比如 &lt;code&gt;CAD&lt;/code&gt; 制图，&lt;code&gt;power bi&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;浏览器的地位将越来越重要。&lt;/p&gt;
&lt;p&gt;目前来说，&lt;code&gt;4G&lt;/code&gt; 的带宽已经足够，&lt;code&gt;5G&lt;/code&gt; 的到来也只是加快了资源加载速度，最终阻碍 &lt;code&gt;WebApp&lt;/code&gt; 的还是用户体验的问题，是有限的显示效果，不流畅的滑动，&lt;code&gt;Native&lt;/code&gt; 硬件支持不完善，底下的性能等等，才是最重要的原因。&lt;/p&gt;
&lt;h2 id=&quot;关于前端的未来&quot;&gt;关于前端的未来&lt;/h2&gt;
&lt;p&gt;这几年前端层出不穷的框架技术让人有一种学不动的感觉，但是这大多是都是围绕着浏览器而进行的。&lt;/p&gt;
&lt;p&gt;在我看来，其实就分两个端，客户端和服务端。一个和用户打交道，一个和服务器打交道而已。&lt;/p&gt;
&lt;p&gt;真正让人兴奋不已的技术革新，&lt;code&gt;Flutter&lt;/code&gt;、&lt;code&gt;RN&lt;/code&gt;、&lt;code&gt;WebAssembly&lt;/code&gt;、&lt;code&gt;PWA&lt;/code&gt; 等技术让人眼前一亮； &lt;code&gt;nodeJS&lt;/code&gt; 包揽后端一部分功能，让人心花怒放； &lt;code&gt;小程序&lt;/code&gt; 这种于 &lt;code&gt;APP&lt;/code&gt; 之内的微小应用即用即开的能力。&lt;/p&gt;
&lt;p&gt;未来&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Rxjs&lt;/code&gt; 可以应对低延迟和万物互联的复杂异步&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Web Worker&lt;/code&gt; 不阻塞主线程，高刷新率的渲染页面&lt;/li&gt;
&lt;li&gt;5G 的低延迟意味着渲染交给服务器没有问题，打开网页玩大型主机游戏也不是梦想&lt;/li&gt;
&lt;li&gt;随着浏览器的更新，&lt;code&gt;WebGL&lt;/code&gt;/&lt;code&gt;OpenGL&lt;/code&gt;/&lt;code&gt;Canvas&lt;/code&gt; 的能力被完全挖掘出来，&lt;code&gt;Web 3D&lt;/code&gt;、&lt;code&gt;Web VR&lt;/code&gt;、&lt;code&gt;可视化&lt;/code&gt;将变成主流，图像和动画交互将是个长期热点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总之，前端的路是光明的。&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 07:32:00 +0000</pubDate>
<dc:creator>梁音</dc:creator>
<og:description>聊聊关于性能优化（一） 隔了许久都没有更新博客，前一阵子是因为忙其他事去了，现在想写点什么，但是思前想后不知道该写些什么，这是这个系列的第一篇，这篇文章没有干货，只是聊聊关于前端优化，关于5G的到来，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liangyin/p/10875915.html</dc:identifier>
</item>
<item>
<title>PostgreSQL 务实应用（四/5）JSON - 三人行工作室</title>
<link>http://www.cnblogs.com/timeddd/p/10875808.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/timeddd/p/10875808.html</guid>
<description>&lt;p&gt;JSON 可谓风靡互联网，在数据交换使用上，其优势特别明显，其结构简洁、可读易读、形式灵活。很多 API 接口的数据都采用 JSON 来表示。&lt;/p&gt;
&lt;p&gt;PostgreSQL 对 JSON 提供了良好的支持。具体的相关函数可参考：&lt;a href=&quot;https://www.cnblogs.com/alianbog/p/5658156.html&quot;&gt;JSON类型和函数&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从使用的角度而言，个人觉得常见的应用场景为：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;读取单个 JSON 的属性值&lt;/li&gt;
&lt;li&gt;遍历单个 JSON 的所有属性&lt;/li&gt;
&lt;li&gt;遍历一个 JSON 数组&lt;/li&gt;
&lt;li&gt;创建一个 JSON 作为返回值&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;之所以仅这些简单的场景，原因在于，在应用中使用高级语言处理 JSON 与在数据库中使用那些高级的 JSON 函数相比，从操作上和可读性上均爽很多。在不支持 JSON 的数据库中，我们也常使用单个文本字段存储 JSON 字符串，然后在应用中加以解析处理。&lt;/p&gt;
&lt;h2 id=&quot;四个场景&quot;&gt;四个场景&lt;/h2&gt;
&lt;p&gt;我们以以下的 JSON 字符串作为输入，来了解 PostgreSQL 在各场景中的应用实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
    &quot;label&quot;: {
        &quot;names&quot;: [&quot;Amy&quot;, &quot;Kala&quot;, &quot;Lily&quot;]
    },
    &quot;color&quot;: &quot;red&quot;,
    &quot;count&quot;: 3
}

// 写成一行即是
{&quot;label&quot;:{&quot;names&quot;:[&quot;Amy&quot;,&quot;Kala&quot;,&quot;Lily&quot;]},&quot;color&quot;:&quot;red&quot;,&quot;count&quot;:3}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;读取属性&quot;&gt;1.读取属性&lt;/h3&gt;
&lt;p&gt;首先，通过下面的表格，感受一下 JavaScript 与 PostgreSQL 中读取 color 属性与 label 属性中 names 的第二个值的形式。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;12&quot;&gt;&lt;td&gt;定义&lt;/td&gt;
&lt;td&gt;var jsonObj = {&quot;label&quot;:{&quot;names&quot;:[&quot;Amy&quot;,&quot;Kala&quot;,&quot;Lily&quot;]}, &quot;color&quot;:&quot;red&quot;,&quot;count&quot;:3};&lt;/td&gt;
&lt;td&gt;jsonObj := '{&quot;label&quot;:{&quot;names&quot;:[&quot;Amy&quot;,&quot;Kala&quot;,&quot;Lily&quot;]}, &quot;color&quot;:&quot;red&quot;,&quot;count&quot;:3}'::json;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;读取 JSON 的 color 属性&lt;/td&gt;
&lt;td&gt;jsonObj.color&lt;/td&gt;
&lt;td&gt;jsonObj -&amp;gt; 'color'&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;读取 JSON 的 label 中 names 的第二个值&lt;/td&gt;
&lt;td&gt;jsonObj.label.names[1]&lt;/td&gt;
&lt;td&gt;jsonObj -&amp;gt; 'label' -&amp;gt; 'names' -&amp;gt; 1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;在 PostgreSQL 中我们可以使用以下语句逐层指定属性路径（属性名称需要使用字符串需单引号，数组索引使用数字）来获取值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- 取得 color 属性
SELECT '{&quot;label&quot;:{&quot;names&quot;:[&quot;Amy&quot;,&quot;Kala&quot;,&quot;Lily&quot;]},&quot;color&quot;:&quot;red&quot;,&quot;count&quot;:3}'::json 
       -&amp;gt; 'color';

-- 取得 label 属性下的 names 的第二个值
SELECT '{&quot;label&quot;:{&quot;names&quot;:[&quot;Amy&quot;,&quot;Kala&quot;,&quot;Lily&quot;]},&quot;color&quot;:&quot;red&quot;,&quot;count&quot;:3}'::json 
       -&amp;gt; 'label' -&amp;gt; 'names' -&amp;gt; 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt; 此时取得的值仍然为 json 类型，如果需要取得值的文本形式，则把最后一个 &quot;-&amp;gt;&quot; 变成 &quot;-&amp;gt;&amp;gt;&quot; 即可。&lt;/p&gt;
&lt;p&gt;当然，路径的表示，也可以通过 #&amp;gt; '{label,names,1}' 的形式表示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT '{&quot;label&quot;:{&quot;names&quot;:[&quot;Amy&quot;,&quot;Kala&quot;,&quot;Lily&quot;]},&quot;color&quot;:&quot;red&quot;,&quot;count&quot;:3}'::json 
       #&amp;gt; '{label,names,1}';&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;遍历属性&quot;&gt; 2.遍历属性&lt;/h3&gt;
&lt;p&gt;使用 json_each 函数，即可返回属性键值对的数据集，数据集包括两列，key 表示属性，value 表示属性值。如下语句输出所有结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DO $$
DECLARE 
    lv_row record; 
    jsonObj json := '{&quot;label&quot;:{&quot;names&quot;:[&quot;Amy&quot;,&quot;Kala&quot;,&quot;Lily&quot;]},&quot;color&quot;:&quot;red&quot;,&quot;count&quot;:3}'::json;
BEGIN   
    FOR lv_row IN SELECT * FROM json_each(jsonObj) LOOP  
        raise notice 'key is %, value is %', lv_row.key, lv_row.value;
    END LOOP;  
END $$;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;p&gt;NOTICE: key is label, value is {&quot;names&quot;:[&quot;Amy&quot;,&quot;Kala&quot;,&quot;Lily&quot;]}&lt;/p&gt;
&lt;p&gt;NOTICE: key is color, value is &quot;red&quot;&lt;/p&gt;
&lt;p&gt;NOTICE: key is count, value is 3&lt;/p&gt;
&lt;h3 id=&quot;遍历数组&quot;&gt;3.遍历数组&lt;/h3&gt;
&lt;p&gt;通过使用 json_array_length 函数获取数组的长度，然后根据索引遍历整个数组即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DO $$
DECLARE 
    lv_row record; 
    lv_size int;
    jsonObj json := '{&quot;label&quot;:{&quot;names&quot;:[&quot;Amy&quot;,&quot;Kala&quot;,&quot;Lily&quot;]},&quot;color&quot;:&quot;red&quot;,&quot;count&quot;:3}'::json;
BEGIN
    -- 取得label 下names 这个json数组
    jsonObj := jsonObj #&amp;gt; '{label,names}';
    -- 取得数组的长度
    lv_size := json_array_length(jsonObj);
    -- 按索引遍历整个数组
    FOR i IN 0..lv_size-1 LOOP
        raise notice '%', jsonObj -&amp;gt; i;
    END LOOP;
END $$;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;NOTICE: &quot;Amy&quot;&lt;/p&gt;
&lt;p&gt;NOTICE: &quot;Kala&quot;&lt;/p&gt;
&lt;p&gt;NOTICE: &quot;Lily&quot; &lt;/p&gt;
&lt;h3 id=&quot;创建一个-json&quot;&gt;4.创建一个 JSON&lt;/h3&gt;
&lt;p&gt;使用 json_build_object 函数，传递  key, value 成对的参数即可创建一个 json，如以下语句形成一个 api 常用的返回执行情况的 json。 &lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT json_build_object('code', 200, 'err_msg', 'run success!');&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;应用示例&quot;&gt;应用示例&lt;/h2&gt;
&lt;p&gt;我们以填写学生地址为例，传递给存储过程的是一个 json 数组，每个数组中的 json 对象包括了学生标识与地址信息。&lt;/p&gt;
&lt;p&gt;以下语句创建数据表&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;-- student_id 学生标识, address 地址
CREATE TABLE student_address (student_id varchar(10) PRIMARY KEY, address varchar(100));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/17509417-85f1cef3db56c37b.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;image.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下为处理过程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CREATE OR REPLACE FUNCTION save_student_addresses_json( 
    v_array_json json)
    RETURNS json
    LANGUAGE 'plpgsql' 
AS $$
DECLARE 
    lv_row_json json; 
    lv_length int;
    lv_field_student_id varchar;
    lv_field_address    varchar;
BEGIN   
    -- 取得数组的长度
    lv_length := json_array_length(v_array_json);
    FOR i IN 0..lv_length-1 LOOP
        -- 取得第 i 行的 json 值
        lv_row_json := v_array_json -&amp;gt; i;
        lv_field_student_id := lv_row_json -&amp;gt;&amp;gt; 'student_id';
        lv_field_address := lv_row_json -&amp;gt;&amp;gt; 'address';

        -- 插入学生地址信息，如果存在则更新地址
        INSERT INTO student_address (student_id, address)
        VALUES (lv_field_student_id, lv_field_address)
            ON CONFLICT (student_id) 
        DO UPDATE SET address = excluded.address;
    END LOOP; 

    RETURN json_build_object(
        'err_code', 200, 
        'err_msg', '保存或更新 ' || lv_length || ' 条记录'
    ); 
end 
$$&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们执行以下操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SELECT save_student_addresses_json(
    '[
     {&quot;student_id&quot;:&quot;01&quot;,&quot;address&quot;:&quot;街道A&quot;},
     {&quot;student_id&quot;:&quot;02&quot;,&quot;address&quot;:&quot;街道B&quot;}
    ]'
);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：{&quot;err_code&quot;:200,&quot;err_msg&quot;:&quot;保存或更新 2 条记录&quot;}&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/17509417-db8fc01bd9c94c8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;小结一下&quot;&gt;小结一下&lt;/h2&gt;
&lt;p&gt;PostgreSQL 对 JSON 的操作支持特性很丰富，但文档中那么多函数一下映入眼帘，让人觉得复杂凌乱。本文从简单易理解的几个应用场景出发，希望能先爽上一把，而后再细细深入。I love PostgreSQL!&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 07:15:00 +0000</pubDate>
<dc:creator>三人行工作室</dc:creator>
<og:description>JSON 可谓风靡互联网，在数据交换使用上，其优势特别明显，其结构简洁、可读易读、形式灵活。很多 API 接口的数据都采用 JSON 来表示。 PostgreSQL 对 JSON 提供了良好的支持。具</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/timeddd/p/10875808.html</dc:identifier>
</item>
<item>
<title>Go语言——没有对象的面向对象编程 - 欣欣念念</title>
<link>http://www.cnblogs.com/xxnn/p/10875693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xxnn/p/10875693.html</guid>
<description>&lt;h3 id=&quot;本文译自steve-francia在oscon-2014的一个ppt原作请前往httpsspf13.compresentationgo-for-object-oriented-programmers&quot;&gt;本文译自Steve Francia在OSCON 2014的一个PPT，原作请前往：&lt;a href=&quot;https://spf13.com/presentation/go-for-object-oriented-programmers/&quot; class=&quot;uri&quot;&gt;https://spf13.com/presentation/go-for-object-oriented-programmers/&lt;/a&gt;&lt;/h3&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对我来说，最吸引我的不是Go拥有的特征，而是那些被故意遗漏的特征。 —— txxxxd&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;为什么你要创造一种从理论上来说，并不令人兴奋的语言？&lt;br/&gt;因为它非常有用。 —— Rob Pike&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;要探讨Go语言中的对象，我们先搞清楚一个问题：&lt;/p&gt;
&lt;h3 id=&quot;go语言有对象吗&quot;&gt;Go语言有对象吗？&lt;/h3&gt;
&lt;p&gt;从语法上来说，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Go中没有类（Classes）&lt;/li&gt;
&lt;li&gt;Go中没有“对象”（Objects）&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;对象是一种抽象的数据类型，拥有状态（数据）和行为（代码）。 —— Steve Francia&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Go语言中，我们这样声明一个类型：&lt;/p&gt;
&lt;h5 id=&quot;类型声明struct&quot;&gt;类型声明（Struct）&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Rect struct {
    width  int
    height int
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;然后我们可以给这个struct声明一个方法&quot;&gt;然后我们可以给这个Struct声明一个方法&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (r *Rect) Area() int {
    return r.width * r.height
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;用起来就像这样&quot;&gt;用起来就像这样&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    r := Rect{width: 10, height: 5}
    fmt.Println(&quot;area: &quot;, r.Area())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们不光可以声明结构体类型，我们可以声明任何类型。比如一个切片：&lt;/p&gt;
&lt;h5 id=&quot;类型声明slice&quot;&gt;类型声明（Slice）&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Rects []*Rect&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;同样也可以给这个类型声明一个方法&quot;&gt;同样也可以给这个类型声明一个方法&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (rs Rects) Area() int {
    var a int
    for _, r := range rs {
        a += r.Area()
    }
    return a
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;用起来&quot;&gt;用起来&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    r := &amp;amp;Rect{width: 10, height: 5}
    x := &amp;amp;Rect{width: 7, height: 10}
    rs := Rects{r, x}
    fmt.Println(&quot;r's area: &quot;, r.Area())
    fmt.Println(&quot;x's area: &quot;, x.Area())
    fmt.Println(&quot;total area: &quot;, rs.Area())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/G1OWXPGvc3&quot; class=&quot;uri&quot;&gt;https://play.golang.org/p/G1OWXPGvc3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们甚至可以声明一个函数类型&lt;/p&gt;
&lt;h5 id=&quot;类型声明func&quot;&gt;类型声明（Func）&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Foo func() int&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;同样的给这个函数类型声明一个方法&quot;&gt;同样的，给这个（函数）类型声明一个方法&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (f Foo) Add(x int) int {
    return f() + x
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;然后用起来&quot;&gt;然后用起来&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    var x Foo

    x = func() int { return 1 }

    fmt.Println(x())
    fmt.Println(x.Add(3))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/YGrdCG3SlI&quot; class=&quot;uri&quot;&gt;https://play.golang.org/p/YGrdCG3SlI&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过上边的例子，这样看来，其实&lt;/p&gt;
&lt;h3 id=&quot;go有对象&quot;&gt;Go有“对象”&lt;/h3&gt;
&lt;p&gt;那么我们来看看&lt;/p&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果一种语言包含对象的基本功能：标识、属性和特性，则通常认为它是基于对象的。&lt;br/&gt;如果一种语言是基于对象的，并且具有多态性和继承性，那么它被认为是面向对象的。 —— Wikipedia&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一条，我们在上边的例子看到了，go中的type declaration其实满足了Go语言是基于对象的。那么，&lt;/p&gt;
&lt;h3 id=&quot;go是基于对象的它是面向对象的吗&quot;&gt;Go是基于对象的，它是面向对象的吗？&lt;/h3&gt;
&lt;p&gt;我们来看看关于第二条，继承性和多态性&lt;/p&gt;
&lt;h3 id=&quot;继承&quot;&gt;继承&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;提供对象的复用&lt;/li&gt;
&lt;li&gt;类是按层级创建的&lt;/li&gt;
&lt;li&gt;继承允许一个类中的结构和方法向下传递这种层级&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;go中实现继承的方式&quot;&gt;Go中实现继承的方式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Go明确地避免了继承&lt;/li&gt;
&lt;li&gt;Go严格地遵循了符合继承原则的组合方式&lt;/li&gt;
&lt;li&gt;Go中通过嵌入类型来实现组合&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;组合&quot;&gt;组合&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;提供对象的复用&lt;/li&gt;
&lt;li&gt;通过包含其他的对象来声明一个对象&lt;/li&gt;
&lt;li&gt;组合使一个类中的结构和方法&lt;strong&gt;被拉进&lt;/strong&gt;其他类中&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;继承把“知识”向下传递，组合把“知识”向上拉升 —— Steve Francia&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;嵌入类型&quot;&gt;嵌入类型&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Person struct {
    Name string
    Address
}

type Address struct {
    Number string
    Street string
    City   string
    State  string
    Zip    string
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;给被嵌入的类型声明一个方法&quot;&gt;给被嵌入的类型声明一个方法&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (a *Address) String() string {
    return a.Number + &quot; &quot; + a.Street + &quot;\n&quot; + a.City + &quot;, &quot; + a.State + &quot; &quot; + a.Zip + &quot;\n&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;使用组合字面量声明一个struct&quot;&gt;使用组合字面量声明一个Struct&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    p := Person{
        Name: &quot;Steve&quot;,
        Address: Address{
            Number: &quot;13&quot;,
            Street: &quot;Main&quot;,
            City:   &quot;Gotham&quot;,
            State:  &quot;NY&quot;,
            Zip:    &quot;01313&quot;,
        },
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;跑起来试试&quot;&gt;跑起来试试&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    p := Person{
        Name: &quot;Steve&quot;,
        Address: Address{
            Number: &quot;13&quot;,
            Street: &quot;Main&quot;,
            City:   &quot;Gotham&quot;,
            State:  &quot;NY&quot;,
            Zip:    &quot;01313&quot;,
        },
    }
    fmt.Println(p.String())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/9beVY9jNlW&quot; class=&quot;uri&quot;&gt;https://play.golang.org/p/9beVY9jNlW&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;升级&quot;&gt;升级&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;升级会检查一个内部类型是否能满足需要，并“升级”它&lt;/li&gt;
&lt;li&gt;内嵌的数据域和方法会被“升级”&lt;/li&gt;
&lt;li&gt;升级发生在运行时而不是声明时&lt;/li&gt;
&lt;li&gt;被升级的方法被认为是符合接口的&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;升级不是重载&quot;&gt;升级不是重载&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (a *Address) String() string {
    return a.Number + &quot; &quot; + a.Street + &quot;\n&quot; + a.City + &quot;, &quot; + a.State + &quot; &quot; + a.Zip + &quot;\n&quot;
}

func (p *Person) String() string {
    return p.Name + &quot;\n&quot; + p.Address.String()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;外部结构的方法和内部结构的方法都是可见的&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    p := Person{
        Name: &quot;Steve&quot;,
        Address: Address{
            Number: &quot;13&quot;,
            Street: &quot;Main&quot;,
            City:   &quot;Gotham&quot;,
            State:  &quot;NY&quot;,
            Zip:    &quot;01313&quot;,
        },
    }
    fmt.Println(p.String())
    fmt.Println(p.Address.String())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/Aui0nGa5Xi&quot; class=&quot;uri&quot;&gt;https://play.golang.org/p/Aui0nGa5Xi&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;这两个类型仍然是两个不同的类型&quot;&gt;这两个类型仍然是两个不同的类型&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func isValidAddress(a Address) bool {
    return a.Street != &quot;&quot;
}

func main() {
    p := Person{
        Name: &quot;Steve&quot;,
        Address: Address{
            Number: &quot;13&quot;,
            Street: &quot;Main&quot;,
            City:   &quot;Gotham&quot;,
            State:  &quot;NY&quot;,
            Zip:    &quot;01313&quot;,
        },
    }

    // 这里不能用 p (Person类型) 作为 Address类型的IsValidAddress参数
    // cannot use p (type Person) as type Address in argument to isValidAddress
    fmt.Println(isValidAddress(p))
    fmt.Println(isValidAddress(p.Address))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/KYjXZxNBcQ&quot; class=&quot;uri&quot;&gt;https://play.golang.org/p/KYjXZxNBcQ&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;升级不是子类型&quot;&gt;升级不是子类型&lt;/h5&gt;
&lt;h3 id=&quot;多态&quot;&gt;多态&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为不同类型的实体提供单一接口&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;通常通过泛型、重载和/或子类型实现&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;go中实现多态的方式&quot;&gt;Go中实现多态的方式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Go明确避免了子类型和重载&lt;/li&gt;
&lt;li&gt;Go尚未提供泛型&lt;/li&gt;
&lt;li&gt;Go的接口提供了多态功能&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;接口&quot;&gt;接口&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;接口就是（要实现某种功能所需要提供的）方法的列表&lt;/li&gt;
&lt;li&gt;结构上的类型 vs 名义上的类型&lt;/li&gt;
&lt;li&gt;“如果什么东西能做这件事，那么就可以在这使用它”&lt;/li&gt;
&lt;li&gt;惯例上就叫它 某种东西&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Go语言采用了鸭式辩型，和JavaScript类似。鸭式辩型的思想是，只要一个动物走起路来像鸭子，叫起来像鸭子，那么就认为它是一只鸭子。&lt;br/&gt;也就是说，只要一个对象提供了和某个接口同样（在Go中就是相同签名）的方法，那么这个对象就可以当做这个接口来用。并不需要像Java中一样显式的实现（implements）这个接口。&lt;/p&gt;
&lt;h5 id=&quot;接口声明&quot;&gt;接口声明&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Shaper interface{ 
    Area() int 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;然后把这个接口作为一个参数类型&quot;&gt;然后把这个接口作为一个参数类型&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func Describe(s Shaper) {
    fmt.Println(&quot;Area is: &quot;, s.Area())
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;这样用&quot;&gt;这样用&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    r := &amp;amp;Rect{width: 10, height: 5}
    x := &amp;amp;Rect{width: 7, height: 10}
    rs := &amp;amp;Rects{r, x}
    Describe(r)
    Describe(x)
    Describe(rs)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://play.golang.org/p/WL77LihUwi&quot; class=&quot;uri&quot;&gt;https://play.golang.org/p/WL77LihUwi&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;“如果你可以重新做一次Java，你会改变什么？”&lt;br/&gt;“我会去掉类class，” 他回答道。&lt;br/&gt;在笑声消失后，他解释道，真正的问题不是类class本身，而是“实现”的继承（类之间extends的关系）。接口的继承（implements的关系）是更可取的方式。&lt;br/&gt;只要有可能，你就应该尽可能避免“实现”的继承。&lt;br/&gt;—— James Gosling（Java之父）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;go的接口是基于实现的而不是基于声明的&quot;&gt;Go的接口是基于实现的，而不是基于声明的&lt;/h3&gt;
&lt;p&gt;这也就是上边所说的鸭式辩型&lt;/p&gt;
&lt;h3 id=&quot;接口的力量&quot;&gt;接口的力量&lt;/h3&gt;
&lt;h5 id=&quot;io.reader&quot;&gt;io.Reader&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Reader interface {
    Read(p []byte) (n int, err error)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Interface&lt;/li&gt;
&lt;li&gt;Read方法读取最多len(p) bytes的数据到字节数组p中&lt;/li&gt;
&lt;li&gt;返回读取的字节数和遇到的任何error&lt;/li&gt;
&lt;li&gt;并不规定Read()方法如何实现&lt;/li&gt;
&lt;li&gt;被诸如 os.File, bytes.Buffer, net.Conn, http.Request.Body等等使用&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;io.writer&quot;&gt;io.Writer&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Writer interface {
    Write(p []byte) (n int, err error)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Interface&lt;/li&gt;
&lt;li&gt;Write方法写入最多len(p) bytes的数据到字节数组p中&lt;/li&gt;
&lt;li&gt;返回写入的字节数和遇到的任何error&lt;/li&gt;
&lt;li&gt;并不规定Write()方法如何实现&lt;/li&gt;
&lt;li&gt;被诸如 os.File, bytes.Buffer, net.Conn, http.Request.Body等等使用&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;io.reader-使用&quot;&gt;io.Reader 使用&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func MarshalGzippedJSON(r io.Reader, v interface{}) error {
    raw, err := gzip.NewReader(r)
    if err != nil {
        return err
    }
    return json.NewDecoder(raw).Decode(&amp;amp;v)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;读取一个json.gz文件&quot;&gt;读取一个json.gz文件&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    f, err := os.Open(&quot;myfile.json.gz&quot;)
    if err != nil {
        log.Fatalln(err)
    }
    defer f.Close()
    m := make(map[string]interface{})
    MarshalGzippedJSON(f, &amp;amp;m)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;实用的交互性&quot;&gt;实用的交互性&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;Gzip.NewReader(io.Reader) 只需要传入一个io.Reader接口类型即可&lt;/li&gt;
&lt;li&gt;在files, http requests, byte buffers, network connections, ...任何你创建的东西里都能工作&lt;/li&gt;
&lt;li&gt;在gzip包里不需要任何特殊处理。只要简单地调用Read(n),把抽象的部分留给实现者即可&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;将-http-response-写入文件&quot;&gt;将 http response 写入文件&lt;/h5&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func main() {
    resp, err := http.Get(&quot;...&quot;)
    if err != nil {
        log.Fatalln(err)
    }
    defer resp.Body.Close()
    out, err := os.Create(&quot;filename.ext&quot;)
    if err != nil {
        log.Fatalln(err)
    }
    defer out.Close()
    io.Copy(out, resp.Body) // out io.Writer, resp.Body io.Reader 
}&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;简单比复杂更难：你必须努力使你的思维清晰，使之简单。但最终还是值得的，因为一旦你到了那里，你就可以移山。 —— Steve Jobs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;go简单实用绝妙&quot;&gt;Go简单，实用，绝妙&lt;/h3&gt;
&lt;h3 id=&quot;go做了一些伟大的事情&quot;&gt;Go做了一些伟大的事情&lt;/h3&gt;
</description>
<pubDate>Thu, 16 May 2019 07:02:00 +0000</pubDate>
<dc:creator>欣欣念念</dc:creator>
<og:description>本文译自Steve Francia在OSCON 2014的一个PPT，原作请前往： 'https://spf13.com/presentation/go for object oriented pro</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xxnn/p/10875693.html</dc:identifier>
</item>
<item>
<title>.NET Core 3.0 可回收程序集加载上下文 - YOYOFx</title>
<link>http://www.cnblogs.com/maxzhang1985/p/10875278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/maxzhang1985/p/10875278.html</guid>
<description>&lt;p&gt;.NET诞生以来，程序集的动态加载和卸载都是一个Hack的技术，之前的NetFx都是使用AppDomain的方式去加载程序集，然而AppDomain并没有提供直接卸载一个程序集的API，而是要卸载整个AppDomain才能卸载包含在其中的所有程序集。然而卸载整个CurrentAppDomain会使程序不能工作。可能有人另辟西经，创建别一个AppDomain来加载/卸载程序集，但是由于程序集之间是不能跨域访问的，也导致只能通过Remote Proxy的方式去访问，这样在类型创建和使用上带来了一定的难度也是类型的继承变得相当复杂。&lt;/p&gt;
&lt;p&gt;.NET Core中一直没有AppDomain的支持。但是在.NET Core 3.0中，我最期待的一个特性就是对可收集程序集的支持(Collectible AssemblyLoadContext)。 众所周知.NET Core中一直使用AssemblyLoadContext的API，来进行程序集的动态加载，但是并没有提供Unload的方法，此次升级更新了这方面的能力。&lt;/p&gt;

&lt;p&gt;其实这次AssemblyLoadContext的设计，我认为更像是Java中ClassLoader的翻版，可以说非常类似。在使用过程中自定义AssemblyLoadContext可以内部管理其中的程序集，并对整体Context进行Unload。使用AssemblyLoadContext也可以避免程序集名称和版本的冲突。&lt;/p&gt;

&lt;p&gt;.NET Core 3.0还没有正式版，所有要使用预览版的SDK完成以下实例。我使用的是.NET Core SDK 3.0.100-preview-009812&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;dotnet new globaljson --sdk-version 3.0.100-preview-009812&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AssemblyLoadContext是一个抽象类的，我们需要子类化。下面显示的是我们创建自定义AssemblyLoadContext的方法,实现一个可回收的Context需要在构造器中指定isCollectible: true ：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class CollectibleAssemblyLoadContext : AssemblyLoadContext
{
    public CollectibleAssemblyLoadContext() : base(isCollectible: true)
    { }
 
    protected override Assembly Load(AssemblyName assemblyName)
    {
        return null;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用netstandard2.0创建一个library&quot;&gt;使用netstandard2.0创建一个library&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;
 
namespace SampleLibrary
{
    public class SayHello
    {
        public void Hello(int iteration)
        {
            Console.WriteLine($&quot;Hello {iteration}!&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试loadunload&quot;&gt;测试Load/Unload&lt;/h2&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var context = new CollectibleAssemblyLoadContext();
var assemblyPath = Path.Combine(Directory.GetCurrentDirectory(),&quot;SampleLibrary.dll&quot;);
using (var fs = new FileStream(assemblyPath, FileMode.Open, FileAccess.Read))
{
    var assembly = context.LoadFromStream(fs);

    var type = assembly.GetType(&quot;SampleLibrary.SayHello&quot;);
    var greetMethod = type.GetMethod(&quot;Hello&quot;);

    var instance = Activator.CreateInstance(type);
    greetMethod.Invoke(instance, new object[] { i });
}

context.Unload();

GC.Collect();
GC.WaitForPendingFinalizers();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当执行GC收回后，加载的程序集会被完全的回收。&lt;/p&gt;

&lt;p&gt;　　GitHub：&lt;a href=&quot;https://github.com/maxzhang1985/YOYOFx&quot; class=&quot;uri&quot;&gt;https://github.com/maxzhang1985/YOYOFx&lt;/a&gt; 如果觉还可以请Star下， 欢迎一起交流。&lt;/p&gt;
&lt;p&gt;　　.NET Core 开源学习群：&lt;a href=&quot;http://shang.qq.com/wpa/qunwpa?idkey=1ca46dc1b9884998e93bbbf672d4e7b920cb75529c7295da2ea69b12ef262409&quot;&gt;214741894&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 06:41:00 +0000</pubDate>
<dc:creator>YOYOFx</dc:creator>
<og:description>一、前世今生 .NET诞生以来，程序集的动态加载和卸载都是一个Hack的技术，之前的NetFx都是使用AppDomain的方式去加载程序集，然而AppDomain并没有提供直接卸载一个程序集的API，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/maxzhang1985/p/10875278.html</dc:identifier>
</item>
<item>
<title>MySQL中ORDER BY与LIMIT一起使用（有坑） - 不要乱摸</title>
<link>http://www.cnblogs.com/cjsblog/p/10874938.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/10874938.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.  现象与问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;ORDER BY&lt;/span&gt;排序后，用&lt;span&gt;LIMIT&lt;/span&gt;取前几条，发现返回的结果集的顺序与预期的不一样&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是我遇到的问题：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201905/874963-20190516124757991-444515110.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201905/874963-20190516124820938-1652738322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201905/874963-20190516124841231-223816713.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201905/874963-20190516124855708-1156706043.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到，带&lt;span&gt;LIMIT&lt;/span&gt;与不带&lt;span&gt;LIMIT&lt;/span&gt;的结果与我预期的不一样，而且“很不可思议”，真是百思不得其解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;后来百度了一下，如果&lt;span&gt;order by&lt;/span&gt;的列有相同的值时，mysql会随机选取这些行，为了保证每次都返回的顺序一致可以额外增加一个排序字段（比如：id），用两个字段来尽可能减少重复的概率&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;于是，改成 order by status, id;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201905/874963-20190516133130615-339135233.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;问题虽然是解决了，但还是看看官方文档上怎么说的吧！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.  LIMIT查询优化&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201905/874963-20190516141713703-396404756.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——摘自“LIMIT查询优化”&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;如果你只需要结果集中的指定数量的行，那么请在查询中使用&lt;span&gt;LIMIT&lt;/span&gt;子句，而不是抓取整个结果集并丢弃剩下那些你不要的数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MySQL有时会优化一个包含&lt;span&gt;LIMIT&lt;/span&gt;子句并且没有&lt;span&gt;HAVING&lt;/span&gt;子句的查询：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;MySQL通常更愿意执行全表扫描，但是如果你用&lt;span&gt;LIMIT&lt;/span&gt;只查询几行记录的话，MySQL在某些情况下可能会使用索引。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果你将&lt;span&gt;LIMIT&lt;/span&gt; &lt;em&gt;&lt;strong&gt;row_count&lt;/strong&gt;&lt;/em&gt;子句与&lt;span&gt;ORDER BY&lt;/span&gt;子句组合在一起使用的话，MySQL会在找到排序结果的第一个&lt;em&gt;&lt;strong&gt;row_count&lt;/strong&gt;&lt;/em&gt;行后立即停止排序，而不是对整个结果进行排序。如果使用索引来完成排序，这将非常快。如果必须执行文件排序，则在找到第一个&lt;em&gt;&lt;strong&gt;row_count&lt;/strong&gt;&lt;/em&gt;行之前，选择所有与查询匹配但不包括&lt;span&gt;LIMIT&lt;/span&gt;子句的行，并对其中大部分或所有行进行排序。一旦找到第一个&lt;em&gt;&lt;strong&gt;row_count&lt;/strong&gt;&lt;/em&gt;之后，MySQL不会对结果集的任何剩余部分进行排序。这种行为的一种表现形式是，一个&lt;span&gt;ORDER BY&lt;/span&gt;查询带或者不带LIMIT可能返回行的顺序是不一样的。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果&lt;span&gt;LIMIT&lt;/span&gt; &lt;em&gt;&lt;strong&gt;row_count&lt;/strong&gt;&lt;/em&gt;与&lt;span&gt;DISTINCT&lt;/span&gt;一起使用，一旦找到&lt;em&gt;&lt;strong&gt;row_count&lt;/strong&gt;&lt;/em&gt;惟一的行，MySQL就会停止。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;span&gt;LIMIT&lt;/span&gt; 0 可以快速返回一个空的结果集，这是用来检测一个查询是否有效的一种很有用的方法。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果服务器使用临时表来解析查询，它将使用LIMIT &lt;em&gt;&lt;strong&gt;row_count&lt;/strong&gt;&lt;/em&gt;子句来计算需要多少空间。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;如果&lt;span&gt;ORDER BY&lt;/span&gt;不走索引，而且后面还带了LIMIT的话，那么优化器可能可以避免用一个合并文件，并使用内存中的filesort操作对内存中的行进行排序。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;如果&lt;span&gt;ORDER BY&lt;/span&gt;列有多行具有相同的值，服务器可以自由地以任何顺序返回这些行，并且根据总体执行计划可能以不同的方式返回。换句话说，这些行的排序顺序对于无序列是不确定的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;影响执行计划的一个因素是&lt;span&gt;LIMIT&lt;/span&gt;，因此对于一个&lt;span&gt;ORDER BY&lt;/span&gt;查询而言，带与不带&lt;span&gt;LIMIT&lt;/span&gt;返回的行的顺序可能是不一样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看下面的例子：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201905/874963-20190516134605563-13461548.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;包含&lt;span&gt;LIMIT&lt;/span&gt;可能会影响每一个category行的顺序。例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201905/874963-20190516134801460-1865631074.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你需要确保无论带不带&lt;span&gt;LIMIT&lt;/span&gt;都要以相同的顺序返回，那么你可以在&lt;span&gt;ORDER BY&lt;/span&gt;中包含附加列，以使顺序具有确定性。例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/874963/201905/874963-20190516135103435-218436421.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.  小结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、如果你只需要结果集中的某几行，那么建议使用&lt;span&gt;limit&lt;/span&gt;。这样这样的话可以避免抓取全部结果集，然后再丢弃那些你不要的行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、对于&lt;span&gt;order by&lt;/span&gt;查询，带或者不带&lt;span&gt;limit&lt;/span&gt;可能返回行的顺序是不一样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、如果&lt;span&gt;limit&lt;/span&gt; &lt;strong&gt;&lt;em&gt;row_count&lt;/em&gt;&lt;/strong&gt; 与 &lt;span&gt;order by&lt;/span&gt; 一起使用，那么在找到第一个&lt;em&gt;&lt;strong&gt;row_count&lt;/strong&gt;&lt;/em&gt;就停止排序，直接返回。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、如果&lt;span&gt;order by&lt;/span&gt;列有相同的值，那么MySQL可以自由地以任何顺序返回这些行。换言之，只要&lt;span&gt;order by&lt;/span&gt;列的值不重复，就可以保证返回的顺序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5、可以在&lt;span&gt;order by&lt;/span&gt;子句中包含附加列，以使顺序具有确定性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.  文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/limit-optimization.html&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/refman/5.7/en/&quot;&gt;https://dev.mysql.com/doc/refman/5.7/en/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.mysql.com/doc/&quot;&gt;https://dev.mysql.com/doc/&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 16 May 2019 06:24:00 +0000</pubDate>
<dc:creator>不要乱摸</dc:creator>
<og:description>1. 现象与问题 ORDER BY排序后，用LIMIT取前几条，发现返回的结果集的顺序与预期的不一样 下面是我遇到的问题： 可以看到，带LIMIT与不带LIMIT的结果与我预期的不一样，而且“很不可思</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cjsblog/p/10874938.html</dc:identifier>
</item>
<item>
<title>shell-----数据呈现方式 - 秦广王</title>
<link>http://www.cnblogs.com/jinyuanliu/p/10874010.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinyuanliu/p/10874010.html</guid>
<description>&lt;h2&gt;输入与输出&lt;/h2&gt;
&lt;p&gt;Linux系统将每个对象当作文件处理，这包括输入和输出进程。&lt;br/&gt;Linux用文件描述符来标识每个文件对象。&lt;br/&gt;文件描述符是一个非负整数，可以唯一标识会话中打开的文件。&lt;br/&gt;每个进程一次多可以有九个文件描述符。出于特殊目的，bash shell保留了前三个文件描述符(0、1和2)&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;img-thumbnail&quot; src=&quot;http://www.jxbh.cn/public/kindedit/attached/image/20171109/20171109160631_24309.png&quot; alt=&quot;Linux的标准文件描述符&quot;/&gt;&lt;/p&gt;



&lt;p&gt;这三个特殊文件描述符会处理脚本的输入和输出。&lt;/p&gt;
&lt;p&gt;1、stdin&lt;/p&gt;
&lt;p&gt;STDIN文件描述符代表shell的标准输入&lt;br/&gt;在使用输入重定向符号(&amp;lt;)时，Linux会用重定向指定的文件来替换标准输入文件描述符。 它会读取文件并提取数据，就如同它是键盘上键入的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# cat &amp;lt; one.txt 
one
two
three
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、stdout&lt;/p&gt;
&lt;p&gt;STDOUT文件描述符代表shell的标准输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# date &amp;gt; time.txt
[root@node1 ljy]# more time.txt 
2019年 05月 16日 星期四 10:08:51 CST
[root@node1 ljy]# date &amp;gt;&amp;gt; time.txt   #&amp;gt;&amp;gt;表示追加的意思
[root@node1 ljy]# more time.txt   
2019年 05月 16日 星期四 10:08:51 CST
2019年 05月 16日 星期四 10:09:01 CST
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、stderr&lt;/p&gt;
&lt;p&gt;shell通过特殊的STDERR文件描述符来处理错误消息。&lt;/p&gt;
&lt;p&gt;默认情况下，错误消息也会输出到显示器输出中。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# aaaa 2&amp;gt; err.txt       
[root@node1 ljy]# more err.txt 
-bash: aaaa: 未找到命令

#shell会只定向错误消息而非普通的数据。
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果想要同时定义普通与错误的消息可以用两个重定向符的方式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# ls -al one two 2&amp;gt; err.txt 1&amp;gt; normal.txt
[root@node1 ljy]# more err.txt 
ls: 无法访问two: 没有那个文件或目录
[root@node1 ljy]# more normal.txt 
-rw-r--r-- 1 root root 0 5月  16 10:17 one
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;bash也提供了特殊的重定向符实现这一个效果&amp;amp;&amp;gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# ls -al one two &amp;amp;&amp;gt; ceshi.txt            
[root@node1 ljy]# more ceshi.txt 
ls: 无法访问two: 没有那个文件或目录
-rw-r--r-- 1 root root 0 5月  16 10:17 one
#生成的所有输出都会到同一位置，包括普通与错误。默认错误消息会处于更高的优先级，方便查看。
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;脚本中重定向输出&lt;/h2&gt;
&lt;p&gt; 1、临时重定向&lt;/p&gt;
&lt;p&gt;希望在脚本中生成错误的信息的话，可以单独的一行输出重定向到STDERR。重定向到文件描述时，你必须在文件描述符数字前加一个&amp;amp;符号。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more one.sh 
#!/bin/bash
echo &quot;this is a error message!&quot; &amp;gt;&amp;amp;2
echo &quot;this is a normal message!&quot;
[root@node1 ljy]# sh one.sh 
this is a error message!
this is a normal message!
[root@node1 ljy]# sh one.sh 2&amp;gt; err.log
this is a normal message!
[root@node1 ljy]# more err.log 
this is a error message!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认情况下，Linux会将STDERR导向STDOUT，但是运行脚本时重定向了STDERR，脚本中所有导向STDERR的都会被重新导向。&lt;/p&gt;
&lt;p&gt;2、永久重定向&lt;/p&gt;
&lt;p&gt;如果脚本中有大量数据需要重定向，可以使用exec命令告诉shell在脚本执行期间重定向某个特定文件描述符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more one.sh 
#!/bin/bash
exec 1&amp;gt; normal.txt
exec 2&amp;gt; err.txt
echo &quot;this is a error message!&quot; &amp;gt;&amp;amp;2
echo &quot;this is a normal message!&quot;
[root@node1 ljy]# 
[root@node1 ljy]# sh one.sh 
[root@node1 ljy]# ls
err.txt  normal.txt  one.sh
[root@node1 ljy]# more err.txt 
this is a error message!
[root@node1 ljy]# more normal.txt 
this is a normal message!
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;脚本中重定向输入&lt;/h2&gt;
&lt;p&gt;exec命令允许你将STDIN重定向到linux文件中&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more test   
one 
two
three
[root@node1 ljy]# more ceshi.sh 
#!/bin/bash
exec 0&amp;lt; test
count=1
while read line
do  
  echo &quot;$count:$line&quot;
  count=$[$count + 1]
done
[root@node1 ljy]# sh ceshi.sh 
1:one
2:two
3:three
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;阻止命令输出&lt;/h2&gt;
&lt;p&gt;shell输出到null文件的任何命令都不会被保存！&lt;/p&gt;
&lt;p&gt;在Linux系统中null的标准位置是/dev/null,你重定向到该位置的文件都会被丢掉不会显示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# ls -al &amp;gt; /dev/null 
[root@node1 ljy]# more /dev/null 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也可以将/dev/null作为输入文件，可以用它来快速清空现有文件的数据，而不需要删除后重新创建。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# more test 
one 
two
three
[root@node1 ljy]# cat /dev/null &amp;gt; test 
[root@node1 ljy]# more test
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;创建临时文件&lt;/h2&gt;
&lt;p&gt;系统上的任何账户都有权限读写/tmp目录中的文件&lt;/p&gt;
&lt;p&gt;mktemp可以在本地目录中创建一个临时文件，需要制定一个文件名，末尾需要设置6个X&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[ljy@node1 tmp]$ mktemp ceshi.XXXXXX
ceshi.vyBZEx
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-t选项会强制mktemp命令在系统的临时目录创建文件。&lt;/p&gt;
&lt;p&gt;由于mktemp命令返回来了全路径名，你可以在Linux系统的任何目录下引用该临时文件，不需要管目录在哪。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[ljy@node1 /]$ mktemp -t ceshi.XXXXXX
/tmp/ceshi.eSU3MD
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;-d选项告诉mktemp命令来创建一个临时目录而不是一个文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[ljy@node1 tmp]$ mktemp -d ceshi.XXXXXX
ceshi.9JVceD
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;记录消息&lt;/h2&gt;
&lt;p&gt;tee命令相当于管道的一个T型接头。他将从STDIN过来的数据同时发往两处，一处是STDOUT，另一处是tee命令行所指定的文件名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
[root@node1 ljy]# date | tee ceshi
2019年 05月 16日 星期四 13:57:40 CST
[root@node1 ljy]# more ceshi
2019年 05月 16日 星期四 13:57:40 CST
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;tee命令会在每次使用时覆盖输出内容，如果你想要追加，必须使用-a参数。&lt;/p&gt;
</description>
<pubDate>Thu, 16 May 2019 06:02:00 +0000</pubDate>
<dc:creator>秦广王</dc:creator>
<og:description>输入与输出 Linux系统将每个对象当作文件处理，这包括输入和输出进程。Linux用文件描述符来标识每个文件对象。文件描述符是一个非负整数，可以唯一标识会话中打开的文件。每个进程一次多可以有九个文件描</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinyuanliu/p/10874010.html</dc:identifier>
</item>
<item>
<title>分布式事务系列 - 解决跨库转账问题 - 路人甲Java</title>
<link>http://www.cnblogs.com/itsoku123/p/10875203.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itsoku123/p/10875203.html</guid>
<description>&lt;h2 id=&quot;本文内容&quot;&gt;本文内容&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;什么是分布式事务&lt;/li&gt;
&lt;li&gt;分布式事务中的难点&lt;/li&gt;
&lt;li&gt;常见的解决方案&lt;/li&gt;
&lt;li&gt;讲解通过可靠消息来解决分布式事务&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;什么是分布式事务&quot;&gt;什么是分布式事务？&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;有这样一个需求：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;小明有两个账户，分别位于A、B两个数据库中，小明需要将A中的资金转到B中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们如何实现？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;按照下面的方式实现看看有没有问题。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;连接数据库A，获取connA连接&lt;/li&gt;
&lt;li&gt;connA打开事务&lt;/li&gt;
&lt;li&gt;A库资金减少100&lt;/li&gt;
&lt;li&gt;连接库B，获取connB连接&lt;/li&gt;
&lt;li&gt;connB打开事务&lt;/li&gt;
&lt;li&gt;B库资金增加100&lt;/li&gt;
&lt;li&gt;connA.commit()&lt;/li&gt;
&lt;li&gt;connB.commit()&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面操作，正常情况是没有问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;考虑如下情况：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第7步执行成功之后，网络出问题了，第8步会提交失败，此时的结果是：A库资金减少了100，B库资金却没有增加；这是一个网络问题导致了我们业务失败了，网络因素是程序不可控的一些因素，还有其他的比如运行到7之后，系统突然断电了，也会出现同样的结果。造成了数据错误，对业务影响也是比较大的。&lt;/p&gt;
&lt;p&gt;分布式事务可以这么理解：&lt;strong&gt;一个业务操作中，会包含很多子业务的，每个子业务都是独立的事务，我们需要考虑的是如何保证这些子业务都成功，或者都失败。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;分布式事务中的难点&quot;&gt;分布式事务中的难点&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;分布式事务中，分支可能是各种各样的，可能存在各种异常情况导致有些成功有些却失败了，这些情况需要我们程序能够处理，保证所有的分支要么都成功、要么都失败，不能出现部分成功而部分失败的情况。&lt;/li&gt;
&lt;li&gt;分布式事务中，很难保证多个分支同时成功。每个分支可能都是提供远程接口进行调用，之间存在网络故障的问题，前面的分支调用成功了，但是其他分支由于网络等不可控的因素而调用不成功，此时数据是很难做到同时一致性的。&lt;/li&gt;
&lt;li&gt;实时一致性难以保证。那么我们可以做到最终一致性也是可以的。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;什么是最终一致性&quot;&gt;什么是最终一致性？&lt;/h2&gt;
&lt;p&gt;就拿上面的转账来说，A库的资金减少了，由于网络问题，操作B库的connB连接断开了，导致B库资金没有增加；网络问题是可以恢复了，如果网络恢复了，系统能够给B中资金加上，这样最终数据也是正确的；这中间有段时间AB库的资金是不一致的（&lt;strong&gt;A库减少了100，B库应该增加100却没有增加，数据是不一致的&lt;/strong&gt;），但是最终某个时间点数据变为一致了。&lt;strong&gt;能够将不一致的时间降到最低是系统需要考虑的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;分布式事务中，我们可以接受数据在某个时间段之内不一致，但是数据最终在某个时间点是一致的。&lt;/p&gt;
&lt;h2 id=&quot;常见解决方案&quot;&gt;常见解决方案&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;可靠消息模式&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;TCC模式实现&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;分布式事务系列&lt;/strong&gt;中主要讲这2种方案，这两种方案基本上可以解决大多数常见的分布式事务的问题，所以咱们必须把这两种方式拿下。&lt;/p&gt;
&lt;p&gt;下面我们介绍一下使用可靠消息如何实现？&lt;/p&gt;
&lt;h2 id=&quot;可靠消息模式实现转账操作&quot;&gt;可靠消息模式实现转账操作&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190516134543622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpa3VuNTU3,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;两个微服务&lt;br/&gt;服务A：用于操作A库中的账户&lt;br/&gt;服务B：用于操作B库中的账户&lt;/p&gt;
&lt;p&gt;两个服务都是链接独立的数据库，依靠数据库提供的功能，能够保证各自的事务。&lt;/p&gt;
&lt;p&gt;对于用户来说过程如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用服务A，扣款100&lt;/li&gt;
&lt;li&gt;发送扣款成功的消息到消息服务&lt;/li&gt;
&lt;li&gt;返回用户&lt;strong&gt;转账已受理&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接着&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;服务B，拉取到转账消息&lt;/li&gt;
&lt;li&gt;B库中给账户+100&lt;/li&gt;
&lt;li&gt;调用消息服务将消息删除&lt;/li&gt;
&lt;li&gt;服务B消费的过程中，比如出现网络、机器重启等原因，导致消费失败，等机器恢复之后，可以再次消费这条消息，&lt;strong&gt;重试多次&lt;/strong&gt;最终会成功&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上面整个转账过程中有几点我们需要考虑一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如何确保A服务中扣款成功之后，消息一定能够发送成功；如果消息发送失败而丢失了，后面的业务将没法进行。这块涉及如何发送可靠消息，之前消息系列的文章有介绍，大家可以看一下：&lt;a href=&quot;http://www.itsoku.com/article/54&quot;&gt;聊聊业务系统中投递消息到mq的几种方式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;我们的服务一般都是集群的方式，消息消费的时候，可能会出现一条消息并发消费的情况，并发情况发生的时候，如何确保消费只能够被消费成功一次。如果一条转账消息被成功消费两次，最终B账户中将增加200，导致业务出错。这块可以参考如何保证消息消费的幂等性，这块之前也有讲过，大家也可以看一下：&lt;a href=&quot;http://www.itsoku.com/article/77&quot;&gt;探讨一下实现幂等性的几种方式&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;依靠消息模式实现分布式事物，比较适合消费者一定会处理成功的场景。比如用户注册发送邮件、发送短信、送积分等。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;本文主要介绍了什么是分布式事务、其中的一些难点&lt;/li&gt;
&lt;li&gt;常见的使用最多的解决方案：异步消息处理分布式事物、tcc模式&lt;/li&gt;
&lt;li&gt;tcc模式我们在后面的文章中介绍，目前在我们自己的系统中实现了通用的tcc，已经上线运行，运行也比较稳定&lt;/li&gt;
&lt;li&gt;对分布式事务有兴趣、或有疑问的，可以加我微信&lt;strong&gt;itsoku&lt;/strong&gt;交流&lt;/li&gt;
&lt;li&gt;请关注公众号&lt;strong&gt;javacode2018&lt;/strong&gt;，免费领取年薪40万的资料，更多好文及时推送给您&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 16 May 2019 05:51:00 +0000</pubDate>
<dc:creator>路人甲Java</dc:creator>
<og:description>什么是分布式事务？分布式事务中的难点，常见的解决方案，案例：常见的跨库转账问题如何解决</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/itsoku123/p/10875203.html</dc:identifier>
</item>
<item>
<title>java线程并发工具类CyclicBarrier、CountDownLatch及Semaphore - darendu</title>
<link>http://www.cnblogs.com/darendu/p/10875205.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/darendu/p/10875205.html</guid>
<description>&lt;p&gt;一、CyclicBarrier   （原文链接：&lt;a href=&quot;http://www.studyshare.cn/blog-front//blog/index&quot;&gt;http://www.studyshare.cn/blog-front/blog/index&lt;/a&gt; ）&lt;/p&gt;
&lt;p&gt;1、定义&lt;/p&gt;
&lt;p&gt;CyclicBarrier是线程并发工具类之一，俗称栅栏。当一组线程全部执行完后，到达栅栏屏障，就放开屏障，继续往后执行。举个简单例子：几个家庭约&lt;/p&gt;
&lt;p&gt;定一个地点集合去郊游，只有当所有家庭都到达后再商量下一步计划，只要有一个没到，先到达的家庭都必须等待。&lt;/p&gt;
&lt;p&gt;2、示例demo&lt;/p&gt;
&lt;p&gt;实现：用5个子线程去执行任务，当任务执行完成后，交出自己的执行结果，再被统一释放（开放栅栏）去做自己的事情，而之前5个子线程交出的结果&lt;/p&gt;
&lt;p&gt;被另外一个线程使用做其他工作。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190516134222457-930249059.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190516134237124-65599616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、执行结果：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190516134304557-963110812.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、CountDownLatch&lt;/p&gt;
&lt;p&gt;1、定义&lt;/p&gt;
&lt;p&gt;CountDownLatch是线程并发工具类，该类具有一个计数器，计数器具有一个初始化的值，当主线程调用latch.await()方法则进行阻塞,调用&lt;/p&gt;
&lt;p&gt;latch.countDown()方法时计数器值减一，一直等到计数器的值减为0的时候，原来阻塞的方法继续往下执行。代码如下：&lt;/p&gt;

&lt;p&gt;（1）、定义两个线程，线程一调用一次countDown()，线程二调用两次countDown()&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190516134345675-845657985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）、主线程代码如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190516134412996-1940797986.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）运行结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190516134508574-568752487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、使用场景&lt;/p&gt;
&lt;p&gt;（1）、使用CountDownLatch编写高并发测试程序，可以使用CountDownLatch初始化100或者更多线程，当所有线程初始化完毕后&lt;/p&gt;
&lt;p&gt;一起去调用需要测试的业务模块代码，以此来模拟实际场景的高并发访问，测试业务代码对高并发的支持极限。&lt;/p&gt;
&lt;p&gt;（2）、某些系统启动之前需要做很多初始化工作，只有当初始化工作线程中的所有代码执行完毕后，才继续执行主线程代码，此时&lt;/p&gt;
&lt;p&gt;使用CountDownLatch来实现。&lt;/p&gt;
&lt;p&gt;3、实现原理&lt;/p&gt;
&lt;p&gt;CountDownLatch是基于AQS（AbstractQueuedSynchronizer （抽象队列同步器））实现的，关于AQS在另外一篇文章有详细讲解，包&lt;/p&gt;
&lt;p&gt;括对源码进行了深入分析，请参考：&lt;a href=&quot;http://www.studyshare.cn/blog-front/blog/details/1131/0&quot; target=&quot;_blank&quot;&gt;http://www.studyshare.cn/blog-front//blog/details/1131/0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三、Semaphore&lt;/p&gt;
&lt;p&gt;1、定义：&lt;/p&gt;
&lt;p&gt;Semaphore：即信号量，它管理着一组虚拟的许可，许可的初始数量可通过构造函数指定，在执行操作时先获取许可（只要还有剩余的&lt;/p&gt;
&lt;p&gt;许可），并在使用后释放许可，如果没有许可，则acquire方法会阻塞直到有许可。它提供的release()方法将返回一个许可给信号量。&lt;/p&gt;
&lt;p&gt; 2、关键方法&lt;/p&gt;
&lt;p&gt;aquire():获取一个虚拟许可，如果Semaphore中还有剩余许可，则返回，否则此方法会阻塞，直到Semaphore中有许可为止。&lt;/p&gt;
&lt;p&gt;release():释放一个虚拟许可回Semaphore中&lt;/p&gt;
&lt;p&gt;3、使用场景&lt;/p&gt;
&lt;p&gt;使用Semaphore实现一个数据库连接池。&lt;a title=&quot;demo源码&quot; href=&quot;http://www.studyshare.cn/blog-front/blog/details/1157/0&quot; target=&quot;_blank&quot;&gt;demo&lt;/a&gt;源码下载&lt;/p&gt;
&lt;p&gt;（1）首先定义一个数据库连接实现类，实现java.sql.Connection接口，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190516134746382-1199817317.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明：java.sql.Connection实现方法很多，已省略。可下载demo源码查看&lt;/p&gt;
&lt;p&gt;（2）使用Semaphore实现数据库连接池，代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190516134809475-263876082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190516134819878-19997803.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190516134830077-416446726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190516134837694-1524412415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）、运行验证结果分析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1501995/201905/1501995-20190516134856741-249460482.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原创文章，转载请注明来源：&lt;a href=&quot;http://www.studyshare.cn/blog-front/blog/details/1157/null&quot;&gt;http://www.studyshare.cn/blog-front/blog/details/1157/0&lt;/a&gt;，&lt;/p&gt;
&lt;p&gt;更多技术文章：&lt;a href=&quot;http://www.studyshare.cn/blog-front//blog/index&quot;&gt;http://www.studyshare.cn/blog-front//blog/index&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 16 May 2019 05:51:00 +0000</pubDate>
<dc:creator>darendu</dc:creator>
<og:description>一、CyclicBarrier （原文链接：http://www.studyshare.cn/blog-front/blog/index ） 1、定义 CyclicBarrier是线程并发工</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/darendu/p/10875205.html</dc:identifier>
</item>
</channel>
</rss>