<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Regex 正则表达式入门 - 码农充电站</title>
<link>http://www.cnblogs.com/codeshell/p/12825243.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/codeshell/p/12825243.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200502170142100.jpg?#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;0，什么是正则表达式&quot;&gt;0，什么是正则表达式&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;正则表达式&lt;/code&gt;（&lt;code&gt;Regular Expression&lt;/code&gt;简写为&lt;code&gt;Regex&lt;/code&gt;），又称为&lt;code&gt;规则表达式&lt;/code&gt;，它是一种强大的文本匹配模式，其用于在字符串中&lt;code&gt;查找匹配&lt;/code&gt;符合特定规则的子串。&lt;/p&gt;
&lt;p&gt;正则表达式是独立于&lt;code&gt;编程语言&lt;/code&gt;而存在的，它并不依赖于某种编程语言。只要一种编程语言实现了&lt;code&gt;正则表达式引擎&lt;/code&gt;，那么这种编程语言，就具备了正则表达式模式匹配的功能。每种&lt;code&gt;工具&lt;/code&gt;或&lt;code&gt;编程语言&lt;/code&gt;对正则表达式的实现，虽有细节上的不同，但基本的使用是相同的。&lt;/p&gt;
&lt;p&gt;正则表达式的基本工作原理如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200502171536552.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;1，正则表达式的由来&quot;&gt;1，正则表达式的由来&lt;/h3&gt;
&lt;p&gt;1956 年，美国数学家&lt;code&gt;Stephen Kleene&lt;/code&gt; 在两位神经生理学家（&lt;code&gt;Warren McCulloch&lt;/code&gt; 和 &lt;code&gt;Walter Pitts&lt;/code&gt;）的早期工作的基础上，发表了一篇标题为&lt;code&gt;神经网事件的表示法&lt;/code&gt;的论文，由此引入了正则表达式的概念。&lt;/p&gt;
&lt;p&gt;之后，Unix 之父&lt;code&gt;Ken Thompson&lt;/code&gt;把这一成果应用于&lt;code&gt;计算搜索算法&lt;/code&gt;的一些早期研究。随后，他将这一符号系统应用于&lt;code&gt;Unix 系统&lt;/code&gt;中的 &lt;code&gt;qed 编辑器&lt;/code&gt;，这是正则表达式的第一个实用程序。&lt;/p&gt;
&lt;p&gt;此后，正则表达式被广泛的应用于类Unix 系统的工具中，如 &lt;code&gt;grep&lt;/code&gt;，&lt;code&gt;perl&lt;/code&gt; 等。&lt;/p&gt;
&lt;h3 id=&quot;2，正则表达式工具&quot;&gt;2，正则表达式工具&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://www.regexbuddy.com/&quot;&gt;RegexBuddy&lt;/a&gt; 是一个很不错的软件。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://regexr.com/&quot;&gt;Regexr&lt;/a&gt; 是一个在线工具。&lt;/p&gt;
&lt;h3 id=&quot;3，正则表达式语法&quot;&gt;3，正则表达式语法&lt;/h3&gt;
&lt;p&gt;正则表达式由一些&lt;code&gt;普通字符&lt;/code&gt;（比如英文字母，数字）和&lt;code&gt;元字符&lt;/code&gt;（代表特定含义）组成。&lt;/p&gt;
&lt;p&gt;正则表达式作为一个字符模板，在字符串中匹配一个或多个符合特定规则的子串。&lt;/p&gt;
&lt;h4 id=&quot;31，元字符&quot;&gt;3.1，元字符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;元字符&lt;/code&gt;就是包含特定含义的字符。如果想匹配这些&lt;code&gt;元字符&lt;/code&gt;，需要使用转义字符&lt;code&gt;\&lt;/code&gt; 进行转义。&lt;/p&gt;
&lt;p&gt;下表是一些常用的元字符：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;19.5&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;\&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;转义字符，常用于转义元字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;.&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配除换行符&lt;code&gt;\n&lt;/code&gt; 之外的任何单字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;$&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配字符串的&lt;code&gt;结尾位置&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;&lt;code&gt;^&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配字符串的&lt;code&gt;开始位置&lt;/code&gt;。当写在中括号&lt;code&gt;[]&lt;/code&gt;内时，表示不匹配该&lt;code&gt;中括号&lt;/code&gt;中的字符集合&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;[^xy]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配&lt;code&gt;非x&lt;/code&gt;，&lt;code&gt;非y&lt;/code&gt;字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;被小括号包含的多个字符，将作为一整个字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;(pattern)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;写在小括号&lt;code&gt;()&lt;/code&gt;内的表达式，表示一个&lt;code&gt;分组&lt;/code&gt;，用于提取内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;(?:pattern)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;只表示一个&lt;code&gt;分组&lt;/code&gt;，不提取内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;被中括号包含的多个字符，这多个字符的关系是&lt;code&gt;逻辑或&lt;/code&gt;的关系&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[xyz]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字符集合，匹配&lt;code&gt;x&lt;/code&gt;或&lt;code&gt;y&lt;/code&gt;或&lt;code&gt;z&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[0-9]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配&lt;code&gt;0&lt;/code&gt;到&lt;code&gt;9&lt;/code&gt;之间的数字&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[a-z]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配&lt;code&gt;a&lt;/code&gt;到&lt;code&gt;z&lt;/code&gt;之间的字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[^a-z]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配不在&lt;code&gt;a&lt;/code&gt;到&lt;code&gt;z&lt;/code&gt;范围内的任意字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;|&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;写在两个字符之间，代表&lt;code&gt;逻辑或&lt;/code&gt;的关系&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;x|y&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配&lt;code&gt;x&lt;/code&gt; 或 &lt;code&gt;y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;\b&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配一个单词边界&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;\B&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配非单词边界&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;\d&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配一个数字字符，等价于&lt;code&gt;[0-9]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;\D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配一个非数字字符，等价于&lt;code&gt;[^0-9]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;\s&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配任何&lt;code&gt;空白字符&lt;/code&gt;，包括&lt;code&gt;空格&lt;/code&gt;、&lt;code&gt;制表符&lt;/code&gt;等&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;\S&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配任何&lt;code&gt;非空白字符&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;\w&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配&lt;code&gt;字母&lt;/code&gt;、&lt;code&gt;数字&lt;/code&gt;、&lt;code&gt;下划线&lt;/code&gt;，等价于&lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;\W&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配&lt;code&gt;非字母&lt;/code&gt;、&lt;code&gt;非数字&lt;/code&gt;、&lt;code&gt;非下划线&lt;/code&gt;，等价于&lt;code&gt;[^A-Za-z0-9_]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;\f&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配&lt;code&gt;换页符&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;\n&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配&lt;code&gt;换行符&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;\r&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配&lt;code&gt;回车符&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;\t&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配&lt;code&gt;制表符&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;\v&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配&lt;code&gt;垂直制表符&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;32，限定符&quot;&gt;3.2，限定符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;限定符&lt;/code&gt;也属于元字符，用来限定一个&lt;code&gt;子表达式&lt;/code&gt;出现的次数。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字符&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;6&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;*&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式&lt;code&gt;零次&lt;/code&gt;或&lt;code&gt;多次&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;+&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式&lt;code&gt;一次&lt;/code&gt;或&lt;code&gt;多次&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;?&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式&lt;code&gt;零次&lt;/code&gt;或&lt;code&gt;一次&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;{n}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式&lt;code&gt;n次&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;{n,}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式&lt;code&gt;至少n次&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;{n,m}&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前面的子表达式&lt;code&gt;n 到m 次&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;4，正则表达式示例&quot;&gt;4，正则表达式示例&lt;/h3&gt;
&lt;p&gt;我们逐个介绍一下每种元字符的使用方式，下面的例子我们都使用&lt;code&gt;RegexBuddy&lt;/code&gt; 软件来演示。&lt;/p&gt;
&lt;h4 id=&quot;41，转义字符&quot;&gt;4.1，转义字符&lt;code&gt;\&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;转义字符用来对一些元字符进行转义，使这些元字符失去其特定的含义，只表示一个普通的字符。&lt;/p&gt;
&lt;p&gt;比如我们想匹配字符串&lt;code&gt;aaa^bbb&lt;/code&gt; 中的&lt;code&gt;a^b&lt;/code&gt; 子串，我们需要用模式&lt;code&gt;a\^b&lt;/code&gt; 来匹配，&lt;code&gt;^&lt;/code&gt; 之前需要加一个转义字符&lt;code&gt;\&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503085630971.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;42，元字符&quot;&gt;4.2，元字符&lt;code&gt;.&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;元字符&lt;code&gt;.&lt;/code&gt; 可匹配任意(除了换行符&lt;code&gt;\n&lt;/code&gt;)的单字符，意思就是&lt;code&gt;.&lt;/code&gt; 可以代表任意（除了换行符&lt;code&gt;\n&lt;/code&gt;）的单字符。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503092015873.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;43，开始位置与结束位置&quot;&gt;4.3，开始位置&lt;code&gt;^&lt;/code&gt;与结束位置&lt;code&gt;$&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;符号&lt;code&gt;^&lt;/code&gt; 表示匹配的子串在&lt;code&gt;行首&lt;/code&gt;，符号&lt;code&gt;$&lt;/code&gt; 表示匹配的子串在&lt;code&gt;行尾&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;匹配行首&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503094258394.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;匹配行尾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503094324437.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;行首行尾&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503094551114.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;44，逻辑或&quot;&gt;4.4，逻辑或&lt;code&gt;|&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;符号&lt;code&gt;|&lt;/code&gt; 写在两个&lt;code&gt;子表达式&lt;/code&gt;之间表示&lt;code&gt;逻辑或&lt;/code&gt;的意思。&lt;/p&gt;
&lt;p&gt;例如模式串&lt;code&gt;ab|cd&lt;/code&gt;，匹配&lt;code&gt;ab&lt;/code&gt; 或 &lt;code&gt;cd&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020050310260386.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;45，限定符&quot;&gt;4.5，限定符&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;限定符&lt;/code&gt;用于限定一个&lt;code&gt;子表达式&lt;/code&gt;出现的&lt;code&gt;次数&lt;/code&gt;，一共6 种，这里给出一些示例。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;符号&lt;code&gt;*&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模式串&lt;code&gt;ab*c&lt;/code&gt;，表示字符&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;c&lt;/code&gt; 之间需要出现&lt;code&gt;0 次&lt;/code&gt;或&lt;code&gt;多次&lt;/code&gt;字符&lt;code&gt;b&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503103941257.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;符号&lt;code&gt;+&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模式串&lt;code&gt;ab+c&lt;/code&gt;，表示字符&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;c&lt;/code&gt; 之间需要出现&lt;code&gt;1 次&lt;/code&gt;或&lt;code&gt;多次&lt;/code&gt;字符&lt;code&gt;b&lt;/code&gt;，即至少出现&lt;code&gt;1次&lt;/code&gt;字符&lt;code&gt;b&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503104331119.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;符号&lt;code&gt;?&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;模式串&lt;code&gt;ab?c&lt;/code&gt;，表示字符&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;c&lt;/code&gt; 之间需要出现&lt;code&gt;0 次&lt;/code&gt;或&lt;code&gt;1次&lt;/code&gt;字符&lt;code&gt;b&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503142539115.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;符号&lt;code&gt;{n}&lt;/code&gt;和&lt;code&gt;{n,}&lt;/code&gt;和&lt;code&gt;{n,m}&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ab{3}c&lt;/code&gt;：符号b 出现的次数必须是&lt;code&gt;3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ab{3,}c&lt;/code&gt;：符号b 出现的次数必须&lt;code&gt;大于等于3&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ab{3,5}c&lt;/code&gt;：符号b 出现的次数必须在&lt;code&gt;3&lt;/code&gt; 和&lt;code&gt;5&lt;/code&gt; 之间，包括&lt;code&gt;3&lt;/code&gt; 和 &lt;code&gt;5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/202005031055103.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;46，字符簇&quot;&gt;4.6，字符簇&lt;code&gt;[]&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;写在中括号&lt;code&gt;[]&lt;/code&gt; 内的多个字符代表&lt;code&gt;逻辑或&lt;/code&gt;的意思。&lt;/p&gt;
&lt;p&gt;模式串&lt;code&gt;a[bef]c&lt;/code&gt;，表示&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;c&lt;/code&gt;中间的字符必须是&lt;code&gt;b&lt;/code&gt;或&lt;code&gt;e&lt;/code&gt;或&lt;code&gt;f&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503095303616.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;当符号&lt;code&gt;^&lt;/code&gt; 写在中括号&lt;code&gt;[]&lt;/code&gt; 内时，表示&lt;code&gt;逻辑非&lt;/code&gt;的意思。&lt;/p&gt;
&lt;p&gt;模式串&lt;code&gt;a[^bef]c&lt;/code&gt;，表示&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;c&lt;/code&gt;中间的字符不能是&lt;code&gt;b&lt;/code&gt;或&lt;code&gt;e&lt;/code&gt;或&lt;code&gt;f&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503100001586.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;符号&lt;code&gt;-&lt;/code&gt; 写在中括号&lt;code&gt;[]&lt;/code&gt;，表示&lt;code&gt;范围&lt;/code&gt;的意思：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;示例&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[a-z]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表示&lt;code&gt;a&lt;/code&gt; 到&lt;code&gt;z&lt;/code&gt; 之间的任意字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[A-Z]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表示&lt;code&gt;A&lt;/code&gt; 到&lt;code&gt;Z&lt;/code&gt; 之间的任意字符&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[0-9]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表示&lt;code&gt;0&lt;/code&gt; 到&lt;code&gt;9&lt;/code&gt; 之间的任意数字，含义同&lt;code&gt;\d&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[^0-9]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表示任意&lt;code&gt;非数字&lt;/code&gt;，含义同&lt;code&gt;\D&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[A-Za-z0-9_]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表示任意&lt;code&gt;字母&lt;/code&gt;，&lt;code&gt;数字&lt;/code&gt;或&lt;code&gt;下划线&lt;/code&gt; ，含义同&lt;code&gt;\w&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[^A-Za-z0-9_]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表示任意&lt;code&gt;非字母&lt;/code&gt;，&lt;code&gt;非数字&lt;/code&gt;，&lt;code&gt;非下划线&lt;/code&gt; ，含义同&lt;code&gt;\W&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[ \f\r\t\n]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表示任意的&lt;code&gt;空白字符&lt;/code&gt;，含义同&lt;code&gt;\s&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;[^ \f\r\t\n]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;表示任意的&lt;code&gt;非空白字符&lt;/code&gt;，含义同&lt;code&gt;\S&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h4 id=&quot;47，字符组合&quot;&gt;4.7，字符组合()&lt;/h4&gt;
&lt;p&gt;写在小括号&lt;code&gt;()&lt;/code&gt;中的多个字符，会被看成一个整体。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503133928362.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h4 id=&quot;48，单词边界b与b&quot;&gt;4.8，单词边界&lt;code&gt;\b&lt;/code&gt;与&lt;code&gt;\B&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;符号&lt;code&gt;\b&lt;/code&gt; 是指一个&lt;code&gt;单词边界&lt;/code&gt;，比如空白字符和标点符号等。&lt;br/&gt;符号&lt;code&gt;\B&lt;/code&gt; 表示&lt;code&gt;非单词边界&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503141020379.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;5，贪婪与非贪婪模式&quot;&gt;5，贪婪与非贪婪模式&lt;/h3&gt;
&lt;p&gt;正则表达式中&lt;code&gt;贪婪&lt;/code&gt;的意思就是&lt;code&gt;贪多&lt;/code&gt;，意思就是正则在匹配的过程中，总是去匹配&lt;code&gt;尽可能多&lt;/code&gt;的字符，符号&lt;code&gt;?&lt;/code&gt; 可以将&lt;code&gt;贪婪&lt;/code&gt;转换为&lt;code&gt;非贪婪&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200503135129219.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3 id=&quot;6，在python-中使用正则&quot;&gt;6，在&lt;code&gt;Python&lt;/code&gt; 中使用正则&lt;/h3&gt;
&lt;p&gt;Python 中提供了&lt;code&gt;re&lt;/code&gt; 模块，用于支持正则表达式功能。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;python&lt;/code&gt; 中一般在表达式前加&lt;code&gt;r&lt;/code&gt;，表示&lt;code&gt;原始字符&lt;/code&gt;，不用考虑转义的问题。例如&lt;code&gt;r'abc'&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下面打开&lt;code&gt;python&lt;/code&gt; 终端：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先引入模块，&lt;code&gt;import re&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;help(re)&lt;/code&gt; 可查看re 模块帮助手册&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dir(re)&lt;/code&gt; 可查看其支持的属性和方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; python           `打开python 终端`
_____________________________________________
Python 2.7.17 (default, Nov  7 2019, 10:07:09) 
[GCC 7.4.0] on linux2
Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.

&amp;gt;&amp;gt;&amp;gt; import re   # 引入re 模块
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; help(re)   # 查看帮助手册
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; dir(re)            # 查看re 支持的属性和方法
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;61，re-模块常用方法&quot;&gt;6.1，re 模块常用方法&lt;/h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;match&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于匹配表达式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;search&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查找匹配项&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;findall&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;查找所有的匹配项&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;compile&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;编译正则表达式&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;详细解释：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;match(pattern, string, flags=0)
        Try to apply the pattern at the start of the string, returning
        a match object, or None if no match was found.

search(pattern, string, flags=0)
        Scan through string looking for a match to the pattern, returning
        a match object, or None if no match was found.
        
findall(pattern, string, flags=0)
        Return a list of all non-overlapping matches in the string.
        
        If one or more groups are present in the pattern, return a
        list of groups; this will be a list of tuples if the pattern
        has more than one group.
        
        Empty matches are included in the result.

compile(pattern, flags=0)
        Compile a regular expression pattern, returning a pattern object.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，每个方法中都有一个&lt;code&gt;flag&lt;/code&gt; 参数，它表示&lt;code&gt;匹配模式&lt;/code&gt;，默认值为&lt;code&gt;0&lt;/code&gt;，表示普通模式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;flag&lt;/code&gt; 参数的值有以下几种选择，可以使用符号&lt;code&gt;|&lt;/code&gt; 连接多种选择：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;`I/IGNORECASE`  Perform case-insensitive matching.
`L/LOCALE`      Make \w, \W, \b, \B, dependent on the current locale.
`M/MULTILINE`   &quot;^&quot; matches the beginning of lines (after a newline)
                as well as the string.
                &quot;$&quot; matches the end of lines (before a newline) as well
                as the end of the string.
`S/DOTALL`      &quot;.&quot; matches any character at all, including the newline.
`X/VERBOSE`     Ignore whitespace and comments for nicer looking RE's.
`U/UNICODE`     Make \w, \W, \b, \B, dependent on the Unicode locale.
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;62，match-方法&quot;&gt;6.2，match 方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;re.match&lt;/code&gt; 尝试从字符串的&lt;code&gt;起始位置&lt;/code&gt;开始匹配：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;成功：返回&lt;code&gt;SRE_Match&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;失败：返回&lt;code&gt;None&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; m = re.match(r'abc', 'abcde')
&amp;gt;&amp;gt;&amp;gt; print m  # 匹配成功
&amp;lt;_sre.SRE_Match object at 0x7f91544cff80&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; m = re.match(r'abc', 'fabcde')
&amp;gt;&amp;gt;&amp;gt; print m  # `fabcde` 不是以`abc` 开头，匹配失败                  
None                     
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;63，search-方法&quot;&gt;6.3，search 方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;re.search&lt;/code&gt; 扫描整个字符串，直到找到&lt;code&gt;第一个&lt;/code&gt;成功的匹配：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;成功：返回&lt;code&gt;SRE_Match&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;失败：返回&lt;code&gt;None&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; m = re.search(r'abc', 'abcde')
&amp;gt;&amp;gt;&amp;gt; print m  # 匹配成功
&amp;lt;_sre.SRE_Match object at 0x7f91544cff80&amp;gt;
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; m = re.search(r'abc', 'fabcde')
&amp;gt;&amp;gt;&amp;gt; print m # 匹配成功
&amp;lt;_sre.SRE_Match object at 0x7f9154521b90&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;64，findall-方法&quot;&gt;6.4，findall 方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;re.findall&lt;/code&gt; 在字符串中查找&lt;code&gt;所有&lt;/code&gt;匹配的子串：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;成功：返回一个列表&lt;/li&gt;
&lt;li&gt;失败：返回&lt;code&gt;空列表[]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; re.findall(r'abc', 'fabcdeabc')
['abc', 'abc']          # 找到两个`abc` 子串
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; re.findall(r'abce', 'fabcdeabc')
[]                  # 没找到子串
&amp;gt;&amp;gt;&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;65，compile-方法&quot;&gt;6.5，compile 方法&lt;/h4&gt;
&lt;p&gt;在使用正则时，&lt;code&gt;re&lt;/code&gt; 模块会先将&lt;code&gt;正则表达式&lt;/code&gt;进行&lt;code&gt;编译&lt;/code&gt;，然后才会去字符串中匹配。&lt;/p&gt;
&lt;p&gt;如果一个&lt;code&gt;正则表达式&lt;/code&gt;会使用很多次，我们可以使用&lt;code&gt;re.compile&lt;/code&gt; 方法对表达式进行&lt;code&gt;预编译&lt;/code&gt;，这样就不会在每次用到这个表达式时都进行编译，有助于提高效率。&lt;/p&gt;
&lt;p&gt;该方法返回一个&lt;code&gt;SRE_Pattern&lt;/code&gt; 对象，该对象又包含&lt;code&gt;match&lt;/code&gt;，&lt;code&gt;search&lt;/code&gt;，&lt;code&gt;findall&lt;/code&gt; 等方法，使用方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; reg =  re.compile(r'abc')      # 编译
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; type(reg)
&amp;lt;type '_sre.SRE_Pattern'&amp;gt;
&amp;gt;&amp;gt;&amp;gt;
&amp;gt;&amp;gt;&amp;gt; reg.findall('fabcdeabc')      # 找到两个
['abc', 'abc']  
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; reg.match('fabcdeabc')        # 没有匹配上
&amp;gt;&amp;gt;&amp;gt; 
&amp;gt;&amp;gt;&amp;gt; reg.search('fabcdeabc')       # 匹配上
&amp;lt;_sre.SRE_Match object at 0x7f9154521b90&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;66，sre_match-对象&quot;&gt;6.6，SRE_Match 对象&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;SRE_Match&lt;/code&gt; 对象用于获取分组，写在小括号&lt;code&gt;()&lt;/code&gt;内的表达式是一个分组。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;&amp;gt;&amp;gt;&amp;gt; # 正则中包含两个分组
&amp;gt;&amp;gt;&amp;gt; m = re.match(r'(\d*)-(\w*)', '123-abc-')
&amp;gt;&amp;gt;&amp;gt; m
&amp;lt;_sre.SRE_Match object at 0x7f91544e0ae0&amp;gt;
&amp;gt;&amp;gt;&amp;gt; m.group(0) # 获取整个匹配的串，同 m.group()
'123-abc'
&amp;gt;&amp;gt;&amp;gt; m.group(1) # 获取第一个分组
'123'
&amp;gt;&amp;gt;&amp;gt; m.group(2) # 获取第二个分组
'abc'
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;67，match，search，findall-比较&quot;&gt;6.7，match，search，findall 比较&lt;/h4&gt;
&lt;p&gt;我们来看下&lt;code&gt;match&lt;/code&gt;，&lt;code&gt;search&lt;/code&gt;，&lt;code&gt;findall&lt;/code&gt; 三个方法的异同点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;match：必须从字符串的开头匹配，只会有一个匹配项，返回结果是&lt;code&gt;SRE_Match&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;search：扫描整个字符串，直到匹配到第一个为止，只会有一个匹配项，返回结果是&lt;code&gt;SRE_Match&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;findall：扫描整个字符串，返回所有的匹配项，返回结果是一个字符串列表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;（完。）&lt;/p&gt;
</description>
<pubDate>Mon, 04 May 2020 00:40:00 +0000</pubDate>
<dc:creator>码农充电站</dc:creator>
<og:description>0，什么是正则表达式 （`Regular Expression Regex 规则表达式 查找匹配`符合特定规则的子串。 正则表达式是独立于 而存在的，它并不依赖于某种编程语言。只要一种编程语言实现了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/codeshell/p/12825243.html</dc:identifier>
</item>
<item>
<title>架构师之路—理解设计模式 - coderidea</title>
<link>http://www.cnblogs.com/xiaoyao2011/p/12824989.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyao2011/p/12824989.html</guid>
<description>&lt;p&gt;在《周期》中作者这样描述过模式：“人类必须生活在现实世界中。我们寻找模式和规律，能够让我们活得更加舒服，也获利更多。”&lt;/p&gt;
&lt;h2&gt;为什么会有设计模式？&lt;/h2&gt;
&lt;p&gt;你曾经多少次有过这种感觉—你已经解决过了一个问题，但就是不能确切知道是在什么地方或怎么解决的？如果你能记起以前问题的细节和怎么解决它的，你就可以复用以前的经验而不需要重新发现它。然而，我们并没有很好记录下可供他人使用的软件设计经验。设计模式的目标是将设计经验以人们能够有效利用的形式记录下来。来复用设计经验，很多问题不必要再从头做起。&lt;/p&gt;
&lt;h2&gt;设计模式的定义&lt;/h2&gt;
&lt;p&gt;设计模式的起初还是来源于建筑业。设计模式的定义：“每一个模式描述了一个在我们周围不断重复发生的问题， 以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动”（这个定义是Christopher Alexander 说的（Christopher Alexander，1936年10月4日生于奥地利维也纳）是加州大学伯克利分校的终身教授和承包商，同时也是建筑师。）尽管Alexander所指的是城市和建筑模式，但同样也适用于面向对向设计模式。最近理解同样也可以用于其他行业的模式，如投资寻找相应的模式和规律进而找到人生获胜的公式。&lt;/p&gt;
&lt;h2&gt;设计模式的元素&lt;/h2&gt;
&lt;p&gt;设计模式有四个基本的元素模式名称、问题、解决方案、效果。&lt;/p&gt;
&lt;p&gt;1.模式名称：一个助记名，用一两个词来描述问题、解决方案和效果，便于同行间沟通交流。&lt;/p&gt;
&lt;p&gt;2.问题：描述问题相关背景和问题的上下文，问题产生的前因后果，有时候描述设计模式的先决条件。&lt;/p&gt;
&lt;p&gt;3.解决方案：问题解决方案，是设计的组成部分，描述了对象间的各自的关系和职责和协作方式。描述怎样通过一般的元素组合来解决问题的。&lt;/p&gt;
&lt;p&gt;4.效果：描述模式应用的效果和使用模式的权衡问题。决策的过程也很重要。这个包含了两个重要的点，模式应用后的效果和选用模式如何去权衡的。、&lt;/p&gt;
&lt;h2&gt;设计模式的学习和运用&lt;/h2&gt;
&lt;p&gt;模式就像是一个模板，可以应用于多个场合来形成一种经验。不管是在建筑业，还是IT业，还是其他行业，模式都可以一次又一次去复用，尤其是历经过考验的成功的一些模式。在学习设计模式的过程中，一方面是学习软件行业已有的设计模式，另一方面学习如何记录软件设计或者其他方面的遇到的问题形成自己一个模式库。&lt;/p&gt;
&lt;p&gt;我们努力想要看透人生，方法是识别模式，进而找到人生获胜的公式。&lt;/p&gt;
</description>
<pubDate>Mon, 04 May 2020 00:21:00 +0000</pubDate>
<dc:creator>coderidea</dc:creator>
<og:description>在《周期》中作者这样描述过模式：“人类必须生活在现实世界中。我们寻找模式和规律，能够让我们活得更加舒服，也获利更多。” 为什么会有设计模式？ 你曾经多少次有过这种感觉—你已经解决过了一个问题，但就是不</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoyao2011/p/12824989.html</dc:identifier>
</item>
<item>
<title>前端面试每日一题（总结版） - codingOrange</title>
<link>http://www.cnblogs.com/zhangguicheng/p/12825216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangguicheng/p/12825216.html</guid>
<description>&lt;blockquote readability=&quot;5.4883720930233&quot;&gt;
&lt;p&gt;这里是每日一题的汇总版，首发于 &lt;a href=&quot;https://t.bilibili.com/?spm_id_from=333.999.b_696e7465726e6174696f6e616c486561646572.28&quot;&gt;b 站动态&lt;/a&gt;，每日一题，在不知不觉中学到前端知识，每天更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;2020年4月20日typeof能判断出哪些数据类型？&quot;&gt;2020年4月20日(typeof能判断出哪些数据类型？)&lt;/h2&gt;
&lt;p&gt;typeof能判断出哪些数据类型？&lt;br/&gt;typeof能直接判断出 Number，String，Boolean，undefined，Symbol&lt;br/&gt;typeof(null)返回 object，判断数组和对象返回 object，判断函数返回 function&lt;/p&gt;
&lt;h2 id=&quot;2020年4月21日-css-中盒模型有几种，有什么不同？&quot;&gt;2020年4月21日 (CSS 中盒模型有几种，有什么不同？)&lt;/h2&gt;
&lt;p&gt;CSS 中盒模型有几种，有什么不同？&lt;br/&gt;CSS 盒模型分为 W3C 标准盒模型和 IE 模型，W3C 标准盒模型中有元素的宽度 width 还有 border，padding， margin，其中 content 的高度和宽度不包含 padding 和 border。&lt;br/&gt;IE 盒模型中也有这几种属性，但是 content 包含 padding 和 margin。&lt;/p&gt;
&lt;h2 id=&quot;2020年4月22日-new-操作符&quot;&gt;2020年4月22日 (new 操作符)&lt;/h2&gt;
&lt;p&gt;使用 new 创建对象时，new 运算符做了哪些事？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个新对象&lt;/li&gt;
&lt;li&gt;将构造函数的作用域赋给新对象（this 就指向了这个新对象）&lt;/li&gt;
&lt;li&gt;执行构造函数中的代码（初始化对象）&lt;/li&gt;
&lt;li&gt;返回新对象&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;2020年4月23日值类型和引用类型的区别&quot;&gt;2020年4月23日(值类型和引用类型的区别)&lt;/h2&gt;
&lt;p&gt;值类型和引用类型的区别？&lt;/p&gt;
&lt;p&gt;值类型是不可变的数据类型，例如 &lt;code&gt;let a = 10;&lt;/code&gt; 在内存中的执行过程是先创建一块内存空间存储 10，然后再令 a 指向这块内存空间。如果这时候令 &lt;code&gt;a=20;&lt;/code&gt; 会在内存中再开辟一段内存空间里面存放 20，然后将 a 指向这段内存空间，之前的那个内存空间会被销毁。所以值类型是不可变的，要想改变必须将之前的销毁然后创建新的内存空间。&lt;/p&gt;
&lt;p&gt;引用类型是可变的数据类型，例如 &lt;code&gt;obj = { x: 1}&lt;/code&gt; 在内存中 obj 中存放的是 &lt;code&gt;{ x: 1 }&lt;/code&gt; 这个对象的地址，这个对象是在堆中存储的，通过 &lt;code&gt;obj.x=3&lt;/code&gt; 改变对象的属性，这个时候并不会将之前的对象销毁，因此引用类型是可变的数据类型。&lt;/p&gt;
&lt;h2 id=&quot;2020-年4月24日doctype的作用&quot;&gt;2020 年4月24日(&amp;lt;!DOCTYPE&amp;gt;的作用)&lt;/h2&gt;
&lt;p&gt;注意 &lt;code&gt;&amp;lt;!DOCTYPE&amp;gt;&lt;/code&gt; 并不是 HTML 标签。&lt;/p&gt;
&lt;p&gt;总结来说有这两个作用：&lt;/p&gt;
&lt;p&gt;1）声明文档的类型，&lt;/p&gt;
&lt;p&gt;2）告诉浏览器应该以什么样的标准解析这个文档&lt;/p&gt;
&lt;p&gt;浏览器有两个模式，怪异模式和标准模式，声明 &lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt; 作用就是告诉浏览器你即将要处理的是 HTML 文档，并且在渲染文档时要按照标准模式的方式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MDN 解释&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/HTML&quot;&gt;HTML&lt;/a&gt;中，文档类型声明是必要的。所有的文档的头部，你都将会看到&quot;&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt;&quot; 的身影。这个声明的目的是防止浏览器在渲染文档时，切换到我们称为“&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/HTML/Quirks_Mode_and_Standards_Mode&quot;&gt;怪异模式(兼容模式)&lt;/a&gt;”的渲染模式。“&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/code&gt;&quot; 确保浏览器按照最佳的相关规范进行渲染，而不是使用一个不符合规范的渲染模式。&lt;/p&gt;
&lt;h2 id=&quot;2020年4月25日（语义化标签的理解）&quot;&gt;2020年4月25日（语义化标签的理解）&lt;/h2&gt;
&lt;p&gt;语义化标签的理解&lt;/p&gt;
&lt;p&gt;按照字面意思理解就是有语义的标签，要做到用最合适的标签做最合适的事，例如要做一个导航栏，要用 Nav 而不是 div。&lt;/p&gt;
&lt;p&gt;使用语义化标签有很多好处：&lt;/p&gt;
&lt;p&gt;开发者看到文档后能够做到见名知义，有利于团队维护和开发。&lt;/p&gt;
&lt;p&gt;能让页面呈现清晰的结构，机器更容易理解，有利于爬虫和搜索引擎的抓取（SEO的优化）&lt;/p&gt;
&lt;p&gt;CSS 选择器优先级&lt;/p&gt;
&lt;p&gt;！importtant 优先级最高 &amp;gt; 内联样式 &amp;gt; ID 选择器 &amp;gt; 类，属性，伪类 &amp;gt; 元素，伪元素&lt;/p&gt;
&lt;p&gt;注意点：不会进位，一万个类选择器也抵不上一个id选择器，相同权重，后写的生效。&lt;/p&gt;
&lt;h2 id=&quot;2020年4月26日（new-运算符的底层代码实现）&quot;&gt;2020年4月26日（new 运算符的底层代码实现）&lt;/h2&gt;
&lt;p&gt;new 运算符的底层代码实现&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// func 为传入的构造函数
const new2 = fucntion (func) {
  const o = Object.create(func.prototype);
  const k = func.call(o);
        return k === 'object' ? k : o;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面这种写法没有考虑带参数的情况。&lt;/p&gt;
&lt;h2 id=&quot;2020年4月27日（css-对于选择器的解析顺序）&quot;&gt;2020年4月27日（CSS 对于选择器的解析顺序）&lt;/h2&gt;
&lt;p&gt;今天的每日一题和大家分享一下 CSS 对于选择器的解析顺序。&lt;/p&gt;
&lt;p&gt;以一段代码为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-css&quot;&gt;body div .hello {
  color: #ccc;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照我们正常的思维是浏览器会选取寻找 body，然后再去找 body 下的 div，然后再去找 div 下的 .hello 类。但是浏览器与这个过程正好相反，它会先去找到 .hello 这个类，然后再去验证它有一个父元素是 div，然后 div 再验证它是否有一个父元素是 body。&lt;/p&gt;
&lt;p&gt;之所以按照这样的流程是出于性能的考虑，如果是第一种方式，找 body 下的 div 时有可能有特别多的 div，然后再在这些 div 中寻找 .hello 类时是非常耗时的。&lt;/p&gt;
&lt;h2 id=&quot;2020-年4月28日（css-中清除浮动常用的两种方法）&quot;&gt;2020 年4月28日（CSS 中清除浮动常用的两种方法）&lt;/h2&gt;
&lt;p&gt;今天和大家分享一下 CSS 中清除浮动常用的两种方法，学累了就来看看吧。&lt;/p&gt;
&lt;p&gt;CSS 清除浮动&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;父元素触发 BFC（例如可以采用 overflow：hidden 使父元素触发 BFC）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;利用伪元素，给父元素的最后面添加一个伪元素，令伪元素 clear: both，这样就会使得左右两边都没有浮动元素，又因为它是父元素的最下面的一个元素，所以它只能在父元素的最下面并且左右都没有浮动元素，这样浮动元素就在它的上面，父元素就不会发生告诉塌陷了。&lt;/p&gt;
&lt;p&gt;代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;父元素::after {
  content: '';
  clear: both; /* 使左右两边没有浮动元素 */
  display: block;
  visibility: hidden;
  height: 0;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;2020年4月29日（js-任务队列）&quot;&gt;2020年4月29日（JS 任务队列）&lt;/h2&gt;
&lt;p&gt;今天和大家来一起学习一下 JavaScript 事件循环机制中的任务队列。&lt;/p&gt;
&lt;p&gt;任务队列分为两种，一种是micro task，另一种是 macro-task。&lt;/p&gt;
&lt;p&gt;macro-task大概包括：script(整体代码), setTimeout, setInterval, setImmediate, I/O, UI rendering。&lt;/p&gt;
&lt;p&gt;micro-task大概包括: process.nextTick, Promise, Object.observe(已废弃), MutationObserver(html5新特性)&lt;/p&gt;
&lt;p&gt;优先级： micro-task &amp;gt; macro-task；&lt;/p&gt;
&lt;p&gt;推荐给大家一个视频，生动形象。 两分钟了解 JavaScript EventLoop &lt;a href=&quot;https://www.bilibili.com/video/BV1kf4y1U7Ln&quot;&gt;https://www.bilibili.com/video/BV1kf4y1U7Ln&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2020年4月30日（get-和-post-的区别）&quot;&gt;2020年4月30日（GET 和 POST 的区别）&lt;/h2&gt;
&lt;p&gt;今天和大家一起来学习一下面试中经常问的 GET 和 POST 的区别，主要有以下几点。&lt;/p&gt;
&lt;p&gt;1）GET 在浏览器回退时是不会再次发送 GET 请求的，POST 会再次发送请求&lt;/p&gt;
&lt;p&gt;2）GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置（在地址栏中输入url的方式只能发送 GET 请求）&lt;/p&gt;
&lt;p&gt;3）GET 请求的参数会被完整保留在浏览器历史记录里，而 POST 请求中的参数不会被保留&lt;/p&gt;
&lt;p&gt;4）GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有限制&lt;/p&gt;
&lt;p&gt;5）GET 参数通过 URL 传递，POST 数据放在 Request body 中&lt;/p&gt;
&lt;p&gt;6）GET 比 POST 安全性低，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息&lt;/p&gt;
&lt;h2 id=&quot;2020-年5月1日（http-中常用的一些状态码）&quot;&gt;2020 年5月1日（HTTP 中常用的一些状态码）&lt;/h2&gt;
&lt;p&gt;今天和大家一起来学习一下 HTTP 中常用的一些状态码。&lt;/p&gt;
&lt;p&gt;200 OK 请求成功&lt;/p&gt;
&lt;p&gt;206 Partial Content 客户端发送了一个带有 Range 头的 GET 请求，服务端成功响应了该请求。在客户端请求一个视频文件的时候，服务端一般都会返回一个 206，表示将部分资源返回给客户端。&lt;/p&gt;
&lt;p&gt;301 Moved Permanently 所请求的资源已被&lt;strong&gt;永久&lt;/strong&gt;地移到别的地方。服务端需要在响应的首部添加一个 Location 属性来表示资源已经被移动到哪个 url 。（Location属性是可选的，但是推荐有）&lt;/p&gt;
&lt;p&gt;302 Found 所请求的资源被&lt;strong&gt;临时&lt;/strong&gt;移动到别的地方。服务端需要在响应的首部添加 Location 属性来临时定位那个资源。将来还是应该用老的 url 进行访问。（Location属性是可选的，但是推荐有）&lt;/p&gt;
&lt;p&gt;304 Not Modified 请求的资源在本地有并且和服务端上的资源一致并没有被修改。&lt;/p&gt;
&lt;p&gt;400 Bad Request 告知客户端发送了一个错误的请求，服务端不能理解&lt;/p&gt;
&lt;p&gt;401 Unauthorized 请求未经授权，这个状态码必须和 WWW.Authenticate 报头域一起使用 403 Forbidden 请求的资源被禁止访问。&lt;/p&gt;
&lt;p&gt;404 Not Found 请求的资源不存在&lt;/p&gt;
&lt;p&gt;500 Internal Server Error 服务器发生不可预期的错误原来的缓冲文档还可以继续使用&lt;/p&gt;
&lt;p&gt;503 Server Unavailable 服务器现在无法为请求提供服务，将来可能可以。如果服务器知道将来什么时候可以提供服务，可以在响应的首部添加一个 Retry-After 属性告诉客户端什么时候可以再次提供服务。&lt;/p&gt;
&lt;h2 id=&quot;2020年5月2日（call，apply，bind-之间的区别）&quot;&gt;2020年5月2日（call，apply，bind 之间的区别）&lt;/h2&gt;
&lt;p&gt;今天和大家聊一下 call，apply，bind 之间的区别？&lt;/p&gt;
&lt;p&gt;先来看一下相同点：&lt;/p&gt;
&lt;p&gt;它们三个都是改变函数运行时内部 this 的指向，第一个参数指定的对象就是函数运行时 this 指向的对象。&lt;/p&gt;
&lt;p&gt;再来看一下不同点：&lt;/p&gt;
&lt;p&gt;call 的第二个参数是参数列表的形式，调用 call 的函数会立即执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;fn1.call(obj, 1, 2, 3)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;apply 的第二个参数是一个数组，调用 apply 的函数也会立即执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;fn1.apply(obj, [1, 2, 3])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bind 的第二个参数是参数列表的形式，调用 bind 的函数会返回一个函数，而不是立即执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;fn1 = fn1.bind(obj, 1, 2, 3)   // 将 fn1 内部的 this 指向 obj，并且返回绑定后的函数
fn1() 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2020年5月3日（比较两个对象的内容是否相等）&quot;&gt;2020年5月3日（比较两个对象的内容是否相等）&lt;/h2&gt;
&lt;p&gt;由于自己做的一个键盘导航组件中需要用到比较两个对象的内容是否相等，因此根据深拷贝的思想写了一个函数分享给大家，大家可以顺便复习一下深拷贝。（b 站不支持 MarkDown太不方便了，直接粘贴成图片了，代码可以在直播页面上的 GIthub 仓库中获取）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/zhangguicheng/1618684/o_200502161832%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AE%B9%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89.png&quot; alt=&quot;判断两个对象的内容是否相等&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2020年5月4日（字节笔试分享）&quot;&gt;2020年5月4日（字节笔试分享）&lt;/h2&gt;
&lt;p&gt;今天做了字节的笔试，客观题只有五道选择题，一个问答题，还有三道编程题。选择题考查的外边距重叠，事件循环机制（场景题让你写输出），object.keys 的返回值（只是一个选项）,window.postMessage() 跨域，JSONP 跨域只能发送 GET 请求等。&lt;/p&gt;
&lt;p&gt;问答题是给你一段代码，让你找出其中的错误，并修正，然后针对这个问题让你写出尽可能多的方案。刚开始没有 Get 到考察的点，后来意识到考察的是 this 并不会遵循作用域链的规则，因此需要 const that = this，然后在子函数中利用 that 才能访问到父函数中的 this。&lt;/p&gt;
&lt;p&gt;关于尽可能多的方案，题目中使用两个 class 来实现的，我使用借用构造函数，借助原型链，组合模式这几种都实现了一下。&lt;/p&gt;
&lt;p&gt;关于编程题，难度 LeetCode 中等难度上下，平时一定要多刷点题，还有在在线下多练习一下各种形式的输入读取和各种形式的输出，到时候可以把精力都放在算法上。&lt;/p&gt;
</description>
<pubDate>Mon, 04 May 2020 00:16:00 +0000</pubDate>
<dc:creator>codingOrange</dc:creator>
<og:description>这里是每日一题的汇总版，首发于 &amp;quot;b 站动态&amp;quot; ，每日一题，在不知不觉中学到前端知识，每天更新。 2020年4月20日(typeof能判断出哪些数据类型？) typeof能判断出哪</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangguicheng/p/12825216.html</dc:identifier>
</item>
<item>
<title>.net core 基于Dapper 的分库分表开源框架（core-data） - Jlion</title>
<link>http://www.cnblogs.com/jlion/p/12771167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jlion/p/12771167.html</guid>
<description>&lt;p&gt;在数据库的数据日积月累的积累下，业务数据库中的单表数据想必也越来越大，大到百万、千万、甚至上亿级别的数据，这个时候就很有必要进行数据库读写分离、以及单表分多表进行存储，提高性能&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;178.66854407209&quot;&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;感觉很久没写文章了，最近也比较忙，写的相对比较少，抽空分享基于&lt;code&gt;Dapper&lt;/code&gt; 的分库分表开源框架&lt;code&gt;core-data&lt;/code&gt;的强大功能，更好的提高开发过程中的效率；&lt;br/&gt;在数据库的数据日积月累的积累下，业务数据库中的单表数据想必也越来越大，大到百万、千万、甚至上亿级别的数据，这个时候就很有必要进行数据库读写分离、以及单表分多表进行存储，提高性能，但是呢很多人不知道怎么去分库分表，也没有现成的分库分表的成熟框架，故不知道怎么下手，又怕影响到业务；现在我给大家推荐&lt;code&gt;core-data&lt;/code&gt;的分库分表开源框架。框架开源地址:&lt;a href=&quot;https://github.com/overtly/core-data&quot;&gt;https://github.com/overtly/core-data&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、基础&quot;&gt;二、基础&lt;/h2&gt;
&lt;h3 id=&quot;21-回顾&quot;&gt;2.1 回顾&lt;/h3&gt;
&lt;p&gt;这里先来回顾下我上一篇文章中的技术栈路线图，如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202004/824291-20200406223103730-527609758.jpg&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;今天从这张技术栈图中来详细分享一切的基础数据库底层操作ORM。&lt;/p&gt;
&lt;h3 id=&quot;22-core-data主要优势：&quot;&gt;2.2 core-data主要优势：&lt;/h3&gt;
&lt;p&gt;上一篇文章&lt;a href=&quot;https://www.cnblogs.com/jlion/p/12635845.html&quot;&gt;.Net 微服务架构技术栈的那些事&lt;/a&gt; 中简单的介绍了&lt;code&gt;core-data&lt;/code&gt;主要优势，如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;官方建议使用DDD 领域驱动设计思想开发&lt;/li&gt;
&lt;li&gt;支持多种数据库（MySql / SqlServer / SQLite ），简单配置添加链接的配置即可&lt;/li&gt;
&lt;li&gt;支持分表操作，自定义分表策略的支持&lt;/li&gt;
&lt;li&gt;支持表达式方式编写，减少写Sql语句机械性工作&lt;/li&gt;
&lt;li&gt;可对Dapper 进行扩展&lt;/li&gt;
&lt;li&gt;性能依赖于Dapper 本身的性能，Dapper 本身是轻量级ORM ，官方测试性能都强于其他的ORM&lt;/li&gt;
&lt;li&gt;框架支持Framework4.6 - NetStandard 2.0&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、实战详解&quot;&gt;三、实战详解&lt;/h2&gt;
&lt;p&gt;这里都仅仅分享核心的内容代码，不把整个代码贴出来，有需要完整Demo源代码请访问 &lt;a href=&quot;https://github.com/a312586670/NetCoreDemo&quot;&gt;https://github.com/a312586670/NetCoreDemo&lt;/a&gt;&lt;br/&gt;在我的解决方案的项目中 引用&lt;code&gt;overt.core.data&lt;/code&gt; nuget包，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202004/824291-20200425215727930-1158176782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;31-单表模式&quot;&gt;3.1 单表模式&lt;/h3&gt;
&lt;p&gt;创建用户实体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 标注数据库对应的表名
    /// &amp;lt;/summary&amp;gt;
    [Table(&quot;User&quot;)]
    public class UserEntity
    {
        /// &amp;lt;summary&amp;gt;
        /// 主键ID,标注自增ID
        /// &amp;lt;/summary&amp;gt;
        [Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int UserId { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 商户ID
        /// &amp;lt;/summary&amp;gt;
        public int MerchantId { set; get; }

        /// &amp;lt;summary&amp;gt;
        /// 用户名
        /// &amp;lt;/summary&amp;gt;
        public string UserName { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 真实姓名
        /// &amp;lt;/summary&amp;gt;
        public string RealName { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 密码
        /// &amp;lt;/summary&amp;gt;
        public string Password { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 添加时间
        /// &amp;lt;/summary&amp;gt;
        public DateTime AddTime { get; set; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中通过&lt;code&gt;[Table(&quot;User&quot;)]&lt;/code&gt; 来和数据库表进行映射关联；&lt;br/&gt;通过[Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)] 标注自增主键.&lt;/p&gt;
&lt;h3 id=&quot;32-默认分表策略&quot;&gt;3.2 默认分表策略&lt;/h3&gt;
&lt;p&gt;从单表模式改成分表模式，并且按照商户的模式进行分表，代码实体代码改造如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   /// &amp;lt;summary&amp;gt;
    /// 标注数据库对于的表名
    /// &amp;lt;/summary&amp;gt;
    [Table(&quot;User&quot;)]
    public class UserEntity
    {
        /// &amp;lt;summary&amp;gt;
        /// 主键ID,标注自增ID
        /// &amp;lt;/summary&amp;gt;
        [Key, DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int UserId { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 商户ID
        /// &amp;lt;/summary&amp;gt;
        [Submeter(Bit =2)]
        public int MerchantId { set; get; }

        /// &amp;lt;summary&amp;gt;
        /// 用户名
        /// &amp;lt;/summary&amp;gt;
        public string UserName { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 真实姓名
        /// &amp;lt;/summary&amp;gt;
        public string RealName { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 密码
        /// &amp;lt;/summary&amp;gt;
        public string Password { get; set; }

        /// &amp;lt;summary&amp;gt;
        /// 添加时间
        /// &amp;lt;/summary&amp;gt;
        public DateTime AddTime { get; set; }
    }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中 MerchantId 字段上添加了&lt;code&gt;[Submeter(Bit =2)]&lt;/code&gt;标注，并且指定了Bit=2，将会分成根据MerchantId字段取二进制进行md5 hash 取前两位分成256张表&lt;/p&gt;
&lt;h4 id=&quot;分表模式源码分析&quot;&gt;分表模式源码分析&lt;/h4&gt;
&lt;p&gt;分表模式可以通过在字段上标注&lt;code&gt;Submeter&lt;/code&gt;属性，我们先来看看框架对于这个标注的源代码，源代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /// &amp;lt;summary&amp;gt;
    /// 分表标识
    /// &amp;lt;/summary&amp;gt;
    public class SubmeterAttribute : Attribute
    {
        /// &amp;lt;summary&amp;gt;
        /// 16进制位数
        /// 1 16
        /// 2 256
        /// 3 4096 
        /// ...
        /// &amp;lt;/summary&amp;gt;
        public int Bit { get; set; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;开源框架中其中一个获得分表的表名称的扩展方法，仅仅只贴了一个扩展方法，有兴趣的可以下载开源框架进行源码阅读。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;        /// &amp;lt;summary&amp;gt;
        /// 获取表名
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;entity&quot;&amp;gt;实体实例&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;tableNameFunc&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        public static string GetTableName&amp;lt;TEntity&amp;gt;(this TEntity entity, Func&amp;lt;string&amp;gt; tableNameFunc = null) where TEntity : class, new()
        {
            if (tableNameFunc != null)
                return tableNameFunc.Invoke();

            var t = typeof(TEntity);
            var mTableName = t.GetMainTableName();
            var propertyInfo = t.GetProperty&amp;lt;SubmeterAttribute&amp;gt;();
            if (propertyInfo == null) // 代表没有分表特性
                return mTableName;

            // 获取分表
            var suffix = propertyInfo.GetSuffix(entity);
            return $&quot;{mTableName}_{suffix}&quot;;
        }

        /// &amp;lt;summary&amp;gt;
        /// 获取后缀(默认根据SubmeterAttribute 标注的位数进行Md5 hash 进行分表)
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;val&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;bit&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        internal static string GetSuffix(string val, int bit = 2)
        {
            if (string.IsNullOrEmpty(val))
                throw new ArgumentNullException($&quot;分表数据为空&quot;);
            if (bit &amp;lt;= 0)
                throw new ArgumentOutOfRangeException(&quot;length&quot;, &quot;length必须是大于零的值。&quot;);

            var result = Encoding.Default.GetBytes(val.ToString());    //tbPass为输入密码的文本框
            var md5Provider = new MD5CryptoServiceProvider();
            var output = md5Provider.ComputeHash(result);
            var hash = BitConverter.ToString(output).Replace(&quot;-&quot;, &quot;&quot;);  //tbMd5pass为输出加密文本

            var suffix = hash.Substring(0, bit).ToUpper();
            return suffix;
        }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源代码中通过&lt;code&gt;SubmeterAttribute&lt;/code&gt; 特性进行对字段进行标注分表，可以传对应的bit参数进行框架默认的分表策略进行分表，但是很多情况下我们需要自定义分表策略，那我们应该怎么去自定义分表策略呢？我们先等一下来实践自定义分表策略，先来创建用户的&lt;code&gt;Repository&lt;/code&gt;，代码如下&lt;br/&gt;&lt;code&gt;IUserRepository&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IUserRepository : IBaseRepository&amp;lt;UserEntity&amp;gt;
{
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要继承&lt;code&gt;IBaseRepository&amp;lt;T&amp;gt;&lt;/code&gt;的接口，该接口默认实现了基本的方法，开源框架中&lt;code&gt;IBaseRepository&amp;lt;T&amp;gt;&lt;/code&gt;代码方法如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202004/824291-20200424232830812-1051693197.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;创建完&lt;code&gt;IUserRepository&lt;/code&gt;接口后，我们来创建它的实现&lt;code&gt;UserRepository&lt;/code&gt;,代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class UserRepository : BaseRepository&amp;lt;UserEntity&amp;gt;, IUserRepository
{
        public UserRepository(IConfiguration configuration)
            : base(configuration, &quot;user&quot;)
        {
        }
 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中&lt;code&gt;UserRepository&lt;/code&gt;类继承了&lt;code&gt;BaseRepository&amp;lt;T&amp;gt;&lt;/code&gt;类，我们来看看这个abstract类的基本结构，如下图:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202004/824291-20200424233618475-1988799785.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;开源框架中&lt;code&gt;BaseRepository&amp;lt;T&amp;gt;&lt;/code&gt;抽象类继承了&lt;code&gt;PropertyAssist&lt;/code&gt;类，我们再来看看它的有哪些方法，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202004/824291-20200424233822342-9035015.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;从图中可以看到定义了一系列的&lt;code&gt;virtual&lt;/code&gt;方法，那既然是&lt;code&gt;virtual&lt;/code&gt;方法我们就可以进行重写&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;CreateScriptFunc&lt;/code&gt;:自动创建脚本数据表方法&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TableNameFunc&lt;/code&gt;：可以进行自定义分表策略&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;33-自定义分表策略&quot;&gt;3.3 自定义分表策略&lt;/h3&gt;
&lt;p&gt;我们来实现上面提出的自定义分表策略问题（根据商户Id来进行分表,并且自动把不存在的表进行初始化创建），代码改造如下：&lt;br/&gt;&lt;code&gt;IUserRepository&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface IUserRepository : IBaseRepository&amp;lt;UserEntity&amp;gt;
{
    int MerchantId { set; get; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;UserRepository&lt;/code&gt; 代码改造如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class UserRepository : BaseRepository&amp;lt;UserEntity&amp;gt;, IUserRepository
{
        public UserRepository(IConfiguration configuration)
            : base(configuration, &quot;user&quot;)
        {
        }

        /// &amp;lt;summary&amp;gt;
        /// 用于根据商户ID来进行分表
        /// &amp;lt;/summary&amp;gt;
        public int MerchantId { set; get; }

        //自定义分表策略
        public override Func&amp;lt;string&amp;gt; TableNameFunc =&amp;gt; () =&amp;gt;
        {
            var tableName = $&quot;{GetMainTableName()}_{MerchantId}&quot;;
            return tableName;
        };

        //自动创建分表的脚本
        public override Func&amp;lt;string, string&amp;gt; CreateScriptFunc =&amp;gt; (tableName) =&amp;gt;
        {
            //MySql
            return &quot;CREATE TABLE `&quot; + tableName + &quot;` (&quot; +
                   &quot;  `UserId` int(11) NOT NULL AUTO_INCREMENT,&quot; +
                   &quot;  `UserName` varchar(200) DEFAULT NULL,&quot; +
                   &quot;  `Password` varchar(200) DEFAULT NULL,&quot; +
                   &quot;  `RealName` varchar(200) DEFAULT NULL,&quot; +
                   &quot;  `AddTime` datetime DEFAULT NULL,&quot; +
                   &quot;  `MerchantId` int(11) NOT NULL,&quot; +
                   &quot;  PRIMARY KEY(`UserId`)&quot; +
                   &quot;) ENGINE = InnoDB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4; &quot;;
        };
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;34-数据库读写分离&quot;&gt;3.4 数据库读写分离&lt;/h3&gt;
&lt;p&gt;我们再来看看开源框架的基类代码结构截图，如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202004/824291-20200425000721068-822231814.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;对于查询的基本常用的方法都有一个&lt;code&gt;isMaster=false&lt;/code&gt;的参数，该参数就是用于是否读取主库，用于基本的主从数据库的分离，也就是读写分离，那改怎么配置读写分离数据库呢&lt;br/&gt;链接字符串如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202004/824291-20200425001833270-1758529717.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;分别指定了主从数据库的链接字符串.&lt;br/&gt;我们来分析源代码，核心框架源代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/// &amp;lt;summary&amp;gt;
/// 连接配置信息获取
/// 1. master / secondary
/// 2. xx.master / xx.secondary
/// &amp;lt;/summary&amp;gt;
public class DataSettings
{
        #region Static Private Members
        static readonly string _connNmeOfMaster = &quot;master&quot;;
        static readonly string _connNameOfSecondary = &quot;secondary&quot;;
        static readonly string _connNameOfPoint = &quot;.&quot;;
        static string _connNameOfPrefix = &quot;&quot;;
        #endregion

        #region Private Member
        /// &amp;lt;summary&amp;gt;
        /// 主库
        /// &amp;lt;/summary&amp;gt;
        private string Master
        {
            get { return $&quot;{_connNameOfPrefix}{_connNmeOfMaster}&quot;; }
        }
        /// &amp;lt;summary&amp;gt;
        /// 从库
        /// &amp;lt;/summary&amp;gt;
        private string Secondary
        {
            get
            {
                return $&quot;{_connNameOfPrefix}{_connNameOfSecondary}&quot;;
            }
        }
        #endregion

        /// &amp;lt;summary&amp;gt;
        /// 获取链接名称
        /// &amp;lt;/summary&amp;gt;
        /// &amp;lt;param name=&quot;isMaster&quot;&amp;gt;&amp;lt;/param&amp;gt;
        /// &amp;lt;param name=&quot;store&quot;&amp;gt;不能包含点&amp;lt;/param&amp;gt;
        /// &amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;
        private string Key(bool isMaster = false, string store = &quot;&quot;)
        {
            _connNameOfPrefix = string.IsNullOrEmpty(store) ? &quot;&quot; : $&quot;{store}{_connNameOfPoint}&quot;;
            var connName = string.Empty;
            if (isMaster)
                connName = Master;
            else
                connName = Secondary;

            return connName;
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中根据isMaster 参数来进行读写数据库链接参数的获取，以达到读写分离的功能，同时还支持前缀的配置支持，也开源自由配置多个数据库进行读取，只需要构造函数中获取配置即可。&lt;br/&gt;上面的分表Demo 单元测试运行后的结果例子如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202004/824291-20200429212822815-491838590.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;已经按照MerchantId 字段进行分表&lt;/p&gt;
&lt;h2 id=&quot;三、总结&quot;&gt;三、总结&lt;/h2&gt;
&lt;p&gt;到这里用户表已经根据商户ID进行分表存储了，这样就做到了读写分离及自定义分表策略存储数据，&lt;code&gt;core-data&lt;/code&gt; 开源框架还支持更多的强大功能，实现了一系列的基础CRUD的方法，不用写任何的sql语句，Where表达式的支持，同时可以自定义复杂的sql语句，更多请访问框架开源地址:&lt;a href=&quot;https://github.com/overtly/core-data&quot;&gt;https://github.com/overtly/core-data&lt;/a&gt;.&lt;br/&gt;完整的Demo 代码 已经放在github上，Demo代码结构图如下:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/824291/202004/824291-20200425211804354-1425360143.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;地址：&lt;a href=&quot;https://github.com/a312586670/NetCoreDemo&quot;&gt;https://github.com/a312586670/NetCoreDemo&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;原创不易，觉得对你有帮助请给一个赞&quot;&gt;原创不易，觉得对你有帮助请给一个赞&lt;/h4&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 04 May 2020 00:09:00 +0000</pubDate>
<dc:creator>Jlion</dc:creator>
<og:description>在数据库的数据日积月累的积累下，业务数据库中的单表数据想必也越来越大，大到百万、千万、甚至上亿级别的数据，这个时候就很有必要进行数据库读写分离、以及单表分多表进行存储，提高性能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jlion/p/12771167.html</dc:identifier>
</item>
<item>
<title>ubuntu 使用 vsftpd 基于系统用户配置相互隔离的 ftp (ftps) 服务并禁止账户 ssh shell 登陆功能 - 张晓栋</title>
<link>http://www.cnblogs.com/berkerdong/p/12825196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/berkerdong/p/12825196.html</guid>
<description>&lt;p&gt;    我们在日常使用 UbuntuServer 服务器时，经常会直接使用基于 ssh 的  sftp 连接服务器直接进行文件上传和下载，不过这个方式其实有一定的安全隐患，当一个团队有多个人员，需要连接服务器去发布时，如果使用 ssh 则意味着需要将系统的 账户和密码 告知对方，别人就不仅拥有了 sftp 的连接权限，同时也拥有了 ssh 的连接权限，意味着可以直接登陆服务器，而且 对方使用 sftp 登陆之后可以看到服务器上全部的文件，这显示是不符合预期的，我们要的仅仅是给对方提供一个 ftp 文件上传下载的权限，并且最好能够限定到具体的目录。&lt;/p&gt;

&lt;p&gt;    针对上面的痛点，我也百度看过不少解决方案，有人说可以 通过配置 账户的 shell ，比如 /usr/sbin/nologin 来实现 账户禁止 ssh 登陆，只保留 sftp 权限，然而我按照多个文章的教程，进行反复操作之后，发现这样的配置确实禁止对应账户远程登陆 ssh 了，但是，，，sftp 也连不上了，，所以在反复实验之后，选择放弃，这时回归最原始的点，想想我需要的是一个ftp服务来提供文件上传下载的方法，为何不直接独立配置 ftp 服务，顺着这个思路，我找到了 Linux Server 下非常优秀的一款软件  vsftpd，这款软件 支持  ftp, ftps(隐式加密), ftpes(显示加密) ，可以完美解决我们的需求，接下来开始我们的正文，在 Ubuntu Server 配置 vsftpd 实现不同通过账户，指向不同的文件夹，并且禁用账户的 shell 登陆功能。&lt;/p&gt;

&lt;p&gt;    sudo apt-get update   #刷新软件源信息&lt;/p&gt;
&lt;p&gt;    sudo apt-get vsftpd    #安装 vsftpd&lt;/p&gt;

&lt;p&gt;    sudo vim /etc/vsftpd.conf   安装好之后开始编辑配置文件，进行如下几项的调整，有些配置项在配置文件中本来存在，修改对应的值即可，有些则不存在需要手动编写，在操作的时候小伙伴要注意    &lt;/p&gt;
&lt;p&gt;    listen=YES                            #开启监听 ipv4 地址&lt;/p&gt;
&lt;p&gt;    listen_ipv6=NO                    #关闭监听 ipv6 地址，ipv4 和 ipv6 不可以同时监听，否则会无法启动&lt;/p&gt;
&lt;p&gt;    chroot_local_user=YES        #限定用户只能操作主目录&lt;/p&gt;
&lt;p&gt;    write_enable=YES                #开启文件写入功能&lt;/p&gt;
&lt;p&gt;    ssl_enable=YES                    #开启 ssl 加密功能，默认为 ftpes 显示加密&lt;/p&gt;
&lt;p&gt;    ssl_tlsv1=YES                       #开启 tlsv1 加密支持，默认为 tlsv1&lt;/p&gt;
&lt;p&gt;    ssl_sslv2=YES                       #开启 sslv2 协议支持&lt;/p&gt;
&lt;p&gt;    ssl_sslv3=YES                       #开启 sslv3 协议支持&lt;/p&gt;
&lt;p&gt;    implicit_ssl=YES                   #指定ssl 加密方式为隐式加密（该项开启之后 ftp 工作于 ftps 隐式加密模式下，ftps 模式端口默认为 990，需要特意指定端口为 990，如果不开启则，不需要修改端口）&lt;/p&gt;
&lt;p&gt;    listen_port=990                    #设定ftp服务端口 （默认情况不需要指定端口值，implicit_ssl=YES 时才需要该端口配置，个人推荐使用隐式加密，连接更加稳定）&lt;/p&gt;
&lt;p&gt;    file_open_mode=0777         #配置 用户默认上传的文件权限为 0777 &lt;/p&gt;
&lt;p&gt;    pasv_min_port=6000           #被动连接模式 最小端口&lt;/p&gt;
&lt;p&gt;    pasv_max_port=7000          #被动连接模式最大端口&lt;/p&gt;
&lt;p&gt;    pasv_enable=YES                 #启用被动连接模式&lt;/p&gt;
&lt;p&gt;    pasv_address=x.x.x.x           #服务器对应的外部IP地址（云服务器，这里一定要填写外网ip地址，如果在内网中使用这边，这行配置可以直接注释）&lt;/p&gt;

&lt;p&gt;    经过上面的调整，vsftpd 模块就算配置完成了，大家可能在百度的时候可能会看到别人还要配置其他很多选项，但是那些其实没必要了，vsftpd 的默认配置，在加上我们上面的调整就相对来说比较完美了，下面介绍三个 vsftpd 的常用命令。&lt;/p&gt;
&lt;p&gt;    sudo service vsftpd start         #启动 vsftpd&lt;/p&gt;
&lt;p&gt;    sudo service vsftpd restart     #重启 vsftpd&lt;/p&gt;
&lt;p&gt;    sudo service vsftpd stop        #停止 vsftpd&lt;/p&gt;

&lt;p&gt;    vsftpd服务安装完成之后，就可以创建账户来进行测试，我们今天教大家的方法，账户是基于系统账户来配置的，操作如下：&lt;/p&gt;
&lt;p&gt;    vim /etc/shells       #编辑系统 shell 规则，加入静止登陆的 shell 规则，追加在文件最后一行即可&lt;/p&gt;
&lt;p&gt;    /usr/sbin/nologin    #屏蔽 ssh 登陆&lt;/p&gt;

&lt;p&gt;    sudo useradd xiaoming      #创建用户xiaoming&lt;/p&gt;
&lt;p&gt;    sudo passwd xiaoming        #修改用户 xiaoming 的密码&lt;/p&gt;
&lt;p&gt;    sudo usermod -d /var/www xiaoming        #为xiaoming 指定账户主目录&lt;/p&gt;
&lt;p&gt;    sudo chmod 555 /var/www        #去除主目录的可写权限 （vsfpd在 chroot_local_user=YES 禁止默认的登陆目录拥有可写权限，如果拥有则会无法登陆）&lt;/p&gt;
&lt;p&gt;    sudo usermod -s /usr/sbin/nologin xiaoming        #屏蔽xiaoming对于系统的 ssh 登陆权限    如果要重新放开登陆权限，执行 sudo usermod -s /bin/bash xiaoming&lt;/p&gt;

&lt;p&gt;    这样一来我就创建了一个账户xiaoming，该账户无法使用 ssh 连接系统，但是支持 ftp 登陆系统，ftp 登陆系统之后默认就会进入 ubuntu 中 nginx 默认的网站目录  /var/www ，这个其实就是我们配置的主目录，大家可以根据自己需求自己调整，主目录地址。客户端这时候可以进行连接测试，客户端推荐使用 FileZilla 创建一个站点，注意 协议选择 ftp，加密方式 选择 要求隐式的 FTP over TLS，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://www.onekib.com/Upload/2020-05-04/6372417504446464688968060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    FileZilla 这时候应该就可以连接到我们 ftp 服务器了，这时候各位如果进行文件上传动作，应该会全部失败，因为我之前设定了主目录的权限为 555，意味着没有任何的可写权限，所以我们需要 在 服务器上提前创建好子目录，以方便我们使用，操作如下：&lt;/p&gt;

&lt;p&gt;    sudo mkdir /var/www/www.xxxx.com            #创建一个文件夹用于存放 www.xxxx.com 的文件&lt;/p&gt;
&lt;p&gt;    sudo chmod 777 /var/www/www.xxxx.com        #调整创建的文件夹权限为 777 &lt;/p&gt;

&lt;p&gt;    这时候我们重新刷新 ftps 应该就可以看到我们创建的  www.xxxx.com 这个文件夹了，点击进入这个文件夹，然后进行文件上传下载删除动作就会发现全部都可以正常操作了。&lt;/p&gt;
</description>
<pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate>
<dc:creator>张晓栋</dc:creator>
<og:description>我们在日常使用 UbuntuServer 服务器时，经常会直接使用基于 ssh 的 sftp 连接服务器直接进行文件上传和下载，不过这个方式其实有一定的安全隐患，当一个团队有多个人员，需要连接服务器去</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/berkerdong/p/12825196.html</dc:identifier>
</item>
<item>
<title>卷积神经网络入门篇 - 奥辰</title>
<link>http://www.cnblogs.com/chenhuabin/p/12825192.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenhuabin/p/12825192.html</guid>
<description>&lt;p&gt;最后，完整总结一下卷积神经网络构建和训练步骤：&lt;/p&gt;
&lt;p&gt;Step 1 ：随机初始化所有滤波器参数和权重，设定网络中超参数，例如过滤器的个数、长宽、网络结构等等。&lt;/p&gt;
&lt;p&gt;Step 2 ：将一张张训练图像“喂”给网络，图像在网络中将依次完成前向传播的过程（卷积层-&amp;gt;池化层-&amp;gt;全连接层），最终输出一个概率向量。由于初始时所有参数、权重均为随机设置，所以，刚开始时网络判别后输出的准确率也很低（基本随机），例如上图14中输出为小船的概率为[0.2, 0.4, 0.1, 0.3]。&lt;/p&gt;
&lt;p&gt;Step 3 ：计算输出层输出概率向量与真实分类的总误差，计算公式如下： $$Total{\text{ }}Error = \frac{1}{2}\sum {{{(target{\text{ }}probalility - output{\text{ }}probability)}^2}} $$&lt;/p&gt;
&lt;p&gt;Step 4 ：使用反向传播算法来计算误差相对于网络中所有权重的梯度，并使用梯度下降法来更新所有卷积层参数和网络中各权重参数值，以最小化输出误差。在这个更新过程中，权重是根据该参数对误差的影响力来寄信调整的，当一次反向传播更新完成后，再一次输入同一图像时，输出概率现在可能是[0.1, 0.1, 0.7, 0.1]，更接近目标向量[0, 0, 1, 0]，这意味着网络已学会通过调整其滤波器参数和网络权重参数来正确分类该特定图像，从而减少输出误差。注意，诸如滤波器数量、大小，网络体系结构等参数在步骤1之前都已固定，在训练过程中不会更改，这一步骤仅更新滤波器矩阵中的值和网络连接权重。&lt;/p&gt;
&lt;p&gt;Step 5 ： 重复2-4步骤，指导网络满足指定终止训练条件，例如迭代次数达到指定数量或准确率达标。&lt;/p&gt;
</description>
<pubDate>Sun, 03 May 2020 23:49:00 +0000</pubDate>
<dc:creator>奥辰</dc:creator>
<og:description>卷积神经网络（Convolutional Neural Networks）,通常我们将之简称为ConvNets或者CNN，它是一种在图像识别和分类领域十分流行且行之有效的神经网络。目前，CNN网络已经</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenhuabin/p/12825192.html</dc:identifier>
</item>
<item>
<title>老师，你确定Java注释不会被执行吗？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12825167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12825167.html</guid>
<description>&lt;p&gt;之前在博客上分享过一篇文章，涉及到 Java 中的注释，就信誓旦旦地写了一句话：“注释是不会被执行的！”结果，有小伙伴留言说，“老师，你确定吗？”&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/java-zhushi-01.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;我这个人一直有个优点，就是能听得进去别人的声音，管你是赞美的还是批评的，从来都是虚心接受。因为我相信，大多数小伙伴都是出于善的目的。&lt;/p&gt;
&lt;p&gt;况且，我在技术上从来没想过要成为多牛逼的大佬，就是喜欢分享的感觉，而已。很多文章中出现的错误，我都原封不动的保留，因为如果把修正了，那么留言中那些指出错误的人，在后来的读者眼里，就会觉得不合时宜。&lt;/p&gt;
&lt;p&gt;那些 diss 我的小伙伴们，放心，我是不会介意的。&lt;/p&gt;
&lt;p&gt;尽管如此，但对于注释这件事，真的是不能忍啊！注释肯定不会被执行啊，我想这位小伙伴一定是在讽刺我。于是我就私信问他为什么，然后他就甩给了我下面这段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(name);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我拷贝到 IDEA 中跑了一下，结果程序输出的结果出乎我的意料：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs&quot;&gt;沉默王三&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;竟然是王三，不是王二。看到这个结果，我算是彻底懵逼了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/java-zhushi-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;那一刹那，我感觉这十来年的 Java 算是白学了。大学那会，老师说注释是不会执行的；就连《编程思想》里也说注释是不会执行的。那现在谁能告诉我这到底为什么？&lt;/p&gt;
&lt;p&gt;不是说程序的世界很单纯吗？不是 0 就是 1？事情搞到这个地步，只能花心思好好研究一下了。&lt;/p&gt;
&lt;p&gt;单纯从代码上来看，问题应该出在那串特殊的字符上——&lt;code&gt;\u000d&lt;/code&gt;，如果不是它在作怪，把 name 的值由“沉默王二”修改为了“沉默王三”，就没有别的原因了——没别的，凭借多年的工作经验，找问题的根源我还是很得心应手的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\u000d&lt;/code&gt; 虽然看上去比较陌生，但我知道它是一个 Unicode 字符。问了一下搜索引擎后，知道它代表一个换行符——一种恍然大悟的感觉啊。我知道，Java 编译器不仅会编译代码，还会解析 Unicode 字符。&lt;/p&gt;
&lt;p&gt;我大致看了一眼上面这段代码编译后的字节码，它长下面这个样子：&lt;/p&gt;
&lt;pre readability=&quot;7&quot;&gt;
&lt;code class=&quot;hljs javascript&quot; readability=&quot;8&quot;&gt;&lt;br/&gt;public &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;com&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;cmower&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;dzone&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;secret&lt;/span&gt;/&lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;p&gt;&lt;br/&gt;public &amp;lt;init&amp;gt;()V&lt;br/&gt;L0&lt;br/&gt;LINENUMBER &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt; L0&lt;br/&gt;ALOAD &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;INVOKESPECIAL java/lang/&lt;span class=&quot;hljs-built_in&quot;&gt;Object&lt;/span&gt;.&amp;lt;init&amp;gt; ()V&lt;br/&gt;RETURN&lt;br/&gt;L1&lt;br/&gt;LOCALVARIABLE &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; Lcom/cmower/dzone/secret/Test; L0 L1 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;MAXSTACK = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;MAXLOCALS = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; main([Ljava/lang/&lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;;)V&lt;br/&gt;L0&lt;br/&gt;LINENUMBER &lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt; L0&lt;br/&gt;LDC &lt;span class=&quot;hljs-string&quot;&gt;&quot;\u6c89\u9ed8\u738b\u4e8c&quot;&lt;/span&gt;&lt;br/&gt;ASTORE &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;L1&lt;br/&gt;LINENUMBER &lt;span class=&quot;hljs-number&quot;&gt;6&lt;/span&gt; L1&lt;br/&gt;LDC &lt;span class=&quot;hljs-string&quot;&gt;&quot;\u6c89\u9ed8\u738b\u4e09&quot;&lt;/span&gt;&lt;br/&gt;ASTORE &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;L2&lt;br/&gt;LINENUMBER &lt;span class=&quot;hljs-number&quot;&gt;7&lt;/span&gt; L2&lt;br/&gt;GETSTATIC java/lang/System.out : Ljava/io/PrintStream;&lt;br/&gt;ALOAD &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/&lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;;)V&lt;br/&gt;L3&lt;br/&gt;LINENUMBER &lt;span class=&quot;hljs-number&quot;&gt;8&lt;/span&gt; L3&lt;br/&gt;RETURN&lt;br/&gt;L4&lt;br/&gt;LOCALVARIABLE args [Ljava/lang/&lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;; L0 L4 &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;LOCALVARIABLE name Ljava/lang/&lt;span class=&quot;hljs-built_in&quot;&gt;String&lt;/span&gt;; L1 L4 &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;MAXSTACK = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;MAXLOCALS = &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;嗯，表示看不懂。不过没关系，把它反编译一下就行了，于是我看到下面这段代码：&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;;&lt;br/&gt;name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王三&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(name);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;咦，两个反斜杠 &lt;code&gt;//&lt;/code&gt; 真的不见了，这可以确定一点——注释确实是不会执行的。只不过 &lt;code&gt;\u000d&lt;/code&gt; 把 &lt;code&gt;name=&quot;沉默王三&quot;;&lt;/code&gt; 挤到了 &lt;code&gt;//&lt;/code&gt; 注释的下一行，就好像下面这段代码的样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Test&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String name = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;;&lt;br/&gt;name=&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王三&quot;&lt;/span&gt;;&lt;br/&gt;System.out.println(name);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那这算不算是 Java 的 bug 呢？说算也不算。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/java-zhushi-03.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;因为通过允许 Java 源代码包含 Unicode 字符，可以确保在世界上任何一个区域编写的代码在其他地方执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;老实说，这段话是我从网上找到，好像明白点啥，又好像不明白。那再来看一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;double&lt;/span&gt; π = Math.PI;&lt;br/&gt;System.out.println(\u03C0);&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假如说程序员小王在创建周期率这个变量的时候，不知道 &lt;code&gt;π&lt;/code&gt; 这个字符怎么敲出来，那么他就可以选择使用 &lt;code&gt;\u03C0&lt;/code&gt; 来替代——编译器知道 &lt;code&gt;\u03C0&lt;/code&gt; 就是 &lt;code&gt;π&lt;/code&gt; 这个变量（编译器会在编译其他代码之前先解析 Unicode 字符）。&lt;/p&gt;
&lt;p&gt;只能说 &lt;code&gt;\u000d&lt;/code&gt; 是一种例外吧。&lt;/p&gt;
&lt;p&gt;当然了，除非特殊情况，不要在源代码中包含 Unicode 字符，以免更改源代码的本意。&lt;/p&gt;
&lt;p&gt;这篇文章没有别的意思，我也不想探究过于深奥的东西，纯粹是提高一下小伙伴们的认知：注释有可能被编译器执行。就好像，鲁迅如果不知道茴香豆的“茴”字有 4 种写法，那他就没办法让孔乙己在鲁镇的那家茶馆里装逼。&lt;/p&gt;
&lt;p&gt;当然了，如果有小伙伴想体验一下装逼的感觉的话，可以把下面这段代码保存在一个名叫 Ugly.java 的文件中：&lt;/p&gt;
&lt;pre readability=&quot;13&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;20&quot;&gt;\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020\u0020&lt;p&gt;\u0063\u006c\u0061\u0073\u0073\u0020\u0055\u0067\u006c\u0079&lt;/p&gt;&lt;p&gt;\u007b\u0070\u0075\u0062\u006c\u0069\u0063\u0020\u0020\u0020&lt;/p&gt;&lt;p&gt;\u0020\u0020\u0020\u0020\u0073\u0074\u0061\u0074\u0069\u0063&lt;/p&gt;&lt;p&gt;\u0076\u006f\u0069\u0064\u0020\u006d\u0061\u0069\u006e\u0028&lt;/p&gt;&lt;p&gt;\u0053\u0074\u0072\u0069\u006e\u0067\u005b\u005d\u0020\u0020&lt;/p&gt;&lt;p&gt;\u0020\u0020\u0020\u0020\u0061\u0072\u0067\u0073\u0029\u007b&lt;/p&gt;&lt;p&gt;\u0053\u0079\u0073\u0074\u0065\u006d\u002e\u006f\u0075\u0074&lt;/p&gt;&lt;p&gt;\u002e\u0070\u0072\u0069\u006e\u0074\u006c\u006e\u0028\u0020&lt;/p&gt;&lt;p&gt;\u0022\u0048\u0065\u006c\u006c\u006f\u0020\u0077\u0022\u002b&lt;/p&gt;&lt;p&gt;\u0022\u006f\u0072\u006c\u0064\u0022\u0029\u003b\u007d\u007d&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在命令行中先执行 &lt;code&gt;javac Ugly.java&lt;/code&gt;，再执行 &lt;code&gt;java Ugly&lt;/code&gt; 命令就可以看到程序结果了：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;Hello&lt;/span&gt; world&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;体验过后，就拉到吧。反正写这样的代码谁也看不懂，除了机器。好了，我亲爱的读者朋友，以上就是本文的全部内容了。是不是感觉认知边界又拓宽了？&lt;/p&gt;
&lt;p&gt;我是沉默王二，一枚有趣的程序员。如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读，回复【&lt;strong&gt;666&lt;/strong&gt;】更有我为你精心准备的 500G 高清教学视频（已分门别类）。&lt;/p&gt;
&lt;blockquote readability=&quot;4.5890410958904&quot;&gt;
&lt;p&gt;本文 &lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;GitHub&lt;/a&gt; 已经收录，有大厂面试完整考点，欢迎 Star。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;原创不易，莫要白票，请你为本文点个赞吧&lt;/strong&gt;，这将是我写作更多优质文章的最强动力。&lt;/p&gt;
</description>
<pubDate>Sun, 03 May 2020 23:15:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>之前在博客上分享过一篇文章，涉及到 Java 中的注释，就信誓旦旦地写了一句话：“注释是不会被执行的！”结果，有小伙伴留言说，“老师，你确定吗？” 我这个人一直有个优点，就是能听得进去别人的声音，管你</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12825167.html</dc:identifier>
</item>
<item>
<title>Linux安装maven(详细教程) - 付宗乐</title>
<link>http://www.cnblogs.com/fuzongle/p/12825048.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fuzongle/p/12825048.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1578696/202005/1578696-20200504012218026-677078673.png&quot; class=&quot;desc_img&quot;/&gt;Maven是意第绪语，意思是“知识的积累者”，最初是为了简化Jakarta Turbine项目中的构建过程。有几个项目，每个项目都有自己的Ant构建文件，所有项目都略有不同。JAR已检入CVS。我们想要一种标准的方式来构建项目，清晰地定义项目的组成，一种简单的方式来发布项目信息，以及一种在多个项目中共享JAR的方式。 　　结果是一个可以用于构建和管理任何基于Java的项目的工具。我们希望我们已经创建了一些东西，可以使Java开发人员的日常工作更加轻松，并且通常有助于理解任何基于Java的项目。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;108.0748373102&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、简介&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　 &lt;span&gt;Maven是意第绪语，意思是“知识的积累者”，最初是为了简化Jakarta Turbine项目中的构建过程。有几个项目，每个项目都有自己的Ant构建文件，所有项目都略有不同。JAR已检入CVS。我们想要一种标准的方式来构建项目，清晰地定义项目的组成，一种简单的方式来发布项目信息，以及一种在多个项目中共享JAR的方式。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　结果是一个可以用于构建和管理任何基于Java的项目的工具。我们希望我们已经创建了一些东西，可以使Java开发人员的日常工作更加轻松，并且通常有助于理解任何基于Java的项目。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、准备工作&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.需要准备一台服务器，大家可以在网上买，个人学习的话还是建议大家去安装一个虚拟机，去装一个Linux系统。关键字点击跳转：&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/fuzongle/p/12760193.html&quot; target=&quot;_blank&quot;&gt;虚拟机安装教程 &lt;/a&gt;&lt;/strong&gt;  &lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/fuzongle/p/12769811.html&quot; target=&quot;_blank&quot;&gt; Linux安装教程&lt;/a&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.需要准备一个远程连接工具，连接到Linux系统，作者采用的是：Xshell 工具 （注意：Xshell下载地址翻到本文最下面）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.maven官方下载地址如下：（注意：maven下载地址翻到本文最下面）&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.apache.org/download.cgi&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1578696/202005/1578696-20200504012218026-677078673.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; 三、开始安装(注意：下图哪个步骤不会配置，翻到最下面进群学习)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.将下载好的maven安装包放在磁盘的 /usr/local/ 目录下，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1578696/202005/1578696-20200504012708606-1736994750.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.解压apache-maven-3.6.3-bin.tar.gz文件。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;tar -zxvf apache-maven-3.6.3-bin.tar.gz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1578696/202005/1578696-20200504013103263-1935747855.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.配置maven仓库，设置阿里镜像仓库，一定要配置一下，国内的下载jar快些，首先进入cd apache-maven-3.6.3目录，创建仓库存储目录，mkdir ck。如下图：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd apache-maven-&lt;span&gt;3.6&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;   #进入apache-maven-&lt;span&gt;3.6&lt;/span&gt;&lt;span&gt;.3目录

mkdir ck    #创建ck目录&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1578696/202005/1578696-20200504013748029-411706936.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.进入cd conf目录，编辑 vi settings.xml文件，找到·localRepository下面复制一行加上&amp;lt;localRepository&amp;gt;/usr/local/apache-maven-3.6.3/ck&amp;lt;/localRepository&amp;gt;， 在找到mirror 加上阿里的仓库配置，配置完成报错退出，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;cd conf            # 进入conf目录

vi settings.xm # settings.xm文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;localRepository&amp;gt;/usr/local/apache-maven-3.6.3/ck&amp;lt;/localRepository&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &amp;lt;mirror&amp;gt;
      &amp;lt;id&amp;gt;alimaven&amp;lt;/id&amp;gt;
      &amp;lt;name&amp;gt;aliyun maven&amp;lt;/name&amp;gt;
       &amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.aliyun.com/nexus/content/groups/public/&amp;lt;/url&amp;gt;&lt;/span&gt;
      &amp;lt;mirrorOf&amp;gt;central&amp;lt;/mirrorOf&amp;gt;
&amp;lt;/mirror&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1578696/202005/1578696-20200504014133783-370023732.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1578696/202005/1578696-20200504014626764-1854115982.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.配置maven环境变量，编辑：&lt;/span&gt;&lt;span&gt;vi /etc/profile 文件，翻到最后一行加上 &lt;/span&gt;&lt;span&gt;export MAVEN_HOME=/usr/local/apache-maven-3.6.3  export PATH=$PATH:$MAVEN_HOME/bin &lt;/span&gt;&lt;em&gt; 保存退出，如下图：&lt;/em&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vi /etc/profile&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;export MAVEN_HOME=/usr/local/apache-maven-&lt;span&gt;3.6&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt;&lt;span&gt;
export PATH&lt;/span&gt;=$PATH:$MAVEN_HOME/bin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1578696/202005/1578696-20200504015236219-301466376.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;6.重新加载一下，source /etc/profile 使新增配置生效，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;source /etc/profile&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1578696/202005/1578696-20200504015441453-414617842.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;7.到此以安装完成，测试一下，输入命令：mvn -v ，如下：&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1578696/202005/1578696-20200504015600345-2022200740.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;注意：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.如果有任何不懂的地方可以咨询我，随时欢迎互相帮助。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.技术交流群QQ：422167709。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.如果希望学习更多，希望微信扫码，长按扫码，帮忙关注一下，举手之劳，当您无助的时候真的能帮你，感谢您关注公众号 &quot;编程小乐&quot;，回复 “Xshell” 领取软件下载地址，&lt;/strong&gt;回复 “maven” 领取软件下载地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1578696/202004/1578696-20200420222937957-991526763.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;











&lt;p&gt;熬熬&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 03 May 2020 18:05:00 +0000</pubDate>
<dc:creator>付宗乐</dc:creator>
<og:description>一、简介 Maven是意第绪语，意思是“知识的积累者”，最初是为了简化Jakarta Turbine项目中的构建过程。有几个项目，每个项目都有自己的Ant构建文件，所有项目都略有不同。JAR已检入CV</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fuzongle/p/12825048.html</dc:identifier>
</item>
<item>
<title>Servlet 教程——检视阅读 - 卡斯特梅的雨伞</title>
<link>http://www.cnblogs.com/castamere/p/12825015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/castamere/p/12825015.html</guid>
<description>&lt;p&gt;Servlet 教程——检视阅读&lt;/p&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;Servlet教程——菜鸟——蓝本&lt;/p&gt;
&lt;p&gt;Servlet教程——w3cschool&lt;/p&gt;
&lt;p&gt;Servlet教程——易百&lt;/p&gt;
&lt;p&gt;servlet依赖maven依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    &amp;lt;!--servlet依赖--&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;javax.servlet&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;javax.servlet-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;3.0.1&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;
&amp;lt;!--    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;javax.servlet.jsp&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;jsp-api&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.1&amp;lt;/version&amp;gt;
      &amp;lt;scope&amp;gt;provided&amp;lt;/scope&amp;gt;
    &amp;lt;/dependency&amp;gt;--&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;略读&lt;/p&gt;
&lt;p&gt;Servlet 为创建基于 web 的应用程序提供了基于组件、独立于平台的方法，可以不受 CGI 程序的性能限制。Servlet 有权限访问所有的 Java API，包括访问企业级数据库的 JDBC API。&lt;/p&gt;
&lt;p&gt;Servlet 是什么？&lt;/p&gt;
&lt;p&gt;Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。&lt;/p&gt;
&lt;p&gt;使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。&lt;/p&gt;
&lt;p&gt;Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;性能明显更好。&lt;/li&gt;
&lt;li&gt;Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。&lt;/li&gt;
&lt;li&gt;Servlet 是独立于平台的，因为它们是用 Java 编写的。&lt;/li&gt;
&lt;li&gt;服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。&lt;/li&gt;
&lt;li&gt;Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Servlet 架构&lt;/p&gt;
&lt;p&gt;下图显示了 Servlet 在 Web 应用程序中的位置。&lt;/p&gt;
&lt;p&gt;Servlet 生命周期&lt;/p&gt;
&lt;p&gt;Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Servlet 通过调用 init () 方法进行初始化。&lt;/li&gt;
&lt;li&gt;Servlet 调用 service() 方法来处理客户端的请求。&lt;/li&gt;
&lt;li&gt;Servlet 通过调用 destroy() 方法终止（结束）。&lt;/li&gt;
&lt;li&gt;最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。&lt;/p&gt;
&lt;p&gt;当用户调用一个 Servlet 时，就会创建一个 Servlet 实例（注意，这个实例是单例的，所有的请求都是在这个里面处理，HttpServletRequest才是原型的，每次请求会新建一个实例），每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。&lt;/p&gt;
&lt;p&gt;架构图&lt;/p&gt;
&lt;p&gt;下图显示了一个典型的 Servlet 生命周期方案。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。&lt;/li&gt;
&lt;li&gt;Servlet 容器在调用 service() 方法之前加载 Servlet。&lt;/li&gt;
&lt;li&gt;然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Servlet 处理表单数据，这些数据会根据不同的情况使用不同的方法自动解析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getParameter()：您可以调用 request.getParameter() 方法来获取表单参数的值。&lt;/li&gt;
&lt;li&gt;getParameterValues()：如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框。&lt;/li&gt;
&lt;li&gt;getParameterNames()：如果您想要得到当前请求中的所有参数的完整列表，则调用该方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Servlet 简介&lt;/p&gt;
&lt;p&gt;Servlet 是什么？&lt;/p&gt;
&lt;p&gt;Java Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。&lt;/p&gt;
&lt;p&gt;使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。&lt;/p&gt;
&lt;p&gt;Java Servlet 通常情况下与使用 CGI（Common Gateway Interface，公共网关接口）实现的程序可以达到异曲同工的效果。但是相比于 CGI，Servlet 有以下几点优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;性能明显更好。&lt;/li&gt;
&lt;li&gt;Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。&lt;/li&gt;
&lt;li&gt;Servlet 是独立于平台的，因为它们是用 Java 编写的。&lt;/li&gt;
&lt;li&gt;服务器上的 Java 安全管理器执行了一系列限制，以保护服务器计算机上的资源。因此，Servlet 是可信的。&lt;/li&gt;
&lt;li&gt;Java 类库的全部功能对 Servlet 来说都是可用的。它可以通过 sockets 和 RMI 机制与 applets、数据库或其他软件进行交互。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Servlet 架构&lt;/p&gt;
&lt;p&gt;Servlet 包&lt;/p&gt;
&lt;p&gt;Java Servlet 是运行在带有支持 Java Servlet 规范的解释器的 web 服务器上的 Java 类。&lt;/p&gt;
&lt;p&gt;Servlet 可以使用 javax.servlet 和 javax.servlet.http 包创建，它是 Java 企业版的标准组成部分，Java 企业版是支持大型开发项目的 Java 类库的扩展版本。&lt;/p&gt;
&lt;p&gt;这些类实现 Java Servlet 和 JSP 规范。在写本教程的时候，二者相应的版本分别是 Java Servlet 2.5 和 JSP 2.1。&lt;/p&gt;
&lt;p&gt;Java Servlet 就像任何其他的 Java 类一样已经被创建和编译。在您安装 Servlet 包并把它们添加到您的计算机上的 Classpath 类路径中之后，您就可以通过 JDK 的 Java 编译器或任何其他编译器来编译 Servlet。&lt;/p&gt;
&lt;p&gt;Servlet 创建的三种方式。&lt;/p&gt;
&lt;p&gt;对于一个 Servlet 类，我们日常最常用的方法是继承自 HttpServlet 类，提供了 Http 相关的方法，HttpServlet 扩展了 GenericServlet 类，而 GenericServlet 类又实现了 Servlet 类和 ServletConfig 类。&lt;/p&gt;
&lt;p&gt;Servlet 类提供了五个方法，其中三个生命周期方法和两个普通方法 。 一个Servlet只会有一个对象，服务所有的请求（单例）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Servlet {
    void init(ServletConfig var1) throws ServletException;

    ServletConfig getServletConfig();

    void service(ServletRequest var1, ServletResponse var2) throws ServletException, IOException;

    String getServletInfo();

    void destroy();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;1、实现 Servlet 接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//Servlet的生命周期:从Servlet被创建到Servlet被销毁的过程
//一次创建，到处服务
//一个Servlet只会有一个对象，服务所有的请求
/*
 * 1.实例化（使用构造方法创建对象）
 * 2.初始化  执行init方法
 * 3.服务     执行service方法
 * 4.销毁    执行destroy方法
 */
public class ServletDemo1 implements Servlet {

    //public ServletDemo1(){}

     //生命周期方法:当Servlet第一次被创建对象时执行该方法,该方法在整个生命周期中只执行一次
    public void init(ServletConfig arg0) throws ServletException {
                System.out.println(&quot;=======init=========&quot;);
        }

    //生命周期方法:对客户端响应的方法,该方法会被执行多次，每次请求该servlet都会执行该方法
    public void service(ServletRequest arg0, ServletResponse arg1)
            throws ServletException, IOException {
        System.out.println(&quot;hehe&quot;);

    }

    //生命周期方法:当Servlet被销毁时执行该方法
    public void destroy() {
        System.out.println(&quot;******destroy**********&quot;);
    }
//当停止tomcat时也就销毁的servlet。
    public ServletConfig getServletConfig() {

        return null;
    }

    public String getServletInfo() {

        return null;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、继承 GenericServlet 类&lt;/p&gt;
&lt;p&gt;它实现了 Servlet 接口，重写 service 的方法，不过这种方法我们极少用。&lt;/p&gt;
&lt;p&gt;GenericServlet 是一个抽象类，实现了 Servlet 接口，并且对其中的 init() 和 destroy() 和 service() 提供了默认实现。在 GenericServlet 中，主要完成了以下任务：&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;将 init() 中的 ServletConfig 赋给一个类级变量，可以由 getServletConfig 获得；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;为 Servlet 所有方法提供默认实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;可以直接调用 ServletConfig 中的方法；&lt;/p&gt;
&lt;p&gt;abstract class GenericServlet implements Servlet,ServletConfig{&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; //GenericServlet通过将ServletConfig赋给类级变量
 private trServletConfig servletConfig;

 public void init(ServletConfig servletConfig) throws ServletException {

    this.servletConfig=servletConfig;

    /*自定义init()的原因是：如果子类要初始化必须覆盖父类的init() 而使它无效 这样
     this.servletConfig=servletConfig不起作用 这样就会导致空指针异常 这样如果子类要初始化，
     可以直接覆盖不带参数的init()方法 */
    this.init();
 }
 
 //自定义的init()方法，可以由子类覆盖  
 //init()不是生命周期方法
 public void init(){

 }

 //实现service()空方法，并且声明为抽象方法，强制子类必须实现service()方法 
 public abstract void service(ServletRequest request,ServletResponse response) 
   throws ServletException,java.io.IOException{
 }

 //实现空的destroy方法
 public void destroy(){ }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、继承 HttpServlet 方法&lt;/p&gt;
&lt;p&gt;HttpServlet 也是一个抽象类，它进一步继承并封装了 GenericServlet，使得使用更加简单方便，由于是扩展了 Http 的内容，所以还需要使用 HttpServletRequest 和 HttpServletResponse，这两个类分别是 ServletRequest 和 ServletResponse 的子类&lt;/p&gt;
&lt;p&gt;HttpServlet 中对原始的 Servlet 中的方法都进行了默认的操作，不需要显式的销毁初始化以及 service()，在 HttpServlet 中，自定义了一个新的 service() 方法，其中通过 getMethod() 方法判断请求的类型，从而调用 doGet() 或者 doPost() 处理 get,post 请求，使用者只需要继承 HttpServlet，然后重写 doPost() 或者 doGet() 方法处理请求即可。&lt;/p&gt;
&lt;p&gt;我们一般都使用继承 HttpServlet 的方式来定义一个 servlet。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;service() 是线程安全的。&lt;/p&gt;
&lt;p&gt;Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法 。这种多线程是线程安全的，因为我们的service(HttpServletRequest req, HttpServletResponse resp)方法传入的参数&lt;/p&gt;
&lt;p&gt;HttpServletRequest req, HttpServletResponse resp都是自己的，虽然只有一个实例，但service方法里面没有调用到类成员变量等共享资源，就不会有线程安全的问题；而在service方法里，虽然只有一个实例，我们假设两个请求同时到该方法中，也是没有问题的，因为局部变量是线程安全的，每个请求调用service方法都会开辟一个栈空间存储局部变量，是不会串位的，这是由于方法直接是线程隔离的，不要担心同时请求导致变量串了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
    String method = req.getMethod();
    long lastModified;
    if (method.equals(&quot;GET&quot;)) {
        lastModified = this.getLastModified(req);
        if (lastModified == -1L) {
            this.doGet(req, resp);
        } else {
            long ifModifiedSince = req.getDateHeader(&quot;If-Modified-Since&quot;);
            if (ifModifiedSince &amp;lt; lastModified) {
                this.maybeSetLastModified(resp, lastModified);
                this.doGet(req, resp);
            } else {
                resp.setStatus(304);
            }
        }
    } else if (method.equals(&quot;HEAD&quot;)) {
        lastModified = this.getLastModified(req);
        this.maybeSetLastModified(resp, lastModified);
        this.doHead(req, resp);
    } else if (method.equals(&quot;POST&quot;)) {
        this.doPost(req, resp);
    } else if (method.equals(&quot;PUT&quot;)) {
        this.doPut(req, resp);
    } else if (method.equals(&quot;DELETE&quot;)) {
        this.doDelete(req, resp);
    } else if (method.equals(&quot;OPTIONS&quot;)) {
        this.doOptions(req, resp);
    } else if (method.equals(&quot;TRACE&quot;)) {
        this.doTrace(req, resp);
    } else {
        String errMsg = lStrings.getString(&quot;http.method_not_implemented&quot;);
        Object[] errArgs = new Object[]{method};
        errMsg = MessageFormat.format(errMsg, errArgs);
        resp.sendError(501, errMsg);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Servlet 生命周期&lt;/p&gt;
&lt;p&gt;Servlet 生命周期可被定义为从创建直到毁灭的整个过程。以下是 Servlet 遵循的过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Servlet 通过调用 init () 方法进行初始化。&lt;/li&gt;
&lt;li&gt;Servlet 调用 service() 方法来处理客户端的请求。&lt;/li&gt;
&lt;li&gt;Servlet 通过调用 destroy() 方法终止（结束）。&lt;/li&gt;
&lt;li&gt;最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;init() 方法&lt;/p&gt;
&lt;p&gt;init 方法被设计成只调用一次。它在第一次创建 Servlet 时被调用，在后续每次用户请求时不再调用。&lt;/p&gt;
&lt;p&gt;Servlet 创建于用户第一次调用对应于该 Servlet 的 URL 时，但是您也可以指定 Servlet 在服务器第一次启动时被加载。&lt;/p&gt;
&lt;p&gt;当用户调用一个 Servlet 时，就会创建一个 Servlet 实例，每一个用户请求都会产生一个新的线程，适当的时候移交给 doGet 或 doPost 方法。init() 方法简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期。&lt;/p&gt;
&lt;p&gt;service() 方法&lt;/p&gt;
&lt;p&gt;service() 方法是执行实际任务的主要方法。Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应写回给客户端。&lt;/p&gt;
&lt;p&gt;每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet、doPost、doPut，doDelete 等方法。&lt;/p&gt;
&lt;p&gt;service() 方法由容器调用，service 方法在适当的时候调用 doGet、doPost、doPut、doDelete 等方法。所以，您不用对 service() 方法做任何动作，您只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。&lt;/p&gt;
&lt;p&gt;doGet() 方法&lt;/p&gt;
&lt;p&gt;GET 请求来自于一个 URL 的正常请求，或者来自于一个未指定 METHOD 的 HTML 表单，它由 doGet() 方法处理。&lt;/p&gt;
&lt;p&gt;doPost() 方法&lt;/p&gt;
&lt;p&gt;POST 请求来自于一个特别指定了 METHOD 为 POST 的 HTML 表单，它由 doPost() 方法处理。&lt;/p&gt;
&lt;p&gt;destroy() 方法&lt;/p&gt;
&lt;p&gt;destroy() 方法只会被调用一次，在 Servlet 生命周期结束时被调用。destroy() 方法可以让您的 Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动。&lt;/p&gt;
&lt;p&gt;Servlet生命周期架构图&lt;/p&gt;
&lt;p&gt;下图显示了一个典型的 Servlet 生命周期方案。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一个到达服务器的 HTTP 请求被委派到 Servlet 容器。&lt;/li&gt;
&lt;li&gt;Servlet 容器在调用 service() 方法之前加载 Servlet。&lt;/li&gt;
&lt;li&gt;然后 Servlet 容器处理由多个线程产生的多个请求，每个线程执行一个单一的 Servlet 实例的 service() 方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Servlet 实例&lt;/p&gt;
&lt;p&gt;Servlet 是服务 HTTP 请求并实现 javax.servlet.Servlet 接口的 Java 类。Web 应用程序开发人员通常编写 Servlet 来扩展 javax.servlet.http.HttpServlet，并实现 Servlet 接口的抽象类专门用来处理 HTTP 请求。&lt;/p&gt;
&lt;p&gt;报错：路径重名的话tomcat启动不了。&lt;/p&gt;
&lt;p&gt;servlet 浏览器访问路径配置有个小问题：&lt;/p&gt;
&lt;p&gt;1、java 类里的注解 —— @WebServlet(&quot;/HelloServlet&quot;) 对应浏览器路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:8080/TomcatTest/HelloServlet
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、配置文件（web.xml）里对应的浏览器访问路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:8080/TomcatTest/HelloServlet
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两种配一个就好了，不然路径重名的话反而会让tomcat启动不了。&lt;/p&gt;
&lt;p&gt;例如这样就启动不了：&lt;/p&gt;
&lt;p&gt;修改 web.xml :&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;url-pattern&amp;gt;/HelloServlet&amp;lt;/url-pattern&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改后，web.xml 和 java 类的注解，对应路径都是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://localhost:8080/TomcatTest/HelloServlet
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;导致&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;命名的 servlet[HelloServlet]和 [com.runoob.test.HelloServlet] 都被映射到 URL 模式 [/ HelloServlet] 这是不允许的。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;p&gt;将注解去掉或者保留注解进入web.xml将映射删除既可以。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//@WebServlet(&quot;/HelloWorld&quot;)
public class HelloWorld extends HttpServlet {

    private String message;

    @Override
    public void init() throws ServletException
    {
        // 执行必需的初始化
        message = &quot;Hello World&quot;;
    }
    @Override
    public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
            throws ServletException, IOException
    {
        // 设置响应内容类型
        response.setContentType(&quot;text/html&quot;);

        // 实际的逻辑是在这里
        PrintWriter out = response.getWriter();
        out.println(&quot;&amp;lt;h1&amp;gt;&quot; + message.toUpperCase() + &quot;&amp;lt;/h1&amp;gt;&quot;);
    }
    @Override
    public void destroy()
    {
        // 什么也不做
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;web.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;servlet&amp;gt;
  &amp;lt;servlet-name&amp;gt;HelloWorld&amp;lt;/servlet-name&amp;gt;
  &amp;lt;servlet-class&amp;gt;com.jsptest.HelloWorld&amp;lt;/servlet-class&amp;gt;
&amp;lt;/servlet&amp;gt;
&amp;lt;servlet-mapping&amp;gt;
  &amp;lt;servlet-name&amp;gt;HelloWorld&amp;lt;/servlet-name&amp;gt;
  &amp;lt;url-pattern&amp;gt;/HelloWorld&amp;lt;/url-pattern&amp;gt;
&amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Servlet 表单数据&lt;/p&gt;
&lt;p&gt;很多情况下，需要传递一些信息，从浏览器到 Web 服务器，最终到后台程序。浏览器使用两种方法可将这些信息传递到 Web 服务器，分别为 GET 方法和 POST 方法。&lt;/p&gt;
&lt;p&gt;GET 方法&lt;/p&gt;
&lt;p&gt;GET 方法向页面请求发送已编码的用户信息。页面和已编码的信息中间用 ? 字符分隔，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://www.test.com/hello?key1=value1&amp;amp;key2=value2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GET 方法是默认的从浏览器向 Web 服务器传递信息的方法，它会产生一个很长的字符串，出现在浏览器的地址栏中。如果您要向服务器传递的是密码或其他的敏感信息，请不要使用 GET 方法。GET 方法有大小限制：请求字符串中最多只能有 1024 个字符。&lt;/p&gt;
&lt;p&gt;这些信息使用 QUERY_STRING 头传递，并可以通过 QUERY_STRING 环境变量访问，Servlet 使用 doGet() 方法处理这种类型的请求。&lt;/p&gt;
&lt;p&gt;POST 方法&lt;/p&gt;
&lt;p&gt;另一个向后台程序传递信息的比较可靠的方法是 POST 方法。POST 方法打包信息的方式与 GET 方法基本相同，但是 POST 方法不是把信息作为 URL 中 ? 字符后的文本字符串进行发送，而是把这些信息作为一个单独的消息。消息以标准输出的形式传到后台程序，您可以解析和使用这些标准输出。Servlet 使用 doPost() 方法处理这种类型的请求。&lt;/p&gt;
&lt;p&gt;使用 Servlet 读取表单数据&lt;/p&gt;
&lt;p&gt;Servlet 处理表单数据，这些数据会根据不同的情况使用不同的方法自动解析：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getParameter()：您可以调用 request.getParameter() 方法来获取表单参数的值。&lt;/li&gt;
&lt;li&gt;getParameterValues()：如果参数出现一次以上，则调用该方法，并返回多个值，例如复选框。&lt;/li&gt;
&lt;li&gt;getParameterNames()：如果您想要得到当前请求中的所有参数的完整列表，则调用该方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;hellomybatis-servlet.xml 响应字符编码设置为utf-8&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 消息转换器代码,处理请求返回json字符串的中文乱码问题 --&amp;gt;
&amp;lt;mvc:annotation-driven&amp;gt;
    &amp;lt;mvc:message-converters&amp;gt;
        &amp;lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&amp;gt;
            &amp;lt;property name=&quot;supportedMediaTypes&quot;&amp;gt;
                &amp;lt;list&amp;gt;
                    &amp;lt;value&amp;gt;text/html;charset=UTF-8&amp;lt;/value&amp;gt;
                    &amp;lt;!--&amp;lt;value&amp;gt;application/json;charset=UTF-8&amp;lt;/value&amp;gt;--&amp;gt;
                &amp;lt;/list&amp;gt;
            &amp;lt;/property&amp;gt;
        &amp;lt;/bean&amp;gt;
    &amp;lt;/mvc:message-converters&amp;gt;
&amp;lt;/mvc:annotation-driven&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;web.xml 请求字符编码过滤为utf-8&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- 字符编码过滤器 --&amp;gt;
&amp;lt;filter&amp;gt;
  &amp;lt;filter-name&amp;gt;encodingFilter&amp;lt;/filter-name&amp;gt;
  &amp;lt;filter-class&amp;gt;org.springframework.web.filter.CharacterEncodingFilter&amp;lt;/filter-class&amp;gt;
  &amp;lt;init-param&amp;gt;
    &amp;lt;param-name&amp;gt;encoding&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;utf-8&amp;lt;/param-value&amp;gt;
  &amp;lt;/init-param&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
  &amp;lt;filter-name&amp;gt;encodingFilter&amp;lt;/filter-name&amp;gt;
  &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;

//加了@WebServlet 注解就不用在web.xml配置servlet
@WebServlet(&quot;/show&quot;)
public class ShowServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
      resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        PrintWriter writer = resp.getWriter();
        String title = &quot;GET 获取称号&quot;;
        //不需要转译编码的原因是
        //String name = new String(req.getParameter(&quot;name&quot;).getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;);
        //String titleName = new String(req.getParameter(&quot;title&quot;).getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;);
        String docType = &quot;&amp;lt;!DOCTYPE html&amp;gt; \n&quot;;
        writer.println(docType +
                &quot;&amp;lt;html&amp;gt;\n&quot; +
                &quot;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&quot; + title + &quot;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\n&quot; +
                &quot;&amp;lt;body bgcolor=\&quot;#f0f0f0\&quot;&amp;gt;\n&quot; +
                &quot;&amp;lt;h1 align=\&quot;center\&quot;&amp;gt;&quot; + title + &quot;&amp;lt;/h1&amp;gt;\n&quot; +
                &quot;&amp;lt;ul&amp;gt;\n&quot; +
                &quot;  &amp;lt;li&amp;gt;&amp;lt;b&amp;gt;人物&amp;lt;/b&amp;gt;：&quot;
                + req.getParameter(&quot;name&quot;) + &quot;\n&quot; +
                &quot;  &amp;lt;li&amp;gt;&amp;lt;b&amp;gt;称号&amp;lt;/b&amp;gt;：&quot;
                + req.getParameter(&quot;title&quot;) + &quot;\n&quot; +
                &quot;&amp;lt;/ul&amp;gt;\n&quot; +
                &quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req,resp);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;表单提交get示例：&lt;/p&gt;
&lt;p&gt;web.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  &amp;lt;servlet&amp;gt;
    &amp;lt;servlet-name&amp;gt;hellomybatis&amp;lt;/servlet-name&amp;gt;
    &amp;lt;servlet-class&amp;gt;org.springframework.web.servlet.DispatcherServlet&amp;lt;/servlet-class&amp;gt;
    &amp;lt;init-param&amp;gt;
      &amp;lt;param-name&amp;gt;contextConfigLocation&amp;lt;/param-name&amp;gt;
      &amp;lt;param-value&amp;gt;
        WEB-INF/hellomybatis-servlet.xml
      &amp;lt;/param-value&amp;gt;
    &amp;lt;/init-param&amp;gt;
    &amp;lt;load-on-startup&amp;gt;1&amp;lt;/load-on-startup&amp;gt;
  &amp;lt;/servlet&amp;gt;
  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;hellomybatis&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;/&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;
  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;default&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;*.xml&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;
  &amp;lt;!--如果是*.html则不走代理，走默认请求到html文件上--&amp;gt;
  &amp;lt;servlet-mapping&amp;gt;
    &amp;lt;servlet-name&amp;gt;default&amp;lt;/servlet-name&amp;gt;
    &amp;lt;url-pattern&amp;gt;*.html&amp;lt;/url-pattern&amp;gt;
  &amp;lt;/servlet-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;show.html&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;佣兵天下&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;form action=&quot;/hellomybatis/show&quot; method=&quot;GET&quot;&amp;gt;
    人物：&amp;lt;input type=&quot;text&quot; name=&quot;name&quot;&amp;gt;
    &amp;lt;br /&amp;gt;
    称号：&amp;lt;input type=&quot;text&quot; name=&quot;title&quot; /&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ShowServlet 不变。&lt;/p&gt;
&lt;p&gt;使用表单的 POST 方法实例:&lt;/p&gt;
&lt;p&gt;只需要把请求改成post，后台对应重写doPost()方法即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &amp;lt;form action=&quot;/hellomybatis/show&quot; method=&quot;POST&quot;&amp;gt;
    人物：&amp;lt;input type=&quot;text&quot; name=&quot;name&quot;&amp;gt;
    &amp;lt;br /&amp;gt;
    称号：&amp;lt;input type=&quot;text&quot; name=&quot;title&quot; /&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Servlet 客户端 HTTP 请求&lt;/p&gt;
&lt;p&gt;当浏览器请求网页时，它会向 Web 服务器发送特定信息，这些信息不能被直接读取，因为这些信息是作为 HTTP 请求的头的一部分进行传输的。您可以查看 HTTP 协议 了解更多相关信息。&lt;/p&gt;
&lt;p&gt;以下是来自于浏览器端的重要头信息，您可以在 Web 编程中频繁使用：&lt;/p&gt;
&lt;p&gt;头信息 描述&lt;br/&gt;Accept 这个头信息指定浏览器或其他客户端可以处理的 MIME 类型。值 image/png 或 image/jpeg 是最常见的两种可能值。&lt;br/&gt;Accept-Charset 这个头信息指定浏览器可以用来显示信息的字符集。例如 ISO-8859-1。&lt;br/&gt;Accept-Encoding 这个头信息指定浏览器知道如何处理的编码类型。值 gzip 或 compress 是最常见的两种可能值。&lt;br/&gt;Accept-Language 这个头信息指定客户端的首选语言，在这种情况下，Servlet 会产生多种语言的结果。例如，en、en-us、ru 等。&lt;br/&gt;Authorization 这个头信息用于客户端在访问受密码保护的网页时识别自己的身份。&lt;br/&gt;Connection 这个头信息指示客户端是否可以处理持久 HTTP 连接。持久连接允许客户端或其他浏览器通过单个请求来检索多个文件。值 Keep-Alive 意味着使用了持续连接。&lt;br/&gt;Content-Length 这个头信息只适用于 POST 请求，并给出 POST 数据的大小（以字节为单位）。&lt;br/&gt;Cookie 这个头信息把之前发送到浏览器的 cookies 返回到服务器。&lt;br/&gt;Host 这个头信息指定原始的 URL 中的主机和端口。&lt;br/&gt;If-Modified-Since 这个头信息表示只有当页面在指定的日期后已更改时，客户端想要的页面。如果没有新的结果可以使用，服务器会发送一个 304 代码，表示 Not Modified 头信息。&lt;br/&gt;If-Unmodified-Since 这个头信息是 If-Modified-Since 的对立面，它指定只有当文档早于指定日期时，操作才会成功。&lt;br/&gt;Referer 这个头信息指示所指向的 Web 页的 URL。例如，如果您在网页 1，点击一个链接到网页 2，当浏览器请求网页 2 时，网页 1 的 URL 就会包含在 Referer 头信息中。&lt;br/&gt;User-Agent 这个头信息识别发出请求的浏览器或其他客户端，并可以向不同类型的浏览器返回不同的内容。&lt;/p&gt;
&lt;p&gt;读取 HTTP 头的方法&lt;/p&gt;
&lt;p&gt;下面的方法可用在 Servlet 程序中读取 HTTP 头。这些方法通过 HttpServletRequest 对象可用。&lt;/p&gt;
&lt;p&gt;序号 方法 &amp;amp; 描述&lt;br/&gt;1 Cookie[] getCookies() 返回一个数组，包含客户端发送该请求的所有的 Cookie 对象。&lt;br/&gt;2 Enumeration getAttributeNames() 返回一个枚举，包含提供给该请求可用的属性名称。&lt;br/&gt;3 Enumeration getHeaderNames() 返回一个枚举，包含在该请求中包含的所有的头名。&lt;br/&gt;4 Enumeration getParameterNames() 返回一个 String 对象的枚举，包含在该请求中包含的参数的名称。&lt;br/&gt;5 HttpSession getSession() 返回与该请求关联的当前 session 会话，或者如果请求没有 session 会话，则创建一个。&lt;br/&gt;6 HttpSession getSession(boolean create) 返回与该请求关联的当前 HttpSession，或者如果没有当前会话，且创建是真的，则返回一个新的 session 会话。&lt;br/&gt;7 Locale getLocale() 基于 Accept-Language 头，返回客户端接受内容的首选的区域设置。&lt;br/&gt;8 Object getAttribute(String name) 以对象形式返回已命名属性的值，如果没有给定名称的属性存在，则返回 null。&lt;br/&gt;9 ServletInputStream getInputStream() 使用 ServletInputStream，以二进制数据形式检索请求的主体。&lt;br/&gt;10 String getAuthType() 返回用于保护 Servlet 的身份验证方案的名称，例如，&quot;BASIC&quot; 或 &quot;SSL&quot;，如果JSP没有受到保护则返回 null。&lt;br/&gt;11 String getCharacterEncoding() 返回请求主体中使用的字符编码的名称。&lt;br/&gt;12 String getContentType() 返回请求主体的 MIME 类型，如果不知道类型则返回 null。&lt;br/&gt;13 String getContextPath() 返回指示请求上下文的请求 URI 部分。&lt;br/&gt;14 String getHeader(String name) 以字符串形式返回指定的请求头的值。&lt;br/&gt;15 String getMethod() 返回请求的 HTTP 方法的名称，例如，GET、POST 或 PUT。&lt;br/&gt;16 String getParameter(String name) 以字符串形式返回请求参数的值，或者如果参数不存在则返回 null。&lt;br/&gt;17 String getPathInfo() 当请求发出时，返回与客户端发送的 URL 相关的任何额外的路径信息。&lt;br/&gt;18 String getProtocol() 返回请求协议的名称和版本。&lt;br/&gt;19 String getQueryString() 返回包含在路径后的请求 URL 中的查询字符串。&lt;br/&gt;20 String getRemoteAddr() 返回发送请求的客户端的互联网协议（IP）地址。&lt;br/&gt;21 String getRemoteHost() 返回发送请求的客户端的完全限定名称。&lt;br/&gt;22 String getRemoteUser() 如果用户已通过身份验证，则返回发出请求的登录用户，或者如果用户未通过身份验证，则返回 null。&lt;br/&gt;23 String getRequestURI() 从协议名称直到 HTTP 请求的第一行的查询字符串中，返回该请求的 URL 的一部分。&lt;br/&gt;24 String getRequestedSessionId() 返回由客户端指定的 session 会话 ID。&lt;br/&gt;25 String getServletPath() 返回调用 JSP 的请求的 URL 的一部分。&lt;br/&gt;26 String[] getParameterValues(String name) 返回一个字符串对象的数组，包含所有给定的请求参数的值，如果参数不存在则返回 null。&lt;br/&gt;27 boolean isSecure() 返回一个布尔值，指示请求是否使用安全通道，如 HTTPS。&lt;br/&gt;28 int getContentLength() 以字节为单位返回请求主体的长度，并提供输入流，或者如果长度未知则返回 -1。&lt;br/&gt;29 int getIntHeader(String name) 返回指定的请求头的值为一个 int 值。&lt;br/&gt;30 int getServerPort() 返回接收到这个请求的端口号。&lt;br/&gt;31 int getParameterMap() 将参数封装成 Map 类型。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/displayHeaderServlet&quot;)
public class DisplayHeaderServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;
    // 处理 GET 方法请求的方法
    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
    {
        // 设置响应内容类型
        //如果不设置会导致乱码
        //HTTP Header ???? - ??????
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);

        PrintWriter out = response.getWriter();
        String title = &quot;HTTP Header 请求响应头&quot;;
        String docType =
                &quot;&amp;lt;!DOCTYPE html&amp;gt; \n&quot;;
        out.println(docType +
                &quot;&amp;lt;html&amp;gt;\n&quot; +
                &quot;&amp;lt;head&amp;gt;&amp;lt;meta charset=\&quot;utf-8\&quot;&amp;gt;&amp;lt;title&amp;gt;&quot; + title + &quot;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\n&quot;+
                &quot;&amp;lt;body bgcolor=\&quot;#f0f0f0\&quot;&amp;gt;\n&quot; +
                &quot;&amp;lt;h1 align=\&quot;center\&quot;&amp;gt;&quot; + title + &quot;&amp;lt;/h1&amp;gt;\n&quot; +
                &quot;&amp;lt;table width=\&quot;100%\&quot; border=\&quot;1\&quot; align=\&quot;center\&quot;&amp;gt;\n&quot; +
                &quot;&amp;lt;tr bgcolor=\&quot;#949494\&quot;&amp;gt;\n&quot; +
                &quot;&amp;lt;th&amp;gt;Header 名称&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Header 值&amp;lt;/th&amp;gt;\n&quot;+
                &quot;&amp;lt;/tr&amp;gt;\n&quot;);

        Enumeration headerNames = request.getHeaderNames();

        while(headerNames.hasMoreElements()) {
            String paramName = (String)headerNames.nextElement();
            out.print(&quot;&amp;lt;tr&amp;gt;&amp;lt;td&amp;gt;&quot; + paramName + &quot;&amp;lt;/td&amp;gt;\n&quot;);
            String paramValue = request.getHeader(paramName);
            out.println(&quot;&amp;lt;td&amp;gt; &quot; + paramValue + &quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;\n&quot;);
        }
        out.println(&quot;&amp;lt;/table&amp;gt;\n&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;);
    }
    // 处理 POST 方法请求的方法
    @Override
    public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;报错：&lt;/p&gt;
&lt;p&gt;1、Class com.jsptest.DisplayHeaderServlet is not a Servlet&lt;/p&gt;
&lt;p&gt;这是因为我们在给DisplayHeaderServlet加上@WebServlet时却没有继承HttpServlet，导致系统初始化Servlet时因为DisplayHeaderServlet没有初始化init()和destroy()等默认方法无法初始化而报错。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;javax.servlet.ServletException: Class com.jsptest.DisplayHeaderServlet is not a Servlet
org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:522)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、Failed to start component&lt;/p&gt;
&lt;p&gt;这是因为@WebServlet(&quot;displayHeaderServlet&quot;)注解没有加/ 斜杠导致的servlet不能加载。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Caused by: java.lang.IllegalStateException: ContainerBase.addChild: start: org.apache.catalina.LifecycleException: Failed to start component [StandardEngine[Catalina].StandardHost[localhost].StandardContext[/hellomybatis]]
        at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:730)

@WebServlet(&quot;displayHeaderServlet&quot;)
public class DisplayHeaderServlet extends HttpServlet {
    /......
}

//正确写法
@WebServlet(&quot;/displayHeaderServlet&quot;)
public class DisplayHeaderServlet extends HttpServlet {
    /......
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Servlet 服务器 HTTP 响应&lt;/p&gt;
&lt;p&gt;状态行包括 HTTP 版本（在本例中为 HTTP/1.1）、一个状态码（在本例中为 200）和一个对应于状态码的短消息（在本例中为 OK）。&lt;/p&gt;
&lt;p&gt;下表总结了从 Web 服务器端返回到浏览器的最有用的 HTTP 1.1 响应报头，您会在 Web 编程中频繁地使用它们：&lt;/p&gt;
&lt;p&gt;头信息 描述&lt;br/&gt;Allow 这个头信息指定服务器支持的请求方法（GET、POST 等）。&lt;br/&gt;Cache-Control 这个头信息指定响应文档在何种情况下可以安全地缓存。可能的值有：public、private 或 no-cache 等。Public 意味着文档是可缓存，Private 意味着文档是单个用户私用文档，且只能存储在私有（非共享）缓存中，no-cache 意味着文档不应被缓存。&lt;br/&gt;Connection 这个头信息指示浏览器是否使用持久 HTTP 连接。值 close 指示浏览器不使用持久 HTTP 连接，值 keep-alive 意味着使用持久连接。&lt;br/&gt;Content-Disposition 这个头信息可以让您请求浏览器要求用户以给定名称的文件把响应保存到磁盘。&lt;br/&gt;Content-Encoding 在传输过程中，这个头信息指定页面的编码方式。&lt;br/&gt;Content-Language 这个头信息表示文档编写所使用的语言。例如，en、en-us、ru 等。&lt;br/&gt;Content-Length 这个头信息指示响应中的字节数。只有当浏览器使用持久（keep-alive）HTTP 连接时才需要这些信息。&lt;br/&gt;Content-Type 这个头信息提供了响应文档的 MIME（Multipurpose Internet Mail Extension）类型。&lt;br/&gt;Expires 这个头信息指定内容过期的时间，在这之后内容不再被缓存。&lt;br/&gt;Last-Modified 这个头信息指示文档的最后修改时间。然后，客户端可以缓存文件，并在以后的请求中通过 If-Modified-Since 请求头信息提供一个日期。&lt;br/&gt;Location 这个头信息应被包含在所有的带有状态码的响应中。在 300s 内，这会通知浏览器文档的地址。浏览器会自动重新连接到这个位置，并获取新的文档。&lt;br/&gt;Refresh 这个头信息指定浏览器应该如何尽快请求更新的页面。您可以指定页面刷新的秒数。&lt;br/&gt;Retry-After 这个头信息可以与 503（Service Unavailable 服务不可用）响应配合使用，这会告诉客户端多久就可以重复它的请求。&lt;br/&gt;Set-Cookie 这个头信息指定一个与页面关联的 cookie。&lt;/p&gt;
&lt;p&gt;设置 HTTP 响应报头的方法&lt;/p&gt;
&lt;p&gt;下面的方法可用于在 Servlet 程序中设置 HTTP 响应报头。这些方法通过 HttpServletResponse 对象可用。&lt;/p&gt;
&lt;p&gt;序号 方法 &amp;amp; 描述&lt;br/&gt;1 String encodeRedirectURL(String url) 为 sendRedirect 方法中使用的指定的 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。&lt;br/&gt;2 String encodeURL(String url) 对包含 session 会话 ID 的指定 URL 进行编码，或者如果编码不是必需的，则返回 URL 未改变。&lt;br/&gt;3 boolean containsHeader(String name) 返回一个布尔值，指示是否已经设置已命名的响应报头。&lt;br/&gt;4 boolean isCommitted() 返回一个布尔值，指示响应是否已经提交。&lt;br/&gt;5 void addCookie(Cookie cookie) 把指定的 cookie 添加到响应。&lt;br/&gt;6 void addDateHeader(String name, long date) 添加一个带有给定的名称和日期值的响应报头。&lt;br/&gt;7 void addHeader(String name, String value) 添加一个带有给定的名称和值的响应报头。&lt;br/&gt;8 void addIntHeader(String name, int value) 添加一个带有给定的名称和整数值的响应报头。&lt;br/&gt;9 void flushBuffer() 强制任何在缓冲区中的内容被写入到客户端。&lt;br/&gt;10 void reset() 清除缓冲区中存在的任何数据，包括状态码和头。&lt;br/&gt;11 void resetBuffer() 清除响应中基础缓冲区的内容，不清除状态码和头。&lt;br/&gt;12 void sendError(int sc) 使用指定的状态码发送错误响应到客户端，并清除缓冲区。&lt;br/&gt;13 void sendError(int sc, String msg) 使用指定的状态发送错误响应到客户端。&lt;br/&gt;14 void sendRedirect(String location) 使用指定的重定向位置 URL 发送临时重定向响应到客户端。&lt;br/&gt;15 void setBufferSize(int size) 为响应主体设置首选的缓冲区大小。&lt;br/&gt;16 void setCharacterEncoding(String charset) 设置被发送到客户端的响应的字符编码（MIME 字符集）例如，UTF-8。&lt;br/&gt;17 void setContentLength(int len) 设置在 HTTP Servlet 响应中的内容主体的长度，该方法设置 HTTP Content-Length 头。&lt;br/&gt;18 void setContentType(String type) 如果响应还未被提交，设置被发送到客户端的响应的内容类型。&lt;br/&gt;19 void setDateHeader(String name, long date) 设置一个带有给定的名称和日期值的响应报头。&lt;br/&gt;20 void setHeader(String name, String value) 设置一个带有给定的名称和值的响应报头。&lt;br/&gt;21 void setIntHeader(String name, int value) 设置一个带有给定的名称和整数值的响应报头。&lt;br/&gt;22 void setLocale(Locale loc) 如果响应还未被提交，设置响应的区域。&lt;br/&gt;23 void setStatus(int sc) 为该响应设置状态码。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/refresh&quot;)
public class RefreshServlet extends HttpServlet {
    // 处理 GET 方法请求的方法
    @Override
    public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
            throws ServletException, IOException
    {
        // 设置刷新自动加载时间为 3秒
        response.setIntHeader(&quot;Refresh&quot;, 3);
        // 设置响应内容类型
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        Cookie cookie = new Cookie(&quot;winner&quot;,&quot;amy&quot;);
        response.addCookie(cookie);
        //使用默认时区和语言环境获得一个日历
        Calendar cale = Calendar.getInstance();
        //将Calendar类型转换成Date类型
        Date tasktime=cale.getTime();
        //设置日期输出的格式
        SimpleDateFormat df=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);
        //格式化输出
        String nowTime = df.format(tasktime);
        PrintWriter out = response.getWriter();
        String title = &quot;自动刷新 Header 页面&quot;;
        String docType =
                &quot;&amp;lt;!DOCTYPE html&amp;gt;\n&quot;;
        out.println(docType +
                &quot;&amp;lt;html&amp;gt;\n&quot; +
                &quot;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&quot; + title + &quot;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\n&quot;+
                &quot;&amp;lt;body bgcolor=\&quot;#f0f0f0\&quot;&amp;gt;\n&quot; +
                &quot;&amp;lt;h1 align=\&quot;center\&quot;&amp;gt;&quot; + title + &quot;&amp;lt;/h1&amp;gt;\n&quot; +
                &quot;&amp;lt;p&amp;gt;当前时间是：&quot; + nowTime + &quot;&amp;lt;/p&amp;gt;\n&quot;);
    }
    // 处理 POST 方法请求的方法
    @Override
    public void doPost(HttpServletRequest request,
                       HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;扩展：Cookie是跟着session会话走的，我们请求的链接如果加了Cookie，就是对整个会话加Cookie，后面的请求都会带上这个Cookie。查看Cookie的两种方式。一个从network，一个从application.&lt;/p&gt;
&lt;p&gt;Servlet HTTP 状态码&lt;/p&gt;
&lt;p&gt;状态行包括 HTTP 版本（在本例中为 HTTP/1.1）、一个状态码（在本例中为 200）和一个对应于状态码的短消息（在本例中为 OK）。&lt;/p&gt;
&lt;p&gt;以下是可能从 Web 服务器返回的 HTTP 状态码和相关的信息列表：&lt;/p&gt;
&lt;p&gt;代码 消息 描述&lt;br/&gt;100 Continue 只有请求的一部分已经被服务器接收，但只要它没有被拒绝，客户端应继续该请求。&lt;br/&gt;101 Switching Protocols 服务器切换协议。&lt;br/&gt;200 OK 请求成功。&lt;br/&gt;201 Created 该请求是完整的，并创建一个新的资源。&lt;br/&gt;202 Accepted 该请求被接受处理，但是该处理是不完整的。&lt;br/&gt;203 Non-authoritative Information&lt;br/&gt;204 No Content&lt;br/&gt;205 Reset Content&lt;br/&gt;206 Partial Content&lt;br/&gt;300 Multiple Choices 链接列表。用户可以选择一个链接，进入到该位置。最多五个地址。&lt;br/&gt;301 Moved Permanently 所请求的页面已经转移到一个新的 URL。&lt;br/&gt;302 Found 所请求的页面已经临时转移到一个新的 URL。&lt;br/&gt;303 See Other 所请求的页面可以在另一个不同的 URL 下被找到。&lt;br/&gt;304 Not Modified&lt;br/&gt;305 Use Proxy&lt;br/&gt;306 Unused 在以前的版本中使用该代码。现在已不再使用它，但代码仍被保留。&lt;br/&gt;307 Temporary Redirect 所请求的页面已经临时转移到一个新的 URL。&lt;br/&gt;400 Bad Request 服务器不理解请求。&lt;br/&gt;401 Unauthorized 所请求的页面需要用户名和密码。&lt;br/&gt;402 Payment Required 您还不能使用该代码。&lt;br/&gt;403 Forbidden 禁止访问所请求的页面。&lt;br/&gt;404 Not Found 服务器无法找到所请求的页面。.&lt;br/&gt;405 Method Not Allowed 在请求中指定的方法是不允许的。&lt;br/&gt;406 Not Acceptable 服务器只生成一个不被客户端接受的响应。&lt;br/&gt;407 Proxy Authentication Required 在请求送达之前，您必须使用代理服务器的验证。&lt;br/&gt;408 Request Timeout 请求需要的时间比服务器能够等待的时间长，超时。&lt;br/&gt;409 Conflict 请求因为冲突无法完成。&lt;br/&gt;410 Gone 所请求的页面不再可用。&lt;br/&gt;411 Length Required &quot;Content-Length&quot; 未定义。服务器无法处理客户端发送的不带 Content-Length 的请求信息。&lt;br/&gt;412 Precondition Failed 请求中给出的先决条件被服务器评估为 false。&lt;br/&gt;413 Request Entity Too Large 服务器不接受该请求，因为请求实体过大。&lt;br/&gt;414 Request-url Too Long 服务器不接受该请求，因为 URL 太长。当您转换一个 &quot;post&quot; 请求为一个带有长的查询信息的 &quot;get&quot; 请求时发生。&lt;br/&gt;415 Unsupported Media Type 服务器不接受该请求，因为媒体类型不被支持。&lt;br/&gt;417 Expectation Failed&lt;br/&gt;500 Internal Server Error 未完成的请求。服务器遇到了一个意外的情况。&lt;br/&gt;501 Not Implemented 未完成的请求。服务器不支持所需的功能。&lt;br/&gt;502 Bad Gateway 未完成的请求。服务器从上游服务器收到无效响应。&lt;br/&gt;503 Service Unavailable 未完成的请求。服务器暂时超载或死机。&lt;br/&gt;504 Gateway Timeout 网关超时。&lt;br/&gt;505 HTTP Version Not Supported 服务器不支持&quot;HTTP协议&quot;版本。&lt;/p&gt;
&lt;p&gt;设置 HTTP 状态代码的方法&lt;/p&gt;
&lt;p&gt;下面的方法可用于在 Servlet 程序中设置 HTTP 状态码。这些方法通过 HttpServletResponse 对象可用。&lt;/p&gt;
&lt;p&gt;序号 方法 &amp;amp; 描述&lt;br/&gt;1 public void setStatus ( int statusCode ) 该方法设置一个任意的状态码。setStatus 方法接受一个 int（状态码）作为参数。如果您的响应包含了一个特殊的状态码和文档，请确保在使用 PrintWriter 实际返回任何内容之前调用 setStatus。&lt;br/&gt;2 public void sendRedirect(String url) 该方法生成一个 302 响应，连同一个带有新文档 URL 的 Location 头。&lt;br/&gt;3 public void sendError(int code, String message) 该方法发送一个状态码（通常为 404），连同一个在 HTML 文档内部自动格式化并发送到客户端的短消息。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/error&quot;)
public class ErrorServlet extends HttpServlet {

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setStatus(403);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       doGet(req,resp);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;Servlet 编写过滤器&lt;/p&gt;
&lt;p&gt;Servlet 过滤器可以动态地拦截请求和响应，以变换或使用包含在请求或响应中的信息。&lt;/p&gt;
&lt;p&gt;filter对象只会创建一次，init方法也只会执行一次。&lt;/p&gt;
&lt;p&gt;可以将一个或多个 Servlet 过滤器附加到一个 Servlet 或一组 Servlet。Servlet 过滤器也可以附加到 JavaServer Pages (JSP) 文件和 HTML 页面。调用 Servlet 前调用所有附加的 Servlet 过滤器。&lt;/p&gt;
&lt;p&gt;Servlet 过滤器是可用于 Servlet 编程的 Java 类，可以实现以下目的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在客户端的请求访问后端资源之前，拦截这些请求。&lt;/li&gt;
&lt;li&gt;在服务器的响应发送回客户端之前，处理这些响应。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;根据规范建议的各种类型的过滤器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;身份验证过滤器（Authentication Filters）。&lt;/li&gt;
&lt;li&gt;数据压缩过滤器（Data compression Filters）。&lt;/li&gt;
&lt;li&gt;加密过滤器（Encryption Filters）。&lt;/li&gt;
&lt;li&gt;触发资源访问事件过滤器。&lt;/li&gt;
&lt;li&gt;图像转换过滤器（Image Conversion Filters）。&lt;/li&gt;
&lt;li&gt;日志记录和审核过滤器（Logging and Auditing Filters）。&lt;/li&gt;
&lt;li&gt;MIME-TYPE 链过滤器（MIME-TYPE Chain Filters）。&lt;/li&gt;
&lt;li&gt;标记化过滤器（Tokenizing Filters）。&lt;/li&gt;
&lt;li&gt;XSL/T 过滤器（XSL/T Filters），转换 XML 内容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;过滤器通过 Web 部署描述符（web.xml）中的 XML 标签来声明，然后映射到您的应用程序的部署描述符中的 Servlet 名称或 URL 模式。&lt;/p&gt;
&lt;p&gt;当 Web 容器启动 Web 应用程序时，它会为您在部署描述符中声明的每一个过滤器创建一个实例。&lt;/p&gt;
&lt;p&gt;Filter的执行顺序与在web.xml配置文件中的配置顺序一致，一般把Filter配置在所有的Servlet之前。&lt;/p&gt;
&lt;p&gt;Servlet 过滤器方法&lt;/p&gt;
&lt;p&gt;过滤器是一个实现了 javax.servlet.Filter 接口的 Java 类。javax.servlet.Filter 接口定义了三个方法：&lt;/p&gt;
&lt;p&gt;序号 方法 &amp;amp; 描述&lt;br/&gt;1 public void doFilter (ServletRequest, ServletResponse, FilterChain) 该方法完成实际的过滤操作，当客户端请求方法与过滤器设置匹配的URL时，Servlet容器将先调用过滤器的doFilter方法。FilterChain用户访问后续过滤器。&lt;br/&gt;2 public void init(FilterConfig filterConfig) web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。&lt;br/&gt;3 public void destroy() Servlet容器在销毁过滤器实例前调用该方法，在该方法中释放Servlet过滤器占用的资源。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class LogFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        String before = filterConfig.getInitParameter(&quot;before&quot;);
        // 输出初始化参数
        System.out.println(&quot;初始化前：&quot; + before);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println(&quot;过滤时执行参数输出：&quot;+ JSON.toJSONString(servletRequest.getParameterMap()));
        // 把请求传回过滤链
        filterChain.doFilter(servletRequest,servletResponse);
    }

    @Override
    public void destroy() {
        System.out.println(&quot;关闭 LogFilter&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;web.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;filter&amp;gt;
  &amp;lt;filter-name&amp;gt;LogFilter&amp;lt;/filter-name&amp;gt;
  &amp;lt;filter-class&amp;gt;com.filter.LogFilter&amp;lt;/filter-class&amp;gt;
  &amp;lt;init-param&amp;gt;
    &amp;lt;param-name&amp;gt;before&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;日志打印&amp;lt;/param-value&amp;gt;
  &amp;lt;/init-param&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
  &amp;lt;filter-name&amp;gt;LogFilter&amp;lt;/filter-name&amp;gt;
  &amp;lt;!--过滤器适用于所有的 Servlet，因为我们在配置中指定 /* ，url-pattern用于匹配我们想要过滤的请求路径--&amp;gt;
  &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求：&amp;lt;&lt;a href=&quot;http://localhost:8080/hellomybatis/show?name=amy&amp;amp;title=%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB&quot;&gt;http://localhost:8080/hellomybatis/show?name=amy&amp;amp;title=屠龙勇士&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;使用多个过滤器&lt;/p&gt;
&lt;p&gt;Web 应用程序可以根据特定的目的定义若干个不同的过滤器。假设您定义了两个过滤器 AuthenFilter 和 LogFilter。&lt;/p&gt;
&lt;p&gt;项目启动时会初始化filter过滤器，初始化是随机的，不一定以web.xml配置的一样。使用多个过滤器以在web.xml配置的先后顺序执行。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;web.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;filter&amp;gt;
  &amp;lt;filter-name&amp;gt;LogFilter&amp;lt;/filter-name&amp;gt;
  &amp;lt;filter-class&amp;gt;com.filter.LogFilter&amp;lt;/filter-class&amp;gt;
  &amp;lt;init-param&amp;gt;
    &amp;lt;param-name&amp;gt;before&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;日志打印&amp;lt;/param-value&amp;gt;
  &amp;lt;/init-param&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
  &amp;lt;filter-name&amp;gt;LogFilter&amp;lt;/filter-name&amp;gt;
  &amp;lt;!--过滤器适用于所有的 Servlet，因为我们在配置中指定 /* ，url-pattern用于匹配我们想要过滤的请求路径--&amp;gt;
  &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;

&amp;lt;filter&amp;gt;
  &amp;lt;filter-name&amp;gt;AuthenFilter&amp;lt;/filter-name&amp;gt;
  &amp;lt;filter-class&amp;gt;com.filter.AuthenFilter&amp;lt;/filter-class&amp;gt;
  &amp;lt;init-param&amp;gt;
    &amp;lt;param-name&amp;gt;authen&amp;lt;/param-name&amp;gt;
    &amp;lt;param-value&amp;gt;权限校验&amp;lt;/param-value&amp;gt;
  &amp;lt;/init-param&amp;gt;
&amp;lt;/filter&amp;gt;
  &amp;lt;filter-mapping&amp;gt;
    &amp;lt;filter-name&amp;gt;AuthenFilter&amp;lt;/filter-name&amp;gt;
    &amp;lt;!--过滤器适用于所有的 Servlet，因为我们在配置中指定 /* ，url-pattern用于匹配我们想要过滤的请求路径--&amp;gt;
    &amp;lt;!--&amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;--&amp;gt;
    &amp;lt;!--只适用于@WebServlet(&quot;/show&quot;)--&amp;gt;
    &amp;lt;url-pattern&amp;gt;/show&amp;lt;/url-pattern&amp;gt;
    &amp;lt;!--不能进入--&amp;gt;
    &amp;lt;!--&amp;lt;url-pattern&amp;gt;/showyyy&amp;lt;/url-pattern&amp;gt;--&amp;gt;
    &amp;lt;!--也可以用&amp;lt;servlet-name&amp;gt;指定过滤器所拦截的Servlet名称，不过该名字必须配置在web.xml中，不能用注解，否则不能识别--&amp;gt;
    &amp;lt;!--&amp;lt;servlet-name&amp;gt;&amp;lt;/servlet-name&amp;gt;--&amp;gt;
  &amp;lt;/filter-mapping&amp;gt;

public class AuthenFilter implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        String authen = filterConfig.getInitParameter(&quot;authen&quot;);
        // 输出初始化参数
        System.out.println(&quot;初始化前：&quot; + authen);
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        //获取请求信息(测试时可以通过get方式在URL中添加name)
        String name = servletRequest.getParameter(&quot;name&quot;);

        // 过滤器核心代码逻辑
        System.out.println(&quot;过滤器获取请求参数:&quot;+name);
        System.out.println(&quot;AuthenFilter 过滤&quot;);

        if(&quot;amy&quot;.equals(name)){
            // 把请求传回过滤链
            filterChain.doFilter(servletRequest, servletResponse);
        }else{
            //设置返回内容类型
            servletResponse.setContentType(&quot;text/html;charset=UTF-8&quot;);

            //在页面输出响应信息
            PrintWriter out = servletResponse.getWriter();
            out.print(&quot;&amp;lt;b&amp;gt;:&quot;+name+&quot;不正确，请求被拦截，不能访问web资源&amp;lt;/b&amp;gt;&quot;);
            System.out.println(&quot;name:&quot;+name+&quot;不正确，请求被拦截，不能访问web资源&quot;);
        }
    }

    @Override
    public void destroy() {
        System.out.println(&quot;关闭 LogFilter&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求：&amp;lt;&lt;a href=&quot;http://localhost:8080/hellomybatis/show?name=amy&amp;amp;title=%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB&quot;&gt;http://localhost:8080/hellomybatis/show?name=amy&amp;amp;title=屠龙勇士&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;请求：&amp;lt;&lt;a href=&quot;http://localhost:8080/hellomybatis/show?name=happ&amp;amp;title=%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB&quot;&gt;http://localhost:8080/hellomybatis/show?name=happ&amp;amp;title=屠龙勇士&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;初始化前：权限校验
初始化前：日志打印
过滤时执行参数输出：{&quot;name&quot;:[&quot;amy&quot;],&quot;title&quot;:[&quot;屠龙勇士&quot;]}
过滤器获取请求参数:amy
AuthenFilter 过滤
过滤时执行参数输出：{&quot;name&quot;:[&quot;happ&quot;],&quot;title&quot;:[&quot;屠龙勇士&quot;]}
过滤器获取请求参数:happ
AuthenFilter 过滤
name:happ不正确，请求被拦截，不能访问web资源
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过滤器的应用顺序&lt;/p&gt;
&lt;p&gt;web.xml 中的 filter-mapping 元素的顺序决定了 Web 容器应用过滤器到 Servlet 的顺序。若要反转过滤器的顺序，您只需要在 web.xml 文件中反转 filter-mapping 元素即可&lt;/p&gt;
&lt;p&gt;web.xml配置各节点说明&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;filter&amp;gt;指定一个过滤器。
&amp;lt;filter-name&amp;gt;用于为过滤器指定一个名字，该元素的内容不能为空。
&amp;lt;filter-class&amp;gt;元素用于指定过滤器的完整的限定类名。
&amp;lt;init-param&amp;gt;元素用于为过滤器指定初始化参数，它的子元素&amp;lt;param-name&amp;gt;指定参数的名字，&amp;lt;param-value&amp;gt;指定参数的值。
在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。
&amp;lt;filter-mapping&amp;gt;元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径
&amp;lt;filter-name&amp;gt;子元素用于设置filter的注册名称。该值必须是在&amp;lt;filter&amp;gt;元素中声明过的过滤器的名字
&amp;lt;url-pattern&amp;gt;设置 filter 所拦截的请求路径(过滤器关联的URL样式)
&amp;lt;servlet-name&amp;gt;指定过滤器所拦截的Servlet名称。
&amp;lt;dispatcher&amp;gt;指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个&amp;lt;dispatcher&amp;gt;子元素用来指定 Filter 对资源的多种调用方式进行拦截。
&amp;lt;dispatcher&amp;gt;子元素可以设置的值及其意义
REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。
INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。
FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。
ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Servlet 异常处理&lt;/p&gt;
&lt;p&gt;当一个 Servlet 抛出一个异常时，Web 容器在使用了 exception-type 元素的 web.xml 中搜索与抛出异常类型相匹配的配置。&lt;/p&gt;
&lt;p&gt;您必须在 web.xml 中使用 error-page 元素来指定对特定异常 或 HTTP 状态码 作出相应的 Servlet 调用。&lt;/p&gt;
&lt;p&gt;请求属性 - 错误/异常&lt;/p&gt;
&lt;p&gt;以下是错误处理的 Servlet 可以访问的请求属性列表，用来分析错误/异常的性质。&lt;/p&gt;
&lt;p&gt;序号 属性 &amp;amp; 描述&lt;br/&gt;1 javax.servlet.error.status_code 该属性给出状态码，状态码可被存储，并在存储为 java.lang.Integer 数据类型后可被分析。&lt;br/&gt;2 javax.servlet.error.exception_type 该属性给出异常类型的信息，异常类型可被存储，并在存储为 java.lang.Class 数据类型后可被分析。&lt;br/&gt;3 javax.servlet.error.message 该属性给出确切错误消息的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。&lt;br/&gt;4 javax.servlet.error.request_uri 该属性给出有关 URL 调用 Servlet 的信息，信息可被存储，并在存储为 java.lang.String 数据类型后可被分析。&lt;br/&gt;5 javax.servlet.error.exception 该属性给出异常产生的信息，信息可被存储，并在存储为 java.lang.Throwable 数据类型后可被分析。&lt;br/&gt;6 javax.servlet.error.servlet_name 该属性给出 Servlet 的名称，名称可被存储，并在存储为 java.lang.String 数据类型后可被分析。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;web.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- error-code 相关的错误页面 --&amp;gt;
&amp;lt;error-page&amp;gt;
  &amp;lt;error-code&amp;gt;404&amp;lt;/error-code&amp;gt;
  &amp;lt;location&amp;gt;/errorHandler&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;
&amp;lt;!-- exception-type 相关的错误页面 --&amp;gt;
&amp;lt;error-page&amp;gt;
  &amp;lt;!--&amp;lt;exception-type&amp;gt;javax.servlet.ServletException&amp;lt;/exception-type&amp;gt;--&amp;gt;
  &amp;lt;exception-type&amp;gt;java.lang.Throwable&amp;lt;/exception-type &amp;gt;
  &amp;lt;location&amp;gt;/errorHandler&amp;lt;/location&amp;gt;
&amp;lt;/error-page&amp;gt;


@WebServlet(&quot;/errorHandler&quot;)
public class ErrorHandlerServlet extends HttpServlet {

    // 处理 GET 方法请求的方法
    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
    {
        Throwable throwable = (Throwable)
                request.getAttribute(&quot;javax.servlet.error.exception&quot;);
        Integer statusCode = (Integer)
                request.getAttribute(&quot;javax.servlet.error.status_code&quot;);
        String servletName = (String)
                request.getAttribute(&quot;javax.servlet.error.servlet_name&quot;);
        if (servletName == null){
            servletName = &quot;Unknown&quot;;
        }
        String requestUri = (String)
                request.getAttribute(&quot;javax.servlet.error.request_uri&quot;);
        if (requestUri == null){
            requestUri = &quot;Unknown&quot;;
        }
        // 设置响应内容类型
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);

        PrintWriter out = response.getWriter();
        String title = &quot;异常页面 Error/Exception 信息&quot;;

        String docType = &quot;&amp;lt;!DOCTYPE html&amp;gt;\n&quot;;
        out.println(docType +
                &quot;&amp;lt;html&amp;gt;\n&quot; +
                &quot;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&quot; + title + &quot;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\n&quot; +
                &quot;&amp;lt;body bgcolor=\&quot;#f0f0f0\&quot;&amp;gt;\n&quot;);
        out.println(&quot;&amp;lt;h1&amp;gt;异常信息展示&amp;lt;/h1&amp;gt;&quot;);
        if (throwable == null &amp;amp;&amp;amp; statusCode == null){
            out.println(&quot;&amp;lt;h2&amp;gt;错误信息丢失&amp;lt;/h2&amp;gt;&quot;);
            out.println(&quot;请返回 &amp;lt;a href=\&quot;&quot; +
                    response.encodeURL(&quot;http://localhost:8080/&quot;) +
                    &quot;\&quot;&amp;gt;主页&amp;lt;/a&amp;gt;。&quot;);
        }else if (statusCode != null) {
            out.println(&quot;错误代码 : &quot; + statusCode);
        }else{
            out.println(&quot;&amp;lt;h2&amp;gt;错误信息&amp;lt;/h2&amp;gt;&quot;);
            out.println(&quot;Servlet Name : &quot; + servletName +
                    &quot;&amp;lt;/br&amp;gt;&amp;lt;/br&amp;gt;&quot;);
            out.println(&quot;异常类型 : &quot; +
                    throwable.getClass( ).getName( ) +
                    &quot;&amp;lt;/br&amp;gt;&amp;lt;/br&amp;gt;&quot;);
            out.println(&quot;请求 URI: &quot; + requestUri +
                    &quot;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt;&quot;);
            out.println(&quot;异常信息: &quot; +
                    throwable.getMessage( ));
        }
        out.println(&quot;&amp;lt;/body&amp;gt;&quot;);
        out.println(&quot;&amp;lt;/html&amp;gt;&quot;);
    }
    // 处理 POST 方法请求的方法
    @Override
    public void doPost(HttpServletRequest request,
                       HttpServletResponse response)
            throws ServletException, IOException {
        doGet(request, response);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;错误请求：&lt;a href=&quot;http://localhost:8080/hellomybatis/df&quot;&gt;http://localhost:8080/hellomybatis/df&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;Servlet Cookie 处理&lt;/p&gt;
&lt;p&gt;使用cookie的三个步骤：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;服务器脚本向浏览器发送一组 Cookie。例如：姓名、年龄或识别号码等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;浏览器将这些信息存储在本地计算机上，以备将来使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;当下一次浏览器向 Web 服务器发送任何请求时，浏览器会把这些 Cookie 信息发送到服务器，服务器将使用这些信息来识别用户。&lt;/p&gt;
&lt;p&gt;//Servlet Cookie 处理需要对中文进行编码与解码，方法如下：&lt;br/&gt;String str = java.net.URLEncoder.encode(&quot;中文&quot;，&quot;UTF-8&quot;); //编码&lt;br/&gt;String str = java.net.URLDecoder.decode(&quot;编码后的字符串&quot;,&quot;UTF-8&quot;); // 解码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Cookie 剖析&lt;/p&gt;
&lt;p&gt;Cookie 通常设置在 HTTP 头信息中.&lt;/p&gt;
&lt;p&gt;正如您所看到的，Set-Cookie 头包含了一个名称值对、一个 GMT 日期、一个路径和一个域。名称和值会被 URL 编码。expires 字段是一个指令，告诉浏览器在给定的时间和日期之后&quot;忘记&quot;该 Cookie。&lt;/p&gt;
&lt;p&gt;如果浏览器被配置为存储 Cookie，它将会保留此信息直到到期日期。如果用户的浏览器指向任何匹配该 Cookie 的路径和域的页面，它会重新发送 Cookie 到服务器。浏览器的头信息可能如下所示：&lt;/p&gt;
&lt;p&gt;Servlet Cookie 方法&lt;/p&gt;
&lt;p&gt;以下是在 Servlet 中操作 Cookie 时可使用的有用的方法列表。&lt;/p&gt;
&lt;p&gt;序号 方法 &amp;amp; 描述&lt;br/&gt;1 public void setDomain(String pattern) 该方法设置 cookie 适用的域，例如 runoob.com。&lt;br/&gt;2 public String getDomain() 该方法获取 cookie 适用的域，例如 runoob.com。&lt;br/&gt;3 public void setMaxAge(int expiry) 该方法设置 cookie 过期的时间（以秒为单位）。如果不这样设置，cookie 只会在当前 session 会话中持续有效。&lt;br/&gt;4 public int getMaxAge() 该方法返回 cookie 的最大生存周期（以秒为单位），默认情况下，-1 表示 cookie 将持续下去，直到浏览器关闭。&lt;br/&gt;5 public String getName() 该方法返回 cookie 的名称。名称在创建后不能改变。&lt;br/&gt;6 public void setValue(String newValue) 该方法设置与 cookie 关联的值。&lt;br/&gt;7 public String getValue() 该方法获取与 cookie 关联的值。&lt;br/&gt;8 public void setPath(String uri) 该方法设置 cookie 适用的路径。如果您不指定路径，与当前页面相同目录下的（包括子目录下的）所有 URL 都会返回 cookie。&lt;br/&gt;9 public String getPath() 该方法获取 cookie 适用的路径。&lt;br/&gt;10 public void setSecure(boolean flag) 该方法设置布尔值，表示 cookie 是否应该只在加密的（即 SSL）连接上发送。&lt;br/&gt;11 public void setComment(String purpose) 设置cookie的注释。该注释在浏览器向用户呈现 cookie 时非常有用。&lt;br/&gt;12 public String getComment() 获取 cookie 的注释，如果 cookie 没有注释则返回 null。&lt;/p&gt;
&lt;p&gt;通过 Servlet 设置 Cookie&lt;/p&gt;
&lt;p&gt;通过 Servlet 设置 Cookie 包括三个步骤：&lt;/p&gt;
&lt;p&gt;(1) 创建一个 Cookie 对象：您可以调用带有 cookie 名称和 cookie 值的 Cookie 构造函数，cookie 名称和 cookie 值都是字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Cookie cookie = new Cookie(&quot;key&quot;,&quot;value&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请记住，无论是名字还是值，都不应该包含空格或以下任何字符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[ ] ( ) = , &quot; / ? @ : ;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(2) 设置最大生存周期：您可以使用 setMaxAge 方法来指定 cookie 能够保持有效的时间（以秒为单位）。下面将设置一个最长有效期为 24 小时的 cookie。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cookie.setMaxAge(60*60*24); 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(3) 发送 Cookie 到 HTTP 响应头：您可以使用 response.addCookie 来添加 HTTP 响应头中的 Cookie，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;response.addCookie(cookie);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 Servlet 读取 Cookie&lt;/p&gt;
&lt;p&gt;要读取 Cookie，您需要通过调用 HttpServletRequest 的 getCookies( ) 方法创建一个 javax.servlet.http.Cookie 对象的数组。然后循环遍历数组，并使用 getName() 和 getValue() 方法来访问每个 cookie 和关联的值。&lt;/p&gt;
&lt;p&gt;通过 Servlet 删除 Cookie&lt;/p&gt;
&lt;p&gt;删除 Cookie 是非常简单的。如果您想删除一个 cookie，那么您只需要按照以下三个步骤进行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取一个现有的 cookie，并把它存储在 Cookie 对象中。&lt;/li&gt;
&lt;li&gt;使用 setMaxAge() 方法设置 cookie 的年龄为零，来删除现有的 cookie。&lt;/li&gt;
&lt;li&gt;把这个 cookie 添加到响应头。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;实例：&lt;/p&gt;
&lt;p&gt;添加cookie：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/show&quot;)
public class ShowServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        // 为名字和姓氏创建 Cookie
        Cookie name = new Cookie(&quot;name&quot;,
                URLEncoder.encode(req.getParameter(&quot;name&quot;), &quot;UTF-8&quot;)); // 中文转码
        Cookie title = new Cookie(&quot;title&quot;,
                req.getParameter(&quot;title&quot;));

        // 为两个 Cookie 设置过期日期为 24 小时后
        name.setMaxAge(60*60*24);
        title.setMaxAge(60*60*24);

        // 在响应头中添加两个 Cookie
        resp.addCookie( name );
        resp.addCookie( title );

        resp.setContentType(&quot;text/html;charset=utf-8&quot;);
        PrintWriter writer = resp.getWriter();
        String top = &quot;GET 获取称号&quot;;
        //不需要转译编码的原因是
        //String name = new String(req.getParameter(&quot;name&quot;).getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;);
        //String titleName = new String(req.getParameter(&quot;title&quot;).getBytes(&quot;ISO-8859-1&quot;), &quot;UTF-8&quot;);
        String docType = &quot;&amp;lt;!DOCTYPE html&amp;gt; \n&quot;;
        writer.println(docType +
                &quot;&amp;lt;html&amp;gt;\n&quot; +
                &quot;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&quot; + top + &quot;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\n&quot; +
                &quot;&amp;lt;body bgcolor=\&quot;#f0f0f0\&quot;&amp;gt;\n&quot; +
                &quot;&amp;lt;h1 align=\&quot;center\&quot;&amp;gt;&quot; + top + &quot;&amp;lt;/h1&amp;gt;\n&quot; +
                &quot;&amp;lt;ul&amp;gt;\n&quot; +
                &quot;  &amp;lt;li&amp;gt;&amp;lt;b&amp;gt;人物&amp;lt;/b&amp;gt;：&quot;
                + req.getParameter(&quot;name&quot;) + &quot;\n&quot; +
                &quot;  &amp;lt;li&amp;gt;&amp;lt;b&amp;gt;称号&amp;lt;/b&amp;gt;：&quot;
                + req.getParameter(&quot;title&quot;) + &quot;\n&quot; +
                &quot;&amp;lt;/ul&amp;gt;\n&quot; +
                &quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req,resp);
    }
}

@WebServlet(&quot;/readCookies&quot;)
public class ReadCookiesServlet extends HttpServlet {

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        Cookie cookie = null;
        Cookie[] cookies = null;
        // 获取与该域相关的 Cookie 的数组
        cookies = request.getCookies();

        // 设置响应内容类型
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);

        PrintWriter out = response.getWriter();
        String title = &quot;Get Cookie Example&quot;;
        String docType = &quot;&amp;lt;!DOCTYPE html&amp;gt;\n&quot;;
        out.println(docType +
                &quot;&amp;lt;html&amp;gt;\n&quot; +
                &quot;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&quot; + title + &quot;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\n&quot; +
                &quot;&amp;lt;body bgcolor=\&quot;#f0f0f0\&quot;&amp;gt;\n&quot;);
        if (cookies != null) {
            out.println(&quot;&amp;lt;h2&amp;gt;Cookie 名称和值&amp;lt;/h2&amp;gt;&quot;);
            for (int i = 0; i &amp;lt; cookies.length; i++) {
                cookie = cookies[i];
                if((cookie.getName( )).compareTo(&quot;name&quot;) == 0 ){
                    cookie.setMaxAge(0);
                    response.addCookie(cookie);
                    out.print(&quot;已删除的 cookie：&quot; +
                            cookie.getName( ) + &quot;&amp;lt;br/&amp;gt;&quot;);
                }
                out.print(&quot;名称：&quot; + cookie.getName() + &quot;，&quot;);
                out.print(&quot;值：&quot; + URLDecoder.decode(cookie.getValue(), &quot;utf-8&quot;) + &quot; &amp;lt;br/&amp;gt;&quot;);
            }
        } else {
            out.println(
                    &quot;&amp;lt;h2 class=\&quot;tutheader\&quot;&amp;gt;No Cookie founds&amp;lt;/h2&amp;gt;&quot;);
        }
        out.println(&quot;&amp;lt;/body&amp;gt;&quot;);
        out.println(&quot;&amp;lt;/html&amp;gt;&quot;);
    }


    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求：&lt;/p&gt;
&lt;p&gt;&amp;lt;&lt;a href=&quot;http://localhost:8080/hellomybatis/show?name=amy&amp;amp;title=%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB&quot;&gt;http://localhost:8080/hellomybatis/show?name=amy&amp;amp;title=屠龙勇士&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://localhost:8080/hellomybatis/readCookies&quot;&gt;http://localhost:8080/hellomybatis/readCookies&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;Servlet Session 跟踪&lt;/p&gt;
&lt;p&gt;HTTP 是一种&quot;无状态&quot;协议，这意味着每次客户端检索网页时，客户端打开一个单独的连接到 Web 服务器，服务器会自动不保留之前客户端请求的任何记录。&lt;/p&gt;
&lt;p&gt;但是仍然有以下4种方式来维持 Web 客户端和 Web 服务器之间的 session 会话：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Cookies&lt;/li&gt;
&lt;li&gt;隐藏的表单字段&lt;/li&gt;
&lt;li&gt;URL 重写&lt;/li&gt;
&lt;li&gt;HttpSession 对象&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Cookies&lt;/p&gt;
&lt;p&gt;一个 Web 服务器可以分配一个唯一的 session 会话 ID 作为每个 Web 客户端的 cookie，对于客户端的后续请求可以使用接收到的 cookie 来识别。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;这可能不是一个有效的方法，因为很多浏览器不支持 cookie，所以我们建议不要使用这种方式来维持 session 会话。&lt;/p&gt;
&lt;p&gt;隐藏的表单字段&lt;/p&gt;
&lt;p&gt;一个 Web 服务器可以发送一个隐藏的 HTML 表单字段，以及一个唯一的 session 会话 ID，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;input type=&quot;hidden&quot; name=&quot;sessionid&quot; value=&quot;12345&quot;&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该条目意味着，当表单被提交时，指定的名称和值会被自动包含在 GET 或 POST 数据中。每次当 Web 浏览器发送回请求时，session_id 值可以用于保持不同的 Web 浏览器的跟踪。&lt;/p&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;p&gt;这可能是一种保持 session 会话跟踪的有效方式，但是点击常规的超文本链接（&lt;a href...=&quot;&quot;&gt;）不会导致表单提交，因此隐藏的表单字段也不支持常规的 session 会话跟踪。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href...=&quot;&quot;&gt;URL 重写&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href...=&quot;&quot;&gt;您可以在每个 URL 末尾追加一些额外的数据来标识 session 会话，服务器会把该 session 会话标识符与已存储的有关 session 会话的数据相关联。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href...=&quot;&quot;&gt;例如，&lt;/a&gt;&lt;a href=&quot;http://w3cschool.cc/file.htm;sessionid=12345%EF%BC%8Csession&quot;&gt;http://w3cschool.cc/file.htm;sessionid=12345，session&lt;/a&gt; 会话标识符被附加为 sessionid=12345，标识符可被 Web 服务器访问以识别客户端。&lt;/p&gt;
&lt;p&gt;URL 重写是一种更好的维持 session 会话的方式，它在浏览器不支持 cookie 时能够很好地工作，但是它的缺点是会动态生成每个 URL 来为页面分配一个 session 会话 ID，即使是在很简单的静态 HTML 页面中也会如此。&lt;/p&gt;
&lt;p&gt;HttpSession 对象&lt;/p&gt;
&lt;p&gt;Servlet 还提供了 HttpSession 接口，该接口提供了一种跨多个页面请求或访问网站时识别用户以及存储有关用户信息的方式。&lt;/p&gt;
&lt;p&gt;Servlet 容器使用这个接口来创建一个 HTTP 客户端和 HTTP 服务器之间的 session 会话。会话持续一个指定的时间段，跨多个连接或页面请求。&lt;/p&gt;
&lt;p&gt;您会通过调用 HttpServletRequest 的公共方法 getSession() 来获取 HttpSession 对象，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;HttpSession session = request.getSession();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你需要在向客户端发送任何文档内容之前调用 request.getSession()。下面总结了 HttpSession 对象中可用的几个重要的方法：&lt;/p&gt;
&lt;p&gt;序号 方法 &amp;amp; 描述&lt;br/&gt;1 public Object getAttribute(String name) 该方法返回在该 session 会话中具有指定名称的对象，如果没有指定名称的对象，则返回 null。&lt;br/&gt;2 public Enumeration getAttributeNames() 该方法返回 String 对象的枚举，String 对象包含所有绑定到该 session 会话的对象的名称。&lt;br/&gt;3 public long getCreationTime() 该方法返回该 session 会话被创建的时间，自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。&lt;br/&gt;4 public String getId() 该方法返回一个包含分配给该 session 会话的唯一标识符的字符串。&lt;br/&gt;5 public long getLastAccessedTime() 该方法返回客户端最后一次发送与该 session 会话相关的请求的时间自格林尼治标准时间 1970 年 1 月 1 日午夜算起，以毫秒为单位。&lt;br/&gt;6 public int getMaxInactiveInterval() 该方法返回 Servlet 容器在客户端访问时保持 session 会话打开的最大时间间隔，以秒为单位。&lt;br/&gt;7 public void invalidate() 该方法指示该 session 会话无效，并解除绑定到它上面的任何对象。&lt;br/&gt;8 public boolean isNew() 如果客户端还不知道该 session 会话，或者如果客户选择不参入该 session 会话，则该方法返回 true。&lt;br/&gt;9 public void removeAttribute(String name) 该方法将从该 session 会话移除指定名称的对象。&lt;br/&gt;10 public void setAttribute(String name, Object value) 该方法使用指定的名称绑定一个对象到该 session 会话。&lt;br/&gt;11 public void setMaxInactiveInterval(int interval) 该方法在 Servlet 容器指示该 session 会话无效之前，指定客户端请求之间的时间，以秒为单位。&lt;/p&gt;
&lt;p&gt;删除 Session 会话数据&lt;/p&gt;
&lt;p&gt;当您完成了一个用户的 session 会话数据，您有以下几种选择：&lt;/p&gt;
&lt;ul readability=&quot;5.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;移除一个特定的属性：您可以调用 public void removeAttribute(String name) 方法来删除与特定的键相关联的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;删除整个 session 会话：您可以调用 public void invalidate() 方法来丢弃整个 session 会话。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;设置 session 会话过期时间：您可以调用 public void setMaxInactiveInterval(int interval) 方法来单独设置 session 会话超时。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;注销用户：如果使用的是支持 servlet 2.4 的服务器，您可以调用 logout 来注销 Web 服务器的客户端，并把属于所有用户的所有 session 会话设置为无效。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;web.xml 配置：如果您使用的是 Tomcat，除了上述方法，您还可以在 web.xml 文件中配置 session 会话超时，如下所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;session-config&amp;gt;
  &amp;lt;session-timeout&amp;gt;15&amp;lt;/session-timeout&amp;gt;
&amp;lt;/session-config&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面实例中的超时时间是以分钟为单位，将覆盖 Tomcat 中默认的 30 分钟超时时间。&lt;/p&gt;
&lt;p&gt;在一个 Servlet 中的 getMaxInactiveInterval() 方法会返回 session 会话的超时时间，以秒为单位。所以，如果在 web.xml 中配置 session 会话超时时间为 15 分钟，那么 getMaxInactiveInterval() 会返回 900。&lt;/p&gt;
&lt;p&gt;实例：需要用新的tomcat，否则计数没出来。老的tomcat session存储在redis中了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/sessionTrack&quot;)
public class SessionTrackServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    @Override
    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException
    {
        // 如果不存在 session 会话，则创建一个 session 对象
        HttpSession session = request.getSession(true);
        // 获取 session 创建时间
        Date createTime = new Date(session.getCreationTime());
        // 获取该网页的最后一次访问时间
        Date lastAccessTime = new Date(session.getLastAccessedTime());

        //设置日期输出的格式
        SimpleDateFormat df=new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);

        String title = &quot;Servlet Session 实例 - 菜鸟教程&quot;;
        Integer visitCount = new Integer(0);
        String visitCountKey = new String(&quot;visitCount&quot;);
        String userIDKey = new String(&quot;userID&quot;);
        String userID = new String(&quot;Runoob&quot;);
        if(session.getAttribute(visitCountKey) == null) {
            session.setAttribute(visitCountKey, new Integer(0));
        }


        // 检查网页上是否有新的访问者
        if (session.isNew()){
            title = &quot;Servlet Session 实例 - 菜鸟教程&quot;;
            session.setAttribute(userIDKey, userID);
        } else {
            visitCount = (Integer)session.getAttribute(visitCountKey);
            visitCount = visitCount + 1;
            userID = (String)session.getAttribute(userIDKey);
        }
        session.setAttribute(visitCountKey,  visitCount);

        // 设置响应内容类型
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();

        String docType = &quot;&amp;lt;!DOCTYPE html&amp;gt;\n&quot;;
        out.println(docType +
                &quot;&amp;lt;html&amp;gt;\n&quot; +
                &quot;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&quot; + title + &quot;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\n&quot; +
                &quot;&amp;lt;body bgcolor=\&quot;#f0f0f0\&quot;&amp;gt;\n&quot; +
                &quot;&amp;lt;h1 align=\&quot;center\&quot;&amp;gt;&quot; + title + &quot;&amp;lt;/h1&amp;gt;\n&quot; +
                &quot;&amp;lt;h2 align=\&quot;center\&quot;&amp;gt;Session 信息&amp;lt;/h2&amp;gt;\n&quot; +
                &quot;&amp;lt;table border=\&quot;1\&quot; align=\&quot;center\&quot;&amp;gt;\n&quot; +
                &quot;&amp;lt;tr bgcolor=\&quot;#949494\&quot;&amp;gt;\n&quot; +
                &quot;  &amp;lt;th&amp;gt;Session 信息&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;值&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;\n&quot; +
                &quot;&amp;lt;tr&amp;gt;\n&quot; +
                &quot;  &amp;lt;td&amp;gt;id&amp;lt;/td&amp;gt;\n&quot; +
                &quot;  &amp;lt;td&amp;gt;&quot; + session.getId() + &quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;\n&quot; +
                &quot;&amp;lt;tr&amp;gt;\n&quot; +
                &quot;  &amp;lt;td&amp;gt;创建时间&amp;lt;/td&amp;gt;\n&quot; +
                &quot;  &amp;lt;td&amp;gt;&quot; +  df.format(createTime) +
                &quot;  &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;\n&quot; +
                &quot;&amp;lt;tr&amp;gt;\n&quot; +
                &quot;  &amp;lt;td&amp;gt;最后访问时间&amp;lt;/td&amp;gt;\n&quot; +
                &quot;  &amp;lt;td&amp;gt;&quot; + df.format(lastAccessTime) +
                &quot;  &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;\n&quot; +
                &quot;&amp;lt;tr&amp;gt;\n&quot; +
                &quot;  &amp;lt;td&amp;gt;用户 ID&amp;lt;/td&amp;gt;\n&quot; +
                &quot;  &amp;lt;td&amp;gt;&quot; + userID +
                &quot;  &amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;\n&quot; +
                &quot;&amp;lt;tr&amp;gt;\n&quot; +
                &quot;  &amp;lt;td&amp;gt;访问统计：&amp;lt;/td&amp;gt;\n&quot; +
                &quot;  &amp;lt;td&amp;gt;&quot; + visitCount + &quot;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;\n&quot; +
                &quot;&amp;lt;/table&amp;gt;\n&quot; +
                &quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Servlet 数据库访问&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/databaseAccess&quot;)
public class DatabaseAccessServlet extends HttpServlet {

    private static final String USER_NAME = &quot;root&quot;;

    private static final String PASSWORD = &quot;123456&quot;;

    // JDBC 驱动名及数据库 URL
    private static final String JDBC_DRIVER = &quot;com.mysql.jdbc.Driver&quot;;
    private static final String DB_URL = &quot;jdbc:mysql://localhost:3306/hello_mybatis&quot;;


    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        Connection connection = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;
        // 设置响应内容类型
        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = resp.getWriter();
        String title = &quot;Servlet Mysql Test&quot;;
        String docType = &quot;&amp;lt;!DOCTYPE html&amp;gt;\n&quot;;
        out.println(docType +
                &quot;&amp;lt;html&amp;gt;\n&quot; +
                &quot;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&quot; + title + &quot;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\n&quot; +
                &quot;&amp;lt;body bgcolor=\&quot;#f0f0f0\&quot;&amp;gt;\n&quot; +
                &quot;&amp;lt;h1 align=\&quot;center\&quot;&amp;gt;&quot; + title + &quot;&amp;lt;/h1&amp;gt;\n&quot;);
        try {
            Class.forName(JDBC_DRIVER);
            connection = DriverManager.getConnection(DB_URL, USER_NAME, PASSWORD);
            pstmt = connection.prepareStatement(&quot;SELECT * FROM t_user WHERE 1=1 AND NAME = ? &quot;);
            if (StringUtils.isNoneEmpty(req.getParameter(&quot;name&quot;))){
                pstmt.setString(1, req.getParameter(&quot;name&quot;));
            }
            rs = pstmt.executeQuery();
            while (rs.next()) {
                int id = rs.getInt(&quot;id&quot;);
                String name = rs.getString(&quot;name&quot;);
                String dept = rs.getString(&quot;dept&quot;);
                String phone = rs.getString(&quot;phone&quot;);
                // 输出数据
                out.println(&quot;ID: &quot; + id);
                out.println(&quot;, 英雄: &quot; + name);
                out.println(&quot;, 所属帝国: &quot; + dept);
                out.println(&quot;, 联系方式: &quot; + phone);
                out.println(&quot;&amp;lt;br /&amp;gt;&quot;);
            }
            out.println(&quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;);

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            try {
                rs.close();
                pstmt.close();
                connection.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
       doGet(req, resp);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求：&lt;a href=&quot;http://localhost:8080/hellomybatis/databaseAccess?name=%E6%B1%A0%E5%AF%92%E6%9E%AB&quot;&gt;http://localhost:8080/hellomybatis/databaseAccess?name=池寒枫&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;Servlet 文件上传&lt;/p&gt;
&lt;p&gt;Servlet 可以与 HTML form 标签一起使用，来允许用户上传文件到服务器。上传的文件可以是文本文件或图像文件或任何文档。&lt;/p&gt;
&lt;p&gt;需要引入的 jar 文件：commons-fileupload-1.3.2、commons-io-2.5.jar。&lt;/p&gt;
&lt;p&gt;创建一个文件上传表单&lt;/p&gt;
&lt;p&gt;下面的 HTML 代码创建了一个文件上传表单。以下几点需要注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;表单 method 属性应该设置为 POST 方法，不能使用 GET 方法。&lt;/li&gt;
&lt;li&gt;表单 enctype 属性应该设置为 multipart/form-data.&lt;/li&gt;
&lt;li&gt;表单 action 属性应该设置为在后端服务器上处理文件上传的 Servlet 文件。下面的实例使用了 UploadServlet Servlet 来上传文件。&lt;/li&gt;
&lt;li&gt;上传单个文件，您应该使用单个带有属性 type=&quot;file&quot; 的 &amp;lt;input .../&amp;gt; 标签。为了允许多个文件上传，请包含多个 name 属性值不同的 input 标签。输入标签具有不同的名称属性的值。浏览器会为每个 input 标签关联一个浏览按钮。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;pom.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!--文件上传依赖，Servlet3.0 已经内置了文件上传这一特性，开发者不再需要将 Commons FileUpload 组件导入到工程中去。--&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;com.asiainfo.crm.apache&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;commons-fileupload&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;1.1&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
    &amp;lt;dependency&amp;gt;
      &amp;lt;groupId&amp;gt;commons-io&amp;lt;/groupId&amp;gt;
      &amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt;
      &amp;lt;version&amp;gt;2.6&amp;lt;/version&amp;gt;
    &amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;index.jsp&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
         pageEncoding=&quot;UTF-8&quot;%&amp;gt;
&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;文件上传实例&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;文件上传实例&amp;lt;/h1&amp;gt;
&amp;lt;form method=&quot;post&quot; action=&quot;/hellomybatis/uploadServlet&quot; enctype=&quot;multipart/form-data&quot;&amp;gt;
    选择一个文件:
    &amp;lt;input type=&quot;file&quot; name=&quot;uploadFile&quot; /&amp;gt;
    &amp;lt;br/&amp;gt;&amp;lt;br/&amp;gt;
    &amp;lt;input type=&quot;submit&quot; value=&quot;上传&quot; /&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;message.jsp&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;
         pageEncoding=&quot;UTF-8&quot;%&amp;gt;
&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;文件上传结果&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;center&amp;gt;
    &amp;lt;h2&amp;gt;${message}&amp;lt;/h2&amp;gt;
&amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;

@WebServlet(&quot;/uploadServlet&quot;)
public class UploadServlet extends HttpServlet {
    private static final long serialVersionUID = 1L;

    // 上传文件存储目录
    private static final String UPLOAD_DIRECTORY = &quot;upload&quot;;

    // 上传配置
    private static final int MEMORY_THRESHOLD   = 1024 * 1024 * 3;  // 3MB
    private static final int MAX_FILE_SIZE      = 1024 * 1024 * 40; // 40MB
    private static final int MAX_REQUEST_SIZE   = 1024 * 1024 * 50; // 50MB

    /**
     * 上传数据及保存文件
     */
    @Override
    protected void doPost(HttpServletRequest request,
                          HttpServletResponse response) throws ServletException, IOException {
        // 检测是否为多媒体上传
        if (!ServletFileUpload.isMultipartContent(request)) {
            // 如果不是则停止
            PrintWriter writer = response.getWriter();
            writer.println(&quot;Error: 表单必须包含 enctype=multipart/form-data&quot;);
            writer.flush();
            return;
        }

        // 配置上传参数
        DiskFileItemFactory factory = new DiskFileItemFactory();
        // 设置内存临界值 - 超过后将产生临时文件并存储于临时目录中
        factory.setSizeThreshold(MEMORY_THRESHOLD);
        // 设置临时存储目录
        factory.setRepository(new File(System.getProperty(&quot;java.io.tmpdir&quot;)));

        ServletFileUpload upload = new ServletFileUpload(factory);

        // 设置最大文件上传值
        //upload.setFileSizeMax(MAX_FILE_SIZE);

        // 设置最大请求值 (包含文件和表单数据)
        upload.setSizeMax(MAX_REQUEST_SIZE);

        // 中文处理
        upload.setHeaderEncoding(&quot;UTF-8&quot;);

        // 构造临时路径来存储上传的文件
        // 这个路径相对当前应用的目录
        String uploadPath = request.getServletContext().getRealPath(&quot;./&quot;) + File.separator + UPLOAD_DIRECTORY;


        // 如果目录不存在则创建
        File uploadDir = new File(uploadPath);
        if (!uploadDir.exists()) {
            uploadDir.mkdir();
        }

        try {
            // 解析请求的内容提取文件数据
            @SuppressWarnings(&quot;unchecked&quot;)
            List&amp;lt;FileItem&amp;gt; formItems = upload.parseRequest(request);

            if (formItems != null &amp;amp;&amp;amp; formItems.size() &amp;gt; 0) {
                // 迭代表单数据
                for (FileItem item : formItems) {
                    // 处理不在表单中的字段
                    if (!item.isFormField()) {
                        String fileName = new File(item.getName()).getName();
                        String filePath = uploadPath + File.separator + fileName;
                        File storeFile = new File(filePath);
                        // 在控制台输出文件的上传路径
                        System.out.println(filePath);
                        // 保存文件到硬盘
                        item.write(storeFile);
                        request.setAttribute(&quot;message&quot;,
                                &quot;文件上传成功!&quot;);
                    }
                }
            }
        } catch (Exception ex) {
            request.setAttribute(&quot;message&quot;,
                    &quot;错误信息: &quot; + ex.getMessage());
        }
        // 跳转到 message.jsp
        request.getServletContext().getRequestDispatcher(&quot;/message.jsp&quot;).forward(
                request, response);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;Servlet 处理日期&lt;/p&gt;
&lt;p&gt;使用 Servlet 的最重要的优势之一是，可以使用核心 Java 中的大多数可用的方法。本章将讲解 Java 提供的 java.util 包中的 Date 类，这个类封装了当前的日期和时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   //初始化当前日期和时间的对象。
   Date today = new Date();
   //接受一个参数获得时间对象，该参数等于 1970 年 1 月 1 日午夜以来经过的毫秒数。
   Date today1 = new Date(System.currentTimeMillis());
SimpleDateFormat ft = new SimpleDateFormat (&quot;yyyy.MM.dd  hh:mm:ss E a &quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用方法：&lt;/p&gt;
&lt;p&gt;序号 方法 &amp;amp; 描述&lt;br/&gt;1 boolean after(Date date) 如果调用的 Date 对象中包含的日期在 date 指定的日期之后，则返回 true，否则返回 false。&lt;br/&gt;2 boolean before(Date date) 如果调用的 Date 对象中包含的日期在 date 指定的日期之前，则返回 true，否则返回 false。&lt;br/&gt;3 Object clone( ) 重复调用 Date 对象。&lt;br/&gt;4 int compareTo(Date date) 把调用对象的值与 date 的值进行比较。如果两个值是相等的，则返回 0。如果调用对象在 date 之前，则返回一个负值。如果调用对象在 date 之后，则返回一个正值。&lt;br/&gt;5 int compareTo(Object obj) 如果 obj 是 Date 类，则操作等同于 compareTo(Date)。否则，它会抛出一个 ClassCastException。&lt;br/&gt;6 boolean equals(Object date) 如果调用的 Date 对象中包含的时间和日期与 date 指定的相同，则返回 true，否则返回 false。&lt;br/&gt;7 long getTime( ) 返回 1970 年 1 月 1 日以来经过的毫秒数。&lt;br/&gt;8 int hashCode( ) 为调用对象返回哈希代码。&lt;br/&gt;9 void setTime(long time) 设置 time 指定的时间和日期，这表示从 1970 年 1 月 1 日午夜以来经过的时间（以毫秒为单位）。&lt;br/&gt;10 String toString( ) 转换调用的 Date 对象为一个字符串，并返回结果。&lt;/p&gt;
&lt;p&gt;使用 SimpleDateFormat 格式化日期&lt;/p&gt;
&lt;p&gt;SimpleDateFormat 是一个以语言环境敏感的方式来格式化和解析日期的具体类。 SimpleDateFormat 允许您选择任何用户定义的日期时间格式化的模式。（非线程安全类）&lt;/p&gt;
&lt;p&gt;简单的日期格式的格式代码&lt;/p&gt;
&lt;p&gt;使用事件模式字符串来指定时间格式。在这种模式下，所有的 ASCII 字母被保留为模式字母，这些字母定义如下：&lt;/p&gt;
&lt;p&gt;字符 描述 实例&lt;br/&gt;G Era 指示器 AD&lt;br/&gt;y 四位数表示的年 2001&lt;br/&gt;M 一年中的月 July 或 07&lt;br/&gt;d 一月中的第几天 10&lt;br/&gt;h 带有 A.M./P.M. 的小时（1~12） 12&lt;br/&gt;H 一天中的第几小时（0~23） 22&lt;br/&gt;m 一小时中的第几分 30&lt;br/&gt;s 一分中的第几秒 55&lt;br/&gt;S 毫秒 234&lt;br/&gt;E 一周中的星期几 Tuesday&lt;br/&gt;D 一年中的第几天 360&lt;br/&gt;F 所在的周是这个月的第几周 2 (second Wed. in July)&lt;br/&gt;w 一年中的第几周 40&lt;br/&gt;W 一月中的第几周 1&lt;br/&gt;a A.M./P.M. 标记 PM&lt;br/&gt;k 一天中的第几小时（1~24） 24&lt;br/&gt;K 带有 A.M./P.M. 的小时（0~11） 10&lt;br/&gt;z 时区 Eastern Standard Time&lt;br/&gt;' Escape for text Delimiter&lt;br/&gt;&quot; 单引号 `&lt;/p&gt;
&lt;p&gt;Servlet 网页重定向&lt;/p&gt;
&lt;p&gt;当文档移动到新的位置，我们需要向客户端发送这个新位置时，我们需要用到网页重定向。当然，也可能是为了负载均衡，或者只是为了简单的随机，这些情况都有可能用到网页重定向。&lt;/p&gt;
&lt;p&gt;重定向请求到另一个网页的最简单的方式是使用 response 对象的 sendRedirect() 方法。也可以通过把 setStatus() 和 setHeader() 方法一起使用来达到同样的效果 。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/pageRedirect&quot;)
public class PageRedirectServlet extends HttpServlet {

    @Override
    public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
            throws ServletException, IOException
    {
        // 设置响应内容类型
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);

        // 要重定向的新位置
        //String site = new String(&quot;http://www.runoob.com&quot;);
         String site = &quot;http://www.runoob.com&quot;;
        //方式一：
        //302
        //response.setStatus(HttpServletResponse.SC_MOVED_TEMPORARILY);
        //response.setHeader(&quot;Location&quot;, site);
        //方式二：
        response.sendRedirect(site);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Servlet 点击计数器&lt;/p&gt;
&lt;p&gt;网页点击计数器&lt;/p&gt;
&lt;p&gt;很多时候，您可能有兴趣知道网站的某个特定页面上的总点击量。使用 Servlet 来计算这些点击量是非常简单的，因为一个 Servlet 的生命周期是由它运行所在的容器控制的。&lt;/p&gt;
&lt;p&gt;以下是实现一个简单的基于 Servlet 生命周期的网页点击计数器需要采取的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 init() 方法中初始化一个全局变量。&lt;/li&gt;
&lt;li&gt;每次调用 doGet() 或 doPost() 方法时，都增加全局变量。&lt;/li&gt;
&lt;li&gt;如果需要，您可以使用一个数据库表来存储全局变量的值在 destroy() 中。在下次初始化 Servlet 时，该值可在 init() 方法内被读取。这一步是可选的。&lt;/li&gt;
&lt;li&gt;如果您只想对一个 session 会话计数一次页面点击，那么请使用 isNew() 方法来检查该 session 会话是否已点击过相同页面。这一步是可选的。&lt;/li&gt;
&lt;li&gt;您可以通过显示全局计数器的值，来在网站上展示页面的总点击量。这一步是可选的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在这里，我们假设 Web 容器将无法重新启动。如果是重新启动或 Servlet 被销毁，计数器将被重置。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/pageHit&quot;)
public class PageHitServlet extends HttpServlet {

    private int hitCount;

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);
        // 增加 hitCount
        hitCount++;
        PrintWriter out = resp.getWriter();
        String title = &quot;总点击量&quot;;
        String docType = &quot;&amp;lt;!DOCTYPE html&amp;gt; \n&quot;;
        out.println(docType +
                &quot;&amp;lt;html&amp;gt;\n&quot; +
                &quot;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&quot; + title + &quot;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\n&quot; +
                &quot;&amp;lt;body bgcolor=\&quot;#f0f0f0\&quot;&amp;gt;\n&quot; +
                &quot;&amp;lt;h1 align=\&quot;center\&quot;&amp;gt;&quot; + title + &quot;&amp;lt;/h1&amp;gt;\n&quot; +
                &quot;&amp;lt;h2 align=\&quot;center\&quot;&amp;gt;&quot; + hitCount + &quot;&amp;lt;/h2&amp;gt;\n&quot; +
                &quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;);
    }

    @Override
    protected void doPut(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doGet(req,resp);
    }

    @Override
    public void init() throws ServletException {
        //初始化
        hitCount = 0;
    }

    @Override
    public void destroy() {
        //可以把 hitCount 的值写入到数据库
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求：&lt;a href=&quot;http://localhost:8080/hellomybatis/pageHit&quot;&gt;http://localhost:8080/hellomybatis/pageHit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;网站点击计数器&lt;/p&gt;
&lt;p&gt;很多时候，您可能有兴趣知道整个网站的总点击量。在 Servlet 中，这也是非常简单的，我们可以使用过滤器做到这一点。&lt;/p&gt;
&lt;p&gt;以下是实现一个简单的基于过滤器生命周期的网站点击计数器需要采取的步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在过滤器的 init() 方法中初始化一个全局变量。&lt;/li&gt;
&lt;li&gt;每次调用 doFilter 方法时，都增加全局变量。&lt;/li&gt;
&lt;li&gt;如果需要，您可以在过滤器的 destroy() 中使用一个数据库表来存储全局变量的值。在下次初始化过滤器时，该值可在 init() 方法内被读取, 这一步是可选的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;web.xml&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;filter&amp;gt;
  &amp;lt;filter-name&amp;gt;SiteHitCountFilter&amp;lt;/filter-name&amp;gt;
  &amp;lt;filter-class&amp;gt;com.filter.SiteHitCountFilter&amp;lt;/filter-class&amp;gt;
&amp;lt;/filter&amp;gt;
&amp;lt;filter-mapping&amp;gt;
  &amp;lt;filter-name&amp;gt;SiteHitCountFilter&amp;lt;/filter-name&amp;gt;
  &amp;lt;url-pattern&amp;gt;/*&amp;lt;/url-pattern&amp;gt;
&amp;lt;/filter-mapping&amp;gt;

public class SiteHitCountFilter implements Filter {

    private int hitCount;

    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        //初始化
        hitCount = 0;
    }

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        // 把计数器的值增加 1
        hitCount++;

        // 输出计数器
        System.out.println(&quot;网站访问统计：&quot;+ hitCount );

        // 把请求传回到过滤器链
        filterChain.doFilter(servletRequest,servletResponse);
    }

    @Override
    public void destroy() {
        //可以把 hitCount 的值写入到数据库
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;网站访问统计：8
网站访问统计：9
网站访问统计：10
网站访问统计：11
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Servlet 发送电子邮件&lt;/p&gt;
&lt;p&gt;//待实践&lt;/p&gt;
&lt;p&gt;Servlet 国际化&lt;/p&gt;
&lt;p&gt;三个重要术语：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;国际化（i18n）：这意味着一个网站提供了不同版本的翻译成访问者的语言或国籍的内容。&lt;/li&gt;
&lt;li&gt;本地化（l10n）：这意味着向网站添加资源，以使其适应特定的地理或文化区域，例如网站翻译成印地文（Hindi）。&lt;/li&gt;
&lt;li&gt;区域设置（locale）：这是一个特殊的文化或地理区域。它通常指语言符号后跟一个下划线和一个国家符号。例如 &quot;en_US&quot; 表示针对 US 的英语区域设置。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Servlet 可以根据请求者的区域设置拾取相应版本的网站，并根据当地的语言、文化和需求提供相应的网站版本。以下是 request 对象中返回 Locale 对象的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;java.util.Locale request.getLocale()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检测区域设置&lt;/p&gt;
&lt;p&gt;下面列出了重要的区域设置方法，您可以使用它们来检测请求者的地理位置、语言和区域设置。下面所有的方法都显示了请求者浏览器中设置的国家名称和语言名称。&lt;/p&gt;
&lt;p&gt;序号 方法 &amp;amp; 描述&lt;br/&gt;1 String getCountry() 该方法以 2 个大写字母形式的 ISO 3166 格式返回该区域设置的国家/地区代码。&lt;br/&gt;2 String getDisplayCountry() 该方法返回适合向用户显示的区域设置的国家的名称。&lt;br/&gt;3 String getLanguage() 该方法以小写字母形式的 ISO 639 格式返回该区域设置的语言代码。&lt;br/&gt;4 String getDisplayLanguage() 该方法返回适合向用户显示的区域设置的语言的名称。&lt;br/&gt;5 String getISO3Country() 该方法返回该区域设置的国家的三个字母缩写。&lt;br/&gt;6 String getISO3Language() 该方法返回该区域设置的语言的三个字母的缩写。&lt;/p&gt;
&lt;p&gt;示例显示某个请求的语言和相关的国家 ：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@WebServlet(&quot;/locale&quot;)
public class GetLocaleServlet extends HttpServlet {

    @Override
    public void doGet(HttpServletRequest request,
                      HttpServletResponse response)
            throws ServletException, IOException
    {
        // 获取客户端的区域设置
        Locale locale = request.getLocale();
        String language = locale.getLanguage();
        String country = locale.getCountry();

        // 设置响应内容类型
        response.setContentType(&quot;text/html;charset=UTF-8&quot;);
        PrintWriter out = response.getWriter();

        String title = &quot;检测区域设置&quot;;
        String docType = &quot;&amp;lt;!DOCTYPE html&amp;gt; \n&quot;;
        out.println(docType +
                &quot;&amp;lt;html&amp;gt;\n&quot; +
                &quot;&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;&quot; + title + &quot;&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;\n&quot; +
                &quot;&amp;lt;body bgcolor=\&quot;#f0f0f0\&quot;&amp;gt;\n&quot; +
                &quot;&amp;lt;h1 align=\&quot;center\&quot;&amp;gt;&quot; + language + &quot;&amp;lt;/h1&amp;gt;\n&quot; +
                &quot;&amp;lt;h2 align=\&quot;center\&quot;&amp;gt;&quot; + country + &quot;&amp;lt;/h2&amp;gt;\n&quot; +
                &quot;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;语言设置&lt;/p&gt;
&lt;p&gt;Servlet 可以输出以西欧语言（如英语、西班牙语、德语、法语、意大利语、荷兰语等）编写的页面。在这里，为了能正确显示所有的字符，设置 Content-Language 头是非常重要的。&lt;/p&gt;
&lt;p&gt;第二点是使用 HTML 实体显示所有的特殊字符，例如，&quot;ñ&quot; 表示 &quot;ñ&quot;，&quot;¡&quot; 表示 &quot;¡&quot;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; // 设置响应内容类型
    response.setContentType(&quot;text/html;charset=UTF-8&quot;);
    PrintWriter out = response.getWriter();
    // 设置西班牙语言代码
    response.setHeader(&quot;Content-Language&quot;, &quot;es&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特定于区域设置的日期&lt;/p&gt;
&lt;p&gt;您可以使用 java.text.DateFormat 类及其静态方法 getDateTimeInstance() 来格式化特定于区域设置的日期和时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; // 设置响应内容类型
    response.setContentType(&quot;text/html;charset=UTF-8&quot;);
    PrintWriter out = response.getWriter();
    // 获取客户端的区域设置
    Locale locale = request.getLocale( );
    String date = DateFormat.getDateTimeInstance(
                                  DateFormat.FULL, 
                                  DateFormat.SHORT, 
                                  locale).format(new Date( ));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特定于区域设置的货币&lt;/p&gt;
&lt;p&gt;您可以使用 java.text.NumberFormat 类及其静态方法 getCurrencyInstance() 来格式化数字（比如 long 类型或 double 类型）为特定于区域设置的货币。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  // 设置响应内容类型
    response.setContentType(&quot;text/html;charset=UTF-8&quot;);
    PrintWriter out = response.getWriter();
    // 获取客户端的区域设置
    Locale locale = request.getLocale( );
    NumberFormat nft = NumberFormat.getCurrencyInstance(locale);
    String formattedCurr = nft.format(1000000);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;特定于区域设置的百分比&lt;/p&gt;
&lt;p&gt;您可以使用 java.text.NumberFormat 类及其静态方法 getPercentInstance() 来格式化特定于区域设置的百分比。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; // 设置响应内容类型
    response.setContentType(&quot;text/html;charset=UTF-8&quot;);
    PrintWriter out = response.getWriter();
    // 获取客户端的区域设置
    Locale locale = request.getLocale( );
    NumberFormat nft = NumberFormat.getPercentInstance(locale);
    String formattedPerc = nft.format(0.51);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;疑问&lt;/p&gt;
&lt;p&gt;Q:Servlet 在 Web 服务器的地址空间内执行。这样它就没有必要再创建一个单独的进程来处理每个客户端请求。这句话怎么理解？&lt;/p&gt;
&lt;p&gt;Q:为什么工作中遇到的JSP页面一般不会写java代码，而是html与js或者说jquery整合？&lt;/p&gt;
&lt;p&gt;A:让Servlet只负责业务逻辑部分，而不会生成HTML代码；同时JSP中也不会充斥着大量的业务代码，这样能大提高了代码的可读性和可维护性。这是因为我们采用MVC模式，这样一来避免了Servlet通过字符串拼接的方式生成动态HTML内容，这样就容易导致代码维护困难、可读性差的缺点，也避免了JSP在HTML中混入大量、复杂的业务逻辑。&lt;/p&gt;
&lt;p&gt;Q:什么是函数式编程？&lt;/p&gt;
&lt;p&gt;Q:servlet怎么请求jsp页面？&lt;/p&gt;
&lt;p&gt;一种：在webapp下的jsp文件可以通过如这个链接直接访问，为什么把jsp文件放在创建的文件夹下就不行了呢？&lt;a href=&quot;http://localhost:8080/hellomybatis/upload.jsp&quot;&gt;http://localhost:8080/hellomybatis/upload.jsp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;扩展阅读&lt;/p&gt;
&lt;p&gt;单点登录技术&lt;/p&gt;
&lt;p&gt;单点登录的目的是为了能在分布式系统或者集群中对用户的请求校验登录状态。&lt;/p&gt;
&lt;p&gt;一般我们用到的是共享session或者唯一token来实现。共享session一般是给网页或者说http请求用，而token一般是给安卓、IOS系统等前端用。&lt;/p&gt;
&lt;p&gt;在这里我们说下共享session。一般我们会用单点登录系统或者是在tomcat上配置redis，当用户请求页面的时候，会根据用户在cookie里默认的sessionId到tomcat上配置redis配置的redis上校验是否存在，存在则不同的系统都共有这个session会话。不存在则跳到登录页面登录。理论上单点登录系统也是这样，一般是通过redis来缓存session会话，实现单点登录。&lt;/p&gt;
&lt;p&gt;servlet和jsp的区别&lt;/p&gt;
&lt;p&gt;ervlet和sp的区别&lt;/p&gt;
&lt;p&gt;1、Servlet在Java代码中可以通过HttpServletResponse对象动态输出HTML内容。&lt;/p&gt;
&lt;p&gt;2、JSP是在静态HTML内容中嵌入Java代码，然后Java代码在被动态执行后生成HTML内容。&lt;/p&gt;
&lt;p&gt;servlet和jsp的各自的特点&lt;/p&gt;
&lt;p&gt;1、Servlet虽然能够很好地组织业务逻辑代码，但是在Java源文件中，因为是通过字符串拼接的方式生成动态HTML内容，这样就容易导致代码维护困难、可读性差。&lt;/p&gt;
&lt;p&gt;2、JSP虽然规避了Servlet在生成HTML内容方面的劣势，但是在HTML中混入大量、复杂的业务逻辑。&lt;/p&gt;
&lt;p&gt;通过MVC双剑合璧&lt;/p&gt;
&lt;p&gt;JSP和Servlet都有自身的适用环境，那么有没有什么办法能够让它们发挥各自的优势呢？答案是肯有的，MVC模式就能够完美解决这一问题。&lt;/p&gt;
&lt;p&gt;MVC模式，是Model-View-Controller的简称，是软件工程中的一种软件架构模式，分为三个基本部分，分别是：模型（Model）、视图（View）和控制器（Controller）：&lt;/p&gt;
&lt;p&gt;Controller——负责转发请求，对请求进行处理&lt;/p&gt;
&lt;p&gt;View——负责界面显示&lt;/p&gt;
&lt;p&gt;Model——业务功能编写（例如算法实现）、数据库设计以及数据存取操作实现&lt;/p&gt;
&lt;p&gt;在JSP/Servlet开发的软件系统中，这三个部分的描述如下所示：&lt;/p&gt;
&lt;p&gt;1、Web浏览器发送HTTP请求到服务端，然后被Controller(Servlet)获取并进行处理（例如参数解析、请求转发）&lt;/p&gt;
&lt;p&gt;2、Controller(Servlet)调用核心业务逻辑——Model部分，获得结果&lt;/p&gt;
&lt;p&gt;3、Controller(Servlet)将逻辑处理结果交给View（JSP），动态输出HTML内容&lt;/p&gt;
&lt;p&gt;4、动态生成的HTML内容返回到浏览器显示&lt;/p&gt;
&lt;p&gt;MVC模式在Web开发中有很大的优势，它完美规避了JSP与Servlet各自的缺点，让Servlet只负责业务逻辑部分，而不会生成HTML代码；同时JSP中也不会充斥着大量的业务代码，这样能大提高了代码的可读性和可维护性。&lt;/p&gt;
</description>
<pubDate>Sun, 03 May 2020 17:36:00 +0000</pubDate>
<dc:creator>卡斯特梅的雨伞</dc:creator>
<og:description>Servlet 教程——检视阅读 参考 Servlet教程——菜鸟——蓝本 Servlet教程——w3cschool Servlet教程——易百 servlet依赖maven依赖： javax.ser</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/castamere/p/12825015.html</dc:identifier>
</item>
<item>
<title>课堂管理系统；在线教辅平台；java课设 - 知亦行</title>
<link>http://www.cnblogs.com/wonker/p/12824823.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wonker/p/12824823.html</guid>
<description>&lt;p&gt;# 白泽智慧教辅平台&lt;/p&gt;
&lt;p&gt;**说明：**&lt;br/&gt;运行时需要修改位置：&lt;br/&gt;bzedu\src\main\resources\application.properties&lt;br/&gt;bzedu\src\main\resources\config\mybatis-config.xml&lt;br/&gt;https证书配置请自行学习&lt;br/&gt;数据库自行配置，直接导入提供的bzedu.sql即可&lt;br/&gt;为方便下载学习，已将工程文件、演示视频、说明文档打包到百度云。&lt;br/&gt;链接：https://pan.baidu.com/s/1rPebGhy7_w9tTjedcv66Ew&lt;br/&gt;提取码：acg3&lt;/p&gt;
&lt;p&gt;github：&lt;a href=&quot;https://github.com/wonke/bzedu&quot;&gt;https://github.com/wonke/bzedu&lt;/a&gt; 欢迎star&lt;/p&gt;

&lt;p&gt;**１．** **技术概要**&lt;/p&gt;
&lt;p&gt;后台框架：SpringBoot、Mybatis；前端框架：BootStrap、layUI；&lt;/p&gt;
&lt;p&gt;数据库：MySQL；人脸签到：百度人脸识别API、webRTC、Canvas、Tracking.js；&lt;/p&gt;
&lt;p&gt;**２．** **项目介绍**&lt;/p&gt;
&lt;p&gt;白泽智教是一款围绕教师授课全环节覆盖的在线教辅管理系统。系统功能有：人脸识别签到，智能语音点名，发布查看课堂作业，在线匿名评教，上传下载课件功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1585858/202005/1585858-20200503235704514-604433480.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1585858/202005/1585858-20200503235718939-1492276634.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1585858/202005/1585858-20200503235724844-1037277165.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;**３．** **项目流程图**&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1585858/202005/1585858-20200503235741663-1236252026.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;**４．** **功能设计**&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1585858/202005/1585858-20200503235754869-426129911.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;**(1)** **人脸签到：**教师发起当堂签到，设置截止时间，并可实时查看签到成功的学生名单。学生要在规定时间内登录白泽智教进行人脸签到。结合百度智能云人脸识别有效保证了签到名单真实性。&lt;/p&gt;
&lt;p&gt;**(2)** **课堂管理**：教师可以通过课堂管理模块创建新课堂，查看班级中的成员，同时为教师内置了智能点名功能，智能点名采用了随机抽取的方式在班级中抽选教师指定数量的同学姓名，并且可以智能语音点名。&lt;/p&gt;
&lt;p&gt;**(3)** **课堂作业**：教师可以使用白泽智教在线发布作业、上课时间调整通知等。学生端可以实时查看作业通知。同时作业会根据时间进行排序，学生可以通过查看课堂作业来完成老师安排的任务。&lt;/p&gt;
&lt;p&gt;**(4)** **课堂评教**：学生通过班级号加入班级后可以对课堂进行评教，评教采取匿名的方式，可以对上课后的一些疑惑点向老师提问也可以向老师提出上课的一些建议。老师可以通过教师端对学生的评教信息进行查看，获取同学们课堂上存在的一些疑惑和建议，来更好的为学生解疑答惑，同时也可以吸取同学们的意见调整授课节奏，加强学生与老师之间的沟通。&lt;/p&gt;
&lt;p&gt;**(5)** **课件上传**：教师可以进行上传平时上课用到的课件等文件，以便学生课下进行学习和查看，文件支持多种常见格式，极大的满足用户文档上传需求，学生和教师可以对文件进行下载查看。&lt;/p&gt;
&lt;p&gt;**(6)** **面部数据**：教师专属后台管理功能，由教师审核确认后将参与课程的同学面部数据采集录入百度智能云人脸库，统一安全保护，提供人脸签到识别时的参照。&lt;/p&gt;
&lt;p&gt;**2.3界面设计**&lt;/p&gt;
&lt;p&gt;界面主要使用了Bootstrap以及Layui两大前端框架，网页使用采用了响应式的设计理念，专门为移动端进行了适配，使得在手机上打开网页也能感受到原生APP的使用体验。图片图标主要引自bootstrap和Iconfont-阿里巴巴矢量图标库。&lt;/p&gt;
</description>
<pubDate>Sun, 03 May 2020 15:59:00 +0000</pubDate>
<dc:creator>知亦行</dc:creator>
<og:description># 白泽智慧教辅平台 **说明：** 运行时需要修改位置： bzedu\src\main\resources\application.properties bzedu\src\main\resourc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wonker/p/12824823.html</dc:identifier>
</item>
</channel>
</rss>