<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>致于即将逝去的2108年，2019年您好 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/10203595.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/10203595.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;前言：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　今天是2018年的最后一天，还有大约两个小时即将要面对的是2019年。从人山人海中逃离回来的我，内心总是觉得应该对这即将逝去的2018年每个圆满的句号，也对在外工作的第二年所经历的一些事情做一个总结，对2019年该走的路做一个明确的方向。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;工作上：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　&lt;span&gt;　2018年对于我来说是一个意义非凡的一年，是对我的职业道路影响最为深远的一年。为什么我会这么说呢?这还的从头说起，2017年3月中旬从学校出来实习，那时候很顺利的通过校招，来到了一家以销售为主的公司，该公司是一家小型的创业公司，大概有个50人左右，其中程序员只有10人左右。这也是我进入公司以后才知道的，再次之前一直以为这家公司有很多的程序员，当然程序员多不多并不是很重要，对于我个人而已，能够学到东西我就很满足了，因为刚开始出来工作。但是结果往往都是差强人意的，因为在这家公司技术都是靠外包，我们的主要工作就是维护系统，做些数据操作和一些小功能的升级迭代。做开发的都知道这样，个人的技术是永远都是无法提升的。是的我就是这样懵懂的在这里做完了2017年，但是这对于喜欢挑战新东西的我来说却已经无法再忍受这种安逸的工作环境了。2018年初，我提了离职当然我的上一任老板对于我的这种想法也是十分的支持的，也对我说了很多公司的也许其他因素，其实我也知道，当老板的其实也挺不容易的一个人要养活四五十人，假如开发一款公司所需要的软件的话耗时耗力，并且还存在很大的风险，所以老板选择用别人已经成熟的系统也是明智之举。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　没错，2018年3月初我离开了我的第一家公司，当然我也感谢以前的同事和老板让我学习到了社会为人处世之道。当然辞职以后我并没有闲着，在辞职后的一周里我面试了八家公司，收到了5家office，还有三家的要求太高，没有通过技术面试（还是技术太渣了）。当然通过这一周的面试我发现我自己的技术真的很渣，于是我选择了一家我自己感觉工作氛围还不错，并且方向还不错的公司（该公司主要从事是电商，微信公众号，微信小程序），就是工资没有达到我的预期。不过现在证明了我当初的这个选择是正确的，在现在的这家公司里大牛有好几个并且他们都很乐意的回答你的困惑，当然前提是你要主动和努力。没错，来到这家公司我只有一个目的把技术学好，我告诉自己不能够再像上家公司一样过得这么安逸了。其实有的时候想让自己过得充实和变得努力，身边的一些压力也是必不可缺的。来新公司的第一天，不是让我熟悉公司开发框架而是让我直接上手，对于一个从来没有接触过微信开发的人来说这是有多么的难受，而且公司还没有框架开发文档说明，只能靠自己摸索。没错就是这么的一种压力，刚进公司的那会我每天能都是最后一个离开公司，每天晚上都要做到两三点才能把当天的任务完成。当然也要感谢当初的压力，让我养成了一个良好的学习和工作习惯，我成功的在两周内总结了一些公司框架的常用的一些数据curd操作，以及一些特殊功能的写法（为了让下一个小白能够快熟的上手），并且我也成功的在两个月内转正。当然现在我还是每天公司最后一个走的人，并不是当天的事情没有做完，而是公司的事情太多了根本做不完，想哭。不过我最应该感谢的还是老板和公司大佬们的器重，能够放心的把一些核心的功能交给我，也谢谢公司的每一个前辈给我的帮助，接下来的日子我还会更加的努力。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;学习上：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　对于学习上而已，我一直都觉得我自己是一个缺乏动力的人。因为只有自己要用的的技术才会沉下心来学习，虽然说有的时候会指定一些学习任务，但是有的时候经常会被一些项目的事情给耽搁。比如说有时候本周计划看完大话设计模式中常用的那几种设计模式，但是有的时候看着看着有搞项目上的东西去了，前面说到过公司的项目多的做不完。在接下来的2019年，将要合理的处理好工作和学习上的事情，并且2019年准备转向.Net Core开发，并且开始研究源码和架构上的东西，不单单只关注业务上的一些东西，最主要的是要把周计划精确到天计划。不要把一些学习计划制定的太过于的大和远，而是要做到精准！以前写博客的基本上是一个月两篇，但是以后是一周最少一篇，虽然说写的技术博客有些渣，但是相信自己多看和多学园内的一些大佬的文字一点能都提升的。记住，现在的社会每天都在进行技术迭代升级和革新，所以我们学习的脚步用于也不能歇息。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;生活上：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　可能2018年让我最为糟糕和最为遗憾的事情可能就是个人感情问题了吧，在今年我失去了那个相爱一年半的女友。其实我也不知道为什么会走到今天这步，以前从来都没有想过会离开她。不过分开的这八九个月里，自己反复的反省着自己，有的时候太过于关注工作上的事情并且经常自己的心情经常会受到工作的影响变得很差，所以走到最后这一步还是因为我自己对人家还是不过好，我也希望她能够找到一个更爱她的人，lcp希望2019年你能够过得更好。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;2018年谢谢你让我经历了我人生中必不可缺的那些环节，2019年我一定要变的更加的优秀更加的努力，更加热爱生活！！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2019年加油！！！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 31 Dec 2018 15:06:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>前言： 今天是2018年的最后一天，还有大约两个小时即将要面对的是2019年。从人山人海中逃离回来的我，内心总是觉得应该对这即将逝去的2018年每个圆满的句号，也对在外工作的第二年所经历的一些事情做一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Can-daydayup/p/10203595.html</dc:identifier>
</item>
<item>
<title>现代 C++ 编译时 结构体字段反射 - BOT-Man</title>
<link>http://www.cnblogs.com/BOT-Man/p/10203562.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BOT-Man/p/10203562.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;基于 C++ 14 原生语法，不到 100 行代码：让编译器帮你写 JSON 序列化/反序列化代码，告别体力劳动。🙃&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文不讨论完整的 C++ 反射技术，只讨论结构体 (struct) 的字段 (field) 反射，及其在序列化/反序列化代码生成上的应用。&lt;/p&gt;
&lt;p&gt;正文开始于 [sec|静态反射] 部分，其他部分都是铺垫。。可以略读。。。&lt;/p&gt;
&lt;h2 id=&quot;背景tldr&quot;&gt;背景（TL;DR）&lt;/h2&gt;
&lt;p&gt;很多人喜欢把程序员称为 &lt;strong&gt;码农&lt;/strong&gt;，程序员也经常嘲讽自己每天都在 &lt;strong&gt;搬砖&lt;/strong&gt;。这时候，大家会想：能否构造出一些 &lt;strong&gt;更好的工具&lt;/strong&gt;，代替我们做那些无意义的 &lt;strong&gt;体力劳动&lt;/strong&gt; 呢？&lt;/p&gt;
&lt;p&gt;在实际 C++ 项目中，我们经常需要实现一些与外部系统交互的 &lt;strong&gt;接口&lt;/strong&gt; —— 外部系统传入 JSON 参数，我们的程序处理后，再以 JSON 的格式传回外部系统。这个过程就涉及到了两次数据结构的转换：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入的 JSON 转换为 C++ 数据结构（&lt;strong&gt;反序列化&lt;/strong&gt; &lt;em&gt;deserialization&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;C++ 数据结构 转换为 输出的 JSON（&lt;strong&gt;序列化&lt;/strong&gt; &lt;em&gt;serialization&lt;/em&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果传输的 JSON 数据 &lt;strong&gt;格式&lt;/strong&gt; &lt;em&gt;(schema)&lt;/em&gt; 非常繁多、比较复杂，那么序列化/反序列化的代码也会变得非常复杂 —— 需要处理 &lt;strong&gt;结构嵌套&lt;/strong&gt;、&lt;strong&gt;可选字段&lt;/strong&gt;、&lt;strong&gt;输入合法性检查&lt;/strong&gt; 等问题。如果为每个 JSON 数据结构都 &lt;strong&gt;人工手写&lt;/strong&gt; 一套序列化/反序列化代码，那么 &lt;strong&gt;工作量&lt;/strong&gt; 会特别大。&lt;/p&gt;
&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;p&gt;例如，&lt;a href=&quot;https://github.com/chromium/chromium/blob/master/headless/public/internal/headless_devtools_client_impl.h&quot;&gt;chromium/headless 的 devtools 相关接口&lt;/a&gt; 里就定义了 33 个 &lt;strong&gt;领域模型&lt;/strong&gt; &lt;em&gt;(domain model)&lt;/em&gt;，每个模型有自己的格式，其中又包含了许多字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;懒惰是程序员的天性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;“勤奋” 的程序员选择 [sec|人工手写 序列化/反序列化 代码]&lt;/li&gt;
&lt;li&gt;“懒惰” 的程序员选择
&lt;ul&gt;&lt;li&gt;构建代码生成器（例如 &lt;a href=&quot;https://github.com/protocolbuffers/protobuf&quot;&gt;protobuf&lt;/a&gt;、&lt;a href=&quot;https://github.com/chromium/chromium/tree/master/mojo&quot;&gt;chromium/mojo&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;或 [sec|编译器生成 序列化/反序列化 代码]&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;代码生成器虽然功能强大，但依赖复杂，不易于和已有系统集成。所以本文主要讨论如何用 C++ 14 提供的 &lt;strong&gt;元编程&lt;/strong&gt; &lt;em&gt;(metaprogramming)&lt;/em&gt; 技巧，让编译器帮你写代码。&lt;/p&gt;
&lt;h2 id=&quot;目标tldr&quot;&gt;目标（TL;DR）&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;基于 C++ &lt;strong&gt;原生语法&lt;/strong&gt;，不需要引入第三方库&lt;/li&gt;
&lt;li&gt;提供 &lt;strong&gt;声明式&lt;/strong&gt; &lt;em&gt;(declarative)&lt;/em&gt; 的方法，只需要声明格式，不需要写逻辑语句&lt;/li&gt;
&lt;li&gt;不会带来 &lt;strong&gt;额外的运行时开销&lt;/strong&gt;，能达到和手写代码一样的运行时效率&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基于 &lt;a href=&quot;https://github.com/nlohmann/json&quot;&gt;nlohmann 的 C++ JSON 库&lt;/a&gt;，给定两个 C++ 结构体 &lt;code&gt;SimpleStruct&lt;/code&gt; 和 &lt;code&gt;NestedStruct&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct SimpleStruct {
  bool bool_;
  int int_;
  double double_;
  std::string string_;
  std::unique_ptr&amp;lt;bool&amp;gt; optional_;
};

struct NestedStruct {
  SimpleStruct nested_;
  std::vector&amp;lt;SimpleStruct&amp;gt; vector_;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般接口的业务处理，往往包括三部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解析输入（字符串到 JSON 对象的转换 + JSON 对象到领域模型的 &lt;strong&gt;反序列化&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;处理业务逻辑（实际需要我们写的代码）&lt;/li&gt;
&lt;li&gt;转储输出（领域模型到 JSON 对象的 &lt;strong&gt;序列化&lt;/strong&gt; + JSON 对象到字符串的转换）&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// input
json json_input = json::parse(
    &quot;{&quot;
    &quot;  \&quot;_nested\&quot;: {&quot;
    &quot;    \&quot;_bool\&quot;: false,&quot;
    &quot;    \&quot;_int\&quot;: 0,&quot;
    &quot;    \&quot;_double\&quot;: 0,&quot;
    &quot;    \&quot;_string\&quot;: \&quot;foo\&quot;&quot;
    &quot;  },&quot;
    &quot;  \&quot;_vector\&quot;: [{&quot;
    &quot;    \&quot;_bool\&quot;: true,&quot;
    &quot;    \&quot;_int\&quot;: 1,&quot;
    &quot;    \&quot;_double\&quot;: 1,&quot;
    &quot;    \&quot;_string\&quot;: \&quot;bar\&quot;,&quot;
    &quot;    \&quot;_optional\&quot;: true&quot;
    &quot;  },{&quot;
    &quot;    \&quot;_bool\&quot;: true,&quot;
    &quot;    \&quot;_int\&quot;: 2,&quot;
    &quot;    \&quot;_double\&quot;: 2.0,&quot;
    &quot;    \&quot;_string\&quot;: \&quot;baz\&quot;,&quot;
    &quot;    \&quot;_optional\&quot;: false&quot;
    &quot;  }]&quot;
    &quot;}&quot;);
NestedStruct nested = json_input.get&amp;lt;NestedStruct&amp;gt;();

// use
nested.nested_.string_ += &quot; in nested struct&quot;;

// output
json json_output = json(nested);
std::string string_output = json_output.dump(2);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;对于 JSON 对象和字符串之间的转换，主流的 &lt;strong&gt;JSON 库都实现&lt;/strong&gt; 了：
&lt;ul&gt;&lt;li&gt;调用 &lt;code&gt;json::parse&lt;/code&gt; 从字符串得到输入 JSON 对象&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;json::dump&lt;/code&gt; 将 JSON 对象转为用于输出的字符串&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;而 JSON 对象和 C++ 结构体之间的转换，&lt;strong&gt;需要我们实现&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;通过反序列化，调用 &lt;code&gt;json::get&amp;lt;NestedStruct&amp;gt;()&lt;/code&gt; 得到 &lt;code&gt;NestedStruct nested&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;通过序列化，使用 &lt;code&gt;nested&lt;/code&gt; 构造输出 JSON 对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实现&quot;&gt;实现&lt;/h2&gt;
&lt;p&gt;实现从 C++ 结构体到 JSON 的序列化/反序列化操作，需要用到以下信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;结构体有 &lt;strong&gt;哪些字段&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;bool_&lt;/code&gt;/&lt;code&gt;int_&lt;/code&gt;/&lt;code&gt;double_&lt;/code&gt;/&lt;code&gt;string_&lt;/code&gt;/&lt;code&gt;optional_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nested_&lt;/code&gt;/&lt;code&gt;vector_&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每个 &lt;strong&gt;字段&lt;/strong&gt; 在 &lt;strong&gt;结构体中&lt;/strong&gt; 的什么 &lt;strong&gt;位置&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;amp;SimpleStruct::bool_&lt;/code&gt;/&lt;code&gt;&amp;amp;SimpleStruct::int_&lt;/code&gt;/&lt;code&gt;&amp;amp;SimpleStruct::double_&lt;/code&gt;/&lt;code&gt;&amp;amp;SimpleStruct::string_&lt;/code&gt;/&lt;code&gt;&amp;amp;SimpleStruct::optional_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;amp;NestedStruct::nested_&lt;/code&gt;/&lt;code&gt;&amp;amp;NestedStruct::vector_&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每个 &lt;strong&gt;字段&lt;/strong&gt; 在 &lt;strong&gt;JSON 中&lt;/strong&gt; 对应的 &lt;strong&gt;名称&lt;/strong&gt; 是什么
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&quot;_bool&quot;&lt;/code&gt;/&lt;code&gt;&quot;_int&quot;&lt;/code&gt;/&lt;code&gt;&quot;_double&quot;&lt;/code&gt;/&lt;code&gt;&quot;_string&quot;&lt;/code&gt;/&lt;code&gt;&quot;_optional&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;_nested&quot;&lt;/code&gt;/&lt;code&gt;&quot;_vector&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;每个 &lt;strong&gt;字段&lt;/strong&gt; 如何从 C++ 到 JSON 进行 &lt;strong&gt;类型映射&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;bool&lt;/code&gt; 对应 &lt;code&gt;Boolean&lt;/code&gt;，&lt;code&gt;int&lt;/code&gt; 对应 &lt;code&gt;Number(Integer)&lt;/code&gt;，&lt;code&gt;double&lt;/code&gt; 对应 &lt;code&gt;Number&lt;/code&gt;，&lt;code&gt;string&lt;/code&gt; 对应 &lt;code&gt;String&lt;/code&gt;，&lt;code&gt;vector&lt;/code&gt; 对应 &lt;code&gt;Array&lt;/code&gt;，&lt;code&gt;SimpleStruct&lt;/code&gt;/&lt;code&gt;NestedStruct&lt;/code&gt; 对应 &lt;code&gt;Object&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;必选字段缺失&lt;/strong&gt; 或 字段类型与 JSON 数据 &lt;strong&gt;类型不匹配&lt;/strong&gt;，则抛出异常&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可选字段&lt;/strong&gt;（例如 &lt;code&gt;optional_&lt;/code&gt;）缺失，则跳过检查&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于很多支持 &lt;a href=&quot;https://en.wikipedia.org/wiki/Reflection_%28computer_programming%29&quot;&gt;&lt;strong&gt;反射&lt;/strong&gt; &lt;em&gt;(reflection)&lt;/em&gt;&lt;/a&gt; 的语言，&lt;strong&gt;JSON 的解析者&lt;/strong&gt; 可以通过反射接口，查询到 &lt;code&gt;SimpleStruct&lt;/code&gt;/&lt;code&gt;NestedStruct&lt;/code&gt; 所有的 &lt;strong&gt;字段信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;尽管 C++ 支持 &lt;a href=&quot;https://en.wikipedia.org/wiki/Run-time_type_information&quot;&gt;&lt;strong&gt;运行时类型信息&lt;/strong&gt; &lt;em&gt;(RTTI, run-time type information)&lt;/em&gt;&lt;/a&gt;，但无法得到所有上述信息，所以需要 &lt;strong&gt;&lt;code&gt;SimpleStruct&lt;/code&gt; 的定义者&lt;/strong&gt; 把这些信息告诉 &lt;strong&gt;JSON 的解析者&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;人工手写-序列化反序列化-代码&quot;&gt;人工手写 序列化/反序列化 代码&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2018/Cpp-Struct-Field-Reflection/raw_json.cc&quot;&gt;代码链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;实现序列化/反序列化最简单的方法，就是通过 &lt;strong&gt;人工编写&lt;/strong&gt; 代码：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void to_json(nlohmann::json&amp;amp; j, const SimpleStruct&amp;amp; value) {
  j[&quot;_bool&quot;] = value.bool_;
  j[&quot;_int&quot;] = value.int_;
  j[&quot;_double&quot;] = value.double_;
  j[&quot;_string&quot;] = value.string_;
  j[&quot;_optional&quot;] = value.optional_;
}

void from_json(const nlohmann::json&amp;amp; j, SimpleStruct&amp;amp; value) {
  j.at(&quot;_bool&quot;).get_to(value.bool_);
  j.at(&quot;_int&quot;).get_to(value.int_);
  j.at(&quot;_double&quot;).get_to(value.double_);
  j.at(&quot;_string&quot;).get_to(value.string_);
  if (j.find(&quot;_optional&quot;) != j.cend()) {
    j.at(&quot;_optional&quot;).get_to(value.optional_);
  }
}

void to_json(nlohmann::json&amp;amp; j, const NestedStruct&amp;amp; value) {
  j[&quot;_nested&quot;] = value.nested_;
  j[&quot;_vector&quot;] = value.vector_;
}

void from_json(const nlohmann::json&amp;amp; j, NestedStruct&amp;amp; value) {
  j.at(&quot;_nested&quot;).get_to(value.nested_);
  j.at(&quot;_vector&quot;).get_to(value.vector_);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;to_json&lt;/code&gt;/&lt;code&gt;from_json&lt;/code&gt; 包含了 &lt;strong&gt;所有字段&lt;/strong&gt; 的 &lt;strong&gt;位置、名称、映射方法&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;使用 &lt;code&gt;j[name] = field&lt;/code&gt; 序列化&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;j.at(name).get_to(field)&lt;/code&gt; 反序列化&lt;/li&gt;
&lt;li&gt;针对可选字段检查字段是否存在，不存在则跳过&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;nlohmann 的 C++ JSON 库能处理 &lt;strong&gt;结构嵌套&lt;/strong&gt;：
&lt;ul&gt;&lt;li&gt;&lt;code&gt;j = value.nested_&lt;/code&gt; 会调用 &lt;code&gt;void to_json(json&amp;amp; j, const SimpleStruct&amp;amp; value)&lt;/code&gt; 序列化 &lt;code&gt;SimpleStruct&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;j.get_to(value.nested_)&lt;/code&gt; 会调用 &lt;code&gt;void from_json(const json&amp;amp; j, SimpleStruct&amp;amp; value)&lt;/code&gt; 反序列化 &lt;code&gt;SimpleStruct&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;nlohmann 的 C++ JSON 库基于 C++ 原生的 &lt;strong&gt;异常处理&lt;/strong&gt;（&lt;code&gt;throw-try-catch&lt;/code&gt;）：
&lt;ul&gt;&lt;li&gt;如果字段不存在，函数 &lt;code&gt;json::at&lt;/code&gt; 抛出异常&lt;/li&gt;
&lt;li&gt;如果字段实际类型和 JSON 输入类型不匹配，函数 &lt;code&gt;json::get_to&lt;/code&gt; 抛出异常&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;手写 &lt;code&gt;to_json&lt;/code&gt;/&lt;code&gt;from_json&lt;/code&gt; 需要写 2 份类似的代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一方面，需要复制粘贴，导致 &lt;strong&gt;代码冗余&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;另一方面，两份代码逻辑不是对称的（需要特殊处理 &lt;strong&gt;可选字段&lt;/strong&gt;），不易于统一编写&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;动态反射&quot;&gt;动态反射&lt;/h2&gt;
&lt;p&gt;“崇尚偷懒”的 Google 的工程师为 &lt;a href=&quot;https://github.com/chromium/chromium/blob/master/base/values.h&quot;&gt;chromium/&lt;code&gt;base::Value&lt;/code&gt;&lt;/a&gt; 构建了一套基于 &lt;strong&gt;动态反射&lt;/strong&gt; &lt;em&gt;(dynamic reflection)&lt;/em&gt; 的反序列化机制，实现统一的 JSON 数据和 C++ 结构体转换。（参考：&lt;a href=&quot;https://github.com/chromium/chromium/blob/master/base/json/json_value_converter.h&quot;&gt;chromium/&lt;code&gt;base::JSONValueConverter&lt;/code&gt;&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心原理&lt;/strong&gt; 是：利用 &lt;a href=&quot;https://bot-man-jl.github.io/articles/?post=2017/Design-Patterns-Notes-2#Adapter&quot;&gt;&lt;strong&gt;适配器模式&lt;/strong&gt; &lt;em&gt;(adapter pattern)&lt;/em&gt;&lt;/a&gt; 和 &lt;a href=&quot;https://bot-man-jl.github.io/articles/?post=2017/Design-Patterns-Notes-3#Strategy&quot;&gt;&lt;strong&gt;策略模式&lt;/strong&gt; &lt;em&gt;(strategy pattern)&lt;/em&gt;&lt;/a&gt;，定义 &lt;strong&gt;接口&lt;/strong&gt; &lt;em&gt;(interface)&lt;/em&gt; 抹除具体字段转换操作的类型，通过 &lt;strong&gt;运行时多态&lt;/strong&gt; &lt;em&gt;(runtime polymorphism)&lt;/em&gt; 调用接口进行实际的转换操作。&lt;/p&gt;
&lt;blockquote readability=&quot;4.56&quot;&gt;
&lt;p&gt;Talk is cheap, show me the code ——&lt;br/&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2018/Cpp-Struct-Field-Reflection/dynamic_reflection.h&quot;&gt;代码链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，为不同 &lt;strong&gt;字段类型&lt;/strong&gt; 定义一个通用的转换接口 &lt;code&gt;ValueConverter&amp;lt;FieldType&amp;gt;&lt;/code&gt;，用于存储实际的 C++ 类型与 JSON 类型的转换操作（&lt;strong&gt;仅关联操作的字段类型，抹除具体转换操作的类型&lt;/strong&gt;）：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename FieldType&amp;gt;
using ValueConverter =
    std::function&amp;lt;void(FieldType* field, const std::string&amp;amp; name)&amp;gt;;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;参数 &lt;code&gt;field&lt;/code&gt; 表示字段的值，&lt;code&gt;name&lt;/code&gt; 是字段的名称&lt;/li&gt;
&lt;li&gt;原始代码将 &lt;code&gt;ValueConverter&lt;/code&gt; 定义为接口；本文为了化简，直接使用 &lt;code&gt;std::function&lt;/code&gt;（关于使用接口的讨论，参考：&lt;a href=&quot;https://bot-man-jl.github.io/articles/?post=2017/Callback-vs-Interface&quot;&gt;回调 vs 接口&lt;/a&gt;）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;然后，为不同类型的 &lt;strong&gt;结构体&lt;/strong&gt; 定义一个通用的转换接口 &lt;code&gt;FieldConverterBase&amp;lt;StructType&amp;gt;&lt;/code&gt;，用于存储结构体内所有字段的转换操作（&lt;strong&gt;仅关联结构体的类型，抹除操作的字段类型&lt;/strong&gt;）：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename StructType&amp;gt;
class FieldConverterBase {
 public:
  virtual ~FieldConverterBase() = default;
  virtual void operator()(StructType* obj) const = 0;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着，通过 &lt;code&gt;FieldConverter&amp;lt;StructType, FieldType&amp;gt;&lt;/code&gt; 将上边两个接口 &lt;strong&gt;承接&lt;/strong&gt; 起来，用于存储 &lt;strong&gt;结构体&lt;/strong&gt; 的 &lt;strong&gt;字段类型&lt;/strong&gt; 的实际转换操作（类似于 &lt;a href=&quot;https://en.wikipedia.org/wiki/Double_dispatch&quot;&gt;double dispatch&lt;/a&gt;），同时关联上具体某个字段的位置和名称（&lt;strong&gt;实现 &lt;code&gt;FieldConverterBase&lt;/code&gt; 接口，调用 &lt;code&gt;ValueConverter&lt;/code&gt; 接口&lt;/strong&gt;）：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename StructType, typename FieldType&amp;gt;
class FieldConverter : public FieldConverterBase&amp;lt;StructType&amp;gt; {
 public:
  FieldConverter(const std::string&amp;amp; name,
                 FieldType StructType::*pointer,
                 ValueConverter&amp;lt;FieldType&amp;gt; converter)
      : field_name_(name),
        field_pointer_(pointer),
        value_converter_(converter) {}

  void operator()(StructType* obj) const override {
    return value_converter_(&amp;amp;(obj-&amp;gt;*field_pointer_), field_name_);
  }

 private:
  std::string field_name_;
  FieldType StructType::*field_pointer_;
  ValueConverter&amp;lt;FieldType&amp;gt; value_converter_;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;构造时传递 字段名称 &lt;code&gt;field_name_&lt;/code&gt;，字段的 &lt;strong&gt;成员指针&lt;/strong&gt; &lt;em&gt;(member pointer)&lt;/em&gt;（即字段位置）&lt;code&gt;field_pointer_&lt;/code&gt;，字段的映射方法 &lt;code&gt;value_converter_&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;operator()&lt;/code&gt; 转换时，调用 &lt;code&gt;value_converter_.operator()&lt;/code&gt;，传入 当前结构体中字段的值 和 字段的名称；其中结构体 &lt;code&gt;obj&lt;/code&gt; 字段的值通过 &lt;code&gt;obj-&amp;gt;*field_pointer_&lt;/code&gt; 得到&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后，针对 &lt;strong&gt;结构体&lt;/strong&gt; 定义一个存储 &lt;strong&gt;所有字段&lt;/strong&gt; 信息（名称、位置、映射方法）的容器 &lt;code&gt;StructValueConverter&amp;lt;StructType&amp;gt;&lt;/code&gt;，并提供 &lt;strong&gt;注册&lt;/strong&gt; 字段信息的接口（有哪些字段）&lt;code&gt;RegisterField&lt;/code&gt; 和执行所有转换操作的接口 &lt;code&gt;operator()&lt;/code&gt;（&lt;strong&gt;仅关联结构体的类型，利用 &lt;code&gt;FieldConverterBase&lt;/code&gt; 抹除操作的字段信息&lt;/strong&gt;）：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;class StructType&amp;gt;
class StructValueConverter {
 public:
  template &amp;lt;typename FieldType&amp;gt;
  void RegisterField(FieldType StructType::*field_pointer,
                     const std::string&amp;amp; field_name,
                     ValueConverter&amp;lt;FieldType&amp;gt; value_converter) {
    fields_.push_back(std::make_unique&amp;lt;FieldConverter&amp;lt;StructType, FieldType&amp;gt;&amp;gt;(
        field_name, field_pointer, std::move(value_converter)));
  }

  void operator()(StructType* obj) const {
    for (const auto&amp;amp; field_converter : fields_) {
      (*field_converter)(obj);
    }
  }

 private:
  std::vector&amp;lt;std::unique_ptr&amp;lt;FieldConverterBase&amp;lt;StructType&amp;gt;&amp;gt;&amp;gt; fields_;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2018/Cpp-Struct-Field-Reflection/dynamic_iostream.cc&quot;&gt;使用样例代码链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体使用时，只需要两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构造 &lt;code&gt;converter&lt;/code&gt; 对象，调用 &lt;code&gt;RegisterField&lt;/code&gt; &lt;strong&gt;动态绑定字段信息&lt;/strong&gt;（名称、位置、映射方法）&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;converter(&amp;amp;simple)&lt;/code&gt; 对所有注册了的字段 &lt;strong&gt;进行转换&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// setup converter (partial)
auto int_converter = [](int* field, const std::string&amp;amp; name) {
  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; *field &amp;lt;&amp;lt; std::endl;
};
auto string_converter = [](std::string* field, const std::string&amp;amp; name) {
  std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; *field &amp;lt;&amp;lt; std::endl;
};

StructValueConverter&amp;lt;SimpleStruct&amp;gt; converter;
converter.RegisterField(&amp;amp;SimpleStruct::int_, &quot;int&quot;,
                        ValueConverter&amp;lt;int&amp;gt;(int_converter));
converter.RegisterField(&amp;amp;SimpleStruct::string_, &quot;string&quot;,
                        ValueConverter&amp;lt;std::string&amp;gt;(string_converter));

// use converter
SimpleStruct simple{2, &quot;hello dynamic reflection&quot;};
converter(&amp;amp;simple);

// output:
//   int: 2
//   string: hello dynamic reflection&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;1.304347826087&quot;&gt;
&lt;p&gt;基于动态反射的开源库：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;静态反射&quot;&gt;静态反射&lt;/h2&gt;
&lt;p&gt;实际上，实现序列化/反序列化所需要的信息（有哪些字段，每个字段的位置、名称、映射方法），在 &lt;strong&gt;编译时&lt;/strong&gt; &lt;em&gt;(compile-time)&lt;/em&gt; 就已经确定了 —— 没必要在 &lt;strong&gt;运行时&lt;/strong&gt; &lt;em&gt;(runtime)&lt;/em&gt; 动态构建 &lt;code&gt;converter&lt;/code&gt; 对象。所以，我们可以利用 &lt;strong&gt;静态反射&lt;/strong&gt; &lt;em&gt;(static reflection)&lt;/em&gt; 的方法，把这些信息告诉 &lt;strong&gt;编译器&lt;/strong&gt;，让它帮我们 &lt;strong&gt;生成代码&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;核心原理&lt;/strong&gt; 是：利用 &lt;a href=&quot;https://bot-man-jl.github.io/articles/?post=2017/Design-Patterns-Notes-3#Visitor&quot;&gt;&lt;strong&gt;访问者模式&lt;/strong&gt; &lt;em&gt;(visitor pattern)&lt;/em&gt;&lt;/a&gt;，使用 &lt;a href=&quot;https://en.cppreference.com/w/cpp/utility/tuple&quot;&gt;&lt;strong&gt;元组&lt;/strong&gt; &lt;code&gt;std::tuple&lt;/code&gt;&lt;/a&gt; 记录结构体所有的字段信息，通过 &lt;strong&gt;编译时多态&lt;/strong&gt; &lt;em&gt;(compile-time polymorphism)&lt;/em&gt; 针对具体的 &lt;strong&gt;字段类型&lt;/strong&gt; 进行转换操作。&lt;/p&gt;
&lt;blockquote readability=&quot;4.56&quot;&gt;
&lt;p&gt;Talk is cheap, show me the code ——&lt;br/&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2018/Cpp-Struct-Field-Reflection/static_reflection.h&quot;&gt;代码链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先，定义一个 &lt;code&gt;StructSchema&amp;lt;StructType&amp;gt;&lt;/code&gt; &lt;strong&gt;函数模板&lt;/strong&gt; &lt;em&gt;(function template)&lt;/em&gt;，返回所有字段信息（默认返回空元组）：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
inline constexpr auto StructSchema() {
  return std::make_tuple();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，提供 &lt;code&gt;DEFINE_STRUCT_SCHEMA&lt;/code&gt; 和 &lt;code&gt;DEFINE_STRUCT_FIELD&lt;/code&gt; 两个 &lt;strong&gt;宏&lt;/strong&gt; &lt;em&gt;(macro)&lt;/em&gt; ，定义结构体 &lt;strong&gt;字段信息&lt;/strong&gt;（有哪些、位置、名称），隐藏 &lt;code&gt;StructSchema&lt;/code&gt; 和 &lt;code&gt;std::tuple&lt;/code&gt; 的实现细节：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;#define DEFINE_STRUCT_SCHEMA(Struct, ...)        \
  template &amp;lt;&amp;gt;                                    \
  inline constexpr auto StructSchema&amp;lt;Struct&amp;gt;() { \
    using _Struct = Struct;                      \
    return std::make_tuple(__VA_ARGS__);         \
  }

#define DEFINE_STRUCT_FIELD(StructField, StructName) \
  std::make_tuple(&amp;amp;_Struct::StructField, StructName)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;StructSchema&lt;/code&gt; 返回元组的结构是：&lt;code&gt;((&amp;amp;field1, name1), (&amp;amp;field2, name2), ...)&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;DEFINE_STRUCT_SCHEMA&lt;/code&gt; 定义了 &lt;strong&gt;结构体&lt;/strong&gt; &lt;code&gt;Struct&lt;/code&gt; &lt;strong&gt;有哪些字段&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DEFINE_STRUCT_FIELD&lt;/code&gt; 定义了每个 &lt;strong&gt;字段&lt;/strong&gt; 的 &lt;strong&gt;位置、名称&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;using _Struct = Struct&lt;/code&gt; 提供了一种宏内数据接力的方法，让下一个宏能获取上一个宏的数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后，提供 &lt;code&gt;ForEachField&amp;lt;StructType&amp;gt;&lt;/code&gt; 函数，从对应的 &lt;code&gt;StructSchema&amp;lt;StructType&amp;gt;&lt;/code&gt; 取出记录结构体 &lt;code&gt;StructType&lt;/code&gt; &lt;strong&gt;所有字段信息&lt;/strong&gt; 的元组，然后遍历这个元组，从中取出 &lt;strong&gt;每个字段的位置、名称&lt;/strong&gt;，作为参数调用转换函数 &lt;code&gt;fn&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T, typename Fn&amp;gt;
inline constexpr void ForEachField(T&amp;amp;&amp;amp; value, Fn&amp;amp;&amp;amp; fn) {
  constexpr auto struct_schema = StructSchema&amp;lt;std::decay_t&amp;lt;T&amp;gt;&amp;gt;();
  detail::ForEachTuple(struct_schema, [&amp;amp;value, &amp;amp;fn](auto&amp;amp;&amp;amp; field_schema) {
    fn(value.*(std::get&amp;lt;0&amp;gt;(std::forward&amp;lt;decltype(field_schema)&amp;gt;(field_schema))),
       std::get&amp;lt;1&amp;gt;(std::forward&amp;lt;decltype(field_schema)&amp;gt;(field_schema)));
  });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;fn&lt;/code&gt; 接受的参数分别为：字段的值和名称 &lt;code&gt;(field_value, field_name)&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;字段的值通过 &lt;code&gt;value.*field_pointer&lt;/code&gt; 得到，其中 &lt;code&gt;field_pointer&lt;/code&gt; 是成员指针&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ForEachTuple&lt;/code&gt; 的实现中还用到了 &lt;strong&gt;静态断言&lt;/strong&gt; &lt;em&gt;(static assert)&lt;/em&gt; 检查，具体见 &lt;a href=&quot;https://bot-man-jl.github.io/articles/2018/Cpp-Struct-Field-Reflection/static_reflection.h&quot;&gt;代码&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;检查 &lt;code&gt;StructSchema&lt;/code&gt; &lt;strong&gt;是否定义了字段信息&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;检查每个字段的信息 &lt;strong&gt;是否都包含了位置和名称&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2018/Cpp-Struct-Field-Reflection/static_iostream.cc&quot;&gt;使用样例代码链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;具体使用时，也是需要两步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用 &lt;code&gt;DEFINE_STRUCT_SCHEMA&lt;/code&gt; 和 &lt;code&gt;DEFINE_STRUCT_FIELD&lt;/code&gt; &lt;strong&gt;静态定义字段信息&lt;/strong&gt;（名称、位置）&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;ForEachField&lt;/code&gt; 并传入 &lt;strong&gt;映射方法&lt;/strong&gt;（函数模板或泛型 lambda 表达式），对所有字段调用这个函数&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// define schema (partial)
DEFINE_STRUCT_SCHEMA(
    SimpleStruct,
    DEFINE_STRUCT_FIELD(int_, &quot;int&quot;),
    DEFINE_STRUCT_FIELD(string_, &quot;string&quot;));

// use ForEachTuple
ForEachField(SimpleStruct{1, &quot;hello static reflection&quot;},
             [](auto&amp;amp;&amp;amp; field, auto&amp;amp;&amp;amp; name) {
               std::cout &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot;: &quot;
                         &amp;lt;&amp;lt; field &amp;lt;&amp;lt; std::endl;
             });

// output:
//   int: 1
//   string: hello static reflection&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;静态反射过程中，&lt;strong&gt;最核心&lt;/strong&gt; 的地方：传入 &lt;code&gt;ForEachField&lt;/code&gt; 的函数 &lt;code&gt;fn&lt;/code&gt;，通过 &lt;strong&gt;编译时多态&lt;/strong&gt; 针对不同 &lt;strong&gt;字段类型&lt;/strong&gt; 选择不同的转换操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;针对 &lt;code&gt;int&lt;/code&gt; 类型字段，&lt;code&gt;ForEachField&lt;/code&gt; 调用 &lt;code&gt;fn(simple.int_, &quot;int&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;针对 &lt;code&gt;std::string&lt;/code&gt; 类型字段，&lt;code&gt;ForEachField&lt;/code&gt; 调用 &lt;code&gt;fn(simple.string_, &quot;string&quot;)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后 &lt;code&gt;ForEachField(SimpleStruct{...}, [](...) { ... });&lt;/code&gt; 经过 &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/inline&quot;&gt;&lt;strong&gt;内联&lt;/strong&gt; &lt;em&gt;(inline)&lt;/em&gt;&lt;/a&gt; 后，生成的代码非常简单：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;{
  SimpleStruct simple{1, &quot;hello static reflection&quot;};
  std::cout &amp;lt;&amp;lt; &quot;int&quot; &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; simple.int_ &amp;lt;&amp;lt; std::endl;
  std::cout &amp;lt;&amp;lt; &quot;string&quot; &amp;lt;&amp;lt; &quot;: &quot; &amp;lt;&amp;lt; simple.string_ &amp;lt;&amp;lt; std::endl;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;2.5&quot;&gt;
&lt;p&gt;基于静态反射的开源库：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;使用编译时静态反射，相对于运行时动态反射，有许多优点：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;使用难度&lt;/td&gt;
&lt;td&gt;（难）需要 &lt;strong&gt;编写注册代码&lt;/strong&gt;，调用 &lt;code&gt;RegisterField&lt;/code&gt; 动态绑定字段信息&lt;/td&gt;
&lt;td&gt;（易）可以通过 &lt;strong&gt;声明式&lt;/strong&gt; 的方法，静态定义字段信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;运行时开销&lt;/td&gt;
&lt;td&gt;（有）需要动态构造 &lt;code&gt;converter&lt;/code&gt; 对象，需要通过 &lt;strong&gt;虚函数表&lt;/strong&gt; &lt;em&gt;(virtual table)&lt;/em&gt; 实现面向对象的多态&lt;/td&gt;
&lt;td&gt;（无）&lt;strong&gt;编译时&lt;/strong&gt; 静态展开代码，和直接手写一样&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;可复用性&lt;/td&gt;
&lt;td&gt;（差）每个 &lt;code&gt;converter&lt;/code&gt; 对象绑定了各个 &lt;strong&gt;字段类型&lt;/strong&gt; 的具体 &lt;strong&gt;映射方法&lt;/strong&gt;；如果需要进行不同转换操作，则需要另外创建 &lt;code&gt;converter&lt;/code&gt; 对象&lt;/td&gt;
&lt;td&gt;（好）在调用 &lt;code&gt;ForEachField&lt;/code&gt; 时，&lt;strong&gt;映射方法&lt;/strong&gt; 作为参数传入；利用 &lt;strong&gt;编译时多态&lt;/strong&gt; 的机制，为不同的 &lt;strong&gt;字段类型&lt;/strong&gt; 选择合适的操作&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;编译器生成-序列化反序列化-代码&quot;&gt;编译器生成 序列化/反序列化 代码&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://bot-man-jl.github.io/articles/2018/Cpp-Struct-Field-Reflection/reflection_json.cc&quot;&gt;代码链接&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基于 &lt;code&gt;ForEachField&lt;/code&gt;，我们可以实现 &lt;strong&gt;通用&lt;/strong&gt; 的结构体序列化/反序列化函数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template &amp;lt;typename T&amp;gt;
struct adl_serializer&amp;lt;T, std::enable_if_t&amp;lt;::has_schema&amp;lt;T&amp;gt;&amp;gt;&amp;gt; {
  template &amp;lt;typename BasicJsonType&amp;gt;
  static void to_json(BasicJsonType&amp;amp; j, const T&amp;amp; value) {
    ForEachField(value, [&amp;amp;j](auto&amp;amp;&amp;amp; field, auto&amp;amp;&amp;amp; name) {
      j[name] = field;
    });
  }

  template &amp;lt;typename BasicJsonType&amp;gt;
  static void from_json(const BasicJsonType&amp;amp; j, T&amp;amp; value) {
    ForEachField(value, [&amp;amp;j](auto&amp;amp;&amp;amp; field, auto&amp;amp;&amp;amp; name) {
      // ignore missing field of optional
      if (::is_optional_v&amp;lt;decltype(field)&amp;gt; &amp;amp;&amp;amp;
          j.find(name) == j.end())
        return;

      j.at(name).get_to(field);
    });
  }
};&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;和 [sec|人工手写 序列化/反序列化 代码] 的代码类似：
&lt;ul&gt;&lt;li&gt;使用 &lt;code&gt;j[name] = field&lt;/code&gt; 序列化&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;j.at(name).get_to(field)&lt;/code&gt; 反序列化&lt;/li&gt;
&lt;li&gt;针对可选字段检查字段是否存在，不存在则跳过（C++ 17 还可以使用 &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/if&quot;&gt;&lt;code&gt;if constexpr&lt;/code&gt;&lt;/a&gt; 实现选择性编译）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于如何使用 &lt;code&gt;nlohmann::adl_serializer&lt;/code&gt; 扩展自定义类型的序列化/反序列化操作，参考 &lt;a href=&quot;https://github.com/nlohmann/json#how-do-i-convert-third-party-types&quot;&gt;How do I convert third-party types? | nlohmann/json&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;使用的两个简单的 &lt;strong&gt;变量模板&lt;/strong&gt; &lt;em&gt;(variable template)&lt;/em&gt;，具体见 &lt;a href=&quot;https://bot-man-jl.github.io/articles/2018/Cpp-Struct-Field-Reflection/reflection_json.cc&quot;&gt;代码&lt;/a&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;has_schema&amp;lt;T&amp;gt;&lt;/code&gt; 检查是否定义了 &lt;code&gt;StructSchema&amp;lt;T&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;is_optional_v&amp;lt;decltype(field)&amp;gt;&lt;/code&gt; 检查字段类型是不是可选参数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于需要进行序列化/反序列化的自定义结构体，我们只需要使用 &lt;code&gt;DEFINE_STRUCT_SCHEMA&lt;/code&gt; 和 &lt;code&gt;DEFINE_STRUCT_FIELD&lt;/code&gt; &lt;strong&gt;声明&lt;/strong&gt; 其字段信息即可 —— 不需要为每个结构体写一遍 &lt;code&gt;to_json&lt;/code&gt;/&lt;code&gt;from_json&lt;/code&gt; 逻辑了：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;DEFINE_STRUCT_SCHEMA(
    SimpleStruct,
    DEFINE_STRUCT_FIELD(bool_, &quot;_bool&quot;),
    DEFINE_STRUCT_FIELD(int_, &quot;_int&quot;),
    DEFINE_STRUCT_FIELD(double_, &quot;_double&quot;),
    DEFINE_STRUCT_FIELD(string_, &quot;_string&quot;),
    DEFINE_STRUCT_FIELD(optional_, &quot;_optional&quot;));

DEFINE_STRUCT_SCHEMA(
    NestedStruct,
    DEFINE_STRUCT_FIELD(nested_, &quot;_nested&quot;),
    DEFINE_STRUCT_FIELD(vector_, &quot;_vector&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;于是，编译器就可以生成和 [sec|人工手写 序列化/反序列化 代码] 一致的代码了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://bot-man-jl.github.io/articles/2018/Cpp-Reference-in-Functional/declarative.png&quot; alt=&quot;Declarative&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.5&quot;&gt;
&lt;p&gt;图片来源：&lt;a href=&quot;https://www.smashingmagazine.com/2014/07/declarative-programming/&quot;&gt;Declarative Programming And The Web&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;不依赖于第三方库，只需要简单的声明，没有额外的运行时开销 —— 这就是 &lt;strong&gt;现代 C++ 元编程&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;马上就 2019 年了，“勤奋” 的程序员还在加班手写重复代码的时候，“懒惰” 的程序员都去跨年了。。。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;掌握 C++ 元编程，自己打造工具，解放生产力，告别搬砖的生活！&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;延伸阅读：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果有什么问题，&lt;strong&gt;欢迎交流&lt;/strong&gt; ~&lt;/p&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://bot-man-jl.github.io/articles/?post=2018/Cpp-Struct-Field-Reflection&quot;&gt;简单的 C++ 结构体字段反射&lt;/a&gt;；欢迎关注个人公众号 &lt;strong&gt;BOTManJL&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Delivered under MIT License © 2018, BOT Man&lt;/p&gt;
</description>
<pubDate>Mon, 31 Dec 2018 14:54:00 +0000</pubDate>
<dc:creator>BOT-Man</dc:creator>
<og:description>基于 C++ 14 原生语法，不到 100 行代码：让编译器帮你写 JSON 序列化/反序列化代码，告别体力劳动。🙃 本文不讨论完整的 C++ 反射技术，只讨论结构体 (struct) 的字段 (f</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/BOT-Man/p/10203562.html</dc:identifier>
</item>
<item>
<title>Vigenere加密 - mambakb</title>
<link>http://www.cnblogs.com/mambakb/p/10187493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mambakb/p/10187493.html</guid>
<description>&lt;p&gt;Vigenere加密法原理很简单，实现起来也不难。与普通的单码加密法不同，明文经过加密之后，每个字母出现的频率就不会有高峰和低峰。&lt;/p&gt;
&lt;p&gt;密钥中字母代表行和明文中的字母代表行。在vigenere表中找到对应的字母即可。当明文的长度大于密钥的长度的时候，密钥重复使用。下面是go语言的实现版本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451419/201812/1451419-20181230213213775-452765813.png&quot; alt=&quot;&quot; width=&quot;400&quot; height=&quot;394&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　vigenege表&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; arr [&lt;span&gt;27&lt;/span&gt;][&lt;span&gt;27&lt;/span&gt;]&lt;span&gt;int //Vigenere表&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;string&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hold&lt;/span&gt;&lt;span&gt;&quot; //密钥&lt;/span&gt;&lt;span&gt;
//初始化vigenere表
func init() {
    arr[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;2&lt;/span&gt;; i++&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j := &lt;span&gt;1&lt;/span&gt;; j &amp;lt; &lt;span&gt;27&lt;/span&gt;; j++&lt;span&gt; {
            arr[i][j] &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + j - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        }
    }
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;1&lt;/span&gt;; i &amp;lt; &lt;span&gt;27&lt;/span&gt;; i++&lt;span&gt; {
        arr[i][&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + i - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
    }
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; num &lt;span&gt;int&lt;/span&gt; = &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;26&lt;/span&gt;; i &amp;gt; &lt;span&gt;0&lt;/span&gt;; i--&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; j := &lt;span&gt;2&lt;/span&gt;; j &amp;lt; &lt;span&gt;27&lt;/span&gt;; j++&lt;span&gt; {
            arr[j][i] &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; +&lt;span&gt; num
            num&lt;/span&gt;++
            &lt;span&gt;if&lt;/span&gt; num%&lt;span&gt;26&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;&lt;span&gt; {
                num &lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
            }
        }
    }
}&lt;br/&gt;//进行加密
func encrypt(str &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;) []&lt;span&gt;byte&lt;/span&gt;&lt;span&gt; {
    count :&lt;/span&gt;= &lt;span&gt;0&lt;/span&gt;
    &lt;span&gt;var&lt;/span&gt; ciphertext []&lt;span&gt;byte&lt;/span&gt; = []&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;(str)
    length :&lt;/span&gt;=&lt;span&gt; len(key)
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i := &lt;span&gt;0&lt;/span&gt;; i &amp;lt; len(str); i++&lt;span&gt; {
        ciphertext[i] &lt;/span&gt;= &lt;span&gt;byte&lt;/span&gt;(arr[str[i]-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;][key[count]-&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;])
        count&lt;/span&gt;++&lt;span&gt;
        count &lt;/span&gt;%=&lt;span&gt; length
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ciphertext
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在很长的一段时间内Vigenere加密法一直被认为是无法破解的。我们可以通过IC(index of coincidence)值来得到密钥的长度。这里还要用到MR(measure of roughness)。当所有字母都均匀分布，那么选取每个字母的概率都相同。为1/26。那么从一段密文中选取某个字母的概率与均匀分布的概率偏差为&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451419/201812/1451419-20181230215818266-698680666.png&quot; alt=&quot;&quot; width=&quot;100&quot; height=&quot;51&quot;/&gt;&lt;/p&gt;
&lt;p&gt;MR就是a-z中所有的字母的偏差的和。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1451419/201812/1451419-20181230220122448-532852259.png&quot; alt=&quot;&quot; width=&quot;177&quot; height=&quot;56&quot;/&gt;&lt;/p&gt;
&lt;p&gt;展开后在进行一些简单的计算可以得到&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451419/201812/1451419-20181230220719492-1216674888.png&quot; alt=&quot;&quot; width=&quot;160&quot; height=&quot;61&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在MR中唯一依赖密文的地方就是&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451419/201812/1451419-20181230220853115-894840767.png&quot; alt=&quot;&quot; width=&quot;22&quot; height=&quot;30&quot;/&gt;。其值为密文中 i 单词出现的次数与密文长度的比值。那么&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451419/201812/1451419-20181230221111792-1833304056.png&quot; alt=&quot;&quot; width=&quot;29&quot; height=&quot;29&quot;/&gt;和IC为&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451419/201812/1451419-20181230221305378-140007688.png&quot; alt=&quot;&quot; width=&quot;153&quot; height=&quot;59&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1451419/201812/1451419-20181230221532540-1715333965.png&quot; alt=&quot;&quot; width=&quot;157&quot; height=&quot;86&quot;/&gt;&lt;/p&gt;
&lt;p&gt;知道了IC值之后，我们可以用IC值，当IC值在0.038与0.066之间时。采用了多码加密法。但我们任然无法准确的得到密钥的长度。1863年Kasiski提出了破解Vigenere的方法。当我们利用密钥加密的时候，总是重复的利用密钥进行加密，当加密后的密文中有重复的字符串则是密钥中相同的部分加密后得到的。当然，也有可能是偶然情况导致的，不过偶然情况不可能出现长串的相同字符串。因此偶然情况的影响可以消除。如下,第一段的 RUN 为密钥，中间是明文，最后为加密后的密文。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;R U N R U N R U N R U N R U N R U N R U N R U N R U N
t o b e o r n o r t o b e t h a t i s t h e q u e s t
K L O V I E E I G K I O V N U R N V J N U V K H V M G&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以观察到密文中'KLOV'出现了两次，‘NU’同样也出现了两次。而重复出现的密文则表示了密钥使用的次数。因此，上述的密钥长度应为6和9的公约数。当获得足够多的密文之后，就可以得到密钥的长度。&lt;/p&gt;
&lt;p&gt;有了密钥的长度就意味着我们可以把密文分为密钥长度个集合，且这些集合是由同个字母单码加密得到的。比如上述密文，我们得到密钥长度为3，那么我们可以得到3个集合&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;K V E K V R J V V
L I I I N N N K M
O E G O U V U H G&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们可以分别破解3个由单码加密的密文&lt;/p&gt;
</description>
<pubDate>Mon, 31 Dec 2018 14:22:00 +0000</pubDate>
<dc:creator>mambakb</dc:creator>
<og:description>Vigenere加密法原理很简单，实现起来也不难。与普通的单码加密法不同，明文经过加密之后，每个字母出现的频率就不会有高峰和低峰。 密钥中字母代表行和明文中的字母代表行。在vigenere表中找到对应</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mambakb/p/10187493.html</dc:identifier>
</item>
<item>
<title>上周热点回顾（12.24-12.30） - 博客园团队</title>
<link>http://www.cnblogs.com/cmt/p/10203437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cmt/p/10203437.html</guid>
<description>[unable to retrieve full-text content]热点随笔： · Windows 支持 OpenSSH 了！（sparkdev）· 29岁了还一事无成是人生的常态？（沉默王二）· 个税革新，你每年能省多少钱～（平头哥联盟）· 互联网寒冬，阿里Ant Design还开坑，程序员该何去何从？（雪雁）· Surging1.0发布在即，.NET开发者们，你</description>
<pubDate>Mon, 31 Dec 2018 14:05:00 +0000</pubDate>
<dc:creator>博客园团队</dc:creator>
<og:description>热点随笔： · Windows 支持 OpenSSH 了！（sparkdev）· 29岁了还一事无成是人生的常态？（沉默王二）· 个税革新，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cmt/p/10203437.html</dc:identifier>
</item>
<item>
<title>[C语言]声明解析器cdecl修改版 - Magic激流</title>
<link>http://www.cnblogs.com/magicxyx/p/10203208.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/magicxyx/p/10203208.html</guid>
<description>

&lt;p&gt;    K&amp;amp;R曾经在书中承认，&quot;C语言声明的语法有时会带来严重的问题。&quot;。由于历史原因(BCPL语言只有唯一一个类型——二进制字)，C语言声明的语法在各种合理的组合下会变得晦涩难懂。不过在15级的优先级规则加持下，C语言的声明仍然有迹可循。这篇文章讲解了一个通常取名为&quot;cdecl&quot;(不同于函数调用约定)的小型程序，该程序常用来解析C语言的声明。本程序的基始版本来源于《C专家编程》p75，约140行代码。&lt;/p&gt;
&lt;p&gt;    博主在这个程序的基础上，增加了两个模块的功能：&lt;/p&gt;
&lt;p&gt;        1、struct/enum/union关键字后&lt;strong&gt;标签&lt;/strong&gt;与&lt;strong&gt;变量名&lt;/strong&gt;的甄别&lt;/p&gt;
&lt;p&gt;            有如下声明：&lt;em&gt;struct student a;&lt;/em&gt; 在这个声明中student是作为struct后可选的&quot;结构标签&quot;出现的，a才是变量名称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201812/1219242-20181231201634554-1653628029.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;        2、函数参数的处理&lt;/p&gt;
&lt;p&gt;            源程序略过了函数参数处理的模块，在此，我们加入了此功能，尽管有些简化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201812/1219242-20181231201635028-976003340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;    通常情况下来讲，一个C语言声明由三部分组成：类型说明符+声明名称(declarator)+分号，如&lt;em&gt;int a;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201812/1219242-20181231201635299-1547248532.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;    1、声明从它的名字开始读取，随后按照优先级顺序依次读取。&lt;/p&gt;
&lt;p&gt;    2、优先级从高到低依次是：&lt;/p&gt;
&lt;p&gt;        2.1、声明中被括号括起来的那部分&lt;/p&gt;
&lt;p&gt;        2,2、后缀操作符：&lt;/p&gt;
&lt;p&gt;            符号 () 表示这是一个函数&lt;/p&gt;
&lt;p&gt;            符号 [] 表示这是一个数组&lt;/p&gt;
&lt;p&gt;        2.3、前缀操作符：*代表&quot;指向...的指针&quot;&lt;/p&gt;
&lt;p&gt;    3、如果const/volatile关键字后面紧跟类型说明符(如int)，那么该关键字作用于类型说明符。在其他情况下，const/volatile关键字作用于它左边紧邻的指针星号。&lt;/p&gt;

&lt;p&gt;    因此运用该规则分析如下声明：&lt;strong&gt;&lt;em&gt;char *(*c[10])();&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    &lt;/strong&gt;第一步：找到变量名c&lt;/p&gt;
&lt;p&gt;    第二步：处理c后的[10]，表示&quot;c是一个有10个元素的数组&quot;&lt;/p&gt;
&lt;p&gt;    第三步：处理c前的*，表示&quot;数组元素为指针&quot;&lt;/p&gt;
&lt;p&gt;    第四步：处理c所在括号后的括号，表示&quot;数组的元素类型是函数指针&quot;&lt;/p&gt;
&lt;p&gt;    第五步：处理(*c[10])前的星号，表示&quot;数组元素指向的函数的返回值是一个指针&quot;&lt;/p&gt;
&lt;p&gt;    第六步：处理char,表示&quot;数组元素指向的函数的返回值是一个指向char的指针&quot;&lt;/p&gt;
&lt;p&gt;    综上，该声明表示：&lt;strong&gt;C&lt;/strong&gt;是一个有10个元素的数组，数组元素类型是函数指针，其所指向的函数的返回值是一个指向char的指针。&lt;/p&gt;


&lt;p&gt;    由于C语言声明并不可以从左往右直接解析，所以我们需要一个&lt;strong&gt;栈结构&lt;/strong&gt;来保存在读取到声明名称前的所有字段，以便在读取到id后再分析。&lt;/p&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;struct&lt;/strong&gt;&lt;span&gt; token{  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;span&gt; type;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;span&gt; string[MAXTOKENLEN];  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;};  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;struct&lt;/strong&gt;&lt;span&gt; token stack[MAXTOKENS];  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将所有字段分为三类：名称、类型以及限定词，使用枚举类型，使之与&lt;em&gt;char type&lt;/em&gt;对应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;enum&lt;/strong&gt;&lt;span&gt; type_tag {  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    IDENTIFIER,QUALIFIER,TYPE  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;};  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;主函数有两大功能，一是找到identifier，二是处理剩下的声明。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; main (&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    read_to_first_identifier();   &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    deal_with_declarator();   &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; 0;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一个函数从左往右读入输入数据，一个读取一个字段(声明的基本单位)，若字段不是id(标识符)，则将其压入栈中，再读取下一个字段，直到读取到字段，该阶段任务结束。&lt;/p&gt;
&lt;p&gt;第二个函数在得到id后开始工作。根据语法规则，先读取id后的字符，判断其为数组还是函数。在处理完id后的字段后，再依次出栈解析前面的声明。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201812/1219242-20181231201635631-1540432788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;    5.1、读取标识符：&lt;em&gt;read_to_first_identifier();&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;        使用一个循环，每次读取一个字段，并判断其是否为标识符，是，则退出，并输出。对于正在读取的标识符，使用一个全局变量&lt;strong&gt;&lt;em&gt;struct token thistoken&lt;/em&gt;&lt;/strong&gt;存储，在处理完该字段后，若其不为标识符，则压入栈中。&lt;/p&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; read_to_first_identifier()  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    gettoken();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;span&gt;(thistoken.type != IDENTIFIER)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        push(thistoken);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        gettoken();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    printf(&lt;span&gt;&quot;%s is &quot;&lt;span&gt;,thistoken.string);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    gettoken();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;    5.2、读取各字段：&lt;em&gt;gettoken();&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;        我们假设各个含有英文字母的字段(如类型说明符、标识符等)都以空格隔开，因此我们可以从我们读取到的第一个非空字符开始，判断它的类型。标识符前的符号有一下几种：说明符、指针(*)。所以我们将其单独处理。&lt;/p&gt;
&lt;ol readability=&quot;12&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; gettoken()  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;span&gt; *p = thistoken.string;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;span&gt;((*p = getchar()) == &lt;span&gt;' '&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(isalnum(*p))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;span&gt;(isalnum(*++p = getchar()));  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        ungetc(*p,stdin);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        *p = &lt;span&gt;'\0'&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        thistoken.type = classify_string();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; ;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(*p == &lt;span&gt;'*'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        strcpy(thistoken.string,&lt;span&gt;&quot;pointer to&quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        thistoken.type = &lt;span&gt;'*'&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; ;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    thistoken.string[1] = &lt;span&gt;'\0'&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    thistoken.type = *p;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; ;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;        对于标识符及声明符，我们在读取完一个字段后就判断其类型。对于'*'或其他符号('(''['等)，则直接用符号本身作为其类型。&lt;/p&gt;
&lt;h2&gt;    5.3、解析字段类型：&lt;em&gt;classify_string ();&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;        在我们提取到完整的英文/数字字段后，通过该函数来推断其类型。通过&lt;em&gt;strcmp()&lt;/em&gt;函数，将其与各个类型说明符对比，如果一样，则返回类型说明符，如type/qualifier。与因为用strcmp()函数来比较字符串时，字符串相等，函数返回值为0。为了在相等时得到我们想要的真值，就需要对其进行取反。除了用&quot;!&quot;外，用宏来解决更方便。&lt;/p&gt;
&lt;ol readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;&lt;span&gt;#define STRCMP(a,R,b) (strcmp(a,b) R 0)&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;        因此，字符串的比较就成了如下形式：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;void&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;        如果读取到的字段并非限定符或者说明符，则认为其为标识符。&lt;/p&gt;
&lt;ol readability=&quot;46.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;enum&lt;/strong&gt;&lt;span&gt; type_tag classify_string()  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;span&gt; *s = thistoken.string;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;const&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        strcpy(s,&lt;span&gt;&quot;read-only&quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; QUALIFIER;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;volatile&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; QUALIFIER;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;void&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;char&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;singed&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;unsinged&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;short&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;int&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;long&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;float&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;double&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;struct&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        check_type_or_id(s);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;union&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        check_type_or_id(s);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(STRCMP(s,==,&lt;span&gt;&quot;enum&quot;&lt;span&gt;))  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        check_type_or_id(s);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; TYPE;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;return&lt;/strong&gt;&lt;span&gt; IDENTIFIER;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;    5.4、解析字段类型：&lt;em&gt;check_type_or_id();&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;        对于类型struct/type/enum，在声明该类型变量时，类型后的字段极有可能是该关键字后可选的&quot;&lt;strong&gt;结构标签&lt;/strong&gt;&quot;。如声明&lt;strong&gt;&lt;em&gt;struct student xxx;&lt;/em&gt;&lt;/strong&gt;，student是作为一个结构标签存在。该声明与&lt;strong&gt;&lt;em&gt;struct student {内容…}xxx;&lt;/em&gt;&lt;/strong&gt;一致。所以在判断&lt;em&gt;student&lt;/em&gt;时，需要看它后面字段的类型。如果struct后两个字段都为标识符，则最后一个标识符才是真的标识符，类型struct/type/enum后的字段则是该类型的另一个名字，如：xxx是一个叫student的结构体。&lt;/p&gt;
&lt;p&gt;        在该模块的实现上，则是在读取到结构struct/type/enum时，再读取其后的两个标签，再判断，并将真正的标识符及其后的内容&lt;strong&gt;返回到输入流&lt;/strong&gt;中。&lt;/p&gt;
&lt;ol readability=&quot;20.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; check_type_or_id(&lt;span&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;span&gt; *s)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;span&gt; temp[MAXTOKENLEN] = {&lt;span&gt;'\0'&lt;span&gt;};  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;struct&lt;/strong&gt;&lt;span&gt; token temp_struct_one = thistoken;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    gettoken();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;struct&lt;/strong&gt;&lt;span&gt; token temp_struct = thistoken;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    gettoken();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;struct&lt;/strong&gt;&lt;span&gt; token temp_struct3 = thistoken;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(thistoken.type==IDENTIFIER)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        strcat(temp,temp_struct_one.string);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        strcat(temp,&lt;span&gt;&quot; called &quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        strcat(temp,temp_struct.string);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        strcpy(s,temp);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        thistoken = temp_struct3;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        strcpy(temp_struct_one.string,temp);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        thistoken = temp_struct;   &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; i = strlen(temp_struct3.string)-1;i&amp;gt;=0;i--)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;            ungetc(temp_struct3.string[i],stdin);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(thistoken.type&amp;gt;=0 &amp;amp;&amp;amp; thistoken.type&amp;lt;=2)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;for&lt;/strong&gt;&lt;span&gt;(&lt;span&gt;&lt;strong&gt;int&lt;/strong&gt;&lt;span&gt; i = strlen(thistoken.string)-1;i&amp;gt;=0;i--)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;            ungetc(thistoken.string[i],stdin);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    thistoken = temp_struct_one;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;    5.5、声明的处理：deal_with_declarator&lt;em&gt;();&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;        在确定了标识符之后，我们就可以处理各种声明、修饰符了。依据优先级规则，我们先需要观察标识符后的符号，以确定其是否是数组/函数；其后还需要处理指针，最后再处理先前被压栈的符号。&lt;/p&gt;
&lt;p&gt;        在开始该阶段的处理之前，我们观察&lt;em&gt;read_to_first_identifier()函数，在该函数的最后一行，我们确定了标识符后，有进行了一次gettoken()，这次调用即将标识符后的符号读入，因此现在在函数开头我们就可以使用switch()直接选择要处理的情况。&lt;/em&gt;&lt;/p&gt;
&lt;ol readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; deal_with_declarator()  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;switch&lt;/strong&gt;&lt;span&gt;(thistoken.type)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;case&lt;/strong&gt;&lt;span&gt; &lt;span&gt;'['&lt;span&gt;:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            deal_with_arrays();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;&lt;strong&gt;break&lt;/strong&gt;&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;case&lt;/strong&gt;&lt;span&gt; &lt;span&gt;'('&lt;span&gt;:  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            deal_with_function_args();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;&lt;strong&gt;break&lt;/strong&gt;&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    deal_with_pointers();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;span&gt;(top &amp;gt;= 0)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(stack[top].type == &lt;span&gt;'('&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            pop;  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            gettoken();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            deal_with_declarator();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;            printf(&lt;span&gt;&quot;%s &quot;&lt;span&gt;,pop.string);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;    5.6、函数参数的处理：deal_with_function_args&lt;em&gt;();&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;        在《C专家编程》中，没有对函数参数进行处理。在此，我加入了对参数的简单处理。简单处理也即，对于复杂声明的参数，并没有能正确的处理。在我写这个模块时，我有一种对整个程序重构的想法，即将声明的解析抽象成一个独立的函数，现在程序里全局变量对函数功能的拓展限制太大了。&lt;/p&gt;
&lt;p&gt;        该函数的流程则是，将括号内的字段全部读取并输出，遇到','重新读取输出。普通单一的类型说明符可直接输出(如 int a)，而int *a;则无法如此简单处理。由于输出使用的是英语，所以该函数大部分的代码都是在处理不同参数时英语表述的语法问题，如但单参数的'parameter is'与多参数的'parameters are'等语法细节。处理粗糙，不看也罢。&lt;/p&gt;
&lt;ol readability=&quot;32.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;void&lt;/strong&gt;&lt;span&gt; deal_with_function_args()  &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;{  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;span&gt; str[MAXTOKENLEN] = {&lt;span&gt;'\0'&lt;span&gt;};  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;char&lt;/strong&gt;&lt;span&gt; para[MAXTOKENLEN] = {&lt;span&gt;'\0'&lt;span&gt;};   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;bool&lt;/strong&gt;&lt;span&gt; flag_no_para = &lt;span&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;bool&lt;/strong&gt;&lt;span&gt; para_is_one = &lt;span&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    strcat(str,&lt;span&gt;&quot;function&quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    gettoken();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;

&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(thistoken.type != &lt;span&gt;')'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        strcat(str,&lt;span&gt;&quot; whose parameter&quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        flag_no_para = &lt;span&gt;&lt;strong&gt;false&lt;/strong&gt;&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }     &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;while&lt;/strong&gt;&lt;span&gt;(thistoken.type != &lt;span&gt;')'&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(thistoken.string[0] == &lt;span&gt;','&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(para_is_one == &lt;span&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;                strcat(str,&lt;span&gt;&quot;s are&quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;                para_is_one = &lt;span&gt;&lt;strong&gt;false&lt;/strong&gt;&lt;span&gt;;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;            }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;

&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;            strcat(para,&lt;span&gt;&quot; and&quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;        {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;            strcat(para,&lt;span&gt;&quot; &quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;            strcat(para,thistoken.string);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        }     &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;        gettoken();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(para_is_one == &lt;span&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;span&gt; &amp;amp;&amp;amp; flag_no_para== &lt;span&gt;&lt;strong&gt;false&lt;/strong&gt;&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        strcat(str,&lt;span&gt;&quot; is&quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    strcat(str,para);  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    gettoken();  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;if&lt;/strong&gt;&lt;span&gt;(flag_no_para == &lt;span&gt;&lt;strong&gt;true&lt;/strong&gt;&lt;span&gt;)  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;        strcat(str,&lt;span&gt;&quot; returning &quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    &lt;span&gt;&lt;strong&gt;else&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    {  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;        strcat(str,&lt;span&gt;&quot;,it returns &quot;&lt;span&gt;);  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;    }  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;    printf(&lt;span&gt;&quot;%s&quot;&lt;span&gt;,str);   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span&gt;}  &lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201812/1219242-20181231201635888-1649265701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201812/1219242-20181231201636143-1628235689.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1219242/201812/1219242-20181231201636322-126839869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;    新增的功能并不尽如人意，不过也将这次的修改探索总结出来，以供后来者学习，希望后来者少踩一些坑，老老实实重构去哈哈哈。&lt;/p&gt;
&lt;p&gt;    最后….预祝新年快乐~&lt;/p&gt;
&lt;p&gt;源码地址：&lt;a href=&quot;https://github.com/MagicXyxxx/BlogAbout&quot;&gt;C语言声明解析器修改版源码&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 31 Dec 2018 12:17:00 +0000</pubDate>
<dc:creator>Magic激流</dc:creator>
<og:description>一、写在前面 K&amp;R曾经在书中承认，&quot;C语言声明的语法有时会带来严重的问题。&quot;。由于历史原因(BCPL语言只有唯一一个类型——二进制字)，C语言声明的语法在各种合理的组合下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/magicxyx/p/10203208.html</dc:identifier>
</item>
<item>
<title>沉淀一年，我想推荐这些书给你 - 鹏&amp;鹏</title>
<link>http://www.cnblogs.com/liaoweipeng/p/10193795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liaoweipeng/p/10193795.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;将近一年没有写博客，前面一直比较忙，加上一些事情耽搁了，然后自己也在一直思考沉淀，毕业2年的心态跟第一年又不太一样了，不过经验、知识也不一样，个人成长许多，沉淀这一年，我想推荐这些书给你。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/717907/201812/717907-20181229092049656-1037227044.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;一、《Redis开发与运维》&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/717907/201812/717907-20181229091302837-559986731.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;是不是redis只会set、get，然后在加上一个过期时间就吊炸天了，只能说你太幼稚，想不想知道里面一些底层的原理呢，Redis怎么持久化、过期的策略、复制、哨兵、集群、设计与运维等等。看这本书就对了，我觉的这本书特别适合对缓存只会set、get操作同学，能够让你的技术深度更进一步。豆瓣评分9.0&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;二、《从Paxos到Zookeeper》&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/717907/201812/717907-20181229091318868-1632029546.png&quot; alt=&quot;&quot; width=&quot;357&quot; height=&quot;478&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;炸了，zookeeper好多同学可能连创建节点和删除节点这些都没有操作过，我也是属于这一类，只会启动。那我推荐这本书可以让你更了解zookeeper，知道什么永久节点和临时节点、有序节点这小case，更能让你知道paxos算法，zap协议，让你知道怎么使用、部署zookeeper，zookeeper的使用场景、以及zookeeper的一些原理，例如：zookeeper选举机制、基于zookeeper的分布式锁、服务注册与实现，以及zk的节点监听（让我大开眼界的是我以为zk的监听是永久有效的，实际上是监听只有一次有效，我们看到的都是基于api的实现）等等这些技术内幕，值得很多同学学习了解。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三、《Java8实战》&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/717907/201812/717907-20181229091331514-1152968173.png&quot; alt=&quot;&quot; width=&quot;325&quot; height=&quot;412&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;都Java11还推荐Java8，有点诡异，不过我相信还是挺多人的项目在使用低版本的JDK，一开始使用Java8的时候会很不适应，我一开始的时候也只是会用，对一些东西了解很浅，很多时候写一些代码还得搜索。随着了解与理解深入，我发现不用lambda表达式已经不习惯了，看完这本书，你可能惊讶于JDK升级的考虑还是让人耳目一新的，你会了解原来这么多Java8的操作这么6的，了解Java8的默认方法的作用以及优先级，以及Java8的并行流、异步编程等等功能。赶快去体验，相信我，等你熟悉了你会爱上Java8的。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;四、《MySQL技术内幕-InnoDB存储引擎》&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/717907/201812/717907-20181229091347237-1776263794.png&quot; alt=&quot;&quot; width=&quot;298&quot; height=&quot;379&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　什么，我本地执行sql很快，到线上执行特别慢，什么索引又加错了，等等一系列的问题暴露了你对mysql的不了解，相信很多Java开发者都离不开mysql，你真的对mysql了解吗？知道什么是间隙锁、意向锁，肮读、幻读、不可重复读的原因，以及索引的数据结构与算法以及应用，事务的实现，以及mysql表的结构与各种文件，以及undo和redo日志，mysql备份与恢复等等知识，让你对数据库更加了解。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;五、《Spring技术内幕》&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/717907/201812/717907-20181229091405610-797582506.png&quot; alt=&quot;&quot; width=&quot;315&quot; height=&quot;432&quot;/&gt;　　　&lt;span&gt;这本书我买来放了快一年多才啃完的，每次看了一会又放那里了，太难啃了，然后年初的时候抽了一个礼拜去看的，看完之后很沉迷了，发现很多还是写的不错的。如果你对ioc和aop的实现还不太了解，对spring的启动过程不太了解，对springMVC不熟悉的，以及对spring的事务和spring的数据库相关的东西不了解，这本书值得你读一读，打开你进入spring的世界。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;六、《Spring技术内幕》&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/717907/201812/717907-20181229091417870-1386614597.png&quot; alt=&quot;&quot; width=&quot;333&quot; height=&quot;432&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;如果你对Java并发编程不太了解，以及项目中很多时候遇不到高并发，好多公司进去的时候都说项目高并发、大数据量什么，进去发现crud，那你是不是就认定自己只能crud呢，这本书也许可以让你对并发编程有更深的了解，Java的加锁机制、原子性、以及一些日常并发操作的类，以及很多你平时没有使用过的并发工具类：FutureTak,信号量，闭锁(Latch)和栅栏（CyclicBarrier），线程池等等。了解熟悉这些能够让你Java的功底更加扎实。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;七、《码出高效：Java开发手册》&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/717907/201812/717907-20181231184126609-1362012811.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　&lt;span&gt;　阿里10月出的，我领导马上就买了，我也就顺手看了看，嘿嘿。确实不错的书，介绍各个方面得知识，有深入细节也有整体框架，适合给自己形成整个Java的开发体系，既有代码规范的讲解，也有源码的分析，也有个人成长的规划，我觉得是目前我看的在各个方面都挺不错的书，不过我觉得你需要精通某一方面的知识还是需要自己去钻研，着本书只能给你指明一条康庄大道，具体的还是需要自己研究。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　上面的书籍都是我今年看完的觉得不错，还有一部分看完没有整理出来。我觉得很多Java开发者都应该看看，让自己的知识体系丰富起来，同时形成自己的专长。一个精！以上所有书籍我大部分都是看的纸质书籍，没有pdf，个人觉得这些书都是值得给自己买，所以不用叫我发pdf了，我也没有。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 31 Dec 2018 11:01:00 +0000</pubDate>
<dc:creator>鹏&amp;amp;鹏</dc:creator>
<og:description>将近一年没有写博客，前面一直比较忙，加上一些事情耽搁了，然后自己也在一直思考沉淀，毕业2年的心态跟第一年又不太一样了，不过经验、知识也不一样，个人成长许多，沉淀这一年，我想推荐这些书给你。 一、《Re</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liaoweipeng/p/10193795.html</dc:identifier>
</item>
<item>
<title>2018年终总结-从我所在的团队回首一年技术变迁 - Danni3</title>
<link>http://www.cnblogs.com/ouyida3/p/10201478.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ouyida3/p/10201478.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;

&lt;p&gt;今天是2018年的最后一天，独自一人关上房门，静坐回想一年来的总总，当作总结吧。&lt;br/&gt;作为传统的it公司，不是互联网企业，能逐渐转型到各种流行的技术，不容易。如果刚好看到此文章的您是互联网公司的，请不要见笑。&lt;/p&gt;

&lt;h2 id=&quot;spring-cloud&quot;&gt;spring cloud&lt;/h2&gt;
&lt;p&gt;微服务近两年很火，特别是spring推出了spring cloud后。2016年用的人不多，所以市面只是零星出了几本书籍，到了2017年，经过了一年多的使用，用的公司多了，书也多了，2018年出了更多的spring cloud书，虽然很多内容相似，但也可以看出火爆。&lt;/p&gt;
&lt;p&gt;版本更新也非常快，从之前的config+eureka+zuul，到今年zuul从1升级2，但spring cloud官方却推出gateway，并且不支持zuul2。&lt;/p&gt;
&lt;p&gt;不管怎样，我终于用spring cloud实现了一个系统。它涉及写代码的不多，更多的是配置。而大部分的配置，都是我来弄的，也算是一种小幸运吧。&lt;/p&gt;
&lt;p&gt;有些奇怪的是，不少的人把微服务和spring boot总拉到一块，虽然你要使用spring cloud就必须得使用spring boot，但无论如何，boot只是spring的简化与集成，它为什么是微服务呢？比如市面上有一本书名为使用spring boot构建微服务；还有一次会议上，一个经理说：前台用vuejs实现，后台咱们就用微服务实现吧，呃，不需要用spring cloud这么复杂，就用spring boot吧。&lt;/p&gt;
&lt;p&gt;可能大家想说的是RESTful api吧，这个spring mvc里就有了，并不是真正的微服务，可能错的人多了，这样称呼也是对的吧。&lt;/p&gt;
&lt;h2 id=&quot;dubbo&quot;&gt;dubbo&lt;/h2&gt;
&lt;p&gt;dubbo是很早就有了，2015年的项目我就接触过，虽然我在项目里没有真正的写dubbo代码。搞不懂是dubbo推动了微服务还是微服务带旺了dubbo。今年感觉dubbo也发展的不错，也推出了spring cloud dubbo的集成。公司也有用，但是RPC写起代码我自己觉得还是比较麻烦，定义interface，打成jar包提供给外。也许天生就没有rest优雅，毕竟关注的是效率。&lt;/p&gt;
&lt;h2 id=&quot;k8s&quot;&gt;k8s&lt;/h2&gt;
&lt;p&gt;虽然听说也提供微服务，但用起来好像更偏向于容器那一块，今年我没有机会接触到，看看明年公司是否有机会给我弄弄这个。&lt;/p&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;一个东西火了之后，一切都好说。华为也推出了微服务，有技术沉淀就是好，说弄就弄出来。晚舟被抓没事，咱们技术跟上就行。&lt;/p&gt;
&lt;p&gt;微软也出了微服务，不过没太关注.net发展，不是很清楚细节。&lt;/p&gt;

&lt;h2 id=&quot;vue.js&quot;&gt;Vue.js&lt;/h2&gt;
&lt;p&gt;今年公司大力在推。基本作为首要的前端框架，无论pc端还是移动端。大把大把的项目在用。用的基本都是Vue2，好在。1和2的差距还是有些的。如果在写2的代码，拿着一本1的书在看，估计比较难受。Vue3也出来了，有什么新变化呢？&lt;/p&gt;
&lt;p&gt;和react、angular这三巨头，react还是占有率最大，但是增长势头却比不上vue。vue有可能将来超越react吗？虽然尤雨溪当时在google，但是毕竟是国人，现在也回来了，vue也入选osc了，如果它能厉害点，还是开心一点。开源中国去年它还排第四，今年居然是冠军了。&lt;/p&gt;
&lt;h2 id=&quot;layui&quot;&gt;layui&lt;/h2&gt;
&lt;p&gt;这名字。。。我总看成layer，或者和很多类似的一大把ui框架名字很相似：ligerui、easyui等等。但它竟然在2017年ocs排名第一！虽然今年倒退到第四，但是估计国内用的项目还是不少的。很多后端的人都说好用。但同事却有的说不好，究竟好不好？看来我要再努力，多参与。&lt;/p&gt;
&lt;h2 id=&quot;bootstrap&quot;&gt;bootstrap&lt;/h2&gt;
&lt;p&gt;想不到这么多年了，在ui、css上这框架还是这么火。不知道和国内的同样比较流行的element比如何，都是栅格系统。&lt;/p&gt;
&lt;p&gt;这三个框架，今年都没能深入弄，2019年我要在前端技术上再积累多一点，不要老搞后端的，不然领导分配个前端的任务给我我还不会，太丢人了。&lt;/p&gt;
&lt;h2 id=&quot;thymeleaffreemarker&quot;&gt;thymeleaf/freemarker&lt;/h2&gt;
&lt;p&gt;不应该放这。随便吧。模板，今年用的不多，明年可能也逐渐被vue替换吧？&lt;/p&gt;

&lt;p&gt;终于转型ssm了！你没听错，我今年之前并不会spring和mybatis（很久前用过，包括hibernate，但是那时候都是配置xml的，这么多年了，连xml里是啥都不记得了）。&lt;/p&gt;
&lt;p&gt;S所代表的spring已经基本都默认用spring boot替代了。第一个的S也早不是struts1或2，现在没有新项目不用spring mvc了把？&lt;/p&gt;
&lt;p&gt;spring各种注解，学起来很爽。但刚开始还是挺难，特别mvc那块，涉及web。mybatis确实没有hibernate有技术含量，不过，好用就行了，应对复杂业务。&lt;/p&gt;

&lt;p&gt;接着，该轮到数据库上场了。&lt;/p&gt;
&lt;h2 id=&quot;mycat&quot;&gt;mycat&lt;/h2&gt;
&lt;p&gt;mycat在2017年还是很不错的，但是在今年却连osc的前20都进不了。可能大家确实觉得bug有点多吧。我用了了父子表，竟然有事务的bug，想该源码，又不知道怎么改，项目进度压力在那，没时间慢慢看。后来放弃了父子表就好了，虽然要xml里加个rule并且不能关联表查询。（谢谢&lt;a href=&quot;https://me.csdn.net/zhxdick&quot;&gt;张哈希&lt;/a&gt;提供了一点帮助）&lt;/p&gt;
&lt;p&gt;QQ群也是一个莫名其妙的存在，入群要交30元。我很惊讶一个开源的软件要交钱入群。虽然我不知道缘由。&lt;/p&gt;
&lt;p&gt;但作为国内的开源分布式mysql解决方案，并且基本是唯一的解决方案，还是不错的。我很想知道，大家是怎么用mysql的？不用mycat，难道都是自己公司造一个轮子，大家都这么厉害？&lt;/p&gt;
&lt;h2 id=&quot;mysql&quot;&gt;mysql&lt;/h2&gt;
&lt;p&gt;我今年终于认真的用mysql进行开发了，之前几年都是在打酱油。细细研究，和oracle差别巨大。建表时每个字段的定义都有讲究，还有json格式，json，是一个好东西，出现在各处。&lt;/p&gt;
&lt;h2 id=&quot;druid&quot;&gt;druid&lt;/h2&gt;
&lt;p&gt;连数据库，国内大家应该都用这个吧？新项目很少用DBCP了吧？支持下阿里还是不错的。&lt;/p&gt;
&lt;h2 id=&quot;redis&quot;&gt;redis&lt;/h2&gt;
&lt;p&gt;五种数据类型我在一个项目里用了四种，zset以后会有机会的。我从没用过redis，也没写过代码，但是大家却用我设计的redis来开发，还没发现什么问题，非常神奇，redis是一个好工具。集群和非集群还需要继续学习，分别用Jedis和JedsCluster操作。&lt;/p&gt;
&lt;h2 id=&quot;mongodb&quot;&gt;mongodb&lt;/h2&gt;
&lt;p&gt;同事在用，所谓文档，很多是json、或者图片吧？明年看看是否可以接触下。&lt;/p&gt;

&lt;p&gt;消息队列竟然单独一章节，很神奇。多年前，只知道jms。&lt;/p&gt;
&lt;p&gt;kafka和RabbitMQ还是选择了前者。效率优先。rocketmq那些就更没机会了。kafka的主题和分区怎么定，我的经验还是欠缺，多向同事学习，毕竟搞了几十个还是上百个broker。大数据量，大并发才有意思。需要写磁盘的，为什么还能这么高效？&lt;/p&gt;

&lt;h2 id=&quot;nginx&quot;&gt;nginx&lt;/h2&gt;
&lt;p&gt;2018年apacke虽然继续第一，但nginx也不弱，第二。而且增长势头第一。apache主要是国外php用所以才多吧？国内java的世界，估计nginx更火。&lt;/p&gt;
&lt;p&gt;刚刚几天前用了最新的1.14.2，前几月还用1.12.几，还有漏洞，nginx的发展也不慢。&lt;/p&gt;
&lt;p&gt;细细看，功能还不少：反向代理、rewrite、缓存等等。学习起来真的不比tomcat简单，反而更难，特别如果用lua开发，基于openresty。&lt;/p&gt;
&lt;h2 id=&quot;keepalived&quot;&gt;keepalived&lt;/h2&gt;
&lt;p&gt;开始弄，走了不少弯路。keepalived+nginx是最成熟的方案了吧，如果不用F5硬件负载的话。keepalived相对简单很多，只要掌握了虚拟ip，和防火墙的配置注意事项。今年终于用上了这个不算新的技术，不错。&lt;/p&gt;
&lt;h2 id=&quot;tomcatjettyundertow&quot;&gt;tomcat、jetty、undertow&lt;/h2&gt;
&lt;p&gt;spring boot默认支持的三剑客。既然必须要用tomcat，那weblogic和Websphere就可以歇歇了。我真正需要拿起多年的tomcat6的书籍看看。虽然我在用的是tomcat9。&lt;/p&gt;
&lt;p&gt;session共享是用tomcat cluster配置，还是用更高效的redis？都和Weblogic差别很大。&lt;/p&gt;
&lt;p&gt;基于nio和少占用内存，undertow和jetty也是可以尝试。谢谢阿里的许进和&lt;a href=&quot;https://me.csdn.net/rickiyeat&quot;&gt;Lovnx&lt;/a&gt;他们给我的一点提示。&lt;/p&gt;

&lt;h2 id=&quot;java8&quot;&gt;java8&lt;/h2&gt;
&lt;p&gt;终于用上java8了，不容易。原因大概就是spring cloud不支持java6。既然升，没理由只升到7而已。可惜oracle马上就说java8要收费。总不能停留在java8的某一个小版本吧？&lt;/p&gt;
&lt;p&gt;公司也许会找人基于openjdk来一个的，我觉得。会不会找我呢？&lt;/p&gt;
&lt;p&gt;或者改用go？net?不太可能。改了也没啥，我也挺有兴趣。&lt;/p&gt;
&lt;p&gt;java8的lambda很有意思，在多线程、集合和打印日志都尝试了，调试是一个麻烦事。java9和java10是不是都不太火？&lt;/p&gt;
&lt;h2 id=&quot;python&quot;&gt;python&lt;/h2&gt;
&lt;p&gt;大家搞机器学习和深度学习的都在谈论，但我们也有人用来shell。是的，也是一个不错的选择，我也这么干了。比写shell舒服很多。解析性的语言学习成本极低。适合搞数学的人拿来就用。&lt;/p&gt;
&lt;p&gt;但是安装包是一个非常麻烦的事情，jar简单很多。python2和python3也在各个平台不一样。&lt;/p&gt;
&lt;h2 id=&quot;es6nodejs&quot;&gt;es6、nodejs&lt;/h2&gt;
&lt;p&gt;代码里大家写的各种let、const、imort、require开始时把我搞晕了，我技术太差，要不断学习。&lt;br/&gt;本来想把nodejs放在web服务器里写，想想又感觉不对。还是放这。&lt;br/&gt;也许是nodejs推动了es6吧？如果没有了nodejs的出现会怎样？npm、webpack这些还会不会出现呢？不知道。我只知道es6里的promise、暂时性死区等等很难理解，要不断看书。&lt;/p&gt;

&lt;p&gt;这两年越来越重要。几年前是很少听见https的，所以传统的、技术落后的公司，也不会错过https的技术浪潮。安全很重要。&lt;/p&gt;
&lt;p&gt;买证书、在nginx上配置；又或者用jdk、openssl等生成自签名。很好玩。&lt;/p&gt;
&lt;p&gt;加密的领域，国内慢慢起来了，国密不比什么aes、rsa差，中国人的数学本来就很好。就看规范、标准的制定和推广策略行不行了。&lt;/p&gt;
&lt;p&gt;我用sm4写了一个jar，晚点打算用android里很流行的混淆技术用Intellij混淆成abc；又用oracle写了一个基于aes+填充标准5的别人看不见我源码的function，感觉很神秘嘛。可惜oracle里没有国密。&lt;/p&gt;

&lt;p&gt;开始搞敏捷了。很痛苦。天天晨会，却没有scrum里的8小时，也没有xp里的两个人一起写代码可以偷偷懒。唉：）&lt;/p&gt;

&lt;h2 id=&quot;jenkins&quot;&gt;jenkins&lt;/h2&gt;
&lt;p&gt;好像开始用了，但是我等了一年，这位同事还没有帮我配置好，没看到。&lt;/p&gt;
&lt;h2 id=&quot;sonar&quot;&gt;sonar&lt;/h2&gt;
&lt;p&gt;一样，白等了一年。&lt;/p&gt;
&lt;h2 id=&quot;mavennexus&quot;&gt;maven、nexus&lt;/h2&gt;
&lt;p&gt;早就用了，今年算是平民化了。Gradle算是颓下去吧？业界感觉势头不行的？&lt;br/&gt;nexus各团队也搭建不少。&lt;br/&gt;maven我感觉自己精通了，其实还有很多不会的。&lt;/p&gt;
&lt;h2 id=&quot;git&quot;&gt;git&lt;/h2&gt;
&lt;p&gt;开始替代svn了。搭建了各种各种的gitlab。[git]，这个读音大家要读正确哦。&lt;/p&gt;
&lt;h2 id=&quot;持续集成&quot;&gt;持续集成&lt;/h2&gt;
&lt;p&gt;没看到，估计在某个团队的某个角落里运行中。但没有喇叭吓我，没有可视化屏幕。&lt;/p&gt;
&lt;p&gt;这些东东放devops不知道对不对，放在没地方放，放这把。我对这些没啥兴趣，几年前都弄过了，也没什么技术含量。&lt;/p&gt;

&lt;p&gt;没有不在用的吧？但我却还不会。我对自己说：Danni，你要赶紧学啊。是的。&lt;br/&gt;不然一下子要发布100台机器怎么办？赶紧看看前天同事写好发我的dockerfile。&lt;br/&gt;年初我就不应该傻傻的写scp的shell，也不应该直接用eureka的rest api来启停发布。&lt;br/&gt;mesos、k8s这些对我更陌生，下一步再说。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我只是一个小小的程序员，也许看到的只是公司的冰山一角。可能还有更多更多的技术变迁。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;&lt;li&gt;设计模式&amp;amp;UML：像难驯服的马，又像深奥的佛学，总是用过了又不记得了，除了最简单的策略模式。不过，今年我还是成功用到了命令模式、模板方法模式、门面（外观）模式、适配器模式。简单工厂就不算了。&lt;/li&gt;
&lt;li&gt;分布式：大并发时还是不太会。&lt;/li&gt;
&lt;li&gt;sso：用的cas，很难，记不住。但是多看几次，也就那样了。&lt;/li&gt;
&lt;li&gt;MAC、工具：Windows转向mac了。eclispe也转向idea，webstorm了。学会postman、jmeter。&lt;/li&gt;
&lt;li&gt;JUnit：在spring和mybatis里应用自如了，但现在好像又忘了。。。&lt;/li&gt;
&lt;li&gt;工作流（ExtJS、DWR）：前阵子放下了，没搞了。太老的技术。。&lt;/li&gt;
&lt;li&gt;TCP/IP、http：想不到这些基础技术还是很有用。比如：https里从哪一步开始加密？加密哪些数据？&lt;/li&gt;
&lt;li&gt;Gitee：比github快太多，如果不是和世界接轨，我都不想用github。&lt;/li&gt;
&lt;li&gt;微信小程序、公众号、app、H5：玩玩就好，我不是搞这个的。不过H5和css3还是要弄。&lt;/li&gt;
&lt;li&gt;json、日志：忘了这个了，虽然是个小东西，但是fastjson、gson、jackson、net.sf等，slf4j、logback、log4j2等。还不少东西。&lt;/li&gt;
&lt;li&gt;数学：想不到还挺重要。特别加密、机器学习里。特别线性代数。&lt;/li&gt;
&lt;li&gt;区块链、机器/深度学习、spark：看看书就好，留给公司的专职去弄，有个同事说spark很好用。看那个马上出版的《程序员2018》也许继续会有。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/720375/201812/720375-20181231181014701-1125553976.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;立flag&quot;&gt;2019立flag&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;学docker，用起来&lt;/li&gt;
&lt;li&gt;写vuejs代码，有空试试vscode，webstorm老卡和闪退&lt;/li&gt;
&lt;li&gt;写redis（+protobuf）和kafka代码&lt;/li&gt;
&lt;li&gt;学国内的开源框架/组件，支持一下国内。什么dubbo、layui、element、iview、mybatisplus，啥都行。&lt;/li&gt;
&lt;li&gt;大并发、分布式&lt;/li&gt;
&lt;li&gt;同事玩EDAS和HSF好像很厉害，要多参与下&lt;/li&gt;
&lt;li&gt;好像怎么明年目标这么小？算了，还得帮公司干活呢，也不能白养我，不能只顾着学习的。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;希望这个flag能进到===true的代码分支吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2018.12.31 下午 Danni3 于家中&lt;/p&gt;
</description>
<pubDate>Mon, 31 Dec 2018 10:15:00 +0000</pubDate>
<dc:creator>Danni3</dc:creator>
<og:description>[TOC] 前言 今天是2018年的最后一天，独自一人关上房门，静坐回想一年来的总总，当作总结吧。 作为传统的it公司，不是互联网企业，能逐渐转型到各种流行的技术，不容易。如果刚好看到此文章的您是互联</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ouyida3/p/10201478.html</dc:identifier>
</item>
<item>
<title>2018-行远自迩，登高自卑 - 运维咖啡吧</title>
<link>http://www.cnblogs.com/37Y37/p/10202641.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/37Y37/p/10202641.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;风起于青萍之末，浪成于微澜之间&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想必运营自己的Blog是每个技术人的梦想。&lt;/p&gt;
&lt;p&gt;自6月27日申请微信公众号以来，累计发表原创技术文章25篇，绝大多数文章都有被专业技术社区转载或推荐，同时也收到多名读者的私下致谢，深感荣幸。&lt;/p&gt;
&lt;p&gt;这些文章不仅方便了他人，更成就了自己。曾经有两次在第三方技术社区开通Blog，但都没能坚持下去，技术人不服输的性格怎么能轻易放弃，于是整理衣襟重新出发，从7月3日发表第一篇文章以来一直写到现在，并且还会继续写下去。&lt;/p&gt;
&lt;p&gt;本着负责的态度，我不会简单复制网上的内容填充于文章，每一行文字都会仔细斟酌，每一行代码都会运行验证。写文并非易事，往往是写之前觉得对一个知识掌握了，可以写出来分享他人，但在写的过程中还是需要花时间查更多的资料，研究相关联的知识，推敲验证，生怕写了差错误人子弟，最终发表完成就会发现对这个知识有了更深的认识，奈何自己能力有限，即便这样也不敢保证内容完全正确，只希望对阅读的人少些误导，也算对自己的每一行文字每一行代码负责。&lt;/p&gt;
&lt;p&gt;使用公众号作为主要输出平台，还是看重公众号方便分享，保护原创。我希望我的公众号粉丝都是因为我的文章对自己有帮助才关注的，都是一群有理想有追求的技术人，所以我不会单纯为了增长粉丝做任何像关注送书转发抽奖之类的活动，怀着最大的敬意，尽量不去打扰。我写你看，能有收获，仅此而已，最好。&lt;/p&gt;
&lt;p&gt;公众号文章没有列表，不方便查看，为此我用github pages做了个主页，里边会有我写的所有文章，也方便你在电脑端查看，点击最后阅读原文可以直接跳转。公众号用了一句slogan，“追求技术的道路上，我从不曾停下脚步”，这也是我工作这么多年不敢放下的，尽管工作内容，职位都有变化，但对技术的学习和追求从来没有放下。&lt;/p&gt;
&lt;p&gt;将我这半年来写的文章分类放在下边，自取感兴趣的阅读&lt;/p&gt;
&lt;h5 id=&quot;devops系列&quot;&gt;DevOps系列&lt;/h5&gt;
&lt;h5 id=&quot;elk系列&quot;&gt;ELK系列&lt;/h5&gt;
&lt;h5 id=&quot;python系列&quot;&gt;Python系列&lt;/h5&gt;
&lt;h5 id=&quot;django系列&quot;&gt;Django系列&lt;/h5&gt;
&lt;h5 id=&quot;ldap系列&quot;&gt;LDAP系列&lt;/h5&gt;
&lt;p&gt;最后愿各位都能在2019年&lt;strong&gt;头发浓密&lt;/strong&gt;，&lt;strong&gt;睡眠良好&lt;/strong&gt;，&lt;strong&gt;情绪稳定&lt;/strong&gt;，&lt;strong&gt;财富自由&lt;/strong&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/31/16803b097761fc8c?w=430&amp;amp;h=475&amp;amp;f=png&amp;amp;s=61555&quot; alt=&quot;长按关注公众号查看更多原创文章&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 31 Dec 2018 09:58:00 +0000</pubDate>
<dc:creator>运维咖啡吧</dc:creator>
<og:description>风起于青萍之末，浪成于微澜之间 想必运营自己的Blog是每个技术人的梦想。 自6月27日申请微信公众号以来，累计发表原创技术文章25篇，绝大多数文章都有被专业技术社区转载或推荐，同时也收到多名读者的私</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/37Y37/p/10202641.html</dc:identifier>
</item>
<item>
<title>我的2018：OCR、实习和秋招 - Madcola</title>
<link>http://www.cnblogs.com/skyfsm/p/10202575.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/skyfsm/p/10202575.html</guid>
<description>&lt;p&gt;真的是光阴似箭，好像昨天还沉浸在考研成功的喜悦，今天却要即将步入2019年，即将硕士毕业。老规矩，还是在每一年的最后一天总结今年以及展望明年。回首2018，经历的东西特别多，视野也开阔了不少，可以说，2018是丰收的一年。如果用三个关键词来描述我的2018，那无疑是：OCR、实习和秋招。&lt;/p&gt;
&lt;p&gt;2018是研究生成长极快的一年，年初把研一上学期一直专注的研究整理成两个发明专利并成功公开，算是很早就达到了学院的毕业要求，所以在接下来的研究生生涯里可以花更多的时间放在自己感兴趣的领域深入探索，以及可以有充足的时间尝试新的想法。在研究生初期一直在专研传统计算机视觉的东西，无论是图像拼接还是图像特征点，都是偏向于传统方法。研究生中期逐渐转向了深度学习，尤其一直专注于OCR领域，并在这个领域探索了不少时间，从文本检测到文字识别，再到端到端的文本识别，再到近期研究的特定领域的文字识别。OCR构成了我2018研究生生涯的关键词，基本的精力都放在这里了，这期间也在博客园写了不少关于OCR的文章，貌似反响也不错。现在比较大的想法是，OCR近年来的进展非常迅猛，是在一些特定场景落地的好时期，刚好自己也在文字识别这个方向有所积累，所以也想把OCR技术应用到一些生活场景中，解决生活中的一些难题。12月也是我毕业论文开题的时间点，我也毫不犹豫地选择了OCR算法研究作为我的毕业论文方向，我觉得，我的研究生生涯如果以OCR算法研究来作为我的研究生标签的话那真是十分贴切了。&lt;/p&gt;
&lt;p&gt;2018年是忙碌的一年，因为专硕时间非常紧，基本需要一年内完成研究成果的发布、实习和秋招找工作，另一年一般用于基本的上课修学分以及毕业论文和答辩。所以2018年就是一个忙碌的年份，因为这一年我除了要尽早给出研究成果外，还需要完成实习和秋招两件大事。今年实习招聘很早，我大概二月底就开始找暑假实习了，因为一开始没什么经验，面试什么的基本都翻车，后面掌握套路了，面试起来越来有信心，基础知识也越面越牢固，接下来接陆续收到一些offer，后面刚好也收获了Intel中国研究中心的实习offer，跟经理讨论了实习的内容，感觉非常有趣，后面就直接接受了。&lt;/p&gt;
&lt;p&gt;后面5月到9月一直在北京英特尔实习，实习期间过得非常愉快，与一群厉害的研究员和工程师工作，真是受益匪浅。因为实习期间也刚好是秋招提前批开始的时间点，所以我也在7月底开始着手准备秋招提前批的知识储备。一边实习一边找工作真是压力很大，还有的时候实验室导师也找我做点研究，所以那段时真的是黑暗岁月，真的非常累。想起8月份那段时间经常实习时写写代码被打电话过来面试，然后匆匆忙忙去电梯间接电话面试，还是相当窘迫，不过没办法，大家都是这么过来的哈哈。秋招找工作相对于春招找实习真的是简单太多了，第一是因为有了春招实习面试的经验，秋招面试完全不虚，有套路可循，而且8月时自己的知识储备更加充分了，自信满满；第二是有了Intel的实习经历，在跟面试官介绍时也有了十足的话题。所以我在在8月各大公司的提前批招聘时基本都收获了不少不错offer，后面正式秋招都基本没参与了，所以所谓的金九银十我也没太多想法。&lt;/p&gt;
&lt;p&gt;在这个秋招阶段一共收获了8个offer：在8月提前批大潮时已经收获了腾讯、快手、360、VIVO和平安的offer，9月结束Intel的实习回到学校继续学业，然后整个月基本处于划水阶段，然后只收获了AI独角兽地平线的算法岗offer（这种小而精的公司面试真难，五轮狂轰乱炸）。10月某个早上我在Intel的经理打电话给我高兴地通知我他为我申请到了return offer，真是振奋人心的消息！10月底，刚好看到宝洁IT管培生的招聘，这里想说说这段有趣的经历。本来是不考虑非互联网企业，后面因为有个朋友一直很想去宝洁当管培生，而且我了解宝洁这家公司后，也被这家公司圈粉了，福利和管培生培养制度都属于业界翘楚。后面我也觉得要不试试世界500强的管培生，锻炼锻炼技术之外的技能？我的英语口语很渣，但我竟敢紧张练习英语口语几天，就去宝洁广州总部面试了。这种世界顶级传统企业在招聘上并不会太关注你的技术有多强，更多关注的是你的领导能力和综合素质，考察的方面非常多，第一轮直属经理对你面试，对英语口语对你项目领导能力进行考察，看重你解决问题能力；第二轮是宝洁三个不同部门的总监对你轮番发问，全程高压问答一小时，专业技术知识考察和项目解决能力的考察依然是重点，当然英语问答还是少不了的，英语问答还是用我的蹩脚广东英语回答了一下，场面一度非常尴尬。但是后面还是收获了宝洁的IT管培生offer，也算是对我的一个综合能力的一个肯定吧！&lt;/p&gt;
&lt;p&gt;回想2018，真的经历了很多事情，忙碌却非常充实，感觉一年时间很短，但成长又很多。3月跟随自动驾驶团队到了常熟进行了15天的上线前的研发调试，通宵达旦最后把自动驾驶最新版本成功上线，新闻发布会演示非常顺利；4月找实习，经历各种失败各种心态崩溃又不断自我调节，最后选择入职英特尔；5至9月在北京开启实习生生活，在公司里遇到一群非常优秀的同事，见到规范化的项目开发流程，学习到了书本学不到的各种技术；在生活里也认识一群好玩优秀的小伙伴，让我在北京的生活丰富多彩；8到10月秋招旅程，虽然刚开始很苦，但一路都比较顺利，最后也得到了理想公司的赏识；11到12月开始帮助导师负责新的项目，又是一个新的挑战，同时毕业论文正式开题，硕士毕业答辩似乎在向我招手了。&lt;/p&gt;
&lt;p&gt;特意找来上一年写的2017总结里面定的2018计划，看看实现了多少：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2018的展望：
1.找个好工作，发个好paper，就是2018最大的愿望。   // 工作找好了，paper放在2019发，2018发了专利，获得了毕业条件
2.博客坚持写，不断总结不断提高。  // 这个还在坚持
3.在github上认真搞一个好project，拿些星星。 // 大突破，贡献了几个好项目
4.把现在的项目做好，顺利上线。 // 基本完成吧
5.坚持读经典课外书，坚持体育锻炼，综合素质比什么都重要。  //看书和锻炼都有在坚持
6.好好搞个大比赛，上次没拿到奖，这次争取拿到！ //2018没有参加比赛了，感觉比赛对我的吸引力不是太强，太忙了&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说一说2018最富有成就感的事情吧&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;去了Intel实习&lt;/li&gt;
&lt;li&gt;在北京结识到一群优秀有趣的朋友&lt;/li&gt;
&lt;li&gt;找到了理想的工作&lt;/li&gt;
&lt;li&gt;博客一直坚持更新，虽然更新频率不高，但是还是会坚持的，现在技术博客的粉丝突破了800，阅读量也超过50W了&lt;/li&gt;
&lt;li&gt;今年在GitHub开源了几个好玩的项目，逐渐有了一百多个follwers，星星也攒了好几百&lt;/li&gt;
&lt;li&gt;收获两项发明专利&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;2018总结完了，是时候给新的一年做做计划了！&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;整理手头上的研究成果，投顶会paper&lt;/li&gt;
&lt;li&gt;顺利过论文审核，顺利过论文答辩，顺利7月毕业！！！2019的终极目标。&lt;/li&gt;
&lt;li&gt;钻研一下分布式系统，分布式计算，推荐系统的知识&lt;/li&gt;
&lt;li&gt;会在毕业论文写好以后开源两个有趣的项目：多图自动拼接算法和票据识别系统&lt;/li&gt;
&lt;li&gt;走南闯北，能顺利毕业的话，真想去台湾走一走！&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;上传几张2018有趣的照片&lt;/p&gt;
&lt;p&gt;我在Github上2018一年的活动，我是一个纯粹的程序员：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1093303/201812/1093303-20181231172436932-296509297.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我参加了阿里极客训练营，见到了大佬云风&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1093303/201812/1093303-20181231172718496-2042830847.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常熟拼命上线后，去了苏州逛了逛，夜色迷人&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1093303/201812/1093303-20181231173210049-453800975.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;某天实习下班，发现天都黑了，远远望去公司大楼，非常漂亮：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1093303/201812/1093303-20181231173229767-1681827300.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;北京实习时的小窝，逸成东苑，难忘的地方：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1093303/201812/1093303-20181231173255033-386868454.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 31 Dec 2018 09:34:00 +0000</pubDate>
<dc:creator>Madcola</dc:creator>
<og:description>真的是光阴似箭，好像昨天还沉浸在考研成功的喜悦，今天却要即将步入2019年，即将硕士毕业。老规矩，还是在每一年的最后一天总结今年以及展望明年。回首2018，经历的东西特别多，视野也开阔了不少，可以说，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/skyfsm/p/10202575.html</dc:identifier>
</item>
<item>
<title>Spring 详解（一）------- AOP - 海向</title>
<link>http://www.cnblogs.com/haixiang/p/10202553.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haixiang/p/10202553.html</guid>
<description>&lt;h3 id=&quot;aop-简介&quot;&gt;1. AOP 简介&lt;/h3&gt;
&lt;p&gt;​ AOP（Aspect Oriented Programming），通常称为面向切面编程。它利用一种称为&quot;横切&quot;的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为&quot;Aspect&quot;，即切面。所谓&quot;切面&quot;，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。&lt;/p&gt;
&lt;h3 id=&quot;示例需求&quot;&gt;2. 示例需求&lt;/h3&gt;
&lt;p&gt;想要为写好的 &lt;strong&gt;ArithmeticCalculator&lt;/strong&gt; 添加日志 ，即每次运算前后添加&lt;br/&gt;采用以下方法太过繁琐,修改内容需要每个跟着都修改,可维护性差&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ArithmeticCalculator {
    int add(int i, int j);
    int sub(int i, int j);

    int mul(int i, int j);
    int div(int i, int j);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyArithmeticCalculatorImp implements ArithmeticCalculator {
    public int add(int i, int j) {
        System.out.println(&quot;The method add begins with[&quot;+i+&quot;,&quot;+j+&quot;]&quot;);
        int result = i + j;
        System.out.println(&quot;The method add ends with[&quot;+result+&quot;]&quot;);
        return result;

    }

    public int sub(int i, int j) {
        System.out.println(&quot;The method sub begins with[&quot;+i+&quot;,&quot;+j+&quot;]&quot;);
        int result = i - j;
        System.out.println(&quot;The method sub ends with[&quot;+result+&quot;]&quot;);
        return result;
    }

    public int mul(int i, int j) {
        System.out.println(&quot;The method mul begins with[&quot;+i+&quot;,&quot;+j+&quot;]&quot;);
        int result = i * j;
        System.out.println(&quot;The method mul ends with[&quot;+result+&quot;]&quot;);
        return result;
    }

    public int div(int i, int j) {
        System.out.println(&quot;The method div begins with[&quot;+i+&quot;,&quot;+j+&quot;]&quot;);
        int result = i / j;
        System.out.println(&quot;The method div ends with[&quot;+result+&quot;]&quot;);
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;The method add begins with[1,2]
The method add ends with[3]
--&amp;gt;3
The method mul begins with[5,2]
The method mul ends with[10]
--&amp;gt;10&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;问题：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;代码混乱：&lt;/strong&gt;越来越多的非业务需求（日志和验证等）加入后，原有的业务方法急剧膨胀，每个方法在处理核心逻辑的同时还必须兼顾替他多个关注点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码分散：&lt;/strong&gt;以日志需求为例，只是为了满足这个单一需求，就不得不在多个模块（方法）里多次重复相同的日志代码，如果日志需求发生变化，必须修改所有模块。&lt;/p&gt;
&lt;h3 id=&quot;解决方法一使用静态代理&quot;&gt;3. 解决方法一：使用静态代理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;创建干净的实现类&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ArithmeticCalculatorImpl implements ArithmeticCalculator {
    @Override
    public int add(int i, int j) {
        return i + j;
    }
    @Override
    public int sub(int i, int j) {
        return i - j;
    }
    @Override
    public int mul(int i, int j) {
        return i * j;
    }
    @Override
    public int div(int i, int j) {
        return i / j;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;创建日志类 MyLogger&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 创建日志类
 */
public class MyLogger {
    /**
     * 入参日志
     * @param a
     * @param b
     */
    public void showParam(int a, int b) {
        System.out.println(&quot;The method add begins with[&quot;+a+&quot;,&quot;+b+&quot;]&quot;);
    }

    /**
     * 运算结果日志
     * @param result
     */
    public void showResult(int result) {
        System.out.println(&quot;The method add ends with[&quot;+3+&quot;]&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;创建静态代理类&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 代理类
 */
public class ProxyLogger implements ArithmeticCalculator {

    //目标类
    private ArithmeticCalculator target;

    //日志类
    private MyLogger logger;

    public ProxyLogger(ArithmeticCalculator target, MyLogger logger) {
        this.target = target;
        this.logger = logger;
    }
    @Override
    public int add(int i, int j) {
        logger.showParam(i, j);
        int result =  target.add(i,j);
        logger.showResult(result);
        return result;
    }
    @Override
    public int sub(int i, int j) {
        logger.showParam(i, j);
        int result =  target.sub(i,j);
        logger.showResult(result);
        return result;
    }
    @Override
    public int mul(int i, int j) {
        logger.showParam(i, j);
        int result =  target.mul(i,j);
        logger.showResult(result);
        return result;
    }
    @Override
    public int div(int i, int j) {
        logger.showParam(i, j);
        int result =  target.div(i,j);
        logger.showResult(result);
        return result;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;结果测试&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Main {
    public static void main(String[] args) {
        ArithmeticCalculator arithmeticCalculator = new ArithmeticCalculatorImpl();
        MyLogger logger = new MyLogger();
        ProxyLogger proxy = new ProxyLogger(arithmeticCalculator, logger);
        System.out.println(proxy.add(1, 9));
        System.out.println(proxy.mul(3, 3));

    }
}
/**
The method add begins with[1,9]
The method add ends with[3]
10
The method add begins with[3,3]
The method add ends with[3]
9
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这是一个很基础的静态代理，业务类 ArithmeticCalculatorImpl 只需要关注业务逻辑本身，保证了业务的重用性，这也是代理类的优点，没什么好说的。我们主要说说这样写的缺点：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，势必要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;如果接口增加一个方法，比如 ArithmeticCalculatorImpl 增加归零 changeZero(）方法，则除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 31 Dec 2018 09:24:00 +0000</pubDate>
<dc:creator>海向</dc:creator>
<og:description>1. AOP 简介 ​ AOP（Aspect Oriented Programming），通常称为面向切面编程。它利用一种称为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haixiang/p/10202553.html</dc:identifier>
</item>
</channel>
</rss>