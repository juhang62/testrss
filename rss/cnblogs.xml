<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>iOS定位权限请求时易犯的错误小结 - Dast1</title>
<link>http://www.cnblogs.com/Dast1/p/12133174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dast1/p/12133174.html</guid>
<description>&lt;h2 id=&quot;起因&quot;&gt;起因&lt;/h2&gt;
&lt;p&gt;用户群反馈app可能请求了不合适的定位权限：始终定位。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/804040/202001/804040-20200102152306053-1222080396.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到这个截图，根据经验判断可能是后台定位功能导致可能不得不请求始终定位权限。再加上之前提交审核时，苹果要求在plist文件中新增NSLocationAlwaysAndWhenInUseUsageDescription和NSLocationAlwaysUsageDescription键值对。猜测可能是对某些点的理解混淆了，因为这种用户体验的确不好。&lt;/p&gt;
&lt;h2 id=&quot;解决思路&quot;&gt;解决思路&lt;/h2&gt;
&lt;p&gt;因为此项目是前同事遗留代码，自从接手后迭代次数比较有限。于是计划根据以下步骤进行排查和验证：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;查现有代码和plist文件&lt;/li&gt;
&lt;li&gt;查官方文档&lt;/li&gt;
&lt;li&gt;改工程代码&lt;/li&gt;
&lt;li&gt;提交审核，查看邮件提醒&lt;/li&gt;
&lt;li&gt;app退入后台，查看定位信息是否输出&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;查plist文件和权限请求代码&quot;&gt;查plist文件和权限请求代码&lt;/h3&gt;
&lt;h4 id=&quot;plist文件&quot;&gt;plist文件&lt;/h4&gt;
&lt;p&gt;以下键都已加入：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;NSLocationAlwaysUsageDescription
NSLocationWhenInUseUsageDescription
NSLocationAlwaysAndWhenInUseUsageDescription&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;权限请求代码&quot;&gt;权限请求代码&lt;/h4&gt;
&lt;p&gt;全局搜索request，找到定位权限请求代码，发现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  if ([_locationManager respondsToSelector:@selector(requestWhenInUseAuthorization)]) {
            [_locationManager requestAlwaysAuthorization];
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查官方文档&quot;&gt;查官方文档&lt;/h3&gt;
&lt;h4 id=&quot;plist文件配置&quot;&gt;plist文件配置&lt;/h4&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;4.5&quot;&gt;
&lt;p&gt;NSLocationAlwaysUsageDescription&lt;/p&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;Discussion&lt;br/&gt;Use this key if your iOS app accesses location information &lt;strong&gt;in the background&lt;/strong&gt;, and you deploy to a target earlier than iOS 11. In that case, add both this key and NSLocationAlwaysAndWhenInUseUsageDescription to your app’s Info.plist file with the same message. Apps running on older versions of the OS use the message associated with NSLocationAlwaysUsageDescription, while apps running on later versions use the one assocated with NSLocationAlwaysAndWhenInUseUsageDescription.&lt;br/&gt;If your app only needs location information when in the foreground, use NSLocationWhenInUseUsageDescription instead. For more information, see Choosing the Authorization Level for Location Services.&lt;br/&gt;If you need location information in a macOS app, use NSLocationUsageDescription instead.&lt;br/&gt;Important&lt;br/&gt;This key is required if your iOS app uses APIs that access the user’s location at all times and deploys to targets earlier than iOS 11.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;NSLocationWhenInUseUsageDescription&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;Discussion&lt;br/&gt;Use this key if your iOS app accesses location information only when running in the foreground. If your app needs location information when in the background, use NSLocationAlwaysAndWhenInUseUsageDescription instead. For more information, see Choosing the Authorization Level for Location Services.&lt;br/&gt;If you need location information in a macOS app, use NSLocationUsageDescription instead.&lt;br/&gt;Important&lt;br/&gt;This key is required if your iOS app uses APIs that access the user’s location information while the app is &lt;strong&gt;running in the foreground&lt;/strong&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;3.5&quot;&gt;
&lt;p&gt;NSLocationAlwaysAndWhenInUseUsageDescription&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;Discussion&lt;br/&gt;Use this key if your iOS app accesses location information &lt;strong&gt;while running in the background&lt;/strong&gt;. If your app only needs location information when in the foreground, use NSLocationWhenInUseUsageDescription instead. For more information, see Choosing the Authorization Level for Location Services.&lt;br/&gt;If you need location information in a macOS app, use NSLocationUsageDescription instead. If your iOS app deploys to versions earlier than iOS 11, see NSLocationAlwaysUsageDescription.&lt;br/&gt;Important&lt;br/&gt;This key is required if your iOS app uses APIs that access the user’s location information at all times.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对比可知：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果app需要前台运行定位权限，需要配置NSLocationWhenInUseUsageDescription；&lt;/li&gt;
&lt;li&gt;如果app需要后台运行定位权限，需要配置NSLocationAlwaysAndWhenInUseUsageDescription；如果适配iOS11之前版本，还需要配置NSLocationAlwaysUsageDescription&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这几种键的区别主要在于区分app &lt;strong&gt;前后台运行&lt;/strong&gt; 时的权限配置。&lt;/p&gt;
&lt;h4 id=&quot;权限请求代码-1&quot;&gt;权限请求代码&lt;/h4&gt;
&lt;p&gt;requestAlwaysAuthorization&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;When the user grants “Always” authorization to your app, your app can start any of the available location services while your app is running in the foreground or background. In addition, services that allow your app to be launched in the background continue to do so.&lt;br/&gt;Important&lt;br/&gt;Requesting “Always” authorization &lt;strong&gt;is discouraged&lt;/strong&gt; because of the potential negative impacts to user privacy. You should request this level of authorization only when doing so offers a genuine benefit to the user.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;requestWhenInUseAuthorization&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;You must call this method or the requestAlwaysAuthorization()method prior to using location services. If the user grants “when-in-use” authorization to your app, your app can start most (but not all) location services while it is in the foreground. (Apps cannot use any services that automatically relaunch the app, such as region monitoring or the significant location change service.) When started in the foreground, services continue to run in the background if your app has &lt;strong&gt;enabled background location updates in the Capabilities tab of your Xcode project&lt;/strong&gt;. Attempts to start location services while your app is running in the background will fail. The system displays a location-services indicator in the status bar when your app moves to the background with active location services.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方建议：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;The type of authorization (“when-in-use” or “always”) that you request determines which location services your app can access and when it can use them:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;When-in-use authorization. Your app can use most services but cannot use services that automatically relaunch the app. Your app must always start services while running in the foreground. If you enable the background location capability for your app, a suspended app will wake in the background to handle location events. However, if your app is not running, it will not be launched.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Always authorization. Your app can use all location services, and it can start those services from either the foreground or the background. If a location-related event occurs when your app is not running, the system launches your app and delivers the event.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;官方更详细说明：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/804040/202001/804040-20200102152352216-790691810.png&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;https://developer.apple.com/documentation/corelocation/choosing_the_location_services_authorization_to_request&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;改工程代码&quot;&gt;改工程代码&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;保持plist配置不变&lt;/li&gt;
&lt;li&gt;修复请求方法：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;  if ([_locationManager respondsToSelector:@selector(requestWhenInUseAuthorization)]) {
            [_locationManager requestWhenInUseAuthorization];
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;提交审核查看邮件提醒&quot;&gt;提交审核，查看邮件提醒&lt;/h3&gt;
&lt;p&gt;新增version，打包上传，查看邮件提醒：并未提及定位权限有何问题。&lt;/p&gt;
&lt;h3 id=&quot;app退入后台查看定位信息是否输出&quot;&gt;app退入后台，查看定位信息是否输出&lt;/h3&gt;
&lt;p&gt;为验证app退到后台依旧可以定位，故实测退到后台后，gps回调方法中log是否持续输出，结果：会！&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;plist权限配置的定义和通过代码请求权限不是绝对的一一对应关系，容易被误解，前同事也是在这个地方混淆了。这也是本bug出现的根本原因。&lt;br/&gt;以后遇到类似易混淆概念，还是查好多篇相关官方文档，并充分理解后再写代码比较好。关于本知识点，网上有的教程可能会混淆，请注意鉴别。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;让我们杜绝浅尝辄止，追求精益求精！&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 03 Jan 2020 00:58:00 +0000</pubDate>
<dc:creator>Dast1</dc:creator>
<og:description>起因 用户群反馈app可能请求了不合适的定位权限：始终定位。 看到这个截图，根据经验判断可能是后台定位功能导致可能不得不请求始终定位权限。再加上之前提交审核时，苹果要求在plist文件中新增NSLoc</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dast1/p/12133174.html</dc:identifier>
</item>
<item>
<title>为什么在做微服务设计的时候需要DDD？ - 张飞洪[厦门]</title>
<link>http://www.cnblogs.com/jackyfei/p/12089123.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jackyfei/p/12089123.html</guid>
<description>&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;记得之前在规划和设计微服务架构的时候，张队长给了我一个至今依然记忆深刻的提示：『你的设计蓝图里为什么没有看到DDD的影子呢？』&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;随着对充血模型的领域认知的加深，我越加感觉到DDD的重要性。但是DDD内容繁多，是不是要深入去了解呢，我觉得不必入坑太深，个人浅见，它最核心的一点就是针对贫血模型的不足而设计，把原先传统的贫血模型里的业务逻辑层拎出来，融入到Domain层，这样面对复杂业务的规模化变更，我们只需要专注于Domain即可。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;　　回到主题，我们要了解的是微服务和DDD到底有什么关系呢？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因为在互联网时代，软件所面临的问题域比以往要复杂得多，这种复杂性来源于不断扩展的问题域自身，也来源于创新变化，以及这种规模性增长所带来的挑战。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　然而一个人一个团队，他对复杂的事物的认知是有极限的，面对这种复杂问题唯一的方法就是分而治之。分主要考虑的是如何去分；治意味着分出来的每一个部分要能够独立的运行，能够互相的协作，完成整体的目标，能够一来应对外部变化所带来的冲击。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      微服务架构在分和治两个方面都给出了很好的理论指导和最佳实践，那微服务是不是解决复杂问题的银弹呢？其实不然，很多团队在应用了微服务架构来构建他们的系统以后，发现并没有完全解决这种复杂性问题，甚至还带来了一些其他的问题。比如服务并&lt;span&gt;&lt;strong&gt;没有解决复杂系统如何应对需求变化这个问题&lt;/strong&gt;&lt;/span&gt;，甚至还加剧了这个问题。当一个需求变化了，需要花大量的精力去识别这个变化影响到了哪些微服务，这些服务的多个团队之间，需要通过无休止的扯皮去决定&lt;strong&gt;&lt;span&gt;哪个服务多一些，哪些服务少改一些&lt;/span&gt;&lt;/strong&gt;，然后测试团队还需要做昂贵的这种联调测试，即便如此呢，开发团队依然不放心，还要通过一系列的开关控制，小心翼翼的去做切流，去做灰度发布。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      从业务层面来看，微服务架构没有避免这种散弹式的修改。甚至反而加重了他，这是为什么呢？一个重要的原因是得微服务架构在分的纬度考虑的并不全面。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      当我们去做分的这种工作的时候，具体拆分详见我的另外一篇文章《&lt;a href=&quot;https://www.cnblogs.com/jackyfei/p/10856427.html&quot; target=&quot;_blank&quot;&gt;微服务的拆分姿势&lt;/a&gt;》，需要考虑哪些维度呢？我觉得我们至少要考虑三个维度：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;功能纬度&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;质量纬度，比如性能，可用性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;工程纬度&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;      微服务对第2个给出了很好的指导，对第3个也给出了一些建议。但是，&lt;span&gt;&lt;strong&gt;对第1个功能纬度只给出来非常有限的指导&lt;/strong&gt;&lt;/span&gt;，就是为什么随着微服务的流行，领域驱动设计(DDD)又被重新重视起来的原因。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      DDD弥补了微服务在&lt;span&gt;&lt;strong&gt;功能划分&lt;/strong&gt;&lt;/span&gt;方面没有给出很好指导的缺陷。所以他们在面对复杂问题和构建系统时候是一种&lt;strong&gt;&lt;span&gt;互补&lt;/span&gt;&lt;/strong&gt;的关系，在系统拆分的时候可以很好的协作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      只是他们看待系统拆分这个角度是不同的。微服务当中的服务所关注的范围正是DDD所推崇的六边形架构中的领域层。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/127185/201912/127185-20191223231629755-1652397724.png&quot; alt=&quot;&quot; width=&quot;300&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt;接下来结合DDD和微服务来拆分一个复杂系统。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;关于领域&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;      &lt;/strong&gt;我们称企业的&lt;span&gt;&lt;strong&gt;业务范围&lt;/strong&gt;&lt;/span&gt;和在这个范围里进行的&lt;span&gt;&lt;strong&gt;活动&lt;/strong&gt;&lt;/span&gt;为领域，和软件系统无关。领域会分成多个子域，比如我们一个电商系统，会有：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;商品子域&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;订单子域&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;库存子域等等。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;      在不同的子域里，不同的概念有不同的含义。所以我们在进行领域建模的时候，必须要有一个明确的&lt;span&gt;&lt;strong&gt;领域边界&lt;/strong&gt;&lt;/span&gt;，也就是DDD里称做的&lt;span&gt;&lt;strong&gt;限界上下文&lt;/strong&gt;&lt;/span&gt;，它是&lt;span&gt;系统内部的一个&lt;strong&gt;架构边界&lt;/strong&gt;&lt;/span&gt;，决定了这个系统架构。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;划分系统内部架构边界&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;      架构简洁之道这本书里边就说过：『系统架构是由系统的内部架构边界以及边界之间的依赖关系所决定的，与系统中各个组件之间的通信和调用的方式是无关的』。我们常说的微服务的服务调用本身只是一种比函数调用方式成本稍高的，分割应用程序行为的一种形式，系统架构无关。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      所以，复杂系统划分的&lt;span&gt;&lt;strong&gt;第一重要&lt;/strong&gt;&lt;/span&gt;的是要&lt;strong&gt;&lt;span&gt;划分内部的架构边界&lt;/span&gt;&lt;/strong&gt;，即划分清楚这个上下文，以及明确他们之间的关系，这对应于我们之前说的功能的维度。这正是DDD用武之处。其次我们才考虑基于非功能的维度如何划分，这是微服务能够发挥其优势的地方。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　举个例子，我们把系统分成ABC三个个上下文，三个上下文的代码可以在一个部署单元里运行，通过进程内调用来完成操作，这就是典型的单体架构；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/127185/201912/127185-20191223232300869-1971758250.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　也可以各自在一个独立的部署单元里运行，通过远程调用来完成操作，这就是现在流行的微服务架构。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;边界清晰的好处&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;　　我们更多的是两种架构模式的一个混合，比如A和B一起是一个部署单元，C是另外一个独立的部署单元，这种情况往往是因为C非常重要，他并发的访问量非常大，或者它的需求变更比较频繁。将C拆分出来的有以下几个好处:&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;资源倾斜&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用弹力设计模式：比如重试，熔断，降级&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;使用特殊技术：比如Go语言&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;具备独立代码库：有独立团队和运维人员，和A和B的运行期做到隔离不互相影响&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　这四点正是服务架构所关注的，它是基于非功能纬度的视角来看待拆分这件事情的，他关注的不是系统架构的逻辑边界，更多的关注的是应用程序行为的分隔。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　那为什么不把A和B都拆成一个独立的部署单元？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　这会带来更多的好处，也会带来额外的成本，架构应该是可以演进的，在业务发展的早期，应该关注系统架构的逻辑边界，保持逻辑边界的清晰和关系的正确，随着业务量的增加，逐步在做拆分，这是组合应用DDD和微服务架构带来的最大的好处。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　在单体架构中，保持架构逻辑边界不被突破是有一定难度。如果逻辑边界不清晰，在需要服务器拆分的时候，就未必能拆得出来了。另外没有人一下子就可以把逻辑边界定义正确，即使这个上下文定义的不太正确，在DDD&lt;strong&gt;&lt;span&gt;聚合根&lt;/span&gt;&lt;/strong&gt;这个概念可以保障我们能够演进出更适合的上下文。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　DDD界限上下文内部通过实体和值对象来对领域概念进行建模，&lt;strong&gt;&lt;span&gt;一组实体和值子对象归属于一个聚合根&lt;/span&gt;&lt;/strong&gt;。那按DDD要求&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;聚合根用来保证内部实体规则的正确性和数据的一致性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;外部对象只能通过ID来引用聚合根，不能引用聚合根内部的实体&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;聚合根之间不能共享一个数据库事务，它们之间的数据一致性需要通过最终的一致性来保障&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;　　有了聚合根，基于这些约束，未来可以根据需要把聚合根升级为上下文，甚至拆分成微服务都是比较容易的。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Jan 2020 00:45:00 +0000</pubDate>
<dc:creator>张飞洪[厦门]</dc:creator>
<og:description>记得之前在规划和设计微服务架构的时候，张队长给了我一个至今依然记忆深刻的提示：『你的设计蓝图里为什么没有看到DDD的影子呢？』 随着对充血模型的领域认知的加深，我越加感觉到DDD的重要性。但是DDD内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jackyfei/p/12089123.html</dc:identifier>
</item>
<item>
<title>@程序员，你们还在用网上随便找的方法导入导出Excel么，我们给你造了个轮子！！！！！ - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/12142460.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/12142460.html</guid>
<description>&lt;p&gt;有一天跟一位同事跟我闲聊，讨论起过去若干年软件行业的感受，他问了个问题：你觉得一个好的软件工程师最显著的特点是什么？&lt;/p&gt;
&lt;p&gt;我想了一会，说：大概是坐得住吧。&lt;/p&gt;
&lt;p&gt;某种意义上来说，在互联网技术飞速发展的今天，信息的洪流总是无声无息间把我们掩埋，一不小心，可能就感觉自己似乎已经out了。&lt;/p&gt;
&lt;p&gt;当然，信息有良种，也有莠子，有的信息能够让我们收获颇多，但是大部分信息其实都是八卦信息，与大家的关系并不大。&lt;/p&gt;
&lt;p&gt;然而我们依然容易沉迷于八卦信息之中，总觉得能够收获什么。其实往往就是虚度光阴。&lt;/p&gt;
&lt;p&gt;哪怕是那些专注于技术领域的大群们，也难免在某段时间过后，变成一个个水群，然后兴趣平平，不了了之。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202001/191302-20200102223520642-430084840.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;技术群里经常讨论的话题大概是某些开源轮子。尤其是.net的群，有时候遇到问题，就会有人说，要是造个某某轮子就好了，同样的东西隔壁java就有；或者是某某轮子出了个bug，然后集体声讨会开始，说作者连这么简单的问题都没考虑到；或者像ngnix卖了大价钱了，有人说，这东西我很多年前就有这个想法，要是当时就做了，那这个发财的一定就是我了。&lt;/p&gt;
&lt;p&gt;然后长沙互联网社区的胡子哥有一句口头禅特别有用：你别想这想那，想那么多什么用都没有，你倒是干啊，别老想干失败了啊，万一干成功了呢？&lt;/p&gt;
&lt;p&gt;所以在这个时代冷静的思考、时刻保持学习的态度，能够坐得住，大概是成为专业开发者的第一步。&lt;/p&gt;
&lt;p&gt;而成为专业开发者之后，通过一个开源项目来练手，一定是一个非常不错的选择，在gayhub之上，许多不同技术类型的开发者都借助平台开创了自己的品牌，他们做了一个个优秀的开源组件，既成就了自己的价值，更是帮助了大量对组件有需求的开发者。前有vue尤雨溪，后有涛思数据陶老师，他们就是中国开发者圈子中的英雄伟人。&lt;/p&gt;
&lt;p&gt;好吧，要撸一个vue.js是真的不容易，要做一个TEngine更是难上加难，那能不能挑个看起来简单的小轮子，例如excel的导入导出吧。&lt;/p&gt;
&lt;p&gt;额，看起来很简单的东西，哪里有那么简单呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202001/191302-20200102223527118-1076106269.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;造一个轮子，开头容易做好难。首先你得开始干，其次你得把事情干好，再次，你还得坚持。&lt;/p&gt;
&lt;p&gt;然后你得做个每一个单元测试，还得考虑各种极限情况，现在开发者很挑剔啦，不仅要求功能齐全，还得性能优异（虽然大部分客户不一定用的到），还得考虑多种数据格式，你还得经常解决issues上大家提出的反馈并及时的修复bug，好吧，能够把这一趟水梭完已经很不容易了。然后你把你的轮子推送到了gayhub上，难免会在一些群里做一些推广。&lt;/p&gt;
&lt;p&gt;于是你会遇到键盘侠们，他们都在吐槽说你干的这个东西：这么简单的东西，一个实习生就会干了。。当然，要让他们来干，除了从网上抄现成的代码，要自己撸，估计那几个单词怎么拼，都要花百度一下，正儿八经要把轮子造出来，估计得等十年也憋不出来了。。&lt;/p&gt;
&lt;p&gt;有一位老师说得很有道理：中国不缺喷子，不缺那些所谓有想法的，缺的是能够把想法转化成显现实的人。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202001/191302-20200102223532838-207858405.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;例如，长沙.NET社区的重要参与者李文强大佬和他的团队，就是这样一个善于把想法转换成现实的人。实际上这几个月来他们特别忙，基本上天天得特别晚才能回去，尤其是作为公司创始人的李文强，更是几乎天天都会加班到特别晚。&lt;/p&gt;
&lt;p&gt;他说他大概是一个想法特别多的人，经常会碰出许多想法，但是由于时间实在是有限，许多开源组件都开始设计得挺不错，但由于开局太大、定制能力要求太高等众多原因逐渐的无法维护，最终不了了之。&lt;/p&gt;
&lt;p&gt;这次他改变了想法，先设计一个比较易于拆卸的小轮子，实现一些基本功能，然后经过一波测试，获得了非常不错的反响，并获得了社区的认同，然后这个轮子也有幸得以成为NCC中的一个小组件。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202001/191302-20200102223622383-2084315329.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Magicodes.IE：导入导出通用库，通过导入导出DTO模型来控制导入和导出，支持Excel、Word、Pdf和Html。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这确实是个非常灵巧的小轮子，虽然看起来很简单，但是他的功能还是很实用的，我相信大部分企业级应用开发者都值得拥有。&lt;/p&gt;
&lt;p&gt;赶紧抛弃你们从网上下载的那些不靠谱的代码，把你们的Excel导入功能合并到这个小轮子上来吧！&lt;/p&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;https://github.com/dotnetcore/Magicodes.IE&quot; class=&quot;uri&quot;&gt;https://github.com/dotnetcore/Magicodes.IE&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;记住这个名字Magicodes.IE，Fork 一波，然后Star一波。。人生精彩从这里开始！。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/191302/202001/191302-20200102223629565-1629162176.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;能看到这里的都是最优秀的程序员，升职加薪就是你了&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 03 Jan 2020 00:24:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>程序员的显著特点 有一天跟一位同事跟我闲聊，讨论起过去若干年软件行业的感受，他问了个问题：你觉得一个好的软件工程师最显著的特点是什么？ 我想了一会，说：大概是坐得住吧。 某种意义上来说，在互联网技术飞</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/12142460.html</dc:identifier>
</item>
<item>
<title>面试官刁难：Java字符串可以引用传递吗？ - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12143003.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12143003.html</guid>
<description>&lt;p&gt;老读者都知道了，六年前，我从苏州回到洛阳，抱着一幅“海归”的心态，投了不少简历，也“约谈”了不少面试官，但仅有两三个令我感到满意。其中有一位叫老马，至今还活在我的手机通讯录里。他当时扔了一个面试题把我砸懵了：“&lt;strong&gt;王二，Java 字符串可以引用传递吗&lt;/strong&gt;？”&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/feoOINGSyivBO8Z1gaQVOA&quot;&gt;我&lt;/a&gt;当时二十三岁，正值青春年华，从事 Java 编程已有 N 年经验（N &amp;lt; 4），自认为所有的面试题都能对答如流，结果没想到啊，被“刁难”了——原来洛阳这块互联网的荒漠也有技术专家啊。现在回想起来，脸上不自觉地泛起了羞愧的红晕：主要是自己当时太菜了。不管怎么说，是时候写篇文章剖析一下字符串是否可以引用传递了。&lt;/p&gt;
&lt;p&gt;对于绝大多数的初级程序员或者说不重视“内功”的老鸟来说，往往停留在“知其然不知其所以然”的层面上——会用，略知一二，但要求他把问题说清楚的时候，就只能挠挠头双手一摊一张问号脸了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-string-reference-pass-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;好了，让我们来步入正题。先来看一段有趣但令人困惑的代码片段吧。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;String x = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; String(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;change(x);&lt;br/&gt;System.out.println(x);&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;x = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王三&quot;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码的字面逻辑来看，程序应该输出“沉默王三”，但事与愿违，程序输出的结果却是“沉默王二”。&lt;code&gt;change()&lt;/code&gt; 方法做的是无用功，因为 String 是值传递而不是引用传递。引用传递可以在被调用的方法中对实参进行修改，但值传递却不可以。为什么呢？&lt;/p&gt;
&lt;p&gt;x 存储的是一个引用，该引用指向内存中的“沉默王二”字符串对象。当我们把 x 作为参数传递给 &lt;code&gt;change()&lt;/code&gt; 方法时，x 仍然指向的是内存中“沉默王二”字符串，就像下面这幅图表达的意思一样。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-string-reference-pass-02.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;那么问题来了。正因为 Java 是值传递，x 的值是“沉默王二”的引用。那么当 &lt;code&gt;change()&lt;/code&gt; 方法被调用的时候，x 不是刚好指向了内存中新创建的字符串对象“沉默王三”了吗？就像下面这幅图表达的意思那样。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-string-reference-pass-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;哦，看起来是一个很完美的解释，对吧？但这样的解释存在一些问题。&lt;/p&gt;
&lt;p&gt;当字符串“沉默王二”被创建的时候，Java 会在内存中申请一小段空间，用来存储这个字符串对象。然后呢，把对象的引用指向了变量 x，也就是说，变量 x 实际上存储的是对象的引用（对象在内存中存储的地址）。&lt;/p&gt;
&lt;p&gt;我相信大家对上面这一点（对象和对象引用）已经完全理解了。&lt;/p&gt;
&lt;p&gt;关键的点来了。当变量 x 作为参数（实参）传递给 &lt;code&gt;change()&lt;/code&gt; 方法时，实际上传递的是 x 的一个拷贝（形参）。在 &lt;code&gt;change()&lt;/code&gt; 方法中，形参 x 起先引用的也是“沉默王二”这个对象，当执行 &lt;code&gt;x = &quot;沉默王三&quot;&lt;/code&gt; 的时候，会在内存中创建新的字符串“沉默王三”，然后形参 x 不再引用“沉默王二”这个对象了，改为引用“沉默王三”这个对象了。但实参 x 呢？并没有发生任何的改变！就像下面这幅图一样。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-string-reference-pass-04.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;假如我们真的需要改变字符串呢？那就不能使用 String 类了，最好使用 StringBuilder，来撸一串代码吧。&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;StringBuilder x = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StringBuilder(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;change(x);&lt;br/&gt;System.out.println(x);&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(StringBuilder x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;x.delete(&lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;,&lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt;).append(&lt;span class=&quot;hljs-string&quot;&gt;&quot;三&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码会输出“沉默王三”，但假如我们使用 new 关键字重新对形参 x 进行赋值，就无济于事。&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(String[] args)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;StringBuilder x = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StringBuilder(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;&lt;/span&gt;);&lt;br/&gt;change(x);&lt;br/&gt;System.out.println(x);&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;change&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(StringBuilder x)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;x = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; StringBuilder(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王三&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出的结果仍然是“沉默王二”，原因其实和 String 一样，&lt;code&gt;change()&lt;/code&gt; 方法在内存中创建了新的字符串“沉默王三”，然后形参 x 不再引用“沉默王二”这个对象，改为引用“沉默王三”这个对象了。但实参 x 并没有任何改变。&lt;/p&gt;
&lt;p&gt;看到这，有些读者可能更疑惑了。&lt;code&gt;x = new StringBuilder(&quot;沉默王三&quot;)&lt;/code&gt; 不可以改变实参，而 &lt;code&gt;x.delete(3,4).append(&quot;三&quot;)&lt;/code&gt; 却可以，为什么？为什么？为什么？为什么呢？&lt;/p&gt;
&lt;p&gt;不要着急，我们来分析一下 &lt;code&gt;delete()&lt;/code&gt; 方法的源码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; AbstractStringBuilder &lt;span class=&quot;hljs-title&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; start, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; end)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; len = end - start;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (len &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;System.arraycopy(value, start+len, value, start, count-end);&lt;br/&gt;count -= len;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中 value 是一个字符数组，用来存储字符序列；count 用来表示字符序列中实际有效的字符数量。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;count -= len&lt;/code&gt; 执行之前，value 的字符内容为“沉默王二”，count 为 4。我是怎么知道的呢？通过 &lt;a href=&quot;http://www.itwanger.com/java/2019/11/25/java-idea-community.html&quot;&gt;IDEA&lt;/a&gt; 的 debug 视图，截图为证。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-string-reference-pass-05.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;当 &lt;code&gt;count -= len&lt;/code&gt; 执行之后，value 的字符内容仍然为“沉默王二”，但 count 变成了 3。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-string-reference-pass-06.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;当鼠标停留在 this 上时，此时的字符内容为“沉默王”，也就意味着 x 当前的字符内容为“沉默王”。同样的，当我们在 &lt;code&gt;append()&lt;/code&gt; 方法上进行 debug 的时候，也可以观察到字符串发生变化的细节。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-string-reference-pass-07.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;当 &lt;code&gt;append()&lt;/code&gt; 方法执行结束后，此时形参 x 的字符内容为“沉默王三”。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-string-reference-pass-08.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;当 &lt;code&gt;change()&lt;/code&gt; 方法执行完后，此时实参 x 的字符内容为“沉默王三”。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-string-reference-pass-09.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;通过上面的源码分析，大家应该会发现另外一个事实：x 对象始终是“StringBuilder@512”，这意味着什么呢？一图胜千言，画个图大家一看就明白了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-string-reference-pass-10.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;由于形参 x 和实参 x 引用的都是同一个对象，那么 &lt;code&gt;change()&lt;/code&gt; 方法执行结束后，实参 x 的字符内容自然也就发生了变化。&lt;/p&gt;
&lt;p&gt;综上所述：Java 字符串不是引用传递而是值传递；更进一步的说，Java 只有值传递，没有引用传递。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/01/java-string-reference-pass-11.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;遥想公瑾当年，小乔初嫁了，雄姿英发。&lt;/p&gt;&lt;p&gt;羽扇纶巾，谈笑间，樯橹灰飞烟灭。&lt;/p&gt;&lt;p&gt;故国神游，多情应笑我，早生华发。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;哎，后悔啊，早年我要是能把这道面试题吃透的话，也不用被老马刁难了。另外，我想要告诉大家的是，作为程序员，我们千万不要轻视这些基础的知识点。因为基础的知识点是各种上层技术共同的基础，只有彻底地掌握了这些基础知识点，才能更好地理解程序的运行原理，做出更优化的产品。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;好了，各位读者朋友们，以上就是本文的全部内容了。&lt;strong&gt;能看到这里的都是最优秀的程序员，升职加薪就是你了&lt;/strong&gt;👍。如果觉得不过瘾，还想看到更多，可以 star 二哥的 GitHub【&lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;itwanger.github.io&lt;/a&gt;】，本文已收录。&lt;/p&gt;
&lt;p&gt;原创不易，如果觉得有点用的话，请不要吝啬你手中&lt;strong&gt;点赞&lt;/strong&gt;的权力；如果想要第一时间看到二哥更新的文章，请扫描下方的二维码，关注沉默王二公众号。我们下篇文章见！&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/cmower_4.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;</description>
<pubDate>Thu, 02 Jan 2020 22:21:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>老读者都知道了，六年前，我从苏州回到洛阳，抱着一幅“海归”的心态，投了不少简历，也“约谈”了不少面试官，但仅有两三个令我感到满意。其中有一位叫老马，至今还活在我的手机通讯录里。他当时扔了一个面试题把我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12143003.html</dc:identifier>
</item>
<item>
<title>【一起学源码-微服务】Nexflix Eureka 源码十二：EurekaServer集群模式源码分析 - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/12143004.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/12143004.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;h4 id=&quot;前情回顾&quot;&gt;前情回顾&lt;/h4&gt;
&lt;p&gt;上一讲看了Eureka 注册中心的自我保护机制，以及里面提到的bug问题。&lt;/p&gt;
&lt;p&gt;哈哈 转眼间都2020年了，这个系列的文章从12.17 一直写到现在，也是不容易哈，每天持续不断学习，输出博客，这一段时间确实收获很多。&lt;/p&gt;
&lt;p&gt;今天在公司给组内成员分享了Eureka源码剖析，反响效果还可以，也算是感觉收获了点东西。后面还会继续feign、ribbon、hystrix的源码学习，依然文章连载的形式输出。&lt;/p&gt;
&lt;h4 id=&quot;本讲目录&quot;&gt;本讲目录&lt;/h4&gt;
&lt;p&gt;本讲主要是EurekaServer集群模式的数据同步讲解，主要目录如下。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目录如下：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;eureka server集群机制&lt;/li&gt;
&lt;li&gt;注册、下线、续约的注册表同步机制&lt;/li&gt;
&lt;li&gt;注册表同步三层队列机制详解&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;技术亮点：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;3层队列机制实现注册表的批量同步需求&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;说明&quot;&gt;说明&lt;/h4&gt;
&lt;p&gt;原创不易，如若转载 请标明来源！&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;一枝花算不算浪漫&lt;/a&gt;&lt;br/&gt;微信公众号：壹枝花算不算浪漫&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;h4 id=&quot;eureka-server集群机制&quot;&gt;eureka server集群机制&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200103062115508-1016632232.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Eureka Server会在注册、下线、续约的时候进行数据同步，将信息同步到其他Eureka Server节点。&lt;/p&gt;
&lt;p&gt;可以想象到的是，这里肯定不会是实时同步的，往后继续看注册表的同步机制吧。&lt;/p&gt;
&lt;h4 id=&quot;注册下线续约的注册表同步机制&quot;&gt;注册、下线、续约的注册表同步机制&lt;/h4&gt;
&lt;p&gt;我们以Eureka Client注册为例，看看Eureka Server是如何同步给其他节点的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PeerAwareInstanceRegistryImpl.java&lt;/code&gt; :&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void register(final InstanceInfo info, final boolean isReplication) {
    int leaseDuration = Lease.DEFAULT_DURATION_IN_SECS;
    if (info.getLeaseInfo() != null &amp;amp;&amp;amp; info.getLeaseInfo().getDurationInSecs() &amp;gt; 0) {
        leaseDuration = info.getLeaseInfo().getDurationInSecs();
    }
    super.register(info, leaseDuration, isReplication);
    replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);
}

private void replicateToPeers(Action action, String appName, String id,
                                  InstanceInfo info /* optional */,
                                  InstanceStatus newStatus /* optional */, boolean isReplication) {
    Stopwatch tracer = action.getTimer().start();
    try {
        if (isReplication) {
            numberOfReplicationsLastMin.increment();
        }
        // If it is a replication already, do not replicate again as this will create a poison replication
        if (peerEurekaNodes == Collections.EMPTY_LIST || isReplication) {
            return;
        }

        for (final PeerEurekaNode node : peerEurekaNodes.getPeerEurekaNodes()) {
            // If the url represents this host, do not replicate to yourself.
            if (peerEurekaNodes.isThisMyUrl(node.getServiceUrl())) {
                continue;
            }
            replicateInstanceActionsToPeers(action, appName, id, info, newStatus, node);
        }
    } finally {
        tracer.stop();
    }
}

private void replicateInstanceActionsToPeers(Action action, String appName,
                                                 String id, InstanceInfo info, InstanceStatus newStatus,
                                                 PeerEurekaNode node) {
    try {
        InstanceInfo infoFromRegistry = null;
        CurrentRequestVersion.set(Version.V2);
        switch (action) {
            case Cancel:
                node.cancel(appName, id);
                break;
            case Heartbeat:
                InstanceStatus overriddenStatus = overriddenInstanceStatusMap.get(id);
                infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                node.heartbeat(appName, id, infoFromRegistry, overriddenStatus, false);
                break;
            case Register:
                node.register(info);
                break;
            case StatusUpdate:
                infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                node.statusUpdate(appName, id, newStatus, infoFromRegistry);
                break;
            case DeleteStatusOverride:
                infoFromRegistry = getInstanceByAppAndId(appName, id, false);
                node.deleteStatusOverride(appName, id, infoFromRegistry);
                break;
        }
    } catch (Throwable t) {
        logger.error(&quot;Cannot replicate information to {} for action {}&quot;, node.getServiceUrl(), action.name(), t);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;注册完成后，调用&lt;code&gt;replicateToPeers()&lt;/code&gt;，注意这里面有一个参数&lt;code&gt;isReplication&lt;/code&gt;，如果是true，代表是其他Eureka Server节点同步的，false则是EurekaClient注册来的。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replicateToPeers()&lt;/code&gt;中一段逻辑，如果&lt;code&gt;isReplication&lt;/code&gt;为true则直接跳出，这里意思是client注册来的服务实例需要向其他节点扩散，如果不是则不需要去同步&lt;/li&gt;
&lt;li&gt;&lt;code&gt;peerEurekaNodes.getPeerEurekaNodes()&lt;/code&gt;拿到所有的Eureka Server节点，循环遍历去同步数据，调用&lt;code&gt;replicateInstanceActionsToPeers()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;replicateInstanceActionsToPeers()&lt;/code&gt;方法中根据注册、下线、续约等去处理不同逻辑&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来就是真正执行同步逻辑的地方，这里主要用了三层队列对同步请求进行了batch操作，将请求打成一批批 然后向各个EurekaServer进行http请求。&lt;/p&gt;
&lt;h4 id=&quot;注册表同步三层队列机制详解&quot;&gt;注册表同步三层队列机制详解&lt;/h4&gt;
&lt;p&gt;到了这里就是真正进入了同步的逻辑，这里还是以上面注册逻辑为主线，接着上述代码继续往下跟：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PeerEurekaNode.java&lt;/code&gt; :&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void register(final InstanceInfo info) throws Exception {
    long expiryTime = System.currentTimeMillis() + getLeaseRenewalOf(info);
    batchingDispatcher.process(
            taskId(&quot;register&quot;, info),
            new InstanceReplicationTask(targetHost, Action.Register, info, null, true) {
                public EurekaHttpResponse&amp;lt;Void&amp;gt; execute() {
                    return replicationClient.register(info);
                }
            },
            expiryTime
    );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里会执行&lt;code&gt;batchingDispatcher.process()&lt;/code&gt; 方法，我们继续点进去，然后会进入 &lt;code&gt;TaskDispatchers.createBatchingTaskDispatcher()&lt;/code&gt; 方法，查看其中的匿名内部类中的&lt;code&gt;process()&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void process(ID id, T task, long expiryTime) {
        // 将请求都放入到acceptorQueue中
        acceptorQueue.add(new TaskHolder&amp;lt;ID, T&amp;gt;(id, task, expiryTime));
        acceptedTasks++;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将需要同步的Task数据放入到&lt;code&gt;acceptorQueue&lt;/code&gt;队列中。&lt;br/&gt;接着回到&lt;code&gt;createBatchingTaskDispatcher()&lt;/code&gt;方法中，看下&lt;code&gt;AcceptorExecutor&lt;/code&gt;，它的构造函数中会启动一个后台线程：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ThreadGroup threadGroup = new ThreadGroup(&quot;eurekaTaskExecutors&quot;);

this.acceptorThread = new Thread(threadGroup, new AcceptorRunner(), &quot;TaskAcceptor-&quot; + id);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们继续跟&lt;code&gt;AcceptorRunner.java&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class AcceptorRunner implements Runnable {
    @Override
    public void run() {
        long scheduleTime = 0;
        while (!isShutdown.get()) {
            try {
                // 处理acceptorQueue队列中的数据
                drainInputQueues();

                int totalItems = processingOrder.size();

                long now = System.currentTimeMillis();
                if (scheduleTime &amp;lt; now) {
                    scheduleTime = now + trafficShaper.transmissionDelay();
                }
                if (scheduleTime &amp;lt;= now) {
                    // 将processingOrder拆分成一个个batch，然后进行操作
                    assignBatchWork();
                    assignSingleItemWork();
                }

                // If no worker is requesting data or there is a delay injected by the traffic shaper,
                // sleep for some time to avoid tight loop.
                if (totalItems == processingOrder.size()) {
                    Thread.sleep(10);
                }
            } catch (InterruptedException ex) {
                // Ignore
            } catch (Throwable e) {
                // Safe-guard, so we never exit this loop in an uncontrolled way.
                logger.warn(&quot;Discovery AcceptorThread error&quot;, e);
            }
        }
    }

    private void drainInputQueues() throws InterruptedException {
        do {
            drainAcceptorQueue();

            if (!isShutdown.get()) {
                // If all queues are empty, block for a while on the acceptor queue
                if (reprocessQueue.isEmpty() &amp;amp;&amp;amp; acceptorQueue.isEmpty() &amp;amp;&amp;amp; pendingTasks.isEmpty()) {
                    TaskHolder&amp;lt;ID, T&amp;gt; taskHolder = acceptorQueue.poll(10, TimeUnit.MILLISECONDS);
                    if (taskHolder != null) {
                        appendTaskHolder(taskHolder);
                    }
                }
            }
        } while (!reprocessQueue.isEmpty() || !acceptorQueue.isEmpty() || pendingTasks.isEmpty());
    }

    private void drainAcceptorQueue() {
        while (!acceptorQueue.isEmpty()) {
            // 将acceptor队列中的数据放入到processingOrder队列中去，方便后续拆分成batch
            appendTaskHolder(acceptorQueue.poll());
        }
    }

    private void appendTaskHolder(TaskHolder&amp;lt;ID, T&amp;gt; taskHolder) {
        if (isFull()) {
            pendingTasks.remove(processingOrder.poll());
            queueOverflows++;
        }
        TaskHolder&amp;lt;ID, T&amp;gt; previousTask = pendingTasks.put(taskHolder.getId(), taskHolder);
        if (previousTask == null) {
            processingOrder.add(taskHolder.getId());
        } else {
            overriddenTasks++;
        }
    }
            
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;认真跟这里面的代码，可以看到这里是将上面的&lt;code&gt;acceptorQueue&lt;/code&gt;放入到&lt;code&gt;processingOrder&lt;/code&gt;, 其中&lt;code&gt;processingOrder&lt;/code&gt;也是一个队列。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;AcceptorRunner.java&lt;/code&gt;的&lt;code&gt;run()&lt;/code&gt;方法中，还会调用&lt;code&gt;assignBatchWork()&lt;/code&gt;方法，这里面就是将&lt;code&gt;processingOrder&lt;/code&gt;打成一个个batch，接着看代码：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;void assignBatchWork() {
            if (hasEnoughTasksForNextBatch()) {
                if (batchWorkRequests.tryAcquire(1)) {
                    long now = System.currentTimeMillis();
                    int len = Math.min(maxBatchingSize, processingOrder.size());
                    List&amp;lt;TaskHolder&amp;lt;ID, T&amp;gt;&amp;gt; holders = new ArrayList&amp;lt;&amp;gt;(len);
                    while (holders.size() &amp;lt; len &amp;amp;&amp;amp; !processingOrder.isEmpty()) {
                        ID id = processingOrder.poll();
                        TaskHolder&amp;lt;ID, T&amp;gt; holder = pendingTasks.remove(id);
                        if (holder.getExpiryTime() &amp;gt; now) {
                            holders.add(holder);
                        } else {
                            expiredTasks++;
                        }
                    }
                    if (holders.isEmpty()) {
                        batchWorkRequests.release();
                    } else {
                        batchSizeMetric.record(holders.size(), TimeUnit.MILLISECONDS);
                        // 将批量数据放入到batchWorkQueue中
                        batchWorkQueue.add(holders);
                    }
                }
            }
        }

        private boolean hasEnoughTasksForNextBatch() {
            if (processingOrder.isEmpty()) {
                return false;
            }
            // 默认maxBufferSize为250
            if (pendingTasks.size() &amp;gt;= maxBufferSize) {
                return true;
            }

            TaskHolder&amp;lt;ID, T&amp;gt; nextHolder = pendingTasks.get(processingOrder.peek());
            // 默认maxBatchingDelay为500ms
            long delay = System.currentTimeMillis() - nextHolder.getSubmitTimestamp();
            return delay &amp;gt;= maxBatchingDelay;
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里加入batch的规则是：&lt;code&gt;maxBufferSize&lt;/code&gt; 默认为250&lt;br/&gt;&lt;code&gt;maxBatchingDelay&lt;/code&gt; 默认为500ms，打成一个个batch后就开始发送给server端。至于怎么发送 我们接着看 &lt;code&gt;PeerEurekaNode.java&lt;/code&gt;， 我们在最开始调用&lt;code&gt;register()&lt;/code&gt;方法就是调用&lt;code&gt;PeerEurekaNode.register()&lt;/code&gt;, 我们来看看它的构造方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;PeerEurekaNode(PeerAwareInstanceRegistry registry, String targetHost, String serviceUrl,
                                     HttpReplicationClient replicationClient, EurekaServerConfig config,
                                     int batchSize, long maxBatchingDelayMs,
                                     long retrySleepTimeMs, long serverUnavailableSleepTimeMs) {
    this.registry = registry;
    this.targetHost = targetHost;
    this.replicationClient = replicationClient;

    this.serviceUrl = serviceUrl;
    this.config = config;
    this.maxProcessingDelayMs = config.getMaxTimeForReplication();

    String batcherName = getBatcherName();
    ReplicationTaskProcessor taskProcessor = new ReplicationTaskProcessor(targetHost, replicationClient);
    this.batchingDispatcher = TaskDispatchers.createBatchingTaskDispatcher(
            batcherName,
            config.getMaxElementsInPeerReplicationPool(),
            batchSize,
            config.getMaxThreadsForPeerReplication(),
            maxBatchingDelayMs,
            serverUnavailableSleepTimeMs,
            retrySleepTimeMs,
            taskProcessor
    );
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里会实例化一个&lt;code&gt;ReplicationTaskProcessor.java&lt;/code&gt;， 我们跟进去，发下它是实现&lt;code&gt;TaskProcessor&lt;/code&gt;的，所以一定会执行此类中的&lt;code&gt;process()&lt;/code&gt;方法，执行方法如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public ProcessingResult process(List&amp;lt;ReplicationTask&amp;gt; tasks) {
    ReplicationList list = createReplicationListOf(tasks);
    try {
        EurekaHttpResponse&amp;lt;ReplicationListResponse&amp;gt; response = replicationClient.submitBatchUpdates(list);
        int statusCode = response.getStatusCode();
        if (!isSuccess(statusCode)) {
            if (statusCode == 503) {
                logger.warn(&quot;Server busy (503) HTTP status code received from the peer {}; rescheduling tasks after delay&quot;, peerId);
                return ProcessingResult.Congestion;
            } else {
                // Unexpected error returned from the server. This should ideally never happen.
                logger.error(&quot;Batch update failure with HTTP status code {}; discarding {} replication tasks&quot;, statusCode, tasks.size());
                return ProcessingResult.PermanentError;
            }
        } else {
            handleBatchResponse(tasks, response.getEntity().getResponseList());
        }
    } catch (Throwable e) {
        if (isNetworkConnectException(e)) {
            logNetworkErrorSample(null, e);
            return ProcessingResult.TransientError;
        } else {
            logger.error(&quot;Not re-trying this exception because it does not seem to be a network exception&quot;, e);
            return ProcessingResult.PermanentError;
        }
    }
    return ProcessingResult.Success;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面是将&lt;code&gt;List&amp;lt;ReplicationTask&amp;gt; tasks&lt;/code&gt; 通过&lt;code&gt;submitBatchUpdate()&lt;/code&gt; 发送给server端。&lt;br/&gt;server端在&lt;code&gt;PeerReplicationResource.batchReplication()&lt;/code&gt;去处理，实际上就是循环调用&lt;code&gt;ApplicationResource.addInstance()&lt;/code&gt; 方法，又回到了最开始注册的方法。&lt;/p&gt;
&lt;p&gt;到此 EurekaServer同步的逻辑就结束了，这里主要是三层队列的数据结构很绕，通过一个batchList去批量同步数据的。&lt;/p&gt;
&lt;p&gt;注意这里还有一个很重要的点，就是Client注册时调用addInstance()方法，这里到了server端&lt;code&gt;PeerAwareInstanceRegistryImpl&lt;/code&gt;会执行同步其他EurekaServer逻辑。&lt;/p&gt;
&lt;p&gt;而EurekaServer同步注册接口仍然会调用addInstance()方法，这里难不成就死循环调用了？当然不是，addInstance()中也有个参数：&lt;code&gt;isReplication&lt;/code&gt;， 在最后调用server端方法的时候如下：&lt;code&gt;registry.register(info, &quot;true&quot;.equals(isReplication));&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;我们知道，EurekaClient在注册的时候&lt;code&gt;isReplication&lt;/code&gt;传递为空，所以这里为false，而Server端同步的时候调用：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PeerReplicationResource&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private static Builder handleRegister(ReplicationInstance instanceInfo, ApplicationResource applicationResource) {
        applicationResource.addInstance(instanceInfo.getInstanceInfo(), REPLICATION);
        return new Builder().setStatusCode(Status.OK.getStatusCode());
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;REPLICATION&lt;/code&gt; 为true&lt;/p&gt;
&lt;p&gt;另外在&lt;code&gt;AbstractJersey2EurekaHttpClient&lt;/code&gt;中发送register请求的时候，有个&lt;code&gt;addExtraHeaders()&lt;/code&gt;方法，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200103062116891-1070419267.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果是使用的&lt;code&gt;Jersey2ReplicationClient&lt;/code&gt;发送的，那么header中的&lt;code&gt;x-netflix-discovery-replication&lt;/code&gt;配置则为true，在后面执行注册的&lt;code&gt;addInstance()&lt;/code&gt;方法中会接收这个参数的：&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;仍然一图流，文中解析的内容都包含在这张图中了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200103062117279-1230211095.png&quot; alt=&quot;11_Eureka注册中心集群同步原理.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;申明&quot;&gt;申明&lt;/h3&gt;
&lt;p&gt;本文章首发自本人博客：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/&quot;&gt;https://www.cnblogs.com/wang-meng&lt;/a&gt; 和公众号：&lt;strong&gt;壹枝花算不算浪漫&lt;/strong&gt;，如若转载请标明来源!&lt;/p&gt;
&lt;p&gt;感兴趣的小伙伴可关注个人公众号：壹枝花算不算浪漫&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/202001/799093-20200103062117536-422176207.jpg&quot; alt=&quot;22.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 Jan 2020 22:21:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>Eureka</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wang-meng/p/12143004.html</dc:identifier>
</item>
<item>
<title>中小型企业级 IPS 部署 - Qftm</title>
<link>http://www.cnblogs.com/qftm/p/12129029.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qftm/p/12129029.html</guid>
<description>&lt;p&gt;2020年的第三天，依旧如往常写文章，分享最近做的项目继《&lt;a href=&quot;https://www.cnblogs.com/qftm/p/12129179.html&quot;&gt;中小型企业级防火墙部署&lt;/a&gt;》之后的另一部分《&lt;a href=&quot;https://www.cnblogs.com/qftm/p/12129029.html&quot;&gt;构建基于Snort+Guardian+Iptables的IPS&lt;/a&gt;》，后面会将整个完整项目开源分享出来，欢迎大家一起交流分享&lt;/p&gt;

&lt;h2 id=&quot;ips简介&quot;&gt;IPS简介&lt;/h2&gt;
&lt;p&gt;IPS是英文“Intrusion Prevention System”的缩写，中文意思是“入侵防御系统”，是一种网络安全设备或应用软件，除了具有IDS的监控检测功能之外，还具有深度感知检测数据流量，对恶意报文进行丢弃，实现实时告警和阻断的入侵防御系统。&lt;/p&gt;
&lt;h2 id=&quot;ips功能组成&quot;&gt;IPS功能组成&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;数据采集：采集和捕获流量数据
入侵检测：分析流量和日志数据，发现安全异常行为并发出警报,常见的有Snort、Suricata、Bro
结果展示：用于分析IDS警报并进行友好展示,常见的IDS警报分析工具有Snorby、Sguil、Base
安全防御：主动响应安全事件，阻断攻击者入侵行为，常用iptables&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;IDS是英文“Intrusion Detection Systems”的缩写，中文意思是“入侵检测系统”，是一种网络安全设备或应用软件，可以依照一定的安全策略，对网络、系统的运行状况进行监视，尽可能发现各种攻击企图、攻击行为或者攻击结果，并发出安全警报。&lt;/p&gt;
&lt;h2 id=&quot;ids通用系统模型&quot;&gt;IDS通用系统模型&lt;/h2&gt;
&lt;p&gt;（1）数据收集器(又称探测器)：主要负责收集数据。探测器的输入数据流包括任何可能包含入侵行为线索的系统数据，如各种网络协议数据包、系统日志文件和系统调用记录等。探测器将这些数据收集起来，然后再发送到检测器进行处理。&lt;br/&gt;（2）检测器(又称分析器或检测引擎)：负责分析和检测入侵的任务，并向控制器发出警报信号。&lt;br/&gt;（3）知识库：为检测器和控制器提供必需的数据信息支持。这些信息包括:用户历史活动档案或检测规则集合等。&lt;br/&gt;（4）控制器：根据从检测器发来的警报信号，人工或自动地对入侵行为做出响应。&lt;/p&gt;
&lt;h2 id=&quot;ids分类&quot;&gt;IDS分类&lt;/h2&gt;
&lt;p&gt;IDS根据两种方法进行分类：按照数据来源、按照入侵检测策略。&lt;/p&gt;
&lt;h3 id=&quot;按照数据来源分类&quot;&gt;按照数据来源分类&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;基于网络的入侵检测系统（NIDS）
基于主机的入侵监测系统（HIDS）
分布式入侵检测系统（DIDS）&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;按照入侵检测策略分类&quot;&gt;按照入侵检测策略分类&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;滥用检测
异常检测
完整性分析&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;企业拓扑&quot;&gt;企业拓扑&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200101170109084-630725488.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;环境准备&quot;&gt;环境准备&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;DMZ区：CentOS7 --- IP:192.168.9.100 Gateway:192.168.9.254
防火墙：kali --- ip1:211.67.93.254；ip2:192.168.9.254；ip3:192.168.33.254；
外网主机：win2003 --- IP:211.67.93.100  Gateway:211.67.93.254
内网主机：win2003 --- IP:192.168.33.100 Gateway:192.168.33.254&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;snort简介&quot;&gt;Snort简介&lt;/h2&gt;
&lt;p&gt;在1998年，Martin Roesch用C语言开发了开放源代码(Open Source)的入侵检测系统Snort。直至今天，Snort已发展成为一个具有多平台(Multi-Platform)、实时(Real-Time)流量分析、网络IP数据包(Pocket)记录等特性的强大的网络入侵检测/防御系统(Network Intrusion Detection/Prevention System)，即NIDS/NIPS。Snort符合通用公共许可(GPL——GNU General Pubic License)，在网上可以通过免费下载获得Snort，并且只需要几分钟就可以安装并开始使用。&lt;br/&gt;Snort有三种工作模式：嗅探器、数据包记录器、网络入侵检测系统。嗅探器模式仅仅是从网络上读取数据包并作为连续不断的流显示在终端上。数据包记录器模式把数据包记录到硬盘上。网络入侵检测模式是最复杂的，而且是可配置的。我们可以让snort分析网络数据流以匹配用户定义的一些规则，并根据检测结果采取一定的动作。&lt;/p&gt;
&lt;h2 id=&quot;snort安装&quot;&gt;Snort安装&lt;/h2&gt;
&lt;p&gt;安装系统Kali&lt;br/&gt;Snort安装方式一般分为源码编译安装与包管理器安装两种方式。使用源码下载会比较复杂，但是文档齐全，debug方便一些；而包管理器安装非常方便，一条命令解决所有问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;apt-get install snort&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;snort配置&quot;&gt;Snort配置&lt;/h2&gt;
&lt;h3 id=&quot;设置规则路径&quot;&gt;设置规则路径&lt;/h3&gt;
&lt;p&gt;修改配置文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/etc/snort/snort.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103001359222-634554585.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;查看规则&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103001528221-1825888212.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;br/&gt;PS：Linux默认安装之后Snort日志路径等都会默认配置好，无需麻烦配置
&lt;h2 id=&quot;snort启动&quot;&gt;Snort启动&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;snort -i eth1 -c /etc/snort/snort.conf -A fast -l /var/log/snort&lt;/code&gt;
&lt;/pre&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103003016355-95081633.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;snort测试&quot;&gt;Snort测试&lt;/h2&gt;
&lt;p&gt;查看默认Snort ICMP规则&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103001826871-184765482.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;br/&gt;测试外网ping DMZ区域Web服务器&lt;br/&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103001846632-640918529.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;br/&gt;查看IDS日志记录&lt;br/&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103001920260-423564396.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;br/&gt;分析日志可知，Snort允许ICMP通过，并且记录了ICMP的相关数据。

&lt;p&gt;Guardian实现Snort+Iptables联动效应&lt;/p&gt;
&lt;h2 id=&quot;guardian下载&quot;&gt;Guardian下载&lt;/h2&gt;
&lt;p&gt;Guardian需要去官网下载&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://www.chaotic.org/guardian/&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;guardian安装&quot;&gt;Guardian安装&lt;/h2&gt;
&lt;h3 id=&quot;下载之后解压&quot;&gt;下载之后解压&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;tar -zxvf guardian-1.7.tar.gz&lt;/code&gt;
&lt;/pre&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103003349041-1963222133.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;移动guardian到snort下-创建名单-日志&quot;&gt;移动guardian到snort下 &amp;amp;&amp;amp; 创建名单 &amp;amp;&amp;amp; 日志&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;→ Qftm ← :~/桌面# mv guardian-1.7 /etc/snort/
→ Qftm ← :~/桌面# touch /etc/snort/guardian-1.7/guardian.ignore 创建白名单
→ Qftm ← :~/桌面# touch /etc/snort/guardian-1.7/guardian.target  创建黑名单
→ Qftm ← :~/桌面# touch /var/log/snort/guardian.log    guardian的日志&lt;/code&gt;
&lt;/pre&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103003525492-1982396014.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;复制block脚本&quot;&gt;复制block脚本&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;→ Qftm ← :/etc/snort/guardian-1.7# cp scripts/iptables_block.sh /usr/local/bin/guardian_block.sh
→ Qftm ← :/etc/snort/guardian-1.7# cp scripts/iptables_unblock.sh /usr/local/bin/guardian_unblock.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103003627399-836275045.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;此操作是为了满足在guardian.pl中设置的&lt;span class=&quot;math inline&quot;&gt;\(blockpath和\)&lt;/span&gt;unblockpath路径&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103003702107-758695107.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;br/&gt;PS:
&lt;pre&gt;
&lt;code&gt;(1)Guardian的执行文件 guardian.pl 
(2)Guardian封锁IP所要调用的外部程序 scripts/iptalbes_block.sh 
(3)Guardian解除对某一IP封锁时，所需要调用的外部程序scripts/iptalbes_unblock.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;guardian配置&quot;&gt;Guardian配置&lt;/h2&gt;
&lt;h3 id=&quot;配置guardian.conf&quot;&gt;配置guardian.conf&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;Interface       eth1
HostGatewayByte  1
LogFile         /var/log/snort/guardian.log
AlertFile       /var/log/snort/alert              
IgnoreFile      /etc/snort/guardian-1.7/guardian.ignore
TargetFile      /etc/snort/guardian-1.7/guardian.target
TimeLimit    86400&lt;/code&gt;
&lt;/pre&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103003843813-133085564.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;PS:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;TimeLimit：在多少秒后解除对IP的封锁，86400秒也就是24小时之后解除对IP的封锁。
AlertFile：警报信息，前提是snort以alert_fast输出报警信息&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置guardian_block.sh和guardian_unblock.sh规则&quot;&gt;配置guardian_block.sh和guardian_unblock.sh规则&lt;/h3&gt;
&lt;p&gt;编写策略文件，配置对外来入侵者进行拦截和解除的策略&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103004246830-856641688.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103004256847-1077381214.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;guardian启动&quot;&gt;Guardian启动&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;→ Qftm ← :/etc/snort/guardian-1.7# perl guardian.pl -c guardian.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103004338484-1803852373.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;h2 id=&quot;外网攻击者对web服务器进行攻击&quot;&gt;外网攻击者对Web服务器进行攻击&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103004438257-1015582249.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;ips检测拦截&quot;&gt;IPS检测&amp;amp;拦截&lt;/h2&gt;
&lt;h3 id=&quot;ips检测&quot;&gt;IPS检测&lt;/h3&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103004503542-111005454.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;ips拦截&quot;&gt;IPS拦截&lt;/h3&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103004511919-62095058.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;由上可知，外部攻击者被IPS记录拦截限制访问&lt;br/&gt;&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103004530740-1052042282.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1594459/202001/1594459-20200103004541742-1938280567.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 02 Jan 2020 16:52:00 +0000</pubDate>
<dc:creator>Qftm</dc:creator>
<og:description>《构建基于Snort+Guardian+Iptables的IPS》 2020年的第三天，依旧如往常写文章，分享最近做的项目继《 &amp;quot;中小型企业级防火墙部署&amp;quot; 》之后的另一部分《 &amp;q</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qftm/p/12129029.html</dc:identifier>
</item>
<item>
<title>python之子类继承父类时进行初始化的一些问题 - 西西嘛呦</title>
<link>http://www.cnblogs.com/xiximayou/p/12142888.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiximayou/p/12142888.html</guid>
<description>&lt;p&gt;直接看代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(Person):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.school &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一中&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
stu &lt;/span&gt;=&lt;span&gt; Student()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学生的姓名是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,stu.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时，程序是不能正常运行的，运行之后报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503039/202001/1503039-20200102231501749-265586818.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;这是为什么呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;__init__相当于是python类的构造方法，在类进行实例化时被调用，当子类和父类中都存在构造方法时，子类中需要显示调用父类的构造方法 。需要注意的是python中构造方法是不能进行重载的，当有多个构造方法存在时，会默认调用最后一个构造方法。修改后的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.name &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(Person):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
      &lt;strong&gt;  &lt;span&gt;super(Student, self).&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;()&lt;/span&gt;&lt;/strong&gt;
        self.school &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一中&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
stu &lt;/span&gt;=&lt;span&gt; Student()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学生的姓名是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,stu.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时的结果就是正常的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503039/202001/1503039-20200102232034076-2038771252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;super(Student, self).&lt;/strong&gt;&lt;strong&gt;__init__&lt;/strong&gt;&lt;strong&gt;()：&lt;/strong&gt;其中super关键字表示父类，Student是本类的名称，self指代本类自己。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;在python中如何设置私有属性和方法？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;将属性和方法前面加上__（双下划线）。加上了私有的属性和方法不能在类外进行访问，同时，子类继承父类的属性和方法时，在子类中也不能够访问父类的私有属性和方法。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__test&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是父类的私有方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(Person):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        super(Student, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        super().&lt;/span&gt;&lt;span&gt;__test&lt;/span&gt;&lt;span&gt;()
        self.school &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一中&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
stu &lt;/span&gt;=&lt;span&gt; Student()&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上代码会报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503039/202001/1503039-20200102235312594-99625776.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;要想访问到父类的私有属性和方法，需这样做：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.&lt;/span&gt;&lt;span&gt;__name&lt;/span&gt; = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jack&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        self.age &lt;/span&gt;= 12
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__test&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是父类的私有方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是父类的公有方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(Person):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        super(Student, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.school &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一中&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; printStudent(self):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;子类自己继承了父类的公有属性，直接访问即可&lt;/span&gt;
        &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;在子类中使用父类的共有属性：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,self.age)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;super()代表父类，可以访问父类的公有方法&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;当然如若子类没有重写父类的方法，也可以使用self.test()来调用&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;super和self区别：super是指代父类,self指代该类本身&lt;/span&gt;
&lt;span&gt;        super().test()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;对于父类的私有属性和方法，需要通过_父类名__属性或方法名来访问&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt;super()._Person__test()&lt;/span&gt;
&lt;span&gt;        self._Person__test()
stu &lt;/span&gt;=&lt;span&gt; Student()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学生的姓名是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,stu._Person__name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学生的年龄是:&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,stu.age)
stu._Person__test()
stu.printStudent()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503039/202001/1503039-20200102235628802-1277733571.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要明确的是python中并没有真正意义上的私有修饰符，从以上的代码也可以看出。Python在运行时会将__属性或方法转换成：_类名__属性或方法。通过这种方式就可以访问到类私有属性或方法。还有一种方式就是通过在类内部再定义一个公有方法，来调用私有的属性或方法，在子类进行调用时调用这个公有的方法即可，这也就是面向对象中封装的作用之一，在接下来会结合进行介绍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;那么假设父类的构造器带有参数，那么在子类中应该如何进行初始化呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;子类要在初始化的时候显示调用父类的有参构造，并且传入相应的参数，具体代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,age):
        self.name &lt;/span&gt;=&lt;span&gt; name
        self.&lt;/span&gt;&lt;span&gt;__age&lt;/span&gt; =&lt;span&gt; age
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__test&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是父类的私有方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(self):
        self.&lt;/span&gt;&lt;span&gt;__test&lt;/span&gt;&lt;span&gt;()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是父类的公有方法&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; setAge(self,age):
        self.&lt;/span&gt;&lt;span&gt;__age&lt;/span&gt; =&lt;span&gt; age
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; getAge(self):
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__age&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(Person):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,school,name,age):
        super(Student, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;(name=name,age=&lt;span&gt;age)
        self.school &lt;/span&gt;=&lt;span&gt; school
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; stuTest(self):
        super().test()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;所在学校为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,self.school)
stu &lt;/span&gt;= Student(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;一中&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,12&lt;span&gt;)
stu.stuTest()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学生的姓名是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,stu.name)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;学生的年龄是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,stu.getAge())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503039/202001/1503039-20200103000102722-508524298.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;补充：&lt;/p&gt;
&lt;p&gt;假设父类中没有显示的定义构造函数，那么在子类中就不用显示的定义父类的构造函数。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Person:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; test(self):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;什么都没有&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name):
        self.name &lt;/span&gt;=&lt;span&gt; name
stu &lt;/span&gt;= Student(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;tom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;姓名是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,stu.name)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/1503039/202001/1503039-20200103000415788-734966126.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 02 Jan 2020 16:05:00 +0000</pubDate>
<dc:creator>西西嘛呦</dc:creator>
<og:description>直接看代码： class Person: def __init__(self): self.name = &amp;quot;jack&amp;quot; class Student(Person): def __i</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiximayou/p/12142888.html</dc:identifier>
</item>
<item>
<title>pytorch :: Dataloader中的迭代器和生成器应用 - hansoluo</title>
<link>http://www.cnblogs.com/hansoluo/p/12131782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hansoluo/p/12131782.html</guid>
<description>&lt;p&gt;在使用pytorch训练模型，经常需要加载大量图片数据，因此pytorch提供了好用的数据加载工具Dataloader。&lt;br/&gt;为了实现小批量循环读取大型数据集，在Dataloader类具体实现中，使用了迭代器和生成器。&lt;br/&gt;这一应用场景正是python中迭代器模式的意义所在，因此本文对Dataloader中代码进行解读，可以更好的理解python中迭代器和生成器的概念。&lt;/p&gt;
&lt;p&gt;本文的内容主要有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;解释python中的迭代器和生成器概念&lt;/li&gt;
&lt;li&gt;解读pytorch中Dataloader代码，如何使用迭代器和生成器实现数据加载&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;python迭代基础&quot;&gt;python迭代基础&lt;/h2&gt;
&lt;p&gt;python中围绕着迭代有以下概念：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可迭代对象 iterables&lt;/li&gt;
&lt;li&gt;迭代器 iterator&lt;/li&gt;
&lt;li&gt;生成器 generator&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这三个概念互相关联，并不是孤立的。在可迭代对象的基础上发展了迭代器，在迭代器的基础上又发展了生成器。&lt;br/&gt;学习这些概念的名词解释没有多大意义。编程中很多的抽象概念都是为了更好的实现某些功能，才去人为创造的协议和模式。&lt;br/&gt;因此，要理解它们，需要探究概念背后的逻辑，为什么这样设计？要解决的真正问题是什么？在哪些场景下应用是最好的？&lt;/p&gt;
&lt;p&gt;迭代模式首先要解决的基础问题是，需要按一定顺序获取集合内部数据，比如循环某个list。&lt;br/&gt;当数据很小时，不会有问题。但当读取大量数据时，一次性读取会超出内存限制，因此想出以下方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把大的数据分成几个小块，分批处理&lt;/li&gt;
&lt;li&gt;惰性的取值方式，按需取值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;循环读数据可分为下面三种应用场景，对应着容器（可迭代对象），迭代器和生成器：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;for x in container&lt;/code&gt;: 为了遍历python内部序列容器（如list）, 这些类型内部实现了__getitem__() 方法，可以从0开始按顺序遍历序列容器中的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for x in iterator&lt;/code&gt;: 为了循环用户自定义的迭代器，需要实现__iter__和__next__方法，__iter__是迭代协议，具体每次迭代的执行逻辑在 __next__或next方法里&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for x in generator&lt;/code&gt;: 为了节省循环的内存和加速，使用生成器来实现惰性加载，在迭代器的基础上加入了yield语句，最简单的例子是 range(5)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;代码示例:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 普通循环 for x in list
numbers = [1, 2, 3,]
for n in numbers:
    print(n) # 1,2,3

# for循环实际干的事情
# iter输入一个可迭代对象list，返回迭代器
# next方法取数据
my_iterator = iter(numbers)
next(my_iterator) # 1
next(my_iterator) # 2
next(my_iterator) # 3
next(my_iterator) # StopIteration exception

# 迭代器循环 for x in iterator
for i,n in enumerate(numbers):
    print(i,n) # 0,1 / 1,3 / 2,3

# 生成器循环 for x in generator
for i in range(3):
    print(i) # 0,1,2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面示例代码中python内置函数iter和next的用法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;iter函数，调用__iter__，返回一个迭代器&lt;/li&gt;
&lt;li&gt;next函数，输入迭代器，调用__next__，取出数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;比较容易混淆的是__iter__和__next__两个方法。它们的区别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;__iter__是为了可以迭代，真正执行取数据的逻辑是__next__方法实现的，实际调用是通过next(iterator)完成&lt;/li&gt;
&lt;li&gt;__iter__可以返回自身（return self），实际读取数据的实现放在__next__方法&lt;/li&gt;
&lt;li&gt;__iter__可以和yield搭配，返回生成器对象&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;__iter__返回自身的做法有点类似 python中的类型系统。为了保持一致性，python中一切皆对象。&lt;br/&gt;每个对象创建后，都有类型指针，而类型对象的指针指向元对象，元对象的指针指向自身。&lt;/p&gt;
&lt;p&gt;生成器，是在__iter__方法中加入yield语句，好处有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;减少循环判断逻辑的复杂度&lt;/li&gt;
&lt;li&gt;惰性取值，节省内存和时间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;yield作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;代替函数中的return语句&lt;/li&gt;
&lt;li&gt;记住上一次循环迭代器内部元素的位置&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;三种循环模式常用函数&quot;&gt;三种循环模式常用函数&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;for x in container&lt;/code&gt;方法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;list, deque, …&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set, frozensets, …&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dict, defaultdict, OrderedDict, Counter, …&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tuple, namedtuple, …&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;str&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;for x in iterator&lt;/code&gt;方法:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;enumerate()&lt;/code&gt; # 加上list的index&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sorted()&lt;/code&gt; # 排序list&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reversed()&lt;/code&gt; # 倒序list&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zip()&lt;/code&gt; # 合并list&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;code&gt;for x in generator&lt;/code&gt;方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;range()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;filter()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reduce()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[x for x in list(...)]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;dataloder源码分析&quot;&gt;Dataloder源码分析&lt;/h2&gt;
&lt;p&gt;pytorch采用&lt;code&gt;for x in iterator&lt;/code&gt;模式，从Dataloader类中读取数据。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;为了实现该迭代模式，在Dataloader内部实现__iter__方法，实际返回的是_DataLoaderIter类。&lt;/li&gt;
&lt;li&gt;_DataLoaderIter类里面，实现了 __iter__方法，返回自身，具体执行读数据的逻辑，在__next__方法中。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以下代码只截取了单线程下的数据读取。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class DataLoader(object):
    r&quot;&quot;&quot;
    Data loader. Combines a dataset and a sampler, and provides
    single- or multi-process iterators over the dataset.
    &quot;&quot;&quot;
    def __init__(self, dataset, batch_size=1, shuffle=False, ...):
        self.dataset = dataset
        self.batch_sampler = batch_sampler
        ...
    
    def __iter__(self):
        return _DataLoaderIter(self)

    def __len__(self):
        return len(self.batch_sampler)

class _DataLoaderIter(object):
    r&quot;&quot;&quot;Iterates once over the DataLoader's dataset, as specified by the sampler&quot;&quot;&quot;
    def __init__(self, loader):
        self.sample_iter = iter(self.batch_sampler)
        ...

    def __next__(self):
        if self.num_workers == 0:  # same-process loading
            indices = next(self.sample_iter)  # may raise StopIteration
            batch = self.collate_fn([self.dataset[i] for i in indices])
            if self.pin_memory:
                batch = pin_memory_batch(batch)
            return batch
        ...

    def __iter__(self):
        return self&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Dataloader类中读取数据Index的方法，采用了 &lt;code&gt;for x in generator&lt;/code&gt;方式，但是调用采用iter和next函数&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构建随机采样类RandomSampler，内部实现了 __iter__方法&lt;/li&gt;
&lt;li&gt;__iter__方法内部使用了 yield，循环遍历数据集，当数量达到batch_size大小时，就返回&lt;/li&gt;
&lt;li&gt;实例化随机采样类，传入iter函数，返回一个迭代器&lt;/li&gt;
&lt;li&gt;next会调用随机采样类中生成器，返回相应的index数据&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class RandomSampler(object):
    &quot;&quot;&quot;random sampler to yield a mini-batch of indices.&quot;&quot;&quot;
    def __init__(self, batch_size, dataset, drop_last=False):
        self.dataset = dataset
        self.batch_size = batch_size
        self.num_imgs = len(dataset)
        self.drop_last = drop_last

    def __iter__(self):
        indices = np.random.permutation(self.num_imgs)
        batch = []
        for i in indices:
            batch.append(i)
            if len(batch) == self.batch_size:
                yield batch
                batch = []
        ## if images not to yield a batch
        if len(batch)&amp;gt;0 and not self.drop_last:
            yield batch


    def __len__(self):
        if self.drop_last:
            return self.num_imgs // self.batch_size
        else:
            return (self.num_imgs + self.batch_size - 1) // self.batch_size

batch_sampler = RandomSampler(batch_size. dataset)
sample_iter = iter(batch_sampler)
indices = next(sample_iter)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文总结了python中循环的三种模式：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;for x in container&lt;/code&gt; 可迭代对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for x in iterator&lt;/code&gt; 迭代器&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for x in generator&lt;/code&gt; 生成器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;pytorch中的数据加载模块 Dataloader，使用生成器来返回数据的索引，使用迭代器来返回需要的张量数据，可以在大量数据情况下，实现小批量循环迭代式的读取，避免了内存不足问题。&lt;/p&gt;
&lt;h2 id=&quot;参考文章&quot;&gt;参考文章&lt;/h2&gt;
</description>
<pubDate>Thu, 02 Jan 2020 15:13:00 +0000</pubDate>
<dc:creator>hansoluo</dc:creator>
<og:description>总结了python中循环的三种模式，可迭代对象，迭代器，生成器。Dataloader使用生成器返回index，使用迭代器返回张量数据，实现小批量循环迭代式的读取，避免了内存不足问题。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hansoluo/p/12131782.html</dc:identifier>
</item>
<item>
<title>开发者请注意：Python2 的最后版本将于 4 月发布，但它确实是在 1 月 1 日就寿命终止了！ - 豌豆花下猫</title>
<link>http://www.cnblogs.com/pythonista/p/12142690.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pythonista/p/12142690.html</guid>
<description>&lt;p&gt;2020 年 1 月 1 日是 Python2 的寿命终止日，这个日期在两年前经&quot;Python之父&quot; Guido van Rossum 宣布，此后一直成为开发者社区翘首以盼的一天。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1573275/202001/1573275-20200102230107257-162200736.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;昨天就是这个大快人心的日子，各种变了花样的喜庆报道不绝于目。调侃的玩笑也不少，比如这个：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1573275/202001/1573275-20200102230107463-1278083948.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;还有这个（别信！）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1573275/202001/1573275-20200102230107594-1797129200.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然而，我今天偶然看到一位大佬的疑问，大意如下：官网发布的 Python2 退休日期说是 4 月，那个倒计时网站是不是冒充的官方消息？&lt;/p&gt;
&lt;p&gt;他所说的官网消息是这篇——&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1573275/202001/1573275-20200102230111490-961246277.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;怎么回事呢？传了那么久的元旦退休消息，竟然会不准确？那么多人在热热闹闹地庆祝着，竟然是在庆祝一个假消息么？&lt;/p&gt;
&lt;p&gt;我搜索那篇文章，仔细读了一遍，然后才注意到发布日期是 2019 年 12 月 20 日，也就是两周前。文中没有提到 1 月 1 日，也没提 4 月的具体日子。&lt;/p&gt;
&lt;p&gt;文章属实，但日期明显矛盾，这是怎么回事呢？官方应该会有所解释吧？带着疑问，我去翻看官方和几个核心开发者的推特。&lt;/p&gt;
&lt;p&gt;经过一番资料查阅，我终于搞清楚了怎么回事，也找到了所谓的&quot;官方解释&quot;。&lt;/p&gt;
&lt;p&gt;简单说明结论：&lt;strong&gt;2020-01-01 是板上钉钉的 Python2 的 EOL (end of life，寿命终止)日子，但是在这个日子前的版本发布周期还在进行，最后一个版本按计划是在今年 4 月的 Pycon US 大会上发布。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Python2.7 在 2019 年的最后一个版本是 10 月 19 日发布的 2.7.17 版本，在它之后直到2020-01-01 之间产生的所有问题，开发者们是接受的，而计划合入的版本将是 4 月 17 日的 2.7.18 版本。&lt;/p&gt;
&lt;p&gt;以篮球比赛中的压哨球来类比，你就明白怎么回事了：球离手在空中飞了三分之一路程，这时终止的哨声吹响，最后这球中袋了当然还是有效的。&lt;/p&gt;
&lt;p&gt;进行了三分之一的 2.7.18 版本，就像离手之球，离弦之箭，泼出之水，负责任的 Python 官方还是要认可它的。&lt;/p&gt;
&lt;p&gt;其实，这个决定并不是最近确定的，早在 2019 年 9 月，Python2 的版本经理 Benjamin Peterson 就公布了这个计划，这里是当时的邮件组截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1573275/202001/1573275-20200102230115970-2085263016.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有不少开发者表示了疑义：为什么不能把 4 月的发布计划提前呢？如果是 4 月发布最后版本，为什么不说 4 月才是 EOL 呢？为什么容许出现两个不一致的日期？&lt;/p&gt;
&lt;p&gt;根据我对讨论内容的理解，主要有如下原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;12 月末不是一个方便的“工作”时间（因为感恩节放假！）&lt;/li&gt;
&lt;li&gt;4 月有一年一度的社区大会，届时大家可以集体宣泄&lt;/li&gt;
&lt;li&gt;Python 1 的最后版本（1.6.1）已经有此先例&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;有不少开发者也表示附议，认可这个安排。详细的讨论过程在：&lt;a href=&quot;https://dwz.cn/ECmB3cZo&quot; class=&quot;uri&quot;&gt;https://dwz.cn/ECmB3cZo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;如果 PSF 在发布那篇“4 月退休”的文章时，对此安排作出解释，也许大家就不会有那么多困惑了，更不至于怀疑自己在传播假消息……&lt;/p&gt;
&lt;p&gt;看到这，你也应该理解了来龙去脉吧？不过，我相信还是有读者有疑问：既然早就知道会有这个尾巴要处理，为什么不能加快进度，多投精力，争取一分不差地在 2019-12-31 发布最后一个版本呢？&lt;/p&gt;
&lt;p&gt;追进度、赶 deadline、加班加点，这种事情在国内互联网领域是司空见惯了。然而，Python 核心开发者们几乎都是志愿者，花的是业余兴趣时间，他们的主业可能都不至于 996，怎么能指望在副业上 996 呢？！不要强人所难！&lt;/p&gt;
&lt;p&gt;最后，不管怎么说，Python2 确实是在 2010-01-01 就 EOL 了，此后自生自灭。&lt;/p&gt;
&lt;p&gt;它的最后一个版本会在 4 月份发布（只包含 1 月 1 日前的问题），我们不用着急，就让这只球飞一会吧，等到球落袋的时候，我们再一起，举杯相庆！&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1573275/202001/1573275-20200102230117951-88377440.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公众号【&lt;strong&gt;Python猫&lt;/strong&gt;】， 本号连载优质的系列文章，有喵星哲学猫系列、Python进阶系列、好书推荐系列、技术写作、优质英文推荐与翻译等等，欢迎关注哦。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Jan 2020 15:01:00 +0000</pubDate>
<dc:creator>豌豆花下猫</dc:creator>
<og:description>2020 年 1 月 1 日是 Python2 的寿命终止日，这个日期在两年前经&amp;quot;Python之父&amp;quot; Guido van Rossum 宣布，此后一直成为开发者社区翘首以盼的一天。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pythonista/p/12142690.html</dc:identifier>
</item>
<item>
<title>告别2019，写给2020：干好技术，要把握好时光里的每一步 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/12142424.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/12142424.html</guid>
<description>&lt;p&gt;不知不觉，一晃年关将近，即将翻开2019，进入新的一页。&lt;/p&gt;
&lt;p&gt;这周已经在朋友圈看到了来自公众号《恰同学少年》《Edi.Wang》和《吃草的罗汉》几位老师写下的年终总结，他们的年终总结让我感想颇多，对自己的2019年也感想颇深，对2020年也充满期待，是时候对过去一年的一些感悟做一个简单的总结了。&lt;/p&gt;

&lt;p&gt;在2&lt;a href=&quot;https://www.cnblogs.com/xiyuanMore/p/10171587.html&quot;&gt;018年的年终总结&lt;/a&gt;中，与其说是一个总结，不如说是写了一堆漂亮话，其实真正落地的flag太少，而且总结不够彻底，没有起到总结经验，反思教训的意义。&lt;/p&gt;
&lt;p&gt;总体上来说，我应该做个对技术充满热情和追求的开发者，而在去年的年终总结大概也只表达了一个意思，不要做云程序员，不要做云程序员，不要做云程序员。&lt;/p&gt;
&lt;p&gt;而2019年，我的目标就是回归本质，不做云程序员，从现在来看，至少从思维模式上，已经发生了很大的变化，至少“我觉得xxx技术也不过如此”“我以为xxx技术不过是xxx”这样的主观评判的口气已经不会在说了。&lt;/p&gt;
&lt;p&gt;之所以成为“云程序员”，大概是来源于过去若干年有意无意的习惯使然。&lt;/p&gt;
&lt;p&gt;有时候得承认，越是中小公司，越容易培养所谓通才，因为公司的发展尚处于摸石头过河的阶段，往往需要在纷繁复杂的混沌乱局中寻找一切可以生存的机会，这也意味着中小企业对开发者的要求几乎都是招之能来，来之能战，战之能胜的通才。中小企业也并没有太多职业生涯规划或培训指导的工作安排，所以工程师的成长往往需要靠自己的方式。&lt;/p&gt;
&lt;p&gt;大部分所谓成长，其实是在憋工龄，在一个又一个圈子中绕来绕去。你会用到许多东西，实际上你无法学到真正属于自己的技能。有时候会贪图掌握更多知识，尤其是新技术，于是就开始走在了云程序员的路上。似乎许多中小企业出来的开发者更喜欢自称为全栈工程师，并自称自己什么都会，有的甚至会因此而对那些真正从事技术领域的专业开发者带有偏见，以为他们是死脑筋，其实往往是井底之蛙的个人之见。&lt;/p&gt;
&lt;p&gt;专业公司的培养形式是以提高效率为目标的工业化培养形式，对专才的要求也越来越高。IT是一个复杂程度丝毫不亚于其他产业的系统工程，它涉及的领域和技术非常多，几乎每一个方面都值得人花一辈子去认真探究。事实上只有优秀的公司才有可能培养出专才，而且才有这样的土壤，能够让一些开发者能够把时间花在某些专业领域持续学习和研究，然后让知识产生价值。&lt;/p&gt;
&lt;p&gt;规模越大、越优秀的公司越容易对开发者产生吸引力，除了其待遇问题外，往往是因为这些公司专业化程度更高，也意味着你更容易快速成长，因为专注于一个领域显然比无法专注于一个领域更能带来更快的成长。从软件研发岗位来说，当你在某些技术方向上的深度上到一定程度，再来扩充广度时，也更容易吸收到有用的东西。当然，现在互联网公司也逐渐开始往通才发展，因为掌握全局思维的开发者更容易做出产品，但是互联网公司和中小企业的通才区别依然比较大。互联网公司需要的是具备互联网思维，能够把自己一块小天地处理完美，还能兼顾其他人工作的可复用型T字型人才，而小企业要的大概是一字型人才。&lt;/p&gt;
&lt;p&gt;尤其对于长沙这座小城市而言，更难以发现专注于某些领域的开发者，或许与企业规模和职业定位有一定的关系，其实哪怕优秀如BAT或华为，也或许无法找到太多某些领域的专业开发者，除了公司的客观因素，与开发者们的主观选择也有关系。当然，不管在大公司或小公司，这不能妨碍我们成为专业开发者，只是意味着如果我们要成为某些领域的大牛，得花更多的时间和精力来经营自己的领域。&lt;/p&gt;
&lt;p&gt;当然，专业/不专业，云程序员/非云程序员或许本身不重要，毕竟对于大部分开发者来说，选择IT知识混口饭吃。而对于有追求的开发者来说，更应该长期的职业发展全局均衡，而不要仅仅关注眼前的利益。尤其在目前这个时代，你的每一段职场，其实不仅仅在为金钱工作，而是为你的简历工作。如何从你的职场中积累对未来发展有价值的东西，才是核心关键的因素。不论你在哪家公司，总会有许多让你收获颇多的东西。常怀感恩之心，用心去发现价值，总能让你成为正能量的传播者。这样的你，既是公司最宝贵的财富，也同时会让你成为人群中的闪光点。&lt;/p&gt;

&lt;p&gt;如前文所说，软件领域是一个非常复杂的系统工程，每一个专业领域都值得人花一辈子去努力钻研，但是对于大部分开发者来说其实无需如此，往往只需花几年时间，就能快速吸取到IT软件发展的精髓，并成长为公司的核心人员。&lt;/p&gt;
&lt;p&gt;当你成长起来之后，或许会以为框架就是技术的王道；也会以为软件就是工具+框架的结合，而忽略了更具有普遍意义的基础技能和算法能力；在抽象化思维上，在过程式思维这条路上越走越远，也极大的局限了开发者的成长；你会以为只有底层代码才是代码，业务代码或增删改查就不是代码；你会以为写文档、写PPT的人都是吹牛逼的。这些都是开发者的怪毛病&lt;/p&gt;
&lt;p&gt;软件研发技能确实是一个值得仔细探究的核心领域，哪怕简单到一句需求的描述，也需要用系统性思维来思考这个问题。&lt;/p&gt;
&lt;p&gt;回顾过去，我总是在想，我真的懂得做项目么，真的懂得如何做好一个软件么？我做的项目是否还有进一步可以提高的空间？如何优雅的收集客户需求，如何优雅的打造完美的产品？如何优雅的做好一个项目？如何让每一个项目都成为标杆项目？如何从失败中吸取经验教训。好吧，我有点啰嗦。&lt;/p&gt;
&lt;p&gt;做一个软件真的并非想象中那么简单，需要将行业思维与IT思维更加完美的融合，既要从更高的战略层面思考问题，又要从代码的微观层面思考问题，有思考有设计、有碰撞有火花，这恰好是软件工程最大的魅力所在。&lt;/p&gt;

&lt;p&gt;2019年看了大概20-30本书，并写了超过15篇书评。包括以下书籍，我认为这些书籍给我带来的无穷收获，远超这些书本身的货币价值。&lt;/p&gt;
&lt;p&gt;《领域驱动设计-软件系统核心复杂性应对之道》：这本书来自埃文斯-埃里克的书，是一本经典的领域驱动设计的书，在2018年8月我开始认真阅读其中的每个文字，并让我对领域驱动有了更深层次的理解；今年我还通过GitChat购买了张逸老师的领域驱动设计的课程，张逸老师不愧为领域驱动设计方面的专家，他用自己的经验解释了领域驱动设计，让我对这本书、以及相关知识都有了系统而全面的了解，同时还通过这一个课程了解了更多的知识领域，对健全我的知识体系产生了巨大的作用。&lt;/p&gt;
&lt;p&gt;《中台》：来自阿里巴巴钟春老师的中台，这本书介绍了阿里巴巴中台建设的历程，这本书造出了一个独特的中国概念，也刷新了我的知识观，虽然短期来看我所经历的企业都没有中台的打算，但能够让我具备全局性思维来思考IT体系建设的问题。&lt;/p&gt;
&lt;p&gt;《小团队、大架构》：来自张清辉老师，这本书介绍了携程的.NET技术架构转型过程，让我对.NET架构的演进方向有了明确的认识。当然这本书过多的介绍轮子，许多读者或许不喜欢，如果跟《微服务架构模式》一起交替的看，一定会产生不错的效果。&lt;/p&gt;
&lt;p&gt;《构建之法》：来自邹欣老师，这本书介绍了软件工程师的成长和微软的IT管理模式，让我能够静下来思考当下自己的发展方向。作为一个拥有十年工作经验的开发者，已经陷入了一个以自我为中心的乖蹇，而周筠老师对我的悉心教导，也让我非常感动，我也要持续努力，坚定自己的发展方向，努力做一个脚踏实地的开发者。&lt;/p&gt;
&lt;p&gt;《浪潮之巅》共两卷：这是吴军老师的作品，吴军老师的质朴清新，不刻意使用过多的辞藻铺垫的写作风格让我获益匪浅，同时讲述的一个个故事又是如此的引人入胜。从故事中，我们看到了一群充满梦想的年轻人们，他们在互联网的浪潮之下做出的选择，是如何一点一点的改变了世界。&lt;/p&gt;
&lt;p&gt;《实例化需求》：这是一本介绍BDD模式的书，介绍了行为驱动开发这种模式，让我获得了新的知识。当然短期内用不起来，但多学一点总不会吃亏。&lt;/p&gt;
&lt;p&gt;除此之外还有：《代码整洁之道》、《重构-改善既有代码的艺术2》、《持续交付2.0》、《PMBook》（好吧，考了12月的pmp，把pmbook看了四遍）、《程序员的三门课》、《Http/2基础教程》、《混乱：如何成为失控时代的掌控者》、《我的世界观》、《算法图解》、《未来简史》、《刷新》、《修炼之道》、《猎豹行动》、《单元测试的艺术》和刚刚读完的《华为方法论》。&lt;/p&gt;
&lt;p&gt;这20几本书都是不同方向的书，与能够读完50本书或更多的优秀前辈们相比确实还存在一点差距，当然这些书有精读有略读，甚至有的其实是牛嚼牡丹，值得以后细细品味。&lt;/p&gt;
&lt;p&gt;有的书着实发人深省带来了许多启迪，有的书则让我的知识体系进一步全面，不过从书到知识到技能，还需要进一步实践、修炼和理解，不然依然是走在云程序员的路上。&lt;/p&gt;

&lt;p&gt;2019年比较大的成绩，拉了一个技术社区应该算是一个；从2月的酝酿，到4月的落地，花了不少的精力，而且这些都是利用业余时间完成的，连筹款都是靠社区大佬、微软、腾讯运加以及社区朋友们的大力支持。也把公众号从80开始，做到了目前的5000+，这些也算是小收获吧，不过没什么骄傲的，毕竟那么多人都是从零开始，做到万粉大号。&lt;/p&gt;
&lt;p&gt;从某种意义上来说，社区似乎离大家都比较远。有时候会感觉试图打造社区来凝聚开发者，其实是一厢情愿。技术社区，或许只会给那些拥有开放性基因的企业和开发者带来好处，并有望助力企业的进一步腾飞。尤其在长沙，究竟有几家企业拥有开放的技术心态？这是个问题。长沙的技术氛围着实令人窒息。&lt;/p&gt;
&lt;p&gt;我们总是渴望打造一个优秀开发者社区。其实优秀开发者本身是一个不好衡量的问题，毕竟成为前百分之二十已经是优秀者，而张一鸣口中的那百分之一的精英，本身就并非一朝一夕所能炼成。&lt;/p&gt;
&lt;p&gt;最终还是落在产出上，你助力企业腾飞、或者你做出了优秀的产品、或者你能够具备自己的系统性思维，并能写出一辆本书；优秀有太多种了，每一种都来之不易。&lt;/p&gt;
&lt;p&gt;一个所谓社区，如果没有形成长期有价值的积累，没能打造优秀的平台，最终走向消亡反而会是“众望所归”。如何让社区避免成为水群、如何发掘更多优秀开发者，形成精英小圈子，我想说每个人都得继续努力，最起码不能成为一个菜市场，否则这样的圈子，其实毫无价值。&lt;/p&gt;
&lt;p&gt;有时候会发现，每个群都是那么几个固定的人，沉迷于群其实根本不能带来个人成长，真正的成长还是得静下来自己认真学习。&lt;/p&gt;
&lt;p&gt;要成为优秀开发者，有时候三天打鱼，两天晒网的刻意憋一点大招，表面上看能带来一点好气象，但是过了那个热度就被客观条件或主观条件抛弃。技术这东西真得坚持个三五年，才真的能够成长起来。有的人，看到这个火，就追逐这个，看到那个热门就赶潮流搞那个，一边写着代码，一边想着明年是不是该转行，这样的学习方式如何能够提高自己？&lt;/p&gt;
&lt;p&gt;从这一点上来看，我只想说我已经在努力朝着好的方向进步，但是还远远不够，与那些已经坚持优秀习惯五年、十年之久的开发者相比，我需要做的远远不止眼前这一点点。&lt;/p&gt;

&lt;p&gt;有时候不太想列过于宏大的计划，因为往往计划会变成插红旗，然后在自己的背上插满了红旗，变成了一个京剧里面的大英雄。这样的计划或许毫无意义。&lt;/p&gt;
&lt;p&gt;所以还是得认真思考，踏踏实实的做几个能够落地的计划：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、勿忘初衷，踏实前进：不吹水，不装逼。做一位优秀的专业开发者，在专业方向上持续形成系统性思维。&lt;/li&gt;
&lt;li&gt;2、减法和加法：
&lt;ul&gt;&lt;li&gt;有感于今年随着参与了社区活动，加的群也越来越多了，2020年得在这一点上多做减法。&lt;/li&gt;
&lt;li&gt;有时候追逐于信息的热度，其实大部分都与我毫无关系。为何关注这些东西？还是八卦性思维的束缚，这一点也有做减法。&lt;/li&gt;
&lt;li&gt;而知识体系的厚度上则需要做加法，多看书，多思考。朋友圈做加法，并非多交更多的朋友，而是都跟优秀的朋友交流沟通，吸取他们的优点，转化成自己的优点。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3、写满一百篇博客，看五十本书。&lt;/li&gt;
&lt;li&gt;4、也得学Edsion周同学锻炼身体了。&lt;/li&gt;
&lt;li&gt;5、努力践行积极乐观向上的团队文化、努力培养一支有战斗力的学习型团队。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;超过30岁的开发者总是会焦虑于自己的职业发展，不知道自己的未来该如何选择，那大概是由于想得太多，做得太少。&lt;/p&gt;
&lt;p&gt;行走在IT这条路，成长太快反而不是好事，只有脚踏实地，一步一个脚印，才能真正无所畏惧。 “易定者无感，易感者无定。”，谋划好未来，并经营自己的当下，才有美好未来。&lt;/p&gt;
</description>
<pubDate>Thu, 02 Jan 2020 14:31:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>不知不觉，一晃年关将近，即将翻开2019，进入新的一页。 这周已经在朋友圈看到了来自公众号《恰同学少年》《Edi.Wang》和《吃草的罗汉》几位老师写下的年终总结，他们的年终总结让我感想颇多，对自己的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/12142424.html</dc:identifier>
</item>
</channel>
</rss>