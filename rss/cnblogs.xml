<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>JVM宏观认知&amp;&amp;内存结构 - noneplus</title>
<link>http://www.cnblogs.com/noneplus/p/11440694.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/noneplus/p/11440694.html</guid>
<description>&lt;h2 id=&quot;什么是虚拟机&quot;&gt;1.什么是虚拟机？&lt;/h2&gt;
&lt;p&gt;虚拟机是一种&lt;strong&gt;软件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可分为系统虚拟机（仿真物理机）和程序虚拟机（执行单个计算机程序，比如JVM）。&lt;/p&gt;

&lt;h2 id=&quot;什么是java虚拟机jvm&quot;&gt;2.什么是Java虚拟机（JVM）？&lt;/h2&gt;
&lt;p&gt;JVM是一种将字节码转化为机器码的软件。（同上）&lt;/p&gt;
&lt;p&gt;历经时间的迭代，目前广泛应用的Java虚拟机是Oracle的HotSpot VM。&lt;/p&gt;

&lt;h2 id=&quot;jvm有什么用&quot;&gt;3.JVM有什么用？&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;理论：加深对Java底层运行机制的了解和认知&lt;/li&gt;
&lt;li&gt;实践：自定义性能更强的JVM(参数调优)，排查由于Java应用本身导致的线上问题（调优主要是调堆）&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;jdk的发布版本了解一下&quot;&gt;JDK的发布版本了解一下&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;1991.4 ：Java语言前身Oak诞生&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;1995.5：Oak语言改名为Java&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;1996.1：JDK1.0发布，代表技术包括JVM，Applet，AWT
&lt;ul&gt;&lt;li&gt;Applet是一种Java程序，需要嵌入在HTML中解释执行&lt;/li&gt;
&lt;li&gt;AWT是早期的抽象窗口工具包，目前流行的有Swing，JavaFx&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;1997.2：JDK1.1发布，代表技术有JAR文件格式，JDBC，内部类，反射&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;2002.2：JDK1.4发布，新的技术有正则表达式，NIO，日志类
&lt;ul&gt;&lt;li&gt;正则表达式是对字符串操作的一种逻辑格式&lt;/li&gt;
&lt;li&gt;NIO在IO的基础上增加了缓冲区，是一种非阻塞式的IO模型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;2004.9：JDK1.5发布,新的技术有自动装箱，泛型，注解，枚举，foreach循环&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;2006.11：Sun公司宣布将Java开源，并建立了OpenJDK组织对源码进行管理。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;2009.4：Oracle以74亿美元收购Sun公司。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;2014.3：Oracle发布JDK1.8，新的特性有Lambda表达式，Stream API&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;2017.9：JDK9发布，新特性有模块化系统，可交互的REPL工具，JIT，JVMCI等等&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;2018.3：JDK10发布，新特性包括JEP286局部变量的类型推断，JEP317向G1引入Full GC&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;2018.9：JDK11发布，新特性包括基于嵌套的访问控制，JavaFx被移除【JDK1.8有】&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;2019.3：JDK12发布，新特性有低暂停时间的GC，微基准测试套件，Switch表达式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;JVM内存结构也称为「运行时数据区」。&lt;/p&gt;

&lt;h2 id=&quot;线程公有&quot;&gt;线程公有：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;Java堆：存放Java实例对象，生命周期和JVM一致&lt;/li&gt;
&lt;li&gt;方法区：存储已被虚拟机加载的类信息、final修饰的常量、static修饰的静态变量。&lt;/li&gt;
&lt;li&gt;运行时常量池：是方法区的一部分，存放字面量与符号引用。
&lt;ul&gt;&lt;li&gt;字面量可以理解为实际值，int a = 8中的8 和 String a = &quot;hello&quot;中的hello都是字面量&lt;/li&gt;
&lt;li&gt;符号引用是一个字符串，对应唯一的类，方法，或者字段。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;线程私有&quot;&gt;线程私有：&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;程序计数器：每个线程都有一个程序计数器，就是一个指针，指向方法区中的方法字节码（下一个将要执行的指令代码），由执行引擎读取下一条指令&lt;/li&gt;
&lt;li&gt;虚拟机栈：描述Java方法执行的过程内存是如何变化的。
&lt;ul&gt;&lt;li&gt;每执行一个方法就会往栈中压入一个元素，这个元素叫“栈帧”用于存储&lt;strong&gt;局部变量表&lt;/strong&gt;，&lt;strong&gt;栈的出入信息&lt;/strong&gt;以及&lt;strong&gt;方法出口信息&lt;/strong&gt;等。&lt;/li&gt;
&lt;li&gt;生命周期和线程相同，线程结束自动释放内存，不需要垃圾回收。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;本地方法栈：为虚拟机使用到的Native方法服务。Native底层是C语言编写的，用于和操作系统交互。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 31 Aug 2019 22:00:00 +0000</pubDate>
<dc:creator>noneplus</dc:creator>
<og:description>JVM宏观认知 1.什么是虚拟机？ 虚拟机是一种 软件 。 可分为系统虚拟机（仿真物理机）和程序虚拟机（执行单个计算机程序，比如JVM）。 2.什么是Java虚拟机（JVM）？ JVM是一种将字节码转</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/noneplus/p/11440694.html</dc:identifier>
</item>
<item>
<title>【Leetcode】【简单】【17. 整数反转】【JavaScript】 - 孙达</title>
<link>http://www.cnblogs.com/2463901520-sunda/p/11441173.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/2463901520-sunda/p/11441173.html</guid>
<description>&lt;blockquote readability=&quot;18.533551554828&quot;&gt;
&lt;h4 class=&quot;css-3mrlhg-Title e5i1odf3&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-integer/&quot;&gt;7. 整数反转&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;p&gt;输入: 123&lt;br/&gt;输出: 321&lt;br/&gt; 示例 2:&lt;/p&gt;
&lt;p&gt;输入: -123&lt;br/&gt;输出: -321&lt;br/&gt;示例 3:&lt;/p&gt;
&lt;p&gt;输入: 120&lt;br/&gt;输出: 21&lt;br/&gt;注意:&lt;/p&gt;
&lt;p&gt;假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31&lt;/sup&gt; − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。&lt;/p&gt;
&lt;p&gt;来源：力扣（LeetCode）&lt;br/&gt;链接：https://leetcode-cn.com/problems/reverse-integer&lt;br/&gt;著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p&gt;

&lt;/blockquote&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; reverse = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(x) {
    
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt;(x)==='number'&lt;span&gt;){

        let str &lt;/span&gt;= ''&lt;span&gt;
        let result &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;
        
        str &lt;/span&gt;= x.toString().split('').reverse().join(''&lt;span&gt;)
        
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(x&amp;lt;0&lt;span&gt;){
           str &lt;/span&gt;= '-' +&lt;span&gt; str
           }
        
        result &lt;/span&gt;=&lt;span&gt; parseInt(str)

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(result&amp;gt;2147483648 || result &amp;lt;-2147483648&lt;span&gt;){
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;
           }
           &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result
    }
};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;



&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1623055/201909/1623055-20190901003416706-17934869.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1623055/201909/1623055-20190901004419032-1204198251.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 31 Aug 2019 16:20:00 +0000</pubDate>
<dc:creator>孙达</dc:creator>
<og:description>题目描述 7. 整数反转 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例&amp;#160;1: 输入: 123输出: 321&amp;#160;示例 2: 输入: -123输出: -</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/2463901520-sunda/p/11441173.html</dc:identifier>
</item>
<item>
<title>zookeeper学习之原理 - 小禾点点</title>
<link>http://www.cnblogs.com/jalja/p/11441174.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jalja/p/11441174.html</guid>
<description>&lt;h2&gt;一、zookeeper 是什么&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Zookeeper是一个分布式协调服务，可用于服务发现，分布式锁，分布式领导选举，配置管理等。这一切的基础，都是Zookeeper提供了一个类似于Linux文件系统的树形结构（可认为是轻量级的内存文件系统，但只适合存少量信息，完全不适合存储大量文件或者大文件），同时提供了对于每个节点的监控与通知机制。既然是一个文件系统，就不得不提Zookeeper是如何保证数据的一致性的。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;二、zookeeper 集群架构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201908/704904-20190831230015212-991511186.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Zookeeper集群是一个基于主从复制的高可用集群，通常 Master服务器作为主服务器提供写服务，其他的 Slave 服务器通过异步复制的方式获取 Master 服务器最新的数据，并提供读服务，在 ZooKeeper 中没有选择传统的 Master/Slave 概念，而是引入了Leader、Follower 和 Observer 三种角色，每个角色承担如下：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;em&gt;Leader&lt;/em&gt; 一个Zookeeper集群同一时间只会有一个实际工作的Leader，它会发起并维护与各Follwer及Observer间的心跳。所有的写操作必须要通过Leader完成再由Leader将写操作广播给其它服务器。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;em&gt;Follower&lt;/em&gt; 一个Zookeeper集群可能同时存在多个Follower，它会响应Leader的心跳。Follower可直接处理并返回客户端的读请求，同时会将写请求转发给Leader处理，并且负责在Leader处理写请求时，对请求进行投票（“过半写成功”策略）。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;em&gt;Observer&lt;/em&gt; 角色与Follower类似，但是无投票权。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt; 在集群中zookeeper是如何保证master与slave数据一致性？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了保证写操作的一致性与可用性，Zookeeper专门设计了一种名为原子广播（ZAB）的支持崩溃恢复的一致性协议。基于该协议，Zookeeper实现了一种主从模式的系统架构来保持集群中各个副本之间的数据一致性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;写数据时保证一致性：Zookeeper 客户端会随机连接到 Zookeeper 集群的一个节点，如果是读请求，就直接从当前节点中读取数据；如果是写请求且当前节点不是leader，那么节点就会向 leader 提交事务，leader 会广播事务，只要有超过半数节点写入成功，该写请求就会被提交（类 2PC 协议）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;服务器运行时期的Leader选举（当leader当机后如何选主）？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;zookeeper 在集群模式下，leader宕机也不会影响继续提供服务，但是leader宕机在从新选主过程时无法对外提供服务，会有一个短暂的停顿过程（这里就是与eureka的区别）。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;集群已存在leader现在又假如一台服务器：对于集群中已经存在Leader而言，此种情况一般都是某台机器启动得较晚，在其启动之前，集群已经在正常工作，对这种情况，该机器试图去选举Leader时，会被告知当前服务器的Leader信息，对于该机器而言，仅仅需要和Leader机器建立起连接，并进行状态同步即可。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;集群存在leader宕机需要重新选举leader：例如server3  宕机了。则剩余的 每个Server发出一个投票。Server1和Server2都会将自己作为Leader服务器来进行投票，每次投票会包含所推举的服务器的myid和ZXID，使用(myid, ZXID)来表示，此时Server1的投票为(1, 0)，Server2的投票为(2, 0)，然后各自将这个投票发给集群中其他机器。当新的leader选择出来以后，第二步就是数据同步保证所有的节点与leader数据一致。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;            处理投票。针对每一个投票，服务器都需要将别人的投票和自己的投票进行PK，PK规则如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　· 优先检查ZXID。ZXID比较大的服务器优先作为Leader。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　· 如果ZXID相同，那么就比较myid。myid较大的服务器作为Leader服务器。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么最好使用奇数台服务器构成 ZooKeeper 集群？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;zookeeper有这样一个特性：集群中只要有过半的机器是正常工作的，那么整个集群对外就是可用的。也就是说如果有2个zookeeper，那么只要有1个死了zookeeper就不能用了，因为1没有过半，所以2个zookeeper的死亡容忍度为0；同理，要是有3个zookeeper，一个死了，还剩下2个正常的，过半了（2&amp;gt;3/2），所以3个zookeeper的容忍度为1。如果是4台zookeeper 如果挂掉2台， 还剩下2台 （2 不大于 4/2），显然不过半所以集群还是不可用，4台的容忍度还是1。因此不是 不能部署偶数台，而是偶数台对于高可用作用不大，浪费服务器。&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;三、ZooKeeper 的一些重要概念&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;ZooKeeper 将数据保存在内存中，这也就保证了 高吞吐量和低延迟（但是内存限制了能够存储的容量不太大，此限制也是保持znode中存储的数据量较小的进一步原因）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ZooKeeper 是高性能的。 在“读”多于“写”的应用程序中尤其地高性能，因为“写”会导致所有的服务器间同步状态。（“读”多于“写”是协调服务的典型场景。）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;会话（Session）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Session 指的是 ZooKeeper 服务器与客户端会话。在 ZooKeeper 中，一个客户端连接是指客户端和服务器之间的一个 TCP 长连接。客户端启动的时候，首先会与服务器建立一个 TCP 连接，从第一次连接建立开始，客户端会话的生命周期也开始了。通过这个连接，客户端能够通过心跳检测与服务器保持有效的会话，也能够向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接收来自服务器的Watch事件通知。 Session的sessionTimeout值用来设置一个客户端会话的超时时间。当由于服务器压力太大、网络故障或是客户端主动断开连接等各种原因导致客户端连接断开时，只要在sessionTimeout规定的时间内能够重新连接上集群中任意一台服务器，那么之前创建的会话仍然有效。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在为客户端创建会话之前，服务端首先会为每个客户端都分配一个sessionID。由于 sessionID 是 Zookeeper 会话的一个重要标识，许多与会话相关的运行机制都是基于这个 sessionID 的，因此，无论是哪台服务器为客户端分配的 sessionID，都务必保证全局唯一。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;Watcher&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　Watcher（事件监听器），是Zookeeper中的一个很重要的特性。Zookeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去，该机制是Zookeeper实现分布式协调服务的重要特性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ACL&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Zookeeper采用ACL（AccessControlLists）策略来进行权限控制，类似于 UNIX 文件系统的权限控制。Zookeeper 定义了如下5种权限&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190901000230548-272140440.png&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;&lt;span&gt;四、zookeeper 的数据结构&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;ZooKeeper 允许分布式进程通过共享的层次结构命名空间进行相互协调，这与标准文件系统类似。 名称空间由 ZooKeeper 中的数据寄存器组成 - 称为znode，这些类似于文件和目录。 与为存储设计的典型文件系统不同，ZooKeeper数据保存在内存中，这意味着ZooKeeper可以实现高吞吐量和低延迟。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/704904/201909/704904-20190901000406318-57030996.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、PERSISTENT--持久化目录节点      客户端与zookeeper断开连接后，该节点依旧存在&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、PERSISTENT_SEQUENTIAL-持久化顺序编号目录节点   客户端与zookeeper断开连接后，该节点依旧存在，只是Zookeeper给该节点名称进行顺序编号&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、EPHEMERAL-临时目录节点   客户端与zookeeper断开连接后，该节点被删除&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、EPHEMERAL_SEQUENTIAL-临时顺序编号目录节点   客户端与zookeeper断开连接后，该节点被删除，只是Zookeeper给该节点名称进行顺序编号&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;五、zookeeper的作用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1、命名服务&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在zookeeper的文件系统里创建一个目录，即有唯一的path,在我们使用tborg无法确定上游程序的部署机器时即可与下游程序约定好path,通过path即能互相探索发现。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;2、配置管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 程序总是需要配置的，如果程序分散部署在多台机器上，要逐个改变配置就变得困难。好吧，现在把这些配置全部放到zookeeper上去，保存在 Zookeeper 的某个目录节点中，然后所有相关应用程序对这个目录节点进行监听，一旦配置信息发生变化，每个应用程序就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中就好。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 3、集群管理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所谓集群管理无在乎两点：是否有机器退出和加入、选举master。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一点，所有机器约定在父目录GroupMembers下创建临时目录节点，然后监听父目录节点的子节点变化消息。一旦有机器挂掉，该机器与 zookeeper的连接断开，其所创建的临时目录节点被删除，所有其他机器都收到通知：某个兄弟目录被删除，于是，所有人都知道他掉线了。新机器加入 也是类似，所有机器收到通知：新兄弟目录加入。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;em id=&quot;__mceDel&quot;&gt;对于第二点，我们稍微改变一下，所有机器创建临时顺序编号目录节点，每次选取编号最小的机器作为master就好。&lt;/em&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;4、分布式锁&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       有了zookeeper的一致性文件系统，锁的问题变得容易。锁服务可以分为两类，一个是保持独占，另一个是控制时序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        对于第一类，我们将zookeeper上的一个znode看作是一把锁，通过createznode的方式来实现。所有客户端都去创建 /distribute_lock 节点，最终成功创建的那个客户端也即拥有了这把锁。用完删除掉自己创建的distribute_lock 节点就释放出锁。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        对于第二类， /distribute_lock 已经预先存在，所有客户端在它下面创建临时顺序编号目录节点，和选master一样，编号最小的获得锁，用完删除，依次方便。  &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 31 Aug 2019 16:19:00 +0000</pubDate>
<dc:creator>小禾点点</dc:creator>
<og:description>ZAB协议包括两种基本的模式，分别是 崩溃恢复和消息广播。当整个服务框架在启动过程中，或是当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进人恢复模式并选举产生新的L</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jalja/p/11441174.html</dc:identifier>
</item>
<item>
<title>多线程入门 - iceblow</title>
<link>http://www.cnblogs.com/iceblow/p/11440999.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/iceblow/p/11440999.html</guid>
<description>&lt;h2&gt;什么是进程和线程?&lt;/h2&gt;
&lt;p&gt;一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。&lt;/p&gt;
&lt;p&gt;多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。&lt;/p&gt;
&lt;p&gt;一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。&lt;/p&gt;
&lt;h2&gt;为什么使用多线程?&lt;/h2&gt;
&lt;p&gt;使用多线程可以编写高效率的程序来达到充分利用 CPU,可以大大提高系统整体的并发能力以及性能.&lt;/p&gt;
&lt;h2&gt;线程的生命周期&lt;/h2&gt;
&lt;p&gt;线程是一个动态执行的过程，它也有一个从产生到死亡的过程。&lt;/p&gt;
&lt;p&gt;下图显示了一个线程完整的生命周期。 &lt;img src=&quot;https://note.youdao.com/yws/public/resource/13e45ac31576fe901e85f3c64ac06332/xmlnote/3271808CC5FD4DC489AEBE90C732E8FC/2259&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;新建状态&lt;/strong&gt;:&lt;br/&gt;使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;就绪状态&lt;/strong&gt;:&lt;br/&gt;当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运行状态&lt;/strong&gt;:&lt;br/&gt;如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;阻塞状态&lt;/strong&gt;:&lt;br/&gt;如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种:
&lt;ul&gt;&lt;li&gt;等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。&lt;/li&gt;
&lt;li&gt;同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。&lt;/li&gt;
&lt;li&gt;其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;死亡状态&lt;/strong&gt;:&lt;br/&gt;一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;创建线程的方式&lt;/h2&gt;
&lt;p&gt;java 提供了三种创建线程的方法：实现 Runnable 接口；继承 Thread 类本身；通过 Callable 和 Future 创建线程。&lt;/p&gt;
&lt;h3&gt;1.实现 Runnable 接口&lt;/h3&gt;
&lt;p&gt;创建一个线程，最简单的方法是创建一个实现 Runnable 接口的类,同时重写 run()方法.&lt;/p&gt;
&lt;p&gt;然后创建Runnable实现类的实例，并以此实例作为Thread的target对象，即该Thread对象才是真正的线程对象。&lt;/p&gt;
&lt;p&gt;新线程创建之后，你调用它的 start() 方法它才会运行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.example.test;

/**
 * @author ydx
 */
public class RunnableDemo implements Runnable{

    /**
     * 线程名称
     */
    private String threadName;

    /**
     * 构造方法
     * @param threadName 线程名称
     */
    public RunnableDemo(String threadName) {
        this.threadName = threadName;
    }

    @Override
    public void run() {
        System.out.println(threadName + &quot; is running&quot;);
        //业务
        for (int i = 0; i &amp;lt; 5; i++) {
            System.out.println(threadName + &quot; 执行 &quot; + i);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(threadName + &quot; is exiting&quot;);
    }

    public static void main(String[] args) {

        RunnableDemo runnable1 = new RunnableDemo(&quot;thread-1&quot;);
        Thread thread1 = new Thread(runnable1);
        thread1.start();

        RunnableDemo runnable2 = new RunnableDemo(&quot;thread-2&quot;);
        Thread thread2 = new Thread(runnable2);
        thread2.start();

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一次运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;thread-1 is running
thread-1 执行 0
thread-2 is running
thread-2 执行 0
thread-2 执行 1
thread-1 执行 1
thread-2 执行 2
thread-1 执行 2
thread-1 执行 3
thread-2 执行 3
thread-1 执行 4
thread-2 执行 4
thread-2 is exiting
thread-1 is exiting
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二次运行结果如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;thread-1 is running
thread-1 执行 0
thread-2 is running
thread-2 执行 0
thread-1 执行 1
thread-2 执行 1
thread-1 执行 2
thread-2 执行 2
thread-1 执行 3
thread-2 执行 3
thread-2 执行 4
thread-1 执行 4
thread-1 is exiting
thread-2 is exiting  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出两次运行结果是不一样的,每次两个线程的执行顺序是随机的.&lt;/p&gt;
&lt;h3&gt;2.继承Thread类&lt;/h3&gt;
&lt;p&gt;创建一个线程的第二种方法是创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。&lt;/p&gt;
&lt;p&gt;继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.example.test;

/**
 * @author ydx
 */
public class ThreadDemo extends Thread {

    /**
     * 线程名称
     */
    private String threadName;

    public ThreadDemo(String threadName) {
        this.threadName = threadName;
    }

    @Override
    public synchronized void start() {
        System.out.println(threadName+ &quot; is starting......&quot;);
        super.start();
    }

    @Override
    public void run() {
        System.out.println(threadName + &quot; is running&quot;);
        //业务
        for (int i = 0; i &amp;lt; 3; i++) {
            System.out.println(threadName + &quot; 执行 &quot; + i);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.println(threadName + &quot; is exiting&quot;);
    }

    public static void main(String[] args) {
        ThreadDemo thread1 = new ThreadDemo(&quot;thread-1&quot;);
        thread1.start();

        ThreadDemo thread2 = new ThreadDemo(&quot;thread-2&quot;);
        thread2.start();

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;thread-1 is starting......
thread-2 is starting......
thread-1 is running
thread-1 执行 0
thread-2 is running
thread-2 执行 0
thread-1 执行 1
thread-2 执行 1
thread-2 执行 2
thread-1 执行 2
thread-2 is exiting
thread-1 is exiting   
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3&gt;3.通过 Callable 和 Future 创建线程&lt;/h3&gt;
&lt;ol readability=&quot;6&quot;&gt;&lt;li&gt;创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。&lt;/li&gt;
&lt;li&gt;创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。&lt;/li&gt;
&lt;li&gt;使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.example.test;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

/**
 * @author ydx
 */
public class CallableTest implements Callable&amp;lt;Integer&amp;gt; {

    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 0; i &amp;lt; 5; i++) {
            sum += i;
            System.out.println(i);
            //sleep 200ms
            Thread.sleep(200);
        }
        return sum;
    }

    public static void main(String[] args) {

        long start = System.currentTimeMillis();

        CallableTest callableTest = new CallableTest();
        FutureTask&amp;lt;Integer&amp;gt; futureTask = new FutureTask&amp;lt;&amp;gt;(callableTest);
        new Thread(futureTask, &quot;thread-1&quot;).start();

        CallableTest callableTest2 = new CallableTest();
        FutureTask&amp;lt;Integer&amp;gt; futureTask2 = new FutureTask&amp;lt;&amp;gt;(callableTest2);
        new Thread(futureTask2, &quot;thread-2&quot;).start();
        try {
            System.out.println(&quot;thread-1的结果: &quot; + futureTask.get());
            System.out.println(&quot;thread-2的结果: &quot; + futureTask.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }

        long end = System.currentTimeMillis();
        System.out.println(&quot;耗时: &quot; + (end - start) + &quot;ms&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;0
0
1
1
2
2
3
3
4
4
thread-1的结果: 10
thread-2的结果: 10
耗时: 1004ms
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们创建了两个线程, 每个线程计算0~4的和,单个线程耗时200ms * 5 = 1000ms,而最终两个线程的总耗时约1000ms,由此可见两个线程是并发进行.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;4.创建线程的三种方式的对比&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用继承 Thread 类的方式创建多线程时，编写简单，但是不够灵活&lt;/li&gt;
&lt;li&gt;采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类,创建线程比较灵活.&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;线程管理&lt;/h2&gt;
&lt;p&gt;Java提供了一些方法用于线程状态的控制。具体如下：&lt;/p&gt;
&lt;h3&gt;1.sleep(线程睡眠)&lt;/h3&gt;
&lt;p&gt;如果我们需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用Thread的sleep方法。&lt;/p&gt;
&lt;p&gt;Thread.sleep(long millis)方法，millis参数设定睡眠的时间，以毫秒为单位。当睡眠结束后，就转为就绪（Runnable）状态。&lt;/p&gt;
&lt;h3&gt;2.wait(线程等待)&lt;/h3&gt;
&lt;p&gt;Object类中的wait()方法，导致当前的线程等待，直到其他线程调用此对象的 notify() 方法或 notifyAll() 唤醒方法.&lt;/p&gt;
&lt;h3&gt;3.yield(线程让步)&lt;/h3&gt;
&lt;p&gt;Thread.yield() 方法，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。&lt;/p&gt;
&lt;p&gt;和sleep()方法不同的是，它不会进入到阻塞状态，而是进入到就绪状态。&lt;/p&gt;
&lt;p&gt;yield()方法只是让当前线程暂停一下，重新进入就绪的线程池中，让系统的线程调度器重新调度器重新调度一次，完全可能出现这样的情况：当某个线程调用yield()方法之后，线程调度器又将其调度出来重新进入到运行状态执行。&lt;/p&gt;
&lt;h3&gt;4.join(线程加入)&lt;/h3&gt;
&lt;p&gt;join()方法，等待其他线程终止。在当前线程中调用另一个线程的join()方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。&lt;/p&gt;
&lt;h3&gt;5.notify(线程唤醒)&lt;/h3&gt;
&lt;p&gt;Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争&lt;/p&gt;
&lt;h2&gt;线程的优先级&lt;/h2&gt;
&lt;p&gt;每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。&lt;/p&gt;
&lt;p&gt;Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN&lt;em&gt;PRIORITY ） - 10 （Thread.MAX&lt;/em&gt;PRIORITY ）。&lt;/p&gt;
&lt;p&gt;默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。&lt;/p&gt;
&lt;p&gt;具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。&lt;/p&gt;
&lt;h2&gt;线程池&lt;/h2&gt;
&lt;p&gt;线程池，其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。使用线程池的好处：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗.&lt;/li&gt;
&lt;li&gt;提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。&lt;/li&gt;
&lt;li&gt;提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Java通过Executors提供四种线程池，分别为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;newCachedThreadPoo 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。&lt;/li&gt;
&lt;li&gt;newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。&lt;/li&gt;
&lt;li&gt;newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。&lt;/li&gt;
&lt;li&gt;newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Sat, 31 Aug 2019 15:22:00 +0000</pubDate>
<dc:creator>iceblow</dc:creator>
<og:description>什么是进程和线程? 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。 多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。 一个进程包括由操</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/iceblow/p/11440999.html</dc:identifier>
</item>
<item>
<title>域渗透-LSA Protection - Micr067</title>
<link>http://www.cnblogs.com/micr067/p/11440992.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/micr067/p/11440992.html</guid>
<description>&lt;p&gt;简介：&lt;/p&gt;
&lt;p&gt;微软在 2014 年 3 月 12 日添加了 LSA 保护策略，用来防止对进程 lsass.exe 的代码注入，这样一来就无法使用 mimikatz 对 lsass.exe 进行注入，相关操作也会失败。&lt;/p&gt;


&lt;p&gt;适用系统：&lt;/p&gt;
&lt;p&gt;Windows 8.1&lt;/p&gt;
&lt;p&gt;Windows Server 2012 R2&lt;/p&gt;

&lt;p&gt;接下来换用 Windows Server 2012 R2 进行测试&lt;/p&gt;
&lt;p&gt;（1）配置 LSA Protection&lt;/p&gt;
&lt;p&gt;注册表位置：&lt;/p&gt;
&lt;p&gt;HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Lsa&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/4ECB5516764C468BBABE719C28ED4671/58880&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/4ECB5516764C468BBABE719C28ED4671/58880&quot;/&gt;&lt;/div&gt;
&lt;p&gt;新建-DWORD（32）值，名称为 RunAsPPL,数值为 00000001，重启系统生效。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/98D160407D964F4FA886B612A978B82F/58882&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/98D160407D964F4FA886B612A978B82F/58882&quot;/&gt;&lt;/div&gt;

&lt;p&gt;（2）测试 Skeleton Key&lt;/p&gt;
&lt;p&gt;mimikatz 命令：&lt;/p&gt;
&lt;p&gt;privilege::debug&lt;/p&gt;
&lt;p&gt;misc::skeleton&lt;/p&gt;
&lt;p&gt;未配置LSA Protection时不会报错。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/DD4176DB607A43AEBB91831FEF99BCFD/58890&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/DD4176DB607A43AEBB91831FEF99BCFD/58890&quot;/&gt;&lt;/div&gt;
&lt;p&gt;配置LSA Protection时失败报错：&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/04344D02889D4D47AEE17FAEC2B7D0CD/58899&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/04344D02889D4D47AEE17FAEC2B7D0CD/58899&quot;/&gt;&lt;/div&gt;

&lt;p&gt;（3）绕过 LSA Protection&lt;/p&gt;
&lt;p&gt;mimikatz 早在 2013 年 10 月就已支持绕过 LSA Protection&lt;/p&gt;

&lt;p&gt;注：该功能需要 mimidrv.sys 文件&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/D09BD16319364387862AF2F0F5851AF1/58913&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/D09BD16319364387862AF2F0F5851AF1/58913&quot;/&gt;&lt;/div&gt;

&lt;p&gt;mimikatz 命令：&lt;/p&gt;
&lt;p&gt;privilege::debug&lt;/p&gt;
&lt;p&gt;!+&lt;/p&gt;
&lt;p&gt;!processprotect /process:lsass.exe /remove&lt;/p&gt;
&lt;p&gt;misc::skeleton&lt;/p&gt;
&lt;p&gt;如图，导入驱动文件mimidrv.sys后，绕过 LSA Protection，操作成功&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/754881CECCAB47EA9E1B481DC82A41AB/58909&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/754881CECCAB47EA9E1B481DC82A41AB/58909&quot;/&gt;&lt;/div&gt;
&lt;p&gt;关闭LSA Protection，将RunAsPPL的值改为0重启计算机即可。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/460BAB1123304A4A886657E626A45873/58921&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/460BAB1123304A4A886657E626A45873/58921&quot;/&gt;&lt;/div&gt;

&lt;p&gt;3.补充&lt;/p&gt;
&lt;p&gt;一些常见问题的解决方法，管理员常常会禁用一些重要程序的运行，比如 cmd、regedit、taskmgr等&lt;/p&gt;
&lt;p&gt;1、如何禁用 cmd、regedit、taskmgr&lt;/p&gt;
&lt;p&gt;输入 gpedit.msc 进入本地组策略编辑器&lt;/p&gt;
&lt;p&gt;本地计算机策略-用户配置-管理模板-系统&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/955008750BEB44AD8E0FB4408B6794BA/58932&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/955008750BEB44AD8E0FB4408B6794BA/58932&quot;/&gt;&lt;/div&gt;

&lt;p&gt;禁用 cmd：&lt;/p&gt;
&lt;p&gt;选择&quot;阻止访问命令提示符&quot;-编辑---启用&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/27DE7F22AEEF4F08B25FF1BF89155CC9/58934&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/27DE7F22AEEF4F08B25FF1BF89155CC9/58934&quot;/&gt;&lt;/div&gt;
&lt;p&gt;组织命令提示符启用。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/32AFEAD42B2345ABA78E3367DC4600CC/58936&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/32AFEAD42B2345ABA78E3367DC4600CC/58936&quot;/&gt;&lt;/div&gt;
&lt;p&gt;测试：命令提示符已被管理员停用。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/CC0DA928ABF848399F04786253898A04/58939&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/CC0DA928ABF848399F04786253898A04/58939&quot;/&gt;&lt;/div&gt;

&lt;p&gt;禁用 regedit：&lt;/p&gt;
&lt;p&gt;选择阻止访问注册表编辑工具&quot;-编辑-启用&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/73C33DFF19B84599BE8F2BEEB6C182C5/58948&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/73C33DFF19B84599BE8F2BEEB6C182C5/58948&quot;/&gt;&lt;/div&gt;
&lt;p&gt;禁用 Windows 注册表编辑器 Regedit.exe。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/5A7BCAACA6904D6CB61B856FD38AD2DB/58951&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/5A7BCAACA6904D6CB61B856FD38AD2DB/58951&quot;/&gt;&lt;/div&gt;
&lt;p&gt;测试：注册表编辑器已被管理员禁用。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/ED563BB05F4443A5BD3C38355EB93AC7/58960&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/ED563BB05F4443A5BD3C38355EB93AC7/58960&quot;/&gt;&lt;/div&gt;

&lt;p&gt;禁用 taskmgr:&lt;/p&gt;
&lt;p&gt;选择&quot;不要运行指定的 Windows 应用程序&quot;-不允许的应用程序列表-填入 taskmgr.exe-启用。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/67F0589E81574D02B4231DC15A5018F1/58964&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/67F0589E81574D02B4231DC15A5018F1/58964&quot;/&gt;&lt;/div&gt;
&lt;p&gt;防止 Windows 运行在此设置中指定的程序。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/41E6A8293EFE41BB8F4F24AE6527B84D/58968&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/41E6A8293EFE41BB8F4F24AE6527B84D/58968&quot;/&gt;&lt;/div&gt;
&lt;p&gt;测试：用户无法运行已添加到不允许的应用程序列表的程序。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/297633EF62674261B8B063689C351FD1/58976&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/297633EF62674261B8B063689C351FD1/58976&quot;/&gt;&lt;/div&gt;
&lt;p&gt;经测试 cmd、regedit、taskmgr 均已被禁用。&lt;/p&gt;

&lt;p&gt;2、绕过&lt;/p&gt;
&lt;p&gt;mimikatz 命令：&lt;/p&gt;
&lt;p&gt;privilege::debug&lt;/p&gt;
&lt;p&gt;misc::cmd&lt;/p&gt;
&lt;p&gt;misc::regedit&lt;/p&gt;
&lt;p&gt;misc::taskmgr&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/D72A7114D118486596B7D69B2CDAB419/58980&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/D72A7114D118486596B7D69B2CDAB419/58980&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/8210EEEF626E49FE8BC709129213452A/58983&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/8210EEEF626E49FE8BC709129213452A/58983&quot;/&gt;&lt;/div&gt;

&lt;div&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/1374D87CCC81484C86D513BB7BBAD25B/58986&quot; alt=&quot;&quot; data-media-type=&quot;image&quot; data-original=&quot;https://note.youdao.com/yws/public/resource/6ef6030c74d29f1c9c16eac5a754bd28/xmlnote/1374D87CCC81484C86D513BB7BBAD25B/58986&quot;/&gt;&lt;/div&gt;
&lt;p&gt;成功执行，绕过限制。&lt;/p&gt;

&lt;p&gt;做自己想做的，不要活给别人看。&lt;/p&gt;

</description>
<pubDate>Sat, 31 Aug 2019 15:20:00 +0000</pubDate>
<dc:creator>Micr067</dc:creator>
<og:description>简介： 微软在 2014 年 3 月 12 日添加了 LSA 保护策略，用来防止对进程 lsass.exe 的代码注入，这样一来就无法使用 mimikatz 对 lsass.exe 进行注入，相关操作</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/micr067/p/11440992.html</dc:identifier>
</item>
<item>
<title>【原创】（二）Linux物理内存初始化 - LoyenWang</title>
<link>http://www.cnblogs.com/LoyenWang/p/11440957.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LoyenWang/p/11440957.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;code&gt;Read the fucking source code!&lt;/code&gt; --By 鲁迅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A picture is worth a thousand words.&lt;/code&gt; --By 高尔基&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Kernel版本：4.14&lt;/li&gt;
&lt;li&gt;ARM64处理器，Contex-A53，双核&lt;/li&gt;
&lt;li&gt;使用工具：Source Insight 3.5， Visio&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;让我们思考几个朴素的问题？&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;系统是怎么知道物理内存的？&lt;/li&gt;
&lt;li&gt;在内存管理真正初始化之前，内核的代码执行需要分配内存该怎么处理？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们先来尝试回答第一个问题，看过&lt;code&gt;dts&lt;/code&gt;文件的同学应该见过&lt;code&gt;memory&lt;/code&gt;的节点，以&lt;code&gt;arch/arm64/boot/dts/freescale/fsl-ls208xa.dtsi&lt;/code&gt;为例：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;    memory@80000000 {
        device_type = &quot;memory&quot;;
        reg = &amp;lt;0x00000000 0x80000000 0 0x80000000&amp;gt;;
              /* DRAM space - 1, size : 2 GB DRAM */
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个节点描述了内存的起始地址及大小，事实上内核在解析&lt;code&gt;dtb&lt;/code&gt;文件时会去读取该&lt;code&gt;memory&lt;/code&gt;节点的内容，从而将检测到的内存注册进系统。&lt;/p&gt;
&lt;p&gt;那么新的问题又来了？Uboot会将&lt;code&gt;kernel image&lt;/code&gt;和&lt;code&gt;dtb&lt;/code&gt;拷贝到内存中，并且将&lt;code&gt;dtb物理地址&lt;/code&gt;告知&lt;code&gt;kernel&lt;/code&gt;，&lt;code&gt;kernel&lt;/code&gt;需要从该物理地址上读取到&lt;code&gt;dtb&lt;/code&gt;文件并解析，才能得到最终的内存信息，&lt;code&gt;dtb&lt;/code&gt;的物理地址需要映射到虚拟地址上才能访问，但是这个时候&lt;code&gt;paging_init&lt;/code&gt;还没有调用，也就是说物理地址的映射还没有完成，那该怎么办呢？没错，&lt;code&gt;Fixed map&lt;/code&gt;机制出现了。&lt;/p&gt;
&lt;p&gt;第二个问题答案：当所有物理内存添加进系统后，在&lt;code&gt;mm_init&lt;/code&gt;之前，系统会使用&lt;code&gt;memblock&lt;/code&gt;模块来对内存进行管理。&lt;/p&gt;
&lt;p&gt;开启探索之旅吧！&lt;/p&gt;

&lt;p&gt;简单来说，&lt;code&gt;Fixed map&lt;/code&gt;指的是虚拟地址中的一段区域，在该区域中所有的线性地址是在编译阶段就确定好的，这些虚拟地址需要在&lt;code&gt;boot&lt;/code&gt;阶段去映射到物理地址上。&lt;br/&gt;来张图片看看虚拟地址空间：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201908/1771657-20190831230820193-922578847.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图中&lt;code&gt;fixed: 0xffffffbefe7fd000 - 0xffffffbefec00000&lt;/code&gt;，描述的就是&lt;code&gt;Fixed map&lt;/code&gt;的区域。&lt;/p&gt;
&lt;p&gt;那么这段区域中的详细一点的布局是怎样呢？看看&lt;code&gt;arch/arm64/include/asm/fixmap.h&lt;/code&gt;中的&lt;code&gt;enum fixed_address&lt;/code&gt;结构就清晰了，图来了：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201908/1771657-20190831230833457-192209033.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中可以看出，如果要访问&lt;code&gt;DTB&lt;/code&gt;所在的物理地址，那么需要将该物理地址映射到&lt;code&gt;Fixed map&lt;/code&gt;中的区域，然后访问该区域中的虚拟地址即可。访问&lt;code&gt;IO&lt;/code&gt;空间也是一样的道理，下文也会讲述到。&lt;/p&gt;
&lt;p&gt;那么来看看&lt;code&gt;early_fixmap_init&lt;/code&gt;函数的关键代码吧：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;void __init early_fixmap_init(void)
{
    pgd_t *pgd;
    pud_t *pud;
    pmd_t *pmd;
    unsigned long addr = FIXADDR_START;              /* (1) */

    pgd = pgd_offset_k(addr);           /* (2) */
    if (CONFIG_PGTABLE_LEVELS &amp;gt; 3 &amp;amp;&amp;amp;
        !(pgd_none(*pgd) || pgd_page_paddr(*pgd) == __pa_symbol(bm_pud))) {
        /*
         * We only end up here if the kernel mapping and the fixmap
         * share the top level pgd entry, which should only happen on
         * 16k/4 levels configurations.
         */
        BUG_ON(!IS_ENABLED(CONFIG_ARM64_16K_PAGES));
        pud = pud_offset_kimg(pgd, addr);
    } else {
        if (pgd_none(*pgd))
            __pgd_populate(pgd, __pa_symbol(bm_pud), PUD_TYPE_TABLE);          /* (3) */
        pud = fixmap_pud(addr);
    }
    if (pud_none(*pud))
        __pud_populate(pud, __pa_symbol(bm_pmd), PMD_TYPE_TABLE);    /* (4) */
    pmd = fixmap_pmd(addr);
    __pmd_populate(pmd, __pa_symbol(bm_pte), PMD_TYPE_TABLE);        /* (5) */
......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;FIXADDR_START&lt;/code&gt;，定义了&lt;code&gt;Fixed map&lt;/code&gt;区域的起始地址，位于&lt;code&gt;arch/arm64/include/asm/fixmap.h&lt;/code&gt;中；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pgd_offset_k(addr)&lt;/code&gt;，获取&lt;code&gt;addr&lt;/code&gt;地址对应pgd全局页表中的&lt;code&gt;entry&lt;/code&gt;，而这个pgd全局页表正是&lt;code&gt;swapper_pg_dir&lt;/code&gt;全局页表；&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;bm_pud&lt;/code&gt;的物理地址写到pgd全局页目录表中；&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;bm_pmd&lt;/code&gt;的物理地址写到pud页目录表中；&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;bm_pte&lt;/code&gt;的物理地址写到pmd页表目录表中；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;code&gt;bm_pud/bm_pmd/bm_pte&lt;/code&gt;是三个全局数组，相当于是中间的页表，存放各级页表的&lt;code&gt;entry&lt;/code&gt;，定义如下：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static pte_t bm_pte[PTRS_PER_PTE] __page_aligned_bss;
static pmd_t bm_pmd[PTRS_PER_PMD] __page_aligned_bss __maybe_unused;
static pud_t bm_pud[PTRS_PER_PUD] __page_aligned_bss __maybe_unused;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;事实上，&lt;code&gt;early_fixmap_init&lt;/code&gt;只是建立了一个映射的框架，具体的物理地址和虚拟地址的映射没有去填充，这个是由使用者具体在使用时再去填充对应的&lt;code&gt;pte entry&lt;/code&gt;。比如像&lt;code&gt;fixmap_remap_fdt()&lt;/code&gt;函数，就是典型的填充&lt;code&gt;pte entry&lt;/code&gt;的过程，完成最后的一步映射，然后才能读取&lt;code&gt;dtb&lt;/code&gt;文件。&lt;/p&gt;
&lt;p&gt;来一张图片就懂了，是透彻的懂了：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201908/1771657-20190831230908465-1716112257.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;如果在boot早期需要操作&lt;code&gt;IO设备&lt;/code&gt;的话，那么&lt;code&gt;ioremap&lt;/code&gt;就用上场了，由于跟实际的内存管理关系不太大，不再太深入的分析。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201908/1771657-20190831230921079-800174381.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;简单来说，&lt;code&gt;ioremap&lt;/code&gt;的空间为&lt;code&gt;7 * 256K&lt;/code&gt;的区域，保存在&lt;code&gt;slot_vir[]&lt;/code&gt;数组中，当需要进行IO操作的时候，最终会调用到&lt;code&gt;__early_ioremap&lt;/code&gt;函数，在该函数中去填充对应的&lt;code&gt;pte entry&lt;/code&gt;，从而完成最终的虚拟地址和物理地址的映射。&lt;/p&gt;

&lt;p&gt;上文讲的内容都只是铺垫，为了能正确访问&lt;code&gt;DTB&lt;/code&gt;文件并且解析得到物理地址信息。从入口到最终添加的调用过程如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201908/1771657-20190831230939571-1284272879.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，这个章节的重点就是&lt;code&gt;memblock&lt;/code&gt;模块，这个是早期的内存分配管理器，我不禁想起了之前在&lt;code&gt;Nuttx&lt;/code&gt;中的内存池实现了，细节已然不太清晰了，但是框架性的思维都大同小异。&lt;/p&gt;
&lt;h2 id=&quot;结构体&quot;&gt;4.1 结构体&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201908/1771657-20190831230951533-1144378625.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总共由三个数据结构来描述：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;struct memblock&lt;/code&gt;定义了一个全局变量，用来维护所有的物理内存；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct memblock_type&lt;/code&gt;代表系统中的内存类型，包括实际使用的内存和保留的内存；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct memblock_region&lt;/code&gt;用来描述具体的内存区域，包含在&lt;code&gt;struct memblock_type&lt;/code&gt;中的&lt;code&gt;regions&lt;/code&gt;数组中，最多可以存放128个。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;直接上个代码吧：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;static struct memblock_region memblock_memory_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
static struct memblock_region memblock_reserved_init_regions[INIT_MEMBLOCK_REGIONS] __initdata_memblock;
#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP
static struct memblock_region memblock_physmem_init_regions[INIT_PHYSMEM_REGIONS] __initdata_memblock;
#endif

struct memblock memblock __initdata_memblock = {
    .memory.regions     = memblock_memory_init_regions,
    .memory.cnt     = 1,    /* empty dummy entry */
    .memory.max     = INIT_MEMBLOCK_REGIONS,
    .memory.name        = &quot;memory&quot;,

    .reserved.regions   = memblock_reserved_init_regions,
    .reserved.cnt       = 1,    /* empty dummy entry */
    .reserved.max       = INIT_MEMBLOCK_REGIONS,
    .reserved.name      = &quot;reserved&quot;,

#ifdef CONFIG_HAVE_MEMBLOCK_PHYS_MAP
    .physmem.regions    = memblock_physmem_init_regions,
    .physmem.cnt        = 1,    /* empty dummy entry */
    .physmem.max        = INIT_PHYSMEM_REGIONS,
    .physmem.name       = &quot;physmem&quot;,
#endif

    .bottom_up      = false,
    .current_limit      = MEMBLOCK_ALLOC_ANYWHERE,
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;定义的&lt;code&gt;memblock&lt;/code&gt;为全局变量，在定义的时候就进行了初始化。初始化的时候，&lt;code&gt;regions&lt;/code&gt;指向的也是静态全局的数组，其中数组的大小为&lt;code&gt;INIT_MEMBLOCK_REGIONS&lt;/code&gt;，也就是128个，限制了这些内存块的个数了，实际在代码中可以看到，当超过这个数值时，数组会以2倍的速度动态扩大。&lt;/p&gt;
&lt;p&gt;初始化完了后，大体是这个样子的：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201908/1771657-20190831231009959-359564492.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;memblock_addmemblock_remove&quot;&gt;4.2 memblock_add/memblock_remove&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;memblock&lt;/code&gt;子模块，基本的逻辑都是围绕内存的添加和移除操作来展开，最终是通过调用&lt;code&gt;memblock_add_range/memblock_remove_range&lt;/code&gt;来实现的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;memblock_add_range&lt;/code&gt;：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201908/1771657-20190831231022912-53426271.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图中的左侧是函数的执行流程图，执行效果是右侧部分。右侧部分画的是一个典型的情况，实际的情况可能有多种，但是核心的逻辑都是对插入的&lt;code&gt;region&lt;/code&gt;进行判断，如果出现了物理地址范围重叠的部分，那就进行&lt;code&gt;split&lt;/code&gt;操作，最终对具有相同&lt;code&gt;flag&lt;/code&gt;的&lt;code&gt;region&lt;/code&gt;进行&lt;code&gt;merge&lt;/code&gt;操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;memblock_remove_range&lt;/code&gt;&lt;br/&gt;该函数执行的一个典型case效果如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201908/1771657-20190831231035612-804455093.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;假如现在需要移除掉一片区域，而该区域跨越了多个&lt;code&gt;region&lt;/code&gt;，则会先调用&lt;code&gt;memblock_isolate_range&lt;/code&gt;来对这片区域进行切分，最后再调用&lt;code&gt;memblock_isolate_range&lt;/code&gt;对区域范围内的&lt;code&gt;region&lt;/code&gt;进行移除操作。&lt;/p&gt;
&lt;p&gt;当调用&lt;code&gt;memblock_alloc&lt;/code&gt;函数进行地址分配时，最后也是调用&lt;code&gt;memblock_add_range&lt;/code&gt;来实现的，申请的这部分内存最终会添加到&lt;code&gt;reserved&lt;/code&gt;类型中，毕竟已经分配出去了，其他人也不应该使用了。&lt;/p&gt;

&lt;p&gt;当物理内存都添加进系统之后，&lt;code&gt;arm64_memblock_init&lt;/code&gt;会对整个物理内存进行整理，主要的工作就是将一些特殊的区域添加进&lt;code&gt;reserved&lt;/code&gt;内存中。函数执行完后，如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201908/1771657-20190831231053115-543452290.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;其中浅绿色的框表示的都是保留的内存区域， 剩下的部分就是可以实际去使用的内存了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;物理内存大体面貌就有了，后续就需要进行内存的页表映射，完成实际的物理地址到虚拟地址的映射了。&lt;/p&gt;
&lt;p&gt;那就待续吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771657/201908/1771657-20190831231130817-144486634.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 31 Aug 2019 15:13:00 +0000</pubDate>
<dc:creator>LoyenWang</dc:creator>
<og:description>背景 By 鲁迅 By 高尔基 说明： 1. Kernel版本：4.14 2. ARM64处理器，Contex A53，双核 3. 使用工具：Source Insight 3.5， Visio 1.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LoyenWang/p/11440957.html</dc:identifier>
</item>
<item>
<title>成为高级程序员不得不了解的并发 - c旋儿</title>
<link>http://www.cnblogs.com/cxuanBlog/p/11440959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cxuanBlog/p/11440959.html</guid>
<description>&lt;p&gt;到目前为止，你学到的都是顺序编程，顺序编程的概念就是某一时刻只有一个任务在执行，顺序编程固然能够解决很多问题，但是对于某种任务，如果能够并发的执行程序中重要的部分就显得尤为重要，同时也可以极大提高程序运行效率，享受并发为你带来的便利。但是，熟练掌握并发编程理论和技术，对于只会CRUD的你来说是一种和你刚学面向对象一样的一种飞跃。&lt;/p&gt;
&lt;p&gt;正如你所看到的，当并行的任务彼此干涉时，实际的并发问题就会接踵而至。而且并发问题不是很难复现，在你实际的测试过程中往往会忽略它们，因为故障是偶尔发生的，这也是我们研究它们的必要条件：如果你对并发问题置之不理，那么你最终会承受它给你带来的损害。&lt;/p&gt;
&lt;h2 id=&quot;并发的多面性&quot;&gt;并发的多面性&lt;/h2&gt;
&lt;h3 id=&quot;更快的执行&quot;&gt;更快的执行&lt;/h3&gt;
&lt;p&gt;速度问题听起来很简单，如果你想让一个程序运行的更快一些，那么可以将其切成多个分片，在单独的处理器上运行各自的分片：前提是这些任务彼此之间没有联系。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意：速度的提高是以多核处理器而不是芯片的形式出现的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你有一台多处理器的机器，那么你就可以在这些处理器之间分布多个任务，从而极大的提高吞吐量。&lt;strong&gt;但是，并发通常是提高在单处理器上的程序的性能。&lt;/strong&gt;在单处理上的性能开销要比多处理器上的性能开销大很多，因为这其中增加了&lt;code&gt;线程切换&lt;/code&gt;(从一个线程切换到另外一个线程)的重要依据。表面上看，将程序的所有部分当作单个的任务运行好像是开销更小一点，节省了线程切换的时间。&lt;/p&gt;
&lt;h3 id=&quot;改进代码的设计&quot;&gt;改进代码的设计&lt;/h3&gt;
&lt;p&gt;在单CPU机器上使用多任务的程序在任意时刻仍旧只在执行一项工作，你肉眼观察到控制台的输出好像是这些线程在同时工作，这不过是CPU的障眼法罢了，CPU为每个任务都提供了不固定的时间切片。Java 的线程机制是抢占式的，也就是说，你必须编写某种让步语句才会让线程进行切换，切换给其他线程。&lt;/p&gt;
&lt;h2 id=&quot;基本的线程机制&quot;&gt;基本的线程机制&lt;/h2&gt;
&lt;p&gt;并发编程使我们可以将程序划分成多个分离的，独立运行的任务。通过使用多线程机制，这些独立任务中的每一项任务都由&lt;code&gt;执行线程&lt;/code&gt;来驱动。一个线程就是进程中的一个单一的顺序控制流。因此，单个进程可以拥有多个并发执行的任务，但是你的程序看起来每个任务都有自己的CPU一样。其底层是切分CPU时间，通常你不需要考虑它。&lt;/p&gt;
&lt;h3 id=&quot;定义任务&quot;&gt;定义任务&lt;/h3&gt;
&lt;p&gt;线程可以驱动任务，因此你需要一种描述任务的方式，这可以由 &lt;code&gt;Runnable&lt;/code&gt; 接口来提供，要想定义任务，只需要实现 Runnable 接口，并在&lt;code&gt;run&lt;/code&gt; 方法中实现你的逻辑即可。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestThread implements Runnable{

    public static int i = 0;

    @Override
    public void run() {
        System.out.println(&quot;start thread...&quot; + i);
        i++;
        System.out.println(&quot;end thread ...&quot; + i);
    }

    public static void main(String[] args) {
        for(int i = 0;i &amp;lt; 5;i++){
            TestThread testThread = new TestThread();
            testThread.run();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;任务 run 方法会有某种形式的循环，使得任务一直运行下去直到不再需要，所以要设定 run 方法的跳出条件(有一种选择是从 run 中直接返回，下面会说到。)&lt;/p&gt;
&lt;p&gt;在 run 中使用静态方法 &lt;code&gt;Thread.yield()&lt;/code&gt; 可以使用线程调度，它的意思是建议线程机制进行切换：你已经执行完重要的部分了，剩下的交给其他线程跑一跑吧。注意是建议执行，而不是强制执行。在下面添加 Thread.yield() 你会看到有意思的输出&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void run() {
  System.out.println(&quot;start thread...&quot; + i);
  i++;
  Thread.yield();
  System.out.println(&quot;end thread ...&quot; + i);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;thread-类&quot;&gt;Thread 类&lt;/h3&gt;
&lt;p&gt;将 Runnable 转变工作方式的传统方式是使用 Thread 类托管他，下面展示了使用 Thread 类来实现一个线程。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
  for(int i = 0;i &amp;lt; 5;i++){
    Thread t = new Thread(new TestThread());
    t.start();
  }
  System.out.println(&quot;Waiting thread ...&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Thread 构造器只需要一个 Runnable 对象，调用 Thread 对象的 start() 方法为该线程执行必须的初始化操作，然后调用 Runnable 的 run 方法，以便在这个线程中启动任务。可以看到，在 run 方法还没有结束前，run 就被返回了。也就是说，程序不会等到 run 方法执行完毕就会执行下面的指令。&lt;/p&gt;
&lt;p&gt;在 run 方法中打印出每个线程的名字，就更能看到不同的线程的切换和调度&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Override
public void run() {
  System.out.println(Thread.currentThread() + &quot;start thread...&quot; + i);
  i++;
  System.out.println(Thread.currentThread() + &quot;end thread ...&quot; + i);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种线程切换和调度是交由 &lt;code&gt;线程调度器&lt;/code&gt; 来自动控制的，如果你的机器上有多个处理器，线程调度器会在这些处理器之间默默的分发线程。每一次的运行结果都不尽相同，因为线程调度机制是未确定的。&lt;/p&gt;
&lt;h3 id=&quot;使用-executor&quot;&gt;使用 Executor&lt;/h3&gt;
&lt;h4 id=&quot;cachedthreadpool&quot;&gt;CachedThreadPool&lt;/h4&gt;
&lt;p&gt;JDK1.5 的&lt;strong&gt;java.util.concurrent&lt;/strong&gt; 包中的执行器 &lt;strong&gt;Executor&lt;/strong&gt; 将为你管理 Thread 对象，从而简化了并发编程。Executor 在客户端和任务之间提供了一个间接层；与客户端直接执行任务不同，这个中介对象将执行任务。Executor 允许你管理异步任务的执行，而无须显示地管理线程的生命周期。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
  ExecutorService service = Executors.newCachedThreadPool();
  for(int i = 0;i &amp;lt; 5;i++){
    service.execute(new TestThread());
  }
  service.shutdown();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们使用 Executor 来替代上述显示创建 Thread 对象。&lt;code&gt;CachedThreadPool&lt;/code&gt; 为每个任务都创建一个线程。注意：ExecutorService 对象是使用静态的 &lt;code&gt;Executors&lt;/code&gt; 创建的，这个方法可以确定 Executor 类型。对 &lt;code&gt;shutDown&lt;/code&gt; 的调用可以防止新任务提交给 ExecutorService ，这个线程在 Executor 中所有任务完成后退出。&lt;/p&gt;
&lt;h4 id=&quot;fixedthreadpool&quot;&gt;FixedThreadPool&lt;/h4&gt;
&lt;p&gt;FixedThreadPool 使你可以使用有限的线程集来启动多线程&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
  ExecutorService service = Executors.newFixedThreadPool(5);
  for(int i = 0;i &amp;lt; 5;i++){
    service.execute(new TestThread());
  }
  service.shutdown();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了 FixedThreadPool 使你可以一次性的预先执行高昂的线程分配，因此也就可以限制线程的数量。这可以节省时间，因为你不必为每个任务都固定的付出创建线程的开销。&lt;/p&gt;
&lt;h4 id=&quot;singlethreadexecutor&quot;&gt;SingleThreadExecutor&lt;/h4&gt;
&lt;p&gt;SingleThreadExecutor 就是线程数量为 1 的 FixedThreadPool，如果向 SingleThreadPool 一次性提交了多个任务，那么这些任务将会排队，每个任务都会在下一个任务开始前结束，所有的任务都将使用相同的线程。SingleThreadPool 会序列化所有提交给他的任务，并会维护它自己(隐藏)的悬挂队列。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void main(String[] args) {
  ExecutorService service = Executors.newSingleThreadExecutor();
  for(int i = 0;i &amp;lt; 5;i++){
    service.execute(new TestThread());
  }
  service.shutdown();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从输出的结果就可以看到，任务都是挨着执行的。我为任务分配了五个线程，但是这五个线程不像是我们之前看到的有换进换出的效果，它每次都会先执行完自己的那个线程，然后余下的线程继续“走完”这条线程的执行路径。你可以用 SingleThreadExecutor 来确保任意时刻都只有唯一一个任务在运行。&lt;/p&gt;
&lt;h3 id=&quot;从任务中产生返回值&quot;&gt;从任务中产生返回值&lt;/h3&gt;
&lt;p&gt;Runnable 是执行工作的独立任务，但它不返回任何值。如果你希望任务在完成时能够返回一个值 ，这个时候你就需要考虑使用 &lt;code&gt;Callable&lt;/code&gt; 接口，它是 JDK1.5 之后引入的，通过调用它的 &lt;code&gt;submit&lt;/code&gt; 方法，可以把它的返回值放在一个 Future 对象中，然后根据相应的 get() 方法取得提交之后的返回值。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TaskWithResult implements Callable&amp;lt;String&amp;gt; {

    private int id;

    public TaskWithResult(int id){
        this.id = id;
    }

    @Override
    public String call() throws Exception {
        return &quot;result of TaskWithResult &quot; + id;
    }
}

public class CallableDemo {

    public static void main(String[] args) throws ExecutionException, InterruptedException {
        ExecutorService executors = Executors.newCachedThreadPool();
        ArrayList&amp;lt;Future&amp;lt;String&amp;gt;&amp;gt; future = new ArrayList&amp;lt;&amp;gt;();
        for(int i = 0;i &amp;lt; 10;i++){

            // 返回的是调用 call 方法的结果
            future.add(executors.submit(new TaskWithResult(i)));
        }
        for(Future&amp;lt;String&amp;gt; fs : future){
            System.out.println(fs.get());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;submit() 方法会返回 Future 对象，Future 对象存储的也就是你返回的结果。你也可以使用 &lt;code&gt;isDone&lt;/code&gt; 来查询 Future 是否已经完成。&lt;/p&gt;
&lt;h3 id=&quot;休眠&quot;&gt;休眠&lt;/h3&gt;
&lt;p&gt;影响任务行为的一种简单方式就是使线程 休眠，选定给定的休眠时间，调用它的 &lt;code&gt;sleep()&lt;/code&gt; 方法， 一般使用的&lt;code&gt;TimeUnit&lt;/code&gt; 这个时间类替换 &lt;code&gt;Thread.sleep()&lt;/code&gt; 方法，示例如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SuperclassThread extends TestThread{

    @Override
    public void run() {
        System.out.println(Thread.currentThread() + &quot;starting ...&quot; );

        try {
            for(int i = 0;i &amp;lt; 5;i++){
                if(i == 3){
                    System.out.println(Thread.currentThread() + &quot;sleeping ...&quot;);
                    TimeUnit.MILLISECONDS.sleep(1000);
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        System.out.println(Thread.currentThread() + &quot;wakeup and end ...&quot;);
    }

    public static void main(String[] args) {
        ExecutorService executors = Executors.newCachedThreadPool();
        for(int i = 0;i &amp;lt; 5;i++){
            executors.execute(new SuperclassThread());
        }
        executors.shutdown();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;关于 TimeUnit 中的 sleep() 方法和 Thread.sleep() 方法的比较，请参考下面这篇博客&lt;/p&gt;
&lt;p&gt;(https://www.cnblogs.com/xiadongqing/p/9925567.html)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;优先级&quot;&gt;优先级&lt;/h3&gt;
&lt;p&gt;上面提到线程调度器对每个线程的执行都是不可预知的，随机执行的，那么有没有办法告诉线程调度器哪个任务想要优先被执行呢？你可以通过设置线程的优先级状态，告诉线程调度器哪个线程的执行优先级比较高，&quot;请给这个骑手马上派单&quot;，线程调度器倾向于让优先级较高的线程优先执行，然而，这并不意味着优先级低的线程得不到执行，也就是说，优先级不会导致死锁的问题。优先级较低的线程只是执行频率较低。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SimplePriorities implements Runnable{

    private int priority;

    public SimplePriorities(int priority) {
        this.priority = priority;
    }

    @Override
    public void run() {
        Thread.currentThread().setPriority(priority);
        for(int i = 0;i &amp;lt; 100;i++){
            System.out.println(this);
            if(i % 10 == 0){
                Thread.yield();
            }
        }
    }

    @Override
    public String toString() {
        return Thread.currentThread() + &quot; &quot; + priority;
    }

    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool();
        for(int i = 0;i &amp;lt; 5;i++){
            service.execute(new SimplePriorities(Thread.MAX_PRIORITY));
        }
        service.execute(new SimplePriorities(Thread.MIN_PRIORITY));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;toString() 方法被覆盖，以便通过使用 &lt;code&gt;Thread.toString()&lt;/code&gt; 方法来打印线程的名称。你可以改写线程的默认输出，这里采用了 &lt;strong&gt;Thread[pool-1-thread-1,10,main]&lt;/strong&gt; 这种形式的输出。&lt;/p&gt;
&lt;p&gt;通过输出，你可以看到，最后一个线程的优先级最低，其余的线程优先级最高。注意，优先级是在 run 开头设置的，在构造器中设置它们不会有任何好处，因为这个时候线程还没有执行任务。&lt;/p&gt;
&lt;p&gt;尽管JDK有10个优先级，但是一般只有&lt;strong&gt;MAX_PRIORITY，NORM_PRIORITY，MIN_PRIORITY&lt;/strong&gt; 三种级别。&lt;/p&gt;
&lt;h3 id=&quot;作出让步&quot;&gt;作出让步&lt;/h3&gt;
&lt;p&gt;我们上面提过，如果知道一个线程已经在 run() 方法中运行的差不多了，那么它就可以给线程调度器一个提示：我已经完成了任务中最重要的部分，可以让给别的线程使用CPU了。这个暗示将通过 yield() 方法作出。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;有一个很重要的点就是，Thread.yield() 是建议执行切换CPU，而不是强制执行CPU切换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于任何重要的控制或者在调用应用时，都不能依赖于 &lt;code&gt;yield()&lt;/code&gt;方法，实际上， yield() 方法经常被滥用。&lt;/p&gt;
&lt;h3 id=&quot;后台线程&quot;&gt;后台线程&lt;/h3&gt;
&lt;p&gt;后台(daemon) 线程，是指运行时在后台提供的一种服务线程，这种线程不是属于必须的。当所有非后台线程结束时，程序也就停止了，&lt;strong&gt;同时会终止所有的后台线程。&lt;/strong&gt;反过来说，只要有任何非后台线程还在运行，程序就不会终止。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class SimpleDaemons implements Runnable{

    @Override
    public void run() {
        while (true){
            try {
                TimeUnit.MILLISECONDS.sleep(100);
                System.out.println(Thread.currentThread() + &quot; &quot; + this);
            } catch (InterruptedException e) {
                System.out.println(&quot;sleep() interrupted&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        for(int i = 0;i &amp;lt; 10;i++){
            Thread daemon = new Thread(new SimpleDaemons());
            daemon.setDaemon(true);
            daemon.start();
        }
        System.out.println(&quot;All Daemons started&quot;);
        TimeUnit.MILLISECONDS.sleep(175);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在每次的循环中会创建10个线程，并把每个线程设置为后台线程，然后开始运行，for循环会进行十次，然后输出信息，随后主线程睡眠一段时间后停止运行。在每次run 循环中，都会打印当前线程的信息，主线程运行完毕，程序就执行完毕了。因为 &lt;code&gt;daemon&lt;/code&gt; 是后台线程，无法影响主线程的执行。&lt;/p&gt;
&lt;p&gt;但是当你把 &lt;code&gt;daemon.setDaemon(true)&lt;/code&gt; 去掉时，while(true) 会进行无限循环，那么主线程一直在执行最重要的任务，所以会一直循环下去无法停止。&lt;/p&gt;
&lt;h3 id=&quot;threadfactory&quot;&gt;ThreadFactory&lt;/h3&gt;
&lt;p&gt;按需要创建线程的对象。使用线程工厂替换了 Thread 或者 Runnable 接口的硬连接，使程序能够使用特殊的线程子类，优先级等。一般的创建方式为&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class SimpleThreadFactory implements ThreadFactory {
  public Thread newThread(Runnable r) {
    return new Thread(r);
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Executors.defaultThreadFactory 方法提供了一个更有用的简单实现，它在返回之前将创建的线程上下文设置为已知值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ThreadFactory 是一个接口，它只有一个方法就是创建线程的方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface ThreadFactory {

    // 构建一个新的线程。实现类可能初始化优先级，名称，后台线程状态和 线程组等
    Thread newThread(Runnable r);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面来看一个 ThreadFactory 的例子&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DaemonThreadFactory implements ThreadFactory {

    @Override
    public Thread newThread(Runnable r) {
        Thread t = new Thread(r);
        t.setDaemon(true);
        return t;
    }
}

public class DaemonFromFactory implements Runnable{

    @Override
    public void run() {
        while (true){
            try {
                TimeUnit.MILLISECONDS.sleep(100);
                System.out.println(Thread.currentThread() + &quot; &quot; + this);
            } catch (InterruptedException e) {
                System.out.println(&quot;Interrupted&quot;);
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        ExecutorService service = Executors.newCachedThreadPool(new DaemonThreadFactory());
        for(int i = 0;i &amp;lt; 10;i++){
            service.execute(new DaemonFromFactory());
        }
        System.out.println(&quot;All daemons started&quot;);
        TimeUnit.MILLISECONDS.sleep(500);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Executors.newCachedThreadPool&lt;/code&gt; 可以接受一个线程池对象，创建一个根据需要创建新线程的线程池，但会在它们可用时重用先前构造的线程，并在需要时使用提供的ThreadFactory创建新线程。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) {
  return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                60L, TimeUnit.SECONDS,
                                new SynchronousQueue&amp;lt;Runnable&amp;gt;(),
                                threadFactory);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;加入一个线程&quot;&gt;加入一个线程&lt;/h3&gt;
&lt;p&gt;一个线程可以在其他线程上调用 &lt;code&gt;join()&lt;/code&gt; 方法，其效果是等待一段时间直到第二个线程结束才正常执行。如果某个线程在另一个线程 t 上调用 t.join() 方法，此线程将被挂起，直到目标线程 t 结束才回复(可以用 t.isAlive() 返回为真假判断)。&lt;/p&gt;
&lt;p&gt;也可以在调用 join 时带上一个超时参数，来设置到期时间，时间到期，join方法自动返回。&lt;/p&gt;
&lt;p&gt;对 join 的调用也可以被中断，做法是在线程上调用 &lt;code&gt;interrupted&lt;/code&gt; 方法，这时需要用到 try...catch 子句&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class TestJoinMethod extends Thread{

    @Override
    public void run() {
        for(int i = 0;i &amp;lt; 5;i++){
            try {
                TimeUnit.MILLISECONDS.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println(&quot;Interrupted sleep&quot;);
            }
            System.out.println(Thread.currentThread() + &quot; &quot; + i);
        }
    }

    public static void main(String[] args) throws InterruptedException {
        TestJoinMethod join1 = new TestJoinMethod();
        TestJoinMethod join2 = new TestJoinMethod();
        TestJoinMethod join3 = new TestJoinMethod();

        join1.start();
//        join1.join();

        join2.start();
        join3.start();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;join() 方法等待线程死亡。 换句话说，它会导致当前运行的线程停止执行，直到它加入的线程完成其任务。&lt;/p&gt;
&lt;h3 id=&quot;线程异常捕获&quot;&gt;线程异常捕获&lt;/h3&gt;
&lt;p&gt;由于线程的本质，使你不能捕获从线程中逃逸的异常，一旦异常逃出任务的run 方法，它就会向外传播到控制台，除非你采取特殊的步骤捕获这种错误的异常，在 Java5 之前，你可以通过线程组来捕获，但是在 Java5 之后，就需要用 Executor 来解决问题，因为线程组不是一次好的尝试。&lt;/p&gt;
&lt;p&gt;下面的任务会在 run 方法的执行期间抛出一个异常，并且这个异常会抛到 run 方法的外面，而且 main 方法无法对它进行捕获&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ExceptionThread implements Runnable{

    @Override
    public void run() {
        throw new RuntimeException();
    }

    public static void main(String[] args) {
        try {
            ExecutorService service = Executors.newCachedThreadPool();
            service.execute(new ExceptionThread());
        }catch (Exception e){
            System.out.println(&quot;eeeee&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了解决这个问题，我们需要修改 Executor 产生线程的方式，Java5 提供了一个新的接口 &lt;code&gt;Thread.UncaughtExceptionHandler&lt;/code&gt; ，它允许你在每个 Thread 上都附着一个异常处理器。&lt;code&gt;Thread.UncaughtExceptionHandler.uncaughtException()&lt;/code&gt; 会在线程因未捕获临近死亡时被调用。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ExceptionThread2 implements Runnable{

    @Override
    public void run() {
        Thread t = Thread.currentThread();
        System.out.println(&quot;run() by &quot; + t);
        System.out.println(&quot;eh = &quot; + t.getUncaughtExceptionHandler());
      
        // 手动抛出异常
        throw new RuntimeException();
    }
}

// 实现Thread.UncaughtExceptionHandler 接口，创建异常处理器
public class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler{

    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println(&quot;caught &quot; + e);
    }
}

public class HandlerThreadFactory implements ThreadFactory {

    @Override
    public Thread newThread(Runnable r) {
        System.out.println(this + &quot; creating new Thread&quot;);
        Thread t = new Thread(r);
        System.out.println(&quot;created &quot; + t);
        t.setUncaughtExceptionHandler(new MyUncaughtExceptionHandler());
        System.out.println(&quot;ex = &quot; + t.getUncaughtExceptionHandler());
        return t;
    }
}

public class CaptureUncaughtException {

    public static void main(String[] args) {
        ExecutorService service = Executors.newCachedThreadPool(new HandlerThreadFactory());
        service.execute(new ExceptionThread2());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在程序中添加了额外的追踪机制，用来验证工厂创建的线程会传递给&lt;code&gt;UncaughtExceptionHandler&lt;/code&gt;，你可以看到，未捕获的异常是通过 &lt;code&gt;uncaughtException&lt;/code&gt; 来捕获的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1515111/201908/1515111-20190831231309100-1225948351.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;文章来源：&lt;/p&gt;
&lt;p&gt;《Java编程思想》&lt;/p&gt;
&lt;p&gt;https://www.javatpoint.com/join()-method&lt;/p&gt;
</description>
<pubDate>Sat, 31 Aug 2019 15:13:00 +0000</pubDate>
<dc:creator>c旋儿</dc:creator>
<og:description>到目前为止，你学到的都是顺序编程，顺序编程的概念就是某一时刻只有一个任务在执行，顺序编程固然能够解决很多问题，但是对于某种任务，如果能够并发的执行程序中重要的部分就显得尤为重要，同时也可以极大提高程序</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cxuanBlog/p/11440959.html</dc:identifier>
</item>
<item>
<title>技术服务于生活——羽毛球+程序员=？ - wangmeijian</title>
<link>http://www.cnblogs.com/wangmeijian/p/11349356.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangmeijian/p/11349356.html</guid>
<description>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;技术服务于生活，不久前在知乎看到一个问题：自己拥有一台服务器可以做哪些很酷的事情？答主们各有各的骚操作，搭博客的、搭个人网盘的、做爬虫的、配私人影院的等等，有位同学做了个离校登记系统，服务于大众，很不错的想法。这些都是技术服务于生活的典范。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664733/201908/664733-20190831224251511-164271969.png&quot; alt=&quot;&quot; height=&quot;300&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我平时会打羽毛球，加了几个微信群，群内会不定时举行各种大大小小的比赛，比赛就需要记分，大家应该见过那种PVC硬塑料的记分牌，我也用过，一般记分员是坐在记分牌背面，自己看不见比分，经常一翻翻两页，翻页的体验极差，用户体验差的东西我是不能忍的，然后就打算做一个线上的记分牌，然而我又不想自己买服务器、建账号系统这些，首选当然是小程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664733/201908/664733-20190813204509826-1076582969.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;207&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小程序支持云开发，数据库、账号系统、项目部署不需要自己处理，我需要做的有：需求设计+原型设计+UI设计+前端逻辑+少量后端数据库增删改查逻辑（云函数）&lt;/p&gt;

&lt;h3&gt;需求设计&lt;/h3&gt;
&lt;p&gt;一、&lt;/p&gt;
&lt;p&gt;目标用户是羽毛球爱好者，在各种大小比赛中用来记录比分，是比赛就会有对阵双方，双方会有队伍名称（或其他代号），稍微正式一点的比赛会有比赛名称，那么界面上显示的数据最多有5项：&lt;/p&gt;
&lt;p&gt;比赛名称、队伍名称A、队伍名称B、A队得分、B队得分&lt;/p&gt;
&lt;p&gt;比赛名称和两队队伍名称需要用户输入，得分则随着比赛的进行随时更改&lt;/p&gt;
&lt;p&gt;二、&lt;/p&gt;
&lt;p&gt;正式一点的比赛一般会比好几场，1/8决赛 =&amp;gt; 1/4决赛 =&amp;gt; 半决赛 =&amp;gt; 决赛，这些场次和比分需要保存下来，随时可以查看。&lt;/p&gt;
&lt;p&gt;三、&lt;/p&gt;
&lt;p&gt;简单友好的用户体验&lt;/p&gt;

&lt;h3&gt;原型设计+UI设计&lt;/h3&gt;
&lt;p&gt;由于产品和开发都是我自己，原型就没画，和UI一块说&lt;/p&gt;
&lt;p&gt;一、&lt;/p&gt;
&lt;p&gt;需求点1，转换成原型就是一个比分展示界面，显示比赛名称、对阵双方队伍及比分，这个界面必须横屏显示，比分是最重要的数据必须凸显。&lt;/p&gt;
&lt;p&gt;运动类的小程序，UI配色必须年轻、彰显活力，参考了YONEX的logo配色，蓝绿白，最终UI如下，没学过设计，UI只能设计成这样了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664733/201908/664733-20190813234036513-250457166.png&quot; alt=&quot;&quot; width=&quot;697&quot; height=&quot;392&quot;/&gt;&lt;/p&gt;
&lt;p&gt;二、&lt;/p&gt;
&lt;p&gt;需求点2，一次比赛会有很多场次，那么就需要一个创建比赛场次的界面，码字的时候，已经出了两个版本了&lt;/p&gt;
&lt;p&gt;UI 1.0，没有凸显出羽毛球运动，很快更新了2.0&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664733/201908/664733-20190831210938030-201516112.jpg&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输入比赛名称、队伍名称，点击创建比赛跳转到记分页面&lt;/p&gt;
&lt;p&gt;另外界面底部有个历史比赛的入口，里面保存着所有比赛场次，可以左滑删除&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664733/201908/664733-20190831211604578-1149283993.jpg&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;前端逻辑+后端逻辑&lt;/h3&gt;
&lt;p&gt;一、&lt;/p&gt;
&lt;p&gt;逻辑并不复杂，只需要按羽毛球规则限，制比分为21分决出胜负，若双方得分都超过20分，则先得分到达30分那一方获胜&lt;/p&gt;
&lt;p&gt;二、&lt;/p&gt;
&lt;p&gt;第一个版本上线后，收到一些反馈，UI和羽毛球的关联性不够强，用户看到首页并不知道这是个什么小程序，于是更新了UI 2.0&lt;/p&gt;
&lt;p&gt;UI 2.0，背景是一个羽毛球场地&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664733/201908/664733-20190831210542755-1821480724.jpg&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在更新UI 2.0的同时，增加了分享比赛功能，用户点击分享的链接，可以查看比分直播&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664733/201908/664733-20190831220018141-619624851.jpg&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;
&lt;p&gt;三、&lt;/p&gt;
&lt;p&gt;今天，为了增加用户黏性，增加了羽毛球运动员世界排名，每周从世界羽联官方网站自动抓取，然后翻译成中文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664733/201908/664733-20190831214758883-378484102.jpg&quot; alt=&quot;&quot; width=&quot;400&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;未来计划&lt;/h3&gt;
&lt;p&gt;1、增加可选的专业模式，增加三局两胜制，局间间歇2分钟，具体发接发、交换场地等等，向专业比赛靠拢&lt;/p&gt;
&lt;p&gt;2、增加世界羽联全年赛事概览，包括比赛名称、时间、地点、级别、奖金&lt;/p&gt;

&lt;h3&gt;后语&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;小程序上线后，添加率（添加到我的小程序的用户比例）还不错，接近&lt;span&gt;30%&lt;br/&gt;&lt;span&gt;用户评价也还行，这是我持续做下去的动力，欢迎扫码体验&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664733/201908/664733-20190831222255915-1179944045.jpg&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;吐槽&lt;/h3&gt;
&lt;p&gt;小程序已经出来挺久了，还是有挺多槽点，随便列一下&lt;/p&gt;
&lt;p&gt;比如云函数环境切换，没有一个固定的配置，对刚接触小程序的开发者极不友好&lt;/p&gt;
&lt;p&gt;比如不支持less/sass等&lt;/p&gt;
&lt;p&gt;比如Mac版模拟器渲染经常会出现字体放大等异常&lt;/p&gt;
&lt;p&gt;比如分享小程序，默认图片没有居中显示&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
&lt;p&gt;希望小程序越来越好吧&lt;/p&gt;
</description>
<pubDate>Sat, 31 Aug 2019 14:45:00 +0000</pubDate>
<dc:creator>wangmeijian</dc:creator>
<og:description>前言 技术服务于生活，不久前在知乎看到一个问题：自己拥有一台服务器可以做哪些很酷的事情？答主们各有各的骚操作，搭博客的、搭个人网盘的、做爬虫的、配私人影院的等等，有位同学做了个离校登记系统，服务于大众</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangmeijian/p/11349356.html</dc:identifier>
</item>
<item>
<title>GCN和GCN在文本分类中应用 - Kalafinaian</title>
<link>http://www.cnblogs.com/Kalafinaian/p/11440732.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Kalafinaian/p/11440732.html</guid>
<description>&lt;p&gt;       传统CNN卷积可以处理图片等欧式结构的数据，却很难处理社交网络、信息网络等非欧式结构的数据。一般图片是由c个通道h行w列的矩阵组成的，结构非常规整。而社交网络、信息网络等是图论中的图(定点和边建立起的拓扑图)。&lt;/p&gt;
&lt;p&gt;       传统CNN卷积面对输入数据维度必须是确定的，进而CNN卷积处理后得到的输出数据的维度也是确定的。欧式结构数据中的每个点周边结构都一样，如一个像素点周围一定有8个像素点，即每个节点的输入维度和输出维度都是固定的。而非欧式结构数据则不一定，如社交网络中A和B是朋友，A有n个朋友，但B不一定有n个朋友，即每个节点的输入维度和输出维度都是不确定的。&lt;/p&gt;
&lt;p&gt;       所以不能使用CNN来对社交网络、信息网络等数据进行处理，因为对A节点处理后得到输出数据的维度和对B节点处理后得到输出数据维度是不一样的。为了得到社交网络、信息网络的空间特征所以我们使用GCN(Graph Convolutional Network)来处理。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180694/201908/1180694-20190831220857270-1336921561.jpg&quot;/&gt;&lt;br/&gt;图1 一个GCN的实例(图片来源网页[3])&lt;/center&gt;
&lt;p&gt;       同一般的卷积神经网络不同，GCN输入的数据是一个图拓扑矩阵，这个拓扑矩阵一般是图的邻接矩阵。&lt;/p&gt;
&lt;h2 id=&quot;概念定义&quot;&gt;2.1 概念定义&lt;/h2&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;一个拓扑图定义为G=(V,E) 其中V是节点集合，E是边集合。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;N&lt;/td&gt;
&lt;td&gt;N是图中节点个数，即|V|&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;F&lt;/td&gt;
&lt;td&gt;节点的特征数，不同学习任务F不同&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;X&lt;/td&gt;
&lt;td&gt;网络初始化矩阵, X是N行F列的矩阵&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;图的度矩阵,Dij表示点i和点j是否存在连接&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;A&lt;/td&gt;
&lt;td&gt;图结构表征矩阵, A是N行N列的矩阵，A通常是G的邻接矩阵&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Hi&lt;/td&gt;
&lt;td&gt;GCN中每层输出矩阵 Hi是一个N行F列矩阵&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Wi&lt;/td&gt;
&lt;td&gt;GCN中每层权值矩阵 Wi是一个F行F列矩阵&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;gcn计算方式&quot;&gt;2.2 GCN计算方式&lt;/h2&gt;
&lt;p&gt;       在GCN中，第1层又H0 = X，从i层到i+1层网络计算其中一个简单传播规则,即传播规则1:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{array}{l} {{\bf{H}}^{i + 1}} = f\left( {{{\bf{H}}^i},{\bf{A}}} \right) \\ \quad \;\;\; = \sigma \left( {{\bf{A}}{{\bf{H}}^i}{{\bf{W}}^i}} \right) \\ \end{array}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       其中激活函数σ一般为ReLu函数。尽然这个规则下GCN是一个简单模型，但已经足够强大，当然实际使用传播规则是下面几个:&lt;/p&gt;
&lt;p&gt;       传播规则2&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{array}{l} {{\bf{H}}^{i + 1}} = f\left( {{{\bf{H}}^i},{\bf{A}}} \right) \\ \quad \;\;\; = \sigma \left( {{{\bf{D}}^{ - \frac{1}{2}}}{\bf{A}}{{\bf{D}}^{ - \frac{1}{2}}}{{\bf{H}}^i}{{\bf{W}}^i}} \right) \\ \end{array}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       传播规则3&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{array}{l} {{\bf{H}}^{i + 1}} = f\left( {{{\bf{H}}^i},{\bf{A}}} \right) \\ \quad \;\;\; = \sigma \left( {\left( {{\bf{I}} + {{\bf{D}}^{ - \frac{1}{2}}}{\bf{A}}{{\bf{D}}^{ - \frac{1}{2}}}} \right){{\bf{H}}^i}{{\bf{W}}^i}} \right) \\ \end{array}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       传播规则4&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{array}{l} {{\bf{H}}^{i + 1}} = f\left( {{{\bf{H}}^i},{\bf{A}}} \right) \\ \quad \;\;\; = \sigma \left( {{{\bf{D}}^{ - \frac{1}{2}}}\left( {{\bf{D}} - {\bf{A}}} \right){{\bf{D}}^{ - \frac{1}{2}}}{{\bf{H}}^i}{{\bf{W}}^i}} \right) \\ \end{array}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       传播规则5&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[\begin{array}{l} {{\bf{H}}^{i + 1}} = f\left( {{{\bf{H}}^i},{\bf{A}}} \right) \\ \quad \;\;\; = \sigma \left( {{{{\bf{\hat D}}}^{ - \frac{1}{2}}}{\bf{\hat A}}{{{\bf{\hat D}}}^{ - \frac{1}{2}}}{{\bf{H}}^i}{{\bf{W}}^i}} \right) \\ \end{array}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;       其中&lt;span class=&quot;math inline&quot;&gt;\({\bf{\hat A}}{\rm{ = }}{\bf{A}}{\rm{ + }}{\rm I}\)&lt;/span&gt;，I是一个N×N的单位矩阵。而&lt;span class=&quot;math inline&quot;&gt;\({\bf{\hat D}}\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\({\bf{\hat A}}\)&lt;/span&gt;&lt;br/&gt;是一个对角线矩阵，其中${{\bf{\hat D}}&lt;em&gt;{ii}} = \sum\limits_j {{{{\bf{\hat A}}}&lt;/em&gt;{ij}}} $。&lt;/p&gt;
&lt;p&gt;       最后根据不同深度学习任务来定制相应的GCN网络输出。&lt;/p&gt;

&lt;h2 id=&quot;文本分类常用算法&quot;&gt;3.1 文本分类常用算法&lt;/h2&gt;
&lt;p&gt;       文本分类是自然语言处理比较常见的问题，常见的文本分类主要基于传统的cnn、lstm以及最近几年比较热门的transform、bert等方法，传统分类的模型主要处理排列整齐的矩阵特征，也就是很多论文中提到的Euclidean Structure，但是我们科学研究或者工业界的实际应用场景中，往往会遇到非Euclidean Structure的数据，如社交网络、信息网络，传统的模型无法处理该类数据，提取特征进一步学习，因此GCN 应运而生，本文主要介绍GCN在文本分类中的应用。&lt;/p&gt;
&lt;h2 id=&quot;gcn在文本分类中具体应用&quot;&gt;3.2 GCN在文本分类中具体应用&lt;/h2&gt;
&lt;p&gt;       首先我们将我们的文本语料构建拓扑图，改图的节点由文档和词汇组成，即图中节点数|v|=|doc|+|voc| 其中|doc|表示文档数，|voc|表示词汇总量，对于特征矩阵X，我们采用单位矩阵I表示，即每个节点的向量都是one-hot形式表示，下面我们将介绍如何定义邻接矩阵A，其公式如所示，对于文档节点和词汇节点的权重，我们采用TF-IDF表示，对于词汇节点之间的权重，我们采用互信息表示（PMI, point-wise mutual information）,在实验中，PMI表现好于两个词汇的共现词汇数，其公式如所示:&lt;br/&gt;&lt;span class=&quot;math display&quot;&gt;\[{A_{ij}} = \left\{ \begin{array}{l} {\rm{PMI}}\left( {i,j} \right)\quad \quad \quad \quad i和j是词语而且{\rm{PMI}}\left( {i,j} \right) &amp;gt; {\rm{0}} \\ {\rm{TF - IDF}}\left( {i,j} \right)\quad \;\;i是文档j是词语 \\ 1\quad \quad \quad \quad \quad \quad \quad \;\;\;i = j \\ 0\quad \quad \quad \quad \quad \quad \quad \;\;其他\\ \end{array} \right.\]&lt;/span&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180694/201908/1180694-20190831220928295-382512643.jpg&quot;/&gt;&lt;/center&gt;
&lt;p&gt;       其中#W(i)表示在固定滑动窗口下词汇i出现的数量，#W(i, j)表示在固定滑动窗口下词汇i，j同时出现的数量，当PMI(i, j)为正数表示词汇i和词汇j有较强的语义关联性，当PMI(i, j)为负数的时候表示词汇i，j语义关联性较低，在构建完图后，我们代入GCN中，构建两层GCN，如下:&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180694/201908/1180694-20190831220945929-1895550441.jpg&quot;/&gt;&lt;/center&gt;
&lt;p&gt;       我们采用经典的交叉熵来定义损失函数:&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1180694/201908/1180694-20190831221003402-905998193.jpg&quot;/&gt;&lt;/center&gt;
&lt;p&gt;       其中YD表示带标签的文挡集合，Ydf 表示标注类别，Zdf为预测的类别。&lt;/p&gt;
&lt;p&gt;       下面介绍GCN在多个公开数据集上的实验结果，其中数据源为：&lt;/p&gt;
&lt;center&gt;表1: Summary statistic of datasets &lt;img src=&quot;https://img2018.cnblogs.com/blog/1180694/201908/1180694-20190831221027882-364326710.jpg&quot;/&gt;&lt;/center&gt;
&lt;p&gt;       GCN在文本分类上的实验结果见表2。&lt;/p&gt;
&lt;center&gt;表2: GCN在在文本分类上的实验结果 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1180694/201908/1180694-20190831221049844-587352728.jpg&quot;/&gt;&lt;/center&gt;
&lt;p&gt;       这种新颖的文本分类方法称为文本图卷积网络（Text-GCN）,巧妙地将文档分类问题转为图节点分类问题。Text-GCN可以很好地捕捉文档地全局单词共现信息和利用好文档有限地标签。一个简单的双层Text-GCN已经取得良好地成果。&lt;/p&gt;

&lt;p&gt;[1] Kipf T N, Welling M. Semi-supervised classification with graph convolutional networks[J]. arXiv preprint arXiv:1609.02907, 2016.&lt;br/&gt;[2] Yao L, Mao C, Luo Y. Graph convolutional networks for text classification[J]. arXiv preprint arXiv:1809.05679, 2018.&lt;br/&gt;[3] &lt;a href=&quot;http://tkipf.github.io/graph-convolutional-networks/&quot; class=&quot;uri&quot;&gt;http://tkipf.github.io/graph-convolutional-networks/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 31 Aug 2019 14:13:00 +0000</pubDate>
<dc:creator>Kalafinaian</dc:creator>
<og:description>1.GCN的概念 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;传统CNN卷积可以处理图片等欧式结构的数据，却很难处理社交网络、信息网络等非欧式结构的数据。一般图</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Kalafinaian/p/11440732.html</dc:identifier>
</item>
<item>
<title>Java异常处理机制 - YaoFrankie</title>
<link>http://www.cnblogs.com/YaoFrankie/p/11440626.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YaoFrankie/p/11440626.html</guid>
<description>&lt;h3&gt;1. Exception&lt;/h3&gt;
&lt;p&gt;　　Exception主要分为两种：&lt;span&gt;Runtime Exception、&lt;/span&gt;&lt;span&gt;Checked（Compile） Exception&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　常见的Runtime Exception，有：NullPointerException、ArithmeticException...&lt;/p&gt;
&lt;p&gt;　　常见的Checked（Compile） Exception，有：IOException、FileNotFoundException...&lt;/p&gt;
&lt;p&gt;　　所谓Checked Exception就是在编译期间，你必须对某条、或多条语句进行异常处理，如： try...catch...、throws语句。&lt;/p&gt;
&lt;p&gt;　　下面介绍下Checked Exception的优缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;特点与优点： &lt;span&gt;Java专有&lt;/span&gt;，体现Java的设计哲学，没有完善错误处理的代码根本就不会给你机会去执行。&lt;/li&gt;
&lt;li&gt;缺点：
&lt;ul&gt;&lt;li&gt;必须显式捕捉并处理异常，或显式声明抛出异常，增加&lt;span&gt;程序复杂度&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;若显式抛出异常，则会增加&lt;span&gt;方法签名与异常的耦合度&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. Error&lt;/h3&gt;
&lt;p&gt;　　Error主要表示一些虚拟机内部错误，如：动态链接失败。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;程序可读性：避免过度使用异常处理代码，减少方法签名与异常的耦合度。&lt;/li&gt;
&lt;li&gt;异常原始性：捕获并&lt;span&gt;保留原始异常信息&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;异常针对性：&lt;span&gt;根据业务需求决定如何处理异常&lt;/span&gt;，比如：
&lt;ul&gt;&lt;li&gt;当你检查商品库存时发生异常，此时就应终止此次调用，并告诉上层用户详细、明确的原因。&lt;/li&gt;
&lt;li&gt;当你获取用户头像失败时，因为该操作不影响整体订单、支付流程，所以不需要终止此次调用，可与上层用户协商处理，比如：返回一个空字符串。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;throw与throws区别？
&lt;ul&gt;&lt;li&gt;位置：
&lt;ul&gt;&lt;li&gt;throws位于&lt;span&gt;方法签名&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;throw位于&lt;span&gt;函数体内&lt;/span&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;语法格式
&lt;ul&gt;&lt;li&gt;throws后面跟的是&lt;span&gt;异常类&lt;/span&gt;，且一次可以跟多个，只需要以逗号分隔。&lt;/li&gt;
&lt;li&gt;throw后面跟着的是&lt;span&gt;异常实例&lt;/span&gt;，且一次只能跟一个。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;命中率
&lt;ul&gt;&lt;li&gt;throws只是做个防守，并不会真正执行。&lt;/li&gt;
&lt;li&gt;一旦执行到throw语句，必定抛出异常。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为什么要有异常处理机制？
&lt;ul&gt;&lt;li&gt;无法穷举所有的异常情况。&lt;/li&gt;
&lt;li&gt;若异常处理的代码过多，会导致程序可读性变差。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为什么要把原始异常封装一层？&lt;br/&gt;&lt;ul&gt;&lt;li&gt;&lt;span&gt;安全性&lt;/span&gt;，防止恶意用户获得系统内部信息。&lt;/li&gt;
&lt;li&gt;对上层用户更加&lt;span&gt;友好&lt;/span&gt;，让其更加明确、详细的知道异常原因。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;为什么有那么多类需要实现Closeable或AutoCloseable接口？
&lt;ul&gt;&lt;li&gt;Java9增强了自动关闭资源的try语句。&lt;/li&gt;
&lt;li readability=&quot;-0.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExceptionTest {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readFile(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;(BufferedReader bufferedReader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedReader(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; FileReader(&quot;justForTest.txt&quot;&lt;span&gt;)))
        {
            System.out.println(bufferedReader.readLine());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
            e.printStackTrace();
        }
    }
}

@Test
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; readFileTest(){
    ExceptionTest.readFile(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Just for test.&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217358/201908/1217358-20190831214417430-1503005103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Getter
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ServiceException &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; RuntimeException {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; HttpStatus status;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ResultCode resultCode;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object     errorData;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ServiceException(HttpStatus status, ResultCode resultCode, Object errorData){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.status     =&lt;span&gt; status;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.resultCode =&lt;span&gt; resultCode;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.errorData  =&lt;span&gt; errorData;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ServiceException badRequest(ResultCode resultCode, Object errorData){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ServiceException(HttpStatus.BAD_REQUEST, resultCode, errorData);
    }
}

@Getter
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; ResultCode {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; errorCode&lt;/span&gt;
    SUCCESS(0, &quot;SUCCESS&quot;&lt;span&gt;),
    INVALID_PARAMETER(&lt;/span&gt;600, &quot;invalid parameter&quot;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; errorCode;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String errorData;

    ResultCode(&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; errorCode, String errorData){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.errorCode =&lt;span&gt; errorCode;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.errorData =&lt;span&gt; errorData;
    }
}

@ControllerAdvice
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GlobalErrorHandler {

    @ExceptionHandler(ServiceException.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;ErrorResponse&amp;gt;&lt;span&gt; handleServiceException(ServiceException ex){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResponseEntity
                .status(ex.getStatus())
                .body(ErrorResponse.failed(ex.getResultCode(), ex.getErrorData()));
    }
}


@ApiModel
@Getter
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ErrorResponse&amp;lt;T&amp;gt; &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Serializable {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; serialVersionUID = -2254339918462802230L&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; errorCode;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; String errorMsg;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; T errorData;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; ErrorResponse(ResultCode resultCode, T errorData) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.errorCode =&lt;span&gt; resultCode.getErrorCode();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.errorMsg  =&lt;span&gt; resultCode.getErrorData();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.errorData =&lt;span&gt; errorData;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; ErrorResponse&amp;lt;T&amp;gt;&lt;span&gt; failed(ResultCode resultCode, T data){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ErrorResponse(resultCode, data);
    }
}

@RestController
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OrderController {

    @GetMapping(value &lt;/span&gt;= &quot;/v1/orders/{order_id}&quot;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;, produces = {&quot;application/toString&quot;, &quot;application/json&quot;}&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Order getOrder(@PathVariable(&quot;order_id&quot;&lt;span&gt;) @NotBlank String orderId){

        Order order &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Order();
        BigDecimal total &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; BigDecimal(-1.00, &lt;span&gt;new&lt;/span&gt; MathContext(2&lt;span&gt;, RoundingMode.HALF_UP));

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (total.compareTo(BigDecimal.ZERO) &amp;lt;= 0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ServiceException.badRequest(ResultCode.INVALID_PARAMETER,
                    &lt;/span&gt;&quot;Total is less than zero!&quot;&lt;span&gt;);
        }
        order.setOrderId(orderId);
        order.setTotal(total);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; order;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1217358/201908/1217358-20190831215026133-1442363253.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;ul&gt;&lt;li&gt;疯狂Java讲义（第十章 - 异常处理）&lt;/li&gt;
&lt;li&gt;JAVA核心知识点整理&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Sat, 31 Aug 2019 14:01:00 +0000</pubDate>
<dc:creator>YaoFrankie</dc:creator>
<og:description>Java异常处理机制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/YaoFrankie/p/11440626.html</dc:identifier>
</item>
</channel>
</rss>