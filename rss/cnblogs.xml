<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>助力苏州、星火相传，广苏两地微软技术俱乐部交流纪实 - 叶伟民</title>
<link>http://www.cnblogs.com/adalovelacer/p/work-together.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adalovelacer/p/work-together.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;p&gt;2019年1月19日时值二十四节气“大寒”前夕，江南水乡冬日的寒气盖不住苏州.NET开发者的热情，就在这一天苏州微软技术俱乐部成立了并举办了第一场大型的线下交流活动。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201901/26286-20190122055813373-547086821.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;星火相传&lt;/h4&gt;
&lt;p&gt;2018年12月8日广州.NET微软技术俱乐部举办了恢复以来的第一场大型线下技术交流活动。或许是因为沉寂了太久，也或许是因为.NET Core的革新，更或许是微软“刷新”后的新面貌；一次年末岁尾的广州.NET社区活动，似乎点燃了其他地区.NET开发者的热情，苏州、上海、成都等地纷纷将成立.NET俱乐部的计划提上日程。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201901/26286-20190122055846821-515743254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;广苏俱乐部传旗交接&lt;/p&gt;
&lt;h4&gt;助力苏州&lt;/h4&gt;
&lt;p&gt;本着大家团结齐心合力把中国.NET社区一起搞好，避免重复建设和资源浪费的初心，让正在筹建的苏州微软技术俱乐部和广州微软技术俱乐部建立起了联系。&lt;/p&gt;
&lt;p&gt;三次工作组远程电话会议，多次主席间的沟通以及最终直接参与到苏州微软俱乐部的筹建工作中。双方深入具体的合作与经验的分享，使得在此次活动筹划与举办过程中都收益匪浅，积累了非常丰富的经验。&lt;/p&gt;
&lt;p&gt;此次苏州俱乐部的筹建，共计邀请到了4位全国社区领袖，10位现（曾）任微软最有价值专家（MVP），以及数十位外地行业专家到场参会。参会人员达到近270人，线上参与直播约有22400人。规模空前，可谓是19年的开门红，为19年全国类似的社区活动起了一个好头。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201901/26286-20190122055919193-1898849359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;苏州主席-苏震巍，广州执行主席-陈作&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201901/26286-20190122055932906-1643504328.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;微软最有价值专家（MVP）与社区领袖&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/26286/201901/26286-20190122055956497-1220546625.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;大会嘉宾名单&lt;/p&gt;
&lt;h4&gt;星星之火可以燎原&lt;/h4&gt;
&lt;p&gt;广苏两地俱乐部大型线下活动的成功举办，为全国其他地区提供了非常好的参照及经验。同时也为.NET开发者树立了信心。&lt;/p&gt;
&lt;p&gt;2019年，我们团结起来，发挥集体的力量！将继续推动.NET社区的向前发展，星星之火可以燎原。&lt;/p&gt;

&lt;p&gt;嗯，这篇文章就是集体协作成果！由广州俱乐部常务秘书戚亚柱（网名白手套）初稿，广州俱乐部主席叶伟民（就是我啦）二稿！&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 22:01:00 +0000</pubDate>
<dc:creator>叶伟民</dc:creator>
<og:description>广苏两地俱乐部大型线下活动的成功举办，为全国其他地区提供了非常好的参照及经验。同时也为.NET开发者树立了信心。 2019年，我们团结起来，发挥集体的力量！将继续推动.NET社区的向前发展，星星之火</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/adalovelacer/p/work-together.html</dc:identifier>
</item>
<item>
<title>PROJ.4学习——地图投影 - eshine</title>
<link>http://www.cnblogs.com/eshinex/p/10299947.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/eshinex/p/10299947.html</guid>
<description>&lt;div readability=&quot;18&quot;&gt;
&lt;p&gt;&lt;strong&gt;PROJ.4学习——地图投影（坐标系投影）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;PROJ是由大量的基础投影库构成。这里主要讨论学习PROJ库的相关参数。&lt;/p&gt;
&lt;p&gt;　　这里大部分是讲如何将3D坐标系投影到2D平面上。投影时，涉及到基准线，单位，比例英子，偏移量，轴转换等。&lt;/p&gt;
&lt;p&gt;　　很多实际操作中却涉及到3D坐标系转换为其他3D坐标系（下一篇更新）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数列表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　下面是可以应用于大多数坐标系定义的PROJ参数列表。此表不尝试描述特定于特定投影类型的参数。&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;table border=&quot;1&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot;&gt;&lt;caption&gt; &lt;/caption&gt;
&lt;tbody readability=&quot;13&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;参数&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;描述&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; +a&lt;/td&gt;
&lt;td&gt; 椭球体长半轴长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; +axis&lt;/td&gt;
&lt;td&gt; 轴防线&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; +b&lt;/td&gt;
&lt;td&gt; 椭球体短半轴长度&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; +ellps&lt;/td&gt;
&lt;td&gt; 椭球体名称，在cmd中输入：proj -le 查看支持哪些椭球体&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; +k&lt;/td&gt;
&lt;td&gt; 比例系数（比例因子），旧版本，不赞成使用&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; +k_0&lt;/td&gt;
&lt;td&gt; 比例系数（比例因子）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; +lat_0&lt;/td&gt;
&lt;td&gt; 维度起点&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; +lon_0&lt;/td&gt;
&lt;td&gt; 中央经线&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; +lon_wrap&lt;/td&gt;
&lt;td&gt; 中央经线的包装参数（详见下面的说明）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;9.5&quot;&gt;&lt;td&gt; +no_defs&lt;/td&gt;
&lt;td readability=&quot;12&quot;&gt;
&lt;p&gt; 不要使用proj库中的缺省定义文件。&lt;/p&gt;
&lt;p&gt; 在linux中路径为：/usr/share/proj/proj_def.dat&lt;/p&gt;
&lt;p&gt; windows中为安装路径下的：&lt;span&gt;E:\SvnWorkspace\LY_WEB_GIS\branches\Documents\ms4w-mapserver-for-wimdows\release-1911-x64-gdal-2-3-3-mapserver-7-2-1\&lt;/span&gt;bin\proj\SHARE\proj_def.dat&lt;/p&gt;
&lt;p&gt;标红处是我安装MapServer是自带安装Proj的路径&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; +over&lt;/td&gt;
&lt;td&gt; 允许经度输出在-180到180范围之外，禁用wrapping(详见下面的说明)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; +pm&lt;/td&gt;
&lt;td&gt; 备用本初子午线(通常是一个城市名称，见下文)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt; +proj&lt;/td&gt;
&lt;td&gt; 投影名称，在cmd中输入：proj -l 查看数据支持&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt; +units&lt;/td&gt;
&lt;td&gt; 水平单位，meters（米）、 US survey feet, etc（英尺等 us-ft）.&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; +vunits&lt;/td&gt;
&lt;td&gt; 垂直单位&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; +x_0&lt;/td&gt;
&lt;td&gt; 东（伪）偏移量&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; +y_0&lt;/td&gt;
&lt;td&gt; 北（伪）偏移量&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;div readability=&quot;90.5&quot;&gt;
&lt;p&gt;&lt;strong&gt;units&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　可以使用+units关键字指定水平单位，该关键字具有单位的符号名称(如：+units=us-ft)。另外换算单位米可以用+to_meter关键字（如：美国一英尺为0.304800609601219米）。&lt;/p&gt;
&lt;p&gt;　　在cmd中输入：  cs2cs -lu 或者 proj -lu 查看PROJ支持的单位。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/249616/201901/249616-20190121174501838-65179099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/249616/201901/249616-20190121174549653-696124944.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下面来了解一下 +to_meter 关键字的使用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46.5&quot;&gt;
&lt;pre readability=&quot;6&quot;&gt;
#在cmd中输入：&lt;br/&gt;&lt;span&gt;cs2cs +proj=merc +lat_ts=56.5 +ellps=GRS80 +to +proj=utm +zone=32 +units=km&lt;/span&gt;&lt;br/&gt;#再输入参数
&lt;span&gt;1699741.9       376042.8&lt;/span&gt;&lt;br/&gt;#得到
&lt;span&gt;2594.43 715.50 0.00&lt;/span&gt;&lt;p&gt;#在cmd中输入：&lt;br/&gt;&lt;span&gt;cs2cs +proj=merc +lat_ts=56.5 +ellps=GRS80 +to_meter=0.5 +to +proj=utm +zone=32 +units=km&lt;/span&gt;&lt;br/&gt;#再输入参数&lt;br/&gt;&lt;span&gt;3399483.80      752085.60&lt;/span&gt;&lt;br/&gt;#得到&lt;br/&gt;&lt;span&gt;2594.43 715.50 0.00&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/249616/201901/249616-20190121194213415-1624382203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　从两个命令比较，第二个增加了 +to_meter=0.5&lt;/p&gt;
&lt;p&gt;　　第二个参数范围是第一个的两倍&lt;/p&gt;
&lt;p&gt;　　但是投影出来的位置却是同一个&lt;/p&gt;
&lt;p&gt;　　因为第二个在投影转换是，将1米转换为了0.5倍，即范围缩小了一半&lt;/p&gt;
&lt;p&gt;　　所以得到的结果是一样的&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;　　同样，垂直单位可以使用 +vunits 关键字。如果没有指定垂直单位，则垂直单位将默认与水平坐标相同。&lt;/p&gt;
&lt;p&gt;　　注意：proj根本不处理垂直单元，因此+vto_meter参数将被忽略。&lt;/p&gt;
&lt;p&gt;　　可以通过应用+k_0参数来缩放输出单元。返回的坐标（经纬度、米、千米等，按照定义的 +units 输出）按使用+k_0参数分配的值进行缩放。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
#tmerc 横墨卡托高斯投影&lt;br/&gt;proj +proj=tmerc +lat_0=0 +lon_0=-55.5 +k=0.9999 +x_0=304800 +y_0=0 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs&lt;br/&gt;#输入&lt;br/&gt;12.2 -58.5&lt;br/&gt;#得到&lt;br/&gt;3664306.25      -8536230.41
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt; 东北（伪）偏移量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　几乎所有的坐标系都允许存在一个假的东偏移 (+x_0)和一个假的北偏移 (+y_0)。请注意，这些值总是以米表示，即使坐标系是其他一些单位。有些坐标系(如UTM)具有隐式的假东向和北向值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 经度覆盖/边界设置（Longitude Wrapping）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　我把Wrap翻译为覆盖或边界，也不知道准确与否。&lt;/p&gt;
&lt;p&gt;　　默认情况下，PROJ将输出经度覆盖/边界值在-180到180之间。可以使用+over开关禁用在pj_inv()中较低级别执行的默认覆盖/边界。这对于等距圆柱投影特别有用，在等距圆柱投影中，X值经过-20000000(大致)后继续经过-180，而不是覆盖/边界到+180。&lt;/p&gt;
&lt;p&gt;　　可以使用+lon_wrap选项在pj_transform()中提供一种进行经度边界设置的替代方法。此选项的参数是一个中心经度。所以+lon_wrap=180表示在0到360范围内的经度。注意+over不会禁用+lon_wrap。&lt;/p&gt;
&lt;p&gt;本初子午线Prime Meridian&lt;/p&gt;
&lt;p&gt;　　本初子午线的定义是基于格林尼治的本初子午线与当前坐标系统本初子午线之间的偏移量定义的（格林尼治的本初子午线是基准，设置 +pm=经度偏移量 表示当前坐标系统的本初子午线；或者是一个符号名称）。&lt;/p&gt;
&lt;p&gt;　　如：EPSG:27500，它的本初子午线就是基于格林尼治的本初子午线加上西偏2.337208333333333构成&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
# ATF (Paris) / Nord de Guerre
&amp;lt;27500&amp;gt; +proj=lcc +lat_1=49.50000000000001 +lat_0=49.50000000000001 +lon_0=5.399999999999999 +k_0=0.99950908 +x_0=500000 +y_0=300000 +a=6376523 +b=6355862.933255573 &lt;span&gt;+pm=2.337208333333333&lt;/span&gt; +units=m +no_defs  &amp;lt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　再如：EPSG:27395，它的本初子午线就是一个符号定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
# NGO 1948 (Oslo) / NGO zone V
&amp;lt;27395&amp;gt; +proj=tmerc +lat_0=58 +lon_0=6.166666666666667 +k=1 +x_0=0 +y_0=0 +a=6377492.018 +b=6356173.508712696 +towgs84=278.3,93,474.5,7.889,0.05,-6.61,6.21 &lt;span&gt;+pm=oslo&lt;/span&gt; +units=m +no_defs  &amp;lt;&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当前子午线声明只被pj_transform() API利用,而不被pj_inv()和pj_fwd()利用。因此用户工具cs2cs遵守本初子午线参数，但是proj程序忽略它.&lt;/p&gt;
&lt;p&gt;　　在cmd中输入：cs2cs -lm 查询支持的本初子午线&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/249616/201901/249616-20190122021949807-841051477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　比如，使用的例子。在格林尼治基于lat/long坐标的位置long=0, lat=0被转换为以马德里为本初子午线的lat/long坐标。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
#在cmd中输入：
&lt;span&gt;cs2cs +proj=latlong +datum=WGS84 +to +proj=latlong +datum=WGS84 +pm=madrid&lt;/span&gt;
#输入参数
&lt;span&gt;0 0&lt;/span&gt;
#得到&lt;br/&gt;&lt;span&gt;3d41'16.58&quot;E    0dN 0.000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;轴方向切换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　从PROJ 4.8.0开始，+axis参数可用于控制坐标系的轴向。默认的方向是“向东，向北，向上”，但是方向可以翻转，或者使用+axis开关中的轴的组合来翻转轴。值分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&quot;e&quot; - Easting&lt;/li&gt;
&lt;li&gt;&quot;w&quot; - Westing&lt;/li&gt;
&lt;li&gt;&quot;n&quot; - Northing&lt;/li&gt;
&lt;li&gt;&quot;s&quot; - Southing&lt;/li&gt;
&lt;li&gt;&quot;u&quot; - Up&lt;/li&gt;
&lt;li&gt;&quot;d&quot; - Down&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　其组合格式如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;+axis=enu&lt;/span&gt; easting，northing，up - 默认值。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;+axis=neu &lt;/span&gt;northing，easting， up - 适用于“lat/long”地理坐标，或向南横向墨卡托。&lt;/li&gt;
&lt;li&gt;&lt;span&gt;+axis=wnu&lt;/span&gt; westing，northing，up - 有些具有“西正”坐标的行星坐标系。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 　　注意 +axis不适用与 proj 命令，只适用于 cs2cs 命令（3D投影到2D上面是不行的，只能是3D坐标系转其他3D坐标系）。&lt;/p&gt;

&lt;/div&gt;
</description>
<pubDate>Mon, 21 Jan 2019 18:45:00 +0000</pubDate>
<dc:creator>eshine</dc:creator>
<og:description>PROJ.4学习——地图投影（坐标系投影） 前言 PROJ是由大量的基础投影库构成。这里主要讨论学习PROJ库的相关参数。 这里大部分是讲如何将3D坐标系投影到2D平面上。投影时，涉及到基准线，单位，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/eshinex/p/10299947.html</dc:identifier>
</item>
<item>
<title>并发concurrent---3 - 涛姐涛哥</title>
<link>http://www.cnblogs.com/taojietaoge/p/10301711.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taojietaoge/p/10301711.html</guid>
<description>&lt;p&gt;&lt;span&gt;背景：并发知识是一个程序员段位升级的体现，同样也是进入BAT的必经之路，有必要把并发知识重新梳理一遍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;ConcurrentHashMap&lt;/span&gt;：&lt;/strong&gt;&lt;br/&gt;&lt;span&gt;在有了并发的基础知识以后，再来研究concurrent包。普通的HashMap为非线程安全的，在高并发场景下要使用线程安全版本的ConcurrentHashMap；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;众所周知HashTable可以保证线程安全但却效率低下，而HashMap是非线程安全但效率却高于HashTable，于是ConcurrentHashMap就孕育而生成为二者的结合体，为了更好的理解ConcurrentHashMap先看下这两个Map。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;HashMap&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap之所以具有很快的访问速度，因为它是根据键的hashCode值来存储数据，在大多数情况下可以直接定位到它的值，但遍历的顺序是不确定的；HashMap的key可以为null，但是最多只允许一条记录的键为null，另外允许多条记录(value)的值为null，key为null的键值对永远都放在一table[0]为头节点的链表中；HashMap为非线程安全的，适用于单线程环境下，即在任一时刻都可以有多个线程同时对HashMap进行读或写操作，可以会导致数据的不一致；如果一定要使用HashMap又要保证线程安全，则可以用Collection的synchronizedMap方法或ConcurrentHashMap都OK；HashMap是基于哈希实表实现的，每一个元素是一个key-value对，其内部通过单链表结局冲突问题的，当Map容量不足(超过了阀值)时链表会自动增长；HashMap实现了Serializable接口，因此其支持序列化，并且实现了Cloneable接口，可以被克隆；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap存储数据的过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HashMap内部维护了一个存储数据的Entry数组，HashMap采用链表解决冲突，每一个Entry本质上其实是一个单向链表；当要添加一个key-value对时，首先会通过hash(key)方法技术hash值，然后通过indexFor(hash,length)求该key-value对的存储位置，其计算方法是先用Hash&amp;amp;0x7FFFFFFF后，再对length取模，这就保证了每一个key-value对都能存入HashMap，当计算出相同的位置是，由于存入位置是一个链表，所以把这个key-value对插入链表头。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190122002244282-156274950.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上图1 所示，最左边竖列排的多个方格就代表&lt;/span&gt;&lt;span&gt;哈希表，也叫哈希数组，数组的每个元素都是一个单链表的头节点，链表是用来解决冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中；HashMap内存储数据的Entry数组默认是16，如果没有对Entry扩容机制的话，当存储的数据一多，Entry内部的链表会很长，这就失去了HashMap的存储意义了，所以HasnMap内部有自己的扩容机制(当size大于threshold时，对HashMap进行扩容)。&lt;/span&gt; &lt;span&gt;上图2 是HashMap的链表存储结构，其中E*代表一个Node节点，每个Node节点就对应着一个key-value的mapping映射；每个Node除了保存了key和value的映射之外，还保存了它下一Node的引用(&lt;span&gt;Eb保存了Ebb的引用，而Ebb保存了Ebbb的引用&lt;/span&gt;)；图2中，每一个链表如Ec--&amp;gt;Ecc--&amp;gt;Eccc，这三个节点的key是不相等的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析HashMap源码会发现其内部有几个重要的变量如：size用于&lt;span&gt;记录HashMap的底层数组中已用槽的数量、&lt;span&gt;threshold用于HashMap的阈值判断，看是否需要调整HashMap的容量(&lt;span&gt;&lt;span&gt;&lt;span&gt;threshold = 容量*加载因子&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;)、&lt;span&gt;DEFAULT_LOAD_FACTOR = 0.75f，即加载因子默认0.75。 &lt;span&gt;HashMap&lt;/span&gt;的扩容&lt;span&gt;是是新建了一个HashMap的底层数组，通过&lt;span&gt;调用transfer方法，将就HashMap的全部元素添加到新的HashMap中&lt;/span&gt;(此步需要&lt;span&gt;重新计算元素在新的数组中的索引位置，导致HashMap&lt;span&gt;扩容成为一个相当耗时的操作&lt;/span&gt;&lt;/span&gt;)，So&lt;span&gt;我们在用HashMap的时，最好能提前预估下&lt;span&gt;HashMap中元素的个数，这样有助于提高HashMap的性能&lt;/span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;HashTable&lt;/strong&gt;：&lt;br/&gt;HashMap的功能与HashMap类似，如同样是基于哈希表实现的、内部也是通过单链表解决冲突问题、容量不足时也会自动增加、同样实现了Seriablizable接口支持序列化、实现了Cloneable接口可克隆；不同的是HashTable继承自Dictionary类且为线程安全的(任一时间只有一个线程可以写HashTable，但性能不如&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ConcurrentHashMap)，而HashMap继承AbstractMap类且非线程安全。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190122010643112-546980307.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div readability=&quot;19.5&quot;&gt;
&lt;p&gt;&lt;span&gt;如图3，HashTable只有一把锁，当一个线程访问HashTable的同步方法时，会将整张table 锁住，当其他线程也想访问HashTable 同步方法时，就会进入阻塞或轮询状态。也就是确保同一时间只有一个线程对同步方法的占用，避免多个线程同时对数据的修改，由此确保线程的安全性；但HashTable 对get，put，remove 方法都使用了同步操作，这就造成如果两个线程都只想使用get 方法去读取数据时，因为一个线程先到进行了锁操作，另一个线程就不得不等待，这样必然导致效率低下，而且竞争越激烈，效率越低下。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;ConcurrentHashMap(并发且线程安全)&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ConcourrentHashMap是通过&lt;span&gt;分段锁技术&lt;/span&gt;来保证线程安全的[case：一个人到酒店开房可直接在前台办理入住，三个陌生人到酒店开房登记入住，另外两个则要先排队等第一个办理结束(普通的Map)，要是三个人所住的每个楼层都有一个可以办理入住的前台就无需排队了(ConcurrentHashMap)]；ConcurrentHashMap主要由Segment(桶)和HashEntry(节点)两大数据组成，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190122012844248-1082385253.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span&gt;在hashMap 的基础上，ConcurrentHashMap将数据分为多个segment(&lt;span&gt;默认16个&lt;/span&gt;)，然后每次操作对一个segment 加锁，HashTable 在竞争激烈的并发环境下表现出效率低下的原因是由于所有访问HashTable的线程都必须竞争同一把锁，而ConcurrentHashMap将数据分到多个segment 中(&lt;span&gt;默认16，也可在申明时自己设置，不过一旦设定就不能更改，扩容都是扩充各个segment 的容量&lt;/span&gt;)，由于每个segment 都有一个自己的锁，只要多个线程访问的不是同一个segment 就没有锁争用，就没有堵塞，也就是允许16个线程并发的更新并且不存在锁争用现象。除此之外，ConcurrentHashMap的segment就类似一个HashTable，但比HashTable又更进一步优化，因为HashTable对get，put，remove方法都会使用锁，而ConcurrnetHashMap中get方法是不涉及到锁的；并且&lt;span&gt;ConcurrentHashMap&lt;/span&gt;内部在并发读取时，除了key 对应的value为null的情况下会用到锁，其它的场景下都没有用到锁，所以对于读操作无论多少线程并发都是安全高效的。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Mon, 21 Jan 2019 17:48:00 +0000</pubDate>
<dc:creator>涛姐涛哥</dc:creator>
<og:description>背景：并发知识是一个程序员段位升级的体现，同样也是进入BAT的必经之路，有必要把并发知识重新梳理一遍。 ConcurrentHashMap：在有了并发的基础知识以后，再来研究concurrent包。普</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taojietaoge/p/10301711.html</dc:identifier>
</item>
<item>
<title>EF6学习笔记十六：变更追踪 - 张四海</title>
<link>http://www.cnblogs.com/jinshan-go/p/10301710.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinshan-go/p/10301710.html</guid>
<description>&lt;h3&gt;&lt;span&gt;要专业系统地学习EF推荐《你必须掌握的Entity Framework 6.x与Core 2.0》。这本书作者（汪鹏，Jeffcky）的博客：https://www.cnblogs.com/CreateMyself/&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;变更追踪是什么呢？通过EF持久化数据，那么EF是怎么知道你的实体发生了变化，哪里放生了变化？你可能说是实体状态，那么它又是怎么改变实体状态呢？&lt;/p&gt;
&lt;p&gt;你的POCO实体状态和EF之间是无法同步的，那么就需要变更追踪的机制。&lt;/p&gt;
&lt;p&gt;变更追踪有两种方式，快照追踪和代理追踪&lt;/p&gt;
&lt;p&gt;快照追踪的原理是，EF从数据库中获取数据，首先它会在内部对这个实体生成一个快照，也就是副本，另一个则返回给我们程序员。&lt;/p&gt;
&lt;p&gt;当我们的POCO实体放生变化调用savechanges()持久化数据的时候，它会扫描POCO和快照进行对比，更改实体状态，这样EF就知道这个实体的变更情况。&lt;/p&gt;
&lt;p&gt;这个比较像是MVVM架构的前端框架里面的双向绑定，专门写个方法，去执行这个检查的操作。EF里面肯定会复杂一些，首先它有延迟加载，为什么要有，因为数据是从数据库中获取的，要保证数据是新数据，所以越晚给你越好。&lt;/p&gt;
&lt;p&gt;第二个方式是代理追踪，它就没有创建快照，而是重写你的POCO生成一个代理类，你的model里面不是会有virtual修饰的属性吗？因为它重写，动态生成，那么它就可以加入自己的代码。&lt;/p&gt;
&lt;p&gt;当你的实体放生改变，那么不需要扫描去对比，直接就通知EF了。&lt;/p&gt;
&lt;p&gt;那么最后会讲到他们之间的性能。你可能会说，既然少了全盘扫描对比，那么肯定是代理的性能高啊！这可就不一定了，难道代理追踪的那个通知机制就不耗性能吗？&lt;/p&gt;
&lt;p&gt;我们先归纳一些问题。&lt;/p&gt;
&lt;p&gt;1.怎样识别这两种方式&lt;/p&gt;
&lt;p&gt;2.既然有两种追踪方式，那么到底怎么使用，是使用了一个就不能使用另一个呢？还是其他&lt;/p&gt;
&lt;p&gt;3、EF默认是使用哪一种&lt;/p&gt;
&lt;p&gt;4、他们之间的具体区别&lt;/p&gt;
&lt;p&gt;5、怎么实现快照式跟踪，怎样实现代理跟踪&lt;/p&gt;
&lt;p&gt;6、全盘扫描，调用的是哪个方法&lt;/p&gt;
&lt;p&gt;7、代理追踪和延迟加载的关系&lt;/p&gt;
&lt;p&gt;我们可以通过打印上下文的Configuration里面的具体配置，看看开启的情况，默认是都开启的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_44c01143-5b1c-495a-8993-71a9f1ebfa4b&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_44c01143-5b1c-495a-8993-71a9f1ebfa4b&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_44c01143-5b1c-495a-8993-71a9f1ebfa4b&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;bool&lt;/span&gt; detect =&lt;span&gt; ctx.Configuration.AutoDetectChangesEnabled;
&lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; proxy =&lt;span&gt; ctx.Configuration.ProxyCreationEnabled;
Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;detect:{detect},proxy:{proxy}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  detect:True,proxy:True&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;那么EF到底默认使用哪种方式，我实践的结论是：快照追踪&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;何种方式会创建为代理类型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;我们来认识一下代理类，代理类的类型是System.Data.Entity.DynamicProxies后面跟一大串数字+字母&lt;br/&gt;比如我们查询这个model，我有两个model，Store商店和Commodity商品，一对多关系。我们看到整个实体和里面的导航属性为代理类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_fbb63382-a5e0-442d-b165-79ca659d42a8&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_fbb63382-a5e0-442d-b165-79ca659d42a8&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_fbb63382-a5e0-442d-b165-79ca659d42a8&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 商品类
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Commodity : BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Unit { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FK_StoreId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Store Store { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt; 然后我们把Commodity类里面的virtual去掉，在看一下，我们看到，查询出的实体不是代理类了，实体中的导航属性为null&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_d4e0f8d9-e64d-4498-83f1-5c3a41d58814&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_d4e0f8d9-e64d-4498-83f1-5c3a41d58814&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_d4e0f8d9-e64d-4498-83f1-5c3a41d58814&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Commodity : BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Unit { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FK_StoreId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Store Store { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  去掉vitrual&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt; 那么我们现在使用Include加载里面的导航属性，可以看到饥饿加载出来的导航属性为代理类型&lt;/p&gt;

&lt;p&gt; 我把Store商店类和BaseEntity贴出来&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_1bbd5b1c-cc77-4380-a88b-7cd043637950&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_1bbd5b1c-cc77-4380-a88b-7cd043637950&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1bbd5b1c-cc77-4380-a88b-7cd043637950&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Store:BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Address { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; ICollection&amp;lt;Commodity&amp;gt; Commodities { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_4efe7383-2f29-4237-929a-d0a43882c98a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_4efe7383-2f29-4237-929a-d0a43882c98a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_4efe7383-2f29-4237-929a-d0a43882c98a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseEntity()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Id =&lt;span&gt; Guid.NewGuid().ToString();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.AddTime =&lt;span&gt; DateTime.Now;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime AddTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 现在我们对上一步稍微修改下查询，我们把Store类中的virtual去掉，我们看到不管是实体本身，还是里面导航属性的类型都已经不是代理类型&lt;/p&gt;

&lt;p&gt; 我们再来看一下，我有个Book类，它和谁都没有关系&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31&quot;&gt;&lt;img id=&quot;code_img_closed_421cc2c7-6bab-4376-af62-947db66f67d9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_421cc2c7-6bab-4376-af62-947db66f67d9&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_421cc2c7-6bab-4376-af62-947db66f67d9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Book:BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; PageSize { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;查询所有book,没有代理类型&lt;/p&gt;

&lt;p&gt; 那么为book类中随便一个属性加上virtual,再查询,可以看到没有代理类型&lt;/p&gt;

&lt;p&gt; 既然这样，那么我们将Commodity类中的Store属性去掉virtual,然后在Name属性用virtual修饰。可以看到，不管查集合还是单个实体，都没有代理类型&lt;/p&gt;

&lt;p&gt; &lt;span&gt;那么我们就来得出结论了，如果你的类型里面的导航属性（非基元类型的属性）被vitrual声明，那么查询出的这个实体或者集合就是代理类型，包括导航属性也是代理类型。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;实现快照追踪与代理追踪&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;上面试验的有点多，可能忘记了前面的问题。上面的测试虽然有代理类型，但是，这就并不代表就是使用的代理追踪。&lt;/p&gt;
&lt;p&gt;因为代理追踪不会全盘扫描快照，进行对比。那么EF里面是哪个方法专管扫描比较这个事情呢？答案就是：DetectChanges()&lt;/p&gt;
&lt;p&gt;所以我们只要试验某一个实体，对他的属性进行了修改，并且实体状态放生了变化。如果没有调用DetectChanges()方法就是使用的代理追踪，如果调用了DetectChanges()则是快照追踪&lt;/p&gt;
&lt;p&gt;所以这里，就要开始调试EF源码了，我今天调了一下，实在是看不懂，但是找到了这个DetectChanges,我在里面加了句Console&lt;/p&gt;

&lt;p&gt; 我们主要面向的是DbContext这个上下文，但是在DbContext上下文中还有一个内部的上下文叫做InternalContext,具体原理不清楚。在内部它使用的的是ObjectContext,而DetectChanges()方法就是在这里面。比如我们调用SaveChanges()方法时，其实他最终会调用DetactChanges&lt;/p&gt;
&lt;p&gt;不只SaveChanges这一个方法会调用DetectChange,还有其他的几个方法，这几个方法，作者为我们列出来了&lt;/p&gt;
&lt;p&gt;DbSet.Find&lt;/p&gt;
&lt;p&gt;DbSet.Local&lt;/p&gt;
&lt;p&gt;DbSet.Remove&lt;/p&gt;
&lt;p&gt;DbSet.Add&lt;/p&gt;
&lt;p&gt;DbSet.Attach&lt;/p&gt;
&lt;p&gt;DbContext.SaveChanges&lt;/p&gt;
&lt;p&gt;DbContext.GetValidationErrors&lt;/p&gt;
&lt;p&gt;DbContext.Entry&lt;/p&gt;
&lt;p&gt;DbContext.Tracker.Entries&lt;/p&gt;
&lt;p&gt;先，现在我们来看一下，这是另一个项目，有三个model。和上面的一样，Order订单类、Porduct产品类、BaseEntity基类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_376b32b3-6736-4f93-8a2e-b4b74abe92df&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_376b32b3-6736-4f93-8a2e-b4b74abe92df&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_376b32b3-6736-4f93-8a2e-b4b74abe92df&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  基类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; BaseEntity()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Id =&lt;span&gt; Guid.NewGuid().ToString();
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.AddTime =&lt;span&gt; DateTime.Now;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DateTime AddTime { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 订单类&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Order : BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;string&lt;/span&gt; OrderNO { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;string&lt;/span&gt; Description { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; ICollection&amp;lt;Product&amp;gt; Products { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  产品类 &lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Product : BaseEntity
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;decimal&lt;/span&gt; Price { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Unit { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; FK_OrderId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Order Order { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;那么我们先添加一个订单验证一下，看看Entiry和SaveChanges是不是调用了DetectChanges方法。可以看到他调用了三次DetectChanges方法，Add一次，SaveChanges一次，Entry一次&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_86b179d2-3b84-4cb8-be9c-4a76353b0d9a&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_86b179d2-3b84-4cb8-be9c-4a76353b0d9a&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_86b179d2-3b84-4cb8-be9c-4a76353b0d9a&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
Order o = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Order
{
      OrderNO &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order9999&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
      Description &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;xxx&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
};
 ctx.Orders.Add(o);
 ctx.SaveChanges();
 Console.WriteLine(ctx.Entry(o).State);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt; 那我们现在对一个查询出来的产品数据，修改它的属性，调用Entry获取它的状态，如果调用了DetectChanges并且状态改变，那么就是快照追踪；如果状态改变并且没有调用DetectChanges则说明使用的是代理追踪&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_059e14fb-9602-4da4-970e-5ea3a57c1b32&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_059e14fb-9602-4da4-970e-5ea3a57c1b32&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_059e14fb-9602-4da4-970e-5ea3a57c1b32&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; order =&lt;span&gt; ctx.Orders.FirstOrDefault();
Console.WriteLine(ctx.Entry(order).State);
order.OrderNO &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dfdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
Console.WriteLine(ctx.Entry(order).State);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt; 上面的说明是快照跟踪。同时也说明了另一个问题，我查询的是第一个订单，订单里面的产品集合我是用virtual修改是，根据上面的结论这个实体类型和他的导航属性类型是代理类型，这就说明了，不是有了代理类型，就会使用代理追踪&lt;/p&gt;
&lt;p&gt;代理追踪需要满足两个条件,二者缺一不可，我试了的，各位可以试一下&lt;/p&gt;
&lt;p&gt;1、设置：AutoDetectChangesEnabled = false; 关闭自动追踪&lt;/p&gt;
&lt;p&gt; 2、将你要设置为代理追踪的model的所有属性加上virtual，如果继承了基类也需要将基类的属性加上virtual&lt;/p&gt;
&lt;p&gt;那么现在再来看，我们将OrderNo属性修改，此时这个属性是被virtual修饰了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_3f78d0d5-8135-468b-90b6-759e7e56a407&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_3f78d0d5-8135-468b-90b6-759e7e56a407&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_3f78d0d5-8135-468b-90b6-759e7e56a407&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
ctx.Configuration.AutoDetectChangesEnabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; order =&lt;span&gt; ctx.Orders.FirstOrDefault();
Console.WriteLine(ctx.Entry(order).State);
order.OrderNO &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dfdf&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
Console.WriteLine(ctx.Entry(order).State);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt; 可以看到状态改变，并且没有调用DetectChanges()方法，这就是代理追踪。&lt;/p&gt;
&lt;p&gt;现在我只是实现了代理追踪的方式，但是对于快照和代理的性能还一无所知，那么明天我就来简单弄一下。为什么说简单弄一下，因为作者给出的结论就是：这两种追踪方式性能上基本没什么区别，EF团队也没有在代理追踪上花太多功夫，这是一个没什么用的东西。&lt;/p&gt;
&lt;p&gt;而且我自己也实在对这个东西不了解，面对源码完全是懵的。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;代理追踪与延迟加载的关系&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;最后来看一下代理追踪和延迟加载的关系,他们之间有什么关系呢？&lt;/p&gt;
&lt;p&gt;首先我们看看下面的查询，我们关闭代理：ProxyCreationEnabled = false；接着查询第一个产品&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_697f50cc-a50c-4c7b-8187-cd3e6b6d268c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_697f50cc-a50c-4c7b-8187-cd3e6b6d268c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_697f50cc-a50c-4c7b-8187-cd3e6b6d268c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
ctx.Configuration.ProxyCreationEnabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; prod =&lt;span&gt; ctx.Products.FirstOrDefault();
Console.WriteLine(JsonConvert.SerializeObject(prod,&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;序列化出的JSON如下，可以看到，导航属性Order为Null&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_26f10001-9b7a-4fdd-9afe-2cb1ec5011c4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_26f10001-9b7a-4fdd-9afe-2cb1ec5011c4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_26f10001-9b7a-4fdd-9afe-2cb1ec5011c4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;Name&quot;: &quot;柚子&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;Price&quot;: 5&lt;span&gt;,
    &lt;/span&gt;&quot;Unit&quot;: &quot;斤&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;FK_OrderId&quot;: &quot;0b03be26-8c3d-40b9-bf85-7dbd877b3f4e&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;Order&quot;: &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
    &lt;/span&gt;&quot;Id&quot;: &quot;18dec640-b54f-4593-8342-2b7393f8c018&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;AddTime&quot;: &quot;2019-01-20T12:33:39.53&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 这是为什么？关闭延迟加载不应该是设置LazyLoadingEnabled = false;  或者将virtual关键字去掉吗？为什么关闭了代理也无法延迟加载了？&lt;/p&gt;
&lt;p&gt;其实延迟加载必须满足三个条件&lt;/p&gt;
&lt;p&gt;1.Configuration.ProxyCreationEnabled = true;&lt;/p&gt;
&lt;p&gt;2.Configuration.LazyLoadingEnabled = true;&lt;/p&gt;
&lt;p&gt;3.导航属性修饰符必须为virtual&lt;/p&gt;
&lt;p&gt;这就是他们之间的关系，更深入的关系我也说不上来，真遗憾。&lt;/p&gt;
&lt;p&gt;其实有一个事比较奇怪，那就是我分别关闭代理和延迟，序列化出来的JSON内容一样，但是顺序不一样，一起来看下&lt;/p&gt;
&lt;p&gt;关闭延迟&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_5d86fa65-56a0-4f7d-a0ff-eff66944638f&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5d86fa65-56a0-4f7d-a0ff-eff66944638f&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5d86fa65-56a0-4f7d-a0ff-eff66944638f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  关闭延迟&lt;/span&gt;
ctx.Configuration.LazyLoadingEnabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; prod = ctx.Products.Include(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).First();
Console.WriteLine(JsonConvert.SerializeObject(prod,&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_20e54111-cc41-4b1c-af5b-11c10a169152&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_20e54111-cc41-4b1c-af5b-11c10a169152&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_20e54111-cc41-4b1c-af5b-11c10a169152&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;Order&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;Id&quot;: &quot;0b03be26-8c3d-40b9-bf85-7dbd877b3f4e&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;OrderNO&quot;: &quot;ttttttt&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;Description&quot;: &quot;xxx&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;AddTime&quot;: &quot;2019-01-20T12:33:39.53&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;Products&quot;&lt;span&gt;: []
    },
    &lt;/span&gt;&quot;Name&quot;: &quot;柚子&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;Price&quot;: 5&lt;span&gt;,
    &lt;/span&gt;&quot;Unit&quot;: &quot;斤&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;FK_OrderId&quot;: &quot;0b03be26-8c3d-40b9-bf85-7dbd877b3f4e&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;Id&quot;: &quot;18dec640-b54f-4593-8342-2b7393f8c018&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;AddTime&quot;: &quot;2019-01-20T12:33:39.53&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;关闭代理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;&lt;img id=&quot;code_img_closed_ebc7aa5c-774a-4c0e-b9bf-6d30dc3860b6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ebc7aa5c-774a-4c0e-b9bf-6d30dc3860b6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ebc7aa5c-774a-4c0e-b9bf-6d30dc3860b6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  关闭代理&lt;/span&gt;
ctx.Configuration.ProxyCreationEnabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; prod = ctx.Products.Include(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).First();
Console.WriteLine(JsonConvert.SerializeObject(prod, &lt;/span&gt;&lt;span&gt;set&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_a7ca4316-9ef9-4ac3-a9f6-ab7d20a6c28d&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_a7ca4316-9ef9-4ac3-a9f6-ab7d20a6c28d&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_a7ca4316-9ef9-4ac3-a9f6-ab7d20a6c28d&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;Name&quot;: &quot;柚子&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;Price&quot;: 5&lt;span&gt;,
    &lt;/span&gt;&quot;Unit&quot;: &quot;斤&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;FK_OrderId&quot;: &quot;0b03be26-8c3d-40b9-bf85-7dbd877b3f4e&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;Order&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;OrderNO&quot;: &quot;ttttttt&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;Description&quot;: &quot;xxx&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;Products&quot;&lt;span&gt;: [],
        &lt;/span&gt;&quot;Id&quot;: &quot;0b03be26-8c3d-40b9-bf85-7dbd877b3f4e&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;AddTime&quot;: &quot;2019-01-20T12:33:39.53&quot;&lt;span&gt;
    },
    &lt;/span&gt;&quot;Id&quot;: &quot;18dec640-b54f-4593-8342-2b7393f8c018&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;AddTime&quot;: &quot;2019-01-20T12:33:39.53&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 同时关闭延迟和代理，序列化出来的JSON和仅关闭代理是一样的&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_75f24ab0-7fd2-45f4-8107-78d09fa50bb4&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_75f24ab0-7fd2-45f4-8107-78d09fa50bb4&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_75f24ab0-7fd2-45f4-8107-78d09fa50bb4&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  那我们来同时关闭延迟和代理&lt;/span&gt;
ctx.Configuration.LazyLoadingEnabled = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
ctx.Configuration.ProxyCreationEnabled &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;               
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; prod = ctx.Products.Include(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).First();
Console.WriteLine(JsonConvert.SerializeObject(prod,&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_2d8acaf0-a934-4f67-b04c-aeaaaee49cf0&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_2d8acaf0-a934-4f67-b04c-aeaaaee49cf0&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_2d8acaf0-a934-4f67-b04c-aeaaaee49cf0&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;Name&quot;: &quot;柚子&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;Price&quot;: 5&lt;span&gt;,
    &lt;/span&gt;&quot;Unit&quot;: &quot;斤&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;FK_OrderId&quot;: &quot;0b03be26-8c3d-40b9-bf85-7dbd877b3f4e&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;Order&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;OrderNO&quot;: &quot;ttttttt&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;Description&quot;: &quot;xxx&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;Products&quot;&lt;span&gt;: [],
        &lt;/span&gt;&quot;Id&quot;: &quot;0b03be26-8c3d-40b9-bf85-7dbd877b3f4e&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;AddTime&quot;: &quot;2019-01-20T12:33:39.53&quot;&lt;span&gt;
    },
    &lt;/span&gt;&quot;Id&quot;: &quot;18dec640-b54f-4593-8342-2b7393f8c018&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;AddTime&quot;: &quot;2019-01-20T12:33:39.53&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 我们上面的都是关闭延迟加载，序列化的结果都是，导航属性里面的导航属性是为空的&lt;/p&gt;
&lt;p&gt;那么如果我不关闭延迟加载，直接使用Netonsoft.json的忽略循环引用的配置来序列化，则会发现不一样。他是导航属性里面的导航属性还有值&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img id=&quot;code_img_closed_5623b203-21f3-4abd-bb50-92c93db27476&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_5623b203-21f3-4abd-bb50-92c93db27476&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_5623b203-21f3-4abd-bb50-92c93db27476&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  忽略循环引用&lt;/span&gt;
JsonSerializerSettings &lt;span&gt;set&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonSerializerSettings();
&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;.ReferenceLoopHandling =&lt;span&gt; ReferenceLoopHandling.Ignore;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res =&lt;span&gt; ctx.Products.FirstOrDefault();
Console.WriteLine(JsonConvert.SerializeObject(res,&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;&lt;img id=&quot;code_img_closed_7d88082d-6c7f-4c2f-9c95-e0be6d22756c&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_7d88082d-6c7f-4c2f-9c95-e0be6d22756c&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_7d88082d-6c7f-4c2f-9c95-e0be6d22756c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;81&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&quot;Order&quot;&lt;span&gt;: {
        &lt;/span&gt;&quot;Id&quot;: &quot;0b03be26-8c3d-40b9-bf85-7dbd877b3f4e&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;OrderNO&quot;: &quot;ttttttt&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;Description&quot;: &quot;xxx&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;AddTime&quot;: &quot;2019-01-20T12:33:39.53&quot;&lt;span&gt;,
        &lt;/span&gt;&quot;Products&quot;&lt;span&gt;: [
            {
                &lt;/span&gt;&quot;Name&quot;: &quot;椪柑&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;Price&quot;: 3.3&lt;span&gt;,
                &lt;/span&gt;&quot;Unit&quot;: &quot;斤&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;FK_OrderId&quot;: &quot;0b03be26-8c3d-40b9-bf85-7dbd877b3f4e&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;Id&quot;: &quot;3959d99c-ab5f-4c28-a7b4-687337ca205d&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;AddTime&quot;: &quot;2019-01-20T12:33:39.53&quot;&lt;span&gt;
            },
            {
                &lt;/span&gt;&quot;Name&quot;: &quot;橙子&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;Price&quot;: 4.9&lt;span&gt;,
                &lt;/span&gt;&quot;Unit&quot;: &quot;斤&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;FK_OrderId&quot;: &quot;0b03be26-8c3d-40b9-bf85-7dbd877b3f4e&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;Id&quot;: &quot;cdcb9a8e-1fd2-4ec3-8351-81097b254598&quot;&lt;span&gt;,
                &lt;/span&gt;&quot;AddTime&quot;: &quot;2019-01-20T12:33:39.53&quot;&lt;span&gt;
            }
        ]
    },
    &lt;/span&gt;&quot;Name&quot;: &quot;柚子&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;Price&quot;: 5&lt;span&gt;,
    &lt;/span&gt;&quot;Unit&quot;: &quot;斤&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;FK_OrderId&quot;: &quot;0b03be26-8c3d-40b9-bf85-7dbd877b3f4e&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;Id&quot;: &quot;18dec640-b54f-4593-8342-2b7393f8c018&quot;&lt;span&gt;,
    &lt;/span&gt;&quot;AddTime&quot;: &quot;2019-01-20T12:33:39.53&quot;&lt;span&gt;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; 最后总算要结束了，今天在调试EF源码的时候碰到了一个有意思的东西，我已经制作成了GIF图。&lt;/p&gt;
&lt;p&gt;什么东西呢？就是我们在调试程序的时候，比如我们要查看某一个变量里面的情况，那么鼠标移上去，会出现下拉框显示关于这个变量的信息。&lt;/p&gt;
&lt;p&gt;可是我碰到的这个还真不是简单的显示，你看我这个，我每次移动上去触发显示详情，EF就会发起一次查询。&lt;/p&gt;


</description>
<pubDate>Mon, 21 Jan 2019 17:46:00 +0000</pubDate>
<dc:creator>张四海</dc:creator>
<og:description>要专业系统地学习EF推荐《你必须掌握的Entity Framework 6.x与Core 2.0》。这本书作者（汪鹏，Jeffcky）的博客：https://www.cnblogs.com/Creat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinshan-go/p/10301710.html</dc:identifier>
</item>
<item>
<title>十年老鸟倾囊分享撬开企业之门的简历情书 - Martin666</title>
<link>http://www.cnblogs.com/51bc/p/10301696.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/51bc/p/10301696.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1574024/201901/1574024-20190122005949419-1743758757.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;说句很实在的话，面试虽然不是找女朋友哈，但事实也差不了多少，你看上了公司，公司选择了你，这事就也就一拍即合！当然啦，现实生活中，绝大部分的情况都是男追女，倒追的有，但很少，比如我。。。(&lt;span&gt;后面必须省略，请原谅我家里刑具太多&lt;/span&gt;)哈哈！找工作也一样，绝大部分情况是我们主动找公司。。。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      好了，既然大家都认同，那么，我们就要使出浑身解数来追求这个“白富美”了，不然真的是跟钱过不去！有一句俗话说得好呀，“&lt;span&gt;&lt;strong&gt;知己知彼，方能百战不殆！&lt;/strong&gt;&lt;/span&gt;&quot;，那么，我也有个建议，就是“&lt;span&gt;&lt;strong&gt;倾其所有，不如投其所好&lt;/strong&gt;&lt;/span&gt;”！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，请大家思考一个问题，&lt;span&gt;企业为什么要找人，她想要找什么样的人，你需要成为什么样的人，才可以俘获她的芳心？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       新手朋友如果没有经历过职场，可以理解在这方面的孤陋寡闻，没关系！大家上人才网看看就知道了，比如前程无忧(www.51job.com) 、智联招聘(https://www.zhaopin.com/)等,有很多企业招人的资讯，归纳起来，无外乎是下面几点：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;span&gt;技术不错，也就是活好！&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;学习能力强，积极上进&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;团队精神，即指听话、目标一致、协同共进&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;span&gt;抗压能力，做事认真，吃苦耐劳,任劳任怨&lt;/span&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1574024/201901/1574024-20190122010837865-394162023.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;OK！有了这点认识，基本上和“知彼”搭上边了，“知己”的话就不聊了，这个全世界只有你自己最清楚！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      那么，接下来就是准备好诱人的“东东”，投其所好了！这个说起来简单，也很好理解，即是说，她需要什么，就竭尽所能满足她，满足不了，也要让上靠，尽量塑造自己，给自己镀金！但实际做的时候，我觉得这里面有两重含义，我们需要这样去理解：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      面试前，懂“她”的简历是必备的！怎么懂？一封简历从你怀着无比期望的心情按下投递按钮的那一刻，它接下来会经过这样一个流程，先到公司人事的邮箱，经过人事筛选再推荐给技术Leader, 技术Leader 觉得不错，你才会得到温柔的人事MM 亲切的问候！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，我们不难发现这里面有两道关卡，一是人事，二是技术Leader！那么，要突破这两道防线，不下点功夫是不行的，怎么突破？颇具技巧，就看你怎么投其所好了！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，&lt;strong&gt;人事MM&lt;/strong&gt;一般都不懂技术，所以，她&lt;strong&gt;重点考察&lt;/strong&gt;的内容是：学历，工作经验，曾经在工作中的表现，并归纳你的技术特征，与用人部门的需求进行匹配，如果没问题，第一道就可以轻松突破，总而言之，在这个环节，攻陷人事的措辞要言简意赅，重点突出！千万别让人事在你简历的杂草丛中找亮点。另外，切记写上&lt;strong&gt;：&lt;/strong&gt;&lt;span&gt;有天下无敌的抗压能力，自己健硕得像条能任劳任怨的老黄牛，外加感动苍天的团队合作精神！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1574024/201901/1574024-20190122011007894-1245051260.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      其次，是&lt;strong&gt;技术Leader&lt;/strong&gt;, 技术Leader 可以说一般就是只火眼金睛的&lt;strong&gt;泼猴&lt;/strong&gt;，请原谅我连自己也“骂”了！所以，这关的话，不要想着忽悠谁，在简历上，我们应该尽可能详细的描述我们擅长的技术和项目经验，特别对自己擅长的，要尽可能深入描述，面试官往往并不是全能型的，说不定某个点还真的可以“忽悠”一把！自己不擅长的，也不要浮夸其辞，避免一两句就被拆穿的尴尬，直接淘汰出局！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好了，如果注意了以上事项，那么到此为止，我们大众化的“情书”是准备好啦！接下来，就是物色心仪的“女友”投递“情书”，在这个点，我觉得大家肯定都是未来的大内高手！然后，如果在投递前，能根据岗位需求微调一下，会更容易等到面试机会！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;最后，祝大家早日成为企业的“高富帅”，迎娶自己的“白富美”！！！&lt;/span&gt;&lt;/p&gt;

&lt;hr/&gt;&lt;p&gt; 文章转自本人公众号：&lt;span&gt;&lt;strong&gt;零基础零障碍学习C语言 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;百分之百原创，转载必须征得本人同意！否则，我将追杀到海角天涯！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 21 Jan 2019 17:21:00 +0000</pubDate>
<dc:creator>Martin666</dc:creator>
<og:description>说句很实在的话，面试虽然不是找女朋友哈，但事实也差不了多少，你看上了公司，公司选择了你，这事就也就一拍即合！当然啦，现实生活中，绝大部分的情况都是男追女，倒追的有，但很少，比如我。。。(后面必须省略，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/51bc/p/10301696.html</dc:identifier>
</item>
<item>
<title>对拼多多事件的思考，理解流程为何如此重要 - 云是风的梦</title>
<link>http://www.cnblogs.com/lijinfeng042/p/10301609.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lijinfeng042/p/10301609.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;今天IT界最火的新闻莫过于拼多多被褥羊毛事件，损失达到千万级别。&lt;a href=&quot;https://news.163.com/shuangchuang/19/0121/14/E62639R300019E21.html&quot;&gt;新闻链接：拼多多公布“优惠券漏洞”案件进展：上海警方已成立专案组&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;从披露的信息来看，此优惠券是拼多多与江苏卫视《非诚勿扰》合作时，因节目录制需要特殊生成的优惠券类型，被生成二维码传播领取。&lt;/p&gt;
&lt;p&gt;漏洞从凌晨被羊毛党发现，5点左右扩散传播到网络，10点左右修复。据说内部还是因为程序员发现并发异常才发现的，这翻车操作。。。&lt;/p&gt;
&lt;p&gt;作为一名互联网电商行业的程序员，我针对公司目前的一些流程有了新的认识。&lt;/p&gt;
&lt;h2 id=&quot;发布流程&quot;&gt;发布流程&lt;/h2&gt;
&lt;p&gt;每一次测试完QA环境之后，然后还要上预发布环境测试，一开始我也是觉得很不理解的。预发布环境是跟生产环境配置一模一样的系统，只是&lt;strong&gt;不对外启用&lt;/strong&gt;，站点配置的访问权限一般都是针对内外的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跟开发环境不同，预发布环境不允许开发人员直接接触，修改配置和发布都需要通过运维。都是有记录，可回滚的操作。&lt;/strong&gt; 而直接修改数据库，那是不可能的。每一个改动都需要提工单，层层审批，最后提交运维执行。&lt;/p&gt;
&lt;p&gt;App上线，正式版本测试通过后，也是经过小应用市场投放，产品验收，业务试单，灰度测试一段时间，监控后台数据正常才会在各个应用市场投放。&lt;/p&gt;
&lt;h2 id=&quot;审批流程&quot;&gt;审批流程&lt;/h2&gt;
&lt;p&gt;这里主要想说的是业务后台的管理流程。没有从事过相关工作，对于优惠券发放流程都是想当然的。当然不同公司会有些出入，但是整体流程都是相似的。&lt;/p&gt;
&lt;p&gt;一张优惠券从申请到上线需要经过多个系统。有效期，适用用范围，优惠方式，数量，活动目标，这几个内容应该是申请审批的重点。&lt;br/&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/66cf5bc0ly1fzemxlhr20j20k00mtq8m.jpg&quot;/&gt;&lt;br/&gt;针对拼多多这张爆出问题的优惠券，我做一个表格：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;有效期&lt;/td&gt;
&lt;td&gt;2019.01.20-2020.01.20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;适用范围&lt;/td&gt;
&lt;td&gt;全网&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;限制&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;无门槛&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;优惠方式&lt;/td&gt;
&lt;td&gt;减&lt;strong&gt;100&lt;/strong&gt;元&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;数量&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;没有限制，或至少几十万张&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;看了这个优惠券的数据，几千万真金白银还敢批的，也是够可以的。就算是烧钱，这种力度没有老板亲自批谁也不敢承担责任啊。&lt;/p&gt;
&lt;p&gt;因此，这种券在生产环境造出来就是一个&lt;strong&gt;定时炸弹&lt;/strong&gt;。我就更加理解为何我们试单财务单证每次都是只提供几张正式环境的优惠券，使用后正式上线前，还要对数据进行清洗。&lt;/p&gt;
&lt;h2 id=&quot;风控管理&quot;&gt;风控管理&lt;/h2&gt;
&lt;p&gt;这个不方便展开，简单说说思路：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;前端用户使用优惠参与活动等黑名单风险识别&lt;/li&gt;
&lt;li&gt;下单风险识别，自动拦截风险订单人工客服处理&lt;/li&gt;
&lt;li&gt;业务BI数据指标监控告警&lt;/li&gt;
&lt;li&gt;核心业务链路人员管理&lt;/li&gt;
&lt;li&gt;线上事件管理流程&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;电商行业是灰黑产的重灾区，业务设计从源头上就需要考虑到多种复杂的流程漏洞问题。如何风险监控，最大程度降低损失，值得我们每一个人深思。&lt;/p&gt;
&lt;p&gt;作为程序谁也不敢保证没有Bug，关键就是如果在设计，开发，测试，运营过程中对暴露的Bug迅速响应，有一套规则去处理，减少损失，而不能祈求道德和法律层面的自觉。&lt;/p&gt;
&lt;p&gt;也期待拼多多事件从法律上可以给出一个判例，毕竟几千万啊，呵呵，普通公司也就直接破产了。&lt;/p&gt;
&lt;p&gt;本文同步发表在公众号文章 &lt;a href=&quot;https://mp.weixin.qq.com/s/Iy1KkrbyHvZ5sVCCyOo_EQ&quot;&gt;对拼多多事件的思考，理解流程为何如此重要&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;博客是我学习过程的输出，希望你有所收获。&lt;/li&gt;
&lt;li&gt;有想法请留言，共同探讨学习。&lt;/li&gt;
&lt;li&gt;由于博主能力有限，文中可能存在描述不正确，欢迎指正、补充！&lt;/li&gt;
&lt;li&gt;你也可以关注我的公众号：&lt;strong&gt;ProgramLife042&lt;/strong&gt;，名称：&lt;strong&gt;风之程序人生&lt;/strong&gt;，方便接收最新内容。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/mw690/66cf5bc0ly1fv6etki980j20760763yz.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 21 Jan 2019 16:08:00 +0000</pubDate>
<dc:creator>云是风的梦</dc:creator>
<og:description>前言 今天IT界最火的新闻莫过于拼多多被褥羊毛事件，损失达到千万级别。 '新闻链接：拼多多公布“优惠券漏洞”案件进展：上海警方已成立专案组' 。 从披露的信息来看，此优惠券是拼多多与江苏卫视《非诚勿扰</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lijinfeng042/p/10301609.html</dc:identifier>
</item>
<item>
<title>毕业后的这几年 - hengly94</title>
<link>http://www.cnblogs.com/hengly/p/10295525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hengly/p/10295525.html</guid>
<description>&lt;h2&gt;从2014年接触到IT到一直到现在，注定了与这个行业的不解之缘&lt;/h2&gt;
&lt;h3&gt;最近在博客园看到了很多篇好的文章 给我了很多启发 希望能在这里认识更多的小伙伴&lt;/h3&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;萌芽期&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;  &lt;span&gt;  我记得那时我在读高二的时候，拥有了自己的第一部手机(天语小黄峰)当时里面的软件很感兴趣就一直在想这个东西是怎么做的，去问过老师和同学都没有结果 我就自己在百度上查资料经过一番查找打听之后才了解到这些软件都是计算机编程出来的 当时觉得很厉害的样子 于是在自己心里就暗自下定决心上大学一定要选择有关计算机的专业&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;      后来高中毕业之后大学选择专业都不&lt;span&gt;同意我选择计算机专业 在他们眼里学计算机到时候不天天上网 这还得了 老爸让我去学海员 老妈让我去学医生 我说我就想学计算机要么就不读&lt;/span&gt;&lt;/span&gt;&lt;span&gt;后来家里也没有办法很无可奈何的让我选择了计算机这个专业(我也很庆幸自己能够选择这个行业不管以后好与不好怨不了别人因为是你选的 而我上学之后发现很多同学不知道选择什么专业 都是父母给选的)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;学习期&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580092/201901/1580092-20190120152701326-1634973949.jpg&quot; alt=&quot;&quot; width=&quot;697&quot; height=&quot;393&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;      &lt;span&gt; 到了大学之后感觉一切都很新鲜 有学长学姐去接我们新生, 也想着能够在大学好好学习 没想到来到学校之后就感觉不对劲了, 大学还要上 早自习 晚自习(当时还没听说过有哪个大学要上晚自习的 有点孤陋寡闻了 )后来我去问我在其他学校读书的同学 发现他们不上, 当时在想 这啥学校呀? 而且每天还是六节课（三节大课）我当时在想这是大学吗? 不是说大学课不是很多吗？当时有无数个疑问在脑海中出现 算了 既来之则安之吧 好好学习! 不用挂科 哈哈!!&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        我在大学很少玩游戏 每次周末的时候寝室的人就一起开黑, 开黑不说, 每次遇到坑队友就飚脏话, 六个人就我一个不玩, 有时候感觉自己很另类 （我就默默做我自己的东西） 一次两次还好 后来每到周末我就不在宿舍呆要么去图书馆. 要么找协会里的面的下伙伴玩, 一起去骑行 野炊  打球~~我也是属于那种不喜欢宅的人 不然小时候别人跟我起的外号叫(&lt;strong&gt;猴子&lt;/strong&gt;）了 多动 在协会里面认识了很多智取相投的小伙伴 现在想起来真是一段难忘的经历。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       有一天协会有个朋友问我想不想创业？我当时听着一脸懵 创业？啥创业？当时听着多么熟悉的名字， 其实自己也想着大学毕业后去创业但是没方向， 当时我就去问他是做什么的 “速卖通”脑子里一片空白 啥啥 后来回去查了一下跨境电商平台 我说可以呀 ！于是就开始 说了立马干， 很快就见到了， 其他的小伙伴 电商、英语、计算机、旅游 的来自各个专业的人， 起初我们在一起讨论团队的名字， 最后经过几个小时的商讨&lt;strong&gt;“小仔汇”&lt;/strong&gt;就诞生了 每天只要是有时间就会去团队(&lt;strong&gt;九点下晚自习然后就过去 基本上都是十一点回寝&lt;/strong&gt;) 虽然每天都很累但感觉很开心时间也过得很快 有一天我像往常一样查看电商平台的数据的时候居然发现了一件衣服的够买数据一下子飚升成直线上升趋势 感觉有点不对劲 再一看衣服的价格 瞬间就知道原因了 本来是&lt;strong&gt;20$&lt;/strong&gt;一件的衣服 被多加了个小数点 变成了几点&lt;strong&gt;几$&lt;/strong&gt;你说谁不疯抢（&lt;strong&gt;消费者才不是傻子&lt;/strong&gt;）有便宜白不占 但是我们并没有去指责哪一个人这是谁做的怎么这么粗心啦（&lt;strong&gt;让我想到了这几天平多多的&quot;羊毛党&lt;/strong&gt;&lt;/span&gt;&lt;strong&gt;&quot;&lt;span&gt;事件&lt;/span&gt;&lt;/strong&gt;）&lt;span&gt;而是一起商量怎么解决这个问题 后来我们我决定给 &lt;strong&gt;每位客户写一封致歉信&lt;/strong&gt; 然后送&lt;strong&gt;点小礼品&lt;/strong&gt; 希望别人能够理解, 有的人能够说的同（&lt;strong&gt;死活都让你发货&lt;/strong&gt;） 也有的人说不通那也没办法 ,给你差评 ,在速卖通上很严格 ,差评多了就要关店啦! 后来没办法把店铺给关了, 这件事也让我知道了创业的辛苦 一步出错, 全盘皆输.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      后来有幸参加了孝感市举行的青年创业比赛， 参加比赛之前每个人的心里都是忐忑的每天想着项目会有哪些问题 ，该怎么去解决这些问题 ，每天晚上我们都是讨论问题到十点多钟才回寝室还要做一些ppt 文档  每天就一起讨论， 就这样几个星期之后参加比赛了，第一参加高大上的比赛心里想着没获奖也开心了(&lt;strong&gt;当时给我印象最深的是一个女企业家 一个电力公司的总经理 她说我今天来参加这个比赛就是为了证明你们男人能做到的我们女人也能做到那是相当的霸气&lt;/strong&gt;) 比赛结束之后也轻松了很多 大概一个星期之后， 收到通知说项目获得了三等奖 ，得到了一万元的创业项目基金 每个人都非常开心 所有的努力都值了 &lt;strong&gt;仅有的一张团队图片&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580092/201901/1580092-20190121235244101-1010700492.jpg&quot; alt=&quot;&quot; width=&quot;811&quot; height=&quot;456&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;&lt;strong&gt;&lt;span&gt;毕业期&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       感觉大学过得很快 转眼就要离开学校 一毕业就打算去北京 班上一共37人 就我一个说要去北京 其他人都去了光“上广深” 说什么北京雾霾大 沙尘暴多 别去那里吃灰 有同学调侃说让我带个口罩过去 我当时就怼了他们 别人明星国家领导都住在那里 我还怕个球  来到北京之后每天就一边投简历 一边找工作 每天晚上先要把面试公司地址找到怎么打车 每天花在路上的时间都好几个小时 有时候位置偏半天都找不到 晚上回去在做题 第二天早早再起来继续 一天~两天~三天~都没消息 每次都是这样 新里想到底啥时候是个头 每天晚上独自一人走在天桥上面思考着以前总听别人说北漂的辛酸故事始终体会不到 现在体会到了 因为在这个城市里没有任何人 有的只有你自己你靠不了任何人 每天吃着包子啃着泡面 就这样持续了两个多星期 第一份工作找到了心里很开心转正前3.5k 转正后5k ，刚开始也没想着挣多少钱也挣不着多少钱 就是让自己能够积累经验学点东西 公司是一个小公司 但是人还不错氛围也挺好的 做了一段时间后就离职了 想从事Java方向的 虽然在学校里面学过但是之前做前端忘了很多 于是就报了一个培训班 好好补补 总是听有人说培训班很坑 （我觉得因人而异吧）虽然现在每天也是九九六&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     经常听别人说程IT这个行业很枯燥 无趣 试想一下一份工作让你整天到晚面对这电脑你能不枯燥吗?换做任何事情都是如此 我觉得工作之余培养自己一两项兴趣爱好真的很重要 我们的生活除了工作还有其他的事情 有的人会说我的兴趣是打游戏 在公司里整天面对电脑 在家里也盯着电脑（想想也恐怖）多去外面转转运动运动 跑跑步 听听歌 我觉得我的生活已经被编程和音乐给占满了 每天都会在回家的路上听着歌曲 有时候都不由自主的唱起来了 旁边的人都会投来诧异的眼光 等过了之后又继续哼着小曲 做一个 爱音乐 爱生活 爱编程 的程序猿。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      我不知道能够在这个行业能够待多长时间 但是看到这么多的人还在奋斗 我也要加油！！！不然离大神们的脚步越来越远呢 &lt;/span&gt;&lt;span&gt;                &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;span&gt;  &lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 21 Jan 2019 16:06:00 +0000</pubDate>
<dc:creator>hengly94</dc:creator>
<og:description>从2014年接触到IT到一直到现在，注定了与这个行业的不解之缘 最近在博客园看到了很多篇好的文章 给我了很多启发 希望能在这里认识更多的小伙伴 萌芽期 我记得那时我在读高二的时候，拥有了自己的第一部手</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hengly/p/10295525.html</dc:identifier>
</item>
<item>
<title>C# List引用类型的克隆 - 陈国良</title>
<link>http://www.cnblogs.com/cglandy/p/10301548.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cglandy/p/10301548.html</guid>
<description>&lt;p&gt;有时候我们想克隆一个List去做别的事，而不影响原来的List,我们直接在list后面加上小点点，发现并没有Clone这样的扩展函数。这时候就只有自己扩展了。&lt;/p&gt;
&lt;p&gt;尝试了三种方式，测试都通过了，至于性能方面我还没有做测试。&lt;/p&gt;
&lt;p&gt;一、反射&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;T&amp;gt; Clone&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; List&amp;lt;T&amp;gt; list) &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             List&amp;lt;T&amp;gt; items = &lt;span&gt;new&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; m &lt;span&gt;in&lt;/span&gt;&lt;span&gt; list)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; model = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; T();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ps =&lt;span&gt; model.GetType().GetProperties();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; properties =&lt;span&gt; m.GetType().GetProperties();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; p &lt;span&gt;in&lt;/span&gt;&lt;span&gt; properties)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; pm &lt;span&gt;in&lt;/span&gt;&lt;span&gt; ps)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt; (pm.Name ==&lt;span&gt; p.Name)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                            pm.SetValue(model, p.GetValue(m));
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                items.Add(model);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; items;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、序列化（依赖Newtonsoft.Json)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;T&amp;gt; Clone&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; List&amp;lt;T&amp;gt; list) &lt;span&gt;where&lt;/span&gt; T : &lt;span&gt;new&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; str =&lt;span&gt; JsonConvert.SerializeObject(list);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; JsonConvert.DeserializeObject&amp;lt;List&amp;lt;T&amp;gt;&amp;gt;&lt;span&gt;(str);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;三、序列化（BinaryFormatter）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;T&amp;gt; Clone&amp;lt;T&amp;gt;(&lt;span&gt;this&lt;/span&gt; List&amp;lt;T&amp;gt;&lt;span&gt; list)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;using&lt;/span&gt; (Stream objectStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MemoryStream())
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 IFormatter formatter = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BinaryFormatter();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                formatter.Serialize(objectStream, list);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 objectStream.Seek(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, SeekOrigin.Begin);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; (List&amp;lt;T&amp;gt;&lt;span&gt;)formatter.Deserialize(objectStream);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Test()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     List&amp;lt;NormalSetting&amp;gt; list = &lt;span&gt;new&lt;/span&gt; List&amp;lt;NormalSetting&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     list.Add(&lt;span&gt;new&lt;/span&gt; NormalSetting { RedisIp = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; });
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     List&amp;lt;NormalSetting&amp;gt; items =&lt;span&gt; list.Clone();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     list[&lt;span&gt;0&lt;/span&gt;].RedisIp = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     logMessager.Show(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{0}:{1}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, list[&lt;span&gt;0&lt;/span&gt;].RedisIp, items[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].RedisIp);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/43951/201901/43951-20190121232623391-232085980.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意事项：&lt;/p&gt;
&lt;p&gt;第一种方式无需任何依赖。&lt;/p&gt;
&lt;p&gt;第二种方式需要Newtonsoft.Json，如果项目中没有用到它，不推荐使用这种方式。&lt;/p&gt;
&lt;p&gt;第三种方式序要给引用类型实体加上[Serializable]特性&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 15:30:00 +0000</pubDate>
<dc:creator>陈国良</dc:creator>
<og:description>有时候我们想克隆一个List去做别的事，而不影响原来的List,我们直接在list后面加上小点点，发现并没有Clone这样的扩展函数。这时候就只有自己扩展了。 尝试了三种方式，测试都通过了，至于性能方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cglandy/p/10301548.html</dc:identifier>
</item>
<item>
<title>spring之旅第二篇-spring IOC概念及原理分析 - 茶底世界</title>
<link>http://www.cnblogs.com/yuanqinnan/p/10301499.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yuanqinnan/p/10301499.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;一、IOC概念&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;上一篇已经了解了spring的相关概念，并且创建了一个spring项目。spring中有最重要的两个概念：&lt;strong&gt;IOC&lt;/strong&gt;和&lt;strong&gt;AOP&lt;/strong&gt;，我们先从IOC入手。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;IOC&lt;/strong&gt;&lt;span&gt;全称Inversion of Control，中文通常翻译为“控制反转”，这其实不是一种技术，而是一种思想。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;简单理解就是把原先我们代码里面需要实现的对象创建、依赖的代码，反转给容器来帮忙实现。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这里&lt;span&gt;&lt;strong&gt;分享Iteye的开涛对Ioc的精彩讲解&lt;/strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;地址：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://jinnianshilongnian.iteye.com/blog/1413846&quot;&gt;https://jinnianshilongnian.iteye.com/blog/1413846&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;IoC是什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;Ioc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想。&lt;/strong&gt;&lt;span&gt;在Java开发中，&lt;span&gt;&lt;strong&gt;Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。&lt;/strong&gt;&lt;span&gt;如何理解好Ioc呢？理解好Ioc的关键是要明确“谁控制谁，控制什么，为何是反转（有反转就应该有正转了），哪些方面反转了”，那我们来深入分析一下：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　●&lt;span&gt;&lt;strong&gt;谁控制谁，控制什么：&lt;/strong&gt;&lt;span&gt;传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；&lt;span&gt;&lt;strong&gt;谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　●&lt;span&gt;&lt;strong&gt;为何是反转，哪些方面反转了：&lt;/strong&gt;&lt;span&gt;有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？&lt;span&gt;&lt;strong&gt;因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　用图例说明一下，传统程序设计如图1-1，都是主动去创建相关对象然后再组合起来：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://images2015.cnblogs.com/blog/249993/201610/249993-20161004152619832-169850656.jpg&quot;&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/249993/201610/249993-20161004152619832-169850656.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;图1-1 传统应用程序示意图&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;当有了IoC/DI的容器后，在客户端类中不再主动去创建这些对象了，如图2-2所示:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://images2015.cnblogs.com/blog/249993/201610/249993-20161004152826535-1580521182.png&quot;&gt;&lt;img src=&quot;https://images2015.cnblogs.com/blog/249993/201610/249993-20161004152826535-1580521182.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;图1-2有IoC/DI容器后程序结构示意图&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;IoC能做什么&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;IoC 不是一种技术，只是一种思想，一个重要的面向对象编程的法则，它能指导我们如何设计出松耦合、更优良的程序。传统应用程序都是由我们在类内部主动创建依赖对象，从而导致类与类之间高耦合，难于测试；有了IoC容器后，把创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是 松散耦合，这样也方便测试，利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　其实&lt;span&gt;&lt;strong&gt;IoC对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC容器来创建并注入它所需要的资源了。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;IoC很好的体现了面向对象设计法则之一—— 好莱坞法则：“别找我们，我们找你”；即由IoC容器帮对象找相应的依赖对象并注入，而不是由对象主动去找。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;IoC和DI&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;DI—Dependency Injection，即“依赖注入”&lt;/strong&gt;&lt;span&gt;：&lt;span&gt;&lt;strong&gt;组件之间依赖关系&lt;/strong&gt;&lt;span&gt;由容器在运行期决定，形象的说，即&lt;span&gt;&lt;strong&gt;由容器动态的将某个依赖关系注入到组件之中&lt;/strong&gt;&lt;span&gt;。&lt;span&gt;&lt;strong&gt;依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。&lt;/strong&gt;&lt;span&gt;通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”，那我们来深入分析一下：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　●&lt;span&gt;&lt;strong&gt;谁依赖于谁：&lt;/strong&gt;&lt;span&gt;当然是&lt;span&gt;&lt;strong&gt;应用程序依赖于IoC容器&lt;/strong&gt;&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　●&lt;span&gt;&lt;strong&gt;为什么需要依赖：*&lt;/strong&gt;&lt;span&gt;*应用程序需要IoC容器来提供对象需要的外部资源**；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　●&lt;span&gt;&lt;strong&gt;谁注入谁：&lt;/strong&gt;&lt;span&gt;很明显是&lt;span&gt;&lt;strong&gt;IoC容器注入应用程序某个对象，应用程序依赖的对象&lt;/strong&gt;&lt;span&gt;；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;●注入了什么：&lt;/strong&gt;&lt;span&gt;就是&lt;span&gt;&lt;strong&gt;注入某个对象所需要的外部资源（包括对象、资源、常量数据）&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;　　&lt;span&gt;&lt;strong&gt;IoC和DI&lt;/strong&gt;&lt;span&gt;由什么&lt;span&gt;&lt;strong&gt;关系&lt;/strong&gt;&lt;span&gt;呢？其实它们&lt;span&gt;&lt;strong&gt;是同一个概念的不同角度描述&lt;/strong&gt;&lt;span&gt;，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，&lt;span&gt;&lt;strong&gt;“*&lt;/strong&gt;&lt;span&gt;*依赖注入”&lt;span class=&quot;md-empty&quot;&gt;&lt;span&gt;明确描述了“被注入对象依赖IoC&lt;span class=&quot;md-empty&quot;&gt;&lt;span&gt;容器配置依赖对象”。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;相信通过上面的文章，对IOC的理解会更深。下面讲讲三种依赖注入的方式&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;构造方法注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;顾名思义，构造方法注入，就是被注入对象可以通过在其构造方法中声明依赖对象的参数列表， 让外部（通常是IoC容器）知道它需要哪些依赖对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; classA(IinterfaceA a,IinterfaceB b){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a=&lt;span&gt;a;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.b=&lt;span&gt;b;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;setter 方法注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;对于JavaBean对象来说，通常会通过setXXX()和getXXX()方法来访问对应属性。这些setXXX()方法统称为setter方法，getXXX()当然就称为getter方法。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; classB(){
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IinterfaceA a;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IinterfaceB b;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IinterfaceA getIinterfaceA(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; a;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setIinterfaceA(IinterfaceA a){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.a=&lt;span&gt;a;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IinterfaceB getIinterfaceB(){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; b;
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setIinterfaceB(IinterfaceB b){
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.b=&lt;span&gt;b;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;接口注入&lt;/strong&gt; &lt;span&gt;　&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;创建Person （被注入对象）要实现的接口&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserInject{
        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; injectUser(User user);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里必须 是被注入对象依赖的对象&lt;/span&gt;
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Person 对象实现接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt; Person &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserInject{ 
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; User user; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Person(){} 
    @Override 
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; injectUser(User user)
    {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.user = user;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实现注入方法，外部通过此方法给此对象注入User对象&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;外部调injectUser方法为Persion对象注入User对象，此即接口注入&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;三种注入方式的比较&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;5.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;接口注入。从注入方式的使用上来说，接口注入是现在不甚提倡的一种方式，基本处于“退役状态”。因为它强制被注入对象实现不必要的接口，带有侵入性。而构造方法注入和setter方法注入则不需要如此。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;构造方法注入。这种注入方式的优点就是，对象在构造完成之后，即已进入就绪状态，可以 9马上使用。缺点就是，当依赖对象比较多的时候，构造方法的参数列表会比较长。而通过反射构造对象的时候，对相同类型的参数的处理会比较困难，维护和使用上也比较麻烦。而且在Java中，构造方法无法被继承，无法设置默认值。对于非必须的依赖处理，可能需要引入多个构造方法，而参数数量的变动可能造成维护上的不便。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;setter方法注入。因为方法可以命名，所以setter方法注入在描述性上要比构造方法注入好一些。 另外，setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。缺点当然就是对象无法在构造完成后马上进入就绪状态。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;综上所述，构造方法注入和setter方法注入因为其侵入性较弱，且易于理解和使用，所以是现在使用最多的注入方式；而接口注入因为侵入性较强，近年来已经不流行了。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;二、源码分析&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在学习spring的具体配置之前，先了解下源码的基本结构。上一篇的测试代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ApplicationContext ctx=&lt;span&gt;new&lt;/span&gt; ClassPathXmlApplicationContext(&quot;META-INF/applicationContext.xml&quot;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取bean的实例&lt;/span&gt;
HelloWorld t=(HelloWorld) ctx.getBean(&quot;hello&quot;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们大致分析下过程：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;3&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;通过Resource对象加载配置文件&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;解析配置文件,得到bean&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;解析bean,id作为bean的名字,class用于反射得到bean的实例(Class.forName(className));&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;调用getBean的时候,从容器中返回对象实例。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;当然这只是简单的理解，IOC核心内容是beanFactory与ApplicationContext&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;strong&gt;BeanFactory&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;BeanFactory 是 Spring 的“心脏”。它就是 Spring IoC 容器的真面目。Spring 使用 BeanFactory 来实例化、配置和管理 Bean，BeanFactory有着庞大的继承、实现体系，有众多的子接口、实现类。&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1113901/201901/1113901-20190121230459062-1263771299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;9&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;BeanFactory作为一个主接口不继承任何接口，暂且称为&lt;span&gt;&lt;strong&gt;一级接口&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;有3个子接口继承了它，进行功能上的增强。这3个子接口称为&lt;span&gt;&lt;strong&gt;二级接口&lt;/strong&gt;&lt;span&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ConfigurableBeanFactory可以被称为&lt;span&gt;&lt;strong&gt;三级接口&lt;/strong&gt;&lt;span&gt;，对二级接口HierarchicalBeanFactory进行了再次增强，它还继承了另一个外来的接口SingletonBeanRegistry&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;ConfigurableListableBeanFactory是一个更强大的接口，继承了上述的所有接口，无所不包，称为&lt;span&gt;&lt;strong&gt;四级接口&lt;/strong&gt;&lt;span&gt;。（这4级接口是BeanFactory的基本接口体系。继续，下面是继承关系的2个抽象类和2个实现类：）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;AbstractBeanFactory作为一个抽象类，实现了三级接口ConfigurableBeanFactory大部分功能。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;AbstractAutowireCapableBeanFactory同样是抽象类，继承自AbstractBeanFactory，并额外实现了二级接口AutowireCapableBeanFactory&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;DefaultListableBeanFactory继承自AbstractAutowireCapableBeanFactory，实现了最强大的四级接口ConfigurableListableBeanFactory，并实现了一个外来接口BeanDefinitionRegistry，它并非抽象类。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;最后是最强大的XmlBeanFactory，继承自DefaultListableBeanFactory，重写了一些功能，使自己更强大。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;最基本的IOC容器接口BeanFactory&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BeanFactory {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;amp;a会得到那个Factory
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String FACTORY_BEAN_PREFIX &lt;/span&gt;= &quot;&amp;amp;&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 四个不同形式的getBean方法，获取实例
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据bean的名字，获取在IOC容器中得到bean实例   &lt;/span&gt;
    Objecpublic &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; BeanFactory {

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 用来引用一个实例，或把它和工厂产生的Bean区分开，就是说，如果一个FactoryBean的名字为a，那么，&amp;amp;a会得到那个Factory
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    String FACTORY_BEAN_PREFIX &lt;/span&gt;= &quot;&amp;amp;&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
     * 四个不同形式的getBean方法，获取实例
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据bean的名字，获取在IOC容器中得到bean实例   &lt;/span&gt;
    Object getBean(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。    &lt;/span&gt;
    &amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt; requiredType) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
    
    &lt;/span&gt;&amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;

    Object getBean(String name, Object... args) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否存在&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsBean(String name); 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否为单实例&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isSingleton(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否为原型（多实例）&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isPrototype(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 名称、类型是否匹配&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isTypeMatch(String name, Class&amp;lt;?&amp;gt;&lt;span&gt; targetType)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到bean实例的Class类型&lt;/span&gt;
    Class&amp;lt;?&amp;gt; getType(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException; 

    String[] getAliases(String name);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据实例的名字获取实例的别名 getBean(String name) throws BeansException;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。    &lt;/span&gt;
    &amp;lt;T&amp;gt; T getBean(String name, Class&amp;lt;T&amp;gt; requiredType) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
    
    &lt;/span&gt;&amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; requiredType) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;

    Object getBean(String name, Object... args) &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否存在&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; containsBean(String name); 
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否为单实例&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isSingleton(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 是否为原型（多实例）&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isPrototype(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 名称、类型是否匹配&lt;/span&gt;
    &lt;span&gt;boolean&lt;/span&gt; isTypeMatch(String name, Class&amp;lt;?&amp;gt;&lt;span&gt; targetType)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到bean实例的Class类型&lt;/span&gt;
    Class&amp;lt;?&amp;gt; getType(String name) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchBeanDefinitionException; 

    String[] getAliases(String name);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据实例的名字获取实例的别名&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BeanFactory接口只是做了最基本的定义，里面不管如何定义和加载，只关心如何得到对象，要知道如何得到对象，必须看具体的实现类，其中XmlBeanFactory就是针对最基本的ioc容器的实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; XmlBeanFactory &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; DefaultListableBeanFactory {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; XmlBeanDefinitionReader reader;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; XmlBeanFactory(Resource resource) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;(resource, (BeanFactory)&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; XmlBeanFactory(Resource resource, BeanFactory parentBeanFactory) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;(parentBeanFactory);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.reader = &lt;span&gt;new&lt;/span&gt; XmlBeanDefinitionReader(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.reader.loadBeanDefinitions(resource);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据Xml配置文件创建Resource资源对象，该对象中包含了BeanDefinition的信息&lt;/span&gt;
 Resource resource = &lt;span&gt;new&lt;/span&gt; ClassPathResource(&quot;META-INF/applicationContext.xml&quot;&lt;span&gt;);
 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建XmlBeanDefinitionReader读取器，用于载入BeanDefinition。之所以需要BeanFactory作为参数，是因为会将读取的信息回调配置给factory&lt;/span&gt;
 BeanFactory beanFactory = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XmlBeanFactory(resource);
 HelloWorld helloWorld &lt;/span&gt;= beanFactory.getBean(&quot;hello&quot;,HelloWorld.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
 System.out.println(helloWorld.getInfo());&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;ApplicationContext&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;ApplicationContext是Spring提供的一个高级的IoC容器，它除了能够提供IoC容器的基本功能外，还为用户提供了以下的附加服务。&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;0&quot;&gt;&lt;li class=&quot;md-list-item md-focus-container&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;支持信息源，可以实现国际化。（实现MessageSource接口）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;访问资源。(实现ResourcePatternResolver接口)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;支持应用事件。(实现ApplicationEventPublisher接口)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;两者的区别&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1.BeanFactroy采用的是延迟加载形式来注入Bean的，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化，这样，我们就不能发现一些存在的Spring的配置问题。而ApplicationContext则相反，它是在容器启动时，一次性创建了所有的Bean。这样，在容器启动时，我们就可以发现Spring中存在的配置错误。 相对于基本的BeanFactory，ApplicationContext 唯一的不足是占用内存空间。当应用程序配置Bean较多时，程序启动较慢。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;BeanFacotry延迟加载,如果Bean的某一个属性没有注入，BeanFacotry加载后，直至第一次使用调用getBean方法才会抛出异常；而ApplicationContext则在初始化自身是检验，这样有利于检查所依赖属性是否注入；所以通常情况下我们选择使用 ApplicationContext。 &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;应用上下文则会在上下文启动后预载入所有的单实例Bean。通过预载入单实例bean ,确保当你需要的时候，你就不用等待，因为它们已经创建好了。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2.BeanFactory和ApplicationContext都支持BeanPostProcessor、BeanFactoryPostProcessor的使用，但两者之间的区别是：BeanFactory需要手动注册，而ApplicationContext则是自动注册。（Applicationcontext比 beanFactory 加入了一些更好使用的功能。而且 beanFactory 的许多功能需要通过编程实现而 Applicationcontext 可以通过配置实现。比如后处理 bean ， Applicationcontext 直接配置在配置文件即可而 beanFactory 这要在代码中显示的写出来才可以被容器识别。 ）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;3.beanFactory主要是面对与 spring 框架的基础设施，面对 spring 自己。而 Applicationcontex 主要面对与 spring 使用的开发者。基本都会使用 Applicationcontex 并非 beanFactory 。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;spring 的IOC实现当然不止这些，这些以后再学，推荐一篇大牛写的博客：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/ITtangtang/p/3978349.html&quot;&gt;https://www.cnblogs.com/ITtangtang/p/3978349.html&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span&gt;看完这些相信对spring IOC概念及其实现会有了一些理性认识了，这里面参考了很多园子里大神的文字，下一篇开始学习spring的配置&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 21 Jan 2019 15:12:00 +0000</pubDate>
<dc:creator>茶底世界</dc:creator>
<og:description>一、IOC概念 上一篇已经了解了spring的相关概念，并且创建了一个spring项目。spring中有最重要的两个概念：IOC和AOP，我们先从IOC入手。 IOC全称Inversion of Co</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yuanqinnan/p/10301499.html</dc:identifier>
</item>
<item>
<title>Excel与Google Sheets中实现线性规划求解 - kentzhang</title>
<link>http://www.cnblogs.com/kentzhang/p/10301487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kentzhang/p/10301487.html</guid>
<description>&lt;p align=&quot;center&quot;&gt;很久没更新过APS系列文章了，这段时间项目工作确实非常紧，所以只能抽点时间学习一下运筹学的入门知识，算是为以后的APS项目积累点基础。看了一些运筹学的书（都是科普级别的）发现原来我目前面对的很多排产、排班、资源分配和路线规划问题，都是运筹学上的典型案例。与此同时，除了继续使用Optaplanner来做我们的规划类项目外，还花点时间去研究了一下Google OR-Tools开源规划引擎，这是Google旗下的一个开源求解器，接下来我会专门写一些关于Google OR-Tools应用的文章，并与Optaplanner作些关联对比。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;本篇先向大家展示一下两个规划工具，在求解线性规划问题上的应用方法，分别是Microsoft Office的Excel里的”规划求解”组件和Google Dos中的Spreadsheet上提供的Linear Optimization插件。这两个工具都可以作为规划问题的求解器。因为它们是以插件或软件功能形式提供的，在灵活性和扩展性方面限制还是比较大，但是因为不涉及软件开发的技能，普通用户都能很好地应用它们来解决一些现实业务中遇到的规则问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;因为Google的Linear Optimization是Google文件服务中的Spreadsheet（Google提供的类似于Excel的电子表格程序），因为目前国内的网络情况（你懂的），访问它需要自己想办法，我们公司总部不在中国境内，所以我们的办公网络经过注册，是可以合法访问外界的；关于网方面不在本篇中讨论，大家自己科学解决就可以了。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;       下面先给出本次我们需要求解的线性规划问题，其实在Optaplanner相关的文章中，详细介绍过关于NPC问题，普通线性规划问题很多并不是NPC问题，因为对于线性规划模型，还是有例如单纯形法等算法推算它的最优解的，而不是所有规划问题的时间复杂度都是O(a^n)或O(n!)的，大家要理解清楚两者的关系。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       我们要求解的问题跟很多运筹学教材或科普书籍上的例子一样，也是最简单的在确定的条件约束下，求最大利润下的产品生产方案问题。例如一家工厂生产两种产品，产品A与产品B，均需使用到三种资源，资源1、资源2和资源3。其中生产一件产品A，需要5个单位的资源1，4个单位的资源2，3个单位的资源3。生产一件产品B需要3个单位的资源1，8个单位的资源2，5个单位的资源3。一个产品A的利润是20，一个产品B的利润是25。库存中三种资源的存量为：280单位的资源1，580单位的资源2，360单位的资源3.见下表：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223212111-912311816.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;求：两种产品分别生产多少件，才能令到总利润最大？此时的利润是多少？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       以上问题是典型的线性规划问题，运筹学的同学可以通过单纯形法进行求解，但是这种方法对于没有运筹学背景的普通工程师来说，困难还是不小。即使我们学会这种办法，但遇到更复杂问题的时候，对我们来说其挑战还是相当大。因此，目前市上，或开源世界里，提供了很多解决此类规划问题的开源软件。但对于非IT人员来说，没有软件开发背景，很难利用这些开源软件工具写程序求解。因此，一些知名的办公软提供了相关的特性，让非IT专业人员直接使用其规划功能，输入数据即可快速求得答案。对各行业的生产、管理活动提供了极大的帮助。下面我们就以Excel和Google Spreadsheet两种工具中的规划求解功能，尝试求解上述问题。 &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;       要解决上述问题，就需要对问题进行线性规划建模，建立数学模型，以数学工具对问题的约束和目标进行归纳、抽象，用数学语言表达问题的本质意义。对于上面的问题我们的建模如下：假设产品A生产x件，产品B生产y件，才能让利润最大化。那么我们通过对问题的约条件和规划目标的分析，可以得出以下数学模型。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223419895-1434200281.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;该模型表示：生产产品A和产品B所需的三种资源的总量，均不能超过每种资源的库存量；并且产品件数量必须是大于等于0的整数。规划的目标函数是找出两种产品的利润之和的最大值，并计算出获得该利润时，两种产品的产量分别是多少。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;对于线性规划问题，其实可以通过单纯形法、对模型进行求解，从而得出z最大时的x与y的值。但此方法需要一定的数学知识，此范围的知识不在本文的讨论范围内，以后若有机会，我再简单介绍一下通过单纯形法对此模型求解步骤。但本人也不是运筹专业出身，估计也只是班门弄斧；因此，大家可以上网寻找更专业的运筹学资源，了解规划模型的解法。本文通过Excel下的规划求解功能，以及Google下的Spreadsheet中的Linear Optimization插件，对该规划模型进行求解，从而取得该生产安排问题的解。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;       Excel提供了一个非常强大的组件用于解决此类规划问题，目前我还只尝试过线性规划问题，根据其资料显示，非线性规划也是可以解的。以后若有机会尝试一下其它规划问题再分享给大家。下面逐一展示这组件具体用法给大家。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;第一步：添加“规则求解”组件&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;因为规则求解功能默认不会出现在Excel的常用工具栏中，因此，需要从加载项目中把它加载出来才能使用。在Excel菜单栏中，选择【文件】-&amp;gt;【选项】，在弹出的【Excel选项】窗口中，选择【加载项】页签，在列表中的【非活动应用程序加载项】（意思是说Excel目前有这些功能可以用，但还没有加载进去，所以不会显示在工具栏中）的其下方找到【规则求解加载项】，如下图.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223627978-1449084006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在列表下方的【管理(A)】下拉框中选择【Excel加载项】，点击【“转到...】按钮，会弹加载项窗口，如下图。在【可用加载宏(A)】列表中，选中【规划求解加载项】，点击确定，窗口关闭。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223705911-82349586.png&quot; alt=&quot;&quot;/&gt;      &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在Excel的【数据】工具栏的最右则，你会看到【规划求解】的图标，即是刚才我们操作完成后加载进来的组件，如下图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223725997-767134091.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;事实上它是Microsoft提供的一个求解器，该组件对应的文件在C:\Program Files (x86)\Microsoft Office\root\Office16\Library\SOLVER此文件夹下。该文件夹下有两个文件，分别是SOLVER.XLAM和SOLVER32.DLL, SOLVER.XLAM是一个Excel的宏文件，用于实现Excel对求解器核心SOLVER32.DLL的调用，因此SOLVER32.DLL应该就是这个求解器的核心程序动态连接库。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;第二步：将问题填入Excel表并建立各变量之间的关系&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;完成规划求解组件加载后，下面就可以将数学模型的各个常量、变量和约束关系填入Excel单元格中；先将两种产品和三种资源对应的使用数量建立一张二维表，如下表。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223824644-1703596535.png&quot; alt=&quot;&quot; width=&quot;484&quot; height=&quot;194&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;通过Excel及规划求解组件解答此问题步骤如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;填&lt;/strong&gt;&lt;strong&gt;入常量：&lt;/strong&gt;上表中，产品A对资源1、资源2和资源3的要求量分别是5，4，3(即B2,B3,B4的值)，其单件利润为20(B5)。 同样方法将产品B对应的数量填入C２- C5单元格中。另外，对于三种资源的库存量，将其值填 入D2 - D4中。自此，模型中涉及的常量已经全部填写时表格。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;根据数学模型，定义运算关系：&lt;/strong&gt;本模型中，我们的目标是求得当z最大时变量x,y的值(x,y在运筹学的规划模型中被称为 决策变量；在Optaplanner中，它们被称作规划变量)。在Excel中每一个决策变量需要确定在一个单元格，以备参与接下来的规划计算，如上表的B6,C6单元格。在未启动规划的时候，这两个单元格直接填上0作为初始值即可。这两个代表决策变量的单元格在完成规划，找到答案后，运算结果值将会被填到对应的单元格中。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;确定好这两个变量后，下一步需要考虑规划目标，也就是总利润最大化的目标，也需要为此目标值确定一个单元格，此单元格的值会在规划完成时，确定了B6和C6两件单元格的值之后计算出来。根据目标函数z = 20x X 25y的定义，此单元格的公式应为 ：B5 * B6 + C5 * C6，即两种产品的利润之和。我们把存储利润之和的值定在D7单元格，为了直观美观，我们把D7与E7合并。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;确定了目标函数值的单元格和计算公式后，下一步需要处理约束条件，也就是产品的资源使用量与库存的约束关系。对于资源1，我们将E2确定为其资源用量，它计算公式应该是:B2 * B6 + C2 * C6,即两种产品对该资源的使用量之和。按相同的规则，设置E3 = B3 * B6+ C3* C6, E4 = B4 * B6 + C4 * C6.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;第三步：设定规划求解逻辑参数&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;通过上述两个步骤设定后，各个单元格的常量值、决策变量和运算关系已设定好。接下来就可以启动【规划求解】插件进行逻辑设定。在【数据】菜单项目中，最右则的【分析】组里，有一个【规划求解】图标，点击它，即可打开【规划求解】窗口(如下图)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121223956162-1962865514.png&quot; alt=&quot;&quot; width=&quot;1110&quot; height=&quot;550&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;以下讲解这些参数意义及其设置。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;1.【设置目标&lt;/strong&gt;&lt;strong&gt;(T)&lt;/strong&gt;&lt;strong&gt;】项&lt;/strong&gt;:该项目我们需要选定一个单元格，表示该单元格是本次规划活动需要计算的目标。通过问题描述和规划模型，我们得知该问题目标是求利润的最大值及取得该利润时两种产品的产量。也即模型中的目标函数z的最大值，及此时的x,y的值。在上表中D7就是存放这个目标函数的单元格，因此这里选中D7即可。在参数设置时，都是使用单元格的绝对地址，因此单元格地址前面都有$符号。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;2.目标值中【到】项&lt;/strong&gt;：该项用于设置对于目标函数的取值要求，可以看到它有【最大值】，【最小值】和【目标值】三个选项。其中【最大值】和【最小值】，表示目标函数往最大或最小两个极值方向求解，即最优解中，D7单元格的值是在满足约束条件情况下取得的最大值。而【目标值】则表示取得最优解时，目标函数值最等于或最接近于此值。本问题中的目标是求利润最大，所以我们选择【最大值】。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;3.【通过更改可变单元格(B)】&lt;/strong&gt;：该项表示在规划过程中求解器，通过改变哪些单元格的值，来获得结果，直到【目标值】所指的单远格（本例中的D7)中的值达到极值。对应到模型中，也就是x与y两个决策变量，本例中对应的单元格是B6和C6，分别表示产品A和产品B的产量。因此，选择B6和C6即可。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;4.【遵守约束】&lt;/strong&gt;：该项内容表示本次规划需要符合的约束条件，也就是模型中的s.t.部分(s.t. 是subject to的缩写)和各个不等式和各变量的范围条件。点击右则的【添加(A)】按钮，弹出【添加约束】窗口(如下图)，可以看到约束的表达方式非常简单，就是添加左右两则值的逻辑关系。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224218459-597434062.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;参照模型中的s.t.部分，和excel中的单元格位置关系，添加它们的关系即可。例如对于资源1，s.t.中的约束条件5x * 3y &amp;lt;= 280, 可参通过选择操作，添加以下关系: E2 &amp;lt;= D2，表示产品A所需资源量与产品B所需资源量之和，不能大于资源库存量。按相同的规则设置好资源2和资源3的约束条件。另外对于决策变量x,y，模型中有这两个变量应为整数，且大于等于0的约束。因此，分选选择B6和C6，并在条件表达关系选择int即可。完成后条件约束的内容如上图中的【遵守约束】列表中的内容。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;5.【选择求解方法】&lt;/strong&gt;：该栏列举了目前可选择的三种求解算法，分别是【单纯线性规划】，即单纯形解法，【非线性GRG】和【演化】。具体的求解方法在选择框下方有简单解释，我们选择默认的【非线性GRG】或【单纯形法】即可。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　&lt;strong&gt;6.【求解】&lt;/strong&gt;：点击【求解】按钮，即会启动求解器进行规划求解。完成后会弹出【规划求解结果】窗口，供进一步操作（例如保存规划方案等）。与此同时，原来在未求解前，因为产量设置为0，所以所需资源（E列）的三个单格E2,E3,E4,以及总利润单元格D7的初始值是0。完成规划后，找到最大利润下两种产品的产量(B6,C6)之后，上述原值为0的单元格的值，也随即被更新为该利润最大方案时对应的值。如下图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224339359-973545515.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;由结果可知，完规划求解后，得到的决策变量值：x=20, y=60, 目标函数z的值为1900，即表示：当产品A生产20个(B6单元格)，产品B生产60(C6单元格)个时，其利润达到最大值1900(D7单元格)。上述规划问题得到完美解。下面我们再使用另外一个工具 - Google Spreadsheet中的线性优化插件，求解同样的问题。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;     &lt;/strong&gt; 对于规划问题，微软和Google通提供了很强大的套件，令到像我这种没有运筹学背景的普通用户，可以方便地求解一些规划问题。在此不得不感叹一下，在此方面国内类似软件与国外的差别。曾经有朋友跟我讨论过，公司使用的国内某个一线办公软件，功能直逼office，办公中绝大部分情况，这个软件都能处理，但遇到一些需要进行规划运算的问题，此软件则没有提供类似的功能，不得不求助于Microsoft Excel。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       说到这种非专业人员用的规划求解工具，不得不延伸提一下规划引擎软件方面，也存同类问题。目前在国内，如果是针对某一大型公司或项目，只要资源到位，实现一个可用的规划引擎问题不算大。但涉及要求更高，可用性更强的通用规划引擎(无论是开源还是商业)国内外的差距就体现出来了。商业求解器领域暂不深入讨论，本人专注于开源规划引擎的应用 研究，近两三年项目应用或自己学习研究中，曾分析应用过一些开源规划引擎，除开优化性能和优化结果的质量上的比较；仅就在工程实践的可用性、易用性上，目前还很难在国内找到一款能跟Optaplanner及Google OR-Tools媲美的开源引擎。先不说可以满足建模要求的引擎软件包，就是求解器方面，国内开源项目也寥寥可数。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       下面开始对Google Spreadsheet中的Linear Optimization插件的应用进行具体介绍。还是在上面已经建立好的数学模型基础上，讨论通过Google的Linear Optimization求解此模型。在开始之前，需要完成以下准备工作：&lt;/p&gt;
&lt;ol start=&quot;1&quot;&gt;&lt;li&gt;&lt;strong&gt;解决网络连接问题&lt;/strong&gt;。这个大家懂的，大家可以自行想办法解决，如果一些在外资或需要访问国外网络的机构工作的朋友（如我们办公室是可能正常合法访问国外网络），则可以跳过此节。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注册Google帐号(若你未有Google帐号）&lt;/strong&gt;。因为Google Docs，Google Spreadsheet均是类似于Microsoft Office的在线文件处理应用服务。无论是哪个Google服务，需要使用必须通过Google帐号。&lt;/li&gt;
&lt;/ol&gt;&lt;p align=&quot;left&quot;&gt;完成上述前期工作后，即可开始Google Spreadsheet的配置和应用。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2 align=&quot;left&quot;&gt;第一步：安装Linear Optimization(线性优化)插件&lt;/h2&gt;
&lt;p align=&quot;left&quot;&gt;       Linear Optimization是Google Spreadsheet的一个插件，可以实现对线性规划模型的求解。默认状态下，Google Spreadsheet是不包括此插件的，需要使用的话，则需要将期添加Spreadsheet中才能使用。下面将操作接步骤列出。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;1.创建Spreedsheet文件&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;登录Google帐号，进入Google Sheets页面（http://sheets.google.com）。进入后Spreadsheet主页后，点击页面右下解的红色添加按钮，创建一个Google Spreadsheet文件。在创建好的文件中，可以将文件命名为“LP_Test”文件即会自动保存到你的Google帐号。如下图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;　　　　　　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224509867-2115452280.png&quot; alt=&quot;&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224550491-2101689754.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;             添加Spreadsheet              重命名文件&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;2. 添加Linear Optimization插件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;通过Spreadsheet页面的Add-ons菜单，将Linear Optimization插件添加到你的帐号上，才能进一步使用该线性优化插件，可以看到还有更多规划功能的插入可以添加。这也是Google在运筹优化方面的系统架构与Optaplanner存在的差别。我将会有新的一篇文章对比两个开源规划引擎这方面的差异，敬请期待。点击Add-ons -&amp;gt; Get add-ons… 菜单项目，将会弹出【Add-ons】页面，在页面上的搜索框中输入”Linear Optimization”并回车，即可搜索出该插件,并点击【+FREE】按钮进行添加。如下图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224634131-996489833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在添加过程中，需要你登录或选择一个已经登录的帐号,选择你已登录的帐号即可，如下图&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224646893-1548257726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;选择或输入帐号后，会转到一个Sign in页面，大概意思是说Linear Optimization将会被添加到指定页面，点击页面底部右则的【Allow】按钮即可。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;3. 创建线性规划模板&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;添加完成后，在【Add-ons】菜下会出现【Linear Optimization】子菜单项，该子菜单下会有用于设置决策变量、约束和求解的子项。见下图。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224751316-403988257.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;选择【Linear Optimization】菜单下的【Set up optimization sheet】子项，即可在当前Sheet中生成求解模板，模板中包含f了决策变量定义区域、目标函数区域和约束区域。下图为新创建的线性规划模板刚创建好的状态.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121224914147-134775963.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;strong&gt;&lt;span&gt;4.填入决策变量、约束和目标函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;创建好线性规划模板后，需要将上面已经建立好的数学规划模型输入模板中对应的单元格，正确地反映数学模型的意义，才启动求解器（Google的在线规划服务，是用通WebAPI提供的，因此其求解器是部署在Google自己的服务器上）。初学者可以通过Linear Optimization菜单下的子项，来辅助输入决策变量和约束。选择Linear Optimization菜单下的【Add Variables...】子项，在页面的右则会显示【Describe data】 页面。该页面中点击【Variables】和【Constrains】页签分别可以提供定义决策变量(即模型中的x,y)和约束条件(即模型中s.t.部分中的不等式)的输入元素。以下是【Variables】的各个字段输入如下：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;a. &lt;strong&gt;Variable Name&lt;/strong&gt;: 该字段表示决策变量，输入第一个决策变量名x.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;b&lt;strong&gt;. Type:&lt;/strong&gt; 从我们建立的规划模型中，知道决策变量x是一个整数，因此Type中选择Integer,(它默认是Continuous).&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;c.&lt;strong&gt;  Lower bound, Upper bound&lt;/strong&gt;:这两个字段分别表示约束变量的最大值与最小值（即决策变量的取值范围），从模型中可以看到它们的最小值是0, 且无最大值限制，因此，Lower bound填上0， Upper bound留空（它提示为Defaults to Infinity,大家应该懂了吧?)。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;d&lt;strong&gt;. Objective coefficient&lt;/strong&gt;:该字段表示该决策变量在目标函数中的系数，也就是目标函数表达式中，x前面的常数，从模型的目标函数上可以看到x前面的技术系数为20，因此填入20即可。点击【Add】按钮，x的相关值及其在目标函数上的体现将会被填入模板中。以相同的规则填入决策变量y相关的信息。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;下面介绍约束的输入，点击【Constraints】页签，页面将会展示约束条件填入界面：&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;a. &lt;strong&gt;Constraint Name&lt;/strong&gt;:因为现在我们是新建立约束，因此在下拉框中选择【New Constraint】, 页面中将会出同【Constraint Name】、【Lower bound】和【 Upper bound】三个字段。【Constraint Name】字段中输入一个名称用于标识该约束即可，因为模型中每个不等式是表示一种资源的限制，因此第一个不等式是针对资源1的库存限制的，我们输入”Resource1”。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;b. &lt;strong&gt;Lower bound&lt;/strong&gt;&lt;strong&gt;，&lt;/strong&gt;&lt;strong&gt;Lower bound&lt;/strong&gt;：以模型的s.t.部分中的首个不等式 &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121225907828-487881289.png&quot; alt=&quot;&quot;/&gt;为例，其实我们根据题意可以把它补充成&lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121225934508-911614235.png&quot; alt=&quot;&quot;/&gt;，也就是说，模型中少了产品A资源用量大于等于０这个限制；其实这样是不严谨的。但因为目标函数是求最大值，因此，大于等于0这个条件不表示出来，也不会影响模型的正确性。但需要在Google的Linear Optimization中表未这个不等式时，必然存此条件才能完整表示，包括以后我们直接使用Google OR-Tools中的线性规划模块，不等式的必须有明确的范围才行。根据上面的不等式，我们在【Lower bound】中填入0，【Upper bound】输入280(即少于等于280)。点【Add】按钮，首个约束就会被添加到模板中，并添加了范围限制见下图红框内.此时,Resource1这一行(第8行)仅仅表示了式子的值域，具体的式子并未完成。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121230028136-910669881.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;c. &lt;strong&gt;Variable Name, Coefficient&lt;/strong&gt;:一上步仅添加了约束Resource1的基本结构。本步骤将要完成不等式中的式子部分。点击【Add】后，页面将会出现【Variable name】下拉框，其中有当前模型的所有决策变量(即本例中的x与y）供选择。在右则还会出现【Variable coefficient】输入框，表示你选择的决策变量在不等式中前面的常数（即技术系数），通过模型我们看到Resource1不等式中x前面的常数是5，因此填入5，并点击【Add】，此时常数5就会被填入当前约束，x对应列的单元格（即D8单元格)。同样地，不等式中决策变量y前面的常是3，因此我们在【Variable name】中选择y，并在【Variable coefficient】中填入3。点击【Add】即可完成约束Resource1的输入。同样的方法输入资源2和资源3的约束，完成后如下图&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121230130139-968541220.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;5.求解&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;完成上述步骤之后，我们建立的规划模型已经全部表达到Linear Optimization模板中，选中【Linear Optimization】菜单下的【Solve】子项，程序将会启用Google的线性规划Web服务，对刚才输入的模型进行求解，并把结果填回表格中，见下图.&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/148283/201901/148283-20190121230609793-1944522223.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       上图是模型的规划结果，可以看到，通过这个模型计算出来的最大的利润是1900(B6单元格)，获得此利润时，产品A的产量是20(D6单元格)，产品B的产量是60(E6单元格).&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;       本文通过对一个简单的线性规划问题，建立线性规划模型；并分别通过Excel的规划求解组件，和Google Spreadsheet下的Linear Optimization插件对模型进行求解，从而得出最优结果。非IT专业人员在实际生产活动中，遇到此类线性规划问题时，可以通过此方法对问题进行求解。而专业的IT人员，遇到的问题会比本文中的情况复杂得多，通过现成的软件功能很可能是无法解决，需要通过软件开发技术，结合规划引擎进行求解。大家可以参考我之前的Optaplanner系列文章 .&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       本人近段时间也在研究Google OR-Tools，发现本文用到的Linear Optimization其实是通过将Google OR-Tools的多个运筹求解器，建立在Google自身的服务器上；再以Web服务方式提供给的。在实际软件项目开发过程中，我们可以绕开Google Spreadsheet服务程序，通过自己的程序调用其运筹优化服务进行求解。当然现目前国内的情况来看，通过对它的开源项目Google OR-Tools的引用，直接将其求解器纳入我们自己开发的系统中更现实。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;       我正在撰写一篇关于Optaplanner与Google OR-Tools的对比文章，通过对比两个引擎的用法，有针对性的引出对Google OR-Tools的应用，敬请期待，谢谢！&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;如需了解更多关于Optaplanner的应用，请发电邮致：&lt;a href=&quot;mailto:kentbill@gmail.com&quot; target=&quot;_blank&quot;&gt;kentbill@gmail.com&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;或到讨论组发表你的意见：&lt;a href=&quot;https://groups.google.com/forum/#!forum/optaplanner-cn&quot; target=&quot;_blank&quot;&gt;https://groups.google.com/forum/#!forum/optaplanner-cn&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;若有需要可添加本人微信（13631823503）或QQ(12977379)实时沟通，但因本人日常工作繁忙，通过微信,QQ等工具可能无法深入沟通，较复杂的问题，建议以邮件或讨论组方式提出。(讨论组属于google邮件列表，国内网络可能较难访问，需自行解决)&lt;/strong&gt;&lt;br/&gt;&lt;/p&gt;



</description>
<pubDate>Mon, 21 Jan 2019 15:08:00 +0000</pubDate>
<dc:creator>kentzhang</dc:creator>
<og:description>很久没更新过APS系列文章了，这段时间项目工作确实非常紧，所以只能抽点时间学习一下运筹学的入门知识，算是为以后的APS项目积累点基础。看了一些运筹学的书（都是科普级别的）发现原来我目前面对的很多排产、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kentzhang/p/10301487.html</dc:identifier>
</item>
</channel>
</rss>