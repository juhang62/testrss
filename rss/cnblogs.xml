<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>SpringBoot 2.x（九）：遇到跨域不再慌 - Vi的技术博客</title>
<link>http://www.cnblogs.com/viyoung/p/10285786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viyoung/p/10285786.html</guid>
<description>&lt;h3 id=&quot;什么是跨域&quot;&gt;什么是跨域&lt;/h3&gt;
&lt;p&gt;首先，我们需要了解一下一个URL是怎么组成的：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;// 协议 + 域名（子域名 + 主域名） + 端口号 + 资源地址&lt;br/&gt;http: + // + www.baidu.com + :8080/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只要&lt;strong&gt;协议，子域名，主域名，端口号&lt;/strong&gt;这四项组成部分中有一项不同，就可以认为是不同的域，不同的域之间互相访问资源，就被称之为跨域。&lt;/p&gt;
&lt;p&gt;随着前后端分离开发的越来越普及，会经常遇到跨域的问题，当我们在浏览器中看到这样的错误时，就需要意识到遇到了跨域：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10641481-948cbe0d4ccae3f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;解决跨域的几种方案&quot;&gt;解决跨域的几种方案&lt;/h3&gt;
&lt;p&gt;首先，我们使用&lt;code&gt;vue-cli&lt;/code&gt;来快速构建一个前端项目，然后使用&lt;code&gt;axios&lt;/code&gt;来向后台发送ajax请求。然后在控制台中打印出返回信息。这里就不再多做赘述，后面我会单独写一篇文章来讲一下如何使用vue-cli快速创建一个vue项目。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这里不再讲解使用&lt;code&gt;jsonp&lt;/code&gt;的方式来解决跨域，因为&lt;code&gt;jsonp&lt;/code&gt;方式只能通过&lt;code&gt;get&lt;/code&gt;请求方式来传递参数，而且有一些不便之处。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;下面的几种方式都是通过&lt;strong&gt;跨域访问技术CORS(Cross-Origin Resource Sharing）&lt;/strong&gt;来解决的。具体的实现原理我们不做深入的探究，这节课的目的是解决跨域问题~&lt;/p&gt;
&lt;h4 id=&quot;方法一注解&quot;&gt;方法一：注解&lt;/h4&gt;
&lt;p&gt;在Spring Boot 中给我们提供了一个注解&lt;code&gt;@CrossOrigin&lt;/code&gt;来实现跨域，这个注解可以实现方法级别的细粒度的跨域控制。我们可以在类或者方添加该注解，如果在类上添加该注解，该类下的所有接口都可以通过跨域访问，如果在方法上添加注解，那么仅仅只限于加注解的方法可以访问。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/user&quot;)
@CrossOrigin
public class UserController {
   @Autowired
    private UserService userService;

   @RequestMapping(&quot;/findAll&quot;)
    public Object findAll(){
        return userService.list();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在再去测试一下：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10641481-b764f7e77e51383e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Bingo，成功！&lt;/p&gt;
&lt;h4 id=&quot;方法二实现webmvcconfigurer&quot;&gt;方法二：实现WebMvcConfigurer&lt;/h4&gt;
&lt;p&gt;这里可以通过实现&lt;code&gt;WebMvcConfigurer&lt;/code&gt;接口中的&lt;code&gt;addCorsMappings()&lt;/code&gt;方法来实现跨域。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
class CORSConfiguration implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping(&quot;/**&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面我们将刚刚加上的注解给注释掉，看看能不能访问到这个接口：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10641481-ddf4721cf12cc17b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不出我们所料，果然还是可以的~&lt;/p&gt;
&lt;h4 id=&quot;方法三filter&quot;&gt;方法三：Filter&lt;/h4&gt;
&lt;p&gt;我们可以通过实现Fiter接口在请求中添加一些Header来解决跨域的问题：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class CORSFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletResponse res = (HttpServletResponse) response;
        res.addHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);
        res.addHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);
        res.addHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;GET, POST, DELETE, PUT&quot;);
        res.addHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,X-CAF-Authorization-Token,sessionToken,X-TOKEN&quot;);
        if (((HttpServletRequest) request).getMethod().equals(&quot;OPTIONS&quot;)) {
            response.getWriter().println(&quot;ok&quot;);
            return;
        }
        chain.doFilter(request, response);
    }
    @Override
    public void destroy() {
    }
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不出意外的话，应该也可以在控制台获取到返回信息。&lt;/p&gt;
&lt;h4 id=&quot;nginx配置解决跨域问题&quot;&gt;Nginx配置解决跨域问题&lt;/h4&gt;
&lt;p&gt;如果我们在项目中使用了Nginx，可以在Nginx中添加以下的配置来解决跨域（原理其实和Filter类似，只不过把活儿丢给了运维🤔）&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;location / {
   add_header Access-Control-Allow-Origin *;
   add_header Access-Control-Allow-Headers X-Requested-With;
   add_header Access-Control-Allow-Methods GET,POST,PUT,DELETE,OPTIONS;

   if ($request_method = 'OPTIONS') {
     return 204;
   }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;原创文章才疏学浅如有不对之处万望告知&quot;&gt;原创文章，才疏学浅，如有不对之处，万望告知！&lt;/h2&gt;
&lt;h3 id=&quot;公众号&quot;&gt;公众号&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/10641481-564fde3219454ceb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;您的推荐就是对我最大的支持！&lt;/p&gt;
</description>
<pubDate>Thu, 17 Jan 2019 23:37:00 +0000</pubDate>
<dc:creator>Vi的技术博客</dc:creator>
<og:description>什么是跨域 首先，我们需要了解一下一个URL是怎么组成的： // 协议 + 域名（子域名 + 主域名） + 端口号 + 资源地址 http: + // + www.baidu.com + :8080/</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/viyoung/p/10285786.html</dc:identifier>
</item>
<item>
<title>Java String：重要到别人只能当老二的字符串类 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/10277688.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/10277688.html</guid>
<description>&lt;p&gt;&lt;img title=&quot;&quot; src=&quot;https://upload-images.jianshu.io/upload_images/1179389-0230f3025330258f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;字符串，是Java中最重要的类。这句肯定的推断不是Java之父詹姆斯·高斯林说的，而是沉默王二说的，因此你不必怀疑它的准确性。&lt;/p&gt;
&lt;p&gt;关于字符串，有很多的面试题，但我总觉得理论知识绕来绕去没多大意思。你比如说：&lt;code&gt;String cmower = new String(&quot;沉默王二&quot;);&lt;/code&gt;定义了几个对象?&lt;/p&gt;
&lt;p&gt;我总觉得问我这样的问题，就好像是在拷问我：“既然你家买了冰箱，你难道不应该知道冰箱制冷的原理？”&lt;/p&gt;
&lt;p&gt;再说，为什么要用&lt;code&gt;String cmower = new String(&quot;沉默王二&quot;);&lt;/code&gt;而不是&lt;code&gt;String cmower = &quot;沉默王二&quot;;&lt;/code&gt;？&lt;/p&gt;
&lt;p&gt;我劝各位面试官不要再缠住这样的问题不放了，切记“学以致用”。理论知识如果一直是在绕弯弯，那真的毫无价值。如果要我来做面试官，我想要问的问题是：“你平常是怎么判断两个字符串相等的？是用equals()还是==？”&lt;/p&gt;
&lt;p&gt;前言就说这么多。接下来，我们来探讨几个实用的知识点。&lt;/p&gt;
&lt;h3 id=&quot;h01&quot;&gt;01 字符串是不可变的&lt;/h3&gt;
&lt;p&gt;我们来看一下String类的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public &lt;span class=&quot;hljs-keyword&quot;&gt;final &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class &lt;span class=&quot;hljs-title&quot;&gt;String&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;implements &lt;span class=&quot;hljs-title&quot;&gt;java.&lt;span class=&quot;hljs-title&quot;&gt;io.&lt;span class=&quot;hljs-title&quot;&gt;Serializable, &lt;span class=&quot;hljs-title&quot;&gt;Comparable&amp;lt;&lt;span class=&quot;hljs-title&quot;&gt;String&amp;gt;, &lt;span class=&quot;hljs-title&quot;&gt;CharSequence {&lt;br/&gt;}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现，String类是final类型的，因此不能被继承。&lt;/p&gt;
&lt;p&gt;如果类可以被继承，那么就会破坏类的不可变性机制。因为子类可以覆盖父类的方法，并且可以改变父类的成员变量值，一旦子类以父类的形式出现时，就不能保证类是不可变的。&lt;/p&gt;
&lt;p&gt;String类的不可变性有什么好处呢？&lt;/p&gt;
&lt;p&gt;1）作为HashMap的键。&lt;/p&gt;
&lt;p&gt;因为字符串是不可变的，因此它在创建的时候哈希码（hash code）就计算好了。这也就意味着每次在使用一个字符串的哈希码的时候不用重新计算一次，这样更加高效，很适合作为HashMap中的键。&lt;/p&gt;
&lt;p&gt;2）线程安全。&lt;/p&gt;
&lt;p&gt;同一个字符串对象可以被多个线程共享，如果访问频繁的话，可以省略同步和锁等待的时间，从而提升性能。&lt;/p&gt;
&lt;p&gt;3）字符串常量池的需要。&lt;/p&gt;
&lt;p&gt;稍后介绍。&lt;/p&gt;
&lt;p&gt;特别要注意的是，&lt;strong&gt;String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;h02&quot;&gt;02 字符串常量池&lt;/h3&gt;
&lt;p&gt;在Java中，常用的创建字符串的方式有两种：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;1&quot;&gt;String cmower = &lt;span class=&quot;hljs-string&quot; readability=&quot;2&quot;&gt;&quot;沉默王二&quot;;&lt;p&gt;String cmowsan = &lt;span class=&quot;hljs-keyword&quot;&gt;new String(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王三&quot;);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;cmower使用双引号，cmowsan使用new关键字，它们有什么区别呢？&lt;/p&gt;
&lt;p&gt;答案如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;String cmower = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;;&lt;br/&gt;String cmower1 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;;&lt;br/&gt;System.out.println(cmower == cmower1); &lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;双引号创建的相同字符串使用&lt;code&gt;==&lt;/code&gt;判断时结果为true，而new关键字创建的相同字符串使用&lt;code&gt;==&lt;/code&gt;判断时结果为false。&lt;/p&gt;
&lt;p&gt;这是为什么呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;String在Java中使用过于频繁，为了避免在系统中产生大量的String对象，Java的设计者引入了“字符串常量池”的概念&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当使用双引号创建一个字符串时，首先会检查字符串常量池中是否有相同的字符串对象，如果有，则直接从常量池中取出对象引用；如果没有，则新建字符串对象，并将其放入字符串常量池中，并返回对象引用。&lt;/p&gt;
&lt;p&gt;这也就是说，&quot;沉默王二&quot;是放在字符串常量池中的，cmower和cmower1两个字符串对象引用是相同的。&lt;/p&gt;
&lt;p&gt;而new关键字创建的字符串对象是不涉及字符串常量池的，直接放在堆中，也就是说，虽然cmowsan和cmowsan1都叫沉默王三，但不一个人。&lt;/p&gt;
&lt;p&gt;强烈建议：不要使用new关键字的形式创建字符串对象。&lt;/p&gt;
&lt;h3 id=&quot;h03stringbuilder&quot;&gt;03 +号和StringBuilder&lt;/h3&gt;
&lt;p&gt;由于字符串是不可变的，因此字符串在进行拼接的时候会创建新的字符串对象。大家都知道，内存是一定的，因此对象创建多了就会影响系统性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;StringBuilder正是为了解决字符串拼接产生太多中间对象的问题而提供的一个类&lt;/strong&gt;，可以通过append()方法把字符串添加到已有序列的末尾，非常高效。&lt;/p&gt;
&lt;p&gt;那么有人在进行字符串拼接的时候，就会产生疑惑：“我到底是用+号还是StringBuilder？”&lt;/p&gt;
&lt;p&gt;我们先来看这样一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;String chenmo = &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默&quot;;&lt;br/&gt;String wanger = &lt;span class=&quot;hljs-string&quot;&gt;&quot;王二&quot;;&lt;br/&gt;System.out.println(chenmo + wanger);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码是怎么编译的呢？可以使用JAD（Java反编译工具）来看一看。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs go&quot;&gt;String s = &lt;span class=&quot;hljs-string&quot;&gt;&quot;\u5A0C\u5910\u7CAF&quot;;&lt;br/&gt;String s1 = &lt;span class=&quot;hljs-string&quot;&gt;&quot;\u941C\u5B29\u7C29&quot;;&lt;br/&gt;System.out.&lt;span class=&quot;hljs-built_in&quot;&gt;println((&lt;span class=&quot;hljs-built_in&quot;&gt;new StringBuilder()).&lt;span class=&quot;hljs-built_in&quot;&gt;append(s).&lt;span class=&quot;hljs-built_in&quot;&gt;append(s1).toString());&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你是不是看到了&lt;code&gt;StringBuilder&lt;/code&gt;的影子？&lt;/p&gt;
&lt;p&gt;没错，使用+号进行字符串拼接的时候，Java编译器实际是通过StringBuilder类来完成的。&lt;/p&gt;
&lt;p&gt;难道可以使用+号来随意拼接字符串？反正Java编译器已经自动地为我们优化了。&lt;/p&gt;
&lt;p&gt;但事实并非如此，来看这样一段代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;String cmowers = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;9; i++) {&lt;br/&gt;cmowers += &lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;;&lt;br/&gt;}&lt;br/&gt;System.out.println(cmowers);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;闭上眼睛先想一想，Java编译器会怎么做？我们期望的结果是在循环外部就创建StringBuilder，Java编译器能如我们所愿吗？&lt;/p&gt;
&lt;p&gt;JAD反编译后的结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs go&quot;&gt;String s = &lt;span class=&quot;hljs-string&quot;&gt;&quot;&quot;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for(&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10; i++)&lt;br/&gt;s = (&lt;span class=&quot;hljs-built_in&quot;&gt;new StringBuilder()).&lt;span class=&quot;hljs-built_in&quot;&gt;append(s).&lt;span class=&quot;hljs-built_in&quot;&gt;append(&lt;span class=&quot;hljs-string&quot;&gt;&quot;\u5A0C\u5910\u7CAF\u941C\u5B29\u7C29&quot;).toString();&lt;p&gt;System.out.&lt;span class=&quot;hljs-built_in&quot;&gt;println(s);&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这么看来，StringBuilder是在for循环内部创建的，也就是说会创建10次。天呐，这可不是我们期望的结果！我们只希望StringBuilder创建一次。&lt;/p&gt;
&lt;p&gt;没办法，Java编译器是做不到的，只能靠我们自己：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;StringBuilder cmowers = &lt;span class=&quot;hljs-keyword&quot;&gt;new StringBuilder();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;9; i++) {&lt;br/&gt;cmowers.append(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot;);&lt;br/&gt;}&lt;br/&gt;System.out.println(cmowers);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;强烈建议：如果只是三四个字符串的拼接，尽管使用+号操作符，别想什么性能优化（举个例子，你离目的地只有100米，你是打算打个出租车，还是自己步行走过去？）；如果遇到多于四个字符串的拼接，或者需要用到循环来拼接，那就选择StringBuilder。&lt;/p&gt;
&lt;p&gt;在我年轻的时候，我还会犯这样一个错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;java language-java hljs&quot;&gt;StringBuilder cmowers = &lt;span class=&quot;hljs-keyword&quot;&gt;new StringBuilder();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;for (&lt;span class=&quot;hljs-keyword&quot;&gt;int i = &lt;span class=&quot;hljs-number&quot;&gt;0; i &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;9; i++) {&lt;br/&gt;cmowers.append(&lt;span class=&quot;hljs-string&quot;&gt;&quot;沉默王二&quot; + &lt;span class=&quot;hljs-string&quot;&gt;&quot;和他的读者朋友们&quot;);&lt;br/&gt;}&lt;br/&gt;System.out.println(cmowers);&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我去，竟然在append()方法的内部使用+号！因为这个错误，我差点没被领导打死。你可要小心点。&lt;/p&gt;
&lt;h3 id=&quot;h04concat&quot;&gt;04 关于concat()&lt;/h3&gt;
&lt;p&gt;除了使用+号和StringBuilder对字符串进行拼接，还可以使用String类的&lt;code&gt;concat()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;concat()方法只不过是String类的一个方法而已，为什么我要单独拎出来说呢？&lt;/p&gt;
&lt;p&gt;因为之前我要在JSP页面的EL表达式中拼接字符串，刚开始想到的是用+号操作符，但EL表达式不是Java，+号操作符是不能拼接字符串的。我当时竟然没想起来用&lt;code&gt;concat()&lt;/code&gt;！&lt;/p&gt;
&lt;p&gt;重新铭记一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs lua&quot;&gt;${item.username.&lt;span class=&quot;hljs-built_in&quot;&gt;concat(&lt;span class=&quot;hljs-string&quot;&gt;'-').&lt;span class=&quot;hljs-built_in&quot;&gt;concat(item.realname)}&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h05intern&quot;&gt;05 关于intern()&lt;/h3&gt;
&lt;p&gt;关于字符串的性能问题，我常在一些技术文章中看到这样的建议：“如果一个字符串使用的频率非常高，建议使用&lt;code&gt;String.intern()&lt;/code&gt;将其缓存。”&lt;/p&gt;
&lt;p&gt;但我并不建议你这么做，因为这个方法要显式的调用，这样很麻烦；况且，在代码编写阶段，怎么可能知道哪个字符串使用频率很高呢？&lt;/p&gt;
&lt;h3 id=&quot;h06stringutils&quot;&gt;06 关于StringUtils&lt;/h3&gt;
&lt;p&gt;据我的编程经验来看，字符串的操作往往需要用到一个工具类，那就是&lt;code&gt;org.apache.commons.lang3.StringUtils&lt;/code&gt;（null安全的，也就是说，StringUtils类的方法可以接受为null的字符串，但不会抛出NullPointerException）。&lt;/p&gt;
&lt;p&gt;不过，我最常用的方法就那么几个：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;方法&lt;/th&gt;
&lt;th&gt;等价&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;IsEmpty(String str)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;str == null || str.length == 0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;isBlank(String str)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;str == null || str.length == 0 || str.trim().length == 0&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;&lt;code&gt;join(Object[] arrey)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;把数组中的元素连接成一个字符串返回&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;

&lt;p&gt;推荐阅读：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.qingmiaokeji.cn/article/11&quot;&gt;Java异常处理：给程序罩一层保险&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;http://www.qingmiaokeji.cn/article/8&quot;&gt;Java集合类：我其实没那么简单&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Jan 2019 23:29:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>字符串，是Java中最重要的类。这句肯定的推断不是Java之父詹姆斯·高斯林说的，而是沉默王二说的，因此你不必怀疑它的准确性。 关于字符串，有很多的面试题，但我总觉得理论知识绕来绕去没多大意</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qing-gee/p/10277688.html</dc:identifier>
</item>
<item>
<title>并发concurrent---1 - 涛姐涛哥</title>
<link>http://www.cnblogs.com/taojietaoge/p/10285607.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/taojietaoge/p/10285607.html</guid>
<description>&lt;p&gt;&lt;span&gt;背景：并发知识是一个程序员段位升级的体现，同样也是进入BAT的必经之路，有必要把并发知识重新梳理一遍。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;说到并发concurrent，肯定首先想到了线程，创建线程有两种方法：1、从Java.lang.Thread类派生一个新的线程类，重载它的run()方法；2、实现Runnalbe接口，重载Runnalbe接口中的run()方法；建议使用方法二创建线程，因为，如果是通过扩展 Thread类的方法来创建线程，那么这个自定义类就不能再去扩展其他的类，也就无法实现更加复杂的功能；而实现Runnable接口的方法来定义该类为线程类，这样就可以避免Java单继承所带来的局限性，也更符合面向对象编程的思想，最重要的就是使用实现Runnable接口的方式创建的线程可以处理同一资源，从而实现资源的共享。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;创建线程的两种方法：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package www.concurent.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TraditionalThread {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread1:&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         Thread thread = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Thread() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                         Thread.sleep(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thread1: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;Thread.currentThread().getName());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        }; 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        thread.start();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Thread2:
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Runnable变量是线程要运行的代码的宿主，更适合面向对象思想的线程方法&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         Thread thread2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                         Thread.sleep(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;thread2: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;Thread.currentThread().getName());
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        thread2.start();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;线程和Timer定时器很类似，下面介绍了两种和线程相似的定时器写法：1、定时一天之后调用方法查询天气情况接口，然后每隔60秒后继续调用该方法；2、定时每天00:39:32调用查询天气情况接口，通过Hutool工具和Timer定时器调用HTTP天气状况接口的返回结果如下截图：(result2得到了天津的天气状况)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190118004920754-1859541685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过Hutool工具和Timer定时器调用HTTP天气状况接口&lt;/span&gt;：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import java.util.Calendar;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import java.util.Date;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import java.util.Timer;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import java.util.TimerTask;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import cn.hutool.http.HttpUtil;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TraditionalTimerTest {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;时间间隔&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;      &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;long&lt;/span&gt; PERIOD_DAY = &lt;span&gt;24&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;60&lt;/span&gt; * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Timer 定时器&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         Calendar cl =&lt;span&gt; Calendar.getInstance();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         cl.&lt;span&gt;set&lt;/span&gt;(Calendar.HOUR_OF_DAY, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         cl.&lt;span&gt;set&lt;/span&gt;(Calendar.MINUTE, 3&lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         cl.&lt;span&gt;set&lt;/span&gt;(Calendar.SECOND, &lt;span&gt;32&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         Date date =&lt;span&gt; cl.getTime();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         Date dateNow = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果第一次执行定时任务的时间 小于 当前的时间
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此时要在 第一次执行定时任务的时间 加一天，以便此任务在下个时间点执行。如果不加一天，任务会立即执行。&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (date.before(dateNow)) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             Calendar clAdd =&lt;span&gt; Calendar.getInstance();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            clAdd.setTime(dateNow);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             clAdd.add(Calendar.DAY_OF_MONTH, &lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;              date =&lt;span&gt; clAdd.getTime();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Timer1:&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Timer().schedule(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Hutool调用http接口&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;                 String result1 = HttpUtil.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://t.weather.sojson.com/api/weather/city/101030100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result1: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;result1);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;一天之后调用方法查询天气情况接口，然后每隔60秒后继续调用该方法&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         },PERIOD_DAY , &lt;span&gt;1000&lt;/span&gt;*&lt;span&gt;60&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Timer2:&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Timer().schedule(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimerTask() {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Hutool调用http接口&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;                 String result2 = HttpUtil.&lt;span&gt;get&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://t.weather.sojson.com/api/weather/city/101030100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 System.&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;result2: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; result2);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定时每天00:39:32调用查询天气情况接口&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }, date , PERIOD_DAY);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; 如果是单个线程调用都还ok，要是有多个线程同时调用那就会出现并发产生；比如有一个方法Output()是经过charAt(i)获取字符串i的字符并且打印再控制台，然后线程A和线程B同时调用Output()方法，此时就会出现线程不安全问题(如银行取钱和转账同时进行)，也就是并发；执行结果发现，线程A为执行完毕线程B就开始执行了，为了能后保证当有一个线程来执行某个方法时，其他的线程不能进来执行该方法，实现排他性，可以通过synchronized和ReentrantLock来实现线程同步；二者其实区别不大，synchronized由于是底层JVM实现的互斥，因此效率会高一些，而ReentrantLock的功能则比synchronized更多，比如定时获取某个锁，多个等待条件等，另外synchronized 会让线程阻塞，ReentrantLock会让线程等待，但是从行为效果上来看是一样的；下面有个例子：并发结果如截图显示，理想状态是打印“huawei”或者“isoftstone”，但是由于并发打印出来诸如此类“ishuaweoftstoni”结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1580332/201901/1580332-20190118010802946-563958188.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FYI:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import java.util.concurrent.locks.Lock;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import java.util.concurrent.locks.ReentrantLock;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MyThreadSynchronized {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要想调用内部类的对象，必须有外部类的实例对象&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; MyThreadSynchronized().init();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 外部类的实例对象&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; init() {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         final Outputer outputer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Outputer();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;thread1:&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                         Thread.sleep(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     outputer.output3(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;huawei&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }).start();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;thread2:&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;false&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                         Thread.sleep(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                        e.printStackTrace();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     outputer.output(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;isoftstone&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        }).start();
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;当有一个线程来执行某个方法时，其他的线程不能进来执行该方法，排他性、独一无二；
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用synchronized/lock同步，且线程用的同步锁是同一个同步对象，可用this互斥或方法.class
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;synchronized由于是底层JVM实现的互斥，因此效率会高一些
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ReentrantLock的功能则比synchronized更多，比如定时获取某个锁，多个等待条件
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;synchronized 会让线程阻塞，ReentrantLock会让线程等待，但是从行为效果上来看是一样的；&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Outputer{
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;内部类  静态方法中不能new内部类的实例对象
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;synchronized:&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; synchronized &lt;span&gt;void&lt;/span&gt;&lt;span&gt; output(String name) {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i&amp;lt;name.length(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 System.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.print(name.charAt(i));
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             System.&lt;span&gt;out&lt;/span&gt;.println();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; switch line&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         
&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;线程不安全&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;  &lt;span&gt;void&lt;/span&gt;&lt;span&gt; output3(String name) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i&amp;lt;name.length(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;                 System.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.print(name.charAt(i));
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             System.&lt;span&gt;out&lt;/span&gt;.println();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; switch line&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;lock：&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ouputlock(String name) {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             Lock &lt;span&gt;lock&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;lock&lt;/span&gt;.&lt;span&gt;lock&lt;/span&gt;();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 上锁同步&lt;/span&gt;
&lt;span&gt;68&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; name.length(); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;                     System.&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.print(name.charAt(i));
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;                 System.&lt;span&gt;out&lt;/span&gt;.println();&lt;span&gt;//&lt;/span&gt;&lt;span&gt; switch line&lt;/span&gt;
&lt;span&gt;73&lt;/span&gt;             } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;                 &lt;span&gt;lock&lt;/span&gt;.unlock();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 解锁&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         
&lt;span&gt;78&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;     
&lt;span&gt;80&lt;/span&gt; }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Thu, 17 Jan 2019 17:10:00 +0000</pubDate>
<dc:creator>涛姐涛哥</dc:creator>
<og:description>背景：并发知识是一个程序员段位升级的体现，同样也是进入BAT的必经之路，有必要把并发知识重新梳理一遍。 说到并发concurrent，肯定首先想到了线程，创建线程有两种方法：1、从Java.lang.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/taojietaoge/p/10285607.html</dc:identifier>
</item>
<item>
<title>MVC、MVCS、MVVM、MVP、VIPER等这么多架构模式哪一个好呢？ - 滴水微澜</title>
<link>http://www.cnblogs.com/zhou--fei/p/10285600.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhou--fei/p/10285600.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;MVC&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;MVC是最经典的架构模式，它出现的时间非常早，也是最被人所熟知的。&lt;/p&gt;
&lt;p&gt;MVC架构的任务分工为：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;M-model：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.数据结构表示 &lt;/p&gt;
&lt;p&gt;2.读取本地数据&lt;/p&gt;
&lt;p&gt;3.写数据到本地&lt;/p&gt;
&lt;p&gt;4.处理弱业务&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-Controller：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.处理主要业务逻辑&lt;/p&gt;
&lt;p&gt;2.处理交互事件&lt;/p&gt;
&lt;p&gt;3.协调V-M数据流&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;V-View：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.展示数据&lt;/p&gt;
&lt;p&gt;2.处理非逻辑交互事件。&lt;/p&gt;

&lt;p&gt;根据上面描述，总之一句话概括：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;M：管理数据， C：处理数据， V：展示数据。&lt;/strong&gt;&lt;/p&gt;

&lt;div readability=&quot;25&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;MVCS&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看名字就感觉这个MVCS架构模式是从MVC中分化出来的，事实上也确实如此。&lt;/p&gt;
&lt;p&gt;S为Store的简称，意思为“存储，保存”。&lt;/p&gt;
&lt;p&gt;下面来看一下多出一个S后，它们的分工有什么变化呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;S-Store：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.负责数据的存储，数据本地持久化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;M-Model：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.数据结构表示 &lt;/p&gt;
&lt;p&gt;2.读取本地数据&lt;/p&gt;
&lt;p&gt;3.处理弱业务&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-Controller：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.处理主要业务逻辑&lt;/p&gt;
&lt;p&gt;2.处理交互事件&lt;/p&gt;
&lt;p&gt;3.协调V-M数据流&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;V-View：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.展示数据&lt;/p&gt;
&lt;p&gt;2.处理非逻辑交互事件。&lt;/p&gt;

&lt;p&gt;从上面的分工可知C，V同MVC架构是完全一样的，只有M的数据存储任务被分离了出来。即：S分担了M的数据管理任务，那么M和S其实都是数据管理的逻辑范畴了。&lt;/p&gt;
&lt;p&gt;根据上面描述，总之一句话概括：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（M+S）：管理数据， C：处理数据， V：展示数据。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;33&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;MVVM&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MVVM为了解决前端的响应式编程而生，由于前端网页混合了HTML、CSS和JavaScript，而且页面众多，代码的组织和维护难度复杂，所以通过ViewModel实现View和Model的双向绑定。&lt;/p&gt;
&lt;p&gt;但是移动端不是前端，从业务处理逻辑上讲，移动端要比前端处理的逻辑更多，你问我有啥依据。你可以把手机的网断掉，进入带有离线功能的APP，一套业务走下来，没啥问题。但是用浏览器打开呢，纵然添加了缓存，也是不能将一套业务走完的。&lt;/p&gt;
&lt;p&gt;所以说，移动端要比前端处理的逻辑多！&lt;/p&gt;

&lt;p&gt;看到MVVM你会有疑问，为啥没有C了，是不是用这个MVVM就不需要C了呢？如果你是移动端的同学，我给你讲是有C的。&lt;/p&gt;
&lt;p&gt;MVVM架构在移动端的完整叫法是：M-V-C-VM。&lt;/p&gt;
&lt;p&gt;MVVM架构的任务分工为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;M-model： &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.数据结构表示 &lt;/p&gt;
&lt;p&gt;2.读取本地数据&lt;/p&gt;
&lt;p&gt;3.写数据到本地&lt;/p&gt;
&lt;p&gt;4.处理弱业务&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C-Controller：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.处理交互事件&lt;/p&gt;
&lt;p&gt;2.协调V-M数据流&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;VM-ViewModel:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.处理主要业务逻辑&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;V-View：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.展示数据&lt;/p&gt;
&lt;p&gt;2.处理非逻辑交互事件。&lt;/p&gt;

&lt;p&gt;从上面的分工可知，VM分担了C中的数据加工任务，将业务处理放到了ViewModel中，其他的M,V同MVC架构完全一样。&lt;/p&gt;
&lt;p&gt;总之一句话概括：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;M：管理数据， （C+VM）：处理数据， V：展示数据。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;29&quot;&gt;&lt;p&gt;&lt;strong&gt;&lt;span&gt;MVP&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MVP从MVC衍生而来，从名称上看只是将C换成了P。其他都一样。而事实上呢？&lt;/p&gt;
&lt;p&gt;它们也确实这样，P承担了C的任务而已。&lt;/p&gt;
&lt;p&gt;区别是：它们两个的数据流向不一样&lt;/p&gt;

&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201901/826860-20190118004550947-64582877.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;MVC的数据流向图&lt;/p&gt;

&lt;div&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/826860/201901/826860-20190118004555513-1943044014.png&quot; alt=&quot;&quot;/&gt;
&lt;/div&gt;
&lt;p&gt;MVP的数据流向图&lt;/p&gt;

&lt;p&gt;对比一下，就可以一样看出了。&lt;/p&gt;
&lt;p&gt;MVC框架中，V的数据从Model中拿&lt;/p&gt;
&lt;p&gt;MVP框架中，V的数据从Presenter中拿。&lt;/p&gt;
&lt;p&gt;MVP架构的任务分工为：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;M-model：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;1.数据结构表示 &lt;/p&gt;
&lt;p&gt;2.读取本地数据&lt;/p&gt;
&lt;p&gt;3.写数据到本地&lt;/p&gt;
&lt;p&gt;4.处理弱业务&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-Presenter：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.处理主要业务逻辑&lt;/p&gt;
&lt;p&gt;2.处理交互事件&lt;/p&gt;
&lt;p&gt;3.协调V，M数据流，从M读取数据，将数据通过接口供V调用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;V-View：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.展示数据&lt;/p&gt;
&lt;p&gt;2.处理非逻辑交互事件。&lt;/p&gt;

&lt;p&gt;根据上面描述，总之一句话概括：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;M：管理数据， P：处理数据， V：展示数据。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;VIPER&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;VIPER是责任粒度划分比较细的一个架构模式，是按照“责任单一原则”的标志来走的，每个类所承担的任务更简单。&lt;/p&gt;
&lt;p&gt;VIPER架构的任务分工为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E-Entity：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.数据结构表示 &lt;/p&gt;
&lt;p&gt;2.读取本地数据&lt;/p&gt;
&lt;p&gt;3.写数据到本地&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I-Interactor：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.处理主要业务逻辑&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P-Presenter:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.处理弱业务&lt;/p&gt;
&lt;p&gt;2.处理交互事件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;R-Routing:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.处理视图的展示顺序逻辑或者说是控制器的跳转控制&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;V-View：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.展示数据&lt;/p&gt;
&lt;p&gt;2.处理非逻辑交互事件。&lt;/p&gt;

&lt;p&gt;根据上面描述，可粗略的概括为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;E：管理数据， （I+P+R）：处理数据， V：展示数据。&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div readability=&quot;65&quot;&gt;
&lt;p&gt;架构从逻辑分层上讲，常见有两种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;三层架构：展示层，业务层，数据层。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四层架构：展示层，业务层，网络层，本地数据层。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;架构从任务分配上讲，常见有五种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MVC、MVCS、MVVM、MVP、VIPER&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;而通常在工程中，这两个维度的思想是同时存在的。&lt;/p&gt;
&lt;p&gt;比如：三层MVC架构，四层MVC架构。&lt;/p&gt;
&lt;p&gt;前面的层级表示逻辑分层方式&lt;/p&gt;
&lt;p&gt;后面的形式表示任务分配方式&lt;/p&gt;

&lt;p&gt;对于上面讲的五种任务分配方式，因为是已经被人熟知，所有被大工程所采用。&lt;/p&gt;

&lt;p&gt;但是目前有个疑惑&lt;/p&gt;
&lt;p&gt;如果有时候一个业务模块很负责时，会不断的讲业务分拆。会产生很多种目录与文件。&lt;/p&gt;
&lt;p&gt;如果模块内视图控制器跳转逻辑负责时，会引入中介者模式进行统一管理跳转。&lt;/p&gt;
&lt;p&gt;这时，模块内的任务分配文件相对于这五种架构模式，显得有点四不像了。&lt;/p&gt;
&lt;p&gt;这时就会疑惑，&lt;strong&gt;我这到底用的是什么架构模式啊？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;通过上面五种架构责任划分的介绍，我们可以知道&lt;/p&gt;
&lt;p&gt;无论是什么架构模式，它们的区别是：任务的分配方式不同罢了。&lt;/p&gt;
&lt;p&gt;虽然我们在任务分配后的文件和目录四不像，但是可以满足我们的业务需求和功能扩展，这就够了。&lt;/p&gt;
&lt;p&gt;不要被形式上所限制。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;那么什么是好的架构模式呢？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;个人认为比较好的架构模式为：三层MVC架构&lt;/p&gt;
&lt;p&gt;任务分配方法是以MVC任务分配方案为基础，按照一定的原则进行个性化分配。&lt;/p&gt;
&lt;p&gt;采用如下分配原则：&lt;/p&gt;
&lt;p&gt;1.保留当前角色的主要功能，拆分次要功能。&lt;/p&gt;
&lt;p&gt;2.弱业务功能放到Model中，尽量不要放到Controller里去。&lt;/p&gt;
&lt;p&gt;3.拆分出去的业务功能尽量封装成可复用组件、对象或协议。&lt;/p&gt;
&lt;p&gt;4.控制好拆分粒度，调用接口少参或无参。&lt;/p&gt;

&lt;p&gt;这样不管形式如何变化，只有架构逻辑分层在，同时满足业务需要和功能扩展就是好架构。&lt;/p&gt;
&lt;/div&gt;


</description>
<pubDate>Thu, 17 Jan 2019 16:42:00 +0000</pubDate>
<dc:creator>滴水微澜</dc:creator>
<og:description>在项目开启阶段，其中一个很重要的环节就是选架构。 那么面对目前已知的这么多架构模式我们该怎么选择呢？这确实是个很让人头疼的问题！ 下面我就在这里梳理一下目前常见的一些架构模式。 先逐个对它们的分析，然</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhou--fei/p/10285600.html</dc:identifier>
</item>
<item>
<title>自主机器人“罗德尼”：第一部分 - I.am.Conmajia</title>
<link>http://www.cnblogs.com/conmajia/p/rodney-robot-part-1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/conmajia/p/rodney-robot-part-1.html</guid>
<description>&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Phil Hopley 著&lt;br/&gt;Conmajia 译&lt;br/&gt;2019 年 1 月 16 日&lt;/p&gt;
&lt;p&gt;原文发表于 CodeProject（2019 年 1 月 15 日）.&lt;/p&gt;
&lt;p&gt;本文是 &lt;strong&gt;House Bot 机器人操作系统&lt;/strong&gt;的第一部分.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;info important&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;全文约 6000 字，建议阅读时间 15 分钟.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190112011856517-760355778.png&quot;/&gt;&lt;a href=&quot;https://www.codeproject.com/KB/boards-embedded-devices/1249436/p1_code_files_v3.zip&quot;&gt;源码 61.7 KB&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190112011856517-760355778.png&quot;/&gt;&lt;a href=&quot;https://www.codeproject.com/KB/boards-embedded-devices/1249436/Rodneys_3D_Prints.zip&quot;&gt;3D 打印文件 70.9 KB&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;u&gt;罗德尼&lt;/u&gt;是我设计的一个&lt;em&gt;自主家庭机器人&lt;/em&gt;. 这是这个项目系列的第一篇文章. 在这部分我主要阐述概念，如何选择单板机，安装 ROS（robot operating system）以及编写第一部分用到的控制软件.&lt;/p&gt;

&lt;p&gt;早在 1970、1980 年代，我买了两本书：&lt;u&gt;David L. Heiserman&lt;/u&gt;&lt;a href=&quot;http://www.cnblogs.com/conmajia/p/rodney-robot-part-1.html#fn1&quot; class=&quot;footnote-ref&quot; id=&quot;fnref1&quot;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; 的《如何打造自编程机器人》和 &lt;u&gt;Tod Loofbourrow&lt;/u&gt;&lt;a href=&quot;http://www.cnblogs.com/conmajia/p/rodney-robot-part-1.html#fn2&quot; class=&quot;footnote-ref&quot; id=&quot;fnref2&quot;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; 的《如何打造计算机控制的机器人》. 当时我打算用我的 Z80 处理器板来制作机器人，可惜这个机器人一直没能诞生. 这么多年过去了，现在有很多类似&lt;strong&gt;树莓派&lt;/strong&gt;（Raspberry Pi）和 &lt;strong&gt;Arduino&lt;/strong&gt; 之类的袖珍单板电脑. 这些新玩意儿让制作复杂的家庭机器人变得特别简单.&lt;/p&gt;
&lt;p&gt;在我那两本启蒙读物中，作者给机器人起名叫&lt;strong&gt;罗德尼&lt;/strong&gt;（Rodney）和&lt;strong&gt;迈克&lt;/strong&gt;（Mike），顺其自然，我给我的机器人起名叫罗德尼.&lt;/p&gt;
&lt;table&gt;&lt;tr&gt;&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117000100013-67006634.jpg&quot;/&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117000126984-1313701346.jpg&quot;/&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/table&gt;&lt;p&gt;图 1 勾起我兴趣的两本机器人制作书籍&lt;/p&gt;
&lt;p&gt;我在 CodeProject 上看到过两篇关于机器人的文章，给我启发很大.&lt;/p&gt;
&lt;p&gt;第一篇文章是《人人都造机器人！》（&lt;em lang=&quot;cmn-latn&quot;&gt;&lt;a href=&quot;https://www.codeproject.com/Articles/1115414/Lets-build-a-robot&quot;&gt;Let's build a robot!&lt;/a&gt;&lt;/em&gt; &lt;a href=&quot;http://www.cnblogs.com/conmajia/p/rodney-robot-part-1.html#fn3&quot; class=&quot;footnote-ref&quot; id=&quot;fnref3&quot;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;）介绍了机器人的基本概念和一些很棒的想法，不过我很怀疑靠这些概念怎么造机器人？这篇文章给我的最大启发是可以用一个小显示器当做机器人的脑袋. 最有用的还是文章里一个 &lt;a href=&quot;https://zenbo.asus.com/&quot;&gt;Pi Robot 的博客链接&lt;/a&gt;，让我第一次认识了&lt;strong&gt;机器人操作系统&lt;/strong&gt;（ROS）. 这实际上是机器人编程的标准，就像维基上对 ROS 的解释：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;ROS（机器人操作系统）为软件开发者创建机器人程序提供各种库函数和工具. 它提供了硬件的抽象，设备驱动，库函数，可视化驱动，消息传递机制，分包管理等等内容. ROS 作为开源软件，通过 BSD 许可授权.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ROS 其实算不是一个真正的操作系统，更像是一个用于 Linux 上的中间件（middleware），尤其适合运行在 Ubuntu 上. 网上可以找到大量开源的 ROS 代码用于各种传感器，可以帮助你集中精力开发机器人程序. ROS 的维基也全是满满的干货，如果你还不熟悉 ROS，去&lt;a href=&quot;http://wiki.ros.org/&quot;&gt;维基&lt;/a&gt;看看就对了.&lt;/p&gt;
&lt;p&gt;第二篇文章是《PiRex：远程控制的树莓派机器人》（&lt;a href=&quot;https://www.codeproject.com/Articles/1237052/PiRex-remote-controlled-Raspberry-Pi-based-robot&quot;&gt;PiRex – remote controlled Raspberry Pi based robot&lt;/a&gt; &lt;a href=&quot;http://www.cnblogs.com/conmajia/p/rodney-robot-part-1.html#fn4&quot; class=&quot;footnote-ref&quot; id=&quot;fnref4&quot;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;）. 尽管涵盖的内容不如第一篇那么广泛，这篇文章完整阐述了一个机器人项目. 两篇文章都用到了树莓派，还是比较便宜的.&lt;/p&gt;
&lt;p&gt;所以，罗德尼不用再像 80 年代我计划的那样先要自制一块处理器板，直接用上了&lt;strong&gt;树莓派3B&lt;/strong&gt;，带 1GB 内存，相当给力.&lt;/p&gt;

&lt;p&gt;这里我将解释如何在项目中使用 ROS 和它提供的工具来测试代码. 我没打算写一篇 ROS 的教程，网上可以找打一大堆，比我能写出来的好得多. 当然我会时不时提供一些 ROS 维基上的链接作为延伸阅读. 现在嘛，我先列出一个提纲和部分 ROS 的名词，休闲读者也可以快速浏览.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;这是一个&lt;strong&gt;分布式系统&lt;/strong&gt;，机器人代码可以在通过网络连接的多台设备上运行&lt;/li&gt;
&lt;li&gt;一个&lt;strong&gt;节点&lt;/strong&gt;（node）负责执行某一任务&lt;/li&gt;
&lt;li&gt;节点以&lt;strong&gt;功能包&lt;/strong&gt;（package）的形式组织，作为一套文件夹或者文件的集合&lt;/li&gt;
&lt;li&gt;可以用多种编程语言来设计节点，我用的是 C++ 和 Python&lt;/li&gt;
&lt;li&gt;节点互相之间用称为&lt;strong&gt;话题&lt;/strong&gt;（topic）的单向流通信&lt;/li&gt;
&lt;li&gt;话题属于即时&lt;strong&gt;消息&lt;/strong&gt;（message），消息是话题的数据结构&lt;/li&gt;
&lt;li&gt;ROS 自带标准消息，也可以定义自己的消息结构&lt;/li&gt;
&lt;li&gt;节点也可以通过服务器／客户端（server/client）的阻塞式协议，使用&lt;strong&gt;服务&lt;/strong&gt;（service）进行通信&lt;/li&gt;
&lt;li&gt;节点还可以通过&lt;strong&gt;动作&lt;/strong&gt;（action）协议进行非阻塞式面向目标任务的通信&lt;/li&gt;
&lt;li&gt;所有节点向系统中唯一的&lt;strong&gt;主机&lt;/strong&gt;（master）注册，即使用分布式系统，主机也是唯一的&lt;/li&gt;
&lt;li&gt;用 catkin 构建和编译代码&lt;/li&gt;
&lt;li&gt;独立的节点可以用 &lt;code&gt;rosrun&lt;/code&gt; 命令调用，也可以用启动工具在一个命令行下启用多个节点&lt;/li&gt;
&lt;li&gt;系统包含了一个&lt;strong&gt;参数服务器&lt;/strong&gt;（parameter server），节点可以在运行过程中存取参数&lt;/li&gt;
&lt;li&gt;系统还包含检查、硬件仿真等多种工具&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既然决定了用树莓派作为处理器，ROS 作为软件系统，第一件要做的事情就是在树莓派上&lt;em&gt;安装&lt;/em&gt; &lt;em lang=&quot;cmn-latn&quot;&gt;ROS&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;ROS 的下载、安装方法可以参考&lt;a href=&quot;http://wiki.ros.org/ROS/Installation&quot;&gt;这个网页&lt;/a&gt;. 但是更轻松的方法是用我制作的预装了 ROS，可以在树莓派上运行的 Ubuntu 系统镜像. 你可以在 &lt;a href=&quot;https://ubiquityrobotics.com/&quot;&gt;Ubiquity Robotics&lt;/a&gt; 网站上下载这个镜像. 镜像中预装的是 Kinetic 版的 ROS，内置了访问树莓派摄像头的 &lt;a href=&quot;https://github.com/ubiquityRobotics/raspicam_node&quot;&gt;raspicam_node&lt;/a&gt; 包. 当然你可以用别的镜像，&lt;a href=&quot;https://github.com/UbiquityRobotics&quot;&gt;GitHub&lt;/a&gt; 上可以下载 Ubiquity 提交的功能包源码.&lt;/p&gt;
&lt;p&gt;罗德尼用到的其他外设有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;7 寸触摸屏&lt;/li&gt;
&lt;li&gt;摄像头模块&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;显示屏显示机器人的状态信息，web 内容，同时显示机器人的表情，算是给了它一张“脸”. 摄像头是机器人的“眼睛”，能进行人脸识别，让它先认出主人来.&lt;/p&gt;
&lt;p&gt;这张是触摸屏的照片，树莓派和摄像头安在屏幕背面，用 3D 打印的零件组装起来. 零件的 &lt;code&gt;.stl&lt;/code&gt; 文件我已经打包出来，&lt;a href=&quot;https://www.codeproject.com/KB/boards-embedded-devices/1249436/Rodneys_3D_Prints.zip&quot;&gt;点击下载&lt;/a&gt;.&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117135532327-911304995.jpg&quot; width=&quot;480px&quot;/&gt;&lt;p&gt;（正面）&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117135543847-1392762844.jpg&quot; width=&quot;480px&quot;/&gt;&lt;p&gt;（反面）&lt;/p&gt;
&lt;p&gt;图 2 罗德尼的脑袋（正面和反面）&lt;/p&gt;
&lt;p&gt;鉴于 ROS 可以在分布式网络上运行，我把我的 Ubuntu PC 机也装上了 ROS，用来开发节点，运行 ROS 测试工具、仿真工具等等.&lt;/p&gt;
&lt;h2 id=&quot;机器人的任务&quot;&gt;机器人的任务&lt;/h2&gt;
&lt;p&gt;设计项目最基本的是确定需求. 对于罗德尼，我打算指定一些想让它完成的功能. 《人人都造机器人！》里罗列了很多家庭机器人可以做的工作，比如：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;帮我带个话&lt;/strong&gt;&lt;br/&gt;&lt;em&gt;既然机器人可以&lt;em&gt;认出&lt;/em&gt;家庭成员，那么让它给某人&lt;em&gt;带个话&lt;/em&gt;就很自然了. 我可以说&lt;q&gt;机器人，帮我告诉&lt;u&gt;某某&lt;/u&gt;下午六点来车站接我.&lt;/q&gt; 之后，即使他电话静音了或者正在嗨音乐，机器人也会跑到他的房间，找到他提醒他.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;听起来不错，也许我的项目可以从这个任务入手. 当然应稍作改进，毕竟我设计的罗德尼可以通过网络浏览器来控制并设置任务.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带个话给某人&lt;/strong&gt;是一个大任务，可以拆分成小的设计目标，各自分别完成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用摄像头观察环境，搜索并识别人脸，找到后显示消息（在脸上）&lt;/li&gt;
&lt;li&gt;面部识别和语音合成.，这样罗德尼可以真正地&lt;em&gt;带个话&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;通过键盘和摇杆遥控机器人移动&lt;/li&gt;
&lt;li&gt;辅助导航的激光雷达或者类似的传感器&lt;/li&gt;
&lt;li&gt;自主移动&lt;/li&gt;
&lt;li&gt;安排任务完成后提示&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;对机器人来说，一个看起来很简单的任务都能列出这么长的单子. 具体实现起来，也不是一两句话能说明白的. 接下来，我把&lt;strong&gt;带个话&lt;/strong&gt;定为“任务 1”，分别设计实现上面各个目标.&lt;/p&gt;
&lt;h2 id=&quot;任务-1目标-1&quot;&gt;任务 1，目标 1&lt;/h2&gt;
&lt;p&gt;要完成这个设计目标，需要：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用 RC 舵机控制机器人的脑袋（摄像头）平移和倾斜&lt;/li&gt;
&lt;li&gt;读取树莓派摄像头拍摄的图片&lt;/li&gt;
&lt;li&gt;检测识别人脸&lt;/li&gt;
&lt;li&gt;依序控制这些动作&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;info&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;u&gt;平移&lt;/u&gt;指舵机在&lt;em&gt;水平方向旋转&lt;/em&gt;，&lt;u&gt;倾斜&lt;/u&gt;指&lt;em&gt;垂直方向旋转&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;本文是第一篇文章，先关注移动机器人的脑袋. 很显然，需要两个&lt;strong&gt;舵机&lt;/strong&gt;分别控制&lt;strong&gt;平移&lt;/strong&gt;（pan）和&lt;strong&gt;倾斜&lt;/strong&gt;（tilt）. 为了扩展，我还添加了一套额外的舵机（2 个）. 这些舵机都是通过 PWM 信号控制的，但是树莓派只有 1 个硬件 PWM 通道，所以要使用软件方式在 GPIO 口输出 PWM 信号. 另外需要注意避免跳舵，我用了一块单独的电路板进行控制.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.piborg.org/sensors-1136/ultraborg&quot;&gt;PiBorg, the UltraBorg&lt;/a&gt; 上有一种模块，通过 I2C 总线把 4 路舵机和 4 路 HC-SR04 超声波传感器连到树莓派. 不过我上一个项目还剩了不少 Arduino Nano，我打算用它来做控制板.&lt;/p&gt;
&lt;p&gt;ROS 社区有很多杰作可以应用，这样我能专心设计我的机器人程序，其他方面，尽量发扬“拿来主义”的精神. 使用 &lt;code&gt;rosserial_arduino&lt;/code&gt; 包，可以把 Arduino 通过串口连接到 ROS，这个包的文档在&lt;a href=&quot;http://wiki.ros.org/rosserial_arduino&quot;&gt;这里阅读&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;使用前，要在 ROS 目标机和 Arduino IDE 里安装 &lt;code&gt;rosserial_arduino&lt;/code&gt;，如果用了自定义消息，那还要重新编译 Arduino 库. 这些操作在&lt;a href=&quot;http://wiki.ros.org/rosserial_arduino/Tutorials&quot;&gt;教程&lt;/a&gt;里都有讲解.&lt;/p&gt;
&lt;p&gt;现在来编写控制各个舵机位置的 ROS 功能包. 这个包的节点将处理平移／倾斜的消息，把它转化成独立的位置消息传给 Arduino，由后者负责控制操作舵机. 第一条消息判断需要移动哪个&lt;strong&gt;关节&lt;/strong&gt;，移动多少；第二条消息发送一个&lt;strong&gt;编号&lt;/strong&gt;和&lt;strong&gt;角度值&lt;/strong&gt;给 Arduino，启动对应的舵机. 这样划分功能后，Arduino 编程时就不必考虑调用它的 ROS，只负责操作舵机.&lt;/p&gt;
&lt;p&gt;第一条消息我用 ROS 内置的 &lt;a href=&quot;http://docs.ros.org/api/sensor_msgs/html/msg/JointState.html&quot;&gt;&lt;code&gt;sensor_msgs/JointState&lt;/code&gt;&lt;/a&gt; 实现. ROS 里标准的位置单位是&lt;em&gt;弧度&lt;/em&gt;，Arduino 接受的角度单位是&lt;strong&gt;度&lt;/strong&gt;，所以在设计节点的时候还要先把弧度换算成度. &lt;code&gt;JointState&lt;/code&gt; 里有不少字段暂时都用不上，虽然有点浪费，不过使用 ROS 内置消息的好处在于可以方便地使用它提供的各种配套工具.&lt;/p&gt;
&lt;p&gt;第二条消息定义了待操作舵机编号和角度. 这里我用了自定义的消息，避免 Arduino 源码里不必要的资源浪费.&lt;/p&gt;
&lt;p&gt;现在来编写用于这两条消息的功能包，以及用于 ROS 的 Arduino 源码.&lt;/p&gt;
&lt;p&gt;控制舵机的功能包消息我命名为 &lt;code&gt;servo_msgs&lt;/code&gt;. 创建好后，它将生成 C++ 和 Python 代码，同时重新编译 Arduino 库生成 &lt;code&gt;.h&lt;/code&gt; 文件.&lt;/p&gt;
&lt;p&gt;实现这个功能包的代码文件包存在 &lt;code&gt;servo_msgs&lt;/code&gt; 文件夹下，包括了一份说明文件以及每个 ROS 功能包都需要的 &lt;code&gt;CmakeList.txt&lt;/code&gt; 和 &lt;code&gt;package.xml&lt;/code&gt; 文件. 这些文件的意义以及如何创建功能包，可以参考这篇&lt;a href=&quot;http://wiki.ros.org/ROS/Tutorials/CreatingPackage&quot;&gt;教程&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;msg&lt;/code&gt; 文件夹包含了消息的定义文件 &lt;code&gt;servo_array.msg&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# index references the servo that the angle is for, e.g. 0, 1, 2 or 3
# angle is the angle to set the servo to
uint8 index
uint16 angle&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;除了编程语法的一点区别，这个定义文件可以理解成 C 语言的结构体. 这个消息将作为 ROS 话题发送给 Arduino，它包含了两个元素，分别指定舵机编号（index）和要设置的角度（angle）.&lt;/p&gt;
&lt;p&gt;这样就完成了一个简单的 ROS 功能包. 接下来将实现用于平移／倾斜的 &lt;code&gt;pan_tilt&lt;/code&gt; 功能包. 这个包的文件都在 &lt;code&gt;pan_tilt&lt;/code&gt; 文件夹下，节点名 &lt;code&gt;pan_tilt_node&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;有几个子文件夹，&lt;code&gt;config&lt;/code&gt; 包含了配置文件 &lt;code&gt;config.yaml&lt;/code&gt;，用来设置给到参数服务器的参数. 这样就能修改系统配置而不需要重新编译代码了. 启动文件的内容如下：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;# Configuration for pan/tilt devices
# In Rodney index0 is for the head and index 1 is spare
servo:
  index0:
    pan:
      servo: 0          
      joint_name: 'head_pan'
    tilt:
      servo: 1
      flip_rotation: true
      max: 0.349066 
      min: -1.39626
      joint_name: 'head_tilt'
  index1:
    pan:
      servo: 2
    tilt:
      servo: 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;index0&lt;/code&gt; 和 &lt;code&gt;index1&lt;/code&gt; 分别给两个平移／倾斜设备（以下简称&lt;strong&gt;设备&lt;/strong&gt;）提供参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;servo&lt;/code&gt; 指定负责当前关节的舵机编号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;joint_name&lt;/code&gt; 指定 &lt;code&gt;joint_state&lt;/code&gt; 消息里关节的名称&lt;/li&gt;
&lt;li&gt;&lt;code&gt;max&lt;/code&gt; 和 &lt;code&gt;min&lt;/code&gt; 用于限制关节移动幅度，单位是弧度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;flip_rotation&lt;/code&gt; 下文解释&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ROS 惯例是&lt;strong&gt;右手定则&lt;/strong&gt;（&lt;a href=&quot;https://en.wikipedia.org/wiki/Right-hand_rule&quot;&gt;right-hand rule&lt;/a&gt;），因此关节的值会围绕正轴的逆时针方向上增大. 现在在罗德尼的头部倾斜舵机安装的方式遵循&lt;strong&gt;左手定则&lt;/strong&gt;，所以需要设置 &lt;code&gt;flip_rotation&lt;/code&gt; 为&lt;strong&gt;真&lt;/strong&gt;. &lt;code&gt;pan_tilt_node&lt;/code&gt; 可以保证传给 Arduino 的舵机方向是正确的，这点不用担心.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cfg&lt;/code&gt; 文件夹下的 &lt;code&gt;pan_tilt.cfg&lt;/code&gt; 文件用于动态配置服务器，这样可以随时对舵机进行&lt;strong&gt;微调&lt;/strong&gt;（trim）. 这个文件实际上是 Python 脚本：&lt;/p&gt;
&lt;pre class=&quot;py&quot;&gt;
&lt;code&gt;#!/usr/bin/env python
PACKAGE = &quot;pan_tilt&quot;

from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

gen.add(&quot;index0_pan_trim&quot;,  int_t, 0, &quot;Index 0 - Pan Trim&quot;,  0,  -45, 45)
gen.add(&quot;index0_tilt_trim&quot;, int_t, 0, &quot;Index 0 - Tilt Trim&quot;, 0,  -45, 45)
gen.add(&quot;index1_pan_trim&quot;,  int_t, 0, &quot;Index 1 - Pan Trim&quot;,  0,  -45, 45)
gen.add(&quot;index1_tilt_trim&quot;, int_t, 0, &quot;Index 1 - Tilt Trim&quot;, 0,  -45, 45)

exit(gen.generate(PACKAGE, &quot;pan_tilt_node&quot;, &quot;PanTilt&quot;))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于动态配置服务器详细内容，可以看&lt;a href=&quot;http://wiki.ros.org/dynamic_reconfigure&quot;&gt;这篇文章&lt;/a&gt;. 在这里，我添加了 4 个参数，用来分别配置 4 个舵机，默认值都是 0，转动范围 -45&lt;span class=&quot;math inline&quot;&gt;\(^\circ\)&lt;/span&gt; 到 45&lt;span class=&quot;math inline&quot;&gt;\(^\circ\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;launch&lt;/code&gt; 文件夹包含了全部启动文件. 其中的 &lt;code&gt;pan_tilt_test.launch&lt;/code&gt; 是测试专用的. 它实际上是个 XML 文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; ?&amp;gt;
&amp;lt;launch&amp;gt;
  &amp;lt;rosparam command=&quot;load&quot; file=&quot;$(find pan_tilt)/config/config.yaml&quot; /&amp;gt;
  &amp;lt;node pkg=&quot;pan_tilt&quot; type=&quot;pan_tilt_node&quot; name=&quot;pan_tilt_node&quot; output=&quot;screen&quot; /&amp;gt;
  &amp;lt;node pkg=&quot;rosserial_python&quot; type=&quot;serial_node.py&quot; name=&quot;serial_node&quot; output=&quot;screen&quot; args=&quot;/dev/ttyUSB0&quot; /&amp;gt;
&amp;lt;/launch&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于启动文件的详细信息，可以看&lt;a href=&quot;http://wiki.ros.org/roslaunch/XML&quot;&gt;这篇文章&lt;/a&gt;. 在启动文件里，首先用 &lt;code&gt;load&lt;/code&gt; 命令加载了配置文件：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;rosparam command=&quot;load&quot; file=&quot;$(find pan_tilt)/config/config.yaml&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来执行了 &lt;code&gt;pan_tilt&lt;/code&gt; 功能包的 &lt;code&gt;pan_tilt_node&lt;/code&gt; 节点，通过指定输出为 &lt;code&gt;screen&lt;/code&gt;，让信息直接显示到运行程序的终端上.&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;node pkg=&quot;pan_tilt&quot; type=&quot;pan_tilt_node&quot; name=&quot;pan_tilt_node&quot; output=&quot;screen&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后运行 &lt;code&gt;roserial&lt;/code&gt; 和 Arduino 进行通信. 我用的 Arduino Nano 是通过 USB 连接到 PC 的，所以指定设备名 &lt;code&gt;/dev/ttyUSB0&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;node pkg=&quot;rosserial_python&quot; type=&quot;serial_node.py&quot; name=&quot;serial_node&quot; output=&quot;screen&quot; args=&quot;/dev/ttyUSB0&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;剩下的 &lt;code&gt;include&lt;/code&gt; 和 &lt;code&gt;src&lt;/code&gt; 文件夹里是功能包的 C++ 源码. &lt;code&gt;pan_tilt_node.cpp&lt;/code&gt; 文件包含了 &lt;code&gt;PanTiltNode&lt;/code&gt; 类的定义和程序的主函数.&lt;/p&gt;
&lt;p&gt;主函数用 &lt;code&gt;pan_tilt_node&lt;/code&gt; 初始化 ROS，生成节点实例，同时将回调函数绑定到动态配置服务器.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int main(int argc, char **argv)
{
    ros::init(argc, argv, &quot;pan_tilt_node&quot;);    
    
    PanTiltNode *pan_tiltnode = new PanTiltNode();
    
    dynamic_reconfigure::Server&amp;lt;pan_tilt::PanTiltConfig&amp;gt; server;
    dynamic_reconfigure::Server&amp;lt;pan_tilt::PanTiltConfig&amp;gt;::CallbackType f;
      
    f = boost::bind(&amp;amp;PanTiltNode::reconfCallback, pan_tiltnode, _1, _2);
    server.setCallback(f);
        
    std::string node_name = ros::this_node::getName();
    ROS_INFO(&quot;%s started&quot;, node_name.c_str());
    ros::spin();
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;PanTiltNode&lt;/code&gt; 类在构造函数里加载参数服务器的参数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 构造函数 
PanTiltNode::PanTiltNode()
{
    double max_radians;
    double min_radians;
    int temp;

    /* 从参数服务器获取参数，如果获取失败，则使用默认值 */

    // 指定舵机功能
    n_.param(&quot;/servo/index0/pan/servo&quot;,  pan_servo_[0],  0);
    n_.param(&quot;/servo/index0/tilt/servo&quot;, tilt_servo_[0], 1);
    n_.param(&quot;/servo/index1/pan/servo&quot;,  pan_servo_[1],  2);
    n_.param(&quot;/servo/index1/tilt/servo&quot;, tilt_servo_[1], 3);

    // 检查舵机安装方式是否符合右手定则
    n_.param(&quot;/servo/index0/pan/flip_rotation&quot;, pan_flip_rotation_[0], false);
    n_.param(&quot;/servo/index0/tilt/flip_rotation&quot;, tilt_flip_rotation_[0], false);
    n_.param(&quot;/servo/index1/pan/flip_rotation&quot;, pan_flip_rotation_[1], false);
    n_.param(&quot;/servo/index1/tilt/flip_rotation&quot;, tilt_flip_rotation_[1], false);

    /* 取值范围. 为了满足右手定则，这些值可能需要进行翻转. */
    n_.param(&quot;/servo/index0/pan/max&quot;, max_radians, M_PI/2.0);
    n_.param(&quot;/servo/index0/pan/min&quot;, min_radians, -(M_PI/2.0));
    pan_max_[0] = (int)signedRadianToServoDegrees(max_radians, pan_flip_rotation_[0]);
    pan_min_[0] = (int)signedRadianToServoDegrees(min_radians, pan_flip_rotation_[0]);
    if(true == pan_flip_rotation_[0])
    {
        temp = pan_max_[0];
        pan_max_[0] = pan_min_[0];
        pan_min_[0] = temp;
    }

    n_.param(&quot;/servo/index0/tilt/max&quot;, max_radians, M_PI/2.0);
    n_.param(&quot;/servo/index0/tilt/min&quot;, min_radians, -(M_PI/2.0));
    tilt_max_[0] = (int)signedRadianToServoDegrees(max_radians, tilt_flip_rotation_[0]);
    tilt_min_[0] = (int)signedRadianToServoDegrees(min_radians, tilt_flip_rotation_[0]);
    if(true == tilt_flip_rotation_[0])
    {
        temp = tilt_max_[0];
        tilt_max_[0] = tilt_min_[0];
        tilt_min_[0] = temp;
    }

    n_.param(&quot;/servo/index1/pan/max&quot;, max_radians, M_PI/2.0);
    n_.param(&quot;/servo/index1/pan/min&quot;, min_radians, -(M_PI/2.0));
    pan_max_[1] = (int)signedRadianToServoDegrees(max_radians, pan_flip_rotation_[1]);  
    pan_min_[1] = (int)signedRadianToServoDegrees(min_radians, pan_flip_rotation_[1]);
    if(true == pan_flip_rotation_[1])
    {
        temp = pan_max_[1];
        pan_max_[1] = pan_min_[1];
        pan_min_[1] = temp;
    }

    n_.param(&quot;/servo/index1/tilt/max&quot;, max_radians, M_PI/2.0);
    n_.param(&quot;/servo/index1/tilt/min&quot;, min_radians, -(M_PI/2.0));
    tilt_max_[1] = (int)signedRadianToServoDegrees(max_radians, tilt_flip_rotation_[1]);
    tilt_min_[1] = (int)signedRadianToServoDegrees(min_radians, tilt_flip_rotation_[1]);
    if(true == tilt_flip_rotation_[1])
    {
        temp = tilt_max_[1];
        tilt_max_[1] = tilt_min_[1];
        tilt_min_[1] = temp;
    }

    // 关节名
    n_.param&amp;lt;std::string&amp;gt;(&quot;/servo/index0/pan/joint_name&quot;, pan_joint_names_[0], &quot;reserved_pan0&quot;);
    n_.param&amp;lt;std::string&amp;gt;(&quot;/servo/index0/tilt/joint_name&quot;, tilt_joint_names_[0], &quot;reserved_tilt0&quot;);
    n_.param&amp;lt;std::string&amp;gt;(&quot;/servo/index1/pan/joint_name&quot;, pan_joint_names_[1], &quot;reserved_pan1&quot;);
    n_.param&amp;lt;std::string&amp;gt;(&quot;/servo/index1/tilt/joint_name&quot;, tilt_joint_names_[1], &quot;reserved_tilt1&quot;);

    first_index0_msg_received_ = false;
    first_index1_msg_received_ = false;

    // 锁存已发布的节点
    servo_array_pub_ = n_.advertise&amp;lt;servo_msgs::servo_array&amp;gt;(&quot;/servo&quot;, 10, true);

    // 订阅话题
    joint_state_sub_ = n_.subscribe(&quot;/pan_tilt_node/joints&quot;, 10, &amp;amp;PanTiltNode::panTiltCB, this);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用 &lt;code&gt;param&lt;/code&gt; 的时候会从参数服务器读取，如果读取失败，就使用默认值：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;n_.param(&quot;/servo/index0/pan_servo&quot;, pan_servo_[0], 0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构造函数最后两行订阅了话题，指定发布节点的话题. 接收到指定话题时将执行对应的回调函数 &lt;code&gt;panTiltCB&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 移动关节的回调函数
void PanTiltNode::panTiltCB(const sensor_msgs::JointState&amp;amp; joint)
{
    bool index0 = false;
    bool index1 = false;

    /* 在消息的列表里查找关节名. 位置（旋转）值均为正弧度值，符合右手定则，
     * 需要根据舵机方向换算成角度值. 
     */
    for (unsigned int i = 0; i &amp;lt; joint.name.size(); i++)
    {         
        // Is it one of the pan or tilt joints
        if(pan_joint_names_[0] == joint.name[i])
        {
            // Index 0 平移
            index0_pan_ = (int)signedRadianToServoDegrees(joint.position[i], pan_flip_rotation_[0]);
            index0 = true;
        }
        else if(pan_joint_names_[1] == joint.name[i])
        {
            // Index 1 平移
            index1_pan_ = (int)signedRadianToServoDegrees(joint.position[i], pan_flip_rotation_[1]);
            index1 = true;            
        }
        else if(tilt_joint_names_[0] == joint.name[i])
        {
            // Index 0 倾斜
            index0_tilt_ = (int)signedRadianToServoDegrees(joint.position[i], tilt_flip_rotation_[0]);
            index0 = true;                        
        }
        else if (tilt_joint_names_[1] == joint.name[i])
        {
            // Index 1 倾斜
            index1_tilt_ = (int)signedRadianToServoDegrees(joint.position[i], tilt_flip_rotation_[1]);
            index1 = true;
        }
    }

    if(index0 == true)
    {
        first_index0_msg_received_ = true;
        movePanTilt(index0_pan_, index0_tilt_, index0_pan_trim_, index0_tilt_trim_, 0);        
    }

    if(index1 == true)
    {
        first_index1_msg_received_ = true; 
        movePanTilt(index1_pan_, index1_tilt_, index1_pan_trim_, index0_tilt_trim_, 1);
    }       
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;回调函数针对接收消息中的每个名字反复执行，直至找到已知的关节名. 找到名字后，回调函数调用 &lt;code&gt;signedRadianToServoDegrees&lt;/code&gt; 函数按照 ROS 标准和方向对关节名关联的正值进行转化，并把结果送到舵机.&lt;/p&gt;
&lt;p&gt;随后，回调函数调用 &lt;code&gt;movePanTilt&lt;/code&gt; 函数给对应的数值里加上微调偏移，微调舵机，检查范围，然后用舵机的编号和位置发布两条消息，一条发给平移舵机，一条发给倾斜舵机.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void PanTiltNode::movePanTilt(int pan_value, int tilt_value, int pan_trim, int tilt_trim, int index)
{
    int pan;
    int tilt;
    servo_msgs::servo_array servo;

    pan = pan_trim + pan_value;
    tilt = tilt_trim + tilt_value;

    pan = checkMaxMin(pan, pan_max_[index], pan_min_[index]);
    tilt = checkMaxMin(tilt, tilt_max_[index], tilt_min_[index]);

    // 发送平移位置
    servo.index = (unsigned int)pan_servo_[index];
    servo.angle = (unsigned int)pan;
    servo_array_pub_.publish(servo);

    // 发送偏移位置
    servo.index = (unsigned int)tilt_servo_[index];
    servo.angle = (unsigned int)tilt;
    servo_array_pub_.publish(servo);    
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里设计了两个助手函数，第一个用来检查最大／最小值范围.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int PanTiltNode::checkMaxMin(int current_value, int max, int min)
{
    int value = current_value;

    if (value &amp;gt; max)
    {
        value = max;
    }

    if (value &amp;lt; min)
    {
        value = min;
    }

    return (value);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个助手函数用来把 ROS 标准单位和方向换算成适合舵机的数值.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 将正弧度值换算成舵机使用的角度值. 0 弧度相当于 90 度.
double PanTiltNode::signedRadianToServoDegrees(double rad, bool flip_rotation)
{
    double retVal;
    
    if(true == flip_rotation)
    {
        retVal = ((-rad/(2.0*M_PI))*360.0)+90.0;
    }        
    else
    {
        retVal = ((rad/(2.0*M_PI))*360.0)+90.0;
    }

    return retVal;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;动态参数服务器回调保存了微调参数，随后调用两次 &lt;code&gt;movePanTilt&lt;/code&gt;，每个设备一次.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// 这个回调会在动态配置参数变化的时候执行
void PanTiltNode::reconfCallback(pan_tilt::PanTiltConfig &amp;amp;config, uint32_t level)
{
    index0_pan_trim_ = config.index0_pan_trim;
    index0_tilt_trim_ = config.index0_tilt_trim;
    index1_pan_trim_ = config.index1_pan_trim;
    index1_tilt_trim_ = config.index1_tilt_trim;

    // 只有收到位置消息才执行
    if(first_index0_msg_received_ == true)
    {
        // 用新微调值发送新消息
        movePanTilt(index0_pan_, index0_tilt_, index0_pan_trim_, index0_tilt_trim_, 0);        
    }

    if(first_index1_msg_received_ == true)
    {
        movePanTilt(index1_pan_, index1_tilt_, index1_pan_trim_, index1_tilt_trim_, 1);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;pan_tilt_node.h&lt;/code&gt; 文件包含了 &lt;code&gt;PanTiltNode&lt;/code&gt; 类定义.&lt;/p&gt;
&lt;p&gt;完成了平移／倾斜功能包后，现在来编写 Arduino 源码. 这份源码是以 &lt;code&gt;rosserial&lt;/code&gt; 例程作为模板来写的，包含了平移／倾斜节点里用到的各元素，支持多个舵机.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;setup&lt;/code&gt; 函数对节点进行了初始化，订阅了舵机话题. 4 台舵机分别连接到 Arduino 的 PWM 引脚 9、6、 5 和 10. &lt;code&gt;loop&lt;/code&gt; 函数里，调用了 &lt;code&gt;spinOnce&lt;/code&gt;，随后延迟 1 毫秒. &lt;code&gt;spinOnce&lt;/code&gt; 实际上会执行 &lt;code&gt;servo_cb&lt;/code&gt; 回调函数. 这个函数每次收到舵机消息时都会执行.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;/*
 * 基于 rosserial 舵机例程
 * 最多可以控制 4 台舵机
 * 节点订阅舵机话题，并作为 rodney_msgs::servo_array 消息运行.
 * 消息包含两个元素，编号和角度.
 * 编号范围：0-3
 * 角度范围：0-180
 *
 * D5 -&amp;gt; PWM 输出口，舵机 2
 * D6 -&amp;gt; PWM 输出口，舵机 1
 * D9 -&amp;gt; PWM 输出口，舵机 0
 * D10 -&amp;gt; PWM 输出口，舵机 3
 */

#if (ARDUINO &amp;gt;= 100)
 #include &amp;lt;Arduino.h&amp;gt;
#else
 #include &amp;lt;WProgram.h&amp;gt;
#endif

#include &amp;lt;Servo.h&amp;gt; 
#include &amp;lt;ros.h&amp;gt;
#include &amp;lt;servo_msgs/servo_array.h&amp;gt;

/* 定义连接舵机的 PWM 端口 */
#define SERVO_0 9
#define SERVO_1 6
#define SERVO_2 5
#define SERVO_3 10

ros::NodeHandle  nh;

Servo servo0;
Servo servo1;
Servo servo2;
Servo servo3;

void servo_cb( const servo_msgs::servo_array&amp;amp; cmd_msg)
{  
  /* Which servo to drive */
  switch(cmd_msg.index)
  {
    case 0:
      nh.logdebug(&quot;Servo 0 &quot;);
      servo0.write(cmd_msg.angle); //设置舵机 0 角度，范围 0-180
      break;

    case 1:
      nh.logdebug(&quot;Servo 1 &quot;);
      servo1.write(cmd_msg.angle); //设置舵机 1 角度，范围 0-180
      break;

    case 2:
      nh.logdebug(&quot;Servo 2 &quot;);
      servo2.write(cmd_msg.angle); //设置舵机 2 角度，范围 0-180
      break;

    case 3:
      nh.logdebug(&quot;Servo 3 &quot;);
      servo3.write(cmd_msg.angle); //设置舵机 3 角度，范围 0-180
      break;
      
    default:
      nh.logdebug(&quot;No Servo&quot;);
      break;
  }  
}

ros::Subscriber&amp;lt;servo_msgs::servo_array&amp;gt; sub(&quot;servo&quot;, servo_cb);

void setup()
{
  nh.initNode();
  nh.subscribe(sub);
  
  
  servo0.attach(SERVO_0); // 关联舵机输出引脚
  servo1.attach(SERVO_1);
  servo2.attach(SERVO_2);
  servo3.attach(SERVO_3);

  // Defaults
  servo0.write(90);
  servo1.write(120); 
}

void loop(){
  nh.spinOnce();
  delay(1);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;上面的程序编译烧录到 Arduino 板子前，要先编译前面写的 ROS 功能包，并且重新编译用于 Arduino 的 ROS 库. 由于我用的 Linux 版 Arduino IDE，我将在两个平台上进行编译. 我决定在树莓派上运行节点，PC 机上运行测试工具. 当然，现在还没有用到专用的树莓派硬件，所以也可以在 PC 上运行节点. 阅读下面的代码时，要注意区分运行的平台（树莓派或 PC）. 这些代码都存在 &lt;code&gt;rodney_ws&lt;/code&gt;（树莓派）和 &lt;code&gt;test_ws&lt;/code&gt;（PC）文件夹下.&lt;/p&gt;
&lt;h2 id=&quot;在-pc-上编译-ros-功能包&quot;&gt;在 PC 上编译 ROS 功能包&lt;/h2&gt;
&lt;p&gt;ROS 使用的是 catkin 编译环境，首先创建工作区并初始化：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ mkdir -p ~/test_ws/src
$ cd ~/test_ws/
$ catkin_make&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把功能包文件夹 &lt;code&gt;pan_tilt&lt;/code&gt;、&lt;code&gt;servo_msgs&lt;/code&gt; 拷到 &lt;code&gt;~/test_ws/src&lt;/code&gt; 文件夹下并编译：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cd ~/test_ws/ 
$ catkin_make&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果以上步骤没有出错，那么编译即告成功.&lt;/p&gt;
&lt;h2 id=&quot;编译-arduino-ros-库&quot;&gt;编译 Arduino ROS 库&lt;/h2&gt;
&lt;p&gt;编译 &lt;code&gt;ros_lib&lt;/code&gt; 库的命令行如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ source ~/test_ws/devel/setup.bash
$ cd ~/Arduino/libraries
$ rm -rf ros_lib
$ rosrun rosserial_arduino make_libraries.py .&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果编译没有问题，&lt;code&gt;~/Arduino/libraries/ros_lib/servo_msgs&lt;/code&gt; 文件夹下会生成 &lt;code&gt;servo_array.h&lt;/code&gt; 头文件.&lt;/p&gt;
&lt;h2 id=&quot;编译并烧录-arduino&quot;&gt;编译并烧录 Arduino&lt;/h2&gt;
&lt;p&gt;把 &lt;code&gt;rodney_control&lt;/code&gt; 文件夹复制到 &lt;code&gt;~/Arduino/Projects&lt;/code&gt; 下. 运行 Arduino IDE，打开 &lt;code&gt;rodney_control.ino&lt;/code&gt; 文件. 在&lt;q&gt;工具→开发板&lt;/q&gt;菜单里选择 Arduino 开发板型号（我这里用的是 Arduino Nano）. 在&lt;q&gt;工具→处理器&lt;/q&gt;菜单里选择处理器型号（ATmega328）.&lt;/p&gt;
&lt;p&gt;用 USB 线把 Arduino Nano 连接到 PC 上，在&lt;q&gt;工具→端口&lt;/q&gt;菜单里选择对应的端口（&lt;code&gt;/dev/ttyUSB0&lt;/code&gt;）.&lt;/p&gt;
&lt;p&gt;点击&lt;q&gt;上传&lt;/q&gt;按钮，如果一切正常，源代码将编译并烧录到 Arduino 里.&lt;/p&gt;
&lt;h2 id=&quot;arduino-电路&quot;&gt;Arduino 电路&lt;/h2&gt;
&lt;p&gt;制作罗德尼的时候，供电问题必须要考虑到. 在我的设计里，Arduino 从树莓派的 USB 口取电，舵机则用 4 节 5 号（AA）可充电电池供电. 图 3 是供电电路的示意图.&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117184443987-1100820849.jpg&quot;/&gt;&lt;p&gt;图 3 罗德尼供电电路图&lt;/p&gt;
&lt;p&gt;为了测试，我在面包板上搭建了上图的电路，并且只接了头部平移／倾斜设备.&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117184501863-1504386229.jpg&quot;/&gt;&lt;p&gt;图 4 罗德尼供电测试电路&lt;/p&gt;
&lt;h3 id=&quot;在树莓派上编译-ros-功能包&quot;&gt;在树莓派上编译 ROS 功能包&lt;/h3&gt;
&lt;p&gt;还是用类似的命令，创建 catkin 工作区并初始化：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ mkdir -p ~/rodney_ws/src
$ cd ~/rodney_ws/
$ catkin_make&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把 &lt;code&gt;pan_tilt&lt;/code&gt; 和 &lt;code&gt;servo_msgs&lt;/code&gt; 文件夹复制到 &lt;code&gt;~/rodney_ws/src&lt;/code&gt; 然后编译：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cd ~/rodney_ws/ 
$ catkin_make&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果无错，则编译完成.&lt;/p&gt;
&lt;div class=&quot;info note&quot; readability=&quot;19&quot;&gt;
&lt;h4&gt;小提示&lt;/h4&gt;
&lt;p&gt;在 PC 和树莓派上运行 ROS 代码和工具时，可能需要在多个命令行终端上执行同样的命令. 下一节我还是会写完整的命令，不过我可以使用我写的 &lt;code&gt;.bash&lt;/code&gt; 文件简化命令输入. 首先编辑 &lt;code&gt;.bashrc&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
$ cd ~/
$ nano .bashrc
&lt;/pre&gt;
在文件最后添加 &lt;code&gt;source /home/ubuntu/rodney_ws/devel/setup.bash&lt;/code&gt;，保存退出. PC 在运行测试代码时需要知道 ROS 主机位置（端口），所以 PC 的 &lt;code&gt;.bashrc&lt;/code&gt; 里我添加了下面的语句：
&lt;pre&gt;
alias rodney='source ~/test_ws/devel/setup.bash; \
export ROS_MASTER_URI=http://ubiquityrobot:11311'
&lt;/pre&gt;
一个 &lt;code&gt;rodney&lt;/code&gt; 就可以一次运行上面两个命令，再不用敲命令敲到手软啦.&lt;/div&gt;
&lt;h3 id=&quot;运行代码&quot;&gt;运行代码&lt;/h3&gt;
&lt;p&gt;一切准备就绪，随时可以运行代码了. 用 USB 线把 Arduino 连到树莓派，用启动文件打开节点：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cd ~/rodney_ws/
$ source devel/setup.bash
$ roslaunch pan_tilt pan_tilt_test.launch&lt;/code&gt;
&lt;/pre&gt;
&lt;div class=&quot;info important&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;如果主机节点没有运行，那么启动命令会同时启动主机节点 &lt;code&gt;roscore&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;终端上会显示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;参数服务器的参数列表&lt;/li&gt;
&lt;li&gt;节点列表，包括了 &lt;code&gt;pan_tilt_node&lt;/code&gt; 和 &lt;code&gt;serial_node&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;主机地址&lt;/li&gt;
&lt;li&gt;上面两个节点的启动过程&lt;/li&gt;
&lt;li&gt;代码里的日志信息&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这时就可以用 ROS 的工具来检查、测试系统了. 新开一个命令行终端（PC），输入命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cd ~/test_ws
$ source devel/setup.bash&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果节点是在同一设备上运行的，而工具程序在另一台设备上运行，那么需要指定主机的地址：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ export ROS_MASTER_URI=http://ubiquityrobot:11311&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在可以运行图形工具了：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ rqt_graph&lt;/code&gt;
&lt;/pre&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117232202070-925371340.jpg&quot;/&gt;&lt;p&gt;图 5 ROS 图形工具&lt;/p&gt;
&lt;p&gt;用这个工具可以看到节点的运行情况以及和 &lt;code&gt;/servo&lt;/code&gt; 话题的连接情况. 图中可以看到 &lt;code&gt;/pan_tilt_node/joints&lt;/code&gt; 话题.&lt;br/&gt;现在在 PC 上打开一个终端，用 &lt;code&gt;rostopic&lt;/code&gt; 发送一条消息移动设备：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cd ~/test_ws
$ source devel/setup.bash
$ export ROS_MASTER_URI=http://ubiquityrobot:11311
$ rostopic pub -1 /pan_tilt_node/joints sensor_msgs/JointState '{header: {seq: 0, stamp: {secs: 0, nsecs: 0},
frame_id: &quot;&quot;}, name: [ &quot;head_pan&quot;,&quot;tilt_pan&quot;], position: [0,0.349066], velocity: [], effort: []}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后一行命令会在 &lt;code&gt;rostopic&lt;/code&gt; 里发布一个 &lt;code&gt;/pan_tilt_node/joints&lt;/code&gt; 话题的实例，使用 &lt;code&gt;sensor_msgs/JointState&lt;/code&gt; 消息类型，平移位置 0，倾斜位置 0.349066，舵机会执行相应动作.&lt;/p&gt;
&lt;div class=&quot;info&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;本文里舵机收到命令后直接移动到位. 下一篇文章里，我将添加一些代码，让舵机移动得更&lt;em&gt;优雅&lt;/em&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;用 &lt;code&gt;rostopic&lt;/code&gt; 命令要输入的东西有点多，也可以用 rqt GUI：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ rosrun rqt_gui rqt_gui&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个命令会运行一个图形界面，可以选择消息发布者，发布消息和内容.&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117232140298-958365211.jpg&quot;/&gt;&lt;p&gt;图 6 rpt 图形界面&lt;/p&gt;
&lt;p&gt;在装配各零件的时候，很可能有一定的机械误差，所以平移／倾斜会偏离中点一定角度，这时候可以对它进行微调，把两个舵机设置到中心位置：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ rostopic pub -1 /pan_tilt_node/joints sensor_msgs/JointState '{header: {seq: 0, stamp: {secs: 0, nsecs: 0}, frame_id: &quot;&quot;}, name: [ &quot;head_pan&quot;,&quot;tilt_pan&quot;], position: [0,0], velocity: [], effort: []}'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在新终端里，运行 &lt;code&gt;rqt_reconfigure&lt;/code&gt; 命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;$ cd ~/test_ws 
$ source devel/setup.bash 
$ export ROS_MASTER_URI=http://ubiquityrobot:11311 
$ rosrun rqt_reconfigure rqt_reconfigure&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个命令会打开类似下面的窗口，微调参数可以通过这个界面调整：&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117232612744-1764116095.jpg&quot;/&gt;&lt;p&gt;图 7 微调参数设置界面&lt;/p&gt;
&lt;p&gt;调整到满意之后，就可以用得到的值更新 &lt;code&gt;pan_tilt.cfg&lt;/code&gt; 配置文件里的默认值了，这样下次节点会使用这些校正过的值启动.&lt;/p&gt;
&lt;p&gt;要关闭节点，在终端里按 &lt;kbd&gt;Ctrl-C&lt;/kbd&gt;.&lt;/p&gt;
&lt;h2 id=&quot;平移倾斜设备&quot;&gt;平移／倾斜设备&lt;/h2&gt;
&lt;p&gt;平移／倾斜设备使用的日本双叶舵机，一个型号是 S3003，另一个是 S3305. S3305 自带金属固定组件，如图 8 所示.&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117233301793-1893018852.jpg&quot; width=&quot;480px&quot;/&gt;&lt;p&gt;图 8 舵机和固定组件&lt;/p&gt;
&lt;p&gt;当然我用的是 3D 打印的零件. 考虑到显示器和树莓派的重量对舵机轴向压力，我用了一个载荷组件来减轻这个问题. 这个组件相当于舵机的外骨骼，可以增强舵机承载的机械强度. 也可以通过把屏幕固定，只移动摄像头的方式代替现在的方案，不过这样看起来就不像一个机器&lt;em&gt;人&lt;/em&gt;了. 图 9 展示了我设计的装配件效果.&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117234512096-1940285501.jpg&quot; width=&quot;480px&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117234550200-146725468.jpg&quot; width=&quot;480px&quot;/&gt;&lt;p&gt;图 9 自制装配件&lt;/p&gt;
&lt;h2 id=&quot;兴趣点&quot;&gt;兴趣点&lt;/h2&gt;
&lt;p&gt;这篇文章里，我实现了用树莓派运行字节编写的 ROS 节点，用 Arduino 控制舵机. 下一篇文章，我将继续研究设计目标 1，添加一个封装在 ROS 节点中的 Python 人脸识别库，然后添加一个节点来控制罗德尼脑袋的移动.&lt;/p&gt;
&lt;p&gt;如果说现在罗德尼还只是一副躯壳，那么它即将拥有灵魂！&lt;/p&gt;
&lt;img src=&quot;https://img2018.cnblogs.com/blog/407692/201901/407692-20190117234731352-480332218.jpg&quot; width=&quot;480px&quot;/&gt;&lt;p&gt;图 10 罗德尼认出我了！&lt;/p&gt;
&lt;h2 id=&quot;历史&quot;&gt;历史&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;首次发表：2018/07/28&lt;/li&gt;
&lt;li&gt;第二版：2018/07/31 修正了 &lt;code&gt;package.xml&lt;/code&gt; 的错误&lt;/li&gt;
&lt;li&gt;第三版：2019/01/09 改用 &lt;code&gt;sensor_msgs/JointState&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文以及任何相关的源代码和文件都是根据 &lt;a href=&quot;http://www.opensource.org/licenses/gpl-3.0.html&quot;&gt;GNU通用公共许可证（GPLv3）&lt;/a&gt;授权的.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://www.codeproject.com/script/Membership/ProfileImages/%7Bbbdc6a2e-fd87-4187-8fcb-27d1201834e8%7D.JPG&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Phil Hopley，来自英国🇬🇧，高级软件工程师，已退休，爱好徒步和划船，闲暇时会做点软硬件小玩意儿.&lt;/p&gt;
&lt;section class=&quot;footnotes&quot;&gt;&lt;hr/&gt;&lt;ol readability=&quot;0.95488721804511&quot;&gt;&lt;li id=&quot;fn1&quot; readability=&quot;-0.95&quot;&gt;
&lt;p&gt;Heiserman 也是《Apple II C语言编程》一书作者.&lt;a href=&quot;http://www.cnblogs.com/conmajia/p/rodney-robot-part-1.html#fnref1&quot; class=&quot;footnote-back&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn2&quot; readability=&quot;-0.92682926829268&quot;&gt;
&lt;p&gt;Loofbourrow 是 ViralGains 公司 CEO.&lt;a href=&quot;http://www.cnblogs.com/conmajia/p/rodney-robot-part-1.html#fnref2&quot; class=&quot;footnote-back&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn3&quot; readability=&quot;-0.96296296296296&quot;&gt;
&lt;p&gt;本文获得了 CodeProject 2016 年 7 月号 &lt;em lang=&quot;cmn-latn&quot;&gt;Everything Else&lt;/em&gt; 奖状第 2 名.&lt;a href=&quot;http://www.cnblogs.com/conmajia/p/rodney-robot-part-1.html#fnref3&quot; class=&quot;footnote-back&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&quot;fn4&quot; readability=&quot;-0.96296296296296&quot;&gt;
&lt;p&gt;本文获得了 CodeProject 2018 年 3 月号 &lt;em lang=&quot;cmn-latn&quot;&gt;Everything Else&lt;/em&gt; 奖状第 2 名.&lt;a href=&quot;http://www.cnblogs.com/conmajia/p/rodney-robot-part-1.html#fnref4&quot; class=&quot;footnote-back&quot;&gt;↩&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/section&gt;</description>
<pubDate>Thu, 17 Jan 2019 15:55:00 +0000</pubDate>
<dc:creator>I.am.Conmajia</dc:creator>
<og:description>一个名叫罗德尼（Rodney）的机器人. 这是第一部分.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/conmajia/p/rodney-robot-part-1.html</dc:identifier>
</item>
<item>
<title>auto类型推导 - 倔强的铃铛</title>
<link>http://www.cnblogs.com/0xfffffff0/p/10285472.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/0xfffffff0/p/10285472.html</guid>
<description>&lt;h3 id=&quot;引言&quot;&gt;引言&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;auto : 类型推导.&lt;/strong&gt; 在使用c++的时候会经常使用, 就像在考虑STL时迭代器类型, 写模板的时候使用auto能少写代码, 也能帮助我们避免一些隐患的细节.&lt;/p&gt;
&lt;h3 id=&quot;auto初始化&quot;&gt;auto初始化&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;使用&lt;code&gt;auto&lt;/code&gt;型别推导要求&lt;strong&gt;必须在定义时初始化&lt;/strong&gt;, 毕竟需要根据对象的类型推导左值对象的型别.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto j;     // error. 必须初始化
auto i = 0; // i 推导型别为 int
vector&amp;lt;int&amp;gt; v; 
auto vv = v.cbegin();   // vv  推导型别为 const int*&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;但是&lt;code&gt;auto&lt;/code&gt;型别推导会&lt;strong&gt;忽略引用和顶层const&lt;/strong&gt;, 所以要对对象加上想要的修饰.&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;const int ci = 0;
auto i = ci;    // i 推导型别为 int, 忽略了顶层const
int &amp;amp;ri = i;
auto ii = ri;   //ii 推导型别为 int, 忽略了引用&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;C11之前只能通过&lt;code&gt;()&lt;/code&gt;和&lt;code&gt;=&lt;/code&gt;对变量初始化, C++11增加了对定义的对象初始化的方法，可以使用&lt;code&gt;{}&lt;/code&gt;对变量初始化&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;em&gt;c11之前的初始化方法&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int i(0);   // i 初始化 0
int j = 0;  // j 初始化 0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;c11后的初始化方法&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto i(0); auto j = i;  // 支持c11前
auto ii{0}; // 使用 {} 进行初始化, 但是auto推导只能接受一个参数
auto jj = { 0 };    // jj 的推导型别为 initializer_list&amp;lt;int&amp;gt;型别&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面jj的推导居然不是int型别, 而是 &lt;code&gt;initializer_list&amp;lt;int&amp;gt;&lt;/code&gt;, 这不能怪auto推导出问题, 这主要是后者的对象初始化就是使用&lt;code&gt;={}&lt;/code&gt;, 可以说是auto推导的是最精确的型别. 不管新添的初始化方法, 找一个习惯的就行了.&lt;/p&gt;
&lt;h3 id=&quot;auto与for&quot;&gt;auto与for&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;最常见的就是与&lt;code&gt;for&lt;/code&gt;联用, 特别是类型特别复杂的时候. 但是auto又有多种选择, 如 : auto, auto &amp;amp;等, 不同的选择其效率也不一样.&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;strong&gt;&lt;code&gt;auto&lt;/code&gt;, 即 for(auto i:range)&lt;/strong&gt; . 这使range中的每一个元素都会产生一个副本, 所以即使修改了 i 也不会实际影响到range.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;const auto&lt;/code&gt;, 及for(const auto i : range)&lt;/strong&gt;. 这也会是range的每一个元素产生一个副本, 但是这个副本竟不能被修改.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;auto &amp;amp;&lt;/code&gt;, 即for(auto &amp;amp;i : range)&lt;/strong&gt;. 引用, 因为i 直接引用range里面的元素, 所以并不会产生一个副本, 但是 i 的修改也会影响range里元素的值. &lt;strong&gt;通常我们需要修改range是会考虑用到.&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;const auto&amp;amp;&lt;/code&gt;, 即for(const auto &amp;amp;&amp;amp;i : range)&lt;/strong&gt;. i 直接引用range里面的元素, 所以并不会产生一个副本, 并且i 也不能修改. &lt;strong&gt;一般初始化的是一个左值时而且是读取range里的元素时都是用&lt;code&gt;const auto&amp;amp;&lt;/code&gt;而不用&lt;code&gt;auto&lt;/code&gt;, 因为前者不会产生副本, 效率要高&lt;/strong&gt;. &lt;em&gt;当然一般初始化的是一个左值时效率低, 但是如果是右值还是使用&lt;code&gt;const auto&lt;/code&gt;效率高, 因为&lt;code&gt;const auto &amp;amp;&lt;/code&gt;需要把 i 存储在内存中的一个位置，间接访问会更消耗时间&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;, 即for(auto &amp;amp;&amp;amp;i : range)&lt;/strong&gt;. 如果初始化是左值, 那么 i 就是左值引用, 如果初始化是右值, 那么 i 就是右值引用,&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;还有&lt;code&gt;const auto &amp;amp;&lt;/code&gt;, 当然具体的选择还是看具体的情况而定.&lt;/p&gt;
&lt;p&gt;最后, 当用&lt;code&gt;auto&lt;/code&gt;推导多维数组的时, 保证除最内层循环外, 其他的外层循环都应该是引用类型, 否则很容易出错, 即 :&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int a[10][10][10];
for (const auto &amp;amp;i : a)
    for(const auto &amp;amp;j : i)
        for(const auto k : j)
            ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;最好使用auto型别推导&quot;&gt;最好使用auto型别推导&lt;/h3&gt;
&lt;h4 id=&quot;初始化&quot;&gt;1. 初始化&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;在定义对象的时候可能或多或少会忘记对变量进行初始化, 但当我们使用该变量的时候就会出错, 而且问题也不好找出来, 但是使用&lt;strong&gt;auto定义对象就要求必须初始化&lt;/strong&gt;有时还能减少代码量, 上面我们已经分析过了.&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;auto&lt;/code&gt;初始化在平台上还有一点好处, 比如 :&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;vector&amp;lt;int&amp;gt; v;
unsigned size = v.size();   // size()返回size_t型别
auto sizet = v.size();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 在32的平台&lt;code&gt;unsigned&lt;/code&gt;代表的是32位, &lt;code&gt;size_t&lt;/code&gt;是32位, 在64的平台&lt;code&gt;unsigned&lt;/code&gt;代表的也是23位, 但是&lt;code&gt;size_t&lt;/code&gt;却是64位, 这样平台差异可能就会带来问题, 使用&lt;code&gt;auto&lt;/code&gt;代替就没有这样的问题.&lt;/p&gt;
&lt;p&gt;不过只有这几点可能不会让人心动, 下面我们还有auto的好处.&lt;/p&gt;
&lt;h4 id=&quot;stl使用型别推导&quot;&gt;2. STL使用型别推导&lt;/h4&gt;
&lt;p&gt;还记得在前言中个说过调用STL最好使用&lt;code&gt;auto&lt;/code&gt;推导型别, 如果你还记得&lt;code&gt;map&lt;/code&gt;与&lt;code&gt;pair&lt;/code&gt; 吗? 是这样 &lt;code&gt;map&amp;lt;pair&amp;lt;key, type&amp;gt;&amp;gt;&lt;/code&gt;? 还是&lt;code&gt;map&amp;lt;pair&amp;lt;const key, type&amp;gt;&amp;gt;&lt;/code&gt;? 答案是最后一种, 那么现在我们就来分析的使用&lt;code&gt;auto&lt;/code&gt;推导还是显示型别比较好.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int main()
{
    std::map&amp;lt;string, std::function&amp;lt;type(type, type)&amp;gt;&amp;gt;func = {
        { &quot;+&quot;, [](auto i, auto j)-&amp;gt;auto {return i + j; } },
        { &quot;-&quot;, [](auto i, auto j)-&amp;gt;auto {return i - j; } },
        { &quot;*&quot;, [](auto i, auto j)-&amp;gt;auto {return i * j; } },
        { &quot;/&quot;, [](auto i, auto j)-&amp;gt;auto {return i / j; } }
    };

    for (const auto &amp;amp;i : func) ;

    for(const std::pair&amp;lt;string, std::function&amp;lt;type(type, type)&amp;gt;&amp;gt; &amp;amp;pa : func) ;

    system(&quot;pause&quot;);
    exit(EXIT_SUCCESS);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到上面的例子毫无问题, 但是深究起来显示型别还是些不完美. 我们知道map的&lt;code&gt;key&lt;/code&gt;不能被改变, 所以显示型别的&lt;code&gt;string&lt;/code&gt;与map的&lt;code&gt;const string&lt;/code&gt;不是匹配, 编译器就会将map对象都会产生一个临时对象再隐式的转为&lt;code&gt;string&lt;/code&gt;, 等等. 是不是注意到有一点了, 为了型别匹配赋值会产生临时变量, 那岂不是每一循环都会产生一个临时变量, 但是&lt;code&gt;auto&lt;/code&gt;型别推导就是精确匹配的, 不会产生临时变量.&lt;/p&gt;
&lt;p&gt;可能觉得将显示型别的key改为&lt;code&gt;const string&lt;/code&gt;就能解决这个问题了, 确实是这样, 但是如果没有注意到这一点细节, 那就会损失效率了, 使用auto可以完全不想这些问题啊.&lt;/p&gt;
&lt;p&gt;当然使用显示型别还是型推导看实际也看个人, 不是必要.&lt;/p&gt;
&lt;h3 id=&quot;auto与函数返回类型&quot;&gt;auto与函数返回类型&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;不能被声明为返回值，&lt;code&gt;auto&lt;/code&gt;不能作为形参，&lt;code&gt;auto&lt;/code&gt;不能被修饰为模板参数. 那么这里&lt;code&gt;auto&lt;/code&gt;还能怎么和函数关联起来? 能.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;auto放在函数名前面告诉编译器，真正的返回值在函数声明之后. 简单说auto可以作为返回值占位符来使返回值后置.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就像这样来写.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto Return(std::size_t N) -&amp;gt; std::size_t
{
    return N;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然c++规定可以这样写肯定有其意义. 其实这个写法主要用于&lt;code&gt;template&lt;/code&gt;中, 当返回值的类型是一个模板类型时使用, 而返回值类型通过&lt;code&gt;decltype&lt;/code&gt;来推导.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这里就解释一下&lt;code&gt;decltype&lt;/code&gt;的简单运用. , &lt;code&gt;decltype&lt;/code&gt;也是类似与&lt;code&gt;auto&lt;/code&gt;的关键字, 都能够进行参数类型推导, 但是&lt;code&gt;decltype&lt;/code&gt;必须要接受一个参数, 如下:&lt;/em&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int i = 1;
decltype(i) j = 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt;与模板函数连用时用模板参数作为返回值. &lt;span&gt;因为编译器并不能直接推断出返回值为类型参数的实际类型, 所以在STL中采用&lt;code&gt;traits&lt;/code&gt;编程解决这个问题, 这里时另一种实现方法.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;首先看一个错误的例子:&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;class T1, class T2, class T3&amp;gt;
    T3 fun(T1 t1, T2 t2) {...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;T3的类型要在函数返回的时候才能知道, 而&lt;strong&gt;函数这样写就必须要编译期间就要知道返回值类型.&lt;/strong&gt; 所以编译器会报错.&lt;/p&gt;
&lt;p&gt;以下这样写就是正确的, 但是必须保证编译器能推导出类型.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;class T1, class T2, class T3&amp;gt;
    T1 fun(T1 t1, T3 t3) {...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用auto将返回值类型放在最后, 就是告诉编译器&lt;span&gt;真正的返回值在编译后动态获取, 而auto在这里的作用也称为&lt;strong&gt;返回值占位&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;class T1, class T2&amp;gt;
    auto fun(T1 t1, T2, t2) -&amp;gt; decltype(*t1) {...}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上可以将返回类型放在函数尾做尾置是C11中的要求, 但是C14已经可以将&lt;strong&gt;返回型别放推导&lt;/strong&gt;在函数头. 如 :&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;template&amp;lt;class T1&amp;gt;
decltype(auto)fun() {...}   // 这样的写法同上式一样&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然规定能够这样写, 有时为了兼容也还是写成尾置.&lt;/p&gt;
&lt;h3 id=&quot;auto与new运算符&quot;&gt;auto与new运算符&lt;/h3&gt;
&lt;p&gt;我们可以使用&lt;code&gt;auto&lt;/code&gt;来推断出&lt;code&gt;new&lt;/code&gt;对象的类型, 但是局限在于, 必须对&lt;code&gt;new&lt;/code&gt;出来的对象进行单一的初始化.&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto i = new int; // 这中写法根本没有用到auto的推导哦, 因为new的类型已经确定了

auto i = new auto(1);       // 这里就是用到了auto推导
auto size = new auto;       // error, 不能推导出size的类型
auto j = new auto(1,2);     // error, 只能接收一个初始化值&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在&lt;code&gt;const&lt;/code&gt;中我们分析到顶层&lt;code&gt;const&lt;/code&gt;会被忽略, 所以&lt;code&gt;auto&lt;/code&gt;是无法推断出顶层const, 即 :&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;auto i = new const auto(1);     // 这里auto并没有推导出顶层const, 所以i的类型实际上是int
const auto j = new const auto(1);   // 只有显示的定义j的类型是const&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想直接推导出顶层const的话, 最好还是&lt;code&gt;decltype&lt;/code&gt;进行推导.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注意 : &lt;code&gt;auto&lt;/code&gt;推导只能推导出int, double等, 不能推导出short类型&lt;/em&gt;.&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;本节对C11的auto用法做了一个浅显的分析, 分别对使用&lt;code&gt;auto&lt;/code&gt;的好处, 定义时注意&lt;code&gt;{}&lt;/code&gt;对象也必须初始化, &lt;code&gt;auto&lt;/code&gt;在与for连用的时候要根据实际参数确定选择哪种实现, 这样效率才会达到最大, 当然一般都使用&lt;code&gt;const auto&amp;amp;&lt;/code&gt;和&lt;code&gt;auto&amp;amp;&amp;amp;&lt;/code&gt;. 最后还对&lt;code&gt;auto&lt;/code&gt;与函数返回值关联, 可以将返回型别放在函数名尾也可以, 这样的做法一般在模板中将模板参数作为返回值才考虑用, 平时也不必这样定义函数.&lt;/p&gt;
&lt;p&gt;参考 :&lt;/p&gt;
&lt;p&gt;&amp;lt;&amp;lt; Effective Modern C++ &amp;gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/25148592&quot;&gt;auto, auto&amp;amp;, const auto&amp;amp;以及其它形式的auto变种在for-range loop的选择&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Jan 2019 15:27:00 +0000</pubDate>
<dc:creator>倔强的铃铛</dc:creator>
<og:description>引言 auto : 类型推导. 在使用c++的时候会经常使用, 就像在考虑STL时迭代器类型, 写模板的时候使用auto能少写代码, 也能帮助我们避免一些隐患的细节. auto初始化 1. 使用 型别</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/0xfffffff0/p/10285472.html</dc:identifier>
</item>
<item>
<title>AOP 还在配置吗改用打标签模式吧！ - 鱼东东</title>
<link>http://www.cnblogs.com/yudongdong/p/10285392.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yudongdong/p/10285392.html</guid>
<description>&lt;p&gt;&lt;span&gt;为什么我喜欢打标签来配置AOP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;1. 配置多很混乱，代码里面很难分辨出来哪些是AOP容器(比如属性注入)&lt;/p&gt;
&lt;p&gt;2. 对于代码生成器生成的代码里面还需要手动加到配置里面&lt;/p&gt;
&lt;p&gt;3. 连java spring现在都是清一色的注解来代替xml，这个就是趋势所在&lt;/p&gt;

&lt;p&gt;我基于&lt;span&gt;Autofac开发了一个基于标签来配置AOP的扩展&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;NUGET ：&lt;span&gt;Install-Package Autofac.Annotation&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;开源地址：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;帮忙点个star 谢谢！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;特色&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.打个Bean标签就能注入到AOP&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.打个Autowired标签自动装配注入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.打个Value标签自动注入配置值(Soure标签配合使用)具体使用方法看下面的例子&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;4.支持拦截器&lt;/p&gt;
&lt;p&gt;5.更多等你发现&lt;/p&gt;

&lt;p&gt;&lt;span&gt;如何使用&lt;/span&gt;&lt;/p&gt;

&lt;div id=&quot;3200-1547734396925&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; builder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ContainerBuilder();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册autofac打标签模式&lt;/span&gt;
builder.RegisterModule(&lt;span&gt;new&lt;/span&gt; AutofacAnnotationModule(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(AnotationTest).Assembly));
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果需要开启支持循环注入
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;builder.RegisterModule(new AutofacAnnotationModule(typeof(AnotationTest).Assembly).SetAllowCircularDependencies(true));&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; container =&lt;span&gt; builder.Build();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; serviceB = container.Resolve&amp;lt;B&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;AutofacAnnotationModule有两种构造方法&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;可以传一个Assebly列表 （&lt;/span&gt;&lt;span&gt;这种方式会注册传入的Assebly里面打了标签的类&lt;/span&gt;&lt;span&gt;）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;可以传一个AsseblyName列表 (&lt;/span&gt;&lt;span&gt;这种方式是先会根据AsseblyName查找Assebly 然后在注册&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;支持的标签说明&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;Bean标签&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;说明：只能打在class上面 把某个类注册到autofac容器 例如：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.无构造方法的方式 等同于 builder.RegisterType();&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;4414-1547734869050&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把class A 注册到容器&lt;/span&gt;
&lt;span&gt;[Bean]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;2.&lt;span&gt;指定Scope [需要指定AutofacScope属性 如果不指定为则默认为AutofacScope.InstancePerDependency]&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;4620-1547734891937&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 [Bean(AutofacScope =&lt;span&gt; AutofacScope.SingleInstance)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;3.&lt;span&gt;指定类型注册 等同于 builder.RegisterType().As()&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;1886-1547734907404&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;6&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; B
    {

    }
    //将class A6以父类B注册到容器
    [Bean(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(B))]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A6:B
    {

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;4.&lt;span&gt;指定名字注册 等同于 builder.RegisterType().Keyed(&quot;a4&quot;)&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;3843-1547734918304&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    [Bean(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a4&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]//注册A4到容器 并给他起了一个名字叫a4 假设容器有多个A4被注册就可以用这个名字来区别自动装配
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A4
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; School { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;


&lt;p&gt;&lt;span&gt;5.其他属性说明&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;InjectProperties 是否默认装配属性 【默认为true】&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;InjectPropertyType 属性自动装配的类型&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Autowired 【默认值】代表打了Autowired标签的才会自动装配&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;ALL 代表会装配所有 等同于 builder.RegisterType().PropertiesAutowired()&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;AutoActivate 【默认为false】 如果为true代表autofac build完成后会自动创建 具体请参考 &lt;/span&gt;&lt;a href=&quot;https://autofaccn.readthedocs.io/en/latest/configuration/xml.html&quot;&gt;&lt;span&gt;autofac官方文档&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Ownership 【默认为空】 具体请参考 &lt;/span&gt;&lt;a href=&quot;https://autofaccn.readthedocs.io/en/latest/configuration/xml.html&quot;&gt;&lt;span&gt;autofac官方文档&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Interceptor 【默认为空】指定拦截器的Type&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;InterceptorType 拦截器类型 拦截器必须实现 Castle.DynamicProxy的 IInterceptor 接口， 有以下两种&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;Interface 【默认值】代表是接口型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;Class 代表是class类型 这种的话是需要将要拦截的方法标virtual&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;InterceptorKey 如果同一个类型的拦截器有多个 可以指定Key&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;InitMethod 当实例被创建后执行的方法名称 类似Spring的init-method 可以是有参数(只能1个参数类型是IComponentContext)和无参数的方法&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;DestroyMetnod 当实例被Release时执行的方法 类似Spring的destroy-method 必须是无参数的方法&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;

&lt;div id=&quot;7171-1547734956665&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  [Bean(InitMethod = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;start&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,DestroyMetnod = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;destroy&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A30
    {
        [Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaaaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Test { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; A29 a29;

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; start(IComponentContext context)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Test = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;bbbb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            a29 &lt;/span&gt;= context.Resolve&amp;lt;A29&amp;gt;&lt;span&gt;();
        }

        &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy()
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.Test = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            a29.Test &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }
    }
    &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;4510-1547734963222&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;7&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; B
    {

    }
    
    [Bean(&lt;/span&gt;&lt;span&gt;typeof&lt;/span&gt;(B),&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;a5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A5:B
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; School { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; } = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试a5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetSchool()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.School;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Autowired 自动装配&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以打在Field Property 构造方法的Parameter上面 其中Field 和 Property 支持在父类&lt;/span&gt;&lt;/p&gt;

&lt;div id=&quot;4172-1547734982524&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [Bean]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A16
    {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; A16([Autowired]A21 a21)
        {
            Name &lt;/span&gt;=&lt;span&gt; name;
            A21 &lt;/span&gt;=&lt;span&gt; a21;
        }
        
        [Autowired(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;A13&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; B b1;


        [Autowired]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; B B { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Required默认为true 如果装载错误会抛异常出来。如果指定为false则不抛异常&lt;/span&gt;
    [Autowired(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;adadada&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,Required = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; B b1;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Value 和 PropertySource&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;PropertySource类似Spring里面的PropertySource 可以指定数据源 支持 xml json格式 支持内嵌资源&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.json格式的文件&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;9940-1547735011133&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;a10&quot;: &quot;aaaaaaaaa1&quot;&lt;span&gt;,
  &lt;/span&gt;&quot;list&quot;: [ 1, 2, 3&lt;span&gt; ],
  &lt;/span&gt;&quot;dic&quot;&lt;span&gt;: {
    &lt;/span&gt;&quot;name&quot;: &quot;name1&quot;&lt;span&gt;
  },
  &lt;/span&gt;&quot;testInitField&quot;: 1&lt;span&gt;,
  &lt;/span&gt;&quot;testInitProperty&quot;: 1&lt;span&gt;,
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;

&lt;div id=&quot;3089-1547735017950&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;   [Bean]
    [PropertySource(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/file/appsettings1.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A10
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; A10([Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{a10}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]&lt;span&gt;string&lt;/span&gt; school,[Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{list}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; list,[Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{dic}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; dic)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.School =&lt;span&gt; school;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; list;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dic =&lt;span&gt; dic;

        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; School { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; list { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt; dic { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
        
    [Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{testInitField}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; test;
        
    [Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{testInitProperty}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; test2 { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;可以直接指定值&lt;/span&gt;
    [Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; test3 { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;2. xml格式的文件&lt;/span&gt;&lt;/p&gt;
&lt;div id=&quot;9419-1547735044089&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;6.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; &lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;autofac&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;a11&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;aaaaaaaaa1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;a11&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;0&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;1&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;2&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;list &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;2&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;3&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dic &lt;/span&gt;&lt;span&gt;name&lt;/span&gt;&lt;span&gt;=&quot;name&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;name1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dic&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;autofac&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div id=&quot;2749-1547735050033&quot; data-language=&quot;javascript&quot; data-theme=&quot;default&quot; readability=&quot;9.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    [Bean]
    [PropertySource(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/file/appsettings1.xml&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A11
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; A11([Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{a11}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]&lt;span&gt;string&lt;/span&gt; school,[Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{list}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; list,[Value(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#{dic}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)]Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; dic)
        {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.School =&lt;span&gt; school;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.list =&lt;span&gt; list;
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.dic =&lt;span&gt; dic;

        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; School { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; list { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;,&lt;span&gt;string&lt;/span&gt;&amp;gt; dic { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3.&lt;/span&gt;&lt;span&gt;不指定PropertySource的话会默认从工程目录的 appsettings.json获取值&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Jan 2019 14:53:00 +0000</pubDate>
<dc:creator>鱼东东</dc:creator>
<og:description>为什么我喜欢打标签来配置AOP 1. 配置多很混乱，代码里面很难分辨出来哪些是AOP容器(比如属性注入) 2. 对于代码生成器生成的代码里面还需要手动加到配置里面 3. 连java spring现在都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yudongdong/p/10285392.html</dc:identifier>
</item>
<item>
<title>深度解密HTTP通信细节 - Stefno</title>
<link>http://www.cnblogs.com/qcrao-2018/p/10285348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcrao-2018/p/10285348.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;p&gt;上一篇&lt;a href=&quot;https://www.cnblogs.com/qcrao-2018/p/10182185.html&quot;&gt;文章&lt;/a&gt;——《“三次握手，四次挥手”，你真的懂吗》中，我们学会了用wireshark和tcpdump来分析TCP的“三次握手，四次挥手”，非常好用。这哥俩就是传说中的&lt;code&gt;锤子&lt;/code&gt;，拿着&lt;code&gt;锤子&lt;/code&gt;，看什么都像&lt;code&gt;钉子&lt;/code&gt;！在这篇文章中，我们对准了&lt;code&gt;HTTP&lt;/code&gt;这颗钉子砸下去，哈哈。&lt;/p&gt;
&lt;p&gt;为了对网络数据包的“流转”有更加深刻的理解，我在docker（远程）上部署一个服务，支持http方式调用。从客户端（本地）用http方式请求其中的一个接口，并得到响应数据。同时本地通过wireshark抓包，远程用tcpdump抓包，然后分析过程中的所有通信细节。悲剧是把美好的东西撕碎给人看，而我们是把复杂的东西撕碎了给人看。&lt;/p&gt;
&lt;p&gt;文章稍长，请你看本文时保持耐心。我们先通过工具获取HTTP通信的数据包，再来抽丝剥茧，深入二进制的天地里，解密HTTP所有的通信细节。分析过程中，由点到面，将相关知识串接起来。保证全篇读完之后，你对HTTP的理解会上升一个台阶！&lt;/p&gt;

&lt;h2 id=&quot;背景介绍&quot;&gt;背景介绍&lt;/h2&gt;
&lt;p&gt;我手头现有一个地理几何相关的服务，它提供一组接口对外使用。其中有一个接口是&lt;code&gt;Fence2Area&lt;/code&gt;. 使用方传入一个围栏（点的列表组成，点由&amp;lt;经度，纬度&amp;gt;表示）、点的坐标系类型（谷歌地图用的是wgs84, 国内腾讯、高德用的是soso, 而百度用的是另一套自己的坐标系），接口输出的则是围栏的面积。&lt;/p&gt;
&lt;p&gt;我们请求服务的“Fence2Area”接口，输入多边形的围栏(fence)顶点(lng, lat)坐标、坐标系类型(coordtype)，返回多边形的面积(area)。&lt;/p&gt;
&lt;p&gt;一次正常的请求示例url, 这个大家都不陌生:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;http://docker_ip:7080/data?cmd=Fence2Area&amp;amp;meta={&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;}&amp;amp;request={&quot;fence&quot;:[{&quot;lng&quot;:10.2,&quot;lat&quot;:10.2}, {&quot;lng&quot;:10.2,&quot;lat&quot;:8.2}, {&quot;lng&quot;:8.2,&quot;lat&quot;:8.2}, {&quot;lng&quot;:8.2,&quot;lat&quot;:10.2}],&quot;coordtype&quot;:2}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请求发出后，服务器进行处理，之后，客户端收到的返回数据如下：&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
    &quot;data&quot;: {
        &quot;area&quot;: 48764135597.842606
    },
    &quot;errstr&quot;: &quot;&quot;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;area&lt;/code&gt;字段表示面积，而&lt;code&gt;errstr&lt;/code&gt;则是空，即没有出错信息。&lt;/p&gt;
&lt;h2 id=&quot;抓包&quot;&gt;抓包&lt;/h2&gt;
&lt;p&gt;在我们真正发送请求之前，需要进行抓包前的设置。在本地mac，我们用wireshark; 而在远程docker上，我们用tcpdump工具。&lt;/p&gt;
&lt;h3 id=&quot;mac本地&quot;&gt;mac本地&lt;/h3&gt;
&lt;p&gt;设置wireshark包过滤器，监控本地主机和远程docker之间的通信。&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;ip.addr eq docker_ip&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;点击开始捕获。&lt;/p&gt;
&lt;h3 id=&quot;远程docker&quot;&gt;远程docker&lt;/h3&gt;
&lt;p&gt;该服务通过7080对外提供，使用如下命令捕获网络包：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;tcpdump -w /tmp/testHttp.cap port 7080 -s0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;请求-分析&quot;&gt;请求 &amp;amp;&amp;amp; 分析&lt;/h2&gt;
&lt;p&gt;准备工作做完，我挑选了一个神圣的时刻，在本地通过浏览器访问如下url:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;http://docker_ip:7080/data?cmd=Fence2Area&amp;amp;meta={&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;}&amp;amp;request={&quot;fence&quot;:[{&quot;lng&quot;:10.2,&quot;lat&quot;:10.2}, {&quot;lng&quot;:10.2,&quot;lat&quot;:8.2}, {&quot;lng&quot;:8.2,&quot;lat&quot;:8.2}, {&quot;lng&quot;:8.2,&quot;lat&quot;:10.2}],&quot;coordtype&quot;:2}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样本地的wireshark和远程的tcpdump都能抓取到HTTP网络数据包。&lt;/p&gt;
&lt;h3 id=&quot;关闭服务进程&quot;&gt;关闭服务进程&lt;/h3&gt;
&lt;p&gt;首先，关闭gcs服务进程，请求直接返回RST报文。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51288531-97929400-1a37-11e9-8425-c6a2ca6405ad.png&quot; alt=&quot;rst&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，我在请求的时候，改用了另一个接口&lt;code&gt;5010&lt;/code&gt;, 这个接口没有服务监听，和关闭gcs服务进程是同样的效果，可以看到，客户端尝试发送SYN报文，直接被远程docker RST掉了。&lt;/p&gt;
&lt;h3 id=&quot;关闭docker&quot;&gt;关闭docker&lt;/h3&gt;
&lt;p&gt;关闭docker, 由于发送的SYN报文段得不到响应，因此会进行重试，mac下重试的次数为10次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/50555866-08823e00-0d0d-11e9-97cd-f1cdcca2f641.png&quot; alt=&quot;mac retry&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先每隔1秒重试了5次，再用“指数退避”的时间间隔重试，2s, 4s, 8s, 16s, 32s. 最后结束。&lt;/p&gt;
&lt;p&gt;重启docker。并再次在本地访问以上url, 浏览器这时还是用的上一次的端口，但是服务端已经没有这个连接的消息了。因此会返回一个RST报文。&lt;/p&gt;
&lt;h3 id=&quot;正常请求&quot;&gt;正常请求&lt;/h3&gt;
&lt;p&gt;服务正常启动，正常发送请求，这次请求成功，那是当然的，嘿嘿！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/50638281-2e6f4300-0f98-11e9-8d8b-0f3c0cc7eb85.png&quot; alt=&quot;normal_req_wireshark&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是在mac上用wireshark捕获的数据包，共7个包，前三个包为3次握手的包，第四个包为&lt;code&gt;HTTP&lt;/code&gt;层发送的请求数据，第五个包为服务端的TCP 确认报文，第六个包为服务端在&lt;code&gt;HTTP&lt;/code&gt;层发送的响应数据，第七个包为mac对第六个包的确认报文。&lt;/p&gt;
&lt;p&gt;重点来关注第四个包，&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;0x0000:  4500 0295 0000 4000 3606 623b ac17 ccdc
0x0010:  0a60 5cd4 db9b 1ba8 a59a 46ce 6d03 e87d
0x0020:  8018 1015 0ee7 0000 0101 080a 2e4c b2ef
0x0030:  0f20 3acf 4745 5420 2f64 6174 613f 636d
0x0040:  643d 4665 6e63 6532 4172 6561 266d 6574
0x0050:  613d 7b25 3232 6361 6c6c 6572 2532 323a
0x0060:  2532 3274 6573 7425 3232 2c25 3232 5472
0x0070:  6163 6549 6425 3232 3a25 3232 7465 7374
0x0080:  2532 327d 2672 6571 7565 7374 3d7b 2532
0x0090:  3266 656e 6365 2532 323a 5b7b 2532 326c
0x00a0:  6e67 2532 323a 3130 2e32 2c25 3232 6c61
0x00b0:  7425 3232 3a31 302e 327d 2c25 3230 7b25
0x00c0:  3232 6c6e 6725 3232 3a31 302e 322c 2532
0x00d0:  326c 6174 2532 323a 382e 327d 2c25 3230
0x00e0:  7b25 3232 6c6e 6725 3232 3a38 2e32 2c25
0x00f0:  3232 6c61 7425 3232 3a38 2e32 7d2c 2532
0x0100:  307b 2532 326c 6e67 2532 323a 382e 322c
0x0110:  2532 326c 6174 2532 323a 3130 2e32 7d5d
0x0120:  2c25 3232 636f 6f72 6474 7970 6525 3232
0x0130:  3a32 7d20 4854 5450 2f31 2e31 0d0a 486f
0x0140:  7374 3a20 3130 2e39 362e 3932 2e32 3132
0x0150:  3a37 3038 300d 0a55 7067 7261 6465 2d49
0x0160:  6e73 6563 7572 652d 5265 7175 6573 7473
0x0170:  3a20 310d 0a41 6363 6570 743a 2074 6578
0x0180:  742f 6874 6d6c 2c61 7070 6c69 6361 7469
0x0190:  6f6e 2f78 6874 6d6c 2b78 6d6c 2c61 7070
0x01a0:  6c69 6361 7469 6f6e 2f78 6d6c 3b71 3d30
0x01b0:  2e39 2c2a 2f2a 3b71 3d30 2e38 0d0a 5573
0x01c0:  6572 2d41 6765 6e74 3a20 4d6f 7a69 6c6c
0x01d0:  612f 352e 3020 284d 6163 696e 746f 7368
0x01e0:  3b20 496e 7465 6c20 4d61 6320 4f53 2058
0x01f0:  2031 305f 3133 5f36 2920 4170 706c 6557
0x0200:  6562 4b69 742f 3630 352e 312e 3135 2028
0x0210:  4b48 544d 4c2c 206c 696b 6520 4765 636b
0x0220:  6f29 2056 6572 7369 6f6e 2f31 322e 302e
0x0230:  3220 5361 6661 7269 2f36 3035 2e31 2e31
0x0240:  350d 0a41 6363 6570 742d 4c61 6e67 7561
0x0250:  6765 3a20 7a68 2d63 6e0d 0a41 6363 6570
0x0260:  742d 456e 636f 6469 6e67 3a20 677a 6970
0x0270:  2c20 6465 666c 6174 650d 0a43 6f6e 6e65
0x0280:  6374 696f 6e3a 206b 6565 702d 616c 6976
0x0290:  650d 0a0d 0a&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来逐字节分析。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;IP版本为ipv4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x5&lt;/td&gt;
&lt;td&gt;首部长度为5 * 4字节=20B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;服务类型，现在基本都置为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0295&lt;/td&gt;
&lt;td&gt;总长度为661字节，即整个包的长度是661字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x4000&lt;/td&gt;
&lt;td&gt;&lt;code&gt;3bit 标志 + 13bit 片偏移&lt;/code&gt;。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x36&lt;/td&gt;
&lt;td&gt;生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x06&lt;/td&gt;
&lt;td&gt;协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x623b&lt;/td&gt;
&lt;td&gt;16bitIP首部校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0xac17 ccdc&lt;/td&gt;
&lt;td&gt;32bit源ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0a60 5cd4&lt;/td&gt;
&lt;td&gt;32bit目的ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0xdb9b&lt;/td&gt;
&lt;td&gt;16bit源端口。56219&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x1ba8&lt;/td&gt;
&lt;td&gt;16bit目的端口7080&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0xa59a 46ce&lt;/td&gt;
&lt;td&gt;32bit序列号。2778351310&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x6d03 e87d&lt;/td&gt;
&lt;td&gt;32bit确认号。1828972669&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0b000000&lt;/td&gt;
&lt;td&gt;6bit保留位。目前置为0.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0b011000&lt;/td&gt;
&lt;td&gt;6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效，同时psh有效&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x1015&lt;/td&gt;
&lt;td&gt;滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。4117&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0ee7&lt;/td&gt;
&lt;td&gt;16bit校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可变长度部分，协议如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0402&lt;/td&gt;
&lt;td&gt;表示支持SACK&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x080a 2e4c b2ef 0f20 3acf&lt;/td&gt;
&lt;td&gt;时间戳。Ts val=0x2e4c b2ef=776778479, ecr=0x0f20 3acf=253770447&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;剩下来的就是数据部分了。我们一行一行地看。因为http是字符流，所以我们先看一下ascii字符集，执行命令：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;man ascii&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;00 nul   01 soh   02 stx   03 etx   04 eot   05 enq   06 ack   07 bel
08 bs    09 ht    0a nl    0b vt    0c np    0d cr    0e so    0f si
10 dle   11 dc1   12 dc2   13 dc3   14 dc4   15 nak   16 syn   17 etb
18 can   19 em    1a sub   1b esc   1c fs    1d gs    1e rs    1f us
20 sp    21  !    22  &quot;    23  #    24  $    25  %    26  &amp;amp;    27  '
28  (    29  )    2a  *    2b  +    2c  ,    2d  -    2e  .    2f  /
30  0    31  1    32  2    33  3    34  4    35  5    36  6    37  7
38  8    39  9    3a  :    3b  ;    3c  &amp;lt;    3d  =    3e  &amp;gt;    3f  ?
40  @    41  A    42  B    43  C    44  D    45  E    46  F    47  G
48  H    49  I    4a  J    4b  K    4c  L    4d  M    4e  N    4f  O
50  P    51  Q    52  R    53  S    54  T    55  U    56  V    57  W
58  X    59  Y    5a  Z    5b  [    5c  \    5d  ]    5e  ^    5f  _
60  `    61  a    62  b    63  c    64  d    65  e    66  f    67  g
68  h    69  i    6a  j    6b  k    6c  l    6d  m    6e  n    6f  o
70  p    71  q    72  r    73  s    74  t    75  u    76  v    77  w
78  x    79  y    7a  z    7b  {    7c  |    7d  }    7e  ~    7f del&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;41.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0030&lt;/td&gt;
&lt;td&gt;4745 5420 2f64 6174 613f 636d&lt;/td&gt;
&lt;td&gt;GE T /d at a? cm&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0040&lt;/td&gt;
&lt;td&gt;643d 4665 6e63 6532 4172 6561 266d 6574&lt;/td&gt;
&lt;td&gt;d= Fe nc e2 Ar ea &amp;amp;m et&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0050&lt;/td&gt;
&lt;td&gt;613d 7b25 3232 6361 6c6c 6572 2532 323a&lt;/td&gt;
&lt;td&gt;a= {% 22 ca ll er %2 2:&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0060&lt;/td&gt;
&lt;td&gt;2532 3274 6573 7425 3232 2c25 3232 5472&lt;/td&gt;
&lt;td&gt;%2 2t es t% 22 ,% 22 Tr&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0070&lt;/td&gt;
&lt;td&gt;6163 6549 6425 3232 3a25 3232 7465 7374&lt;/td&gt;
&lt;td&gt;ac eI d% 22 :% 22 te st&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0080&lt;/td&gt;
&lt;td&gt;2532 327d 2672 6571 7565 7374 3d7b 2532&lt;/td&gt;
&lt;td&gt;%2 2} &amp;amp;r eq ue st ={ %2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0090&lt;/td&gt;
&lt;td&gt;3266 656e 6365 2532 323a 5b7b 2532 326c&lt;/td&gt;
&lt;td&gt;2f en ce %2 2: [{ %2 2l&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00a0&lt;/td&gt;
&lt;td&gt;6e67 2532 323a 3130 2e32 2c25 3232 6c61&lt;/td&gt;
&lt;td&gt;ng %2 2: 10 .2 ,% 22 la&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00b0&lt;/td&gt;
&lt;td&gt;7425 3232 3a31 302e 327d 2c25 3230 7b25&lt;/td&gt;
&lt;td&gt;t% 22 :1 0. 2} ,% 20 {%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00c0&lt;/td&gt;
&lt;td&gt;3232 6c6e 6725 3232 3a31 302e 322c 2532&lt;/td&gt;
&lt;td&gt;22 ln g% 22 :1 0. 2, %2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00d0&lt;/td&gt;
&lt;td&gt;326c 6174 2532 323a 382e 327d 2c25 3230&lt;/td&gt;
&lt;td&gt;2l at %2 2: 8. 2} ,% 20&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00e0&lt;/td&gt;
&lt;td&gt;7b25 3232 6c6e 6725 3232 3a38 2e32 2c25&lt;/td&gt;
&lt;td&gt;{% 22 ln g% 22 :8 .2 ,%&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00f0&lt;/td&gt;
&lt;td&gt;3232 6c61 7425 3232 3a38 2e32 7d2c 2532&lt;/td&gt;
&lt;td&gt;22 la t% 22 :8 .2 }, %2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0100&lt;/td&gt;
&lt;td&gt;307b 2532 326c 6e67 2532 323a 382e 322c&lt;/td&gt;
&lt;td&gt;0{ %2 2l ng %2 2: 8. 2,&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0110&lt;/td&gt;
&lt;td&gt;2532 326c 6174 2532 323a 3130 2e32 7d5d&lt;/td&gt;
&lt;td&gt;%2 2l at %2 2: 10 .2 } ]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0120&lt;/td&gt;
&lt;td&gt;2c25 3232 636f 6f72 6474 7970 6525 3232&lt;/td&gt;
&lt;td&gt;,% 22 co or dt yp e% 22&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0130&lt;/td&gt;
&lt;td&gt;3a32 7d20 4854 5450 2f31 2e31 0d0a 486f&lt;/td&gt;
&lt;td&gt;:2 } HT TP /1 .1 crnl Ho&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0140&lt;/td&gt;
&lt;td&gt;7374 3a20 3130 2e39 362e 3932 2e32 3132&lt;/td&gt;
&lt;td&gt;st : 10 .9 6. 92 .2 12&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;0x0150&lt;/td&gt;
&lt;td&gt;3a37 3038 300d 0a55 7067 7261 6465 2d49&lt;/td&gt;
&lt;td&gt;:7 08 0cr nlU pg ra de -I&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0160&lt;/td&gt;
&lt;td&gt;6e73 6563 7572 652d 5265 7175 6573 7473&lt;/td&gt;
&lt;td&gt;ns ec ur e- Re qu es ts&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0170&lt;/td&gt;
&lt;td&gt;3a20 310d 0a41 6363 6570 743a 2074 6578&lt;/td&gt;
&lt;td&gt;: 1cr nlA cc ep t: t ex&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0180&lt;/td&gt;
&lt;td&gt;742f 6874 6d6c 2c61 7070 6c69 6361 7469&lt;/td&gt;
&lt;td&gt;t/ ht ml ,a pp li ca ti&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0190&lt;/td&gt;
&lt;td&gt;6f6e 2f78 6874 6d6c 2b78 6d6c 2c61 7070&lt;/td&gt;
&lt;td&gt;on /x ht ml +x ml ,a pp&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x01a0&lt;/td&gt;
&lt;td&gt;6c69 6361 7469 6f6e 2f78 6d6c 3b71 3d30&lt;/td&gt;
&lt;td&gt;li ca ti on /x ml ;q =0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x01b0&lt;/td&gt;
&lt;td&gt;2e39 2c2a 2f2a 3b71 3d30 2e38 0d0a 5573&lt;/td&gt;
&lt;td&gt;.9 ,* /* ;q =0 .8 crnl Us&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x01c0&lt;/td&gt;
&lt;td&gt;6572 2d41 6765 6e74 3a20 4d6f 7a69 6c6c&lt;/td&gt;
&lt;td&gt;er -A ge nt : Mo zi ll&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x01d0&lt;/td&gt;
&lt;td&gt;612f 352e 3020 284d 6163 696e 746f 7368&lt;/td&gt;
&lt;td&gt;a/ 5. 0 (M ac in to sh&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x01e0&lt;/td&gt;
&lt;td&gt;3b20 496e 7465 6c20 4d61 6320 4f53 2058&lt;/td&gt;
&lt;td&gt;; In te l Ma c OS X&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x01f0&lt;/td&gt;
&lt;td&gt;2031 305f 3133 5f36 2920 4170 706c 6557&lt;/td&gt;
&lt;td&gt;1 0_ 13 _6 ) Ap pl eW&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0200&lt;/td&gt;
&lt;td&gt;6562 4b69 742f 3630 352e 312e 3135 2028&lt;/td&gt;
&lt;td&gt;eb Ki t/ 60 5. 1. 15 (&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0210&lt;/td&gt;
&lt;td&gt;4b48 544d 4c2c 206c 696b 6520 4765 636b&lt;/td&gt;
&lt;td&gt;KH TM L, l i k e Ge ck&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0220&lt;/td&gt;
&lt;td&gt;6f29 2056 6572 7369 6f6e 2f31 322e 302e&lt;/td&gt;
&lt;td&gt;o) V er si o n /1 2. 0.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0230&lt;/td&gt;
&lt;td&gt;3220 5361 6661 7269 2f36 3035 2e31 2e31&lt;/td&gt;
&lt;td&gt;2 Sa fa ri /6 05 .1 .1&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;0x0240&lt;/td&gt;
&lt;td&gt;350d 0a41 6363 6570 742d 4c61 6e67 7561&lt;/td&gt;
&lt;td&gt;5cr nlA cc ep t- La ng ua&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0250&lt;/td&gt;
&lt;td&gt;6765 3a20 7a68 2d63 6e0d 0a41 6363 6570&lt;/td&gt;
&lt;td&gt;ge : zh -c ncr nlA cc ep&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0260&lt;/td&gt;
&lt;td&gt;742d 456e 636f 6469 6e67 3a20 677a 6970&lt;/td&gt;
&lt;td&gt;t- En co di ng : gz ip&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0270&lt;/td&gt;
&lt;td&gt;2c20 6465 666c 6174 650d 0a43 6f6e 6e65&lt;/td&gt;
&lt;td&gt;, de fl at ecr nlC on ne&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0280&lt;/td&gt;
&lt;td&gt;6374 696f 6e3a 206b 6565 702d 616c 6976&lt;/td&gt;
&lt;td&gt;ct io n: k ee p- al iv&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0290&lt;/td&gt;
&lt;td&gt;650d 0a0d 0a&lt;/td&gt;
&lt;td&gt;ecr nl cr nl&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;把上表的最后一列连起来，就是：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;GET /data?cmd=Fence2Area&amp;amp;meta={%22caller%22:%22test%22,%22TraceId%22:%22test%22}&amp;amp;request={%22fence%22:[{%22lng%22:10.2,%22lat%22:10.2},%20{%22lng%22:10.2,%22lat%22:8.2},%20{%22lng%22:8.2,%22lat%22:8.2},%20{%22lng%22:8.2,%22lat%22:10.2}],%22coordtype%22:2} HTTP/1.1 
Host: 10.96.92.212:7080 
Upgrade-Insecure-Requests: 1 
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.2 Safari/605.1.15 
Accept-Language: zh-cn 
Accept-Encoding: gzip, deflate 
Connection: keep-alive 
 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，cr nl表示回车，换行。&lt;/p&gt;
&lt;p&gt;docker收到数据后，会回复一个ack包。第四个包的总长度为661字节，去掉IP头部20字节，TCP头部固定部分20字节，TCP头部可选长度为12字节，共52字节，因此TCP数据部分总长度为661-52=609字节。&lt;/p&gt;
&lt;p&gt;序列号为2778351310.&lt;/p&gt;
&lt;p&gt;再来看第5个包，字节流如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;        0x0000:  4500 0034 d28b 4000 4006 8810 0a60 5cd4
        0x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f
        0x0020:  8010 00ec e04e 0000 0101 080a 0f20 3af7
        0x0030:  2e4c b2ef&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;IP版本为ipv4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x5&lt;/td&gt;
&lt;td&gt;首部长度为5 * 4字节=20B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;服务类型，现在基本都置为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0034&lt;/td&gt;
&lt;td&gt;总长度为52字节，即整个包的长度是52字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0xd28b&lt;/td&gt;
&lt;td&gt;标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x4000&lt;/td&gt;
&lt;td&gt;&lt;code&gt;3bit 标志 + 13bit 片偏移&lt;/code&gt;。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x40&lt;/td&gt;
&lt;td&gt;生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x06&lt;/td&gt;
&lt;td&gt;协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x8810&lt;/td&gt;
&lt;td&gt;16bitIP首部校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x0a60 5cd4&lt;/td&gt;
&lt;td&gt;32bit源ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0xac17 ccdc&lt;/td&gt;
&lt;td&gt;32bit目的ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x1ba8&lt;/td&gt;
&lt;td&gt;16bit源端口7080&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0xdb9b&lt;/td&gt;
&lt;td&gt;16bit目的端口。56219&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x6d03 e87d&lt;/td&gt;
&lt;td&gt;32bit序列号。1828972669&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0xa59a 492f&lt;/td&gt;
&lt;td&gt;32bit确认号。2778351919. 第三个包的序列号为2778351310, 加上数据长度609, 正好相等。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0b000000&lt;/td&gt;
&lt;td&gt;6bit保留位。目前置为0.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0b010000&lt;/td&gt;
&lt;td&gt;6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00ec&lt;/td&gt;
&lt;td&gt;滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。4117&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0xe04e&lt;/td&gt;
&lt;td&gt;16bit校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可变长度部分，协议如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0402&lt;/td&gt;
&lt;td&gt;表示支持SACK&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x080a 2e4c b2ef 0f20 3acf&lt;/td&gt;
&lt;td&gt;时间戳。Ts val=253770487, ecr=776778479&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;数据部分为空，这个包仅为确认包。&lt;/p&gt;
&lt;p&gt;再来看第六个包，字节流如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;0x0000:  4500 00f9 d28c 4000 4006 874a 0a60 5cd4
0x0010:  ac17 ccdc 1ba8 db9b 6d03 e87d a59a 492f
0x0020:  8018 00ec e113 0000 0101 080a 0f20 3af8
0x0030:  2e4c b2ef 4854 5450 2f31 2e31 2032 3030
0x0040:  204f 4b0d 0a41 6363 6573 732d 436f 6e74
0x0050:  726f 6c2d 416c 6c6f 772d 4f72 6967 696e
0x0060:  3a20 2a0d 0a44 6174 653a 2054 6875 2c20
0x0070:  3033 204a 616e 2032 3031 3920 3132 3a32
0x0080:  333a 3437 2047 4d54 0d0a 436f 6e74 656e
0x0090:  742d 4c65 6e67 7468 3a20 3438 0d0a 436f
0x00a0:  6e74 656e 742d 5479 7065 3a20 7465 7874
0x00b0:  2f70 6c61 696e 3b20 6368 6172 7365 743d
0x00c0:  7574 662d 380d 0a0d 0a7b 2264 6174 6122
0x00d0:  3a7b 2261 7265 6122 3a34 3837 3634 3133
0x00e0:  3535 3937 2e38 3432 3630 367d 2c22 6572
0x00f0:  7273 7472 223a 2222 7d&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;IP版本为ipv4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x5&lt;/td&gt;
&lt;td&gt;首部长度为5 * 4字节=20B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;服务类型，现在基本都置为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00f9&lt;/td&gt;
&lt;td&gt;总长度为249字节，即整个包的长度是249字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0xd28c&lt;/td&gt;
&lt;td&gt;标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x4000&lt;/td&gt;
&lt;td&gt;&lt;code&gt;3bit 标志 + 13bit 片偏移&lt;/code&gt;。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x40&lt;/td&gt;
&lt;td&gt;生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为64.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x06&lt;/td&gt;
&lt;td&gt;协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x874a&lt;/td&gt;
&lt;td&gt;16bitIP首部校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x0a60 5cd4&lt;/td&gt;
&lt;td&gt;32bit源ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0xac17 ccdc&lt;/td&gt;
&lt;td&gt;32bit目的ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x1ba8&lt;/td&gt;
&lt;td&gt;16bit源端口7080&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0xdb9b&lt;/td&gt;
&lt;td&gt;16bit目的端口。56219&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x6d03 e87d&lt;/td&gt;
&lt;td&gt;32bit序列号。1828972669&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0xa59a 492f&lt;/td&gt;
&lt;td&gt;32bit确认号。2778351919&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0b000000&lt;/td&gt;
&lt;td&gt;6bit保留位。目前置为0.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0b011000&lt;/td&gt;
&lt;td&gt;6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效，同时psh有效&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00ec&lt;/td&gt;
&lt;td&gt;滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。236&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0xe113&lt;/td&gt;
&lt;td&gt;16bit校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可变长度部分，协议如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0402&lt;/td&gt;
&lt;td&gt;表示支持SACK&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x080a 0f20 3af8 2e4c b2ef&lt;/td&gt;
&lt;td&gt;时间戳。Ts val=0x2e4c b2ef=253770488, ecr=0x0f20 3acf=776778479&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;剩下来的就是数据部分了。我们一行一行地看。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0030&lt;/td&gt;
&lt;td&gt;4854 5450 2f31 2e31 2032 3030&lt;/td&gt;
&lt;td&gt;HTTP/1.1 200&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0040&lt;/td&gt;
&lt;td&gt;204f 4b0d 0a41 6363 6573 732d 436f 6e74&lt;/td&gt;
&lt;td&gt;OK \r\n Access-Cont&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0050&lt;/td&gt;
&lt;td&gt;726f 6c2d 416c 6c6f 772d 4f72 6967 696e&lt;/td&gt;
&lt;td&gt;rol-Allow-Origin&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0060&lt;/td&gt;
&lt;td&gt;3a20 2a0d 0a44 6174 653a 2054 6875 2c20&lt;/td&gt;
&lt;td&gt;: * \r\n Date: Thu,&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0070&lt;/td&gt;
&lt;td&gt;3033 204a 616e 2032 3031 3920 3132 3a32&lt;/td&gt;
&lt;td&gt;03 Jan 2019 12:2&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0080&lt;/td&gt;
&lt;td&gt;333a 3437 2047 4d54 0d0a 436f 6e74 656e&lt;/td&gt;
&lt;td&gt;3:47 GMT \r\n Conten&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0090&lt;/td&gt;
&lt;td&gt;742d 4c65 6e67 7468 3a20 3438 0d0a 436f&lt;/td&gt;
&lt;td&gt;t-Length: 48\r\n Co&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00a0&lt;/td&gt;
&lt;td&gt;6e74 656e 742d 5479 7065 3a20 7465 7874&lt;/td&gt;
&lt;td&gt;ntent-Type: text&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00b0&lt;/td&gt;
&lt;td&gt;2f70 6c61 696e 3b20 6368 6172 7365 743d&lt;/td&gt;
&lt;td&gt;/plain; charset=&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00c0&lt;/td&gt;
&lt;td&gt;7574 662d 380d 0a0d 0a7b 2264 6174 6122&lt;/td&gt;
&lt;td&gt;utf-8\r\n\r\n{&quot;data&quot;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00d0&lt;/td&gt;
&lt;td&gt;3a7b 2261 7265 6122 3a34 3837 3634 3133&lt;/td&gt;
&lt;td&gt;:{&quot;area&quot;:4876413&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00e0&lt;/td&gt;
&lt;td&gt;3535 3937 2e38 3432 3630 367d 2c22 6572&lt;/td&gt;
&lt;td&gt;5597.842606},&quot;er&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x00f0&lt;/td&gt;
&lt;td&gt;7273 7472 223a 2222 7d&lt;/td&gt;
&lt;td&gt;rstr&quot;:&quot;&quot;}&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;把上表的最后一列连起来，就是：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;HTTP/1.1 200 OK 
Access-Control-Allow-Origin: * 
Date: Thu, 03 Jan 2019 12:23:47 GMT 
Content-Length: 48 
Content-Type: text/plain; charset=utf-8 
{&quot;data&quot;:{&quot;area&quot;:48764135597.842606},&quot;errstr&quot;:&quot;&quot;}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Content-Length: 48，最后一行的长度即为48个字节。&lt;/p&gt;
&lt;p&gt;最后，第七个包，字节流如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;0x0000:  4500 0034 0000 4000 3606 649c ac17 ccdc
0x0010:  0a60 5cd4 db9b 1ba8 a59a 492f 6d03 e942
0x0020:  8010 100f 1eb9 0000 0101 080a 2e4c b314
0x0030:  0f20 3af8&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x4&lt;/td&gt;
&lt;td&gt;IP版本为ipv4&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x5&lt;/td&gt;
&lt;td&gt;首部长度为5 * 4字节=20B&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x00&lt;/td&gt;
&lt;td&gt;服务类型，现在基本都置为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x0034&lt;/td&gt;
&lt;td&gt;总长度为52字节，即整个包的长度是52字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;标识。同一个数据报的唯一标识。当IP数据报被拆分时，会复制到每一个数据中。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x4000&lt;/td&gt;
&lt;td&gt;&lt;code&gt;3bit 标志 + 13bit 片偏移&lt;/code&gt;。3bit 标志对应 R、DF、MF。目前只有后两位有效，DF位：为1表示不分片，为0表示分片。MF：为1表示“更多的片”，为0表示这是最后一片。13bit 片位移：本分片在原先数据报文中相对首位的偏移位。（需要再乘以8 )&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x36&lt;/td&gt;
&lt;td&gt;生存时间TTL。IP报文所允许通过的路由器的最大数量。每经过一个路由器，TTL减1，当为 0 时，路由器将该数据报丢弃。TTL 字段是由发送端初始设置一个 8 bit字段.推荐的初始值由分配数字 RFC 指定。发送 ICMP 回显应答时经常把 TTL 设为最大值 255。TTL可以防止数据报陷入路由循环。 此处为54.&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x06&lt;/td&gt;
&lt;td&gt;协议类型。指出IP报文携带的数据使用的是哪种协议，以便目的主机的IP层能知道要将数据报上交到哪个进程。TCP 的协议号为6，UDP 的协议号为17。ICMP 的协议号为1，IGMP 的协议号为2。该 IP 报文携带的数据使用 TCP 协议，得到了验证。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x649c&lt;/td&gt;
&lt;td&gt;16bitIP首部校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0xac17 ccdc&lt;/td&gt;
&lt;td&gt;32bit源ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x0a60 5cd4&lt;/td&gt;
&lt;td&gt;32bit目的ip地址。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;剩余的数据部分即为TCP协议相关的。TCP也是20B固定长度+可变长度部分。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;10.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0xdb9b&lt;/td&gt;
&lt;td&gt;16bit源端口。56219&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x1ba8&lt;/td&gt;
&lt;td&gt;16bit目的端口7080&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0xa59a 492f&lt;/td&gt;
&lt;td&gt;32bit序列号。2778351919&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x6d03 e942&lt;/td&gt;
&lt;td&gt;32bit确认号号。1828972866. 第六个包的序列号为1828972669, 加上数据长度197, 正好相等&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0x8&lt;/td&gt;
&lt;td&gt;4bit首部长度，以4byte为单位。共8*4=32字节。因此TCP报文的可选长度为32-20=12字节&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0b000000&lt;/td&gt;
&lt;td&gt;6bit保留位。目前置为0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;0b010000&lt;/td&gt;
&lt;td&gt;6bitTCP标志位。从左到右依次是紧急 URG、确认 ACK、推送 PSH、复位 RST、同步 SYN 、终止 FIN。ack有效&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;0x100f&lt;/td&gt;
&lt;td&gt;滑动窗口大小，滑动窗口即tcp接收缓冲区的大小，用于tcp拥塞控制。4111&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x1eb9&lt;/td&gt;
&lt;td&gt;16bit校验和。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;0x0000&lt;/td&gt;
&lt;td&gt;紧急指针。仅在 URG = 1时才有意义，它指出本报文段中的紧急数据的字节数。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍是普通数据。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;可变长度部分，协议如下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;0x01&lt;/td&gt;
&lt;td&gt;无操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;0x080a 2e4c b314 0f20 3af8&lt;/td&gt;
&lt;td&gt;时间戳。Ts val=0x2e4c b314=776778516, ecr=0x0f20 3af8=253770488&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;至此，一次完整的http请求的报文就解析完了。你是否觉得也就那样，sso easy？&lt;/p&gt;

&lt;p&gt;上面我们把HTTP协议相关的数据给解构了，下面我将对照上面的数据拆解结果，一步步深入理解HTTP的协议。&lt;/p&gt;
&lt;h2 id=&quot;整体介绍&quot;&gt;整体介绍&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;HTTP&lt;/code&gt;(Hypertext Transfer Protocol)超文本传输协议，是在互联网上进行通信时使用的一种协议。更形象一点：&lt;code&gt;HTTP&lt;/code&gt;是现代互联网中使用的公共语言。它最著名的应用是用在浏览器的服务器间的通信。&lt;/p&gt;
&lt;p&gt;HTTP属于应用层协议，底层是靠TCP进行可靠地信息传输。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51079842-4b2f1780-170a-11e9-9b22-ad68fe4541cc.png&quot; alt=&quot;HTTP层次&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HTTP在传输一段报文时，会以&lt;code&gt;流&lt;/code&gt;的形式将报文数据的内容通过&lt;code&gt;一条打开&lt;/code&gt;的TCP连接按序传输。TCP接到上层应用交给它的数据流之后，会按序将数据流打散成一个个的分段。再交到IP层，通过网络进行传输。另一端的接收方则相反，它们将接收到的分段按序组装好，交给上层HTTP协议进行处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/50802850-15adb700-1323-11e9-87b8-892139c3104d.png&quot; alt=&quot;tcp http structure&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;编码&quot;&gt;编码&lt;/h2&gt;
&lt;p&gt;我们再来回顾一下：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;12&quot;&gt;&lt;td&gt;原始url&lt;/td&gt;
&lt;td&gt;/data?cmd=Fence2Area&amp;amp;meta={&quot;caller&quot;:&quot;test&quot;,&quot;TraceId&quot;:&quot;test&quot;}&amp;amp;request={&quot;fence&quot;:[{&quot;lng&quot;:10.2,&quot;lat&quot;:10.2}, {&quot;lng&quot;:10.2,&quot;lat&quot;:8.2}, {&quot;lng&quot;:8.2,&quot;lat&quot;:8.2}, {&quot;lng&quot;:8.2,&quot;lat&quot;:10.2}],&quot;coordtype&quot;:2}&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;13&quot;&gt;&lt;td&gt;编码后url&lt;/td&gt;
&lt;td&gt;/data?cmd=Fence2Area&amp;amp;meta={%22caller%22:%22test%22,%22TraceId%22:%22test%22}&amp;amp;request={%22fence%22:[{%22lng%22:10.2,%22lat%22:10.2},%20{%22lng%22:10.2,%22lat%22:8.2},%20{%22lng%22:8.2,%22lat%22:8.2},%20{%22lng%22:8.2,%22lat%22:10.2}],%22coordtype%22:2}&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;我们看到多了很多&lt;code&gt;%22&lt;/code&gt;，&lt;code&gt;0x22&lt;/code&gt;是&lt;code&gt;&quot;&lt;/code&gt;的ascii值，&lt;/p&gt;
&lt;p&gt;一方面，URL描述的资源为了能通过其他各种协议传送，但是有些协议在传输过程中会剥去一些特定的字符；另一方面，URL还是可读的，所以那些不可打印的字符就不能在URL中使用了，如空格；最后，URL还得是完整的，它需要支持所有语言的字符。&lt;/p&gt;
&lt;p&gt;总之，基于很多原因，URL设计者将US-ASCII码和其转义序列集成到URL中，通过转义序列，就可以用US-ASCII字符集的有限子集对任意字符或数据进行编码了。&lt;/p&gt;
&lt;p&gt;转义的方法：百分号(&lt;code&gt;%&lt;/code&gt;)后跟着两个表示ASCII码的十六进制数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51080616-322e6280-171a-11e9-8deb-28ca0a472d51.png&quot; alt=&quot;转义法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以上面在浏览器发送给服务器的URL进行了非“安全字符”编码，也就不奇怪了吧？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51294507-3aeea380-1a4e-11e9-9f52-2fb248a2d5de.png&quot; alt=&quot;url保留及受限的字符&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在URL中，当上面的保留字符用在保留用途之外的场合时，需要对URL进行编码。&lt;/p&gt;
&lt;h2 id=&quot;mime类型&quot;&gt;MIME类型&lt;/h2&gt;
&lt;p&gt;响应数据中，我们注意到有一个首部：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Content-Type: text/plain; charset=utf-8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;互联网上有数千种不同的数据类型，HTTP给每种对象都打上了MIME(Multipurpose Internet Media Extension, 多用途因特网邮件扩展)标签，也就是响应数据中的&lt;code&gt;Content-Type&lt;/code&gt;. MIME本来是用在邮件中的，后来被移植到了HTTP中。浏览器从服务器上取回了一个对象时，会去查看MIME类型，从而得知如何处理这种对象，如展示图片，调用声卡播放声音。MIME通过斜杠来标识对象的主类型和其中的特定的子类型，下表中的实体主体是指body部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51149947-3768ea00-189f-11e9-8fcd-d40f2f2ccf0a.png&quot; alt=&quot;MIME类型&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;uriurlurn&quot;&gt;URI/URL/URN&lt;/h2&gt;
&lt;p&gt;URI(Uniform Resource Identifier, 统一资源标识符)表示服务器资源，URL(Uniform Resource Locator)和URN(Uniform Resource Name, 统一资源名)是URI的具体实现。URI是一个通用的概念，由两个主要的子集URL和URN构成，URL通过位置、URN通过名字来标识资源。&lt;/p&gt;
&lt;p&gt;URL定义了资源的位置，表示资源的实际地址，在使用URL的过程中，如果URL背后的资源发生了位置移动，访问者就找不到它了。这个时候就要用到URN了，它给定资源一个名字，无论它移动到哪里，都可以通过这个名字来访问到它，简直完美！&lt;/p&gt;
&lt;p&gt;URL通常的格式是：协议方案(scheme)(如 &lt;code&gt;http&lt;/code&gt;, &lt;code&gt;ftp&lt;/code&gt;，告知web客户端怎样访问资源)+服务器地址(如 &lt;code&gt;www.oreilly.com&lt;/code&gt;)+具体的资源路径(如 &lt;code&gt;index.html&lt;/code&gt;)。如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51070533-b5e64180-167d-11e9-8dc3-4c54b3cbf1a2.png&quot; alt=&quot;URL举例&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;http方法&quot;&gt;HTTP方法&lt;/h2&gt;
&lt;p&gt;HTTP支持几种不同的请求方法，每种方法对服务器要求的动作不同，如下图是几种常见的方法：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51070644-a0721700-167f-11e9-8579-8702abdb860b.png&quot; alt=&quot;常见的http方法&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HEAD方法只获取头部，不获取数据部分。通过头部可以获取比如资源的类型(Content-Type)、资源的长度(Content-Length)这些信息。&lt;/p&gt;
&lt;p&gt;POST用于向服务器发送数据，PUT用于向服务器上的资源存储数据。&lt;/p&gt;
&lt;h2 id=&quot;状态码&quot;&gt;状态码&lt;/h2&gt;
&lt;p&gt;每条HTTP的响应报文都会带上一个三位数字的状态码和一条解释性的“原因短语”，通知客户端本次请求的状态，帮助客户端快速理解事务处理结果，最常见的是：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;200 OK 
404 Not Found
500 Internal Server Error&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们平时使用浏览器的时候，很多的错误码其实是由浏览器处理的，我们感知不到。但是&lt;code&gt;404 Not Found&lt;/code&gt;会穿透重重迷雾，来到我们面前，那是因为他对我们爱的深沉啊！&lt;/p&gt;
&lt;p&gt;客户端可以据此状态码，决定下一步的行动（如重定向等）。&lt;/p&gt;
&lt;p&gt;三位数字的第一位表示分类：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51070802-2f802e80-1682-11e9-8a02-f60e2f11c3e6.png&quot; alt=&quot;http状态分类&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;报文格式&quot;&gt;报文格式&lt;/h2&gt;
&lt;p&gt;HTTP报文实际上是由一行行的字符串组成的，每行字符串的mowei用&lt;code&gt;\r\n&lt;/code&gt;分隔，人类可以很方便的阅读。顺便说一句，不是所有的协议都对人类这么友好的，像thrift协议，直接甩一堆字节给你，告诉你说&lt;code&gt;0x0001&lt;/code&gt;表示调用方法，诸如此类的，你只能对着一个十六进制的数据块一个个地去“解码”。&lt;/p&gt;
&lt;p&gt;请求报文和响应报文的格式，还可以结合上面的例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51070991-6dcb1d00-1685-11e9-8dae-25b63ad7ad52.png&quot; alt=&quot;请求响应报文示例&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上，请求报文也是可以有body（主体）部分的。请求报文是由&lt;code&gt;请求行（request line）、请求头部（header）、空行和请求数据&lt;/code&gt;四个部分组成。唯一要注意的一点就是，请求报文即使body部分是空的，请求头部后的&lt;code&gt;回车换行&lt;/code&gt;符也是必须要有的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51071026-c4d0f200-1685-11e9-81ca-87c8da1dfc30.png&quot; alt=&quot;请求报文格式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;响应报文的格式和请求报文的格式类似：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51074380-67ef2f00-16b9-11e9-81e7-d5ecaa8d4537.png&quot; alt=&quot;响应报文格式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求报文、响应报文的起始行和响应头部里的字段都是文本化、结构化的。而请求body却可以包含任意二进制数据（如图片、视频、软件等），当然也可以包含文本。&lt;/p&gt;
&lt;p&gt;有些首部是通用的，有些则是请求或者响应报文才会有的。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;6.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;通用&lt;/td&gt;
&lt;td&gt;Thu, 03 Jan 2019 12:23:47 GMT&lt;/td&gt;
&lt;td&gt;报文构建的时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;Accept&lt;/td&gt;
&lt;td&gt;请求报文&lt;/td&gt;
&lt;td&gt;text/html,application/xhtml+xml,application/xm&lt;/td&gt;
&lt;td&gt;客户端能接收的数据类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;Content-Type&lt;/td&gt;
&lt;td&gt;响应报文&lt;/td&gt;
&lt;td&gt;Content-Type: text/plain; charset=utf-8&lt;/td&gt;
&lt;td&gt;响应报文中的body部分的数据类型&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;顺便提一下， 用telnet直连服务器的http端口，telnet命令会建立一条TCP通道，然后我们可以直接发送请求数据，获取响应数据了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51079989-318fcf00-170e-11e9-9958-daf87d65972b.png&quot; alt=&quot;telnet与http对话&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;代理&quot;&gt;代理&lt;/h2&gt;
&lt;p&gt;HTTP的代理是服务器即是Web服务器，又是Web客户端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51082793-23ab6f80-1749-11e9-8247-1a3fc5ac4d1d.png&quot; alt=&quot;HTTP代理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用代理可以“接触”到所有流过的HTTP流量，代理可以对其进行监视和修改。常见的就是对儿童过滤一些“成人”内容；网络工程师会利用代理服务器来提高安全性，它可以限制哪些应用层的协议数据可以通过，过滤“病毒”等数据；代理可以存储缓存的文件，直接返回给访问者，无需请求原始的服务器资源；对于访问慢速网络上的公共内容时，可以假扮服务器提供服务，从而提高访问速度；这被称为&lt;code&gt;反向代理&lt;/code&gt;；可以作为内容路由器，如对付费用户，则将请求导到缓存服务器，提高访问速度；可以将页面的语言转换到与客户端相匹配，这称为“内容转码器”；“匿名代理”会主动从HTTP报文中删除身份相关的信息，如&lt;code&gt;User-Agent&lt;/code&gt;, &lt;code&gt;Cookie&lt;/code&gt;等字段。&lt;/p&gt;
&lt;p&gt;现实中，请求通过以下几种方式打到代理服务器上去：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51083035-c534c000-174d-11e9-9cab-ddc4a0de2314.png&quot; alt=&quot;代理获取流量的方式&quot;/&gt;&lt;/p&gt;
&lt;p&gt;报文每经过一个中间点（代理或网关），都需要在首部via字段的末尾插入一个可以代表本节点的独特的字符串，包含实现的协议版本和主机地址。&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51083254-e7304180-1751-11e9-95f8-a833a0d10d51.png&quot; alt=&quot;via字段&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请求和响应的报文传输路径通常都是一致的，只不过方向是相反的。因此，响应报文上的via字段表示的中间节点的顺序是刚好相反的。&lt;/p&gt;
&lt;h2 id=&quot;缓存&quot;&gt;缓存&lt;/h2&gt;
&lt;p&gt;当有很多请求访问同一个页面时，服务器会多次传输同一份数据，这些数据重复地在网络中传输着，消耗着大量带宽。如果将这些数据缓存下来，就可以提高响应速度，节省网络带宽了。&lt;/p&gt;
&lt;p&gt;大部分缓存只有在客户端发起请求，并且副本已经比较旧的情况下才会对副本的新鲜度进行检测。最常用的请求首部是&lt;code&gt;If-Modified-Since&lt;/code&gt;, 如果在xx(此时间即为If-Modified-Since的值)时间之后内容没有变化，服务器会回应一个&lt;code&gt;304 Not Modified&lt;/code&gt;. 否则，服务器会正常响应，并返回原始的文件数据，而这个过程中被称为&lt;code&gt;再验证命中&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再验证可能出现命中或未命中的情况。未命中时，服务器回复&lt;code&gt;200 OK&lt;/code&gt;，并且返回完整的数据；命中时，服务器回复&lt;code&gt;304 Not Modified&lt;/code&gt;; 还有一种情况，缓存被删除了，那么缓存服务器也会删除自己缓存的副本。&lt;/p&gt;
&lt;p&gt;顺带提一句，若要在项目中使用缓存，就一定要关注缓存命中比例。若命中比例不高，就要重新考虑设置缓存的必要性了。&lt;/p&gt;
&lt;p&gt;缓存服务器返回响应的时候，是基于已缓存的服务器响应的首部，对一些首部字段做一些微调。比如向其中插入新鲜度信息（如&lt;code&gt;Age&lt;/code&gt;, &lt;code&gt;Expires&lt;/code&gt;首部等），而且通常会包含一个&lt;code&gt;via&lt;/code&gt;首部来说明缓存是由一个缓存代理提供的。注意，这时不要修改&lt;code&gt;Date&lt;/code&gt;字段，它表示原始服务器最初构建这条响应的日期。&lt;/p&gt;
&lt;p&gt;HTTP通过&lt;code&gt;文档过期机制&lt;/code&gt;和&lt;code&gt;服务器再验证机制&lt;/code&gt;保持已缓存数据和服务器间的数据充分一致。&lt;/p&gt;
&lt;p&gt;文档过期通过如下首部字段来表示缓存的有效期：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51092170-60ba4500-17cf-11e9-8689-71b3c552bff3.png&quot; alt=&quot;缓存有效期&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当上面两个字段暗示的过期时间已到，需要向服务器再次验证文档的新鲜度。如果这时缓存仍和服务器上的原始文档一致，缓存只需要更新头部的相关字段。&lt;/p&gt;
&lt;p&gt;为了更好的节省网络流量，缓存服务器可以通过相关首部向原始服务器发送一个&lt;code&gt;条件GET&lt;/code&gt;请求, 这样只有在缓存真正过期的情况下，才会返回原始的文档，否则只会返回相关的首部。&lt;code&gt;条件GET&lt;/code&gt;请求会用到如下的字段：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51092289-8562ec80-17d0-11e9-9e35-47a010a3f7a3.png&quot; alt=&quot;缓存条件GET&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;cookie&quot;&gt;cookie&lt;/h2&gt;
&lt;p&gt;cookie是服务器“贴在”客户端身上的标签，由客户端维护的状态片段，并且只会回送给合适的站点。&lt;/p&gt;
&lt;p&gt;有两类cookie: 会话cookie、持久cookie. 会话cookie在退出浏览器后就被删除了；而持久cookie则保存在硬盘中，计算机重启后仍然存在。&lt;/p&gt;
&lt;p&gt;服务器在给客户端的响应字段首部加上&lt;code&gt;Set-cookie&lt;/code&gt;或&lt;code&gt;Set-cookie2&lt;/code&gt;, 值为名字=值的列表，即可以包含多个字段。当下次浏览器再次访问到相同的网站时，会将这些字段通过&lt;code&gt;Cookie&lt;/code&gt;带上。cookie中保留的内容是服务器给此客户端打的标签，方便服务进行追踪的识别码。浏览器会将cookie以特定的格式存储在特定的文件中。&lt;/p&gt;
&lt;p&gt;浏览器只会向产生这条cookie的站点发生cookie. &lt;code&gt;Set-cookie&lt;/code&gt;字段的值会包含&lt;code&gt;domain&lt;/code&gt;这个字段，告知浏览器可以把这条cookie发送给给相关的匹配的站点。&lt;code&gt;path&lt;/code&gt;字段也是相似的功能。如i浏览器收到如下的cookie:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Set-cookie: user=&quot;mary&quot;; domain=&quot;stefno.com&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么浏览器在访问任意以&lt;code&gt;stefno.com&lt;/code&gt;结尾的站点都会发送：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Cookie: user=&quot;mary&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;实体和编码&quot;&gt;实体和编码&lt;/h2&gt;
&lt;p&gt;响应报文中的body部分传输的数据本质上都是二进制。我们从上面的报文数据也可以看出来，都是用十六进制数来表示，关键是怎么解释这块内容。如果&lt;code&gt;Content-Type&lt;/code&gt;定义是&lt;code&gt;text/plain&lt;/code&gt;, 那说明body内容就是文本，我们直接按文本编码来解释；如果&lt;code&gt;Content-Type&lt;/code&gt;定义是&lt;code&gt;image/png&lt;/code&gt;, 说明body部分是一幅图片，那我们就按图片的格式去解释数据。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Content-Length&lt;/code&gt;标示报文主体部分的数据长度大小，如果内容是压缩的，那它表示的就是压缩后的大小。另外，&lt;code&gt;Content-Length&lt;/code&gt;在长连接的情况下，可以对多个报文进行正确地分段。所以，如果没有采用分块编码，响应数据中必须带上&lt;code&gt;Content-Length&lt;/code&gt;字段。分块编码的情形中，数据被拆分成很多小块，每块都有大小说明。因此，任何带有主体部分的报文（请求或是响应）都应带上正确的&lt;code&gt;Content-Length&lt;/code&gt;首部。&lt;/p&gt;
&lt;p&gt;HTTP的早期版本采用关闭连接的方式来划定报文的结束。这带来的问题是显而易见的：客户端并不能分清是因为服务器正常结束还是中途崩溃了。这里，如果是客户端用关闭来表示请求报文主体部分的结束，是不可取的，因为关闭之后，就无法获取服务器的响应了。当然，客户端可以采用半关闭的方式，只关闭数据发送方向，但是很多服务器是不识别的，会把半关闭当成客户端要成服务器断开来处理。&lt;/p&gt;
&lt;p&gt;HTTP报文在传输的过程中可能会遭到代理或是其他通信实体的无意修改，为了让接收方知道这种情况，服务器会对body部分作一个md5, 并把值放到&lt;code&gt;Content-MD5&lt;/code&gt;这个字段中。但是，如果中间的代理即修改了报文主体，又修改了md5, 就不好检测了。因此规定代理是不能修改&lt;code&gt;Content-MD5&lt;/code&gt;首部的。这样，客户端在收到数据后，先进行解码，再算出md5, 并与&lt;code&gt;Content-MD5&lt;/code&gt;首部进行比较。&lt;/p&gt;
&lt;p&gt;HTTP在发送内容之前需要对其进行编码，它是对报文主体进行的可逆变换。比如将报文用gzip格式进行压缩，减少传输时间。常见的编码类型如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51150609-12c24180-18a2-11e9-9ca4-032f5abcd474.png&quot; alt=&quot;编码类型&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，客户端为了避免服务器返回自己不能解码的数据，请求的时候，会在&lt;code&gt;Accept-Encoding&lt;/code&gt;首部里带上自己支持的编码方式。如果不传输的话，默认可以接受任何编码方式。&lt;/p&gt;
&lt;p&gt;上面提到的编码是内容编码，它只是在响应报文的主体报文将原始数据进行编码，改变的是内容的格式。还有另一种编码：传输编码。它与内容无关，它是为了改变报文数据在网络上传输的方式。传输编码是在HTTP 1.1中引入的一个新特性。&lt;/p&gt;
&lt;p&gt;通常，服务器需要先生成数据，再进行传输，这时，可以计算数据的长度，并将其编码到&lt;code&gt;Content-Length&lt;/code&gt;中。但是，有时，内容是动态生成的，服务器希望在数据生成之前就开始传输，这时，是没有办法知道数据大小的。这种情况下，就要用到&lt;code&gt;传输编码&lt;/code&gt;来标注数据的结束的。&lt;/p&gt;
&lt;p&gt;HTTP协议中通过如下两个首部来描述和控制传输编码：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;Transfer-Encoding&lt;/td&gt;
&lt;td&gt;发送方告知接收方，我方已经进行了何种传输编码&lt;/td&gt;
&lt;td&gt;chuncked 分块编码&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;TE&lt;/td&gt;
&lt;td&gt;请求方告知服务器可以用哪种传输编码&lt;/td&gt;
&lt;td&gt;trailers, chuncked 接受分块编码，并且愿意接受在报文结尾上的拖挂&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;分块编码的报文形式是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51151337-671af080-18a5-11e9-80ad-926461f90f6a.png&quot; alt=&quot;分块编码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每个分块包含一个长度值（十六进制，字节数）和该分块的数据。&lt;code&gt;&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;&lt;/code&gt;用于区隔长度值和数据。长度值不包含分块中的任何&lt;code&gt;&amp;lt;CR&amp;gt;&amp;lt;LF&amp;gt;&lt;/code&gt;序列。最后一个分块，用长度值0来表示结束。注意看报文首部包含一个&lt;code&gt;Trailer: Content-MD5&lt;/code&gt;, 所以在紧跟着最后一个报文结束之后，就是一个拖挂。其他如，&lt;code&gt;Content-Length&lt;/code&gt;, &lt;code&gt;Trailer&lt;/code&gt;, &lt;code&gt;Transfer-Encoding&lt;/code&gt;也可以作为拖挂。&lt;/p&gt;
&lt;p&gt;内容编码和传输编码是可以结合起来使用的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51151680-ae55b100-18a6-11e9-819c-5cffcc35cd69.png&quot; alt=&quot;内容编码和传输编码结合&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;国际化支持&quot;&gt;国际化支持&lt;/h2&gt;
&lt;p&gt;HTTP为了支持国际化的内容，客户端要告知服务器自己能理解的何种语言，浏览器上安装了何种字母表编码算法。这通过&lt;code&gt;Accept-Charset&lt;/code&gt;和&lt;code&gt;Accept-Language&lt;/code&gt;首部实现。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Accept-Language: fr, en;q=0.8
Accept-Charset: iso-8859-1, utf-8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示：客户端接受法语（优先级默认为1.0）、英语（优先级为0.8），支持iso-8859-1, utf-8两种字符集编码。服务器则会在&lt;code&gt;Content-Type&lt;/code&gt;首部里放上&lt;code&gt;charset&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;本质上，HTTP报文的body部分存放的就是一串二进制码，我们先把二进制码转换成字符代码（如ascii是一个字节表示一个字符，而utf-8则表示一个字符的字节数不定，每个字符1~6个字节），之后，用字符代码支字符集中找到对应的元素。&lt;/p&gt;
&lt;p&gt;比较常见的字符集是&lt;code&gt;US-ASCII&lt;/code&gt;: 这个字符集是所有字符集的始祖，早在1968年就发布了标准。ASCII码的代码值从0到127, 只需要7个bit位就可以覆盖代码空间。HTTP报文的首部、URL使用的字符集就是ASCII码。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;US-ASCII&lt;/code&gt;是把每个字符编码成固定的7位二进制值。&lt;code&gt;UTF-8&lt;/code&gt;则是无固定的编码方案。第一个字节的高位用来表示编码后的字符所用的字节数（如果所用的字节数是5，则第一个字节前5bit都是1，第6bit是0），所需的后续的字节都含有6位的代码值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51167193-e2e65e80-18e0-11e9-97da-caea0244386d.png&quot; alt=&quot;utf-8编码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;举个例子，汉字“严”的Unicode编码为&lt;code&gt;4E25&lt;/code&gt;(&lt;code&gt;100111000100101&lt;/code&gt;), 共有15位，落在上表中的第三行，因此“严”的编码就需要三个字节。将&lt;code&gt;100111000100101&lt;/code&gt;填入上表中的&lt;code&gt;c&lt;/code&gt;位即可。因此，严的&lt;code&gt;UTF-8&lt;/code&gt;编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5. 比如我在谷歌搜索框里搜索“严”字，google发出的请求如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;https://www.google.com.hk/search?q=%E4%B8%A5&amp;amp;oq=%E4%B8%A5&amp;amp;aqs=chrome..69i57j0l5.3802j0j4&amp;amp;sourceid=chrome&amp;amp;ie=UTF-8&amp;amp;gws_rd=cr&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;q=%E4%B8%A5&lt;/code&gt;这个就是搜索的词了。&lt;/p&gt;
&lt;h2 id=&quot;重点向与负载均衡&quot;&gt;重点向与负载均衡&lt;/h2&gt;
&lt;p&gt;Web内容通常分散地分布在很多地方，这可以防止“单点故障”，万一某个地方发生地震了，机房被毁了，那还有其他地方的机房可以提供服务。所谓&lt;code&gt;狡兔三窟&lt;/code&gt;嘛。&lt;/p&gt;
&lt;p&gt;这样，用户的请求会根据&lt;code&gt;负载均衡&lt;/code&gt;的原则，被&lt;code&gt;重定向&lt;/code&gt;到它应该去的地方。&lt;/p&gt;
&lt;h3 id=&quot;http重定向&quot;&gt;HTTP重定向&lt;/h3&gt;
&lt;p&gt;服务器收到客户端请求后，向客户端返回一条带有状态码&lt;code&gt;302&lt;/code&gt;重定向的报文，告诉他们应该去其他的地方试试。web站点将重定向看成一种简单的负载均衡策略来使用，&lt;code&gt;重定向&lt;/code&gt;服务器找到可用的负载最小的机器，由于服务器知道客户端的地址，理论上来说，可以做到最优的重定向选择。&lt;/p&gt;
&lt;p&gt;当然，缺点也是显而易见的，由于客户端要发送两次请求，因此增加耗时。&lt;/p&gt;
&lt;h3 id=&quot;dns重定向&quot;&gt;DNS重定向&lt;/h3&gt;
&lt;p&gt;DNS将几个IP地址关联到一个域上，采用算法决定返回的IP地址。可以是简单的&lt;code&gt;轮转&lt;/code&gt;；也可以是更高级的算法，返回负载最轻的服务器的IP地址，称为&lt;code&gt;负载均衡算法&lt;/code&gt;；如果考虑地理位置，并返回给客户端最近位置的地址，称为&lt;code&gt;邻接路由算法&lt;/code&gt;；还有一种是绕过出现故障的地址，称为&lt;code&gt;故障屏蔽算法&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;DNS服务器总是会返回所有的IP地址，但是DNS客户端一般只会使用第一个IP地址，而且会缓存下来，之后会一直用这个地址。所以，DNS轮转通常不会平衡单个客户端的负载。但是，由于DNS服务器对于不同的请求，总是会返回轮转后的IP地址列表，因此，会把负载分散到多个客户端。&lt;/p&gt;
&lt;h2 id=&quot;http连接&quot;&gt;HTTP连接&lt;/h2&gt;
&lt;p&gt;HTTP连接是HTTP报文传输的关键通道。&lt;/p&gt;
&lt;h3 id=&quot;并行连接&quot;&gt;并行连接&lt;/h3&gt;
&lt;p&gt;对于一个页面上同时出现多个对象的时候，如果浏览器并行地打开多个连接，同时去获取这些对象，多个连接的TCP握手时延可以进行重叠，看起来速度会快起来。&lt;/p&gt;
&lt;p&gt;如一个包含3张图片的页面，浏览器要发送4次HTTP请求来获取页面。1个用于顶层的HTML页面，3个用于图片。如果采用串行方式，那么连接时延会进行叠加。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/50803988-0f213e80-1327-11e9-93d9-10339ee54864.png&quot; alt=&quot;串行连接&quot;/&gt;&lt;/p&gt;
&lt;p&gt;采用并行连接之后：&lt;br/&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/50803776-13992780-1326-11e9-8752-defd450ca639.png&quot; alt=&quot;并行连接&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是并行连接也不绝对提升速度，如果一个页面有数百个内嵌对象，那要启动数百个连接，对服务器的性能也是非常大的挑战。所以，通常浏览器会限制并行连接的总数据在一个较小的值，通常是4个，而且服务端可以随意关闭客户端超量的连接。&lt;/p&gt;
&lt;p&gt;另一方面，如果客户端网络带宽较小，每个连接都会去争抢有限的带宽，每个连接都会获取较小的速度，即每个对象都会以较小的速度去加载。这样，并行连接带来的速度提升就会比较小，甚至没有提升。&lt;/p&gt;
&lt;h3 id=&quot;持久连接&quot;&gt;持久连接&lt;/h3&gt;
&lt;p&gt;HTTP keep-alive机制&lt;/p&gt;
&lt;p&gt;我们知道HTTP请求是“请求-应答”模式，每次请求-应答都要新建一个连接，完成之后要断开连接。HTTP是无状态的，连接之间没有任何关系。&lt;/p&gt;
&lt;p&gt;HTTP是应用层协议，TCP是传输层协议。HTTP底层仍然采用TCP进行传输数据。TCP为HTTP提供了一层可靠的比特传输通道。HTTP一般交换的数据都不大，而每次连接都要进行TCP三次握手，很大一部分时间都消耗在这上面，有时候甚至能达到50%。如果能复用连接，就可以减少由于TCP三次握手所带来的时延。&lt;/p&gt;
&lt;p&gt;HTTP 1.1默认开启keep-alive机制，从上面抓到的包也可以看到。这样，数据传输完成之后保持TCP连接不断开，之后同域名下复用连接，继续用这个通道传输数据。服务器在响应一个请求后，可以保持这个连接keep-alive timeout的时间，在这个时间内没有请求，则关闭此连接；否则，重新开始倒计时keep-alive timeout时间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51286420-e4716d00-1a2d-11e9-9b95-79b1e0a1984a.png&quot; alt=&quot;http keep alive&quot;/&gt;&lt;/p&gt;
&lt;p&gt;HTTP有keep-alive机制，目的是可以在一个TCP&lt;br/&gt;连接上传输多个HTTP事务，以此提高通信效率。底层的TCP其实也有keep-alive机制，它是为了探测TCP连接的活跃性。TCP层的keepalive可以在任何一方设置，可以是一端设置、两端同时设置或者两端都没有设置。新建socket的时候需要设置，从而使得协议栈调用相关函数tcp_set_keepalive，来激活连接的keep-alive属性。&lt;/p&gt;
&lt;p&gt;当网络两端建立了TCP连接之后，闲置（双方没有任何数据流发送往来）时间超过&lt;code&gt;tcp_keepalive_time&lt;/code&gt;后，服务器内核就会尝试向客户端发送侦测包，来判断TCP连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(ack包)，则会在 &lt;code&gt;tcp_keepalive_intvl&lt;/code&gt;后再次尝试发送侦测包，直到收到对方的ack,如果一直没有收到对方的ack,一共会尝试 tcp_keepalive_probes次，每次的间隔时间在这里分别是15s, 30s, 45s, 60s, 75s。如果尝试&lt;code&gt;tcp_keepalive_probes&lt;/code&gt;次后,依然没有收到对方的ack包，则会丢弃该TCP连接。TCP连接默认闲置时间是2小时，一般设置为30分钟足够了。&lt;/p&gt;
&lt;h3 id=&quot;管道化连接&quot;&gt;管道化连接&lt;/h3&gt;
&lt;p&gt;在keep-alive的基础上，我们可以做地更进一步，在响应到达之前，我们将多条请求放入请求队列，服务端在收到请求后，必须按照顺序对应请求的响应。但由于网络环境非常复杂，因此即使请求是按顺序发送的，也不一定是按顺序到达服务端的。所以最好是在响应中附带一些可以标识请求的参数。&lt;/p&gt;
&lt;p&gt;为了安全起见，管道化的连接只适合“幂等”的请求，一般我们认为：GET/HEAD/PUT/DELETE/TRACE/OPTIONS等方法都是幂等的。&lt;/p&gt;

&lt;p&gt;以上，就是所有HTTP的通信细节了。其实比较简单，更多的细节可以在用到的时候再去仔细研究。&lt;/p&gt;
&lt;p&gt;不知道你对HTTP的理解有没有更上一层楼？欢迎一起交流探讨。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51325279-8bdeb600-1aa7-11e9-860d-2063fbae105b.png&quot; alt=&quot;wechat QR&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Jan 2019 14:44:00 +0000</pubDate>
<dc:creator>Stefno</dc:creator>
<og:description>本文将带领你深入二进制的天地，深入分析HTTP通信的所有细节！看完本文，相信你对HTTP的理解会上一个台阶！ 为了对网络数据包的“流转”有更加深刻的理解，我在docker（远程）上部署一个服务，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcrao-2018/p/10285348.html</dc:identifier>
</item>
<item>
<title>利用Topshelf把.NET Core Generic Host管理的应用程序部署为Windows服务 - Elder_James</title>
<link>http://www.cnblogs.com/ElderJames/p/Using-Topshelf-To-Deploy-Net-Core-Generic-Host-App-To-Windows-Services.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ElderJames/p/Using-Topshelf-To-Deploy-Net-Core-Generic-Host-App-To-Windows-Services.html</guid>
<description>&lt;p&gt;2019第一篇文章。&lt;/p&gt;
&lt;p&gt;此文源于前公司在迁移项目到.NET Core的过程中，希望使用Generic Host来管理定时任务程序时，没法部署到Windows服务的问题，而且官方也没给出解决方案，只能关注一下&lt;a href=&quot;https://github.com/aspnet/Extensions/issues/809&quot;&gt;官方issue #809&lt;/a&gt; 等他们方解决了。&lt;/p&gt;
&lt;p&gt;官方文档只提供了一个&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/windows-service?spm=a2c4e.11153940.blogcont676413.12.65753eb0BIzfmE&amp;amp;view=aspnetcore-2.1&quot;&gt;《在 Windows 服务中托管 ASP.NET Core》&lt;/a&gt;的方案，可以使用&lt;code&gt;Microsoft.AspNetCore.Hosting.WindowsServices&lt;/code&gt;类库来把Web应用部署为Windows服务。但是ASP.NET Core虽然是控制台程序，但是它本身是使用了含有HTTP管道的Web Host来负责应用程序的生命周期管理，用它来作为定时任务的话，会有很多不必要的工作负载，例如占用端口、增加了很多依赖等等。&lt;/p&gt;
&lt;p&gt;官方意识到这个问题之后，在.NET Core 2.1版本新增了Generic Host通用主机，剥离了原来WebHost的Http管道相关的API，源码中可以发现Web Host已经基于Generic Host实现。它才是作为纯粹定时任务程序的最佳拍档。&lt;/p&gt;
&lt;p&gt;但是由于Generic Host本身非常简单，用它运行的程序设置在注册为Windows服务启动之后会自动停止。研究很久之后才知道，想在Windows上启动服务，还是不能像Linux上那么简单——&lt;/p&gt;
&lt;p&gt;于是尝试结合Topshelf来创建Windows服务，最终成功了。&lt;/p&gt;
&lt;h2 id=&quot;实现方法&quot;&gt;实现方法&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;先实现&lt;code&gt;IHostLifetime&lt;/code&gt;接口来接管应用程序的生命周期，其实就是用空的实现来替换掉默认的ConsoleLifetime，这样就可以在之后由Topshelf框架内部去管理生命周期。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    internal class TopshelfLifetime : IHostLifetime
    {
        public TopshelfLifetime(IApplicationLifetime applicationLifetime, IServiceProvider services)
        {
            ApplicationLifetime = applicationLifetime ?? throw new ArgumentNullException(nameof(applicationLifetime));
        }

        private IApplicationLifetime ApplicationLifetime { get; }

        public Task WaitForStartAsync(CancellationToken cancellationToken)
        {
            return Task.CompletedTask;
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            return Task.CompletedTask;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;然后实现&lt;code&gt;IHostedService&lt;/code&gt;接口，把后台任务逻辑写到&lt;code&gt;StartAsync&lt;/code&gt;方法中，参见官方文档&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-2.1#ihostedservice-interface&quot;&gt;《在 ASP.NET Core 中使用托管服务实现后台任务》&lt;/a&gt;，本文示例使用定时写入文本到一个文件来测试定时任务是否成功运行。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    internal class FileWriterService : IHostedService, IDisposable
    {
        private static string path = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, @&quot;test.txt&quot;);

        private Timer _timer;

        public Task StartAsync(CancellationToken cancellationToken)
        {
            if (cancellationToken.IsCancellationRequested) return Task.FromCanceled(cancellationToken);

            _timer = new Timer(
                (e) =&amp;gt; WriteTimeToFile(),
                null,
                TimeSpan.Zero,
                TimeSpan.FromSeconds(10));

            return Task.CompletedTask;
        }

        public void WriteTimeToFile()
        {
            if (!File.Exists(path))
            {
                using (var sw = File.CreateText(path))
                {
                    sw.WriteLine(DateTime.Now);
                }
            }
            else
            {
                using (var sw = File.AppendText(path))
                {
                    sw.WriteLine(DateTime.Now);
                }
            }
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            _timer?.Change(Timeout.Infinite, 0);

            return Task.CompletedTask;
        }

        public void Dispose()
        {
            _timer?.Dispose();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;构建Generic Host，在&lt;code&gt;ConfigureServices&lt;/code&gt;方法中注册&lt;code&gt;TopshelfLifetime&lt;/code&gt;，并且注册一个托管服务&lt;code&gt;FileWriterService&lt;/code&gt;，就能完成Generic Host的简单构建，当然完整的项目应该还包含配置、日志等等。最后，使用Topshelf来接管Generic Host，创建Windows服务。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    internal class Program
    {
        private static void Main(string[] args)
        {
            var builder = new HostBuilder()
                .ConfigureServices((hostContext, services) =&amp;gt;
                {
                    services.AddSingleton&amp;lt;IHostLifetime, TopshelfLifetime&amp;gt;();
                    services.AddHostedService&amp;lt;FileWriterService&amp;gt;();
                });

            HostFactory.Run(x =&amp;gt;
            {
                x.SetServiceName(&quot;GenericHostWindowsServiceWithTopshelf&quot;);
                x.SetDisplayName(&quot;Topshelf创建的Generic Host服务&quot;);
                x.SetDescription(&quot;运行Topshelf创建的Generic Host服务&quot;);

                x.Service&amp;lt;IHost&amp;gt;(s =&amp;gt;
                {
                    s.ConstructUsing(() =&amp;gt; builder.Build());
                    s.WhenStarted(service =&amp;gt;
                    {
                        service.Start();
                    });
                    s.WhenStopped(service =&amp;gt;
                    {
                        service.StopAsync();
                    });
                });
            });
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;最后发布应用程序，并安装到Windows服务。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;以管理员权限开启终端，执行命令：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;  dotnet publish -c release -r win-x64
  
  cd path-to-project/bin/release/netcoreapp2.1/win-x64/publish

  ./project-name install

  net start GenericHostWindowsServiceWithTopshelf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://yangshunjie.com/images/generic-host/generic-host-install.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样这个Windows服务就启动了！查看输出文件，可以看到定时写入成功，服务也一直没关闭~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://yangshunjie.com/images/generic-host/generic-host-result.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例代码&quot;&gt;示例代码&lt;/h2&gt;
&lt;p&gt;https://github.com/ElderJames/GenericHostWindowsServiceWithTopshelf&lt;/p&gt;
&lt;h2 id=&quot;参考链接&quot;&gt;参考链接&lt;/h2&gt;
&lt;p&gt;官方文档&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/generic-host?view=aspnetcore-2.1&quot;&gt;《.NET 通用主机》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方文档&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-2.1&quot;&gt;《在 ASP.NET Core 中使用托管服务实现后台任务》&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 17 Jan 2019 14:34:00 +0000</pubDate>
<dc:creator>Elder_James</dc:creator>
<og:description>背景 2019第一篇文章。 此文源于前公司在迁移项目到.NET Core的过程中，希望使用Generic Host来管理定时任务程序时，没法部署到Windows服务的问题，而且官方也没给出解决方案，只</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ElderJames/p/Using-Topshelf-To-Deploy-Net-Core-Generic-Host-App-To-Windows-Services.html</dc:identifier>
</item>
<item>
<title>ML.NET 0.9特性简介 - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10284906.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10284906.html</guid>
<description>&lt;p&gt;ML.NET 0.9已于上周发布，距离上次0.8版本的发布只有一个多月，此次增加的新特性主要包括特征贡献计算，模型可解释性增强，ONNX转换对GPU的支持，Visual Studio ML.NET项目模板预览，以及API改进。&lt;/p&gt;

&lt;p&gt;特征贡献计算(Feature Contribution Calculation)通过决定每个特征对模型分数的贡献，从而显示哪些特征在对特别个体的数据样本的模型预测最有影响力。&lt;/p&gt;
&lt;p&gt;当你面临历史数据中有许多特征时而又想选择使用最重要的特征时，特征贡献计算显得十分重要。因为使用太多的特征(尤其是包含对模型没有影响的特征)会减少模型的性能与准确性。因此，使用特征贡献计算你可以从原始特征集中识别最有影响力的正向与负向的贡献。&lt;/p&gt;
&lt;p&gt;示例代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;// 创建特征贡献计算器
// 对已有训练模型参数的所有特征进行计算贡献

var featureContributionCalculator = mlContext.Model.Explainability.FeatureContributionCalculation(model.Model, model.FeatureColumn, numPositiveContributions: 11, normalize: false);

// FeatureContributionCalculatingEstimator可被用作管道中的一个步骤
// 被FeatureContributionCalculatingEstimator保存的特征将在FeatureContribution列中

var pipeline = mlContext.Model.Explainability.FeatureContributionCalculation(model.Model, model.FeatureColumn, numPositiveContributions: 11)
    .Append(mlContext.Regression.Trainers.OrdinaryLeastSquares(featureColumn: &quot;FeatureContributions&quot;));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果可下：&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;The output of the above code is:

  Label   Score   BiggestFeature         Value   Weight   Contribution

  24.00   27.74   RoomsPerDwelling        6.58    98.55   39.95
  21.60   23.85   RoomsPerDwelling        6.42    98.55   39.01
  34.70   29.29   RoomsPerDwelling        7.19    98.55   43.65
  33.40   27.17   RoomsPerDwelling        7.00    98.55   42.52&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;除了特征贡献计算之外，排列特征重要性(PFI)与广义加性模型(GAM)也有加强。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;排列特征重要性支持大多数学习任务：回归，二元分类，多元分类与排序。&lt;/li&gt;
&lt;li&gt;排列特征重要性允许你在特征重要性分数上计算置信区间，以便可以得到更好的平均值估计。&lt;/li&gt;
&lt;li&gt;广义加性模型支持特征贡献计算，以便你可以迅速看到哪些特征驱动个体的预测。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201901/991496-20190117214901389-1936956853.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在ML.NET 0.9中通过集成高性能的ONNX运行时库添加了使用激活GPU的CUDA 10.0运行ONNX模型的功能。ONNX模型的GPU支持现在已经可以在Windows 64位系统上使用，不久之后将支持Linux与Mac系统。&lt;/p&gt;

&lt;p&gt;Visual Studio项目模板现在推出了支持ML.NET的预览版本。&lt;a href=&quot;https://aka.ms/mlnettemplates&quot;&gt;下载地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/991496/201901/991496-20190117222511934-2105582242.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板涵盖以下场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ML.NET控制台应用程序&lt;/li&gt;
&lt;li&gt;ML.NET模型类库&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;简化文本数据加载&quot;&gt;简化文本数据加载&lt;/h2&gt;
&lt;p&gt;ML.NET 0.9以前你需要显示的标明列名：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var mlContext = new MLContext();

var reader = mlContext.Data.CreateTextReader(new[] {
        new TextLoader.Column(&quot;IsOver50K&quot;, DataKind.BL, 0),
        new TextLoader.Column(&quot;Workclass&quot;, DataKind.TX, 1)
    },hasHeader: true
);
var dataView = reader.Read(dataPath);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在你可以直接使用泛型：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;var mlContext = new MLContext();

var dataView = mlContext.Data.ReadFromTextFile&amp;lt;InspectedRow&amp;gt;(dataPath, hasHeader: true);

private class InspectedRow
{
    [LoadColumn(0)]
    public bool IsOver50K { get; set; }
    [LoadColumn(1)]
    public string Workclass { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;获取预测置信因子&quot;&gt;获取预测置信因子&lt;/h2&gt;
&lt;p&gt;通过Calibrator Estimators，除了在评估模型质量时可以获得分数列之外，还可以得到置信因子。&lt;/p&gt;
&lt;p&gt;例如，你可以获得每个预测值的概率：&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;Score - 0.458968    Probability 0.4670409
Score - 0.7022135   Probability 0.3912723
Score 1.138822      Probability 0.8703266&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;新的键-值匹配估测器及转换&quot;&gt;新的键-值匹配估测器及转换&lt;/h2&gt;
&lt;p&gt;新特性替换了TermLookupTransform，同时提供了指定值之间匹配的新方法。你可以指定键列与值列的匹配关系，但需保证两者数量一致。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;允许ML.NET在Windows Nano容器及Windows机器上运行，而无需安装Visual C++运行时。&lt;/li&gt;
&lt;li&gt;在包含模型信息的DataView构造器中提供元数据支持，比如被编码为元数据的评估指标可以通过代码解析出来，由此能够使用任何工具进行可视化。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Thu, 17 Jan 2019 14:29:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>ML.NET 0.9已于上周发布，距离上次0.8版本的发布只有一个多月，此次增加的新特性主要包括特征贡献计算，模型可解释性增强，ONNX转换对GPU的支持，Visual Studio ML.NET项目</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10284906.html</dc:identifier>
</item>
</channel>
</rss>