<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Rasa init报错：AttributeError: type object 'Callable' has no attribute '_abc_registry' - 君君姐</title>
<link>http://www.cnblogs.com/WMT-Azura/p/12914821.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/WMT-Azura/p/12914821.html</guid>
<description>[unable to retrieve full-text content]错误：Rasa init --no-prompt 报错 原因：Python升级到3.7后会遇到该问题 解决：pip uninstall typing</description>
<pubDate>Tue, 19 May 2020 00:51:00 +0000</pubDate>
<dc:creator>君君姐</dc:creator>
<og:description>错误：Rasa init --no-prompt 报错 原因：Python升级到3.7后会遇到该问题 解决：pip uninstall typing</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/WMT-Azura/p/12914821.html</dc:identifier>
</item>
<item>
<title>重学数据结构之哈夫曼树 - TM0831</title>
<link>http://www.cnblogs.com/TM0831/p/12904855.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TM0831/p/12904855.html</guid>
<description>&lt;h2&gt;一、哈夫曼树&lt;/h2&gt;
&lt;h3&gt;1.带权扩充二叉树的外部路径长度&lt;/h3&gt;
&lt;p&gt;　　扩充二叉树的外部路径长度，即根到其叶子节点的路径长度之和。&lt;/p&gt;
&lt;p&gt;　　例如下面这两种带权扩充二叉树：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/1450803/202005/1450803-20200517123905680-1548923099.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　左边的二叉树的外部路径长度为：(2 + 3 + 6 + 9) * 2 = 38。&lt;/p&gt;
&lt;p&gt;　　右边的二叉树的外部路径长度为：9 + 6 * 2 + (2 + 3) * 3 = 36。&lt;/p&gt;
&lt;h3&gt;2.哈夫曼树&lt;/h3&gt;
&lt;p&gt;　　哈夫曼树（Huffman Tree）是一种重要的二叉树，在信息领域有重要的理论和实际价值。&lt;/p&gt;
&lt;p&gt;　　设有实数集 W = {&lt;span&gt;W&lt;/span&gt;&lt;sub&gt;&lt;span&gt;0&lt;/span&gt;&lt;/sub&gt; ，&lt;span&gt;W&lt;/span&gt;&lt;sub&gt;&lt;span&gt;1&lt;/span&gt;&lt;/sub&gt; ，···，&lt;span&gt;W&lt;/span&gt;&lt;sub&gt;&lt;span&gt;m-1&lt;/span&gt;&lt;/sub&gt; }，T 是一颗扩充二叉树，其 m 个外部节点分别以 &lt;span&gt;W&lt;/span&gt;&lt;sub&gt;&lt;span&gt;i&lt;/span&gt;&lt;/sub&gt; (i = 1, 2, n - 1) 为权，而且 T 的带权外部路径长度在所有这样的扩充二叉树中达到最小，则称 T 为数据集 W 的最优二叉树或者哈夫曼树。&lt;/p&gt;

&lt;h2&gt;二、哈夫曼算法&lt;/h2&gt;
&lt;h3&gt;1.基本概念&lt;/h3&gt;
&lt;p&gt;　　哈夫曼（D.A.Huffman）提出了一个算法，它能从任意的实数集合构造出与之对应的哈夫曼树。这个构造算法描述如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;算法的输入为实数集合 W = {&lt;span&gt;W&lt;/span&gt;&lt;sub&gt;&lt;span&gt;0&lt;/span&gt;&lt;/sub&gt; ，&lt;span&gt;W&lt;/span&gt;&lt;sub&gt;&lt;span&gt;1&lt;/span&gt;&lt;/sub&gt; ，···，&lt;span&gt;W&lt;/span&gt;&lt;sub&gt;&lt;span&gt;m-1&lt;/span&gt;&lt;/sub&gt; }。&lt;/li&gt;
&lt;li&gt;在构造中维护一个包含 k 个二叉树集合的集合 F，开始时k = m 且 F = {T&lt;sub&gt;&lt;span&gt;0&lt;/span&gt;&lt;/sub&gt; ，T&lt;sub&gt;&lt;span&gt;1&lt;/span&gt;&lt;/sub&gt; ，···，T&lt;sub&gt;&lt;span&gt;m-1&lt;/span&gt;&lt;/sub&gt; }，其中每个 T&lt;sub&gt;&lt;span&gt;i&lt;/span&gt;&lt;/sub&gt; 是一颗只包含权为 &lt;span&gt;W&lt;/span&gt;&lt;sub&gt;&lt;span&gt;i&lt;/span&gt;&lt;/sub&gt; 的根节点的二叉树。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　该算法的构造过程中会重复执行以下两个步骤，直到集合 F 中只剩下一棵树为止：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构造一颗二叉树，其左右子树是从集合 F 中选取的两颗权值最小的二叉树，其根节点的权值设置为这两颗子树的根节点的权值之和。&lt;/li&gt;
&lt;li&gt;将所选取的两颗二叉树从集合 F 中删除，把新构造的二叉树加入到集合 F 中。　&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　&lt;strong&gt;注意&lt;/strong&gt;：给定集合 W 上的哈夫曼树并不唯一！&lt;/p&gt;
&lt;h3&gt;2.示例&lt;/h3&gt;
&lt;p&gt;　　对于实数集合 W = {2, 1, 3, 7, 8, 4, 5}，下面的图1到图7表示了从这个实数集合开始，构造一个哈夫曼树的过程：&lt;/p&gt;
&lt;p&gt;　　图1：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1450803/202005/1450803-20200517213236288-782012796.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　图2：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1450803/202005/1450803-20200517213221996-1604480471.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 　　图3：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1450803/202005/1450803-20200517213210590-444195464.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图4： 　　&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1450803/202005/1450803-20200517213153910-1194988725.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图5： &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1450803/202005/1450803-20200517213139762-551257095.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图6： &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1450803/202005/1450803-20200517213119524-1680002691.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　图7： &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1450803/202005/1450803-20200517213058123-1572566694.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;三、哈夫曼算法的实现&lt;/h2&gt;
&lt;h3&gt;1.实现思路&lt;/h3&gt;
&lt;p&gt;　　要实现哈夫曼算法，需要维护一组二叉树，而且要知道每颗二叉树的根节点的权值 ，这个可以使用前面定义的二叉树的节点来构造哈夫曼树，只需要在根节点处记录该树的权值。而在执行算法时&lt;/p&gt;
&lt;p&gt;　　在算法开始时，需要根据传入的实数集和来创建一组单节点的二叉树，并以权值作为其优先级存入一个优先级队列之中，在之后的过程中反复执行以下两步，直至队列中只有一颗二叉树：&lt;/p&gt;
&lt;p&gt;　　1）从该优先级队列中取出两颗权值最小的二叉树；&lt;/p&gt;
&lt;p&gt;　　2）创建一颗新的二叉树，其权值为选出的两棵树的权值之和，其左右子树分别为选出的两颗树，并将创建好的二叉树加入到优先级队列中。&lt;/p&gt;
&lt;p&gt;　　当整个优先级队列中只剩下一颗二叉树的时候，就得到我们需要的哈夫曼树了。&lt;/p&gt;
&lt;h3&gt;2.实现代码&lt;/h3&gt;
&lt;p&gt;　　首先是要对哈夫曼树的节点进行定义，主要是增加一个权值，定义哈夫曼树节点的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 哈夫曼树节点&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HNode(Node):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, value=None, left=None, right=None, weight=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         super(HNode, self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         self.value =&lt;span&gt; value
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         self.left =&lt;span&gt; left
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;         self.right =&lt;span&gt; right
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         self.weight = weight
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后还需要一个优先级的队列，在我前面写过的一篇队列的博客中有提到，只不过那篇博客里的优先级队列用的是一个最大堆，而在这里需要用最小堆，这样每次才能取出权值最小的树。&lt;/p&gt;
&lt;p&gt;　　最后，下面就是实现哈夫曼算法的主要代码了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; create(weights: list):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    根据传入的权值列表创建一个哈夫曼树
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    :param weights: 实数集合
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     queue =&lt;span&gt; PriorityQueue()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将节点添加到优先级队列中&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; weight &lt;span&gt;in&lt;/span&gt;&lt;span&gt; weights:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         node = HNode(weight=&lt;span&gt;weight)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        queue.enqueue(node, weight)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; queue.size() &amp;gt; 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         node1 =&lt;span&gt; queue.dequeue()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         node2 =&lt;span&gt; queue.dequeue()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         new_node = HNode(left=node1, right=node2, weight=node1.weight +&lt;span&gt; node2.weight)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        queue.enqueue(new_node, new_node.weight)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; queue.dequeue()
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;四、哈夫曼编码问题&lt;/h2&gt;
&lt;h3&gt;1.问题描述 &lt;/h3&gt;
&lt;p&gt;　　最优编码问题，给定两个集合 C 和 W，C 为基本数据集合，W 为 C 中各个字符在实际信息传递中使用的频率，要求设定一套编码规则，要求： 1）使用这种编码规则的开销最小； 2）对任意一对不同字符 Ci 和 Cj，要求 Ci 的编码不是 Cj 编码的前缀。&lt;/p&gt;
&lt;h3&gt;2.问题分析&lt;/h3&gt;
&lt;p&gt;　　使用哈夫曼算法构建一颗哈夫曼树，这棵树的叶子节点的数量和字符数量一致，叶子节点的值就是字符的值，叶子节点的权值就是该字符对应的使用频率。然后从根节点开始遍历，往左子树遍历时标记为0，往右子树遍历时标记为1，这样就能保证走到叶子节点时所标记的路径结果是不一样的了，最后将每个叶子节点的值和对应的标记结果返回，就是题目所求的最优编码。&lt;/p&gt;
&lt;p&gt;　　例如输入的数据为：{&quot;A&quot;: 2, &quot;b&quot;: 3, &quot;c&quot;: 5, &quot;d&quot;: 6, &quot;e&quot;: 9} 。&lt;/p&gt;
&lt;p&gt;　　则构造出来的哈夫曼树如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1450803/202005/1450803-20200517222234874-886312990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　最后得到的编码为：{&quot;A&quot;: &quot;000&quot;, &quot;b&quot;: &quot;001&quot;, &quot;c&quot;: &quot;01&quot;, &quot;d&quot;: &quot;10&quot;, &quot;e&quot;: &quot;11&quot;} &lt;/p&gt;
&lt;h3&gt;3.代码实现&lt;/h3&gt;
&lt;p&gt;　　下面就是使用哈夫曼算法来求解编码问题的主要代码了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Tree.tree &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Node
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; Queue.queue &lt;span&gt;import&lt;/span&gt;&lt;span&gt; PriorityQueue
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 哈夫曼树节点&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HNode(Node):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, value=None, left=None, right=None, weight=&lt;span&gt;None):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         super(HNode, self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         self.value =&lt;span&gt; value
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         self.left =&lt;span&gt; left
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         self.right =&lt;span&gt; right
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         self.weight =&lt;span&gt; weight
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 自定义哈夫曼树&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HuffmanTree:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         self.root =&lt;span&gt; HNode()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         self.code =&lt;span&gt; {}
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_leaves(self, node: HNode, code: str):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        获取所有叶节点，对树中的分支节点向左子节点的路径标记为0，向右子节点的路径标记为1
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        :param node: 哈夫曼树的节点
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        :param code: 字符使用的编码
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        :return:
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; node:
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         code_ = code  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因为要分别向左向右探索路径，所以需要复制一份&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; node.left:
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;             code += &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            self.get_leaves(node.left, code)
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; node.right:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             code_ += &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            self.get_leaves(node.right, code_)
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 没有左右子节点，表明是叶子节点&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; node.left &lt;span&gt;and&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; node.right:
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             self.code[node.value] =&lt;span&gt; code
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; create(self, char_data: dict):
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        根据传入的权值列表创建一个哈夫曼树
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        :param char_data: 字符和其对应频率的字典
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         queue =&lt;span&gt; PriorityQueue()
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将节点添加到优先级队列中&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; char, weight &lt;span&gt;in&lt;/span&gt;&lt;span&gt; char_data.items():
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             node = HNode(value=char, weight=&lt;span&gt;weight)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            queue.enqueue(node, weight)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; queue.size() &amp;gt; 1&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             node1 =&lt;span&gt; queue.dequeue()
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             node2 =&lt;span&gt; queue.dequeue()
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             new_node = HNode(left=node1, right=node2, weight=node1.weight +&lt;span&gt; node2.weight)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            queue.enqueue(new_node, new_node.weight)
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         self.root =&lt;span&gt; queue.dequeue()
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; solution(char_data: dict):
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    解决哈夫曼编码问题
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;    :param char_data: 字符和其对应频率的字典
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; &lt;span&gt;    :return:
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;     tree =&lt;span&gt; HuffmanTree()
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;    tree.create(char_data)
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     tree.get_leaves(tree.root, &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; tree.code
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Tue, 19 May 2020 00:47:00 +0000</pubDate>
<dc:creator>TM0831</dc:creator>
<og:description>一、哈夫曼树 1.带权扩充二叉树的外部路径长度 扩充二叉树的外部路径长度，即根到其叶子节点的路径长度之和。 例如下面这两种带权扩充二叉树： 左边的二叉树的外部路径长度为：(2 + 3 + 6 + 9)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/TM0831/p/12904855.html</dc:identifier>
</item>
<item>
<title>（Python基础教程之二十二）爬虫下载网页视频(video blob) - 分布式编程</title>
<link>http://www.cnblogs.com/daichangya/p/12914789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/daichangya/p/12914789.html</guid>
<description>&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B&quot;&gt;Python基础教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/%E5%9C%A8sublimeeditor%E4%B8%AD%E9%85%8D%E7%BD%AEpython%E7%8E%AF%E5%A2%83&quot;&gt;在SublimeEditor中配置Python环境&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%BB%A3%E7%A0%81%E4%B8%AD%E6%B7%BB%E5%8A%A0%E6%B3%A8%E9%87%8A&quot;&gt;Python代码中添加注释&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8&quot;&gt;Python中的变量的使用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&quot;&gt;Python中的数据类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97&quot;&gt;Python中的关键字&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C&quot;&gt;Python字符串操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E7%9A%84list%E6%93%8D%E4%BD%9C&quot;&gt;Python中的list操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E7%9A%84tuple%E6%93%8D%E4%BD%9C&quot;&gt;Python中的Tuple操作&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/pythonmax%E5%92%8Cmin%E5%9C%A8%E5%88%97%E8%A1%A8%E6%88%96%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC%E5%92%8C%E6%9C%80%E5%B0%8F%E5%80%BC&quot;&gt;Pythonmax（）和min（）–在列表或数组中查找最大值和最小值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E6%89%BE%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%B8%AA%E5%89%8Dn%E4%B8%AA%E6%88%96%E6%9C%80%E5%B0%8F%E7%9A%84n%E4%B8%AA%E9%A1%B9%E7%9B%AE&quot;&gt;Python找到最大的N个（前N个）或最小的N个项目&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E8%AF%BB%E5%86%99csv%E6%96%87%E4%BB%B6&quot;&gt;Python读写CSV文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E4%BD%BF%E7%94%A8httplib2httpget%E5%92%8Cpost%E7%A4%BA%E4%BE%8B&quot;&gt;Python中使用httplib2–HTTPGET和POST示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E5%B0%86tuple%E5%BC%80%E7%AE%B1%E4%B8%BA%E5%8F%98%E9%87%8F%E6%88%96%E5%8F%82%E6%95%B0&quot;&gt;Python将tuple开箱为变量或参数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E5%BC%80%E7%AE%B1tuple%E5%A4%AA%E5%A4%9A%E5%80%BC%E6%97%A0%E6%B3%95%E8%A7%A3%E5%8E%8B&quot;&gt;Python开箱Tuple–太多值无法解压&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/pythonmultidict%E7%A4%BA%E4%BE%8B%E5%B0%86%E5%8D%95%E4%B8%AA%E9%94%AE%E6%98%A0%E5%B0%84%E5%88%B0%E5%AD%97%E5%85%B8%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E5%80%BC&quot;&gt;Pythonmultidict示例–将单个键映射到字典中的多个值&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/pythonordereddict%E6%9C%89%E5%BA%8F%E5%AD%97%E5%85%B8&quot;&gt;PythonOrderedDict–有序字典&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E5%AD%97%E5%85%B8%E4%BA%A4%E9%9B%86%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%AD%97%E5%85%B8&quot;&gt;Python字典交集–比较两个字典&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97%E7%A4%BA%E4%BE%8B&quot;&gt;Python优先级队列示例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/python%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F&quot;&gt;python中如何格式化日期&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/30%E5%88%86%E9%92%9Fpython%E7%88%AC%E8%99%AB%E6%95%99%E7%A8%8B&quot;&gt;30 分钟 Python 爬虫教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zthinker.com/archives/htmlvideoblob%E8%A7%86%E9%A2%91%E4%B8%8B%E8%BD%BD&quot;&gt;爬虫下载网页视频(video blob)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;现在视频链接一般为m3u8,找到m3u8地址就可以下载了&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开Chrome Developer工具，然后点击“网络”标签。&lt;/li&gt;
&lt;li&gt;导航到包含视频的页面，然后开始播放。&lt;/li&gt;
&lt;li&gt;将文件列表过滤为“ m3u8”。&lt;/li&gt;
&lt;li&gt;找到master.m3u8或index.m3u8并单击它。&lt;/li&gt;
&lt;li&gt;将文件保存到磁盘并在其中查看。&lt;/li&gt;
&lt;li&gt;如果文件包含一个m3u8主URL，则复制该URL。&lt;/li&gt;
&lt;li&gt;使用ffmpeg 工具下载m3u8视频&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;ffmpeg -i &quot;https://secure.brightcove.com/services/mobile/streaming/index/rendition.m3u8?assetId=6138283938001&amp;amp;secure=true&amp;amp;videoId=6138277786001&quot; -bsf:a aac_adtstoasc -vcodec copy -c copy -crf 50 6138277786001.mp4
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Python下载代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/env python3
import requests,urllib
from bs4 import BeautifulSoup
import os
import subprocess

pwd = os.path.split(os.path.realpath(__file__))[0]

url = &quot;https://www.topgear.com/videos&quot;

headers = {
    'upgrade-insecure-requests': &quot;1&quot;,
    'user-agent': &quot;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.77 Safari/537.36&quot;,
    'accept': &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&quot;,
    'accept-encoding': &quot;gzip, deflate, br&quot;,
    'accept-language': &quot;zh-CN,zh;q=0.9,en;q=0.8&quot;,
    'cookie': &quot;has_js=1; minVersion={\&quot;experiment\&quot;:1570672462,\&quot;minFlavor\&quot;:\&quot;new_vermi-1.13.7.11.js100\&quot;}; minUniq=%7B%22minUID%22%3A%22bb80328a30-e8cdeb4d55-9a314411d2-aff4bb11a6-4aa23e3779%22%7D; minDaily=%7B%22testMode%22%3Atrue%2C%22dailyUser%22%3Atrue%7D; __gads=ID=b6eee23a8df86f72:T=1588041695:S=ALNI_MYCQR1Bf2fq53bqISIZBy8kIgI9oA; minBuffer=%7B%22minAnalytics%22%3A%22%7B%5C%22clicks%5C%22%3A%5B%5D%2C%5C%22clicksDelay%5C%22%3A%5B%5D%7D%22%2C%22_minEE1%22%3A%22%5B%5D%22%7D; minSession=%7B%22minSID%22%3A%227f32fd50ab-88cc4cf6f3-68d284cdee-1faeb65c08-c5966d76ac%22%2C%22minSessionSent%22%3Atrue%2C%22hadImp%22%3Atrue%2C%22sessionUniqs%22%3A%22%7Btime%3A1588053248571%2Clist%3A%5B11206251nt0%5D%7D%22%7D; OptanonConsent=landingPath=NotLandingPage&amp;amp;datestamp=Tue+Apr+28+2020+13%3A55%3A33+GMT%2B0800+(%E4%B8%AD%E5%9B%BD%E6%A0%87%E5%87%86%E6%97%B6%E9%97%B4)&amp;amp;version=3.6.24&amp;amp;AwaitingReconsent=false&amp;amp;groups=1%3A1%2C101%3A0%2C2%3A0%2C0_132429%3A0%2C3%3A0%2C4%3A0%2C0_132431%3A0%2C104%3A0%2C106%3A0%2C111%3A0%2C114%3A0%2C120%3A0%2C124%3A0%2C126%3A0%2C130%3A0%2C133%3A0%2C134%3A0%2C144%3A0%2C145%3A0%2C146%3A0%2C147%3A0%2C150%3A0%2C151%3A0%2C157%3A0%2C162%3A0%2C173%3A0%2C0_126679%3A0%2C0_137695%3A0%2C0_132361%3A0%2C0_132391%3A0; GED_PLAYLIST_ACTIVITY=W3sidSI6Ijh5clQiLCJ0c2wiOjE1ODgwNTMzNDksIm52IjowLCJ1cHQiOjE1ODgwNTMzMzMsImx0IjoxNTg4MDUzMzM3fV0.&quot;,
    'cache-control': &quot;no-cache&quot;}

if __name__ == '__main__':
    response = requests.request(&quot;GET&quot;, url, headers=headers)
    soup = BeautifulSoup(response.text, 'html.parser')
    videoId = soup.find_all('video', class_=&quot;video-js&quot;)[0]['data-video-id'] ##获取视频Id
    title = soup.find_all('h1', class_=&quot;video-player__title&quot;)[0].contents[0] ##获取视频标题
    url = &quot;https://secure.brightcove.com/services/mobile/streaming/index/master.m3u8?videoId={}&amp;amp;secure=true&quot;.format(videoId)  ##生成视频下载Url
    filename = '{}.mp4'.format(title).replace(&quot; &quot;,&quot;-&quot;)
    cmd_str = 'ffmpeg -i \&quot;' + url + '\&quot; ' + '-acodec copy -vcodec copy -absf aac_adtstoasc ' + pwd + &quot;/&quot; +filename  ##下载视频
    print(cmd_str)
    subprocess.call(cmd_str,shell=True)
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 19 May 2020 00:42:00 +0000</pubDate>
<dc:creator>分布式编程</dc:creator>
<og:description>1. &amp;quot;Python基础教程&amp;quot; 2. &amp;quot;在SublimeEditor中配置Python环境&amp;quot; 3. &amp;quot;Python代码中添加注释&amp;quot; 4. &amp;</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/daichangya/p/12914789.html</dc:identifier>
</item>
<item>
<title>一文带你学会国产加密算法SM4的vue实现方案 - 经典鸡翅</title>
<link>http://www.cnblogs.com/jichi/p/12913768.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jichi/p/12913768.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;上篇文章我们介绍了国产SM4加密算法的后端java实现方案。没有看过的小伙伴可以看一下这篇文章。&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/jichi/p/12913768.html&quot;&gt;https://www.cnblogs.com/jichi/p/12907453.html&lt;/a&gt;&lt;br/&gt;本篇文章将介绍前端vue的解决方案，和java后端互相辉映。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200518225213312-1732416561.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;说起前端的vue，真的是一个非常好用的框架，vue也是现在web项目的主流前端开发方案。所以基于vue的sm4加密实现方案是十分有必要掌握的。&lt;/p&gt;
&lt;h3 id=&quot;国产sm4加密解密算法概念介绍&quot;&gt;国产SM4加密解密算法概念介绍&lt;/h3&gt;
&lt;p&gt;SMS4算法是在国内广泛使用的WAPI无线网络标准中使用的加密算法，是一种32轮的迭代非平衡Feistel结构的分组加密算法，其密钥长度和分组长度均为128。SMS4算法的加解密过程中使用的算法是完全相同的，唯一不同点在于该算法的解密密钥是由它的加密密钥进行逆序变换后得到的。&lt;br/&gt;SMS4分组加密算法是中国无线标准中使用的分组加密算法，在2012年已经被国家商用密码管理局确定为国家密码行业标准，标准编号GM/T 0002-2012并且改名为SM4算法，与SM2椭圆曲线公钥密码算法，SM3密码杂凑算法共同作为国家密码的行业标准，在我国密码行业中有着极其重要的位置。&lt;br/&gt;SMS4算法的分组长度为128bit，密钥长度也是128bit。加解密算法均采用32轮非平衡Feistel迭代结构，该结构最先出现在分组密码LOKI的密钥扩展算法中。SMS4通过32轮非线性迭代后加上一个反序变换，这样只需要解密密钥是加密密钥的逆序，就能使得解密算法与加密算法保持一致。SMS4加解密算法的结构完全相同，只是在使用轮密钥时解密密钥是加密密钥的逆序。&lt;br/&gt;S盒是一种利用非线性变换构造的分组密码的一个组件，主要是为了实现分组密码过程中的混淆的特性和设计的。SMS4算法中的S盒在设计之初完全按照欧美分组密码的设计标准进行，它采用的方法是能够很好抵抗差值攻击的仿射函数逆映射复合法。&lt;/p&gt;
&lt;h3 id=&quot;sm4加密算法应用场景&quot;&gt;SM4加密算法应用场景&lt;/h3&gt;
&lt;p&gt;SM4常用于政府系统的数据传输加密，比如当我们前端向后台传参数的时候，可以使用此算法。对参数的数据进行加密，然后后台对加密的数据进行解密再存储到数据库中，保证数据传输过程中，不受泄露。&lt;br/&gt;本次提供的方案不仅提供sm4的加密解密，还提供了md5算法的完整性防篡改校验。&lt;/p&gt;
&lt;h3 id=&quot;vue的加密方案实现流程&quot;&gt;vue的加密方案实现流程&lt;/h3&gt;
&lt;p&gt;针对于我们的前端vue来说，我们通过axios来进行请求和响应，在我们vue的项目中，必然有一个request.js文件，用于封装request和respone。那么我们通过sm4的工具类。拦截所有的request请求进行加密，使用md5对参数进行加密，作为参数的一种防篡改表示，放在request的请求头中，供后台进行校验。在我们response的时候，同样进行拦截回应，将回应的数据的加密值进行解析。并使用md5重新加密，使我们获得的数据防篡改。&lt;/p&gt;
&lt;h3 id=&quot;基于vue的sm4加密解密工具&quot;&gt;基于vue的sm4加密解密工具&lt;/h3&gt;
&lt;p&gt;我们先介绍一下vue的加密解密工具类。通过调用工具类的方法可以直接对数据进行加密解密，配合request和response即可实现。我们贴出下面的工具类代码，大家可以直接使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const SboxTable = [
  [0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c, 0x05],
  [0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86, 0x06, 0x99],
  [0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed, 0xcf, 0xac, 0x62],
  [0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa, 0x75, 0x8f, 0x3f, 0xa6],
  [0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c, 0x19, 0xe6, 0x85, 0x4f, 0xa8],
  [0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb, 0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35],
  [0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25, 0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87],
  [0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52, 0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e],
  [0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38, 0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1],
  [0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34, 0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3],
  [0x1d, 0xf6, 0xe2, 0x2e, 0x82, 0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f],
  [0xd5, 0xdb, 0x37, 0x45, 0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51],
  [0x8d, 0x1b, 0xaf, 0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8],
  [0x0a, 0xc1, 0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0],
  [0x89, 0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84],
  [0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39, 0x48],
];

const FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc];
const CK = [
  0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,
  0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,
  0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,
  0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,
  0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,
  0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,
  0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,
  0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279,
];

const SM4_ENCRYPT = 1;
const SM4_DECRYPT = 0;

function sm4_context() {
  this.mode = 0;
  this.sk = [];
}


function GET_ULONG_BE(n, b, i) {
  return (b[i] &amp;lt;&amp;lt; 24) | (b[i + 1] &amp;lt;&amp;lt; 16) | (b[i + 2]) &amp;lt;&amp;lt; 8 | (b[i + 3]);
}

function PUT_ULONG_BE(n, b, i) {
  b[i] = n &amp;gt;&amp;gt;&amp;gt; 24;
  b[i + 1] = n &amp;gt;&amp;gt;&amp;gt; 16;
  b[i + 2] = n &amp;gt;&amp;gt;&amp;gt; 8;
  b[i + 3] = n;
}

function ROTL(x, n) {
  const a = (x &amp;amp; 0xFFFFFFFF) &amp;lt;&amp;lt; n;
  const b = x &amp;gt;&amp;gt;&amp;gt; (32 - n);

  return a | b;
}


function sm4Sbox(n) {
  const l = n &amp;gt;&amp;gt;&amp;gt; 4;
  const r = n % 16;
  return SboxTable[l][r];
}

function sm4Lt(ka) {
  let bb = 0;
  let c = 0;
  const a = new Uint8Array(4);
  const b = new Array(4);
  PUT_ULONG_BE(ka, a, 0);
  b[0] = sm4Sbox(a[0]);
  b[1] = sm4Sbox(a[1]);
  b[2] = sm4Sbox(a[2]);
  b[3] = sm4Sbox(a[3]);
  bb = GET_ULONG_BE(bb, b, 0);

  c = bb ^ (ROTL(bb, 2)) ^ (ROTL(bb, 10)) ^ (ROTL(bb, 18)) ^ (ROTL(bb, 24));
  return c;
}

function sm4F(x0, x1, x2, x3, rk) {
  return (x0 ^ sm4Lt(x1 ^ x2 ^ x3 ^ rk));
}

function sm4CalciRK(ka) {
  let bb = 0;
  let rk = 0;
  const a = new Uint8Array(4);
  const b = new Array(4);
  PUT_ULONG_BE(ka, a, 0);
  b[0] = sm4Sbox(a[0]);
  b[1] = sm4Sbox(a[1]);
  b[2] = sm4Sbox(a[2]);
  b[3] = sm4Sbox(a[3]);
  bb = GET_ULONG_BE(bb, b, 0);

  rk = bb ^ (ROTL(bb, 13)) ^ (ROTL(bb, 23));

  return rk;
}

function sm4_setkey(SK, key) {
  const MK = new Array(4);
  const k = new Array(36);
  let i = 0;
  MK[0] = GET_ULONG_BE(MK[0], key, 0);
  MK[1] = GET_ULONG_BE(MK[1], key, 4);
  MK[2] = GET_ULONG_BE(MK[2], key, 8);
  MK[3] = GET_ULONG_BE(MK[3], key, 12);

  k[0] = MK[0] ^ FK[0];
  k[1] = MK[1] ^ FK[1];
  k[2] = MK[2] ^ FK[2];
  k[3] = MK[3] ^ FK[3];

  for (; i &amp;lt; 32; i++) {
    k[i + 4] = k[i] ^ (sm4CalciRK(k[i + 1] ^ k[i + 2] ^ k[i + 3] ^ CK[i]));
    SK[i] = k[i + 4];
  }
}

function sm4_one_round(sk, input, output) {
  let i = 0;
  const ulbuf = new Array(36);

  ulbuf[0] = GET_ULONG_BE(ulbuf[0], input, 0);
  ulbuf[1] = GET_ULONG_BE(ulbuf[1], input, 4);
  ulbuf[2] = GET_ULONG_BE(ulbuf[2], input, 8);
  ulbuf[3] = GET_ULONG_BE(ulbuf[3], input, 12);
  while (i &amp;lt; 32) {
    ulbuf[i + 4] = sm4F(ulbuf[i], ulbuf[i + 1], ulbuf[i + 2], ulbuf[i + 3], sk[i]);
    i++;
  }

  PUT_ULONG_BE(ulbuf[35], output, 0);
  PUT_ULONG_BE(ulbuf[34], output, 4);
  PUT_ULONG_BE(ulbuf[33], output, 8);
  PUT_ULONG_BE(ulbuf[32], output, 12);
}

function sm4_setkey_enc(ctx, key) {
  ctx.mode = SM4_ENCRYPT;
  sm4_setkey(ctx.sk, key);
}

function sm4_setkey_dec(ctx, key) {
  let i; let j;
  ctx.mode = SM4_ENCRYPT;
  sm4_setkey(ctx.sk, key);
  for (i = 0; i &amp;lt; 16; i++) {
    j = ctx.sk[31 - i];
    ctx.sk[31 - i] = ctx.sk[i];
    ctx.sk[i] = j;
  }
}

function sm4_crypt_ecb(ctx, mode, length, input, output) {
  let index = 0;
  while (length &amp;gt; 0) {
    const oneInput = input.slice(index, index + 16);
    const oneOutput = new Uint8Array(16);
    sm4_one_round(ctx.sk, oneInput, oneOutput);

    for (let i = 0; i &amp;lt; 16; i++) {
      output[index + i] = oneOutput[i];
    }
    index += 16;
    length -= 16;
  }
}

function sm4_crypt_cbc(ctx, mode, length, iv, input, output) {
  let i;
  const temp = new Array(16);
  let index = 0;

  if (mode == SM4_ENCRYPT) {
    while (length &amp;gt; 0) {
      const oneInput = input.slice(index, index + 16);
      const oneOutput = new Array(16);
      for (i = 0; i &amp;lt; 16; i++) {
        oneOutput[i] = oneInput[i] ^ iv[i];
      }

      sm4_one_round(ctx.sk, oneOutput, oneOutput);

      for (i = 0; i &amp;lt; 16; i++) {
        iv[i] = oneOutput[i];
        output[index + i] = oneOutput[i];
      }

      index += 16;
      length -= 16;
    }
  } else /* SM4_DECRYPT */ {
    while (length &amp;gt; 0) {
      const oneInput = input.slice(index, index + 16);
      const oneOutput = new Array(16);
      index += 16;
      for (i = 0; i &amp;lt; 16; i++) {
        temp[i] = oneInput[i];
      }

      sm4_one_round(ctx.sk, oneInput, oneOutput);

      for (i = 0; i &amp;lt; 16; i++) {
        oneOutput[i] = oneOutput[i] ^ iv[i];
        output[index + i] = oneOutput[i];
      }

      for (i = 0; i &amp;lt; 16; i++) {
        iv[i] = temp[i];
      }

      index += 16;
      length -= 16;
    }
  }
}

function strfix(str, len) {
  let length = len - str.length;
  while (length-- &amp;gt; 0) {
    str = `0${str}`;
  }
  return str;
}

function HEXStrXOR(str1, str2) {
  const buf1 = hex2Array(str1);
  const buf2 = hex2Array(str2);

  let result = '';
  for (let i = 0; i &amp;lt; 16; i++) {
    result += strfix((buf1[i] ^ buf2[i]).toString(16).toUpperCase(), 2);
  }

  return result;
}

function hex2Array(str) {
  const len = str.length / 2;
  let substr = '';
  const result = new Array(len);
  for (let i = 0; i &amp;lt; len; i++) {
    substr = str.slice(2 * i, 2 * (i + 1));
    result[i] = parseInt(substr, 16) || 0;
  }
  return result;
}


const stringToByteArray = function (str) {
  const bytes = new Array();
  let len; let c;
  len = str.length;
  for (let i = 0; i &amp;lt; len; i++) {
    c = str.charCodeAt(i);
    if (c &amp;gt;= 0x010000 &amp;amp;&amp;amp; c &amp;lt;= 0x10FFFF) {
      bytes.push(((c &amp;gt;&amp;gt; 18) &amp;amp; 0x07) | 0xF0);
      bytes.push(((c &amp;gt;&amp;gt; 12) &amp;amp; 0x3F) | 0x80);
      bytes.push(((c &amp;gt;&amp;gt; 6) &amp;amp; 0x3F) | 0x80);
      bytes.push((c &amp;amp; 0x3F) | 0x80);
    } else if (c &amp;gt;= 0x000800 &amp;amp;&amp;amp; c &amp;lt;= 0x00FFFF) {
      bytes.push(((c &amp;gt;&amp;gt; 12) &amp;amp; 0x0F) | 0xE0);
      bytes.push(((c &amp;gt;&amp;gt; 6) &amp;amp; 0x3F) | 0x80);
      bytes.push((c &amp;amp; 0x3F) | 0x80);
    } else if (c &amp;gt;= 0x000080 &amp;amp;&amp;amp; c &amp;lt;= 0x0007FF) {
      bytes.push(((c &amp;gt;&amp;gt; 6) &amp;amp; 0x1F) | 0xC0);
      bytes.push((c &amp;amp; 0x3F) | 0x80);
    } else {
      bytes.push(c &amp;amp; 0xFF);
    }
  }
  return bytes;
};

const hexStringToByteArray = function (str) {
  let pos = 0;
  let len = str.length;
  if (len % 2 !== 0) {
    return str;
  }
  len /= 2;
  const arrBytes = new Array();
  for (let i = 0; i &amp;lt; len; i++) {
    const s = str.substr(pos, 2);
    const v = parseInt(s, 16);
    arrBytes.push(v);
    pos += 2;
  }
  return arrBytes;
};
const byteArrayToHexString = function (arr) {
  let str = '';
  for (let i = 0; i &amp;lt; arr.length; i++) {
    let tmp = arr[i].toString(16);
    if (tmp.length == 1) {
      tmp = `0${tmp}`;
    }
    str += tmp;
  }
  return str;
};
const byteArrayToString = function (arr) {
  if (typeof arr === 'string') {
    return arr;
  }
  let str = '';
  const _arr = arr;
  for (let i = 0; i &amp;lt; _arr.length; i++) {
    const one = _arr[i].toString(2);
    const v = one.match(/^1+?(?=0)/);
    if (v &amp;amp;&amp;amp; one.length == 8) {
      const bytesLength = v[0].length;
      let store = _arr[i].toString(2).slice(7 - bytesLength);
      for (let st = 1; st &amp;lt; bytesLength; st++) {
        store += _arr[st + i].toString(2).slice(2);
      }
      str += String.fromCharCode(parseInt(store, 2));
      i += bytesLength - 1;
    } else {
      str += String.fromCharCode(_arr[i]);
    }
  }
  return str;
};

function SM4CryptECBWithPKCS7Padding(data, sCryptFlag) {
  const szSM4Key = 'cc9368581322479ebf3e79348a2757d9';
  if (szSM4Key.length !== 32) {
    // console.log(&quot;传入密钥[&quot; + szSM4Key + &quot;]长度不为32位&quot;);
    return '';
  }
  let szData = null;
  if (sCryptFlag === SM4_ENCRYPT) { // 加密
    szData = stringToByteArray(data);
  } else { // 解密
    szData = hexStringToByteArray(data);
  }
  const len = szData.length;

  if (sCryptFlag === SM4_ENCRYPT) { // 加密,进行填充PKCS7Padding
    const p = 16 - len % 16;
    for (let i = 0; i &amp;lt; p; i++) {
      szData.push(p);
    }
  }

  const ctx = new sm4_context();
  const lpbKey = hex2Array(szSM4Key);
  if (sCryptFlag === SM4_ENCRYPT) {
    sm4_setkey_enc(ctx, lpbKey); // 加密
  } else {
    sm4_setkey_dec(ctx, lpbKey); // 解密
  }
  const pbyCryptResult = new Array(szData.length);
  sm4_crypt_ecb(ctx, sCryptFlag, szData.length, szData, pbyCryptResult);
  if (sCryptFlag === SM4_DECRYPT) { // 解密,去除填充PKCS7Padding
    const p = pbyCryptResult[pbyCryptResult.length - 1];
    for (let i = 0; i &amp;lt; p; i++) {
      pbyCryptResult.pop();
    }
  }
  if (sCryptFlag === SM4_ENCRYPT) { // 加密
    return byteArrayToHexString(pbyCryptResult);
  } // 解密
  return byteArrayToString(pbyCryptResult);
}

export function encrypt(inArray) {
  return SM4CryptECBWithPKCS7Padding(inArray, 1);
}

export function decrypt(inArray) {
  return SM4CryptECBWithPKCS7Padding(inArray, 0);
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上就是我们sm4的加密解密算法。其中重要的方法就是SM4CryptECBWithPKCS7Padding，这里我们要传入两个值，第一个值是我们加密或者要解密的值，第二个是标志是加密还是解密。当为1的时候，就是加密，当为0的时候就是解密。&lt;br/&gt;下面介绍一下md5加密的防篡改算法。&lt;/p&gt;
&lt;h3 id=&quot;md5的加密算法&quot;&gt;md5的加密算法&lt;/h3&gt;
&lt;p&gt;md5加密我们直接采用模块crypto，针对于我们的vue项目，我们先将这个module进行安装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cnpm install crypto
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成后，在我们需要进行md5加密的位置，进行加密，我们在这里是在request中进行加密。下面介绍一下md5加密的使用方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import crypto from 'crypto';

const md5Hash = crypto.createHash('md5');
const dataJson = JSON.stringify(data);
md5Hash.update(dataJson);
md5Data = md5Hash.digest('hex');

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上我们就得到了参数的md5值。在对于后端的时候，要注意一个大坑，前端的这种加密方式，如果开头为0，并不会省略，如果后台使用bigInteger的方式，会导致后端的0直接被省略。导致md5值不一样，所以后端的md5校验推荐使用Integer的形式。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200518231027336-722370082.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Md5Utils {

    public static String getMD5String(String str) {
        try {
            MessageDigest md = MessageDigest.getInstance(&quot;md5&quot;);
            md.update(str.getBytes());
            byte s[] = md.digest();
            String result = &quot;&quot;;
            for (int i = 0; i &amp;lt; s.length; i++) {
                result += Integer.toHexString((0x000000FF &amp;amp; s[i]) | 0xFFFFFF00).substring(6);
            }
            return result;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;基于vue的实例实战代码&quot;&gt;基于vue的实例实战代码&lt;/h3&gt;
&lt;h4 id=&quot;全局变量的配置和需要加密的url&quot;&gt;全局变量的配置和需要加密的url&lt;/h4&gt;
&lt;p&gt;我们定义这样的两个变量。全局变量用于是否进行加密1是进行加密，0是进行解密。&lt;br/&gt;在encryptUrl 中key值配置为要加密的url，value值设置成属性必须加密name属性，sex属性不加密。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const isEncrypt = '1'; // 1是加密 0是不加密
// 将所有要加密的url和key放在一起
const encryptUrl = {
  [/test/save`]: ['name'],
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;针对于加密解密进行函数的封装&quot;&gt;针对于加密解密进行函数的封装&lt;/h4&gt;
&lt;p&gt;上面已经有了可以使用的工具类，我们对此进行递归的函数封装。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function encryptValue(pObj, pParamKeys, pDecrypt) {
  if (pObj) {
    if (Array.isArray(pObj)) {
      let i = pObj.length;
      while (i--) {
        encryptValue(pObj[i], pParamKeys, pDecrypt);
      }
    } else if (typeof (pObj) === 'object') {
      if (pObj.constructor !== RegExp) {
        for (const k in pObj) {
          if (pObj.hasOwnProperty(k)) {
            if (typeof (pObj[k]) === 'object') {
              encryptValue(pObj[k], pParamKeys, pDecrypt);
            } else if (pParamKeys.indexOf(k) !== -1 &amp;amp;&amp;amp; pObj[k]) {
              if (pDecrypt === true) {
                // 解密
                pObj[k] = decrypt(pObj[k]);
              } else {
                pObj[k] = encrypt(pObj[k]);
              }
            }
          }
        }
      }
    }
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;request的拦截方式&quot;&gt;request的拦截方式&lt;/h4&gt;
&lt;p&gt;我们首先拦截所有请求的request的地方，进行sm4加密解密。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;axios.interceptors.request.use(
  (config) =&amp;gt; {
    // 加密代码开始-------------------
    // 获取到当前请求的所有值
    const paramData = lodash.cloneDeep(config.data);
    // 获取到加密的url
    const urlAddr = config.url;
    let md5Data = '';
    if (paramData &amp;amp;&amp;amp; isEncrypt === '1') {
      let paramKeys = [];
      for (const key in encryptUrl) {
        if (encryptUrl.hasOwnProperty(key)) {
          if (urlAddr &amp;amp;&amp;amp; urlAddr.startsWith(key)) {
            paramKeys = encryptUrl[key];
            break;
          }
        }
      }
      // 获取到所有要加密的key值。
      if (paramKeys &amp;amp;&amp;amp; paramKeys.length &amp;gt; 0) {
        let SM4cloneData = paramData;
        if (typeof (SM4cloneData) === 'string') {
          try {
            const dataStr = $.parseJSON(SM4cloneData);
            encryptValue(dataStr, paramKeys);
            SM4cloneData = JSON.stringify(dataStr);
          } catch (e) {
            console.log(e);
          }
        } else {
          encryptValue(SM4cloneData, paramKeys);
        }
      }
      const md5Hash = crypto.createHash('md5');
      const dataJson = JSON.stringify(config.data);
      md5Hash.update(dataJson);
      md5Data = md5Hash.digest('hex');
      config.data = paramData;
    }
      config.headers = {
        'md5': md5Data,
      };
    return config;
  }
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;response的拦截方式&quot;&gt;response的拦截方式&lt;/h4&gt;
&lt;p&gt;针对于response我们要对配置的url进行解密。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;axios.interceptors.response.use(
  (response) =&amp;gt; {
    // 开始解密
    // 获取到当前请求的所有值
    const cloneData = lodash.cloneDeep(response.data);
    // 获取到解密的url
    const urlAddr = response.url;
    // 对paramData进行加密,此时先直接加密做试验。
    if (cloneData &amp;amp;&amp;amp; isEncrypt === '1') {
      let paramKeys = [];
      for (const key in encryptUrl) {
        if (encryptUrl.hasOwnProperty(key)) {
          if (urlAddr &amp;amp;&amp;amp; urlAddr.startsWith(key)) {
            paramKeys = encryptUrl[key];
            break;
          }
        }
      }
      // 获取到所有要解密的key值。
      if (paramKeys &amp;amp;&amp;amp; paramKeys.length &amp;gt; 0) {
        let SM4cloneData;
        if (Array.isArray(cloneData)) {
          SM4cloneData = cloneData.data;
        } else if (typeof (cloneData) === 'object') {
          SM4cloneData = cloneData;
        }

        if (typeof (SM4cloneData) === 'string') {
          try {
            const dataStr = $.parseJSON(SM4cloneData);
            encryptValue(dataStr, paramKeys, true);
            SM4cloneData = JSON.stringify(dataStr);
          } catch (e) {
            console.log(e);
          }
        } else {
          encryptValue(SM4cloneData, paramKeys, true);
        }
        const md5Hash = crypto.createHash('md5');
        const dataJson = JSON.stringify(cloneData);
        md5Hash.update(dataJson);
        const md5Data = md5Hash.digest('hex');
        if (response.headers.md5.hasOwnProperty('md5')) {
          if (md5Data === response.headers.md5) {
            alert(&quot;md5完整性校验错误&quot;);
            return;
          }
        }
      }
      return response.data;
    }

    return response.data;
  },
  
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;支持基于vue的国产sm4加密解密方案到此结束。文中难免有不足之处，希望大家批评指正。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1534147/202005/1534147-20200518232020908-2110873341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 19 May 2020 00:42:00 +0000</pubDate>
<dc:creator>经典鸡翅</dc:creator>
<og:description>前言 上篇文章我们介绍了国产SM4加密算法的后端java实现方案。没有看过的小伙伴可以看一下这篇文章。 &amp;quot;https://www.cnblogs.com/jichi/p/12907453.h</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jichi/p/12913768.html</dc:identifier>
</item>
<item>
<title>学会阅读源码后，我觉得自己better了 - 沉默王二</title>
<link>http://www.cnblogs.com/qing-gee/p/12914774.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qing-gee/p/12914774.html</guid>
<description>&lt;p&gt;我有一个大学同学，名叫石磊，我在之前的文章里提到过几次，我们俩合作过很多项目。只要有他在，我就特别放心，因为几乎所有难搞的问题，到他这，都能够巧妙地化解。他给我印象最深刻的一句话就是，“有啥解决不了的？只要你肯阅读源码。”&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/yuanma-01.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;说起来源码，我是不太建议新手去阅读，容易劝退。不信，你让一个小学生去读一下《百年孤独》，我保证他会从此对阅读失去兴趣。去年，我忍着头皮读了这本书的前十页，然后就没有然后了——读不下去。我觉得自己还是嫩了点，生活阅历没到那个层次，感悟、内化、思考的能力也没到那个份上。&lt;/p&gt;
&lt;p&gt;我建议程序员至少在有一到两年编程经验后，再去阅读源码，这个时间段会比较合适。我是大三出去实习的，那会的水平真不敢恭维。不过，公司对我们的耐心还是有的。二十多名新人，分两组，一组做个计算器，一组做画图工具，要求两个月内完成。&lt;/p&gt;
&lt;p&gt;说白了，就是考核我们的，不合格就请退。我做的是计算器，成品后来放到了 CSDN 的资源库上，骗了不少 C 币。坦白说吧，有一部分代码我是从网上复制粘贴的。&lt;/p&gt;
&lt;p&gt;就这部分代码，我研究了一个多月时间，硬是没有吃透，只是说把其中的一些小 bug 修复了——靠着这种能力，我谋得了一份可以挣钱养活自己的差事。&lt;/p&gt;
&lt;p&gt;接下来一年半的工作时间里，我没有强逼自己去阅读源码，而是跟着项目组的进度，不断地积攒编程的经验。就像小孩子一样，在会跑之前，总得先学会走路啊。&lt;/p&gt;
&lt;p&gt;时间来到了 2012 年，我通过某些契机了解到公司以后的发展重心会是 Flex（结合了 B/S 与 C/S 技术优点的新一代富客户端技术），我就开始在项目间隙研究起了 Flex 的源码。这时候，我觉得自己“复制粘贴”（或者说面向搜索引擎）的能力已经炉火纯青了，平常的工作任务都能够应付，但总觉得自己还很菜。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/yuanma-02.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;Flex 的整体框架是日方人员设计的，在原生的技术上做了一层封装，组件更丰富了，有点类似于现在前端非常火热的 Vue.js 或者 React。&lt;/p&gt;
&lt;p&gt;我当时还没有参与到 Flex 的项目当中，但因为和公司的一个前辈关系比较要好，就找他要了一个小项目的源码，在本地搭了一个调试环境，开始“打怪升级”了。&lt;/p&gt;
&lt;p&gt;不得不承认，日方开发人员写的代码还是非常严谨的，注释比代码多得多。我的日语水平虽然不咋滴，但在翻译软件的帮助下，再加上对代码的感知能力，还是能够钻研下去的。&lt;/p&gt;
&lt;p&gt;这里顺带透露一点。有两个源码的作者来过苏州的分公司，我见过他们，年纪至少在四十岁以上，据同事说，有一个都五十多岁了，看来保养的不错啊。他们为人非常谦和（学到了我们民族的精髓），完完全全是一副纯粹的技术人的模样——那些大龄程序员都去哪了？答案就在这里，只要你技术够牛，公司就需要你。&lt;/p&gt;
&lt;p&gt;经过四个多月不懈的努力，我觉得自己的编程能力得到了飞速的提升，不仅会用框架已有的组件，在必要的时候还能够扩展一些自定义的组件——因为我已经读懂了大部分的源码，敢在上面动手动脚了。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/yuanma-03.png&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;在这期间，我用 Flex 做了一款聊天工具，我在很早之前的文章里提到过。公司内部使用的 spark 聊天工具是有档案记录的，不能在上面谈一些工作之外的话题，比如说有几个同事喜欢分享魔兽世界的心得体会，我这个工具恰好为他们提供了便利，服务器就在我本地电脑上。&lt;/p&gt;
&lt;p&gt;就是凭借这款聊天工具，我被一个领导看中了，直接挖我过去做了小组长，负责项目的编码部分。更重要的是，加薪了！&lt;/p&gt;
&lt;p&gt;所以说，我一直觉得，阅读源码是一项重要的能力——它能够让你从一名代码的搬砖工人蜕变成为一名会造轮子的工程师。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我现在八年工作经验了，但前几年出来的时候没注重基础，没研究过源码，现在三十了，感觉压力上来了。投了很多简历，也没啥面试的消息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面这段话是前天一名读者安少给我发的信息，看完后，真的蛮为他感到惋惜的。阅读源码虽然不是万能的，但对一个程序员的能力提升，真的是非常重要，大概就相当于内功心法吧。&lt;/p&gt;
&lt;p&gt;如果安少在程序生涯的早期（三五年的时候）就能够静下心去源码里“潜水”或者“畅游”一段时间，他就不至于在 30 岁的时候担心自己的前途。&lt;/p&gt;
&lt;p&gt;参加过 Java 岗位面试的读者应该清楚，面试官喜欢问一些关于源码方面的知识点，比如说，“HashMap 的底层原理是什么？大小超过了负载因子定义的容量该怎么办？”如果平常肯去倒腾源码的话，这些问题你肯定能够答得行云流水，否则真的是一脸懵逼啊。&lt;/p&gt;
&lt;img src=&quot;http://www.itwanger.com/assets/images/2020/05/yuanma-04.gif&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;总结一下，&lt;strong&gt;阅读源码不仅能够提升你的编程能力，还能够让你从容面对面试官的提问&lt;/strong&gt;。对了，我差点忘记一点，&lt;strong&gt;阅读源码还是解决 bug 的银弹&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这也是为什么 GitHub 这么流行的原因之一啊，因为它上面的源码都是开源的。这就意味着，如果程序出现了故障，而故障的原因是由这些源码引起的，你就不必苦苦等待源码的作者去修复它，“自己动手丰衣足食”啊。毕竟源码的作者还有很多其他重要的事情要做，他不可能在线等你 issue 啊。&lt;/p&gt;
&lt;p&gt;还记得我在文章开头提到的石磊吧，他遇到问题的第一反应就是去把源码的底裤扒个精光。在他眼里，问题发生的根源要么是他自己，要么就是源码，所以我一直觉得他蛮有极客精神的。&lt;/p&gt;
&lt;p&gt;而我，通常是，先检查自己的代码，如果找不出，去求助一下搜索引擎，如果还找不出，才会去阅读源码。&lt;/p&gt;
&lt;p&gt;不要怕，一开始阅读源码真的会有点难度，但如果你想要成长，就不能一直待在自己的舒适区，你得硬着头皮上。等你头硬（秃）了之后，就真的变强了！&lt;/p&gt;
&lt;p&gt;如果觉得文章对你有点帮助，请微信搜索「 &lt;strong&gt;沉默王二&lt;/strong&gt; 」第一时间阅读。&lt;/p&gt;
&lt;blockquote readability=&quot;4.4565217391304&quot;&gt;
&lt;p&gt;本文已收录 GitHub，&lt;a href=&quot;https://github.com/qinggee/itwanger.github.io&quot;&gt;&lt;strong&gt;传送门~&lt;/strong&gt;&lt;/a&gt; ，里面更有大厂面试完整考点，欢迎 Star。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我是沉默王二，一枚有颜值却靠才华苟且的程序员。&lt;strong&gt;关注即可提升学习效率，别忘了三连啊，点赞、收藏、留言，我不挑，嘻嘻&lt;/strong&gt;。&lt;/p&gt;
</description>
<pubDate>Tue, 19 May 2020 00:34:00 +0000</pubDate>
<dc:creator>沉默王二</dc:creator>
<og:description>我有一个大学同学，名叫石磊，我在之前的文章里提到过几次，我们俩合作过很多项目。只要有他在，我就特别放心，因为几乎所有难搞的问题，到他这，都能够巧妙地化解。他给我印象最深刻的一句话就是，“有啥解决不了的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qing-gee/p/12914774.html</dc:identifier>
</item>
<item>
<title>Dotnet core使用JWT认证授权最佳实践(二) - Tiger.Wang</title>
<link>http://www.cnblogs.com/tiger-wang/p/12894021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tiger-wang/p/12894021.html</guid>
<description>&lt;blockquote readability=&quot;6.4382470119522&quot;&gt;
&lt;p&gt;最近，团队的小伙伴们在做项目时，需要用到JWT认证。遂根据自己的经验，整理成了这篇文章，用来帮助理清JWT认证的原理和代码编写操作。&lt;/p&gt;
&lt;p&gt;第一部分：&lt;a href=&quot;https://www.cnblogs.com/tiger-wang/p/12892383.html&quot; target=&quot;_blank&quot;&gt;Dotnet core使用JWT认证授权最佳实践(一)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（接上文）&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;&lt;span&gt;测试运行&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;bash language-bash hljs&quot;&gt;% dotnet run&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等程序运行起来后，在浏览器输入：http://localhost:5000/swagger/，会进到Swagger的API界面。选择requestToken，点击按钮”Try it out“-&amp;gt;”Execute“，可以看到运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;http language-http hljs&quot;&gt;[&quot;&lt;span class=&quot;hljs-attribute&quot;&gt;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoic3RyaW5nIiwiZXhwIjoxNTg5MzgxMzQ4LCJpc3MiOiJXYW5nUGx1cyJ9.ojGuWUk9i2Vp5qu3s2UZSLC64Sm95Cao2eGF3GDVvec&quot;,&quot;123456&quot;]&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好吧，不要在意这个返回的格式。返回的两个串中，第一个就是Token，第二个是refreshToken。&lt;/p&gt;

&lt;p&gt;到这儿，我们成功拿到了用户的Token。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;    &lt;span&gt;为防止非授权转发，这儿给出本文的原文链接：&lt;a class=&quot;ng-star-inserted&quot; href=&quot;https://www.cnblogs.com/tiger-wang/p/12894021.html&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/tiger-wang/p/12894021.html&lt;/a&gt;&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;拿到Token后，我们就可以进行认证操作了。&lt;/p&gt;
&lt;p&gt;既然是认证，那应该在每个API上进行。所以，认证的过程不会放到控制器里，而应该以MiddleWare的方式，放到主流程中。&lt;/p&gt;
&lt;p&gt;这个MiddleWare，Microsoft.AspNetCore.Authentication.JwtBearer库已经帮我们做好了。我们只需要配置就好。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;在Startup.cs中，ConfigureServices方法里，添加以下内容&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;11&quot;&gt;services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)&lt;br/&gt;.AddJwtBearer(option =&amp;gt;&lt;br/&gt;{&lt;br/&gt;option.RequireHttpsMetadata = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;option.SaveToken = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;;&lt;p&gt;var token = Configuration.GetSection(&lt;span class=&quot;hljs-string&quot;&gt;&quot;tokenParameter&quot;&lt;/span&gt;).Get&amp;lt;tokenParameter&amp;gt;();&lt;/p&gt;&lt;p&gt;option.TokenValidationParameters = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TokenValidationParameters&lt;br/&gt;{&lt;br/&gt;ValidateIssuerSigningKey = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,&lt;br/&gt;IssuerSigningKey = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.ASCII.GetBytes(token.Secret)),&lt;br/&gt;ValidIssuer = token.Issuer,&lt;br/&gt;ValidateIssuer = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,&lt;br/&gt;ValidateAudience = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;,&lt;br/&gt;};&lt;br/&gt;});&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里面，有几个参数需要注意：&lt;/p&gt;
&lt;p&gt;RequireHttpsMetadata: 限定认证操作是否必须通过https来做，这个要跟随项目在生产环境中的运行情况来定。如果WebServer是我前文&lt;a href=&quot;https://www.cnblogs.com/tiger-wang/p/12791005.html&quot; target=&quot;_blank&quot;&gt;15分钟从零开始搭建支持10w+用户的生产环境(三)&lt;/a&gt;中介绍的Jexus，采用对外https，对内http的方式，那这儿可以设为false。&lt;/p&gt;
&lt;p&gt;SaveToken: 决定Token在认证完成后，是否需要保存到上下文里并向后传。这个设置也要看应用。我们Token生成后，用户的相关信息已经包含在里面了。API里如果有涉及用户的操作，按理可以不用往API里传相关用户的参数。一方面不安全，另一方面代码也不好看。这时就可以把这个参数设为True，然后API从上下文中直接取用户信息。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;span&gt;在Startup.cs里，Configure方法中，打开认证&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;app.UseAuthentication();&lt;br/&gt;app.UseAuthorization();&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这两步完成，我们就完成的认证的开发工具。&lt;/p&gt;
&lt;p&gt;用别人的轮子还是很爽的，虽然轮子的挑选工作很复杂很费力。&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;设置API认证。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在这个Demo里，我们选代码生成时给的WeatherForecastController下的Get方法来测试。&lt;/p&gt;
&lt;p&gt;在方法前边，我们加上Authorize：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;[HttpGet]&lt;br/&gt;[Authorize]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; IEnumerable&amp;lt;WeatherForecast&amp;gt; Get()&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;&lt;span&gt;测试运行。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;启动程序，跟上一章的方式一样。&lt;/p&gt;
&lt;p&gt;程序运行后，打开：http://localhost:5000/swagger/，进入WeatherForecast，点”Try it out“-&amp;gt;”Execute“，我们会得到一个401 - Error: Unauthorized的返回，因为我们没有做认证。&lt;/p&gt;
&lt;p&gt;下面测试做认证后的访问。&lt;/p&gt;
&lt;p&gt;先去requestToken拿一个Token（refreshToken这章不用），在前边加“Bearer ”，拼成一个串&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;http language-http hljs&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJodHRwOi8vc2NoZW1hcy54bWxzb2FwLm9yZy93cy8yMDA1LzA1L2lkZW50aXR5L2NsYWltcy9uYW1lIjoic3RyaW5nIiwiZXhwIjoxNTg5MzgxMzQ4LCJpc3MiOiJXYW5nUGx1cyJ9.ojGuWUk9i2Vp5qu3s2UZSLC64Sm95Cao2eGF3GDVvec&lt;br/&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;要注意，Bearer后边要跟一个空格。这个串的格式是：Bearer + 空格 + Token。&lt;/p&gt;
&lt;p&gt;在页面的右上角，有一个“Authorize”，点进去，在Value输入框中粘贴上面拼好的串，然后点按钮“Authorize”，保存认证信息。&lt;/p&gt;
&lt;p&gt;下面进入WeatherForecast，点”Try it out“-&amp;gt;”Execute“，这时候，我们就能拿到正确的返回数据。&lt;/p&gt;

&lt;p&gt;在上一章中，我们实现了用户的认证。但这个认证有个不漂亮的地方：用户只简单的被认证系统分成了通过认证的和不通过认证的。&lt;/p&gt;
&lt;p&gt;在实际项目中，我们有时候会有这样的需求：对于某个API，我们希望只允许具有某种角色权限的用户去访问。&lt;/p&gt;
&lt;p&gt;下面，我们对这个项目进行小量的修改，以完成这个需求。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;在给用户签发Token的过程中，加入用户的角色数据。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在AuthenticationController的RequestToken中，我们构建了一个用户的Claims：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;var claims = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[]&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Claim(ClaimTypes.Name,request.username),&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就是这儿。我们在这儿加入用户的角色：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;var claims = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[]&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Claim(ClaimTypes.Name,request.username),&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Claim(ClaimTypes.Role, &lt;span class=&quot;hljs-string&quot;&gt;&quot;testUser&quot;&lt;/span&gt;),&lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际应用中，这个角色的名称，可以根据需要，从用户系统中拿来。&lt;/p&gt;
&lt;p&gt;在这个Demo里，就直接写成个字符串了。就是说，有一个角色，叫testUser。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;span&gt;给API增加认证的角色要求&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;[HttpGet]&lt;br/&gt;[Authorize(Roles=&lt;span class=&quot;hljs-string&quot;&gt;&quot;testUser&quot;&lt;/span&gt;)]&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; IEnumerable&amp;lt;WeatherForecast&amp;gt; Get()&lt;br/&gt;...&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，这个Roles=&quot;testUser&quot;里的testUser，就是这个方法授权所对应的角色名称。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;测试运行&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;按正常的步骤，取Token，拼串，保存认证信息，然后去运行WeatherForecast，API能正常返回。&lt;/p&gt;
&lt;p&gt;我们可以把代码中的testUser改成别的字符串进行测试，会返回403 - Error: Forbidden错误。&lt;/p&gt;

&lt;p&gt;增加角色认证成功。&lt;/p&gt;

&lt;p&gt;Token过期后，就需要刷新。&lt;/p&gt;
&lt;p&gt;当然我们可以把Token设成永远不过期，但这不是个安全的做法。还可以在Token过期后重新请求一个新Token，但这样做会显得Low。&lt;/p&gt;
&lt;p&gt;赏心悦目的做法是：用refreshToken来刷新Token。设置refreshToken的过期时间长于Token。Token过期后，让用户提交Token和refreshToken到服务器，服务器验证Token是否合法，并从中提取用户信息，根据用户信息和refreshToken核验是否匹配。如果匹配，就重新生成Token给用户。&lt;/p&gt;
&lt;p&gt;至于refreshToken的过期时长，和是否需要在刷新Token时也刷新refreshToken，就看心情了，没有固定的做法。我自己的项目中，Token是2小时过期，refreshToken是24小时过期。在Token刷新时，如果refreshToken的过期时间少于6小时，则刷新refreshToken。供参考。&lt;/p&gt;

&lt;p&gt;下面，按这个方式，做一下刷新Token。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;在DTOModels下建一个RefreshTokenDTO，用作API的输入参数&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;using&lt;/span&gt; System;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;namespace&lt;/span&gt; demo.DTOModels&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;RefreshTokenDTO&lt;/span&gt;&lt;br/&gt;{&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; Token { get; &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;; } &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;string&lt;/span&gt; refreshToken { get; &lt;span class=&quot;hljs-built_in&quot;&gt;set&lt;/span&gt;; }&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;&lt;span&gt;在AuthenticationController里，创建一个RefreshToken的API，并补齐验证代码&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre readability=&quot;14.5&quot;&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot; readability=&quot;23&quot;&gt;[HttpPost, Route(&lt;span class=&quot;hljs-string&quot;&gt;&quot;refreshToken&quot;&lt;/span&gt;)]&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; ActionResult &lt;span class=&quot;hljs-title&quot;&gt;RefreshToken&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;([FromBody]RefreshTokenDTO request)&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt;(request.Token == null &amp;amp;&amp;amp; request.refreshToken == null)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; BadRequest(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Invalid Request&quot;&lt;/span&gt;);&lt;p&gt;&lt;br/&gt;var handler = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; JwtSecurityTokenHandler();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt;&lt;br/&gt;{&lt;br/&gt;ClaimsPrincipal claim = handler.ValidateToken(request.Token, &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TokenValidationParameters{&lt;br/&gt;ValidateIssuerSigningKey = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,&lt;br/&gt;IssuerSigningKey = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.ASCII.GetBytes(_tokenParameter.Secret)),&lt;br/&gt;ValidateIssuer = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;,&lt;br/&gt;ValidateAudience = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;,&lt;br/&gt;ValidateLifetime = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;,&lt;br/&gt;}, out SecurityToken securityToken);&lt;/p&gt;&lt;p&gt;var username = claim.Identity.Name;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;var token = GenUserToken(username, &lt;span class=&quot;hljs-string&quot;&gt;&quot;testUser&quot;&lt;/span&gt;);&lt;/p&gt;&lt;p&gt;var refreshToken = &lt;span class=&quot;hljs-string&quot;&gt;&quot;654321&quot;&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Ok(&lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt;[] { token, refreshToken });&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt;(Exception)&lt;br/&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; BadRequest(&lt;span class=&quot;hljs-string&quot;&gt;&quot;Invalid Request&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样，Token刷新就完成了。可以用生成Token运行测试，能正常认证通过。&lt;/p&gt;

&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;单独说一下refreshToken&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;refreshToken，名义上是为了刷新Token，实际上用处主要是给用户重新登录做计时。refreshToken过期了，用户就必须重新登录。就是这么个作用。要不然，Token自己刷新岂不更好？&lt;/p&gt;
&lt;p&gt;refreshToken可以采用跟Token一样的生成方式。但是，我们也看到，Token生成出来的串就很长，如果refreshToken也那样生成，那就也会是一个很长的串。这样会加大前端到API的传输量。因此，这不算是一个好主意。&lt;/p&gt;
&lt;p&gt;一般来说，refreshToken会换一种生成方式。唯一序列、Hash，都是可以选择的，可以减少很多传输。&lt;/p&gt;
&lt;p&gt;至于持久化和过期，依托数据库就好了。&lt;/p&gt;

&lt;p&gt;最后，送大家一个彩蛋。&lt;/p&gt;
&lt;p&gt;在生成Token时，我们把过期时间设置成少于五分钟的时长，比方3分钟。但这时，实测会发现，Token的过期失效了。&lt;/p&gt;
&lt;p&gt;为什么呢？&lt;/p&gt;
&lt;p&gt;TokenValidationParameters有一个属性叫ClockSkew，这个参数有个默认值是TimeSpan.FromMinutes(5)。&lt;/p&gt;
&lt;p&gt;这个参数的意义是：考虑到各个服务器之间的时间不一定完全同步，系统给了个5分钟的误差时间。&lt;/p&gt;
&lt;p&gt;这个误差时间导致的结果是：少于五分钟的过期时间，会在实际认证检查时被忽略。&lt;/p&gt;
&lt;p&gt;这个情况，Microsoft上有N多人在讨论，可以自己去查。&lt;/p&gt;
&lt;p&gt;所以，当Token的过期小于5分钟时，想要让认证对这个时间生效，可以把这个值设为TimeSpan.Zero。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;c# language-c# hljs cpp&quot;&gt;option.TokenValidationParameters = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TokenValidationParameters&lt;br/&gt;{&lt;br/&gt;ValidateIssuerSigningKey = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,&lt;br/&gt;IssuerSigningKey = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.ASCII.GetBytes(token.Secret)),&lt;br/&gt;ValidIssuer = token.Issuer,&lt;br/&gt;ValidateIssuer = &lt;span class=&quot;hljs-literal&quot;&gt;true&lt;/span&gt;,&lt;br/&gt;ValidateAudience = &lt;span class=&quot;hljs-literal&quot;&gt;false&lt;/span&gt;,&lt;br/&gt;ClockSkew = TimeSpan.Zero,        &lt;br/&gt;};&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我把上面的代码，传到了Github上，需要了可以拉下来直接测试。&lt;/p&gt;
&lt;p&gt;代码地址：&lt;a href=&quot;https://github.com/humornif/Demo-Code/tree/master/0007/demo&quot; target=&quot;_blank&quot;&gt;https://github.com/humornif/Demo-Code/tree/master/0007/demo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（全文完）&lt;/p&gt;

&lt;hr/&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;7.5&quot;&gt;&lt;td&gt;&lt;img src=&quot;https://i.niupic.com/images/2020/05/07/7Eyn.jpg&quot; alt=&quot;&quot; width=&quot;160&quot; height=&quot;160&quot;/&gt;&lt;/td&gt;
&lt;td readability=&quot;10&quot;&gt;
&lt;p&gt;微信公众号：老王Plus&lt;/p&gt;
&lt;p&gt;扫描二维码，关注个人公众号，可以第一时间得到最新的个人文章和内容推送&lt;/p&gt;
&lt;p&gt;本文版权归作者所有，转载请保留此声明和原文链接&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;</description>
<pubDate>Tue, 19 May 2020 00:33:00 +0000</pubDate>
<dc:creator>Tiger.Wang</dc:creator>
<og:description>最近，团队的小伙伴们在做项目时，需要用到JWT认证。遂根据自己的经验，整理成了这篇文章，用来帮助理清JWT认证的原理和代码编写操作。 第一部分：Dotnet core使用JWT认证授权最佳实践(一)</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tiger-wang/p/12894021.html</dc:identifier>
</item>
<item>
<title>动态规划两题连刷，移动下标的小技巧 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12914735.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12914735.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天是LeetCode的37篇，我们继续愉快的刷题。今天要刷的题目输出LeetCode 63和64两题，分别是Unique Paths II和Minimum Path Sum。&lt;/p&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从题目的名称我们就可以看出来，今天的题目都和path有关，其实不止如此，这两题的题意也几乎一样，本质上都是上一篇文章所讲的LeetCode 62题的延伸和拓展。这也是我们把这两题放在一起解决的原因。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Unique Paths II&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们先来看第一题，Unique Paths II。它和62题基本一样，都是机器人走一个矩形迷宫求解路径总数的问题。大概就像是下面这张图一样，机器人从左上角出发，往右下角前进。&lt;/p&gt;
&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/19/1722a41dc15e9062?w=400&amp;amp;h=183&amp;amp;f=jpeg&amp;amp;s=9934&quot; alt=&quot;img&quot;/&gt;img
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;机器人只能往下或者是往右移动，不能往左或者是往上。并且这一次给定的矩形迷宫不再是所有点都可以访问了，有些点设置了路障。机器人不能访问设置了路障的点，请问在此情况下，机器人从起点走到终点的路径一共有多少条？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;样例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;Input:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
Output: 2
Explanation:
There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -&amp;gt; Right -&amp;gt; Down -&amp;gt; Down
2. Down -&amp;gt; Down -&amp;gt; Right -&amp;gt; Right
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;从样例可以看出来，题目用一个二维数组代表了矩形，数组当中为1的点表示了路障。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你读过我们上一篇文章，做过LeetCode 62题，你会发现这题几乎是完全一样的翻版，并且连解题思路都一样。如果你没有做过，可以通过下面的传送门回顾一下：&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMTM5OTM2NA==&amp;amp;mid=2247485276&amp;amp;idx=1&amp;amp;sn=b43b9218140cbf0f9e8e43d0b26227a4&amp;amp;chksm=f9dafa77cead7361906c70861ae9f71b8a219daff14fa86491e838788fb8596acd53f853ad9d&amp;amp;token=1225167937&amp;amp;lang=zh_CN#rd&quot;&gt;LeetCode 62: 想到动态规划就无敌了？这道题还有更牛的解法&lt;/a&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们套用一下62题的思路，其中动态规划的解法是完全适用的。路障的存在只会影响路障的点本身以及它附近可以转移到的点，对于它本身而言，它无法到达，自然可访问的路径数就是0。而对于它转移到的点来说，这点无法访问，自然贡献也是0。所以我们只需要在转移的过程当中将路障的位置置为0即可。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;而通过排列组合求解答案的方法就无法使用了，因为路障和路障之间会有影响，所以我们没有办法仅仅通过排列组合就求出起点到路障处的路径数量，也无法确定这个路障对于总体路径数量带来的变化量，更无法确定路障是否有把所有通路堵死。这些点之间互相影响，仅仅通过数学很难计算，所以不太方便使用。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以我们只能通过动态规划来求解，这段代码和上一题的几乎也一样，只不过做了一点细微的改动，加上了路障的判断。&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;uniquePathsWithObstacles&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, obstacleGrid: List[List[int]])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;
        n, m = len(obstacleGrid), len(obstacleGrid[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])
        
        dp = [[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(m+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)] &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(n+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)]
        
        dp[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, n+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;):
            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, m+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;):
               
                &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; obstacleGrid[i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;][j&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;] == &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;:
                    dp[i][j] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
                &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt;:
                    dp[i][j] = dp[i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;][j] + dp[i][j&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;]
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; dp[n][m]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这题看着简单，代码想要一次性写对不容易，有一个坑点是我们dp数组维护的下标范围和题目给定的路障数组的下标是不一样的，我们设置了下标从1开始，这样可以不用考虑转移时数组越界的问题。既然下标设置从1开始，我们在判断对应位置是否是路障的时候，就需要i和j都-1。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们继续看下一题。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;Minimum Path Sum&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;题意同样是机器人走矩形迷宫，不过稍有不同的是，这一题当中加上了路径长度的判断，我们从起点开始，每到一个点都会有一个消耗。现在我们想要让机器人从起点到达终点，所需要的最小消耗。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;样例&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;Input:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
Output: 7
Explanation: Because the path 1→3→1→1→1 minimizes the sum.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果你理解了上面一题的思路来做这题，几乎是秒杀的，因为解题的思路完全一样，只不过是我们dp数组当中维护不再是到每个点的路径数量，而是起点开始到这个点最小的距离。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于每一个点i,j来说，它有两个来源，分别是i-1,j 和i, j-1。状态转移方程就是&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=dp[i][j]%20=%20min(dp[i][j-1],%20dp[i-1][j])+%20cost[i][j]&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;。这里的cost数组也就是题目给的每个点的花费。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们直接来看代码：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt;:&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;minPathSum&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(self, grid: List[List[int]])&lt;/span&gt; -&amp;gt; int:&lt;/span&gt;
        n = len(grid)
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; n == &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;:
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
        m = len(grid[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;])
        
        
        dp = [[&lt;span class=&quot;hljs-number&quot;&gt;0x3f3f3f3f&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(m+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)] &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; _ &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(n+&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;)]
        
        
        dp[&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;] = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, n+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;):
            &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; j &lt;span class=&quot;hljs-keyword&quot;&gt;in&lt;/span&gt; range(&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, m+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;):
               
                dp[i][j] = min(dp[i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;][j], dp[i][j&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;]) + grid[i&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;][j&lt;span class=&quot;hljs-number&quot;&gt;-1&lt;/span&gt;]
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; dp[n][m]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里我们用了一个巧妙的方法，我们令&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=dp[0][1]%20=%200&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;，这是为了给&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=dp[1][1]&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;一个消耗为0的入口。这样当我们执行&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=min(dp[0][1],%20dp[1][0])&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;的时候，就会获得0，这样&lt;span class=&quot;span-inline-equation&quot;&gt;&lt;span&gt;&lt;img class=&quot;equation&quot; src=&quot;https://juejin.im/equation?tex=dp[1][1]%20=%20cost[1][1]&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;就会自动完成，就不用我们在循环当中进行特判了。当然使用 if 特判也是可以的，但是这样写感觉更简洁一些。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;结尾&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;到这里，关于LeetCode 63和64两题就做完了，是不是很轻松呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在这两题的代码当中我们用到了两个技巧，一个是为了防止dp的时候超界，而进行大量的判断，从而移动下标的技巧。另一个技巧是人为给初始位置提供一个初始选择入口的技巧。有了这两个技巧，可以大大简化我们编码的复杂度。不然你可能需要写很多额外的逻辑来特殊处理一些边界情况，这些边界情况往往复杂并且容易出错，因此能够避免是再好不过了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;今天的文章就到这里，原创不易，&lt;strong&gt;扫码关注我&lt;/strong&gt;，获取更多精彩文章。&lt;/p&gt;
</description>
<pubDate>Tue, 19 May 2020 00:11:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是LeetCode的37篇，我们继续愉快的刷题。今天要刷的题目输出LeetCode 63和64两题，分别是Unique Paths</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12914735.html</dc:identifier>
</item>
<item>
<title>解读银行卡支付背后的原理 - 楼下小黑哥</title>
<link>http://www.cnblogs.com/goodAndyxublog/p/12914676.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodAndyxublog/p/12914676.html</guid>
<description>&lt;p&gt;上次写了一篇『&lt;a href=&quot;https://mp.weixin.qq.com/s/De71w6C49YJJb_VXeLL0vw&quot;&gt;轻轻一扫，立刻扣款，付款码背后的原理你不想知道吗&lt;/a&gt;』 ，本以为这类文章没什么会看，没想到发布之后，阅读量数据还不错。那么今天小黑哥再来跟大家聊聊支付。&lt;/p&gt;
&lt;p&gt;虽然现在我们主流的支付方式是使用支付宝/微信支付，但是当我们余额不足，或者选择从银行卡扣款时，将就会使用到银行卡支付。&lt;/p&gt;
&lt;p&gt;所以今天我们就来来讲讲银行卡支付的相关原理，科普一下银行卡支付整个流程。&lt;/p&gt;
&lt;p&gt;银行卡支付可以将其分为线上支付与线下支付。其中线下支付分类就比较简单，就是我们平常在商城购物时，POS 机刷卡支付。&lt;/p&gt;
&lt;p&gt;而线上支付分类就比较多了，根据银行卡类别，可以分为信用卡支付与借记卡支付。按照支付行为，我们又可以将其分为快捷支付，网银支付，Token 支付。&lt;/p&gt;
&lt;p&gt;今天我们主要来聊聊快捷支付与网银支付，这两种方式是目前比较流行的方式。其他几种方式，我们可以后面再来聊聊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200519071024554-2009321892.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;网银支付&quot;&gt;网银支付&lt;/h2&gt;
&lt;p&gt;首先我们来聊聊网银支付，这种方式在 10 年前，应该是最主流线上支付方式。&lt;/p&gt;
&lt;p&gt;我们以电商购物为例，我们在网站上下单之后，选择银行卡支付通常会跳转到一个收银台页面。然后在收银台页面我们选择相关银行，点击到银行支付最后将会跳转到相应的银行页面。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这个收银台页面可能是商户的页面，也可能是支付机构的页面，这个跟网银支付对接模式有关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;跳转到银行页面之后，我们首先需要下载按照银行安全控件，这样我们才能输入银行卡的相关信息。其次我们还需要使用银行给的安全设备，比如 USB 盾，令牌器，令牌码等。&lt;/p&gt;
&lt;p&gt;在银行网站支付成功之后，就可以点击返回同步跳回到电商的网站，整个流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200519071024773-1530158438.jpg&quot; alt=&quot;网银支付流程&quot;/&gt;&lt;/p&gt;
&lt;p&gt;后台支付流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200519071025365-816049808.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到网银支付整个链路非常长，任何一步都可能发生失败，所以支付成功率不会很高。另外有部分银行网银页面只能在 IE 中打开，而且还有可能是很老版本的 IE。再加上网银支付为了保证安全性，还需要使用 U 盾，安装安全插件。&lt;/p&gt;
&lt;p&gt;这个过程说实话还是很复杂，还记得当年使用某行网银充值购买黄钻的时候，搞了一下午都没成功的，各种证书安装失败啥的。第一次在线充值，就这么失败告终。&lt;/p&gt;
&lt;p&gt;感谢某行为我省下 10 元零花钱~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200519071025607-1336400658.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;快捷支付&quot;&gt;快捷支付&lt;/h2&gt;
&lt;p&gt;快捷支付，指的用户提供卡信息给电商等商户，商户会在后台将卡信息传递给支付机构，然后进行协议绑定。一旦绑定成功，下次支付，无需再让用户提供卡号等信息。&lt;/p&gt;
&lt;p&gt;还是以电商购物支付为例，首次支付，需要经历绑卡过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200519071025890-1003361164.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;扣款成功之后，前往银行 APP 可以查到该卡与支付机构绑定记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200519071026203-1746966302.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;历次在电商网站下单支付时，由于电商网站已保存记录，所以无需再输入卡信息。历次支付流程如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200519071026374-1493881344.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图展示历次支付过程还需要输入验证码的情况，这一步其实还可以做到一定额度的免密支付。&lt;/p&gt;
&lt;p&gt;快捷支付接口一般可以归为两类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;签约/支付&lt;/li&gt;
&lt;li&gt;代扣支付&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;签约支付&quot;&gt;签约/支付&lt;/h3&gt;
&lt;p&gt;签约/支付需要分为两个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;签约申请/签约验证&lt;/li&gt;
&lt;li&gt;支付&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;签约过程需要传入银行卡信息，银行卡号，户名，身份证号，手机号，信用卡的话可能还需要传入 cvv2 以及有效期。这个过程主要是为了鉴权，校验银行卡信息的正确性。&lt;/p&gt;
&lt;p&gt;一旦支付机构/银行端信息校验成功，将会下发短信。用户回填短信，就代表同意开通快捷支付，建立绑定关系。绑定成功之后，支付机构将会返回给商户&lt;strong&gt;协议号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;支付过程，商户就可以拿着协议号进行扣款。&lt;/p&gt;
&lt;p&gt;整个后台流程如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200519071026578-964724064.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;代扣支付&quot;&gt;代扣支付&lt;/h3&gt;
&lt;p&gt;代扣支付的过程相比签约/支付就比较简单，每次直接上送银行卡信息，就可以直接扣款。代扣支付原则上可以做到整个过程无密支付，即不需输入验证码，完成扣款。&lt;/p&gt;
&lt;p&gt;流程较为简单，详情可以参考快捷支付支付过程。&lt;/p&gt;
&lt;p&gt;相比于签约/支付过程，代扣支付看起来更快捷，但是这种方式安全风险就会比签约支付大，可能就会出现盗刷现象。原本代扣接口本应适用于水电煤等扣费场景，但是发展过程一度被用于金融支付等场景。&lt;/p&gt;
&lt;p&gt;现在这类接口正在慢慢下线，正在被新的商业委托接口（类似于签约/支付）所代替。&lt;/p&gt;
&lt;p&gt;虽然快捷支付支付体验好，整个流程无需跳转到银行页面，支付过程不会被打断，支付成功率高。&lt;/p&gt;
&lt;p&gt;但是易用跟安全性，永远都是矛盾。由于这个过程用户向商户提供银行卡相关信息，这些数据如果一旦被窃取，资金就可能会被盗取。另外，快捷支付，手机验证码可能是最后一道防线，手机如果丢失，那么银行卡资金也可能被盗取。&lt;/p&gt;
&lt;h2 id=&quot;银行支付相关问题&quot;&gt;银行支付相关问题&lt;/h2&gt;
&lt;p&gt;总得来说，对接银行卡支付渠道，整个过程不是很难的，无非就是按照接口文档，拼接参数，然后做一些相应的调试。但是这个过程有些点需要特别注意。&lt;/p&gt;
&lt;h3 id=&quot;加签验签&quot;&gt;加签/验签&lt;/h3&gt;
&lt;p&gt;银行卡支付一般通过互联网传输，这个过程为了防止报文被串改，通常会采用 RSA2 ，国密等加密算法加密报文，得到签名串，然后一起上送给支付机构。&lt;/p&gt;
&lt;p&gt;支付机构方会进行相应的验签，验签失败，就会驳回支付请求，这样可以有效保证支付请求是从合法商户发起。所以对于商户来说，一定要保存好相应公私钥，不要随意泄漏。&lt;/p&gt;
&lt;p&gt;另外，对于支付请求的响应信息/网银结果异步通知，支付机构端也会进行加签。商户端一定要进行&lt;strong&gt;验签&lt;/strong&gt;，只有验签通过才能进行下一步。&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;ps:发送请求由于不加签，交易无法进行，所以这一步肯定会做的。&lt;/p&gt;
&lt;p&gt;但是返回信息你不进行验签，也能处理报文，这个可能就会被忽略。&lt;/p&gt;
&lt;p&gt;我第一次对接相关支付渠道的时候，嫌麻烦，就没进行验签。现在想想，真的是心大。。。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;终态判定&quot;&gt;终态判定&lt;/h3&gt;
&lt;p&gt;对于快捷支付这类同步接口，对于支付接口请求响应消息，我们需要判定请求是否成功，需要根据接口返回的响应码。有些接口也可能返回响应码与支付状态，那么我们就需要根据两者结合起来一起判断。&lt;/p&gt;
&lt;p&gt;这个过程，不是说除了成功的响应码之外，其他都算失败。我们需要根据相关的接口文档进行相应的分类，有些如余额不足，卡要素不正确等错误码，当然可以明确归类为失败。&lt;/p&gt;
&lt;p&gt;但是比如一些处理中，或者系统异常等返回码，这种无法明确到底是成功还是失败的，我们不能置为失败，需要结合支付查询或者异步通知结果，然后在做处理。&lt;/p&gt;
&lt;p&gt;对于网银支付这类同步接口，这类只能等待渠道端的异步通知。一般来说，渠道端只会通知的成功的支付订单。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这个具体根据渠道端接口文档。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一般来说渠道异步通知接口，若没有给渠道端异步通知返回成功响应，该通知将会重复通知，直到到达一定次数或者得到成功的相应。&lt;/p&gt;
&lt;p&gt;所以接受到异步通知之后，&lt;strong&gt;一定要内部逻辑处理成功之后&lt;/strong&gt;，才能返回成功响应码给渠道端。这样即使内部逻辑处理错误，还能再次通过异步通知处理内部逻辑。&lt;/p&gt;
&lt;p&gt;另外还需要注意内部处理逻辑的&lt;strong&gt;幂等性&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;请求参数相关&quot;&gt;请求参数相关&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;支付金额&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;请求过程一定要注意接口文档中支付&lt;strong&gt;金额的单位&lt;/strong&gt;，是分，还是元。如果不注意单位，很有可能造成少收，多收的情况。&lt;/p&gt;
&lt;p&gt;对于成功响应的信息，我们还需要注意校验上送金额与扣款金额（如果有返回的话）一致性。如果不一致，&lt;strong&gt;一定不要将订单更新为成功，&lt;/strong&gt;及时人工介入查单。&lt;/p&gt;
&lt;p&gt;最后支付渠道上线之后，还需要做一些真实扣款，比如小额 0.1,渠道最大额度测试。扣款成功之后，还要及时查看银行卡真实扣款金额是否与上送金额一致。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;原因见下文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;请求流水号(订单号)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了支付金额，我们还需要注意请求流水号/订单号唯一性，需要使用&lt;strong&gt;唯一 id&lt;/strong&gt; 当做请求流水号，切勿使用时间戳等方式。&lt;/p&gt;
&lt;p&gt;对于重复流水号，如果未成功，是允许重复支付的。如果成功，不允许再次支付的。但是也不乏有些机构接口没做好这部分校验。&lt;/p&gt;
&lt;p&gt;举一个自己趟过的坑，一个几万的教训。之前对对接过某银行的系统，测试的时候为了方便，直接采用时间戳当流水号。&lt;/p&gt;
&lt;p&gt;上线时未及时发现这个问题，某天恰好同一秒产生两笔流水号一样的单子，上送给银行。然后对方返回两笔都收款成功，但是第二天对账时发现仅收到一笔单子的资金。所幸最后通过人工追回这笔资金，不然当时卖了我，也赔不起啊。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200519071026753-560207240.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;虽然这个例子银行端肯定也是存在问题的，未做防重处理，但是只要我们做好唯一流水号的逻辑，也能避免该问题。&lt;/p&gt;
&lt;h3 id=&quot;真实惨痛例子&quot;&gt;真实惨痛例子&lt;/h3&gt;
&lt;p&gt;上面注意的问题聊了这么多，其实想引起对接渠道技术同学注意。不要片面认为支付机构或银行等系统很稳，不会有问题。&lt;/p&gt;
&lt;p&gt;程序毕竟是人写的，一次升级改动，就有可能引起血崩。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200519071026886-1044429272.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以不要过分相信对方系统的稳定性，我们能做的就是做好我们自己系统的稳定性，加入各种参数校验，尽量降低风险的发生。&lt;/p&gt;
&lt;p&gt;给大家举几个惨痛的例子：&lt;/p&gt;
&lt;p&gt;曾经对接过某银行，小额测试，完全没问题。但是我们在测试限额的时候，比如说限额 1000 元，我们测试 1000.01 的时候，讲道理这笔支付应该会失败。&lt;/p&gt;
&lt;p&gt;但是这笔扣款成功了，并且查看银行扣款记录，仅仅只扣了 0.01 。&lt;/p&gt;
&lt;p&gt;看到这个，你是否有很多问号？？？这 TM 竟然发生限额溢出。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200519071027195-1776107807.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哎，这种问题，只能紧急下线该渠道，然后等待银行端修复。&lt;/p&gt;
&lt;p&gt;最后再举几个来自网上的例子，关于支付的漏洞。&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://wooyun.js.org/drops/&quot;&gt;https://wooyun.js.org/drops/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1419561/202005/1419561-20200519071027768-1101605862.png&quot; alt=&quot;来源：https://wooyun.js.org/drops/在线支付逻辑漏洞总结.html&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;今天我们主要聊了下银行卡支线上支付的两种主流模式，快捷支付与网银支付。&lt;/p&gt;
&lt;p&gt;快捷支付目前是现在最主流银行卡支付方式，因为使用体验最好，支付流程不易被打断。但是该模式相对来说安全性较低。不过现在支付机构端与银行端会有相应的风控手段，大家不用过分担心。&lt;/p&gt;
&lt;p&gt;另外一点快捷支付，一般额度较小，通常最高额度可能只有几万。&lt;/p&gt;
&lt;p&gt;所以对于支付金额较大的场景，只能采用网银支付这种方案。&lt;/p&gt;
&lt;p&gt;最后聊了下银行卡支付对接过程中一些问题，有些例子，可以集成到测试案例中。每当对接一个渠道时，就可以按照案例执行。&lt;/p&gt;
&lt;h2 id=&quot;最后（求关注，求点赞，求转发）&quot;&gt;最后（求关注，求点赞，求转发）&lt;/h2&gt;
&lt;p&gt;支付系列的文章，小黑哥已经更新几篇，历史文章可以查看下面相关阅读。&lt;/p&gt;
&lt;p&gt;后续，小黑哥还会更新几篇，聊聊支付宝/微信支付相关支付方式，聊聊支付过程中重复扣款等等。&lt;/p&gt;
&lt;p&gt;如果各位同学还想了解其他支付相关的话题，可以在评论区留言。&lt;/p&gt;
&lt;h2 id=&quot;相关阅读&quot;&gt;相关阅读&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/De71w6C49YJJb_VXeLL0vw&quot;&gt;支付宝/微信支付付款码原理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/leJyjudXr0xswSXOvKTmLg&quot;&gt;微信/支付宝支付的相关概念&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Det95SU1u1dDH7nT_B1XEQ&quot;&gt;多支付渠道路由方法&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/NujSkFrZTXqqeTTpbxTwtQ&quot;&gt;余额更新踩坑经历&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/bW7pUzC3hB4eNzVd3JIi4A&quot;&gt;聊聊银企直联服务那些事&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/47s0YdRM6u1JNngNe6yghg&quot;&gt;对账系统的设计方案&lt;/a&gt;&lt;br/&gt;未完待续...&lt;/p&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;http://www.woshipm.com/pd/477150.html&quot;&gt;http://www.woshipm.com/pd/477150.html&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5.5384615384615&quot;&gt;
&lt;p&gt;欢迎关注我的公众号：程序通事，获得日常干货推送。如果您对我的专题内容感兴趣，也可以关注我的博客：&lt;a href=&quot;https://studyidea.cn&quot;&gt;studyidea.cn&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 18 May 2020 23:10:00 +0000</pubDate>
<dc:creator>楼下小黑哥</dc:creator>
<og:description>上次写了一篇『 &amp;quot;轻轻一扫，立刻扣款，付款码背后的原理你不想知道吗&amp;quot; 』 ，本以为这类文章没什么会看，没想到发布之后，阅读量数据还不错。那么今天小黑哥再来跟大家聊聊支付。 虽然现在</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodAndyxublog/p/12914676.html</dc:identifier>
</item>
<item>
<title>线上Kafka突发rebalance异常，如何快速解决？ - 陈树义</title>
<link>http://www.cnblogs.com/chanshuyi/p/kafka_rebalance_quick_guide.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chanshuyi/p/kafka_rebalance_quick_guide.html</guid>
<description>&lt;p&gt;Kafka 是我们最常用的消息队列，它那几万、甚至几十万的处理速度让我们为之欣喜若狂。但是随着使用场景的增加，我们遇到的问题也越来越多，其中一个经常遇到的问题就是：rebalance（重平衡）问题。&lt;/p&gt;
&lt;h2 id=&quot;什么是消费组&quot;&gt;什么是消费组&lt;/h2&gt;
&lt;p&gt;要想了解 rebalance，那就得先了解消费组（consumer group）。&lt;/p&gt;
&lt;p&gt;消费组指的是多个消费者（consumer）组成起来的一个组，它们共同消费 topic 的所有消息，并且一个 topic 的一个 partition 只能被一个 consumer 消费。&lt;/p&gt;
&lt;p&gt;Kafka 为消费者组定义了 5 种状态，它们分别是：Empty、Dead、PreparingRebalance、CompletingRebalance 和 Stable。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15892444057803.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;了解了这些状态的含义之后，我们来看一张图片，它展示了状态机的各个状态流转。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15892444207503.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一个消费者组最开始是 Empty 状态，当重平衡过程开启后，它会被置于 PreparingRebalance 状态等待成员加入，之后变更到 CompletingRebalance 状态等待分配方案，最后流转到 Stable 状态完成重平衡。&lt;/p&gt;
&lt;p&gt;当有新成员加入或已有成员退出时，消费者组的状态从 Stable 直接跳到 PreparingRebalance 状态，此时，所有现存成员就必须重新申请加入组。当所有成员都退出组后，消费者组状态变更为 Empty。Kafka 定期自动删除过期位移的条件就是，组要处于 Empty 状态。因此，如果你的消费者组停掉了很长时间（超过 7 天），那么 Kafka 很可能就把该组的位移数据删除了。我相信，你在 Kafka 的日志中一定经常看到下面这个输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Removed ✘✘✘ expired offsets in ✘✘✘ milliseconds.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是 Kafka 在尝试定期删除过期位移。现在你知道了，只有 Empty 状态下的组，才会执行过期位移删除的操作。&lt;/p&gt;
&lt;h2 id=&quot;什么是rebalance？&quot;&gt;什么是rebalance？&lt;/h2&gt;
&lt;p&gt;我们都知道 kafka 主要可以分为三大块：生产者、kafka broker、消费者。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15891592181787.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;而 kafka 怎么均匀地分配某个 topic 下的所有 partition 到各个消费者，从而使得消息的消费速度达到最快，这就是平衡（balance）。&lt;strong&gt;而 rebalance（重平衡）其实就是重新进行 partition 的分配，从而使得 partition 的分配重新达到平衡状态。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;rebalance的流程&quot;&gt;rebalance的流程&lt;/h2&gt;
&lt;p&gt;重平衡的完整流程需要消费者端和协调者组件共同参与才能完成。我们先从消费者的视角来审视一下重平衡的流程。&lt;/p&gt;
&lt;p&gt;在消费者端，重平衡分为两个步骤：分别是加入组和等待领导消费者（Leader Consumer）分配方案。这两个步骤分别对应两类特定的请求：&lt;strong&gt;JoinGroup 请求和 SyncGroup 请求。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;joingroup请求&quot;&gt;JoinGroup请求&lt;/h3&gt;
&lt;p&gt;当组内成员加入组时，它会向协调者发送 JoinGroup 请求。在该请求中，每个成员都要将自己订阅的主题上报，这样协调者就能收集到所有成员的订阅信息。一旦收集了全部成员的 JoinGroup 请求后，协调者会从这些成员中选择一个担任这个消费者组的领导者。&lt;/p&gt;
&lt;p&gt;通常情况下，第一个发送 JoinGroup 请求的成员自动成为领导者。你一定要注意区分这里的领导者和之前我们介绍的领导者副本，它们不是一个概念。这里的领导者是具体的消费者实例，它既不是副本，也不是协调者。这里的领导者指的是消费组（consumer group）的领导者，&lt;strong&gt;消费组领导者的任务是收集所有成员的订阅信息，然后根据这些信息，制定具体的分区消费分配方案。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;选出领导者之后，协调者会把消费者组订阅信息封装进 JoinGroup 请求的响应体中，然后发给领导者，由领导者统一做出分配方案后，进入到下一步：发送 SyncGroup 请求。&lt;/p&gt;
&lt;h3 id=&quot;syncgroup请求&quot;&gt;SyncGroup请求&lt;/h3&gt;
&lt;p&gt;在这一步中，领导者向协调者发送 SyncGroup 请求，将刚刚做出的分配方案发给协调者。值得注意的是，其他成员也会向协调者发送 SyncGroup 请求，只不过请求体中并没有实际的内容。这一步的主要目的是让协调者接收分配方案，然后统一以 SyncGroup 响应的方式分发给所有成员，这样组内所有成员就都知道自己该消费哪些分区了。&lt;/p&gt;
&lt;p&gt;接下来，我用一张图来形象地说明一下 JoinGroup 请求的处理过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15892437016869.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就像前面说的，JoinGroup 请求的主要作用是将组成员订阅信息发送给领导者消费者，待领导者制定好分配方案后，重平衡流程进入到 SyncGroup 请求阶段。&lt;/p&gt;
&lt;p&gt;下面这张图描述的是 SyncGroup 请求的处理流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15892437578771.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;SyncGroup 请求的主要目的，就是让协调者把领导者制定的分配方案下发给各个组内成员。当所有成员都成功接收到分配方案后，消费者组进入到 Stable 状态，即开始正常的消费工作。&lt;/p&gt;
&lt;h2 id=&quot;什么时候会发生rebalance？&quot;&gt;什么时候会发生rebalance？&lt;/h2&gt;
&lt;p&gt;前面我们已经说到，rebalance 其实就是对 partition 进行重新分配。那么什么时候会发生 rebalance 呢？其实在以下三种情况下，会触发 rebalance：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;订阅 Topic 的分区数发生变化。&lt;/li&gt;
&lt;li&gt;订阅的 Topic 个数发生变化。&lt;/li&gt;
&lt;li&gt;消费组内成员个数发生变化。例如有新的 consumer 实例加入该消费组或者离开组。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;订阅topic的分区数发生变化&quot;&gt;订阅Topic的分区数发生变化&lt;/h3&gt;
&lt;p&gt;简单地说，就是之前 topic 有 10 个分区，现在变成了 20 个，那么多出来的 10 个分区的数据就没人消费了。那么此时就需要进行重平衡，将新增的 10 个分区分给消费组内的消费者进行消费。所以在这个情况下，会发生重平衡。&lt;/p&gt;
&lt;h3 id=&quot;订阅的topic个数发生变化&quot;&gt;订阅的Topic个数发生变化&lt;/h3&gt;
&lt;p&gt;简单地说，一个 consumer group 如果之前只订阅了 A topic，那么其组内的 consumer 知会消费 A topic 的消息。而如果现在新增订阅了 B topic，那么 kafka 就需要把 B topic 的 partition 分配给组内的 consumer 进行消费。这个分配的过程，其实也是一个 rebalance 的过程。&lt;/p&gt;
&lt;h3 id=&quot;消费组内成员个数发生变化&quot;&gt;消费组内成员个数发生变化&lt;/h3&gt;
&lt;p&gt;我们都知道 kafka 中是以消费组（consumer group）的方式进行消费的，消费组内的消费者共同消费一个 topic 下的消息。而当消费组内成员个数发生变化，例如某个 consumer 离开，或者新 consumer 加入，都会导致消费组内成员个数发生变化，从而导致重平衡。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相比起之前的两个情况，这种情况在实际情况中更加常见。因为订阅分区数、以及订阅 topic 数都是我们主动改变才会发生，而组内消费组成员个数发生变化，则是更加随机的。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;下面我们一起分析一下「消费组内成员个数发生变化」的几种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新成员加入&lt;/li&gt;
&lt;li&gt;组成员主动离开&lt;/li&gt;
&lt;li&gt;组成员崩溃&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;新成员加入&quot;&gt;新成员加入&lt;/h4&gt;
&lt;p&gt;新成员入组是指组处于 Stable 状态后，有新成员加入。如果是全新启动一个消费者组，Kafka 是有一些自己的小优化的，流程上会有些许的不同。我们这里讨论的是，组稳定了之后有新成员加入的情形。&lt;/p&gt;
&lt;p&gt;当协调者收到新的 JoinGroup 请求后，它会通过心跳请求响应的方式通知组内现有的所有成员，强制它们开启新一轮的重平衡。具体的过程和之前的客户端重平衡流程是一样的。现在，我用一张时序图来说明协调者一端是如何处理新成员入组的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15892432564564.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;组成员主动离开&quot;&gt;组成员主动离开&lt;/h4&gt;
&lt;p&gt;何谓主动离组？就是指消费者实例所在线程或进程调用 close() 方法主动通知协调者它要退出。这个场景就涉及到了第三类请求：LeaveGroup 请求。协调者收到 LeaveGroup 请求后，依然会以心跳响应的方式通知其他成员，因此我就不再赘述了，还是直接用一张图来说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15892438535570.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;组成员崩溃&quot;&gt;组成员崩溃&lt;/h4&gt;
&lt;p&gt;崩溃离组是指消费者实例出现严重故障，突然宕机导致的离组。它和主动离组是有区别的，因为后者是主动发起的离组，协调者能马上感知并处理。但崩溃离组是被动的，协调者通常需要等待一段时间才能感知到，这段时间一般是由消费者端参数 session.timeout.ms 控制的。&lt;/p&gt;
&lt;p&gt;也就是说，Kafka 一般不会超过 session.timeout.ms 就能感知到这个崩溃。当然，后面处理崩溃离组的流程与之前是一样的，我们来看看下面这张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15892439595340.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;疑惑&quot;&gt;疑惑&lt;/h4&gt;
&lt;p&gt;在许多文章中，它们会加多了一个 rebalance 场景，即：「重平衡时协调者对组内成员提交位移的处理」。其实这个要说是 rebalance 场景，有点牵强。我们先来了解下这个场景究竟是什么情况。&lt;/p&gt;
&lt;p&gt;正常情况下，每个组内成员都会定期汇报位移给协调者。当重平衡开启时，协调者会给予成员一段缓冲时间，要求每个成员必须在这段时间内快速地上报自己的位移信息，然后再开启正常的 JoinGroup/SyncGroup 请求发送。还是老办法，我们使用一张图来说明。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www-shuyi-me.oss-cn-shenzhen.aliyuncs.com/15892440922259.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以这种场景是指 rebalance 发生之时，留有时间给消费者提交 offset，并不是引起 rebalance 的触发原因（并不是因为提交 offset 引发 rebalance）。因此在我这篇文章里，我并没有将其作为 rebalance 的一种场景。&lt;/p&gt;
&lt;h2 id=&quot;rebalance问题处理思路&quot;&gt;rebalance问题处理思路&lt;/h2&gt;
&lt;p&gt;前面我们讲过 rebalance 一般会有 3 种情况，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;新成员加入&lt;/li&gt;
&lt;li&gt;组成员主动离开&lt;/li&gt;
&lt;li&gt;组成员崩溃&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于「新成员加入」、「组成员主动离开」都是我们主动触发的，能比较好地控制。但是「组成员崩溃」则是我们预料不到的，遇到问题的时候也比较不好排查。但对于「组成员崩溃」也是有一些通用的排查思路的，下面我们就来聊聊「rebalance问题的处理思路」。&lt;/p&gt;
&lt;p&gt;要学会处理 rebalance 问题，我们需要先搞清楚 kafaka 消费者配置的四个参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;session.timeout.ms 设置了超时时间&lt;/li&gt;
&lt;li&gt;heartbeat.interval.ms 心跳时间间隔&lt;/li&gt;
&lt;li&gt;max.poll.interval.ms 每次消费的处理时间&lt;/li&gt;
&lt;li&gt;max.poll.records 每次消费的消息数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;session.timeout.ms&lt;/strong&gt; 表示 consumer 向 broker 发送心跳的超时时间。例如 session.timeout.ms = 180000 表示在最长 180 秒内 broker 没收到 consumer 的心跳，那么 broker 就认为该 consumer 死亡了，会启动 rebalance。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;heartbeat.interval.ms&lt;/strong&gt; 表示 consumer 每次向 broker 发送心跳的时间间隔。heartbeat.interval.ms = 60000 表示 consumer 每 60 秒向 broker 发送一次心跳。一般来说，session.timeout.ms 的值是 heartbeat.interval.ms 值的 3 倍以上。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;max.poll.interval.ms&lt;/strong&gt; 表示 consumer 每两次 poll 消息的时间间隔。简单地说，其实就是 consumer 每次消费消息的时长。如果消息处理的逻辑很重，那么市场就要相应延长。否则如果时间到了 consumer 还么消费完，broker 会默认认为 consumer 死了，发起 rebalance。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;max.poll.records&lt;/strong&gt; 表示每次消费的时候，获取多少条消息。获取的消息条数越多，需要处理的时间越长。所以每次拉取的消息数不能太多，需要保证在 max.poll.interval.ms 设置的时间内能消费完，否则会发生 rebalance。&lt;/p&gt;
&lt;p&gt;简单来说，会导致崩溃的几个点是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;消费者心跳超时，导致 rebalance。&lt;/li&gt;
&lt;li&gt;消费者处理时间过长，导致 rebalance。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;消费者心跳超时&quot;&gt;消费者心跳超时&lt;/h3&gt;
&lt;p&gt;我们知道消费者是通过心跳和协调者保持通讯的，如果协调者收不到心跳，那么协调者会认为这个消费者死亡了，从而发起 rebalance。&lt;/p&gt;
&lt;p&gt;而 kafka 的消费者参数设置中，跟心跳相关的两个参数为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;session.timeout.ms 设置了超时时间&lt;/li&gt;
&lt;li&gt;heartbeat.interval.ms 心跳时间间隔&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这时候需要调整 session.timeout.ms 和 heartbeat.interval.ms 参数，使得消费者与协调者能保持心跳。一般来说，超时时间应该是心跳间隔的 3 倍时间。即 session.timeout.ms 如果设置为 180 秒，那么 heartbeat.interval.ms 最多设置为 60 秒。&lt;/p&gt;
&lt;p&gt;为什么要这么设置超时时间应该是心跳间隔的 3 倍时间？因为这样的话，在一个超时周期内就可以有多次心跳，避免网络问题导致偶发失败。&lt;/p&gt;
&lt;h3 id=&quot;消费者处理时间过长&quot;&gt;消费者处理时间过长&lt;/h3&gt;
&lt;p&gt;如果消费者处理时间过长，那么同样会导致协调者认为该 consumer 死亡了，从而发起重平衡。&lt;/p&gt;
&lt;p&gt;而 kafka 的消费者参数设置中，跟消费处理的两个参数为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;max.poll.interval.ms 每次消费的处理时间&lt;/li&gt;
&lt;li&gt;max.poll.records 每次消费的消息数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于这种情况，&lt;strong&gt;一般来说就是增加消费者处理的时间（即提高 max.poll.interval.ms 的值），减少每次处理的消息数（即减少 max.poll.records 的值）。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除此之外，超时时间参数（session.timeout.ms）与 消费者每次处理的时间（max.poll.interval.ms）也是有关联的。&lt;strong&gt;max.poll.interval.ms 时间不能超过 session.timeout.ms 时间。&lt;/strong&gt; 因为在 kafka 消费者的实现中，其是单线程去消费消息和执行心跳的，如果线程卡在处理消息，那么这时候即使到时间要心跳了，还是没有线程可以去执行心跳操作。很多同学在处理问题的时候，明明设置了很长的 session.timeout.ms 时间，但最终还是心跳超时了，就是因为没有处理好这两个参数的关联。&lt;/p&gt;
&lt;p&gt;对于 rebalance 类问题，简单总结就是：&lt;strong&gt;处理好心跳超时问题和消费处理超时问题&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于心跳超时问题。一般是调高心跳超时时间（session.timeout.ms），调整超时时间（session.timeout.ms）和心跳间隔时间（heartbeat.interval.ms）的比例。阿里云官方文档建议超时时间（session.timeout.ms）设置成 25s，最长不超过 30s。那么心跳间隔时间（heartbeat.interval.ms）就不超过 10s。&lt;/li&gt;
&lt;li&gt;对于消费处理超时问题。一般是增加消费者处理的时间（max.poll.interval.ms），减少每次处理的消息数（max.poll.records）。阿里云官方文档建议 max.poll.records 参数要远小于当前消费组的消费能力（records &amp;lt; 单个线程每秒消费的条数 x 消费线程的个数 x session.timeout的秒数）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
</description>
<pubDate>Mon, 18 May 2020 22:59:00 +0000</pubDate>
<dc:creator>陈树义</dc:creator>
<og:description>文章首发于 &amp;quot;【陈树义的博客】&amp;quot; ，点击跳转到原文 &amp;quot;《线上Kafka突发rebalance异常，如何快速解决？》&amp;quot; Kafka 是我们最常用的消息队列，它那几</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chanshuyi/p/kafka_rebalance_quick_guide.html</dc:identifier>
</item>
<item>
<title>智慧城市交通的要素：路口监管可视化系统的解决方案 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/12896492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/12896492.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200515132611089-2012359213.gif&quot; class=&quot;desc_img&quot;/&gt; 随着信息时代的发展变迁，荧幕里呈现的智慧城市慢慢出现了在现实生活中，很大程度上便利了日常的管理和维护。在智慧城市的大背景下，智慧交通监管可视化系统是其重要的组成部分，通过一条条道路监控的串联，引申出一座智慧城市的管控，而在众多数据的维护中，实时数据、设备状态以及视频监控是极为重要的。其中视频监控一直是作为主体的部分，而在互联网和物联网齐头并进的形式下，“中国天网”应运而生，这其实是一项城市监控系统，但它不是个仅一台摄像头的设备，而是足足有1.7亿个监控摄像头，而在未来三年内，还将再安装4亿个摄像头。介于 2D 组态和 3D 组态上，Hightopo（以下简称 HT ）的 HT for Web 产品上的有着丰富的组态化可供选择，本文将介绍如何运用 HT 丰富的 2/3D 组态搭建出一个路口监控系统的解决方案。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;173.58371282528&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;随着信息时代的发展变迁，荧幕里呈现的&lt;strong&gt;智慧城市&lt;/strong&gt;慢慢出现了在现实生活中，很大程度上便利了日常的管理和维护。在智慧城市的大背景下，&lt;strong&gt;智慧交通监管可视化系统&lt;/strong&gt;是其重要的组成部分，通过一条条道路监控的串联，引申出一座智慧城市的管控，而在众多数据的维护中，&lt;strong&gt;实时数据&lt;/strong&gt;、&lt;strong&gt;设备状态&lt;/strong&gt;以及&lt;strong&gt;视频监控&lt;/strong&gt;是极为重要的。其中视频监控一直是作为主体的部分，而在&lt;strong&gt;互联网&lt;/strong&gt;和&lt;strong&gt;物联网&lt;/strong&gt;齐头并进的形式下，&lt;strong&gt;“中国天网”&lt;/strong&gt;应运而生，这其实是一项城市监控系统，但它不是个仅一台摄像头的设备，而是足足有1.7亿个监控摄像头，而在未来三年内，还将再安装4亿个摄像头。交通作为城市发展的动脉，与人们下日常息息相关，而在这一系列的监管作用下，成为了一个“公安治安视频监控系统”，关乎人们日常的安全治安管理。&lt;/p&gt;
&lt;p&gt;城市交通的主要方式体现在城市道路、公交、轨道交通等设施上，但随着城市化进程的加快和经济社会发展的推动下，机动车保有量迅速增加，城市交通问题日益严峻。面对这一现状，为了缓和城市交通的各种问题，采取了多种解决方案，例如建设一系列信号灯控制，路口卡口监控、视频监控等多种方法的系统维护，有着一定程度上的效果，但是各个系统都独立着解决其对应的问题，无法从整体的交通态势上进行综合掌控，而实现城市化智慧交通的管理系统可以很好地应对这一问题。介于 2D 组态和 3D 组态上，&lt;strong&gt;Hightopo&lt;/strong&gt;（以下简称 HT ）的 &lt;strong&gt;HT for Web&lt;/strong&gt; 产品上的有着丰富的组态化可供选择，本文将介绍如何运用 HT 丰富的 &lt;strong&gt;2/3D 组态&lt;/strong&gt;搭建出一个路口监控系统的解决方案。&lt;/p&gt;
&lt;div readability=&quot;16.5&quot;&gt;

&lt;p&gt;本文将从一下几个方面介绍智慧交通可视化监控系统的实现过程：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、&lt;/strong&gt;车辆生成以及在红绿灯控制下的运行；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、&lt;/strong&gt;摄像头的仿真和实景监控；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、&lt;/strong&gt;路口监控信息的实时数据以及维护；&lt;/p&gt;

&lt;div readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;界面简介及效果预览&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在智慧交通监控系统里，呈现了拟真的红绿灯控制下实时车辆行驶的场景，搭配上可控制的天气环境切换面板，可以模拟在各种天气下的路口运行状态；还实现了路口摄像头的监控状态，点击路口的每个摄像头可以查看此摄像头监控范围内路口的实时运行，提供仿真和实景两种状态的切换；其次还添加了许多实时数据的监控面板，对接真实接口数据起到实时路口监控的最大效益化。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200518110143690-220284770.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;系统分析&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;HT 通过丰富的 2D 组态和 3D 组态的交融结合使用上，整理出许多工业互联网上的解决方案，在智慧城市推动的背景下，智慧交通管理系统可视化决策系统也是极为重要的部分，对于道路以及路口的监测中，面向交管智慧中心大屏环境，其三维场景上可通过 &lt;strong&gt;HT for Web&lt;/strong&gt; 产品轻量化 HTML5/WebGL 建模的方案，实现快速建模、运行时轻量化到甚至手机终端浏览器即可 3D 可视化运维的良好效果；二维图纸上拥有矢量图标在放大后图像不会失真，支持大屏、多屏、超大分辨率等显示情景。&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;1、综合态势监测&lt;/strong&gt;&lt;br/&gt;集成地理信息系统、视频监控系统、交管部门各业务系统数据，对交通路况车流量、事故处理报告等要素进行综合监测，并支持点选查看具体警力、机动目标、交通事件、监控视频等详细信息，帮助管理者实时掌握交通整体运行态势。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200515155812078-336933446.png&quot; alt=&quot;&quot; width=&quot;553&quot; height=&quot;272&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span data-mce-=&quot;&quot;&gt;2、&lt;strong&gt;交通基础资源监测&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;支持对摄像头、流量检测设备、交通信号灯等交通基础资源的数量、空间位置分布、实时状态等信息进行监测和可视化管理，支持设备详细信息查询，支持对未正常工作的设备进行告警，加强管理者对设备状态的监测与感知，提升交通基础设施的运维管理效率。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200515155640463-362070720.png&quot; alt=&quot;&quot; width=&quot;522&quot; height=&quot;255&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;3、视频巡检监测&lt;/strong&gt;&lt;br/&gt;支持集成前端视频巡检系统，有效结合视频智能分析、智能定位、智能研判技术，对道路拥堵点位、隐患点位、事故点位等情况进行可视化监测，实现异常事件的实时告警、快速显示，并可智能化调取异常点位周边监控视频，有效提升接处警效率。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200518110214739-311880980.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;4、路口信号灯监测&lt;/strong&gt;&lt;br/&gt;支持集成路口信号灯、视频监控等系统数据，对路口交通流量、流速、车辆及道路异常事件、信号灯状态等信息进行实时监测，并可结合专业的模型算法，比对历史最佳通行速度及最佳通行量，对路口交通态势进行可视化分析研判，为信号配时调优和路口交通组织优化提供科学的决策依据，有效提升交通运行效率。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200518110225284-1621464542.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;5、违法违章案件分析&lt;/strong&gt;&lt;br/&gt;充分整合交管部门现有数据资源，提供多种可视化分析、交互手段，对海量历史违法违章案件数据进行可视化串并分析，深度挖掘案件时空分布规律，为交管部门进行原因分析、主动防范等业务应用提供支持。&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200515155938526-481271617.png&quot; alt=&quot;&quot; width=&quot;542&quot; height=&quot;264&quot;/&gt; &lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;一、车辆生成以及在红绿灯控制下的运行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;21&quot;&gt;
&lt;p&gt;在路口的仿真的运行系统下，场景中有这许许多多来往运行的车辆，是通过动态加载车辆模型并且设置管道运行动画，而这些车辆当然需要符合信号灯的运行规则，需要运用一些控制手段，让这些车辆遵纪守法。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200518110232790-302719473.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;以下是通过设置一些车辆的基础属性以及根据 type 类型判断加载对应的车辆模型的伪代码：&lt;/p&gt;
&lt;div readability=&quot;11.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;loadCar(type) {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 创建车辆新节点
    let car = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.Node();
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 根据车辆类型创建加载对应车辆模型
    &lt;span data-mce-=&quot;&quot;&gt;switch&lt;span data-mce-=&quot;&quot;&gt; (type) {
        &lt;span data-mce-=&quot;&quot;&gt;case 'familyCar'&lt;span data-mce-=&quot;&quot;&gt;:
            car.s('shape3d', 'models/HT模型库/交通/车辆/家用车.json'&lt;span data-mce-=&quot;&quot;&gt;);
            &lt;span data-mce-=&quot;&quot;&gt;break&lt;span data-mce-=&quot;&quot;&gt;;
        &lt;span data-mce-=&quot;&quot;&gt;case 'truck'&lt;span data-mce-=&quot;&quot;&gt;:
            car.s('shape3d', 'models/HT模型库/交通/车辆/卡车.json'&lt;span data-mce-=&quot;&quot;&gt;);
            &lt;span data-mce-=&quot;&quot;&gt;break&lt;span data-mce-=&quot;&quot;&gt;;
        &lt;span data-mce-=&quot;&quot;&gt;case 'jeep'&lt;span data-mce-=&quot;&quot;&gt;:
            car.s('shape3d', 'models/HT模型库/交通/车辆/吉普车.json'&lt;span data-mce-=&quot;&quot;&gt;);
            &lt;span data-mce-=&quot;&quot;&gt;break&lt;span data-mce-=&quot;&quot;&gt;;
        ...
        &lt;span data-mce-=&quot;&quot;&gt;default&lt;span data-mce-=&quot;&quot;&gt;:
            console.log('NO THIS TYPE CAR!'&lt;span data-mce-=&quot;&quot;&gt;);
            &lt;span data-mce-=&quot;&quot;&gt;break&lt;span data-mce-=&quot;&quot;&gt;;
    }
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置车辆不可选择和不可移动
&lt;span data-mce-=&quot;&quot;&gt;    car.s({
        '3d.selectable': &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;,
        '3d.movable': &lt;span data-mce-=&quot;&quot;&gt;false&lt;span data-mce-=&quot;&quot;&gt;
    });
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置锚点 --- 车的头部
    car.setAnchor3d(1, 0, 0.5&lt;span data-mce-=&quot;&quot;&gt;); 
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置初始位置
    car.setPosition3d(0, 100000, 0&lt;span data-mce-=&quot;&quot;&gt;);

    let typeIndex = 1&lt;span data-mce-=&quot;&quot;&gt;;
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 判断是否此前生成了这种类型的车辆
    &lt;span data-mce-=&quot;&quot;&gt;this.g3dDm.each(data =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        &lt;span data-mce-=&quot;&quot;&gt;if (data.getTag() === type +&lt;span data-mce-=&quot;&quot;&gt; typeIndex) {
            typeIndex++&lt;span data-mce-=&quot;&quot;&gt;;
        }
    })
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置车辆节点标签
    car.setTag(type +&lt;span data-mce-=&quot;&quot;&gt; typeIndex);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置车辆节点的名字
&lt;span data-mce-=&quot;&quot;&gt;    car.setDisplayName(type);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将车辆节点添加到数据模型中
    &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3dDm.add(car);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;通过管道动画的驱使，生成的车辆在信号灯的控制下行驶着，首先要通过 ht.Polyline 绘制出一条车辆的运行管道，其实现上有二维形式与三维的形式，是继承于 ht.Shape，当 shape3d 设置为 cylinder 时则显示为立体的三维管线效果。而当车辆加载以及管道绘制的完成，我们就可以通过 HT 封装的动画函数 ht.Default.startAnim() 来趋势车辆沿着管道运行，实现管道动画的效果。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200515133326827-258125824.gif&quot; alt=&quot;&quot; width=&quot;361&quot; height=&quot;223&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;22.5&quot;&gt;
&lt;p&gt;而关于管道动画的实现上，基于 ht.Default.startAnim() 封装了一个 move 的动画函数是节点沿着路径平滑移动的封装函数，主要参数为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;node：&lt;/strong&gt;动画节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;path：&lt;/strong&gt;运行路径；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;duration：&lt;/strong&gt;动画执行调度时间;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;animParams：&lt;/strong&gt;动画参数；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通过绘制一条运行路线的管道，ht.Default.getLineCacheInfo() 得到这条管道的点位和分割信息 cache，然后管道信息通过 ht.Default.getLineLength() 得到管道的长度，并且通过 ht.Default.getLineOffset() 来获取连线或者管道指定比例的偏移信息，从而达到移动的效果，是为了通过 node.lookAtX() 来获取节点下一个面对的朝向的位置信息，并设置节点此时的位置，从而达到节点沿着路径平滑移动的效果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
move(node, path, duration = 20000&lt;span data-mce-=&quot;&quot;&gt;, animParams) {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; path._cache_ 里面存着管道的节点信息
    let cache =&lt;span data-mce-=&quot;&quot;&gt; path._cache_; 
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 如果没有缓存信息，则获取 path._cache_ 里面存着管道的节点信息
    &lt;span data-mce-=&quot;&quot;&gt;if (!&lt;span data-mce-=&quot;&quot;&gt;cache) {
        cache = path._cache_ =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.getLineCacheInfo(path.getPoints(), path.getSegments());
    }
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取管道缓存信息的长度
    const len =&lt;span data-mce-=&quot;&quot;&gt; ht.Default.getLineLength(cache);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置动画对象初始化
    animParams = animParams ||&lt;span data-mce-=&quot;&quot;&gt; {};
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置 action 为 animParams 的动画执行函数
    const action =&lt;span data-mce-=&quot;&quot;&gt; animParams.action;
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 动画执行部分
    animParams.action = (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取管道运动的偏移信息
        const offset = ht.Default.getLineOffset(cache, len *&lt;span data-mce-=&quot;&quot;&gt; v);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取偏移位置上的点
        const point =&lt;span data-mce-=&quot;&quot;&gt; offset.point;
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置节点看向的下一个位置
        node.lookAtX([point.x, point.y, point.z], &quot;forward &quot;&lt;span data-mce-=&quot;&quot;&gt;);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置节点的位置
&lt;span data-mce-=&quot;&quot;&gt;        node.p3(point.x, point.y, point.z);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 判断动画是否执行完
        &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (action) action();
    };
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 循环调用动画执行函数
    &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt; loop(animParams.action, duration);
}

&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 循环动画函数
&lt;span data-mce-=&quot;&quot;&gt;loop(action, duration) {
    &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt; ht.Default.startAnim({
        duration: duration,
        action: action
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;二、摄像头的仿真和实景监控&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;视频监控作为本系统重要的解决方案之一，提供了仿真和实景的两套风格实现，仿真的意义是通过简单的车辆模型模拟出交通流向然后通过绘制场景并共用一个数据模型来体现，实质意义上可以通过科幻风格突出监控的重点信息，例如设备维护以及一些违法的场景重现；而对于实景风格是通过对接实时的视频数据流，然后展示出路口的运行状态，以真实的原貌重现路口的每一个动态信息。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/591709/202005/591709-20200518162320980-1166922695.png&quot; alt=&quot;&quot;/&gt;

&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;2.1 拟真摄像头的实现原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;作为拟真方案的摄像头实现上，通过 HT 的渲染元素 renderHTML 加载出一个弹窗的三维小场景，并且与路口主场景共享一个数据模型 dataModel，实现数据变化以及动画的互通，而现在只需要去获取所点击摄像头的真实视角信息，通过全局事件派发将获取的真实视角，传到摄像头弹窗场景去改变对应视角的 眼睛 eye 和 中心点 center，就能达到获取摄像头在主场景中拟真的视角。为了使摄像头活动的时候具有动画的辨识度，在每个摄像头前绘制了一个锥形的监控区域吸附在摄像头上，界定出摄像头的监控范围，达到智慧监控的效果。&lt;/p&gt;
&lt;div readability=&quot;34.5&quot;&gt;
&lt;p&gt;在交互实现上，通过点击选中摄像头后，使这个摄像头的锥形区域变为直线，表示为选中状态同时标记选中的摄像头的选中前后顺序，并且通过派发事件驱使 2D 图纸上显示摄像头弹窗，在弹窗显示的同时，通过计算得到实时变动的中心点位置信息（center），只要实时通过全局派发事件把位置信息传输到摄像头弹窗场景，就能起到摄像头场景视角与主场景中所点击摄像头的视角同步；取消弹窗显示的交互方式是通过双击场景背景，恢复摄像头锥形区域并且派发事件去隐藏 2D图纸上的摄像头弹窗：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 全局事件派发器
&lt;span data-mce-=&quot;&quot;&gt;var G =&lt;span data-mce-=&quot;&quot;&gt; {}
window.G =&lt;span data-mce-=&quot;&quot;&gt; G;
G.event = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.Notifier();

handleInteractive(e) {
    const {kind, data} =&lt;span data-mce-=&quot;&quot;&gt; e;
    &lt;span data-mce-=&quot;&quot;&gt;if(kind === 'clickData'&lt;span data-mce-=&quot;&quot;&gt;) {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 判断点击节点是否带有标签，没有标签则 return
        let tag =&lt;span data-mce-=&quot;&quot;&gt; data.getTag();
        &lt;span data-mce-=&quot;&quot;&gt;if(!tag) &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt;;
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 判断标签名为摄像头
        &lt;span data-mce-=&quot;&quot;&gt;if(tag.indexOf('camera') &amp;gt;= 0&lt;span data-mce-=&quot;&quot;&gt;) {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置指定上一个点击的摄像头和当前点击的摄像头
            &lt;span data-mce-=&quot;&quot;&gt;this.lastClickCamera = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.nowClickCamera;
            &lt;span data-mce-=&quot;&quot;&gt;this.nowClickCamera =&lt;span data-mce-=&quot;&quot;&gt; data;
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 如果之前有点击摄像头，则初始化摄像头锥体的大小
            &lt;span data-mce-=&quot;&quot;&gt;if (&lt;span data-mce-=&quot;&quot;&gt;this.lastClickCamera !== &lt;span data-mce-=&quot;&quot;&gt;null&lt;span data-mce-=&quot;&quot;&gt;) {
                let clickRangeNode = &lt;span data-mce-=&quot;&quot;&gt;this.lastClickCamera.getChildren()._as[0&lt;span data-mce-=&quot;&quot;&gt;];
                clickRangeNode.s3(300, 150, 500&lt;span data-mce-=&quot;&quot;&gt;);
            }
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 如果有点击摄像头，则设定所点击摄像头锥体的大小
            &lt;span data-mce-=&quot;&quot;&gt;if (&lt;span data-mce-=&quot;&quot;&gt;this.nowClickCamera !== &lt;span data-mce-=&quot;&quot;&gt;null&lt;span data-mce-=&quot;&quot;&gt;) {
                let clickRangeNode = &lt;span data-mce-=&quot;&quot;&gt;this.nowClickCamera.getChildren()._as[0&lt;span data-mce-=&quot;&quot;&gt;];
                clickRangeNode.s3(5, 5, 500&lt;span data-mce-=&quot;&quot;&gt;);
            }
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取点击摄像头的位置信息
            &lt;span data-mce-=&quot;&quot;&gt;var cameraP3 =&lt;span data-mce-=&quot;&quot;&gt; nowClickCamera.p3();
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取点击摄像头的旋转信息
            &lt;span data-mce-=&quot;&quot;&gt;var cameraR3 =&lt;span data-mce-=&quot;&quot;&gt; nowClickCamera.r3();
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取点击摄像头的大小信息
            &lt;span data-mce-=&quot;&quot;&gt;var cameraS3 =&lt;span data-mce-=&quot;&quot;&gt; nowClickCamera.s3();
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 当前锥体起始位置
            &lt;span data-mce-=&quot;&quot;&gt;var realP3 = [cameraP3[0], cameraP3[1] + cameraS3[1] / 2, cameraP3[2] + cameraS3[2] / 2&lt;span data-mce-=&quot;&quot;&gt;]; 
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将当前眼睛位置绕着摄像头起始位置旋转得到正确眼睛位置
            &lt;span data-mce-=&quot;&quot;&gt;var realEye =&lt;span data-mce-=&quot;&quot;&gt; getCenter(cameraP3, realP3, cameraR3); 
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 全局事件派发至摄像头场景改变视角的眼睛 eye 和中心点 center
&lt;span data-mce-=&quot;&quot;&gt;            G.event.fire({
                type: 'videoCreated'&lt;span data-mce-=&quot;&quot;&gt;,
                eye: realEye,
                center: getCenter(realEye, [realEye[0], realEye[1] ,realEye[2] + 5&lt;span data-mce-=&quot;&quot;&gt;], cameraR3)
            });

            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 视频弹窗显示派发
            event.fire(SHOW_VIDEO, {g3dDm: &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3dDm, cameraName:tag});
        }
    }
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 双击背景隐藏摄像头场景窗口，并初始化摄像头锥体的大小
    &lt;span data-mce-=&quot;&quot;&gt;if(kind === 'doubleClickBackground'&lt;span data-mce-=&quot;&quot;&gt;) {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 视频弹窗隐藏派发
&lt;span data-mce-=&quot;&quot;&gt;        event.fire(HIDE_VIDEO);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 如果之前有点击摄像头，则初始化摄像头锥体的大小
        &lt;span data-mce-=&quot;&quot;&gt;if (&lt;span data-mce-=&quot;&quot;&gt;this.nowClickCamera !== &lt;span data-mce-=&quot;&quot;&gt;null&lt;span data-mce-=&quot;&quot;&gt;) {
            let clickRangeNode = &lt;span data-mce-=&quot;&quot;&gt;this.nowClickCamera.getChildren()._as[0&lt;span data-mce-=&quot;&quot;&gt;];
            clickRangeNode.s3(300, 150, 500&lt;span data-mce-=&quot;&quot;&gt;)
        }
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置当前点击摄像头为空
        &lt;span data-mce-=&quot;&quot;&gt;this.nowClickCamera = &lt;span data-mce-=&quot;&quot;&gt;null&lt;span data-mce-=&quot;&quot;&gt;;
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;以上所涉及到方法 getCenter()，实际上是通过去获取每个摄像头节点在场景中对应的旋转角度，简化理解就是一个点 A 围绕着另外一个点 B 旋转，即中心点位置（center）围绕着眼睛位置（eye）旋转，而我们则需要去计算点 A 的位置（中心点位置 center），这里通过封装一个 getCenter 方法用于获取 3d 场景中点 A 绕着点 B 旋转 angle 角度之后得到的点 A 在 3d 场景中的位置，方法中采用了 HT 封装的 ht.Math 下面的方法，以下为实现的代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200518114426880-1806697572.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实现代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; pointA 为 pointB 围绕的旋转点&lt;span data-mce-=&quot;&quot;&gt;
//&lt;span data-mce-=&quot;&quot;&gt; pointB 为需要旋转的点&lt;span data-mce-=&quot;&quot;&gt;
//&lt;span data-mce-=&quot;&quot;&gt; r3 为旋转的角度数组 [xAngle, yAngle, zAngle] 为绕着 x, y, z 轴分别旋转的角度 
const getCenter = &lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(pointA, pointB, r3) {
    const mtrx = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.Math.Matrix4();
    const euler = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.Math.Euler();
    const v1 = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.Math.Vector3();
    const v2 = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.Math.Vector3();

    mtrx.makeRotationFromEuler(euler.set(r3[0], r3[1], r3[2&lt;span data-mce-=&quot;&quot;&gt;]));

    v1.fromArray(pointB).sub(v2.fromArray(pointA));
    v2.copy(v1).applyMatrix4(mtrx);
    v2.sub(v1);

    &lt;span data-mce-=&quot;&quot;&gt;return [pointB[0] + v2.x, pointB[1] + v2.y, pointB[2] +&lt;span data-mce-=&quot;&quot;&gt; v2.z];
};&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;2.2 实景摄像头的实现原理&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;对于实景的实现上，我们可以通过对接实时的视频数据流，现在主要常用的流媒体传输协议有：&lt;strong&gt;RTMP&lt;/strong&gt;、&lt;strong&gt;RTSP&lt;/strong&gt;、&lt;strong&gt;HLS &lt;/strong&gt;和 &lt;strong&gt;HTTP-FLV&lt;/strong&gt;。&lt;/p&gt;
&lt;div readability=&quot;12.5&quot;&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;RTMP&lt;/strong&gt; (Real Time Messaging Protocol)：实时消息传输协议，RTMP 协议中，视频必须是 H264 编码，音频必须是 AAC 或 MP3 编码，且多以 flv 格式封包。因为 RTMP 协议传输的基本是 FLV 格式的流文件，必须使用 flash 播放器才能播放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RTSP&lt;/strong&gt; (Real-Time Stream Protocol)：RTSP 实时效果非常好，适合视频聊天、视频监控等方向。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HLS&lt;/strong&gt;(Http Live Streaming)：由 Apple 公司定义的基于 HTTP 的流媒体实时传输协议。传输内容包括两部分：1.M3U8 描述文件，2.TS 媒体文件。TS 媒体文件中的视频必须是H264编码，音频必须是 AAC 或 MP3 编码。数据通过 HTTP 协议传输。目前 video.js 库支持该格式文件的播放。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;HTTP-FLV&lt;/strong&gt;：本协议就是 http+flv，将音视频数据封装成FLV格式，然后通过http协议传输到客户端，这个协议大大方便了浏览器客户端播放直播视频流.目前 flv.js 库支持该格式的文件播放。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如通过一个简单的 RTMP 视频流的对接就可以明白其实现的原理。对于的视频的载入，需要用到 video.js 的插件进行展示，所以先引入插件，然后对接视频流后，也是同样通过全局事件派发到 HT 的渲染元素 renderHTML 将视频流渲染到场景图纸中，以下是实现的伪代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 引入 video.js 插件
&amp;lt;script src=&quot;./js/video.js&quot;&amp;gt;&amp;lt;/script&amp;gt;

&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过全局事件派发到渲染元素 renderHTML 去渲染视频到场景图纸中
G.event.add(&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt;(e){
    &lt;span data-mce-=&quot;&quot;&gt;if(e.type==='videoCreated'&lt;span data-mce-=&quot;&quot;&gt;){
        &lt;span data-mce-=&quot;&quot;&gt;var div=&lt;span data-mce-=&quot;&quot;&gt;e.div;
        div.innerHTML='&amp;lt;video id=&quot;video&quot; class=&quot;video-js vjs-default-skin&quot;&amp;gt;&amp;lt;source src=&quot;rtmp://10.10.70.57/live/test&quot; type=&quot;rtmp/flv&quot;&amp;gt;&amp;lt;/video&amp;gt;'&lt;span data-mce-=&quot;&quot;&gt;;
        window.player = videojs('video'&lt;span data-mce-=&quot;&quot;&gt;);
    }
});&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;三、路口监控信息的实时数据以及维护 &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于一些路口的关键数据可以通过接口对接的形式展示出来，通过实时数据变动的监控，即时反馈道路路口的信息数据，包含一些事故统计、车流量分析、设备维护状态以及车辆违章。这些数据依赖展示的载体是通过 HT 的 2D 组态矢量图来实现的，矢量图适用于很多场合，其特点是放大后图像不会失真，可以适应不同分辨率的屏幕都不会模糊，使得整个系统适用与不同的屏幕下，包括在大屏的监控系统上也得心应手。而通过矢量图的信息展示上，对比以往一些单纯数据展示的页面，本系统则是通过一些自定义的动画交互，可以使得整个页面的上效果呈现上有一种沉浸式的体验，整体的客户体验可以大大地提升。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200515140050949-1308737817.gif&quot; alt=&quot;&quot; width=&quot;573&quot; height=&quot;281&quot;/&gt;&lt;/div&gt;

&lt;div readability=&quot;9.8099762470309&quot;&gt;数据的展示形式有着多种多样的方式，可以通过一些图表插件，例如 eEcharts，HT 也有机制可以让我们使用它们，当然我们也可以自定义封装一些组件，示例中的表格和圆环进度条就是一种很好地呈现方式，而在许多效果呈现上，HT也是拥有自己一套功能丰富的 UI 组态，如果感兴趣的话可以通过 &lt;a href=&quot;https://www.hightopo.com/index.html&quot; target=&quot;_blank&quot;&gt;HT主页&lt;/a&gt; 上来了解使用。&lt;/div&gt;
&lt;p&gt;对于数据接口的获取，可以运用一些主流的方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;&lt;strong&gt;ajax：&lt;/strong&gt;&lt;/strong&gt;使用 JavaScript 向服务器提出请求并处理响应而不阻塞用户核心对象 XMLHttpRequest；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;axios：&lt;/strong&gt;&lt;/strong&gt;基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;WebSocket：&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;HTML5 提供的一种在单个 TCP 连接上进行全双工通讯的协议；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ajax 和 axios 要实时获取接口数据得通过轮询调用接口的形式进行传输，而 WebSocket 可以双向进行数据传输，在选择运用上可以匹配自己的实现需求。本系统是采用通过 axios 调用接口获取实时数据。&lt;/p&gt;
&lt;p&gt;示例中的柱状图和折线图，是通过 HT 里的机制下去使用 eEcharts 上一些图表进行自定义配置而实现的，继而通过对 axios 接口轮询调用载入数据，展现了实时的路口监控数据信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;loadData() {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取图纸的数据模型
    let dm = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g2d.dm();
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取车流量接口的数据
    axios.get('/traffic').then(res =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 接入日车流量折线图的数据
        &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.lineChart1.a({
            'seriesData1'&lt;span data-mce-=&quot;&quot;&gt;: res.lineChartData1,
            'axisData'&lt;span data-mce-=&quot;&quot;&gt; : res.axisData
        });
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 接入车辆运行高峰折线图的数据
        &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.lineChart2.a({
            'seriesData1'&lt;span data-mce-=&quot;&quot;&gt;: res.lineChartData2,
            'axisData'&lt;span data-mce-=&quot;&quot;&gt; : res.axisData
        })
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 采用数字跳动的方式载入一些数据内容
        setBindingDatasWithAnim(dm, res, 800, v =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; Math.round(v));
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 接入运行峰值的时刻
        &lt;span data-mce-=&quot;&quot;&gt;this.peakTime.s('text'&lt;span data-mce-=&quot;&quot;&gt;, res.peakTime);
    });
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 载入设备运行状态的数据
    axios.get('/equipmentStatus').then(res =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        setBindingDatasWithAnim(dm, res, 800, v =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; Math.round(v));
    });
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 载入事故统计的数据
    axios.get('/accident').then(res =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        setBindingDatasWithAnim(dm, res, 800, v =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; Math.round(v));
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 接入每月事故柱状图的数据
        &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.accidentBar.a({
            axisData: res.axisData,
            seriesData1: res.seriesData1
        })
    }); 
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;关于表格的绘制，实际上是封装了一个组件来实现的，而其中的交互动画，主要还是运用了 HT 自带的动画函数 ht.Default.startAnim()，横向通过滚动 100 宽度并数据透明度慢慢浮现，纵向采用向下偏移一行表格行高 54 来添加新的警报信息。&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;addTableRow() {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取表格节点
    let table = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.table;
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过 axios 的 promise 请求接口数据
    axios.get('getEvent').then(res =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取表格节点滚动信息的数据绑定
        let tableData = table.a('dataSource'&lt;span data-mce-=&quot;&quot;&gt;);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过向 unshift() 方法可向滚动信息数组的开头添加一个或更多元素
&lt;span data-mce-=&quot;&quot;&gt;        tableData.unshift(res);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 初始化表格的纵向偏移
        table.a('ty', -54&lt;span data-mce-=&quot;&quot;&gt;);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 开启表格滚动动画
&lt;span data-mce-=&quot;&quot;&gt;        ht.Default.startAnim({
            duration: 600&lt;span data-mce-=&quot;&quot;&gt;,
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 动画执行函数 action
            action: (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                table.a({
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过添加数据后，横向滚动 100
                    'firstRowTx': 100 * (1 -&lt;span data-mce-=&quot;&quot;&gt; v),
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 第一行行高出现的透明度渐变效果
                    'firstRowOpacity'&lt;span data-mce-=&quot;&quot;&gt;: v,
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 纵向偏移 54 的高度
                    'ty': (v - 1) * 54&lt;span data-mce-=&quot;&quot;&gt;
                });
            }
        });
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;城市大脑被炒的火热，红绿灯调控解决拥堵问题只是智慧交通的冰山一角，常态下的监测监管、分析研判，才是交通管理者真正得以运筹帷幄的有利保障，而这些，离不开让交通数据可见可感的“智慧交通可视化决策平台”。&lt;/p&gt;
&lt;div readability=&quot;7.2950819672131&quot;&gt;
&lt;div readability=&quot;9.7267759562842&quot;&gt;智慧交通可视化系统通过实时数据的载入，可以有效即时地反映出路口所处的状态，使得以往散乱的各个系统串联起来形成一个完整的智慧交通系统，而在这个系统下串联出许多条道路的监控，这其实是一个智慧城市的缩影，而在以往的经验积累上，HT 也完成了一套完整的智慧城市系统的解决方案，串联了许多城市数据以及设施建设的记录，可以起到合并许多个功能子系统进行实时的数据监控和展示：&lt;a href=&quot;https://www.hightopo.com/demo/city/&quot; target=&quot;_blank&quot;&gt;HT 智慧城市&lt;/a&gt;&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202005/1496396-20200515145722910-1273391448.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;/div&gt;



&lt;/div&gt;</description>
<pubDate>Mon, 18 May 2020 16:03:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 随着信息时代的发展变迁，荧幕里呈现的智慧城市慢慢出现了在现实生活中，很大程度上便利了日常的管理和维护。在智慧城市的大背景下，智慧交通监管可视化系统是其重要的组成部分，通过一条条道路监控的串联，引</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/12896492.html</dc:identifier>
</item>
</channel>
</rss>