<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>@ConfigurationProperties 注解使用姿势，这一篇就够了 - tan日拱一兵</title>
<link>http://www.cnblogs.com/FraserYu/p/11261916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FraserYu/p/11261916.html</guid>
<description>&lt;p&gt;在编写项目代码时，我们要求更灵活的配置，更好的模块化整合。在 Spring Boot 项目中，为满足以上要求，我们将大量的参数配置在 application.properties 或 application.yml 文件中，通过 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解，我们可以方便的获取这些参数值&lt;/p&gt;
&lt;h2 id=&quot;使用-configurationproperties-配置模块&quot;&gt;使用 @ConfigurationProperties 配置模块&lt;/h2&gt;
&lt;p&gt;假设我们正在搭建一个发送邮件的模块。在本地测试，我们不想该模块真的发送邮件，所以我们需要一个参数来「开关」 disable 这个功能。另外，我们希望为这些邮件配置一个默认的主题，这样，当我们查看邮件收件箱，通过邮件主题可以快速判断出这是测试邮件&lt;/p&gt;
&lt;p&gt;在 application.properties 文件中创建这些参数:&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-24-05%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用 &lt;code&gt;@Value&lt;/code&gt; 注解或着使用 Spring &lt;code&gt;Environment&lt;/code&gt; bean 访问这些属性，是这种注入配置方式有时显得很笨重。我们将使用更安全的方式(&lt;code&gt;@ConfigurationProperties&lt;/code&gt; )来获取这些属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-24-34%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 的基本用法非常简单:我们为每个要捕获的外部属性提供一个带有字段的类。请注意以下几点:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前缀定义了哪些外部属性将绑定到类的字段上&lt;/li&gt;
&lt;li&gt;根据 Spring Boot 宽松的绑定规则，类的属性名称必须与外部属性的名称匹配&lt;/li&gt;
&lt;li&gt;我们可以简单地用一个值初始化一个字段来定义一个默认值&lt;/li&gt;
&lt;li&gt;类本身可以是包私有的&lt;/li&gt;
&lt;li&gt;类的字段必须有公共 setter 方法&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;h3 id=&quot;spring-宽松绑定规则-relaxed-binding&quot;&gt;Spring 宽松绑定规则 (relaxed binding)&lt;/h3&gt;
&lt;p&gt;Spring使用一些宽松的绑定属性规则。因此，以下变体都将绑定到 hostName 属性上:&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-27-10%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们将 MailModuleProperties 类型的 bean 注入到另一个 bean 中，这个 bean 现在可以以类型安全的方式访问那些外部配置参数的值。&lt;/p&gt;
&lt;p&gt;但是，我们仍然需要让 Spring 知道我们的 @ConfigurationProperties 类存在，以便将其加载到应用程序上下文中( &lt;a href=&quot;https://mp.weixin.qq.com/s/YBQB086ADBjHUmwrFQrWew&quot;&gt;面试还不知道 BeanFactory 和 ApplicationContext 的区别？&lt;/a&gt;)&lt;/p&gt;
&lt;h2 id=&quot;激活-configurationproperties&quot;&gt;激活 @ConfigurationProperties&lt;/h2&gt;
&lt;p&gt;对于 Spring Boot，创建一个 MailModuleProperties 类型的 bean，我们可以通过下面几种方式将其添加到应用上下文中&lt;/p&gt;
&lt;p&gt;首先，我们可以通过添加 @Component 注解让 Component Scan 扫描到&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-27-33%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很显然，只有当类所在的包被 Spring &lt;code&gt;@ComponentScan&lt;/code&gt; 注解扫描到才会生效，默认情况下，该注解会扫描在主应用类下的所有包结构&lt;/p&gt;
&lt;p&gt;我们也可以通过 Spring 的 Java Configuration 特性实现同样的效果:&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-29-20%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只要 MailModuleConfiguration 类被 Spring Boot 应用扫描到，我们就可以在应用上下文中访问 MailModuleProperties bean&lt;/p&gt;
&lt;p&gt;我们还可以使用 &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt; 注解让我们的类被 Spring Boot 所知道，在该注解中其实是用了&lt;code&gt;@Import(EnableConfigurationPropertiesImportSelector.class)&lt;/code&gt; 实现，大家可以看一下&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-29-42%402x.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;h3 id=&quot;激活一个-configurationproperties-类的最佳方式是什么&quot;&gt;激活一个 @ConfigurationProperties 类的最佳方式是什么？&lt;/h3&gt;
&lt;p&gt;所有上述方法都同样有效。然而，我建议模块化你的应用程序，并让每个模块提供自己的&lt;code&gt;@ConfigurationProperties&lt;/code&gt; 类，只提供它需要的属性，就像我们在上面的代码中对邮件模块所做的那样。这使得在不影响其他模块的情况下重构一个模块中的属性变得容易。&lt;/p&gt;
&lt;p&gt;因此，我不建议在应用程序类本身上使用 &lt;code&gt;@EnableConfigurationProperties&lt;/code&gt;，如许多其他教程中所示，是在特定于模块的 @Configuration 类上使用&lt;code&gt;@EnableConfigurationProperties&lt;/code&gt;，该类也可以利用包私有的可见性对应用程序的其余部分隐藏属性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;无法转换的属性&quot;&gt;无法转换的属性&lt;/h2&gt;
&lt;p&gt;如果我们在 application.properties 属性上定义的属性不能被正确的解析会发生什么？假如我们为原本应该为布尔值的属性提供的值为 'foo':&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-30-09%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，Spring Boot 将会启动失败，并抛出异常:&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Failed to bind properties under 'myapp.mail.enabled' to java.lang.Boolean:

    Property: myapp.mail.enabled
    Value: foo
    Origin: class path resource [application.properties]:1:20
    Reason: failed to convert java.lang.String to java.lang.Boolean&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们为属性配置错误的值时，而又不希望 Spring Boot 应用启动失败，我们可以设置 &lt;code&gt;ignoreInvalidFields&lt;/code&gt; 属性为 true (默认为 false)&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-49-56%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，Spring Boot 将会设置 enabled 字段为我们在 Java 代码里设定好的默认值。如果我们没有设置默认值，enabled 将为 null，因为这里定义的是 boolean 的包装类 Boolean&lt;/p&gt;
&lt;h2 id=&quot;未知的属性&quot;&gt;未知的属性&lt;/h2&gt;
&lt;p&gt;和上面的情况有些相反，如果我们在 application.properties 文件提供了 MailModuleProperties 类不知道的属性会发生什么？&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-52-20%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，Spring Boot 会忽略那些不能绑定到 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 类字段的属性&lt;/p&gt;
&lt;p&gt;然而，当配置文件中有一个属性实际上没有绑定到 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 类时，我们可能希望启动失败。也许我们以前使用过这个配置属性，但是它已经被删除了，这种情况我们希望被触发告知手动从 application.properties 删除这个属性&lt;/p&gt;
&lt;p&gt;为了实现上述情况，我们仅需要将 &lt;code&gt;ignoreUnknownFields&lt;/code&gt; 属性设置为 false (默认是 true)&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-53-28%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在，应用启动时，控制台会反馈我们异常信息&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Binding to target [Bindable@cf65451 type = com.example.configurationproperties.properties.MailModuleProperties, value = 'provided', annotations = array&amp;lt;Annotation&amp;gt;[@org.springframework.boot.context.properties.ConfigurationProperties(value=myapp.mail, prefix=myapp.mail, ignoreInvalidFields=false, ignoreUnknownFields=false)]] failed:

    Property: myapp.mail.unknown-property
    Value: foo
    Origin: class path resource [application.properties]:3:29
    Reason: The elements [myapp.mail.unknown-property] were left unbound.&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;弃用警告⚠️(Deprecation Warning)&lt;br/&gt;&lt;code&gt;ignoreUnknownFields&lt;/code&gt; 在未来 Spring Boot 的版本中会被标记为 deprecated，因为我们可能有两个带有 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 的类，同时绑定到了同一个命名空间 (namespace) 上，其中一个类可能知道某个属性，另一个类却不知道某个属性，这样就会导致启动失败&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;启动时校验-configurationproperties&quot;&gt;启动时校验 @ConfigurationProperties&lt;/h2&gt;
&lt;p&gt;如果我们希望配置参数在传入到应用中时有效的，我们可以通过在字段上添加 &lt;code&gt;bean validation&lt;/code&gt; 注解，同时在类上添加 &lt;code&gt;@Validated&lt;/code&gt; 注解&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-55-40%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我们忘记在 application.properties 文件设置 enabled 属性，并且设置 defaultSubject 为空&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-56-53%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应用启动时，我们将会得到 &lt;code&gt;BindValidationException&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;Binding to target org.springframework.boot.context.properties.bind.BindException: Failed to bind properties under 'myapp.mail' to com.example.configurationproperties.properties.MailModuleProperties failed:

    Property: myapp.mail.enabled
    Value: null
    Reason: must not be null

    Property: myapp.mail.defaultSubject
    Value: null
    Reason: must not be empty&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然这些默认的验证注解不能满足你的验证要求，我们也可以自定义注解&lt;/p&gt;
&lt;p&gt;如果你的验证逻辑很特殊，我们可以实现一个方法，并用 @PostConstruct 标记，如果验证失败，方法抛出异常即可, 关于 @PostConstruct，可以查看 &lt;a href=&quot;https://mp.weixin.qq.com/s/I7zgbOoCgAUnRFy4avipiQ&quot;&gt;Spring Bean 的生命周期，我从哪里来？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;复杂属性类型&quot;&gt;复杂属性类型&lt;/h2&gt;
&lt;p&gt;多数情况，我们传递给应用的参数是基本的字符串或数字。但是，有时我们需要传递诸如 List 的数据类型&lt;/p&gt;
&lt;h3 id=&quot;list-和-set&quot;&gt;List 和 Set&lt;/h3&gt;
&lt;p&gt;假如，我们为邮件模块提供了一个 SMTP 服务的列表，我们可以添加该属性到 MailModuleProperties 类中&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-58-11%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们有两种方式让 Spring Boot 自动填充该 list 属性&lt;/p&gt;
&lt;h4 id=&quot;application.properties&quot;&gt;application.properties&lt;/h4&gt;
&lt;p&gt;在 application.properties 文件中以数组形式书写&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-59-06%402x.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;application.yml&quot;&gt;application.yml&lt;/h4&gt;
&lt;p&gt;YAML 本身支持 list 类型，所以可以在 application.yml 文件中添加:&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-59-34%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;set 集合也是这种方式的配置方式，不再重复书写。另外YAML 是更好的阅读方式，层次分明，所以在实际应用中更推荐大家使用该种方式做数据配置&lt;/p&gt;
&lt;h3 id=&quot;duration&quot;&gt;Duration&lt;/h3&gt;
&lt;p&gt;Spring Boot 内置支持从配置参数中解析 durations (持续时间)，&lt;a href=&quot;https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-conversion-duration&quot;&gt;官网文档&lt;/a&gt; 给出了明确的说明&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-00-08%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们既可以配置毫秒数数值，也可配置带有单位的文本:&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-01-01%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;官网上已明确说明，配置 duration 不写单位，默认按照毫秒来指定，我们也可已通过 @DurationUnit 来指定单位:&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-01-47%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常用单位如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;ns&lt;/code&gt; for nanoseconds (纳秒)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;us&lt;/code&gt; for microseconds (微秒)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ms&lt;/code&gt; for milliseconds (毫秒)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; for seconds (秒)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt; for minutes (分)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;h&lt;/code&gt; for hours (时)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;d&lt;/code&gt; for days (天)&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;datasize&quot;&gt;DataSize&lt;/h3&gt;
&lt;p&gt;与 Duration 的用法一毛一样，默认单位是 byte (字节)，可以通过 @DataSizeUnit 单位指定:&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-02-34%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;添加配置&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-03-17%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，我测试的时候打印出来结果都是以 B (bytes) 来显示&lt;/p&gt;
&lt;p&gt;常见单位如下:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;B&lt;/code&gt; for bytes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;KB&lt;/code&gt; for kilobytes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;MB&lt;/code&gt; for megabytes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GB&lt;/code&gt; for gigabytes&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TB&lt;/code&gt; for terabytes&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;自定义类型&quot;&gt;自定义类型&lt;/h2&gt;
&lt;p&gt;有些情况，我们想解析配置参数到我们自定义的对象类型上，假设，我们我们设置最大包裹重量:&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-04-08%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在 MailModuleProperties 中添加 Weight 属性&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-04-51%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以模仿 DataSize 和 Duration 创造自己的 converter (转换器)&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-05-39%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将其注册到 Spring Boot 上下文中&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-07-03%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@ConfigurationPropertiesBinding&lt;/code&gt; 注解是让 Spring Boot 知道使用该转换器做数据绑定&lt;/p&gt;
&lt;h2 id=&quot;使用-spring-boot-configuration-processor-完成自动补全&quot;&gt;使用 Spring Boot Configuration Processor 完成自动补全&lt;/h2&gt;
&lt;p&gt;我们向项目中添加依赖:&lt;/p&gt;
&lt;h3 id=&quot;maven&quot;&gt;Maven&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-09-28%402x.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;gradle&quot;&gt;Gradle&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-09-58%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重新 build 项目之后，configuration processor 会为我们创建一个 JSON 文件:&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-15-23-19.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，当我们在 application.properties 和 application.yml 中写配置的时候会有自动提醒:&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-15-24-36.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;标记配置属性为-deprecated&quot;&gt;标记配置属性为 Deprecated&lt;/h2&gt;
&lt;p&gt;configuration processor 允许我们标记某一个属性为 deprecated&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-11-03%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以通过添加 &lt;code&gt;@DeprecatedConfigurationProperty&lt;/code&gt; 注解到字段的 getter 方法上，来标示该字段为 deprecated，重新 build 项目，看看 JSON 文件发生了什么？&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-17-12-06%402x.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当我们再编写配置文件时，已经给出了明确 deprecated 提示:&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-15-52-19.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Spring Boot 的 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解在绑定类型安全的 Java Bean 时是非常强大的，我们可以配合其注解属性和 &lt;code&gt;@DeprecatedConfigurationProperty&lt;/code&gt; 注解获取到更友好的编程方式，同时这样让我们的配置更加模块化。&lt;/p&gt;
&lt;h2 id=&quot;附加说明&quot;&gt;附加说明&lt;/h2&gt;
&lt;p&gt;以为 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解满足我们的全部需要了吗？其实不然，Spring 官网明确给出了该注解和 &lt;code&gt;@Value&lt;/code&gt; 注解的对比:&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-02-04.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果使用 SpEL 表达式，我们只能选择 &lt;code&gt;@Value&lt;/code&gt; 注解&lt;/p&gt;
&lt;p&gt;另外我之前在阅读 RabbitMQ 源码时，发现 RabbitProperties 类充分的利用了 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解特性:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;deprecated&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-05-40.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Duration&lt;br/&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E5%BA%94%E7%94%A8%E7%B1%BB%E6%96%87%E7%AB%A0/_image/2019-07-23/2019-07-24-16-06-48.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Enum&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;嵌套属性&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;感觉自己后知后觉，最近在思考，为什么小时候要阅读和背诵古诗词，文言文等经典，因为这样写文章就可以轻松熟练的引用经典。技术也一样，各种框架的源码就是学生时代的古诗词和文言文，我们要多多查看阅读，甚至背诵编程思想，这样就可以写出越来越优雅的代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于 &lt;code&gt;@ConfigurationProperties&lt;/code&gt; 注解的使用，这里推荐 &lt;a href=&quot;https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/amqp/RabbitProperties.java&quot;&gt;RabbitMQ Github 源码&lt;/a&gt;，只需看这一个类就可以，知道怎样充分利用这个注解.&lt;/p&gt;
&lt;p&gt;Demo 代码获取，回复公众号「demo」，打开链接查看对应的子文件夹即可&lt;/p&gt;
&lt;h2 id=&quot;灵魂追问&quot;&gt;灵魂追问&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;在实际项目中， 你能够充分利用这些特性让你的配置更灵活和模块化吗？&lt;/li&gt;
&lt;li&gt;阅读框架源码时，他们都是怎样配置的呢？&lt;/li&gt;
&lt;li&gt;@Value 注解怎样给出默认值？&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;提高效率工具&quot;&gt;提高效率工具&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/_image/2019-06-18/b.png&quot;/&gt; [center]&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;推荐阅读&quot;&gt;推荐阅读&lt;/h2&gt;
&lt;hr/&gt;&lt;blockquote&gt;
&lt;h3 id=&quot;欢迎持续关注公众号日拱一兵&quot;&gt;欢迎持续关注公众号：「日拱一兵」&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;前沿 Java 技术干货分享&lt;/li&gt;
&lt;li&gt;高效工具汇总&lt;/li&gt;
&lt;li&gt;面试问题分析与解答&lt;/li&gt;
&lt;li&gt;技术资料领取&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;以读侦探小说思维轻松趣味学习 Java 技术栈相关知识，本着将复杂问题简单化，抽象问题具体化和图形化原则逐步分解技术问题，技术持续更新，请持续关注......&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://rgyb.sunluomeng.top/%E5%85%AC%E4%BC%97%E8%B4%A6%E5%8F%B7%E6%96%87%E7%AB%A0/%E6%84%9F%E6%83%B3%E4%B8%8E%E6%80%BB%E7%BB%93/_image/2019-06-18/a%20%281%29.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jul 2019 00:44:00 +0000</pubDate>
<dc:creator>tan日拱一兵</dc:creator>
<og:description>在编写项目代码时，我们要求更灵活的配置，更好的模块化整合。在 Spring Boot 项目中，为满足以上要求，我们将大量的参数配置在 application.properties 或 applicat</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FraserYu/p/11261916.html</dc:identifier>
</item>
<item>
<title>天天吹微服务，单体应用有啥不好？ - 江南一点雨</title>
<link>http://www.cnblogs.com/lenve/p/11261876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lenve/p/11261876.html</guid>
<description>&lt;p&gt;单体应用确实有问题！&lt;/p&gt;
&lt;p&gt;最近在研究微服务架构，有一点点心得，打算在公众号上写几篇文章和大家慢慢分享下。&lt;/p&gt;
&lt;p&gt;这个话题有点大，我会分几篇文章和大家慢慢说，今天就先来说说传统的单体应用有哪些弊端，正是因为单体应用存在的弊端，使得我们不得不考虑发展微服务。&lt;/p&gt;
&lt;p&gt;人类发展的历史就是一个社会分工不断细化的历史，从这个角度来讲，微服务这种将一个复杂的大项目拆分为众多小项目，然后程序员分工合作，共同完成项目，这种协作方式是符合历史潮流的。&lt;/p&gt;
&lt;p&gt;这是我们站在今天的角度来说的，曾经的单体应用也是先进生产力的代表。&lt;/p&gt;
&lt;p&gt;但是，随着互联网的发展，我们对一个系统的要求越来越高，单体应用已经很难适应当前的开发，因此在回答我们为什么要使用微服务这个问题之前，我们有必要来聊一聊单体应用目前都面临哪些问题。&lt;/p&gt;

&lt;h2 id=&quot;项目过度复杂&quot;&gt;1.项目过度复杂&lt;/h2&gt;
&lt;p&gt;你要创建一个简单的用户管理系统，二话不说，直接创建 Maven 项目然后开干就完事了，这没问题，因为这很简单。&lt;/p&gt;
&lt;p&gt;但是你要说想搞一个淘宝网站，或者你想搞一个用友 U8 系统，那你恐怕就得先慢慢设计系统架构了。单体应用，由于就是一个项目，所有的功能都是写在一个项目中，不可避免的出现项目过度复杂的情况。而且这种复杂情况会不断恶化。&lt;/p&gt;
&lt;p&gt;有的小伙伴可能有这样的经验，刚入职了一家公司，新接手了一个项目，上面催的很急，让你赶快修复几个 bug ，项目复杂，光是实体类的包就有好几个 bean、model、pojo 等，一个项目被很多人经手之后，到你手里，早已经一团乱麻，你小心翼翼尽量不碰触到已有的功能，终于修完了几个 bug，搞了俩礼拜，你觉得这个项目太坑爹了，不想干了，于是接盘侠从你手里接到了一个复杂度又上升了一步的项目。&lt;/p&gt;
&lt;p&gt;就这样，一个原本简简单单的单体项目，在变复杂的路上一去不复返。&lt;/p&gt;
&lt;h2 id=&quot;开发速度缓慢&quot;&gt;2.开发速度缓慢&lt;/h2&gt;
&lt;p&gt;单体应用开发速度缓慢，因为单体应用复杂了之后，项目变得异常臃肿而且庞大，每一次编译构建、运行以及测试，都需要花费大量时间，而且如果测试有问题，又得从头来一遍，注意，这里的每一次从头编译构建等都是整个项目的从头编译构建。&lt;/p&gt;
&lt;p&gt;即使你可能只要修改某一个参数，你也得把上面整个流程走一遍，相当于每一次的修改都是牵一发而动全身的操作。&lt;/p&gt;
&lt;p&gt;速度没法快。&lt;/p&gt;
&lt;h2 id=&quot;不易扩展&quot;&gt;3.不易扩展&lt;/h2&gt;
&lt;p&gt;项目中不同模块对计算机的性能要求不一样，例如使用 Redis 来保存了大量的热点数据，那么我们希望服务器的内存非常大，另外有一个模块涉及到了图片处理，我们又希望服务器的 CPU 非常强，如果是单体应用部署的话，那么这些条件服务器都要满足。&lt;/p&gt;
&lt;h2 id=&quot;技术栈不易扩展&quot;&gt;4.技术栈不易扩展&lt;/h2&gt;
&lt;p&gt;单体应用还有一个劣势就是技术栈不易扩展，一旦你选定了某一个技术栈来开发项目，以后很难在技术栈上做切换。有的公司还会自己搞一套系统，这种在当时看起来好像都没有啥问题，可是经过几年之后，回头再看，已经很过时了，很 low 了，当初设计系统的人可能已经离职了，刚入职的新手也不敢动这个老古董，只能在这个老古董上面忍痛开发。&lt;/p&gt;
&lt;p&gt;有的时候，有一个服务需要处理高并发，你很想用 Go 语言来做，可是做不到，没法引入其他语言。&lt;/p&gt;
&lt;p&gt;这些都是单体应用的劣势，如果有微服务，上面这些问题都将得到解决。&lt;/p&gt;

&lt;p&gt;当然，事物都是有两面性的，单体应用也有它自己的优势，例如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;开发简单，一个 IDE 就可以快速构建出一个单体应用&lt;/li&gt;
&lt;li&gt;测试简单&lt;/li&gt;
&lt;li&gt;部署简单，Tomcat 安装好之后，应用扔上去就行了&lt;/li&gt;
&lt;li&gt;集群化部署也很容易，多个 Tomcat + 一个 Nginx 分分钟就搭建好集群环境了&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这么多优势，还是难掩劣势。&lt;/p&gt;
&lt;p&gt;不过大家在做项目的时候，还是要结合实际情况来选择，不能因为微服务厉害，所有项目都是微服务，如果你仅仅只想做一个用户的增删改查，那么很明显，创建一个简单的单体应用是最合适的。&lt;/p&gt;
&lt;p&gt;好了，本文主要和大家分享了传统单体应用存在的一些问题，正是因为这些问题，我们需要引入微服务，下篇文章，我们就来看看微服务有哪些优势。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;[1] Chris Richardson.微服务架构设计模式[M].北京：机械工业出版社，2019.&lt;/p&gt;
&lt;p&gt;关注公众号【江南一点雨】，专注于 Spring Boot+微服务以及前后端分离等全栈技术，定期视频教程分享，关注后回复 Java ，领取松哥为你精心准备的 Java 干货！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/747810/201907/747810-20190710095647242-469154686.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jul 2019 00:24:00 +0000</pubDate>
<dc:creator>江南一点雨</dc:creator>
<og:description>单体应用确实有问题！ 最近在研究微服务架构，有一点点心得，打算在公众号上写几篇文章和大家慢慢分享下。 &lt;! more 这个话题有点大，我会分几篇文章和大家慢慢说，今天就先来说说传统的单体应用有哪些弊端</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lenve/p/11261876.html</dc:identifier>
</item>
<item>
<title>burpsuit用法 - fanyiaaa</title>
<link>http://www.cnblogs.com/fytech-/p/11261871.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fytech-/p/11261871.html</guid>
<description>
&lt;p&gt;1. 学习Proxy首先看标红，intercept is on 为拦截状态  其对应的intercept is off 为非拦截状态,设置完代理后打开拦截状态&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617896/201907/1617896-20190729081859062-73745683.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;，浏览器发起的请求会被burpsuite所拦截forward: 进行请求后被拦截，点击forward可以继续此次请求，如果你点击drop则丢弃此请求数据。继续请求后能够看到返回结果可以在消息分析选项卡查看这次请求的所有内容1. Raw 这个视图主要显示web请求的raw格式，包含请求地址， http协议版本， 主机头， 浏览器信息，accept可接受的内容类型，字符集，编码方式，cookies等,       可以手动修改这些内容，然后在点击forward进行渗透测试2. params 这个视图主要是显示客户端请求的参数信息，get或者post的参数，cookies参数，也可以修改3.headers是头部信息和Raw其实差不多，展示更直观4.Hex 这个试图显示Raw的二进制内容 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1617896/201907/1617896-20190729081837794-1418747747.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;注意： 默认情况下，BurpProxy只拦截请求的消息，普通的文件如css,js,图片是不会拦截的，当然，想拦截什么都可以设置,我们现在知道了怎么设置代理，怎么安装，怎么进行请求拦截，怎么修改请求发起的内容向服务端进行渗透，接下来我们学习一下怎么控制这些拦截 上图为http history 所有拦截的历史均会被记录起来在 http history中能够通过7种情况进行请求过滤：按照请求类型过滤 你可以选择仅显示当前作用域的、仅显示有服务器端响应的和仅显示带有请求参数的消息。当你勾选“仅显示当前作用域”时，此作用域需要在Burp Target的Scope选项中进行配置，详细请阅读Burp Target相关章节。按照MIME类型过滤 你可以控制是否显示服务器端返回的不同的文件类型的消息，比如只显示HTML、css或者图片。此过滤器目前支持HTML、Script、XML、CSS、其他文本、图片、Flash、二进制文件 8种形式。按照服务器返回的HTTP状态码过滤 Burp根据服务器的状态码，按照2XX,3XX,4XX,5XX分别进行过滤。比如，如果你只想显示返回状态码为200的请求成功消息，则勾选2XX。按照查找条件过滤 此过滤器是针对服务器端返回的消息内容，与输入的关键字进行匹配，具体的匹配方式，你可以选择 1.正则表达式 2.大小写敏感 3.否定查找 3种方式的任何组合，前面两种匹配方式容易理解，第3种匹配方式是指与关键字匹配上的将不再显示。按照文件类型过滤 通过文件类型在过滤消息列表，这里有两个选择可供操作。一是仅仅显示哪些，另一个是不显示哪些。如果是仅仅显示哪些，在show only的输入框中填写显示的文件类型，同样，如果不显示哪些文件类型，只要在hide的输入框中填写不需要显示的文件类型即可。按照注解过滤 此过滤器的功能是指，根据每一个消息拦截时候的备注或者是否高亮来作为筛选条件控制哪些消息在历史列表中显示。按照监听端口过滤 此过滤器通常使用于当我们在Proxy Listeners中多个监听端口时，仅仅显示某个监听端口通信的消息，一般情况下，我们很少用到 Burp Proxy的拦截功能主要由Intercept选项卡中的Forward、Drop、Interception is on/off、Action、Comment 以及Highlight构成，它们的功能分别是： Forward的功能是当你查看过消息或者重新编辑过消息之后，点击此按钮，将发送消息至服务器端。 Drop的功能是你想丢失当前拦截的消息，不再forward到服务器端。Interception is on表示拦截功能打开，拦截所有通过Burp Proxy的请求数据；Interception is off表示拦截功能关闭，不再拦截通过Burp Proxy的所有请求数据。 Action的功能是除了将当前请求的消息传递到Spider、Scanner、Repeater、Intruder、Sequencer、Decoder、Comparer组件外，还可以做一些请求消息的修改，如改变GET或者POST请求方式、改变请求body的编码，同时也可以改变请求消息的拦截设置，如不再拦截此主机的消息、不再拦截此IP地址的消息、不再拦截此种文件类型的消息、不再拦截此目录的消息，也可以指定针对此消息拦截它的服务器端返回消息。   &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1617896/201907/1617896-20190729081817679-1954092142.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;                                                                                                                                               接下来我们主要介绍一下 options1.proxyListeners 前面介绍过了，配置代理使用时可以使用2.intercept Client REQUESTS客户端请求消息拦截： Match type表示匹配类型，此处匹配类型可以基于域名、IP地址、协议、请求方法、URL、文件类型、参数, cookies, 头部或者内容, 状态码, MIME类型, HTML页面的title等。relationship表示此条规则是匹配还是不匹配Match condition输入的关键字。当我们输入这些信息，点击【OK】按钮，则规则即被保存。如果intercept request based on the follow rules的checkbox被选中，则拦截所有符合勾选按钮下方列表中的请求规则的消息都将被拦截，拦截时，对规则的过滤是自上而下进行的如果Automatically fix missing的checkbox被选中，则表示在一次消息传输中，Burp Suite会自动修复丢失或多余的新行。比如说，一条被修改过的请求消息，如果丢失了头部结束的空行，Burp Suite会自动添加上；如果一次请求的消息体中，URl编码参数中包含任何新的换行，Burp Suite将会移除。此项功能在手工修改请求消息时，为了防止错误，有很好的保护效果。如果Automatically update Content-Length的checkbox被选中，则当请求的消息被修改后，Content-Length消息头部也会自动被修改，替换为与之相对应的值其他的配置和上面的大同小异，理解其意思就可以根据自己的需要进行配置本&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jul 2019 00:19:00 +0000</pubDate>
<dc:creator>fanyiaaa</dc:creator>
<og:description>1. 学习Proxy首先看标红，intercept is on 为拦截状态 其对应的intercept is off 为非拦截状态,设置完代理后打开拦截状态 ，浏览器发起的请求会被burpsuite所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fytech-/p/11261871.html</dc:identifier>
</item>
<item>
<title>.net持续集成sonarqube篇之 sonarqube触发webhook - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11261868.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11261868.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;WebHook近些年来变得越来越流行,github,gitlab等代码托管平台都提供webhook功能.关于webhook这里不做详细介绍,大家可以参阅读相关互联网书籍或者材料来更深了解.可以把它简单理解为某一事件完成以后的一个回调.&lt;/p&gt;
&lt;p&gt;在持续集成环境里,我们可以使用Sonarqube的webhook功能来实现持续发布和发布包归档功能.大致思路是当项目构建成功后我们可以通过webhook通知服务器构建任务已完成,接下来web 服务器可以根据webhook传递的参数决定要处理的包是哪个项目的包(通过项目的key来判断),如何对包进行归档以及如何把包发布到远程服务器(通过http,ftp等方式).&lt;/p&gt;
&lt;h2 id=&quot;web服务器搭建&quot;&gt;Web服务器搭建&lt;/h2&gt;
&lt;p&gt;要想实现webhook,必须有一个预先设计好的web服务器供回调.我们预先建好了一个web项目(新建一个mvc项目即可)&lt;/p&gt;
&lt;p&gt;由于是测试,我们这里就用Visual的模板生成一个mvc项目,然后在Home控制器下新建一个Action,代码如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;    public IActionResult HookTest([FromBody]SonarQubeVm sonar)
        {
            return new EmptyResult();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;由于Sonarqube webhook是通过post方式提交,因此action必须支持Post方式请求.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参数sonar是&lt;code&gt;SonarQubeVm&lt;/code&gt;类型的参数,是根据Sonarqube请求规格文档构建的,代码如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public class SonarQubeVm
    {
        public DateTime? AnalysedAt { get; set; }
        public SonarProjectInfo project { get; set; }
        public string ServerUrl { get; set; }
        public string Status { get; set; }
        public string TaskId { get; set; }
    }

    public class SonarProjectInfo
    {
        public string Key { get; set; }
        public string Name { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;注意以上参数并不完全包含Sonarqube返回的所有参数,我们只取了部分.关于Sonarqube webhook完整请求参数请查看&lt;code&gt;http://localhost:9000/documentation/webhooks&lt;/code&gt;,localhost:9000是默认的服务器的端口号,如果你更改了端口号或者从外网请求,则要更改为实际的ip地址(或者域名)加上指定的端口号.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;webhook调用&quot;&gt;WebHook调用&lt;/h2&gt;
&lt;p&gt;在Sonarqube里可以通过两种方式调用webhook,全局模式和项目模式.全局模式每当一个构建成功后就会触发.项目模式则只有指定的项目构建以后才会触发.&lt;/p&gt;
&lt;h3 id=&quot;全局模式&quot;&gt;全局模式&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190729075901289-176094376.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图示,我们点击全局&lt;code&gt;Administration&lt;/code&gt;然后点击configuration在出现的下拉列表里选择WebHooks,此时右上角有一个&lt;code&gt;create&lt;/code&gt;按钮,点击后出现一个弹出框,要求输入名称和url,然后点击确定.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190729075855155-526560803.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们以调试模式启动web项目,然后执行一个Sonarqube项目构建,执行完成后看看是否有请求到达web服务器.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MSBuild.SonarQube.Runner.exe begin /k:&quot;mytest&quot; /n:&quot;mytest&quot; /v:&quot;v3.0&quot; /d:sonar.cs.opencover.reportsPaths=&quot;%CD%\testcover.xml&quot;

msbuild.exe

&quot;E:\personalproject\newTest2018\ConsoleApp1\packages\OpenCover.4.6.519\tools\OpenCover.Console.exe&quot; -output:&quot;%CD%\testcover.xml&quot; -register:user -target:&quot;C:\Program Files (x86)\Microsoft Visual Studio\2017\Enterprise\Common7\IDE\CommonExtensions\Microsoft\TestWindow\vstest.console.exe&quot; -targetargs:&quot;%CD%\bin\Debug\NunitTest.dll&quot;

MSBuild.SonarQube.Runner.exe end&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上是我们上一节讲单元测试的时候执行的代码只修改了版本号.我们执行它.&lt;/p&gt;
&lt;p&gt;等等以上代码都执行完成,稍等片刻我们就可以看到http请求击中断点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190729075848899-1198566821.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过serverurl是来自localhost:9000,我们可以确定是Sonarqube发来的请求.项目的key和name都是我们设定的mytest&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;以上仅是个示例程序,没有有用代码,实际项目中我们可以根据webhook请求的key来获取到构建的是哪个项目,然后根据预先设定的逻辑决定把它归档到哪里,以及把它发布到哪些web服务器下的哪些目录里(前面我们讲过通过ftt方式发布web项目,可以在这里使用)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;项目模式&quot;&gt;项目模式&lt;/h3&gt;
&lt;p&gt;项目模式与全局模式设置完全一样,只是入口不同,项目模式需要进入项目的&lt;code&gt;Administration&lt;/code&gt;标签里进行设置.仍然以mytest项目为例子,我们打开mytest项目,进入到Administration标签里选择webhooks即可.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190729075840743-1325043237.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设置和全局设置一样,这里不再赘述.&lt;/p&gt;
&lt;h2 id=&quot;请求认证&quot;&gt;请求认证&lt;/h2&gt;
&lt;p&gt;通过以上配置,我们成功搞好了webhook功能,然而以上代码根本无法使用到生产环境中,因为没有对请求进行认证,如果任何人都可以调用构建服务器地址则后果不堪设想.我们必须对请求进行认证,然后再决定是否执行相应逻辑.&lt;/p&gt;
&lt;p&gt;由于sonaqube不支持设置header,因此我们无法使用复杂的请求认证.只能使用基本的http认证&lt;/p&gt;
&lt;p&gt;我们在服务端增加以下类&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; public class BasicAuthenticationAttribute: ActionFilterAttribute
    {
        protected string Username { get; set; } = &quot;sto&quot;;
        protected string Password { get; set; } = &quot;sto&quot;;

        public override void OnActionExecuting(ActionExecutingContext filterContext)
        {
            var req = filterContext.HttpContext.Request;
            var auth = req.Headers[&quot;Authorization&quot;].ToString();
            if (!String.IsNullOrEmpty(auth))
            {
                var cred = System.Text.Encoding.ASCII.GetString(Convert.FromBase64String(auth.Substring(6))).Split(':');
                var user = new { Name = cred[0], Pass = cred[1] };
                if (user.Name == Username &amp;amp;&amp;amp; user.Pass == Password) return;
            }
            filterContext.Result = new UnauthorizedResult();
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码中,我们通过硬编码方式指定了用户名和密码,实际生产环境中我们可以通过查询数据库来获取用户名和密码. 在&lt;code&gt;OnActionExecuting&lt;/code&gt;重写方法中我们通过头信息&lt;code&gt;Authorization&lt;/code&gt;获取加密的Base64字符串,然后通过&lt;code&gt;:&lt;/code&gt;分割获取到用户名和密码.然后和真实用户名密码做对比然后决定下一步动作.&lt;/p&gt;
&lt;p&gt;我们把这个filter加到请求方法上.&lt;/p&gt;
&lt;p&gt;改造后的代码如下:&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [BasicAuthentication]
        public IActionResult HookTest([FromBody]SonarQubeVm sonar)
        {
            return new EmptyResult();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们把webhook的url更新为如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://sto:sto1@localhost:49442/home/HookTest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实际上服务端逻辑要求账户和密码都必须是sto能请求,我们故意把密码改为sto1看看请求是否能成功.&lt;/p&gt;
&lt;p&gt;我们仍然执行前面的构建代码,只是把版本号增加一下.&lt;/p&gt;
&lt;p&gt;我们再进入webhook管理界面,可以看到请求失败了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190729075834557-129447880.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们点击失日期后面的&lt;code&gt;四框&lt;/code&gt;图标,可以看到失败的状态是401&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190729075827986-1328546036.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们把请求地址更改为如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;http://sto:sto@localhost:49442/home/HookTest&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里sto1改为服务器期待的sto,请求就能成功了.&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jul 2019 00:18:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' WebHook近些年来变得越来越流行,github,gitlab等代码托管平台都提供webhook功能.关于webhook这里不做详细介绍,大家可以参阅读相关互联网书籍或者材料来更深了解</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11261868.html</dc:identifier>
</item>
<item>
<title>WebRTC：会话描述协议SDP - 程序猿小卡</title>
<link>http://www.cnblogs.com/chyingp/p/sdp-in-webrtc.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chyingp/p/sdp-in-webrtc.html</guid>
<description>&lt;h2 id=&quot;什么是sdp&quot;&gt;什么是SDP&lt;/h2&gt;
&lt;p&gt;SDP（Session Description Protocol）是一种通用的会话描述协议，主要用来描述多媒体会话，用途包括会话声明、会话邀请、会话初始化等。&lt;/p&gt;
&lt;p&gt;WebRTC主要在连接建立阶段用到SDP，连接双方通过信令服务交换会话信息，包括音视频编解码器(codec)、主机候选地址、网络传输协议等。&lt;/p&gt;
&lt;p&gt;下面先简单介绍下SDP的格式、常用属性，然后通过WebRTC连接建立过程生成的SDP实例进行进一步讲解。&lt;/p&gt;
&lt;h2 id=&quot;协议格式说明&quot;&gt;协议格式说明&lt;/h2&gt;
&lt;p&gt;SDP的格式非常简单，由多个行组成，每个行都是如下格式。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;type&amp;gt;=&amp;lt;value&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt;：大小写敏感的一个字符，代表特定的属性，比如&lt;code&gt;v&lt;/code&gt;代表版本；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;value&amp;gt;&lt;/code&gt;：结构化文本，格式与属性类型有关，UTF8编码；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt;两边不允许存在空格；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=*&lt;/code&gt;表示是可选的；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;常见属性&quot;&gt;常见属性&lt;/h2&gt;
&lt;p&gt;以下面的SDP为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;v=0
o=alice 2890844526 2890844526 IN IP4 host.anywhere.com
s=
c=IN IP4 host.anywhere.com
t=0 0
m=audio 49170 RTP/AVP 0
a=rtpmap:0 PCMU/8000
m=video 51372 RTP/AVP 31
a=rtpmap:31 H261/90000
m=video 53000 RTP/AVP 32
a=rtpmap:32 MPV/90000&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;协议版本号v&quot;&gt;协议版本号：&lt;code&gt;v=&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;格式如下，注意，没有子版本号。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;v=0&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;会话发起者o&quot;&gt;会话发起者：&lt;code&gt;o&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;格式如下，其中，username、session-id、nettype、addrtype、unicast-address 一起，唯一标识一个会话。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;o=&amp;lt;username&amp;gt; &amp;lt;sess-id&amp;gt; &amp;lt;sess-version&amp;gt; &amp;lt;nettype&amp;gt; &amp;lt;addrtype&amp;gt; &amp;lt;unicast-address&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;各字段含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;username：发起者的用户名，不允许存在空格，如果应用不支持用户名，则为&lt;code&gt;-&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;sess-id：会话id，由应用自行定义，规范的建议是NTP(Network Time Protocol)时间戳。&lt;/li&gt;
&lt;li&gt;sess-version：会话版本，用途由应用自行定义，只要会话数据发生变化时（比如编码），sess-version随着递增就行。同样的，规范的建议是NTP时间戳。&lt;/li&gt;
&lt;li&gt;nettype：网络类型，比如&lt;code&gt;IN&lt;/code&gt;表示&lt;code&gt;Internet&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;addrtype：地址类型，比如&lt;code&gt;IP4&lt;/code&gt;、&lt;code&gt;IV6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;unicast-address：域名，或者IP地址。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;会话名-s&quot;&gt;会话名 &lt;code&gt;s=&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;必选，有且仅有一个&lt;code&gt;s=&lt;/code&gt;字段，且不能为空。如果实在没有有意义的会话名，可以赋一个空格，即&lt;code&gt;s=&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s=&amp;lt;session name&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;连接数据c&quot;&gt;连接数据：c=&lt;/h3&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;c=&amp;lt;nettype&amp;gt; &amp;lt;addrtype&amp;gt; &amp;lt;connection-address&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;每个SDP至少需要包含一个会话级别的&lt;code&gt;c=&lt;/code&gt;字段，或者在每个媒体描述后面各包含一个&lt;code&gt;c=&lt;/code&gt;字段。（媒体描述后的&lt;code&gt;c=&lt;/code&gt;会覆盖会话级别的&lt;code&gt;c=&lt;/code&gt;）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;nettype：网络类型，比如&lt;code&gt;IN&lt;/code&gt;，表示 Internet。&lt;/li&gt;
&lt;li&gt;addrtype：地址类型，比如&lt;code&gt;IP4&lt;/code&gt;、&lt;code&gt;IP6&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;connection-address：如果是广播，则为广播地址组；如果是单播，则为单播地址；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举例01：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;c=IN IP4 224.2.36.42/127&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举例02：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;c=IN IP4 host.anywhere.com&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;媒体描述m&quot;&gt;媒体描述：&lt;code&gt;m=&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;SDP可能同时包含多个媒体描述。格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;m=&amp;lt;media&amp;gt; &amp;lt;port&amp;gt; &amp;lt;proto&amp;gt; &amp;lt;fmt&amp;gt; ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;media：媒体类型。包括 video、audio、text、application、message等。&lt;/li&gt;
&lt;li&gt;port：传输媒体流的端口，具体含义取决于使用的网络类型（在&lt;code&gt;c=&lt;/code&gt;中声明）和使用的协议(proto，在&lt;code&gt;m=&lt;/code&gt;中声明)。&lt;/li&gt;
&lt;li&gt;proto：传输协议，具体含义取决于&lt;code&gt;c=&lt;/code&gt;中定义的地址类型，比如&lt;code&gt;c=&lt;/code&gt;是IP4，那么这里的传输协议运行在IP4之上。比如：
&lt;ul&gt;&lt;li&gt;UDP：传输层协议是UDP。&lt;/li&gt;
&lt;li&gt;RTP/AVP：针对视频、音频的RTP协议，跑在UDP之上。&lt;/li&gt;
&lt;li&gt;RTP/SAVP：针对视频、音频的SRTP协议，跑在UDP之上。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;fmt：媒体格式的描述，可能有多个。根据 proto 的不同，fmt 的含义也不同。比如 proto 为 RTP/SAVP 时，fmt 表示 RTP payload 的类型。如果有多个，表示在这次会话中，多种payload类型可能会用到，且第一个为默认的payload类型。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;举例，下面表示媒体类型是视频，采用SRTP传输流媒体数据，且RTP包的类型可能是122、102...119，默认是122。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;m=video 9 UDP/TLS/RTP/SAVPF 122 102 100 101 124 120 123 119&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于 RTP/SAVP，需要注意的是，payload type 又分两种类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;静态类型：参考 &lt;a href=&quot;https://en.wikipedia.org/wiki/RTP_audio_video_profile#RTP/AVP_audio_and_video_payload_types&quot;&gt;RTP/AVP audio and video payload types&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;动态类型：在&lt;code&gt;a=fmtp:&lt;/code&gt;里进行定义。(&lt;code&gt;a=&lt;/code&gt;为附加属性，见后面小节)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举例，下面的SDP中：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对于audio，111 是动态类型，表示&lt;code&gt;opus/48000/2&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;对于video，122 是动态类型，表示&lt;code&gt;H264/90000&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 126
a=rtpmap:111 opus/48000/2
m=video 9 UDP/TLS/RTP/SAVPF 122 102 100 101 124 120 123 119
a=rtpmap:122 H264/90000&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;附加属性a&quot;&gt;附加属性：&lt;code&gt;a=&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;作用：用于扩展SDP。&lt;/p&gt;
&lt;p&gt;有两种作用范围：会话级别(session-level)、媒体级别（media-level）。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;媒体级别：媒体描述（m=）后面可以跟任意数量的 a= 字段，对媒体描述进行扩展。&lt;/li&gt;
&lt;li&gt;会话级别：在第一个媒体字段(media field)前，添加的 a= 字段是会话级别的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有如下两种格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a=&amp;lt;attribute&amp;gt;
a=&amp;lt;attribute&amp;gt;:&amp;lt;value&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;格式1举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a=recvonly&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;格式2举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a=rtpmap:0 PCMU/8000&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;时间t&quot;&gt;时间：&lt;code&gt;t=&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;作用：声明会话的开始、结束时间。&lt;/p&gt;
&lt;p&gt;格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t=&amp;lt;start-time&amp;gt; &amp;lt;stop-time&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果&lt;code&gt;&amp;lt;stop-time&amp;gt;&lt;/code&gt;是0，表示会话没有结束的边界，但是需要在&lt;code&gt;&amp;lt;start-time&amp;gt;&lt;/code&gt;之后会话才是活跃(active)的。如果&lt;code&gt;&amp;lt;start-time&amp;gt;&lt;/code&gt;是0，表示会话是永久的。&lt;/p&gt;
&lt;p&gt;举例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;t=0 0&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;webrtc实例&quot;&gt;WebRTC实例&lt;/h2&gt;
&lt;p&gt;下面例子来自腾讯云WebRTC服务的远端offer。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// sdp版本号为0
v=0
// o=&amp;lt;username&amp;gt; &amp;lt;sess-id&amp;gt; &amp;lt;sess-version&amp;gt; &amp;lt;nettype&amp;gt; &amp;lt;addrtype&amp;gt; &amp;lt;unicast-address&amp;gt;
// 用户名为空，会话id是8100750360520823155，会话版本是2（后面如果有类似改变编码的操作，sess-version加1），地址类型为IP4，地址为127.0.0.1（这里可以忽略）
o=- 7595655801978680453 2 IN IP4 112.90.139.105
// 会话名为空
s=-
// 会话的起始时间，都为0表示没有限制
t=0 0
a=ice-lite
// 音频、视频的传输的传输采取多路复用，通过同一个RTP通道传输音频、视频，可以参考 https://tools.ietf.org/html/draft-ietf-mmusic-sdp-bundle-negotiation-54
a=group:BUNDLE 0 1
// WMS是WebRTC Media Stram的缩写，这里给Media Stream定义了一个唯一的标识符。一个Media Stream可以有多个track（video track、audio track），这些track就是通过这个唯一标识符关联起来的，具体见下面的媒体行(m=)以及它对应的附加属性(a=ssrc:)
// 可以参考这里 http://tools.ietf.org/html/draft-ietf-mmusic-msid
a=msid-semantic: WMS 5Y2wZK8nANNAoVw6dSAHVjNxrD1ObBM2kBPV
// m=&amp;lt;media&amp;gt; &amp;lt;port&amp;gt; &amp;lt;proto&amp;gt; &amp;lt;fmt&amp;gt; ...
// 本次会话有音频，端口为9（可忽略，端口9为Discard Protocol专用），采用UDP传输加密的RTP包，并使用基于SRTCP的音视频反馈机制来提升传输质量，111、103、104等是audio可能采用的编码（参见前面m=的说明）
m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 126
// 音频发送者的IP4地址，WebRTC采用ICE，这里的 0.0.0.0 可直接忽略
c=IN IP4 0.0.0.0
// RTCP采用的端口、IP地址（可忽略）
a=rtcp:9 IN IP4 0.0.0.0
// ice-ufrag、ice-pwd 分别为ICE协商用到的认证信息
a=ice-ufrag:58142170598604946
a=ice-pwd:71696ad0528c4adb02bb40e1
// DTLS协商过程的指纹信息
a=fingerprint:sha-256 7F:98:08:AC:17:6A:34:DB:CF:3B:EC:93:ED:57:3F:5A:9E:1F:4A:F3:DB:D5:BF:66:EE:17:58:E0:57:EC:1B:19
// 当前客户端在DTLS协商过程中，既可以作为客户端，也可以作为服务端，具体可参考 RFC4572
a=setup:actpass
// 当前媒体行的标识符（在a=group:BUNDLE 0 1 这行里面用到，这里0表示audio）
a=mid:0
// RTP允许扩展首部，这里表示采用了RFC6464定义的针对audio的扩展首部，用来调节音量，比如在大型会议中，有多个音频流，就可以用这个来调整音频混流的策略
// 这里没有vad=1，表示不启用这个音量控制
a=extmap:1 urn:ietf:params:rtp-hdrext:ssrc-audio-level
// 表示既可以发送音频，也可以接收音频
a=sendrecv
// 表示启用多路复用，RTP、RTCP共用同个通道
a=rtcp-mux
// 下面几行都是对audio媒体行的补充说明（针对111），包括rtpmap、rtcp-fb、fmtp
// rtpmap：编解码器为opus，采样率是48000，2声道
a=rtpmap:111 opus/48000/2
// rtcp-fb：基于RTCP的反馈控制机制，可以参考 https://tools.ietf.org/html/rfc5124、https://webrtc.org/experiments/rtp-hdrext/transport-wide-cc-02/
a=rtcp-fb:111 transport-cc
a=rtcp-fb:111 nack
// 最小的音频打包时间
a=fmtp:111 minptime=20
// 跟前面的rtpmap类似
a=rtpmap:126 telephone-event/8000
// ssrc用来对媒体进行描述，格式为a=ssrc:&amp;lt;ssrc-id&amp;gt; &amp;lt;attribute&amp;gt;:&amp;lt;value&amp;gt;，具体可参考 RFC5576
// cname用来唯一标识媒体的数据源
a=ssrc:16864608 cname:YZcxBwerFFm6GH69
// msid后面带两个id，第一个是MediaStream的id，第二个是audio track的id（跟后面的mslabel、label对应）
a=ssrc:16864608 msid:5Y2wZK8nANNAoVw6dSAHVjNxrD1ObBM2kBPV 128f4fa0-81dd-4c3a-bbcd-22e71e29d178
a=ssrc:16864608 mslabel:5Y2wZK8nANNAoVw6dSAHVjNxrD1ObBM2kBPV
a=ssrc:16864608 label:128f4fa0-81dd-4c3a-bbcd-22e71e29d178
// 跟audio类似，不赘述
m=video 9 UDP/TLS/RTP/SAVPF 122 102 125 107 124 120 123 119
c=IN IP4 0.0.0.0
a=rtcp:9 IN IP4 0.0.0.0
a=ice-ufrag:58142170598604946
a=ice-pwd:71696ad0528c4adb02bb40e1
a=fingerprint:sha-256 7F:98:08:AC:17:6A:34:DB:CF:3B:EC:93:ED:57:3F:5A:9E:1F:4A:F3:DB:D5:BF:66:EE:17:58:E0:57:EC:1B:19
a=setup:actpass
a=mid:1
a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time
a=extmap:4 urn:3gpp:video-orientation
a=extmap:5 http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01
a=extmap:6 http://www.webrtc.org/experiments/rtp-hdrext/playout-delay
a=sendrecv
a=rtcp-mux
a=rtcp-rsize
a=rtpmap:122 H264/90000
a=rtcp-fb:122 ccm fir
a=rtcp-fb:122 nack
a=rtcp-fb:122 nack pli
a=rtcp-fb:122 goog-remb
a=rtcp-fb:122 transport-cc
a=fmtp:122 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001f
a=rtpmap:102 rtx/90000
a=fmtp:102 apt=122
a=rtpmap:125 H264/90000
a=rtcp-fb:125 ccm fir
a=rtcp-fb:125 nack
a=rtcp-fb:125 nack pli
a=rtcp-fb:125 goog-remb
a=rtcp-fb:125 transport-cc
a=fmtp:125 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f
a=rtpmap:107 rtx/90000
a=fmtp:107 apt=125
a=rtpmap:124 H264/90000
a=rtcp-fb:124 ccm fir
a=rtcp-fb:124 nack
a=rtcp-fb:124 nack pli
a=rtcp-fb:124 goog-remb
a=rtcp-fb:124 transport-cc
a=fmtp:124 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=4d0032
a=rtpmap:120 rtx/90000
a=fmtp:120 apt=124
a=rtpmap:123 H264/90000
a=rtcp-fb:123 ccm fir
a=rtcp-fb:123 nack
a=rtcp-fb:123 nack pli
a=rtcp-fb:123 goog-remb
a=rtcp-fb:123 transport-cc
a=fmtp:123 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640032
a=rtpmap:119 rtx/90000
a=fmtp:119 apt=123
a=ssrc-group:FID 33718809 50483271
a=ssrc:33718809 cname:ovaCctnHP9Asci9c
a=ssrc:33718809 msid:5Y2wZK8nANNAoVw6dSAHVjNxrD1ObBM2kBPV 1d7fc300-9889-4f94-9f35-c0bcc77a260d
a=ssrc:33718809 mslabel:5Y2wZK8nANNAoVw6dSAHVjNxrD1ObBM2kBPV
a=ssrc:33718809 label:1d7fc300-9889-4f94-9f35-c0bcc77a260d
a=ssrc:50483271 cname:ovaCctnHP9Asci9c
a=ssrc:50483271 msid:5Y2wZK8nANNAoVw6dSAHVjNxrD1ObBM2kBPV 1d7fc300-9889-4f94-9f35-c0bcc77a260d
a=ssrc:50483271 mslabel:5Y2wZK8nANNAoVw6dSAHVjNxrD1ObBM2kBPV
a=ssrc:50483271 label:1d7fc300-9889-4f94-9f35-c0bcc77a260d&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;写在后面&quot;&gt;写在后面&lt;/h2&gt;
&lt;p&gt;SDP协议格式本身很简单，难点一般在于应用层在不同场景下扩展出来的属性，以及不同扩展属性对应的含义。比如上面举的例子，扩展属性、属性值的说明分散在数十个RFC里，查找、理解都费了一番功夫。&lt;/p&gt;
&lt;p&gt;如有错漏，敬请指出。&lt;/p&gt;
&lt;h2 id=&quot;相关链接&quot;&gt;相关链接&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4566&quot;&gt;SDP: Session Description Protocol&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://datatracker.ietf.org/doc/draft-ietf-rtcweb-sdp/&quot;&gt;Annotated Example SDP for WebRTC&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 29 Jul 2019 00:12:00 +0000</pubDate>
<dc:creator>程序猿小卡</dc:creator>
<og:description>WebRTC主要在连接建立阶段用到SDP，连接双方通过信令服务交换会话信息，包括音视频编解码器(codec)、主机候选地址、网络传输协议等。下面先简单介绍下SDP的格式、常用属性，然后通过WebRTC</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chyingp/p/sdp-in-webrtc.html</dc:identifier>
</item>
<item>
<title>一文带你了解Java反射机制 - 代码无止境</title>
<link>http://www.cnblogs.com/endless-code/p/11261558.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endless-code/p/11261558.html</guid>
<description>&lt;blockquote readability=&quot;3.943661971831&quot;&gt;
&lt;p&gt;想要获取更多文章可以访问我的博客 - &lt;a href=&quot;https://itweknow.cn&quot;&gt;代码无止境&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上周上班的时候解决一个需求，需要将一批数据导出到Excel。本来公司的中间件组已经封装好了使用POI生成Excel的工具方法，但是无奈产品的需求里面有个合并单元格的要求，工具类中找了半天也没发现适用的方法，就只能自己撸起袖子干了。导出Excel的工具方法会少不了使用反射，但是反射这东西对于我这种写业务代码的人来说接触比较少，所以就恶补了一下，写下这篇文章记录一下。&lt;/p&gt;
&lt;h3 id=&quot;什么是反射&quot;&gt;什么是反射&lt;/h3&gt;
&lt;p&gt;万物究其根，研究一样新东西，首先我们需要了解它是什么，干什么用的。在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。那么我们又能利用反射做什么呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在运行时分析类。&lt;/li&gt;
&lt;li&gt;在运行时查看对象，我们还可以利用反射编写一个toString方法供所有类使用。&lt;/li&gt;
&lt;li&gt;利用Method对象，在运行时任意调用一个对象的方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么本篇文章将围绕者上面三个点来了解一下Java的反射机制。在开始之前，我们先来介绍一下一个类，这个类是我们在使用反射的过程中必不可少会使用到的一个类。&lt;/p&gt;
&lt;h3 id=&quot;class类&quot;&gt;Class类&lt;/h3&gt;
&lt;p&gt;在运行时，Java运行时系统会为每一个对象都维护一个标识这个对象类型的信息，而保存这些信息的类型就是Class类。我们可以通过对象的&lt;code&gt;getClass()&lt;/code&gt;方法来获取该对象对于的Class对象，就像下面这样。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;User user = new User();
Class c = user.getClass();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个世界上的任何东西都有它存在的意义，那么我们可以用Class对象来干什么呢？我们最常使用Class来判断一个对象是不是属于某个类型，就像下面这样：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;User user = new User();

if (user.getClass() == User.class) {
    System.out.println(&quot;user is User&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然我们也经常会使用Class类的&lt;code&gt;getName()&lt;/code&gt;方法来获取某个类的名称。有写时候，我们还会利用它的&lt;code&gt;newInstance()&lt;/code&gt;方法来获取某个类型的实例（当这类没有提供共有的构造方法时）。&lt;/p&gt;
&lt;h3 id=&quot;利用反射分析类&quot;&gt;利用反射分析类&lt;/h3&gt;
&lt;p&gt;分析一个类，无外乎就是查看这个类中的属性、方法以及其构造方法了。在Java的反射包中提供了三个类Field、Method以及Constructor来分别描述属性、方法和构造器。&lt;br/&gt;下面我们就分别来看下，我们是如何通过反射机制来获取一个类的这些信息的。&lt;br/&gt;1.获取属性&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;User user = new User();
Class cl = user.getClass();
Field[] fields1 = cl.getFields();
Field[] fields2 = cl.getDeclaredFields();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我们可以利用&lt;code&gt;getFields()&lt;/code&gt;和&lt;code&gt;getDeclaredFields()&lt;/code&gt;两个方法来获取类中的属性列表，那么这两个方法有什么区别呢？区别就是前者只会返回类的共有成员信息，而后者这会返回类中所有的成员信息包括公有的、私有的、受保护的，但是不包括父类的成员信息。&lt;/p&gt;
&lt;p&gt;2.获取构造器&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Constructor[] constructors1 = cl.getConstructors();
Constructor[] constructors2 = cl.getDeclaredConstructors();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.获取方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Method[] methods1 = cl.getMethods();
Method[] methods2 = cl.getDeclaredMethods();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到我们可以通过一个类的Class对象很轻松的获取他的属性、构造器以及方法信息。但是在Field、Constructor以及Method中又分别提供了哪些api呢？下面我们就一起来看下。&lt;/p&gt;
&lt;p&gt;1.&lt;code&gt;getName()&lt;/code&gt;方法，用来获取对应的名称。&lt;strong&gt;&lt;em&gt;同时存在于Field、Constructor以及Method类中&lt;/em&gt;&lt;/strong&gt;。&lt;br/&gt;2.&lt;code&gt;getModifiers()&lt;/code&gt;方法来获取前面的修饰符（public等），但是&lt;code&gt;getModifiers()&lt;/code&gt;返回的是一个int值，我们可以通过&lt;code&gt;Modifier.toString(int i)&lt;/code&gt;将其转换成对应的字符串。&lt;strong&gt;&lt;em&gt;也同样同时存在于Field、Constructor以及Method类中。&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;3.&lt;code&gt;getParameterTypes()&lt;/code&gt;方法，用来获取方法的参数类型数组。&lt;strong&gt;&lt;em&gt;存在于Constructor以及Method类中&lt;/em&gt;&lt;/strong&gt;&lt;br/&gt;4.&lt;code&gt;getReturnType()&lt;/code&gt;方法，用来获取方法的返回类型。&lt;strong&gt;&lt;em&gt;只存在于Method类中&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有了这些api，我们就拥有了在运行时分析一个类的能力，我们可以通过一个简单的小例子来实践一下，我们可以编写一个方法来输出一个类的完整信息，具体的实现会在文末给出，大家可以先自己尝试一下。&lt;/p&gt;
&lt;h3 id=&quot;利用反射查看对象&quot;&gt;利用反射查看对象&lt;/h3&gt;
&lt;p&gt;有些时候呢，我们可能也需要反射去获取对象中属性的值，比如说在导出Excel的时候，我们只知道列所对应属性的字段名称，然后我们需要通过反射获取它的值，然后把它写到Excel中。那么这节内容就一起来看下如何利用Java的反射机制来分析对象。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;User user = new User(1,&quot;itweknow&quot;);
Class cl = user.getClass();
Field userName = cl.getDeclaredField(&quot;userName&quot;);
Object value = userName.get(user);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就像上面的代码一样，我们可以使用&lt;code&gt;Field&lt;/code&gt;类中提供的&lt;code&gt;get(Object obj)&lt;/code&gt;方法来获取属性的值，对于基础类型还提供了特定的get方法，比如&lt;code&gt;getDouble()&lt;/code&gt;。但是如果上面的&lt;code&gt;userName&lt;/code&gt;是个私有属性的话，&lt;code&gt;get()&lt;/code&gt;方法肯定会抛出&lt;code&gt;IllegalAccessException&lt;/code&gt;的异常。这是时候我们需要使用&lt;code&gt;setAccessible()&lt;/code&gt;方法覆盖安全管理器的访问控制。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;User user = new User(1,&quot;itweknow&quot;);
Class cl = user.getClass();
Field userName = cl.getDeclaredField(&quot;userName&quot;);
userName.setAccessible(true);
Object value = userName.get(user);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;setAccessible()&lt;/code&gt;方法在&lt;code&gt;Field&lt;/code&gt;、&lt;code&gt;Method&lt;/code&gt;、&lt;code&gt;Constructor&lt;/code&gt;类中都有提供。与&lt;code&gt;get()&lt;/code&gt;方法呼应，&lt;code&gt;Field&lt;/code&gt;还提供了&lt;code&gt;set()&lt;/code&gt;方法用来给属性设置值。&lt;/p&gt;
&lt;h3 id=&quot;利用反射调用任何方法&quot;&gt;利用反射调用任何方法&lt;/h3&gt;
&lt;p&gt;在Method类中提供了&lt;code&gt;invoke()&lt;/code&gt;方法来调用，当前Method对象所包装的方法。&lt;code&gt;invoke()&lt;/code&gt;方法的定义如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Object invoke(Object obj, Object... args)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个参数是调用这个方法的对象，第二个参数是该方法的参数，是一个数组的形式。下面我们就来看下如何利用反射来调用&lt;code&gt;User&lt;/code&gt;类中的&lt;code&gt;sayHello()&lt;/code&gt;方法吧。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Method sayHelloMethod = cl.getDeclaredMethod(&quot;sayHello&quot;, String.class);
sayHelloMethod.setAccessible(true);
sayHelloMethod.invoke(user, &quot;Reflect&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上面的代码我们通过&lt;code&gt;getDeclaredMethod()&lt;/code&gt;方法来获取了一个名为&lt;code&gt;sayHello&lt;/code&gt;的私有方法（PS:如果是公有方法的话直接使用&lt;code&gt;getMethod()&lt;/code&gt;方法就可以了），同样对于私有方法，我们需要修改它的访问控制才能顺利调用。&lt;/p&gt;
&lt;h3 id=&quot;api整理&quot;&gt;API整理&lt;/h3&gt;
&lt;p&gt;上面的章节中提到了不少Java反射机制中提供的Api，下面是我整理的一些常用的反射Api，大家可以参考一下。&lt;/p&gt;
&lt;p&gt;1.Class类&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;forName()&lt;/td&gt;
&lt;td&gt;返回指定类名的Class对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;newInstance()&lt;/td&gt;
&lt;td&gt;返回一个这个类的新实例&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getFields()&lt;/td&gt;
&lt;td&gt;返回这个类所有的公有属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getDeclaredField()&lt;/td&gt;
&lt;td&gt;返回这个类所有的属性（包含公有、私有、受保护）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getMethods()&lt;/td&gt;
&lt;td&gt;返回这个类下所有的共有方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getDeclaredMethods()&lt;/td&gt;
&lt;td&gt;返回这个类所有的方法（包含公有、私有、受保护）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getConstructors()&lt;/td&gt;
&lt;td&gt;返回这个类所有公有的构造器&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;getDeclaredConstructors()&lt;/td&gt;
&lt;td&gt;返回这个类所有的构造器（包含公有、私有、受保护）&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;getField() &amp;amp; getDeclaredField()&lt;/td&gt;
&lt;td&gt;返回这个类中指定名称的属性&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;getMethod() &amp;amp; getDeclaredMethod()&lt;/td&gt;
&lt;td&gt;返回指定名称和参数的方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;cl.getConstructor() &amp;amp; cl.getDeclaredConstructor()&lt;/td&gt;
&lt;td&gt;获取指定参数的构造器&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;2.Field类&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;getModifiers()&lt;/td&gt;
&lt;td&gt;返回一个用于描述属性的修饰符的整型数值。使用 Modifier类中的&lt;code&gt;toString()&lt;/code&gt;方法将其转为字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getName()&lt;/td&gt;
&lt;td&gt;返冋一个用于描述属性名的字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;3.Method类&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;5.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;getModifiers()&lt;/td&gt;
&lt;td&gt;返回一个用于描述方法的修饰符的整型数值。使用 Modifier类中的&lt;code&gt;toString()&lt;/code&gt;方法将其转为字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getName()&lt;/td&gt;
&lt;td&gt;返冋一个用于描述方法名的字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getParameterTypes()&lt;/td&gt;
&lt;td&gt;返回一个用于描述参数类型的Class对象数组。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getReturnType()&lt;/td&gt;
&lt;td&gt;返回一个用于描述返H类型的Class对象。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;invoke()&lt;/td&gt;
&lt;td&gt;调用这个对象所描述的方法， 传递给定参数，并返回方法的返回值。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;4.Constructor类&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;getModifiers()&lt;/td&gt;
&lt;td&gt;返回一个用于描述构造器的修饰符的整型数值。使用 Modifier类中的&lt;code&gt;toString()&lt;/code&gt;方法将其转为字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getName()&lt;/td&gt;
&lt;td&gt;返冋一个用于描述构造器名的字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;getParameterTypes()&lt;/td&gt;
&lt;td&gt;返回一个用于描述参数类型的Class对象数组。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;5.AccessibleObject类&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;setAccessible(boolean flag)&lt;/td&gt;
&lt;td&gt;为反射对象设置可访问标志。flag 为 true 表明屏蔽 Java 语言的访问检查，使得对象的私有属性也可以被査询和设置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;isAccessible()&lt;/td&gt;
&lt;td&gt;返回反射对象的可访问标志的值。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;结束语&quot;&gt;结束语&lt;/h3&gt;
&lt;p&gt;这篇文章主要和大家一起了解了一下Java的反射机制，以及在反射包下&lt;code&gt;Field&lt;/code&gt;、&lt;code&gt;Method&lt;/code&gt;、&lt;code&gt;Constructor&lt;/code&gt;三个类所提供的api。在&lt;strong&gt;&lt;em&gt;利用反射分析类&lt;/em&gt;&lt;/strong&gt;小节中，我提到了使用反射打印类的完整信息，具体的实现代码&lt;a href=&quot;https://github.com/ganchaoyang/java-tutorial/blob/master/reflect/src/main/java/cn/itweknow/reflect/AnalysisClass.java&quot;&gt;点击这里获取&lt;/a&gt;。希望这篇文章能够对大家有所帮助。最后，如果你喜欢这篇文章的话欢迎在Github&lt;a href=&quot;https://github.com/ganchaoyang/java-tutorial&quot;&gt;源码项目&lt;/a&gt;点个Star。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS:学习不止，码不停蹄！如果您喜欢我的文章，就关注我吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://g-blog.oss-cn-beijing.aliyuncs.com/image/qrcode_for_gh_526c6f450b21_258.jpg&quot; alt=&quot;扫码关注“代码无止境”&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 29 Jul 2019 00:07:00 +0000</pubDate>
<dc:creator>代码无止境</dc:creator>
<og:description>想要获取更多文章可以访问我的博客 '代码无止境' 。 上周上班的时候解决一个需求，需要将一批数据导出到Excel。本来公司的中间件组已经封装好了使用POI生成Excel的工具方法，但是无奈产品的需求里</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/endless-code/p/11261558.html</dc:identifier>
</item>
<item>
<title>使用腾讯云提供的针对Nuget包管理器的缓存加速服务 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/11261216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/11261216.html</guid>
<description>&lt;p&gt;继阿里巴巴开源镜像站（&lt;a href=&quot;https://opsx.alibaba.com/&quot;&gt;https://opsx.alibaba.com/&lt;/a&gt;）、华为云镜像站点（&lt;a href=&quot;https://mirrors.huaweicloud.com/&quot;&gt;https://mirrors.huaweicloud.com/&lt;/a&gt; ）之后，腾讯也已于近日&lt;a href=&quot;https://mirrors.cloud.tencent.com/index.html&quot;&gt;上线&lt;/a&gt;了类似的服务，官方名称为腾讯云软件源（Tencent Open Source Mirror Site），为国内开发者提供新的软件镜像源选择[&lt;a title=&quot;https://mp.weixin.qq.com/s/T43MZSDiN04EdgirBif1GQ&quot; href=&quot;https://mp.weixin.qq.com/s/T43MZSDiN04EdgirBif1GQ&quot;&gt;https://mp.weixin.qq.com/s/T43MZSDiN04EdgirBif1GQ&lt;/a&gt;]。与国内其他同类服务相似，此开源镜像站提供了主流的Linux发行版安装镜像下载以及软件源镜像，还有几大语言程序包的仓库服务，比如Node.js的npm仓库和Python的pip仓库以及dotnet的nuget 仓库。Nuget 镜像地址是（&lt;a title=&quot;https://mirrors.cloud.tencent.com/nuget/&quot; href=&quot;https://mirrors.cloud.tencent.com/nuget/&quot;&gt;https://mirrors.cloud.tencent.com/nuget/&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;在Visual Studio 2013、2015、2017、2019 中，使用的是Nuget包管理器对第三方组件进行管理升级的。而且 Nuget 是我们使用.NET Core的一项基础设施，.NET的软件包管理器NuGet.org是一项面向全球用户搭建的服务，不论用户身在何处，NuGet.org都应该有能力提供高性能的服务。2017 年微软针对中国访问Nuget服务的访问慢的问题进行了优化，把Blob存储备份到中国本地，并使用本地CDN服务商来处理软件包下载请求，具体参考 https://blog.nuget.org/20170907/Changes-to-NuGet-dot-org-service-management-and-performance-improvements-in-China.html。&lt;/p&gt;
&lt;p&gt;Nuget包的API分为搜索、注册和存储三大类。其中使用最为频繁的是注册和存储两类API。 Nuget镜像包含了缓存的反向代理来加速这些API。 使用这个镜像可以在腾讯云和在应用开发可实现如下加速效果：&lt;/p&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;对于包的搜索&lt;/strong&gt;：&lt;strong&gt;无加速效果&lt;/strong&gt;。搜索组件包是由额外的域名提供的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;安装、卸载、升级包等&lt;/strong&gt;：&lt;strong&gt;完全加速&lt;/strong&gt;。所有包信息均按天缓存在服务器上，每天每个包第一次访问为代理访问，随后均为本地访问&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;包安装、升级下载文件&lt;/strong&gt;：&lt;strong&gt;完全加速&lt;/strong&gt;。每个包的每个版本第一次下载微代理访问，之后所有同样版本、ID的包均为本地访问&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;使用方法:&lt;/h3&gt;
&lt;p&gt;在Visual Studio中点击“&lt;kbd&gt;工具&lt;/kbd&gt;”-“&lt;kbd&gt;选项&lt;/kbd&gt;”，左侧找到“&lt;kbd&gt;Nuget包管理器&lt;/kbd&gt;”-“&lt;kbd&gt;程序包源&lt;/kbd&gt;”，确认您的列表中包含有&lt;strong&gt;V3版的API&lt;/strong&gt;（&lt;code&gt;&lt;a href=&quot;https://api.nuget.org/v3/index.json&quot;&gt;https://api.nuget.org/v3/index.json&lt;/a&gt;&lt;/code&gt;）。 腾讯云的加速服务仅支持&lt;strong&gt;V3版包源&lt;/strong&gt;，如果没有这个记录，那么您可能无法使用加速服务，请升级您的&lt;strong&gt;Nuget包管理器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201907/510-20190728221708554-505151035.png&quot;&gt;&lt;img title=&quot;5624069de6df7825bc826bdfd347e43&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201907/510-20190728221714540-661941218.png&quot; alt=&quot;5624069de6df7825bc826bdfd347e43&quot; width=&quot;710&quot; height=&quot;418&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;点击添加按钮，然后在下方输入信息：&lt;/p&gt;
&lt;p&gt;输入后，点击&lt;strong&gt;更新&lt;/strong&gt;按钮更新，最后确认并关闭配置。&lt;/p&gt;
&lt;p&gt;上面设置后，Nuget的配置文件里就加入了相关配置，文件位置在：C:\Users\geffzhang\AppData\Roaming\NuGet\Nuget.config ,其中geffzhang 是我的电脑账号，更换你的账号，下面是我的Nuget 配置样例：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201907/510-20190728221720289-263073968.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201907/510-20190728221730474-520885390.png&quot; alt=&quot;image&quot; width=&quot;719&quot; height=&quot;162&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;上述操作我们都是在windows 10 上的，特别是做.NET Core的开发，很多同学喜欢用Mac，如果是Mac 与 Linux 中的路径是，那么路径是在 ~/.nuget/NuGet/NuGet.Config。&lt;/p&gt;
&lt;p&gt;注：NuGet.Config 在 Windows 中路径是 %appdata%\NuGet\NuGet.Config ，在 Mac 与 Linux 中的路径是 ~/.nuget/NuGet/NuGet.Config ，如果没有 NuGet.Config 文件，可以运行 dotnet restore 命令生成。&lt;/p&gt;
&lt;p&gt;上面的配置是全局的配置， 如果我们的项目使用的是在腾讯云上持续集成可以在项目中引入Nuget.config来完成：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/510/201907/510-20190728221737314-1222927724.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/510/201907/510-20190728221743281-1500571339.png&quot; alt=&quot;image&quot; width=&quot;736&quot; height=&quot;187&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当你使用dotnet restore 时也可以通过 –s 指定使用腾讯云镜像，我们就用这种方法来测试下腾讯云的镜像的速度，我用两个项目做了简单测试，测试结果表明为腾讯云的镜像的速度还是要比官方的要快。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jul 2019 23:40:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>继阿里巴巴开源镜像站（https://opsx.alibaba.com/）、华为云镜像站点（https://mirrors.huaweicloud.com/ ）之后，腾讯也已于近日上线了类似的服务，官</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/11261216.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core Web Api之JWT VS Session VS Cookie(二) - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/11197497.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/11197497.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本文我们来探讨下JWT VS Session的问题，这个问题本没有过多的去思考，看到评论讨论太激烈，就花了一点时间去研究和总结，顺便说一句，这就是写博客的好处，一篇博客写出有的可能是经验积累，有的可能是学习分享，但都逃不过看到文章的你有更多或更好的想法，往返交流自身能收获更多，何乐而不为呢？希望本文能解惑或者能得到更多的交流。我们可直接抛出问题：使用客户端存储的JWT比服务端维持Session更好吗？ &lt;/p&gt;
&lt;h2&gt;基于JWT和Session认证共同点&lt;/h2&gt;
&lt;p&gt;既然要比较JWT VS Session，那我们就得知道为何需要JWT和Session，它们共同是为了解决什么问题呢？那我们从一个场景说起，网上购物现已是再平常不过的事情了，当我们将某个商品加入购物车后，然后跳转到其他商品页面此时需要之前选择的商品依然在购物车中，此时就需要维持会话，因为HTTP无状态，所以JWT和Session共同点都是为了持久维持会话而存在，为了克服HTTP无状态的情况，JWT和Session分别是如何处理的呢？&lt;/p&gt;

&lt;h2&gt;JWT VS Session认证&lt;/h2&gt;
&lt;p&gt;Session：当用户在应用系统中登录后，此时服务端会创建一个Session（我们也称作为会话），然后SessionId会保存到用户的Cookie中，只要用户是登录状态，对于每个请求，在Cookie中的SessionId都会发送到服务端，然后服务端会将保存在内存中的SessionId和Cookie中的SessionId进行比较来认证用户的身份并响应。&lt;/p&gt;
&lt;p&gt;JWT：当用户在应用系统中登录后，此时服务端会创建一个JWT，并将JWT发送到客户端，客户端存储JWT（一般是在Local Storage中）同时在每个请求头即Authorization中包含JWT，对于每个请求，服务端都会进行验证JWT是否合法，直接在服务端本地进行验证，比如颁发者，受理者等等，以致于无需发出网络请求或与数据库交互，这种方式可能比使用Session更快，从而加快响应性能，降低服务器和数据库服务器负载。&lt;/p&gt;

&lt;p&gt;通过如上对JWT认证和Session认证简短的描述，我们知道二者最大的不同在于Session是存储在服务端，而JWT存储在客户端。服务端存储会话无外乎两种，一种是将会话标识符存储在数据库，一种是存储在内存中维持会话，我想大多数情况下都是基于内存来维持会话，但是这会带来一定的问题，如果系统存在大流量，也就是说若有大量用户访问系统，此时使用基于内存维持的会话则限制了水平扩展，但对基于Token的认证则不存在这样的问题，同时Cookie一般也只适用于单域或子域，如果对于跨域，假如是第三方Cookie，浏览器可能会禁用Cookie，所以也受浏览器限制，但对Token认证来说不是问题，因为其保存在请求头中。&lt;/p&gt;

&lt;p&gt;如果我们将会话转移到客户端，也就是说使用Token认证，此时将解除会话对服务端的依赖，同时也可水平扩展，不受浏览器限制，但是与此同时也会带来一定的问题，一是令牌的传输安全性，对于令牌传输安全性我们可使用HTTPS加密通道来解决，二是与存储在Cookie中的SessionId相比，JWT显然要大很多，因为JWT中还包含用户信息，所以为了解决这个问题，我们尽量确保JWT中只包含必要的信息（大多数情况下只包含sub以及其他重要信息），对于敏感信息我们也应该省略掉从而防止XSS攻击。JWT的核心在于声明，声明在JWT中是JSON数据，也就是说我们可以在JWT中嵌入用户信息，从而减少数据库负载。所以综上所述JWT解决了其他会话存在的问题或缺点：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;更灵活&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;更安全&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;减少数据库往返，从而实现水平可伸缩。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;防篡改客户端声明&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;移动设备上能更好工作&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;适用于阻止Cookie的用户&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;综上关于JWT在有效期内没有强制使其无效的能力而完全否定JWT的好处显然站不住脚，当然不可辩驳的是若是没有如上诸多使用限制，实现其他类型的身份验证完全也是合情合理且合法的，需综合权衡，而非一家之言下死结论。到目前为止，我们一直讨论的是JWT VS Session认证，而不是JWT VS Cookie认证，但是如标题我们将Cookie也纳入了，只是想让学习者别搞混了，因为JWT VS Cookie认证这种说法是错误的，Cookie只是一种存储和传输信息介质，只能说我们可以通过Cookie存储和传输JWT。接下来我们来实现Cookie存储和传输JWT令牌。&lt;/p&gt;

&lt;h2&gt;JWT AS Cookies Identity Claim&lt;/h2&gt;
&lt;p&gt;在Startup中我们可以添加如下Cookie认证中间件，此时我们有必要了解下配置Cookie的一些选项，通过对这些选项的配置来告知Cookie身份认证中间件在浏览器中的表现形式，我们看下几个涉及到安全的选项。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;           services.AddAuthentication(CookieAuthenticationDefaults.AuthenticationScheme)
           .AddCookie(options &lt;/span&gt;=&amp;gt;&lt;span&gt;
           {
               options.LoginPath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Account/Login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
               options.LogoutPath &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Account/Logout&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
               options.Cookie.Expiration &lt;/span&gt;= TimeSpan.FromMinutes(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
               options.Cookie.HttpOnly &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
               options.Cookie.SecurePolicy &lt;/span&gt;=&lt;span&gt; CookieSecurePolicy.None;
               options.Cookie.SameSite &lt;/span&gt;=&lt;span&gt; SameSiteMode.Lax;
           });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;&lt;span&gt;配置HttpOnly标志着Cookie是否仅供服务端使用，而不能通过前端直接访问。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置SecurePolicy将限制Cookie为HTTPS，在生产环境建议配置此参数同时支持HTTPS。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;配置SameSite用来指示浏览器是否可以将Cookie与跨站点请求一同使用，若是对于OAuth身份认证，可设置为Lax，允许外部链接重定向发出比如POST请求而维持会话，若是Cookie认证，设置为Restrict，因为Cookie认证只适用于单站点，若是设置为None，则不会设置Cookie Header值。（注意：SameSite属性在谷歌、火狐浏览器均已实现，对于IE11好像不支持，Safari从版本12.1开始支持该属性）&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在创建.NET Core默认Web应用程序时，在ConfigureServices方法中，通过中间件直接配置了全局Cookie策略，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            services.Configure&amp;lt;CookiePolicyOptions&amp;gt;(options =&amp;gt;&lt;span&gt;
            {
                options.CheckConsentNeeded &lt;/span&gt;= context =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                options.MinimumSameSitePolicy &lt;/span&gt;=&lt;span&gt; SameSiteMode.None;
            });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然默认配置了全局Cookie策略，同时也在Configure方法中使用其策略如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
            app.UseCookiePolicy();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们也可以直接在上述调用使用Cookie策略中间件的方法中来设置对应参数策略，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190718230037802-1660953205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;若是我们在添加Cookie中间件的同时也配置全局Cookie策略，我们会发现对于属性HTTPOnly和SameSite都可配置，此时个人猜测会存在覆盖的情况，如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190718225805956-1194554806.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于需要认证的控制器我们需要添加上[Authroize]特性，对每一个控制器我们都得添加这样一个特性，相信大部分童鞋都是这么干的。其实我们大可反向操作，对于无需认证的我们添加可匿名访问特性即可，而需要认证的控制器我们进行全局配置认证过滤器，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 services.AddMvc(options=&amp;gt; &lt;span&gt;options.Filters.Add(new&lt;/span&gt;&lt;span&gt;&lt;span&gt; AuthorizeFilter())&lt;/span&gt;)
                .SetCompatibilityVersion(CompatibilityVersion.Version_2_2);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;好了到了这里，我们只是粗略的讲解了下关于Cookie中间件参数配置和Cookie全局配置策略的说明，没有太深入去研究里面的细枝末节，等遇到问题再具体分析吧。继续回到话题，Cookie认证相比JWT对API访问来讲安全系数低，所以我们完全可以在Cookie认证中结合JWT来使用。具体我们可尝试怎么搞呢？将其放到身份信息声明中，我想应该是可行的方式，我们来模拟登陆和登出试试，大概代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;53&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AccountController : Controller
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 登录
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Login()
        {            
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claims = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim[]
            {
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(ClaimTypes.Name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Jeffcky&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(JwtRegisteredClaimNames.Email, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2752154844@qq.com&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Claim(JwtRegisteredClaimNames.Sub, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;D21D099B-B49B-4604-A247-71B0518A0B1C&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;),
                &lt;/span&gt;&lt;span&gt;new Claim(&quot;access_token&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;, GenerateAccessToken()&lt;/span&gt;),
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; claimsIdentity = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClaimsIdentity(
                claims, CookieAuthenticationDefaults.AuthenticationScheme);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; authticationProperties = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AuthenticationProperties();

            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; HttpContext.SignInAsync(
              CookieAuthenticationDefaults.AuthenticationScheme,
              &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClaimsPrincipal(claimsIdentity),
              authticationProperties);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; RedirectToAction(nameof(HomeController.Index), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;string&lt;/span&gt;&lt;span&gt; GenerateAccessToken()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; key = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234567890123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityToken(
                issuer: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                audience: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                notBefore: DateTime.Now,
                expires: DateTime.Now.AddHours(&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;),
                signingCredentials: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; SigningCredentials(key, SecurityAlgorithms.HmacSha256)
            );

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler().WriteToken(token);
        }

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 退出
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [Authorize]
        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Logout()
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; RedirectToAction(nameof(HomeController.Index), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述代码很简单，无需我再多讲，和Cookie认证无异，只是我们在声明中添加了access_token来提高安全性，接下来我们自定义一个Action过滤器特性，并将此特性应用于Action方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; AccessTokenActionFilterAttribute : ActionFilterAttribute
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnActionExecuting(ActionExecutingContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; principal = context.HttpContext.User &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ClaimsPrincipal;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; accessTokenClaim = principal?&lt;span&gt;.Claims
              .FirstOrDefault(c &lt;/span&gt;=&amp;gt; c.Type == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (accessTokenClaim &lt;span&gt;is&lt;/span&gt; &lt;span&gt;null&lt;/span&gt; || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(accessTokenClaim.Value))
            {
                context.HttpContext.Response.Redirect(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/account/login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, permanent: &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sharedKey = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.UTF8.GetBytes(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1234567890123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; validationParameters = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenValidationParameters
            {
                ValidateAudience &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                ValidIssuer &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                ValidAudiences &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:5001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; },
                IssuerSigningKeys &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt;[] { sharedKey }
            };

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; accessToken =&lt;span&gt; accessTokenClaim.Value;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; handler = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; user = (ClaimsPrincipal)&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                user &lt;/span&gt;= handler.ValidateToken(accessToken, validationParameters, &lt;span&gt;out&lt;/span&gt;&lt;span&gt; SecurityToken validatedToken);
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (SecurityTokenValidationException exception)
            {
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Exception($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Token failed validation: {exception.Message}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            }

            &lt;/span&gt;&lt;span&gt;base&lt;/span&gt;&lt;span&gt;.OnActionExecuting(context);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;JWT Combine Cookie Authentication&lt;/h2&gt;
&lt;p&gt;如上是采用将JWT放到声明的做法，我想这么做也未尝不可，至少我没找到这么做有什么不妥当的地方。我们也可以将Cookie认证和JWT认证进行混合使用，只不过是在上一节的基础上添加了Cookie中间件罢了，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190720003601799-98957129.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过如上配置后我们就可以将Cookie和JWT认证来组合使用了，比如我们在用户登录后，如下图点击登录后显示当前登录用户名，然后点击退出，在退出Action方法上我们添加组合特性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190720010042442-76758685.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 退出
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;[Authorize(AuthenticationSchemes = &quot;Bearer,Cookies&quot;&lt;/span&gt;&lt;span&gt;&lt;span&gt;)]&lt;/span&gt;
        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Logout()
        {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; HttpContext.SignOutAsync(CookieAuthenticationDefaults.AuthenticationScheme);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; RedirectToAction(nameof(HomeController.Index), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190720010227189-1345687892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上一节中，我们通过获取AccessToken，从而访问端口号为5001的客户端来获取当前时间，那现在我们针对获取当前时间的方法添加上需要Cookie认证，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;        [Authorize(CookieAuthenticationDefaults.AuthenticationScheme)]&lt;/span&gt;
        [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetCurrentTime()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; sub = User.FindFirst(d =&amp;gt; d.Type == JwtRegisteredClaimNames.Sub)?&lt;span&gt;.Value;

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyy-MM-dd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190720013527158-1023515278.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;Cookie认证撤销&lt;/h2&gt;
&lt;p&gt;在.NET Core 2.1版本通过Cookie进行认证中，当用户与应用程序进行交互修改了信息，需要在cookie的整个生命周期，也就说在注销或cookie过期之前看不到信息的更改时，我们可通过cookie的身份认证事件【撤销身份】来实现这样的需求，下面我们来看看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RevokeCookieAuthenticationEvents : CookieAuthenticationEvents
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IDistributedCache _cache;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RevokeCookieAuthenticationEvents(
          IDistributedCache cache)
        {
            _cache &lt;/span&gt;=&lt;span&gt; cache;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; Task ValidatePrincipal(
          CookieValidatePrincipalContext context)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userId = context.Principal?&lt;span&gt;.Claims
            .First(c &lt;/span&gt;=&amp;gt; c.Type == JwtRegisteredClaimNames.Sub)?&lt;span&gt;.Value;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;.IsNullOrEmpty(_cache.GetString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;revoke-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; userId)))
            {
               &lt;span&gt; context.RejectPrincipal();&lt;/span&gt;

                _cache.Remove(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;revoke-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; userId);
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Task.CompletedTask;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们通过重写CookieAuthenticationEvents事件中的ValidatePrincipal，然后判断写在内存中关于用户表示是否存在，若存在则调用 &lt;span class=&quot;cnblogs_code&quot;&gt;context.RejectPrincipal()&lt;/span&gt; 撤销用户身份。然后我们在添加Cookie中间件里配置该事件类型以及对其进行注册：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190728213613293-1608138375.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 services.AddScoped&amp;lt;RevokeCookieAuthenticationEvents&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们写一个在页面上点击【修改信息】的方法，并在内存中设置撤销指定用户，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [HttpPost]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult ModifyInformation()
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; principal = HttpContext?.User &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ClaimsPrincipal;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; userId = principal?&lt;span&gt;.Claims
              .First(c &lt;/span&gt;=&amp;gt; c.Type == JwtRegisteredClaimNames.Sub)?&lt;span&gt;.Value;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(userId))
            {
                _cache.SetString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;revoke-&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; userId, userId);
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; RedirectToAction(nameof(HomeController.Index), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Home&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201907/589642-20190728213653259-1987357074.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从如上动图中我们可以看到，当点击修改信息后，然后将撤销的用户标识写入到内存中，然后跳转到Index页面，此时调用我们写的撤销事件，最终重定向到登录页，且此时用户cookie仍未过期，所以我们能够在左上角看到用户名，不清楚这种场景在什么情况下才会用到。&lt;/p&gt;
&lt;h2&gt;重定向至登录携带或移除参数&lt;/h2&gt;
&lt;p&gt;当我们在某个页面进行操作时，若此时Token或Cookie过期了，此时则会自动引导用户且将用户当前访问的URL携带并重定向跳转到登录页进行登录，比如关于博客园如下跳转URL：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;account.cnblogs.com/signin?returnUrl=http%3a%2f%2fi.cnblogs.com%2f&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是如果我们有这样的业务场景：用于跳转至登录页时，在URL上需要携带额外的参数，我们需要获取此业务参数才能进行对应业务处理，那么此时我们应该如何做呢？我们依然是重写CookieAuthenticationEvents事件中的RedrectToLogin方法，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedirectToLoginCookieAuthenticationEvents : CookieAuthenticationEvents
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IUrlHelperFactory _helper;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; IActionContextAccessor _accessor;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RedirectToLoginCookieAuthenticationEvents(IUrlHelperFactory helper,
            IActionContextAccessor accessor)
        {
            _helper &lt;/span&gt;=&lt;span&gt; helper;
            _accessor &lt;/span&gt;=&lt;span&gt; accessor;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; Task RedirectToLogin(RedirectContext&amp;lt;CookieAuthenticationOptions&amp;gt;&lt;span&gt; context)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取路由数据&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; routeData =&lt;span&gt; context.Request.HttpContext.GetRouteData();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取路由数据中的路由值&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; routeValues =&lt;span&gt; routeData.Values;

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; uri = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Uri(context.RedirectUri);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解析跳转URL查询参数&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; returnUrl =&lt;span&gt; HttpUtility.ParseQueryString(uri.Query)[context.Options.ReturnUrlParameter];

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;add extra parameters for redirect to login&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; parameters = $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;id={Guid.NewGuid().ToString()}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加额外参数到路由值中&lt;/span&gt;
            routeValues.Add(context.Options.ReturnUrlParameter, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{returnUrl}{parameters}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; urlHelper =&lt;span&gt; _helper.GetUrlHelper(_accessor.ActionContext);

            context.RedirectUri &lt;/span&gt;= UrlHelperExtensions.Action(urlHelper, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Account&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, routeValues);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.RedirectToLogin(context);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要注意的是因为上述我们用到了IActionContextAccessor，所以我们需要将其进行对应如下注册：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
 services.AddSingleton&amp;lt;IActionContextAccessor, ActionContextAccessor&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终我们跳转到登录页将会看到我们添加的额外参数id也将呈现在url上，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;localhost:5001/Account/Login?ReturnUrl=%2FAccount%2FGetCurrentTime%3Fid%3Da309f451-e2ff-4496-bf18-65ba5c3ace9f&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本节我们讲解了Session和JWT的优缺点以及Cookie认证中可能我们需要用到的地方，下一节也是JWT最后一节内容，我们讲讲并探讨如何实现刷新Token，感谢阅读。&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jul 2019 23:35:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 本文我们来探讨下JWT VS Session的问题，这个问题本没有过多的去思考，看到评论讨论太激烈，就花了一点时间去研究和总结，顺便说一句，这就是写博客的好处，一篇博客写出有的可能是经验积累，有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/11197497.html</dc:identifier>
</item>
<item>
<title>重复造轮子系列——基于FastReport设计打印模板实现桌面端WPF套打和商超POS高度自适应小票打印 - sylla</title>
<link>http://www.cnblogs.com/sylla/p/11261524.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sylla/p/11261524.html</guid>
<description>&lt;h2&gt;&lt;span&gt;&lt;strong&gt;一、引言&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;桌面端系统经常需要对接各种硬件设备，比如扫描器、读卡器、打印机等。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里介绍下桌面端系统打印经常使用的场景。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、一种是类似票务方面的系统需要打印固定格式的票据。比如景点门票、车票、电影票。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种基本是根据模板调整位置套打。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、还有一种是交易小票，比如商超POS小票，打印长度会随着内容的大小自动伸缩。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种就不仅仅是固定格式的套打了，还得计算数据行以适应不同的打印长度。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打印方式也有两种类型&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、指令打印，根据不同打印机可能需要对接不同的打印指令。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、驱动打印，不同打印机都有自带安装驱动。通过驱动打印更方便。下面介绍的内容以驱动打印的方式 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打印经常需要调整打印字体位置等等这些，如果有个可视化模板设计下，系统不需要任何改动就可以是最方便的，这样方便客户或者现场实施自己做调整。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想到各种客户端报表工具都有可视化的界面而且可以打印，就找了个FastReport.Net工具来做。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;二、&lt;strong&gt;固定格式的套打&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里以门票为例，讲解怎么使用FastReport.Net工具来设计模板以及打印。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载FastReport.Net工具，引用到这三个dll，FastReport.dll、FastReport.Bars.dll、FastReport.Editor.dll&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;封装一个公共的PrintHelper.cs,提供两个方法，打印和设计。代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; PrintHelper

    {

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 打印

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;printerName&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;打印机&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;frxPath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;模板&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dicParam&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;字典参数&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dsDataSource&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;printNum&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;打印数量&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;bool&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; Print(&lt;span&gt;string&lt;/span&gt; printerName, &lt;span&gt;string&lt;/span&gt; frxPath, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; dicParam, DataSet dsDataSource, &lt;span&gt;int&lt;/span&gt; printNum = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)

        {

            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; msg = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

            FastReport.Report report &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FastReport.Report();

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;

            {

                report.Load(frxPath);

                report.DoublePass &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dicParam != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; dicParam.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                {

                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dicParam)

                    {

                        report.SetParameterValue(item.Key, item.Value);

                    }

                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dsDataSource != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; dsDataSource.Tables.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                {

                    report.RegisterData(dsDataSource);

                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DataSourceBase dataSourceBase &lt;span&gt;in&lt;/span&gt;&lt;span&gt; report.Dictionary.DataSources)

                    {

                        dataSourceBase.Enabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    }

                }

 

                report.PrintSettings.ShowDialog &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                report.PrintSettings.Printer &lt;/span&gt;=&lt;span&gt; printerName;

                report.PrintSettings.PrintMode &lt;/span&gt;=&lt;span&gt; PrintMode.Split;

                EnvironmentSettings envSet &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EnvironmentSettings();

                envSet.ReportSettings.ShowProgress &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; printNum; i++&lt;span&gt;)

                {

                    report.Print();

                }                

                flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打印成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            }

            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)

            {

                flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                msg &lt;/span&gt;=&lt;span&gt; ex.Message;

            }

            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;

            {

                report.Dispose();

            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;bool&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(flag, msg);

        }

 

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 设计

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;frxPath&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;模板&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dicParam&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;字典参数&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;dsDataSource&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;数据源&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;

        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;bool&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt; Design(&lt;span&gt;string&lt;/span&gt; frxPath, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt; dicParam, DataSet dsDataSource)

        {

            &lt;/span&gt;&lt;span&gt;bool&lt;/span&gt; flag = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; msg = &lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;;

            FastReport.Report report &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FastReport.Report();

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;

            {

                report.Load(frxPath);

                report.DoublePass &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dicParam != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; dicParam.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                {

                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; dicParam)

                    {

                        report.SetParameterValue(item.Key, item.Value);

                    }

                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (dsDataSource != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; dsDataSource.Tables.Count &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;)

                {

                    report.RegisterData(dsDataSource);

                    &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (DataSourceBase dataSourceBase &lt;span&gt;in&lt;/span&gt;&lt;span&gt; report.Dictionary.DataSources)

                    {

                        dataSourceBase.Enabled &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                    }

                }

 

                report.Design();

                flag &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;

                msg &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;设计器打开成功&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            }

            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)

            {

                flag &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

                msg &lt;/span&gt;=&lt;span&gt; ex.Message;

            }

            &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt;

            {

                report.Dispose();

            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;bool&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;(flag, msg);

        }

}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Demo设计一个TicketTemp.frx模板，如下图1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233338329-606020314.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图1&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;面板上面的排列可以任意拖动，字体样式设计，还可以360旋转。如图2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233347091-96659088.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图2&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;普通文本标签在Parameters里面直接可以取字典传入的参数值，双击或者拖拉都可以。如图3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233354695-67800935.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图3&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二维码或者条码类型，FastReport有提供相应的标签，看模板左边竖着的工具条，找到Barcode，拖一个到面板上，如图4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233402000-649807603.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图4&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对应的属性看右下角，如图5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233410696-462977394.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图5&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Barcode属性值下拉，支持这么多类型的条码和二维码编码格式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果是使用自己生成的二维码图片就可以使用左边竖着工具里面的图片标签Picture，使用这个就可以自定义图片打印（当然条码二维码也是特殊图片）。但这个时候传入的数据要使用数据源了，并且在图片标签属性里面找到这个属性值，绑定数据源里面对应的图片字段。如图6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233418378-149283240.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看下demo里面模板设计按钮代码，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BtnTicketDesign_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)

        {

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(txtTicketTemp.Text))

            {

                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;门票模板不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            }                

 

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CreateTicketData();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;data.Item1)

            {

                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;模拟数据生成错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            }

 

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tuple =&lt;span&gt; PrintHelper.Design(txtTicketTemp.Text, data.Item2, data.Item3);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;tuple.Item1)

            {

                MessageBox.Show($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打开设计器失败：{tuple.Item2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            }

        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;        &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看下demo里面模板打印按钮代码，如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; BtnTicketPrint_Click(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, RoutedEventArgs e)

        {

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cbxPrinter.SelectedValue == &lt;span&gt;null&lt;/span&gt; || &lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(cbxPrinter.SelectedValue.ToString()))

            {

                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请选择打印机&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            }

 

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrEmpty(txtTicketTemp.Text))

            {

                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;门票模板不能为空&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            }

 

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.CreateTicketData();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;data.Item1)

            {

                MessageBox.Show(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;模拟数据生成错误&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            }

 

 

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tuple =&lt;span&gt; PrintHelper.Print(cbxPrinter.SelectedValue.ToString(), txtTicketTemp.Text, data.Item2, data.Item3);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;tuple.Item1)

            {

                MessageBox.Show($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;打印失败：{tuple.Item2}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            }

        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;打印和设计共同的组装模拟数据的方法代码如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 组装门票打印模拟数据

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;

        &lt;span&gt;private&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;bool&lt;/span&gt;, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;, DataSet&amp;gt;&lt;span&gt; CreateTicketData()

        {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意事项

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文本内容放入字段中，传入就可以

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;图片内容有两种方案

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1：使用模板的Barcode标签，这个支持标准qr码，条码等等多种类型，字典或者数据源传入文本值，自动会显示qr码条码图片

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2：使用模板的Picture标签，使用这个就是要程序生成好图片，再把图片显示，这里就不仅仅限制于二维码条码了，各种想显示的图片都可以，但需要把图片流放到数据源中传入&lt;/span&gt;
&lt;span&gt;
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; dic = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();

            dic.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ticketModelName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;XXX景点门票&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            dic.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ticketModelKind&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;成人票&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            dic.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ticketModelPrice&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;￥100&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;字典中传入二维码的文本，fastreport提供了生成qr码以及各种条码&lt;/span&gt;
&lt;span&gt;
            dic.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;barcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ET2018000000000000001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

 

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果需要，组装dataset数据源，这里以传入二维码图片为例&lt;/span&gt;
&lt;span&gt;
            DataTable dtImage &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DataTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dtBarcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            dtImage.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;barcode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(Byte[]));

 

            DataSet dsFrx &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataSet();

            dsFrx.Tables.Add(dtImage);

 

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1、把二维码码文本生成图片  这个有很多第三方库可以支持  我这里用 ThoughtWorks.QRCode&lt;/span&gt;
&lt;span&gt;
            QRCodeEncoder qrCodeEncoder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QRCodeEncoder();

            qrCodeEncoder.QRCodeEncodeMode &lt;/span&gt;=&lt;span&gt; QRCodeEncoder.ENCODE_MODE.BYTE;

            qrCodeEncoder.QRCodeScale &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;

            qrCodeEncoder.QRCodeVersion &lt;/span&gt;= &lt;span&gt;4&lt;/span&gt;&lt;span&gt;;

            qrCodeEncoder.QRCodeErrorCorrect &lt;/span&gt;=&lt;span&gt; QRCodeEncoder.ERROR_CORRECTION.M;

 

            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (Image image = qrCodeEncoder.Encode(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ET2018000000000000001&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

            {

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2、生成的图片本地可以做个备份记录，也可以不需要直接将image转byte[]传人数据源就可以&lt;/span&gt;

                &lt;span&gt;if&lt;/span&gt; (!Directory.Exists(Path.Combine(Directory.GetCurrentDirectory(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BarCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)))

                {

                    Directory.CreateDirectory(Path.Combine(System.IO.Directory.GetCurrentDirectory(), &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BarCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));

                }

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; filename = DateTime.Now.ToString(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;yyyymmddhhmmssfff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).ToString() + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; filepath = Path.Combine(System.IO.Directory.GetCurrentDirectory(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;BarCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, filename);

                &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (FileStream fs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileStream(filepath, FileMode.OpenOrCreate, FileAccess.Write))

                {

                    image.Save(fs, ImageFormat.Jpeg);

                }

 

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3、将image转byte[]传人数据源  注意图片传入的是字节数组byte[]  不是文本也不是图片路径！！！&lt;/span&gt;
&lt;span&gt;
                dtImage.Rows.Add(ImageToBytes(image, ImageFormat.Jpeg));

            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;bool&lt;/span&gt;, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;, DataSet&amp;gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, dic, dsFrx);

        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行，在设计器里面也可以预览，看下最终打印效果，如图7&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233431402-220055973.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图7&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;三、&lt;strong&gt;动态格式的打印&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;这里以商超POS交易小票为例，讲解怎么使用FastReport.Net工具来设计模板以及打印。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这种小票大部分和上面说的一样，唯一不同的是有数量不固定的数据集动态数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Demo设计一个BillTemp.frx模板，如下图8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233453392-746540101.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图8&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;固定大小的数据和上面的类似，放到报表头尾，或者页面头尾都可以。动态数据需要放到Data里面，点击Configure Bands，如图9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233500423-1413206430.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里可以添加删除Band。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Data需要绑定对应的数据源，传进来是DataSet，也可以使用多个Data这样就可以有多个DataTable，实例这里就使用了一个。看设计器右上角数据源，如图10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233511508-549193283.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图10&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;当前的data需要指定哪个数据源，如图11&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233519976-655849787.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图11&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;动态数据每个值也是和普通的文本类似，但不是取Parameters里面，要取DataSources里面对应的数据源字段，如图12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233527141-1121266165.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图12&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;小票模板里面还有一点是特殊的，由于数据集的动态的防止打印的时候分页，需要动态的控制面板的长度，切换到code，如图13&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233538641-573430173.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图13&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在code里面增加代码计算数据布局之后的总高度，代码如下&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ReportScript

  {                      

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; pageHeader1Height;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; reportTitle1Height;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; dataHeaderHeight;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; data1Height;  

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; reportSummaryHeight;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;float&lt;/span&gt;&lt;span&gt; pageFooter1Height;

    

 

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Page1_StartPage(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)

    {

      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(Engine.FinalPass)

      {                                             

        Page1.PaperHeight &lt;/span&gt;=&lt;span&gt; (reportTitle1Height

          &lt;/span&gt;+&lt;span&gt; pageHeader1Height

          &lt;/span&gt;+&lt;span&gt;dataHeaderHeight

          &lt;/span&gt;+&lt;span&gt;data1Height

          &lt;/span&gt;+&lt;span&gt;reportSummaryHeight

          &lt;/span&gt;+pageFooter1Height)/&lt;span&gt;Units.Millimeters

          &lt;/span&gt;+&lt;span&gt;Page1.TopMargin

          &lt;/span&gt;+&lt;span&gt;Page1.BottomMargin;

      }

    }

 

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PageHeader1_AfterLayout(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)

    {

      pageHeader1Height&lt;/span&gt;=&lt;span&gt;PageHeader1.Height;

    }

 

 

 

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ReportTitle1_AfterLayout(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)

    {

      reportTitle1Height&lt;/span&gt;=&lt;span&gt;ReportTitle1.Height;

    }

 

 

 

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; PageFooter1_AfterLayout(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)

    {

      pageFooter1Height&lt;/span&gt;=&lt;span&gt;PageFooter1.Height;  

    }

 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Data 的高度 用+=&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Data1_AfterLayout(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)

    {

       data1Height&lt;/span&gt;+=&lt;span&gt;Data1.Height;  

    }

 

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;DataHeader 的高度 用+=&lt;/span&gt;

    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; DataHeader1_AfterLayout(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)

    {

        dataHeaderHeight&lt;/span&gt;+=&lt;span&gt;DataHeader1.Height;

    }

    

 

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ReportSummary1_AfterLayout(&lt;span&gt;object&lt;/span&gt;&lt;span&gt; sender, EventArgs e)

    {

      reportSummaryHeight&lt;/span&gt;=&lt;span&gt;ReportSummary1.Height;

    }     

  }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这段代码就是所有的band属性的AfterLayout事件，如图14&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233557350-399001930.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图14&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;算出当前band高度最后总和最为页面的高度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Demo里面小票的设计和打印代码和上面门票的类似，这里看下模拟数据组装的方法代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 组装小票打印模拟数据

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;

        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;

        &lt;span&gt;private&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;bool&lt;/span&gt;, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;, DataSet&amp;gt;&lt;span&gt; CreateBillData()

        {

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意事项

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;小票打印和门票一样，主要的区别是小票动态数据会变化，小票的长度也会动态改变

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里主要演示下  动态数据源  为了动态拉伸，除了传入数据源，在模板上面code部分需要加代码&lt;/span&gt;
&lt;span&gt;
            Dictionary&lt;/span&gt;&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt; dic = &lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;&lt;span&gt;();

            dic.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;billNo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2018111100002222&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            dic.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;optorName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;管理员&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

 

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;组装dataset数据源&lt;/span&gt;
&lt;span&gt;
            DataTable dtDetail &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; DataTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dtDetail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            dtDetail.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GOODSCODE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            dtDetail.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GOODSNAME&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            dtDetail.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GOODSPRICE&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            dtDetail.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;GOODSCOUNT&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            dtDetail.Columns.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;PAYSUM&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

 

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加10种商品&lt;/span&gt;

            &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;; i &amp;lt;= &lt;span&gt;10&lt;/span&gt;; i++&lt;span&gt;)

            {

                dtDetail.Rows.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;测试商品&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + i, &lt;span&gt;10.00m&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;, &lt;span&gt;50.00m&lt;/span&gt;&lt;span&gt;);

            }

 

 

            DataSet dsFrx &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DataSet();

            dsFrx.Tables.Add(dtDetail);

 

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Tuple&amp;lt;&lt;span&gt;bool&lt;/span&gt;, Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;object&lt;/span&gt;&amp;gt;, DataSet&amp;gt;(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;, dic, dsFrx);

        }&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行，在设计器里面也可以预览，看下最终打印效果，如图15&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/233178/201907/233178-20190728233607934-567785429.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;图15&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;四、总结&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用这个做打印模板还是比较方便的，在套打情况下要频繁调整界面布局，使用这种可视化的界面操作方便。经常客户自己就可以自定义调整。不需要程序做任何修改。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个FastReport.Net的具体使用方法可以查看网上资料，我这里主要是作为打印模板来用。很多细节以及用法就没展开细讲。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为FastReport是商业软件。支持软件版权。针对商业版权问题，FastReport提供了开源版本，在nuget就可以直接引用，作为报表功能有删减，但针对打印功能完全够用了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://files.cnblogs.com/files/sylla/AgileUtility.Printer.zip&quot; target=&quot;_blank&quot;&gt;demo下载&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;感谢阅读，希望这篇文章能给你带来帮助！&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jul 2019 23:29:00 +0000</pubDate>
<dc:creator>sylla</dc:creator>
<og:description>重复造轮子系列——基于FastReport设计打印模板实现桌面端WPF套打和商超POS高度自适应小票打印 一、引言 桌面端系统经常需要对接各种硬件设备，比如扫描器、读卡器、打印机等。 这里介绍下桌面端</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sylla/p/11261524.html</dc:identifier>
</item>
<item>
<title>Python秒算24点，行还是不行？ - 上海小胖</title>
<link>http://www.cnblogs.com/moonhmily/p/11261800.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/moonhmily/p/11261800.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201907/649191-20190729070845313-1676614949.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;周末闲来无事，看到隔壁家的老王在和隔壁家的媳妇玩24点，就进屋看了看。发现老王是真不行啊，那不行，这也不行。&lt;/p&gt;
&lt;p&gt;就连个24点都玩不过他媳妇，给他媳妇气的，啥都不能满足，这不能，那也不能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201907/649191-20190729070853289-1883125024.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我坐下来和他媳妇玩了两把，那都是无出其右，把把赢！&lt;/p&gt;
&lt;p&gt;我要走的时候，他媳妇还挽留我多玩几把，有意思。&lt;/p&gt;
&lt;p&gt;为了能让老王在他媳妇面前抬起头来，我决定帮他一把……就用python写了个算24点的玩意，老王对我感激涕零。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/649191/201907/649191-20190729070900631-1049443654.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们先来约定下老王和他媳妇玩的24点规则：给定4个任意数字（0-9），然后通过&lt;code&gt;+,-,*,/&lt;/code&gt;，将这4个数字计算出24。&lt;/p&gt;
&lt;p&gt;小时候玩的都是这个规则，长大了才有根号，才有各种莫名其妙的高级算法，不好玩了，因为我不会。&lt;/p&gt;
&lt;p&gt;可能有人会觉得很简单，但是真的简单吗？&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;8，3，3，3&lt;/li&gt;
&lt;li&gt;7，3，3，3&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你能一眼看出来答案吗？好像真的可以……&lt;/p&gt;

&lt;p&gt;这样想，将四个数字进行全排列，在他们之间添加运算符号。&lt;/p&gt;
&lt;p&gt;运算符我们需要进行排列组合，因为只有四个数字，所以只需要三个运算符，而且算法符可能会重复，比如三个都是&lt;code&gt;+&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再遍历四个数字的全排列，对每一组数字而言，遍历所有组合的操作符。最后将数字和操作符进行拼接运算，就可以得到最终结果了。&lt;/p&gt;

&lt;p&gt;操作系统：windows10&lt;/p&gt;
&lt;p&gt;python版本：python 3.7&lt;/p&gt;
&lt;p&gt;代码编辑器：pycharm 2018.2&lt;/p&gt;
&lt;p&gt;使用模块：math，itertools, collections.abc&lt;/p&gt;

&lt;p&gt;1、首先我们对所有数字进行去全排列，这里我们使用 itertools.permutations 来帮助我们完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;iertools.permutations 用法演示&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from itertools import permutations

data_list = permutations([1,2,3,4],2)
for data in data_list:
print(data)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;(1, 2)
(1, 3)
(1, 4)
(2, 1)
(2, 3)
(2, 4)
(3, 1)
(3, 2)
(3, 4)
(4, 1)
(4, 2)
(4, 3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;permutations 第一个参数是接收一个课迭代的对象，第二个参数指定每次排列时从课迭代对象中选着几个字符进行排列。也可以不传入第二个参数，那么默认就是可迭代对象的长度。并且返回一个生成器。&lt;/p&gt;
&lt;p&gt;所以我们需要对所有数字进行全排列，就可以像下面这样写：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def get_all_data_sequence(data_iter):
    return permutations(data_iter)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、然后我们需要拿到所有的操作运算符的所有组合方式。这里我们就会使用 &lt;code&gt;itertools.product&lt;/code&gt; 函数了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;itertools.product 用法演示&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from itertools import product

sequence1 = product('ABCD','xy')
sequence2 = product([0,1],repeat=3)

for sequence in sequence1:
    print(sequence)

print('-'*30)

for sequence in sequence2:
    print(sequence)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;('A','x')
('A','y')
('B','x')
('B','y')
('C','x')
('C','y')
('D','x')
('D','y')
------------------------------
(0, 0, 0)
(0, 0, 1)
(0, 1, 0)
(0, 1, 1)
(1, 0, 0)
(1, 0, 1)
(1, 1, 0)
(1, 1, 1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;itertools.product&lt;/code&gt;，返回传入所有序列中笛卡尔积的元祖，repeat参数表示传入序列的重复次数。返回的是一个生成器。&lt;/p&gt;
&lt;p&gt;那么获取所有的操作运算符就可以通过这个函数来获取了&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def get_all_operations_sequence():
    operations = ['+','-','*','/']
    return product(operations,repeat=3)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、现在我们已经拿到了所有可能组合的操作符和数字了，接下来就需要对他们进行拼接了。然后执行运算。&lt;/p&gt;
&lt;p&gt;这一步操作我们会用到 &lt;code&gt;itertools.zip_longest()&lt;/code&gt; 和 &lt;code&gt;itertools.chain.form_iterable()&lt;/code&gt; 函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;itertools.zip_longest() 用法演示&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;data = zip_longest([1,2,3,4],['*','-','+'],fillvalue='')
for value in data:
    print(value)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;(1, '*')
(2, '-')
(3, '+')
(4, '')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;zip_longest()&lt;/code&gt; 其实和 python 内置的 zip() 函数用法差不多，只是 zip_longest 是以最长的一个序列为基准，缺失值就使用 &lt;code&gt;fillvalue&lt;/code&gt; 参数的值进行填充&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;itertools.chain.form_iterable() 用法演示&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;data = zip_longest([1,2,3,4],['*','-','+'],fillvalue='')
data_chain = chain.from_iterable(data)
for value in data_chain:    
    print(value)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果显示&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;1
*
2
-
3
+
4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的data是什么样的大家知道了吧，然后我们将data传入 chain.form_iterable() 中，它就能将里面的值依次拿出来。&lt;/p&gt;
&lt;p&gt;了解了这两个函数之后，那么我们就可以开始拼接数字和操作运算符了。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def calculate(self):
    '''
    计算值，返回对应的表达式和值
    :return:    
    '''    
    for data_sequence in get_all_data_sequence():       
        operation_sequences = get_all_operation_sequence()       
        for operation_sequence in operation_sequences:            
            value = zip_longest(data_sequence, operation_sequence, 
        fillvalue='')            
            value_chain = chain.from_iterable(value)           
            calculate_str = ''           
            # 对得到的字符进行拼接成为表达式 calculate_str
            for _ in value_chain:                
                calculate_str += _          
            try：
                result = eval(calculate_str
            # 处理被除数可能为零的情况，然后就直接跳过这次循环
            except ZeroDivisionError:
                continue
            if math.isclose(result, 24):                    
               return calculate_str,result
    return None,None&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;1、eval() 函数，接受一个字符串，能让这个字符串当成 python 代码运行，返回运行的结果。&lt;/p&gt;
&lt;p&gt;2、math.isclose()：为什么这里需要使用 math.isclose() ，而不是直接使用&lt;code&gt;==&lt;/code&gt;运算符呢？这是因为最后算出来的表达式可能有精度问题，例如23.9...或者24.0...等数字，所以我们就需要使用math.isclose()函数来帮助我们判断两个数字是否相等了，这个函数就有一个精度范围。这样出现上面情况的时候，我们也能匹配得到条件了。&lt;/p&gt;
&lt;p&gt;我们运行代码，然后测试代码是否能达到我们的需求。&lt;/p&gt;
&lt;p&gt;首先我们测试1,2,3,4四个数字，&lt;/p&gt;
&lt;p&gt;程序出来了结果 &lt;code&gt;1*2*3*4&lt;/code&gt; 24&lt;/p&gt;
&lt;p&gt;看来好像我们写的代码是正确的&lt;/p&gt;

&lt;p&gt;我们再来测试一组数据8,8,3,3.&lt;/p&gt;
&lt;p&gt;嗯？我们并没有得到结果？这四个数字不能运算出24吗？&lt;/p&gt;
&lt;p&gt;&lt;code&gt;8 / ( 3 - 8 / 3 )&lt;/code&gt; 这样组合可以吧，为什么没有算出来这种结果呢？&lt;/p&gt;

&lt;p&gt;这是因为我们没有考虑括号的原因。括号是可以改变运算优先级的。所以我们得把括号考虑进去。&lt;/p&gt;
&lt;p&gt;那么想一下括号最多可以有几个呢？怎样给我们的表达式添加括号呢？&lt;/p&gt;

&lt;p&gt;在4个数字的运算中，括号最多只能有三个。&lt;/p&gt;
&lt;p&gt;并且，在这里，我们使用一种简单的方法添加括号，我们把所有可能出现括号的情况全部罗列出来，然后在将得到的运算表达式拼接进去。&lt;/p&gt;
&lt;p&gt;可能大家会觉得罗列出所有括号出现的情况不现实，因为有很多情况&lt;/p&gt;
&lt;p&gt;其实不然，当我们去罗列的时候，你就会发现，只有11种情况。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;FORM_STRS = [
    # 数字 运算符 数字 运算符 数字 运算符 数字
    # 一个括号 的情况
    '(%s %s %s) %s %s %s %s',
    '(%s %s %s %s %s) %s %s',
    '(%s %s %s %s %s %s %s)',
    '%s %s (%s %s %s) %s %s',
    '%s %s (%s %s %s %s %s)',
    '%s %s %s %s (%s %s %s)',
    # 两个括号 的情况
    '(%s %s %s) %s (%s %s %s)',
    '( (%s %s %s) %s %s) %s %s',
    '( %s %s (%s %s %s)) %s %s',
    '%s %s ((%s %s %s) %s %s)',
    '%s %s (%s %s (%s %s %s))',
    # 三个括号是重复的,就不用罗列出来了
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们对得到的表达式在进行遍历拼接，然后我们再运算表达式。&lt;/p&gt;
&lt;p&gt;这样我们就能得出正确的结果了&lt;/p&gt;
&lt;p&gt;代码写完了，终于可以开始和媳妇，哦不，老王家的媳妇玩起来了&lt;/p&gt;
&lt;p&gt;代码已全部上传至Github：&lt;a href=&quot;https://github.com/MiracleYoung/You-are-Pythonista/tree/master/PythonExercise/App/python_24/xujin&quot; class=&quot;uri&quot;&gt;https://github.com/MiracleYoung/You-are-Pythonista/tree/master/PythonExercise/App/python_24/xujin&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;关注公众号「Python专栏」，更多好玩有趣的Python等着你&lt;/p&gt;
</description>
<pubDate>Sun, 28 Jul 2019 23:10:00 +0000</pubDate>
<dc:creator>上海小胖</dc:creator>
<og:description>周末闲来无事，看到隔壁家的老王在和隔壁家的媳妇玩24点，就进屋看了看。发现老王是真不行啊，那不行，这也不行。 就连个24点都玩不过他媳妇，给他媳妇气的，啥都不能满足，这不能，那也不能。 我</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/moonhmily/p/11261800.html</dc:identifier>
</item>
</channel>
</rss>