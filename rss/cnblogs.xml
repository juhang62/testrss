<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于spark实现并行化Apriori算法 - 编程匠心者</title>
<link>http://www.cnblogs.com/brooksj/p/spark-Apriori.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/brooksj/p/spark-Apriori.html</guid>
<description>&lt;p&gt;详细代码我已上传到github：&lt;a href=&quot;https://github.com/tracy-talent/curriculum/tree/master/MapReduce/Apriori&quot;&gt;click me&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;一-实验要求&quot;&gt;一、 实验要求&lt;/h2&gt;
&lt;p&gt;        在 Spark2.3 平台上实现 Apriori 频繁项集挖掘的并行化算法。要求程序利用 Spark 进&lt;br/&gt;行并行计算。&lt;/p&gt;
&lt;h2 id=&quot;二算法设计&quot;&gt;二、算法设计&lt;/h2&gt;
&lt;h3 id=&quot;设计思路&quot;&gt;2.1 设计思路&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;变量定义
&lt;ul&gt;&lt;li&gt;D为数据集，设Lk是k项频繁项集，Ck是k项候选集，每一行数据定义为一笔交易（transaction），交易中的每个商品为项item。&lt;/li&gt;
&lt;li&gt;支持度: support, 即该项集在数据集D中出现的次数&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;算法流程
&lt;ul&gt;&lt;li&gt;单机Apriori算法的主要步骤如下：
&lt;ol&gt;&lt;li&gt;获取输入数据，产生频繁1项集，以及和I作为候选集，扫描数据集D，获取候选集C1的支持度，并找出最小支持度min_sup的元素作为频繁1项集L1.&lt;/li&gt;
&lt;li&gt;扫描数据集D，获取候选集Ck的支持度，并找出其中满足最小支持度的元素作为频繁k项集Lk&lt;/li&gt;
&lt;li&gt;通过频繁k项集Lk产生k+1候选集Ck+1&lt;/li&gt;
&lt;li&gt;通过迭代步骤2和3,直到找不到k+1项集结束&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;并行化设计的思路主要是考虑将对于支持度计数的过程使用wordcount来进行统计。&lt;/p&gt;
&lt;h3 id=&quot;并行化算法设计&quot;&gt;2.2 并行化算法设计&lt;/h3&gt;
&lt;p&gt;        Apriori算法产生频繁项集有两个特点：第一，它是逐层的，即从频繁1-项集到频繁k-项集；第二，它使用产生-测试的策略来发现频繁项，每次迭代后都由前一次产生的频繁项来产生新的候选项，然后对新产生的候选项集进行支持度计数得到新的频繁项集。根据算法的特点，我们将算法分为两个阶段：&lt;br/&gt;如下图1.1算法的并行化框架图，主节点每次迭代时需要将候选项集以广播的形式分发到每个从节点，每个从节点收到之后进行一些列的操作得到新的频繁项集，如此反复直至求得最大频繁项集。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-%E5%B9%B6%E8%A1%8C%E5%8C%96%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E5%9B%BE.png&quot;/&gt;&lt;/div&gt;
&lt;center&gt;图1.1 并行化框架图&lt;/center&gt;
&lt;ul readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;阶段1：从HDFS上获取原始的数据集SparkRDD，加载到分布式内存中。扫描所有的RDD事务，进行支持度计数，产生频繁1-项集；如图1.2所示为Ap算法并行化第一阶段的Lineage图。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-%E5%B9%B6%E8%A1%8C%E5%8C%96%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5Lineage%E5%9B%BE.png&quot;/&gt;&lt;/div&gt;
&lt;center&gt;图1.2 Apriori算法并行化第一阶段的Lineage图&lt;/center&gt;
&lt;p&gt;原始事务集由flatMap函数去读取事务，并将所有的事务转化为Spark RDD并cache到分布式内存中。接下来，在每一个事务中执行flatMap函数来获取所有的Items项集，之后执行map函数，发射&amp;lt;Item, 1&amp;gt;的key/value形式，接下来执行reduceByKey函数统计每一个候选1-项集的支持度，最后并利用事先设好的支持度阈值进行剪枝，所有超过支持度阈值的项集将会生成频繁1-项集，下面给出了第一阶段的算法伪代码&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-%E5%B9%B6%E8%A1%8C%E5%8C%96%E7%AE%97%E6%B3%95%E4%BC%AA%E4%BB%A3%E7%A0%81.png&quot;/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;阶段2：在这个阶段，不断迭代使用频繁k-项集去产生频繁k+1项集&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-%E5%B9%B6%E8%A1%8C%E5%8C%96%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5Lineage%E5%9B%BE.png&quot;/&gt;&lt;/div&gt;
&lt;center&gt;图1.3 Apriori算法并行化第二阶段的Lineage图&lt;/center&gt;
&lt;p&gt;如图1.3所示，首先读取频繁k-项集并且以&amp;lt;itemSet, Count&amp;gt;的形式将其存储为Spark RDD。接下来，从频繁k-项集得到候选(k+1)-项集。为加速从候选项集中查找(k+1)-项集的过程，将候选(k+1)-项集存放在哈希表中，并将其broadcast到每个worker节点。接下来，通过flatMap函数获取每个候选项集在原始事务集中的支持度，进一步对每个候选项使用map函数得到&amp;lt;ItemSet, 1&amp;gt;，之后通过reduceBykey函数搜集每个事务的最终的支持度计数，最后利用实现设定好的支持度阈值剪枝，支持度大于等于最小阈值的频繁项集将会以key/value的形式输出，作为频繁(k+1)-项集，下面给出了算法第二阶段的伪代码。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-%E7%AE%97%E6%B3%95%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E4%BC%AA%E4%BB%A3%E7%A0%81.png&quot;/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;程序设计与性能分析&quot;&gt;2.3 程序设计与性能分析&lt;/h3&gt;
&lt;ul readability=&quot;24.5&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;读取数据集，按空格划分每行内容，并用HashSet存储，方便后期求子集以及一些集合操作&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// 将输入数据分区，由于后面要频繁使用。因此缓存起来
val transations = sc.textFile(input, num)
        .map(x =&amp;gt; {
            val content = x.split(&quot;\\s+&quot;)
            val tmp = new HashSet[String]
            for (i &amp;lt;- 0 until content.length) {
                tmp.add(content(i))
            }
            tmp
        }).cache()&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;根据支持度和数据总量计算频繁项阈值，便于后期统计集合频度后直接对比&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// 计算频繁项阈值
val numRecords = transations.count().toDouble
val freqThre = numRecords * support
println(&quot;frequency threshold：&quot; + freqThre)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;计算频繁1项集用于后续的循环迭代计算&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// 计算频繁1项集
val oneFreqSet = transations
        .flatMap(_.seq)
        .map(x =&amp;gt; (x, 1))
        .reduceByKey(_ + _)
        .filter(x =&amp;gt; x._2 &amp;gt;= freqThre)
        .map(x =&amp;gt; (HashSet(x._1), x._2 / numRecords))&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;15&quot;&gt;
&lt;p&gt;利用上一轮迭代计算生成的频繁k项集来构造候选k+1项集，然后通过比频繁项阈值比对筛选出频繁k+1项集。这里有一点要注意的，由于从文件读入的源数据transaction被划分在各个partition上，而候选集candidates要与transaction中每条记录比对来统计频度，因此需要spark调用broadcast将候选集广播到每个partition上&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// 生成频繁项的候选集
val candidates = generateCandidates(preFreSets, round)
// 将候选项集广播到各个分区
val broadcastCandidates = sc.broadcast(candidates)

//复杂度：len(transactions) * len(candidates) * round * transaction项的平均长度
//这里的len(transaction)是指各个partition上transaction的平均长度
val curFreqSet = transations
    .flatMap(x =&amp;gt; verifyCandidates(x, broadcastCandidates.value))
    .reduceByKey(_ + _)
    .filter(x =&amp;gt; x._2 &amp;gt;= freqThre)

// 写入频繁round项集结果到hdfs
curFreqSet.map(a =&amp;gt; {
    val out = a._1.mkString(&quot;,&quot;) + &quot;:&quot; + (a._2 / numRecords).toString
    out
}).saveAsTextFile(output + &quot;/&quot; + infileName + &quot;freqset-&quot; + round)

// 生成频繁round-Itemsets，用于下一轮迭代生成候选集
preFreSets = curFreqSet.collect().map(x =&amp;gt; x._1)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第round轮迭代，由候选项集生成频繁项集的复杂度：len(transactions) * len(candidates) * round * transaction项的平均长度，这里的len(transaction)是指各个partition上transaction的平均长度，尽管我们通过提高并发度的方式将复杂度的稍微将了一些，可是算法的整体复杂度还是很高，特别是当源数据集很大时，这样查表式地验证候选集很费时，有考虑将项集索引，但是如果全部项集都存那这个存储开销太大了，目前没有很好的优化思路，时间有限也没有进一步深入怎么优化这一步了。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;对于候选集生成方法generateCandidates的具体实现，我们首先拆分上一轮频繁项集preFreSets中的每个项再合并成一个元素集，相当于一个词汇表，然后遍历preFreSets中每个项，如果该项中不包含元素表中的某个元素，则将该元素与该项合并成一个候选项。具体实现如下：&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;def generateCandidates(preFreSets : Array[HashSet[String]], curRound: Int): Array[HashSet[String]] = {
    // 复杂度：len(elements) * len(preFrestats)^2 * curRound^2
    val elements = preFreSets.reduce((a,b) =&amp;gt; a.union(b))
    val canSets = preFreSets.flatMap( t =&amp;gt; for (ele &amp;lt;- elements if(!t.contains(ele))) yield t.+(ele) ).distinct
    canSets.filter( set =&amp;gt; {
        val iter = set.subsets(curRound - 1)
        var flag = true
        while (iter.hasNext &amp;amp;&amp;amp; flag){
            flag = preFreSets.contains(iter.next())
        }
        flag
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这个过程复杂度太高：len(elements) * len(preFrestats)^2 * curRound^2，当数据源中元素过多，迭代更深以后，这个复杂度将变得让人难以接受，花了大量的时间再前一轮的候选项集中验证候选项，需要想一个办法来避免顺序式的查表，但限于时间有限，这个地方没有深入展开研究怎么优化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;关联规则的实现&quot;&gt;2.4 关联规则的实现&lt;/h3&gt;
&lt;ul readability=&quot;12&quot;&gt;&lt;li readability=&quot;13&quot;&gt;
&lt;p&gt;利用当前这一轮迭代生成的频繁项集curFreqSet来计算关联规则，利用curFreqSet建立频繁项索引freqSetIndex，同统计候选项频度的原因一样，我们需要将freqSetIndex广播到各个partition以统计规则A-&amp;gt;B左项A的频度，再利用freqSetIndex索引AB频繁项的频度即可计算规则A-&amp;gt;B的置信度，然后与设定的置信度对比即可筛选出需要的关联规则，代码实现如下：&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;// 生成关联规则
val asst1 = System.nanoTime()
// 建立频繁round-Itemsets的索引Map
val freqSetIndex = HashMap[HashSet[String], Int]()
curFreqSet.collect().foreach(fs =&amp;gt; freqSetIndex.put(fs._1, fs._2))
// 将频繁round-Itemsets的索引Map广播到各个partition
val broadcastCurFreqSet = sc.broadcast(freqSetIndex)
// 生成所有可能的关联规则，然后筛选出置信度&amp;gt;=confidence的关联规则
val associationRules = transations
        .flatMap(x =&amp;gt; verifyRules(x, broadcastCurFreqSet.value.keys.toArray, round))
        .reduceByKey(_ + _)
        .map(x =&amp;gt; ((x._1._1, x._1._2), broadcastCurFreqSet.value.get(x._1._1.union(x._1._2)).getOrElse(0) * 1.0 / x._2))
        .filter(x =&amp;gt; x._2 &amp;gt;= confidence)&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;11&quot;&gt;
&lt;p&gt;对于规则构造verifyRules的具体实现，我们通过遍历规则左项的长度来构造，具体实现如下：&lt;/p&gt;
&lt;pre class=&quot;scala&quot;&gt;
&lt;code&gt;def verifyRules(transaction: HashSet[String], candidates: Array[HashSet[String]], curRound: Int): Array[((HashSet[String], HashSet[String]), Int)] = {
    // yield会根据第一个循环类型返回对应的类型，这里的candidates是Array，因此返回的也是Array类型
    for {
        set &amp;lt;- candidates

        i &amp;lt;- 1 until curRound

        iter = set.subsets(i)
        l &amp;lt;- iter
        if (l.subsetOf(transaction))
        r = set.diff(l)
    } yield ((l, r), 1)
}&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三实验环境运行方式及结果&quot;&gt;三、实验环境、运行方式及结果&lt;/h2&gt;
&lt;h3 id=&quot;环境&quot;&gt;3.1 环境&lt;/h3&gt;
&lt;p&gt;spark分布式环境的安装&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;在本地配置好java,scala,hadoop(Spark会用到hadoop的hdfs)&lt;br/&gt;版本： jdk 1.8.0_161, scala 2.11.8, hadoop 2.7.5&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在spark官网下载spark-2.3.0-bin-hadoop2.7,解压安装&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt; tar -zxvf spark-2.3.0-bin-hadoop2.7 -C ~/bigdata/spark&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;配置环境变量,并使环境变量生效&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ vim ~/.bashrc
# Spark Environment Variables
export JAVA_HOME=~/bigdata/java/jdk1.8.0_161
export JRE_HOME=${JAVA_HOME}/jre
export SCALA_HOME=~/bigdata/scala/scala-2.11.8
export HADOOP_HOME=~/bigdata/hadoop/hadoop-2.7.5
export SPARK_HOME=~/bigdata/spark/spark-2.3.0-bin-hadoop2.7

export CLASS_PATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib

export PATH=${JAVA_HOME}/bin:${SCALA_HOME}/bin:${HADOOP_HOME}/bin:${HADOOP_HOME}/sbin:${SPARK_HOME}/bin:${SPARK_HOME}/sbin:$PATH

$ source /etc/profile&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;配置，spark的配置文件位于$SPARK_HOME/conf目录下，需要修改的文件有spark-env.sh, spark-defaluts.conf和slaves。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;$ cd ~/bigdata/spark/spark-2.3.0-bin-hadoop2.7/conf
$ cp spark-env.sh.template spark-env.sh
$ vim spark-env,sh
# spark-env.sh configuration
export JAVA_HOME=~/bigdata/java/jdk1.8.0_161
export SCALA_HOME=~/bigdata/scala/scala-2.11.8
export SPARK_HOME=~/bigdata/spark/spark-2.3.0-bin-hadoop2.7
export HADOOP_HOME=~/bigdata/hadoop/hadoop-2.7.5
export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop
export PATH=$PATH:$JAVA_HOME/bin:$SCALA_HOME/bin:$SPARK_HOME/bin:$HADOOP_HOME/bin
export SPARK_MASTER_IP=slave103

$ cp spark-defaluts.conf.template spark-defaults.conf
$ vim saprk-defaults.conf
# spark-defaults.conf configuration
spark.executor.extraJavaOptions    -XX:+PrintGCDetails -XX:+PrintGCTimeStamps
spark.eventLog.enabled             true
spark.eventLog.dir             hdfs://slave103:9000/spark_event
spark.yarn.historyServer.address   slave103:18080
spark.history.fs.logDirectory      hdfs://slave103:9000/history_log
spark.serializer                   org.apache.spark.serializer.KryoSerializer
spark.executor.memory              2g
spark.executor.cores               2
spark.driver.memory                2g
spark.driver.cores                 2
spark.yarn.am.memory               2g
spark.yarn.am.cores                2
spark.local.dir                    /tmp/sparklocaldir
spark.yarn.jars                    hdfs://slave103:9000/spark/jars/*                 

$ cp slaves.template slaves
$ vim slaves
# slaves configuration(主机名在/etc/hosts中配置)
slave101
slave103&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;启动和停止&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;# 启动
$ bash $SPARK_HOME/sbin/start-all.sh
# 停止
$ bash $SPARK_HOME/sbin/stop-all.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;启动hadoop和spark执行jps命令，显示的进程如下图3.1和3.2所示：&lt;/li&gt;
&lt;/ol&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-masterJPS.png&quot;/&gt;&lt;/div&gt;
&lt;center&gt;图3.1 主节点jvm进程&lt;/center&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-slaveJPS.png&quot;/&gt;&lt;/div&gt;
&lt;center&gt;图3.2 从节点jvm进程&lt;/center&gt;
&lt;h3 id=&quot;jar包运行方式&quot;&gt;3.2 jar包运行方式&lt;/h3&gt;
&lt;p&gt;假设输入数据文件为chess.dat，shell下运行方式如下：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;spark-submit --class main.scala.Apriori.distributed.Apriori --master spark://slave103:7077 --conf spark.driver.memory=4g --conf spark.executor.cores=2 original-MapReduce-1.0.jar input/apriori/chess.dat output 0.8 20 24 0.9
# jar后面的参数说明：输入文件 输出目录 支持度 迭代轮数 并发度即partition数目 置信度&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;结果&quot;&gt;3.3 结果&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;测试connect.dat数据集生成频繁项集的运行时间，图3.3是单机版的，图3.4是并行版的：&lt;/li&gt;
&lt;/ul&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori(seq).png&quot;/&gt;&lt;/div&gt;
&lt;center&gt;图3.3 单机版运行时间&lt;/center&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-2018-12-17%2021-15-32%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot;/&gt;&lt;/div&gt;
&lt;center&gt;图3.4 并行版运行时间&lt;/center&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在chess.dat数据集上测试并行版本的频繁项集生成和关联规则挖掘的运行时间如下：&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-2018-12-20%2023-29-08%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot;/&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;chess.dat频繁项集生成结果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-2018-12-20%2023-50-55%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot;/&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;chess.dat关联规则挖掘结果&lt;/li&gt;
&lt;/ul&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-2018-12-20%2023-51-19%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot;/&gt;&lt;/div&gt;
&lt;h2 id=&quot;四webui执行报告&quot;&gt;四、WebUI执行报告&lt;/h2&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-2018-12-20%2023-26-43%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot;/&gt;&lt;/div&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tracy-talent/Notes/master/imgs/Apriori-2018-12-20%2023-26-55%20%E7%9A%84%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE.png&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Thu, 20 Dec 2018 18:24:00 +0000</pubDate>
<dc:creator>编程匠心者</dc:creator>
<og:description>详细代码我已上传到github：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/brooksj/p/spark-Apriori.html</dc:identifier>
</item>
<item>
<title>javasrcipt的作用域和闭包（一） - 他乡踏雪</title>
<link>http://www.cnblogs.com/ZheOnaAndOnly/p/10153526.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZheOnaAndOnly/p/10153526.html</guid>
<description>&lt;p&gt;&lt;strong&gt;一、作用域是什么？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;几乎所有的编程语言最基本的功能之一，就是能够存储变量的值，并且能访问和修改这些值。&lt;/p&gt;
&lt;p&gt;修改变量值的过程我们通常在程序执行时，称为改变一个对象的状态。有了状态，让程序变得有非常有趣。&lt;/p&gt;
&lt;p&gt;然而，这些变量存在哪里？程序又是如何找到它们的？&lt;/p&gt;
&lt;p&gt;这些问题就说明需要一套设计良好的规则来存储变量，并且之后能方便的找到这些变量。&lt;span&gt;这套规则就被称为作用域&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1编译原理&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;javasctrip通常被称为“动态“”和“解释执行”语言（脚本），但事实上它是一门语言。但是javascript不能像其他传统语言被通篇编译，编译结果更不能像传统语言一样在分布式系统中移植。但是编译方式任然和传统语言的编译方式非常相识，在某些环节可能比传统语言的编译还要复杂。&lt;/p&gt;
&lt;p&gt;传统编程语言的编译流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;1.1.1分词/词法分析（Tokenizing/Lexing）&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这个过程将由字符组成的字符串分解成代码块（对编程语言来说有意义的代码块），&lt;span&gt;这些代码块被称为词法单元（token）&lt;/span&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以下列程序为例&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; a = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;该程序将会被分解成下面这些词法单元&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;var、a、=、2、;&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt;空格是否有意义，取决于空格在这门语言中是否具有意义&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;分词（tokenizing）与词法分析(Lexing)之间的主要区别在于，词法单元的识别是通过有状态还是无状态的方式进行的。&lt;/p&gt;
&lt;p&gt;也就是说词法单元生成器判断a是一个独立的词法单元，调用的就是无状态的解析规则，&lt;span&gt;这个过程就叫做分词&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果词法单元生成器判断a是其他词法单元的一部分，调用的就是有状态的解析规则，&lt;span&gt;这个过程叫做词法分析&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1.2解析/语法分析(Parsing)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;解析也就是语法分析过程，是将词法单元（数组）转换成一个有元素逐级嵌套所组成的代表程序语法的结构树。这个数被称为“抽象语法树”。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;例如：var a = 2；大概可以用一下树形图表示。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309608/201812/1309608-20181220024138117-131057767.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;深度理解抽象语法树：&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/7759414.html&quot;&gt;javascript编写一个简单的编译器(理解抽象语法树AST)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.1.3代码生成&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 代码生成就是将AST转换成可执行代码。&lt;/p&gt;
&lt;p&gt;简单的说（不讨论具体生成细节）就是将var a = 2 ;转化为一组机器指定，用来穿件一个叫a的变量（包括分配内存等），并将一个值存储在a中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：javascript编译生成的具体内容，待后面有相关文章分析，这一部分只对传统与编译与javascript编译做对比介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而&lt;/strong&gt;，javascript相比较传统编程语言来说，javascript引擎要复杂的多。&lt;/p&gt;
&lt;p&gt;例如：在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。&lt;/p&gt;
&lt;p&gt;javascript不会像传统语言那样在程序执行前通篇编译，而是在执行的前一刻进行编译，这个时间只有几微妙（甚至更短）。&lt;/p&gt;
&lt;p&gt;这些都是我们讨论作用域的背后问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2理解javascript的作用域&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在解析javascript作用域之前，我们先来了解一下引擎、编译器、作用域及三者之间的关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2.1关系&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引擎，也就是浏览器的内核。负责整个javascriot程序的编译和执行过程。&lt;/p&gt;
&lt;p&gt;编译器，负责语法分析及代码生成（1.1编译原理）。&lt;/p&gt;
&lt;p&gt;作用域，负责收集维护所有声明的标识符（变量）&lt;strong&gt;组成的一系列查询&lt;/strong&gt;，并且带有严格的规则，确定当前执行代码对这些标识符的&lt;strong&gt;访问权限&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2.1引擎与编译器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以var a = 2;为例，通常这段代码我们所理解的编译就是一句声明。&lt;/p&gt;
&lt;p&gt;但是，引擎完全不这么看，引擎在编译这段代码时有两个完全不同的声明。&lt;/p&gt;
&lt;p&gt;两个？是的，两个完全不同的声明。&lt;/p&gt;
&lt;p&gt;从通常的理解来看，我们认为引擎编译处理这段代码是：&lt;/p&gt;
&lt;p&gt;　　编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。&lt;span&gt;（这是1.1.1和1.1.2传统编程语言编译时的分词/词法分析和解析/语法分析）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果是这样，也就可以将这段代码通俗的理解为：为一个变量分配内存，将其命名为a，然后将值2保存进这个变量。&lt;/p&gt;
&lt;p&gt;然而，事实上引擎与编译器会这么处理：&lt;/p&gt;
&lt;p&gt;　　1）遇到var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一作用域的集合中。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果是，编译器会忽略该声明，继续进行编译。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　否则，它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为a。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　~接下来，编译器会为引擎生成运行时所需要的代码，这些代码用来处理a = 2这个赋值操作。&lt;/p&gt;
&lt;p&gt;　　2）遇到a = 2时，引擎首先会问作用域，在当前的作用域集合中是否存在一个叫做a的变量。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　如果是，引擎就会使用该变量，在当前作用域找到的a变量，并给a的命名空间上赋值2。（如果找到a变量但赋值失败就会抛出异常）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　否则，引擎会继续查找该变量（1.3作用域嵌套相关的内容）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2.3编译器怎会如此简单&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在编译过程的第二部生成代码，引擎执行它时，会通过查找变量a来判断它是否已经声明过。查找过程由作用域协助，但是引擎执行怎样的查找，会影响最终的查找结果。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在上面的例子中，引擎会为a进行LHS查询。另一个查找的类型叫做RHS。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我想大家能猜到“L”和“R”的含义，他们分别代表左侧和右侧。（&lt;span&gt;什么东西的左侧和右侧？&lt;/span&gt;）&lt;/p&gt;
&lt;p&gt;——&lt;span&gt;赋值操作的左侧和右侧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;简单的说，就是当变量出现在左侧时进行LHS查询，出现在右侧时进行RHS查询。但是说到这里大家估计还是一头雾水，下面我们来看一些示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
b = 10&lt;span&gt;;
console.log(b);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这两行代码引擎在编译的过程中就执行了不同的查询。&lt;/p&gt;
&lt;p&gt;抛开b变量的声明问题（此处埋雷了），我们假设b已经被声明过了。&lt;/p&gt;
&lt;p&gt;在编译b = 10 的时候，引擎会执行LHS查询，编译器在编译这段代码时，会先去作用域上查找变量b，看有没有这个变量。&lt;/p&gt;
&lt;p&gt;在编译console.log(b)时,b引用的是RHS查询，直接通过b变量去作用域上查找b变量的值。然后把查找到的值赋给console.log(...)。&lt;/p&gt;
&lt;p&gt;通俗的说，b = 10引用LHS查询是试图找到变量容器的本身，&lt;/p&gt;
&lt;p&gt;而console.log(b)引用的RHS查询是试图找到b变量容器里面的值。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：LSH和RHS的含义是“赋值操作的左侧或右侧”并不意味着就是“=赋值操作的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LSH）”以及“谁是赋值操作的源头（RHS）”。(如果这里有点懵可暂时跳过，上面的解释我认为可以解决99.9%的开发时遇到的问题)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;继续来一个示例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(a){
  console.log(a);
}
foo(&lt;/span&gt;2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里只关注foo(2)这部分代码编译时的赋值操作，这段代码编译时共存在4次赋值操作。（注意：这里赋值操作不是通常编码时的概念，而是编译器的赋值操作）&lt;/p&gt;
&lt;p&gt;第一个赋值操作：foo(...)函数调用需要对foo进行RHS引用，意味着去找到foo的值，并把它交给引擎执行（相当于把foo的值赋给引擎）。&lt;/p&gt;
&lt;p&gt;第二个赋值操作：a=2,这个操作隐式的发生在执行foo(...)的前一刻，编译器会给参数a（隐式的）分配值，需要进行一次LHS查询。&lt;/p&gt;
&lt;p&gt;第三个赋值操作：当console.log(...)被调用时，编译器需要对console对象引用RHS查询，并检查得到的值中是否有一个叫做log的方法。&lt;/p&gt;
&lt;p&gt;第四个赋值操作：在执行console.log(a)的前一刻，这里还需要对a进行一次RHS查询，并且把值传给console.log(...)。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.2.4引擎与作用域&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 这一部分我就引用《你不知道的JavaScript:上卷》中的一段原文，书中的解析非常的人性、轻松、易懂。（这些词语可能还不足以描述他的好！！！）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(a){
  console.log(a);
}
foo(&lt;/span&gt;2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;书中对这段代码的编译描述，把引擎和作用域比作两个人对话，读完这段对话你就会明白引擎与作用域之间的关系了。&lt;/p&gt;
&lt;p&gt;引擎：我说作用域，我需要foo进行RHS引用。你见过它吗？&lt;/p&gt;
&lt;p&gt;作用域：别说，我真见过，编译器那小子刚刚声明了它。他是一个函数，给你。&lt;/p&gt;
&lt;p&gt;引擎：哥们太够意思！好吧，大哥，我来执行foo。&lt;/p&gt;
&lt;p&gt;引擎：作用域，还有个事儿。我需要为a进行LHS引用，这个你见过吗？&lt;/p&gt;
&lt;p&gt;作用域：这个也见过，编译器最近把它声明为foo的一个形式参数，拿去吧。&lt;/p&gt;
&lt;p&gt;引擎：大恩不言谢，你总是这么棒。现在我要把2赋值给a。&lt;/p&gt;
&lt;p&gt;引擎：哥们，不好意思又来打扰你。我要为console进行RHS引用，你见过它吗？&lt;/p&gt;
&lt;p&gt;作用域：咱两谁跟谁啊，在说我就是干这个的。这个我也有，console是个内置对象。&lt;/p&gt;
&lt;p&gt;              给你。&lt;/p&gt;
&lt;p&gt;引擎：么么哒。我得看看这里面是不是有log(...)。太好了，找到了，是一个函数。&lt;/p&gt;
&lt;p&gt;引擎：哥们，能帮我再找一下a的RHS引用吗？虽然我记得它，但想再确认一次。&lt;/p&gt;
&lt;p&gt;作用域：放心吧，这个变量没动过，拿走，不谢。&lt;/p&gt;
&lt;p&gt;引擎：真棒。我来把a的值，也就是2，传递进log(...)。&lt;/p&gt;
&lt;p&gt;......&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2.5这里需要来个小测试了&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分别查找下列代码中有几个LHS查询和RHS查询，还可以试试编写一个引擎、编译器、作用域之间的对话。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;31.5&quot;&gt;&lt;img id=&quot;code_img_closed_91d845a8-14a7-453d-b403-9ef6aebdfcbb&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_91d845a8-14a7-453d-b403-9ef6aebdfcbb&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_91d845a8-14a7-453d-b403-9ef6aebdfcbb&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(a){
  &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b =&lt;span&gt; a;
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; a +&lt;span&gt; b;   
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; c = foo(2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;答案待整理完这个系列书的笔记后来添加。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.3作用域嵌套&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;记得在1.2.1中我们介绍了作用域，也在1.2.4中介绍了作用域在代码编译执行时所承担的任务。如果只说前面介绍的作用域就是它的全部的话，那真的是太小看它了。&lt;/p&gt;
&lt;p&gt;作用域因为嵌套机制让我们编写的程序如虎天翼，如果你对javascript很了解的话，没有作用域嵌套机制你一定会想死，但是有了嵌套机制你就更会想死，她有一个让你活着笑的方法，就是你必须征服她。&lt;/p&gt;
&lt;p&gt;所以，加油。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在这里暂时对作用域嵌套做一个简单的介绍，后期一步一步深入的介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt; 1.3.1定义&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 前面说过，作用域是根据名称查找变量的一套规则，而这套规则通常都建立在几个作用域上。&lt;/p&gt;
&lt;p&gt; 当一个块或函数嵌套在另一个块或者函数中时，就发生了作用域的嵌套关系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.3.2应用&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 在当前作用域无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或抵达最外层的作用域（全局作用域）为止。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(a){
  console.log(a&lt;/span&gt;+&lt;span&gt;b);
}
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; b = 2&lt;span&gt;;
foo(&lt;/span&gt;2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这段代码中，对b进行RHS引用无法在函数foo内部完成，但可以在上一级作用域（全局作用域）中完成。（所以引擎与作用域有了这样一段对话）&lt;/p&gt;
&lt;p&gt;引擎：foo的作用域兄弟，你见过b吗？我需要对它进行RHS引用。&lt;/p&gt;
&lt;p&gt;作用域：听都没听过，走开。&lt;/p&gt;
&lt;p&gt;引擎：foo的上级作用域兄弟，咦？有眼不识泰山，原来你是全局作用域大哥，太好了。你见过b吗？我需要对它进行RHS引用。&lt;/p&gt;
&lt;p&gt;作用域：当然了，给你吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.3.3遍历作用域链的规则&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;引擎从当前的执行作用域开始找变量，如果找不到，就向上一级继续查找。当抵达最外层的全局作用域时，无论找到还是没找到，查找过程都会停止。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于作用域链的嵌套，如果我们用可视化的图形来表示，可以象形的比作下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1309608/201812/1309608-20181220193930899-1248497051.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;引擎从当前作用域开始；&lt;/p&gt;
&lt;p&gt;然后到达上级作用域；（与当前作用域有嵌套关系的作用域，也可以叫做父级作用域）&lt;/p&gt;
&lt;p&gt;......　　　　　　　　 （这中间可以被嵌套若干个节点）&lt;/p&gt;
&lt;p&gt;直到全局作用域。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.4异常&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;为什么我们在编译环节要花很大篇幅介绍LHS和RHS呢？&lt;/p&gt;
&lt;p&gt;还记得在1.2.3中我标注了一个“此处埋雷了”。&lt;/p&gt;
&lt;p&gt;在前端开发中，我们的编辑器是不会提示变量未声明的；而在其他后台编程语言中，这个提示是普遍存在的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(a){
  console.log(a &lt;/span&gt;+&lt;span&gt; b);&lt;br/&gt;b = a;&lt;br/&gt;&lt;/span&gt;&lt;span&gt;} &lt;br/&gt;foo(&lt;/span&gt;2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行的结果：Uncaught &lt;strong&gt;&lt;span&gt;ReferenceError&lt;/span&gt;&lt;/strong&gt;: b is not defined&lt;/p&gt;
&lt;p&gt;报错ReferenceError表示非法或不能识别的引用数据。（暂时不讨论这个问题，我们再来看一段代码）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; foo(a){
  b &lt;/span&gt;=&lt;span&gt; a;
  console.log(a &lt;/span&gt;+&lt;span&gt; b);
} 
foo(&lt;/span&gt;2);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果：4&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我相信又变成经验的朋友都知道：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第一段代码是因为调用一个未经声明的变量的值会报错，第二段代码在执行b=a时内部隐式的创建了一个变量b，然后将a的值赋给b，所以没有报错。&lt;/p&gt;
&lt;p&gt;的确是这样，但是为什么呢？同样是调用一个未经声明的变量，为什么第一段代码会报错，而第二段代码会内部隐式创建这个变量呢？&lt;/p&gt;
&lt;p&gt;我们都知道这个问题发生在编译环节，那我们就来分析一下引擎在这个环节究竟有什么区别，那我们就看有区别的部分，跳过fon的RHS查询，跳过a的LHS查询，直接进入函数内部执行语句。&lt;/p&gt;
&lt;p&gt;第一段代码先执行console.log(a + b)，&lt;span&gt;在这里b执行的是RHS查询&lt;/span&gt;，当前作用域和全局作用域都找不到这个变量，然后因为没办法引用这个变量的值，抛出错误。&lt;/p&gt;
&lt;p&gt;第二段代码先执行b = a,&lt;span&gt;在这里b执行的是LHS查询&lt;/span&gt;，当前作用域和全局作用域上都找不到b变量，这时候就会在全局作用域上创建一个b变量，并将其返还给引擎。引擎就可以执行正常的赋值操作了。&lt;/p&gt;
&lt;p&gt;这就是编译环节中RHS与LHS查询的区别，当查询的变量没有定义时，编译器执行的LHS查询会隐式创建这个变量。而当编译器执行RHS查询时，因为无法获取到未声明变量的值会抛出错误。&lt;/p&gt;
&lt;p&gt;为了避免这样一些低级的错误持续干扰我们的开发，ES5引入了“严格模式”。&lt;/p&gt;
&lt;p&gt;在严格模式下，编译器执行LHS查询也会跟RHS查询一样，使用未经声明的变量同样会抛出&lt;span&gt;ReferenceError&lt;/span&gt;错误提示。&lt;/p&gt;
&lt;p&gt;关于严格模式下编译环节还有一些除了&lt;span&gt;ReferenceError&lt;/span&gt;以外的错误提示。&lt;/p&gt;
&lt;p&gt;1.对一个非函数类型的值执行函数调用。&lt;/p&gt;
&lt;p&gt;2.引用null和undefined类型的值中的属性。&lt;/p&gt;
&lt;p&gt;以上这种不合理的操作在严格模式下，编译环节会抛出TypeError错误提示。&lt;/p&gt;
&lt;p&gt;ReferenceError同作用域判别失败相关，而TypeError则代表作用域判别成功，但是对结果的操作是非法或不合理的。&lt;/p&gt;
</description>
<pubDate>Thu, 20 Dec 2018 17:11:00 +0000</pubDate>
<dc:creator>他乡踏雪</dc:creator>
<og:description>一、作用域是什么？ 几乎所有的编程语言最基本的功能之一，就是能够存储变量的值，并且能访问和修改这些值。 修改变量值的过程我们通常在程序执行时，称为改变一个对象的状态。有了状态，让程序变得有非常有趣。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZheOnaAndOnly/p/10153526.html</dc:identifier>
</item>
<item>
<title>清清楚楚地搭建MongoDB数据库（以搭建4.0.4版本的副本集为例） - 东山絮柳仔</title>
<link>http://www.cnblogs.com/xuliuzai/p/10152789.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xuliuzai/p/10152789.html</guid>
<description>&lt;h3&gt;数据的目录文件层次设计&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201812/780228-20181220215937208-717112405.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 我们一般采用多实例的方式，而不是将所有的数据库尽可能地放在一个实例中。&lt;/p&gt;
&lt;p&gt;主要基于以下考虑：&lt;/p&gt;
&lt;p&gt;1:不同业务线对应的数据库放在不同的实例上，部分操作的运维时间容易协调等到。&lt;/p&gt;
&lt;p&gt;2:相互独立，减少相互干扰。不会因为某个业务的激增或某个开发Team的代码问题，拖累太多的数据库。&lt;/p&gt;
&lt;p&gt;3:实例资源容易控制，例如内存等。&lt;/p&gt;

&lt;p&gt;从上图可以知道，mongo二进制文件是多个实例公用的。一个版本一个目录，从图可以看出，这个服务器上支持两个版本的MongoDB，一个是版本3.4.4，一个是比较新的4.0.4。三级目录上的实例文档，我们一般是根据用途命名。比如，要安装一台存储weixin信息的MongoDB，使用的版本是4.0.4,那么它的目录层次是这样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/780228/201812/780228-20181221003234732-1393187546.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;安装配置步骤&lt;/h3&gt;
&lt;p&gt;下面以安装mongodbtest实例为例，逐步实现。此案例演示到创建副本集结束。&lt;/p&gt;
&lt;p&gt;要搭建的副本集名称为 repltest，节点信息如下：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;span&gt;Item&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;ServerIP&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;span&gt;Port&lt;/span&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;Primary&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;171.217.177.125&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;27288&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;Secondary&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;171.217.177.182&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;27288&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;&lt;em&gt;&lt;span&gt;Arbiter&lt;/span&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;171.217.177.134&lt;/span&gt;&lt;/td&gt;
&lt;td&gt;&lt;span&gt;27288&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;step 1 创建mongodb的配置文件，添加基本参数&lt;/strong&gt;&lt;br/&gt;创建文件：&lt;br/&gt;touch mongodbtest.conf&lt;br/&gt;添加启动参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
port=27288
dbpath=/data/mongodb/mongodbtest/data/db
logpath=/data/mongodb/mongodbtest/logs/mongod.log
fork=true
bind_ip=127.0.0.1,171.217.177.125
maxConns=2500
wiredTigerCacheSizeGB=108
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;step 2 创建数据文件和日志文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;创建数据文件&lt;br/&gt;mkdir -p /data/mongodb/mongodbtest/data/db&lt;/p&gt;
&lt;p&gt;指定路径下创建日志文件&lt;br/&gt;touch mongod.log&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step 3为 Linux 系统添加mongodb专有账号（&lt;/strong&gt;非必须，当然也可以以root账号启动；一次性，检查服务器上已添加，不需要执行了）&lt;br/&gt;useradd mongouser&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step 4 修改mongo数据文件的拥有者,（为mongouser增加权限）&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
chown -R mongodbuser:mongouser /data/mongodb/mongodbtest
chown -R mongodbuser:mongouser /data/mongodb/authkeyfile/mon-keyfile   ###(一次性)
chown -R mongodbuser:mongouser /data/mongodb/mongobin404/bin/mongodbtest.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;step 5 添加MongoDB服务配置文件,配置service服务的文件。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;service 文件放置在/lib/systemd/system文件夹中&lt;/p&gt;
&lt;p&gt;touch mongodbtest.service&lt;/p&gt;
&lt;p&gt;添加参数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[Unit]

Description=mongodbtest
After=network.target remote-fs.target nss-lookup.target
[Service]
User=mongouser
Group=mongouser
# (open files)
LimitNOFILE=64000
Type=forking
ExecStart=/data/mongodb/mongobin404/bin/mongod --config /data/mongodb/mongobin404/bin/mongodbtest.conf
ExecReload=/bin/kill -s HUP $MAINPID
ExecStop=/data/mongodb/mongobin404/bin/mongod --shutdown --config /data/mongodb/mongobin404/bin/mongodbtest.conf
PrivateTmp=true

[Install]
WantedBy=multi-user.target
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;step 6 启动服务，添加服务自启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动&lt;/p&gt;
&lt;p&gt;systemctl start mongodbtest.service&lt;/p&gt;
&lt;p&gt;查看状态&lt;/p&gt;
&lt;p&gt;systemctl status mongodbtest.service&lt;/p&gt;
&lt;p&gt;设置服务为开机自启动&lt;/p&gt;
&lt;p&gt;systemctl enable mongodbtest.service&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step 7 添加认证启动前，配置root权限的账号(在admin数据中执行)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;db.createUser({user:&quot;roottest&quot;, pwd:&quot;roottestrootok&quot;,roles:[{role:&quot;root&quot;,db:&quot;admin&quot;}]})&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step 8 修改启动文件mongodbtest.conf，追加登入验证参数，和副本集参数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;（安全认证机制KeyFile的设置在此不做详解了，大家可以goole或百度）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
auth=true
replSet=repltest
oplogSize=1024
keyFile=/data/mongodb/authkeyfile/mon-keyfile　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;以上8步所有的操作，在副本集的所有节点上（Primary、Secondary、arbiter）都要操作一遍。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;step 9 重启服务，配置副本集，请在Primary&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;---副本集初始化&lt;br/&gt;rs.initiate( {_id : &quot;repltest&quot;, members: [ { _id : 0, host : &quot;171.217.177.125:27288&quot; } ]})&lt;br/&gt;----添加辅助节点&lt;br/&gt;rs.add(&quot;171.217.177.182:27288&quot;)&lt;br/&gt;----添加见证节点&lt;br/&gt;rs.add(&quot;171.217.177.134:27288&quot;,true)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;step 10 创建用户数据库及设置相关权限(要在指定的数据库test_messqq上执行)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;配置读写账号&lt;/p&gt;
&lt;p&gt;db.createUser({user:&quot;test_messqq_dev&quot;, pwd:&quot;test_messqq_devyaoqian&quot;,roles: [ { &quot;role&quot; : &quot;readWrite&quot;, &quot;db&quot; : &quot;test_messqq&quot; }] })&lt;/p&gt;
&lt;p&gt;配置只读账号&lt;br/&gt;db.createUser({user:&quot;test_messqq_dev_read&quot;, pwd:&quot;test_messqq_dev_read&quot;,roles: [ { &quot;role&quot; : &quot;read&quot;, &quot;db&quot; : &quot;test_messqq&quot; }] })&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;本文版权归作者所有，未经作者同意不得转载,谢谢配合！！！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 20 Dec 2018 16:39:00 +0000</pubDate>
<dc:creator>东山絮柳仔</dc:creator>
<og:description>数据的目录文件层次设计 我们一般采用多实例的方式，而不是将所有的数据库尽可能地放在一个实例中。 主要基于以下考虑： 1:不同业务线对应的数据库放在不同的实例上，部分操作的运维时间容易协调等到。 2:相</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xuliuzai/p/10152789.html</dc:identifier>
</item>
<item>
<title>初步掌握node的路由控制 - 木人子韦一日尘</title>
<link>http://www.cnblogs.com/murenziwei/p/10153477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/murenziwei/p/10153477.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.1.2：node.js的路由控制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.运行原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    在1.1.1节中，提到过app.js中app.get(&quot;/&quot;,routes.index)可以用以下代码取代：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
app.get(&quot;/&quot;,function(req,res){

    res.render(&quot;index&quot;,{title:&quot;Express&quot;});

})
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    这段代码可以这样理解：当访问主页时，调用ejs模板引擎来渲染index.ejs模板文件（即将所有的tittle变量替换成字符串Express）,生成静态页面并渲染在浏览器上。&lt;/p&gt;
&lt;p&gt;     我就在这里做一个修改，既然以上的代码可以实现路由的功能，那么我可以去除routes/index.js文件，把实现路由功能的代码都写在app.js里，随着功能需求的增多，app.js会变得臃肿且难以维护，这不符合代码模块化的思想，所以呢，那些实现路由功能的代码都放在了routes/index.js中。官方给出的写法是在app.js中实现了简单的路由分配，然后再去index.js中找到相应的路由函数，最终实现路由功能。我准备这样做，把路由控制器和实现路由功能的函数都放到index.js里，在app.js只有一个总的路由接口。&lt;/p&gt;
&lt;p&gt;     打开app.js，做出修改和添加，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/**
 * Module dependencies.
 */

var express = require('express');

var routes = require('./routes');
/*
var user = require('./routes/user');
*/
var http = require('http');
var path = require('path');

var app = express();

// all environments
app.set('port', process.env.PORT || 3000);
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'ejs');
app.use(express.favicon());
app.use(express.logger('dev'));
app.use(express.json());
app.use(express.urlencoded());
app.use(express.methodOverride());
app.use(app.router);
app.use(express.static(path.join(__dirname, 'public')));

// development only
if ('development' == app.get('env')) {
  app.use(express.errorHandler());
}
/*
app.get('/', routes.index);
app.get('/users', user.list);
*/
http.createServer(app).listen(app.get('port'), function(){
  console.log('Express server listening on port ' + app.get('port'));
});
//添加代码
routes(app);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　打开index.js，修改如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/*
 * GET home page.
 */

module.exports = function(app){
  app.get(&quot;/&quot;,function(req,res){
        res.render(&quot;index&quot;,{title:&quot;Express&quot;});
  });
};
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后，你再次在app.js目录上，打开终端，输入node app，访问localhost:3000，你会发现修改后的效果和修改前的效果没有变化。为何？这里我在routes/index.js中通过module.express导出了一个函数接口，在app.js中通过require加载了index.js，然后通过routes(app)调用了index.js导出的函数;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.路由规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Express封装了多种http请求方式，常用的有get和post，即app.get()和app.post();app.get()和app.post()的第一个参数都为请求的路径，第二个参数为处理请求的回调函数，回调函数有两个参数，请求和响应，习惯用req和res表示。路径请求及对应的获取路径有以下几种形式：&lt;/p&gt;
&lt;p&gt;    （1）req.query&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
//GET  /murenziwei?like=node
console.log(req.query.like) //=&amp;gt;&quot;node&quot;

//GET  /love?name=liwei&amp;amp;birthday[year]=2222&amp;amp;birthday[month]=11
console.log(req.query.name);//=&amp;gt;&quot;liwei&quot;

console.log(req.query.birthday.year);//=&amp;gt;&quot;2222&quot;

console.log(req.query.birthday.month);//=&amp;gt;&quot;11&quot;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）  req.body&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
//POST  book[name]=凡人修仙传&amp;amp;book[author]=忘语
console.log(req.body.book.name)//=&amp;gt;凡人修仙传

console.log(req.body.book.author);//=&amp;gt;忘语

//POST  {&quot;name&quot;:&quot;诛仙&quot;}
console.log(req.body.name);//=&amp;gt;诛仙
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）req.params&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
//GET  /user/murenziwei
console.log(req.params.name)//=&amp;gt;&quot;murenziwei&quot;

//GET /language/typescript/node.js
console.log(req.params[0]);//=&amp;gt;&quot;typescript/node.js&quot;

&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（4）req.param(xxx)&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
//GET /language/typescript/node.js?name=liwei
console.log(req.param('name'))//=&amp;gt;&quot;liwei&quot;

//POST name=liwei
console.log(req.param('name'));//=&amp;gt;&quot;liwei&quot;

// /user/liwei  for  /user/:name
console.log(req.param('name'));//=&amp;gt;&quot;liwei&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 由上述的代码，总结出以下获取路径的含义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;req.query：处理get请求，获取get请求体&lt;/li&gt;
&lt;li&gt;req.body：处理post请求，获取post请求体&lt;/li&gt;
&lt;li&gt;req.params：处理/:xxx形式的get或post请求，获取请求参数&lt;/li&gt;
&lt;li&gt;req.param()：处理get和post请求，但查找优先级由高到低为：req.params=&amp;gt;req.body=&amp;gt;req.query&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt; 听说路径规则还支持正则表达式，如果你感兴趣的话，不妨一试。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.路由规则&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; 在浏览器上访问localhost:3000，会显示如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/792361/201812/792361-20181221001444915-924078792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果我要访问localhost:3000/hello这种不存在的页面时就会显示如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/792361/201812/792361-20181221001714442-1910671223.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;这是因为不存在/hello的路由规则，而且它也不是一个public目录下的文件，所有express返回了404Not Found的错误。下面我来添加一个路由规则，使得当访问localhost:3000/hello时，页面显示“你好，路由规则！”&lt;/p&gt;
&lt;p&gt;修改index.js，在app.get(&quot;/&quot;)后面添加一条路由规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
/*
 * GET home page.
 */

module.exports = function(app){
  app.get(&quot;/&quot;,function(req,res){
        res.render(&quot;index&quot;,{title:&quot;Express&quot;});
  });
  app.get(&quot;/hello&quot;,function(req,res){
        res.send(&quot;你好，路由规则！&quot;);
  });
};　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 修改后，再来在终端重新输入node app，打开浏览器访问local host:3000/hello页面显示图下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/792361/201812/792361-20181221002952458-1026147445.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;看到这，是不是很简单！那么总结一下，我主要讲了基本的路由规则以及如何添加一条路由规则的知识点。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 20 Dec 2018 16:39:00 +0000</pubDate>
<dc:creator>木人子韦一日尘</dc:creator>
<og:description>1.1.2：node.js的路由控制 1.运行原理 在1.1.1节中，提到过app.js中app.get(&quot;/&quot;,routes.index)可以用以下代码取代： 这段代码可以这样理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/murenziwei/p/10153477.html</dc:identifier>
</item>
<item>
<title>redis小结 - Teenager</title>
<link>http://www.cnblogs.com/yebingluo/p/10153468.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yebingluo/p/10153468.html</guid>
<description>&lt;h3&gt;1.redis的简单介绍&lt;/h3&gt;
&lt;p&gt;   redis是一种高性能的Key-Value类型的内存数据库，之所以说性能非常好，是因为redis是存放在内存中的，存取都是不用进行io磁盘操作，所以效率十分高。&lt;/p&gt;
&lt;h3&gt;2.为什么会使用redis这种数据结构&lt;/h3&gt;
&lt;p&gt;   其一：就是性能好，可以节约大量的时间。其二：在高并发的情况下，如果所有的请求（一般查询偏多）都直接请求数据库，会导致数据库连接异常。如果在这种情况下，先请求redis缓存，即可有效缓解这种问题。&lt;/p&gt;
&lt;h3&gt;3.redis可支持的数据类型及使用场景&lt;/h3&gt;
&lt;p&gt;redis除了性能和高并发还能支持多种数据类型，包括：list，set，hash，sorted set, hash共五中数据接口。&lt;/p&gt;
&lt;h3&gt;4.redis单线程效率为何那么高&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;  纯内存操作，没有IO磁盘操作，因此效率很高。&lt;/li&gt;
&lt;li&gt;  单线程操作，避免了频繁的上下文切换，从一定角度来看也是提高了效率。&lt;/li&gt;
&lt;li&gt;  采用了非阻塞I/O多路复用机制&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;5.redis数据持久化&lt;/h3&gt;
&lt;p&gt;Redis 提供了多种不同级别的持久化方式：&lt;/p&gt;
&lt;ul class=&quot;simple&quot;&gt;&lt;li&gt;RDB 持久化可以在指定的时间间隔内生成数据集的时间点快照（point-in-time snapshot）。&lt;/li&gt;
&lt;li&gt;AOF 持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。 AOF 文件中的命令全部以 Redis 协议的格式来保存，新命令会被追加到文件的末尾。 Redis 还可以在后台对 AOF 文件进行重写（rewrite），使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小。&lt;/li&gt;
&lt;li&gt;Redis 还可以同时使用 AOF 持久化和 RDB 持久化。 在这种情况下， 当 Redis 重启时， 它会优先使用 AOF 文件来还原数据集， 因为 AOF 文件保存的数据集通常比 RDB 文件所保存的数据集更完整。&lt;/li&gt;
&lt;li&gt;你甚至可以关闭持久化功能，让数据只在服务器运行时存在。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;了解 RDB 持久化和 AOF 持久化之间的异同是非常重要的， 以下几个小节将详细地介绍这这两种持久化功能， 并对它们的相同和不同之处进行说明。&lt;/p&gt;
&lt;p&gt;RDB：RDB 是一个非常紧凑（compact）的文件，它保存了 Redis 在某个时间点上的数据集。 这种文件非常适合用于进行备份。虽然 Redis 允许你设置不同的保存点（save point）来控制保存 RDB 文件的频率， 但是， 因为RDB 文件需要保存整个数据集的状态， 所以它并不是一个轻松的操作。 因此你可能会至少 5 分钟才保存一次 RDB 文件。 在这种情况下， 一旦发生故障停机， 你就可能会丢失好几分钟的数据。所以如果不允许丢失数据的RDB不合适。&lt;/p&gt;
&lt;p&gt;AOF：使用 AOF 持久化会让 Redis 变得非常耐久。AOF 文件有序地保存了对数据库执行的所有写入操作。对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。并且效率比RDB低。&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;究竟选择哪一种方法：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; 如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失， 那么你可以只使用 RDB 持久化。&lt;/p&gt;
&lt;p&gt;有很多用户都只使用 AOF 持久化， 但我们并不推荐这种方式： 因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快， 除此之外， 使用 RDB 还可以避免之前提到的 AOF 程序的 bug 。&lt;/p&gt;
&lt;h3&gt;6.redis分布式锁的实现&lt;/h3&gt;
&lt;p id=&quot;可靠性&quot;&gt;&lt;strong&gt;可靠性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;互斥性。在任意时刻，只有一个客户端能持有锁。&lt;/li&gt;
&lt;li&gt;不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。&lt;/li&gt;
&lt;li&gt;具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。&lt;/li&gt;
&lt;li&gt;解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt; 加锁的简单实现方法：每个客户端或者说每一个对象对于同一个key都只能执行一次set，保证了加锁的机制。等操作完成及时解锁。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;42&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class RedisTool {

    private static final String LOCK_SUCCESS = &quot;OK&quot;;
    private static final String SET_IF_NOT_EXIST = &quot;NX&quot;;
    private static final String SET_WITH_EXPIRE_TIME = &quot;PX&quot;;

    /**
     * 尝试获取分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @param expireTime 超期时间
     * @return 是否获取成功
     */
    public static boolean tryGetDistributedLock(Jedis jedis, String lockKey, String requestId, int expireTime) {

        String result = jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);

        if (LOCK_SUCCESS.equals(result)) {
            return true;
        }
        return false;

    }

}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;解锁的简单实现　　：根据key对应的value，进行删除锁。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class RedisTool {

    private static final Long RELEASE_SUCCESS = 1L;

    /**
     * 释放分布式锁
     * @param jedis Redis客户端
     * @param lockKey 锁
     * @param requestId 请求标识
     * @return 是否释放成功
     */
    public static boolean releaseDistributedLock(Jedis jedis, String lockKey, String requestId) {

        String script = &quot;if redis.call('get', KEYS[1]) == ARGV[1] then return redis.call('del', KEYS[1]) else return 0 end&quot;;
        Object result = jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));

        if (RELEASE_SUCCESS.equals(result)) {
            return true;
        }
        return false;

    }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　应用场景：使用redis实现分布式锁，达到分布式部署场景下用户借款串行处理（防止产生多笔重复借款）。&lt;/p&gt;
&lt;h3&gt;7.redis的过期策略以及内存淘汰机制&lt;/h3&gt;
&lt;p&gt;redis采用的是定期删除和惰性删除，而还有一种叫定时删除，&lt;/p&gt;
&lt;p&gt;为什么不用定时删除策略?&lt;/p&gt;
&lt;p&gt;定时删除,用一个定时器来负责监视key,过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key,因此没有采用这一策略.&lt;/p&gt;

&lt;p&gt;定期删除，redis默认每个100ms检查，是否有过期的key,有过期key则删除。需要说明的是，redis不是每个100ms将所有的key检查一次，而是随机抽取进行检查(如果每隔100ms,全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。&lt;/p&gt;
&lt;p&gt;于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。&lt;/p&gt;
&lt;p&gt;如果定期删除没删除key。然后你也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用内存淘汰机制。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;内存淘汰机制：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在redis.conf中有一行配置&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;# maxmemory-policy volatile-lru    （最大内存策略）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一共6种方式：&lt;/p&gt;
&lt;p&gt;1）noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。应该没人用吧。&lt;/p&gt;

&lt;p&gt;2）allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。推荐使用，目前项目在用这种。&lt;/p&gt;

&lt;p&gt;3）allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。应该也没人用吧，你不删最少使用Key,去随机删。&lt;/p&gt;

&lt;p&gt;4）volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。这种情况一般是把redis既当缓存，又做持久化存储的时候才用。不推荐&lt;/p&gt;

&lt;p&gt;5）volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。依然不推荐&lt;/p&gt;

&lt;p&gt;6）volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。不推荐&lt;/p&gt;

&lt;h3&gt;8.redis所带来的问题以及解决方案&lt;/h3&gt;
&lt;p&gt;(一)缓存和数据库双写一致性问题&lt;/p&gt;
&lt;p&gt;     具体问题是指在更新数据库时，因为有缓存存在，会导致缓存和数据库中数据不一致的问题。&lt;/p&gt;
&lt;p&gt;一般解决方案有以下几种：&lt;/p&gt;
&lt;p&gt;（1）先更新数据库，在更新缓存。&lt;/p&gt;
&lt;p&gt;多线程情况下：&lt;/p&gt;
&lt;p&gt;  1）线程A更新了数据库&lt;br/&gt;  2）线程B更新了数据库&lt;br/&gt;  3）线程B更新了缓存&lt;br/&gt;  4）线程A更新了缓存&lt;/p&gt;
&lt;p&gt;   明显应该A先更新缓存，可B却先更新了缓存，导致了脏数据。并且如果写操作比较多，缓存还没有被读就一直在更新，就会浪费这次操作，影响性能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   因此：一般都采用这种方式解决一致性问题。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;（2）先删除缓存，在更新数据库。&lt;/p&gt;
&lt;p&gt;    多线程的案例：&lt;/p&gt;
&lt;p&gt;   1）请求A进行写操作，删除缓存&lt;br/&gt;   2）请求B查询发现缓存不存在&lt;br/&gt;   3）请求B去数据库查询得到旧值&lt;br/&gt;   4）请求B将旧值写入缓存&lt;br/&gt;   5）请求A将新值写入数据库&lt;/p&gt;
&lt;p&gt;   导致了缓存和数据库不一致。如果没有key过期作废的机制，这个脏数据就会一直存在。&lt;/p&gt;
&lt;p&gt;（3）先更新数据库，在删除缓存。&lt;/p&gt;
&lt;p&gt;   发生这种情况的案例：&lt;/p&gt;
&lt;p&gt;     1）缓存刚好失效&lt;br/&gt;     2）请求A查询数据库，得一个旧值&lt;br/&gt;     3）请求B将新值写入数据库&lt;br/&gt;     4）请求B删除缓存&lt;br/&gt;     5）请求A将查到的旧值写入缓存&lt;br/&gt; 如果发生上述情况，确实是会发生脏数据。但是概率很小。因为步骤5）一般都会在步骤3）前执行。因为读操作远快于写操作，所以这种策略比较常用。&lt;/p&gt;
&lt;p&gt;(二)缓存雪崩问题&lt;/p&gt;
&lt;p&gt;可能是并发大量请求导致缓存失效（查不到值），即缓存同一时间大面积的失效，这个时候又来了一波请求，结果请求都怼到数据库上，从而导致数据库连接异常。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;(1)给缓存的失效时间，加上一个随机值，避免集体失效。&lt;/p&gt;

&lt;p&gt;(2)使用互斥锁，但是该方案吞吐量明显下降了。&lt;/p&gt;

&lt;p&gt;(3)双缓存。我们有两个缓存，缓存A和缓存B。缓存A的失效时间为20分钟，缓存B不设失效时间。自己做缓存预热操作。然后细分以下几个小点&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;I 从缓存A读数据库，有则直接返回&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;II A没有数据，直接从B读数据，直接返回，并且异步启动一个更新线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;III 更新线程同时更新缓存A和缓存B。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(三)缓存击穿问题&lt;/p&gt;
&lt;p&gt;     缓存穿透，即黑客故意去请求缓存中不存在的数据，导致所有的请求都怼到数据库上，从而数据库连接异常。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;(1)利用互斥锁，缓存中不存在数据的时候，先去获得锁，得到锁了，再去请求数据库。没得到锁，则休眠一段时间重试&lt;/p&gt;
&lt;p&gt;(2)采用异步更新策略，无论key是否取到值，都直接返回。value值中维护一个缓存失效时间，缓存如果过期，异步起一个线程去读数据库，更新缓存。需要做缓存预热(项目启动前，先加载缓存)操作。&lt;/p&gt;
&lt;p&gt;(3)提供一个能迅速判断请求是否有效的拦截机制，比如，利用布隆过滤器，内部维护一系列合法有效的key。迅速判断出，请求所携带的Key是否合法有效。如果不合法，则直接返回。&lt;/p&gt;
&lt;p&gt;(四)缓存的并发竞争key问题&lt;/p&gt;
&lt;p&gt;多个子系统同时set同一个值，导致竞争key的问题。&lt;/p&gt;
&lt;p&gt;解决方案：&lt;/p&gt;
&lt;p&gt;(1)如果对这个key操作，不要求顺序&lt;/p&gt;
&lt;p&gt;这种情况下，准备一个分布式锁，大家去抢锁，抢到锁就做set操作即可，比较简单。&lt;/p&gt;
&lt;p&gt;(2)如果对这个key操作，要求顺序&lt;/p&gt;
&lt;p&gt;系统A key 1 {valueA  3:00}&lt;/p&gt;
&lt;p&gt;系统B key 1 {valueB  3:05}&lt;/p&gt;
&lt;p&gt;系统C key 1 {valueC  3:10}&lt;/p&gt;
&lt;p&gt;当系统抢到分布式锁的时候，还要判断时间戳，如果小与缓存中的时间戳，则不去set操作。&lt;/p&gt;

</description>
<pubDate>Thu, 20 Dec 2018 16:34:00 +0000</pubDate>
<dc:creator>Teenager</dc:creator>
<og:description>redis将会越来越流行</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yebingluo/p/10153468.html</dc:identifier>
</item>
<item>
<title>基于CBOW网络手动实现面向中文语料的word2vec - 牛云杰</title>
<link>http://www.cnblogs.com/NosenLiu/p/10153419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NosenLiu/p/10153419.html</guid>
<description>&lt;p&gt;最近在工作之余学习NLP相关的知识，对word2vec的原理进行了研究。在本篇文章中，尝试使用TensorFlow自行构建、训练出一个word2vec模型，以强化学习效果，加深理解。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;背景知识：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在深度学习实践中，传统的词汇表达方式是使用one-hot向量，其中，向量的维度等于词汇量的大小。这会导致在语料较为丰富，词汇量较大的时候，向量的维度过长，进而产生一个相当大的稀疏矩阵，占用不少内存开销，降低机器运行速度。而word2vec则为这个问题提供了一种解决方案。&lt;/p&gt;
&lt;p&gt;word2vec是一个用来产生词向量的相关模型，使用固定长度(长度较短)的词向量来代替one-hot向量，从而降低深度学习网络中的运算复杂度。其基本思想是使用skip-gram网络/cbow网络来对语料进行训练，留下其中间过程所生成的权重矩阵作为词向量表。这个词向量表是一个[词汇量大小*词向量维度]的矩阵，在使用时，可以使用one-hot向量和词向量表做矩阵乘法，提取出对应词汇的词向量以供后续使用。&lt;/p&gt;
&lt;p&gt;除了降低词向量的维度之外，word2vec可以使两个含义相近的词语用于更为接近的词向量(即两个词向量之间的欧式距离更接近)。因此在搭建语言模型时拥有更强大的逻辑相关性。&lt;/p&gt;
&lt;p&gt;现在已经有一个较为方便的word2vec模块(由Google开发)供大家使用，可以通过 pip install word2vec 指令来对其进行安装使用。为加深理解，强化学习效果，这里我们不使用该模块，尝试自己搭建预训练网络来生成word2vec词向量表。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;二&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;建模思路：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这次的建模、训练流程如下图所示，大致分为&lt;strong&gt;语料预处理&lt;/strong&gt;，&lt;strong&gt;网络搭建&lt;/strong&gt;，&lt;strong&gt;训练存储&lt;/strong&gt;三个阶段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201812/1463653-20181220235618499-1135231432.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于这次是对中文语料进行处理，因此预处理过程中较为复杂，相比处理英文语料多一个分词的步骤。此外，也没有查找到资料详细的解释word2vec是否需要对所有词汇进行训练，因此这里在预处理步骤中加入了词频统计，仅提取出10000个出现频率最高的词语作为常用词汇进行建模训练。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;语料预处理：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这里我们使用的是搜狐新闻语料库(1.5GB)来作为我们的数据源。下载地址为：http://www.sogou.com/labs/resource/cs.php&lt;/p&gt;
&lt;p&gt;首先我们要进行语料的预处理工作。搜狐新闻语料库是一个结构化的语料数据文件，其中，新闻标题位于标签&amp;lt;content-title&amp;gt;&amp;lt;/content-title&amp;gt;中，新闻内容位于标签&amp;lt;content&amp;gt;&amp;lt;/content&amp;gt;中。第一步就是要将新闻内容从标签中提取出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.1 乱码问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在提取新闻内容时，遇到了一个比较棘手的编码问题。在这个数据文件中，大部分的新闻内容是使用GBK方式进行编码的，而其中又夹杂着某些字符使用了其他编码格式，包括Unicode，ISO-8859-1等等。为解决这个问题，这里引入datadec模块来判断字符的编码格式。最初的想法是使用datadec来判断每一个字符，使用判断出的格式来对其进行解码。但实际问题是各种编码格式所占字节数长度并不一致，如GBK是双字节编码，而UTF-8则是可变长字符编码，从1-6字节不等，如果每次读取一个固定长度来datadec其编码类型，往往会判断出错。因此，在语料预处理中，读取文件的每一行，使用datadec.detect()函数来判断该行文件的编码格式，之后用对应的格式进行解码。其中遇到串码问题无法正确解析的，在decode()函数中使用errors=’ignore’参数来对该问题进行忽略，保证程序的正常运行。但最终生成的文件还是会有部分乱码，后期会使用词频统计的方式尽量将其过滤。&lt;/p&gt;
&lt;p&gt;解决乱码问题的关键代码如下(注意读文件时要使用二进制方式读取，即’rb’)：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; pure_file = open(path[:-4]+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_pure.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; with codecs.open(path,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f_corp:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; TODO 去除杂质编码&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     count = 0    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录总共处理了多少行新闻文件&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     count1 = 0   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 记录通过非GBK编码处理了多少行新闻文件&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     lines =&lt;span&gt; f_corp.readlines()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lines:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             count += 1
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 此处不设置 errors='ignore' 参数，尝试使用GBK解码，遇到解析问题时跳入except处理流程。&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             word_out = word.decode(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;gbk&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            pure_file.write(word_out)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             count1 += 1
&lt;span&gt;15&lt;/span&gt;             code_name =&lt;span&gt; chardet.detect(word)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; code_name[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;confidence&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;]&amp;gt;0.90&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 word_out = word.decode(code_name[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;encoding&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],errors=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;ignore&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                pure_file.write(word_out)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; pure_file.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在解决完乱码问题之后，我们通过匹配&amp;lt;content&amp;gt;标签来提取所需要的新闻内容，使用逻辑判断的方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; content_file = open(path[:-4]+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;_content.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; with open(path,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f_corp:
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     content_lines =&lt;span&gt; f_corp.readlines()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt;&lt;span&gt; content_lines:
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; item[:9]==&lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;content&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; len(item)&amp;gt;20:     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 需判断长度，防止有&amp;lt;content&amp;gt;&amp;lt;/content&amp;gt; 的情形出现&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;             content_file.write(item[9:-11]+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; content_file.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终获得纯净的新闻内容供后续使用，类似下图所示(可以看出仍有部分乱码，后期会通过词频统计进行处理)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201812/1463653-20181221001634512-827000403.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;3.2 分词与词频统计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拿到纯净的新闻内容后，就可以进行分词与词频统计工作。这里使用jieba分词器来完成我们的分词工作。jieba分词器是一个轻量级的中文分词模块，可以使用pip install jieba指令来进行安装。注意，由于jieba是第三方python模块，因此不能够使用conda来进行安装。&lt;/p&gt;
&lt;p&gt;考虑到后面制作训练样本时，各类词语容易与标点形成训练样本，影响训练效果。在分词之前，首先借助unicodedata模块中的category函数来去除新闻中的标点符号。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; ss &lt;span&gt;in&lt;/span&gt;&lt;span&gt; c_lines:
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     sentences = &lt;span&gt;''&lt;/span&gt;.join(ch &lt;span&gt;for&lt;/span&gt; ch &lt;span&gt;in&lt;/span&gt; ss &lt;span&gt;if&lt;/span&gt; category(ch)[0]!=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;P&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对每一行新闻通过上述语句进行扫描，排除掉其中的标点符号。&lt;/p&gt;
&lt;p&gt;之后使用jieba分词器来对语句进行切分，并存入语料文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; words = jieba.cut(sentences,cut_all=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; words = &lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;.join(words)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 使用 空格 将每一个词汇隔开 此时是str类型变量。&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; array_c.append(words[:-1])   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 去除句末的 '\n'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;切分后语料如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201812/1463653-20181221001811773-118364103.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出，在文本中仍然存在有些许乱码，这多少为后续的准确训练埋下隐患，但由各种乱码常常是孤立字符，可以通过统计常用词的方式将其进行排除。&lt;/p&gt;
&lt;p&gt;为完成词频统计工作，我们建立两个list，array_di(记录已统计的词汇)以及array_dn(记录array_di中各对应位置词汇的出现次数)。代码逻辑大致如下：挨个扫描新闻中词汇，若该词语已在存在于array_di中，则array_dn的对应位置+1；若该词汇从未出现过，则将其添加在array_di的末尾，同时array_dn的末尾添加一个1，表示这个词汇出现了一次。&lt;/p&gt;
&lt;p&gt;在分词与词频统计的过程中，会出现&lt;strong&gt;程序运行缓慢，&lt;/strong&gt;&lt;strong&gt;CPU&lt;/strong&gt;&lt;strong&gt;使用率较低&lt;/strong&gt;的情况，可以使用多进程的方法分派工作，待所有子进程完工之后，再进行拼接。具体方法在我的上一篇学习笔记中有描述。(&lt;a href=&quot;https://www.cnblogs.com/NosenLiu/p/10092892.html&quot; target=&quot;_blank&quot;&gt;学习笔记-使用多进程、多线程加速文本内容预处理&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;截取常用词的工作可以使用numpy模块的argsort()函数来对array_dn进行逆序排序，截取数值最大的10000个值所在的索引，提取出对应索引在array_di中的词汇做成字典，保存在json文件内。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; dict_list_index_last =&lt;span&gt; np.array(array_dn)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; word_frequent_list = np.argsort(-dict_list_index_last)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 降序排序，并获取其排序的索引顺序&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; d_out = dict()            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; TODO 最终常用词词典列表&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt; count =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; index &lt;span&gt;in&lt;/span&gt; word_frequent_list[:10000]:    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取10000个常用词汇&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;     d_out[array_di[index]] =&lt;span&gt; count
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;     count += 1
&lt;span&gt;8&lt;/span&gt; with open(pured_file[:-4]+&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_dict.json&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,encoding=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as f_dict:
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     json.dump(d_out, f_dict)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最终生成的.json文件如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201812/1463653-20181221001435263-368333231.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中，key为词汇的utf-8编码，value值为其对应的位置，取值从0~9999。为后续构建初始one-hot vector作好了准备。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;四&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;网络搭建：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1 模型结构设计&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据预处理工作完成以后，可以开展网络结构的设计。有两种网络模型可以用来进行word2vec的训练，分别是CBOW(Continuous Bag-of-Words Model)和skip-Gram(Continuous Skip-gram Model)。这两个网络的区别主要在于训练样本的构造。&lt;/p&gt;
&lt;p&gt;CBOW构造一个训练样本时，样本的输入为当前词汇的前n个词和后n个词，其中n表示窗口长度。例如对于句子[寒冷的 冬天 我 爱 在 学校 里 跑步]，当窗口长度为2的时候，这个句子可以分解为4个训练样本，即[[寒冷的,冬天,爱,在],[我]]，[[冬天,我,在,学校],[爱]]，[[我,爱,学校,里],[在]]，[[爱,在,里,跑步],[学校]]。其中每一个样本的前半部分为输入，后半部分为其对应的输出。&lt;/p&gt;
&lt;p&gt;而使用skip-Gram来构造训练样本时，同样取向前n个词和向后n个词作为窗口。但输入与输出的维度是相等的，即训练样本以词对的形式来展现。同样对于[寒冷的 冬天 我 爱 在 学校 里 跑步]这个句子，窗口长度n=2。&lt;/p&gt;
&lt;p&gt;输出词汇为[寒冷的]时，有[[寒冷的],[冬天]]，[[寒冷的],[我]]两个样本，&lt;/p&gt;
&lt;p&gt;输入词汇为[冬天]时，有[[冬天],[寒冷的]]，[[冬天],[我]]，[[冬天],[爱]]三个样本，&lt;/p&gt;
&lt;p&gt;输入词汇为[我]时，有[[我], [寒冷的]]，[[我], [冬天]]，[[我],[爱]]，[[我],[在]]这四个样本。&lt;/p&gt;
&lt;p&gt;以此类推，这句话一共可以生成2+3+4+4+4+4+3+2=26个样本。相对于CBOW网络来说训练内容要丰富一些。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;考虑到训练量过大会比较考验机器性能，这里选择使用CBOW&lt;/strong&gt;&lt;strong&gt;网络来完成word2vec&lt;/strong&gt;&lt;strong&gt;的训练。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在开始考虑网络的维度结构，因为选择的是CBOW网络，所以说初始的输入是2*n个词汇(n表示窗口长度)，即2*n个one-hot vector，叠加成的矩阵，由于预处理中截取的词汇量为10000，所以输入矩阵的维度为[2n*10000]；同样的，由于输出仅仅只有一个词汇，所以样本的输出是一个维度为[1*10000]的one-hot vector。这里假设目标词向量的维度为300，因此词向量表的维度为[10000*300]。输入矩阵和词向量表经过矩阵乘法相乘，可以得到一个维度为[2n*300]的矩阵，即2n个词汇经过降维所得到的较短的词向量。为了使其可以正确的和样本输出计算进行对应，需将其正确的映射到[1*10000]的维度。这里使用[1*2n]×[2n*300]×[300*10000]的方法，将其转换为[1*10000]的向量，经过softmax激活函数计算，可以同样本输出计算出loss值，并根据loss使用随机梯度下降法来对网络进行训练。&lt;/p&gt;
&lt;p&gt;网络的模型维度设计示意图如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201812/1463653-20181221000606651-1863259942.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，搭建此次网络模型需要初始化tar_weight，front_weight，back_weight三个权重矩阵。&lt;/p&gt;
&lt;p&gt;根据上面设计的网络维度结果，开始构建CBOW网络类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CBOW_Cell(object):
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;(self, window_length=5, word_dim=300&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         with tf.variable_scope(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;matrix_scope&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) as matrix_scope:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             self.tar_weight = tf.get_variable(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;tar_weight&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,shape=[10000&lt;span&gt;,word_dim],\
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 initializer=tf.truncated_normal_initializer(stddev=0.1),dtype=&lt;span&gt;tf.float32)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             self.front_weight = tf.get_variable(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;front_weight&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,shape=[1,2*&lt;span&gt;window_length],\
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 initializer=tf.truncated_normal_initializer(stddev=0.1),dtype=&lt;span&gt;tf.float32)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             self.back_weight = tf.get_variable(name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;back_weight&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,shape=[word_dim,10000&lt;span&gt;],\
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 initializer=tf.truncated_normal_initializer(stddev=0.1),dtype=&lt;span&gt;tf.float32)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            matrix_scope.reuse_variables()
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 上方为tar_weight,front_weight,back_weight 三个权重矩阵的维度设置及初始化。&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下方为偏移量权重的设置 及 变量保存。&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         self.bias = tf.Variable(tf.zeros([1,10000])) &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 偏移量，用于加到softmax前的输出上&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         self.word_dim = word_dim   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 词向量维度&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         self.window_length =&lt;span&gt; window_length    
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下方为占位符，规定好输入、输出的shape&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         self.sample_in = tf.placeholder(tf.float32, [2*window_length, 10000],name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sample_in&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         self.sample_out = tf.placeholder(tf.float32, [1, 10000],name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sample_out&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了上面提到的3个权重矩阵需要使用tf.get_variable()进行初始化，还额外的需要两个占位符sample_in，sample_out来表示训练样本输入及训练样本输出。&lt;/p&gt;
&lt;p&gt;下一步来设计前向传播函数以及损失函数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; forward_prop(self,s_input):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         step_one =&lt;span&gt; tf.matmul(s_input,self.tar_weight)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         out_vector = tf.matmul(tf.matmul(self.front_weight,step_one),self.back_weight)+&lt;span&gt;self.bias
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; out_vector
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; loss_func(self,lr=0.001&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         out_vector =&lt;span&gt; self.forward_prop(self.sample_in)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         y_pre = tf.nn.softmax(out_vector,name=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;y_pre&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         cross_entropy = tf.nn.softmax_cross_entropy_with_logits_v2(labels=self.sample_out,logits=&lt;span&gt;y_pre)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         train_op =&lt;span&gt; tf.train.GradientDescentOptimizer(lr).minimize(cross_entropy)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; y_pre,cross_entropy,train_op
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;前向传播函数forward_prop()使用占位符sample_in来计算出维度为[1,10000]的输出向量。而损失函数loss_func()通过softmax来计算出前向预测结果y_pre，并通过交叉熵函数计算出损失值，train_op是定义了随机梯度下降的权重优化计算图。在后续的程序中，我们可以通过train_op来对权重进行优化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4.2 制作训练样本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在前面分词工作结束之后，我们获得了类似[寒冷的 冬天 我 爱 在 学校 里 跑步]的语料样本。这里要根据这个语料样本，以及窗口大小n，来制作输入维度为[2n*10000]，输出维度为[1*10000]的训练样本。&lt;/p&gt;
&lt;p&gt;制作训练样本分为如下几步：①对于一条新闻来说，首先就是要确定句子的长度，如果句子包含的词语数≤2*n时，该语句无法拼接成样本，直接将其进行弃置。②对于长度充足的句子，我们取一个长度为2n+1的滑动窗口，前n个词和后n个词做成维度为[1*10000]的one-hot vector，叠加成为[2n*10000]的输入矩阵，中间词汇做成[1*10000]的one-hot vector作为样本输出。将输入和输出组成对进行输出。③为了使样本更多一些，对于一个句子开头和结束的几个词语，在目标词汇前方/后方的词语数目小于窗口长度时，顺着后方/前方窗口额外取数个词语使输入词语数目达到2n，再组成[2n*10000]的输入矩阵，将目标词汇做成one-hot vector向量作为样本输出。（第③步的样本制作方法的目标是增加训练样本数目，但该方法是否科学合理仍有待论证）&lt;/p&gt;
&lt;p&gt;为此，编写样本制作函数如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; make_samples(crop_lines_all,index_to_word,word_to_index,window_len,i):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;参数中的i指第几轮语料&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 一次处理5行语料防止内存溢出&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     crop_lines = crop_lines_all[i*5:(i+1)*5&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     sample_in_list = []     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输入样本list&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     sample_out_list = []    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 输出样本list&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; crop_lines:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         line_list = line.split(&lt;span&gt;'&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         line_list = [word &lt;span&gt;for&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt; line_list &lt;span&gt;if&lt;/span&gt; word &lt;span&gt;in&lt;/span&gt;&lt;span&gt; index_to_word]
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; len(line_list)&amp;lt;window_len*2+1:     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 如果语句词汇过少，则抛弃这条语句&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;continue&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 词语大于双倍窗口的情况下，可以开始拼接样本&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; i2 &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(line_list)):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 句子开头几个词语，前侧的词语数量不够window_len，则后侧多取一些词语攒齐2*window_len的长度&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; i2&amp;lt;window_len+1&lt;span&gt;:   
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     temp_line_list = line_list[:i2]+line_list[i2+1:2*window_len+1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    sample_in_list.append(input_matrix_calc(word_to_index,temp_line_list))
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     temp_out_sample = np.zeros(10000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     temp_out_sample[word_to_index[line_list[i2]]] = 1.0
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                    sample_out_list.append(temp_out_sample)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 句子末尾几个词语，后侧的词语数量不够window_len，则前侧多取一些词语攒齐2*window_len的长度&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;elif&lt;/span&gt; i2&amp;gt;=len(line_list)-&lt;span&gt;window_len: 
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                     temp_line_list = line_list[len(line_list)-2*window_len-1:i2]+line_list[i2+1&lt;span&gt;:]
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                    sample_in_list.append(input_matrix_calc(word_to_index,temp_line_list))
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                     temp_out_sample = np.zeros(10000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     temp_out_sample[word_to_index[line_list[i2]]] = 1.0
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                    sample_out_list.append(temp_out_sample)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 处于中间阶段，前窗口和后窗口都不越界&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     temp_line_list = line_list[i2-window_len:i2]+line_list[i2+1:i2+1+&lt;span&gt;window_len]
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                    sample_in_list.append(input_matrix_calc(word_to_index,temp_line_list))
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     temp_out_sample = np.zeros(10000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     temp_out_sample[word_to_index[line_list[i2]]] = 1.0
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                    sample_out_list.append(temp_out_sample)
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; np.array(sample_in_list),np.array(sample_out_list)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数列中的i是用于分批制作样本的参数，每次处理5行语料，来防止内存溢出，因为一个样本对应了一个巨大的稀疏矩阵，因此每次少处理一些语料比较保险。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;五&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;训练存储：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;由于需要TensorFlow的Session中完成训练的步骤，因此训练及存储的工作需要在CBOW网络类中实现。编辑功能函数train_model如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt; train_model(self, savepath,crop_lines_all,index_to_word,word_to_index,epochs=1000,lr=0.001&lt;span&gt;):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         y_pre,cross_entropy,train_op = self.loss_func(lr)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; TODO TODO TODO  这句话千万不能放到循环里面，会重复绘制计算图！！！运行很慢！！&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        with tf.Session() as sess:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;            sess.run(tf.global_variables_initializer())
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; data_num &lt;span&gt;in&lt;/span&gt; range(int(len(crop_lines_all)/5&lt;span&gt;)):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;pass&lt;/span&gt; &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 生成 in_list out_list &lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                 in_list,out_list =&lt;span&gt; make_samples(crop_lines_all,index_to_word,\
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     word_to_index,self.window_length,data_num)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt;一次20个行的处理语料样本&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;                 out_list = out_list.reshape(len(in_list),1,10000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (data_num)%50==&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;样本已处理&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,data_num*5,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,len(crop_lines_all),&lt;span&gt;'&lt;/span&gt;&lt;span&gt;行。 &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,datetime.datetime.now().strftime(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;%H:%M:%S.%f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(epochs):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt; j &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(in_list)):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                         sess.run(train_op, feed_dict=&lt;span&gt;{self.sample_in:in_list[j], \
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;                            self.sample_out:out_list[j]})
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt;下面为存储模型的代码&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;             tar_weight=self.tar_weight.eval()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个就是词向量表[10000*词向量维度]，是word2vec的最终目标&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;             front_weight=&lt;span&gt;self.front_weight.eval()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             back_weight=&lt;span&gt;self.back_weight.eval()
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             bias=&lt;span&gt;self.bias.eval()
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             word_dim=&lt;span&gt;self.word_dim
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             window_length=&lt;span&gt;self.window_length
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             np.savez(savepath,tar_weight=tar_weight,front_weight=&lt;span&gt;front_weight,\
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 back_weight=back_weight,bias=bias,word_dim=word_dim,window_length=&lt;span&gt;window_length)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;model saved in:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,savepath)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在该函数中，首先获取损失函数所返回的三个计算图：y_pre，cross_entropy，train_op。之后建立Session，初始化权重矩阵，通过制作训练样本的函数获取训练样本列表，对于每个样本分别使用train_op进行训练，优化权重矩阵。经过了数轮训练，将权重矩阵及CBOW网络类的参数存入.npz文件，这个文件以字典形式保存权重矩阵，其中tar_weight是我们最终目标的词向量表。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;六&lt;/strong&gt;&lt;strong&gt;.&lt;/strong&gt;&lt;strong&gt;实践与结果验证：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6.1 词向量表调用：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用np.load()函数便可以加载.npz文件，并获取词向量表tar_weight。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
param_dict = np.load(filepath)
tar_weight = param_dict['tar_weight']
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们也可以通过np.linalg.norm()函数来计算两个词向量之间的欧氏距离，通过下面数个词汇来观察词向量距离变化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
dist = np.linalg.norm(w2v[word_to_index['车辆']] - w2v[word_to_index['车子']]) 
print('\&quot;车辆\&quot; 与 \&quot;车子\&quot; 之间的欧式距离为：',dist,'!!')
dist = np.linalg.norm(w2v[word_to_index['机械']] - w2v[word_to_index['工业化']]) 
print('\&quot;机械\&quot; 与 \&quot;工业化\&quot; 之间的欧式距离为：',dist,'!!')
dist = np.linalg.norm(w2v[word_to_index['车辆']] - w2v[word_to_index['茶叶']]) 
print('\&quot;车辆\&quot; 与 \&quot;茶叶\&quot; 之间的欧式距离为：',dist,'!!')
dist = np.linalg.norm(w2v[word_to_index['粮食']] - w2v[word_to_index['手表']]) 
print('\&quot;粮食\&quot; 与 \&quot;手表\&quot; 之间的欧式距离为：',dist,'!!')
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;6.2 效果呈现：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最初，经过4000条新闻的训练，词汇之间的关系还比较散乱，词语之间的关系随机性较为明显（下图左）。后经过10万条新闻的训练(花了大约24小时….)，随着网络内部参数的调整，[车辆，车子]，[机械，工业化]这些意义接近的词组之间的欧式距离变小，而[车辆，茶叶][粮食，手表]这些意义较远的词汇欧氏距离变大（下图右）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201812/1463653-20181221002244770-2066909608.png&quot; alt=&quot;&quot;/&gt;           &lt;img src=&quot;https://img2018.cnblogs.com/blog/1463653/201812/1463653-20181221002252908-147585061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是训练的速度还是较慢，与谷歌提供的word2vec模块依然有较大差距。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;七&lt;/strong&gt;&lt;strong&gt;.后记&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这次自己手动实现word2vec，主要是为了巩固前期的学习成果，在实践的过程中仍然发现了不少待探究的细节。&lt;/p&gt;
&lt;p&gt;第一个处理不到位的地方就是对不常用的词的处理方法。本次实践中，我们将其做了删除操作，将非常用词排除在样本制作之外。这样做有可能会丢失部分信息。一种处理了思路是使用unknown标签来将不常用的词进行概括，作为词汇表的一部分。&lt;/p&gt;
&lt;p&gt;还有一个疑问就是对于标点符号的处理是否妥当。本次实践中，我们将语料中的标点进行了删除，之后再进行分词操作，主要目的是提高处理效率，但标点符号对语句结构的影响会被忽略。&lt;/p&gt;
&lt;p&gt;当然，这次我所构架的仅仅是一个简单的结构，还有部分优化策略没有使用，导致训练速度特别的慢。一方面原因是负采样策略的缺失。如果使用采样数为5的负采样策略的话，每一次随机梯度下降过程将会只调整6个(5个负样本和一个正样本)权重值，计算量仅相当于现有情况的万分之六，训练速度也会飞速提升。（直至网络搭建完成之后，经查阅手册才发现有个tf.nn. nce-loss()函数可以实现负采样功能，后期需要继续对其进行深入学习研究。）&lt;/p&gt;
&lt;p&gt;另一个待优化的区域是训练样本制作方面，本次实践所采用的训练样本制作方法仍较为笨拙。（该网络搭建完成后，查阅有关资料，发现tf.nn.embedding_lookup()函数可以进行查表操作，因此省去第一步one-hot向量的制作。）我在本机使用Google开发的word2vec模块，可以在几分钟之内将30多万行经过分词的语料训练完毕，而我这个手撸的CBOW网络模型训练10万行语句就消耗了24小时，其中大部分时间都消耗在了样本制作上。后续可参考word2vec的源码继续深入学习研究。&lt;/p&gt;


&lt;p&gt;参考资料：&lt;/p&gt;
&lt;p&gt;https://mp.weixin.qq.com/s/u2IumPRlzr4uHStrWXM87A&lt;/p&gt;
&lt;p&gt;http://www.dataguru.cn/article-13488-1.html&lt;/p&gt;

</description>
<pubDate>Thu, 20 Dec 2018 16:26:00 +0000</pubDate>
<dc:creator>牛云杰</dc:creator>
<og:description>最近在工作之余学习NLP相关的知识，对word2vec的原理进行了研究。在本篇文章中，尝试使用TensorFlow自行构建、训练出一个word2vec模型，以强化学习效果，加深理解。 一.背景知识：</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NosenLiu/p/10153419.html</dc:identifier>
</item>
<item>
<title>“6年的程序员还不会写委托”，问题在哪？ - 自由飞</title>
<link>http://www.cnblogs.com/freeflying/p/10153409.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeflying/p/10153409.html</guid>
<description>&lt;p&gt;今天在QQ群闲聊，一位群友的话突然引起了我的兴趣，&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;还有个6年经验老手，委托都不会写，(吐血.jpg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是我反问了一句：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;为什么你会觉得6年老手就要会写委托呢？（坏笑.jpg&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实我经常看到这种说法，但本能的我就觉得不舒服。为什么呢？我仔细的想了想，可能这么几个原因。&lt;/p&gt;
&lt;p&gt;首先，我自己就是个老码农，然后我自己知道自己其实很多东西都还不会（啊！崩了人设，是不是作死？）。我很怕有一天有人说：飞哥十年的老码农，XXX都还不会……这应该就是兔死狐悲吧？&lt;/p&gt;
&lt;p&gt;好了好了，“自黑”就到此为止，接下来开始我的自我辩护。&lt;/p&gt;
&lt;p&gt;我记得我有一个回答，&lt;a href=&quot;https://www.zhihu.com/question/62372823/answer/251915935&quot; target=&quot;_blank&quot;&gt;面试前端工作7年以上的人，总感觉他们水平一般般&lt;/a&gt;？我的回答：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span class=&quot;RichText ztext CopyrightRichText-richText&quot;&gt;换一下，让他来面试你，你就知道他有多厉害了。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抖了下机灵，收获了180个赞。&lt;/p&gt;
&lt;p&gt;这个回答第一个层次的解释可以是：你不能用别人刚好不熟悉的领域来判断一个人。&lt;/p&gt;
&lt;p&gt;但我想挖得更深一点，为什么不能呢？！&lt;/p&gt;
&lt;p&gt;我找了很久很久终于找到了，这几幅图，很可惜，原作者@itlr已经被知乎干掉了（我估计我迟早有一天也会被知乎干掉，ʅ(‾◡◝)ʃ）：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;很多人假设知识之间的关系是这样的：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img class=&quot;content_image&quot; src=&quot;https://pic4.zhimg.com/50/ac2d5ac9ad528d73ee391f929d03bbed_b.jpg&quot; alt=&quot;&quot; width=&quot;400&quot; data-caption=&quot;&quot; data-rawwidth=&quot;400&quot; data-rawheight=&quot;300&quot;/&gt;&lt;/p&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;而没有意识到，更多时候真实的关系是这样的：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img class=&quot;content_image&quot; src=&quot;https://pic2.zhimg.com/50/ae150248f6e78ef58afeb3f1d704cf20_b.jpg&quot; alt=&quot;&quot; width=&quot;381&quot; data-caption=&quot;&quot; data-rawwidth=&quot;381&quot; data-rawheight=&quot;380&quot;/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;甚至是这样的：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/49387/201812/49387-20181220231523153-2122181590.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;太特么一针见血了！&lt;/p&gt;
&lt;p&gt;其实说：“xxxx还不知道/会xxxx”的人，他们潜意识里就认为知识结构是“金字塔”或者“阶梯”形状的，同时把你不会的那一个知识点放在了“基础”级上，进而再推论出：你基础的都不会，上面的自然更不会了。这对不对呢？只能说有时候对，有时候不对。&lt;/p&gt;

&lt;p&gt;作为程序猿，理解这一点其实应该更容易，因为：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;封装&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;我不觉得6年的程序员不会写“委托”有什么问题，但我发现很多6年经验的程序员不懂得“封装”才是要命的。（好吧，夸张了一点，其实也没那么严重，只要能把功能实现一样可以领工资，不要命，O(∩_∩)O哈哈~）&lt;/p&gt;
&lt;p&gt;假如我问：面向对象的封装是干嘛用的？我估计很多同学会回答public/private之类的……&lt;/p&gt;
&lt;p&gt;但其实不是的，或者说，远不止于此。&lt;/p&gt;
&lt;p&gt;封装的作用，是屏蔽细节，或者说屏蔽复杂度。简单的说，就是让你“没有基础”“不知道原理”一样可以干活。&lt;/p&gt;
&lt;p&gt;我们可以想象，如果没有封装的话，在现代社会，从事一个任何职业，得有多累！因为任何事情，你都要从“基础”学起，要了解他的“原理”，天啊，一台汽车多少零部件多少力学原理，车间装配工人要了解这些怕是博士生都不够用。&lt;/p&gt;
&lt;p&gt;我们程序开发人员也是一样的，至少软件就只管软件，别去关心硬件，这是一个最基本的隔离（封装）……别拽你学了计算机组成原理，USB2.0和3.0的区别说得清楚不？会造不？还有说什么数据结构和算法的，天天在用的MD5加密，算法怎么实现的，为什么不可逆你说得清楚不？你不知道，这不丢人，因为你也根本不需要知道。他们被封装好了，你只需要拿过来，直接使用它，完成你的工作就OK了，这一点不丢人。&lt;/p&gt;
&lt;p&gt;我真不明白为什么程序员圈子里会有这么奇怪的一个文化：用别人封装好的东西就是丢人。每个人都想去造轮子，有必要么？看看现在前端造出来的那些铺天盖地、奇形怪状的轮子，不知道他们是怎么想的，我要是前端，我简直都要崩溃了。&lt;/p&gt;

&lt;p&gt;我记得这种观点我以前说过？就不啰嗦了，其实我写这篇博客，是因为我被刺激了，因为QQ群里的这位网友问我：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;你别告诉我你们培训不讲这个（委托）？那就太误人子弟了！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 我本来是准备要讲一讲委托的，但他这么一说，我不由得想：我就不讲了又怎么的呢？所以我的回答是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;完全可以不讲啊！&lt;/p&gt;
&lt;p&gt;直接lambda不行吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt; 我觉得这个现象很矛盾：作为学员，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一方面他们想学“最新的”技术，比如我培训的内容是ASP.NET MVC（我打算是Framework和core都讲的，甚至WebForm都会分出几个课时说一下），他们一定要问一问：“不是ASP.NET core吗？”&lt;/li&gt;
&lt;li&gt;但另一方面，他们有很强调“基础”。比如这位同学就把“委托”当成了学习Lambda的基础，觉得不学委托，Lambda就学不会或者学不好……&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;你们说，飞哥该肿么办？&lt;/p&gt;

&lt;p&gt;我觉得，很多同学，错误的理解了“基础”。比如说，委托不是Lambda的基础，委托只是Lambda“之前的”语法。&lt;/p&gt;
&lt;p&gt;我的教学原则：当你理解当前的事物很困难的时候，如果其发展历史可以帮助你理解，我就会给你讲一讲它的历史；否则，没有太大的必要，甚至有可能会有副作用。比如我刚入行的时候，理解C#里面的“引用”，很多书籍资料都会提到“指针”——那时候我不知道“指针”啊，我理解“引用”都很困难了，你还给我搅一个“指针”进来，这不是把一个复杂的问题搞得更复杂了么？但是我在讲JavaScript的时候，讲了一下这门语言的“黑历史”，很多同学给我反映：茅塞顿开，原来如此……&lt;/p&gt;
&lt;p&gt;差不多了，最后几句话：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;委托的语法很简单啊，最多十分钟就学会了。&lt;/p&gt;
&lt;p&gt;搞明白为什么要有委托、什么时候用委托才是最关键的！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要说基础，这才是基础；要说本事，这才是本事。&lt;/p&gt;

&lt;p&gt;+++++++++++++++++++&lt;/p&gt;
&lt;p&gt;惯例广告，飞哥的线下培训班“源栈”已经开班了。开业酬宾大优惠，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/49387/201812/49387-20181221000715893-73392119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;详见：&lt;a href=&quot;http://17bang.ren/Article/258&quot; target=&quot;_blank&quot;&gt;【开业优惠】一折起！真的一折起啊！！！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;不过一折早就被抢了，现在马上报名，还有六折。&lt;/p&gt;

</description>
<pubDate>Thu, 20 Dec 2018 16:09:00 +0000</pubDate>
<dc:creator>自由飞</dc:creator>
<og:description>今天在QQ群闲聊，一位群友的话突然引起了我的兴趣， 还有个6年经验老手，委托都不会写，(吐血.jpg 于是我反问了一句： 为什么你会觉得6年老手就要会写委托呢？（坏笑.jpg 其实我经常看到这种说法，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeflying/p/10153409.html</dc:identifier>
</item>
<item>
<title>【译】异步JavaScript的演变史：从回调到Promises再到Async/Await - LINJIAJUN</title>
<link>http://www.cnblogs.com/GeniusLyzh/p/10153383.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/GeniusLyzh/p/10153383.html</guid>
<description>&lt;p&gt;我最喜欢的网站之一是&lt;a href=&quot;http://www.berkshirehathaway.com/&quot;&gt;BerkshireHathaway.com&lt;/a&gt;--它简单，有效，并且自1997年推出以来一直正常运行。更值得注意的是，在过去的20年中，这个网站很有可能从未出现过错误。为什么？因为它都是静态的。它自20多年前推出以来几乎一样。如果你预先拥有所有数据，那么构建网站非常简单。不幸的是，现在大多数网站都没有。为了弥补这一点，我们发明了“模式”来处理为我们的应用程序提取外部数据。像大多数事情一样，这些模式都随着时间的推移而发生变化。在这篇文章中，我们将分析这三种最常见的模式的优缺点，模式分别是回调(Callbacks)，Promises，和Async/Await 并从历史背景谈论它们的意义和进展。&lt;/p&gt;
&lt;p&gt;让我们从这些数据获取的最初的模式开始，回调(Callbacks)&lt;/p&gt;
&lt;h2 id=&quot;回调callbacks&quot;&gt;回调（Callbacks）&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;我假设你完全不知道什么是回调。如果我假设错了，只需向下滚动一下跳过。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当我第一次学习编程时，它帮助我将函数理解为机器。这些机器可以做任何你想要的东西。他们甚至可以接受输入并返回一个值。每台机器上都有一个按钮，你可以在需要机器运行时按下该按钮，即（）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function add (x, y) {
  return x + y
}

add(2,3) // 5 - 按下按钮，执行机器&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论我按下按钮，你按下按钮，或者别人按下按钮无所谓。无论何时按下按钮，机器都将运行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function add (x, y) {
  return x + y
}

const me = add
const you = add
const someoneElse = add

me(2,3) // 5 - Press the button, run the machine.
you(2,3) // 5 - Press the button, run the machine.
someoneElse(2,3) // 5 - Press the button, run the machine.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在上面的代码，我们分配add函数，三个不同的变量，me，you，和someoneElse。重要的是要注意add我们创建的原始变量和每个变量都指向内存中的相同位置。它们在不同的名称下完全相同。所以，当我们调用me时you，或者someoneElse，就好像我们正在调用一样add函数。&lt;br/&gt;现在如果我们把add机器送到另一台机器怎么办？请记住，按下（）按钮并不重要，如果按下它，它就会运行。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function add (x, y) {
  return x + y
}

function addFive (x, addReference) {
  return addReference(x, 5) // 15 - Press the button, run the machine.
}

addFive(10, add) // 15&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你的大脑可能在这一点上有点奇怪，但这里没有新的东西。我们不是“按下按钮” add，而是add作为参数传递addFive，重命名它addReference，然后我们“按下按钮”或调用它。&lt;/p&gt;
&lt;p&gt;这突出了JavaScript语言的一些重要概念。首先，正如你可以将字符串或数字作为参数传递给函数一样，你也可以将函数的引用作为参数传递。当执行此操作时，作为参数传递的函数称为回调函数，并且将回调函数传递给的函数称为高阶函数。&lt;/p&gt;
&lt;p&gt;因为词汇很重要，所以这里的代码与重新命名的变量相同，以匹配他们演示的概念。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function add (x,y) {
  return x + y
}

function higherOrderFunction (x, callback) {
  return callback(x, 5)
}

higherOrderFunction(10, add)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种模式应该看起来很熟悉，无处不在。如果你曾经使用过任何JavaScript Array方法，那么你已经使用了回调。如果你曾经使用过lodash，那么你已经使用过回调。如果你曾经使用过jQuery，那么你已经使用了回调。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[1,2,3].map((i) =&amp;gt; i + 5)

_.filter([1,2,3,4], (n) =&amp;gt; n % 2 === 0 );

$('#btn').on('click', () =&amp;gt;
  console.log('Callbacks are everywhere')
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通常，回调有两种常见的用例。第一，我们看下.map和_.filter例子，是翻转一个值到另一个很好的抽象。我们说“嘿，这是一个数组和一个函数。来吧，根据我给你的函数给我一个新的值“。第二个，也就是我们在jQuery示例中看到的，是将函数的执行延迟到特定时间。“嘿，这是这个函数。每当btn点击具有id的元素时，请继续调用它。“这是我们将关注的第二个用例，”延迟执行函数直到特定时间“。&lt;/p&gt;
&lt;p&gt;现在我们只看了同步的例子。正如我们在本文开头所讨论的那样，我们构建的大多数应用程序都没有预先获得所需的所有数据。相反，他们需要在用户与应用程序交互时获取外部数据。我们刚刚看到回调如何成为一个很好的用例，因为它们再次允许你“延迟执行函数直到特定时间”。看看我们如何使该句子适应数据提取并不需要太多想象力。我们可以延迟函数的执行，直到我们获得所需的数据，而不是将函数的执行延迟到特定时间。这可能是最流行的例子，jQuery的方法：getJSON。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// updateUI and showError are irrelevant.
// Pretend they do what they sound like.

const id = 'tylermcginnis'

$.getJSON({
  url: `https://api.github.com/users/${id}`,
  success: updateUI,
  error: showError,
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在获得用户数据之前，我们无法更新应用的UI。那么我们该怎么办？我们说，“嘿，这是一个对象。如果请求成功，请继续调用success并传递用户的数据。如果没有，请继续调用error并传递错误对象。你不需要担心每种方法的作用，只要确保在你应该的时候调用它们。这是使用异步请求回调的完美演示。&lt;/p&gt;
&lt;p&gt;在这一点上，我们已经了解了回调是什么以及它们如何在同步和异步代码中都有用处的。我们还没有谈到的是回调的黑暗面。请看下面的代码。你能说出发生了什么吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// updateUI, showError, and getLocationURL are irrelevant.
// Pretend they do what they sound like.

const id = 'tylermcginnis'

$(&quot;#btn&quot;).on(&quot;click&quot;, () =&amp;gt; {
  $.getJSON({
    url: `https://api.github.com/users/${id}`,
    success: (user) =&amp;gt; {
      $.getJSON({
        url: getLocationURL(user.location.split(',')),
        success (weather) {
          updateUI({
            user,
            weather: weather.query.results
          })
        },
        error: showError,
      })
    },
    error: showError
  })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果觉得有帮助，你可以在这里玩&lt;a href=&quot;https://codesandbox.io/s/m587rq0lox&quot;&gt;实时版本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;请注意，我们添加了一些回调层。首先，我们说在btn点击具有id的元素之前不要运行初始的AJAX请求。单击按钮后，我们会发出第一个请求。如果该请求成功，我们会发出第二个请求。如果该请求成功，我们将调用updateUI从两个请求获得的数据的方法。无论你是否乍一看是否理解了代码，客观地说它比以前的代码更难阅读。这将我们带到“回调地狱”的主题。&lt;/p&gt;
&lt;p&gt;作为人类，我们很自然地会顺序思考。当你在嵌套回调中嵌套回调时，它会强迫你超出你自然的思维方式。当你的软件阅读方式与自然思考方式之间存在脱节时，就会发生错误。&lt;/p&gt;
&lt;p&gt;像大多数软件问题的解决方案一样，一种使“回调地狱”更容易消费的常用方法是模块化你的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function getUser(id, onSuccess, onFailure) {
  $.getJSON({
    url: `https://api.github.com/users/${id}`,
    success: onSuccess,
    error: onFailure
  })
}

function getWeather(user, onSuccess, onFailure) {
  $.getJSON({
    url: getLocationURL(user.location.split(',')),
    success: onSuccess,
    error: onFailure,
  })
}

$(&quot;#btn&quot;).on(&quot;click&quot;, () =&amp;gt; {
  getUser(&quot;tylermcginnis&quot;, (user) =&amp;gt; {
    getWeather(user, (weather) =&amp;gt; {
      updateUI({
        user,
        weather: weather.query.results
      })
    }, showError)
  }, showError)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果觉得有帮助，你可以在这里玩&lt;a href=&quot;https://codesandbox.io/s/m587rq0lox&quot;&gt;实时版本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;好的，函数名称可以帮助我们更加了解正在发生的事情，但客观上是“更好”吗？并不是很多。我们只是在回调地狱的可读性问题上加了一个创可贴。问题仍然存在，我们自然地按顺序思考，即使有额外的功能，嵌套的回调也会使我们摆脱顺序的思维方式。&lt;/p&gt;
&lt;p&gt;下一期回调与&lt;a href=&quot;https://en.wikipedia.org/wiki/Inversion_of_control&quot;&gt;控制反转&lt;/a&gt;有关。当你编写一个回调时，假设你给回调的程序是负责的，并且会在它应该的时候（并且只有当它）时调用它。实际上是将程序控制权转换为另一个程序。当您处理jQuery，lodash甚至vanilla JavaScript等库时，可以安全地假设使用正确的参数在正确的时间调用回调函数。但是，对于许多第三方库，回调函数是您与它们交互方式的接口。第三方库无论是故意的还是偶然的，都可以打破他们与你的回调互动的方式，这是完全合情合理的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function criticalFunction () {
  // It's critical that this function
  // gets called and with the correct
  // arguments.
}

thirdPartyLib(criticalFunction)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然你不是那个调用者criticalFunction，你就可以控制调用它的时间和参数。大多数时候这不是问题，但是当它出现问题时，这是一个很大的问题。&lt;/p&gt;
&lt;h2 id=&quot;promises&quot;&gt;Promises&lt;/h2&gt;
&lt;p&gt;你有没有预订去过一个繁忙的餐馆？当这种情况发生时，餐厅需要一种方法在桌子打开时与你联系。从历史上看，当你的桌子准备就绪时，他们只会取你的名字并大喊大叫。然后，自然而然地，他们决定开始变幻想。一个解决方案是，一旦桌子打开，他们就会取你的号码并给你发短信，而不是取你的名字。这使您可以超出大喊大叫的范围，但更重要的是，它允许他们随时根据需要定位你的手机广告。听起来有点熟？这应该！好吧，也许不应该。这是回调的隐喻！将你的号码提供给餐馆就像给第三方服务提供回拨功能一样。你希望餐厅在桌子打开时给您发短信，就像你一样期望第三方服务在何时以及如何表达时调用你的功能。一旦你的号码或回叫功能掌握在他们手中，您就失去了所有控制权。&lt;/p&gt;
&lt;p&gt;值得庆幸的是，存在另一种解决方案。一个设计，允许您保持所有控制。你甚至可能以前都经历过 - 这是他们给你的小嗡嗡声。你知道，这个。&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/20/167cc50c580bf116?w=946&amp;amp;h=626&amp;amp;f=png&amp;amp;s=672863&quot;/&gt;&lt;br/&gt;如果你之前从未使用过，那么这个想法很简单。他们没有取你的名字或号码，而是给你这个设备。当设备开始嗡嗡作响并发光时，你的桌子就准备好了。当你等待桌子打开时，你仍然可以做任何你想做的事，但现在你不必放弃任何东西。事实上，恰恰相反。他们必须给你一些东西。没有控制倒置。&lt;/p&gt;
&lt;p&gt;蜂鸣器始终处于三种不同状态中的一种- pending，fulfilled或rejected。&lt;/p&gt;
&lt;p&gt;pending是默认的初始状态。当他们给你蜂鸣器时，它处于这种状态。&lt;/p&gt;
&lt;p&gt;fulfilled 当蜂鸣器闪烁并且你的桌子准备就绪时蜂鸣器所在的状态。&lt;/p&gt;
&lt;p&gt;rejected当出现问题时，蜂鸣器处于状态。也许餐厅即将关闭，或者他们忘了有人在晚上出租餐厅。&lt;/p&gt;
&lt;p&gt;同样，要记住的重要一点是，你，蜂鸣器的接收器，拥有所有的控制权。如果蜂鸣器进入fulfilled，你可以去你的桌子。如果它被放入fulfilled并且你想忽略它，那么很酷，你也可以这样做。如果它被放入rejected，那很糟糕，但你可以去别的地方吃。如果没有任何事情发生并且它留在pending，你永远不会吃，但你实际上并没有任何东西。&lt;/p&gt;
&lt;p&gt;现在你已成为餐厅蜂鸣器的主人，让我们将这些知识应用到重要的事情上。&lt;/p&gt;
&lt;p&gt;如果给餐厅你的号码就像给他们一个回调功能，接收这个小小的东西就像收到所谓的“Promise”。&lt;/p&gt;
&lt;p&gt;一如既往，让我们从为什么开始吧。为什么Promises存在？它们的存在使得使异步请求更易于管理的复杂性。完全像蜂鸣器，一个 Promise可以处于三种状态之一pending，fulfilled或者rejected。与蜂鸣器不同，它们代表表示餐馆桌子状态的这些状态，它们代表异步请求的状态。&lt;/p&gt;
&lt;p&gt;如果异步请求仍在进行中，则Promise状态为pending。如果异步请求成功完成，则Promise状态将更改为fulfilled。如果异步请求失败，Promise则将更改为状态rejected。蜂鸣器比喻很有意义，对吗？&lt;/p&gt;
&lt;p&gt;既然你已经理解了Promise存在的原因以及它们可以存在的不同状态，那么我们还需要回答三个问题。&lt;br/&gt;1、如何创造一个Promise？&lt;br/&gt;2、如何改变Prommise的状态？&lt;br/&gt;3、当Promise的状态发生变化时，如何监听？&lt;/p&gt;
&lt;h3 id=&quot;如何创造一个promise&quot;&gt;如何创造一个Promise？&lt;/h3&gt;
&lt;p&gt;这个很直接。创建一个new实例Promise。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const promise = new Promise()&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何改变prommise的状态&quot;&gt;如何改变Prommise的状态？&lt;/h3&gt;
&lt;p&gt;该Promise构造函数接受一个参数，一个（回调）函数。这个函数将传递两个参数，resolve和reject。&lt;/p&gt;
&lt;p&gt;resolve - 一个允许你更改Promise状态的功能 fulfilled&lt;/p&gt;
&lt;p&gt;reject- 一个允许你更改Promise状态的功能rejected。&lt;/p&gt;
&lt;p&gt;在下面的代码中，我们使用setTimeout等待2秒然后调用resolve。这将改变Promise的状态fulfilled。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;const promise = new Promise((resolve, reject) =&amp;gt; {
  setTimeout(() =&amp;gt; {
    resolve() // Change status to 'fulfilled'
  }, 2000)
})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以通过在创建它之后立即记录promise来看到这种变化，然后resolve在调用之后大约2秒后再次记录。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2018/12/21/167cc59059e07302?w=1144&amp;amp;h=722&amp;amp;f=gif&amp;amp;s=1635795&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意Promise从pending到resolved。&lt;/p&gt;
&lt;h3 id=&quot;当promise的状态发生变化时如何监听&quot;&gt;当Promise的状态发生变化时，如何监听？&lt;/h3&gt;
&lt;p&gt;在我看来，这是最重要的问题。很酷我们知道如何创建Promise并改变其状态，但如果我们在状态发生变化后不知道如何做任何事情，那就毫无价值。&lt;/p&gt;
&lt;p&gt;我们还没有谈到的一件事是Promise实际上是什么。当你创建一个时new Promise，你真的只是创建一个普通的旧JavaScript对象。该对象可以调用两个方法then，和catch。这是关键。当promise的状态更改fulfilled为时，.then将调用传递给的函数。当promise的状态更改rejected为时，.catch将调用传递给的函数。这意味着一旦你创建了一个promise，如果异步请求成功，你将传递你想要运行的函数.then。如果异步请求失败，你将传递要运行的功能.catch。&lt;/p&gt;
&lt;p&gt;我们来看一个例子吧。我们将setTimeout再次使用fulfilled在两秒钟（2000毫秒）之后将Promise的状态更改为。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function onSuccess () {
  console.log('Success!')
}

function onError () {
  console.log('💩')
}

const promise = new Promise((resolve, reject) =&amp;gt; {
  setTimeout(() =&amp;gt; {
    resolve()
  }, 2000)
})

promise.then(onSuccess)
promise.catch(onError)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果运行上面的代码，你会注意到大约2秒后，您将在控制台中看到“成功！”。这种情况再次发生的原因是两件事。首先，当我们创建了promise时，我们resolve在〜2000毫秒之后调用- 这改变了promise的状态fulfilled。其次，我们将onSuccess函数传递给promises的.then方法。通过这样做，我们告诉Promise，onSuccess当Promise的状态改变为fulfilled〜2000毫秒后它所做的时，调用。&lt;/p&gt;
&lt;p&gt;现在让我们假装发生了一些不好的事情，我们想要改变Promise的状态rejected。resolve我们打电话，而不是打电话reject。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function onSuccess () {
  console.log('Success!')
}

function onError () {
  console.log('💩')
}

const promise = new Promise((resolve, reject) =&amp;gt; {
  setTimeout(() =&amp;gt; {
    reject()
  }, 2000)
})

promise.then(onSuccess)
promise.catch(onError)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在这一次而不是onSuccess被调用的onError函数，因为我们调用了函数reject。&lt;/p&gt;
&lt;p&gt;你已经了解了Promise API的方法，让我们开始查看一些真实的代码。&lt;/p&gt;
&lt;p&gt;还记得我们之前看到的最后一个异步回调示例吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function getUser(id, onSuccess, onFailure) {
  $.getJSON({
    url: `https://api.github.com/users/${id}`,
    success: onSuccess,
    error: onFailure
  })
}

function getWeather(user, onSuccess, onFailure) {
  $.getJSON({
    url: getLocationURL(user.location.split(',')),
    success: onSuccess,
    error: onFailure,
  })
}

$(&quot;#btn&quot;).on(&quot;click&quot;, () =&amp;gt; {
  getUser(&quot;tylermcginnis&quot;, (user) =&amp;gt; {
    getWeather(user, (weather) =&amp;gt; {
      updateUI({
        user,
        weather: weather.query.results
      })
    }, showError)
  }, showError)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以在这里使用Promise API而不是使用回调吗？如果我们将AJAX请求包含在promise中，该怎么办？然后我们可以简单地resolve或reject取决于请求的方式。让我们开始吧getUser。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function getUser(id) {
  return new Promise((resolve, reject) =&amp;gt; {
    $.getJSON({
      url: `https://api.github.com/users/${id}`,
      success: resolve,
      error: reject
    })
  })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很好。请注意，参数getUser已更改。而不是接收id，onSuccess和onFailure，它只是接收id。不再需要那些其他两个回调函数，因为我们不再反转控制。相反，我们使用Promise resolve和reject函数。resolve如果请求成功reject将被调用，如果有错误将被调用。&lt;/p&gt;
&lt;p&gt;接下来让我们重构一下getWeather。我们将遵循相同的策略。我们将使用使用resolve和reject而不是接收onSuccess和onFailure回调函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function getWeather(user) {
  return new Promise((resolve, reject) =&amp;gt; {
    $.getJSON({
      url: getLocationURL(user.location.split(',')),
      success: resolve,
      error: reject,
    })
  })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看起来不错。现在我们需要更新的最后一件事是我们的点击处理程序。请记住，这是我们想要采取的流程。&lt;/p&gt;
&lt;p&gt;从Github API获取用户的信息。&lt;br/&gt;1、使用用户的位置从Yahoo Weather API获取他们的天气。&lt;br/&gt;2、使用用户信息及其天气更新UI。&lt;br/&gt;3、让我们从＃1开始 - 从Github API获取用户的信息。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#btn&quot;).on(&quot;click&quot;, () =&amp;gt; {
  const userPromise = getUser('tylermcginnis')

  userPromise.then((user) =&amp;gt; {

  })

  userPromise.catch(showError)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，现在它不是getUser接受两个回调函数，而是返回一个我们可以调用.then和.catch启用的Promise。如果.then被调用，将使用用户的信息调用它。如果.catch被调用，它将被调用错误。&lt;/p&gt;
&lt;p&gt;接下来让我们做＃2 - 使用用户的位置来获取他们的天气。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#btn&quot;).on(&quot;click&quot;, () =&amp;gt; {
  const userPromise = getUser('tylermcginnis')

  userPromise.then((user) =&amp;gt; {
    const weatherPromise = getWeather(user)
    weatherPromise.then((weather) =&amp;gt; {

    })

    weatherPromise.catch(showError)
  })

  userPromise.catch(showError)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意，我们遵循我们在＃1中完全相同的模式，但现在我们调用getWeather它传递给user我们的对象userPromise。&lt;/p&gt;
&lt;p&gt;最后，＃3 - 使用用户信息及其天气更新UI。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#btn&quot;).on(&quot;click&quot;, () =&amp;gt; {
  const userPromise = getUser('tylermcginnis')

  userPromise.then((user) =&amp;gt; {
    const weatherPromise = getWeather(user)
    weatherPromise.then((weather) =&amp;gt; {
      updateUI({
        user,
        weather: weather.query.results
      })
    })

    weatherPromise.catch(showError)
  })

  userPromise.catch(showError)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是你可以使用的&lt;a href=&quot;https://codesandbox.io/s/l9xrjq88p7&quot;&gt;完整代码&lt;/a&gt;。&lt;br/&gt;新代码看起来更好，但我们仍然可以做出一些改进。在我们做出这些改进之前，你需要知道Promise到两个功能：链式调用和将参数从resolve传递到then。&lt;/p&gt;
&lt;h2 id=&quot;链式调用&quot;&gt;链式调用&lt;/h2&gt;
&lt;p&gt;.then和.catch都会返回一个新的Promise。这似乎是一个小细节，但它很重要，因为它意味着Promise可以被链式调用。&lt;/p&gt;
&lt;p&gt;在下面的示例中，我们调用getPromise它返回一个将在至少2000毫秒内解析的promise。从那里，因为.then将返回一个Promise，我们可以继续将我们的.thens链接在一起，直到我们抛出一个new Error被该.catch方法捕获的东西。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function getPromise () {
  return new Promise((resolve) =&amp;gt; {
    setTimeout(resolve, 2000)
  })
}

function logA () {
  console.log('A')
}

function logB () {
  console.log('B')
}

function logCAndThrow () {
  console.log('C')

  throw new Error()
}

function catchError () {
  console.log('Error!')
}

getPromise()
  .then(logA) // A
  .then(logB) // B
  .then(logCAndThrow) // C
  .catch(catchError) // Error!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很酷，但为什么这么重要？请记住，在回调部分，我们谈到了回调的一个缺点，即它们会迫使你摆脱自然，顺序的思维方式。当你将Promise链接在一起时，它并不会强迫你摆脱那种自然的思维方式，因为链式调用Promise是连续的。getPromise runs then logA runs then logB runs then...。&lt;/p&gt;
&lt;p&gt;这样你就可以看到另一个示例，这是使用fetchAPI 时的常见用例。fetch将返回一个将通过HTTP响应解决的Promise。要获得实际的JSON，你需要调用.json。由于链接，我们可以按顺序思考这个问题。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fetch('/api/user.json')
  .then((response) =&amp;gt; response.json())
  .then((user) =&amp;gt; {
    // user is now ready to go.
  })&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们知道有关链式调用，让我们来重构我们早期getUser/ getWeather代码并且使用它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function getUser(id) {
  return new Promise((resolve, reject) =&amp;gt; {
    $.getJSON({
      url: `https://api.github.com/users/${id}`,
      success: resolve,
      error: reject
    })
  })
}

function getWeather(user) {
  return new Promise((resolve, reject) =&amp;gt; {
    $.getJSON({
      url: getLocationURL(user.location.split(',')),
      success: resolve,
      error: reject,
    })
  })
}

$(&quot;#btn&quot;).on(&quot;click&quot;, () =&amp;gt; {
  getUser(&quot;tylermcginnis&quot;)
    .then(getWeather)
    .then((weather) =&amp;gt; {
      // We need both the user and the weather here.
      // Right now we just have the weather
      updateUI() // ????
    })
    .catch(showError)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它看起来好多了，但现在我们遇到了一个问题。你能发现它吗？在第二个.then我们要调用updateUI。问题是，我们需要通过updateUI这两个user和weather。目前我们如何设置，我们只收到weather，而不是user。不知何故，我们需要找出一种方法来使它成为一个Promise，即getWeather使用user和来解决回报weather。&lt;/p&gt;
&lt;p&gt;这是关键。resolve只是一个功能。您传递给它的任何参数都将传递给给定的函数.then。这是什么意思是，里面getWeather，如果我们调用resolve我们自己，我们可以通过它weather和user。然后，.then我们链中的第二个方法将同时接收user和weather作为参数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function getWeather(user) {
  return new Promise((resolve, reject) =&amp;gt; {
    $.getJSON({
      url: getLocationURL(user.location.split(',')),
      success(weather) {
        resolve({ user, weather: weather.query.results })
      },
      error: reject,
    })
  })
}

$(&quot;#btn&quot;).on(&quot;click&quot;, () =&amp;gt; {
  getUser(&quot;tylermcginnis&quot;)
    .then(getWeather)
    .then((data) =&amp;gt; {
      // Now, data is an object with a
      // &quot;weather&quot; property and a &quot;user&quot; property.

      updateUI(data)
    })
    .catch(showError)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;你可以在这里玩&lt;a href=&quot;https://codesandbox.io/s/9lkl75vqxw&quot;&gt;最终的代码&lt;/a&gt;&lt;br/&gt;它位于我们的点击处理程序中，与回调相比，你真正看到了Promise的力量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Callbacks 🚫
getUser(&quot;tylermcginnis&quot;, (user) =&amp;gt; {
  getWeather(user, (weather) =&amp;gt; {
    updateUI({
      user,
      weather: weather.query.results
    })
  }, showError)
}, showError)


// Promises ✅
getUser(&quot;tylermcginnis&quot;)
  .then(getWeather)
  .then((data) =&amp;gt; updateUI(data))
  .catch(showError);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遵循这种逻辑感觉很自然，因为它是我们习惯于按顺序思考的方式。getUser then getWeather then update the UI with the data。&lt;br/&gt;现在很明显，promises会大大提高异步代码的可读性，但有没有办法让它变得更好？假设你是TC39委员会成员，并且你有能力为JavaScript语言添加新功能。你将采取哪些步骤来改进此代码？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#btn&quot;).on(&quot;click&quot;, () =&amp;gt; {
  getUser(&quot;tylermcginnis&quot;)
    .then(getWeather)
    .then((data) =&amp;gt; updateUI(data))
    .catch(showError)
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如我们所讨论的那样，代码读得非常好。正如我们的大脑工作一样，它是按顺序排列的。我们遇到的一个问题是我们需要将data（users）从第一个异步请求一直到最后一个.then。这不是什么大不了的事，但它让我们改变了我们的getWeather功能，也传递了它users。如果我们编写异步代码的方式与编写同步代码的方式相同怎么办？如果我们这样做了，那么这个问题就会彻底消失，而且它仍会按顺序读取。这是一个想法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#btn&quot;).on(&quot;click&quot;, () =&amp;gt; {
  const user = getUser('tylermcginnis')
  const weather = getWeather(user)

  updateUI({
    user,
    weather,
  })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好吧，那会很好。我们的异步代码看起来就像我们的同步代码。我们的大脑没有额外的步骤需要采取，因为我们已经非常熟悉这种思维方式。可悲的是，这显然是行不通的。如你所知，如果我们要运行上面的代码，user并且weather两者都只是Promise，因为那是什么getUser并getWeather返回。但请记住，我们正在使用TC39。我们有能力为我们想要的语言添加任何功能。按原样，这段代码在制作工作时会非常棘手。我们必须以某种方式教JavaScript引擎，以便了解异步函数调用和常规的同步函数调用之间的区别。让我们在代码中添加一些关键字，以便在引擎上更轻松。&lt;/p&gt;
&lt;p&gt;首先，让我们在主函数本身添加一个关键字。这可以让引擎知道这个函数内部我们将要进行一些异步函数调用。让我们用async它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#btn&quot;).on(&quot;click&quot;, async () =&amp;gt; {
  const user = getUser('tylermcginnis')
  const weather = getWeather(user)

  updateUI({
    user,
    weather,
  })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;酷。这看似合理。接下来让我们添加另一个关键字，让引擎确切知道被调用的函数何时是异步的并且将返回一个promise。我们来使用await。如同，“嘿发动机。此函数是异步的并返回一个promise。不要像往常一样继续，继续“等待”Promise的最终的值并在继续之前将其返回“。与这两个我们的新的async和await在游戏中的关键字，我们的新的代码看起来像这样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#btn&quot;).on(&quot;click&quot;, async () =&amp;gt; {
  const user = await getUser('tylermcginnis')
  const weather = await getWeather(user.location)

  updateUI({
    user,
    weather,
  })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非常漂亮。我们已经发明了一种合理的方法来使我们的异步代码看起来和行为就像它是同步的一样。现在下一步是让TC39上的某个人相信这是一个好主意。幸运的是，正如你现在可能已经猜到的那样，我们不需要做任何令人信服的事情，因为这个功能已经成为JavaScript的一部分而且它被称为Async/Await。&lt;/p&gt;
&lt;p&gt;不相信我？这是我们的&lt;a href=&quot;https://codesandbox.io/s/00w10o19xn&quot;&gt;实时代码&lt;/a&gt;，现在我们已经添加了Async / Await。随意玩它。&lt;/p&gt;
&lt;h2 id=&quot;异步函数返回一个promise&quot;&gt;异步函数返回一个promise&lt;/h2&gt;
&lt;p&gt;既然您已经看到了Async / Await的好处，那么让我们讨论一些重要的细节，这些细节很重要。首先，无论何时添加async到函数，该函数都将隐式返回一个promise。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;async function getPromise(){}

const promise = getPromise()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;即使getPromise字面上是空的，它仍然会返回一个Promise，因为它是一个async函数。&lt;/p&gt;
&lt;p&gt;如果async函数返回一个值，那么该值也将包含在一个promise中。这意味着你将不得不使用.then它来访问它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;async function add (x, y) {
  return x + y
}

add(2,3).then((result) =&amp;gt; {
  console.log(result) // 5
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;没有异步的等待很糟糕&quot;&gt;没有异步的等待很糟糕&lt;/h2&gt;
&lt;p&gt;如果你尝试await在非函数内部使用关键字async，则会出现错误。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#btn&quot;).on(&quot;click&quot;, () =&amp;gt; {
  const user = await getUser('tylermcginnis') // SyntaxError: await is a reserved word
  const weather = await getWeather(user.location) // SyntaxError: await is a reserved word

  updateUI({
    user,
    weather,
  })
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是我对此的看法。添加async到函数时，它会执行两项操作。它使得函数本身返回（或包装返回的内容）一个Promise并使它可以await在其内部使用&lt;/p&gt;
&lt;h2 id=&quot;错误处理&quot;&gt;错误处理&lt;/h2&gt;
&lt;p&gt;你可能已经注意到我们有点作弊。在我们的原始代码中，我们有一种方法可以捕获任何错误.catch。当我们切换到Async / Await时，我们删除了该代码。使用Async / Await，最常见的方法是将代码包装在一个try/catch块中以便能够捕获错误。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$(&quot;#btn&quot;).on(&quot;click&quot;, async () =&amp;gt; {
  try {
    const user = await getUser('tylermcginnis')
    const weather = await getWeather(user.location)

    updateUI({
      user,
      weather,
    })
  } catch (e) {
    showError(e)
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(完)&lt;/p&gt;
&lt;h2 id=&quot;链接&quot;&gt;链接&lt;/h2&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;p&gt;以上译文仅用于学习交流，水平有限，难免有错误之处，敬请指正。&lt;/p&gt;
</description>
<pubDate>Thu, 20 Dec 2018 16:02:00 +0000</pubDate>
<dc:creator>LINJIAJUN</dc:creator>
<og:description>我最喜欢的网站之一是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/GeniusLyzh/p/10153383.html</dc:identifier>
</item>
<item>
<title>Ubuntu中网络配置interfaces与界面网络配置NetworkManager - Jerry_Jin</title>
<link>http://www.cnblogs.com/jins-note/p/10153374.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jins-note/p/10153374.html</guid>
<description>&lt;h2&gt;【Server版本】&lt;/h2&gt;
&lt;p&gt;在Ubuntu Server版本中，因为只存有命令行模式，所以要想进行网络参数设置，只能通过修改 &lt;span class=&quot;cnblogs_code&quot;&gt;/etc/network/interfaces&lt;/span&gt; 。具体设置方法如下：&lt;/p&gt;
&lt;p&gt;(1) Ubuntu Server 修改 IP地址&lt;/p&gt;
&lt;p&gt;打开 &lt;span class=&quot;cnblogs_code&quot;&gt;/etc/network/interfaces&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; vim /etc/network/interfaces
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;加入以下语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;auto eth0

iface eth0 inet static

address xxx.xxx.xxx.xxx #IP地址

netmask xxx.xxx.xxx.xxx #子网掩码

gateway xxx.xxx.xxx.xxx #网关&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(2) Ubuntu Server 修改 DNS&lt;/p&gt;
&lt;p&gt;打开 &lt;span class=&quot;cnblogs_code&quot;&gt;/etc/resolv.conf&lt;/span&gt; &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; vim/etc/resolv.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;改为如下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;searchlocaldomain #如果本Server为DNS服务器，可以加上这一句，如果不是，可以不加
nameserver 172.&lt;/span&gt;&lt;span&gt;16.3&lt;/span&gt;.&lt;span&gt;4&lt;/span&gt;&lt;span&gt; #希望修改成的DNS
nameserver 172.&lt;/span&gt;&lt;span&gt;16.3&lt;/span&gt;.&lt;span&gt;3&lt;/span&gt; #希望修改成的DNS
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;(3) Ubuntu Server 最后一步，也是最重要的一步&lt;/p&gt;
&lt;p&gt;　　在rc.local里加入这个重启网络配置的命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; /etc/init.d/networking restart
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;【Desktop版本】&lt;/h2&gt;
&lt;p&gt;在Desktop版本中，除了可以修改 &lt;span class=&quot;cnblogs_code&quot;&gt;/etc/network/interfaces&lt;/span&gt; 来进行配置以外；还可以直接在network-manager中配置。通过 interfaces修改的方法参照Server版本。network-manager的配置和直观，按照提示一步一步操作即可，有兴趣的朋友，可以自行Google或者Baidu。&lt;/p&gt;
&lt;p&gt;但如果修改了interfaces，又配置了network-manager（以下简称nm），你就会发现出现了一些莫名其妙的问题：&lt;/p&gt;
&lt;p&gt;1，interfaces和 nm中的网络设置不一样，系统实际的IP是哪个？&lt;/p&gt;
&lt;p&gt;2，有时候莫名其妙的，界面右上角的网络连接图标就丢失了。&lt;/p&gt;
&lt;p&gt;3，明明在nm中配置了正确的网络设置，为什么就上不了网呢？&lt;/p&gt;
&lt;p&gt;其实，我们要知道 interfaces和 nm之间的关系，这些问题就不难解释了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先，当系统内没有第三方网络管理工具（比如nm）时，系统默认使用interfaces文件内的参数进行网络配置。（就像Server版本一样）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接着，当系统内安装了 nm之后，nm默认接管了系统的网络配置，使用nm 自己的网络配置参数来进行配置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;但是，如果用户在安装nm之后（Desktop版本默认安装了nm），自己手动修改了interfaces 文件，那nm 就自动停止对系统网络的管理，系统改使用interfaces 文件内的参数进行网络配置。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此时，再去修改nm 内的参数，不影响系统实际的网络配置。若要让nm 内的配置生效，必须重新启用nm 接管系统的网络配置。&lt;/strong&gt;&lt;/p&gt;


&lt;p&gt;现在知道了两者之间的工作关系，再看上面的三个问题：&lt;/p&gt;
&lt;p&gt;1，要看nm是否接管，如果没有接管，系统实际的IP设置以interfaces 中的为准。反之，以nm 中的为准。&lt;/p&gt;
&lt;p&gt;2，当nm 停止接管的时候，网络连接图标就丢失了。&lt;/p&gt;
&lt;p&gt;3，同样是接管的问题。&lt;/p&gt;
&lt;p&gt;如果用户希望在Desktop版本中，直接使用interfaces 进行网络配置，那可以关闭network-manager：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/etc/init.d/network-manager stop
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;vi /etc/network/interfaces修改之后&lt;/p&gt;
&lt;p&gt;确保/etc/NetworkManager/Network-manager.conf内的&lt;span&gt;managed=false&lt;/span&gt;(系统默认是false，但是你更改过的话需要改这里)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
/etc/init.d/networking restart
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果希望能继续使用nm 来进行网络配置，则需要进行如下操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; service network-&lt;span&gt;manager stop # 停止 nm服务
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; &lt;span&gt;rm &lt;/span&gt;/var/lib/NetworkManager/&lt;span&gt;NetworkManager.state # 移除nm 的状态文件
&lt;/span&gt;&lt;span&gt;sudo&lt;/span&gt; gedit /etc/NetworkManager/nm-system-settings.conf # 打开nm 的配置文件
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;##里面有一行：&lt;span&gt;managed=true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;## 如果你手工改过 &lt;span class=&quot;cnblogs_code&quot;&gt;/etc/network/interfaces&lt;/span&gt; ，nm会自己把这行改成：managed=false(这里应该默认就是false)&lt;/p&gt;
&lt;p&gt;## 将false 修改成true&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;sudo&lt;/span&gt; servicenetwork-manager start
&lt;/pre&gt;&lt;/div&gt;






</description>
<pubDate>Thu, 20 Dec 2018 15:59:00 +0000</pubDate>
<dc:creator>Jerry_Jin</dc:creator>
<og:description>【Server版本】 在Ubuntu Server版本中，因为只存有命令行模式，所以要想进行网络参数设置，只能通过修改 /etc/network/interfaces 。具体设置方</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jins-note/p/10153374.html</dc:identifier>
</item>
<item>
<title>2019年React学习路线图 - 燕十三丶</title>
<link>http://www.cnblogs.com/Yanss/p/10153337.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yanss/p/10153337.html</guid>
<description>&lt;p&gt;&lt;strong&gt;作者｜javinpaul&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;译者｜无明&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;之前我们已经介绍了 &lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&amp;amp;mid=2247490087&amp;amp;idx=1&amp;amp;sn=fb16b7826416244642cdab69a52848c0&amp;amp;chksm=f951af64ce262672982f1896976f594589925a0b2730801715247ae40d7ee06c2960d6b6a338&amp;amp;token=1582750074&amp;amp;lang=zh_CN&amp;amp;scene=21#wechat_redirect&quot; data-linktype=&quot;2&quot;&gt;2019 年 Vue 学习路线图&lt;/a&gt;，而 React 作为当前应用最广泛的前端框架，在 Facebook 的支持下，近年来实现了飞越式的发展，我们将在下文中介绍 2019 年 React 学习路线图，希望给想学 React 的开发者一些借鉴。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;下图是2018 年的 React 路线图，它非常全面，2018 年剩下的时间可能不够你学会所有这些，但不要担心，所有的技术在 2019 年仍然有效。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1563071/201812/1563071-20181220234925237-1537427831.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;图片来源：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;https://github.com/adam-golab/react-developer-roadmap/blob/master/roadmap.png&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 基础知识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;不管你要学习哪个 Web 开发框架或库，都必须掌握基础知识，如 HTML、CSS 和 JavaScript，这三个是 Web 开发的三大支柱。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; HTML&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HTML 是 Web 开发人员最重要的技能之一，因为它为网页提供了基本结构。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; CSS&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;CSS 用于设置网页样式，让网页看起来更好看。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; JavaScript&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JavaScript 让网页具备交互性。React 是基于 JavaScript 的，因此在学习 React 之前，你应该先了解 JavaScript。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 通用的开发技能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无论你是前端开发人员还是后端开发人员，甚至是全栈工程师，都必须了解一些能够让你在编程世界中生存下来的通用开发技能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 学习 GIT&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你必须在 2018 年完全了解 Git。尝试在 GitHub 上创建一些存储库，与其他人共享你的代码，并学习如何在你喜欢的 IDE 中克隆 Github 上的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 了解 HTTP(S) 协议&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你想成为一名 Web 开发人员，那么了解 HTTP 绝对是有必要的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我不是要你去阅读 HTTP(S) 规范，但你至少应该熟悉常见的 HTTP 请求方法，如 GET、POST、PUT、PATCH、DELETE、OPTIONS 以及 HTTP/HTTPS 的工作原理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 学习终端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然前端开发人员学习 Linux 或终端并不是强制性的，但我强烈建议你熟悉以下终端，了解如何配置你的 shell（bash、zsh、csh）等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 算法和数据结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好吧，这又是一个通用编程技能，成为 React 开发者不一定需要了解这些，但要成为真正的程序员，这是必备技能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 学习设计模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;就像算法和数据结构一样，成为 React 开发者并不一定要学习设计模式，但学好设计模式会让你变得更好。了解设计模式将帮你找到能够经受住时间考验的解决方案。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 学习 React&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你必须学好 React 才能成为一名 React 开发者。学习 React 最好的资源是它的官方网站，但作为初学者，它对你来说可能有点难。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.1 学习构建工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你想成为一名专业的 React 开发者，那么你应该花一些时间熟悉一下你将作为 Web 开发者需要使用的工具，比如构建工具、单元测试工具、调试工具等。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是路线图中列出的构建工具：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;包管理器：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;npm&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;yarn&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;pnpm&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;任务执行器&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;npm 脚本&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;gulp&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;WebPack&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Rollup&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Parcel&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;顺便说一句，并非要学习所有这些工具，对于初学者来说，学习 npm 和 Webpack 应该足够了。在你对 Web 开发和 React 生态系统有了更多的了解后，你就可以学习其他工具。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.2 样式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你的目标是成为 React 开发者，了解一些样式相关的知识只会有益无害。路线图中提到了很多 CSS 相关的东西，比如 CSS 预处理器、CSS 框架、CSS 架构和 JS 中的 CSS。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我建议你至少学习一下 Bootstrap，这是你经常会用到的 CSS 框架。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你想进一步学习 bootstrap，也可以学习 Materialise 或 Material UI。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.3 状态管理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是 React 开发者应该关注的另一个重要领域。路线图中提到了以下一些需要掌握的概念和框架：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果东西太多，我建议你只关注 Redux。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.4 Type Checker&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于 JavaScript 不是一种强类型语言，因此编译器不会捕获那些与类型相关的错误。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随着应用程序的增长，你可以通过类型检查捕获大量错误，尤其是如果你可以使用 Flow 或 TypeScript 等 JavaScript 扩展对整个应用程序进行类型检查。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React 也提供了一些内置的类型检查功能，可以用它们帮你尽早发现 bug。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于 Angular 也使用了 TypeScript，我认为可以同时学习 JavaScript 和 TypeScript。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.5 Form Helper&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除了 Type Checker 之外，还可以学习像 Redux Form 这样的 Form Helper，它提供了在 Redux 中管理表单状态的最佳方法。除了 Redux Form 之外，还有 Formik、Formsy 和 Final。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.6 路由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组件是 React 声明性编程模型的核心，而路由组件是应用程序的重要组成部分。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React Router 提供了一组导航组件，这些组件可以通过声明的方式与你的应用程序组合在一起。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;除了 React Router 之外，你还可以看看 Router 5 和 Redux-First Router。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.7 API 客户端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在今天的世界中，你很少会构建独立的 GUI，相反，你将有更多机会使用 REST 和 GraphQL 等 API 构建与其他应用程序发生交互的东西。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得庆幸的是，React 开发者可以使用很多 API 客户端：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;REST&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Fetch&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SuperAgent&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;axios&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;GraphQL&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Apollo&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Relay&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;urql&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Apollo 客户端是我的最爱，它提供了一种使用 GraphQL 构建客户端应用程序的简便方法。Apollo 可以帮你快速构建使用 GraphQL 获取数据的 UI，并可以与任意 JavaScript 前端一起使用。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.8 辅助库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这些库可以让你的工作变得更轻松。React 开发人员可以使用很多辅助库，如下所示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Lodash&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Moment&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;classnames&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Numeral&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;RxJS&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Ramda&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;这些不一定都要学，路线图中的 Lodash、Moment 和 Classnames 是用黄色标注的，所以应该先从它们开始学习。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.9 测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;测试是 React 开发者的一项重要技能，但经常被忽视，如果你想在竞争中保持领先，就要学习一些用于测试的库。这些库可用于单元测试、集成测试和端到端测试。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是路线图中提到的库：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 单元测试&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Jest&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Enzyme&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sinon&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Mocha&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Chai&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;AVA&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Tape&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; 端到端测试&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Selenium, Webdriver&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cypress&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Puppeteer&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cucumber.js&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Nightwatch.js&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt; 集成测试&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你可以学习你想学习的库，但建议一定要学习 Jest 和 Enzyme。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.10 国际化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是前端开发的另一个重要主题。你可能需要支持日本、中国、西班牙和其他欧洲国家的本地 GUI 版本。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路线图中建议你学习以下技术，它们都很好理解：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;React Intl&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;React i18next&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;这两个库都提供了 React 组件和 API 来格式化日期、数字和字符串，包括复数和处理翻译。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.11 服务器端渲染&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你可能会想，服务器端渲染和客户端渲染之间有什么区别。在使用客户端渲染时，你的浏览器会下载一个最小的 HTML 页面，然后通过 JavaScript 并将内容填充到页面中。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在使用服务器端渲染时，React 组件是在服务器上进行渲染的，将输出的 HTML 内容传到客户端或浏览器。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路线图推荐了以下的服务器端渲染：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Next.js&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;After.js&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Rogue&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;不过我建议学习 Next.js 应该足够了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.12 静态站点生成器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gatsby.js 是一个现代静态站点生成器。你可以使用 Gatsby 创建个性化的登录网站体验。它将你的数据与 JavaScript 相结合，并创建格式良好的 HTML 内容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 3.13 后端框架集成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React on Rails 将 Rails 与 Facebook 的 React 前端框架（服务器渲染）集成在一起。它提供了服务器渲染，通常用于 SEO 爬虫索引和 UX。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 移动端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;React Native 正迅速成为使用 JavaScript 开发具有原生外观的移动应用程序的标准方法。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路线图中建议你学习以下库：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;React Native&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Cordova/PhoneGap&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;但我认为只要学习 React Native 就足够了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 桌面端&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;还有一些基于 React 的框架可用于构建像 React Native Windows 这样的桌面 GUI，让你可以使用 React 构建原生 UWP 和 WPF 应用程序。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;路线图建议使用以下几个库：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Proton Native&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Electron&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;React Native Windows&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;它们都是进阶的内容，如果你已经掌握了 React，可以看一下它们。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. 虚拟现实&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果你对构建基于虚拟现实的应用程序感兴趣，还可以了解以下像 React 360 这样的框架，让你可以通过 React 开发 VR 体验。如果你对这个领域感兴趣，可以进一步了解 React 360。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;英文原文：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;https://hackernoon.com/the-2018-react-js-roadmap-4d0a43814c02&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 20 Dec 2018 15:50:00 +0000</pubDate>
<dc:creator>燕十三丶</dc:creator>
<og:description>作者｜javinpaul 译者｜无明 之前我们已经介绍了 2019 年 Vue 学习路线图，而 React 作为当前应用最广泛的前端框架，在 Facebook 的支持下，近年来实现了飞越式的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yanss/p/10153337.html</dc:identifier>
</item>
</channel>
</rss>