<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>树莓派开发笔记(十一)：蓝牙的使用，BlueZ协议（双树莓探测rssi并通过蓝牙互传获取的rssi信号强度） - 红胖子(红模仿)</title>
<link>http://www.cnblogs.com/qq21497936/p/14118493.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq21497936/p/14118493.html</guid>
<description>

&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  接下来介绍树莓派蓝牙模块的开发，使用的协议为bluez。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;
&lt;h2&gt;ssh远程登录到树莓派&lt;/h2&gt;
&lt;/p&gt;



&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201210205727501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMjE0OTc5MzY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  客户端bob，服务器alice，探测两方的rssi，并传送给服务器alice&lt;br/&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/2020120920592779.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201209205933117.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201209210106971.gif&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;
&lt;h2&gt;简介&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;  BlueZ是官方Linux Bluetooth栈，由主机控制接口（Host Control Interface，HCI）层、Bluetooth协议核心、逻辑链路控制和适配协议（Logical Link Control and Adaptation Protocol，L2CAP）、SCO 音频层、其他 Bluetooth 服务、用户空间后台进程以及配置工具组成。&lt;br/&gt;BlueZ由许多单独的模块组成：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;蓝牙内核子系统核心&lt;/li&gt;
&lt;li&gt;L2CAP和SCO音频内核层&lt;/li&gt;
&lt;li&gt;RFCOMM，BNEP，CMTP和HIDP内核实现&lt;/li&gt;
&lt;li&gt;HCI UART，USB，PCMCIA和虚拟设备驱动程序&lt;/li&gt;
&lt;li&gt;通用蓝牙和SDP库和守护程序&lt;/li&gt;
&lt;li&gt;配置和测试实用程序&lt;/li&gt;
&lt;li&gt;协议解码和分析工具&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;


&lt;p&gt;
&lt;h3&gt;步骤一：安装bluez&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code&gt;sudo apt-get install bluez
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
&lt;h2&gt;检查蓝牙设备是否加载成功&lt;/h2&gt;
&lt;/p&gt;

&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201209205406212.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;打开蓝牙&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;pre&gt;
&lt;code&gt;sudo hciconfig hci0 up
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201209205423869.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;扫描蓝牙&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;pre&gt;
&lt;code&gt;sudo hciconfig iscan
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201209205451610.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;  （注意：不好用，显示的都是mac地址，而且中文乱码，周围蓝牙多，根本分不清楚）&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;启动蓝牙程序&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;pre&gt;
&lt;code&gt;bluetoothctl
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201209205525113.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;启动/关闭蓝牙电源&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;pre&gt;
&lt;code&gt;power on/off
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201209205640527.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;获取要配对设备的MAC地址&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201209205625663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMjE0OTc5MzY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;  电脑上的蓝牙，先打开：&lt;br/&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201209205706330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMjE0OTc5MzY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code&gt;sudo python3 -m pip install pybluez
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;
&lt;h2&gt;server.py&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;11&quot;&gt;
&lt;pre&gt;
&lt;code&gt;# -*-coding: utf-8 -*-
from bluetooth import *
import sys
import time
import os
import struct
import bluetooth._bluetooth as bluez
import bluetooth

global hostRssi

os.system(&quot;bluetoothctl power on&quot;)

# 获取服务,通过uuid查找目标服务
#uuid = &quot;63078d70-feb9-lle7-9812-dca90488bd22&quot;
#os.system(&quot;bluetoothctl discoverable on&quot;)
dstuuid   = &quot;11111111-1111-1111-1111-111111111111&quot;
localuuid = &quot;22222222-2222-2222-2222-222222222222&quot;

print(&quot;本地服务器，搜索客户端蓝牙rssi&quot;)
...
data = client.recv(1024)
print (data)
client.close()

bluetooth_sock.close()

&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;client.py&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;12&quot;&gt;
&lt;pre&gt;
&lt;code&gt;from bluetooth import *
import sys
import time
import os
import struct
import bluetooth._bluetooth as bluez
import bluetooth

global hostRssi

#开启蓝牙可见
os.system(&quot;bluetoothctl power on&quot;)
os.system(&quot;bluetoothctl discoverable on&quot;)
dstuuid   = &quot;22222222-2222-2222-2222-222222222222&quot;
localuuid = &quot;11111111-1111-1111-1111-111111111111&quot;

bluetooth_sock=BluetoothSocket(RFCOMM)
bluetooth_sock.bind((&quot;&quot;,PORT_ANY))
bluetooth_sock.listen(1)
...
 data = &quot;server:&quot; + str(hostRssi) + &quot;, client:&quot; + str(clientRssi)
...
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;
&lt;h2&gt;入坑一：打开蓝颜失败&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201209205732161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMjE0OTc5MzY=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
&lt;code&gt;sudo vim /lib/systemd/system/bluetooth.service
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;  修改文件内容&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code&gt;#ExecStart=/usr/lib/bluez5/bluetooth/bluetoothd
ExecStart=/usr/lib/bluez5/bluetooth/bluetoothd -E -C
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&amp;amp;emso;&amp;amp;emso;然后重启服务&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;pre&gt;
&lt;code&gt;sudo sdptool add SP
sudo systemctl daemon-reload
sudo systemctl restart bluetooth
sudo sdptool browse local
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;入坑二：“no advertisable device”&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;  &lt;img src=&quot;https://img-blog.csdnimg.cn/20201209205820495.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;  原因：由于蓝牙不可见导致&lt;/p&gt;
&lt;/div&gt;




</description>
<pubDate>Fri, 11 Dec 2020 00:27:00 +0000</pubDate>
<dc:creator>红胖子(红模仿)</dc:creator>
<og:description>若该文为原创文章，转载请注明原文出处本文章博客地址：https://blog.csdn.net/qq21497936/article/details/110940484长期持续带来更多项目与技术分享，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qq21497936/p/14118493.html</dc:identifier>
</item>
<item>
<title>2020中国.NET开发者峰会近50场热点技术专题揭秘 - 张善友</title>
<link>http://www.cnblogs.com/shanyou/p/14118444.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shanyou/p/14118444.html</guid>
<description>&lt;p&gt;简介 / Summary&lt;/p&gt;
&lt;p&gt;2014年微软组织并成立.NET基金会，微软在成为主要的开源参与者的道路上又前进了一步。2014年以来已经有众多知名公司加入.NET基金会，微软，Google，AWS三大云厂商已经齐聚.NET基金会，在平台项目中，.NET平台上的ARM 架构由三星团队贡献，在.NET Core 3.1上得到了完整支持，.NET 5上面得到进一步的优化，国内的龙芯团队正在开发MIPS架构的支持，即将正式发布.NET Core 3.1 For MIPS。为了将.NET基金会变成一个更加多样化和成员驱动的组织，微软把.NET的发展真正交给社区，为了让OSS真正蓬勃发展。&lt;/p&gt;
&lt;p&gt;从2016年以来，我们的.NET社区通过协作来推动.NET开源项目和社区的发展，在github/gitee上活跃着很多中国的.NET 开源开发者组织，例如NCC、盛派开发者、EasyAbp、龙芯.NET等，我们在全国各大城市有.NET 俱乐部定期举办活动，今年由于疫情，更多是线上的直播活动。11月10号成功举办的2020 年.Net Conf，.NET 5已经在大会上正式发布了。2019年我们也在上海成功举办了第一届中国.NET开发者峰会，今年我们将继续在苏州举办第二届.NET社区的中国峰会。&lt;/p&gt;
&lt;p&gt;In 2014, Microsoft organized and established the .NET Foundation, and Microsoft took another step forward on the road to becoming a major open source participant.&lt;/p&gt;
&lt;p&gt;Since 2014, many well-known companies have joined the .NET Foundation. The three major cloud vendors of Google, Microsoft, and AWS have gathered at the .NET Foundation. In the platform project, the ARM architecture on the .NET platform is contributed by the Samsung team. NET Core 3.1 has been fully supported, and .NET 5 has been further optimized. The domestic Loongson team is developing support for the MIPS architecture and will officially release .NET Core 3.1 For MIPS. In order to turn the .NET Foundation into a more diverse and member-driven organization. Microsoft has truly entrusted the development of .NET to the community in order to make OSS truly flourish.&lt;/p&gt;
&lt;p&gt;Since 2016, our .NET community has promoted the development of .NET open source projects and communities through collaboration. Many Chinese .NET open source developer organizations are active on github/gitee, such as NCC, Shengpai Developer, EasyAbp, Loongson.NET, etc. We have .NET clubs in major cities across the country to hold regular events. This year, due to the epidemic, more live events are online. At the successful .Net Conf 2020 held on November 10th, .NET 5 has been officially released at the conference. In 2019, we also successfully held the first China .NET Developers Summit in Shanghai. This year we will continue to host the second China Summit of the .NET Community in Suzhou.&lt;/p&gt;
&lt;p&gt;分享嘉宾 / Speakers&lt;/p&gt;
&lt;p&gt;主会场嘉宾：&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;徐明强博士&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;224&quot; height=&quot;241&quot; src=&quot;https://uploader.shimo.im/f/E1uBfSn68eAl35s4.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;徐明强博士&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微软全渠道事业部首席技术官（CTO）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;徐明强博士目前担任微软全渠道事业部首席技术官，负责微软大中华区合作伙伴解决方案策略技术策划工作。徐明强的团队侧重现代工作空间、数据和人工智能、业务应用、云基础设施及应用领域，为合作伙伴提供架构上的支撑。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dr.  Xu Mingqiang&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Chief Technology Officer, One Commercial Partner,&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Greater China Region, Microsoft&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Dr. Mingqiang Xu is presently the CTO of the Microsoft One Commercial Partner organization, being responsible for the partners’solution building/planning.  His team is focusing on providing architectural support for solutions in areas of modern workplace, data and AI, business applications and cloud infrastructure and applications.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;
&lt;h6&gt;&lt;strong&gt;林家伟&lt;/strong&gt;&lt;/h6&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img width=&quot;221&quot; height=&quot;236&quot; src=&quot;https://uploader.shimo.im/f/ofj9qqaJ2hfk8LHa.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;林家伟&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微软大中华区Azure事业部 - 总经理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;林家伟先生目前整体负责微软大中华区Azure业务，工作职责涵盖战略、规划、执行、宣传、管理和培训。林家伟先生在为高速增长的云和软件业务搭建客户体验以及业务转型方面有超过24年的经验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JiaWoei Ling&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;General Manager @Azure Business Group - Greater China Region&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Jia Woei currently leads the Azure business for Microsoft with end-to-end accountability across Greater China including strategy, planning, execution, advocacy, governance and learning. Jia Woei brings to Microsoft nearly 24 years of experience building and transforming high growth cloud and software businesses.&lt;/p&gt;
&lt;p&gt;3.敖琪&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;192&quot; height=&quot;253&quot; src=&quot;https://uploader.shimo.im/f/NODEWCwWcb0fcUVN.jpg!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;敖琪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;龙芯.NET项目负责人，龙芯JVM负责人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：龙芯.NET到来&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题简述：&lt;/strong&gt;.NET Core社区版本目前只支持x86和arm平台，在龙芯平台上运行.NET应用是一大挑战和难题。龙芯公司从2019年开始研发基于龙芯平台的.NET环境，目前已将.NET Core 3.1成功移植至龙芯平台。本次报告将会介绍龙芯在.NET上的工作和现状。&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;王鸿&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img width=&quot;112&quot; height=&quot;112&quot; src=&quot;https://uploader.shimo.im/f/AdyL20qW4ELaOnzz.png!thumbnail&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;王鸿&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;西安葡萄城，表格技术负责人&lt;/p&gt;
&lt;p&gt;.NET技术专家，毕业于西安交通大学计算机系, 曾在大学任教两年，后进入西安葡萄城从事表格组件研发工作。2014年至今，一直聚焦于企业高性能表格技术领域的研究，为葡萄城设计了全新的表格组件架构，并带领研发团队推出了一款性能在业界领先的电子表格组件GcExcel, 积累了大量高并发、高可用性组件的架构设计经验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：在 .NET Core 等平台下实现高性能电子表格组件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;如何在 .NET Core 等平台下，批量处理、解析 Excel文档？如何将组件性能提升至POI/NPOI的7倍以上？本次分享将从电子表格组件的需求场景出发，基于葡萄城的多项应用实践，如多线程支持、应用SIMD及高速缓存、减少垃圾回收、慎用异常、不动态生成IL code以便在IOS正常运行等技术手段，实现一款跨平台的高性能电子表格组件。&lt;/p&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;
&lt;h6&gt;张善友&lt;/h6&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img width=&quot;135&quot; height=&quot;202&quot; src=&quot;https://uploader.shimo.im/f/MwGFS5WfyDu5KIQn.jpg!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;张善友 / Shanyou Zhang&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;深圳市友浩达科技有限公司/CTO     &lt;/p&gt;
&lt;p&gt;毕业于兰州大学，在服务腾讯12年后于2018年创立深圳市友浩达科技有限公司，连续15年被评为微软最有价值专家（MVP），腾讯云TVP和华为云MVP。拥有超过十九年IT行业经验，运营拥有6万粉丝的微信公众号“dotnet跨平台”, 同时积极参与.NET社区开源项目，.NET基金会成员，被尊称为张队长&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：.NET 5 和.NET 未来&lt;/strong&gt; 中级&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;通过.NET Framework、.NET Core 的发展历程以及.NET Standard和.NET 5 ，带大家了解.NET技术的来龙去脉，以20年的从业经验向你展示我对 .NET 的发展方向的认识，和我一同树立.NET技术的信心&lt;/p&gt;
&lt;p&gt;嘉宾&lt;/p&gt;
&lt;p&gt;☆以下排名不分先后，根据姓名首字母依次排序。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;
&lt;h6&gt;Anduin Xue&lt;/h6&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img width=&quot;381&quot; height=&quot;254&quot; src=&quot;https://uploader.shimo.im/f/IbuNKmE24CMwo45B.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Anduin Xue&lt;/p&gt;
&lt;p&gt;Microsoft FTE, .NET  developer, hacker, blogger, Starcraft II player&lt;/p&gt;
&lt;p&gt;I am the founder of  Aiursoft. And I am one of the authors of Kahla. I love C#, TypeScript and  open source and I'm focusing on micro-services, DevOps, Web and PWA.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：开发多端共享交互 .NET 应用开发&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;如何保证多端的数据实时交互、共享，并维持时序的一致性和可用性？如何构建可以离线使用的增删改查应用？如何确保应用的数据可以尽快远程和其它设备同步，并节省流量和服务器性能？Anduin 将简单介绍如何在 .NET 中构建交互日志引擎，分享开发过程中的难点和痛点，并给出实际应用案例，以开发多端共享交互 .NET 应用开发。&lt;/p&gt;
&lt;p&gt;2.陈超超&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;375&quot; height=&quot;427&quot; src=&quot;https://uploader.shimo.im/f/On9GyrBWfTwliMqd.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;陈超超 正泰集团开发工程师 Ant Design Blazor  项目贡献者&lt;/p&gt;
&lt;p&gt;长期基于.Net技术栈进行架构和开发企业IT系统的工作，擅长Blzaor，WinForm，Unity3D等领域&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题: Blazor助力企业后台开发实战 中级（Intermediate）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：对客户&lt;/strong&gt;体验的日益重视带来了前端的兴起，但目前在企业后台应用开发领域采用传统方案变的越发复杂，重复劳动，人员冗余等问题，边际效应严重，而Blazor的特点很好的解决了这些问题，主要介绍在以下方面&lt;/p&gt;
&lt;p&gt;1、复杂度降低：前端与后端使用相同的语言实现了一致的开发体验。&lt;/p&gt;
&lt;p&gt;2、成本减少：所有环节使用相同的框架，代码库直接复用减少工作量，无需前后端分别配备开发减少人员数量。&lt;/p&gt;
&lt;p&gt;3、简化资源调配：开发人员技能构了单一化，有助于资源调配、沟通协作。&lt;/p&gt;
&lt;p&gt;4、前端工程化：模块化、组件化、规范化、自动化。&lt;/p&gt;
&lt;p&gt;通过现场实战，演示企业后台程序最常见的几个场景（Server、WASM两种模式均做演示）&lt;/p&gt;
&lt;p&gt;1、多查询条件的查询页面开发&lt;/p&gt;
&lt;p&gt;2、添加与编辑功能中前后端共享Dto&lt;/p&gt;
&lt;p&gt;3、VS中的OpenAPI服务（WASM专属）&lt;/p&gt;
&lt;p&gt;4、前端直接使用EF操作数据库（Server专属）&lt;/p&gt;
&lt;p&gt;5、前后端共享相同的安全策略&lt;/p&gt;
&lt;p&gt;3.仇华&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;317&quot; height=&quot;317&quot; src=&quot;https://uploader.shimo.im/f/nGr73Oj4rmM0xkJN.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仇华&lt;/p&gt;
&lt;p&gt;苏州三星高级研发工程师，SciSharp STACK 主要成员，Google TensorFlow Developer  Certificate&lt;/p&gt;
&lt;p&gt;TensorFlow User Group苏州 主要组织者，园区高技能领军人才，从事工业机器视觉开发和深度学习11年。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：.NET深度学习的工业视觉解决方案&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;作为一名.NET开发者，同时也是多年的工业机器视觉从业者，在推进深度学习应用于工业现场的机器视觉项目的过程 中，我摸索尝试过各种解决方案，也深入地和现场使用人员交流，并对工业现场的视觉软硬件环境做了广泛的调研， 发现深度学习在工业应用场景和互联网领域应用存在一定的差异性。本次主要和大家分享交流下述内容：1）. 工业领 域机器视觉中应用部署深度学习的行业特点分析和技术痛点解剖，主要分为视觉硬件成像环境和图像特征、生产环境 负样本不足、如何集成到现有设备老旧的系统、模型现场部署和推理以及算法落地的配套工具开发；2）. 如何高效地 使用C#结合TensorFlow.NET开发深度学习的实际项目，.NET Core 和 .NET FrameWork 的双框架支持使用，无需 依赖TensorFlow Python库，纯.NET框架下的深度学习开发，充分发挥.NET的高效率和高性能的特点；3）. 配置部 署深度学习的GPU环境如何发挥.NET优势和便利性，无需复杂的cuda和cuDNN安装配置，直接DLL引用方式配置 GPU环境，搭建环境打包式的GPU Package软件包进行客户交付；4）. 关于开发基于.NET的交互式工业视觉深度学 习完整软件平台的经验和解决方案分享。&lt;/p&gt;
&lt;p&gt;4.董彬&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;292&quot; height=&quot;292&quot; src=&quot;https://uploader.shimo.im/f/2Lwfpjdgk2R7WgvV.jpg!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;董彬&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;某知名投资银行 任职于某知名投资银行的风控部门，负责桌面客户端开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闪电主题：解析C# 9新特性：Record&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;5.&lt;strong&gt;冯辉 / HuiFeng&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;323&quot; height=&quot;337&quot; src=&quot;https://uploader.shimo.im/f/PsIwgMpGZmcrMRTU.JPG!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;冯辉 / HuiFeng&lt;/p&gt;
&lt;p&gt;开创云 / Ctrl 目前就职于开创云，负责公司架构设计，微软MVP。&lt;/p&gt;
&lt;p&gt;擅长dotnet跨平台架构设计，有丰富的跨平台实战经验。对.NET平台情有独钟，乐于分享知识与经验，热爱开源。&lt;/p&gt;
&lt;p&gt;I am a professional software engineer, Microsoft MVP. A devotee of the OSS. Have always maintained a love for technology, like to pay attention to and research cutting-edge technology, enthusiastic about technology and experience sharing.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题&lt;/strong&gt;&lt;strong&gt;：&lt;/strong&gt;&lt;strong&gt;“搭乐高式”ABP应用开发&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;以“乐高积木”带大家走进模块化设计，我们会了解到积木（模块）不同特性，以及如何在我们的项目中去使用这些积木，并且如何搭建出来一个APP。&lt;/p&gt;
&lt;p&gt;Summary：Today we will explore the ABP framework LEGO-like modular design and use the modules to build a new powerful application quickly.&lt;/p&gt;
&lt;p&gt;6.伏允昆&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;247&quot; src=&quot;https://uploader.shimo.im/f/B9Yz5j6oE3E27VYj.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;伏允昆&lt;/p&gt;
&lt;p&gt;苏州盛派网络科技有限公司合伙人/技术总监&lt;/p&gt;
&lt;p&gt;7.桂素伟/GuiSuWe&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;328&quot; height=&quot;294&quot; src=&quot;https://uploader.shimo.im/f/Br2i1K9aNoxfdkdG.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;桂素伟/GuiSuWei&lt;/p&gt;
&lt;p&gt;株式会社ネットスターズ/NetStars - 系统架构&lt;/p&gt;
&lt;p&gt;多届微软MVP，喜欢分布式技术，微服务，迷恋在GitHub上彻墙，热衷技术社区分享，忠实的.net  core布道者，从事.net 开发、架构10余年，仍然奋斗在码码的第一线。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：&lt;/strong&gt;基于kubernetes复杂项目交付/Deliver complex projects on kubernetes 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;Kubernetes已经成为云原生分布式架构的标准，我们公司使用kubernetes也一段时间了，本次分享一个真实的，自已带队架构开发的，基于kubernetes环境的复杂项目的交付案例。本次演讲会从项目的业务特征，交付要求特点；源码管理的分支设计；基于kubenetes开发，测试，预生产，生产的环境交付流程等几个方面来分享我们的心路历程。&lt;/p&gt;
&lt;p&gt;8.郝冠军&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;348&quot; height=&quot;358&quot; src=&quot;https://uploader.shimo.im/f/I6NfmqPY8tNxRd7C.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;郝冠军&lt;/p&gt;
&lt;p&gt;微软最有价值专家，《ASP.NET本质论》作者&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：透析 ASP. NET Core 认证&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;主题简介：在 ASP. NET Core 中，认证部分变得更加强大，也更加灵活，透彻理解认证架构与实现，是用好认证的关键。&lt;/p&gt;
&lt;p&gt;本次内容从一个开发实例入手，剖析认证相关问题，梳理认证涉及的相关技术，涉及基于 JWT 的认证，基于 Cookie 的认证，ASP.NET Identity 等相关技术，理论联系实际，助你成为认证高手。&lt;/p&gt;
&lt;p&gt;9.黄国石&lt;/p&gt;
&lt;p&gt;黄国石&lt;/p&gt;
&lt;p&gt;递易智能科技CTO&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;153&quot; height=&quot;153&quot; src=&quot;https://uploader.shimo.im/f/BTSR883OCCatfFIp.jpg!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;15年的.NET开发经验，先后从事过电网、金融、传媒等领域，在物联网方向创业8年，在中通快递担任资深架构师负责大数据分析和物联网方向，目前在递易担任CTO，从事快递柜、送餐柜等物联网Saas平台建设，全面使用Redis消息队列！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闪电主题：Redis消息队列&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;消息队列是分布式系统必不可少的中间件，而大部分消息队列产品（如RocketMQ/RabbitMQ/Kafka等）要求团队有比较强的技术实力才能用好，不适用于中小团队。而Redis实现的轻量级消息队列很简单，就是Redis常规操作，几乎不需要开发团队掌握额外的知识，就可以用得很好！&lt;/p&gt;
&lt;p&gt;10.黄海鹏&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;462&quot; height=&quot;616&quot; src=&quot;https://uploader.shimo.im/f/qRujtjgaifB2UOLt.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;黄海鹏&lt;/p&gt;
&lt;p&gt;苏州易泰勒电子 - 软件研发总监&lt;/p&gt;
&lt;p&gt;从事物联网行业开发十余年，是电子货架标签（ESL）系统的主要开发者，亦是.NET技术栈的忠实拥护者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闪电主题：C#树莓派编程入门&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;开发人员可以使用C#+树莓派进行很多有趣的开发，诸如涉及GPIO口的编程，低成本物联网项目的数据网关结点，以及生活中各种智能设备（如NAS，可视门铃等）原型开发板。&lt;/p&gt;
&lt;p&gt;Huang Hai Peng&lt;/p&gt;
&lt;p&gt;Suzhou Etag Ltd - Software R &amp;amp; D director&lt;/p&gt;
&lt;p&gt;He has developed from the Internet of things industry for more than 10 years, is a major developer of the electronic shelf label (ESL) system and a loyal supporter of. Net technology stack.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lightning:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary：&lt;/strong&gt;Our developers can using C# and Raspbery Pi to do many interesting work, like developing with GPIO interface, data node of low-cost IoT project, and quickly prototype development board of many smart devices in your life(like NAS, visual doorbell etc).&lt;/p&gt;
&lt;p&gt;11.黄立敬/Lijing Huang&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;309&quot; height=&quot;282&quot; src=&quot;https://uploader.shimo.im/f/CJ3PdH9b9fX4IQlt.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;黄立敬/Lijing Huang&lt;/p&gt;
&lt;p&gt;人大数媒科技(北京)有限公司 技术总监 /RUC Digital Media Technology(Beijing) Co., Ltd. - CTO &lt;/p&gt;
&lt;p&gt;负责公司技术团队的搭建和公司各大互联网产品的架构设计和开发工作。一直默默关注C#开源社区，2010年玩过Mono，2013年采用Xamarin开发Android应用，从2019年起开始带来团队实践.NET Core项目，公司核心的产品已经迁移到.NET Core，今年以来带领团队完成国产化系统下的.NET Core项目改造。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：国产化系统下的.NET Core实践&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Topic：NET Core Practice for Localization  Systems&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;国产化系统下的.NET  Core实践经验和心得&lt;/p&gt;
&lt;p&gt;1、系统现状和要求，包括CPU、操作系统和中间件的要求，如何突破目前中间件对Java的特殊保护，到底是用java重写还是迁移.NET  Core，给出实用的迁移建议；&lt;/p&gt;
&lt;p&gt;2、国产化各种准备工作，重点技术预研，特别是现有系统的各个类库对.NET  Core的支持情况，最终做出技术评估；&lt;/p&gt;
&lt;p&gt;3、项目迁移工作，除了按照官方要求迁移之外，还需要考虑系统在各个平台的可移植情况，我们迁移过程中遇到的问题和解决办法；&lt;/p&gt;
&lt;p&gt;4、项目测试，模拟各种国产CPU搭建测试环境，并对系统进行测试；&lt;/p&gt;
&lt;p&gt;5、系统部署，部署过程中的问题和解决方案。&lt;/p&gt;
&lt;p&gt;12.Justin Yoo&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;220&quot; height=&quot;220&quot; src=&quot;https://uploader.shimo.im/f/zAoUyobrOgrJyZRC.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Justin Yoo&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Senior Cloud Advocate at Microsoft&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;He used to be  a double-awarded Microsoft MVP for many years in both Developer Technology  and Azure. He likes serverless, enterprise service integration and messaging.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闪电主题：What to Know When Migrating from Legacy WebForm to Blazor&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;因为.NET5 has been released, 所以 many organisations are planning  to migrate their legacy ASP.NET WebForm apps to Blazor ones. Both are similar  to each other at the same time different from each other. 我打算 discuss what to  consider for migration.&lt;/p&gt;
&lt;p&gt;13.贾维维/ Jiaweiwei&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;189&quot; height=&quot;283&quot; src=&quot;https://uploader.shimo.im/f/t7waD0PLrc4xeRHc.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;贾维维/ Jiaweiwei&lt;/p&gt;
&lt;p&gt;汽车之家/autohome - 搜索架构师&lt;/p&gt;
&lt;p&gt;对.NET Core 高性能计算有一定研究&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：.Net 5与高性能计算&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;主要介绍下，目前通过.net core如何实现高性能，主要包括simd（单指令多数据流），Compiler as  Service，IL  Emit等在高性能计算中的一些应用，以及目前通过这些技术构建 .NET 大数据生态做的一些框架和尝试，并就目前做出来的功能进行一些列的展示和对比，为生态赋能。&lt;/p&gt;
&lt;p&gt;14.李枫&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;297&quot; height=&quot;451&quot; src=&quot;https://uploader.shimo.im/f/nTZJCPpG1CxECfNA.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;李枫&lt;/p&gt;
&lt;p&gt;独立开发者&lt;/p&gt;
&lt;p&gt;先后就职于摩托罗拉, 三星等IT公司, 现为独立开发者。在移动平台上积累了十年以上的研发经验, 近几年主要专注于云计算/边缘计算基础设施领域。是《灰帽黑客 第4版：正义黑客的道德规范、渗透测试、攻击方法和漏洞分析技术》（ISBN：9787302428671）和《恶意网络环境下的Linux防御之道 》（ISBN: 9787115544384）中文版的主要译者。&lt;/p&gt;
&lt;p&gt;对技术创新具有浓厚的兴趣和实践能力，热心参与开源社区的各种活动。&lt;/p&gt;
&lt;p&gt;Feng Li&lt;/p&gt;
&lt;p&gt;Indie developer&lt;/p&gt;
&lt;p&gt;Had been worked in Motorola, Samsung, etc, now I am an indie developer. Accumulated more than ten years experience in mobile development on various platforms, and focused on Cloud &amp;amp; Edge Infrastructure during the past few years. The main translator of the book «Gray Hat Hacking The Ethical Hacker's Handbook, Fourth Edition» (ISBN：9787302428671) and «Linux Hardening in Hostile Networks, First Edition».&lt;/p&gt;
&lt;p&gt;With strong interest and practical ability in technology innovation, I am enthusiastic in take part in various activities of the Open Source Community.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：ARM上的Akka.NET&lt;/strong&gt; 中级&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;Akka.NET是流行的Akka（由Java/Scala编写）分布式Actor框架在.NET上的一个专业级移植, 本提案包含下列子话题：&lt;/p&gt;
&lt;p&gt;1) Akka.NET项目的架构与设计综述；&lt;/p&gt;
&lt;p&gt;2) 在开源硬件平台树莓派4（ARM64）上构建Akka.NET(使用.Net 5)；&lt;/p&gt;
&lt;p&gt;3) 在树莓派集群上实践Akka.NET集群。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Topic： Akka.NET on ARM&lt;/strong&gt; Intermediate&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary：&lt;/strong&gt;Akka.NET is a professional-grade port of the popular Java/Scala framework Akka distributed actor framework to .NET, and this proposal comes with the following sub-topics:&lt;/p&gt;
&lt;p&gt;       1) Overview of the architecture &amp;amp; design of project Akka.NET&lt;/p&gt;
&lt;p&gt;       2) Set up Akka.NET with .Net 5 on Raspberry Pi 4（ARM64）&lt;/p&gt;
&lt;p&gt;       3) Practicing Akka.NET cluster with a Raspberry Pi cluster&lt;/p&gt;
&lt;p&gt;15.李帅&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;358&quot; height=&quot;266&quot; src=&quot;https://uploader.shimo.im/f/p1hZcqEg4P7XzKgT.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;李帅/Spring Lee&lt;/p&gt;
&lt;p&gt;递易智能科技有限公司/ Diyi- 高级工程师&lt;/p&gt;
&lt;p&gt;HttpReports APM 项目作者，开源爱好者，同时也是 NCC 组织成员&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：HttpReports APM 在微服务的应用&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;随着微服务架构的流行，往往一次请求会设计到多个微服务，因此服务性能监控和排查就变得更复杂, 于是分布式系统的APM管理系统应运而生。&lt;/p&gt;
&lt;p&gt;HttpReports是基于.Net Core 开发的APM监控系统，使用MIT开源协议，主要功能包括，统计, 分析, 可视化， 监控，追踪，拓扑图等，本次分享会介绍HttpReports 的架构设计和分布式追踪的原理。&lt;/p&gt;
&lt;p&gt;16.李卫涵/LiWeihan&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;293&quot; height=&quot;293&quot; src=&quot;https://uploader.shimo.im/f/7bEIBWVRfOAB64JL.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;李卫涵/LiWeihan&lt;/p&gt;
&lt;p&gt;iHerb - .NET 研发工程师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闪电主题：xunit中依赖注入的使用&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;一个项目的高质量少不了测试项目来保证，优秀的开源项目一定少不了测试项目，依赖注入已经几乎融入到了每一个现代化框架中，asp.net core 从一开始就集成了依赖注入，依赖注入在测试项目中也不能缺席&lt;/p&gt;
&lt;p&gt;使用 Xunit.DependenceInjection，优雅的在测试里使用依赖注入，更好用的流程控制，更方便的做 asp.net core 的集成测试&lt;/p&gt;
&lt;p&gt;A high quality project must be guaranteed by the test projects. A good open source project must have test projects. Dependency injection has been integrated into almost every modern framework. Asp.net core has integrated dependency injection from the very beginning. Dependency injection can't be absent in the test project.  with Xunt.DependencyInjection, we could implement dependency injection much more easily&lt;/p&gt;
&lt;p&gt;17.李宇/Yu Li&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;262&quot; height=&quot;336&quot; src=&quot;https://uploader.shimo.im/f/hsa7R0XaywgdCZRs.jpg!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;李宇/Yu Li&lt;/p&gt;
&lt;p&gt;ThoughtWorks咨询师&lt;/p&gt;
&lt;p&gt;有多年C#/.NET开发经验，参与多个基于.NET/.NET  Core的国内外项目。目前专注微软Azure/.NET Core技术。&lt;/p&gt;
&lt;p&gt;ThoughtWorks consultant, has many years  of C#/.NET development experience, and participated in a number of domestic  and foreign projects based on .NET/.NET Core. Currently focusing on Microsoft  Azure/.NET Core technology.&lt;/p&gt;
&lt;p&gt;演讲主题：基于Azure Functions &amp;amp; .NET快速构建无服务化应用&lt;/p&gt;
&lt;p&gt;Topic：Quickly build serverless application with Azure Functions &amp;amp; .NET 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;主题简介：主要介绍Microsoft Azure Functions的基本概念和开发方法。在实际操作环节，将从零开始构建一个用户感兴趣的内容定时聚合功能，并将聚合结果发送邮件通知用户的Azure Functions应用。希望通过理论的介绍和动手实践，让大家了解Azure Functions，并可以开始搭建自己的第一个serverless应用，鼓励大家去探索使用Azure Functions更多的可能性。&lt;/p&gt;
&lt;p&gt;Summary：Mainly introduce the basic concepts and development methods of Microsoft Azure Functions. In the actual operation, an Azure Functions application will be built from scratch to periodically aggregate content that users are interested in, and the aggregation results will be sent to notify users by email. I hope that through theoretical introduction and hands-on practice, everyone can understand Azure Functions and start building their first serverless application, and encourage everyone to explore more possibilities for using Azure Functions.&lt;/p&gt;
&lt;p&gt;18.刘桂海&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;346&quot; height=&quot;356&quot; src=&quot;https://uploader.shimo.im/f/YFo7czZQS5cm3Kup.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;刘桂海&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特来电技术架构师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;12年工作经验，曾负责浪潮软件“楼上”中间件平台研发工作，擅长平台架构设计、基于Flink的流计算技术，目前专注AIOps研发工作，致力于打造新能源充电行业领先的稳定性运维保障技术体系，实现基于大数据及机器学习的新一代智能运维。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：特来电稳定性保障技术体系实践&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;特来电稳定性保障技术体系提供端到端的运维保障解决方案，以AIOps为指导原则，首先提供.Net技术的监控SDK、监控Agent、全链路追踪体系；然后基于流计算技术及图计算技术，对监控大数据进行实时分析，可以一览无余的查看链路流量情况、底层异常聚类情况，并在链路异常时进行逐层下钻，快速定位到问题点；其次基于机器学习技术，结合平台运维实践，不断优化检测算法，实现对系统异常的实时聚类分析、异常检测，保证能够及时发现问题；最后对接自动运维系统，实现运维故障的自动发现、自动处理，做到了故障的闭环管理，有力的保障了平台稳定性。&lt;/p&gt;
&lt;p&gt;19.卢建晖&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;294&quot; height=&quot;264&quot; src=&quot;https://uploader.shimo.im/f/OHlFkjcVFjqTnTP3.jpg!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;卢建晖&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;华南师范大学网络教育学院程序开发总监&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微软技术社区区域总监，微软最有价值专家&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;较难（Advanced）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题： .NET in Deep Learning&lt;/strong&gt; 较难（Advanced）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;讲述 ML.NET 和 TensorFlow.NET 的深度学习故事，ML.NET 是微软在 dotnet core 下的原生机器学习解决方案，发展快两年，在整合开发工具和算例有了快速进展，而TensorFlow.NET 是一个基于C#/F# 的深度学习解决方案，两者的融合让.NET 生态有了一个从训练到应用的全平台机器学习方案。本课程通过通俗易懂的方式和.NETer介绍ML.NET 和TensorFlow.NET  从安装到开发，训练，再到实现的一站式体验&lt;/p&gt;
&lt;p&gt;20.陆楠/Lamond Lu&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;612&quot; height=&quot;345&quot; src=&quot;https://uploader.shimo.im/f/0uAfJeiEQgfUHS7H.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;陆楠/Lamond Lu&lt;/p&gt;
&lt;p&gt;Shinetech Inc. - 工程师&lt;/p&gt;
&lt;p&gt;陆楠，英文名Lamond Lu, 80后程序员，12年.NET开发经验,  目前就职于北京盛安德科技发展有限公司青岛分公司，喜欢研究各种程序架构, 沉迷DDD, Event Source, CQRS,  微服务。乐于分享，喜欢分享，擅长翻译国外优秀博客，曾担任微软 Insider Dev Tour 2019烟台站讲师。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：基于ASP.NET Core的热插拔插件机制&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;在.Net Framwork时代, 我们可以使用AppDomain来实现一个热插拔插件系统，在进入.NET Core时代之后，一直没有出现一套能够实现热插拔的插件系统，很多基于.NET Core的插件系统都不能实现热插拔的，他们的插件更新需要重启宿主来实现。本次主题是基于开源项目Mystique，讲解一下使用ASP.NET Core创建热插拔插件系统的一些要点&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/lamondlu/Mystique&quot;&gt;https://github.com/lamondlu/Mystique&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;相关博客：&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/13992077.html&quot;&gt;https://www.cnblogs.com/lwqlun/p/13992077.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;21.&lt;strong&gt;骆姜斌&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;185&quot; height=&quot;277&quot; src=&quot;https://uploader.shimo.im/f/Kt5LsOJBZ3h7mrG0.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;骆姜斌&lt;/p&gt;
&lt;p&gt;智鹏瑞尔软件 / SSW China - 高级软件架构师/高级咨询师。&lt;/p&gt;
&lt;p&gt;14年 .Net开发及架构设计经验， 资深技术团队领队。负责过大量重要项目，项目客户主要为政府及物流业。在IM，物流供应链等领域有着丰厚的经验积累。&lt;/p&gt;
&lt;p&gt;Jerry Luo&lt;/p&gt;
&lt;p&gt;Senior software architect / senior consultant in SSW, Australia's top software consulting firm&lt;/p&gt;
&lt;p&gt;More than 14 years’ experience of .Net development and architecture design. He has been in charge of many large projects with clients mainly in the government and logistics industry, which access him to rich experience in IM, logistics supply chain and other related fields.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：介绍 asp.NET Core高级功能托管服务&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;如何在.Net Core中执行后台任务；什么是后台任务；后台任务的使用场景, 解决什么问题；选项: IHostedService, BackgroundService, Worker Service, Hangfire； 什么是IHostedService, 如何使用, 优点, 缺点；什么是BackgroundService, 如何使用, 优点, 缺点；什么是Worker Service, 如何使用, 优点, 缺点； 什么是Hangfire, 优点, 缺点； 简单Demo讲解&lt;/p&gt;
&lt;p&gt;22.潘淳/Pan Chun， 林德熙/lindexi&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;200&quot; height=&quot;300&quot; src=&quot;https://uploader.shimo.im/f/zbaihizLrZ5fDHj6.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;潘淳：微软技术俱乐部（苏州）执行主席，Office开发者联盟发起人，苏州市人工智能协会智慧金融专委会委员。&lt;/p&gt;
&lt;p&gt;林德熙：微软应用开发方向的最具价值专家，dotnet  基金会成员。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闪电主题：后翼弃兵，现世代 .NET 大局观&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;后翼弃兵布局后来居上，暗喻.NET框架在布局完成后，.NET 5  在现世代（趋于开放，突破WIN平台，大步迈向新格局），与代表传统JAVA的战斗才开始进行，在高水平的层次上进行对抗。面对国际纷争，国产化的UOS、龙芯、鲲鹏等软硬件的入局，.NET  5的大统一将迎来高光时刻。从标准与技术入局，结合场景与应用，深入.NET 5的框架、语言、性能、开源、版权以及编译器到运行构建发布。&lt;/p&gt;
&lt;p&gt;23.彭伟 pengwei&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;210&quot; height=&quot;280&quot; src=&quot;https://uploader.shimo.im/f/9IE83E0VAs9D6l7I.jpg!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;彭伟 PengWei&lt;/p&gt;
&lt;p&gt;途虎 tuhu - 资深 .NET 开发&lt;/p&gt;
&lt;p&gt;有10年的 .NET 开发经验，负责公共服务和 .NET 基础组件开发&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：配置中心在微服务架构中的应用&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;介绍 Apollo 配置中心的架构、在微服务架构中如何管理配置中的敏感信息、同一应用如何在多环境多机房中使用不同配置以及配置的灰度发布&lt;/p&gt;
&lt;p&gt;24.苏震巍&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;261&quot; height=&quot;261&quot; src=&quot;https://uploader.shimo.im/f/WJ2SIBNosJ31JkMm.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;苏震巍&lt;/p&gt;
&lt;p&gt;苏州盛派网络科技有限公司创始人兼首席架构师，微软RD、微软MVP、微软技术俱乐部（苏州）主席&lt;/p&gt;
&lt;p&gt;《微信开发深度解析》《网站模块化开发全程实录》作者、Senparc.Weixin SDK / NCF 作者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题： .NET Core/5 + EF Core + NCF 多数据库迁移及切换解决方案&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们在开发可重用的业务模块、平台应用的时候，经常会遇到多数据库支持和迁移（Migration）的需求，在本课程中您将学习到：&lt;/p&gt;
&lt;p&gt;1） 借助盛派全新的开源框架 NCF（NeuCharFramework），在高度模块化的设计下，让系统业务和数据库选型解耦，实现一次开发业务代码，就能灵活支持多数据库（SQL Server/MySQL/Oracle，等等），并且可以在不同数据库间“一键迁移”；&lt;/p&gt;
&lt;p&gt;2） 利用多数据库支持特性，实现开发环境、测试环境、生产环境、数据库备份等多环节的数据库灵活切换；&lt;/p&gt;
&lt;p&gt;3） 剖析多数据库架构的核心设计思想。&lt;/p&gt;
&lt;p&gt;25.&lt;strong&gt;唐敦峰&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;215&quot; height=&quot;215&quot; src=&quot;https://uploader.shimo.im/f/l9lu57po1KvTaeDY.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;唐敦峰&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;明源云天际平台-建模平台 架构师 &lt;/p&gt;
&lt;p&gt;10年以上.Net开发经验，5年系统架构设计经验，目前专注于企业级低代码开发平台的设计，元数据驱动架构，可视建模、在线编码的方式快速构建高质量的企业级应用程序，让开发过程中仅通过简单地拖拽与配置完成，降低了开发者的门槛，让开发者只专注于核心业务逻辑的部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：Entity Framework Core实践与分享&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;主题标签：ORM框架   Entity Framework Core   领域驱动开发&lt;/p&gt;
&lt;p&gt;主题简介：&lt;/p&gt;
&lt;p&gt;1.EF Core简介  EF Core的发展历程、常用特性、原理剖析。&lt;/p&gt;
&lt;p&gt;2.EF Core实践  分享在EF Core实践应用中踩过的坑、发现的问题以及解决方案。基于EF Core，在低代码开发过程中的应用场景。&lt;/p&gt;
&lt;p&gt;3.EF Core高级特性分享  利用EF Core高级特性，实现多租户模式、软删除、数据审计、数据加密、并发控制器等。在领域驱动开发过程中的应用。&lt;/p&gt;
&lt;p&gt;26.汪恺&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;300&quot; height=&quot;301&quot; src=&quot;https://uploader.shimo.im/f/EYwp2jGa9NkUq5od.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;汪恺&lt;/p&gt;
&lt;p&gt;同花顺 - B2C业务架构师&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：.NET在投资领域的应用实践&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;随着资讯的发达，人们的投资意识逐渐浓厚，传统的投资软件已经无法满足日益增长的各式各样的C端客户需求，对投资软件的要求也越来越高，对于一家老牌公司，强大的.NET的能在这个领域发挥怎样的潜在威力呢？&lt;/p&gt;
&lt;p&gt;27.&lt;strong&gt;汪宇杰(Edi Wang)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;305&quot; height=&quot;305&quot; src=&quot;https://uploader.shimo.im/f/Chdn3ylEy4INKmwB.jpg!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;汪宇杰(Edi Wang)&lt;/p&gt;
&lt;p&gt;Green Dot 高级软件工程师&lt;/p&gt;
&lt;p&gt;微软全球最有价值专家，技术社区布道者。在ASP.NET和Azure云平台开发方面拥有丰富经验，已在GitHub上开源全部个人项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：Azure让.NET如虎添翼&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;全面介绍基于.NET 5.0开源博客系统Moonglade如何综合运用Azure的12种服务以实现覆盖全球用户、兼顾性能与安全和快速响应故障的目标，并有效提升普通用户和开发者的使用体验。&lt;/p&gt;
&lt;p&gt;28.王健/Ken Wang&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;288&quot; height=&quot;264&quot; src=&quot;https://uploader.shimo.im/f/c923FmjS7fpFnAGo.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;王健/Ken Wang&lt;/p&gt;
&lt;p&gt;ThoughtWorks高级咨询师&lt;/p&gt;
&lt;p&gt;参与并主导多个.NET Core项目的落地及上云实践，对容器化及无服务架构有深刻的理解&lt;/p&gt;
&lt;p&gt;ThoughtWorks senior consultant, participated in and led the landing and cloud practice of multiple .NET Core projects, and has a deep understanding of containerization and serviceless architecture&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;闪电主题：Blazor+WebAssembly开启Web开发新体验&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;Blazor是基于.NET实现的交互式客户端Web UI框架，在JavaScript统治前端的时代，它的出现与WebAssembly的完美配合使得我们可以将服务端的流畅体验带回到浏览器，也使得构建.NET的SPA成为了可能,这样的组合使得我们既能享受C#语言的优雅和高效，又能省去JavaScript带来的烦恼，实在程序员的福音&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Summary：&lt;/strong&gt;Blazor is an interactive client-side Web UI framework based on .NET. In the era when JavaScript dominates the front-end, its appearance and the perfect cooperation with WebAssembly allow us to bring the smooth experience of the server back to the browser, and also make the construction of .NET SPA becomes possible. This combination allows us to not only enjoy the elegance and efficiency of the C# language, but also save the troubles caused by JavaScript, which is a real gospel for programmers&lt;/p&gt;
&lt;p&gt;29.肖伟宇 /  Weiyu Xiao&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;276&quot; height=&quot;414&quot; src=&quot;https://uploader.shimo.im/f/8LJoaaACcbQVZEF8.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;肖伟宇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;.NET Conf China 2019 主会场讲师&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Fire User Group 常驻讲师&lt;/p&gt;
&lt;p&gt;有超过10年的.NET平台的应用经验，目前负责校宝在线的教培SaaS系统架构工作，在包含系统设计、迭代交付、运维保障等系统交付场景方面积累了丰富的经验。&lt;/p&gt;
&lt;p&gt;Weiyu Xiao&lt;/p&gt;
&lt;p&gt;Speaker of .NET Conf China 2019&lt;/p&gt;
&lt;p&gt;Resident Speaker of Fire User Group&lt;/p&gt;
&lt;p&gt;More than 10 years. Net platform application experience, currently responsible for SchoolPal Online’s SaaS system architecture, including system design, DevOps, site reliability and other aspects have accumulated a wealth of experience.在；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：&lt;/strong&gt;To B SaaS微服务架构的灰度实战经验 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Topic：&lt;/strong&gt;Gray-release experience for To B SaaS microserver architecture 较难（Advanced）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;对于To B SaaS系统，发布变更是系统稳定性的最大挑战之一，在充分测试的基础上，采取手段最大程度降低意外问题的影响范围是非常有必要的，我们采取的手段就是灰度阶梯发布。&lt;/p&gt;
&lt;p&gt;灰度发布意味着同时存在两个版本在线，在庞大的微服务架构集群中，每次需要部署大量的服务，但实际情况是变更的服务通常只是少数几个，基于这个情况，我们实现了按需灰度的能力，最大程度降低了灰度环境构建的成本。&lt;/p&gt;
&lt;p&gt;本次分享将讲解我们在实现过程中遇到的挑战以及详细方案。&lt;/p&gt;
&lt;p&gt;Summary：&lt;/p&gt;
&lt;p&gt;For To B SaaS systems, publishing changes is one of the biggest challenges to system stability, and on the basis of adequate testing, it is necessary to take measures to minimize the impact of unexpected problems, so we use Gray-release.&lt;/p&gt;
&lt;p&gt;Gray-release means that there are two versions online at the same time, and in a large cluster of microserver architectures, a large number of services need to be deployed at a time, but the reality is that the changed services are usually only a few, and based on this, we implement the ability to on-demand gray-release, minimizing the cost of building gray environments.&lt;/p&gt;
&lt;p&gt;Here we will share the challenges we face in the process and how to implement them.&lt;/p&gt;
&lt;p&gt;30.徐福扬&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;248&quot; src=&quot;https://uploader.shimo.im/f/VFP54joPktMM8oVf.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;徐福扬&lt;/p&gt;
&lt;p&gt;苏州盛派网络科技有限公司&lt;/p&gt;
&lt;p&gt;技术经理&lt;/p&gt;
&lt;p&gt;31.&lt;strong&gt;徐杨/Eleven&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;210&quot; src=&quot;https://uploader.shimo.im/f/rziVBFipyO14BTkd.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;徐杨(Eleven)&lt;/p&gt;
&lt;p&gt;微软MVP，武汉dotNET俱乐部发起人之一，武汉朝夕教育科技有限公司创始人&lt;/p&gt;
&lt;p&gt;09年毕业于武汉大学，专注.NET领域十多年，微软MVP，武汉dotNET俱乐部发起人之一，武汉朝夕教育科技有限公司创始人。当下专注于.NET在线教育，连续多年腾讯课堂金牌讲师，5年下来在线直播超1500场，累计受众超过30w人次，相关视频点击播放近千万次，对推动国内.NET社区发展做出了微末贡献。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：《.NET5落地微服务架构》&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;32.&lt;/strong&gt;刘腾飞/Jesse&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;612&quot; height=&quot;408&quot; src=&quot;https://uploader.shimo.im/f/Hd9c4dUgiwsAZNPB.jpeg!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刘腾飞/Jesse 上海程析智能 平台事业部部长&lt;/p&gt;
&lt;p&gt;博客园推荐博主，infoQ社区编辑成员《ASP.NET Core核心模块》、《asp.net core微服务实战》、《.NET Core 微服务 on K8S》多个热门视频系列作者。jessetalk公众号作者，对.Net Core微服务，云原生应用有较多的应用与实践。最近一年在带领团队研发低代码开发平台。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：.Net Core面向元数据驱动的架构&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;介绍低代码平台的一些主要场景，功能，以及底层架构思路。以及低代码平台在未来对开发者可能会产生的一些影响 。&lt;/p&gt;
&lt;p&gt;33.杨守斌&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;325&quot; height=&quot;325&quot; src=&quot;https://uploader.shimo.im/f/0w7UnfTDeowDwJhA.jpg!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;杨守斌&lt;/p&gt;
&lt;p&gt;青岛萨纳斯智能科技 技术负责人&lt;/p&gt;
&lt;p&gt;微软区域技术总监,MS RD&lt;/p&gt;
&lt;p&gt;目前在青岛萨纳斯智能科技,主要从事技术管理和研发工作,历任多年的MS MVP, 主要方向为ASP.NET, 硬件工程, Iot, Azure 等,希望能和大家交流.NET相关技术&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题： .NET 5中的高性能服务gRPC&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;远程服务gRPC是一个众所周知的高性能的RPC框架，在全世界广泛应用于各个领域，包括系统通信和Apps等，自从微软利用.NET Core 实现该框架,并贡献给CNCF以后,其在.NET Core环境下也得到了广泛的重视和应用, 本讲座主要是讲述.NET 5环境下gRPC的新特性, 包括性能的提升,gRPC-Web, Blazor的支持等等,随后将DEMO这些新特性,并讨论今后在.NET 5 环境中的应用场景, 最后将讨论如何进行部署和优化,例如Http.sys,IIS, OpenTelmetry等环境.&lt;/p&gt;
&lt;p&gt;34.杨舜杰&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;242&quot; height=&quot;242&quot; src=&quot;https://uploader.shimo.im/f/oByVtHaXGtGrPXyP.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;杨舜杰&lt;/p&gt;
&lt;p&gt;上海程析智能 系统架构研发工程师&lt;/p&gt;
&lt;p&gt;.NET基金会项目 Ant Design Blazor 作者，微软MVP，开源爱好者。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：Blazor 原生实现 Ant Design 前端组件库&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;主题简介：Ant Design Blazor 是一个用 Blazor 原生实现的前端组件库。启动8个月已在 Github 获得 2.6k Star，300+Folk，50+贡献者参与。&lt;/p&gt;
&lt;p&gt;本次主题将分享我们开发 Ant Design Blazor 的过程，为何选择 Ant Design，与 Ant Design 其他 3个前端框架的实现有什么不同，与 .NET 的其他应用模型又有什么联系，以及介绍组件开发中遇到的 Blazor 常见问题。&lt;/p&gt;
&lt;p&gt;35.衣明志&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;237&quot; height=&quot;356&quot; src=&quot;https://uploader.shimo.im/f/ncfUBsrMSWqhii8w.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;衣明志&lt;/p&gt;
&lt;p&gt;烟台易云网络科技有限公司创始人&lt;/p&gt;
&lt;p&gt;曾连任9年的微软全球最有价值专家（MVP），发起并创办了胶东开发者部落和胶东.NET俱乐部。从.NET 1.0 Beta开始就是.NET的忠实粉丝，有近20年的开发经验。现主要热衷于将云计算、DevOps、微服务架构、跨平台开发等。在汽车、农业机械、保险、零售等商业领域的信息化智能化方面经验丰富。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：高效率的开发.NET应用&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;程序开发经常会是一种高强度的工作，作为一个.NET开发老兵和技术创业者，我们会谋求快乐、高效、低强度的开发过程，通过新的工具、类库、方法避免996式的开发工作。头发已渐稀疏的老衣带着他的私货跟你分享他的高效开发心得。&lt;/p&gt;
&lt;p&gt;36.曾健&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;185&quot; height=&quot;185&quot; src=&quot;https://uploader.shimo.im/f/j1s6UNV1kp7Mm55p.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;曾健&lt;/p&gt;
&lt;p&gt;西安葡萄城，高级产品经理&lt;/p&gt;
&lt;p&gt;葡萄城 Wyn Enterprise 嵌入式商业智能软件的高级产品经理，拥有12年报表开发、大型数据库设计及其分析建模经验，主导多项大数据分析和可视化项目，服务的客户涵盖石油、电力、地产、医疗等各行业领域。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：基于.NET Core的嵌入式大数据分析技术研究&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;随着移动互联网的发展，数据发挥出的价值日益凸显，用户对于数据产品的需求越发旺盛，如何提升大数据计算性能、高并发下的网络吞吐能力、分布式架构下的消息队列管理，对于企业而言至关重要。本次分享将从嵌入式大数据分析技术出发，深入研究如何实现数据功能的开发和项目快速交付。&lt;/p&gt;
&lt;p&gt;37.张潇&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;612&quot; height=&quot;857&quot; src=&quot;https://uploader.shimo.im/f/tBKv0bQTPjQ4jvsu.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;张潇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;DaoCloud 资深软件工程师, Kubernetes 社区 member，kubernetes  sig-Windows 成员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在DaoCloud 负责云原生 PaaS 平台的架构和核心研发工作，最近负责基于 Prometheus  的云原生监控平台的架构与研发工作。在此之前有丰富的 net 技术栈研发经验。热爱开源，业余时间给参与 kubernetes 代码贡献。与此同时，还是第一届  .NET Conf 的 speaker ;同时受邀在 CNCF举办的 2020 Kubecon China 发表关于Windows  Container主题分享。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：云原生监控能给 . NET带来什么&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;在云原生技术变得越来越流行的今天，. NET 5为云原生而生。越来越多 . NET 的应用被容器化，拥抱云原生。当我们  .NET  技术弄潮儿在应用上云的时候我们应该关注什么呢？应用上云之后时候如预期般丝滑运行,是否可以让devops人员解放双手，专注于业务呢？本主题讲围绕云原生中的可观测性来展开，通过一个生动形象的例子来讲述  NET core 在云原生可观测性方面的思考和演进路线&lt;/p&gt;
&lt;p&gt;38.赵铭哲&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;373&quot; height=&quot;442&quot; src=&quot;https://uploader.shimo.im/f/6bVPdX2e0Ckk4PAB.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;赵铭哲&lt;/p&gt;
&lt;p&gt;山西米立信息技术有限公司CEO&amp;amp;CTO&lt;/p&gt;
&lt;p&gt;2005-2013年主要从事制造业半自动化研发及事业群MES等系统开发，2014年-2017年初主要从事房产中介行业ERP的开发及底层核心开发，2017年至今自主创业，目前我们公司做过的项目涵盖了教育，医疗，电商，矿产资源，金融，社交，社会服务，健身，IoT，自动化等领域，此次想要跟大家分享的是NCF在电子商务线上购物场景中的应用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：NCF在电子商务线上购物场景中的应用&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;议在电子商务线上购物场景中，从后台到接口再到前端，如何使用NCF框架及XncfModule来解决后台如何配置自定义活动产品，如何上传产品图片，如何通过富文本编辑器来编辑产品文案，在富文本编辑器中上传图片资源，如何在富文本编辑器中上传媒体资源，如何上传产品封面图，如何开放静态资源的访问权限给到前端使用，如何解决文件跨域的问题，如何输出WebApi的接口给到前端页面调用，如何输出WebApi的注释文档给前端开发查看，以及前端如何调用后展示等内容。&lt;/p&gt;
&lt;p&gt;39.周国庆&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;266&quot; height=&quot;281&quot; src=&quot;https://uploader.shimo.im/f/nwW2PVVb9Hp45Fkq.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;周国庆&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特来电云平台技术负责人，.NET领域的微软MVP（2020-2021）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;十多年一线研发经验，基于.NET+开源技术栈，采用微服务、分布式、平台化设计理念，从零开始搭建了特来电互联网技术平台，支撑了中国最强新能源汽车充电网的大规模应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：基于.NET技术栈的互联网技术平台揭秘&lt;/strong&gt; 较难（Advanced）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;特来电互联网技术平台，是一款高性能的、分布式的、互联网级PaaS平台，整个特来电云平台完全在其之上构建。&lt;/p&gt;
&lt;p&gt;此技术平台采用微服务、分布式、平台化的理念设计开发。&lt;/p&gt;
&lt;p&gt;本议题将从平台技术发展历程、.NET技术栈和技术架构、业务创新成果和案例分享等多个方面，带大家全面了解.NET技术体系下互联网技术平台建设的方方面面,  同时为大家分享特来电在分布式高并发、智能监控运维、快速开发交付的一些落地经验。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;40.朱永光 / 陈作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;612&quot; height=&quot;407&quot; src=&quot;https://uploader.shimo.im/f/PeAPYfhZ2Pd5CvJe.jpg!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;朱永光&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Microsoft 高级技术顾问&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从业20年，在软件架构、研发管理方面有长期的经验，目前在工作中重点关注DevOps和云原生/微服务的落地。曾连任微软最有价值专家（MVP）11届，喜欢在社区中和大家交流技术，闲暇之余会在自己的技术博客和微信公众号上分享一些经验总结文章。作为讲师多次在微软技术会议（TechEd、TechSummit）上分享最新开发技术的心得体会。微信公众号：dotNET开发经验谈&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;410&quot; height=&quot;615&quot; src=&quot;https://uploader.shimo.im/f/aFWY5hwTW6dPRqlI.jpg!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;陈作&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;深圳阿铺科技CTO，架构师&lt;/p&gt;
&lt;p&gt;十余年研发、项目管理工作经验，目前工作重点方向是devops、微服务方面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：Dapr开启微服务应用开发新世界&lt;/strong&gt; 中级（Intermediate）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;Dapr是微软发起、社区热度很高的开源项目，皆在提供一个平台中立的微服务应用开发框架。本分享将对Dapr进行基本介绍，并辅以简单示例来带领大家进入微服务开发的新世界。&lt;/p&gt;
&lt;p&gt;41.朱宗海&lt;/p&gt;
&lt;p&gt;&lt;img width=&quot;612&quot; height=&quot;1088&quot; src=&quot;https://uploader.shimo.im/f/Y81qB9Ydxbn5qAYu.png!thumbnail&quot;/&gt;&lt;/p&gt;
&lt;p&gt;朱宗海&lt;/p&gt;
&lt;p&gt;上海蔚来汽车有限公司，数字化发展软件开发与创新部，系统架构师；&lt;/p&gt;
&lt;p&gt;一名码龄20年的老码农，经历过的大大小小的系统&amp;amp;项目近百余，一直追随着技术最前沿者的脚步，不求闻达于世人，但求不落后于时代；步入不惑之年，偶尔闲暇之余回顾过往种种，思考人生和技术的本质，不禁感慨良多……&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;演讲主题：从汽车工厂总装PBS系统谈谈.Net的智能智造&lt;/strong&gt; 较难（Advanced）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主题简介：&lt;/strong&gt;今天，制造业面临着数字化转型、升级，向着智能制造业迈进，这里有无数机遇和机会！我将向大家分享一个真实的案例，从一个汽车工厂总装PBS产线系统的开发到上线来谈谈 .Net 在这场制造业数字化转型，向着智能制造业迈进过程中所拥有的巨大优势，面临的挑战以及机遇，也希望能减轻大龄码农们的一些职业忧虑。&lt;/p&gt;
&lt;p&gt;在向智能制造业的转型升级过程中，.Neter 们，你们不仅有广阔的前景，更有丰厚的钱景！&lt;/p&gt;
&lt;p&gt;工作坊：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作坊1： 使用 NCF 从 0 到 1 快速模块化开发/部署业务系统实战&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作坊简介：&lt;/strong&gt;本次工作坊由盛派开发团队亲自带领开发者使用 NCF（NeuCharFramework） 框架进行系统快速开发，进行现场实操训练，大家可以通过本次活动学习并亲自动手实现：&lt;/p&gt;
&lt;p&gt;1、5 分钟内完成快速搭建系统管理后台&lt;/p&gt;
&lt;p&gt;2、1 分钟内完成快速创建功能模块&lt;/p&gt;
&lt;p&gt;3、1 分钟内完成多数据库集成和迁移（SQL Server / MySQL 等）&lt;/p&gt;
&lt;p&gt;4、灵活切换 .NET Core 和 .NET 5应用&lt;/p&gt;
&lt;p&gt;5、使用 DevOps 进行 CI/CD 从集成到部署的全流程操作&lt;/p&gt;
&lt;p&gt;6、使用 Docker 部署 NCF 应用&lt;/p&gt;
&lt;p&gt;参与人员可以和盛派开发团队及 NCF 项目团队进行近距离的 .NET 相关技术交流。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作坊时间：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;09:30 - 16:30 （其中 12:00 - 13:00 为午餐及午休时间，组委会提供免费午餐）&lt;/p&gt;
&lt;p&gt;工作坊2： 基于 Blazor 的 C# 前端开发实战工作坊&lt;/p&gt;
&lt;p&gt;主要内容：&lt;/p&gt;
&lt;p&gt;以讲课+实践的形式，学习 Blazor 前端开发基础知识，体验用 C# 进行前后端 Web 应用开发的新姿势。&lt;/p&gt;
&lt;p&gt;适合人群：&lt;/p&gt;
&lt;p&gt;1. 对于有一定的 .NET 开发基础的开发者，可以直接使用 Blazor 构建 Web 前端应用程序；&lt;/p&gt;
&lt;p&gt;2. 对于目前使用 .NET 开发后端，JS 开发前端的开发者，可以体验 C# 相比 JS 做 .NET 前端开发的高效与一致性；&lt;/p&gt;
&lt;p&gt;3. 对于目前从事客户端开发，并想体验 Web 开发的开发者，可以在 Blazor 上获得与客户端非常相似的开发体验。&lt;/p&gt;
&lt;p&gt;课程大纲：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;09:00 - 12:00&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 课程介绍及环境准备 30分钟 9:00 - 9:40&lt;/p&gt;
&lt;p&gt;        a. 课程介绍，下载源码等资料。&lt;/p&gt;
&lt;p&gt;        b. 演示创建一个 Ant Design Blazor 模板项目。&lt;/p&gt;
&lt;p&gt;        c. 介绍一个 blazor 应用的项目结构&lt;/p&gt;
&lt;p&gt;    （相关资料会提前公布，建议提前准备。）&lt;/p&gt;
&lt;p&gt;2. 组件与页面布局开发 40分钟  9:40 - 10: 20&lt;/p&gt;
&lt;p&gt;        a. 制作整个应用的布局&lt;/p&gt;
&lt;p&gt;        b. 学习页面组件与路由配置&lt;/p&gt;
&lt;p&gt;        c. 体验一个组件的开发过程，以及模板化组件的应用&lt;/p&gt;
&lt;p&gt;3. 事件与数据绑定 40分钟 10:30 - 11:10&lt;/p&gt;
&lt;p&gt;        a. 学习原生事件的绑定，自定义事件的实现&lt;/p&gt;
&lt;p&gt;        b. 学习表单的双向绑定与验证，自定义双向绑定的实现&lt;/p&gt;
&lt;p&gt;4. 依赖注入与状态模式 40分钟 11:20 - 12:00&lt;/p&gt;
&lt;p&gt;        a. 学习 Blazor 的状态模式&lt;/p&gt;
&lt;p&gt;        b. 学习依赖注入在 Blazor 的应用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;午餐与交流 1小时&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;13:00 - 17:00&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    1. 验证与授权 40分钟 13:00 - 13:40&lt;/p&gt;
&lt;p&gt;        a. 集成 IdentityServer4 进行用户验证与授权&lt;/p&gt;
&lt;p&gt;        b. 实现前端登录页&lt;/p&gt;
&lt;p&gt;    2. JS 互操作的应用 40分钟 13:50 - 14:30&lt;/p&gt;
&lt;p&gt;        a. 通过集成 JS 地图组件学习对现有JS库的互操作&lt;/p&gt;
&lt;p&gt;    3. 发布与部署 40分钟 14:40 - 15:20&lt;/p&gt;
&lt;p&gt;        a. 介绍 Blazor 的多个托管模型&lt;/p&gt;
&lt;p&gt;        b. 学习Blazor应用的发布&lt;/p&gt;
&lt;p&gt;        c. 演示将 Blazor 发布到 Github，并通过 Azure App Service 部署上线&lt;/p&gt;
&lt;p&gt;    4. Q&amp;amp;A 与自由练习 60分钟 15:20 - 16:20&lt;/p&gt;
&lt;p&gt;        a. 完善作品与问答交流环节&lt;/p&gt;
&lt;p&gt;    5. 课后交流 16:20 - 17:00&lt;/p&gt;

&lt;p&gt;报名方式&lt;/p&gt;
&lt;p&gt;活动行：&lt;a href=&quot;https://www.huodongxing.com/event/3571957681711&quot;&gt;https://www.huodongxing.com/event/3571957681711&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&quot;Scan me!&quot; src=&quot;data:image/png;base64,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&quot;/&gt;&lt;/p&gt;
&lt;p&gt;百格活动：&lt;a href=&quot;https://www.bagevent.com/event/6975865&quot;&gt;https://www.bagevent.com/event/6975865&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/510/202011/510-20201116181109151-53491052.png&quot;&gt;&lt;img width=&quot;185&quot; height=&quot;178&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2020.cnblogs.com/blog/510/202011/510-20201116181109520-1107203408.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;现场参会的福利绝对是超值，不仅仅可以和来自全国各地的同仁一起共谋dotnet生态发展大计，还可以体验上有天堂，下有苏杭的苏州美景，同时也少不了苏州美食。&lt;/p&gt;
</description>
<pubDate>Thu, 10 Dec 2020 23:31:00 +0000</pubDate>
<dc:creator>张善友</dc:creator>
<og:description>简介 / Summary 简介 / Summary 分享嘉宾 / Speakers 分享嘉宾 / Speakers 主会场嘉宾： 1.徐明强博士 3.敖琪 4.王鸿 嘉宾 2.陈超超 3.仇华 4.董</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/shanyou/p/14118444.html</dc:identifier>
</item>
<item>
<title>Tensorflow学习笔记No.10 - VioletOrz</title>
<link>http://www.cnblogs.com/VioletOrz/p/14118391.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/VioletOrz/p/14118391.html</guid>
<description>&lt;p&gt;&lt;span&gt;使用函数式API构建&lt;span&gt;多输出模型&lt;/span&gt;完成&lt;span&gt;多标签&lt;/span&gt;分类任务。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;数据集下载链接：&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://pan.baidu.com/s/1JtKt7KCR2lEqAirjIXzvgg&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1JtKt7KCR2lEqAirjIXzvgg&lt;/a&gt; &lt;span&gt;提取码：2kbc&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1.读取数据并构建数据集&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;详细的API介绍在&lt;a href=&quot;https://www.cnblogs.com/VioletOrz/p/13779995.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;ensorflow学习笔记5.0&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;中均有提及，这里只简单讲述方法流程并展示代码。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;1.1图片数据读取&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;首先导入需要的模块(运行环境为jupyternotebook)。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; tensorflow as tf
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; pathlib
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; matplotlib.pyplot as plt
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; random
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; %matplotlib inline
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;创建地址为数据所在位置的根目录，所创建的data_root为一个WindowsPath类型的变量。。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; data_dir = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E:/BaiduNetdiskDownload/多输出模型数据集（同时预测物品和颜色）/multi-output-classification/dataset&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt; data_root = pathlib.Path(data_dir)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;读取该目录下所有的jpg/jpeg文件，图片存储位置为dataset/(标签文件夹)/*，所以使用.glob('*/*')来获取所有的图片文件。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; all_image_path = list(data_root.glob(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*/*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; image_count = len(all_image_path) #共计2525张图片
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;1.2标签读取&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在读取完图片之后，我们还要读取图片对应的标签信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们所进行的是一个衣服分类任务，每件衣服都有颜色和类型两个标签，我们需要提取出每张图片对应的标签。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;图片存储在名字为“颜色_类型”的文件夹下，对应了这些图片的颜色和类型，所以我们对文件夹名字进行处理即可。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;首先我们获取所有含有标签信息的文件夹名称。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; label_names = sorted(item.name &lt;span&gt;for&lt;/span&gt; item &lt;span&gt;in&lt;/span&gt; data_root.glob(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;*&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) &lt;span&gt;if&lt;/span&gt; item.is_dir())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;label_names中包含了所有的标签名称——&lt;/span&gt;&lt;span&gt;['black_jeans', 'black_shoes', 'blue_dress', 'blue_jeans', 'blue_shirt', 'red_dress', 'red_shirt']。总共七种类别，为三种颜色类别和四种衣服类型的组合。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下一步奖颜色和类型标签分别提取出来，使用.split('_')对字符串进行分割，得到每个复合标签对应的两个基本标签。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; color_label = set(name.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0] &lt;span&gt;for&lt;/span&gt; name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; label_names)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; item_label = set(name.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[1] &lt;span&gt;for&lt;/span&gt; name &lt;span&gt;in&lt;/span&gt; label_names)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后我们通过这两个存有标签的集合构建从标签字符串映射到数字编号的字典。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; color_to_indx = dict((name, indx) &lt;span&gt;for&lt;/span&gt; indx, name &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(color_label))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; item_to_indx = dict((name, indx) &lt;span&gt;for&lt;/span&gt; indx, name &lt;span&gt;in&lt;/span&gt; enumerate(item_label))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;现在我们仅仅是获得了字典，而没有获得与图片对应的基本标签，下一步我们着手制作这些标签，一个图片应该对应两个标签。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先获取每个图片与之对应的复合类别标签(颜色_类型标签)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用.parent.name方法获得WindowsPath对象的父文件夹名字，即图片的标签。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; all_image_label = list(pathlib.Path(path).parent.name &lt;span&gt;for&lt;/span&gt; path &lt;span&gt;in&lt;/span&gt; all_image_path)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;然后通过两个字典构建出每个图片的两个数字标签。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; color_label = list(color_to_indx[label.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[0]] &lt;span&gt;for&lt;/span&gt; label &lt;span&gt;in&lt;/span&gt;&lt;span&gt; all_image_label)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; item_label = list(item_to_indx[label.split(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;_&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)[1]] &lt;span&gt;for&lt;/span&gt; label &lt;span&gt;in&lt;/span&gt; all_image_label)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;1.3数据集的构建&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在获取完标签和图像地址后，我们利用这些信息来制作一个标准的数据集。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先定义一个图像处理函数，用于读取并解码图像，同时归一化为统一的尺寸。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;def&lt;/span&gt;&lt;span&gt; load_pregrosess_image(path):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     image =&lt;span&gt; tf.io.read_file(path)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     image = tf.image.decode_jpeg(image, channels = 3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     image = tf.image.resize(image, [224, 224&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     image =&lt;span&gt; tf.cast(image, tf.float32)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;     image = image / 255
&lt;span&gt;7&lt;/span&gt;     &lt;span&gt;#&lt;/span&gt;&lt;span&gt;image = image * 2 - 1&lt;/span&gt;
&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; image
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用tf.data中提供的方法对图片地址进行切片操作，变成一个dateset类型的数据，然后使用.map方法利用刚刚定义的函数将地址处理为图像。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; train_image_ds =&lt;span&gt; tf.data.Dataset.from_tensor_slices(all_image_path)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; image_data = train_image_ds.map(load_pregrosess_image)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;同样的把两个标签也切片封装为dataset类型的文件，最后再把图片和标签合并变成完整的数据集。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; label_data =&lt;span&gt; tf.data.Dataset.from_tensor_slices((color_label, item_label))
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; dataset = tf.data.Dataset.zip((image_data, label_data))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;随后按照8：2分为训练集和验证集即可。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; BATCHSIZE = 8
&lt;span&gt;2&lt;/span&gt; train_count = int(image_count * 0.8&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; test_count = image_count -&lt;span&gt; train_count
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt; train_dataset =&lt;span&gt; dataset.take(train_count)
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; test_dataset =&lt;span&gt; dataset.skip(train_count)
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 
&lt;span&gt;8&lt;/span&gt; train_dataset = train_dataset.shuffle(train_count).repeat(&lt;span&gt;).batch(BATCHSIZE)
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; test_dataset = test_dataset.repeat().batch(BATCHSIZE)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;至此数据集构建完毕，下一步将搭建模型并进行训练。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2.多输出模型&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;由于我们要预测图片的两个属性，颜色和衣服类型，同样的我们也需要两个输出，然而线性模型显然无法满足我们的需求。所以我们使用函数式API构建非线性模型来完成目标。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;2.1构建模型&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;我们的模型结构为一个卷积神经网络和两个分类器，如图所示。(&lt;span&gt;3D画图随手一画很丑见谅(。﹏。*)&lt;/span&gt;）&lt;img src=&quot;https://img2020.cnblogs.com/blog/1924931/202012/1924931-20201211013135329-3894267.png&quot; alt=&quot;&quot; width=&quot;646&quot; height=&quot;373&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;由卷积神经网络提取特征，然后通过两个分类器输出图片在两个不同标签上的分类结果。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;我们采用预训练的Mobile-Net作为卷积部分并冻结其可训练参数，使用函数式API搭建模型，&lt;strong&gt;&lt;span&gt;注意这里有两个输出层，在keras.Model方法中用列表形式作为输入&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;，同时给两个输出层添加name参数进行命名便于区分和后续调用&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;函数式API在&lt;a href=&quot;https://www.cnblogs.com/VioletOrz/p/13770506.html&quot; target=&quot;_blank&quot;&gt;&lt;strong&gt;&lt;span&gt;Tensorflow学习笔记No.2&lt;/span&gt;&lt;/strong&gt;&lt;/a&gt;中有详细介绍这里也不再做赘述，预训练网络的使用在&lt;a href=&quot;https://www.cnblogs.com/VioletOrz/p/13869628.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;&lt;strong&gt;Tensorflow学习笔记No.8&lt;/strong&gt;&lt;/span&gt;&lt;/a&gt;中有相关介绍。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; input = tf.keras.Input(shape = (224, 224, 3&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; mobile_net = tf.keras.applications.MobileNetV2(weights = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;imagenet&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, input_shape = (224, 224, 3), include_top =&lt;span&gt; False)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; mobile_net.trianable =&lt;span&gt; False
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; x =&lt;span&gt; mobile_net(input)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; x =&lt;span&gt; tf.keras.layers.GlobalAveragePooling2D()(x)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; x1 = tf.keras.layers.Dense(1024, activation = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(x)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; x2 = tf.keras.layers.Dense(1024, activation = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;relu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(x)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; output_color = tf.keras.layers.Dense(3, activation = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;output_color&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(x1)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; output_item = tf.keras.layers.Dense(4, activation = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;softmax&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, name = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;output_item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)(x2)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt; model = tf.keras.Model(inputs = input, outputs = [output_color, output_item])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;将全连接层和softmax组合在一起作为分类器，按照上图所示方式进行连接即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;得到的模型如下图所示，使用model.summary()进行查看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1924931/202012/1924931-20201211014136109-261236833.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt; &lt;span&gt;2.2模型训练&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;不熟悉model.complie()和model.fit()方法的小伙伴可以翻看&lt;span&gt;&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/VioletOrz/p/13770380.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Tensorflow学习笔记No.1&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;进行学习这里也不在赘述(&lt;span&gt;主要是因为懒&lt;/span&gt;)。&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;注意，因为有两个分类器，所以对每个分类器要单独规定一个损失函数&lt;/span&gt;，使用字典的方式按照{输出层名称:损失函数，......}的格式指定分类器，前面对卷积命名也是方便此步骤的进行。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;steps_per_epoch和&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;validation_steps代表了训练集和验证集每一个epoch需要训练多少步，也就是数据总数/BATCH_SIZE。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意学习率设置为0.0001等较小的学习率，使用较大的学习率会导致loss异常增大。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; model.compile(optimizer = tf.keras.optimizers.Adam(learning_rate=0.0001&lt;span&gt;),
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;               loss = {&lt;span&gt;'&lt;/span&gt;&lt;span&gt;output_color&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sparse_categorical_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                       &lt;span&gt;'&lt;/span&gt;&lt;span&gt;output_item&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:&lt;span&gt;'&lt;/span&gt;&lt;span&gt;sparse_categorical_crossentropy&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;},
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;               metrics = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;acc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;             )
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; history =&lt;span&gt; model.fit(train_dataset,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     steps_per_epoch = train_count//&lt;span&gt;BATCHSIZE,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     epochs = 5&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     validation_data =&lt;span&gt; test_dataset,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     validation_steps = test_count//&lt;span&gt;BATCHSIZE,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                    )
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;由于使用了预训练模型，只需要5个epochs便可以达到90%以上的准确率，得到如下所示结果(仅供参考)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1924931/202012/1924931-20201211020133518-159833614.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;到这里多输出模型的实例就结束了，前段时间由于事情较多断更了一段时间，后续会继续更新Tensorflow的学习笔记。由于本人正在参加AI算法竞赛(入门菜鸡)，后续可能会分享一些与竞赛有关的内容，撒悠娜拉 Bey~ o(*￣▽￣*)ブ。&lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Thu, 10 Dec 2020 18:07:00 +0000</pubDate>
<dc:creator>VioletOrz</dc:creator>
<og:description>多输出模型 使用函数式API构建多输出模型完成多标签分类任务。 数据集下载链接：https://pan.baidu.com/s/1JtKt7KCR2lEqAirjIXzvgg&amp;#160;提取码：2kb</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/VioletOrz/p/14118391.html</dc:identifier>
</item>
<item>
<title>Power BI八年回望记 - 哥本哈士奇(aspnetx)</title>
<link>http://www.cnblogs.com/aspnetx/p/14118345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aspnetx/p/14118345.html</guid>
<description>&lt;p&gt;本人从事BI，数据仓库领域相关工作15个年头，这15年目睹了这个方向从火爆到逐渐被大数据领域不断吞食。中间零散关注Power BI好长时间，也算目睹了它的成长。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;149&quot;&gt;
&lt;p&gt;本人从事BI，数据仓库领域相关工作15个年头，这15年目睹了这个方向从火爆到逐渐被大数据领域不断吞食。中间零散关注Power BI好长时间，也算目睹了它的成长。&lt;/p&gt;
&lt;p&gt;那天在网络上搜索power bi，无意搜索到我在2013年写过的文章。那个时候还叫Power BI for Office 365，微软还在Office产品线上不断的去做尝试。如今随着微软产品线的调整，它的名字也彻底变了。&lt;/p&gt;
&lt;p&gt;回望这八年，能看到的是power bi确实是进步了不少，正在逐步拉近跟Tableau的距离，但也正如我那段时间总结：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;span&gt;感觉&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;power BI&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;和&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;Tableau&lt;/span&gt;&lt;/em&gt;&lt;em&gt;&lt;span&gt;比较起来，一个是速溶咖啡，一个是现磨咖啡，各有各的好。但也不得不说，随着萃取技术的升级，现在有些速溶咖啡的口感也正在直逼现磨咖啡的口感。当然，不管是速溶的还是现磨的，咖啡豆的品质也很重要，就好像你有什么样的数据一样。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;也就是说，工具再牛是其次，关键是看你有什么样的数据。&lt;/p&gt;
&lt;p&gt;如今这两大工具都在遵循相同的套路，说微软抄了些Tableau的东西也不为过，对于从业者来说，如果你有SQL的功底（熟悉怎么去组织数据），以及MDX的功底（去理解那些行列轴），再加上点Data上的敏感度（看到数据idea立刻就能在脑子里组织起来），以及对各种图表的深刻理解（把数据好看易懂的方式表达出来），那么上手哪一个都不会特别困难。&lt;/p&gt;

&lt;p&gt;再说回来它的竞争对手。在某魔力象限近年来的统计，在这个领域显示的是微软完全领先了，首先我认同这个结果，这确实体现了微软在整个战略布局上的考虑，软件层面就不说了，优势还体现在微软在云端的战略部署，以及成功的商业运作（不成功的也很多这里只吐槽就不例举了），这些都是任何一个软件厂商比拟不了的，人家拼的就是一个综合实力。&lt;/p&gt;
&lt;p&gt;但在部分细节领域里应该还是能看到有差距，比如：&lt;/p&gt;
&lt;p&gt;Tableau desktop开发的报表，可以部署到我自己的服务，或者SAAS服务。&lt;/p&gt;
&lt;p&gt;但是在Power BI中，你得用两个Desktop去做同样的事情，尽管做一个报告的步骤差不多，但是你必须要重做一套。我个人觉得微软在后续的版本会将其统一，但这个时间不会很快，要知道三年前就是这个样子了。&lt;/p&gt;
&lt;p&gt;当然也许你会说云是一个趋势，确实现在好多企业的Sales Marketing数据都可以上云，但还没有哪个企业敢开放到HR， Finance的数据也上云，除非他们公司的股价不高经得起折腾。&lt;/p&gt;
&lt;p&gt;在Tableau Server里，一些企业级安全配置比如SSO相对比较容易，甚至有直接的UI可以去配置，而且网络上的资料也比较好找，UI上没有接口的，也会有相应的命令行工具可以去配置。&lt;/p&gt;
&lt;p&gt;Power BI对比起来想去实现相对费劲。也许你会说AD是其一个优势，但好多企业都会要求用自己的SSO，甚至两重身份验证的方式。&lt;/p&gt;
&lt;p&gt;最后不得不说Power BI的圈子，还是有点小，这里就用一个最简单粗暴的方法去衡量：用不同的关键字去搜索各大不同招聘网站，就很容易就能看到差距（也许这个时候很多power BI的追随者早就哭晕在了厕所，但哥可是见过当年windows phone世面的人）。&lt;/p&gt;

&lt;p&gt;当然Power BI也有比较好的地方：&lt;/p&gt;
&lt;p&gt;你要是熟悉Office或者Excel，ACCESS的话，那么上手Power BI应该很快，因为都是自家的东西，做起东西来都是一个套路。&lt;/p&gt;
&lt;p&gt;Tableau的话是独树一帜，你需要花时间去熟悉这个套路。&lt;/p&gt;
&lt;p&gt;另外就是这个价格，Tableau不管你用不用发布功能，都需要买Desktop的授权。即使有一个Public的版本，你还不能把结果保留在本地，只能在云端。&lt;/p&gt;
&lt;p&gt;Power BI Desktop你可以直接下载不需要序列号，如果需要发布的话才需要花钱。我觉得能满足相当一大部分人的需求了。&lt;/p&gt;
&lt;p&gt;还有一点，微软的产品大多有developer版，本地的Power BI也一样，对于开发人员来说少了一个门槛。但对于Tableau来说现在还是高高在上的状态。&lt;/p&gt;

&lt;p&gt;最后，两种工具的大多数功能，就是大多数人能看得到的功能，基本上已经达到了麦当劳对肯德基，可口可乐对百事可乐的成都，就看个人的喜好和口味。总体来说比较好的方面是我们能看到两家产品在竞争中不断的升级迭代，促使这个领域快速的发展，而不至于一家独大。&lt;/p&gt;

&lt;p&gt;最后的最后想吐槽下国内最热的某搜索引擎，当你去搜索power BI的时候，第一个结果居然是Tableau，而且结果导航很有迷惑性。我好难相信Tableau会在这个搜索引擎上打微软的擦边球，好比比亚迪，去蹭宾利的热度我能理解，但是这种反过来的方式我好难脑补背后的故事。也许，只是因为微软当初取了一个霸气的名字，power BI，正所谓名正言就容易顺。&lt;/p&gt;

&lt;p&gt;本文写于2020年12月，再过同样的八年回来再看今天写的东西不知道又会是什么感觉。不过八年在这个领域会发生些什么呢，这里做个疯狂的预测：&lt;/p&gt;
&lt;p&gt;l  Tableau会消失或者被收购，本土会有优秀的平台诞生，开源领域也会有更多的可替代品，但仍是微软独大。&lt;/p&gt;
&lt;p&gt;l  大数据领域已经相当成熟，甚至可以取代数据仓库。&lt;/p&gt;
&lt;p&gt;l  AI在线功能会更多的集成到这些XXX Desktop之中。&lt;/p&gt;
&lt;p&gt;l  更多的企业会拥抱云，更多的数据会上云。&lt;/p&gt;
&lt;p&gt;l  传统行业会放弃自研发的物联网转而和科技厂商合作，术业有专攻。&lt;/p&gt;
&lt;p&gt;l  读过本文的人在北上广都会有套自己的房子。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Thu, 10 Dec 2020 16:46:00 +0000</pubDate>
<dc:creator>哥本哈士奇(aspnetx)</dc:creator>
<og:description>本人从事BI，数据仓库领域相关工作15个年头，这15年目睹了这个方向从火爆到逐渐被大数据领域不断吞食。中间零散关注Power BI好长时间，也算目睹了它的成长。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/aspnetx/p/14118345.html</dc:identifier>
</item>
<item>
<title>海量数据架构下如何保证Mycat的高可用？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/14118285.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/14118285.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;13.513981358189&quot;&gt;
&lt;p&gt;在《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MzE1NTIzNA==&amp;amp;mid=2247490191&amp;amp;idx=1&amp;amp;sn=641966023ac4e950ace429b7ff0413c7&amp;amp;chksm=cee50542f9928c54a56aa8ec265ead9d3f97e76c724024fb881cb49b7013cc8c105d9cf37975&amp;amp;token=1450448620&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;冰河，能讲讲Mycat如何实现MySQL的读写分离吗？&lt;/a&gt;》一文中，我们实现了使用Mycat实现MySQL的读写分离。然而，此时的Mycat只有一个节点，如果Mycat节点宕机了，则整个MySQL集群将不可用，所以，我们有必要保证Mycat节点的高可用。那如何保证Mycat节点的高可用呢？今天，我们就一起来聊聊这个话题。一起搭建一套Mycat的高可用集群。&lt;/p&gt;

&lt;p&gt;目前，我也在业余时间开发和维护Mycat源码，小伙伴们在学习和使用Mycat时，遇到问题也可以加我微信【sun_shine_lyz】共同交流哦！&lt;/p&gt;

&lt;p&gt;注：文章已经收录到：&lt;/p&gt;
&lt;p&gt;GitHub：&lt;a href=&quot;https://github.com/sunshinelyz/technology-binghe&quot; target=&quot;_blank&quot;&gt;https://github.com/sunshinelyz/technology-binghe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitee：&lt;a href=&quot;https://gitee.com/binghe001/technology-binghe&quot; target=&quot;_blank&quot;&gt;https://gitee.com/binghe001/technology-binghe&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;软件版本&quot;&gt;软件版本&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;操作系统：CentOS-6.8-x86_64&lt;/li&gt;
&lt;li&gt;JDK版本：jdk1.8&lt;/li&gt;
&lt;li&gt;HAProxy版本：haproxy-1.5.19.tar.gz&lt;/li&gt;
&lt;li&gt;Mycat版本：Mycat-server-1.6 (自行下载源码编译)&lt;/li&gt;
&lt;li&gt;MySQL版本：mysql-5.7&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;部署规划&quot;&gt;部署规划&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201210235108828.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;mycat集群架构图&quot;&gt;Mycat集群架构图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201210235116713.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图解说明：&lt;/p&gt;
&lt;p&gt;HAProxy负责将请求分发到Mycat上，起到负载均衡的作用，同时HAProxy也能检测到Mycat是否存活，HAProxy只会将请求转发到存活的Mycat上。如果一台Mycat服务器宕机，HAPorxy转发请求时不会转发到宕机的Mycat上，所以Mycat依然可用。&lt;/p&gt;
&lt;h2 id=&quot;mycat节点2的部署&quot;&gt;Mycat节点2的部署&lt;/h2&gt;
&lt;p&gt;Mycat主机2（liuyazhuang134，192.168.209.134）请参考《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MzE1NTIzNA==&amp;amp;mid=2247490191&amp;amp;idx=1&amp;amp;sn=641966023ac4e950ace429b7ff0413c7&amp;amp;chksm=cee50542f9928c54a56aa8ec265ead9d3f97e76c724024fb881cb49b7013cc8c105d9cf37975&amp;amp;token=1450448620&amp;amp;lang=zh_CN#rd&quot; target=&quot;_blank&quot;&gt;冰河，能讲讲Mycat如何实现MySQL的读写分离吗？&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;注意：liuyazhuang133（192.168.209.133）和 liuyazhuang134（192.168.209.134） 中都要加上（或更新）主机名映射配置。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;# vi /etc/hosts
192.168.209.131 liuyazhuang131
192.168.209.132 liuyazhuang132
192.168.209.133 liuyazhuang133
192.168.209.134 liuyazhuang134
192.168.209.135 liuyazhuang135
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;配置mycat状态检查服务&quot;&gt;配置Mycat状态检查服务&lt;/h2&gt;
&lt;p&gt;注意：需要在Mycat节点主机上配置。&lt;/p&gt;
&lt;p&gt;Mycat服务主机（liuyazhuang133、liuyazhuang134）上需要增加Mycat服务的状态检测脚本，并开放相应的检测端口，以提供给HAProxy对Mycat的服务状态进行检测判断。可以使用xinetd来实现，通过xinetd，HAProxy可以用httpchk来检测Mycat的存活状态。（xinetd即extended internet daemon，xinetd是新一代的网络守护进程服务程序，又叫超级Internet服务器。经常用来管理多种轻量级Internet服务。xinetd提供类似于inetd+tcp_wrapper的功能，但是更加强大和安全。xinetd为linux系统的基础服务）&lt;/p&gt;
&lt;p&gt;（1）安装xinetd&lt;/p&gt;
&lt;p&gt;如果xinetd还没有安装，可使用如下命令安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;yum install xinetd
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）添加 includedir /etc/xinetd.d&lt;/p&gt;
&lt;p&gt;检查/etc/xinetd.conf的末尾是否有 includedir /etc/xinetd.d ，没有就加上&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim /etc/xinetd.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201210235307141.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）创建/etc/xinetd.d 目录&lt;/p&gt;
&lt;p&gt;检查 /etc/xinetd.d 目录是否存在，不存在则创建&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mkdir /etc/xinetd.d/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）增加Mycat存活状态检测服务配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;touch /etc/xinetd.d/mycat_status
vi /etc/xinetd.d/mycat_status
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;service mycat_status
{
flags = REUSE
## 使用该标记的socket_type为stream，需要设置wait为no
socket_type = stream ## 封包处理方式，Stream为TCP数据包
port = 48700 ## 服务监听端口
wait = no ## 表示不需等待，即服务将以多线程的方式运行
user = root ## 执行此服务进程的用户
server =/usr/local/bin/Mycat_status ## 需要启动的服务脚本
log_on_failure += USERID ## 登录失败记录的内容
disable = no ## 要启动服务，将此参数设置为no
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）添加 /usr/local/bin/Mycat_status 服务脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;touch /usr/local/bin/mycat_status
vim /usr/local/bin/mycat_status
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash
#/usr/local/bin/mycat_status.sh
# This script checks if a Mycat server is healthy running on localhost.
# It will return:
# &quot;HTTP/1.x 200 OK\r&quot; (if Mycat is running smoothly)
# &quot;HTTP/1.x 503 Internal Server Error\r&quot; (else)
Mycat=`/usr/local/Mycat/bin/Mycat status | grep 'not running' | wc -l`
if [ &quot;$Mycat&quot; = &quot;0&quot; ]; then
/bin/echo -e &quot;HTTP/1.1 200 OK\r\n&quot;
else
/bin/echo -e &quot;HTTP/1.1 503 Service Unavailable\r\n&quot;
fi
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）给新增脚本赋予可执行权限&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;chmod a+x /usr/local/bin/mycat_status
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（7）在 /etc/services 中加入 mycat_status 服务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vi /etc/services
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在末尾加入：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mycat_status 48700/tcp # mycat_status
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020121023514210.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;保存后，重启xinetd服务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;service xinetd restart
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（8）验证mycat_status服务是否成功启动&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;netstat -antup|grep 48700
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201210235158893.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;能看到上图这样的信息，说明服务配置成功。&lt;/p&gt;
&lt;p&gt;（9）Mycat服务主机的防火墙上打开 48700端口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vi /etc/sysconfig/iptables
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;-A INPUT -m state --state NEW -m tcp -p tcp --dport 48700 -j ACCEPT
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;保存后重启防火墙&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;service iptables restart
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;脚本测试：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/usr/local/bin/mycat_status
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;haproxy介绍&quot;&gt;HAProxy介绍&lt;/h2&gt;
&lt;p&gt;HAProxy官网：&lt;a href=&quot;http://www.haproxy.org/&quot; target=&quot;_blank&quot;&gt;http://www.haproxy.org/&lt;/a&gt;&lt;br/&gt;HAProxy各版本的官方文档：&lt;a href=&quot;http://cbonte.github.io/haproxy-dconv/index.html&quot; target=&quot;_blank&quot;&gt;http://cbonte.github.io/haproxy-dconv/index.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;HAProxy 是一款提供高可用性、负载均衡以及基于TCP（第四层）和HTTP（第七层）应用的代理软件，支持虚拟主机，它是免费、快速并且可靠的一种解决方案。&lt;/p&gt;
&lt;p&gt;HAProxy目前主要有三个版本：1.4、1.5、1.6、1.7，CentOS6.6自带的RPM包为1.5的。&lt;/p&gt;
&lt;p&gt;HAProxy1.5版开始，支持SSL、DDoS防护等功能，可看官网说明：&lt;br/&gt;version 1.5 : the most featureful version, supports SSL, IPv6, keep-alive, DDoS protection, etc...&lt;br/&gt;Mycat官方推荐使用HAProxy做MyCat的高可用负载均衡代理。&lt;/p&gt;
&lt;h2 id=&quot;haproxy的安装&quot;&gt;HAProxy的安装&lt;/h2&gt;
&lt;p&gt;在192.168.209.135服务器上进行安装。&lt;/p&gt;
&lt;p&gt;（1）下载（或上传） haproxy-1.5.19.tar.gz 到 /usr/local/src，解压安装&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd /usr/local/src/
wget http://www.haproxy.org/download/1.5/src/haproxy-1.5.19.tar.gz
tar -zxvf haproxy-1.5.19.tar.gz
cd haproxy-1.5.19
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（2）如需了解安装注意点，可查看HAProxy的软件说明&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;less README
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）安装编译所需的依赖包&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;yum install gcc gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（4）编译&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;make TARGET=linux2628 ARCH=x86_64 USE_PCRE=1 USE_OPENSSL=1 USE_ZLIB=1 PREFIX=/usr/local/haproxy
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;TARGET是指定内核版本，高于2.6.28的建议设置为linux2628，Linux操作系统内核版本查看命令# uname -r， ARCH指定系统架构，openssl pcre zlib 这三个包需要安装不然不支持&lt;/p&gt;
&lt;p&gt;（5）创建安装目录 /usr/local/haproxy&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mkdir /usr/local/haproxy
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）执行安装&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;make install PREFIX=/usr/local/haproxy
install -d &quot;/usr/local/haproxy/sbin&quot;
install haproxy &quot;/usr/local/haproxy/sbin&quot;
install -d &quot;/usr/local/haproxy/share/man&quot;/man1
install -m 644 doc/haproxy.1 &quot;/usr/local/haproxy/share/man&quot;/man1
install -d &quot;/usr/local/haproxy/doc/haproxy&quot;
for x in configuration architecture haproxy-en haproxy-fr; do \
install -m 644 doc/$x.txt &quot;/usr/local/haproxy/doc/haproxy&quot; ; \
done
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（7）创建配置文件目录&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mkdir -p /usr/local/haproxy/conf
mkdir -p /etc/haproxy/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（8）从配置文件模版复制配置文件，并添加配置文件软连接&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cp /usr/local/src/haproxy-1.5.19/examples/haproxy.cfg /usr/local/haproxy/conf/
ln -s /usr/local/haproxy/conf/haproxy.cfg /etc/haproxy/haproxy.cfg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（9）拷贝错误页面，并添加目录软连接（HTTP模式选配）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cp -r /usr/local/src/haproxy-1.5.19/examples/errorfiles /usr/local/haproxy/
ln -s /usr/local/haproxy/errorfiles /etc/haproxy/errorfiles
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（10）拷贝开机启动文件，并赋予可执行权限&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cp /usr/local/src/haproxy-1.5.19/examples/haproxy.init /etc/rc.d/init.d/haproxy
chmod +x /etc/rc.d/init.d/haproxy
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（11）添加haproxy命令脚本软连接&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;ln -s /usr/local/haproxy/sbin/haproxy /usr/sbin
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（12）设置HAProxy开机启动&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;chkconfig --add haproxy
chkconfig haproxy on
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;搭建mycat负载均衡集群&quot;&gt;搭建Mycat负载均衡集群&lt;/h2&gt;
&lt;p&gt;这里，我们使用HAProxy来搭建Mycat负载均衡集群。HAProxy支持TCP（第四层）和HTTP（第七层）应用的代理，本节课程我们使用HAProxy来做MyCat的负载均衡代理使用的是TCP模式。在4层模式下HAProxy仅在客户端和服务器之间转发双向流量。HAProxy配置简单，拥有非常不错的服务器健康检查功能，当其代理的后端服务器出现故障，HAProxy会自动将该服务器摘除，故障恢复后会自动将该服务器加入进来｡&lt;/p&gt;
&lt;p&gt;（1）修改haproxy.cfg 配置文件&lt;/p&gt;
&lt;p&gt;具体参数说明可参考官方配置文档 /usr/local/haproxy/doc/haproxy/configuration.txt或GitHub连接：&lt;a href=&quot;http://cbonte.github.io/haproxy-dconv/configuration-1.5.html&quot; target=&quot;_blank&quot;&gt;http://cbonte.github.io/haproxy-dconv/configuration-1.5.html&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vi /usr/local/haproxy/conf/haproxy.cfg
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编辑后的文件内容如下所示。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;## global配置中的参数为进程级别的参数，通常与其运行的操作系统有关

global

log 127.0.0.1 local0 info ## 定义全局的syslog服务器，最多可以定义2个

### local0是日志设备，对应于/etc/rsyslog.conf中的配置，默认回收info的日志级别

#log 127.0.0.1 local1 info

chroot /usr/share/haproxy ## 修改HAProxy的工作目录至指定的目录并在放弃权限之前执行

### chroot() 操作，可以提升 haproxy 的安全级别

group haproxy ## 同gid，不过这里为指定的用户组名

user haproxy ## 同uid，但这里使用的为用户名

daemon ## 设置haproxy后台守护进程形式运行

nbproc 1 ## 指定启动的haproxy进程个数，

### 只能用于守护进程模式的haproxy；默认为止启动1个进程，

### 一般只在单进程仅能打开少数文件描述符的场中中才使用多进程模式

maxconn 4096 ## 设定每个haproxy进程所接受的最大并发连接数，

### 其等同于命令行选项&quot;-n&quot;，&quot;ulimit-n&quot;自动计算的结果正式参照从参数设定的

# pidfile /var/run/haproxy.pid ## 进程文件（默认路径 /var/run/haproxy.pid）

node liuyazhuang135 ## 定义当前节点的名称，用于HA场景中多haproxy进程共享同一个IP地址时

description liuyazhuang135 ## 当前实例的描述信息

## defaults：用于为所有其他配置段提供默认参数，这默认配置参数可由下一个&quot;defaults&quot;所重新设定

defaults

log global ## 继承global中log的定义

mode http ## mode:所处理的模式 (tcp:四层 , http:七层 , health:状态检查,只会返回OK)

### tcp: 实例运行于纯tcp模式，在客户端和服务器端之间将建立一个全双工的连接，

#### 且不会对7层报文做任何类型的检查，此为默认模式

### http:实例运行于http模式，客户端请求在转发至后端服务器之前将被深度分析，

#### 所有不与RFC模式兼容的请求都会被拒绝

### health：实例运行于health模式，其对入站请求仅响应“OK”信息并关闭连接，

#### 且不会记录任何日志信息 ，此模式将用于相应外部组件的监控状态检测请求

option httplog

retries 3

option redispatch ## serverId对应的服务器挂掉后,强制定向到其他健康的服务器

maxconn 2000 ## 前端的最大并发连接数（默认为2000）

### 其不能用于backend区段，对于大型站点来说，可以尽可能提高此值以便让haproxy管理连接队列，

### 从而避免无法应答用户请求。当然，此最大值不能超过“global”段中的定义。

### 此外，需要留心的是，haproxy会为每个连接维持两个缓冲，每个缓存的大小为8KB，

### 再加上其他的数据，每个连接将大约占用17KB的RAM空间，这意味着经过适当优化后 ，

### 有着1GB的可用RAM空间时将维护40000-50000并发连接。

### 如果指定了一个过大值，极端场景中，其最终所占据的空间可能会超过当前主机的可用内存，

### 这可能会带来意想不到的结果，因此，将其设定一个可接受值放为明智绝对，其默认为2000

timeout connect 5000ms ## 连接超时(默认是毫秒,单位可以设置us,ms,s,m,h,d)

timeout client 50000ms ## 客户端超时

timeout server 50000ms ## 服务器超时

## HAProxy的状态信息统计页面

listen admin_stats

bind :48800 ## 绑定端口

stats uri /admin-status ##统计页面

stats auth admin:admin ## 设置统计页面认证的用户和密码，如果要设置多个，另起一行写入即可

mode http

option httplog ## 启用日志记录HTTP请求

## listen: 用于定义通过关联“前端”和“后端”一个完整的代理，通常只对TCP流量有用

listen mycat_servers

bind :3307 ## 绑定端口

mode tcp

option tcplog ## 记录TCP请求日志

option tcpka ## 是否允许向server和client发送keepalive

option httpchk OPTIONS * HTTP/1.1\r\nHost:\ www ## 后端服务状态检测

### 向后端服务器的48700端口（端口值在后端服务器上通过xinetd配置）发送 OPTIONS 请求

### (原理请参考HTTP协议) ，HAProxy会根据返回内容来判断后端服务是否可用.

### 2xx 和 3xx 的响应码表示健康状态，其他响应码或无响应表示服务器故障。

balance roundrobin ## 定义负载均衡算法，可用于&quot;defaults&quot;、&quot;listen&quot;和&quot;backend&quot;中,默认为轮询方式

server mycat_01 192.168.209.133:8066 check port 48700 inter 2000ms rise 2 fall 3 weight 10

server mycat_02 192.168.209.134:8066 check port 48700 inter 2000ms rise 2 fall 3 weight 10

## 格式：server &amp;lt;name&amp;gt; &amp;lt;address&amp;gt;[:[port]] [param*]

### serser 在后端声明一个server，只能用于listen和backend区段。

### &amp;lt;name&amp;gt;为此服务器指定的内部名称，其将会出现在日志及警告信息中

### &amp;lt;address&amp;gt;此服务器的IPv4地址，也支持使用可解析的主机名，但要在启动时需要解析主机名至响应的IPV4地址

### [:[port]]指定将客户端连接请求发往此服务器时的目标端口，此为可选项

### [param*]为此server设定的一系列参数，均为可选项，参数比较多，下面仅说明几个常用的参数：

#### weight:权重，默认为1，最大值为256，0表示不参与负载均衡

#### backup:设定为备用服务器，仅在负载均衡场景中的其他server均不可以启用此server

#### check:启动对此server执行监控状态检查，其可以借助于额外的其他参数完成更精细的设定

#### inter:设定监控状态检查的时间间隔，单位为毫秒，默认为2000，

##### 也可以使用fastinter和downinter来根据服务器端专题优化此事件延迟

#### rise:设置server从离线状态转换至正常状态需要检查的次数（不设置的情况下，默认值为2）

#### fall:设置server从正常状态转换至离线状态需要检查的次数（不设置的情况下，默认值为3）

#### cookie:为指定server设定cookie值，此处指定的值将会在请求入站时被检查，

##### 第一次为此值挑选的server将会被后续的请求所选中，其目的在于实现持久连接的功能

#### maxconn:指定此服务器接受的最大并发连接数，如果发往此服务器的连接数目高于此处指定的值，

#####其将被放置于请求队列，以等待其他连接被释放
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：多节点部署时node 、 description的值要做相应调整。&lt;/p&gt;
&lt;p&gt;（2）根据以上HAProxy配置文件要求做以下配置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加haproxy用户组和用户&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;groupadd haproxy
useradd -g haproxy haproxy
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建chroot运行的路径&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mkdir /usr/share/haproxy
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;防火墙中打开3306端口和48800端口&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vi /etc/sysconfig/iptables
-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT
-A INPUT -m state --state NEW -m tcp -p tcp --dport 48800 -j ACCEPT
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重启防火墙&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;service iptables restart
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（3）开启rsyslog的haproxy日志记录功能&lt;/p&gt;
&lt;p&gt;默认情况下 haproxy是不记录日志的，如果需要记录日志，还需要配置系统的syslog，在linux系统中是rsyslog服务。syslog服务器可以用作一个网络中的日志监控中心，rsyslog是一个开源工具，被广泛用于Linux系统以通过TCP/UDP协议转发或接收日志消息。安装配置rsyslog服务：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;yum install rsyslog ## 没安装的情况下执行安装
vi /etc/rsyslog.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;把 $ModLoad imudp 和 $UDPServerRun 514前面的 # 去掉&lt;br/&gt;$ModLoad imudp ## 是模块名，支持UDP协议&lt;br/&gt;$UDPServerRun 514&lt;/p&gt;
&lt;h2 id=&quot;允许514端口接收使用udp和tcp协议转发过来的日志，&quot;&gt;允许514端口接收使用UDP和TCP协议转发过来的日志，&lt;/h2&gt;
&lt;h2 id=&quot;而rsyslog在默认情况下，正是在514端口监听udp&quot;&gt;而rsyslog在默认情况下，正是在514端口监听UDP&lt;/h2&gt;
&lt;p&gt;确认 #### GLOBAL DIRECTIVES #### 段中是否有 $IncludeConfig /etc/rsyslog.d/*.conf没有则增加上此配置，增加后的效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201210235210368.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cd /etc/rsyslog.d/ ## rsyslog服务会来此目录加载配置
touch haproxy.conf ## 创建haproxy的日志配置文件
vi /etc/rsyslog.d/haproxy.conf
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;增加以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;local0.* /var/log/haproxy.log

&amp;amp;~
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;如果不加上面的的配置则除了在varloghaproxylog中写入日志外，也会写入varlogmessage文件中配置保存后重启rsyslog服务&quot;&gt;如果不加上面的的&quot;&amp;amp;~&quot;配置则除了在/var/log/haproxy.log中写入日志外，也会写入/var/log/message文件中配置保存后重启rsyslog服务&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;service rsyslog restart
Shutting down system logger: [ OK ]
Starting system logger: [ OK ]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等到HAProxy服务启动后，就能在/var/log/haproxy.log中看到日志了&lt;/p&gt;
&lt;p&gt;（4）配置系统内核的IP包转发功能&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vi /etc/sysctl.conf
net.ipv4.ip_forward = 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使配置生效&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;sysctl -p
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（5）启动HAProxy&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;service haproxy start
ps -ef | grep haproxy
haproxy 23921 1 0 23:27 ? 00:00:00 /usr/sbin/haproxy -D -f /etc/haproxy/haproxy.cfg -p /var/run/haproxy.pid
root 23924 23179 0 23:27 pts/1 00:00:00 grep haproxy
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;（6）使用MySQL客户端通过HAProxy连接Mycat&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mysql -ulyz -plyz.123 -h192.168.209.135 -P3307
mysql&amp;gt; show databases;
mysql&amp;gt; lyz_schema1;
mysql&amp;gt; show tables;
mysql&amp;gt; select * from lyz_user;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201210235220797.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;写数据测试&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;insert into lyz_user (userName, pwd) values ('lyz6'666666');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201210235233470.png#pic_center&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;查询后的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201210235244786.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（7）登录HAProxy的状态信息统计页面&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://192.168.209.135:48800/admin-status&quot; target=&quot;_blank&quot;&gt;http://192.168.209.135:48800/admin-status&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用户名和密码都是admin，对应的haproxy.cfg配置片段&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;## HAProxy的状态信息统计页面
listen admin_stats
bind :48800 ## 绑定端口
stats uri /admin-status ##统计页面
stats auth admin:admin ## 设置统计页面认证的用户和密码，如果要设置多个，另起一行写入即可
mode http
option httplog ## 启用日志记录HTTP请求
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;统计页面如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201210235254589.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好了，今天就到这儿吧，我是冰河，我们下期见~~&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;微信搜一搜【冰河技术】微信公众号，关注这个有深度的程序员，每天阅读超硬核技术干货，公众号内回复【PDF】有我准备的一线大厂面试资料和我原创的超硬核PDF技术文档，以及我为大家精心准备的多套简历模板（不断更新中），希望大家都能找到心仪的工作，学习是一条时而郁郁寡欢，时而开怀大笑的路，加油。如果你通过努力成功进入到了心仪的公司，一定不要懈怠放松，职场成长和新技术学习一样，不进则退。如果有幸我们江湖再见！&lt;/p&gt;
&lt;p&gt;另外，我开源的各个PDF，后续我都会持续更新和维护，感谢大家长期以来对冰河的支持！！&lt;/p&gt;
</description>
<pubDate>Thu, 10 Dec 2020 16:15:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 在《冰河，能讲讲Mycat如何实现MySQL的读写分离吗？》一文中，我们实现了使用Mycat实现MySQL的读写分离。然而，此时的Mycat只有一个节点，如果Mycat节点宕机了，则整个My</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/14118285.html</dc:identifier>
</item>
<item>
<title>TCP连接时动态端口的相关问题说明 - chenzk</title>
<link>http://www.cnblogs.com/chen943354/p/14118255.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chen943354/p/14118255.html</guid>
<description>&lt;p&gt;最近在线上遇到一个TCP动态端口相关的问题，之前没有留意过此类问题，做个笔记记录在这里，希望也能给大家提供个参考。&lt;/p&gt;
&lt;p&gt;简单介绍下问题的场景：Windows服务器上，部署了网关程序SG和RPC进程，其中RPC进程监听本地8003端口。问题发生在一次线上常规发布的时候，RPC程序会重启一次加载新部署的程序文件。然而却启动失败了，直接原因是”通常每个套接字地址(协议/网络地址/端口)只允许使用一次。“。于是检查本地端口占用情况，发现8003端口确实被占用了，而且是被网关程序占用，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://czk-1251259984.cos.ap-beijing.myqcloud.com/mdpics/20201210230844.png&quot; alt=&quot;image-20201210230844546&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;背景资料&quot;&gt;背景资料&lt;/h4&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;TCP/IP协议传输层建立连接时请求方和目标方都需要分配一个端口号。目标方的端口号自然是提前分配并创建连接时确定具体端口的，但是请求方的端口就采用本地动态端口的策略随机分配1个使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;动态端口的分配也不是纯随机的，而是根据OS设置，在一个范围内随机。可以通过命令查看：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;netsh int ipv4 show dynamicport tcp
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://czk-1251259984.cos.ap-beijing.myqcloud.com/mdpics/20201210231702.png&quot; alt=&quot;image-20201210231702381&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中启动端口就是起始端口，端口数就是动态端口可分配的个数。&lt;/p&gt;
&lt;p&gt;也可以通过命令设置起始端口和数量：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;netsh int ipv4 set dynamicport tcp start=32765 num=30000
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;Windows上动态端口的设置不是一成不变的，简单来说： 在Windows vista和windows server 2008以前的系统中动态的客户端端口范围是1025到5000；在Windows vista和windows server 2008中，为了遵守IANA的推荐，把范围扩展成49152到65535。&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;原因分析&quot;&gt;原因分析&lt;/h4&gt;
&lt;p&gt;根据以上内容，查看了服务器的动态端口配置，发现确实有问题：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://czk-1251259984.cos.ap-beijing.myqcloud.com/mdpics/20201210232855.png&quot; alt=&quot;image-20201210232855770&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，作为Socket连接请求方的网关进程，确实可能会从OS获取到8003端口准备发起连接，所以RPC进程重启时再次绑定8003自然就失败了。&lt;/p&gt;
&lt;h4 id=&quot;解决方案&quot;&gt;解决方案&lt;/h4&gt;
&lt;p&gt;修改本地动态端口范围，避开常用的服务端口范围。&lt;/p&gt;
&lt;h4 id=&quot;扩展延申&quot;&gt;扩展延申&lt;/h4&gt;
&lt;p&gt;查阅资料时，看到有文章提到端口回收到重用会有时间间隔，根据 RFC793 规范，此值应是网络上最大段生存期的两倍（2msl），处于这个阶段的连接状态未TIME_WAIT。可以通过注册表配置此值，路径：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\ Services\TCPIP\Parameters，键TcpTimedWaitDelay。&lt;/p&gt;
&lt;h4 id=&quot;参考资料&quot;&gt;参考资料&lt;/h4&gt;
</description>
<pubDate>Thu, 10 Dec 2020 16:06:00 +0000</pubDate>
<dc:creator>chenzk</dc:creator>
<og:description>最近在线上遇到一个TCP动态端口相关的问题，之前没有留意过此类问题，做个笔记记录在这里，希望也能给大家提供个参考。 简单介绍下问题的场景：Windows服务器上，部署了网关程序SG和RPC进程，其中R</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chen943354/p/14118255.html</dc:identifier>
</item>
<item>
<title>基于Dokcer搭建Redis集群（主从集群） - niceyoo</title>
<link>http://www.cnblogs.com/niceyoo/p/14118146.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niceyoo/p/14118146.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最近陆陆续续有不少园友加我好友咨询 redis 集群搭建的问题，我觉得一定是之前写的这篇 &lt;a href=&quot;https://www.cnblogs.com/niceyoo/p/13011626.html&quot;&gt;《基于Docker的Redis集群搭建》&lt;/a&gt; 文章有问题了，所以我花了几分钟浏览之前的文章总结了下面几个问题：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;redis 数量太少，只创建了 3 个实例；&lt;/li&gt;
&lt;li&gt;由于只有 3 个实例，所以全部只能是主节点，无法体现集群主从关系；&lt;/li&gt;
&lt;li&gt;如何搭建主从集群？如何分配从节点？&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于之前的文章，我想快速的过一下这几个问题，本文基于 Docker + Redis 5.0.5 版本，通过 cluster 方式创建一个 6 个 redis 实例的主从集群，当然文章会指出相应的参数说明，这样即便是创建 9 个实例的集群方式也是一样的。&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1、拉取 Redis 镜像&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;基于 Redis：5.0.5 版本，执行如下指令：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;docker pull redis:5.0.5&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2、创建 6 个 Redis 容器&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建 6 个Redis 容器：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;redis-node1：6379&lt;/li&gt;
&lt;li&gt;redis-node2：6380&lt;/li&gt;
&lt;li&gt;redis-node3：6381&lt;/li&gt;
&lt;li&gt;redis-node4：6382&lt;/li&gt;
&lt;li&gt;redis-node5：6383&lt;/li&gt;
&lt;li&gt;redis-node6：6384&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行命令如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;10.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;15&quot;&gt;docker create --name redis-node1 --net host -v /data/redis-data/node1:/data redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-1.conf --port 6379&lt;p&gt;docker create --name redis-node2 --net host -v /data/redis-data/node2:/data redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-2.conf --port 6380&lt;/p&gt;&lt;p&gt;docker create --name redis-node3 --net host -v /data/redis-data/node3:/data redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-3.conf --port 6381&lt;/p&gt;&lt;p&gt;docker create --name redis-node4 --net host -v /data/redis-data/node4:/data redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-4.conf --port 6382&lt;/p&gt;&lt;p&gt;docker create --name redis-node5 --net host -v /data/redis-data/node5:/data redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-5.conf --port 6383&lt;/p&gt;&lt;p&gt;docker create --name redis-node6 --net host -v /data/redis-data/node6:/data redis:5.0.5 --cluster-enabled yes --cluster-config-file nodes-node-6.conf --port 6384&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;部分参数解释：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;--cluster-enabled：是否启动集群，选值：yes 、no&lt;/li&gt;
&lt;li&gt;--cluster-config-file 配置文件.conf ：指定节点信息，自动生成&lt;/li&gt;
&lt;li&gt;--cluster-node-timeout 毫秒值： 配置节点连接超时时间&lt;/li&gt;
&lt;li&gt;--appendonly：是否开启持久化，选值：yes、no&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行命令截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20201210222843978.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3、启动 Redis 容器&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行命令如下：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;docker start redis-node1 redis-node2 redis-node3 redis-node4 redis-node5 redis-node6&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;启动截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20201210223420315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;4、组建 Redis 集群&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;进入任意一个 Redis 实例：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;docker &lt;span class=&quot;hljs-built_in&quot;&gt;exec&lt;/span&gt; -it redis-node1 /bin/bash&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行组件集群的命令：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;redis-cli --cluster create 10.211.55.4:6379 10.211.55.4:6380 10.211.55.4:6381 10.211.55.4:6382 10.211.55.4:6383 10.211.55.4:6384 --cluster-replicas 1&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行命令截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20201210223827327.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;创建成功后，通过 redis-cli 查看一下集群节点信息：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;root@CentOS7:/data&lt;br/&gt;127.0.0.1:6379&amp;gt; cluster nodes&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行命令截图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20201210224555085.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;5、关于Redis集群搭建&lt;/span&gt;&lt;/h4&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再回到创建集群的命令上：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;redis-cli --cluster create 10.211.55.4:6379~6384 --cluster-replicas 1&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大家着重看这个参数 &lt;strong&gt;--cluster-replicas 1&lt;/strong&gt;，参数后面的数字表示的是主从比例，比如这里的 1 表示的是主从比例是 1:1，什么概念呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是 1 个主节点对应几个从节点，现有 6 个实例，所以主从分配就是 3 个 master 主节点，3 个 slave 从节点。&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;5&quot;&gt;
&lt;p&gt;主节点最少3个，3个才能保证集群的健壮性。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果 &lt;strong&gt;--cluster-replicas 2&lt;/strong&gt; 呢？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么主从比例就是 1:2，也就是 1 个主节点对于应 2 个从节点。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;即：3(master) + 6(slave) = 9个 Redis 实例。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果不足 9个 Redis 实例，但是参数指定为 2 会怎么样？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;报错信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20201210230413314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;提示已经很清楚了，Redis集群至少需要3个主节点。那么从节点就需要有6个，所以最后说：至少需要9个节点。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;好的，至少3个主节点的要求我不继续刚了，但是我想4个主节点，2个从节点，这总该可以了吧？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4个主节点满足你：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;br/&gt;docker &lt;span class=&quot;hljs-built_in&quot;&gt;exec&lt;/span&gt; -it redis-node1 /bin/bash&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;执行组建集群的命令：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;redis-cli --cluster create 10.211.55.4:6379 10.211.55.4:6380 10.211.55.4:6381 10.211.55.4:6382  --cluster-replicas 0&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;指定4个没有从节点的主节点，这样你就有4个主节点了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20201210231122697.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;剩下的两个从节点怎么办呢？手动添加。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;怎么添加？手动添加！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20201210231505299.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这些 master 节点的 id 了吗，只需要把 slave 指定给他们就可以了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;继续执行如下命令：&lt;/p&gt;
&lt;pre class=&quot;custom&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;hljs&quot; readability=&quot;3&quot;&gt;redis-cli --cluster add-node 10.211.55.4:6383 10.211.55.4:6379  --cluster-slave --cluster-master-id b0c32b1dae9e7b7f7f4b74354c59bdfcaa46f30a&lt;p&gt;redis-cli --cluster add-node 10.211.55.4:6384 10.211.55.4:6379  --cluster-slave --cluster-master-id 111de8bed5772585cef5280c4b5225ecb15a582e&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;将两个 Redis 实例塞给其他主节点了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20201210232253318.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后我们进入 redis-cli，通过 cluster nodes 查看一下节点信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/niceyoo/blog/raw/master/img/image-20201210232445938.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;看到这，你学废了吗？再学不废，下期我可要录视频了。。。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;博客园：&lt;a href=&quot;https://niceyoo.cnblogs.com/&quot;&gt;https://niceyoo.cnblogs.com/&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Dec 2020 15:30:00 +0000</pubDate>
<dc:creator>niceyoo</dc:creator>
<og:description>最近陆陆续续有不少园友加我好友咨询 redis 集群搭建的问题，我觉得一定是之前写的这篇 《基于Docker的Redis集群搭建》 文章有问题了，所以我花了几分钟浏览之前的文章总结了下面几个问题： r</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/niceyoo/p/14118146.html</dc:identifier>
</item>
<item>
<title>二叉树的所有遍历非递归实现 - Yrion</title>
<link>http://www.cnblogs.com/wyq178/p/14059151.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq178/p/14059151.html</guid>
<description>&lt;p&gt;前言：二叉树的遍历形式有很多,比如前序、中序、后序、层序遍历,在最近的一次面试中,面试官要求手写层序遍历代码(非递归的形式),由此可见遍历的重要性.本篇博客我们就来看一下二叉树的几种遍历方式.本篇博客语言均采用java实现：&lt;/p&gt;
&lt;p&gt;目录:&lt;/p&gt;








&lt;h2&gt;1.1：二叉树结构&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;       维基百科中对二叉树是这样定义的：(英文名：&lt;/span&gt;&lt;/span&gt;&lt;span lang=&quot;en&quot;&gt;&lt;span&gt;&lt;span&gt;Binary tree&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;。&lt;/span&gt;&lt;span&gt;通常分支被称作“左子树”或“右子树”,&lt;/span&gt;&lt;span&gt;二元树的分支具有左右次序，不能随意颠倒.如下图,是一颗标准的二叉树(其中标明了节点的属性,比如左一、右二等,下面用到的示例均采用该树)&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1066538/202012/1066538-20201208003341773-222442834.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt; 1.2:二叉树的遍历&lt;/h2&gt;
&lt;p&gt;       二叉树的遍历是指按照一定的规则访问二叉树的每一个结点并且查看它的值。有很多常见的顺序来访问所有的结点，而且每一种都有有用的性质。一般分为前序遍历(根 左 右),中序遍历(左 根 右),后序遍历(左 右 根)&lt;/p&gt;
&lt;h2&gt;二：前序遍历(根、左、右)&lt;/h2&gt;
&lt;p&gt;前序遍历是指按照根左右的顺序依次遍历,使用非递归遍历,一般会用到栈,利用先进后出的特性来达到访问二叉树节点目的。来看一下&lt;/p&gt;
&lt;h4&gt;2.1 前序遍历非递归实现思路：&lt;/h4&gt;
&lt;p&gt;①：首先将根节点放入到stack中存储&lt;/p&gt;
&lt;p&gt;②：遍历栈,如果stack不为空,直接弹出根节点&lt;/p&gt;
&lt;p&gt;③：如果右节点不为空,将右节点放入到栈中&lt;/p&gt;
&lt;p&gt;④：如果左节点不为空,将左节点放入到栈中&lt;/p&gt;
&lt;p&gt;解释：因为栈都是后进先出的,所以在遍历子树的时候应该先将右节点放入栈中,再把左节点放入栈中.&lt;/p&gt;
&lt;h5&gt;2.2 代码实现：&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 前序遍历 (根 左 右) *
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; head
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;Integer&amp;gt;&lt;span&gt; preOrderIteration(TreeNode head) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结果集&lt;/span&gt;
        List&amp;lt;Integer&amp;gt; resultList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        // &lt;span&gt;栈&lt;/span&gt;
        Stack&lt;/span&gt;&amp;lt;TreeNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 首先放入头节点&lt;/span&gt;
&lt;span&gt;        stack.push(head);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;stack.isEmpty()) {
            TreeNode node &lt;/span&gt;=&lt;span&gt; stack.pop();
            resultList.add(node.val);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放入右节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (node.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                stack.push(node.right);
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 放入左节点&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (node.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                stack.push(node.left);
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultList;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;按照上图给的二叉树节点,走完测试用例结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1066538/202012/1066538-20201204000419844-127913568.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 2.3: 栈中的数据变化(从下往上看)&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1066538/202012/1066538-20201208003325008-319340134.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;三：中序遍历(左、根、右)&lt;/h2&gt;
&lt;h4&gt;&lt;strong&gt;中序遍历的非递归实现思路:&lt;/strong&gt;&lt;/h4&gt;
&lt;p&gt;①一直递归的遍历左子节点,然后弹出左子节点,直到不为null&lt;/p&gt;
&lt;p&gt;② 然后弹出最近的一个左节点,如果它的right节点不为null，将当前的节点置为right&lt;/p&gt;
&lt;p&gt;③ 然后依次继续①的步骤 遍历到左子树为null停止&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码实现:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 中序遍历 (左 根 右)
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; head
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Integer&amp;gt;&lt;span&gt; inOrderIteration(TreeNode head) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 结果集&lt;/span&gt;
        List&amp;lt;Integer&amp;gt; resultList = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        TreeNode cur &lt;/span&gt;=&lt;span&gt; head;
        Stack&lt;/span&gt;&amp;lt;TreeNode&amp;gt; stack = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!stack.isEmpty() || cur != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一直先把左节点依次放入栈中&lt;/span&gt;
            &lt;span&gt;while&lt;/span&gt; (cur != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                stack.push(cur);
                cur &lt;/span&gt;=&lt;span&gt; cur.left;
            }
            TreeNode node &lt;/span&gt;=&lt;span&gt; stack.pop();
            resultList.add(node.val);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                cur &lt;/span&gt;=&lt;span&gt; node.right;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultList;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;按照上图给的二叉树节点,走完测试用例结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1066538/202012/1066538-20201208001416548-1068349150.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt; 栈中的数据节点变化(从下往上看):&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1066538/202012/1066538-20201208003851936-754055310.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt;四：后序遍历(左 右 根)&lt;/h2&gt;
&lt;p&gt;后序遍历需要用到两个栈,可以想一想为什么需要两个栈？ stack1负责将节点的值依次存储,stack2负责存储stack1弹出的节点值 ，因为后序遍历的根节点是最后遍历的顺序,因此需要一个中转的栈首先将根放入,然后再放入右节点,再放入左节点.最后再逆序(pop)出去就是后序遍历的顺序了。&lt;/p&gt;
&lt;p&gt;①首先将根节点放入到stack1中，再弹出根节点,放入到stack2,保证stack2存储的第一个节点是根节点&lt;/p&gt;
&lt;p&gt;②再将根节点的左右节点依次放入到stack1中,注意这里是先加入左节点,再加入右节点&lt;/p&gt;
&lt;p&gt;③最终再将stack2的节点依次pop出去加入到结果集里面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 后序遍历 (左 右 根) *
     *
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; head
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; List&amp;lt;Integer&amp;gt;&lt;span&gt; postOrderIteration(TreeNode head) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (head == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayList();
        }
        List&lt;/span&gt;&amp;lt;Integer&amp;gt; resultList=  &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        Stack&lt;/span&gt;&amp;lt;TreeNode&amp;gt; stack1 = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;&lt;span&gt;();
        Stack&lt;/span&gt;&amp;lt;TreeNode&amp;gt; stack2 = &lt;span&gt;new&lt;/span&gt; Stack&amp;lt;&amp;gt;&lt;span&gt;();
        stack1.push(head);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;stack1.isEmpty()) {
            TreeNode node &lt;/span&gt;=&lt;span&gt; stack1.pop();
            stack2.push(node);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                stack1.push(node.left);
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (node.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                stack1.push(node.right);
            }
        }
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;stack2.isEmpty()) {
            resultList.add(stack2.pop().val);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;  resultList;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1066538/202012/1066538-20201209010328958-536507197.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;栈中节点的变化图:&lt;/p&gt;

&lt;h2&gt;五：层序遍历&lt;/h2&gt;
&lt;h4&gt;实现思路:&lt;/h4&gt;
&lt;h4&gt;层序遍历需要用到Queue(先进先出)，而不是栈,因为它是顺序添加的。&lt;/h4&gt;
&lt;p&gt;①声明一个队列,首先添加进去根节点&lt;/p&gt;
&lt;p&gt;②弹出根节点,再依次加入左节点,再加入右节点&lt;/p&gt;
&lt;p&gt;③依次循环,再弹出上一次的左节点,再加入左节点的左节点、左节点的右节点&lt;/p&gt;
&lt;h4&gt;&lt;strong&gt;代码实现:&lt;/strong&gt;&lt;/h4&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 层序遍历
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; root
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt;&lt;span&gt; levelOrder(TreeNode root) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 返回的结果集&lt;/span&gt;
        List&amp;lt;List&amp;lt;Integer&amp;gt;&amp;gt; res = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 队列&lt;/span&gt;
        Queue&amp;lt;TreeNode&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();

        queue.add(root);
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;queue.isEmpty()) {
            List&lt;/span&gt;&amp;lt;Integer&amp;gt; temp = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size =&lt;span&gt; queue.size();
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; size; i++&lt;span&gt;) {
                TreeNode poll &lt;/span&gt;=&lt;span&gt; queue.poll();
                temp.add(poll.val);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (poll.left != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    queue.add(poll.left);
                }
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (poll.right != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    queue.add(poll.right);
                }
            }
            res.add(temp);
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1066538/202012/1066538-20201208001122681-702813901.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;队列中的数据变化图(从下往上看):&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1066538/202012/1066538-20201209010618740-214650335.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 class=&quot;p1&quot;&gt;&lt;span class=&quot;s1&quot;&gt;&lt;strong&gt;六：总结&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;p2&quot;&gt;&lt;span class=&quot;s2&quot;&gt;     二叉树作为一种经典的数据结构, 在实现遍历的时候,采用递归的方式非常简单。但是在面试中,一旦让面试者写非递归的实现方式,很多人就望而却步了。对于借助于栈还是队列按照何种规律来巧妙实现所有的遍历,其实也是值得深入学习的。本篇博客就分析了二叉树的四种遍历方式,全部采用非递归的方法，希望大家对于二叉树的最基本操作遍历有一个深刻的理解。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Dec 2020 15:05:00 +0000</pubDate>
<dc:creator>Yrion</dc:creator>
<og:description>前言：二叉树的遍历形式有很多,比如前序、中序、后序、层序遍历,在最近的一次面试中,面试官要求手写层序遍历代码(非递归的形式),由此可见遍历的重要性.本篇博客我们就来看一下二叉树的几种遍历方式.本篇博客</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyq178/p/14059151.html</dc:identifier>
</item>
<item>
<title>聊一聊程序员人群的认知偏见 - pointersss</title>
<link>http://www.cnblogs.com/pointers/p/14118001.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pointers/p/14118001.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;成长&amp;amp;认知 丨 作者 / 袁吴范&lt;/p&gt;
&lt;p&gt;这是&lt;strong&gt;pointers&lt;/strong&gt;公众号的第27篇原创文章&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我的很多读者肯定会认为像我这种级别的人都是非常有思想、有决策力的大神。&lt;/p&gt;
&lt;p&gt;我会根据事情的真相，再三权衡，最后做出一个理性、正确的决定。&lt;/p&gt;
&lt;p&gt;但，&lt;strong&gt;事实上基本上没人能做到每一个决定都是理性而正确&lt;/strong&gt;，即便是公司高管，我也不例外 。&lt;/p&gt;
&lt;p&gt;其实我们的大脑在你不知不觉的时候帮我们做了很多决定。&lt;/p&gt;
&lt;p&gt;这些决策都是基于不完善的信息和当时我们的心情，而忽视了关键的事实。&lt;/p&gt;
&lt;p&gt;我们的大脑不是软件，出现了bug，可以进行debug，最后找到错误的代码。&lt;/p&gt;
&lt;p&gt;但我们大脑却在时时刻刻出现着bug，常见的bug就是认知偏见。&lt;/p&gt;
&lt;p&gt;认知偏见有很多种，在Wikipedia列举了大约90种常见认知偏见。&lt;/p&gt;
&lt;p&gt;下面我会从认知偏见这个角度展示出程序员群体最常见的错误“代码”。&lt;/p&gt;
&lt;p&gt;让你更加清楚了解这些偏见对我们思维和行动的影响。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;给大家举2个例子。&lt;/p&gt;
&lt;p&gt;一、&lt;/p&gt;
&lt;p&gt;19世纪中叶，美国加州传来发现金矿的消息。许多人认为这是一个千载难逢的发财机会，蜂拥而至，许多不幸的淘金者不但没有圆致富梦，反而被折磨得半死。有个叫默克尔的人，通过卖水却在很短的时间靠卖水赚到几千美元，这在当时是一笔非常可观的财富了。&lt;/p&gt;
&lt;p&gt;二、&lt;/p&gt;
&lt;p&gt;我们公司大楼的2,3两层是食堂，每次吃完饭。电梯口乌央乌央全是人，等着电梯，堪比挤东京的地铁，像我这种中年发福的男人是挤不上去的。于是我就想了一个办法，楼梯走到1楼，明显感觉少了很多，只有零星几个人，然后就非常容易的搭上电梯。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由此可见，当我们苦苦不得其解，其实只要稍微转变下思维，问题就迎刃而解。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在项目的开发过程中，经常听到有程序员跟我反馈，按需求上理解就应该这样设计，领导给了规范就应该这样。&lt;/p&gt;
&lt;p&gt;程序猿在工作的过程中就非常容易受这样或那样的要求的限定，久而久之便形成了思维定势，这样的定势一但形成就很难突破，本能的坚定的认为按照要求完成一定不会错，不会错但不一定是对的或最好最高效的。&lt;/p&gt;
&lt;p&gt;因为你的领导也会受他们自己的思维所限，所制定的要求只是相对理想但永远不会是最理想，这也是为什么所有的企业都提畅创新，想要创新最理想的状态，需要我们每一个程序猿在工作中不断的思考，不断的突破，不断的共享，不断的修改规则和要求，从而才能实现创新，提高效率，与此同时你个人也会在这个不断改变的过程中，收获工作以外的成就感和价值感。&lt;/p&gt;
&lt;p&gt;以我自己为例。&lt;/p&gt;
&lt;p&gt;2015年的时候，我离开老东家，来到海康。&lt;/p&gt;
&lt;p&gt;刚来第一个月里，一般情况下就是熟悉团队氛围和公司制度、文化的阶段，而我发现代码中的兼容性、扩展性都比较差，而且耦合特别大。就强制要求自己每天早上非常早的就来公司，晚上几乎11、12点下班，在一个月时间内就输出了一份软件架构方案，递到了领导的手上。&lt;/p&gt;
&lt;p&gt;最后虽然方案还是有漏洞，但是大的问题没有，在第二年就慢慢切换使用我设计的架构&lt;/p&gt;
&lt;p&gt;原先的软件架构一直问题比较大，为什么直到我的出现才完成了重构？&lt;/p&gt;
&lt;p&gt;你可能会说，其他人的能力没你强，心有余力不足。&lt;/p&gt;
&lt;p&gt;但我觉得最大的问题是出在了思维定势&lt;strong&gt;。团队的每个人都习惯了这套代码，只会想到怎样去让自己新增代码更好的适配当前架构&lt;/strong&gt;，并没有联想到重新设计架构。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;&lt;strong&gt;极其不可能的巧合事件其实每天都在发生。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就2020年来说吧，从年初爆发的疫情，到全球经济下行的压力，大家都成为了历史的见证者。&lt;/p&gt;
&lt;p&gt;虽然这次疫情可能是人类历史以来最为严重的疫情，但是拉到地球生命时间线上看，这样的事件肯定并不少见。&lt;/p&gt;
&lt;p&gt;我们会觉得很反常，因为在我们的记忆中或者我们父母的记忆中（甚至祖父母的记忆中），这些灾难从没发生过。但是，这不意味着不会发生，也不能阻止它们一下子连续发生好几次。&lt;/p&gt;
&lt;p&gt;给大家一个数据。&lt;/p&gt;
&lt;p&gt;美国人每年被雷电劈死的概率大概为600万分之一。这个数字听起来应该很小吧，但是仍然有几十个人死于雷电。&lt;/p&gt;
&lt;p&gt;再给大家一个数据。&lt;/p&gt;
&lt;p&gt;美国人每年死于坠床的概率大概为40万分之一。这个数字看起来也挺小的吧，而且你可能认为不算是危险的事情。虽然非常罕见，但每年都有上百人死于坠床。&lt;/p&gt;
&lt;p&gt;这些事情都警示着每一个程序员，&lt;strong&gt;不要把未观察到的、或者是概率及其小的事情认为是不可能。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;任何你忽视的细节都可能让你的软件在未来的某个时刻出现莫名其妙的崩溃。&lt;/p&gt;
&lt;p&gt;你应该在设计代码时，仔细思考一下你可能遗漏的点，可能没有想到的点。花时间检查一下“不可能”异常值或者“极其不可能的”case。&lt;/p&gt;
&lt;p&gt;如果它们真的发生了，你将会消耗10倍甚至100倍的时间和精力去解决它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，记住：很少并不意味着没有。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;对于没有结局的电视剧，没有找到真凶的侦探电影。&lt;/p&gt;
&lt;p&gt;大家是什么感觉？是不是非常的不舒服。&lt;/p&gt;
&lt;p&gt;其实这是我们大脑给我们强烈的信号，对于这种疑问和不确定性感到极不舒适。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们会竭尽全力解决还未有定论的问题，最终得出结论。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是你有没有想过不确定性也是一件好事：让你的选择是开放的。&lt;/p&gt;
&lt;p&gt;强行给出不成熟的定论，会迫使你放弃选择，易于犯错。&lt;/p&gt;
&lt;p&gt;举一个例子。&lt;/p&gt;
&lt;p&gt;当领导交给你一个新需求时，你经过简单的思考，就给出了开发截止时间，这就是严重错误。&lt;/p&gt;
&lt;p&gt;你并没有经过严格评估，没有考虑项目内的不确定性，就草率的给出deadline，这其实一种自我掩饰，最终倒霉的还是你自己。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你应该怎么做？你可以告诉领导，这个需求工作量我会在半天内评估出来，然后会告知您每个细节的开发时间。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这样的行为是不是更加有理有据。&lt;/p&gt;
&lt;p&gt;所以我们需要适应不确定性。&lt;/p&gt;
&lt;p&gt;在项目开发中，有太多的不确定因素，我们不知道项目究竟结束是哪一天。不知道是否有疑难bug暂时无法解决。有太多的不确定因素干扰着项目。&lt;/p&gt;
&lt;p&gt;随着项目的进行，这些不确定终于找到了答案，慢慢的走向确定。&lt;/p&gt;
&lt;p&gt;难道我们就不能做点什么吗？&lt;/p&gt;
&lt;p&gt;当然啦，我们可以采取一些措施减少这种不确定。&lt;/p&gt;
&lt;p&gt;例如，我们可以对需求进行详细的设计，论证；可以对代码进行严密的概要设计，等等。&lt;/p&gt;
&lt;p&gt;虽然，措施多多少少有点作用，但是总是会遗漏，无法考虑全面，当然也就无法根治问题。&lt;/p&gt;
&lt;p&gt;这不是坏事，这个从不确定到确定的过程，就是探索事物的过程，也是成长的过程。&lt;/p&gt;
&lt;p&gt;最关键的是摆正心态，不要着急。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;这个其实涉及到了心理学的概念，以下截自百度百科。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;基本归因错误描绘人们在考察某些行为或后果的原因时高估倾向性因素（谴责或赞誉他人）、低估情景性因素（谴责或赞誉环境）的双重倾向。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;什么意思？&lt;/p&gt;
&lt;p&gt;就是人们倾向于把别人的行为归因于他们的个性，而不去考虑行为发生时的场景。&lt;/p&gt;
&lt;p&gt;举个例子，比如A小姐，平时活泼、开朗，外向型性格，那么，如果有人告诉你她去喝酒应酬的时候喝多了，失态了。&lt;/p&gt;
&lt;p&gt;你会认为这有可能发生，甚至会深信其一定发生过。&lt;/p&gt;
&lt;p&gt;如果有人告诉你她见客户的时候很害羞、很内向，倒水的时候手都紧张的发抖，你一定不会相信。&lt;/p&gt;
&lt;p&gt;你会认为一个外向的人不会突然内向或特别紧张。&lt;/p&gt;
&lt;p&gt;你会自然的认为外向型的人就做外向型的事，内向型的人就做内向型的事，这是一种偏见，其实，这是错误的。&lt;/p&gt;
&lt;p&gt;还有一个更简单的例子，人基本都会把面善的人认为是好人，而把面恶的人认为是坏人。&lt;/p&gt;
&lt;p&gt;生活中，我们经常以貌取人，也是源自归因的错误。&lt;/p&gt;
&lt;p&gt;总的来说，基本归因偏差又分三种。&lt;/p&gt;
&lt;p&gt;一种是内部归因，是指事情发生了，当事人会把所有问题指向自己。&lt;/p&gt;
&lt;p&gt;外部归因则是指事情发生了，当事人习惯把事情发生因素归纳总结为外部因素。&lt;/p&gt;
&lt;p&gt;而综合归因则是事情发生了，当事人会内外综合进行评价。&lt;/p&gt;
&lt;p&gt;所以有的人他觉得自己从来不会错，其实是指他是习惯性外部归因，比如说他没有升职或者原地踏步，他会责怪是自己没有关系没有背景，所以导致升不上去。&lt;/p&gt;
&lt;p&gt;而内部归因的人则习惯性把因素指向自己，比如同样是升职没有升上去，他会认为所有的问题都是发生在自己身上，因为自己不够努力，人际关系不够好，所以才导致自己不能升职。&lt;/p&gt;
&lt;p&gt;总的来说，习惯外部归因的人总是喜欢抱怨，最后容易变成愤青；&lt;/p&gt;
&lt;p&gt;而习惯内部归因的人则相对对自己较为苛刻，最后让自己背负巨大的压力。&lt;/p&gt;
&lt;p&gt;所以我们要想最为客观看待一件事情，我们必须学会内外结合，既采用综合归因，我们才能得到较为准确的信息，也才能更好的帮助我们自己成长，获取更为立体的信息。&lt;/p&gt;
&lt;hr/&gt;

&lt;p&gt;在项目开发中，大家有没有遇到这种情况。&lt;/p&gt;
&lt;p&gt;有一些技术相对比较好的程序员在开发过程中会使用一些相对难于理解的技术实现，或者是一些语法新特性，也可能是一些新的库。&lt;/p&gt;
&lt;p&gt;往往使用这些技术开发出来的功能只有作者本人能理解代码的逻辑实现，小组中的其他成员很难理解，甚至不理解。&lt;/p&gt;
&lt;p&gt;这一发展形成了技术壁垒 因此别人无法去涉及这业务， 随着业务的不断发展, 壁垒就会越来越高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;虽然这种技术壁垒可以保证你在项目中的地位，但是这是自私的行为&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一旦这块业务发生了bug，即使你忙的不可开交，你还是推卸不掉。&lt;/p&gt;
&lt;p&gt;因为没人懂，只有你去解决，别人根本帮不了你。&lt;/p&gt;
&lt;p&gt;如果业务是经常变动的，可想而知你会多么痛苦。&lt;/p&gt;
&lt;p&gt;更大的危害是，这中自私的行为阻碍了你的职业发展，因为技术壁垒不光阻挡了其他人的进入， 同样也阻挡了你出去。&lt;/p&gt;
&lt;p&gt;由于你无法从这个壁垒脱身，导致很多机会都给了其他人， 你只能眼巴巴的看着，时间久了， 你也只是成为了最熟悉这一块业务的程序员而已。&lt;/p&gt;
&lt;p&gt;我面试过很多工作5年左右的程序员，他们往往在一个业务上做了很久，但技术能力很是一般。&lt;/p&gt;
&lt;p&gt;为什么呢？&lt;/p&gt;
&lt;p&gt;因为他们对自己的业务熟悉了，太安逸了，在自己业务领域舒适着做个温水青蛙。&lt;/p&gt;
&lt;p&gt;最后一跳槽，原形毕露，毫无竞争力。&lt;/p&gt;
&lt;p&gt;说到底是在自己负责的业务上设置了业务壁垒，殊不知是自私导致。&lt;/p&gt;
&lt;p&gt;试问一下，如果新来的小伙伴问你业务代码，你会不会耐心跟对方讲解清楚，有没有让对方完全理解。如果没有，其实你在建立自己的商业壁垒。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果读者你有这样的行为，请立即停止，请丢掉自私心理。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你需要将自己的技术和业务经验，毫无保留的分享给你的同伴或者下属。让他们能够成长，甚至超越你。&lt;/p&gt;
&lt;p&gt;当有新需求，或者出现bug时，你的同事能够帮你分担，能够团队协作。同时你有更多的时间接触新技术提升自己。&lt;/p&gt;
&lt;p&gt;还有一种人 ，如果项目成功，最大的功能都是他的，一直强调自己对项目的贡献很大，而受到领导的不公。而项目一旦失败，推卸责任，所有的失败都与他无关。&lt;/p&gt;
&lt;p&gt;这种行为，是一种个人防御机制，也是一种自私的偏见。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;记住无论失败，团队所有的人承担。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后，既然选择做程序员这条道路，自私的心理就应该丢掉。这样才能让你走的更远。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我是袁吴范，程序员的职场导师，公众号：”pointers“；&lt;/p&gt;
&lt;p&gt;如有疑问，欢迎微信撩我：“pointersss” 坑位有限，先到先得。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;推荐阅读（干货）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484114&amp;amp;idx=1&amp;amp;sn=8e7dc76fa54087cf0784ef13dc261078&amp;amp;chksm=cf2097c0f8571ed6de8272864698e35cf0c78183bceb109fe71ee450d077f72ba29e5ac819f2&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;7年，从“游戏少年”到大厂技术总监的逆袭之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484027&amp;amp;idx=1&amp;amp;sn=fb6fe35037e1693bf0f1c0a81d059bdc&amp;amp;chksm=cf209769f8571e7f311b5195d1f4c8fc1dc7f6905375bbdc6b0afbec0abc4775889b1012db7c&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;程序员成为高级管理者的三次跃升&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484011&amp;amp;idx=1&amp;amp;sn=e52d915760314e3300c145039ede831b&amp;amp;chksm=cf209779f8571e6f81be5951b70607c2a2518fd0fc94c80c8f96c3331f82bdd6e07807179ce4&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot;&gt;技术总监7年总结，如何进行正确的沟通？&lt;/a&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;从业7年。从软件开发、高级软件开发、技术经理再到技术总监，分享职业发展、技术管理、职场晋升、技术成长等个人多年经验和心得。一起成长！&lt;/p&gt;
&lt;p&gt;关注我↓↓，帮你答疑解惑！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/4XQ0RVoHjpwwHPUKTfFPuXricWutdgzqDd8IhicA9rFr2MtXU3SaVfxfR9Y5sfhTib9Wq0kkU5bEZj6aSkAQC7zzA/640?wx_fmt=jpeg&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&amp;amp;wx_co=1&quot; alt=&quot;图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 10 Dec 2020 14:58:00 +0000</pubDate>
<dc:creator>pointersss</dc:creator>
<og:description>成长&amp;amp;amp;认知 丨 作者 / 袁吴范 这是pointers公众号的第27篇原创文章 我的很多读者肯定会认为像我这种级别的人都是非常有思想、有决策力的大神。 我会根据事情的真相，再三权衡，最</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pointers/p/14118001.html</dc:identifier>
</item>
<item>
<title>Python迭代器&amp;生成器&amp;装饰器 - Praywu</title>
<link>http://www.cnblogs.com/hgzero/p/14117967.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hgzero/p/14117967.html</guid>
<description>&lt;h2&gt;1. 迭代器&lt;/h2&gt;
&lt;h3&gt;1.1 可迭代对象（Iterator）&lt;/h3&gt;
&lt;p&gt;迭代器协议：某对象必须提供一个__next__()方法，执行方法要么返回迭代中的下一项，要么引起一个Stopiteration异常，以终止迭代（只能往后走，不能往前退）&lt;/p&gt;
&lt;p&gt;协议是一种规范，可迭代对象实现了迭代器协议，python的内部工具（如for循环、sum、min、max函数），使用迭代器协议访问对象&lt;/p&gt;
&lt;p&gt;可迭代对象（Iterator）：实现了迭代器协议的对象（如何实现：对象内部定义了一个__iter__()方法），也就是可迭代对象内部要包含__iter__() 函数&lt;/p&gt;
&lt;p&gt;迭代器（Iterator）：内部包含了__iter()__() ，同时也包含__next__()&lt;/p&gt;
&lt;h3&gt;1.2 for循环的工作机制&lt;/h3&gt;
&lt;p&gt;先通过__iter__()方法将可迭代对象转换为迭代器，再调用迭代器中的__next__()方法遍历，最后再抓取结束时的异常&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;解析for循环的工作机制：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
num &lt;/span&gt;= [1, 2, 3, 4, 5&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; num:           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 工作机制：  num.__iter__()  ------&amp;gt;  num.__next__()&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(i)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.3 可迭代对象与迭代器&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1）可迭代对象与迭代器之间的关系&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可迭代对象包含迭代器&lt;/li&gt;
&lt;li&gt;如果一个对象拥有__iter__方法，其就是可迭代对象（可以被for循环迭代）；如果一个对象拥有next方法，其是迭代器&lt;/li&gt;
&lt;li&gt;定义可迭代对象，必须事先__iter__方法；定义迭代器，必须实现__iter__和next方法。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）迭代器的特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;节省内存&lt;/li&gt;
&lt;li&gt;惰性机制&lt;/li&gt;
&lt;li&gt;不能反复，只能向下执行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3）isinstance()判断对象是否为Iterable对象：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;from&lt;/span&gt; collections &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Iterable
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(isinstance([], Iterable))
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;1.4 迭代器协议的使用示例&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;使用while循环遍历一个列表：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
index &lt;/span&gt;=&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;while&lt;/span&gt; index &amp;lt;&lt;span&gt; len(num):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(num[index])
    index &lt;/span&gt;+= 1

&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;利用迭代器协议遍历一个列表：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
iter &lt;/span&gt;= num.&lt;span&gt;__iter__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(iter.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(iter.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(iter.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;解析文件操作中对于文件内容的遍历：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
f &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
f_iter &lt;/span&gt;= f.&lt;span&gt;__iter__&lt;/span&gt;()      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里先将整个文件转换为一个迭代器，之后对迭代器调用__next__()方法，只在有需要的时候才加载文件一行内容&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 当取出一行内容时，因为没有赋值给任何变量，所以占用的内存会被python的自动回收机制回收，所以这种遍历文件的方式只会动态的占用一小块内存&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(f_iter.&lt;span&gt;__next__&lt;/span&gt;(), end=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f_iter.&lt;span&gt;__next__&lt;/span&gt;(), end=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f_iter.&lt;span&gt;__next__&lt;/span&gt;(), end=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f_iter.&lt;span&gt;__next__&lt;/span&gt;(), end=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f_iter.&lt;span&gt;__next__&lt;/span&gt;(), end=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;)
f.close()

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;next()方法：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; next()方法---&amp;gt;调用__next__()方法&lt;/span&gt;
the_num = [1, 2, 3&lt;span&gt;]
the_iter &lt;/span&gt;= the_num.&lt;span&gt;__iter__&lt;/span&gt;()   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 也可以直接使用iter(the_num)方法&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(next(the_iter))     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; next(the_iter)  -----&amp;gt;  调用 the_iter.__next__()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;2. 生成器&lt;/h2&gt;
&lt;h3&gt;2.1 生成器概述（generator）&lt;/h3&gt;
&lt;p&gt;生成器（generator）就是可迭代对象（它在内部实现了迭代器协议）&lt;/p&gt;
&lt;p&gt;生成器在python中的两种表达形式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;生成器表达式&lt;/li&gt;
&lt;li&gt;生成器函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;触发生成器的方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通过调用__next__()方法，相当于send(None)&lt;/li&gt;
&lt;li&gt;通过调用send()方法&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2.2 生成器函数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;只要函数中包含yield关键字，则此函数就是一个生成器函数&lt;/li&gt;
&lt;li&gt;每调用一次 __next__()，yield后面的值就会被返回一次，且保留此次的状态，下一次调用从此位置开始&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1）生成器函数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;现在开始执行生成器函数：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;First-----&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第一步&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Second-----&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第二步&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Third&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第三步&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;End&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生成器函数调用完毕&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;

f &lt;/span&gt;=&lt;span&gt; func()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f.&lt;span&gt;__next__&lt;/span&gt;())    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; __next__()函数调用接受到的返回值就是yield后面的值&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(f.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(f.&lt;span&gt;__next__&lt;/span&gt;())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;2）用yield方式的生成器实现字典中文件的内容查找&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; get_num():
    f &lt;/span&gt;= open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;population.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这个文件中的每一行都是一个字典&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f:
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; i                                        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里返回的 i 为字符串类型&lt;/span&gt;
&lt;span&gt;
population &lt;/span&gt;= eval(get_num().&lt;span&gt;__next__&lt;/span&gt;())                &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里通过eval()函数重新恢复了文件中数据的数据类型，恢复成了字典&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%s的人口数为%s&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (population[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;city&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;], population[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;population&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]))
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 注意：生成器只能遍历一次&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用生成器表达式的方式实现字典中文件数字的求和&lt;/span&gt;
f = open(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;population.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;r&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, encoding=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
p &lt;/span&gt;= sum(eval(i)[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;population&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; f)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(p)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3）send()方法的使用&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; my_func():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;First&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    send1 &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt; 1     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; yield后面的值是next方法调用的返回值，而前面的值是yield接收值之后赋值的变量&lt;/span&gt;
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Second&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;此次send传送的值为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, send1)
    send2 &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt; 2
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Third&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;此次send传送的值为：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, send2)
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; 3
    &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;End&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
  
m &lt;/span&gt;= my_func()           &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里并不会执行这个函数，因为只要函数内部定义了yield关键字，函数就变成了生成器，只有通过next方法调用&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(m.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(m.send(None) )    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里的send(None),就相当于__next__()方法，触发一次生成器&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; send()函数将值传递给当前停留位置的yield，之后这个yield会将值传递给前面的变量&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(m.send(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这是第二次send&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4）yield from&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;yield from可以直接把迭代对象中的每一个数据作为生成器的结果进行返回&lt;/li&gt;
&lt;li&gt;因为yield from是将列表中的每一个元素返回，所以写两个yield from并不会产生交替的效果&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func():
    lst1 &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;卫龙&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;老冰棍&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;北冰洋&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;牛羊配&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    lst2 &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;馒头&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;花卷&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;豆包&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;大饼&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; lst1
    &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; lst2
g &lt;/span&gt;=&lt;span&gt; func()
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; g:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(i)
    
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 卫龙&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 老冰棍&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 北冰洋&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 牛羊配&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 馒头&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 花卷&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 豆包&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 大饼&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;5）额外&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func3():
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
        &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt;&lt;span&gt; i

t &lt;/span&gt;=&lt;span&gt; func3()
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; for i in t:            # 因为for循环的工作机制就是使用迭代器协议调用next方法，所以会触发生成器函数&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     print(i)&lt;/span&gt;
&lt;span&gt;
li1 &lt;/span&gt;= (i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; t)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里li1会得到一个生成器的地址&lt;/span&gt;
li2 = (i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; li1)   
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(type(li1))
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(list(li1))         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里的list函数中会用for循环机制取值，从而触发生成器，现在这个位置li1中的值已经被取完了&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(list(li2))         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因li1中的值已经被取完了，所以li2现在已经取不到值了&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.3 推导式&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;推导式有：列表推导式、字典推导式、集合推导式&lt;/li&gt;
&lt;li&gt;没有元组推导式&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1）列表推导式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;三元表达式
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hgzero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
ret &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;me&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; name == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hgzero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;else&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;other&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 若name等于hgzero，则返回me，否则返回other&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(ret)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li readability=&quot;-1&quot;&gt;列表推导式（列表解析）
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
list1 = [i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10)]                 &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 列表解析会将生成的列表直接放于内存中，会占用较大的内存&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list1)
list2 &lt;/span&gt;= [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数字%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10)]       &lt;span&gt;#&lt;/span&gt;&lt;span&gt; for循环处理后将i依次往前面传递&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(list2)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li readability=&quot;-1.5&quot;&gt;筛选模式（三元表达式和列表解析的使用示例）
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;三元表达式和列表解析结合&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
list3 &lt;/span&gt;= [&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数字%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10) &lt;span&gt;if&lt;/span&gt; i &amp;gt; 5]   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里不能使用else，因为已经构成了三元表达式了&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(list3)
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2）生成器推导式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将列表推导式外围的中括号换成小括号就变成了一个生成器推导式&lt;/li&gt;
&lt;li&gt;生成器推导式也可以使用筛选模式&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;生成器表达式：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
list2 &lt;/span&gt;= (&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;数字%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10))    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将列表解析表达式外围的中括号换成小括号就变成了一个生成器&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 生成器表达式更节省内存&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(list2)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(list2.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(list2.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(list2.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(list2.&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;())

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 可以将生成器表达式传递给sum()等函数，以节省占用内存的大小&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;(sum(i &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(100000&lt;span&gt;)))        
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里的sum函数里面的生成器表达式不需要加括号&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 如果直接在sum中传入一个非常大的列表，会造成占用太多内存而导致机器卡死，而用生成器的方式传入则会动态的占用很小的一片内存&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;3）字典推导式&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
lst1 = [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jay&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;huazai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
lst2 &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;周杰伦&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;林俊杰&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;刘德华&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
dic &lt;/span&gt;= {lst1[i]:lst2[i] &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(len(lst1))}
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(dic)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;4）集合推导式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;集合推导式可以直接生成一个集合&lt;/li&gt;
&lt;li&gt;集合的特点：无需、不重复，所以集合推导式自带去重功能&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
lst = [1,2,3,-1,-3,-7,9&lt;span&gt;]
s &lt;/span&gt;= {abs(i) &lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lst}
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(s)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.4 生产者消费者模型&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; def producer():&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     ret = []&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     for i in range(100):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;         time.sleep(0.1)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;         ret.append(&quot;包子%s&quot; % i)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     return ret&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; def consumer(ret):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;     for index, baozi in enumerate(ret):&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;         time.sleep(0.1)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;         print(&quot;第%d个人来了，吃了第%s个包子&quot; % (index, baozi))&lt;/span&gt;&lt;span&gt;
#
#&lt;/span&gt;&lt;span&gt; p = producer()&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; consumer(p)&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; producer():
     c1 &lt;/span&gt;= consumer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hgzero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)     
     c2 &lt;/span&gt;= consumer(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wuzhihao&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
     c1.&lt;/span&gt;&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;()
     c2.&lt;/span&gt;&lt;span&gt;__next__&lt;/span&gt;&lt;span&gt;()
     &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(10&lt;span&gt;):
         time.sleep(&lt;/span&gt;1&lt;span&gt;)
         &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;现在包子 %s 已经做好了！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; i)
         c1.send(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第%s个包子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; i)
         c2.send(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;第%s个包子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; i)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; consumer(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;吃包子开始！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
        baozi &lt;/span&gt;= &lt;span&gt;yield&lt;/span&gt;&lt;span&gt;
        time.sleep(&lt;/span&gt;1&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;我是 %s , 现在开始吃 %s 包子&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (name, baozi))

producer()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.5 闭包&lt;/h3&gt;
&lt;p&gt;在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用，这样就构成了一个闭包。简单来说，闭包就是内层函数，对外层函数变量的引用。&lt;/p&gt;
&lt;p&gt;一般情况下，如果一个函数执行结束，则这个函数的内部的变量以及局部命名空间中的内容都会被释放掉。但是在闭包中，如果外函数在结束的时候发现有自己的临时变量将来会在内部函数中用到，就把这个临时变量绑定给了内部函数，然后自己再结束。也就说，使用闭包，可以保证外部函数中的变量在内存中常驻，以供后面的程序使用。&lt;/p&gt;
&lt;p&gt;其实闭包中外部函数的返回值定义成内部函数的地址，是为了防止内部函数被垃圾回收机制回收。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func1():  
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func2(): 
        s &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;地主家的傻儿子&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
        &lt;span&gt;def&lt;/span&gt;&lt;span&gt; func3():       
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(s)      
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func3 
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func2
func1()()()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.6 解压序列&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解压序列：&lt;/span&gt;
a, *b, c = [1, 2, 3, 4, 5, 6, 7, 8, 9]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里的 * 号表示所有的意思&lt;/span&gt;
&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(b)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(c)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 交换两个变量的值：&lt;/span&gt;
a = 1&lt;span&gt;
b &lt;/span&gt;= 2
&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;通过中间变量的形式交换：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
c &lt;/span&gt;=&lt;span&gt; a
a &lt;/span&gt;=&lt;span&gt; b
b &lt;/span&gt;=&lt;span&gt; c
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(a, b)

&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;另外两种不引入额外变量实现交换的方式：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
f1 &lt;/span&gt;= 1&lt;span&gt;
f2 &lt;/span&gt;= 2&lt;span&gt;
f1, f2 &lt;/span&gt;=&lt;span&gt; f2, f1
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(f1, f2)

n1 &lt;/span&gt;= 1&lt;span&gt;
n2 &lt;/span&gt;= 2&lt;span&gt;
n1 &lt;/span&gt;= n1 +&lt;span&gt; n2
n2 &lt;/span&gt;= n1 -&lt;span&gt; n2
n1 &lt;/span&gt;= n1 -&lt;span&gt; n2
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(n1, n2)
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;3. 装饰器&lt;/h2&gt;
&lt;h3&gt;3.1 装饰器概述&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;装饰器：本质上就是函数，功能是为其他函数添加附加功能&lt;/li&gt;
&lt;li&gt;原则：
&lt;ul&gt;&lt;li&gt;不修改被修饰函数的源代码&lt;/li&gt;
&lt;li&gt;不修改被修饰函数的调用方法&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;装饰器 = 高阶函数 + 函数嵌套 + 闭包&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;3.2 装饰器的实现方式&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;1）用高阶函数的方式实现装饰器的功能&lt;/strong&gt;：不合格，因为这种方式会使工作函数调用了两次&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;    1.不修改被修饰函数的源代码&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;    2. 不修改被修饰函数的调用方式&lt;/span&gt;

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 装饰器 = 高阶函数+函数嵌套+闭包&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用高阶函数的形式想实现装饰器的功能，不合格，因为这种方式会使工作函数调用了两次&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; work_func():
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是work_func函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; dec_func(func):
    start_time &lt;/span&gt;=&lt;span&gt; time.time()
    func()
    finish_time &lt;/span&gt;=&lt;span&gt; time.time()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这个函数运行的时间是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (finish_time-&lt;span&gt;start_time))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; func

work_func &lt;/span&gt;= dec_func(work_func)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里在赋值之前就已经执行了dec_func(work_func)函数&lt;/span&gt;
work_func()                   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里又执行了一便work_func函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;2）用高阶函数 + 函数嵌套 + 闭包的方式实现装饰器&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; work_func2():
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是work_func2函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; dec_func2(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wapper():
        start_time &lt;/span&gt;=&lt;span&gt; time.time()
        func()
        finish_time &lt;/span&gt;=&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这个函数运行的时间是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (finish_time -&lt;span&gt; start_time))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wapper

work_func2 &lt;/span&gt;= dec_func2(work_func2)   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里执行dec_func2函数时遭遇一个闭包，得到的是闭包wrapper函数的内存地址(并没有执行它)&lt;/span&gt;
work_func2()                         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里执行上面得到的闭包函数，即执行wapper()函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;3）用“语法糖”的形式实现装饰器&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; dec_func3(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; wapper():
        start_time &lt;/span&gt;=&lt;span&gt; time.time()
        func()
        finish_time &lt;/span&gt;=&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这个函数运行的时间是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (finish_time -&lt;span&gt; start_time))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wapper

@dec_func3     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 用“语法糖”的形式实现装饰器 ，相当于 work_func3 = dec_func3(work_func3)&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; work_func3():
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是work_func3函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
work_func3()   


&lt;/span&gt;&lt;span&gt;def&lt;/span&gt; dec_func4(func):   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 装饰器改进，添加返回值和多参数功能&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; wapper(*args, **&lt;span&gt;kwargs):
        start_time &lt;/span&gt;=&lt;span&gt; time.time()
        res &lt;/span&gt;= func(*args, **kwargs)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; func()函数的返回值就是work_func函数中的返回值，用res接收之后，再返回出去&lt;/span&gt;
        finish_time =&lt;span&gt; time.time()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这个函数运行的时间是%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (finish_time -&lt;span&gt; start_time))
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wapper

@dec_func4     &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; work_func4 = dec_func3(work_func3) 这时执行work_func4函数就是执行wapper函数，因为dec_func3函数返回的就是wapper的地址&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; work_func4(name, age):
    time.sleep(&lt;/span&gt;1&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这里是work_func4函数&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Name:【%s】，Age:【%d】&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (name, age))
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 12345                      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这时，work_func函数的返回值就是dec_func函数的闭包---&amp;gt; wapper函数的返回值&lt;/span&gt;
work_func4(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hgzero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, 21)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.3 带认证功能的装饰器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time

user &lt;/span&gt;=&lt;span&gt; [
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hgzero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wzh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
]

login_dict &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: None, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: False}    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里用这个字典模拟session的功能&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; login_func(func):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kwargs):
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; login_dict[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &lt;span&gt;and&lt;/span&gt; login_dict[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]:
            ret &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
            username &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入用户名：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
            passwd &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入密码：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; dict &lt;span&gt;in&lt;/span&gt;&lt;span&gt; user:
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; dict[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == username &lt;span&gt;and&lt;/span&gt; dict[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] ==&lt;span&gt; passwd:
                    login_dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; username
                    login_dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; True
                    ret &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名或密码错误！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                time.sleep(&lt;/span&gt;1&lt;span&gt;)
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请重新输入-----&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper

@login_func
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;欢迎来到zero的网站主页！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

@login_func
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; home(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】，欢迎来到个人中心！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (name))

@login_func
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; shopping(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】,现在您的购物车中有 %s ， %s ， %s &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;牛奶&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;香蕉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;芒果&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

index()
home(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python工程师&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
shopping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python工程师&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.4 带参数的装饰器&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; time
user &lt;/span&gt;=&lt;span&gt; [
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hgzero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;wzh&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;zero&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;},
    {&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;abc&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}
]

login_dict &lt;/span&gt;= {&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: None, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: False}    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 这里用这个字典模拟session的功能&lt;/span&gt;

&lt;span&gt;def&lt;/span&gt;&lt;span&gt; func(db_type):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; login_func(func):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;这个数据库的类型是：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, db_type)
        &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; wrapper(*args, **&lt;span&gt;kwargs):
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; login_dict[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] &lt;span&gt;and&lt;/span&gt; login_dict[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]:
                ret &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; True:
                username &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入用户名：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
                passwd &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请输入密码：&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).strip()
                &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; dict &lt;span&gt;in&lt;/span&gt;&lt;span&gt; user:
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; dict[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] == username &lt;span&gt;and&lt;/span&gt; dict[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] ==&lt;span&gt; passwd:
                        login_dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;username&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; username
                        login_dict[&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;login&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] =&lt;span&gt; True
                        ret &lt;/span&gt;= func(*args, **&lt;span&gt;kwargs)
                        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户名或密码错误！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
                    time.sleep(&lt;/span&gt;1&lt;span&gt;)
                    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;请重新输入-----&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; wrapper
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; login_func


@func(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;MySQL&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)  &lt;span&gt;#&lt;/span&gt;&lt;span&gt;  这里先执行func(&quot;MySQL&quot;)  ---&amp;gt;   index = login_func(index)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; 这里因为后面加了括号，所以是执行了func函数，执行了func函数所得到的返回值就是login_func函数的地址&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; func()函数执行得到的地址就是login_func,所以这里就等价于是 @login_func,同时也将参数传进去了，巧妙的运用了闭包的原理&lt;/span&gt;
&lt;span&gt;def&lt;/span&gt;&lt;span&gt; index():
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;欢迎来到zero的网站主页！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)

@func(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Mongodb&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; home(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】，欢迎来到个人中心！&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; %&lt;span&gt; (name))

@func(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; shopping(name):
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;【%s】,现在您的购物车中有 %s ， %s ， %s &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; % (name, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;牛奶&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;香蕉&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;芒果&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;))

index()
home(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python工程师&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
shopping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;python工程师&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;







</description>
<pubDate>Thu, 10 Dec 2020 14:51:00 +0000</pubDate>
<dc:creator>Praywu</dc:creator>
<og:description>1. 迭代器 1.1 可迭代对象（Iterator） 迭代器协议：某对象必须提供一个__next__()方法，执行方法要么返回迭代中的下一项，要么引起一个Stopiteration异常，以终止迭代（只</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hgzero/p/14117967.html</dc:identifier>
</item>
</channel>
</rss>