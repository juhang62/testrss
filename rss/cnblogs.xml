<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>自制触摸屏电话 - McKay</title>
<link>http://www.cnblogs.com/aarond/p/arduino_phone.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/aarond/p/arduino_phone.html</guid>
<description>&lt;p&gt;几个周末前闲着无聊做了个触摸屏电话，功能是简单了点，只能打电话、接电话、挂断、接听。而且个子还大了点，但是总归还算是做出了点东西，就晒晒。喷吧，哈哈。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/68230/201903/68230-20190318223505154-1892854547.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小触摸屏是这样的（按钮左上角的编号实际显示时是没有的，这里是截的设计状态的图）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/68230/201903/68230-20190318223637149-1659429868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;主要元件：触摸屏、arduino mega、sim800c、功放喇叭、电源（至少1A电流）&lt;/p&gt;
&lt;p&gt;原理很简单：&lt;/p&gt;
&lt;p&gt;设计触摸屏UI、按钮（厂家提供驱动可以通过arduino检测触摸的button）&lt;/p&gt;
&lt;p&gt;通过arduino去发送指令到sim800C&lt;/p&gt;
&lt;p&gt;先介绍下触摸屏UI的设计，如下图就是编辑器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/68230/201903/68230-20190318224421042-538012229.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Object_Id: 81代表对应按钮的id，这个id是会回传到arduino中的，需要对应上才行，比如arduino中检测到objectId=81被触发了就代表按下了某个按钮。&lt;/p&gt;
&lt;p&gt;右面的mckay_main代表页面，后面的5是具体arduino中的id，比如初始化的时候arduino会设置page 5 为默认页面&lt;/p&gt;
&lt;p&gt;图片也是可以自定义的，只是不能拉伸&lt;/p&gt;
&lt;p&gt;最上方的就是编译按钮了，会输出一个vImage.bin文件。&lt;/p&gt;
&lt;p&gt;接下来就是将这个vImage.bin烧录到触摸屏flash中了，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/68230/201903/68230-20190318225027661-680327237.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;记得先打开相应的COM接口，等到状态变成了 Open后，click  下载bin，然后就会先擦出整个flash存储，再慢慢写入了，这步是比较慢的。&lt;/p&gt;
&lt;p&gt;taobao链接：&lt;a href=&quot;https://item.taobao.com/item.htm?id=563235539384&amp;amp;_u=iq9aqj84c5&quot; target=&quot;_blank&quot;&gt;https://item.taobao.com/item.htm?id=563235539384&amp;amp;_u=iq9aqj84c5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;厂家会提供触摸屏LCD的设计软件以及接线方式（别忘了同时买USB转串口设备，有了就忽略，刚入门的话就买这个）&lt;/p&gt;

&lt;p&gt;接下来介绍下SIM800C &lt;/p&gt;
&lt;p&gt;淘宝链接：&lt;a href=&quot;https://item.taobao.com/item.htm?id=540672563189&amp;amp;_u=iq9aqj76d8&quot; target=&quot;_blank&quot;&gt;https://item.taobao.com/item.htm?id=540672563189&amp;amp;_u=iq9aqj76d8&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img.alicdn.com/imgextra/i1/230947266/TB20tPUaFOP.eBjSZFHXXXQnpXa_!!230947266.png&quot; alt=&quot;&quot; width=&quot;493&quot; height=&quot;400&quot;/&gt; &lt;/p&gt;
&lt;p&gt; 这个板子大家还是自己陶下，因为原子哥那里卖的贵。。很贵。。自己买个替代品吧，有便宜的。我是后来才发现买贵了。&lt;/p&gt;
&lt;p&gt;这个板子，看上去很多东西，但其实控制这个板子只要插好micro sim卡（得自己去办卡，或者现成的，得匹配好你买入的板上对应的sim卡座大小）、和通过AT指令就搞定了。&lt;/p&gt;
&lt;p&gt;部分AT指令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
拨号
ATD137xxxxxxxx;

挂断-主动挂断
ATH

接电话
ATA　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;那么arduino是如何发送这些指令给这个板呢?&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;SoftwareSerial.h&amp;gt;
&lt;/pre&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
SoftwareSerial SIM800C(10, 11);     // Serial RX, TX
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;是通过10、11数字pin口模拟了1个串口。　　&lt;/p&gt;
&lt;p&gt;这里刚接触的话比较绕，arduino的10是RX、11是TX；需要与SIM800C的TX，RX相连，就是：arduino 10(RX)----&amp;gt;sim800c tx口, arduino 11(TX)---&amp;gt;sim800c rx口&lt;/p&gt;
&lt;p&gt;sim800c的tx、rx位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/68230/201903/68230-20190318231150743-961402827.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除此之外，上图中央有2个黄色的pin口，其中1个标记了GND，这个需要与arduino的GND相连，必须相连，不然没效果。&lt;/p&gt;
&lt;p&gt;下面看看arduino代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:cpp;gutter:true;&quot;&gt;
#include &amp;lt;LiquidCrystalDisplay.h&amp;gt;             &lt;span&gt;//这个厂家会提供&lt;/span&gt;
#include &amp;lt;SoftwareSerial.h&amp;gt;                   &lt;span&gt;//这个是arduino标准库&lt;/span&gt;

uint8_t   identifier,cnt;
uint8_t   cmd_buffer[CMD_MAX_SIZE];
uint8_t   data_size;
uint8_t   update_en;
uint8_t   command_cmd;
uint8_t   command_statu;
uint8_t   command_length;

LiquidCrystal TFTlcd(13);//RST pin13
SoftwareSerial SIM800C(10, 11);     //Serial RX, TX

void setup()                                            &lt;span&gt;//setup是初始化函数，只运行1次&lt;/span&gt;
{
   update_en =0;
   data_size =0;
   TFTlcd.queue_reset();
   
   Serial.begin(9600);
   TFTlcd.begin();

   attachInterrupt(0,LcdIICInterrupt,FALLING);           &lt;span&gt;//pin 2口是中断0，触摸屏靠这个来发送中断命令，FALLING代表当高电平转变为低电平时触发&lt;/span&gt;
   TFTlcd.SetPage(5);                                    &lt;span&gt;//默认页id&lt;/span&gt;

   SIM800C.begin(9600);
}

void LcdIICInterrupt()
{
    command_cmd = TFTlcd.I2C_Read();
    TFTlcd.queue_push(command_cmd);
    for(cnt =0;cnt &amp;lt;2;cnt++)
    {
      identifier = TFTlcd.I2C_Read();
      TFTlcd.queue_push(identifier);
    }
    command_statu = TFTlcd.I2C_Read();
    TFTlcd.queue_push(command_statu);
    identifier = TFTlcd.I2C_Read();
    TFTlcd.queue_push(identifier);
    command_length = TFTlcd.I2C_Read();
    TFTlcd.queue_push(command_length);
    if((command_cmd == GET_EDIT_VALUE &amp;amp;&amp;amp; command_statu == 0x6f)||(command_cmd == GET_TOUCH_EDIT_VALUE &amp;amp;&amp;amp; command_statu == 0x6f))
    {
      for(cnt =0;cnt &amp;lt;command_length;cnt++)
      {
        identifier = TFTlcd.I2C_Read();
        TFTlcd.queue_push(identifier);
      }
    }
}

void loop()                                               &lt;span&gt;//循环执行的函数&lt;/span&gt;
{
  data_size = TFTlcd.queue_find_cmd(cmd_buffer,CMD_MAX_SIZE);
  if(data_size&amp;gt;0)
      ProcessMessage((PCTRL_MSG)cmd_buffer, data_size);
}

void ProcessMessage( PCTRL_MSG msg, uint16_t dataSize )
{
    uint8_t cmd_type    = msg-&amp;gt;cmd_type;
    uint8_t control_id  = msg-&amp;gt;control_id;
    uint8_t page_id     = msg-&amp;gt;page_id;
    uint8_t _status     = msg-&amp;gt;status;
    uint8_t key_type    = msg-&amp;gt;key_type;
    uint8_t key_value   = msg-&amp;gt;key_value;

    if(control_id==81)                                   &lt;span&gt;//不同的id，代表不同的按钮的被按下&lt;/span&gt;
        dial(&quot;137xxxxxxxx&quot;);
    else if(control_id==82)
        dial(&quot;137xxxxxxxx&quot;);
    else if(control_id==83)
        dial(&quot;137xxxxxxxx&quot;);
    else if(control_id==84)
        dial(&quot;137xxxxxxxx&quot;);
    else if(control_id==89)
        send_cmd_to_sim800c(&quot;ATA&quot;);
    else if(control_id==86)
        send_cmd_to_sim800c(&quot;ATH&quot;);  
}

void dial(String mobileNumber)
{
    String dial_cmd=&quot;ATD&quot;+mobileNumber+&quot;;&quot;;
    send_cmd_to_sim800c(dial_cmd);
}
void send_cmd_to_sim800c(String at_cmd)
{
    Serial.println(at_cmd);
    SIM800C.println(at_cmd);
}　　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;主要的器件和程序就是上面这些了，不过离最终的完成还是需要其他组件的，比如：喇叭功放、降压模块转USB、1带n DC头、话筒&lt;/p&gt;
&lt;p&gt;OK，该继续学习新东西了，这个就先这样了。&lt;/p&gt;


&lt;p&gt;#include &amp;lt;SoftwareSerial.h&amp;gt;&lt;/p&gt;

</description>
<pubDate>Mon, 18 Mar 2019 15:24:00 +0000</pubDate>
<dc:creator>McKay</dc:creator>
<og:description>几个周末前闲着无聊做了个触摸屏电话，功能是简单了点，只能打电话、接电话、挂断、接听。而且个子还大了点，但是总归还算是做出了点东西，就晒晒。喷吧，哈哈。 小触摸屏是这样的（按钮左上角的编号实际显示时是没</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/aarond/p/arduino_phone.html</dc:identifier>
</item>
<item>
<title>python异步编程模块asyncio学习(一) - python学习中</title>
<link>http://www.cnblogs.com/c-x-a/p/10555976.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c-x-a/p/10555976.html</guid>
<description>&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;asyncio模块提供了使用协程构建并发应用的工具。它使用一种单线程单进程的的方式实现并发，应用的各个部分彼此合作, 可以显示的切换任务，一般会在程序阻塞I/O操作的时候发生上下文切换如等待读写文件,或者请求网络。同时asyncio也支持调度代码在将来的某个特定事件运行，从而支持一个协程等待另一个协程完成，以处理系统信号和识别其他一些事件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;异步并发的概念&quot;&gt;异步并发的概念&lt;/h3&gt;
&lt;p&gt;对于其他的并发模型大多数采取的都是线性的方式编写。并且依赖于语言运行时系统或操作系统的底层线程或进程来适当地改变上下文，而基于asyncio的应用要求应用代码显示的处理上下文切换。&lt;br/&gt;asyncio提供的框架以事件循环(event loop)为中心，程序开启一个无限的循环，程序会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数。&lt;/p&gt;
&lt;h4 id=&quot;事件循环&quot;&gt;事件循环&lt;/h4&gt;
&lt;p&gt;事件循环是一种处理多并发量的有效方式，在维基百科中它被描述为「一种等待程序分配事件或消息的编程架构」，我们可以定义事件循环来简化使用轮询方法来监控事件，通俗的说法就是「当A发生时，执行B」。事件循环利用poller对象，使得程序员不用控制任务的添加、删除和事件的控制。事件循环使用回调方法来知道事件的发生。它是asyncio提供的「中央处理设备」，支持如下操作：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;注册、执行和取消延迟调用（超时）&lt;/li&gt;
&lt;li&gt;创建可用于多种类型的通信的服务端和客户端的Transports&lt;/li&gt;
&lt;li&gt;启动进程以及相关的和外部通信程序的Transports&lt;/li&gt;
&lt;li&gt;将耗时函数调用委托给一个线程池&lt;/li&gt;
&lt;li&gt;单线程（进程）的架构也避免的多线程（进程）修改可变状态的锁的问题。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;与事件循环交互的应用要显示地注册将运行的代码，让事件循环在资源可用时向应用代码发出必要的调用。如：一个套接字再没有更多的数据可以读取，那么服务器会把控制全交给事件循环。&lt;/p&gt;
&lt;h4 id=&quot;future&quot;&gt;Future&lt;/h4&gt;
&lt;p&gt;future是一个数据结构，表示还未完成的工作结果。事件循环可以监视Future对象是否完成。从而允许应用的一部分等待另一部分完成一些工作。&lt;/p&gt;
&lt;h4 id=&quot;task&quot;&gt;Task&lt;/h4&gt;
&lt;p&gt;task是Future的一个子类，它知道如何包装和管理一个协程的执行。任务所需的资源可用时，事件循环会调度任务允许，并生成一个结果，从而可以由其他协程消费。&lt;/p&gt;
&lt;h3 id=&quot;异步方法&quot;&gt;异步方法&lt;/h3&gt;
&lt;p&gt;使用asyncio也就意味着你需要一直写异步方法。&lt;br/&gt;一个标准方法是这样的：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def regular_double(x):
    return 2 * x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而一个异步方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;async def async_double(x):
    return 2 * x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从外观上看异步方法和标准方法没什么区别只是前面多了个async。&lt;br/&gt;“Async” 是“asynchronous”的简写，为了区别于异步函数，我们称标准函数为同步函数，&lt;br/&gt;从用户角度异步函数和同步函数有以下区别：&lt;/p&gt;
&lt;p&gt;要调用异步函数，必须使用&lt;strong&gt;await&lt;/strong&gt;关键字。 因此，不要写regular_double(3)，而是写await async_double(3).&lt;br/&gt;不能在同步函数里使用await，否则会出错。&lt;br/&gt;句法错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def print_double(x):
    print(await async_double(x))   # &amp;lt;-- SyntaxError here&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是在异步函数中，await是被允许的:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;async def print_double(x):
    print(await async_double(x))   # &amp;lt;-- OK!&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;协程&quot;&gt;协程&lt;/h3&gt;
&lt;h4 id=&quot;启动一个协程&quot;&gt;启动一个协程&lt;/h4&gt;
&lt;p&gt;一般异步方法被称之为协程(Coroutine)。asyncio事件循环可以通过多种不同的方法启动一个协程。一般对于入口函数，最简答的方法就是使用run_until_complete(),并将协程直接传入这个方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


async def foo():
    print(&quot;这是一个协程&quot;)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        print(&quot;开始运行协程&quot;)
        coro = foo()
        print(&quot;进入事件循环&quot;)
        loop.run_until_complete(coro)
    finally:
        print(&quot;关闭事件循环&quot;)
        loop.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;开始运行协程
进入事件循环
这是一个协程
关闭事件循环&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就是最简单的一个协程的例子，下面让我们了解一下上面的代码.&lt;br/&gt;第一步首先得到一个事件循环的应用也就是定义的对象loop。可以使用默认的事件循环，也可以实例化一个特定的循环类(比如uvloop),这里使用了默认循环run_until_complete(coro)方法用这个协程启动循环，协程返回时这个方法将停止循环。&lt;br/&gt;run_until_complete的参数是一个futrue对象。当传入一个协程，其内部会自动封装成task，其中task是Future的子类。关于task和future后面会提到。&lt;/p&gt;
&lt;h4 id=&quot;从协程中返回值&quot;&gt;从协程中返回值&lt;/h4&gt;
&lt;p&gt;将上面的代码，改写成下面代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


async def foo():
    print(&quot;这是一个协程&quot;)
    return &quot;返回值&quot;


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        print(&quot;开始运行协程&quot;)
        coro = foo()
        print(&quot;进入事件循环&quot;)
        result = loop.run_until_complete(coro)
        print(f&quot;run_until_complete可以获取协程的{result}，默认输出None&quot;)
    finally:
        print(&quot;关闭事件循环&quot;)
        loop.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;run_until_complete可以获取协程的返回值，如果没有给定返回值，则像函数一样，默认返回None。&lt;/p&gt;
&lt;h4 id=&quot;协程调用协程&quot;&gt;协程调用协程&lt;/h4&gt;
&lt;p&gt;一个协程可以启动另一个协程，从而可以任务根据工作内容，封装到不同的协程中。我们可以在协程中使用&lt;strong&gt;await&lt;/strong&gt;关键字，链式的调度协程，来形成一个协程任务流。向下面的例子一样。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


async def main():
    print(&quot;主协程&quot;)
    print(&quot;等待result1协程运行&quot;)
    res1 = await result1()
    print(&quot;等待result2协程运行&quot;)
    res2 = await result2(res1)
    return (res1,res2)


async def result1():
    print(&quot;这是result1协程&quot;)
    return &quot;result1&quot;


async def result2(arg):
    print(&quot;这是result2协程&quot;)
    return f&quot;result2接收了一个参数,{arg}&quot;


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        result = loop.run_until_complete(main())
        print(f&quot;获取返回值:{result}&quot;)
    finally:
        print(&quot;关闭事件循环&quot;)
        loop.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;主协程
等待result1协程运行
这是result1协程
等待result2协程运行
这是result2协程
获取返回值:('result1', 'result2接收了一个参数,result1')
关闭事件循环&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;协程中调用普通函数&quot;&gt;协程中调用普通函数&lt;/h3&gt;
&lt;p&gt;在协程中可以通过一些方法去调用普通的函数。可以使用的关键字有call_soon,call_later，call_at。&lt;/p&gt;
&lt;h4 id=&quot;call_soon&quot;&gt;call_soon&lt;/h4&gt;
&lt;p&gt;可以通过字面意思理解调用立即返回。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;loop.call_soon(callback, *args, context=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在下一个迭代的时间循环中立刻调用回调函数,大部分的回调函数支持位置参数，而不支持”关键字参数”，如果是想要使用关键字参数，则推荐使用functools.aprtial()对方法进一步包装.可选关键字context允许指定要运行的回调的自定义contextvars.Context。当没有提供上下文时使用当前上下文。在Python 3.7中， asyncio&lt;br/&gt;协程加入了对上下文的支持。使用上下文就可以在一些场景下隐式地传递变量，比如数据库连接session等，而不需要在所有方法调用显示地传递这些变量。&lt;br/&gt;下面来看一下具体的使用例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio
import functools


def callback(args, *, kwargs=&quot;defalut&quot;):
    print(f&quot;普通函数做为回调函数,获取参数:{args},{kwargs}&quot;)


async def main(loop):
    print(&quot;注册callback&quot;)
    loop.call_soon(callback, 1)
    wrapped = functools.partial(callback, kwargs=&quot;not defalut&quot;)
    loop.call_soon(wrapped, 2)
    await asyncio.sleep(0.2)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(main(loop))
finally:
    loop.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;注册callback
普通函数做为回调函数,获取参数:1,defalut
普通函数做为回调函数,获取参数:2,not defalut&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过输出结果我们可以发现我们在协程中成功调用了一个普通函数，顺序的打印了1和2。&lt;/p&gt;
&lt;p&gt;有时候我们不想立即调用一个函数，此时我们就可以call_later延时去调用一个函数了。&lt;/p&gt;
&lt;h4 id=&quot;call_later&quot;&gt;call_later&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;loop.call_later(delay, callback, *args, context=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先简单的说一下它的含义，就是事件循环在delay多长时间之后才执行callback函数.&lt;br/&gt;配合上面的call_soon让我们看一个小例子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


def callback(n):
    print(f&quot;callback {n} invoked&quot;)


async def main(loop):
    print(&quot;注册callbacks&quot;)
    loop.call_later(0.2, callback, 1)
    loop.call_later(0.1, callback, 2)
    loop.call_soon(callback, 3)
    await asyncio.sleep(0.4)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main(loop))
    finally:
        loop.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;注册callbacks
callback 3 invoked
callback 2 invoked
callback 1 invoked&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的输出可以得到如下结果：&lt;br/&gt;1.&lt;strong&gt;call_soon&lt;/strong&gt;会在call_later之前执行，和它的位置在哪无关&lt;br/&gt;2.&lt;strong&gt;call_later&lt;/strong&gt;的第一个参数越小，越先执行。&lt;/p&gt;
&lt;h4 id=&quot;call_at&quot;&gt;call_at&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;loop.call_at(when, callback, *args, context=None)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;call_at第一个参数的含义代表的是一个单调时间，它和我们平时说的系统时间有点差异，&lt;br/&gt;这里的时间指的是事件循环内部时间，可以通过loop.time()获取，然后可以在此基础上进行操作。后面的参数和前面的两个方法一样。实际上call_later内部就是调用的call_at。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


def call_back(n, loop):
    print(f&quot;callback {n} 运行时间点{loop.time()}&quot;)


async def main(loop):
    now = loop.time()
    print(&quot;当前的内部时间&quot;, now)
    print(&quot;循环时间&quot;, now)
    print(&quot;注册callback&quot;)
    loop.call_at(now + 0.1, call_back, 1, loop)
    loop.call_at(now + 0.2, call_back, 2, loop)
    loop.call_soon(call_back, 3, loop)
    await asyncio.sleep(1)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        print(&quot;进入事件循环&quot;)
        loop.run_until_complete(main(loop))
    finally:
        print(&quot;关闭循环&quot;)
        loop.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;进入事件循环
当前的内部时间 4412.152849525
循环时间 4412.152849525
注册callback
callback 3 运行时间点4412.152942526
callback 1 运行时间点4412.253202825
callback 2 运行时间点4412.354262512
关闭循环&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为call_later内部实现就是通过call_at所以这里就不多说了。&lt;/p&gt;
&lt;h3 id=&quot;future-1&quot;&gt;Future&lt;/h3&gt;
&lt;h4 id=&quot;获取futrue里的结果&quot;&gt;获取Futrue里的结果&lt;/h4&gt;
&lt;p&gt;future表示还没有完成的工作结果。事件循环可以通过监视一个future对象的状态来指示它已经完成。future对象有几个状态：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Pending&lt;/li&gt;
&lt;li&gt;Running&lt;/li&gt;
&lt;li&gt;Done&lt;/li&gt;
&lt;li&gt;Cancelled&lt;br/&gt;创建future的时候，task为pending，事件循环调用执行的时候当然就是running，调用完毕自然就是done，如果需要停止事件循环，就需要先把task取消，状态为cancel。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;import asyncio


def foo(future, result):
    print(f&quot;此时future的状态:{future}&quot;)
    print(f&quot;设置future的结果:{result}&quot;)
    future.set_result(result)
    print(f&quot;此时future的状态:{future}&quot;)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        all_done = asyncio.Future()
        loop.call_soon(foo, all_done, &quot;Future is done!&quot;)
        print(&quot;进入事件循环&quot;)
        result = loop.run_until_complete(all_done)
        print(&quot;返回结果&quot;, result)
    finally:
        print(&quot;关闭事件循环&quot;)
        loop.close()
    print(&quot;获取future的结果&quot;, all_done.result())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;进入事件循环
此时future的状态:&amp;lt;Future pending cb=[_run_until_complete_cb() at /Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/asyncio/base_events.py:176]&amp;gt;
设置future的结果:Future is done!
此时future的状态:&amp;lt;Future finished result='Future is done!'&amp;gt;
返回结果 Future is done!
关闭事件循环
获取future的结果 Future is done!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过输出结果发现，调用set_result之后future对象的状态由pending变为finished&lt;br/&gt;，Future的实例all_done会保留提供给方法的结果，可以在后续使用。&lt;/p&gt;
&lt;h4 id=&quot;future对象使用await&quot;&gt;Future对象使用await&lt;/h4&gt;
&lt;p&gt;future和协程一样可以使用await关键字获取其结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


def foo(future, result):
    print(&quot;设置结果到future&quot;, result)
    future.set_result(result)


async def main(loop):
    all_done = asyncio.Future()
    print(&quot;调用函数获取future对象&quot;)
    loop.call_soon(foo, all_done, &quot;the result&quot;)

    result = await all_done
    print(&quot;获取future里的结果&quot;, result)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main(loop))
    finally:
        loop.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;future回调&quot;&gt;Future回调&lt;/h4&gt;
&lt;p&gt;Future 在完成的时候可以执行一些回调函数，回调函数按注册时的顺序进行调用:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio
import functools


def callback(future, n):
    print('{}: future done: {}'.format(n, future.result()))


async def register_callbacks(all_done):
    print('注册callback到future对象')
    all_done.add_done_callback(functools.partial(callback, n=1))
    all_done.add_done_callback(functools.partial(callback, n=2))


async def main(all_done):
    await register_callbacks(all_done)
    print('设置future的结果')
    all_done.set_result('the result')

if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        all_done = asyncio.Future()
        loop.run_until_complete(main(all_done))
    finally:
        loop.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过add_done_callback方法给funtrue任务添加回调函数，当funture执行完成的时候,就会调用回调函数。并通过参数future获取协程执行的结果。&lt;br/&gt;到此为止，我们就学会了如何在协程中调用一个普通函数并获取其结果。&lt;/p&gt;
&lt;h3 id=&quot;并发的执行任务&quot;&gt;并发的执行任务&lt;/h3&gt;
&lt;p&gt;任务（Task）是与事件循环交互的主要途径之一。任务可以包装协程，可以跟踪协程何时完成。任务是Future的子类，所以使用方法和future一样。协程可以等待任务，每个任务都有一个结果，在它完成之后可以获取这个结果。&lt;br/&gt;因为协程是没有状态的，我们通过使用create_task方法可以将协程包装成有状态的任务。还可以在任务运行的过程中取消任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


async def child():
    print(&quot;进入子协程&quot;)
    return &quot;the result&quot;


async def main(loop):
    print(&quot;将协程child包装成任务&quot;)
    task = loop.create_task(child())
    print(&quot;通过cancel方法可以取消任务&quot;)
    task.cancel()
    try:
        await task
    except asyncio.CancelledError:
        print(&quot;取消任务抛出CancelledError异常&quot;)
    else:
        print(&quot;获取任务的结果&quot;, task.result())


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main(loop))
    finally:
        loop.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;将协程child包装成任务
通过cancel方法可以取消任务
取消任务抛出CancelledError异常&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果把上面的task.cancel()注释了我们可以得到正常情况下的结果，如下。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;将协程child包装成任务
通过cancel方法可以取消任务
进入子协程
获取任务的结果 the result&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;另外出了使用loop.create_task将协程包装为任务外还可以使用asyncio.ensure_future(coroutine)建一个task。在python3.7中可以使用asyncio.create_task创建任务。&lt;/p&gt;
&lt;h3 id=&quot;组合协程&quot;&gt;组合协程&lt;/h3&gt;
&lt;p&gt;一系列的协程可以通过await链式的调用，但是有的时候我们需要在一个协程里等待多个协程，比如我们在一个协程里等待1000个异步网络请求，对于访问次序有没有要求的时候，就可以使用另外的关键字wait或gather来解决了。wait可以暂停一个协程，直到后台操作完成。&lt;/p&gt;
&lt;h4 id=&quot;等待多个协程&quot;&gt;等待多个协程&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Task的使用&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


async def num(n):
    try:
        await asyncio.sleep(n*0.1)
        return n
    except asyncio.CancelledError:
        print(f&quot;数字{n}被取消&quot;)
        raise


async def main():
    tasks = [num(i) for i in range(10)]
    complete, pending = await asyncio.wait(tasks, timeout=0.5)
    for i in complete:
        print(&quot;当前数字&quot;,i.result())
    if pending:
        print(&quot;取消未完成的任务&quot;)
        for p in pending:
            p.cancel()


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main())
    finally:
        loop.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当前数字 1
当前数字 2
当前数字 0
当前数字 4
当前数字 3
取消未完成的任务
数字5被取消
数字9被取消
数字6被取消
数字8被取消
数字7被取消&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现我们的结果并没有按照数字的顺序显示，在内部wait()使用一个set保存它创建的Task实例。因为set是无序的所以这也就是我们的任务不是顺序执行的原因。wait的返回值是一个元组，包括两个集合，分别表示已完成和未完成的任务。wait第二个参数为一个超时值&lt;br/&gt;达到这个超时时间后，未完成的任务状态变为pending，当程序退出时还有任务没有完成此时就会看到如下的错误提示。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Task was destroyed but it is pending!
task: &amp;lt;Task pending coro=&amp;lt;num() done, defined at 11.py:12&amp;gt; wait_for=&amp;lt;Future pending cb=[&amp;lt;TaskWakeupMethWrapper object at 0x1093e0558&amp;gt;()]&amp;gt;&amp;gt;
Task was destroyed but it is pending!
task: &amp;lt;Task pending coro=&amp;lt;num() done, defined at 11.py:12&amp;gt; wait_for=&amp;lt;Future pending cb=[&amp;lt;TaskWakeupMethWrapper object at 0x1093e06d8&amp;gt;()]&amp;gt;&amp;gt;
Task was destroyed but it is pending!
task: &amp;lt;Task pending coro=&amp;lt;num() done, defined at 11.py:12&amp;gt; wait_for=&amp;lt;Future pending cb=[&amp;lt;TaskWakeupMethWrapper object at 0x1093e0738&amp;gt;()]&amp;gt;&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时我们可以通过迭代调用cancel方法取消任务。也就是这段代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if pending:
        print(&quot;取消未完成的任务&quot;)
        for p in pending:
            p.cancel()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;gather的使用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;gather的作用和wait类似不同的是。&lt;br/&gt;1.gather任务无法取消。&lt;br/&gt;2.返回值是一个结果列表&lt;br/&gt;3.可以按照传入参数的顺序，顺序输出。&lt;br/&gt;我们将上面的代码改为gather的方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio


async def num(n):
    try:
        await asyncio.sleep(n * 0.1)
        return n
    except asyncio.CancelledError:
        print(f&quot;数字{n}被取消&quot;)
        raise


async def main():
    tasks = [num(i) for i in range(10)]
    complete = await asyncio.gather(*tasks)
    for i in complete:
        print(&quot;当前数字&quot;, i)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main())
    finally:
        loop.close()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当前数字 0
当前数字 1
....中间部分省略
当前数字 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;gather通常被用来阶段性的一个操作，做完第一步才能做第二步，比如下面这样&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio

import time


async def step1(n, start):
    await asyncio.sleep(n)
    print(&quot;第一阶段完成&quot;)
    print(&quot;此时用时&quot;, time.time() - start)
    return n


async def step2(n, start):
    await asyncio.sleep(n)
    print(&quot;第二阶段完成&quot;)
    print(&quot;此时用时&quot;, time.time() - start)
    return n


async def main():
    now = time.time()
    result = await asyncio.gather(step1(5, now), step2(2, now))
    for i in result:
        print(i)
    print(&quot;总用时&quot;, time.time() - now)


if __name__ == '__main__':
    loop = asyncio.get_event_loop()
    try:
        loop.run_until_complete(main())
    finally:
        loop.close()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;第二阶段完成
此时用时 2.0014898777008057
第一阶段完成
此时用时 5.002960920333862
5
2
总用时 5.003103017807007&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过上面结果得到如下结论：&lt;br/&gt;1.step1和step2是并行运行的。&lt;br/&gt;2.gather会等待最耗时的那个完成之后才返回结果，耗时总时间取决于其中任务最长时间的那个。&lt;/p&gt;
&lt;h4 id=&quot;任务完成时进行处理&quot;&gt;任务完成时进行处理&lt;/h4&gt;
&lt;p&gt;as_complete是一个生成器，会管理指定的一个任务列表，并生成他们的结果。每个协程结束运行时一次生成一个结果。与wait一样，as_complete不能保证顺序，不过执行其他动作之前没有必要等待所以后台操作完成。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import asyncio
import time


async def foo(n):
    print('Waiting: ', n)
    await asyncio.sleep(n)
    return n


async def main():
    coroutine1 = foo(1)
    coroutine2 = foo(2)
    coroutine3 = foo(4)

    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    for task in asyncio.as_completed(tasks):
        result = await task
        print('Task ret: {}'.format(result))


now = lambda : time.time()
start = now()

loop = asyncio.get_event_loop()
done = loop.run_until_complete(main())
print(now() - start)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Waiting:  1
Waiting:  2
Waiting:  4
Task ret: 1
Task ret: 2
Task ret: 4
4.004292249679565&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以发现结果逐个输出。&lt;/p&gt;
&lt;p&gt;到此为止第一部分就结束了，对于asyncio入门级学习来说这些内容就够了。如果想继续跟进asyncio的内容，敬请期待后面的内容。&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;更多异步内容请关注微信公众号：python学习开发&lt;/p&gt;
</description>
<pubDate>Mon, 18 Mar 2019 15:21:00 +0000</pubDate>
<dc:creator>python学习中</dc:creator>
<og:description>asyncio模块提供了使用协程构建并发应用的工具。它使用一种单线程单进程的的方式实现并发，应用的各个部分彼此合作, 可以显示的切换任务，一般会在程序阻塞I/O操作的时候发生上下文切换如等待读写文件,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/c-x-a/p/10555976.html</dc:identifier>
</item>
<item>
<title>String、StringBuffer、StringBuilder的比较 - 吴永吉</title>
<link>http://www.cnblogs.com/wuyongji/p/10555941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wuyongji/p/10555941.html</guid>
<description>&lt;p&gt;　　看String类的定义：public final class String...{private final char value[];}&lt;/p&gt;
&lt;p&gt;　　看AbstractStringBuilder类的定义：abstract class AbstractStringBuilder...{char[] value;}&lt;/p&gt;
&lt;p&gt;　　PS:StringBuffer类和StringBuilder类都继承自AbstractStringBuilder类&lt;/p&gt;
&lt;p&gt;　　我们不难发现：在String类中有一个char类型的数组变量value，用final修饰说明大小不可变，用来存放String类型数据，实际字符串底层就是用字符数组来存储的；而在AbstractStringBuilder类中也有一个char类型的数组变量value，但是没有任何修饰，表示大小可变。&lt;/p&gt;
&lt;p&gt;　　直接上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.bjwyj.method;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt; * 测试String、StringBuffer、StringBuilder的区别和联系
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt; * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; 吴永吉
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt; *
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestString {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        testString();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        testStringBuffer();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        testStringBuilder();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;     * 测试String对象的追加
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testString() {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         String str = &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;10000;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             str +=&lt;span&gt; i;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; endTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         System.out.println(endTime-&lt;span&gt;startTime);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;     * 测试StringBuffer对象的追加
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testStringBuffer() {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         StringBuffer sbuf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuffer();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;10000;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            sbuf.append(i);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; endTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         System.out.println(endTime-&lt;span&gt;startTime);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;/**&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;     * 测试StringBuilder对象的追加
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testStringBuilder() {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         StringBuilder sbud = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StringBuilder();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; startTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;10000;i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;            sbud.append(i);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; endTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;         System.out.println(endTime-&lt;span&gt;startTime);
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试结果：&lt;/p&gt;

&lt;p&gt;　　从测试结果可以看出：同样是循环10000次的追加操作，结果却大不相同。String类每次追加字符串都会创建新的对象，消耗的时间最长，性能极差。而StringBuffer和StringBuilder每次追加字符串都是同一个对象，消耗的时间极短，性能良好。而StringBuffer比StringBuilder消耗的时间稍长一点点，原因是StringBuffer是线程安全的，而StringBuilder是线程不安全的，所以StringBuffer相比StringBuilder性能稍差一点点。&lt;/p&gt;
&lt;p&gt;　　总结：&lt;/p&gt;
&lt;p&gt;　　（1）String类是不可变类，即一旦一个String对象被创建后，包含在这个对象中的字符序列是不可改变的，直至这个对象销毁。&lt;/p&gt;&lt;p&gt;　　（2）StringBuffer类则代表一个字符序列可变的字符串，可以通过append、insert、reverse、setCharAt、setLength等方法改变其内容。一旦生成了最终的字符串，调用toString方法将其转变为String。&lt;/p&gt;&lt;p&gt;　　（3）JDK1.5新增了一个StringBuilder类，与StringBuffer相似，构造方法和方法基本相同。不同是StringBuffer是线程安全的，而StringBuilder是线程不安全的，所以性能略高。通常情况下，创建一个内容可变的字符串，应该优先考虑使用StringBuilder。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Mar 2019 15:15:00 +0000</pubDate>
<dc:creator>吴永吉</dc:creator>
<og:description>String、StringBuffer、StringBuilder</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wuyongji/p/10555941.html</dc:identifier>
</item>
<item>
<title>操作系统精髓与设计原理笔记——计算机系统概述 - 重设代码的天空</title>
<link>http://www.cnblogs.com/wangzxblog/p/10555949.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangzxblog/p/10555949.html</guid>
<description>&lt;h2&gt;关键术语&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;寄存器(&lt;/strong&gt;Register &lt;/strong&gt;)：寄存器是中央处理器内的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令，数据和地址。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;地址寄存器(Command &lt;strong&gt;Register MR&lt;/strong&gt;)&lt;/strong&gt;：用来保存当前 CPU所访问的内存单元的地址。由于在内存和CPU之间存在着操作速度上的差别，所以必须使用地址寄存器来保持地址信息，直到内存的读/写操作完成为止。&lt;span&gt;存储器地址寄存器（Memory Address Register MAR）,用于下一次读/写的存储器地址；I/O地址寄存器（I/O Address Register I/O AR）,用于确定一个特定的输入输出设备。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令寄存器（Instruction Register IR）&lt;/strong&gt;：将从地址寄存器取出的指令放在处理器的一个寄存器中，该放置指令的寄存器寄存器称为指令寄存器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据寄存器&lt;/strong&gt;：用来暂时存放计算过程中所用到的操作数、结果和信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;辅助存储器&lt;/strong&gt;：又称二级存储器，主要表现为非易失性，主要存储程序和数据文件，其表现形式是程序员可以看到的文件和记录，而不是单个字节或字。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中断(Interrupt)&lt;/strong&gt;：用于提高处理器效率的一种手段，中断整体可以分为4大类&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot; readability=&quot;3&quot;&gt;&lt;td&gt;程序中断&lt;/td&gt;
&lt;td&gt;在某些条件下由指令执行的结果产生，如算术溢出、除数为0、试图执行一条非法机器指令及访问用户不允许的存储器位置&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot; readability=&quot;2&quot;&gt;&lt;td&gt;时钟中断&lt;/td&gt;
&lt;td&gt;由处理器的计时器产生，允许操作系统以一定的规律执行函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot; readability=&quot;2&quot;&gt;&lt;td&gt;I/O中断&lt;/td&gt;
&lt;td&gt;由I/O控制器产生，用于发信号通知一个操作的正常完成或各种错误条件&lt;/td&gt;
&lt;/tr&gt;&lt;tr align=&quot;center&quot; valign=&quot;middle&quot; readability=&quot;2&quot;&gt;&lt;td&gt;硬件失效中断&lt;/td&gt;
&lt;td&gt;由诸如掉电或存储器奇偶校验错之类的故障产生&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;strong&gt;中断驱动I/O&lt;/strong&gt;：由处理器给I/O模块发送I/O命令，然后处理器继续做其他一些有用的工作。当I/O模块准备好与处理器交换数据时，他将打断处理器的执行并请求服务。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;计算机的基本构成&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;-----------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理器&lt;/strong&gt;：控制计算机的操作，执行数据处理功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存&lt;/strong&gt;：存储数据和程序。此类存储器通常是易失性的，既当计算机关机时，存储器的内容会丢失&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O模块&lt;/strong&gt;：在计算机和外部存取器之间移动数据。外部环境由各种外部设备组成，包括辅助存储器设备（如硬盘）、通信设备和终端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统总线&lt;/strong&gt;：在处理器、内存和I/O模块间提供通信的设施&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中央处理单元（CPU）&lt;/strong&gt;：当计算机只有有个处理器时，通常此处理器称为中央处理器，也称为中央处理单元&lt;/p&gt;
&lt;p&gt;---------------------------------------------------------------------------------------------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高速缓存&lt;/strong&gt;：高速缓存是用来协调CPU与主存之间存取速度的差异而设置的。一般情况下，CPU的工作速度高，但内存的工作速度相对较低，为了解决这个问题，通常使用高速缓存，高速缓存的存取速度介于CPU和主存之间。系统将一些CPU在近几个时间段经常访问的内容存入高速缓冲，当CPU需要使用数据时，先在高速缓存中找，如果找到，就不必访问内存了，找不到时，再找内存，这样就在一定程度上缓解了由于主存速度低造成的CPU“停工待料”的情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;可编程I/O&lt;/strong&gt;：当处理器正在执行程序并遇到一个与I/O相关的指令时，他会通过给相应的I/O模块发命令来执行这个指令。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分级存储体系&lt;/strong&gt;：分级存储是将数据采取不同的存储方式分别存储在不同性能的存储设备上，减少非重要性数据在一级本地磁盘所占用的空间，还可加快整个系统的存储性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接内存读取（Direct Memory Access DMA）&lt;/strong&gt;：是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。否则，CPU 需要从来源把每一片段的资料复制到&lt;a href=&quot;https://baike.baidu.com/item/%E6%9A%82%E5%AD%98%E5%99%A8/4308343&quot; target=&quot;_blank&quot; data-lemmaid=&quot;4308343&quot;&gt;暂存器&lt;/a&gt;，然后把它们再次写回到新的地方。在这个时间中，CPU 对于其他的工作来说就无法使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;命中率&lt;/strong&gt;：终端用户访问加速节点时，如果该节点有缓存住了要被访问的数据时就叫做命中，如果没有的话需要回原服务器取，就是没有命中。取数据的过程与用户访问是同步进行的，所以即使是重新取的新数据，用户也不会感觉到有延时。 命中率=命中数/（命中数+没有命中数）， 缓存命中率是判断加速效果好坏的重要因素之一&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;程序计数器(Program Counter)&lt;/strong&gt;：保存下一次要读取的指令地址，除非出现特殊情况，否则处理器在每次取指令后总是递增PC，以便能按顺序取下一条指令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令&lt;/strong&gt;：处理器执行的程序是由一组保存在存储器中的指令组成的。最简单的指令处理包括两步：处理器从存储器一次读取一条指令，然后执行每条指令&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;指令周期&lt;/strong&gt;：单个指令所需要的处理称为一个指令周期&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多核&lt;/strong&gt;：多核是指在一枚处理器中集成两个或多个完整的计算引擎&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多处理器&lt;/strong&gt;：在一枚处理器中集成两个或多个完整的计算引擎，此时处理器能支持系统总线上的多个处理器，由总线控制器提供所有总线控制信号和命令信号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;芯片多处理器&lt;/strong&gt;：将两个或多个处理器组装在同一块硅上的计算机&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;局部性&lt;/strong&gt;：在执行程序期间，处理器的指令访存和数据访存呈“簇”（指一组数据集合）状。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;空间局部性&lt;/strong&gt;：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;时间局部性&lt;/strong&gt;：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;栈&lt;/strong&gt;：又名堆栈，它是一种运算受限的线性表。其限制是仅允许在表的一端进行插入和删除运算。这一端被称为栈顶，相对地，把另一端称为栈底。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;堆栈结构&lt;/strong&gt;：向一个栈插入新元素又称作进栈、入栈或压栈，它是把新元素放到栈顶元素的上面，使之成为新的栈顶元素；从一个栈删除元素又称作出栈或退栈，它是把栈顶元素删除掉，使其相邻的元素成为新的栈顶元素。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;栈指针&lt;/strong&gt;：在栈操作过程中，指出栈顶元素所在的位置&lt;/p&gt;
&lt;h2&gt;复习题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.1 指出并简要定义计算机的4个基本组成部分？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理器：&lt;/strong&gt;控制计算机的操作，执行数据处理功能&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内存&lt;/strong&gt;：存储数据和程序。此类存储器通常是易失性的，既当计算机关机时，存储器的内容会丢失&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O模块&lt;/strong&gt;：在计算机和外部存取器之间移动数据。外部环境由各种外部设备组成，包括辅助存储器设备（如硬盘）、通信设备和终端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;系统总线&lt;/strong&gt;：在处理器、内存和I/O模块间提供通信的设施&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;1.2 定义处理器寄存器的两种主要类别？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存储器地址寄存器（Memory Address Register MAR）&lt;/strong&gt;,用于下一次读/写的存储器地址；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;I/O地址寄存器（I/O Address Register I/O AR）&lt;/strong&gt;,用于确定一个特定的输入输出设备。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.3 一般而言，一条机器指令能指令的4种不同操作是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;处理器-存储器&lt;/span&gt;&lt;/strong&gt;：数据可以从处理器传送到存储器，或从存储器传送到处理器&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;处理器-I/O&lt;/strong&gt;：通过处理器和I/O模块间的数据传送，数据可以输出到外部设备，或从外部设备向处理器输入数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据处理&lt;/strong&gt;：处理器可以执行很多与数据相关的算术操作和逻辑操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制&lt;/strong&gt;：某些指令可以改变执行顺序。例如：处理器从地址为149的存储单元中取出一条指令，该指令指定下一条指令应该从地址为182的存储单元中取，这样处理器就会把PC置为182.因此在下一个取址阶段，将从地址为182的存储单元而非150的存储单元获取指令。&lt;/p&gt;
&lt;p&gt;指令的执行可能涉及这些动作的组合。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.4 什么是中断？&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;1.5 多个中断的处理方式是什么？&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;4.5&quot;&gt;&lt;tr&gt;&lt;td&gt;处理方式&lt;/td&gt;
&lt;td&gt;优点&lt;/td&gt;
&lt;td&gt;缺点&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;在处理一个中断时，禁止再发生中断&lt;/td&gt;
&lt;td&gt;实现简单，所有中断都严格按照顺序处理&lt;/td&gt;
&lt;td&gt;未考虑相对优先级和时间限制的要求，有可能由于I/O设备的缓冲区装满或溢出而丢失数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;定义中断优先级，允许高优先级中断打断低优先级中断的运行&lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;&lt;span&gt;1.6 内存层次各个元素间的特征是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;每”位“的价格递减；容量递增；存取时间递增；处理器访问存储器的频率递减&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.7 什么是高速缓存？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;利用局部性原理，在处理器和内存之间提供一个容量小且速度快的存储器，称为高速缓存。&lt;/p&gt;
&lt;p&gt;1.8 多处理器系统和多核系统的区别是什么？&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1.9 空间局部性和时间局部性的区别是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;空间局部性指涉及多簇存储器单元的执行趋势，反映了处理器顺序访问指令的倾向，同时也反映了程序顺序访问数据单元的倾向，如处理数据表；&lt;/p&gt;
&lt;p&gt;时间局部性指处理器访问最近使用过的存储器单元的趋势，例如在执行一个循环时，处理器重复执行相同的指令集合&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.10 开发空间局部性和时间局部性的策略是什么？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;时间局部性是通过将近来使用的指令和数据保存到高速缓存中并使用高速缓存的层次结构实现的；&lt;/p&gt;
&lt;p&gt;空间局部性通常是使用较大的高速缓存并将预取机制集成到高速缓存控制逻辑中实现。&lt;/p&gt;

</description>
<pubDate>Mon, 18 Mar 2019 15:15:00 +0000</pubDate>
<dc:creator>重设代码的天空</dc:creator>
<og:description>关键术语 寄存器(Register )：寄存器是中央处理器内的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令，数据和地址。 地址寄存器(Command Register M</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangzxblog/p/10555949.html</dc:identifier>
</item>
<item>
<title>3-3 计算属性、方法和侦听器 - 如花红茶</title>
<link>http://www.cnblogs.com/ytraister/p/10555250.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ytraister/p/10555250.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;Vue的计算属性、方法和侦听器介绍：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本案例主要：定义firstName,lastName。然后把firstName和lastName组合fullName来输出&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先介绍之前提及到的引用方法：插值表达式&lt;/span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318154647770-1971248534.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;//而这种方法，会使得数据出现冗余的现象。 fullName和firstName,lastName的引用出现重复了&lt;/p&gt;

&lt;p&gt;&lt;span&gt;所以，现在介绍几种新的方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一：计算属性(computed)&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318155658977-197680880.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;//该方法：首先，定义了两个数据（firstName,lastName），再引入计算属性(computed) 的fullName方法来引用前面的两个数据，实现最优效果。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而计算属性有个特性：即=》内置缓存的概念，下面就来介绍一下：请看图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318160600475-881875757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;//这里引入了新的数据age，和fullName方法中的输出( console.log() )。&lt;/p&gt;
&lt;p&gt;//以下图片在控制台中查看：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;①：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318211226308-1475369644.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;②：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318211648891-161750819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;③：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318211819127-852621758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;//&lt;span&gt;综上：&lt;/span&gt;&lt;strong&gt;控制台图①&lt;/strong&gt;是页面原本的显示；在修改了age的属性之后，age的值发生改变（如&lt;strong&gt;控制台图②&lt;/strong&gt;），而fullName的值却没有发生变化；在修改了lastName属性后，fullName的值发生改变，age不变（如&lt;strong&gt;控制台图③&lt;/strong&gt;），并输出&lt;span&gt;&lt;span&gt;'计算了一次’&lt;/span&gt;&lt;/span&gt;。可以看出，computed计算属性的内置缓存的作用体现出来了，只有fullName的值发生改变，才会重新更新，而其他时候不关于fullName的值改变后，它会驻留在缓存中，不用去更新。性能更高！！！&lt;/p&gt;
&lt;p&gt;===================================================================&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二：方法(methods)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318215257072-780394836.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;//以上，运用methods方法来重写案例，需要注意的是第12行代码的fullName的引用，需要加上‘（）’。而且同样可以正常输出结果。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而&lt;span&gt;methods方法却没有计算属性的内置缓存特性，如下：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318215701914-66520496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;//这里引入了新的数据age，和fullName方法中的输出( console.log() )。&lt;/p&gt;
&lt;p&gt;//以下图片在控制台中查看：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;①：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318211226308-1475369644.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;②：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318215820255-223898543.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;③：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318220004503-1481606175.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;//&lt;span&gt;综上：&lt;/span&gt;&lt;strong&gt;控制台图①&lt;/strong&gt;是页面原本的显示；在修改了age的属性之后，age的值发生改变（如&lt;strong&gt;控制台图②&lt;/strong&gt;），而fullName的值却没有发生变化，但会输出&lt;span&gt;&lt;span&gt;‘&lt;/span&gt;&lt;span&gt;计算一次&lt;/span&gt;&lt;span&gt;’&lt;/span&gt;&lt;/span&gt;；在修改了lastName属性后，fullName的值发生改变，age不变（如&lt;strong&gt;控制台图③&lt;/strong&gt;），并输出&lt;span&gt;&lt;span&gt;'计算了一次’&lt;/span&gt;&lt;/span&gt;。可以看出，methods方法没有computed计算属性的内置缓存的作用，不论是age值还是fullName值的改变，都会重新更新数据。&lt;/p&gt;
&lt;p&gt;===================================================================&lt;/p&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;三：侦听器(watch)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318225441438-1278778741.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;//这里引入了新的数据age，和fullName方法中的输出( console.log() )。&lt;/p&gt;

&lt;p&gt;//以下图片在控制台中查看：&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;①：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318211226308-1475369644.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;②：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1575890/201903/1575890-20190318225112442-1004076000.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; //&lt;span&gt;综上，&lt;/span&gt;&lt;strong&gt;控制台图①&lt;/strong&gt;是页面原本的显示；在修改了age的属性之后，age的值发生改变，修改了lastName属性后，fullName的值发生改变，age不变（如&lt;strong&gt;控制台图②&lt;/strong&gt;），并输出'&lt;span&gt;计算了一次&lt;/span&gt;’。可以看出，侦听器（watch）和计算属性（computed）都具有内置缓存的作用并体现出来了，只有fullName的值发生改变，才会重新更新，而其他时候不关于fullName的值改变后，它会驻留在缓存中，不用去更新。但侦听器（watch）的麻烦之处在于：侦听的是firstName和lastName两个属性的变化，要编写的代码量相对大，而且还要在data中声明fullName属性的值，用于存放fullName的原始数据。&lt;/p&gt;
&lt;p&gt;===================================================================&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;&lt;span&gt;得出结论：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;computed和watch&lt;/strong&gt;都具备缓存的机制，而methods不具备；相对的，computed和watch会比methods好，而computed和watch相比，computed的编写代码会少很多。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;若一个案例中都可以运用上面的三种写法，推荐用computed来编写代码，它的使用效率高，代码编写量少，编写性能更高！&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Mar 2019 15:14:00 +0000</pubDate>
<dc:creator>如花红茶</dc:creator>
<og:description>Vue的计算属性、方法和侦听器介绍： 本案例主要：定义firstName,lastName。然后把firstName和lastName组合fullName来输出 首先介绍之前提及到的引用方法：插值表达</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ytraister/p/10555250.html</dc:identifier>
</item>
<item>
<title>再不了解PostgreSQL，你就晚了之PostgreSQL主从流复制部署 - 三升水</title>
<link>http://www.cnblogs.com/sanshengshui/p/10555930.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sanshengshui/p/10555930.html</guid>
<description>&lt;pre class=&quot;md-meta-block md-end-block&quot;&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/backgroud.jpg&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/backgroud.jpg&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-focus&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;在MySQL被收购之后，虽然有其替代品为: MariaDB,但是总感觉心里有点膈应。大家发现了另一款开源的数据库: PostgreSQL。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;虽然centos自带版本9.2也可以用，但是最近的几次升级支持了更多更新的内容，比如，PostgreSQL有一个MySQL无法比拟的优势，那就是PostGIS，PostGIS可以完美支持空间数据存储和空间分析；从PostgreSQL9.3起就内置了JSON数据类型，而9.4又开始支持JSONB，这标志着PostgreSQL实际上已经是一个关系型数据库和NoSQL数据库的结合体了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;虽然postgresql是一个关系型数据库，但是近几次更新PostgreSQL的NoSQL性能有益到甚至超过了MongoDB。我们可以从下图&lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://db-engines.com/en/ranking&quot;&gt;&lt;span&gt;数据库Rank榜&lt;/span&gt;&lt;/a&gt;&lt;span&gt;上观察到PostgreSQL排在第四位,和MongoDB的位置不相上下。可见PostgreSQL在开发人员的喜爱度上,可信赖度上和社区文档的查询上都是不错的。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/DB-Engines_Ranking.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/DB-Engines_Ranking.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;更新源&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;云服务器系统: CentOS 7.2 x86_64架构&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;地址: &lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://www.postgresql.org/download/linux/redhat/&quot;&gt;https://www.postgresql.org/download/linux/redhat/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/PostgreSQL-Yum_Repository.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/PostgreSQL-Yum_Repository.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这里我选择PostgreSQL10,CentOS 7平台, x86_64架构,就会出现相应的yum源了。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在centos系统中执行以下命令:&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;yum install https://download.postgresql.org/pub/repos/yum/10/redhat/rhel-7-x86_64/pgdg-centos10-10-2.noarch.rpm&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;安装PostgreSQL&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;先查看PostgreSQL源&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/Yum-Repository_List.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/Yum-Repository_List.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们需要安装的是这三个个。postgresql10-devel.x86_64, postgresql10-contrib.x86_64,postgresql10-server.x86_64&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt; yum install postgresql10-client postgresql10-server postgresql10-contrib postgresql10-devel&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;初始化数据库&lt;/span&gt;&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;PostgreSQL安装目录是/usr/pgsql-10,而PostgreSQL的数据目录是/var/lib/pgsql/版本号(这里为10)&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在这里，如果在装系统开始分配var空间足够大则可以继续，如果分配var空间不够，我们需要更改数据目录，在这里，我们假设var空间足够大。直接开始初始化。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;/usr/pgsql-10/bin/postgresql-10-setup initdb&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/initdb.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/initdb.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;显示这个代表初始化成功&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;启功数据库并设置开机启动&lt;/span&gt;&lt;/h2&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;sudo systemctl start postgresql-10&lt;br/&gt;&lt;span&gt;sudo systemctl enable postgresql-10.service&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;登录PostgreSQL并设置密码&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;postgresql在安装时默认添加用户postgres&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;输入&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;su - postgres&lt;br/&gt;&lt;span&gt;psql&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;进入数据库&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;命令界面长这样&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/PostgreSQL-Terminal.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/PostgreSQL-Terminal.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们来设置密码:&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/alter-password.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/alter-password.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;退出: \q&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;列出所有库 \l&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;列出所有用户 \du&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;列出库下所有表 \d&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;支持密码和远程登陆&lt;/span&gt;&lt;/h2&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;修改密码验证&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;默认情况下postgresql是不用密码不支持远程登录的。我们需要修改配置文件&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;vi /var/lib/pgsql/10/data/pg_hba.conf&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;原本长成这样&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/hba.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/hba.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们需要改成&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/update_hba.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/update_hba.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;保存退出&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;关于退出vim的问题，这里还有一个小趣闻：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;StackOverflow骄傲的宣布： 已经帮助187万不知如何从VIM退出的程序员&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/view_exit_vim.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/view_exit_vim.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在这里我引用上面的高赞回答，帮助大家脱离这个187万群体。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/QA_exit_vim.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/QA_exit_vim.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;修改远程访问&lt;/span&gt;&lt;/h3&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;vi /var/lib/pgsql/10/data/postgresql.conf&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;往下拉我们会看到&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/postgresql_conf.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/postgresql_conf.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;需要改成&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/after_postgresql_conf.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/after_postgresql_conf.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在vim中搜索想要查找的文字，可以用 /***, n 表示下翻页，N表示上翻页&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;重启postgresql&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;systemctl restart postgresql-10&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;登录postgresql&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;postgresql在安装时默认添加用户postgres&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;输入&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;su - postgres&lt;br/&gt;&lt;span&gt;psql&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;进入数据库&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/verify_password.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/verify_password.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;此时已经可以进行验证密码&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;远程连接数据库&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;我们使用Navicat Premium 12来验证连接&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/postgresql_test.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/postgresql_test.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;此时我们可以看到相关数据了&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/PostgreSQL_View.png&quot;&gt;&lt;img src=&quot;https://james-1258744956.cos.ap-shanghai.myqcloud.com/PostgreSQL%E4%B8%BB%E4%BB%8E%E6%B5%81%E5%A4%8D%E5%88%B6%E9%83%A8%E7%BD%B2%E5%AE%89%E8%A3%85/PostgreSQL_View.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;

&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;简介&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;postgres在9.0之后引入了主从的流复制机制，所谓流复制，就是从服务器通过tcp流从主服务器中同步相应的数据。这样当主服务器数据丢失时从服务器中仍有备份。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;与基于文件日志传送相比，流复制允许保持从服务器更新。 从服务器连接主服务器，其产生的流WAL记录到从服务器， 而不需要等待主服务器写完WAL文件。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;PostgreSQL流复制默认是异步的。在主服务器上提交事务和从服务器上变化可见之间有一个小的延迟，这个延迟远小于基于文件日志传送，通常1秒能完成。如果主服务器突然崩溃，可能会有少量数据丢失。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;同步复制必须等主服务器和从服务器都写完WAL后才能提交事务。这样在一定程度上会增加事务的响应时间。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;配置同步复制仅需要一个额外的配置步骤： &lt;span class=&quot; md-link&quot;&gt;&lt;a href=&quot;https://link.jianshu.com?t=http://www.postgres.cn/docs/9.4/runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES&quot;&gt;&lt;span&gt;synchronous_standby_names&lt;/span&gt;&lt;/a&gt;&lt;span&gt;必须设置为一个非空值。synchronous_commit也必须设置为on。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这里部署的是异步的流复制。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;主从服务器所在节点的系统、环境等最好一致。PostgreSQL版本也最好一致，否则可能会有问题。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p class=&quot;md-end-block&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;安装部署&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;先假定在192.168.20.93和192.168.20.94均安装PostgreSQL,具体情况按照实际IP地址。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;具体安装部署步骤见：&lt;span&gt;&lt;strong&gt;上述步骤&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2.1 主服务器&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;主服务器为192.168.20.93&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1.首先需要创建一个数据库用户进行主从同步。创建用户replica，并赋予登录和复制的权限。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
postgres# CREATE ROLE replica login replication encrypted password 'replica'；
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2.修改pg_hba.conf，允许replica用户来同步。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在pg_hba.conf里增加两行：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
host     all             all          192.168.20.94/32          trust   #允许94连接到主服务器
host   replication      replica       192.168.20.94/32          md5   #允许94使用replica用户来复制
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;这样，就设置了replica这个用户可以从192.168.20.93进行流复制请求。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;&lt;strong&gt;注：&lt;/strong&gt; &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span&gt;第二个字段必须要填replication&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;4.修改postgresql.conf&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
listen_addresses = '*'   # 监听所有IP
archive_mode = on  # 允许归档
archive_command = 'cp %p /opt/pgsql/pg_archive/%f'  # 用该命令来归档logfile segment
wal_level = hot_standby 
max_wal_senders = 32 # 这个设置了可以最多有几个流复制连接，差不多有几个从，就设置几个wal_keep_segments = 256 ＃ 设置流复制保留的最多的xlog数目
wal_sender_timeout = 60s ＃ 设置流复制主机发送数据的超时时间
max_connections = 100 # 这个设置要注意下，从库的max_connections必须要大于主库的
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;配置完两个文件后重启服务器。&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
systemctl restart postgresql-10
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3.测试94能否连接93数据库。在94上运行如下命令：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
psql -h 192.168.20.93 -U postgres
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;看看是否能进入数据库。若可以，则正常。&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;2.2 从服务器&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;1.从主节点拷贝数据到从节点&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
su - postgres
rm -rf /var/lib/pgsql/10/data/*   #先将data目录下的数据都清空
pg_basebackup -h 192.168.20.93 -U replica  -X stream -P  # 从93拷贝数据到94（基础备份）
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;2.配置recovery.conf&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;复制/usr/pgsql-9.4/share/recovery.conf.sample 到 /opt/pgsql/data/recovery.conf&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
cp /usr/pgsql-10/share/recovery.conf.sample /usr/pgsql-10/share/recovery.conf
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;修改recovery.conf&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
standby_mode = on    # 说明该节点是从服务器
primary_conninfo = 'host=192.168.20.93 port=5432 user=replica password=replica'  # 主服务器的信息以及连接的用户
recovery_target_timeline = 'latest'
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;3.配置postgresql.conf&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
wal_level = hot_standby
max_connections = 1000 ＃ 一般查多于写的应用从库的最大连接数要比较大
hot_standby = on ＃ 说明这台机器不仅仅是用于数据归档，也用于数据查询
max_standby_streaming_delay = 30s # 数据流备份的最大延迟时间
wal_receiver_status_interval = 10s # 多久向主报告一次从的状态，当然从每次数据复制都会向主报告状态，这里只是设置最长的间隔时间
hot_standby_feedback = on # 如果有错误的数据复制，是否向主进行反馈
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;配置完后重启从服务器&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
systemctl restart postgresql-10
&lt;/pre&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span&gt;3. 验证是否部署成功&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在主节点上执行：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
select client_addr,sync_state from pg_stat_replication;
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;结果如下：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
postgres=# select client_addr,sync_state from pg_stat_replication;
  client_addr  | sync_state
---------------+------------
 192.168.20.94 | async
(1 行记录)
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;说明94是从服务器，在接收流，而且是异步流复制。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;此外，还可以分别在主、从节点上运行 ps aux | grep postgres 来查看进程：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;主服务器（93）上：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
postgres 262270  0.0  0.0 337844  2832 ?        Ss   10:14   0:00 postgres: wal sender process replica 192.168.20.94(13059) streaming 0/A002A88
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可以看到有一个 wal sender 进程。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;从服务器（94）上：&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;md-fences mock-cm md-end-block&quot;&gt;
postgres 569868  0.0  0.0 384604  2960 ?        Ss   10:14   0:02 postgres: wal receiver process   streaming 0/A002B60
&lt;/pre&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;可以看到有一个 wal receiver 进程。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;至此，PostgreSQL主从流复制安装部署完成。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;在主服务器上插入数据或删除数据，在从服务器上能看到相应的变化。从服务器上只能查询，不能插入或删除。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;版权声明: 作者：穆书伟&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;github出处：&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://github.com/sanshengshui&quot;&gt;https://github.com/sanshengshui&lt;/a&gt;&lt;span&gt;　　　　&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block&quot;&gt;&lt;span&gt;个人博客出处：&lt;span class=&quot;md-link md-expand&quot;&gt;&lt;a href=&quot;https://www.mushuwei.cn/&quot;&gt;https://www.mushuwei.cn/&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Mar 2019 15:12:00 +0000</pubDate>
<dc:creator>三升水</dc:creator>
<og:description>前言 在MySQL被收购之后，虽然有其替代品为: MariaDB,但是总感觉心里有点膈应。大家发现了另一款开源的数据库: PostgreSQL。 虽然centos自带版本9.2也可以用，但是最近的几次</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sanshengshui/p/10555930.html</dc:identifier>
</item>
<item>
<title>[NewLife.XCode]高级增删改 - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/xcode_curd_adv.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/xcode_curd_adv.html</guid>
<description>&lt;p&gt;NewLife.XCode是一个有10多年历史的开源数据中间件，支持nfx/netstandard，由新生命团队(2002~2019)开发完成并维护至今，以下简称XCode。&lt;/p&gt;
&lt;p&gt;整个系列教程会大量结合示例代码和运行日志来进行深入分析，蕴含多年开发经验于其中，代表作有百亿级大数据实时计算项目。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/NewLifeX/X&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/X &lt;/a&gt;（求star, 707+）&lt;/p&gt;

&lt;p&gt; 前文&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd.html&quot; target=&quot;_blank&quot;&gt;《XCode添删改》&lt;/a&gt;给大家展示了添删改数据的基本概况，本文将详解添删改高级功能。&lt;/p&gt;


&lt;p&gt;最常用的添删改操作Insert/Update/Delete，实际是根据实体对象生成相应的SQL语句，由IEntityPersistence接口实现。&lt;/p&gt;
&lt;p&gt;** &lt;em&gt;IEntityPersistence在XCode内部有一个默认实现，用户可以自定义后注册到对象容器ObjectContainer中。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Insert&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; 生成标准Insert Into语句，根据设置决定是否使用参数化。（&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_setting.html#_label2&quot; target=&quot;_blank&quot;&gt;参数化设置&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190318223526257-383744102.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;91&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Insert&lt;/span&gt; &lt;span&gt;Into&lt;/span&gt; &lt;span&gt;User&lt;/span&gt;(Name, Password, DisplayName, Sex, Mail, Mobile, Code, Avatar, RoleID, RoleIDs, DepartmentID, Online, Enable, Logins, LastLogin, LastLoginIP, RegisterTime, RegisterIP, Ex1, Ex2, Ex3, Ex4, Ex5, Ex6, UpdateUser, UpdateUserID, UpdateIP, UpdateTime, Remark) &lt;span&gt;Values&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;张三&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;E10ADC3949BA59ABBE56E057F20F883E&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;, &lt;span&gt;null&lt;/span&gt;);&lt;span&gt;Select&lt;/span&gt; last_insert_rowid() &lt;span&gt;newid&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Insert把所有字段加入到SQL中，即使是没有设置数值的字段，也给予默认值。（自增字段显然不需要加入）&lt;/p&gt;
&lt;p&gt;生成的Insert Into语句，最后一部分是获取最近插入的自增ID，因此执行Insert以后，user.ID就取得了最新的自增值。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Update&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; 最精彩的部分，莫过于&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dirty.html&quot; target=&quot;_blank&quot;&gt;脏数据&lt;/a&gt;（后面将有专门文章介绍）。&lt;/p&gt;
&lt;p&gt;在XCode中，修改数据的标准流程是，先查出来，修改属性后保存。此时&lt;span&gt;生成的update set语句，只包含修改过的字段&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190318224755677-1852903823.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Update&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;Set&lt;/span&gt; Mobile&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;13012345678&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, Code&lt;span&gt;=&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;abcdef&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;Where&lt;/span&gt; ID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上，修改了3个字段，但是Name本来就是“张三”，因此实际上只修改了两个字段，也就是说只有两个字段有脏数据（数值改变被弄脏了）。&lt;/p&gt;
&lt;p&gt;最终生成的update set语句，只包含带有脏数据的字段。最后的where部分，则由主键组成。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;Delete&lt;/strong&gt;&lt;/span&gt; 就简单多了，只取了其中的主键字段，拼接where部分。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190318224454124-707664831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;Delete&lt;/span&gt; &lt;span&gt;From&lt;/span&gt; &lt;span&gt;User&lt;/span&gt; &lt;span&gt;Where&lt;/span&gt; ID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Save&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt; 是一个包装操作，它会根据主键来判断调用Insert或Update。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果实体对象来自数据库，Save时调用Update；&lt;/li&gt;
&lt;li&gt;自增主键，ID=0时调用Insert，否则调用Update；&lt;/li&gt;
&lt;li&gt;非自增主键，查询一次数据库，如果有数据则Update，没有则Insert，（这样子显然很傻）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实体类的添删改操作都可以重载（Insert/Update/Delete/OnInsert/OnUpdate/OnDelete）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190318225843812-709269607.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190318225854255-84741743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;重载后可以做业务代码判断，也可以级联更新其它表，还可以记录添删改操作日志，甚至还可以做假删除（重载OnDelete然后实际执行OnUpdate）&lt;/p&gt;
&lt;p&gt;分为两组重载，实际执行顺序是：Insert=&amp;gt;Valid=&amp;gt;EntityModule=&amp;gt;OnInsert&lt;/p&gt;


&lt;p&gt; 每个实体类在Insert/Update之前，都需要Valid验证数据 ，参数isNew以区分Insert。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201903/19592-20190318230043301-1004101534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Valid常常可用于判断主要字段的有效性，无效时强烈推荐抛出参数类异常，魔方NewLife.Cube表单将可以捕获并定位。&lt;/p&gt;
&lt;p&gt;除此之外，Valid用得更多的功能是在Insert/Update之前修改完善字段数据，例如上面对密码进行MD5散列，以及格式化RoleIDs。&lt;/p&gt;
&lt;p&gt;这里出现新技术，IsDirty和Dirtys，这是XCode的脏数据，前者判断Password字段是否有脏数据（Password被赋予跟原来不想等的值），后者清空Password脏数据。&lt;/p&gt;
&lt;p&gt;脏数据是生成Update语句的核心，不脏的字段不会出现在update set 之中，实现部分字段更新，后续有专门章节讲解。&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;实体过滤器EntityModule&lt;/strong&gt;，用于拦截实体类的添删改操作，内置最常用的3个过滤器UserModule/TimeModule/IPModule&lt;/p&gt;
&lt;p&gt;前面&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_model.html#_label3&quot; target=&quot;_blank&quot;&gt;《XCode数据模型文件》&lt;/a&gt;推荐的8个常用字段还记得吗？ CreateUser/CreateTime/CreateIP 等，所有CreateAbc将在Insert的时候拦截赋值，所有UpdateAbc将在Insert和Update的时候拦截赋值。&lt;/p&gt;
&lt;p&gt;UserModule取当前登录用户，由ManageProvider驱动；&lt;/p&gt;
&lt;p&gt;TimeModule取当前时间；&lt;/p&gt;
&lt;p&gt;IPModule取当前访问IP，由ManageProvider.UserHost提供；&lt;/p&gt;


&lt;p&gt;NewLife.XCode教程系列[2019版]&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd.html&quot; target=&quot;_blank&quot;&gt;增删改查入门&lt;/a&gt;。快速展现用法，代码配置连接字符串&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_model.html&quot; target=&quot;_blank&quot;&gt;数据模型文件&lt;/a&gt;。建立表格字段和索引，名字以及数据类型规范，推荐字段（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html&quot; target=&quot;_blank&quot;&gt;实体类详解&lt;/a&gt;。数据类业务类，泛型基类，接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_setting.html&quot; target=&quot;_blank&quot;&gt;功能设置&lt;/a&gt;。连接字符串，调试开关，SQL日志，慢日志，参数化，执行超时。代码与配置文件设置，连接字符串局部设置&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_negative.html&quot; target=&quot;_blank&quot;&gt;反向工程&lt;/a&gt;。自动建立数据库数据表&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_initdata.html&quot; target=&quot;_blank&quot;&gt;数据初始化&lt;/a&gt;。InitData写入初始化数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd_adv.html&quot; target=&quot;_blank&quot;&gt;高级增删改&lt;/a&gt;。重载拦截，自增字段，Valid验证，实体模型（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dirty.html&quot; target=&quot;_blank&quot;&gt;脏数据&lt;/a&gt;。如何产生，怎么利用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_additional.html&quot; target=&quot;_blank&quot;&gt;增量累加&lt;/a&gt;。高并发统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_transaction.html&quot; target=&quot;_blank&quot;&gt;事务处理&lt;/a&gt;。单表和多表，不同连接，多种写法&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_extend.html&quot; target=&quot;_blank&quot;&gt;扩展属性&lt;/a&gt;。多表关联，Map映射&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_search.html&quot; target=&quot;_blank&quot;&gt;高级查询&lt;/a&gt;。复杂条件，分页，自定义扩展FieldItem，查总记录数，查汇总统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dbcache.html&quot; target=&quot;_blank&quot;&gt;数据层缓存&lt;/a&gt;。Sql缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entitycache.html&quot; target=&quot;_blank&quot;&gt;实体缓存&lt;/a&gt;。全表整理缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_singlecache.html&quot; target=&quot;_blank&quot;&gt;对象缓存&lt;/a&gt;。字典缓存，适用用户等数据较多场景。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_100billion.html&quot; target=&quot;_blank&quot;&gt;百亿级性能&lt;/a&gt;。字段精炼，索引完备，合理查询，充分利用缓存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_factory.html&quot; target=&quot;_blank&quot;&gt;实体工厂&lt;/a&gt;。元数据，通用处理程序&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_membership.html&quot; target=&quot;_blank&quot;&gt;角色权限&lt;/a&gt;。Membership&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_import_export.html&quot; target=&quot;_blank&quot;&gt;导入导出&lt;/a&gt;。Xml，Json，二进制，网络或文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_division.html&quot; target=&quot;_blank&quot;&gt;分表分库&lt;/a&gt;。常见拆分逻辑&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_stat.html&quot; target=&quot;_blank&quot;&gt;高级统计&lt;/a&gt;。聚合统计，分组统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_batch.html&quot; target=&quot;_blank&quot;&gt;批量写入&lt;/a&gt;。批量插入，批量Upsert，异步保存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_queue.html&quot; target=&quot;_blank&quot;&gt;实体队列&lt;/a&gt;。写入级缓存，提升性能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_backup.html&quot; target=&quot;_blank&quot;&gt;备份同步&lt;/a&gt;。备份数据，恢复数据，同步数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_service.html&quot; target=&quot;_blank&quot;&gt;数据服务&lt;/a&gt;。提供RPC接口服务，远程执行查询，例如SQLite网络版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_bigdata.html&quot; target=&quot;_blank&quot;&gt;大数据分析&lt;/a&gt;。ETL抽取，调度计算处理，结果持久化&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Mon, 18 Mar 2019 15:03:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<og:description>前文《XCode添删改》给大家展示了添删改数据的基本概况，本文将详解添删改高级功能。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/xcode_curd_adv.html</dc:identifier>
</item>
<item>
<title>spring源码 — 四、MVC - lacker</title>
<link>http://www.cnblogs.com/sunshine-2015/p/10555748.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshine-2015/p/10555748.html</guid>
<description>&lt;p&gt;spring mvc是怎么实现的？为什么我们只需要在方法上写一个注解，就可以通过http访问这个接口？下面我们分3部分来解答这两个问题&lt;/p&gt;
&lt;p&gt;&lt;code&gt;注意：本文是基于spring4.3.2的&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;spring mvc整体流程&lt;/li&gt;
&lt;li&gt;HandlerMapping&lt;/li&gt;
&lt;li&gt;HandlerAdapter&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;spring-mvc整体流程&quot;&gt;spring mvc整体流程&lt;/h2&gt;
&lt;p&gt;我们通过看一下spring处理一个http请求的过程来大概了解下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/846961/201903/846961-20190318223910616-1664873574.png&quot; alt=&quot;spring_mvc&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Spring mvc的入口就是DispatcherServlet，请求交给这个servlet之后，通过调用doDispatch来分发这个请求，主要做了一下几件事情&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;处理multipart请求，如果有文件上传等请求，先封装为DefaultMultipartHttpServletRequest&lt;/li&gt;
&lt;li&gt;从HandlerMapping中获取处理该请求的handler，并构造HandlerExecutionChain，将入所有的interceptor&lt;/li&gt;
&lt;li&gt;根据handler从所有的HandlerAdapter中找到可以处理这个handler的adapter&lt;/li&gt;
&lt;li&gt;执行所有interceptor.prehandle方法&lt;/li&gt;
&lt;li&gt;调用写有RequestMapping注解的方法，返回ModelAndView&lt;/li&gt;
&lt;li&gt;执行所有interceptor.postHandle方法&lt;/li&gt;
&lt;li&gt;解析view&lt;/li&gt;
&lt;li&gt;render，将model转化为response返回&lt;/li&gt;
&lt;li&gt;执行所有interceptor.afterCompletion&lt;/li&gt;
&lt;li&gt;cleanupMultipart&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从上面的流程中可以看出，在处理过程中主要是一些关键组件完成了对应的逻辑，下面我们看下其中的组件。&lt;/p&gt;
&lt;h2 id=&quot;handlermapping&quot;&gt;HandlerMapping&lt;/h2&gt;
&lt;p&gt;作为DispatcherServlet组件之一，就是其中一个field&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;org.springframework.web.servlet.DispatcherServlet#handlerMappings&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主要作用是维护从url到Controller的映射，根据url找到对应的Controller。&lt;/p&gt;
&lt;h3 id=&quot;有哪些handlermapping&quot;&gt;有哪些HandlerMapping&lt;/h3&gt;
&lt;p&gt;spring是怎么查找所有的HandlerMapping的呢？是在DispatcherServlet初始化的时候查找并初始化这个字段的&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// org.springframework.web.servlet.DispatcherServlet#initHandlerMappings
private void initHandlerMappings(ApplicationContext context) {
    this.handlerMappings = null;

    if (this.detectAllHandlerMappings) {
        // Find all HandlerMappings in the ApplicationContext, including ancestor contexts.
        // 从容器中查找所有HandlerMapping类型的bean
        Map&amp;lt;String, HandlerMapping&amp;gt; matchingBeans =
            BeanFactoryUtils.beansOfTypeIncludingAncestors(context, HandlerMapping.class, true, false);
        if (!matchingBeans.isEmpty()) {
            this.handlerMappings = new ArrayList&amp;lt;HandlerMapping&amp;gt;(matchingBeans.values());
            // We keep HandlerMappings in sorted order.
            AnnotationAwareOrderComparator.sort(this.handlerMappings);
        }
    }
    else {
        try {
            HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class);
            this.handlerMappings = Collections.singletonList(hm);
        }
        catch (NoSuchBeanDefinitionException ex) {
            // Ignore, we'll add a default HandlerMapping later.
        }
    }

    // Ensure we have at least one HandlerMapping, by registering
    // a default HandlerMapping if no other mappings are found.
    if (this.handlerMappings == null) {
        this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class);
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;No HandlerMappings found in servlet '&quot; + getServletName() + &quot;': using default&quot;);
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么容器中有哪些HandlerMapping类型的bean呢？如果我们使用RequestMapping注解的话需要在xml中进行以下配置&lt;/p&gt;
&lt;pre class=&quot;ml&quot;&gt;
&lt;code&gt;&amp;lt;mvc:annotation-driven /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;spring解析这个标签使用的是&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类解析xml标签的时候会向容器中注册RequestMappingHandlerMapping，这个类继承自HandlerMapping&lt;/p&gt;
&lt;p&gt;如果我们进行了一下配置&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;mvc:default-servlet-handler /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;spring解析这个标签的使用的是&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;org.springframework.web.servlet.config.DefaultServletHandlerBeanDefinitionParser&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解析的时候spring会向容器注入DefaultServletHttpRequestHandler和SimpleUrlHandlerMapping&lt;/p&gt;
&lt;p&gt;那么&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;BeanNameHandlerMapping&lt;/li&gt;
&lt;li&gt;DefaultAnnotationHandlerMapping&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以这种情况下会有这三个HandlerMapping类型的bean，spring遍历handlerMappings来根据request path查找对应的handler。&lt;/p&gt;
&lt;h3 id=&quot;handlermapping怎么管理url到handler的映射关系&quot;&gt;HandlerMapping怎么管理url到handler的映射关系&lt;/h3&gt;
&lt;p&gt;HandlerMapping抽象类AbstractHandlerMethodMapping中有一个field&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// org.springframework.web.servlet.handler.AbstractHandlerMethodMapping
private final MappingRegistry mappingRegistry = new MappingRegistry();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类就是用来维护url到handler的映射，看下这个类有哪些数据结构&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.MappingRegistry
// 所有的mapping都会加入这个map中
private final Map&amp;lt;T, HandlerMethod&amp;gt; mappingLookup = new LinkedHashMap&amp;lt;T, HandlerMethod&amp;gt;();
// 只有具体的(没有通配符org.springframework.util.AntPathMatcher#isPattern)的才会加入这个map中
private final MultiValueMap&amp;lt;String, T&amp;gt; urlLookup = new LinkedMultiValueMap&amp;lt;String, T&amp;gt;();
// 根据name找handler
private final Map&amp;lt;String, List&amp;lt;HandlerMethod&amp;gt;&amp;gt; nameLookup =
    new ConcurrentHashMap&amp;lt;String, List&amp;lt;HandlerMethod&amp;gt;&amp;gt;();
// cors mapping
private final Map&amp;lt;HandlerMethod, CorsConfiguration&amp;gt; corsLookup =&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注册mapping的过程就是讲找到的mapping添加到上面对应的数据结构中，以RequestMappingHandlerMapping为例，具体注册的时机是在RequestMappingHandlerMapping bean初始化的时候，spring容器初始化完成以后会将容器中eagere init的bean进行初始化，构造bean的时候会调用afterPropertiesSet，最后会调用AbstractHandlerMethodMapping#initHandlerMethods来查找容器中所有的bean&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;找到容器中所有的bean&lt;/li&gt;
&lt;li&gt;针对每个bean查找里面有没有mapping&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在调用到initHandlerMethods方法的时候会拿出容器中所有的bean，用isHandler判断是否是handler，其实就是判断是否有Controller或RequestMapping的注解&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;protected boolean isHandler(Class&amp;lt;?&amp;gt; beanType) {
    return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||
            AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到类后，再找里面的方法，方法的查找逻辑就是看看方法上有没有RequestMapping，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private RequestMappingInfo createRequestMappingInfo(AnnotatedElement element) {
    // 查找方法上的RequestMapping注解
    RequestMapping requestMapping = AnnotatedElementUtils.findMergedAnnotation(element, RequestMapping.class);
    RequestCondition&amp;lt;?&amp;gt; condition = (element instanceof Class&amp;lt;?&amp;gt; ?
                                     getCustomTypeCondition((Class&amp;lt;?&amp;gt;) element) : getCustomMethodCondition((Method) element));
    return (requestMapping != null ? createRequestMappingInfo(requestMapping, condition) : null);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;找到对应的方法之后构造成mapping注册到MappingRegistry&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void register(T mapping, Object handler, Method method) {
    this.readWriteLock.writeLock().lock();
    try {
        HandlerMethod handlerMethod = createHandlerMethod(handler, method);
        assertUniqueMethodMapping(handlerMethod, mapping);

        if (logger.isInfoEnabled()) {
            logger.info(&quot;Mapped \&quot;&quot; + mapping + &quot;\&quot; onto &quot; + handlerMethod);
        }
        // 所有的mapping都会加入mappingLookup
        this.mappingLookup.put(mapping, handlerMethod);

        List&amp;lt;String&amp;gt; directUrls = getDirectUrls(mapping);
        // 找到所有具体的(直接的，就是不包含通配符)的url添加到urlLookup
        for (String url : directUrls) {
            this.urlLookup.add(url, mapping);
        }

        String name = null;
        if (getNamingStrategy() != null) {
            name = getNamingStrategy().getName(handlerMethod, mapping);
            addMappingName(name, handlerMethod);
        }

        CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);
        if (corsConfig != null) {
            this.corsLookup.put(handlerMethod, corsConfig);
        }

        this.registry.put(mapping, new MappingRegistration&amp;lt;T&amp;gt;(mapping, handlerMethod, directUrls, name));
    }
    finally {
        this.readWriteLock.writeLock().unlock();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在根据url查找handler的时候优先查找urlLookup，看看没有通配符的能不能匹配，如果没有直接匹配的则再从mappingLookup里面找&lt;/p&gt;
&lt;h2 id=&quot;handleradapter&quot;&gt;HandlerAdapter&lt;/h2&gt;
&lt;p&gt;HandlerAdapter是为了将invoke过程的细节对于DispatcherServlet屏蔽，比如参数解析。&lt;/p&gt;
&lt;p&gt;在DispatcherServlet初始化的时候调用inithandlerAdapters，在里面找容器中所有的handlerAdapter实现类，容器里面的handlerAdapter是在解析mvc标签的时候加入容器的&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这篇文章通过spring处理一次请求的过程了解了springmvc怎么工作，以及其中两个关键组件，HandlerMapping和HandlerAdapter。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Mar 2019 14:39:00 +0000</pubDate>
<dc:creator>lacker</dc:creator>
<og:description>spring mvc是怎么实现的？为什么我们只需要在方法上写一个注解，就可以通过http访问这个接口？下面我们分3部分来解答这两个问题 spring mvc整体流程 HandlerMapping Ha</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunshine-2015/p/10555748.html</dc:identifier>
</item>
<item>
<title>基于IPv6的数据包分析 - 先喝汤后吃饭</title>
<link>http://www.cnblogs.com/lxxkim/p/10555663.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lxxkim/p/10555663.html</guid>
<description>&lt;p&gt;&lt;span&gt;1.首先我们来构建拓扑：如下所示&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318212305494-1837092153.png&quot; alt=&quot;&quot; width=&quot;633&quot; height=&quot;359&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.对各个路由器进行配置使得网络ping通：命令如下&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      a)配置各路由器接口的IPv6地址，可由上图注释配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      b)配置各路由器的静态路由（此处举例R4）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;         (global)  ipv6 unicast-routing                   //启用IPv6单播路由功能&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318213230666-1338589998.png&quot; alt=&quot;&quot; width=&quot;257&quot; height=&quot;30&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          (interface)  ipv6  enable                          //端口下启用IPv6&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318213304871-539798601.png&quot; alt=&quot;&quot; width=&quot;260&quot; height=&quot;21&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          (global)  ipv6 route 2001:db8:88:b::10/64  fastethernet 0/0  2001:db8:88:a::1              //静态路由配置&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          #show ipv6 route                                       //查看路由表&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318213705334-261563623.png&quot; alt=&quot;&quot; width=&quot;462&quot; height=&quot;254&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 3.在R4上进行互相ping&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318213816588-671245987.png&quot; alt=&quot;&quot; width=&quot;473&quot; height=&quot;302&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.确认网络通之后，进行抓包分析&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在抓包后分析它的报文格式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318220756021-1092124284.jpg&quot; alt=&quot;&quot; width=&quot;426&quot; height=&quot;123&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318220932624-769181350.png&quot; alt=&quot;&quot; width=&quot;515&quot; height=&quot;92&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     它的消息报文格式为&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318221053377-1336297791.jpg&quot; alt=&quot;&quot; width=&quot;401&quot; height=&quot;322&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  i)  回送请求报文(echo request)&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      type=128  code=0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318214059805-157404257.png&quot; alt=&quot;&quot; width=&quot;622&quot; height=&quot;195&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;br/&gt;&lt;/strong&gt;节点的ICMPv6层收到一个echo request 报文后，可能会通知高层的进程。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;源节点生成了标识符和序列号字段的值，这些值可以帮助源节点将回送请求报文和返回的回送应答报文对应起来。数据字段中包含零个或多个任意内容的字节。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   ii) 回送应答请求(echo reply)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;          type=129  code=0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                       &lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318214911792-289502533.png&quot; alt=&quot;&quot; width=&quot;840&quot; height=&quot;283&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;源节点的ICMPv6层必须将回送应答报文通知那个产生了它所享有的原始echo request报文的高层进程，可能还需要通知其他高层的进程，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;但这些通知都是可选的，标识符和序列号字段的值是从echo request报文中获得。数据字段也是从回送请求报文中获得。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   iii) 路由器通告(RA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;              type=134  code=0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318215334249-866231449.png&quot; alt=&quot;&quot; width=&quot;761&quot; height=&quot;276&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;源地址为始发数据包接口的IPv6链路本地地址，目的地址为所有节点的多播地址（ff02::1）或发出请求的设备的链路本地地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      iiii)   邻居请求(NS)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;             type=135  code=0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318215809341-751220157.png&quot; alt=&quot;&quot; width=&quot;881&quot; height=&quot;263&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;源地址为始发该消息的接口IPv6地址或“：：”，目的地址为被请求节点的多播地址，或者就是目标地址。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   iiiii)  邻居通告(NA)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;           type=136  code=0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1616204/201903/1616204-20190318220144498-1488386653.png&quot; alt=&quot;&quot; width=&quot;924&quot; height=&quot;226&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;源地址为始发该消息的接口IPv6地址，目的地址为该消息所要答复的发出请求的源地址，或者是所有节点的多播地址（FF02::1)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;iiiiii)  路由器请求(RS)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      type=133  code=0&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       RS源地址为未指定的IPV6地址：：，若主机配置了单播地址，则此接口的单播地址可作为源地址。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       RS目的地址为所有路由器的多播地址FF02::2。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;       RS作用域为本地链路。       &lt;/span&gt;&lt;br/&gt;&lt;span&gt;       RS只发送三次以避免没有路由器时拥塞网络。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;5.总结&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   完成此次作业查阅了相关的资料，发现RS消息报文需要主机？不知道。总之我的type=133一直没有出现，所以就没有截图了。作业所要求的行距，似乎在这设置不了字体也没5号字所以我选择了常见的16px大小字体（网页字体默认大小）。一开始做的时候比较棘手，不会配置ipv6的静态路由，查了一些资料实验过了才懂。总的来说还行吧，熟悉巩固了基本的命令配置，也懂了新的命令配置，了解了ICMPv6报文的类型和格式，收获颇丰。如有错误请指出，谢谢，欢迎讨论。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 18 Mar 2019 14:32:00 +0000</pubDate>
<dc:creator>先喝汤后吃饭</dc:creator>
<og:description>1.首先我们来构建拓扑：如下所示 2.对各个路由器进行配置使得网络ping通：命令如下 a)配置各路由器接口的IPv6地址，可由上图注释配置 b)配置各路由器的静态路由（此处举例R4） (global</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lxxkim/p/10555663.html</dc:identifier>
</item>
<item>
<title>Java内存区域与内存溢出异常 - 技术小工</title>
<link>http://www.cnblogs.com/qianpangzi/p/10555612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianpangzi/p/10555612.html</guid>
<description>&lt;p&gt;Java的内存管理是一个老生常谈的问题，虽然Java号称可以自动管理自己的内存，使程序员从内存管理的围墙解放出来，但是一连串的内存泄漏和溢出方面的问题，使得我们不得不去深入了解Java的内存管理机制。本篇文章将从Java的内存区域开始剖析Jvm的内存机制，阐述内存溢出异常产生的原因。&lt;/p&gt;
&lt;h4 id=&quot;运行时数据区域&quot;&gt;运行时数据区域&lt;/h4&gt;
&lt;p&gt;众说周知，Java程序是运行在Java虚拟机中的，虚拟机顾名思义，就是一个虚拟的计算机。所以Java虚拟机也拥有一些与真实计算机相近的概念，比如栈，堆，程序计数器等，通常我们在这些概念面前加上虚拟机，以表明特指Java虚拟机的栈。&lt;/p&gt;
&lt;p&gt;Java程序运行时，Java虚拟机会对内存进行管理，划分为若干个不同的数据区域，每个数据区域都有其不同的功能。根据《Java虚拟机规范（Java SE 7版）》的规定，Java虚拟机所管理的区域会包括以下几个运行时区域，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.bdqfork.cn/markdown1182497-20170616192739978-1176032049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们一一介绍每个区域的不同功能。&lt;/p&gt;
&lt;h4 id=&quot;程序计数器&quot;&gt;程序计数器&lt;/h4&gt;
&lt;p&gt;程序计数器，即PC。学过计算机组成原理的同学一定对这个概念不陌生，在计算机组成原理中PC指的是PC寄存器，用来存放计算机执行的指令的所在内存区域的地址。而在Java虚拟机中，PC也有类似的作用，它的作用是存储当前线程所执行的字节码的行号指示器，通过改变这个计数器的值来选取下一条需要执行的字节码指令。与计算机PC不同的是，在Java虚拟机中，PC只是一块较小的内存空间，而不是寄存器。&lt;/p&gt;
&lt;p&gt;由于Java虚拟机是多线程的，为了在线程之间进行隔离，每一个线程都会拥有一个独立的程序计数器。因此，在进行线程调度的时候，每个线程的执行互不影响。我们称这类内存区域为“线程私有”的内存。&lt;/p&gt;
&lt;p&gt;程序计数器记录的只是正在执行的虚拟机字节码指令的地址，如果执行的是Native方法，那么计数器的值则为空。该内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。&lt;/p&gt;
&lt;h4 id=&quot;Java虚拟机栈&quot;&gt;Java虚拟机栈&lt;/h4&gt;
&lt;p&gt;Java虚拟机栈与系统栈也有些类似，都用来存储程序运行过程中创建的栈帧，不过Java虚拟机栈存储的是方法的栈帧而已，它与程序计数器一样，都是线程私有的。&lt;/p&gt;
&lt;p&gt;在Java方法执行时创建的栈帧是用来存储局部变量表、操作数栈、动态链接，方法出口等信息，我们平常所说的方法的入栈和出栈就是一个方法从执行到结束的过程。虚拟机栈的特性与一般的栈一样，同样是后进先出，递归调用的原理就是基于此。&lt;/p&gt;
&lt;p&gt;一般来说，对于Java虚拟机栈，我们主要关心的部分是它的局部变量表的存储。在我们定义一个变量的时候，变量到底被存放在哪里是我们经常遇到的问题。对于基本数据类型，如boolean、byte等以及对象的引用(reference类型，一个指向对象的指针或者是一个句柄，不是对象本身)和returnAddress类型（指向了一条字节码指令的地址）。&lt;/p&gt;
&lt;p&gt;局部变量表的大小是在编译期就已经完全确定下来的，在方法运行期间不会改变局部变量表的大小。同时，对于64位长度的long和double类型的数据会占用两个局部变量空间，其余的只占用一个。&lt;/p&gt;
&lt;p&gt;在Java虚拟机规范中，对这个区域规定了两种异常情况：StackOverflowError异常和OutOfMemoryError异常。&lt;/p&gt;
&lt;h4 id=&quot;本地方法栈&quot;&gt;本地方法栈&lt;/h4&gt;
&lt;p&gt;本地方法栈与虚拟机栈类似，唯一的区别是本地方法栈是用来执行Native方法的。&lt;/p&gt;
&lt;h4 id=&quot;Java堆&quot;&gt;Java堆&lt;/h4&gt;
&lt;p&gt;Java堆是我们在编写Java程序中所能使用的最大的一块的内存区域了，也是我们经常需要调整的区域。这个区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，包括数组（因为数组也是引用数据类型）。Java堆与虚拟机栈不同，它是被所有线程共享的区域，在虚拟机启动的时候创建。&lt;/p&gt;
&lt;p&gt;Java堆还可以进一步分为：新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等，这些更细致的分区是在Java堆垃圾收集器进行垃圾管理的时候需要考虑的。&lt;/p&gt;
&lt;p&gt;Java堆的大小可以是固定的，也可以是不固定的，可以通过-Xmx和-Xms控制，前者是最大值，后者是最小值，在两者相同时，堆的大小就是固定的。在内存中如果没有足够的空间来分配，将会抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;h4 id=&quot;方法区&quot;&gt;方法区&lt;/h4&gt;
&lt;p&gt;方法区和Java堆一样，是各个线程共享的内存区域，用来存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。&lt;/p&gt;
&lt;p&gt;这个区域也是属于需要进行垃圾回收的区域，主要是回收常量池和对类型的卸载，一般来说，回收的效果不会太理想，但是却是必须的。&lt;/p&gt;
&lt;p&gt;根据Java虚拟机的规范规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。&lt;/p&gt;
&lt;h4 id=&quot;运行时常量池&quot;&gt;运行时常量池&lt;/h4&gt;
&lt;p&gt;该区域是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，有时候直接引用也会放入，这部分内容将在类加载后进入方法区的运行时常量池中存放。&lt;/p&gt;
&lt;p&gt;运行时常量池有一定的动态性，对String类有所了解的同学应该明白，在运行期间通过String类的intern()方法可以动态往常量池里动态添加常量。&lt;/p&gt;
&lt;h4 id=&quot;直接内存&quot;&gt;直接内存&lt;/h4&gt;
&lt;p&gt;直接内存不属于Java虚拟机运行时数据区的一部分，而是属于操作系统管理的区域。这部分的使用很频繁，利用的好，可以大大提升程序的运行效率，比较优秀的使用例如基于NIO的Netty框架等。&lt;/p&gt;
&lt;p&gt;为什么使用直接内存可以提升性能呢，因为可以避免在Java堆和Native堆中来回复制数据的开销。&lt;/p&gt;
&lt;p&gt;这部分的内存使用不会收到Java堆大小的限制，但会收到本机的内存大小限制。因此，在操作这部分内存时需要谨慎，一旦出问题，可能会影响到本机的其它服务。 当各个内存区域总和大于物理内存限制，抛出OutOfMemoryError异常。&lt;/p&gt;
</description>
<pubDate>Mon, 18 Mar 2019 14:20:00 +0000</pubDate>
<dc:creator>技术小工</dc:creator>
<og:description>Java的内存管理是一个老生常谈的问题，虽然Java号称可以自动管理自己的内存，使程序员从内存管理的围墙解放出来，但是一连串的内存泄漏和溢出方面的问题，使得我们不得不去深入了解Java的内存管理机制。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianpangzi/p/10555612.html</dc:identifier>
</item>
</channel>
</rss>