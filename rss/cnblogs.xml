<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>正则表达式：后面不要包含指定的字符串内容 - xiangyuecn</title>
<link>http://www.cnblogs.com/xiangyuecn/p/10668378.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiangyuecn/p/10668378.html</guid>
<description>&lt;blockquote readability=&quot;16&quot;&gt;
&lt;p&gt;以前只会&lt;code&gt;/&amp;lt;abc(?!def).+&amp;gt;/.exec(&quot;&amp;lt;abcdef&amp;gt;\n&amp;lt;abczzz&amp;gt;&quot;)&lt;/code&gt;，匹配到&lt;code&gt;&amp;lt;abczzz&amp;gt;&lt;/code&gt;，这种简单的固定写法，但实际使用次数几乎趋近于0。&lt;/p&gt;
&lt;p&gt;很多场景不能写死&lt;code&gt;abc&lt;/code&gt;，顺理成章的就写成了&lt;code&gt;/&amp;lt;.+(?!def).+&amp;gt;/.exec(&quot;&amp;lt;abcdef&amp;gt;\n&amp;lt;abczzz&amp;gt;&quot;)&lt;/code&gt;，咦？咋把前面的匹配到了！从入门到放弃。&lt;/p&gt;
&lt;p&gt;昨天(2019-04-07)随手写了一下&lt;code&gt;/&amp;lt;(?:.(?!def))+&amp;gt;/.exec(&quot;&amp;lt;abcdef&amp;gt;\n&amp;lt;abczzz&amp;gt;&quot;)&lt;/code&gt;，原来是对&lt;code&gt;.+(?!排除的字符串)&lt;/code&gt;这个结构能起到的作用理解错了，怪不得达不到预期，&lt;code&gt;(.(?!排除的字符串))+&lt;/code&gt;才是正解。&lt;/p&gt;
&lt;p&gt;留下一个未解的问题，每个字符后面排除一下的能良好工作，一堆未定长度字符后排除一下怎么就不能工作，前瞻不会和前面的&lt;code&gt;+、*、{}&lt;/code&gt;起作用吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;正则表达式匹配指定内容后面要或不要包含指定的字符串内容：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;要：比较简单，写上这个要的即可&lt;/li&gt;
&lt;li&gt;不要：比要复杂很多，如何排除掉？&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;h2 id=&quot;前提原则&quot;&gt;前提原则&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;表达式内固定内容的字符串能不写尽量不写，能简写的尽量简化来写（如前面写的&lt;code&gt;abc&lt;/code&gt;部分不能写死）&lt;/li&gt;
&lt;li&gt;可以少量使用前瞻（正向），后瞻（反向）基本不学，学了还要研究那些浏览器支持，不敢用，太多了也学不动。&lt;/li&gt;
&lt;li&gt;NoJS(&lt;code&gt;Not Only JavaScript&lt;/code&gt;)；不仅仅是浏览器中的js；不过js的正则&lt;code&gt;/exp/&lt;/code&gt;字面量写法简洁到没盆友（哪个语言），函数、对象、字符串统统不需要；不接受反驳。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;假设待匹配的文本&quot;&gt;假设待匹配的文本&lt;/h2&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;htmlRaw=`
&amp;lt;div ***=&quot;***
    ***&quot; class=&quot;***&quot; ***=&quot;***&quot;&amp;gt;
    class=&quot; matchX 1&quot;
    &amp;lt;div ***=&quot;***
        ***&quot; class=&quot;*** matchX ***&quot; ***=&quot;*** excludeX ***&quot;&amp;gt;
        class=&quot; matchX 2&quot;
    &amp;lt;/div&amp;gt;
    class=&quot; matchX 3&quot;
&amp;lt;/div&amp;gt;

&amp;lt;div ***=&quot;***
    ***&quot; class=&quot;***&quot; ***=&quot;***&quot;&amp;gt;
    class=&quot; matchX 4&quot;
    &amp;lt;div ***=&quot;***
        ***&quot; class=&quot;*** ***&quot; ***=&quot;***&quot;&amp;gt;
        class=&quot; matchX 5&quot;
    &amp;lt;/div&amp;gt;
    class=&quot; matchX 6&quot;
&amp;lt;/div&amp;gt;

......
`;
//注: *** 不是固定内容，但不会出现未转义的xml实体、matchX、excludeX
//注: class=&quot; matchX 123456&quot;纯文本只做演示干扰之用，不应当作为特征

//如果数据对换行不敏感，应优先转换成没有换行的，大概率可以简化正则逻辑
htmlNoWrap=htmlRaw.replace(/[\r\n]+/g,&quot; &quot;);

//正则测试代码
(/[\s\S]*/.exec(htmlRaw)||[])[0]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;不要单个字符的匹配&quot;&gt;不要单个字符的匹配&lt;/h2&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;匹配出&lt;code&gt;div.matchX&lt;/code&gt;标签：&lt;code&gt;&amp;lt;div ***=&quot;*** ***&quot; class=&quot;*** matchX ***&quot; ***=&quot;***&quot;&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以直接使用 &lt;code&gt;[^&amp;gt;]&lt;/code&gt;把&lt;code&gt;matchX&lt;/code&gt;限定在&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; HTML标记内，意思就是&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;中的文本不要出现结尾的&lt;code&gt;&amp;gt;&lt;/code&gt;字符。&lt;/p&gt;
&lt;p&gt;单个字符还算简单：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//有效
/&amp;lt;div[^&amp;gt;]+matchX[^&amp;gt;]+&amp;gt;/.exec(htmlRaw)[0]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不限定在&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;标记内，可能会匹配出界；并且这种不限定，迟早会出乱子：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//无效
/&amp;lt;div.+?matchX.+?&amp;gt;/.exec(htmlNoWrap)[0]

/&amp;lt;div[\s\S]+?matchX[\s\S]+?&amp;gt;/.exec(htmlRaw)[0] //有换行符就是又长又难看&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;其他单个字符场景另行灵活运用。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;不要一个字符串的匹配&quot;&gt;不要一个字符串的匹配&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;匹配出第一层不带&lt;code&gt;excludeX&lt;/code&gt;文本内容的第一块&lt;code&gt;div&lt;/code&gt;，就是返回包含&lt;code&gt;matchX 4&lt;/code&gt;的那块&lt;code&gt;div&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;[^]&lt;/code&gt;语法只能排除掉单个字符，不要一个字符串咋办？硬是要写成&lt;code&gt;[^abc]&lt;/code&gt;，会把&lt;code&gt;a、b、c&lt;/code&gt;字符全部排除掉；除了使用前瞻，好像还没有别的简单办法。&lt;/p&gt;
&lt;p&gt;使用本文开头的&lt;code&gt;(.(?!排除的字符串))+&lt;/code&gt;结构就能达到目的，核心就在&lt;code&gt;(?:[^&amp;gt;](?!excludeX))*&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//有效
/&amp;lt;div[^&amp;gt;]*&amp;gt;[^&amp;lt;]+&amp;lt;div(?:[^&amp;gt;](?!excludeX))*&amp;gt;[^&amp;lt;]+&amp;lt;\/div&amp;gt;[^&amp;lt;]+&amp;lt;\/div&amp;gt;/.exec(htmlRaw)[0]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;要包含一个字符串的匹配，直接写需要的字符串即可，相对简单太多，就不写这种例子了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;未研究&lt;code&gt;(.(?!排除的字符串))+&lt;/code&gt;结构的性能。&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 23:49:00 +0000</pubDate>
<dc:creator>xiangyuecn</dc:creator>
<og:description>以前只会 ，匹配到``，这种简单的固定写法，但实际使用次数几乎趋近于0。 很多场景不能写死 ，顺理成章的就写成了 ，咦？咋把前面的匹配到了！从入门到放弃。 昨天(2019 04 07)随手写了一下 ，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiangyuecn/p/10668378.html</dc:identifier>
</item>
<item>
<title>cmd下的一些小技巧 - p0pl4r</title>
<link>http://www.cnblogs.com/p0pl4r/p/9856095.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/p0pl4r/p/9856095.html</guid>
<description>&lt;p&gt;切换盘符：[盘符]+:&lt;/p&gt;
&lt;p&gt;tips1：&lt;/p&gt;
&lt;p&gt;在盘符A执行一条命令后的同时切换到盘符B：A:\&amp;gt;dir &amp;amp;&amp;amp; B:（此处只能用&amp;amp;&amp;amp;或者&amp;amp;）&lt;/p&gt;
&lt;p&gt;tips2：&lt;/p&gt;
&lt;p&gt;在盘符A执行一条命令后，切换到盘符B，同时在B下执行命令：A:\&amp;gt;dir &amp;amp;&amp;amp; B: &amp;amp;&amp;amp;dir（第一处&amp;amp;&amp;amp;可换成&amp;amp;）&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 23:42:00 +0000</pubDate>
<dc:creator>p0pl4r</dc:creator>
<og:description>切换盘符：[盘符]+: tips1： 在盘符A执行一条命令后的同时切换到盘符B：A:\&gt;dir &amp;&amp; B:（此处只能用&amp;&amp;或者&amp;） tips2： 在盘符A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/p0pl4r/p/9856095.html</dc:identifier>
</item>
<item>
<title>【憩园】C#并发编程之异步编程(线程讨论) - 艾心❤</title>
<link>http://www.cnblogs.com/edison0621/p/10665819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edison0621/p/10665819.html</guid>
<description>&lt;p&gt;本篇是异步编程系列的第三篇，本来计划第三篇的内容是介绍异步编程中常用的几个方法，但是前两篇写出来后，身边的朋友总是会有其他问题，所以决定在续写一篇，作为&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/edison0621/p/10542953.html&quot;&gt;异步编程(一)&lt;/a&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/edison0621/p/10584279.html&quot;&gt;异步编程(二)&lt;/a&gt;&lt;/strong&gt;的补充。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;本篇内容主要讨论，在我们的异步代码里，运行的到底是哪个线程，在执行长时间运行操作时线程发生了什么。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在一个被async修饰了的异步方法里，如果没有遇到await，你的代码将一直在调用线程上。在UI应用程序里，比如ASP.NET或者WinForm程序里，你的代码会在ASP.NET工作线程或WinForm工作线程上运行。&lt;/p&gt;
&lt;p&gt;我们来看一下以下范例&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;11&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;public&lt;/span&gt; async Task GetResultAsync()
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   2:  &lt;/span&gt;{
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   3:  &lt;/span&gt;    Console.WriteLine();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   4:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   5:  &lt;/span&gt;    User user = &lt;span class=&quot;kwrd&quot;&gt;this&lt;/span&gt;.GetUserAsync();
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   6:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   7:  &lt;/span&gt;    &lt;span class=&quot;rem&quot;&gt;//call other code&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;   8:  &lt;/span&gt; 
&lt;/pre&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   9:  &lt;/span&gt;    &lt;span class=&quot;kwrd&quot;&gt;return&lt;/span&gt; Task.CompletedTask;
&lt;/pre&gt;
&lt;pre&gt;
&lt;span class=&quot;lnum&quot;&gt;  10:  &lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;以上范例里，我们在一个异步方法里调用了另一个异步方法，但是我们并没有使用await，这段代码依然在原始调用线程上执行，此时这个方法只是扮演了一个传播异步的作用。&lt;/p&gt;
&lt;p&gt;当我们在UI线程上如此编程的时候，代码在UI线程是执行，在没有执行结束之前，页面是没有响应的。所以如果页面长时间没有响应，未必是异步导致的，可能会有其他原因，需要综合考虑，可以借助性能分析器来查看影响系统的原因在哪里。&lt;/p&gt;

&lt;p&gt;代码到达await后，到底是哪一个线程在执行异步操作呢。&lt;/p&gt;
&lt;p&gt;我们以ASP.NET为例，对于网络请求之类的操作，此时没有线程在执行异步操作，他们都被阻塞了，正在等待操作完成。但是如果使用了Task.Run，那么执行该任务时就要用到线程池里的线程了。&lt;/p&gt;
&lt;p&gt;那么问题来了，我们在编写异步方法的时候，确确实实可以看到这个方法被执行了，肯定有线程执行才行啊。&lt;/p&gt;
&lt;p&gt;对的，确实需要线程来执行，这个线程我们把它称之为是IO完成端口线程。此线程等待网络请求完成，同时它在所有网络请求之间共享。当网络请求完成时，操作系统中的中断处理程序会以Job方式添加到IO完成端口的队列中。在请求发起后，响应返回前，它们需要依次由单个IO完成端口处理。&lt;/p&gt;
&lt;p&gt;实际上，一般情况下只有少量IO完成端口线程，以充分利用多个CPU核心。需要注意的是，无论当前有多少个请求，我们的线程数量都是固定的。 &lt;/p&gt;
&lt;p&gt;参考以下运行图&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/533598/201904/533598-20190407161836206-91394780.png&quot;&gt;&lt;img title=&quot;IO&quot; src=&quot;https://img2018.cnblogs.com/blog/533598/201904/533598-20190407161839998-311847990.png&quot; alt=&quot;IO&quot; width=&quot;638&quot; height=&quot;512&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;我在异步编程(一)这边文章里，有讲到SynchronizationContext这个类，它是.NET框架提供的类，可以在特定类型的线程中运行代码。&lt;/p&gt;
&lt;p&gt;.NET使用各种SynchronizationContext，常见的有ASP.NET、WinForms和WPF使用的UI线程上下文。SynchronizationContext的实例本身并没有特殊的地方，其实例指向的是其子类，具有静态成员，可以用于读取和控制当前的SynchronizationContext。&lt;/p&gt;
&lt;p&gt;当前SynchronizationContext是当前线程的属性。在一个特定线程所运行到的任意的地方，都能够获取当前的SynchronizationContext并存储它，并且可以使用SynchronizationContext，在所启动的这个特定线程上运行代码。综上所述，我们并不需要知道代码在哪个线程上启动，只需要使用到SynchronizationContext，我们就可以返回到启动线程。&lt;/p&gt;
&lt;p&gt;SynchronizationContext的重要方法是POST，它可以使委托在正确的上下文中运行。&lt;/p&gt;
&lt;p&gt;某些SynchronizationContext封装单个线程，如UI线程。有些线程封装了特定类型的线程，例如线程池，但可以选择将委托发送到其中的任何一个线程。有些不会更改代码运行在哪个线程上，而只用于监视，如ASP.NET SynchronizationContext。&lt;/p&gt;
&lt;p&gt;到这个地方，我们就需要了解一个问题了。在await之前，我们的代码是在调用线程上运行，那么await之后，恢复方法时到了哪个线程上了？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;实际上，&lt;strong&gt;大多数情况下&lt;/strong&gt;，await后的代码也由调用线程运行，尽管调用线程可能在等待期间做了其他事情。C#使用SynchronizationContext来完成此操作。当等待任务完成时，当前的同步上下文被存储为暂停方法的一部分。然后，当方法恢复时，await关键字的基础结构使用POST在捕获的同步上下文上恢复该方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然有大多数情况，那么肯定也有小众情况吧，以下情况可以在不同的线程上运行&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;ul&gt;&lt;li&gt;SynchronizationContext具有多个线程，如线程池&lt;/li&gt;
&lt;li&gt;SynchronizationContext不是真正切换线程的上下文&lt;/li&gt;
&lt;li&gt;到达等待时，没有当前的同步上下文，例如在控制台应用程序中。&lt;/li&gt;
&lt;li&gt;将任务配置为不使用同步上下文来恢复&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于UI应用程序来说，在同一线程上恢复是最重要的，我们等待之后安全的操作UI。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;以WinForm为例，我们设计一个按钮，用于下载我们喜欢的小图标。用户点击按钮之后，UI线程启动，并会执行响应的操作，以下图片展示了一个异步操作的流程，以及期间UI线程与IO线程是如何切换的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/533598/201904/533598-20190407161840592-150328980.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/533598/201904/533598-20190407161841291-1393682436.png&quot; alt=&quot;image&quot; width=&quot;707&quot; height=&quot;475&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;50&quot;&gt;
&lt;p&gt;1、用户单击该按钮，事件处理程序GetButton_OnClick开始排队等待运行。&lt;/p&gt;
&lt;p&gt;2、用户界面线程执行GetButton_OnClick的前半部分，包括对GetFaviconAsync的调用。&lt;/p&gt;
&lt;p&gt;3、UI线程继续进入GetFaviconAsync并执行其前半部分，包括对DownloadDataTaskAsync的调用。&lt;/p&gt;
&lt;p&gt;4、UI线程继续进入DownloadDataTaskAsync，它启动下载并返回任务。&lt;/p&gt;
&lt;p&gt;5、UI线程离开DownloadDataTaskAsync，并返回GgetFaviconAsync处的await。&lt;/p&gt;
&lt;p&gt;6、当前的UI线程捕获到了SynchronizationContext。&lt;/p&gt;
&lt;p&gt;7、GetFaviconAsyncy因为有await的标识，会等待，当DownloadDataTaskAsync完成后GetFaviconAsyncy便会使用捕获到的SynchronizationContext恢复。&lt;/p&gt;
&lt;p&gt;8、用户线程离开GetFaviconAsync，并返回一个任务，并运行到GetButton_OnClick中的await。&lt;/p&gt;
&lt;p&gt;9、类似地，GetButton_OnClick被等待暂停。&lt;/p&gt;
&lt;p&gt;10、用户线程离开GetButton_OnClick，可能会用于处理其他操作。【此时，我们正在等待图标下载。可能需要几秒钟。注意，UI线程可以自由处理其他用户操作，而IO完成端口线程尚未涉及到。操作期间阻塞的线程总数为零。】&lt;/p&gt;
&lt;p&gt;11、下载完成，因此IO完成端口在DownloadDataTaskAsync中对逻辑进行排队处理。&lt;/p&gt;
&lt;p&gt;12、IO完成端口线程将把DownloadDataTaskAsync返回的任务设置为完成。&lt;/p&gt;
&lt;p&gt;13、IO完成端口线程在任务内部运行代码并处理完成，并会调用捕获到的同步上下文（UI线程）上的POST以继续运行接下来的代码。&lt;/p&gt;
&lt;p&gt;14、IO完成端口线程被释放并可能在其他IO上工作。&lt;/p&gt;
&lt;p&gt;15、用户界面线程找到POST指令，并继续执行GetFaviconAsync的后半部分，直到结束。&lt;/p&gt;
&lt;p&gt;16、当UI线程离开GetFaviconAsync时，它会将GetFaviconAsync返回的任务设置为完成。&lt;/p&gt;
&lt;p&gt;17、在这个运行点里，当前的同步上下文与捕获的上下文相同，因而无需用到POST，UI线程也会继续同步进行。【此逻辑在WPF中是无效的，因为WPF经常创建新的SynchronizationContext对象。尽管它们是等效的，这使得TPL认为它需要重新POST。】&lt;/p&gt;
&lt;p&gt;18、用户线程继续运行GetButton_OnClick的后半部分，直到结束。 &lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;同步上下文的每个实现都是以不同的方式执行POST的，这是非常消耗性能的事情。为了避免这种开销，.NET内部也是有自己的优化机制的，它会在捕获的SynchronizationContext与任务完成时的当前上下文相同时，不使用POST。很有意思的是，如果你使用调试器查看这种情况，会发现调用堆栈是颠倒的。&lt;/p&gt;
&lt;p&gt;但是，当同步上下文不同时，这就需要用到系统开销了。在性能关键的代码中或者某个代码库中，如果我们并不不关心使用到了哪个线程，这个时候我们也可以通过自己的手动操作来避开这种开销。&lt;/p&gt;
&lt;p&gt;在等待任务之前调用ConfigureaWait来完成。这样就不会恢复到原始同步上下文。&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;9&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;&lt;span class=&quot;kwrd&quot;&gt;byte&lt;/span&gt;[] bytes = await httpClient.PostAsJsonAsync(url,data).ConfigureAwait(&lt;span class=&quot;kwrd&quot;&gt;false&lt;/span&gt;).ReadAsStreamAsync();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不过，ConfigureAwait并不是严格的指令，它是.NET设计的一个标识，用来告诉运行时我们不介意方法在哪个线程上运行。如果该线程不重要（线程池线程），它将会继续执行代码。如果是很重要的线程，.NET会通过自身机制将线程释放，让它来做其他事情，而方法也将在线程池中恢复。.NET使用线程的当前的SynchronizationContext来判断它是否重要。&lt;/p&gt;
&lt;p&gt;前文有说过，本文再提一次，在同步代码中运行异步代码，可能有隐藏的问题。Task有一个Result属性，该属性阻止等待任务完成。如以下代码：&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;var result = GetUserAsync().Result;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是如果在只有一个线程（如UI线程）的SynchronizationContext使用就会发生死锁现象。解决问题的方法就是，我们可以使用线程池线程来解决这个问题。如以下代码：&lt;/p&gt;
&lt;div class=&quot;csharpcode&quot; readability=&quot;7&quot;&gt;
&lt;pre class=&quot;alt&quot;&gt;
&lt;span class=&quot;lnum&quot;&gt;   1:  &lt;/span&gt;var result = Task.Run(() =&amp;gt;GetUserAsync()).Result;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Sun, 07 Apr 2019 23:37:00 +0000</pubDate>
<dc:creator>艾心❤</dc:creator>
<og:description>写在前面 本篇是异步编程系列的第三篇，本来计划第三篇的内容是介绍异步编程中常用的几个方法，但是前两篇写出来后，身边的朋友总是会有其他问题，所以决定在续写一篇，作为异步编程(一)和异步编程(二)的补充。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edison0621/p/10665819.html</dc:identifier>
</item>
<item>
<title>[Java初探07]__关于面向对象的简单认识 - 小舍先生</title>
<link>http://www.cnblogs.com/gemuxiaoshe/p/10668315.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gemuxiaoshe/p/10668315.html</guid>
<description>&lt;ul&gt;&lt;li&gt;前言&lt;br/&gt;类和对象,在我们学习Java语言的过程中,它们无时无刻不存在着,在我们还远未详细弄明白它们的意义之前,在我们不知不觉的下意识里,我们都会直接或间接的用到它们,这是因为Java是一门面向对象的语言,在学习类与对象的前提下,我们应当先对面向对象有所了解.&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;我们都知道,Java语言是一门面向对象的语言,实际上类与对象,就是面向对象编程思想的重要基础.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;面向对象编程思想概述&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;面向对象的开发思想可以说是人类最自然的一种思考方式,它将所有预处理的问题抽象成为对象,同时了解这些对象的相应属性以及展示这些对象的行为,以解决这些对象面临的一些实际问题,面向对象设计的实质就是对现实社会中的对象进行建模操作.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对象&lt;/strong&gt;&lt;br/&gt;对象是什么,按表面意思理解,对象就是表示我们眼中的某件事物.它可以是现实世界的任何一件事物,也可以是一个抽象的,我们自己脑海中构造的.&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;对象就是某个事物存在的实体,就例如人类,书桌,高楼大厦等,人类解决问题的方式总是不断将复杂的事物简化,于是就会思索这些对象由哪些组成,通常会将对象划分为静态部分和动态部分.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;静态部分,即对象不变的部分,称之为属性.任何对象都具有其自身属性.&lt;/li&gt;
&lt;li&gt;动态部分,即对象可能存在的行为,动作.如一个人会哭泣,微笑,行走奔跑等.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;人们通过研究对象的属性和行为来了解对象.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;而面向对象抽象设计的思想,就是以对象来思考问题的,首先将现实世界中的实体抽象为对象.然后考虑这个对象具备的属性和行为.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们通过一个大雁南飞的问题来看看:&lt;/p&gt;
&lt;p&gt;首先我们将大雁抽象为一个对象,接着观察分析对象,大雁因该具有的属性和行为:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-a4b40327d36c14c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-7-05.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们分析完成后,这个对象的定义就完成了,然后就可以根据这个对象来解决大雁南飞的问题.&lt;/p&gt;
&lt;p&gt;我们还可以发现,在现实生活中,很多大雁都具有这样的特性,而大雁又不只一只, 所以我们就将这些属性和行为封装起来,就组成了类,对象就是类抽象出来的一个实例.这其中的原理和图书馆图书的分类类似,具有某些特征的书归为一类存放,而这类里的书都可以说是这个类别的一个实例.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;类&lt;/strong&gt;&lt;br/&gt;类,其实就如同我们日常生活中的类别一样,指的是具有某一类相同特性的一类事物,描述的是一个群体,类不能用来单指某个事物,所以也不能当作某一事物来使用.&lt;br/&gt;类是构造对象时所依赖的规范(因为对象都是基于类创建的).对象就是符合某个类的定义所产生出来的实例.&lt;br/&gt;类是封装对象的属性和行为的载体.也可以说具有相同属性和行为的一类实体被称为类.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-3dc8981b35a2d6c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-7-06.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Java语言中,类中对象的行为是通过方法的形式定义的,对象的属性是以成员变量定义的.&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-c247975cce739c2b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-7-07.png&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;继承性&lt;br/&gt;类和类之间同样有着联系这种联系有很多种,其中比较典型的关系之一就是继承,就像是图书分类一样,有着层层分级的关系,其中小类同样拥有其父类的属性和方法,这就是继承关系.继承性主要用到特定对象之间共有属性.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8067684-504a90ee1cc8158b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;2019-4-7-08.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;前面我们了解了继承,知道了父类与子类的关系,多态就是将父类对象应用与子类的特征.多态的实现不依赖于具体的类,而是依赖于接口可抽象类的.在多态的机制中,比抽象类更方便的方式是将抽象类定义为接口.由抽象方法的集合就是接口.接口的概念在现实生活中也是十分常见的.&lt;/p&gt;
&lt;p&gt;关于类,对象,及三大特性,接口,抽象类,抽象方法等概念会在后面单独出一篇文章专门学习,这里主要是为了简单了解下面向对象的编程思想.&lt;br/&gt;***&lt;br/&gt;更新时间:&lt;br/&gt;2019-4-8&lt;br/&gt;1:09&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 17:36:00 +0000</pubDate>
<dc:creator>小舍先生</dc:creator>
<og:description>前言 类和对象,在我们学习Java语言的过程中,它们无时无刻不存在着,在我们还远未详细弄明白它们的意义之前,在我们不知不觉的下意识里,我们都会直接或间接的用到它们,这是因为Java是一门面向对象的语言</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gemuxiaoshe/p/10668315.html</dc:identifier>
</item>
<item>
<title>Oracle 12.2报错ORA-15032、ORA-15410或ORA-15411解决 - AlfredZhao</title>
<link>http://www.cnblogs.com/jyzhao/p/10668227.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jyzhao/p/10668227.html</guid>
<description>&lt;p&gt;&lt;strong&gt;现象：&lt;/strong&gt;在Oracle 12.2.0.1 RAC环境，在其ASM实例中，如果添加不同大小或者不同数量的LUN到failgroup中，会报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ORA-15032: not all alterations performed
ORA-15410: Disks in disk group OCRVT do not have equal size.
或者
ORA-15032: not all alterations performed
ORA-15411: Failure groups in disk group OCRVT have different number of disks.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;br/&gt;动态修改这两个隐藏参数可以解决：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;alter system set &quot;_asm_disable_failgroup_size_checking&quot;=true;
alter system set &quot;_asm_disable_dangerous_failgroup_checking&quot;=true;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;下面举一个实际的例子：&lt;/strong&gt;&lt;br/&gt;比如新加的LUN：mpathi，mpathj，mpathk都是200M大小，以前的ASM磁盘组OCRVT由3个LUN：mpatha，mpathb，mpathc都是1G大小组成；现在想把新的LUN加到OCRVT磁盘组中：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt;  select name, failgroup, path, mode_status, voting_file from v$asm_disk;

NAME                                FAILGROUP                      PATH                                          MODE_ST V
----------------------------------- ------------------------------ --------------------------------------------- ------- -
                                                                   /dev/mapper/mpathj                            ONLINE  N
                                                                   /dev/mapper/mpathi                            ONLINE  N
                                                                   /public/nfsdisk                               ONLINE  N
                                                                   /dev/mapper/mpathk                            ONLINE  N
DATA_0001                           DATA_0001                      /dev/mapper/mpathf                            ONLINE  N
FRA_0000                            FRA_0000                       /dev/mapper/mpathh                            ONLINE  N
DATA_0002                           DATA_0002                      /dev/mapper/mpathg                            ONLINE  N
DATA_0000                           DATA_0000                      /dev/mapper/mpathe                            ONLINE  N
MGMT_0000                           MGMT_0000                      /dev/mapper/mpathd                            ONLINE  N
OCRVT_0000                          OCRVT_0000                     /dev/mapper/mpathc                            ONLINE  Y
OCRVT_0002                          OCRVT_0002                     /dev/mapper/mpathb                            ONLINE  Y
OCRVT_0001                          OCRVT_0001                     /dev/mapper/mpatha                            ONLINE  Y

12 rows selected.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接尝试添加新的LUN到ASM磁盘组OCRVT中，会报错。依次尝试设置相关的隐藏参数，可以成功添加：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; alter diskgroup ocrvt add FAILGROUP OCRVT_0000 disk '/dev/mapper/mpathi';   
alter diskgroup ocrvt add FAILGROUP OCRVT_0000 disk '/dev/mapper/mpathi'
*
ERROR at line 1:
ORA-15032: not all alterations performed
ORA-15410: Disks in disk group OCRVT do not have equal size.

SQL&amp;gt; alter system set &quot;_asm_disable_dangerous_failgroup_checking&quot;=true;

System altered.

SQL&amp;gt; alter diskgroup ocrvt add FAILGROUP OCRVT_0000 disk '/dev/mapper/mpathi';
alter diskgroup ocrvt add FAILGROUP OCRVT_0000 disk '/dev/mapper/mpathi'
*
ERROR at line 1:
ORA-15032: not all alterations performed
ORA-15411: Failure groups in disk group OCRVT have different number of disks.

SQL&amp;gt; alter system set &quot;_asm_disable_failgroup_size_checking&quot;=true;

System altered.

SQL&amp;gt;  alter diskgroup ocrvt add FAILGROUP OCRVT_0000 disk '/dev/mapper/mpathi';

Diskgroup altered.&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;总结：&lt;/strong&gt;&lt;br/&gt;asm中与failgroup相关的隐藏参数:&lt;br/&gt;_asm_disable_dangerous_failgroup_checking FALSE&lt;br/&gt;_asm_disable_failgroup_count_checking FALSE&lt;br/&gt;_asm_disable_failgroup_size_checking FALSE&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SQL&amp;gt; r
  1  SELECT   i.ksppinm name,
  2     i.ksppdesc description,
  3     CV.ksppstvl VALUE
  4  FROM   sys.x$ksppi i, sys.x$ksppcv CV
  5     WHERE   i.inst_id = USERENV ('Instance')
  6     AND CV.inst_id = USERENV ('Instance')
  7     AND i.indx = CV.indx
  8     AND i.ksppinm LIKE '%&amp;amp;param%'
  9* ORDER BY   REPLACE (i.ksppinm, '_', '')
Enter value for param: failgroup
old   8:    AND i.ksppinm LIKE '%&amp;amp;param%'
new   8:    AND i.ksppinm LIKE '%failgroup%'

NAME                                DESCRIPTION                                                        VALUE
----------------------------------- ------------------------------------------------------------------ ------------------------------
_asm_disable_dangerous_failgroup_ch Disable checking for dubious failgroup configurations              FALSE
ecking

_asm_disable_failgroup_count_checki Disable checking for failure group count                           FALSE
ng

_asm_disable_failgroup_size_checkin Disable checking for failure group size                            FALSE
g

--这类参数实测可以动态修改：
alter system set &quot;_asm_disable_failgroup_size_checking&quot;=true;
alter system set &quot;_asm_disable_dangerous_failgroup_checking&quot;=true;
--alter system set &quot;_asm_disable_failgroup_count_checking&quot;=true; 这个参数我没有测出来实际作用，实测只需要上面两个参数设置为true就同样可以允许failgroup的数量不一致。

SQL&amp;gt; show parameter _asm

NAME                                 TYPE        VALUE
------------------------------------ ----------- ------------------------------
_asm_disable_dangerous_failgroup_che boolean     TRUE
cking
_asm_disable_failgroup_size_checking boolean     TRUE


--test
SQL&amp;gt; select name, failgroup, path, mode_status, voting_file from v$asm_disk;

NAME                                FAILGROUP                      PATH                                          MODE_ST V
----------------------------------- ------------------------------ --------------------------------------------- ------- -
                                                                   /public/nfsdisk                               ONLINE  N
OCRVT_0005                          OCRVT_0002                     /dev/mapper/mpathk                            ONLINE  N
OCRVT_0004                          OCRVT_0001                     /dev/mapper/mpathj                            ONLINE  N
DATA_0001                           DATA_0001                      /dev/mapper/mpathf                            ONLINE  N
OCRVT_0003                          OCRVT_0000                     /dev/mapper/mpathi                            ONLINE  N
FRA_0000                            FRA_0000                       /dev/mapper/mpathh                            ONLINE  N
DATA_0002                           DATA_0002                      /dev/mapper/mpathg                            ONLINE  N
DATA_0000                           DATA_0000                      /dev/mapper/mpathe                            ONLINE  N
MGMT_0000                           MGMT_0000                      /dev/mapper/mpathd                            ONLINE  N
OCRVT_0000                          OCRVT_0000                     /dev/mapper/mpathc                            ONLINE  Y
OCRVT_0002                          OCRVT_0002                     /dev/mapper/mpathb                            ONLINE  Y
OCRVT_0001                          OCRVT_0001                     /dev/mapper/mpatha                            ONLINE  Y

12 rows selected.

--以下操作均可以成功:
alter diskgroup ocrvt drop disk OCRVT_0003;
alter diskgroup ocrvt add FAILGROUP OCRVT_0000 disk '/dev/mapper/mpathi';   
       
--如果不改参数，那么只能同时删除/增加每个failgroup中的成员:
alter diskgroup ocrvt drop disk OCRVT_0003, OCRVT_0004, OCRVT_0005;
alter diskgroup ocrvt add FAILGROUP OCRVT_0000 disk '/dev/mapper/mpathi'  
FAILGROUP OCRVT_0001 disk '/dev/mapper/mpathj'  
FAILGROUP OCRVT_0002 disk '/dev/mapper/mpathk';

--最后同样可以动态还原配置：
alter system set &quot;_asm_disable_failgroup_size_checking&quot;=false;
alter system set &quot;_asm_disable_dangerous_failgroup_checking&quot;=false;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;实验发现如果使用asmca添加磁盘，无论是否设置这个参数，都会报错[DBT-30003] The size of the disks selected is not the same as to allow for an equal number of 4MB AU size blocks.&lt;br/&gt;而使用命令行操作，只要设置这2个隐藏参数为true即可成功。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 16:27:00 +0000</pubDate>
<dc:creator>AlfredZhao</dc:creator>
<og:description>现象： 在Oracle 12.2.0.1 RAC环境，在其ASM实例中，如果添加不同大小或者不同数量的LUN到failgroup中，会报错： 解决方案： 动态修改这两个隐藏参数可以解决： 下面举一个实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jyzhao/p/10668227.html</dc:identifier>
</item>
<item>
<title>为什么我们要做单元测试？(二) - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/10667988.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/10667988.html</guid>
<description>&lt;p&gt; &lt;span&gt;&lt;strong&gt;引子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;当我第一篇博客原题叫做&amp;lt;为什么.NET开发者都不写单元测试&amp;gt;,我的本意是想跟.NET技术圈的朋友们一起交流,为什么过去在.NET开发中很少用到单元测试,之后，在公众号文章和博客园的留言中，许多开发者纷纷表示，单元测试作为企业行为，与实施的技术栈不同，不是开发者个人行为，实施单元测试花费的时间精力过于庞大，与实际效果严重不对等，而且如果过度的采用单元测试，也会增加新的测试点，因为单元测试代码本身就需要进行测试等。&lt;/p&gt;
&lt;p&gt;从这些回复可以看出，程序员要不要编写单元测试这种话题，大概做传统开发时，问程序员要不要写项目文档一样充满争议。正如大家都深刻明白项目文档的重要性，但是一旦程序员需要编写项目文档了，往往会对这个事情产生抵触情绪，这实际上是绝大多数开发者的通病。&lt;/p&gt;
&lt;p&gt;单元测试也是这样的矛盾纠结体。在长沙.net技术社区就有不少朋友纷纷表示，他们都曾经试图在公司推动单元测试的应用，但是受到了自上而下的反对声，最终迫于压力，只能放弃。 而之所以阻力这么大，其主要原因是编写单元测试会增加额外的时间，因为编写单元测试，不仅仅只是编写一个简单的测试入口，而是一系列步骤，但是领导要求在最短的时间看到效果，并且有的领导还经常改变主意，如果设计了一个优秀的单元测试用例，有时候甚至会因为无法适应需求的变化，而最终腐烂。 &lt;/p&gt;
&lt;p&gt;显然，使用单元测试和更高的单元测试的代码覆盖率，大概是一个试金石。过去在长沙还很少有企业会问开发者会不会使用单元测试，但是近年来越来越多的企业会问候选人代码覆盖率的问题，所以作为开发者，可以尝试从单元测试开始,努力提高自己的代码习惯，编写更加高质量的代码。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;有哪些公司在要求编写单元测试？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;过去，单元测试一直是专业软件公司的首选，有一位原诺基亚核心部门的开发者说为诺基亚内部，对单元测试的要求很高，虽然没有达到百分之百，但也有非常高的要求，在《构建之法》中，邹欣老师介绍了微软的开发实践，也对单元测试覆盖率提出了很高的要求。 当然有的读者或许会嗤之以鼻，这些都是古典软件公司，举这些例子有什么意义呢？中国式IT 公司，哪家都是996，哪里还有什么时间实行单元测试？ &lt;/p&gt;
&lt;p&gt;然而，优秀的互联网公司都开始推行devops 作为企业信息化建设过程中的最佳实践标准，持续集成和持续发布都对单元测试有很高的要求，例如在阿里巴巴java 开发者手册中，就明确提出了以下一系列指标，要求开发者务必采用单元测试方法，尽可能的提高代码质量。&lt;/p&gt;
&lt;ol class=&quot;list-paddingleft-2&quot; readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;【强制】好的单元测试必须遵守 AIR 原则。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;...此处省略七百字&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;【推荐】单元测试的基本目标：语句覆盖率达到 70% ；核心模块的语句覆盖率和分支覆盖率都要达到 100% &lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;参见原文阿里巴巴Java 开发者手册，由此可见，单元测试已经作为一种行之有效的手段，显然已经成为了中国优秀互联网企业的必然之选。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;单元测试中的代码覆盖率有什么用？&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码覆盖率是单元测试的重要衡量指标，反映了单元测试中测试用例对被测代码的覆盖程度，是对代码的测试质量衡量的重要指标。&lt;/p&gt;
&lt;p&gt;在十年前，博客园《代码覆盖率浅谈》(参考资料1）一文，深入浅出的介绍了单元测试的四种类型， 包括语句覆盖，判定覆盖，条件覆盖，路径覆盖四种类型，作者指出，单元测试覆盖率结果，有以下作用：&lt;/p&gt;
&lt;p&gt;a. 覆盖率数据只能代表你测试过哪些代码，不能代表你是否测试好这些代码。 &lt;/p&gt;
&lt;p&gt;b. 不要过于相信覆盖率数据。&lt;/p&gt;
&lt;p&gt;c. 不要只拿语句覆盖率(行覆盖率)来考核你的测试人员。 &lt;/p&gt;
&lt;p&gt;d. 路径覆盖率 &amp;gt; 判定覆盖 &amp;gt; 语句覆盖 &lt;/p&gt;
&lt;p&gt;e. 测试人员不能盲目追求代码覆盖率，而应该想办法设计更多更好的案例，哪怕多设计出来的案例对覆盖率一点影响也没有。 &lt;/p&gt;
&lt;p&gt;在软件开发过程中盲目的追求的高代码覆盖率，往往得不偿失，尤其是为了提高代码覆盖率而做的单元测试，往往只会成为累赘。&lt;/p&gt;
&lt;p&gt;合理的操作形式应该是基于实际用例出发，设定更多的用例场景，实现基于用户场景驱动的单元测试覆盖，像在阿里巴巴开发者手册中说的，测试人员与开发人员配合，共同完成测试用例覆盖，就是一种不错的应用实践。&lt;/p&gt;
&lt;p&gt;当然，即便测试缺位，开发者也完全应该主动的承担更多单元测试的职能，尽可能多的思考用户场景中可能存在的变数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编写好的单元测试的一些小技巧&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　技巧一，多看书肯定是不错的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有朋友问，怎么写好单元测试？有什么书推荐么？我很惭愧，我自己的代码单元测试的覆盖率还相当低，可能没办法给出指导，我想多看书肯定是没错的，而编写单元测试的书，还挺多的，例如这一本，《单元测试的艺术》，一看就是基于C#的，可以试一试。  &lt;/p&gt;
&lt;p&gt; 而想入单元测试的门，可以看看我后面找到的一系列引文，相信能给你带来方便。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　技巧二，运用测试框架&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;1、单元测试框架：XUnit、NUnit、MSTest等.&lt;/p&gt;
&lt;p&gt;2、测试运行工具：xunit.runner.visualstudio 。类似如：Resharper的xUnit runner插件。 &lt;/p&gt;
&lt;p&gt;3、模拟框架：Moq、RhinoMocks、NSubstitute、FakeItEasy等。   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　技巧三，灵活的运用事务回滚或内存数据库，避免单元测试数据污染正常数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前者是阿里巴巴开发者手册中提到的一种方法，在有的场景下也挺实用的，不过有开发者指出，可以使用模拟内存数据库来解决这个问题更为妥当，例如使用Effort.EF6，通过nuget获取，使得创建一个伪造的、供EF容易使用的内存数据库成为可能。与这类似的，还可以使用HttpSimulator来模拟http 请求。  &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　技巧四，使用依赖注入和单例模式改良不可测代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态类为代码编写带来了许多便利，但是也使得代码测试变得相对困难，而使用单例模式进行改良则使得操作更可控。 &lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;人生苦短，撸码不易。从选择成为开发者的那一天起，我们就被迫承受了许多压力，尤其是技术发展的不确定性，更是如此，你永远也不知道自己当下的选择是否正确，说不定你今天最为熟悉的技术或框架，明天就凉凉了。尤其是现在的各种自媒体，时不时的发几篇文章来输出焦虑，巴不得天天说优胜劣汰才能获得读者的关注一般，让开发者们压力更大。 &lt;/p&gt;
&lt;p&gt;我觉得，技术是解决问题的方法，而良好的代码习惯则是自身心法，尤其是单元测试，更是一种好习惯，先别总想着担心自己被淘汰，努力的使自己习惯更好，总会获得无穷收获。&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;参考资料1:《&lt;a href=&quot;https://www.cnblogs.com/coderzh/archive/2009/03/29/1424344.html?tt_from=copy_link&amp;amp;utm_source=copy_link&amp;amp;utm_medium=toutiao_ios&amp;amp;utm_campaign=client_share&quot; target=&quot;_blank&quot;&gt;代码覆盖率浅谈&lt;/a&gt;》.&lt;/p&gt;
&lt;p&gt;参考资料2：《&lt;a href=&quot;https://www.infoq.cn/article/test-coverage-ocd&quot; target=&quot;_blank&quot;&gt;代码覆盖率强迫症&lt;/a&gt;》.&lt;br/&gt;参考资料3: 《&lt;a href=&quot;https://www.cnblogs.com/jacksundatashare/p/5083352.html.&quot; target=&quot;_blank&quot;&gt;代码覆盖率 (Code Coverage)从简到繁&lt;/a&gt;》&lt;/p&gt;
&lt;p&gt;参考资料4，《&lt;a href=&quot;http://www.cnblogs.com/zhaopei/p/UnitTesting.html?from=singlemessage&amp;amp;isappinstalled=0&quot; target=&quot;_blank&quot;&gt;C#单元测试，带你快速入门&lt;/a&gt;》.&lt;/p&gt;
&lt;p&gt;【版权声明】 &lt;/p&gt;
&lt;p&gt;本博客版权归作者和博客园共有，作品来自于长沙.NET技术社区成员【邹溪源】，有兴趣了解长沙.NET技术社区详情，请关注公众号【DotNET技术圈】,作品采用知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 15:12:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>引子 当我第一篇博客原题叫做&lt;为什么.NET开发者都不写单元测试&gt;,我的本意是想跟.NET技术圈的朋友们一起交流,为什么过去在.NET开发中很少用到单元测试,之后，在公众号文章和博客园的留</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiyuanMore/p/10667988.html</dc:identifier>
</item>
<item>
<title>你不知道的JavaScript --- 作用域相关 - Shapeying</title>
<link>http://www.cnblogs.com/shapeY/p/10667985.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shapeY/p/10667985.html</guid>
<description>&lt;p&gt;本篇是《你不知道的JavaScript》的读书笔记&lt;/p&gt;
&lt;h2 id=&quot;什么是作用域&quot;&gt;什么是作用域？&lt;/h2&gt;
&lt;p&gt;程序离不变量，那么变量存储在哪里？程序需要时如何找到他们？&lt;/p&gt;
&lt;p&gt;这些问题说明需要一套设计良好的&lt;strong&gt;规则&lt;/strong&gt;来存储变量， 并且之后可以方便地找到这些变量。这套规则被称为&lt;strong&gt;作用域&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;作用域负责收集并维护由所有声明的标识符（变量） 组成的一系列查询， 并实施一套非常严格的规则， 确定当前执行的代码对这些标识符的访问权限。&lt;/p&gt;
&lt;h2 id=&quot;作用域嵌套&quot;&gt;作用域嵌套&lt;/h2&gt;
&lt;p&gt;当一个块或函数嵌套在另一个块或函数中时， 就发生了作用域的嵌套。 因此， 在当前作用域中无法找到某个变量时， 引擎就会在外层嵌套的作用域中继续查找， 直到找到该变量，或抵达最外层的作用域（也就是全局作用域） 为止。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    function foo(a) { 
        console.log( a + b ); // foo的作用域中没有变量b，去外层找
    }
    var b = 2;
    foo( 2 ); // 4&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;词法作用域&quot;&gt;词法作用域&lt;/h2&gt;
&lt;p&gt;刚学的时候就知道JavaScript是&lt;strong&gt;词法作用域&lt;/strong&gt;，那么究竟是什么意思？&lt;/p&gt;
&lt;p&gt;JavaScript的源代码在执行之前会在编译器中经历词法分析、语法分析、代码生成等环节。&lt;/p&gt;
&lt;p&gt;词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义。&lt;strong&gt;词法作用域是由你在写代码时将变量和块作用域写在哪里决定的&lt;/strong&gt;，因此当词法分析器处理代码时会保持作用域不变。&lt;/p&gt;
&lt;p&gt;词法作用域意味着作用域是由书写代码时函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1072774/201904/1072774-20190407230717971-858552154.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;作用域气泡由其对应的作用域块代码写在哪里决定， 它们是逐级包含的。&lt;/p&gt;
&lt;h2 id=&quot;欺骗词法&quot;&gt;欺骗词法&lt;/h2&gt;
&lt;p&gt;正常情况下，词法作用域完全由写代码期间函数所声明的位置来定义。但是JavaScript也有两种机制可以在运行的时候来“修改”（也可以说欺骗）词法作用域。&lt;code&gt;eval()&lt;/code&gt;和&lt;code&gt;with&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;JavaScript 引擎会在编译阶段进行数项的&lt;strong&gt;性能优化&lt;/strong&gt;。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎&lt;strong&gt;在代码中发现了 eval(..) 或 with&lt;/strong&gt;，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。那么所有的优化可能都是无意义的，因此最简单的做法就是&lt;strong&gt;完全不做任何优化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果代码中大量使用 eval(..) 或 with ，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，&lt;strong&gt;代码会运行得更慢&lt;/strong&gt;这个事实。&lt;/p&gt;
&lt;h2 id=&quot;提升&quot;&gt;提升&lt;/h2&gt;
&lt;p&gt;先看个小栗子&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    console.log(a)
    var a = 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直觉上认为，&lt;code&gt;JavaScript&lt;/code&gt;是从上而下一行一行执行的，应该会报错&lt;code&gt;ReferenceError&lt;/code&gt;. 但实际上这里会输出&lt;code&gt;undefined&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。&lt;strong&gt;包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以上述栗子可以理解为&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    var a;
    console.log(a); // undefined
    a = 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;定义在编译阶段进行，赋值留在原地等待执行阶段&lt;/strong&gt;，这个过程就叫做&lt;strong&gt;提升&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;函数声明会被提升，但是函数表达式不会被提升&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    foo1(); // 'foo1'
    foo2(); // TypeError : foo2 is not a function  此处的foo2未被赋值，为undefined

    function foo1(){
        console.log('foo1');
    }
    var foo2 = function (){
        console.log('foo2');
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;函数会首先被提升，然后才是变量&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    foo(); //foo1  而不是TypeError 说明函数声明先被提升，然后才是变量提升，但是同名，所以变量的声明被忽略了

    var foo = function (){
        console.log('foo2');
    }

    function foo(){
        console.log('foo1');
    }

    foo(); //foo2 执行赋值之后，foo函数输出foo2&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;闭包&quot;&gt;闭包&lt;/h2&gt;
&lt;p&gt;闭包是基于&lt;strong&gt;词法作用域&lt;/strong&gt;写代码时所产生的自然结果，闭包的创建和使用在代码中随处可见，我们需要的是根据自己的意愿来识别，拥抱和影响闭包的思维环境。&lt;/p&gt;
&lt;p&gt;当函数可以记住并访问所在的词法作用域时，就产生了&lt;strong&gt;闭包&lt;/strong&gt;，即使函数是在当前作用域之外执行。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function foo() {
    var a = 2;
    
    function bar() {
        console.log(a);
    }

    return bar;
}

var baz = foo();

baz() // 2  --- 闭包效果&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数&lt;code&gt;baz&lt;/code&gt;（实际上就是&lt;code&gt;bar&lt;/code&gt;的引用）可以访问到&lt;code&gt;foo&lt;/code&gt;内部作用域，虽然是在&lt;code&gt;foo&lt;/code&gt;作用域外部执行的。而正是由于&lt;code&gt;bar&lt;/code&gt;的存在，所以foo函数执行后，内部作用域没有被销毁，&lt;code&gt;bar&lt;/code&gt;会使用这个内部作用域。&lt;/p&gt;
&lt;p&gt;bar依然持有对该作用域的引用，这个引用就叫做&lt;strong&gt;闭包&lt;/strong&gt;。闭包使得函数可以继续访问定义时词法作用域。无论使用何种方式对函数类型的值进行传递，&lt;strong&gt;当函数在别处别调用时都可以观察到闭包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;闭包的一个经典问题&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    for(var i = 1; i &amp;lt;= 5 ; i++) {
        setTimeout(function timer() {
            console.log(i);
        },i * 1000);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里会每间隔一秒，打印一个&lt;code&gt;6&lt;/code&gt;。每次循环都会创建一个&lt;code&gt;timer&lt;/code&gt;函数传递个&lt;code&gt;setTimeout&lt;/code&gt;。timer中使用的变量i都是上层作用域中定义的变量i（闭包），当循环执行完之后，i的值为6，所以会连续打印5个6.&lt;/p&gt;
&lt;p&gt;如果想依次打印1到5。有以下处理方式。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在定时器外创建一层作用域，使每次循环产生的timer使用的i都不一样。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    for(var i = 1; i &amp;lt;= 5 ; i++) {
        (function(j){
                    setTimeout(function timer() {
            console.log(j);
        },j * 1000);
        })(i)
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;使用块级作用域 - let&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;    for(let i = 1; i &amp;lt;= 5 ; i++) {
        setTimeout(function timer() {
            console.log(i);
        },i * 1000);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;块级作用域会使每次创建定时器的作用域都不一样。而且语言特性会使循环时记住上一次i的值。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 15:08:00 +0000</pubDate>
<dc:creator>Shapeying</dc:creator>
<og:description>本篇是《你不知道的JavaScript》的读书笔记 什么是作用域？ 程序离不变量，那么变量存储在哪里？程序需要时如何找到他们？ 这些问题说明需要一套设计良好的 规则 来存储变量， 并且之后可以方便地找</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shapeY/p/10667985.html</dc:identifier>
</item>
<item>
<title>性能测试必知必会 - 大卡尔</title>
<link>http://www.cnblogs.com/jinsdu/p/10646278.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jinsdu/p/10646278.html</guid>
<description>&lt;h2 id=&quot;说到性能测试我们到底是想谈论什么&quot;&gt;说到性能测试，我们到底是想谈论什么？&lt;/h2&gt;
&lt;p&gt;任何做产品的，都希望自己家的产品，品质优，性能好，服务海量用户，还不出问题。&lt;/p&gt;
&lt;p&gt;任何使用产品的，都喜欢自己购买的产品功能全，性能优，不花一分冤枉钱。&lt;/p&gt;
&lt;p&gt;不过理想很丰满，现实很骨感。实际产品的性能与开发周期，部署方式，软硬件性能等都息息相关。所以真正提到做性能测试的场景，多数是为满足特定需求而进行的度量或调优。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;针对交付客户的软硬件环境，提供性能测试报告，证明对客户需求的满足&lt;/li&gt;
&lt;li&gt;针对特定的性能瓶颈，进行针对性测试，为问题定位提供帮助&lt;/li&gt;
&lt;li&gt;重大功能迭代，架构设计上线前的性能评估&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所有的这些场景，都隐含着对性能测试目标的确认，这一点非常重要。因为如果没有明确的测试目标，为了做而做，多数情况是没有价值的，浪费精力。&lt;/p&gt;
&lt;p&gt;而性能测试的目标一般是期望支持的目标用户数量，负载，QPS等等，这些信息一般可以从业务负责人或者产品经理处获得。当然如果有实际的业务数据支持，也可以据此分析得出。&lt;strong&gt;所以在开展性能测试之前，一定要先搞清楚测试目标&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;目标明确之后如何开展性能测试&quot;&gt;目标明确之后，如何开展性能测试？&lt;/h2&gt;
&lt;p&gt;有了性能测试目标，之后还需要进一步拆解，做到具体可执行。根据经验，个人认为性能测试的执行，最终会落地到以下两个场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在特定硬件条件，特定部署架构下，测试系统的最大性能表现&lt;/li&gt;
&lt;li&gt;在相同场景，相同硬件配置下，与竞品比较，与过往分析，总结出优劣&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不同的目的，做事的方式也不一样。&lt;/p&gt;
&lt;p&gt;第一类场景，因为结果的不确定性，测试时需要不断的探索测试矩阵，找出尽可能优的结果。&lt;/p&gt;
&lt;p&gt;第二类场景，首先需要理清楚，业界同类产品，到底比的是什么，相应的测试工具是什么，测试方法是什么。总之要在公平公正的条件下，遵循业界标准，得出测试结果，给出结论。&lt;/p&gt;
&lt;p&gt;所有的性能测试场景，都需要有明确的分析与结论，以支持上述两个场景下的目的达成。测试场景要贴近实际的目标场景，测试数据要贴近实际的业务数据，最好就用目标业务场景下的数据来进行性能测试。&lt;/p&gt;
&lt;h2 id=&quot;服务端性能测试到底要看哪些指标&quot;&gt;服务端性能测试到底要看哪些指标?&lt;/h2&gt;
&lt;p&gt;不同的领域，业务形态，可能关注的性能指标是不一样的，所以为了表述精确，我们这里只谈服务端的性能测试指标。&lt;/p&gt;
&lt;p&gt;一般我们会用以下指标来衡量被测业务: QPS, 响应时间(Latency), 成功率，吞吐率，以及服务端的资源利用率(CPU/Memory/IOPS/句柄等)。&lt;/p&gt;
&lt;p&gt;不过，这里有一些常识需要明确:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;响应时间不要用平均值，要用百分值。比如常见的，98值(98th percentile)表示。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;成功率是性能数据采集标准的前提，在成功率不足的情况下，其他的性能数据是没意义的(当然这时候可以基于失败请求来分析性能瓶颈)。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;单独说QPS不够精确，而应结合响应时间综合来看。比如 &quot;在响应时间TP98都小于100ms情况下，系统可以达到10000qps&quot; 这才有意义。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能测试一定要持续一定时间，在确保被测业务稳定的情况下，测出的数据才有意义。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要多体会下这些常识，实战中很多新手对这块理解不深，导致有时出的性能数据基本是无效的。&lt;/p&gt;
&lt;h2 id=&quot;为什么性能测试报告一定要给出明确的软硬件配置以及部署方式&quot;&gt;为什么性能测试报告一定要给出明确的软硬件配置，以及部署方式？&lt;/h2&gt;
&lt;p&gt;前面说到，性能数据是与软件版本，硬件配置，部署方式等息息相关的。每一项指标的不同，得出的数据可能是天差万别。所以在做性能测试时，一定要明确这些基础前置条件，且在后期的性能测试报告中，清晰的说明。&lt;/p&gt;
&lt;h2 id=&quot;jmeter-ab-wrk-lotust-k6-这么多性能测试工具我应该选择哪个&quot;&gt;jmeter, ab, wrk, lotust, k6 这么多性能测试工具，我应该选择哪个？&lt;/h2&gt;
&lt;p&gt;业界性能测试数据工具非常多，不过适用的场景，以及各自特点会有不同。所以针对不同的性能测试需求，应当选择合适的性能工具。比如:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;jmeter: 主要提供图形化操作以及录制功能，入门简单，功能也较强大。缺点是需要额外安装。&lt;/li&gt;
&lt;li&gt;ab(apech benchmark): 简单好用，且一般系统内置了，应对简单场景已足够&lt;/li&gt;
&lt;li&gt;lotust：简单好用，支持python编写自定义脚本，支持多worker，图形化界面汇总性能数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里不一一介绍工具，大家有兴趣的都可以自行去网上搜索。&lt;/p&gt;
&lt;p&gt;其实笔者在实践过程中发现，其实绝大多数性能测试场景，都需要编码实现。所以如何优雅的结合现有的测试代码，环境，以及基础设施，来方便的进行性能测试反而是个可以考量的点。&lt;/p&gt;
&lt;p&gt;笔者比较认可Go+Prometheus+Kubernetes的模式。首先go语言因其独有的并发模式，上手简单等特点，在云服务，服务端程序领域使用已经非常广了，采用其写脚本，也许与被测程序天然紧密结合。且服务端程序要想很好的运维，必然有一套完整的监控告警体系，而Prometheus基本是其中热度最高的，使用范围最广的，同时我们也可以将测试程序性能数据打点到Prometheus，这样在计算QPS，成功率等指标上，非常方便。&lt;/p&gt;
&lt;p&gt;另外大家知道，在性能测试时，多数需要不断的调整metrix，比如并发数，worker数量等，来探测系统的性能表现，这时候如果将测试程序跑在Kubernetes上，就可以借助其能力，比如Deployment，灵活的部署和水平扩展，体验相当优雅。&lt;/p&gt;
&lt;h2 id=&quot;单机10000并发为什么可能不靠谱&quot;&gt;单机10000并发为什么可能不靠谱？&lt;/h2&gt;
&lt;p&gt;我们知道使用goroutine，可以瞬间开很多并发，非常好用。于是可能就会有同学觉得用它做性能测试很方便，直接写个脚本，起超多的并发，去做性能测试。但这样真的靠谱吗？&lt;/p&gt;
&lt;p&gt;虽然go语言的并发，通过P，G，M模型，在调度goroutine时，比较高效，但无论如何，任何的程序执行，最终消耗的都是系统资源，测试脚本也同样。所以单机上执行的并发效果，最终会受限于，你脚本的复杂程序，也就是对CPU,IO，网络等系统资源的消耗。所以，并不是并发越多越好，一定是基于实际环境，通过不断调节并发数量，worker数量等，来达到最佳姿势。&lt;/p&gt;
&lt;h2 id=&quot;构建业务性能数据的持续可观测性对产品质量意义重大&quot;&gt;构建业务性能数据的持续可观测性对产品质量意义重大&lt;/h2&gt;
&lt;p&gt;一次专项性的性能分析，可以观察当前业务的性能表现，进一步的分析性能瓶颈，为之后的改进提供帮助，意义挺大。但只这样可能不够全面，因为指不定的某次迭代，句柄没关，goutinue泄露，就会造成性能问题，如果我们没有常态化的检测手段，等上线后才发现，很明显不是我们想看到的。&lt;/p&gt;
&lt;p&gt;所以更优雅的做法是，将性能测试常态化的持续运营，甚至可以做到每次PR触发，都自动执行性能测试，检测性能问题。&lt;/p&gt;
&lt;h2 id=&quot;to-be-continued&quot;&gt;To-Be-Continued&lt;/h2&gt;
&lt;p&gt;性能测试对保障产品质量，提升用户体验意义重大。笔者这里只罗列了一些个人在实际工作中看的问题，以及一些体会，可能不全面。所以如果您有问题，欢迎抛出来，共同探讨。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;https://coolshell.cn/articles/17381.html&lt;/li&gt;
&lt;li&gt;https://www.dynatrace.com/news/blog/why-averages-suck-and-percentiles-are-great/&lt;/li&gt;
&lt;li&gt;https://automationrhapsody.com/how-to-do-proper-performance-testing/&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Email: jinsdu@outlook.com&lt;/p&gt;
&lt;p&gt;Blog: &lt;a href=&quot;http://www.cnblogs.com/jinsdu/&quot; class=&quot;uri&quot;&gt;http://www.cnblogs.com/jinsdu/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Github: &lt;a href=&quot;https://github.com/CarlJi&quot; class=&quot;uri&quot;&gt;https://github.com/CarlJi&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 14:55:00 +0000</pubDate>
<dc:creator>大卡尔</dc:creator>
<og:description>说到性能测试，我们到底是想谈论什么？ 任何做产品的，都希望自己家的产品，品质优，性能好，服务海量用户，还不出问题。 任何使用产品的，都喜欢自己购买的产品功能全，性能优，不花一分冤枉钱。 不过理想很丰满</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/jinsdu/p/10646278.html</dc:identifier>
</item>
<item>
<title>Effective Java 第三版——89. 对于实例控制，枚举类型优于READRESOLVE - 林本托</title>
<link>http://www.cnblogs.com/IcanFixIt/p/10667837.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IcanFixIt/p/10667837.html</guid>
<description>&lt;blockquote readability=&quot;5.0845771144279&quot;&gt;
&lt;p&gt;Tips&lt;br/&gt;书中的源代码地址：&lt;a href=&quot;https://github.com/jbloch/effective-java-3e-source-code&quot; class=&quot;uri&quot;&gt;https://github.com/jbloch/effective-java-3e-source-code&lt;/a&gt;&lt;br/&gt;注意，书中的有些代码里方法是基于Java 9 API中的，所以JDK 最好下载 JDK 9以上的版本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/4366140-8966e457a14bc8b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Effective Java, Third Edition&quot;/&gt;&lt;/p&gt;

&lt;p&gt;条目 3描述了单例（Singleton）模式，并给出了以下示例的单例类。 此类限制对其构造方法的访问，以确保只创建一个实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() {  ... }

    public void leaveTheBuilding() { ... }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如条目 3所述，如果将&lt;code&gt;implements Serializable&lt;/code&gt;添加到类的声明中，则此类将不再是单例。 类是否使用默认的序列化形式或自定义序列化形式（条目 87）并不重要，该类是否提供显式的readObject方法（条目 88项）也无关紧要。 任何readObject方法，无论是显式方法还是默认方法，都会返回一个新创建的实例，该实例与在类初始化时创建的实例不同。&lt;/p&gt;
&lt;p&gt;readResolve特性允许你用另一个实例替换readObject方法 [Serialization, 3.7]创建的实例。如果正在反序列化的对象的类，使用正确的声明定义了readResolve方法，则在新创建的对象反序列化之后，将在该对象上调用该方法。该方法返回的对象引用，代替新创建的对象返回。在该特性的大多数使用中，不保留对新创建对象的引用，因此它立即就有资格进行垃圾收集。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Elvis&lt;/code&gt;类用于实现Serializable，则以下read-Resolve方法足以保证单例性质：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// readResolve for instance control - you can do better!
private Object readResolve() {
    // Return the one true Elvis and let the garbage collector
    // take care of the Elvis impersonator.
    return INSTANCE;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此方法忽略反序列化对象，返回初始化类时创建的区分的&lt;code&gt;Elvis&lt;/code&gt;实例。因此，&lt;code&gt;Elvis&lt;/code&gt;实例的序列化形式不需要包含任何实际数据；所有实例属性都应该声明为transient。事实上，&lt;strong&gt;如果依赖readResolve方法进行实例控制，那么所有具有对象引用类型的实例属性都必须声明为transient&lt;/strong&gt;。否则，有决心的攻击者有可能在运行readResolve方法之前，保护对反序列化对象的引用，使用的技术有点类似于条目 88中的&lt;code&gt;MutablePeriod&lt;/code&gt;类攻击。&lt;/p&gt;
&lt;p&gt;这种攻击有点复杂，但其基本思想很简单。如果单例包含一个非瞬时状态对象引用属性，则在运行单例的readResolve方法之前，将对该属性的内容进行反序列化。这允许一个精心设计的流在对象引用属性的内容被反序列化时，“窃取”对原来反序列化的单例对象的引用。&lt;/p&gt;
&lt;p&gt;下面是它的工作原理。首先，编写一个&lt;code&gt;stealer&lt;/code&gt;类，该类具有readResolve方法和一个实例属性，该实例属性引用序列化的单例，其中&lt;code&gt;stealer&lt;/code&gt;“隐藏”在其中。在序列化流中，用一个&lt;code&gt;stealer&lt;/code&gt;实例替换单例的非瞬时状态属性。现在有了一个循环：单例包含了&lt;code&gt;stealer&lt;/code&gt;，而&lt;code&gt;stealer&lt;/code&gt;又引用了单例。&lt;/p&gt;
&lt;p&gt;因为单例包含&lt;code&gt;stealer&lt;/code&gt;，所以当反序列化单例时，&lt;code&gt;stealer&lt;/code&gt;的readResolve方法首先运行。因此，当&lt;code&gt;stealer&lt;/code&gt;的readResolve方法运行时，它的实例属性仍然引用部分反序列化(且尚未解析)的单例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;stealer&lt;/code&gt;的readResolve方法将引用从其实例属性复制到静态属性，以便在readResolve方法运行后访问引用。然后，该方法为其隐藏的属性返回正确类型的值。如果不这样做，当序列化系统试图将&lt;code&gt;stealer&lt;/code&gt;引用存储到该属性时，虚拟机会抛出ClassCastException异常。&lt;/p&gt;
&lt;p&gt;要使其具体化，请考虑以下有问题的单例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Broken singleton - has nontransient object reference field!
public class Elvis implements Serializable {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() { }

    private String[] favoriteSongs =
        { &quot;Hound Dog&quot;, &quot;Heartbreak Hotel&quot; };
    public void printFavorites() {
        System.out.println(Arrays.toString(favoriteSongs));
    }

    private Object readResolve() {
        return INSTANCE;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是一个“stealer”类，按照上面的描述构造：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ElvisStealer implements Serializable {
    static Elvis impersonator;
    private Elvis payload;

    private Object readResolve() {
        // Save a reference to the &quot;unresolved&quot; Elvis instance
        impersonator = payload;

        // Return object of correct type for favoriteSongs field
        return new String[] { &quot;A Fool Such as I&quot; };
    }
    private static final long serialVersionUID = 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，这是一个丑陋的程序，它反序列化了一个手工制作的流，生成有缺陷单例的两个不同实例。这个程序省略了反序列化方法，因为它与条目88（第354页）的方法相同:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ElvisImpersonator {

  // Byte stream couldn't have come from a real Elvis instance!

  private static final byte[] serializedForm = {
    (byte)0xac, (byte)0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x05,
    0x45, 0x6c, 0x76, 0x69, 0x73, (byte)0x84, (byte)0xe6,
    (byte)0x93, 0x33, (byte)0xc3, (byte)0xf4, (byte)0x8b,
    0x32, 0x02, 0x00, 0x01, 0x4c, 0x00, 0x0d, 0x66, 0x61, 0x76,
    0x6f, 0x72, 0x69, 0x74, 0x65, 0x53, 0x6f, 0x6e, 0x67, 0x73,
    0x74, 0x00, 0x12, 0x4c, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c,
    0x61, 0x6e, 0x67, 0x2f, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74,
    0x3b, 0x78, 0x70, 0x73, 0x72, 0x00, 0x0c, 0x45, 0x6c, 0x76,
    0x69, 0x73, 0x53, 0x74, 0x65, 0x61, 0x6c, 0x65, 0x72, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01,
    0x4c, 0x00, 0x07, 0x70, 0x61, 0x79, 0x6c, 0x6f, 0x61, 0x64,
    0x74, 0x00, 0x07, 0x4c, 0x45, 0x6c, 0x76, 0x69, 0x73, 0x3b,
    0x78, 0x70, 0x71, 0x00, 0x7e, 0x00, 0x02
  };

  public static void main(String[] args) {
    // Initializes ElvisStealer.impersonator and returns
    // the real Elvis (which is Elvis.INSTANCE)
    Elvis elvis = (Elvis) deserialize(serializedForm);
    Elvis impersonator = ElvisStealer.impersonator;

    elvis.printFavorites();
    impersonator.printFavorites();
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行此程序将生成以下输出，最终证明可以创建两个不同的Elvis实例(两种具有不同的音乐品味):&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[Hound Dog, Heartbreak Hotel]
[A Fool Such as I]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过声明&lt;code&gt;favoriteSongs&lt;/code&gt;属性为transient来解决问题，但最好通过把Elvis成为单个元素枚举类型来修复它（条目 3）。 正如&lt;code&gt;ElvisStealer&lt;/code&gt;类攻击所证明的那样，使用readResolve方法来防止攻击者访问“临时”反序列化实例是非常脆弱的，需要非常小心。&lt;/p&gt;
&lt;p&gt;如果将可序列化的实例控制类编写为枚举，Java会保证除了声明的常量之外，不会再有有任何实例，除非攻击者滥用&lt;code&gt;AccessibleObject.setAccessible&lt;/code&gt;等特权方法。 任何能够做到这一点的攻击者已经拥有足够的权限来执行任意本机代码，并且所有的赌注都已关闭。 以下是下面是&lt;code&gt;Elvis&lt;/code&gt;作为枚举的例子:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// Enum singleton - the preferred approach
public enum Elvis {
    INSTANCE;

    private String[] favoriteSongs =
        { &quot;Hound Dog&quot;, &quot;Heartbreak Hotel&quot; };
    public void printFavorites() {
        System.out.println(Arrays.toString(favoriteSongs));
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用readResolve进行实例控制并不是过时的。 如果必须编写一个可序列化的实例控制类，实例在编译时是未知的，那么无法将该类表示为枚举类型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;readResolve的可访问性非常重要&lt;/strong&gt;。 如果在final类上放置readResolve方法，它应该是私有的。 如果将readResolve方法放在非final类上，则必须仔细考虑其可访问性。 如果它是私有的，则不适用于任何子类。 如果它是包级私有的，它将仅适用于同一包中的子类。 如果它是受保护的或公共的，它将适用于所有不重写它的子类。 如果readResolve方法是受保护或公共访问，并且子类不重写它，则反序列化子类实例将生成一个父类实例，这可能会导致ClassCastException异常。&lt;/p&gt;
&lt;p&gt;总而言之，使用枚举类型尽可能强制实例控制不变性。 如果这是不可能的，并且还需要一个类可序列化和实例控制，则必须提供readResolve方法并确保所有类的实例属性都是基本类型，或瞬时状态。&lt;/p&gt;
</description>
<pubDate>Sun, 07 Apr 2019 14:40:00 +0000</pubDate>
<dc:creator>林本托</dc:creator>
<og:description>Tips 书中的源代码地址：https://github.com/jbloch/effective java 3e source code 注意，书中的有些代码里方法是基于Java 9 API中的，所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/IcanFixIt/p/10667837.html</dc:identifier>
</item>
<item>
<title>总结JAVA----IO流中的字节流 - *三井寿*</title>
<link>http://www.cnblogs.com/roseneverdie/p/10650952.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/roseneverdie/p/10650952.html</guid>
<description>&lt;p&gt;                                                &lt;span&gt;  &lt;span&gt;对于IO流中字节流的总结&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字节流&lt;span&gt;的概念&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于应用程序,经常需要和文件打交道,所以Inputstream专门提供了读写文件的子类:FileInputStream和FileOutputStream类,如果程序对于文件的操作较为简单,就比如说只是顺序的读写文件,那么就可以使用字节流进行操作.并且我们都知道,所有文件的最底层数据类型都是字节,所以说,字节流的应用范围是十分广的,当然,它也有相应的缺点,只能处理简单的数据文本,一旦数据多了,其处理速度慢的弊端也就显现了出来.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;子父类关系&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;通过超级父类InputStream延伸出的很多派系,并且一些派系完美的解决了,字节流速度慢的问题(字节缓冲流)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1534253/201904/1534253-20190404211408144-1608807935.png&quot; alt=&quot;&quot; width=&quot;694&quot; height=&quot;444&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编码方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;查阅了挺久资料的,发现在编码方式这块,由于我还没有接触计算机原理这门课,所以对于这块的概念十分的模糊,从昨天到今天也查阅了许多资料,但还是无法很系统的整理出一些真正有用的东西,所以对于编码方式这里,我会在以后认真的总结一番。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其与字符流的不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字节流传输的最基本单位是字节&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符流传输的最基本单位是字符&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;编码方式不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符流在传输方面上，由于计算机的传输本质都是字节，而一个字符由多个字节组成，转成字节之前先要去查表转成字节，所以传输时有时候会使用缓冲区。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字节流传输时不会用到缓冲区,是通过直接访问IO设备的方式来完成传输。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字节流适用于图片,文本,视频等等格式的数据.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字符流适用于文本,并且最好是中文文本,处理速度超快.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字节流的输入\输出流&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构造方法(1)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534253/201904/1534253-20190404190533440-1240607262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构造方法(2)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534253/201904/1534253-20190404191315553-599236692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构造方法(3)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534253/201904/1534253-20190404192034228-1520384757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这三种构造方法都要求在对象创建之前便给出文件名。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于一个文件进行的输入输出操作的代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Scanner;
&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * 该类用于做一个文件字节流的例子
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo1 {
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
        File file&lt;/span&gt;=&lt;span&gt;function();
        choice(file);
    }
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; File function() &lt;span&gt;throws&lt;/span&gt; IOException{     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法用于创建一个文件对象&lt;/span&gt;
         File file=&lt;span&gt;new&lt;/span&gt; File(&quot;C:\\Users\\Lenovo\\Desktop\\Demo.txt&quot;&lt;span&gt;);   
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建一个文件对象&lt;/span&gt;
         &lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;file.exists()) {
             file.createNewFile();      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;若文件不存在则创建一个文本文件&lt;/span&gt;
&lt;span&gt;         }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; file;
     }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; choice(File file) &lt;span&gt;throws&lt;/span&gt; IOException{    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该类用于进行选择输入方式(是覆盖还是从文件末尾写)&lt;/span&gt;
          &lt;span&gt;int&lt;/span&gt; a = 0&lt;span&gt;;
          System.out.println(&lt;/span&gt;&quot;a==&quot;&lt;span&gt;);
          Scanner sc&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
          a&lt;/span&gt;=&lt;span&gt;sc.nextInt();
          &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt;(a) {
          &lt;/span&gt;&lt;span&gt;case&lt;/span&gt; 1:function1(file);function3(file);&lt;span&gt;break&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是覆盖式写入&lt;/span&gt;
          &lt;span&gt;case&lt;/span&gt; 2:function2(file);function3(file);&lt;span&gt;break&lt;/span&gt;;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是从文件末尾写入&lt;/span&gt;
          &lt;span&gt;default&lt;/span&gt;:System.out.println(&quot;无该索引&quot;&lt;span&gt;);
          }
          sc.close();
      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;  &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; function1(File file) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
          FileOutputStream  fos&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  FileOutputStream(file);
          System.out.println(&lt;/span&gt;&quot;请输入您想要写入的信息&quot;&lt;span&gt;);
          Scanner sc&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
          String s&lt;/span&gt;=&lt;span&gt;sc.nextLine();
          &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b=s.getBytes();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将字符串转换为字节数组&lt;/span&gt;
&lt;span&gt;          fos.write(b);
          fos.close();
          sc.close();
      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; function2(File file) &lt;span&gt;throws&lt;/span&gt; IOException{  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法是从末尾开始写&lt;/span&gt;
          FileOutputStream  fos=&lt;span&gt;new&lt;/span&gt;  FileOutputStream(file,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
          System.out.println(&lt;/span&gt;&quot;请输入您想要写入的信息&quot;&lt;span&gt;);
          Scanner sc&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Scanner(System.in);
          String s&lt;/span&gt;=&lt;span&gt;sc.nextLine();
          &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b=&lt;span&gt;s.getBytes();      
          fos.write(b);
          fos.close();
          sc.close();
      }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; function3(File file) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
          FileInputStream fis&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt;  FileInputStream(file);
          &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) file.length()];
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;运用File类关于文件属性的方法,但是返回值是long型数据,需要强转。&lt;/span&gt;
&lt;span&gt;          fis.read(b);
          System.out.println(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(b));
          fis.close();
      }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第一次键入a=1,输入&quot;啊哈哈&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二次键入a=1,输入&quot;嘿嘿嘿”   会发现文件中只剩下&quot;嘿嘿嘿” &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第三次键入a=1,输入&quot;啊哈哈&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二次键入a=2,输入&quot;嘿嘿嘿”   会发现文件中是&quot;啊哈哈嘿嘿嘿” &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字节缓冲流&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BufferedInputStream&amp;amp;BufferedOutputStream&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这两种类为IO提供了带缓冲区的操作,一般打开文件进行写入或读取操作时,都会加上缓冲,这样提高了IO的性能。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于IO的抽象理解&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果我们要将一缸水转到另一缸水中&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;FileOutputStream&amp;amp;FileInputStream相当于把水一滴一滴的转移&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DataOutputStream&amp;amp;DateaInputStream相当于把水一瓢一瓢的转移&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;BufferedOutputStream&amp;amp;BufferdeInputStream相当于先把水全部放入一缸水中,然后在将这一缸水倒入目标缸中。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以说带缓冲区的字节缓冲流是很好使的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们用字节缓冲流代码实现一下文件的复制&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
 * 用字节缓冲流完成对于文件的复制
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Dmeo2 {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
          &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b=&lt;span&gt;function();
          function1(b);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[] function() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        InputStream is&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; FileInputStream(&quot;C:\\Users\\Lenovo\\Desktop\\Demo.txt&quot;&lt;span&gt;);
        BufferedInputStream bis&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; BufferedInputStream(is);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;构造方法参数为InputStream类型&lt;/span&gt;
        &lt;span&gt;byte&lt;/span&gt;[] b=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&quot;C:\\Users\\Lenovo\\Desktop\\Demo.txt&quot;&lt;span&gt;.length()];
        bis.read(b);          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将信息转换为字节数组&lt;/span&gt;
&lt;span&gt;        bis.close();       
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; b;                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;将字节数组返回&lt;/span&gt;
&lt;span&gt;    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; function1(&lt;span&gt;byte&lt;/span&gt;[] b) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException {
        OutputStream os&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; FileOutputStream(&quot;C:\\Users\\Lenovo\\Desktop\\Demo1.txt&quot;&lt;span&gt;);
        BufferedOutputStream bos&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BufferedOutputStream(os);
        bos.write(b);
        bos.flush();         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;此处一定要记得刷新缓冲区,这样信息才能流入文件&lt;/span&gt;
        bos.close();      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;若是我们手动关闭的话,系统会帮我们自动刷新缓冲区&lt;/span&gt;
        &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;所以说fluse()方法与close()方法写一个就行,但这只是理论上的
         * 但是为了程序的可读性还是都写好一点
         &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这里的Demo文件是我们上个代码也就是字节流中所创建的文件。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;字节数组流&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  &lt;span&gt;  字节数组流在功能方面属于字节流,属于直接作用于目标设备的一种流类.经常而言我们都是针对文件的操作，然后带上缓冲的节点流进行处理，但有时候为了提升效率，我们发现频繁的读写文件并不是太好，那么于是出现了字节数组流，即存放在内存中，因此又称之为内存流.(这里是直接copy别人的).其实也就是将我们的目标放在了缓冲区之上,而不再是文件了.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ByteOtputArrayStream(字节数组输出流)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构造方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534253/201904/1534253-20190407200734182-738865521.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第一个是有初始长度但可以增加,第二个是自己设置长度&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里我感觉我们不可以将其理解为数组,总感觉它和集合真的好像,因为他的属性单位也是以size()方法来查看的,并且他和集合一样长度是可变的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;特殊方法：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534253/201904/1534253-20190407201347741-1983198866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这个无效close最先真的搞得我一头雾水,后来才反应过来这里我们操作的对象是缓冲区,缓冲区是无法关闭的,或者说关闭了会出很大的问题,所以这里他应该是无效的,并且作为子类,我们从父类中所拿到的方法并不全是有用的,毕竟子类与父类是不同的两个单独存在的个体。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534253/201904/1534253-20190407201836874-1912311496.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;关于缓冲区属性的一个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534253/201904/1534253-20190407202011041-905355670.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534253/201904/1534253-20190407202018436-308448100.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这两个方法都是write方法,这里的处理方式其实和父类中的write方法基本一致吧，只是目标有所变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ByteInputArrayStream\字节输入流&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构造方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534253/201904/1534253-20190407203414950-593802052.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这里最关键的是buf的选择,作为输入流我们若是想从缓冲区得到数据的话,buf应该是输入流.toByteArray()方法得到的数组,在我看来输入流就代表着那一块我们正存放数据的缓冲区,这样转换成数组合情合理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;完成一个简单读写操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo3 {
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
       function();
}
     &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; function() &lt;span&gt;throws&lt;/span&gt; IOException{   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法用于输出流的存入&lt;/span&gt;
         ByteArrayOutputStream  bos=&lt;span&gt;new&lt;/span&gt; ByteArrayOutputStream();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用默认构造方法&lt;/span&gt;
         String s=&quot;我是哈哈哈&quot;&lt;span&gt;;
         &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b=&lt;span&gt;s.getBytes();
         bos.write(b); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里不要像上文给出的write(byte[] b,int off,int len)因为这样的话我们还要
         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算一下字节个数,很麻烦,还容易出错,当然也有其它方法知道准确字节数但是代码量会多&lt;/span&gt;
&lt;span&gt;         function1(bos.size(),bos);
     }
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; function1(&lt;span&gt;int&lt;/span&gt; a,ByteArrayOutputStream bos) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
          ByteArrayInputStream bis&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteArrayInputStream(bos.toByteArray());
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如上文所说,以输出流所转化成的数组为参数创建一个对象&lt;/span&gt;
          &lt;span&gt;byte&lt;/span&gt;[] b=&lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[a];
          bis.read(b);   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把字节存到b数组中&lt;/span&gt;
          System.out.println(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; String(b));
      }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;字节数据流&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DataInputStream和DataOutputStream类创建的对象称为数据输入流和数据输出流.这两个流是很有用的流,他们允许程序按着及其无关的的风格读取JAVA原始数据.也就是说,当读取一个数值时,不必再关心这个数值应该是多少个字节(而且有些数据类型long,double数据类型真的很难转成字节),它们属于处理流,即程序通过一个间接流类去调用节点流类，以达到更加灵活方便地读写各种类型的数据，这个间接流类就是处理流&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;构造方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534253/201904/1534253-20190407210848456-1000147350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534253/201904/1534253-20190407210852937-84896252.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也就是说他们的参数是节点流。并且这里我们可以很好的利用多态的概念,FileInputStream。。。。等等都可以作为参数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读写方法writexxx,readxxx。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码完成简单的读取操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;import&lt;/span&gt; java.io.*&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Demo4 {
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; String file=&quot;C:\\Users\\Lenovo\\Desktop\\李xx.txt&quot;&lt;span&gt;;
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
        function();
        function1();
}  
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; function() &lt;span&gt;throws&lt;/span&gt; IOException{  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;该方法用于存&lt;/span&gt;
&lt;span&gt;       
       DataOutputStream dos&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; DataOutputStream(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(Demo4.file));
       dos.writeInt(&lt;/span&gt;1&lt;span&gt;);
       dos.writeInt(&lt;/span&gt;2&lt;span&gt;);
       dos.writeInt(&lt;/span&gt;3&lt;span&gt;);
       dos.writeInt(&lt;/span&gt;4&lt;span&gt;);
       dos.writeUTF(&lt;/span&gt;&quot;你是真滴6&quot;&lt;span&gt;);
       dos.close();
   }
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; function1() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException{
       DataInputStream  dis&lt;/span&gt;=&lt;span&gt;new&lt;/span&gt; DataInputStream(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileInputStream(file));
       System.out.println(dis.readInt());
       System.out.println(dis.readInt());
       System.out.println(dis.readInt());
       System.out.println(dis.readInt());
       System.out.println(dis.readUTF());
   }
}&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;但是我发现数据流中读取时指针的跳转过于笨拙,也就是说我们必须知道下个数据类型是啥,才能将其准确读取出来,并且前一个读不出来的话,后一个也是无法读取的。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 07 Apr 2019 14:29:00 +0000</pubDate>
<dc:creator>*三井寿*</dc:creator>
<og:description>对于IO流中字节流的总结 字节流的概念 由于应用程序,经常需要和文件打交道,所以Inputstream专门提供了读写文件的子类:FileInputStream和FileOutputStream类,如果</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/roseneverdie/p/10650952.html</dc:identifier>
</item>
</channel>
</rss>