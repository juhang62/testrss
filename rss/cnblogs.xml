<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>效率工具 | 快速创建虚拟机，Vagrant真香！ - AnonyStar</title>
<link>http://www.cnblogs.com/i-code/p/14239031.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/i-code/p/14239031.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202101/2024393-20210106084325493-312474582.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Vagrant&lt;/code&gt; 是一个基于&lt;code&gt;Ruby&lt;/code&gt;的工具，主要用于创建和部署虚拟化开发环境。它以来于&lt;code&gt;Oracle&lt;/code&gt;的开源&lt;a href=&quot;https://baike.baidu.com/item/VirtualBox&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;VirtualBox&lt;/code&gt;&lt;/a&gt;虚拟化系统，通过使用 &lt;code&gt;Chef&lt;/code&gt;创建自动化虚拟环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vagrant&lt;/code&gt; 主要的功能如下：
&lt;ul&gt;&lt;li&gt;建立和删除虚拟机&lt;/li&gt;
&lt;li&gt;配置虚拟机相关参数&lt;/li&gt;
&lt;li&gt;管理虚拟机运行状态&lt;/li&gt;
&lt;li&gt;自动配置和安装开发环境&lt;/li&gt;
&lt;li&gt;打包和分发虚拟机运行环境&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;因为 &lt;code&gt;Vagrant&lt;/code&gt; 依赖于某种虚拟化技术，目前支持常见的 &lt;code&gt;VirtualBox&lt;/code&gt;、 &lt;code&gt;VMWare&lt;/code&gt;等，所以在使用&lt;code&gt;Vagrant&lt;/code&gt;之前我们需要先安装&lt;code&gt;VirtualBox&lt;/code&gt;或 &lt;code&gt;VMWare&lt;/code&gt;，不然无法使用。推荐安装 &lt;code&gt;VirtualBox&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;vagrant&lt;/code&gt; 可以快速，方便，全自动的构建虚拟化环境，这也是我们选择它的原因，而不是让我们像以前一样全部自己来部署。&lt;/li&gt;
&lt;li&gt;它类似与 &lt;code&gt;docker&lt;/code&gt; 这种，有自己的仓库，我们直接可以通过命令从仓库中拉取虚拟镜像来快速构建&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;下载安装&quot;&gt;下载安装&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;两者软件最好都下载最新的，免得出现兼容问题，&lt;/li&gt;
&lt;li&gt;需要安装虚拟机，需要先开启处理器虚拟化技术，&lt;em&gt;&lt;strong&gt;VT-x/AMD-V硬件加速&lt;/strong&gt;。&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&quot;vagrant基本命令&quot;&gt;Vagrant基本命令&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr&gt;&lt;td&gt;vagrant box add&lt;/td&gt;
&lt;td&gt;添加box的操作&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;vagrant init&lt;/td&gt;
&lt;td&gt;初始化box的操作，会生成vagrant的配置文件Vagrantfile&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vagrant up&lt;/td&gt;
&lt;td&gt;启动本地环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;vagrant ssh&lt;/td&gt;
&lt;td&gt;通过 ssh 登录本地环境所在虚拟机&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vagrant halt&lt;/td&gt;
&lt;td&gt;关闭本地环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vagrant suspend&lt;/td&gt;
&lt;td&gt;暂停本地环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vagrant resume&lt;/td&gt;
&lt;td&gt;恢复本地环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;vagrant reload&lt;/td&gt;
&lt;td&gt;修改了 Vagrantfile 后，使之生效（相当于先 halt，再 up）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vagrant destroy&lt;/td&gt;
&lt;td&gt;彻底移除本地环境&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;vagrant box list&lt;/td&gt;
&lt;td&gt;显示当前已经添加的box列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vagrant box remove&lt;/td&gt;
&lt;td&gt;删除相应的box&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;vagrant package&lt;/td&gt;
&lt;td&gt;打包命令，可以把当前的运行的虚拟机环境进行打包&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;vagrant plugin&lt;/td&gt;
&lt;td&gt;用于安装卸载插件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;vagrant status&lt;/td&gt;
&lt;td&gt;获取当前虚拟机的状态&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;vagrant global-status&lt;/td&gt;
&lt;td&gt;显示当前用户Vagrant的所有环境状态&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;安装一个虚拟机案例&quot;&gt;安装一个虚拟机案例&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;首先我们新建一个文件夹名字 &lt;code&gt;vagrant&lt;/code&gt; ，这个名字随机，就是存放要新建的虚拟机的配置的目录，之后在&lt;code&gt;vagrant&lt;/code&gt; 目录中打开 &lt;code&gt;cmd&lt;/code&gt;或&lt;code&gt;Power Shell&lt;/code&gt; 窗口，&lt;/li&gt;
&lt;li&gt;执行下面命令：&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;vagrant init centos/7 --box-version 2004.01&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;PS D:\vagrant&amp;gt; vagrant init centos/7  --box-version 2004.01
A `Vagrantfile` has been placed in this directory. You are now
ready to `vagrant up` your first virtual environment! Please read
the comments in the Vagrantfile as well as documentation on
`vagrantup.com` for more information on using Vagrant.
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;上面命令执行结束后，在之下下面 &lt;code&gt;up&lt;/code&gt; 命令，这个过程会去下载我们需要的镜像，是比较漫长的过程，下载完后会直接启动，&lt;code&gt;vagrant up&lt;/code&gt; 命令本来就是启动命令，这是是因为没有所以会先去下载，&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;PS D:\vagrant&amp;gt; vagrant up
Bringing machine 'default' up with 'virtualbox' provider...
==&amp;gt; default: Box 'centos/7' could not be found. Attempting to find and install...
    default: Box Provider: virtualbox
    default: Box Version: 2004.01
==&amp;gt; default: Loading metadata for box 'centos/7'
    default: URL: https://vagrantcloud.com/centos/7
==&amp;gt; default: Adding box 'centos/7' (v2004.01) for provider: virtualbox
    default: Downloading: https://vagrantcloud.com/centos/boxes/7/versions/2004.01/providers/virtualbox.box
Download redirected to host: cloud.centos.org
Progress: 3% (Rate: 371k/s, Estimated time remaining: 0:18:28)
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;当然我们也可以直接提前将镜像文件下载好，直接使用 &lt;code&gt;vagrant box add {name} {url}&lt;/code&gt; 的命令进行本地安装，其中，&lt;code&gt;{name}&lt;/code&gt; 是我们要安装的名称， &lt;code&gt;url&lt;/code&gt; 是我们下载到本地的镜像路径&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;PS D:\vagrant&amp;gt; vagrant box add centos/7 E:\迅雷下载\CentOS-7-x86_64-Vagrant-1905_01.VirtualBox.box
==&amp;gt; box: Box file was not detected as metadata. Adding it directly...
==&amp;gt; box: Adding box 'centos/7' (v0) for provider:
    box: Unpacking necessary files from: file:///E:/%D1%B8%C0%D7%CF%C2%D4%D8/CentOS-7-x86_64-Vagrant-1905_01.VirtualBox.box
    box:
==&amp;gt; box: Successfully added box 'centos/7' (v0) for 'virtualbox'!
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;如果是使用本地添加的，那么这里通过 &lt;code&gt;vagrant up&lt;/code&gt; 来启动，如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;PS D:\vagrant&amp;gt; vagrant up
Bringing machine 'default' up with 'virtualbox' provider...
==&amp;gt; default: Checking if box 'centos/7' version '2004.01' is up to date...
==&amp;gt; default: Clearing any previously set forwarded ports...
==&amp;gt; default: Clearing any previously set network interfaces...
==&amp;gt; default: Preparing network interfaces based on configuration...
    default: Adapter 1: nat
==&amp;gt; default: Forwarding ports...
    default: 22 (guest) =&amp;gt; 2222 (host) (adapter 1)
==&amp;gt; default: Booting VM...
==&amp;gt; default: Waiting for machine to boot. This may take a few minutes...
    default: SSH address: 127.0.0.1:2222
    default: SSH username: vagrant
    default: SSH auth method: private key
==&amp;gt; default: Machine booted and ready!
==&amp;gt; default: Checking for guest additions in VM...
    default: No guest additions were detected on the base box for this VM! Guest
    default: additions are required for forwarded ports, shared folders, host only
    default: networking, and more. If SSH fails on this machine, please install
    default: the guest additions and repackage the box to continue.
    default:
    default: This is not an error message; everything may continue to work properly,
    default: in which case you may ignore this message.
==&amp;gt; default: Rsyncing folder: /cygdrive/d/vagrant/ =&amp;gt; /vagrant
==&amp;gt; default: Machine already provisioned. Run `vagrant provision` or use the `--provision`
==&amp;gt; default: flag to force provisioning. Provisioners marked to run always will still run.
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;启动后我们可以通过 &lt;code&gt;vagrant ssh&lt;/code&gt; 开启SSH，并登陆到 &lt;code&gt;centos7&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202101/2024393-20210106084326411-2023407233.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;网络ip配置&quot;&gt;网络IP配置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这是一个虚拟机，那么我们要实现与宿主机器的通信，可以采用端口转发，或者独立局域网，端口转发并不方便需要我们每个端口的配置，我们这里直接采用私有网段配置，也就是桥接的方式，&lt;/li&gt;
&lt;li&gt;首先我们查看自己 &lt;code&gt;Windows&lt;/code&gt; 电脑的 &lt;code&gt;IP&lt;/code&gt;，其中有个网卡 &lt;code&gt;VirtualBox Host-Only Network&lt;/code&gt;。，这就是虚拟机的网卡，看到其&lt;code&gt;IP&lt;/code&gt;地址段&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202101/2024393-20210106084326927-644746264.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;直接在我们刚才 &lt;code&gt;vagrant&lt;/code&gt; 的目录下的 &lt;code&gt;Vagrantfile&lt;/code&gt; 文件中就行配置修改，这是我们刚才创建的虚拟机的配置文件 ，配置 &lt;code&gt;config.vm.network &quot;private_network&quot;, ip: &quot;192.168.56.10&quot;&lt;/code&gt;，如下所示：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202101/2024393-20210106084328381-1137403466.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;里面可以配置很多，我们配置私有网路，刚才看到虚拟网卡网段是 &lt;code&gt;192.168.56.1&lt;/code&gt;，那么我们将这台的配置为 &lt;code&gt;192.168.56.10&lt;/code&gt; ，配置好之后需要重启虚拟机，通过 &lt;code&gt;vagrant reload&lt;/code&gt; ，进行重启，重启后我们可以验证其与主机是否能互通&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202101/2024393-20210106084329576-858258675.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;到此为止，我们已经配置好了虚拟机 的网络，那么我们接下来是否能通过 &lt;code&gt;Xshell&lt;/code&gt; 或 &lt;code&gt;Secure CRT&lt;/code&gt; 进行远程连接呢？&lt;/li&gt;
&lt;li&gt;我们需要开启远程登陆，通过 &lt;code&gt;vagrant ssh&lt;/code&gt; 到虚拟机，之后找到 &lt;code&gt;/etc/ssh/sshd_config&lt;/code&gt; 文件修改它，通过 &lt;code&gt;sudo vi sshd_config&lt;/code&gt; ,修改里面的如下两项内容，修改后直接 &lt;code&gt;wq&lt;/code&gt; 保存退出&lt;code&gt;vi&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;PermitRootLogin yes 
PasswordAuthentication yes
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;开启后，我们再重启 &lt;code&gt;SSHD&lt;/code&gt; ，通过 &lt;code&gt;systemctl restart sshd&lt;/code&gt;，这时候会让你输入&lt;code&gt;root&lt;/code&gt; 的密码，&lt;code&gt;root&lt;/code&gt; 账号的密码默认也是 &lt;code&gt;vagrant&lt;/code&gt;，你可以选择直接用 &lt;code&gt;sudo&lt;/code&gt; 执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202101/2024393-20210106084330202-785856541.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在 &lt;code&gt;xshell&lt;/code&gt; 下测试是否能登录&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2024393/202101/2024393-20210106084331107-600665565.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;6.0520833333333&quot;&gt;
&lt;p&gt;本文由AnonyStar 发布,可转载但需声明原文出处。&lt;br/&gt;欢迎关注微信公账号 ：云栖简码 获取更多优质文章&lt;br/&gt;更多文章关注笔者博客 ：&lt;a href=&quot;https://i-code.online/&quot; target=&quot;_blank&quot;&gt;云栖简码 i-code.online&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 06 Jan 2021 00:44:00 +0000</pubDate>
<dc:creator>AnonyStar</dc:creator>
<og:description>Vagrant 是一个基于Ruby的工具，主要用于创建和部署虚拟化开发环境。它以来于Oracle的开源VirtualBox虚拟化系统，通过使用 Chef创建自动化虚拟环境。 Vagrant 主要的功能</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/i-code/p/14239031.html</dc:identifier>
</item>
<item>
<title>JavaCV FFmpeg AAC编码 - HiIT青年</title>
<link>http://www.cnblogs.com/itqn/p/14225880.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/itqn/p/14225880.html</guid>
<description>&lt;p&gt;上次成功通过FFmpeg采集麦克风的PCM数据，这次针对上一次的程序进行了改造，使用AAC编码采集后的数据。&lt;/p&gt;
&lt;p&gt;(传送门) &lt;a href=&quot;https://www.cnblogs.com/itqn/p/14224295.html&quot; target=&quot;_blank&quot;&gt;JavaCV FFmpeg采集麦克风PCM音频数据&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;采集麦克风数据是一个解码过程，而将采集后的数据进行AAC编码则是编码过程，如图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202010/2083963-20201011103416657-1015041119.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;从上图可以看出，编码过程，数据流是从AVFrame流向AVPacket，而解码过程正好相反，数据流是从AVPacket流向AVFrame。&lt;/p&gt;
&lt;p&gt;javacpp-ffmpeg依赖：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.bytedeco.javacpp-presets&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;ffmpeg&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;${ffmpeg.version}&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FFmpeg编码的过程是解码的逆过程，不过主线流程是类似的，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202101/2083963-20210103155847187-46415562.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;基本上主要的步骤都是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;查找编码/解码器&lt;/li&gt;
&lt;li&gt;打开编码/解码器&lt;/li&gt;
&lt;li&gt;进行编码/解码&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在FFmpeg的demo流程中其实还有创建流&lt;code&gt;avformat_new_stream()&lt;/code&gt;，写入头部信息&lt;code&gt;avformat_write_header()&lt;/code&gt;和尾部信息&lt;code&gt;av_write_trailer()&lt;/code&gt;等操作，这里只是将PCM数据编码成AAC，所以可以暂时不需要考虑这些操作。&lt;/p&gt;
&lt;p&gt;将采集音频流数据进行AAC编码的整体流程主要有以下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;采集音频帧&lt;/li&gt;
&lt;li&gt;将视音频帧重采样&lt;/li&gt;
&lt;li&gt;构建AAC编码器&lt;/li&gt;
&lt;li&gt;对音频帧进行编码&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;采集音频帧&quot;&gt;采集音频帧&lt;/h5&gt;
&lt;p&gt;采集音频流中的音频帧在上一次采集PCM数据的时候已经实现了，主要是从AVFormatContext中用&lt;code&gt;av_read_frame()&lt;/code&gt;读取音频数据并进行解码（&lt;code&gt;avcodec_decode_audio4()&lt;/code&gt;），实现代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public AVFrame grab() throws FFmpegException {
    if (av_read_frame(pFormatCtx, pkt) &amp;gt;= 0 &amp;amp;&amp;amp; pkt.stream_index() == audioIdx) {
        ret = avcodec_decode_audio4(pCodecCtx, pFrame, got, pkt);
        if (ret &amp;lt; 0) {
            throw new FFmpegException(ret, &quot;avcodec_decode_audio4 解码失败&quot;);
        }
        if (got[0] != 0) {
            return pFrame;
        }
        av_packet_unref(pkt);
    }
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样通过grab()方法就可以获取到音频流中的音频帧了。&lt;/p&gt;
&lt;h5 id=&quot;音频帧重采样&quot;&gt;音频帧重采样&lt;/h5&gt;
&lt;p&gt;在进行AAC编码之前，如果采集的音频帧信息格式跟编码器信息不一致则需要进行重采样，用到的是FFmpeg的&lt;code&gt;SwrContext&lt;/code&gt;组件，下面的&lt;code&gt;AudioConverter&lt;/code&gt;是对&lt;code&gt;SwrContext&lt;/code&gt;封装的组件，内部实现了AVFrame的填充及&lt;code&gt;SwrContext&lt;/code&gt;的初始化，使用方式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 1. 创建AudioConverter，指定转化格式为AV_SAMPLE_FMT_S16
AudioConverter.create(src_channel_layout, src_sample_fmt, src_sample_rate, 
    dst_channel_layout, AV_SAMPLE_FMT_S16, dst_sample_rate, dst_nb_samples);
// 2. 对音频帧进行转化swr_convert
converter.convert(pFrame);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AudioConverter的convert方式，实际上也是调用了SwrContext的swr_convert方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;swr_convert(swrCtx, new PointerPointer&amp;lt;&amp;gt;(buffer), bufferLen, pFrame.data(), pFrame.nb_samples());
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;构建aac编码器&quot;&gt;构建AAC编码器&lt;/h5&gt;
&lt;p&gt;进行AAC编码之前需要构建AAC编码器，根据上面的流程图利用&lt;code&gt;avcodec_find_encoder()&lt;/code&gt;和&lt;code&gt;avcodec_alloc_context3()&lt;/code&gt;实现编码器的创建和参数配置，最后用&lt;code&gt;avcodec_open()&lt;/code&gt;打开编码器，完整的初始化代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static AudioAACEncoder create(int channels, int sample_fmt, int sample_rate, Consumer&amp;lt;byte[]&amp;gt; aacBufConsumer, Map&amp;lt;String, String&amp;gt; opts) throws FFmpegException {
    AudioAACEncoder a = new AudioAACEncoder();
    // 查找AAC编码器
    a.pCodec = avcodec_find_encoder(AV_CODEC_ID_AAC);
    if (a.pCodec == null) {
        throw new FFmpegException(&quot;初始化 AV_CODEC_ID_AAC 编码器失败&quot;);
    }
    // 初始化编码器信息
    a.pCodecCtx = avcodec_alloc_context3(a.pCodec);
    a.pCodecCtx.codec_id(AV_CODEC_ID_AAC);
    a.pCodecCtx.codec_type(AVMEDIA_TYPE_AUDIO);
    a.pCodecCtx.sample_fmt(sample_fmt);
    a.pCodecCtx.sample_rate(sample_rate);
    a.pCodecCtx.channel_layout(av_get_default_channel_layout(channels));
    // 音频参数设置
    a.pCodecCtx.channels(av_get_channel_layout_nb_channels(a.pCodecCtx.channel_layout()));
    a.pCodecCtx.bit_rate(64000);
    // 其他参数设置
    AVDictionary dictionary = new AVDictionary();
    opts.forEach((k, v) -&amp;gt; av_dict_set(dictionary, k, v, 0));
    a.ret = avcodec_open2(a.pCodecCtx, a.pCodec, dictionary);
    if (a.ret &amp;lt; 0) {
        throw new FFmpegException(a.ret, &quot;avcodec_open2 编码器打开失败&quot;);
    }
    // 填充音频帧
    a.aacFrame = av_frame_alloc();
    a.aacFrame.nb_samples(a.pCodecCtx.frame_size());
    a.aacFrame.format(a.pCodecCtx.sample_fmt());
    a.aacFrameSize = av_samples_get_buffer_size((IntPointer) null, a.pCodecCtx.channels(), //
        a.pCodecCtx.frame_size(), a.pCodecCtx.sample_fmt(), 1);
    // pCodecCtx.sample_fmt() = S16
    // AutoCloseable
    a.buffer = new BytePointer(av_malloc(a.aacFrameSize)).capacity(a.aacFrameSize);
    avcodec_fill_audio_frame(a.aacFrame, a.pCodecCtx.channels(), a.pCodecCtx.sample_fmt(), a.buffer, a.aacFrameSize, 1);

    a.pkt = new AVPacket();
    a.pcmBuffer = new byte[DEF_PCM_BUFFER_SIZE];
    a.aacBuffConsumer = aacBufConsumer;
    return a;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要特别注意的是，不是每一帧pcm数据都能编码成为一帧AAC音频帧，所以这里通过&lt;code&gt;Consumer&amp;lt;byte[]&amp;gt; aacBufConsumer&lt;/code&gt;指定回调来消费编码完成的AAC音频帧。&lt;/p&gt;
&lt;h5 id=&quot;对音频帧进行编码&quot;&gt;对音频帧进行编码&lt;/h5&gt;
&lt;p&gt;编码器构建完成后就可以对音频帧进行编码了，入参为AVFrame，出参通过&lt;code&gt;Consumer&amp;lt;byte[]&amp;gt; aacBufConsumer&lt;/code&gt;指定回调输出byte[]，就如上面提到，不是一帧PCM音频数据就能编码成一帧AAC数据，所以这里需要就多帧pcm音频帧进行编码，并缓存未编码的pcm数据留到下一次编码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void encode(AVFrame avFrame) throws FFmpegException {
    // 计算Pcm容量
    int size = AudioUtils.toPcmFrameSize(avFrame, pCodecCtx.channels(), pCodecCtx.sample_fmt());
    byte[] buff = new byte[size];
    avFrame.data(0).get(buff);

    System.arraycopy(buff, 0, pcmBuffer, offset, size);
    offset += size;
    capacity += size;

    while (capacity &amp;gt;= aacFrameSize) {
        byte[] aacBuf = new byte[aacFrameSize];
        System.arraycopy(pcmBuffer, 0, aacBuf, 0, aacFrameSize);
        aacFrame.data(0).put(aacBuf);
        // 减去已经用于编码的buff
        capacity -= aacFrameSize;
        offset = capacity;
        if (capacity &amp;gt; 0) { // 如果还有剩余，则放入buffer最前面
            byte[] lBuff = new byte[capacity];
            System.arraycopy(pcmBuffer, aacFrameSize, lBuff, 0, capacity);
            System.arraycopy(lBuff, 0, pcmBuffer, 0, capacity);
        }

        ret = avcodec_encode_audio2(pCodecCtx, pkt, aacFrame, got);
        if (ret &amp;lt; 0) {
            throw new FFmpegException(ret, &quot;avcodec_encode_audio2 音频编码失败&quot;);
        }
        if (got[0] != 0) {
            byte[] pktBuff = new byte[pkt.size()];
            pkt.data().get(pktBuff);
            if (aacBuffConsumer != null) {
                aacBuffConsumer.accept(pktBuff);
            }
            av_packet_unref(pkt);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后只需要调整一下上一次的主程序，将读取pcm数据的部分，调整为将AVFrame丢进编码器，拉取byte数组即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static void main(String[] args) throws FFmpegException, FileNotFoundException {
    FFmpegRegister.register();
    AudioGrabber a = AudioGrabber.create(&quot;External Mic (Realtek(R) Audio)&quot;);

    FileOutputStream fos = new FileOutputStream(new File(&quot;s16.aac&quot;));
    AudioAACEncoder encoder = AudioAACEncoder.create(a.channels(), a.sample_fmt(), a.sample_rate(), buff -&amp;gt; {
        try {
            fos.write(buff);
        } catch (IOException e) {
            e.printStackTrace();
        }
    });
    for (int i = 0; i &amp;lt; 100; i++) {
        encoder.encode(a.grab());
    }
    encoder.release();
    a.release();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终采集编码后的AAC数据可以用VLC播放：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202101/2083963-20210103162630294-413034639.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这里对比一下&lt;/strong&gt;，同样的100帧pcm数据和aac数据的大小，相差还是很大的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2083963/202101/2083963-20210103162720430-1326483060.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;=========================================================&lt;br/&gt;AAC编码源码可&lt;strong&gt;关注&lt;/strong&gt;公众号 “HiIT青年” 发送 “ffmpeg-aac” 获取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/itqn/1797476/o_200702010008qrcode.jpg&quot; alt=&quot;HiIT青年&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;关注公众号&lt;/strong&gt;，阅读更多文章。&lt;/p&gt;
</description>
<pubDate>Wed, 06 Jan 2021 00:44:00 +0000</pubDate>
<dc:creator>HiIT青年</dc:creator>
<og:description>上次成功通过FFmpeg采集麦克风的PCM数据，这次针对上一次的程序进行了改造，使用AAC编码采集后的数据。 (传送门) JavaCV FFmpeg采集麦克风PCM音频数据 采集麦克风数据是一个解码过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/itqn/p/14225880.html</dc:identifier>
</item>
<item>
<title>Kubernetes官方java客户端之四：内部应用 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14239024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14239024.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;概览&quot;&gt;概览&lt;/h3&gt;
&lt;ol readability=&quot;3.7087126137841&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本文是《Kubernetes官方java客户端》系列的第四篇，以下提到的java客户端都是指client-jar.jar；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.7741935483871&quot;&gt;
&lt;p&gt;前文&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107528068&quot; target=&quot;_blank&quot;&gt;《Kubernetes官方java客户端之三：外部应用》&lt;/a&gt;中，咱们开发了一个名为&lt;span&gt;OutsideclusterApplication&lt;/span&gt;的SpringBoot应用，该应用并未部署在K8S环境，而是远程访问K8S环境内部的API Server，整体结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210106084032033-33507307.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;除了前文中部署在外部的方式，还有一种常见场景：使用java客户端的应用自身也部署在K8S环境中，如下图所示，名为&lt;span&gt;DemoApplication的SpringBoot&lt;/span&gt;应用部署在K8S环境内，调用java客户端库的API对K8S进行各种操作，整体结构如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210106084032305-1975420303.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;本文的内容就是开发上图中名为&lt;span&gt;DemoApplication&lt;/span&gt;的应用，并且部署在K8S环境中进行验证；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;额外准备&quot;&gt;额外准备&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;SpringBoot制作成docker镜像，首选官方推荐的方式，参考&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106597358&quot; target=&quot;_blank&quot;&gt;《体验SpringBoot(2.3)应用制作Docker镜像(官方方案)》&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106598189&quot; target=&quot;_blank&quot;&gt;《详解SpringBoot(2.3)应用制作Docker镜像(官方方案)》&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;SpringBoot应用在K8S环境下的探针技术，参考&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106605264&quot; target=&quot;_blank&quot;&gt;《掌握SpringBoot-2.3的容器探针：基础篇》&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106606442&quot; target=&quot;_blank&quot;&gt;《掌握SpringBoot-2.3的容器探针：深入篇》&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/106607225&quot; target=&quot;_blank&quot;&gt;《掌握SpringBoot-2.3的容器探针：实战篇》&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;kubernetesclient&lt;/span&gt;文件夹下，如下图红框所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210106084032488-222754474.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;开发k8s环境内的应用：demoapplication&quot;&gt;开发K8S环境内的应用：DemoApplication&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;打开&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107480015&quot; target=&quot;_blank&quot;&gt;《Kubernetes官方java客户端：准备》&lt;/a&gt;中创建的的&lt;span&gt;kubernetesclient&lt;/span&gt;工程，在里面创建子工程，名为&lt;span&gt;helloworld&lt;/span&gt;，这是个SpringBoot工程，pom.xml内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&amp;gt;
    &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt;

    &amp;lt;parent&amp;gt;
        &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;kubernetesclient&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;
        &amp;lt;relativePath&amp;gt;../pom.xml&amp;lt;/relativePath&amp;gt;
    &amp;lt;/parent&amp;gt;

    &amp;lt;groupId&amp;gt;com.bolingcavalry&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;helloworld&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
    &amp;lt;name&amp;gt;helloworld&amp;lt;/name&amp;gt;
    &amp;lt;description&amp;gt;Demo project for Spring Boot&amp;lt;/description&amp;gt;
    &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt;

    &amp;lt;dependencies&amp;gt;
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;spring-boot-starter-actuator&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;org.projectlombok&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;lombok&amp;lt;/artifactId&amp;gt;
            &amp;lt;optional&amp;gt;true&amp;lt;/optional&amp;gt;
        &amp;lt;/dependency&amp;gt;
        
        &amp;lt;dependency&amp;gt;
            &amp;lt;groupId&amp;gt;io.kubernetes&amp;lt;/groupId&amp;gt;
            &amp;lt;artifactId&amp;gt;client-java&amp;lt;/artifactId&amp;gt;
        &amp;lt;/dependency&amp;gt;

    &amp;lt;/dependencies&amp;gt;

    &amp;lt;build&amp;gt;
        &amp;lt;plugins&amp;gt;
            &amp;lt;plugin&amp;gt;
                &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;
                &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt;
                &amp;lt;version&amp;gt;2.3.0.RELEASE&amp;lt;/version&amp;gt;
                &amp;lt;!--该配置会在jar中增加layer描述文件，以及提取layer的工具--&amp;gt;
                &amp;lt;configuration&amp;gt;
                    &amp;lt;layers&amp;gt;
                        &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt;
                    &amp;lt;/layers&amp;gt;
                &amp;lt;/configuration&amp;gt;
            &amp;lt;/plugin&amp;gt;
        &amp;lt;/plugins&amp;gt;
    &amp;lt;/build&amp;gt;

&amp;lt;/project&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;编写java代码，创建&lt;span&gt;DemoApplication.java&lt;/span&gt;，这里为了简单起见，将引导类和web controller的代码都写在DemoApplication类中：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;package com.bolingcavalry.demo;

import com.google.gson.Gson;
import io.kubernetes.client.openapi.ApiClient;
import io.kubernetes.client.openapi.Configuration;
import io.kubernetes.client.openapi.apis.CoreV1Api;
import io.kubernetes.client.openapi.models.V1PodList;
import io.kubernetes.client.util.Config;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.stream.Collectors;

@SpringBootApplication
@RestController
@Slf4j
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

    @RequestMapping(value = &quot;/hello&quot;)
    public List&amp;lt;String&amp;gt; hello() throws Exception {
        ApiClient client = Config.defaultClient();
        Configuration.setDefaultApiClient(client);

        CoreV1Api api = new CoreV1Api();

        // 调用客户端API取得所有pod信息
        V1PodList v1PodList = api.listPodForAllNamespaces(null, null, null, null, null, null, null, null, null);

        // 使用Gson将集合对象序列化成JSON，在日志中打印出来
        log.info(&quot;pod info \n{}&quot;, new Gson().toJson(v1PodList));

        return v1PodList
                .getItems()
                .stream()
                .map(value -&amp;gt;
                        value.getMetadata().getNamespace()
                        + &quot;:&quot;
                        + value.getMetadata().getName())
                .collect(Collectors.toList());
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;还记得&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107503695&quot; target=&quot;_blank&quot;&gt;《Kubernetes官方java客户端之二：序列化和反序列化问题》&lt;/a&gt;提到的序列化问题吗？上述代码中，log.info那段代码里对&lt;span&gt;V1PodList&lt;/span&gt;执行序列化的是Gson，并且hello方法返回的也不是V1PodList实例，而是新做的一个List实例，这样做是因为jackson对V1PodList做序列化会导致异常，这里要避免jackson参与序列化操作；&lt;/li&gt;
&lt;li&gt;应用的代码已经写完，接下来是镜像制作用到的Dockerfile文件，该文件和刚才创建的pom.xml文件在同一个目录下(即子工程&lt;span&gt;helloworld&lt;/span&gt;的文件夹下)，Dockerfile文件内容如下：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;# 指定基础镜像，这是分阶段构建的前期阶段
FROM openjdk:8u212-jdk-stretch as builder
# 执行工作目录
WORKDIR application
# 配置参数
ARG JAR_FILE=target/*.jar
# 将编译构建得到的jar文件复制到镜像空间中
COPY ${JAR_FILE} application.jar
# 通过工具spring-boot-jarmode-layertools从application.jar中提取拆分后的构建结果
RUN java -Djarmode=layertools -jar application.jar extract

# 正式构建镜像
FROM openjdk:8u212-jdk-stretch
WORKDIR application
# 前一阶段从jar中提取除了多个文件，这里分别执行COPY命令复制到镜像空间中，每次COPY都是一个layer
COPY --from=builder application/dependencies/ ./
COPY --from=builder application/spring-boot-loader/ ./
COPY --from=builder application/snapshot-dependencies/ ./
COPY --from=builder application/application/ ./
ENTRYPOINT [&quot;java&quot;, &quot;org.springframework.boot.loader.JarLauncher&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;在子工程pom.xml文件所在目录执行以下命令完成编译构建：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mvn clean package -U -DskipTests
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;接下来要制作镜像文件了，请确保当前电脑已经安装并运行了docker，另外构建docker镜像的操作&lt;span&gt;我仅在macOS和Linux操作系统下执行成功&lt;/span&gt;，在Windows环境能否成功请自行尝试；&lt;/li&gt;
&lt;li&gt;在Dockerfile所在目录执行以下命令即可创建docker镜像文件：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker build -t 192.168.50.43:5888/common/helloworld:1.0-SNAPSHOT .
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;8&quot; readability=&quot;1.3946629213483&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;上述命令执行成功后，镜像文件还只是在本机的docker仓库中，请放置到K8S环境可以访问的地方，我这里是在内网部署了镜像仓库Harbor，执行以下命令即可从本地仓库推送到Harbor(可能需要先登录，与Harbor的设置有关)：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210106084032787-747340985.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.7658079625293&quot;&gt;
&lt;p&gt;镜像准备完成，接下来就是在K8S环境部署了，在K8S环境创建名为helloworld.yaml的文件，内容如下，可见deployment和service都配置好了，另外请注意serviceAccountName属性的值为kubernates-client-service-account，此serviceAccountName是在&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/107480015&quot; target=&quot;_blank&quot;&gt;《Kubernetes官方java客户端之一：准备》&lt;/a&gt;一文中创建好的RBAC资源，令咱们开发的helloworld应用有权限请求API Server：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-yaml&quot;&gt;apiVersion: v1
kind: Service
metadata:
  name: helloworld
  namespace : kubernetesclient
spec:
  type: NodePort
  ports:
    - port: 8080
      nodePort: 30100
  selector:
    name: helloworld
---
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  namespace : kubernetesclient
  name: helloworld
spec:
  replicas: 1
  template:
    metadata:
      labels:
        name: helloworld
    spec:
      serviceAccountName: kubernates-client-service-account
      containers:
        - name: helloworld
          image: 192.168.50.43:5888/common/helloworld:1.0-SNAPSHOT
          tty: true
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 8080
            initialDelaySeconds: 5
            failureThreshold: 10
            timeoutSeconds: 10
            periodSeconds: 5
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8080
            initialDelaySeconds: 5
            timeoutSeconds: 10
            periodSeconds: 5
          ports:
            - containerPort: 8080
          resources:
            requests:
              memory: &quot;512Mi&quot;
              cpu: &quot;100m&quot;
            limits:
              memory: &quot;1Gi&quot;
              cpu: &quot;1000m&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;10&quot; readability=&quot;-0.43911439114391&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;helloworld.yaml所在目录执行命令：&lt;span&gt;kubectl apply -f helloworld.yaml&lt;/span&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210106084033111-305584947.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;我这边，上图中的Pod所在宿主机IP地址是&lt;span&gt;192.168.50.135&lt;/span&gt;，因此用浏览器访问&lt;a href=&quot;http://192.168.50.135:30100/hello&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://192.168.50.135:30100/hello&lt;/span&gt;&lt;/a&gt;，如下图，可见当前K8S环境下所有Pod名称都返回了：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202101/485422-20210106084033492-1217282973.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至此，SpringBoot应用通过K8S官方java客户端，成功获取了自身所在K8S环境的信息，通过前文和本章，咱们对K8S官方java客户端已经有了基本的认识，接下来的实战会开启这个客户端更丰富的能力；&lt;/p&gt;
&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 06 Jan 2021 00:41:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14239024.html</dc:identifier>
</item>
<item>
<title>改进你的c#代码的5个技巧（二） - 码农译站</title>
<link>http://www.cnblogs.com/hhhnicvscs/p/14239022.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hhhnicvscs/p/14239022.html</guid>
<description>&lt;p&gt;在本文中，我将向你展示c#编程的5个最佳实践。我从日常编程经验中学到了这些实践。我在release模式下测试了所有的代码，并在开发环境稳定后进行了截屏。我想你会喜欢这些建议的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;在使用数据类型之前选择它&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于许多类型，我们宁愿不决定在日常编程生活中使用什么数据类型。就在几个月前，我也是其中之一。但是当我开始学习编程中的最佳实践以提高代码性能时，我了解到了错误的数据类型是如何影响代码的。我将展示一个演示来证明这个概念。&lt;/p&gt;

&lt;p&gt;在上面的代码中，首先我使用了一个list来存储1000个整数值，在第二次执行相同的操作时，我使用了一个整数数组。我的输出截图显示了哪种存储机制最适合整数数组。现在，你可能会想为什么这个list要花更多的时间呢?原因是，list以对象格式存储数据，当我们首先尝试存储值类型时，它将其转换为引用类型，然后再存储。因此，第一点是始终选择适当的存储机制以获得最佳性能。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;使用for循环代替foreach&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我现在要解释一个非常有趣的事实。我想你们都熟悉for和foreach循环。现在如果我问你哪个更快?嗯…不知道。对吧?&lt;/p&gt;
&lt;p&gt;伙计们，for循环比foreach循环快得多。让我们看看下面的例子。&lt;/p&gt;

&lt;p&gt;不要担心，我已经在发布模式下测试了这个示例，这个屏幕截图是在几次测试运行后拍摄的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;选择何时使用类，何时使用结构体&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接受这样一个事实，即基本理解了c#中的结构体和类，或者至少理解了最喜欢的编程语言中的结构体和类(如果它们存在的话)。好吧，如果你在想“很久以前我学过结构体，但在日常编码生活中从未使用过它”，那么你就是那95%从未测量过类和结构体性能的开发人员中的一员。别担心;在写这篇文章之前，我也没有。&lt;/p&gt;
&lt;p&gt;那么类呢?是的，我们时不时地在日常项目开发中实现一个类。&lt;/p&gt;
&lt;p&gt;现在我的问题是“哪个更快，类还是结构体”?我猜你会想“从未测试过”。好的，我们来测试一下。看看下面的代码。&lt;/p&gt;

&lt;p&gt;输出结果如下：&lt;/p&gt;

&lt;p&gt;现在很明显，结构体要比类快得多。同样，我在发布模式下测试了这段代码，并获得了至少20个输出，以使程序达到稳定的位置。&lt;/p&gt;
&lt;p&gt;现在最大的问题是“为什么结构体比类快?”&lt;/p&gt;
&lt;p&gt;正如我们所知，结构体变量是值类型，值(或结构体变量)存储在一个位置。&lt;/p&gt;
&lt;p&gt;类对象是引用类型。如果是对象类型，则创建引用，并将值存储在内存的其他位置。基本上，值存储在一个可管理的堆中，指针创建在堆栈中。以这种方式在内存中实现一个对象，通常要比结构体变量花费更多的时间。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;始终使用Stringbuilder进行字符串连接操作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这一点对开发人员来说非常关键。在进行大量字符串拼接操作时，请使用StringBuilder代替String。为了演示它对代码性能的影响，我准备了以下示例代码。我在for循环中执行了500次字符串拼接操作。&lt;/p&gt;


&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;选择分配类数据成员的最佳方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在为类变量赋值之前，我建议你现在查看以下代码和输出屏幕。&lt;/p&gt;

&lt;p&gt; 是的，我们的输出屏幕是说，使用属性分配数据成员比直接分配要慢得多。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;欢迎关注我的公众号，如果你有喜欢的外文技术文章，可以通过公众号留言推荐给我。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2248030/202101/2248030-20210106083954084-1766163321.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;原文链接：https://www.c-sharpcorner.com/UploadFile/dacca2/5-tips-to-improve-performance-of-C-Sharp-code/&lt;/p&gt;
</description>
<pubDate>Wed, 06 Jan 2021 00:40:00 +0000</pubDate>
<dc:creator>码农译站</dc:creator>
<og:description>在本文中，我将向你展示c#编程的5个最佳实践。我从日常编程经验中学到了这些实践。我在release模式下测试了所有的代码，并在开发环境稳定后进行了截屏。我想你会喜欢这些建议的。 在使用数据类型之前选择</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hhhnicvscs/p/14239022.html</dc:identifier>
</item>
<item>
<title>2020年度总结之成长篇 - 虚生</title>
<link>http://www.cnblogs.com/dylancao/p/14239013.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dylancao/p/14239013.html</guid>
<description>&lt;p&gt;  新年的钟声敲响了，沉重的2020就这样消失在历史中了。一年之间，斗转星移，春夏秋冬，当回望过去，感触颇深。有太多的经历值得回味，有太多痛苦值得铭记。有太多的失误值得修正，也有太多的成长值得庆祝。经历过彷徨，失望，也经历过开心和刻骨铭心。不过，这些都会像窗外飘飞的雪花落入泥土一样，这些都会慢慢的变成历史，或多或少的影响着未来的路。&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;7&quot;&gt; &lt;/p&gt;

&lt;p&gt;  一场突入其来的疫情，把年前的一切期许都冰封了。封闭在家，除了吃饭睡觉，我并没有丝毫的松懈，一直默默地为来年的产品准备一些前期的技术，那段时间，能够深刻的感悟到李安低谷期的心情，在家带孩子，做饭，同时还要不断地修炼内功，以图事业有所突破。由于自身眼光的局限和方法的不对，几个月的努力，发现这些技术虽然是成功的，但是商业上却是失败的。把两个芯片的所有应用层写了一遍，摸索着搭建了属于自己的网页。后来的时间证明，这些自认为很好的创意在商业上都是非常失败的。这些门槛太低了，很多人都能做，自己又不熟悉市场，导致了弄出来的东西根本无人问津。现在回想起来，当初就像一个小孩子在玩泥巴，虽然非常的卖力，但是并不知道这些泥巴到底会有什么用处。也就是这些泥巴，不仅仅锻炼了我的技术水平，更重要的是，让我无意中发现了一个成长和营销的窗口，也就是借着这个窗口，才让后续的事业有了新的开端。&lt;/p&gt;
&lt;p&gt; 这个春天，我顶着寒风，在寒冷贫瘠的土地上，颤巍巍的种下了几颗不知道未来如何的种子。也许，这个就是人生吧，你永远不知道种下的将来会成为什么。&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;15&quot;&gt; &lt;/p&gt;

&lt;p&gt;  疫情还没结束，我就匆匆的踏上了出差的旅程。于此同时，春天一个无意之举，带来了一些生意。每天接待客户的电话，解决者客户的问题，那种忙碌的程度，真是让人连吃饭的时间都没了。同时，由于自身实力还不够强大，只能寄人篱下，那种寄人篱下的无奈和苦楚，让我倍感艰辛。后来迫于无奈，才找了一个根据地，这个时候我才发现。效率真是高啊，终于体会到革命根据地的重要性了。下面摘抄毛主席的这句话，可以充分说明此刻的心情和体会：革命要有根据地，就像人要有屁股，人若没有屁股，便不能坐下来；要是老走着，老站着，定然不会持久；腿走酸了，站软了，就会倒下去。革命有了根据地，才能够有地方休整，恢复气力，补充力量，再继续战斗，扩大发展，走向最后胜利。这段经历，虽然很苦很累，可是，让我知道了很多路是行不通的，找到根据地，弄好产品，才能往前发展啊。任何事情，不经历怎么知道呢&lt;/p&gt;
&lt;p&gt;  这个夏天，让我经历了从零到N的突破，让我经历游击生活到根据地生活，自此之后，不再打游击了。这段游击岁月，真是一段特殊的经历啊。经历了游击，你才能体会到革命根据的重要性。希望在这个偏僻的根据地，能够拉出一个忠于理想，能打硬仗的队伍来。才能在后面的激烈的市场竞争中，能够脱颖而出。&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;22&quot;&gt; &lt;/p&gt;

&lt;p&gt;  秋天一般是收获的季节，我却被一个的错误的决策给耽误了，答应一个朋友的请求，做了一个和主业毫不相关的业务外包，把整个团队都陷进去了。整个年头，就这个项目最急，加班最多，却收获最小。从这个 烂泥潭中爬出来的瞬间，真是有种浴火重生感觉啊。我暗自发誓，再也不接纯体力的技术外包了，这种外包，真是连外围都不如啊。&lt;/p&gt;
&lt;p&gt;  没有颗粒无收的秋天，前提是春天你要多播种，夏天多呵护。这个秋天，虽然有重大的方向失误，可还是有一些收获的，两个大客户的产品已经通过评审，算是出了一些货，这样就让我吃了一颗定心丸，总归，客户的事情是搞定了一些。有不少希望在前面延伸，无论如何，相比以前，真是好了不少。&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;29&quot;&gt; &lt;/p&gt;

&lt;p&gt;  劳累了一年，终于到了一年中的结尾。这个冬天有点冷，坐在属于自己的办公室，围着火炉，写着那些充满希望的代码，愈发感觉到星星之火逐渐明朗了。方向逐渐的明确了，产品逐渐的清晰了，这些都是很好的苗头，只要沿着这个苗头往前走，明年，肯定是会更上一层楼的。&lt;/p&gt;
&lt;p class=&quot;sync-line&quot; data-line=&quot;34&quot;&gt; &lt;/p&gt;

&lt;p&gt;  人最重要的是阅历，今年走过的这些路，都是我这个技术理工男以前所不曾经历的，阶层决定眼光，这个是给以前的补课啊。既然都是需要经历的，那就是越早越好。在新的一年，希望能够越来越好，搭建一个高素质的团队吧。尽量做一个高速运营的团队。一个具有核心竞争力的公司。&lt;/p&gt;
</description>
<pubDate>Wed, 06 Jan 2021 00:37:00 +0000</pubDate>
<dc:creator>虚生</dc:creator>
<og:description>总结 新年的钟声敲响了，沉重的2020就这样消失在历史中了。一年之间，斗转星移，春夏秋冬，当回望过去，感触颇深。有太多的经历值得回味，有太多痛苦值得铭记。有太多的失误值得修正，也有太多的成长值得庆祝。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dylancao/p/14239013.html</dc:identifier>
</item>
<item>
<title>Redis缓存篇（一）Redis是如何工作的 - 大杂草</title>
<link>http://www.cnblogs.com/liang24/p/14208977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liang24/p/14208977.html</guid>
<description>&lt;p&gt;Redis提供了高性能的数据存取功能，所以广泛应用在缓存场景中，既能有效地提升业务应用的响应速度，还可以避免把高并发压力发送到数据库层。&lt;/p&gt;
&lt;p&gt;因为Redis用作缓存的普遍性以及它在业务应用中的重要作用，所以需要系统地掌握缓存的一系列内容，包括工作原理、替换策略、异常处理和扩展机制。&lt;/p&gt;
&lt;p&gt;今天我们了解缓存的特征和Redis缓存的工作机制。&lt;/p&gt;
&lt;h2&gt;缓存特征&lt;/h2&gt;
&lt;p&gt;主要有两个特征：&lt;/p&gt;
&lt;p&gt;一是在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，能避免每次从慢速子系统中存取数据。&lt;/p&gt;
&lt;p&gt;二是缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中。&lt;/p&gt;
&lt;h2&gt;Redis缓存处理请求的两种情况&lt;/h2&gt;
&lt;p&gt;把Redis用作缓存时，会把Redis部署在数据库的前端，业务应用在访问数据时，会先查询Redis中是否保存了相应的数据。此时，根据数据是否存在缓存中，会有两种情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;缓存命中：Redis中有相应数据，就直接读取Redis，性能非常快。&lt;/li&gt;
&lt;li&gt;缓存失败：Redis中没有相应数据，就从后端数据库中读取数据，性能就会变慢。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为Redis是独立的系统软件，和业务应用程序是两个软件，因此使用Redis缓存时，要在应用程序中增加三方面代码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;当应用程序需要读取数据时，需要在代码中显式调用Redis的GET操作接口，进行查询；&lt;/li&gt;
&lt;li&gt;如果缓存缺失了，应用程序需要再和数据库连接，从数据库中读取数据；&lt;/li&gt;
&lt;li&gt;当缓存中的数据需要更新时，也需要在应用程序中显式地调用SET操作接口，把更新的数据写入缓存。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是一段示例代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
String cacheKey =&lt;span&gt; “productid_11010003”;
String cacheValue &lt;/span&gt;=&lt;span&gt; redisCache.get(cacheKey)；
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存命中&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt; ( cacheValue !=&lt;span&gt; NULL)
   &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; cacheValue;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存缺失&lt;/span&gt;
&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
   cacheValue &lt;/span&gt;=&lt;span&gt; getProductFromDB();
   redisCache.put(cacheValue)  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;缓存更新&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;缓存的类型&lt;/h2&gt;
&lt;p&gt;按照Redis缓存是否接受写请求，可以分为只读缓存和读写缓存。&lt;/p&gt;
&lt;h3&gt;只读缓存&lt;/h3&gt;
&lt;p&gt;只读缓存指读请求会先经过Redis，写操作不会经过Redis，但是会删除相应的数据。当再次读取数据时，会发生缓存缺失，然后从数据库中读取并写入缓存。&lt;/p&gt;
&lt;h3&gt;读写缓存&lt;/h3&gt;
&lt;p&gt;读写缓存指除了读请求会发到缓存处理，写请求也会发到缓存处理。&lt;/p&gt;
&lt;p&gt;和只读缓存不一样的是，在使用读写缓存时，最新的数据是在Redis中，而Redis是内存数据库，一旦出现掉电或宕机，内存中的数据就会丢失。&lt;/p&gt;
&lt;p&gt;所以，根据业务应用对数据可靠性和缓存性能的不同要求，会有两种策略，分别是同步直写和异步写回。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;同步直写，优先保证数据可靠性&lt;/strong&gt;：写请求发给缓存，同时也会发给后端数据库进行处理，等到缓存和数据库都写完数据，才给客户端返回。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步写回，优先提供快速响应&lt;/strong&gt;：所有写请求都先在缓存中处理，等到这些增改的数据要被缓存淘汰时，缓存再写回后端数据库。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;只读缓存和读写缓存的选择&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;如果需要对写请求进行回事，选择读写缓存。&lt;/li&gt;
&lt;li&gt;如果写请求很少，或者是只需要提升读请求的响应速度的话，选择只读缓存。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;只读缓存和使用直写策略的读写缓存有什么区别？&lt;/h3&gt;
&lt;p&gt;使用只读缓存时，是先把修改写到后端数据中，再把缓存中的数据删除。下次访问时，再从后端数据库读取。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：数据库和缓存完全一致，缓存中永远保留的是经常访问的热点数据。&lt;/li&gt;
&lt;li&gt;缺点：数据删除后访问会触发一次缓存缺失，从后端数据库加载数据到缓存中，这个过程访问延时会变大。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;使用读写缓存时，是同时修改数据库和缓存中的值。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;优点：被修改后的数据永远在缓存中存在，下次访问直接命中缓存。&lt;/li&gt;
&lt;li&gt;缺点：在高并发场景下，可能会导致缓存和数据库的不一致&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当数据库或缓存修改失败时：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;只读缓存：数据库和缓存中的数据保持一致&lt;/li&gt;
&lt;li&gt;读写缓存：可能导致缓存和数据库的不一致&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总结一下：只读缓存牺牲一定性能，优先保证数据库和缓存的一致性，更适合对于一致性要求比较高的业务场景。对于数据库和缓存一致性要求不高，或者不存在并发修改同一个值的情况，使用读写缓存比较合适，保证更好的性能。&lt;/p&gt;
&lt;h2&gt;参考资料&lt;/h2&gt;
</description>
<pubDate>Wed, 06 Jan 2021 00:02:00 +0000</pubDate>
<dc:creator>大杂草</dc:creator>
<og:description>Redis提供了高性能的数据存取功能，所以广泛应用在缓存场景中，既能有效地提升业务应用的响应速度，还可以避免把高并发压力发送到数据库层。 因为Redis用作缓存的普遍性以及它在业务应用中的重要作用，所</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liang24/p/14208977.html</dc:identifier>
</item>
<item>
<title>SpringBoot官网提供所有组件整理 - Brian_Huang</title>
<link>http://www.cnblogs.com/hlkawa/p/14223054.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hlkawa/p/14223054.html</guid>
<description>&lt;p class=&quot;group-title&quot;&gt;下面所有SpringBoot组件整理来自于：&lt;a href=&quot;https://start.spring.io/&quot; target=&quot;_blank&quot;&gt;https://start.spring.io/&lt;/a&gt;，紧随Spring社区的步伐......&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Developer Tools&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot DevTools &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Provides fast application restarts, LiveReload, and configurations for enhanced development experience.&lt;/p&gt;
&lt;p&gt;开发时期热部署插件,实现类文件和静态资源文件的热部署&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lombok &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java annotation library which helps to reduce boilerplate code.&lt;/p&gt;
&lt;p&gt;lombok是一个可以通过简单的注解的形式来帮助我们简化消除一些必须有但显得很臃肿的 Java 代码，lombok能够达到的效果就是在源码中不需要写一些通用的方法，但是在编译生成的字节码文件中会帮我们生成这些方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Configuration Processor &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Generate metadata for developers to offer contextual help and &quot;code completion&quot; when working with custom configuration keys (ex.application.properties/.yml files).&lt;/p&gt;
&lt;p&gt;spring默认使用yml中的配置，但有时候要用传统的xml或properties配置，就需要使用spring-boot-configuration-processor了&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Web&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring Web &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Build web, including RESTful, applications using Spring MVC. Uses Apache Tomcat as the default embedded container.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Reactive Web &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Build reactive web applications with Spring WebFlux and Netty.&lt;/p&gt;
&lt;p&gt;Spring的响应式web框架&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rest Repositories &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Exposing Spring Data repositories over REST via Spring Data REST.&lt;/p&gt;
&lt;p class=&quot;text-center detail_tit c1&quot;&gt;增加Rest Repositories让Spring数据直接升级为RestAPI (基于Spring Data原本提供的功能)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Session &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Provides an API and implementations for managing user session information.&lt;/p&gt;
&lt;p&gt;Spring Session 提供了一套创建和管理 Servlet HttpSession 的方案，默认采用外置的 Redis 来存储 Session 数据，以此来解决 Session 共享的问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rest Repositories HAL Explorer &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Browsing Spring Data REST repositories in your browser.&lt;/p&gt;
&lt;p&gt;Hypermedia API(&lt;em&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/HATEOAS&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;HATEOAS&lt;/a&gt;&lt;/em&gt;)风格的Http Restful API接口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Rest Repositories HAL Browser &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Browsing Spring Data REST repositories in your browser.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.2.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;invalid&quot;&gt;&lt;em&gt;&lt;a href=&quot;https://github.com/mikekelly/hal-browser&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;HAL-browser&lt;/a&gt; &lt;/em&gt;是基于hal+json的media type的API浏览器，Spring Data Rest 提供了集成&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring HATEOAS &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Eases the creation of RESTful APIs that follow the HATEOAS principle when working with Spring / Spring MVC.&lt;/p&gt;
&lt;p&gt;HATEOAS是Hypertext As The Engine Of Application State的缩写。在Richardson Maturity Model中, 它是REST的最高级形态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Web Services &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Facilitates contract-first SOAP development. Allows for the creation of flexible web services using one of the many ways to manipulate XML payloads.&lt;/p&gt;
&lt;p&gt;Spring Web Services旨在促进契约优先的SOAP服务开发，允许使用多种方式之一来操作XML有效负载来创建灵活的Web服务。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Jersey &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Framework for developing RESTful Web Services in Java that provides support for JAX-RS APIs.&lt;/p&gt;
&lt;p&gt;Jersey 这是一个非常优秀的框架，是一个实现了RESTful的webservice框架&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vaadin &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java framework for building rich client apps based on Web components.&lt;/p&gt;
&lt;p&gt;一个用Java构建web应用程序的开放框架&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Template Engines&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Thymeleaf &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A modern server-side Java template engine for both web and standalone environments. Allows HTML to be correctly displayed in browsers and as static prototypes.&lt;/p&gt;
&lt;p&gt;用于web和独立环境的现代服务器端Java模板引擎。允许HTML在浏览器中正确显示，并作为静态原型。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Apache Freemarker &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Java library to generate text output (HTML web pages, e-mails, configuration files, source code, etc.) based on templates and changing data.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Mustache &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Logic-less Templates. There are no if statements, else clauses, or for loops. Instead there are only tags.&lt;/p&gt;
&lt;p&gt;Mustache 是一个轻逻辑的模板语言（ Logic-less templates），mustache 是一个js模板,用于展示和js分离，它的优势在于可以应用在 Javascript、PHP、Python、Perl 等多种编程语言中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Groovy Templates &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Groovy templating engine.&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Security&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring Security &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Highly customizable authentication and access-control framework for Spring applications.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OAuth2 Client &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot integration for Spring Security's OAuth2/OpenID Connect client features.&lt;/p&gt;
&lt;p&gt;Spring Security的OAuth2/OpenID连接客户端特性的Spring Boot集成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OAuth2 Resource Server &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Boot integration for Spring Security's OAuth2 resource server features.&lt;/p&gt;
&lt;p&gt;Spring Security的OAuth2资源服务器特性的Spring引导集成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring LDAP &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Makes it easier to build Spring based applications that use the Lightweight Directory Access Protocol.&lt;/p&gt;
&lt;p&gt;轻量级目录访问协议，LDAP是一个访问协议, LDAP概念和原理介绍(&lt;a href=&quot;https://www.cnblogs.com/wilburxu/p/9174353.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/wilburxu/p/9174353.html&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Okta &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Okta specific configuration for Spring Security/Spring Boot OAuth2 features. Enable your Spring Boot application to work with Okta via OAuth 2.0/OIDC.&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;tran_0&quot; class=&quot;copied&quot; data-aligning=&quot;#tran_0,#src_0&quot;&gt;针对Spring Security/Spring Boot OAuth2特性的Okta特定配置。&lt;span id=&quot;tran_1&quot; class=&quot;copied&quot; data-aligning=&quot;#tran_1,#src_1&quot;&gt;通过OAuth 2.0/OIDC使您的Spring Boot应用程序与Okta一起工作。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;SQL&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;JDBC API &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Database Connectivity API that defines how a client may connect and query a database.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data JPA &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Persist data in SQL stores with Java Persistence API using Spring Data and Hibernate.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data JDBC &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Persist data in SQL stores with plain JDBC using Spring Data.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data R2DBC &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Provides Reactive Relational Database Connectivity to persist data in SQL stores using Spring Data in reactive applications.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MyBatis Framework &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Persistence framework with support for custom SQL, stored procedures and advanced mappings. MyBatis couples objects with stored procedures or SQL statements using a XML descriptor or annotations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Liquibase Migration &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Liquibase database migration and source control library.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Flyway Migration &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Version control for your database so you can migrate from any version (incl. an empty database) to the latest version of the schema.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JOOQ Access Layer &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Generate Java code from your database and build type safe SQL queries through a fluent API.&lt;/p&gt;
&lt;p&gt;jOOQ 可以从数据库生成Java代码，并允许你通过其流利的API构建类型安全的SQL查询。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IBM DB2 Driver &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A JDBC driver that provides access to IBM DB2.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Apache Derby Database &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An open source relational database implemented entirely in Java.&lt;/p&gt;
&lt;p&gt;Apache Derby是一个完全用 java 编写的数据库，Derby是一个Open source的产品。 Apache Derby非常小巧，核心部分derby.jar只有2M，既可以做为单独的数据库服务器使用，也可以内嵌在应用程序中使用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;H2 Database &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Provides a fast in-memory database that supports JDBC API and R2DBC access, with a small (2mb) footprint. Supports embedded and server modes as well as a browser based console application.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HyperSQL Database &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lightweight 100% Java SQL Database Engine.&lt;/p&gt;
&lt;p&gt;HyperSQL是用Java编写的一款SQL关系数据库引擎，它的核心完全是多线程的，支持双向锁和MVCC(多版本并发控制).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MariaDB Driver &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MariaDB JDBC and R2DBC driver.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MS SQL Server Driver &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A JDBC and R2DBC driver that provides access to Microsoft SQL Server and Azure SQL Database from any Java application.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL Driver &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MySQL JDBC and R2DBC driver.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Oracle Driver &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A JDBC driver that provides access to Oracle.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PostgreSQL Driver &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A JDBC and R2DBC driver that allows Java programs to connect to a PostgreSQL database using standard, database independent Java code.&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;NoSQL&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring Data Redis (Access+Driver) &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Advanced and thread-safe Java Redis client for synchronous, asynchronous, and reactive usage. Supports Cluster, Sentinel, Pipelining, Auto-Reconnect, Codecs and much more.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data Reactive Redis &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Access Redis key-value data stores in a reactive fashion with Spring Data Redis.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data MongoDB &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Store data in flexible, JSON-like documents, meaning fields can vary from document to document and data structure can be changed over time.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data Reactive MongoDB &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Provides asynchronous stream processing with non-blocking back pressure for MongoDB.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data Elasticsearch (Access+Driver) &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A distributed, RESTful search and analytics engine with Spring Data Elasticsearch.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data for Apache Solr &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Apache Solr is an open source enterprise search platform built on Apache Lucene.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data for Apache Cassandra &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A free and open-source, distributed, NoSQL database management system that offers high-scalability and high-performance.&lt;/p&gt;
&lt;p&gt;Apache Cassandra 是一个开源的、分布式、无中心、弹性可扩展、高可用、容错、一致性可调、面向行的数据库，它基于 Amazon Dynamo 的分布式设计和 Google Bigtable 的数据模型，由 Facebook 创建，在一些最流行的网站中得到应用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data Reactive for Apache Cassandra &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Access Cassandra NoSQL Database in a reactive fashion.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring for Apache Geode &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Apache Geode is a data management platform that helps users build real-time, highly concurrent, highly performant and reliable Spring Boot applications at scale that is compatible with Pivotal Cloud Cache.&lt;/p&gt;
&lt;p&gt;geode是java生态圈，目的是高性能高可用，除了缓存，更像数据库，可以sql查询，硬盘可能仅在出现灾难时才用，大部分都在内存就处理了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data Couchbase &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NoSQL document-oriented database that offers in memory-first architecture, geo-distributed deployments, and workload isolation.&lt;/p&gt;
&lt;p&gt;Couchbase Server 是个面向文档的数据库（其所用的技术来自于Apache CouchDB项目），能够实现水平伸缩，并且对于数据的读写来说都能提供低延迟的访问（这要归功于Membase技术）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data Reactive Couchbase &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Access Couchbase NoSQL database in a reactive fashion with Spring Data Couchbase.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring Data Neo4j &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An open source NoSQL database that stores data structured as graphs consisting of nodes, connected by relationships.&lt;/p&gt;
&lt;p&gt;Neo4j是一个高性能的,NOSQL图形数据库，它将结构化数据存储在网络上而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎，但是它将结构化数据存储在网络(从数学角度叫做图)上而不是表中。&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Messaging&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring Integration &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Adds support for Enterprise Integration Patterns. Enables lightweight messaging and supports integration with external systems via declarative adapters.&lt;/p&gt;
&lt;p&gt;如果你的系统处在各个系统的中间，需要JMS交互，又需要Database/Redis/MongoDB，还需要监听Tcp/UDP等，还有固定的文件转移，分析。还面对着时不时的更改需求的风险。那么，它再适合不过了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring for RabbitMQ &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Gives your applications a common platform to send and receive messages, and your messages a safe place to live until received.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring for Apache Kafka &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Publish, subscribe, store, and process streams of records.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring for Apache Kafka Streams &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Building stream processing applications with Apache Kafka Streams.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring for Apache ActiveMQ 5 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring JMS support with Apache ActiveMQ 'Classic'.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring for Apache ActiveMQ Artemis &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring JMS support with Apache ActiveMQ Artemis.&lt;/p&gt;
&lt;p&gt;Apache ActiveMQ Artemis 提供了一个非堵塞架构，实现了超高性能的 Java 对象消息服务器。其核心只依赖一个 netty.jar 文件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WebSocket &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Build WebSocket applications with SockJS and STOMP.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RSocket &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;RSocket.io applications with Spring Messaging and Netty.&lt;/p&gt;
&lt;p&gt;RSocket是一个二进制的协议，以异步消息的方式提供4种对等的交互模型，以字节流的方式运行在TCP, WebSockets, Aeron等传输层之上。RSocket专门设计用于与Reactive风格应用配合使用，这些应用程序基本上是非阻塞的，并且通常（但不总是）与异步行为配对。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Apache Camel &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Apache Camel is an open source integration framework that empowers you to quickly and easily integrate various systems consuming or producing data.&lt;/p&gt;
&lt;p&gt;Apache Camel 是一个非常强大的基于规则的路由以及媒介引擎，该引擎提供了一个基于POJO的 企业应用模式(Enterprise Integration Patterns)的实现，你可以采用其异常强大且十分易用的API (可以说是一种Java的领域定义语言 Domain Specific Language)来配置其路由或者中介的规则.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Solace PubSub+ &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Connect to a Solace PubSub+ Advanced Event Broker to publish, subscribe, request/reply and store/replay messages&lt;/p&gt;
&lt;p&gt;一个完整的实时企业事件流和管理平台。PubSub+平台帮助企业设计、部署和管理跨混合云、多云和物联网环境的事件驱动架构(EDAs)，使它们能够更加集成和事件驱动。&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;I/O&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring Batch &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Batch applications with transactions, retry/skip and chunk based processing.&lt;/p&gt;
&lt;p&gt;Spring Batch是一个轻量级，全面的批处理框架，旨在开发对企业系统日常运营至关重要的强大批处理应用程序。1.从数据库，文件或队列中读取大量记录。2.以某种方式处理数据。3.以修改之后的形式写回数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Validation &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Bean Validation with Hibernate validator.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java Mail Sender &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Send email using Java Mail and Spring Framework's JavaMailSender.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Quartz Scheduler &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Schedule jobs using Quartz.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Spring cache abstraction &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Provides cache-related operations, such as the ability to update the content of the cache, but does not provide the actual data store.&lt;/p&gt;
&lt;p&gt;基于注解方式管理缓存，@Cacheable ， @CacheEvict， @CachePut， @Caching， @CacheConfig&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Ops&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring Boot Actuator &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Supports built in (or custom) endpoints that let you monitor and manage your application - such as application health, metrics, sessions, etc.&lt;/p&gt;
&lt;p&gt;SpringBoot自带监控功能Actuator，可以帮助实现对程序内部运行情况监控，比如监控状况、Bean加载情况、环境变量、日志信息、线程信息等&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Codecentric's Spring Boot Admin (Client) &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Required for your application to register with a Codecentric's Spring Boot Admin Server instance.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Codecentric's Spring Boot Admin (Server) &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A community project to manage and monitor your Spring Boot applications. Provides a UI on top of the Spring Boot Actuator endpoints.&lt;/p&gt;
&lt;p&gt;在Spring Boot Actuator的基础上提供简洁的可视化WEB UI，是用来管理 Spring Boot 应用程序的一个简单的界面。&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Observability&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Datadog &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Datadog is a dimensional time-series SAAS with built-in dashboarding and alerting.&lt;/p&gt;
&lt;p&gt;一站式云端性能监控平台。Datadog 是 SaaS 监测工具，针对 DevOps 团队，从你的 app 或者其他各种工具获取数据并提供数据可视化功能。它把从你基础设备和软件采集的数据统一处理并存储。允许你创建仪表盘和搜索访问你提供的数据。他们目前提供数据的聚合和展示而不是提供数据分析。 Datadog 的一个优点是了开放所有 API，可以让你很灵活的开发自己的指标或整合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Influx &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Support real-time stream processing and storage of time-series data.&lt;/p&gt;
&lt;p&gt;InfluxDB 是用Go语言编写的一个开源分布式时序、事件和指标数据库，无需外部依赖。&lt;/p&gt;
&lt;p&gt;InfluxDB是因为物联网而兴起的数据库，其天生具有IOT的特性。几乎所有的物联网数据都可以通过InfluxDB存储，分析与展示。&lt;/p&gt;
&lt;p&gt;InfluxDB的具体使用场景包括：智慧物联网监控分析系统，传统石油化工、采矿以及制造企业设备数据采集与分析，医疗数据采集与分析，车联网，智慧交通等。InfluxDB同时还可以用于日志数据存储与分析，各种服务、软件以及系统监控数据采集、分析与报警，金融数据采集与分析等。&lt;/p&gt;
&lt;p&gt;总之，只要符合写多读少、无事务要求、海量高并发持续写入、基于时间区间聚合分析以及基于时间区间快速查询的数据都可以使用InfluxDB。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Graphite &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hierarchical metrics systems backed by a fixed-size database.&lt;/p&gt;
&lt;p&gt;Graphite是一个开源实时的、显示时间序列度量数据的图形系统。Graphite并不收集度量数据本身，而是像一个数据库，通过其后端接收度量数据，然后以实时方式查询、转换、组合这些度量数据。Graphite支持内建的Web界面，它允许用户浏览度量数据和图。&lt;/p&gt;
&lt;p&gt;Graphite通常用于监控基础设施级别的度量，比如CPU、内存、I/O利用率、网络吞吐量和延迟，当然Graphite在应用程序级的度量和业务级的度量方面也很不错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;New Relic &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SaaS offering with a full UI and a query language called NRQL.&lt;/p&gt;
&lt;p&gt;New Relic 是一个很强大的服务器性能监控工具，New Relic目前专注于SaaS和App性能管理业务，它支持支持agent和API传送数据，能够对部署在本地或在云中的web应用程序进行监控、故障修复、诊断、线程分析以及容量计划。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Prometheus &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;An in-memory dimensional time series database with a simple built-in UI, a custom query language, and math operations.&lt;/p&gt;
&lt;p&gt;prometheus是由谷歌研发的一款开源的监控软件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Wavefront &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Tanzu Observability by Wavefront is a SaaS-based metrics monitoring and analytics platform that lets you visualize, query, and alert over data from across your entire stack (infrastructure, network, custom app metrics, business KPIs, etc.)&lt;/p&gt;
&lt;p&gt;一个基于saas的度量监测和分析平台，它可以让你对整个堆栈(基础设施、网络、定制应用程序度量、业务kpi等)的数据进行可视化、查询和警报。&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Testing&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Spring REST Docs &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Document RESTful services by combining hand-written with Asciidoctor and auto-generated snippets produced with Spring MVC Test.&lt;/p&gt;
&lt;p&gt;spring-rest-docs是一个测试驱动的spring组件，他能生成测试成功的接口进行文档生成，支持markdown的转换或者html的转化，对于文档对接，其实也够了，缺点就是无法像其他工具那样模拟测试数据，前端在对接的时候，可以直接调用模拟数据，尤其对于赶进度的接口，可能是先写接口，再写实现，那么这样的话，就有点不适合。&lt;/p&gt;
&lt;p&gt;但他的强大之处，就是可以自动生成文档，而且是经过测试过的接口，减去一些不必要的撰写工作，相对于Swagger来说，没有任何代码的依赖侵入。所以在实际的spring那套开发框架下，还是建议使用，他确实很不错。如果真的需要用到其他系统化的api管理工具，可以把markdown再导入到管理工具中去，即可。&lt;/p&gt;
&lt;p&gt;Api管理工具（spring-rest-docs）（&lt;a href=&quot;https://www.cnblogs.com/hlkawa/p/Api管理工具（spring-rest-docs）&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qq350760546/p/8397557.html&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Testcontainers &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Provide lightweight, throwaway instances of common databases, Selenium web browsers, or anything else that can run in a Docker container.&lt;/p&gt;
&lt;p&gt;testcontainers Java 提供了几个现成的使用频率较高的容器的类封装，比如大部分数据库(MySQL, Postgres, Cassandra, Neo4j), UI测试的Webdriver，ElasticSearch，Kafka, Nginx等等。如果你没找到现成的封装，你总是可以调用更底层的&lt;code&gt;GenericContainer&lt;/code&gt;。它也支持主流的Java测试框架，JUnit4, JUnit 5, TestNG，Spock。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Contract Verifier &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Moves TDD to the level of software architecture by enabling Consumer Driven Contract (CDC) development.&lt;/p&gt;
&lt;p&gt;通过支持消费者驱动契约(CDC)开发，将TDD移动到软件架构的级别。&lt;/p&gt;
&lt;p&gt;技术干货 | 消费者驱动契约(CDC) 之 SpringCloud Contracts (&lt;a href=&quot;https://www.sohu.com/a/200331844_617676&quot; target=&quot;_blank&quot;&gt;https://www.sohu.com/a/200331844_617676&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Contract Stub Runner &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Stub Runner for HTTP/Messaging based communication. Allows creating WireMock stubs from RestDocs tests.&lt;/p&gt;
&lt;p&gt;用于基于HTTP/消息传递的通信的存根运行程序。允许从RestDocs测试创建WireMock存根。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Embedded LDAP Server &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Provides a platform neutral way for running a LDAP server in unit tests.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Embedded MongoDB Database &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Provides a platform neutral way for running MongoDB in unit tests.&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Spring Cloud&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Cloud Bootstrap &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Non-specific Spring Cloud features, unrelated to external libraries or integrations (e.g. Bootstrap context and @RefreshScope).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Function &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Promotes the implementation of business logic via functions and supports a uniform programming model across serverless providers, as well as the ability to run standalone (locally or in a PaaS).&lt;/p&gt;
&lt;p&gt;Spring Cloud Function 是基于 Spring Boot 的函数计算框架，它抽象出所有传输细节和基础架构，允许开发人员保留所有熟悉的工具和流程，并专注于业务逻辑。&lt;/p&gt;
&lt;p&gt;Spring Cloud Function 有以下高级别的目标：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过函数促进业务逻辑的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;将业务逻辑的开发生命周期与特定运行时分离，以便相同的代码可以作为 Web 端点、流处理器或任务运行。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;支持 Serverless 提供商之间的统一编程模型，以及独立运行（本地或 PaaS）的能力。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在 Serverless 提供商上启用 Spring Boot 功能（自动配置、依赖注入、Metrics）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;Task &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Allows a user to develop and run short lived microservices using Spring Cloud. Run them locally, in the cloud, and on Spring Cloud Data Flow.&lt;/p&gt;
&lt;p&gt;Spring Cloud Task 允许用户使用Spring Cloud 开发和运行一个短生命周期的微服务。它主要就是来解决 short-lived microservices的问题，因为一般的服务都是长时间一直保持运行的，但是有很多服务并不需要一直保持运行；比如一些定时任务或者临时任务。所以Spring Cloud Task可以让你更简单的创建短时运行的微服务。&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Spring Cloud Security&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Cloud Security &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A declarative model which can be heavily configured externally (or centrally) lends itself to the implementation of large systems of co-operating, remote components, usually with a central indentity management service.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cloud OAuth2 &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OAuth2 and distributed application patterns with spring-cloud-security.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Spring Cloud Tools&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Cloud Connectors &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Simplifies the process of connecting to services and gaining operating environment awareness in cloud platforms such as Cloud Foundry and Heroku.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.3.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;invalid&quot;&gt;Spring Cloud Connectors简化了云平台（如Cloud Foundry和Heroku）中连接服务和获取操作环境感知的过程，尤其适用于Spring应用程序。 它是为可扩展性而设计的：您可以使用提供的云连接器之一或为您的云平台编写一个，并且您可以使用内置支持常用服务（关系数据库，MongoDB，Redis，RabbitMQ）或扩展Spring 云连接器可与您自己的服务配合使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Open Service Broker &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Framework for building Spring Boot apps that implement the Open Service Broker API, which can deliver services to applications running within cloud native platforms such as Cloud Foundry, Kubernetes and OpenShift.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;invalid&quot;&gt;Spring Cloud Open Service Broker是一个用于构建实现Open Service Broker API的Spring Boot应用程序的框架。&lt;br/&gt;Open Service Broker API项目允许开发人员为云本地平台（如Cloud Foundry，Kubernetes和OpenShift）中运行的应用程序提供服务。 Spring Cloud Open Service Broker提供了一个基于Spring Boot的框架，使您能够在支持Open Service Broker API的平台上为您自己的托管服务快速创建服务代理。&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Spring Cloud Config&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Config Client &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Client that connects to a Spring Cloud Config Server to fetch the application's configuration.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Config Server &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Central management for configuration via Git, SVN, or HashiCorp Vault.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Vault Configuration &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Provides client-side support for externalized configuration in a distributed system. Using HashiCorp's Vault you have a central place to manage external secret properties for applications across all environments.&lt;/p&gt;
&lt;p&gt;Hashicorp Vault是一个工具，它为开发人员提供了以安全的方式进行安全的存取，比如API 令牌、SSL 证书和口令。它还处理用户的访问控制，具有撤销令牌的能力。除此之外，它还有审计功能，可以用它来跟踪用户。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Apache Zookeeper Configuration &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Enable and configure common patterns inside your application and build large distributed systems with Apache Zookeeper based components. The provided patterns include Service Discovery and Configuration.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Consul Configuration &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Enable and configure the common patterns inside your application and build large distributed systems with Hashicorp’s Consul. The patterns provided include Service Discovery, Distributed Configuration and Control Bus.&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Spring Cloud Discovery&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Eureka Discovery Client &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;a REST based service for locating services for the purpose of load balancing and failover of middle-tier servers.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Eureka Server &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;spring-cloud-netflix Eureka Server.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Apache Zookeeper Discovery &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Service discovery with Apache Zookeeper.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cloud Foundry Discovery &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Service discovery with Cloud Foundry.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Consul Discovery &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Service discovery with Hashicorp Consul.&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Spring Cloud Routing&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Zuul [Maintenance] &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Intelligent and programmable routing with Spring Cloud Netflix Zuul.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Gateway &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Provides a simple, yet effective way to route to APIs and provide cross cutting concerns to them such as security, monitoring/metrics, and resiliency.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Ribbon [Maintenance] &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Client-side load-balancing with Spring Cloud Netflix and Ribbon.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OpenFeign &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Declarative REST Client. OpenFeign creates a dynamic implementation of an interface decorated with JAX-RS or Spring MVC annotations.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cloud LoadBalancer &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Client-side load-balancing with Spring Cloud LoadBalancer.&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Spring Cloud Circuit Breaker&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Resilience4J &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Cloud Circuit breaker with Resilience4j as the underlying implementation.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hystrix [Maintenance] &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Circuit breaker with Spring Cloud Netflix Hystrix.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Hystrix Dashboard [Maintenance] &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Circuit breaker dashboard with Spring Cloud Netflix Hystrix.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Turbine [Maintenance] &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Circuit breaker metric aggregation using spring-cloud-netflix with Turbine and server-sent events.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Turbine Stream [Maintenance] &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Circuit breaker metric aggregation using spring-cloud-netflix with Turbine and Spring Cloud Stream (requires a binder, e.g. Apache Kafka or RabbitMQ).&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Spring Cloud Tracing&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Sleuth &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Distributed tracing via logs with Spring Cloud Sleuth.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Zipkin Client &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Distributed tracing with an existing Zipkin installation and Spring Cloud Sleuth Zipkin.&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Spring Cloud Messaging&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Cloud Bus &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Links nodes of a distributed system with a lightweight message broker which can used to broadcast state changes or other management instructions (requires a binder, e.g. Apache Kafka or RabbitMQ).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cloud Stream &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Framework for building highly scalable event-driven microservices connected with shared messaging systems (requires a binder, e.g. Apache Kafka, RabbitMQ or Solace PubSub+).&lt;/p&gt;
&lt;p&gt;构建高度可扩展的事件驱动微服务的框架，连接到共享的消息传递系统(需要绑定器，例如Apache Kafka, RabbitMQ或Solace PubSub+)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reactive Cloud Stream &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Reactive messaging microservices with Spring Cloud Stream (requires a binder, e.g. Apache Kafka or RabbitMQ).&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.2.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Pivotal Cloud Foundry&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Config Client (PCF) &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Config client on Pivotal Cloud Foundry.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Service Registry (PCF) &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Eureka service discovery client on Pivotal Cloud Foundry.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Circuit Breaker (PCF) &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Hystrix circuit breaker client on Pivotal Cloud Foundry.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Amazon Web Services&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;AWS Core &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;AWS native services from Spring Cloud for AWS.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AWS RDS &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Relational databases on AWS with RDS and Spring Cloud AWS JDBC.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;AWS Simple Queue Service &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Messaging on AWS with SQS and Spring Cloud AWS Messaging.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Microsoft Azure&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Azure Support &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Auto-configuration for Azure Services (Service Bus, Storage, Active Directory, Cosmos DB, Key Vault, and more).&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Azure Active Directory &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Spring Security integration with Azure Active Directory for authentication.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Azure Key Vault &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Manage application secrets and keys.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.4.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Azure Storage &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Azure Storage service integration.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.0.0.RELEASE and &amp;lt; 2.3.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Google Cloud Platform&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GCP Support &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Contains auto-configuration support for every Spring Cloud GCP integration. Most of the auto-configuration code is only enabled if other dependencies are added to the classpath.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GCP Messaging &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Adds the GCP Support entry and all the required dependencies so that the Google Cloud Pub/Sub integration work out of the box.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;GCP Storage &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Adds the GCP Support entry and all the required dependencies so that the Google Cloud Storage integration work out of the box.&lt;/p&gt;
&lt;h2 class=&quot;group-title&quot;&gt;Alibaba&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Nacos Configuration &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Support for externalized configuration in a distributed system, auto refresh when configuration changes.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.2.0.RELEASE and &amp;lt; 2.3.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Nacos Service Discovery &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Service discovery with Alibaba Nacos.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.2.0.RELEASE and &amp;lt; 2.3.0.M1.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sentinel &lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Flow control and circuit breaking with Alibaba Sentinel.&lt;span class=&quot;invalid&quot;&gt;Requires Spring Boot &amp;gt;= 2.2.0.RELEASE and &amp;lt; 2.3.0.M1.&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 05 Jan 2021 22:36:00 +0000</pubDate>
<dc:creator>Brian_Huang</dc:creator>
<og:description>下面所有SpringBoot组件整理来自于：https://start.spring.io/，紧随Spring社区的步伐...... Developer Tools Spring Boot DevTo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hlkawa/p/14223054.html</dc:identifier>
</item>
<item>
<title>FFT原理及C++与MATLAB混合编程详细介绍 - 羽扇纶巾o0</title>
<link>http://www.cnblogs.com/gjblog/p/14227295.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gjblog/p/14227295.html</guid>
<description>&lt;p&gt;首先讨论了快速傅里叶变换的原理，包括具体运算步骤的蝶形图，给出了C++实现代码。然后介绍了MATLAB与C++混合编程的详细步骤，包括mex接口定义等，最后实现了MATLAB调用C++进行FFT/IFFT变换，并将结果返回MATLAB&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;280&quot;&gt;
&lt;h2 id=&quot;一：fft原理&quot;&gt;一：FFT原理&lt;/h2&gt;
&lt;h3 id=&quot;11-dft计算&quot;&gt;1.1 DFT计算&lt;/h3&gt;
&lt;p&gt;在一个周期内的离散傅里叶级数(DFS)变换定义为离散傅里叶变换(DFT)。&lt;/p&gt;
&lt;p&gt;\[\begin{cases} X(k) = \sum_{n=0}^{N-1}x(n)W_N^{kn}, &amp;amp; 0 \le k \le {N-1} \\ x(n) = \frac{1}{N} \sum_{k=0}^{N-1}X(k)W_N^{-kn}, &amp;amp; 0 \le n \le {N-1} \\ \end{cases} \]&lt;/p&gt;
&lt;p&gt;其中，&lt;span class=&quot;math inline&quot;&gt;\(W_N = e^{-j\frac{2\pi}{N}}\)&lt;/span&gt;。&lt;span class=&quot;math inline&quot;&gt;\(X(k)\)&lt;/span&gt;是&lt;span class=&quot;math inline&quot;&gt;\(x(n)\)&lt;/span&gt;的离散傅里叶变换。&lt;/p&gt;
&lt;p&gt;用矩阵方程可以更加清楚的看出DFT的变换过程：&lt;/p&gt;
&lt;p&gt;\[X = W \cdot x \tag{1} \]&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(X = \begin{pmatrix} X(0) \\ X(1) \\ x(2) \\ \vdots \\ X(N-1) \\ \end{pmatrix}\)&lt;/span&gt;；&lt;span class=&quot;math inline&quot;&gt;\(W = \begin{pmatrix} 1 &amp;amp; 1 &amp;amp; 1 &amp;amp; \cdots &amp;amp; 1 \\ 1 &amp;amp; W_N^1 &amp;amp; W_N^2 &amp;amp; \cdots &amp;amp; W_N^{N-1} \\ 1 &amp;amp; W_N^2 &amp;amp; W_N^4 &amp;amp; \cdots &amp;amp; W_N^{2(N-1)} \\ \vdots &amp;amp; \vdots &amp;amp; \vdots &amp;amp; \ddots &amp;amp; \vdots \\ 1 &amp;amp; W_N^{N-1} &amp;amp; W_N^{2(N-1)} &amp;amp; \cdots &amp;amp; W_N^{(N-1)(N-1)} \\ \end{pmatrix}\)&lt;/span&gt;；&lt;span class=&quot;math inline&quot;&gt;\(x = \begin{pmatrix} x(0) \\ x(1) \\ x(2) \\ \vdots \\ x(N-1) \\ \end{pmatrix}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;可以看出，长度为&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;的有限长序列&lt;span class=&quot;math inline&quot;&gt;\(x(n)\)&lt;/span&gt;，其离散傅里叶变换&lt;span class=&quot;math inline&quot;&gt;\(X(k)\)&lt;/span&gt;仍是一个长度为&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;的有限长序列。由(1)可看出时间复杂度为&lt;span class=&quot;math inline&quot;&gt;\(O(N^2)\)&lt;/span&gt;，如果&lt;span class=&quot;math inline&quot;&gt;\(N = 1024\)&lt;/span&gt;点的话，需要1048576(一百多万)次复数乘法。DFT的计算量实在是太大了，于是有了后面的优化版本：快速傅里叶变换(FFT)。&lt;/p&gt;
&lt;h3 id=&quot;12-fft计算&quot;&gt;1.2 FFT计算&lt;/h3&gt;
&lt;h4 id=&quot;121-性质铺垫&quot;&gt;1.2.1 性质铺垫&lt;/h4&gt;
&lt;p&gt;由于系数&lt;span class=&quot;math inline&quot;&gt;\(W_N^{nk} = e^{-j\frac{2\pi}{N}nk}\)&lt;/span&gt;是一个周期函数，可以用它的性质来改进算法，提高计算效率。&lt;/p&gt;
&lt;p&gt;这里主要利用以上两个性质，把长度为N点的大点数的DFT运算依次分解为若干个小点数的DFT。因为DFT的计算量正比于&lt;span class=&quot;math inline&quot;&gt;\(N^2\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;小计算量也小。&lt;/p&gt;
&lt;h4 id=&quot;122-按时间抽取的基2fftn点&quot;&gt;1.2.2 按时间抽取的基2FFT(N点)&lt;/h4&gt;
&lt;p&gt;假设进行FFT的点数N是2的整次方(基2)，首先将序列分为两组，一组为偶数项，一组为奇数项，然后进行如下的变换，推导如下：&lt;/p&gt;
&lt;p&gt;\[\begin{align} X(k) &amp;amp;= \sum_{n=0}^{N-1}x(n)W_N^{nk} \notag\\ &amp;amp;= \sum_{n=0为偶数}^{N-2}x(n)W_{N}^{nk} + \sum_{n=1为奇数}^{N-2}x(n)W_{N}^{nk} \notag\\ &amp;amp;= \sum_{r=0}^{\frac{N}{2}-1}x(2r)W_{N}^{2rk} + \sum_{r=0}^{\frac{N}{2}-1}x(2r+1)W_{N}^{(2r+1)k} \notag\\ &amp;amp;= \sum_{r=0}^{\frac{N}{2}-1}x(2r)W_{N}^{2rk} + W_N^k \sum_{r=0}^{\frac{N}{2}-1}x(2r+1)W_{N}^{2rk} （由性质二\downarrow）\notag\\ &amp;amp;= \sum_{r=0}^{\frac{N}{2}-1}x(2r)W_{\frac{N}{2}}^{rk} + W_N^k \sum_{r=0}^{\frac{N}{2}-1}x(2r+1)W_{\frac{N}{2}}^{rk} ，0 \le k \le \frac{N}{2} - 1 \tag{2} \end{align} \]&lt;/p&gt;
&lt;p&gt;可以看出求&lt;span class=&quot;math inline&quot;&gt;\(x(n)\)&lt;/span&gt;的DFT变成了求其偶数项的DFT和奇数项的DFT的组合，但注意这只计算出了前一半的DFT值，后一半由如下性质得到：&lt;/p&gt;
&lt;p&gt;由性质一&lt;span class=&quot;math inline&quot;&gt;\(\downarrow\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;\[X(k + \frac{N}{2}) = \sum_{r=0}^{\frac{N}{2}-1}x(2r)W_{\frac{N}{2}}^{rk} - W_N^k \sum_{r=0}^{\frac{N}{2}-1}x(2r+1)W_{\frac{N}{2}}^{rk} ，0 \le k \le \frac{N}{2} - 1 \tag{3} \]&lt;/p&gt;
&lt;p&gt;这样一来，我们就计算出了完整的&lt;span class=&quot;math inline&quot;&gt;\(x(n)\)&lt;/span&gt;的DFT值，其实这就是FFT的核心思想了，接下来我们用蝶形图让上面的计算步骤更直观形象一些。&lt;/p&gt;
&lt;h3 id=&quot;13-蝶形信号流图&quot;&gt;1.3 蝶形信号流图&lt;/h3&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048856/202101/2048856-20210106001240950-303526290.png&quot; width=&quot;620&quot; height=&quot;180&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;p&gt;用&lt;span class=&quot;math inline&quot;&gt;\(G(k)\)&lt;/span&gt;代替偶数项DFT，用&lt;span class=&quot;math inline&quot;&gt;\(H(k)\)&lt;/span&gt;代替奇数项DFT，则整理公式(2)、(3)为：&lt;/p&gt;
&lt;p&gt;\[\begin{cases} X(k) = G(k) + W_N^k H(k)，&amp;amp; 0 \le k \le \frac{N}{2} - 1\\ X(k + \frac{N}{2}) = G(k) - W_N^k H(k), &amp;amp; 0 \le k \le \frac{N}{2} - 1 \tag{4} \\ \end{cases} \]&lt;/p&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;p&gt;\[\begin{cases} G(k) = \sum_{r=0}^{\frac{N}{2}-1}x(2r)W_{\frac{N}{2}}^{rk}\\ H(k) = \sum_{r=0}^{\frac{N}{2}-1}x(2r+1)W_{\frac{N}{2}}^{rk} \tag{5} \\ \end{cases} \]&lt;/p&gt;
&lt;p&gt;从（4）和（5）可以看出，我们可以把一串时域数据分成偶数部分和奇数部分来计算&lt;span class=&quot;math inline&quot;&gt;\(G(K)\)&lt;/span&gt;和&lt;span class=&quot;math inline&quot;&gt;\(H(k)\)&lt;/span&gt;，同样也可以再把偶数部分再分成偶数部分和奇数部分计算，直到分到最后只剩下两个数据，再递归计算出FFT结果，具体直观点的流程见下面经典的N点蝶形图：&lt;/p&gt;
&lt;img src=&quot;https://img2020.cnblogs.com/blog/2048856/202101/2048856-20210106001250851-784700173.png&quot; width=&quot;680&quot; height=&quot;720&quot; alt=&quot;&quot; align=&quot;center&quot;/&gt;&lt;hr/&gt;&lt;h2 id=&quot;二：fft的c实现&quot;&gt;二：FFT的C++实现&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;#include &amp;lt;iostream&amp;gt; // fft算法实现，基2时间抽取
#include &amp;lt;vector&amp;gt;
#include &amp;lt;ctime&amp;gt;
using namespace std;

const double PI = acos(-1); // pi值

struct Cpx // 定义一个复数结构体和复数运算法则
{
        double r, i;
        Cpx() : r(0), i(0) {}
        Cpx(double _r, double _i) : r(_r), i(_i) {}
};
Cpx operator + (Cpx a, Cpx b) { return Cpx(a.r + b.r, a.i + b.i); }
Cpx operator - (Cpx a, Cpx b) { return Cpx(a.r - b.r, a.i - b.i); }
Cpx operator * (Cpx a, Cpx b) { return Cpx(a.r * b.r - a.i * b.i, a.r * b.i + a.i * b.r); }

void fft(vector&amp;lt;Cpx&amp;gt;&amp;amp; a, int lim, int opt)
{
        if (lim == 1) return; 
        vector&amp;lt;Cpx&amp;gt; a0(lim &amp;gt;&amp;gt; 1), a1(lim &amp;gt;&amp;gt; 1); // 初始化一半大小，存放偶数和奇数部分
        for (int i = 0; i &amp;lt; lim; i += 2)
                a0[i &amp;gt;&amp;gt; 1] = a[i], a1[i &amp;gt;&amp;gt; 1] = a[i + 1]; // 分成偶数部分和奇数部分

        fft(a0, lim &amp;gt;&amp;gt; 1, opt); // 递归计算偶数部分
        fft(a1, lim &amp;gt;&amp;gt; 1, opt); // 递归计算偶数部分

        Cpx wn(cos(2 * PI / lim), opt * -sin(2 * PI / lim)); //等于WN
        Cpx w(1, 0);
        for (int k = 0; k &amp;lt; (lim &amp;gt;&amp;gt; 1); k++) // 见蝶形图1运算过程
        {
                a[k] = a0[k] + w * a1[k];
                a[k + (lim &amp;gt;&amp;gt; 1)] = a0[k] - w * a1[k];
                w = w * wn;
        }

        //for (int k = 0; k &amp;lt; (lim &amp;gt;&amp;gt; 1); k++) // 见蝶形图2，小优化一下，少一次乘法
        //{
        //      Cpx t = w * a1[k];
        //      a[k] = a0[k] + t;
        //      a[k + (lim &amp;gt;&amp;gt; 1)] = a0[k] - t;
        //      w = w * wn;
        //}

}

int main()
{
        int opt = 1; // 1为FFT，-1为IFFT
        vector&amp;lt;Cpx&amp;gt; a(16); // 这里固定为16点，可以改变
        for (int i = 0; i &amp;lt; 16; i++) // 随机生成16个数作为待处理的数据
        {
                Cpx c = Cpx(cos(0.2 * PI * i), 0);
                a[i] = c;
        }

        if (1 == opt)
                fft(a, 16, opt); // a数组成为FFT过后的值
        else if (-1 == opt)
        {
                fft(a, 16, opt); // a数组成为IFFT过后的值
                for (int i = 0; i &amp;lt; 512; i++) a[i].r /= 512, a[i].i /= -512;// IFFT要除以长度
        }
        else;

        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;h2 id=&quot;三：matlab与c混合编程&quot;&gt;三：MATLAB与C++混合编程&lt;/h2&gt;
&lt;p&gt;在工程上有的时候为了使数据处理更快或者支持某些定点运算，而选择将某些处理步骤用C/C++来处理，其实一般工程用MATLAB处理速度已经足够了，混合编程也全当是复习一下C++吧。&lt;/p&gt;
&lt;p&gt;MATLAB与C++混合编程分为MATLAB中调用C++和C++中调用MATLAB，这里我们讨论的是前者。MATLAB与C++混合编程不是简单的把两种语言写在一起就行，而是需要遵循一种接口规范，具体在3.2中讨论。&lt;/p&gt;
&lt;h3 id=&quot;31-混合编程步骤&quot;&gt;3.1 混合编程步骤&lt;/h3&gt;
&lt;p&gt;从MATLAB的编译器配置到最后程序跳转到VS中打断点调试，在整个混合编程的过程中遇到了不少的困难，网上能找的资料多但是也杂乱，这里总结一下我从开始到最后所做的步骤。&lt;/p&gt;
&lt;p&gt;① 我是用的是MATLAB2019b和VS2019，之前用的MATLAB2016，然后下载什么2019支持文件，修改注册表等等搞了很久也没弄好，索性直接换MATLAB2019b。&lt;/p&gt;
&lt;p&gt;② MATLAB中运行mex -setup C++与mbuild -setup C++，如果不成功那就是当前版本的MATLAB不支持当前版本的Visual Studio，建议把MATLAB版本升高。不建议把VS的版本降低，会有兼容问题。&lt;/p&gt;
&lt;p&gt;③ 不需要创建工程，直接创建一个xx.cpp文件按照mex接口定义写一个C++程序（具体程序之后讨论）。之前创建工程捣鼓了很久VS里面的配置问题，比如链接extern库等等，但感觉最后也并不需要创建工程，所以并不需要配置这些外部链接库？直接写xx.cpp文件就好了？（我也不太确定，也可能有用）&lt;/p&gt;
&lt;p&gt;④ 程序写好之后在MATLAB中运行mex -g xx.cpp，如果xx.cpp程序写的符合规范的话，就会mex成功，生成xx.mexw64和xx.pdb文件；如果mex失败的话根据MATLAB返回的警告去修改代码。注意为了之后能进入到VS2019里断点调试，要加-g。&lt;/p&gt;
&lt;p&gt;⑤ 在MATLAB脚本中写相应的测试程序，设置断点运行停在xx()函数处。&lt;/p&gt;
&lt;p&gt;⑥ 用VS2019打开xx.cpp文件，在‘调试’一栏找到‘添加到进程’，进去 选择‘本机’，然后把MATLAB添加到进程。在你想停的地方设置断点。&lt;/p&gt;
&lt;p&gt;⑦ MATLAB继续运行，则进入到VS2019中的相应断点处。（最后两步有可能进不去，其实我也是有时候能进去有时候不能，暂时也没有什么好的解决办法）&lt;/p&gt;
&lt;h3 id=&quot;32-接口使用&quot;&gt;3.2 接口使用&lt;/h3&gt;
&lt;p&gt;mex文件是MATLAB中.m文件与VS中.cpp文件的桥梁，mex接口好坏关系到我们的MATLAB数据能不能正确地在C++程序中运行。&lt;/p&gt;
&lt;p&gt;其中最重要的头文件和接口主函数如下，写法是固定的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#include &quot;mex.h&quot;

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;int nrhs：输入参数的个数&lt;/p&gt;
&lt;p&gt;mxArray *prhs[]:输入参数的指针数组&lt;/p&gt;
&lt;p&gt;int nlhs：输出参数的个数&lt;/p&gt;
&lt;p&gt;const mxArray *plhs[]：输出参数的指针数组&lt;/p&gt;
&lt;p&gt;注意输入和输出都是以指针的形式传输的，可以理解成MATLAB把它的参数放到了某个地址处，然后C++中根据这个参数的长度去相应地址处读取相应长度的数据，就完成了参数的传递过程。相反最后再传递回去。&lt;br/&gt;下面总结几个常用的mex函数：&lt;/p&gt;
&lt;p&gt;读取参数时会用到的函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 复数单值读取
double Nr1 = *mxGetPr(prhs[0]); // 读取第一个参数的实部
double Ni2 = *mxGetPr(prhs[1]); // 读取第二个参数的虚部
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 地址读取
double* Pr1 = mxGetPr(prhs[0]); // 读取第一个参数的实部地址
double* Pi2 = mxGetPi(prhs[0]); // 读取第一个参数的虚部地址
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;// 矩阵维度读取
int M = mxGetM(prhs[2]); // 读取第三个参数的行数
int N = mxGetN(prhs[2]); // 读取第三个参数的列数
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;待补充&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;输出参数时会用到的函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 输出复矩阵 
plhs[0] = mxCreateDoubleMatrix(M, N, mxCOMPLEX); // 创建M*N的复矩阵
double* outPr = mxGetPr(plhs[0]);
double* outPi = mxGetPi(plhs[0]);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;待补充&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;33-fft的matlabc混合实现&quot;&gt;3.3 FFT的MATLAB/C++混合实现&lt;/h3&gt;
&lt;p&gt;先将第二章中FFT的代码用mex接口改写成如下形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# include &quot;mex.h&quot;
# include &amp;lt;vector&amp;gt;
# include &amp;lt;ctime&amp;gt;

const double PI = acos(-1); // pi

struct Cpx // 定义一个复数结构体和复数运算法则
{
        double r, i;
        Cpx() : r(0), i(0) {}
        Cpx(double _r, double _i) : r(_r), i(_i) {}
};
Cpx operator + (Cpx a, Cpx b) { return Cpx(a.r + b.r, a.i + b.i); }
Cpx operator - (Cpx a, Cpx b) { return Cpx(a.r - b.r, a.i - b.i); }
Cpx operator * (Cpx a, Cpx b) { return Cpx(a.r * b.r - a.i * b.i, a.r * b.i + a.i * b.r); }

void fft(std::vector&amp;lt;Cpx&amp;gt;&amp;amp; a, int lim, int opt)
{
        if (lim == 1) return;
        std::vector&amp;lt;Cpx&amp;gt; a0(lim &amp;gt;&amp;gt; 1), a1(lim &amp;gt;&amp;gt; 1);
        for (int i = 0; i &amp;lt; lim; i += 2)
                a0[i &amp;gt;&amp;gt; 1] = a[i], a1[i &amp;gt;&amp;gt; 1] = a[i + 1]; // 分成偶数部分和奇数部分

        fft(a0, lim &amp;gt;&amp;gt; 1, opt);
        fft(a1, lim &amp;gt;&amp;gt; 1, opt);

        Cpx wn(cos(2 * PI / lim), opt * -sin(2 * PI / lim));
        Cpx w(1, 0);
        for (int k = 0; k &amp;lt; (lim &amp;gt;&amp;gt; 1); k++) // 蝶形运算过程
        {
                a[k] = a0[k] + w * a1[k];
                a[k + (lim &amp;gt;&amp;gt; 1)] = a0[k] - w * a1[k];
                w = w * wn;
        }
}

void mexFunction(int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[]) // mex主函数
{
        int M = mxGetM(prhs[0]); // 输入矩阵行数
        int N = mxGetN(prhs[0]); // 输入矩阵列数
        double* xpr = mxGetPr(prhs[0]); // 输入矩阵实部指针
        double* xpi = mxGetPi(prhs[0]); // 输入矩阵虚部指针
        int lim = *mxGetPr(prhs[1]); // 输入参数，长度，这里输入的为行向量，所以lim = N，M = 1
        int opt = *mxGetPr(prhs[2]); // 输入参数，选择， 1为FFT，-1为IFFT

        plhs[0] = mxCreateDoubleMatrix(M, N, mxCOMPLEX); // 输出矩阵创建（重要）
        double* ypr = mxGetPr(plhs[0]); // 输出矩阵实部指针
        double* ypi = mxGetPi(plhs[0]); // 输出矩阵虚部指针


        std::vector&amp;lt;Cpx&amp;gt; a(lim); // 用vector存储数据
        for (int i = 0; i &amp;lt; lim; i++) // 输入向量传入
        {
                a[i].r = xpr[i];
                a[i].i = xpi[i];
        }

        if (1 == opt)
                fft(a, lim, opt); // a数组变为FFT过后的值
        else if (-1 == opt)
        {
                fft(a, lim, opt); // a数组变为IFFT过后的值
                for (int i = 0; i &amp;lt; lim; i++) a[i].r /= lim, a[i].i /= lim;// IFFT要除以长度
        }
        else;
         
        for (int i = 0; i &amp;lt; lim; i++) // 输出向量传出
        {
                ypr[i] = a[i].r;
                ypi[i] = a[i].i;
        }

        return;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再在MATLAB脚本中写如下程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;clear all
mex fftxx.cpp -g
a = randn(1, 16) + 1i * randn(1, 16); % 随机生成16个复数数据
fftsize = 16;
b = fftxx(a, fftsize, 1)   % 传入C++中进行FFT处理
b1 = fft(a,fftsize)         % MATLAB系统函数进行FFT处理

c = fftxx(b, fftsize, -1)  % 传入C++中进行IFFT处理
c1 = ifft(b, fftsize)       % MATLAB系统函数进行IFFT处理

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后运行该.m程序，在MATLAB命令行窗口中可以看到b和b1，c和c1输出结果完全一致。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 05 Jan 2021 16:43:00 +0000</pubDate>
<dc:creator>羽扇纶巾o0</dc:creator>
<og:description>首先讨论了快速傅里叶变换的原理，包括具体运算步骤的蝶形图，给出了C++实现代码。然后介绍了MATLAB与C++混合编程的详细步骤，包括mex接口定义等，最后实现了MATLAB调用C++进行FFT/IF</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/gjblog/p/14227295.html</dc:identifier>
</item>
<item>
<title>如何写出一篇博客 - 溪源More</title>
<link>http://www.cnblogs.com/xiyuanMore/p/14238747.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiyuanMore/p/14238747.html</guid>
<description>&lt;h4 id=&quot;引子&quot;&gt;引子&lt;/h4&gt;
&lt;p&gt;众所周知，写博客是一种入门门槛低，疗效好，还能带来长期影响力的过程。几乎每一位爱上写博客的开发者总是乐于向其他人分享写博客的乐趣和益处，但即便如此，身边的人还是很难体会到写博客的好处。&lt;/p&gt;
&lt;p&gt;哪怕有时有的公司付费鼓励员工通过知识库的形式分享平时自己遇到的问题和解决问题时的思考，也鲜有员工薅到这样的羊毛，这确实是一件令人费解的事情。会不会是由于同事们不差钱呢？显然并非如此，每个月从200元到500元不等的奖金，每年累计下来也要大几千，估计很少有人能够克制这样的诱惑。&lt;/p&gt;
&lt;p&gt;其实也许是因为存在一种心理障碍。年轻的开发者们还没有完成心路历程的转变，没有深刻的体会到写博客其实不是写作文，它不需要灵感，也不需要写出太高大上的文字，他的门槛其实是如此之低，与其说是知识输出，倒不如说是更像是软文或应用文。有时，你无需花太多的时间，只需按照一些简单的套路，其实就能踏上这条贼船。隔行如隔山，信息不对称的危害可见一斑。&lt;/p&gt;
&lt;p&gt;写博客的套路就是：提出一个问题，分析问题，解决问题，记下来。&lt;/p&gt;
&lt;p&gt;啥华丽的辞藻，啥专业的解读，啥深度剖析，这些都不重要，这些都是循序渐进的过程。经典的小说千千万，经典的博客却少之又少。作为菜鸟的我们，又何必追求写出那么经典的博客呢？&lt;/p&gt;
&lt;p&gt;为了让读者能够更加切实的体会这个观点，本文就是这样的示例代码（本文虽然是一篇博客，同样像一篇应用文，前面铺垫大家都可以理解为废话。&lt;/p&gt;
&lt;h4 id=&quot;1、提出问题&quot;&gt;1、提出问题&lt;/h4&gt;
&lt;p&gt;在软件开发过程中，我们经常会遇到各种各样的问题，有的看起来毫不起眼，但也让人发人深思，有的问题则看起来就很复杂，但解决之道却如此简单。&lt;/p&gt;
&lt;p&gt;所以，如何提出你发现的问题，就是写博客的第一步。&lt;/p&gt;
&lt;p&gt;举一个很简单的例子： Thread.Sleep方法，好像参数只需一个整型数，就能享受让主线程阻塞的优雅性能。（阻塞线程显然不能带来性能快感，但有时吧。。）但你想过没，这个Thread.Sleep的最小值，居然不是0，而是-1，这是为啥呢？&lt;/p&gt;
&lt;p&gt;如果你发现了这个问题，并提出这个质疑，也许一篇优秀的文章就在等着你。（当然，就.NET而言，微软官方已经围绕这个问题进行了解释）。&lt;/p&gt;
&lt;p&gt;当然，这样的例子非常常见，我们也可以从http协议开始理解，这种无处不在的协议，究竟是如何运作的？这也是一个很不错的问题。&lt;/p&gt;
&lt;h4 id=&quot;2、分析问题&quot;&gt;2、分析问题&lt;/h4&gt;
&lt;p&gt;透过问题的表象，看看问题本质的东西，这本身也许需要积累，有时也需要一些机遇。但在我们初涉博客时，只需多从几个角度剖析问题，借助一些知识整理，也许就能看到之前从未涉及的视角。&lt;/p&gt;
&lt;p&gt;有时，我们也不必纠结写博客质量太低，担心被人称作南郭先生，其实大部分友好的技术社区大部分正常的读者，对持续坚持写博客的博主总是比较友好的。多关注于技术和作品本身，反而有助于我们屏蔽外界干扰，并从钻研技术的过程中获得更多乐趣。&lt;/p&gt;
&lt;h4 id=&quot;3、尝试解决问题&quot;&gt;3、尝试解决问题&lt;/h4&gt;
&lt;p&gt;依托互联网媒介，寻找问题的解决办法，并将解决问题的过程客观真实的描述下来。有时也许只需一行代码，或一个流程图，就能给读者解决很多问题。&lt;/p&gt;
&lt;h4 id=&quot;4、稍微修饰一下&quot;&gt;4、稍微修饰一下&lt;/h4&gt;
&lt;p&gt;当然，如果你能再写完博客后，花一点点时间对内容进行一些修饰，自然而然就会获得更多的读者了。&lt;/p&gt;
&lt;p&gt;1、加强文章的排版，注意字体大小的错落，注意换行等。在手机上阅读大段大段的文字着实不便，如果我们能控制每段的文字数大概在100字左右，也许读者会轻松许多。&lt;/p&gt;
&lt;p&gt;2、去掉那些过于华丽的辞藻。作为一篇技术博客，辞藻华丽不仅仅没有优点，反而会让读者远离。。&lt;/p&gt;
&lt;p&gt;3、注意引文的实时性。考虑到技术博客本身刷新的频率特别高，如果你能基于最新的知识体系进行写作，自然而然也会让更多开发人员从中获益。&lt;/p&gt;
&lt;p&gt;4、适当的留下伏笔。虽然一篇文章力求解决一个问题，但如何能够为下一篇文章介绍的内容埋下伏笔，也能让你的博客获得更多吸引力。&lt;/p&gt;
&lt;h4 id=&quot;5、多坚持一下&quot;&gt;5、多坚持一下&lt;/h4&gt;
&lt;p&gt;对大多数人而言，技术写作是一件令人困惑的事情，俯拾即是的技术问题，难免都会让人产生动笔的冲动，但自我怀疑和混乱迷思，却打破了我们的思考节奏，让我们最终没能迈出这一步。我们也可能会在文思泉涌和下笔如枯之间摇摆，有时搜出一些边边角角的话题，然后写出了一篇越写越没劲的话题。但也许，我们的工匠精神也正是在这样的每一瞬间慢慢积累，并让我们最终获益。&lt;/p&gt;
&lt;p&gt;抛弃幻想，放下自我，让博客能够更好的成为我们成长的利器，投入更多的坚持到我们真正需要关注的东西本身--技术上，确实会让我们获益匪浅。&lt;/p&gt;
&lt;p&gt;在追求互联网速度、被各种应用干掉了大部分碎片时间的我们可能很难抽出写一篇博客的时间，但我们可以尝试一周输出一篇1500字的博客。每天花15分钟稍微写一点点，再周末花一点点时间打磨一下，也许一篇质量还不错的博客就形成了。&lt;/p&gt;
&lt;p&gt;如果我们能坚持下去，一切都将大不一样。&lt;/p&gt;
</description>
<pubDate>Tue, 05 Jan 2021 15:59:00 +0000</pubDate>
<dc:creator>溪源More</dc:creator>
<og:description>引子 众所周知，写博客是一种入门门槛低，疗效好，还能带来长期影响力的过程。几乎每一位爱上写博客的开发者总是乐于向其他人分享写博客的乐趣和益处，但即便如此，身边的人还是很难体会到写博客的好处。 哪怕有时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiyuanMore/p/14238747.html</dc:identifier>
</item>
<item>
<title>单细胞分析实录(5): Seurat标准流程 - TOP生物信息</title>
<link>http://www.cnblogs.com/TOP-Bio/p/14238723.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/TOP-Bio/p/14238723.html</guid>
<description>&lt;p&gt;前面我们已经学习了单细胞转录组分析的：&lt;a href=&quot;https://www.jianshu.com/p/5ace1c5b18b7&quot; target=&quot;_blank&quot;&gt;使用Cell Ranger得到表达矩阵&lt;/a&gt;和&lt;a href=&quot;https://www.jianshu.com/p/64976eb6725d&quot; target=&quot;_blank&quot;&gt;doublet检测&lt;/a&gt;，今天我们开始Seurat标准流程的学习。这一部分的内容，网上有很多帖子，基本上都是把&lt;a href=&quot;https://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html&quot; target=&quot;_blank&quot;&gt;Seurat官网PBMC的例子&lt;/a&gt;重复一遍，这回我换一个数据集，细胞类型更多，同时也会加入一些实际分析中很有用的技巧。&lt;/p&gt;
&lt;h3 id=&quot;1-导入数据，创建seurat对象&quot;&gt;1. 导入数据，创建Seurat对象&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;library(Seurat)
library(tidyverse)
testdf=read.table(&quot;test_20210105.txt&quot;,header = T,row.names = 1)
test.seu=CreateSeuratObject(counts = testdf)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下长什么样子&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; test.seu
An object of class Seurat 
33538 features across 6746 samples within 1 assay 
Active assay: RNA (33538 features)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试数据有33538个基因，6746个细胞。除此之外，还要关注一下另外两层信息：test.seu@meta.data这个数据框用来存储元数据，每一个细胞都有多个属性；test.seu[[&quot;RNA&quot;]]@counts这个稀疏矩阵用来存储原始UMI表达矩阵。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; head(test.seu@meta.data)
                   orig.ident nCount_RNA nFeature_RNA
A_AAACCCAAGGGTCACA          A       3714         1151
A_AAACCCAAGTATAACG          A       1855          816
A_AAACCCAGTCTCTCAC          A       1530          823
A_AAACCCAGTGAGTCAG          A      11145         1087
A_AAACCCAGTGGCACTC          A       2289          834
A_AAACGAAAGCCAGAGT          A       3714          990

&amp;gt; test.seu[[&quot;RNA&quot;]]@counts[1:4,1:4]
4 x 4 sparse Matrix of class &quot;dgCMatrix&quot;
            A_AAACCCAAGGGTCACA A_AAACCCAAGTATAACG A_AAACCCAGTCTCTCAC A_AAACCCAGTGAGTCAG
MIR1302-2HG                  .                  .                  .                  .
FAM138A                      .                  .                  .                  .
OR4F5                        .                  .                  .                  .
AL627309.1                   .                  .                  .                  .
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-简单过滤&quot;&gt;2. 简单过滤&lt;/h3&gt;
&lt;p&gt;接下来，我们根据每个细胞内部&lt;code&gt;线粒体基因表达占比&lt;/code&gt;、&lt;code&gt;检测到的基因数&lt;/code&gt;、&lt;code&gt;检测的UMI总数&lt;/code&gt;这三个方面来对细胞进行简单的过滤。&lt;br/&gt;先计算细胞内线粒体基因表达占比，类似的核糖体基因(大多为RP开头)也能这样计算，还要注意不要将线粒体基因的&lt;code&gt;MT-&lt;/code&gt;写成了&lt;code&gt;MT&lt;/code&gt;，不然就把别的基因也算进去了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;test.seu[[&quot;percent.mt&quot;]] &amp;lt;- PercentageFeatureSet(test.seu, pattern = &quot;^MT-&quot;)  #正则表达式，表示以MT-开头；test.seu[[&quot;percent.mt&quot;]]这种写法会在meta.data矩阵加上一列
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我已经根据预先设定好的阈值过滤了，代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;test.seu &amp;lt;- subset(test.seu, subset = nCount_RNA &amp;gt; 1000 &amp;amp; 
                     nFeature_RNA &amp;lt; 5000 &amp;amp; 
                     percent.mt &amp;lt; 30 &amp;amp; 
                     nFeature_RNA &amp;gt; 600)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;过滤之后的数值分布如下，用到&lt;code&gt;VlnPlot()&lt;/code&gt;函数，该绘图函数里面的feature参数可以是meta.data矩阵的某一列，也可以是某一个基因，很多文章都用这种图展示marker gene&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;VlnPlot(test.seu,features = c(&quot;nCount_RNA&quot;, &quot;nFeature_RNA&quot;, &quot;percent.mt&quot;))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2265439/202101/2265439-20210105234317535-862237305.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;nFeature_RNA/nCount_RNA不能太小（空液滴），不能太大（doublet、测序技术限制）， 而且阈值设定要综合多个样本来看，像下面这样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2265439/202101/2265439-20210105234317769-605072848.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;一般在CD45阴性的细胞中percent.mt的阈值大一些，50%也看过几次了&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;3-标准化，消除文库大小的影响&quot;&gt;3. 标准化，消除文库大小的影响&lt;/h3&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如何标准化：LogNormalize: Feature counts for each cell are divided by the total counts for that cell and multiplied by the scale.factor. This is then natural-log transformed using log1p.（先相除，再求对数）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;test.seu &amp;lt;- NormalizeData(test.seu, normalization.method = &quot;LogNormalize&quot;, scale.factor = 10000)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;标准化之后的矩阵存储在test.seu[[&quot;RNA&quot;]]@data&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; test.seu[[&quot;RNA&quot;]]@data[1:4,1:4]
4 x 4 sparse Matrix of class &quot;dgCMatrix&quot;
            A_AAACCCAAGGGTCACA A_AAACCCAAGTATAACG A_AAACCCAGTCTCTCAC A_AAACCCAGTGAGTCAG
MIR1302-2HG                  .                  .                  .                  .
FAM138A                      .                  .                  .                  .
OR4F5                        .                  .                  .                  .
AL627309.1                   .                  .                  .                  .
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;4-找variable基因&quot;&gt;4. 找Variable基因&lt;/h3&gt;
&lt;p&gt;因为单细胞表达矩阵很稀疏（很多0），选high variable基因的目的可以找到包含信息最多的基因（很多基因的表达差不多都是0），同时极大提升软件运行速度&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;test.seu &amp;lt;- FindVariableFeatures(test.seu, selection.method = &quot;vst&quot;, nfeatures = 2000)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这些基因存储在VariableFeatures(test.seu)，有时候可能需要人为指定high variable基因，可以这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;VariableFeatures(test.seu)=&quot;specific genes&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5-归一化表达矩阵&quot;&gt;5. 归一化表达矩阵&lt;/h3&gt;
&lt;p&gt;（基于前面得到的data矩阵）&lt;br/&gt;这一步之后，所有基因的表达值的分布就差不多了，不然表达值不在一个数量级，对后续降维聚类影响挺大。新的矩阵存储在test.seu[[&quot;RNA&quot;]]@scale.data里面。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;test.seu &amp;lt;- ScaleData(test.seu, features = rownames(test.seu))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认只对上一步选出来的基因scale，这里调整为所有基因，是为了方便以后画热图，画热图一般会用scale之后的z-score&lt;/p&gt;
&lt;h3 id=&quot;6-降维聚类&quot;&gt;6. 降维聚类&lt;/h3&gt;
&lt;p&gt;（基于前面得到的high variable基因的scale矩阵）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;test.seu &amp;lt;- RunPCA(test.seu, npcs = 50, verbose = FALSE)
test.seu &amp;lt;- FindNeighbors(test.seu, dims = 1:30)
test.seu &amp;lt;- FindClusters(test.seu, resolution = 0.5)

test.seu &amp;lt;- RunUMAP(test.seu, dims = 1:30)
test.seu &amp;lt;- RunTSNE(test.seu, dims = 1:30)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Run开头的函数降维，Find开头的函数聚类，一般就这几步，相对固定。PCA将原来2000维的数据降到50维，dims参数表示使用多少个主成分（一般20左右就可以了，多几个少几个对结果影响不大），resolution参数表达聚类的分辨率，这个值大于0，一般都是在0-1范围里面调整，越大得到的cluster越多，这个值可以反复调整，并不会改变降维的结果（也就是tsne、umap图的二维坐标）。&lt;/p&gt;
&lt;p&gt;这一步之后的数据是这样的&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; test.seu
An object of class Seurat 
33538 features across 6746 samples within 1 assay 
Active assay: RNA (33538 features)
 3 dimensional reductions calculated: pca, umap, tsne
 # 几种降维方式都会呈现出来
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;聚类之后多了两列，RNA_snn_res.0.5记录了你用的分辨率，最终的聚类结果保存在seurat_clusters中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt; head(test.seu@meta.data)
                  orig.ident nCount_RNA nFeature_RNA percent.mt RNA_snn_res.0.5
A_AAACCCAAGGGTCACA          A       3714         1151   9.585353               8
A_AAACCCAAGTATAACG          A       1855          816  12.776280               0
A_AAACCCAGTCTCTCAC          A       1530          823  14.248366              12
A_AAACCCAGTGAGTCAG          A      11145         1087   2.853297               4
A_AAACCCAGTGGCACTC          A       2289          834  15.640017               3
A_AAACGAAAGCCAGAGT          A       3714          990   5.654281               0
                  seurat_clusters
A_AAACCCAAGGGTCACA               8
A_AAACCCAAGTATAACG               0
A_AAACCCAGTCTCTCAC              12
A_AAACCCAGTGAGTCAG               4
A_AAACCCAGTGGCACTC               3
A_AAACGAAAGCCAGAGT               0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;7-tsneumap展示结果&quot;&gt;7. tsne/umap展示结果&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;library(cowplot)
test.seu$patient=str_replace(test.seu$orig.ident,&quot;_.*$&quot;,&quot;&quot;)
p1 &amp;lt;- DimPlot(test.seu, reduction = &quot;tsne&quot;, group.by = &quot;patient&quot;, pt.size=0.5)
p2 &amp;lt;- DimPlot(test.seu, reduction = &quot;tsne&quot;, group.by = &quot;ident&quot;,   pt.size=0.5, label = TRUE,repel = TRUE) #后面两个参数用来添加文本标签
p3 &amp;lt;- DimPlot(test.seu, reduction = &quot;umap&quot;, group.by = &quot;patient&quot;, pt.size=0.5)
p4 &amp;lt;- DimPlot(test.seu, reduction = &quot;umap&quot;, group.by = &quot;ident&quot;,   pt.size=0.5, label = TRUE,repel = TRUE)

fig_tsne &amp;lt;- plot_grid(p1, p2, labels = c('patient','ident'),align = &quot;v&quot;,ncol = 2)
ggsave(filename = &quot;tsne.pdf&quot;, plot = fig_tsne, device = 'pdf', width = 30, height = 15, units = 'cm')
fig_umap &amp;lt;- plot_grid(p3, p4, labels = c('patient','ident'),align = &quot;v&quot;,ncol = 2)
ggsave(filename = &quot;umap.pdf&quot;, plot = fig_umap, device = 'pdf', width = 30, height = 15, units = 'cm')
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ident表示每个细胞的标签，聚类之后就是聚类的结果，在一些特定场景可以更换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2265439/202101/2265439-20210105234318310-2079389447.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/2265439/202101/2265439-20210105234318807-180517578.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在umap图中，cluster之间的距离更明显&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;从上面的图可以看出不同样本其实是有批次效应的，下一讲我会介绍两种去批次效应的方法。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;因水平有限，有错误的地方，欢迎批评指正！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 05 Jan 2021 15:43:00 +0000</pubDate>
<dc:creator>TOP生物信息</dc:creator>
<og:description>前面我们已经学习了单细胞转录组分析的：使用Cell Ranger得到表达矩阵和doublet检测，今天我们开始Seurat标准流程的学习。这一部分的内容，网上有很多帖子，基本上都是把Seurat官网P</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/TOP-Bio/p/14238723.html</dc:identifier>
</item>
</channel>
</rss>