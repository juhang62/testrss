<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何在logback.xml中自定义动态属性 - 【空山新雨】</title>
<link>http://www.cnblogs.com/spec-dog/p/11386668.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/spec-dog/p/11386668.html</guid>
<description>&lt;p&gt;原文地址：&lt;a href=&quot;http://blog.jboost.cn/trick-logback-prop.html&quot;&gt;http://blog.jboost.cn/trick-logback-prop.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;当使用logback来记录Web应用的日志时，我们通过在logback.xml中配置appender来指定日志输出格式及输出文件路径，这在一台主机或一个文件系统上部署单个实例没有问题，但是如果部署多个实例（比如通过容器的方式），多个实例同时往同一文件写日志可能就会引起问题。这时可以将每个实例的日志文件加以区分，如IP或UUID，或两者结合的形式。这其实就涉及如何在logback.xml中自定义动态属性的问题。&lt;/p&gt;
&lt;p&gt;可以有4种方式来实现logback.xml中获取自定义变量值：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;通过设置环境变量或传递系统属性（比如在程序启动时通过-D传递）的方式，两者是可以直接在logback.xml中通过 &lt;code&gt;${变量名}&lt;/code&gt; 获取的。&lt;/li&gt;
&lt;li&gt;自定义logback.xml的加载时机，在其加载前将需要设置的属性注入到logback的context中，这种方式相对复杂，本文不讨论。&lt;/li&gt;
&lt;li&gt;通过实现PropertyDefiner接口来提供属性值设置&lt;/li&gt;
&lt;li&gt;通过实现LoggerContextListener接口来设置属性值&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一种方式简单，但不能通过程序生成属性值，第二种方式稍显复杂，本文主要介绍后两种方式。&lt;/p&gt;
&lt;h2 id=&quot;PropertyDefiner方式&quot;&gt;PropertyDefiner方式&lt;/h2&gt;
&lt;p&gt;首先定义一个类，实现PropertyDefiner接口，可以通过继承PropertyDefinerBase会更方便&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.PropertyDefinerBase;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.slf4j.LoggerFactory;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.UnknownHostException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.UUID;
&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
 * 将本地IP拼接到日志文件名中，以区分不同实例，避免存储到同一位置时的覆盖冲突问题
 * @Author ronwxy
 * @Date 2019/8/20 16:17   
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IPLogDefiner &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; PropertyDefinerBase {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOG = LoggerFactory.getLogger(IPLogDefiner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getUniqName() {
        String localIp &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            localIp &lt;/span&gt;=&lt;span&gt; InetAddress.getLocalHost().getHostAddress();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnknownHostException e) {
            LOG.error(&lt;/span&gt;&quot;fail to get ip...&quot;&lt;span&gt;, e);
        }
        String uniqName &lt;/span&gt;= UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (localIp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            uniqName &lt;/span&gt;= localIp + &quot;-&quot; +&lt;span&gt; uniqName;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; uniqName;
    }


    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getPropertyValue() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getUniqName();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在logback.xml中，添加 &lt;code&gt;&amp;lt;define&amp;gt;&lt;/code&gt; 配置，指定属性名（本例中为localIP）及获取属性值的实现类，这样就可以在配置中通过 &lt;code&gt;${localIP}&lt;/code&gt;来引用该属性值了。在实现方法 &lt;code&gt;getPropertyValue&lt;/code&gt; 中返回你需要生成的值，本例中是返回 &lt;code&gt;本地IP-UUID&lt;/code&gt; 的形式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;configuration&amp;gt;
    &lt;span&gt;&amp;lt;define name=&quot;localIP&quot; class=&quot;cn.jboost.common.IPLogDefiner&quot;/&amp;gt;&lt;/span&gt;
    &amp;lt;appender name=&quot;interfaceLogFile&quot;
              &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
        &amp;lt;File&amp;gt;D:\\logs\\elk\\&lt;span&gt;interface&lt;/span&gt;-${localIP}.log&amp;lt;/File&amp;gt;
        &amp;lt;filter &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&amp;gt;
            &amp;lt;level&amp;gt;INFO&amp;lt;/level&amp;gt;
        &amp;lt;/filter&amp;gt;&lt;span&gt;
# 省略了其它配置&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;LoggerContextListener方式&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;定义一个实现LoggerContextListener接口的类，在start方法中，将需要设置的属性设置到logback的Context中，&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; ch.qos.logback.classic.Level;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; ch.qos.logback.classic.Logger;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; ch.qos.logback.classic.LoggerContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; ch.qos.logback.classic.spi.LoggerContextListener;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.Context;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.spi.ContextAwareBase;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; ch.qos.logback.core.spi.LifeCycle;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.InetAddress;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.net.UnknownHostException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.UUID;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;*
 * 第二种实现方式
 * @Author ronwxy
 * @Date 2019/8/20 18:45   
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; LoggerStartupListener &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ContextAwareBase 
    &lt;/span&gt;&lt;span&gt;implements&lt;/span&gt;&lt;span&gt; LoggerContextListener, LifeCycle {

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; started = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (started) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        Context context &lt;/span&gt;=&lt;span&gt; getContext();
        context.putProperty(&lt;/span&gt;&quot;localIP&quot;&lt;span&gt;, getUniqName());
        started &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String getUniqName() {
        String localIp &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            localIp &lt;/span&gt;=&lt;span&gt; InetAddress.getLocalHost().getHostAddress();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (UnknownHostException e) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;LOG.error(&quot;fail to get ip...&quot;, e);&lt;/span&gt;
&lt;span&gt;        }
        String uniqName &lt;/span&gt;= UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (localIp != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            uniqName &lt;/span&gt;= localIp + &quot;-&quot; +&lt;span&gt; uniqName;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; uniqName;
    }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略了其它函数&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 然后在logback.xml中，配置如上监听器类，这样就可以通过 &lt;code&gt;${localIP}&lt;/code&gt; 获取到上面 &lt;code&gt;context.putProperty(&quot;localIP&quot;, getUniqName());&lt;/code&gt; 设置的值了。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;configuration&amp;gt;

    &amp;lt;!--&amp;lt;define name=&quot;localIP&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.cnbot.common.IPLogDefiner&quot;/&amp;gt;--&amp;gt;
   &lt;span&gt; &amp;lt;contextListener class=&quot;cn.jboost.common.LoggerStartupListener&quot;/&amp;gt;&lt;/span&gt;
    &amp;lt;define name=&quot;localIP&quot; &lt;span&gt;class&lt;/span&gt;=&quot;com.cnbot.common.IPLogDefiner&quot;/&amp;gt;
    &amp;lt;appender name=&quot;interfaceLogFile&quot;
              &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;&amp;gt;
        &amp;lt;encoding&amp;gt;UTF-8&amp;lt;/encoding&amp;gt;
        &amp;lt;File&amp;gt;D:\\logs\\elk\\&lt;span&gt;interface&lt;/span&gt;-${localIP}.log&amp;lt;/File&amp;gt;
        &amp;lt;filter &lt;span&gt;class&lt;/span&gt;=&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;&amp;gt;
            &amp;lt;level&amp;gt;INFO&amp;lt;/level&amp;gt;
        &amp;lt;/filter&amp;gt;&lt;span&gt;
# 省略了其它配置&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这种方式能设置任意个数的属性值，比前一种方式灵活。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;在logback.xml中获取自定义属性值，主要是需要在加载前将对应的属性值进行设置，这样加载时才能有效获取。本文虽是自定义日志文件名称，但不局限于此，所有需要动态获取的变量都可以按这种方式实现。&lt;/p&gt;
&lt;p&gt;如果觉得有帮助，请帮忙转发、推荐。欢迎关注我的微信公众号：jboost-ksxy&lt;br/&gt;———————————————————————————————————————————————————————————————&lt;br/&gt;&lt;img src=&quot;http://blog.jboost.cn/assets/qrcode-05.jpg&quot; alt=&quot;微信公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 21 Aug 2019 00:36:00 +0000</pubDate>
<dc:creator>【空山新雨】</dc:creator>
<og:description>原文地址：http://blog.jboost.cn/trick-logback-prop.html 当使用logback来记录Web应用的日志时，我们通过在logback.xml中配置appende</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/spec-dog/p/11386668.html</dc:identifier>
</item>
<item>
<title>开源题材征集 + MVC&amp;EF Core 完整教程小结 - 编程小纸条</title>
<link>http://www.cnblogs.com/miro/p/11383712.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/miro/p/11383712.html</guid>
<description>&lt;p&gt;到目前为止，我们的MVC+EF Core 完整教程的理论部分就全部结束了，共20篇，覆盖了核心的主要知识点。&lt;/p&gt;

&lt;p&gt;下一阶段是实战部分，我们将会把这些知识点串联起来，用10篇(天)来完成一个开源项目。&lt;/p&gt;
&lt;p&gt;现向园友征集题材，你提需求我来实现。&lt;/p&gt;

&lt;p&gt;我将会在选取一个相对适合的题材，通过敏捷开发，快速迭代，将详细开发过程记录下来，抛砖引玉，供大家参考。&lt;/p&gt;
&lt;p&gt;前面已完成的20篇我们以技术为主导，后面的10篇我们将会以产品为主导。&lt;/p&gt;

&lt;p&gt;请在评论中提出你的需求，并加以简明扼要的描述。&lt;/p&gt;
&lt;p&gt;题材最好是有趣的、有一定应用价值的，例如像Trello这样的效率管理系统。&lt;/p&gt;
&lt;p&gt;开发完之后，博主可以提供个云服务器将程序放上去给大家使用，我们可以一边玩一边改进。&lt;/p&gt;

&lt;p&gt;主要开发环境：&lt;/p&gt;
&lt;p&gt;1、.net core 3 最新版&lt;/p&gt;
&lt;p&gt;2、js &amp;amp; jquery(如果时间允许，我们尽量多用原生js), bootstrap&lt;/p&gt;
&lt;p&gt;3、MS SQL 2016&lt;/p&gt;

&lt;p&gt;最终的开源项目将会具有：&lt;/p&gt;
&lt;p&gt;1、详细的使用说明书（直接放在系统中，点击帮助就能看到）&lt;/p&gt;
&lt;p&gt;2、详细的代码说明，v1.0版本后将会托管到github上&lt;/p&gt;
&lt;p&gt;3、详细的开发说明（代码演进），以博客园系列文章发布，了解代码演讲过程比最终的代码更有价值。&lt;/p&gt;

&lt;p&gt;感谢写作过程中各位园友的鼓励，授人以鱼不如授人以渔，希望能给你们带来一点帮助。&lt;/p&gt;
&lt;p&gt;祝学习进步 ：）&lt;/p&gt;

&lt;p&gt;P.S. 历史文章回顾与总结说明&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/101211/201908/101211-20190820162420926-1886458442.png&quot; alt=&quot;&quot; width=&quot;627&quot; height=&quot;391&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 21 Aug 2019 00:24:00 +0000</pubDate>
<dc:creator>编程小纸条</dc:creator>
<og:description>到目前为止，我们的MVC+EF Core 完整教程的理论部分就全部结束了，共20篇，覆盖了核心的主要知识点。 下一阶段是实战部分，我们将会把这些知识点串联起来，用10篇(天)来完成一个开源项目。 现向</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/miro/p/11383712.html</dc:identifier>
</item>
<item>
<title>.net测试篇之单元测试/集成测试神器Autofixture - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11386635.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11386635.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11386635.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;autofixture简介&quot;&gt;autofixture简介&lt;/h2&gt;
&lt;p&gt;有了单元测试框架加上Moq(后面我们会用单独章节来介绍moq),可以说测试问题基上都能搞定了.然而有了AutoFixture对单元测试来说可以说是如虎添翼,AutoFixture并且它能与moq,rhinomock等框架结合,对单元测试带来的便捷性,可维护性和扩展性更是难以言表,只有用用了才知道.&lt;/p&gt;
&lt;p&gt;说了这么多,还没有介绍AutoFixture是干什么的,其实AutoFixture就是一个假数据填充工具.&lt;/p&gt;
&lt;p&gt;其实不论是Nunit还是Xunit都有数据填充功能,并且大部分时候都能满足需求.然而通过我们前面的介绍就会知道有以下问题:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;不论是vlues注解还是TestCase注解都没有类型约束,这就可能会造成运行时错误.&lt;/li&gt;
&lt;li&gt;基于注解的值都只能是Const值,如果需要复杂类型就需要定义一个类型做为Source为当前操作提供值.&lt;/li&gt;
&lt;li&gt;与Nunit和Xunit生成的填充数据相比,Autofixture可以生成符合验证规则的数据(基于system.componentmodel.annotations名称空间下的注解约束),这在集成测试里帮助很大,对于有着非常复杂模型验证的接口来说,手工制造出符合模型验证规则的数据往往是非常痛苦的.&lt;/li&gt;
&lt;li&gt;Autofixture可以生成一组符合验证规则的数据,这样在测试的时候增加了样本数据的随机性,大大提升了测试的覆盖面.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Moq测试虽然极大方便了测试,但是也会有一些问题:&lt;/p&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;对于比较复杂的web项目,往往一个业务逻辑可能要消费十个几个甚至几十个数据接口,如果业务不是很成熟可能需要不断的来调整这些接口,这里的修改同时单元测试方法也需要修改(因为这些接口多数时候是通过构造函数注入的,构造函数参数数量的变动会导致调用者也需要做相应调整)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;虽然Moq也能够模拟类对象,但是限制非常多,我们不可能为了测试把所有的方法和属性都加上abstract或者virtual.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;而autofixture则可以很好的解决这些问题.这样极大增加代码的可维护性和扩展性.&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;AutoFixture并不是对moq的替代,它只能填充对象,而不能模拟对象,但是它可以与moq框架结合实现更强大的功能.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;autofixture安装&quot;&gt;autofixture安装&lt;/h2&gt;
&lt;p&gt;autofixture安装非常简单,我们在Nuget里搜索autofixture,第一个就是它点击安装即可.&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;关于autofixture与moq结合需要的包在后面讲到的时候再安装,这里先略过.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;要使AutoFixture与Nunit结合,首先我们需要安装特定的包.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Nuget里输入AutoFixture.Nunit3,会出现以下选项&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190821081852990-319408247.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;br/&gt;由于我们使用的是Nunit3,因此我们选择第一个安装.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;AutoFixture还可以与Xunit结合.在Nuget里搜索AutoFixture.xunit2便可以搜索到AutoFixture与Xunit结合的框架.与Xunit结果的用法与Nunit差不多,只是需要注意Xunit数据测试方法需要Theory注解.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们新建一个名为&lt;code&gt;FixtureTest&lt;/code&gt;并引入&lt;code&gt;AutoFixture.NUnit3;&lt;/code&gt;名称空间&lt;/p&gt;
&lt;p&gt;代码如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt; [TestFixture]
   public class FixtureTest
    {
        [Test]
        [AutoData]
        public void FixValueTest(int a, int b)
        {
            var result = Add(a , b);
            Assert.AreEqual(a + b, result);
        }
        int Add(int x, int y)
        {
            return x + y;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里与平时的单元测试相比,多了一个AutoData注解,有了AutoData注解,AutoFixture便可以给当前测试提供值了.&lt;br/&gt;我们断点调试一下看看a和b的值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190821081847783-1147078289.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到a和b都被赋予了随机的值.&lt;/p&gt;
&lt;p&gt;我们把测试代码改为如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Test]
        [AutoData]
        public void FixValueTest(Person p1, Person p2)
        {
            var result = Add(p1.Age , p2.Age);
            Assert.AreEqual(p1.Age + p2.Age, result);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再断点调试一下看看是否有值&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190821081842364-1611584408.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;复杂对象它也能填充!这样就免去了为了使用复杂对象需要额外写很多source繁琐.&lt;/p&gt;
&lt;p&gt;我们把代码改成如下&lt;/p&gt;
&lt;pre class=&quot;cs&quot;&gt;
&lt;code&gt;        [Test]
        [AutoData]
        public void FixValueTest(IEnumerable&amp;lt;Person&amp;gt; people)
        {
            var ages = people.Sum(a =&amp;gt; a.Age);
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看看此时会有什么结果&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201908/811801-20190821081833845-1947638048.png&quot; alt=&quot;Avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过监视容器可以看到,AutoFixture生成了一个包含三个元素的对象.&lt;/p&gt;
&lt;p&gt;这简直是太方便了,autofixture自动填充值不但减少了运行时可能的类型错误,还有极大的扩展性,如果我们在测试方法上添加其它参数,它仍然能够自动填充.而使用Nunit自身带的TestCase如果参数减少,里面指定的值也要减少,否则会抛出运行时异常.&lt;/p&gt;
&lt;p&gt;通过以上我们可以看到,AutoFixture可以生成各种类型的对象,它可以创建集合对象对我们测试来说尤其有用,免去了手动创建的麻烦.但是我们同时也看到,基于注解的方法生成集合时只生成了三个,实际上要模拟数据库是的数据测试一些行为我们可能需要更多的元素.这里就需要对AutoFixture本身进行配置.这是基于注解的方法无法完成的.&lt;/p&gt;
</description>
<pubDate>Wed, 21 Aug 2019 00:21:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' autofixture简介 有了单元测试框架加上Moq(后面我们会用单独章节来介绍moq),可以说测试问题基上都能搞定了.然而有了AutoFixture对单元测试来说可以说是如虎添翼,A</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11386635.html</dc:identifier>
</item>
<item>
<title>Executor线程池只看这一篇就够了 - 小强的进阶之路</title>
<link>http://www.cnblogs.com/xiaoqiang-code/p/11386612.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoqiang-code/p/11386612.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;线程池为线程生命周期的开销和资源不足问题提供了解决方 案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;线程实现方式&quot;&gt;线程实现方式&lt;/h2&gt;
&lt;p&gt;Thread、Runnable、Callable&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//实现Runnable接口的类将被Thread执行，表示一个基本任务
public interface Runnable {
    //run方法就是它所有内容，就是实际执行的任务
    public abstract void run();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;//Callable同样是任务，与Runnable接口的区别在于它接口泛型，同时它执行任务候带有返回值；
//Callable的使用通过外层封装成Future来使用
public interface Callable&amp;lt;V&amp;gt; {
    //相对于run方法，call方法带有返回值
    V call() throws Exception;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：启动Thread线程只能用start（JNI方法）来启动，start方法通知虚拟机，虚拟机通过调用器映射到底层操作系统，通过操作系统来创建线程来执行当前任务的run方法&lt;/p&gt;
&lt;h2 id=&quot;executor框架&quot;&gt;Executor框架&lt;/h2&gt;
&lt;p&gt;Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方法。&lt;br/&gt;从图中可以看出Exectuor下有一个重要的子接口ExecutorService，其中定义了线程池的具体行为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
private static final int COUNT_BITS = Integer.SIZE - 3;
private static final int CAPACITY   = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ctl：对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段，它包含两部分信息：线程池的运行状态(runState)和线程池内有效线程的数量(workerCount)。&lt;/p&gt;
&lt;p&gt;这里可以看到，使用Integer类型来保存，高3位保存runState，低29位保存workerCount。COUNT_BITS 就是29，CAPACITY 就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。&lt;/p&gt;
&lt;p&gt;ctl相关方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//获取运行状态
private static int runStateOf(int c)     { return c &amp;amp; ~CAPACITY; }
//获取活动线程数
private static int workerCountOf(int c)  { return c &amp;amp; CAPACITY; }
//获取运行状态和活动线程数的值
private static int ctlOf(int rs, int wc) { return rs | wc; }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程池的状态：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;RUNNING = ­1 &amp;lt;&amp;lt; COUNT_BITS; //高3位为111
SHUTDOWN = 0 &amp;lt;&amp;lt; COUNT_BITS; //高3位为000
STOP = 1 &amp;lt;&amp;lt; COUNT_BITS; //高3位为001
TIDYING = 2 &amp;lt;&amp;lt; COUNT_BITS; //高3位为010
TERMINATED = 3 &amp;lt;&amp;lt; COUNT_BITS; //高3位为011&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201908/1771943-20190821075852112-497573778.jpg&quot; alt=&quot;线程池运行状态扭转&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1、RUNNING&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态说明：线程池处于RUNNING状态，能够接收新任务，以及对已添加的任务进行处理。&lt;/li&gt;
&lt;li&gt;状态切换：线程池的初始化状态是RUNNING。换句话说，线程池一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;2、SHUTDOWN&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态说明：线程池处于SHUTDOWN状态，不接收新任务，能够处理已经添加的任务。&lt;/li&gt;
&lt;li&gt;状态切换：调用shutdown()方法时，线程池由RUNNING -&amp;gt; SHUTDOWN。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;3、STOP&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态说明：线程池处于STOP状态，不接收新任务，不处理已提交的任务，并且会中断正在处理的任务。&lt;/li&gt;
&lt;li&gt;状态切换：调用线程池中的shutdownNow()方法时，线程池由(RUNNING or SHUTDOWN) -&amp;gt; STOP。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;4、TIDYING&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态说明：当所有的任务已经停止，ctl记录“任务数量”为0，线程池会变为TIDYING状态。当线程池处于TIDYING状态时，会执行钩子函数 terminated()。 terminated()在ThreadPoolExecutor类中是空， 的，若用户想在线程池变为TIDYING时，进行相应处理，可以通过重载 terminated()函数来实现。&lt;/li&gt;
&lt;li&gt;状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行任务也为空时，就会由SHUTDOWN -&amp;gt; TIDYING。当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP-&amp;gt; TIDYING。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;5、TERMINATED&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;状态说明：线程池线程池彻底停止，线程池处于TERMINATED状态，&lt;/li&gt;
&lt;li&gt;状态切换：线程池处于TIDYING状态时，执行完terminated()之后， 就会由TIDYING-&amp;gt;TERMINATED。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;线程池使用&quot;&gt;线程池使用&lt;/h2&gt;
&lt;p&gt;RunTask类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class RunTask implements Runnable {
    public void run() {
        System.out.println(&quot;Thread name:&quot;+Thread.currentThread().getName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ExecutorSample类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ExecutorSample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(5);
        for (int i=0;i&amp;lt;20;i++){
            //提交任务无返回值
            executor.execute(new RunTask());
            //任务执行完成后有返回值
            Future&amp;lt;Object&amp;gt; future = executor.submit(new RunTask());
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程池的具体使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler) {
    this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,
         threadFactory, defaultHandler);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;corePoolSize：线程池中的核心线程数。当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程。&lt;/li&gt;
&lt;li&gt;maximumPoolSize：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize。&lt;/li&gt;
&lt;li&gt;keepAliveTime：线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize时候，如果这时候没有新的任务提交，核心线程外的线程不会立即被销毁，而是会等待，直到等待的时间超过了keepAliveTime&lt;br/&gt;unit：keepAliveTime的单位时间&lt;/li&gt;
&lt;li&gt;workQueue：用于保存等待被执行的任务的阻塞队列，且任务必须实现Runnable接口，在JDK中提供了如下阻塞队列：&lt;br/&gt;ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务。&lt;br/&gt;LinkedBlockingQueue：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQueue。&lt;br/&gt;SynchronousQueue：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常高于LinkedBlockingQueue。&lt;/li&gt;
&lt;li&gt;PriorityBlockingQueue：具有优先级的无界阻塞队列。&lt;/li&gt;
&lt;li&gt;threadFactory：ThreadFactory 类型的变量，用来创建新线程。默认使用ThreadFactory.defaultThreadFactory来创建线程， 会使新创建线程具有相同的NORM_PRIORITY优先级并且都是非守护线程，同时也设置了线程名称。&lt;/li&gt;
&lt;li&gt;handler：线程池的饱和策略。当阻塞队列满了，且没有空闲的工作队列，如果继续提交任务，必须采用一种策略处理该任务.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;线程池的监控：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public long getTaskCount() //线程池已执行与未执行的任务总数
public long getCompletedTaskCount() //已完成的任务数
public int getPoolSize() //线程池当前的线程数
public int getActiveCount() //线程池中正在执行任务的线程数量&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;线程池的原理&quot;&gt;线程池的原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201908/1771943-20190821075852258-1859369739.jpg&quot; alt=&quot;线程池执行示意图&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意这一个步骤需要获取全局锁）。&lt;/li&gt;
&lt;li&gt;如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue。&lt;/li&gt;
&lt;li&gt;如果无法将任务加入BlockingQueue（队列已满），则创建新的线程来处理任务（注意这一个步骤需要获取全局锁）。&lt;/li&gt;
&lt;li&gt;如果创建的新线程将使当前运行的线程超出maximumPoolSize，任务将被执行饱和策略。&lt;br/&gt;ThreadPoolExecutor 采用上述的设计思路，是为执行execute()方法时，尽可能避免获取全局锁(一个严重的可伸缩瓶颈)。在ThreadPoolExecutor完成预热之后，几乎所有的execute()方法调用都是在执行步骤2，而步骤2不需要获取全局锁。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;还没关注我的公众号？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;扫文末二维码关注公众号【小强的进阶之路】可领取如下:&lt;/li&gt;
&lt;li&gt;学习资料： 1T视频教程：涵盖Javaweb前后端教学视频、机器学习/人工智能教学视频、Linux系统教程视频、雅思考试视频教程；&lt;/li&gt;
&lt;li&gt;100多本书：包含C/C++、Java、Python三门编程语言的经典必看图书、LeetCode题解大全；&lt;/li&gt;
&lt;li&gt;软件工具：几乎包括你在编程道路上的可能会用到的大部分软件；&lt;/li&gt;
&lt;li&gt;项目源码：20个JavaWeb项目源码。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1771943/201908/1771943-20190821075853015-78048908.png&quot; alt=&quot;小强的进阶之路二维码&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 20 Aug 2019 23:59:00 +0000</pubDate>
<dc:creator>小强的进阶之路</dc:creator>
<og:description>线程池为线程生命周期的开销和资源不足问题提供了解决方 案。通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上。 线程实现方式 Thread、Runnable、Callable 注意：启动Thr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoqiang-code/p/11386612.html</dc:identifier>
</item>
<item>
<title>Redis之对象篇——Redis对象系统简介 - 崖边小生</title>
<link>http://www.cnblogs.com/hunternet/p/11386610.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hunternet/p/11386610.html</guid>
<description>&lt;h2 id=&quot;redis之对象篇redis对象系统简介&quot;&gt;Redis之对象篇——Redis对象系统简介&lt;/h2&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;    之前几篇文章,简单介绍 Redis用到的所有主要数据结构,简单动态字符串(SDS)、双端链表、字典、压缩列表、整数集合、跳跃表。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hunternet/p/9957913.html&quot;&gt;图解Redis之数据结构篇——简单动态字符串SDS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hunternet/p/9967279.html&quot;&gt;图解Redis之数据结构篇——链表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hunternet/p/9989771.html&quot;&gt;图解Redis之数据结构篇——字典&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hunternet/p/11248192.html&quot;&gt;图解Redis之数据结构篇——跳跃表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hunternet/p/11268067.html&quot;&gt;图解Redis之数据结构篇——整数集合&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/hunternet/p/11306690.html&quot;&gt;图解Redis之数据结构篇——压缩列表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    Redis并没有直接使用这些数据结构来实现键值对数据库,而是基于这些数据结构创建了一个对象系统,这个系统包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象,而每种对象又通过不同的编码映射到不同的底层数据结构。&lt;/p&gt;
&lt;h3 id=&quot;一redis对象类型和编码&quot;&gt;一、Redis对象类型和编码&lt;/h3&gt;
&lt;p&gt;    Redis中的每个对象都由一个redisObject结构表示,该结构中和保存数据有关的三个属性分别是type属性、 encoding属性和ptr属性:&lt;/p&gt;
&lt;p&gt;    Redis使用对象来表示数据库中的键和值,每次当我们在Redis的数据库中新创建一个键值对时,我们至少会创建两个对象,一个对象用作键值对的健(键对象),另一个对象用作键值对的值(值对象)。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;typedef struct redisObiect{
    //类型
    unsigned type:4;
    //编码
    unsigned encoding:4;
    //指向底层数据结构的指针
    void *ptr;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;    其中Redis的键对象都是字符串对象，而Redis的值对象主要有字符串、哈希、列表、集合、有序集合几种。其分别对应的内部编码和底层数据结构如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://hunter-image.oss-cn-beijing.aliyuncs.com/redis/object/Redis%E5%AF%B9%E8%B1%A1%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;二思考一个问题&quot;&gt;二、思考一个问题&lt;/h3&gt;
&lt;p&gt;    Redis中的对象，大都是通过多种数据结构来实现的，为什么会这样设计呢？用一种固定的数据结构来实现，不是更加简单吗？&lt;/p&gt;
&lt;p&gt;Redis这样设计有两个好处：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以自由改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令，例如Redis3.2提供了quicklist，其结合了ziplist和linkedlist两者&lt;br/&gt;的优势，为列表类型提供了一种更为优秀的内部编码实现，而对外部用户来说基本感知不到。 这一点比较像程序设计中的分层架构。&lt;/li&gt;
&lt;li&gt;多种内部编码实现可以在不同场景下发挥各自的优势，从而优化对象在不同场景下的使用效率。例如ziplist比较节省内存，但是在列表元素比较多的情况下，性能会有所下降，这时候Redis会根据配置选项将列表类型的内部实现转换linkedlist。 (后续文章将根据具体对象介绍)&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;本文重点&quot;&gt;本文重点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Redis基于底层的一些数据结构创建了一个对象系统以供用户使用&lt;/li&gt;
&lt;li&gt;这个系统主要包含字符串对象、列表对象、哈希对象、集合对象和有序集合对象&lt;/li&gt;
&lt;li&gt;Redis的键对象都是字符串对象&lt;/li&gt;
&lt;li&gt;Redis的值对象主要有字符串、哈希、列表、集合、有序集合几种&lt;/li&gt;
&lt;li&gt;为了可以自由改进内部编码，以及在不同场景下发挥其最大优势，Redis中的对象，大都是通过多种数据结构来实现&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;p&gt;《Redis设计与实现》&lt;/p&gt;
&lt;p&gt;《Redis开发与运维》&lt;/p&gt;
&lt;p&gt;《Redis官方文档》&lt;/p&gt;
&lt;h3 id=&quot;end-----&quot;&gt;-----END-----&lt;/h3&gt;
</description>
<pubDate>Tue, 20 Aug 2019 23:56:00 +0000</pubDate>
<dc:creator>崖边小生</dc:creator>
<og:description>Redis之对象篇——Redis对象系统简介 前言 &amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;之前几篇文章,简单介绍 Redis用到的所有主要数据结构,简单动态字符串(SDS)、双端链表、字典、</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/hunternet/p/11386610.html</dc:identifier>
</item>
<item>
<title>Java虚拟机详解（六）------内存分配 - YSOcean</title>
<link>http://www.cnblogs.com/ysocean/p/11117359.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ysocean/p/11117359.html</guid>
<description>&lt;p&gt;　　我们说Java是自动进行内存管理的，所谓自动化就是，不需要程序员操心，Java会自动进行&lt;strong&gt;内存分配&lt;/strong&gt;和&lt;strong&gt;内存回收&lt;/strong&gt;这两方面。&lt;/p&gt;
&lt;p&gt;　　前面我们介绍过如何通过垃圾回收器来回收内存，那么本篇博客我们来聊聊如何进行分配内存。&lt;/p&gt;
&lt;p&gt;　　对象的内存分配，往大方向上讲，就是堆上进行分配（但也有可能经过JIT编译后被拆散为标量类型并间接的在栈上分配），对象主要分配在新生代 Eden 区上，如果启动了本地线程分配缓冲，将按线程优先在 TLAB 上分配。少数情况下也可能会直接分配在老年代上（下面会详细介绍），分配的规则并不是百分之百固定的，其细节取决于当前使用哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数设置。&lt;/p&gt;
&lt;p&gt;　　本篇博客会介绍几条最普遍的内存分配规则。通过增加 -XX:+UseParallelGC 参数，表示使用的垃圾收集器是 Parallel Scavenge + Serial Old ，通过这两个垃圾收集器组合进行校验。&lt;/p&gt;
&lt;h3&gt;1、Minor GC 、Major GC 和 Full GC&lt;/h3&gt;
&lt;p&gt;　　下面会出现这几个概念，所以这里首先介绍一下。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;①、Minor GC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　也叫Young GC，指的是新生代 GC，发生在新生代（Eden区和Survivor区）的垃圾回收。因为Java对象大多是朝生夕死的，所以 Minor GC 通常很频繁，一般回收速度也很快。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、Major GC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　也叫Old GC，指的是老年代的 GC，发生在老年代的垃圾回收，该区域的对象存活时间比较长，通常来讲，发生 Major GC时，会伴随着一次 Minor GC，而 Major GC 的速度一般会比 Minor GC 慢10倍。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;②、Full GC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　指的是全区域（整个堆）的垃圾回收，通常来说和 Major GC 是等价的。　　&lt;/p&gt;
&lt;h3&gt;1、对象优先在 Eden 上分配&lt;/h3&gt;
&lt;p&gt;　　大多数情况下，对象优先在 Eden 上分配。当 Eden 区没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC(新生代GC)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.ys.algorithmproject.leetcode.demo.JVM;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Create by YSOcean
 * 对象优先在Eden区上分配
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EdenTest {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; _1MB = &lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 虚拟机参数设置：-XX:+UseParallelGC -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
     * @param args
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] a = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt;*&lt;span&gt;_1MB];
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] b = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt;*&lt;span&gt;_1MB];
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] c = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;2&lt;/span&gt;*&lt;span&gt;_1MB];
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] d = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;3&lt;/span&gt;*&lt;span&gt;_1MB];
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行时的虚拟机参数设置为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-XX:+UseParallelGC -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=&lt;span&gt;8&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　①、 -XX:+UseParallelGC 参数，表示使用的垃圾收集器是 Parallel Scavenge + Serial Old ；&lt;/p&gt;
&lt;p&gt;　　②、-XX:+PrintGCDetails 参数，表示打印详细的GC日志，便于我们查看GC情况&lt;/p&gt;
&lt;p&gt;　　③、-Xms20M -Xmx20M 这两个参数分别表示设置最大堆，最小堆内存都是20M&lt;/p&gt;
&lt;p&gt;　　④、-Xmn 参数表示设置新生代大小为 10M&lt;/p&gt;
&lt;p&gt;　　⑤、-XX:SurvivorRatio=8 新生代中的 Eden 区和 Survivor 区的比值为8:1，注意 Survivor是有两个的。&lt;/p&gt;
&lt;p&gt;　　运行打印的GC日志为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190818121244818-1642105242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　我们首先分析设置的JVM参数，表示堆中内存为20M，新生代和老年代分别各占一半为10M，并且新生代的Eden区为8M，剩下两个 Survivor 各为 1M。&lt;/p&gt;
&lt;p&gt;　　在看代码，首先分配了三个大小都为2M的对象 a,b,c。这时候新生代对象的 Eden区已经被占用了6M，这时候来了一个对象d，大小为3M，发现新生代Eden区已经不足以分配对象d了，于是发起一次Minor GC。GC期间虚拟机又发现现在已有3个 2MB对象无法全部放入Survivor空间（Survivor空间只有1MB），所以只好通过分配担保机制提前转移到老年代中，然后将这个对象d分配到新生代Eden区中。&lt;/p&gt;
&lt;p&gt;　　我们查看日志，在eden区中，总共8192K的空间，被使用了38%，约等于3113K，大概就是对象d(3MB)的大小。其次在老年代中，总共10240K（10MB），被使用了6865K，大概也就是a,b,c这三个对象的大小（6MB）。&lt;/p&gt;
&lt;h3&gt;2、大对象直接进行老年代&lt;/h3&gt;
&lt;p&gt;　　通常大对象是指需要大量连续内存空间的Java对象，比较典型的就是那种很长的字符串以及数组。&lt;/p&gt;
&lt;p&gt;　　系统中出现大量大对象是很影响性能的，这样会导致还有不少空间时就提前触发垃圾回收来放置这些对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package com.ys.algorithmproject.leetcode.demo.JVM;

&lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Create by YSOcean
 * 大对象直接在老年代上分配
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldTest {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; final &lt;span&gt;int&lt;/span&gt; _1MB = &lt;span&gt;1024&lt;/span&gt;*&lt;span&gt;1024&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
     * 虚拟机参数设置：-XX:+UseParallelGC -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
     * @param args
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] a = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;[&lt;span&gt;8&lt;/span&gt;*&lt;span&gt;_1MB];

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　运行时虚拟机参数还和上面一样，运行的GC日志如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190818124823152-745808027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　可以看到老年代 ParOldGen直接被使用了 8192K，而新生代只被占用了1820K。&lt;/p&gt;
&lt;p&gt;　　PS：可以通过设置-XX:PretenureSizeThreshold 参数，大于这个参数设置值的对象直接在老年代中分配，但是这个参数只对 Serial 和 ParNew 这两款垃圾收集器有效，Parallel Scavenge 收集器不认识这个参数。&lt;/p&gt;
&lt;h3&gt;3、长期存活的对象将进入老年代&lt;/h3&gt;
&lt;p&gt; 　　我们知道Java虚拟机是通过分代收集的思想来管理内存，新创建的对象通常放在新生代，除此之外，还有一些对象放在老年代。为了识别哪些对象放在新生代，哪些对象放在老年代，虚拟机给每个对象定义了一个年龄计数器(Age)，如果对象在新生代Eden创建，并经历一次 Minor GC 后仍然存活，并且能够被 Survivor 容纳的话，虚拟机会将该对象移动到 Survivor 区域，并将对象的年龄Age+1。&lt;/p&gt;
&lt;p&gt;　　新生代对象每熬过一次 Minor GC，年龄就增加1，当它的年龄增加到一定阈值时（默认是15岁），就会被晋升到老年代中。&lt;/p&gt;
&lt;p&gt;　　这个年龄阈值可以通过如下参数来设置（N表示晋升到老年代的阈值）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-XX:MaxTenuringThreshold=N
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.ys.algorithmproject.leetcode.demo.JVM;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Create by YSOcean
 * 新生代对象经过N次Minor GC后，晋升到老年代
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; OldAgeTest {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; _1MB = 1024*1024&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 虚拟机参数设置：-XX:MaxTenuringThreshold=1 -XX:+UseParallelGC -XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; args
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;byte&lt;/span&gt;[] a = &lt;span&gt;new&lt;/span&gt; &lt;span&gt;byte&lt;/span&gt;&lt;span&gt;[_1MB];
        System.gc();

    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意：这里我们设置 -XX:MaxTenuringThreshold=1，也就是经历一次gc，新生代对象就直接进入老年代了，然后手动调用了 System.gc() 方法，表示让虚拟机进行垃圾回收。打印的日志如下：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190819204634025-908108573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意看，代码中我们只创建了一个 1MB大小的对象，但是老年代占用了1999K的内存，而新生代确只有246K。&lt;/p&gt;
&lt;p&gt;　　接下来可以将 -XX:MaxTenuringThreshold 参数设置的更大一点，来对比打印的日志，这里读者可以自己进行验证。&lt;/p&gt;
&lt;h3&gt;4、新生代Survivor 区相同年龄所有对象之和大于 Survivor 所有对象之和的一半，大于等于该年龄的对象进入老年代&lt;/h3&gt;
&lt;p&gt;　　Java虚拟机并不会死板的根据上面第3点说的，设置-XX:MaxTenuringThreshold 的阈值，只有对象经历该阈值次GC后，才会进入到老年代。而是会根据新生代对象的年龄来动态的决定哪些对象可以进入到老年代。&lt;/p&gt;
&lt;p&gt;　　也就是说，新生代经历一次 Minor GC 后，Survivor 区域存活对象的所有相同年龄之和大于整个 Survivor 区域的所有对象之和，那么该区域大于等于这个年龄的对象就会进入老年代，而无需等到 -XX:MaxTenuringThreshold 设置的阈值。&lt;/p&gt;

&lt;h3&gt;5、空间分配担保原则&lt;/h3&gt;
&lt;p&gt;　　在前面介绍 &lt;a href=&quot;https://www.cnblogs.com/ysocean/p/11108933.html&quot; target=&quot;_blank&quot;&gt;垃圾回收&lt;/a&gt; 时，我们介绍过现在Java虚拟机采用的是分代回收算法，新生代采用复制收集算法，而老年代采用标记整理，或者标记清除算法。&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1120165/201908/1120165-20190819211653146-411821811.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　新生代内存分为一块 Eden区，和两块 Survivor 区域，当发生一次 Minor GC时，虚拟机会将Eden和一块Survivor区域的所有存活对象复制到另一块Survivor区域，通常情况下，Java对象朝生夕死，一块 Survivor 区域是能够存放GC后剩余的对象的，但是极端情况下，GC后仍然有大量存活的对象，那么一块 Survivor 区域就会存放不下这么多的对象，那么这时候就需要老年代进行分配担保，让无法放入 Survivor 区域的对象直接进入到老年代，当然前提是老年代还有空间能够存放这些对象。但是实际情况是在完成GC之前，是不知道还有多少对象能够存活下来的，所以老年代也无法确认是否能够存放GC后新生代转移过来的对象，那么这该怎么办呢?&lt;/p&gt;
&lt;p&gt;　　前面我们介绍的都是Minor GC,那么何时会发生 Full GC？&lt;/p&gt;
&lt;p&gt;　　在发生 Minor GC 时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间，如果大于，则改为 Full GC。如果小于，则查看 HandlePromotionFailure 设置是否允许担保失败，如果允许，那只会进行一次 Minor GC，如果不允许，则也要进行一次 Full GC。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
-XX:-HandlePromotionFailure
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　回到第一个问题，老年代也无法确认是否能够存放GC后新生代转移过来的对象，那么这该怎么办呢?&lt;/p&gt;
&lt;p&gt;　　也就是取之前每一次回收晋升到老年代对象容量的平均大小作为经验值，然后与老年代剩余空间进行比较，来决定是否进行 Full GC，从而让老年代腾出更多的空间。&lt;/p&gt;
&lt;p&gt;　　通常情况下，我们会将 HandlePromotionFaile 设置为允许担保失败，这样能够避免频繁的发生 Full GC。&lt;/p&gt;

</description>
<pubDate>Tue, 20 Aug 2019 23:54:00 +0000</pubDate>
<dc:creator>YSOcean</dc:creator>
<og:description>Java虚拟机详解（六）------内存分配</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ysocean/p/11117359.html</dc:identifier>
</item>
<item>
<title>Swift 基础语法 - xiaoyouPrince</title>
<link>http://www.cnblogs.com/xiaoyouPrince/p/Swift.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaoyouPrince/p/Swift.html</guid>
<description>&lt;p&gt;本文基于Swift 5.0+&lt;/p&gt;
&lt;p&gt;目录如下：&lt;/p&gt;
&lt;h2 id=&quot;toc_1&quot;&gt;常量&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;由 &lt;code&gt;let&lt;/code&gt; 关键字定义&lt;/li&gt;
&lt;li&gt;只能赋值1次&lt;/li&gt;
&lt;li&gt;它的值不要求在编译时期确定，但使用之前必须赋值1次&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;let age1 = 10

let age2: Int 
age2 = 20

func getAge() -&amp;gt; Int{
    return 30
}

let age3 = getAge()
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;常量、变量在初始化之前，都不能使用,如下代码都是错误的&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;let age: Int
var height: Int

print(age)          // 未进行初始化，直接使用，在编译期直接报错
print(height)       // 未进行初始化，直接使用，在编译期直接报错

let age
age = 20            // 常量声明时须直接赋值，由编译期自动推断类型，或者仅设置类型，稍后使用之前赋值一次。
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_2&quot;&gt;标识符&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;标识符（如常量名，变量名，函数名）几乎可以使用任何字符串&lt;/li&gt;
&lt;li&gt;标识符不能以数字开头，不能包含空白字符、制表符、箭头等特殊字符&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;func 🐂🍺(){
    print(666)
}

let 👽 = &quot;ET&quot;
var 🥛 = &quot;milk&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_3&quot;&gt;常见的数据类型&lt;/h2&gt;
&lt;p&gt;Swift 中数据类型，主要分为两大类。值类型(value type) 和 引用类型(reference type)&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;主要分类&lt;/th&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;代表类型&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;值类型 value type&lt;/td&gt;
&lt;td&gt;枚举 enum &lt;/td&gt;
&lt;td&gt;Optional&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;值类型 value type&lt;/td&gt;
&lt;td&gt;结构体 struct&lt;/td&gt;
&lt;td&gt;Bool、Int、Float、Double、Character、&lt;br/&gt; String、Array、Dictionary、Set&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;引用类型 reference type&lt;/td&gt;
&lt;td&gt;类&lt;br/&gt;class &lt;/td&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;let letFloat: Float = 30.0
let letDouble = 30.0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_4&quot;&gt;字面量&lt;/h2&gt;
&lt;p&gt;字面量就是一些直接写出来看到的变量或者常量，如下展示了常用的一些字面量&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 布尔
let bool = true

// 字符串
let string = &quot;Swift&quot;

// 字符 (可存储 ASCII 字符 和 Unicode 字符)。Swift 中字符类型也使用双引号
let character: Character = &quot;🐶&quot;

// 整数
let intDecimal = 17         // 十进制整数
let intBinary = 0b10001     // 二进制
let intOctal = 0o21         // 八进制
let intHeaxDecimal = 0x11   // 十六进制

// 浮点数
let doubleDecimal = 125.0               // 十进制 等价于 1.25e2， 0.125 等价于 12.5e-2
let doubleHeaxDecimal1 = 0xFp2          // 十六进制 等价于 15*2^2 = 60(十进制)
let doubleHeaxDecimal2 = 0xFp-2         // 十六进制 等价于 15*2^-2 = 3.75(十进制)


// 数组, Swift 中数组可以存放 Any 类型数据，此处仅为存放整数
let array: Array = [1,2,3,54]

// 字典, Swift 中字典可以存放 Any 类型数据，此处仅为存放整数
let dictionary: Dictionary = [&quot;name&quot;:&quot;xiaoming&quot;,&quot;height&quot;:&quot;1.7&quot;]

// 十进制数字 12.1875 的如下表示方式
// 12.1875   121.875e-1     十进制
// 0xC.3p0                  十六进制

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;note&lt;br/&gt;整数和浮点数可以添加额外的零或者添加下划线来增强可读性&lt;br/&gt;如：100_000 、 1_000_000_000.000_1 、000123.456&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;类型转换&lt;/h2&gt;
&lt;p&gt;Swift 中的类型都是强类型，不同类型不能进行运算，必须转换成同样的类型才可以运算&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;整数转换&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;let int1: Int16 = 2_000                         // 2000
let int2: Int8 = 1                              // 1
let int3 = int1 + Int16(int2)                   // 2001
let int4: Int = Int(int3) + Int(int1)           // 4001
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;整数/浮点数转换&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;let int = 3                         // 3
let double = 0.14159                // 0.14159
let pi = Double(int) + double       // 3.14159
let intPi = Int(pi)                 // 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;字面量之间可以直接进行运算，是因为数字字面量本身没有明确的类型&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;let result = 3 + 0.14159

// let result = 3 + .14159 // Swift 中不允许写 .14159 代表小数
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;元组（Tuple）&lt;/h2&gt;
&lt;p&gt;元组就是一组元素，使用小括号括起来，元素之间使用逗号分隔。元素之间会形成一个整体，且一一对应.示例代码如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 声明一个元组对象，并打印其第一个元素
let Http404Error = (404,&quot;page not found&quot;)
print(&quot;the error code is \(Http404Error.0)&quot;)

// 声明一个元组等价于元组 Http404Error 这样会给声明的元组内部元素自动赋值
let (statusCode , errorMsg) = Http404Error
print(&quot;the error code is \(statusCode)&quot;)

// 声明一个仅需要一个值的元组等价于 Http404Error，对内部元素自动对应 Http404Error 元素
let (theStatusCode , _) = Http404Error

// 声明一个带参数的元组。
let http200Status = (statusCode: 200,description: &quot;OK&quot;)
print(&quot;the status code is \(http200Status.statusCode)&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;toc_7&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;本文讲述了 Swift 语言中基础的一些语法，作为后续学习的基础，后面会循序渐进学习并总结 Swift 中更深层次的知识。&lt;/p&gt;
</description>
<pubDate>Tue, 20 Aug 2019 18:09:00 +0000</pubDate>
<dc:creator>xiaoyouPrince</dc:creator>
<og:description>Swift 基础语法 本文基于Swift 5.0+ 目录如下： &amp;lt;!--目录--&amp;gt; Swift 基础语法 常量 标识符 常见的数据类型 字面量 类型转换 元组（Tuple） 小结 常量 由</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaoyouPrince/p/Swift.html</dc:identifier>
</item>
<item>
<title>Reactive 漫谈 - 美码师</title>
<link>http://www.cnblogs.com/littleatp/p/11386487.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleatp/p/11386487.html</guid>
<description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;p&gt;Reactive Programming(响应式编程)已经不是一个新东西了。&lt;br/&gt;关于 Reactive 其实是一个泛化的概念，由于很抽象，一些理论性的介绍很容易把人带到沟里去，包括一些语言框架在实现上也会使用不同的一些概念。&lt;/p&gt;
&lt;p&gt;按照 维基百科的解释：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;reactive programming is a declarative programming paradigm concerned with data streams and the propagation of change&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;意思就是，Reactive Programming 就是一种面向数据流、关注变更的声明式编程范式。&lt;br/&gt;面向数据流比较容易理解，而关注变更则说的应该是数据流的特点，比如来自某个界面元素属性的变更(前端领域)、又或是某个后端实体的更新事件(日志)..&lt;/p&gt;
&lt;p&gt;以下面的这个函数为例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;c = a + b;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定义了变量c 是 变量a、变量b 之和，当a=1,b=2时，c的值就是3。&lt;br/&gt;假设我们在程序中执行了这个语句，那么对于一次执行过程所产生的c的值就是确定的(上下文中的a、b变量也是确定的)&lt;br/&gt;但是，如果a、b的值是不确定的呢？即这个语句&lt;strong&gt;仅仅是定义了变量c与 变量a、b 的计算关系&lt;/strong&gt;，那么c 的值就是可变的！&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;a=1,b=1,c=2
a=2,b=2,c=4
a=3,b=2,c=5
...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;简言之，c需要动态的由 a、b 共同来决定：&lt;br/&gt;当 a、b 的值发生变化时，c 的结果要能&lt;strong&gt;及时的做出响应(或者叫反应)&lt;/strong&gt;，以此来保证正确性。&lt;/p&gt;
&lt;p&gt;这应该就是 Reactive(响应式) 的由来了，由于变量 a、b的值可能会不断的变化，于是会形成持续不断的变更事件，也就是事件流，因此 Reactive 是面向流式处理来设计的。&lt;br/&gt;此外，在处理这种&quot;变更的流&quot;时，通常是由异步通知的方式来完成，因此异步化也是其特征之一。&lt;/p&gt;
&lt;p&gt;从现有的一些Reactive框架来看，关于下面的定义则更加的贴切：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Reactive编程 是面向数据流的、异步化的编程范式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201908/242916-20190821005143474-980932639.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图-Reactive-Proactive&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;与Reactive 相对的是Proactive ，后者是一种同步的、轮询式的处理方式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;面向流设计&quot;&gt;面向流设计&lt;/h2&gt;
&lt;p&gt;首先，有别于面向对象编程的思想，在Reactive 范式里面，所有的东西都可以当做流，即 Everything is Stream。&lt;br/&gt;流(Stream) 被作为响应式编程的基本元素，这和其他的编程范式非常类似：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;面向对象设计，基本单位是对象&lt;/li&gt;
&lt;li&gt;面向函数设计，基本单位就是函数&lt;/li&gt;
&lt;li&gt;响应式设计，基本单位就是流..&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;那么流是什么样的东西呢？&lt;/p&gt;
&lt;p&gt;可以是 用户输入、数据结构、缓存、动态变量... 等等！&lt;br/&gt;可以来自 静态的数据集合，或是动态的事件流。&lt;/p&gt;
&lt;h4 id=&quot;案例mvc&quot;&gt;案例：MVC&lt;/h4&gt;
&lt;p&gt;MVC(Model-View-Controller) 是前端设计的标准，这也是用来说明&quot;面向流&quot;的一个很好的例子。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201908/242916-20190821005225356-1415747069.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;图-MVC&lt;/p&gt;
&lt;p&gt;其中，来自于用户的点击操作，会被转换为各种事件传递给 Controller 进行处理。&lt;br/&gt;在这里，我们可以认为这些持续不断的事件形成了&quot;事件流&quot;。 比如一个按钮的点击事件流如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201908/242916-20190821005250641-90993108.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这里，事件流是按时间排序进行处理的。 但你可能会说，这不就是简单的一个事件处理机制嘛?&lt;br/&gt;别着急，基于响应式流可以做更多的事情，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201908/242916-20190821005257985-105420894.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图的每个灰框代表了一个处理方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;buffer(stream.throttle(250ms))，buffer就是缓冲，而throttle 是节流。&lt;br/&gt;这个函数的意思就是对流进行缓冲处理，将250毫秒范围内发生的事件合并到一起。&lt;/li&gt;
&lt;li&gt;map('length of list')，将合并后的列表进行转换，输出为每个列表的长度&lt;/li&gt;
&lt;li&gt;filter(x&amp;gt;=2)，即按照&amp;gt;=2的条件进行过滤。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，使用传统的编程方式也完全可以实现这些逻辑，只是相比之下基于响应式流的处理会更加的优雅，所用代码也会更少。&lt;/p&gt;
&lt;p&gt;上面的这个例子出自于《The introduction to Reactive Programming you've been missing》(英文原文：&lt;a href=&quot;https://gist.github.com/staltz/868e7e9bc2a7b8c1f754&quot; class=&quot;uri&quot;&gt;https://gist.github.com/staltz/868e7e9bc2a7b8c1f754&lt;/a&gt;)，该文章也获得非常多的star，至少有一部分可以说明基于MVC的例子来理解响应式还是比较容易的。当然，除了前端领域之外，也很容易将响应式流的思想扩展到各个方面，包括 Web后端、大数据处理、实时流计算等等。&lt;/p&gt;
&lt;h2 id=&quot;异步化&quot;&gt;异步化&lt;/h2&gt;
&lt;p&gt;异步化处理是响应式编程的另一个重要特征，这里的异步与我们常说的网络IO异步化意思上是相同的，与异步相对的概念是同步。&lt;/p&gt;
&lt;p&gt;下面的案例可以很好的解释两者的区别：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
假设你是一个读书爱好者，某一天你想看《开国大典》这本书，于是你打电话给图书馆的管理员，询问馆内是否有这本书可以借。

同步的方式，管理员在接到电话之后让你等一下，然后去图书室查找一番，几分钟后回来再拿起电话告诉你结果；
异步的方式，管理员把你的电话号码记下来，然后挂掉电话，后面他查找完了再打回电话给你通知结果。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;同步和异步的区别就在于结果通知的方式不同&lt;/strong&gt;，很明显，异步的方式会显得更加的人性化和高效。&lt;br/&gt;因此，&lt;strong&gt;响应式编程通常是采用异步回调的方式，回调方法的调用和控制则会由响应式框架来完成，对于应用开发来说只需要关注回调方法的实现就可以了。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;关于同步、异步，往往会牵扯到阻塞、非阻塞 这两个相似的概念，需注意的是 后者的侧重点不同：&lt;br/&gt;阻塞、非阻塞所关注的是调用者的状态(是否可以停下来做其他事情)的区别&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然谈到了异步，这里提一个著名的设计原则：&lt;strong&gt;好莱坞原则(Hollywood principle)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201908/242916-20190821005331096-1627930857.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;don't call us, we'll call you&lt;/strong&gt;&lt;br/&gt;不要给我们打电话，我们会给你打电话&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;在好莱坞，把简历递交给演艺公司后就只有回家等待。由于演艺公司对整个娱乐圈是完全控制的，演员只能被动式的接受公司的差使，只能在需要的环节中完成自己的演出。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;好莱坞原则的核心是以通知代替轮询，其强调的是使用回调来降低模块间的依赖关系，或是提升消息处理效率。&lt;/p&gt;
&lt;p&gt;与好莱坞原则相关(延伸)的设计模式有许多：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Spring 的依赖注入(DI)，通过将Bean的定义、依赖关系配置到XML文件中，由容器来完成Bean的自动装配。&lt;br/&gt;这样控制权就从具体的 Bean转移到到了容器手上，于是就有了控制反转IoC(Inversion of Control)一词。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;Swing UI框架中大肆使用的 观察者模式(Observer), 我们希望获知某个UI组件的事件变化，可以添加一个ActionListener。&lt;br/&gt;之后Swing将会自动将发生的事件传递到我们的回调方法上(actionPerformed)。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;Reactor 响应器模式，基于事件驱动的一种设计模式，其设定了Service Handler负责派发事件，Service Handler同步获得输入的事件后，进而分发给相应的Request Handler(多路复用)&lt;br/&gt;Reactor 一般是用于NIO的场景，如Netty 的网络处理模型：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201908/242916-20190821005355166-810774251.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意到了吗？这些设计模式都不约而同使用了回调！，当然在Reactive 范式中也必然离不开这点。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;或许，100 种设计模式中，调整一下角度，可以归纳为10种甚至更少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;响应式宣言&quot;&gt;响应式宣言&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.reactivemanifesto.org/&quot; class=&quot;uri&quot;&gt;https://www.reactivemanifesto.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了上述的两大特征之外，还需要提到的一个东西叫 Reactive Manifesto(响应式宣言)，这个是由Lightbend 公司发起的。 它的前身是Typesafe，大名鼎鼎的Scala 就是其发明的。 还有流行的Web后端框架 Playframework 也出自于此。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;Playframework 的底层是基于Scala的(可同时支持Java和Scala开发)，同时也包含了NIO、Reactive的各种特性，不少国外的企业如Linkin、Verizon 都在使用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是，有了响应式宣言之后，Reactive开始得到了正名，随后的Akka、Rx系列、包括Spring生态 都纷纷加入了这个队列。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/242916/201908/242916-20190821005408651-531271183.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这个宣言里面，对于响应式的系统特征定义了四个特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;及时响应(Responsive)：系统能及时的响应请求。&lt;/li&gt;
&lt;li&gt;有韧性(Resilient)：系统在出现异常时仍然可以响应，即支持容错。&lt;/li&gt;
&lt;li&gt;有弹性(Elastic)：在不同的负载下，系统可弹性伸缩来保证运行。&lt;/li&gt;
&lt;li&gt;消息驱动(Message Driven)：不同组件之间使用异步消息传递来进行交互，并确保松耦合及相互隔离。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在响应式宣言的所定义的这些系统特征中，无一不与响应式的流有若干的关系，于是乎就有了 2013年发起的 &lt;strong&gt;响应式流规范(Reactive Stream Specification)&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.reactive-streams.org/&quot; class=&quot;uri&quot;&gt;https://www.reactive-streams.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其中，对于响应式流的处理环节又做了如下定义：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;具有处理无限数量的元素的能力，即允许流永不结束&lt;/li&gt;
&lt;li&gt;按序处理&lt;/li&gt;
&lt;li&gt;异步地传递元素&lt;/li&gt;
&lt;li&gt;实现非阻塞的负压(back-pressure)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;负压这个概念或许有些陌生，但本质是为了协调流的处理能力提出的，对于流处理来说会分为 Publisher(发布者) 和Subscriber(订阅者)两个角色，可看做生产者与消费者的模式。当发布者产生的消息过快时，订阅者的处理速度可能会跟不上，此时可能会导致一系列的系统问题。 因此负压的目的就是定义一种反馈机制，让订阅者(消费方)向发布者告知其自身的状态(包括处理速度)，&lt;br/&gt;尽可能让发布方作出调整，本质上是一种系统自我保护的手段。 说到这里，不得不想到TCP的 MTU协商了。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Java 9 平台开始支持 Reactive Stream API&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于Reactive Stream 规范的定义可以参考这篇翻译：&lt;br/&gt;&lt;a href=&quot;https://github.com/yelf2000/rxjava/wiki/Reative-Streams-%E8%A7%84%E8%8C%83&quot;&gt;https://github.com/yelf2000/rxjava/wiki/Reative-Streams-%E8%A7%84%E8%8C%83&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么要使用Reactive&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回答这个问题并不容易，一定是要从 Reactive 编程中获得一定好处了之后才能解答，当然不同人的看法也不一样。&lt;br/&gt;就笔者浅显的看法来说，&lt;strong&gt;Reactive响应式编程提出了一种更高级的抽象，将数据的处理方式沉淀到可复用的库之后可以提高开发的效率。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实质上， Reactive响应式始终是一种模式，只是在不同的框架体系中产生了各种五花八门的说法，导致初学者非常容易迷路。&lt;br/&gt;光是Java语言中的 RxJava、Reactor、Java 9 这些不同类库的接口概念就有不少差异，更不用说跨语言了。&lt;/p&gt;
&lt;p&gt;对此，下面的这篇文章有比较详细的解读，值得一看：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://yq.aliyun.com/articles/617709&quot; class=&quot;uri&quot;&gt;https://yq.aliyun.com/articles/617709&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;极客学院译文-响应式编程介绍&lt;br/&gt;&lt;a href=&quot;https://wiki.jikexueyuan.com/project/android-weekly/issue-145/introduction-to-RP.html&quot; class=&quot;uri&quot;&gt;https://wiki.jikexueyuan.com/project/android-weekly/issue-145/introduction-to-RP.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Java 平台 Reactive编程&lt;br/&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/article/1073888&quot; class=&quot;uri&quot;&gt;https://cloud.tencent.com/developer/article/1073888&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;the-hollywood-principle(好莱坞原则)&lt;br/&gt;&lt;a href=&quot;https://dzone.com/articles/the-hollywood-principle&quot; class=&quot;uri&quot;&gt;https://dzone.com/articles/the-hollywood-principle&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;维基百科- Reactive Programing&lt;br/&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Reactive_programming&quot; class=&quot;uri&quot;&gt;https://en.wikipedia.org/wiki/Reactive_programming&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 20 Aug 2019 16:57:00 +0000</pubDate>
<dc:creator>美码师</dc:creator>
<og:description>[TOC] 概念 Reactive Programming(响应式编程)已经不是一个新东西了。 关于 Reactive 其实是一个泛化的概念，由于很抽象，一些理论性的介绍很容易把人带到沟里去，包括一些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/littleatp/p/11386487.html</dc:identifier>
</item>
<item>
<title>逆向破解之160个CrackMe —— 014 - 寂夜云</title>
<link>http://www.cnblogs.com/lonenysky/p/11383769.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lonenysky/p/11383769.html</guid>
<description>&lt;p&gt;160 CrackMe 是比较适合新手学习逆向破解的CrackMe的一个集合一共160个待逆向破解的程序&lt;/p&gt;
&lt;p&gt;CrackMe:它们都是一些公开给别人尝试破解的小程序，制作 crackme 的人可能是程序员，想测试一下自己的软件保护技术，也可能是一位 cracker，想挑战一下其它 cracker 的破解实力，也可能是一些正在学习破解的人，自己编一些小程序给自己破。&lt;/p&gt;
&lt;p&gt;CrackMe简称CM。&lt;/p&gt;

&lt;div class=&quot;para&quot; readability=&quot;6.7789473684211&quot;&gt;
&lt;h2&gt;&lt;a href=&quot;https://www.cnblogs.com/lonenysky/p/11383769.html%20&quot; target=&quot;_blank&quot;&gt;来源&lt;/a&gt; &amp;lt;-点击查看&lt;/h2&gt;
&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;编号&lt;/td&gt;
&lt;td&gt;作者&lt;/td&gt;
&lt;td&gt;保护方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;014&lt;/td&gt;
&lt;td&gt;bjanes&lt;/td&gt;
&lt;td&gt;Serial(VB5)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;h2&gt;工具 &lt;/h2&gt;
&lt;p&gt;x32dbg&lt;/p&gt;
&lt;p&gt;VB Decompiler Pro&lt;/p&gt;
&lt;p&gt;peid&lt;/p&gt;


&lt;p&gt;首先使用peid查壳，发现是VB的程序&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190820162048902-1295694957.png&quot; alt=&quot;&quot; width=&quot;395&quot; height=&quot;227&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用x32dbg打开014号程序，查找字符串&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190820162139531-1055934249.png&quot; alt=&quot;&quot; width=&quot;854&quot; height=&quot;113&quot;/&gt;&lt;/p&gt;
&lt;p&gt;找到了报错字符串，双击进入报错字符串地址，在上方跳转处下断点，运行发现并没有拦截到断点处，可能断点地址是错误的&lt;/p&gt;
&lt;p&gt;我们按Ctrl+B  输入“&lt;span&gt;816C24&lt;/span&gt;” 这是VB的按钮事件，在这里我们要选择整块，不然搜索不到，点击确定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190820162433296-546310828.png&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;495&quot;/&gt;&lt;/p&gt;
&lt;p&gt;搜索到五处地址，我们在五处地址上分别下断点&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190820162555066-891905864.png&quot; alt=&quot;&quot; width=&quot;527&quot; height=&quot;140&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在程序上输入任意数据，点击Check it按钮，程序停在了我们的断点处，&lt;span&gt;F7&lt;/span&gt;两次进入&lt;span&gt;第一个jmp&lt;/span&gt; ,单步向下走&lt;/p&gt;
&lt;p&gt;此时我们来到了&lt;span&gt;00403A04&lt;/span&gt;地址处，发现在该出跳转，跳转到了错误的提示字符，我们将&lt;span&gt;JNE&lt;/span&gt;改为&lt;span&gt;NOP&lt;/span&gt;运行&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190820162928166-440042556.png&quot; alt=&quot;&quot; width=&quot;947&quot; height=&quot;315&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bingo  爆破成功~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190820163053041-1868678904.png&quot; alt=&quot;&quot; width=&quot;334&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;

&lt;p&gt;使用VB Decompiler Pro打开014号程序 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190820173206396-1837395661.png&quot; alt=&quot;&quot; width=&quot;625&quot; height=&quot;350&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将反编译代码转换为Python代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
code = ''&lt;br/&gt;for i in range(1, 10):&lt;br/&gt;a = i ^ 2&lt;br/&gt;code = code + str(a)[-1]&lt;br/&gt;print(code)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得出结果为&lt;span&gt;301674501&lt;/span&gt;我们输入到输入框内，点击Check it按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190821000030462-1105299732.png&quot; alt=&quot;&quot; width=&quot;284&quot; height=&quot;139&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bingo ~答案正确&lt;/p&gt;
&lt;p&gt;在这里我们需要看一下汇编代码，在汇编中计算异或后我们得到的是一个一位数，8和9的循环计算答案是两位数，这里我们需要细心观察一下反编译代码中Right指的是右边的一位，所以就是8和9循环中异或计算值的右边一位，也就是最后一位。&lt;/p&gt;

</description>
<pubDate>Tue, 20 Aug 2019 16:04:00 +0000</pubDate>
<dc:creator>寂夜云</dc:creator>
<og:description>CrackMe —— 014 160 CrackMe 是比较适合新手学习逆向破解的CrackMe的一个集合一共160个待逆向破解的程序 CrackMe:它们都是一些公开给别人尝试破解的小程序，制作 c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lonenysky/p/11383769.html</dc:identifier>
</item>
<item>
<title>重学计算机网络(二) - 曾记否,查IP地址 - JavaEdge</title>
<link>http://www.cnblogs.com/JavaEdge/p/11386238.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JavaEdge/p/11386238.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1752328/cyt6u5rhid.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先献上几个梗&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1.1.1.1 不是测试用的，原来一直没分配，现在被用来做一个DNS了，宣传是比谷歌等公司的dns服务&lt;br/&gt;更保护用户隐私。&lt;/li&gt;
&lt;li&gt;IP地址255.255.255.255，代表有限广播，它的目标是网络中的所有主机。&lt;/li&gt;
&lt;li&gt;IP地址0.0.0.0，通常代表未知的源主机。当主机采用DHCP动态获取IP地址而无法获得合法IP地址时，会用IP地址0.0.0.0来表示源主机IP地址未知。&lt;/li&gt;
&lt;li&gt;NID不能以数字127开头。NID 127被保留给内部回送函数,作为本机循环测试使用。&lt;br/&gt;例如，使用命令ping 127.0.0.1测试TCP/IP协议栈是否正确安装。在路由器中，同样支持循环测试地址的使用。1 查ip&lt;/li&gt;
&lt;li&gt;Windows - ipconfig&lt;/li&gt;
&lt;li&gt;Linux上- ifconfig&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;还有--- &lt;strong&gt;ip addr&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ifconfig &amp;amp; ip addr的区别&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;net-tools起源于BSD，自2001年起，Linux社区已经对其停止维护，而iproute2旨在取代net-tools，并提供了一些新功能。一些Linux发行版已经停止支持net-tools，只支持iproute2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;net-tools通过procfs(/proc)和ioctl系统调用去访问和改变内核网络配置，而iproute2则通过netlink套接字接口与内核通讯。&lt;/p&gt;
&lt;p&gt;net-tools中工具的名字比较杂乱，而iproute2则相对整齐和直观，基本是ip命令加后面的子命令。&lt;/p&gt;
&lt;p&gt;虽然取代意图很明显，但是这么多年过去了，net-tool依然还在被广泛使用，最好还是两套命令都掌握吧。&lt;/p&gt;
&lt;p&gt;想象你登录进入一个非常小的Linux系统，发现既没有_ifconfig_命令，也没有_ip addr_命令，&lt;/p&gt;
&lt;p&gt;是不是感觉这个系统没法用？&lt;/p&gt;
&lt;p&gt;可以自行安装net-tools和iproute2这两个工具&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运行ip addr。不出意外，应该会输出下面的内容&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1752328/82jzge91jg.png&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;该命令显示这台机器上所有的网卡&lt;/p&gt;
&lt;p&gt;大部分的网卡都有一个IP地址&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IP地址是一个网卡在网络世界的通讯地址，相当于我们现实世界的门牌号码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然是门牌号，不能大家都一样，不然就会冲突,快递就找不到地方了&lt;/p&gt;
&lt;p&gt;所以，有时候咱们的电脑弹出网络地址冲突，出现上不去网的情况，多半是IP地址冲突&lt;/p&gt;
&lt;p&gt;如上输出的结果，192.168.10.208就是一个IP地址&lt;/p&gt;
&lt;p&gt;地址被点分隔为四个部分，每个部分8bit，总共32位&lt;/p&gt;
&lt;p&gt;这样产生的IP地址的数量很快就不够用了&lt;/p&gt;
&lt;p&gt;于是就有了IPv6，也就是上面输出结果里面inet6 fe80::...&lt;/p&gt;
&lt;p&gt;这个有128位，现在看来是够够的&lt;/p&gt;
&lt;p&gt;本来32位的IP地址就不够，还被分成了5类。现在想想，当时分配地址的时候，真是太奢侈了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1752328/ahm1fa9bqx.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在网络地址中，至少在当时设计的时候，对于A、B、 C类主要分两部分&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前面一部分是网络号&lt;/li&gt;
&lt;li&gt;后面一部分是主机号&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这很好理解，大家都是六单元1001号&lt;/p&gt;
&lt;p&gt;我是小区A的六单元1001号&lt;/p&gt;
&lt;p&gt;而你是小区B的六单元1001号。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;下面这个表格，详细地展示了A、B、C三类地址所能包含的主机的数量&lt;br/&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1752328/iu04jhmf47.png&quot;/&gt;&lt;br/&gt;这里面有个尴尬的事情，就是C类地址能包含的最大主机数量实在太少了，只有254个&lt;br/&gt;当时设计的时候恐怕没想到，现在估计一个网吧都不够用吧&lt;br/&gt;而B类地址能包含的最大主机数量又太多了。6万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这打破了原来设计的几类地址的做法，将32位的IP地址一分为二&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前面是网络号&lt;/li&gt;
&lt;li&gt;后面是主机号&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;10.100.122.2/24，这个IP地址中有一个斜杠，斜杠后面有个数字24&lt;/p&gt;
&lt;p&gt;这种地址表示形式，就是&lt;strong&gt;CIDR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;后面24的意32位中前24是网络号，后8位是主机号&lt;/p&gt;
&lt;p&gt;伴随着CIDR存在的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个是&lt;strong&gt;广播地址&lt;/strong&gt;&lt;br/&gt;10.100.122.255 如果发送这个地址，所有10.100.122网络里面的机器都可以收到&lt;/li&gt;
&lt;li&gt;另一个是&lt;strong&gt;子网掩码&lt;/strong&gt;&lt;br/&gt;255.255.255.0&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;将子网掩码和IP地址进行AND计算,就可得到&lt;strong&gt;网络号&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;前面三个255，转成二进制都是1&lt;br/&gt;1和任何数值取AND，都是原来数值，因而前三个数不变，为10.100.122&lt;/li&gt;
&lt;li&gt;后面一个0，转换成二进制是0&lt;br/&gt;0和任何数值取AND，都是0，因而最后一个数变为0，合起来就是10.100.122.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;日常工作，几乎不用划分A类、B类或者C类，很多人就忘记了这个分类，只记得CIDR&lt;/p&gt;
&lt;p&gt;但是有一点还是要注意的，就是&lt;strong&gt;公有IP地址和私有IP地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1752328/rftycekj7l.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的表格。表格最右列是私有IP地址段&lt;/p&gt;
&lt;p&gt;平时看到的数据中心里，办公室/家/学校的IP地址，一般都是私有IP地址段&lt;/p&gt;
&lt;p&gt;因为这些地址允许组织内部的IT人员自己管理、分配，而且可重复&lt;/p&gt;
&lt;p&gt;因此，你学校的某个私有IP地址段和我学校的可以是一样的。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这就像每个小区有自己的楼编号和门牌号，你们小区可以叫6栋，我们小区也叫6栋，没有任何问题&lt;br/&gt;但是一旦出了小区，就需要使用公有IP地址。就像人民路888号，是国家统一分配的，不能两个小区都叫人民路888号。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;公有IP地址有个组织统一分配，你需要去买&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你搭建一个网站，给你学校的人使用，让你们学校的IT人员给你一个IP地址就行&lt;/p&gt;
&lt;p&gt;但是假如你要做一个类似网易163这样的网站，就需要有公有IP地址，这样全世界的人才能访问。&lt;/p&gt;
&lt;p&gt;表格中的&lt;strong&gt;192.168.0.x&lt;/strong&gt;是最常用的私有IP地址&lt;/p&gt;
&lt;p&gt;你家里有Wi-Fi，对应就会有一个IP地址。一般你家里地上网设备不会超过256个，所以/24基本就够了&lt;/p&gt;
&lt;p&gt;有时候我们也能见到/16的CIDR，这两种是最常见的，也是最容易理解的。&lt;/p&gt;
&lt;p&gt;不需要将十进制转换为二进制32位，就能明显看出192.168.0是网络号，后面是主机号&lt;/p&gt;
&lt;p&gt;而整个网络里面的第一个地址192.168.0.1，往往就是你这个私有网络的出口地址&lt;/p&gt;
&lt;p&gt;例如，你家里的电脑连接Wi-Fi，Wi-Fi路由器的地址就是192.168.0.1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ask.qcloudimg.com/http-save/1752328/n3r1rqg895.png&quot;/&gt;而192.168.0.255就是广播地址。一旦发送这个地址，整个192.168.0网络里面的所有机器都能收到。&lt;/p&gt;
&lt;p&gt;但是也不总都是这样的情况。因此，其他情况往往就会很难理解，还容易出错。&lt;/p&gt;

&lt;p&gt;我们来看16.158.165.91/22这个CIDR&lt;/p&gt;
&lt;p&gt;求一下这个网络的第一个地址、子网掩码和广播地址&lt;/p&gt;
&lt;p&gt;你要是上来就写16.158.165.1，那就大错特错!!!&lt;/p&gt;
&lt;p&gt;/22不是8的整数倍，不好办，只能先变成二进制来看&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;16.158的部分不会动，它占了前16位&lt;/li&gt;
&lt;li&gt;中间的165，变为二进制为‭10100101‬。除了前面的16位，还剩6位。所以，这8位中前6位是网络号，16.158.&amp;lt;101001&amp;gt;，而&amp;lt;01&amp;gt;.91是机器号。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一个地址是16.158.&amp;lt;101001&amp;gt;&amp;lt;00&amp;gt;.1，即16.158.164.1&lt;/p&gt;
&lt;p&gt;子网掩码是255.255.&amp;lt;111111&amp;gt;&amp;lt;00&amp;gt;.0，即255.255.252.0&lt;/p&gt;
&lt;p&gt;广播地址为16.158.&amp;lt;101001&amp;gt;&amp;lt;11&amp;gt;.255，即16.158.167.255。&lt;/p&gt;
&lt;p&gt;D类是&lt;strong&gt;组播地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用这一类地址，属于某个组的机器都能收到&lt;/p&gt;
&lt;p&gt;这有点类似在公司里面大家都加入了一个邮件组。发送邮件，加入这个组的都能收到&lt;/p&gt;
&lt;p&gt;在IP地址的后面有个scope&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于eth0这张网卡来讲，是global，说明这张网卡是可以对外的，可以接收来自各个地方的包&lt;/li&gt;
&lt;li&gt;对于lo来讲，是host，说明仅可以供本机相互通信。&lt;br/&gt;lo全称是loopback，又称&lt;strong&gt;环回接口&lt;/strong&gt;，往往会被分配到127.0.0.1这个地址&lt;br/&gt;这个地址用于本机通信，经过内核处理后直接返回，不会在任何网络中出现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在IP地址的上一行是link/ether fa:16:3e:c7:79:75 brd ff:ff:ff:ff:ff:ff&lt;/p&gt;
&lt;p&gt;这个被称为&lt;strong&gt;MAC地址&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是一个网卡的物理地址，用十六进制，6个byte表示&lt;/p&gt;
&lt;p&gt;MAC地址号称全局唯一，不会有两个网卡有相同的MAC地址，而且网卡自生产出来，就带着这个地址&lt;/p&gt;
&lt;p&gt;很多人看到这里就会想，既然这样，整个互联网的通信，全部用MAC地址好了，只要知道了对方的MAC地址，就可以把信息传过去。&lt;/p&gt;
&lt;p&gt;这样当然是不行的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;一个网络包要从一个地方传到另一个地方，除了要有确定的地址，还需要有定位功能&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;而有门牌号码属性的&lt;code&gt;IP地址，才是有远程定位功能&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;例如，你去XX市XX路XX号X楼X层找XX，你在路上问路，可能被问的人不知道X楼是哪个，但是可以给你指网商路怎么去&lt;br/&gt;但是如果你问一个人，你知道这个身份证号的人在哪里吗？可想而知，没有人知道。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;MAC地址更像是身份证，是一个唯一的标识&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;它的唯一性设计是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突&lt;/p&gt;
&lt;p&gt;从硬件角度，保证不同的网卡有不同的标识。&lt;/p&gt;
&lt;p&gt;MAC地址是有一定定位功能的，只不过范围非常有限&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;你可以根据IP地址，找到XX市XX路XX号X楼X层，但是依然找不到我，你就可以靠吼了，大声喊身份证XXXX的是哪位？我听到了，我就会站起来说，是我啊&lt;br/&gt;但是如果你在上海，到处喊身份证XXXX的是哪位，我不在现场，当然不会回答，因为我在杭州不在上海。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，MAC地址的通信范围比较小，局限在一个子网里面&lt;/p&gt;
&lt;p&gt;例如，从192.168.0.2/24访问192.168.0.3/24是可以用MAC地址的&lt;/p&gt;
&lt;p&gt;一旦跨子网，即从192.168.0.2/24到192.168.1.2/24，MAC地址就不行了，需要IP地址起作用了&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/em&gt; 叫&lt;strong&gt;net_device flags，网络设备的状态标识&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;UP&lt;br/&gt;网卡处于启动的状态&lt;/li&gt;
&lt;li&gt;BROADCAST&lt;br/&gt;网卡有广播地址，可以发送广播包&lt;/li&gt;
&lt;li&gt;MULTICAST&lt;br/&gt;网卡可以发送多播包&lt;/li&gt;
&lt;li&gt;LOWER_UP&lt;br/&gt;L1是启动的，也即网线插着呢&lt;/li&gt;
&lt;li&gt;MTU1500&lt;br/&gt;最大传输单元MTU为1500，这是以太网的默认值。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;网络包是层层封装的&lt;/p&gt;
&lt;p&gt;MTU是二层MAC层的概念。MAC层有MAC的头，以太网规定连MAC头带正文合起来，不允许超过1500个字节。正文里面有IP的头、TCP的头、HTTP的头。如果放不下，就需要分片来传输。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;qdisc pfifo_fast (queueing discipline，排队规则)&lt;br/&gt;内核如果需要通过某个网络接口发送数据包，它都需要按照为这个接口配置的qdisc（排队规则）把数据包加入队列。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最简单的qdisc是pfifo，它不对进入的数据包做任何的处理，数据包采用先入先出的方式通过队列&lt;/p&gt;
&lt;p&gt;pfifo_fast稍微复杂一些，它的队列包括三个波段（band）。在每个波段里面，使用先进先出规则。&lt;/p&gt;
&lt;p&gt;三个波段（band）的优先级也不相同。band 0的优先级最高，band 2的最低。如果band 0里面有数据包，系统就不会处理band 1里面的数据包，band 1和band 2之间也是一样。&lt;/p&gt;
&lt;p&gt;数据包是按照&lt;strong&gt;服务类型（Type of Service，TOS）&lt;/strong&gt; 被分配到三个波段（band）里面的&lt;/p&gt;
&lt;p&gt;TOS是IP头里面的一个字段，代表了当前的包是高优先级的，还是低优先级的。&lt;/p&gt;
&lt;p&gt;队列是个好东西，后面我们讲云计算中的网络的时候，会有很多用户共享一个网络出口的情况，这个时候如何排队，每个队列有多粗，队列处理速度应该怎么提升，我都会详细为你讲解。&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;IP是地址，有定位功能；MAC是身份证，无定位功能&lt;/li&gt;
&lt;li&gt;CIDR可以用来判断是不是本地人&lt;/li&gt;
&lt;li&gt;IP分公有的IP和私有的IP&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;趣谈网络协议&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 20 Aug 2019 15:09:00 +0000</pubDate>
<dc:creator>JavaEdge</dc:creator>
<og:description>先献上几个梗 1.1.1.1 不是测试用的，原来一直没分配，现在被用来做一个DNS了，宣传是比谷歌等公司的dns服务 更保护用户隐私。 IP地址255.255.255.255，代表有限广播，它的目标是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JavaEdge/p/11386238.html</dc:identifier>
</item>
</channel>
</rss>