<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>入职国企一周 - SAP梦心</title>
<link>http://www.cnblogs.com/saper/p/14055019.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/saper/p/14055019.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;欢迎关注微信公众号：sap_gui （ERP咨询顾问之家）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;span&gt;每次跳槽我都会写一篇入职一周的文章，这次也不例外，但却已经有点不知道该怎么起笔了。按道理来说今年行情如此特殊，再加上目前工作环境也还可以，有地位，做事比较权威，业务部门认可度高，似乎没有太多理由去跳槽。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其实接到G公司第一通电话的时候，我是有点不太上心的，因为对它不了解，也因为招聘网上挂的岗位自己不是很看得上。事后我详细了解了一下，加上HR说有更高阶的，于是也终于开始认真起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;整个过程很简单，周一面试，周二在线测验，周三确认结果，周五流程审批通过，再隔了一个周末Offer就收到了，一切来得非常快。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;提交离职申请的一刹那确实有点百感交集，这跟我之前的规划有点冲突了，这一切来得比较突然。也许能让我怀念的就是在这里可以让我“唯我独尊”得工作，财务部营销部那高到爆棚的认可度。在很多人看来我甚至有点“功成身退”的感觉，或者说，是“惋惜”。但不管有多少人不舍得，我都觉得人就是要跟着自己的信念、跟着初心走。至于初心是什么，信念又是啥，很多不可明说，自己很清楚即可。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，还是在此说一声再见。再见了，一天4次的打卡；再见了，满是坑的系统；再见了，互相信任的同事们；再见了，最不舍的销产供项目；再见了，J公司。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第一天：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这算是我第一次坐班车上班，而且班车刚好就停在小区门口，简直不能再方便了。G公司有一个之前的同事也是住附近，刚好这次约好一起坐车。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;周一早上还是有些堵车，意外发现车子居然也经过了之前公司附近，一时间感慨万千。班车差不多开了25分钟才到公司楼下，其实路程并不远，主要还是红绿灯堵车较多。一下车跟着很多穿正装的人一起走进宏伟整洁的公司大门，仿佛置身于电影场景里面，不再是之前那种庸碌疲于奔波的样子，而是真正都市白领造气蓬勃的那种奇妙的感觉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同事将我领到办公室，刚好之前面试我的领到也在，后面简单聊了一下，发现这是一个技术型的领导，也会负责一些工作事项，跟之前那些公司那些只会要PPT文档，只安排工作的风格完全不同，他是时时刻刻知道下属在干嘛，会跟大家一起讨论技术、制定计划、分析方案，业务能力扎实，系统解决能力过硬。这类领导我较少遇到，不过却真心欣赏喜欢这样的，没有那么多心眼和官架子，相处起来比较随和。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;之后就是到HR那边提交各种材料和签合同，以及一些事项，表过不提。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为新员工入职需要申请购置新电脑，所以我暂时用自己的电脑，域账号还没申请下来，于是借用同事的电脑申领办公用品。发现申领办公用品非常有趣，是在内网上一个类似京东淘宝的网站选择你所需要的办公用品，如计算器、剪刀、排插、笔记本、笔等，提交上去直接到其他楼层找前台领即可，不需要任何人审批。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;领导安排一个老员工引领我熟悉工作环境和系统，讲述当前项目的一些情况和业务，也带领我去其他楼层的业务部门走了一圈，与其他业务人员认识。来之前我还担心国企的同事人际关系会跟其他公司不同，看来是我想多了，其实这边同事都非常的热心，待人彬彬有礼，而且平时大家都会互相聊天开玩笑。就连供方都非常有礼貌和专业，想到之前那些牛鬼蛇神，这也算是刷新了我对供方的认知了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;公司有专门的公共Wifi，自己的笔记本以及大家的手机都可以无限制连上去使用，而且网络没有任何的限制。后来域账号下来了，本以为会跟之前公司那样麻烦，没想到这个“域账号”更像是一个专门的账号验证中心或者网络认证，链接特定的内部Wifi网络之后，填入域账号和密码就完了，就可以登录所有的内部系统如SAP、OA等，电脑不用重启也没有任何的管理员限制（比如安装软件限制等），就连网络也没有任何的浏览限制，微信和QQ都能登录，不需要额外的申请。这更是刷新了我对“域控”和网络权限管理的认知，我想，它更是属于一种Wifi网络的认证吧，但其实公司已经把它拓展到很多的系统认证层级了，真正做到一个账号走天下，个人觉得有点像中台会员/账号中心的基础雏形了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有了域账号，我就开始申请购置笔记本，有八千元的额度，思来想去，我选了联想(Lenovo)YOGA 14c 2021款 14英寸全面屏超轻薄笔记本电脑(i7-1165G7 16G 512G 翻转触控 高色域) ，满足了性能和轻薄的要求。之前公司那i5和4G内存、13.3英寸的笔记本，那卡顿的场景终于一去不复返了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;习惯了中午下班的铃声，这边12点一到什么声音都没有，要不是看到同事陆陆续续起身去吃饭，我都忘了时间。公司食堂有2层，其中一层还是清真食堂。因为电梯足够强大和足够多，基本上下楼吃饭不怎么要排队，而排队取餐就免不了了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;食堂吃饭是要收费的，好在公司每月有餐费补贴（是真补贴），水饺、快餐、咸饭、沙茶面、拉面等等选择很多。在有自己免费食堂的公司干活，员工是真的很幸福（这也是我一直很怀念Leedarson的原因）！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中午休息2个小时，都是在看文档看资料，同事带我下去业务部门认识了一圈，简单介绍一下。这里办公人员很多，大家都比较忙，看着场景，我突然想起一些电影的场景：在人山人海热火朝天的办公室里，每个人都在忙，打电话递文件，充实且美妙。我原以为国企很多人都在里面养老，不干活整天浑水摸鱼，看来，这个世界对国企的误会真的太深了。这些业务人员未来我打交道会非常的多，我都有点迫不及待了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下班时间是5点半，同事负责的系统今天发包要加班，就我一个人坐班车回了。班车5点50分发出，走过早上过来的路，看着外面灯火辉煌，车来车往，恍惚间有点心乱神迷。差不多6点15分下车。这个时间点刚好是上家公司的下班时间点。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就这样，第一天结束了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第二天：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天的工作内容主要还是看目前在上线的也是在负责的一个协同平台相关的文档和流程图，它的项目目的和逻辑有点跟之前在包装公司所做的ICC项目一样，看了这个系统的原型图，总的来说还算比较规整整齐，想起那年那套ICC系统，我主要负责后端SAP系统，ICC整套系统扩展性和架构都不太好，不过感觉现在应该会比之前的好很多。总的来说，这些供应链整合平台的业务流程和设计其实不难理解，难的是要对整个业务乃至多种交易场景进行更好更深入的熟悉和掌握。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下班的时候临时被叫去领导办公室开会讨论一个关于交货改单的问题，说实在的，这也是我第一次遇到采购合同/订单跟后续交货单不同SKU的情况，看来每个行业都有自己的特殊性，真的是隔行如隔山，跳得也多，见识到各种业务场景也越多。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;原理和业务并不复杂，复杂的是怎么更好通过系统实现，更快更高效解决用户的问题。领导也真是技术型，会跟着我们一起讨论方案，提供各种点子思路。将军带兵上阵杀敌，士兵会更勇猛，奋勇杀敌，我想，这是一种魅力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;因为加班所以错过了班车，只好到楼下等公交车回去，到BRT转车。下班高峰期车子非常难等，人也非常多，想起那年在钟宅挤车去软件园的情景。原本几分钟的车程硬是堵了十几分钟，好在公司有员工班车，非常方便，不然的话这每天上下班交通绝对让人哭死！&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第三天：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天工作内容开始涉猎SAP系统，同事发给我一份关于SAP里面GTM供应链模块的相关培训文档，我也跟着文档一步一步操作下来。虽然销售订单和采购订单跟SDMM是一样的数据表和画面，但管控和操作过程却完全不同。操作一遍下来，单据凭证关系简直颠覆了我的想象，真的是隔了一个行业就像隔了一座山。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这边因为供应链业务的特殊性，SAP系统上做了非常多的开发，导出都是接口，而且接口都做成了跟合兴一样的数据表行，最后也打包了Webservice。不过跟上家公司不同的是，这些开发程序和接口非常的问题，用起来非常舒服，要不是事务代码是Z开头，我一度怀疑它是标准程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不仅如此，这边还对平常使用较多的如供应商主数据、客户主数据以及物料主数据的操作进行了大大的简化，而且操作都高度集成在一个画面里面，程序代码虽然注释很少，但整体看起来比较规整和清晰，运行起来简直像是艺术品一样，整个操作流程下来没有碰到任何的数据或者程序bug！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此时回想起来3年前我尝试着走一遍C2F的整套单据流，所用到的物料、客户、供应商等等数据都是新创建的，基本上都是走一步卡一步，问过相应系统的负责人，每个人都说对接了，数据集成了，但大家都想当然的理所当然这么认为系统是这样，实际上完全就是行不通。从来没有一个人完全能走得通全部，测试所用的数据都是后台人为更新数据库来完成的，什么系统之间集成都是想当然的以为。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;从京东上买的折叠床到货了，终于可以好好午休了。这里几乎每个人都有一张折叠床，可以放在工位下面，使用起来非常方便，再也不用担心跟别人挤位置了。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第四天：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;今天工作主要是跟顾问确认一个需求，关于入仓修改采购合同的事情。远程连线JD顾问，发现这真是一群比较优雅专业的顾问，跟他们谈论问题和需求的时候，能够比较有耐心和条理，思路也比较清晰，整个沟通下来还是挺顺利的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;想起之前接触的一些顾问，要么谈论需求的时候没有条理，要么就是没耐心或者服务意识不够，都是服务技术行业，人跟人区别还是挺大的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们这边还有一个做开发的同事一起参与对接，按之前的理解，内部开发人员一般也用不着跟顾问和用户对接，而这边很多业务都懂开发，很多开发都熟悉业务，可谓全能。之前以为懂业务和懂开发的人很少，而这边已经集齐了各路高手了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需求谈论完毕，后面顾问发来文档内容也比较有结构化，包括参会人员、谈论议题、会议结论以及后续安排，一件事确定下来他们知道该跟谁确认，以及相关计划调整，都相对比较明确。我想供方的质量决定了项目的成败和质量，我对这个项目整体还是非常有信心的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下午约了一个业务的人员当面大概沟通了他们的一些业务，她比较热心，基本上知无不言，让我对公司买卖的供应链业务有新的理解，之前工作的那套流程和业务思维在这边未必行得通，但好在很多都有一定的共性在，财务端也八九不离十，只是供应链的管理有自己的独特的需求，在SAP上面也是在MMSD上面做了一套解决方案来。没接触过这种业务的人断然是不会理解和经验的，很多人进来基本上要熬一段学习的时间。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;也许今后要多多仰仗这些业务人员，多跟他们接触一下。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;第五天：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;转眼到了入职的第五天，今天一天都是会议，邀请了SAP原厂的顾问过来讲解SAP S4HANA系统。公司所用的SAP系统版本比较老旧，有些许年头了，正好明年计划考虑升级到S4，因公司业务跟其他生产制造业大不一样，况且公司自己的独特需求导致了目前系统里面存在着大量的开发和接口。我想起了第一家公司用的QAD，也是做了非常多的开发，基本上很多的功能都做了自开发，刚开始进去的人是应该好好熟悉一下系统的流程和逻辑。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;听了SAP原厂顾问的介绍，这才发现SAP系统中内外贸以及贸易供应链的解决方案跟之前接触的完全不同，当真是全新的世界，这让我有点犯难起来。不过值得期待的是我正好可以利用这次升级系统的机会从头跟到尾，绝对可以比平时运维更快切入公司业务和熟悉系统，能快速成长起来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中午公司宴请这些远道而来的顾问，这还真是有点新鲜，也体现了公司对人家的重视和诚意。想起之前的公司，我们邀请很多大厂顾问远道而来进行交流，沟通方案，结果领导都不出面，只有我们在会议室跟人家交流，然后聊完还只能拜拜了，送人家都电梯口，公司并没有任何的招待。这就是差距啊！&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;以上，大概便是这次跳槽入职的内容了。整体而言，我对当前环境是即陌生又期待。新的环境，意味着一切从头开始，抛弃了之前那种“生龙活虎”、“唯我独尊”、“我是最权威”的工作环境，来到一个完全陌生，只能先做“乖乖孩子”的地方，&lt;span&gt;这种超级大的落差需要一个适应调整期&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看着每个同事忙得不可开交，甚至晚上下班了还在微信和QQ群里发消息解决问题，我心里是五味杂陈。其实在之前J公司，我也是很忙，不仅要管着整个SAP供应链的项目和需求，还要跟进销产供协同平台，还要负责OMS项目管理，连财务也经常找我谈大需求，忙的时候是真的恨不得一个人掰成几个人来工作，特别是SAP SD模块，因为公司业务的多样和庞大，SD模块的需求很多，经常要跟着前后端变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;但忙并不可怕，怕的是瞎忙，无意义的、填坑式的忙。&lt;/span&gt;J公司系统以及架构其实很多早就定好了的，很多的系统配置和开发也都是早就有了，不管之前做的合不合理，坑大不大，随着业务和流程的变更，总是有很多东西要调整。我经常自嘲说：我做项目的最大收益就是顺便发现和解决了其他几处Bug...&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;还有一点最大的感触就是大家对国企的误会真的太深了，都认为去国企就是混日子，就是养老，人际关系复杂，人云亦云之后大家的观念根深蒂固。真正进来了才发现，哪里有人在养老，领导专业且亲切随和，同事们都非常Nice，都能独当一面，八面玲珑的，都在兢兢业业、勤勉工作，晚上自觉加班，大半夜还有人在群里聊工作的事情，回想之前的环境，到底是谁在养老呢？当真是有一种“找到组织”的感觉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不管怎么样，既然已经抉择了，那就会坚持下去，不放弃！真心希望能够在这边长长久久待下去，发挥自己的价值，获得应有的价值认同~&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Nov 2020 16:24:00 +0000</pubDate>
<dc:creator>SAP梦心</dc:creator>
<og:description>欢迎关注微信公众号：sap_gui （ERP咨询顾问之家） 每次跳槽我都会写一篇入职一周的文章，这次也不例外，但却已经有点不知道该怎么起笔了。按道理来说今年行情如此特殊，再加上目前工作环境也还可以，有</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/saper/p/14055019.html</dc:identifier>
</item>
<item>
<title>K8ssandra——专为Kubernetes云原生数据而生 - DataStax</title>
<link>http://www.cnblogs.com/datastax/p/14054971.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datastax/p/14054971.html</guid>
<description>[unable to retrieve full-text content]DataStax最近发布了K8ssandra——一个开源的、部署于Kubernetes上的Apache Cassandra™全新发行版本。K8ssandra一站式集合了在Kubernetes上部署开源版Apache Cassandra™所需的一切。 Apache Cassandra在可伸缩且零宕机的</description>
<pubDate>Sat, 28 Nov 2020 16:07:00 +0000</pubDate>
<dc:creator>DataStax</dc:creator>
<dc:language>zh-CN</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://account.cnblogs.com:443/signin?ReturnUrl=https%3A%2F%2Fwww.cnblogs.com%2Fdatastax%2Fp%2F14054971.html</dc:identifier>
</item>
<item>
<title>从零开始了解多线程知识之开始篇目 -- jvm＆volatile - 宁剑文</title>
<link>http://www.cnblogs.com/ningjianwen/p/14054949.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ningjianwen/p/14054949.html</guid>
<description>&lt;p&gt;CPU缓存一致性协议，JVM基础知识了解，多线程基础知识了解 本文章主要介绍到到了一些CPU缓存一致性协议的基础知识，由此引出的多线程知识，同时谈到了多线程中数据操作 原子性 可见性 有序性 的问题 从线程的基本概念到多线程下工作的数据安全问题，主要谈到了java知识中volatile关键字，使用实例的模式讲解了 volatile可见性，有序性，指令重排的问题&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;403&quot;&gt;
&lt;p&gt;本文章主要介绍到到了一些CPU缓存一致性协议的基础知识，由此引出的多线程知识，同时谈到了多线程中数据操作 原子性 可见性 有序性 的问题&lt;br/&gt;从线程的基本概念到多线程下工作的数据安全问题，主要谈到了java知识中volatile关键字，使用实例的模式讲解了 volatile可见性，有序性，指令重排的问题&lt;br/&gt;接下来大家一起来学习学习吧&lt;/p&gt;
&lt;p&gt;CPU多核缓存存储结构图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2197806/202011/2197806-20201128234200740-1033443230.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1.电脑存储结构概念&lt;/p&gt;
&lt;p&gt;多CPU&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;     一个现代计算机通常由两个或者多个CPU，如果要运行多个程序（进程）的话，假如只有 一个CPU的话，就意味着要经常进行进程上下文切换
     因为单CPU即便是多核的，也只是多个 处理器核心，其他设备都是共用的，所以多个进程就必然要经常进行进程上下文切换，这个代价是很高的。 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CPU多核&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    一个现代CPU除了处理器核心之外还包括寄存器、L1L2L3缓存这些存储设备、浮点运算 单元、整数运算单元等一些辅助运算设备以及内部总线等。
    一个多核的CPU也就是一个CPU上 有多个处理器核心，这样有什么好处呢？比如说现在我们要在一台计算机上跑一个多线程的程序
    因为是一个进程里的线程，所以需要一些共享一些存储变量，如果这台计算机都是单核单线程CPU的话，就意味着这个程序的不同线程需要经常在CPU之间的外部总线上通信，
    同时还 要处理不同CPU之间不同缓存导致数据不一致的问题，所以在这种场景下多核单CPU的架构就 能发挥很大的优势，通信都在内部总线，共用同一个缓存。 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CPU寄存器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    每个CPU都包含一系列的寄存器，它们是CPU内内存的基础。CPU在寄存器上执行操作的速度远大于在主存上执行的速度。
    这是因为CPU访问寄存器的速度远大于主存。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CPU缓存&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。
    由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，因此出现了CPU缓存
    Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用, 减少CPU的等待时间，提高了系统的效率。 
    CPU缓存包括 一级Cache(L1 Cache) 二级Cache(L2 Cache) 三级Cache(L3 Cache) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内存&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    一个计算机还包含一个主存。
    所有的CPU都可以访问主存。主存通常比CPU中的缓存大得多。 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;CPU读取存储器数据过程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    CPU要取寄存器XX的值，只需要一步：直接读取。 
    CPU要取L1 cache的某个值，需要1-3步（或者更多）：把cache行锁住，把某个数据拿 来，解锁，如果没锁住就慢了。
    CPU要取L2 cache的某个值，先要到L1 cache里取，L1当中不存在，在L2里，L2开始加 锁，加锁以后，把L2里的数据复制到L1，再执行读L1的过程，上面的3步，再解锁。
    CPU取L3 cache的也是一样，只不过先由L3复制到L2，从L2复制到L1，从L1到CPU。 
    CPU取内存则复杂：通知内存控制器占用总线带宽，通知内存加锁，发起内存读请求， 
    等待回应，回应数据保存到L3（如果没有就到L2），再从L3/2到L1，再从L1到CPU，之后解除总线锁定。 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多线程环境下存在的问题&lt;/p&gt;
&lt;p&gt;缓存一致性问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存 （MainMemory）。
基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是 也引入了新的问题：缓存一致性（CacheCoherence）。
当多个处理器的运算任务都涉及同一 块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，
那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都 遵循一些协议，
在读写时要根据协议来进行操作，这类协议有MSI、 MESI（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指令重排序问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，
处理器会在计算之后将乱序执行的结果重组，保证该 结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的 顺序一致。
因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不 能靠代码的先后顺序来保证。
与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有 类似的指令重排序（Instruction Reorder）优化
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2.什么是线程&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个Java程序，操作系统就会创建一个Java进程。
现代操作系统调度CPU的最小单元是线程，也叫轻量级进程，在一个进程里可以创建多个线程，
这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。
处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程的实现可以分为两类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1、用户级线程(User-Level Thread)
2、内核线线程(Kernel-Level Thread)

在了解线程之前，需要知道系统存在两种空间：用户空间和内核空间
其中内核空间只能由内核代码进行方访问，用户代码无法直接访问如果用户代码要访问内核空间，
需要借助内核空间提供的访问接口
系统中用户程序运行在用户方式下，而系统调用运行在内核方式下。
在这两种方式下所用的堆栈不一样：用户方式下用的是一般的堆栈，而内核方式下用的是固定大小的堆栈（一般为一个内存页的大小）

比如一个4G内存的空间，可能只有3GB可以用于用户应用程序。一个进程只能运行在用户方式（usermode）或内核方式（kernelmode）下，
每个进程都有自己的3G用户空间，它们共享1GB的内核空间。当一个进程从用户空间进入内核空间时，它就不再有自己的进程空间了。
这也就是为什么我们经常说线程上下文切换会涉及到用户态到内核态的切换原因所在
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用户线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。
另外，用户线程是由应用进程利用线程库创建和管理，不依赖于操作系统核心。不需要用户态/核心态切换，速度快。
操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞（可理解为串行化的）
由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内核线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;线程的所有管理操作都是由操作系统内核完成的。内核保存线程的状态和上下文信息，
当一个线程执行了引起阻塞的系统调用时，内核可以调度该进程的其他线程执行。
在多处理器系统上，内核可以分派属于同一进程的多个线程在多个处理器上运行，提高进程执行的并行度。
由于需要内核完成线程的创建、调度和管理，所以和用户级线程相比这些操作要慢得多，但是仍然比进程的创建和管理操作要快。
大多数市场上的操作系统，如Windows，Linux等都支持内核级线程。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是用户线程和内核线程的接口图，用户线程空间中，并没有进程-线程对应关系表，但内核线程中有&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2197806/202011/2197806-20201128234303263-713754761.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java线程与系统内核线程关系模型&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2197806/202011/2197806-20201128234351323-1652016261.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Java线程&lt;br/&gt;JVM中创建线程有2种方式&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   1. new java.lang.Thread().start()
   2. 使用JNI将一个native thread attach到JVM中
   针对 new java.lang.Thread().start()这种方式，只有调用start()方法的时候，才会真正的在
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JVM中去创建线程，主要的生命周期步骤有：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 创建对应的JavaThread的instance
2. 创建对应的OSThread的instance
3. 创建实际的底层操作系统的native thread
4. 准备相应的JVM状态，比如ThreadLocal存储空间分配等
5. 底层的native thread开始运行，调用java.lang.Thread生成的Object的run()方法
6. 当java.lang.Thread生成的Object的run()方法执行完毕返回后,或者抛出异常终止后，终止native thread
7. 释放JVM相关的thread的资源，清除对应的JavaThread和OSThread
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;针对JNI将一个native thread attach到JVM中，主要的步骤有：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 通过JNI call AttachCurrentThread申请连接到执行的JVM实例
2. JVM创建相应的JavaThread和OSThread对象
3. 创建相应的java.lang.Thread的对象
4. 一旦java.lang.Thread的Object创建之后，JNI就可以调用Java代码了
5. 当通过JNI call DetachCurrentThread之后，JNI就从JVM实例中断开连接
6. JVM清除相应的JavaThread, OSThread, java.lang.Thread对象
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.为什么用到并发？并发会产生什么问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;并发编程的本质其实就是利用多线程技术，在现代多核的CPU的背景下，催生了并发编程
的趋势，通过并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升。除此之
外，面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分。

即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现
这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切
换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。
并发不等于并行：并发指的是多个任务交替进行，而并行则是指真正意义上的“同时进
行”。实际上，如果系统内只有一个CPU，而使用多线程时，那么真实系统环境下不能并行，
只能通过切换时间片的方式交替进行，而成为并发执行任务。真正的并行也只能出现在拥有多个CPU的系统中。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并发的优点：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1. 充分利用多核CPU的计算能力；
2. 方便进行业务拆分，提升应用性能；
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并发产生的问题：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;高并发场景下，导致频繁的上下文切换
临界区线程安全问题，容易出现死锁的，产生死锁就会造成系统功能不可用
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其它&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。
但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。
所以任务从保存到再加载的过程就是一次上下文切换。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;什么是JMM模型？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Java内存模型(Java Memory Model简称JMM)是一种抽象的概念，并不真实存在，它描
述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构
成数组对象的元素）的访问方式。JVM运行程序的实体是线程，而每个线程创建时JVM都会为
其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数据，而Java内存模型中规
定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，但线程对变量的
操作(读取赋值等)必须在工作内存中进行，首先要将变量从主内存拷贝的自己的工作内存空
间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，
工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区
域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完
成。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JMM不同于JVM内存区域模型 （JVM是是实际存在的，JMM只是逻辑规则）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JMM与JVM内存区域的划分是不同的概念层次，更恰当说JMM描述的是一组规则，通过
这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式，JMM是围绕原子性，有序性、可见性展开。

JMM与Java内存区域唯一相似点，都存在共享数据区域和私有数据区域，在JMM中主内存属于共享数据区域，
从某个程度上讲应该包括了堆和方法区，而工作内存数据线程私有数据区域，
从某个程度上讲则应该包括程序计数器、虚拟机栈以及本地方法栈。

线程，工作内存，主内存工作交互图（基于JMM规范）：
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2197806/202011/2197806-20201128234436059-38146631.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主内存&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 主要存储的是Java实例对象，所有线程创建的实例对象都存放在主内存中，不管该实例对
 象是成员变量还是方法中的本地变量(也称局部变量)，当然也包括了共享的类信息、常量、静
 态变量。由于是共享数据区域，多条线程对同一个变量进行访问可能会发生线程安全问题。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;工作内存&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;主要存储当前方法的所有本地变量信息(工作内存中存储着主内存中的变量副本拷贝)，每
个线程只能访问自己的工作内存，即线程中的本地变量对其它线程是不可见的，就算是两个线
程执行的是同一段代码，它们也会各自在自己的工作内存中创建属于当前线程的本地变量，当
然也包括了字节码行号指示器、相关Native方法的信息。注意由于工作内存是每个线程的私有
数据，线程间无法相互访问工作内存，因此存储在工作内存的数据不存在线程安全问题。

根据JVM虚拟机规范主内存与工作内存的数据存储类型以及操作方式，对于一个实例对象中的成员方法而言，
如果方法中包含本地变量是基本数据类型（boolean,byte,short,char,int,long,float,double），
将直接存储在工作内存的帧栈结构中，但倘若本地变量是引用类型，那么该变量的引用会存储在功能内存的帧栈中，
而对象实例将存储在主内存(共享数据区域，堆)中。但对于实例对象的成员变量，不管它是基本数据类型或者
包装类型(Integer、Double等)还是引用类型，都会被存储到堆区。至于static变量以及类本身
相关信息将会存储在主内存中。需要注意的是，在主内存中的实例对象可以被多线程共享，倘
若两个线程同时调用了同一个对象的同一个方法，那么两条线程会将要操作的数据拷贝一份到
自己的工作内存中，执行完成操作后才刷新到主内存
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模型如下图所示&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2197806/202011/2197806-20201128234515953-575538913.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;JMM存在的必要性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在明白了Java内存区域划分、硬件内存架构、Java多线程的实现原理与Java内存模型的具
体关系后，接着来谈谈Java内存模型存在的必要性。由于JVM运行程序的实体是线程，而每个
线程创建时JVM都会为其创建一个工作内存(有些地方称为栈空间)，用于存储线程私有的数
据，线程与主内存中的变量操作必须通过工作内存间接完成，主要过程是将变量从主内存拷贝
的每个线程各自的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，如
果存在两个线程同时对一个主内存中的实例对象的变量进行操作就有可能诱发线程安全问题。

假设主内存中存在一个共享变量x，现在有A和B两条线程分别对该变量x=1进行操作，
A/B线程各自的工作内存中存在共享变量副本x。假设现在A线程想要修改x的值为2，而B线程
却想要读取x的值，那么B线程读取到的值是A线程更新后的值2还是更新前的值1呢？答案是，不确定，
即B线程有可能读取到A线程更新前的值1，也有可能读取到A线程更新后的值2，
这是因为工作内存是每个线程私有的数据区域，而线程A变量x时，首先是将变量从主内存拷贝到A
线程的工作内存中，然后对变量进行操作，操作完成后再将变量x写回主内，而对于B线程的也
是类似的，这样就有可能造成主内存与工作内存间数据存在一致性问题，假如A线程修改完后
正在将数据写回主内存，而B线程此时正在读取主内存，即将x=1拷贝到自己的工作内存中，
这样B线程读取到的值就是x=1，但如果A线程已将x=2写回主内存后，B线程才开始读取的
话，那么此时B线程读取到的就是x=2，但到底是哪种情况先发生呢？

如图 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2197806/202011/2197806-20201128234553192-1658009676.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;以上关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内
存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完
成。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JMM-同步八种操作介绍&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;（1）lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态
（2）unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
（3）read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用
（4）load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中
（5）use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎
（6）assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量
（7）store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作
（8）write(写入)：作用于工作内存的变量，它把store操作从工作内存中的一个变量的值传送到主内存的变量中

如果要把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，
如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。但Java内
存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2197806/202011/2197806-20201128234623493-478060364.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同步规则分析&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;1）不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中

2）一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。
   即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。

3）一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，
  只有执行相同次数的unlock操作，变量才会被解锁。lock和unlock必须成对出现。

4）如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变
  量之前需要重新执行load或assign操作初始化变量的值。

5）如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。

6）对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作） 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;并发编程的可见性，原子性与有序性问题&lt;/p&gt;
&lt;p&gt;原子性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会
被其他线程影响。
在java中，对基本数据类型的变量的读取和赋值操作是原子性操作有点要注意的是，对于
32位系统的来说，long类型数据和double类型数据(对于基本数据类型，
byte,short,int,float,boolean,char读写是原子操作)，它们的读写并非原子性的，也就是说如
果存在两条线程同时对long类型或者double类型的数据进行读写是存在相互干扰的，因为对
于32位虚拟机来说，每次原子读写是32位的，而long和double则是64位的存储单元，这样会
导致一个线程在写时，操作完前32位的原子操作后，轮到B线程读取时，恰好只读取到了后32
位的数据，这样可能会读取到一个既非原值又不是线程修改值的变量，它可能是“半个变
量”的数值，即64位数据被两个线程分成了两次读取。但也不必太担心，因为读取到“半个变
量”的情况比较少见，至少在目前的商用的虚拟机中，几乎都把64位的数据的读写操作作为原
子操作来执行，因此对于这个问题不必太在意，知道这么回事即可。
X=10;  //原子性（简单的读取、将数字赋值给变量）
Y = x;  //变量之间的相互赋值，不是原子操作
X++;  //对变量进行计算操作
X = x+1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;理解了指令重排现象后，可见性容易了，可见性指的是当一个线程修改了某个共享变量的
值，其他线程是否能够马上得知这个修改的值。对于串行程序来说，可见性是不存在的，因为
我们在任何一个操作中修改了某个变量的值，后续的操作中都能读取这个变量值，并且是修改
过的新值。
但在多线程环境中可就不一定了，前面我们分析过，由于线程对共享变量的操作都是线程
拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享
变量x的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量x进行操作，但
此时A线程工作内存中共享变量x对线程B来说并不可见，这种工作内存与主内存同步延迟现象
就造成了可见性问题，另外指令重排以及编译器优化也可能导致可见性问题，通过前面的分
析，我们知道无论是编译器优化还是处理器优化的重排现象，在多线程环境下，确实会导致程
序轮序执行的问题，从而也就导致可见性问题。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有序性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;有序性是指对于单线程的执行代码，我们总是认为代码的执行是按顺序依次执行的，这样
的理解并没有毛病，毕竟对于单线程而言确实如此，但对于多线程环境，则可能出现乱序现
象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未
必一致，要明白的是，在Java程序中，倘若在本线程内，所有操作都视为有序行为，如果是多
线程环境下，一个线程中观察另外一个线程，所有操作都是无序的，前半句指的是单线程内保
证串行语义执行的一致性，后半句则指指令重排现象和工作内存与主内存同步延迟现象。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;JMM如何解决原子性&amp;amp;可见性&amp;amp;有序性问题?&lt;/p&gt;
&lt;p&gt;原子性问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; 除了JVM自身提供的对基本数据类型读写操作的原子性外，可以通过 synchronized和Lock实现原子性。
 因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见性问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;volatile关键字保证可见性。当一个共享变量被volatile修饰时，它会保证修改的值立即被
其他的线程看到，即修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中读取
新值。synchronized和Lock也可以保证可见性，因为它们可以保证任一时刻只有一个线程能
访问共享资源，并在其释放锁之前将修改的变量刷新到内存中
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有序性问题&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述
volatile关键字）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized
和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就
保证了有序性。

Java内存模型：

每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的
所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他
线程的工作内存。Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得
到保证的有序性，这个通常也称为happens-before 原则。如果两个操作的执行次序无法从
happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它
们进行重排序。

指令重排序：

java语言规范规定JVM线程内部维持顺序化语义。即只要程序的最终结果与
它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排
序。指令重排序的意义是什么？JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）
适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性
能

下图为从源码到最终执行的指令序列示意图
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2197806/202011/2197806-20201128234703625-1097792232.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;as-if-serial语义&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线
    程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。
    为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因
    为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被
    编译器和处理器重排序。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;happens-before 原则&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;只靠sychronized和volatile关键字来保证原子性、可见性以及有序性，那么编写并发程序可能会显得十分麻烦，
幸运的是，从JDK5开始，Java使用新的JSR-133内存模型，提供了happens-before原则来辅助保证程序执行的原子性、可见性以及有序性的问题，
它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下

1. 程序顺序原则，即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。

2. 锁规则解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说，
    如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。
    
3. volatile规则 volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单
    的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当
    该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能
    够看到该变量的最新值。
    
4. 线程启动规则 线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的
    start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量
    的修改对线程B可见
    
5. 传递性 A先于B ，B先于C 那么A必然先于C

6. 线程终止规则 线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前
    执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法
    成功返回后，线程B对共享变量的修改将对线程A可见。
    
7. 线程中断规则 对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中
    断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。
    
8. 对象终结规则 对象的构造函数执行，结束先于finalize()方法
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;volatile内存语义&lt;br/&gt;volatile是Java虚拟机提供的轻量级的同步机制。&lt;br/&gt;volatile保证可见性与有序性，但是不能保证原子性，要保证原子性需要借助synchronized、Lock锁机制，同理也能保证有序性与可见性。&lt;br/&gt;因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。&lt;/p&gt;
&lt;p&gt;volatile关键字有如下两个作用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。
禁止指令重排序优化。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;volatile的可见性&lt;br/&gt;关于volatile的可见性作用，我们必须意识到被volatile修饰的变量对所有线程总数立即可见的，会showtime，底层被编译的时候会有lock信号&lt;br/&gt;对volatile变量的所有写操作总是能立刻反应到其他线程中&lt;br/&gt;示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    /
     * 以下代码先执行线程A，一直执行i++,然后执行线程B，更改initFlag的值为true,想要退出循环
     * 但是如果变量不加volatile或者不加锁，由于线程A中的initFlag从第一次从主内存中load到线程A工作内存后
     * 一直使用的线程A的缓存数据，即便在线程B中更改了initFlag，但是并没有showtime给线程A
     * 线程A使用的仍然是他缓存中的，并没有去主内存中获取，所以当前代码要实现initFlag可见，
     * 可以加volatile关键字实现volatile写（更改后一定会写到主内存中并且会showtime）,(保证可见性)
     * 或者加同步代码块synchronized
     *      加synchronized原因：看代码第三版
     *
     */
    public class VolatileVisibilitySample {
        private boolean  initFlag = false;
        static Object object = new Object();
        public void refresh(){
            //普通写操作，(主要改成volatile写就可以)
            this.initFlag = true;
            String threadname = Thread.currentThread().getName();
            System.out.println(&quot;线程：&quot;+threadname+&quot;:修改共享变量initFlag&quot;);
        }
        public void load(){
            String threadname = Thread.currentThread().getName();
            int i = 0;
    
    
            // 第一版 initFlag没加volatile，后面的打印不会出现  (空跑会一直占用CPU使用权，优先级别非常高)
            //while (!initFlag){ }
    
            // 第二版，加一个变量 initFlag没加volatile，后面的打印不会出现，因为i和他没关系
            //while (!initFlag){ i++;}
    
            // 第三版 加同步块 initFlag没加volatile，后面的打印会出现，
            // 存在同步块，这里可能引起阻塞，竞争可能导致上下文切换，线程的上下文切换会把线程的信息等数据回写到内存的 任务状态段 里面
            // 所以可能重新去主内存load数据，能知道initFlag已经改变，得以更新线程A的内存副本
            while (!initFlag){
                synchronized (object){
                    i++;
                }
            }
            System.out.println(&quot;线程：&quot;+threadname+&quot;当前线程嗅探到initFlag的状态的改变&quot;+i);
        }
        public static void main(String[] args){
            VolatileVisibilitySample sample = new VolatileVisibilitySample();
            Thread threadA = new Thread(()-&amp;gt;{ sample.refresh(); },&quot;threadA&quot;);
            Thread threadB = new Thread(()-&amp;gt;{ sample.load(); },&quot;threadB&quot;);
            threadB.start();
            try {
                 Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            threadA.start();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;volatile无法保证原子性&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public class VolatileVisibility {
        public  static  volatile int  i =0;
        public  static  void  increase(){i++;}
    }

    在并发场景下，i变量的任何改变都会立马反应到其他线程中，但是如此存在多条线程同时调用increase()方法的话，
    就会出现线程安全问题，毕竟i++;操作并不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，
    分两步完成，如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一
    个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全，需
    要注意的是一旦使用synchronized修饰方法后，由于synchronized本身也具备与volatile相同的特性，即可见性，
    因此在这样种情况下就完全可以省去volatile修饰变量
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;volatile禁止重排优化&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;volatile关键字另一个作用就是禁止指令重排优化，从而避免多线程环境下程序出现乱序
执行的现象，关于指令重排优化前面已详细分析过，这里主要简单说明一下volatile是如何实
现禁止指令重排优化的。先了解一个概念，内存屏障(Memory Barrier）。
内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，一是保证特定操作的执行顺序，
二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）。
由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，
不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏
障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出
各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。
总之，volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化。

下面看一个非常典型的禁止重排优化的例子DCL，如下

    /
     * volatile保证指令重排（原理是插入了屏障）
     */
    public class Singleton {
    
        /
         * 查看汇编指令
         * -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp
         */
        private volatile static Singleton myinstance;
    
        public static Singleton getInstance() {
            if (myinstance == null) {
                synchronized (Singleton.class) {
                    if (myinstance == null) {
    
                        //多线程环境下可能会出现问题的地方
    
                        / 对象创建过程，本质可以分文三步
                         * 1. 申请地址 address=allocate
                         * 2.地址上实例化对象 new Singleton()
                         * 3.第三步 myinstance=address
                         *
                         * 要加volatile关键字，为了阻止指令重排，原因：
                         *  其中这三步无法保证原子性，第二步和第三步可能存在指令重排
                         *  当很高的高并发请求下，如果不进行两层判断，
                         *  如果程序执行了第一步申请地址之后
                         *  如果第三步和第二步进行了指令重排，那么会导致myinstance=address
                         *  但是这时候address是空的，在使用的时候就会报错
                         *
                         *
                         *
                         */
                        myinstance = new Singleton();
                        //对象延迟初始化
                        //
                    }
                }
            }
            return myinstance;
        }
        public static void main(String[] args) {
            Singleton.getInstance();
        }
    
        /
         * 如果在多线程环境下就可以出现线程安全问题。原因在于某一个线程执行到第一次检测，读
         * 取到的instance不为null时，instance的引用对象可能没有完成初始化。
         * 因为instance = new Singleton();可以分为以下3步完成(伪代码)
              memory = allocate();//1.分配对象内存空间
              instance(memory);//2.初始化对象
              instance = memory;//3.设置instance指向刚分配的内存地址，此时
              instance！=null
         * 由于步骤1和步骤2间可能会重排序，如下：
              memory=allocate();//1.分配对象内存空间
              instance=memory;//3.设置instance指向刚分配的内存地址，此时instance！
              =null，但是对象还没有初始化完成！
              instance(memory);//2.初始化对象
         * 由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单
         * 线程中并没有改变，因此这种重排优化是允许的。但是指令重排只会保证串行语义的执行的一
         * 致性(单线程)，但并不会关心多线程间的语义一致性。所以当一条线程访问instance不为null
         * 时，由于instance实例未必已初始化完成，也就造成了线程安全问题。那么该如何解决呢，很
         * 简单，我们使用volatile禁止instance变量被执行指令重排优化即可。
         * 
         //禁止指令重排优化
         private volatile static Singleton myinstance;
         */
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;指令重排+读写屏障实例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/
 * 指令重排，不允许使用volatile的话，手动插入屏障理解
 *
 * 从代码上理解，正常的逻辑思维情况下下，可能打印的结果只有三种
 *  1,1 (当线程1执行了a=1,同时线程2执行了b=1的时候)
 *  1,0(当线程1执行了a=1,线程2还没执行，y=b取了默认值)
 *  0,1(当线程2执行了b=1,线程1还没执行，x=a取了默认值)
 *
 *  指令重排的结果
 *  0,0（a=1和x=b进行了指令重排，b=1和y=a进行了指令重排，xy都取了ab默认值）
 *
 */
public class VolatileReOrderSample {
    private static int x = 0, y = 0;
    private static int a = 0, b =0;
    //private volatile static int a = 0, b =0;
    static Object object = new Object();

    public static void main(String[] args) throws InterruptedException {
        int i = 0;

        for (;;){
            i++;
            x = 0; y = 0;
            a = 0; b = 0;
            Thread t1 = new Thread(new Runnable() {
                @Override
                public void run() {
                    //由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.
                    shortWait(10000);
                    a = 1; //是读还是写？store，volatile写
                    //storeload ,读写屏障，不允许volatile写与第二部volatile读发生重排
                    //手动加内存屏障
                    //UnsafeInstance.reflectGetUnsafe().storeFence();

                    // 如果a,b使用volatile修饰，防止指令重排：这个操作 先读volatile，然后写普通变量b
                    x = b;
                    //分两步进行，第一步先volatile读，第二步再普通写
                }
            });
            Thread t2 = new Thread(new Runnable() {
                @Override
                public void run() {
                    b = 1;
                    //UnsafeInstance.reflectGetUnsafe().storeFence();
                    y = a;
                }
            });
            t1.start();
            t2.start();
            t1.join();
            t2.join();
            String result = &quot;第&quot; + i + &quot;次 (&quot; + x + &quot;,&quot; + y + &quot;）&quot;;
            if(x == 0 &amp;amp;&amp;amp; y == 0) {
                System.err.println(result);
                break;
            } else {
                System.out.println(result);
            }
        }

    }
    public static void shortWait(long interval){
        long start = System.nanoTime();
        long end;
        do{
            end = System.nanoTime();
        }while(start + interval &amp;gt;= end);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;volatile内存语义的实现&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;前面提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM
会分别限制这两种类型的重排序类型。
下面是JMM针对编译器制定的volatile重排序规则表

    是否能重排序                    第二个操作
      第一个操作       普通读/写      volatile读      volatile写
      普通读/写                                        NO
      volatile读       NO              NO             NO 
      volatile写                       NO             NO
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;举例来说，第三行最后一个单元格的意思是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在程序中，当第一个操作为普通变量的读或写时，如果第二个操作为volatile写，则编译器不能重排序这两个操作。
从上图可以看出：

当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。
这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。

当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。
这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。

当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。&lt;br/&gt;对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能。&lt;br/&gt;为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;∙在每个volatile写操作的前面插入一个StoreStore屏障。
∙在每个volatile写操作的后面插入一个StoreLoad屏障。
∙在每个volatile读操作的后面插入一个LoadLoad屏障。
∙在每个volatile读操作的后面插入一个LoadStore屏障。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述内存屏障插入策略非常保守，但它可以保证在任意处理器平台，任意的程序中都能得&lt;br/&gt;到正确的volatile内存语义。&lt;br/&gt;下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2197806/202011/2197806-20201128234757480-1302002150.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;上图中StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作已经对任意处理器可见了。
这是因为StoreStore屏障将保障上面所有的普通写在volatile写之前刷新到主内存。

这里比较有意思的是，volatile写后面的StoreLoad屏障。此屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。
因为编译器常常无法准确判断在一个volatile写的后面是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了保证能正确实现volatile的内存语义，JMM在采取了保守策略：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;在每个volatile写的后面，或者在每个volatile 读的前面插入一个StoreLoad屏障。从整
体执行效率的角度考虑，JMM最终选择了在每个 volatile写的后面插入一个StoreLoad屏障。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为volatile写-读内存语义的常见使用模式是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;一个写线程写volatile变量，多个读线程读同一个volatile变量。
当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。
从这里可以看到JMM 在实现上的一个特点：首先确保正确性，然后再去追求执行效率。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下图是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2197806/202011/2197806-20201128234817897-326511800.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中LoadLoad屏障用来禁止处理器把上面的volatile读与下面的普通读重排序。&lt;br/&gt;LoadStore屏障用来禁止处理器把上面的volatile读与下面的普通写重排序。&lt;br/&gt;上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不&lt;br/&gt;改变 volatile写-读的内存语义，编译器可以根据具体情况省略不必要的屏障。&lt;br/&gt;下面通过具体的示例&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class VolatileBarrierExample {
    int a;
    volatile int m1 = 1;
    volatile int m2 = 2;

    void readAndWrite() {
        int i = m1;   // 第一个volatile读
        int j = m2;   // 第二个volatile读

        a = i + j;    // 普通写

        m1 = i + 1;   // 第一个volatile写
        m2 = j * 2;   // 第二个 volatile写
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;针对readAndWrite()方法，编译器在生成字节码时可以做如下的优化&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2197806/202011/2197806-20201128234838017-1981475734.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，最后的StoreLoad屏障不能省略。因为第二个volatile写之后，方法立即return。&lt;br/&gt;此时编 译器可能无法准确断定后面是否会有volatile读或写，为了安全起见，编译器通常会在这里插 入一个StoreLoad屏障。&lt;br/&gt;上面的优化针对任意处理器平台，由于不同的处理器有不同“松紧度”的处理器内 存模 型，&lt;br/&gt;内存屏障的插入还可以根据具体的处理器内存模型继续优化。以X86处理器为&lt;br/&gt;例，图3-21 中除最后的StoreLoad屏障外，其他的屏障都会被省略。&lt;br/&gt;前面保守策略下的volatile读和写，在X86处理器平台可以优化成如下图所示。前文提到过，X86处理器仅会对写-读操作做重排序。&lt;br/&gt;X86不会对读-读、读-写和写-写操作做重排序，因此在X86处理器中会省略掉这3种操作类型对应的内存屏障。&lt;br/&gt;在X86中，JMM仅需 在volatile写后面插入一个StoreLoad屏障即可正确实现volatile写-读的内存&lt;br/&gt;语义。这意味着在 X86处理器中，volatile写的开销比volatile读的开销会大很多（因为执行StoreLoad屏障开销会比较大）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2197806/202011/2197806-20201128234857569-432780234.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;过多使用cas(compareandswap)和volatile导致的bus总线风暴&lt;br/&gt;volatile 基于底层缓存一致协议&lt;/p&gt;
&lt;p&gt;cpu --&amp;gt; 工作内存 --&amp;gt; bus总线(缓存一致性协议) ---&amp;gt; 主内存&lt;br/&gt;cpu1 --&amp;gt; 工作内存 --&amp;gt; bus总线(缓存一致性协议) ---&amp;gt; 主内存&lt;/p&gt;
&lt;p&gt;如果使用volatile特别多或者热别多原子的cas，会导致工作内存见产生特别多无效工作内存变量，由于volatile在bus中无限showtime，&lt;br/&gt;导致bus总线交互变得特别多，其他有意义的操作交互变得延迟&lt;br/&gt;这时候和synchronized比较，还不如使用synchronized&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 28 Nov 2020 15:58:00 +0000</pubDate>
<dc:creator>宁剑文</dc:creator>
<og:description>CPU缓存一致性协议，JVM基础知识了解，多线程基础知识了解 本文章主要介绍到到了一些CPU缓存一致性协议的基础知识，由此引出的多线程知识，同时谈到了多线程中数据操作 原子性 可见性 有序性 的问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ningjianwen/p/14054949.html</dc:identifier>
</item>
<item>
<title>自动化运维工具之Puppet基础入门 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14052241.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14052241.html</guid>
<description>&lt;p&gt;　　一、简介&lt;/p&gt;
&lt;p&gt;　　puppet是什么？它能做什么？&lt;/p&gt;
&lt;p&gt;　　puppet是一个IT基础设施自动化运维工具，它能够帮助系统管理员管理基础设施的整个生命周期；比如，安装服务，提供配置文件，启动服务等等一系列操作；基于puppet，可实现自动化重复任务、快速部署关键性应用以及在本地或云端完成主动变更和快速扩展架构规模等；它遵循GPL协议（2.7.0以前），基于ruby语言开发，2.7.0以后使用apache 2.0协议；&lt;/p&gt;
&lt;p&gt;　　puppet架构&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201128123047988-648363840.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：puppet是master/agent架构，master和agent使用https通信；puppet有两种工作方式，第一种是standalone模式，这种方式通常运行在单机之上；另一种则是master/agent模式，这种模式master和agent运行在不同的服务器之上；&lt;/p&gt;
&lt;p&gt;　　puppet工作流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201128125257755-797667296.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：puppet工作流程分4个步骤，第一个步骤是定义manifast，这个步骤由管理员完成，主要通过过puppet的声明性配置语言定义基础设施配置的目标状态；第二个步骤是模拟，所谓模拟就是把我们定义的manifest，在目标主机上试着运行一遍，但不真正的应用（不改变目标主机的状态）；这一步主要用来检查我们定义的manifest是否有语法错误等等；第三步是强制，所谓强制就是把目标主机状态强制改变为我们在manifest中定义的状态；最后一步就是报告，报告就是指我们当前目标主机的状态和manifest中定义的状态的不同，以及达成目标状态所进行的改变信息；&lt;/p&gt;
&lt;p&gt;　　puppet standalone模式工作过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201128125517261-465314422.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：在单机模式下，puppet的执行过程如上图；首先puppet会把我们写的manifest文件进行编译，编译成为代码这个为代码有点类似java中的字节码；然后puppet把编译的结果应用到对应的目标主机上；在应用之前它首先要对比目标主机当前状态和我们定义的目标状态是否一样，如果一样则跳过不更改其状态，如果不一样则强制让目标主机当前状态和我们定义的目标状态一样，最后将执行的过程报告给管理员；这里值得注意的是，在单机模型下，puppet应用manifest时，是我们人工手动指定来应用；&lt;/p&gt;
&lt;p&gt;　　puppet master/agent模式工作过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202011/1503305-20201128130951509-1291020519.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：master/agent模型，总的流程和单机模型类似，都是先编译然后再到应用；不同的是master/agent模型管理员可以不用手动应用manifest，默认情况下agent会每隔30分钟就到master拉取和自己相关的配置，如果对应master端有和自己相关的新配置，它会将其拉取到本地，然后强制执行，也就是说每隔30分钟各个agent会来master同步配置，如果对应目标主机当前状态和我们定义的目标状态不一样，最迟30分钟会自动修复；&lt;/p&gt;
&lt;p&gt;　　二、puppet单机模型的安装和使用&lt;/p&gt;
&lt;p&gt;　　安装puppet&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# yum install -y puppet
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：单机模型我们只需要安装puppet即可；这个包来源epel仓库，安装之前，请确保epel仓库配置正常；另外在epel仓库中这个包的版本稍微有点低，如果要使用最新版本可以到&lt;a href=&quot;https://yum.puppet.com&quot; target=&quot;_blank&quot;&gt;https://yum.puppet.com&lt;/a&gt;这个仓库中下载对应版本的包进行安装即可；&lt;/p&gt;
&lt;p&gt;　　puppet的基础使用&lt;/p&gt;
&lt;p&gt;　　查看puppet工具帮助&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# puppet help

Usage: puppet &amp;lt;subcommand&amp;gt; [options] &amp;lt;action&amp;gt; [options]

Available subcommands:
    
  agent             The puppet agent daemon
  apply             Apply Puppet manifests locally
  ca                Local Puppet Certificate Authority management.
  catalog           Compile, save, view, and convert catalogs.
  cert              Manage certificates and requests
  certificate       Provide access to the CA for certificate management.
  certificate_request  Manage certificate requests.
  certificate_revocation_list  Manage the list of revoked certificates.
  config            Interact with Puppet's settings.
  describe          Display help about resource types
  device            Manage remote network devices
  doc               Generate Puppet documentation and references
  facts             Retrieve and store facts.
  file              Retrieve and store files in a filebucket
  filebucket        Store and retrieve files in a filebucket
  help              Display Puppet help.
  inspect           Send an inspection report
  instrumentation_data  Manage instrumentation listener accumulated data.
  instrumentation_listener  Manage instrumentation listeners.
  instrumentation_probe  Manage instrumentation probes.
  key               Create, save, and remove certificate keys.
  kick              Remotely control puppet agent
  man               Display Puppet manual pages.
  master            The puppet master daemon
  module            Creates, installs and searches for modules on the Puppet Forge.
  node              View and manage node definitions.
  parser            Interact directly with the parser.
  plugin            Interact with the Puppet plugin system.
  queue             Deprecated queuing daemon for asynchronous storeconfigs
  report            Create, display, and submit reports.
  resource          The resource abstraction layer shell
  resource_type     View classes, defined resource types, and nodes from all manifests.
  secret_agent      Mimics puppet agent.
  status            View puppet server status.

See 'puppet help &amp;lt;subcommand&amp;gt; &amp;lt;action&amp;gt;' for help on a specific subcommand action.
See 'puppet help &amp;lt;subcommand&amp;gt;' for help on a specific subcommand.
Puppet v3.6.2
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：puppet这个工具有很多子命令，对应不同的子命令有不同的选项，同时对应不同的子命令有着不同的操作命令，不同操作命令对应不同的选项；&lt;/p&gt;
&lt;p&gt;　　查询对应子命令的帮助&lt;/p&gt;
&lt;p&gt;　　查看describe子命令的帮助说明&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# puppet describe --help

puppet-describe(8) -- Display help about resource types
========

SYNOPSIS
--------
Prints help about Puppet resource types, providers, and metaparameters.


USAGE
-----
puppet describe [-h|--help] [-s|--short] [-p|--providers] [-l|--list] [-m|--meta]


OPTIONS
-------
* --help:
  Print this help text

* --providers:
  Describe providers in detail for each type

* --list:
  List all types

* --meta:
  List all metaparameters

* --short:
  List only parameters without detail


EXAMPLE
-------
    $ puppet describe --list
    $ puppet describe file --providers
    $ puppet describe user -s -m


AUTHOR
------
David Lutterkort


COPYRIGHT
---------
Copyright (c) 2011 Puppet Labs, LLC Licensed under the Apache 2.0 License

[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：describe这个子命令主要用来显示资源类型的帮助信息；在puppet中所谓资源指我们能够操作目标主机的对象，比如创建用户，那么这个用户资源就是我们操作的对象，创建用户组，对应组就是我们操作的对象；&lt;/p&gt;
&lt;p&gt;　　查看puppet支持的资源类型列表&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# puppet describe --list
These are the types known to puppet:
augeas          - Apply a change or an array of changes to the  ...
computer        - Computer object management using DirectorySer ...
cron            - Installs and manages cron jobs
exec            - Executes external commands
file            - Manages files, including their content, owner ...
filebucket      - A repository for storing and retrieving file  ...
group           - Manage groups
host            - Installs and manages host entries
interface       - This represents a router or switch interface
k5login         - Manage the `.k5login` file for a user
macauthorization - Manage the Mac OS X authorization database
mailalias       - .. no documentation ..
maillist        - Manage email lists
mcx             - MCX object management using DirectoryService  ...
mount           - Manages mounted filesystems, including puttin ...
nagios_command  - The Nagios type command
nagios_contact  - The Nagios type contact
nagios_contactgroup - The Nagios type contactgroup
nagios_host     - The Nagios type host
nagios_hostdependency - The Nagios type hostdependency
nagios_hostescalation - The Nagios type hostescalation
nagios_hostextinfo - The Nagios type hostextinfo
nagios_hostgroup - The Nagios type hostgroup
nagios_service  - The Nagios type service
nagios_servicedependency - The Nagios type servicedependency
nagios_serviceescalation - The Nagios type serviceescalation
nagios_serviceextinfo - The Nagios type serviceextinfo
nagios_servicegroup - The Nagios type servicegroup
nagios_timeperiod - The Nagios type timeperiod
notify          - .. no documentation ..
package         - Manage packages
resources       - This is a metatype that can manage other reso ...
router          - .. no documentation ..
schedule        - Define schedules for Puppet
scheduled_task  - Installs and manages Windows Scheduled Tasks
selboolean      - Manages SELinux booleans on systems with SELi ...
selmodule       - Manages loading and unloading of SELinux poli ...
service         - Manage running services
ssh_authorized_key - Manages SSH authorized keys
sshkey          - Installs and manages ssh host keys
stage           - A resource type for creating new run stages
tidy            - Remove unwanted files based on specific crite ...
user            - Manage users
vlan            - .. no documentation ..
whit            - Whits are internal artifacts of Puppet's curr ...
yumrepo         - The client-side description of a yum reposito ...
zfs             - Manage zfs
zone            - Manages Solaris zones
zpool           - Manage zpools
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　查看对应资源类型的使用帮助&lt;/p&gt;
&lt;p&gt;　　查看user资源类型的帮助&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;87&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# puppet describe user

user
====
Manage users.  This type is mostly built to manage system
users, so it is lacking some features useful for managing normal
users.
This resource type uses the prescribed native tools for creating
groups and generally uses POSIX APIs for retrieving information
about them.  It does not directly modify `/etc/passwd` or anything.
**Autorequires:** If Puppet is managing the user's primary group (as
provided in the `gid` attribute), the user resource will autorequire
that group. If Puppet is managing any role accounts corresponding to the
user's roles, the user resource will autorequire those role accounts.


Parameters
----------

- **allowdupe**
    Whether to allow duplicate UIDs. Defaults to `false`.
    Valid values are `true`, `false`, `yes`, `no`. 

- **attribute_membership**
    Whether specified attribute value pairs should be treated as the
    **complete list** (`inclusive`) or the **minimum list** (`minimum`) of
    attribute/value pairs for the user. Defaults to `minimum`.
    Valid values are `inclusive`, `minimum`. 

- **attributes**
    Specify AIX attributes for the user in an array of attribute = value
    pairs.
Requires features manages_aix_lam.

- **auth_membership**
    Whether specified auths should be considered the **complete list**
    (`inclusive`) or the **minimum list** (`minimum`) of auths the user
    has. Defaults to `minimum`.
Valid values are `inclusive`, `minimum`. 

- **auths**
    The auths the user has.  Multiple auths should be
    specified as an array.
Requires features manages_solaris_rbac.

- **comment**
    A description of the user.  Generally the user's full name.

- **ensure**
    The basic state that the object should be in.
    Valid values are `present`, `absent`, `role`. 

- **expiry**
    The expiry date for this user. Must be provided in
    a zero-padded YYYY-MM-DD format --- e.g. 2010-02-19.
    If you want to make sure the user account does never
    expire, you can pass the special value `absent`.
    Valid values are `absent`. Values can match `/^\d{4}-\d{2}-\d{2}$/`.
    Requires features manages_expiry.

- **forcelocal**
    Forces the mangement of local accounts when accounts are also
    being managed by some other NSS
    Valid values are `true`, `false`, `yes`, `no`. 
    Requires features libuser.

- **gid**
    The user's primary group.  Can be specified numerically or by name.
    This attribute is not supported on Windows systems; use the `groups`
    attribute instead. (On Windows, designating a primary group is only
    meaningful for domain accounts, which Puppet does not currently manage.)

- **groups**
    The groups to which the user belongs.  The primary group should
    not be listed, and groups should be identified by name rather than by
    GID.  Multiple groups should be specified as an array.

- **home**
    The home directory of the user.  The directory must be created
    separately and is not currently checked for existence.

- **ia_load_module**
    The name of the I&amp;amp;A module to use to manage this user.
    Requires features manages_aix_lam.

- **iterations**
    This is the number of iterations of a chained computation of the
    password hash (http://en.wikipedia.org/wiki/PBKDF2).  This parameter
    is used in OS X. This field is required for managing passwords on OS X
    &amp;gt;= 10.8.
Requires features manages_password_salt.

- **key_membership**
    Whether specified key/value pairs should be considered the
    **complete list** (`inclusive`) or the **minimum list** (`minimum`) of
    the user's attributes. Defaults to `minimum`.
    Valid values are `inclusive`, `minimum`. 

- **keys**
    Specify user attributes in an array of key = value pairs.
    Requires features manages_solaris_rbac.

- **managehome**
    Whether to manage the home directory when managing the user.
    This will create the home directory when `ensure =&amp;gt; present`, and
    delete the home directory when `ensure =&amp;gt; absent`. Defaults to `false`.
    Valid values are `true`, `false`, `yes`, `no`. 

- **membership**
    Whether specified groups should be considered the **complete list**
    (`inclusive`) or the **minimum list** (`minimum`) of groups to which
    the user belongs. Defaults to `minimum`.
    Valid values are `inclusive`, `minimum`. 

- **name**
    The user name. While naming limitations vary by operating system,
    it is advisable to restrict names to the lowest common denominator,
    which is a maximum of 8 characters beginning with a letter.
    Note that Puppet considers user names to be case-sensitive, regardless
    of the platform's own rules; be sure to always use the same case when
    referring to a given user.

- **password**
    The user's password, in whatever encrypted format the local
    system requires.
    * Most modern Unix-like systems use salted SHA1 password hashes. You can
    use
      Puppet's built-in `sha1` function to generate a hash from a password.
    * Mac OS X 10.5 and 10.6 also use salted SHA1 hashes.
    * Mac OS X 10.7 (Lion) uses salted SHA512 hashes. The Puppet Labs
    [stdlib][]
      module contains a `str2saltedsha512` function which can generate
    password
      hashes for Lion.
    * Mac OS X 10.8 and higher use salted SHA512 PBKDF2 hashes. When
      managing passwords on these systems the salt and iterations properties
      need to be specified as well as the password.
    * Windows passwords can only be managed in cleartext, as there is no
    Windows API
      for setting the password hash.
    [stdlib]: https://github.com/puppetlabs/puppetlabs-stdlib/
    Be sure to enclose any value that includes a dollar sign ($) in single
    quotes (') to avoid accidental variable interpolation.
    Requires features manages_passwords.

- **password_max_age**
    The maximum number of days a password may be used before it must be
    changed.
Requires features manages_password_age.

- **password_min_age**
    The minimum number of days a password must be used before it may be
    changed.
Requires features manages_password_age.

- **profile_membership**
    Whether specified roles should be treated as the **complete list**
    (`inclusive`) or the **minimum list** (`minimum`) of roles
    of which the user is a member. Defaults to `minimum`.
    Valid values are `inclusive`, `minimum`. 

- **profiles**
    The profiles the user has.  Multiple profiles should be
    specified as an array.
Requires features manages_solaris_rbac.

- **project**
    The name of the project associated with a user.
    Requires features manages_solaris_rbac.

- **purge_ssh_keys**
    Purge ssh keys authorized for the user
    if they are not managed via ssh_authorized_keys. When true,
    looks for keys in .ssh/authorized_keys in the user's home
    directory. Possible values are true, false, or an array of
    paths to file to search for authorized keys. If a path starts
    with ~ or %h, this token is replaced with the user's home directory.
    Valid values are `true`, `false`. 

- **role_membership**
    Whether specified roles should be considered the **complete list**
    (`inclusive`) or the **minimum list** (`minimum`) of roles the user
    has. Defaults to `minimum`.
Valid values are `inclusive`, `minimum`. 

- **roles**
    The roles the user has.  Multiple roles should be
    specified as an array.
Requires features manages_solaris_rbac.

- **salt**
    This is the 32 byte salt used to generate the PBKDF2 password used in
    OS X. This field is required for managing passwords on OS X &amp;gt;= 10.8.
    Requires features manages_password_salt.

- **shell**
    The user's login shell.  The shell must exist and be
    executable.
    This attribute cannot be managed on Windows systems.
    Requires features manages_shell.

- **system**
    Whether the user is a system user, according to the OS's criteria;
    on most platforms, a UID less than or equal to 500 indicates a system
    user. Defaults to `false`.
    Valid values are `true`, `false`, `yes`, `no`. 

- **uid**
    The user ID; must be specified numerically. If no user ID is
    specified when creating a new user, then one will be chosen
    automatically. This will likely result in the same user having
    different UIDs on different systems, which is not recommended. This is
    especially noteworthy when managing the same user on both Darwin and
    other platforms, since Puppet does UID generation on Darwin, but
    the underlying tools do so on other platforms.
    On Windows, this property is read-only and will return the user's
    security identifier (SID).

Providers
---------
    aix, directoryservice, hpuxuseradd, ldap, pw, user_role_add, useradd,
    windows_adsi
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上从以上帮助信息可以看到，我们定义在目标主机上创建用户可以使用user这个资源类型，其中对应有很多属性，这些属性主要用来描述对应资源该有的属性，比如uid用来描述用户的id，gid用于描述组id；&lt;/p&gt;
&lt;p&gt;　　定义资源清单语法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
type {'title':
    attribute1  =&amp;gt; value1,
    atrribute2  =&amp;gt; value2,
    ……
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：type指资源类型，type必须使用小写字符；title是一个字符串，在同一类型中必须惟一；&lt;/p&gt;
&lt;p&gt;　　资源属性中的三个特殊属性：&lt;/p&gt;
&lt;p&gt;　　　　Namevar， 可简称为name；&lt;br/&gt;　　　　ensure：资源的目标状态；&lt;br/&gt;　　　　Provider：指明资源的管理接口；&lt;/p&gt;
&lt;p&gt;　　示例：定义manifest，创建用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# cat user.pp
user{'tom':
        ensure  =&amp;gt; present,
        uid     =&amp;gt; 5000,
        home    =&amp;gt; '/home/tom',
        shell   =&amp;gt; '/bin/bash',
        comment =&amp;gt; 'this is test user',
}
[root@node12 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：上述资源清单中，没有用name指定对应资源类型的名称，如果没有指定默认使用title的值作为其资源类型的名称；资源清单使用.pp为后缀，意思就是puppet的简写；&lt;/p&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# puppet apply -v --noop user.pp
Notice: Compiled catalog for node12.test.org in environment production in 0.07 seconds
Info: Applying configuration version '1606542594'
Notice: /Stage[main]/Main/User[tom]/ensure: current_value absent, should be present (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Info: Creating state file /var/lib/puppet/state/state.yaml
Notice: Finished catalog run in 0.02 seconds
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：应用资源清单使用puppet apply命令，其中-v用于指定显示执行输出过程；--noop用于指定干跑，不应用，主要检测对应的manifast文件是否有语法错误；如果没有语法错误，我们就可以把对应noop选项取消，然后真正应用其资源清单到本地；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# puppet apply -v  user.pp      
Notice: Compiled catalog for node12.test.org in environment production in 0.06 seconds
Info: Applying configuration version '1606542785'
Notice: /Stage[main]/Main/User[tom]/ensure: created
Notice: Finished catalog run in 0.05 seconds
[root@node12 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：查看tom用户是否创建呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# getent passwd tom
tom:x:5000:5000:this is test user:/home/tom:/bin/bash
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应tom用户已经创建成功，并且uid，注释信息和家目录，shell等信息都是我们指定的内容；&lt;/p&gt;
&lt;p&gt;　　示例：删除tom用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# cat user.pp
user{'tom':
        ensure  =&amp;gt; absent,
        uid     =&amp;gt; 5000,
        home    =&amp;gt; '/home/tom',
        shell   =&amp;gt; '/bin/bash',
        comment =&amp;gt; 'this is test user',
}
[root@node12 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：ensure这个属性主要指定对应资源类型在目标主机上的状态，absent表示缺席之意，如果对应主机上有tom用户就删除；&lt;/p&gt;
&lt;p&gt;　　验证：应用资源清单，看看tom用户是否被删除？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# puppet apply -v user.pp
Notice: Compiled catalog for node12.test.org in environment production in 0.25 seconds
Info: Applying configuration version '1606574872'
Notice: /Stage[main]/Main/User[tom]/ensure: removed
Notice: Finished catalog run in 0.11 seconds
[root@node12 ~]# getent passwd tom      
[root@node12 ~]# id tom
id: tom: no such user
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到应用了资源清单以后，本机的tom用户就被删除了；&lt;/p&gt;
&lt;p&gt;　　以上就是puppet的基础使用方式，在使用puppet我们最核心的就是要写manifest（资源清单），就是我们要让某资源处于什么状态，就用puppet的配置语言描述，然后使用puppet apply命令应用对应的资源清单即可；&lt;/p&gt;
</description>
<pubDate>Sat, 28 Nov 2020 15:10:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>一、简介 puppet是什么？它能做什么？ puppet是一个IT基础设施自动化运维工具，它能够帮助系统管理员管理基础设施的整个生命周期；比如，安装服务，提供配置文件，启动服务等等一系列操作；基于pu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14052241.html</dc:identifier>
</item>
<item>
<title>设计模式：如何优雅地使用工厂模式 - James_Shangguan</title>
<link>http://www.cnblogs.com/sgh1023/p/14054693.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sgh1023/p/14054693.html</guid>
<description>&lt;p&gt;本文从是什么、为什么、怎么做的三个步骤，分析简单工厂模式、工厂方法模式和抽象工厂模式，通过框架源码学习如何优雅地使用工厂模式。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;135&quot;&gt;
&lt;p&gt;本文从是什么、为什么、怎么做的三个步骤，分析简单工厂模式、工厂方法模式和抽象工厂模式，通过框架源码学习如何优雅地使用工厂模式。&lt;/p&gt;

&lt;p&gt;关于什么是工厂模式这个问题呢？其实完全可以见名知意，工厂是做什么的？工厂是生产产品的地方啊，那么映射到编程领域，工厂模式不就是生产对象的一种模式嘛？借用百度百科的一句话来说：工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。&lt;/p&gt;
&lt;p&gt;工厂模式，按照业务实际场景可以划分为3中不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象方法模式。&lt;/p&gt;
&lt;p&gt;简单工厂模式又叫静态工厂方法模式，简单来说就是，该模式有&lt;strong&gt;一个具体的工厂类&lt;/strong&gt;，可以生产许多不同的产品。有一件有意思的事情，简单工厂模式其实不是一种设计模式（不属于GoF23种设计模式），更像是一种编程等习惯，但是由于该习惯经常被使用，许多开发人员都把它称为”工厂模式“，那么就”将错就错“被大家所接受咯。&lt;/p&gt;
&lt;p&gt;在简单工厂模式中，生产产品是由一个单一的、具体的工厂类来实现的；在工厂方法模式中，不再采用这种方式，而是由&lt;strong&gt;工厂类的子类&lt;/strong&gt;实现具体产品的生产工作。当增加一类产品的时候，只需要增加一个相应的工厂类的子类。这样做的好处是可以解决简单工厂模式由于生产产品种类过多而引发的代码臃肿的问题。举个例子，需要创建3种类型的产品，简单工厂模式需要3个分支（不管是if-else也好，switch-case也罢），工厂方法模式需要3个子类；那么产品类型有10种呢？当生产的产品种类较多的时候，使用工厂方法模式可以解决简单工厂方法模式大量代码重复的问题，这也就是工厂方法模式存在的意义。&lt;/p&gt;
&lt;p&gt;抽象工厂模式是这么定义的：抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确执行具体类。抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要关系实际产出的具体产品是什么。&lt;/p&gt;

&lt;p&gt;”为什么要使用工厂模式“，关于这个问题我是这么理解的：&lt;/p&gt;
&lt;p&gt;第一，为什么要使用设计模式？逼格，对，设计模式就是逼格的体现。除了逼格，说的实际点，就是可以使代码变得清晰和优雅，让新人接手代码的时候在心里少骂我们几句。&lt;/p&gt;
&lt;p&gt;第二，主要的目的还是解耦。如果没有简单工厂模式，我们需要关心生产逻辑（创建过程）和调用，可以使用一坨代码去实现，此时这二者是没有分开的；当使用了简单工厂模式，具体的生产逻辑放在了简单工厂里面，只需要调用即可；当品类增多，简单工厂的工厂类的逻辑变得复杂，耦合变得严重，出现工厂方法模式，将不同品类的生产逻辑剥离到子类中进行，让外部只是知道如何调用即可，实现解耦....其实从不使用设计模式--&amp;gt; 简单工厂模式--&amp;gt; 工厂方法模式--&amp;gt;抽象工厂模式，这就是层次递进的解耦关系。那为什么需要使用工厂模式呢，我想本质也就在这里吧。&lt;/p&gt;

&lt;p&gt;关于如何使用工厂模式？不写之前的demo了，来看下优秀的框架中是如何使用工厂模式的。&lt;/p&gt;
&lt;h2 id=&quot;31-简单工厂模式&quot;&gt;3.1 简单工厂模式&lt;/h2&gt;
&lt;p&gt;简单工厂模式java.util.Calendar类中的运用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private static Calendar createCalendar(TimeZone zone,
                                       Locale aLocale)
{
    CalendarProvider provider =
        LocaleProviderAdapter.getAdapter(CalendarProvider.class, aLocale)
                             .getCalendarProvider();
    if (provider != null) {
        try {
            return provider.getInstance(zone, aLocale);
        } catch (IllegalArgumentException iae) {
            // fall back to the default instantiation
        }
    }

    Calendar cal = null;

    if (aLocale.hasExtensions()) {
        String caltype = aLocale.getUnicodeLocaleType(&quot;ca&quot;);
        if (caltype != null) {
            switch (caltype) {
            case &quot;buddhist&quot;:
            cal = new BuddhistCalendar(zone, aLocale);
                break;
            case &quot;japanese&quot;:
                cal = new JapaneseImperialCalendar(zone, aLocale);
                break;
            case &quot;gregory&quot;:
                cal = new GregorianCalendar(zone, aLocale);
                break;
            }
        }
    }
    if (cal == null) {
        // If no known calendar type is explicitly specified,
        // perform the traditional way to create a Calendar:
        // create a BuddhistCalendar for th_TH locale,
        // a JapaneseImperialCalendar for ja_JP_JP locale, or
        // a GregorianCalendar for any other locales.
        // NOTE: The language, country and variant strings are interned.
        if (aLocale.getLanguage() == &quot;th&quot; &amp;amp;&amp;amp; aLocale.getCountry() == &quot;TH&quot;) {
            cal = new BuddhistCalendar(zone, aLocale);
        } else if (aLocale.getVariant() == &quot;JP&quot; &amp;amp;&amp;amp; aLocale.getLanguage() == &quot;ja&quot;
                   &amp;amp;&amp;amp; aLocale.getCountry() == &quot;JP&quot;) {
            cal = new JapaneseImperialCalendar(zone, aLocale);
        } else {
            cal = new GregorianCalendar(zone, aLocale);
        }
    }
    return cal;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;32-工厂方法模式&quot;&gt;3.2 工厂方法模式&lt;/h2&gt;
&lt;p&gt;Logback源码中的工厂方法模式的使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public static Logger getLogger(String name){
    ILoggerFactory iLoggerFactory = getILoggerFactory();
    return iLoggerFactory.getLogger(name);
}
public static Logger getLogger(Class clazz){
    return getLogger(clazz.getName());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;33-抽象方法模式&quot;&gt;3.3 抽象方法模式&lt;/h2&gt;
&lt;p&gt;在Spring源码中，所有工厂都是BeanFactory的子类。通过对BeanFactory的实现，我们可以从Spring的容器访问Bean。根据不同的策略调用getBean()方法，从而获得具体对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface BeanFactory {
    String FACTORY_BEAN_PREFIX = &quot;&amp;amp;&quot;;

    Object getBean(String var1) throws BeansException;

    &amp;lt;T&amp;gt; T getBean(String var1, Class&amp;lt;T&amp;gt; var2) throws BeansException;

    Object getBean(String var1, Object... var2) throws BeansException;

    &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; var1) throws BeansException;

    &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt; var1, Object... var2) throws BeansException;

    &amp;lt;T&amp;gt; ObjectProvider&amp;lt;T&amp;gt; getBeanProvider(Class&amp;lt;T&amp;gt; var1);

    &amp;lt;T&amp;gt; ObjectProvider&amp;lt;T&amp;gt; getBeanProvider(ResolvableType var1);

    boolean containsBean(String var1);

    boolean isSingleton(String var1) throws NoSuchBeanDefinitionException;

    boolean isPrototype(String var1) throws NoSuchBeanDefinitionException;

    boolean isTypeMatch(String var1, ResolvableType var2) throws NoSuchBeanDefinitionException;

    boolean isTypeMatch(String var1, Class&amp;lt;?&amp;gt; var2) throws NoSuchBeanDefinitionException;

    @Nullable
    Class&amp;lt;?&amp;gt; getType(String var1) throws NoSuchBeanDefinitionException;

    @Nullable
    Class&amp;lt;?&amp;gt; getType(String var1, boolean var2) throws NoSuchBeanDefinitionException;

    String[] getAliases(String var1);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/div&gt;</description>
<pubDate>Sat, 28 Nov 2020 14:47:00 +0000</pubDate>
<dc:creator>James_Shangguan</dc:creator>
<og:description>本文从是什么、为什么、怎么做的三个步骤，分析简单工厂模式、工厂方法模式和抽象工厂模式，通过框架源码学习如何优雅地使用工厂模式。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sgh1023/p/14054693.html</dc:identifier>
</item>
<item>
<title>MySQL数据更新 - xbhog</title>
<link>http://www.cnblogs.com/xbhog/p/14054624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xbhog/p/14054624.html</guid>
<description>&lt;ol&gt;&lt;li&gt;该练习是本人课程学习进行整理的，若有不对，欢迎指出！&lt;/li&gt;
&lt;li&gt;该练习没有配套的sql文件，如果需要可以看之前的文章有student表等（MySQL查询练习）;&lt;/li&gt;
&lt;li&gt;这是最后一部分练习题，如果后面有更新，会补上。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;1、插入数据&quot;&gt;1、插入数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（1）在学生表Student中插入数据：&lt;/strong&gt;&lt;br/&gt;Sno：9512102 Sname:刘晨 Ssex：男 Sage:20 Sdept：计算机系&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;Insert into student (sno,sname,ssex,sage,sdept) values('9512102','刘晨','男',20,'计算机系');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（2）在课程表Course中插入数据：&lt;/strong&gt;&lt;br/&gt;Cno：C06 Cname：数据结构 Ccredit：5 Semster：4&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;insert into course (cno, cname, ccredit, semster) 
values ('C06', '数据结构', '5', '4');
#或
前提是该属性列允许为NULL
insert into course values ('c06','数据结构',5,4,null);
insert into course values ('c06','数据结构',5,4,'');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（3）在选课表SC中插入95211班学生选修C04的选课信息。&lt;/strong&gt;&lt;br/&gt;提示：&lt;br/&gt;多行数据插入，插入数据中的sno从student表中查询而来，插入的cno为“C04”&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;insert into sc(sno, cno) select sno, 'C04' from student
where sno like '95211%';
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;2、修改数据&quot;&gt;2、修改数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（1）将所有学生的年龄增加1岁。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;UPDATE student SET sage=sage+1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（2）修改“9512101”的“C01”课程成绩为85。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;UPDATE sc SET grade=85 WHERE cno='c01' AND sno='9512101';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（3）修改“王大力”的“计算机导论”课程成绩为70。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;UPDATE sc SET grade=70 WHERE sno in (SELECT sno FROM student WHERE sname='王大力') AND cno in (SELECT cno from course WHERE cname='计算机导论');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;UPDATE student,sc,course set grade=70 WHERE student.sno=sc.sno AND sc.cno=course.cno and sname='王大力' AND cname='计算机导论';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（4）将所有平均分为75分以上的学生的各门课成绩在原来基础上加5分。&lt;/strong&gt;&lt;br/&gt;select的结果再通过一个中间表select多一次，就可以避免这个错误&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-markdown&quot;&gt;ERROR 1093 (HY000): You can’t specify target table ‘message’ for update in FROM clause
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;派生表必须使用别名&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;update sc 
set grade = grade + 5
where sno in 
        (
                select sno 
                from 
                (               
                        select sno
                        from sc
                        group by sno 
                        having avg(grade) &amp;gt;= 75 
                ) as A
        ) ;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（5）修改“高等数学”课程倒数三名成绩，在原来分数上减5分。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;update sc set grade=grade-5 where cno in
(select cno from course where cname='高等数学')
and grade is not null order by grade limit 3;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更通用，去除成绩重复值和为空的情况:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;update sc set grade=grade-5 where cno in 
(select sno from couse where cname='高等数学')
and grade in 
(select grade from(
select distinct grade from sc,course where sc.cno=course.cno and 
cname='高等数学' and grade is not null order by grade ase limit 3
) as newtable);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3、删除数据&quot;&gt;3、删除数据&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;（1）删除“9531102”学生“C05”课程的成绩记录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;DELETE FROM sc WHERE sno='9531102' AND cno='c05';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（2）删除“张海”的所有成绩记录&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;DELETE FROM sc WHERE sno IN(SELECT sno FROM student where sname='张海');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（3）删除“数据库基础”的全部记录（包括课程信息，成绩信息）&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;DELETE from sc WHERE cno=(SELECT cno from course WHERE cname='数据库基础');
DELETE from course WHERE cname='数据库基础';
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4、创建索引&quot;&gt;4、创建索引&lt;/h2&gt;
&lt;p&gt;导入rental表数据，在customer_id上建立普通索引（通过语句或表设计器均可）&lt;br/&gt;查询customer_id=367的记录，记录查询时间：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;select * 
from rental 
where customer_id = 367 ;
create index ix_ct_id on rental(customer_id);
drop index ix_ct_id on rental ;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有索引情况下的执行时间： 0.001ms&lt;br/&gt;无索引情况下的执行时间： 0.005ms&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.插入图书信息：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将图书信息插入到book表中，其中书号 7, 书名 组合数学, 作者 刘迪, 价格 36.70, 数量 37。&lt;/p&gt;
&lt;p&gt;表结构如下：&lt;/p&gt;
&lt;p&gt;book(图书) 表：bno 书号，bname 书名，author 作者，price 单价，quantity 库存数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;insert into book values('7','组合数学','刘迪','36.70','37');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.删除“数据库基础”的全部记录（包括课程信息，成绩信息）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;学生数据库db_student包括三个数据表student（学生表）、course（课程表）和sc（选课表）。表结构如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、student（学生表）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SNO学号CHAR(7)&lt;/p&gt;
&lt;p&gt;SNAME姓名CHAR(10)&lt;/p&gt;
&lt;p&gt;SSEX性别CHAR(2)&lt;/p&gt;
&lt;p&gt;SAGE年龄SMALLINT&lt;/p&gt;
&lt;p&gt;SDEPT所在系 VARCHAR(20)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、course（课程表）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CNO课程号CHAR(10)&lt;/p&gt;
&lt;p&gt;CNAME课程名VARCHAR(20)&lt;/p&gt;
&lt;p&gt;CCREDIT学分SMALLINT&lt;/p&gt;
&lt;p&gt;SEMSTER学期SMALLINT&lt;/p&gt;
&lt;p&gt;PERIOD学时SMALLINT&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、sc（选课表）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SNO 学号CHAR(7)&lt;/p&gt;
&lt;p&gt;CNO 课程号CHAR(10)&lt;/p&gt;
&lt;p&gt;GRADE 成绩 SMALLINT&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;delete from sc where cno =(select cno from course where sc.cno=course.cno and cname='数据库基础' ) ;
delete from course where cno='数据库基础';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3.&lt;strong&gt;删除图书信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从BOOK表中删除当前无人借阅的图书记录。&lt;/p&gt;
&lt;p&gt;表结构如下：&lt;/p&gt;
&lt;p&gt;book(图书) 表：bno 书号，bname 书名，author 作者，price 单价，quantity 库存数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_3-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;borrow(借书记录)表 ：cno 借书卡号，bno 书号，rdate 还书日期&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_3-2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;delete from book
where bno not in (
    select bno
  from borrow
  where borrow.bno = book.bno
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4.&lt;strong&gt;修改计算机系李勇的&lt;/strong&gt;VB课程成绩为60&lt;/p&gt;
&lt;p&gt;修改计算机系李勇的VB课程成绩为60。&lt;/p&gt;
&lt;p&gt;表结构如下&lt;/p&gt;
&lt;p&gt;course表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_4-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;student表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_4-2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;sc表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_4-3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;update sc set grade=60
where sno in 
(select sno from student where sname='李勇' and sdept='计算机系') 
and
  cno in 
(select cno from course where cname='VB');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5.&lt;strong&gt;将所有平均分为75分以上的学生的各门课成绩在原来基础上加5分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将所有平均分为75分以上的学生的各门课成绩在原来基础上加5分。&lt;/p&gt;
&lt;p&gt;学生数据库db_student包括三个数据表student（学生表）、course（课程表）和sc（选课表）。表结构如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、student（学生表）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SNO学号CHAR(7)&lt;/p&gt;
&lt;p&gt;SNAME姓名CHAR(10)&lt;/p&gt;
&lt;p&gt;SSEX性别CHAR(2)&lt;/p&gt;
&lt;p&gt;SAGE年龄SMALLINT&lt;/p&gt;
&lt;p&gt;SDEPT所在系 VARCHAR(20)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、course（课程表）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CNO课程号CHAR(10)&lt;/p&gt;
&lt;p&gt;CNAME课程名VARCHAR(20)&lt;/p&gt;
&lt;p&gt;CCREDIT学分SMALLINT&lt;/p&gt;
&lt;p&gt;SEMSTER学期SMALLINT&lt;/p&gt;
&lt;p&gt;PERIOD学时SMALLINT&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、sc（选课表）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SNO 学号CHAR(7)&lt;/p&gt;
&lt;p&gt;CNO 课程号CHAR(10)&lt;/p&gt;
&lt;p&gt;GRADE 成绩 SMALLINT&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;update sc
set grade = grade + 5
where sno in 
(
    select sno
    from 
  (
    select sno 
    from sc
       group by sno
      having avg(grade) &amp;gt;75    
  ) as A
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;p&gt;派生子查询需要设置别名。&lt;/p&gt;
&lt;p&gt;6.&lt;strong&gt;修改“高等数学”课程倒数三名成绩，在原来分数上减5分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改“高等数学”课程倒数三名成绩，在原来分数上减5分。&lt;/p&gt;
&lt;p&gt;学生数据库db_student包括三个数据表student（学生表）、course（课程表）和sc（选课表）。表结构如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、student（学生表）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SNO学号CHAR(7)&lt;/p&gt;
&lt;p&gt;SNAME姓名CHAR(10)&lt;/p&gt;
&lt;p&gt;SSEX性别CHAR(2)&lt;/p&gt;
&lt;p&gt;SAGE年龄SMALLINT&lt;/p&gt;
&lt;p&gt;SDEPT所在系 VARCHAR(20)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、course（课程表）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CNO课程号CHAR(10)&lt;/p&gt;
&lt;p&gt;CNAME课程名VARCHAR(20)&lt;/p&gt;
&lt;p&gt;CCREDIT学分SMALLINT&lt;/p&gt;
&lt;p&gt;SEMSTER学期SMALLINT&lt;/p&gt;
&lt;p&gt;PERIOD学时SMALLINT&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、sc（选课表）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SNO 学号CHAR(7)&lt;/p&gt;
&lt;p&gt;CNO 课程号CHAR(10)&lt;/p&gt;
&lt;p&gt;GRADE 成绩 SMALLINT&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;UPDATE sc
SET grade=grade-5
WHERE cno IN(
SELECT cno FROM course WHERE cname='高等数学')
ORDER BY grade ASC LIMIT 3;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;7.修改borrow表增加一列；修改日期数据（两条语句完成）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;修改borrow表增加借书日期bdate列，列类型为datetime；&lt;/p&gt;
&lt;p&gt;将机械系的同学的借书日期值修改为还书日期的前两个月的时间。&lt;/p&gt;
&lt;p&gt;用两条语句完成，日期的修改可以用date_add( )或adddate( )。&lt;/p&gt;
&lt;p&gt;原表结构如下：&lt;/p&gt;
&lt;p&gt;card(借书卡) 表：cno 卡号，name 姓名，class 班级&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_7-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;borrow(借书记录)表 ：cno 借书卡号，bno 书号，rdate 还书日期&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_7-2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;alter table borrow 
add column bdate datetime;
update borrow 
set bdate = date_add(rdate,interval - 2 month)
where cno in 
(select cno 
 from card 
 where deptName = '机械系');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注释：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定义和用法&lt;/strong&gt;：&lt;br/&gt;DATE_ADD() 函数向日期添加指定的时间间隔。&lt;br/&gt;DATE_SUB() 函数向日期减少指定的时间间隔。&lt;br/&gt;&lt;strong&gt;语法&lt;/strong&gt;：&lt;br/&gt;DATE_ADD(date,INTERVAL expr type)&lt;br/&gt;DATE_SUB(date,INTERVAL expr type)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;date&lt;/strong&gt; ：参数是合法的日期表达式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;expr&lt;/strong&gt;：参数是您希望添加的时间间隔。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt; ：参数可以是下列值，具体参数及用法请查下文章最后的博客链接&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8.在选课表SC中插入95211班学生选修C04的选课信息。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在选课表SC中插入95211班学生选修C04的选课信息。&lt;/p&gt;
&lt;p&gt;提示：多行数据插入，插入的数据的sno从student表中查询而来，插入的cno为“C04”&lt;/p&gt;
&lt;p&gt;学生数据库db_student包括三个数据表student（学生表）、course（课程表）和sc（选课表）。表结构如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、student（学生表）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SNO学号CHAR(7)&lt;/p&gt;
&lt;p&gt;SNAME姓名CHAR(10)&lt;/p&gt;
&lt;p&gt;SSEX性别CHAR(2)&lt;/p&gt;
&lt;p&gt;SAGE年龄SMALLINT&lt;/p&gt;
&lt;p&gt;SDEPT所在系 VARCHAR(20)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、course（课程表）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CNO课程号CHAR(10)&lt;/p&gt;
&lt;p&gt;CNAME课程名VARCHAR(20)&lt;/p&gt;
&lt;p&gt;CCREDIT学分SMALLINT&lt;/p&gt;
&lt;p&gt;SEMSTER学期SMALLINT&lt;/p&gt;
&lt;p&gt;PERIOD学时SMALLINT&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、sc（选课表）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SNO 学号CHAR(7)&lt;/p&gt;
&lt;p&gt;CNO 课程号CHAR(10)&lt;/p&gt;
&lt;p&gt;GRADE 成绩 SMALLINT&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;INSERT INTO   sc(sno,cno) select sno,'c04' from student where sno like '95211%';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;9.在课程表Course中插入数据：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在课程表Course中插入数据：&lt;/p&gt;
&lt;p&gt;Cno：C06 Cname：数据结构 Ccredit：5 Semster：4&lt;/p&gt;
&lt;p&gt;表结构如下：course（课程表）&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;列名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;约束&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;CNO&lt;/td&gt;
&lt;td&gt;课程号&lt;/td&gt;
&lt;td&gt;CHAR(10)&lt;/td&gt;
&lt;td&gt;主码&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CNAME&lt;/td&gt;
&lt;td&gt;课程名&lt;/td&gt;
&lt;td&gt;VARCHAR(20)&lt;/td&gt;
&lt;td&gt;NOT NULL&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;CCREDIT&lt;/td&gt;
&lt;td&gt;学分&lt;/td&gt;
&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SEMSTER&lt;/td&gt;
&lt;td&gt;学期&lt;/td&gt;
&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;PERIOD&lt;/td&gt;
&lt;td&gt;学时&lt;/td&gt;
&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;insert into course (cno,cname,ccredit,semster) values('c06','数据结构','5','4');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;10.在学生表Student中插入数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在学生表Student中插入数据：&lt;/p&gt;
&lt;p&gt;Sno：9512102 Sname:刘晨 Ssex：男 Sage:20 Sdept：计算机系&lt;/p&gt;
&lt;p&gt;表结构如下：student（学生表）&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;列名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;th&gt;数据类型&lt;/th&gt;
&lt;th&gt;约束&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;SNO&lt;/td&gt;
&lt;td&gt;学号&lt;/td&gt;
&lt;td&gt;CHAR(7)&lt;/td&gt;
&lt;td&gt;主码&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SNAME&lt;/td&gt;
&lt;td&gt;姓名&lt;/td&gt;
&lt;td&gt;CHAR(10)&lt;/td&gt;
&lt;td&gt;NOT NULL&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SSEX&lt;/td&gt;
&lt;td&gt;性别&lt;/td&gt;
&lt;td&gt;CHAR(2)&lt;/td&gt;
&lt;td&gt;取“男”或“女”&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SAGE&lt;/td&gt;
&lt;td&gt;年龄&lt;/td&gt;
&lt;td&gt;SMALLINT&lt;/td&gt;
&lt;td/&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SDEPT&lt;/td&gt;
&lt;td&gt;所在系&lt;/td&gt;
&lt;td&gt;VARCHAR(20)&lt;/td&gt;
&lt;td&gt;默认“计算机系”&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;insert into student values('9512102','男','20','计算机系')；
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;11.使用insert set 语句向sc表中插入数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用insert set 向sc表中插入一条选课记录，姓名为周璐的学生，课程名为数据库原理与应用的课程的选课记录。&lt;/p&gt;
&lt;p&gt;student表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_11-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;course表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_11-2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;sc表：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_11-3.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;用法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;INSERT INTO tablename SET column_name1 = value1, column_name2 = value2，…;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;insert sc
set sno=(
  select sno 
  from student 
  where sname='周璐'),
cno=(
  select cno 
  from course 
  where cname='数据库原理与应用');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;12.插入计算机系学生C01课程的选课记录。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在sc表中插入计算机系所有学生C01课程的选课记录。&lt;/p&gt;
&lt;p&gt;student表结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_12-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;sc表结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_12-2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;insert into sc(sno,cno) select sno,'c01' from student where sdept='计算机系';
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;13.一次向student表中插入多条数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一次向student表中插入两条记录，其中王大力的系别用缺省值赋值。&lt;br/&gt;两行数据的学号，姓名，性别，年龄和系别分别如下：&lt;br/&gt;9520103,王敏,女,20,信息系;&lt;br/&gt;9520104,王大力,男,19。&lt;/p&gt;
&lt;p&gt;student表结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_12-1.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;insert into student values('9520103','敏','女','20','信息系'),('9520104','王大力','男','19');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;14.向course中插入数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在course表中插入一新记录，课程号为c06,课程名为软件测试，学分为4。&lt;/p&gt;
&lt;p&gt;course表结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/xbhog/BlogImg/raw/master/null/update_11-2.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;insert into course('c06','软甲测试',null,'4');
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;15.删除“9531102”学生“C05”课程的成绩记录。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;删除“9531102”学生“C05”课程的成绩记录。&lt;/p&gt;
&lt;p&gt;学生数据库db_student包括三个数据表student（学生表）、course（课程表）和sc（选课表）。表结构如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、student（学生表）：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SNO学号CHAR(7)&lt;/p&gt;
&lt;p&gt;SNAME姓名CHAR(10)&lt;/p&gt;
&lt;p&gt;SSEX性别CHAR(2)&lt;/p&gt;
&lt;p&gt;SAGE年龄SMALLINT&lt;/p&gt;
&lt;p&gt;SDEPT所在系 VARCHAR(20)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、course（课程表）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;CNO课程号CHAR(10)&lt;/p&gt;
&lt;p&gt;CNAME课程名VARCHAR(20)&lt;/p&gt;
&lt;p&gt;CCREDIT学分SMALLINT&lt;/p&gt;
&lt;p&gt;SEMSTER学期SMALLINT&lt;/p&gt;
&lt;p&gt;PERIOD学时SMALLINT&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3、sc（选课表）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;SNO 学号CHAR(7)&lt;/p&gt;
&lt;p&gt;CNO 课程号CHAR(10)&lt;/p&gt;
&lt;p&gt;GRADE 成绩 SMALLINT&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-mysql&quot;&gt;delete from sc where sno='9531102' and cno='c05';
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;DATE_ADD函数相关用法：&lt;a href=&quot;https://blog.csdn.net/l1028386804/article/details/87790243&quot;&gt;https://blog.csdn.net/l1028386804/article/details/87790243&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第一部分：MySQL查询练习 &lt;a href=&quot;https://www.cnblogs.com/xbhog/p/13971373.html&quot;&gt;https://www.cnblogs.com/xbhog/p/13971373.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第二部分：MySQL查询练习2 &lt;a href=&quot;https://www.cnblogs.com/xbhog/p/14021013.html&quot;&gt;https://www.cnblogs.com/xbhog/p/14021013.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;理论部分：&lt;/p&gt;
&lt;p&gt;第一部分：MySQL必知必会(1-12章) &lt;a href=&quot;https://www.cnblogs.com/xbhog/p/13721359.html&quot;&gt;https://www.cnblogs.com/xbhog/p/13721359.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.....持续更新.....有时间更新&lt;/p&gt;
&lt;p&gt;感谢各位看到最后！&lt;/p&gt;
</description>
<pubDate>Sat, 28 Nov 2020 14:40:00 +0000</pubDate>
<dc:creator>xbhog</dc:creator>
<og:description>MySQL数据更新： 导读： 该练习是本人课程学习进行整理的，若有不对，欢迎指出！ 该练习没有配套的sql文件，如果需要可以看之前的文章有student表等（MySQL查询练习）; 这是最后一部分练习</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xbhog/p/14054624.html</dc:identifier>
</item>
<item>
<title>《Spring Boot 实战纪实》之如何攥写需求文档 - 戎&quot;码&quot;一生</title>
<link>http://www.cnblogs.com/lucky_hu/p/14054634.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lucky_hu/p/14054634.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://www.52interview.com/book/36/0&quot;&gt;前言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;(思维篇)人人都是产品经理
&lt;ul&gt;&lt;li&gt;1.需求文档
&lt;/li&gt;
&lt;li&gt;2 原型设计
&lt;ul&gt;&lt;li&gt;2.1 缺失的逻辑&lt;/li&gt;
&lt;li&gt;2.2 让想法跃然纸上&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;3 开发设计文档
&lt;ul&gt;&lt;li&gt;3.1 功能梳理&lt;/li&gt;
&lt;li&gt;3.2 数据库设计&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;4 制定开发任务和计划
&lt;ul&gt;&lt;li&gt;4.1 时间管理&lt;/li&gt;
&lt;li&gt;4.2 任务管理(任务拆分+排期)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;(技术篇) 码农的自我修养&lt;/li&gt;
&lt;li&gt;5 Java基础
&lt;ul&gt;&lt;li&gt;5.1 Java环境搭建&lt;/li&gt;
&lt;li&gt;5.2 Java基本语法&lt;/li&gt;
&lt;li&gt;5.3 Java流程控制&lt;/li&gt;
&lt;li&gt;5.4 Java 集合&lt;/li&gt;
&lt;li&gt;5.5 Java 类与对象&lt;/li&gt;
&lt;li&gt;5.6 构造方法&lt;/li&gt;
&lt;li&gt;5.7 封装,继承,多态&lt;/li&gt;
&lt;li&gt;5.8 Java抽象/接口&lt;/li&gt;
&lt;li&gt;5.9 Java常用类&lt;/li&gt;
&lt;li&gt;5.10 Java异常处理&lt;/li&gt;
&lt;li&gt;5.11 异常的定义及捕获&lt;/li&gt;
&lt;li&gt;5.12 Java多线程/线程池&lt;/li&gt;
&lt;li&gt;5.13 Java的反射机制&lt;/li&gt;
&lt;li&gt;5.14 Java的23种设计模式&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;6 Spring框架
&lt;ul&gt;&lt;li&gt;6.1 了解spring&lt;/li&gt;
&lt;li&gt;6.2 Spring带给Java开发的便利&lt;/li&gt;
&lt;li&gt;6.2 Spring ioc/aop&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;7 SpringMVC
&lt;ul&gt;&lt;li&gt;7.1 了解springMVC&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;8 SpringBoot
&lt;ul&gt;&lt;li&gt;8.1 MVC 模型&lt;/li&gt;
&lt;li&gt;8.2 拦截器&lt;/li&gt;
&lt;li&gt;8.3 过滤器&lt;/li&gt;
&lt;li&gt;8.4 POJO&lt;/li&gt;
&lt;li&gt;8.5 controller&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;9 MyBaits plus&lt;/li&gt;
&lt;li&gt;8 Web基础
&lt;ul&gt;&lt;li&gt;html+css&lt;/li&gt;
&lt;li&gt;javascript&lt;/li&gt;
&lt;li&gt;bootstrap&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;(实战篇) 打造自己的轮子
&lt;ul&gt;&lt;li&gt;10 项目架构&lt;/li&gt;
&lt;li&gt;11 网站母版构建
&lt;ul&gt;&lt;li&gt;11.1 thymeleaf介绍&lt;/li&gt;
&lt;li&gt;11.2 使用thymeleaf构建网站模板&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;12 首页
&lt;ul&gt;&lt;li&gt;12.1 banner&lt;/li&gt;
&lt;li&gt;12.2 轮播图&lt;/li&gt;
&lt;li&gt;12.3 文章分页&lt;/li&gt;
&lt;li&gt;12.4 编码实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;13 登录
&lt;ul&gt;&lt;li&gt;13.1 功能点介绍&lt;/li&gt;
&lt;li&gt;13.2 知识点&lt;/li&gt;
&lt;li&gt;13.3 编码实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;14 注册
&lt;ul&gt;&lt;li&gt;14.1 功能点介绍&lt;/li&gt;
&lt;li&gt;14.2 知识点&lt;/li&gt;
&lt;li&gt;14.3 编码实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;15 用户管理
&lt;ul&gt;&lt;li&gt;10.1 功能点介绍&lt;/li&gt;
&lt;li&gt;10.2 知识点&lt;/li&gt;
&lt;li&gt;10.3 编码实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;16 权限控制
&lt;ul&gt;&lt;li&gt;10.1 功能点介绍&lt;/li&gt;
&lt;li&gt;10.2 知识点&lt;/li&gt;
&lt;li&gt;10.3 编码实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;17 权限控制
&lt;ul&gt;&lt;li&gt;11.1 功能点介绍&lt;/li&gt;
&lt;li&gt;10.2 知识点&lt;/li&gt;
&lt;li&gt;10.3 编码实现&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;li&gt;源码&lt;/li&gt;
&lt;li&gt;参考&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h2 id=&quot;导航&quot;&gt;导航&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;永远考虑那个拥有更强写作能力的人&lt;/li&gt;
&lt;li&gt;工欲善其事,必先利其器
&lt;ul&gt;&lt;li&gt;markdown&lt;/li&gt;
&lt;li&gt;思维导图&lt;/li&gt;
&lt;li&gt;流程图&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;换位思考&lt;/li&gt;
&lt;li&gt;这个需求,「不做」&lt;/li&gt;
&lt;li&gt;闭环&lt;/li&gt;
&lt;li&gt;写作套路
&lt;ul&gt;&lt;li&gt;铺垫&lt;/li&gt;
&lt;li&gt;下定义&lt;/li&gt;
&lt;li&gt;逻辑清晰&lt;/li&gt;
&lt;li&gt;说人话&lt;/li&gt;
&lt;li&gt;视角&lt;/li&gt;
&lt;li&gt;版本延续性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;结语&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;Reading makes a full man, conference a ready man, and writing an exact man.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;永远考虑那个拥有更强写作能力的人&quot;&gt;永远考虑那个拥有更强写作能力的人&lt;/h3&gt;
&lt;p&gt;  如果一个岗位有几个候选人，永远考虑那个拥有更强写作能力的人。无论这个人是设计师、程序员、市场或销售人员，写作能力总是可以带来回报的。有效、简洁的写作能带来有效、简洁的代码、设计、邮件、即时通讯等等。&lt;/p&gt;
&lt;p&gt;  写作带来：&lt;br/&gt;更深度的思考，更认真的生活，更清晰的沟通，更有效的社交， 更强大的内心。&lt;/p&gt;
&lt;h3 id=&quot;工欲善其事必先利其器&quot;&gt;工欲善其事,必先利其器&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;君子生非异也，善假于物也&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  思想固然重要,但是善于借助工具表达自己的思想也很重要。这里介绍一些好用的写作方面的工具。&lt;/p&gt;
&lt;h4 id=&quot;markdown&quot;&gt;Markdown&lt;/h4&gt;
&lt;p&gt;  根据&lt;a href=&quot;https://www.52interview.com/book/1/0&quot;&gt;百度百科-markdown&lt;/a&gt;,Markdown是一种轻量级标记语言，创始人为约翰·格鲁伯（英语：John Gruber）。 它允许人们使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML（或者HTML）文档。&lt;/p&gt;
&lt;p&gt;  Markdown是一种简单的格式化文本的方法，让排版变得简答,在任何设备上看起来都很棒。有道笔记,印象笔记,博客园,vscode,github,码云等都支持markdown语法。&lt;/p&gt;
&lt;p&gt;  相关教程&lt;/p&gt;
&lt;br/&gt;&lt;section&gt;&lt;a href=&quot;https://img.zhikestreet.com/20201128130353.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; data-lightbox=&quot;example-set&quot;&gt;&lt;img src=&quot;https://img.zhikestreet.com/20201128130353.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;h4 id=&quot;思维导图&quot;&gt;思维导图&lt;/h4&gt;
&lt;p&gt;  对于某些需求涵盖功能点较多,后者分支较多场景,使用思维导图呈现更直观。比如,这是我整理的考试系统的前期需求的一个思维导图：&lt;/p&gt;
&lt;br/&gt;&lt;section&gt;&lt;a href=&quot;https://img.zhikestreet.com/202011281321.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; data-lightbox=&quot;example-set&quot;&gt;&lt;img src=&quot;https://img.zhikestreet.com/202011281321.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;  现在有很多工具都支持画思维导图:&lt;/p&gt;
&lt;h4 id=&quot;流程图&quot;&gt;流程图&lt;/h4&gt;
&lt;p&gt;  程序员童鞋对流程图肯定不会陌生,常见程序流程图设计应该是信手拈来。针对复杂需求,有时候使用语言和文字难以描述清楚。这个时候,流程图该上场了。&lt;/p&gt;
&lt;br/&gt;&lt;section&gt;&lt;a href=&quot;https://img.zhikestreet.com/202011281541.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; data-lightbox=&quot;example-set&quot;&gt;&lt;img src=&quot;https://img.zhikestreet.com/202011281541.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;  流程图在整个需求的整理中的核心,他能将产品业务背后的逻辑展示出来。这个需要你对吃透需求,然后内化,加工,再输出。&lt;strong&gt;说句题外话,如果你参与了这个需求,一定要抠细节,流程越细化,越有助于成功的实现需求。&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;  这里推荐几个常用的流程图工具：&lt;/p&gt;
&lt;h3 id=&quot;换位思考&quot;&gt;换位思考&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;接到需求之后,技术同学往往会先思考技术实现,然后陷入技术细节,这也是大多数技术人的通病。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  在此前的文章&lt;a href=&quot;https://www.52interview.com/book/36/342&quot;&gt;《需求管理》&lt;/a&gt;中,我曾指出技术同学要放下傲慢和偏见,跳出技术思维。这对于需求的理解和整理至关重要。&lt;/p&gt;
&lt;p&gt;  跳出技术思维,然后换位思考,这有助于全方位,多角度的理解需求。一个功能可能由不同的角色人员使用,视角不同,需求不同。你需要像导演拍电影一样,针对不同角色，一个场景一个场景的拍摄,最终串联成一个完整的电影作品。&lt;/p&gt;
&lt;h3 id=&quot;这个需求「不做」&quot;&gt;这个需求,「不做」&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;懂得拒绝是一门艺术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  技术人不是一个没有灵魂的代码工具。&quot;这是需求爸爸提的,我没法拒绝&quot;,&quot;这是产品爸爸喊做的,不管我的事&quot;。当出现问题的时候,我们经常听到技术同学这样说。&lt;/p&gt;
&lt;p&gt;  不合理的需求,对用户不友好的需求,低收益,高投入的需求,要敢于拒绝。当然,拒绝也是一门艺术,这就是与人沟通的艺术。&lt;strong&gt;如果经过深思熟虑,你能够给出比较合理的解释或者提出更有建设性的方案,我想这样才会更加容易让人接受。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;闭环&quot;&gt;闭环&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;闭环这个词,真是互联网领域的万金油。但是,笔者这里特指产品需求逻辑的闭环。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  笔者曾经待过一个互联网教育创业公司。因为参与人很多都是TOB行业经验的人。大家都是知道,TOB公司的产品卖出去很多时候是线下的操作。比如,微软公司,我做操作系统一流,我赢家通吃。但是,TOC就不一定了,个体用户更加注重用户体验,比如曾经的电商百团大战的竞争,后面的共享单车的竞争,消费者可以直接用脚投票的。&lt;/p&gt;
&lt;p&gt;  我们做了一个课程官网,包括课程展示,订阅充值的官网。官网上线之后,市场同事也做了宣传,但是发现基本上没人注册,很多用户都是让我们帮忙注册。经过研究发现了原因:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为集成Azure注册慢,登录页面,而且极不友好。 这导致用户放弃注册。&lt;/li&gt;
&lt;li&gt;官网没有展示客服咨询电话,只有一个用户建议表单。无法实时联系客服。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;  这个案例,很典型。从市场到技术,我们做了很多工作,但是最终效果不理想。&lt;strong&gt;最大的愿意就是产品不闭环。&lt;/strong&gt;用户想学习课程,但是登录和注册体验太差,这就已经挡住了大部分的用户。&lt;/p&gt;
&lt;h3 id=&quot;写作套路&quot;&gt;写作套路&lt;/h3&gt;
&lt;p&gt;  前面我们讲了很多坑和避坑策略,那要如何才能写好需求文档呢？&lt;/p&gt;
&lt;h4 id=&quot;铺垫&quot;&gt;铺垫&lt;/h4&gt;
&lt;blockquote readability=&quot;7.4534161490683&quot;&gt;
&lt;p&gt;根据&lt;a href=&quot;https://baike.baidu.com/item/%E9%93%BA%E5%9E%AB%E6%B3%95&quot;&gt;百度百科-铺垫法&lt;/a&gt;。戏剧情节结构的一种手法。在戏剧的进展中，对于某些将要出现的关键性情节和起关键作用的人物，必须在事前有所准备、暗示；为情节的展开，为高潮的到来，酝酿气氛，作好准备，铺平道路。这种手法叫埋伏或伏笔。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  其实可以简单理解为背景说明。在需求文档中,增加一定的背景表述,可以增强事物间的因果联系和完整性,不显突兀。&lt;/p&gt;
&lt;p&gt;  一般可以在你的需求前增加一个背景交代，&lt;/p&gt;
&lt;br/&gt;&lt;section&gt;&lt;a href=&quot;https://img.zhikestreet.com/20201128205025.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; data-lightbox=&quot;example-set&quot;&gt;&lt;img src=&quot;https://img.zhikestreet.com/20201128205025.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/section&gt;&lt;p&gt;  这样的好处是,其一,让之前没有参与的人有个背景认识;其二,为自己后续的观点(或者设计思路)提供可信依据,至少不知自己拍脑袋想出来的。&lt;/p&gt;
&lt;h4 id=&quot;下定义&quot;&gt;下定义&lt;/h4&gt;
&lt;p&gt;  对于不同的业务,有时候会有一些&lt;strong&gt;专有名词&lt;/strong&gt;,或者是你自己了说明某个事物而定义的名词。如果不做一些定义的解释,很难理解。比如,在设计IM聊天时候,可能会有一些定义,可以给出定义。&lt;/p&gt;
&lt;br/&gt;&lt;section&gt;&lt;a href=&quot;https://img.zhikestreet.com/20201128212927.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; data-lightbox=&quot;example-set&quot;&gt;&lt;img src=&quot;https://img.zhikestreet.com/20201128212927.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;h4 id=&quot;逻辑清晰&quot;&gt;逻辑清晰&lt;/h4&gt;
&lt;p&gt;  需求文档,不是日记,切记流水账。排版工整,重难点突出。逻辑清晰,富有层次感。&lt;/p&gt;
&lt;p&gt;  利用图表配合文字,有条不紊的表达出合理地逻辑。这样大家阅读起来,一目了然。&lt;/p&gt;
&lt;h4 id=&quot;说人话&quot;&gt;说人话&lt;/h4&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;针对不同的人群一定要设计不同的话术&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  这里的人是指不同的受众。考虑到需求文档面向的对象较多,有技术,业务,测试等,需要抛弃过于专业的技术语言，比如不要出现技术设计的细节,尽量要用自然语言表达。&lt;/p&gt;
&lt;p&gt;  说句题外话,其实严格意义上,需求文档可能是要写两份,一类是给技术同学看的,一类是给非技术同学看的。对于前者,你当然可以用类似抽象的uml图或者直接给出伪代码来说明。&lt;/p&gt;
&lt;h4 id=&quot;视角&quot;&gt;视角&lt;/h4&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;子非鱼,安知鱼之乐&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;  你以为的就是你以为的吗?很多时候,需求的来源并不单一,比如公司要做一个工单系统,这个工单系统的使用者几乎涵盖了公司的各个部门。按照&quot;用户第一&quot;的要求,我们需要考虑到不同业务方的诉求和用户习惯。&lt;/p&gt;
&lt;p&gt;  我们在做需求的时候,就要提前想到。否则,后面的设计一定会违背使用者的意图。前面,讲过的换位思考,或者多角色思考该排上用场了。&lt;/p&gt;
&lt;p&gt;  在文档中,如何体现呢？通常,可以按照不通视角来描述。这就是类似程序的switch...case...&lt;/p&gt;
&lt;p&gt;  切记站在上帝视角看待问题。&lt;/p&gt;
&lt;h4 id=&quot;版本延续性&quot;&gt;版本延续性&lt;/h4&gt;
&lt;p&gt;  需求文档很少一次性就让各方满意的,或多或少都会有补充和调整。比较好的习惯是使用修订版本来记录。&lt;/p&gt;
&lt;p&gt;  修订历史是一个版本的可追溯源，对需求变更历程有一个清晰的认识。&lt;/p&gt;
&lt;p&gt;  新建默认为相应模块的首次使用，对于文档的修改以及增加的地方可加入超链接，同时在增加与修改的具体地方进行颜色标示或者其他标志来进行区分，方便其他人员进行查询。&lt;/p&gt;
&lt;br/&gt;&lt;section&gt;&lt;a href=&quot;https://img.zhikestreet.com/20201128220708.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; data-lightbox=&quot;example-set&quot;&gt;&lt;img src=&quot;https://img.zhikestreet.com/20201128220708.png?imageView2/0/q/75|watermark/2/text/NTJJbnRlcnZpZXc=/font/5a6L5L2T/fontsize/240/fill/IzBFMDkwNQ==/dissolve/100/gravity/SouthEast/dx/10/dy/10&quot; alt=&quot;&quot;/&gt;&lt;/a&gt;&lt;/section&gt;&lt;br/&gt;&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;  写好一个需求文档,让人觉得很专业有很多东西需要学习。这里笔者只根据个人多年的工作经验,抛砖引玉,欢迎大家怕批评和斧正。&lt;/p&gt;
</description>
<pubDate>Sat, 28 Nov 2020 14:36:00 +0000</pubDate>
<dc:creator>戎&quot;码&quot;一生</dc:creator>
<og:description>目录 前言 (思维篇)人人都是产品经理 1.需求文档 1.1 需求管理 1.2 如何攥写需求文档 1.3 需求关键点文档 2 原型设计 2.1 缺失的逻辑 2.2 让想法跃然纸上 3 开发设计文档 3</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lucky_hu/p/14054634.html</dc:identifier>
</item>
<item>
<title>跨域共享CORS详解及Gin配置跨域 - 常见-youmen</title>
<link>http://www.cnblogs.com/you-men/p/14054348.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/you-men/p/14054348.html</guid>
<description>&lt;h4 id=&quot;跨域简介&quot;&gt;跨域简介&lt;/h4&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;当两个域具有相同的协议(如http), 相同的端口(如80)，相同的host，那么我们就可以认为它们是相同的域（协议，域名，端口都必须相同）。&lt;br/&gt;跨域就指着&lt;strong&gt;协议，域名，端口&lt;/strong&gt;不一致，出于安全考虑，跨域的资源之间是无法交互的(例如一般情况跨域的JavaScript无法交互，当然有很多解决跨域的方案)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;解决跨域几种方案&quot;&gt;解决跨域几种方案&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
    CORS 普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，
    前端无须设置，若要带cookie请求：前后端都需要设置。
                
    JSONP 缺点：只能使用get 请求
    document.domain 仅限主域相同，子域不同的跨域应用场景。
    window.name
    websockets
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;跨域资源共享cors&quot;&gt;跨域资源共享CORS&lt;/h4&gt;
&lt;blockquote readability=&quot;7.2380952380952&quot;&gt;
&lt;p&gt;CORS是一个W3C标准，全称是&quot;跨域资源共享&quot;（Cross-origin resource sharing）。&lt;/p&gt;
&lt;p&gt;它允许浏览器向跨源服务器，发出&lt;a href=&quot;http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html&quot;&gt;&lt;code&gt;XMLHttpRequest&lt;/code&gt;&lt;/a&gt;请求，从而克服了AJAX只能&lt;a href=&quot;http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html&quot;&gt;同源&lt;/a&gt;使用的限制。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;cors简介&quot;&gt;Cors简介&lt;/h5&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。&lt;/p&gt;
&lt;p&gt;整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。&lt;/p&gt;
&lt;p&gt;因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;两种请求&quot;&gt;两种请求&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;满足以下两大条件,属于简单请求&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
    （1) 请求方法是以下三种方法之一：
        HEAD
        GET
        POST
    （2）HTTP的头信息不超出以下几种字段：
        Accept
        Accept-Language
        Content-Language
        Last-Event-ID
        Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。&lt;/p&gt;
&lt;p&gt;凡是不同时满足上面两个条件，就属于非简单请求。&lt;/p&gt;
&lt;p&gt;浏览器对这两种请求的处理，是不一样的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;简单请求&quot;&gt;简单请求&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;基本流程&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个&lt;code&gt;Origin&lt;/code&gt;字段。&lt;/p&gt;
&lt;p&gt;下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个&lt;code&gt;Origin&lt;/code&gt;字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
    GET /cors HTTP/1.1
    Origin: http://api.bob.com
    Host: api.alice.com
    Accept-Language: en-US
    Connection: keep-alive
    User-Agent: Mozilla/5.0...
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;上面的头信息中，&lt;code&gt;Origin&lt;/code&gt;字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Origin&lt;/code&gt;指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段（详见下文），就知道出错了，从而抛出一个错误，被&lt;code&gt;XMLHttpRequest&lt;/code&gt;的&lt;code&gt;onerror&lt;/code&gt;回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;Origin&lt;/code&gt;指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
    Access-Control-Allow-Origin: http://api.bob.com
    Access-Control-Allow-Credentials: true
    Access-Control-Expose-Headers: FooBar
    Content-Type: text/html; charset=utf-8
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;上面的头信息之中，有三个与CORS请求相关的字段，都以&lt;code&gt;Access-Control-&lt;/code&gt;开头。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;1 . Access-Control-Allow-Origin&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;该字段是必须的,他的值要么是请求Origin字段的值,要么是一个*, 表示接受任意域名的请求.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;2 . Access-Control-Allow-Credentials&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为&lt;code&gt;true&lt;/code&gt;，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为&lt;code&gt;true&lt;/code&gt;，如果服务器不要浏览器发送Cookie，删除该字段即可.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;3 . Access-Control-Expose-Headers&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;该字段可选。CORS请求时，&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象的&lt;code&gt;getResponseHeader()&lt;/code&gt;方法只能拿到6个基本字段：&lt;code&gt;Cache-Control&lt;/code&gt;、&lt;code&gt;Content-Language&lt;/code&gt;、&lt;code&gt;Content-Type&lt;/code&gt;、&lt;code&gt;Expires&lt;/code&gt;、&lt;code&gt;Last-Modified&lt;/code&gt;、&lt;code&gt;Pragma&lt;/code&gt;。如果想拿到其他字段，就必须在&lt;code&gt;Access-Control-Expose-Headers&lt;/code&gt;里面指定。上面的例子指定，&lt;code&gt;getResponseHeader('FooBar')&lt;/code&gt;可以返回&lt;code&gt;FooBar&lt;/code&gt;字段的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;withcredentials属性&quot;&gt;withCredentials属性&lt;/h5&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定&lt;code&gt;Access-Control-Allow-Credentials&lt;/code&gt;字段。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// Access-Control-Allow-Credentials: true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;另一方面，开发者必须在AJAX请求中打开withCredentials属性。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// var xhr = new XMLHttpRequest();
// xhr.withCredentials = true;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。&lt;/p&gt;
&lt;p&gt;但是，如果省略&lt;code&gt;withCredentials&lt;/code&gt;设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭&lt;code&gt;withCredentials&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// xhr.withCredentials = false;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;需要注意的是，如果要发送Cookie，&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的&lt;code&gt;document.cookie&lt;/code&gt;也无法读取服务器域名下的Cookie。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;非简单请求&quot;&gt;非简单请求&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;预检请求&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;非简单请求是那种对服务器有特殊要求的请求，比如请求方法是&lt;code&gt;PUT&lt;/code&gt;或&lt;code&gt;DELETE&lt;/code&gt;，或者&lt;code&gt;Content-Type&lt;/code&gt;字段的类型是&lt;code&gt;application/json&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。&lt;/p&gt;
&lt;p&gt;浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的&lt;code&gt;XMLHttpRequest&lt;/code&gt;请求，否则就报错。&lt;/p&gt;
&lt;p&gt;下面是一段浏览器的JavaScript脚本。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;var url = 'http://api.alice.com/cors';
var xhr = new XMLHttpRequest();
xhr.open('PUT', url, true);
xhr.setRequestHeader('X-Custom-Header', 'value');
xhr.send();
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;上面代码中，HTTP请求的方法是&lt;code&gt;PUT&lt;/code&gt;，并且发送一个自定义头信息&lt;code&gt;X-Custom-Header&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;浏览器发现，这是一个非简单请求，就自动发出一个&quot;预检&quot;请求，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&quot;预检&quot;请求用的请求方法是&lt;code&gt;OPTIONS&lt;/code&gt;，表示这个请求是用来询问的。头信息里面，关键字段是&lt;code&gt;Origin&lt;/code&gt;，表示请求来自哪个源。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;除了Origin字段，&quot;预检&quot;请求的头信息包括两个特殊字段&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
  （1）Access-Control-Request-Method
  该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。

  （2）Access-Control-Request-Headers
  该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;预检请求的回应&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;服务器收到&quot;预检&quot;请求以后，检查了&lt;code&gt;Origin&lt;/code&gt;、&lt;code&gt;Access-Control-Request-Method&lt;/code&gt;和&lt;code&gt;Access-Control-Request-Headers&lt;/code&gt;字段以后，确认允许跨源请求，就可以做出回应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;上面的HTTP回应中，关键的是&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;字段，表示&lt;code&gt;http://api.bob.com&lt;/code&gt;可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;Access-Control-Allow-Origin: *
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果服务器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被&lt;code&gt;XMLHttpRequest&lt;/code&gt;对象的&lt;code&gt;onerror&lt;/code&gt;回调函数捕获。控制台会打印出如下的报错信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;服务器回应的其他CORS相关字段如下。&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
    Access-Control-Allow-Methods: GET, POST, PUT
    Access-Control-Allow-Headers: X-Custom-Header
    Access-Control-Allow-Credentials: true
    Access-Control-Max-Age: 1728000
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;字段说明&quot;&gt;字段说明&lt;/h5&gt;
&lt;p&gt;&lt;code&gt;1.Access-Control-Allow-Origin&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;首先，客户端请求时要带上一个Origin，用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。然后服务端在返回时需要带上这个字段，并把对方传过来的值返回去。告知客户端，允许这次请求。&lt;br/&gt;这个字段也可以设置为*，即允许所有客户端访问。但是这样做会和Access-Control-Allow-Credentials 起冲突。可能导致跨域请求失败。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;2.Access-Control-Allow-Credentials&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;这个字段是一个&lt;strong&gt;BOOL&lt;/strong&gt;值，可以允许客户端携带一些校验信息，比如cookie等。如果设置为Access-Control-Allow-Origin：*，而该字段是true，并且客户端开启了withCredentials, 仍然不能正确访问。需要把Access-Control-Allow-Origin的值设置为客户端传过来的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;3.Access-Control-Allow-Credentials&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;该字段与简单请求时的含义相同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;4.Access-Control-Max-Age&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h5 id=&quot;浏览器的正常请求和回应&quot;&gt;浏览器的正常请求和回应&lt;/h5&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;一旦服务器通过了&quot;预检&quot;请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个&lt;code&gt;Origin&lt;/code&gt;头信息字段。服务器的回应，也都会有一个&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;头信息字段。&lt;/p&gt;
&lt;p&gt;下面是&quot;预检&quot;请求之后，浏览器的正常CORS请求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                PUT /cors HTTP/1.1
    Origin: http://api.bob.com
    Host: api.alice.com
    X-Custom-Header: value
    Accept-Language: en-US
    Connection: keep-alive
    User-Agent: Mozilla/5.0...
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;上面头信息的&lt;code&gt;Origin&lt;/code&gt;字段是浏览器自动添加的。&lt;/p&gt;
&lt;p&gt;下面是服务器正常的回应。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
    Access-Control-Allow-Origin: http://api.bob.com
    Content-Type: text/html; charset=utf-8
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;与jsonp的比较&quot;&gt;与JSONP的比较&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                CORS与JSONP的使用目的相同，但是比JSONP更强大。

                JSONP只支持GET请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，
                以及可以向不支持CORS的网站请求数据。
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;开启中间件进行跨域&quot;&gt;开启中间件进行跨域&lt;/h4&gt;
&lt;h5 id=&quot;安装cors包&quot;&gt;安装cors包&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;govendor fetch github.com/gin-contrib/cors
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;配置cors跨域&quot;&gt;配置cors跨域&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main
import (
    &quot;github.com/gin-gonic/gin&quot;
    &quot;strings&quot;
    &quot;fmt&quot;
    &quot;net/http&quot;
)

func main() {
        r := gin.Default()
        r.Use(Cors()) //开启中间件 允许使用跨域请求
        r.run()
}

func Cors() gin.HandlerFunc {
    return func(c *gin.Context) {
        method := c.Request.Method
        origin := c.Request.Header.Get(&quot;Origin&quot;) //请求头部
        if origin != &quot;&quot; {
            //接收客户端发送的origin （重要！）
            c.Writer.Header().Set(&quot;Access-Control-Allow-Origin&quot;, origin) 
            //服务器支持的所有跨域请求的方法
            c.Header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, PUT, DELETE,UPDATE&quot;) 
            //允许跨域设置可以返回其他子段，可以自定义字段
            c.Header(&quot;Access-Control-Allow-Headers&quot;, &quot;Authorization, Content-Length, X-CSRF-Token, Token,session&quot;)
            // 允许浏览器（客户端）可以解析的头部 （重要）
            c.Header(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers&quot;) 
            //设置缓存时间
            c.Header(&quot;Access-Control-Max-Age&quot;, &quot;172800&quot;) 
            //允许客户端传递校验信息比如 cookie (重要)
            c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)                                                                                                                                                                                                                          
        }

        //允许类型校验 
        if method == &quot;OPTIONS&quot; {
            c.JSON(http.StatusOK, &quot;ok!&quot;)
        }

        defer func() {
            if err := recover(); err != nil {
                log.Printf(&quot;Panic info is: %v&quot;, err)
            }
        }()

        c.Next()
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Example&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;// 处理跨域请求,支持options访问
func Cors() gin.HandlerFunc {
        return func(c *gin.Context) {
                method := c.Request.Method
 
                c.Header(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;)
                c.Header(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,AccessToken,X-CSRF-Token, Authorization, Token&quot;)
                c.Header(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS&quot;)
                c.Header(&quot;Access-Control-Expose-Headers&quot;, &quot;Content-Length, Access-Control-Allow-Origin, Access-Control-Allow-Headers, Content-Type&quot;)
                c.Header(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)
 
                //放行所有OPTIONS方法
                if method == &quot;OPTIONS&quot; {
                        c.AbortWithStatus(http.StatusNoContent)
                }
                // 处理请求
                c.Next()
        }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;CORS原理讲解有部分借鉴于 阮一峰 写的博客&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Nov 2020 13:59:00 +0000</pubDate>
<dc:creator>常见-youmen</dc:creator>
<og:description>跨域简介 当两个域具有相同的协议(如http), 相同的端口(如80)，相同的host，那么我们就可以认为它们是相同的域（协议，域名，端口都必须相同）。 跨域就指着协议，域名，端口不一致，出于安全考虑</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/you-men/p/14054348.html</dc:identifier>
</item>
<item>
<title>IPv6 Rapid Deployment, IPv6 6rd初探 - KingPop</title>
<link>http://www.cnblogs.com/kingpop/p/14054321.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingpop/p/14054321.html</guid>
<description>&lt;h3 id=&quot;ipv6-rapid-deployment-provide-ipv6-access-to-customers-over-an-ipv4-only-network&quot;&gt;IPv6 Rapid Deployment: Provide IPv6 Access to Customers over an IPv4-Only Network&lt;/h3&gt;
&lt;p&gt;原文地址：&lt;a href=&quot;https://www.cisco.com/c/en/us/products/collateral/ios-nx-os-software/enterprise-ipv6-solution/whitepaper_c11-665758.html&quot;&gt;https://www.cisco.com/c/en/us/products/collateral/ios-nx-os-software/enterprise-ipv6-solution/whitepaper_c11-665758.html&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;一、你将会学到什么？&quot;&gt;一、你将会学到什么？&lt;/h4&gt;
&lt;p&gt;IPv6 rapid deployment(6rd)(RFC 5969)是一种无状态隧道机制，它允许一个服务商在不要求升级已存在的IPv4接入网络基础设施的情况下，轻巧安全的快速部署IPv6。当然这里有一系列方法通过IPv4来承载IPv6，6rd的方式尤其成功，其主要在于他的实施是一个轻巧、自然地可扩展、有弹性且易于配置的无感知模式。6rd提供的服务是生产质量，使得所有的客户和整个Internet看起似乎是原生的本地IPv6网络。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;本文提出：
&lt;ul&gt;&lt;li&gt;6rd技术描述&lt;/li&gt;
&lt;li&gt;6rd部署场景&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h5 id=&quot;11-6rd作业概述：&quot;&gt;1.1 6rd作业概述：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128212216024-1994669048.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;图 1提供一个6rd作业的视图&lt;br/&gt;6rd由两个主要的硬件组件组成，CE(Customer Equipment)路由器和BR（Border Relay）路由器。&lt;/p&gt;
&lt;h5 id=&quot;12-ce路由器（客户边缘路由器）：&quot;&gt;1.2 CE路由器（客户边缘路由器）：&lt;/h5&gt;
&lt;p&gt;CE路由器位置在服务商提供IPv4接入基础设施的边缘和为这些终端用户网络提供IPv6通信。来自于这些终端用户的原生IPv6流量通过CE路由器封装成IPv4，隧道连接到BR路由器和或直接送到相同6rd域的其他CE路由器。反过来，通过BR路由器从Internet网接收到的封装的6rd流量和来自其他CE路由器的6rd流量将会被解封装后，并转发到最终用户节点。&lt;/p&gt;
&lt;h5 id=&quot;13-br路由器&quot;&gt;1.3 BR路由器&lt;/h5&gt;
&lt;p&gt;BR路由器提供CE路由器和IPv6网络（公有网络或私有网络）两者之间的通信。CE和BR路由两者都是双栈（IPv4和IPv6）设备，在BR和CE两者之间可以仅是IPv4。&lt;br/&gt;在CE路由器，如果IPv6报文的目的地址和本地配置的6rd前缀匹配，这个报文会被认为是本地6rd域的一部分，需要被转发到其他CE路由器。在这种情况下，IPv4地址嵌入在IPv6的目的地址中，作为6rd隧道的目的地址使用。本地WAN接口的IPv4地址将被用作6rd隧道的源地址，这个IPv6报文直接封装成IPv4。如果IPv6目的地址和本地配置的6rd前缀不匹配就另说，如果这个报文不属于本地6rd域，这个报文将会通过6rd隧道隧穿到BR路由器。在这种情况下，在CE路由器本地配置的BR IPv4地址将被用作封装作报文的目的地址。&lt;/p&gt;
&lt;h5 id=&quot;14-6rd作业详述：&quot;&gt;1.4 6rd作业详述：&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128212936581-130024612.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;6rd的CE LAN侧接口承载IPv6主机来回的流量&lt;/li&gt;
&lt;li&gt;多点隧道接口承载隧道封装的往返于IPv6主机的流量&lt;/li&gt;
&lt;li&gt;用于6rd隧道封装的是直接的IPv6-in-IPv4的封装。IPv4协议字段被设置为协议号：41。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128213034754-74237832.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;6rd委托前缀&quot;&gt;6rd委托前缀&lt;/h5&gt;
&lt;p&gt;图2展示的网络中，CE路由器给他的网站提供一个范围的前缀。这些前缀称作6rd委托前缀和IPv6域主机配置协议（DHCPv6）的PD前缀相似。一个6rd委托前缀有以下几个元素组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务商选择一个IPv6前缀用于给定6rd部署的通用6rd服务提供前缀；&lt;/li&gt;
&lt;li&gt;为CE路由器分配的IPv4地址，这个地址可以是私有的也可以是全局的；6rd不会必须使用IPv4地址整个32bit（在后面的文档中进行解释）。&lt;br/&gt;思考图3中的示例：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128213134503-176281706.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;图3的示例显示了一下内容：&lt;/li&gt;
&lt;li&gt;服务提供商选择的前缀是：2001:DB8::/32&lt;/li&gt;
&lt;li&gt;每一个6rd CE路由器从10.0.0./8块中使用一个IPv4地址。在6rd中，你可以嵌入少于32bit的IPv4地址到6rd委托前缀。通过引入以下两个概念使该动作成为可能：
&lt;ol&gt;&lt;li&gt;IPv4通用前缀：在6rd域中的所有6rd CE路由器和BR路由器可以共享一个通用IPv4前缀用于他们的IPv4地址块。这个通用前缀已分配给6rd域中所有节点，因此不需要IPv6地址携带以标识隧道终点。在图3的示例中，IPv4的通用前缀是10.0.0.0/8。&lt;/li&gt;
&lt;li&gt;IPv4通用后缀：所有6rd CE路由器和BR路由器可以统一一个通用的IPv4地址尾部来标识隧道终点。例如，在这个示例中，假设IPv4的通用后缀是0.0.0.1/8。后缀的实现通过隧道传输终点将会使用（在CE路由器上，在6rd CE WAN侧的接口地址是一个典型的IPv4地址，将被用作隧道源地址）：
&lt;ul&gt;&lt;li&gt;CE1：10.1.1.1&lt;/li&gt;
&lt;li&gt;CE2：10.1.2.1&lt;/li&gt;
&lt;li&gt;BR： 10.1.3.1&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;IPv4地址块中的这些bit数是独立的，在一个域中不同的6rd CE路由器和BR路由器可以按照以下方式计算：&lt;br/&gt;32 bits - （IPv4通用前缀长度）-（IPv4通用后缀长度）&lt;br/&gt;在前面的示例中，值将会是：&lt;br/&gt;32 - 16 – 8 = 8。&lt;br/&gt;这8bit需要嵌入在6rd委托前缀中。&lt;/li&gt;
&lt;li&gt;因此，6rd委托前缀长度是服务商选择的前缀长度和同一域中6rd CE路由器和BR路由器IPv4地址块中不相同的bit数之和；在前面的示例中，这个长度是：&lt;br/&gt;32 + 8 = 40&lt;/li&gt;
&lt;li&gt;6rd的参数在表1中显示&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128214522425-1006188459.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;示例2：&lt;br/&gt;很常见的是挑战服务提供商受限于现有服务提供者，导致在6rd地址空间压缩IPv4地址是不行的。因为这个，整个IPv4地址的32bit需要插入6rd IPv6地址，如下图4所示：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128213739288-1636275319.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;区域注册机构（RIPE、ARIN等）正在研究一种模型，其中一个服务提供商通过6rd提供IPv6服务可以获得一个/29的IPv6地址分配，来替代小于 /32的地址分配。这将为每位终点用户网提供3bit用于分割本地网络，从而为每个终点用户提供8个子网。&lt;/p&gt;
&lt;p&gt;6rd地址隧道终点的确定：&lt;br/&gt;当目的地是6rd域地址的本机IPv6报文到达一个6rd CE路由器，它将被送到适当的目标CE路由器。6rd隧道的目的IPv4地址通过以下规则来获取：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确定IPv6头中携带的IPv4地址bit数，如下所示：&lt;br/&gt;（32bits）-（IPv4 通用前缀长度）-（IPv4通用后缀长度）&lt;/li&gt;
&lt;li&gt;确定这些bit在IPv6头中的位置。图4展示了6rd域的前缀长度&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128213814937-1204278969.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;li&gt;提取IPv6目的地址头中携带的IPv4地址。现在知道6rd域地址和通用前缀长度就可以执行提取。&lt;/li&gt;
&lt;li&gt;起始是IPv4的通用前缀，然后拼接从IPv6头中提取的bit，最后拼接IPv4通用后缀。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128213847210-735550821.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;现在应用之前的算法到先前介绍的6rd网络中。思考一个报文的目的主机是2001:DB8:0100::11，它是CE网站1的一个主机。&lt;/li&gt;
&lt;li&gt;IPv6头中携带的bit数是：&lt;br/&gt;（32bits）-（IPv4通用前缀长度）-（IPv4通用后缀长度）&lt;br/&gt;这儿，值是：32 – 16 = 8&lt;/li&gt;
&lt;li&gt;确定了位于IPv6头中的这些bit后，6rd本地域前缀长度是32&lt;/li&gt;
&lt;li&gt;提取IPv6头中携带的IPv4地址的bit。现在你知道了位置和长度既可执行提取。结果是8位介于33至40bit之间的二进制值。示例如下：&lt;br/&gt;从2001:DB8:0100::11中32bit开始提取8bit，产生16进制0x01（IPv6地址是十六进制的）。二进制值是：00000001，在十进制编号系统中是1。
&lt;ul&gt;&lt;li&gt;重建远程6rd CE路由器地址，以IPv4通用前缀开始，拼接从IPv6头中提取的bit数，在拼接IPv4通用后缀。&lt;br/&gt;结果是：10.1.1.1，这个是CE1的地址。&lt;br/&gt;每当CE路由器收到目的地为第六本地域内的目的地的IPv6数据包时，都会运行前面的第六隧道端点确定。&lt;br/&gt;如果收到本地IPv6报文发往超出了6rd本地域的IPv6 Internet网，6rd BR路由器的IPv4地址将由手动输入提供。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;路由考虑：&quot;&gt;路由考虑：&lt;/h5&gt;
&lt;p&gt;本地路由用于同一6rd域的CE和BR路由器之间。为了实现高可用性，可以配置一个以上的BR路由器。为了达到这个目的，BR路由器必须使用在IPv4内部网关协议（IGP）中通告IPv4任播地址，导致6rd域中有多个6rd BR路由器。CE路由器将会基于IGP的选举规则使用最近的BR路由器。&lt;br/&gt;服务提供商必须向IPv6 Internet宣布已注册的IPv6地址范围（第6个委托前缀），以实现全球可达性。&lt;/p&gt;
&lt;h4 id=&quot;二、一个6rd报文的生命周期&quot;&gt;二、一个6rd报文的生命周期&lt;/h4&gt;
&lt;p&gt;本节逐步说明数据包如何从CE路由器发送到另一个CE路由器或IPv6 Internet并返回（图7）。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128214005294-1665892657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;21-ce到ce：&quot;&gt;2.1 CE到CE：&lt;/h5&gt;
&lt;p&gt;如果IPv6目标地址落在本地配置的6rd域前缀的范围内，然后需要转发到另一个6rd CE路由器，则将在面向客户的接口上本地接收IPv6流量（图8）。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128214044345-1985184471.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这个IPv6报文封装在IPv4标记头中。嵌入的IPv4地址复制到IPv4目的地址中。本地配置的隧道源地址复制为IPv4源地址。IPv4的隧道头的协议字段的类型被设置为41（IPv6 in IPv4）。&lt;br/&gt;隧道化IPv6数据包的IPv4数据包通过遵循IPv4路由表的IPv4域转发到目标CE路由器。&lt;br/&gt;目的CE路由器接收这个隧道化的IPv6报文，然后将IPv4头移除。出于安全措施，IPv4头中的源地址将要和嵌入在IPv6头中的IPv4地址做比较。如果不匹配，报文将会被丢弃。如果匹配，这个IPv6报文将会被视为一个本地IPv6报文转发到CE LAN侧的IPv6目标地址去。&lt;/p&gt;
&lt;h5 id=&quot;22-ce到ipv6-internet网&quot;&gt;2.2 CE到IPv6 Internet网&lt;/h5&gt;
&lt;p&gt;在CE到IPv6 Internet的场景中，IPv6流量在面向用户侧的接口时本地接收的。IPv6目的地址没有填入本地配置的6rd前缀的范围，这意味着它不针对本地6rd域内的目标。在这种情况下，报文需要被转发到6rd BR路由器。&lt;br/&gt;在CE到CE的场景中，IPv6头封装在IPv4头中。然而，不同之处在于本地配置的BR IPv4地址复制到IPv4的目的地址。此外，本地配置的隧道源地址复制到IPv4源地址。协议字段设置为41（IPv4中的IPv6），然后，按照正常的IPv4路由表将封装的数据包通过IPv4域转发到BR路由器。&lt;br/&gt;BR路由器接收IPv4数据包并删除IPv4标头封装。 将IPv4标头源地址与嵌入在IPv6源地址中的IPv4地址进行比较。 如果地址不匹配，则丢弃该数据包。 否则，IPv6数据包将本地转发到IPv6目标地址。&lt;/p&gt;
&lt;h5 id=&quot;23-ipv6-internet到ce&quot;&gt;2.3 IPv6 Internet到CE&lt;/h5&gt;
&lt;p&gt;在从IPv6 Internet到CE的场景中，BR路由器从其面向IPv6网络的接口之一接收本地IPv6数据包。 IPv6目标地址属于本地配置的6rd前缀的范围，这意味着它以本地第6个域内的目标为目标。 在这种情况下，需要将数据包转发到适当的CE路由器（图9）。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128214117660-69527598.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;6rd BR路由器会将IPv6数据包封装在IPv4标头中。 IPv6标头中嵌入的IPv4地址用作IPv4目标地址。 隧道的源地址将是在6rd BR路由器的6rd隧道接口上配置的IPv4地址。 标头中的IPv4数据包的协议字段设置为41（IPv4中的IPv6）。 然后，数据包由第六BR路由器使用传统的IPv4转发路径转发到第六CE路由器。&lt;/p&gt;
&lt;p&gt;当CE路由器接收到隧道化的6rd IPv4报文，为了暴露封装的IPv6报文将会移除IPv4头。首先，IPv4头源地址将和本地配置的6rd BR IPv4地址进行比较。如果地址不匹配报文将被丢弃。如果匹配，则6rd CE路由器通过IPv6将IPv6报文本地转发到IPv6目标地址。&lt;/p&gt;
&lt;h4 id=&quot;三、配置：&quot;&gt;三、配置：&lt;/h4&gt;
&lt;p&gt;6rd CE路由器委派的IPv6地址是从本地WAN接口IPv4地址与第六个前缀组合得出的。 可以手动配置地址。但是，通常会通过DHCPv4从连接的服务提供商接收IPv4地址。&lt;br/&gt;除了此IPv4地址，还必须配置其他信息。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;6rd前缀：这是在整个6rd域中使用的通用前缀，它确定数据包是针对6rd域内部还是外部的目的地；&lt;/li&gt;
&lt;li&gt;6rd前缀长度：此参数提供有关第6个前缀中的值位的信息；&lt;/li&gt;
&lt;li&gt;IPv4掩码长度：此参数指定在所有6rd CE和BR路由器IPv4地址中共有多少位，因此可以在站点的6rd前缀内压缩。 在Cisco IOS软件内，可以压缩来自IPv4前缀和后缀的位。&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;31-cisco的基本配置：&quot;&gt;3.1 Cisco的基本配置：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;BR Router

IPv6 general-prefix DELEGATED_PREFIX 6rd Tunnel0
interface Loopback0
ip address 10.0.0.1 255.255.255.0
!
interface Tunnel0
tunnel source Loopback0
tunnel mode IPv6ip 6rd
tunnel6rd IPv4 prefix-len 8
tunnel6rd prefix 2001:db80::/32
IPv6 address DELEGATED_PREFIX::/128 anycast
!
IPv6 route 2001:db80::/32 Tunnel0
IPv6 route ::/0 2001:babe::1
CE Router

IPv6 general-prefix DELEGATED_PREFIX6rd Tunnel0
interface Dialer0
ip address dhcp ! (10.1.1.1)
!
interface Tunnel0
tunnel source Dialer0
tunnel mode IPv6ip 6rd
tunnel 6rd IPv4 prefix-len 8
tunnel 6rd prefix 2001:db80::/32
tunnel 6rd br 10.1.3.1
IPv6 address DELEGATED_PREFIX ::/128 anycast
!
interface Ethernet0
IPv6 address DELEGATED_PREFIX ::/64 eui-64
!
IPv6 route 2001:db80::/28 Tunnel0
IPv6 route ::/0 Tunnel0, 2001:db80:a000:0010::
IPv6 route 2001:db80:0:A00::/56 Null0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;32-linux的配置步骤：&quot;&gt;3.2 Linux的配置步骤：&lt;/h5&gt;
&lt;p&gt;三台Linux虚拟构建网络拓扑。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128214252502-178764535.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#配置CE设备
ip address add 192.168.110.27 dev eth0
ip link set eth0 up
ip tunnel add kali006rd mode sit local 192.168.110.27
ip tunnel 6rd dev kali006rd 6rd-prefix 2012:db8::/32 6rd-relay_prefix 192.168.147.136/32
ip link set kali006rd up
ip -6 addr add 2012:db8:c0a8:6e1b::1/64 dev kali006rd 
ip -6 route add 2012:db8::/32 dev kali006rd
ip -6 route add default via ::192.168.147.136

#配置ISP
ip address add 192.168.147.1 dev eth0
ip link set eth0 up
ip address add 192.168.110.1 dev eth1
ip link set eth1 up

#配置BR设备
ip address add 192.168.147.136 dev eth0
ip link set eth0 up
ip tunnel add kali006rd mode sit local 192.168.147.136
ip tunnel 6rd dev kali006rd 6rd-prefix 2012:db8::/32
ip link set kali006rd up
ip -6 addr add 2012:db8:c0a8:9388::1/64 dev kali006rd 
ip -6 route add 2012:db8::/32 dev kali006rd

#在CE设备测试连通性：
root@kalimk:~# ping6 2012:db8:c0a8:9388::1 -c 5
PING 2012:db8:c0a8:9388::1(2012:db8:c0a8:9388::1) 56 data bytes
64 bytes from 2012:db8:c0a8:9388::1: icmp_seq=1 ttl=64 time=0.759 ms
64 bytes from 2012:db8:c0a8:9388::1: icmp_seq=2 ttl=64 time=1.64 ms
64 bytes from 2012:db8:c0a8:9388::1: icmp_seq=3 ttl=64 time=0.769 ms
64 bytes from 2012:db8:c0a8:9388::1: icmp_seq=4 ttl=64 time=0.606 ms
64 bytes from 2012:db8:c0a8:9388::1: icmp_seq=5 ttl=64 time=0.710 ms

--- 2012:db8:c0a8:9388::1 ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4065ms
rtt min/avg/max/mdev = 0.606/0.897/1.642/0.376 ms

#在BR设备创建一个IPv6/IPv4 Internet
ip link del kaliBr0
ip link add dev kaliBr0 type bridge
ip link set kaliBr0 up
ip -6 addr add 2233:ccc::1/64 dev kaliBr0

#在CE设备测试连通性：
root@kalimk:~# ping6 2233:ccc::1 
PING 2233:ccc::1(2233:ccc::1) 56 data bytes
64 bytes from 2233:ccc::1: icmp_seq=1 ttl=64 time=0.723 ms
64 bytes from 2233:ccc::1: icmp_seq=2 ttl=64 time=0.424 ms
64 bytes from 2233:ccc::1: icmp_seq=3 ttl=64 time=0.722 ms
64 bytes from 2233:ccc::1: icmp_seq=4 ttl=64 time=1.69 ms
64 bytes from 2233:ccc::1: icmp_seq=5 ttl=64 time=0.887 ms
64 bytes from 2233:ccc::1: icmp_seq=6 ttl=64 time=1.62 ms
64 bytes from 2233:ccc::1: icmp_seq=7 ttl=64 time=0.603 ms
64 bytes from 2233:ccc::1: icmp_seq=8 ttl=64 time=0.642 ms
64 bytes from 2233:ccc::1: icmp_seq=9 ttl=64 time=0.596 ms
64 bytes from 2233:ccc::1: icmp_seq=10 ttl=64 time=0.677 ms

--- 2233:ccc::1 ping statistics ---
10 packets transmitted, 10 received, 0% packet loss, time 9138ms
rtt min/avg/max/mdev = 0.424/0.858/1.687/0.413 ms
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：CE和BR之间，只能存在IPv4网络，需要将网卡的IPv6都禁用掉。&lt;br/&gt;我的环境是KaliLinux：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1040597/202011/1040597-20201128214323785-1535058725.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;四、其他考虑：&quot;&gt;四、其他考虑：&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;最大传输单元和分片&lt;/li&gt;
&lt;li&gt;6rd和6to4&lt;br/&gt;6rd是自动6to4隧道机制（RFC 3056）的一般化。 它克服了6to4自动隧道机制最大的缺点：对所有6to4站点使用众所周知的固定前缀2002 :: / 16。 该IPv6前缀由IPv6 Internet上的许多路由器（也称为6to4中继路由器）注入。 直接后果是，流量可能不对称，服务提供商无法控制返回路径的6to4中继，并且当本机IPv6可用时，站点必须重新编号。 第六种机制通过允许每个服务提供商为每个客户使用唯一的IPv6前缀来消除这些缺点，从而有助于确保不需要其他不受信任的第三方中继。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;参考链接：&lt;br/&gt;&lt;a href=&quot;https://blog.51cto.com/enderjoe/2367434?source=dra&quot;&gt;https://blog.51cto.com/enderjoe/2367434?source=dra&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/qq_39628285/article/details/105230013?utm_medium=distribute.pc_relevant&quot;&gt;https://blog.csdn.net/qq_39628285/article/details/105230013?utm_medium=distribute.pc_relevant&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Nov 2020 13:54:00 +0000</pubDate>
<dc:creator>KingPop</dc:creator>
<og:description>###IPv6 Rapid Deployment: Provide IPv6 Access to Customers over an IPv4-Only Network 原文地址：https://ww</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kingpop/p/14054321.html</dc:identifier>
</item>
<item>
<title>重学数据结构（七、图） - 三分恶</title>
<link>http://www.cnblogs.com/three-fighter/p/14054307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/three-fighter/p/14054307.html</guid>
<description>&lt;p&gt;@&lt;/p&gt;

&lt;br/&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;图是一种比线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系，并且每一层中的数据元素可能和下一层中的多个元素（即其孩子结点）相关，但只能和上一层中一个元素（即其双亲结点）相关； 而在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在计算机科学中的图是由点和边构成的。&lt;/p&gt;

&lt;center&gt;&lt;span&gt;图1：图的示意图&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201122170320653.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;1、图的定义&quot;&gt;1、图的定义&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;图(Graph)&lt;/strong&gt; G由两个集合V和E组成，记为G=(V,E) , 其中V是&lt;strong&gt;顶点&lt;/strong&gt;的有穷非空集合，E是V中&lt;strong&gt;顶点偶对&lt;/strong&gt;的有穷集合，这些顶点偶对称为&lt;strong&gt;边&lt;/strong&gt;。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若 E(G)为空，则图G只有顶点而没有边。&lt;/p&gt;
&lt;p&gt;对于图G ,若边集E(G)为有向边的集合，则称该图为有向图；若边集E(G)为无向边的集合，则称该图为无向图。&lt;/p&gt;

&lt;center&gt;&lt;span&gt;图2：无向图（a）和有向图（b）&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201122171200989.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在有向图中，&lt;strong&gt;顶点对&amp;lt;x, y&amp;gt;是有序的&lt;/strong&gt;，它称为从顶点 x到顶点y的一条有向边。 因此&amp;lt;x,y&amp;gt;与&amp;lt;y, x&amp;gt;是不同的两条边。 顶点对用一对尖括号括起来，x是有向边的始点，y是有向边的终点。&amp;lt;x, y&amp;gt;也称作一条弧，则 x为弧尾， y为弧头。&lt;/p&gt;
&lt;p&gt;在无向图中，&lt;strong&gt;顶点对&amp;lt;x, y&amp;gt;是无序的&lt;/strong&gt;，它称为从顶点 x与顶点y相关联的一条边。这条边没有特定的方向，（x,y） 和 （y,x）是同一条边。为了区别于有向图，无向图的一对顶点用括号括起来。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;2、图的基本术语&quot;&gt;2、图的基本术语&lt;/h2&gt;
&lt;p&gt;用n表示图中顶点数目，用e表示边的数目， 来看看图结构中的一些基本术语。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;子图&lt;/strong&gt;：假设有两个图 G = (V, E)和 G'= (V', E'), 如果V'己V 且 E'&lt;span class=&quot;math inline&quot;&gt;\(\subseteq\)&lt;/span&gt;E, 则称 G'为 G 的子图。例如， 图 3 所示为图 2 中 G 1 和 G2 子图的一些例子。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;span&gt;图3：子图示例&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201122173032526.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;10.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;无向完全图和有向完全图&lt;/strong&gt;：对千无向图， 若具有 n(n- 1)/2 条边，则称为无向完全图。对于有向图， 若具有 n(n- l)条弧，则称为有向完全图。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;稀疏图和稠密图&lt;/strong&gt;：有很少条边或弧（如 e&amp;lt;nlog2n) 的图称为稀疏图， 反之称为稠密图。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;权和网&lt;/strong&gt;：在实际应用中，每条边可以标上具有某种含义的数值，该数值称为该边上的&lt;strong&gt;权&lt;/strong&gt;。这些权可以表示从一个顶点到另一个顶点的距离或耗费。这种带权的图通常称为&lt;strong&gt;网&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;邻接点&lt;/strong&gt;：对于 无向图 G, 如果图的边 (v, v')&lt;span class=&quot;math inline&quot;&gt;\(\in\)&lt;/span&gt;E, 则称顶点 v 和 v'互为邻接点， 即 v 和 v'相邻接。边 (v, v')&lt;strong&gt;依附&lt;/strong&gt;于顶点 v 和 v', 或者说边 (v, v')与顶点 v 和 v'&lt;strong&gt;相关联&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;&lt;strong&gt;度、入度和出度&lt;/strong&gt;：顶知的度是指和v 相关联的边的数目，记为 TD(v) 。例如，图2 (b) 中G2的顶点 V3 的度是3。对于有向图，顶点v的度分为&lt;strong&gt;入度和出度&lt;/strong&gt;。&lt;strong&gt;入度&lt;/strong&gt;是以顶点v为头的弧的数目，记为 ID(v); &lt;strong&gt;出度&lt;/strong&gt;是以顶点 v 为尾的弧的数目，记为OD(v)。顶点 v 的度为 TD(v) = ID(v) + OD(可。例如，图2中 G1 的顶点v1的入度 ID(v1)=1, 出度 OD(v1)=2, 度TD(v1)= ID(v1) + OD(v1) =3。一般地，如果顶点 Vi 的度记为 TD(vi)，那么一个有n个顶点，e条边的图，满足如下关系:&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201122174610899.png#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;13&quot;&gt;&lt;li readability=&quot;17&quot;&gt;
&lt;p&gt;路径和路径长度：在无向图 G 中，从 顶点 v 到顶点 v'的 路径是一个顶点序列 (v = vi,0,Vi, 1,…, i;, m= v'), 其中 (vi,j-1, vi,j)&lt;span class=&quot;math inline&quot;&gt;\(\in\)&lt;/span&gt;E, 其中1&lt;span class=&quot;math inline&quot;&gt;\(\leq\)&lt;/span&gt;j&lt;span class=&quot;math inline&quot;&gt;\(\leq\)&lt;/span&gt;m。 如果 G 是有向图， 则路径也是有向的，顶点序列应满 足 &amp;lt;v;,1-1, vi,j）&amp;gt;&lt;span class=&quot;math inline&quot;&gt;\(\in\)&lt;/span&gt;E, 其中1&lt;span class=&quot;math inline&quot;&gt;\(\leq\)&lt;/span&gt;j&lt;span class=&quot;math inline&quot;&gt;\(\leq\)&lt;/span&gt;m。 路径长度是一条路径上经过的边或弧的数目。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;回路或环&lt;/strong&gt;：第一个顶点和最后一个顶点相同的路径称为&lt;strong&gt;回路或环&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;strong&gt;简单路径、 简单回路或简单环&lt;/strong&gt;：序列中顶点不重复出现的路径称为&lt;strong&gt;简单路径&lt;/strong&gt;。除了第一个顶点和最后一个顶点之外， 其余顶点不重复出现的回路，称为&lt;strong&gt;简单回路&lt;/strong&gt;或&lt;strong&gt;简单环&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;&lt;strong&gt;连通、连通图和连通分量&lt;/strong&gt;：在无向图 G 中，如果从顶点 v 到顶点 v'有路径，则称 v 和 v'是连通的。如果对于图中任意两个顶点 Vi、 Vj&lt;span class=&quot;math inline&quot;&gt;\(\in\)&lt;/span&gt;V, Vi 和 Vj 都是连通的，则称 G 是连通图。图 2&lt;br/&gt;(b)中的 G2 就是一个连通图，而图 4 (a) 中的 G3 则是非连通图，但 G3 有 3个连通分量，如图&lt;br/&gt;4 (b) 所示。所谓连通分量， 指的是无向图中的极大连通子图。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;span&gt;图4：无向图及其连通分量&lt;/span&gt;&lt;/center&gt;
&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201122180046375.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;ul&gt;&lt;li&gt;强连通图和强连通分量：在有向图 G 中，如果对于每一对 Vi, Vj &lt;span class=&quot;math inline&quot;&gt;\(\in\)&lt;/span&gt;V,Vi&lt;span class=&quot;math inline&quot;&gt;\(\not=\)&lt;/span&gt;Vj, 从 Vi到 Vj和&lt;br/&gt;从 Vj 到Vi都存在路径，则称G是强连通图。有向图中的极大强连通子图称作有向图的强连通分量。例如图2 中的G1 不是强连通图，但它有两个强连通分量，如图5所示。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;span&gt;图5：G1 的两个强连通分量&lt;/span&gt;&lt;/center&gt;
&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201122180356809.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;连通图的生成树&lt;/strong&gt;:一个极小连通子图，它含有图中全部顶点，但只有足以构成一棵树的 n-1 条边，这样的连通子图称为连通图的生成树。图6所示为G3 中最大连通分量的一棵生成树。如果在一棵生成树上添加一条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;span&gt;图6：G3的最大连通分量的一棵生成树&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201122180609456.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;有向树和生成森林&lt;/strong&gt;：有一个顶点的入度为 0, 其余顶点的入度均为 l1的有向图称为有向树。 一个有向图的生成森林是由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。 图7所示为其一例。&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;&lt;span&gt;图7：一个有向图及其生成森林&lt;/span&gt;&lt;/center&gt;
&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201122180811145.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;p&gt;图的存储结构相较线性表与树来说就更加复杂。&lt;/p&gt;
&lt;p&gt;图的存储结构比较常见的有两种，邻接矩阵和邻接表。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;1、邻接矩阵&quot;&gt;1、邻接矩阵&lt;/h2&gt;
&lt;p&gt;具体地，若图 G 中包含 n 个顶点，我们就使用一个 n×n 的方阵 A，并使每一顶点都分别对应于某一行（列）。既然图所描述的是这些顶点各自对应的元素之间的二元关系，故可以很自然地将任意一对元素 u 和 v 之间可能存在二元关系与矩阵 A 中对应的单元 A[u, v]对应起来： 1 或 true 表示存在关系， 0 或 false 表示不存在关系。这一矩阵中的各个单元分别描述了一对元素之间可能存在的邻接关系，故此得名。&lt;/p&gt;

&lt;center&gt;&lt;span&gt;图8：邻接矩阵存储示意图&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201128194242836.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(a)是无向图， (b)是有向图。无向图的邻接矩阵，是一个对称矩阵。在图中所示的矩阵，a[i][j] 值都为1，如果是带权的图，我们可以将其设置为权值。&lt;/p&gt;
&lt;p&gt;这一表示形式也可以推广至带权图，具体方法是，将每条边的权重记录在该边对应得矩阵单元中。&lt;/p&gt;
&lt;p&gt;需要注意的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;(1) 邻接矩阵表示法对于以图的顶点为主的运算比较适用；&lt;/li&gt;
&lt;li&gt;(2) 除完全图外， 其他图的邻接矩阵有许多零元素， 特别是当 n 值较大， 而边数相对完全图的边又少得多时， 则此矩阵称为“ 稀疏矩阵” ， 比较浪费存储空间。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;图的邻接矩阵表示方法简单实现如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @Author 三分恶
 * @Date 2020/11/28
 * @Description 图的邻接矩阵存储实现
 */
public class AMWGraph {
    private ArrayList vertexList;//存储点的链表
    private int[][] edges;//邻接矩阵，用来存储边
    private int numOfEdges;//边的数目

    public AMWGraph(int n) {
        //初始化矩阵，一维数组，和边的数目
        edges=new int[n][n];
        vertexList=new ArrayList(n);
        numOfEdges=0;
    }

    //得到结点的个数
    public int getNumOfVertex() {
        return vertexList.size();
    }

    //得到边的数目
    public int getNumOfEdges() {
        return numOfEdges;
    }

    //返回结点i的数据
    public Object getValueByIndex(int i) {
        return vertexList.get(i);
    }

    //返回v1,v2的权值
    public int getWeight(int v1,int v2) {
        return edges[v1][v2];
    }

    //插入结点
    public void insertVertex(Object vertex) {
        vertexList.add(vertexList.size(),vertex);
    }

    //插入结点
    public void insertEdge(int v1,int v2,int weight) {
        edges[v1][v2]=weight;
        numOfEdges++;
    }

    //删除结点
    public void deleteEdge(int v1,int v2) {
        edges[v1][v2]=0;
        numOfEdges--;
    }

    //得到第一个邻接结点的下标
    public int getFirstNeighbor(int index) {
        for(int j=0;j&amp;lt;vertexList.size();j++) {
            if (edges[index][j]&amp;gt;0) {
                return j;
            }
        }
        return -1;
    }

    //根据前一个邻接结点的下标来取得下一个邻接结点
    public int getNextNeighbor(int v1,int v2) {
        for (int j=v2+1;j&amp;lt;vertexList.size();j++) {
            if (edges[v1][j]&amp;gt;0) {
                return j;
            }
        }
        return -1;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;2、邻接表&quot;&gt;2、邻接表&lt;/h2&gt;
&lt;p&gt;邻接矩阵虽然比较直观，但是空间利用率是上并不理想。其中大量的单元所对应的边有可能并未在图中出现，这也是静态向量结构普遍的不足。既然如此，我们为什么不将向量改为列表呢？&lt;/p&gt;
&lt;p&gt;邻接表是图的一种链接存储结构。 邻接表表示法只关心存在的边,将顶点的邻接边用列表表示。&lt;/p&gt;

&lt;center&gt;&lt;span&gt;图9：邻接表存储示意图&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201128204303459.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;我们来看一下具体的实现。&lt;/p&gt;
&lt;br/&gt;&lt;h3 id=&quot;21、有向图接口定义&quot;&gt;2.1、有向图接口定义&lt;/h3&gt;
&lt;p&gt;这是有向图的抽象接口定义。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @Author 三分恶
 * @Date 2020/11/28
 * @Description 有向图接口
 */
public interface IDirectGraph&amp;lt;V&amp;gt; {

    /**
     * 新增顶点
     *
     * @param v 顶点
     * @since 0.0.2
     */
    void addVertex(final V v);

    /**
     * 删除顶点
     *
     * @param v 顶点
     * @return 是否删除成功
     * @since 0.0.2
     */
    boolean removeVertex(final V v);

    /**
     * 获取顶点
     *
     * @param index 下标
     * @return 返回顶点信息
     * @since 0.0.2
     */
    V getVertex(final int index);

    /**
     * 新增边
     *
     * @param edge 边
     * @since 0.0.2
     */
    void addEdge(final Edge&amp;lt;V&amp;gt; edge);

    /**
     * 移除边
     *
     * @param edge 边信息
     * @since 0.0.2
     */
    boolean removeEdge(final Edge&amp;lt;V&amp;gt; edge);

    /**
     * 获取边信息
     *
     * @param from 开始节点
     * @param to   结束节点
     * @since 0.0.2
     */
    Edge&amp;lt;V&amp;gt; getEdge(final int from, final int to);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22、边的实现&quot;&gt;2.2、边的实现&lt;/h3&gt;
&lt;p&gt;这是有向图的边的实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @Author 三分恶
 * @Date 2020/11/28
 * @Description 边
 */
public class Edge&amp;lt;V&amp;gt; {

    /**
     * 开始节点
     * @since 0.0.2
     */
    private V from;

    /**
     * 结束节点
     * @since 0.0.2
     */
    private V to;

    /**
     * 权重
     * @since 0.0.2
     */
    private double weight;

    public Edge(V from, V to) {
        this.from = from;
        this.to = to;
    }

    public V getFrom() {
        return from;
    }

    public void setFrom(V from) {
        this.from = from;
    }

    public V getTo() {
        return to;
    }

    public void setTo(V to) {
        this.to = to;
    }

    public double getWeight() {
        return weight;
    }

    public void setWeight(double weight) {
        this.weight = weight;
    }

    @Override
    public String toString() {
        return &quot;Edge{&quot; +
                &quot;from=&quot; + from +
                &quot;, to=&quot; + to +
                &quot;, weight=&quot; + weight +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
        Edge&amp;lt;?&amp;gt; edge = (Edge&amp;lt;?&amp;gt;) o;
        return Double.compare(edge.weight, weight) == 0 &amp;amp;&amp;amp;
                to.equals(edge.to) &amp;amp;&amp;amp;
                from.equals(edge.from);
    }

    @Override
    public int hashCode() {
        return hashCode();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h3 id=&quot;23、有向图节点&quot;&gt;2.3、有向图节点&lt;/h3&gt;
&lt;p&gt;这里我们不再单独做顶点的实现，所以 节点=顶点+边。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @Author 三分恶
 * @Date 2020/11/28
 * @Description
 */
public class GraphNode&amp;lt;V&amp;gt; {

    /**
     * 顶点信息
     * @since 0.0.2
     */
    private V vertex;

    /**
     * 以此顶点为起点的边的集合，是一个列表，列表的每一项是一条边
     *
     * （1）使用集合，避免重复
     */
    private Set&amp;lt;Edge&amp;lt;V&amp;gt;&amp;gt; edgeSet;

    /**
     * 初始化一个节点
     * @param vertex 顶点
     */
    public GraphNode(V vertex) {
        this.vertex = vertex;
        this.edgeSet = new HashSet&amp;lt;Edge&amp;lt;V&amp;gt;&amp;gt;();
    }

    /**
     * 新增一条边
     * @param edge 边
     */
    public void add(final Edge&amp;lt;V&amp;gt; edge) {
        edgeSet.add(edge);
    }

    /**
     * 获取目标边
     * @param to 目标边
     * @return 边
     * @since 0.0.2
     */
    public Edge&amp;lt;V&amp;gt; get(final V to) {
        for(Edge&amp;lt;V&amp;gt; edge : edgeSet) {
            V dest = edge.getTo();

            if(dest.equals(to)) {
                return edge;
            }
        }

        return null;
    }

    /**
     * 获取目标边
     * @param to 目标边
     * @return 边
     * @since 0.0.2
     */
    public Edge&amp;lt;V&amp;gt; remove(final V to) {
        Iterator&amp;lt;Edge&amp;lt;V&amp;gt;&amp;gt; edgeIterable = edgeSet.iterator();

        while (edgeIterable.hasNext()) {
            Edge&amp;lt;V&amp;gt; next = edgeIterable.next();

            if(to.equals(next.getTo())) {
                edgeIterable.remove();
                return next;
            }
        }

        return null;
    }

    public V getVertex() {
        return vertex;
    }

    public Set&amp;lt;Edge&amp;lt;V&amp;gt;&amp;gt; getEdgeSet() {
        return edgeSet;
    }

    @Override
    public String toString() {
        return &quot;GraphNode{&quot; +
                &quot;vertex=&quot; + vertex +
                &quot;, edgeSet=&quot; + edgeSet +
                '}';
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h3 id=&quot;24、有向图具体实现&quot;&gt;2.4、有向图具体实现&lt;/h3&gt;
&lt;p&gt;接下来是有向图的邻接表表示具体实现。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * @Author 三分恶
 * @Date 2020/11/28
 * @Description
 */
public class ListDirectGraph&amp;lt;V&amp;gt; implements IDirectGraph&amp;lt;V&amp;gt; {

    /**
     * 节点链表
     *
     * @since 0.0.2
     */
    private List&amp;lt;GraphNode&amp;lt;V&amp;gt;&amp;gt; nodeList;

    /**
     * 初始化有向图
     *
     * @since 0.0.2
     */
    public ListDirectGraph() {
        this.nodeList = new ArrayList&amp;lt;GraphNode&amp;lt;V&amp;gt;&amp;gt;();
    }


    public void addVertex(V v) {
        GraphNode&amp;lt;V&amp;gt; node = new GraphNode&amp;lt;V&amp;gt;(v);

        // 直接加入到集合中
        this.nodeList.add(node);
    }


    public boolean removeVertex(V v) {
        //1. 移除一个顶点
        //2. 所有和这个顶点关联的边也要被移除
        Iterator&amp;lt;GraphNode&amp;lt;V&amp;gt;&amp;gt; iterator = nodeList.iterator();
        while (iterator.hasNext()) {
            GraphNode&amp;lt;V&amp;gt; graphNode = iterator.next();

            if (v.equals(graphNode.getVertex())) {
                iterator.remove();
            }
        }

        return true;
    }


    public V getVertex(int index) {
        return nodeList.get(index).getVertex();
    }


    public void addEdge(Edge&amp;lt;V&amp;gt; edge) {
        //1. 新增一条边，直接遍历列表。
        // 如果存在这条的起始节点，则将这条边加入。
        // 如果不存在，则直接报错即可。

        for (GraphNode&amp;lt;V&amp;gt; graphNode : nodeList) {
            V from = edge.getFrom();
            V vertex = graphNode.getVertex();

            // 起始节点在开头
            if (from.equals(vertex)) {
                graphNode.getEdgeSet().add(edge);
            }
        }
    }


    public boolean removeEdge(Edge&amp;lt;V&amp;gt; edge) {
        // 直接从列表中对应的节点，移除即可
        GraphNode&amp;lt;V&amp;gt; node = getGraphNode(edge);
        if (null != node) {
            // 移除目标为 to 的边
            node.remove(edge.getTo());
        }

        return true;
    }


    public Edge&amp;lt;V&amp;gt; getEdge(int from, int to) {
        // 获取开始和结束的顶点
        V toVertex = getVertex(from);

        // 获取节点
        GraphNode&amp;lt;V&amp;gt; fromNode = nodeList.get(from);
        // 获取对应结束顶点的边
        return fromNode.get(toVertex);
    }

    /**
     * 获取图节点
     *
     * @param edge 边
     * @return 图节点
     */
    private GraphNode&amp;lt;V&amp;gt; getGraphNode(final Edge&amp;lt;V&amp;gt; edge) {
        for (GraphNode&amp;lt;V&amp;gt; node : nodeList) {
            final V from = edge.getFrom();

            if (node.getVertex().equals(from)) {
                return node;
            }
        }

        return null;
    }

    /**
     * 获取对应的图节点
     *
     * @param vertex 顶点
     * @return 图节点
     * @since 0.0.2
     */
    private GraphNode&amp;lt;V&amp;gt; getGraphNode(final V vertex) {
        for (GraphNode&amp;lt;V&amp;gt; node : nodeList) {
            if (vertex.equals(node.getVertex())) {
                return node;
            }
        }
        return null;
    }


}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和树的遍历类似，图的遍历也是从图中某一顶点出发，按照某种方法对图中所有顶点访问且仅访问一次。然而， 图的遍历要比树的遍历复杂得多。 因为图的任一顶点都可能和其余的顶点相邻接。 所以在访问了某个顶点之后， 可能沿着某条路径搜索之后， 又回到该顶点上。&lt;/p&gt;
&lt;p&gt;根据搜索路径的方向， 通常有两条遍历图的路径：深度优先遍历和广度优先遍历。 它们对无向图和有向图都适用。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;1、深度优先遍历&quot;&gt;1、深度优先遍历&lt;/h2&gt;
&lt;p&gt;深度优先(DepthFirst Search, DFS)遍历类似千树的先序遍历，是树的先序遍历的推广。&lt;/p&gt;
&lt;p&gt;对于一个连通图，深度优先搜索遍历的过程如下。&lt;/p&gt;
&lt;p&gt;初始条件下所有节点为白色，选择一个作为起始顶点，按照如下步骤遍历：&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;a. 选择起始顶点涂成灰色，表示还未访问&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;b. 从该顶点的邻接顶点中选择一个，继续这个过程（即再寻找邻接结点的邻接结点），一直深入下去，直到一个顶点没有邻接结点了，涂黑它，表示访问过了&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;c. 回溯到这个涂黑顶点的上一层顶点，再找这个上一层顶点的其余邻接结点，继续如上操作，如果所有邻接结点往下都访问过了，就把自己涂黑，再回溯到更上一层。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;d. 上一层继续做如上操作，直到所有顶点都访问过。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以下面一个有向图为例来展示这个过程：&lt;/p&gt;

&lt;center&gt;&lt;span&gt;图9：有向图深度优先遍历&lt;/span&gt;&lt;/center&gt;
&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201128214312734.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;p&gt;具体代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public List&amp;lt;V&amp;gt; dfs(V root) {
    List&amp;lt;V&amp;gt; visitedList = Guavas.newArrayList();
    Stack&amp;lt;V&amp;gt; visitingStack = new Stack&amp;lt;&amp;gt;();
    // 顶点首先压入堆栈
    visitingStack.push(root);
    // 获取一个边的节点
    while (!visitingStack.isEmpty()) {
        V visitingVertex = visitingStack.peek();
        GraphNode&amp;lt;V&amp;gt; graphNode = getGraphNode(visitingVertex);
        boolean hasPush = false;
        if(null != graphNode) {
            Set&amp;lt;Edge&amp;lt;V&amp;gt;&amp;gt; edgeSet = graphNode.getEdgeSet();
            for(Edge&amp;lt;V&amp;gt; edge : edgeSet) {
                V to = edge.getTo();
                if(!visitedList.contains(to)
                        &amp;amp;&amp;amp; !visitingStack.contains(to)) {
                    // 寻找到下一个临接点
                    visitingStack.push(to);
                    hasPush = true;
                    break;
                }
            }
        }
        // 循环之后已经结束，没有找到下一个临点，则说明访问结束。
        if(!hasPush) {
            // 获取第一个元素
            visitedList.add(visitingStack.pop());
        }
    }
    return visitedList;
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;2、广度优先遍历&quot;&gt;2、广度优先遍历&lt;/h2&gt;
&lt;p&gt;广度优先(Breadth First Search, BFS)遍历类似于树的按层次遍历的过程。&lt;/p&gt;
&lt;p&gt;广度优先搜索在进一步遍历图中顶点之前，先访问当前顶点的所有邻接结点。&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;a.首先选择一个顶点作为起始结点，并将其染成灰色，其余结点为白色。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;b. 将起始结点放入队列中。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;c. 从队列首部选出一个顶点，并找出所有与之邻接的结点，将找到的邻接结点放入队列尾部，将已访问过结点涂成黑色，没访问过的结点是白色。如果顶点的颜色是灰色，表示已经发现并且放入了队列，如果顶点的颜色是白色，表示还没有发现&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;d. 按照同样的方法处理队列中的下一个结点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;基本就是出队的顶点变成黑色，在队列里的是灰色，还没入队的是白色。&lt;/p&gt;
&lt;p&gt;以下面一个有向图为例来展示这个过程：&lt;/p&gt;

&lt;center&gt;&lt;span&gt;图10：有向图广度优先遍历&lt;/span&gt;&lt;/center&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020112821492594.png?#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来看一下具体代码实现：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public List&amp;lt;V&amp;gt; bfs(final V root) {
    List&amp;lt;V&amp;gt; visitedList = Guavas.newArrayList();
    Queue&amp;lt;V&amp;gt; visitingQueue = new LinkedList&amp;lt;&amp;gt;();
    // 1. 放入根节点
    visitingQueue.offer(root);
    // 2. 开始处理
    V vertex = visitingQueue.poll();
    while (vertex != null) {
        // 2.1 获取对应的图节点
        GraphNode&amp;lt;V&amp;gt; graphNode = getGraphNode(vertex);
        // 2.2 图节点存在
        if(graphNode != null) {
            Set&amp;lt;Edge&amp;lt;V&amp;gt;&amp;gt; edgeSet = graphNode.getEdgeSet();
            //2.3 将不在访问列表中 &amp;amp;&amp;amp; 不再处理队列中的元素加入到队列。
            for(Edge&amp;lt;V&amp;gt; edge : edgeSet) {
                V target = edge.getTo();
                if(!visitedList.contains(target)
                    &amp;amp;&amp;amp; !visitingQueue.contains(target)) {
                    visitingQueue.offer(target);
                }
            }
        }
        //3. 更新节点信息
        // 3.1 放入已经访问的列表
        visitedList.add(vertex);
        // 3.2 当节点设置为最新的元素
        vertex = visitingQueue.poll();
    }
    return visitedList;
}

&lt;/code&gt;
&lt;/pre&gt;

&lt;hr/&gt;&lt;p&gt;上一篇：&lt;a href=&quot;https://blog.csdn.net/sinat_40770656/article/details/108805930&quot;&gt;重学数据结构（六、树和二叉树）&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;本博客为学习笔记，参考资料如下！&lt;br/&gt;水平有限，难免错漏，欢迎指正！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;big&gt;&lt;strong&gt;参考：&lt;/strong&gt;&lt;/big&gt;&lt;/p&gt;
&lt;p&gt;【1】：邓俊辉 编著. 《数据结构与算法》&lt;br/&gt;【2】：王世民 等编著 . 《数据结构与算法分析》&lt;br/&gt;【3】： Michael T. Goodrich 等编著.《Data-Structures-and-Algorithms-in-Java-6th-Edition》&lt;br/&gt;【4】：严蔚敏、吴伟民 编著 . 《数据结构》&lt;br/&gt;【5】：程杰 编著 . 《大话数据结构》&lt;br/&gt;【6】：&lt;a href=&quot;https://segmentfault.com/a/1190000002685782&quot;&gt;图的理解：存储结构与邻接矩阵的Java实现&lt;/a&gt;&lt;br/&gt;【7】：&lt;a href=&quot;https://houbb.github.io/2020/01/23/data-struct-learn-03-direct-graph&quot;&gt;java 实现有向图(Direct Graph)&lt;/a&gt;&lt;br/&gt;【8】：&lt;a href=&quot;https://www.codenong.com/cs106355167/&quot;&gt;数据结构——图简介（java代码实现邻接矩阵）&lt;/a&gt;&lt;br/&gt;【9】：&lt;a href=&quot;https://segmentfault.com/a/1190000002685939&quot;&gt;图的理解：深度优先和广度优先遍历及其 Java 实现&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 28 Nov 2020 13:52:00 +0000</pubDate>
<dc:creator>三分恶</dc:creator>
<og:description>@ 图是一种比线性表和树更为复杂的数据结构。在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；在树形结构中，数据元素之间有着明显的层次关系，并且每一层中的数据元素可能和</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/three-fighter/p/14054307.html</dc:identifier>
</item>
</channel>
</rss>