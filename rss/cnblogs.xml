<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>RabbitMQ (十三) 消息确认机制 - 消费者确认 - 热敷哥</title>
<link>http://www.cnblogs.com/refuge/p/10356750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/refuge/p/10356750.html</guid>
<description>&lt;p&gt;由于生产者和消费者不直接通信,生产者只负责把消息发送到队列,消费者只负责从队列获取消息(不管是push还是pull).&lt;/p&gt;
&lt;p&gt;消息被&quot;消费&quot;后,是需要从队列中删除的.那怎么确认消息被&quot;成功消费&quot;了呢?&lt;/p&gt;
&lt;p&gt;是消费者从队列获取到消息后,broker 就从队列中删除该消息?&lt;/p&gt;
&lt;p&gt;那如果消费者收到消息后,还没来得及&quot;消费&quot;它,或者说还没来得及进行业务逻辑处理时,消费者所在的信道或者连接因某种原因断开了,&lt;/p&gt;
&lt;p&gt;那这条消息岂不是就被无情的抛弃了...&lt;/p&gt;
&lt;p&gt;我们更期望的是,消费者从队列获取到消息后,broker 暂时不删除该条消息,&lt;/p&gt;
&lt;p&gt;等到消费者&quot;成功消费&quot;掉该消息后,再删除它.&lt;/p&gt;
&lt;p&gt;所以需要一个机制来确认生产者发送的消息被消费者&quot;成功消费&quot;.&lt;/p&gt;
&lt;p&gt;RabbitMQ 提供了一种叫做&quot;消费者确认&quot;的机制.&lt;/p&gt;

&lt;p&gt;消费者确认分两种:&lt;strong&gt;自动确认&lt;/strong&gt;和&lt;strong&gt;手动确认&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在自动确认模式中,消息在发送到消费者后即被认为&quot;成功消费&quot;.&lt;/span&gt;&lt;span&gt;这种模式可以降低吞吐量（只要消费者可以跟上）,以降低交付和消费者处理的安全性.&lt;/span&gt;&lt;span&gt;这种模式通常被称为“即发即忘”.&lt;/span&gt;&lt;span&gt;与手动确认模型不同,如果消费者的TCP连接或通道在真正的&quot;成功消费&quot;之前关闭,则服务器发送的消息将丢失.&lt;/span&gt;&lt;span&gt;因此,自动消息确认&lt;/span&gt;&lt;/span&gt;&lt;strong&gt;应被视为不安全,&lt;/strong&gt;&lt;span&gt;并不适用于所有工作负载.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;使用自动确认模式时需要考虑的另一件事是消费者过载.手动确认模式通常与有界信道预取(BasicQos方法)一起使用,该预取限制了信道上未完成（“进行中”）的消息的数量.但是,自动确认没有这种限制.因此,消费者可能会被消息的发送速度所淹没,可能会导致消息积压并耗尽堆或使操作系统终止其进程.某些客户端库将应用TCP反压(停止从套接字读取,直到未处理的交付积压超过某个限制).因此,仅建议能够以稳定的速度有效处理消息的消费者使用自动确认模式.&lt;/p&gt;
&lt;h2&gt;1.自动确认 autoAck : true&lt;/h2&gt;
&lt;p&gt;下面是消费者的部分代码,我们故意每次只推送一条消息,并且让每条消息的处理都超过10秒.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;            channel.BasicQos(0, 1, false);&lt;/span&gt;&lt;span&gt;//将Qos预取值设置为1,这表示&lt;/span&gt;&lt;span&gt;设置broker每次只推送队列里面的一条消息到消费者,只有在确认这条消息&quot;成功消费&quot;后,才会继续推送&lt;/span&gt;
            consumer.Received += (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str =&lt;span&gt; Encoding.Default.GetString(e.Body);&lt;/span&gt;
                Thread.Sleep(10&lt;span&gt;000&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
                Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;consumer1 receive : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str);&lt;/span&gt;
&lt;span&gt;            };
            channel.BasicConsume(queue: QueueName, &lt;span&gt;autoAck: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;true,&lt;/span&gt; consumer: consumer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面是生产者的部分代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;byte&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;)
                {
                    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; msg = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello world &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; i;
                    channel.BasicPublish(&lt;/span&gt;&lt;span&gt;&quot;&quot;&lt;/span&gt;, QueueName, &lt;span&gt;null&lt;/span&gt;&lt;span&gt;, Encoding.Default.GetBytes(msg));
                    Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;send {msg}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
                }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190209005810775-554219177.png&quot; alt=&quot;&quot;/&gt;   &lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190208225006572-2090956003.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从管理后台可以看到,消费者还没打印&quot;receive&quot;那句话,该队列中就已经没有任何消息了.&lt;/p&gt;
&lt;h2&gt;2.手动确认 autoAck : false&lt;/h2&gt;
&lt;p&gt;手动确认又分两种:&lt;strong&gt;肯定确认&lt;/strong&gt;和&lt;strong&gt;否定确认.&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;1)肯定确认 BasicAck&lt;/h4&gt;
&lt;p&gt;消费者部分代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
            channel.BasicQos(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置broker每次只推送队列里面的一条消息到消费者,只有在确认这条消息&quot;成功消费&quot;后,才会继续推送&lt;/span&gt;
            consumer.Received += (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str =&lt;span&gt; Encoding.Default.GetString(e.Body);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;consumer1 receive : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str);
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;30000&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;deliveryTag 传递标签,ulong 类型.它的范围隶属于每个信道.因此必须在收到消息的相同信道上确认.不同的信道将导致“未知的传递标签”协议异常并关闭通道.
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;multiple 确认一条消息还是多条.false 表示只确认 e.DelivertTag 这条消息,true表示确认 小于等于 e.DelivertTag 的所有消息 &lt;/span&gt;
                channel.&lt;span&gt;BasicAck&lt;/span&gt;(deliveryTag: e.DeliveryTag, multiple: &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
                Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;consumer1 Ack : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str);&lt;/span&gt;
&lt;span&gt;            };
            channel.BasicConsume(queue: QueueName, &lt;span&gt;autoAck: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;false,&lt;/span&gt; consumer: consumer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;生产者代码不变.&lt;/p&gt;
&lt;p&gt;当消费者收到一条消息,但是还没有肯定确认时,从管理后台可以清晰的看到,队列中一共有5条消息,其中4条尚未推送,1条已经推送但尚未确认.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190209004632918-1622239646.png&quot; alt=&quot;&quot;/&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190209004703732-803264652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 当消费者确认后(立马又接收了一条),这时候,队列中一共只有4条了,&quot;成功消费&quot;的那条已经被broker从队列中删掉了.剩余3条尚未推送,1条已推送但尚未确认.&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190209004826699-709646072.png&quot; alt=&quot;&quot;/&gt;         &lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190209004902908-1299539149.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h4&gt;2)否定确认  BasicNack , BasicReject &lt;/h4&gt;
&lt;p&gt;否定确认的场景不多,但有时候某个消费者因为某种原因无法立即处理某条消息时,就需要否定确认了.&lt;/p&gt;
&lt;p&gt;否定确认时,需要&lt;span&gt;&lt;span&gt;指定是&lt;/span&gt;丢弃掉这条消息&lt;/span&gt;,还是&lt;span&gt;让这条消息重新排队,过一会再来&lt;/span&gt;,又或者是&lt;span&gt;让这条消息重新排队,并尽快让另一个消费者接收并处理它.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;i.丢弃  requeue: false&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消费者部分代码:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
            channel.BasicQos(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;);
            consumer.Received += (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str =&lt;span&gt; Encoding.Default.GetString(e.Body);
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;10000&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
                channel.&lt;span&gt;BasicNack&lt;/span&gt;(deliveryTag: e.DeliveryTag, multiple: &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;requeue: false&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;consumer1 Nack : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str);
            };
            channel.BasicConsume(queue: QueueName, &lt;span&gt;autoAck: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;false,&lt;/span&gt; consumer: consumer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;ii.重新排队 requeue: true&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消费者部分代码:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
            channel.BasicQos(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置broker每次只从推送队列里面的一条消息到消费者,只有在确认这条消息&quot;成功消费&quot;后,才会继续推送&lt;/span&gt;
            consumer.Received += (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str =&lt;span&gt; Encoding.Default.GetString(e.Body);
                Thread.Sleep(&lt;/span&gt;&lt;span&gt;5000&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
                channel.&lt;span&gt;BasicNack&lt;/span&gt;(deliveryTag: e.DeliveryTag, multiple: &lt;span&gt;false&lt;/span&gt;, &lt;span&gt;requeue: true&lt;/span&gt;&lt;span&gt;);
                Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;consumer1 Nack : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str);
            };
            channel.BasicConsume(queue: QueueName, &lt;span&gt;autoAck: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;false,&lt;/span&gt; consumer: consumer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190209131958100-1628523026.png&quot; alt=&quot;&quot;/&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190209132004393-1252195075.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到,消费者收到的一直是&quot;hello world 0&quot;这条消息,而管理后台一直显示 4,1,5.这是为什么呢?&lt;/p&gt;
&lt;p&gt;首先,我们设置的是每次只推送一条消息给消费者,否定确认中我们选择的是重新排队,所以&quot;hello world 0&quot;这条消息被否定确认后,被broker安排去重新排队了.当消息被重新排队时,如果可能的话,它将被放置在其队列中的原始位置.也就是说&quot;hello world 0&quot;这条消息又被放到了队列头,因为它的原始位置就是队列头.所以结果就变成了消费之一直在消费&quot;hello world 0&quot;,并且一直在否定确认.&lt;/p&gt;
&lt;p&gt;感觉这种方式的代价是不是有点大...消息重新排队,还要回到之前的位置,还要重新发送一次....感觉代价有点小贵啊...而且其他消息貌似永远只有ready...&lt;/p&gt;
&lt;p&gt;但,如果多个消费者共享队列时,该消息将被重新排队到更靠近队列头的位置,并且会被聪明的broker从队列中推送到其他队列.&lt;/p&gt;
&lt;p&gt;测试:&lt;/p&gt;
&lt;p&gt;我们重新创建两个消费者:consumer1 否定确认,3秒一次;consumer2 肯定确认,1秒一次.两个消费共享一个队列(公平分发)&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
            channel.BasicQos(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            consumer.Received &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str =&lt;span&gt; Encoding.Default.GetString(e.Body);&lt;/span&gt;
                Thread.Sleep(&lt;span&gt;3000&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
             &lt;span&gt;   channel.BasicNack(e.DeliveryTag, false, true);&lt;/span&gt;
                Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now} consumer1 Nack : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str);
            };
            channel.BasicConsume(queue: QueueName, autoAck: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, consumer: consumer);
&lt;/pre&gt;&lt;/div&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
            channel.BasicQos(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;1&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            consumer.Received &lt;/span&gt;+= (s, e) =&amp;gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; str =&lt;span&gt; Encoding.Default.GetString(e.Body);&lt;/span&gt;
                Thread.Sleep(&lt;span&gt;1000&lt;/span&gt;&lt;span&gt;);
    &lt;span&gt;            channel.BasicAck(deliveryTag: e.DeliveryTag, multiple: &lt;/span&gt;&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;&lt;span&gt;);&lt;/span&gt;
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{DateTime.Now} consumer2 Ack : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; str);
            };
            channel.BasicConsume(queue: QueueName, autoAck: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;, consumer: consumer);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190209134830304-1192884941.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;一切尽在图中.&lt;/p&gt;
&lt;p&gt; BasicReject 方法和 BasicNack 方法基本一样,唯一的区别是没有 multiple 这个入参.&lt;/p&gt;

&lt;h3 class=&quot;docHeading&quot;&gt;消费者确认模式,预取和吞吐量&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;确认模式和QoS预取值对消费者吞吐量具有显着影响。&lt;/span&gt;&lt;span&gt;通常，增加预取将提高向消费者传递消息的速率。&lt;/span&gt;&lt;span&gt;自动确认模式可以产生最佳的交付率。&lt;/span&gt;&lt;span&gt;但是，在这两种情况下，已传送但尚未处理的消息的数量也将增加，从而增加了消费者的RAM消耗。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;应谨慎使用具有无限预取功能的自动确认模式或手动确认模式。&lt;/span&gt;&lt;span&gt;在没有确认的情况下消耗大量消息的消费者将导致他们所连接的节点上的内存消耗增长。&lt;/span&gt;&lt;span&gt;找到合适的预取值需要不断试验，并且会因工作负载而异。&lt;/span&gt;&lt;/span&gt;100到300范围内的值通常可提供最佳吞吐量，并且不会面临压倒性消费者的重大风险。较高的价值往往会影响收益递减规律。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;预取值1是最保守的。&lt;/span&gt;&lt;span&gt;它将显着降低吞吐量，特别是在消费者连接延迟较高的环境中。&lt;/span&gt;&lt;span&gt;对于许多应用来说，更高的值是合适的和最佳的。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h3 class=&quot;docHeading&quot;&gt;当消费者失败或失去连接时：自动重新排队&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;使用手动确认时，除了我们主动让消息重新排队外,任何未确认的消息都将在关闭发生传递的信道（或连接）时自动重新排队。&lt;/span&gt;&lt;span&gt;这包括客户端的TCP连接丢失，消费者应用程序（进程）故障和通道级协议异常.&lt;/span&gt;&lt;/span&gt;请注意，检测不可用的客户端需要一段时间。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;由于这种行为，消费者必须准备好处理重新发送，否则就要&lt;/span&gt;&lt;span&gt;考虑&lt;/span&gt;&lt;span&gt;到&lt;/span&gt;&lt;/span&gt;&lt;span&gt;幂等性&lt;/span&gt;&lt;span&gt;&lt;span&gt;。BasicDeliverEventArgs &lt;/span&gt;&lt;span&gt;有一个特殊的布尔属性 : Redelivered&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;code&quot;&gt;&lt;span&gt;&lt;span&gt;，如果该消息是&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;code&quot;&gt;&lt;span&gt;&lt;span&gt;第一次交付，它将被设置为&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;code&quot;&gt;&lt;span&gt;&lt;span&gt;false.否则为 true.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;code&quot;&gt;&lt;span class=&quot;code&quot;&gt;&lt;span class=&quot;code&quot;&gt;&lt;span&gt;&lt;span&gt;测试:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;code&quot;&gt;&lt;span class=&quot;code&quot;&gt;&lt;span class=&quot;code&quot;&gt;&lt;span&gt;&lt;span&gt;还是借用上一个测试的代码,只是分别加了一句话:&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
Console.WriteLine($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{str} 是否是重复发送 : &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + e.&lt;span&gt;Redelivered&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1189148/201902/1189148-20190209141403566-1871040570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;这里要特别注意,consumer2 收到 &quot;hello world 0&quot;的时候, Redelivered 的值依然是 true . 因为 Redelivered 属性的维度是消息,不是消费者.&lt;/p&gt;


</description>
<pubDate>Sat, 09 Feb 2019 07:34:00 +0000</pubDate>
<dc:creator>热敷哥</dc:creator>
<og:description>由于生产者和消费者不直接通信,生产者只负责把消息发送到队列,消费者只负责从队列获取消息(不管是push还是pull). 消息被&quot;消费&quot;后,是需要从队列中删除的.那怎么确认消息被&amp;q</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/refuge/p/10356750.html</dc:identifier>
</item>
<item>
<title>《.NET和Java之争》一点随想 - Lemon丶</title>
<link>http://www.cnblogs.com/liuhaoyang/p/10357198.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuhaoyang/p/10357198.html</guid>
<description>&lt;p&gt;最近几天在博客园出现了几篇关于《.NET和Java之争》的文章，事情的起因来源于一篇&lt;a href=&quot;https://mp.weixin.qq.com/s/hfp5y2IlnAp51pFX9qGbhQ&quot;&gt;年后离职跳槽指南&lt;/a&gt;公众号，文章里面提到&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;.NET在程序开发中就属于门槛比较低的一类。个中原因我想大家都懂的，就不在这里赘述了。做.NET不需要你科班出身，或许一点兴趣再加上一点时间，或许一个类似某马的培训，都可以让你开始从事.NET开发了。你可以不懂指针、不懂数据结构、不懂算法、不懂汇编、不懂很多东西，但照样可以做出一个.NET程序来。而这些人往往又是对薪资的要求没那么高的，这样无形中就拉低了.NET程序员的“身价”。.NET的易学易会，很大程度上是由于它的封装性比较好。底层的东西都屏蔽掉了，你只要知道学习一下命名空间，然后寻找相关的API去调用就好了。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后&quot;&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/ReActive-GuangZhou-DotNet-Club.html&quot;&gt;广州.NET俱乐部&lt;/a&gt;&quot;的&lt;a href=&quot;https://www.cnblogs.com/adalovelacer&quot;&gt;叶主席&lt;/a&gt;写了第一篇&lt;a href=&quot;https://www.cnblogs.com/adalovelacer/p/dotnet-vs-java.html&quot;&gt;《.NET和Java之争》&lt;/a&gt;，说实话这篇文章里面没有一点技术性对比，提出的论点也模棱两可，所以有了后面的两篇反驳文章&lt;a href=&quot;https://www.cnblogs.com/fnng/p/10356484.html&quot;&gt;《.NET和Java之争》 读后感&lt;/a&gt;、&lt;a href=&quot;https://www.cnblogs.com/hiroshi-cnblogs/p/10357064.html&quot;&gt;虽然不抱希望但也愿.Net和Java之争暂得平息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;三篇文章各自给出了作者自己的观点，但都没有客观的分析&lt;code&gt;.NET和Java之争&lt;/code&gt; 争的到底是什么。由于笔者本人同时在用.NET，Java，Go，所以这篇文章将从.NET ，Java以及最近流行的Go技术本身和生态进行对比。&lt;/p&gt;
&lt;p&gt;首先，我们来看看三个语言/平台都可以做什么以及各自的优势。&lt;/p&gt;
&lt;h3 id=&quot;net-.net-core&quot;&gt;.NET / .NET Core&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;WPF/Winform/UWP技术进行Windows桌面开发&lt;/li&gt;
&lt;li&gt;ASP.NET/ASP.NET Core/WCF技术进行Web业务层开发&lt;/li&gt;
&lt;li&gt;Unity3D使用C#进行游戏客户端开发&lt;/li&gt;
&lt;li&gt;Xamarin进行跨平台App开发，但面临React Native和Flutter的激烈竞争&lt;/li&gt;
&lt;li&gt;Blazor WebAssembly前端开发&lt;/li&gt;
&lt;li&gt;ML.NET 机器学习应用开发&lt;/li&gt;
&lt;li&gt;... 其他未列举&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;javajvm系语言&quot;&gt;Java/JVM系语言&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Spring boot/Cloud / Dubbo进行Web分布式应用开发&lt;/li&gt;
&lt;li&gt;分布式系统中间件，如RocketMQ、Kafka、ZooKeeper&lt;/li&gt;
&lt;li&gt;分布式存储中间件，如ElasticSearch、HBase、Cassandra&lt;/li&gt;
&lt;li&gt;大数据引擎，Spark、Flink&lt;/li&gt;
&lt;li&gt;Android App开发&lt;/li&gt;
&lt;li&gt;TeaVM WebAssembly前端开发&lt;/li&gt;
&lt;li&gt;机器学习应用和基于大数据引擎的机器学习开发&lt;/li&gt;
&lt;li&gt;... 其他未列举&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;go&quot;&gt;Go&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Beego/Echo Web应用开发&lt;/li&gt;
&lt;li&gt;高性能网络中间件开发，如蚂蚁金服用于替换Istio中Envoy的MOSN&lt;/li&gt;
&lt;li&gt;分布式存储中间件，如InfluxDb、TiDB的Sql层&lt;/li&gt;
&lt;li&gt;容器、编排工具和云原生基础设施中间件，如Docker，Kubernetes、ETCD、Prometheus&lt;/li&gt;
&lt;li&gt;... 其他未列举&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;综上，我们可以看到.NET/.NET Core在桌面开发和游戏客户端开发具有优势，Java系在中间件和大数据方向有无法追赶的优势，go在云原生基础设施生态上有得天独厚的优势。&lt;br/&gt;而在Web应用层，虽然三个平台都可以进行业务开发，但spring boot/cloud/dubbo长期积累的生态组件和同一个平台的中间件加成，使用java在分布式应用开发上稍胜一筹。有人会说&lt;code&gt;Java中间件我们.NET也可以用&lt;/code&gt;，但是大部分java团队开发的中间件优先支持的还是java sdk，.NET /.NET Core的sdk只能等开源爱好者去开发或者提一个不知道要等到什么时候的issue去等中间件开发团队来支持。&lt;/p&gt;
&lt;h3 id=&quot;语言层面&quot;&gt;语言层面&lt;/h3&gt;
&lt;p&gt;毫无疑问，C#在语言特性上走在java、go的前面，linq、精细的内存管理、和native交互、异步支持是C#的优势。如今.NET Core已经开源5年，各大云厂商也在加强对.NET Core的支持，&lt;strong&gt;如何扩大C#本身的优势，进而形成生态优势，是每一个C#使用者都应该思考的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;最后，NCC(&lt;a href=&quot;https://github.com/dotnetcore&quot;&gt;.NET Core Community&lt;/a&gt;)从.NET Core开源之初就致力于.NET Core生态建设，如果你有时间精力，想一起来发展.NET Core社区生态，想一起来玩开源，有任何想法欢迎&lt;a href=&quot;https://github.com/dotnetcore/Home/issues/new&quot;&gt;联系我们&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Sat, 09 Feb 2019 03:31:00 +0000</pubDate>
<dc:creator>Lemon丶</dc:creator>
<og:description>最近几天在博客园出现了几篇关于《.NET和Java之争》的文章，事情的起因来源于一篇 '年后离职跳槽指南' 公众号，文章里面提到 然后' '广州.NET俱乐部' '的 '叶主席' 写了第一篇 '《.N</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liuhaoyang/p/10357198.html</dc:identifier>
</item>
<item>
<title>虽然不抱希望但也愿.Net和Java之争暂得平息 - hiroshi_cnblogs</title>
<link>http://www.cnblogs.com/hiroshi-cnblogs/p/10357064.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hiroshi-cnblogs/p/10357064.html</guid>
<description>&lt;p&gt;我在刚开始学编程的时候就经常来博客园，当时博客园基本是.Net的天下，从那时开始.Net和Java哪个好就一直在打，这些年没怎么看博客园了，回来发现到了今天居然还在争论，让我不由得想来分析一下这个问题，这里只考虑技术层面，而不谈什么大道理。&lt;/p&gt;
&lt;p&gt;第一是大家关心的整体薪资分布，作为工程师或高级工程师，决定薪资的因素很多时候不光决定于你的技术，也决定于公司规模和制度，比如996拿得相对多自然付出的也多，所以单纯看月薪统计数据恐怕意义不大，这通常取决于你的贡献，再者薪资冒尖的一部分人必定不只会一门技术。&lt;/p&gt;
&lt;p&gt;第二点是薪资的增幅，以Java来说，作为一个学生会不会用SpringBoot体系或者说用得好不好可能是五千和一万的差别，但是如果你已经月薪两万开外了，再去学一个PHP或者django之类的框架对你的薪资增幅毫无疑义，且你会发现你学会这些东西需要投入的成本可能不到一周，但是你学第一门可能花了之少好几个月，也就是说在同一个开发范畴之内（比如Web开发）对具体语言或框架在战术层面的投入带来收益的增速是衰减的（二阶导数为负），最终会逼近一个天花板，你不得不另谋出路。&lt;/p&gt;
&lt;p&gt;第三是职业分工，我不懂为什么很多程序员都喜欢标榜自己是“Java程序员、Node程序员、.Net程序员、python程序员“等等，你们都是”Backend Engineer“，五岳能不能并派啊？不会触类旁通的只能说是瘸腿工程师或者图样，我还真不信让一个只写过.Net的人在一周内用flask做个API他做不了，我也不信什么能搞EF的搞不了JPA，能自给写出一套Spring的人会怕.Net换Java么，撑死了抽一天看看动态代理而已。严重依照技术栈招聘的，我只能说要么技术部门现在缺这么个人，要么在某种程度上来说能反应公司整体的管理风格和业务特点，好比卖OA的一般Java或.Net系统比较成型了，而高吞吐量的公司可能要招Node、Golang之流，然而你能说这俩东西Java工程师稍微学一学搞不来么？&lt;/p&gt;
&lt;p&gt;第四是一些通的东西，以B/C模式开发整个技术栈来说，前端/微信之类的平台、移动开发、服务端开发、大数据端开发/BI开发、DevOps、和可能涉及到的机器学习，每一个里面都是一大套体系，又不是一个语言一个框架的事，我不敢说这里面哪一样只懂个.Net或者Java就能搞定你的工作，虽然有些东西是通的，比如这些里面很多都要用Redis，那Java和.Net的SDK有什么本质区别么？&lt;/p&gt;
&lt;p&gt;吐了一堆槽，想说的是很多时候你要面对的问题，并不是Java哪种new字符串的姿势更科学，你非纠结这个的话翻翻面试宝典抄一个行不行？也不是.Net和Java哪个快，你能以一己之力撬动整个公司的决策的话，想必你也不会纠结哪个语言好了。我已经染指过很多门主流语言了，诚实地说，你问我这些语言的for循环怎么写，我肯定告诉你“复制粘贴”。&lt;/p&gt;
&lt;p&gt;学编程，我认为可以多思考这种东西，下面随想随写，单拿编程语言一个范畴举几个例子：&lt;br/&gt;1.拿for循环来说，我想到for循环，就想到迭代器，拿到任何语言，我就会找类似于iteratable的接口，进而想到函数式的foreach匿名函数之流，会留意集合的不可变性和并发问题，哦，记得Flux里也对不可变有要求，等等，这些东西放到任何语言里皆准&lt;br/&gt;2.现在重新看Java设计模式，我会想起Scala的单例对象、lazy关键字、iOS的delegate实现、C#的委托实现，不再会纠结各种什么工厂而是知道把new的逻辑单拿出来拾掇拾掇，自己写个什么IoC，写个什么连接池任务池，知道抽象能自聚合实现链式调用等等，放到任何语言里皆准&lt;br/&gt;3.想异常处理，会考虑异常在架构上的边界和异常管理，Golang的强制返回err是不是比Java的try更安心，有什么能彼此借鉴的，想到监控日志报警一条龙&lt;br/&gt;4.看到JS有事件队列，安卓和iOS有时间循环，就考虑接Web请求的程序是不是也能自给弄个守护线程之类的&lt;br/&gt;5.看到JS的引用计数在前端造成内存泄漏，就思考iOS的自动释放池机制，就去对比JVM的GC，在Hadoop之类的场景为什么会GC时间过长等等，大数据框架为什么要选JVM语言？&lt;br/&gt;6.这个语言的并发包有栅栏工具、换个语言也有，这个语言能把线程当对象管理，换个语言我能不能很好地监控线程，换了协程咋弄，换了bash咋办&lt;br/&gt;7.bash既然那么恶心我能不能换python？这个项目的后端要搞大把JavaBean还要写一堆for处理数据我能不能换pandas？&lt;br/&gt;8.C#的IL是把linq这种函数式用OO实现了一把，拿来对比JS的实现，再考虑python，再反观Java7，最后为何不投奔Scala？&lt;br/&gt;9.要说真麻烦的，还真是各种语言的环境配置和依赖管理了，那就让他们HTTP通信，docker怎么样？能不能考虑JSON之外的通信协议？&lt;/p&gt;
&lt;p&gt;现在在争.Net和Java的人，将来你面对的工作可能是这样的：这个项目的特性是什么，我们选什么语言、DB或组件、云服务组件，这个语言的什么框架好，要什么API、如何组织它们协作，如何结合team现状拆分人员，怎么管元数据、版本、异常监控、要不要强制TDD、是DDD还是从前打到后、怎么运维、负载如何、怎么应对将来变化、机器学习是自己训练还是拿人家的、这部分自己做还是外包、数据处理流程是什么、安全管理怎么做、持续集成用什么、如何控制成本、这些东西怎么复制到下个项目里...你写的每一行代码长得再丑，背后都是满心的纠结&lt;/p&gt;
&lt;p&gt;回到上面说的几点问题&lt;/p&gt;
&lt;p&gt;第一点，对于码农来说，薪资天花板不是语言带来的，而是你能解决问题的复杂度，.Net也好Java也罢，无非就是个工具，除此之外还有很多工具，能砍掉PM需求的脑子和嘴皮子也是个工具，不要把某一个工具看得过于当看的，鄙视链就是个闹剧噱头，居然会有人当真？&lt;/p&gt;
&lt;p&gt;第二点，作为后端工程师为了推迟天花板的到来，应该带着现有的技术跳去其他技术领域，比如Java可以跳大数据会迫使你跟进Python或Scala，比如去做高负载高并发的内容可能迫使你学习Golang、微服务、乃至bash，再走向DevOps，而做大数据也需要Ops，而做前端的不妨从Nginx开始从网络领域渗透到后端，另外像爬虫和数据分析这种东西如果不求太精则是谁都能去玩的，但是这里不建议往移动开发这种相关性低的领域跳。当你在技术上的投入带来的技术成长逐步趋于平缓之后，由于之前的充分综合积累，自己能发挥的价值还是会不断增加的。&lt;/p&gt;
&lt;p&gt;第三点，深度是建立在广度的基础上的，我认为码农在一年后，发展应该先有一定广度，在这个基础上找一个领域深挖，就好比从大学读到博士，专业面虽然逐渐缩小，但也是建立在广度之上的，没有相对全局的视野，战术上的勤奋偶尔也会让你一时走错路，何况你不知道各种聪明的码农在愁烦什么的话，也别谈管人了。相比对于广度的投入来说，对某一个具体框架源码的研究带来的整体收益可能很小，这种事情并不在98%的需求范围内，除非你投入开源，或者进了阿里这种要自己写架构的厂写架构。&lt;/p&gt;
&lt;p&gt;第四点，说到分工范畴，虽然不要求跨领域面太广，而我不敢想象一个.Net的OA开发人员一辈子都搞这个学生都能玩的CRUD夕阳产业，除非他把自己禁锢在这个领域，而不把自己真正当作一个后端工程师来看。而不论转什么都有一些通识，比如模式DDD、TDD、ORM原理、多线程、FP、数据结构性能估算等等，加之DB优化、网络协议、分布式原理等非编程语言内容也是通的，而换一种语言无非换一层皮，廖雪峰的python教程能让你两天看懂，不就是因为你有通识么？一个自称前端工程师的人我也不相信他只会JS不会其他TS等，一个自称数据工程师的人也不至于彻底不沾染机器学习。&lt;/p&gt;
&lt;p&gt;有时候需要站在一个34岁有幸没有被开除还混到开发部经理的人的角度反过来看程序员的技术成长，而不是站在现在的位置歪歪将来如何。&lt;/p&gt;
&lt;p&gt;如果你能忍耐着看到这里，现在可以回答我.Net和Java哪个好么？&lt;/p&gt;
</description>
<pubDate>Fri, 08 Feb 2019 17:53:00 +0000</pubDate>
<dc:creator>hiroshi_cnblogs</dc:creator>
<og:description>我在刚开始学编程的时候就经常来博客园，当时博客园基本是.Net的天下，从那时开始.Net和Java哪个好就一直在打，这些年没怎么看博客园了，回来发现到了今天居然还在争论，让我不由得想来分析一下这个问题</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hiroshi-cnblogs/p/10357064.html</dc:identifier>
</item>
<item>
<title>Linux 桌面玩家指南：17. 在 Ubuntu 中使用 deepin-wine，解决一些依赖 Windows 的痛点问题 - 京山游侠</title>
<link>http://www.cnblogs.com/youxia/p/LinuxDesktop017.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/youxia/p/LinuxDesktop017.html</guid>
<description>&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;strong&gt;特别说明：&lt;/strong&gt;要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用&lt;code&gt;$&lt;/code&gt;标记数学公式的开始和结束。如果某条评论中出现了两个&lt;code&gt;$&lt;/code&gt;，MathJax 会将两个&lt;code&gt;$&lt;/code&gt;之间的内容按照数学公式进行排版，从而导致评论区格式混乱。如果大家的评论中用到了&lt;code&gt;$&lt;/code&gt;，但是又不是为了使用数学公式，就请使用&lt;code&gt;\$&lt;/code&gt;转义一下，谢谢。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想从头阅读该系列吗？下面是传送门：&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;Linux 桌面系统对程序员来说非常友好，我已经很长时间没有使用 Windows 系统了，我的所有工作都是在 Linux 上完成的。但是，这个社会太过于依赖 Windows 了，我不用，不代表着别人也不用，所以我也经常面对一些痛点问题。比如，如何在 Linux 下使用 QQ 或者微信传输文件，或者使用 QQ 截图。&lt;/p&gt;
&lt;p&gt;还有就是关于办公软件的问题。在 Linux 桌面系统上，要么使用 LibreOffice，要么使用 WPS，但是这两款办公软件的功能和可靠性仍然比不过 MS Office。我 LibreOffice Writer 和 LibreOffice Impress 都用得不错，写文档和做 ppt 都能够圆满完成任务，只是要做好它随时崩溃的心理准备，但是做数据表的话，LibreOffice 就比 Excel 差得太多了。不是说 LibreOffice 对 Javascript 和 Python 的支持不好，也不是说 VBA 有多优秀，但是生态环境是那样，别人都是用 VBA，而且别人的 VBA 用的都是 MS Office 的那一套对象模型，你突然来个如此异类的数据表，怎么无缝衔接？我是一名程序员，我都没搞定 LibreOffice Calc，更别谈普通用户了。&lt;/p&gt;
&lt;p&gt;还有迅雷，确实是一款比较好的下载软件。如果只谈下载功能的话，Linux 系统中确实有很多软件可以替代。但是，请注意这个但是，在网络上有很多资源，它往往指定只能使用迅雷下载，它的链接地址使用的是迅雷协议，这就让人比较蛋疼了。&lt;/p&gt;
&lt;p&gt;我以前解决这些问题，使用的是虚拟机 Virtual Box。Linux 系统中的虚拟机软件是比较丰富的，具体介绍可以看我这一篇：&lt;a href=&quot;https://www.cnblogs.com/youxia/p/LinuxDesktop007.html&quot;&gt;Linux 桌面玩家指南：07. Linux 中的 Qemu、KVM、VirtualBox、Xen 虚拟机体验&lt;/a&gt; 。只要你的电脑够强大，可以给虚拟机中的系统分配足够多的 CPU 和内存，运行速度还是非常快的。如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201902/16576-20190208225921896-605924759.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Virtual Box 还可以使用无缝模式，在无缝模式下使用 Office 2010 的效果如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201902/16576-20190208230045245-284985690.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然，使用全屏模式也是可以的，而且效果更好。不过那个截图如果晒出来，就是完全在使用 Windows 了，和 Linux 桌面没有半点关系了。&lt;/p&gt;
&lt;p&gt;还有就是迅雷，虚拟机中也可以使用迅雷，然后通过共享文件夹的功能把文件从虚拟机中转移到主机中。我很长一段时间都是这么干。这里碰到的一个问题是，如果挂机下载的时间比较长的话，虚拟机中的系统有时会失去网络连接，必须重启虚拟机才有效，这个问题也让我很蛋疼。&lt;/p&gt;
&lt;p&gt;虚拟机可以解决一切依赖 Windows 的问题，包括 Flash、淘宝、百度网盘、网银 U 盾、QQ、微信、迅雷，等等。只是在转移文件的时候稍微麻烦一点，运行效率稍微差一点，对主机的硬件要求稍微高一点。而且在我心中，一直认为这是最正统的解决问题的方式，因为从隔离性和功能的完整性来讲，使用虚拟机是最好的。&lt;/p&gt;
&lt;h2 id=&quot;deepin-对-linux-世界的贡献&quot;&gt;Deepin 对 Linux 世界的贡献&lt;/h2&gt;
&lt;p&gt;非常感谢 Deepin 团队，他们为我们带来了非常好的一个 Linux 发行版。Deepin 在国际上也是很知名的。Deepin 的目标是做一个所有用户都能用好的 Linux 桌面系统，不是那种只有我这样的程序员才能玩转的 Linux 桌面系统，所以，他们也花了很大的精力来解决 Windows 依赖的痛点问题。比如，搜狗拼音输入法、网易云音乐等软件都有 Linux 版本，这都离不开 Deepin 团队的努力。&lt;/p&gt;
&lt;p&gt;另外，Deepin 团队还尝试使用 wine 来运行 Windows 中的常用软件，专门开发了 deepin-wine。同时，感谢 wszqkzqk，他为我们提供了能在 Ubuntu 中安装的 deepin-wine，和经过精心测试的 QQ、微信、迅雷等软件。&lt;/p&gt;
&lt;h2 id=&quot;安装-deepin-wine-ubuntu&quot;&gt;安装 deepin-wine-ubuntu&lt;/h2&gt;
&lt;p&gt;在 Github 中搜索 deepin-wine，就可以找到 deepin-wine-ubuntu，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201902/16576-20190208232331025-1867401088.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点进去，就可以看到安装方法，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201902/16576-20190208232526310-1453888725.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先使用如下命令将 deepin-wine-ubuntu 克隆到本地：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;git clone https://github.com/wszqkzqk/deepin-wine-ubuntu.git&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后进入 deepin-wine-ubuntu 的目录，使用如下命令进行安装：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;sudo ./install.sh&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后，下载相应的软件包进行安装就可以了。&lt;/p&gt;
&lt;h2 id=&quot;这些软件的运行效果&quot;&gt;这些软件的运行效果&lt;/h2&gt;
&lt;p&gt;安装完成后，可以在 Activities 中找到它们的图标，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201902/16576-20190208233047307-29258758.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这些软件的运行界面，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201902/16576-20190208233110911-1719055435.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;QQ 还可以截图的哦。其实 Linux 中已经有足够多的截图软件了，但是 QQ 中的截图也可以算是独树一帜，因为博客园中有些大神写随笔时，喜欢发用 QQ 截的图，其标志就是下图中这样的箭头：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/16576/201902/16576-20190208233809639-88661671.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚开始我总在想，这箭头画得真拉风啊，Windows 自带的截图工具好像没有这功能吧。大神就是大神啊，用的工具都好屌。直到我认识了 QQ 中的截图。&lt;/p&gt;
&lt;h2 id=&quot;版权申明&quot;&gt;版权申明&lt;/h2&gt;
&lt;p&gt;该随笔由京山游侠在2019年02月09日发布于博客园，引用请注明出处，转载或出版请联系博主。QQ邮箱：1841079@qq.com&lt;/p&gt;
</description>
<pubDate>Fri, 08 Feb 2019 16:21:00 +0000</pubDate>
<dc:creator>京山游侠</dc:creator>
<og:description>特别说明： 要在我的随笔后写评论的小伙伴们请注意了，我的博客开启了 MathJax 数学公式支持，MathJax 使用 标记数学公式的开始和结束。如果某条评论中出现了两个 ，MathJax 会将两个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/youxia/p/LinuxDesktop017.html</dc:identifier>
</item>
<item>
<title>Scratch不仅适合小朋友，程序员和大学老师都应该广泛使用！！！ - 麦克*堂</title>
<link>http://www.cnblogs.com/michael703/p/10356918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/michael703/p/10356918.html</guid>
<description>
&lt;p&gt;去年接触到了Scratch这个编程工具，它是一种简易图形化编程工具，这个软件的开发团队来自于麻省理工大学称为“终身幼儿园团队”（Lifelong Kindergarten Group）。&lt;/p&gt;
&lt;p&gt;网址https://scratch.mit.edu/&lt;/p&gt;
&lt;p&gt;使用这个工具，当时我是为了教孩子们，在使用了一段时间之后，一些想法不自主的就萌生出来了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Scratch可使大学教学更有互动性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我记得当年读大学的时候，老师都是用C在一个黑色或蓝色背景的编辑框中，敲入或输出一些非常无趣的字符。&lt;/p&gt;
&lt;p&gt;我只想说老师，其实我就想知道游戏是怎么做出来的，怎么就出来一架飞机，它就能移动且发射子弹了。&lt;/p&gt;
&lt;p&gt;那么这个在Scratch工具中很容易实现，可以加入一个Sprite，然后图片切换来实现物体的运动。&lt;/p&gt;
&lt;p&gt;当时老师如果能先用Scratch来实现一个东西，然后分析一下原理，然后再代码来一通，这知识点不就联系起来了？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Scratch对面向对象的理解有帮助&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Scratch绝对是面向对象编程入门的神器。因为代码都是写给每个对象的。&lt;/p&gt;
&lt;p&gt;这样能很好的使你在思考程序实现的时候，只考虑当前对象应该有的行为，而不是老想着在某一个对象里去直接控制其它对象行为。&lt;/p&gt;
&lt;p&gt;在Scratch里对象的行为都是靠“事件”来驱动的，这样你能很好的理解事件的概念。&lt;/p&gt;
&lt;p&gt;在Scratch中对象都是独立的，松耦合的，那么对象直接的协作主要是通过“消息”来控制，这样你也能很好的理解消息的概念和工作方式。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/297575/201902/297575-20190208231908762-2007073918.jpg&quot; alt=&quot;&quot; width=&quot;448&quot; height=&quot;240&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Scratch是个很好理解程序语言的工具&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在scratch中你会经常需要用到&lt;strong&gt;变量&lt;/strong&gt;，&lt;strong&gt;循环&lt;/strong&gt;，&lt;strong&gt;判断&lt;/strong&gt;，和&lt;strong&gt;方法定义&lt;/strong&gt;来实现一些功能。&lt;/p&gt;
&lt;p&gt;扩展模块，其实就是用来定义函数，这样能使你更好的理解函数的使用方法，使用场景和使用函数的好处。&lt;/p&gt;
&lt;p&gt;用来理解&lt;strong&gt;递归&lt;/strong&gt;也比java等代码来得直观。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/297575/201902/297575-20190208232116360-490125208.jpg&quot; alt=&quot;&quot; width=&quot;433&quot; height=&quot;318&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Scratch是个很好的建模工具，使你关注于编程逻辑而非语言本身&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有时候为了解决某个问题，你有个很好的算法。&lt;/p&gt;
&lt;p&gt;但是为了验证这个算法，你需要将其用C，C++或java等其中某一种语言来实现。&lt;/p&gt;
&lt;p&gt;由于你不太熟悉编程语言语法以及它提供的方法，使得你花很多时间来编写程序，有时甚至运行不起来。&lt;/p&gt;
&lt;p&gt;你原本目的是验证算法，然而大部分时间都花在了熟悉编程语言，以及debug上面。是不是很得不偿失？&lt;/p&gt;
&lt;p&gt;Scratch使用模块拖拽，你不再需要关注语言，语法，而更多的是算法，建模。&lt;/p&gt;
&lt;p&gt;如下图的：冒泡排序&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/297575/201902/297575-20190208232237163-2094280738.jpg&quot; alt=&quot;&quot; width=&quot;592&quot; height=&quot;577&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;思考用Scratch将逻辑可视化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其它的编程类工具，要实现解释一个算法或原理，一般都很晦涩，学生很难理解。&lt;/p&gt;
&lt;p&gt;如果能用图形化界面，编程之后，让它动态的显示出来，那就生动得多了。&lt;/p&gt;
&lt;p&gt;还是上面排序的例子，如果将上面的数字，转化成图片，然后图片根据算法动态的一轮一轮交换位置，最后排出想要的结果。&lt;/p&gt;
&lt;p&gt;这个能让学生更直观的掌握排序或其它算法。&lt;/p&gt;
&lt;p&gt;“搜索算法”和一些“贪心算法”，“动态规划”等都出现在了我的脑海中。&lt;/p&gt;

&lt;p&gt;我深深的觉得，Scratch这种形式的可视化编程工具，会让更多的人进入编程行业，编程语言将不再是障碍，也许未来编程就是这样。&lt;/p&gt;
&lt;p&gt;想想可视化的代码和数据库建模工具吧，是不是就是在朝这个方向发展啊。&lt;/p&gt;

&lt;p&gt;最后（思考一下）：“N.Wirth(沃斯)提出，程序=数据结构+算法.数据结构指的是数据与数据之间的逻辑关系.算法指的是解决特定问题的步骤和方法.”&lt;/p&gt;
&lt;p&gt;上面提到了数据结构和算法，并没有提到编程语言，编程语言只是实现程序的一种工具，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以“程序员，程序员，要会数据结构和算法的才能算得上程序员，只会敲代码的那就是码农，不是程序员！”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这让我理解了，为什么很多公司后来不喜欢招那个“xxx鸟” 机构培训出来的学员了~~&lt;/p&gt;

&lt;p&gt;P.S. 2018年的总结忙得忘了写了，人就是这样，过了那个点就不想补了：）&lt;/p&gt;
&lt;p&gt;这篇是最近脑海里的想法，写于2019年农历初四~~ &lt;/p&gt;
&lt;p&gt;再过10多分钟，迎财神咯~~&lt;/p&gt;

&lt;p&gt;补一句 scratch 3.0 加入了 摄像头互动，乐高机器人控制，以及语音互动功能。这也告诉了我们人机交互，增强现实，软硬结合将是趋势~~&lt;/p&gt;
</description>
<pubDate>Fri, 08 Feb 2019 15:52:00 +0000</pubDate>
<dc:creator>麦克*堂</dc:creator>
<og:description>去年接触到了Scratch这个编程工具，它是一种简易图形化编程工具，这个软件的开发团队来自于麻省理工大学称为“终身幼儿园团队”（Lifelong Kindergarten Group）。 网址http</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/michael703/p/10356918.html</dc:identifier>
</item>
<item>
<title>.Net Core跨平台应用研究-HelloArm(串口篇) - 赫山老妖</title>
<link>http://www.cnblogs.com/flyfire-cn/p/10356991.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flyfire-cn/p/10356991.html</guid>
<description>&lt;p&gt;        为了验证采用dotnet core技术开发的物联网设备数据采集接入服务应用是否能在高性价比的linux嵌入式平台运行，针对dotnet core应用程序进行嵌入式linux环境的发布部署运行验证研究。&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;        硬件系统经过对比筛选，选用了友善之臂出品的NanoPC-T3 Plus。该控制板为掌上型嵌入式Linux系统迷你PC，采用64位三星arm CPU，具有完善的硬件接口和驱动支持，大于1G的内存和8G以上的eMMC闪存，具有较高的性能价格比。 &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208233016332-149094259.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;NanoPC-T3 Plus是友善之臂专门针对企业用户而设计，它采用三星八核Cortex -A53架构的S5P6818处理器，动态运行主频400M-1.4GHz。NanoPC-T3 Plus配备了16GB的eMMC、音频接口、视频输入/输出接口等；并且集成了WiFi和蓝牙，增加千兆以太网和电源管理功能，板载陶瓷天线，带串口调试功能。为适应工业客户需要，NanoPC-T3 Plus加装了标配的散热片，以解决芯片发热问题。&lt;/li&gt;
&lt;li&gt;NanoPC-T3 Plus带两路视频输入，支持DVP 摄像头及MIPI-CSI摄像头，并且带四路视频输出，分别为HDMI 1.4A接口、LVDS接口、并行RGB-LCD接口、MIPI-DSI接口。并且支持RTC，板载备份电池接口，引出四个USB接口(其中三个是标准A型接口, 另外一个是2.54mm排母)等。&lt;/li&gt;
&lt;li&gt; NanoPC-T3 Plus)流畅运行Android5.1、Debian、UbuntuCore+Qt等系统，内核驱动源码完全开源，接口丰富。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;硬件资源特性&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;CPU: S5P6818, 运行主频1.4GHz&lt;/li&gt;
&lt;li&gt;电源管理: 采用一颗ARM® Cortex®-M0单片机做电源管理, 支持动态调压, 软件关机和定时开机等功能&lt;/li&gt;
&lt;li&gt;内存: 2GB 32bit DDR3 RAM&lt;/li&gt;
&lt;li&gt;存储: 1 x microSD 卡槽&lt;/li&gt;
&lt;li&gt;网络: Gbit Ethernet(RTL8211E)&lt;/li&gt;
&lt;li&gt;Wireless：802.11 b/g/n&lt;/li&gt;
&lt;li&gt;Bluetooth: 4.0 dual mode&lt;/li&gt;
&lt;li&gt;天线: Wi-Fi和蓝牙共用, 板载陶瓷天线, 同时提供IPX接口&lt;/li&gt;
&lt;li&gt;eMMC: 16GB&lt;/li&gt;
&lt;li&gt;视频输入：DVP Camera/MIPI-CSI(双摄像头口)&lt;/li&gt;
&lt;li&gt;视频输出：HDMI/LVDS/并行RGB-LCD/MIPI-DSI(四个视频输出接口)&lt;/li&gt;
&lt;li&gt;音频：3.5mm耳机座/Via HDMI&lt;/li&gt;
&lt;li&gt;麦克风: 板载麦克风&lt;/li&gt;
&lt;li&gt;USB Host: 4 x USB 2.0 Host , 其中三个是标准A型接口, 另外一个是2.54mm排母&lt;/li&gt;
&lt;li&gt;Micro USB: 1 x USB 2.0 Client&lt;/li&gt;
&lt;li&gt;LCD接口: 45pin, 0.5mm间距FPC贴片座，支持全彩TFT LCD (RGB:8-8-8)&lt;/li&gt;
&lt;li&gt;HDMI: HDMI 1.4a, Type A型口，1080P高清显示&lt;/li&gt;
&lt;li&gt;DVP Camera接口: 24pin, 0.5mm间距，FPC贴片竖座&lt;/li&gt;
&lt;li&gt;GPIO扩展接口: 30 Pin2.54mm排母, 包含4个UART, 1路I2C, 1路SPI, 3路PWM,9个GPIO&lt;/li&gt;
&lt;li&gt;I2S/USB: 2.54mm间距排母&lt;/li&gt;
&lt;li&gt;调试串口: 2.54mm间距排针&lt;/li&gt;
&lt;li&gt;按键: 电源按键, 复位按键, 启动选择按键各一个&lt;/li&gt;
&lt;li&gt;LED: 1 x power LED and 1 x system LED&lt;/li&gt;
&lt;li&gt;CPU温度检测: CPU内部集成温度传感器&lt;/li&gt;
&lt;li&gt;RTC: 支持RTC, 板上有备份电池接口&lt;/li&gt;
&lt;li&gt;散热片螺丝孔：能加螺丝固定的散热片&lt;/li&gt;
&lt;li&gt;供电: DC 5V/3A&lt;/li&gt;
&lt;li&gt;PCB Size:100 x 64mm，八层，沉金工艺&lt;/li&gt;
&lt;li&gt;温度工作范围: -40℃ to 80℃&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;       为避免广告嫌宜，不过多对设备进行说明（好象难以避免呵，如有此方面问题，请管理员协助进行和谐呵）&lt;/p&gt;
&lt;p&gt;       在此给出设备的wiki地址：&lt;a href=&quot;http://wiki.friendlyarm.com/wiki/index.php/NanoPC-T3_Plus/zh&quot;&gt;http://wiki.friendlyarm.com/wiki/index.php/NanoPC-T3_Plus/zh&lt;/a&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2&gt;支持的系统平台&lt;/h2&gt;
&lt;p&gt;       厂家提供的系统映像文件支持以下版本系统&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;lubuntu-desktop-xenial-4.4-armhf（基于ubuntu16.04的LUbuntu桌面版，32位arm系统）&lt;/li&gt;
&lt;li&gt;friendlycore-xenial-4.4-armhf（基于ubuntu16.04的FriendlyCore系统，32位arm系统）&lt;/li&gt;
&lt;li&gt;friendlycore-xenial-4.4-arm64（基于ubuntu16.04的FriendlyCore系统，64位arm系统）&lt;/li&gt;
&lt;li&gt;Android5.1系统&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;       FriendlyCore，是一个没有X-windows环境，基于Ubuntu core构建的系统，使用Qt-Embedded作为图形界面的轻量级系统，兼容Ubuntu系统软件源，非常适合于企业用户用作产品的基础OS。&lt;/p&gt;
&lt;p&gt;       系统除了保留Ubuntu Core的特性以外，还包括以下特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;支持电容和电阻触摸屏&lt;/li&gt;
&lt;li&gt;支持WiFi连接&lt;/li&gt;
&lt;li&gt;支持以太网连接&lt;/li&gt;
&lt;li&gt;支持蓝牙，已预装bluez等相关软件包&lt;/li&gt;
&lt;li&gt;支持音频播放&lt;/li&gt;
&lt;li&gt;支持Qt 5.10.0 EGLES和OpenGL ES1.1/2.0&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;.NET Core支持的Linux版本&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/core/linux-prerequisites?tabs=netcore2x&quot;&gt;https://docs.microsoft.com/zh-cn/dotnet/core/linux-prerequisites?tabs=netcore2x&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Core 2.x 将 Linux 视为一个操作系统。 支持的 Linux 分发都对应有一个 Linux 内部版本（根据芯片体系结构）。&lt;/p&gt;

&lt;p&gt;以下 Linux 发行版本/版本支持 NET Core 2.x：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Red Hat Enterprise Linux 7，6 - 64 位（x86_64 或 amd64）&lt;/li&gt;
&lt;li&gt;CentOS 7 - 64 位（x86_64 或 amd64）&lt;/li&gt;
&lt;li&gt;Oracle Linux 7 - 64 位（x86_64 或 amd64）&lt;/li&gt;
&lt;li&gt;Fedora 28、27 - 64 位（x86_64 或 amd64）&lt;/li&gt;
&lt;li&gt;Debian 9（64 位，arm32）、8.7 或更高版本 - 64 位（x86_64 或 amd64）&lt;/li&gt;
&lt;li&gt;Ubuntu 18.04（64 位，arm32）、16.04、14.04 - 64 位（x86_64 或 amd64）&lt;/li&gt;
&lt;li&gt;Linux Mint 18、17 - 64 位（x86_64 或 amd64）&lt;/li&gt;
&lt;li&gt;openSUSE 42.3 或更高版本 - 64 位（x86_64 或 amd64）&lt;/li&gt;
&lt;li&gt;SUSE Enterprise Linux (SLES) 12 Service Pack 2 或更高版本 - 64 位（x86_64 或 amd64）&lt;/li&gt;
&lt;li&gt;Alpine Linux 3.7 或更高版本 - 64 位（x86_64 或 amd64）&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;系统平台选择&lt;/h2&gt;
&lt;p&gt;根据.NET Core 2.x对Linux系统的支持，选择friendlycore-xenial-4.4-arm64作为系统运行平台。&lt;/p&gt;
&lt;p&gt;下载厂家提供的系统映像文件，对NanoPC-T3/Plus进行系统烧写，方法详见&lt;a href=&quot;http://wiki.friendlyarm.com/wiki/index.php/NanoPC-T3_Plus/zh#.E7.83.A7.E5.86.99.E7.B3.BB.E7.BB.9F.E5.88.B0eMMC&quot;&gt;WIKI&lt;/a&gt;教程.&lt;/p&gt;
&lt;p&gt;烧写主要步骤：&lt;/p&gt;
&lt;p&gt;1、下载厂家提供的映像文件和烧写工具win32diskimager（wiki中提供了下载链接）&lt;/p&gt;
&lt;p&gt;2、准备一张tf卡，格式化为一个分区（FAT32）&lt;/p&gt;
&lt;p&gt;3、运行win32diskimager软件，选择映像文件，选择tf卡对应的分区，点击写入&lt;/p&gt;
&lt;p&gt;4、烧写完成&lt;/p&gt;
&lt;p&gt;5、将tf卡插入卡座，按信boot键给控制板上电（需外接显示器和键盘、鼠标）&lt;/p&gt;
&lt;p&gt;6、根据屏幕提示，将系统安装至eMMC闪存。&lt;/p&gt;


&lt;p&gt;FriendlyCore系统默认支持多种连接方式，可通过外接输入、输出设备（键盘/鼠标、显示器）进行连接，也可以通过串口终端进行连接，也支持通过网络，使用ssh终端方式进行连接。&lt;/p&gt;
&lt;p&gt;FriendlyCore系统默认配置了两个用户帐户&lt;/p&gt;
&lt;p&gt;普通用户：&lt;/p&gt;
&lt;p&gt;   用户名: pi&lt;/p&gt;
&lt;p&gt;   密码: pi&lt;/p&gt;
&lt;p&gt;Root用户：&lt;/p&gt;
&lt;p&gt;   用户名: root&lt;/p&gt;
&lt;p&gt;   密码: fa&lt;/p&gt;
&lt;p&gt;系统开机默认会以 pi 用户自动登录，你可以使用 sudo npi-config 命令取消自动登录。&lt;/p&gt;

&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;h2&gt;物理连接&lt;/h2&gt;
&lt;p&gt;NanoPC具有HDMI、TFT显示接口和USB接口，可以直接连接显示器、键盘/鼠标进行操作。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208233044156-428106315.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;串口连接&lt;/h2&gt;
&lt;p&gt;NanoPC默认支持调试串口做为终端。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208233850874-1025046204.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通过USB转TTL串口的串口模块进行连接。默认通讯参数：115200，N,8,1&lt;/p&gt;
&lt;p&gt;软件可使用任意串口终端工具，如SecureCRT或Windows系统自带超级终端。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208233907379-343741655.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208233918641-1791861125.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;

&lt;h2&gt;网络连接&lt;/h2&gt;
&lt;p&gt;可以通SSH工具进行网络连接，通过网络终端的方式访问。(Win10系统自带)&lt;/p&gt;
&lt;p&gt;FriendlyCore系统网络配置默认为自动获取IP地址。通过网络连接设备，需要确定设备的IP地址。&lt;/p&gt;
&lt;p&gt;初始IP地址可以通在串口终端模式下输入ifconfig命令查看，或通过网络扫描确定。&lt;/p&gt;
&lt;p&gt;确定设备的IP地址后，可以通ssh命令进行终端连接&lt;/p&gt;
&lt;p&gt;本次实验中，我们设备的IP地址为172.16.93.74,通过如下命令进行网络终端接入：&lt;/p&gt;
&lt;p&gt;ssh &lt;a href=&quot;mailto:pi@172.16.93.74&quot;&gt;pi@172.16.93.74&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;根据提示输入密码后，即可成功登入。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208233932827-1142735455.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;由于后期主要需要使用的程序功能为网络通讯和串口通讯，我们主要针对目标嵌入式linux系统下的网络和串口通讯进行验证。&lt;/p&gt;
&lt;p&gt;本次实验中，我们先对串口通讯进行验证。&lt;/p&gt;
&lt;p&gt;编写一个netcore2.x的控制台程序，程序实现系统信息显示，串口资源列举，串口选择，串口打开/关闭，串口接收显示和串口定时发送测试数据功能。&lt;/p&gt;
&lt;h2&gt;验证程序设计&lt;/h2&gt;
&lt;p&gt;采用SerialPort类进行串口测试功能实现（netcore项目需通过Nuget安装SerailPort库）&lt;/p&gt;
&lt;p&gt;实现以下功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;显示系统平台信息&lt;/li&gt;
&lt;li&gt;串口资源列举，&lt;/li&gt;
&lt;li&gt;串口选择，&lt;/li&gt;
&lt;li&gt;串口打开&lt;/li&gt;
&lt;li&gt;串口关闭&lt;/li&gt;
&lt;li&gt;串口接收/数据显示&lt;/li&gt;
&lt;li&gt;串口定时发送测试数据&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;程序较为简单，在此贴出部分功能代码：&lt;/p&gt;
&lt;h3&gt;显示系统平台信息&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208233602844-1289841991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;串口资源列举&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208233609466-1950909570.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;串口测试&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208233618016-645860486.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;编译程序，在window下测试程序通过。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208233720679-1047300568.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;跨平台发布&lt;/h2&gt;
&lt;p&gt;因目标平台为arm64嵌入式linux系统，采用以下方式进行程序发布：&lt;/p&gt;
&lt;p&gt;在命令行窗口，切换到项目文件夹，运行如下命令：&lt;/p&gt;
&lt;p&gt;dotnet publish -r linux-arm64 -c Release&lt;/p&gt;
&lt;p&gt;通过以上命令，得到生成的目标平台的发布包，程序文件及相关.netcore运行时依赖均被发布到项目release\netcoreapp2.2\linux-arm64\publish文件夹中。&lt;/p&gt;

&lt;h2&gt;远程部署&lt;/h2&gt;
&lt;p&gt;采用scp命令，将发布文件复制到目标机器&lt;/p&gt;
&lt;p&gt;在windows（win10）系统中，打开控制台窗口，输入scp命令，命令格式如下：&lt;/p&gt;
&lt;p&gt;scp –r d:\ubuntu\publish\ &lt;a href=&quot;mailto:pi@172.16.93.74/home/pi/&quot;&gt;pi@172.16.93.74:/home/pi/&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;根据提示输入用户密码，完成文件夹的复制。&lt;/p&gt;

&lt;p&gt;在ssh终端窗口,切换到程序文件夹&lt;/p&gt;
&lt;p&gt;cd /home/pi/publish&lt;/p&gt;
&lt;p&gt;设置程序执行权限：&lt;/p&gt;
&lt;p&gt;chmod 777 ./HelloArm           # HelloArm为测试程序文件名&lt;/p&gt;

&lt;p&gt;输入./ HelloArm运行程序&lt;/p&gt;

&lt;h2&gt;Linux环境运行.Net Core程序&lt;/h2&gt;
&lt;p&gt;在普通用户pi中运行程序&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208234045192-2031277477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;程序显示了系统环境信息&lt;/p&gt;
&lt;p&gt;由于程序启动后调用了SerialPort.GetPortNames方法，程序未能按预期执行，出现如下信息：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208234101405-1482512852.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;提示信息表明SerialPort类库仅支持Windows系统平台，不支持跨平台。&lt;/p&gt;
&lt;p&gt;至此，.net core程序跨平台在linux系统运行成功，但串口类库不支持跨平台。&lt;/p&gt;

&lt;p&gt;为解决串口类支持问题，查找资料，发现github上有一个开源SerialPortStream类库支持netcore,能够支持Linux系统。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/jcurl/SerialPortStream&quot;&gt;https://github.com/jcurl/SerialPortStream&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;该类库支持windows系统和Linux系统，但在Linux系统下运行，需要额外编译目标平台支持库并进行相关环境配置。&lt;/p&gt;
&lt;h2&gt;Linux串口类库编译&lt;/h2&gt;
&lt;p&gt;You first need to compile the support library libnserial.so for your platform. To do that, you'll need a compiler (e.g. GCC 4.8 or later) and cmake.&lt;/p&gt;
&lt;p&gt;在目标系统中（FriendlyCore），安装GCC编译器和cmake&lt;/p&gt;

&lt;p&gt;首先确定网络正常连接，能够访问互联网（需要良好的网络环境）。&lt;/p&gt;
&lt;p&gt;执行如下命令：&lt;/p&gt;
&lt;p&gt;sudo apt-get update&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208234140229-455308254.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;安装更新GCC&lt;/p&gt;
&lt;p&gt;sudo apt-get install gcc&lt;/p&gt;

&lt;p&gt;安装cmake&lt;/p&gt;
&lt;p&gt;sudo apt-get install cmake&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208234159936-1654924093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;确保gcc和cmake安装正常。可采用命令查看安装情况&lt;/p&gt;
&lt;p&gt;gcc –version&lt;/p&gt;
&lt;p&gt;cmake –version&lt;/p&gt;
&lt;p&gt;After cloning the repository, execute the following:&lt;/p&gt;
&lt;p&gt;$ git clone https://github.com/jcurl/serialportstream.git&lt;/p&gt;
&lt;p&gt;$ cd serialportstream/dll/serialunix&lt;/p&gt;
&lt;p&gt;$ ./build.sh&lt;/p&gt;
&lt;p&gt;根据上面的命令，完成类库的源码克隆和编译。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：类库linux依赖库仅需在同一目标平台编译一次，其他相同目标平台，复制并配置依赖库到目标系统即可。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;环境变量配置&lt;/h2&gt;
&lt;p&gt;Binaries are built and put in the bin folder from where you ran the build script. You can add a reference to LD_LIBRARY_PATH to the library:&lt;/p&gt;
&lt;p&gt;$ export LD_LIBRARY_PATH=`pwd`/bin/usr/local/lib:$LD_LIBRARY_PATH&lt;/p&gt;

&lt;p&gt;执行上述命令，配置类库目标到环境变量（上述命令为临时环境变量配置，仅当前shell有效）&lt;/p&gt;
&lt;p&gt;配置全局环境变量的方法：&lt;/p&gt;
&lt;p&gt;vi /etc/profile&lt;/p&gt;
&lt;p&gt;在文件的最后一行，增加环境变量LD_LIBRARY_PATH的配置&lt;/p&gt;
&lt;p&gt;保存退出后，执行source /etc/profile 刷新环境变量&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：vi相关操作，请自行百度或必应。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;Linux串口测试&lt;/h2&gt;
&lt;p&gt;将测试验证程序中的SerialPort类更换为SerialPortStream类库（方法、属性基本兼容），进行适当的调整，在windows系统上编译运行，通过。&lt;/p&gt;
&lt;p&gt;重新发布Linux系统运行版本，进行linux系统部署。&lt;/p&gt;

&lt;p&gt;采用普通用户pi登录&lt;/p&gt;
&lt;p&gt;如环境变量未有效配置，串口类无法正常执行，程序执行到串口方法调用处停止。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208234251482-387373602.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p&gt;按Ctrl+C终止程序。&lt;/p&gt;

&lt;p&gt;配置好串口类库所需环境变量，重新运行程序，程序正常运行。&lt;/p&gt;
&lt;p&gt;如下图，程序启动，列举出系统有效串口，如下图所示：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208234301407-1002358513.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于pi用户帐户权限原因，程序只显示了/dev/ttySAC0一个串口，此串口为系统调试终端输出串口。&lt;/p&gt;

&lt;p&gt;切换到系统超级用户&lt;/p&gt;
&lt;p&gt;su root&lt;/p&gt;
&lt;p&gt;根据提示输入密码：fa&lt;/p&gt;

&lt;p&gt;切换到程序目录，执行测试程序 ./publish/HelloArm，出现如下界面：&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1525067/201902/1525067-20190208234327670-1076529578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;center&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在超级用户下，程序列举出了5个串口。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;通过操作命令，打开指定的串口，开启接收事件及定时周期发送数据，连接电脑串口（目前大部分电脑已不再提供串口，本实验通过USB转串口模块进行连接），通过PC端的串口工具软件同Linux迷你PC主机进行通讯，收发通讯正常。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p align=&quot;left&quot;&gt;在root用户下，配置/etc/rc.local文件，将程序添加到系统开机运行&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;vi /etc/rc.local&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;在exit 0之前增加一行&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;/home/pi/publish/HelloArm&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;保存退出，重启系统&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;reboot&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;重启系统后，调试串口终端界面中，可以看到程序运行的输出信息，至此，程序配置完成，开机自动运行成功。&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt; &lt;/p&gt;

&lt;p&gt;       .net core为微软推出的跨平台托管程序框架，具备在非windows系统部署运行的能力，但在实际应用中，不能过于想当然，以为支持跨平台就万事大吉，以为凡是.net程序就可以顺利移植为.net core跨平台程序，在实际应用中，需要小心求证，以避免掉进计划时间过于理想的大坑（本实验耗费的时间，远超出计划时间呵。串口类库问题耗费了不少时间，对Linux系统相关操作的熟悉，也耗费了较多时间）。&lt;/p&gt;
&lt;p&gt;       本文中，验证程序是以指定目标平台，无环境依赖方式进行的发布部署，.net core程序也支持以跨平台方式发布部署，但相关目标平台需安装.net core运行时以及相关依赖，微软官方已有详细的说明文档，本文不再赘述。&lt;/p&gt;
&lt;p&gt;       注：本实验中，使用了两种硬件设备，故截图有所不同，但系统相同，不影响实验效果和结论。&lt;/p&gt;

&lt;p&gt;本文为作者原创，未经许可，请勿转载。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Feb 2019 15:49:00 +0000</pubDate>
<dc:creator>赫山老妖</dc:creator>
<og:description>为了验证采用dotnet core技术开发的物联网设备数据采集接入服务应用是否能在高性价比的linux嵌入式平台运行，针对dotnet core应用程序进行嵌入式linux环境的发布部署运行验证研究。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/flyfire-cn/p/10356991.html</dc:identifier>
</item>
<item>
<title>JVM自动内存管理机制——Java内存区域（上） - 风沙迷了眼</title>
<link>http://www.cnblogs.com/fsmly/p/10356492.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fsmly/p/10356492.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、JVM运行时数据区域概述&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Java相比较于C/C++的一个特点就是，在虚拟机自动内存管理机制的帮助下，我们不需要为每一个操作都写像C/C++一样的delete/free代码，所以也不容易出现内存泄漏和内存溢出的问题。显然，这里的不容易只是相对而言的，如果我们想要降低这种代码隐患的发生，就需要对Java虚拟机怎样使用内存有了解，这样的话就算产生错误，排查起来也会相对容易。下面我们来说一说JVM运行时数据区域&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190208123758382-331193994.png&quot; alt=&quot;&quot; width=&quot;587&quot; height=&quot;262&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;1、程序计数器（PC寄存器）:&lt;/strong&gt; 被看作是当前线程所执行的字节码的行号指示器，字节码解析的时候就通过改变这个计数器的值来选取下一条需要执行的指令（包括分支、循环、跳转、异常处理等等都依赖PC）。在多线程程序中，每条线程都需要拥有一个独立的程序计数器，所以程序计数器是线程私有的。（如果程序正在执行一个Java方法，那么这个计数器记录的就是当前执行的字节码指令的地址；如果执行的是一个Native方法，那么计数器为Undefined），该内存区域是JVM规范中唯一一个没有规定OutOfMemoryError的区域。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2、Java虚拟机栈：&lt;/strong&gt;虚拟机栈描述的是Java方法执行的内存模型，这块区域也是线程私有的，生命周期和线程相同。每个方法在执行的时候会创建栈帧，用来存放局部变量表、操作数栈、动态链接、返回值等信息。（我们常说的在Java中的栈内存就是指这块区域）。在JVM规范中：如果线程请求栈深度大于虚拟机提供的深度，那么抛出StackOutflowError异常；如果无法申请得到足够的内存，会抛出OutofMemoryError异常&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;3、本地方法栈：&lt;/strong&gt;与Java虚拟机栈不同的是，本地方法栈为虚拟机执行Native方法服务，而Java虚拟机栈为虚拟机执行Java方法服务。由于JVM规范并没有对本地方法栈做强制规定，所以如同HotSpot一样，直接将本地方法栈和虚拟机栈合二为一。异常情况和JAVA虚拟机栈相同&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;4、Java堆：&lt;/strong&gt;Java堆是被所有线程所共享的一块内存区域，在虚拟机启动时候创建，这块区域的目的就是存放对象实力，基本上我们所创建的所有的对象实例都要在这里分配内存。我们下面会详细的介绍Java堆&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;5、方法区：&lt;/strong&gt;方法区和Java堆一样，是各个线程共享的内存区域，&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;6、运行时常量池：&lt;/strong&gt;运行时常量池是方法区的一部分，在Class文件中（存在类的版本、字段、方法、接口等）存在常量池的信息，作用就是用于存放编译期间生成的各种字面量和符号引用。受到方法区内存的限制，当无法申请到内存时候会抛出OutOfMemoryError异常&lt;/p&gt;
&lt;p&gt;　　还有一部分就是直接内存，但是直接内存并不是运行时数据区域的一部分，在Java的NIO库中允许Java程序员频繁的使用直接内存，从而提高性能（避免了Java堆和Native堆之间来回复制数据）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、再探Java堆、栈、方法区&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　1、Java堆：Java堆的存在是为了解决数据存储的问题，堆中存放了对象实例。堆也是垃圾收集器管理的主要区域（所以也可以被称为GC堆）。从内存回收的角度来讲，采用分代回收算法的JVM，在堆中可被分为新生代（新生的对象或者年龄不大的对象）和老年代（老年对象），这里面的划分是按照垃圾收集器的次数，来判断对象的年龄。新生代中又被分为Eden区、s0区（from区域）、s1区（to区域），From和To是两块大小相等，可以互换角色的区域。一般来说，新生的对象会被首先分配在Eden区，然经过一次GC之后（如果对象还存活）会到from或者to区。之后类似的每一次回收，都会加1，当对象达到一定年龄后，会进入老年代。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190208144457452-499090490.png&quot; alt=&quot;&quot; width=&quot;494&quot; height=&quot;146&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　2、栈：Java栈是一个线程私有的空间，一般情况下一个栈由3部分组成：局部变量表、操作数栈、帧数据区。&lt;/p&gt;
&lt;p&gt;　　局部变量表：里面存放的是报错函数的参数以及局部变量；&lt;/p&gt;
&lt;p&gt;　　操作数栈：其中保存计算过程中的中间结果，同时作为计算过程中变量的临时存储空间；&lt;/p&gt;
&lt;p&gt;　　帧数据区：除了局部变量表和操作数栈之外，还需要一些数据来支持常量池的解析，帧数据区中保存着访问常量池的指针，方便程序访问常量池。除此之外，当函数返回或者出现异常时，JVM必须有一个异常处理表，方便发送异常的时候找到异常的代码（从而异常处理也是帧数据区的一部分）&lt;/p&gt;
&lt;p&gt;　　3、方法区：方法区是一块所有线程共享的内存区域，他保存了类的信息（类的字段、方法、常量池等等），方法区大小决定了系统可以保存多少个类。&lt;/p&gt;
&lt;p&gt;　　4、一张简略的图描述一下堆、栈、方法区之间的关系&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190208132516505-1427233686.png&quot; alt=&quot;&quot; width=&quot;557&quot; height=&quot;244&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;三、探秘JVM堆中对象分配&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;1、对象的创建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　a）我们从new开始，当虚拟机遇到一条new指令的时候，会首先检查这个指令的参数能否在常量池中找到这个类的符号引用，并且检查这个类的加载是否被加载、解析、初始化过，如果没有就会按照类加载过程进行相应类的加载。&lt;/p&gt;
&lt;p&gt;　　b）在类加载完毕后，然后JVM对新生对象分配内存，对象的分配简单而言就是在将一块确定大小的内存从Java堆中分配出来。&lt;/p&gt;
&lt;p&gt;　　①堆是完整的（这时候所有使用的内存在一边，没有使用的内存在一边，中间放着一个指针作为分界点的指示器）：分配内存就只是把指针向空闲内存那边移动与对象大小一样大的距离（这种方式成为“指针碰撞”）&lt;/p&gt;
&lt;p&gt;　　②堆不是完整的（使用和未用的相互交错）：虚拟机需要维护一个列表，其中记录的是空间内存的状况，在分配的时候从空闲内存中找到一块足够的空间划分给对象实例，然后更新表中的记录信息（这种方式成为“空闲列表”）&lt;/p&gt;
&lt;p&gt;　　c）考虑多线程情况下的对象内存分配&lt;/p&gt;
&lt;p&gt;　　在并发的情况下是线程不安全的，可能出现正在给对象A进行分配，这时候指针位置还没有来得及改变，然后这时候对象B的内存分配又使用了原来的指针记性分配。在《深入理解Java虚拟机》中讲到两种解决方案&lt;/p&gt;
&lt;p&gt;　　①对对象的分配进行同步处理，采用CAS配置失败重试的方式保证更新操作的原子性&lt;/p&gt;
&lt;p&gt;　　②将内存分配的动作按照线程划分在不同的空间中进行。即保证每个线程预先在Java堆中分配一小块空间（本地线程分配缓冲TLAB）。线程需要分配的时候，就先在TLAB上面分配，然后当TLAB使用完毕再进行同步锁定。&lt;/p&gt;
&lt;p&gt;　　d）内存分配完成之后，虚拟机需要将分配的内存初始化为零值，这一步保证了对象实例字段在Java代码中可以不被赋初值就使用，使得程序能够访问到这些字段的数据类型对应的零值。&lt;/p&gt;
&lt;p&gt;　　e）然后虚拟机需要对对象进行必要的设置，比如对象是那个类的实例，类的元数据、对象哈希码、GC年龄等等存放在对象头中。　　&lt;/p&gt;
&lt;p&gt;　　f） 上面执行完毕之后，从虚拟机角度而言已经产生了心得对象。但是程序中对象创建还没有执行&amp;lt;init&amp;gt;方法，所有字段均为零值。所以，执行完new指令，还需要执行&amp;lt;init&amp;gt;方法，按照程序的角度进行初始化，才能使用这个对象。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;2&lt;/strong&gt;&lt;span&gt;&lt;strong&gt;、对象的访问定位&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我们在介绍堆栈的时候就介绍过堆栈和方法区之间的关系，Java程序中对象的引用存放在栈（reference）中，引用的实例存放在Java堆中（使用栈上面的对象引用来操作堆上面的具体对象），但是我们并没有定义怎样通过引用去定位、访问堆中的具体对象位置，下面介绍句柄和直接指针的方式&lt;/p&gt;
&lt;p&gt;　　a）句柄方式&lt;/p&gt;
&lt;p&gt;　　首先在Java堆中分配一块区域作为句柄池，栈中的reference中存放的就是对象的句柄地址信息（句柄中包含的是对象实例数据和类型数据各自的具体地址信息）。使用句柄方式的好处就是reference中存储的是稳定的句柄地址信息，而reference本身不需要修改。下面是句柄方式的简略图&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190208174022582-346906097.png&quot; alt=&quot;&quot; width=&quot;511&quot; height=&quot;286&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　b）直接指针方式：&lt;/p&gt;
&lt;p&gt;　　Java堆中对象的布局中必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象的地址。使用直接指针的方式就是存取速度快，节省了一次指针定位的时间。&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368768/201902/1368768-20190208183023055-1345752181.png&quot; alt=&quot;&quot; width=&quot;499&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 08 Feb 2019 15:32:00 +0000</pubDate>
<dc:creator>风沙迷了眼</dc:creator>
<og:description>一、JVM运行时数据区域概述 Java相比较于C/C++的一个特点就是，在虚拟机自动内存管理机制的帮助下，我们不需要为每一个操作都写像C/C++一样的delete/free代码，所以也不容易出现内存泄</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fsmly/p/10356492.html</dc:identifier>
</item>
<item>
<title>TensorFlow中的通信机制——Rendezvous（一）本地传输 - DeepLearningStack</title>
<link>http://www.cnblogs.com/deep-learning-stacks/p/10354258.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/deep-learning-stacks/p/10354258.html</guid>
<description>&lt;p&gt;[作者：&lt;a href=&quot;https://www.cnblogs.com/deep-learning-stacks&quot; target=&quot;_blank&quot;&gt;DeepLearningStack&lt;/a&gt;，阿里巴巴算法工程师，开源TensorFlow Contributor]&lt;/p&gt;
&lt;p&gt;在TensorFlow源码中我们经常能看到一个奇怪的词——Rendezvous。如果从仔细统计该单词出现的频率和模块，你会发现无论在单机还是分布式，无论在core目录还是contrib目录都存在它的身影，所涉及的模块非常多。Rendezvous是一个法语单词，发音也比较特殊，一般直译为“约会、相会、会和”，而在TensorFlow中，Rendezvous是用来完成消息传输的通信组件。大部分源码读者在起初阅读时通信部分的代码时可能会觉得有点懵圈，为什么不使用Communicator这样简单明了的单词来表明通信过程，反而使用这样一个晦涩的法语词作为抽象呢？其实在了解TensorFlow消息通信的原理后就会发现，使用Rendezvous作为这一过程的抽象是非常贴切的。&lt;/p&gt;
&lt;p&gt;因为Rendezvous所涉及的模块组件较多，为了让读者循序渐进地理解TensorFlow中的通信机制，决定将Rendezvous分成多个系列，由浅入深分开梳理。这样做的目的不但能让读者阅读时对整体层次结构有较好的把握，而且简短的篇幅也便于阅读，所以建议读者按顺序阅读本系列。 本文是TensorFlow通信机制系列的第一篇文章，侧重整体结构和本地传输通信的梳理。&lt;/p&gt;

&lt;p&gt;在TensorFlow中无论是单机还是分布式都涉及到消息传输，并且消息传输总是从发送端Send，接收端Recv。那么这里就存在一个消息的对应问题：在多组消息同时发送接收时，需要对每一对Send和Recv梳理一个对应关系，即Send端发送的消息与Recv端接收的消息不能有错位。如果Recv端本打算接收的消息是A，但由于消息对应错误导致接收到了B，那么整个训练过程就会出现错误。其实解决这个问题也非常简单，因为每一对Send和Recv所处理消息都是同一个，所以只要让某个消息在被Send前加上一个唯一标识符，而Recv在接收消息前也能够按照某种规则拼出一样的唯一标识符，这个对应关系就完美解决了。在TensorFlow中确实定义了这样一种标识符，它就是结构体ParsedKey。&lt;/p&gt;
&lt;h2&gt;ParsedKey结构体&lt;/h2&gt;
&lt;p&gt;在tensorflow/core/framework/rendezvous.h的Rendezvous类内定义了结构体ParsedKey，它内容非常简短却又十分全面，不但包含了消息传输的所有必须的内容，还具备唯一性，在我们直接分析其源代码结构。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Parses the key constructed by CreateKey and parse src/dst device
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; names into structures respectively.&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; ParsedKey {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  StringPiece src_device;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  DeviceNameUtils::ParsedName src;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   uint64 src_incarnation = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;  StringPiece dst_device;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  DeviceNameUtils::ParsedName dst;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  StringPiece edge_name;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  ParsedKey() {}
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   ParsedKey(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; b) { *&lt;span&gt;this&lt;/span&gt; =&lt;span&gt; b; }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;   ParsedKey&amp;amp; &lt;span&gt;operator&lt;/span&gt;=(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp;&lt;span&gt; b);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;   StringPiece FullKey() &lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; buf_; }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;  &lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;   friend &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Rendezvous;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;   friend &lt;span&gt;class&lt;/span&gt;&lt;span&gt; SendOp;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;   friend &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RecvOp;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   &lt;span&gt;string&lt;/span&gt;&lt;span&gt; buf_;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到其结构非常简单，一个完备的ParsedKey要包括六个部分。&lt;/p&gt;
&lt;p&gt;src_device：消息发送源的字符串信息，形如/job:localhost/replica:0/task_id:0/device:GPU:0&lt;/p&gt;
&lt;p&gt;src：和src_device的信息量相同，只不过是结构体的表示方法&lt;/p&gt;
&lt;p&gt;src_incarnation：一般来说这个字段没有什么作用，但是当某个worker重启后，该值会发生变化，用来和之前挂掉的worker做区分，这便于debug&lt;/p&gt;
&lt;p&gt;dst_device：消息发送的接收方字符串信息，格式和src_device相同&lt;/p&gt;
&lt;p&gt;dst：和dst_device的信息量相同，只不过是结构体的表示方法&lt;/p&gt;
&lt;p&gt;edge_name：这个字段是该Key最特殊的地方，它可以灵活指定为任何字符串，实现不同Key的区分。比如它可以是Tensor的名字，也可以是具有某种特殊意义的固定字符串&lt;/p&gt;
&lt;h2&gt;CreateKey过程与ParseKey过程&lt;/h2&gt;
&lt;p&gt;一般情况下，在TensorFlow中应该优先使用CreateKey函数来构造可以解析的Key字符串，然后经过ParseKey过程将该字符串的每个信息解析到ParsedKey结构体中，之所以使用CreateKey函数构造Key字符串是因为这是最安全保险的方式，下面是CreateKey函数构造Key字符串的过程展现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190208202040797-1150435323.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;CreateKey只要接受五个参数即可安全构造字符串形式的Key，这里面特殊之处有两个，a. 参数中frame_and_iter一般直接取自OpKernelContext中的FrameAndIter对象；b. src_incarnation要做一个十六进制的字符串转换。CreateKey函数的输出是以分号（&quot;;&quot;）为分隔符的字符串，该字符串同样包含五个域。CreateKey是一个static函数，代码比较简单，就不在这里列出。随后我们这个字符串传入ParseKey函数即可完成结构体ParsedKey的解析，解析过程如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190208203302181-1488622898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ParseKey对输入字符串的前四个域做了映射，抛弃了第五个域，但是在提供Key字符串时需要提供完整的五个域，否则会检查报错。和CreateKey相同，ParseKey过程也是一个static函数，代码如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; static &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; Status Rendezvous::ParseKey(StringPiece key, ParsedKey* &lt;span&gt;out&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (key.data() == &lt;span&gt;out&lt;/span&gt;-&amp;gt;&lt;span&gt;buf_.data()) {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Caller used our buf_ string directly, so we don't need to copy.  (The
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; SendOp and RecvOp implementations do this, for example).&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     DCHECK_EQ(key.size(), &lt;span&gt;out&lt;/span&gt;-&amp;gt;&lt;span&gt;buf_.size());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;   } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Make a copy that our StringPieces can point at a copy that will persist
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; for the lifetime of the ParsedKey object.&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;out&lt;/span&gt;-&amp;gt;&lt;span&gt;buf_.assign(key.data(), key.size());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;   StringPiece s(&lt;span&gt;out&lt;/span&gt;-&amp;gt;&lt;span&gt;buf_);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;   StringPiece parts[&lt;span&gt;5&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;5&lt;/span&gt;; i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     parts[i] = ConsumeNextPart(&amp;amp;s, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (s.empty() &amp;amp;&amp;amp;          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Consumed the whole string&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;       !parts[&lt;span&gt;4&lt;/span&gt;].empty() &amp;amp;&amp;amp;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Exactly five parts&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;       DeviceNameUtils::ParseFullName(parts[&lt;span&gt;0&lt;/span&gt;], &amp;amp;&lt;span&gt;out&lt;/span&gt;-&amp;gt;src) &amp;amp;&amp;amp;
&lt;span&gt;20&lt;/span&gt;       strings::HexStringToUint64(parts[&lt;span&gt;1&lt;/span&gt;], &amp;amp;&lt;span&gt;out&lt;/span&gt;-&amp;gt;src_incarnation) &amp;amp;&amp;amp;
&lt;span&gt;21&lt;/span&gt;       DeviceNameUtils::ParseFullName(parts[&lt;span&gt;2&lt;/span&gt;], &amp;amp;&lt;span&gt;out&lt;/span&gt;-&amp;gt;dst) &amp;amp;&amp;amp;
&lt;span&gt;22&lt;/span&gt;       !parts[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;].empty()) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;out&lt;/span&gt;-&amp;gt;src_device = StringPiece(parts[&lt;span&gt;0&lt;/span&gt;].data(), parts[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].size());
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;out&lt;/span&gt;-&amp;gt;dst_device = StringPiece(parts[&lt;span&gt;2&lt;/span&gt;].data(), parts[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;].size());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;out&lt;/span&gt;-&amp;gt;edge_name = StringPiece(parts[&lt;span&gt;3&lt;/span&gt;].data(), parts[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;].size());
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Status::OK();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt; errors::InvalidArgument(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Invalid  rendezvous key: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, key);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在了解ParsedKey之后，我们就可以窥探Rendezvous这个类的内部结构和实现了。最基本的Rendezvous类被定义在了tensorflow/core/framework/rendezvous.h文件中，它对外提供了最基本的Send、Recv和RecvAsync接口和实现。总体来说这个类还是比较抽象的，在不同的通信场景下需要提供不同的实现。比如对于本地传输来说，TensorFlow提供了LocalRendezvous和IntraProcessRendezvous实现类，对于使用跨进程通信场景来说，TensorFlow提供了RemouteRendezvous实现系列。不同通信场景的实现细节差别相当大，所以本系列将对这些做逐个梳理，本文只关注本地传输部分。如果对跨进程传输感兴趣，那么请关注该系列的下一篇文章。Rendezvous类中最重要的函数是Send和Recv系列，它们的签名和注释如下代码所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The caller is a tensor producer and it sends a message (a tensor
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; &quot;val&quot; and a bool &quot;is_dead&quot;) under the given &quot;key&quot;.
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; {val, is_dead} is bundled as a message sent and received.
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Typically, is_dead is set by some control flow nodes
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; (e.g., a not-taken branch).  args is passed by Send to the
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Recv function to communicate any information that the Recv
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; function might need.  This is typically only necessary for
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Send/Recv on the same worker.
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Send() never blocks.&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; Status Send(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp; args, &lt;span&gt;const&lt;/span&gt; Tensor&amp;amp; val, &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; is_dead) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;virtual&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; RecvAsync(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp; args, DoneCallback done) = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Synchronous wrapper for RecvAsync.&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; Status Recv(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp; args, Tensor* val, &lt;span&gt;bool&lt;/span&gt;*&lt;span&gt; is_dead, int64 timeout_ms);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; Status Recv(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp; args, Tensor* val, &lt;span&gt;bool&lt;/span&gt;* is_dead);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;TensorFlow中的Recv有两种，一种是同步版本，换一种是异步版本。通常情况下为了计算和通信的overlap，TensorFlow广泛使用了RecvAsync函数。并且在后面一节中我们可以知道，Send过程并不是真的参与数据通信，所有的通信过程均由RecvAsync完成。&lt;/p&gt;
&lt;h2&gt;Rendezvous相关类结构&lt;/h2&gt;
&lt;p&gt;在了解通信过程之前，应该先熟悉下Rendezvous相关的类结构。下面的类图展示了当期TensorFlow系统中所有的Rendezvous相关类图结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190208205157291-2111425534.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有的Rendezvous相关类都以Rendezvous基类为核心，LocalRendezvous和IntraProcessRendezvous是我们本文分析的重点，SimpleRendezvous实现非常简单，读者可以在熟悉前两个实现之后自行分析该类。而BaseRemoteRendezvous类以及相关类是跨进程通信相关的组件，这部分内容将在下一篇文章中分析。&lt;/p&gt;
&lt;h2&gt;Rendezvous基类中的Recv函数&lt;/h2&gt;
&lt;p&gt;因为Recv函数只是RecvAsync函数的同步版本封装，因此在每个实现类继承重新函数时，只需要提供Send函数的实现和RecvAsync函数实现即可，下面的代码是Rendezvous基类中同步版本实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Status Rendezvous::Recv(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp;&lt;span&gt; recv_args,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                         Tensor* val, &lt;span&gt;bool&lt;/span&gt;*&lt;span&gt; is_dead, int64 timeout_ms) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  Status ret;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  Notification n;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;  RecvAsync(key, recv_args,
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             [&amp;amp;ret, &amp;amp;n, val, is_dead](&lt;span&gt;const&lt;/span&gt; Status&amp;amp; s, &lt;span&gt;const&lt;/span&gt; Args&amp;amp;&lt;span&gt; send_args,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                                      &lt;span&gt;const&lt;/span&gt; Args&amp;amp; recv_args, &lt;span&gt;const&lt;/span&gt; Tensor&amp;amp;&lt;span&gt; v,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                                      &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt;&lt;span&gt; dead) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;               ret =&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;               *val =&lt;span&gt; v;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;               *is_dead =&lt;span&gt; dead;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;              n.Notify();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            });
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;   &lt;span&gt;if&lt;/span&gt; (timeout_ms &amp;gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     int64 timeout_us = timeout_ms * &lt;span&gt;1000&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; notified = WaitForNotificationWithTimeout(&amp;amp;&lt;span&gt;n, timeout_us);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;notified) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Status(error::DEADLINE_EXCEEDED,
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Timed out waiting for notification&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;   } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    n.WaitForNotification();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;  }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;   &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ret;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，无论RecvAsync的实现内容是什么，Recv函数都可以将RecvAsync视为黑盒，在其上层封装成为与RecvAsync相同实现的同步函数版本。&lt;/p&gt;
&lt;h2&gt;本地传输过程&lt;/h2&gt;
&lt;p&gt;使用本地传输过程包括LocalRendezous和IntraProcessRendezvous两个实现类，但是后者是前者的封装，因此本文分析的重点在于LocalRendezvous实现类。&lt;/p&gt;
&lt;h3&gt;消息队列的缓存——Table&lt;/h3&gt;
&lt;p&gt;在TensorFlow中，几乎每个Rendezvous实现类都有自己的消息队列缓存，而几乎每种消息队列缓存都是依靠Table实现的。&lt;strong&gt;Rendezvous的发送(Send)和接收(Recv)都将通过Table完成，这完美地阐释了“约会、相会、会和”的释义，这也是为什么TensorFlow使用这样一个法语词来抽象通信过程&lt;/strong&gt;。下图形象化的表示了Table以及Table中的每个Item。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190208212513856-400473741.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在LocalRendezvous实现类中，Send端和Recv端使用的是同一个Rendezvous对象，所以他们共享同一个Table，所以Table属于临界资源，应该加锁形成互斥访问。Item这个结构中其实有很多内容，在上图中只解释两个比较重要的部分。&lt;/p&gt;
&lt;p&gt;Value：这就是参与通信Tensor本体&lt;/p&gt;
&lt;p&gt;Waitor：这是在确认Tensor被接收端完成接收后的处理函数，也就是consumer处理该Tensor的函数过程&lt;/p&gt;
&lt;h3&gt;传输过程分析&lt;/h3&gt;
&lt;p&gt;无论是Send过程还是Recv过程，它们都将借助Table完成Tensor的转发。Send过程作为Tensor的生产者，它负责将待发送的Tensor送入Table中，并将ParsedKey作为该Item的键。而Recv过程作为消费者，它也会根据自己所需拼出相同的ParsedKey，然后从Table中查看是否已经存在该项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190208214124589-375714695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;应该注意的是，&lt;span&gt;Tensor虽然由Send端生产，但是Table中的Item却不一定是由Send端插入&lt;/span&gt;。因为在TensorFlow中，Send和RecvAsync二者的相对顺序是不能保证先后的，经常出现需求比供给在时间片上先到的情况，那么这时就会出现RecvAsync先拼出了ParsedKey然后立即查表的情况。应对这种情况的一种方案是，RecvAsync放弃此次查询，开启另一个线程轮询该表直到Send端产生为止，然后执行consumer的waiter函数，但这是一个非常消耗资源的实现方式。TensorFlow为了保证异步性，使用另一种无需CPU轮询消耗资源的实现方式。&lt;/p&gt;
&lt;p&gt;我们知道，在Send和RecvAsync顺序相对异步的情况下，waitor函数的执行时机只有两种情况，它取决于Send的供给和RecvAsync的需求哪一个先到达。若生产者先到达，那么waiter函数的调用由RecvAsync执行。若消费者的需求先到达，那么waiter函数的调用由Send执行。简而言之，&lt;span&gt;总是迟到的一方执行waiter函数&lt;/span&gt;。那么可以这样设计：和Send端相同，允许RecvAsync将所需的Item插入到Table中，并连同waiter函数一起发送到该表里。如果Send端后到达，那么Send函数将从表中取出该Item，并执行waiter函数，反之，则由RecvAsync函数取出自己所需要的Item，然后执行waiter函数，下面的图展示了这个过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1437153/201902/1437153-20190208220553449-627548990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;Send过程源码&lt;/h3&gt;
&lt;p&gt;了解上述的过程后，我们可以直接看Send函数的源码了。下面是LocalRendezvous的Send函数源码展示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; Status Send(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp; send_args, &lt;span&gt;const&lt;/span&gt; Tensor&amp;amp;&lt;span&gt; val,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;               &lt;span&gt;const&lt;/span&gt; &lt;span&gt;bool&lt;/span&gt; is_dead) &lt;span&gt;override&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     uint64 key_hash =&lt;span&gt; KeyHash(key.FullKey());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     VLOG(&lt;span&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Send &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;this&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; key_hash &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; key.FullKey();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     mu_.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;status_.ok()) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Rendezvous has been aborted.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;       Status s =&lt;span&gt; status_;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;      mu_.unlock();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; s;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     ItemQueue* queue = &amp;amp;&lt;span&gt;table_[key_hash];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (queue-&amp;gt;empty() || queue-&amp;gt;front()-&amp;gt;&lt;span&gt;IsSendValue()) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; There is no waiter for this message. Append the message
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; into the queue. The waiter will pick it up when arrives.
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only send-related fields need to be filled.&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;       Item* item = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Item;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       item-&amp;gt;value =&lt;span&gt; val;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       item-&amp;gt;is_dead =&lt;span&gt; is_dead;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       item-&amp;gt;send_args =&lt;span&gt; send_args;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (item-&amp;gt;&lt;span&gt;send_args.device_context) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         item-&amp;gt;send_args.device_context-&amp;gt;&lt;span&gt;Ref();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;       queue-&amp;gt;&lt;span&gt;push_back(item);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;      mu_.unlock();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Status::OK();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; There is an earliest waiter to consume this message.&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     Item* item = queue-&amp;gt;&lt;span&gt;front();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     queue-&amp;gt;&lt;span&gt;pop_front();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    mu_.unlock();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Notify the waiter by invoking its done closure, outside the
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; lock.&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     DCHECK(!item-&amp;gt;&lt;span&gt;IsSendValue());
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     item-&amp;gt;waiter(Status::OK(), send_args, item-&amp;gt;&lt;span&gt;recv_args, val, is_dead);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Status::OK();
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;RecvAsync过程源码&lt;/h3&gt;
&lt;p&gt;下面是LocalRendezvous的RecvAsync函数源码展示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;   &lt;span&gt;void&lt;/span&gt; RecvAsync(&lt;span&gt;const&lt;/span&gt; ParsedKey&amp;amp; key, &lt;span&gt;const&lt;/span&gt; Args&amp;amp;&lt;span&gt; recv_args,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                  DoneCallback done) &lt;span&gt;override&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     uint64 key_hash =&lt;span&gt; KeyHash(key.FullKey());
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     VLOG(&lt;span&gt;2&lt;/span&gt;) &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Recv &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;this&lt;/span&gt; &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt; key_hash &amp;lt;&amp;lt; &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt; &amp;lt;&amp;lt;&lt;span&gt; key.FullKey();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     mu_.&lt;span&gt;lock&lt;/span&gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;status_.ok()) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Rendezvous has been aborted.&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;       Status s =&lt;span&gt; status_;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;      mu_.unlock();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;       done(s, Args(), recv_args, Tensor(), &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     ItemQueue* queue = &amp;amp;&lt;span&gt;table_[key_hash];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (queue-&amp;gt;empty() || !queue-&amp;gt;front()-&amp;gt;&lt;span&gt;IsSendValue()) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; There is no message to pick up.
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;       &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Only recv-related fields need to be filled.&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;       Item* item = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Item;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;       item-&amp;gt;waiter =&lt;span&gt; std::move(done);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;       item-&amp;gt;recv_args =&lt;span&gt; recv_args;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;       &lt;span&gt;if&lt;/span&gt; (item-&amp;gt;&lt;span&gt;recv_args.device_context) {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         item-&amp;gt;recv_args.device_context-&amp;gt;&lt;span&gt;Ref();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;      }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;       queue-&amp;gt;&lt;span&gt;push_back(item);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;      mu_.unlock();
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;       &lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; A message has already arrived and is queued in the table under
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; this key.  Consumes the message and invokes the done closure.&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     Item* item = queue-&amp;gt;&lt;span&gt;front();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     queue-&amp;gt;&lt;span&gt;pop_front();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    mu_.unlock();
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Invokes the done() by invoking its done closure, outside scope
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; of the table lock.&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     DCHECK(item-&amp;gt;&lt;span&gt;IsSendValue());
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     done(Status::OK(), item-&amp;gt;send_args, recv_args, item-&amp;gt;value, item-&amp;gt;&lt;span&gt;is_dead);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;delete&lt;/span&gt;&lt;span&gt; item;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;   }
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;关于IntraProcessRendezvous的Send和RecvAsync函数&lt;/h2&gt;
&lt;p&gt;其实本质上IntraProcessRendezvous和LocalRendezvous是同一个函数实现，只是前者对后者做了一层封装。我们从源码中看到，LocalRendezvous是IntraProcessRendezvous的成员之一，只是在回调函数中多了一些简单的处理而已，比如它会仔细考量Tensor的生产方和消费方是存在于CPU还是GPU，是否可以通过P2P直接拷贝，还是需要通过Host做中转，关于拷贝过程使用的是下面的函数，其他地方大同小异，因此不再赘述。有兴趣的读者可以到tensorflow/core/common_runtime/目录下参考rendezvous_mgr.h、rendezvous_mgr.cc和copy_tensor.h与copy_tensor.cc这几个文件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Copies &quot;input&quot; to &quot;output&quot; between devices accessible to the
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; local process via some DMA-like method.  &quot;edge_name&quot; is the name
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; of the tensor being copied, for debugging purposes. Depending on
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; the type of devices and memory in use, the copy may be performed
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; synchronously or asynchronously.  'done' will be invoked only
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; after the copy is actually complete.&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ViaDMA(StringPiece edge_name, DeviceContext*&lt;span&gt; send_dev_context,
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                      DeviceContext* recv_dev_context, Device* src, Device*&lt;span&gt; dst,
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                      &lt;span&gt;const&lt;/span&gt;&lt;span&gt; AllocatorAttributes src_alloc_attr,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                      &lt;span&gt;const&lt;/span&gt;&lt;span&gt; AllocatorAttributes dst_alloc_attr,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                      &lt;span&gt;const&lt;/span&gt; Tensor* input, Tensor*&lt;span&gt; output,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                      &lt;span&gt;int&lt;/span&gt; dev_to_dev_stream_index, StatusCallback done);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;本文是TensorFlow通信机制系列的第一篇文章，先通过抛出高并发情况下消息通信两端的对应问题引出TensorFlow中的ParsedKey结构设计的必要性，然后给出了Rendezvous全局类图，最后详细的分析了LocalRendezvous的消息传输实现过程。TensorFlow的通信机制的完美的阐释了Rendezvous一词的含义——无论是Send端还是Recv端都需要在临界资源Table中“约会”，进行消息的传输。随后还着重分析了异步情况下，本属于consumer的waiter函数调用时机设计问题——为了保证waiter函数的执行不被阻塞，从设计上采取Late invoke的方案。IntraProcessRendezous本质是LocalRendezvous的一层封装，它在数据拷贝上面做了更多的工作，借助LocalRendezvous实现了Send和Recv处于不同或相同种类Device情况下，对上层完全透明的拷贝过程。由于篇幅原因，特意将TensorFlow通信机制分为多个系列分析，作为第一篇文章，本篇介绍了Rendezvous的基本框架。在该系列之后的文章中，还会对跨进程的通信进行详细地分析。&lt;/p&gt;
</description>
<pubDate>Fri, 08 Feb 2019 14:31:00 +0000</pubDate>
<dc:creator>DeepLearningStack</dc:creator>
<og:description>背景 [作者：DeepLearningStack，阿里巴巴算法工程师，开源TensorFlow Contributor] 在TensorFlow源码中我们经常能看到一个奇怪的词——Rendezvous</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/deep-learning-stacks/p/10354258.html</dc:identifier>
</item>
<item>
<title>Android Intent实现页面跳转 - carry莫奈</title>
<link>http://www.cnblogs.com/MrChen-/p/10356866.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrChen-/p/10356866.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;什么是Intent&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    Intent可以理解为信使(意图)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    由Intent来协作完成Android各个组件之间的通讯, 也可以说是实现页面与页面之间的跳转&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Intent实现页面之间的跳转&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li&gt;startActivity(intent)        //第一种方式启动&lt;/li&gt;
&lt;li readability=&quot;7&quot;&gt;
&lt;p&gt;startActivityForResult(intent, requestCode); //第二种启动方式&lt;/p&gt;
&lt;p&gt;onActivityResult(int requestCode, int resultCode, Intent data)&lt;/p&gt;
&lt;p&gt;setResult(resultCode, data);&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一种启动方式实现直接跳转,无返回值&lt;/p&gt;
&lt;p&gt;第二种启动方式A页面-&amp;gt;B页面, B页面也能回传到A页面数据&lt;/p&gt;
&lt;p&gt;onActivityResult(int requestCode, int resultCode, Intent data)&lt;/p&gt;
&lt;p&gt;这个是 用来A页面接收B页面回传的数据用的&lt;/p&gt;
&lt;p&gt;setResult(resultCode, data) 这个是用来B页面回传给A页面数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221433369-787598379.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221433610-1865199953.png&quot; alt=&quot;&quot;/&gt;首先创建一个项目&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;新建两个Activity&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221433976-1410214243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;然后再layout 里面新建两个页面布局 layout右键&lt;span&gt;à&lt;/span&gt;new&lt;span&gt;à&lt;/span&gt;Android XML File&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221434429-1738423906.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随后,进行绑定,例如:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221434904-1326781442.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后,配置清单文件AndroidManifest.xml&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221435370-950926494.png&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208221435574-671920061.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后,在activity_first 插入两个button 一个textview 分别用来第一个和第二个跳转方式, 以及数据回传,代码如下:&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;LinearLayout &lt;/span&gt;&lt;span&gt;xmlns:android&lt;/span&gt;&lt;span&gt;=&quot;http://schemas.android.com/apk/res/android&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    android:orientation&lt;/span&gt;&lt;span&gt;=&quot;vertical&quot;&lt;/span&gt; &lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/bt_first&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        android:text&lt;/span&gt;&lt;span&gt;=&quot;第一种启动方式&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Button
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/bt_Second&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        android:text&lt;/span&gt;&lt;span&gt;=&quot;第二种启动方式&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;TextView
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;android:id&lt;/span&gt;&lt;span&gt;=&quot;@+id/textview&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        android:layout_width&lt;/span&gt;&lt;span&gt;=&quot;match_parent&quot;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        android:layout_height&lt;/span&gt;&lt;span&gt;=&quot;wrap_content&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        android:text&lt;/span&gt;&lt;span&gt;=&quot;把第二个页面回传的数据显示&quot;&lt;/span&gt; &lt;span&gt;/&amp;gt;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;LinearLayout&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;刚才提到了,实现跳转需要用到Intent意图,代码很简单 清晰明了 我直接贴代码了&lt;/p&gt;
&lt;p&gt;首先 FirstActivity&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.intentdemo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.app.Activity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Intent;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View.OnClickListener;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Button;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.TextView;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; FirstActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Activity {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    Button bt_first, bt_second;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    TextView textView;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        setContentView(R.layout.activity_first);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        initView();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initView() {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 关联控件&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         bt_first =&lt;span&gt; (Button) findViewById(R.id.bt_first);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         bt_second =&lt;span&gt; (Button) findViewById(R.id.bt_Second);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         textView =&lt;span&gt; (TextView) findViewById(R.id.textview);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         bt_first.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnClickListener() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View arg0) {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第一种跳转,无数据返回跳转&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;                 Intent intent = &lt;span&gt;new&lt;/span&gt; Intent(FirstActivity.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                         SecondActivity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 intent.putExtra(&quot;content&quot;, &quot;第一种跳转方式&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                startActivity(intent);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         bt_second.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnClickListener() {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View arg0) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 第二种方式,有数据返回跳转&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;                 Intent intent = &lt;span&gt;new&lt;/span&gt; Intent(FirstActivity.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                         SecondActivity.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 intent.putExtra(&quot;content&quot;, &quot;第二种跳转方式&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                 * 第一个参数是intent对象 第二个参数的请求的一个标识
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                  &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;                 startActivityForResult(intent, 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; &lt;span&gt;     * 通过startActivityForresult跳转,接收返回数据的方法 requestCode:请求的标识
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;     * resultCode:第二个页面返回的标识 data:第二个页面回传的数据
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;      &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt; 
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; onActivityResult(&lt;span&gt;int&lt;/span&gt; requestCode, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; resultCode, Intent data) {
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onActivityResult(requestCode, resultCode, data);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (requestCode == 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (resultCode == 1&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;                 String text = data.getStringExtra(&quot;content&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;                textView.setText(text);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;SecondActivity代码如下:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.example.intentdemo;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.app.Activity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.content.Intent;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.os.Bundle;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.view.View.OnClickListener;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.Button;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; android.widget.TextView;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SecondActivity &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Activity {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    TextView textView;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    Button button;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onCreate(Bundle savedInstanceState) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.onCreate(savedInstanceState);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        setContentView(R.layout.activity_second);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取第一个页面的意图&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         Intent intent =&lt;span&gt; getIntent();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         
&lt;span&gt;21&lt;/span&gt;         button =&lt;span&gt; (Button) findViewById(R.id.button);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         textView =&lt;span&gt; (TextView) findViewById(R.id.textview);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接收第一个页面传送的数据&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;         textView.setText(intent.getStringExtra(&quot;content&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         button.setOnClickListener(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; OnClickListener() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; onClick(View arg0) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 setResult(1, &lt;span&gt;new&lt;/span&gt; Intent().putExtra(&quot;content&quot;, &quot;从第二个页面返回&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;结束当前页面&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                finish(); 
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; }&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208223753604-470559341.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208223801562-433943799.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/756009/201902/756009-20190208223809161-132566406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;这样就简单的实现了,&lt;/p&gt;
&lt;p&gt;如果有不懂的可以在下面发,我看到会帮你解决,Android其他问题也可以&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/16HEQ1pVnpB995i3-lAG7qw&quot; target=&quot;_blank&quot;&gt;下面贴上Demo:https://pan.baidu.com/s/16HEQ1pVnpB995i3-lAG7qw&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Feb 2019 14:15:00 +0000</pubDate>
<dc:creator>carry莫奈</dc:creator>
<og:description>什么是Intent Intent可以理解为信使(意图) 由Intent来协作完成Android各个组件之间的通讯, 也可以说是实现页面与页面之间的跳转 Intent实现页面之间的跳转 startAct</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrChen-/p/10356866.html</dc:identifier>
</item>
<item>
<title>SpringMVC源码阅读：异常解析器 - Rest探路者</title>
<link>http://www.cnblogs.com/Java-Starter/p/10356055.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Java-Starter/p/10356055.html</guid>
<description>&lt;h2&gt;1.前言&lt;/h2&gt;
&lt;p&gt;SpringMVC是目前J2EE平台的主流Web框架，不熟悉的园友可以看&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/Java-Starter/p/10304896.html&quot;&gt;&lt;span&gt;SpringMVC源码阅读入门&lt;/span&gt;&lt;/a&gt;&lt;span class=&quot;postTitle2&quot;&gt;,它交代了SpringMVC的基础知识和源码阅读的技巧&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;本文将通过源码(基于Spring4.3.7)分析，弄清楚SpringMVC如何完成异常解析、捕捉异常，并自定义异常和异常解析器&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;2.源码分析&lt;/h2&gt;
&lt;p&gt;进入DispatcherServlet的processDispatchResult方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208170026293-944358959.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1024行判断异常是否是ModelAndViewDefiningException类型，如果是，直接返回ModelAndView&lt;/p&gt;
&lt;p&gt;不是ModelAndViewDefiningException类型，则获取HandlerMethod，调用processHandlerExeception方法&lt;/p&gt;
&lt;p&gt;点进去1030行的processHandlerException方法，该方法根据HandlerExecutionResolvers来解析异常并选择ModelAndView&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208171835812-95739692.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1217行遍历HandlerExecutionResolvers，我们讲过，在&amp;lt;mvc:annotation-driven/&amp;gt;帮我们注册了默认的异常解析器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208172038102-1832208929.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;请看AnnotationDrivenBeanDefinitionParser(解析annotation-driven的类)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208172128532-175487705.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1218行调用HandlerExceptionResolver的resolveException方法，该方法被子类AbstractHandlerExceptionResolver实现&lt;/p&gt;
&lt;p&gt;1225行给request设置异常信息&lt;/p&gt;
&lt;p&gt;现在进入HandlerExceptionResolver接口resolveException方法的实现处——AbstractHandlerExceptionResolver的resolveException方法&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208173205501-573075239.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;131行判断该异常解析器是否可以被应用到Handler&lt;/p&gt;
&lt;p&gt;135行为异常情况准备response，即给response添加头部&lt;/p&gt;
&lt;p&gt;136行调用抽象方法doResolveException，由子类实现&lt;/p&gt;
&lt;p&gt;进入AbstractHandlerMethodExceptionResolver的&lt;span&gt;doResolveException方法&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208174209221-254562967.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;59行调用抽象方法，被子类ExceptionHandlerExceptionResolver实现&lt;/p&gt;
&lt;p&gt;打开ExceptionHandlerExceptionResolver的doResolveHandlerMethodException方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208180528183-359441487.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;362行获取有异常的Controller方法&lt;/p&gt;
&lt;p&gt;367~368行为ServletInvocableHandlerMethod设置HandlerMethodArgumentResolverComposite和HandlerMethodReturnValueComposite，用来解析参数和处理返回值&lt;/p&gt;
&lt;p&gt;380行调用invokeAndHandle方法处理返回值，暴露cause&lt;/p&gt;
&lt;p&gt;384行无cause&lt;/p&gt;
&lt;h2&gt;3.实例&lt;/h2&gt;
&lt;h3&gt;3.1 使用@ResponseStatus自定义异常UnauthorizedException&lt;/h3&gt;
&lt;p&gt;@ResponseStatus会被ResponseStatusExceptionResolver解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@ResponseStatus(code=HttpStatus.UNAUTHORIZED,reason=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;用户未授权&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; UnauthorizedException extends RuntimeException {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
    @RequestMapping(&quot;/unauth&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Map unauth() {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnauthorizedException();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器输入http://localhost:8080/springmvcdemo/error/unauth&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208211146717-1078606498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.2 无注解情况&lt;/h3&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
    @RequestMapping(&quot;/noSuchMethod&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map noHandleMethod() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; NoSuchMethodException {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchMethodException();
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没有@ExceptionHandler和@ResponseStatus注解则会被DefaultHandlerExceptionResolver解析&lt;/p&gt;
&lt;p&gt;浏览器输入http://localhost:8080/springmvcdemo/error/noSuchMethod&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208212031026-45807059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.3 @ExceptionHandler处理异常&lt;/h3&gt;
&lt;p&gt;测试方法&lt;/p&gt;
&lt;p&gt;@ExceptionHandler会被ExceptionHandlerExceptionResolver解析&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    @RequestMapping(&quot;/exception&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map exception() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ClassNotFoundException {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ClassNotFoundException(&quot;class not found&quot;&lt;span&gt;);
    }

    @RequestMapping(&lt;/span&gt;&quot;/nullpointer&quot;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Map nullpointer() {
        Map resultMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
        String str &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        str.length();
        resultMap.put(&lt;/span&gt;&quot;strNullError&quot;&lt;span&gt;,str);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultMap;
    }

    @ExceptionHandler(RuntimeException.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Map error(RuntimeException error, HttpServletRequest request) {
        Map resultMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
        resultMap.put(&lt;/span&gt;&quot;param&quot;, &quot;Runtime error&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultMap;
    }

    @ExceptionHandler()
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Map error(Exception error, HttpServletRequest request, HttpServletResponse response) {
        Map resultMap &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HashMap();
        resultMap.put(&lt;/span&gt;&quot;param&quot;, &quot;Exception error&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; resultMap;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;浏览器输入http://localhost:8080/springmvcdemo/error/classNotFound&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208213744608-773765210.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;浏览器输入http://localhost:8080/springmvcdemo/error/nullpointer&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208213611837-440482564.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据异常类继承关系，ClassNotFoundException离Exception更近，所以被&lt;span&gt;@ExceptionHandler()&lt;/span&gt;的error方法解析，注解无参相当于Exception.class。&lt;/p&gt;
&lt;p&gt;同理，NullPointerException方法离NullPointerException“最近”，把&lt;span&gt;@ExceptionHandler(NullPointerException.class)的error方法注释掉，浏览器输入http://localhost:8080/springmvcdemo/error/nullpointer，会发现&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;浏览器返回RuntimeException，印证了我们的说法&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;3.4 定义全局异常处理&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * @Author: 谷天乐
 * @Date: 2019/1/21 10:48
 * @Description: ExceptionHandlerMethodResolver内部找不到Controller的@ExceptionHandler注解的话，
 * 会找@ControllerAdvice中的@ExceptionHandler注解方法
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@ControllerAdvice
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExceptionControllerAdvice {

    @ExceptionHandler(Throwable.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Map&amp;lt;String, Object&amp;gt;&lt;span&gt; ajaxError(Throwable error, HttpServletRequest request, HttpServletResponse response) {
        Map&lt;/span&gt;&amp;lt;String, Object&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Object&amp;gt;&lt;span&gt;();
        map.put(&lt;/span&gt;&quot;error&quot;&lt;span&gt;, error.getMessage());
        map.put(&lt;/span&gt;&quot;result&quot;, &quot;error&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;浏览器输入http://localhost:8080/springmvcdemo/error/unauth&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1201453/201902/1201453-20190208214947884-667464365.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;优先级关系：@ExceptionHandler&amp;gt;@ControllerAdvice中的@ExceptionHandler&amp;gt;@ResponseStatus&lt;/p&gt;
&lt;p&gt;要把TestErrorController中@ExceptionHandler的方法注释掉才会有效果&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;4.总结&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;HandlerExceptionResolver作为异常解析器的接口，核心方法是resolveException&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;AbstractHandlerExceptionResolver实现HandlerException，resolveException方法内部调用抽象方法doResolveException，该方法被子类实现；shouldApplyTo方法检查该异常解析器是否可以被应用到Handler&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;AbstractHandlerMethodExceptionResolver的doResolveException内部调用抽象方法doResolveHandlerMethodException，由子类实现，返回ModelAndView，可以在视图模型里自定义错误页面；&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;shouldApplyTo&lt;/span&gt;&lt;/span&gt;调用父类方法&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;ExceptionHandlerExceptionResovler的doResolveHandlerMethodException处理异常，返回ModelAndView&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;DefaultHandlerExceptionResolver的doResolveException处理默认异常&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;ResponseStatusExceptionResolver的doResolveException方法处理@ResponseStatus修饰的异常&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;DispatcherServler的processHandlerException方法根据注册的HandlerExceptionResolvers选择一个ModelAndView&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;DispatcherServlet的doDispatch方法调用processDispatchResult，该方法处理Handler的选择和调用的结果，processDispatchResult方法调用&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span class=&quot;postTitle2&quot;&gt;processHandlerException&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;5.参考&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/4.3.7.RELEASE/spring-framework-reference/htmlsingle/#beans-beans-conversion&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://docs.spring.io/spring/docs/4.3.7.RELEASE/spring-framework-reference/htmlsingle/#beans-beans-conversion&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://docs.spring.io/spring/docs/current/javadoc-api/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://docs.spring.io/spring/docs/current/javadoc-api/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://github.com/spring-projects/spring-framework&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://github.com/spring-projects/spring-framework&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;文中难免有不足，欢迎指正&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 08 Feb 2019 14:07:00 +0000</pubDate>
<dc:creator>Rest探路者</dc:creator>
<og:description>1.前言 SpringMVC是目前J2EE平台的主流Web框架，不熟悉的园友可以看SpringMVC源码阅读入门,它交代了SpringMVC的基础知识和源码阅读的技巧 本文将通过源码(基于Spring</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Java-Starter/p/10356055.html</dc:identifier>
</item>
</channel>
</rss>