<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>gitbook 入门教程之快速体验 - 雪之梦技术驿站</title>
<link>http://www.cnblogs.com/snowdreams1006/p/10640297.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snowdreams1006/p/10640297.html</guid>
<description>&lt;p&gt;本文主要介绍三种使用 &lt;code&gt;gitbook&lt;/code&gt; 的方式,分别是 &lt;code&gt;gitbook&lt;/code&gt; 命令行工具,&lt;code&gt;Gitbook Editor&lt;/code&gt; 官方编辑器和 &lt;code&gt;gitbook.com&lt;/code&gt; 官网.&lt;/p&gt;
&lt;p&gt;总体来说,三种途径适合各自不同的人群,找到适合自己的方式就好,基本操作流程都是一样的.&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命令行工具更适合具备编程经验开发者,具有简单高效易整合等特点.&lt;/li&gt;
&lt;li&gt;编辑器更适合无任何编程经验的文学创作者,不熟悉 &lt;code&gt;markdown&lt;/code&gt; 语法,不熟悉 &lt;code&gt;git&lt;/code&gt; 工作流,这种情况下也推荐使用图形化操作的编辑器.&lt;/li&gt;
&lt;li&gt;官网适合想要快速体验 &lt;code&gt;gitbook&lt;/code&gt; 效果的萌新,只有觉得物超所值才能有动力搭建 &lt;code&gt;gitbook&lt;/code&gt; 开发环境,不是吗?&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;当然,如果你想访问官网的话,你可能需要学会科学上网,网址见文章结尾.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;gitbook-命令行&quot;&gt;&lt;code&gt;gitbook&lt;/code&gt; 命令行&lt;/h2&gt;
&lt;p&gt;首先需要创建存放书籍的目录,然后对该目录进行初始化,最后启动本地服务即可体验效果.&lt;/p&gt;
&lt;h3 id=&quot;初始化项目&quot;&gt;初始化项目&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;语法格式: &lt;code&gt;gitbook init&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果是空目录会自动创建 &lt;code&gt;README.md&lt;/code&gt; 和 &lt;code&gt;SUMMARY.md&lt;/code&gt; 两个文件,当然也可以手动创建再初始化.&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 创建 `gitbook` 演示项目
$ mkdir gitbook-demo

# 初始化项目
$ gitbook init
warn: no summary file in this book 
info: create README.md 
info: create SUMMARY.md 
info: initialization is finished 

# 当前目录结构
$ tree 
.
├── README.md
└── SUMMARY.md

0 directories, 2 files
$ &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;gitbook init&lt;/code&gt; 命令可能会自动生成 &lt;code&gt;README.md&lt;/code&gt; 和 &lt;code&gt;SUMMARY.md&lt;/code&gt; 两个文件,如已存在则更新.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;运行项目&quot;&gt;运行项目&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;语法格式: &lt;code&gt;gitbook serve&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将初始化后的项目启动成为一个本地服务,我们可以直接在浏览器访问项目,预览书籍效果.&lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 启动本地服务器
$ gitbook serve
Live reload server started on port: 35729
Press CTRL+C to quit ...

info: 7 plugins are installed 
info: loading plugin &quot;livereload&quot;... OK 
info: loading plugin &quot;highlight&quot;... OK 
info: loading plugin &quot;search&quot;... OK 
info: loading plugin &quot;lunr&quot;... OK 
info: loading plugin &quot;sharing&quot;... OK 
info: loading plugin &quot;fontsettings&quot;... OK 
info: loading plugin &quot;theme-default&quot;... OK 
info: found 1 pages 
info: found 0 asset files 
info: &amp;gt;&amp;gt; generation finished with success in 1.2s ! &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-beac5b37af49f99f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-serve-preview.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果要停止服务器,只需同时按住 &lt;code&gt;CTRL+C&lt;/code&gt; 即可,现在再看一下 &lt;code&gt;gitbook-demo&lt;/code&gt; 目录结构.&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ tree
.
├── README.md
├── SUMMARY.md
└── _book
    ├── gitbook
    │   ├── fonts
    │   │   └── fontawesome
    │   │       ├── FontAwesome.otf
    │   │       ├── fontawesome-webfont.eot
    │   │       ├── fontawesome-webfont.svg
    │   │       ├── fontawesome-webfont.ttf
    │   │       ├── fontawesome-webfont.woff
    │   │       └── fontawesome-webfont.woff2
    │   ├── gitbook-plugin-fontsettings
    │   │   ├── fontsettings.js
    │   │   └── website.css
    │   ├── gitbook-plugin-highlight
    │   │   ├── ebook.css
    │   │   └── website.css
    │   ├── gitbook-plugin-livereload
    │   │   └── plugin.js
    │   ├── gitbook-plugin-lunr
    │   │   ├── lunr.min.js
    │   │   └── search-lunr.js
    │   ├── gitbook-plugin-search
    │   │   ├── lunr.min.js
    │   │   ├── search-engine.js
    │   │   ├── search.css
    │   │   └── search.js
    │   ├── gitbook-plugin-sharing
    │   │   └── buttons.js
    │   ├── gitbook.js
    │   ├── images
    │   │   ├── apple-touch-icon-precomposed-152.png
    │   │   └── favicon.ico
    │   ├── style.css
    │   └── theme.js
    ├── index.html
    └── search_index.json

11 directories, 27 files
$ &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;code&gt;gitbook serve&lt;/code&gt; 命令可能会自动生成 &lt;code&gt;_book&lt;/code&gt; 目录,如已存在则更新.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-0c7e35985dbaac7f.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;gitbook-serve.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;gitbook-editor-编辑器&quot;&gt;&lt;code&gt;gitbook editor&lt;/code&gt; 编辑器&lt;/h2&gt;
&lt;p&gt;下载 &lt;a href=&quot;https://legacy.gitbook.com/editor&quot;&gt;gitbook editor&lt;/a&gt; 并安装,如果下载遇到困难,可以找我来帮忙哟!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-66aa2dda45eb3084.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-editor-welcome.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你没有梯子,可以暂不登录(Do that Later),只不过无法与 &lt;code&gt;gitbook.com&lt;/code&gt; 保持同步.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;更改图书路径&quot;&gt;更改图书路径&lt;/h3&gt;
&lt;p&gt;更改默认图书存放位置(&lt;code&gt;Gitbook Editor =&amp;gt; Change Library Path...&lt;/code&gt;),以后图书目录都在该目录下,比如设置的是 &lt;code&gt;.../gitbook-editor/&lt;/code&gt; 图书目录.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-6fcdcb61b765bcfb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-editor-library-preview.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-c9f96b67ed6ca10b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-editor-library-chose.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;新建图书&quot;&gt;新建图书&lt;/h3&gt;
&lt;p&gt;新建图书项目,名字仍然是 &lt;code&gt;gitbook-demo&lt;/code&gt;,这样方便比较和命令行创建的 &lt;code&gt;gitbook-demo&lt;/code&gt; 区别.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-885e3bb141fed523.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-editor-demo-preview.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;图形化操作界面总体来说还是很容易上手的,自己好好研究一下即可,这里仅仅演示默认效果.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;启动项目&quot;&gt;启动项目&lt;/h3&gt;
&lt;p&gt;现在先找到新建图书的具体目录,然后再启动本地服务器,同样地,我们在浏览器中体验电子书效果.&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;图书项目路径: &lt;code&gt;/workspace/gitbook-editor/Import/gitbook-demo&lt;/code&gt;,其中 &lt;code&gt;/workspace/gitbook-editor/&lt;/code&gt; 是上一步更改的图书路径.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;# 启动本地服务器
$ gitbook serve&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里不再需要运行 &lt;code&gt;gitbook init&lt;/code&gt; 命令了,因为已经创建过 &lt;code&gt;README.md&lt;/code&gt; 和 &lt;code&gt;SUMMARY.md&lt;/code&gt; 这两个文件.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/16648241-a38a5b69f76bffbc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;gitbook-editor-serve-preview.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;code&gt;Gitbook Editor&lt;/code&gt; 编辑器新建的图书项目和 &lt;code&gt;gitbook-cli&lt;/code&gt; 创建的图书项目本质上并没有什么不同,只不过编辑器集成了常用功能而已!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;由于受网络因素所限,暂时不分享这部分知识了,简单来说就是在线编辑并发布电子书,这一点和 &lt;code&gt;github&lt;/code&gt; 的代码托管服务类似.&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;初始化项目 : &lt;code&gt;gitbook init&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;启动项目 : &lt;code&gt;gitbook serve&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;默认访问地址: &lt;code&gt;http://localhost:4000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 01 Apr 2019 23:25:00 +0000</pubDate>
<dc:creator>雪之梦技术驿站</dc:creator>
<og:description>本文主要介绍三种使用 `gitbook` 的方式,分别是 `gitbook` 命令行工具,`Gitbook Editor` 官方编辑器和 `gitbook.com` 官网. 总体来说,三种途径适</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/snowdreams1006/p/10640297.html</dc:identifier>
</item>
<item>
<title>使用MediatR重构单体应用中的事件发布/订阅 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10640280.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10640280.html</guid>
<description>&lt;blockquote readability=&quot;4.5424528301887&quot;&gt;
&lt;p&gt;标题：使用MediatR重构单体应用中的事件发布/订阅&lt;/p&gt;
&lt;p&gt;作者：Lamond Lu&lt;/p&gt;
&lt;p&gt;地址：&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/10640280.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lwqlun/p/10640280.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源代码：&lt;a href=&quot;https://github.com/lamondlu/EventHandlerInSingleApplication&quot; class=&quot;uri&quot;&gt;https://github.com/lamondlu/EventHandlerInSingleApplication&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201904/65831-20190402061649072-1894283141.jpg&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在之前的一篇文章中，我分享了一个&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/10468058.html&quot;&gt;在ASP.NET Core单体程序中，使用事件发布/订阅解耦业务逻辑的例子&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201904/65831-20190402061655132-1294720334.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.4457831325301&quot;&gt;
&lt;p&gt;项目源代码地址：&lt;a href=&quot;https://github.com/lamondlu/EventHandlerInSingleApplication&quot; class=&quot;uri&quot;&gt;https://github.com/lamondlu/EventHandlerInSingleApplication&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在文章评论中老张提到了使用MediatR的方案。对于MediatR，我以前只是听说的，没有认真研究过。上周末的胶东开发者技术沙龙中，衣哥也提到了这个库，闲暇时间我就研究了一下，并修改了之前的例子，发现确实简化了不少代码。&lt;/p&gt;
&lt;blockquote readability=&quot;5.3181818181818&quot;&gt;
&lt;p&gt;如果没有看过&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/10468058.html&quot;&gt;之前的文章&lt;/a&gt;，建议你先看一下之前的实现，本文中的所有修改都是针对上一篇的代码。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。&lt;/p&gt;
&lt;p&gt;中介者模式是一种对象行为型模式，其主要优点如下。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;降低了对象之间的耦合性，使得对象易于独立地被复用。&lt;/li&gt;
&lt;li&gt;将对象间的一对多关联转变为一对一的关联，提高系统的灵活性，使得系统易于维护和扩展。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实事件发布/订阅就是中介者模式的一种实现方式。&lt;/p&gt;

&lt;p&gt;MediatR是一个基于.NET的中介者模式实现库，它是一种&lt;strong&gt;进程内&lt;/strong&gt;消息传递的方案，官网地址https://github.com/jbogard/MediatR/。&lt;/p&gt;
&lt;p&gt;MediatR可以发送两种消息&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;请求/响应消息，这种消息只有一个处理程序， 这种方式的消息需要实现&lt;code&gt;IRequest&lt;/code&gt;接口， 其处理程序需要实现&lt;code&gt;IRequestHandler&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;通知消息，这种消息可以有一个或多个处理程序，这种方式的消息需要实现&lt;code&gt;INotification&lt;/code&gt;接口， 其处理程序需要实现&lt;code&gt;INotificationHandler&lt;/code&gt;接口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从消息的特性上看，如果要改造我们之前的事件发布/订阅功能，我们需要使用通知消息，因为每个事件可能会有一个或多个的处理程序。&lt;/p&gt;

&lt;p&gt;在.NET Core中可以直接使用Nuget添加MediatR.Extensions.Microsoft.DependencyInjection库来引入MediatR&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Install-Package MediatR.Extensions.Microsoft.DependencyInjection&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;添加完成后，我们还需要在Startup.cs中启动MediatR中间件。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public void ConfigureServices(IServiceCollection services)
    {
        services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
        
        ...
        services.AddMediatR();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在我们就可以在项目中使用MediatR了。&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;这里你可以会有疑问，之前的代码中，我们这里还定义了事件和处理器之间的映射，现在怎么就不需要了？&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;EventHandlerContainer
  .Subscribe&amp;lt;ShoppingCartSubmittedEvent, CreateOrderHandler&amp;gt;();
EventHandlerContainer
  .Subscribe&amp;lt;ShoppingCartSubmittedEvent, ConfirmEmailSentHandler&amp;gt;();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里MediatR中已经提供了一个自动映射功能，它会在程序启动时，自动搜索所有事件和事件处理器，并自动设置好它们之间的映射，所以我们就不需要在手动做这个事情了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在我们之前的代码中，我们定义了一个购物车提交事件，它继承自事件基类&lt;code&gt;EventBase&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class ShoppingCartSubmittedEvent : EventBase
    {
        public ShoppingCartSubmittedEvent()
        {
            Items = new List&amp;lt;ShoppingCartSubmittedItem&amp;gt;();
        }

        public List&amp;lt;ShoppingCartSubmittedItem&amp;gt; Items { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在改用MediatR之后，我们需要修改当前事件的定义，让它实现&lt;code&gt;INotification&lt;/code&gt;接口。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class ShoppingCartSubmittedEvent : INotification
    {
        public ShoppingCartSubmittedEvent()
        {
            Items = new List&amp;lt;ShoppingCartSubmittedItem&amp;gt;();
        }

        public List&amp;lt;ShoppingCartSubmittedItem&amp;gt; Items { get; set; }
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;完成事件定义部分的修改之后，我们还需要重构事件处理器的代码。&lt;/p&gt;
&lt;p&gt;在之前的代码中，针对购物车提交事件，我们定义了两个处理器，一个是创建订单处理器&lt;code&gt;CreateOrderHandler&lt;/code&gt;，一个是发送邮件处理器&lt;code&gt;ConfirmEmailSentHandler&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;现在我们来使用&lt;code&gt;INotificationHandler&lt;/code&gt;接口来改造之前定义好的两个处理器。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class CreateOrderHandler : INotificationHandler&amp;lt;ShoppingCartSubmittedEvent&amp;gt;
    {
        private IOrderManager _orderManager = null;

        public CreateOrderHandler(IOrderManager orderManager)
        {
            _orderManager = orderManager;
        }

        public Task Handle(ShoppingCartSubmittedEvent notification, CancellationToken cancellationToken)
        {
            _orderManager.CreateNewOrder(new Models.DTOs.CreateOrderDTO
            {
                Items = notification.Items.Select(p =&amp;gt; new Models.DTOs.NewOrderItemDTO
                {
                    ItemId = p.ItemId,
                    Name = p.Name,
                    Price = p.Price
                }).ToList()
            });

            return Task.CompletedTask;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public class ConfirmEmailSentHandler : INotificationHandler&amp;lt;ShoppingCartSubmittedEvent&amp;gt;
    {
        public Task Handle(ShoppingCartSubmittedEvent notification, CancellationToken cancellationToken)
        {
            Console.WriteLine(&quot;Confirm Email Sent.&quot;);
            return Task.CompletedTask;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;代码解释：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;INotificationHandler&lt;/code&gt;是一个泛型接口，接口中定义的泛型类需要实现&lt;code&gt;INotification&lt;/code&gt;接口&lt;/li&gt;
&lt;li&gt;当处理器实现&lt;code&gt;INotificationHandler&lt;/code&gt;接口时，就需要实现一个&lt;code&gt;Handle&lt;/code&gt;方法, 在该方法中，我们可以编写具体的业务代码&lt;/li&gt;
&lt;li&gt;从方法的返回值Task, 你可以了解到这个方法是没有返回值的，并且可以使用async/await变为一个异步的版本。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;

&lt;p&gt;在之前的代码中，当购物车提交成功之后，我们会在&lt;code&gt;OrderManager&lt;/code&gt;类中，使用&lt;code&gt;EventContainer&lt;/code&gt;发布事件。当我们使用MediatR之后，这部分代码稍有改动， 我们需要使用&lt;code&gt;IMediator&lt;/code&gt;接口对象的&lt;code&gt;Publish&lt;/code&gt;方法来发布事件。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;    public void SubmitShoppingCart(string shoppingCartId)
    {
        var shoppingCart = _unitOfWork.ShoppingCartRepository.GetShoppingCart(shoppingCartId);

        _unitOfWork.ShoppingCartRepository.SubmitShoppingCart(shoppingCartId);

        _mediator.Publish(new ShoppingCartSubmittedEvent()
        {
            Items = shoppingCart.Items.Select(p =&amp;gt; new ShoppingCartSubmittedItem
            {
                ItemId = p.ItemId,
                Name = p.Name,
                Price = p.Price
            }).ToList()
        });

        _unitOfWork.Save();
    }&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;至此，所有代码就都完成了，我们可以按照上一篇的操作步骤，再测试一次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201904/65831-20190402061700852-2040080046.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当执行购物车提交操作的时候，订单创建和邮件发送处理器都正确触发了。&lt;/p&gt;

&lt;p&gt;MediatR是一个基于.NET的中介者模式实现，它虽然只支持&lt;strong&gt;进程内&lt;/strong&gt;的消息传递，但是却可以简化事件发布/订阅代码，帮助实现业务逻辑代码的解耦，你可以自己试一试。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 22:22:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>标题：使用MediatR重构单体应用中的事件发布/订阅 作者：Lamond Lu 地址： 源代码：https://github.com/lamondlu/EventHandlerInSingleApp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10640280.html</dc:identifier>
</item>
<item>
<title>Linux 中查看进程及资源使用情况 - 刘哇勇</title>
<link>http://www.cnblogs.com/Wayou/p/linux_top_command.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Wayou/p/linux_top_command.html</guid>
<description>&lt;p&gt;自带的 &lt;code&gt;top&lt;/code&gt; 命令类似于平时我们使用的任务管理器，能够列出当前系统中的进程及资源的使用情况。&lt;/p&gt;
&lt;div class=&quot;highlight highlight-source-shell&quot; readability=&quot;7&quot;&gt;
&lt;pre&gt;
$ man top
       top - display Linux tasks
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用起来很简单，不加任何参数的情况下已经很实用了。其输出大致是下面这个样子：&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55340333-0e87e680-54d7-11e9-8761-8ea2bc2fabac.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55340333-0e87e680-54d7-11e9-8761-8ea2bc2fabac.png&quot; alt=&quot;top命令的输出界面&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;em&gt;&lt;code&gt;top&lt;/code&gt;命令的输出界面&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;按 &lt;code&gt;q&lt;/code&gt; 可退出该界面。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Tips: &lt;code&gt;top&lt;/code&gt; 的输出每 3 秒刷新一次，如果想将画面定格，Mac 下可使用 &lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;s&lt;/kbd&gt; 来停止刷新，&lt;kbd&gt;control&lt;/kbd&gt; + &lt;kbd&gt;q&lt;/kbd&gt; 恢复刷新。当然，还可以通过在当前界面按 &lt;kbd&gt;d&lt;/kbd&gt; 来设置刷新频率，如下图。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55340375-22334d00-54d7-11e9-8f4f-b96d3d727c54.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55340375-22334d00-54d7-11e9-8f4f-b96d3d727c54.png&quot; alt=&quot;按 &amp;lt;kbd&amp;gt;d&amp;lt;/kdb&amp;gt; 设置刷新频率&quot;/&gt;&lt;/a&gt;&lt;br/&gt;&lt;em&gt;按 &lt;kbd&gt;d&lt;/kbd&gt; 设置刷新频率&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下面来细看各部分的内容的含义。&lt;/p&gt;
&lt;h3&gt;top&lt;/h3&gt;
&lt;p&gt;关于机器运行的统计信息。从👈🏻至👉🏻依次是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;22:23:10&lt;/code&gt; 系统当前时间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;up 80 days, 11:44&lt;/code&gt; 系统已经运行了80多天了。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 user&lt;/code&gt; 当前登录的用户数。1 个，也就是我自己。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;load average: 1.31, 1.33, 1.29&lt;/code&gt; 系统平均负荷（Load），三个值，分别表示过去 1 分钟，5 分钟和 15 分钟的平均负荷。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;Tasks&lt;/h3&gt;
&lt;p&gt;进程统计信息，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;66 total&lt;/code&gt; 总计 66 个进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 running&lt;/code&gt; 其中 1 个正在运行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;65 sleeping&lt;/code&gt; 65 个处于休眠。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 stopped&lt;/code&gt; 0 个停止。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 zombie&lt;/code&gt; 以及 0 个&lt;strong&gt;僵尸进程&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里，其他都好理解，什么又是僵尸进程？简单理解它是这么种进程，任务已经完成但没有退出，仍然显示在进程列表中。常见的情形是子进程，子进程中任务完成后，主进程还可能保持与其进行通信等。继续了解可阅读 &lt;a href=&quot;https://www.tutorialspoint.com/what-is-zombie-process-in-linux&quot; rel=&quot;nofollow&quot;&gt;What is Zombie Process in Linux?&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;CPU&lt;/h3&gt;
&lt;p&gt;这一行是 CPU 使用情况的统计。分成了 8 个部分，他们相加后当然应该是 100% 啦。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;100.0 us&lt;/code&gt; ：（user） 用户消耗的 CPU 百分比。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0.0 sy&lt;/code&gt; ：（system） 系统消耗的 CPU。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0.0 ni&lt;/code&gt; ： &lt;strong&gt;nice 进程&lt;/strong&gt;消耗的 CPU。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0.0 id&lt;/code&gt; ：（idle） 空闲的 CPU。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0.0 wa&lt;/code&gt; ：（waiting） 等待处理 I/O 操作的 CPU 资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0.0 hi&lt;/code&gt; ：（Hardware IRQ）处理硬件交互的 CPU 资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0.0 si&lt;/code&gt; ：（Software Interrupts）处理软件交互的 CPU 资源。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0.0 st&lt;/code&gt; ：（Steal Time）如果当前处于虚拟系统（vm）中，此项表示由管理程序从此系统偷走拿去处理其他任务的 CPU 资源。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其他好说，什么是 nice 进程。简单理解，进程的 nice 值与 priority 都是标识进程优先级的，前者是用户层面的优先级，后者是 Linux Kernel 使用的值。继续了解可移步 &lt;a href=&quot;https://askubuntu.com/questions/656771/process-niceness-vs-priority&quot; rel=&quot;nofollow&quot;&gt;Process 'niceness' vs. 'priority'&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;Mem &amp;amp; Swap&lt;/h3&gt;
&lt;p&gt;这两行表示物理内存（RAM）及 swap 空间的使用情况。拿内存这一行来说，依次表示：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;606704 total&lt;/code&gt; 总内存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;89464 free&lt;/code&gt; 空闲的部分&lt;/li&gt;
&lt;li&gt;&lt;code&gt;128300 used&lt;/code&gt; 使用的部分&lt;/li&gt;
&lt;li&gt;&lt;code&gt;388940 buff/cache&lt;/code&gt; buff 或缓存的部分&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于内存这部分，可阅读此文章 &lt;a href=&quot;http://linuxaria.com/howto/linux-memory-management&quot; rel=&quot;nofollow&quot;&gt;Linux memory management&lt;/a&gt; 进一步了解详情。&lt;br/&gt;关于 swap 的理解可阅读 &lt;a href=&quot;https://www.linux.com/news/all-about-linux-swap-space&quot; rel=&quot;nofollow&quot;&gt;All about Linux swap space&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;进程列表&lt;/h3&gt;
&lt;p&gt;紧接着列出的是各进程，默认以 CPU 使用量排序。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;PID&lt;/code&gt;： 进程的 id，通过它来操作指定进程。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;USER&lt;/code&gt;： 进程的所有者。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;PR&lt;/code&gt;： 进程的优先级。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NI&lt;/code&gt;： 进程的 &lt;code&gt;NICE&lt;/code&gt; 值，默认 0。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;VIRT&lt;/code&gt;： 进程使用的虚拟内存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;RES&lt;/code&gt;： 进程使用的物理内存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SHR&lt;/code&gt;： 进程使用的共享内存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;S&lt;/code&gt;： status，进程的状态: S=睡眠中/sleep R=支行中/running Z=僵尸进程/zombie (S)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%CPU&lt;/code&gt;： 进程消耗的 CPU 百分比。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%MEM&lt;/code&gt;： 进程使用的 RAM 百分比。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TIME+&lt;/code&gt;： 进程运行时长。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;COMMAND&lt;/code&gt;： 进程名。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上。&lt;/p&gt;
&lt;p&gt;大致了解后便不会感到眼花缭乱了。对于各指标含义了解后，可方便我们在服务端排查问题，分析程序运行是否可控和正常。比如你的 Node.js 服务。&lt;/p&gt;
&lt;h3&gt;一些 top 命令&lt;/h3&gt;
&lt;p&gt;除了展现信息，在 top 的输出界面，还有很多命令可用，比如上面提到的 &lt;kbd&gt;d&lt;/kbd&gt; 设置刷新时间。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最常用的，发现某个进程快把机器爆掉了，按 &lt;kbd&gt;k&lt;/kbd&gt; 然后输入其 PID 将该进程结束掉。&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;o&lt;/kbd&gt; 调整各列的顺序/order。&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;u&lt;/kbd&gt; 展示某个用户的进程。再次进入设置时设置成空则回到展示全部进程。&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;z&lt;/kbd&gt; 高亮运行中的进程。&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;c&lt;/kbd&gt; 展示进程的绝对路径。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;htop&lt;/h3&gt;
&lt;p&gt;除了自带的 &lt;code&gt;top&lt;/code&gt; 命令，还可安装另外一个加强版 &lt;code&gt;htop&lt;/code&gt;，其界面更加美观，呈现的东西大同小异，但功能交互上更加方便强大。&lt;/p&gt;

&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener noreferrer&quot; href=&quot;https://user-images.githubusercontent.com/3783096/55340408-32e3c300-54d7-11e9-9b11-911b224444a0.png&quot;&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/3783096/55340408-32e3c300-54d7-11e9-9b11-911b224444a0.png&quot; alt=&quot;htop 的界面界面&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;界面上友好的菜单已经无须多说便能上手。&lt;/p&gt;
&lt;h3&gt;相关资料&lt;/h3&gt;
</description>
<pubDate>Mon, 01 Apr 2019 15:52:00 +0000</pubDate>
<dc:creator>刘哇勇</dc:creator>
<og:description>自带的 top 命令类似于平时我们使用的任务管理器，能够列出当前系统中的进程及资源的使用情况。 $ man top top display Linux tasks 使用起来很简单，不加任何参数的情况下</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Wayou/p/linux_top_command.html</dc:identifier>
</item>
<item>
<title>JAVA8给我带了什么——并流行和接口新功能 - Aomi</title>
<link>http://www.cnblogs.com/hayasi/p/10639994.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hayasi/p/10639994.html</guid>
<description>&lt;p&gt;流，确定是笔者内心很向往的天堂，有他之后JAVA在处理数据就变更加的灵动。加上lambda表达不喜欢都不行。JAVA8也为流在提供另一个功能——并行流。即是有并行流，那么是不是也有顺序流。没有错。我前面操作的一般都是顺序流。在JAVA8里面并行流和顺序流是可以转变的。来看一个例子——笔者打印数字。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package com.aomi;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import java.util.stream.LongStream;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         LongStream.range(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;).forEach(i -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             System.&lt;span&gt;out&lt;/span&gt;.print(i + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;LongStream.range这个方法是来获取数字的。这里表示获得0到10，但不含10 的数字。运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/660648/201904/660648-20190401231853594-215137203.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在让我们把他换成并行来看看。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package com.aomi;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import java.util.stream.LongStream;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         LongStream.range(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;).parallel().forEach(i -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             System.&lt;span&gt;out&lt;/span&gt;.print(i + &lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/660648/201904/660648-20190401232020110-148957155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;俩个结果相比一下，我们就可以明显他们发生了变化。我们只是加一个parallel函数就发生好多的变化。笔者本来是要讲他们之间的性能比较的。不敢，因为笔者试好还有个例子。却发现有时候顺序流都比并行流来快。上面是顺序流转并行流。在来看一下相反的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;         List&amp;lt;Integer&amp;gt; datas = Arrays.asList(1,2,3,4,56&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         
&lt;span&gt;6&lt;/span&gt;         datas.parallelStream().forEach(i -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             System.out.print(i + &quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;parallelStream函数就是用来建一个并行流的。运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/660648/201904/660648-20190401232212985-652529774.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;转为顺序流&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt; 
&lt;span&gt;4&lt;/span&gt;         List&amp;lt;Integer&amp;gt; datas = Arrays.asList(1,2,3,4,56&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         
&lt;span&gt;6&lt;/span&gt;         datas.parallelStream().sequential().forEach(i -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt;             System.out.print(i + &quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/660648/201904/660648-20190401232323769-1998241056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们都知道流里面用到了JAVA7里面的分支和合并的框架来进行的。古代有一个词叫分而治之。把一个事情分为几个小事件。然面各自处理。所以了解代码里面是什么样子折分成小事件是非常重要的。他有俩个关键字Fork和Join。Fork方法你可以理解为拆分，并压入线程队列中。而Join就是合并的意思了。来笔者来写一个试。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomi;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.ArrayList;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.RecursiveTask;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DistinctCharForkJoin &lt;span&gt;extends&lt;/span&gt; RecursiveTask&amp;lt;List&amp;lt;Character&amp;gt;&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;Character&amp;gt;&lt;span&gt; chars;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; DistinctCharForkJoin(List&amp;lt;Character&amp;gt;&lt;span&gt; chars) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;(chars, 0&lt;span&gt;, chars.size());
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; DistinctCharForkJoin(List&amp;lt;Character&amp;gt; chars, &lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; end) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.chars =&lt;span&gt; chars.subList(start, end);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;protected&lt;/span&gt; List&amp;lt;Character&amp;gt;&lt;span&gt; compute() {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         List&amp;lt;Character&amp;gt; tmpChars = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Character&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断不可以在拆分了&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.chars.size() &amp;lt; 3&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Character character : chars) {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;tmpChars.contains(character))
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    tmpChars.add(character);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示可以在拆分。&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;int&lt;/span&gt; len = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.chars.size();
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建立左边的小事件&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             DistinctCharForkJoin leftForkJoin = &lt;span&gt;new&lt;/span&gt; DistinctCharForkJoin(chars, 0, len / 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            leftForkJoin.fork();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 建立右边的小事件&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;             DistinctCharForkJoin rightForkJoin = &lt;span&gt;new&lt;/span&gt; DistinctCharForkJoin(chars, len / 2&lt;span&gt;, len);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            rightForkJoin.fork();
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;             List&amp;lt;Character&amp;gt; rChars =&lt;span&gt; rightForkJoin.join();
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; 
&lt;span&gt;49&lt;/span&gt;             List&amp;lt;Character&amp;gt; lChars =&lt;span&gt; leftForkJoin.join();
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 俩个合并。&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Character character : rChars) {
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;tmpChars.contains(character))
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                    tmpChars.add(character);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Character character : lChars) {
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;tmpChars.contains(character))
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;                    tmpChars.add(character);
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; 
&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmpChars;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Main:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         List&amp;lt;Character&amp;gt; chars = Arrays.asList('a', 'b', 'c', 'd', 'b', 'a'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         DistinctCharForkJoin task = &lt;span&gt;new&lt;/span&gt; DistinctCharForkJoin(&quot;main&quot;&lt;span&gt;, chars);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         List&amp;lt;Character&amp;gt; resChars = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ForkJoinPool().invoke(task);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Character character : resChars) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;             System.out.print(character +&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/660648/201904/660648-20190401232501507-658352898.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;你们一定很奇怪为什么笔者会讲到JAVA7带来的东西呢？JAVA8引入了一个新的接口——Spliterator接口。人称可分迭代器。如果你有心去看一个接口List的话，你可能会发现一个方法。如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;default&lt;/span&gt; Spliterator&amp;lt;E&amp;gt;&lt;span&gt; spliterator() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; Spliterators.spliterator(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, Spliterator.ORDERED);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Spliterator接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Spliterator&amp;lt;T&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; tryAdvance(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; T&amp;gt;&lt;span&gt; action);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     Spliterator&amp;lt;T&amp;gt;&lt;span&gt; trySplit();
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt;&lt;span&gt; estimateSize();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; characteristics();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;讲JAVA7里面的分支/合并的目地就是为了理解Spliterator接口的作用。如下&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;tryAdvance：用于遍历当前的元素。如果还有的话，就返回true;&lt;/li&gt;
&lt;li&gt;trySplit：用于拆分。如果当前不可以在拆分的话，就返回null;跟上面的compute方法很像。&lt;/li&gt;
&lt;li&gt;estimateSize：表示还需要遍历的元素有多少。&lt;/li&gt;
&lt;li&gt;characteristics：表示当前处理的数据是什么样子的。比如是否有序，每一元素是否为null。上面Spliterator接口的代码是笔者去掉大部分复制出来。这个值都在代码中。作用你们可以自己去看一下代码就是知道。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;要注意Spliterator接口只是用去拆分任务的作用。JAVA8帮你做了很多拆分的功能。大部分你可以不用自己写。当然如果你想要自己动手。你只要实现这样子就可以了。如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomi;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.List;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Spliterator;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.function.Consumer;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; DistinctCharSpliterator &lt;span&gt;implements&lt;/span&gt; Spliterator&amp;lt;Character&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; List&amp;lt;Character&amp;gt;&lt;span&gt; chars;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; index = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; DistinctCharSpliterator(List&amp;lt;Character&amp;gt;&lt;span&gt; chars) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.chars =&lt;span&gt; chars;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; DistinctCharSpliterator(List&amp;lt;Character&amp;gt; chars, &lt;span&gt;int&lt;/span&gt; start, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; end) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.chars =&lt;span&gt; chars.subList(start, end);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; tryAdvance(Consumer&amp;lt;? &lt;span&gt;super&lt;/span&gt; Character&amp;gt;&lt;span&gt; action) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         action.accept(&lt;span&gt;this&lt;/span&gt;.chars.get(index++&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; index &amp;lt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.chars.size();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Spliterator&amp;lt;Character&amp;gt;&lt;span&gt; trySplit() {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; difLen = &lt;span&gt;this&lt;/span&gt;.chars.size() -&lt;span&gt; index;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断不可以在拆分了&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (difLen &amp;lt; 3&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt; {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 表示可以在拆分。&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;             
&lt;span&gt;38&lt;/span&gt;             DistinctCharSpliterator spliterator = &lt;span&gt;new&lt;/span&gt; DistinctCharSpliterator(chars.subList(index, index + 2&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt;             index = index + 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; spliterator;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; estimateSize() {
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.chars.size() -&lt;span&gt; index;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; characteristics() {
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有序 元素不空 遍历过程不能删除，和修改 增加&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; ORDERED + NONNULL +&lt;span&gt; IMMUTABLE;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Main:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;         List&amp;lt;Character&amp;gt; chars = Arrays.asList('a', 'b', 'c', 'd', 'b', 'a'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;         DistinctCharSpliterator distinctCharSpliterator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DistinctCharSpliterator(chars);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         Stream&amp;lt;Character&amp;gt; stream = StreamSupport.stream(distinctCharSpliterator, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         stream.distinct().forEach((Character ch) -&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;             System.out.print(ch+&quot; &quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/660648/201904/660648-20190401232803660-1391468339.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的例子有一点烂。但是大家可以复制做一下继点去看看他的执行过程。就可以看出很多东西来。主要是理解这个原理就可以了。&lt;br/&gt;流的并行功能并没有让笔者有多心动。真正让笔者感觉不错的要属于JAVA8对接口的升级。什么意思？笔者不清楚有多少个人写个框架或是读过框架源码，一般框架里面都会用到一些面向接口的编程模式。那个或多或少会有这样子感觉。一但项目发布出去，这个时候你想要修改接口。比如在接口里面增加一个新的功能方法。这样子时候你就不得不考虑一下外面有多少个人在实现你现在框架的接口。因为你增加一个接口的新方法。别人也要跟着实现，不然的一定会报错或是运行时候报错。不管哪一种都是设计者不想看到的。&lt;br/&gt;JAVA8现在可以让你定义接口的默认方法。什么思意呢？让笔得写一个例子。&lt;/p&gt;
&lt;p&gt;Base接口：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomi;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Base {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BaseA类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomi;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; BaseA &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Base {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Main：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomi;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         Base baseA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseA();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        baseA.call();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的代码没有什么特别的。现在笔者在加一个方法。看一个他会不会有问题。如下&lt;/p&gt;
&lt;p&gt;base类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomi;
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; 
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Base {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call();
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call2();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/660648/201904/660648-20190401233513475-1990337788.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看到吧。BaseA类马上就报错。现在笔者在加上一个默认的方法会什么呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomi;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; Base {
    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; call();

    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call2() {
        System.out.println(&lt;/span&gt;&quot;default call2&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Main修改一下吧。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomi;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Main {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         Base baseA = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BaseA();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        baseA.call2();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/660648/201904/660648-20190401233633104-1199036825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的代码。笔者在BaseA类里面并没有实现call2的方法。显然现在的功能对我们写框架的人来写太棒了。在也不用担心增加一个接方法而去考虑有多少个人用这个接口了。&lt;br/&gt;那么问题来了。我们在写代码的过程中，一定会遇到方法相同的情况吧。这个时候JAVA8提供了三个标准来确定用哪一个。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;类或父类的方法优先级高于接口默认的方法。&lt;/li&gt;
&lt;li&gt;如果上面不行的话，谁拥有最具体的实现的话，就用谁。&lt;/li&gt;
&lt;li&gt;如果都不能确定的情况下，就必须显性的调用。来指定他要调哪一个。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;举例子。A和B都是接口。其中B继承了A。同时C实现了A和B。这个时候调用C会是什么样子。&lt;br/&gt;A：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; A {

    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call() {
        System.out.println(&lt;/span&gt;&quot;A call&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;B：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; B  &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; A {
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call() {
        System.out.println(&lt;/span&gt;&quot;B call&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;C:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; C &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; A, B {

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;D:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; TODO Auto-generated method stub&lt;/span&gt;
&lt;span&gt;
        C c &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; C();
        
        c.call();

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/660648/201904/660648-20190401233904438-888951131.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面A和B都是接口。他们有call方法。其中关键是B继承了。说明B拥有A的一切方法。那么是不是说B就是最具体实现的。如果你们只用第一个标准的话，那是肯定不行的。&lt;br/&gt;还是简单一点，我们把B继承A的这个关系去掉，在来看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/660648/201904/660648-20190401233952238-937460286.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不好意思好像报错了。所以只能苦一下了。显性调用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.aomi;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; C &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; B, A {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call() {
        B.&lt;/span&gt;&lt;span&gt;super&lt;/span&gt;&lt;span&gt;.call();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 当然除了上面之外，你还是可以定义静态方法和常量。这个时候有人就会说他不是跟抽象类很像吗？是很像。可是不一样子。抽象类是不是可以实例一个字段。但是接口却不行。还有抽像类你只能单继承。接口就可以多继承了。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 15:50:00 +0000</pubDate>
<dc:creator>Aomi</dc:creator>
<og:description>流，确定是笔者内心很向往的天堂，有他之后JAVA在处理数据就变更加的灵动。加上lambda表达不喜欢都不行。JAVA8也为流在提供另一个功能——并行流。即是有并行流，那么是不是也有顺序流。没有错。我前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hayasi/p/10639994.html</dc:identifier>
</item>
<item>
<title>ThreadPoolExcutor 线程池 异常处理 （下篇） - 一枝花算不算浪漫</title>
<link>http://www.cnblogs.com/wang-meng/p/10639914.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wang-meng/p/10639914.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;因为这是之前面试的一个题目，所以印象比较深刻，前几天写了一篇文章：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/10588637.html&quot;&gt;ThreadPoolExcutor 线程池 异常处理 （上篇）&lt;/a&gt; 中已经介绍了线程池异常的一些问题以及一步步分析了里面的一些源代码，今天就来继续说下如何防范这种情况。&lt;/p&gt;
&lt;h3 id=&quot;结论&quot;&gt;结论&lt;/h3&gt;
&lt;p&gt;这里直接抛出结论，然后再一个个分析:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在我们提供的Runnable的run方法中捕获任务代码可能抛出的所有异常，包括未检测异常&lt;/li&gt;
&lt;li&gt;使用ExecutorService.submit执行任务，利用返回的Future对象的get方法接收抛出的异常，然后进行处理&lt;/li&gt;
&lt;li&gt;重写ThreadPoolExecutor.afterExecute方法，处理传递到afterExecute方法中的异常&lt;/li&gt;
&lt;li&gt;为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常 (不推荐)&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;分析解读&quot;&gt;分析解读&lt;/h3&gt;
&lt;h4 id=&quot;runnable的run方法中捕获任务代码可能抛出的所有异常&quot;&gt;Runnable的run方法中捕获任务代码可能抛出的所有异常&lt;/h4&gt;
&lt;p&gt;这个其实最简单，但是往往面试官问这个问题 考察的点也不在这里。具体的方式可以参考我之前的一篇文章：&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/10163855.html&quot;&gt;论如何优雅的自定义ThreadPoolExecutor线程池&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;核心代码如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230118126-1684676217.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;使用executorservice.submit执行任务利用返回的future对象的get方法接收抛出的异常&quot;&gt;使用ExecutorService.submit执行任务，利用返回的Future对象的get方法接收抛出的异常&lt;/h4&gt;
&lt;p&gt;1， 使用submit执行异步任务，然后通过Future的get方法来接收异常。演示如下：&lt;br/&gt;冲图片可以看到，使用了get方法后，这里直接接收到了异常信息。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230149378-621228438.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2， 这里newTaskFor返回的是FutureTask，然后传递给了execute方法：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230417485-252989006.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3， 接着我们继续往下跟踪execute方法，发现这里调用的是ThreadExecutor中的execute方法，在&lt;a href=&quot;https://www.cnblogs.com/wang-meng/p/10588637.html&quot;&gt;ThreadPoolExcutor 线程池 异常处理 （上篇）&lt;/a&gt; 我们已经分析过这里，最终会到addWorker方法中执行线程的start()方法，因为我们在上一张图片传递的是FutureTask， 所以我们继续跟踪FutureTask中的run方法：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230309326-772071217.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4， 到了FutureTask.run() 方法中，一切似乎都已经明了，这里会有catch捕获当前线程抛出的异常，紧接着我们看看setException做了什么事情：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230439250-1080357118.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5，setExcetion首先是将一个异常信息赋值给一个全局变量outcome，并且将全局的任务状态state字段通过CAS更新为3(异常状态)&lt;br/&gt;然后最后做一些清理工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230459542-163001258.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6，finishCompletion后续是做一些线程池的清理工作，这里涉及到线程池以及线程池中的等待队列的操作，不清楚的同学可以看下线程池实现代码。到了这里线程池中的线程执行已经完毕了，下面再去跟踪一下FutureTask.get()方法。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230519817-1743901553.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7，这里是FutureTask.get()的底层实现，这里其实会拿上面的setException方法中设置的outcome和state做一些逻辑判断，到了这里就直接往上抛出了异常，所以我们在最开始的main方法中才能够捕获到这个异常。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230536195-1283380565.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;重写threadpoolexecutor.afterexecute方法处理传递到afterexecute方法中的异常&quot;&gt;重写ThreadPoolExecutor.afterExecute方法，处理传递到afterExecute方法中的异常&lt;/h3&gt;
&lt;p&gt;这里为何要重写afterExecute方法呢？因为线程执行完毕后一定会执行此方法，源码如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230557717-1313608072.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以我们可以重写此方法来达到接收异常的目的。&lt;/p&gt;
&lt;h3 id=&quot;为工作者线程设置uncaughtexceptionhandler在uncaughtexception方法中处理异常-不推荐&quot;&gt;为工作者线程设置UncaughtExceptionHandler，在uncaughtException方法中处理异常 (不推荐)&lt;/h3&gt;
&lt;p&gt;1，我们在之前ThreadExecutor-&amp;gt;Worker-&amp;gt;run方法中直接往上抛出了异常，但是这些异常抛到哪里了呢？&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230617110-288596807.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2，通过查询JVM的一些资料，最终的异常会到Thread.dispatchUncaughtException中，如下图：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230637292-850368941.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3，所以当我们自定义UncaughtExceptionHandler时就可以捕获到&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/799093/201904/799093-20190401230659293-453513283.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;具体测试代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 测试singleThreadPool异常问题
 *
 * @author: wangmeng
 * @date: 2019/3/25 23:40
 */
public class ThreadPoolException {
    private final static Logger LOGGER = LoggerFactory.getLogger(ThreadPoolException.class);

    public static void main(String[] args) throws InterruptedException {
        ExecutorService execute = new ThreadPoolExecutor(1, 1,
                0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&amp;lt;Runnable&amp;gt;(), new ThreadFactoryBuilder().setUncaughtExceptionHandler(new MyHandler()).build());

        execute.execute(new Runnable() {
            @Override
            public void run() {
                LOGGER.info(&quot;=====11=======&quot;);
            }
        });

        TimeUnit.SECONDS.sleep(5);
        execute.execute(new Run1());
    }


    private static class Run1 implements Runnable {
        @Override
        public void run() {
            int count = 0;
            while (true) {
                count++;
                LOGGER.info(&quot;-------222-------------{}&quot;, count);

                if (count == 10) {
                    System.out.println(1 / 0);
                    try {
                    } catch (Exception e) {
                        LOGGER.error(&quot;Exception&quot;,e);
                    }
                }

                if (count == 20) {
                    LOGGER.info(&quot;count={}&quot;, count);
                    break;
                }
            }
        }
    }
}

class MyHandler implements Thread.UncaughtExceptionHandler {
    private final static Logger LOGGER = LoggerFactory.getLogger(MyHandler.class);
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        LOGGER.error(&quot;threadId = {}, threadName = {}, ex = {}&quot;, t.getId(), t.getName(), e.getMessage());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面说了其实是不推荐重写UncaughtExceptionHandler 的，因为UncaughtExceptionHandler 只有在&lt;code&gt;execute.execute()&lt;/code&gt;方法中才生效，在&lt;code&gt;execute.submit&lt;/code&gt;中是无法捕获到异常的。&lt;/p&gt;
&lt;p&gt;由于本人水平有限，文章中如果有不严谨的地方还请提出来，愿闻其详。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 15:07:00 +0000</pubDate>
<dc:creator>一枝花算不算浪漫</dc:creator>
<og:description>前言 因为这是之前面试的一个题目，所以印象比较深刻，前几天写了一篇文章： 'ThreadPoolExcutor 线程池 异常处理 （上篇）' 中已经介绍了线程池异常的一些问题以及一步步分析了里面的一些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wang-meng/p/10639914.html</dc:identifier>
</item>
<item>
<title>frp源码剖析-frp中的mux模块 - MnCu</title>
<link>http://www.cnblogs.com/MnCu8261/p/10639897.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MnCu8261/p/10639897.html</guid>
<description>&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;frp几乎所有的连接处理都是构建在mux模块之上的，重要性不必多说，来看一下这是个啥吧&lt;/p&gt;
&lt;p&gt;ps: 安装方法&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;go get &quot;github.com/fatedier/golib/net/mux&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该模块很小，不到300行，分为两个文件：&lt;code&gt;mux.go&lt;/code&gt;和&lt;code&gt;rule.go&lt;/code&gt;。&lt;br/&gt;因为&lt;code&gt;rule.go&lt;/code&gt;文件相对简单一些，我们先来看这个。&lt;/p&gt;
&lt;h2 id=&quot;role.go文件&quot;&gt;role.go文件&lt;/h2&gt;
&lt;p&gt;首先看其中所命名的函数类型&lt;code&gt;MatchFunc&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type MatchFunc func(data []byte) (match bool)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该类型的函数用来判断&lt;code&gt;data&lt;/code&gt;属于什么协议。&lt;/p&gt;
&lt;p&gt;那么具体如何判断呢，这里也实现了三个例子:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var (
    HttpsNeedBytesNum uint32 = 1
    HttpNeedBytesNum  uint32 = 3
    YamuxNeedBytesNum uint32 = 2
)

var HttpsMatchFunc MatchFunc = func(data []byte) bool {
    if len(data) &amp;lt; int(HttpsNeedBytesNum) {
        return false
    }

    if data[0] == 0x16 {
        return true
    } else {
        return false
    }
}

// From https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods
var httpHeadBytes = map[string]struct{}{
    &quot;GET&quot;: struct{}{},
    &quot;HEA&quot;: struct{}{},
    &quot;POS&quot;: struct{}{},
    &quot;PUT&quot;: struct{}{},
    &quot;DEL&quot;: struct{}{},
    &quot;CON&quot;: struct{}{},
    &quot;OPT&quot;: struct{}{},
    &quot;TRA&quot;: struct{}{},
    &quot;PAT&quot;: struct{}{},
}

var HttpMatchFunc MatchFunc = func(data []byte) bool {
    if len(data) &amp;lt; int(HttpNeedBytesNum) {
        return false
    }

    _, ok := httpHeadBytes[string(data[:3])]
    return ok
}

// From https://github.com/hashicorp/yamux/blob/master/spec.md
var YamuxMatchFunc MatchFunc = func(data []byte) bool {
    if len(data) &amp;lt; int(YamuxNeedBytesNum) {
        return false
    }

    if data[0] == 0 &amp;amp;&amp;amp; data[1] &amp;gt;= 0x0 &amp;amp;&amp;amp; data[1] &amp;lt;= 0x3 {
        return true
    }
    return false
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这三个函数分别实现了区分&lt;code&gt;HTTPS&lt;/code&gt;,&lt;code&gt;HTTP&lt;/code&gt;以及go中特有的&lt;code&gt;yamux&lt;/code&gt;(实际上这是一个库，可以参考&lt;a href=&quot;http://fishu.cn/blog/%E5%9F%BA%E4%BA%8E-go-%E5%AE%9E%E7%8E%B0i/o%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%80/&quot;&gt;Go中的I/O多路复用&lt;/a&gt;)。&lt;/p&gt;
&lt;h2 id=&quot;mux.go文件&quot;&gt;mux.go文件&lt;/h2&gt;
&lt;p&gt;先来看其中的&lt;code&gt;struct&lt;/code&gt;，第一个是&lt;code&gt;Mux&lt;/code&gt;第二个是&lt;code&gt;listener&lt;/code&gt;，这里先来看一下较为简单的&lt;code&gt;listener&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;listener结构体&quot;&gt;listener结构体&lt;/h3&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type listener struct {
    mux *Mux

    priority     int
    needBytesNum uint32
    matchFn      MatchFunc

    c  chan net.Conn
    mu sync.RWMutex
}

// Accept waits for and returns the next connection to the listener.
func (ln *listener) Accept() (net.Conn, error) {
    ...
}

// Close removes this listener from the parent mux and closes the channel.
func (ln *listener) Close() error {
    ...
}

func (ln *listener) Addr() net.Addr {
    ...
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;刚看到这个结构体我们可能很迷惑，不知道都是干啥的，而且网络编程中一般listener这种东西要绑定在一个套接字上，但很明显&lt;code&gt;listener&lt;/code&gt;没有，不过其唯一跟套接字相关的可能是其&lt;code&gt;c&lt;/code&gt;字段，其是一个由&lt;code&gt;net&lt;/code&gt;包中的&lt;code&gt;Conn&lt;/code&gt;接口组成的&lt;code&gt;chanel&lt;/code&gt;；然后&lt;code&gt;mu&lt;/code&gt;字段就是&lt;a href=&quot;https://www.zhihu.com/question/66733477&quot;&gt;读写锁&lt;/a&gt;了，这个很简单；然后&lt;code&gt;mux&lt;/code&gt;字段则是上面提到的两个结构体中的另一个结构体&lt;code&gt;Mux&lt;/code&gt;的指针；接下来到了&lt;code&gt;priority&lt;/code&gt;字段上，顾名思义，这个似乎跟优先级有关系，暂且存疑；&lt;code&gt;needBytesNum&lt;/code&gt;则更有些蒙了，不过感觉其是跟读取byte的数量有关系，最后是&lt;code&gt;matchFn&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;好，初步认识了这个结构体的结构后，我们看看其方法。三个方法的&lt;code&gt;listener&lt;/code&gt;实现了&lt;code&gt;net&lt;/code&gt;模块中的&lt;code&gt;Listener&lt;/code&gt;接口:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// A Listener is a generic network listener for stream-oriented protocols.
//
// Multiple goroutines may invoke methods on a Listener simultaneously.
type Listener interface {
    // Accept waits for and returns the next connection to the listener.
    Accept() (Conn, error)

    // Close closes the listener.
    // Any blocked Accept operations will be unblocked and return errors.
    Close() error

    // Addr returns the listener's network address.
    Addr() Addr
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后先来分析其&lt;code&gt;Accept&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (ln *listener) Accept() (net.Conn, error) {
    conn, ok := &amp;lt;-ln.c
    if !ok {
        return nil, fmt.Errorf(&quot;network connection closed&quot;)
    }
    return conn, nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法很简单，就是从&lt;code&gt;c&lt;/code&gt;这个由&lt;code&gt;Conn&lt;/code&gt;组成的&lt;code&gt;channel&lt;/code&gt;中，获取&lt;code&gt;Conn&lt;/code&gt;对象，好这里我们就明白了，这个&lt;code&gt;listener&lt;/code&gt;和普通的不一样，他很特别，普通的&lt;code&gt;listener&lt;/code&gt;监听的是套接字，而他监听的是&lt;code&gt;channel&lt;/code&gt;，另外，肯定有某个地方在不停的往&lt;code&gt;c&lt;/code&gt;这个&lt;code&gt;channel&lt;/code&gt;中放&lt;code&gt;Conn&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;接下来是&lt;code&gt;Close&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (ln *listener) Close() error {
    if ok := ln.mux.release(ln); ok {
        // Close done to signal to any RLock holders to release their lock.
        close(ln.c)
    }
    return nil
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们暂且先把这个&lt;code&gt;ln.mux.release(ln)&lt;/code&gt;放到一边，因为还不知道这个东西干了啥，暂且只需关注&lt;code&gt;close(ln.c)&lt;/code&gt;，我们知道这个函数是用来关闭&lt;code&gt;channel&lt;/code&gt;的，go推荐由发送端调用，但这里似乎&lt;code&gt;listener&lt;/code&gt;是一个消费端，可以看一下&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32529039&quot;&gt;如何优雅的关闭Go Channel&lt;/a&gt;，看来重点在于&lt;code&gt;ln.mux.release(ln)&lt;/code&gt;这里，我们暂且&lt;sup&gt;存疑[1]&lt;/sup&gt;，留待下面解决。&lt;/p&gt;
&lt;p&gt;最后是&lt;code&gt;Addr&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (ln *listener) Addr() net.Addr {
    if ln.mux == nil {
        return nil
    }
    ln.mux.mu.RLock()
    defer ln.mux.mu.RUnlock()
    if ln.mux.ln == nil {
        return nil
    }
    return ln.mux.ln.Addr()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，&lt;code&gt;mu&lt;/code&gt;字段就用上了，加读锁，然后返回&lt;code&gt;mux&lt;/code&gt;字段中的&lt;code&gt;ln&lt;/code&gt;字段的&lt;code&gt;Addr&lt;/code&gt;方法。也就是这句&lt;code&gt;return ln.mux.ln.Addr()&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;mux结构体&quot;&gt;Mux结构体&lt;/h3&gt;
&lt;h4 id=&quot;字段以及相关函数&quot;&gt;字段以及相关函数&lt;/h4&gt;
&lt;p&gt;Mux结构体则相对来说复杂很多，先来看一下他的字段定义:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;type Mux struct {
    ln net.Listener

    defaultLn *listener

    // sorted by priority
    lns             []*listener
    maxNeedBytesNum uint32

    mu sync.RWMutex
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;好，第一个字段&lt;code&gt;ln&lt;/code&gt;是一个&lt;code&gt;Listener&lt;/code&gt;接口；然后&lt;code&gt;defaultLn&lt;/code&gt;是一个&lt;code&gt;listener&lt;/code&gt;的指针；&lt;code&gt;lns&lt;/code&gt;则是由&lt;code&gt;listener&lt;/code&gt;的指针组成的切片，根据注释&lt;code&gt;// sorted by priority&lt;/code&gt;，我们终于知道&lt;code&gt;listener&lt;/code&gt;的&lt;code&gt;priority&lt;/code&gt;字段是干啥的了；接下来是&lt;code&gt;maxNeedBytesNum&lt;/code&gt;字段，好奇怪，比起&lt;code&gt;listener&lt;/code&gt;的&lt;code&gt;needBytesNum&lt;/code&gt;多了个“Max”，所以我们推测这个值取得是&lt;code&gt;lns&lt;/code&gt;以及&lt;code&gt;defaultLn&lt;/code&gt;字段中所有&lt;code&gt;listener&lt;/code&gt;中&lt;code&gt;needBytesNum&lt;/code&gt;值最大的；最后的&lt;code&gt;mu&lt;/code&gt;字段我们就不说了。&lt;/p&gt;
&lt;p&gt;需要注意的是：我们可能会发现&lt;code&gt;Mux&lt;/code&gt;和&lt;code&gt;listener&lt;/code&gt;存在相互引用，但在&lt;code&gt;Go&lt;/code&gt;中我们倒也不用太担心，因为&lt;code&gt;Go&lt;/code&gt;采用“标记-回收”或者其变种的垃圾回收算法，感兴趣可以参考&lt;a href=&quot;http://legendtkl.com/2017/04/28/golang-gc/&quot;&gt;Golang 垃圾回收剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;mux.go&lt;/code&gt;文件中定义了&lt;code&gt;Mux&lt;/code&gt;的生成函数&lt;code&gt;NewMux&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func NewMux(ln net.Listener) (mux *Mux) {
    mux = &amp;amp;Mux{
        ln:  ln,
        lns: make([]*listener, 0),
    }
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很简单，需要注意的是&lt;code&gt;ln&lt;/code&gt;字段存储的一般&lt;strong&gt;不是&lt;/strong&gt;&lt;code&gt;listener&lt;/code&gt;这样的非常规Listener，一般是&lt;code&gt;TCPListener&lt;/code&gt;这样具体的绑定了套接字的监听器。&lt;/p&gt;
&lt;h4 id=&quot;mux方法&quot;&gt;Mux方法&lt;/h4&gt;
&lt;p&gt;接下来看&lt;code&gt;Mux&lt;/code&gt;结构体的方法，首先看&lt;code&gt;Listen&lt;/code&gt;和&lt;code&gt;copyLns&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// priority
func (mux *Mux) Listen(priority int, needBytesNum uint32, fn MatchFunc) net.Listener {
    // 1
    ln := &amp;amp;listener{
        c:            make(chan net.Conn),
        mux:          mux,
        priority:     priority,
        needBytesNum: needBytesNum,
        matchFn:      fn,
    }

    mux.mu.Lock()
    defer mux.mu.Unlock()
    // 2
    if needBytesNum &amp;gt; mux.maxNeedBytesNum {
        mux.maxNeedBytesNum = needBytesNum
    }

    // 3
    newlns := append(mux.copyLns(), ln)
    sort.Slice(newlns, func(i, j int) bool {
        if newlns[i].priority == newlns[j].priority {
            return newlns[i].needBytesNum &amp;lt; newlns[j].needBytesNum
        }
        return newlns[i].priority &amp;lt; newlns[j].priority
    })
    mux.lns = newlns
    return ln
}

func (mux *Mux) copyLns() []*listener {
    lns := make([]*listener, 0, len(mux.lns))
    for _, l := range mux.lns {
        lns = append(lns, l)
    }
    return lns
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;copyLns&lt;/code&gt;方法很简单，就是跟名字的含义一样，生成一个&lt;code&gt;lns&lt;/code&gt;字段的副本并返回。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Listen&lt;/code&gt;基本做了三步:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;生成一个&lt;code&gt;listener&lt;/code&gt;结构体实例，并获取互斥锁&lt;/li&gt;
&lt;li&gt;根据情况更新&lt;code&gt;needBytesNum&lt;/code&gt;字段&lt;/li&gt;
&lt;li&gt;将新生成的&lt;code&gt;listener&lt;/code&gt;实例按照优先级放入&lt;code&gt;lns&lt;/code&gt;字段对应的slice中&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来是&lt;code&gt;ListenHttp&lt;/code&gt;和&lt;code&gt;ListenHttps&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (mux *Mux) ListenHttp(priority int) net.Listener {
    return mux.Listen(priority, HttpNeedBytesNum, HttpMatchFunc)
}

func (mux *Mux) ListenHttps(priority int) net.Listener {
    return mux.Listen(priority, HttpsNeedBytesNum, HttpsMatchFunc)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个差不多，所以放到一起说，基本都是专门写了一个方法让我们能方便的创建处理&lt;code&gt;Http&lt;/code&gt;或者&lt;code&gt;Https&lt;/code&gt;的&lt;code&gt;listener&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;再来看&lt;code&gt;DefaultListener&lt;/code&gt;方法:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (mux *Mux) DefaultListener() net.Listener {
    mux.mu.Lock()
    defer mux.mu.Unlock()
    if mux.defaultLn == nil {
        mux.defaultLn = &amp;amp;listener{
            c:   make(chan net.Conn),
            mux: mux,
        }
    }
    return mux.defaultLn
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法很简单，基本就是有则返回没有则生成然后返回的套路。不过我们要注意&lt;code&gt;defaultLn&lt;/code&gt;字段中的&lt;code&gt;listener&lt;/code&gt;是不放入&lt;code&gt;lns&lt;/code&gt;字段中的。&lt;/p&gt;
&lt;p&gt;接下来是&lt;code&gt;Server&lt;/code&gt;方法：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Serve handles connections from ln and multiplexes then across registered listeners.
func (mux *Mux) Serve() error {
    for {
        // Wait for the next connection.
        // If it returns a temporary error then simply retry.
        // If it returns any other error then exit immediately.
        conn, err := mux.ln.Accept()
        if err, ok := err.(interface {
            Temporary() bool
        }); ok &amp;amp;&amp;amp; err.Temporary() {
            continue
        }

        if err != nil {
            return err
        }

        go mux.handleConn(conn)
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;一般来说，当我们调用&lt;code&gt;NewMux&lt;/code&gt;函数以后，接下来就会调用&lt;code&gt;Server&lt;/code&gt;方法，该方法基本上就是阻塞监听某个套接字，当有连接建立成功后立即另起一个goroutine调用&lt;code&gt;handleConn&lt;/code&gt;方法；当连接建立失败根据&lt;code&gt;err&lt;/code&gt;是否含有&lt;code&gt;Temporary&lt;/code&gt;方法，如果有则执行并忽略错误，没有则返回错误。&lt;/p&gt;
&lt;p&gt;现在我们看看&lt;code&gt;handleConn&lt;/code&gt;方法干了些啥:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (mux *Mux) handleConn(conn net.Conn) {
    // 1
    mux.mu.RLock()
    maxNeedBytesNum := mux.maxNeedBytesNum
    lns := mux.lns
    defaultLn := mux.defaultLn
    mux.mu.RUnlock()
    
    // 2
    sharedConn, rd := gnet.NewSharedConnSize(conn, int(maxNeedBytesNum))
    data := make([]byte, maxNeedBytesNum)

    conn.SetReadDeadline(time.Now().Add(DefaultTimeout))
    _, err := io.ReadFull(rd, data)
    if err != nil {
        conn.Close()
        return
    }
    conn.SetReadDeadline(time.Time{})
    // 3
    for _, ln := range lns {
        if match := ln.matchFn(data); match {
            err = errors.PanicToError(func() {
                ln.c &amp;lt;- sharedConn
            })
            if err != nil {
                conn.Close()
            }
            return
        }
    }

    // No match listeners
    if defaultLn != nil {
        err = errors.PanicToError(func() {
            defaultLn.c &amp;lt;- sharedConn
        })
        if err != nil {
            conn.Close()
        }
        return
    }

    // No listeners for this connection, close it.
    conn.Close()
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;handleConn&lt;/code&gt;方法也不算复杂，大体可以分为三步：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;获取当前状态&lt;/li&gt;
&lt;li&gt;从&lt;code&gt;conn&lt;/code&gt;中读取数据，注意：&lt;code&gt;shareConn&lt;/code&gt;和&lt;code&gt;rd&lt;/code&gt;存在单向关系，如果从&lt;code&gt;rd&lt;/code&gt;中读取数据的话，数据也会复制一份放到&lt;code&gt;shareConn&lt;/code&gt;中，反过来就不成立了&lt;/li&gt;
&lt;li&gt;读取到的数据会被遍历，最终选出&lt;code&gt;与matchFunc&lt;/code&gt;匹配的最高优先级的&lt;code&gt;listener&lt;/code&gt;，并将&lt;code&gt;shareConn&lt;/code&gt;放入该&lt;code&gt;listener&lt;/code&gt;的&lt;code&gt;c&lt;/code&gt;字段中，如果没有匹配到则放到&lt;code&gt;defaultLn&lt;/code&gt;中的&lt;code&gt;c&lt;/code&gt;字段中，如果&lt;code&gt;defaultLn&lt;/code&gt;是&lt;code&gt;nil&lt;/code&gt;的话就不处理，直接关闭&lt;code&gt;conn&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;最后来到了&lt;code&gt;release&lt;/code&gt;方法了:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func (mux *Mux) release(ln *listener) bool {
    result := false
    mux.mu.Lock()
    defer mux.mu.Unlock()
    lns := mux.copyLns()

    for i, l := range lns {
        if l == ln {
            lns = append(lns[:i], lns[i+1:]...)
            result = true
            break
        }
    }
    mux.lns = lns
    return result
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;release方法意思很明确：把对应的&lt;code&gt;listener&lt;/code&gt;从&lt;code&gt;lns&lt;/code&gt;中移除，并把结果返回，整个过程有互斥锁，我们回到&lt;sup&gt;存疑1&lt;/sup&gt;，尽管有互斥锁，但在这种情况下：当某个goroutine运行到&lt;code&gt;handleConn&lt;/code&gt;已经执行到了第三阶段的开始状态(也就是还没有找到匹配的&lt;code&gt;listener&lt;/code&gt;)时，且&lt;code&gt;Go&lt;/code&gt;运行在多核状态下，当另一个goroutine运行完&lt;code&gt;listener&lt;/code&gt;的&lt;code&gt;Close&lt;/code&gt;方法时，这时就可能发生往一个已经关闭的&lt;code&gt;channel&lt;/code&gt;中send数据，但请注意&lt;code&gt;handleConn&lt;/code&gt;的第三步的这段代码:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;err = errors.PanicToError(func() { // 就是这里了
    ln.c &amp;lt;- sharedConn
})
if err != nil {
    conn.Close()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个&lt;code&gt;PanicToError&lt;/code&gt;是这样的：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func PanicToError(fn func()) (err error) {
    defer func() {
        if r := recover(); r != nil {
            err = fmt.Errorf(&quot;Panic error: %v&quot;, r)
        }
    }()

    fn()
    return
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;基本上就是执行了&lt;code&gt;recover&lt;/code&gt;然后将错误打印出来，结合下面的对err的判断，就会将send失败的conn关闭。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;code&gt;Mux&lt;/code&gt;中包含了一个初始监听器，基本上所有的事件(比如说新的连接建立，之所以叫事件是因为我实在想不出更精确的词语了)都起源于此&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listener&lt;/code&gt;实现了&lt;code&gt;net.Listener&lt;/code&gt;接口，可以作为二级监听器使用(比如传给&lt;code&gt;net/http.Server&lt;/code&gt;结构体的&lt;code&gt;Server&lt;/code&gt;方法进行处理)。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Mux&lt;/code&gt;包含了一个由&lt;code&gt;listener&lt;/code&gt;组成的有序slice，当有事件产生时就会遍历这个slice找出合适的&lt;code&gt;listener&lt;/code&gt;并将事件传给他。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;讲到这里基本上是完事了。整个&lt;code&gt;mux&lt;/code&gt;模块还是比较简单的，起码是由一个个简单的东西组合而成。那么一起来意淫一下整体流程吧。&lt;/p&gt;
&lt;p&gt;假如我要实现这么一个网络程序：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;绑定监听一个基于tcp的套接字&lt;/li&gt;
&lt;li&gt;我们允许其应用层可支持多个(比如说支持http https这两个吧，尽管http和https可以说是一个协议。。)，不同的应用层协议对应不同的处理函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;就这么两个很简单的要求，不难吧。&lt;/p&gt;
&lt;p&gt;那么我们一起来实现吧:&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;
type HandleFunc func(c net.Conn) (n int, err error) 

type MyServer struct {
    l net.Listener
    hFunc Handle
}

func (h *MyServer) Server() (err error) {
    for {
        conn, err := h.l.Accept()
        if err != nil {
            return
        }
        go h.hFunc(conn)
    }
}

func HandleHttp(c net.Conn)(n int, err error){
    n, err = c.Write([]byte(&quot;Get Off! Don't you know that it is not safe?&quot;))
}

func HandleHttps(c net.Conn)(n int, err error){
    n, err = c.Write([]byte(&quot;Get Off! Don't you know that this is more complicated than http?&quot;))
}


func main() (err error){
    ln, err := net.Listen(&quot;tcp&quot;, &quot;0.0.0.0:12345&quot;)
    if err != nil {
        err = fmt.Errorf(&quot;Create server listener error, %v&quot;, err)
        return
    }
    muxer = mux.NewMux(ln)
    
    var lHttp, lHttps net.Listener
    lHttp = muxer.ListenHttp(1)
    httpServer := *MyServer{lHttp, HandleHttp}
    
    lHttps = muxer.ListenHttps(2)
    httpsServer := *MyServer{lHttps, HandleHttps}
    
    go httpServer.Server()
    go httpsServer.Server()

    err = muxer.Serve()
}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Mon, 01 Apr 2019 15:04:00 +0000</pubDate>
<dc:creator>MnCu</dc:creator>
<og:description>前言 frp几乎所有的连接处理都是构建在mux模块之上的，重要性不必多说，来看一下这是个啥吧 ps: 安装方法 该模块很小，不到300行，分为两个文件： 和`rule.go`。 因为 文件相对简单一些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MnCu8261/p/10639897.html</dc:identifier>
</item>
<item>
<title>[NewLife.XCode]扩展属性（替代多表关联Join提升性能） - 大石头</title>
<link>http://www.cnblogs.com/nnhy/p/xcode_extend.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nnhy/p/xcode_extend.html</guid>
<description>&lt;p&gt;NewLife.XCode是一个有10多年历史的开源数据中间件，支持nfx/netstandard，由新生命团队(2002~2019)开发完成并维护至今，以下简称XCode。&lt;/p&gt;
&lt;p&gt;整个系列教程会大量结合示例代码和运行日志来进行深入分析，蕴含多年开发经验于其中，代表作有百亿级大数据实时计算项目。&lt;/p&gt;
&lt;p&gt;开源地址：&lt;a href=&quot;https://github.com/NewLifeX/X&quot; target=&quot;_blank&quot;&gt;https://github.com/NewLifeX/X &lt;/a&gt;（求star, 743+）&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;XCode不支持多表关联查询，单表查询利于优化以及分表分库，一切Join都可以借助扩展属性实现，配合缓存使用可以达到更好的效果！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;（XCode前期支持多表关联，直到2008年才正式废除）&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;“扩展属性”是2007年起XCode特有叫法，不同于其它任何场景的意义（如Silverlight/WPF）&lt;/p&gt;

&lt;p&gt;前文&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html&quot; target=&quot;_blank&quot;&gt;《实体类详解》&lt;/a&gt;中有提到一个学生班级的实体类模型，一个典型需求是查询学生列表时希望暂时班级名称或者其它信息。于是有：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;select&lt;/span&gt; s.&lt;span&gt;*&lt;/span&gt;, c.name &lt;span&gt;where&lt;/span&gt; student s &lt;span&gt;left&lt;/span&gt; &lt;span&gt;join&lt;/span&gt; class c &lt;span&gt;on&lt;/span&gt; s.classid&lt;span&gt;=&lt;/span&gt;c.id
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;sql语法千变万化，如果要支持多表关联join，就很难做到统一查询风格，更是难以优化。&lt;/p&gt;
&lt;p&gt;于是XCode放弃支持多表关联，宁可拆分为多次查询。令人惊讶的是，不仅性能没有下降，反而大大提升了，主要因为单表小查询有多级缓存的加持！&lt;/p&gt;


&lt;p&gt;使用扩展属性来实现关联查询，本质上就是多次查询！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190401220650886-1686847874.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，这是一个经典的多表关联场景，学生表带有班级ID字段，同样还有产品和分类表等等。&lt;/p&gt;
&lt;p&gt;这是XCode根据模型文件自动生成的代码，因为字段名ClassID刚好是Class表加上它的主键ID，并且都是整型。&lt;/p&gt;
&lt;p&gt;对于实体对象来说，student.Name是学生名称，student.ClassName是班级名称。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;看起来它们就像是一张表的属性字段，这就是扩展属性的由来，不仅仅是多表关联属性，还可以是其它属性，为区别于数据字段属性，统称为扩展属性！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;扩展属性先准备一个Class属性，再加一个ClassName，主要是为了方便某些场合使用 student.Class。&lt;/p&gt;
&lt;p&gt;当然，执行一次查询得到student后，不论是访问student.Class还是访问student.ClassName，都会触发一次Class.FindByID，可以理解为执行一次查询（不一定是数据库）。&lt;/p&gt;
&lt;p&gt;在Web页面上，如果每页显示20个学生，那么先要执行 select * from student limit 20，然后展示学生列表时，因为需要班级名称，触发扩展属性查询。&lt;/p&gt;
&lt;p&gt;可以认为，理论上这个页面需要查询1+20次。&lt;/p&gt;

&lt;p&gt;扩展属性为什么不写成 public Class Class =&amp;gt; Class.FindByID(ClassID) 呢？&lt;/p&gt;
&lt;p&gt;其实虽然看起来简单，但是还得考虑一个可能，同一个student对象可能多次访问student.ClassName，这么写岂不是每次访问都会执行Class.FindByID？&lt;/p&gt;
&lt;p&gt;因此，XCode设计了扩展集合Extends，可以认为是一个字典，每个扩展属性都经过它走一遭，如果查询过一次就缓存起来，避免反复查询。&lt;/p&gt;
&lt;p&gt;Extends.Get第一个属性是扩展属性名，决定是否有缓存，第二个是没有缓存时要执行的委托。&lt;/p&gt;
&lt;p&gt;这就是扩展属性缓存，默认缓存时间10秒，足够抗住短期内成千上万次重复调用。&lt;/p&gt;


&lt;p&gt;尽管有Extends扩展属性缓存支持，但每个对象还是要执行一次Class.FindByID查询，损耗还是不小的。&lt;/p&gt;
&lt;p&gt;在XCode里面，根据主键而设计的查询（如FindByID）往往带有很好的缓存优化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190401222840449-878153953.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上，这是XCode默认生成的代码，当Class表数据不足1000行时，走实体缓存。&lt;/p&gt;
&lt;p&gt;也就是说，Meta.Cache时执行一次 select * from student 返回所有行，并缓存起来。后面的Find实际上是在缓存中查找。实体缓存有效期默认10秒。&lt;/p&gt;
&lt;p&gt;只有数据表达到1000行，才走 Find(_.ID==id) 数据库查询 select * from class where id=? 。然而XCode下层还有一个数据层缓存，相同select查询默认缓存10秒&lt;/p&gt;
&lt;p&gt;此外，也可以根据业务特点采用单对象缓存，例如跨境电商的产品种类特别多（10万+），可以采用字典式的单对象缓存。&lt;/p&gt;

&lt;p&gt;因此，在学生类那边看起来访问属性会触发多次Class.FindByID，殊不知它内部别有洞天，三级缓存（实体缓存、对象缓存、数据缓存）等着伺候！（后续专文介绍缓存）&lt;/p&gt;

&lt;p&gt;回到开头的例子，一个列表页显示20个学生，理论查询次数1+20次，在多级缓存加持的扩展属性下，99.99%的时候只会查询1次，而班级表的关联，完全在内存缓存中进行。&lt;/p&gt;
&lt;p&gt;一次简单的单表查询，显然要比join班级表的查询要快得多！&lt;/p&gt;


&lt;p&gt;在上述扩展属性中，注意到ClassName属性上有一个Map特性。&lt;/p&gt;
&lt;p&gt;它表示映射，本对象的ClassID字段，映射到Class类的ID字段。&lt;/p&gt;
&lt;p&gt;在魔方列表页中，本来显示冷冰冰ClassID的地方，就会变为显示友好的ClassName。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190401224441197-814418010.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在魔方表单页中，本来显示数字框ClassID的地方，也会变成显示下拉列表框。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190401224520001-1814489048.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果下拉列表库内容很多，可以精简Map特性，只要第一个参数指明本地字段，而不需要第二第三字段表示的目标字段。此时在魔方表单页会显示数字框，但是后面显示ClassName&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/19592/201904/19592-20190401224601176-1568398835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;到此，你还认为多次查询一定比单次Join慢吗？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;NewLife.XCode教程系列[2019版]&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd.html&quot; target=&quot;_blank&quot;&gt;增删改查入门&lt;/a&gt;。快速展现用法，代码配置连接字符串&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_model.html&quot; target=&quot;_blank&quot;&gt;数据模型文件&lt;/a&gt;。建立表格字段和索引，名字以及数据类型规范，推荐字段（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entity.html&quot; target=&quot;_blank&quot;&gt;实体类详解&lt;/a&gt;。数据类业务类，泛型基类，接口&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_setting.html&quot; target=&quot;_blank&quot;&gt;功能设置&lt;/a&gt;。连接字符串，调试开关，SQL日志，慢日志，参数化，执行超时。代码与配置文件设置，连接字符串局部设置&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_negative.html&quot; target=&quot;_blank&quot;&gt;反向工程&lt;/a&gt;。自动建立数据库数据表&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_initdata.html&quot; target=&quot;_blank&quot;&gt;数据初始化&lt;/a&gt;。InitData写入初始化数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_curd_adv.html&quot; target=&quot;_blank&quot;&gt;高级增删改&lt;/a&gt;。重载拦截，自增字段，Valid验证，实体模型（时间，用户，IP）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dirty.html&quot; target=&quot;_blank&quot;&gt;脏数据&lt;/a&gt;。如何产生，怎么利用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_additional.html&quot; target=&quot;_blank&quot;&gt;增量累加&lt;/a&gt;。高并发统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_transaction.html&quot; target=&quot;_blank&quot;&gt;事务处理&lt;/a&gt;。单表和多表，不同连接，多种写法&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_extend.html&quot; target=&quot;_blank&quot;&gt;扩展属性&lt;/a&gt;。多表关联，Map映射&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_search.html&quot; target=&quot;_blank&quot;&gt;高级查询&lt;/a&gt;。复杂条件，分页，自定义扩展FieldItem，查总记录数，查汇总统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_dbcache.html&quot; target=&quot;_blank&quot;&gt;数据层缓存&lt;/a&gt;。Sql缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_entitycache.html&quot; target=&quot;_blank&quot;&gt;实体缓存&lt;/a&gt;。全表整理缓存，更新机制&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_singlecache.html&quot; target=&quot;_blank&quot;&gt;对象缓存&lt;/a&gt;。字典缓存，适用用户等数据较多场景。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_100billion.html&quot; target=&quot;_blank&quot;&gt;百亿级性能&lt;/a&gt;。字段精炼，索引完备，合理查询，充分利用缓存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_factory.html&quot; target=&quot;_blank&quot;&gt;实体工厂&lt;/a&gt;。元数据，通用处理程序&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_membership.html&quot; target=&quot;_blank&quot;&gt;角色权限&lt;/a&gt;。Membership&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_import_export.html&quot; target=&quot;_blank&quot;&gt;导入导出&lt;/a&gt;。Xml，Json，二进制，网络或文件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_division.html&quot; target=&quot;_blank&quot;&gt;分表分库&lt;/a&gt;。常见拆分逻辑&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_stat.html&quot; target=&quot;_blank&quot;&gt;高级统计&lt;/a&gt;。聚合统计，分组统计&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_batch.html&quot; target=&quot;_blank&quot;&gt;批量写入&lt;/a&gt;。批量插入，批量Upsert，异步保存&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_queue.html&quot; target=&quot;_blank&quot;&gt;实体队列&lt;/a&gt;。写入级缓存，提升性能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_backup.html&quot; target=&quot;_blank&quot;&gt;备份同步&lt;/a&gt;。备份数据，恢复数据，同步数据&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_service.html&quot; target=&quot;_blank&quot;&gt;数据服务&lt;/a&gt;。提供RPC接口服务，远程执行查询，例如SQLite网络版&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/nnhy/p/xcode_bigdata.html&quot; target=&quot;_blank&quot;&gt;大数据分析&lt;/a&gt;。ETL抽取，调度计算处理，结果持久化&lt;/li&gt;
&lt;/ol&gt;
</description>
<pubDate>Mon, 01 Apr 2019 14:47:00 +0000</pubDate>
<dc:creator>大石头</dc:creator>
<og:description>XCode不支持多表关联查询，单表查询利于优化以及分表分库，一切Join都可以借助扩展属性实现，配合缓存使用可以达到更好的效果！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nnhy/p/xcode_extend.html</dc:identifier>
</item>
<item>
<title>工程实践：让变量命名做到&quot;自解释&quot; - Matrix海子</title>
<link>http://www.cnblogs.com/dolphin0520/p/10639167.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dolphin0520/p/10639167.html</guid>
<description>&lt;p&gt;工程实践：让变量命名做到&quot;自解释&quot;&lt;/p&gt;
&lt;p&gt;　　在上一篇文章中跟大家分享了关于函数命名的一些实践心得，今天我们继续命名这个话题，来讲一讲如何对变量命名。&lt;/p&gt;
&lt;p&gt;　　以下是本文的目录大纲：&lt;/p&gt;
&lt;p&gt;　　一. 变量命名风格&lt;/p&gt;
&lt;p&gt;　　二. 变量命名最高境界&lt;/p&gt;
&lt;p&gt;　　三. 变量命名最佳实践&lt;/p&gt;
&lt;p&gt;　　若有不正之处请多多谅解，并欢迎批评指正。&lt;/p&gt;
&lt;p&gt;　　请尊重作者劳动成果，转载请标明原文链接：&lt;/p&gt;
&lt;p&gt;    　https://www.cnblogs.com/dolphin0520/p/10639167.html&lt;/p&gt;

&lt;h2&gt;一.变量命名风格&lt;/h2&gt;
&lt;p&gt;　　变量命名风格通常会根据不同的变量类型来区分，以Java语言为例，根据变量类型不同有两种命名风格：&lt;/p&gt;
&lt;p&gt;1）类成员变量、局部变量&lt;/p&gt;
&lt;p&gt;　　类成员变量、局部变量通常采用&lt;strong&gt;驼峰命名&lt;/strong&gt;风格，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
String userName;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2）静态成员变量、枚举值、常量&lt;/p&gt;
&lt;p&gt;　　静态成员变量、枚举值、常量通常采用&lt;strong&gt;所有字母大写、多个单词以英文下划线连接&lt;/strong&gt;，如：&lt;/p&gt;

&lt;h2&gt;二.变量命名最高境界&lt;/h2&gt;
&lt;p&gt;　　在函数命名那篇中我们说的函数命名最高境界是见字如面，那么对于变量命名来说，最高境界是什么呢？ 我认为是：自解释，即&quot;代码即注释&quot;。&lt;/p&gt;
&lt;p&gt;　　为什么这么说呢，因为通常来说一个函数是会有函数注释的，即使函数名字取的不好，如果注释写的比较清楚，对于后续维护人员来说也是了解函数具体功能的一种方式。&lt;/p&gt;
&lt;p&gt;　　而变量则不同，在一个工程里面，变量的数量远远大于函数的数量，所以不太可能对于每个变量都去写注释，所以如果一个工程的变量命名很糟糕，那么对于后续维护人员来说将是毁灭性的打击，因为每读到一个变量，可能就需要去猜测变量的含义，我想没有哪个人愿意读到这样的代码，永远记住一点：&quot;代码是写给人看的，不是写给机器看的&quot;。&lt;/p&gt;
&lt;p&gt;　　譬如下面这段代码的命名就非常糟糕：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
ppn = (cpn &amp;gt; 1) ? (cpn - 1) : cpn;
npn = (cpn &amp;lt; tpn) ? (cpn + 1) : tpn;
​
p = new Page(ppn, cpn, npn, tpn);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上面这段代码估计只有原作者清楚地知道各个变量的含义是啥了，&lt;/p&gt;
&lt;p&gt;　　如果修改为下面这种写法，可读性会好很多，并且一目了然，很容易知道其大概意图是计算分页信息：&lt;/p&gt;

&lt;h2&gt;三.变量命名最佳实践&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1）采用名词或者形容词来命名变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　变量一般情况下建议使用名词、名字组合或者形容词，因为变量一般形容的是一种事物或者事物的属性，所以用名词或者名词组合更容易让人理解，而形容词一般用于bool类型的变量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2）避免使用单字母变量，尽量细化变量含义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在程序中，尽量避免使用单字母变量，唯一可以接受使用单字母变量的场景只有for循环，不过还是不太推荐在for循环中使用单字母变量(用pos、index比for循环的i、j、k要好很多)。&lt;/p&gt;
&lt;p&gt;　　举个例子，比如下面这行代码：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3）变量命名前后用词需统一&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在同一个工程或者一个场景下，变量命名风格需前后统一，比如total和sum都能表示总计的意思，那么所有需要用到&quot;总计&quot;含义的地方要么全部使用total、要么全部使用sum。&lt;/p&gt;
&lt;p&gt;　　保持前后命名风格统一是保证工程代码良好可读性的关键保证。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4）集合变量用类型或者复数s作为后缀&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在java中，有很多集合，比如List、Map、Set等，那么集合变量该怎么命名呢？&lt;/p&gt;
&lt;p&gt;　　一般可采取两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;使用复数s结尾&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
List&amp;lt;Student&amp;gt; students = new ArrayList&amp;lt;&amp;gt;();
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　上面两种方式均可，没有比较明显的偏好，根据实际场景决定。第一种方式相对更简洁，第二种在局部作用域里面有多种相关的集合变量时区分度更大，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
List&amp;lt;Student&amp;gt; studentList = new ArrayList&amp;lt;&amp;gt;();
Map&amp;lt;Long, Student&amp;gt; studentMap = Maps.newHashMap();
​
for (Student stu : studentList) {
  studentMap.put(stu.getId, stu);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　我的建议是如果局部作用域只有一种类型的集合，那么推荐使用复数形式；如果局部作用域有多个相关的集合类型，那么推荐用类型结尾。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5）禁止使用is作为bool类型的类成员变量前置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　在java中，禁止用is作为bool类型的类成员变量的前缀，因为is作为前缀会导致序列化/反序列出现问题，阿里的java代码规范中也明确提到了这一点，所以在写代码的时候最好还是遵守公认的规范，不然哪天说不定就踩坑了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6）尽量避免使用缩写进行命名&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　有些时候，变量名可能有点长，不利于代码可读性，因此很多时候在写代码的时候喜欢用缩写来命名，但这个不是一个好的习惯，除非使用的缩写是大家都会使用的约定俗称的缩写。&lt;/p&gt;
&lt;p&gt;　　比如下面这个命名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int averageStudentAge;  =&amp;gt;  int avgStudentAge;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　因为avg大家都知道是average的缩写，所以这么写问题不大，不会引起歧义；&lt;/p&gt;
&lt;p&gt;　　但是下面这种缩写命名：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
res
tmp
cnt
dep
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　就不是好的缩写命名，因为不同的人阅读可能会有不同的理解：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
res =&amp;gt; response、resource、result
tmp =&amp;gt; temporary、template
cnt =&amp;gt; count、content、context
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　附上一些约定俗称的缩写：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;全称&lt;/td&gt;
&lt;td&gt;缩写&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;identification&lt;/td&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;average&lt;/td&gt;
&lt;td&gt;avg&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;maximum&lt;/td&gt;
&lt;td&gt;max&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;minimum&lt;/td&gt;
&lt;td&gt;min&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;buffer&lt;/td&gt;
&lt;td&gt;buf&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;err&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;message&lt;/td&gt;
&lt;td&gt;msg&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;image&lt;/td&gt;
&lt;td&gt;img&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;length&lt;/td&gt;
&lt;td&gt;len&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;library&lt;/td&gt;
&lt;td&gt;lib&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;password&lt;/td&gt;
&lt;td&gt;pwd&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;position&lt;/td&gt;
&lt;td&gt;pos&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;data transfer object&lt;/td&gt;
&lt;td&gt;dto&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;view object&lt;/td&gt;
&lt;td&gt;vo&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;7）抛弃掉flag变量&lt;/p&gt;
&lt;p&gt;　　国内一些早期的教材上，到处充斥着各种flag风格的变量，这种命名方式对于大型工程简直就是噩梦，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
int flag = getDoctorFlag(doctorId);
if (flag == 1) {
  //....
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看到这段代码，读者会有疑问flag变量的含义是什么？flag值为1的时候又代表什么含义？是医生的值班/在岗状态、还是医生的身体状态？估计读者的内心是崩溃的。&lt;/p&gt;
&lt;p&gt;　　如果优化成下面这种形式：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
DutyStatus doctorDutyStatus = getDoctorDutyStatus(doctorId);
if (doctorDutyStatus == DutyStatus.ONLINE) {
  // ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　就比上面的形式清晰多了，很容易看出来判断的是医生的值班/在岗状态。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 14:34:00 +0000</pubDate>
<dc:creator>Matrix海子</dc:creator>
<og:description>工程实践：让变量命名做到&quot;自解释&quot; 在上一篇文章中跟大家分享了关于函数命名的一些实践心得，今天我们继续命名这个话题，来讲一讲如何对变量命名。 以下是本文的目录大纲： 一. 变量命名</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dolphin0520/p/10639167.html</dc:identifier>
</item>
<item>
<title>深度解密Go语言之Slice - Stefno</title>
<link>http://www.cnblogs.com/qcrao-2018/p/10631989.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qcrao-2018/p/10631989.html</guid>
<description>&lt;p&gt;Go 语言的 &lt;code&gt;slice&lt;/code&gt; 很好用，不过也有一些坑。&lt;code&gt;slice&lt;/code&gt; 是 Go 语言一个很重要的数据结构。网上已经有很多文章写过了，似乎没必要再写。但是每个人看问题的视角不同，写出来的东西自然也不一样。我这篇会从更底层的汇编语言去解读它。而且在我写这篇文章的过程中，发现绝大部分文章都存在一些问题，文章里会讲到，这里先不展开。&lt;/p&gt;
&lt;p&gt;我希望本文可以终结这个话题，下次再有人想和你讨论 &lt;code&gt;slice&lt;/code&gt;，直接把这篇文章的链接丢过去就行了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;slice&lt;/code&gt; 翻译成中文就是&lt;code&gt;切片&lt;/code&gt;，它和&lt;code&gt;数组（array）&lt;/code&gt;很类似，可以用下标的方式进行访问，如果越界，就会产生 panic。但是它比数组更灵活，可以自动地进行扩容。&lt;/p&gt;
&lt;p&gt;了解 slice 的本质，最简单的方法就是看它的源代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// runtime/slice.go
type slice struct {
    array unsafe.Pointer // 元素指针
    len   int // 长度 
    cap   int // 容量
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到了吗，&lt;code&gt;slice&lt;/code&gt; 共有三个属性：&lt;br/&gt;&lt;code&gt;指针&lt;/code&gt;，指向底层数组；&lt;br/&gt;&lt;code&gt;长度&lt;/code&gt;，表示切片可用元素的个数，也就是说使用下标对 slice 的元素进行访问时，下标不能超过 slice 的长度；&lt;br/&gt;&lt;code&gt;容量&lt;/code&gt;，底层数组的元素个数，容量 &amp;gt;= 长度。在底层数组不进行扩容的情况下，容量也是 slice 可以扩张的最大限度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/55270142-876c2000-52d6-11e9-99e5-2e921fc2d430.png&quot; alt=&quot;切片数据结构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意，底层数组是可以被多个 slice 同时指向的，因此对一个 slice 的元素进行操作是有可能影响到其他 slice 的。&lt;/p&gt;

&lt;p&gt;创建 slice 的方式有以下几种：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;7&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;直接声明&lt;/td&gt;
&lt;td&gt;&lt;code&gt;var slice []int&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;new&lt;/td&gt;
&lt;td&gt;&lt;code&gt;slice := *new([]int)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;6&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;字面量&lt;/td&gt;
&lt;td&gt;&lt;code&gt;slice := []int{1,2,3,4,5}&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;4&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;make&lt;/td&gt;
&lt;td&gt;&lt;code&gt;slice := make([]int, 5, 10)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;从切片或数组“截取”&lt;/td&gt;
&lt;td&gt;&lt;code&gt;slice := array[1:5]&lt;/code&gt; 或 &lt;code&gt;slice := sourceSlice[1:5]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;直接声明&quot;&gt;直接声明&lt;/h2&gt;
&lt;p&gt;第一种创建出来的 slice 其实是一个 &lt;code&gt;nil slice&lt;/code&gt;。它的长度和容量都为0。和&lt;code&gt;nil&lt;/code&gt;比较的结果为&lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里比较混淆的是&lt;code&gt;empty slice&lt;/code&gt;，它的长度和容量也都为0，但是所有的空切片的数据指针都指向同一个地址 &lt;code&gt;0xc42003bda0&lt;/code&gt;。空切片和 &lt;code&gt;nil&lt;/code&gt; 比较的结果为&lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;它们的内部结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54864985-ac720780-4d99-11e9-8386-68ef68880c8d.png&quot; alt=&quot;nil slice 与 empty slice&quot;/&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;方式一&lt;/td&gt;
&lt;td&gt;var s1 []int&lt;/td&gt;
&lt;td&gt;var s2 = []int{}&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;方式二&lt;/td&gt;
&lt;td&gt;var s4 = *new([]int)&lt;/td&gt;
&lt;td&gt;var s3 = make([]int, 0)&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;长度&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;容量&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;和 &lt;code&gt;nil&lt;/code&gt; 比较&lt;/td&gt;
&lt;td&gt;&lt;code&gt;true&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;nil&lt;/code&gt; 切片和空切片很相似，长度和容量都是0，官方建议尽量使用 &lt;code&gt;nil&lt;/code&gt; 切片。&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;nil slice&lt;/code&gt;和&lt;code&gt;empty slice&lt;/code&gt;的探索可以参考公众号“码洞”作者老钱写的一篇文章《深度解析 Go 语言中「切片」的三种特殊状态》，地址附在了参考资料部分。&lt;/p&gt;
&lt;h2 id=&quot;字面量&quot;&gt;字面量&lt;/h2&gt;
&lt;p&gt;比较简单，直接用&lt;code&gt;初始化表达式&lt;/code&gt;创建。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    s1 := []int{0, 1, 2, 3, 8: 100}
    fmt.Println(s1, len(s1), cap(s1))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[0 1 2 3 0 0 0 0 100] 9 9&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;唯一值得注意的是上面的代码例子中使用了索引号，直接赋值，这样，其他未注明的元素则默认 &lt;code&gt;0 值&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;make&quot;&gt;make&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;make&lt;/code&gt;函数需要传入三个参数：切片类型，长度，容量。当然，容量可以不传，默认和长度相等。&lt;/p&gt;
&lt;p&gt;上篇文章&lt;a href=&quot;https://www.cnblogs.com/qcrao-2018/p/10562216.html&quot;&gt;《走进Go的底层》&lt;/a&gt;中，我们学到了汇编这个工具，这次我们再次请出汇编来更深入地看看&lt;code&gt;slice&lt;/code&gt;。如果没看过上篇文章，建议先回去看完，再继续阅读本文效果更佳。&lt;/p&gt;
&lt;p&gt;先来一小段玩具代码，使用 &lt;code&gt;make&lt;/code&gt; 关键字创建 &lt;code&gt;slice&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    slice := make([]int, 5, 10) // 长度为5，容量为10
    slice[2] = 2 // 索引为2的元素赋值为2
    fmt.Println(slice)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行如下命令，得到 Go 汇编代码：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;go tool compile -S main.go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们只关注main函数：&lt;/p&gt;
&lt;pre class=&quot;asm&quot;&gt;
&lt;code&gt;0x0000 00000 (main.go:5)TEXT    &quot;&quot;.main(SB), $96-0
0x0000 00000 (main.go:5)MOVQ    (TLS), CX
0x0009 00009 (main.go:5)CMPQ    SP, 16(CX)
0x000d 00013 (main.go:5)JLS     228
0x0013 00019 (main.go:5)SUBQ    $96, SP
0x0017 00023 (main.go:5)MOVQ    BP, 88(SP)
0x001c 00028 (main.go:5)LEAQ    88(SP), BP
0x0021 00033 (main.go:5)FUNCDATA    $0, gclocals·69c1753bd5f81501d95132d08af04464(SB)
0x0021 00033 (main.go:5)FUNCDATA    $1, gclocals·57cc5e9a024203768cbab1c731570886(SB)
0x0021 00033 (main.go:5)LEAQ    type.int(SB), AX
0x0028 00040 (main.go:6)MOVQ    AX, (SP)
0x002c 00044 (main.go:6)MOVQ    $5, 8(SP)
0x0035 00053 (main.go:6)MOVQ    $10, 16(SP)
0x003e 00062 (main.go:6)PCDATA  $0, $0
0x003e 00062 (main.go:6)CALL    runtime.makeslice(SB)
0x0043 00067 (main.go:6)MOVQ    24(SP), AX
0x0048 00072 (main.go:6)MOVQ    32(SP), CX
0x004d 00077 (main.go:6)MOVQ    40(SP), DX
0x0052 00082 (main.go:7)CMPQ    CX, $2
0x0056 00086 (main.go:7)JLS     221
0x005c 00092 (main.go:7)MOVQ    $2, 16(AX)
0x0064 00100 (main.go:8)MOVQ    AX, &quot;&quot;..autotmp_2+64(SP)
0x0069 00105 (main.go:8)MOVQ    CX, &quot;&quot;..autotmp_2+72(SP)
0x006e 00110 (main.go:8)MOVQ    DX, &quot;&quot;..autotmp_2+80(SP)
0x0073 00115 (main.go:8)MOVQ    $0, &quot;&quot;..autotmp_1+48(SP)
0x007c 00124 (main.go:8)MOVQ    $0, &quot;&quot;..autotmp_1+56(SP)
0x0085 00133 (main.go:8)LEAQ    type.[]int(SB), AX
0x008c 00140 (main.go:8)MOVQ    AX, (SP)
0x0090 00144 (main.go:8)LEAQ    &quot;&quot;..autotmp_2+64(SP), AX
0x0095 00149 (main.go:8)MOVQ    AX, 8(SP)
0x009a 00154 (main.go:8)PCDATA  $0, $1
0x009a 00154 (main.go:8)CALL    runtime.convT2Eslice(SB)
0x009f 00159 (main.go:8)MOVQ    16(SP), AX
0x00a4 00164 (main.go:8)MOVQ    24(SP), CX
0x00a9 00169 (main.go:8)MOVQ    AX, &quot;&quot;..autotmp_1+48(SP)
0x00ae 00174 (main.go:8)MOVQ    CX, &quot;&quot;..autotmp_1+56(SP)
0x00b3 00179 (main.go:8)LEAQ    &quot;&quot;..autotmp_1+48(SP), AX
0x00b8 00184 (main.go:8)MOVQ    AX, (SP)
0x00bc 00188 (main.go:8)MOVQ    $1, 8(SP)
0x00c5 00197 (main.go:8)MOVQ    $1, 16(SP)
0x00ce 00206 (main.go:8)PCDATA  $0, $1
0x00ce 00206 (main.go:8)CALL    fmt.Println(SB)
0x00d3 00211 (main.go:9)MOVQ    88(SP), BP
0x00d8 00216 (main.go:9)ADDQ    $96, SP
0x00dc 00220 (main.go:9)RET
0x00dd 00221 (main.go:7)PCDATA  $0, $0
0x00dd 00221 (main.go:7)CALL    runtime.panicindex(SB)
0x00e2 00226 (main.go:7)UNDEF
0x00e4 00228 (main.go:7)NOP
0x00e4 00228 (main.go:5)PCDATA  $0, $-1
0x00e4 00228 (main.go:5)CALL    runtime.morestack_noctxt(SB)
0x00e9 00233 (main.go:5)JMP     0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先说明一下，Go 语言汇编 &lt;code&gt;FUNCDATA&lt;/code&gt; 和 &lt;code&gt;PCDATA&lt;/code&gt; 是编译器产生的，用于保存一些和垃圾收集相关的信息，我们先不用 care。&lt;/p&gt;
&lt;p&gt;以上汇编代码行数比较多，没关系，因为命令都比较简单，而且我们的 Go 源码也足够简单，没有理由看不明白。&lt;/p&gt;
&lt;p&gt;我们先从上到下扫一眼，看到几个关键函数：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;CALL    runtime.makeslice(SB)
CALL    runtime.convT2Eslice(SB)
CALL    fmt.Println(SB)
CALL    runtime.morestack_noctxt(SB)&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;创建slice&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;类型转换&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;打印函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;栈空间扩容&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;1&lt;/code&gt;是创建 slice 相关的；&lt;code&gt;2&lt;/code&gt;是类型转换；调用 &lt;code&gt;fmt.Println&lt;/code&gt;需要将 slice 作一个转换； &lt;code&gt;3&lt;/code&gt;是打印语句；&lt;code&gt;4&lt;/code&gt;是栈空间扩容函数，在函数开始处，会检查当前栈空间是否足够，不够的话需要调用它来进行扩容。暂时可以忽略。&lt;/p&gt;
&lt;p&gt;调用了函数就会涉及到参数传递，Go 的参数传递都是通过 栈空间完成的。接下来，我们详细分析这整个过程。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;11&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;code&gt;main&lt;/code&gt;函数定义，栈帧大小为 &lt;code&gt;96B&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;3&quot;&gt;&lt;td&gt;2-4&lt;/td&gt;
&lt;td&gt;判断栈是否需要进行扩容，如果需要则跳到 &lt;code&gt;228&lt;/code&gt;，这里会调用 &lt;code&gt;runtime.morestack_noctxt(SB)&lt;/code&gt; 进行栈扩容操作。具体细节后续还会有文章来讲&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;5-9&lt;/td&gt;
&lt;td&gt;将 &lt;code&gt;caller BP&lt;/code&gt; 压栈，具体细节后面会讲到&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;10-15&lt;/td&gt;
&lt;td&gt;调用 &lt;code&gt;runtime.makeslice(SB)&lt;/code&gt; 函数及准备工作。*_type表示的是 &lt;code&gt;int&lt;/code&gt;，也就是 &lt;code&gt;slice&lt;/code&gt; 元素的类型。这里对应的源码是第6行，也就是调用 &lt;code&gt;make&lt;/code&gt; 创建 &lt;code&gt;slice&lt;/code&gt; 的那一行。&lt;code&gt;5&lt;/code&gt; 和 &lt;code&gt;10&lt;/code&gt; 分别代表长度和容量，函数参数会在栈顶准备好，之后执行函数调用命令 &lt;code&gt;CALL&lt;/code&gt;，进入到被调用函数的栈帧，就会按顺序从 &lt;code&gt;caller&lt;/code&gt; 的栈顶取函数参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;16-18&lt;/td&gt;
&lt;td&gt;接收 &lt;code&gt;makeslice&lt;/code&gt;的返回值，通过 &lt;code&gt;move&lt;/code&gt; 移动到寄存器中&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;5&quot;&gt;&lt;td&gt;19-21&lt;/td&gt;
&lt;td&gt;给数组索引值为 &lt;code&gt;2&lt;/code&gt; 的元素赋上值 &lt;code&gt;2&lt;/code&gt;，因为是 &lt;code&gt;int&lt;/code&gt; 型的 &lt;code&gt;slice&lt;/code&gt;，元素大小为8字节，所以 &lt;code&gt;MOVQ $2, 16(AX)&lt;/code&gt; 此命令就是将 &lt;code&gt;2&lt;/code&gt; 搬到索引为 &lt;code&gt;2&lt;/code&gt; 的位置。这里还会对索引值的大小进行检查，如果越界，则会跳转到 &lt;code&gt;221&lt;/code&gt;，执行 &lt;code&gt;panic&lt;/code&gt; 函数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;22-26&lt;/td&gt;
&lt;td&gt;分别通过寄存器 &lt;code&gt;AX，CX，DX&lt;/code&gt; 将 &lt;code&gt;makeslice&lt;/code&gt; 的返回值 &lt;code&gt;move&lt;/code&gt; 到内存的其他位置，也称为局部变量，这样就构造出了 &lt;code&gt;slice&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54982728-5fcf3c00-4fe6-11e9-819b-9c5b45cc93bf.png&quot; alt=&quot;makeslice 栈帧&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左边是栈上的数据，右边是堆上的数据。&lt;code&gt;array&lt;/code&gt; 指向 &lt;code&gt;slice&lt;/code&gt; 的底层数据，被分配到堆上了。注意，栈上的地址是从高向低增长；堆则从低向高增长。栈左边的数字表示对应的汇编代码的行数，栈右边箭头则表示栈地址。（48）SP、（56）SP 表示的内容接着往下看。&lt;/p&gt;
&lt;p&gt;注意，在图中，栈地址是从下往上增长，所以 SP 表示的是图中 &lt;code&gt;*_type&lt;/code&gt; 所在的位置，其它的依此类推。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;27-32&lt;/td&gt;
&lt;td&gt;准备调用 &lt;code&gt;runtime.convT2Eslice(SB)&lt;/code&gt;的函数参数&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;33-36&lt;/td&gt;
&lt;td&gt;接收返回值，通过AX，CX寄存器 &lt;code&gt;move&lt;/code&gt; 到(48)SP、（56）SP&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;code&gt;convT2Eslice&lt;/code&gt; 的函数声明如下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func convT2Eslice(t *_type, elem unsafe.Pointer) (e eface) &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一个参数是指针 &lt;code&gt;*_type&lt;/code&gt;，&lt;code&gt;_type&lt;/code&gt;是一个表示类型的结构体，这里传入的就是 &lt;code&gt;slice&lt;/code&gt;的类型 &lt;code&gt;[]int&lt;/code&gt;；第二个参数则是元素的指针，这里传入的就是 &lt;code&gt;slice&lt;/code&gt; 底层数组的首地址。&lt;/p&gt;
&lt;p&gt;返回值 &lt;code&gt;eface&lt;/code&gt; 的结构体定义如下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;type eface struct {
    _type *_type
    data  unsafe.Pointer
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于我们会调用 &lt;code&gt;fmt.Println(slice)&lt;/code&gt;，看下函数原型：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func Println(a ...interface{}) (n int, err error)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Println&lt;/code&gt; 接收 interface 类型，因此我们需要将 &lt;code&gt;slice&lt;/code&gt; 转换成 interface 类型。由于 &lt;code&gt;slice&lt;/code&gt; 没有方法，是个“&lt;code&gt;空 interface&lt;/code&gt;”。因此会调用 &lt;code&gt;convT2Eslice&lt;/code&gt; 完成这一转换过程。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;convT2Eslice&lt;/code&gt; 函数返回的是类型指针和数据地址。源码就不贴了，大体流程是：调用 &lt;code&gt;mallocgc&lt;/code&gt; 分配一块内存，把数据 &lt;code&gt;copy&lt;/code&gt; 进到新的内存，然后返回这块内存的地址，&lt;code&gt;*_type&lt;/code&gt; 则直接返回传入的参数。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/55271648-2d298a00-52eb-11e9-9dd0-e1bcc1fe33d0.png&quot; alt=&quot;convT2Eslice 栈帧&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;32(SP)&lt;/code&gt; 和 &lt;code&gt;40(SP)&lt;/code&gt; 其实是 &lt;code&gt;makeslice&lt;/code&gt; 函数的返回值，这里可以忽略。&lt;/p&gt;
&lt;p&gt;还剩 &lt;code&gt;fmt.Println(slice)&lt;/code&gt; 最后一个函数调用了，我们继续。&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;1.5&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;3&quot;&gt;&lt;td&gt;37-40&lt;/td&gt;
&lt;td&gt;准备 &lt;code&gt;Println&lt;/code&gt; 函数参数。共3个参数，第一个是类型地址，还有两个 &lt;code&gt;1&lt;/code&gt;，这块暂时还不知道为什么要传，有了解的同学可以在文章后面留言&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;所以调用 &lt;code&gt;fmt.Println(slice)&lt;/code&gt; 时，实际是传入了一个 &lt;code&gt;slice类型的eface地址&lt;/code&gt;。这样，&lt;code&gt;Println&lt;/code&gt;就可以访问类型中的数据，最终给“打印”出来。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/55271702-1f283900-52ec-11e9-9d3f-d8eb754ef23c.png&quot; alt=&quot;fmt.Println 栈帧&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，我们看下 &lt;code&gt;main&lt;/code&gt; 函数栈帧的开始和收尾部分。&lt;/p&gt;
&lt;pre class=&quot;asm&quot;&gt;
&lt;code&gt;0x0013 00019 (main.go:5)SUBQ    $96, SP
0x0017 00023 (main.go:5)MOVQ    BP, 88(SP)
0x001c 00028 (main.go:5)LEAQ    88(SP), BP
…………………………
0x00d3 00211 (main.go:9)MOVQ    88(SP), BP
0x00d8 00216 (main.go:9)ADDQ    $96, SP
RET&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;BP&lt;/code&gt;可以理解为保存了当前函数栈帧栈底的地址，&lt;code&gt;SP&lt;/code&gt;则保存栈顶的地址。&lt;/p&gt;
&lt;p&gt;初始，&lt;code&gt;BP&lt;/code&gt; 和 &lt;code&gt;SP&lt;/code&gt; 分别有一个初始状态。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt; 函数执行的时候，先根据 &lt;code&gt;main&lt;/code&gt; 函数栈帧大小确定 &lt;code&gt;SP&lt;/code&gt; 的新指向，使得 &lt;code&gt;main&lt;/code&gt; 函数栈帧大小达到 &lt;code&gt;96B&lt;/code&gt;。之后把老的 &lt;code&gt;BP&lt;/code&gt; 保存到 &lt;code&gt;main&lt;/code&gt; 函数栈帧的底部，并使 &lt;code&gt;BP&lt;/code&gt; 寄存器重新指向新的栈底，也就是 &lt;code&gt;main&lt;/code&gt; 函数栈帧的栈底。&lt;/p&gt;
&lt;p&gt;最后，当 &lt;code&gt;main&lt;/code&gt; 函数执行完毕，把它栈底的 &lt;code&gt;BP&lt;/code&gt; 给回弹回到 &lt;code&gt;BP&lt;/code&gt; 寄存器，恢复调用前的初始状态。一切都像是没有发生一样，完美的现场。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54874022-24821100-4e1e-11e9-805b-408c29b3c1c4.png&quot; alt=&quot;栈帧变化&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这部分，又详细地分析了一遍函数调用的过程。一方面，让大家复习一下上一篇文章讲的内容；另一方面，向大家展示如何找到 Go 中的一个函数背后真实调用了哪些函数。像例子中，我们就看到了 &lt;code&gt;make&lt;/code&gt; 函数背后，实际上是调用了 &lt;code&gt;makeslice&lt;/code&gt; 函数；还有一点，让大家对汇编不那么“惧怕”，可以轻松地分析一些东西。&lt;/p&gt;
&lt;h2 id=&quot;截取&quot;&gt;截取&lt;/h2&gt;
&lt;p&gt;截取也是比较常见的一种创建 slice 的方法，可以从数组或者 slice 直接截取，当然需要指定起止索引位置。&lt;/p&gt;
&lt;p&gt;基于已有 slice 创建新 slice 对象，被称为 &lt;code&gt;reslice&lt;/code&gt;。新 slice 和老 slice 共用底层数组，新老 slice 对底层数组的更改都会影响到彼此。基于数组创建的新 slice 对象也是同样的效果：对数组或 slice 元素作的更改都会影响到彼此。&lt;/p&gt;
&lt;p&gt;值得注意的是，新老 slice 或者新 slice 老数组互相影响的前提是两者共用底层数组，如果因为执行 &lt;code&gt;append&lt;/code&gt; 操作使得新 slice 底层数组扩容，移动到了新的位置，两者就不会相互影响了。所以，&lt;code&gt;问题的关键在于两者是否会共用底层数组&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;截取操作采用如下方式：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt; data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
 slice := data[2:4:6] // data[low, high, max]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对 &lt;code&gt;data&lt;/code&gt; 使用3个索引值，截取出新的 &lt;code&gt;slice&lt;/code&gt;。这里 &lt;code&gt;data&lt;/code&gt; 可以是数组或者 &lt;code&gt;slice&lt;/code&gt;。&lt;code&gt;low&lt;/code&gt; 是最低索引值，这里是闭区间，也就是说第一个元素是 &lt;code&gt;data&lt;/code&gt; 位于 &lt;code&gt;low&lt;/code&gt; 索引处的元素；而 &lt;code&gt;high&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 则是开区间，表示最后一个元素只能是索引 &lt;code&gt;high-1&lt;/code&gt; 处的元素，而最大容量则只能是索引 &lt;code&gt;max-1&lt;/code&gt; 处的元素。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;max &amp;gt;= high &amp;gt;= low&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 &lt;code&gt;high == low&lt;/code&gt; 时，新 &lt;code&gt;slice&lt;/code&gt; 为空。&lt;/p&gt;
&lt;p&gt;还有一点，&lt;code&gt;high&lt;/code&gt; 和 &lt;code&gt;max&lt;/code&gt; 必须在老数组或者老 &lt;code&gt;slice&lt;/code&gt; 的容量（&lt;code&gt;cap&lt;/code&gt;）范围内。&lt;/p&gt;
&lt;p&gt;来看一个例子，来自雨痕大佬《Go学习笔记》第四版，P43页，参考资料里有开源书籍地址。这里我会进行扩展，并会作详细说明：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    s1 := slice[2:5]
    s2 := s1[2:6:7]

    s2 = append(s2, 100)
    s2 = append(s2, 200)

    s1[2] = 20

    fmt.Println(s1)
    fmt.Println(s2)
    fmt.Println(slice)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看下代码运行的结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[2 3 20]
[4 5 6 7 100 200]
[0 1 2 3 20 5 6 7 100 9]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来走一遍代码，初始状态如下：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;slice := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
s1 := slice[2:5]
s2 := s1[2:6:7]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;s1&lt;/code&gt; 从 &lt;code&gt;slice&lt;/code&gt; 索引2（闭区间）到索引5（开区间，元素真正取到索引4），长度为3，容量默认到数组结尾，为8。&lt;br/&gt;&lt;code&gt;s2&lt;/code&gt; 从 &lt;code&gt;s1&lt;/code&gt; 的索引2（闭区间）到索引6（开区间，元素真正取到索引5），容量到索引7（开区间，真正到索引6），为5。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54960948-c5490b80-4f99-11e9-8772-66d102caae8e.png&quot; alt=&quot;slice origin&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，向 &lt;code&gt;s2&lt;/code&gt; 尾部追加一个元素 100：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;s2 = append(s2, 100)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;s2&lt;/code&gt; 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 &lt;code&gt;s1&lt;/code&gt; 都可以看得到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54960896-8ca93200-4f99-11e9-86de-df4d85cca135.png&quot; alt=&quot;append 100&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再次向 &lt;code&gt;s2&lt;/code&gt; 追加元素200：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;s2 = append(s2, 100)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时，&lt;code&gt;s2&lt;/code&gt; 的容量不够用，该扩容了。于是，&lt;code&gt;s2&lt;/code&gt; 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 &lt;code&gt;append&lt;/code&gt; 带来的再一次扩容，&lt;code&gt;s2&lt;/code&gt; 会在此次扩容的时候多留一些 &lt;code&gt;buffer&lt;/code&gt;，将新的容量将扩大为原始容量的2倍，也就是10了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54961368-4654d280-4f9b-11e9-9b00-de96c6eedea9.png&quot; alt=&quot;append 200&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，修改 &lt;code&gt;s1&lt;/code&gt; 索引为2位置的元素：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;s1[2] = 20&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这次只会影响原始数组相应位置的元素。它影响不到 &lt;code&gt;s2&lt;/code&gt; 了，人家已经远走高飞了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/54961330-29200400-4f9b-11e9-88d0-a29308a818ae.png&quot; alt=&quot;s1[2]=20&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再提一点，打印 &lt;code&gt;s1&lt;/code&gt; 的时候，只会打印出 &lt;code&gt;s1&lt;/code&gt; 长度以内的元素。所以，只会打印出3个元素，虽然它的底层数组不止3个元素。&lt;/p&gt;
&lt;p&gt;至于，我们想在汇编层面看看到底它们是如何共享底层数组的，限于篇幅，这里不再展开。感兴趣的同学可以在公众号后台回复：&lt;code&gt;切片截取&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我会给你详细分析函数调用关系，对共享底层数组的行为也会一目了然。二维码见文章底部。&lt;/p&gt;

&lt;p&gt;slice 的底层数据是数组，slice 是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。&lt;/p&gt;
&lt;p&gt;数组是定长的，长度定义好之后，不能再更改。在 Go 中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如 &lt;code&gt;[3]int&lt;/code&gt; 和 &lt;code&gt;[4]int&lt;/code&gt; 就是不同的类型。&lt;/p&gt;
&lt;p&gt;而切片则非常灵活，它可以动态地扩容。切片的类型和长度无关。&lt;/p&gt;

&lt;p&gt;先来看看 &lt;code&gt;append&lt;/code&gt; 函数的原型：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;func append(slice []Type, elems ...Type) []Type&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;append 函数的参数长度可变，因此可以追加多个值到 slice 中，还可以用 &lt;code&gt;...&lt;/code&gt; 传入 slice，直接追加一个切片。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;slice = append(slice, elem1, elem2)
slice = append(slice, anotherSlice...)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;append&lt;/code&gt;函数返回值是一个新的slice，Go编译器不允许调用了 append 函数后不使用返回值。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;append(slice, elem1, elem2)
append(slice, anotherSlice...)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以上面的用法是错的，不能编译通过。&lt;/p&gt;
&lt;p&gt;使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 &lt;code&gt;len-1&lt;/code&gt; 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。&lt;/p&gt;
&lt;p&gt;这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 &lt;code&gt;slice&lt;/code&gt; 的容量是留了一定的 &lt;code&gt;buffer&lt;/code&gt; 的。否则，每次添加元素的时候，都会发生迁移，成本太高。&lt;/p&gt;
&lt;p&gt;新 slice 预留的 &lt;code&gt;buffer&lt;/code&gt; 大小是有一定规律的。网上大多数的文章都是这样描述的：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;当原 slice 容量小于 &lt;code&gt;1024&lt;/code&gt; 的时候，新 slice 容量变成原来的 &lt;code&gt;2&lt;/code&gt; 倍；原 slice 容量超过 &lt;code&gt;1024&lt;/code&gt;，新 slice 容量变成原来的&lt;code&gt;1.25&lt;/code&gt;倍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我在这里先说结论：以上描述是错误的。&lt;/p&gt;
&lt;p&gt;为了说明上面的规律是错误的，我写了一小段玩具代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    s := make([]int, 0)

    oldCap := cap(s)

    for i := 0; i &amp;lt; 2048; i++ {
        s = append(s, i)

        newCap := cap(s)

        if newCap != oldCap {
            fmt.Printf(&quot;[%d -&amp;gt; %4d] cap = %-4d  |  after append %-4d  cap = %-4d\n&quot;, 0, i-1, oldCap, i, newCap)
            oldCap = newCap
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我先创建了一个空的 &lt;code&gt;slice&lt;/code&gt;，然后，在一个循环里不断往里面 &lt;code&gt;append&lt;/code&gt; 新的元素。然后记录容量的变化，并且每当容量发生变化的时候，记录下老的容量，以及添加完元素之后的容量，同时记下此时 &lt;code&gt;slice&lt;/code&gt; 里的元素。这样，我就可以观察，新老 &lt;code&gt;slice&lt;/code&gt; 的容量变化情况，从而找出规律。&lt;/p&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[0 -&amp;gt;   -1] cap = 0     |  after append 0     cap = 1   
[0 -&amp;gt;    0] cap = 1     |  after append 1     cap = 2   
[0 -&amp;gt;    1] cap = 2     |  after append 2     cap = 4   
[0 -&amp;gt;    3] cap = 4     |  after append 4     cap = 8   
[0 -&amp;gt;    7] cap = 8     |  after append 8     cap = 16  
[0 -&amp;gt;   15] cap = 16    |  after append 16    cap = 32  
[0 -&amp;gt;   31] cap = 32    |  after append 32    cap = 64  
[0 -&amp;gt;   63] cap = 64    |  after append 64    cap = 128 
[0 -&amp;gt;  127] cap = 128   |  after append 128   cap = 256 
[0 -&amp;gt;  255] cap = 256   |  after append 256   cap = 512 
[0 -&amp;gt;  511] cap = 512   |  after append 512   cap = 1024
[0 -&amp;gt; 1023] cap = 1024  |  after append 1024  cap = 1280
[0 -&amp;gt; 1279] cap = 1280  |  after append 1280  cap = 1696
[0 -&amp;gt; 1695] cap = 1696  |  after append 1696  cap = 2304&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在老 slice 容量小于1024的时候，新 slice 的容量的确是老 slice 的2倍。目前还算正确。&lt;/p&gt;
&lt;p&gt;但是，当老 slice 容量大于等于 &lt;code&gt;1024&lt;/code&gt; 的时候，情况就有变化了。当向 slice 中添加元素 &lt;code&gt;1280&lt;/code&gt; 的时候，老 slice 的容量为 &lt;code&gt;1280&lt;/code&gt;，之后变成了 &lt;code&gt;1696&lt;/code&gt;，两者并不是 &lt;code&gt;1.25&lt;/code&gt; 倍的关系（1696/1280=1.325）。添加完 &lt;code&gt;1696&lt;/code&gt; 后，新的容量 &lt;code&gt;2304&lt;/code&gt; 当然也不是 &lt;code&gt;1696&lt;/code&gt; 的 &lt;code&gt;1.25&lt;/code&gt; 倍。&lt;/p&gt;
&lt;p&gt;可见，现在网上各种文章中的扩容策略并不正确。我们直接搬出源码：源码面前，了无秘密。&lt;/p&gt;
&lt;p&gt;从前面汇编代码我们也看到了，向 slice 追加元素的时候，若容量不够，会调用 &lt;code&gt;growslice&lt;/code&gt; 函数，所以我们直接看它的代码。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// go 1.9.5 src/runtime/slice.go:82
func growslice(et *_type, old slice, cap int) slice {
    // ……
    newcap := old.cap
    doublecap := newcap + newcap
    if cap &amp;gt; doublecap {
        newcap = cap
    } else {
        if old.len &amp;lt; 1024 {
            newcap = doublecap
        } else {
            for newcap &amp;lt; cap {
                newcap += newcap / 4
            }
        }
    }
    // ……
    
    capmem = roundupsize(uintptr(newcap) * ptrSize)
    newcap = int(capmem / ptrSize)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看到了吗？如果只看前半部分，现在网上各种文章里说的 &lt;code&gt;newcap&lt;/code&gt; 的规律是对的。现实是，后半部分还对 &lt;code&gt;newcap&lt;/code&gt; 作了一个&lt;code&gt;内存对齐&lt;/code&gt;，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 &lt;code&gt;大于等于&lt;/code&gt; 老 slice 容量的 &lt;code&gt;2倍&lt;/code&gt;或者&lt;code&gt;1.25倍&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。&lt;/p&gt;
&lt;p&gt;最后，向 &lt;code&gt;growslice&lt;/code&gt; 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。&lt;/p&gt;
&lt;p&gt;关于 &lt;code&gt;append&lt;/code&gt;，我们最后来看一个例子，来源于参考资料部分的【Golang Slice的扩容规则】。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    s := []int{1,2}
    s = append(s,4,5,6)
    fmt.Printf(&quot;len=%d, cap=%d&quot;,len(s),cap(s))
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果是：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;len=5, cap=6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果按网上各种文章中总结的那样：小于原 slice 长度小于 1024 的时候，容量每次增加 1 倍。添加元素 4 的时候，容量变为4；添加元素 5 的时候不变；添加元素 6 的时候容量增加 1 倍，变成 8。&lt;/p&gt;
&lt;p&gt;那上面代码的运行结果就是：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;len=5, cap=8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是错误的！我们来仔细看看，为什么会这样，再次搬出代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// go 1.9.5 src/runtime/slice.go:82
func growslice(et *_type, old slice, cap int) slice {
    // ……
    newcap := old.cap
    doublecap := newcap + newcap
    if cap &amp;gt; doublecap {
        newcap = cap
    } else {
        // ……
    }
    // ……
    
    capmem = roundupsize(uintptr(newcap) * ptrSize)
    newcap = int(capmem / ptrSize)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个函数的参数依次是 &lt;code&gt;元素的类型，老的 slice，新 slice 最小求的容量&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例子中 &lt;code&gt;s&lt;/code&gt; 原来只有 2 个元素，&lt;code&gt;len&lt;/code&gt; 和 &lt;code&gt;cap&lt;/code&gt; 都为 2，&lt;code&gt;append&lt;/code&gt; 了三个元素后，长度变为 3，容量最小要变成 5，即调用 &lt;code&gt;growslice&lt;/code&gt; 函数时，传入的第三个参数应该为 5。即 &lt;code&gt;cap=5&lt;/code&gt;。而一方面，&lt;code&gt;doublecap&lt;/code&gt; 是原 &lt;code&gt;slice&lt;/code&gt;容量的 2 倍，等于 4。满足第一个 &lt;code&gt;if&lt;/code&gt; 条件，所以 &lt;code&gt;newcap&lt;/code&gt; 变成了 5。&lt;/p&gt;
&lt;p&gt;接着调用了 &lt;code&gt;roundupsize&lt;/code&gt; 函数，传入 40。（代码中ptrSize是指一个指针的大小，在64位机上是8）&lt;/p&gt;
&lt;p&gt;我们再看内存对齐，搬出 &lt;code&gt;roundupsize&lt;/code&gt; 函数的代码：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;// src/runtime/msize.go:13
func roundupsize(size uintptr) uintptr {
    if size &amp;lt; _MaxSmallSize {
        if size &amp;lt;= smallSizeMax-8 {
            return uintptr(class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]])
        } else {
            //……
        }
    }
    //……
}

const _MaxSmallSize = 32768
const smallSizeMax = 1024
const smallSizeDiv = 8&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显，我们最终将返回这个式子的结果：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;class_to_size[size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是 &lt;code&gt;Go&lt;/code&gt; 源码中有关内存分配的两个 &lt;code&gt;slice&lt;/code&gt;。&lt;code&gt;class_to_size&lt;/code&gt;通过 &lt;code&gt;spanClass&lt;/code&gt;获取 &lt;code&gt;span&lt;/code&gt;划分的 &lt;code&gt;object&lt;/code&gt;大小。而 &lt;code&gt;size_to_class8&lt;/code&gt; 表示通过 &lt;code&gt;size&lt;/code&gt; 获取它的 &lt;code&gt;spanClass&lt;/code&gt;。&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;var size_to_class8 = [smallSizeMax/smallSizeDiv + 1]uint8{0, 1, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 23, 23, 24, 24, 24, 24, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31, 31}

var class_to_size = [_NumSizeClasses]uint16{0, 8, 16, 32, 48, 64, 80, 96, 112, 128, 144, 160, 176, 192, 208, 224, 240, 256, 288, 320, 352, 384, 416, 448, 480, 512, 576, 640, 704, 768, 896, 1024, 1152, 1280, 1408, 1536, 1792, 2048, 2304, 2688, 3072, 3200, 3456, 4096, 4864, 5376, 6144, 6528, 6784, 6912, 8192, 9472, 9728, 10240, 10880, 12288, 13568, 14336, 16384, 18432, 19072, 20480, 21760, 24576, 27264, 28672, 32768}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们传进去的 &lt;code&gt;size&lt;/code&gt; 等于 40。所以 &lt;code&gt;(size+smallSizeDiv-1)/smallSizeDiv = 5&lt;/code&gt;；获取 &lt;code&gt;size_to_class8&lt;/code&gt; 数组中索引为 &lt;code&gt;5&lt;/code&gt; 的元素为 &lt;code&gt;4&lt;/code&gt;；获取 &lt;code&gt;class_to_size&lt;/code&gt; 中索引为 &lt;code&gt;4&lt;/code&gt; 的元素为 &lt;code&gt;48&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最终，新的 slice 的容量为 &lt;code&gt;6&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;newcap = int(capmem / ptrSize) // 6&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于，上面的两个&lt;code&gt;魔法数组&lt;/code&gt;的由来，暂时就不展开了。&lt;/p&gt;

&lt;p&gt;其实 &lt;code&gt;nil slice&lt;/code&gt; 或者 &lt;code&gt;empty slice&lt;/code&gt; 都是可以通过调用 append 函数来获得底层数组的扩容。最终都是调用 &lt;code&gt;mallocgc&lt;/code&gt; 来向 Go 的内存管理器申请到一块内存，然后再赋给原来的&lt;code&gt;nil slice&lt;/code&gt; 或 &lt;code&gt;empty slice&lt;/code&gt;，然后摇身一变，成为“真正”的 &lt;code&gt;slice&lt;/code&gt; 了。&lt;/p&gt;

&lt;p&gt;前面我们说到，slice 其实是一个结构体，包含了三个成员：len, cap, array。分别表示切片长度，容量，底层数据的地址。&lt;/p&gt;
&lt;p&gt;当 slice 作为函数参数时，就是一个普通的结构体。其实很好理解：若直接传 slice，在调用者看来，实参 slice 并不会被函数中的操作改变；若传的是 slice 的指针，在调用者看来，是会被改变原 slice 的。&lt;/p&gt;
&lt;p&gt;值的注意的是，不管传的是 slice 还是 slice 指针，如果改变了 slice 底层数组的数据，会反应到实参 slice 的底层数据。为什么能改变底层数组的数据？很好理解：底层数据在 slice 结构体里是一个指针，仅管 slice 结构体自身不会被改变，也就是说底层数据地址不会被改变。 但是通过指向底层数据的指针，可以改变切片的底层数据，没有问题。&lt;/p&gt;
&lt;p&gt;通过 slice 的 array 字段就可以拿到数组的地址。在代码里，是直接通过类似 &lt;code&gt;s[i]=10&lt;/code&gt; 这种操作改变 slice 底层数组元素值。&lt;/p&gt;
&lt;p&gt;另外，啰嗦一句，Go 语言的函数参数传递，只有值传递，没有引用传递。后面会再写一篇相关的文章，敬请期待。&lt;/p&gt;
&lt;p&gt;再来看一个年幼无知的代码片段：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

func main() {
    s := []int{1, 1, 1}
    f(s)
    fmt.Println(s)
}

func f(s []int) {
    // i只是一个副本，不能改变s中元素的值
    /*for _, i := range s {
        i++
    }
    */

    for i := range s {
        s[i] += 1
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行一下，程序输出：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[2 2 2]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;果真改变了原始 slice 的底层数据。这里传递的是一个 slice 的副本，在 &lt;code&gt;f&lt;/code&gt; 函数中，&lt;code&gt;s&lt;/code&gt; 只是 &lt;code&gt;main&lt;/code&gt; 函数中 &lt;code&gt;s&lt;/code&gt; 的一个拷贝。在&lt;code&gt;f&lt;/code&gt; 函数内部，对 &lt;code&gt;s&lt;/code&gt; 的作用并不会改变外层 &lt;code&gt;main&lt;/code&gt; 函数的 &lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;要想真的改变外层 &lt;code&gt;slice&lt;/code&gt;，只有将返回的新的 slice 赋值到原始 slice，或者向函数传递一个指向 slice 的指针。我们再来看一个例子：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;fmt&quot;

func myAppend(s []int) []int {
    // 这里 s 虽然改变了，但并不会影响外层函数的 s
    s = append(s, 100)
    return s
}

func myAppendPtr(s *[]int) {
    // 会改变外层 s 本身
    *s = append(*s, 100)
    return
}

func main() {
    s := []int{1, 1, 1}
    newS := myAppend(s)

    fmt.Println(s)
    fmt.Println(newS)

    s = newS

    myAppendPtr(&amp;amp;s)
    fmt.Println(s)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[1 1 1]
[1 1 1 100]
[1 1 1 100 100]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;myAppend&lt;/code&gt; 函数里，虽然改变了 &lt;code&gt;s&lt;/code&gt;，但它只是一个值传递，并不会影响外层的 &lt;code&gt;s&lt;/code&gt;，因此第一行打印出来的结果仍然是 &lt;code&gt;[1 1 1]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;newS&lt;/code&gt; 是一个新的 &lt;code&gt;slice&lt;/code&gt;，它是基于 &lt;code&gt;s&lt;/code&gt; 得到的。因此它打印的是追加了一个 &lt;code&gt;100&lt;/code&gt; 之后的结果： &lt;code&gt;[1 1 1 100]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;最后，将 &lt;code&gt;newS&lt;/code&gt; 赋值给了 &lt;code&gt;s&lt;/code&gt;，&lt;code&gt;s&lt;/code&gt; 这时才真正变成了一个新的slice。之后，再给 &lt;code&gt;myAppendPtr&lt;/code&gt; 函数传入一个 &lt;code&gt;s 指针&lt;/code&gt;，这回它真的被改变了：&lt;code&gt;[1 1 1 100 100]&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;到此，关于 &lt;code&gt;slice&lt;/code&gt; 的部分就讲完了，不知大家有没有看过瘾。我们最后来总结一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;切片是对底层数组的一个抽象，描述了它的一个片段。&lt;/li&gt;
&lt;li&gt;切片实际上是一个结构体，它有三个字段：长度，容量，底层数据的地址。&lt;/li&gt;
&lt;li&gt;多个切片可能共享同一个底层数组，这种情况下，对其中一个切片或者底层数组的更改，会影响到其他切片。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;append&lt;/code&gt; 函数会在切片容量不够的情况下，调用 &lt;code&gt;growslice&lt;/code&gt; 函数获取所需要的内存，这称为扩容，扩容会改变元素原来的位置。&lt;/li&gt;
&lt;li&gt;扩容策略并不是简单的扩为原切片容量的 &lt;code&gt;2&lt;/code&gt; 倍或 &lt;code&gt;1.25&lt;/code&gt; 倍，还有内存对齐的操作。扩容后的容量 &amp;gt;= 原容量的 &lt;code&gt;2&lt;/code&gt; 倍或 &lt;code&gt;1.25&lt;/code&gt; 倍。&lt;/li&gt;
&lt;li&gt;当直接用切片作为函数参数时，可以改变切片的元素，不能改变切片本身；想要改变切片本身，可以将改变后的切片返回，函数调用者接收改变后的切片或者将切片指针作为函数参数。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;最后，如果你觉得本文对你有帮助的话，帮我点一下右下角的“推荐”吧，感谢！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/7698088/51420568-305b1800-1bce-11e9-962a-52b12be7eb2e.png&quot; alt=&quot;QR&quot;/&gt;&lt;/p&gt;

&lt;p&gt;【码洞《深度解析 Go 语言中「切片」的三种特殊状态》】&lt;a href=&quot;https://juejin.im/post/5bea58df6fb9a049f153bca8&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5bea58df6fb9a049f153bca8&lt;/a&gt;&lt;br/&gt;【老钱 数组】&lt;a href=&quot;https://juejin.im/post/5be53bc251882516c15af2e0&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5be53bc251882516c15af2e0&lt;/a&gt;&lt;br/&gt;【老钱 切片】&lt;a href=&quot;https://juejin.im/post/5be8e0b1f265da614d08b45a&quot; class=&quot;uri&quot;&gt;https://juejin.im/post/5be8e0b1f265da614d08b45a&lt;/a&gt;&lt;br/&gt;【golang interface源码】&lt;a href=&quot;https://i6448038.github.io/2018/10/01/Golang-interface/&quot; class=&quot;uri&quot;&gt;https://i6448038.github.io/2018/10/01/Golang-interface/&lt;/a&gt;&lt;br/&gt;【golang interface源码】&lt;a href=&quot;http://legendtkl.com/2017/07/01/golang-interface-implement/&quot; class=&quot;uri&quot;&gt;http://legendtkl.com/2017/07/01/golang-interface-implement/&lt;/a&gt;&lt;br/&gt;【interface】&lt;a href=&quot;https://www.jishuwen.com/d/2C9z#tuit&quot; class=&quot;uri&quot;&gt;https://www.jishuwen.com/d/2C9z#tuit&lt;/a&gt;&lt;br/&gt;【雨痕开源Go学习笔记】&lt;a href=&quot;https://github.com/qyuhen/book&quot; class=&quot;uri&quot;&gt;https://github.com/qyuhen/book&lt;/a&gt;&lt;br/&gt;【slice 图很漂亮】&lt;a href=&quot;https://halfrost.com/go_slice/&quot; class=&quot;uri&quot;&gt;https://halfrost.com/go_slice/&lt;/a&gt;&lt;br/&gt;【Golang Slice的扩容规则】&lt;a href=&quot;https://jodezer.github.io/2017/05/golangSlice%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99&quot;&gt;https://jodezer.github.io/2017/05/golangSlice%E7%9A%84%E6%89%A9%E5%AE%B9%E8%A7%84%E5%88%99&lt;/a&gt;&lt;br/&gt;【slice作为参数】&lt;a href=&quot;https://www.cnblogs.com/fwdqxl/p/9317769.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/fwdqxl/p/9317769.html&lt;/a&gt;&lt;br/&gt;【源码】&lt;a href=&quot;https://ictar.xyz/2018/10/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-go-slice/&quot;&gt;https://ictar.xyz/2018/10/25/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-go-slice/&lt;/a&gt;&lt;br/&gt;【append机制 译文】&lt;a href=&quot;https://brantou.github.io/2017/05/24/go-array-slice-string/&quot; class=&quot;uri&quot;&gt;https://brantou.github.io/2017/05/24/go-array-slice-string/&lt;/a&gt;&lt;br/&gt;【slice 汇编】&lt;a href=&quot;http://xargin.com/go-slice/&quot; class=&quot;uri&quot;&gt;http://xargin.com/go-slice/&lt;/a&gt;&lt;br/&gt;【slice tricks】&lt;a href=&quot;https://colobu.com/2017/03/22/Slice-Tricks/&quot; class=&quot;uri&quot;&gt;https://colobu.com/2017/03/22/Slice-Tricks/&lt;/a&gt;&lt;br/&gt;【有图】&lt;a href=&quot;https://i6448038.github.io/2018/08/11/array-and-slice-principle/&quot; class=&quot;uri&quot;&gt;https://i6448038.github.io/2018/08/11/array-and-slice-principle/&lt;/a&gt;&lt;br/&gt;【slice的本质】&lt;a href=&quot;https://www.flysnow.org/2018/12/21/golang-sliceheader.html&quot; class=&quot;uri&quot;&gt;https://www.flysnow.org/2018/12/21/golang-sliceheader.html&lt;/a&gt;&lt;br/&gt;【slice使用技巧】&lt;a href=&quot;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201901/go/slice_de_yi_xie_shi_yong_ji_qiao.html&lt;/a&gt;&lt;br/&gt;【slice/array、内存增长】&lt;a href=&quot;https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html&quot; class=&quot;uri&quot;&gt;https://blog.thinkeridea.com/201901/go/shen_ru_pou_xi_slice_he_array.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 14:23:00 +0000</pubDate>
<dc:creator>Stefno</dc:creator>
<og:description>slice 是 Go 语言一个很重要的数据结构。网上已经有很多文章写过了，似乎没必要再写。但是每个人看问题的视角不同，写出来的东西自然也不一样。我这篇会从更底层的汇编语言去解读它，这是一个新的世界。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qcrao-2018/p/10631989.html</dc:identifier>
</item>
<item>
<title>基于async/non-blocking高性能redis组件库BeetleX.Redis - smark</title>
<link>http://www.cnblogs.com/smark/p/10639573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smark/p/10639573.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;code&gt;BeetleX.Redis&lt;/code&gt;是基于&lt;code&gt;async/non-blocking&lt;/code&gt;模式实现的高性能&lt;code&gt;redis&lt;/code&gt;组件库，组件支持redis基础指令集，并封装更简便的&lt;code&gt;List&lt;/code&gt;,&lt;code&gt;Hashset&lt;/code&gt;和&lt;code&gt;Subscribe&lt;/code&gt;操作。除了在基础操作功能上，组件还提供多服务备份方式和多连接池机制，从而让组件提供高可用和高性能的访问方案;在数据格式上组件默认集成了&lt;code&gt;json&lt;/code&gt;和&lt;code&gt;protobuf&lt;/code&gt;可以根据自己的需求来选择相应的存储格式。接下来大概看一下组件的性能和应用功能。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;性能&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;针对Order结构进行一个&lt;code&gt;GET/SET&lt;/code&gt;性能测试，分别测试&lt;code&gt;BeetleX&lt;/code&gt;和&lt;code&gt;StackExchange&lt;/code&gt;在这两个操作下不同线程的压测，由于在8以上线程数测试&lt;code&gt;StackExchange&lt;/code&gt;经常抛timeout错误....，所以只测了1,2和4线程情况。详细测试代码:&lt;a href=&quot;https://github.com/IKende/BeetleX.Redis/tree/master/PerformanceTest&quot;&gt;https://github.com/IKende/BeetleX.Redis/tree/master/PerformanceTest&lt;/a&gt;（代码里集成了一个轻巧的性能测试功能类，用起来非常方便，只需要简单编写测试用例就可以列表出测试时间和并发等相关数据，以下测试结果列表由这个测试类输出。）&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;测试数据结构&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrderID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;10255&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;CustomerID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RICSU&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;EmployeeID&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;9&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;OrderDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1996-07-12T00:00:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RequiredDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1996-08-09T00:00:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShippedDate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1996-07-15T00:00:00&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShipVia&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;3&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Freight&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;148.33&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShipName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Richter Supermarkt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShipAddress&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Starenweg 5&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShipCity&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Genève&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShipPostalCode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;1204&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ShipCountry&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Switzerland&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;  &lt;span&gt;await&lt;/span&gt;&lt;span&gt; RedisDB.Set(item.OrderID.ToString(), item);
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;  &lt;span&gt;await&lt;/span&gt; RedisDB.Get&amp;lt;Order&amp;gt;(i.ToString());
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;StackExchange&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;   &lt;span&gt;await&lt;/span&gt;&lt;span&gt; RedisDB.StringSetAsync(item.OrderID.ToString(), Newtonsoft.Json.JsonConvert.SerializeObject(item));
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; data = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; RedisDB.StringGetAsync(i.ToString());
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;   &lt;span&gt;var&lt;/span&gt; item = Newtonsoft.Json.JsonConvert.DeserializeObject&amp;lt;Northwind.Data.Order&amp;gt;(data);
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;测试结果&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
-------------------------------------------------------------------------------
|Name                          | Round| Threads|     Count| Use time(s)|   Sec|
-------------------------------------------------------------------------------
|BeetleX_SET                   |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;5.22&lt;/span&gt;| &lt;span&gt;19157&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_SET             |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;6.97&lt;/span&gt;| &lt;span&gt;14357&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_SET        |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;6.62&lt;/span&gt;| &lt;span&gt;15103&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_GET                   |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;5.41&lt;/span&gt;| &lt;span&gt;18487&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_GET             |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;7.48&lt;/span&gt;| &lt;span&gt;13378&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_GET        |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;7.09&lt;/span&gt;| &lt;span&gt;14105&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_MGET                  |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;7.03&lt;/span&gt;| &lt;span&gt;14216&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_MGET            |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;8.69&lt;/span&gt;| &lt;span&gt;11504&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_MGET       |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;1&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;8.36&lt;/span&gt;| &lt;span&gt;11963&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_SET                   |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.55&lt;/span&gt;| &lt;span&gt;39246&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_SET             |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;3.97&lt;/span&gt;| &lt;span&gt;25199&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_SET        |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;3.56&lt;/span&gt;| &lt;span&gt;28069&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_GET                   |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.78&lt;/span&gt;| &lt;span&gt;35946&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_GET             |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|         &lt;span&gt;4.1&lt;/span&gt;| &lt;span&gt;24364&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_GET        |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;3.72&lt;/span&gt;| &lt;span&gt;26907&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_MGET                  |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;3.59&lt;/span&gt;| &lt;span&gt;27871&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_MGET            |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;4.75&lt;/span&gt;| &lt;span&gt;21035&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_MGET       |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;2&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;4.55&lt;/span&gt;| &lt;span&gt;21976&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_SET                   |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.04&lt;/span&gt;| &lt;span&gt;48956&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_SET             |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.37&lt;/span&gt;| &lt;span&gt;42220&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_SET        |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.15&lt;/span&gt;| &lt;span&gt;46541&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_GET                   |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.14&lt;/span&gt;| &lt;span&gt;46822&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_GET             |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.58&lt;/span&gt;| &lt;span&gt;38789&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_GET        |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.24&lt;/span&gt;| &lt;span&gt;44619&lt;/span&gt;|
-------------------------------------------------------------------------------
|BeetleX_MGET                  |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.49&lt;/span&gt;| &lt;span&gt;40238&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_MGET            |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;3.06&lt;/span&gt;| &lt;span&gt;32708&lt;/span&gt;|
-------------------------------------------------------------------------------
|StackExchange_Sync_MGET       |     &lt;span&gt;1&lt;/span&gt;|       &lt;span&gt;4&lt;/span&gt;|    &lt;span&gt;100000&lt;/span&gt;|        &lt;span&gt;2.76&lt;/span&gt;| &lt;span&gt;36264&lt;/span&gt;|
-------------------------------------------------------------------------------
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;-&quot;&gt;组件使用&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;组件默认就支持数据对象操作，而数据存储的格式则由相应创建的DB数据类型决定，所以在使用和处理数据上都比较方便。&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;创建数据库&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
RedisDB DB = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RedisDB();
DB.AddWriteHost(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.2.19&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; set password&lt;/span&gt;
DB.AddWriteHost(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;192.168.2.19&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;).Password=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123456&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;json-&quot;&gt;Json 数据库&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
RedisDB DB = &lt;span&gt;new&lt;/span&gt; RedisDB(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; JsonFormater());
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;protobuf-&quot;&gt;Protobuf 数据库&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
RedisDB DB = &lt;span&gt;new&lt;/span&gt; RedisDB(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;new&lt;/span&gt; ProtobufFormater());
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;-&quot;&gt;基础操作&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;await&lt;/span&gt; DB.Decr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Decrby(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;5&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Del(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Dump(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Exists(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Expire(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Expireat(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1293840000&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Get&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.GetBit(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.GetRange(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, -&lt;span&gt;3&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.GetSet&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mycounter&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Incr(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Incrby(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.IncrbyFloat(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;0.1f&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Keys(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;t??&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.MGet&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.MGet&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;aaa&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.MSet(m =&amp;gt; m[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;world&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.MSetNX(m =&amp;gt; m[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;there&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Move(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;one&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;9&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.PSetEX(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1000&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Persist(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Pexpire(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1500&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Pexpireat(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;1555555555005&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; DB.Ping();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.PTtl(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; DB.Randomkey();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Rename(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myotherkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Renamenx(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myotherkey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;henryfan&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.SetBit(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;7&lt;/span&gt;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.SetEX(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;10&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.SetNX(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;mykey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.SetRange(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;6&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;redis&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Strlen(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; DB.Type(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;key2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;-&quot;&gt;列表操作&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;创建列表&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 &lt;span&gt;var&lt;/span&gt; list = DB.CreateList&amp;lt;Employee&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;employees&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;列表操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;await&lt;/span&gt;&lt;span&gt; list.BLPop();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; list.BRPop();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.BRPopLPush(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;List2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Index(&lt;span&gt;0&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Insert(&lt;span&gt;true&lt;/span&gt;, GetEmployee(&lt;span&gt;2&lt;/span&gt;), GetEmployee(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; list.Len();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; list.Pop();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Push(GetEmployee(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Push(GetEmployee(&lt;span&gt;1&lt;/span&gt;), GetEmployee(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; myotherlist.PushX(GetEmployee(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Rem(-&lt;span&gt;2&lt;/span&gt;, GetEmployee(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Set(-&lt;span&gt;2&lt;/span&gt;, GetEmployee(&lt;span&gt;5&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Trim(&lt;span&gt;1&lt;/span&gt;, -&lt;span&gt;1&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; list.RPop();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.RPopLPush(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myotherlist&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.RPush(GetEmployee(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.RPush(GetEmployee(&lt;span&gt;1&lt;/span&gt;), GetEmployee(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.RPushX(GetEmployee(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; list.Range(-&lt;span&gt;3&lt;/span&gt;, &lt;span&gt;2&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;hashtable-&quot;&gt;HashTable结构&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;创建&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; table = DB.CreateHashTable(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;myhash&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;相关操作&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;await&lt;/span&gt; table.Del(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;emp1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.Exists(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;emp1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.Get&amp;lt;Employee&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;emp1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; table.Keys();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; table.Len();
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.Get&amp;lt;Employee, Order&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;emp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.Get&amp;lt;Employee, Order, Customer&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;emp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;order&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;customer&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.MSet(m =&amp;gt; m[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;field1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetEmployee(&lt;span&gt;1&lt;/span&gt;)][&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;field2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetCustomer(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)]);
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.Set(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;field1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetEmployee(&lt;span&gt;1&lt;/span&gt;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;await&lt;/span&gt; table.SetNX(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;field&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetEmployee(&lt;span&gt;1&lt;/span&gt;));
&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id=&quot;-&quot;&gt;订阅&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;创建订阅&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; sub =&lt;span&gt; db.Subscribe();
            sub.Register&lt;/span&gt;&amp;lt;Employee&amp;gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            sub.Receive &lt;/span&gt;= (o, e) =&amp;gt;&lt;span&gt;
            {
                Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;[{DateTime.Now}]{e.Channel}-{e.Type}:{e.Data}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            };
            sub.Listen();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;通过&lt;code&gt;Retister&lt;/code&gt;方法注册订阅频道，在注册的时候必须指定数据类型，对象反序列化的格式依据库数据的格式类型。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;await&lt;/span&gt; DB.Publish(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;test1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, GetEmployee(i));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;以上是发布消息到频道&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;以上是&lt;code&gt;BeetleX.Redis&lt;/code&gt;现有版本的功能，集群功能暂没有实现；但提供主备功能可以根据自己的需要添加多个WriteHost或ReadHost，默认连接池机制随意应对高并发应用；组件希望打造一个高性能简便的Redis .net core组件,但要发挥组件的性能特色就要适应完全基于await的方法进行组件操作。 项目开源地址：&lt;a href=&quot;https://github.com/IKende/BeetleX.Redis&quot;&gt;https://github.com/IKende/BeetleX.Redis&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Apr 2019 14:09:00 +0000</pubDate>
<dc:creator>smark</dc:creator>
<og:description>BeetleX.Redis是基于async/non-blocking模式实现的高性能redis组件库，组件支持redis基础指令集，并封装更简便的List,Hashset和Subscribe操作。除了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smark/p/10639573.html</dc:identifier>
</item>
</channel>
</rss>