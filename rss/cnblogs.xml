<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>行业动态 | DataStax 2021年新年预测 - DataStax</title>
<link>http://www.cnblogs.com/datastax/p/14224699.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/datastax/p/14224699.html</guid>
<description>&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;a0to6-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;a0to6-0-0&quot;&gt;&lt;em&gt;&lt;em&gt;&lt;span data-offset-key=&quot;4o5hq-0-0&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2111170/202101/2111170-20210103024511465-713449817.png&quot; alt=&quot;&quot; width=&quot;876&quot; height=&quot;493&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;4o5hq-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;4o5hq-0-0&quot;&gt;
&lt;p&gt;&lt;strong&gt; &lt;em&gt;Happy New Year！&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;dibc2-0-0&quot; readability=&quot;8&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;dibc2-0-0&quot; readability=&quot;7.5&quot;&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;2htj3-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;em&gt;今天是元旦，DataStax在此祝大家2021新年快乐 o(*≧▽≦)ノ&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;4o5hq-0-0&quot; readability=&quot;8&quot;&gt;

&lt;p&gt;&lt;em&gt;新的一年中，我们也将为大家提供更多有用的资源，并组织更多有意义的活动。&lt;/em&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;em&gt;&lt;span data-offset-key=&quot;dibc2-0-0&quot;&gt;同时我们也希望看到更多的小伙伴们加入Cassandra中文社区的建设，分享经验和见解。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;

&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;fpf9j-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;span data-offset-key=&quot;fpf9j-0-0&quot;&gt;非常期待在新的一年中继续和大家深入交流，让我们共同进步 o(〃’▽’〃)o&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;d3g7f-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;span data-offset-key=&quot;d3g7f-0-0&quot;&gt;回顾2020，这是不平凡的一年。从中我们获得了很多宝贵的经验，而这些经验则将在2021年驱动我们前行。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;afqsq-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;span data-offset-key=&quot;afqsq-0-0&quot;&gt;在2021年，我们将会看到哪些明显的改变呢？DataStax的开发者关系副总裁兼首席布道师Patrick McFadin做出了他对2021年的预测，在此与大家分享。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;/div&gt;



&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;97ghv-0-0&quot; readability=&quot;8&quot;&gt; 
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;b1hho-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;b1hho-0-0&quot;&gt;美国摇滚乐队感恩至死(Grateful Dead)有一句名言：“这是一段多么漫长而奇特的旅程”。这句话相当好地描述了2020这个疫情之年。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;956n4-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;956n4-0-0&quot;&gt;这是艰难的一年，但是我们也从中学到了很多新的事情。带着这些经验进入到2021年，以下是我认为在即将到来的一年中我们会看到的事情。&lt;/span&gt;&lt;/p&gt;


&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;97ghv-0-0&quot;&gt;01 &lt;span data-offset-key=&quot;97ghv-0-1&quot;&gt;实验探究性质的数据项目的资金将会被缩减&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;27eu2-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;27eu2-0-0&quot;&gt;在众多数据项目中，那些更贴近用户且回报率更快的项目在2020年这个新冠疫情之年收获颇丰。那些找到门路并得以这种方式运营的公司，将会继续他们创新的步伐。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;3eksf-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;3eksf-0-0&quot;&gt;预期用数月甚至一年左右才能获得回报的大型项目将会被暂停甚至完全停止。因为2021年将不会是一个能够试验长远计划的年份——2021要求我们行动快速且回应客户需求。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;77kki-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;77kki-0-0&quot;&gt;那些声称“我们将会花费三年时间建成一个平台”的项目将会遭受现实的重击。相反的是，我们会看到利用现成的产品来推动现状的发展。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;3tk0q-0-0&quot;&gt;02 &lt;span data-offset-key=&quot;3tk0q-0-1&quot;&gt;信息化落伍者的大淘汰&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;4aaov-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4aaov-0-0&quot;&gt;2020年中，我很多次因企业适应隔离封城和新模式的速度而感到震惊。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;c6btp-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;c6btp-0-0&quot;&gt;我的孩子们喜欢的刨冰摊贩现在有了一个能够到店自取刨冰的App。这是真的吗？！&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;4rig3-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4rig3-0-0&quot;&gt;甚至连小商家们都已经认识到了创新和信息化转型对于企业生存的必要性，我提到的刨冰店就是一个很好的例子。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;2nmig-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;2nmig-0-0&quot;&gt;2021年，我们可能重获自由，不再需要隔离封城。但是我不认为2020年带给我们的好的改变会因此而逆转。顾客们刚刚经历了在商品和服务的交互方式上的巨大转变，这不会再恢复原状。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;32rnr-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;32rnr-0-0&quot;&gt;这意味着那些光想着等疫情过去而没有做出任何改变的企业现在已经落后了。他们会在2021年艰难求生，但所有的一切会以更快的速度向一个无可逆转的结局发展。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;f8aiq-0-0&quot;&gt;03 &lt;span data-offset-key=&quot;f8aiq-0-1&quot;&gt;会有人在未来将2020年称为“SRE之年”&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;bptoo-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;bptoo-0-0&quot;&gt;只有我这么认为吗？&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;68aag-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;68aag-0-0&quot;&gt;网站可靠性工程师(SRE)所做的可不只是保证备份功能良好运行。在如今的快节奏开发进程中，他们得保证产品的部署又快又好。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;28gf9-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;28gf9-0-0&quot;&gt;随着越来越多的云原生方法和产品采取“按需收费(pay-as-you-need)”的方式，SRE对企业的最终财务表现有着至关重要的影响。高效的部署包括了控制云环境的支出——我们必须得说，企业通常在这点上做得并不好。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;d5ivm-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;d5ivm-0-0&quot;&gt;我们通常将SRE工程师们看做企业中非常重要的一部分，但是不止于此，我们将认识到SRE会为企业的财务健康作出新的贡献。我们甚至可能看到一些CFO出于赞赏，会将2020年称为“SRE之年”。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;6r7fd-0-0&quot;&gt;04 &lt;span data-offset-key=&quot;6r7fd-0-1&quot;&gt;大型的线下用户大会将不会再度归来&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;fklv6-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;fklv6-0-0&quot;&gt;未来的某天，当我们回望时会发现2019是线下用户大会流行的最后一年。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;aqjlh-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;aqjlh-0-0&quot;&gt;每个科技公司成功的秘诀中都包含了举办大型会议，因为其他人都是这么干的。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;29ve8-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;29ve8-0-0&quot;&gt;但是在2020年，用户们日常技术栈中使用的技术都会有相关的线上用户大会。这些几乎每周都发生的线上会议多到经常会在时间上彼此冲突，以至于大家难以从中选择。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;ab9hi-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;ab9hi-0-0&quot;&gt;我们在过去的一年中已经进步升级了——我们学会了如何在不登上飞机的情况下与人交流。登上飞机并回到燥热的会议厅，这听起来很没吸引力。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;c4km5-0-0&quot; readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;c4km5-0-0&quot;&gt;我们依然会想要在我们的社区中与大家面对面交流，但是为了说服某些人踏上旅程，各个公司将需要考虑线上线下相结合，或者其他更有吸引力的方式。毕竟公司难道真的有时间将一队开发人员送去一个大型会议，然后拖慢一周的工作进度？&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;b6gq1-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;b6gq1-0-0&quot;&gt;2021年我们将看到更多的线上互动，它们将拥有高质量，并提供更多用户所需要的东西。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;es2l0-0-0&quot;&gt;05 &lt;span data-offset-key=&quot;es2l0-0-1&quot;&gt;2021将会是Apache Cassandra新特性的复苏之年&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;7m5dj-0-0&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;7m5dj-0-0&quot;&gt;这是我能最容易做出的准确预测。过去的几年中，Apache Cassandra的发展主要集中于提升数据库的运维、稳定性和整体的正确性。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;4bup1-0-0&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;4bup1-0-0&quot;&gt;为了集中精力于即将推出的4.0版本，Apache Cassandra恰当地停止了对于新特性的推进。这使得我们积压了一些能够提升这个项目的内核的前沿特性，比如像是索引模式(indexing scheme)、存储引擎的选择、查询和通信协议的改变。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;491m6-0-0&quot;&gt;
&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;491m6-0-0&quot;&gt;&lt;span data-offset-key=&quot;491m6-0-0&quot;&gt;不久之后4.0版本就会发布，这之后根据新特性的改动幅度，你将会看到一连串的与4.x和5.0版本特性相关的Git分支(branch)。我们已经准备好看到他们在Cassandra改进方案(&lt;a class=&quot;Link ztext-link&quot; href=&quot;https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=95652201&quot; target=&quot;_blank&quot; data-offset-key=&quot;491m6-1-0&quot; data-editable=&quot;true&quot;&gt;&lt;span data-offset-key=&quot;491m6-1-0&quot;&gt;&lt;span data-text=&quot;true&quot;&gt;Cassandra Enhancement Process&lt;/span&gt;&lt;/span&gt;&lt;/a&gt;&lt;span data-offset-key=&quot;491m6-2-0&quot;&gt;, aka, CEP)中排队出现了。&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;agagm-0-0&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span data-offset-key=&quot;agagm-0-0&quot;&gt;护好你的帽子，这些飞驰的进展将带给你一个很棒的旅程！&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;8m5c7-0-0&quot;&gt;

&lt;p&gt;&lt;strong&gt;&lt;span data-offset-key=&quot;8m5c7-0-0&quot;&gt;作者介绍&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;Editable-unstyled&quot; data-block=&quot;true&quot; data-editor=&quot;4h53v&quot; data-offset-key=&quot;3534t-0-0&quot; readability=&quot;9&quot;&gt;

&lt;p&gt;&lt;span data-offset-key=&quot;3534t-0-0&quot;&gt;Patrick McFadin&lt;span data-offset-key=&quot;3534t-0-1&quot;&gt;是DataStax开发者关系副总裁，他带领团队致力于帮助Apache Cassandra使用者们获得成功。与此同时，Patrick McFadin还是Apache Cassandra的首席布道师以及DataStax的咨询师，他为一些超大型且令人兴奋的生产部署提供了帮助。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;public-DraftStyleDefault-block public-DraftStyleDefault-ltr&quot; data-offset-key=&quot;3534t-0-0&quot;&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-7d8d5b7dc4c9f285e5a6da3b0ec5da32_720w.jpeg&quot; class=&quot;Image FocusPlugin--unfocused Image--isBlock&quot; data-size=&quot;normal&quot; data-rawwidth=&quot;220&quot; data-rawheight=&quot;274&quot; data-watermark=&quot;original&quot; data-original-src=&quot;https://pic2.zhimg.com/v2-7d8d5b7dc4c9f285e5a6da3b0ec5da32.jpeg&quot; data-watermark-src=&quot;https://pic4.zhimg.com/v2-b559b5293cfeeccb011673f5d86c6c95.jpeg&quot;/&gt;&lt;/div&gt;
&lt;p&gt;Patrick McFadin&lt;/p&gt;
&lt;/div&gt;

</description>
<pubDate>Sat, 02 Jan 2021 18:49:00 +0000</pubDate>
<dc:creator>DataStax</dc:creator>
<og:description>Happy New Year！ 今天是元旦，DataStax在此祝大家2021新年快乐 o(*≧▽≦)ノ 新的一年中，我们也将为大家提供更多有用的资源，并组织更多有意义的活动。 同时我们也希望看到更多</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/datastax/p/14224699.html</dc:identifier>
</item>
<item>
<title>元旦在家撸了两天Seata源码，你们是咋度过的呢？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/14224562.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/14224562.html</guid>
<description>&lt;h2 id=&quot;撸seata源码&quot;&gt;撸Seata源码&lt;/h2&gt;
&lt;p&gt;2020年12月31日晚23点30分，我发了2020年的最后一个朋友圈：假期吃透Seata源码，有组队的吗？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210102235403697.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不少小伙伴都来点赞了， &lt;strong&gt;其中也包括Seata项目的发起人——季敏大佬哦！&lt;/strong&gt; 点赞部分截图如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210102235417170.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然说了，就要行动，这不元旦假期我就在家死磕了两天Seata源码。从主体脉络上理清了Seata源码的结构和主要的框架代码。个人感觉还是比较清晰和易懂的。后续再发文为小伙伴们详细介绍吧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210103000125726.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;节后，我也要和猫大人一起发力合著书籍了，希望尽快出版，这本书的内容是相当硬核的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来，晒一晒我之前出版的两本书吧，刚刚拍的，我也不咋会拍照，大家凑合看吧。这两本书也是相当硬核的。&lt;/p&gt;
&lt;p&gt;《海量数据处理与大数据技术实战》详细总结了冰河在亿级流量、高并发场景下，如何构建海量数据离线批处理计算平台与在线实时计算平台的经验，书中很多场景和案例来源于冰河实际工作中，对商品实时精准推荐平台的架构设计。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210102235547381.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;《MySQL技术大全：开发、优化与运维实战》全书基于MySQL8.x编写，兼容MySQL5.x版本，涵盖MySQL基础、开发、优化、运维和架构的方方面面知识，书籍中大量的场景和案例均来源于冰河实际的工作场景，有不少案例的解决方案可直接应用于高并发、大流量的生产环境。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210102235559311.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好了，今天就到这儿吧，我是冰河，小伙伴们，大家元旦都是怎么过的呀？欢迎在下方留言呀！可以加我微信，我们一起交流技术，一起进阶，一起牛逼~~&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210102235308513.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;冰河原创pdf&quot;&gt;冰河原创PDF&lt;/h2&gt;
&lt;p&gt;关注 &lt;strong&gt;冰河技术&lt;/strong&gt; 微信公众号：&lt;/p&gt;
&lt;p&gt;回复 “&lt;strong&gt;并发编程&lt;/strong&gt;” 领取《深入理解高并发编程（第1版）》PDF文档。&lt;/p&gt;
&lt;p&gt;回复 “&lt;strong&gt;并发源码&lt;/strong&gt;” 领取《并发编程核心知识（源码分析篇 第1版）》PDF文档。&lt;/p&gt;
&lt;p&gt;回复 ”&lt;strong&gt;限流&lt;/strong&gt;“ 领取《亿级流量下的分布式解决方案》PDF文档。&lt;/p&gt;
&lt;p&gt;回复 “&lt;strong&gt;设计模式&lt;/strong&gt;” 领取《深入浅出Java23种设计模式》PDF文档。&lt;/p&gt;
&lt;p&gt;回复 “&lt;strong&gt;Java8新特性&lt;/strong&gt;” 领取 《Java8新特性教程》PDF文档。&lt;/p&gt;
&lt;p&gt;回复 “&lt;strong&gt;分布式存储&lt;/strong&gt;” 领取《跟冰河学习分布式存储技术》 PDF文档。&lt;/p&gt;
&lt;p&gt;回复 “&lt;strong&gt;Nginx&lt;/strong&gt;” 领取《跟冰河学习Nginx技术》PDF文档。&lt;/p&gt;
&lt;p&gt;回复 “&lt;strong&gt;互联网工程&lt;/strong&gt;” 领取《跟冰河学习互联网工程技术》PDF文档。&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;p&gt;微信搜一搜【冰河技术】微信公众号，关注这个有深度的程序员，每天阅读超硬核技术干货，公众号内回复【PDF】有我准备的一线大厂面试资料和我原创的超硬核PDF技术文档，以及我为大家精心准备的多套简历模板（不断更新中），希望大家都能找到心仪的工作，学习是一条时而郁郁寡欢，时而开怀大笑的路，加油。如果你通过努力成功进入到了心仪的公司，一定不要懈怠放松，职场成长和新技术学习一样，不进则退。如果有幸我们江湖再见！&lt;/p&gt;
&lt;p&gt;另外，我开源的各个PDF，后续我都会持续更新和维护，感谢大家长期以来对冰河的支持！！&lt;/p&gt;
</description>
<pubDate>Sat, 02 Jan 2021 16:21:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>撸Seata源码 2020年12月31日晚23点30分，我发了2020年的最后一个朋友圈：假期吃透Seata源码，有组队的吗？ 不少小伙伴都来点赞了， 其中也包括Seata项目的发起人——季敏大佬哦！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/14224562.html</dc:identifier>
</item>
<item>
<title>二本非科班，秋招，实习，面试，offer之路 - KANLON</title>
<link>http://www.cnblogs.com/kanlon2015/p/14224512.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kanlon2015/p/14224512.html</guid>
<description>&lt;p&gt;最近不是刚刚过了圣诞节吗？然后又准备到元旦了，迎来2021年！在微信公众号上看到小部分公众号在总结2020年了。所以就勾起自己从毕业到现在的回忆，顺便总结一下，自己如何从准备秋招到拿到offer的，算作记录一下自己的另一个阶段。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;157.26636207203&quot;&gt;
&lt;p&gt;不知不觉已经工作一年多的，我是2019年7月毕业的，但是如果算上实习就工作差不多两年了的吧。&lt;/p&gt;
&lt;p&gt;最近不是刚刚过了圣诞节吗？然后又准备到元旦了，迎来2021年！在微信公众号上看到小部分公众号在总结2020年了。所以就勾起自己从毕业到现在的回忆，顺便总结一下，自己如何从准备秋招到拿到offer的，算作记录一下自己的另一个阶段。&lt;/p&gt;
&lt;p&gt;犹记得，当初高考结束的时候后，自己填报的志愿大部分都是计算机相关的，因为从高中开始，就一直对于电脑方面比较感兴趣，可能跟自己小时候喜欢看科幻片有关吧🤣（一个科幻迷）。小时候，就觉得以后的科技应该会发展很快，感到会电脑挺厉害的，加上看好互联网的发展，所以高考填报志愿的时候，都是清一色的计算机相关专业（我个人比较独立，基本报考什么专业的，主要看自己喜欢什么！父母和亲戚的建议仅仅作为参考）。结果，由于当时候自己分不清哪些是属于计算机专业的，没有看专业所属的学院，填了个“信息与计算科学专业”（&lt;span&gt;听起来很像计算机专业的吧&lt;/span&gt;）, 它属于数学学院的。刚好广东某某学院录取的时候，把我录取进了这个专业🙃，于是乎，糊里糊涂地开始了一系列的数学的相关的学习。不过由于自己对于计算相关还是挺感兴趣，所以大二开始就开始自学计算机相关的课程，另外还加入了学校一个挺有名气的计算机相关的组织（&lt;span&gt;这个决定影响了我后面的技术发展和兴趣方向，后面有机会再来单独介绍一下&lt;/span&gt;）。后面就跟着组织里面的师兄师姐的教导和自己继续学习计算机相关的知识一直到了大四。&lt;/p&gt;
&lt;p&gt;大三升大四那个暑假，才开始去找实习&lt;span&gt;（那个时候才开始找太晚了😭，有看这篇文章的师弟师妹千万不要学我）&lt;/span&gt;，当时候找了差不多2、3个星期吧，投了100多份简历，一共才有不到5、6场面试，而且都是中小型公司。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201227175306562.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;不过当时自己的简历的确挺菜的，要实习没有实习，要好学校不是好学校，要计算机专业不是科班出身。后面面了好几次面试后，自己知道了面试大概会出怎么样的题目，然后开始边面试边刷题，可能是凭借着之前的面试经验或者可能是实习要求没有那么高，我在7月份左右的时候，拿到了广州用友网络的实习岗位😀。它是我当时拿到的唯一一个实习offer，接着就去了那里实习了2个多月。在那里实习的两个月里学习到了很多，算是自己的第一次体验了程序员的工作和生活。亲身作为一线程序员应该需要做哪些事情&lt;span&gt;（其实就是CRUD，偶尔会有比较困难的需求，但是大部分工作都还是增删改查）&lt;/span&gt;，如何去跟需求方谈需求和在项目里面与真实的产品经理接触。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201227234803555.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;第一次进入职场体验了两个月后，感觉自己还是挺适合做程序员，去上班的时候，不用穿很正式，上班大部分时间都是在写代码，与人沟通的时间比较少&lt;span&gt;（因为我是一个挺内向的人的，比较喜欢宅😅）&lt;/span&gt;，工位也比较自由，工作时间内不一定完全都需要在工作地点内，偶尔下楼逛逛也可以。这样的工作真的很适合自己，我比较喜欢自由一点，与人交流少一点的工作😜。唯一有一点不好的地方是要&lt;strong&gt;无偿加班&lt;/strong&gt;😪，在平常工作日的时候，基本上我们下班之后，还是要工作多1,2个小时，有时候是需求没完成，有时候是今天做的需求的有bug，基本很少没有加班的工作日。不过相对实习生来说，加班情况比较少，大部分时间我虽然是在下班之后还留在公司，只不过我是留在公司学习，毕竟对于自己刚刚正式接触真实职场，有很多东西需要学习。例如：公司所使用的框架，发布系统，测试流程，发布的流程，还有秋招的准备等等。感觉&lt;strong&gt;加班&lt;/strong&gt;对于程序员这个职位来说是&quot;通病&quot;，在互联网公司很少程序员这个的职位是没有加班的。&lt;/p&gt;
&lt;p&gt;到了2018年9月份左右，当时我已经实习了两个月了，然后看到的网上和学校的各种就业群里都已经发布了大公司的秋招信息，而且基本在9月，10月份大公司的秋招都基本结束了。于是为了更加专心地准备秋招，好好刷题之类的，我辞掉了实习。当时大约9月份的时候，我身边很多同学都已经拿到了大公司的offer，另外还有一个的跟我一起在用友实习的同学，拿到了vivo的移动端offfer。当时真的很焦虑，因为当时我也有开始的投秋招提前批的简历了，但是我的简历就基本都没有过😭。所以当时也才会着急辞掉实习，以便更专心地准备秋招。&lt;/p&gt;
&lt;p&gt;在辞掉实习时候，我就开始海投简历，基本不管是大公司还是小公司，先投了再说，想着赚一波面试经验也好，毕竟当时我基本没有什么面试机会。其实这时候秋招已经进入白热化阶段了，我身边很多的面试非技术的岗位的同学都已经再开始投简历了的。然后当时也去了广东工业大学，华南理工大学 等一本理科学校参加了挺多宣讲会的（基本是有笔试机会的才去，我自己所在的学校是金融相关的，基本没有技术类相关的招聘），不过当时在宣讲会上做的笔试也是基本没有过的，可能是由于现场笔试参加的人数太多了，在秋招后才觉得如果不是很有实力的，参加宣讲会也没用，跟线上笔试差不多。那时候也开始刷一些面试题了，当然也有在刷算法题，当时把《剑指offer》里面的算法题全部刷了一遍，顺便记录到自己的 github上面了 &lt;a href=&quot;https://github.com/KANLON&quot; target=&quot;_blank&quot;&gt;https://github.com/KANLON&lt;/a&gt; ，感觉帮助很大 ，后面面试后的有部分算法题是从里面出的原题。&lt;/p&gt;
&lt;p&gt;到2018年10月份的时候陆续有了一些公司的面试机会了，例如：小米，58集团，中信，建设银行，顺丰银行等。不过大部分都是&quot;一轮游&quot;，还是自己的基础知识不牢固，我依然记得当初面试小米的时候，要现场写一个这样的小算法题&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;现场手写一个简单的算法题，将链表996大小的，分成10份，每份100个，最后一个96个&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当时由于太紧张了，而且自己基本没有现场写过算法题的经验，结果耗费了很多时间，最后也挂了（&lt;strong&gt;多面试&lt;/strong&gt;的重要性😖）。后面我就继续边面试面刷题，也积累了一些面试经验，终于在10月末尾拿到了格力的offer😀（简直开心到飞起，有了第一个offer，而且碰巧我还是我们宿舍第一个拿到offer的人）。&lt;/p&gt;
&lt;p&gt;后面也陆续有收到面试通知，不过还是很少，一直面到11月底左右，在11月底的时候也收到的佛山某银行的技术岗offer。综合考虑之下，放弃了格力的offer ，和佛山某银行签订了三方协议。&lt;/p&gt;
&lt;p&gt;在2018年12月份的时候，基本所有的大公司的秋招的都结束了，我也在这个时候基本没有面试了，我打算先停止去求职了，算作拿到了勉强满意的offer了，打算春招的时候再去看看。12月份刚刚好是的六级考试的时候，我是有报考的，之前已经考过了2次，一直没有过😂，我英语方面是挺水的，想着努力试试最后一次。记得好像是六级考试前一周时间才开始准备的，之前一直在忙刷题，签三方等问题。后面上考场的考试的时候挺轻松的，作为自己大学期间最后一场在自己学校进行的考试，虽然不用在乎这场考试的成绩了，但是意义还是重大，当时写着试题的时候，总是会分神，觉得自己的大学就这样过去了。一片寂静中，在熟悉的课堂上，看着周围熟悉的环境，做着陌生的试题，眼眶莫名地湿润起来。&lt;/p&gt;
&lt;p&gt;在考完六级英语考试之后，自我感觉已经过不了的，太久没有复习英语了，从大三开始一直到最近拿到offer之前都基本没有接触英语，靠着一周“突袭”，是基本不可能的过的（后面结果成绩的出来之后，发现是自己考得最差的一次六级考试😅）。&lt;/p&gt;
&lt;p&gt;六级考试之后的一周就是考研了，我们宿舍也是有几个人考研，我大概刚上大四的时候，看到他们都报考了，想着报考也不需要多少钱，顺便学一点考研相关的知识，学习多点(chui)东(niu)西(bi)，于是我也当时也报考了。接着就跟着我们宿舍的同学一起准备考研了一周，期间还是挺有意思的，因为当时接近考研了，经常他们学习回到宿舍后都会讨论一下考研的一些题目的，当时由于我也在准备，我也常常跟着一起讨(zhuang)论(bi)。虽然我学习考研相关的还不是很久，但是还是可以挺懂其中一些的，我们有时候会相互提问一些考研相关的知识，常常当我以我一知半解的考研知识作答的时候，会引起哄堂大笑，也是一段很开心时光（也是一次不用背负成绩压力的考试准备）。当时一周，我每天都会去自习室自习的，看着周围人都在努力准备的考研的时候，自己也会感受到有一股冲动去努力自习，感受高考过后，自己很久没有那么认真过，虽然我是抱着试试的心态去考的，但是周围人的氛围会影响你的，觉得大家都那么努力，你有什么资格努力呢。当时也是有好好准备了一些资料来看的。如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210102183845202.PNG&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就这样，一直努力到考研考试那天，当时一周我也是全心身投入到考研考试中了。说一个小意外，当时为了节省点钱，我考研的时候并没有在考点周围租房，因为自己也是试试考研的，没有必要单独租房，从我们学校出发到考点那里大概2个小时左右，如果我6点从学校起床刚好是可以到达考点的地方，然后第一天去考试的时候，没想到会那么塞车，差点不能进入考场了，记得当时考试已经开始了5,6分钟了的，如果再迟10分钟左右估计就不能进入考场（这也是算我第一次考试开始后，都还没到考场的考试吧🙃）。&lt;/p&gt;
&lt;p&gt;当然最后的考试考研结果是：&lt;br/&gt;。。。。。。。。&lt;br/&gt;。。。。。。。。&lt;br/&gt;。。。。。。。。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210102184112532.PNG&quot; alt=&quot;考研成绩单&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;不过啦！&lt;/p&gt;
&lt;p&gt;不得不说，虽然我是数学相关专业的，但是太久没有接触的话，很容易忘记的💀。&lt;/p&gt;
&lt;p&gt;就这样算作过了2018年吧，后面到2019年上半年过年前，基本就是写毕业论文，拍毕业照，准备毕业的东西了。当时也有为了准备一下春招，开始准备找一份实习，海投面试了很多小公司，大公司也基本没有回😰。后面还是遇到一个机会，我们部落社团内的一个在YY实习的同学，在群里发了Java开发实习生岗位内推信息，说他们组正在找招人，于是想着自己有了一次实习经验了，凭借之前面试经验，也刷了不少题，所以也就投了（其实我们学校跟我同一届的同学就有好几个进入YY实习过的，不过之前我认为我技术没过关，然后一直不敢投）。后面运气比较好，面试问的问题都没有太难，现场让我手写的算法题也很顺利的写出来的。于是在1月份左右，我在就开始在YY实习了，当然这时候的实习一般是没有转正名额，当时HR就明确跟我说是没有转正名额的。不过我也没有想着转正，毕竟秋招已经过了，一般很少大公司会在春招招人的，我也是报着学习的心态来实习的。&lt;/p&gt;
&lt;p&gt;2019年一份月我是刚入职实习的，基本就是在的熟悉环境，了解一下部门组织体系，公司的部门等，没有做什么。在入职没多久之后，就开始放春节假期了，我在YY的实习工作，算作从过年回来之后才开始。刚刚开始接触YY这边的技术的，发现这里的技术用的都是比较新的技术，而且大部分是都是Spring Cloud 之类开源的框架，挺容易上手的，感觉自己还真是来对了地方（因为我上一家实习公司用的是是公司团队完全自己开发的一套框架，而且比较老的，如果遇到问题想百度一下都百度不到😔）。但是由于YY这边的用的技术我之前没有怎么用过，所以过年回来之后，我基本都是边看这边的项目结构，边在网上学习对应的框架用法。刚开始那段时间真的有点痛苦，随便看项目基本框架任意一部分都基本看不懂，于是基本上我在刚开始实习那会，天天自己加班到21、22点，在网上学习对应的框架，对着官方文档或一些博客自己先搭个 demo 出来。那时候虽然有很多不懂，但是学着学着就慢慢地摸清了项目中的使用的框架，另外对当时微服务的架构都有了比较深的了解。那时候给我的需求还不是很多，我一般都是边做需求，边学习新技术的，经常在周六、日的时候都会过来公司这边学习技术。不得不说，在比较大一点的公司里实习，学习到的东西会有很多的，对于自己的提升也会很大。例如需求这方面，我在YY这边的做的需求除了一些简单的 Crud 工作，还能应用微服务，消息队列等技术，而且基本上会放手这个需求给当时我这个实习生去负责。另外，由于是比较大的公司的，部门服务分工明确，YY 这边的数据库、域名网络、部署方面都有专门的部门的去负责的，申请数据库、域名、服务器和部署服务之类的都很简单，让开发自己专注于业务代码代码即可。当然如果想自己了解底层架构相关的东西也可以，可以找对应的部门问问，或者自己去申请服务器去自己搭一下试试也可以。总之当时在YY实习那会学习到的东西，感觉比自己之前学习到的编程技术都多，感觉自己技术水平突然有了质的提升（大概就是学习到了很多，不知道怎么表达了🤓）。&lt;/p&gt;
&lt;p&gt;在这种情况下实习到大概4，5月份的时候，我看到春招了已经有很多公司开始了（不包含YY，YY一般技术类的没有春招😢），虽然没有秋招那么多大公司在招聘，但是还是有几个中大厂还在招技术（春招比秋招的机会少太多😪）。于是我也去投了一波中大厂，然后春招我就只有一个的面试机会，CVTE 的，记得当时 CVTE 秋招挂了我简历和笔试的，接着又是面试，当时面试几天后，进入了HR面，但是最后HR面挂了我，只能说是无缘了。期间还有一个意外惊喜，大概就是我面试CVTE的时候，我们组组长告诉了我一个好消息，说看到我做事认真，技术还不错，可以给我转正！！！当时就差点感动哭了，之前我一直都是以为不可能转正的。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210102231124246.gif&quot; alt=&quot;感动到哭&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后我后面跟YY这边HR说我没有三方的时候，他们说没有三方也可以的。于是，我快速联系之前跟之前签了三方佛山某银行HR道歉说，我不能去他们那里上班了，我接了其他公司的offer，让他们给我方式交三方违约金（这个违约金为8000，还是有一点点心疼）。那边的HR也是打电话来，跟我二次确认，问了我的一些情况，后面也同意。不过在这里还是再次对佛山某银行说声对不起的，十分感谢他们当时给了我offer，也很抱歉由于个人原因毁了三方。&lt;/p&gt;
&lt;p&gt;就这样，我的找工作之路到这里就结束了，后面我就一直在欢聚时代这边工作了，正常转正，正常工作。回顾一下自己找工作的经历，还是挺曲折的。不过最后的结果，对于我个人来说已经很满意了，毕竟自己大学时候没有早点认识到自己应该学习的东西，没有早点积累技术，虽然比不上我们学校部落社团同届那些去了阿里，今日头条等大公司的大佬，但是他们的确大学的时候比我勤奋，比我更努力和更早一步比我先学习。有时候是真的羡慕不来的，人与人可能差距就那么大，做好自己能做好的事情就够了。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;我个人的找工作经历就是这样的，原本想着写经历一直写到现在工作两年后的情况，后面发现时间不太够，也不太符合这次的主题，就分开了，后面有机会在补充。又准备到一年一次的秋招了，在这里给几点建议即将准备就业的同学吧：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;秋招的提前批和秋招是技术类找工作的最好时机，如果错过了秋招，基本很难进大公司。&lt;/li&gt;
&lt;li&gt;能尽早去实习的尽快去，最好在秋招前的一个寒假就去实习了&lt;/li&gt;
&lt;li&gt;多提前去面试，面试多几次积累一下经验也不错&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;</description>
<pubDate>Sat, 02 Jan 2021 15:52:00 +0000</pubDate>
<dc:creator>KANLON</dc:creator>
<og:description>最近不是刚刚过了圣诞节吗？然后又准备到元旦了，迎来2021年！在微信公众号上看到小部分公众号在总结2020年了。所以就勾起自己从毕业到现在的回忆，顺便总结一下，自己如何从准备秋招到拿到offer的，算</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kanlon2015/p/14224512.html</dc:identifier>
</item>
<item>
<title>JustAuth 1.15.9 版发布，支持飞书、喜马拉雅、企业微信网页登录 - HandsomeBoy丶</title>
<link>http://www.cnblogs.com/zhangyadong/p/14224502.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyadong/p/14224502.html</guid>
<description>&lt;p&gt;JustAuth 1.15.9 版发布，支持飞书、喜马拉雅、企业微信网页登录&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;59.228989813243&quot;&gt;
&lt;h2&gt;新增&lt;/h2&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;修复并正式启用 飞书 平台的第三方登录&lt;/li&gt;
&lt;li&gt;AuthToken 类中新增 refreshTokenExpireIn 记录 refresh token 的有效期&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;PR&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;合并 Github &lt;a href=&quot;https://gitee.com/yadong.zhang/JustAuth/pulls/101&quot;&gt;#101&lt;/a&gt;：支持喜马拉雅登录&lt;/li&gt;
&lt;li&gt;合并 Github &lt;a href=&quot;https://gitee.com/yadong.zhang/JustAuth/pulls/101&quot;&gt;#105&lt;/a&gt;：支持企业微信网页授权登录&lt;/li&gt;
&lt;li&gt;合并 Github &lt;a href=&quot;https://gitee.com/yadong.zhang/JustAuth/pulls/107&quot;&gt;#107&lt;/a&gt;：添加AuthAlipayRequest网络代理构造器，解决 Github Issue [#102](feat:代理问题,代理能否可配置化 · Issue #102 · justauth/JustAuth)&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;修改&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;修改喜马拉雅配置参数，将ClientOsType参数提到 AuthConfig 中&lt;/li&gt;
&lt;li&gt;AuthChecker 中增加对喜马拉雅平台的校验&lt;/li&gt;
&lt;li&gt;升级 facebook api 版本到 v9.0，解决 Gitee Issue [#I2AR5S](升级 facebook api 版本 · Issue #I2AR5S · yadong.zhang/JustAuth - Gitee.com)&lt;/li&gt;
&lt;li&gt;！！！注意！！！修改原来的企业微信 Request 类名为 AuthWeChatEnterpriseQrcodeRequest，升级后注意该点&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;注意&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;可能有些开发者对于 JA 集成的四个微信平台不太理解，这儿统一说明：&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h3&gt;按照类名&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;AuthWeChatEnterpriseQrcodeRequest：企业微信二维码登录&lt;/li&gt;
&lt;li&gt;AuthWeChatEnterpriseWebRequest：企业微信网页登录&lt;/li&gt;
&lt;li&gt;AuthWeChatOpenRequest：微信开放平台&lt;/li&gt;
&lt;li&gt;AuthWeChatMpRequest：微信公众平台&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h3&gt;按照枚举&lt;/h3&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ul&gt;&lt;li&gt;WECHAT_ENTERPRISE：企业微信二维码登录&lt;/li&gt;
&lt;li&gt;WECHAT_ENTERPRISE_WEB：企业微信网页登录&lt;/li&gt;
&lt;li&gt;WECHAT_OPEN：微信开放平台&lt;/li&gt;
&lt;li&gt;WECHAT_MP：微信公众平台&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;关于 Just Auth&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;8&quot;&gt;
&lt;p&gt;JustAuth，如你所见，它仅仅是一个第三方授权登录的工具类库，它可以让我们脱离繁琐的第三方登录SDK，让登录变得So easy!&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;11&quot;&gt;
&lt;p&gt;目前已支持Github、Gitee、微博、钉钉、百度、Coding、腾讯云开发者平台、OSChina、支付宝、QQ、微信、淘宝、Google、Facebook、抖音、领英、小米、微软、今日头条、Teambition、StackOverflow、Pinterest、人人、华为、企业微信、酷家乐、Gitlab、美团、饿了么和推特等第三方平台的授权登录。 Login, so easy!&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;部分用户&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;p&gt;&lt;img src=&quot;http://img3.sycdn.imooc.com/5ff0958e000135ca11800303.jpg&quot; alt=&quot;image.png&quot; data-original=&quot;http://img3.sycdn.imooc.com/5ff0958e000135ca11800303.jpg&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;特点&lt;/h2&gt;
&lt;/p&gt;
&lt;div class=&quot;cl-preview-section&quot; readability=&quot;7&quot;&gt;
&lt;p&gt;废话不多说，就俩字：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;cl-preview-section&quot;&gt;
&lt;ol&gt;&lt;li&gt;全：已集成十多家第三方平台（国内外常用的基本都已包含），仍然还在持续扩展中（[开发计划]([开发计划] 待扩展的第三方平台 · Issue #IUGRK · yadong.zhang/JustAuth - Gitee.com)）！&lt;/li&gt;
&lt;li&gt;简：API就是奔着最简单去设计的，尽量让您用起来没有障碍感！&lt;/li&gt;
&lt;/ol&gt;&lt;/div&gt;
&lt;p&gt;
&lt;h2&gt;项目源码库&lt;/h2&gt;
&lt;/p&gt;


&lt;/div&gt;</description>
<pubDate>Sat, 02 Jan 2021 15:49:00 +0000</pubDate>
<dc:creator>HandsomeBoy丶</dc:creator>
<og:description>JustAuth 1.15.9 版发布，支持飞书、喜马拉雅、企业微信网页登录</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangyadong/p/14224502.html</dc:identifier>
</item>
<item>
<title>VIM和正则表达式 - bestvae</title>
<link>http://www.cnblogs.com/bestvae/p/14224477.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bestvae/p/14224477.html</guid>
<description>&lt;h2 id=&quot;1vim&quot;&gt;1.VIM&lt;/h2&gt;
&lt;h3 id=&quot;11vim简介&quot;&gt;1.1vim简介&lt;/h3&gt;
&lt;p&gt;vim是一款强大的文本编辑器，它和 vi 使用方法一致，但功能更为强大。官网：www.vim.org、中文手册：&lt;a href=&quot;http://vimcdoc.sourceforge.net/&quot; target=&quot;_blank&quot;&gt;http://vimcdoc.sourceforge.net/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;12使用vim&quot;&gt;1.2使用vim&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.2.1命令格式&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;vim [options] [file ..]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;+# 打开文件后，让光标处于第#行的行首，+默认行尾&lt;/li&gt;
&lt;li&gt;+/PATTERN 让光标处于第一个被PATTERN匹配到的行行首&lt;/li&gt;
&lt;li&gt;-d file1 file2… 比较多个文件，相当于 vimdiff&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：当使用vim打开文件的时候，如果该文件存在，文件被打开并显示内容。如果该文件不存在，当编辑后第一次存盘时创建它&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.2.2vim三种模式的切换&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;三种模式分为&lt;/p&gt;
&lt;p&gt;命令或普通模式、插入模式、扩展模式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;命令模式 --&amp;gt; 插入模式&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;i insert, 在光标所在处输入
I 在当前光标所在行的行首输入
a append, 在光标所在处后面输入
A 在当前光标所在行的行尾输入
o 在当前光标所在行的下方打开一个新行
O 在当前光标所在行的上方打开一个新行
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;插入模式 --- ESC-----&amp;gt; 命令模式&lt;/li&gt;
&lt;li&gt;命令模式 ---- : ----&amp;gt; 扩展命令模式&lt;/li&gt;
&lt;li&gt;扩展命令模式 ----ESC,enter----&amp;gt; 命令模式&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;13扩展命令模式&quot;&gt;1.3扩展命令模式&lt;/h3&gt;
&lt;h5 id=&quot;131-基本命令&quot;&gt;1.3.1 基本命令&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;w              写（存）磁盘文件
wq      写入并退出
x               写入并退出加密
q               退出，如果修改了内容无法退出
q！   强制不存盘退出，即使更改都将丢失
r filename 读文件内容到当前文件中
!command        执行命令
r!command       读入命令的输出
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;132-地址定界&quot;&gt;1.3.2 地址定界&lt;/h5&gt;
&lt;p&gt;格式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;:start_pos,end_pos CMD
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;地址定界符&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#                      #具体第#行，例如2表示第2行
#,#             #从左侧#表示起始行，到右侧#表示结尾行
#,+#            #从左侧#表示的起始行，加上右侧#表示的行数，范例：2,+3 表示2到5行
.               #当前行
$                       #最后一行
.,$-1   #当前行到倒数第二行
%                       #全文, 相当于1,$

/pattern/       #从当前行向下查找，直到匹配pattern的第一行,即:正则表达式
/pat1/,/pat2/   #从第一次被pat1模式匹配到的行开始，一直到第一次被pat2匹配到的行结束
#,/pat/         #从指定行开始，一直找到第一个匹配patttern的行结束
/pat/,$         #向下找到第一个匹配patttern的行到整个文件的结尾的所有行
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;地址定界后可跟一个编辑命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;d              #删除
y                       #复制
w file  #将范围内的行另存至指定文件中
r file  #在指定位置插入指定文件中的所有内容
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;133-查找和替换&quot;&gt;1.3.3 查找和替换&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;s/要查找的内容/替换为的内容/修饰符
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;要查找的内容：可使用基末正则表达式模式
替换为的内容：不能使用模式，但可以使用\1, \2, ...等后向引用符号；还可以使用“&amp;amp;”引用前面查找时查
找到的整个内容
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;修饰符：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;i #忽略大小写
g #全局替换，默认情况下，每一行只替换第一次出现
gc #全局替换，每次替换前询问
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;查找替换中的分隔符/可替换为其它字符，如：#,@&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;s@/etc@/var@g
s#/boot#/#i
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;134-定制vim&quot;&gt;1.3.4 定制vim&lt;/h5&gt;
&lt;p&gt;配置文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;/etc/vimrc #全局
~/.vimrc #个人

#行号
显示：set number，简写 set nu
取消显示：set nonumber, 简写 set nonu

#忽略字符的大小写
启用：set ignorecase，简写 set ic
不忽略：set noic

#自动缩进
启用：set autoindent，简写 set ai
禁用：set noai

#设置光标所在行的标识线
启用：set cursorline，简写 set cul
禁用：set nocursorline

#Tab用指定空格的个数代替
启用：set tabstop=# 指定#个空格代替Tab
简写：set ts=4

#文件格式
启用windows格式：set fileformat=dos
启用unix格式：set fileformat=unix
简写 set ff=dos|unix

#Tab 用空格代替
启用：set expandtab 默认为8个空格代替Tab
禁用：set noexpandtab
简写：set et 

#语法高亮
启用：syntax on
禁用：syntax of

#高亮搜索
启用：set hlsearch
禁用：set nohlsearch

#显示Tab和换行符 ^I 和$显示
启用：set list
禁用：set nolist

#set showcmd
显示命令模式下输入的字符
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;14-命令模式&quot;&gt;1.4 命令模式&lt;/h3&gt;
&lt;h5 id=&quot;141-退出vim&quot;&gt;1.4.1 退出VIM&lt;/h5&gt;
&lt;p&gt;ZZ | wq 保存退出&lt;/p&gt;
&lt;p&gt;ZQ | q 不保存退出&lt;/p&gt;
&lt;h5 id=&quot;142-光标跳转&quot;&gt;1.4.2 光标跳转&lt;/h5&gt;
&lt;p&gt;字符间跳转：&lt;/p&gt;
&lt;p&gt;h: 左 L: 右 j: 下 k: 上&lt;/p&gt;

&lt;p&gt;单词间跳转：&lt;/p&gt;
&lt;p&gt;w：下一个单词的词首&lt;/p&gt;
&lt;p&gt;e：当前或下一单词的词尾&lt;/p&gt;
&lt;p&gt;b：当前或前一个单词的词首&lt;/p&gt;

&lt;p&gt;当前页跳转：&lt;/p&gt;
&lt;p&gt;H：页首 M：页中间行 L：页底&lt;/p&gt;
&lt;p&gt;zt：将光标所在当前行移到屏幕顶端&lt;/p&gt;
&lt;p&gt;zz：将光标所在当前行移到屏幕中间&lt;/p&gt;
&lt;p&gt;zb：将光标所在当前行移到屏幕底端&lt;/p&gt;
&lt;p&gt;行首行尾跳转：&lt;/p&gt;
&lt;p&gt;^ 跳转至行首的第一个非空白字符&lt;/p&gt;
&lt;p&gt;0 跳转至行首&lt;/p&gt;
&lt;p&gt;$ 跳转至行尾&lt;/p&gt;
&lt;p&gt;行间移动：&lt;/p&gt;
&lt;p&gt;#G 或者扩展命令模式下 :# 跳转至由第#行&lt;/p&gt;
&lt;p&gt;G 最后一行&lt;/p&gt;
&lt;p&gt;1G, gg 第一行&lt;/p&gt;
&lt;p&gt;命令模式翻屏操作&lt;/p&gt;
&lt;p&gt;Ctrl+f 向文件尾部翻一屏&lt;/p&gt;
&lt;p&gt;Ctrl+b 向文件首部翻一屏&lt;/p&gt;
&lt;p&gt;Ctrl+d 向文件尾部翻半屏&lt;/p&gt;
&lt;p&gt;Ctrl+u 向文件首部翻半屏&lt;/p&gt;
&lt;h5 id=&quot;143-字符编辑&quot;&gt;1.4.3 字符编辑&lt;/h5&gt;
&lt;p&gt;x 删除光标处的字符&lt;/p&gt;

&lt;p&gt;xp 交换光标所在处的字符及其后面字符的位置&lt;/p&gt;
&lt;h5 id=&quot;144-替换命令replace&quot;&gt;1.4.4 替换命令(replace)&lt;/h5&gt;
&lt;p&gt;r 只替换光标所在处的一个字符&lt;/p&gt;
&lt;p&gt;R 切换成REPLACE模式（在末行出现-- REPLACE -- 提示）,按ESC回到命令模式&lt;/p&gt;
&lt;h5 id=&quot;145-删除命令（delete）&quot;&gt;1.4.5 删除命令（delete）&lt;/h5&gt;
&lt;p&gt;d 删除命令，可结合光标跳转字符，实现范围删除&lt;/p&gt;
&lt;p&gt;d$ 删除到行尾&lt;/p&gt;
&lt;p&gt;d^ 删除到非空行首&lt;/p&gt;
&lt;p&gt;d0 删除到行首&lt;/p&gt;
&lt;p&gt;dd： 剪切光标所在的行&lt;/p&gt;

&lt;p&gt;D：从当前光标位置一直删除到行尾，等同于d$&lt;/p&gt;
&lt;h5 id=&quot;146-复制命令yank&quot;&gt;1.4.6 复制命令(yank)&lt;/h5&gt;
&lt;p&gt;y 复制，行为相似于d命令&lt;/p&gt;
&lt;h5 id=&quot;147-粘贴命令paste&quot;&gt;1.4.7 粘贴命令(paste)&lt;/h5&gt;
&lt;p&gt;p 缓冲区存的如果为整行，则粘贴当前光标所在行的下方；否则，则粘贴至当前光标所在处的后面&lt;/p&gt;
&lt;p&gt;P 缓冲区存的如果为整行，则粘贴当前光标所在行的上方；否则，则粘贴至当前光标所在处的前面&lt;/p&gt;
&lt;h5 id=&quot;148-改变命令change&quot;&gt;1.4.8 改变命令(change)&lt;/h5&gt;
&lt;p&gt;c: 删除后切换成插入模式&lt;/p&gt;
&lt;p&gt;c$&lt;/p&gt;
&lt;p&gt;c^&lt;/p&gt;
&lt;p&gt;c0&lt;/p&gt;
&lt;p&gt;cb&lt;/p&gt;
&lt;h5 id=&quot;149-查找&quot;&gt;1.4.9 查找&lt;/h5&gt;
&lt;p&gt;/PATTERN：从当前光标所在处向文件尾部查找&lt;/p&gt;
&lt;p&gt;?PATTERN：从当前光标所在处向文件首部查找&lt;/p&gt;
&lt;p&gt;n：与命令同方向&lt;/p&gt;
&lt;p&gt;N：与命令反方向&lt;/p&gt;
&lt;h5 id=&quot;1410-撤消更改&quot;&gt;1.4.10 撤消更改&lt;/h5&gt;
&lt;p&gt;u 撤销最近的更改，相当于windows中ctrl+z&lt;/p&gt;
&lt;p&gt;#u 撤销之前多次更改&lt;/p&gt;
&lt;p&gt;U 撤消光标落在这行后所有此行的更改&lt;/p&gt;
&lt;p&gt;Ctrl - r 重做最后的“撤消”更改，相当于windows中crtl+y&lt;/p&gt;
&lt;p&gt;. 重复前一个操作&lt;/p&gt;

&lt;h5 id=&quot;1411-高级用法&quot;&gt;1.4.11 高级用法&lt;/h5&gt;
&lt;p&gt;常见Command：y 复制、d 删除、gU 变大写、gu 变小写&lt;/p&gt;
&lt;p&gt;范例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;0y$ 命令
#粘贴一个字符100次
100ihello [ESC] 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;di&quot; 光标在” “之间，则删除” “之间的内容&lt;/p&gt;
&lt;p&gt;yi( 光标在()之间，则复制()之间的内容&lt;/p&gt;
&lt;p&gt;vi[ 光标在[]之间，则选中[]之间的内容&lt;/p&gt;
&lt;p&gt;dtx 删除字符直到遇见光标之后的第一个 x 字符&lt;/p&gt;
&lt;p&gt;ytx 复制字符直到遇见光标之后的第一个 x 字符&lt;/p&gt;
&lt;h3 id=&quot;15-可视化模式&quot;&gt;1.5 可视化模式&lt;/h3&gt;
&lt;p&gt;在末行有”-- VISUAL -- “指示，表示在可视化模式&lt;/p&gt;
&lt;p&gt;进入可视化模式按键&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;v 面向字符，-- VISUAL --&lt;/li&gt;
&lt;li&gt;V 面向整行，-- VISUAL LINE --&lt;/li&gt;
&lt;li&gt;ctrl-v 面向块，-- VISUAL BLOCK --&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;16-多文件模式&quot;&gt;1.6 多文件模式&lt;/h3&gt;
&lt;p&gt;vim FILE1 FILE2 FILE3 ...&lt;/p&gt;
&lt;p&gt;:next 下一个&lt;/p&gt;
&lt;p&gt;:prev 前一个&lt;/p&gt;
&lt;p&gt;:first 第一个&lt;/p&gt;
&lt;p&gt;:last 最后一个&lt;/p&gt;
&lt;p&gt;:wall 保存所有&lt;/p&gt;
&lt;p&gt;:qall 不保存退出所有&lt;/p&gt;
&lt;p&gt;:wqall保存退出所有&lt;/p&gt;
&lt;h3 id=&quot;17-多窗口模式&quot;&gt;1.7 多窗口模式&lt;/h3&gt;
&lt;h5 id=&quot;171-多文件分割&quot;&gt;1.7.1 多文件分割&lt;/h5&gt;
&lt;p&gt;vim -o|-O FILE1 FILE2 ...&lt;/p&gt;
&lt;p&gt;-o: 水平或上下分割&lt;/p&gt;
&lt;p&gt;-O: 垂直或左右分割（vim only）&lt;/p&gt;
&lt;p&gt;在窗口间切换：Ctrl+w+方向键&lt;/p&gt;
&lt;h5 id=&quot;172-单文件窗口分割&quot;&gt;1.7.2 单文件窗口分割&lt;/h5&gt;
&lt;p&gt;Ctrl+w+s：split, 水平分割，上下分屏&lt;/p&gt;
&lt;p&gt;Ctrl+w+v：vertical, 垂直分割，左右分屏&lt;/p&gt;
&lt;p&gt;ctrl+w+q：取消相邻窗口&lt;/p&gt;
&lt;p&gt;ctrl+w+o：取消全部窗口&lt;/p&gt;
&lt;p&gt;:wqall 退出&lt;/p&gt;
&lt;h3 id=&quot;18-vim寄存器&quot;&gt;1.8 vim寄存器&lt;/h3&gt;
&lt;p&gt;有26个命名寄存器和1个无命名寄存器，常存放不同的剪贴版内容，可以在同一个主机的不同会话（终 端窗口）间共享&lt;/p&gt;
&lt;p&gt;寄存器名称a，b,…,z,格式： ”寄存器 放在数字和命令之间&lt;/p&gt;
&lt;p&gt;范例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;3&quot;tyy 表示复制3行到t寄存器中 ，末行显示 3 lines yanked into &quot;t
&quot;tp 表示将t寄存器内容粘贴
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;19-标记和宏macro&quot;&gt;1.9 标记和宏(macro)&lt;/h3&gt;
&lt;p&gt;ma 将当前位置标记为a，26个字母均可做标记， mb 、 mc 等等&lt;/p&gt;
&lt;p&gt;'a 跳转到a标记的位置，实用的文档内标记方法，文档中跳跃编辑时很有用&lt;/p&gt;
&lt;p&gt;qa 录制宏 a，a为宏的名称，末行提示： recording @a&lt;/p&gt;
&lt;p&gt;q 停止录制宏&lt;/p&gt;
&lt;p&gt;@a 执行宏 a&lt;/p&gt;
&lt;p&gt;@@ 重新执行上次执行的宏&lt;/p&gt;
&lt;h2 id=&quot;2-文本常见处理工具&quot;&gt;2 文本常见处理工具&lt;/h2&gt;
&lt;h3 id=&quot;21查看文件内容&quot;&gt;2.1查看文件内容&lt;/h3&gt;
&lt;h5 id=&quot;211-cat&quot;&gt;2.1.1 cat&lt;/h5&gt;
&lt;p&gt;cat 可以查看文本内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;cat [OPTION]... [FILE]...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常见选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-E：显示行结束符$&lt;/li&gt;
&lt;li&gt;-A：显示所有控制符&lt;/li&gt;
&lt;li&gt;-n：对显示出的每一行进行编号&lt;/li&gt;
&lt;li&gt;-b：非空行编号&lt;/li&gt;
&lt;li&gt;-s：压缩连续的空行成一行&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;212-nl&quot;&gt;2.1.2 nl&lt;/h5&gt;
&lt;p&gt;nl：显示行号，相当于cat -b&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;nl [OPTION]... [FILE]...       
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;213-tac&quot;&gt;2.1.3 tac&lt;/h5&gt;
&lt;p&gt;tac：逆向显示文本内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;tac [OPTION]... [FILE]...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;214-rev&quot;&gt;2.1.4 rev&lt;/h5&gt;
&lt;p&gt;rev：将同一行的内容逆向显示&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;rev [option] [file...]
[root@centos8 data]# rev lx.txt 
ba321
[root@centos8 data]# cat lx.txt 
123ab
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;215-hexdump&quot;&gt;2.1.5 hexdump&lt;/h5&gt;
&lt;p&gt;hexdump：以十六进制，十进制，八进制或ASCII显示文件内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;hexdump [options] file...

-C 十六进制+ASCII显示
[root@centos8 data]# hexdump -C lx.txt 
00000000  31 32 33 61 62 0a                                 |123ab.|
00000006
[root@centos8 data]# cat lx.txt 
123ab
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22分页查看文本内容&quot;&gt;2.2分页查看文本内容&lt;/h3&gt;
&lt;h5 id=&quot;221-more&quot;&gt;2.2.1 more&lt;/h5&gt;
&lt;p&gt;more：分页查看文件（文本翻至尾部就会自动退出）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;more [options] file...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常见选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-d 显示翻页以及退出提示&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;222-less&quot;&gt;2.2.2 less&lt;/h5&gt;
&lt;p&gt;less：分页查看文件（文本末页不会自动退出）&lt;/p&gt;
&lt;p&gt;less 命令是man命令使用的分页器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@centos8 data]# cat passwd | less
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;23-显示文本前或后行内容&quot;&gt;2.3 显示文本前或后行内容&lt;/h3&gt;
&lt;h5 id=&quot;231-head&quot;&gt;2.3.1 head&lt;/h5&gt;
&lt;p&gt;head：显示文件或者标准输入前面内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;head [OPTION]... [FILE]...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常见选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-c # 指定获取前#字节&lt;/li&gt;
&lt;li&gt;-n # 指定获取前#行&lt;/li&gt;
&lt;li&gt;-# 同上&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;范例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@centos8 data]# head -2 lx.txt 
1
2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;232-tail&quot;&gt;2.3.2 tail&lt;/h5&gt;
&lt;p&gt;tail：和head 相反，查看文件或标准输入的倒数行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;tail [OPTION]... [FILE]...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-c # 指定获取后#字节&lt;/li&gt;
&lt;li&gt;-n # 指定获取后#行&lt;/li&gt;
&lt;li&gt;-# 同上&lt;/li&gt;
&lt;li&gt;-f 跟踪显示文件fd新追加的内容,常用日志监控，相当于 --follow=descriptor,当文件删除再新建同名 文件,将无法继续跟踪文件&lt;/li&gt;
&lt;li&gt;-F 跟踪文件名，相当于--follow=name --retry，当文件删除再新建同名文件,将可以继续跟踪文件&lt;/li&gt;
&lt;li&gt;tailf 类似 tail –f，当文件不增长时并不访问文件&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;范例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@centos8 data]# tail -2 /data/lx.txt 
9
10
#只查看最新发生的日志
[root@centos8 data]# tail -fn0 /data/lx.txt 
ab
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;24-cut&quot;&gt;2.4 cut&lt;/h3&gt;
&lt;p&gt;cut：提取文本文件或者STDIN数据指定列&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;cut OPTION... [FILE]...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用选项&lt;/p&gt;
&lt;ul readability=&quot;5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;-d DELIMITER: 指明分隔符，默认tab&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;9&quot;&gt;
&lt;p&gt;-f FILEDS:&lt;/p&gt;
&lt;p&gt;​ #: 第#个字段,例如:3&lt;/p&gt;
&lt;p&gt;​ #,#[,#]：离散的多个字段，例如:1,3,6&lt;/p&gt;
&lt;p&gt;​ #-#：连续的多个字段, 例如:1-6&lt;/p&gt;
&lt;p&gt;​ 混合使用：1-3,7&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;-c 按字符切割&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;--output-delimiter=STRING指定输出分隔符&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;范例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#查看主机IP地址
[root@centos8 data]# ifconfig | head -2 | tail -1 | tr -s ' ' | cut -d' ' -f3
172.22.73.89
#显示df命令中磁盘使用率
[root@centos8 data]# df | tr -s ' ' | cut -d' ' -f5 | tr -dc '[0-9\n]'
0
0
[root@centos8 data]# df | tr -s ' ' % | cut -d% -f5 | tr -d [:alpha:]

0
0
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;25-paste&quot;&gt;2.5 paste&lt;/h3&gt;
&lt;p&gt;paste：合并多个文件同行号列到一行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;paste [OPTION]... [FILE]...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-d 分隔符：指定分隔符，默认用TAB&lt;/li&gt;
&lt;li&gt;-s : 所有行合成一行显示&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;26-文本分析工具&quot;&gt;2.6 文本分析工具&lt;/h3&gt;
&lt;h5 id=&quot;261-wc&quot;&gt;2.6.1 wc&lt;/h5&gt;
&lt;p&gt;wc：统计文件的行总数、单词总数、字节总数和字符总数&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;wc [OPTION]... [FILE]...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-l 只计数行数&lt;/li&gt;
&lt;li&gt;-w 只计数单词总数&lt;/li&gt;
&lt;li&gt;-L 显示文件中最长行的长度&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@centos8 data]# wc -l lx.txt 
2 lx.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;262-sort&quot;&gt;2.6.2 sort&lt;/h5&gt;
&lt;p&gt;sort：把整理过的文本显示在STDOUT，不改变原始文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sort [OPTION]... [FILE]...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-r 执行反方向（由上至下）整理&lt;/li&gt;
&lt;li&gt;-R 随机排序&lt;/li&gt;
&lt;li&gt;-n 执行按数字大小整理&lt;/li&gt;
&lt;li&gt;-u 选项（独特，unique），合并重复项，即去重&lt;/li&gt;
&lt;li&gt;-t c 选项使用c做为字段界定符&lt;/li&gt;
&lt;li&gt;-k 指定排序的关键字&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;范例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#统计日志访问量
[root@centos8 data]#cut -d&quot; &quot; -f1 /var/log/nginx/access_log |sort -u|wc -l
201

[root@centos8 data]# cut -d: -f1,3 passwd | sort -k2 -nr | head -5
user3:2004
user2:2003
user1:1002
user:1001
unbound:996
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;263-uniq&quot;&gt;2.6.3 uniq&lt;/h5&gt;
&lt;p&gt;uniq：命令从输入中删除前后相接的重复的行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;uniq [OPTION]... [INPUT [OUTPUT]]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-c: 显示每行重复出现的次数&lt;/li&gt;
&lt;li&gt;-d: 仅显示重复过的行&lt;/li&gt;
&lt;li&gt;-u: 仅显示不曾重复的行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;uniq常和sort 命令一起配合使用：&lt;/p&gt;
&lt;p&gt;范例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;#统计日志访问量最多的请求
[root@centos8 data]# cut -d&quot; &quot; -f1 access_log | sort | uniq -c | sort -nr | head -1
2834 172.20.0.222

#取两个文件的相同行
[root@centos8 data]# cat a.txt b.txt | sort | uniq -d
200
#取两个文件的不同行
[root@centos8 data]# cat a.txt b.txt | sort | uniq -u
100
123
23
3321
34556
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;264-diff&quot;&gt;2.6.4 diff&lt;/h5&gt;
&lt;p&gt;diff：令比较两个文件之间的区别&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;diff [OPTION]... FILES

[root@centos8 data]# cat a.txt b.txt 
a
b
c
a
b
bc
[root@centos8 data]# diff a.txt b.txt 
3c3
&amp;lt; c
---
&amp;gt; bc
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-正则表达式&quot;&gt;3 正则表达式&lt;/h2&gt;
&lt;p&gt;正则表达式分两类：&lt;/p&gt;
&lt;p&gt;​ 基本正则表达式：BRE&lt;/p&gt;
&lt;p&gt;​ 扩展正则表达式：ERE&lt;/p&gt;
&lt;p&gt;​ 帮助：man 7 regex&lt;/p&gt;
&lt;h3 id=&quot;31-基本正则表达式元字符&quot;&gt;3.1 基本正则表达式元字符&lt;/h3&gt;
&lt;p&gt;与通配符不同，通配 符功能是用来处理文件名，而正则表达式是处理文本内容中字符&lt;/p&gt;
&lt;h5 id=&quot;311-字符匹配&quot;&gt;3.1.1 字符匹配&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;.   匹配任意单个字符，可以是一个汉字
[]   匹配指定范围内的任意单个字符，示例：[wang]   [0-9]   [a-z]   [a-zA-Z]
[^] 匹配指定范围外的任意单个字符,示例：[^wang]

[:alnum:] 字母和数字
[:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z
[:lower:] 小写字母,示例:[[:lower:]],相当于[a-z]
[:upper:] 大写字母
[:blank:] 空白字符（空格和制表符）
[:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广）
[:cntrl:] 不可打印的控制字符（退格、删除、警铃...）
[:digit:] 十进制数字
[:xdigit:]十六进制数字
[:graph:] 可打印的非空白字符
[:print:] 可打印字符
[:punct:] 标点符号
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;312-匹配次数&quot;&gt;3.1.2 匹配次数&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;* 匹配前面的字符任意次，包括0次，贪婪模式：尽可能长的匹配
.* 任意长度的任意字符
\? 匹配其前面的字符0或1次,即:可有可无
\+ 匹配其前面的字符至少1次,即:肯定有，&amp;gt;=1
\{n\} 匹配前面的字符n次
\{m,n\} 匹配前面的字符至少m次，至多n次
\{,n\} 匹配前面的字符至多n次,&amp;lt;=n
\{n,\} 匹配前面的字符至少n次
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;313-位置锚定&quot;&gt;3.1.3 位置锚定&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;^ 行首锚定，用于模式的最左侧
$ 行尾锚定，用于模式的最右侧
^PATTERN$ 用于模式匹配整行
^$ 空行
^[[:space:]]*$ 空白行
\&amp;lt; 或 \b 词首锚定，用于单词模式的左侧
\&amp;gt; 或 \b 词尾锚定，用于单词模式的右侧
\&amp;lt;PATTERN\&amp;gt; 匹配整个单词
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;314-分组其它&quot;&gt;3.1.4 分组其它&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;分组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;分组：() 将多个字符捆绑在一起，当作一个整体处理，如：(root)+ 后向引用：分组括号中的模式匹配到的内容会被正则表达式引擎记录于内部的变量中，这些变量的命名 方式为: \1, \2, \3, ...&lt;/p&gt;
&lt;p&gt;\1 表示从左侧起第一个左括号以及与之匹配右括号之间的模式所匹配到的字符&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;或者&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;a\|b #a或b  
C\|cat #C或cat  
\(C\|c\)at #Cat或cat
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;32-扩展正则表达式&quot;&gt;3.2 扩展正则表达式&lt;/h3&gt;
&lt;p&gt;扩展正则于正则用法基本相同，大部分扩展正则相比正则只是取消了反斜线&lt;/p&gt;
&lt;h5 id=&quot;321-字符匹配元字符&quot;&gt;3.2.1 字符匹配元字符&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;. 任意单个字符
[wang] 指定范围的字符
[^wang] 不在指定范围的字符
[:alnum:] 字母和数字
[:alpha:] 代表任何英文大小写字符，亦即 A-Z, a-z
[:lower:] 小写字母,示例:[[:lower:]],相当于[a-z]
[:upper:] 大写字母
[:blank:] 空白字符（空格和制表符）
[:space:] 水平和垂直的空白字符（比[:blank:]包含的范围广）
[:cntrl:] 不可打印的控制字符（退格、删除、警铃...）
[:digit:] 十进制数字
[:xdigit:]十六进制数字
[:graph:] 可打印的非空白字符
[:print:] 可打印字符
[:punct:] 标点符号
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;322-次数匹配&quot;&gt;3.2.2 次数匹配&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;*   匹配前面字符任意次
? 0或1次
+ 1次或多次
{n} 匹配n次
{m,n} 至少m，至多n次
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;323-位置锚定&quot;&gt;3.2.3 位置锚定&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;^ 行首
$ 行尾
\&amp;lt;, \b 语首
\&amp;gt;, \b 语尾
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;324-分组其它&quot;&gt;3.2.4 分组其它&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;() 分组
后向引用：\1, \2, ...
| 或者
a|b #a或b
C|cat #C或cat
(C|c)at #Cat或cat
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4-文本处理三剑客&quot;&gt;4 文本处理三剑客&lt;/h2&gt;
&lt;h3 id=&quot;41-grep&quot;&gt;4.1 grep&lt;/h3&gt;
&lt;p&gt;grep：文本搜索工具，根据用户指定的“模式”对目标文本逐行进行匹配检查；打印匹配到的行&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;grep [OPTIONS] PATTERN [FILE...]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;常用选项&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;-v 显示不被pattern匹配到的行&lt;/li&gt;
&lt;li&gt;-i 忽略字符大小写&lt;/li&gt;
&lt;li&gt;-n 显示匹配的行号&lt;/li&gt;
&lt;li&gt;-c 统计匹配的行数&lt;/li&gt;
&lt;li&gt;-f file 根据模式文件处理&lt;/li&gt;
&lt;li&gt;-E 使用ERE，相当于egrep&lt;/li&gt;
&lt;li&gt;-o 仅显示匹配到的字符串&lt;/li&gt;
&lt;li&gt;-e 实现多个选项间的逻辑or关系,如：grep –e ‘cat ’ -e ‘dog’ file&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;范例&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;[root@centos8 data]# grep &quot;whoami&quot; /etc/passwd
[root@centos8 data]# grep `whoami` /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:11:0:operator:/root:/sbin/nologin

#文件匹配
[root@centos8 data]# cat a.txt b.txt 
a
b
c
a
b
d
[root@centos8 data]# grep -f a.txt b.txt 
a
b

#查看磁盘最高使用率
[root@centos8 data]# df | grep ^/dev/vd | tr -s &quot; &quot; % | cut -d% -f5
7

#计算出所有人年龄之和
[root@centos8 data]# cat lx.txt 
xiaoming=20
xiaodong=18
xiaoqiang=22
[root@centos8 data]# cut -d= -f2 lx.txt | tr &quot;\n&quot; + | grep -Eo .*[0-9] | bc
60
[root@centos8 data]# grep -Eo [0-9]+ /data/lx.txt | tr &quot;\n&quot; + | grep -Eo .*[0-9] | bc
60
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;练习&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;1.统计出/etc/passwd文件中默认其shell为非/sbin/nologin的用户个数，并将用户都显示出来
[root@centos8 data]# cat /etc/passwd | grep -v /sbin/nologin | cut -d: -f1
root
user
user1
slackware
user2
user3
2.查出用户UID的最大值的用户名、UID及shell类型
[root@centos8 data]# cut -d: -f1,3,7 /etc/passwd | sort -k2 -nr | head -1
user3:2004:/bin/bash
3.统计当前连接本机的每个远程主机IP的连接数，并按从小到大排序
[root@centos8 data]# ss -nt | grep ^ESTAB | tr -s &quot; &quot; : | cut -d: -f6 | sort -nr
110.152.191.166
100.100.30.25
4.编写脚本disk.sh,显示当前硬盘分区中空间利用率最大的值
[root@centos8 data]# cat lx.txt 
#/bin/bash!
df | grep /dev/vd | tr -s &quot; &quot; % | cut -d% -f5
5.编写脚本systeminfo.sh,显示当前主机系统信息，包括：主机名，ipv4地址，操作系统版本，内核版本，cpu型号，内存大小，硬盘大小
  1 #/bin/bash!
  2 echo 主机名`hostname`
  3 echo 地址`ifconfig | head -3 | tail -2 | tr -s &quot; &quot; % | cut -d% -f3 | head -1`
  4 echo 操作系统版本`cat /etc/redhat-release`
  5 echo 内核版本`uname -r`
  6 echo cpu型号`cat /proc/cpuinfo | grep &quot;model name&quot; | cut -d: -f2`
  7 echo 内存大小 &quot;`free -h | grep ^Mem | tr -s &quot; &quot; % | cut -d% -f2`&quot;
  8 echo 硬盘大小`lsblk | grep 'vda\&amp;gt;' | grep -Eo '[0-9]+[[:upper:]]'`
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 02 Jan 2021 15:37:00 +0000</pubDate>
<dc:creator>bestvae</dc:creator>
<og:description>1.VIM 1.1vim简介 vim是一款强大的文本编辑器，它和 vi 使用方法一致，但功能更为强大。官网：www.vim.org、中文手册：http://vimcdoc.sourceforge.ne</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bestvae/p/14224477.html</dc:identifier>
</item>
<item>
<title>C++ string的内部究竟是什么样的？ - RioTian</title>
<link>http://www.cnblogs.com/RioTian/p/14224419.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/RioTian/p/14224419.html</guid>
<description>&lt;p&gt;在C语言中，有两种方式表示字符串：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种是用字符数组来容纳字符串，例如&lt;code&gt;char str[10] = &quot;abc&quot;&lt;/code&gt;，这样的字符串是可读写的；&lt;/li&gt;
&lt;li&gt;一种是使用字符串常量，例如&lt;code&gt;char *str = &quot;abc&quot;&lt;/code&gt;，这样的字符串只能读，不能写。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两种形式总是以&lt;code&gt;\0&lt;/code&gt;作为结束标志。&lt;/p&gt;
&lt;p&gt;C++ string 与它们在C语言中的前身截然不同。首先，也是最重要的不同点，C++ string 隐藏了它所包含的字符序列的物理表示。程序设计人员不必关心数组的维数或&lt;code&gt;\0&lt;/code&gt;方面的问题。&lt;/p&gt;
&lt;p&gt;string 在内部封装了与内存和容量有关的信息。具体地说，C++ string 对象知道自己在内存中的开始位置、包含的字符序列以及字符序列长度；当内存空间不足时，string 还会自动调整，让内存空间增长到足以容纳下所有字符序列的大小。&lt;/p&gt;
&lt;p&gt;C++ string 的这种做法，极大地减少了C语言编程中三种最常见且最具破坏性的错误：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数组越界；&lt;/li&gt;
&lt;li&gt;通过未被初始化或者被赋以错误值的指针来访问数组元紊；&lt;/li&gt;
&lt;li&gt;释放了数组所占内存，但是仍然保留了“悬空”指针。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;C++ 标准没有定义 string 类的内存布局，各个编译器厂商可以提供不同的实现，但必须保证 string 的行为一致。采用这种做法是为了获得足够的灵活性。&lt;/p&gt;
&lt;p&gt;特別是，C++ 标准没有定义在哪种确切的情况下应该为 string 对象分配内存空间来存储字符序列。string 内存分配规则明确规定：允许但不要求以引用计数（reference counting）的方式实现。但无论是否采用引用计数，其语义都必须一致。&lt;/p&gt;
&lt;p&gt;C++ 的这种做法和C语言不同，在C语言中，每个字符型数组都占据各自的物理存储区。在 C++ 中，独立的几个 string 对象可以占据也可以不占据各自特定的物理存储区，但是，如果采用引用计数避免了保存同一数据的拷贝副本，那么各个独立的对象（在处理上）必须看起来并表现得就像独占地拥有各自的存储区一样。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// #include&amp;lt;bits/stdc++.h&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;string&amp;gt;
using namespace std;

int main() {
    string s1(&quot;12345&quot;);
    string s2 = s1;
    cout &amp;lt;&amp;lt; (s1 == s2) &amp;lt;&amp;lt; endl;
    s1[0] = '6';
    cout &amp;lt;&amp;lt; &quot;s1 = &quot; &amp;lt;&amp;lt; s1 &amp;lt;&amp;lt; endl;  // 62345
    cout &amp;lt;&amp;lt; &quot;s2 = &quot; &amp;lt;&amp;lt; s2 &amp;lt;&amp;lt; endl;  // 12345
    cout &amp;lt;&amp;lt; (s1 == s2) &amp;lt;&amp;lt; endl;

    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 GCC 下的运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;1
s1 = 62345
s2 = 12345
0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只有当字符串被修改的时候才创建各自的拷贝，这种实现方式称为写时&lt;strong&gt;复制&lt;/strong&gt;（copy-on-write）策略。当字符串只是作为&lt;strong&gt;值参数&lt;/strong&gt;（value parameter）或在其他只读情形下使用，这种方法能够节省时间和空间。&lt;/p&gt;
&lt;p&gt;不论一个库的实现是不是采用引用计数，它对 &lt;strong&gt;string 类&lt;/strong&gt;的使用者来说都应该是透明的。遗憾的是，情况并不总是这样。在多线程程序中，几乎不可能安全地使用引用计数来实现。&lt;/p&gt;
</description>
<pubDate>Sat, 02 Jan 2021 15:21:00 +0000</pubDate>
<dc:creator>RioTian</dc:creator>
<og:description>在C语言中，有两种方式表示字符串： 一种是用字符数组来容纳字符串，例如char str[10] = &amp;amp;quot;abc&amp;amp;quot;，这样的字符串是可读写的； 一种是使用字符串常量，例如</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/RioTian/p/14224419.html</dc:identifier>
</item>
<item>
<title>RocketMQ(十)：数据存储模型设计与实现 - 等你归去来</title>
<link>http://www.cnblogs.com/yougewe/p/14224366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yougewe/p/14224366.html</guid>
<description>&lt;p&gt;　　消息中间件，说是一个通信组件也没有错，因为它的本职工作是做消息的传递。然而要做到高效的消息传递，很重要的一点是数据结构，数据结构设计的好坏，一定程度上决定了该消息组件的性能以及能力上限。&lt;/p&gt;

&lt;h3&gt;1. 消息中间件的实现方式概述&lt;/h3&gt;
&lt;p&gt;　　消息中间件实现起来自然是很难的，但我们可以从某些角度，简单了说说实现思路。&lt;/p&gt;
&lt;p&gt;　　它的最基本的两个功能接口为：接收消息的发送（produce）, 消息的消费（consume）. 就像一个邮递员一样，经过它与不经过它实质性的东西没有变化，它只是一个中介（其他功能效应，咱们抛却不说）。&lt;/p&gt;
&lt;p&gt;　　为了实现这两个基本的接口，我们就得实现两个最基本的能力：消息的存储和查询。存储即是接收发送过来的消息，查询则包括业务查询与系统自行查询推送。&lt;/p&gt;

&lt;p&gt;我们先来看第一个点：消息的存储。&lt;/p&gt;
&lt;p&gt;　　直接基于内存的消息组件，可以做到非常高效的传递，基本上此时的消息中间件就是由几个内存队列组成，只要保证这几个队列的安全性和实时性，就可以工作得很好了。然而基于内存则必然意味着能力有限或者成本相当高，所以这样的设计适用范围得结合业务现状做下比对。&lt;/p&gt;
&lt;p&gt;　　另一个就是基于磁盘的消息组件，磁盘往往意味着更大的存储空间，或者某种程度上意味着无限的存储空间，因为毕竟所有的大数据都是存放在磁盘上的，前提是系统需要协调好各磁盘间的数据关系。然而，磁盘也意味着性能的下降，数据存放起来更麻烦。但rocketmq借助于操作系统的pagecache和mmap以及顺序写机制，在读写性能方面已经非常优化。所以，更重要的是如何设计好磁盘的数据据结构。&lt;/p&gt;

&lt;p&gt;然后是第二个点：消息的查询。&lt;/p&gt;
&lt;p&gt;　　具体如何查询，则必然依赖于如何存储，与上面的原理类似，不必细说。但一般会有两种消费模型：推送消息模型和拉取消费模型。即是消息中间件主动向消费者推送消息，或者是消费者主动查询消息中间件。二者也各有优劣，推送模型一般可以体现出更强的实时性以及保持比较小的server端存储空间占用，但是也带来了非常大的复杂度，它需要处理各种消费异常、重试、负载均衡、上下线，这不是件小事。而拉取模型则会对消息中间件减轻许多工作，主要是省去了异常、重试、负载均衡类的工作，将这些工作转嫁到消费者客户端上。但与此同时，也会对消息中间件提出更多要求，即要求能够保留足够长时间的数据，以便所有合法的消费者都可以进行消费。而对于客户端，则也需要中间件提供相应的便利，以便可以实现客户端的基本诉求，比如消费组管理，上下线管理以及最基本的高效查询能力。&lt;/p&gt;

&lt;h3&gt;2. rocketmq存储模型设计概述&lt;/h3&gt;
&lt;p&gt;　　很明显，rocketmq的初衷就是要应对大数据的消息传递，所以其必然是基于磁盘的存储。而其性能如上节所述，其利用操作系统的pagecache和mmap机制，读写性能非常好，另外他使用顺序写机制，使普通磁盘也能体现出非常高的性能。&lt;/p&gt;
&lt;p&gt;　　但是，以上几项，只是为高性能提供了必要的前提。但具体如何利用，还需要从重设计。毕竟，快不是目的，实现需求才是意义。&lt;/p&gt;
&lt;p&gt;　　rocketmq中主要有四种存储文件：commitlog 数据文件, consumequeue 消费队列文件, index 索引文件, 元数据信息文件。最后一个元数据信息文件比较简单，因其数据量小，方便操作。但针对前三个文件，都会涉及大量的数据问题，所以必然好详细设计其结构。&lt;/p&gt;
&lt;p&gt;　　从总体上来说，rocketmq都遵从定长数据结构存储，定长的最大好处就在于可以快速定位位置，这是其高性能的出发点。定长模型。&lt;/p&gt;
&lt;p&gt;　　从核心上来说，commitlog文件保存了所有原始数据，所有数据想要获取，都能从或也只能从commitlog文件中获取，由于commitlog文件保持了顺序写的特性，所以其性能非常高。而因数据只有一份，所以也就从根本上保证了数据一致性。&lt;/p&gt;
&lt;p&gt;　　而根据各业务场景，衍生出了consumequeue和index文件，即 consumequeue 文件是为了消费者能够快速获取到相应消息而设计，而index文件则为了能够快速搜索到消息而设计。从功能上说，consumequeue和index文件都是索引文件，只是索引的维度不同。consumequeue 是以topic和queueId维度进行划分的索引，而index 则是以时间和key作为划分的索引。有了这两个索引之后，就可以为各自的业务场景，提供高性能的服务了。具体其如何实现索引，我们稍后再讲！&lt;/p&gt;
&lt;p&gt;　　commitlog vs consumequeue 的存储模型如下:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/830731/202101/830731-20210102225705987-61834568.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h3&gt;3. commitlog文件的存储结构&lt;/h3&gt;
&lt;p&gt;　　直接顺序写的形式存储，每个文件设定固定大小，默认是1G即: 1073741824 bytes. 写满一个文件后，新开一个文件写入。文件名就是其存储的起始消息偏移量。&lt;/p&gt;
&lt;p&gt;　　官方描述如下：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;CommitLog：消息主体以及元数据的存储主体，存储Producer端写入的消息主体内容,消息内容不是定长的。单个文件大小默认1G ，文件名长度为20位，左边补零，剩余为起始偏移量，比如00000000000000000000代表了第一个文件，起始偏移量为0，文件大小为1G=1073741824；当第一个文件写满了，第二个文件为00000000001073741824，起始偏移量为1073741824，以此类推。消息主要是顺序写入日志文件，当文件满了，写入下一个文件；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　当给定一个偏移量，要查找某条消息时，只需在所有的commitlog文件中，根据其名字即可知道偏移的数据信息是否存在其中，即相当于可基于文件实现一个二分查找，实际上rocketmq实现得更简洁，直接一次性查找即可定位：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; org.apache.rocketmq.store.CommitLog#getData&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; SelectMappedBufferResult getData(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; returnFirstOnNotFound) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mappedFileSize = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getMessageStoreConfig().getMappedFileSizeCommitLog();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 先在所有commitlog文件中查找到对应所在的 commitlog 分片文件&lt;/span&gt;
        MappedFile mappedFile = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileQueue.findMappedFileByOffset(offset, returnFirstOnNotFound);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mappedFile != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再从该分片文件中，移动余数的大小偏移，即可定位到要查找的消息记录了&lt;/span&gt;
            &lt;span&gt;int&lt;/span&gt; pos = (&lt;span&gt;int&lt;/span&gt;) (offset %&lt;span&gt; mappedFileSize);
            SelectMappedBufferResult result &lt;/span&gt;=&lt;span&gt; mappedFile.selectMappedBuffer(pos);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找偏移所在commitlog文件的实现方式：
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; org.apache.rocketmq.store.MappedFileQueue#findMappedFileByOffset(long, boolean)
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; firstMappedFile.getFileFromOffset() / this.mappedFileSize 代表了第一条记录所处的文件位置编号
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; offset / this.mappedFileSize 代表当前offset所处的文件编号
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 那么，两个编号相减就是当前offset对应的文件编号，因为第一个文件编号的相对位置是0
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 但有个前提：就是每个文件存储的大小必须是真实的对应的 offset 大小之差，而实际上consumeQueue根本无法确定它存了多少offset
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 也就是说，只要文件定长，offset用于定位 commitlog文件就是合理的&lt;/span&gt;
    &lt;span&gt;int&lt;/span&gt; index = (&lt;span&gt;int&lt;/span&gt;) ((offset / &lt;span&gt;this&lt;/span&gt;.mappedFileSize) - (firstMappedFile.getFileFromOffset() / &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileSize));
    MappedFile targetFile &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 所以，此处可以找到 commitlog 文件对应的 mappedFile&lt;/span&gt;
        targetFile = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFiles.get(index);
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ignored) {
    }
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (targetFile != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; offset &amp;gt;=&lt;span&gt; targetFile.getFileFromOffset()
        &lt;/span&gt;&amp;amp;&amp;amp; offset &amp;lt; targetFile.getFileFromOffset() + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileSize) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; targetFile;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果快速查找失败，则退回到遍历方式, 使用O(n)的复杂度再查找一次&lt;/span&gt;
    &lt;span&gt;for&lt;/span&gt; (MappedFile tmpMappedFile : &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFiles) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (offset &amp;gt;=&lt;span&gt; tmpMappedFile.getFileFromOffset()
            &lt;/span&gt;&amp;amp;&amp;amp; offset &amp;lt; tmpMappedFile.getFileFromOffset() + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileSize) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; tmpMappedFile;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　定位到具体的消息记录位置后，如何知道要读多少数据呢？这实际上在commitlog的数据第1个字节中标明，只需读出即可知道。&lt;/p&gt;
&lt;p&gt;　　具体commitlog的存储实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; org.apache.rocketmq.store.CommitLog.DefaultAppendMessageCallback#doAppend&lt;/span&gt;
&lt;span&gt;    ...
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialization of storage space&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resetByteBuffer(msgStoreItemMemory, msgLen);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1 TOTALSIZE, 首先将消息大小写入&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.putInt(msgLen);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2 MAGICCODE&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.putInt(CommitLog.MESSAGE_MAGIC_CODE);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3 BODYCRC&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.putInt(msgInner.getBodyCRC());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4 QUEUEID&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.putInt(msgInner.getQueueId());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5 FLAG&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.putInt(msgInner.getFlag());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6 QUEUEOFFSET&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.putLong(queueOffset);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 7 PHYSICALOFFSET&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.msgStoreItemMemory.putLong(fileFromOffset +&lt;span&gt; byteBuffer.position());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 8 SYSFLAG&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.putInt(msgInner.getSysFlag());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 9 BORNTIMESTAMP&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.putLong(msgInner.getBornTimestamp());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10 BORNHOST&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resetByteBuffer(bornHostHolder, bornHostLength);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.put(msgInner.getBornHostBytes(bornHostHolder));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 11 STORETIMESTAMP&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.putLong(msgInner.getStoreTimestamp());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 12 STOREHOSTADDRESS&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.resetByteBuffer(storeHostHolder, storeHostLength);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.put(msgInner.getStoreHostBytes(storeHostHolder));
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 13 RECONSUMETIMES&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.putInt(msgInner.getReconsumeTimes());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 14 Prepared Transaction Offset&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.putLong(msgInner.getPreparedTransactionOffset());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 15 BODY&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.putInt(bodyLength);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bodyLength &amp;gt; 0&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.put(msgInner.getBody());
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 16 TOPIC&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.msgStoreItemMemory.put((&lt;span&gt;byte&lt;/span&gt;&lt;span&gt;) topicLength);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.put(topicData);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 17 PROPERTIES&lt;/span&gt;
    &lt;span&gt;this&lt;/span&gt;.msgStoreItemMemory.putShort((&lt;span&gt;short&lt;/span&gt;&lt;span&gt;) propertiesLength);
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (propertiesLength &amp;gt; 0&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.msgStoreItemMemory.put(propertiesData);

    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; beginTimeMills = CommitLog.&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.now();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Write messages to the queue buffer&lt;/span&gt;
    byteBuffer.put(&lt;span&gt;this&lt;/span&gt;.msgStoreItemMemory.array(), 0&lt;span&gt;, msgLen);
    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　可以看出，commitlog的存储还是比较简单的，因为其主要就是负责将接收到的所有消息，依次写入同一文件中。因为专一所以专业。&lt;/p&gt;

&lt;h3&gt;4. consumequeue文件的存储结构&lt;/h3&gt;
&lt;p&gt;　　consumequeue作为消费者的重要依据，同样起着非常重要的作用。消费者在进行消费时，会使用一些偏移量作为依据（拉取模型实现）。而这些个偏移量，实际上就是指的consumequeue的偏移量（注意不是commitlog的偏移量）。这样做有什么好处呢？首先，consumequeue作为索引文件，它被要求要有非常高的查询性能，所以越简单越好。最好是能够一次性定位到数据！&lt;/p&gt;
&lt;p&gt;　　如果想一次性定位数据，那么唯一的办法是直接使用commitlog的offset。但这会带来一个最大的问题，就是当我当前消息消费拉取完成后，下一条消息在哪里呢？如果单靠commitlog文件，那么，它必然需要将下一条消息读入，然后再根据topic判定是不是需要的数据。如此一来，就必然存在大量的commitlog文件的io问题了。所以，这看起来是非常快速的一个解决方案，最终又变成了非常费力的方案了。&lt;/p&gt;
&lt;p&gt;　　而使用commitlog文件的offset，则好了许多。因为consumequeue的文件存储格式是一条消息占20字节，即定长。根据这20字节，你可以找到commitlog的offset. 而因为consumequeue本身就是按照topic/queueId进行划分的，所以，本次消费完成后，下一次消费的数据必定就在consumequeue的下一位置。如此简单快速搞得定了。具体consume的存储格式，如官方描述：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;ConsumeQueue：消息消费队列，引入的目的主要是提高消息消费的性能，由于RocketMQ是基于主题topic的订阅模式，消息消费是针对主题进行的，如果要遍历commitlog文件中根据topic检索消息是非常低效的。Consumer即可根据ConsumeQueue来查找待消费的消息。其中，ConsumeQueue（逻辑消费队列）作为消费消息的索引，保存了指定Topic下的队列消息在CommitLog中的起始物理偏移量offset，消息大小size和消息Tag的HashCode值。consumequeue文件可以看成是基于topic的commitlog索引文件，故consumequeue文件夹的组织方式如下：topic/queue/file三层组织结构，具体存储路径为：$HOME/store/consumequeue/{topic}/{queueId}/{fileName}。同样consumequeue文件采取定长设计，每一个条目共20个字节，分别为8字节的commitlog物理偏移量、4字节的消息长度、8字节tag hashcode，单个文件由30W个条目组成，可以像数组一样随机访问每一个条目，每个ConsumeQueue文件大小约5.72M；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　其中fileName也是以偏移量作为命名依据，因为这样才能根据offset快速查找到数据所在的分片文件。&lt;/p&gt;
&lt;p&gt;　　其存储实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; org.apache.rocketmq.store.ConsumeQueue#putMessagePositionInfo&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; putMessagePositionInfo(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; offset, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; size, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; tagsCode,
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; cqOffset) {

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (offset + size &amp;lt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.maxPhysicOffset) {
            log.warn(&lt;/span&gt;&quot;Maybe try to build consume queue repeatedly maxPhysicOffset={} phyOffset={}&quot;&lt;span&gt;, maxPhysicOffset, offset);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次写入 offset + size + tagsCode&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.byteBufferIndex.flip();
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.byteBufferIndex.limit(CQ_STORE_UNIT_SIZE);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.byteBufferIndex.putLong(offset);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.byteBufferIndex.putInt(size);
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.byteBufferIndex.putLong(tagsCode);

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; expectLogicOffset = cqOffset *&lt;span&gt; CQ_STORE_UNIT_SIZE;

        MappedFile mappedFile &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileQueue.getLastMappedFile(expectLogicOffset);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mappedFile != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mappedFile.isFirstCreateInQueue() &amp;amp;&amp;amp; cqOffset != 0 &amp;amp;&amp;amp; mappedFile.getWrotePosition() == 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.minLogicOffset =&lt;span&gt; expectLogicOffset;
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileQueue.setFlushedWhere(expectLogicOffset);
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileQueue.setCommittedWhere(expectLogicOffset);
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.fillPreBlank(mappedFile, expectLogicOffset);
                log.info(&lt;/span&gt;&quot;fill pre blank space &quot; + mappedFile.getFileName() + &quot; &quot; + expectLogicOffset + &quot; &quot;
                    +&lt;span&gt; mappedFile.getWrotePosition());
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (cqOffset != 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; currentLogicOffset = mappedFile.getWrotePosition() +&lt;span&gt; mappedFile.getFileFromOffset();

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (expectLogicOffset &amp;lt;&lt;span&gt; currentLogicOffset) {
                    log.warn(&lt;/span&gt;&quot;Build  consume queue repeatedly, expectLogicOffset: {} currentLogicOffset: {} Topic: {} QID: {} Diff: {}&quot;&lt;span&gt;,
                        expectLogicOffset, currentLogicOffset, &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.topic, &lt;span&gt;this&lt;/span&gt;.queueId, expectLogicOffset -&lt;span&gt; currentLogicOffset);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (expectLogicOffset !=&lt;span&gt; currentLogicOffset) {
                    LOG_ERROR.warn(
                        &lt;/span&gt;&quot;[BUG]logic queue order maybe wrong, expectLogicOffset: {} currentLogicOffset: {} Topic: {} QID: {} Diff: {}&quot;&lt;span&gt;,
                        expectLogicOffset,
                        currentLogicOffset,
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.topic,
                        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.queueId,
                        expectLogicOffset &lt;/span&gt;-&lt;span&gt; currentLogicOffset
                    );
                }
            }
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.maxPhysicOffset = offset +&lt;span&gt; size;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将buffer写入 consumequeue 的 mappedFile 中&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; mappedFile.appendMessage(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.byteBufferIndex.array());
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }
    当需要进行查找进，也就会根据offset, 定位到某个 consumequeue 文件，然后再根据偏移余数信息，再找到对应记录，取出20字节，即是 commitlog信息。此处实现与 commitlog 的offset查找实现如出一辙。
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找索引所在文件的实现,如下：
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; org.apache.rocketmq.store.ConsumeQueue#getIndexBuffer&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; SelectMappedBufferResult getIndexBuffer(&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; startIndex) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; mappedFileSize = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileSize;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 给到客户端的偏移量是除以 20 之后的，也就是说 如果上一次的偏移量是 1, 那么下一次的偏移量应该是2
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一次性消费多条记录另算, 自行加减&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; offset = startIndex *&lt;span&gt; CQ_STORE_UNIT_SIZE;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (offset &amp;gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getMinLogicOffset()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 委托给mappedFileQueue进行查找到单个具体的consumequeue文件
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据 offset 和规范的命名，可以快速定位分片文件，如上 commitlog 的查找实现&lt;/span&gt;
            MappedFile mappedFile = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFileQueue.findMappedFileByOffset(offset);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (mappedFile != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 再根据剩余的偏移量，直接类似于数组下标的形式，一次性定位到具体的数据记录&lt;/span&gt;
                SelectMappedBufferResult result = mappedFile.selectMappedBuffer((&lt;span&gt;int&lt;/span&gt;) (offset %&lt;span&gt; mappedFileSize));
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果想一次性消费多条消息，则只需要依次从查找到索引记录开始，依次读取多条，然后同理回查commitlog即可。即consumequeue的连续，成就了commitlog的不连续。如下消息拉取实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; org.apache.rocketmq.store.DefaultMessageStore#getMessage
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 其中 bufferConsumeQueue 是刚刚查找出的consumequeue的起始消费位置
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基于此文件迭代，完成多消息记录消费&lt;/span&gt;
&lt;span&gt;    ...
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; nextPhyFileStartOffset =&lt;span&gt; Long.MIN_VALUE;
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; maxPhyOffsetPulling = 0&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = 0&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxFilterMessageCount = Math.max(16000, maxMsgNums *&lt;span&gt; ConsumeQueue.CQ_STORE_UNIT_SIZE);
    &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; diskFallRecorded = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.messageStoreConfig.isDiskFallRecorded();
    ConsumeQueueExt.CqExtUnit cqExtUnit &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ConsumeQueueExt.CqExtUnit();
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (; i &amp;lt; bufferConsumeQueue.getSize() &amp;amp;&amp;amp; i &amp;lt; maxFilterMessageCount; i +=&lt;span&gt; ConsumeQueue.CQ_STORE_UNIT_SIZE) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次取出commitlog的偏移量，数据大小，hashCode
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一次循环即是取走一条记录，多次循环则依次往下读取&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; offsetPy =&lt;span&gt; bufferConsumeQueue.getByteBuffer().getLong();
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; sizePy =&lt;span&gt; bufferConsumeQueue.getByteBuffer().getInt();
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; tagsCode =&lt;span&gt; bufferConsumeQueue.getByteBuffer().getLong();

        maxPhyOffsetPulling &lt;/span&gt;=&lt;span&gt; offsetPy;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nextPhyFileStartOffset !=&lt;span&gt; Long.MIN_VALUE) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (offsetPy &amp;lt;&lt;span&gt; nextPhyFileStartOffset)
                &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; isInDisk =&lt;span&gt; checkInDiskByCommitOffset(offsetPy, maxOffsetPy);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.isTheBatchFull(sizePy, maxMsgNums, getResult.getBufferTotalSize(), getResult.getMessageCount(),
            isInDisk)) {
            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; extRet = &lt;span&gt;false&lt;/span&gt;, isTagsCodeLegal = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (consumeQueue.isExtAddr(tagsCode)) {
            extRet &lt;/span&gt;=&lt;span&gt; consumeQueue.getExt(tagsCode, cqExtUnit);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (extRet) {
                tagsCode &lt;/span&gt;=&lt;span&gt; cqExtUnit.getTagsCode();
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; can't find ext content.Client will filter messages by tag also.&lt;/span&gt;
                log.error(&quot;[BUG] can't find consume queue extend file content!addr={}, offsetPy={}, sizePy={}, topic={}, group={}&quot;&lt;span&gt;,
                    tagsCode, offsetPy, sizePy, topic, group);
                isTagsCodeLegal &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (messageFilter != &lt;span&gt;null&lt;/span&gt;
            &amp;amp;&amp;amp; !messageFilter.isMatchedByConsumeQueue(isTagsCodeLegal ? tagsCode : &lt;span&gt;null&lt;/span&gt;, extRet ? cqExtUnit : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getResult.getBufferTotalSize() == 0&lt;span&gt;) {
                status &lt;/span&gt;=&lt;span&gt; GetMessageStatus.NO_MATCHED_MESSAGE;
            }

            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        SelectMappedBufferResult selectResult &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.commitLog.getMessage(offsetPy, sizePy);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; ==&lt;span&gt; selectResult) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getResult.getBufferTotalSize() == 0&lt;span&gt;) {
                status &lt;/span&gt;=&lt;span&gt; GetMessageStatus.MESSAGE_WAS_REMOVING;
            }

            nextPhyFileStartOffset &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.commitLog.rollNextFile(offsetPy);
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (messageFilter != &lt;span&gt;null&lt;/span&gt;
            &amp;amp;&amp;amp; !messageFilter.isMatchedByCommitLog(selectResult.getByteBuffer().slice(), &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (getResult.getBufferTotalSize() == 0&lt;span&gt;) {
                status &lt;/span&gt;=&lt;span&gt; GetMessageStatus.NO_MATCHED_MESSAGE;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; release...&lt;/span&gt;
&lt;span&gt;            selectResult.release();
            &lt;/span&gt;&lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.storeStatsService.getGetMessageTransferedMsgCount().incrementAndGet();
        getResult.addMessage(selectResult);
        status &lt;/span&gt;=&lt;span&gt; GetMessageStatus.FOUND;
        nextPhyFileStartOffset &lt;/span&gt;=&lt;span&gt; Long.MIN_VALUE;
    }

    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (diskFallRecorded) {
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; fallBehind = maxOffsetPy -&lt;span&gt; maxPhyOffsetPulling;
        brokerStatsManager.recordDiskFallBehindSize(group, topic, queueId, fallBehind);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分配下一次读取的offset偏移信息，同样要除以单条索引大小&lt;/span&gt;
    nextBeginOffset = offset + (i /&lt;span&gt; ConsumeQueue.CQ_STORE_UNIT_SIZE);

    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; diff = maxOffsetPy -&lt;span&gt; maxPhyOffsetPulling;
    &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; memory = (&lt;span&gt;long&lt;/span&gt;&lt;span&gt;) (StoreUtil.TOTAL_PHYSICAL_MEMORY_SIZE
        &lt;/span&gt;* (&lt;span&gt;this&lt;/span&gt;.messageStoreConfig.getAccessMessageInMemoryMaxRatio() / 100.0&lt;span&gt;));
    getResult.setSuggestPullingFromSlave(diff &lt;/span&gt;&amp;gt;&lt;span&gt; memory);
    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上即理论的实现，无须多言。&lt;/p&gt;

&lt;h3&gt;5. index文件的存储结构&lt;/h3&gt;
&lt;p&gt;　　index文件是为搜索场景而生的，如果没有搜索业务需求，则这个实现是意义不大的。一般这种搜索，主要用于后台查询验证类使用，或者有其他同的有妙用，不得而知。总之，一切为搜索。它更多的需要借助于时间限定，以key或者id进行查询。&lt;/p&gt;
&lt;p&gt;　　官方描述如下：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;IndexFile（索引文件）提供了一种可以通过key或时间区间来查询消息的方法。Index文件的存储位置是：$HOME \store\index\${fileName}，文件名fileName是以创建时的时间戳命名的，固定的单个IndexFile文件大小约为400M，一个IndexFile可以保存 2000W个索引，IndexFile的底层存储设计为在文件系统中实现HashMap结构，故rocketmq的索引文件其底层实现为hash索引。&lt;br/&gt;IndexFile索引文件为用户提供通过“按照Message Key查询消息”的消息索引查询服务，IndexFile文件的存储位置是：$HOME\store\index\${fileName}，文件名fileName是以创建时的时间戳命名的，文件大小是固定的，等于40+500W\*4+2000W\*20= 420000040个字节大小。如果消息的properties中设置了UNIQ_KEY这个属性，就用 topic + “#” + UNIQ_KEY的value作为 key 来做写入操作。如果消息设置了KEYS属性（多个KEY以空格分隔），也会用 topic + “#” + KEY 来做索引。&lt;br/&gt;其中的索引数据包含了Key Hash/CommitLog Offset/Timestamp/NextIndex offset 这四个字段，一共20 Byte。NextIndex offset 即前面读出来的 slotValue，如果有 hash冲突，就可以用这个字段将所有冲突的索引用链表的方式串起来了。Timestamp记录的是消息storeTimestamp之间的差，并不是一个绝对的时间。整个Index File的结构如图，40 Byte 的Header用于保存一些总的统计信息，4\*500W的 Slot Table并不保存真正的索引数据，而是保存每个槽位对应的单向链表的头。20\*2000W 是真正的索引数据，即一个 Index File 可以保存 2000W个索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　具体结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/830731/202101/830731-20210102230345473-1226296822.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　那么，如果要查找一个key, 应当如何查找呢？rocketmq会根据时间段找到一个index索引分版，然后再根据key做hash得到一个值，然后定位到 slotValue . 然后再从slotValue去取出索引数据的地址，找到索引数据，然后再回查 commitlog 文件。从而得到具体的消息数据。也就是，相当于搜索经历了四级查询： 索引分片文件查询 -&amp;gt; slotValue 查询 -&amp;gt; 索引数据查询 -&amp;gt; commitlog 查询 。 &lt;/p&gt;
&lt;p&gt;　　具体查找实现如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;84&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; org.apache.rocketmq.broker.processor.QueryMessageProcessor#queryMessage&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RemotingCommand queryMessage(ChannelHandlerContext ctx, RemotingCommand request)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; RemotingCommandException {
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; RemotingCommand response =&lt;span&gt;
            RemotingCommand.createResponseCommand(QueryMessageResponseHeader.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; QueryMessageResponseHeader responseHeader =&lt;span&gt;
            (QueryMessageResponseHeader) response.readCustomHeader();
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; QueryMessageRequestHeader requestHeader =&lt;span&gt;
            (QueryMessageRequestHeader) request
                .decodeCommandCustomHeader(QueryMessageRequestHeader.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

        response.setOpaque(request.getOpaque());

        String isUniqueKey &lt;/span&gt;=&lt;span&gt; request.getExtFields().get(MixAll.UNIQUE_MSG_QUERY_FLAG);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isUniqueKey != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; isUniqueKey.equals(&quot;true&quot;&lt;span&gt;)) {
            requestHeader.setMaxNum(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerController.getMessageStoreConfig().getDefaultQueryMaxNum());
        }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从索引文件中查询消息&lt;/span&gt;
        &lt;span&gt;final&lt;/span&gt; QueryMessageResult queryMessageResult =
            &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.brokerController.getMessageStore().queryMessage(requestHeader.getTopic(),
                requestHeader.getKey(), requestHeader.getMaxNum(), requestHeader.getBeginTimestamp(),
                requestHeader.getEndTimestamp());
        &lt;/span&gt;&lt;span&gt;assert&lt;/span&gt; queryMessageResult != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

        responseHeader.setIndexLastUpdatePhyoffset(queryMessageResult.getIndexLastUpdatePhyoffset());
        responseHeader.setIndexLastUpdateTimestamp(queryMessageResult.getIndexLastUpdateTimestamp());

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (queryMessageResult.getBufferTotalSize() &amp;gt; 0&lt;span&gt;) {
            response.setCode(ResponseCode.SUCCESS);
            response.setRemark(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                FileRegion fileRegion &lt;/span&gt;=
                    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryMessageTransfer(response.encodeHeader(queryMessageResult
                        .getBufferTotalSize()), queryMessageResult);
                ctx.channel().writeAndFlush(fileRegion).addListener(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ChannelFutureListener() {
                    @Override
                    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; operationComplete(ChannelFuture future) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
                        queryMessageResult.release();
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;future.isSuccess()) {
                            log.error(&lt;/span&gt;&quot;transfer query message by page cache failed, &quot;&lt;span&gt;, future.cause());
                        }
                    }
                });
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
                log.error(&lt;/span&gt;&quot;&quot;&lt;span&gt;, e);
                queryMessageResult.release();
            }

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        }

        response.setCode(ResponseCode.QUERY_NOT_FOUND);
        response.setRemark(&lt;/span&gt;&quot;can not find message, maybe time range not correct&quot;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; response;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; org.apache.rocketmq.store.DefaultMessageStore#queryMessage&lt;/span&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; QueryMessageResult queryMessage(String topic, String key, &lt;span&gt;int&lt;/span&gt; maxNum, &lt;span&gt;long&lt;/span&gt; begin, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; end) {
        QueryMessageResult queryMessageResult &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryMessageResult();

        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; lastQueryMsgTime =&lt;span&gt; end;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; 3; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 委托给 indexService 搜索记录, 时间是必备参数&lt;/span&gt;
            QueryOffsetResult queryOffsetResult = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexService.queryOffset(topic, key, maxNum, begin, lastQueryMsgTime);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (queryOffsetResult.getPhyOffsets().isEmpty()) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            Collections.sort(queryOffsetResult.getPhyOffsets());

            queryMessageResult.setIndexLastUpdatePhyoffset(queryOffsetResult.getIndexLastUpdatePhyoffset());
            queryMessageResult.setIndexLastUpdateTimestamp(queryOffsetResult.getIndexLastUpdateTimestamp());

            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; m = 0; m &amp;lt; queryOffsetResult.getPhyOffsets().size(); m++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; offset =&lt;span&gt; queryOffsetResult.getPhyOffsets().get(m);

                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

                    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; match = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
                    MessageExt msg &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.lookMessageByOffset(offset);
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (0 ==&lt;span&gt; m) {
                        lastQueryMsgTime &lt;/span&gt;=&lt;span&gt; msg.getStoreTimestamp();
                    }

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (match) {
                        SelectMappedBufferResult result &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.commitLog.getData(offset, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (result != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; size = result.getByteBuffer().getInt(0&lt;span&gt;);
                            result.getByteBuffer().limit(size);
                            result.setSize(size);
                            queryMessageResult.addMessage(result);
                        }
                    } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                        log.warn(&lt;/span&gt;&quot;queryMessage hash duplicate, {} {}&quot;&lt;span&gt;, topic, key);
                    }
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                    log.error(&lt;/span&gt;&quot;queryMessage exception&quot;&lt;span&gt;, e);
                }
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (queryMessageResult.getBufferTotalSize() &amp;gt; 0&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (lastQueryMsgTime &amp;lt;&lt;span&gt; begin) {
                &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
            }
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; queryMessageResult;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; QueryOffsetResult queryOffset(String topic, String key, &lt;span&gt;int&lt;/span&gt; maxNum, &lt;span&gt;long&lt;/span&gt; begin, &lt;span&gt;long&lt;/span&gt;&lt;span&gt; end) {
        List&lt;/span&gt;&amp;lt;Long&amp;gt; phyOffsets = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;Long&amp;gt;&lt;span&gt;(maxNum);

        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; indexLastUpdateTimestamp = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; indexLastUpdatePhyoffset = 0&lt;span&gt;;
        maxNum &lt;/span&gt;= Math.min(maxNum, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.defaultMessageStore.getMessageStoreConfig().getMaxMsgsNumBatch());
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.readWriteLock.readLock().lock();
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexFileList.isEmpty()) {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;从最后一个索引文件，依次搜索&lt;/span&gt;
                &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;this&lt;/span&gt;.indexFileList.size(); i &amp;gt; 0; i--&lt;span&gt;) {
                    IndexFile f &lt;/span&gt;= &lt;span&gt;this&lt;/span&gt;.indexFileList.get(i - 1&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; lastFile = i == &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexFileList.size();
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (lastFile) {
                        indexLastUpdateTimestamp &lt;/span&gt;=&lt;span&gt; f.getEndTimestamp();
                        indexLastUpdatePhyoffset &lt;/span&gt;=&lt;span&gt; f.getEndPhyOffset();
                    }
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判定该时间段是否数据是否在该索引文件中&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (f.isTimeMatched(begin, end)) {
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构建出 key的hash, 然后查找 slotValue, 然后得以索引数据, 然后将offset放入 phyOffsets 中&lt;/span&gt;
&lt;span&gt;                        f.selectPhyOffset(phyOffsets, buildKey(topic, key), maxNum, begin, end, lastFile);
                    }

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (f.getBeginTimestamp() &amp;lt;&lt;span&gt; begin) {
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }

                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (phyOffsets.size() &amp;gt;=&lt;span&gt; maxNum) {
                        &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            log.error(&lt;/span&gt;&quot;queryMsg exception&quot;&lt;span&gt;, e);
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.readWriteLock.readLock().unlock();
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; QueryOffsetResult(phyOffsets, indexLastUpdateTimestamp, indexLastUpdatePhyoffset);
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; org.apache.rocketmq.store.index.IndexFile#selectPhyOffset&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; selectPhyOffset(&lt;span&gt;final&lt;/span&gt; List&amp;lt;Long&amp;gt; phyOffsets, &lt;span&gt;final&lt;/span&gt; String key, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; maxNum,
        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; begin, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; end, &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; lock) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFile.hold()) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; keyHash =&lt;span&gt; indexKeyHashMethod(key);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; slotPos = keyHash % &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.hashSlotNum;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos *&lt;span&gt; hashSlotSize;

            FileLock fileLock &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; slotValue = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedByteBuffer.getInt(absSlotPos);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (slotValue &amp;lt;= invalidIndex || slotValue &amp;gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexHeader.getIndexCount()
                    &lt;/span&gt;|| &lt;span&gt;this&lt;/span&gt;.indexHeader.getIndexCount() &amp;lt;= 1&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超出搜索范围，不处理&lt;/span&gt;
                } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; nextIndexToRead =&lt;span&gt; slotValue; ; ) {
                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (phyOffsets.size() &amp;gt;=&lt;span&gt; maxNum) {
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }

                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; absIndexPos =&lt;span&gt;
                            IndexHeader.INDEX_HEADER_SIZE &lt;/span&gt;+ &lt;span&gt;this&lt;/span&gt;.hashSlotNum *&lt;span&gt; hashSlotSize
                                &lt;/span&gt;+ nextIndexToRead *&lt;span&gt; indexSize;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 依次读出 keyHash+offset+timeDiff+nextOffset&lt;/span&gt;
                        &lt;span&gt;int&lt;/span&gt; keyHashRead = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedByteBuffer.getInt(absIndexPos);
                        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; phyOffsetRead = &lt;span&gt;this&lt;/span&gt;.mappedByteBuffer.getLong(absIndexPos + 4&lt;span&gt;);

                        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; timeDiff = (&lt;span&gt;long&lt;/span&gt;) &lt;span&gt;this&lt;/span&gt;.mappedByteBuffer.getInt(absIndexPos + 4 + 8&lt;span&gt;);
                        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; prevIndexRead = &lt;span&gt;this&lt;/span&gt;.mappedByteBuffer.getInt(absIndexPos + 4 + 8 + 4&lt;span&gt;);

                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (timeDiff &amp;lt; 0&lt;span&gt;) {
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }

                        timeDiff &lt;/span&gt;*= 1000L&lt;span&gt;;
                        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据文件名可得到索引写入时间&lt;/span&gt;
                        &lt;span&gt;long&lt;/span&gt; timeRead = &lt;span&gt;this&lt;/span&gt;.indexHeader.getBeginTimestamp() +&lt;span&gt; timeDiff;
                        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; timeMatched = (timeRead &amp;gt;= begin) &amp;amp;&amp;amp; (timeRead &amp;lt;=&lt;span&gt; end);

                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (keyHash == keyHashRead &amp;amp;&amp;amp;&lt;span&gt; timeMatched) {
                            phyOffsets.add(phyOffsetRead);
                        }

                        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (prevIndexRead &amp;lt;=&lt;span&gt; invalidIndex
                            &lt;/span&gt;|| prevIndexRead &amp;gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexHeader.getIndexCount()
                            &lt;/span&gt;|| prevIndexRead == nextIndexToRead || timeRead &amp;lt;&lt;span&gt; begin) {
                            &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
                        }

                        nextIndexToRead &lt;/span&gt;=&lt;span&gt; prevIndexRead;
                    }
                }
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                log.error(&lt;/span&gt;&quot;selectPhyOffset exception &quot;&lt;span&gt;, e);
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fileLock != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        fileLock.release();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        log.error(&lt;/span&gt;&quot;Failed to release the lock&quot;&lt;span&gt;, e);
                    }
                }

                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedFile.release();
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　看起来挺费劲，但真正处理起来性能还好，虽然没有consumequeue高效，但有mmap和pagecache的加持，效率还是扛扛的。而且，搜索相对慢一些，用户也是可以接受的嘛。毕竟这只是一个附加功能，并非核心所在。&lt;/p&gt;
&lt;p&gt;　　而索引文件并没有使用什么高效的搜索算法，而是简单从最后一个文件遍历完成，因为时间戳不一定总是有规律的，与其随意查找，还不如直接线性查找。另外，实际上对于索引重建问题，搜索可能不一定会有效。不过，我们可以通过扩大搜索时间范围的方式，总是能够找到存在的数据。而且因其使用hash索引实现，性能还是不错的。&lt;/p&gt;
&lt;p&gt;　　另外，index索引文件与commitlog和consumequeue有一个不一样的地方，就是它不能进行顺序写，因为hash存储，写一定是任意的。且其slotValue以一些统计信息可能随时发生变化，这也给顺序写带来了不可解决的问题。&lt;/p&gt;
&lt;p&gt;　　其具体写索引过程如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; org.apache.rocketmq.store.index.IndexFile#putKey&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; putKey(&lt;span&gt;final&lt;/span&gt; String key, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; phyOffset, &lt;span&gt;final&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; storeTimestamp) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.indexHeader.getIndexCount() &amp;lt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexNum) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; keyHash =&lt;span&gt; indexKeyHashMethod(key);
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; slotPos = keyHash % &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.hashSlotNum;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; absSlotPos = IndexHeader.INDEX_HEADER_SIZE + slotPos *&lt;span&gt; hashSlotSize;

            FileLock fileLock &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;

            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先尝试拉取slot对应的数据
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果为0则说明是第一次写入, 否则为当前的索引条数&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; slotValue = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedByteBuffer.getInt(absSlotPos);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (slotValue &amp;lt;= invalidIndex || slotValue &amp;gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexHeader.getIndexCount()) {
                    slotValue &lt;/span&gt;=&lt;span&gt; invalidIndex;
                }

                &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; timeDiff = storeTimestamp - &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexHeader.getBeginTimestamp();

                timeDiff &lt;/span&gt;= timeDiff / 1000&lt;span&gt;;

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.indexHeader.getBeginTimestamp() &amp;lt;= 0&lt;span&gt;) {
                    timeDiff &lt;/span&gt;= 0&lt;span&gt;;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (timeDiff &amp;gt;&lt;span&gt; Integer.MAX_VALUE) {
                    timeDiff &lt;/span&gt;=&lt;span&gt; Integer.MAX_VALUE;
                } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (timeDiff &amp;lt; 0&lt;span&gt;) {
                    timeDiff &lt;/span&gt;= 0&lt;span&gt;;
                }
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 直接计算出本次存储的索引记录位置
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因索引条数只会依次增加，故索引数据将表现为顺序写样子，主要是保证了数据不会写冲突了&lt;/span&gt;
                &lt;span&gt;int&lt;/span&gt; absIndexPos =&lt;span&gt;
                    IndexHeader.INDEX_HEADER_SIZE &lt;/span&gt;+ &lt;span&gt;this&lt;/span&gt;.hashSlotNum *&lt;span&gt; hashSlotSize
                        &lt;/span&gt;+ &lt;span&gt;this&lt;/span&gt;.indexHeader.getIndexCount() *&lt;span&gt; indexSize;
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 按协议写入内容即可&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.mappedByteBuffer.putInt(absIndexPos, keyHash);
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mappedByteBuffer.putLong(absIndexPos + 4&lt;span&gt;, phyOffset);
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mappedByteBuffer.putInt(absIndexPos + 4 + 8, (&lt;span&gt;int&lt;/span&gt;&lt;span&gt;) timeDiff);
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mappedByteBuffer.putInt(absIndexPos + 4 + 8 + 4&lt;span&gt;, slotValue);
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 写入slotValue为当前可知的索引记录条数
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 即每次写入索引之后，如果存在hash冲突，那么它会写入自身的位置
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而此时 slotValue 必定存在一个值，那就是上一个发生冲突的索引，从而形成自然的链表
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查找数据时，只需根据slotValue即可以找到上一个写入的索引，这设计妙哉！
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 做了2点关键性保证：1. 数据自增不冲突; 2. hash冲突自刷新; 磁盘版的hash结构已然形成&lt;/span&gt;
                &lt;span&gt;this&lt;/span&gt;.mappedByteBuffer.putInt(absSlotPos, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexHeader.getIndexCount());

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.indexHeader.getIndexCount() &amp;lt;= 1&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexHeader.setBeginPhyOffset(phyOffset);
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexHeader.setBeginTimestamp(storeTimestamp);
                }

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (invalidIndex ==&lt;span&gt; slotValue) {
                    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexHeader.incHashSlotCount();
                }
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexHeader.incIndexCount();
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexHeader.setEndPhyOffset(phyOffset);
                &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexHeader.setEndTimestamp(storeTimestamp);

                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
                log.error(&lt;/span&gt;&quot;putKey exception, Key: &quot; + key + &quot; KeyHashCode: &quot; +&lt;span&gt; key.hashCode(), e);
            } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fileLock != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                        fileLock.release();
                    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException e) {
                        log.error(&lt;/span&gt;&quot;Failed to release the lock&quot;&lt;span&gt;, e);
                    }
                }
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            log.warn(&lt;/span&gt;&quot;Over index file capacity: index count = &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexHeader.getIndexCount()
                &lt;/span&gt;+ &quot;; index max num = &quot; + &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.indexNum);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　rocketmq 巧妙地使用了自增结构和hash slot, 完美实现一个磁盘版的hash索引。相信这也会给我们平时的工作带来一些提示。&lt;/p&gt;

&lt;h3&gt;6. 写在最后&lt;/h3&gt;
&lt;p&gt;　　以上就是本文对rocketmq的存储模型设计的解析了，通过这些解析，相信大家对其工作原理也会有质的理解。存储实际上是目前我们的许多的系统中的非常核心部分，因为大部分的业务几乎都是在存储之前做一些简单的计算。&lt;/p&gt;
&lt;p&gt;      很显然业务很重要，但有了存储的底子，还何愁业务实现难？&lt;/p&gt;


</description>
<pubDate>Sat, 02 Jan 2021 15:08:00 +0000</pubDate>
<dc:creator>等你归去来</dc:creator>
<og:description>消息中间件，说是一个通信组件也没有错，因为它的本职工作是做消息的传递。然而要做到高效的消息传递，很重要的一点是数据结构，数据结构设计的好坏，一定程度上决定了该消息组件的性能以及能力上限。 1. 消息中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yougewe/p/14224366.html</dc:identifier>
</item>
<item>
<title>Spring Cloud Hystrix源码篇（十二） - 童话述说我的结局</title>
<link>http://www.cnblogs.com/xing1/p/14223358.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xing1/p/14223358.html</guid>
<description>&lt;p&gt;Hystrix流程图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210102144532612-1184521007.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;Hystrix整个工作流如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构造一个 HystrixCommand或HystrixObservableCommand对象，用于封装请求，并在构造方法配置请求被执行需要的参数；&lt;/li&gt;
&lt;li&gt;执行命令，Hystrix提供了4种执行命令的方法，后面详述；&lt;/li&gt;
&lt;li&gt;判断是否使用缓存响应请求，若启用了缓存，且缓存可用，直接使用缓存响应请求。Hystrix支持请求缓存，但需要用户自定义启动；&lt;/li&gt;
&lt;li&gt;判断熔断器是否打开，如果打开，跳到第8步；&lt;/li&gt;
&lt;li&gt;判断线程池/队列/信号量是否已满，已满则跳到第8步；&lt;/li&gt;
&lt;li&gt;执行HystrixObservableCommand.construct()或HystrixCommand.run()，如果执行失败或者超时，跳到第8步；否则，跳到第9步；&lt;/li&gt;
&lt;li&gt;统计熔断器监控指标；&lt;/li&gt;
&lt;li&gt;走Fallback备用逻辑&lt;/li&gt;
&lt;li&gt;返回请求响应&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;从流程图上可知道，第5步线程池/队列/信号量已满时，还会执行第7步逻辑，更新熔断器统计信息，而第6步无论成功与否，都会更新熔断器统计信息。&lt;/p&gt;

&lt;p&gt;hystrix在服务降级熔断的过程中有几个步骤他是必须要去完成的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt; 可配置化的降级策略（根据不同的服务降级类型配置不同的降级策略方案）:
&lt;ul&gt;&lt;li&gt;三种方式：信号量/线程 、超时（默认1s）、熔断（错误率）&lt;/li&gt;
&lt;li&gt;在HystrixCommandProperty类中通过相关属性去配置改变他的默认策略（上篇中有说明过）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;可以识别的降级边界：
&lt;ul&gt;&lt;li&gt;@HystrixCommand(Spring AOP通过注解标注一个接口的资源，去表示说明这个接口需要通过Hystrix来接管这个请求，如果达到注解内的配置要求就熔断)&lt;/li&gt;
&lt;li&gt;自己去继承HystrixCommand 抽象类，等下演示下，这玩意还挺好玩的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;数据采集：
&lt;ul&gt;&lt;li&gt;如何触发熔断（上篇幅也说过10s 内20个请求 ，错误率达到50），这里引出的问题是如何采集数据，如何统计数据.&lt;/li&gt;
&lt;li&gt;SEMAPHORE，最大并发数量 （它底层其实就是个AQS 统计次数tryAcquire(), acquire()）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;行为干预： 触发降级/熔断之后，对正常业务产生影响&lt;/li&gt;
&lt;li&gt;结果干预： 通过fallback()返回数据&lt;/li&gt;
&lt;li&gt;自动恢复（处于熔断状态下，会每隔5s尝试去恢复）&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt; 2.1、通过HystrixCommand 接管我们定义的请求&lt;/h2&gt;
&lt;p&gt;上一篇幅我是通过注解的方式来进行服务熔错的，这次不通过注解换一种方式，首先在spring-cloud-user服务中写以下内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210102161558404-196684410.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210102162125662-1301554900.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 然后启动服务访问浏览器，结果如果我想的一样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210102162355427-986689618.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;h2&gt; 2.2、Hystrix是如何工作的&lt;/h2&gt;
&lt;p&gt;下面演示个带超时降级的Hystrix注解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210102164117278-1720757661.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 然后用AOP写自己的拦截规则&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210102170315609-42207692.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 *这里面用到的是AOP的知识点，如果不了解可以先自行补下，后面我有空把Spring的AOP原理也写下，这样回头看这个就没这么难了
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
@Aspect  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;切入&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; GhyHystrixAspect {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过线程池去请求&lt;/span&gt;
    ExecutorService executorService= Executors.newFixedThreadPool(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义切点针对GhyHystrix进行切入&lt;/span&gt;
    @Pointcut(value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;@annotation(GhyHystrix)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; pointCut(){}
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;切入后执行的方法&lt;/span&gt;
    @Around(value = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pointCut()&amp;amp;&amp;amp;@annotation(hystrixCommand)&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object doPointCut(ProceedingJoinPoint joinPoint, GhyHystrix hystrixCommand) throws InterruptedException, ExecutionException, TimeoutException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义超时降级&lt;/span&gt;
        &lt;span&gt;int&lt;/span&gt; timeout=&lt;span&gt;hystrixCommand.timeout();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;前置的判断逻辑&lt;/span&gt;
        Future future=executorService.submit(()-&amp;gt;&lt;span&gt;{
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; joinPoint.proceed(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行目标方法&lt;/span&gt;
            } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable throwable) {
                throwable.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        });
        Object result;
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到开始和结束时间判断是否超时，如果超时就降级&lt;/span&gt;
            result=future.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(timeout, TimeUnit.MILLISECONDS);
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (InterruptedException | ExecutionException |&lt;span&gt; TimeoutException e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;超时了就取消请求&lt;/span&gt;
            future.cancel(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 先判断是否为空如果空就把异常抛出去&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(StringUtils.isBlank(hystrixCommand.fallback())){
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用fallback&lt;/span&gt;
            result=&lt;span&gt;invokeFallback(joinPoint,hystrixCommand.fallback());
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;反射调用&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Object invokeFallback(ProceedingJoinPoint joinPoint,String fallback) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
        MethodSignature signature&lt;/span&gt;=&lt;span&gt;(MethodSignature)joinPoint.getSignature();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;拿到方法的信息&lt;/span&gt;
        Method method=&lt;span&gt;signature.getMethod();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到参数类型&lt;/span&gt;
        Class&amp;lt;?&amp;gt;[] parameterTypes=&lt;span&gt;method.getParameterTypes();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以上是获取被代理的方法的参数和Method
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到fallback方法&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            Method fallbackMethod&lt;/span&gt;=&lt;span&gt;joinPoint.getTarget().getClass().getMethod(fallback,parameterTypes);
            fallbackMethod.setAccessible(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;完成反射调用&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt;&lt;span&gt; fallbackMethod.invoke(joinPoint.getTarget(),joinPoint.getArgs());
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            e.printStackTrace();
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后再写个调用逻辑，用自己定义的注解&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210102170402149-1134325385.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 浏览器访问，返回的不是我们刚刚定义的降级内容，其实这也挺好想的，我用的是之前的项目，之前在spring-cloud-api工程中定义了熔断规则，改一下就好&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210102170427859-1998368673.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;p&gt; 将这此内容改下就好，还有配置文件隐藏下，这里就不搞了&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210102170600979-1287571914.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;当请求过来时，如果请求失败，先判断请求次数是否达到了最小请求次数，再判断错误率是否达到了阈值，如果没达到就继续请求，这个错误率的统计时间默认是10S；如果达到了阈值就要打开断路器，打开断 路器后有5秒的时间是熔断状态，5秒后，如果有请求过来，就会试着把请求发送到远程服务，如果成功，断路器就关闭；如果失败断路器继续开启；这个流程就引出第一个概念，那就是滑动窗口&lt;/p&gt;
&lt;h2&gt;3.1、滑动窗口&lt;/h2&gt;
&lt;p&gt;在 hystrix 里，大量使用了 RxJava 这个响应式函数编程框架，滑动窗口的实现也是使用了 RxJava 框架。它其实就是一个 流量控制技术；竟然提到了滑动窗口，那就必须要提两上东西，一个是计数器，另一个就是滑动窗口;为了更通俗的理解计数器和滑动窗口关系，就以一个例子说明；假如有一个场景：要做一个请求限制，限制要求一分钟内最多只能有60个请求通过，这时最通用的做方就是用个计数器，计数一分钟内请求的次数，在这一分钟内每来一个请求计数器就加1；一分钟过后进入下一个一分钟时计数器就把计数归零重新计数；所以说如果要限流判断就只用判断这一分钟内的计数量就可以了，但这种做法在每个1分钟的临界值时是有问题的，问题是啥呢，假如说在0到58S时都没有请求，但是突然在第59S时一下子来了60个请求，在60S时再来60个请求，这个时候发生的情况是在相邻两秒内一下子来了120个请求，此时因为59S在第一个时间段；60S在第二个时间段，所以没有满足触发熔断条件，这就导至了相邻两秒间的请求量过了阈值，系统很可能炸了，为此引出了另一个玩意，那就是滑动窗口；滑动窗口把一分钟分成6个窗口，每个窗口是10S，红色框代表可以滑动的滑动窗口，黑色的窗口代表10S的统计数值，第一个10S统计 完成后红色滑动窗口会向前滑动一格，改成滑动窗口后他统计的就是红色滑动窗口内的访问量总和了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210102205538265-1705514939.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;hystrix是通过滑动窗口统计的，他一共有10个窗口，每个窗口代表1S，所以他统计的是他10S内的数据&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1287410/202101/1287410-20210102210601675-1676126993.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span lang=&quot;zh-cn&quot;&gt;上图的每个小矩形代表一个桶，可以看到，每个桶都记录着&lt;span lang=&quot;en-us&quot;&gt;1&lt;span lang=&quot;zh-cn&quot;&gt;秒内的四个指标数据：成功量、失败量、超时量和拒绝量，这里的拒绝量指的就是上面流程图中【信号量&lt;span lang=&quot;en-us&quot;&gt;/线程池资源检查&lt;span lang=&quot;zh-cn&quot;&gt;】中被拒绝的流量。&lt;span lang=&quot;en-us&quot;&gt;10个桶合起来是一个完整的滑动窗口&lt;span lang=&quot;zh-cn&quot;&gt;，所以计算一个滑动窗口的总数据需要将&lt;span lang=&quot;en-us&quot;&gt;10个桶的数据加起来&lt;span lang=&quot;zh-cn&quot;&gt;。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;Hystrix熔断的@HystrixCommand注解，是通过HystrixCommandAspect这个切面来处理的。其中关注@Around注解声明的方法，它针对于请求合并，以及降级的注解进行代理。这里重点针对HystrixCommand这个注解进行详细分析。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;getMethodFromTarget 获取目标方法信息&lt;/li&gt;
&lt;li&gt;MetaHolder metaHolder = metaHolderFactory.create(joinPoint); 获取元数据，比如调用方法，HystrixProperty注解数据、方法参数等&lt;/li&gt;
&lt;li&gt;HystrixCommandFactory.getInstance().create 获取调用者，它持有一个命令对象，并且可以在合适的时候通过这个命令对象完成具体的业务逻辑&lt;/li&gt;
&lt;li&gt;execute，执行命令&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
@Around(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hystrixCommandAnnotationPointcut() ||&lt;/span&gt;
hystrixCollapserAnnotationPointcut()&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Object methodsAnnotatedWithHystrixCommand(final ProceedingJoinPoint
joinPoint) throws Throwable {
  Method method &lt;/span&gt;=&lt;span&gt; getMethodFromTarget(joinPoint);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省略代码...&lt;/span&gt;
  MetaHolderFactory metaHolderFactory =&lt;span&gt;
META_HOLDER_FACTORY_MAP.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(HystrixPointcutType.of(method));
  MetaHolder metaHolder &lt;/span&gt;=&lt;span&gt; metaHolderFactory.create(joinPoint);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是异步，则创建GenericObservableCommand， 否则，则创建GenericCommand&lt;/span&gt;
  HystrixInvokable invokable =&lt;span&gt;
HystrixCommandFactory.getInstance().create(metaHolder);
 
  ExecutionType executionType &lt;/span&gt;= metaHolder.isCollapserAnnotationPresent() ?&lt;span&gt;
    metaHolder.getCollapserExecutionType() : metaHolder.getExecutionType();
  Object result;
  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!metaHolder.isObservable()) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否是响应式的（由于我们这些都是同步的会走&lt;/span&gt;
&lt;span&gt;这个逻辑）&lt;br/&gt;//默认是走这里面，用命令执行器去执行
      result &lt;/span&gt;=&lt;span&gt; CommandExecutor.execute(invokable, executionType,
metaHolder);
   } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      result &lt;/span&gt;=&lt;span&gt; executeObservable(invokable, executionType, metaHolder);
   }
 } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (HystrixBadRequestException e) {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; e.getCause();
 } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (HystrixRuntimeException e) {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; hystrixRuntimeExceptionToThrowable(metaHolder, e);
}
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;点击进入 CommandExecutor类的execute方法，这个方法主要用来执行命令，从代码中可以看出这里有三个执行类型，分别是同步、异步、以及响应式。其中，响应式又分为Cold Observable（observable.toObservable()） 和 HotObservable（observable.observe()）&lt;/p&gt;
&lt;p&gt;默认的executionType=SYNCHRONOUS ，同步请求。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;execute():同步执行，返回一个单一的对象结果，发生错误时抛出异常。&lt;/li&gt;
&lt;li&gt;queue():异步执行，返回一个 Future 对象，包含着执行结束后返回的单一结果。&lt;/li&gt;
&lt;li&gt;observe():这个方法返回一个 Observable 对象，它代表操作的多个结果，但是已经被订阅者消费掉了。&lt;/li&gt;
&lt;li&gt;toObservable():这个方法返回一个 Observable 对象，它代表操作的多个结果，需要咱们自己手动订阅并消费掉。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是，Hystrix用到了RxJava这个框架，它是一个响应式编程框架，在Android里面用得比较多 &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; Object execute(HystrixInvokable invokable, ExecutionType executionType, MetaHolder metaHolder) throws RuntimeException {
        Validate.notNull(invokable);
        Validate.notNull(metaHolder);
         
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (executionType) {&lt;br/&gt;&lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; SYNCHRONOUS: {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; castToExecutable(invokable, executionType).execute();
            }
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; ASYNCHRONOUS: {
                HystrixExecutable executable &lt;/span&gt;=&lt;span&gt; castToExecutable(invokable, executionType);
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (metaHolder.hasFallbackMethodCommand()
                        &lt;/span&gt;&amp;amp;&amp;amp; ExecutionType.ASYNCHRONOUS ==&lt;span&gt; metaHolder.getFallbackExecutionType()) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FutureDecorator(executable.queue());
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; executable.queue();
            }
            &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; OBSERVABLE: {
                HystrixObservable observable &lt;/span&gt;=&lt;span&gt; castToObservable(invokable);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; ObservableExecutionMode.EAGER == metaHolder.getObservableExecutionMode() ?&lt;span&gt; observable.observe() : observable.toObservable();
            }
            &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unsupported execution type: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; executionType);
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为是走默认的，所以进入HystrixCommand类的execute()方法；这个方法中，首先调用queue()，这个方法会返回一个future对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
  &lt;span&gt;public&lt;/span&gt;&lt;span&gt; R execute() {
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; queue().&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; Exceptions.sneakyThrow(decomposeException(e));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;queue这个方法中，返回了一个Future对象，这个future对象的实现是f，f是以匿名内部类，它是Java.util.concurrent中定一个的一个异步带返回值对象。当调用queue().get()方法时，最终是委派给了delegate.get 方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; Future&amp;lt;R&amp;gt;&lt;span&gt; queue() {
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
    * The Future returned by Observable.toBlocking().toFuture() does not
implement the
    * interruption of the execution thread when the &quot;mayInterrupt&quot; flag of
Future.cancel(boolean) is set to true;
    * thus, to comply with the contract of Future, we must wrap around it.
    &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  final Future&lt;/span&gt;&amp;lt;R&amp;gt; &lt;span&gt;delegate&lt;/span&gt; =&lt;span&gt; toObservable().toBlocking().toFuture();
  final Future&lt;/span&gt;&amp;lt;R&amp;gt; f = &lt;span&gt;new&lt;/span&gt; Future&amp;lt;R&amp;gt;&lt;span&gt;() {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean cancel(boolean mayInterruptIfRunning) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;.isCancelled()) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
     }
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;
(HystrixCommand.&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getProperties().executionIsolationThreadInterruptOnFutureCa
ncel().&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;()) {
        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
          * The only valid transition here is false -&amp;gt; true. If there
are two futures, say f1 and f2, created by this command
          * (which is super-weird, but has never been prohibited),
and calls to f1.cancel(true) and to f2.cancel(false) are
          * issued by different threads, it's unclear about what
value would be used by the time mayInterruptOnCancel is checked.
          * The most consistent way to deal with this scenario is to
say that if *any* cancellation is invoked with interruption,
          * than that interruption request cannot be taken back.
          &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
        interruptOnFutureCancel.compareAndSet(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
mayInterruptIfRunning);
     }
      final boolean res &lt;/span&gt;= &lt;span&gt;delegate&lt;/span&gt;.cancel(interruptOnFutureCancel.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;());
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!isExecutionComplete() &amp;amp;&amp;amp; interruptOnFutureCancel.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;()) {
        final Thread t &lt;/span&gt;= executionThread.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (t != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;t.equals(Thread.currentThread())) {
t.interrupt();
       }
     }
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; res;
   }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean isCancelled() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;.isCancelled();
   }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; boolean isDone() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt;&lt;span&gt;.isDone();
   }&lt;br/&gt;//最终会调用此方法
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; R &lt;span&gt;get&lt;/span&gt;&lt;span&gt;() throws InterruptedException, ExecutionException {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();
   }
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; R &lt;span&gt;get&lt;/span&gt;(&lt;span&gt;long&lt;/span&gt;&lt;span&gt; timeout, TimeUnit unit) throws InterruptedException,
ExecutionException, TimeoutException {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;delegate&lt;/span&gt;.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(timeout, unit);
   }
 };
  &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; special handling of error states that throw immediately &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (f.isDone()) {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
      f.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;();
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; f;
   } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
      Throwable t &lt;/span&gt;=&lt;span&gt; decomposeException(e);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (t instanceof HystrixBadRequestException) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; f;
     } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (t instanceof HystrixRuntimeException) {
        HystrixRuntimeException hre &lt;/span&gt;=&lt;span&gt; (HystrixRuntimeException) t;
        &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt;&lt;span&gt; (hre.getFailureType()) {
          &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; COMMAND_EXCEPTION:
          &lt;/span&gt;&lt;span&gt;case&lt;/span&gt;&lt;span&gt; TIMEOUT:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; we don't throw these types from queue() only from&lt;/span&gt;
queue().&lt;span&gt;get&lt;/span&gt;() &lt;span&gt;as&lt;/span&gt;&lt;span&gt; they are execution errors
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; f;
          &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt;:
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; these are errors we throw from queue() as they as&lt;/span&gt;
&lt;span&gt;rejection type errors
            &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; hre;
       }
     } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; Exceptions.sneakyThrow(t);
     }
   }
 }
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; f;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为最终是委派给了delegate.get 方法执行，而delegate在开头final Future&amp;lt;R&amp;gt; delegate = toObservable().toBlocking().toFuture();中，所以进入toObservable()方法中，在RxJava中，分为几种角色&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Observable（被观察者），它的主要作用是产生事件&lt;/li&gt;
&lt;li&gt;Observer（观察者），它的作用是接收事件并作出相应&lt;/li&gt;
&lt;li&gt;Subscribe（订阅），它用来连接被观察者和观察者&lt;/li&gt;
&lt;li&gt;Event（事件），被观察者、观察者、沟通的载体&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在queue中，调用toObservable()方法创建一个被观察者。通过Observable定义一个被观察者，这个被观察者会被toObservable().toBlocking().toFuture() ，实际上就是返回可获得 run() 抽象方法执行结果的Future 。 run() 方法由子类实现，执行正常的业务逻辑。在下面这段代码中，当存在subscriber时，便会调用Func0#call() 方法，而这个subscriber是在 toBlocking() 中被订阅的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;调用 isRequestCachingEnabled(); 判断请求结果缓存功能是否开启，如果开启并且命中了缓存，则会以Observable形式返回一个缓存结果&lt;/li&gt;
&lt;li&gt;创建执行命令的Observable： hystrixObservable&lt;/li&gt;
&lt;li&gt;当缓存处于开启状态并且没有命中缓存时，则创建一个“订阅了执行命令的Observable”：HystrixCommandResponseFromCache
&lt;ul&gt;&lt;li&gt;创建存储到缓存的Observable： HystrixCachedObservable&lt;/li&gt;
&lt;li&gt;将toCache添加到缓存中，返回获取缓存的Observable：fromCache&lt;/li&gt;
&lt;li&gt;如果添加失败: fromCache!=null, 则调用 toCache.unsubscribe() 方法，取消HystrixCachedObservable 的订阅&lt;/li&gt;
&lt;li&gt;如果添加成功，则调用 toCache.toObservable(); 获得缓存Observable&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;当缓存特性没有开启时，则返回执行命令的Observable。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;public&lt;/span&gt; Observable&amp;lt;R&amp;gt;&lt;span&gt; toObservable() {
        final AbstractCommand&lt;/span&gt;&amp;lt;R&amp;gt; _cmd = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;doOnCompleted handler already did all of the SUCCESS work
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;doOnError handler already did all of the FAILURE/TIMEOUT/REJECTION/BAD_REQUEST work&lt;/span&gt;
        final Action0 terminateCommandCleanup = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Action0() {

            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call() {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_cmd.commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.TERMINAL)) {
                    handleCommandEnd(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;user code never ran&lt;/span&gt;
                } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_cmd.commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.TERMINAL)) {
                    handleCommandEnd(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;user code did run&lt;/span&gt;
&lt;span&gt;                }
            }
        };

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;mark the command as CANCELLED and store the latency (in addition to standard cleanup)&lt;/span&gt;
        final Action0 unsubscribeCommandCleanup = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Action0() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call() {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_cmd.commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED, CommandState.UNSUBSCRIBED)) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_cmd.executionResult.containsTerminalEvent()) {
                        _cmd.eventNotifier.markEvent(HystrixEventType.CANCELLED, _cmd.commandKey);
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                            executionHook.onUnsubscribe(_cmd);
                        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable hookEx) {
                            logger.warn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error calling HystrixCommandExecutionHook.onUnsubscribe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, hookEx);
                        }
                        _cmd.executionResultAtTimeOfCancellation &lt;/span&gt;=&lt;span&gt; _cmd.executionResult
                                .addEvent((&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;) (System.currentTimeMillis() -&lt;span&gt; _cmd.commandStartTimestamp), HystrixEventType.CANCELLED);
                    }
                    handleCommandEnd(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;user code never ran&lt;/span&gt;
                } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_cmd.commandState.compareAndSet(CommandState.USER_CODE_EXECUTED, CommandState.UNSUBSCRIBED)) {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;_cmd.executionResult.containsTerminalEvent()) {
                        _cmd.eventNotifier.markEvent(HystrixEventType.CANCELLED, _cmd.commandKey);
                        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                            executionHook.onUnsubscribe(_cmd);
                        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable hookEx) {
                            logger.warn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error calling HystrixCommandExecutionHook.onUnsubscribe&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, hookEx);
                        }
                        _cmd.executionResultAtTimeOfCancellation &lt;/span&gt;=&lt;span&gt; _cmd.executionResult
                                .addEvent((&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;) (System.currentTimeMillis() -&lt;span&gt; _cmd.commandStartTimestamp), HystrixEventType.CANCELLED);
                    }
                    handleCommandEnd(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;user code did run&lt;/span&gt;
&lt;span&gt;                }
            }
        };

        final Func0&lt;/span&gt;&amp;lt;Observable&amp;lt;R&amp;gt;&amp;gt; applyHystrixSemantics = &lt;span&gt;new&lt;/span&gt; Func0&amp;lt;Observable&amp;lt;R&amp;gt;&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Observable&amp;lt;R&amp;gt;&lt;span&gt; call() {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (commandState.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;().equals(CommandState.UNSUBSCRIBED)) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Observable.never();
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; applyHystrixSemantics(_cmd);
            }
        };

        final Func1&lt;/span&gt;&amp;lt;R, R&amp;gt; wrapWithAllOnNextHooks = &lt;span&gt;new&lt;/span&gt; Func1&amp;lt;R, R&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; R call(R r) {
                R afterFirstApplication &lt;/span&gt;=&lt;span&gt; r;

                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    afterFirstApplication &lt;/span&gt;=&lt;span&gt; executionHook.onComplete(_cmd, r);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable hookEx) {
                    logger.warn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error calling HystrixCommandExecutionHook.onComplete&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, hookEx);
                }

                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; executionHook.onEmit(_cmd, afterFirstApplication);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable hookEx) {
                    logger.warn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error calling HystrixCommandExecutionHook.onEmit&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, hookEx);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; afterFirstApplication;
                }
            }
        };

        final Action0 fireOnCompletedHook &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Action0() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call() {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    executionHook.onSuccess(_cmd);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable hookEx) {
                    logger.warn(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Error calling HystrixCommandExecutionHook.onSuccess&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, hookEx);
                }
            }
        };
&lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Observable.defer(&lt;span&gt;new&lt;/span&gt; Func0&amp;lt;Observable&amp;lt;R&amp;gt;&amp;gt;&lt;span&gt;() {
  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Observable&amp;lt;R&amp;gt;&lt;span&gt; call() {
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; this is a stateful object so can only be used once &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; CAS保证命令只执行一次 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;commandState.compareAndSet(CommandState.NOT_STARTED,
CommandState.OBSERVABLE_CHAIN_CREATED)) {
      IllegalStateException ex &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;This instance&lt;/span&gt;
can only be executed once. Please instantiate a &lt;span&gt;new&lt;/span&gt; instance.&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;TODO make a new error type for this&lt;/span&gt;
      &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HystrixRuntimeException(FailureType.BAD_REQUEST_EXCEPTION,
_cmd.getClass(), getLogMessagePrefix() &lt;/span&gt;+ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; command executed multiple times -&lt;/span&gt;
&lt;span&gt;this&lt;/span&gt; &lt;span&gt;is&lt;/span&gt; not permitted.&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ex, null);&lt;/span&gt;
&lt;span&gt;   }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 命令开始时间戳&lt;/span&gt;
    commandStartTimestamp =&lt;span&gt; System.currentTimeMillis();
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 打印日志&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (properties.requestLogEnabled().&lt;span&gt;get&lt;/span&gt;&lt;span&gt;()) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; log this command execution regardless of what happened&lt;/span&gt;
      &lt;span&gt;if&lt;/span&gt; (currentRequestLog != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
currentRequestLog.addExecutedCommand(_cmd);
     }
   }
   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 缓存开关，缓存KEY（这个是Hystrix中请求缓存功能，hystrix支持将一个请求结果缓存起&lt;/span&gt;
&lt;span&gt;来，下一个具有相同key的请求将直接从缓存中取出结果，减少请求开销）
    final boolean requestCacheEnabled &lt;/span&gt;=&lt;span&gt; isRequestCachingEnabled();
    final String cacheKey &lt;/span&gt;=&lt;span&gt; getCacheKey();
    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; try from cache first &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (requestCacheEnabled) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果开启了缓存机制，则从缓存中获取结果&lt;/span&gt;
      HystrixCommandResponseFromCache&amp;lt;R&amp;gt; fromCache =&lt;span&gt;
(HystrixCommandResponseFromCache&lt;/span&gt;&amp;lt;R&amp;gt;) requestCache.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;(cacheKey);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fromCache != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        isResponseFromCache &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handleRequestCacheHitAndEmitValues(fromCache, _cmd);
     }
   }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 声明执行命令的Observable&lt;/span&gt;
    Observable&amp;lt;R&amp;gt; hystrixObservable =&lt;span&gt;
      Observable.defer(applyHystrixSemantics)
     .map(wrapWithAllOnNextHooks);
    Observable&lt;/span&gt;&amp;lt;R&amp;gt;&lt;span&gt; afterCache;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;保存请求结果到缓存中&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (requestCacheEnabled &amp;amp;&amp;amp; cacheKey != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; wrap it for caching&lt;/span&gt;
      HystrixCachedObservable&amp;lt;R&amp;gt; toCache =&lt;span&gt;
HystrixCachedObservable.&lt;/span&gt;&lt;span&gt;from&lt;/span&gt;&lt;span&gt;(hystrixObservable, _cmd);
      HystrixCommandResponseFromCache&lt;/span&gt;&amp;lt;R&amp;gt; fromCache =&lt;span&gt;
(HystrixCommandResponseFromCache&lt;/span&gt;&amp;lt;R&amp;gt;&lt;span&gt;) requestCache.putIfAbsent(cacheKey,
toCache);
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (fromCache != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; another thread beat us so we'll use the cached value instead&lt;/span&gt;
&lt;span&gt;        toCache.unsubscribe();
        isResponseFromCache &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handleRequestCacheHitAndEmitValues(fromCache, _cmd);
     } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; we just created an ObservableCommand so we cast and return it&lt;/span&gt;
        afterCache =&lt;span&gt; toCache.toObservable();
     }
   } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
      afterCache &lt;/span&gt;=&lt;span&gt; hystrixObservable;
   }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; afterCache
     .doOnTerminate(terminateCommandCleanup)   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; perform cleanup once&lt;/span&gt;
(either on normal terminal state (&lt;span&gt;this&lt;/span&gt;&lt;span&gt; line), or unsubscribe (next line))
     .doOnUnsubscribe(unsubscribeCommandCleanup) &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; perform cleanup once&lt;/span&gt;
&lt;span&gt;     .doOnCompleted(fireOnCompletedHook);
 }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行命令的Observable的定义如下，通过defer定义了一个 applyHystrixSemantics 的事件。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
final Func0&amp;lt;Observable&amp;lt;R&amp;gt;&amp;gt; applyHystrixSemantics = &lt;span&gt;new&lt;/span&gt; Func0&amp;lt;Observable&amp;lt;R&amp;gt;&amp;gt;&lt;span&gt;() {
  @Override
 &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Observable&amp;lt;R&amp;gt;&lt;span&gt; call() {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当commandState处于UNSUBSCRIBED时，不执行命令&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt; (commandState.&lt;span&gt;get&lt;/span&gt;&lt;span&gt;().equals(CommandState.UNSUBSCRIBED)) {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Observable.never();
   }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回执行命令的Observable&lt;/span&gt;
    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; applyHystrixSemantics(_cmd);
 }
};
Observable&lt;/span&gt;&amp;lt;R&amp;gt; hystrixObservable =&lt;span&gt;
  Observable.defer(applyHystrixSemantics)
 .map(wrapWithAllOnNextHooks);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;applyHystrixSemantics方法；假设缓存特性未开启或者未命中缓存，那么代码将执行 applyHystrixSemantics 。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;传入的_cmd是一个GenericCommand，最终执行这个command中的run方法，本质就是完成对queryOrder方法的代理&lt;/li&gt;
&lt;li&gt;circuitBreaker.allowRequest() 如果为true，表示当前不处于熔断状态，正常执行，否则，调用 handleShortCircuitViaFallback 实现服务降级，如果我们配置了fallback方法，则会获得我们配置的fallback执行&lt;/li&gt;
&lt;li&gt;如果当前hystrix处于未熔断状态，则&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;getExecutionSemaphore 判断当前策略是否为信号量（TryableSemaphoreNoOp/TryableSemaphoreActual），如果是，则调用 tryAcquire 来获取信号量。如果当前信号量满了，则调用 handleSemaphoreRejectionViaFallback 方法。&lt;/li&gt;
&lt;li&gt;调用 executeCommandAndObserve 获取命令执行Observable。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
   &lt;span&gt;private&lt;/span&gt; Observable&amp;lt;R&amp;gt; applyHystrixSemantics(final AbstractCommand&amp;lt;R&amp;gt;&lt;span&gt; _cmd) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mark that we're starting execution on the ExecutionHook
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; if this hook throws an exception, then a fast-fail occurs with no fallback.  No state is left inconsistent&lt;/span&gt;
&lt;span&gt;        executionHook.onStart(_cmd);

        &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; determine if we're allowed to execute &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (circuitBreaker.allowRequest()) {
            final TryableSemaphore executionSemaphore &lt;/span&gt;=&lt;span&gt; getExecutionSemaphore();
            final AtomicBoolean semaphoreHasBeenReleased &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; AtomicBoolean(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            final Action0 singleSemaphoreRelease &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Action0() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call() {
                    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (semaphoreHasBeenReleased.compareAndSet(&lt;span&gt;false&lt;/span&gt;, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)) {
                        executionSemaphore.release();
                    }
                }
            };

            final Action1&lt;/span&gt;&amp;lt;Throwable&amp;gt; markExceptionThrown = &lt;span&gt;new&lt;/span&gt; Action1&amp;lt;Throwable&amp;gt;&lt;span&gt;() {
                @Override
                &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call(Throwable t) {
                    eventNotifier.markEvent(HystrixEventType.EXCEPTION_THROWN, commandKey);
                }
            };

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (executionSemaphore.tryAcquire()) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; used to track userThreadExecutionTime &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
                    executionResult &lt;/span&gt;=&lt;span&gt; executionResult.setInvocationStartTime(System.currentTimeMillis());&lt;br/&gt;//跟进
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; executeCommandAndObserve(_cmd)
                            .doOnError(markExceptionThrown)
                            .doOnTerminate(singleSemaphoreRelease)
                            .doOnUnsubscribe(singleSemaphoreRelease);
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RuntimeException e) {
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Observable.error(e);
                }
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handleSemaphoreRejectionViaFallback();
            }
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; handleShortCircuitViaFallback();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;executeCommandAndObserve&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定义不同的回调，doOnNext、doOnCompleted、onErrorResumeNext、doOnEach。&lt;/li&gt;
&lt;li&gt;调用executeCommandWithSpecifiedIsolation获得执行命令的Observable&lt;/li&gt;
&lt;li&gt;若执行命令超时特性开启，调用 Observable.lift 方法实现执行命令超时功能。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; Observable&amp;lt;R&amp;gt; executeCommandAndObserve(final AbstractCommand&amp;lt;R&amp;gt;&lt;span&gt; _cmd) {
  final HystrixRequestContext currentRequestContext &lt;/span&gt;=&lt;span&gt;
HystrixRequestContext.getContextForCurrentThread();
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Action和Func都是定义的一个动作，Action是无返回值，Func是有返回值
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; doOnNext中的回调。即命令执行之前执行的操作&lt;/span&gt;
  final Action1&amp;lt;R&amp;gt; markEmits &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; doOnCompleted中的回调。命令执行完毕后执行的操作&lt;/span&gt;
  final Action0 markOnCompleted = &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; onErrorResumeNext中的回调。命令执行失败后的回退逻辑&lt;/span&gt;
  final Func1&amp;lt;Throwable, Observable&amp;lt;R&amp;gt;&amp;gt; handleFallback = &lt;span&gt;//&lt;/span&gt;&lt;span&gt;...
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; doOnEach中的回调。`Observable`每发射一个数据都会执行这个回调，设置请求上下文&lt;/span&gt;
  final Action1&amp;lt;Notification&amp;lt;? super R&amp;gt;&amp;gt; setRequestContext =&lt;span&gt;//&lt;/span&gt;&lt;span&gt;...&lt;/span&gt;
  Observable&amp;lt;R&amp;gt;&lt;span&gt; execution;
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (properties.executionTimeoutEnabled().&lt;span&gt;get&lt;/span&gt;&lt;span&gt;()) {
    execution &lt;/span&gt;=&lt;span&gt; executeCommandWithSpecifiedIsolation(_cmd)
      .lift(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; HystrixObservableTimeoutOperator&amp;lt;R&amp;gt;&lt;span&gt;(_cmd));
  } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    execution &lt;/span&gt;=&lt;span&gt; executeCommandWithSpecifiedIsolation(_cmd);
  }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; execution.doOnNext(markEmits)
.doOnCompleted(markOnCompleted)
    .onErrorResumeNext(handleFallback)
    .doOnEach(setRequestContext);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;executeCommandWithSpecifiedIsolation方法，这个方法首先是根据当前不同的资源隔离策略执行不同的逻辑，THREAD、SEMAPHORE，这里就不展开实现细节，我们直接看执行的方法 getUserExecutionObservable 。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; Observable&amp;lt;R&amp;gt;&lt;span&gt; executeCommandWithSpecifiedIsolation(final
AbstractCommand&lt;/span&gt;&amp;lt;R&amp;gt;&lt;span&gt; _cmd) {
  &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (properties.executionIsolationStrategy().&lt;span&gt;get&lt;/span&gt;() ==&lt;span&gt;
ExecutionIsolationStrategy.THREAD) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; mark that we are executing in a thread (even if we end up being&lt;/span&gt;
&lt;span&gt;rejected we still were a THREAD execution and not SEMAPHORE)
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Observable.defer(&lt;span&gt;new&lt;/span&gt; Func0&amp;lt;Observable&amp;lt;R&amp;gt;&amp;gt;&lt;span&gt;() {
      @Override
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Observable&amp;lt;R&amp;gt;&lt;span&gt; call() {
        executionResult &lt;/span&gt;=&lt;span&gt; executionResult.setExecutionOccurred();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;
(&lt;/span&gt;!&lt;span&gt;commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED,
CommandState.USER_CODE_EXECUTED)) {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Observable.error(&lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;
attempted &lt;span&gt;while&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; state : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; + commandState.get().name()));&lt;/span&gt;
&lt;span&gt;       }
        metrics.markCommandStart(commandKey, threadPoolKey,
ExecutionIsolationStrategy.THREAD);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (isCommandTimedOut.&lt;span&gt;get&lt;/span&gt;() ==&lt;span&gt; TimedOutStatus.TIMED_OUT) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the command timed out in the wrapping thread so we will&lt;/span&gt;
&lt;span&gt;return&lt;/span&gt;&lt;span&gt; immediately
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; and not increment any of the counters below or other such&lt;/span&gt;
&lt;span&gt;logic
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Observable.error(&lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;timed out&lt;/span&gt;
before executing run()&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;
&lt;span&gt;       }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (threadState.compareAndSet(ThreadState.NOT_USING_THREAD,
ThreadState.STARTED)) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;we have not been unsubscribed, so should proceed&lt;/span&gt;
&lt;span&gt;          HystrixCounters.incrementGlobalConcurrentThreads();
          threadPool.markThreadExecution();
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; store the command that is being run&lt;/span&gt;
          endCurrentThreadExecutingCommand =&lt;span&gt;
Hystrix.startCurrentThreadExecutingCommand(getCommandKey());
          executionResult &lt;/span&gt;=&lt;span&gt; executionResult.setExecutedInThread();
          &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
            * If any of these hooks throw an exception, then it
appears as if the actual execution threw an error
            &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
          &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            executionHook.onThreadStart(_cmd);
            executionHook.onRunStart(_cmd);
            executionHook.onExecutionStart(_cmd);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getUserExecutionObservable(_cmd);
} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Observable.error(ex);
         }
       } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;command has already been unsubscribed, so return&lt;/span&gt;
&lt;span&gt;immediately
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Observable.error(&lt;span&gt;new&lt;/span&gt; RuntimeException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unsubscribed&lt;/span&gt;
before executing run()&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));&lt;/span&gt;
&lt;span&gt;       }
     }
   }).doOnTerminate(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Action0() {
      @Override
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (threadState.compareAndSet(ThreadState.STARTED,
ThreadState.TERMINAL)) {
          handleThreadEnd(_cmd);
       }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (threadState.compareAndSet(ThreadState.NOT_USING_THREAD,
ThreadState.TERMINAL)) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if it was never started and received terminal, then no&lt;/span&gt;
need to clean up (I don&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t think this is possible)&lt;/span&gt;
&lt;span&gt;       }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if it was unsubscribed, then other cleanup handled it&lt;/span&gt;
&lt;span&gt;     }
   }).doOnUnsubscribe(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Action0() {
      @Override
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call() {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (threadState.compareAndSet(ThreadState.STARTED,
ThreadState.UNSUBSCRIBED)) {
          handleThreadEnd(_cmd);
       }
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (threadState.compareAndSet(ThreadState.NOT_USING_THREAD,
ThreadState.UNSUBSCRIBED)) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if it was never started and was cancelled, then no need to&lt;/span&gt;
&lt;span&gt;clean up
       }
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;if it was terminal, then other cleanup handled it&lt;/span&gt;
&lt;span&gt;     }
   }).subscribeOn(threadPool.getScheduler(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Func0&amp;lt;Boolean&amp;gt;&lt;span&gt;() {
      @Override
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Boolean call() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;
properties.executionIsolationThreadInterruptOnTimeout().&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;() &amp;amp;&amp;amp;&lt;span&gt;
_cmd.isCommandTimedOut.&lt;/span&gt;&lt;span&gt;get&lt;/span&gt;() ==&lt;span&gt; TimedOutStatus.TIMED_OUT;
     }
   }));
 } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Observable.defer(&lt;span&gt;new&lt;/span&gt; Func0&amp;lt;Observable&amp;lt;R&amp;gt;&amp;gt;&lt;span&gt;() {
      @Override
      &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Observable&amp;lt;R&amp;gt;&lt;span&gt; call() {
        executionResult &lt;/span&gt;=&lt;span&gt; executionResult.setExecutionOccurred();
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;
(&lt;/span&gt;!&lt;span&gt;commandState.compareAndSet(CommandState.OBSERVABLE_CHAIN_CREATED,
CommandState.USER_CODE_EXECUTED)) {
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Observable.error(&lt;span&gt;new&lt;/span&gt; IllegalStateException(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;execution&lt;/span&gt;
attempted &lt;span&gt;while&lt;/span&gt; &lt;span&gt;in&lt;/span&gt; state : &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; + commandState.get().name()));&lt;/span&gt;
&lt;span&gt;       }
metrics.markCommandStart(commandKey, threadPoolKey,
ExecutionIsolationStrategy.SEMAPHORE);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; semaphore isolated
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; store the command that is being run&lt;/span&gt;
        endCurrentThreadExecutingCommand =&lt;span&gt;
Hystrix.startCurrentThreadExecutingCommand(getCommandKey());
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
          executionHook.onRunStart(_cmd);
          executionHook.onExecutionStart(_cmd);
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; getUserExecutionObservable(_cmd);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;the&lt;/span&gt;
getUserExecutionObservable method already wraps sync exceptions, so &lt;span&gt;this&lt;/span&gt;&lt;span&gt;
shouldn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t throw&lt;/span&gt;
       } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;If the above hooks throw, then use that as the result of&lt;/span&gt;
&lt;span&gt;the run method
          &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Observable.error(ex);
       }
     }
   });
 }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;调用 getExecutionObservable 方法创建 命令执行Observable 。 getExecutionObservable 方法是个抽象方法， HystrixCommand 实现了该方法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; Observable&amp;lt;R&amp;gt; getUserExecutionObservable(final AbstractCommand&amp;lt;R&amp;gt;&lt;span&gt; _cmd)
{
  Observable&lt;/span&gt;&amp;lt;R&amp;gt;&lt;span&gt; userObservable;
  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    userObservable &lt;/span&gt;=&lt;span&gt; getExecutionObservable();
 } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; the run() method is a user provided implementation so can throw&lt;/span&gt;
instead of &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Observable.onError
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; so we catch it here and turn it into Observable.error&lt;/span&gt;
    userObservable =&lt;span&gt; Observable.error(ex);
 }
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; userObservable
   .lift(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExecutionHookApplication(_cmd))
   .lift(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DeprecatedOnRunHookApplication(_cmd));
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;调用 HystrixCommand.getExecutionObservable 方法创建命令执行Observable这里最终调用的是run方法，通过Observable.just， just是RxJava中的一个操作符，它可以接受一个或者多个参数来创建一个Observable对象。而这个run（）方法是一个抽象方法，在HystrixCommand中并没有实现，而是在子类中实现，而此时传递的cmd=GenricCommand正好实现了HystrixCommand，重写了run方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
final &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; Observable&amp;lt;R&amp;gt;&lt;span&gt; getExecutionObservable() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Observable.defer(&lt;span&gt;new&lt;/span&gt; Func0&amp;lt;Observable&amp;lt;R&amp;gt;&amp;gt;&lt;span&gt;() {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Observable&amp;lt;R&amp;gt;&lt;span&gt; call() {
      &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Observable.just(run());
     } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Observable.error(ex);
     }
   }
 }).doOnSubscribe(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Action0() {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; call() {
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Save thread on which we get subscribed so that we can interrupt&lt;/span&gt;
it later &lt;span&gt;if&lt;/span&gt;&lt;span&gt; needed
      executionThread.&lt;/span&gt;&lt;span&gt;set&lt;/span&gt;&lt;span&gt;(Thread.currentThread());
   }
 });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;enericCommand类中的run方法，这里的实现和前面自定义的 HystrixCommandService 实现是一样的，同样是集成HystrixCommand，重写run方法。这里也是如此。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先调用 getCommandAction() 方法获取 CommandAction ，我们的示例中获取到的是MethodExecutionAction 。&lt;/li&gt;
&lt;li&gt;然后调用 MethodExecutionAction.execute 方法，传入 ExecutionType 参数，我们的示例中传入的是 ExecutionType.SYNCHRONOUS 。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;protected&lt;/span&gt;&lt;span&gt; Object run() throws Exception {
  LOGGER.debug(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;execute command: {}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, getCommandKey().name());
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; process(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Action() {
    @Override
    Object execute() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getCommandAction().execute(getExecutionType());
   }
 });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;





&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt; &lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br/&gt; &lt;/p&gt;

</description>
<pubDate>Sat, 02 Jan 2021 14:16:00 +0000</pubDate>
<dc:creator>童话述说我的结局</dc:creator>
<og:description>一、Hystrix处理流程 Hystrix流程图如下： Hystrix整个工作流如下： 构造一个&amp;#160;HystrixCommand或HystrixObservableCommand对象，用于封装</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xing1/p/14223358.html</dc:identifier>
</item>
<item>
<title>SAML和OAuth2这两种SSO协议的区别 - flydean</title>
<link>http://www.cnblogs.com/flydean/p/14224139.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/14224139.html</guid>
<description>&lt;p&gt;SSO是单点登录的简称，常用的SSO的协议有两种，分别是SAML和OAuth2。本文将会介绍两种协议的不同之处，从而让读者对这两种协议有更加深入的理解。&lt;/p&gt;

&lt;p&gt;SAML的全称是Security Assertion Markup Language， 是由OASIS制定的一套基于XML格式的开放标准，用在身份提供者（IdP）和服务提供者 (SP)之间交换身份验证和授权数据。&lt;/p&gt;
&lt;p&gt;SAML的一个非常重要的应用就是基于Web的单点登录（SSO）。&lt;/p&gt;
&lt;p&gt;在SAML协议中定义了三个角色，分别是principal：代表主体通常表示人类用户。identity provider (IdP)身份提供者和service provider (SP)服务提供者。&lt;/p&gt;
&lt;p&gt;IdP的作用就是进行身份认证，并且将用户的认证信息和授权信息传递给服务提供者。&lt;/p&gt;
&lt;p&gt;SP的作用就是进行用户认证信息的验证，并且授权用户访问指定的资源信息。&lt;/p&gt;
&lt;p&gt;接下来，我们通过一个用SAML进行SSO认证的流程图，来分析一下SAML是怎么工作的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200917121937112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_25,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中User Agent就是web浏览器，我们看一下如果用户想请求Service Provider的资源的时候，SAML协议是怎么处理的。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;用户通过User Agent请求Service Provider,比如：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;http://sp.flydean.com/myresource
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SP将会对该资源进行相应的安全检查，如果发现已经有一个有效的安全上下文的话，SP将会跳过2-7步，直接进入第8步。&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;如果在第一步的时候，SP并没有找到相应的有效安全上下文的话，则会生成对应的SAMLRequest，并将User Agent重定向到IdP：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;302 Redirect
Location: https://idp.flydean.com/SAML2/SSO/Redirect?SAMLRequest=request&amp;amp;RelayState=token
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;RelayState是SP维护的一个状态信息，主要用来防止CSRF攻击。&lt;/p&gt;
&lt;p&gt;其中这个SAMLRequest是用Base64编码的&lt;a target=&quot;_blank&quot;&gt;samlp:AuthnRequest&lt;/a&gt;，下面是一个samlp:AuthnRequest的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;  &amp;lt;samlp:AuthnRequest
    xmlns:samlp=&quot;urn:oasis:names:tc:SAML:2.0:protocol&quot;
    xmlns:saml=&quot;urn:oasis:names:tc:SAML:2.0:assertion&quot;
    ID=&quot;aaf23196-1773-2113-474a-fe114412ab72&quot;
    Version=&quot;2.0&quot;
    IssueInstant=&quot;2020-09-05T09:21:59Z&quot;
    AssertionConsumerServiceIndex=&quot;0&quot;
    AttributeConsumingServiceIndex=&quot;0&quot;&amp;gt;
    &amp;lt;saml:Issuer&amp;gt;https://sp.flydean.com/SAML2&amp;lt;/saml:Issuer&amp;gt;
    &amp;lt;samlp:NameIDPolicy
      AllowCreate=&quot;true&quot;
      Format=&quot;urn:oasis:names:tc:SAML:2.0:nameid-format:transient&quot;/&amp;gt;
  &amp;lt;/samlp:AuthnRequest&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了安全起见，SAMLRequest还可以使用SP提供的签名key来进行签名。&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;User agent将会发送一个get请求到IdP的SSO server :&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;GET /SAML2/SSO/Redirect?SAMLRequest=request&amp;amp;RelayState=token HTTP/1.1
Host: idp.flydean.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;IdP收到这个AuthnRequest请求之后，将会进行安全验证，如果是合法的AuthnRequest，那么将会展示登录界面。&lt;/p&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;用户可以输入用户名密码进行登录。登录成功之后，IdP将会返回一个XHTML form：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;  &amp;lt;form method=&quot;post&quot; action=&quot;https://sp.flydean.com/SAML2/SSO/POST&quot; ...&amp;gt;
    &amp;lt;input type=&quot;hidden&quot; name=&quot;SAMLResponse&quot; value=&quot;response&quot; /&amp;gt;
    &amp;lt;input type=&quot;hidden&quot; name=&quot;RelayState&quot; value=&quot;token&quot; /&amp;gt;
    ...
    &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot; /&amp;gt;
  &amp;lt;/form&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个form中包含了SAMLResponse信息，SAMLResponse中包含了用户相关的信息。&lt;/p&gt;
&lt;p&gt;同样的SAMLResponse也是使用Base64进行编码过的&lt;a target=&quot;_blank&quot;&gt;samlp:Response&lt;/a&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;samlp:Response
    xmlns:samlp=&quot;urn:oasis:names:tc:SAML:2.0:protocol&quot;
    xmlns:saml=&quot;urn:oasis:names:tc:SAML:2.0:assertion&quot;
    ID=&quot;identifier_2&quot;
    InResponseTo=&quot;identifier_1&quot;
    Version=&quot;2.0&quot;
    IssueInstant=&quot;2020-09-05T09:22:05Z&quot;
    Destination=&quot;https://sp.flydean.com/SAML2/SSO/POST&quot;&amp;gt;
    &amp;lt;saml:Issuer&amp;gt;https://idp.flydean.com/SAML2&amp;lt;/saml:Issuer&amp;gt;
    &amp;lt;samlp:Status&amp;gt;
      &amp;lt;samlp:StatusCode
        Value=&quot;urn:oasis:names:tc:SAML:2.0:status:Success&quot;/&amp;gt;
    &amp;lt;/samlp:Status&amp;gt;
    &amp;lt;saml:Assertion
      xmlns:saml=&quot;urn:oasis:names:tc:SAML:2.0:assertion&quot;
      ID=&quot;identifier_3&quot;
      Version=&quot;2.0&quot;
      IssueInstant=&quot;2020-09-05T09:22:05Z&quot;&amp;gt;
      &amp;lt;saml:Issuer&amp;gt;https://idp.flydean.com/SAML2&amp;lt;/saml:Issuer&amp;gt;
      &amp;lt;!-- a POSTed assertion MUST be signed --&amp;gt;
      &amp;lt;ds:Signature
        xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;&amp;gt;...&amp;lt;/ds:Signature&amp;gt;
      &amp;lt;saml:Subject&amp;gt;
        &amp;lt;saml:NameID
          Format=&quot;urn:oasis:names:tc:SAML:2.0:nameid-format:transient&quot;&amp;gt;
          3f7b3dcf-1674-4ecd-92c8-1544f346baf8
        &amp;lt;/saml:NameID&amp;gt;
        &amp;lt;saml:SubjectConfirmation
          Method=&quot;urn:oasis:names:tc:SAML:2.0:cm:bearer&quot;&amp;gt;
          &amp;lt;saml:SubjectConfirmationData
            InResponseTo=&quot;identifier_1&quot;
            Recipient=&quot;https://sp.flydean.com/SAML2/SSO/POST&quot;
            NotOnOrAfter=&quot;2020-09-05T09:27:05Z&quot;/&amp;gt;
        &amp;lt;/saml:SubjectConfirmation&amp;gt;
      &amp;lt;/saml:Subject&amp;gt;
      &amp;lt;saml:Conditions
        NotBefore=&quot;2020-09-05T09:17:05Z&quot;
        NotOnOrAfter=&quot;2020-09-05T09:27:05Z&quot;&amp;gt;
        &amp;lt;saml:AudienceRestriction&amp;gt;
          &amp;lt;saml:Audience&amp;gt;https://sp.flydean.com/SAML2&amp;lt;/saml:Audience&amp;gt;
        &amp;lt;/saml:AudienceRestriction&amp;gt;
      &amp;lt;/saml:Conditions&amp;gt;
      &amp;lt;saml:AuthnStatement
        AuthnInstant=&quot;2020-09-05T09:22:00Z&quot;
        SessionIndex=&quot;identifier_3&quot;&amp;gt;
        &amp;lt;saml:AuthnContext&amp;gt;
          &amp;lt;saml:AuthnContextClassRef&amp;gt;
            urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport
         &amp;lt;/saml:AuthnContextClassRef&amp;gt;
        &amp;lt;/saml:AuthnContext&amp;gt;
      &amp;lt;/saml:AuthnStatement&amp;gt;
    &amp;lt;/saml:Assertion&amp;gt;
  &amp;lt;/samlp:Response&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到samlp:Response中包含有saml:Assertion信息。&lt;/p&gt;
&lt;ol start=&quot;5&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;user agent 收到XHTML form之后将会提交该form给SP。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;SP中的assertion consumer service将会处理这个请求，创建相关的安全上下文，并将user agent重定向到要访问的资源页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;user agent再次请求SP资源。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;因为安全上下文已经创建完毕，SP可以直接返回相应的资源，不用再次到IdP进行认证。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我们可以看到上面的所有的信息交换都是由前端浏览器来完成的，在SP和IdP之间不存在直接的通信。&lt;/p&gt;
&lt;p&gt;这种全部由前端来完成信息交换的方式好处就是协议流非常简单，所有的消息都是简单的GET或者POST请求。&lt;/p&gt;
&lt;p&gt;如果为了提高安全性，也可以使用引用消息。也就是说IdP返回的不是直接的SAML assertion，而是一个SAML assertion的引用。SP收到这个引用之后，可以从后台再去查询真实的SAML assertion，从而提高了安全性。&lt;/p&gt;
&lt;h2 id=&quot;saml的缺点&quot;&gt;SAML的缺点&lt;/h2&gt;
&lt;p&gt;SAML协议是2005年制定的，在制定协议的时候基本上是针对于web应用程序来说的，但是那时候的web应用程序还是比较简单的，更别提对App的支持。&lt;/p&gt;
&lt;p&gt;SAML需要通过HTTP Redect和HTTP POST协议来传递用户信息，并且通常是通过HTML FORM的格式来进行数据的提交的。如果应用程序并不是web应用，比如说是一个手机App应用。&lt;/p&gt;
&lt;p&gt;这个手机APP应用的启动链接是 my-photos://authenticate ， 但是手机app可能并不能获取到Http POST的body内容。他们只能够通过URL来进行参数的传递。&lt;/p&gt;
&lt;p&gt;这就意味着，在手机APP中不能够使用SAML。&lt;/p&gt;
&lt;p&gt;当然，要想工作也可以，不过需要进行一些改造。比如通过第三方应用对POST消息进行解析，然后将解析出来的SAMLRequest以URL参数的形式传递给APP。&lt;/p&gt;
&lt;p&gt;另一种方法就是使用OAuth2.&lt;/p&gt;

&lt;p&gt;因为Oauth2是在2012年才产生的。所以并没有那么多的使用限制。我们可以在不同的场合中使用OAuth2。&lt;/p&gt;
&lt;p&gt;我们先来看一下OAuth2中授权的流程图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200914225501505.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_0,text_aHR0cDovL3d3dy5mbHlkZWFuLmNvbQ==,size_25,color_8F8F8F,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般来说OAuth2中有4个角色。&lt;/p&gt;
&lt;p&gt;resource owner： 代表的是资源的所有者，可以通过提供用户名密码或者其他方式来进行授权。通常来是一个人。&lt;/p&gt;
&lt;p&gt;resource server：代表的是最终需要访问到资源的服务器。比如github授权之后获取到的用户信息。&lt;/p&gt;
&lt;p&gt;client： 用来替代resource owner来进行交互的客户端。&lt;/p&gt;
&lt;p&gt;authorization server： 用来进行授权的服务器，可以生成相应的Access Token。&lt;/p&gt;
&lt;p&gt;整个流程是这样的：&lt;/p&gt;
&lt;p&gt;Client向resource owner发起一个授权请求，resource owner输入相应的认证信息，将authorization grant返回给client。&lt;/p&gt;
&lt;p&gt;client再将获取到的authorization grant请求授权服务器，并返回access token。&lt;/p&gt;
&lt;p&gt;client然后就可以拿着这个access token去请求resource server，最后获取到受限资源。&lt;/p&gt;
&lt;h2 id=&quot;oauth2的缺点&quot;&gt;OAuth2的缺点&lt;/h2&gt;
&lt;p&gt;OAuth2并没有指定Resource Server怎么和Authorization Server进行交互。也没有规定返回用户信息的内容和格式。这些都需要实现方自己去决定。&lt;/p&gt;
&lt;p&gt;OAuth2默认是在HTTPS环境下工作的，所以并没有约定信息的加密方式。我们需要自己去实现。&lt;/p&gt;
&lt;p&gt;最后，OAuth2是一个授权协议，而不是认证协议。对于这个问题，其实我们可以考虑使用OpenID Connect协议。因为OpenID Connect就是基于OAuth2实现的，并且添加了认证协议。&lt;/p&gt;
&lt;p&gt;OpenID Connect简称为OIDC，已成为Internet上单点登录和身份管理的通用标准。 它在OAuth2上构建了一个身份层，是一个基于OAuth2协议的身份认证标准协议。&lt;/p&gt;
&lt;p&gt;OAuth2实际上只做了授权，而OpenID Connect在授权的基础上又加上了认证。&lt;/p&gt;
&lt;p&gt;OIDC的优点是：简单的基于JSON的身份令牌（JWT），并且完全兼容OAuth2协议。&lt;/p&gt;

&lt;p&gt;在SAML协议中，SAML token中已经包含了用户身份信息，但是在OAuth2，在拿到token之后，需要额外再做一次对该token的校验。&lt;/p&gt;
&lt;p&gt;但是另一方面，OAuth2因为需要再做一次认证，所以可以在 Authorization Server 端对token进行无效处理。&lt;/p&gt;

&lt;p&gt;做过SSO的应该都听说过CAS。CAS的全称是Central Authentication Service，是一个企业级的开源的SSO认证框架。&lt;/p&gt;
&lt;p&gt;CAS内部集成了CAS1,2,3，SAML1,2，OAuth2,OpenID和OpenID Connect协议，非常的强大。我们会在后面的文章中介绍CAS的使用。&lt;/p&gt;
&lt;blockquote readability=&quot;10.394366197183&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/saml-vs-oauth2/&quot; target=&quot;_blank&quot;&gt;http://www.flydean.com/saml-vs-oauth2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:「程序那些事」最通俗的解读，最深刻的干货，最简洁的教程，众多你不知道的小技巧等你来发现！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Sat, 02 Jan 2021 13:56:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>简介 SSO是单点登录的简称，常用的SSO的协议有两种，分别是SAML和OAuth2。本文将会介绍两种协议的不同之处，从而让读者对这两种协议有更加深入的理解。 SAML SAML的全称是Securit</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/14224139.html</dc:identifier>
</item>
<item>
<title>.NET 云原生架构师训练营（模块二 基础巩固 MongoDB 写入和查询）--学习笔记 - MingsonZheng</title>
<link>http://www.cnblogs.com/MingsonZheng/p/14224071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MingsonZheng/p/14224071.html</guid>
<description>&lt;ul&gt;&lt;li&gt;写入&lt;/li&gt;
&lt;li&gt;查询&lt;/li&gt;
&lt;li&gt;查找操作符&lt;/li&gt;
&lt;li&gt;逻辑操作符&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;li&gt;嵌套对象&lt;/li&gt;
&lt;li&gt;数组&lt;/li&gt;
&lt;li&gt;游标方法&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;写入&quot;&gt;写入&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/tutorial/insert-documents/&quot; target=&quot;_blank&quot;&gt;https://docs.mongodb.com/manual/tutorial/insert-documents/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;insertOne&lt;/li&gt;
&lt;li&gt;insertMany&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;db.questions.insert( 
{  
    &quot;_id&quot;:&quot;003&quot;,
    &quot;title&quot;:&quot;第三个问题&quot;, 
    &quot;view&quot;:0,
    &quot;isDeleted&quot;:false,
    &quot;content&quot;:&quot;第三个问题&quot;, 
    &quot;status&quot;:&quot;open&quot;, 
    &quot;tags&quot;:[&quot;c#&quot;], 
    &quot;answers&quot;:[
        {&quot;content&quot;:&quot;回答1&quot;},
        {&quot;content&quot;:&quot;回答2&quot;},
        {&quot;content&quot;:&quot;回答3&quot;}
        ]
 } 
    )
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;db.questions.insertMany( 
[
{  
    &quot;_id&quot;:&quot;004&quot;,
    &quot;title&quot;:&quot;第三个问题&quot;, 
    &quot;view&quot;:0,
    &quot;isDeleted&quot;:false,
    &quot;content&quot;:&quot;第三个问题&quot;, 
    &quot;status&quot;:&quot;open&quot;, 
    &quot;tags&quot;:[&quot;c#&quot;], 
    &quot;answers&quot;:[
        {&quot;content&quot;:&quot;回答1&quot;},
        {&quot;content&quot;:&quot;回答2&quot;},
        {&quot;content&quot;:&quot;回答3&quot;}
        ]
 },
 {  
    &quot;_id&quot;:&quot;005&quot;,
    &quot;title&quot;:&quot;第三个问题&quot;, 
    &quot;view&quot;:0,
    &quot;isDeleted&quot;:false,
    &quot;content&quot;:&quot;第三个问题&quot;, 
    &quot;status&quot;:&quot;open&quot;, 
    &quot;tags&quot;:[&quot;c#&quot;], 
    &quot;answers&quot;:[
        {&quot;content&quot;:&quot;回答1&quot;},
        {&quot;content&quot;:&quot;回答2&quot;},
        {&quot;content&quot;:&quot;回答3&quot;}
        ]
 }
] 
    )
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查询&quot;&gt;查询&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/reference/operator/query/&quot; target=&quot;_blank&quot;&gt;https://docs.mongodb.com/manual/reference/operator/query/&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;db.users.find(
    { age: { $gt: 18 } },    // 查询条件
    { name: 1, address: 1 }  // 查询字段
).limit(5)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;db.getCollection('questions').find({&quot;title&quot;:&quot;第三个问题&quot;},{&quot;title&quot;:1,&quot;content&quot;:1})

db.getCollection('questions').find({},{&quot;title&quot;:1,&quot;content&quot;:1}).skip(1).limit(2)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查找操作符&quot;&gt;查找操作符&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;1&quot;&gt;&lt;tr&gt;&lt;td&gt;$eq&lt;/td&gt;
&lt;td&gt;等于&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;$gt&lt;/td&gt;
&lt;td&gt;大于&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;$gte&lt;/td&gt;
&lt;td&gt;大于等于&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;$lt&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;$lte&lt;/td&gt;
&lt;td&gt;小于等于&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;$ne&lt;/td&gt;
&lt;td&gt;不等于&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;$in&lt;/td&gt;
&lt;td&gt;存在于&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$nin&lt;/td&gt;
&lt;td&gt;不存在于：一般用于数组&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;// 大于等于
db.getCollection('questions').find({&quot;view&quot;:{$gte: NumberInt(0)}})

// 存在于
db.getCollection('questions').find({&quot;tags&quot;:{$in: [&quot;c#&quot;]}})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;逻辑操作符&quot;&gt;逻辑操作符&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr&gt;&lt;td&gt;$and&lt;/td&gt;
&lt;td&gt;满足多个条件&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$or&lt;/td&gt;
&lt;td&gt;满足多个条件中的一个&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$not&lt;/td&gt;
&lt;td&gt;不匹配，或者字段不存在&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$nor&lt;/td&gt;
&lt;td&gt;多个条件，一个都不满足&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;// 满足多个条件中的一个
db.getCollection('questions').find({$or:
[
{&quot;tags&quot;:{$in: [&quot;c#&quot;]}},
{&quot;view&quot;:{$gt:2}}
]
})

db.getCollection('questions').find({&quot;view&quot;:{&quot;$gt&quot;: 5}})
// 不匹配，或者字段不存在（取反）
db.getCollection('questions').find({&quot;view&quot;: {$not: {&quot;$gt&quot;: 5}}})

// 多个条件，一个都不满足
db.getCollection('questions').find({$nor: [{&quot;view&quot;:{&quot;$gt&quot;: 5}}]})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;其他&quot;&gt;其他&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;$exists&lt;/td&gt;
&lt;td&gt;存在某个字段&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;$type&lt;/td&gt;
&lt;td&gt;字段的类型&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;// 存在某个字段则显示
db.getCollection('questions').find({&quot;best&quot;: {$exists:1}})
// 不存在某个字段则显示
db.getCollection('questions').find({&quot;best&quot;: {$exists:0}})
// 字段的类型，16代表32-byte integer
db.getCollection('questions').find({&quot;view&quot;: {$type: 16}})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://mongoing.com/docs/reference/bson-types.html&quot; target=&quot;_blank&quot;&gt;https://mongoing.com/docs/reference/bson-types.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;嵌套对象&quot;&gt;嵌套对象&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;db.getCollection('questions').find({&quot;best.content&quot;:{$eq: &quot;最好的答案&quot;}})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;数组&quot;&gt;数组&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$all&lt;/td&gt;
&lt;td&gt;所有元素匹配，匹配简单类型数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;$elemMatch&lt;/td&gt;
&lt;td&gt;用于匹配 object 数组&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;$size&lt;/td&gt;
&lt;td&gt;长度条件&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code&gt;db.getCollection('questions').find({&quot;tags&quot;: {$in: [&quot;c#&quot;]}})

db.getCollection('questions').find({&quot;tags&quot;: {$nin: [&quot;c#&quot;]}})

// 都必须包含
db.getCollection('questions').find({&quot;tags&quot;: {$all: [&quot;c#&quot;, &quot;asp.net core&quot;]}})

// 大小为2
db.getCollection('questions').find

// 包含 回答1 的数组
db.getCollection('questions').find({&quot;answers&quot;: {$elemMatch: {&quot;content&quot;: &quot;回答1&quot;}}})

db.getCollection('questions').find({&quot;answers&quot;: {$elemMatch: {&quot;content&quot;: {$gte: &quot;回答1&quot;}}}})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;游标方法&quot;&gt;游标方法&lt;/h2&gt;
&lt;p&gt;只在 mongo shell 中有效，其他语言版本 sdk 无效&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;skip&lt;/li&gt;
&lt;li&gt;limit&lt;/li&gt;
&lt;li&gt;count&lt;/li&gt;
&lt;li&gt;pretty 美化&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
&lt;p&gt;欢迎转载、使用、重新发布，但务必保留文章署名 郑子铭 （包含链接： &lt;a href=&quot;http://www.cnblogs.com/MingsonZheng/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/MingsonZheng/&lt;/a&gt; ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。&lt;/p&gt;
&lt;p&gt;如有任何疑问，请与我联系 (MingsonZheng@outlook.com) 。&lt;/p&gt;
</description>
<pubDate>Sat, 02 Jan 2021 13:43:00 +0000</pubDate>
<dc:creator>MingsonZheng</dc:creator>
<og:description>2.5.3 MongoDB -- 写入和查询 写入 查询 查找操作符 逻辑操作符 其他 嵌套对象 数组 游标方法 写入 https://docs.mongodb.com/manual/tutorial</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MingsonZheng/p/14224071.html</dc:identifier>
</item>
</channel>
</rss>