<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>2020 SSR落地开花的三大机遇 - 梦烬</title>
<link>http://www.cnblogs.com/ayqy/p/ssr-2020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ayqy/p/ssr-2020.html</guid>
<description>[unable to retrieve full-text content]Serverless、low-code、4G/5G 网络环境三大机遇让 SSR 出现了新的转机，落地开花正当时</description>
<pubDate>Wed, 04 Nov 2020 00:59:00 +0000</pubDate>
<dc:creator>梦烬</dc:creator>
<dc:identifier>http://www.cnblogs.com/ayqy/p/ssr-2020.html</dc:identifier>
</item>
<item>
<title>「补课」进行时：设计模式(7)——租房子中的中介者模式 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/13924098.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/13924098.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/java_design_pattern.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-前文汇总&quot;&gt;1. 前文汇总&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/category/%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f/&quot;&gt;「补课」进行时：设计模式系列&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;2-租房子&quot;&gt;2. 租房子&lt;/h2&gt;
&lt;p&gt;国内某知名大学著名毕业生隔壁老王同学在近日毕业了，好不容易在大魔都找到一份工作，接下来就需要做另一件大事儿了，租房子。&lt;/p&gt;
&lt;p&gt;租过房子的同学应该都知道，最方便最快捷的方式就是找房租中介，如果不找中介的话，就需要自己去联系一个一个的房东，去约看每一间的房子。&lt;/p&gt;
&lt;p&gt;如果恰巧这些房东之间有联系，都在出租房屋，当客户 A 看了一号房东的房子，感觉不满意，一号房东推荐它可以去看看其他几个房东的房子，这时候，这个房东就需要联系他的其他几个房东朋友。&lt;/p&gt;
&lt;p&gt;如果这些房东中间恰好有一个人把房子租出来，他就需要自己通知所有的朋友，他的房子租掉了（状态变了）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/07/1470432-20191011173223865-2146866069.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里就造成了一个问题，当其中一个人发生了变化，需要告诉其他几个人，牵一发而动全身。&lt;/p&gt;
&lt;p&gt;这种情况下，如果能加入一个中介，将会大大的改善这种情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/07/1470432-20191011173238871-955239686.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时，如果一个人的状态变化了，只需要通知中介就行，有任何问题直接找中介进行处理，不再会有刚才的牵一发而动全身的情况出现。&lt;/p&gt;
&lt;p&gt;接下来看下示例代码：&lt;/p&gt;
&lt;h3 id=&quot;21-抽象中介类&quot;&gt;2.1 抽象中介类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Mediator {
    public abstract void Common(String type);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定义了一个同事类之间交互方法。&lt;/p&gt;
&lt;h3 id=&quot;22-抽象房东类&quot;&gt;2.2 抽象房东类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Colleague {
    public abstract void showHouse();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定义一个抽象方法，抽象每个房东都需要做的事情（展示自己的房屋）。&lt;/p&gt;
&lt;h3 id=&quot;23-具体房东类&quot;&gt;2.3 具体房东类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SmallHouseColleague extends Colleague {
    @Override
    public void showHouse() {
        System.out.println(&quot;一室一厅便宜整洁&quot;);
    }
}

public class TwoHouseColleague extends Colleague {
    @Override
    public void showHouse() {
        System.out.println(&quot;两居室——合适靠谱&quot;);
    }
}

public class ThreeHouseColleague extends Colleague {
    @Override
    public void showHouse() {
        System.out.println(&quot;三居室——大气宽松&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里定义了三个具体的房东要做的事情（展示自己的房子）。&lt;/p&gt;
&lt;h3 id=&quot;24-具体房屋中介&quot;&gt;2.4 具体房屋中介&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class HouseMediator extends Mediator {
    private SmallHouseColleague smallHouse;
    private TwoHouseColleague twoHouse;
    private ThreeHouseColleague threeHouse;

    public void setSmallHouse(SmallHouseColleague smallHouse) {
        this.smallHouse = smallHouse;
    }

    public void setTwoHouse(TwoHouseColleague twoHouse) {
        this.twoHouse = twoHouse;
    }

    public void setThreeHouse(ThreeHouseColleague threeHouse) {
        this.threeHouse = threeHouse;
    }

    @Override
    public void Common(String type) {
        switch (type) {
            case &quot;单间&quot;:
                smallHouse.showHouse();
                System.out.println(&quot;如果可以就可以租房了!&quot;);
                break;
            case &quot;两居室&quot;:
                twoHouse.showHouse();
                System.out.println(&quot;如果可以就可以租房了!&quot;);
                break;
            case &quot;三居室&quot;:
                threeHouse.showHouse();
                System.out.println(&quot;如果可以就可以租房了!&quot;);
                break;
            default:
                System.out.println(type + &quot;暂时没有房源!&quot;);
                break;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;25-测试类&quot;&gt;2.5 测试类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Test {
    public static void main(String[] args) {
        System.out.println(&quot;租客来看房啦！！！&quot;);
        //初始化中介
        HouseMediator mediator = new HouseMediator();
        //初始化房屋信息
        SmallHouseColleague smallHouseColleague = new SmallHouseColleague( );
        TwoHouseColleague twoHouseColleague = new TwoHouseColleague( );
        ThreeHouseColleague threeHouseColleague = new ThreeHouseColleague( );

        //中介获取房屋信息
        mediator.setSmallHouse(smallHouseColleague);
        mediator.setTwoHouse(twoHouseColleague);
        mediator.setThreeHouse(threeHouseColleague);

        // 租户A需要两居室、提供看房
        mediator.Common(&quot;两居室&quot;);

        // 租户B需要四居室、暂无房源
        mediator.Common(&quot;四居室&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后的执行结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;租客来看房啦！！！
两居室——合适靠谱
如果可以就可以租房了!
四居室暂时没有房源!
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;3-中介者模式&quot;&gt;3. 中介者模式&lt;/h2&gt;
&lt;h3 id=&quot;31-定义&quot;&gt;3.1 定义&lt;/h3&gt;
&lt;p&gt;中介者模式的定义为：Define an object that encapsulates how a set ofobjects interact.Mediator promotes loose coupling by keeping objects fromreferring to each other explicitly,and it lets you vary their interactionindependently.（用一个中介对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使其耦合松散，而且可以独立地改变它们之间的交互。）&lt;/p&gt;
&lt;h3 id=&quot;32-通用类图&quot;&gt;3.2 通用类图&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.geekdigging.com/DesignPatterns/07/Mediator_UML.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从类图中看，中介者模式由以下几部分组成：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Mediator: 抽象中介者角色，定义统一的接口，用于各同事角色之间的通信。&lt;/li&gt;
&lt;li&gt;Concrete Mediator: 具体中介者角色，通过协调各同事角色实现协作行为，因此它必须依赖于各个同事角色。&lt;/li&gt;
&lt;li&gt;Colleague: 同事角色，每一个同事角色都知道中介者角色，而且与其他的同事角色通信的时候，一定要通过中介者角色协作。每个同事类的行为分为两种：一种是同事本身的行为，比如改变对象本身的状态，处理自己的行为等，这种行为叫做自发行为（Self-Method），与其他的同事类或中介者没有任何的依赖；第二种是必须依赖中介者才能完成的行为，叫做依赖方法（Dep-Method）。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;33-通用抽象中介者&quot;&gt;3.3 通用抽象中介者&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Mediator {
    // 定义同事类
    protected ConcreteColleague1 colleague1;
    protected ConcreteColleague2 colleague2;

    // 通过 get/set 将同事注入进来
    public ConcreteColleague1 getC1() {
        return colleague1;
    }

    public void setC1(ConcreteColleague1 colleague1) {
        this.colleague1 = colleague1;
    }

    public ConcreteColleague2 getC2() {
        return colleague2;
    }

    public void setC2(ConcreteColleague2 colleague2) {
        this.colleague2 = colleague2;
    }

    // 中介者模式的业务逻辑
    public abstract void doSomething1();
    public abstract void doSomething2();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;34-通用中介者&quot;&gt;3.4 通用中介者&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConcreteMediator extends Mediator {
    @Override
    public void doSomething1() {
        // 调用同事类的方法
        super.colleague1.selfMethod1();
        super.colleague2.selfMethod2();
    }

    @Override
    public void doSomething2() {
        super.colleague1.selfMethod1();
        super.colleague2.selfMethod2();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;35-抽象同事类&quot;&gt;3.5 抽象同事类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class Colleague {
    protected Mediator mediator;

    public Colleague(Mediator mediator) {
        this.mediator = mediator;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;36-具体同事类&quot;&gt;3.6 具体同事类&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class ConcreteColleague1 extends Colleague{

    public ConcreteColleague1(Mediator mediator) {
        super(mediator);
    }

    public void selfMethod1() {
        // 处理自己的业务逻辑
    }

    public void depMethod1() {
        // 处理自己的业务逻辑
        // 自己处理不了的业务委托中介者进行处理
        super.mediator.doSomething1();
    }
}

public class ConcreteColleague2 extends Colleague {

    public ConcreteColleague2(Mediator mediator) {
        super(mediator);
    }

    public void selfMethod2() {
        // 处理自己的业务逻辑
    }

    public void depMethod2() {
        // 处理自己的业务逻辑
        // 自己处理不了的业务委托中介者进行处理
        super.mediator.doSomething2();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;4-中介者模式的优缺点&quot;&gt;4. 中介者模式的优缺点&lt;/h2&gt;
&lt;h3 id=&quot;41-优点&quot;&gt;4.1 优点&lt;/h3&gt;
&lt;p&gt;中介者模式的优点就是减少类间的依赖，把原有的一对多的依赖变成了一对一的依赖，同事类只依赖中介者，减少了依赖，当然同时也降低了类间的耦合。&lt;/p&gt;
&lt;h3 id=&quot;42-缺点&quot;&gt;4.2 缺点&lt;/h3&gt;
&lt;p&gt;中介者模式的缺点就是中介者会膨胀得很大，而且逻辑复杂，原本N个对象直接的相互依赖关系转换为中介者和同事类的依赖关系，同事类越多，中介者的逻辑就越复杂。&lt;/p&gt;
</description>
<pubDate>Wed, 04 Nov 2020 00:49:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>1. 前文汇总 「补课」进行时：设计模式系列 2. 租房子 国内某知名大学著名毕业生隔壁老王同学在近日毕业了，好不容易在大魔都找到一份工作，接下来就需要做另一件大事儿了，租房子。 租过房子的同学应该都</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/13924098.html</dc:identifier>
</item>
<item>
<title>在IIS中部署前后端应用，多么痛的领悟！ - 有态度的小码甲</title>
<link>http://www.cnblogs.com/JulianHuang/p/13923386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/JulianHuang/p/13923386.html</guid>
<description>&lt;p&gt;目前手上的Web项目是前后端分离的，所以有时也会倒腾Vue框架。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;前后端应用最终以容器形态、在k8s中部署, 为此我搭建了基于Gitlab flow的Devops流程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Devops实践中，容器部署成为良方和事实标准。&lt;/p&gt;
&lt;p&gt;但是在开发和自测阶段，前后端团队还需要一个&lt;strong&gt;友好的联调+自测的验证环境&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;最友好、最顺手的web服务器当属IIS，(后端API已经使用WebDeploy部署到IIS)，本文记录使用IIS托管Vue前端应用的姿势。&lt;/p&gt;
&lt;h4 id=&quot;前置条件：安装iis、url-rewrite-module-&quot;&gt;前置条件：安装IIS、Url-Rewrite Module !!!&lt;/h4&gt;
&lt;h3 id=&quot;1-部署vue应用&quot;&gt;1. 部署Vue应用&lt;/h3&gt;
&lt;p&gt;我们以Github上Vue Todo应用为例，执行&lt;code&gt;yarn build&lt;/code&gt;&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/88a06fd1-aab1-4e5f-9508-d1a7e76c02e2.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=Z6JmmtXxxVv9yA8UZRuzZ5w6s5E%253D&amp;amp;Expires=1604497577&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果build成功，你会发现生成了一个&lt;code&gt;dist&lt;/code&gt;静态资源文件夹。&lt;/p&gt;
&lt;h3 id=&quot;2-创建webconfig&quot;&gt;2. 创建web.config&lt;/h3&gt;
&lt;p&gt;将yarn生成的dist文件夹拷贝到随意位置，并添加以下web.config文件， 这个文件实际是我们在IIS Url-Rewrite module上配置的结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
    &amp;lt;system.webServer&amp;gt;
        &amp;lt;rewrite&amp;gt;
            &amp;lt;rules&amp;gt;
                &amp;lt;rule name=&quot;Handle History Mode and custom 404/500&quot; stopProcessing=&quot;true&quot;&amp;gt;
                    &amp;lt;match url=&quot;(.*)&quot; /&amp;gt;
                    &amp;lt;conditions logicalGrouping=&quot;MatchAll&quot;&amp;gt;
                        &amp;lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsFile&quot; negate=&quot;true&quot; /&amp;gt;
                        &amp;lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsDirectory&quot; negate=&quot;true&quot; /&amp;gt;
                    &amp;lt;/conditions&amp;gt;
                    &amp;lt;action type=&quot;Rewrite&quot; url=&quot;/&quot; /&amp;gt;
                &amp;lt;/rule&amp;gt;
            &amp;lt;/rules&amp;gt;
        &amp;lt;/rewrite&amp;gt;
        &amp;lt;httpErrors&amp;gt;
            &amp;lt;remove statusCode=&quot;404&quot; subStatusCode=&quot;-1&quot; /&amp;gt;
            &amp;lt;remove statusCode=&quot;500&quot; subStatusCode=&quot;-1&quot; /&amp;gt;
            &amp;lt;error statusCode=&quot;404&quot; path=&quot;/survey/notfound&quot; responseMode=&quot;ExecuteURL&quot; /&amp;gt;
            &amp;lt;error statusCode=&quot;500&quot; path=&quot;/survey/error&quot; responseMode=&quot;ExecuteURL&quot; /&amp;gt;
        &amp;lt;/httpErrors&amp;gt;
        &amp;lt;modules runAllManagedModulesForAllRequests=&quot;true&quot;/&amp;gt;
    &amp;lt;/system.webServer&amp;gt;
&amp;lt;/configuration&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-在iis上部署vue应用&quot;&gt;3. 在IIS上部署Vue应用&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/1df10f2b-2271-4e0c-a92a-93ff9aa8211f.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=TtXlcu9Wp%252B%252BytdrhtnFtGIKAgIs%253D&amp;amp;Expires=1604499917&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;点击确定&lt;/p&gt;
&lt;h3 id=&quot;4运行vue应用&quot;&gt;4.运行Vue应用&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/2adaa032-c81d-4726-a55c-1bc95e662a94.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=LYEUDiFym%252F0GJe3QGzoRboa7fkA%253D&amp;amp;Expires=1604500185&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Nice！ 现在你的Vue静态应用就运行在IIS上。&lt;/p&gt;
&lt;p&gt;But， 在前后端分离模式中，我们的Vue应用不仅有静态资源，还要发起动态api请求。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;一般情况下webpack打包后的api请求路径是&lt;code&gt;/&lt;/code&gt;, 会尝试请求同域名下api资源， 实际并不存在。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们需要将对Vue应用的api请求代理到真实后端地址。&lt;/p&gt;
&lt;h3 id=&quot;5-反向代理后端api请求&quot;&gt;5. 反向代理后端api请求&lt;/h3&gt;
&lt;p&gt;Vue应用站点还要充当一部分反向代理服务器的作用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/96b75a14-acf7-43dc-9453-6e460bcbc4a5.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=PWDw0olS4j3MMIKyI7wwIe7EDm4%253D&amp;amp;Expires=1604503175&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设真实后端api地址以部署在10.200.200.157:8091地址上，api以&lt;code&gt;/api&lt;/code&gt;为前缀。&lt;/p&gt;
&lt;p&gt;下面利用Url-Rewrite Module反向代理 Vue api请求到真实后端：&lt;/p&gt;
&lt;p&gt;点击站点功能视图---&amp;gt; Url重写---&amp;gt; 添加入站规则&lt;br/&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/75a7a04c-ee39-497e-8edd-3adf1ef09625.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=UlxPlJpgTV3uxVHm%252FtgqYMv0I70%253D&amp;amp;Expires=1604501749&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Url重写的结果其实就是下面的web.config文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;configuration&amp;gt;
  &amp;lt;!-- To customize the asp.net core module uncomment and edit the following section. 
  For more info see https://go.microsoft.com/fwlink/?linkid=838655 --&amp;gt;
  &amp;lt;system.webServer&amp;gt;
    &amp;lt;rewrite&amp;gt; 
       &amp;lt;rules&amp;gt; 
       &amp;lt;clear /&amp;gt; 
           &amp;lt;rule name=&quot;ReverseProxyInboundRule&quot; stopProcessing=&quot;true&quot;&amp;gt; 
                &amp;lt;match url=&quot;api/([_0-9a-z/-]+)&quot; /&amp;gt;
                &amp;lt;conditions logicalGrouping=&quot;MatchAll&quot; trackAllCaptures=&quot;false&quot; /&amp;gt;
                &amp;lt;action type=&quot;Rewrite&quot; url=&quot;http://10.200.200.157:8091/{R:0}&quot; /&amp;gt; 
           &amp;lt;/rule&amp;gt; 
           &amp;lt;rule name=&quot;ResourceToIndex&quot; stopProcessing=&quot;true&quot;&amp;gt;
                &amp;lt;match url=&quot;(.*)&quot; /&amp;gt;
                &amp;lt;conditions logicalGrouping=&quot;MatchAll&quot; trackAllCaptures=&quot;false&quot;&amp;gt;
                &amp;lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsFile&quot; negate=&quot;true&quot; /&amp;gt;
                &amp;lt;add input=&quot;{REQUEST_FILENAME}&quot; matchType=&quot;IsDirectory&quot; negate=&quot;true&quot; /&amp;gt;
                &amp;lt;/conditions&amp;gt;
                &amp;lt;action type=&quot;Rewrite&quot; url=&quot;/&quot; /&amp;gt;
           &amp;lt;/rule&amp;gt;
      &amp;lt;/rules&amp;gt;
    &amp;lt;/rewrite&amp;gt;
    &amp;lt;httpErrors&amp;gt;
      &amp;lt;remove statusCode=&quot;404&quot; subStatusCode=&quot;-1&quot; /&amp;gt;
      &amp;lt;remove statusCode=&quot;500&quot; subStatusCode=&quot;-1&quot; /&amp;gt;
      &amp;lt;error statusCode=&quot;404&quot; path=&quot;/survey/notfound&quot; responseMode=&quot;ExecuteURL&quot; /&amp;gt;
      &amp;lt;error statusCode=&quot;500&quot; path=&quot;/survey/error&quot; responseMode=&quot;ExecuteURL&quot; /&amp;gt;
    &amp;lt;/httpErrors&amp;gt; 
        
  &amp;lt;/system.webServer&amp;gt;
&amp;lt;/configuration&amp;gt;
&amp;lt;!--ProjectGuid: 068855e8-9240-4f1a-910b-cf825794513b--&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意： 黄色背景行便是反向代理规则&lt;code&gt;ReverseProxyInboundRule&lt;/code&gt;， 注意反向代理规则要在静态资源规则&lt;code&gt;ResourceToIndex&lt;/code&gt;的前面。&lt;/p&gt;
&lt;p&gt;这样我们就完成了在前后端分离开发模式下，使用IIS托管Vue应用的全过程。&lt;/p&gt;
&lt;p&gt;可算解决了前后端团队开发中一大问题，我把这个问题定义为[效率工具]类，有兴趣的读者可以试一试。&lt;/p&gt;
</description>
<pubDate>Wed, 04 Nov 2020 00:47:00 +0000</pubDate>
<dc:creator>有态度的小码甲</dc:creator>
<og:description>目前手上的Web项目是前后端分离的，所以有时也会倒腾Vue框架。 前后端应用最终以容器形态、在k8s中部署, 为此我搭建了基于Gitlab flow的Devops流程。 在Devops实践中，容器部署</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/JulianHuang/p/13923386.html</dc:identifier>
</item>
<item>
<title>技术总监7年总结，如何进行正确的沟通？ - pointersss</title>
<link>http://www.cnblogs.com/pointers/p/13924055.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pointers/p/13924055.html</guid>
<description>&lt;p&gt;有很粉丝私信我，问我要怎样地和领导、同事沟通？&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;3&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/1c6b76a9f27e388a082822ead552723d.png&quot; alt=&quot;&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/img_convert/1c6b76a9f27e388a082822ead552723d.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/img_convert/1c6b76a9f27e388a082822ead552723d.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;因为在工作中，如何正确的沟通，是非常重要的。例如下面这个例子：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;2&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/0bb6b7ac9d993c36790478010c0f8245.png&quot; alt=&quot;&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/img_convert/0bb6b7ac9d993c36790478010c0f8245.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/img_convert/0bb6b7ac9d993c36790478010c0f8245.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种沟通方式，应该不用五个来回，就能打起来了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这篇文章我想给大家分享几个正确沟通的技巧，不管你是主管还是下属，都能适用。&lt;/p&gt;
&lt;hr/&gt;




&lt;p&gt;&lt;em&gt;&lt;strong&gt;不要反问&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;沟通是一种语言的表达。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;而表达背后其实反映的是一个人的思考方式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有些人说话喜欢用反问的方式。&lt;/p&gt;
&lt;p&gt;反问，也是一剂沟通的毒药。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;你为什么会不知道呢？&lt;/p&gt;
&lt;p&gt;你难道不懂吗？&lt;/p&gt;
&lt;p&gt;你为什么不这样做？&lt;/p&gt;
&lt;p&gt;这样的问题，其实已经把你的建议藏在了问题中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这不是提问，这是把别人强行拉入到你的价值观念和判断体系，让人很不舒服。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当别人启动防御机制时，距离吵架就不远了。&lt;/p&gt;
&lt;p&gt;当嘴仗开始时，距离答案就更远了。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;strong&gt;换位思考&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;有些人的说话的方式是这样的：&lt;/p&gt;
&lt;p&gt;我说得这么明白，你怎么就是听不懂呢！&lt;/p&gt;
&lt;p&gt;我对你一片好心，你居然一点都不领情！&lt;/p&gt;
&lt;p&gt;我当然问心无愧，你应该好好反思自己！&lt;/p&gt;
&lt;p&gt;这些话语背后的模式，其实都暗藏着另一句话：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我没有错。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我苦口婆心，我勤勤恳恳，我任劳任怨，我没有错，都是别人的错。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种以自我为中心的沟通，应该戒掉。&lt;/p&gt;
&lt;p&gt;别人为什么不明白？不是别人不明白，而是你没有讲明白。&lt;/p&gt;
&lt;p&gt;你应该这么说会比较好：&lt;/p&gt;
&lt;p&gt;“我讲的足够清楚吗？”&lt;/p&gt;
&lt;p&gt;这句话的潜台词就是：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;”如果没有讲清楚是我的责任，我的问题“&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这句话听起来会非常的舒服，没有很强的攻击性，情绪自然会好很多了。&lt;/p&gt;
&lt;p&gt;一个人会沟通，会说话，不仅仅是能清晰表达自己的意思，更是能让对方产生好的情绪。&lt;/p&gt;
&lt;hr/&gt;






&lt;p&gt;在公司内，我们扮演者多个角色，有时候我们是下属，有时候我们是上级。&lt;/p&gt;
&lt;p&gt;你的下属可能会满心欢喜的完成了任务，告知你任务完成的喜讯。&lt;/p&gt;
&lt;p&gt;你的同事遇到问题，需要寻求你的帮助，满怀期待你的慷慨。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;很多老板都会冷冷冰冰的回了一句：“嗯，好”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这句话是什么意思？背后的意思是啥？&lt;/p&gt;
&lt;p&gt;其实是想说，这点问题还需要我去帮你解决，这点任务完成了有什么好开心的，有什么难度吗？还有一点就是，&lt;strong&gt;“我现在真的很忙，不要来浪费我时间”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;聪明很多人在心中都有一个 高大的ego，一个深深的自我，始终想和全世界证明自己的聪明，并且想尽一切办法告诉别人，我很聪明。&lt;/p&gt;
&lt;p&gt;所以请不要这么简单回复，尽量保持谦虚的态度&lt;strong&gt;“真棒，加油！”&lt;/strong&gt;or&lt;strong&gt;“好的，请稍等，我这还需要几分钟”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;既简单、谦虚，又不是礼貌。&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;






&lt;p&gt;黄金思维有三个层次——&lt;strong&gt;why、how、what&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;做任何事情都包含了这个黄金思维的三个层次。&lt;/p&gt;
&lt;p&gt;沟通是一种表达方式，当然也不例外。&lt;/p&gt;
&lt;p&gt;我们在沟通的时候，往往只可能关注一个点，what——就是干什么？&lt;/p&gt;
&lt;p&gt;但是，&lt;strong&gt;我们经常忽略了 why，为什么要做这件事，做这件事情的目的，有何价值。以及忽略了 how，如何做这件事。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因此在职场沟通的时候，每当布置一个 what，你都要下意识地反应，前面还有一个大大的 why，后面还有一个大大的 how。 &lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;1&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/9a8f29805d456d6342d3148e8adc52f7.png&quot; alt=&quot;&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/img_convert/9a8f29805d456d6342d3148e8adc52f7.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/img_convert/9a8f29805d456d6342d3148e8adc52f7.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;如果你是领导，把你的想法告诉你的下属，为什么要做这件事。没有任何一个人，希望在充满困惑的环境中工作。&lt;/p&gt;
&lt;p&gt;上图中，&lt;strong&gt;普通员工的思维模式，就是大众模式从外向内，从清晰到模糊。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;领导需要拥有非凡模式，从内向外，从模糊到清晰。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;黄金思维，这几乎是职场沟通最好的思维方式了。&lt;/p&gt;
&lt;hr/&gt;






&lt;p&gt;在工作中，不可避免的要向领导汇报。&lt;/p&gt;
&lt;p&gt;同样一件事，有的人三句话就能讲得清楚明白，而有些人半个小时，还没说到重点。&lt;/p&gt;
&lt;p&gt;汇报工作的时候，有的人5页ppt就能说服对方，要点就能把握，有的人，写了几十页，却被人问想表达什么。&lt;/p&gt;
&lt;p&gt;金字塔原则可以帮助到汇报困难户。&lt;/p&gt;
&lt;p&gt;基本结构是：&lt;strong&gt;结论先行，以上统下，归类分组，逻辑递进。先重要后次要，先总结后具体，先框架后细节，先结论后原因，先结果后过程，先论点后论据&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;例如：老板，我这个方案我觉得最优，第一，xxx，第二x，xxxx，第三xxxx。具体方案如下…。计划需要xx天，领导你觉得呢？ &lt;/p&gt;
&lt;p&gt;这个方案给到领导，有理有据、重点突出、思路清晰、层次分明、简单易懂，让领导有兴趣，能理解，记得住。&lt;/p&gt;
&lt;p&gt;总之两个字—&lt;strong&gt;—满意！&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;






&lt;p&gt;清楚了，就去干吧。&lt;/p&gt;
&lt;p&gt;你以为这样就行了吗？&lt;/p&gt;
&lt;p&gt;不行，没有deadline限制，没有清晰的目标时间限制，很容易拖延&lt;/p&gt;
&lt;p&gt;这个时候，常常会设置一个“最后期限”（Deadline）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主动的提出deadline。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;你以为最后deadline一天提交就行了吗？&lt;/p&gt;
&lt;p&gt;当然不行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;deadline是最低要求，最好在这之前就完成。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了保持项目、任务的良性进展，需要时刻保持信息的畅通。&lt;/p&gt;
&lt;p&gt;就是主动的汇报自己的工作进展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;让领导知道你正在干什么？干到什么程度了。有什么问题？需要什么资源？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你是领导，每天能看到下属每天反馈进展，那种掌控的成就感，油然而生。&lt;/p&gt;
&lt;p&gt;所以在deadline之前，保持和领导的信息交流，这最好的沟通方式。&lt;/p&gt;
&lt;hr/&gt;




&lt;p&gt;沟通是每一个技术人绕不开的技能，“别管我，我只想一个人安静写代码！”，这是不存在的。&lt;/p&gt;
&lt;p&gt;技术人大多数情况下并非是和计算机打交道而是人，本身写的代码就是给人看的。想要成为好的开发人员，领导心里的能力者，一定要学会正确的沟通。&lt;/p&gt;
&lt;p&gt;上面的5点建议，&lt;strong&gt;丢掉自我为中心、保持谦虚、黄金思维、金字塔原则、信息传递，&lt;/strong&gt;希望大家职业生涯中的能够沟通得更加优雅、从容。&lt;/p&gt;
&lt;hr/&gt;


&lt;p&gt;&lt;strong&gt;&lt;em&gt;推荐阅读（干货）&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484001&amp;amp;idx=1&amp;amp;sn=e5aafcb7ab8bad8b7439d4f8587d2f1f&amp;amp;chksm=cf209773f8571e659ca9fb146a49809b321ea2e83cf7d10248e7c94196b3eacb5b7d8f8142fc&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247484001&amp;amp;idx=1&amp;amp;sn=e5aafcb7ab8bad8b7439d4f8587d2f1f&amp;amp;chksm=cf209773f8571e659ca9fb146a49809b321ea2e83cf7d10248e7c94196b3eacb5b7d8f8142fc&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员如何管理你的上级领导？&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483962&amp;amp;idx=1&amp;amp;sn=cc73b3d2124fc23d89ccc4c5c612d18c&amp;amp;chksm=cf209728f8571e3e4345d4737029960d1e5c3f7b005fd4c8545a1ac283c086a73e4ca914ede0&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483962&amp;amp;idx=1&amp;amp;sn=cc73b3d2124fc23d89ccc4c5c612d18c&amp;amp;chksm=cf209728f8571e3e4345d4737029960d1e5c3f7b005fd4c8545a1ac283c086a73e4ca914ede0&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员如何打造个人品牌？&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483954&amp;amp;idx=1&amp;amp;sn=4d122f3d2330254f5a5ecca3876c46a8&amp;amp;chksm=cf209720f8571e368d1123e185b30e930c83463496b0a9d8b76aec9ebcffeeb1c3f5155cb1dc&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483954&amp;amp;idx=1&amp;amp;sn=4d122f3d2330254f5a5ecca3876c46a8&amp;amp;chksm=cf209720f8571e368d1123e185b30e930c83463496b0a9d8b76aec9ebcffeeb1c3f5155cb1dc&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员你应该勇敢说不&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483946&amp;amp;idx=1&amp;amp;sn=7629654c4acf6bd1c5f53639707a9c61&amp;amp;chksm=cf209738f8571e2e66764576dfa494bec92059058c9f2609391ede8c40bc010c167b2d535820&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483946&amp;amp;idx=1&amp;amp;sn=7629654c4acf6bd1c5f53639707a9c61&amp;amp;chksm=cf209738f8571e2e66764576dfa494bec92059058c9f2609391ede8c40bc010c167b2d535820&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;strong&gt;聊一聊 软件系统中的“热力学第二定律”&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=a170a555f571d4cbd2c4136b8ed57eff&amp;amp;chksm=cf209711f8571e07d674b4582488fe61e4e64d7179be7cb5ca5574edeee36f207d0cf7b0ea52&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483907&amp;amp;idx=1&amp;amp;sn=a170a555f571d4cbd2c4136b8ed57eff&amp;amp;chksm=cf209711f8571e07d674b4582488fe61e4e64d7179be7cb5ca5574edeee36f207d0cf7b0ea52&amp;amp;scene=21#wechat_redirect&quot;&gt;谈一谈程序员的职业发展路线&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483891&amp;amp;idx=1&amp;amp;sn=24cd8a6abf3b0681179dc5e5e846e0ba&amp;amp;chksm=cf2094e1f8571df70c1e37be4f3a3a81df0165e5e3359006a16ed64730fe9e5cc7fe97c37289&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483891&amp;amp;idx=1&amp;amp;sn=24cd8a6abf3b0681179dc5e5e846e0ba&amp;amp;chksm=cf2094e1f8571df70c1e37be4f3a3a81df0165e5e3359006a16ed64730fe9e5cc7fe97c37289&amp;amp;scene=21#wechat_redirect&quot;&gt;程序员进阶必备能力——晋升之道&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483792&amp;amp;idx=1&amp;amp;sn=f30fe58e4ea99d647b1853eca6bd5a6a&amp;amp;chksm=cf209482f8571d94e7dd372851397f98a838e84a9fbea9299337e5ee2301084228a4f57d315c&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483792&amp;amp;idx=1&amp;amp;sn=f30fe58e4ea99d647b1853eca6bd5a6a&amp;amp;chksm=cf209482f8571d94e7dd372851397f98a838e84a9fbea9299337e5ee2301084228a4f57d315c&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;strong&gt;送给刚毕业的程序员——7点建议&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483826&amp;amp;idx=1&amp;amp;sn=c82601363825ba261b88c0198ee3a91d&amp;amp;chksm=cf2094a0f8571db6b69603ba66b1ac62ef588fc3668ffdcddd4ca2fa62713eb8c614e279290b&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483826&amp;amp;idx=1&amp;amp;sn=c82601363825ba261b88c0198ee3a91d&amp;amp;chksm=cf2094a0f8571db6b69603ba66b1ac62ef588fc3668ffdcddd4ca2fa62713eb8c614e279290b&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;strong&gt;程序员进阶技术专家必备能力——深度思考&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483879&amp;amp;idx=1&amp;amp;sn=96067a68ebe584002a64dc0e21edb21d&amp;amp;chksm=cf2094f5f8571de38333e04d03d1dd60a56574d08d62324ae65bc73a3bc414e6d6e5e9d17121&amp;amp;scene=21#wechat_redirect&quot; data-cke-saved-href=&quot;http://mp.weixin.qq.com/s?__biz=Mzg3NzUxMTgwNQ==&amp;amp;mid=2247483879&amp;amp;idx=1&amp;amp;sn=96067a68ebe584002a64dc0e21edb21d&amp;amp;chksm=cf2094f5f8571de38333e04d03d1dd60a56574d08d62324ae65bc73a3bc414e6d6e5e9d17121&amp;amp;scene=21#wechat_redirect&quot;&gt;&lt;strong&gt;程序员如何选择一家好公司&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;


&lt;p&gt;&lt;strong&gt;觉得不错，记得关注、转发和在看！多年经验分享，实属不易，感谢支持！&lt;/strong&gt;&lt;/p&gt;
&lt;hr/&gt;
&lt;p&gt;博主是一位物联网大厂技术总监，从业7年。从软件开发、高级软件开发、技术经理再到技术总监，分享职业发展、技术管理、职场晋升、技术成长等个人多年经验和心得。一起成长！有问题可以加我微信交流：&lt;strong&gt;pointersss&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果你有技术成长的瓶颈、对未来迷茫、关注我，帮你答疑解惑！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span class=&quot;cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected&quot; data-cke-widget-wrapper=&quot;1&quot; data-cke-filter=&quot;off&quot; data-cke-display-name=&quot;图像&quot; data-cke-widget-id=&quot;0&quot;&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/425da483c978ace9c0672045e177b1d1.png&quot; alt=&quot;&quot; class=&quot;cke_widget_element&quot; data-cke-saved-src=&quot;https://img-blog.csdnimg.cn/img_convert/425da483c978ace9c0672045e177b1d1.png&quot; data-cke-widget-data=&quot;{&amp;amp;quot;hasCaption&amp;amp;quot;:false,&amp;amp;quot;src&amp;amp;quot;:&amp;amp;quot;https://img-blog.csdnimg.cn/img_convert/425da483c978ace9c0672045e177b1d1.png&amp;amp;quot;,&amp;amp;quot;alt&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;width&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;height&amp;amp;quot;:&amp;amp;quot;&amp;amp;quot;,&amp;amp;quot;lock&amp;amp;quot;:true,&amp;amp;quot;align&amp;amp;quot;:&amp;amp;quot;none&amp;amp;quot;,&amp;amp;quot;classes&amp;amp;quot;:[]}&quot; data-cke-widget-upcasted=&quot;1&quot; data-cke-widget-keep-attr=&quot;0&quot; data-widget=&quot;image&quot;/&gt;&lt;span class=&quot;cke_reset cke_widget_drag_handler_container&quot;&gt;&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==&quot; width=&quot;15&quot; height=&quot;15&quot; class=&quot;cke_reset cke_widget_drag_handler&quot; title=&quot;点击并拖拽以移动&quot; data-cke-widget-drag-handler=&quot;1&quot;/&gt;&lt;span class=&quot;cke_image_resizer&quot; title=&quot;点击并拖拽以改变尺寸&quot;&gt;​&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 04 Nov 2020 00:24:00 +0000</pubDate>
<dc:creator>pointersss</dc:creator>
<og:description>有很粉丝私信我，问我要怎样地和领导、同事沟通？ ​ 因为在工作中，如何正确的沟通，是非常重要的。例如下面这个例子： ​ 这种沟通方式，应该不用五个来回，就能打起来了。 这篇文章我想给大家分享几个正确沟</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pointers/p/13924055.html</dc:identifier>
</item>
<item>
<title>学了元件作用域，我终于对JMeter开窍了 - 测试老树</title>
<link>http://www.cnblogs.com/df888/p/13922220.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/13922220.html</guid>
<description>&lt;p&gt;先看一下这个例子，测试计划“进入考场”下面有一个线程组，线程组下面有 3 个 HTTP 请求，分别是学生登录、考场 token和进入房间：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201103200717887-1277914145.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;它们的处理逻辑是：&lt;/p&gt;
&lt;ol readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;学生登录后，在响应中返回了登录后的 token，使用正则表达式提取器，提取登录 token&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;在登录以后，把登录 token 作为 header，去请求“考场token”这个接口，请求后的响应中，返回了考场 token，使用正则表达式提取，下图是“考场token”请求的 header，使用了 HTTP Header 管理器：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201103200716556-384774487.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;拿到考场 token 以后，把考场 token 作为 header，去请求“进入房间”接口，下图是“进入房间”请求的 header，Value定义的是 ${exam_token}，就是考场 token，这个 token 是从第 2 个请求“考场token”的响应中，使用正则表达式提取出来的：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201103200716969-902736942.png&quot;/&gt;&lt;/center&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;回顾一下，首先登陆，登陆后获取token，然后再获取考场token，最后进入房间。这个例子的问题就在于，第 2 个请求和第 3 个请求，都设置了 header，这 2 个 HTTP Header Manager 能按我们想的去工作吗？&lt;/p&gt;

&lt;h2 id=&quot;运行顺序&quot;&gt;运行顺序&lt;/h2&gt;
&lt;p&gt;先了解一下 JMeter 元件的运行顺序。JMeter 根据 2 个维度来决定元件的运行顺序，第 1 个维度是&lt;strong&gt;从上往下&lt;/strong&gt;，第 2 个维度是&lt;strong&gt;元件类型&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从上往下，指的是从根节点-&amp;gt;父节点-&amp;gt;子节点-&amp;gt;叶子节点。&lt;/p&gt;
&lt;p&gt;元件类型，分为 3 类：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;线程组、逻辑控制器。&lt;/li&gt;
&lt;li&gt;取样器。&lt;/li&gt;
&lt;li&gt;配置元件、前置处理器、定时器、后置处理器、断言、监听器。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;最后这六个元件类型，都是为取样器服务的。&lt;/strong&gt;它们的运行顺序如下：&lt;/p&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;配置元件（如果存在）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;前置处理器（如果存在）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;定时器（如果存在）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;取样器（如果存在）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;后置处理器（如果存在且取样器的结果不为空）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;断言（如果存在且取样器的结果不为空）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;监听器（如果存在且取样器的结果不为空）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;我总结一下加强理解&lt;/strong&gt;。假设我们新建了 1 个线程，想用这个线程去发请求。&lt;/p&gt;
&lt;p&gt;首先是初始化配置，比如参数化、设置 Header、Cookie 等，&lt;strong&gt;配置元件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接着可能需要给线程加点参数，比如用户参数，会用到&lt;strong&gt;前置处理器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;然后在发送请求前可能会等待一段时间，添加&lt;strong&gt;定时器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;准备好以后，就可以发送请求了，也就是&lt;strong&gt;取样器&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果取样器什么数据也没有返回，那么就可以直接退出了。&lt;/p&gt;
&lt;p&gt;如果返回了数据，使用&lt;strong&gt;后置处理器&lt;/strong&gt;，比如正则表达式提取器，提取想要的数据。&lt;/p&gt;
&lt;p&gt;提取之后还有要做验证，&lt;strong&gt;断言&lt;/strong&gt;一把。&lt;/p&gt;
&lt;p&gt;测试运行的怎么样呢，用&lt;strong&gt;监听器&lt;/strong&gt;看一看。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;再结合示例感受一下，请看以下测试计划，添加了 1 个 线程组，包含 3 个 取样器（HTTP Request 1 2 3）：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201103200717276-124209933.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;JMeter 会按以下步骤运行：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;线程组（如果有多个线程组可以在测试计划设置是顺序执行还是同时执行）&lt;/li&gt;
&lt;li&gt;简单控制器（父节点）&lt;/li&gt;
&lt;li&gt;HTTP Cookie 管理器（配置元件）&lt;/li&gt;
&lt;li&gt;用户参数（前置处理器）&lt;/li&gt;
&lt;li&gt;Synchronizing Timer（定时器）&lt;/li&gt;
&lt;li&gt;HTTP 请求 1（取样器）&lt;/li&gt;
&lt;li&gt;正则表达式提取器（后置处理器）&lt;/li&gt;
&lt;li&gt;响应断言（断言）&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;HTTP Cookie 管理器（配置元件）&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;用户参数（前置处理器）&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;Synchronizing Timer（定时器）&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;HTTP 请求 2（取样器）&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;正则表达式提取器（后置处理器）&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;响应断言（断言）&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;HTTP 请求 3（取样器）&lt;/li&gt;
&lt;li&gt;察看结果树（严格来讲是与第 6 步并行，也就是取样器之后）&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;作用域&quot;&gt;作用域&lt;/h2&gt;
&lt;p&gt;第 9 ~ 14 步我用黑色斜体加粗了，因为从图中的位置来看，“HTTP 请求 2”，前后并没有元件，但是也被作用上了。&lt;/p&gt;
&lt;p&gt;这是因为它们具有相同的作用域，在 JMeter 中，&lt;strong&gt;同一层级的元件具有相同的作用域&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;示例中，添加了一个简单控制器，然后在下级添加了配置元件、前置处理器、定时器、后置处理器、断言，和 2 个取样器（HTTP Request 1 2 ）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单控制器&lt;/strong&gt;是一个执行单元，本身没有内容，它的作用是把元件进行分组运行：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201103200717575-982826313.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;所以简单控制器下面的这些同级元件，作用域相同，既会作用于 HTTP Request 1，也会作用于 HTTP Request 2。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;配置元件、前置处理器、定时器、后置处理器、断言、监听器，这六个元件类型，会作用到范围内的所有取样器&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;层级&quot;&gt;层级&lt;/h2&gt;
&lt;p&gt;在 JMeter 中，上级的作用域包含下级的作用域。&lt;/p&gt;
&lt;p&gt;但是下级是不能作用到上级的。&lt;/p&gt;
&lt;p&gt;比如示例中的 HTTP Request 3，和简单控制器是平级，那么简单控制器下级的元件，是不会作用到 HTTP Request 3 的。&lt;/p&gt;

&lt;p&gt;再看看开头的例子：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201103200717887-1277914145.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;有 3 个取样器，用户自定义变量和 CSV Data Set Config，都是配置元件，跟取样器同级，会同时作用到这 3 个取样器上面。&lt;/p&gt;
&lt;p&gt;HTTP Header Manager 也是配置元件，不会作用到学生登录取样器，因为根据从上往下的维度，它们都位于学生登录取样器之后。&lt;/p&gt;
&lt;p&gt;图中有 2 个 HTTP Header Manager，你可能会认为它们会分别执行，实际上它们会一起执行！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在同一执行单元中，如果相同类型的元件有多个，会被当做一个一起执行。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我把第 2 个 HTTP Header Manager 稍微改了一下，可以看得很明显：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201103200718195-1552746482.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;考场token的请求，在目录树中是第 2 个，但是从结果来看，它的 header，被添加上了我在后面第 3 个请求设置的 header了。&lt;/p&gt;
&lt;p&gt;这个结果显然不是想要的。&lt;/p&gt;
&lt;p&gt;所以为了避免混乱，建议在使用 JMeter 添加元件的时候，一是根据先后顺序，从上往下合理的放置元件的顺序。二是对于配置元件、前置处理器、定时器、后置处理器、断言这六类元件，因为它们都是为取样器服务的，如果只想作用于单个取样器，最好是放在这个取样器的下级，以避免由于同一作用域相互作用，导致意想不到的结果。&lt;/p&gt;
&lt;p&gt;这个例子把 HTTP Header Manager 分别放到各自的取样器下级，就能按设想运行起来了：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202011/1629545-20201103200718502-300105065.png&quot;/&gt;&lt;/center&gt;

&lt;p&gt;本文首先引入了我工作中碰到的问题，接着结合示例讲解了运行顺序、作用域和层级，搞懂了 JMeter 目录树是怎么运行的，最后回到开头的例子进行了结果分析，给出了在使用时的两条建议。&lt;/p&gt;
</description>
<pubDate>Wed, 04 Nov 2020 00:15:00 +0000</pubDate>
<dc:creator>测试老树</dc:creator>
<og:description>元件作用域。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/13922220.html</dc:identifier>
</item>
<item>
<title>Django之MTV实战(2) - Singvis</title>
<link>http://www.cnblogs.com/singvis/p/13923631.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/singvis/p/13923631.html</guid>
<description>&lt;p&gt;Hello, 各位，我回来了，大家别以为我消失了，我还是在的...&lt;/p&gt;
&lt;p&gt;最近忙于家里重要事情，不能定期及时更新，请包含...&lt;/p&gt;
&lt;p&gt;忙里挑一，我还是在后台默默的码了几篇文章，前提要保证下质量，才能发出来，哈哈！不然...嘿嘿&lt;/p&gt;
&lt;p&gt;大家搬好小板凳了，前方的真的高能，文章篇幅有点多，一步一步来...&lt;/p&gt;
&lt;p&gt;跟着我走，简单学起来...&lt;/p&gt;

&lt;p&gt;上一篇文章已经教会了大家怎么安装Django和简单的配置，相信大家应该早就学会了，那么我们在回忆一下吧，懂的同学可跳过这章节。&lt;/p&gt;
&lt;h2 id=&quot;11-新增工程&quot;&gt;1.1 新增工程&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;django-admin startproject &amp;lt;自定义工程名称&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;(py369) [python@localhost Python]$ django-admin startproject devops 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;12-创建新的app&quot;&gt;1.2 创建新的APP&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;python manage.py startapp &amp;lt;自定义APP名称&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;(py369) [python@localhost devops]$ python manage.py startapp hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;13-注册app&quot;&gt;1.3 注册APP&lt;/h2&gt;
&lt;p&gt;在&lt;code&gt;devops-&amp;gt;settings.y&lt;/code&gt;里面t添加:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # 第一种方式
    'hello.apps.HelloConfig',
    # 第二种方式，直接写hello也行
    'hello',
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;14-编写url和view&quot;&gt;1.4 编写URL和VIEW&lt;/h2&gt;
&lt;p&gt;在devops下的主路由&lt;code&gt;urls.py&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.contrib import admin
from django.urls import path,include
from views import index

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', index.index),
    # 引导到hello下的路由URL(也叫子路由)
    path('hello/', include('hello.urls'))
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在hello下的子路由&lt;code&gt;urls.py&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.urls import path
from hello import view

app_name = 'hello'
urlpatterns = [
    # 普通url参数
    path('', view.index, name='index'),
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;hello下的&lt;code&gt;view.py&lt;/code&gt;代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.http import HttpResponse

def index(request):
    return HttpResponse('hello django')
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;15-验证结果如下：&quot;&gt;1.5 验证结果如下：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005923693-278505591.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;21-专业术语&quot;&gt;2.1 专业术语&lt;/h2&gt;
&lt;p&gt;MTV简写：&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;M：model，这个是对应数据库的，简单理解就是对应数据库的表。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;T：template，这个对应的是HTML模板，前端渲染用的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;V：view，这个对应的是后台python执行脚本了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;通俗的一句话&lt;/strong&gt;：用户发送http请求，匹配&lt;code&gt;url&lt;/code&gt;后执行&lt;code&gt;view&lt;/code&gt;脚本返回模板&lt;code&gt;template&lt;/code&gt;，用户看到了网页的展示效果(&lt;code&gt;渲染)&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;22-mtv之视图&quot;&gt;2.2 MTV之视图&lt;/h2&gt;
&lt;h3 id=&quot;221-request对象&quot;&gt;2.2.1 request对象&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005924352-88450075.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;222-respone对象&quot;&gt;2.2.2 Respone对象&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005924604-1452210994.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面详细介绍下...&lt;/p&gt;
&lt;h3 id=&quot;223-get请求&quot;&gt;2.2.3 GET请求&lt;/h3&gt;
&lt;ul readability=&quot;59&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;GET请求，不带参数&lt;/p&gt;
&lt;p&gt;网页输入这样的格式，是&lt;code&gt;不带参数&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;https://192.168.8.130:8888/hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备注：如上面演示的就是不带参数。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;47&quot;&gt;
&lt;p&gt;GET请求，?+参数&lt;/p&gt;
&lt;p&gt;比较常用的方式&lt;code&gt;?+参数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在浏览器输入如下地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;http://192.168.8.130:8888/hello/?year=2020&amp;amp;month=09&amp;amp;day=02
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;说明：&lt;/em&gt; 参数：&lt;code&gt;year&lt;/code&gt; &lt;code&gt;month&lt;/code&gt; &lt;code&gt;day&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;网址匹配到路由&lt;code&gt;hello/url.py&lt;/code&gt; 的配置规则&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.urls import path
from hello import view

app_name = 'hello'
urlpatterns = [
    # 普通参数
        path('', view.index, name='index'),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后台视图&lt;code&gt;hello/view.py&lt;/code&gt;代码配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.http import HttpResponse

def index(request):
    print(request.GET)
    return HttpResponse(&quot;year is {}, month is {}, day is {}.&quot;.format(year, month, day))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后台打印输出的结果如下：&lt;br/&gt;&lt;em&gt;备注：&lt;/em&gt; 是一个&lt;code&gt;QueryDict&lt;/code&gt;对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;&amp;lt;QueryDict: {'year': ['2020'], 'month': ['09'], 'day': ['02']}&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面已经接收到用户的信息了，就可以获取相应的参数了，hello/view后台脚本更新如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;  from django.http import HttpResponse
  
  def index(request):
      #第一个参数是获取QueryDict的year
      #第二参数是默认值，表示拿不到数据，用缺省值
      year = request.GET.get('year', '2030')                                 
      month = request.GET.get('month', 'Sep')
      day = request.GET.get('day', '8')
      return HttpResponse(&quot;year is {}, month is {}, day is {}.&quot;.format(year, month, day))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网页请求带参数返回的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005925296-1951751841.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;网页请求不带参数返回的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005925984-2133700590.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;22&quot;&gt;
&lt;p&gt;GET请求，位置参数&lt;/p&gt;
&lt;p&gt;&lt;code&gt;不推荐使用，位置要一一对应入座&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;网址匹配到路由&lt;code&gt;hello/url.py&lt;/code&gt;配置规则&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.urls import re_path
from hello import view

app_name = 'hello'
urlpatterns = [
    # 位置参数
    # [0-9]表示数字0-9，{4}表示取4位数字
        re_path('([0-9]{4})/([0-9]{2})/([0-9]{2})/', view.index, name='index'),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后台视图&lt;code&gt;hello/view.py&lt;/code&gt;脚本配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def index(request, year, month, day):
    return HttpResponse(&quot;year is {}, month is {}, day is {}.&quot;.format(year, month, day))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网页输入如下地址，请求返回的结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005926599-1107571958.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;40&quot;&gt;
&lt;p&gt;GET请求，关键字参数&lt;/p&gt;
&lt;p&gt;说明：&lt;code&gt;强烈推荐，优雅的方式&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在浏览器输入如下地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;http://192.168.8.130:8888/2020/09/02
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;路由视图&lt;code&gt;hello/url.py&lt;/code&gt;配置规则&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.urls import re_path
from hello import view

app_name = 'hello'
urlpatterns = [
    # 关键字参数，(?&amp;lt;参数名&amp;gt;参数类型)
    re_path('(?P&amp;lt;year&amp;gt;[0-9]{4})/(?P&amp;lt;month&amp;gt;[0-9]{2})/(?P&amp;lt;day&amp;gt;[0-9]{2})', view.index, name='index'),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后台视图&lt;code&gt;hello/view.py&lt;/code&gt;脚本配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.http import HttpResponse

def index(request, **kwargs):
    # 输出结果:{'year': '2020', 'month': '09', 'day': '02'}
    print(kwargs)  
    year = kwargs.get('year')
    month = kwargs.get('month')
    day = kwargs.get('day')
    return HttpResponse(&quot;year is {}, month is {}, day is {}.&quot;.format(year, month, day))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还可以换成另外一种写法，更加灵活，但是用的也不是很多：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.http import HttpResponse

# 不用考虑到函数参数的位置
def index(request, day, month, year):
    return HttpResponse(&quot;year is {}, month is {}, day is {}.&quot;.format(year, month, day))
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;224-post请求&quot;&gt;2.2.4 POST请求&lt;/h3&gt;
&lt;p&gt;在devops/setting.py里把&lt;code&gt;csrf&lt;/code&gt;关闭，不然会运行报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    # 默认开启防止中间人CSRF攻击,前期先注释掉
    # 'django.middleware.csrf.CsrfViewMiddleware',  
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网址匹配到路由&lt;code&gt;hello/urls.py&lt;/code&gt;配置规则&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.urls import path
from hello import view

app_name = 'hello'
urlpatterns = [
    path('', view.index, name='index'),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后台视图&lt;code&gt;hello/view.py&lt;/code&gt;脚本配置如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.http import HttpResponse, QueryDict

def index(request):
    if request.method == &quot;POST&quot;:
        # POST方法
        print(request.method) 
        # body是字节编码，b'year=2020&amp;amp;month=09&amp;amp;day=13'
        print(request.body)  
        # 转换为字典{'year': '2020', 'month': '09', 'day': '13'}
        print(QueryDict(request.body).dict())
        # &amp;lt;QueryDict: {'year': ['2020'], 'month': ['09'], 'day': ['13']}&amp;gt;
        print(request.POST)  
        data = request.POST
        year = data.get('year', '2030')
        month = data.get('month', '9')
        day = data.get('day', '8')

        return HttpResponse(&quot;year is {}, month is {}, day is {}.&quot;.format(year, month, day))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;模拟触发POST流量：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[root@localhost ~]# curl -X POST http://192.168.8.130:8888/hello/ -d 'year=2020&amp;amp;month=09&amp;amp;day=13'
year is 2030, month is 9, day is 13.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看我们后台接收哪些信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005927282-1535712477.gif&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;225-querydict介绍&quot;&gt;2.2.5 QueryDict介绍&lt;/h3&gt;
&lt;p&gt;在httprequest对象中，GET和POST属性是django.http.QueryDict的实例，它是一个自定义的类似字典的类，用来处理同一个键带多个值。无论使用GET，POST方式，他们最终都是通过QueryDict方法对传入的参数进行处理。&lt;/p&gt;

&lt;h2 id=&quot;31-模板继承&quot;&gt;3.1 模板继承&lt;/h2&gt;
&lt;h3 id=&quot;311-常规手段&quot;&gt;3.1.1 常规手段&lt;/h3&gt;
&lt;ul readability=&quot;18&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;创建模板&lt;code&gt;templates&lt;/code&gt;目录及子目录&lt;code&gt;hello&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;mkdir -p devops/templates/hello
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备注：每一个APP对应一个目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;路由视图&lt;code&gt;hello/urls.py&lt;/code&gt;配置规则&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.urls import path
from hello import view

app_name = 'hello'
urlpatterns = [
    path('list/', view.list, name='list'),
]
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;16&quot;&gt;
&lt;p&gt;后台视图&lt;code&gt;hello/view.py&lt;/code&gt;配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.shortcuts import render

def list(request):
    users = [
        {'username':'test01', 'age':18, 'hobby':'python'},
        {'username':'test02', 'age':18, 'hobby':'java'},
        {'username':'test01', 'age':18, 'hobby':'C'},
    ]
    return render(request, 'hello/list.html', {'users':users})
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明：本次练习，还没涉及到数据库，所以先本地创建数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;新建模板&lt;/p&gt;
&lt;p&gt;&lt;code&gt;templates/hello/list.html&lt;/code&gt;配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;!DOCTYPE html&amp;gt;
  &amp;lt;html lang=&quot;en&quot;&amp;gt;
  &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;点滴技术&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
  &amp;lt;p style=&quot;background-color: #77ee77&quot;&amp;gt;用户列表&amp;lt;/p&amp;gt;
     

  &amp;lt;table border=&quot;1&quot;&amp;gt;
        &amp;lt;thead style=&quot;background-color: #00aced&quot;&amp;gt;
                &amp;lt;tr&amp;gt;
                        &amp;lt;td&amp;gt;username&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;age&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;hobby&amp;lt;/td&amp;gt;
                &amp;lt;/tr&amp;gt;
        &amp;lt;/thead&amp;gt;
        &amp;lt;tbody&amp;gt;
                {% for user in users %}
                &amp;lt;tr&amp;gt;
                        &amp;lt;td&amp;gt; {{ user.username }} &amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt; {{ user.age }} &amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt; {{ user.hobby }} &amp;lt;/td&amp;gt;
                &amp;lt;/tr&amp;gt;
                {% endfor %}
        &amp;lt;/tbody&amp;gt;
  &amp;lt;/table&amp;gt;
  &amp;lt;p style=&quot;background-color: yellow&quot;&amp;gt; 版权所有©点滴技术 &amp;lt;/p&amp;gt;
  &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;网页输入地址后，效果图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005927902-1249603475.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;312-模板继承&quot;&gt;3.1.2 模板继承&lt;/h3&gt;
&lt;ul readability=&quot;12.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;定义母板&lt;br/&gt;在&lt;code&gt;devops/templates&lt;/code&gt;目录下新增一个&lt;code&gt;base.html&lt;/code&gt;母板。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;!doctype html&amp;gt;
  &amp;lt;html lang=&quot;en&quot;&amp;gt;
  &amp;lt;head&amp;gt;
  &amp;lt;!--   每个html的标签变量，都可以自定义--&amp;gt;
    &amp;lt;title&amp;gt;
        {% block title %}NetDevOps{% endblock title %}
    &amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;

  &amp;lt;body&amp;gt;
  &amp;lt;!--  body变量，每个页面都可以自定义内容--&amp;gt;
  {% block body %}这是body的内容{% endblock body %}

  &amp;lt;!-- 底部，每个html页面固定样式 --&amp;gt;
  &amp;lt;p style=&quot;background-color: yellow&quot;&amp;gt; 版权所有©点滴技术 &amp;lt;/p&amp;gt;
  &amp;lt;/body&amp;gt;
  &amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;子页面继承&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;!--继承母版--&amp;gt;
  {% extends &quot;base.html&quot; %}
  &amp;lt;!--重写title的内容--&amp;gt;
  {% block title %} 用户的列表 {% endblock %}

  &amp;lt;!--重写body的内容--&amp;gt;
  {% block body %}
  &amp;lt;table border=&quot;1&quot;&amp;gt;
        &amp;lt;thead style=&quot;background-color: #00aced&quot; &amp;gt;
                &amp;lt;tr&amp;gt;
                        &amp;lt;td&amp;gt;username&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;age&amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt;hobby&amp;lt;/td&amp;gt;
                &amp;lt;/tr&amp;gt;
        &amp;lt;/thead&amp;gt;
        &amp;lt;tbody&amp;gt;
                {% for user in users %}
                &amp;lt;tr&amp;gt;
                        &amp;lt;td&amp;gt; {{ user.username }} &amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt; {{ user.age }} &amp;lt;/td&amp;gt;
                        &amp;lt;td&amp;gt; {{ user.hobby }} &amp;lt;/td&amp;gt;
          &amp;lt;/tr&amp;gt;
                {% endfor %}
        &amp;lt;/tbody&amp;gt;
  &amp;lt;/table&amp;gt;
  {% endblock%}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备注：公共部分代码就不用写出来了，减少了代码冗余。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;视图&lt;code&gt;hello/view.py&lt;/code&gt;配置&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.shortcuts import render

def userlist(request):
    users = [
        {'username':'test01', 'age':18, 'hobby':'python'},
        {'username':'test02', 'age':18, 'hobby':'java'},
        {'username':'test03', 'age':18, 'hobby':'C'},
    ]
    return render(request, 'hello/userlist.html', {'users':users})
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;效果图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005928059-1071998826.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;41-django自带常用过滤器&quot;&gt;4.1 Django自带常用过滤器&lt;/h2&gt;
&lt;ul readability=&quot;15&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;传入参数的长度&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;{% if messages|length &amp;gt;= 3 %}
 The Messages is too long.
{% else %}
 The messages is too short.
{% endif %}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;default：缺省值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;{{ messages|default:&quot;nothing&quot; }}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备注：如果传入的值为false，则使用缺省值。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;first/last&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;{{ messages|first }}
{{ messages|last }}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;备注：显示列表第一个或最后一个元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;join&lt;br/&gt;说明：将列表转为字符串。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;{{ value|join:&quot;-&quot; }}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;length&lt;br/&gt;说明：判断长度，返回布尔值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;{{ messages|length}}
{{ messages|length_is:&quot;4&quot;}}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;static&lt;br/&gt;说明：加载本地图片、css、js样式等资源，通常使用CDN方式。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;# 方法1：
{% load static %}
&amp;lt;img src=&quot;{% static &quot;images/favicon.png&quot; %}&quot; alt=&quot;Hi!&quot; /&amp;gt;

# 方法2：
{% load static %}
{% static &quot;images/favicon.png&quot; as myphoto %}
&amp;lt;img src=&quot;{{ myphoto }}&quot;&amp;gt;&amp;lt;/img&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;date&lt;br/&gt;说明：时间格式化，返回年-月-日 时-分-秒&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;{{ messages|date:&quot;Y/m/d&quot; }}{{ messages|date:&quot;H:i:s&quot; }}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;safe&lt;br/&gt;说明：缺省情况下，django会对HTML等标签进行自动转义，如果要关闭自动转义，可通过过滤器&quot;|safe&quot;的方式申明不用转义。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;value = &quot;&amp;lt;a href=&quot;https://www.python.org&quot;&amp;gt; 百度链接 &amp;lt;/a&amp;gt;&quot;
{{ value|safe }}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;csrf_token&lt;br/&gt;说明：用于跨站请求伪造保护&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;  &amp;lt;form action=&quot;&quot; method='post'&amp;gt;
        {% csrf_token %}        # 有了这个POST请求才能正常运行
        &amp;lt;p&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;user&quot;&amp;gt;&amp;lt;/p&amp;gt;
        &amp;lt;input type=&quot;submit&quot;&amp;gt;
  &amp;lt;/form&amp;gt; 
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;slice&lt;br/&gt;说明：切片&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;{{ messages|slice:&quot;:2&quot;}}

&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;42-自定义模板标签和过滤器&quot;&gt;4.2 自定义模板标签和过滤器&lt;/h2&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;定义标签&lt;br/&gt;创建目录及文件：&lt;code&gt;hello/templatetags/mytag.py&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django import template

register = template.Library()

@register.filter
def test(x, y):
    return int(x)*2 + int(y)qq
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;模板视图&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;  &amp;lt;!--继承母版--&amp;gt;
  {% extends &quot;base.html&quot; %}
  {% block title %}模板标签{% endblock %}

  &amp;lt;!--重写body的内容--&amp;gt;
  {% block body %}

  &amp;lt;!--自定义模板标签--&amp;gt;
  {% load mytag %}
  &amp;lt;p&amp;gt; {{ &quot;2&quot;|test:&quot;1&quot; }}&amp;lt;/p&amp;gt;

  {% endblock%}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;51-模型概念&quot;&gt;5.1 模型概念&lt;/h2&gt;
&lt;p&gt;简单理解：模型对应数据库中的表，模型中的一个类对应数据库一张表；&lt;/p&gt;
&lt;h3 id=&quot;511-常用字段类型&quot;&gt;5.1.1 常用字段类型&lt;/h3&gt;
&lt;ul readability=&quot;9&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;字符串：&lt;code&gt;CharFieLd&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.db import models
class User():
        username = models.CharField(max_length=20)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;整数：&lt;code&gt;IntegerField&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;int_field = models.IntegerField()
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;浮点数：&lt;code&gt;FloatField&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;float_field = models.FloatField()
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自增字段：&lt;code&gt;AutoField&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;id_field = models.AutoField(primary_key=True)
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;文本框：&lt;code&gt;TextField&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;text_field = models.TextField()
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;邮箱：&lt;code&gt;EmailField&lt;/code&gt;&lt;br/&gt;说明：用于检查邮箱的合法性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;mail_field = models.EmailField()
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;日期：&lt;code&gt;DateField&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;说明：&lt;code&gt;auto_now&lt;/code&gt;是被保存时，将时间设置为当前时间，通常表示&lt;code&gt;last-modified&lt;/code&gt;, &lt;code&gt;auto_now_add&lt;/code&gt;是首次被创建时，设置为当前时间，通常表示创建时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;date = models.DateField()
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;文件上传：&lt;code&gt;Filefield&lt;/code&gt;&lt;br/&gt;说明：&lt;code&gt;upload_to&lt;/code&gt;必选参数，指文件的上传存放路径。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;upload_file = models.FileField(upload_to='/usr/tmp/test')
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;512-常用字段参数&quot;&gt;5.1.2 常用字段参数&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;null&lt;br/&gt;如果&lt;code&gt;null=True&lt;/code&gt;将再数据库存放一个空值NULL，缺省为Flase。&lt;br/&gt;该字段是可以在数据中存放null值。&lt;/li&gt;
&lt;li&gt;blank&lt;br/&gt;如果&lt;code&gt;blank=True&lt;/code&gt;，则允许该字段为空白，缺省是False，不允许为空。&lt;br/&gt;该字段是表单验证是否允许为空或不为空的。&lt;/li&gt;
&lt;li&gt;unique&lt;br/&gt;如果&lt;code&gt;unique=True&lt;/code&gt;，表示该字段在整个表单中是唯一的，不重复的。&lt;/li&gt;
&lt;li&gt;primary_key&lt;br/&gt;如果&lt;code&gt;primary_key=True&lt;/code&gt;, 表示该字段在数据库中是主键。&lt;/li&gt;
&lt;li&gt;default = ''&lt;br/&gt;用于定义缺省值。&lt;/li&gt;
&lt;li&gt;verbose_name&lt;br/&gt;&lt;code&gt;ForeignKey&lt;/code&gt;、&lt;code&gt;ManyToManyField&lt;/code&gt;、和&lt;code&gt;OneToOneField&lt;/code&gt;的备注信息需要用到这个。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;61-设计一个简单的模型&quot;&gt;6.1 设计一个简单的模型&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;hello\models.py&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#!/usr/bin/env python3
#-*- coding:UTF-8 -*-

from django.db import models

class Devices(models.Model):
    device_name = models.CharField(max_length=32, help_text='设备名称')
    ip = models.CharField(max_length=15, help_text='管理IP地址')
    vendor = models.CharField(max_length=16, help_text='厂商')
    device_type = models.CharField(max_length=6, help_text='设备类型')
    model = models.CharField(max_length=32, help_text='设备型号')
    sn = models.CharField(max_length=32, help_text='序列号')
    os = models.CharField(max_length=16, help_text='操作系统')
    version = models.CharField(max_length=32, help_text='版本')

    def __str__(self):
        return self.device_name
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;62-将模型同步到数据库&quot;&gt;6.2 将模型同步到数据库&lt;/h2&gt;
&lt;ul readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;生成迁移脚本&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;(py369) [root@localhost devops]# python manage.py makemigrations hello
Migrations for 'hello':
  hello/migrations/0004_devices.py
    - Create model Devices
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;展示迁移的sql语句&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;(py369) [root@localhost devops]# python manage.py sqlmigrate hello 0004
BEGIN;
--
-- Create model Devices
--
此处省略...

&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;执行数据库命令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;(py369) [root@localhost devops]# python manage.py migrate hello
Operations to perform:
  Apply all migrations: hello
Running migrations:
  Applying hello.0004_devices... OK
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看数据库表&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005928273-577408283.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;常用命令解释&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 生产迁移脚本
python manage.py makemigrations &amp;lt;app_name&amp;gt;
# 转换后的sql语句
python manage.py sqlmigrate &amp;lt;app_name&amp;gt; &amp;lt;number&amp;gt;
# 执行数据库命令
python manage.py migrate
# 所有APP及对应生效的migration
python manage.py showmigrations
# 将某个APP的migration重置
python manage.py migrate --fake hello
# 强制执行某个版本的迁移脚本
python manage.py migrate --fake hello
python manage.py migrate --fake hello 0004

&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;71-orm概念&quot;&gt;7.1 ORM概念&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;ORM是对数据抽象建模并提供访问接口的编程方式&lt;/li&gt;
&lt;li&gt;模型中的一个类(class)表示一个表(table)&lt;/li&gt;
&lt;li&gt;每一个属性对应数据表中的一个字段&lt;/li&gt;
&lt;li&gt;调用数据表，就是实例化类的对象&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;72-增--删--改--查&quot;&gt;7.2 增 | 删 | 改 | 查&lt;/h2&gt;
&lt;h3 id=&quot;721-增加数据&quot;&gt;7.2.1 增加数据&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;(py369) [root@localhost devops]# python manage.py shell

In [1]: from hello.models import Devices
# 实例化对象    
In [4]: D = Devices.objects.all()
In [5]: D
# 暂时还没有数据，为空    
Out[5]: &amp;lt;QuerySet []&amp;gt;  
In [7]: data = {'device_name':'test-sw-01', 'ip':'192.168.1.1', 'vendor':'cisco','device_type':'switch','model':'c3850','sn':'001','os':'ios','version':'15.0'}
# 第一种创建方式(最常用)
In [8]: D.create(**data)
Out[8]: &amp;lt;Devices: test-sw-01&amp;gt;

# 第二种创建方式(防止重复，速度相对较慢)：
# 返回一个元组（对象，True或False）
In [10]: data2 = {'device_name':'test-sw-02', 'ip':'192.168.1.2', 'vendor':'cisco','device_type':'switch','model':'c3850','sn':'001','os':'ios','version':'15.0'}
In [14]: D.get_or_create(**data2)
Out[14]: (&amp;lt;Devices: test-sw-02&amp;gt;, True)
In [16]: D
Out[16]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-01&amp;gt;, &amp;lt;Devices: test-sw-02&amp;gt;]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;722-删除删除&quot;&gt;7.2.2 删除删除&lt;/h3&gt;
&lt;p&gt;数据库表中的数据（偷偷增加了一台设备）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005928459-696356643.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;In [1]: from hello.models import Devices
# 删除一条记录
 # 第一种方法：get
In [4]: D = Devices.objects.get(device_name = 'test-sw-02')
In [5]: D.delete()
Out[5]: (1, {'hello.Devices': 1})
 # 第二种方法：filter
In [2]: Devices.objects.filter(device_name='test-sw-03').delete()
Out[2]: (1, {'hello.Devices': 1})

# 先还原数据，再删除所有的记录
In [5]: Devices.objects.all().delete()
Out[5]: (3, {'hello.Devices': 3})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;723-修改数据&quot;&gt;7.2.3 修改数据&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 第一种方法：
In [2]: D = Devices.objects.get(device_name='test-sw-03')
In [3]: D.device_name = 'test-sw-13'
In [4]: D.save()
In [5]: Devices.objects.all()
Out[5]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-01&amp;gt;, &amp;lt;Devices: test-sw-02&amp;gt;, &amp;lt;Devices: test-sw-13&amp;gt;]&amp;gt;

# 第二种方法：
# 指定字段更新，偷偷去看下后台的ID是多少
In [6]: Devices.objects.filter(id=11)
Out[6]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-13&amp;gt;]&amp;gt;
In [7]: Devices.objects.filter(id=11).update(device_name='test-sw-03')
Out[7]: 1    
In [8]: Devices.objects.get(device_name='test-sw-03')
Out[8]: &amp;lt;Devices: test-sw-03&amp;gt;
        
# 多个字段更新
In [26]: data = {'vendor':'huawei','device_type':'switch','model':'S9303','sn':'001','os':'VRP'}
In [27]: Devices.objects.filter(id=11).update(**data)
Out[27]: 1

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终效果如下(通过数据库查询)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005928649-1457222657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;724-查看数据&quot;&gt;7.2.4 查看数据&lt;/h3&gt;
&lt;ul readability=&quot;22.5&quot;&gt;&lt;li readability=&quot;19&quot;&gt;
&lt;p&gt;查询多条数据&lt;/p&gt;
&lt;p&gt;列表嵌套一个字典(QuerySet对象)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 查询所有
In [30]: D = Devices.objects.all()
In [31]: D
Out[31]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-01&amp;gt;, &amp;lt;Devices: test-sw-02&amp;gt;, &amp;lt;Devices: test-sw-03&amp;gt;]&amp;gt;
# 每个对象及对象的属性
In [32]: D[0]
Out[32]: &amp;lt;Devices: test-sw-01&amp;gt;
In [33]: D[0].device_name
Out[33]: 'test-sw-01'
# 切片，不支持负索引
In [34]: D[:2]
Out[34]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-01&amp;gt;, &amp;lt;Devices: test-sw-02&amp;gt;]&amp;gt;
# 遍历
In [36]: for d in D:
        ...:     print(d.device_name)
        ...:
test-sw-01
test-sw-02
test-sw-03
# 返回指定的字段（values_list 和 values）
In [37]: D.values_list('device_name','ip')
Out[37]: &amp;lt;QuerySet [('test-sw-01', '192.168.1.1'), ('test-sw-02', '192.168.1.2'), ('test-sw-03',                       '192.168.1.3')]&amp;gt;
        
In [39]: D.values('device_name','vendor')
Out[39]: &amp;lt;QuerySet [{'device_name': 'test-sw-01', 'vendor': 'cisco'}, {'device_name': 'test-sw-02', 'vendor': 'cisco'}, {'device_name': 'test-sw-03', 'vendor': 'huawei'}]&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;26&quot;&gt;
&lt;p&gt;查询一条数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 第一种方法：
In [2]: D = Devices.objects.get(device_name='test-sw-01')
In [3]: D
# 返回的是一个对象
Out[3]: &amp;lt;Devices: test-sw-01&amp;gt;
# 取对象的属性值
In [4]: D.device_name
Out[4]: 'test-sw-01'
In [5]: D.vendor
Out[5]: 'cisco

# 第二种方法：
In [6]: data = {'device_name':'test-sw-01'}
In [7]: D = Devices.objects.get(**data)
In [8]: D.device_name
Out[8]: 'test-sw-01'

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;过滤查询&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;In [9]: Devices.objects.filter(device_name='test-sw-01')
Out[9]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-01&amp;gt;]&amp;gt;
In [11]: Devices.objects.filter(**data)
Out[11]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-01&amp;gt;]&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;过滤常用方法：&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 不区分大小写：&amp;lt;属性值&amp;gt;__iexact
In [16]: Devices.objects.filter(device_name__iexact='test-sw-01')
Out[16]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-01&amp;gt;]&amp;gt;

# 包含匹配：&amp;lt;属性值&amp;gt;__contains
In [17]: Devices.objects.filter(device_name__contains='sw')
Out[17]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-01&amp;gt;, &amp;lt;Devices: test-sw-02&amp;gt;, &amp;lt;Devices: test-sw-03&amp;gt;]&amp;gt;
# 模糊匹配，不分区大小写：&amp;lt;属性值&amp;gt;__icontains
In [18]: Devices.objects.filter(device_name__icontains='sw')
Out[18]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-01&amp;gt;, &amp;lt;Devices: test-sw-02&amp;gt;, &amp;lt;Devices: test-sw-03&amp;gt;]&amp;gt;

# 正则模糊匹配:&amp;lt;属性值&amp;gt;__regex
In [20]: Devices.objects.filter(device_name__regex='-03$')
Out[20]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-03&amp;gt;]&amp;gt;
# 正则模糊匹配,不区分大小写:&amp;lt;属性值&amp;gt;__regex
In [21]: Devices.objects.filter(device_name__iregex='^test')
Out[21]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-01&amp;gt;, &amp;lt;Devices: test-sw-02&amp;gt;, &amp;lt;Devices: test-sw-03&amp;gt;]&amp;gt;

# 排除过滤：&amp;lt;属性值&amp;gt;__contains
In [22]: Devices.objects.exclude(device_name__contains='test-sw-01')
Out[22]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-02&amp;gt;, &amp;lt;Devices: test-sw-03&amp;gt;]&amp;gt;
# 包含带有sw的device_name,但排除了vendor是cisco厂商的
In [23]: Devices.objects.filter(device_name__contains='sw').exclude(vendor='cisco')
Out[23]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-03&amp;gt;]&amp;gt;

# filter其他常用过滤查询方法
__exact：精确匹配
__iexact：精确匹配,忽略大小写
__gt：大于
__gte：大于等于
__lt：小于
__lte：小于等于
__in：在一个list列表范围内
__startswith：以...开头
__startswith：以...开头，忽略大小写
__endswith：以...结尾
__range：在...范围内
__year：日期的年份
__month：日期的月份
__day：日期的日数
__isnull=True/False：字段是否为空

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;filter&lt;/code&gt;的区别：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt; # 都可以获取到指定的对象；
 # get是获取唯一数据的场景，数据不存在会报错；
 # filter适用于任何场景，返回是一个QuerySet对象，数据不存在则返回是空的对象。
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;排序查询&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 正序
In [32]: Devices.objects.all().order_by('device_name')
Out[32]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-01&amp;gt;, &amp;lt;Devices: test-sw-02&amp;gt;, &amp;lt;Devices: test-sw-03&amp;gt;]&amp;gt;
# 倒序，前面加
In [33]: Devices.objects.all().order_by('-device_name')
Out[33]: &amp;lt;QuerySet [&amp;lt;Devices: test-sw-03&amp;gt;, &amp;lt;Devices: test-sw-02&amp;gt;, &amp;lt;Devices: test-sw-01&amp;gt;]&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;81-创建模型&quot;&gt;8.1 创建模型&lt;/h2&gt;
&lt;p&gt;参见以上的&lt;code&gt;hello/models.py&lt;/code&gt;的配置。&lt;/p&gt;
&lt;h2 id=&quot;82-创建视图view&quot;&gt;8.2 创建视图view&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.shortcuts import render
from hello.models import Devices

def devicelist(request):
    # 对象实例化
    devices = Devices.objects.all()
    # {'devices':devices}表示传参
    return render(request, 'hello/device.html', {'devices':devices})
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;83-创建模板&quot;&gt;8.3 创建模板&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-HTML&quot;&gt;&amp;lt;!--继承母版--&amp;gt;
{% extends &quot;base.html&quot; %}

&amp;lt;!--重写title的内容--&amp;gt;
{% block title %}设备列表{% endblock %}

&amp;lt;!--重写body的内容--&amp;gt;
{% block body %}
&amp;lt;p style=&quot;background-color: #77ee77&quot;&amp;gt;设备列表&amp;lt;/p&amp;gt;
&amp;lt;!--表格--&amp;gt;
&amp;lt;table border=&quot;1&quot;&amp;gt;
&amp;lt;!--    表头--&amp;gt;
    &amp;lt;thead style=&quot;background-color: #00aced&quot; &amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt;设备名称&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;IP地址&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;厂商&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;设备类型&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;型号&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;序列号&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;操作系统&amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt;版本号&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/thead&amp;gt;
&amp;lt;!--表的正文--&amp;gt;
    &amp;lt;tbody&amp;gt;
        {% for device in devices %}
        &amp;lt;tr&amp;gt;
            &amp;lt;td&amp;gt; {{ device.device_name }} &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt; {{ device.ip }} &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt; {{ device.vendor }} &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt; {{ device.device_type }} &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt; {{ device.model }} &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt; {{ device.sn }} &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt; {{ device.os }} &amp;lt;/td&amp;gt;
            &amp;lt;td&amp;gt; {{ device.version }} &amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
        {% endfor %}
    &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;

{% endblock%}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;84-创建路由视图url&quot;&gt;8.4 创建路由视图URL&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;from django.urls import path
from hello import view

app_name = 'hello'
urlpatterns = [
    path('devicelist', view.devicelist, name='devicelist'),
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;85-效果图如下：&quot;&gt;8.5 效果图如下：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005929083-336662265.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大家先不要在意前端效果，后面的项目，再把&lt;code&gt;UI&lt;/code&gt;这块优化好，先到这里了，大家学会了吗？&lt;/p&gt;
&lt;p&gt;好不容易码完这篇了，大家点个赞吧！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;如果喜欢的我的文章，欢迎关注我的公众号：点滴技术，扫码关注，不定期分享&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1813756/202011/1813756-20201104005929501-1148151201.jpg&quot; alt=&quot;公众号：点滴技术&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 03 Nov 2020 16:59:00 +0000</pubDate>
<dc:creator>Singvis</dc:creator>
<og:description>Hello, 各位，我回来了，大家别以为我消失了，我还是在的... 最近忙于家里重要事情，不能定期及时更新，请包含... 忙里挑一，我还是在后台默默的码了几篇文章，前提要保证下质量，才能发出来，哈哈！</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/singvis/p/13923631.html</dc:identifier>
</item>
<item>
<title>Lock接口之Condition接口 - 彼岸舞</title>
<link>http://www.cnblogs.com/flower-dance/p/13923528.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flower-dance/p/13923528.html</guid>
<description>&lt;p&gt;之前在写显示锁的是后,在显示锁的接口中,提到了new Condition这个方法,这个方法会返回一个Condition对象&lt;/p&gt;
&lt;p&gt;简单介绍一下&lt;/p&gt;
&lt;h2&gt;Condition接口:&lt;/h2&gt;
&lt;p&gt;　　任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。之前写过一篇&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2 vertical-middle&quot; href=&quot;https://www.cnblogs.com/flower-dance/p/13678742.html&quot;&gt;线程之间的协作(等待通知模式)&lt;/a&gt;是使用Object的wait和notify/notifyAll+Synchronized写的&lt;/p&gt;
&lt;p&gt;　　换而言之，synchronized关键字想要实现等待/通知模式，需要调用以上的四种方法。&lt;/p&gt;
&lt;p&gt;　　然后我们的Condition接口也提供了能够实现等待/通知模式，是与Lock配合实现的。&lt;/p&gt;
&lt;p&gt;　　我感觉这个Condition和那个差不多,也是用来完成线程之间的协作的&lt;/p&gt;
&lt;p&gt;　　但是二者在使用方式上以及功能特性上还是有所差别的。&lt;/p&gt;
&lt;h2&gt;Object对比Condition:&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1979837/202011/1979837-20201103232822652-1191100440.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 由此表可以看出，condition接口可以有多个等待队列，而object监视器方法只有一个队列，而且还不支持在等待状态响应中断，还不支持当前线程释放锁并进入等待状态到将来的某个时间。&lt;/p&gt;
&lt;h2&gt;示例:&lt;/h2&gt;
&lt;p&gt;　　也不打算写新的示例了,用这个Condition接口改造一下之前使用等待通知模式的那个案例吧&lt;/p&gt;
&lt;p&gt;　　Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的。其实就是，Condition是依赖Lock对象的。就像使用wait/notify需要依赖Synchronized锁一样,Condition的使用方式比较简单，需要注意在调用方法前获取锁&lt;/p&gt;
&lt;p&gt;创建等待通知类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day4.condition;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Condition;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.Lock;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantLock;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 类说明：使用Condition接口实现等待通知模式
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ExpressCond {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; String CITY = &quot;ShangHai&quot;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 快递运输里程数
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; km;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 快递到达地点
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String site;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 创建显示锁
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Lock lock = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantLock();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 检测城市变化
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Condition siteCond =&lt;span&gt; lock.newCondition();

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 检测公里数变化
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Condition kmCond =&lt;span&gt; lock.newCondition();

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; ExpressCond() {
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ExpressCond(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; km, String site) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.km =&lt;span&gt; km;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.site =&lt;span&gt; site;
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 变化公里数，然后通知处于wait状态并需要处理公里数的线程进行业务处理&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeKm() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取锁&lt;/span&gt;
&lt;span&gt;        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.km = 101&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒在kmCond 上 等待的线程&lt;/span&gt;
&lt;span&gt;            kmCond.signal();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 变化地点，然后通知处于wait状态并需要处理地点的线程进行业务处理&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; changeSite() {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取锁&lt;/span&gt;
&lt;span&gt;        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.site = &quot;BeiJing&quot;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 唤醒在siteCond 上 等待的线程&lt;/span&gt;
&lt;span&gt;            siteCond.signal();
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;当快递的里程数大于100时更新数据库&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; waitKm() {
        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.km &amp;lt;= 100&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    kmCond.await();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 处理线程中断&lt;/span&gt;
&lt;span&gt;                    Thread.currentThread().interrupt();
                    e.printStackTrace();
                }
                System.out.println(&lt;/span&gt;&quot;check km thread[&quot; +&lt;span&gt; Thread.currentThread().getId()
                        &lt;/span&gt;+ &quot;] is be notifed.&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
        System.out.println(&lt;/span&gt;&quot;the Km is &quot; + &lt;span&gt;this&lt;/span&gt;.km + &quot;,I will change db&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;当快递到达目的地时通知用户&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; waitSite() {
        lock.lock();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (CITY.equals(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.site)) {
                &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
                    siteCond.await();
                } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(&lt;/span&gt;&quot;check site thread[&quot; +&lt;span&gt; Thread.currentThread().getId()
                        &lt;/span&gt;+ &quot;] is be notifed.&quot;&lt;span&gt;);
            }
        } &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
            lock.unlock();
        }
        System.out.println(&lt;/span&gt;&quot;the site is &quot; + &lt;span&gt;this&lt;/span&gt;.site + &quot;,I will call user&quot;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过代码可以看见,我们一个锁,是可以携带多个等待队列的&lt;/p&gt;
&lt;p&gt;创建测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.dance.day4.condition;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *类说明：测试Lock和Condition实现等待通知
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestCond {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; ExpressCond express = &lt;span&gt;new&lt;/span&gt; ExpressCond(0&lt;span&gt;,ExpressCond.CITY);

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;检查里程数变化的线程,不满足条件，线程一直等待&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CheckKm &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            express.waitKm();
        }
    }

    &lt;/span&gt;&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;检查地点变化的线程,不满足条件，线程一直等待&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CheckSite &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Thread{
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
            express.waitSite();
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;3;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CheckSite().start();
        }
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i=0;i&amp;lt;3;i++&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; CheckKm().start();
        }

        Thread.sleep(&lt;/span&gt;1000&lt;span&gt;);
        express.changeKm();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;快递里程变化&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
check km thread[14&lt;span&gt;] is be notifed.
the Km is &lt;/span&gt;101,I will change db
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过执行结果,我们可以清晰的看到,他是直接唤醒了,在公里数变化上等待的线程的,在之前的等待通知模式中,也就是wait/notify/notifyAll+Sync实现的等待通知模式中,推荐大家使用notifyAll()来唤醒正在等待中的线程,但是在使用Condition接口中,推荐大家使用signal,而不是signalAll().为啥呢?因为wait/notify/notifyAll是Object的方法,在指定的对象中等待的可能是多个线程,分别在检测不同的变量,可能造成信号的拦截,所以推荐使用全部唤醒,,但是在使用Condition上却不是,因为他是多个等待队列,他清晰的知道自己应该唤醒那个线程,所以推荐使用signal,至于Condition的实现分析暂时先不写,等写完AQS再写方便,大家理解,我感觉不是所有相关的知识都要堆在一起,要是理解不了,再深入也没用&lt;/p&gt;
&lt;p&gt;作者：彼岸舞&lt;/p&gt;
&lt;p&gt;时间：2020\11\04&lt;/p&gt;
&lt;p&gt;内容关于：并发编程&lt;/p&gt;
&lt;p&gt;本文来源于网络，只做技术分享，一概不负任何责任&lt;/p&gt;
</description>
<pubDate>Tue, 03 Nov 2020 16:18:00 +0000</pubDate>
<dc:creator>彼岸舞</dc:creator>
<og:description>之前在写显示锁的是后,在显示锁的接口中,提到了new Condition这个方法,这个方法会返回一个Condition对象 简单介绍一下 Condition接口: 任意一个Java对象，都拥有一组监视</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flower-dance/p/13923528.html</dc:identifier>
</item>
<item>
<title>【面经】面试官：做过性能优化的工作吗？你会从哪些方面入手做性能优化呢？ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13923433.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13923433.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;随着互联网的高速发展，互联网行业已经从IT时代慢慢步入到DT时代。对于Java程序员的要求越来越高，只是单纯的掌握CRUD以不足以胜任互联网公司的相关职位，大量招聘岗位显示：如果是面试中高级的Java岗，基本上都需要懂性能优化的相关知识。今天，我们就一起来聊聊一个经典的面试题：做过性能优化的工作吗？你会从哪些方面入手做性能优化呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;问题分析&lt;/h2&gt;
&lt;p&gt;标题中问出了两个问题，一个是有没有做过性能优化的工作，一个是从哪些方面入手做性能优化。对于第一个问题，我们可以直接回答有或者没有。相信小伙伴们都希望自己做过性能优化的工作，如果是回答做过，那第二个问题，我们又该如何回答呢？&lt;/p&gt;
&lt;p&gt;首先，对于第二个问题来说，问的是会从哪些方面入手。这个问题就没有固定答案了。你可以按照你以往的经验来回答这个问题，但是，在回答这个问题之前，需要先好好梳理下你的思路，将你要表达的说清楚。&lt;/p&gt;
&lt;p&gt;接下来，我们就一起来聊聊第二个问题：你会从哪些方面入手做性能优化？&lt;/p&gt;
&lt;p&gt;我们可以从性能优化的几个方面来进行回答。下面，我们就来聊聊性能优化可以从哪些方面进行。&lt;/p&gt;
&lt;h2 id=&quot;性能优化有哪些方面？&quot;&gt;性能优化有哪些方面？&lt;/h2&gt;
&lt;p&gt;这里，我结合平时工作中的总结，将性能优化总结为下面这张图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20201103003704366.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也就是说，我们可以从数据聚合优化、资源冲突优化、算法优化、JVM优化、复用优化、计算优化和快速实现等方面来进行回答。接下来，我们就针对每个点进行说明。&lt;/p&gt;
&lt;h3 id=&quot;数据聚合优化&quot;&gt;数据聚合优化&lt;/h3&gt;
&lt;p&gt;数据聚合优化主要针对的是对于数据的整合和传输的优化。比如：我们从数据库中查询出的数据，经过程序的聚合处理后再返回给客户端，而不用客户端调用多次接口来分别获取数据。&lt;/p&gt;
&lt;p&gt;再比如：我们在项目中使用的Nginx，一般都会开启GZIP压缩，使传输的数据更加紧凑，同时，使传输的数据量更小。&lt;/p&gt;
&lt;p&gt;细心的小伙伴会发现，我们对于数据聚合的优化，主要是使传输的数据量更小。所以，我们在使用SQL语句查询数据库中的数据时，尽量查询那些需要的字段，对于不需要的字段就直接忽略不查询了，避免在SQL语句中出现select *&lt;/p&gt;
&lt;h3 id=&quot;资源冲突优化&quot;&gt;资源冲突优化&lt;/h3&gt;
&lt;p&gt;在我们平时的工作中，尤其是在高并发的场景下，经常会出现锁冲突的问题，锁冲突是资源冲突的一个典型场景。&lt;/p&gt;
&lt;p&gt;关于锁我们可以联想到数据库的行锁、表锁、Java中的synchronized和Lock等。如果对应到操作系统级别，则会有CPU命令级别的锁，JVM指令级别的锁，操作系统的内部锁等。&lt;/p&gt;
&lt;p&gt;这里，小伙伴们需要注意一点：只有在并发的场景下，才会出现资源冲突的问题。也就是说：在同一时刻，只能有一个请求获取到请求资源，解决冲突的方式就是加锁。&lt;/p&gt;
&lt;p&gt;我们需要在平时的工作过程中避免锁冲突的问题，优化如何优化加锁方式，小伙伴们可以参见《&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MzE1NTIzNA==&amp;amp;mid=2247488569&amp;amp;idx=1&amp;amp;sn=b9e1e60bee2166e3043695a9198b67d1&amp;amp;chksm=cee50bf4f99282e2eb7b69196eebf65d02260cdc151cd3aa7d639abb0afa9bcf30dd6e485939&amp;amp;token=537906095&amp;amp;lang=zh_CN#rd&quot;&gt;【高并发】面试官：讲讲高并发场景下如何优化加锁方式？&lt;/a&gt;》一文。&lt;/p&gt;
&lt;h3 id=&quot;算法优化&quot;&gt;算法优化&lt;/h3&gt;
&lt;p&gt;在一个大型的互联网项目中，往往涉及到分布式和微服务等技术，其中，也会使用到大量的数据结构和算法，对于算法的优化能够显著的提高系统的性能。一个好的实现，相比于一个拙劣的实现来说，在系统性能的提升上存在着巨大的差异。&lt;/p&gt;
&lt;p&gt;比如，作为 List 的实现，LinkedList 和 ArrayList 在随机访问的性能上，差了好几个数量级；又比如，CopyOnWriteList 采用写时复制的方式，可以显著降低读多写少场景下的锁冲突。而什么时候使用同步，什么时候是线程安全的，也对我们的编码能力有较高的要求。&lt;/p&gt;
&lt;p&gt;所以，我们需要在平时工作过程中，多多积累数据结构和算法的相关知识。&lt;/p&gt;
&lt;h3 id=&quot;jvm优化&quot;&gt;JVM优化&lt;/h3&gt;
&lt;p&gt;JVM调优，不用说，这是每个Java工程师必须要掌握的标准技能。所有的Java程序最终都是运行在JVM中的，对JVM进行优化也能够提升Java程序的性能。但是，需要注意的是：如果在优化JVM时，参数设置不当，可能会造成内存溢出等严重的问题。&lt;/p&gt;
&lt;p&gt;目前被广泛使用的垃圾回收器是 G1，通过很少的参数配置，内存即可高效回收。CMS 垃圾回收器已经在 Java 14 中被移除，由于它的 GC 时间不可控，有条件应该尽量避免使用。&lt;/p&gt;
&lt;h3 id=&quot;复用优化&quot;&gt;复用优化&lt;/h3&gt;
&lt;p&gt;复用优化，这个看名字就知道，说白了就是可以重复利用。估计很多小伙伴都有这样的经验，在写代码的时候，可以将很多重复的代码抽象出来，做成公共的方法。这样，就不用每次都去写重复的逻辑代码了。这是代码层面的复用。&lt;/p&gt;
&lt;p&gt;如果是数据层面的话，我们可以使用缓冲和缓存来复用数据。&lt;/p&gt;
&lt;p&gt;这里，小伙伴们需要注意一个知识点：缓冲主要针对的是写操作，缓存主要针对的是读操作。&lt;/p&gt;
&lt;p&gt;另一个复用优化的典型场景就是池化技术，比如：数据库连接池、线程池等。&lt;/p&gt;
&lt;h3 id=&quot;计算优化&quot;&gt;计算优化&lt;/h3&gt;
&lt;p&gt;对于计算优化来说，我们可以从以下几个小的方面来阐述。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并行计算&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不难理解，就是多个计算同时进行。这里，又可以将并行计算分为：多机并行计算、多进程并行计算和多线程并行计算。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多机并行计算：&lt;/strong&gt; 将一个大的计算任务，拆分成N个小的计算任务，分发到不同的机器进行处理。典型的场景就是Hadoop的MapReduce极端。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多进程计算：&lt;/strong&gt; 比如，Nginx采用的NIO模型，采用的是进程调度的策略，由Master进程调度Worker进程，Worker进行来处理具体的请求。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多线程计算&lt;/strong&gt;： 对于多线程计算来说，也是我们平时接触最多的一种计算方式，我们可以使用多线程技术，将复杂的逻辑计算拆分成一个个小的计算任务，分发到不同的线程中去执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步变异步&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步和异步的区别就是：同步需要等待返回结果，异步不需要等待返回结果。如果我们在业务程序中，不需要等待返回结果数据，则我们可以将同步调用优化为异步调用，从而提升我们系统的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;懒加载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最典型的场景就是Spring中的懒加载，只有第一次获取bean的时候，才会创建bean实例。&lt;/p&gt;
&lt;h3 id=&quot;快速实现&quot;&gt;快速实现&lt;/h3&gt;
&lt;p&gt;对于快速实现来说，不仅包含我们需要利用相关的程序框架迅速开发出我们想要的业务，也需要我们在进行技术选型时，尽量使用一些性能优良的组件。比如，在进行网络开发时，尽量选择Netty，结合轻量级的数据传输，就不要使用WebService等技术了。&lt;/p&gt;
&lt;p&gt;很多公司喜欢使用适配器模式，在一些现有的开源组件之上，再抽象一层自己的组件，这样就能够做到切换底层组件的时候，对上层应用无感。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好了，今天我们就到这儿吧，我是冰河，我们下期见！！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;重磅福利&quot;&gt;重磅福利&lt;/h2&gt;
&lt;p&gt;微信搜一搜【冰河技术】微信公众号，关注这个有深度的程序员，每天阅读超硬核技术干货，公众号内回复【PDF】有我准备的一线大厂面试资料和我原创的超硬核PDF技术文档，以及我为大家精心准备的多套简历模板（不断更新中），希望大家都能找到心仪的工作，学习是一条时而郁郁寡欢，时而开怀大笑的路，加油。如果你通过努力成功进入到了心仪的公司，一定不要懈怠放松，职场成长和新技术学习一样，不进则退。如果有幸我们江湖再见！&lt;/p&gt;
&lt;p&gt;另外，我开源的各个PDF，后续我都会持续更新和维护，感谢大家长期以来对冰河的支持！！&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 03 Nov 2020 15:52:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 随着互联网的高速发展，互联网行业已经从IT时代慢慢步入到DT时代。对于Java程序员的要求越来越高，只是单纯的掌握CRUD以不足以胜任互联网公司的相关职位，大量招聘岗位显示：如果是面试中高级</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13923433.html</dc:identifier>
</item>
<item>
<title>.NET Core如何进行请求转发？ - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/13923371.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/13923371.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;冒个泡，近日，有关注我公众号的小伙伴私信我，遇到一个问题搞了很久没解决，此问题具有参考意义，这里跟大家分享下，希望对后续可能有需要的你能有所参考和帮助。&lt;/p&gt;
&lt;h2&gt;请求转发问题&lt;/h2&gt;
&lt;p&gt;内网环境跟外网隔离，现在外网的请求都需要一个专用服务器转接到内网处理，用app.UseRewriter转接， 从外网服务器转发到内网服务器的时候Header 里面的Authorization 居然丢失了，重新设置RewriteContext.HttpContex Header也不行，有没有办法解决？当时我的想法是，实在不行，在外网将token直接放到url或body里不就完事，这样的话，外网每增加一个接口，都得将token取出然后进行转换，内网以相同方式获取，这是小伙伴所不能忍受。这里我们创建两个Web应用程序，然后添加自定义转发规则。首先我们在第一个Web应用程序创建针对如下接口请求转发规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RewriteForwardRules
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; RedirectRequests(RewriteContext context)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; request =&lt;span&gt; context.HttpContext.Request;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request.Path.Value.StartsWith(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/forward&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, StringComparison.OrdinalIgnoreCase))
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; response =&lt;span&gt; context.HttpContext.Response;

            response.Headers[HeaderNames.Location] &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:8091/api/custom&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

            context.Result &lt;/span&gt;=&lt;span&gt; RuleResult.EndResponse;
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在startup中注入我们自定义转发规则&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
app.UseRewriter(&lt;span&gt;new&lt;/span&gt; RewriteOptions().Add(RewriteForwardRules.RedirectRequests));
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当然，如果URL(GET请求)或Body(POST请求)中包含其他参数，将其对应转发写入URL或Body即可，这里token已存储在请求头中，所以我们直接转发请求即可。接下来我们通过Postman模拟外网发出如下POST请求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202011/589642-20201103233329644-181421746.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;紧接着，我们在第二个Web应用程序中来接收转发请求，并获取token信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[HttpPost]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Custom()
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; token =&lt;span&gt; Request.Headers[HeaderNames.Authorization].ToString();

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(token);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们一运行，发现结果都没转发到对应内网应用程序，这是为何呢？事实上，转发请求涉及到资源重分配指向另一URL问题，当然我们需要注意的是，既然是转发请求，势必转发者和接受者请求方式必须一致，要不然肯定不行。所以我们必须显式指定重定向状态码，设置为308，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202011/589642-20201103233509737-1761497052.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/589642/202011/589642-20201103233609558-1533791818.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;针对状态码308的意思，我们可以参看.NET Core中对于状态码枚举解释：&lt;span&gt;永久重定向，原始请求方式和目标请求方式必须一致，支持原始请求和目标请求同为GET或POST。&lt;/span&gt;.NET Core中关于此状态码的解释并不那么详细，我们来到专对状态码官方解释（&lt;a title=&quot;https://httpstatuses.com/308&quot; href=&quot;https://httpstatuses.com/308&quot; target=&quot;_blank&quot;&gt;https://httpstatuses.com/308&lt;/a&gt;），这里我贴下谷歌翻译后的中文：308永久重定向：已为目标资源分配了一个新的永久URI，以后对该资源的任何引用都应使用其中一个URI。具有链接编辑功能的客户端应在可能的情况下自动将对有效请求URI 1的引用重新链接到服务器发送的一个或多个新引用。服务器应在响应中生成一个Location头字段，其中包含新的永久URI的首选URI引用。用户代理可以使用位置字段值进行自动重定向。服务器的响应有效负载通常包含简短的超文本注释，其中包含指向新URI的超链接。默认情况下，308响应可缓存；即，除非方法定义或显式缓存控制。&lt;/p&gt;

&lt;p&gt;当然，我们也可以设置状态码为301，301永久移动：已为目标资源分配了一个新的永久URI，以后对该资源的任何引用都应使用其中一个URI。那么状态码301和308到底有何区别呢？&lt;span&gt;301类似308永久移动，只不过，301不允许将请求方法从GET更改为POST。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;💡 请求转发时注意设置状态码为301或308&lt;/p&gt;
&lt;p&gt;💡 301类似308永久移动，只不过，301不允许将请求方法从GET更改为POST&lt;/p&gt;
&lt;p&gt;💡 基于以上所述，请求转发推荐使用状态码308&lt;/p&gt;
</description>
<pubDate>Tue, 03 Nov 2020 15:46:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 冒个泡，近日，有关注我公众号的小伙伴私信我，遇到一个问题搞了很久没解决，此问题具有参考意义，这里跟大家分享下，希望对后续可能有需要的你能有所参考和帮助。 请求转发问题 内网环境跟外网隔离，现在外</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/13923371.html</dc:identifier>
</item>
<item>
<title>Linux杂谈：进程锁核+实时线程导致的读写锁死循环 - TpCode</title>
<link>http://www.cnblogs.com/tp1226/p/13923402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tp1226/p/13923402.html</guid>
<description>&lt;h2&gt;发现问题   &lt;/h2&gt;
&lt;p&gt;    公司项目测试的时候，发现运行一段时间后会出现cpu百分之百的情况。&lt;/p&gt;
&lt;p&gt;    想着可能是哪里出现了死循环，于是打算用gdb跟一下，结果gdb居然无法attach到进程。。。。。。&lt;/p&gt;

&lt;h2&gt;定位问题&lt;/h2&gt;
&lt;p&gt;    查了查去，原来有一个优先级为RT的实时线程出现了死循环，并且由于配置了CPU的亲和属性，使得进程只运行在第一个核上，此时gdb就无法attach了&lt;/p&gt;
&lt;p&gt;    使用taskset现场修改进程的cpu亲和属性后，发现这个占cpu百分百的实时线程并没有出现一般的死循环，而是每次都在pthread_rwlock_wrlock这个函数中，&lt;/p&gt;
&lt;p&gt;    而更诡异的是，只要修改了cpu亲和属性，就没有“死循环了”。。。。。。&lt;/p&gt;

&lt;h2&gt;实验&lt;/h2&gt;
&lt;p&gt;    于是写了一段实验代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; _GNU_SOURCE
&lt;span&gt; 2&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdio.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stdlib.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unistd.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; #include &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;pthread.h&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;sched.h&amp;gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;pthread_rwlock_t rwlock;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* task1(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     pthread_setname_np(pthread_self(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    {   
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n task1 lock \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         pthread_rwlock_wrlock(&amp;amp;&lt;span&gt;rwlock);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n task1 unlock \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         pthread_rwlock_unlock(&amp;amp;&lt;span&gt;rwlock);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         usleep(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;    }   
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;* task2(&lt;span&gt;void&lt;/span&gt; *&lt;span&gt;arg)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; sched_param sparam;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     pthread_setname_np(pthread_self(), &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;task2&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置为最高优先级的实时任务 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     sparam.sched_priority =&lt;span&gt; sched_get_priority_max(SCHED_RR);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     pthread_setschedparam(pthread_self(), SCHED_RR, &amp;amp;&lt;span&gt;sparam);
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(&lt;span&gt;1&lt;/span&gt;)
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    {   
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n task2 lock \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         pthread_rwlock_wrlock(&amp;amp;&lt;span&gt;rwlock);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt;         printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\r\n task2 unlock \r\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         pthread_rwlock_unlock(&amp;amp;&lt;span&gt;rwlock);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; 
&lt;span&gt;44&lt;/span&gt;         usleep(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }   
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; main(&lt;span&gt;int&lt;/span&gt; argc, &lt;span&gt;char&lt;/span&gt; *&lt;span&gt;argv[])
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    pthread_t t1, t2, t3; 
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;    cpu_set_t cpuset;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 设置cpu亲和属性，将进程绑定在第一个核上 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;     CPU_ZERO(&amp;amp;&lt;span&gt;cpuset);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;     CPU_SET(&lt;span&gt;0&lt;/span&gt;, &amp;amp;&lt;span&gt;cpuset);
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;     sched_setaffinity(&lt;span&gt;0&lt;/span&gt;, &lt;span&gt;sizeof&lt;/span&gt;(cpuset), &amp;amp;&lt;span&gt;cpuset);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;     pthread_rwlock_init(&amp;amp;&lt;span&gt;rwlock, NULL);
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     pthread_create(&amp;amp;&lt;span&gt;t2, NULL, task1, NULL);
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     sleep(&lt;span&gt;3&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     pthread_create(&amp;amp;&lt;span&gt;t3, NULL, task2, NULL);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (&lt;span&gt;1&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         sleep(&lt;span&gt;10&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; 
&lt;span&gt;67&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;运行结果，如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1035445/202011/1035445-20201104082334151-1789845684.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;真的出现了CPU百分百的情况！！！&lt;/p&gt;

&lt;h2&gt;分析原因&lt;/h2&gt;
&lt;p&gt;1. 读写锁的“拿锁”和“放锁”操作并不是一个完整的原子操作，而是有可能操作到一半被调度出去；&lt;/p&gt;
&lt;p&gt;2. 此次实验结果显示，task1（非实时）在做unlock操作时，已经修改了一部分读写锁的属性，此时task2（实时）lock时，发现不需要再阻塞了，只需要自旋等待（死循环）task1将unlock操作做完；然而由于task2是实时任务，整个进程又只绑定到了第一个核上，task1无法得到调度，造成了task2的死循环。&lt;/p&gt;

</description>
<pubDate>Tue, 03 Nov 2020 15:44:00 +0000</pubDate>
<dc:creator>TpCode</dc:creator>
<og:description>发现问题 公司项目测试的时候，发现运行一段时间后会出现cpu百分之百的情况。 想着可能是哪里出现了死循环，于是打算用gdb跟一下，结果gdb居然无法attach到进程。。。。。。 定位问题 查了查去，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tp1226/p/13923402.html</dc:identifier>
</item>
</channel>
</rss>