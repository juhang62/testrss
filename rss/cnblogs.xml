<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>css布局之居中 - seanxushuo</title>
<link>http://www.cnblogs.com/seanxushuo/p/11397849.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/seanxushuo/p/11397849.html</guid>
<description>&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;本文主要是介绍水平居中，垂直居中，还有水平垂直居中的方法&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;https://user-images.githubusercontent.com/36322912/50374866-75bc1200-062f-11e9-8f19-e044ad460927.png&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;水平居中&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1.&lt;span&gt;&lt;strong&gt;行内元素水平居中&lt;/strong&gt; &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;使用text-align:center;就可以实现行内元素的水平居中，但是记得要在父元素中设置，会对子元素生效。此方法对，&lt;span&gt;&lt;strong&gt;inline、inline-block、inline-table、inline-flex&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;都有效。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.box{
  text-align:center;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;pre class=&quot;md-fences md-end-block ty-contain-cm modeLoaded&quot;&gt;
&lt;span&gt;此外，如果块级元素包着一个块级元素，&lt;/span&gt;&lt;span&gt;&lt;strong&gt;那么我们可以设置外部盒子text-align:center;给内部盒子设置display:inline-block;&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;这样也可以使得内部元素居中。但要注意的是，内部盒子已经设置了display:inline-block，就不可以再设置其他的display，&lt;strong&gt;所以最好不要使用这种方法。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;parent&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;div &lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;=&quot;child&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
  &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;div&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;
  .parent&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
  text-align&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;center&lt;/span&gt;&lt;span&gt;;&lt;/span&gt;
  &lt;span&gt;}&lt;/span&gt;&lt;span&gt;
  .child&lt;/span&gt;&lt;span&gt;{&lt;/span&gt;&lt;span&gt;
  display&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;inline-block
  &lt;/span&gt;&lt;span&gt;}&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;style&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2.&lt;span&gt;&lt;strong&gt;块级元素水平居中&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;使用margin居中&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;margin：0 auto;但是使用这种方法，要记得给元素设置宽度，否则不会生效&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;使用absolute+transform&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;&lt;strong&gt;absolute&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;定位，左 50%，然后使用&lt;span&gt;&lt;strong&gt;transform&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;向左移动50%；&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;3.&lt;span&gt;&lt;strong&gt;浮动元素水平居中&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.child{
  width:200px;
  float:left;
  position:relative;
  left:50%;
  margin:-100px;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul class=&quot;ul-list&quot; data-mark=&quot;-&quot; readability=&quot;2.5&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;11&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;未知宽度，父子元素都用相对定位&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.parent{
  float:left;
  postion:relative;
  left:50%;
}
.child{
  float:left;
  position:relative;
  right:50%;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;父元素相对于左定位50%；且因为，父元素的宽度是由子元素撑起来的，所以当子元素相对于自身右定位50%时，水平居中&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;示例&lt;/strong&gt; &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;&lt;strong&gt;当我们把child的定位取消时&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1746270/201908/1746270-20190823082831036-692311735.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span&gt;&lt;strong&gt;打开child的相对定位时&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1746270/201908/1746270-20190823082840049-471370488.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;4.&lt;span&gt;&lt;strong&gt;绝对定位元素水平居中&lt;/strong&gt; &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这种方式通过子元素的绝对定位，外加margin:0 auto;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.parent{
  position:relative;
}
.child{
  postion:absolute;
  width:100px;
  height:100px;
  background:red;
  margin:0 auto;
  left:0;
  right:0;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;垂直居中&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;1.&lt;span&gt;&lt;strong&gt;单行内联元素垂直居中&lt;/strong&gt; &lt;span class=&quot;md-softbreak&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这种方法适合对单行文本的垂直居中，比如应用在顶部菜单栏中&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.parent{
  height:100px;
  line-height:100px;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;2.&lt;span&gt;&lt;strong&gt;块级元素垂直居中&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;使用absolute+负margin&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.parent{
  position:relative;
}
.child{
  height:100px;
  position:absolute;
  top:50%;
  margin-top:-50px;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;使用absolute+tranform&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;.parent{
  position:relative;
}
.child{
  position:absolute;
  top:50%;
  transform:translateY(-50%);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;水平垂直居中&lt;/span&gt;&lt;/h3&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;可以参考上面的水平居中和垂直居中的方法，结合起来就可以了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Aug 2019 00:31:00 +0000</pubDate>
<dc:creator>seanxushuo</dc:creator>
<og:description>CSS布局之居中 本文主要是介绍水平居中，垂直居中，还有水平垂直居中的方法 水平居中 1.行内元素水平居中 使用text-align:center;就可以实现行内元素的水平居中，但是记得要在父元素中设</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/seanxushuo/p/11397849.html</dc:identifier>
</item>
<item>
<title>单点登录的原理 - 经典鸡翅</title>
<link>http://www.cnblogs.com/jichi/p/11396264.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jichi/p/11396264.html</guid>
<description>&lt;h3 id=&quot;一单点登录的概念&quot;&gt;一、单点登录的概念&lt;/h3&gt;
&lt;h4 id=&quot;什么是单点登陆&quot;&gt;1、什么是单点登陆&lt;/h4&gt;
&lt;p&gt;单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。&lt;/p&gt;
&lt;h4 id=&quot;单点登录的引入&quot;&gt;2、单点登录的引入&lt;/h4&gt;
&lt;p&gt;较大的企业内部，一般都有很多的业务支持系统为其提供相应的管理和IT服 务。&lt;br/&gt;例如：&lt;br/&gt;财务系统为财务人员提供财务的管理、计算和报表服务；&lt;br/&gt;人事系统为人事部门提供全公司人员的维护服务；&lt;br/&gt;各种业务系统为公司内部不同的业务提供不同的 服务等等。&lt;br/&gt;这些系统的目的都是让计算机来进行复杂繁琐的计算工作，来替代人力的手工劳动，提高工作效率和质量。&lt;br/&gt;这些不同的系统往往是在不同的时期建设起来 的，运行在不同的平台上；也许是由不同厂商开发，使用了各种不同的技术和标准。&lt;/p&gt;
&lt;p&gt;如果举例说国内一著名的IT公司（名字隐去），内部共有60多个业务系统，这些系统包括两个不同版本的SAP的ERP系统，12个不同类型和版本的数据库系统，8个不同类型和版本的操作系统，以及使用了3种不同的防火墙技术，还有数十种互相不能兼容的协议和标准，这种情况其实非常普遍。每一个应用系统在运行了数年以后，都会成为不可替换的企业IT架构的一部分，如下图所示。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534147/201908/1534147-20190822190050327-1583313436.png&quot;/&gt;&lt;br/&gt;随 着企业的发展，业务系统的数量在不断的增加，老的系统却不能轻易的替换，这会带来很多的开销。其一是管理上的开销，需要维护的系统越来越多。&lt;br/&gt;很多系统的数 据是相互冗余和重复的，数据的不一致性会给管理工作带来很大的压力。&lt;br/&gt;业务和业务之间的相关性也越来越大，例如公司的计费系统和财务系统，财务系统和人事系 统之间都不可避免的有着密切的关系。&lt;br/&gt;为了降低管理的消耗，最大限度的重用已有投资的系统，很多企业都在进行着企业应用集成（EAI）。&lt;/p&gt;
&lt;p&gt;企业应用集成可以在不同层面上进行：&lt;br/&gt;例如：&lt;br/&gt;在数据存储层面上的“数据大集中”，&lt;br/&gt;在传输层面上的“通用数据交换平台”，&lt;br/&gt;在应用层面上的“业务流程整合”，&lt;br/&gt;和用 户界面上的“通用企业门户”等等。&lt;br/&gt;事实上，还用一个层面上的集成变得越来越重要，那就是“身份认证”的整合，也就是“单点登录”。&lt;br/&gt;通常来说，每个单独的系统都会有自己的安全体系和身份认证系统。&lt;br/&gt;整合以前，进入每个系统都需要进行登录，这样的局面不仅给管理上带来了很大的困难，在安全方面也埋下了重大的隐患。下面是一些著名的调查公司显示的统计数据：&lt;br/&gt;用户每天平均 16 分钟花在身份验证任务上 - 资料来源： IDS&lt;br/&gt;频繁的 IT 用户平均有 21 个密码 - 资料来源： NTA Monitor Password Survey&lt;br/&gt;49% 的人写下了其密码，而 67% 的人很少改变它们&lt;br/&gt;每 79 秒出现一起身份被窃事件 - 资料来源：National Small Business Travel Assoc&lt;br/&gt;全球欺骗损失每年约 12B - 资料来源：Comm Fraud Control Assoc&lt;br/&gt;到 2007 年，身份管理市场将成倍增长至 $4.5B - 资料来源：IDS&lt;/p&gt;
&lt;h4 id=&quot;单点登录带来的好处&quot;&gt;3、单点登录带来的好处&lt;/h4&gt;
&lt;p&gt;使用“单点登录”整合后，只需要登录一次就可以进入多个系统，而不需要重新登录，这不仅仅带来了更好的用户体验，更重要的是降低了安全的风险和管理的消耗。请看下面的统计数据：&lt;br/&gt;提高 IT 效率：对于每 1000 个受管用户，每用户可节省$70K&lt;br/&gt;帮助台呼叫减少至少1/3，对于 10K 员工的公司，每年可以节省每用户 $75，或者合计 $648K&lt;br/&gt;生产力提高：每个新员工可节省 $1K，每个老员工可节省 $350 资料来源：Giga&lt;br/&gt;ROI 回报：7.5 到 13 个月 资料来源：Gartner&lt;br/&gt;另外，使用“单点登录”还是SOA时代的需求之一。&lt;br/&gt;在面向服务的架构中，服务和服务之间，程序和程序之间的通讯大量存在，服务之间的安全认证是SOA应用的难点之一，应此建立“单点登录”的系统体系能够大大简化SOA的安全问题，提高服务之间的合作效率。&lt;/p&gt;
&lt;h3 id=&quot;二单点登录的运行原理&quot;&gt;二、单点登录的运行原理&lt;/h3&gt;
&lt;h4 id=&quot;一个简单的运行机制&quot;&gt;1、一个简单的运行机制&lt;/h4&gt;
&lt;p&gt;单点登录的机制其实是比较简单的，用一个现实中的例子做比较。&lt;br/&gt;某公园内部有许多独立的景点，游客可以在各个景点门口单独买票。&lt;br/&gt;对于需要游玩所有的景点的游客，这种买票方式很不方便，需要在每个景点门口排队买票，钱包拿 进拿出的，容易丢失，很不安全。&lt;br/&gt;于是绝大多数游客选择在大门口买一张通票（也叫套票），就可以玩遍所有的景点而不需要重新再买票。&lt;br/&gt;他们只需要在每个景点门 口出示一下刚才买的套票就能够被允许进入每个独立的景点。&lt;/p&gt;
&lt;p&gt;单点登录的机制也一样，如下图所示&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534147/201908/1534147-20190822190134800-1634949265.png&quot;/&gt;&lt;br/&gt;当用户第一次访问应用系统1的时候，因为还没有登录，会被引导到认证系统中进行登录（1）；&lt;/p&gt;
&lt;p&gt;根据用户提供的登录信息，认证系统进行身份效验，如果通过效验，应该返回给用户一个认证的凭据－－ticket（2）；&lt;/p&gt;
&lt;p&gt;用户再访问别的应用的时候（3，5）就会将这个ticket带上，作为自己认证的凭据，应用系统接受到请求之后会把ticket送到认证系统进行效验，检查ticket的合法性（4，6）。&lt;/p&gt;
&lt;p&gt;如果通过效验，用户就可以在不用再次登录的情况下访问应用系统2和应用系统3了。&lt;/p&gt;
&lt;h4 id=&quot;稍微复杂一点的运行机制&quot;&gt;2、稍微复杂一点的运行机制&lt;/h4&gt;
&lt;p&gt;从上面的视图可以看出，要实现SSO，需要以下主要的功能：&lt;/p&gt;
&lt;p&gt;所有应用系统共享一个身份认证系统。统一的认证系统是SSO的前提之一。认证系统的主要功能是将用户的登录信息和用户信息库相比较，对用户进行登录认证；认证成功后，认证系统应该生成统一的认证标志（ticket），返还给用户。&lt;br/&gt;另外，认证系统还应该对ticket进行效验，判断其有效性。所有应用系统能够识别和提取ticket信息，要实现SSO的功能，让用户只登录一次，就必须让应用系统能够识别已经登录过的用户。&lt;br/&gt;应用系统应该能对ticket进行识别和提取，通过与认证系统的通讯，能自动判断当前用户是否登录过，从而完成单点登录的功能。&lt;/p&gt;
&lt;p&gt;上面的功能只是一个非常简单的SSO架构，在现实情况下的SSO有着更加复杂的结构。有两点需要指出的是：&lt;/p&gt;
&lt;p&gt;单一的用户信息数据库并不是必须的，有许多系统不能将所有的用户信息都集中存储，应该允许用户信息放置在不同的存储中。事实上，只要统一认证系统，统一ticket的产生和校验，无论用户信息存储在什么地方，都能实现单点登录。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534147/201908/1534147-20190822190159439-22045541.png&quot;/&gt;&lt;br/&gt;统一的认证系统并不是说只有单个的认证服务器，如下图所示，整个系统可以存在两个以上的认证服务器，这些服务器甚至可以是不同的产品。认证服务器之间要通过标准的通讯协议，互相交换认证信息，就能完成更高级别的单点登录。如下图，当用户在访问应用系统1时，由第一个认证服务器进行认证后，得到由此服务器产生的ticket。当他访问应用系统4的时候，认证服务器2能够识别此ticket是由第一个服务器产生的，通过认证服务器之间标准的通讯协议（例如SAML）来交换认证信息，仍然能够完成SSO的功能。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534147/201908/1534147-20190822190218966-351741635.png&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;web-sso&quot;&gt;3、web-sso&lt;/h4&gt;
&lt;p&gt;随着互联网的高速发展，WEB应用几乎统治了绝大部分的软件应用系统，因此WEB-SSO是SSO应用当中最流行的。&lt;br/&gt;WEB-SSO有其自身的特点和优势，实现起来比较简单易用。很多商业软件和开源软件都有对WEB-SSO的实现。&lt;br/&gt;其中值得一提的是OpenSSO （&lt;a href=&quot;https://opensso.dev.java.net&quot; class=&quot;uri&quot;&gt;https://opensso.dev.java.net&lt;/a&gt;），为用Java实现WEB-SSO提供架构指南和服务指南，为用户自己来实现WEB-SSO提供了理论的依据和实现的方法。&lt;/p&gt;
&lt;p&gt;为什么说WEB-SSO比较容易实现呢？这是有WEB应用自身的特点决定的。&lt;br/&gt;众所周知，Web协议（也就是HTTP）是一个无状态的协议。一个Web应用由很多个Web页面组成，每个页面都有唯一的URL来定义。用户在浏览器的地址栏输入页面的URL，浏览器就会向Web Server去发送请求。&lt;br/&gt;如下图，浏览器向Web服务器发送了两个请求，申请了两个页面。这两个页面的请求是分别使用了两个单独的HTTP连接。所谓无状态的协议也就是表现在这里，浏览器和Web服务器会在第一个请求完成以后关闭连接通道，在第二个请求的时候重新建立连接。Web服务器并不区分哪个请求来自哪个客户端，对所有的请求都一视同仁，都是单独的连接。&lt;br/&gt;这样的方式大大区别于传统的（Client/Server）C/S结构,在那样的应用中，客户端和服务器端会建立一个长时间的专用的连接通道。&lt;br/&gt;正是因为有了无状态的特性，每个连接资源能够很快被其他客户端所重用，一台Web服务器才能够同时服务于成千上万的客户端。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534147/201908/1534147-20190822190243455-497657921.png&quot;/&gt;&lt;br/&gt;但是我们通常的应用是有状态的。先不提不同应用之间的SSO，在同一个应用中也需要保存用户的登录身份信息。&lt;br/&gt;例如用户在访问页面1的时候进行了登录，当客户再次访问页面2的时候，如何才能告诉Web服务器，客户刚才已经登录过了呢？&lt;br/&gt;浏览器和服务器之间有约定：通过使用cookie技术来维护应用的状态。Cookie是可以被Web服务器设置的字符串，并且可以保存在浏览器中。&lt;br/&gt;如下图所示，当浏览器访问了页面1时，web服务器设置了一个cookie，并将这个cookie和页面1一起返回给浏览器，浏览器接到cookie之后，就会保存起来，&lt;br/&gt;在它访问页面2的时候会把这个cookie也带上，Web服务器接到请求时也能读出cookie的值，根据cookie值的内容就可以判断和恢复一些用户的信息状态。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1534147/201908/1534147-20190822190259262-1985013069.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Web-SSO完全可以利用Cookie来完成用户登录信息的保存，将浏览器中的Cookie和上文中的Ticket结合起来，完成SSO的功能。&lt;/p&gt;
&lt;p&gt;为了完成一个简单的SSO的功能，需要两个部分的合作：&lt;br/&gt;统一的身份认证服务。&lt;br/&gt;修改Web应用，使得每个应用都通过这个统一的认证服务来进行身份效验。&lt;/p&gt;
&lt;h3 id=&quot;ps&quot;&gt;ps&lt;/h3&gt;
&lt;p&gt;这篇是我在网上看到的，觉得写得很好，转过来存着，怕找不到，原文链接：&lt;a href=&quot;https://www.cnblogs.com/lexiaofei/p/7172214.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lexiaofei/p/7172214.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 23 Aug 2019 00:27:00 +0000</pubDate>
<dc:creator>经典鸡翅</dc:creator>
<og:description>一、单点登录的概念 1、什么是单点登陆 单点登录（Single Sign On），简称为 SSO，是目前比较流行的企业业务整合的解决方案之一。SSO的定义是在多个应用系统中，用户只需要登录一次就可以访</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jichi/p/11396264.html</dc:identifier>
</item>
<item>
<title>Hive 系列（八）—— Hive 数据查询详解 - 黑白影</title>
<link>http://www.cnblogs.com/heibaiying/p/11397788.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/heibaiying/p/11397788.html</guid>
<description>&lt;h2 id=&quot;一数据准备&quot;&gt;一、数据准备&lt;/h2&gt;
&lt;p&gt;为了演示查询操作，这里需要预先创建三张表，并加载测试数据。&lt;/p&gt;
&lt;blockquote readability=&quot;4.4375&quot;&gt;
&lt;p&gt;数据文件 emp.txt 和 dept.txt 可以从本仓库的&lt;a href=&quot;https://github.com/heibaiying/BigData-Notes/tree/master/resources&quot;&gt;resources&lt;/a&gt; 目录下载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;员工表&quot;&gt;1.1 员工表&lt;/h3&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt; -- 建表语句
 CREATE TABLE emp(
     empno INT,     -- 员工表编号
     ename STRING,  -- 员工姓名
     job STRING,    -- 职位类型
     mgr INT,   
     hiredate TIMESTAMP,  --雇佣日期
     sal DECIMAL(7,2),  --工资
     comm DECIMAL(7,2),
     deptno INT)   --部门编号
    ROW FORMAT DELIMITED FIELDS TERMINATED BY &quot;\t&quot;;

  --加载数据
LOAD DATA LOCAL INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE INTO TABLE emp;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;部门表&quot;&gt;1.2 部门表&lt;/h3&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt; -- 建表语句
 CREATE TABLE dept(
     deptno INT,   --部门编号
     dname STRING,  --部门名称
     loc STRING    --部门所在的城市
 )
 ROW FORMAT DELIMITED FIELDS TERMINATED BY &quot;\t&quot;;
 
 --加载数据
 LOAD DATA LOCAL INPATH &quot;/usr/file/dept.txt&quot; OVERWRITE INTO TABLE dept;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分区表&quot;&gt;1.3 分区表&lt;/h3&gt;
&lt;p&gt;这里需要额外创建一张分区表，主要是为了演示分区查询：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;CREATE EXTERNAL TABLE emp_ptn(
      empno INT,
      ename STRING,
      job STRING,
      mgr INT,
      hiredate TIMESTAMP,
      sal DECIMAL(7,2),
      comm DECIMAL(7,2)
  )
 PARTITIONED BY (deptno INT)   -- 按照部门编号进行分区
 ROW FORMAT DELIMITED FIELDS TERMINATED BY &quot;\t&quot;;


--加载数据
LOAD DATA LOCAL INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE INTO TABLE emp_ptn PARTITION (deptno=20)
LOAD DATA LOCAL INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE INTO TABLE emp_ptn PARTITION (deptno=30)
LOAD DATA LOCAL INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE INTO TABLE emp_ptn PARTITION (deptno=40)
LOAD DATA LOCAL INPATH &quot;/usr/file/emp.txt&quot; OVERWRITE INTO TABLE emp_ptn PARTITION (deptno=50)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二单表查询&quot;&gt;二、单表查询&lt;/h2&gt;
&lt;h3 id=&quot;select&quot;&gt;2.1 SELECT&lt;/h3&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 查询表中全部数据
SELECT * FROM emp;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;where&quot;&gt;2.2 WHERE&lt;/h3&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 查询 10 号部门中员工编号大于 7782 的员工信息 
SELECT * FROM emp WHERE empno &amp;gt; 7782 AND deptno = 10;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;distinct&quot;&gt;2.3 DISTINCT&lt;/h3&gt;
&lt;p&gt;Hive 支持使用 DISTINCT 关键字去重。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 查询所有工作类型
SELECT DISTINCT job FROM emp;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;分区查询&quot;&gt;2.4 分区查询&lt;/h3&gt;
&lt;p&gt;分区查询 (Partition Based Queries)，可以指定某个分区或者分区范围。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 查询分区表中部门编号在[20,40]之间的员工
SELECT emp_ptn.* FROM emp_ptn
WHERE emp_ptn.deptno &amp;gt;= 20 AND emp_ptn.deptno &amp;lt;= 40;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;limit&quot;&gt;2.5 LIMIT&lt;/h3&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 查询薪资最高的 5 名员工
SELECT * FROM emp ORDER BY sal DESC LIMIT 5;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;group-by&quot;&gt;2.6 GROUP BY&lt;/h3&gt;
&lt;p&gt;Hive 支持使用 GROUP BY 进行分组聚合操作。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;set hive.map.aggr=true;

-- 查询各个部门薪酬综合
SELECT deptno,SUM(sal) FROM emp GROUP BY deptno;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;hive.map.aggr&lt;/code&gt; 控制程序如何进行聚合。默认值为 false。如果设置为 true，Hive 会在 map 阶段就执行一次聚合。这可以提高聚合效率，但需要消耗更多内存。&lt;/p&gt;
&lt;h3 id=&quot;order-and-sort&quot;&gt;2.7 ORDER AND SORT&lt;/h3&gt;
&lt;p&gt;可以使用 ORDER BY 或者 Sort BY 对查询结果进行排序，排序字段可以是整型也可以是字符串：如果是整型，则按照大小排序；如果是字符串，则按照字典序排序。ORDER BY 和 SORT BY 的区别如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用 ORDER BY 时会有一个 Reducer 对全部查询结果进行排序，可以保证数据的全局有序性；&lt;/li&gt;
&lt;li&gt;使用 SORT BY 时只会在每个 Reducer 中进行排序，这可以保证每个 Reducer 的输出数据是有序的，但不能保证全局有序。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;由于 ORDER BY 的时间可能很长，如果你设置了严格模式 (hive.mapred.mode = strict)，则其后面必须再跟一个 &lt;code&gt;limit&lt;/code&gt; 子句。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注 ：hive.mapred.mode 默认值是 nonstrict ，也就是非严格模式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 查询员工工资，结果按照部门升序，按照工资降序排列
SELECT empno, deptno, sal FROM emp ORDER BY deptno ASC, sal DESC;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;having&quot;&gt;2.8 HAVING&lt;/h3&gt;
&lt;p&gt;可以使用 HAVING 对分组数据进行过滤。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 查询工资总和大于 9000 的所有部门
SELECT deptno,SUM(sal) FROM emp GROUP BY deptno HAVING SUM(sal)&amp;gt;9000;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;distribute-by&quot;&gt;2.9 DISTRIBUTE BY&lt;/h3&gt;
&lt;p&gt;默认情况下，MapReduce 程序会对 Map 输出结果的 Key 值进行散列，并均匀分发到所有 Reducer 上。如果想要把具有相同 Key 值的数据分发到同一个 Reducer 进行处理，这就需要使用 DISTRIBUTE BY 字句。&lt;/p&gt;
&lt;p&gt;需要注意的是，DISTRIBUTE BY 虽然能保证具有相同 Key 值的数据分发到同一个 Reducer，但是不能保证数据在 Reducer 上是有序的。情况如下：&lt;/p&gt;
&lt;p&gt;把以下 5 个数据发送到两个 Reducer 上进行处理：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;k1
k2
k4
k3
k1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Reducer1 得到如下乱序数据：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;k1
k2
k1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Reducer2 得到数据如下：&lt;/p&gt;
&lt;pre class=&quot;properties&quot;&gt;
&lt;code&gt;k4
k3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想让 Reducer 上的数据时有序的，可以结合 &lt;code&gt;SORT BY&lt;/code&gt; 使用 (示例如下)，或者使用下面我们将要介绍的 CLUSTER BY。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 将数据按照部门分发到对应的 Reducer 上处理
SELECT empno, deptno, sal FROM emp DISTRIBUTE BY deptno SORT BY deptno ASC;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cluster-by&quot;&gt;2.10 CLUSTER BY&lt;/h3&gt;
&lt;p&gt;如果 &lt;code&gt;SORT BY&lt;/code&gt; 和 &lt;code&gt;DISTRIBUTE BY&lt;/code&gt; 指定的是相同字段，且 SORT BY 排序规则是 ASC，此时可以使用 &lt;code&gt;CLUSTER BY&lt;/code&gt; 进行替换，同时 &lt;code&gt;CLUSTER BY&lt;/code&gt; 可以保证数据在全局是有序的。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT empno, deptno, sal FROM emp CLUSTER  BY deptno ;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三多表联结查询&quot;&gt;三、多表联结查询&lt;/h2&gt;
&lt;p&gt;Hive 支持内连接，外连接，左外连接，右外连接，笛卡尔连接，这和传统数据库中的概念是一致的，可以参见下图。&lt;/p&gt;
&lt;p&gt;需要特别强调：JOIN 语句的关联条件必须用 ON 指定，不能用 WHERE 指定，否则就会先做笛卡尔积，再过滤，这会导致你得不到预期的结果 (下面的演示会有说明)。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;600px&quot; src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/sql-join.jpg&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;inner-join&quot;&gt;3.1 INNER JOIN&lt;/h3&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 查询员工编号为 7369 的员工的详细信息
SELECT e.*,d.* FROM 
emp e JOIN dept d
ON e.deptno = d.deptno 
WHERE empno=7369;

--如果是三表或者更多表连接，语法如下
SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key1) JOIN c ON (c.key = b.key1)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;left-outer-join&quot;&gt;3.2 LEFT OUTER JOIN&lt;/h3&gt;
&lt;p&gt;LEFT OUTER JOIN 和 LEFT JOIN 是等价的。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 左连接
SELECT e.*,d.*
FROM emp e LEFT OUTER  JOIN  dept d
ON e.deptno = d.deptno;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;right-outer-join&quot;&gt;3.3 RIGHT OUTER JOIN&lt;/h3&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;--右连接
SELECT e.*,d.*
FROM emp e RIGHT OUTER JOIN  dept d
ON e.deptno = d.deptno;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行右连接后，由于 40 号部门下没有任何员工，所以此时员工信息为 NULL。这个查询可以很好的复述上面提到的——JOIN 语句的关联条件必须用 ON 指定，不能用 WHERE 指定。你可以把 ON 改成 WHERE，你会发现无论如何都查不出 40 号部门这条数据，因为笛卡尔运算不会有 (NULL, 40) 这种情况。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img width=&quot;700px&quot; src=&quot;https://raw.githubusercontent.com/heibaiying/BigData-Notes/master/pictures/hive-right-join.png&quot;/&gt;&lt;/div&gt;
&lt;h3 id=&quot;full-outer-join&quot;&gt;3.4 FULL OUTER JOIN&lt;/h3&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT e.*,d.*
FROM emp e FULL OUTER JOIN  dept d
ON e.deptno = d.deptno;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;left-semi-join&quot;&gt;3.5 LEFT SEMI JOIN&lt;/h3&gt;
&lt;p&gt;LEFT SEMI JOIN （左半连接）是 IN/EXISTS 子查询的一种更高效的实现。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JOIN 子句中右边的表只能在 ON 子句中设置过滤条件;&lt;/li&gt;
&lt;li&gt;查询结果只包含左边表的数据，所以只能 SELECT 左表中的列。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;-- 查询在纽约办公的所有员工信息
SELECT emp.*
FROM emp LEFT SEMI JOIN dept 
ON emp.deptno = dept.deptno AND dept.loc=&quot;NEW YORK&quot;;

--上面的语句就等价于
SELECT emp.* FROM emp
WHERE emp.deptno IN (SELECT deptno FROM dept WHERE loc=&quot;NEW YORK&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;join&quot;&gt;3.6 JOIN&lt;/h3&gt;
&lt;p&gt;笛卡尔积连接，这个连接日常的开发中可能很少遇到，且性能消耗比较大，基于这个原因，如果在严格模式下 (hive.mapred.mode = strict)，Hive 会阻止用户执行此操作。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT * FROM emp JOIN dept;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四join优化&quot;&gt;四、JOIN优化&lt;/h2&gt;
&lt;h3 id=&quot;streamtable&quot;&gt;4.1 STREAMTABLE&lt;/h3&gt;
&lt;p&gt;在多表进行联结的时候，如果每个 ON 字句都使用到共同的列（如下面的 &lt;code&gt;b.key&lt;/code&gt;），此时 Hive 会进行优化，将多表 JOIN 在同一个 map / reduce 作业上进行。同时假定查询的最后一个表（如下面的 c 表）是最大的一个表，在对每行记录进行 JOIN 操作时，它将尝试将其他的表缓存起来，然后扫描最后那个表进行计算。因此用户需要保证查询的表的大小从左到右是依次增加的。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;`SELECT a.val, b.val, c.val FROM a JOIN b ON (a.key = b.key) JOIN c ON (c.key = b.key)`&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后，用户并非需要总是把最大的表放在查询语句的最后面，Hive 提供了 &lt;code&gt;/*+ STREAMTABLE() */&lt;/code&gt; 标志，用于标识最大的表，示例如下：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT /*+ STREAMTABLE(d) */  e.*,d.* 
FROM emp e JOIN dept d
ON e.deptno = d.deptno
WHERE job='CLERK';&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;mapjoin&quot;&gt;4.2 MAPJOIN&lt;/h3&gt;
&lt;p&gt;如果所有表中只有一张表是小表，那么 Hive 把这张小表加载到内存中。这时候程序会在 map 阶段直接拿另外一个表的数据和内存中表数据做匹配，由于在 map 就进行了 JOIN 操作，从而可以省略 reduce 过程，这样效率可以提升很多。Hive 中提供了 &lt;code&gt;/*+ MAPJOIN() */&lt;/code&gt; 来标记小表，示例如下：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT /*+ MAPJOIN(d) */ e.*,d.* 
FROM emp e JOIN dept d
ON e.deptno = d.deptno
WHERE job='CLERK';&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五select的其他用途&quot;&gt;五、SELECT的其他用途&lt;/h2&gt;
&lt;p&gt;查看当前数据库：&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;SELECT current_database()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;六本地模式&quot;&gt;六、本地模式&lt;/h2&gt;
&lt;p&gt;在上面演示的语句中，大多数都会触发 MapReduce, 少部分不会触发，比如 &lt;code&gt;select * from emp limit 5&lt;/code&gt; 就不会触发 MR，此时 Hive 只是简单的读取数据文件中的内容，然后格式化后进行输出。在需要执行 MapReduce 的查询中，你会发现执行时间可能会很长，这时候你可以选择开启本地模式。&lt;/p&gt;
&lt;pre class=&quot;sql&quot;&gt;
&lt;code&gt;--本地模式默认关闭，需要手动开启此功能
SET hive.exec.mode.local.auto=true;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启用后，Hive 将分析查询中每个 map-reduce 作业的大小，如果满足以下条件，则可以在本地运行它：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;作业的总输入大小低于：hive.exec.mode.local.auto.inputbytes.max（默认为 128MB）；&lt;/li&gt;
&lt;li&gt;map-tasks 的总数小于：hive.exec.mode.local.auto.tasks.max（默认为 4）；&lt;/li&gt;
&lt;li&gt;所需的 reduce 任务总数为 1 或 0。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;因为我们测试的数据集很小，所以你再次去执行上面涉及 MR 操作的查询，你会发现速度会有显著的提升。&lt;/p&gt;
&lt;h2 id=&quot;参考资料&quot;&gt;参考资料&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Select&quot;&gt;LanguageManual Select&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+Joins&quot;&gt;LanguageManual Joins&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+GroupBy&quot;&gt;LanguageManual GroupBy&lt;/a&gt;&lt;/li&gt;
&lt;li readability=&quot;-1.2075471698113&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://cwiki.apache.org/confluence/display/Hive/LanguageManual+SortBy&quot;&gt;LanguageManual SortBy&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.75&quot;&gt;
&lt;p&gt;&lt;strong&gt;更多大数据系列文章可以参见 GitHub 开源项目&lt;/strong&gt;： &lt;a href=&quot;https://github.com/heibaiying/BigData-Notes&quot;&gt;&lt;strong&gt;大数据入门指南&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Thu, 22 Aug 2019 23:51:00 +0000</pubDate>
<dc:creator>黑白影</dc:creator>
<og:description>一、数据准备 为了演示查询操作，这里需要预先创建三张表，并加载测试数据。 数据文件 emp.txt 和 dept.txt 可以从本仓库的 'resources' 目录下载。 1.1 员工表 1.2 部</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/heibaiying/p/11397788.html</dc:identifier>
</item>
<item>
<title>【JavaScript】论一个低配版Web实时通信库是如何实现的之二（ EventSource篇) - 外婆的彭湖湾</title>
<link>http://www.cnblogs.com/penghuwan/p/11391705.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/penghuwan/p/11391705.html</guid>
<description>&lt;h2&gt;&lt;span&gt;前情提要&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;「 话说上回说到！那WebSocket大侠,巧借http之内力，破了敌阵的双工鸳鸯锁，终于突出重围。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然而玄难未了，此时web森林中飞出一只银头红缨枪，划破夜色。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;莫非!?&quot; websocket大侠喃喃念道，&quot;恐怖如斯，你莫不是就是那个手使单向追魂枪的。。。&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&quot;正是在下！&quot;，那人厉声喝道。只见那胸前的纹章铭刻着几个洋文——&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;读作&quot;EventSource&quot;！」&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;Post-Title&quot;&gt;&lt;span&gt;&lt;span&gt;上一篇文章请看这里：&lt;a href=&quot;%20https://zhuanlan.zhihu.com/p/77583872&quot; target=&quot;_blank&quot;&gt;论一个低配版Web实时通信库是如何实现的（ WebSocket篇)&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;引论&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;simple-socket是我写的一个&quot;低配版&quot;的Web实时通信工具（&lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=http%3A//xn--socket-og8i392gd27c.io/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;相对于Socket.io&lt;/a&gt;），在参考了相关源码和资料的基础上，实现了前后端实时互通的基本功能，选用了WebSocket -&amp;gt;server-sent-event -&amp;gt; AJAX轮询这三种方式做降级兼容，分为simple-socket-client和simple-socket-server两套代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;我的上一篇文章讲了&lt;a href=&quot;https://zhuanlan.zhihu.com/p/77583872&quot; target=&quot;_blank&quot;&gt;如何进行websocket的前后端编码&lt;/a&gt;，所以今天来聊一聊event-source这块的&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;论一个低配版Web实时通信库是如何实现的（ WebSocket篇)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;github仓库地址&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/penghuwan/simple-socket&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;npm命令&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm i simple-socket-&lt;span&gt;serve   （服务端npm包）
npm i simple&lt;/span&gt;-socket-client   (客户端npm包)
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;&lt;span&gt;EventSource的前端代码&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;EventSource的前端API主要有这么四个&lt;/span&gt;&lt;/p&gt;
&lt;ol readability=&quot;1.9609120521173&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;创建es对象：var es = new EventSource(url)&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;es两端连接事件打开的回调：es.onopen = function () { }&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;监听服务端发送事件： es.addEventListener(&quot;XXX&quot;, function (e) { // &lt;a class=&quot; wrap external&quot; href=&quot;https://link.zhihu.com/?target=http%3A//e.data/&quot; rel=&quot;nofollow noreferrer&quot; target=&quot;_blank&quot; data-za-detail-view-id=&quot;1043&quot;&gt;e.data&lt;/a&gt; }&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;监听服务端的message事件es.onmessage = function; 相当于es.addEventListener(&quot;message&quot;，function);&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;业务代码如下&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;（1）前端从服务端接收消息&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;前端通过监听服务端message事件，接收消息，并解析event和data，然后通过emitter.emit(event, data)触发事件，从而调用socket.on设置的监听回调&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Client() {
  &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.ws = &lt;span&gt;null&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;.es = &lt;span&gt;null&lt;/span&gt;;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt; EventSource对象&lt;/span&gt;
  init.call(&lt;span&gt;this&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置this.type并初始化相关对象例如es或ws&lt;/span&gt;
  listen.call(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; listen() { 
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 保存this&lt;/span&gt;
  &lt;span&gt;var&lt;/span&gt; self  = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;switch&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.type) {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 当type为eventsource时，执行以下代码，this.type根据能力检测设置&lt;/span&gt;
    &lt;span&gt;case&lt;/span&gt; 'eventsource'&lt;span&gt;:
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听触发connect事件,把client对象自身传入当作socket&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.es.onopen = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
        emitter.emit(&lt;/span&gt;'connect'&lt;span&gt;, self);
      };
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 监听服务端传来的message事件&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;.es.addEventListener(&quot;message&quot;, &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (e) {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; payload =&lt;span&gt; JSON.parse(e.data);;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; event =&lt;span&gt; payload.event;
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; data =&lt;span&gt; payload.data;
        emitter.emit(event, data);
      }, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
      &lt;/span&gt;&lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ...&lt;/span&gt;
&lt;span&gt;  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;（2）前端发送消息给服务端&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;由于event-source是单向的，只能从服务端从前端发送消息，而不能从前端发送消息给服务端。这和websocket显著不同&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;不过别担心，因为我们不是还有AJAX嘛！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于前端发送消息的情况 我们可以发一个post请求过去，同时借助/eventsource这个路径，告诉服务端这是一个SSE请求&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$.ajax({,
  type: &lt;/span&gt;'POST'&lt;span&gt;,
  url: `http:&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;${url}/eventsource`,&lt;/span&gt;
&lt;span&gt;  data: { event, data },
  success: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;EventSource的服务端代码&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;好像这波就没了吧，OK，我们接下来走下路。&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;server-sent-event的服务端握手流程&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;server-sent-event(或event-source)，需要借助流(stream)的方式去实现通信。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器的request/response 对象就是一个 Stream。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它可以分为四种类型：&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Readable - 可读操作。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Writable - 可写操作。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Duplex - 可读可写操作.&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;Transform - 操作被写入数据，然后读出结果。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;服务器每次接收的Response是一个Writable，它可以被写入数据，将一个流写入另一个流可以通过调用pipe方法。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以我们需要创建一个stream的实例，然后通过调用stream.pipe(Response)将流写入响应中，这样就可以被前端es.addEventListener添加的回调给接收到了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;但问题在于 。。。Stream是个抽象接口，Node.js没有给Stream提供构造函数&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1060770/201908/1060770-20190821223705256-1189960962.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;不过没关系，我们可以这样做：&lt;/span&gt;&lt;/p&gt;
&lt;div&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;使用call方法继承stream父函数&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;使用util.inherits继承stream的原型&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;重写_read和_write方法（否则会报错）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 因为我们的流需要写和读，所以使用双工的stream.Duplex构造&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; EventStream() { 
stream.Duplex.call(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 构造函数继承&lt;/span&gt;
&lt;span&gt;}
util.inherits(EventStream, stream.Duplex); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 原型继承&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 重写_read和_write方法&lt;/span&gt;
EventStream.prototype._read = &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () { }
EventStream.prototype._write &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt; () { }
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;43.418029933867&quot;&gt;
&lt;h3&gt;&lt;span&gt;握手代码逻辑&lt;/span&gt;&lt;/h3&gt;
&lt;ol readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;&lt;span&gt;创建stream实例，调用pipe方法输送给Response, 同时stream我们保存在socket对象中，在向前端发送数据时候会使用&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;将Content-Type字段设置为'text/event-stream'，同时Connection设置为'keep-alive'&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;将状态码设为200（否则前端onopen方法不会触发）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt;_handleEShandShake(ctx, socket) {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 前面定义好的类似stream的类&lt;/span&gt;
  const eventStream = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EventStream();
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置eventStream&lt;/span&gt;
&lt;span&gt;  socket.setEventStream(eventStream);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 握手成功后触发onConnection方法,TODO&lt;/span&gt;
  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置符合Event-Source要求的首部&lt;/span&gt;
&lt;span&gt;  ctx.set({
    &lt;/span&gt;'Content-Type': 'text/event-stream'&lt;span&gt;,
    &lt;/span&gt;'Cache-Control': 'no-cache'&lt;span&gt;,
    &lt;/span&gt;'Connection': 'keep-alive'&lt;span&gt;,
  });
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将Stream赋给body,Koa底层会判断Stream类型并调用pipe方法流入response&lt;/span&gt;
  ctx.body =&lt;span&gt; eventStream;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置表示请求成功，否则前端onopen方法不会触发  &lt;/span&gt;
  ctx.status = 200&lt;span&gt;;
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 触发connect方法，传递socket对象&lt;/span&gt;
  &lt;span&gt;this&lt;/span&gt;.emit('connect'&lt;span&gt;, socket);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;&lt;span&gt;Event-Source服务端向前端发送消息。&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;这里要先说下event-source的报文结构了，由四种字段组成&lt;/span&gt;&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;event：事件名，对应前端es.addEventLisener设置的事件名&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;data：数据，为字符串&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;id: 消息标识符，可以缺省&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;span&gt;retry：表示重新连接的时间间隔&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;这四个字段两两之间用\n分开，而最后一个字段值需要用\n\n做结尾&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如：`event:message\n data: XXX \n\n`&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;ztext-empty-paragraph&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;话不多说，看代码&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Socket extends events.EventEmitter {
  constructor(socketId) {
    super();
  }
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置&lt;/span&gt;
&lt;span&gt;  setEventStream(eventStream) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.eventStream =&lt;span&gt; eventStream;
  }

  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 自定义的emit,触发的是前端的on&lt;/span&gt;
&lt;span&gt;  emit(event, data) {
    const dataStr &lt;/span&gt;=&lt;span&gt; JSON.stringify({event,data})
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.transport === 'eventsource'&lt;span&gt;) {
      &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.eventStream) { &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error('eventStream不存在,无法emit'&lt;span&gt;) };
      &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向stream中写入数据，只要stream尚未关闭&lt;/span&gt;
      &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 数据就会传给前端的onmessage方法或addEventListener('message',fuc)方法&lt;/span&gt;
      &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventStream.push(`event:message\ndata:${dataStr}\n\n`);
    } 
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;Event-Source服务端接收前端消息&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;之前说了，event-source是单向的，所以前端到服务端的传送是通过Ajax请求过来的，所以解析下body,触发事件就OK了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;故事到这里就结束了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;有诗为证&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;江河湖泊浪滔滔，&lt;span&gt;WebSocket&lt;/span&gt;多逍遥&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;EventSource&lt;/span&gt;先来却后到，Ajax轮询热血逞英豪！&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;欲知后事如何，且听下回分解！&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;知乎专栏&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;最近也在知乎上写文章，感觉破乎的体验很差！没有博客园好！感觉博客园的各位才个个都是人才，说话又好听！我超喜欢在里面的。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;所以说。。。大家好，给大家介绍一下这是我的知乎专栏&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/c_135367198&quot;&gt;https://zhuanlan.zhihu.com/c_135367198&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;这位路过的大哥你有灵气从键盘喷出，看来是百年一遇的代码奇才，就施舍善心关注一下吧，以解小弟拖家带口之忧，养儿奉母之仇(大雾)&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 22 Aug 2019 23:42:00 +0000</pubDate>
<dc:creator>外婆的彭湖湾</dc:creator>
<og:description>话说上回说到！那WebSocket大侠,巧借http之内力，破了敌阵的双工鸳鸯锁，终于突出重围。然而玄难未了，此时web森林中飞出一只银头红缨枪，划破夜色。'莫非!?' ， websocket大侠喃喃</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/penghuwan/p/11391705.html</dc:identifier>
</item>
<item>
<title>Docker系列之AspNetCore Runtime  VS .NetCore Runtime VS .NET Core SDK（四） - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/11391646.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/11391646.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;接下来我们就要慢慢步入在.NET Core中使用Docker的殿堂了，在开始之前如题，我们需要搞清楚一些概念，要不然看到官方提供如下一系列镜像，我们会一脸懵逼，不知道到底要使用哪一个。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190821223610791-1175484565.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;h2&gt;AspNetCore Runtime  VS .NetCore Runtime VS .NET Core SDK &lt;/h2&gt;
&lt;p&gt;本节我们所讲解的官方所提供的一系列镜像都是最新镜像，而且阅读本文的您还需明白一点，要是您看到其他博文中提供的镜像以microsoft开头，那么说明已过时不再可取。这里额外再多说一句，很多时候我们看到一些资料，然后亲自实践却没达到文章中所描述的效果，大部分情况下可能都是官方已更新导致，一切以官方文档为主才是最佳。我们将官方所提供的镜像作如下说明：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;镜像地址&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;镜像名称&lt;/td&gt;
&lt;td&gt;镜像说明&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;mcr.microsoft.com/dotnet/core/runtime&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt; .NET Core Runtime&lt;/td&gt;
&lt;td&gt;部署.NET Core控制台程序&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;mcr.microsoft.com/dotnet/core/runtime-deps &lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;.NET Core Runtime Dependencies&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;部署自包含的部署应用程序&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;mcr.microsoft.com/dotnet/core/sdk &lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;.NET Core SDK&lt;/td&gt;
&lt;td&gt;构建.NET Core（或ASP.NET Core应用程序）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;mcr.microsoft.com/dotnet/core/aspnet &lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;ASP.NET Core Runtime&lt;/td&gt;
&lt;td&gt;部署ASP.NET Core应用程序&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;上述对于.NET Core Runtime Dependencies镜像包我没做过多了解，在官方文档上有对这个的详细介绍名叫《SCD》，送上地址《&lt;a title=&quot;Self-contained deployments (SCD)&quot; href=&quot;https://docs.microsoft.com/en-gb/dotnet/core/deploying/index#self-contained-deployments-scd&quot;&gt;https://docs.microsoft.com/en-gb/dotnet/core/deploying/index#self-contained-deployments-scd&lt;/a&gt;》，搞那么多包，好像很复杂似的，其实我们只需谨记如下两点：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;span&gt;若需构建.NET Core应用程序，请使用.NET Core SDK&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;若需运行.NET Core应用程序，请使用.NET Core Runtime&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如上一节我们构建、发布应用程序直接在本地进行，所以我们只构建了.NET Core Runtime镜像，若在镜像中发布则还需提前下载.NET Core SDK镜像，接下来我们运行webapi来说明通过SDK镜像来构建程序，Runtime来运行程序。这里需要注意下，若下载了3.0预览版本直接运行如下命令所创建的程序版本为3.0，此时可能会因缺少对应包而还原失败，所以这里我们将通过命令( &lt;span class=&quot;cnblogs_code&quot;&gt;dotnet &lt;span&gt;new&lt;/span&gt; globaljson --sdk-version &lt;span&gt;2.2&lt;/span&gt;.&lt;span&gt;203&lt;/span&gt; --force&lt;/span&gt; )回退到2.2稳定版，继续往下走。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190821234113158-1909074035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190821234253723-2073045599.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;到这里为止我们并未如上一节那样直接发布，我们将其直接拖到ubuntu中，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190821234558691-1756855146.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里针对上一节内容补充说一句(个人有强迫症，上一节创建的镜像名称为(hellowrold)，这个镜像所打的标签单词名称打错了，应该是helloworld，所以这里我们重命名下镜像标签名称。又掌握了一个命令，哈哈。首先，我们查看镜像，如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190821235536474-416487514.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Docker中重命名镜像标签名称有两种方式，一是直接通过标签名称来重命名，而是通过镜像id来重命名，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;docker tag hellowrold:latest helloworld:latest

或

docker tag 75a287b4f21c helloworld:latest&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们通过如上任何一种方式重命名后再查看镜像，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190821235807520-886587310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;因为容器存在对旧镜像的引用，所以旧的会仍然存在而不是以新的进行完全覆盖，所以我们接下来执行如下命令将旧的镜像给移除：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker rmi hellowrold
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过执行如上命令会删除别名/标签，由于75a287b4f21c具有其他名称，因此不会删除实际图像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190822000335239-333494589.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;回到正题，接下来我们开始通过Dockerfile来构建webapi镜像，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
FROM mcr.microsoft.com/dotnet/core/sdk:&lt;span&gt;2.2&lt;/span&gt;&lt;span&gt; AS build
WORKDIR &lt;/span&gt;/&lt;span&gt;app

COPY &lt;/span&gt;*.csproj ./&lt;span&gt;
RUN dotnet restore

COPY . .&lt;/span&gt;/&lt;span&gt;
RUN dotnet publish &lt;/span&gt;-c Release -o &lt;span&gt;out&lt;/span&gt;&lt;span&gt;

FROM mcr.microsoft.com&lt;/span&gt;/dotnet/core/aspnet:&lt;span&gt;2.2&lt;/span&gt;&lt;span&gt; AS runtime
WORKDIR &lt;/span&gt;/&lt;span&gt;app

COPY &lt;/span&gt;--&lt;span&gt;from&lt;/span&gt;=build /app/&lt;span&gt;out&lt;/span&gt;&lt;span&gt; .

ENTRYPOINT [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dotnet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;WebApi.dll&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190822001403816-1126058058.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我们构建基础镜像SDK来构建应用程序，我们指定/app作为我们构建的工作目录。然后将文件从本地文件系统复制到镜像中，我们将只复制csproj文件并运行restore，然后复制其他剩余文件并运行dotnet publish来构建我们的应用程序并发布。该文件的运行时部分使用不同的docker基础映像也就是使用aspnetcore-runtime映像，它复制构建中的所有文件，然后定义应用程序入口点。我们发现在整个构建镜像过程的不同阶段都是可交互的，因为如上我们第一阶段获取构建程序镜像也就是别名为build，在第二阶段获取运行程序镜像也就是runtime，我们引用了build。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190822230525959-1050575326.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从如上我们构建镜像命令和上一节对比知道，构建命令可以通过 &lt;span class=&quot;cnblogs_code&quot;&gt;docker build . -t tagname&lt;/span&gt;  或 &lt;span class=&quot;cnblogs_code&quot;&gt;docker build -t tagname .&lt;/span&gt;  这两种方式来进行皆可。构建镜像就是基于上一镜像层并创建一个新的镜像层的过程，每个新的镜像层都对应一个唯一的标识id，我们可以通过如下命令来查看镜像构建的历史记录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker image history webapi:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190822211811190-1577184314.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;镜像“《none》”说明&lt;/h2&gt;
&lt;p&gt;当我们构建完镜像后，我们查看镜像列表会看到此时会多出了镜像标签名称为none的，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190822232934195-733820453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上生成的镜像none的作用是什么呢？我们是不是可以将其删除呢？&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;优点：它用来维护中间镜像层，因为对于每个Dockerfile说明的每一步骤，都会为中间层创建一个新的哈希值，通过允许缓存每个步骤来提高可重用性，减少磁盘使用量并加速docker构建。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;缺点：它作为悬空镜像，可能会导致磁盘空间问题，但是它被列为docker镜像的一部分。（Docker中空的文件系统层是未使用的，并且没有被任何镜像所引用，因此我们需要一种机制让Docker清除这些空的镜像）&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;none的镜像只是为临时容器保存而已，由于Docker的架构，即使容器停止了，这些悬空的镜像也依然会保留，所以我们可以对其进行清理，我们可以使用 &lt;span class=&quot;cnblogs_code&quot;&gt;docker rmi $(docker images -f &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dangling=true&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -q)&lt;/span&gt; 来清理它们，-f &quot;dangling = true&quot; -q显示所有悬空镜像，rmi将删除所有这些图像，若没有任何悬空镜像但执行了此命令，则会返回错误，但是我们可以使用 &lt;span class=&quot;cnblogs_code&quot;&gt;docker images prune -a&lt;/span&gt; （仅适用于1.25以上的docker版本）。&lt;/p&gt;
&lt;p&gt;接下来则是创建并启动容器运行程序，上一节我们在代码中配置了端口号为5000，并且也通过 &lt;span class=&quot;cnblogs_code&quot;&gt;docker run -p &lt;span&gt;5050&lt;/span&gt;:&lt;span&gt;5050&lt;/span&gt; hellowrold&lt;/span&gt; 指定相同端口号运行程序，这里我们在代码中并未配置端口，所以默认端口号为80，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
docker run webapi:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190822212553877-2036600759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来如果我们访问http:// localhost/api/values，我们会看到无法连接，也就是说没有得到我们所期望的JSON响应。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190822214315763-1885015225.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是为何呢？我们来看看docker给我们生成容器的名称，docker给容器随机生成例如如下一个名称：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190822215836761-703150781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们通过终端运行容器管理命令来修复，我们首先将容器停止，然后进行移除，命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;docker container stop gracious_chaplygin
docker container rm gracious_chaplygin&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190822220653823-1433352958.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们需要将gracious_chaplygi替换为从docker container ls返回的容器名称，我们使用以下命令再次启动容器：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
docker run --name webapi --env ASPNETCORE_ENVIRONMENT=Production -p &lt;span&gt;80&lt;/span&gt;:&lt;span&gt;80&lt;/span&gt; webapi:latest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上我们配置了3个参数，--name是容器启动和运行时的名称，--env允许我们将环境变量传递给正在运行的容器，-p允许我们将容器上的端口映射到在我们的机器上的端口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190822221422494-625784686.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190822221931969-1680932576.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上容器已启动，我们再次使用ls命令查看我们提供的名称和端口映射：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190822224126461-1042609268.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上述我猜测可能是因为容器名称随机生成的问题，然后指定了容器名称，结果好使了，但是上述我们再次获取容器名称时发现依然是随机生成的容器名称，所以我认为不是这个问题导致，和上一节我们运行容器做本节对比，只是指定了映射端口号，而本节未指定端口号，默认启动端口号为80，容器也运行起来了呀，最终发现还是未指定端口号的缘故，因为当我启动容器时，也如下明确指定端口号为80就好使了，所以这里需要注意下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201908/589642-20190823002236910-1000780804.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结 &lt;/h2&gt;
&lt;p&gt;本节我们讲解了在Docker中安装对应.NET Core镜像包的问题，并且以一个例子来说明，同时呢，我们在上一节使用指令的基础上又额外添加了对WORKDIR和RUN指令的使用，以及对容器停止、移除、镜像列表查看、镜像重命名、镜像删除、镜像构建历史记录查看指令的使用。接下来我们会继续通过例子来灵活使用各种指令，然后在这个过程中还涉及到一些可优化、以及Docker中比如卷、网络更深入的讲解。&lt;/p&gt;
</description>
<pubDate>Thu, 22 Aug 2019 23:38:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 接下来我们就要慢慢步入在.NET Core中使用Docker的殿堂了，在开始之前如题，我们需要搞清楚一些概念，要不然看到官方提供如下一系列镜像，我们会一脸懵逼，不知道到底要使用哪一个。 AspN</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/11391646.html</dc:identifier>
</item>
<item>
<title>博客园五月纪念日——去你的写博无用论 - 泰斗贤若如</title>
<link>http://www.cnblogs.com/zyx110/p/11395187.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyx110/p/11395187.html</guid>
<description>&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;博客园五月纪念日——去你的写博无用论&lt;/span&gt;&lt;/h2&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;纪念祝福&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;今天是我注册博客园的第五个月，此时此刻，我想吟诗一首：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;strong&gt;你问我爱你有多深&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;strong&gt;我爱你有几分&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-expand&quot;&gt;&lt;strong&gt;我的情也真&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;strong&gt;我的爱也真&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;strong&gt;博客代表我的心&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;写博初心&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5CLenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1566444736629.png&quot;&gt;&lt;img src=&quot;file://c/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/1566444736629.png?lastModify=1566462914&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201908/1640688-20190822163336608-1844030931.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;为什么坚持写博客&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;五个月前我注册了博客园，注册的原因很简单，我的“师傅”给我推荐博客园，说写博客对自身提高很有帮助。当时由于对他很崇拜，再加上当时学习很迷茫，一直找不到学习的方向，所以我把他对我说的每一句话都当救命稻草，注册博客不在话下，他一说完我就立马注册了。注册了就得写啊，可写什么？如何写？以前从来没写过，还是“师傅”，他在教我Java的过程中给我布置任务，让我把那些任务整理成博客。我照做了，无非就是复制粘贴一下他教过的笔记，然后整理一下格式，提交完成。就这样写了好几篇，几天后师傅看了我写的博客，看到我把代码直接从IDEA上截图放到博客中了，然后他跟我说不能这样做，有些代码是可以复用的，以后你需要的时候直接从你的博客中复制一下就可以了，别人也可以用，如果你用图片的话，就做不到这一点了。还有，你写的博客除了你自己外还有很多人会看的，所以你要考虑你写的每一篇博客能让别人获取到什么信息，一篇好的博客是能让人在轻松愉悦的阅读中获得通俗易懂的知识。经过“师傅”的一番教导，我慢慢明白了该怎样去写，我自己探索，有时候看别人的博客，然后思考为什么别人的博客会有那么多阅读量，后来自己慢慢尝试，直到有一次我写了一篇技术博客《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/10648119.html&quot; target=&quot;_blank&quot;&gt;抽象类能实例化吗？&lt;/a&gt;》&lt;span class=&quot;md-link&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;，这篇博客是我自己动脑经整理的，我当时没敢点发布至首页（怕被刷下去，之前的所有博客发布至首页后不出几秒就被刷出首页了），只是发布到了首页候选区，但是首页候选区的审核通过了，我一直刷新页面就等博客园移除通知呢，却是迟迟没有等到，不过我见证了激动人心的片段，每刷新一次网页，阅读量都会以几十人次的数目增长，两个小时之内阅读量超过了200人（别笑话我，当时的200人在我看来已经很多了），我截图给“师傅”发信息，激动的说我上首页候选区了，结果师傅都没搭理我。有了这次前车之鉴，我开始对一些单独的知识点整理，做技术博客，然后在排版各方面注意点，就基本能在首页候选区立足了。人是有野心的，征服了首页候选区后我开始准备如何上首页了，首页的审核比候选区的标准要高，我写了好几篇都没有通过，后来写了一篇《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/10661545.html&quot; target=&quot;_blank&quot;&gt;彻底填平static坑&lt;/a&gt;》&lt;span class=&quot;md-link&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;，这篇图文并茂，成功通过了博客园首页的审核，但是当时没想明白，这篇上了首页的阅读量居然没有首页候选区的高，百思不得其解，就不想了，至少也进步了。有了这两次经历后，我写博客就有自己套路了，然后就剩下坚持了，“师傅”说伟人之所以伟大，是因为他们坚持了别人不能坚持的，我也没想过要成为伟人啥的，但坚持是为了自己，既然没有更好的路可以走，那就选择一条可以走的路先坚持吧，有决定总比空想好。事实证明我选择的路是对的，随着坚持时间的增长，博客质量的提高，我的博客上首页的次数越来越多，有几次还上了首页的好几个榜（最多推荐，最多评论，48小时阅读排行，10天推荐排行），阅读量越来越多，我也越来越有信心。再到后面，算是我成熟点后吧，我想把自己理解消化了的知识整理成教程帮助新手学习，自己也能在整理的过程中复习提高，一举两得。我写的第一个教程是《&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/10666082.html&quot; target=&quot;_blank&quot;&gt;IDEA新手使用教程&lt;/a&gt;》&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/zyx110/p/10666082.html,&quot;&gt;,&lt;/a&gt;&lt;span class=&quot;md-plain&quot;&gt;这篇教程现在有4300多的阅读量，从百到千的转变就是我的成长，还有一次机会就是我的文章被脚本之家看好，推荐我去脚本之家投稿，我尝试了，好多文章都通过了脚本之家的审核并发布，我还赚到了很多稿费，这个就是意外的收获，还有就是博客园关注我的粉丝越来越多，支持点赞支持我甚至加我好友跟我聊天的朋友越来越多，我更加努力，更加喜欢写博客，因为爱所以执着，因为爱所以追求，这就是我在博客园五个月的经历和收获。我想分享给更多人，鼓励更多人跟我一起写博客，让更多人了解我，支持我，我敢倾囊分享，你愿意与我同行吗？&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;谁还在说写博客没用？&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我在写博客的过程中也听到过一些写博客无用论，我必须反驳他们，错，大错特错，你们说写博客没用是因为你们在“修仙”的时候没看到比你们优秀的人比你还努力，但这才是最可怕的，不要做井底之蛙，否则你的天空永远就是井口那么大。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;一些人不愿意写博客是因为不能坚持，还有一些人不愿意写博客也无非是担心以下几点：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;2&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;不知道写什么，摸着键盘敲不出字。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;总感觉自己的内心想法表达不出来。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;感觉写了没什么用，自己都明白了干嘛还要写。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;怕写出来被人笑话被人喷。（这个也是我经常害怕的）&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;写博客的费脑力，耗时间。还不如拿这精力去再学更多的东西。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对于这几点，我有自己的一些看法要表达：&lt;/span&gt;&lt;/p&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;9&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;万事开头难，我们不管做什么事，最难的是用零到一的过程，但是难才有挑战不是吗，简单的事情大家都会做，有难度的事才是需要能人去解决的，是平凡是伟大仅在一念之间而已。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;其实这个就是你自身存在的问题，内心想法表达不出来，说明你的表达能力还不够好，还有就是对知识点的理解不透彻，但这个问题才是你成长的基石啊，如果你想逃避这个问题，那你就只能在原地打转，永远到不了终点，我们的人生使命不就是解决问题吗，所以发现问题并不可怕，可怕的是你连面对问题的勇气都没有，这才是最可悲的，狭路相逢勇者胜，要想成功就不要犹豫了，时间不等人的。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;你明白了你能保证保持长期记忆吗？你明白了你能保证能给一个没学过的人讲明白吗？你整理的过程就是加深记忆的过程，你梳理简化知识的过程就是你提高的过程，因为在这个过程中你可能会遇到各种未知的问题，这需要你去查资料，去解决，在这过程中你可能引发更多的疑问，其实你写完博客你就会发现，你本来要总结的知识对你其实提高不是很大，也就是加深记忆，但通过总结引申出来的问题和知识才是你真正的收获和成长。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;这是一个锻炼你心智的过程，不以物喜,不以己悲，这是一种境界，需要我们去体验，这对你或许是一个锻炼机会。还有，真正的勇士敢于直面惨淡的人生，敢于正视淋漓的鲜血，对勇士来说，这还算事吗。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;大家都知道，凡是费脑力的事肯定是经过思考的，你的提升就来源于思考，而且知识不是一天两天就能学完的，它是一个长期积累的过程，而写博客记录了你的学习过程，还有什么能比这个更能证明你的能力，我觉得这才是最好的简历，是你找工作的利器。&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;别犹豫了，给你几条写博客的理由&lt;/span&gt;&lt;/h2&gt;
&lt;ol class=&quot;ol-list&quot; readability=&quot;9&quot;&gt;&lt;li class=&quot;md-list-item&quot; readability=&quot;0&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;写博客有很多好处，却没有任何明显的坏处&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;，&lt;strong&gt;用博客的形式来记录下你有价值的思考&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;，&lt;strong&gt;积累的多了，你的价值也就大了。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;能够交到很多志同道合的朋友&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;，&lt;strong&gt;我们交朋友，需要先互相聊天，交流观点，然后才逐渐熟悉起来，这需要一个较长的过程，而且更糟糕的是，当你遇到另一个陌生人，又要把整个过程重复一次，表达你已经对老友表达过的那番想法。可博客却做到了“一次表达，无数次阅读”，当我看到一个写了好几年的博客，看完了之后我仿佛和这个人交谈了很久，用程序员们喜欢听的话来说就是，“博客极大地增强了话语的复用性”。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;去教一个完全不懂的人，则是一种最最强大和彻底的反思途径&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;，&lt;strong&gt;有一种学习方法叫费曼学习法，就是把知识理解后用最通俗易懂的方式教给别人，这是公认最好的学习方法。老师常说，“教”是最好的“学”，如果一件事情你不能用自己的话表述出来，十有八九就是你还没有完全理解。要让一个不明白的人做到明白，这就需要我们对我们大脑中整个的知识体系来个寻根究底，把大脑中的那些我们知道、但不知道自己知道的潜在概念或假设都挖出来，把它们从内隐记忆拉扯到外显记忆中。因为只有完全知道、并知道自己知道一切来龙去脉的人，才能真正把一件事情讲得通通透透。*&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;你的受众越是不懂，你需要反思得就越深刻&lt;/em&gt;&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;*&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;2&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;strong&gt;讨论是绝佳的反思&lt;/strong&gt;&lt;span class=&quot;md-plain&quot;&gt;，&lt;strong&gt;如果你公开你的想法，几乎总能看到与你持不同意见的人，然后你通过比较你和他的观念之间的差别，会发现你们在一开始的思路上就存在差异，差异从哪里来的？在进一步讨论中你们就会不断地迫使对方拿出更深层次的理由，这同样也是一种非常有效地促使自己反思的方法，在讨论的过程中双方的理由自然会变得越来越深入，越来越接近问题的本质，一些平时难以注意到的深层面的差异性就会逐渐浮现出来，你也就多了一次难得的机会去审视自己的思维中到底存放了哪些错误的信息。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;激励你去持续学习和思考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;学会持之以恒地做一件事情&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li class=&quot;md-list-item&quot; readability=&quot;-1&quot;&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;一个长期的价值博客是一份很好的简历&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;h2 class=&quot;md-end-block md-heading&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;结束语&lt;/span&gt;&lt;/h2&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;我承认一些话术是我参考自两个大神博客，以我目前的实力，还整理不出如此意味深长的话术，我会继续努力的。最后附上一幅图，希望有所思，有所悟。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-tab&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1640688/201908/1640688-20190822163350004-857735090.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-image md-img-loaded&quot; data-src=&quot;C:%5CUsers%5CLenovo%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1566462844206.png&quot;&gt;&lt;img src=&quot;file://c/Users/Lenovo/AppData/Roaming/Typora/typora-user-images/1566462844206.png?lastModify=1566462914&quot; alt=&quot;&quot; data-local-refresh=&quot;true&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;参考文献：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/zhaopei/p/why_write_blog.html#4281776&quot;&gt;https://www.cnblogs.com/zhaopei/p/why_write_blog.html#4281776&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-link&quot;&gt;&lt;a href=&quot;https://blog.csdn.net/pongba/article/details/3896311&quot;&gt;https://blog.csdn.net/pongba/article/details/3896311&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;*****************************************************************************************************&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我的博客园地址：&lt;a href=&quot;https://www.cnblogs.com/zyx110/&quot;&gt;https://www.cnblogs.com/zyx110/&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;【原创声明】此篇为作者原创，未经本人同意不得转载，经本人同意转载请说明出处。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我不能保证我所说的都是对的，但我能保证每一篇都是用心去写的，我始终认同“分享的越多，你的价值增值越大”，欢迎大家关注我的技术分享“Java匹马行天下”和学习心得分享“匹马行天下”，在分享中进步，越努力越幸运，人生赢在转折处，改变从现在开始！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;支持我的朋友们记得点波推荐哦，您的肯定就是我前进的动力。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 22 Aug 2019 23:18:00 +0000</pubDate>
<dc:creator>泰斗贤若如</dc:creator>
<og:description>博客园五月纪念日——去你的写博无用论 纪念祝福 今天是我注册博客园的第五个月，此时此刻，我想吟诗一首： 你问我爱你有多深 我爱你有几分 我的情也真 我的爱也真 博客代表我的心 写博初心 为什么坚持写博</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zyx110/p/11395187.html</dc:identifier>
</item>
<item>
<title>番茄日志发布1.0.3版本-增加Kafka支持 - Ron.Liang</title>
<link>http://www.cnblogs.com/viter/p/11396640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/11396640.html</guid>
<description>&lt;p&gt;可能你是第一次听说TomatoLog，没关系，我可以从头告诉你，通过了解番茄日志，希望能帮助有需要的朋友，番茄日志处理将大大降低你采集、分析、处理日志的过程。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201904/26882-20190402183947715-774940439.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TomatoLog 是一个基于 .NETCore 平台的日志处理组件,包含客户端、服务端，非常容易使用和部署。&lt;/p&gt;
&lt;h2 id=&quot;多客户端实现&quot;&gt;多客户端实现&lt;/h2&gt;
&lt;p&gt;TomatoLog 的客户端和服务端目前都是基于 .NETCore 版本,客户端提供了三种日志流传输方式，目前实现了 Redis/RabbitMQ/Kafka流。如果希望使用非 .NETCore 平台的客户端，你可以自己开放其它第三方语言的客户端，通过实现 TomatoLog 传输协议，将数据传送到管道(Redis/RabbitMQ/Kafka)中即可。&lt;/p&gt;
&lt;h2 id=&quot;强大的日志存储方式&quot;&gt;强大的日志存储方式&lt;/h2&gt;
&lt;p&gt;TomatoLog 服务端还提供了三种存储日志的方式，分别是 File、MongoDB、Elasticsearch，存储方式可以通过配置文件指定。在 TomatoLog 服务端，我们还提供了一个Web 控制台，通过该控制台，可以对日志进行查询、搜索，对服务过滤器进行配置，警报配置、通知发送等等&lt;/p&gt;
&lt;h2 id=&quot;灵活多样的日志报警配置&quot;&gt;灵活多样的日志报警配置&lt;/h2&gt;
&lt;p&gt;其中，可使用的警报通知方式有：SMS 和 Email 两种方式，但是，SMS 其本质是一个 Http 请求，通过 SMS 的配置，可以实现向所有提供了 Http 接口的网关发送通知。&lt;/p&gt;

&lt;p&gt;为了开发支持Kafka，还得学习Kafka/Zookeeper，为了使用Kafka-Manager控制台，还学习Scala/sbt编译雅虎这个破项目，控制台我就起了四个，不说了，看图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190822202549352-1992819293.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;TomatoLogServer 服务器版本 1.0.3 ，主要增加了对Kafka的支持，服务端做了一些优化，在配置上，几乎没有改动，只需要在原来的基础上增加Kafka配置即可&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&quot;Kafka&quot;: {
        &quot;Group&quot;: &quot;TomatoLogServer&quot;,
        &quot;BootstrapServers&quot;: &quot;127.0.0.1:9092&quot;,
        &quot;Topic&quot;: &quot;TomatoLog&quot;
      }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时也增加了Kafka客户端的支持，当前版本为：1.0.3&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Install-Package TomatoLog.Client.Kafka&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用方式和其它Redis/RabbitMQ客户端是没有任何区别的，主要看下面的 WriteLogAsync() 方法，只要做好了 TomatoLogClientKafka 的配置，剩下的，就是调用 Exception 的扩展方法 ex.AddTomatoLogAsync()&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class TomatoLogClientKafkaTest
{

    [Fact]
    public async Task WriteLogAsync()
    {
        int i = 0;
        for (; i &amp;lt; 10; i++)
        {
            try
            {
                throw new Exception(&quot;Kafka throw exception&quot;);
            }
            catch (Exception ex)
            {
                ex.Data[&quot;connection&quot;] = &quot;127.0.0.1&quot;;
                await ex.AddTomatoLogAsync(1320);
            }
        }
        Assert.Equal(10, i);
    }

    ITomatoLogClient client;
    public TomatoLogClientKafkaTest()
    {
        var options = new EventKafkaOptions
        {
            Logger = null,
            LogLevel = Microsoft.Extensions.Logging.LogLevel.Information,
            ProjectLabel = &quot;20272&quot;,
            ProjectName = &quot;TomatoLog&quot;,
            SysOptions = new EventSysOptions
            {
                EventId = true,
                IP = true,
                IPList = true,
                MachineName = true,
                ProcessId = true,
                ProcessName = true,
                ThreadId = true,
                Timestamp = true,
                UserName = true
            },
            Tags = null,
            Version = &quot;1.0.1&quot;,
            BootstrapServers = &quot;127.0.0.1:9092&quot;,
            Topic = &quot;TomatoLog&quot;
        };
        client = new TomatoLogClientKafka(options);
    }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;首页看日志列表&quot;&gt;首页看日志列表&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190822202238790-1573151783.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;日志详情弹出查看详情日志搜索支持esmongodbfile搜索&quot;&gt;日志详情、弹出查看详情、日志搜索、支持ES/MongoDB/File搜索&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190822202255288-443865765.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;全局日志处理警报配置&quot;&gt;全局日志处理、警报配置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190822202300283-1657931620.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;针对单个项目的详细日志处理警报配置&quot;&gt;针对单个项目的详细日志处理、警报配置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201908/26882-20190822202305174-1497565500.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;不管是从项目结构还是解决方案，我都强调简单就是最美的根本要求，解决方案的内容虽然看起来很多，但是你也只需要按需引用其中一个客户端就可以了，服务端更是如此，全站都打包在一个 .NETCore 的应用程序中，程序的警报配置都是存储在配置文件中的，无需数据库支持。&lt;/p&gt;
&lt;p&gt;看到这里，其实完全就可以点赞了。谢谢大家！&lt;/p&gt;

&lt;p&gt;优秀的微服务网关Kong的.NETCore中唯一客户端&lt;br/&gt;&lt;a href=&quot;https://github.com/lianggx/Kong.Net&quot; class=&quot;uri&quot;&gt;https://github.com/lianggx/Kong.Net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;基于.NETCore+PostgreSQL的快速开发脚手架&lt;br/&gt;&lt;a href=&quot;https://github.com/lianggx/mystaging&quot; class=&quot;uri&quot;&gt;https://github.com/lianggx/mystaging&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Asp.NETCore轻松学系列的开源实例代码&lt;br/&gt;&lt;a href=&quot;https://github.com/lianggx/EasyAspNetCoreDemo&quot; class=&quot;uri&quot;&gt;https://github.com/lianggx/EasyAspNetCoreDemo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;好了，这下我真的没啥家底了，都抖露给你们看完了。&lt;/p&gt;
</description>
<pubDate>Thu, 22 Aug 2019 23:14:00 +0000</pubDate>
<dc:creator>Ron.Liang</dc:creator>
<og:description>番茄日志（TomatoLog）能做什么 可能你是第一次听说TomatoLog，没关系，我可以从头告诉你，通过了解番茄日志，希望能帮助有需要的朋友，番茄日志处理将大大降低你采集、分析、处理日志的过程。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viter/p/11396640.html</dc:identifier>
</item>
<item>
<title>Laravel框架内实现api文档:markdown转为html - 翟码农</title>
<link>http://www.cnblogs.com/drunkhero/p/11397605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/drunkhero/p/11397605.html</guid>
<description>&lt;p&gt;前后端分离的工作模式于今是非常流行了，前后端工作的对接，就离开不了API文档的辅助。&lt;/p&gt;

&lt;p&gt;根据自己以往的工作经历，以及了解的一些资讯，API文档的建立，无非以下几种方式：&lt;/p&gt;
&lt;p&gt;1. word文档模板&lt;/p&gt;
&lt;p&gt;2. 第三方平台，类如postman、showdoc等&lt;/p&gt;
&lt;p&gt;3. 框架内单独自定义一套绑定路由的结构，再解析成html页面&lt;/p&gt;
&lt;p&gt;4. 在框架内每个路由的方法的注释块里按照规则写注释，再解析生成api文档&lt;/p&gt;
&lt;p&gt;5. 框架内直接编辑markdown文件，再转换成html页面&lt;/p&gt;

&lt;p&gt;根据自己的使用心得，发表一下个人看法。&lt;/p&gt;
&lt;h3&gt;1.word文档模板：&lt;/h3&gt;
&lt;p&gt;这是在第一家公司--富士康科技集团--接触到的，就是公司准备好了一个API文档的模板，每个api对应一个表格，在表格里填上对应的路径(path)，调用方式(method)、请求参数，返回数据结构等信息。对于刚开始新增api是ok的，当时测试工作和后端正好在不同城市，api文档可以起到很好的沟通作用。但对于后期维护，总要完善了一个接口，就要对应的去word文档里查找并修改，一旦后端没有或忘记更新了，随着时间过着越久，反而后面越容易把自己带到坑里去。&lt;/p&gt;

&lt;p&gt;优点：前期工作少，拿个模板就可以开写了。&lt;/p&gt;
&lt;p&gt;缺点：更新接口不是很方便。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;2.第三方平台：&lt;/h3&gt;
&lt;p&gt;工作经历中有一家用到，无非就是把api信息录入到第三方平台，本人很是反感。尤其是需要像form表单一样一个个栏位填写，一个个接口的添加，简直是作践后端的时间价值。维护？简直是更乱，因为第三方平台需要登录账号，每多一小步，人发懒的概率就越大，时间久了，api文档不同步的概率和范围就更大更广。&lt;/p&gt;

&lt;p&gt;工作中现在我一直用postman测试接口，所以postman是必用的工具。至于用它写api文档是否支持又是否方便，本人没有接触过，就不发表看法了。&lt;/p&gt;
&lt;p&gt;showDoc是编辑markdown方式，对于添加API接口，撰写体验还是很不错的。但接口信息像postman一样一条条分开的，查找浏览不方便，维护一般首先就是要查找，所以维护体验也感觉很不好。所以以往有的公司，项目涉及到成员多批变迁时，就有那种同一个功能出现几个不同的api。因为新增接口信息可以避免去了解去确认此功能接口之前是否已经撰写过，人都有惰性，就干脆直接新增了接口文档记录，结果就自然导致同样接口的文档记录有两三条，文档就慢慢失去了原本的价值：辅助新员工快速了解功能和开展工作。&lt;/p&gt;

&lt;p&gt;那什么时候考虑第三方平台呢？&lt;/p&gt;
&lt;p&gt;有的第三方平台实现了接口功能实时监控及安全防护，就是有受到攻击或者接口挂掉的情况时，可以给你手机发短信通知你。如果你非常需要这个，那你就用吧。&lt;/p&gt;

&lt;p&gt;优点：前期工作少，有可能带有接口安全防护和实时监控，避免因为接口挂掉带来利益损失。&lt;/p&gt;
&lt;p&gt;缺点：不仅多了一步登录操作，而且大多产品设计的页面体验不好，不利于快速新增及更新文档，管理不好的话，容易失去文档的本身价值。&lt;/p&gt;
&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;3.自定义绑定路由的结构：&lt;/h3&gt;
&lt;p&gt;这是我自己起的名字，可能不太准确。&lt;/p&gt;
&lt;p&gt;大体实现方式就是，接口写好了并定好了路由，就在另外一个php文件针对每一条路由用php语言来定义好一个api文档所需要的信息。&lt;/p&gt;
&lt;p&gt;例如如下：&lt;/p&gt;
&lt;pre&gt;
$app-&amp;gt;route(&quot;user/getlist&quot;)&lt;br/&gt;-&amp;gt;request(&lt;br/&gt;array(&lt;br/&gt;'page' =&amp;gt; '1 //第几页',&lt;br/&gt;'page_size' =&amp;gt; '10 //每页数据条数'&lt;br/&gt;)&lt;br/&gt;)&lt;br/&gt;-&amp;gt;method('post')&lt;br/&gt;-&amp;gt;response(&lt;br/&gt;array(&lt;br/&gt;'data' =&amp;gt; array(&lt;br/&gt;'total_count' =&amp;gt; '199 //总记录条数',&lt;br/&gt;'list' =&amp;gt; array(&lt;br/&gt;'username' =&amp;gt; 'coderzhai //姓名',&lt;br/&gt;'gender' =&amp;gt; '1  //1-男 2-女'&lt;br/&gt;)&lt;br/&gt;)&lt;br/&gt;)&lt;br/&gt;)
&lt;/pre&gt;
&lt;p&gt;然后自己再根据上述结构解析出对应数据展示在页面里。&lt;/p&gt;

&lt;p&gt;优点：跟后端代码一起，文档更新及维护更方便。文档按功能划分、按区域划分、按版本划分、增加用户权限控制等实现比较方便。&lt;/p&gt;
&lt;p&gt;缺点：由于以上代码是用php语言编写的，一旦遇上哪里少了括号或是逗号等php语法错误，就会造成文档页面无法浏览。还需要费时间的去找到问题的所在并及时修复它。接口路由不适宜用resource组合的，因为具体对应增删查改哪几个接口不好确定。&lt;/p&gt;

&lt;h3&gt;4.利用方法的注释块生成api文档&lt;/h3&gt;
&lt;p&gt;这种方式是了解apidoc时了解到的，就是按照规定的规则在接口方法的注释块里备注信息，类如如下：&lt;/p&gt;
&lt;pre&gt;
/**&lt;br/&gt;* @api {get} /user/:id Request User information&lt;br/&gt;* @apiName GetUser&lt;br/&gt;* @apiGroup User&lt;br/&gt;*&lt;br/&gt;* @apiParam {Number} id Users unique ID.&lt;br/&gt;*&lt;br/&gt;* @apiSuccess {String} firstname Firstname of the User.&lt;br/&gt;* @apiSuccess {String} lastname  Lastname of the User.&lt;br/&gt;*&lt;br/&gt;* @apiSuccessExample Success-Response:&lt;br/&gt;*     HTTP/1.1 200 OK&lt;br/&gt;*     {&lt;br/&gt;*       &quot;firstname&quot;: &quot;John&quot;,&lt;br/&gt;*       &quot;lastname&quot;: &quot;Doe&quot;&lt;br/&gt;*     }&lt;br/&gt;*&lt;br/&gt;* @apiError UserNotFound The id of the User was not found.&lt;br/&gt;*&lt;br/&gt;* @apiErrorExample Error-Response:&lt;br/&gt;*     HTTP/1.1 404 Not Found&lt;br/&gt;*     {&lt;br/&gt;*       &quot;error&quot;: &quot;UserNotFound&quot;&lt;br/&gt;*     }&lt;br/&gt;*/
&lt;/pre&gt;
&lt;p&gt;以上是我从网上随便粘贴的一段，虽说本人写代码不是非常洁癖，但这么一大串的注释，本人看着就表示不爽，所以没一点深入了解它的欲望。不介意的就自行研究喽。&lt;/p&gt;

&lt;p&gt;优点：同后端代码一起，更新维护距离近在咫尺。&lt;/p&gt;
&lt;p&gt;缺点：注释太大块了，感觉影响看功能，代码显得十分拖沓，影响美观。&lt;/p&gt;

&lt;h3&gt; &lt;/h3&gt;
&lt;h3&gt;5.框架内直接编辑markdown文件&lt;/h3&gt;
&lt;p&gt;这就是我目前最喜欢的方式，也是本文要讲解实现的方式。&lt;/p&gt;

&lt;p&gt;优点：同后端代码一起，维护方便；markdown格式编写，文档撰写省时；所有接口在一个页面或几个划分好的页面里，方便浏览和查找。&lt;/p&gt;
&lt;p&gt;缺点：要做一些前期工作来实现。但现在有了现成的插件和本文的教程支持，缺点就可以忽略不计了。&lt;/p&gt;


&lt;p&gt;以上几种方式都比较完了，现在我就来实现在Laravel内撰写Api文档，支持网页浏览。&lt;/p&gt;

&lt;p&gt;要实现的功能主要就是把指定的md文件转换成html。&lt;/p&gt;
&lt;p&gt;github上有一个人气很旺的插件：erusev/parsedown, 地址：&lt;a href=&quot;https://github.com/erusev/parsedown&quot; target=&quot;_blank&quot;&gt;php解析markdown为html的插件:erusev/parsedown&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一般项目涉及PC后台，我这里就新增一个路由文件专门来放这些后台的api。&lt;/p&gt;

&lt;h4&gt;1.安装erusev/parsedown插件。&lt;/h4&gt;
&lt;p&gt;编辑composer.json文件，添加代码如下：&lt;/p&gt;
&lt;pre&gt;
 &quot;require&quot;: {&lt;br/&gt;&quot;php&quot;: &quot;^7.1.3&quot;,&lt;br/&gt;&quot;fideloper/proxy&quot;: &quot;^4.0&quot;,&lt;br/&gt;&quot;laravel/framework&quot;: &quot;5.7.*&quot;,&lt;br/&gt;&quot;laravel/tinker&quot;: &quot;^1.0&quot;,&lt;br/&gt;&quot;erusev/parsedown&quot;:&quot;^1.6&quot;  //新增的&lt;br/&gt;},
&lt;/pre&gt;

&lt;p&gt;项目根目录下执行composer install进行安装。在vendor文件夹下可看到erusev文件夹，则代表安装成功。&lt;/p&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;2.在app/Providers/RouteServiceProvider.php中引入自定义的后台路由文件。&lt;/h4&gt;
&lt;pre readability=&quot;7&quot;&gt;
public function map()&lt;br/&gt;{&lt;br/&gt;$this-&amp;gt;mapApiRoutes();&lt;br/&gt;$this-&amp;gt;mapWebRoutes();&lt;br/&gt;//新增的后台路由&lt;br/&gt;$this-&amp;gt;mapAdminRoutes();&lt;br/&gt;}&lt;p&gt;protected function mapAdminRoutes()&lt;br/&gt;{&lt;br/&gt;Route::prefix('admin')&lt;br/&gt;//    -&amp;gt;middleware('api')   //避免篇幅过长，中间件的引入这里就忽略了&lt;br/&gt;-&amp;gt;namespace($this-&amp;gt;namespace)&lt;br/&gt;-&amp;gt;group(base_path('routes/admin.php'));&lt;br/&gt;}
&lt;/p&gt;&lt;/pre&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;3.添加路由，添加控制器，先调试，要可以成功进入控制器方法。&lt;/h4&gt;
&lt;p&gt;routes问价下新增admin.php文件，里面加上我们的api文档路由：&lt;/p&gt;
&lt;pre&gt;
Route::get('/apidoc', 'Admin\ApiDocController@showDoc');  //注意后面是反斜杠\,否则会报错
&lt;/pre&gt;
&lt;p&gt;laravel框架入口是public/index.php,为了隐藏这个就自定义个本地解析的名称，编辑apache的httpd-vhosts文件如下：&lt;/p&gt;
&lt;pre&gt;
&amp;lt;VirtualHost *:80&amp;gt;&lt;br/&gt;ServerName testlaravel&lt;br/&gt;DocumentRoot E:/wamp64/www/laravel/public&lt;br/&gt;&amp;lt;Directory  &quot;E:/wamp64/www/laravel/public/&quot;&amp;gt;&lt;br/&gt;Options +Indexes +Includes +FollowSymLinks +MultiViews&lt;br/&gt;AllowOverride All&lt;br/&gt;Allow from all&lt;br/&gt;Header set Access-Control-Allow-Origin  *&lt;br/&gt;&amp;lt;/Directory&amp;gt;&lt;br/&gt;RewriteEngine On&lt;br/&gt;RewriteCond $1 !^(index\.php|images|robots\.txt)&lt;br/&gt;RewriteRule ^(.*)$ /index.php/$1 [L]&lt;br/&gt;&amp;lt;/VirtualHost&amp;gt;
&lt;/pre&gt;
&lt;p&gt;编辑好后，重启apache服务。&lt;/p&gt;

&lt;p&gt;现在来加控制器，laravel可以用artisan命令生成，方便快捷。在项目根目录执行如下命令：&lt;/p&gt;
&lt;pre&gt;
php artisan &lt;a href=&quot;make:controller&quot;&gt;make:controller&lt;/a&gt; Admin/ApiDocController
&lt;/pre&gt;
&lt;p&gt;接下来编辑controller文件：&lt;/p&gt;
&lt;pre readability=&quot;10&quot;&gt;
&amp;lt;?php&lt;p&gt;namespace App\Http\Controllers\Admin;&lt;/p&gt;&lt;p&gt;use Illuminate\Http\Request;&lt;br/&gt;use App\Http\Controllers\Controller;&lt;/p&gt;&lt;p&gt;class ApiDocController extends Controller&lt;br/&gt;{&lt;br/&gt;public function showDoc(Request $request){&lt;br/&gt;echo &quot;hello coder&quot;;&lt;br/&gt;}&lt;br/&gt;}&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;浏览器输入http://laraveltest/admin/apidoc,直到出现hello coder后才可以进行后面步骤。&lt;/p&gt;
&lt;h4&gt; &lt;/h4&gt;
&lt;h4&gt;4. 使用插件实现markdown转为html&lt;/h4&gt;
&lt;p&gt;功能很简单，就直接上代码啦。&lt;/p&gt;
&lt;pre readability=&quot;18&quot;&gt;
&amp;lt;?php&lt;p&gt;namespace App\Http\Controllers\Admin;&lt;/p&gt;&lt;p&gt;use Illuminate\Http\Request;&lt;br/&gt;use App\Http\Controllers\Controller;&lt;br/&gt;use Parsedown;&lt;/p&gt;&lt;p&gt;class ApiDocController extends Controller&lt;br/&gt;{&lt;br/&gt;public function __construct(){&lt;br/&gt;$this-&amp;gt;markdownParser = new Parsedown();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public function showDoc(Request $request){&lt;br/&gt;$fileContent = file_get_contents(storage_path('doc/admin_api.md'));&lt;br/&gt;$htmlContent = $this-&amp;gt;convertMarkdownToHtml($fileContent);&lt;br/&gt;$content = $this-&amp;gt;convertMarkdownToHtml($htmlContent);&lt;br/&gt;return view('apidoc_admin')-&amp;gt;with('content',$content);&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;public function convertMarkdownToHtml($markdown)&lt;br/&gt;{&lt;br/&gt;$convertedHmtl = $this-&amp;gt;markdownParser-&amp;gt;setBreaksEnabled(true)-&amp;gt;text($markdown);&lt;br/&gt;return $convertedHmtl;&lt;br/&gt;}&lt;br/&gt;}&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;本文推荐的就是用markdown编辑api的方式，md就是markdown文件的后缀，我现在把这个文件放在storage/doc/admin_api.md处。&lt;/p&gt;
&lt;p&gt;为了测试，我暂时在文件里粘贴了一个markdown格式的api：&lt;/p&gt;
&lt;pre readability=&quot;26&quot;&gt;
**简要描述：** &lt;p&gt;- 用户登录接口&lt;/p&gt;&lt;p&gt;**请求URL：** &lt;br/&gt;- ` http://xx.com/api/user/login `&lt;/p&gt;&lt;p&gt;**请求方式：**&lt;br/&gt;- POST &lt;/p&gt;&lt;p&gt;**参数：** &lt;/p&gt;&lt;p&gt;|参数名|必选|类型|说明|&lt;br/&gt;|:----    |:---|:----- |-----   |&lt;br/&gt;|username |是  |string |用户名   |&lt;br/&gt;|password |是  |string | 密码    |&lt;/p&gt;&lt;p&gt;**返回示例**&lt;br/&gt;``` &lt;br/&gt;{&lt;br/&gt;&quot;error_code&quot;: 0,&lt;br/&gt;&quot;data&quot;: {&lt;br/&gt;&quot;uid&quot;: &quot;1&quot;,&lt;br/&gt;&quot;username&quot;: &quot;zhai coder&quot;,&lt;br/&gt;&quot;name&quot;: &quot;翟码农&quot;,&lt;br/&gt;&quot;groupid&quot;: 2 ,&lt;br/&gt;&quot;reg_time&quot;: &quot;2019-08-01&quot;,&lt;br/&gt;&quot;last_login_time&quot;: &quot;0&quot;,&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;```&lt;br/&gt;**返回参数说明** &lt;/p&gt;&lt;p&gt;|参数名|类型|说明|&lt;br/&gt;|:-----  |:-----|-----                           |&lt;br/&gt;|groupid |int   |用户组id，1：超级管理员；2：普通用户  |&lt;/p&gt;&lt;p&gt;**备注** &lt;/p&gt;&lt;p&gt;- 更多返回错误代码请看首页的错误代码描述&lt;/p&gt;&lt;/pre&gt;
&lt;p&gt;最后还需要准备好一个view文件。&lt;/p&gt;
&lt;p&gt;我是创建在resources/views文件夹下的，文件名为：apidoc_admin.blade.php。&lt;/p&gt;
&lt;p&gt;方便表达我强烈的推荐意愿，css样式我都给大家调好了，大家直接拿去用吧。&lt;/p&gt;
&lt;pre&gt;
&amp;lt;!doctype html&amp;gt;&lt;br/&gt;&amp;lt;html lang=&quot;{{ str_replace('_', '-', app()-&amp;gt;getLocale()) }}&quot;&amp;gt;&lt;br/&gt;&amp;lt;head&amp;gt;&lt;br/&gt;&amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;&lt;br/&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;&lt;br/&gt;&amp;lt;title&amp;gt;Laravel&amp;lt;/title&amp;gt;&lt;br/&gt;&amp;lt;style&amp;gt;&lt;br/&gt;html, body {&lt;br/&gt;background-color: #fff;&lt;br/&gt;color: #636b6f;&lt;br/&gt;font-family: 'Nunito', sans-serif;&lt;br/&gt;font-weight: 200;&lt;br/&gt;height: 100vh;&lt;br/&gt;margin: 0;&lt;br/&gt;color:#222;  }&lt;br/&gt;.container{&lt;br/&gt;width:800px;&lt;br/&gt;margin:10px auto;&lt;br/&gt;padding:20px;&lt;br/&gt;border-left:2px solid silver;&lt;br/&gt;border-right:2px solid silver; }&lt;br/&gt;table th,td{&lt;br/&gt;border:1px solid #ede;&lt;br/&gt;padding:5px 10px; }&lt;br/&gt;pre{&lt;br/&gt;background: #666;&lt;br/&gt;color: white;&lt;br/&gt;padding: 20px 10px;&lt;br/&gt;font-family: yahei;&lt;br/&gt;overflow: auto; }&lt;br/&gt;li code{&lt;br/&gt;font-size: 28px;&lt;br/&gt;color: #4eb4ee;&lt;br/&gt;font-weight: bold;&lt;br/&gt;}&lt;br/&gt;&amp;lt;/style&amp;gt;&lt;br/&gt;&amp;lt;/head&amp;gt;&lt;br/&gt;&amp;lt;body&amp;gt;&lt;br/&gt;&amp;lt;div class=&quot;container&quot;&amp;gt;&lt;br/&gt;{!! $content !!}&lt;br/&gt;&amp;lt;/div&amp;gt;&lt;br/&gt;&amp;lt;/body&amp;gt;&lt;br/&gt;&amp;lt;/html&amp;gt;
&lt;/pre&gt;

&lt;p&gt;到这里，所有工作算是完成了。&lt;/p&gt;
&lt;p&gt;在浏览器输入api文档访问地址：&lt;/p&gt;
&lt;pre&gt;
http://testlaravel/admin/apidoc
&lt;/pre&gt;
&lt;p&gt;一幅如画卷般的文档页面就出来喽。&lt;/p&gt;

</description>
<pubDate>Thu, 22 Aug 2019 16:19:00 +0000</pubDate>
<dc:creator>翟码农</dc:creator>
<og:description>前后端分离的工作模式于今是非常流行了，前后端工作的对接，就离开不了API文档的辅助。 根据自己以往的工作经历，以及了解的一些资讯，API文档的建立，无非以下几种方式： 1. word文档模板 2</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/drunkhero/p/11397605.html</dc:identifier>
</item>
<item>
<title>逻辑回归(Logistic Regression)详解,公式推导及代码实现 - VitoLin</title>
<link>http://www.cnblogs.com/VitoLin21/p/11395753.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/VitoLin21/p/11395753.html</guid>
<description>&lt;h3&gt;什么是逻辑回归:&lt;/h3&gt;
&lt;p&gt;　　逻辑回归(Logistic Regression)是一种基于概率的模式识别算法,虽然名字中带&quot;回归&quot;,但实际上是一种分类方法,在实际应用中,逻辑回归可以说是应用最广泛的机器学习算法之一&lt;/p&gt;
&lt;h3&gt;回归问题怎么解决分类问题?&lt;/h3&gt;
&lt;p&gt;　　将样本的特征和样本发生的概率联系起来,而概率是一个数.换句话说,我预测的是这个样本发生的概率是多少,所以可以管它叫做回归问题&lt;/p&gt;

&lt;p&gt;在许多机器学习算法中,我们都是在追求这样的一个函数&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822174351055-1891083045.png&quot; alt=&quot;&quot; width=&quot;171&quot; height=&quot;71&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 例如我们希望预测一个学生的成绩y,将现有数据x输入模型 f(x) 中,便可以得到一个预测成绩y&lt;/p&gt;
&lt;p&gt;但是在逻辑回归中,我们得到的y的值本质是一个概率值p&lt;/p&gt;
&lt;p&gt;　 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822181912541-1480690010.png&quot; alt=&quot;&quot; width=&quot;144&quot; height=&quot;61&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在得到概率值p之后根据概率值来进行分类&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822182015824-1125275126.png&quot; alt=&quot;&quot; width=&quot;260&quot; height=&quot;156&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然了这个1和0在不同情况下可能有不同的含义,比如0可能代表恶性肿瘤患者,1代表良性肿瘤患者&lt;/p&gt;
&lt;p&gt;逻辑回归既可以看做是回归算法，也可以看做是分类算法,通常作为分类算法用，只可以解决二分类问题,不过我们可以使用一些其他的技巧(OvO,OvR),使其支持解决多分类问题&lt;/p&gt;

&lt;p&gt;下面我们来看一下逻辑回归使用什么样的方法来得到一个事件发生的概率的值&lt;/p&gt;
&lt;p&gt; 在线性回归中,我们使用&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822184635784-1631745171.png&quot; alt=&quot;&quot; width=&quot;324&quot; height=&quot;38&quot;/&gt;&lt;/p&gt;
&lt;p&gt;来计算,要注意,因为Θ&lt;sub&gt;0&lt;/sub&gt;的存在,所以x用小的X&lt;sub&gt;b&lt;/sub&gt;来表示,就是每来一个样本,前面还还要再加一个1,这个1和Θ&lt;sub&gt;0&lt;/sub&gt;相乘得到的是截距,但是不管怎样,这种情况下,y的值域是(-infinity, +infinity)&lt;/p&gt;
&lt;p&gt;而对于概率来讲,它有一个限定,其值域为[0,1]&lt;/p&gt;
&lt;p&gt;所以我们如果直接使用线性回归的方式,去看能不能找到一组Θ来与特征x相乘之后得到的y值就来表达这个事件发生的概率呢?&lt;/p&gt;
&lt;p&gt;其实单单从应用的角度来说,可以这么做,但是这么做不够好,就是因为概率有值域的限制,而使用线性回归得到的结果则没有这个限制&lt;/p&gt;
&lt;p&gt;为此,我们有一个很简单的解决方案:&lt;/p&gt;
&lt;p&gt;我们将线性回归得到的结果再作为一个特征值传入一个新的函数,经过转换,将其转换成一个值域在[0,1]之间的值&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822190023981-2090013905.png&quot; alt=&quot;&quot; width=&quot;203&quot; height=&quot;70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sigmoid函数:&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822190657042-414793216.png&quot; alt=&quot;&quot; width=&quot;195&quot; height=&quot;106&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将函数绘制出来:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822190731151-305043519.png&quot; alt=&quot;&quot; width=&quot;336&quot; height=&quot;222&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其最左端趋近于0,最右端趋近于1,其值域在(0,1),这正是我们所需要的性质&lt;/p&gt;
&lt;p&gt;当传入的参数 t &amp;gt; 0 时, p &amp;gt; 0.5, t &amp;lt; 0 时, p &amp;lt; 0.5,分界点是 t = 0&lt;/p&gt;

&lt;p&gt;使用Sigmoid函数后:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822191656062-1357656374.png&quot; alt=&quot;&quot; width=&quot;392&quot; height=&quot;114&quot;/&gt;  &lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822191743323-1674063184.png&quot; alt=&quot;&quot; width=&quot;187&quot; height=&quot;95&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在的问题就是,给定了一组样本数据集X和它对应的分类结果y，我们如何找到参数Θ，使得用这样的方式可以最大程度的获得这个样本数据集X对应的分类输出y&lt;/p&gt;
&lt;p&gt;这就是我们在训练的过程中要做的主要任务,也就是拟合我们的训练样本,而拟合过程,就会涉及到&lt;strong&gt;逻辑回归的损失函数&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;逻辑回归的损失函数:&lt;/h4&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822195042347-1375998271.png&quot; alt=&quot;&quot; width=&quot;414&quot; height=&quot;128&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们定义了一个这样的损失函数:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822200227420-2065709814.png&quot; alt=&quot;&quot; width=&quot;422&quot; height=&quot;123&quot;/&gt;&lt;/p&gt;
&lt;p&gt;画出图像:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822200921490-1488595869.png&quot; alt=&quot;&quot; width=&quot;297&quot; height=&quot;217&quot;/&gt;&lt;/p&gt;
&lt;p&gt;让我们看一下这个函数有什么样的性质，据图像我们很容易发现:&lt;/p&gt;
&lt;p&gt;　　当y=1时，p趋近于零的时候，在这个时候可以看此时-log(p)趋近于正无穷，这是因为当p趋近于0的时候，按照我们之前的这个分类的方式，我们就会把这个样本分类成0这一类，但是这个样本实际是1这一类，显然我们分错了，那么此时我们对它进行惩罚，这个惩罚是正无穷的，随着p逐渐的增高，可以看我们的损失越来越小，当我们的p到达1的时候，也就是根据我们的分类标准，我们会将这个样本x分类成1，此时，它和这个样本真实的y等于1是一致的，那么此时损失函数取0也就是没有任何损失,当y=0时同理&lt;/p&gt;

&lt;p&gt;现在这个损失函数还是太过复杂,需要判定y的值,我们对其进行简化:&lt;/p&gt;
&lt;div&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822201820767-1084735047.png&quot; alt=&quot;&quot; width=&quot;550&quot; height=&quot;70&quot;/&gt;&lt;/div&gt;
&lt;p&gt;这个函数与上面的是等价的&lt;/p&gt;
&lt;p&gt;这样,根据我们求出的p,就可以得出这次估计的损失是多少&lt;/p&gt;
&lt;p&gt;最后,再把损失相加求平均值,其公式为:&lt;/p&gt;
&lt;div readability=&quot;107&quot;&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822202113045-2012535450.png&quot; alt=&quot;&quot; width=&quot;543&quot; height=&quot;91&quot;/&gt;&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822203136919-62932091.png&quot; alt=&quot;&quot; width=&quot;281&quot; height=&quot;81&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将两个式子整合:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822203313975-1253894130.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;97&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面我们要做的事情,就是找到一组Θ,使得J(Θ)最小&lt;/p&gt;
&lt;p&gt;对于这个式子,我们很难像线性回归那样推得一个正规方程解,实际上这个式子是没有数学解的,也就是无法把X和直接套进公式获得Θ&lt;/p&gt;
&lt;p&gt;不过,我们可以使用梯度下降法求得它的解,而且,这个损失函数是一个凸函数,不用担心局部最优解的,只存在全局最优解&lt;/p&gt;

&lt;p&gt;现在,我们的任务就是求出J(Θ)的梯度,使用梯度下降法来进行计算&lt;/p&gt;

&lt;p&gt;首先,求J(Θ)的梯度的公式:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822205704148-1995559028.png&quot; alt=&quot;&quot; width=&quot;174&quot; height=&quot;182&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先,我们对Sigmoid函数求导:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822210013094-232821843.png&quot; alt=&quot;&quot; width=&quot;320&quot; height=&quot;72&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822210026278-808360616.png&quot; alt=&quot;&quot; width=&quot;151&quot; height=&quot;49&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到其导数,再对logσ(t)求导,求导步骤:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822210223489-1226225013.png&quot; alt=&quot;&quot; width=&quot;383&quot; height=&quot;415&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此可知, 前半部分的导数:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822210420854-1583608228.png&quot; alt=&quot;&quot; width=&quot;429&quot; height=&quot;85&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　其中y&lt;sup&gt;(i)&lt;/sup&gt;是常数&lt;/p&gt;
&lt;p&gt;再求后半部分:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822210608278-365820556.png&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;59&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 这其中&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822210639132-1482607465.png&quot; alt=&quot;&quot; width=&quot;268&quot; height=&quot;104&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822210647722-1323361129.png&quot; alt=&quot;&quot; width=&quot;164&quot; height=&quot;115&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将结果代入,化简得:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822210831010-823749367.png&quot; alt=&quot;&quot; width=&quot;595&quot; height=&quot;275&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就得到后半部分的求导结果:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822210953185-1012342067.png&quot; alt=&quot;&quot; width=&quot;554&quot; height=&quot;84&quot;/&gt;&lt;/p&gt;
&lt;p&gt;将前后部分相加:&lt;/p&gt;
&lt;p&gt;　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822222305195-346776173.png&quot; alt=&quot;&quot; width=&quot;619&quot; height=&quot;159&quot;/&gt;&lt;/p&gt;
&lt;p&gt;即:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822222830191-1594685309.png&quot; alt=&quot;&quot; width=&quot;315&quot; height=&quot;70&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　  　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822222846528-143002224.png&quot; alt=&quot;&quot; width=&quot;227&quot; height=&quot;69&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就可以得到:&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822223114580-1878433037.png&quot; alt=&quot;&quot; width=&quot;487&quot; height=&quot;341&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时我们回忆一下线性回归的向量化过程&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822223628008-1228232030.png&quot; alt=&quot;&quot; width=&quot;517&quot; height=&quot;298&quot;/&gt;&lt;/p&gt;
&lt;p&gt;参考这个,可以得到:&lt;/p&gt;
&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822224540791-1719755329.png&quot; alt=&quot;&quot; width=&quot;503&quot; height=&quot;296&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是我们要求的梯度,再使用梯度下降法,就可以求得结果&lt;/p&gt;

&lt;h3&gt;决策边界:&lt;/h3&gt;
&lt;p&gt;这里引入一个概念，叫做判定边界，可以理解为是用以对不同类别的数据分割的边界，边界的两旁应该是不同类别的数据&lt;/p&gt;
&lt;p&gt;从二维直角坐标系中，举几个例子，大概是如下这个样子:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822230104732-319343019.png&quot; alt=&quot;&quot; width=&quot;339&quot; height=&quot;194&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822230020140-1972982775.png&quot; alt=&quot;&quot; width=&quot;341&quot; height=&quot;205&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822230226984-1721064037.png&quot; alt=&quot;&quot; width=&quot;345&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;使用OvR和OvO方法解决多分类:&lt;/h3&gt;
&lt;p&gt;原本的逻辑回归只能解决双分类问题,但我们可以通过一些方法,让它支持多分类问题,比如OvR和OvO方法&lt;/p&gt;
&lt;h3&gt;OvR:&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822231900557-1614451506.png&quot; alt=&quot;&quot; width=&quot;276&quot; height=&quot;236&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　n 种类型的样本进行分类时，分别取一种样本作为一类，将剩余的所有类型的样本看做另一类，这样就形成了 n 个二分类问题，使用逻辑回归算法对 n 个数据集训练出 n 个模型，将待预测的样本传入这 n 个模型中，所得概率最高的那个模型对应的样本类型即认为是该预测样本的类型&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822232030960-1410583567.png&quot; alt=&quot;&quot; width=&quot;578&quot; height=&quot;100&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　n个类别就进行n次分类，选择分类得分最高的&lt;/p&gt;
&lt;h3&gt; OvO:&lt;/h3&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822232151106-1994231028.png&quot; alt=&quot;&quot; width=&quot;390&quot; height=&quot;81&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1699361/201908/1699361-20190822232130389-2037683136.png&quot; alt=&quot;&quot; width=&quot;450&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　n 类样本中，每次挑出 2 种类型，两两结合，一共有 C&lt;sub&gt;n&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; 种二分类情况，使用 C&lt;sub&gt;n&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; 种模型预测样本类型，有 C&lt;sub&gt;n&lt;/sub&gt;&lt;sup&gt;2&lt;/sup&gt; 个预测结果，种类最多的那种样本类型，就认为是该样本最终的预测类型&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;这两种方法中,OvO的分类结果更加精确,因为每一次二分类时都用真实的类型进行比较，没有混淆其它的类别,但时间复杂度较高&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;代码实现 :&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;76&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; .metrics &lt;span&gt;import&lt;/span&gt;&lt;span&gt; accuracy_score
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LogisticRegression:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;初始化Linear Regression模型&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;         self.coef_ =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         self.intercept_ =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         self._theta =&lt;span&gt; None
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; _sigmoid(self, t):
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; 1. / (1. + np.exp(-&lt;span&gt;t))
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; fit(self, X_train, y_train, eta=0.01, n_iters=1e4&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;根据训练数据集X_train, y_train, 使用梯度下降法训练Logistic Regression模型&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;assert&lt;/span&gt; X_train.shape[0] ==&lt;span&gt; y_train.shape[0], \
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the size of X_train must be equal to the size of y_train&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;def&lt;/span&gt;&lt;span&gt; J(theta, X_b, y):
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             y_hat =&lt;span&gt; self._sigmoid(X_b.dot(theta))
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; - np.sum(y*np.log(y_hat) + (1-y)*np.log(1-y_hat)) /&lt;span&gt; len(y)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;except&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; float(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;inf&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;def&lt;/span&gt;&lt;span&gt; dJ(theta, X_b, y):
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; X_b.T.dot(self._sigmoid(X_b.dot(theta)) - y) /&lt;span&gt; len(X_b)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;def&lt;/span&gt; gradient_descent(X_b, y, initial_theta, eta, n_iters=1e4, epsilon=1e-8&lt;span&gt;):
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;             theta =&lt;span&gt; initial_theta
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             cur_iter =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;while&lt;/span&gt; cur_iter &amp;lt;&lt;span&gt; n_iters:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 gradient =&lt;span&gt; dJ(theta, X_b, y)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 last_theta =&lt;span&gt; theta
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 theta = theta - eta *&lt;span&gt; gradient
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (abs(J(theta, X_b, y) - J(last_theta, X_b, y)) &amp;lt;&lt;span&gt; epsilon):
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;                 cur_iter += 1
&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; theta
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;         X_b = np.hstack([np.ones((len(X_train), 1&lt;span&gt;)), X_train])
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         initial_theta = np.zeros(X_b.shape[1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         self._theta =&lt;span&gt; gradient_descent(X_b, y_train, initial_theta, eta, n_iters)
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; 
&lt;span&gt;51&lt;/span&gt;         self.intercept_ =&lt;span&gt; self._theta[0]
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;         self.coef_ = self._theta[1&lt;span&gt;:]
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt; 
&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; predict_proba(self, X_predict):
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;给定待预测数据集X_predict，返回表示X_predict的结果概率向量&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;assert&lt;/span&gt; self.intercept_ &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; None &lt;span&gt;and&lt;/span&gt; self.coef_ &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None, \
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;must fit before predict!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;         &lt;span&gt;assert&lt;/span&gt; X_predict.shape[1] ==&lt;span&gt; len(self.coef_), \
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the feature number of X_predict must be equal to X_train&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt; 
&lt;span&gt;65&lt;/span&gt;         X_b = np.hstack([np.ones((len(X_predict), 1&lt;span&gt;)), X_predict])
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; self._sigmoid(X_b.dot(self._theta))
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; predict(self, X_predict):
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;给定待预测数据集X_predict，返回表示X_predict的结果向量&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;70&lt;/span&gt;         &lt;span&gt;assert&lt;/span&gt; self.intercept_ &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt; None &lt;span&gt;and&lt;/span&gt; self.coef_ &lt;span&gt;is&lt;/span&gt; &lt;span&gt;not&lt;/span&gt;&lt;span&gt; None, \
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;must fit before predict!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;assert&lt;/span&gt; X_predict.shape[1] ==&lt;span&gt; len(self.coef_), \
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;the feature number of X_predict must be equal to X_train&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt; 
&lt;span&gt;75&lt;/span&gt;         proba =&lt;span&gt; self.predict_proba(X_predict)
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; np.array(proba &amp;gt;= 0.5, dtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; 
&lt;span&gt;78&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; score(self, X_test, y_test):
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         &lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;根据测试数据集 X_test 和 y_test 确定当前模型的准确度&lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt;         y_predict =&lt;span&gt; self.predict(X_test)
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; accuracy_score(y_test, y_predict)
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; 
&lt;span&gt;84&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__repr__&lt;/span&gt;&lt;span&gt;(self):
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;LogisticRegression()&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
</description>
<pubDate>Thu, 22 Aug 2019 15:26:00 +0000</pubDate>
<dc:creator>VitoLin</dc:creator>
<og:description>逻辑回归(Logistic Regression) 什么是逻辑回归: 逻辑回归(Logistic Regression)是一种基于概率的模式识别算法,虽然名字中带&amp;quot;回归&amp;quot;,但实际上</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/VitoLin21/p/11395753.html</dc:identifier>
</item>
<item>
<title>逆向破解之160个CrackMe —— 016 - 寂夜云</title>
<link>http://www.cnblogs.com/lonenysky/p/11397402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lonenysky/p/11397402.html</guid>
<description>&lt;p&gt;160 CrackMe 是比较适合新手学习逆向破解的CrackMe的一个集合一共160个待逆向破解的程序&lt;/p&gt;
&lt;p&gt;CrackMe:它们都是一些公开给别人尝试破解的小程序，制作 crackme 的人可能是程序员，想测试一下自己的软件保护技术，也可能是一位 cracker，想挑战一下其它 cracker 的破解实力，也可能是一些正在学习破解的人，自己编一些小程序给自己破。&lt;/p&gt;
&lt;p&gt;CrackMe简称CM。&lt;/p&gt;

&lt;table border=&quot;1&quot; align=&quot;left&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;编号&lt;/td&gt;
&lt;td&gt;作者&lt;/td&gt;
&lt;td&gt;保护方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;016&lt;/td&gt;
&lt;td&gt;bjanes&lt;/td&gt;
&lt;td&gt;Serial(VB5)&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;


&lt;h2&gt;工具 &lt;/h2&gt;
&lt;p&gt;x32dbg&lt;/p&gt;
&lt;p&gt;VB Decompiler Pro&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;爆破方式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;使用x32dbg打开016号程序&lt;/p&gt;
&lt;p&gt;右键 搜索-&amp;gt;当前模块-&amp;gt;字符串 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190822224058424-1278333689.png&quot; alt=&quot;&quot; width=&quot;999&quot; height=&quot;115&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看见了错误提示字符串地址&lt;span&gt;00403A69&lt;/span&gt;和正确提示字符串地址&lt;span&gt;00403AE9&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们进入错误提示字符串地址00403A69处向上查看&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;59&quot;&gt;
&lt;pre&gt;
&lt;span&gt;004039FE&lt;/span&gt; | 83C4 &lt;span&gt;18&lt;/span&gt;                  | &lt;span&gt;add&lt;/span&gt; esp,&lt;span&gt;18&lt;/span&gt;&lt;span&gt;                              |
&lt;/span&gt;&lt;span&gt;00403A01&lt;/span&gt; | &lt;span&gt;66&lt;/span&gt;:85FF                  | &lt;span&gt;test&lt;/span&gt;&lt;span&gt; di,di                              |
&lt;/span&gt;&lt;span&gt;00403A04&lt;/span&gt; | &lt;span&gt;75&lt;/span&gt; 1C                    | &lt;span&gt;jne&lt;/span&gt; bjcm20a.4&lt;span&gt;03A22&lt;/span&gt;&lt;span&gt;                      |跳转处 跳转到00403A22
&lt;/span&gt;&lt;span&gt;00403A06&lt;/span&gt; | 8B7D &lt;span&gt;08&lt;/span&gt;                  | &lt;span&gt;mov&lt;/span&gt; edi,dword ptr &lt;span&gt;ss:&lt;/span&gt;[ebp+&lt;span&gt;8&lt;/span&gt;&lt;span&gt;]            |
&lt;/span&gt;&lt;span&gt;00403A09&lt;/span&gt; | B8 &lt;span&gt;01000000&lt;/span&gt;              | &lt;span&gt;mov&lt;/span&gt; eax,&lt;span&gt;1&lt;/span&gt;&lt;span&gt;                               |
&lt;/span&gt;&lt;span&gt;00403A0E&lt;/span&gt; | &lt;span&gt;66&lt;/span&gt;:&lt;span&gt;0345&lt;/span&gt; E8               | &lt;span&gt;add&lt;/span&gt; ax,word ptr &lt;span&gt;ss:&lt;/span&gt;[ebp-&lt;span&gt;18&lt;/span&gt;&lt;span&gt;]             |
&lt;/span&gt;&lt;span&gt;00403A12&lt;/span&gt; | &lt;span&gt;0F80&lt;/span&gt; &lt;span&gt;94010000&lt;/span&gt;            | &lt;span&gt;jo&lt;/span&gt; bjcm20a.4&lt;span&gt;03BAC&lt;/span&gt;&lt;span&gt;                       |大跳
&lt;/span&gt;&lt;span&gt;00403A18&lt;/span&gt; | &lt;span&gt;8945&lt;/span&gt; E8                  | &lt;span&gt;mov&lt;/span&gt; dword ptr &lt;span&gt;ss:&lt;/span&gt;[ebp-&lt;span&gt;18&lt;/span&gt;&lt;span&gt;],eax           |
&lt;/span&gt;&lt;span&gt;00403A1B&lt;/span&gt; | 33DB                     | &lt;span&gt;xor&lt;/span&gt;&lt;span&gt; ebx,ebx                             |
&lt;/span&gt;&lt;span&gt;00403A1D&lt;/span&gt; | E9 5AFDFFFF              | &lt;span&gt;jmp&lt;/span&gt; bjcm20a.4&lt;span&gt;0377C&lt;/span&gt;&lt;span&gt;                      |
&lt;/span&gt;&lt;span&gt;00403A22&lt;/span&gt; | 33DB                     | &lt;span&gt;xor&lt;/span&gt;&lt;span&gt; ebx,ebx                             |
&lt;/span&gt;&lt;span&gt;00403A24&lt;/span&gt; | 8B35 A4104000            | &lt;span&gt;mov&lt;/span&gt; esi,dword ptr &lt;span&gt;ds:&lt;/span&gt;&lt;span&gt;[&amp;lt;&amp;amp;__vbaVarDup&amp;gt;]   |
&lt;/span&gt;&lt;span&gt;00403A2A&lt;/span&gt; | B9 &lt;span&gt;04000280&lt;/span&gt;              | &lt;span&gt;mov&lt;/span&gt; ecx,&lt;span&gt;80020004&lt;/span&gt;&lt;span&gt;                        |
&lt;/span&gt;&lt;span&gt;00403A2F&lt;/span&gt; | 894D &lt;span&gt;98&lt;/span&gt;                  | &lt;span&gt;mov&lt;/span&gt; dword ptr &lt;span&gt;ss:&lt;/span&gt;[ebp-&lt;span&gt;68&lt;/span&gt;&lt;span&gt;],ecx           |
&lt;/span&gt;&lt;span&gt;00403A32&lt;/span&gt; | B8 &lt;span&gt;0A000000&lt;/span&gt;              | &lt;span&gt;mov&lt;/span&gt; eax,A                               | &lt;span&gt;A:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;00403A37&lt;/span&gt; | 894D A8                  | &lt;span&gt;mov&lt;/span&gt; dword ptr &lt;span&gt;ss:&lt;/span&gt;[ebp-&lt;span&gt;58&lt;/span&gt;&lt;span&gt;],ecx           |
&lt;/span&gt;&lt;span&gt;00403A3A&lt;/span&gt; | BF &lt;span&gt;08000000&lt;/span&gt;              | &lt;span&gt;mov&lt;/span&gt; edi,&lt;span&gt;8&lt;/span&gt;&lt;span&gt;                               |
&lt;/span&gt;&lt;span&gt;00403A3F&lt;/span&gt; | 8D95 5&lt;span&gt;0FFFFFF&lt;/span&gt;            | &lt;span&gt;lea&lt;/span&gt; edx,dword ptr &lt;span&gt;ss:&lt;/span&gt;[ebp-B0]           | &lt;span&gt;edx:&lt;/span&gt;&lt;span&gt;EntryPoint
&lt;/span&gt;&lt;span&gt;00403A45&lt;/span&gt; | 8D4D B0                  | &lt;span&gt;lea&lt;/span&gt; ecx,dword ptr &lt;span&gt;ss:&lt;/span&gt;[ebp-&lt;span&gt;50&lt;/span&gt;&lt;span&gt;]           |
&lt;/span&gt;&lt;span&gt;00403A48&lt;/span&gt; | &lt;span&gt;8945&lt;/span&gt; &lt;span&gt;90&lt;/span&gt;                  | &lt;span&gt;mov&lt;/span&gt; dword ptr &lt;span&gt;ss:&lt;/span&gt;[ebp-&lt;span&gt;70&lt;/span&gt;&lt;span&gt;],eax           |
&lt;/span&gt;&lt;span&gt;00403A4B&lt;/span&gt; | &lt;span&gt;8945&lt;/span&gt; A0                  | &lt;span&gt;mov&lt;/span&gt; dword ptr &lt;span&gt;ss:&lt;/span&gt;[ebp-&lt;span&gt;60&lt;/span&gt;&lt;span&gt;],eax           |
&lt;/span&gt;&lt;span&gt;00403A4E&lt;/span&gt; | C785 58FFFFFF F0224000   | &lt;span&gt;mov&lt;/span&gt; dword ptr &lt;span&gt;ss:&lt;/span&gt;[ebp-A8],bjcm20a.4&lt;span&gt;022F&lt;/span&gt; | 4&lt;span&gt;022F0&lt;/span&gt;:L&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Wrong serial!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;00403A58&lt;/span&gt; | 89BD 5&lt;span&gt;0FFFFFF&lt;/span&gt;            | &lt;span&gt;mov&lt;/span&gt; dword ptr &lt;span&gt;ss:&lt;/span&gt;&lt;span&gt;[ebp-B0],edi           |
&lt;/span&gt;&lt;span&gt;00403A5E&lt;/span&gt; | FFD6                     | &lt;span&gt;call&lt;/span&gt;&lt;span&gt; esi                                |
&lt;/span&gt;&lt;span&gt;00403A60&lt;/span&gt; | 8D95 6&lt;span&gt;0FFFFFF&lt;/span&gt;            | &lt;span&gt;lea&lt;/span&gt; edx,dword ptr &lt;span&gt;ss:&lt;/span&gt;[ebp-A0]           | &lt;span&gt;edx:&lt;/span&gt;&lt;span&gt;EntryPoint
&lt;/span&gt;&lt;span&gt;00403A66&lt;/span&gt; | 8D4D C0                  | &lt;span&gt;lea&lt;/span&gt; ecx,dword ptr &lt;span&gt;ss:&lt;/span&gt;[ebp-&lt;span&gt;40&lt;/span&gt;&lt;span&gt;]           |
&lt;/span&gt;&lt;span&gt;00403A69&lt;/span&gt; | C785 68FFFFFF C8224000   | &lt;span&gt;mov&lt;/span&gt; dword ptr &lt;span&gt;ss:&lt;/span&gt;[ebp-&lt;span&gt;98&lt;/span&gt;],bjcm20a.4&lt;span&gt;022C&lt;/span&gt; | 4&lt;span&gt;022C8&lt;/span&gt;:L&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sorry, try again!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们看到了最近的跳转处是&lt;span&gt;00403A1D&lt;/span&gt; 该处是一个向上跳的&lt;span&gt;JMP&lt;/span&gt;明显不是我们要找的跳转，在往上&lt;span&gt;00403A12&lt;/span&gt;是一个向下的大跳也不是我们要找的跳转，再往上&lt;span&gt;00403A04&lt;/span&gt;是一个跳转到&lt;span&gt;00403A1D&lt;/span&gt;下发的地址可能是我们要找的跳转，在此处下断点&lt;/p&gt;
&lt;p&gt;F9运行，在输入框内输入任意数据，点击Check it按钮，没有在跳转处暂停，我们在下一条指令下设置断点，再次点击按钮，此时程序暂停到了我们的断点处&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190822225505985-1291223838.png&quot; alt=&quot;&quot; width=&quot;711&quot; height=&quot;297&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由此可知，程序是通过别处跳转到&lt;span&gt;00403A24&lt;/span&gt;处&lt;/p&gt;
&lt;p&gt;我在x32dbg内右键 搜索-&amp;gt;当前模块-&amp;gt;常数   在输入框内输入&lt;span&gt;00403A24&lt;/span&gt;点击确定&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190822225738011-990231918.png&quot; alt=&quot;&quot; width=&quot;301&quot; height=&quot;256&quot;/&gt;&lt;/p&gt;
&lt;p&gt;搜索到一处引用的地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190822225950681-862912678.png&quot; alt=&quot;&quot; width=&quot;426&quot; height=&quot;81&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击进入该地址，在此处下断点&lt;/p&gt;
&lt;p&gt;再次点击Check it 按钮&lt;/p&gt;
&lt;p&gt;此时程序停在了我们刚刚设置的断点处，我们单步向下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190822230238134-1570072297.png&quot; alt=&quot;&quot; width=&quot;826&quot; height=&quot;187&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时可以看出程序跳转到了错误信息提示处，我们将&lt;span&gt;00403A04&lt;/span&gt;处的指令改为&lt;span&gt;NOP&lt;span&gt;，F9运行&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190822230404798-1440148311.png&quot; alt=&quot;&quot; width=&quot;577&quot; height=&quot;161&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bingo~ 此时破解成功&lt;/p&gt;


&lt;h2&gt;&lt;span&gt;&lt;span&gt;注册机方式&lt;/span&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;我们使用VB Decompiler Pro打开016号程序&lt;/span&gt; &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190822231240419-1473238629.png&quot; alt=&quot;&quot; width=&quot;955&quot; height=&quot;597&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现和我们的014号程序代码一样&lt;/p&gt;
&lt;p&gt;附上我们的注册机代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
code = &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; i &lt;span&gt;in&lt;/span&gt; range(1, 10&lt;span&gt;):
    a &lt;/span&gt;= i ^ 2&lt;span&gt;
    code &lt;/span&gt;= code + str(a)[-1&lt;span&gt;]
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(code)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;得出结果为&lt;span&gt;301674501&lt;/span&gt;我们输入到输入框内，点击Check it按钮&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/784993/201908/784993-20190822231351660-1205160379.png&quot; alt=&quot;&quot; width=&quot;297&quot; height=&quot;261&quot;/&gt;&lt;/p&gt;
&lt;p&gt;bingo ~ 破解成功&lt;/p&gt;

</description>
<pubDate>Thu, 22 Aug 2019 15:16:00 +0000</pubDate>
<dc:creator>寂夜云</dc:creator>
<og:description>CrackMe —— 016 160 CrackMe 是比较适合新手学习逆向破解的CrackMe的一个集合一共160个待逆向破解的程序 CrackMe:它们都是一些公开给别人尝试破解的小程序，制作 c</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lonenysky/p/11397402.html</dc:identifier>
</item>
</channel>
</rss>