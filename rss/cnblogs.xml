<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>一起了解 .Net Foundation 项目 No.5 - Newbe36524</title>
<link>http://www.cnblogs.com/newbe36524/p/12359958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/newbe36524/p/12359958.html</guid>
<description>&lt;p&gt;.Net 基金会中包含有很多优秀的项目，今天就和笔者一起了解一下其中的一些优秀作品吧。&lt;/p&gt;

&lt;h2 id=&quot;中文介绍&quot;&gt;中文介绍&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;中文介绍内容翻译自英文介绍，主要采用意译、如与原文存在出入，请以原文为准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Couchbase-Lite-for-NET&quot;&gt;Couchbase Lite for .NET&lt;/h3&gt;
&lt;p&gt;该项目是采用 C# 语言基于 &lt;a href=&quot;https://developer.couchbase.com/mobile/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Couchbase Lite&lt;/a&gt; 的 Java 版本代码进行重制的 Couchbase Lite。&lt;/p&gt;
&lt;p&gt;Couchbase Lite 是一个全功能的、嵌入式的、轻量级的、原生良好的文档型 JSON 数据库。&lt;/p&gt;
&lt;p&gt;使用 Couchbase Lite ，您可以在轻量型设备上拥有全功能的 Couchbase 体验。您可以进行创建、更新、删除、查询、同步等等一系列操作。&lt;/p&gt;
&lt;h4 id=&quot;项目详情&quot;&gt;项目详情&lt;/h4&gt;
&lt;h4 id=&quot;相关链接&quot;&gt;相关链接&lt;/h4&gt;
&lt;h2 id=&quot;笔者简评&quot;&gt;笔者简评&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.infoq.cn/article/xmjUYPj1jxjkd4U7KwKT&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Couchbase&lt;/a&gt; 是一款冉冉升起的 NoSQL 数据库产品。 Couchbase Lite 则是其轻量版，主要支持运行在轻量型设备上。&lt;/p&gt;
&lt;p&gt;Couchbase Lite for .NET 则是采用 C# 编写的版本，其与 .Net 语言具有更好集成的互操作性。&lt;/p&gt;
&lt;p&gt;如果要深入的了解 NoSQL，仅仅只是了解 Mongdb 恐怕是不够的，排名第三的 Couchbase 了解一下？&lt;a href=&quot;https://db-engines.com/en/ranking/document+store&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;（截至 2020 年 1 月 19 日 17:05:52 ）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;英文介绍&quot;&gt;英文介绍&lt;/h2&gt;
&lt;h3 id=&quot;Couchbase-Lite-for-NET-1&quot;&gt;Couchbase Lite for .NET&lt;/h3&gt;
&lt;p&gt;This project is a port of the &lt;a href=&quot;https://developer.couchbase.com/mobile/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;Couchbase Lite&lt;/a&gt; portable Java codebase, ported to C#. Couchbase Lite is a fully functional, on-device, lightweight, native, embedded JSON database. With Couchbase Lite, you have the full power of a Couchbase database locally on the device. You can create, update, delete, query, sync and much, much more.&lt;/p&gt;
&lt;h4 id=&quot;Project-Details&quot;&gt;Project Details&lt;/h4&gt;
&lt;h4 id=&quot;Quicklinks&quot;&gt;Quicklinks&lt;/h4&gt;
&lt;blockquote readability=&quot;5.404958677686&quot;&gt;
&lt;p&gt;以上《英文介绍》摘录自 .NET Foundation 的&lt;a href=&quot;https://github.com/dotnet/foundation/blob/master/projects/couchbase-lite-for-.net.md&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;项目介绍&lt;/a&gt; 。原文受原项目许可证保护。## 中文介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;中文介绍内容翻译自英文介绍，主要采用意译、如与原文存在出入，请以原文为准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;DNN-框架&quot;&gt;DNN 框架&lt;/h3&gt;
&lt;p&gt;&lt;img class=&quot;medium-zoom-image&quot; src=&quot;https://github.com/dnnsoftware/Dnn.Platform/raw/development/dnnplatform.png&quot; alt=&quot;一张图看遍 DNN&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DNN® (旧名称为 DotNetNuke®) 是一款在微软生态圈中占据主导地位的网站内容管理系统开发平台（CMS）。该产品用于构建具备专业外观并且易于使用的商业网站、社会站点、社区门户和合作方站点。尽管包含了所有类型的动态内容，DNN 站点仍然非常易于部署和更新。 DNN 已经被下载超过 8 百万次，并支撑全球超过 750,000 个站点。它由超过 1 百万成员的社区共同支持。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://store.dnnsoftware.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;DNN 商城&lt;/a&gt;上，成千上万的付费或免费插件、应用和皮肤可供使用，这使得扩展一个 DNN 站点变得方便快捷又经济实惠。&lt;/p&gt;
&lt;p&gt;作为一个强大的内容管理系统，开源免费的 DNN 平台包含有一些这些内建的特性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一次安装，便可承载多个站点&lt;/li&gt;
&lt;li&gt;文件和文件夹管理&lt;/li&gt;
&lt;li&gt;支持静态和动态的本地化支持，包含六款拆箱可用的语言支持（英语、荷兰语、法语、德语、意大利语和西班牙语）。&lt;/li&gt;
&lt;li&gt;可自定义站点模板和主题&lt;/li&gt;
&lt;li&gt;原生支持微软 Azure 部署运行&lt;/li&gt;
&lt;li&gt;100% 支持的 REST API，进行站点和内容管理&lt;/li&gt;
&lt;li&gt;选择现代化站点客户端开发工具，例如 CSS 3、HTML 5、JQuery 和 React&lt;/li&gt;
&lt;li&gt;支持拖拽式 UI 编辑和无弹框的即可富文本编辑体验&lt;/li&gt;
&lt;li&gt;极具扩展性，支持通过自建模块和在 DNN 商店中的很多第三方模块进行扩展&lt;/li&gt;
&lt;li&gt;强大的安全性&lt;/li&gt;
&lt;li&gt;具备充分的系统管理功能，例如：角色安全性、访问受限内容、SEO、计划任务、SSL 支持、分类分组、站点日志等等&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;项目详情-1&quot;&gt;项目详情&lt;/h4&gt;
&lt;h4 id=&quot;相关链接-1&quot;&gt;相关链接&lt;/h4&gt;
&lt;h2 id=&quot;笔者简评-1&quot;&gt;笔者简评&lt;/h2&gt;
&lt;p&gt;CMS 助于方便的建立内容展示为主的站点。其核心的领域问题包括有：主体管理、内容管理、插件化开发等等和站点展示有关的内容。&lt;/p&gt;
&lt;p&gt;DNN 目前采用 Asp.NET MVC 5 作为主体框架进行开发。&lt;/p&gt;
&lt;p&gt;DNN 作为老牌 CMS 系统，它一直在发展。尽管从笔者看来，在国内的使用度很低，但其中的系统思想和方法非常值得学习。&lt;/p&gt;
&lt;h2 id=&quot;英文介绍-1&quot;&gt;英文介绍&lt;/h2&gt;
&lt;h3 id=&quot;DNN-Platform&quot;&gt;DNN Platform&lt;/h3&gt;
&lt;p&gt;&lt;img class=&quot;medium-zoom-image&quot; src=&quot;https://github.com/dnnsoftware/Dnn.Platform/raw/development/dnnplatform.png&quot; alt=&quot;DNN Platform At A Glance&quot;/&gt;&lt;/p&gt;
&lt;p&gt;DNN® ( formerly DotNetNuke® ) is the leading open source web content management platform (CMS) in the Microsoft ecosystem. The product is used to build professional looking and easy-to-use commercial websites, social intranets, community portals, or partner extranets. Containing dynamic content of all types, DNN sites are easy to deploy and update. The DNN Platform has been downloaded more than 8 million times and powers more than 750,000 websites globally. A community of more than 1 million members forms a powerful support network.&lt;/p&gt;
&lt;p&gt;Thousands of free and commercial extensions, apps and skins are available at the &lt;a href=&quot;https://store.dnnsoftware.com/&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;DNN Store&lt;/a&gt; that make extending a DNN site fast and affordable.&lt;/p&gt;
&lt;p&gt;In addition to robust content management, the free, open source DNN Platform includes the following built-in features:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Single installation with multi-site capability&lt;/li&gt;
&lt;li&gt;File and folder management&lt;/li&gt;
&lt;li&gt;Static and dynamic Localization - 6 languages out-of-the-box (English, Ducth, French, German, Italian, and Spanish)&lt;/li&gt;
&lt;li&gt;Customized web site templates and themes&lt;/li&gt;
&lt;li&gt;Cloud-ready with MS Azure compatibility&lt;/li&gt;
&lt;li&gt;100’s of REST API for site and content managment&lt;/li&gt;
&lt;li&gt;Modern client-side Web tools like CSS 3, HTML 5, JQuery, and React&lt;/li&gt;
&lt;li&gt;UI with drag and drop capability, and rich-text editor for in-place UI editing&lt;/li&gt;
&lt;li&gt;Extensible through custom modules and many third party modules available in the DNN store&lt;/li&gt;
&lt;li&gt;Robust security&lt;/li&gt;
&lt;li&gt;Administration features like: security roles, protected content, SEO, scheduler, SSL support, taxonomy, site log, and many more.&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;Project-Details-1&quot;&gt;Project Details&lt;/h4&gt;
&lt;h4 id=&quot;Quick-Links&quot;&gt;Quick Links&lt;/h4&gt;
&lt;blockquote readability=&quot;5.404958677686&quot;&gt;
&lt;p&gt;以上《英文介绍》摘录自 .NET Foundation 的&lt;a href=&quot;https://github.com/dotnet/foundation/blob/master/projects/dnn-platform.md&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;项目介绍&lt;/a&gt; 。原文受原项目许可证保护。## 中文介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;中文介绍内容翻译自英文介绍，主要采用意译、如与原文存在出入，请以原文为准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;NET-Compiler-Platform-“Roslyn”&quot;&gt;.NET Compiler Platform (“Roslyn”)&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnet/roslyn&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;.NET Compiler Platform (“Roslyn”)&lt;/a&gt; 是一款开源的 C# 和 Visual Basic 编译器，它提供了丰富的代码分析接口。你可以使用它来构建自己的代码分析工具，微软公司当前就是使用它来实现 Visual Studio！&lt;/p&gt;
&lt;h4 id=&quot;项目详情-2&quot;&gt;项目详情&lt;/h4&gt;
&lt;h4 id=&quot;相关链接-2&quot;&gt;相关链接&lt;/h4&gt;
&lt;p&gt;项目博客:&lt;/p&gt;
&lt;h2 id=&quot;笔者简评-2&quot;&gt;笔者简评&lt;/h2&gt;
&lt;p&gt;在 Roslyn 出来之前，编译器就是一个黑盒，传入的是源码，出来的是目标文件或者程序集。开发者仅仅能通过有限的参数来改变其行为。&lt;/p&gt;
&lt;p&gt;但是 Roslyn 出来之后，时代变了。&lt;/p&gt;
&lt;p&gt;开发者具备了完成下面这些事情的能力：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;可以编写自己的语法检查规则，例如：必须使用 var 。&lt;/li&gt;
&lt;li&gt;可以基于语法分析来编写代码生成器，替代提前的反射方法或者 T4。这意味着，写代码的时候就可以生成代码。&lt;/li&gt;
&lt;li&gt;编译器的升级不再依赖于 VS 和 framework 的版本发布。它单独的包，完全可以单独安装新的编译器而不升级 VS。（当然这么做的话，VS 的提示会有点小瑕疵）&lt;/li&gt;
&lt;li&gt;甚至可以自定义语法。加入自己定义的语法规则。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;常规的业务开发，或许涉及不到上面的工作，但假如是研发岗位。为了更优质的代码，你需要学习使用这个框架。&lt;/p&gt;
&lt;h2 id=&quot;英文介绍-2&quot;&gt;英文介绍&lt;/h2&gt;
&lt;h3 id=&quot;NET-Compiler-Platform-“Roslyn”-1&quot;&gt;.NET Compiler Platform (“Roslyn”)&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://github.com/dotnet/roslyn&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;.NET Compiler Platform (“Roslyn”)&lt;/a&gt; provides open-source C# and Visual Basic compilers with rich code analysis APIs. You can build code analysis tools with the same APIs that Microsoft is using to implement Visual Studio!&lt;/p&gt;
&lt;h4 id=&quot;Project-Details-2&quot;&gt;Project Details&lt;/h4&gt;
&lt;h4 id=&quot;Quicklinks-1&quot;&gt;Quicklinks&lt;/h4&gt;
&lt;p&gt;Blogs:&lt;/p&gt;
&lt;blockquote readability=&quot;5.3207547169811&quot;&gt;
&lt;p&gt;以上《英文介绍》摘录自 .NET Foundation 的&lt;a href=&quot;https://github.com/dotnet/foundation/blob/master/projects/dotnet-compiler-platform.md&quot; rel=&quot;external nofollow noopener noreferrer&quot; target=&quot;_blank&quot;&gt;项目介绍&lt;/a&gt; 。原文受原项目许可证保护。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;其他项目&quot;&gt;其他项目&lt;/h2&gt;
</description>
<pubDate>Tue, 25 Feb 2020 00:44:00 +0000</pubDate>
<dc:creator>Newbe36524</dc:creator>
<og:description>.Net 基金会中包含有很多优秀的项目，今天就和笔者一起了解一下其中的一些优秀作品吧。 中文介绍 中文介绍内容翻译自英文介绍，主要采用意译、如与原文存在出入，请以原文为准。 Couchbase Lit</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/newbe36524/p/12359958.html</dc:identifier>
</item>
<item>
<title>花 1 小时，开源设计 LoRa 继电器开关 - rimelink</title>
<link>http://www.cnblogs.com/rimelink/p/12359916.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rimelink/p/12359916.html</guid>
<description>&lt;p&gt;&lt;em&gt;提示1：锐米所有 LoRa 产品严格遵循&lt;strong&gt;国标标准的 LoRaWAN 协议&lt;/strong&gt;&lt;/em&gt;。&lt;br/&gt;&lt;em&gt;提示2：您可以免费复制，修改和商用本项目，请注明&lt;a href=&quot;http://www.rimelink.com&quot;&gt;锐米原创&lt;/a&gt;&lt;/em&gt;。&lt;br/&gt;&lt;em&gt;提示3：如果您有其他 LoRa 需求或建议，欢迎联系锐米 &lt;strong&gt;support@rimelink.com&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074013209-1895779691.png&quot; width=&quot;400&quot; height=&quot;400&quot;/&gt;&lt;/p&gt;

&lt;p&gt;LoRa 继电器开关，用于无线远程控制电气设备，通过 App 下发指令能实时控制：电器，灯光，电机，阀门等。&lt;br/&gt;&lt;strong&gt;物联网 Arduino LoRa LoRaWAN 继电器开关&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074807810-1802277410.jpg&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;&lt;strong&gt;LoRa 扩展板 x 1&lt;/strong&gt; &lt;a href=&quot;https://item.taobao.com/item.htm?spm=a1z10.3-c-s.w4002-13955217965.27.715f421cEkbQLU&amp;amp;id=612648762230&quot;&gt;采购链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074642570-890417490.jpg&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;&lt;strong&gt;Arduino UNO x 1&lt;/strong&gt; &lt;a href=&quot;https://item.taobao.com/item.htm?spm=a1z09.2.0.0.773d2e8dmYIyUF&amp;amp;id=593401940517&amp;amp;_u=k201cu1luac7c6&quot;&gt;采购链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225080958560-609301975.jpg&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;&lt;strong&gt;5V继电器模块 x 1&lt;/strong&gt; &lt;a href=&quot;https://detail.tmall.com/item.htm?id=41231430731&amp;amp;spm=a1z09.2.0.0.3c6a2e8dtYyRTi&amp;amp;_u=l34jp72pd125&amp;amp;skuId=3764441873869&quot;&gt;采购链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074714637-1742240917.png&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;&lt;strong&gt;天线 x 1&lt;/strong&gt; &lt;a href=&quot;https://detail.tmall.com/item.htm?spm=a230r.1.14.20.43dc71de9WHs3W&amp;amp;id=17521693052&amp;amp;ns=1&amp;amp;abbucket=7&quot;&gt;采购链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074833167-1807785075.jpg&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;&lt;strong&gt;1K欧姆 x 1&lt;/strong&gt; &lt;a href=&quot;https://detail.tmall.com/item.htm?spm=a1z10.3-b-s.w4011-16538328900.60.560c3d6c1fIOpf&amp;amp;id=542721590093&amp;amp;rn=ee1348ad4dd04ab3700b67c8996f7925&amp;amp;abbucket=18&amp;amp;skuId=3769488045642&quot;&gt;采购链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074721164-1284890712.jpg&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;&lt;strong&gt;杜邦线 x 3&lt;/strong&gt; &lt;a href=&quot;https://detail.tmall.com/item.htm?id=41254478179&amp;amp;spm=a1z09.2.0.0.7b0d2e8dkRdPtj&amp;amp;_u=k201cu1luab121&amp;amp;skuId=3108862773142&quot;&gt;采购链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074732651-47393429.jpg&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;&lt;strong&gt;LoRa网关&lt;/strong&gt; &lt;a href=&quot;https://item.taobao.com/item.htm?spm=2013.1.w4023-13955217959.11.38c65d3aDTFBlO&amp;amp;id=559152286301&quot;&gt;采购链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074846247-1165003210.png&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;&lt;strong&gt;LoRaServer&lt;/strong&gt; &lt;a href=&quot;http://www.rimecloud.com/&quot;&gt;下载链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074741697-169215463.jpg&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;&lt;strong&gt;LoRaApp&lt;/strong&gt; &lt;a href=&quot;https://github.com/rimelink-lorawan/csharp-app-sdk/releases/download/v1.0/RDemoConfig1.0.zip&quot;&gt;下载链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074651224-590141242.jpg&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;&lt;strong&gt;Arduino IDE&lt;/strong&gt; &lt;a href=&quot;https://www.arduino.cc/en/main/software&quot;&gt;下载链接&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一个城市有上 100,000 盏路灯，一栋楼宇有上 10,000 电器，一个工厂有上 1,000 电气设备，大型农场有上 1,000 阀门。。。。远程实时控制这些电气设备，&lt;strong&gt;不但可以节能减排，而且降低运营维护成本&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;LoRa 继电器开关，使用 App 实时远程控制电气设备。它的实时性好，一般在 2 秒内响应；操作简单，业余人员使用手机即可操作；成本低廉，硬件物料批量生产仅 ￥60&lt;/p&gt;
&lt;p&gt;LoRa 继电器开关可以应用在：工厂，楼宇，农场，鱼塘，学校，路灯等场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LoRa 继电器开关_应用场景&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225082103348-1894476546.png&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LoRa 继电器开关_App远程控制&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225082406871-1764973441.png&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相比传统的产品，LoRa 继电器开关具备的优点为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;em&gt;安装简单便捷，不需要布线&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;App远程控制，简单便捷&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;成本低廉，没有流量费用&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;实时控制，响应时间 &amp;lt; 2 秒&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本项目==开源设计 LoRa 继电器开关的核心---软件和硬件==，用户选择一个漂亮的外壳，即可组成一个产品。&lt;br/&gt;同时，简介了 LoRa 网络组件，轻松构建一个商用的物联网。&lt;/p&gt;

&lt;h2 id=&quot;元器件介绍&quot;&gt;元器件介绍&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074807810-1802277410.jpg&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;这是专为 Arduino 而设计的 LoRa 扩展板，既可以安装在 Arduino UNO 上，也能使用杜邦线连接到 Arduino Pro Mini。&lt;br/&gt;它能达到==空旷 10km 的通信距离，休眠电流仅 1.3uA==。精心设计的软件库，使其开发极为容易：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;发送数据&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;LoRa.write(&quot;123&quot;, 3);&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;接收数据&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;if (LoRa.availabe()) { 
    len = LoRa.read(buf, MAX_LEN); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074642570-890417490.jpg&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;Arduino UNO 是最常用的开发板，它便宜简单，接线方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225080958560-609301975.jpg&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;继电器模块，带光耦隔离，5V/5mA 直流驱动 220V/10A 交流负载。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225074714637-1742240917.png&quot; width=&quot;200&quot;/&gt;&lt;br/&gt;470MHz 胶棒天线，增益 3.5dB，特别适合中国 LoRa 频段范围（470~510MHz）。&lt;/p&gt;
&lt;h2 id=&quot;硬件接线&quot;&gt;硬件接线&lt;/h2&gt;
&lt;p&gt;如下图所示，使用公对公杜邦线连接 Arduino、继电器模块和1K欧姆电阻。&lt;br/&gt;(在本设计案例中，继电器的输出回路(NO 和 COM)连接到 220V 火线上，&lt;strong&gt;绝缘处理要严格，否则可能导致触电危险！&lt;/strong&gt;)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;电路图&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225082650644-1510961375.png&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实物图&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225082724747-1718931190.jpg&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;## 通信逻辑&lt;br/&gt;如下图所示，通过 App 可以控制继电器开关的&lt;strong&gt;接通或断开&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;为此，需要配置如下的网络组件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225082813012-1899236994.png&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;运行效果&quot;&gt;运行效果&lt;/h2&gt;
&lt;p&gt;如下图所示，通过 App 下发控制命令给 LoRa 继电器开关(RY 是 Relay(继电器) 的缩写)&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;RY:1&lt;/strong&gt; 接通继电器，点亮灯光&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RY:0&lt;/strong&gt; 断开继电器 ，熄灭灯光&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1915372/202002/1915372-20200225082849601-581156356.png&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;arduino-代码&quot;&gt;Arduino 代码&lt;/h2&gt;
&lt;p&gt;编译本工程需要添加&lt;a href=&quot;https://github.com/rimelink-lorawan/ArduinoLoRaLibrary/archive/1.1.zip&quot;&gt;LoRa 驱动库&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用 Arduino IDE 打开工程，点击&quot;&lt;strong&gt;Sketch -&amp;gt; Include Library -&amp;gt; Add .ZIP Library...&lt;/strong&gt;&quot;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Arduino 的 zip 库安装路径一般为：C:\Users\Administrator\Documents\Arduino\libraries&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Arduino 的代码简洁，容易理解，&lt;a href=&quot;https://github.com/rimelink-lorawan/ArduinoLoRaProject/blob/master/ArduinoLoRa_Relay.ino&quot;&gt;下载链接&lt;/a&gt;&lt;/p&gt;
&lt;ul readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;em&gt;DEBUG 设置为 0 禁止调试功能；设置为 1 它将通过 8 和 9 两个引脚打印调试信息（使用“USB转串口”连接到 PC）&lt;/em&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;按 LoRaWAN 协议，Class C 的节点入网后，必须先发送一帧数据并且服务器成功接收后，节点才能处于持续接收状态。因此，在 setup() 中节点发送了 2 帧数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;当 LoRa 节点接收到来自 App 的下发数据帧时，它通过拉低 Pin2 引脚来通知 Arduino。这里，loop() 持续检测该引脚并接收数据帧。&lt;br/&gt;(为了简化设计，此处使用的是查询机制；如果要求高效率和低功耗，需要切换为中断机制，代价是复杂度大增)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;#include &amp;lt;lora.h&amp;gt;

lora LoRa;
const int wakeupPin = 2;  // LoRaNode LOW wakeup connected to pin 2
const int solenoidPin = 5;  // Solenoid connected to pin 5

#define DEBUG    0

#if DEBUG
#include &amp;lt;SoftwareSerial.h&amp;gt;
SoftwareSerial debugSerial(8, 9);  // 8=RX, 9=TX
#endif

void setup()
{
  Serial.begin(115200);  // for LoRa node
  pinMode(wakeupPin, INPUT);
  pinMode(solenoidPin, OUTPUT);
  
#if DEBUG
  pinMode(LED_BUILTIN, OUTPUT);
  debugSerial.begin(115200); // start software serial port at 115200-8-N-1
  debugSerial.println(&quot;debug begin&quot;);
#endif

  for (int i = 0; i &amp;lt; 2; ++i) {
    LoRa.write(&quot;hi&quot;, 2);
    delay(5000);
  }
}

void loop()
{
  #define MAXINSZ    20  // like as: RY:x
  char instr[MAXINSZ];  // Input buffer
  int  len;
  int  val;

  do {
    val = digitalRead(wakeupPin);
  } while (HIGH == val);  // check looply until the pin is LOW

  delay(10);  // waiting until the LoRa message have been received

  if (LoRa.available()) {
    len = LoRa.read(instr, MAXINSZ);
    if (('R' == instr[0]) &amp;amp;&amp;amp; ('Y' == instr[1]) &amp;amp;&amp;amp; (':' == instr[2]))  // match the &quot;RY:0&quot; or &quot;RY:1&quot;
    {      
      if ('1' == instr[3])  // turn ON
      {
        digitalWrite(solenoidPin, HIGH); // activates the solenoid
      }
      else if ('0' == instr[3])  // turn OFF
      {
        digitalWrite(solenoidPin, LOW);  // deactivates the solenoid
      }
      else  // do nothing for the noise
      {
      }
    }

  #if DEBUG
    digitalWrite(LED_BUILTIN, HIGH);
    debugSerial.write(instr, len);
    digitalWrite(LED_BUILTIN, LOW);
  #endif
  }
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;LoRa 继电器开关的==硬件成本约 ￥60==，这依赖于批量数目和供货渠道。&lt;/p&gt;
&lt;p&gt;批量生产的一些技术挑战：&lt;strong&gt;尺寸，成本，功耗，烧录，升级&lt;/strong&gt;。&lt;br/&gt;我们为您准备好解决方案：&lt;a href=&quot;https://blog.csdn.net/jiangjunjie_2005/article/details/103668959&quot;&gt;低成本快速开发LoRa终端：从1到10000&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Feb 2020 00:44:00 +0000</pubDate>
<dc:creator>rimelink</dc:creator>
<og:description>LoRa 继电器开关，用于无线远程控制电气设备，通过 App 下发指令能实时控制：电器，灯光，电机，阀门等。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rimelink/p/12359916.html</dc:identifier>
</item>
<item>
<title>意法半导体STM32MP157A MPU加持，米尔科技首款ST Linux开发板MYD-YA157C评测 - myfeiyang</title>
<link>http://www.cnblogs.com/cbd7788/p/12359959.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cbd7788/p/12359959.html</guid>
<description>&lt;p&gt;ST公司去年推出了MPU系列芯片，MPU系列不同于以往产品，它既包含有ARM公司Cortex M 单片机核心，也包含有ARM公司Cortex A 应用处理器核心，一起将STM32单片机产品优势扩展到更高性能、更多资源和更多开源软件的 linux 领域中。&lt;/p&gt;
&lt;p&gt;米尔电子基于此系列芯片也推出了MYD-YA157C linux 开发板，采用的正是STM32MP157A 芯片，双Cortex®-A7 核心 + 单Cortex®-M4 核心，可应用于高性能计算，音视频等领域，同时也可应用于实时控制，IOT 物联网等领域。&lt;/p&gt;
&lt;p&gt;本次为大家带来米尔MYD-YA157C 开发板使用评测：&lt;/p&gt;
&lt;p&gt;产品介绍&lt;/p&gt;
&lt;p&gt;米尔产品还是一贯的外装风格，橙白色硬纸彩盒包装，内有海绵缓冲，静电袋防护，装箱清单，使用手册，米尔所有产品都是统一的包装风格，既保护了产品也给用户很好的印象。&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image001.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image001-700x551.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;551&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image003.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image003-700x522.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;522&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;米尔MYD-YA157C 开发板现真身，整套产品包含一块开发板，一条2.4G天线，一条USB转 ttl连接线，一条type-c 数据线&lt;/p&gt;
&lt;p&gt;开发板整体尺寸不大110mm x 80mm，位于中间的近似方形的核心板使用了邮票孔封装，贴装于底板上，核心板尺寸：43mm x 45mm&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image005.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image005-700x514.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;514&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image007.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image007-700x515.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;515&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;米尔MYD-YA157C 开发板外部接口相当的多，多而全：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;显示接口：LCD屏幕， HDMI 显示，MIPI-DSI显示都支持&lt;/li&gt;
&lt;li&gt;USB接口：USB Host接口，type-c Device接口&lt;/li&gt;
&lt;li&gt;网络接口：有线千兆网口，WiFi+BT&lt;/li&gt;
&lt;li&gt;调试接口：Debug uart接口，JTAG接口&lt;/li&gt;
&lt;li&gt;工业接口：RS232，RS485，CAN， IO扩展&lt;/li&gt;
&lt;li&gt;用户接口：LED指示灯，三个按键，拨码开关&lt;/li&gt;
&lt;li&gt;存储接口：TF 卡槽（背面）&lt;/li&gt;
&lt;li&gt;电源接口：12V DC接口，5V type-c 接口&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image009.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image009.jpg&quot; alt=&quot;&quot; width=&quot;613&quot; height=&quot;422&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;米尔MYD-YA157C 开发板硬件配置和参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SOC芯片：STM32MP157AAC3,TFBGA361,12x12mm&lt;/li&gt;
&lt;li&gt;PMIC芯片：STPMIC1APQR&lt;/li&gt;
&lt;li&gt;内存：512MB DDR3&lt;/li&gt;
&lt;li&gt;存储：4GB EMMC（可选Nand Flash，nand emmc 二选一），，支持TF扩展&lt;/li&gt;
&lt;li&gt;网络：Ethernet 千兆，KSZ9031，WiFi+BT（正基AP6212模块，封装的拨通芯片）&lt;/li&gt;
&lt;li&gt;米尔MYD-YA157C 开发板整体系统框架如下三张图：SoC线片框架图，核心板框架图，开发板框架图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image011.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image011.jpg&quot; alt=&quot;&quot; width=&quot;492&quot; height=&quot;662&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SoC 芯片框架图：芯片内嵌 ARM 双Cortex A7 核心，运行频率650Mhz，外加一颗ARM Cortex M4 核心，运行频率209Mhz，集成3D GPU模块，原生CAN支持,设有有原生HDMI接口，和其他一众特性模块接口&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image013.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image013.jpg&quot; alt=&quot;&quot; width=&quot;492&quot; height=&quot;282&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;核心板框架图：电源管理，存储，内存，网络PHY芯片全部集成于核心板，其他IO直接导出。&lt;br/&gt;核心板就是一个最小系统，可以基于核心板开发产品，只要扩展出需要的接口即可，加速产品上市缩短开发验证测试时间。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image015.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image015.jpg&quot; alt=&quot;&quot; width=&quot;646&quot; height=&quot;473&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;开发板框架图：含DCDC电源模块，SII9022 RGB转换HDMI，RS485 RS232 转换电路，和其他一众接口。&lt;/p&gt;
&lt;p&gt;米尔还为开发板准备了配套的资料：用户手册，芯片手册，核心板pin脚列表，底板原理图，软件开发手册，软件开发工具， TFA源码，U-boot源码，kernel源码，驱动源码，Yocto开发套件，系统经镜像等文件：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image017.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image017.jpg&quot; alt=&quot;&quot; width=&quot;384&quot; height=&quot;214&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image019.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image019.jpg&quot; alt=&quot;&quot; width=&quot;469&quot; height=&quot;177&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image021.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image021-365x700.jpg&quot; alt=&quot;&quot; width=&quot;365&quot; height=&quot;700&quot;/&gt;&lt;/a&gt;&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;系统展示&lt;br/&gt;米尔开发板应该是预装了系统的，开机就可以启动使用的，可惜这块板子需要笔者自己动手来烧录系统：&lt;/p&gt;
&lt;p&gt;1，安装烧录开发板系统软件：STM32CubeProgrammer，此软件同时支持windows mac linux 三平台，有ST 公司免费提供，米尔已经把软件放在光盘资料包03-Tools\STM32MP1 Tools中了&lt;br/&gt;2，下载下面地址中的三个镜像文件后解压：http://down.myir-tech.com/MYD-YA157C/&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image023.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image023.jpg&quot; alt=&quot;&quot; width=&quot;621&quot; height=&quot;300&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3，烧录weston系统，成功&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image025.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image025-700x453.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;453&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;连接显示器，网线，Debug-uart，鼠标键盘卡机：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image027.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image027-570x700.jpg&quot; alt=&quot;&quot; width=&quot;570&quot; height=&quot;700&quot;/&gt;&lt;/a&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image029.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image029-700x409.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;409&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Weston 系统是 ST 的一个 Demo 系统，针对STM32MP157这颗芯片的功能展示的一个定制系统，主要功能有网络，摄像头，视频播放，AI人工智能，3D GPU，蓝牙音频。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image031.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image031-700x414.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;414&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Netdata 是个基于网络服务的系统监控软件，打开后提示可以通过网络访问此服务&lt;br/&gt;也可以把WiFi打开，开发板会创建一个热点，通过手机扫码连接访问这个网址，或者电脑WiFi连接访问&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image033.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image033-700x393.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;393&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;3D GPU 会动态渲染一个在三维空间旋转的的立方体&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image035.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image035-700x416.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;416&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Video playback 自动播放系统内的视频，介绍ST芯片特性的，播放视频很流畅，系统cpu使用不到50%上下：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image037.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image037-700x416.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;416&quot;/&gt;&lt;/a&gt;&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;软件开发&lt;br/&gt;开发环境：笔者使用的8代6核心CPU，16GB内存，全固态硬盘，&lt;br/&gt;系统软件：ubuntu18.04 x64系统&lt;br/&gt;开发环境搭建一切顺利，TF-a 编译后运行成功：&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image039.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image039.jpg&quot; alt=&quot;&quot; width=&quot;603&quot; height=&quot;296&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;uboot编译运行成功：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image041.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image041-700x363.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;363&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Uboot 引导系统启动时候，需要调试，经过以下两步调试可以正常运行&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image043.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image043.jpg&quot; alt=&quot;&quot; width=&quot;589&quot; height=&quot;419&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;调试后直接修改uboot源代码，重新编译，重新烧录uboot，就可以了；&lt;br/&gt;源码修改uboot 的设备树；绿色代码注释掉，增加红色代码&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image045.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image045-700x304.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;304&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使用Yocto开发工具编译seston系统，完美运行：&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image047.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image047-700x395.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;395&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;米尔还提供了一系列linux 驱动源码和测试程序及开发文档，Qt开发，SoC上的 M4核心调试开发文档，可以此参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image049.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image049.jpg&quot; alt=&quot;&quot; width=&quot;521&quot; height=&quot;333&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;米尔也提供了ubuntu18.04系统镜像，需要自己修改一下才能启动，启动时间较长，要一两分钟吧，启动的时候连接上Debug-uart口，能看到启动状态和错误信息&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image051.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image051-700x410.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;410&quot;/&gt;&lt;/a&gt;&lt;br/&gt;（使用笔者修改后的系统：链接：https://pan.baidu.com/s/1PP5iUCwc0yT4EFGriothog 提取码：urhv ）&lt;/p&gt;
&lt;p&gt;除此之外，ST 产品的生态还提供一些第三方公司的支持，比如其他linux，androd BSP，RTOS ，Debian BSP 等等。&lt;br/&gt; &lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image053.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image053-700x512.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;512&quot;/&gt;&lt;/a&gt; &lt;a href=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image055.jpg&quot;&gt;&lt;img src=&quot;https://www.eeboard.com/wp-content/uploads/2020/01/image055-700x450.jpg&quot; alt=&quot;&quot; width=&quot;700&quot; height=&quot;450&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结&lt;/p&gt;
&lt;p&gt;从硬件上来看，米尔MYD-YA157C 开发板丰富的接口可最大化满足用户和工程师们的各种使用场景，不大不小的内存足以发挥SoC的性能也不多余浪费， EMMC高速存储搭配方便的TF调试，有线网络无线网络蓝牙多种连接方式；米尔MYD-YA157C 开发板算是一块小而精致的多用途开发板。也折射出米尔电子的产品开发的能力，和对用户的了解，对工程师们的需求很熟悉。&lt;/p&gt;
&lt;p&gt;从软件生态看，上游的支持也很丰富，有ST原厂商级别的各种工具集，Yocto开发套件，Debain android BSP 支持，RTOS 系统支持等，weston Demo系统能流畅运行一些视频3D网络服务，音视频网络服务，完全可以使用Yocto开发套件编译系统，基于此开发自己产品，有经验的开发者和厂商可以参与进来开发产品了；奈何芯片上市时间还不长，下游开发还不足够充分，系统对普通用户还不够友好；当然随着时间推移，这些用户使用体验会越来越好。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Feb 2020 00:44:00 +0000</pubDate>
<dc:creator>myfeiyang</dc:creator>
<og:description>ST公司去年推出了MPU系列芯片，MPU系列不同于以往产品，它既包含有ARM公司Cortex M 单片机核心，也包含有ARM公司Cortex A 应用处理器核心，一起将STM32单片机产品优势扩展到更</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cbd7788/p/12359959.html</dc:identifier>
</item>
<item>
<title>一个软件产品的幸福人生 - efonfighting</title>
<link>http://www.cnblogs.com/efonfighting/p/12359941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/efonfighting/p/12359941.html</guid>
<description>&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/1859694/202002/1859694-20200225082118964-710343354.png&quot; alt=&quot;&quot; width=&quot;792&quot; height=&quot;444&quot;/&gt;&lt;/h2&gt;
&lt;h2 id=&quot;h&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;昨天一番发布了一个桌面软件小工具，整个产品从无到有，从粗糙到完善，也算是经历了整个从概念到产品的完整周期。虽然有几个环节做得还有欠缺，这里也算是做一个复盘，回顾总结整个流程，希望在下个迭代流程走得更好。&lt;/p&gt;
&lt;h2 id=&quot;h-1&quot;&gt;需求整理&lt;/h2&gt;
&lt;p&gt;一番发布了两个面向普通用户的软件，都是带有图形交互界面的。&lt;/p&gt;
&lt;p&gt;这两个软件面向的需求的主要来源有两个，一个是一番自身的功能需求，一个是跟大家交流中得到的需求。&lt;/p&gt;
&lt;p&gt;对需求的理解深度，会影响产品的功能、交互、体验等等，可以说是一个软件产品的灵魂。&lt;/p&gt;
&lt;p&gt;一番其实一年前就有这两个产品的需求，也能做出这样轻量级的应用，但过于纠结产品的外观，因此过多的纠结在设计方案选型的过程中，最终不得成型。&lt;/p&gt;
&lt;p&gt;其实从产品初期的需求来看，功能需求大于外观需求。而且最后一番做出来的界面交互其实也不是太差。得到这个启发的也是看到WeChatDownload小工具得到的。虽然界面不是那么炫，但只要市面上还没有这样的工具，其实市场对功能的需求、与使用者的交互友好、大于对外观的追求。&lt;/p&gt;
&lt;p&gt;总结出来就是，&lt;strong&gt;功能 &amp;gt; 交互 &amp;gt; 外观&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然，一个优秀的软件产品，这三个点都很重要。&lt;/p&gt;
&lt;h2 id=&quot;h-2&quot;&gt;方案设计&lt;/h2&gt;
&lt;p&gt;有了上面产品需求的理解，那么就需要找实现方案了。大概包括这几点：&lt;/p&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;编程语言选择：这个需要结合功能的技术方案、开发者的技术栈和学习成本综合考虑。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;功能模块设计：从需求出发，一个大需求需要分解成哪些子需求，需要实现哪些功能。还有一些软件通用需求，比如升级、问题反馈、使用说明、联系方式等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;界面交互设计：主要从小白用户角度出发，尽量减少用户的学习成本和使用难度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h-3&quot;&gt;编码设计&lt;/h2&gt;
&lt;p&gt;编码阶段主要注意几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;编程规范&lt;/li&gt;
&lt;li&gt;模块化&lt;/li&gt;
&lt;li&gt;可复用性&lt;/li&gt;
&lt;li&gt;可扩展性&lt;/li&gt;
&lt;li&gt;代码管理&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h-4&quot;&gt;开发测试&lt;/h2&gt;
&lt;p&gt;编码开发完之后需要有基本的功能测试，这里需要设计一些测试用例，才能避免因为在开发一个模块而影响到其他功能了却不知道。&lt;/p&gt;
&lt;p&gt;测试用例的设计也是需要结合方案设计、用户需求来做。&lt;/p&gt;
&lt;p&gt;整个自测用例跑完一遍后，就会对当前版本的状态有一个大概的认知了。&lt;/p&gt;
&lt;p&gt;最后，评估下当前版本状态，如果可以，就可以打包了。&lt;/p&gt;
&lt;h2 id=&quot;h-5&quot;&gt;发版测试&lt;/h2&gt;
&lt;p&gt;打包后，理论上来讲这个就是我们准备发布的版本了。但打包版本和我们开发调试版本是有差异的，所以一定要做一次发版测试。&lt;/p&gt;
&lt;p&gt;发版测试大概包括这几点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;功能测试：基本就是将整个开发测试的测试用例再跑一遍，这是最基本要求。&lt;/li&gt;
&lt;li&gt;稳定性测试：找一些特殊使用场景，看下功能的稳定性。&lt;/li&gt;
&lt;li&gt;用户体验测试：非法操作、交互体验、任何可能的操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;以上如果测出来严重问题，需要重新做开发，然后重新进行发版测试。&lt;/p&gt;
&lt;h2 id=&quot;h-6&quot;&gt;版本发布&lt;/h2&gt;
&lt;p&gt;这一步就是最开心的了，终于可以发版本了。也包括怎么告知用户，软件功能展示。需要让用户简单明了的清楚软件功能、使用方式和可能的用户体验。&lt;/p&gt;
&lt;p&gt;如果可能，还需要有运营、推广。&lt;/p&gt;
&lt;h2 id=&quot;h-7&quot;&gt;产品迭代&lt;/h2&gt;
&lt;p&gt;以上所有环节完成后，根据用户反馈，就需要考虑是否有下一个产品迭代周期了。如果有，那就进入下一个同样的周期了。&lt;/p&gt;
&lt;h2 id=&quot;h-8&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;有了上面这些所有的环节，一个软件产品才算是有一个完整的人生，健康的一生。根据软件的规模，以上每个环节的投入都可大可小。&lt;/p&gt;
</description>
<pubDate>Tue, 25 Feb 2020 00:23:00 +0000</pubDate>
<dc:creator>efonfighting</dc:creator>
<og:description>麻雀虽小，但需要五脏俱全。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/efonfighting/p/12359941.html</dc:identifier>
</item>
<item>
<title>Python应用——自定义排序全套方案 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12359924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12359924.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;

&lt;p&gt;今天的这篇文章和大家聊聊Python当中的排序，和很多高级语言一样，Python封装了成熟的排序函数。我们只需要调用内部的sort函数，就可以完成排序。但是实际场景当中，排序的应用往往比较复杂，比如对象类型，当中有多个字段，我们希望按照指定字段排序，或者是希望按照多关键字排序，这个时候就不能简单的函数调用来解决了。&lt;/p&gt;

&lt;h2 id=&quot;字典排序&quot;&gt;字典排序&lt;/h2&gt;

&lt;p&gt;我们先来看下最常见的字典排序的场景，假设我们有一个字典的数组，字典内有多个字段。我们希望能够根据字典当中的某一个字段来进行排序，我们用实际数据来举个例子：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;kids = [
    {'name': 'xiaoming', 'score': 99, 'age': 12},
    {'name': 'xiaohong', 'score': 75, 'age': 13},
    {'name': 'xiaowang', 'score': 88, 'age': 15}
]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的kids是一个dict类型的数组，dict当中拥有name， score和age三个字段。假设我们当下希望能够按照score来排序，应该怎么办呢？&lt;/p&gt;
&lt;p&gt;对于这个问题，解决的方案有很多，首先，我们可以使用上一篇文章当中提到的匿名函数来指定排序的。这里的用法和上篇文章优先队列的用法是一样的，我们直接来看代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sorted(kids, key=lambda x: x['score'])&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在匿名函数当中我们接收的x是kids当中的元素，也就是一个dict，所以我们想要指定我们希望的字段，需要用dict访问元素的方法，也就是用中括号来查找对应字段的值。&lt;/p&gt;
&lt;p&gt;假如我们希望按照多关键字排序呢？&lt;/p&gt;
&lt;p&gt;首先介绍一下多关键字排序，还是用上面的数据打比方。在上面的例子当中，各个kid的score都不一样，所以排序的结果是确定的。但如果存在两个人的score相等，我希望年龄小的排在前面，那么应该怎么办呢？我们分析一下可以发现，原本是按照分数从小到大排序，但有可能会出现分数相等的情况。这个时候，我们希望能够按照在分数相等的情况下来比较年龄，也就是说我们希望根据两个关键字来排序，第一个关键字是分数，第二个关键字是年龄。&lt;/p&gt;
&lt;p&gt;由于Python当中支持tuple和list类型的排序，也就是说我们可以直接比较[1, 3]和[1, 2]的大小关系，Python会自动一次比较两个数组当中的元素的大小。如果相等就自动往后比较，直到出现不等或者结束为止。&lt;/p&gt;
&lt;p&gt;明白了这点，其实就很好办了。我们只要在匿名函数当中稍稍修改，让它返回的结果增加一个字段即可。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sorted(kids, key=lambda x: (x['score'], x['age']))&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;itemgetter&quot;&gt;itemgetter&lt;/h2&gt;

&lt;p&gt;除了匿名函数，Python也有自带的库可以解决这个问题。用法和匿名函数非常接近，使用起来稍稍容易一些。&lt;/p&gt;
&lt;p&gt;它就是operator库当中的itemgetter函数，我们直接来看代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from operator import itemgetter

sorted(kids, key=itemgetter('score'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是多关键字也可以，传入多个key即可：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sorted(kids, key=itemgetter('score', 'age'))&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;对象排序&quot;&gt;对象排序&lt;/h2&gt;

&lt;p&gt;我们接下来看一下对象的自定义排序，我们首先把上面的dict写成对象：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Kid:
    def __init__(self, name, score, age):
        self.name = name
        self.score = score
        self.age = age

    def __repr__(self):
        return 'Kid, name: {}, score: {}, age:{}'.format(self.name, self.score, self.age)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了方便观察打印结果，我们重载了__repr__方法，可以简单地将它当做是Java当中的toString方法，这样我们可以指定在print它的时候的输出结果。&lt;/p&gt;
&lt;p&gt;同样，operator当中也提供了对象的排序因子函数，用法上和itemgetter一样，只是名字不同。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from operator import attrgetter

kids = [Kid('xiaoming', 99, 12), Kid('xiaohong', 75, 13), Kid('xiaowang', 88, 15)]

sorted(kids, key=attrgetter('score'))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们也可以使用匿名函数lambda来实现：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sorted(kids, key=lambda x: x.score)&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;自定义排序&quot;&gt;自定义排序&lt;/h2&gt;

&lt;p&gt;到这里还没有结束，因为仍然存在一些问题解决不了。虽然我们实现了多关键字排序，但是还有一个问题解决不了，就是排序的顺序问题。&lt;/p&gt;
&lt;p&gt;我们可以在sorted函数的参数当中传入reverse=True来控制是正序还是倒叙，但是如果我使用多关键字，想要按照某个关键字升序，某个关键字降序怎么办？举个例子，比如说我们想要按照分数降序，年龄升序就没办法通过reverse来解决了，这就是当前解决不了的问题。&lt;/p&gt;
&lt;p&gt;那应该怎么办呢？&lt;/p&gt;
&lt;p&gt;这个时候就需要终极排序杀器上场了，也就是标题当中所说的自定义排序。也就是说我们自己实现一个定义元素大小的函数，然后让sorted来调用我们这个函数来完成排序。这也是C++和Java等语言的用法。&lt;/p&gt;
&lt;p&gt;自定义的函数并不难写，我们随手就来：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def cmp(kid1, kid2):
    return kid1.age &amp;lt; kid2.age if kid1.score == kid2.score else kid1.score &amp;gt; kid2.score&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果看不明白，也没关系，我写成完整版：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def cmp(kid1, kid2):
    if kid1.score == kid2.score:
        return kid1.age &amp;lt; kid2.age
    else:
        return kid1.score &amp;gt; kid2.score&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写完了之后，还没有结束，这个函数是不能直接投入使用的，他和我们之前提到的lambda匿名函数是不一样的。之前的匿名函数只是用来指定字段的，所以我们不能直接将这个函数传递给key，还需要在外面包一层加工处理才可以。不过这一层处理函数Python也已经有现成的工具了，我们可以直接调用，它在functools里，我们来看代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from functools import cmp_to_key

sorted(kids, key=cmp_to_key(cmp))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们来看一下cmp_to_key函数里的源码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def cmp_to_key(mycmp):
    &quot;&quot;&quot;Convert a cmp= function into a key= function&quot;&quot;&quot;
    class K(object):
        __slots__ = ['obj']
        def __init__(self, obj):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) &amp;lt; 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) &amp;gt; 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) &amp;lt;= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) &amp;gt;= 0
        __hash__ = None
    return K&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，在函数内部，它其实定义了一个类，然后在类当中重载了比较函数，最后返回的是一个重载了比较函数的新的对象。这些__lt__, __gt__函数就是类当中重载的比较函数。比如__lt__是小于的判断函数，__eq__是相等的函数。那么问题来了，我们能不能直接在Kid类当中重载比较函数呢，这样就可以直接排序了。&lt;/p&gt;
&lt;p&gt;答案是确定的，我们当然可以这么办，实际上这也是面向对象当中非常常用的做法。相比于自定义比较函数，我们往往更倾向于在类当中定义好优先级。Python当中实现的方法也很简单，就是我们手动实现一个__lt__函数，sorted默认会将小的元素排在前面，所以我们只用实现__lt__一个函数就够了。这个函数当中传入的参数是另一个对象，我们直接在函数里面写清楚比较逻辑就行了。返回True表示当前对象比other小，否则比other大。&lt;/p&gt;
&lt;p&gt;我们附上完整代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Kid:
    def __init__(self, name, score, age):
        self.name = name
        self.score = score
        self.age = age

    def __repr__(self):
        return 'Kid, name: {}, score: {}, age:{}'.format(self.name, self.score, self.age)

    def __lt__(self, other):
        return self.score &amp;gt; other.score or (self.score == other.score and self.age &amp;lt; other.age)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现了比较函数之后，我们直接调用sorted，不用任何其他传参就可以对它进行排序了。&lt;/p&gt;
&lt;p&gt;今天的内容虽然难度不大，但是在我们日常编程当中非常常用，经常会出现需要对复杂的对象和内容进行排序的情况，所以希望大家都掌握，因为一定会派上用场的。&lt;/p&gt;
&lt;p&gt;今天的文章就是这些，如果觉得有所收获，请顺手&lt;strong&gt;扫码点个关注&lt;/strong&gt;吧，你们的举手之劳对我来说很重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/2/25/17079a8f45c782d5?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 25 Feb 2020 00:10:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天的这篇文章和大家聊聊Python当中的排序，和很多高级语言一样，Python封装了成熟的排序函数。我们只需要调用内部的sort函数，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12359924.html</dc:identifier>
</item>
<item>
<title>在Ubuntu上部署一个基于webrtc的多人视频聊天服务 - Agile.Zhou</title>
<link>http://www.cnblogs.com/kklldog/p/webrtc-deploy-on-Ubuntu.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kklldog/p/webrtc-deploy-on-Ubuntu.html</guid>
<description>&lt;p&gt;最近研究webrtc视频直播技术，网上找了些教程最终都不太能顺利跑起来的，可能是文章写的比较老，使用的一些开源组件已经更新了，有些配置已经不太一样了，所以按照以前的步骤会有问题。折腾了一阵终于跑起来了，记录一下。&lt;/p&gt;
&lt;h2 id=&quot;一个简单的聊天室html页面&quot;&gt;一个简单的聊天室html页面&lt;/h2&gt;
&lt;p&gt;这个页面使用simple-webrtc来实现webrtc的通讯，simple-webrtc是对几个webrtc核心对象的封装，所以使用这个会比较简单。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;webrtc chat room &amp;lt;/title&amp;gt;
  &amp;lt;style&amp;gt;
    video {
      height: 200px;
      width: 200px;
      border: 1px solid cornflowerblue;
      border-radius: 3px;
      margin: 10px;
    }
  &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;div&amp;gt;
    roomid: &amp;lt;input id=&quot;roomid&quot; type=&quot;text&quot; value=&quot;&quot;/&amp;gt;   &amp;lt;input type=&quot;button&quot; id=&quot;btnStart&quot; value=&quot;join room&quot;&amp;gt;
  &amp;lt;/div&amp;gt;
  
  &amp;lt;div&amp;gt;
   nick name: &amp;lt;input id =&quot;nickname&quot; readonly=&quot;readonly&quot;  type = &quot;text&quot; value=&quot;&quot;&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;h3&amp;gt;
      self:
  &amp;lt;/h3&amp;gt;
  &amp;lt;video id=&quot;localVideo&quot;&amp;gt;&amp;lt;/video&amp;gt;
  &amp;lt;div id=&quot;remoteVideos&quot;&amp;gt;
      &amp;lt;h3&amp;gt;
          remote clients:
      &amp;lt;/h3&amp;gt;
  &amp;lt;/div&amp;gt;
  &amp;lt;script src=&quot;https://cdn.bootcss.com/jquery/3.3.0/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script src=&quot;js/simplewebrtc-with-adapter.bundle.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;script lang=&quot;javascript&quot;&amp;gt;
    $(&quot;#nickname&quot;).val(new Date().getTime());     
    var qs = function (key) {
        return (document.location.search.match(new RegExp(&quot;(?:^\\?|&amp;amp;)&quot; + key + &quot;=(.*?)(?=&amp;amp;|$)&quot;)) || ['', null])[1];
    };

    var roomid = qs(&quot;roomid&quot;);
    if (roomid) {
     $('#roomid').val(roomid);
    }
    else {
     $('#roomid').val('99999');
    }
   // $('#roomid').val(roomid);
    var smUrl = 'https://webrtc.xxx.com:8800';
    var webrtc = new SimpleWebRTC({
      // the id/element dom element that will hold &quot;our&quot; video
      localVideoEl: 'localVideo',
      // the id/element dom element that will hold remote videos
      remoteVideosEl: 'remoteVideos',
      // immediately ask for camera access
      autoRequestMedia: true,
      url: smUrl,
      nick: $('#nickname').val(),
    });

    webrtc.on('readyToCall', function () {
      // you can name it anything
      console.log('connectioned .');
    });
    webrtc.on(&quot;createdPeer&quot;, function (peer) {
        console.log('createdPeer', peer, peer.nick );
    if (peer.nick) {
      alert('client '+ peer.nick + ' joined');
    }
    });
    webrtc.on(&quot;joinedRoom&quot;, (roomName )=&amp;gt;{
        console.log('joinedRoom', roomName );
    alert('joined room ' + roomName );
    });
    webrtc.on(&quot;leftRoom&quot;, (roomName )=&amp;gt;{
        console.log('leftRoom', roomName );
    });
    webrtc.on(&quot;videoAdded&quot;, (videoEl, peer )=&amp;gt;{
        console.log('videoAdded', videoEl, peer );
    if (peer.nick) {
     alert('client '+ peer.nick + ' joined');
    }
    });
    webrtc.on(&quot;videoRemoved&quot;, (videoEl, peer )=&amp;gt;{
        console.log('videoRemoved', videoEl, peer );
    });
    $('#btnStart').click(function(){
      var roomId = $('#roomid').val();
      webrtc.joinRoom(roomId);   
     // alert('join room '+ roomId +' success')   
    })
    //$('#btnStart').click();
  &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;安装nginx并部署聊天室页面&quot;&gt;安装nginx并部署聊天室页面&lt;/h2&gt;
&lt;h3 id=&quot;安装nginx&quot;&gt;安装nginx：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;sudo apt-get install nginx&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置nginx&quot;&gt;配置nginx：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;server {
                listen 80;
                listen 443;
                server_name webrtc.xxx.com;
                location / {
                                index index.html;
                                root html/www;
                        }
                ssl on;
        ssl_certificate /ssl/xxx.crt;
        ssl_certificate_key /ssl/xxx.key;
        ssl_session_timeout 5m;
        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;

        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装完成nginx后把上面的html页面使用nginx部署到服务器。注意需要走https，因为chrome的设定不走https没法调用起摄像头跟麦克风。&lt;/p&gt;
&lt;h2 id=&quot;安装并配置signalmaster信令服务&quot;&gt;安装并配置signalmaster信令服务&lt;/h2&gt;
&lt;p&gt;信令服务是用来在客户端之间传输webrtc的客户端信息。因为在webrtc建立p2p连接的时候需要对方客户端的相关信息，所以需要一个渠道来转发客户端之间的信息。signalmaster是一个基于nodejs的服务，使用socket.io实现websocket长连接。&lt;/p&gt;
&lt;h3 id=&quot;安装signalmaster&quot;&gt;安装signalmaster:&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;git clone https://github.com/simplewebrtc/signalmaster.git&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置signalmaster&quot;&gt;配置signalmaster：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cd signalmaster
cd config
vim development.json
//编辑
{
  &quot;isDev&quot;: true,
  &quot;server&quot;: {
    &quot;port&quot;: 8800,
    &quot;/* secure */&quot;: &quot;/* whether this connects via https */&quot;,
    &quot;secure&quot;: true,
    &quot;cert&quot;: &quot;/ssl/xxx.crt&quot;,
    &quot;key&quot;: &quot;/ssl/xxx.key&quot;,
    &quot;password&quot;: null
  },
  &quot;rooms&quot;: {
    &quot;/* maxClients */&quot;: &quot;/* maximum number of clients per room. 0 = no limit */&quot;,
    &quot;maxClients&quot;: 0
  },
  &quot;stunservers&quot;: [
    {
      &quot;urls&quot;: &quot;stun:webrtc.xxx.com:3478&quot;
    }
  ],
  &quot;turnservers&quot;: [
    {
      &quot;urls&quot;: [&quot;turn:webrtc.xxx.com:3478&quot;],
      &quot;username&quot;: &quot;abc&quot;,
      &quot;credential&quot;: &quot;123&quot;,
      &quot;secret&quot;: &quot;&quot;,
      &quot;expiry&quot;: 86400
    }
  ]
}
~  &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要注意的是也需要配置ssl证书，证书使用上面nginx那个证书即可。另外trunserver如果设置了密码也需要配置正确的用户名跟密码。&lt;/p&gt;
&lt;h2 id=&quot;安装并配置coturn穿透服务&quot;&gt;安装并配置coturn穿透服务&lt;/h2&gt;
&lt;p&gt;我们的客户端一般都在局域网之内，所以p2p连接建立的时候需要进行内网穿透。使用coturn建立turnserver作为穿透服务。&lt;/p&gt;
&lt;h3 id=&quot;安装coturn&quot;&gt;安装coturn：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;# deps
apt-get install -y \
    emacs-nox \
    build-essential \
    libssl-dev sqlite3 \
    libsqlite3-dev \
    libevent-dev \
    g++ \
    libboost-dev \
    libevent-dev

# download
wget https://github.com/coturn/coturn/archive/4.5.0.7.tar.gz
tar xvf 4.5.0.7.tar.gz

# build &amp;amp; install
cd coturn-4.5.0.7
./configure --prefix=/opt
make
make install

# env
echo &quot;export PATH=/opt/bin:$PATH&quot; &amp;gt;&amp;gt; ~/.bashrc
source ~/.bashrc&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置coturn&quot;&gt;配置coturn：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cd coturn-4.5.0.7
vim coturn.conf
#server
listening-port=3478
listening-ip= 
relay-ip= 
alt-listening-port=0
external-ip= 
realm=abc

# server-name={YOUR_SERVER_NAME}

no-tls
no-dtls
mobility
no-cli
verbose
fingerprint

# auth
lt-cred-mech
stale-nonce=3600

# user
# 这里是演示，不配置数据库，通过 use={name}:{password} 方式配置
# userdb=/opt/var/db/turndb
# 多用户则写多行
user=abc:123&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里主要需要注意的是ip的配置listening-ip=内网ip，relay-ip=内网ip，external-ip=外网ip。还有user配置了话，信令服务器也要配置对应的用户名密码。&lt;/p&gt;
&lt;h2 id=&quot;运行所有服务&quot;&gt;运行所有服务&lt;/h2&gt;
&lt;h3 id=&quot;运行信令服务&quot;&gt;运行信令服务：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cd signalmaster
node server.js&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;运行穿透服务器&quot;&gt;运行穿透服务器：&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;cd coturn-4.5.0.7
turnserver -c coturn.conf&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问一下nginx部署的静态页面就可以啦。开两个网页，自己可以跟自己试一下，最好找其他朋友试一下，有的时候穿透服务没配置好的时候，自己跟自己是可以的，但是跟其他人就不可以了。&lt;br/&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/kklldog/1401672/o_200224165558%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200225005509.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/32093871&quot;&gt;Coturn: TURN and STUN Server&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yubaolee/p/webrtc.html&quot;&gt;5分钟快速打造WebRTC视频聊天&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://webrtc.org/&quot;&gt;Real-time communication for the web&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/coturn/coturn&quot;&gt;coturn&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://github.com/simplewebrtc/signalmaster&quot;&gt;signalmaster&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Feb 2020 17:22:00 +0000</pubDate>
<dc:creator>Agile.Zhou</dc:creator>
<og:description>最近研究webrtc视频直播技术，网上找了些教程最终都不太能顺利跑起来的，可能是文章写的比较老，使用的一些开源组件已经更新了，有些配置已经不太一样了，所以按照以前的步骤会有问题。折腾了一阵终于跑起来了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kklldog/p/webrtc-deploy-on-Ubuntu.html</dc:identifier>
</item>
<item>
<title>你知道数字签名吗？ - AhuntSun</title>
<link>http://www.cnblogs.com/AhuntSun-blog/p/12359656.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AhuntSun-blog/p/12359656.html</guid>
<description>&lt;h2 id=&quot;数字签名&quot;&gt;数字签名&lt;/h2&gt;
&lt;h3 id=&quot;一数字签名简介&quot;&gt;一、数字签名简介&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;数字签名是基于公钥密码体制（非对称密钥密码体制）的。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;基本特征&quot;&gt;1.1.基本特征&lt;/h4&gt;
&lt;p&gt;数字签名必须保证以下三点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;报文鉴别&lt;/strong&gt;——接收者能够核实发送者对报文的签名；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;报文的完整性&lt;/strong&gt;——接收者不能伪造对报文的签名或更改报文内容。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不可否认&lt;/strong&gt;——发送者事后不能抵赖对报文的签名；&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;数字签名的验证过程&quot;&gt;1.2.数字签名的验证过程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/1.png&quot; alt=&quot;image-20200203210110403&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图位用户A使用数字签名向用户B传输一份文件的过程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，文件经过单向散列函数的处理得到一份占128位的摘要（无论文件多大，经过单向散列函数的处理，生成的摘要都是128位），这份摘要相当于该文件的&quot;指纹&quot;，能够唯一地识别文件。&lt;strong&gt;注意：&lt;/strong&gt;只要文件发生改动，经过单向散列函数处理后得到地摘要都会不一样。所以，文件和文件的摘要具有很强的对应关系。&lt;/li&gt;
&lt;li&gt;随后，用户A使用自己地私钥对这份128位地摘要进行加密，得到一份加密地摘要。&lt;/li&gt;
&lt;li&gt;然后，用户A把文件、加密的摘要和公钥打包一起发给用户B。传输的过程中并没有对文件进行加密处理。&lt;/li&gt;
&lt;li&gt;用户B将收到的文件经过单向散列函数处理得出一份128位摘要，这份摘要是通过收到的文件得到的，存在被更改的可能；使用A提供的公钥对收到的&quot;加密的摘要&quot;进行解密得到另一份128位摘要，这份摘要是通过原始文件得到的，一般认为代表真正的文件；然后将两份摘要进行比较。&lt;/li&gt;
&lt;li&gt;如果两份摘要相等，说明文件经过用户A签名之后，在传输的过程中没有被更改；若不相等，说明文件在传输过程中被更改了，或者说已经不是原来的文件了，此时用户A的签名失效。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;strong&gt;数字签名三个特征的验证&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;不可否认&lt;/strong&gt;——只有用户A拥有私钥A，并能使用私钥A产生&quot;加密的摘要&quot;，这样用户A就不能否认给用户B发送了经过签名的密文。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;报文的完整性&lt;/strong&gt;——用户B通过比较得出的两份摘要是否相等，可以判断签名或文件内容是否发生改变。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;报文鉴别&lt;/strong&gt;——用户B可以使用收到的公钥对&quot;加密的摘要&quot;进行解密，从而核实用户A对文件的签名。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;需要强调&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;用户A使用私钥对由文件生成的128位摘要进行加密的过程称为&lt;strong&gt;数字签名的过程&lt;/strong&gt;，得到的&lt;strong&gt;&quot;加密的摘要&quot;&lt;/strong&gt;，称为该文件的&lt;strong&gt;数据签名&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;用户A使用私钥加密的是摘要而不是文件。&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用户B验证签名实际上是比较得出的两份摘要是否相等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;数字签名使用的场合&quot;&gt;1.3.数字签名使用的场合&lt;/h4&gt;
&lt;p&gt;什么时候使用这种不对文件加密，而对文件的摘要加密（对文件进行签名）的技术呢？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数字签名解决的核心问题是：&lt;strong&gt;确保收到的文件没有被更改&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;比如：公司的领导给员工下发放假通知，这时候就需要对邮件进行数字签名来证明这个通知是领导发的。员工收到通知，看到上面有领导的签名，于是就可以放心休假了。如果有人冒充领导发通知，上面没有领导的签名，员工休假回来就要扣工资。同样的，通知有了领导的签名，领导想抵赖也不行。&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;h3 id=&quot;二证书颁发机构ca&quot;&gt;二、证书颁发机构CA&lt;/h3&gt;
&lt;h4 id=&quot;ca简介&quot;&gt;2.1CA简介&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;证书颁发机构，即认证中心&lt;strong&gt;CA&lt;/strong&gt; (Certification Authority)，来将公钥与其对应的实体（人或机器）进行&lt;strong&gt;绑定&lt;/strong&gt;(binding)；即给公司或个人颁发证书。&lt;/li&gt;
&lt;li&gt;认证中心一般由政府出资建立。每个实体都有CA 发来的&lt;strong&gt;证书&lt;/strong&gt;(certificate)，里面有公钥及其拥有者的标识信息。此证书被 CA 进行了数字签名。任何用户都可从可信的地方获得认证中心 CA 的公钥，此公钥用来验证某个公钥是否为某个实体所拥有。有的大公司也提供认证中心服务。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/2.png&quot; alt=&quot;image-20200203230237525&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，用户A使用数字签名时给用户B发送了一个数据包，数据包中包含了A的公钥、文件和加密的摘要。那么问题来了：&lt;strong&gt;用户B如何确定收到的公钥是用户A发送的，而不是他人冒充用户A发送的呢？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;举个例子：把用户A的公钥和私钥假设为身份证。如果是用户A自己造的身份证别人会信吗？反之，用户A拿着真正的身份证去住宾馆，老板一开始也不相信身份证是用户A的，但是老板相信给用户A发身份证的公安局，老板通过比对公安网上对应身份证号码的信息就可以判断这个身份证是不是用户A的，由此可以确认用户A的身份。&lt;/li&gt;
&lt;li&gt;同理，B一开始并不确认收到的公钥是来自用户A的，用户A也可抵赖B收到的公钥不是自己发送的。这时就需要有一个双方都信任的第三方证书颁发机构来协调。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;证书颁发和使用过程&quot;&gt;2.2.证书颁发和使用过程&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/3.png&quot; alt=&quot;image-20200206155804062&quot;/&gt;&lt;/p&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;首先，用户A向证书颁发机构提交个人信息，申请证书。通过CA审核后，CA生成用户A的证书，证书中包括了A的公钥和私钥还有CA的数字签名。证书颁发机构CA本身拥有一对密钥，这是对CA所颁发的证书进行数字签名和保密的基础，绝不能泄露。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;用户A收到的证书中包括了带有CA数字签名的，专属A公钥和私钥，CA的数字签名确保了别人不能伪造用户A的公钥和私钥。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;同时，用户B也必须信任给用户A颁发证书的第三方认证机构CA，即用户B拥有CA颁发的&quot;CA公钥&quot;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;通信时，用户A向用户B发送的数据包中的&quot;加密的摘要&quot;上有用户A的数字签名，“A公钥” 上有认证机构CA的数字签名。用户B收到数据包之后，先要验证收到的 “A公钥” 是否来源合法：是认证机构颁发的带有CA签名的公钥吗？用户B并不信任用户A，但是用户B信任第三方认证机构CA。所以，用户B先使用证书颁发机构颁发的 &quot;CA公钥&quot; 验证收到的 &quot;A公钥&quot; 是否由同一认证机构颁发，是否在颁发之后更改过。&lt;/p&gt;
&lt;p&gt;验证通过后，用户B便相信收到的 &quot;A公钥&quot; 确实来自真实的用户A。随后再使用 &quot;A公钥&quot; 对 &quot;加密的摘要&quot; 进行解密，进行上文提到的对比操作，以判断文件是否更改。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;查看计算机信任的认证机构&quot;&gt;2.3.查看计算机信任的认证机构&lt;/h4&gt;
&lt;p&gt;信任一个第三方认证机构就意味着拥有该机构颁发的包含该机构公钥的证书。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在Windows系统开始菜单中输入&quot;MMC&quot;命令，打开 &quot;Microsoft 管理工具&quot; 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/4.png&quot; alt=&quot;image-20200206161418997&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;打开 &quot;文件&quot; 菜单栏，选择 &quot;添加或删除管理单元&quot; 选项，找到 &quot;证书&quot; 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/5.png&quot; alt=&quot;image-20200206161615998&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点击 &quot;添加&quot; ，选择需要查看帐户的证书。可重复操作，添加多个账户。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/6.png&quot; alt=&quot;image-20200206161729657&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;添加完成之后，点击 &quot;确认&quot; ，即可查看相关帐户的证书。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/7.png&quot; alt=&quot;image-20200206161906853&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/8.png&quot; alt=&quot;image-20200206162019459&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;双击列表中的一个 &quot;证书&quot; ，在 &quot;详细信息&quot; 中可以找到证书对应的 &quot;公钥&quot; 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/9.png&quot; alt=&quot;image-20200203235946196&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/ahuntsun/BlogImgs/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/7.3.%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/10.png&quot; alt=&quot;image-20200204000011441&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;证书的吊销&quot;&gt;2.4.证书的吊销&lt;/h4&gt;
&lt;p&gt;当用户A遗失或泄露了CA颁发的证书后，为了避免他人使用该证书冒充用户A，用户A向认证机构CA &quot;挂失&quot; 该证书。于是认证机构CA把该证书放入该认证机构的证书吊销列表（CRL）中，并在网上公示。&lt;/p&gt;
&lt;p&gt;用户B在收到用户A的公钥时，除了要验证该公钥是否位认证机构颁发的，还要登录认证机构的网站查看该公钥是否已被认证机构吊销变为无效证书。&lt;/p&gt;
&lt;h4 id=&quot;总结&quot;&gt;2.5.总结&lt;/h4&gt;
&lt;p&gt;认证机构CA的作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为企业和用户颁发数字证书，确保这些企业和个人的身份是真实的；&lt;/li&gt;
&lt;li&gt;发布证书吊销列表，供用户查询收到的证书是否已被机构吊销而无效；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;认证机构发挥作用的前提：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;企业和个人都要信任认证机构。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 24 Feb 2020 16:01:00 +0000</pubDate>
<dc:creator>AhuntSun</dc:creator>
<og:description>数字签名 一、数字签名简介 数字签名是基于公钥密码体制（非对称密钥密码体制）的。 1.1.基本特征 数字签名必须保证以下三点： 报文鉴别 ——接收者能够核实发送者对报文的签名； 报文的完整性 ——接收</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AhuntSun-blog/p/12359656.html</dc:identifier>
</item>
<item>
<title>分析思维 第四篇：数据分析入门阶段——描述性统计分析和相关分析 - 悦光阴</title>
<link>http://www.cnblogs.com/ljhdo/p/11501415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljhdo/p/11501415.html</guid>
<description>&lt;p&gt;数据分析的入门思维，首先要认识数据，然后对数据进行简单的分析，比如描述性统计分析和相关性分析等。&lt;/p&gt;
&lt;h2&gt;一，认识变量和数据&lt;/h2&gt;
&lt;p&gt;变量和数据是数据分析中常用的概念，用变量来描述事物的特征，而数据是变量的具体值，把变量的值也叫做观测值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，变量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;变量是用来描述总体中成员的某一个特性，例如，性别、年龄、身高、收入等。&lt;/p&gt;
&lt;p&gt;变量可以分为：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;定性变量：用于分类，一般是文本，例如，性别、颜色&lt;/li&gt;
&lt;li&gt;定序变量：用于表示等级或次序的变量，例如，学历，职位，排名等，变量的值可以把事务排列为高低或大小，但是各个变量值之间没有确切的间隔距离，无法确定两个定序变量之间相差多少。&lt;/li&gt;
&lt;li&gt;定量变量：是数量变量，能够比较大小。分为两类：离散变量和连续变量。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2，数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据是变量的具体值，按照变量的类型，可以把数据分为：分类数据、顺序数据和数值型数据。&lt;/p&gt;
&lt;p&gt;按照数据分析的目的，可以把数据分为实验组（Treatment）和参照组（Control）。&lt;/p&gt;
&lt;p&gt;按照数据的类型，可以把数据分为：文本数据、数值型数据和日期时间数据。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3，缺失值&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不是所有的数据都是完整的，有些观测值可能会缺失，对于缺失值，通常的处理方式是：删除缺失值所在的数据行，填充缺失值、插补缺失值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，观测值的重编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数据分析中，通常需要把连续型变量转换为定序变量，例如，把学生的成绩划分为优秀、良好、合格和差4个等级，这种操作也称作离散化。&lt;/p&gt;
&lt;p&gt;当观测数据所用的单位可能影响数据分析时，还需要对数据进行规范化，常用的规范化方法是：最小-最大规范化，标准化变换等。&lt;/p&gt;
&lt;p&gt;观测值的重编码，后续会有详细的介绍。&lt;/p&gt;
&lt;h2&gt;二，描述性统计分析&lt;/h2&gt;
&lt;p&gt;描述性统计量分为：集中趋势、离散程度（离中趋势）和分布形态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1，集中趋势的描述性统计量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;均值：是指一组数据的算术平均数，描述一组数据的平均水平，是集中趋势中波动最小、最可靠的指标，但是均值容易受到极端值（极小值或极大值）的影响。&lt;/li&gt;
&lt;li&gt;中位数：是指当一组数据按照顺序排列后，位于中间位置的数，不受极端值的影响，对于定序型变量，中位数是最适合的表征集中趋势的指标。&lt;/li&gt;
&lt;li&gt;众数：是指一组数据中出现次数最多的观测值，不受极端值的影响，常用于描述定性数据的集中趋势。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;2，离散程度的描述性统计量&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;最大值和最小值：是一组数据中的最大观测值和最小观测值&lt;/li&gt;
&lt;li&gt;极差：又称全距，是一组数据中的最大观测值和最小观测值之差，记作R，一般情况下，极差越大，离散程度越大，其值容易受到极端值的影响。&lt;/li&gt;
&lt;li&gt;方差和标准差：是描述一组数据离散程度的最常用、最适用的指标，值越大，表明数据的离散程度越大。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;3，分布形态的描述性统计量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;偏度：用来评估一组数据的分布呈先的对称程度，当偏度=0时，分布是对称的；当偏度&amp;gt;0时，分布呈正偏态；当偏度&amp;lt;0时，分布呈负偏态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/628084/202002/628084-20200224215336250-219120326.png&quot; alt=&quot;&quot; width=&quot;441&quot; height=&quot;242&quot;/&gt;&lt;/p&gt;
&lt;p&gt;峰度：用来评估一组数据的分布形状的高低程度的指标，当峰度=0时，分布和正态分布基本一直；当峰度&amp;gt;0时，分布形态高狭；当峰度&amp;lt;0时，分布形态低阔。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/i-beta/628084/202002/628084-20200224215702224-1582066260.png&quot; alt=&quot;&quot; width=&quot;446&quot; height=&quot;248&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4，频率分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;频数分布分析（又称频率分析）主要通过频数分布表、条形图和直方图、百分位值等来描述数据的分布特征。&lt;/p&gt;
&lt;p&gt;在做频数分布分析时，通常按照定性数据（即分类的类别），统计各个分类的频数，计算各个分类所占的百分比，进而得到频率分布表，最后根据频率分布表来绘制频率分布图。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/i-beta/628084/202002/628084-20200224223106575-705208244.png&quot; alt=&quot;&quot; width=&quot;374&quot; height=&quot;325&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5，按照时间递增的趋势分析&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;特殊情况下，当X轴是日期数据，Y轴是统计量（比如均值、总数量）时，可以绘制出统计量按照时间递增的趋势图，从图中可以看到统计量按照时间增加的趋势（无变化、递增或递减）和周期性。&lt;/p&gt;
&lt;p&gt;例如，下图的X轴是日期，Y轴的统计量是总数量，两条折线分别是湖北确诊病例人数和湖北新增确诊病例人数：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/common/628084/202002/628084-20200224230459840-631149493.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;200&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;三，相关性分析 &lt;/h2&gt;
&lt;p&gt;相关性分析是研究事务之间是否存在某种依存关系，并对具有依存关系的现象进行相关方向和相关程度的分析。&lt;/p&gt;
&lt;p&gt;相关程度用相关系数r表示，|r|&amp;lt;=1，r=0表示不相关，通常情况下，0 &amp;lt; | r | &amp;lt;1表示变量之间存在不同程度的线性相关，根据约定的规则：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;| r | &amp;lt;=0.3 ：为弱线性相关或不存在线性相关；&lt;/li&gt;
&lt;li&gt;0.3 &amp;lt; | r | &amp;lt;=0.5 ：低度线性相关，认为存在线性相关，但是相关性不明显&lt;/li&gt;
&lt;li&gt;0.5 &amp;lt; | r | &amp;lt;=0.8 ：显著线性相关，认为存在强线性相关，存在明显的相关性&lt;/li&gt;
&lt;li&gt;| r | &amp;gt;0.8 ：高度相关，认为存在极强的线性相关&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考文档：&lt;/p&gt;
</description>
<pubDate>Mon, 24 Feb 2020 14:46:00 +0000</pubDate>
<dc:creator>悦光阴</dc:creator>
<og:description>数据分析的入门思维，首先要认识数据，然后对数据进行简单的分析，比如描述性统计分析和相关性分析等。 一，认识变量和数据 变量和数据是数据分析中常用的概念，用变量来描述事物的特征，而数据是变量的具体值，把</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ljhdo/p/11501415.html</dc:identifier>
</item>
<item>
<title>drf认证组件、权限组件、jwt认证、签发、jwt框架使用 - 辜老板</title>
<link>http://www.cnblogs.com/guyouyin123/p/12359351.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/guyouyin123/p/12359351.html</guid>
<description>&lt;h2 id=&quot;urls.py&quot;&gt;urls.py&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;router.register('register', views.RegisterViewSet, 'register')
from rest_framework_jwt.views import ObtainJSONWebToken
urlpatterns = [
    url('^login/$', ObtainJSONWebToken.as_view()),
    url('', include(router.urls))
]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;views.py&quot;&gt;views.py&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework.viewsets import GenericViewSet, ModelViewSet
from rest_framework import mixins
from . import models, serializers

class RegisterViewSet(GenericViewSet, mixins.CreateModelMixin):
    queryset = models.User.objects.filter(is_active=True).all()
    serializer_class = serializers.RegisterSerializer
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;serializers.py&quot;&gt;serializers.py&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework import serializers
from rest_framework.exceptions import ValidationError
from . import models


class RegisterSerializer(serializers.ModelSerializer):
    re_password = serializers.CharField(write_only=True, min_length=8, max_length=18)
    class Meta:
        model = models.User
        fields = ('username', 'password', 're_password', 'mobile')
        extra_kwargs = {
            'password': {
                'write_only': True,
                'min_length': 8,
                'max_length': 18
            }
        }

    # username和mobile可以自定义局部钩子校验（省略）

    def validate(self, attrs):
        password = attrs.get('password')
        re_password = attrs.pop('re_password')
        if password != re_password:
            raise ValidationError({'re_password': 'password confirm error'})
        return attrs

    # 需要重写create，创建用户需要密文
    def create(self, validated_data):
        return models.User.objects.create_user(**validated_data)&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;调用写好的登录接口即可&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework_jwt.views import ObtainJSONWebToken
urlpatterns = [
    url('^login/$', ObtainJSONWebToken.as_view()),

    url('', include(router.urls))
]&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;urls.py-1&quot;&gt;urls.py&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;router.register('user/center', views.UserCenterViewSet, 'center')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;views.py-1&quot;&gt;views.py&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework.permissions import AllowAny, IsAuthenticated, IsAdminUser, IsAuthenticatedOrReadOnly
class UserCenterViewSet(GenericViewSet, mixins.RetrieveModelMixin):
    permission_classes = [IsAuthenticated, ]
    queryset = models.User.objects.filter(is_active=True).all()
    serializer_class = serializers.UserCenterSerializer&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;'''
AllowAny:游客也可访问
IsAuthenticated：必须登录的用户  才有权限
IsAdminUser：必须登录，并且时后台用户  才有权限
IsAuthenticatedOrReadOnly：读可以(get请求可以)，但是写(post请求)必须登录
'''&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;serializers.py-1&quot;&gt;serializers.py&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class UserCenterSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.User
        fields = ('username', 'mobile', 'icon', 'email')&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;urls.py-2&quot;&gt;urls.py&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;router.register('books', views.BookViewSet, 'book')&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;views.py-2&quot;&gt;views.py&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class BookViewSet(ModelViewSet):
    queryset = models.Book.objects.all()
    serializer_class = serializers.BookSerializer&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;serializers.py-2&quot;&gt;serializers.py&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class BookSerializer(serializers.ModelSerializer):
    class Meta:
        model = models.Book
        fields = ('name', )&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;重点&quot;&gt;重点&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
1）认证规则
2）如何自定义认证类
3）我们一般不需要自定义认证类，在settings中全局配置第三方 jwt 认证组件提供的认证类即可
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义认证类&quot;&gt;自定义认证类&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
1）自定义认证类，继承 BaseAuthentication 类
2）必须重写 authenticate(self, request) 方法
    没有认证信息，返回None：匿名用户(游客) =&amp;gt; 匿名用户request.user也有值，就是&quot;匿名对象(Anonymous)&quot;
    有认证信息，且通过，返回(user, token)：合法用户 =&amp;gt; user对象会存到request.user中
    有认证信息，不通过，抛异常：非法用户
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;重点-1&quot;&gt;重点&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
1）权限规则
2）如何自定义权限类
3）我们一般在视图类中局部配置drf提供的权限类，但是也会自定义权限类完成局部配置
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;自定义权限类&quot;&gt;自定义权限类&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
1）自定义权限类，继承 BasePermission 类
2）必须重写 has_permission(self, request, view): 方法
    设置权限条件，条件通过，返回True：有权限
    设置权限条件，条件失败，返回False：有权限
    
3）drf提供的权限类：
AllowAny：匿名与合法用户都可以
IsAuthenticated：必须登录，只有合法用户可以
IsAdminUser：必须是admin后台用户
IsAuthenticatedOrReadOnly：匿名只读(get请求可以)(post请求不可以)，合法用户无限制
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1736414/202002/1736414-20200224223142747-679334855.png&quot;/&gt;&lt;/p&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot; jwt优势
1）没有数据库写操作，高效
2）服务器不存token，低耗
3）签发校验都是算法，集群
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1736414/202002/1736414-20200224223232860-427544498.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1736414/202002/1736414-20200224223255151-1103321729.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1736414/202002/1736414-20200224223321412-171396884.png&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1736414/202002/1736414-20200224223322891-1134995598.png&quot;/&gt;&lt;/p&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
1）jwt分三段式：头.体.签名 （head.payload.sgin）
2）头和体是可逆加密，让服务器可以反解出user对象；签名是不可逆加密，保证整个token的安全性的
3）头体签名三部分，都是采用json格式的字符串，进行加密，可逆加密一般采用base64算法，不可逆加密一般采用hash(md5)算法
4）头中的内容是基本信息：公司信息、项目组信息、token采用的加密方式信息
{
    &quot;company&quot;: &quot;公司信息&quot;,
    ...
}
5）体中的内容是关键信息：用户主键、用户名、签发时客户端信息(设备号、地址)、过期时间
{
    &quot;user_id&quot;: 1,
    ...
}
6）签名中的内容时安全信息：头的加密结果 + 体的加密结果 + 服务器不对外公开的安全码 进行md5加密
{
    &quot;head&quot;: &quot;头的加密字符串&quot;,
    &quot;payload&quot;: &quot;体的加密字符串&quot;,
    &quot;secret_key&quot;: &quot;安全码&quot;
}
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;签发根据登录请求提交来的-账号-密码-设备信息-签发-token&quot;&gt;签发：根据登录请求提交来的 账号 + 密码 + 设备信息 签发 token&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
1）用基本信息存储json字典，采用base64算法加密得到 头字符串
2）用关键信息存储json字典，采用base64算法加密得到 体字符串
3）用头、体加密字符串再加安全码信息存储json字典，采用hash md5算法加密得到 签名字符串

账号密码就能根据User表得到user对象，形成的三段字符串用 . 拼接成token返回给前台
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;校验根据客户端带token的请求-反解出-user-对象&quot;&gt;校验：根据客户端带token的请求 反解出 user 对象&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
1）将token按 . 拆分为三段字符串，第一段 头加密字符串 一般不需要做任何处理
2）第二段 体加密字符串，要反解出用户主键，通过主键从User表中就能得到登录用户，过期时间和设备信息都是安全信息，确保token没过期，且时同一设备来的
3）再用 第一段 + 第二段 + 服务器安全码 不可逆md5加密，与第三段 签名字符串 进行碰撞校验，通过后才能代表第二段校验得到的user对象就是合法的登录用户
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
1）用账号密码访问登录接口，登录接口逻辑中调用 签发token 算法，得到token，返回给客户端，客户端自己存到cookies中

2）校验token的算法应该写在认证类中(在认证类中调用)，全局配置给认证组件，所有视图类请求，都会进行认证校验，所以请求带了token，就会反解出user对象，在视图类中用request.user就能访问登录的用户

注：登录接口需要做 认证 + 权限 两个局部禁用
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;安装终端&quot;&gt;安装（终端）&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;: pip install djangorestframework-jwt&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;签发token&quot;&gt;签发token&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;(登录接口)：视图类已经写好了，配置一下路由就行（urls.py）&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework_jwt.views import ObtainJSONWebToken
# api/urls.py
urlpatterns = [
    # ...
    url('^login/$', ObtainJSONWebToken.as_view()),
]

# Postman请求：/api/login/，提供username和password即可&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;校验token认证组件&quot;&gt;校验token(认证组件)&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;认证类已经写好了，全局配置一下认证组件就行了（settings.py）&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# drf-jwt的配置
import datetime
JWT_AUTH = {
    # 配置过期时间
    'JWT_EXPIRATION_DELTA': datetime.timedelta(days=7),
}


# drf配置（把配置放在最下方）
REST_FRAMEWORK = {
    # 自定义三大认证配置类们
    'DEFAULT_AUTHENTICATION_CLASSES': ['rest_framework_jwt.authentication.JSONWebTokenAuthentication'],
    # 'DEFAULT_PERMISSION_CLASSES': [],
    # 'DEFAULT_THROTTLE_CLASSES': [],
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;设置需要登录才能访问的接口进行测试views.py&quot;&gt;设置需要登录才能访问的接口进行测试（views.py）&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from rest_framework.permissions import IsAuthenticated
class UserCenterViewSet(GenericViewSet, mixins.RetrieveModelMixin):
    # 设置必须登录才能访问的权限类
    permission_classes = [IsAuthenticated, ]

    queryset = models.User.objects.filter(is_active=True).all()
    serializer_class = serializers.UserCenterSerializer&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;测试访问登录认证接口postman&quot;&gt;测试访问登录认证接口（Postman）&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;&quot;&quot;&quot;
1）用 {&quot;username&quot;: &quot;你的用户&quot;, &quot;password&quot;: &quot;你的密码&quot;} 访问 /api/login/ 接口等到 token 字符串

2）在请求头用 Authorization 携带 &quot;jwt 登录得到的token&quot; 访问 /api/user/center/1/ 接口访问个人中心
&quot;&quot;&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1736414/202002/1736414-20200224222118888-683536892.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Feb 2020 14:42:00 +0000</pubDate>
<dc:creator>辜老板</dc:creator>
<og:description>[TOC] 一、注册接口 urls.py views.py serializers.py 二、登录接口 调用写好的登录接口即可 三、用户中心接口（权限校验） urls.py views.py seri</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/guyouyin123/p/12359351.html</dc:identifier>
</item>
<item>
<title>3.【Spring Cloud Alibaba】声明式HTTP客户端-Feign - 程序猿Knight</title>
<link>http://www.cnblogs.com/xjknight/p/12349099.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xjknight/p/12349099.html</guid>
<description>&lt;h3 id=&quot;使用feign实现远程http调用&quot;&gt;使用Feign实现远程HTTP调用&lt;/h3&gt;
&lt;h4 id=&quot;什么是feign&quot;&gt;什么是Feign&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Feign是Netflix开源的声明式HTTP客户端&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;GitHub地址：https://github.com/openfeign/feign&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;实现&quot;&gt;实现&lt;/h5&gt;
&lt;h5 id=&quot;pom.xml&quot;&gt;pom.xml&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;org.springframework.cloud&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;spring-cloud-starter-openfeign&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;
&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;io.github.openfeign&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;feign-httpclient&amp;lt;/artifactId&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;@MapperScan(&quot;com.itmuch.contentcenter.dao&quot;)
@SpringBootApplication
@EnableFeignClients// (defaultConfiguration = GlobalFeignConfiguration.class)
@EnableBinding({Source.class})
public class ContentCenterApplication {&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;@FeignClient(name = &quot;user-center&quot;)
public interface UserCenterFeignClient {
    /**
     * http://user-center/users/{id}
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/users/{id}&quot;)
    UserDTO findById(@PathVariable Integer id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;private final UserCenterFeignClient userCenterFeignClient;

// 1. 代码不可读
// 2. 复杂的url难以维护：https://user-center/s?ie={ie}&amp;amp;f={f}&amp;amp;rsv_bp=1&amp;amp;rsv_idx=1&amp;amp;tn=baidu&amp;amp;wd=a&amp;amp;rsv_pq=c86459bd002cfbaa&amp;amp;rsv_t=edb19hb%2BvO%2BTySu8dtmbl%2F9dCK%2FIgdyUX%2BxuFYuE0G08aHH5FkeP3n3BXxw&amp;amp;rqlang=cn&amp;amp;rsv_enter=1&amp;amp;rsv_sug3=1&amp;amp;rsv_sug2=0&amp;amp;inputT=611&amp;amp;rsv_sug4=611
// 3. 难以相应需求的变化，变化很没有幸福感
// 4. 编程体验不统一
UserDTO userDTO = this.userCenterFeignClient.findById(userId);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;feign的组成&quot;&gt;Feign的组成&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/c99708b8347e4fa4b4d58425d004e1c2/xmlnote/05B9DBA0648E4DA5A26C8722E698C12E/37319&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;细粒度配置自定义&quot;&gt;细粒度配置自定义&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Java代码方式&lt;/li&gt;
&lt;li&gt;配置属性方法&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;指定日志级别&quot;&gt;指定日志级别&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/c99708b8347e4fa4b4d58425d004e1c2/xmlnote/E70A342199424BED922CBC8FD555EBEF/37323&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;java代码方式&quot;&gt;Java代码方式&lt;/h4&gt;
&lt;h5 id=&quot;usercenterfeignclient&quot;&gt;UserCenterFeignClient&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;@FeignClient(name = &quot;user-center&quot;, configuration = GlobalFeignConfiguration.class)
public interface UserCenterFeignClient {
    /**
     * http://user-center/users/{id}
     *
     * @param id
     * @return
     */
    @GetMapping(&quot;/users/{id}&quot;)
    UserDTO findById(@PathVariable Integer id);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;globalfeignconfiguration&quot;&gt;GlobalFeignConfiguration&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * feign的配置类
 * 这个类别加@Configuration注解了，否则必须挪到@ComponentScan能扫描的包以外
 */
public class GlobalFeignConfiguration {
    @Bean
    public Logger.Level level(){
        // 让feign打印所有请求的细节
        return Logger.Level.FULL;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;application.yml&quot;&gt;application.yml&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;logging:
  level:
    com.itmuch.contentcenter.feignclient.UserCenterFeignClient: debug&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置属性方法&quot;&gt;配置属性方法&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/c99708b8347e4fa4b4d58425d004e1c2/xmlnote/9B2F6C79A76B485A95D842EFE2DAFB9A/37333&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/c99708b8347e4fa4b4d58425d004e1c2/xmlnote/B0F47643C3CE41589082820570F9D66C/37337&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;全局配置&quot;&gt;全局配置&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;Java代码方式&lt;/li&gt;
&lt;li&gt;配置属性方式&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;java代码方式-1&quot;&gt;Java代码方式&lt;/h4&gt;
&lt;h5 id=&quot;contentcenterapplication&quot;&gt;ContentCenterApplication&lt;/h5&gt;
&lt;p&gt;&lt;strong&gt;EnableFeignClients&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 扫描mybatis哪些包里面的接口
@MapperScan(&quot;com.itmuch.contentcenter.dao&quot;)
@SpringBootApplication
@EnableFeignClients(defaultConfiguration = GlobalFeignConfiguration.class)
@EnableBinding({Source.class})
public class ContentCenterApplication {&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;/**
 * feign的配置类
 * 这个类别加@Configuration注解了，否则必须挪到@ComponentScan能扫描的包以外
 */
public class GlobalFeignConfiguration {
    @Bean
    public Logger.Level level(){
        // 让feign打印所有请求的细节
        return Logger.Level.FULL;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;配置属性方式&quot;&gt;配置属性方式&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;// 扫描mybatis哪些包里面的接口
@MapperScan(&quot;com.itmuch.contentcenter.dao&quot;)
@SpringBootApplication
@EnableFeignClients// (defaultConfiguration = GlobalFeignConfiguration.class)
@EnableBinding({Source.class})
public class ContentCenterApplication {&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/c99708b8347e4fa4b4d58425d004e1c2/xmlnote/84A6C39C909E40B785F225B186235E65/37349&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;支持的配置项&quot;&gt;支持的配置项&lt;/h4&gt;
&lt;h5 id=&quot;java代码方式支持的配置项&quot;&gt;Java代码方式支持的配置项&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/c99708b8347e4fa4b4d58425d004e1c2/xmlnote/D7A12133F4704DB8B0EE6540F2D243B8/37351&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;配置属性方式支持的配置项&quot;&gt;配置属性方式支持的配置项&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/c99708b8347e4fa4b4d58425d004e1c2/xmlnote/DEA0518EE9A04C6D90D58C6BAE2A2E94/37353&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;配置最佳实践&quot;&gt;配置最佳实践&lt;/h3&gt;
&lt;h4 id=&quot;ribbon配置-vs-feign配置&quot;&gt;Ribbon配置 VS Feign配置&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/c99708b8347e4fa4b4d58425d004e1c2/xmlnote/B800A8DA482C4CAE8F5536404802EA66/37365&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;feign代码方式-vs-属性方式&quot;&gt;Feign代码方式 vs 属性方式&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/c99708b8347e4fa4b4d58425d004e1c2/xmlnote/2A5048CBCCE8436CA51FECDF3B8B8213/37371&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;最佳实践&quot;&gt;最佳实践&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/c99708b8347e4fa4b4d58425d004e1c2/xmlnote/BBD0E55347BA4139BAF2852B1C8FA2A2/37373&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;feign的继承&quot;&gt;Feign的继承&lt;/h3&gt;
&lt;h4 id=&quot;关于继承的争议&quot;&gt;关于继承的争议&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;官方观点：官方不推荐使用&lt;/li&gt;
&lt;li&gt;业界观点：很多公司使用&lt;/li&gt;
&lt;li&gt;个人观点：权衡利弊&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;多参数请求构造&quot;&gt;多参数请求构造&lt;/h3&gt;
&lt;h4 id=&quot;get请求&quot;&gt;Get请求&lt;/h4&gt;
&lt;h5 id=&quot;testcontroller&quot;&gt;TestController&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;@GetMapping(&quot;test-get&quot;)
public UserDTO query(UserDTO userDTO) {
    return testUserCenterFeignClient.query(userDTO);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方法1&quot;&gt;方法1&lt;/h4&gt;
&lt;h5 id=&quot;testusercenterfeignclient&quot;&gt;TestUserCenterFeignClient&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;import com.itmuch.contentcenter.domain.dto.user.UserDTO;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.cloud.openfeign.SpringQueryMap;
import org.springframework.web.bind.annotation.GetMapping;

@FeignClient(name = &quot;user-center&quot;)
public interface TestUserCenterFeignClient {
    @GetMapping(&quot;/q&quot;)
    UserDTO query(@SpringQueryMap UserDTO userDTO);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;方法二&quot;&gt;方法二&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;@FeignClient(name = &quot;user-center&quot;)
public interface UserFeignClient {
  @RequestMapping(value = &quot;/q&quot;, method = RequestMethod.GET)
  public UserDTO query(@RequestParam(&quot;id&quot;) Long id, @RequestParam(&quot;username&quot;) String username);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;post请求包含多个参数&quot;&gt;POST请求包含多个参数&lt;/h4&gt;
&lt;p&gt;下面来讨论如何使用Feign构造包含多个参数的POST请求。假设服务提供者的Controller是这样编写的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@RestController
public class UserController {
  @PostMapping(&quot;/post&quot;)
  public User post(@RequestBody User user) {
    ...
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;我们要如何使用feign去请求呢答案非常简单示例&quot;&gt;我们要如何使用Feign去请求呢？答案非常简单，示例：&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;@FeignClient(name = &quot;microservice-provider-user&quot;)
public interface UserFeignClient {
  @RequestMapping(value = &quot;/post&quot;, method = RequestMethod.POST)
  public User post(@RequestBody User user);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;feign脱离ribbon的使用&quot;&gt;Feign脱离Ribbon的使用&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;

// 脱离ribbon的使用
@FeignClient(name = &quot;baidu&quot;, url = &quot;http://www.baidu.com&quot;)
public interface TestBaiduFeignClient {
    @GetMapping(&quot;&quot;)
    String index();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;resttemplate-vs-feign&quot;&gt;RestTemplate vs Feign&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://note.youdao.com/yws/public/resource/c99708b8347e4fa4b4d58425d004e1c2/xmlnote/81D6464E59D04A9E8BEBFC5AA554E292/37548&quot; alt=&quot;image&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;feign性能优化&quot;&gt;Feign性能优化&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;连接池[提升15%左右]&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;feign:
  sentinel:

    # 为feign整合sentinel
    enabled: true
  client:
    config:
      # 全局配置
      default:
        loggerLevel: full
        requestInterceptors:
          - com.itmuch.contentcenter.feignclient.interceptor.TokenRelayRequestIntecepor
  httpclient:
    # 让feign使用apache httpclient做请求；而不是默认的urlconnection
    enabled: true
    # feign的最大连接数
    max-connections: 200
    # feign单个路径的最大连接数
    max-connections-per-route: 50&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;目前在spring-cloud中服务之间通过restful方式调用有两种方式&quot;&gt;目前，在Spring cloud中服务之间通过restful方式调用有两种方式&lt;/h5&gt;
&lt;ul&gt;&lt;li&gt;restTemplate+Ribbon&lt;/li&gt;
&lt;li&gt;feign&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从实践上看，&lt;strong&gt;采用feign的方式更优雅（feign内部也使用了ribbon做负载均衡）。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 24 Feb 2020 14:38:00 +0000</pubDate>
<dc:creator>程序猿Knight</dc:creator>
<og:description>使用Feign实现远程HTTP调用 什么是Feign Feign是Netflix开源的声明式HTTP客户端 GitHub地址：https://github.com/openfeign/feign 实现</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xjknight/p/12349099.html</dc:identifier>
</item>
</channel>
</rss>