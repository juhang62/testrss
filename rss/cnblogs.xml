<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>用PyCharm打个专业的招呼 - dongfanger</title>
<link>http://www.cnblogs.com/df888/p/14070248.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/df888/p/14070248.html</guid>
<description>&lt;p&gt;PyCharm（读作“拍恰姆”）是 JetBrains 全家桶中的一员，专门用来写 Python 的：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192402585-171272726.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;官方网址是：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jetbrains.com/pycharm/&quot;&gt;https://www.jetbrains.com/pycharm/&lt;/a&gt;&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192403277-1178255258.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;&lt;code&gt;for Professional Developers&lt;/code&gt;，顾名思义，它是为专业开发者而生的。&lt;/p&gt;

&lt;p&gt;PyCharm 有 2 个版本：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192404381-1427593040.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;左边的 Professional 是专业版，需要付（ po ）费（ jie ）。右边的 Community 是社区版，永久免费。一般社区版够用了。我用的是专业版，看着齐全。&lt;/p&gt;

&lt;p&gt;安装完成后，打开：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192404746-1778012068.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;不需要导入配置，点击 OK 按钮：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192405003-1282220817.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;有 2 个主题，个人偏好左边这种，酷酷的。点击左下角 &lt;code&gt;Skip Remaining and Set Defaults&lt;/code&gt; 跳过插件安装，进入主界面（专业版破解后才能看到这个界面，具体破解方法网上贼多）：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192405568-543876023.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;首次打开，还没有创建项目，会出现引导页。选择 &lt;code&gt;New Project&lt;/code&gt;：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192405851-1425098933.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;这是专业版的界面，社区版会简略一点。选择好存放目录后，还需要配置解释器。点击解释器右边的 &lt;code&gt;...&lt;/code&gt; ，切换到 &lt;code&gt;System Interpreter&lt;/code&gt;，选择已经安装好的 Python：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192406197-1984192289.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;OK 后再点击 Create，来了：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192406486-48500055.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;老手可以勾选 &lt;code&gt;Tip of the Day&lt;/code&gt; 左小角 &lt;code&gt;Don't show tips&lt;/code&gt;。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192406952-2007374685.png&quot;/&gt;&lt;/center&gt;

&lt;p&gt;右上角的按钮区可以点击运行，代码编辑区域的行号那如果出现了绿色小箭头，也可以点击运行，甚至是代码编辑区里面右键，文件名右键，都可以运行！看看 PyCharm 想的多周到，生怕你不会运行。运行后结果会从下方弹出来：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192407391-1935524279.png&quot;/&gt;&lt;/center&gt;

&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192407676-851165571.png&quot;/&gt;&lt;/center&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192407949-164059560.png&quot;/&gt;&lt;/center&gt;

&lt;p&gt;开篇我们用的是 Python 自带的 IDLE，现在试试在 PyCharm 中 say hello。先在项目目录中右键创建 .py 文件：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192408344-1032181799.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;输入代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(&quot;hello&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在代码编辑器任意位置右键 Run：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192408634-440973447.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;Python 同样会回应一句 hello：&lt;/p&gt;
&lt;center&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1629545/202012/1629545-20201201192409017-1316314905.png&quot;/&gt;&lt;/center&gt;
&lt;p&gt;没错，是的，你已经会用 PyCharm 写 Python 了！&lt;/p&gt;

&lt;p&gt;本文介绍了 PyCharm 的基本使用，更多技巧请阅读知乎问答 &lt;a href=&quot;https://www.zhihu.com/question/37787004/answer/186042335?utm_division=ge13_3&quot;&gt;你有哪些想要分享的 PyCharm 使用技巧？&lt;/a&gt;，比我写的好太多了。如果使用过程中遇到问题，百度一般能搜出来答案。不行的话就找 Google，安装浏览器插件 ghelper 即可访问，谷歌浏览器和火狐浏览器都支持。还解决不了，有一个办法，就是加入我们的高质量核心交流“Python互助讨论群”，技术面前无大佬，无惧提问，我们都是一群相互取暖的小白，交流经验，共同进步，每周六分享PyCharm使用技巧等知识点，每周日一起刷LeetCode编程题。公众号后台回复”加群“即可。&lt;/p&gt;
</description>
<pubDate>Wed, 02 Dec 2020 00:37:00 +0000</pubDate>
<dc:creator>dongfanger</dc:creator>
<og:description>PyCharm基本使用。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/df888/p/14070248.html</dc:identifier>
</item>
<item>
<title>Steps 组件的设计与实现 - jdf2e</title>
<link>http://www.cnblogs.com/jdrdfe/p/14069941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/jdrdfe/p/14069941.html</guid>
<description>&lt;h3 id=&quot;nutui-组件源码揭秘&quot;&gt;NutUI 组件源码揭秘&lt;/h3&gt;
&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;
&lt;p&gt;本文的主题是 Steps 组件的设计与实现。Steps 组件是 Steps 步骤和 Timeline 组件结合的组件，在此之前他们是两个不同的组件，在 &lt;a href=&quot;http://nutui.jd.com/#/index&quot;&gt;NutUI&lt;/a&gt; 最近一次版本升级的时候将他们合二为一了，来看看在组件的开发过程中是如何一步步实现组件功能的。&lt;/p&gt;
&lt;p&gt;说到 &lt;a href=&quot;http://nutui.jd.com/#/index&quot;&gt;NutUI&lt;/a&gt; ， 可能有些人还不太了解，容我们先简单介绍一下。 &lt;a href=&quot;http://nutui.jd.com/#/index&quot;&gt;NutUI&lt;/a&gt; 是一套京东风格的移动端Vue组件库，开发和服务于移动 Web 界面的企业级前中后台产品。通过 &lt;a href=&quot;http://nutui.jd.com/#/index&quot;&gt;NutUI&lt;/a&gt; ，可以快速搭建出风格统一的页面，提升开发效率。目前已有 50+ 个组件，这些组件被广泛使用于京东的各个移动端业务中。&lt;/p&gt;
&lt;p&gt;在此之前他们要分开使用，但是又有很多功能是交叉的，而且并不能满足步骤和时间同时出现的业务场景，因此将他们进行了合并。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img12.360buyimg.com/imagetools/jfs/t1/115722/17/16343/249914/5f475970E83de92b5/ab4e99e9c5ea175b.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先来看下 Steps 组件的最终呈现效果，数据展示，并带有一些流程性的逻辑。&lt;/p&gt;
&lt;p&gt;组件的功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;根据不同场景采用不同的布局方式&lt;/li&gt;
&lt;li&gt;可以指定当前所在的节点&lt;/li&gt;
&lt;li&gt;可以横向或者纵向排列&lt;/li&gt;
&lt;li&gt;能够动态响应数据的变化&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img14.360buyimg.com/imagetools/jfs/t1/144645/31/5935/581711/5f3e2343Eb79a83c4/a593ea602c554d4c.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般来说在物流信息、流程信息等内容的展示需要使用到这个组件，可以像下面这样使用它。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;nut-steps type=&quot;mini&quot;&amp;gt;
      &amp;lt;nut-step title=&quot;已签收&quot; content=&quot;您的订单已由本人签收。如有疑问您可以联系配送员，感谢您在京东购物。&quot; time=&quot;2020-03-03 11:09:96&quot; /&amp;gt;
      &amp;lt;nut-step title=&quot;运输中&quot; content=&quot;您的订单已达到京东【北京旧宫营业部】&quot; time=&quot;2020-03-03 11:09:06&quot; /&amp;gt;
      &amp;lt;nut-step content=&quot;您的订单已达到京东【北京旧宫营业部】&quot; time=&quot;2020-03-03 11:09:06&quot; /&amp;gt;
      &amp;lt;nut-step content=&quot;您的订单由京东【北京顺义分拣中心】送往【北京旧宫营业部】&quot; time=&quot;2020-03-03 11:09:06&quot; /&amp;gt;
      &amp;lt;nut-step title=&quot;已下单&quot; content=&quot;您提交了订单，请等待系统确认&quot; time=&quot;2020-03-03 11:09:06&quot;/&amp;gt;
&amp;lt;/nut-steps&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;组件封装的思路&quot;&gt;组件封装的思路&lt;/h3&gt;
&lt;p&gt;大多数的组件是一个单独的组件，使用起来很简单，比如我们 NutUI 组件库中的 &lt;code&gt;&amp;lt;nut-button block&amp;gt;默认状态&amp;lt;/nut-button&amp;gt;&lt;/code&gt; 、&lt;code&gt;&amp;lt;nut-icon type=&quot;top&quot;&amp;gt;&amp;lt;/nut-icon&amp;gt;&lt;/code&gt; 等等这样简单的使用方式就可以实现组件的功能。&lt;/p&gt;
&lt;p&gt;这样设计组件是相当优秀的，因为使用者用的时候真的非常方便简单。&lt;/p&gt;
&lt;p&gt;这样简单而优雅的组件设计方式适用于大多数功能简单的组件，但是对于逻辑相对复杂、布局也比较复杂的组件来说就不合适了。&lt;/p&gt;
&lt;p&gt;功能相对复杂的组件，会让组件变得很不灵活，模板固定，使用自由度很低，对于开发者来，组件编码也会变得十分臃肿。&lt;/p&gt;
&lt;p&gt;所以在 vue 组件开发过程中合理使用插槽 slot 特性，让组件更加的灵活和开放。就像下面这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;nut-tab @tab-switch=&quot;tabSwitch&quot;&amp;gt;
  &amp;lt;nut-tab-panel tab-title=&quot;页签一&quot;&amp;gt;这里是页签1内容&amp;lt;/nut-tab-panel&amp;gt;
  &amp;lt;nut-tab-panel tab-title=&quot;页签二&quot;&amp;gt;这里是页签2内容&amp;lt;/nut-tab-panel&amp;gt;
  &amp;lt;nut-tab-panel tab-title=&quot;页签三&quot;&amp;gt;这里是页签3内容&amp;lt;/nut-tab-panel&amp;gt;
  &amp;lt;nut-tab-panel tab-title=&quot;页签四&quot;&amp;gt;这里是页签4内容&amp;lt;/nut-tab-panel&amp;gt;
&amp;lt;/nut-tab&amp;gt;

&amp;lt;nut-subsidenavbar title=&quot;人体识别1&quot; ikey=&quot;9&quot;&amp;gt;
  &amp;lt;nut-sidenavbaritem ikey=&quot;10&quot; title=&quot;人体检测1&quot;&amp;gt;&amp;lt;/nut-sidenavbaritem&amp;gt;
  &amp;lt;nut-sidenavbaritem ikey=&quot;11&quot; title=&quot;细粒度人像分割1&quot;&amp;gt;&amp;lt;/nut-sidenavbaritem&amp;gt;
&amp;lt;/nut-subsidenavbar&amp;gt;

...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有很多相对复杂的组件采用这种方式，既能保证组件功能的完整性，也能自由配置子元素内容。&lt;/p&gt;
&lt;h3 id=&quot;组件的实现&quot;&gt;组件的实现&lt;/h3&gt;
&lt;p&gt;基于上面的设计思路，就可以着手实现组件了。&lt;/p&gt;
&lt;p&gt;本文的 Steps 组件，包含外层的 &lt;code&gt;&amp;lt;nut-steps&amp;gt;&lt;/code&gt; 和内层的 &lt;code&gt;&amp;lt;nut-step&amp;gt;&lt;/code&gt; 两个部分。&lt;/p&gt;
&lt;p&gt;我们一般会这样设计&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;-- nut-steps --&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;nut-steps&quot; :class=&quot;{ horizontal: direction === 'horizontal' }&quot;&amp;gt;
    &amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;-- nut-step --&amp;gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;nut-step clearfix&quot; :class=&quot;`${currentStatus ? currentStatus : ''}`&quot;&amp;gt;
    ...
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;外层组件控制整体组件的布局，激活状态等，子组件主要渲染内容，但是他们之间的关联成了难题。&lt;/p&gt;
&lt;p&gt;子组件中的一些状态逻辑需要由父组件来控制，这就存在父子组件之间属性或状态的通信。&lt;/p&gt;
&lt;p&gt;解决这个问题有两种思路，一是在父组件中获取子组件信息，再将子组件需要的父组件信息给子组件设置上，二是在子组件中获取父组件的属性信息来渲染子组件。&lt;/p&gt;
&lt;p&gt;第一种方案：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;this.steps = this.$slots.default.filter((vnode) =&amp;gt; !!vnode.componentInstance).map((node) =&amp;gt; node.componentInstance);
this.updateChildProps(true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先通过 &lt;code&gt;this.$slots.default&lt;/code&gt; 获取到所有的子组件，然后在 &lt;code&gt;updateChildProps&lt;/code&gt; 中遍历 &lt;code&gt;this.steps&lt;/code&gt; ，并根据父组件的属性信息更新子组件。&lt;/p&gt;
&lt;p&gt;跑起来验证下，似乎实现想要的效果！！！&lt;/p&gt;
&lt;h3 id=&quot;prop-动态更新&quot;&gt;Prop 动态更新&lt;/h3&gt;
&lt;p&gt;但是，在实际项目应用中，发现在动态刷新这块存在很大问题。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当前所处状态发生改变需要遍历所用子组件，性能低下&lt;/li&gt;
&lt;li&gt;子组件内容或某个属性变化，想要更新组件会变得异常麻烦&lt;/li&gt;
&lt;li&gt;父组件中要维护管理很多子组件的属性&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在刚开始甚至用了比较笨拙的方法，将渲染子组件用到的 list 传递给父组件，并监听该属性的变化情况来重新渲染子组件。但是为了实现这种更新却添加了一个毫无意义的数据监听，还需要深度监听，而部分场景下也并不是必须，重新遍历渲染子组件也会造成性能消耗，效率低下。&lt;/p&gt;
&lt;p&gt;所以这种方式并不合适，改用第二种方式。&lt;/p&gt;
&lt;p&gt;在子组件中访问父组件的属性，利用 &lt;code&gt;this.$parent&lt;/code&gt; 来访问父组件的属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// step 组件创建之前将组件实例添加到父组件的 steps 数组中
beforeCreate() {
  this.$parent.steps.push(this);
},
  
data() {
  return {
    index: -1,
  };
},
  
methods: {
  getCurrentStatus() {
    // 访问父组件的逻辑更新属性
    const { current, type, steps, timeForward } = this.$parent;
    // 逻辑处理
  }
},
mounted() {
  // 监听 index 的变化重新计算相关逻辑
  const unwatch = this.$watch('index', val =&amp;gt; {
    this.$watch('$parent.current', this.getCurrentStatus, { immediate: true });
    unwatch();
  });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在父组件中，接收子组件实例并设置 index 属性&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;data() {
  return {
    steps: [],
  };
},
watch: {
  steps(steps) {
    steps.forEach((child, index) =&amp;gt; {
      child.index = index; // 设置子组件的 index 属性，将会用于子组件的展示逻辑
    });
  }
},
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过下面这张图来看下它的数据变化。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img12.360buyimg.com/imagetools/jfs/t1/115696/12/15128/85890/5f3deeaeE8866be9b/f74006e6629cbd46.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;子组件中的属性变化只依赖子组件的属性，子组件内部的属性变化并不需要触发父组件的更新，而子组件数量的变化会触达父组件，并按照创建顺序给子组件重新排序设定 index 值，子组件再根据 index 值的变化重新渲染。&lt;/p&gt;
&lt;p&gt;将更多的逻辑交给了子组件处理，而父组件更多的是做整体组件的功能逻辑。也不必要监听子组件的数据源也能更新组件。&lt;/p&gt;
&lt;p&gt;但是，实现过程中有个关键属性可能是造成 bug 的重要隐患，它就是 &lt;code&gt;this.$parent&lt;/code&gt; .&lt;/p&gt;
&lt;p&gt;只有子组件 &lt;code&gt;&amp;lt;step&amp;gt;&lt;/code&gt; 的父级是 &lt;code&gt;&amp;lt;steps&amp;gt;&lt;/code&gt; 时访问到的 &lt;code&gt;this.$parent&lt;/code&gt; 才是准确的。&lt;/p&gt;
&lt;p&gt;如果不是直接的父子级就一定会出现 bug 。&lt;/p&gt;
&lt;p&gt;实际使用中，不仅是这个组件，其他这类组件也会出现子组件的直接父级并不是它对应父级的情况，这就会产生 bug 。比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;nut-steps :current=&quot;active&quot;&amp;gt;
  &amp;lt;nut-row&amp;gt;
    &amp;lt;nut-step v-for=&quot;(step, index) in steps&quot; :key=&quot;index&quot; :title=&quot;step.title&quot; :content=&quot;step.content&quot; :time=&quot;step.time&quot;&amp;gt;
    &amp;lt;/nut-step&amp;gt;
  &amp;lt;/nut-row&amp;gt;
&amp;lt;/nut-steps&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;nut-row&amp;gt;&lt;/code&gt; 组件作为 &lt;code&gt;&amp;lt;nut-step&amp;gt;&lt;/code&gt; 组件的父级组件的时候， &lt;code&gt;this.$parent&lt;/code&gt; 指向的就不是 &lt;code&gt;&amp;lt;nut-steps&amp;gt;&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;那么在 &lt;code&gt;&amp;lt;nut-step&amp;gt;&lt;/code&gt; 中可以加一些 hack：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;let parent = this.$parent || this.$parent.$parent;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但这很快就会失控，治标不治本，再加几层嵌套，立刻玩完。&lt;/p&gt;
&lt;h3 id=&quot;多层传递的神器---依赖注入&quot;&gt;多层传递的神器 - 依赖注入&lt;/h3&gt;
&lt;p&gt;现在主要要解决的问题是让后代子组件访问到父级组件实例上的属性或方法，中间不管跨几级。&lt;/p&gt;
&lt;p&gt;vue 依赖注入可以派上用场了。&lt;/p&gt;
&lt;p&gt;vue 实例有两个配置选项：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;provide: 指定我们想要提供给后代组件的数据/方法。&lt;/li&gt;
&lt;li&gt;inject：接收指定的我们想要添加在这个实例上的 property 。&lt;/li&gt;
&lt;/ol&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这两个属性是 vue v2.2.0 版本新增&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这两选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在其上下游关系成立的时间里始终生效。如果熟悉 React，这与 React 的上下文特性很相似。&lt;/p&gt;
&lt;p&gt;父组件使用 &lt;code&gt;provide&lt;/code&gt; 提供可注入子孙组件的 property 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 父级组件 steps
provide() {
  return {
    timeForward: this.timeForward,
    type: this.type,
    pushStep: this.pushStep,
    delStep: this.delStep,
    current: this.current,
  }
}, 
  
methods: {
    pushStep(step) {
      this.steps.push(step);
    },
    delStep(step) {
      const steps = this.steps;
      const index = steps.indexOf(step);
      if (index &amp;gt;= 0) {
        steps.splice(index, 1);
      }
    }
},
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子组件使用 &lt;code&gt;inject&lt;/code&gt; 读取父级组件提供的 property 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// 子孙组件 step
inject: ['timeForward', 'type', 'current', 'pushStep', 'delStep']
// beforeCreate() {
//   this.$parent.steps.push(this);
//   // this.pushStep(this);
// },
created() {
  this.pushStep(this);
},
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;子组件不再使用 &lt;code&gt;this.$parent&lt;/code&gt; 来获取父级组件的数据了。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里有个细节，子组件更新父组件的 steps 值的时机从 &lt;code&gt;beforeCreate&lt;/code&gt; 变成了 &lt;code&gt;created&lt;/code&gt; ，这是因为 &lt;code&gt;inject&lt;/code&gt; 的初始化是在 &lt;code&gt;beforeCreate&lt;/code&gt; 之后执行的，因此在此之前是访问不到 &lt;code&gt;inject&lt;/code&gt; 中的属性的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;解决了跨层级嵌套的问题，还有另一个问题，监听父组件属性的变化。因为：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;code&gt;provide&lt;/code&gt; 和 &lt;code&gt;inject&lt;/code&gt; 绑定并不是可响应的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如 &lt;code&gt;current&lt;/code&gt; 属性是可以动态改变的，像上面这个注入，子孙组件拿到的永远是初始化注入的值，并不是最新的。&lt;/p&gt;
&lt;p&gt;这个也很容易解决，在父组件注入依赖时使用函数来获取实时的 current 值即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;  provide() {
    return {
      getCurrentIndex: () =&amp;gt; this.current,
    }
  },  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在子组件中：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;  computed: {
    current() {
      return this.getCurrentIndex();
    }
  },
    
  mounted() {
    const unwatch = this.$watch('index', val =&amp;gt; {
      this.$watch('current', this.getCurrentStatus, { immediate: true });
      unwatch();
    });
  },
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;this.$watch&lt;/code&gt; 和 &lt;code&gt;watch&lt;/code&gt; 方法中监听是相同的效果，可以主动触发监听，&lt;code&gt;this.$watch()&lt;/code&gt; 回返回一个取消观察函数，用来停止触发回调。 这里在组件挂载完成后监听 &lt;code&gt;index&lt;/code&gt; 的变化，&lt;code&gt;index&lt;/code&gt; 变化再立即触发 &lt;code&gt;current&lt;/code&gt; 属性变化的监听。&lt;/p&gt;
&lt;p&gt;这样就能实时获得父组件的属性变化了，实现数据监听刷新组件。&lt;/p&gt;
&lt;p&gt;至此这个组件的主要难点就攻克了。&lt;/p&gt;
&lt;p&gt;当然这种方式只适用于父子层级比较深的场景，同层级兄弟组件之间是无法通过这种方式实现通信的。&lt;/p&gt;
&lt;p&gt;另外 &lt;code&gt;provide&lt;/code&gt; 和 &lt;code&gt;inject&lt;/code&gt; 主要适用于开发高阶组件或组件库的时候使用，在普通的应用程序代码中最好不要使用。因为这可能会造成数据混乱，业务于逻辑混杂，项目变得难以维护。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;在组件开发过程中，为了保证组件的灵活性、整体性，很多组件都会出现这种嵌套问题，甚至深层嵌套导致的属性共享问题、数据监听问题，那么本文主要根据 Steps 组件的开发经验提供一种解决方案，希望对大家有那么一丢丢的帮助或启发。&lt;/p&gt;
</description>
<pubDate>Wed, 02 Dec 2020 00:29:00 +0000</pubDate>
<dc:creator>jdf2e</dc:creator>
<og:description>NutUI 组件源码揭秘 前言 本文的主题是 Steps 组件的设计与实现。Steps 组件是 Steps 步骤和 Timeline 组件结合的组件，在此之前他们是两个不同的组件，在 NutUI 最近</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/jdrdfe/p/14069941.html</dc:identifier>
</item>
<item>
<title>03Python网络编程系列之服务端 - 月为暮</title>
<link>http://www.cnblogs.com/cong12586/p/14071785.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cong12586/p/14071785.html</guid>
<description>&lt;pre readability=&quot;63&quot;&gt;
# 这里边是一个定义了服务端的一系列函数，是Python网络编程这本书第七章的第一个例子。&lt;br/&gt;# 这是供后边函数进行调用了，然后我们来进行研究网络的单线程编程，多线程编程、异步网络编程等。&lt;p&gt;# 导入网络编程socket、时间time、cmd参数获取模块&lt;br/&gt;import argparse, socket, time&lt;/p&gt;&lt;p&gt;# 定义一个字典用来存放发送给客户端的消息。&lt;br/&gt;aphorisms = {b'Beautiful is better than?': b'Ugly.',&lt;br/&gt;b'Explicit is better than?': b'Implicit.',&lt;br/&gt;b'Simple is better than?': b'Complex.'}&lt;/p&gt;&lt;p&gt;# 获取答案， 如果客户端发送了问题，就从上边的字典里边获取，如果没有的话就返回我不知道的错误。&lt;br/&gt;def get_answer(aphorism):&lt;br/&gt;&quot;&quot;&quot;Return the string response to a particular Zen-of-Python aphorism.&quot;&quot;&quot;&lt;br/&gt;time.sleep(0.0)  # increase to simulate an expensive operation&lt;br/&gt;return aphorisms.get(aphorism, b'Error: unknown aphorism.')&lt;/p&gt;&lt;p&gt;# 定义一个函数用来获取终端需要传入的参数。 host：主机IP或者名称 -p：端口，默认为1060&lt;br/&gt;# 返回值是一个元祖，包含IP端口。&lt;br/&gt;def parse_command_line(description):&lt;br/&gt;&quot;&quot;&quot;Parse command line and return a socket address.&quot;&quot;&quot;&lt;br/&gt;parser = argparse.ArgumentParser(description=description)&lt;br/&gt;parser.add_argument('host', help='IP or hostname')&lt;br/&gt;parser.add_argument('-p', metavar='port', type=int, default=1060,&lt;br/&gt;help='TCP port (default 1060)')&lt;br/&gt;args = parser.parse_args()&lt;br/&gt;address = (args.host, args.p)&lt;br/&gt;return address&lt;/p&gt;&lt;p&gt;# 创造一个socket套接字，这里的入参是上边那个函数的出参。&lt;br/&gt;def create_srv_socket(address):&lt;br/&gt;&quot;&quot;&quot;Build and return a listening server socket.&quot;&quot;&quot;&lt;br/&gt;# 创造一个套接字。&lt;br/&gt;listener = socket.socket(socket.AF_INET, socket.SOCK_STREAM)&lt;br/&gt;# 设置。&lt;br/&gt;listener.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)&lt;br/&gt;# 服务端绑定IP和端口。&lt;br/&gt;listener.bind(address)&lt;br/&gt;# 设置服务端能够监听的数量，这里设置的是最大能够同时监听64个。&lt;br/&gt;listener.listen(64)&lt;br/&gt;# 打印出绑定的IP端口，服务端绑定的。&lt;br/&gt;print('Listening at {}'.format(address))&lt;br/&gt;# 返回这个套接字。&lt;br/&gt;return listener&lt;/p&gt;&lt;p&gt;# 一直持续不断的进行监听， 观察有没有客户端和服务端进行连接。&lt;br/&gt;# 这里的入参是上边函数的出参&lt;br/&gt;def accept_connections_forever(listener):&lt;br/&gt;&quot;&quot;&quot;Forever answer incoming connections on a listening socket.&quot;&quot;&quot;&lt;br/&gt;# 死循环&lt;br/&gt;while True:&lt;br/&gt;# 服务端一直在监听端口，看有没有客户端进行连接。&lt;br/&gt;# 这个是阻塞的，如果有的话那么才会进行下边的操作。&lt;br/&gt;sock, address = listener.accept()&lt;br/&gt;# 打印出客户端IP端口&lt;br/&gt;print('Accepted connection from {}'.format(address))&lt;br/&gt;handle_conversation(sock, address)&lt;/p&gt;&lt;p&gt;# 处理连接对话函数。&lt;br/&gt;def handle_conversation(sock, address):&lt;br/&gt;&quot;&quot;&quot;Converse with a client over `sock` until they are done talking.&quot;&quot;&quot;&lt;br/&gt;try:&lt;br/&gt;while True:&lt;br/&gt;# 这里一直处理客户端的请求。&lt;br/&gt;handle_request(sock)&lt;br/&gt;# 接收异常，代表着客户端断开了连接。&lt;br/&gt;except EOFError:&lt;br/&gt;print('Client socket to {} has closed'.format(address))&lt;br/&gt;# 如果有其他错误，我们也需要进行接收下来。&lt;br/&gt;except Exception as e:&lt;br/&gt;print('Client {} error: {}'.format(address, e))&lt;br/&gt;# 最后关闭服务端的套接字。&lt;br/&gt;finally:&lt;br/&gt;sock.close()&lt;/p&gt;&lt;p&gt;# 处理请求函数。&lt;br/&gt;def handle_request(sock):&lt;br/&gt;&quot;&quot;&quot;Receive a single client request on `sock` and send the answer.&quot;&quot;&quot;&lt;br/&gt;# 这里我们调用函数进行接收客户端发送过来的消息。&lt;br/&gt;aphorism = recv_until(sock, b'?')&lt;br/&gt;# 然后调用获取答案函数，将我们的答案回复给客户端。&lt;br/&gt;answer = get_answer(aphorism)&lt;br/&gt;# 服务端进行发送消息&lt;br/&gt;sock.sendall(answer)&lt;/p&gt;&lt;p&gt;# 服务端和客户端进行连接后，一直进行接收客户端发送过来的消息，直到客户端发送了suffix&lt;br/&gt;# 这里我们的入参为？，如果客户端发送了suffix就代表着客户端发送完了消息。就需要进行关闭了。&lt;br/&gt;def recv_until(sock, suffix):&lt;br/&gt;&quot;&quot;&quot;Receive bytes over socket `sock` until we receive the `suffix`.&quot;&quot;&quot;&lt;br/&gt;# 接收数据，&lt;br/&gt;message = sock.recv(4096)&lt;br/&gt;# 如果数据为空。就抛出一个连接关闭的错误。&lt;br/&gt;if not message:&lt;br/&gt;raise EOFError('socket closed')&lt;br/&gt;# 判断接收的消息最后是否是suffix，如果是地话，那我们就直接反悔了。&lt;br/&gt;# 如果不是，就代表着客户端还有数据进行发送，服务端就需要继续进行接收。&lt;br/&gt;while not message.endswith(suffix):&lt;br/&gt;# 能够进来while循环，就代表着客户端还有数据进行发送，&lt;br/&gt;# 那么我们需要继续进行接收&lt;br/&gt;data = sock.recv(4096)&lt;br/&gt;# 如果客户端的数据为空。&lt;br/&gt;# 再次抛出一个异常。&lt;br/&gt;if not data:&lt;br/&gt;raise IOError('received {!r} then socket closed'.format(message))&lt;br/&gt;message += data&lt;br/&gt;# 返回接收的数据。&lt;br/&gt;return message
&lt;/p&gt;&lt;/pre&gt;</description>
<pubDate>Wed, 02 Dec 2020 00:12:00 +0000</pubDate>
<dc:creator>月为暮</dc:creator>
<og:description># 这里边是一个定义了服务端的一系列函数，是Python网络编程这本书第七章的第一个例子。# 这是供后边函数进行调用了，然后我们来进行研究网络的单线程编程，多线程编程、异步网络编程等。# 导入网络编程</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cong12586/p/14071785.html</dc:identifier>
</item>
<item>
<title>自动化运维工具之Puppet常用资源（一） - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14071459.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14071459.html</guid>
<description>&lt;p&gt;　　前文我们聊到了puppet的架构，单机模型和master/agent模型的工作流程以及puppet的基础使用，回顾请参考&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/14052241.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/14052241.html&lt;/a&gt;；今天我们主要来了解下puppet的核心资源的使用；&lt;/p&gt;
&lt;p&gt;　　什么是资源？&lt;/p&gt;
&lt;p&gt;　　在puppet中，资源就是指我们要操作被管控端主机的对象；puppet中的资源概念有点类似ansible中的模块，在ansible中不同模块有着不同的功能，比如用户管理，我们就要用user模块，文件管理就要用file模块，执行命令有shell模块和command模块；puppet中的资源也是类似的作用，不同的是puppet中资源是高度抽象的；所谓高度抽象就是指用户无需关心底层操作系统接口；比如我们要在被管控端安装一个nginx软件，如果用puppet来实现，我们直接使用package这个资源即可完成，用户不用考虑底层到底是windows还是centos或者ubuntu，puppet它能够自动识别，然后采用不同的安装方法；而在ansible中对于不同操作系统，使用的模块有所不同，比如redhat系列要使用yum这个模块，debian系列要使用apt模块；puppet把相似的资源被抽象成同一种资源类型，比如程序包资源，用户资源以及服务资源等；将资源属性或状态的描述与其实现方式剥离开；如安装程序包用户无需关心使用什么方法去实现，只需要描述清楚资源的目标状态以及相关属性信息即可；&lt;/p&gt;
&lt;p&gt;　　puppet常用资源的使用&lt;/p&gt;
&lt;p&gt;　　1、group：该资源类型主要用来管理被管控端主机上的组；&lt;/p&gt;
&lt;p&gt;　　　　主要属性&lt;/p&gt;
&lt;p&gt;　　　　name：该属性主要用来描述组名，namevar如果默认不人工手动指定，则以title字符串来替代；&lt;/p&gt;
&lt;p&gt;　　　　gid：该属性用来描述GID（组ID）；&lt;/p&gt;
&lt;p&gt;　　　　system：该属性用来描述是否为系统组，取值yes/no或者true/false；&lt;/p&gt;
&lt;p&gt;　　　　ensure：该属性用来描述目标状态（即用户期待目标主机对应该资源的期望状态），取值present/absent；&lt;/p&gt;
&lt;p&gt;　　　　members：该属性用来描述组中的成员用户信息；&lt;/p&gt;
&lt;p&gt;　　示例：创建一个test组&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# cat group.pp
group{'create_group':
        name    =&amp;gt; 'test',
        gid     =&amp;gt; 1212,
        system  =&amp;gt; false,
        ensure  =&amp;gt; present,
}
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　模拟运行以上资源清单检查是否有语法错误&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# puppet apply -v --noop group.pp
Notice: Compiled catalog for node12.test.org in environment production in 0.05 seconds
Info: Applying configuration version '1606827824'
Notice: /Stage[main]/Main/Group[create_group]/ensure: current_value absent, should be present (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Finished catalog run in 0.02 seconds
[root@node12 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　应用到本地主机&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# puppet apply -v  group.pp      
Notice: Compiled catalog for node12.test.org in environment production in 0.05 seconds
Info: Applying configuration version '1606827835'
Notice: /Stage[main]/Main/Group[create_group]/ensure: created
Notice: Finished catalog run in 0.08 seconds
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：查看本机是否创建test组？对应gid是否是我们指定的gid?&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# getent group test
test:x:1212:
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、user：该资源类型主要用来管理被管控端主机上的用户，如新建用户，删除用户等等；&lt;/p&gt;
&lt;p&gt;　　主要属性&lt;/p&gt;
&lt;p&gt;　　　　name：用户名，namevar&lt;/p&gt;
&lt;p&gt;　　　　uid：UID；&lt;/p&gt;
&lt;p&gt;　　　　gid：基本组id；&lt;/p&gt;
&lt;p&gt;　　　　groups：附加组，不能包含基本组；&lt;/p&gt;
&lt;p&gt;　　　　comment：注释；&lt;/p&gt;
&lt;p&gt;　　　　expiry：过期时间；&lt;/p&gt;
&lt;p&gt;　　　　home：家目录；&lt;/p&gt;
&lt;p&gt;　　　　shell：默认shell类型；&lt;/p&gt;
&lt;p&gt;　　　　system：是否为系统用户，取值yes/no或者true/false；&lt;/p&gt;
&lt;p&gt;　　　　ensure：用户期望的目标状态，取值present/absent；&lt;/p&gt;
&lt;p&gt;　　　　password：加密后的密码串； &lt;/p&gt;
&lt;p&gt;　　示例：创建一个用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# cat user.pp
user{&quot;create_user&quot;:
        name    =&amp;gt; &quot;jerry&quot;,
        uid     =&amp;gt; 1213,
        groups  =&amp;gt; [&quot;test&quot;,&quot;test1&quot;,&quot;test2&quot;,&quot;test3&quot;],
        comment =&amp;gt; &quot;this is create test user&quot;,
        system  =&amp;gt; no,
        ensure  =&amp;gt; present,
}
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证语法和应用到本机&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# puppet apply -v --noop user.pp
Notice: Compiled catalog for node12.test.org in environment production in 0.06 seconds
Info: Applying configuration version '1606829084'
Notice: /Stage[main]/Main/User[create_user]/ensure: current_value absent, should be present (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Finished catalog run in 0.02 seconds
[root@node12 ~]# puppet apply -v  user.pp      
Notice: Compiled catalog for node12.test.org in environment production in 0.06 seconds
Info: Applying configuration version '1606829091'
Notice: /Stage[main]/Main/User[create_user]/ensure: created
Notice: Finished catalog run in 0.05 seconds
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：查看jerry用户是否创建完成，对应属性是否是我们指定的属性呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# id jerry
uid=1213(jerry) gid=1213(jerry) groups=1213(jerry),1000(test1),1001(test2),1002(test3),1212(test)
[root@node12 ~]# getent passwd jerry
jerry:x:1213:1213:this is create test user:/home/jerry:/bin/bash
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　以上示例在指定附加组是系统上已经存在的情况，如果指定的组没有这么办呢？我们知道puppet执行资源清单时，有一个很重要的特性，幂等性；所谓幂等性就是指不管执行多少遍资源清单，对应的目标状态会保持一致，如果应系统指定的资源不是用户定义的目标状态，puppet会强制让其状态保持为目标状态，如果对应系统资源状态满足我们定义的目标状态，则不执行或跳过；结合上述说的，在创建用户时，指定的附加组不存在，理论上我们应该先确保对应组存在，然后再创建用户；所以用户资源可能依赖组资源；简单讲user资源依赖group资源，在创建用户时，对应的附加组应该提前创建；&lt;/p&gt;
&lt;p&gt;　　在puppet中资源和资源是有依赖关系的，定义资源和资源间的依赖关系有两种方式，如下&lt;/p&gt;
&lt;p&gt;　　A before B: A优先于B，定义在A资源中；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
{
    ...
    before      =&amp;gt; Type['B'],
    ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　B require A： B依赖于A，定义在B资源中；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
{
　　...
　　require       =&amp;gt; Type['A'],
　　...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　示例：不定义依赖，应用资源清单，看看tom用户是否会被创建？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# cat user.pp
user{&quot;tom&quot;:
        groups  =&amp;gt; [&quot;mygrp&quot;,&quot;testgrp&quot;],
        comment =&amp;gt; &quot;this is create test user&quot;,
        system  =&amp;gt; no,
        ensure  =&amp;gt; present,
#       require =&amp;gt; [Group[&quot;mygrp&quot;],Group[&quot;testgrp&quot;]]
}

[root@node12 ~]# puppet apply -v --noop  user.pp
Notice: Compiled catalog for node12.test.org in environment production in 0.06 seconds
Info: Applying configuration version '1606832440'
Notice: /Stage[main]/Main/User[tom]/ensure: current_value absent, should be present (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Finished catalog run in 0.02 seconds
[root@node12 ~]# puppet apply -v   user.pp      
Notice: Compiled catalog for node12.test.org in environment production in 0.06 seconds
Info: Applying configuration version '1606832447'
Error: Could not create user tom: Execution of '/usr/sbin/useradd -c this is create test user -G mygrp,testgrp -M tom' returned 6: useradd: group 'mygrp' does not exist
useradd: group 'testgrp' does not exist
Error: /Stage[main]/Main/User[tom]/ensure: change from absent to present failed: Could not create user tom: Execution of '/usr/sbin/useradd -c this is create test user -G mygrp,testgrp -M tom' returned 6: useradd: group 'mygrp' does not exist
useradd: group 'testgrp' does not exist
Notice: Finished catalog run in 0.03 seconds
[root@node12 ~]# id tom
id: tom: no such user
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：在puppet资源清单中“#”号代表注释；可以看到创建用户时，指定一个不存在的组给对应用户做附加组，它会提示我们对应的组不存在；当然对应的tom也不会被成功新建；&lt;/p&gt;
&lt;p&gt;　　示例：定义依赖关系，再次执行资源清单，看看tom是否会被新建呢？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# 
[root@node12 ~]# cat user.pp
user{&quot;tom&quot;:
        groups  =&amp;gt; [&quot;mygrp&quot;,&quot;testgrp&quot;],
        comment =&amp;gt; &quot;this is create test user&quot;,
        system  =&amp;gt; no,
        ensure  =&amp;gt; present,
        require =&amp;gt; [Group[&quot;mygrp&quot;],Group[&quot;testgrp&quot;]]
}

[root@node12 ~]# puppet apply -v --noop  user.pp
Notice: Compiled catalog for node12.test.org in environment production in 0.10 seconds
Error: Could not find dependency Group[mygrp] for User[tom] at /root/user.pp:7
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：这里虽然定义了依赖的资源，但是它这里提示我们为在当前资源清单中找到对应的依赖资源定义内容；这里需要注意一点引用资源的方式是Type[&quot;resouce name&quot;],其中type指资源类型，并且首字母必须大写；&lt;/p&gt;
&lt;p&gt;　　在资源清单中定义被依赖的资源，再次执行资源清单，看看tom用户是否被创建？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# cat user.pp
user{&quot;tom&quot;:
        groups  =&amp;gt; [&quot;mygrp&quot;,&quot;testgrp&quot;],
        comment =&amp;gt; &quot;this is create test user&quot;,
        system  =&amp;gt; no,
        ensure  =&amp;gt; present,
        require =&amp;gt; [Group[&quot;mygrp&quot;],Group[&quot;testgrp&quot;]]
}
group{&quot;mygrp&quot;:
        ensure  =&amp;gt; present,
}
group{&quot;testgrp&quot;:
        ensure  =&amp;gt; present,
}

[root@node12 ~]# puppet apply -v --noop  user.pp
Notice: Compiled catalog for node12.test.org in environment production in 0.10 seconds
Info: Applying configuration version '1606833022'
Notice: /Stage[main]/Main/Group[mygrp]/ensure: current_value absent, should be present (noop)
Notice: /Stage[main]/Main/Group[testgrp]/ensure: current_value absent, should be present (noop)
Notice: /Stage[main]/Main/User[tom]/ensure: current_value absent, should be present (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 3 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Finished catalog run in 0.02 seconds
[root@node12 ~]# puppet apply -v   user.pp      
Notice: Compiled catalog for node12.test.org in environment production in 0.10 seconds
Info: Applying configuration version '1606833042'
Notice: /Stage[main]/Main/Group[mygrp]/ensure: created
Notice: /Stage[main]/Main/Group[testgrp]/ensure: created
Notice: /Stage[main]/Main/User[tom]/ensure: created
Notice: Finished catalog run in 0.08 seconds
[root@node12 ~]# id tom
uid=1214(tom) gid=1216(tom) groups=1216(tom),1214(mygrp),1215(testgrp)
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到在定义了依赖关系以后，被依赖的资源要先执行；简单讲定义依赖关系就是指定资源执行的先后顺序；&lt;/p&gt;
&lt;p&gt;　　除了以上方式定义资源执行的先后顺序，还可以使用以下方式定义资源执行的先后顺序&lt;/p&gt;
&lt;p&gt;　　在被依赖的资源中使用before属性指定要优先那个资源执行&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;45&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# cat user.pp
user{&quot;tom&quot;:
        groups  =&amp;gt; [&quot;mygrp&quot;,&quot;testgrp&quot;],
        comment =&amp;gt; &quot;this is create test user&quot;,
        system  =&amp;gt; no,
        ensure  =&amp;gt; present,
#       require =&amp;gt; [Group[&quot;mygrp&quot;],Group[&quot;testgrp&quot;]]
}
group{&quot;mygrp&quot;:
        ensure  =&amp;gt; present,
        before  =&amp;gt; User[&quot;tom&quot;],
}
group{&quot;testgrp&quot;:
        ensure  =&amp;gt; present,
        before  =&amp;gt; User[&quot;tom&quot;],
}

[root@node12 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　单独定义资源执行顺序&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# cat user.pp
user{&quot;tom&quot;:
        groups  =&amp;gt; [&quot;mygrp&quot;,&quot;testgrp&quot;],
        comment =&amp;gt; &quot;this is create test user&quot;,
        system  =&amp;gt; no,
        ensure  =&amp;gt; present,
}
group{&quot;mygrp&quot;:
        ensure  =&amp;gt; present,
}
group{&quot;testgrp&quot;:
        ensure  =&amp;gt; present,
}

Group[&quot;testgrp&quot;] -&amp;gt; Group[&quot;mygrp&quot;] -&amp;gt; User[&quot;tom&quot;]
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上清单内容表示Group[&quot;testgrp&quot;]要优先于Group[&quot;mygrp&quot;]优先于User[&quot;tom&quot;]资源；&lt;/p&gt;
&lt;p&gt;　　删除testgrp,mygrp组和tom用户&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# groupdel mygrp 
[root@node12 ~]# groupdel testgrp   
[root@node12 ~]# userdel tom
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　不定义资源执行顺序，应用资源清单的顺序是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201201225228382-1133660152.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：默认在一个资源清单中的资源会自动解决依赖关系，通常被依赖的资源会从上至下依次执行；&lt;/p&gt;
&lt;p&gt;　　定义资源执行顺序，应用资源清单，看看对应资源执行顺序是否是我们定义的资源顺序呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202012/1503305-20201201225448123-2002889542.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：可以看到定义了资源执行顺序以后，资源的执行顺序就是我们定义的顺序；&lt;/p&gt;
&lt;p&gt;　　3、package：该资源类型用于管理被控端的包资源；&lt;/p&gt;
&lt;p&gt;　　主要属性&lt;/p&gt;
&lt;p&gt;　　　　name：包名称，namevar；&lt;/p&gt;
&lt;p&gt;　　　　ensure：目标状态，取值有installed/present/latest,absent/purgud；&lt;/p&gt;
&lt;p&gt;　　　　source：程序包来源，仅对不会自动下载相关程序包的provider有用，例如rpm或dpkg；&lt;/p&gt;
&lt;p&gt;　　　　provider：指定安装方式；&lt;/p&gt;
&lt;p&gt;　　示例：安装redis服务&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# cat package.pp
package{&quot;redis&quot;:
        ensure  =&amp;gt; installed,
}
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# rpm -q redis                      
package redis is not installed
[root@node12 ~]# puppet apply -v --noop package.pp 
Notice: Compiled catalog for node12.test.org in environment production in 0.18 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1606835569'
Notice: /Stage[main]/Main/Package[redis]/ensure: current_value absent, should be present (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Finished catalog run in 0.08 seconds
[root@node12 ~]# puppet apply -v  package.pp        
Notice: Compiled catalog for node12.test.org in environment production in 0.19 seconds
Warning: The package type's allow_virtual parameter will be changing its default value from false to true in a future release. If you do not want to allow virtual packages, please explicitly set allow_virtual to false.
   (at /usr/share/ruby/vendor_ruby/puppet/type.rb:816:in `set_default')
Info: Applying configuration version '1606835576'
Notice: /Stage[main]/Main/Package[redis]/ensure: created
Notice: Finished catalog run in 2.88 seconds
[root@node12 ~]# rpm -q redis                      
redis-3.2.12-2.el7.x86_64
[root@node12 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、service：该资源类型用于管理被控端的服务；&lt;/p&gt;
&lt;p&gt;　　主要属性&lt;/p&gt;
&lt;p&gt;　　　　ensure：定义目标状态，取值有running/stopped或者true/false；&lt;/p&gt;
&lt;p&gt;　　　　enable：是否设置为开机启动，取值true/false；&lt;/p&gt;
&lt;p&gt;　　　　name：服务名称，namevar&lt;/p&gt;
&lt;p&gt;　　　　path：脚本的搜索路径，默认为/etc/init.d/；&lt;/p&gt;
&lt;p&gt;　　　　binary：二进制程序路径，主要用于指定编译后的二进制程序路径；&lt;/p&gt;
&lt;p&gt;　　　　hasrestart：是否有重启命令；&lt;/p&gt;
&lt;p&gt;　　　　hasstatus：是否有status命令；&lt;/p&gt;
&lt;p&gt;　　　　start：手动定义启动服务命令；&lt;/p&gt;
&lt;p&gt;　　　　stop：手动定义停止服务命令；&lt;/p&gt;
&lt;p&gt;　　　　status：手动定义查看服务状态命令；&lt;/p&gt;
&lt;p&gt;　　　　restart：手动定义重启服务命令；&lt;/p&gt;
&lt;p&gt;　　示例：启动redis&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# cat redis.pp
service{&quot;redis&quot;:
        ensure  =&amp;gt; running,
        enable  =&amp;gt; true,
}
[root@node12 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# ss -tnl
State      Recv-Q Send-Q         Local Address:Port                        Peer Address:Port              
LISTEN     0      128                        *:22                                     *:*                  
LISTEN     0      100                127.0.0.1:25                                     *:*                  
LISTEN     0      128                        *:27017                                  *:*                  
LISTEN     0      128                       :::22                                    :::*                  
LISTEN     0      100                      ::1:25                                    :::*                  
[root@node12 ~]# puppet apply -v --noop redis.pp 
Notice: Compiled catalog for node12.test.org in environment production in 0.06 seconds
Info: Applying configuration version '1606835960'
Notice: /Stage[main]/Main/Service[redis]/ensure: current_value stopped, should be running (noop)
Info: /Stage[main]/Main/Service[redis]: Unscheduling refresh on Service[redis]
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Finished catalog run in 0.04 seconds
[root@node12 ~]# puppet apply -v redis.pp        
Notice: Compiled catalog for node12.test.org in environment production in 0.07 seconds
Info: Applying configuration version '1606835968'
Notice: /Stage[main]/Main/Service[redis]/ensure: ensure changed 'stopped' to 'running'
Info: /Stage[main]/Main/Service[redis]: Unscheduling refresh on Service[redis]
Notice: Finished catalog run in 0.09 seconds
[root@node12 ~]# ss -tnl
State      Recv-Q Send-Q         Local Address:Port                        Peer Address:Port              
LISTEN     0      128                127.0.0.1:6379                                   *:*                  
LISTEN     0      128                        *:22                                     *:*                  
LISTEN     0      100                127.0.0.1:25                                     *:*                  
LISTEN     0      128                        *:27017                                  *:*                  
LISTEN     0      128                       :::22                                    :::*                  
LISTEN     0      100                      ::1:25                                    :::*                  
[root@node12 ~]# systemctl is-enabled redis
enabled
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到应用清单文件以后，对应redis服务已经正常启动，并设置开机启动；&lt;/p&gt;
&lt;p&gt;　　示例：停止redis服务，并禁用其开机启动&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@node12 ~]# cat redis.pp
service{&quot;redis&quot;:
        ensure  =&amp;gt; stopped,
        enable  =&amp;gt; false,
}
[root@node12 ~]# puppet apply -v --noop redis.pp 
Notice: Compiled catalog for node12.test.org in environment production in 0.07 seconds
Info: Applying configuration version '1606836096'
Notice: /Stage[main]/Main/Service[redis]/ensure: current_value running, should be stopped (noop)
Notice: Class[Main]: Would have triggered 'refresh' from 1 events
Notice: Stage[main]: Would have triggered 'refresh' from 1 events
Notice: Finished catalog run in 0.04 seconds
[root@node12 ~]# puppet apply -v redis.pp 
Notice: Compiled catalog for node12.test.org in environment production in 0.07 seconds
Info: Applying configuration version '1606836102'
Notice: /Stage[main]/Main/Service[redis]/ensure: ensure changed 'running' to 'stopped'
Notice: Finished catalog run in 0.11 seconds
[root@node12 ~]# ss -tnl
State      Recv-Q Send-Q         Local Address:Port                        Peer Address:Port              
LISTEN     0      128                        *:22                                     *:*                  
LISTEN     0      100                127.0.0.1:25                                     *:*                  
LISTEN     0      128                        *:27017                                  *:*                  
LISTEN     0      128                       :::22                                    :::*                  
LISTEN     0      100                      ::1:25                                    :::*                  
[root@node12 ~]# systemctl is-enabled redis
disabled
[root@node12 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到执行了资源清单以后，对应服务就停掉了并且也禁用了开机启动；&lt;/p&gt;
</description>
<pubDate>Tue, 01 Dec 2020 15:50:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊到了puppet的架构，单机模型和master/agent模型的工作流程以及puppet的基础使用，回顾请参考https://www.cnblogs.com/qiuhom-1874/p/14</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14071459.html</dc:identifier>
</item>
<item>
<title>动态链接的PLT与GOT - 张雅宸</title>
<link>http://www.cnblogs.com/zhangyachen/p/14071491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangyachen/p/14071491.html</guid>
<description>&lt;p&gt;最近在研究缓冲区溢出攻击的试验，发现其中有一种方法叫做ret2plt。plt？这个词好熟悉，在汇编代码里经常见到，和plt经常一起出现的还有一个叫got的东西，但是对这两个概念一直很模糊，趁着这个机会研究一下。&lt;/p&gt;
&lt;p&gt;可以先说一下结论 : plt和got是&lt;strong&gt;动态链接&lt;/strong&gt;中用来重定位的。&lt;/p&gt;
&lt;h3 id=&quot;got&quot;&gt;GOT&lt;/h3&gt;
&lt;p&gt;我们知道，一般我们的代码都需要引用外部文件的函数或者变量，比如&lt;code&gt;#include&amp;lt;stdio.h&amp;gt;&lt;/code&gt;里的&lt;code&gt;printf&lt;/code&gt;，但是由于我们代码中用到的共享对象是运行时加载进来的，在虚拟地址空间的位置并不确定，所以代码里&lt;code&gt;call &amp;lt;addr of printf&amp;gt;&lt;/code&gt;的&lt;code&gt;addr of printf&lt;/code&gt;不确定，只有等运行时共享对象被加载到进程的虚拟地址空间里时，才能最终确定printf的地址，再进行&lt;strong&gt;重定位地址&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;看一个最简单的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(){

    printf(&quot;Hello World&quot;);

    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用GDB调试一下(关于GDB调试汇编可以参考之前写的&lt;a href=&quot;https://github.com/zhangyachen/zhangyachen.github.io/issues/134&quot;&gt;GDB 单步调试汇编&lt;/a&gt; )：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(gdb) ni
0x000000000040054e in main ()
=&amp;gt; 0x000000000040054e &amp;lt;main+14&amp;gt;:       e8 71 fe ff ff  callq  0x4003c4 &amp;lt;printf@plt&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，&lt;code&gt;call &amp;lt;addr of printf&amp;gt;&lt;/code&gt;被&lt;code&gt;callq 0x4003c4&lt;/code&gt;代替，而这个0x4003c4并不是真正的printf函数的地址。&lt;/p&gt;
&lt;p&gt;可能有人已经想到了，为什么不能直接在printf函数地址确定后，直接将&lt;code&gt;call &amp;lt;addr of printf&amp;gt;&lt;/code&gt;修改为&lt;code&gt;call &amp;lt;real addr of printf&amp;gt;&lt;/code&gt;，像静态链接那样呢（静态链接是在链接阶段进行重定位，直接修改的代码段）？有两个原因：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;现代操作系统不允许修改代码段，只能修改数据段。&lt;/li&gt;
&lt;li&gt;如果上面的代码片段是在一个共享对象内，修改了代码段，那么它就无法做到系统内所有进程共享同一个共享对象，因为代码段被修改了。而动态库的主要一个优点就是多个进程共享同一个共享对象的代码段，节省内存空间，但是进程拥有数据段的独立副本。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以，我们很容易的想到，既然不能修改代码段，能修改数据段，我们可以在共享对象加载完成后，将真实的符号地址放到数据段中，代码中直接读取数据段内的地址就行，这里开辟的空间就叫做GOT(图有点挫)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/14103319/52471695-73f0e280-2bcc-11e9-9f32-4cafbf007026.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为每一个需要重定位的符号建立一个GOT表项。&lt;/li&gt;
&lt;li&gt;当动态链接器装载共享对象时查找每一个需要重定位符号的变量地址，填充GOT。&lt;/li&gt;
&lt;li&gt;当指令需要访问变量或者函数的地址时，从对应的GOT表项中读出地址，再访问即可。对应的指令可能是&lt;code&gt;callq *(addr in GOT)&lt;/code&gt;或者&lt;code&gt;movq offset(%rip) %rax&lt;/code&gt;(&lt;code&gt;%rax&lt;/code&gt;就是全局变量的地址，可以用&lt;code&gt;(%rax)&lt;/code&gt;解引用)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;但是这样有一个问题，一个动态库可能有成百上千个符号，但是我们引入该动态库可能只会使用其中某几个符号，像上面那种方式就会造成不使用的符号也会进行重定位，造成不必要的效率损失。我们知道，动态链接比静态链接慢1% ~ 5%，其中一个原因就是动态链接需要在运行时查找地址进行重定位。&lt;/p&gt;
&lt;p&gt;所以ELF采用了延迟绑定的技术，当函数第一次被用到时才进行绑定。实现方式就是使用&lt;strong&gt;plt。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;plt&quot;&gt;PLT&lt;/h3&gt;
&lt;p&gt;我们可以先自己独立思考如何实现延迟绑定。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上文描述的是动态链接器主动将确定好的符号地址放到GOT中，延迟绑定需要我们自己主动告诉一个模块：我现在需要该符号的确定地址。假设该模块叫做&lt;code&gt;_dl_runtime_resolve()&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;我们需要告诉&lt;code&gt;_dl_runtime_resolve()&lt;/code&gt;需要寻找的符号，也就是函数参数。可以放到栈中或者寄存器传递。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_dl_runtime_resolve()&lt;/code&gt;寻找完符号的特定地址后，放到寄存器上，比如&lt;code&gt;%rax&lt;/code&gt;，供调用者使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以初步的实现步骤是：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;callq plt_printf    &amp;lt;printf@plt&amp;gt;
......
......

plt_printf:
    pushq   %rbp            ## allocate stack frame     
    movq    %rsp,%rbp
    pushq iden_of_printf        ## 告诉_dl_runtime_resolve()找printf函数地址，即_dl_runtime_resolve()的参数&amp;gt;
    callq _dl_runtime_resolve()
    callq %rax     ## %rax存放printf真实地址
    leaveq    ## deallocate stack frame
    retq    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的步骤可以实现通过一段小代码(plt)实现延迟绑定，但是存在一个问题：每一次调用printf的时候都需要走一遍这个步骤，然而printf的地址一旦确定就不会变了，所以我们需要一个缓存机制，将查找好的printf地址缓存起来。&lt;/p&gt;
&lt;h3 id=&quot;plt与got&quot;&gt;PLT与GOT&lt;/h3&gt;
&lt;p&gt;上面说过&lt;code&gt;_dl_runtime_resolve&lt;/code&gt;会将确定好的符合地址放到GOT中，那么在需要延迟加载的情况下，GOT里存放什么地址？上面说过需要我们需要将确定好的符号地址缓存起来，那么ELF是如何通过PLT与GOT的配合做到延迟加载的？我们直接看一个真实的例子就行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C&quot;&gt;#include &amp;lt;stdio.h&amp;gt;

int main(){

    printf(&quot;Hello World&quot;);

    printf(&quot;Hello World Again&quot;);

    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;gdb调试一下：&lt;/p&gt;
&lt;h4 id=&quot;one-调用printf的plt&quot;&gt;One 调用printf的plt&lt;/h4&gt;
&lt;p&gt;第一次调用printf，会调用printf对应的plt代码片段，与上面我们自己分析实现延迟加载的步骤一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(gdb) ni
0x000000000040054e in main ()
=&amp;gt; 0x000000000040054e &amp;lt;main+14&amp;gt;:       e8 71 fe ff ff  callq  0x4003c4 &amp;lt;printf@plt&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;two-调到printf对应的got里存储的地址&quot;&gt;Two 调到printf对应的GOT里存储的地址&lt;/h4&gt;
&lt;p&gt;进到&lt;code&gt;&amp;lt;printf@plt&amp;gt;&lt;/code&gt;看看：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(gdb) si
0x00000000004003c4 in printf@plt ()
=&amp;gt; 0x00000000004003c4 &amp;lt;printf@plt+0&amp;gt;:  ff 25 56 05 20 00       jmpq   *0x200556(%rip)        # 0x600920 &amp;lt;printf@got.plt&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里跳到了printf对应的GOT里存储的地址。（elf对got做了细分：&lt;strong&gt;got存放全局变量引用的地址，got.plt存放函数引用的地址&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;看看动态链接在将确定的符号地址放到GOT前，GOT里存放的是什么地址：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(gdb) x 0x600920
0x600920 &amp;lt;printf@got.plt&amp;gt;:        0x004003ca
(gdb) disas  0x4003c4
Dump of assembler code for function printf@plt:
   0x00000000004003c4 &amp;lt;+0&amp;gt;:       jmpq   *0x200556(%rip)        # 0x600920 &amp;lt;printf@got.plt&amp;gt;
=&amp;gt; 0x00000000004003ca &amp;lt;+6&amp;gt;:    pushq  $0x0
   0x00000000004003cf &amp;lt;+11&amp;gt;:      jmpq   0x4003b4
End of assembler dump.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有意思的是jmp到了下一条指令的地址。其实这个时候我们已经可以猜出来了：延迟加载之前，got.plt里存放的是下一条指令地址，延迟加载之后，got.plt里存放的就是真实的符号地址，就可以直接jmp到printf函数里了。&lt;/p&gt;
&lt;h4 id=&quot;three-将printf对应的标识压到栈中，并跳到plt0&quot;&gt;Three 将printf对应的标识压到栈中，并跳到plt[0]&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;(gdb) ni
0x00000000004003ca in printf@plt ()
=&amp;gt; 0x00000000004003ca &amp;lt;printf@plt+6&amp;gt;:  68 00 00 00 00  pushq  $0x0
(gdb) ni
0x00000000004003cf in printf@plt ()
=&amp;gt; 0x00000000004003cf &amp;lt;printf@plt+11&amp;gt;: e9 e0 ff ff ff  jmpq   0x4003b4
(gdb) si
0x00000000004003b4 in ?? ()      ## 这里应该是plt[0]，但是gdb不知道为什么没有显示出来
=&amp;gt; 0x00000000004003b4:       ff 35 56 05 20 00       pushq  0x200556(%rip)        # 0x600910 &amp;lt;_GLOBAL_OFFSET_TABLE_+8&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;four-在plt0中调用_dl_runtime_resolve查找符合真实地址&quot;&gt;Four 在plt[0]中调用_dl_runtime_resolve查找符合真实地址&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;说明这个是什么地址？？0x600910&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(gdb)
0x00000000004003b4 in ?? ()
=&amp;gt; 0x00000000004003b4:       ff 35 56 05 20 00       pushq  0x200556(%rip)        # 0x600910 &amp;lt;_GLOBAL_OFFSET_TABLE_+8&amp;gt;
(gdb)
0x00000000004003ba in ?? ()
=&amp;gt; 0x00000000004003ba:       ff 25 58 05 20 00       jmpq   *0x200558(%rip)        # 0x600918 &amp;lt;_GLOBAL_OFFSET_TABLE_+16&amp;gt;
(gdb)
_dl_runtime_resolve () at ../sysdeps/x86_64/dl-trampoline.S:34
34              subq $56,%rsp
=&amp;gt; 0x00007ffff7deef30 &amp;lt;_dl_runtime_resolve+0&amp;gt;: 48 83 ec 38     sub    $0x38,%rsp
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们不用管&lt;code&gt;_dl_runtime_resolve&lt;/code&gt;是怎么处理的，直接看&lt;code&gt;_dl_runtime_resolve&lt;/code&gt;处理完成后printf对应的GOT的值：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(gdb)
56              jmp *%r11               # Jump to function address.
=&amp;gt; 0x00007ffff7deef8e &amp;lt;_dl_runtime_resolve+94&amp;gt;:        41 ff e3        jmpq   *%r11
   0x00007ffff7deef91:  66 66 66 66 66 66 2e 0f 1f 84 00 00 00 00 00    data32 data32 data32 data32 data32 nopw %cs:0x0(%rax,%rax,1)
(gdb)
0x00007ffff7a7b5d0 in printf () from /lib64/libc.so.6
=&amp;gt; 0x00007ffff7a7b5d0 &amp;lt;printf+0&amp;gt;:      48 81 ec d8 00 00 00    sub    $0xd8,%rsp
(gdb)
......
......
(gdb) x 0x600920
0x600920 &amp;lt;printf@got.plt&amp;gt;:        0xf7a7b5d0
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与之前猜测的一样，printf对应的GOT表项目前已经存放了printf真实的虚拟地址。那么在下次调用时就避免再重定位，直接跳到printf地址了。&lt;/p&gt;
&lt;h4 id=&quot;five-第二次调用printf&quot;&gt;Five 第二次调用printf&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;(gdb) si
0x00000000004003c4 in printf@plt ()
=&amp;gt; 0x00000000004003c4 &amp;lt;printf@plt+0&amp;gt;:  ff 25 56 05 20 00       jmpq   *0x200556(%rip)        # 0x600920 &amp;lt;printf@got.plt&amp;gt;
(gdb) x 0x600920
0x600920 &amp;lt;printf@got.plt&amp;gt;:        0xf7a7b5d0
(gdb) si
0x00007ffff7a7b5d0 in printf () from /lib64/libc.so.6
=&amp;gt; 0x00007ffff7a7b5d0 &amp;lt;printf+0&amp;gt;:      48 81 ec d8 00 00 00    sub    $0xd8,%rsp
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接跳到printf的虚拟地址。&lt;/p&gt;
&lt;p&gt;下面这张图可以总结上面的五步过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/14103319/52620852-b2deab00-2ee0-11e9-8284-ec636a6f5724.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（完）&lt;/p&gt;
&lt;p&gt;朋友们可以关注下我的公众号，获得最及时的更新：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1298604/202011/1298604-20201103132150036-885052821.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 Dec 2020 15:22:00 +0000</pubDate>
<dc:creator>张雅宸</dc:creator>
<og:description>最近在研究缓冲区溢出攻击的试验，发现其中有一种方法叫做ret2plt。plt？这个词好熟悉，在汇编代码里经常见到，和plt经常一起出现的还有一个叫got的东西，但是对这两个概念一直很模糊，趁着这个机会</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhangyachen/p/14071491.html</dc:identifier>
</item>
<item>
<title>手把手教你使用Vue/React/Angular三大框架开发Pagination分页组件 - kagol</title>
<link>http://www.cnblogs.com/kagol/p/14071347.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kagol/p/14071347.html</guid>
<description>&lt;p&gt;19世纪著名的印象派画家莫奈，喜欢对着同一处景物，分别画出对象在不同时间，不同光线下的色彩变化。 如果同一个组件，用不同的框架实现，会有什么不同呢？ 带着这个想法，我分别选用目前最火的Vue/React/Angular三大框架，去实现一个简单的Pagination分页组件。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;577.36002925198&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/296720/202012/296720-20201201224807829-197300972.png&quot; width=&quot;1000&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;


&lt;blockquote readability=&quot;6.1659574468085&quot;&gt;
&lt;p&gt;DevUI是一支兼具设计视角和工程视角的团队，服务于华为云&lt;a href=&quot;https://www.huaweicloud.com/devcloud/&quot;&gt;DevCloud&lt;/a&gt;平台和华为内部数个中后台系统，服务于设计师和前端工程师。&lt;br/&gt;官方网站：&lt;a href=&quot;https://devui.design/&quot;&gt;devui.design&lt;br/&gt;&lt;/a&gt;Ng组件库：&lt;a href=&quot;https://github.com/DevCloudFE/ng-devui&quot;&gt;ng-devui&lt;/a&gt;（欢迎Star）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;“他在正午、黄昏，在一天里的许多时刻去感受它、记录它，结果也就让我们看到了那么多的不同。他描绘它的角度没变，但它的面目却极大地改变了。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;19世纪著名的印象派画家莫奈，喜欢对着同一处景物，分别画出对象在不同时间，不同光线下的色彩变化。&lt;/p&gt;
&lt;p&gt;比如不同季节的三株白杨：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795a65b9316b?w=1500&amp;amp;h=891&amp;amp;f=jpeg&amp;amp;s=198943&quot;/&gt;&lt;/p&gt;
&lt;p&gt;比如一天中不同时刻的浮翁大教堂：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795a65c45b0c?w=1500&amp;amp;h=734&amp;amp;f=jpeg&amp;amp;s=175280&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果同一个组件，用不同的框架实现，会有什么不同呢？&lt;/p&gt;
&lt;p&gt;带着这个想法，我分别选用目前最火的Vue/React/Angular三大框架，去实现一个简单的Pagination分页组件。&lt;/p&gt;


&lt;p&gt;我们要实现的分页组件大致效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795a65d030a5?w=904&amp;amp;h=116&amp;amp;f=png&amp;amp;s=4070&quot;/&gt;&lt;/p&gt;
&lt;p&gt;主要包含以下功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;点击左右分页按钮可以跳转到上一页/下一页；&lt;/li&gt;
&lt;li&gt;点击中间的页码按钮可能跳转到相应的页码；&lt;/li&gt;
&lt;li&gt;首页尾页需要始终显示出来（如果只有1页则不显示尾页）；&lt;/li&gt;
&lt;li&gt;除首尾页之外，当前页码左右最多只显示2页（共5页）；&lt;/li&gt;
&lt;li&gt;页码太多时显示更多页码按钮，点击更多页码按钮跳转5页。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从设计稿可以看出，Pagination组件主要由2个模块组成：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Button - 左右分页按钮&lt;/li&gt;
&lt;li&gt;Pager - 中间的分页器&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795a6f13ce30?w=916&amp;amp;h=216&amp;amp;f=png&amp;amp;s=13064&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们采用自上而下的方式创建组件，先创建一个空的Pagination组件。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;注意⚠️&lt;/p&gt;
&lt;p&gt;我使用的框架版本号如下：&lt;/p&gt;
&lt;p&gt;node@10.15.1&lt;/p&gt;
&lt;p&gt;vue-cli@3.7.0&lt;/p&gt;
&lt;p&gt;vue@2.6.10&lt;/p&gt;
&lt;p&gt;create-react-app@3.0.1&lt;/p&gt;
&lt;p&gt;react@16.8.6&lt;/p&gt;
&lt;p&gt;angular-cli@7.3.9&lt;/p&gt;
&lt;p&gt;angular@7.2.0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;3.1 Vue版本&lt;/h2&gt;
&lt;p&gt;使用&lt;a href=&quot;https://cli.vuejs.org/zh/guide/&quot;&gt;Vue CLI&lt;/a&gt;创建一个基础Vue项目，并输入npm run serve命令启动起来。&lt;/p&gt;
&lt;p&gt;然后在components文件夹新建一个pagination文件夹，里面新建我们需要的3个组件文件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按钮组件 - Button.vue&lt;/li&gt;
&lt;li&gt;分页器组件 - Pager.vue&lt;/li&gt;
&lt;li&gt;分页组件 - Pagination.vue&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795a660ed8d4?w=346&amp;amp;h=786&amp;amp;f=png&amp;amp;s=39894&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Pagination.vue文件中增加以下代码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;x-pagination&quot;&amp;gt;
    Pagination组件
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
export default {
  name: 'Pagination',
};
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Vue组件的特点是将HTML/CSS/JavaScript都统一放在一个.vue后缀的文件中。&lt;/p&gt;
&lt;p&gt;对于习惯将HTML/CSS/JavaScript分开编写的前端开发者来说，显得非常自然，加上Vue的语法非常简洁，入门门槛比较低，所以2014年一经推出，很快便席卷全球。&lt;/p&gt;
&lt;p&gt;在views/Home.vue中使用Pagination组件：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;home&quot;&amp;gt;
    &amp;lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot;&amp;gt;
    &amp;lt;HelloWorld msg=&quot;Welcome to Your Vue.js App by kagol&quot;/&amp;gt;
    &amp;lt;Pagination /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
// @ is an alias to /src
import HelloWorld from '@/components/HelloWorld.vue';
import Pagination from '@/components/pagination/Pagination.vue';
export default {
  name: 'home',
  components: {
    HelloWorld,
    Pagination,
  },
};
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;组件的使用方式也和普通HTML元素很类似：&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;Pagination /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;需要注意的是使用Vue局部组件之前需要在components中声明该组件。&lt;/p&gt;
&lt;p&gt;这只是一个空组件，只显示了“Pagination组件”文字，没有太大的意义，不过不要着急，后面我们会一步步完善该组件，实现我们想要的功能，并能不断扩展和演进。在继续开发Vue版本的Pagination组件之前，我们先来看看其他框架如何实现和使用一个组件。&lt;/p&gt;
&lt;p&gt;以下是显示效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795a661c45d5?w=932&amp;amp;h=854&amp;amp;f=png&amp;amp;s=50036&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;3.2 React版本&lt;/h2&gt;
&lt;p&gt;先来看看React框架，我们同样使用&lt;a href=&quot;https://create-react-app.dev/&quot;&gt;Create React App&lt;/a&gt;创建一个基础的React项目，并输入命令npm start命令启动。&lt;/p&gt;
&lt;p&gt;和Vue项目一样，创建以下3个组件文件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;按钮组件 - Button.js&lt;/li&gt;
&lt;li&gt;分页器组件 - Pager.js&lt;/li&gt;
&lt;li&gt;分页组件 - Pagination.js&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795a95132c47?w=350&amp;amp;h=754&amp;amp;f=png&amp;amp;s=37759&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在Pagination.js文件中增加以下代码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import React from 'react';

function Pagination() {
  return (
    &amp;lt;div className=&quot;x-pagination&quot;&amp;gt;
      Pagination组件
    &amp;lt;/div&amp;gt;
  );
}

export default Pagination;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以看到React开发组件的方式和Vue相差非常大，React推崇函数式编程（FP，Functional Programming），每个React组件都是一个函数，HTML/&lt;a href=&quot;https://styled-components.com/&quot;&gt;CSS&lt;/a&gt;/JavaScript都在函数里面，在函数里面返回模板内容。&lt;/p&gt;
&lt;p&gt;需要注意⚠️的是在React中HTML元素的class需要写成className，原因是class是JavaScript中的保留关键字，而React使用的JSX是JavaScript的扩展，使用class会导致命名冲突。&lt;/p&gt;
&lt;p&gt;React这种写法很特别，初学者可能会不太习惯，不过一旦用习惯了，会觉得非常爽，觉得一切都非常合理，组件就应该这样写。&lt;/p&gt;
&lt;p&gt;在App.js中使用Pagination组件：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import React from 'react';
import Pagination from './components/pagination/Pagination';
import './App.scss';

function App() {
  return (
    &amp;lt;div className=&quot;App&quot;&amp;gt;
      &amp;lt;Pagination /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}

export default App;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;使用React组件的方式也很简单，和使用普通HTML元素类似：&lt;/p&gt;
&lt;div&gt;
&lt;div&gt;
&lt;div&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;Pagination /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;显示的效果与Vue版本无异。&lt;/p&gt;
&lt;h2&gt;3.3 Angular版本&lt;/h2&gt;
&lt;p&gt;和Vue/React这种专注View视图层的轻量级框架不同，Angular是一个很重的框架，配备非常完整，Web开发过程中你需要的一切，Angular框架都给你提供好了，你只需要随手取用即可。&lt;/p&gt;
&lt;p&gt;我们一起来看看怎么开发一个Angular组件吧。&lt;/p&gt;
&lt;p&gt;同样是使用&lt;a href=&quot;https://cli.angular.io/&quot;&gt;Angular CLI&lt;/a&gt;创建一个基础的Angular项目，并输入命令npm start命令启动。&lt;/p&gt;
&lt;p&gt;和React/Vue组件不同，Angular组件不能单独使用，需要包一层Module，因此我们需要创建1个模块文件和3个组件文件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Pagination模块 - pagination.module.ts&lt;/li&gt;
&lt;li&gt;按钮组件 - button.component.ts&lt;/li&gt;
&lt;li&gt;分页器组件 - pager.component.ts&lt;/li&gt;
&lt;li&gt;分页组件 - pagination.component.ts&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;HTML/CSS可以放在ts文件里面，也可以放在单独的文件里。&lt;/p&gt;
&lt;p&gt;一般而言，HTML/CSS内容较少时，会将它们放到ts文件里。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795aa3d52025?w=478&amp;amp;h=886&amp;amp;f=png&amp;amp;s=67091&quot;/&gt;&lt;/p&gt;
&lt;p&gt;先创建Pagination模块，在pagination.module.ts文件中增加以下代码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import { NgModule } from &quot;@angular/core&quot;;
@NgModule()
export class PaginationModule { }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后是创建Pagination组件，在pagination.component.ts文件中增加以下代码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import { Component } from &quot;@angular/core&quot;;
@Component({
  selector: 'x-pagination',
  template: `
    &amp;lt;div class=&quot;x-pagination&quot;&amp;gt;
      Pagination组件
    &amp;lt;/div&amp;gt;
  `,
})
export class PaginationComponent { }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Angular和Vue/React非常明显的区别已经显示出来：&lt;/p&gt;
&lt;p&gt;首先是组件需要依托于Module存在；&lt;/p&gt;
&lt;p&gt;然后是不管是定义Module还是Component都需要使用装饰器；&lt;/p&gt;
&lt;p&gt;比如定义一个Angular模块需要使用@NgModule装饰器，定义一个Angular组件需要使用@Component装饰器。&lt;/p&gt;
&lt;p&gt;还有就是Angular推崇的是面向对象的编程范式，Angular里面的几乎一切都是类和对象，除了刚才一经介绍的模块和组件，还有服务（Service）、管道（Pipe）等，都是类（class）。&lt;/p&gt;
&lt;p&gt;为了使用Pagination组件，我们需要先导入Pagination模块，并声明Pagination组件，在app.module.ts文件中增加以下代码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import { BrowserModule } from '@angular/platform-browser';
import { NgModule } from '@angular/core';
import { AppComponent } from './app.component';
import { PaginationModule } from './components/pagination/pagination.module';
import { PaginationComponent } from './components/pagination/pagination.component';
@NgModule({
  declarations: [
    AppComponent,
    PaginationComponent, // 声明Pagination组件
  ],
  imports: [
    BrowserModule,
    PaginationModule, // 导入Pagination模块
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后就能使用Pagination组件了，在app.component.ts文件中增加以下代码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;div style=&quot;text-align:center&quot;&amp;gt;
  &amp;lt;h1&amp;gt;
    Welcome to {{ title }}!
  &amp;lt;/h1&amp;gt;
  &amp;lt;img width=&quot;300&quot; alt=&quot;Angular Logo&quot; src=&quot;data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyNTAgMjUwIj4KICAgIDxwYXRoIGZpbGw9IiNERDAwMzEiIGQ9Ik0xMjUgMzBMMzEuOSA2My4ybDE0LjIgMTIzLjFMMTI1IDIzMGw3OC45LTQzLjcgMTQuMi0xMjMuMXoiIC8+CiAgICA8cGF0aCBmaWxsPSIjQzMwMDJGIiBkPSJNMTI1IDMwdjIyLjItLjFWMjMwbDc4LjktNDMuNyAxNC4yLTEyMy4xTDEyNSAzMHoiIC8+CiAgICA8cGF0aCAgZmlsbD0iI0ZGRkZGRiIgZD0iTTEyNSA1Mi4xTDY2LjggMTgyLjZoMjEuN2wxMS43LTI5LjJoNDkuNGwxMS43IDI5LjJIMTgzTDEyNSA1Mi4xem0xNyA4My4zaC0zNGwxNy00MC45IDE3IDQwLjl6IiAvPgogIDwvc3ZnPg==&quot;&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;x-pagination&amp;gt;&amp;lt;/x-pagination&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;使用Angular组件的方式和普通的HTML元素类似：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;x-pagination&amp;gt;&amp;lt;/x-pagination&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;显示的效果与Vue/React一样。&lt;/p&gt;

&lt;p&gt;在添加实际的分页功能之前我们需要先做一个List组件，用来模拟分页数据的展示。&lt;/p&gt;
&lt;p&gt;根据我们之前介绍的3个框架实现组件的方式，然后稍微增加些额外的知识，我们就能很快做一个数据渲染组件List。&lt;/p&gt;
&lt;p&gt;还是先看Vue框架吧。&lt;/p&gt;
&lt;h2&gt;4.1 Vue版本&lt;/h2&gt;
&lt;p&gt;新建List.vue组件文件，输入以下代码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li v-for=&quot;list in lists&quot; :key=&quot;list.id&quot;&amp;gt;
      {{ list.name }}
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: 'List',
  props: {
    dataSource: Array
  },
  data() {
    return {
      lists: this.dataSource
    }
  },
  watch: {
    // 对dataSource进行监听，如果发生变化则重新将新值赋给lists
    dataSource: {
      handler(newValue, oldValue) {
        this.lists = newValue;
      }
    }
  }
};
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在template模板部分，我们使用Vue的v-for指令，在li元素中循环lists数组，并将name值显示出来。其中的:key是v-bind:key的简写形式，为元素绑定唯一的key值，用于DOM对比时的性能优化。&lt;/p&gt;
&lt;p&gt;1) 通过props传入数据&lt;/p&gt;
&lt;p&gt;原本我打算直接将lists的值放到props中，通过外部传进来，如下：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;ul&amp;gt;
    &amp;lt;li v-for=&quot;list in lists&quot; :key=&quot;list.id&quot;&amp;gt;
      {{ list.name }}
    &amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
export default {
  name: 'List',
  props: {
    lists: Array
  }
};
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样有一个问题，就是外部传入的lists如果发生变化，template里绑定的lists不会相应的变化。&lt;/p&gt;
&lt;p&gt;2) 维护内部状态&lt;/p&gt;
&lt;p&gt;为了监听props中的值的变化，我把lists放到组件内部状态中（data），外部传入的数据叫dataSource，如下：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;script&amp;gt;
export default {
  name: 'List',
  props: {
    dataSource: Array
  },
  data() {
    return {
      lists: this.dataSource
    }
  },
};
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;3) 监听外部props的变化&lt;/p&gt;
&lt;p&gt;然后监听dataSource的变化，当dataSource变化时，将新值赋值给lists：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
watch: {
  // 对dataSource进行监听，如果发生变化则重新将新值赋给lists
  dataSource: {
    handler(newValue, oldValue) {
      this.lists = newValue;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;传入List组件的lists数组如下：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;div readability=&quot;29&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
export const lists = [
  { id: 1, name: 'Curtis' },
  { id: 2, name: 'Cutler' },
  { id: 3, name: 'Cynthia' },
  { id: 4, name: 'Cyril' },
  { id: 5, name: 'Cyrus' },
  { id: 6, name: 'Dagmar' },
  { id: 7, name: 'Dahl' },
  { id: 8, name: 'Dahlia' },
  { id: 9, name: 'Dailey' },
  { id: 10, name: 'Daine' },
];
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;使用List组件展示数据：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;List :data-source=&quot;lists&quot; /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里需要注意⚠️的是，所有绑定的数据需要使用短横线命名法，比如上面的data-source，对应data中驼峰命名法的dataSource。&lt;/p&gt;
&lt;p&gt;展示的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795aa831ab3e?w=292&amp;amp;h=504&amp;amp;f=png&amp;amp;s=7953&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;4.2 React版本&lt;/h2&gt;
&lt;p&gt;React编写的是函数组件，props的变化会直接反映到模板中，不需要单独监听，所以写起来非常简洁：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import React from 'react';
function List({ dataSource }) {
  return (
    &amp;lt;ul className=&quot;m-list&quot;&amp;gt;
      {
        dataSource.map(list =&amp;gt; {
          return &amp;lt;li key={ list.id }&amp;gt;{ list.name }&amp;lt;/li&amp;gt;;
        })
      }
    &amp;lt;/ul&amp;gt;
  );
}
export default List
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;外部数据通过函数的props参数传入，这里将props进行了对象解构，直接取到了dataSource字段。&lt;/p&gt;
&lt;p&gt;还有一点和Vue不太一样，就是React是函数式编程的写法，列表数据的渲染不需要v-for之类的指令，而是通过数组的map方法，直接返回相应的li元素即可，看着非常自然。其中li元素上绑定的key值与Vue中key值的作用类似。&lt;/p&gt;
&lt;p&gt;使用方式和Vue的类似：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;List dataSource={dataSource} /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;4.3 Angular版本&lt;/h2&gt;
&lt;p&gt;Angular稍微麻烦些，需要同时定义Module和Component：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;List模块 - list.module.ts&lt;/li&gt;
&lt;li&gt;List组件：list.component.ts&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先编写list.module.ts：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import { NgModule } from &quot;@angular/core&quot;;
@NgModule()
export class ListModule { }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后编写List组件list.component.ts：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import { Component, Input } from &quot;@angular/core&quot;;
@Component({
  selector: 'x-list',
  template: `
    &amp;lt;ul&amp;gt;
      &amp;lt;li *ngFor=&quot;let list of dataSource; trackBy: trackByIndex&quot;&amp;gt;
        {{ list.name }}
      &amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  `,
})
export class ListComponent {
  @Input() dataSource;
  trackByIndex(index, list){
    return list.id;
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Angular和Vue/React的差别比较大：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一是外部传参方式不同，Angular使用@Input这个装饰器表示外部参数；&lt;/li&gt;
&lt;li&gt;二是Angular使用ngFor指令渲染列表数据；&lt;/li&gt;
&lt;li&gt;三是Angular优化DOM对比的方式是使用trackBy。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Angular组件的使用方式，倒是和其他框架大同小异：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;x-list [dataSource]=&quot;dataSource&quot;&amp;gt;&amp;lt;/x-list&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;接下来我们开始给Pagination组件添加实际的分页功能。&lt;/p&gt;
&lt;p&gt;添加分页功能之前，我们先设计好Pagination组件的API：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据总数 - total&lt;/li&gt;
&lt;li&gt;每页数据数 - defaultPageSize&lt;/li&gt;
&lt;li&gt;当前页码 - defaultCurrent&lt;/li&gt;
&lt;li&gt;页码改变事件 - onChange&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;total和defaultPageSize两个参数可以合并为一个参数totalPage（总页码），不过考虑到后续的可扩展性（比如需要改变pageSize），将其拆分开来。&lt;/p&gt;
&lt;p&gt;实现分页按钮分以下步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;实现一个通用的按钮组件&lt;/li&gt;
&lt;li&gt;在分页组件中使用按钮组件&lt;/li&gt;
&lt;li&gt;使用Pagination组件对List进行分页&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;5.1 Vue版本&lt;/h2&gt;
&lt;h3&gt;5.1.1 实现通用的按钮组件&lt;/h3&gt;
&lt;p&gt;通过前面编写的空的Pagination组件和List组件，相信大家对Vue组件都很熟悉了。&lt;/p&gt;
&lt;p&gt;新建一个Button.vue组件文件，编写以下代码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;button type=&quot;button&quot; @click=&quot;$emit('click')&quot;&amp;gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    name: 'Button',
  };
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里要特别注意的是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Vue组件向外暴露事件的方式：使用$emit方法；&lt;/li&gt;
&lt;li&gt;还有就是Vue定义插槽的方式是使用&amp;lt;slot&amp;gt;标签。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;其实以上的写法是一种简写形式，实际应该是这样：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;button type=&quot;button&quot; @click=&quot;click()&quot;&amp;gt;&amp;lt;slot&amp;gt;&amp;lt;/slot&amp;gt;&amp;lt;/button&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
  export default {
    name: 'Button',
    methods: {
      click() {
        this.$emit('click');
      }
    },
  };
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;$emit是Vue组件实例的是一个方法，用于组件对外暴露事件和传递数据，后面会看到传参的例子。&lt;/p&gt;
&lt;h3&gt;5.1.2 在Pagination组件中使用Button组件&lt;/h3&gt;
&lt;p&gt;做了这么多准备工作，终于可以做些实际的功能。&lt;/p&gt;
&lt;p&gt;还记得之前我们编写了一个空的Pagination组件吗？这时我们可以往里面写点功能了。&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div readability=&quot;23&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;x-pagination&quot;&amp;gt;
    &amp;lt;Button class=&quot;btn-prev&quot; @click=&quot;setPage(current - 1)&quot;&amp;gt;&amp;amp;lt;&amp;lt;/Button&amp;gt;
    {{ current }}
    &amp;lt;Button class=&quot;btn-next&quot; @click=&quot;setPage(current + 1)&quot;&amp;gt;&amp;gt;&amp;lt;/Button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import Button from './Button.vue';
export default {
  name: 'Pagination',
  components: {
    Button,
  },
  // 接口定义 props
  props: {
    defaultCurrent: Number,
    defaultPageSize: Number,
    total: Number,
  },
  // 组件内部状态 data
  data() {
    return {
      current: this.defaultCurrent,
    }
  },
  // 计算属性
  computed: {
    totalPage: function () {
      return Math.ceil(this.total / this.defaultPageSize);
    },
  },
  // 内部方法定义
  methods: {
    setPage(page) {
      if (page &amp;lt; 1) return;
      if (page &amp;gt; this.totalPage) return;
      this.current = page;
      this.$emit('change', this.current);
    },
  }
};
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;将之前的文字“Pagination组件”删掉，加上上一页（&amp;lt;）/下一页（&amp;gt;）两个翻页按钮，另外我们也将当前页码current展示在两个翻页按钮中间，这样我们能更清楚当前处于第几页。&lt;/p&gt;
&lt;p&gt;由于左尖括号与HTML标签的左尖括号冲突，不能直接使用，需要使用HTML实体字符&amp;amp;lt;代替。&lt;/p&gt;
&lt;p&gt;之前设计的Pagination组件的API参数都放到props里面：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
// 接口定义 props
props: {
  defaultCurrent: Number, // 默认当前页码
  defaultPageSize: Number, // 默认每页数据数
  total: Number, // 数据总数
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;我们定义了一个组件内部属性current，用于存放动态的页码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
// 组件内部状态 data
data() {
  return {
    current: this.defaultCurrent,
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;需要注意⚠️的是，data属性使用的是函数形式，在函数内部返回一个对象，current定义在该对象里面，这样可以确保每个实例可以维护一份被返回对象的独立的拷贝，具体原因可以参考&lt;a href=&quot;https://cn.vuejs.org/v2/guide/components.html#data-%E5%BF%85%E9%A1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0&quot;&gt;官网的解释&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外我们还定义了一个&lt;a href=&quot;https://cn.vuejs.org/v2/guide/computed.html#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7&quot;&gt;计算属性&lt;/a&gt;，用于获取总页码totalPage（限制页码边界时需要用到）：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
// 计算属性
computed: {
  totalPage: function () {
    return Math.ceil(this.total / this.defaultPageSize);
  },
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;最后定义了一个内部方法setPage，用于改变页码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
// 内部方法定义
methods: {
  setPage(page) {
    if (page &amp;lt; 1) return; // 限制上一页翻页按钮的边界
    if (page &amp;gt; this.totalPage) return; // 限制下一页翻页按钮的边界
    this.current = page;
    this.$emit('change', this.current);
  },
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当点击上一页/下一页翻页按钮时都会调用该方法，传入改变后的页码值。&lt;/p&gt;
&lt;p&gt;如果是上一页，则传入current - 1：&lt;/p&gt;
&lt;p&gt;&amp;lt;Button class=&quot;btn-prev&quot; @click=&quot;setPage(current - 1)&quot;&amp;gt;&amp;amp;lt;&amp;lt;/Button&amp;gt;&lt;/p&gt;
&lt;p&gt;下一页则是current + 1：&lt;/p&gt;
&lt;p&gt;&amp;lt;Button class=&quot;btn-next&quot; @click=&quot;setPage(current + 1)&quot;&amp;gt;&amp;gt;&amp;lt;/Button&amp;gt;&lt;/p&gt;
&lt;p&gt;setPage中除了设置当前页码之外，还将页码改变事件发射出去，并将当前页码传到组件外部。&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
this.$emit('change', this.current);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;另外也增加了一些限制翻页边界的逻辑，避免翻页时超过页码的边界，导致不必要的Bug：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
if (page &amp;lt; 1) return; // 限制上一页翻页按钮的边界
if (page &amp;gt; this.totalPage) return; // 限制下一页翻页按钮的边界
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;5.1.3 使用Pagination组件对List进行分页&lt;/h3&gt;
&lt;p&gt;有了Pagination组件和List组件，就可以使用Pagination对List进行分页展示。&lt;/p&gt;
&lt;p&gt;在Home.vue组件中使用Pagination组件。&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;div readability=&quot;25&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;home&quot;&amp;gt;
    &amp;lt;img alt=&quot;Vue logo&quot; src=&quot;../assets/logo.png&quot;&amp;gt;
    &amp;lt;List :data-source=&quot;dataList&quot; /&amp;gt;
    &amp;lt;Pagination :default-current=&quot;defaultCurrent&quot; :default-page-size=&quot;defaultPageSize&quot; :total=&quot;total&quot; @change=&quot;onChange&quot; /&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;
import Pagination from '@/components/pagination/Pagination.vue';
import List from './List.vue';
import { lists } from '@/db';
import { chunk } from '@/util';
export default {
  name: 'home',
  components: {
    Pagination,
    List,
  },
  data() {
    return {
      defaultCurrent: 1,
      defaultPageSize: 3,
      total: lists.length,
      dataList: [],
    }
  },
  created() {
    this.setList(this.defaultCurrent, this.defaultPageSize);
  },
  methods: {
    onChange(current) {
      this.setList(current, this.defaultPageSize);
    },
    setList: function(current, pageSize) {
      this.dataList = chunk(lists, pageSize)[current - 1];
    }
  }
};
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;除了defaultCurrent/defaultPageSize/total这3个Pagination组件的参数外，我们在data内部状态中还定义了一个dataList字段，用于动态传入给List组件，达到分页的效果。&lt;/p&gt;
&lt;p&gt;在setList方法中将对lists进行分块，并根据当前的页码获取分页数据，并赋值给dataList字段，这样List组件中就会展示相应的分页数据。&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
setList: function(current, pageSize) {
  this.dataList = chunk(lists, pageSize)[current - 1];
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;setList方法在两处进行调用：created&lt;a href=&quot;https://cn.vuejs.org/v2/guide/instance.html#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E7%A4%BA&quot;&gt;生命周期方法&lt;/a&gt;和onChange页码改变事件。&lt;/p&gt;
&lt;p&gt;created生命周期事件在Vue实例初始化之后，挂载到DOM之前执行，在created事件中我们将第1页的数据赋值给dataList：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
created() {
  this.setList(this.defaultCurrent, this.defaultPageSize);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;因此List组件将展示第1页的数据：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795aab2d563f?w=214&amp;amp;h=256&amp;amp;f=png&amp;amp;s=6126&quot;/&gt;&lt;/p&gt;
&lt;p&gt;onChange事件是Pagination组件的页码改变事件，当点击上一个/下一页翻页按钮时执行，在该事件中可获取到当前的页码current。&lt;/p&gt;
&lt;p&gt;我们在该事件中将当前页码的数据赋值给dataList，这样List组件将展示当前页码的数据，从而达到分页效果。&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
onChange(current) {
  this.setList(current, this.defaultPageSize);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;setList方法调用了chunk方法（作用与Lodash中的chunk方法类似），该方法用于将一个数组分割成指定大小的多个小数组，它的源码如下：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;div readability=&quot;13&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
// 将数组按指定大小分块
export function chunk(arr = [], size = 1) {
  if (arr.length === 0) return [];
  return arr.reduce((total, currentValue) =&amp;gt; {
    if (total[total.length - 1].length === size) {
      total.push([currentValue]);
    } else {
      total[total.length - 1].push(currentValue);
    }
    return total;
  }, [[]]);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;比如之前的lists数组，如果按每页3条数据进行分块chunk(lists, 3)，则得到的结果如下：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;div readability=&quot;29&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
[
  [
    { &quot;id&quot;: 1, &quot;name&quot;: &quot;Curtis&quot; },
    { &quot;id&quot;: 2, &quot;name&quot;: &quot;Cutler&quot; },
    { &quot;id&quot;: 3, &quot;name&quot;: &quot;Cynthia&quot; }
  ],
  [
    { &quot;id&quot;: 4, &quot;name&quot;: &quot;Cyril&quot; },
    { &quot;id&quot;: 5, &quot;name&quot;: &quot;Cyrus&quot; },
    { &quot;id&quot;: 6, &quot;name&quot;: &quot;Dagmar&quot; }
  ],
  [
    { &quot;id&quot;: 7, &quot;name&quot;: &quot;Dahl&quot; },
    { &quot;id&quot;: 8, &quot;name&quot;: &quot;Dahlia&quot; },
    { &quot;id&quot;: 9, &quot;name&quot;: &quot;Dailey&quot; }
  ],
  [
    { &quot;id&quot;: 10, &quot;name&quot;: &quot;Daine&quot; }
  ]
]
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;最终实现的分页效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795ab0a5167c?w=214&amp;amp;h=256&amp;amp;f=png&amp;amp;s=6126&quot;/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795ac08a0f84?w=202&amp;amp;h=276&amp;amp;f=png&amp;amp;s=5492&quot;/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795acbb46643?w=198&amp;amp;h=178&amp;amp;f=png&amp;amp;s=3672&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在做一个小小的总结，为了实现分页功能，我们：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;先实现了一个通用的按钮组件；&lt;/li&gt;
&lt;li&gt;然后使用这个通用组件，在Pagination组件中增加上一页/下一页两个翻页按钮，点击可以改变当前页码current；&lt;/li&gt;
&lt;li&gt;接着使用做好的Pagination组件对List列表组件进行分页。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来我们看下React如何实现以上功能。&lt;/p&gt;
&lt;h2&gt;5.2 React版本&lt;/h2&gt;
&lt;h3&gt;5.1.1 实现通用的按钮组件&lt;/h3&gt;
&lt;p&gt;同样也是先定义一个通用按钮组件Button.js：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import React from 'react';
function Button({ onClick, children }) {
  return (
    &amp;lt;button type=&quot;button&quot; onClick={ onClick }&amp;gt;{ children }&amp;lt;/button&amp;gt;
  );
}
export default Button
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;通过前面开发的Pagination/List组件，相信大家对React的函数组件并不陌生了。&lt;/p&gt;
&lt;p&gt;和Vue不同的是，React不需要对外发射事件之类的操作，传什么事件进来直接就发射出去了；&lt;/p&gt;
&lt;p&gt;另一个不同是定义插槽的方式，React使用props.children代表组件标签中间传入的内容。&lt;/p&gt;
&lt;h3&gt;5.1.2 在Pagination组件中使用Button组件&lt;/h3&gt;
&lt;p&gt;然后使用通用按钮组件，在Pagination组件中增加上一页/下一页两个翻页按钮：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import React, { useState } from 'react';
import Button from './Button';
function Pagination(props) {
  const { total, defaultCurrent, defaultPageSize, onChange } = props;
  // 声明一个叫 “current” 的 state 变量，用来保存当前的页码；
  // setPage方法是用来改变current的。
  const [current, setPage] = useState(defaultCurrent);
  const totalPage = Math.ceil(total / defaultPageSize);
  return (
    &amp;lt;div className=&quot;m-pagination&quot;&amp;gt;
      &amp;lt;Button className=&quot;btn-prev&quot; onClick={() =&amp;gt; {
        if (current &amp;lt; 2) return;
        setPage(current - 1);
        onChange(current - 1);
      }}&amp;gt;&amp;amp;lt;&amp;lt;/Button&amp;gt;
      {{ current }}
      &amp;lt;Button className=&quot;btn-next&quot; onClick={() =&amp;gt; {
        if (current &amp;gt;= totalPage) return;
        setPage(current + 1);
        onChange(current + 1);
      }}&amp;gt;&amp;gt;&amp;lt;/Button&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}
export default Pagination;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这里引出React 16.8之后一个很重要的概念：&lt;a href=&quot;https://zh-hans.reactjs.org/docs/hooks-intro.html&quot;&gt;React Hooks&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;为了在函数组件中定义组件内部状态，从react库中引入了&lt;a href=&quot;https://zh-hans.reactjs.org/docs/hooks-state.html&quot;&gt;useState&lt;/a&gt;这个方法：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import React, { useState } from 'react';
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;useState就是一个Hook，通过在函数组件里调用它来给组件添加一些内部state，React会在重复渲染时保留这个state。&lt;/p&gt;
&lt;p&gt;useState会返回一对值：当前状态和一个让你更新它的函数。&lt;/p&gt;
&lt;p&gt;useState唯一的参数就是初始state，这里是默认当前页码（defaultCurrent），这个初始 state 参数只有在第一次渲染时会被用到。&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
const [current, setPage] = useState(defaultCurrent);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当点击上一页/下一页翻页按钮时，我们调用了setPage方法，传入新的页码，从而改变current当前页码，实现分页功能。&lt;/p&gt;
&lt;p&gt;另外也和Vue版本一样，通过调用onChange方法将页码改变事件发射出去，并将当前页码传递到组件之外。&lt;/p&gt;
&lt;p&gt;如果是上一页：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;Button className=&quot;btn-prev&quot; onClick={() =&amp;gt; {
  if (current &amp;lt; 2) return;
  setPage(current - 1);
  onChange(current - 1);
}}&amp;gt;&amp;amp;lt;&amp;lt;/Button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;如果是下一页：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;Button className=&quot;btn-next&quot; onClick={() =&amp;gt; {
  if (current &amp;gt;= totalPage) return;
  setPage(current + 1);
  onChange(current + 1);
}}&amp;gt;&amp;gt;&amp;lt;/Button&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;5.1.3 使用Pagination组件对List进行分页&lt;/h3&gt;
&lt;p&gt;Pagination组件做好了，我们就可以使用它来给List列表组件进行分页啦。&lt;/p&gt;
&lt;p&gt;在App.js中引入List和Pagination组件：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import React, { useState } from 'react';
import Pagination from './components/pagination/Pagination';
import List from './components/List';
import { lists } from './db';
import { chunk } from './util';
import './App.scss';
function App() {
  const defaultCurrent = 1;
  const defaultPageSize = 3;
  // 设置List默认分页数据：第一页的数据chunk(lists, defaultPageSize)[defaultCurrent - 1]
  const [dataSource, setLists] = useState(chunk(lists, defaultPageSize)[defaultCurrent - 1]);
  return (
    &amp;lt;div className=&quot;App&quot;&amp;gt;
      &amp;lt;List dataSource={dataSource} /&amp;gt;
      &amp;lt;Pagination total={lists.length} defaultCurrent={defaultCurrent} defaultPageSize={defaultPageSize} onChange={current =&amp;gt; {
        // 页码改变时，重新设置当前的分页数据
        setLists(chunk(lists, defaultPageSize)[current - 1]);
      }} /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}
export default App;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;同样也是定义了一个List组件的数据源（使用useState这个React Hook）：dataSource，默认设置为第一页的数据：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
// 设置List默认分页数据：第一页的数据chunk(lists, defaultPageSize)[defaultCurrent - 1]
const [dataSource, setLists] = useState(chunk(lists, defaultPageSize)[defaultCurrent - 1]);
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;当页码改变时，Pagination的onChange事件能捕获到并执行，该事件中可以拿到当前页码current，这时我们可以通过调用useState的第2个返回值——setLists方法——来改变dataSource数据源，实现分页功能：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;Pagination ... onChange={current =&amp;gt; {
  // 页码改变时，重新设置当前的分页数据
  setLists(chunk(lists, defaultPageSize)[current - 1]);
}} /&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在组件内维护状态的方式，React和Vue相差较大，这里做一个简单的对比：&lt;/p&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;8&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt; &lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;组件内部状态存放位置&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;改变组件内部状态的方式&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;11&quot;&gt;&lt;td&gt;
&lt;p&gt;React&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;useState第1个返回值。&lt;/p&gt;
&lt;p&gt;const [&lt;strong class=&quot;juejin-editor-bold&quot;&gt;state&lt;/strong&gt;, setState] = useState(initialState];&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;8&quot;&gt;
&lt;p&gt;useState第2个返回值（一个方法）。&lt;/p&gt;
&lt;p&gt;const [state, &lt;strong class=&quot;juejin-editor-bold&quot;&gt;setState&lt;/strong&gt;] = useState(initialState];&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;8&quot;&gt;&lt;td&gt;
&lt;p&gt;Vue&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;data方法中。&lt;/p&gt;
&lt;p&gt;data() {&lt;/p&gt;
&lt;p&gt;   return {&lt;/p&gt;
&lt;p&gt;     state: [],&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;7&quot;&gt;
&lt;p&gt;methods对象中。&lt;/p&gt;
&lt;p&gt;methods: {&lt;/p&gt;
&lt;p&gt;   setState: function() {&lt;/p&gt;
&lt;p&gt;     // 执行具体的代码&lt;/p&gt;
&lt;p&gt;   }&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p&gt;另外还有一个需要注意⚠️：&lt;/p&gt;
&lt;p&gt;在Vue中，为了初始化List的数据源，没法直接在data中写，比如：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
data() {
  return {
    dataList: chunk(lists, this.defaultPageSize)[this.defaultCurrent - 1],
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;而是必须在created初始化方法中写：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
created() {
  this.dataList = chunk(lists, this.defaultPageSize)[this.defaultCurrent - 1];
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;而在React中则显得简洁和自然许多：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
// 设置List默认分页数据：第一页的数据
const [dataSource, setLists] = useState(chunk(lists, defaultPageSize)[defaultCurrent - 1];
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;不过React这种写法对初学者是不友好的，习惯之后会觉得很舒服。&lt;/p&gt;
&lt;h2&gt;5.3 Angular版本&lt;/h2&gt;
&lt;h3&gt;5.1.1 实现通用的按钮组件&lt;/h3&gt;
&lt;p&gt;最后来看下Angular如何实现分页功能，思路都一样，先定义一个通用按钮组件button.component.ts：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import { Component, Output, EventEmitter } from &quot;@angular/core&quot;;
@Component({
  selector: 'x-button',
  template: `
    &amp;lt;button type=&quot;button&quot; (click)=&quot;onClick()&quot;&amp;gt;&amp;lt;ng-content&amp;gt;&amp;lt;/ng-content&amp;gt;&amp;lt;/button&amp;gt;
  `,
})
export class ButtonComponent {
  @Output() btnClick = new EventEmitter();
  onClick() {
    this.btnClick.emit();
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Angular和React/Vue的差别是很明显的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一是绑定事件的语法不同；&lt;/li&gt;
&lt;li&gt;二是定义插槽的方式不同；&lt;/li&gt;
&lt;li&gt;三是暴露外部事件和发射外部事件的方式不同。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里也简单做一个对比：&lt;/p&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr&gt;&lt;td&gt; &lt;/td&gt;
&lt;td&gt;
&lt;p&gt;绑定事件&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;定义插槽&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;外部事件&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Vue&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;v-on指令（简写形式：@）&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&amp;lt;slot&amp;gt;标签&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;$emit()&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;
&lt;p&gt;React&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;props传递&lt;/p&gt;
&lt;p&gt;props.onClick&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;props.children&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;props传递，无需发射&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;
&lt;p&gt;Angular&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;括号符()&lt;/p&gt;
&lt;p&gt;(click)=&quot;btnClick()&quot;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&amp;lt;ng-content&amp;gt;标签&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;@Output()+emit()&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;h3&gt;5.1.2 在Pagination组件中使用Button组件&lt;/h3&gt;
&lt;p&gt;现在模板中使用通用按钮组件pagination.component.html：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;div class=&quot;x-pagination&quot;&amp;gt;
  &amp;lt;x-button
    class=&quot;btn-prev&quot;
    (btnClick)=&quot;setPage(current - 1)&quot;
  &amp;gt;&amp;amp;lt;&amp;lt;/x-button&amp;gt;
  {{ current }}
  &amp;lt;x-button
    class=&quot;btn-next&quot;
    (btnClick)=&quot;setPage(current + 1)&quot;
  &amp;gt;&amp;gt;&amp;lt;/x-button&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后在pagination.component.ts中定义具体逻辑：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div readability=&quot;15&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import { Component, Input, Output, EventEmitter } from &quot;@angular/core&quot;;
@Component({
  selector: 'x-pagination',
  templateUrl: './pagination.component.html',
  styleUrls: ['./pagination.component.scss']
})
export class PaginationComponent {
  // 组件接口定义
  @Input() total: number;
  @Input() defaultCurrent = 1;
  @Input() defaultPageSize: number;
  @Output() onChange = new EventEmitter();
  // 计算属性
  @Input()
  get totalPage() {
    return Math.ceil(this.total / this.defaultPageSize);
  }
  // 组件内部状态
  current = this.defaultCurrent;
  // 组件方法
  setPage(page) {
    if (this.current &amp;lt; 2) return;
    if (this.current &amp;gt; this.totalPage - 1) return;
    this.current = page;
    this.onChange.emit(this.current);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;和Vue/React一样，定义组件接口/计算属性/内部状态/组件方法，只是具体的语法不同，语法上的对比前面已经说明，不再赘言。&lt;/p&gt;
&lt;p&gt;下面直接介绍如何使用Pagination组件对List进行分页。&lt;/p&gt;
&lt;h3&gt;5.1.3 使用Pagination组件对List进行分页&lt;/h3&gt;
&lt;p&gt;在app.component.html中引入Pagination/List两个组件：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;x-list [dataSource]=&quot;dataSource&quot;&amp;gt;&amp;lt;/x-list&amp;gt;
&amp;lt;x-pagination
  [total]=&quot;total&quot;
  [defaultCurrent]=&quot;defaultCurrent&quot;
  [defaultPageSize]=&quot;pageSize&quot;
  (onChange)=&quot;onChange($event)&quot;
&amp;gt;&amp;lt;/x-pagination&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在app.component.ts中定义具体逻辑：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;div readability=&quot;17&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import { Component, OnInit } from '@angular/core';
import { lists } from './db';
import { chunk } from './util';
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss']
})
export class AppComponent implements OnInit {
  defaultCurrent = 1;
  defaultPageSize = 3;
  total = lists.length;
  dataSource = [];
  ngOnInit() {
    this.setLists(this.defaultCurrent, this.defaultPageSize);
  }
  onChange(current) { // 页码改变
    this.setLists(current, this.defaultPageSize);
  }
  setLists(page, pageSize) {
    this.dataSource = chunk(lists, pageSize)[page - 1];
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;思路也是一样的，定义一个List组件的数据源dataSource，组件初始化（ngOnInit）时给dataSource设置初始分页数据（第一页数据），然后在页码改变时重新设置dataSource的值，不再赘言。&lt;/p&gt;
&lt;p&gt;只是有一些差异需要注意⚠️：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Angular的初始化方法是ngOnInit，Vue是created；&lt;/li&gt;
&lt;li&gt;Angular绑定属性的方式是使用中括号[]，Vue是使用v-bind指令（或者简写方式:key）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;至此三大框架实现基本分页功能的方法及其差异都已介绍完毕，后一节将介绍本文最核心的内容：分页器的实现。&lt;/p&gt;

&lt;p&gt;我们再来回顾下分页组件的模块图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795ae2e9016b?w=916&amp;amp;h=216&amp;amp;f=png&amp;amp;s=13064&quot;/&gt;&lt;/p&gt;
&lt;p&gt;中间显示页码的部分就是分页器，它的核心是页码显示和页码省略的逻辑。&lt;/p&gt;
&lt;h2&gt;6.1 页码显示策略&lt;/h2&gt;
&lt;p&gt;为了方便地跳转到任意页码，却又不至于在页面中显示太多页码，页码并不是始终全部显示出来的，而是在页码少时全部显示，页码多时只显示部分页码。这就存在显示策略问题。&lt;/p&gt;
&lt;p&gt;我们从当前页码出发，比如模块图中当前页码是第5页：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795ae4664dd1?w=732&amp;amp;h=90&amp;amp;f=png&amp;amp;s=3274&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么以该页码为中心，两边显示一定的页码，比如两边各显示2页；&lt;/p&gt;
&lt;p&gt;另外首页和尾页需要始终显示出来，方便回到首页和跳转到尾页；&lt;/p&gt;
&lt;p&gt;首页到第3页中间的页码以及第7页到尾尾的页码都隐藏起来，并且支持点击左/右更多按钮，快捷跳转多页（比如5页）的功能。&lt;/p&gt;
&lt;p&gt;另外需要考虑页码少的情况，如果只有8页怎么显示呢？&lt;/p&gt;
&lt;p&gt;很简单，直接去掉右边的更多按钮就好：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795ae7642bac?w=734&amp;amp;h=88&amp;amp;f=png&amp;amp;s=3524&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果当前页码在第4页呢？去掉左边的更多按钮，显示右边的更多按钮即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795aeb8c0936?w=736&amp;amp;h=94&amp;amp;f=png&amp;amp;s=3606&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上就是全部的页码显示策略。&lt;/p&gt;
&lt;p&gt;现简述如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首页尾页需要始终显示出来（如果只有1页则不显示尾页）；&lt;/li&gt;
&lt;li&gt;除首尾页之外，当前页码左右最多只显示2页（共5页）；&lt;/li&gt;
&lt;li&gt;其他页码折叠起来，用更多按钮代替。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来看看如何用三大框架实现这个逻辑。&lt;/p&gt;
&lt;h2&gt;6.2 Vue版本&lt;/h2&gt;
&lt;h3&gt;6.2.1 组件接口设计&lt;/h3&gt;
&lt;p&gt;编写Pager分页器组件之前，还是设计好组件的API：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;总页数 - totalPage&lt;/li&gt;
&lt;li&gt;默认当前页码 - defaultCurrent&lt;/li&gt;
&lt;li&gt;页码改变事件 - onChange&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;6.2.2 基本模板框架&lt;/h3&gt;
&lt;p&gt;然后先写好模板，在Pager.vue的&amp;lt;template&amp;gt;中编写以下代码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;ul class=&quot;x-pager&quot;&amp;gt;
    &amp;lt;li class=&quot;number&quot;&amp;gt;1&amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;more left&quot;&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;number&quot;&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;more right&quot;&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li class=&quot;number&quot;&amp;gt;{{ totalPage }}&amp;lt;/li&amp;gt;
  &amp;lt;/ul&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;再在&amp;lt;script&amp;gt;中写基本的逻辑：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;script&amp;gt;
import Vue from 'vue';
export default {
  name: 'Pager',
  // 组件接口定义
  props: {
    totalPage: Number, // 总页数
    defaultCurrent: Number, // 默认当前页码
  },
};
&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;搭好基本框架之后，我们采取&lt;a href=&quot;http://www.woshipm.com/pd/879821.html&quot;&gt;最小可用产品&lt;/a&gt;（Minimum Viable Product，MVP）的思路：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795afc23a1aa?w=1500&amp;amp;h=1060&amp;amp;f=jpeg&amp;amp;s=66578&quot;/&gt;&lt;/p&gt;
&lt;p&gt;分3步实现分页器功能：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第1步 实现首尾翻页&lt;/li&gt;
&lt;li&gt;第2步 实现快捷分页&lt;/li&gt;
&lt;li&gt;第3步 实现分页按钮组&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795b048e2219?w=1500&amp;amp;h=266&amp;amp;f=png&amp;amp;s=41271&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6.2.3 第1步：首/尾页翻页逻辑&lt;/h3&gt;
&lt;p&gt;先显示第1步：首页尾页的显示和跳页逻辑：&lt;/p&gt;
&lt;p&gt;首页&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;li
  class=&quot;number&quot;
  :class=&quot;{ active: this.current == 1 }&quot;
  @click=&quot;setPage(1)&quot;
&amp;gt;1&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;尾页&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;li
  class=&quot;number&quot;
  :class=&quot;{ active: this.current == totalPage }&quot;
  v-if=&quot;totalPage !== 1&quot;
  @click=&quot;setPage(totalPage)&quot;
&amp;gt;{{ totalPage }}&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;由于当前页码有可能从Pager组件外部改变（上一页/下一页按钮），因为需要监听defaultCurrent的变化，需要增加组件内部状态current代替defaultCurrent：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
data() {
  return {
    current: this.defaultCurrent, // 当前页码
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后监听defaultCurrent，当外部传入的defaultCurrent发生变化时，将新值赋值给current：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
watch: {
  defaultCurrent: {
    handler(newValue, oldValue) {
      this.current = newValue;
    }
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;接着定义翻页方法：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
methods: {
  setPage(page) {
    // 对页码进行限制，不能超出[1, totalPage]的范围
    let newPage = page;
    if (page &amp;lt; 1) newPage = 1;
    if (page &amp;gt; this.totalPage) newPage = this.totalPage;
    this.current = newPage; // 设置当前页码
    this.$emit('change', this.current); // 向外发射页码改变事件
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;显示的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795b18d5fe0d?w=410&amp;amp;h=90&amp;amp;f=png&amp;amp;s=1017&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6.2.4 在Pagination组件中使用Pager组件&lt;/h3&gt;
&lt;p&gt;我们可以在Pagination组件中试试初版的Pager。&lt;/p&gt;
&lt;p&gt;在Pagination.vue中，去掉之前页码显示的那一行代码，使用Pager组件替代：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;m-pagination&quot;&amp;gt;
    &amp;lt;Button class=&quot;btn-prev&quot; @click=&quot;setPage(current - 1)&quot;&amp;gt;&amp;amp;lt;&amp;lt;/Button&amp;gt;
    // 去掉该行 {{ current }}，替换成以下Pager组件
    &amp;lt;Pager :total-page=&quot;totalPage&quot; :default-current=&quot;current&quot; @change=&quot;onChange&quot;&amp;gt;&amp;lt;/Pager&amp;gt;
    &amp;lt;Button class=&quot;btn-next&quot; @click=&quot;setPage(current + 1)&quot;&amp;gt;&amp;gt;&amp;lt;/Button&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后增加Pager的onChange页码改变的回调事件：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
methods: {
  onChange(current) {
    this.current = current; // 设置当前页码
    this.$emit('change', this.current); // 向Pagination组件外发射页码改变事件
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;可以试试首/尾页的翻页效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795b1b56dbf7?w=574&amp;amp;h=220&amp;amp;f=png&amp;amp;s=4698&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6.2.5 第2步：增加左/右更多按钮的翻页功能&lt;/h3&gt;
&lt;p&gt;有了首尾页的翻页还不够，还需要继续完善更多按钮的快捷翻页功能。&lt;/p&gt;
&lt;p&gt;先梳理下更多按钮的显示逻辑：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;中间按钮一共5页，加上首尾按钮2页，一共7页，也就是说只有大于7页，才有可能显示更多按钮；&lt;/li&gt;
&lt;li&gt;左右更多按钮会随着当前页码的不同而显示或隐藏，以第4页和倒数第4页为界；&lt;/li&gt;
&lt;li&gt;当页码大于第4页时，应该显示左边更多按钮；&lt;/li&gt;
&lt;li&gt;当页码小于倒数第4页，都应该显示右边更多按钮。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;具体实现如下：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;!-- 左更多按钮 --&amp;gt;
&amp;lt;li
  class=&quot;more left&quot;
  v-if=&quot;totalPage &amp;gt; 7 &amp;amp;&amp;amp; current &amp;gt;= 5&quot;
&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;!-- 右更多按钮 --&amp;gt;
&amp;lt;li
  class=&quot;more right&quot;
  v-if=&quot;totalPage &amp;gt; 7 &amp;amp;&amp;amp; current &amp;lt;= totalPage - 4&quot;
&amp;gt;&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;不过我们不想写死这些数字，假设中间页码数为centerSize（这里是5），可以重构成：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;li
  class=&quot;more left&quot;
  v-if=&quot;totalPage &amp;gt; centerSize + 2 &amp;amp;&amp;amp; current &amp;gt;= centerSize&quot;
&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li
  class=&quot;more right&quot;
  v-if=&quot;totalPage &amp;gt; centerSize + 2 &amp;amp;&amp;amp; current &amp;lt;= totalPage - centerSize + 1&quot;
&amp;gt;&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;接着是增加快捷翻页事件：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;li
  class=&quot;more left&quot;
  v-if=&quot;totalPage &amp;gt; centerSize + 2 &amp;amp;&amp;amp; current &amp;gt;= centerSize&quot;
  @click=&quot;setPage(current - jumpSize)&quot;
&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li
  class=&quot;more right&quot;
  v-if=&quot;totalPage &amp;gt; centerSize + 2 &amp;amp;&amp;amp; current &amp;lt;= totalPage - centerSize + 1&quot;
  @click=&quot;setPage(current - jumpSize)&quot;
&amp;gt;&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;注意⚠️：为了不写死每次快捷跳转的页码，我们用jumpSize保存该值。&lt;/p&gt;
&lt;p&gt;接下来我们可以看看快捷翻页的效果，为了清楚看出当前处于哪一页，我们暂时将中间为哦未实现的页码按钮组显示成当前页码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6&quot;&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;!-- 中间页码组 --&amp;gt;
&amp;lt;li class=&quot;number&quot;&amp;gt;{{ current }}&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;初始在第1页： &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795b20326a04?w=498&amp;amp;h=258&amp;amp;f=png&amp;amp;s=6065&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击右更多按钮之后（跳转到第6页）： &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795b303f1e39?w=574&amp;amp;h=290&amp;amp;f=png&amp;amp;s=7175&quot;/&gt;&lt;/p&gt;
&lt;p&gt;再点击右更多按钮（跳转到第11页）： &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795b30033597?w=522&amp;amp;h=248&amp;amp;f=png&amp;amp;s=6061&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击左更多按钮则又回到第6页，完美达到预期。&lt;/p&gt;
&lt;h3&gt;6.2.6 第3步：实现中间的页码按钮组&lt;/h3&gt;
&lt;p&gt;中间页码组centerPages是一个长度在[0, centerSize]之间的数组，它的值由总页码totalPage和当前页码current共同决定，计算规则如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果总页码小于等于7，则centerPages是除首尾页之外的所有页码；&lt;/li&gt;
&lt;li&gt;如果总页码大于7，则centerPages是以current为中心，左右各加两页组成的页码数组。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;将centerPages定义为计算属性，具体实现如下：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
computed: {
  centerPages: function() {
    // 中间页码计算
    let centerPage = this.current;
    if (this.current &amp;gt; this.totalPage - 3) {
      centerPage = this.totalPage - 3;
    }
    if (this.current &amp;lt; 4) {
      centerPage = 4;
    }
    if (this.totalPage &amp;lt;= this.centerSize + 2) {
      // 总页码较小时，全部显示出来
      const centerArr = [];
      for (let i = 2; i &amp;lt; this.totalPage; i++) {
        centerArr.push(i);
      }
      return centerArr;
    } else {
      // 总页码较大时，只显示中间centerSize个页码
      const centerArr = [];
      for (let i = centerPage - 2; i &amp;lt;= centerPage + 2; i++) {
        centerArr.push(i);
      }
      return centerArr;
    }
  }
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;有了中间页码数组，就可以渲染中间页码组：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;!-- 中间页码组 --&amp;gt;
&amp;lt;li
  class=&quot;number&quot;
  v-for=&quot;(page, index) in centerPages&quot;
  :key=&quot;index&quot;
&amp;gt;{{ page }}&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;接着为其增加active类（用于高亮）和绑定点击事件（用于跳转到相应的页码）：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;!-- 中间页码组 --&amp;gt;
&amp;lt;li
  class=&quot;number&quot;
  :class=&quot;{ active: current === page }&quot;
  v-for=&quot;(page, index) in centerPages&quot;
  :key=&quot;index&quot;
  @click=&quot;setPage(page)&quot;
&amp;gt;{{ page }}&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;最终效果如下：&lt;/p&gt;
&lt;p&gt;只有1页的情况： &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795b43456a50?w=244&amp;amp;h=354&amp;amp;f=png&amp;amp;s=7740&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;=7页的情况： &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795b49adba41?w=756&amp;amp;h=358&amp;amp;f=png&amp;amp;s=13359&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt;7页且当前页码&amp;lt;=4页的情况： &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795b4ec45117?w=832&amp;amp;h=296&amp;amp;f=png&amp;amp;s=7884&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&amp;gt;7页且当前页码&amp;gt;4页的情况： &lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/9/171f795b524abb10?w=908&amp;amp;h=302&amp;amp;f=png&amp;amp;s=8695&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，Vue版本分页器组件已全部实现，整个Pagination组件也全部实现。&lt;/p&gt;
&lt;p&gt;接下来看看React/Angular如何实现分页器吧。&lt;/p&gt;
&lt;h2&gt;6.3 React版本&lt;/h2&gt;
&lt;p&gt;同样采&lt;a href=&quot;http://www.woshipm.com/pd/879821.html&quot;&gt;MVP&lt;/a&gt;的思路，我们按以下步骤开发Pager分页器组件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;搭建基本模板框架&lt;/li&gt;
&lt;li&gt;实现首尾页翻页&lt;/li&gt;
&lt;li&gt;实现更多按钮快捷翻页&lt;/li&gt;
&lt;li&gt;实现页码按钮组翻页&lt;/li&gt;
&lt;/ol&gt;&lt;h3&gt;6.3.1 基本模板框架&lt;/h3&gt;
&lt;p&gt;我们先搭建基本模板框架，在Pager.js中编写以下代码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div readability=&quot;12&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import React from 'react';
function Pager({ totalPage, defaultCurrent, onChange }) {
  return (
    &amp;lt;ul className=&quot;x-pager&quot;&amp;gt;
      &amp;lt;li className=&quot;number&quot;&amp;gt;1&amp;lt;/li&amp;gt;
      &amp;lt;li className=&quot;more left&quot;&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;li className=&quot;number&quot;&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;li className=&quot;more right&quot;&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;li className=&quot;number&quot;&amp;gt;{ totalPage }&amp;lt;/li&amp;gt;
    &amp;lt;/ul&amp;gt;
  );
}
export default Pager;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这只是一个空壳子，什么都做不了，接下来我们加点实际的功能。&lt;/p&gt;
&lt;h3&gt;6.3.2 第1步：首/尾页翻页逻辑&lt;/h3&gt;
&lt;p&gt;增加首尾页显示条件、高亮条件和翻页功能。&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import React, { useState } from 'react';
function Pager({ totalPage, defaultCurrent, onChange }) {
  // 使用useState定义内部状态：当前页码current
  const [current, setPage] = useState(defaultCurrent);
  return (
    &amp;lt;ul className=&quot;x-pager&quot;&amp;gt;
      &amp;lt;li
        className={'number' + (current == 1 ? ' active' : '')}
        onClick={() =&amp;gt; {
          setPage(1);
          onChange(1);
        }}
      &amp;gt;1&amp;lt;/li&amp;gt;
      &amp;lt;li className=&quot;more left&quot;&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;li className=&quot;number&quot;&amp;gt;&amp;lt;/li&amp;gt;
      &amp;lt;li className=&quot;more right&quot;&amp;gt;&amp;lt;/li&amp;gt;
      { totalPage !== 1 &amp;amp;&amp;amp; &amp;lt;li
        className={'number' + (current == totalPage ? ' active' : '')}
        onClick={() =&amp;gt; {
        setPage(totalPage);
          onChange(totalPage);
        }}
      &amp;gt;{ totalPage }&amp;lt;/li&amp;gt; }
    &amp;lt;/ul&amp;gt;
  );
}
export default Pager;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;值得注意的是条件渲染的写法，React和Vue还是有点区别的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;React是直接用大括号{}包裹，然后像写JS一样写分支判断&lt;/li&gt;
&lt;li&gt;Vue在HTML元素中使用的是v-if指令进行分支判断&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;另外就是Vue中有标签class绑定的功能，而React没有类似的功能，需要通过在{}大括号中写三目运算符来判断高亮。&lt;/p&gt;
&lt;p&gt;至此Pager已经可以直接拿去Pagination中使用了，不过只能首页和尾页翻页，接下来继续增强Pager的功能。&lt;/p&gt;
&lt;h3&gt;6.3.3 第2步：增加左/右更多按钮的翻页功能&lt;/h3&gt;
&lt;p&gt;更多按钮显示的逻辑和Vue版本一样：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;只有大于7页，才有可能显示更多按钮；&lt;/li&gt;
&lt;li&gt;左右更多按钮会随着当前页码的不同而显示或隐藏，以第4页和倒数第4页为界；&lt;/li&gt;
&lt;li&gt;当页码大于第4页时，应该显示左边更多按钮；&lt;/li&gt;
&lt;li&gt;当页码小于倒数第4页，都应该显示右边更多按钮。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;左更多按钮：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
const centerSize = 5; // 中间按钮组的页码数
const jumpSize = 5; // 快捷翻页的页数
{
  totalPage &amp;gt; centerSize + 2 &amp;amp;&amp;amp; current &amp;gt;= centerSize
  &amp;amp;&amp;amp; &amp;lt;li className=&quot;more left&quot;
    onClick={() =&amp;gt; {
setPage(current - jumpSize); // 设置快捷翻页后的新页码
onChange(current - jumpSize); // 页码改变时的外部回调事件
    }}
  &amp;gt;&amp;lt;/li&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;右更多按钮：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
{
  totalPage &amp;gt; centerSize + 2 &amp;amp;&amp;amp; current &amp;lt;= totalPage - centerSize + 1
  &amp;amp;&amp;amp; &amp;lt;li className=&quot;more right&quot;
    onClick={() =&amp;gt; {
    setPage(current + jumpSize);
      onChange(current + jumpSize);
    }}
  &amp;gt;&amp;lt;/li&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;最后实现页码按钮组功能。&lt;/p&gt;
&lt;h3&gt;6.3.4 第3步：实现中间的页码按钮组&lt;/h3&gt;
&lt;p&gt;主要是需要计算好centerPages页码数组，计算逻辑和Vue的一样：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;如果总页码小于等于7，则centerPages是除首尾页之外的所有页码；&lt;/li&gt;
&lt;li&gt;如果总页码大于7，则centerPages是以current为中心，左右各加两页组成的页码数组。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先计算centerPages：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
// 计算中间页码数组
const centerPages = [];
let centerPage = current;
if (current &amp;gt; totalPage - 3) {
  centerPage = totalPage - 3;
}
if (current &amp;lt; 4) {
  centerPage = 4;
}
if (totalPage &amp;lt;= centerSize + 2) {
  for (let i = 2; i &amp;lt; totalPage; i++) {
    centerPages.push(i);
  }
} else {
  for (let i = centerPage - 2; i &amp;lt;= centerPage + 2; i++) {
    centerPages.push(i);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后将其显示出来：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
{
  centerPages.map((page, index) =&amp;gt; {
    return (
      &amp;lt;li
        key={index}
        className={'number' + (page == current ? ' active' : '')}
        onClick={() =&amp;gt; {
          setPage(page);
          onChange(page);
        }}
      &amp;gt;{ page }&amp;lt;/li&amp;gt;
    );
  })
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;列表渲染的方式需要注意⚠️：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;React依然使用的是大括号包裹，然后用JS的map方法进行迭代；&lt;/li&gt;
&lt;li&gt;Vue是在HTML标签中使用v-for指令进行列表渲染。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;由于Pager中的当前页码有可能通过外部改变（比如上一页/下一页按钮），因为在传入的defaultCurrent变化时，需要动态改变current，这需要借助另一个React Hook——useEffect——来实现，具体代码如下：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
// 外部传入的defaultCurrent变化时，需要重新设置current
useEffect(() =&amp;gt; {
  setPage(defaultCurrent);
});
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;另外需要注意的就是更多按钮快捷翻页可能会越界，需要加以显示，为此我们编写了一个limitPage方法：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;6.5&quot;&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
const limitPage = (page) =&amp;gt; {
  if (page &amp;lt; 1) return 1;
  if (page &amp;gt; totalPage) return totalPage;
  return page;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;在更多按钮的事件中使用：&lt;/p&gt;
&lt;p&gt;左更多按钮：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
{
  totalPage &amp;gt; centerSize + 2 &amp;amp;&amp;amp; current &amp;gt;= centerSize
  &amp;amp;&amp;amp; &amp;lt;li className=&quot;more left&quot;
    onClick={() =&amp;gt; {
    setPage(limitPage(current - jumpSize)); // 设置快捷翻页后的新页码
    onChange(limitPage(current - jumpSize)); // 页码改变时的外部回调事件
    }}
  &amp;gt;&amp;lt;/li&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;右更多按钮：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7&quot;&gt;
&lt;div readability=&quot;9&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
{
  totalPage &amp;gt; centerSize + 2 &amp;amp;&amp;amp; current &amp;lt;= totalPage - centerSize + 1
  &amp;amp;&amp;amp; &amp;lt;li className=&quot;more right&quot;
    onClick={() =&amp;gt; {
      setPage(limitPage(current + jumpSize));
      onChange(limitPage(current + jumpSize));
    }}
  &amp;gt;&amp;lt;/li&amp;gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;这样就完成了React版本的Pager分页器组件，除了细微语法上的差异外，大部分代码逻辑都是一样的。&lt;/p&gt;
&lt;p&gt;接下来即将介绍的Angular版本的Pager也是一样的，大部分逻辑都可以复用。&lt;/p&gt;
&lt;h2&gt;6.4 Angular版本&lt;/h2&gt;
&lt;p&gt;Angular实现Pager的思路和Vue/React也差不多，就是写法上的差异，同样按MVP的思路，分成以下3个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;第1步 实现首尾翻页&lt;/li&gt;
&lt;li&gt;第2步 实现快捷分页&lt;/li&gt;
&lt;li&gt;第3步 实现分页按钮组&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;先实现首/尾页翻页功能。&lt;/p&gt;
&lt;h3&gt;6.4.1 第1步：实现首/尾页翻页逻辑&lt;/h3&gt;
&lt;p&gt;先做模板，在pager.component.html中编写以下代码：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;9.5&quot;&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;ul class=&quot;x-pager&quot;&amp;gt;
  &amp;lt;li [ngClass]=&quot;{
      number: true,
      active: 1 == current
    }&quot;
    (click)=&quot;setPage($event, 1)&quot;
  &amp;gt;1&amp;lt;/li&amp;gt;
  &amp;lt;li class=&quot;more left&quot;&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li class=&quot;number&quot; &amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li class=&quot;more right&quot;&amp;gt;&amp;lt;/li&amp;gt;
  &amp;lt;li *ngIf=&quot;totalPage !== 1&quot; [ngClass]=&quot;{
      number: true,
      active: totalPage == current
    }&quot;
    (click)=&quot;setPage($event, totalPage)&quot;
  &amp;gt;{{ totalPage }}&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;然后在pager.component.ts中写具体逻辑：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;10.5&quot;&gt;
&lt;div readability=&quot;16&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
import { Component, Input, Output, EventEmitter } from &quot;@angular/core&quot;;
@Component({
  selector: 'x-pager',
  templateUrl: './pager.component.html',
  styleUrls: ['./pager.component.scss']
})
export class PagerComponent {
  @Input() totalPage: number;
  @Input() defaultCurrent: number;
  @Output() onChange = new EventEmitter();
  current = this.defaultCurrent;
  setPage($event, page) {
    this.current = page;
    this.onChange.emit(this.current);
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;6.4.2 第2步：实现左/右更多按钮的翻页功能&lt;/h3&gt;
&lt;p&gt;由于用于设置页码的方法setPage前面已经写好了，因此只需要在模板中新加左/右更多按钮即可：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;8&quot;&gt;
&lt;div readability=&quot;11&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;li
  class=&quot;more left&quot;
  *ngIf=&quot;totalPage &amp;gt; centerSize + 2 &amp;amp;&amp;amp; current &amp;gt;= centerSize&quot;
(click)=&quot;setPage($event, current - centerSize)&quot;
&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;li
  class=&quot;more right&quot;
  *ngIf=&quot;totalPage &amp;gt; centerSize + 2 &amp;amp;&amp;amp; current &amp;lt;= totalPage - centerSize + 1&quot;
(click)=&quot;setPage($event, current + centerSize)&quot;
&amp;gt;&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h3&gt;6.4.3 第3步：实现中间的页码按钮组&lt;/h3&gt;
&lt;p&gt;最后是实现页码按钮组，关键还是centerPages数组的计算，计算逻辑可以复用Vue/React的。具体实现如下：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
@Input()
get centerPages() {
  let centerPage = this.current;
  if (this.current &amp;gt; this.totalPage - 3) {
    centerPage = this.totalPage - 3;
  }
  if (this.current &amp;lt; 4) {
    centerPage = 4;
  }
  const centerArr = [];
  if (this.totalPage &amp;lt; this.centerSize + 2) {
    for (let i = 2; i &amp;lt; this.totalPage; i++) {
      centerArr.push(i);
    }
  } else {
    for (let i = centerPage - 2; i &amp;lt;= centerPage + 2; i++) {
      centerArr.push(i);
    }
  }
  return centerArr;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;类似Vue中的计算属性（computed）。&lt;/p&gt;
&lt;p&gt;然后是使用centerPages渲染页码按钮组：&lt;/p&gt;
&lt;div&gt;
&lt;div readability=&quot;7.5&quot;&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;pre class=&quot;juejin-editor-highlight&quot;&gt;
&amp;lt;li
  [ngClass]=&quot;{
number: true,
active: page == current
}&quot;
  *ngFor=&quot;let page of centerPages&quot;
  (click)=&quot;setPage($event, page)&quot;
&amp;gt;{{ page }}&amp;lt;/li&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;至此三大框架的Pager组件都已实现，因而Pagination组件也告一段落。&lt;/p&gt;
&lt;p&gt;最后做一个总结，大致对比下Vue/React/Angular三大框架开发组件的差别。&lt;/p&gt;

&lt;div&gt;
&lt;table&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;框架&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;从外向内通讯&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;从内向外通讯&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;编程范式&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;列表渲染&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;条件渲染&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;事件绑定&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;内部状态&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;插槽定义方式&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;计算属性&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;监听外部传入的参数变量&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p&gt;Vue&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;props&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;$emit()&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;响应式&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;v-for指令&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;v-if指令&lt;/p&gt;
&lt;/td&gt;
&lt;td readability=&quot;5&quot;&gt;
&lt;p&gt;v-bind:event（简写@event）&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;data&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&amp;lt;slot&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;computed&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;watch&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;React&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;props&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;props&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;函数组件&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;{}包裹map&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;{}包裹三目运算符&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;onEvent&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;useState&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;props.children&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;直接写&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;useEffect&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p&gt;Angular&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;@Input()&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;@Output()&lt;/p&gt;
&lt;p&gt;emit()&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;面向对象&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;*ngFor指令&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;*ngIf指令&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;(event)&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;直接写&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;&amp;lt;ng-content&amp;gt;&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;@Input() get&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p&gt;ngOnChanges&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;

&lt;p&gt;以上3大框架的Pagination组件源码地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/kagol/components&quot;&gt;https://github.com/kagol/components&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本文参考&lt;a href=&quot;https://github.com/DevCloudFE/ng-devui&quot;&gt;DevUI&lt;/a&gt;分页组件写成，该组件源码地址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/DevCloudFE/ng-devui/tree/master/devui/pagination&quot;&gt;https://github.com/DevCloudFE/ng-devui/tree/master/devui/pagination&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;欢迎大家关注&lt;a href=&quot;https://github.com/DevCloudFE/ng-devui&quot;&gt;DevUI组件库&lt;/a&gt;，给我们提意见和建议，也欢迎Star。&lt;/p&gt;


&lt;p&gt;我们是&lt;a href=&quot;http://devui.design/&quot;&gt;DevUI团队&lt;/a&gt;，欢迎来这里和我们一起打造优雅高效的人机设计/研发体系。招聘邮箱：muyang2@huawei.com。&lt;/p&gt;
&lt;p&gt;文/DevUI Kagol&lt;/p&gt;



&lt;/div&gt;</description>
<pubDate>Tue, 01 Dec 2020 14:50:00 +0000</pubDate>
<dc:creator>kagol</dc:creator>
<og:description>19世纪著名的印象派画家莫奈，喜欢对着同一处景物，分别画出对象在不同时间，不同光线下的色彩变化。 如果同一个组件，用不同的框架实现，会有什么不同呢？ 带着这个想法，我分别选用目前最火的Vue/Reac</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kagol/p/14071347.html</dc:identifier>
</item>
<item>
<title>InnoDB 中的缓冲池(Buffer Pool) - 萌新J</title>
<link>http://www.cnblogs.com/mengxinJ/p/14071262.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mengxinJ/p/14071262.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;span&gt;本文主要说明 InnoDB Buffer Pool 的内部执行原理，其生效的前提是使用到了索引，如果没有用到索引会进行全表扫描。&lt;/span&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2&gt;结构&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;在 InnoDB 存储引擎层维护着一个缓冲池，通过其可以避免对磁盘频繁的IO操作。下面是其内部结构的概要图（实际没有这么简单，本文只着重说一下它的“读”、“写”缓存）。其本质就是将磁盘上的数据页移到内存中，以此来减少对磁盘数据的直接IO。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202012/2012006-20201201094111800-1141275761.png&quot; alt=&quot;&quot; width=&quot;611&quot; height=&quot;337&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;可以看到内部含有一个小区域，叫做 Change Buffer，这个是用 InnoDB 的 &quot;写&quot;缓存，而外面的是 InnoDB 的 “读”缓存。&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;读缓存&lt;/h2&gt;
&lt;h3&gt;预读&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;MySQL 内部一般都会使用缓冲池，而如果多次语句操作的是相邻的记录，那么就会多次进行磁盘读取，导致速度降低，所以 MySQL 一般在读取数据时都是采用预读方式，读取指定数据周围的多条数据。而在 InnoDB 引擎中的数据是以页为单位进行存储的，并且提出了“数据页”概念。数据页的结构如下，大小默认为 16K，关于数据页这里就不过多阐述，感兴趣可以查看原&lt;a href=&quot;https://blog.csdn.net/mashaokang1314/article/details/109716569&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;。&lt;span&gt;对硬盘上的数据读取最小单位就是数据页。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202012/2012006-20201201153225484-1754467780.png&quot; alt=&quot;&quot; width=&quot;636&quot; height=&quot;220&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202012/2012006-20201201170533221-1258770863.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而在数据页上面，还分为区(Extent)、段(Segment)、表空间(Tablespace)，它们之间的包含关系如下图。具体可以查看原&lt;a href=&quot;https://blog.csdn.net/fu_zhongyuan/article/details/90244503&quot; target=&quot;_blank&quot;&gt;博客&lt;/a&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202012/2012006-20201201171135836-1421832495.png&quot; alt=&quot;&quot; width=&quot;536&quot; height=&quot;365&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; InnoDB 引擎在预读时， 有两种预读算法。线性预读和随机预读。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;1、线性预读（innodb_read_ahead_threshold）&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;选择是否预读下一个 Extent 的数据。有一个重要的参数 innodb_read_ahead_threshold，如果当前 Extent 中连续读取的数据页超过规定值，就会将下一个 Extent 的数据也读到缓冲池中。innodb_read_ahead_threshold 的范围是 0-64（因为一个 Extent 也就64页）。&lt;/span&gt;&lt;/p&gt;

&lt;h4&gt;2、随机预读（innodb_random_read_ahead）&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;用来设置是否将当前 Extent 的剩余页也预读到缓冲池中，由于这种预读性能不稳定，所以MySQL 5.5开始默认关闭。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;缓冲池的LRU算法&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;InnoDB 的缓冲池数据的存储算法是改进版的 LRU 算法，以此来避免了传统 LRU 算法的两个问题，预读失效和缓冲池污染。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;LRU 算法简单来说，如果用链表来实现，将最近命中（加载）的数据页移在头部，未使用的向后偏移，直至移除链表。这样的淘汰算法就叫做 LRU 算法。但是其会含有前面说得两个问题。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;1、预读失效&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;在磁盘上读取数据时，可能会因为操作不当导致多个用不到的数据页加载到缓冲池。从而导致之前经常被使用的数据页缓存被无用的数据页挤到尾部，甚至被移出缓存，那么就会降低性能。而 InnoDB 的解决方案是将缓冲池分为两部分，新生代和老年代，比例默认为5:3，分别存储常用的数据页以及不常用的数据页，新生代位于头部，新生代位于尾部，这两部分都有头部和尾部。当从磁盘的数据页移入缓冲池中时，首先是放入老年代的头部，然后进行筛选，使用到的数据页会移入新生代的头部，未使用的数据页会随着时间流逝而慢慢移入老年代的尾部，直至淘汰。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202012/2012006-20201201104948822-294064164.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2012006/202012/2012006-20201201104918812-491150639.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;2、缓冲池污染。&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;在处理数据页时，如果需要对大量数据页进行筛选（但是没有用到），那么还是会使大量的热点数据页被挤出。如 select * from student where name like '张%'；name字段包含索引，那么在执行时虽然会先加载到老年代的头部，但是因为每条数据都需要筛选，所以都会移入新生代头部，导致新生代热点数据页被挤到老年代甚至移除。InnoDB 为了解决这个问题，使用了 &quot;老年代停留时间窗口&quot; 机制，这个机制是设置一个时间，如果在老年代的数据页被调用后还需要去检查它在老年代的停留时间是否达到了这个规定时间，达到了才能移入新生代头部，否则只会移到老年代头部。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;写缓存（Change Buffer）&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;写缓存(Change Buffer)在5.5之前叫做 插入缓存(insert  Buffer)，因为只支持插入的缓存，在随后版本又添加了 update、delete，所以改名 change Buffer。因为直接对磁盘进行IO操作会比较耗时，如果我们的程序在高并发的场景，同时某段时间写操作非常多，那么如果直接更新到磁盘上数据库的压力就会非常大，甚至崩溃。为了避免这种情况，可以错开高峰期，让数据在系统空闲时再更新到磁盘，那么该如何实现，Change Buffer就起到这样的作用。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;执行&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;在更新语句进来时，首先会判断数据页缓存中有没有对应的数据，如果有直接更新对应的缓存数据，否则将其记录在 Change Buffer 中。随后(不管前面是哪种情况都会执行)再将这条sql依次写入 redo log、bin log(Server 层的日志，所有执行引擎都可以用，而 redo log 是InnoDB内部维护的，bin log 一般用于主从复制)。&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;redo log落盘的时机&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;将日志中的sql更新到硬盘上的操作叫做“落盘(merge)”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、mysql系统后台会定期落盘&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、查询 redo log中sql操作过的数据时需要先落盘&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、mysql 正常关闭时&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;Change Buffer 适用场景&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;1、更新后立刻需要读取该数据场景少。因为读取更新过的数据需要先落盘，那么 Change Buffer 存在的意义就没有了，同时还增加了redo log 写入的成本。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、非唯一索引，如果使用的是唯一索引进行查询，那么操作的数据需要进行唯一性检查，所以需要将相应数据页先加载到缓冲池中，然后再判断，更新，过程中不会用到 Change Buffer。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;写入redo log不也是磁盘数据IO么？为什么就比直接更新到磁盘上效率高？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;使用 redo log 只是将操作存储进去，而更新到磁盘数据则是需要先读操作查找 B+ 树，找到数据后再进行写操作。&lt;/span&gt;&lt;/p&gt;


&lt;h2&gt;相关参数&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Buffer Pool :&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、innodb_buffer_pool_size：缓冲池大小，在内存足够的条件下，越大越好。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;2、innodb_old_blocks_pct：老年代占整个LRU链长度的比例，默认是37，即整个LRU的新生代和老年代长度比例是63：37。（如果配置是100就变成普通的LRU了）&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;3、innodb_old_blocks_time：老年代停留时间窗口，单位是毫秒，默认是1000，即同时满足“被访问”与“在老年代停留时间超过1秒”两个条件，才会被插入到新生代头部。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;strong&gt;Change Buffer：&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;1、innodb_change_buffer_max_size：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　配置写缓冲的大小，占整个缓冲池的比例，默认值是25%，最大值是50%。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　画外音：写多读少的业务，才需要调大这个值，读多写少的业务，25%其实也多了。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;2、innodb_change_buffering：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt;&lt;span&gt;　　介绍：配置哪些写操作启用写缓冲，可以设置成all/none/inserts/deletes等。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p align=&quot;justify&quot;&gt; &lt;/p&gt;
&lt;p&gt;参考博客：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/mashaokang1314/article/details/109716569&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/mashaokang1314/article/details/109716569&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/fu_zhongyuan/article/details/90244503&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/fu_zhongyuan/article/details/90244503&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/geaozhang/p/7397699.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/geaozhang/p/7397699.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/virgosnail/p/10454150.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/virgosnail/p/10454150.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 Dec 2020 14:47:00 +0000</pubDate>
<dc:creator>萌新J</dc:creator>
<og:description>本文主要说明 InnoDB Buffer Pool&amp;#160;的内部执行原理，其生效的前提是使用到了索引，如果没有用到索引会进行全表扫描。 结构 在 InnoDB&amp;#160;存储引擎层维护着一个缓冲池</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mengxinJ/p/14071262.html</dc:identifier>
</item>
<item>
<title>SpringCloud 源码系列（1）—— 注册中心 Eureka（上） - bojiangzhou</title>
<link>http://www.cnblogs.com/chiangchou/p/eureka-1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chiangchou/p/eureka-1.html</guid>
<description>&lt;p&gt;eureka 源码研究系列第一篇，eureka 架构、源码环境、eureka-server 启动流程分析、eureka-client 启动流程分析&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;345.9996517396&quot;&gt;
&lt;p&gt;Eureka 是 Netflix 公司开源的一个服务注册与发现的组件，和其他 Netflix 公司的服务组件（例如负载均衡、熔断器、网关等）一起，被 Spring Cloud 整合为 Spring Cloud Netflix 模块。不过 Eureka 2.0 开始闭源了，但 1.x 还在继续维护中，可以继续使用。这篇文章就来深入学习下 Eureka 注册中心，便于我们更好的使用和调优注册中心。&lt;/p&gt;
&lt;p&gt;关于版本：本文章使用的 Spring cloud 版本为 Hoxton.SR8，Spring boot 版本为 2.3.3.RELEASE，依赖的 eureka 版本则为 1.9.25。&lt;/p&gt;
&lt;h2&gt;一、Eureka 初体验&lt;/h2&gt;
&lt;p&gt;Eureka 分为 Eureka Server 和 Eureka Client，Eureka Server 为 Eureka 注册中心，Eureka Client 为 Eureka 客户端。这节先通过demo把注册中心的架子搭起来，看看注册中心的基础架构。&lt;/p&gt;
&lt;h3&gt;1、Eureka Server&lt;/h3&gt;
&lt;p&gt;① 创建注册中心服务：sunny-register&lt;/p&gt;
&lt;p&gt;首先创建一个 maven 工程，服务名称为 sunny-register，并在 pom.xml 中引入注册中心服务端的依赖。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-server&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependencies&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 添加配置文件&lt;/p&gt;
&lt;p&gt;在 resources 下添加 application.yml 配置文件，并添加注册中心相关配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;server:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   port: 8000
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  application:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     name: sunny-&lt;span&gt;register
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;eureka:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  instance:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    hostname: dev.lyyzoo.com
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;  client:
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    # 是否向注册中心注册自己
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     register-with-eureka: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    # 是否检索服务
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     fetch-registry: &lt;span&gt;false&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     service-&lt;span&gt;url:
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;       defaultZone: http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;${eureka.instance.hostname}:${server.port}/eureka/&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 添加启动类&lt;/p&gt;
&lt;p&gt;添加启动类，并在启动类上加上 @EnableEurekaServer 注解，启用注册中心。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.lyyzoo.sunny.register;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.SpringApplication;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.boot.autoconfigure.SpringBootApplication;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;@EnableEurekaServer
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RegisterApplication {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         SpringApplication.run(RegisterApplication.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ 启动注册中心&lt;/p&gt;
&lt;p&gt;启动注册中心后，访问 http://dev.lyyzoo.com:8000/，就可以看到注册中心的页面了，现在还没有实例注册上来。（dev.lyyzoo.com 在本地 hosts 文件中映射到 127.0.0.1）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202011/856154-20201118072627451-582207594.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、Eureka Client&lt;/h3&gt;
&lt;p&gt;创建两个 demo 服务，demo-producer 服务作为生产者提供一个接口，demo-consumer 服务作为消费者去调用 demo-producer 的接口。&lt;/p&gt;
&lt;p&gt;① 创建客户端服务：demo-producer&lt;/p&gt;
&lt;p&gt;创建maven工程，服务名称为 demo-producer，在 pom.xml 中引入注册中心客户端的依赖，并添加了 web 的依赖。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.cloud&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-cloud-starter-netflix-eureka-client&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.boot&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;spring-boot-starter-web&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② 添加配置文件&lt;/p&gt;
&lt;p&gt;在 resouces 下添加 application.yml 配置文件，添加注册中心客户端相关的配置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;server:
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;   port: 8010
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;spring:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;  application:
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     name: demo-&lt;span&gt;producer
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;eureka:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;  client:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    serviceUrl:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;       defaultZone: ${EUREKA_DEFAULT_ZONE:http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;dev.lyyzoo.com:8000/eureka}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;③ 添加启动类&lt;/p&gt;
&lt;p&gt;添加启动类，并在启动类上加上 @EnableEurekaClient 注解，启用客户端。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;@EnableEurekaClient
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ProducerApplication {
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 
&lt;span&gt;5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         SpringApplication.run(ProducerApplication.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;④ 添加一个 rest 接口&lt;/p&gt;
&lt;p&gt;添加一个接口用于测试调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoController {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger =&lt;span&gt; LoggerFactory.getLogger(getClass());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     @GetMapping(&quot;/v1/uuid&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;String&amp;gt;&lt;span&gt; getUUID() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         String uuid =&lt;span&gt; UUID.randomUUID().toString();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         logger.info(&quot;generate uuid: {}&quot;&lt;span&gt;, uuid);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResponseEntity.ok(uuid);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑤  创建客户端服务：demo-consumer&lt;/p&gt;
&lt;p&gt;类似的方式，再创建消费者服务：demo-producer，这个服务中添加一个消费者接口，通过 RestTemplate 负载均衡的方式来调用 demo-producer 的接口。&lt;/p&gt;
&lt;p&gt;因此需要先配置一个带有负载均衡的 RestTemplate：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@EnableEurekaClient
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;@SpringBootApplication
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ConsumerApplication {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Bean
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @LoadBalanced
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate() {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RestTemplate();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         SpringApplication.run(ConsumerApplication.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;, args);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加消费者接口，注意这里 url 是写的服务名称，并不是具体的 ip 地址或端口，在微服务场景下，服务间调用也不可能写死某个具体的地址。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@RestController
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DemoController {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger logger =&lt;span&gt; LoggerFactory.getLogger(getClass());
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    @Autowired
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; RestTemplate restTemplate;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     @GetMapping(&quot;/v1/id&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; ResponseEntity&amp;lt;String&amp;gt;&lt;span&gt; getId() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         ResponseEntity&amp;lt;String&amp;gt; result = restTemplate.getForEntity(&quot;http://&lt;span&gt;demo-producer&lt;/span&gt;/v1/uuid&quot;, String.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         String uuid =&lt;span&gt; result.getBody();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         logger.info(&quot;request id: {}&quot;&lt;span&gt;, uuid);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ResponseEntity.ok(uuid);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;⑥ 启动注册中心客户端&lt;/p&gt;
&lt;p&gt;以两个不同的端口启动 demo-producer，可以通过环境变量的方式制定端口。然后再启动 demo-consumer。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202011/856154-20201118075809397-1396592048.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;启动完成之后，就可以在注册中心看到注册上来的两个 demo-producer 实例和一个 demo-consumer 实例，并且状态都为 UP。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202011/856154-20201125014011364-617501770.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;⑦ 测试接口&lt;/p&gt;
&lt;p&gt;调用消费者服务的接口，多次访问 http://dev.lyyzoo.com:8020/v1/id 接口，会发现生产者服务 demo-consumer 两个实例的控制台会交替的输出日志信息。这就说明消费者客户端通过服务名称访问到生产者了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202011/856154-20201118080457526-818121280.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3、Eureka 基础架构&lt;/h3&gt;
&lt;p&gt;通过前面的体验，可以发现，服务间调用只需知道某个服务的名称就可以调用这个服务的api了，而不需要指定具体的ip地址和端口，那这是怎么做到的呢？&lt;/p&gt;
&lt;p&gt;不难看出，Eureka 的基础架构包含三种角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;服务注册中心：Eureka Server，提供服务注册和发现的功能&lt;/li&gt;
&lt;li&gt;服务提供者：Eureka Client，提供服务（本身也可以作为消费者）&lt;/li&gt;
&lt;li&gt;服务消费者：Eureka Client，消费服务（本身也可以作为提供者）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202011/856154-20201125014248831-727899614.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先需要一个服务注册中心，客户端则向注册中心注册，将自己的信息（比如服务名、服务的 IP 地址和端口信息等）提交给注册中心。客户端向注册中心获取一份服务注册列表的信息，该列表包含了所有向注册中心注册的服务信息。获取服务注册列表信息之后，客户端服务就可以根据服务名找到服务的所有实例，然后通过负载均衡选择其中一个实例，根据其 IP 地址和端口信息，就可以调用服务的API接口了。&lt;/p&gt;
&lt;p&gt;这就是注册中心最基础的架构和功能了，提供服务注册和发现，为各个客户端提供服务注册列表信息。但为了完成这些工作，Eureka 有很多的机制来实现以及保证其高可用，如服务注册、服务续约、获取服务注册列表、服务下线、服务剔除等等。Eureka 也提供了很多参数让我们可以根据实际的场景来优化它的一些功能和配置，比如维持心跳的时间、拉取注册表的间隔时间、自我保护机制等等。下面我们就从 eureka 的源码层面来分析下 eureka 的这些功能以及参数，理解其原理，学习它的一些设计。&lt;/p&gt;
&lt;h2&gt;二、Eureka 源码准备&lt;/h2&gt;
&lt;p&gt;虽然我们在 pom.xml 中依赖的是 spring-cloud-starter-netflix-eureka-server 和 spring-cloud-starter-netflix-eureka-client，但 spring-cloud-starter-netflix 只是对 eureka 做了封装，使得其可以通过 springboot 的方式来启动和初始化，其底层其实是 netflix 的 eureka-core、eureka-client 等。所以我们先分析 netflix eureka 的源码，最后再看看 spring-cloud-starter-netflix 的源码。&lt;/p&gt;
&lt;h3&gt;1、源码环境准备&lt;/h3&gt;
&lt;p&gt;① 下载源码&lt;/p&gt;
&lt;p&gt;Netflix Eureka：&lt;a href=&quot;https://github.com/Netflix/eureka&quot; target=&quot;_blank&quot;&gt;https://github.com/Netflix/eureka&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Spring Cloud Netflix：&lt;a href=&quot;https://github.com/spring-cloud/spring-cloud-netflix&quot; target=&quot;_blank&quot;&gt;https://github.com/spring-cloud/spring-cloud-netflix&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;克隆 eureka 的源码到本地：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/Netflix/eureka.git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于我们依赖的是 1.9.25 版本，将代码克隆到本地后，将其切换到 1.9.25：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
$ git checkout -b &lt;span&gt;1.9&lt;/span&gt;.&lt;span&gt;25&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后到 eureka 根目录下执行构建的命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
$ ./gradlew clean build -x test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;② IDEA 打开源码&lt;/p&gt;
&lt;p&gt;由于 eureka 使用 gradle 管理依赖，所以本地需要先安装 gradle，之后 IDEA 中也需要安装 gradle 的插件，跟 maven 都是类似的，安装教程可自行百度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202011/856154-20201119192439001-1884044880.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、Eureka 工程结构&lt;/h3&gt;
&lt;p&gt;Eureka 主要包含如下模块：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;eureka-client：eureka 客户端&lt;/li&gt;
&lt;li&gt;eureka-core：eureka 服务端，注册中心的核心功能&lt;/li&gt;
&lt;li&gt;eureka-resources：基于jsp的eureka控制台，可以查看注册了哪些服务实例&lt;/li&gt;
&lt;li&gt;eureka-server：注册中心，集成了 eureka-client、eureka-core、eureka-resources，因为依赖了 eureka-client，因此 eureka-server 也是一个客户端，在 eureka server 集群模式下，eureka-server 也会作为客户端注册到其它注册中心上&lt;/li&gt;
&lt;li&gt;eureka-examples：eureka 例子&lt;/li&gt;
&lt;li&gt;eureka-test-utils：eureka 单元测试工具&lt;/li&gt;
&lt;li&gt;eureka-core|client-jersey2：对 jersey 框架的封装，jersey 类似于 spring mvc，支持 http restful 请求，eureka-client 和 eureka-server 之间的通信就是基于 jersey 框架来的&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;三、Eureka Server 启动初始化&lt;/h2&gt;
&lt;p&gt;首先要看的是 eureka-server，注册中心启起来之后，客户端才能来注册服务和发现服务。&lt;/p&gt;
&lt;h3&gt;1、eureka-server 模块&lt;/h3&gt;
&lt;p&gt;① eureka-server 目录&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;resources 目录中主要是 eureka client 和 server 的配置文件&lt;/li&gt;
&lt;li&gt;webapp 下有一个 web.xml 配置文件，这里面就配置了启动初始化的入口，从这也可以看出，eureka-server 会被打包成 war 包来运行&lt;/li&gt;
&lt;li&gt;test 下有个单元测试类 EurekaClientServerRestIntegrationTest，这里面就包含了服务注册、续约、下线等单元测试，我们就可以运行这些单元测试来调试代码&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202011/856154-20201119211318975-758785170.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;② web.xml&lt;/p&gt;
&lt;p&gt;web.xml 的内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_c3a639ac-cbb8-4e41-a5e0-56e939be8b18&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_c3a639ac-cbb8-4e41-a5e0-56e939be8b18&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_c3a639ac-cbb8-4e41-a5e0-56e939be8b18&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;60&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;&amp;lt;?&lt;/span&gt;&lt;span&gt;xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;&lt;/span&gt;&lt;span&gt;?&amp;gt;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;web-app &lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;=&quot;2.5&quot;&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;         xmlns&lt;/span&gt;&lt;span&gt;=&quot;http://java.sun.com/xml/ns/javaee&quot;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;         xmlns:xsi&lt;/span&gt;&lt;span&gt;=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;         xsi:schemaLocation&lt;/span&gt;&lt;span&gt;=&quot;http://java.sun.com/xml/ns/javaee
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; eureka 启动初始化类 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;listener-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.netflix.eureka.EurekaBootStrap&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;listener-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;listener&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 状态过滤器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;statusFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.netflix.eureka.StatusFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 认证过滤器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;requestAuthFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.netflix.eureka.ServerRequestAuthFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 限流过滤器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;rateLimitingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.netflix.eureka.RateLimitingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;gzipEncodingEnforcingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.netflix.eureka.GzipEncodingEnforcingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; jersey 容器 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jersey&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sun.jersey.spi.container.servlet.ServletContainer&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sun.jersey.config.property.WebPageContentRegex&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/(flex|images|js|css|jsp)/.*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sun.jersey.config.property.packages&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sun.jersey;com.netflix&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; GZIP content encoding/decoding &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sun.jersey.spi.container.ContainerRequestFilters&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sun.jersey.api.container.filter.GZIPContentEncodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;53&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sun.jersey.spi.container.ContainerResponseFilters&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;       &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.sun.jersey.api.container.filter.GZIPContentEncodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;     &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;statusFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;requestAuthFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;65&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;67&lt;/span&gt; 
&lt;span&gt;68&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Uncomment this to enable rate limiter filter.
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;  &amp;lt;filter-mapping&amp;gt;
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    &amp;lt;filter-name&amp;gt;rateLimitingFilter&amp;lt;/filter-name&amp;gt;
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; &lt;span&gt;    &amp;lt;url-pattern&amp;gt;/v2/apps&amp;lt;/url-pattern&amp;gt;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt; &lt;span&gt;    &amp;lt;url-pattern&amp;gt;/v2/apps/*&amp;lt;/url-pattern&amp;gt;
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt; &lt;span&gt;  &amp;lt;/filter-mapping&amp;gt;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;   &lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;gzipEncodingEnforcingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;78&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/v2/apps&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;79&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/v2/apps/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;80&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt; 
&lt;span&gt;82&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jersey&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;84&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;85&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;86&lt;/span&gt; 
&lt;span&gt;87&lt;/span&gt;   &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 欢迎页 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;span&gt;88&lt;/span&gt;   &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;welcome-file-list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;89&lt;/span&gt;     &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;welcome-file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;jsp/status.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;welcome-file&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;90&lt;/span&gt;   &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;welcome-file-list&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;91&lt;/span&gt; 
&lt;span&gt;92&lt;/span&gt; &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;web-app&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;web.xml 中可以得知如下信息：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;eureka server 启动时首先通过 com.netflix.eureka.EurekaBootStrap 类来进行启动初始化相关的工作&lt;/li&gt;
&lt;li&gt;配置了 StatusFilter（server 状态过滤器）、ServerRequestAuthFilter（认证过滤器）、RateLimitingFilter（限流过滤器） 等过滤器，但 RateLimitingFilter 默认没有启用&lt;/li&gt;
&lt;li&gt;配置了 jersey 的 servlet 容器，其实就跟 springframework 的 DispatcherServlet 是类似的，用来拦截处理 http restful 请求，这块我们不用过于关注&lt;/li&gt;
&lt;li&gt;最后还配置了 eureka server 的欢迎页为 jsp/status.jsp 页面，这个页面在 eureka-resources 模块下，也就是前面看到的 eureka 控制台页面&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;③ 单元测试类 EurekaClientServerRestIntegrationTest&lt;/p&gt;
&lt;p&gt;首先看 setUp 方法，每个测试用例运行之前都会先运行 setUp 方法来初始化运行环境。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@BeforeClass
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setUp() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化 eureka 配置&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    injectEurekaConfiguration();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动 eureka server，会找 build/libs 目录下的 eureka-server.*.war 包来运行
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这一步启动时，就会加载 web.xm 配置文件，然后进入 EurekaBootStrap 初始化类&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    startServer();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eureka server 配置&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    createEurekaServerConfig();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; 
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建 jersey 客户端，使用 jersey 客户端来调用资源&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     httpClientFactory =&lt;span&gt; JerseyEurekaHttpClientFactory.newBuilder()
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             .withClientName(&quot;testEurekaClient&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             .withConnectionTimeout(1000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             .withReadTimeout(1000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             .withMaxConnectionsPerHost(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             .withMaxTotalConnections(1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             .withConnectionIdleTimeout(1000&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            .build();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     jerseyEurekaClient = httpClientFactory.newClient(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultEndpoint(eurekaServiceUrl));
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; 
&lt;span&gt;23&lt;/span&gt;     ServerCodecs serverCodecs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultServerCodecs(eurekaServerConfig);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     jerseyReplicationClient =&lt;span&gt; JerseyReplicationClient.createReplicationClient(
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            eurekaServerConfig,
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            serverCodecs,
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            eurekaServiceUrl
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    );
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个类提供了如下的一些测试用例，我们可以运行这些测试用例来进行调试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202011/856154-20201120081129845-2135298798.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2、EurekaBootStrap 初始化&lt;/h3&gt;
&lt;p&gt;EurekaBootStrap 是监听器的入口，实现了 ServletContextListener 接口，主要完成了 eureka server 的启动初始化。&lt;/p&gt;
&lt;p&gt;从 contextInitialized 方法进去，整体上来说，分为 eureka 环境初始化和 eureka server 上下文初始化。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; contextInitialized(ServletContextEvent event) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eureka 环境初始化&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        initEurekaEnvironment();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eureka server 上下文初始化&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        initEurekaServerContext();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;         ServletContext sc =&lt;span&gt; event.getServletContext();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         sc.setAttribute(EurekaServerContext.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;.getName(), serverContext);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         logger.error(&quot;Cannot bootstrap eureka server :&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;Cannot bootstrap eureka server :&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;① eureka环境初始化&lt;/p&gt;
&lt;p&gt;initEurekaEnvironment 方法内主要是设置数据中心和运行环境参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;archaius.deployment.datacenter = default&lt;/li&gt;
&lt;li&gt;archaius.deployment.environment = test&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;② eureka server 上下文初始化&lt;/p&gt;
&lt;p&gt;initEurekaServerContext 上下文初始化则包含了很多阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;构造 eureka 注册中心配置：EurekaServerConfig&lt;/li&gt;
&lt;li&gt;构造 eureka 实例配置：EurekaInstanceConfig&lt;/li&gt;
&lt;li&gt;构造实例信息：InstanceInfo&lt;/li&gt;
&lt;li&gt;构造实例管理器：ApplicationInfoManager &lt;/li&gt;
&lt;li&gt;构造 eureka 客户端配置：EurekaClientConfig&lt;/li&gt;
&lt;li&gt;创建 eureka 客户端：EurekaClient（DiscoveryClient）&lt;/li&gt;
&lt;li&gt;创建注册表（可以感知eureka集群的注册表）：PeerAwareInstanceRegistry&lt;/li&gt;
&lt;li&gt;创建集群：PeerEurekaNodes&lt;/li&gt;
&lt;li&gt;将信息封装到eureka上下文：EurekaServerContext&lt;/li&gt;
&lt;li&gt;将eureka上下文放到一个全局容器中：EurekaServerContextHolder&lt;/li&gt;
&lt;li&gt;初始化eureka上下文&lt;/li&gt;
&lt;li&gt;同步eureka server的注册表&lt;/li&gt;
&lt;li&gt;开启追踪&lt;/li&gt;
&lt;li&gt;注册监控统计&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; initEurekaServerContext() &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1、eureka 注册中心配置&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     EurekaServerConfig eurekaServerConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultEurekaServerConfig();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; For backward compatibility&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     JsonXStream.getInstance().registerConverter(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     XmlXStream.getInstance().registerConverter(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; V1AwareInstanceInfoConverter(), XStream.PRIORITY_VERY_HIGH);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     logger.info(&quot;Initializing the eureka client...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    logger.info(eurekaServerConfig.getJsonCodecName());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     ServerCodecs serverCodecs = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultServerCodecs(eurekaServerConfig);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;     ApplicationInfoManager applicationInfoManager = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (eurekaClient == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 2、eureka 实例配置&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         EurekaInstanceConfig instanceConfig =&lt;span&gt; isCloud(ConfigurationManager.getDeploymentContext())
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 ? &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CloudInstanceConfig()
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 : &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyDataCenterInstanceConfig();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 3、构造 InstanceInfo 实例信息
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 4、构造 ApplicationInfoManager 应用管理器&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         applicationInfoManager = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApplicationInfoManager(
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 instanceConfig, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EurekaConfigBasedInstanceInfoProvider(instanceConfig).get());
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 5、eureka 客户端配置&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;         EurekaClientConfig eurekaClientConfig = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultEurekaClientConfig();
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 6、构造 EurekaClient，DiscoveryClient 封装了客户端相关的操作&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;         eurekaClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DiscoveryClient(applicationInfoManager, eurekaClientConfig);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         applicationInfoManager =&lt;span&gt; eurekaClient.getApplicationInfoManager();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    PeerAwareInstanceRegistry registry;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isAws(applicationInfoManager.getInfo())) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         registry = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AwsInstanceRegistry(
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                eurekaServerConfig,
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                eurekaClient.getEurekaClientConfig(),
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                serverCodecs,
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                eurekaClient
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         awsBinder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AwsBinderDelegate(eurekaServerConfig, eurekaClient.getEurekaClientConfig(), registry, applicationInfoManager);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        awsBinder.start();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 7、构造感知eureka集群的注册表&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;         registry = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PeerAwareInstanceRegistryImpl(
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                eurekaServerConfig,
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                eurekaClient.getEurekaClientConfig(),
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                serverCodecs,
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                eurekaClient
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; 
&lt;span&gt;54&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 8、构造eureka-server集群信息&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt;     PeerEurekaNodes peerEurekaNodes =&lt;span&gt; getPeerEurekaNodes(
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;            registry,
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;            eurekaServerConfig,
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            eurekaClient.getEurekaClientConfig(),
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            serverCodecs,
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt; &lt;span&gt;            applicationInfoManager
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt; &lt;span&gt;    );
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 9、基于前面构造的对象创建 EurekaServerContext&lt;/span&gt;
&lt;span&gt;64&lt;/span&gt;     serverContext = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultEurekaServerContext(
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt; &lt;span&gt;            eurekaServerConfig,
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;            serverCodecs,
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt; &lt;span&gt;            registry,
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            peerEurekaNodes,
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;            applicationInfoManager
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;    );
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt; 
&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将 serverContext 放到 EurekaServerContextHolder 上下文中，
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这样其它地方都可以通过 EurekaServerContextHolder 拿到 EurekaServerContext&lt;/span&gt;
&lt;span&gt;74&lt;/span&gt; &lt;span&gt;    EurekaServerContextHolder.initialize(serverContext);
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt; 
&lt;span&gt;76&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 10、初始化eureka-server上下文&lt;/span&gt;
&lt;span&gt;77&lt;/span&gt; &lt;span&gt;    serverContext.initialize();
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     logger.info(&quot;Initialized server context&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; 
&lt;span&gt;80&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 11、从相邻的eureka-server同步注册表&lt;/span&gt;
&lt;span&gt;81&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; registryCount =&lt;span&gt; registry.syncUp();
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;/12、启动注册表，启动一些定时任务&lt;/span&gt;
&lt;span&gt;83&lt;/span&gt; &lt;span&gt;    registry.openForTraffic(applicationInfoManager, registryCount);
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; 
&lt;span&gt;85&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;/13、注册监控统计&lt;/span&gt;
&lt;span&gt;86&lt;/span&gt; &lt;span&gt;    EurekaMonitors.registerAllStats();
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、面向接口的配置读取&lt;/h3&gt;
&lt;p&gt;初始化中有三个配置接口，EurekaServerConfig、EurekaInstanceConfig、EurekaClientConfig，分别对应了注册中心、eureka实例、eureka客户端的配置获取。&lt;/p&gt;
&lt;p&gt;从它们默认实现类的构造方法进去可以看到，EurekaServerConfig 是读取的 eureka-server.properties 配置文件，命名前缀是 eureka.server；EurekaInstanceConfig、EurekaClientConfig 是读取的 eureka-client.properties 配置文件，命名前缀分别是 eureka.instance、eureka.client。&lt;/p&gt;
&lt;p&gt;这里可以看到，eureka 在代码中获取配置的方式是通过接口方法的形式来获取的，在其默认的实现类里通过硬编码的方式定义了配置的编码以及默认值。这种基于接口的配置读取方式是可以借鉴的，这种方式读取配置更易于维护，不用维护一堆常量，如果配置编码变了只需更改实现类即可。&lt;/p&gt;
&lt;p&gt;例如下面的配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getExpectedClientRenewalIntervalSeconds() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; configured =&lt;span&gt; configInstance.getIntProperty(
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             namespace + &quot;expectedClientRenewalIntervalSeconds&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             30&lt;span&gt;).get();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; configured &amp;gt; 0 ? configured : 30&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;double&lt;/span&gt;&lt;span&gt; getRenewalPercentThreshold() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; configInstance.getDoubleProperty(
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             namespace + &quot;renewalPercentThreshold&quot;, 0.85&lt;span&gt;).get();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; shouldEnableReplicatedRequestCompression() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; configInstance.getBooleanProperty(
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             namespace + &quot;enableReplicatedRequestCompression&quot;, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;).get();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4、基于建造者模式构造服务实例&lt;/h3&gt;
&lt;p&gt;看 new EurekaConfigBasedInstanceInfoProvider(instanceConfig).get() 这段代码，在 get 方法中完成了服务实例信息的构造。它这里主要用到了建造者设计模式来构建 LeaseInfo 和 InstanceInfo，以 InstanceInfo 为例，它的内部有一个静态的 Builder 类，通过 newBuilder() 方法创建了 InstanceInfo 对象，然后可以调用 Builder 的属性设置方法来设置属性，在设置这些属性的时候，会做一些关联性的校验，在设置完成后，就调用 build() 方法返回对象，也可以在 build 方法中再做一些最终的校验。建造者模式就很适合用于构建这种复杂的对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_8c794bd7-8131-4d93-8e83-6ffc2a7e80b1&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_8c794bd7-8131-4d93-8e83-6ffc2a7e80b1&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_8c794bd7-8131-4d93-8e83-6ffc2a7e80b1&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;73&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;synchronized&lt;/span&gt;&lt;span&gt; InstanceInfo get() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (instanceInfo == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 续约信息：主要有续约间隔时间（默认30秒）和续约过期时间（默认90秒）&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         LeaseInfo.Builder leaseInfoBuilder =&lt;span&gt; LeaseInfo.Builder.newBuilder()
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                .setRenewalIntervalInSecs(config.getLeaseRenewalIntervalInSeconds())
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;                .setDurationInSecs(config.getLeaseExpirationDurationInSeconds());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (vipAddressResolver == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             vipAddressResolver = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Archaius1VipAddressResolver();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基于建造者模式来创建 InstanceInfo&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         InstanceInfo.Builder builder =&lt;span&gt; InstanceInfo.Builder.newBuilder(vipAddressResolver);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; set the appropriate id for the InstanceInfo, falling back to datacenter Id if applicable, else hostname&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         String instanceId =&lt;span&gt; config.getInstanceId();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (instanceId == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; instanceId.isEmpty()) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             DataCenterInfo dataCenterInfo =&lt;span&gt; config.getDataCenterInfo();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (dataCenterInfo &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; UniqueIdentifier) {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 instanceId =&lt;span&gt; ((UniqueIdentifier) dataCenterInfo).getId();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 instanceId = config.getHostName(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        String defaultAddress;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (config &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; RefreshableInstanceConfig) {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Refresh AWS data center info, and return up to date address&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;             defaultAddress = ((RefreshableInstanceConfig) config).resolveDefaultAddress(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;             defaultAddress = config.getHostName(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; fail safe&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (defaultAddress == &lt;span&gt;null&lt;/span&gt; ||&lt;span&gt; defaultAddress.isEmpty()) {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             defaultAddress =&lt;span&gt; config.getIpAddress();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置属性&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        builder.setNamespace(config.getNamespace())
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                .setInstanceId(instanceId)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                .setAppName(config.getAppname())
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                .setAppGroupName(config.getAppGroupName())
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                .setDataCenterInfo(config.getDataCenterInfo())
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                .setIPAddr(config.getIpAddress())
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                .setHostName(defaultAddress)
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                .setPort(config.getNonSecurePort())
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                .enablePort(PortType.UNSECURE, config.isNonSecurePortEnabled())
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                .setSecurePort(config.getSecurePort())
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;                .enablePort(PortType.SECURE, config.getSecurePortEnabled())
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                .setVIPAddress(config.getVirtualHostName())
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                .setSecureVIPAddress(config.getSecureVirtualHostName())
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;                .setHomePageUrl(config.getHomePageUrlPath(), config.getHomePageUrl())
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;                .setStatusPageUrl(config.getStatusPageUrlPath(), config.getStatusPageUrl())
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;                .setASGName(config.getASGName())
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;                .setHealthCheckUrls(config.getHealthCheckUrlPath(),
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt; &lt;span&gt;                        config.getHealthCheckUrl(), config.getSecureHealthCheckUrl());
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; 
&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Start off with the STARTING state to avoid traffic&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;config.isInstanceEnabledOnit()) {
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;             InstanceStatus initialStatus =&lt;span&gt; InstanceStatus.STARTING;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;             LOG.info(&quot;Setting initial instance status as: {}&quot;&lt;span&gt;, initialStatus);
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt; &lt;span&gt;            builder.setStatus(initialStatus);
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             LOG.info(&quot;Setting initial instance status as: {}. This may be too early for the instance to advertise &quot;
&lt;span&gt;67&lt;/span&gt;                      + &quot;itself as available. You would instead want to control this via a healthcheck handler.&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;                     InstanceStatus.UP);
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; 
&lt;span&gt;71&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add any user-specific metadata information&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (Map.Entry&amp;lt;String, String&amp;gt;&lt;span&gt; mapEntry : config.getMetadataMap().entrySet()) {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             String key =&lt;span&gt; mapEntry.getKey();
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;             String value =&lt;span&gt; mapEntry.getValue();
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; only add the metadata if the value is present&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (value != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;value.isEmpty()) {
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt; &lt;span&gt;                builder.add(key, value);
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt; 
&lt;span&gt;81&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 调用 build 方法做属性校验并创建 InstanceInfo 实例&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt;         instanceInfo =&lt;span&gt; builder.build();
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt; &lt;span&gt;        instanceInfo.setLeaseInfo(leaseInfoBuilder.build());
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; instanceInfo;
&lt;/span&gt;&lt;span&gt;86&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;LeaseInfo 就是续约信息，可以看到主要的两个配置就是续约间隔时间和多久未续约认为实例过期，实例过期就会被剔除。然后就是基于 config 设置 InstanceInfo，就是实例信息，包含了实例ID、主机名称、端口、LeaseInfo 等等。&lt;/p&gt;
&lt;h3&gt;5、注册中心构造客户端 DiscoveryClient&lt;/h3&gt;
&lt;p&gt;在集群模式下，eureka server 也会作为客户端注册到其它注册中心，此时，它本身就是一个 eureka client。因此会去构建 EurekaClient，其默认实现类是 DiscoveryClient。DiscoveryClient 包含了 eureka 客户端的大部分核心功能，比如服务注册、续约、维持心跳、拉取注册表等。&lt;/p&gt;
&lt;p&gt;一步步进入到DiscoveryClient最复杂的那个构造方法，我们先整体分析下做了哪些事情，抓大放小，很多组件的细节等后面分析具体功能的时候再来看。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;将 EurekaClientConfig、EurekaInstanceConfig、EurekaTransportConfig、InstanceInfo、ApplicationInfoManager 等保存到本地变量中&lt;/li&gt;
&lt;li&gt;如果要获取注册表，就创建一个注册表状态度量器&lt;/li&gt;
&lt;li&gt;如果要注册到注册中心，就创建一个心跳状态度量器&lt;/li&gt;
&lt;li&gt;如果不获取注册表且不注册到注册中心，就不会创建调度器、心跳线程池这些了，释放一些资源&lt;/li&gt;
&lt;li&gt;如果要注册到注册中心且要抓取注册表，就初始化一些调度的资源：
&lt;ul&gt;&lt;li&gt;创建了支持调度的线程池，有两个核心线程，从后面可以看出，主要就是处理心跳和缓存刷新的任务&lt;/li&gt;
&lt;li&gt;创建了维持心跳的线程池，核心线程数为1，最大线程数配置默认为5&lt;/li&gt;
&lt;li&gt;创建了刷新缓存的线程池，核心线程数为1，最大线程数配置默认为5&lt;/li&gt;
&lt;li&gt;创建了eureka client 与 eureka server 进行网络通信的组件 EurekaTransport，并进行了一些初始化 。EurekaTransport 里的客户端主要就是封装了对 server 的 api 调用接口，便于调用&lt;/li&gt;
&lt;li&gt;接着，如果要抓取注册表，就会抓取注册表了，fetchRegistry 里面可以看到是分为全量抓取和增量抓取的，第一次启动的时候就是全量抓取注册表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;开始初始化调度任务：
&lt;ul&gt;&lt;li&gt;如果要抓取注册表，就创建刷新缓存的任务，并开始调度，默认每隔30秒抓取一次注册表&lt;/li&gt;
&lt;li&gt;如果要注册到注册中心，就创建发送心跳的任务，并开始调度，默认每隔30秒发送一次心跳&lt;/li&gt;
&lt;li&gt;如果要注册到注册中心，还会创建实例副本传播器（内部也是一个定时调度任务）、实例状态变更的监听器&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;65&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_1863e2a3-5df6-44ff-9d2b-57e164186d15&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_1863e2a3-5df6-44ff-9d2b-57e164186d15&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1863e2a3-5df6-44ff-9d2b-57e164186d15&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;125&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args,
&lt;/span&gt;&lt;span&gt;  2&lt;/span&gt;                 Provider&amp;lt;BackupRegistry&amp;gt;&lt;span&gt; backupRegistryProvider, EndpointRandomizer endpointRandomizer) {
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (args != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.healthCheckHandlerProvider =&lt;span&gt; args.healthCheckHandlerProvider;
&lt;/span&gt;&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.healthCheckCallbackProvider =&lt;span&gt; args.healthCheckCallbackProvider;
&lt;/span&gt;&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.eventListeners.addAll(args.getEventListeners());
&lt;/span&gt;&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.preRegistrationHandler =&lt;span&gt; args.preRegistrationHandler;
&lt;/span&gt;&lt;span&gt;  8&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.healthCheckCallbackProvider = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.healthCheckHandlerProvider = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.preRegistrationHandler = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 将实例信息、配置信息保存到本地&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.applicationInfoManager =&lt;span&gt; applicationInfoManager;
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;     InstanceInfo myInfo =&lt;span&gt; applicationInfoManager.getInfo();
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;     clientConfig =&lt;span&gt; config;
&lt;/span&gt;&lt;span&gt; 18&lt;/span&gt;     staticClientConfig =&lt;span&gt; clientConfig;
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;     transportConfig =&lt;span&gt; config.getTransportConfig();
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;     instanceInfo =&lt;span&gt; myInfo;
&lt;/span&gt;&lt;span&gt; 21&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (myInfo != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 22&lt;/span&gt;         appPathIdentifier = instanceInfo.getAppName() + &quot;/&quot; +&lt;span&gt; instanceInfo.getId();
&lt;/span&gt;&lt;span&gt; 23&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;         logger.warn(&quot;Setting instanceInfo to a passed in null value&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 26&lt;/span&gt; 
&lt;span&gt; 27&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.backupRegistryProvider =&lt;span&gt; backupRegistryProvider;
&lt;/span&gt;&lt;span&gt; 28&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.endpointRandomizer =&lt;span&gt; endpointRandomizer;
&lt;/span&gt;&lt;span&gt; 29&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.urlRandomizer = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EndpointUtils.InstanceInfoBasedUrlRandomizer(instanceInfo);
&lt;/span&gt;&lt;span&gt; 30&lt;/span&gt;     localRegionApps.set(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Applications());
&lt;/span&gt;&lt;span&gt; 31&lt;/span&gt; 
&lt;span&gt; 32&lt;/span&gt; 
&lt;span&gt; 33&lt;/span&gt;     fetchRegistryGeneration = &lt;span&gt;new&lt;/span&gt; AtomicLong(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt;     remoteRegionsToFetch = &lt;span&gt;new&lt;/span&gt; AtomicReference&amp;lt;String&amp;gt;&lt;span&gt;(clientConfig.fetchRegistryForRemoteRegions());
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 从远程拉取注册表的地址数组，使用的原子类，在运行中可能会动态更新地址&lt;/span&gt;
&lt;span&gt; 36&lt;/span&gt;     remoteRegionsRef = &lt;span&gt;new&lt;/span&gt; AtomicReference&amp;lt;&amp;gt;(remoteRegionsToFetch.get() == &lt;span&gt;null&lt;/span&gt; ? &lt;span&gt;null&lt;/span&gt; : remoteRegionsToFetch.get().split(&quot;,&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 37&lt;/span&gt; 
&lt;span&gt; 38&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果要获取注册表，就会注册状态监视器&lt;/span&gt;
&lt;span&gt; 39&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (config.shouldFetchRegistry()) {
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.registryStalenessMonitor = &lt;span&gt;new&lt;/span&gt; ThresholdLevelsMetric(&lt;span&gt;this&lt;/span&gt;, METRIC_REGISTRY_PREFIX + &quot;lastUpdateSec_&quot;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;[]{15L, 30L, 60L, 120L, 240L, 480L&lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.registryStalenessMonitor =&lt;span&gt; ThresholdLevelsMetric.NO_OP_METRIC;
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 44&lt;/span&gt; 
&lt;span&gt; 45&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果要注册到 eureka-server，就会创建心跳状态监视器&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (config.shouldRegisterWithEureka()) {
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.heartbeatStalenessMonitor = &lt;span&gt;new&lt;/span&gt; ThresholdLevelsMetric(&lt;span&gt;this&lt;/span&gt;, METRIC_REGISTRATION_PREFIX + &quot;lastHeartbeatSec_&quot;, &lt;span&gt;new&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;[]{15L, 30L, 60L, 120L, 240L, 480L&lt;span&gt;});
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 49&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.heartbeatStalenessMonitor =&lt;span&gt; ThresholdLevelsMetric.NO_OP_METRIC;
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt; 
&lt;span&gt; 52&lt;/span&gt;     logger.info(&quot;Initializing Eureka in region {}&quot;&lt;span&gt;, clientConfig.getRegion());
&lt;/span&gt;&lt;span&gt; 53&lt;/span&gt; 
&lt;span&gt; 54&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果不注册到注册中心，且不拉取注册表，就不创建调度器、线程池等资源了&lt;/span&gt;
&lt;span&gt; 55&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!config.shouldRegisterWithEureka() &amp;amp;&amp;amp; !&lt;span&gt;config.shouldFetchRegistry()) {
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;         logger.info(&quot;Client configured to neither register nor query for data.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 57&lt;/span&gt;         scheduler = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;         heartbeatExecutor = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 59&lt;/span&gt;         cacheRefreshExecutor = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 60&lt;/span&gt;         eurekaTransport = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 61&lt;/span&gt;         instanceRegionChecker = &lt;span&gt;new&lt;/span&gt; InstanceRegionChecker(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyBasedAzToRegionMapper(config), clientConfig.getRegion());
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt; 
&lt;span&gt; 63&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; to work with DI'd DiscoveryClient&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt;         DiscoveryManager.getInstance().setDiscoveryClient(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt; &lt;span&gt;        DiscoveryManager.getInstance().setEurekaClientConfig(config);
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt; 
&lt;span&gt; 68&lt;/span&gt;         initTimestampMs =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt;         initRegistrySize = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getApplications().size();
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;         registrySize =&lt;span&gt; initRegistrySize;
&lt;/span&gt;&lt;span&gt; 71&lt;/span&gt;         logger.info(&quot;Discovery Client initialized at timestamp {} with initial instances count: {}&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt; &lt;span&gt;                initTimestampMs, initRegistrySize);
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt; 
&lt;span&gt; 74&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; no need to setup up an network tasks and we are done&lt;/span&gt;
&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt; 
&lt;span&gt; 77&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 78&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建定时调度器，默认有2个核心线程，主要处理心跳任务和缓存刷新任务&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;         scheduler = Executors.newScheduledThreadPool(2&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactoryBuilder()
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                         .setNameFormat(&quot;DiscoveryClient-%d&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt;                         .setDaemon(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt; &lt;span&gt;                        .build());
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt; 
&lt;span&gt; 85&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 维持心跳的线程池，一个核心线程，最大线程数默认5。
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注意其使用的队列是 SynchronousQueue 队列，这个队列只能放一个任务，一个线程将任务取走后，才能放入下一个任务，否则只能阻塞。&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt;         heartbeatExecutor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                 1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0&lt;span&gt;, TimeUnit.SECONDS,
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;(),
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactoryBuilder()
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt;                         .setNameFormat(&quot;DiscoveryClient-HeartbeatExecutor-%d&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                         .setDaemon(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;                        .build()
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;         );  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use direct handoff
&lt;/span&gt;&lt;span&gt; 95&lt;/span&gt; 
&lt;span&gt; 96&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刷新缓存的线程池，一个核心线程，最大线程数据默认为5&lt;/span&gt;
&lt;span&gt; 97&lt;/span&gt;         cacheRefreshExecutor = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadPoolExecutor(
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                 1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0&lt;span&gt;, TimeUnit.SECONDS,
&lt;/span&gt;&lt;span&gt; 99&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; SynchronousQueue&amp;lt;Runnable&amp;gt;&lt;span&gt;(),
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactoryBuilder()
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;                         .setNameFormat(&quot;DiscoveryClient-CacheRefreshExecutor-%d&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt;                         .setDaemon(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                        .build()
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt;         );  &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use direct handoff
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt; 
&lt;span&gt;106&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; eureka http 调用客户端，支持 eureka client 与 eureka server 之间的通信&lt;/span&gt;
&lt;span&gt;107&lt;/span&gt;         eurekaTransport = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EurekaTransport();
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化 eurekaTransport&lt;/span&gt;
&lt;span&gt;109&lt;/span&gt; &lt;span&gt;        scheduleServerEndpointTask(eurekaTransport, args);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; 
&lt;span&gt;111&lt;/span&gt; &lt;span&gt;        AzToRegionMapper azToRegionMapper;
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (clientConfig.shouldUseDnsForFetchingServiceUrls()) {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt;             azToRegionMapper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DNSBasedAzToRegionMapper(clientConfig);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;             azToRegionMapper = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; PropertyBasedAzToRegionMapper(clientConfig);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;null&lt;/span&gt; !=&lt;span&gt; remoteRegionsToFetch.get()) {
&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;             azToRegionMapper.setRegionsToFetch(remoteRegionsToFetch.get().split(&quot;,&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt;         instanceRegionChecker = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InstanceRegionChecker(azToRegionMapper, clientConfig.getRegion());
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; RuntimeException(&quot;Failed to initialize DiscoveryClient!&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;123&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt; 
&lt;span&gt;125&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (clientConfig.shouldFetchRegistry()) {
&lt;/span&gt;&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 拉取注册表：全量抓取和增量抓取&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; primaryFetchRegistryResult = fetchRegistry(&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;primaryFetchRegistryResult) {
&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;                 logger.info(&quot;Initial registry fetch from primary servers failed&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;132&lt;/span&gt;             &lt;span&gt;boolean&lt;/span&gt; backupFetchRegistryResult = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!primaryFetchRegistryResult &amp;amp;&amp;amp; !&lt;span&gt;fetchRegistryFromBackup()) {
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;                 backupFetchRegistryResult = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;                 logger.info(&quot;Initial registry fetch from backup servers failed&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!primaryFetchRegistryResult &amp;amp;&amp;amp; !backupFetchRegistryResult &amp;amp;&amp;amp;&lt;span&gt; clientConfig.shouldEnforceFetchRegistryAtInit()) {
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Fetch registry error at startup. Initial fetch failed.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;139&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable th) {
&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;             logger.error(&quot;Fetch registry error at startup: {}&quot;&lt;span&gt;, th.getMessage());
&lt;/span&gt;&lt;span&gt;142&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(th);
&lt;/span&gt;&lt;span&gt;143&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;144&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;145&lt;/span&gt; 
&lt;span&gt;146&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; call and execute the pre registration handler before all background tasks (inc registration) is started&lt;/span&gt;
&lt;span&gt;147&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.preRegistrationHandler != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.preRegistrationHandler.beforeRegistration();
&lt;/span&gt;&lt;span&gt;149&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;150&lt;/span&gt; 
&lt;span&gt;151&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (clientConfig.shouldRegisterWithEureka() &amp;amp;&amp;amp;&lt;span&gt; clientConfig.shouldEnforceRegistrationAtInit()) {
&lt;/span&gt;&lt;span&gt;152&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;153&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;register() ) {
&lt;/span&gt;&lt;span&gt;154&lt;/span&gt;                 &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; IllegalStateException(&quot;Registration error at startup. Invalid server response.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;155&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;156&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable th) {
&lt;/span&gt;&lt;span&gt;157&lt;/span&gt;             logger.error(&quot;Registration error at startup: {}&quot;&lt;span&gt;, th.getMessage());
&lt;/span&gt;&lt;span&gt;158&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(th);
&lt;/span&gt;&lt;span&gt;159&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;160&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;161&lt;/span&gt; 
&lt;span&gt;162&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化一些调度任务：刷新缓存的调度任务、发送心跳的调度任务、实例副本传播器&lt;/span&gt;
&lt;span&gt;163&lt;/span&gt; &lt;span&gt;    initScheduledTasks();
&lt;/span&gt;&lt;span&gt;164&lt;/span&gt; 
&lt;span&gt;165&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;166&lt;/span&gt;         Monitors.registerObject(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;167&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;168&lt;/span&gt;         logger.warn(&quot;Cannot register timers&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;169&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;170&lt;/span&gt; 
&lt;span&gt;171&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This is a bit of hack to allow for existing code using DiscoveryManager.getInstance()
&lt;/span&gt;&lt;span&gt;172&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; to work with DI'd DiscoveryClient&lt;/span&gt;
&lt;span&gt;173&lt;/span&gt;     DiscoveryManager.getInstance().setDiscoveryClient(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;174&lt;/span&gt; &lt;span&gt;    DiscoveryManager.getInstance().setEurekaClientConfig(config);
&lt;/span&gt;&lt;span&gt;175&lt;/span&gt; 
&lt;span&gt;176&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化的时间&lt;/span&gt;
&lt;span&gt;177&lt;/span&gt;     initTimestampMs =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;178&lt;/span&gt;     initRegistrySize = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.getApplications().size();
&lt;/span&gt;&lt;span&gt;179&lt;/span&gt;     registrySize =&lt;span&gt; initRegistrySize;
&lt;/span&gt;&lt;span&gt;180&lt;/span&gt;     logger.info(&quot;Discovery Client initialized at timestamp {} with initial instances count: {}&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;181&lt;/span&gt; &lt;span&gt;            initTimestampMs, initRegistrySize);
&lt;/span&gt;&lt;span&gt;182&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;183&lt;/span&gt; 
&lt;span&gt;184&lt;/span&gt; &lt;span&gt;////////////////////////////////////////////////////////////////////
&lt;/span&gt;&lt;span&gt;185&lt;/span&gt; 
&lt;span&gt;186&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initScheduledTasks() {
&lt;/span&gt;&lt;span&gt;187&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (clientConfig.shouldFetchRegistry()) {
&lt;/span&gt;&lt;span&gt;188&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抓取注册表的间隔时间，默认30秒&lt;/span&gt;
&lt;span&gt;189&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; registryFetchIntervalSeconds =&lt;span&gt; clientConfig.getRegistryFetchIntervalSeconds();
&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刷新缓存调度器延迟时间扩大倍数，在任务超时的时候，将扩大延迟时间
&lt;/span&gt;&lt;span&gt;191&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这在出现网络抖动、eureka-sever 不可用时，可以避免频繁发起无效的调度&lt;/span&gt;
&lt;span&gt;192&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; expBackOffBound =&lt;span&gt; clientConfig.getCacheRefreshExecutorExponentialBackOffBound();
&lt;/span&gt;&lt;span&gt;193&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册表刷新的定时任务&lt;/span&gt;
&lt;span&gt;194&lt;/span&gt;         cacheRefreshTask = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimedSupervisorTask(
&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;                 &quot;cacheRefresh&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;196&lt;/span&gt; &lt;span&gt;                scheduler,
&lt;/span&gt;&lt;span&gt;197&lt;/span&gt; &lt;span&gt;                cacheRefreshExecutor,
&lt;/span&gt;&lt;span&gt;198&lt;/span&gt; &lt;span&gt;                registryFetchIntervalSeconds,
&lt;/span&gt;&lt;span&gt;199&lt;/span&gt; &lt;span&gt;                TimeUnit.SECONDS,
&lt;/span&gt;&lt;span&gt;200&lt;/span&gt; &lt;span&gt;                expBackOffBound,
&lt;/span&gt;&lt;span&gt;201&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt; CacheRefreshThread() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刷新注册表的任务&lt;/span&gt;
&lt;span&gt;202&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;203&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 30秒后开始调度刷新注册表的任务&lt;/span&gt;
&lt;span&gt;204&lt;/span&gt; &lt;span&gt;        scheduler.schedule(
&lt;/span&gt;&lt;span&gt;205&lt;/span&gt; &lt;span&gt;                cacheRefreshTask,
&lt;/span&gt;&lt;span&gt;206&lt;/span&gt; &lt;span&gt;                registryFetchIntervalSeconds, TimeUnit.SECONDS);
&lt;/span&gt;&lt;span&gt;207&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;208&lt;/span&gt; 
&lt;span&gt;209&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (clientConfig.shouldRegisterWithEureka()) {
&lt;/span&gt;&lt;span&gt;210&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 续约间隔时间，默认30秒&lt;/span&gt;
&lt;span&gt;211&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; renewalIntervalInSecs =&lt;span&gt; instanceInfo.getLeaseInfo().getRenewalIntervalInSecs();
&lt;/span&gt;&lt;span&gt;212&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 心跳调度器的延迟时间扩大倍数，默认10&lt;/span&gt;
&lt;span&gt;213&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; expBackOffBound =&lt;span&gt; clientConfig.getHeartbeatExecutorExponentialBackOffBound();
&lt;/span&gt;&lt;span&gt;214&lt;/span&gt;         logger.info(&quot;Starting heartbeat executor: &quot; + &quot;renew interval is: {}&quot;&lt;span&gt;, renewalIntervalInSecs);
&lt;/span&gt;&lt;span&gt;215&lt;/span&gt; 
&lt;span&gt;216&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 心跳的定时任务&lt;/span&gt;
&lt;span&gt;217&lt;/span&gt;         heartbeatTask = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimedSupervisorTask(
&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;                 &quot;heartbeat&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;219&lt;/span&gt; &lt;span&gt;                scheduler,
&lt;/span&gt;&lt;span&gt;220&lt;/span&gt; &lt;span&gt;                heartbeatExecutor,
&lt;/span&gt;&lt;span&gt;221&lt;/span&gt; &lt;span&gt;                renewalIntervalInSecs,
&lt;/span&gt;&lt;span&gt;222&lt;/span&gt; &lt;span&gt;                TimeUnit.SECONDS,
&lt;/span&gt;&lt;span&gt;223&lt;/span&gt; &lt;span&gt;                expBackOffBound,
&lt;/span&gt;&lt;span&gt;224&lt;/span&gt;                 &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HeartbeatThread()
&lt;/span&gt;&lt;span&gt;225&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;226&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 30秒后开始调度心跳的任务&lt;/span&gt;
&lt;span&gt;227&lt;/span&gt; &lt;span&gt;        scheduler.schedule(
&lt;/span&gt;&lt;span&gt;228&lt;/span&gt; &lt;span&gt;                heartbeatTask,
&lt;/span&gt;&lt;span&gt;229&lt;/span&gt; &lt;span&gt;                renewalIntervalInSecs, TimeUnit.SECONDS);
&lt;/span&gt;&lt;span&gt;230&lt;/span&gt; 
&lt;span&gt;231&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例副本传播器，用于定时更新自己状态&lt;/span&gt;
&lt;span&gt;232&lt;/span&gt;         instanceInfoReplicator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; InstanceInfoReplicator(
&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;                 &lt;span&gt;this&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;234&lt;/span&gt; &lt;span&gt;                instanceInfo,
&lt;/span&gt;&lt;span&gt;235&lt;/span&gt; &lt;span&gt;                clientConfig.getInstanceInfoReplicationIntervalSeconds(),
&lt;/span&gt;&lt;span&gt;236&lt;/span&gt;                 2); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; burstSize
&lt;/span&gt;&lt;span&gt;237&lt;/span&gt; 
&lt;span&gt;238&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 实例状态变更的监听器&lt;/span&gt;
&lt;span&gt;239&lt;/span&gt;         statusChangeListener = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ApplicationInfoManager.StatusChangeListener() {
&lt;/span&gt;&lt;span&gt;240&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;241&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String getId() {
&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &quot;statusChangeListener&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;243&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;244&lt;/span&gt; 
&lt;span&gt;245&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;246&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; notify(StatusChangeEvent statusChangeEvent) {
&lt;/span&gt;&lt;span&gt;247&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt; (statusChangeEvent.getStatus() ==&lt;span&gt; InstanceStatus.DOWN) {
&lt;/span&gt;&lt;span&gt;248&lt;/span&gt;                     logger.error(&quot;Saw local status change event {}&quot;&lt;span&gt;, statusChangeEvent);
&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;                 } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;250&lt;/span&gt;                     logger.info(&quot;Saw local status change event {}&quot;&lt;span&gt;, statusChangeEvent);
&lt;/span&gt;&lt;span&gt;251&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;252&lt;/span&gt; &lt;span&gt;                instanceInfoReplicator.onDemandUpdate();
&lt;/span&gt;&lt;span&gt;253&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;254&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;255&lt;/span&gt; 
&lt;span&gt;256&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 向 ApplicationInfoManager 注册监听器&lt;/span&gt;
&lt;span&gt;257&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (clientConfig.shouldOnDemandUpdateStatusChange()) {
&lt;/span&gt;&lt;span&gt;258&lt;/span&gt; &lt;span&gt;            applicationInfoManager.registerStatusChangeListener(statusChangeListener);
&lt;/span&gt;&lt;span&gt;259&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;260&lt;/span&gt; 
&lt;span&gt;261&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动副本传播器，默认延迟时间40秒&lt;/span&gt;
&lt;span&gt;262&lt;/span&gt; &lt;span&gt;        instanceInfoReplicator.start(clientConfig.getInitialInstanceInfoReplicationIntervalSeconds());
&lt;/span&gt;&lt;span&gt;263&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;         logger.info(&quot;Not registering with Eureka server per configuration&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;265&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;266&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;6、定时任务监管器的设计&lt;/h3&gt;
&lt;p&gt;可以看到，eureka client 为了定时发送心跳以及定时抓取注册表，使用了定时任务和调度器，我觉得它这里的定时调度的设计思想是可以参考和借鉴的。&lt;/p&gt;
&lt;p&gt;以心跳任务的这段代码为例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (clientConfig.shouldFetchRegistry()) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 抓取注册表的间隔时间，默认30秒&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; registryFetchIntervalSeconds =&lt;span&gt; clientConfig.getRegistryFetchIntervalSeconds();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刷新缓存调度器延迟时间扩大倍数，在任务超时的时候，将扩大延迟时间
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 这在出现网络抖动、eureka-sever 不可用时，可以避免频繁发起无效的调度&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; expBackOffBound =&lt;span&gt; clientConfig.getCacheRefreshExecutorExponentialBackOffBound();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册表刷新的定时任务&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     cacheRefreshTask = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TimedSupervisorTask(
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &quot;cacheRefresh&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            scheduler,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            cacheRefreshExecutor,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            registryFetchIntervalSeconds,
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;            TimeUnit.SECONDS,
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            expBackOffBound,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; CacheRefreshThread() &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 刷新注册表的任务&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    );
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 30秒后开始调度刷新注册表的任务&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    scheduler.schedule(
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            cacheRefreshTask,
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            registryFetchIntervalSeconds, TimeUnit.SECONDS);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面这段代码其实并不复杂，主要就是创建了一个定时任务，然后使用调度器在一定的延迟之后开始调度。但它这里并不是直接使用调度器调度任务（CacheRefreshThread），也不是以一个固定的频率调度（每隔30秒）。它定义了一个任务的监管器 TimedSupervisorTask，在创建这个监管器的时候，传入了调度器、要执行的任务、以及间隔时间等参数，然后调度器调度 TimedSupervisorTask。&lt;/p&gt;
&lt;p&gt;看 TimedSupervisorTask 的构造方法，主要有以下几个点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;任务的超时时间等于间隔时间，也就是默认30秒的超时时间，然后延迟时间默认等于超时时间  如果 eureka server down 了，或者网络问题，就有可能出现超时&lt;/li&gt;
&lt;li&gt;设置了最大的延迟时间，默认在超时时间的基础上扩大10倍，即300秒&lt;/li&gt;
&lt;li&gt;最后创建了一些计数器，分别统计成功、超时、拒绝、异常的次数，可以看到，它这里对任务的调度是有做统计的&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; TimedSupervisorTask(String name, ScheduledExecutorService scheduler, ThreadPoolExecutor executor,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                            &lt;span&gt;int&lt;/span&gt; timeout, TimeUnit timeUnit, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; expBackOffBound, Runnable task) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.scheduler =&lt;span&gt; scheduler;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.executor =&lt;span&gt; executor;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务超时时间就等于任务调度的间隔时间&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.timeoutMillis =&lt;span&gt; timeUnit.toMillis(timeout);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.task =&lt;span&gt; task;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 延迟时间默认为超时时间&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.delay = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; AtomicLong(timeoutMillis);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最大延迟时间，默认在超时时间的基础上扩大10倍&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.maxDelay = timeoutMillis *&lt;span&gt; expBackOffBound;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化计数器并注册&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     successCounter = Monitors.newCounter(&quot;success&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     timeoutCounter = Monitors.newCounter(&quot;timeouts&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     rejectedCounter = Monitors.newCounter(&quot;rejectedExecutions&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;     throwableCounter = Monitors.newCounter(&quot;throwables&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     threadPoolLevelGauge = &lt;span&gt;new&lt;/span&gt; LongGauge(MonitorConfig.builder(&quot;threadPoolUsed&quot;&lt;span&gt;).build());
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     Monitors.registerObject(name, &lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再看 TimedSupervisorTask 的 run 方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1）首先将任务异步提交到线程池去执行，它这里并不是直接运行任务，而是异步提交到线程池中，这样可以实现超时等待，不影响主任务&lt;/li&gt;
&lt;li&gt;2）任务如果超时，比如出现网络延迟、eureka server 不可用等情况，超时了，它这个时候就会认为如果还是30秒后调度，可能 eureka server 还是不可用的状态，那么就增大延迟时间，那么第一次超时就会在300秒后再调度。如果300秒内 eureka server 可用了，然后有新的服务实例注册上去了，那这个客户端就不能及时感知到了，因此我觉得可以将 getCacheRefreshExecutorExponentialBackOffBound 对应的参数适当设置小一点（默认10倍）。&lt;/li&gt;
&lt;li&gt;3）如果任务没有超时，在调度成功后，就会重置延迟时间为默认的超时时间。最后在 finally 中进行下一次的调度。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     Future&amp;lt;?&amp;gt; future = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 提交任务到线程池&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         future =&lt;span&gt; executor.submit(task);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         threadPoolLevelGauge.set((&lt;span&gt;long&lt;/span&gt;&lt;span&gt;) executor.getActiveCount());
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 阻塞直到任务完成或超时&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        future.get(timeoutMillis, TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 任务完成后，重置延迟时间为超时时间，即30秒&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        delay.set(timeoutMillis);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         threadPoolLevelGauge.set((&lt;span&gt;long&lt;/span&gt;&lt;span&gt;) executor.getActiveCount());
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 成功次数+1&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        successCounter.increment();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (TimeoutException e) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         logger.warn(&quot;task supervisor timed out&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 超时次数+1&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        timeoutCounter.increment();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果任务超时了，就会增大延迟时间，当前延迟时间*2，然后取一个最大值&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; currentDelay =&lt;span&gt; delay.get();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;long&lt;/span&gt; newDelay = Math.min(maxDelay, currentDelay * 2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置为最大的一个延迟时间&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        delay.compareAndSet(currentDelay, newDelay);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RejectedExecutionException e) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (executor.isShutdown() ||&lt;span&gt; scheduler.isShutdown()) {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;             logger.warn(&quot;task supervisor shutting down, reject the task&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;             logger.warn(&quot;task supervisor rejected the task&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; 
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        rejectedCounter.increment();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (executor.isShutdown() ||&lt;span&gt; scheduler.isShutdown()) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             logger.warn(&quot;task supervisor shutting down, can't accept the task&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;             logger.warn(&quot;task supervisor threw an exception&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        throwableCounter.increment();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (future != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             future.cancel(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; 
&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;scheduler.isShutdown()) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 延迟 delay 时间后，继续调度任务&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;             scheduler.schedule(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;, delay.get(), TimeUnit.MILLISECONDS);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;总结一下这块设计：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1）首先在远程调用的时候要考虑到网络不可用、server 端 down 了等情况导致调用超时，可以使用线程池异步提交任务，实现等待超时机制。&lt;/li&gt;
&lt;li&gt;2）超时之后，可以假想服务恢复可用状态可能需要一定的时间，如果还是按原来的时间间隔调度，可能还是会超时，因此增大延迟时间。如果调用成功，说明已经恢复了，则重置延迟时间。&lt;/li&gt;
&lt;li&gt;3）定时任务的调度以一定的延迟时间来循环调度（schedule），延迟时间可以根据实际情况变化，而不是一开始就按一个固定的频率来调度（scheduleAtFixedRate）。&lt;/li&gt;
&lt;li&gt;4）定时任务、线程池里的任务，最好做好任务执行状态的统计，便于观察任务的调度情况。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;7、构造注册表&lt;/h3&gt;
&lt;p&gt;接着构造 PeerAwareInstanceRegistry，从命名来看，这是一个可以感知 eureka 集群的注册表，就是在集群模式下，eureka server 从其它 server 节点拉取注册表。它的默认实现类是 PeerAwareInstanceRegistryImpl，继承自 AbstractInstanceRegistry，就是实例注册表。&lt;/p&gt;
&lt;p&gt;① 构造 PeerAwareInstanceRegistry&lt;/p&gt;
&lt;p&gt;进入 PeerAwareInstanceRegistryImpl 的构造方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是将前面构造的 EurekaServerConfig、EurekaClientConfig、EurekaClient 等传入构造方法来构造 PeerAwareInstanceRegistry&lt;/li&gt;
&lt;li&gt;调用了 super 的构造方法，主要初始化了如下几个东西：
&lt;ul&gt;&lt;li&gt;保存最近下线实例的循环队列&lt;/li&gt;
&lt;li&gt;保存最近注册实例的循环队列&lt;/li&gt;
&lt;li&gt;最近一分钟续约次数的计数器&lt;/li&gt;
&lt;li&gt;定时任务剔除 recentlyChangedQueue 中的实例&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;然后创建了一个最近一分钟集群同步次数的计数器 numberOfReplicationsLastMin。MeasuredRate 我们到后面再来分析它的设计。&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_1879fbaa-965c-4081-ab30-98498a10845f&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_1879fbaa-965c-4081-ab30-98498a10845f&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_1879fbaa-965c-4081-ab30-98498a10845f&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;75&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; PeerAwareInstanceRegistryImpl(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;        EurekaServerConfig serverConfig,
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        EurekaClientConfig clientConfig,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        ServerCodecs serverCodecs,
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;        EurekaClient eurekaClient
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;super&lt;/span&gt;&lt;span&gt;(serverConfig, clientConfig, serverCodecs);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.eurekaClient =&lt;span&gt; eurekaClient;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最近一分钟集群同步的次数计数器&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.numberOfReplicationsLastMin = &lt;span&gt;new&lt;/span&gt; MeasuredRate(1000 * 60 * 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; We first check if the instance is STARTING or DOWN, then we check explicit overrides,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; then we check the status of a potentially existing lease.&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.instanceStatusOverrideRule = &lt;span&gt;new&lt;/span&gt; FirstMatchWinsCompositeRule(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; DownOrStartingRule(),
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt; OverrideExistsRule(overriddenInstanceStatusMap), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LeaseExistsRule());
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; 
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;//////////////////////////////////////////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; AbstractInstanceRegistry(EurekaServerConfig serverConfig, EurekaClientConfig clientConfig, ServerCodecs serverCodecs) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.serverConfig =&lt;span&gt; serverConfig;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.clientConfig =&lt;span&gt; clientConfig;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.serverCodecs =&lt;span&gt; serverCodecs;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最近下线的循环队列&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.recentCanceledQueue = &lt;span&gt;new&lt;/span&gt; CircularQueue&amp;lt;Pair&amp;lt;Long, String&amp;gt;&amp;gt;(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最近注册的循环队列&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.recentRegisteredQueue = &lt;span&gt;new&lt;/span&gt; CircularQueue&amp;lt;Pair&amp;lt;Long, String&amp;gt;&amp;gt;(1000&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; 
&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 最近一分钟续约的计数器&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.renewsLastMin = &lt;span&gt;new&lt;/span&gt; MeasuredRate(1000 * 60 * 1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 一个定时调度任务，定时剔除最近改变队列中过期的实例&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.deltaRetentionTimer.schedule(getDeltaRetentionTask(),
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            serverConfig.getDeltaRetentionTimerIntervalInMs(),
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            serverConfig.getDeltaRetentionTimerIntervalInMs());
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;这块的具体细节等后面分析具体功能的时候再来看，我们先知道有这些队列、计数器就行了。&lt;/p&gt;
&lt;p&gt;② 循环队列 CircularQueue 的设计&lt;/p&gt;
&lt;p&gt;从构造方法可以看到，它使用了循环队列来保存最近下线和最近注册的实例信息，容量固定为1000，这样就把最近的实例数量控制在1000以内。&lt;/p&gt;
&lt;p&gt;CircularQueue 是它自定义的一个循环队列，继承自 AbstractQueue。其内部其实就是代理了 ArrayBlockingQueue，然后重写了入队的 offer 方法，当队列满了，就取出头部的一个元素，然后再放到队列尾部。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CircularQueue&amp;lt;E&amp;gt; &lt;span&gt;extends&lt;/span&gt; AbstractQueue&amp;lt;E&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ArrayBlockingQueue&amp;lt;E&amp;gt;&lt;span&gt; delegate;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; CircularQueue(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; capacity) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.capacity =&lt;span&gt; capacity;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.delegate = &lt;span&gt;new&lt;/span&gt; ArrayBlockingQueue&amp;lt;&amp;gt;&lt;span&gt;(capacity);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;E&amp;gt;&lt;span&gt; iterator() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegate.iterator();
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; size() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegate.size();
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; 
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; offer(E e) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果队列满了，就取出头部的一个元素，然后再放到尾部&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;delegate.offer(e)) {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            delegate.poll();
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E poll() {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegate.poll();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;    @Override
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt;&lt;span&gt; E peek() {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; delegate.peek();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;8、创建 Eureka Server 上下文并初始化&lt;/h3&gt;
&lt;p&gt;接下来先是创建了 PeerEurekaNodes，应该就是代表 eureka 集群的。然后基于前面创建的一些东西创建 eureka server 上下文 EurekaServerContext，从 DefaultEurekaServerContext 构造方法进去可以看到，只是将前面构造的东西封装起来，便于全局使用。然后将 serverContext 放到 EurekaServerContextHolder 中，这样其它地方就可以通过这个 holder 获取 serverContext 了。&lt;/p&gt;
&lt;p&gt;接着就是初始化eureka server上下文：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;启动 eureka 集群：
&lt;ul&gt;&lt;li&gt;主要是启动一个定时任务（间隔时间默认10分钟）更新 eureka 集群节点的信息，根据配置的 eureka server 地址更新 PeerEurekaNode，这样当有 eureka server 下线或上线后，就可以及时感知到其它 server 节点。PeerEurekaNode 主要就是用于集群节点间的数据同步，这块后面分析集群的时候再具体分析。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;注册表初始化：
&lt;ul&gt;&lt;li&gt;首先启动了前面创建的计数器：numberOfReplicationsLastMin&lt;/li&gt;
&lt;li&gt;初始化响应缓存，eureka server 构造了一个多级缓存来响应客户端抓取注册表的请求，这个多级缓存的设计就是响应频繁抓取注册表请求的核心所在，等后面分析客户端抓取注册表的时候再具体分析&lt;/li&gt;
&lt;li&gt;定时调度任务更新续约阈值，主要就是更新 numberOfRenewsPerMinThreshold 这个值，即每分钟续约次数，等分析续约的时候再来分析&lt;/li&gt;
&lt;li&gt;初始化 RemoteRegionRegistry，猜测是跟 eureka 多个区域（region）部署有关的&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; initialize() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     logger.info(&quot;Initializing ...&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动eureka集群&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    peerEurekaNodes.start();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册表初始化&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        registry.init(peerEurekaNodes);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(e);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     logger.info(&quot;Initialized&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;PeerEurekaNodes 的 start 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35.5&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_09d0c4ef-c7f6-40c4-9045-8f2608d0c881&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_09d0c4ef-c7f6-40c4-9045-8f2608d0c881&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_09d0c4ef-c7f6-40c4-9045-8f2608d0c881&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;66&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; start() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 单个线程的线程池&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     taskExecutor =&lt;span&gt; Executors.newSingleThreadScheduledExecutor(
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ThreadFactory() {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;                @Override
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;public&lt;/span&gt;&lt;span&gt; Thread newThread(Runnable r) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                     Thread thread = &lt;span&gt;new&lt;/span&gt; Thread(r, &quot;Eureka-PeerNodesUpdater&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     thread.setDaemon(&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; thread;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    );
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 根据集群地址更新 PeerEurekaNode，PeerEurekaNode 就包含了调度其它注册中心的客户端&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        updatePeerEurekaNodes(resolvePeerUrls());
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         Runnable peersUpdateTask = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            @Override
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                    updatePeerEurekaNodes(resolvePeerUrls());
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                     logger.error(&quot;Cannot update the replica Nodes&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定时跟新集群信息 PeerEurekaNode，如果有eureka-server不可用了，就可以及时下线，或者新上线了eureka-server，可以及时感知到&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        taskExecutor.scheduleWithFixedDelay(
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                peersUpdateTask,
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                serverConfig.getPeerEurekaNodesUpdateIntervalMs(),
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                serverConfig.getPeerEurekaNodesUpdateIntervalMs(),
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                TimeUnit.MILLISECONDS
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; IllegalStateException(e);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (PeerEurekaNode node : peerEurekaNodes) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         logger.info(&quot;Replica node URL:  {}&quot;&lt;span&gt;, node.getServiceUrl());
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;PeerAwareInstanceRegistryImpl 的 init 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_292f0160-9d54-4c0c-a546-66a54df7797c&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_292f0160-9d54-4c0c-a546-66a54df7797c&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_292f0160-9d54-4c0c-a546-66a54df7797c&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;61&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init(PeerEurekaNodes peerEurekaNodes) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动计数器&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.numberOfReplicationsLastMin.start();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.peerEurekaNodes =&lt;span&gt; peerEurekaNodes;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化响应缓存，eureka server 构造了一个多级缓存来响应客户端抓取注册表的请求&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    initializedResponseCache();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定时调度任务更新续约阀值，主要就是更新 numberOfRenewsPerMinThreshold 这个值，即每分钟续约次数&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;    scheduleRenewalThresholdUpdateTask();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 初始化 RemoteRegionRegistry&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    initRemoteRegionRegistry();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         Monitors.registerObject(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable e) {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         logger.warn(&quot;Cannot register the JMX monitor for the InstanceRegistry :&quot;&lt;span&gt;, e);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;9、完成 Eureka Server 初始化&lt;/h3&gt;
&lt;p&gt;接下来看最后几步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先调用 registry.syncUp() 将 EurekaClient 本地的实例同步到注册表，在集群模式下，eureka server 也是一个客户端，因此会获取到其它注册中心的注册表同步到当前 server 的注册表中。它默认会重试5次，每次间隔30秒。在单机模式下，应该将重试次数设置为 0。&lt;/li&gt;
&lt;li&gt;然后调用 registry.openForTraffic 做最后的一些初始化：
&lt;ul&gt;&lt;li&gt;更新每分钟续约阈值&lt;/li&gt;
&lt;li&gt;设置实例状态&lt;/li&gt;
&lt;li&gt;启动统计最近一分钟续约次数的计数器&lt;/li&gt;
&lt;li&gt;启动定时任务剔除下线的实例，定时任务默认每隔60秒调度一次&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最后一步就是注册 eureka 自身的一些监控统计&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;syncUp 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_82cf6336-4ab5-43cf-8981-a4c8f0e58df7&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_82cf6336-4ab5-43cf-8981-a4c8f0e58df7&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_82cf6336-4ab5-43cf-8981-a4c8f0e58df7&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; syncUp() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Copy entire entry from neighboring DS node&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; count = 0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册表同步重试次数，默认5次&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; ((i &amp;lt; serverConfig.getRegistrySyncRetries()) &amp;amp;&amp;amp; (count == 0)); i++&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (i &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 同步重试时间，默认30秒&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;                Thread.sleep(serverConfig.getRegistrySyncRetryWaitMs());
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 logger.warn(&quot;Interrupted during registry transfer..&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         Applications apps =&lt;span&gt; eurekaClient.getApplications();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Application app : apps.getRegisteredApplications()) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (InstanceInfo instance : app.getInstances()) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (isRegisterable(instance)) {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 注册实例&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                         register(instance, instance.getLeaseInfo().getDurationInSecs(), &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                         count++&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable t) {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                     logger.error(&quot;During DS init copy&quot;&lt;span&gt;, t);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;openForTraffic 方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; id=&quot;code_img_closed_36b1ac20-c9b4-4fb5-a67b-9e753bd26198&quot; class=&quot;code_img_closed&quot;/&gt;&lt;img src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; id=&quot;code_img_opened_36b1ac20-c9b4-4fb5-a67b-9e753bd26198&quot; class=&quot;code_img_opened&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_36b1ac20-c9b4-4fb5-a67b-9e753bd26198&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; openForTraffic(ApplicationInfoManager applicationInfoManager, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; count) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 期望的客户端每分钟的续约次数&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.expectedNumberOfClientsSendingRenews =&lt;span&gt; count;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 更新每分钟续约阀值&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    updateRenewsPerMinThreshold();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     logger.info(&quot;Got {} instances from neighboring DS node&quot;&lt;span&gt;, count);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     logger.info(&quot;Renew threshold is: {}&quot;&lt;span&gt;, numberOfRenewsPerMinThreshold);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;this&lt;/span&gt;.startupTime =&lt;span&gt; System.currentTimeMillis();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (count &amp;gt; 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.peerInstancesTransferEmptyOnStartup = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     DataCenterInfo.Name selfName =&lt;span&gt; applicationInfoManager.getInfo().getDataCenterInfo().getName();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;boolean&lt;/span&gt; isAws = Name.Amazon ==&lt;span&gt; selfName;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (isAws &amp;amp;&amp;amp;&lt;span&gt; serverConfig.shouldPrimeAwsReplicaConnections()) {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         logger.info(&quot;Priming AWS connections for all replicas..&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        primeAwsReplicas(applicationInfoManager);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     logger.info(&quot;Changing status to UP&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置实例状态为已启动&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    applicationInfoManager.setInstanceStatus(InstanceStatus.UP);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     &lt;span&gt;super&lt;/span&gt;&lt;span&gt;.postInit();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;//////////////////////////////////////&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; postInit() {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 启动 统计最近一分钟续约次数的计数器&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    renewsLastMin.start();
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (evictionTaskRef.get() != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;        evictionTaskRef.get().cancel();
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 定时剔除任务&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     evictionTaskRef.set(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; EvictionTask());
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;    evictionTimer.schedule(evictionTaskRef.get(),
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            serverConfig.getEvictionIntervalTimerInMs(),
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            serverConfig.getEvictionIntervalTimerInMs());
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;h3&gt;10、Eureka Server 启动流程图&lt;/h3&gt;
&lt;p&gt;下面通过一张图来展示下 eureka server 的启动初始化流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/856154/202012/856154-20201201103920038-355210066.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;四、Eureka Client 启动初始化&lt;/h2&gt;
&lt;p&gt;eureka client 的启动初始化我们看 eureka-examples 模块下的 ExampleEurekaClient 这个类，它的 main 方法中就模拟了作为一个 eureka client 启动初始化，并向注册中心发送请求。&lt;/p&gt;
&lt;p&gt;eureka server 的初始化中其实已经包含了客户端的初始化，可以看出，客户端的初始化主要有如下的一些东西：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读取 eureka-client.properties 配置文件，创建 EurekaInstanceConfig&lt;/li&gt;
&lt;li&gt;基于 InstanceConfig 创建实例信息 InstanceInfo&lt;/li&gt;
&lt;li&gt;基于 InstanceConfig 和 InstanceInfo 创建应用实例管理器 ApplicationInfoManager&lt;/li&gt;
&lt;li&gt;读取 eureka-client.properties 配置文件，创建 EurekaClientConfig&lt;/li&gt;
&lt;li&gt;基于应用实例管理器和 clientConfig 创建 EurekaClient（DiscoveryClient），初始化流程跟 eureka server 初始化流程中 DiscoveryClient 的创建是一样的&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     ExampleEurekaClient sampleClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ExampleEurekaClient();
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基于实例配置和实例信息创建应用实例管理器&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     ApplicationInfoManager applicationInfoManager = initializeApplicationInfoManager(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; MyDataCenterInstanceConfig());
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 基于应用实例管理器和客户端配置创建 EurekaClient（DiscoveryClient）&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     EurekaClient client = initializeEurekaClient(applicationInfoManager, &lt;span&gt;new&lt;/span&gt;&lt;span&gt; DefaultEurekaClientConfig());
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; use the client&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    sampleClient.sendRequestToServiceUsingEureka(client);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; shutdown the client&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    eurekaClient.shutdown();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;</description>
<pubDate>Tue, 01 Dec 2020 14:42:00 +0000</pubDate>
<dc:creator>bojiangzhou</dc:creator>
<og:description>eureka 源码研究系列第一篇，eureka 架构、源码环境、eureka-server 启动流程分析、eureka-client 启动流程分析</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chiangchou/p/eureka-1.html</dc:identifier>
</item>
<item>
<title>利用python库stats进行t检验 - 皮卡qiu</title>
<link>http://www.cnblogs.com/zwrAI/p/14071305.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zwrAI/p/14071305.html</guid>
<description>&lt;p&gt;​ t检验通常分为三种，分别是单样本t检验、双样本t检验和配对样本t检验。本文基于python的scipy.stats函数对每种t检验进行了介绍和实验。&lt;/p&gt;
&lt;h2 id=&quot;一、t检验介绍&quot;&gt;一、t检验介绍&lt;/h2&gt;
&lt;p&gt;无论哪种t检验，都有以下的基本前提条件：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;样本数据符合正态分布&lt;/li&gt;
&lt;li&gt;各个样本之间是独立的&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;提出原假设和备择假设&lt;/li&gt;
&lt;li&gt;构造t统计量&lt;/li&gt;
&lt;li&gt;计算t统计量&lt;/li&gt;
&lt;li&gt;对于得到的p值进行分析，p大于0.05则接受原假设，反之接受备择假设&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;二、-单样本t检验&quot;&gt;二、 单样本t检验&lt;/h2&gt;
&lt;p&gt;应用场景：对某个样本的均值进行检验，比较是否和总体的均值(自己定）是否存在差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原假设和备择假设&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;​ &lt;img src=&quot;https://img2020.cnblogs.com/blog/1955286/202012/1955286-20201201223718428-53392512.png&quot; alt=&quot;9wmgvuncay&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，我获取了50个中国人的身高（随机生成均值为1.5m的50个数据），想比较当前样本的平均身高和中国人的平均身高(1.7m）是否存在差异。按道理来说应该是存在差异的，因为一个是1.5,一个是1.7。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现：&lt;/strong&gt;使用ttest_1samp函数实现，第一个参数为样本数据，第二个参数为总体均值。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from scipy.stats import ttest_1samp
from scipy import stats

rvs = stats.norm.rvs(loc=1.5, scale=1, size=(50))                               #生成均值为1.5，标准差为1的样本
t, p = ttest_1samp(rvs, 1.7)                                                    #进行单样本t检验
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最终得到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;out：t =  -0.29277920321046647   p =   0.7709272063776454
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;p值大于0.05，说明我们不能拒绝原假设&lt;strong&gt;(即认为样本均值和总体均值没有显著差异)&lt;/strong&gt;，说明样本的身高均值可以认为是1.7m。之所以得到这样的结果可能由于我们的样本数目太少，还有就是生成的数据1.5和1.7过于的接近。所以我们再进行一组实验来说明，将随机数的均值改为2.5。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;rvs = stats.norm.rvs(loc=2.5, scale=1, size=(50))                            #生成均值为1.5，标准差为1的样本
t, p = ttest_1samp(rvs, 1.7)                                                    #进行单样本t检验，返回对应的t值和p值
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;out：t =  5.333243665065403  p =  2.4443516254546488e-06
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时p小于0.05，我们可以拒绝原假设&lt;strong&gt;(即认为样本均值和总体均值有显著差异)&lt;/strong&gt;，说明样本身高的均值不可以认为是1.7m。而且因为2.5是大于1.7的，最终得到的t也是一个正数。&lt;/p&gt;
&lt;h2 id=&quot;三、独立样本t检验双样本t检验&quot;&gt;三、独立样本t检验(双样本t检验)&lt;/h2&gt;
&lt;p&gt;应用场景：是针对两组不相关样本（各样本量可以相等也可以不相等），检验它们在均值之间的差异。对于该检验方法而言，我们首先要确定两个总体的方差是否相等，如果不等，先利用&lt;strong&gt;levene检验&lt;/strong&gt;，检验两总体是否具有方差齐性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原假设和备择假设&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1955286/202012/1955286-20201201223718147-895801715.png&quot; alt=&quot;wumri45ar4&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，我想检验A公司销售额的均值和B公司销售额的均值是否存在差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现：&lt;/strong&gt;使用stats.levene检验方差是否相等，再使用stats.ttest_ind进行独立样本t检验，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A = stats.norm.rvs(loc=1, scale=1, size=(100))                #生成A公司的销售额
B = stats.norm.rvs(loc=3, scale=1, size=(100))           #生成B公司的销售额
stats.levene(A, B)                                       #进行levene检验
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;out:LeveneResult(statistic=0.8054648213132949, pvalue=0.37055445629183437)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;得到的p值大于0.05，说明满足方差相等。使用ttest_ind函数进行独立样本t检验，函数的最后一个参数为判断两个样本的方差是否相同，如果不同，设为False进行独立样本t检验。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;stats.ttest_ind(A,B,equal_var=True)                          #进行独立样本t检验
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;out：Ttest_indResult(statistic=-15.25297417258199, pvalue=2.993305057567317e-35)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;检验结果显示p远小于0.05，我们拒绝原假设，即认为A公司和B公司的销售额均值存在显著差异&lt;/p&gt;
&lt;h2 id=&quot;四、配对t检验&quot;&gt;四、配对t检验&lt;/h2&gt;
&lt;p&gt;应用场景：是针对同一组样本在不同场景下均值之间的差异。检验的是两配对样本差值的均值是否等于0，如果等于0，则认为配对样本之间的均值没有差异，否则存在差异。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原假设和备择假设&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1955286/202012/1955286-20201201223717724-349625419.png&quot; alt=&quot;vldz9mvgtl&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;例如，我们有A公司今年的销售额以及去年的销售额，来判断今年和去年的销售额均值之间是否有差异。与独立样本t检验相比，配对样本T检验要求样本是配对的，&lt;strong&gt;两个样本的样本量要相同&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现：&lt;/strong&gt;可以选择单样本t检验的ttest_1samp函数(两组样本的差异为输入），也可以直接选择实现配对样本t检验的ttest_rel函数（两组样本作为输入)。代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;A0 = stats.norm.rvs(loc=1, scale=1, size=(100))                       #生成去年的销售额
A1 = stats.norm.rvs(loc=1.5, scale=1, size=(100))                #生成今年的销售额

# 计算两年销售额之间的差值
diff = A0-A1
# 使用ttest_1samp函数计算配对样本的t统计量
stats.ttest_1samp(diff)
out:
Ttest_1sampResult(statistic=13.983206457471795, pvalue=1.1154473504425075e-14)

# 使用ttest_rel函数计算配对样本的t统计量
stats.ttest_rel(A0,A1)
out:
Ttest_relResult(statistic=-4.731625986009621, pvalue=7.412846164679422e-06)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见，用哪个函数最终得到的t和p值都是相同的。对于这个问题，p值小于0.05，认为两年的销售额存在显著差异。&lt;/p&gt;
</description>
<pubDate>Tue, 01 Dec 2020 14:41:00 +0000</pubDate>
<dc:creator>皮卡qiu</dc:creator>
<og:description>​	t检验通常分为三种，分别是单样本t检验、双样本t检验和配对样本t检验。本文基于python的scipy.stats函数对每种t检验进行了介绍和实验。 一、t检验介绍 无论哪种t检验，都有以下的基本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zwrAI/p/14071305.html</dc:identifier>
</item>
<item>
<title>使用RestTemplate，显示请求信息，响应信息 - 口袋里的猫</title>
<link>http://www.cnblogs.com/pi-laoban/p/14071279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pi-laoban/p/14071279.html</guid>
<description>&lt;p&gt;这里不讲怎么用RestTemplate具体细节用法，就是一个学习中的过程记录&lt;/p&gt;
&lt;p&gt;一个简单的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class App {
    public static void main(String[] args) {
        String url = &quot;https://api.uixsj.cn/hitokoto/get&quot;;
        RestTemplate restTemplate = new RestTemplate();
        String body = restTemplate.getForObject(url, String.class);
        System.out.println(body);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2186622/202012/2186622-20201201222630654-405560632.png&quot; alt=&quot;image-20201130123152314&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;❓：现在我想看看他的请求头，请求参数，响应头，响应体的详细信息是怎么样子的，这样也方便以后检查请求参数是否完整，响应正确与否。&lt;/p&gt;
&lt;p&gt;经过搜集资料发现&lt;code&gt;ClientHttpRequestInterceptor&lt;/code&gt;满足需求，于是就有了下面的代码&lt;/p&gt;
&lt;h2 id=&quot;打印请求头响应头&quot;&gt;打印请求头/响应头&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class App {
    public static void main(String[] args) {
        String url = &quot;https://api.uixsj.cn/hitokoto/get&quot;;
        RestTemplate restTemplate = new RestTemplate();
        // 加上拦截器打印将请求请求，响应信息打印出来
        restTemplate.setInterceptors(Collections.singletonList(new LoggingInterceptor()));
        String body = restTemplate.getForObject(url, String.class);
        System.out.println(body);
    }
}

@Slf4j
class LoggingInterceptor implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        displayRequest(request, body);
        ClientHttpResponse response = execution.execute(request, body);
        displayResponse(response);
        return response;
    }

    /**
     * 显示请求相关信息
     * @param request
     * @param body
     */
    private void displayRequest(HttpRequest request, byte[] body) {
        log.debug(&quot;====request info====&quot;);
        log.debug(&quot;URI         : {}&quot;, request.getURI());
        log.debug(&quot;Method      : {}&quot;, request.getMethod());
        log.debug(&quot;Req Headers : {}&quot;, this.headersToString(request.getHeaders()));
        log.debug(&quot;Request body: {}&quot;, body == null ? &quot;&quot; : new String(body, StandardCharsets.UTF_8));
    }

    /**
     * 显示响应相关信息
     * @param response
     * @throws IOException
     */
    private void displayResponse(ClientHttpResponse response) throws IOException {
        StringBuilder inputStringBuilder = new StringBuilder();
        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(response.getBody(), StandardCharsets.UTF_8))) {
            String line = bufferedReader.readLine();
            while (line != null) {
                inputStringBuilder.append(line);
                inputStringBuilder.append('\n');
                line = bufferedReader.readLine();
            }
        }
        log.debug(&quot;====response info====&quot;);
        log.debug(&quot;Status code  : {}&quot;, response.getStatusCode());
        log.debug(&quot;Status text  : {}&quot;, response.getStatusText());
        log.debug(&quot;Resp Headers : {}&quot;, headersToString(response.getHeaders()));
        log.debug(&quot;Response body: {}&quot;, inputStringBuilder.toString());
    }

    /**
     * 将Http头信息格式化处理
     * @param httpHeaders
     * @return
     */
    private String headersToString(HttpHeaders httpHeaders) {
        if (Objects.isNull(httpHeaders)) {
            return &quot;[]&quot;;
        }
        return httpHeaders.entrySet().stream()
                .map(entry -&amp;gt; {
                    List&amp;lt;String&amp;gt; values = entry.getValue();
                    return &quot;\t&quot; + entry.getKey() + &quot;:&quot; + (values.size() == 1 ?
                            &quot;\&quot;&quot; + values.get(0) + &quot;\&quot;&quot; :
                            values.stream().map(s -&amp;gt; &quot;\&quot;&quot; + s + &quot;\&quot;&quot;).collect(Collectors.joining(&quot;, &quot;)));
                })
                .collect(Collectors.joining(&quot;, \n&quot;, &quot;\n[\n&quot;, &quot;\n]\n&quot;));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2186622/202012/2186622-20201201222658288-2066109236.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行过程中会报错，具体错误信息是&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Exception in thread &quot;main&quot; org.springframework.web.client.ResourceAccessException: I/O error on GET request for &quot;https://api.uixsj.cn/hitokoto/get&quot;: stream is closed; nested exception is java.io.IOException: stream is closed
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里报错信息是&lt;code&gt;流已关闭&lt;/code&gt;，报错是在添加&lt;code&gt;LoggingInterceptor&lt;/code&gt;后出现的，那就是新加代码引起的。在看看&lt;code&gt;LoggingInterceptor&lt;/code&gt;的实现，什么地方操作了流，并且关闭了流。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LoggingInterceptor.displayResponse&lt;/code&gt;这个方法里面，为了读取响应体操作了流&lt;code&gt;response.getBody()&lt;/code&gt;，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;try (...) {
}
// 这个try块结束后就把流给关了
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注释掉代码中流操作相关代码，再次运行没有错误信息。因该是在拦截器后，RestTemplate也需要操作了&lt;code&gt;response.getBody()&lt;/code&gt;的流（废话）。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Response body 不能读第二次这个很要命呀&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;问题找到了，初步的想到了几种解决&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;改写代码，不&lt;code&gt;close&lt;/code&gt;流，读取完之后再&lt;code&gt;reset&lt;/code&gt;流&lt;/li&gt;
&lt;li&gt;代理一下&lt;code&gt;ClientHttpResponse&lt;/code&gt;每次调用&lt;code&gt;getBody&lt;/code&gt;都返回一个新的输入流&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;解决不能重复读response-body&quot;&gt;解决不能重复读Response body&lt;/h2&gt;
&lt;h3 id=&quot;方法一：读取完后不关闭流&quot;&gt;方法一：读取完后不关闭流&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 略...
InputStream responseBody = response.getBody();
BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(responseBody, StandardCharsets.UTF_8));
String line = bufferedReader.readLine();
while (line != null) {
    inputStringBuilder.append(line);
    inputStringBuilder.append('\n');
    line = bufferedReader.readLine();
}
responseBody.reset();
// 略...
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很遗憾，执行后依旧有错误&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Exception in thread &quot;main&quot; org.springframework.web.client.ResourceAccessException: I/O error on GET request for &quot;https://api.uixsj.cn/hitokoto/get&quot;: mark/reset not supported; nested exception is java.io.IOException: mark/reset not supported
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说的很清楚，不支持&lt;code&gt;mark/reset&lt;/code&gt;方法。很明显了它不允许随意修改读取定位。没办法只转为第二种方法了。&lt;/p&gt;
&lt;h3 id=&quot;方法二：代理，每次都返回一个新的流&quot;&gt;方法二：代理，每次都返回一个新的流&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;静态代理实现&lt;code&gt;ClientHttpResponse&lt;/code&gt;接口，好在&lt;code&gt;ClientHttpResponse&lt;/code&gt;实现的接口数量不多，实现的代码如下。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Slf4j
class LoggingInterceptor implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        displayRequest(request, body);
        ClientHttpResponse response = execution.execute(request, body);
        // 包装代理一下
        response = new ClientHttpResponseWrapper(response);
        displayResponse(response);
        return response;
    }

    /**
     * 显示请求相关信息
     * @param request
     * @param body
     */
    private void displayRequest(HttpRequest request, byte[] body) {
        // 略...
    }

    /**
     * 显示响应相关信息
     * @param response
     * @throws IOException
     */
    private void displayResponse(ClientHttpResponse response) throws IOException {
        StringBuilder inputStringBuilder = new StringBuilder();
        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(response.getBody(), StandardCharsets.UTF_8))) {
            String line = bufferedReader.readLine();
            while (line != null) {
                inputStringBuilder.append(line);
                inputStringBuilder.append('\n');
                line = bufferedReader.readLine();
            }
        }
        // 略...
    }

    /**
     * 将Http头信息格式化处理
     * @param httpHeaders
     * @return
     */
    private String headersToString(HttpHeaders httpHeaders) {
        // 略...
    }

    private class ClientHttpResponseWrapper implements ClientHttpResponse {
        private ClientHttpResponse clientHttpResponse;
        private byte[] body;

        public ClientHttpResponseWrapper(ClientHttpResponse clientHttpResponse) {
            this.clientHttpResponse = clientHttpResponse;
        }

        @Override
        public HttpStatus getStatusCode() throws IOException {
            return this.clientHttpResponse.getStatusCode();
        }

        @Override
        public int getRawStatusCode() throws IOException {
            return this.clientHttpResponse.getRawStatusCode();
        }

        @Override
        public String getStatusText() throws IOException {
            return this.clientHttpResponse.getStatusText();
        }

        @Override
        public void close() {
            this.clientHttpResponse.close();
        }

        /**
         * 缓存body每次返回一个新的输入流
         * @return
         * @throws IOException
         */
        @Override
        public InputStream getBody() throws IOException {
            if (Objects.isNull(this.body)) {
                this.body = StreamUtils.copyToByteArray(this.clientHttpResponse.getBody());
            }
            return new ByteArrayInputStream(this.body == null ? new byte[0] : this.body);
        }

        @Override
        public HttpHeaders getHeaders() {
            return this.clientHttpResponse.getHeaders();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2186622/202012/2186622-20201201222658679-1935149575.png&quot; alt=&quot;image-20201130132734043&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;代码运行没问题，但是总感觉代码写出来笨笨的，要重写这么多用不着的方法，看着不舒服，换个写法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;动态代理&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;
public class App {
    public static void main(String[] args) {
        String url = &quot;https://api.uixsj.cn/hitokoto/get&quot;;
        RestTemplate restTemplate = new RestTemplate();
        restTemplate.setInterceptors(Collections.singletonList(new LoggingInterceptor()));
        String body = restTemplate.getForObject(url, String.class);
        System.out.println(body);
    }

}

@Slf4j
class LoggingInterceptor implements ClientHttpRequestInterceptor {

    @Override
    public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException {
        displayRequest(request, body);
        ClientHttpResponse response = execution.execute(request, body);
        // 包装代理一下
        response = (ClientHttpResponse) Proxy.newProxyInstance(response.getClass().getClassLoader(), new Class[]{ClientHttpResponse.class}, new ClientHttpResponseHandler(response));
        displayResponse(response);
        return response;
    }

    /**
     * 显示请求相关信息
     * @param request
     * @param body
     */
    private void displayRequest(HttpRequest request, byte[] body) {
        // 略......
    }

    /**
     * 显示响应相关信息
     * @param response
     * @throws IOException
     */
    private void displayResponse(ClientHttpResponse response) throws IOException {
        StringBuilder inputStringBuilder = new StringBuilder();
        try (BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(response.getBody(), StandardCharsets.UTF_8))) {
            String line = bufferedReader.readLine();
            while (line != null) {
                inputStringBuilder.append(line);
                inputStringBuilder.append('\n');
                line = bufferedReader.readLine();
            }
        }
        // 略......
    }

    /**
     * 将Http头信息格式化处理
     * @param httpHeaders
     * @return
     */
    private String headersToString(HttpHeaders httpHeaders) {
        // 略......
    }

    private static class ClientHttpResponseHandler implements InvocationHandler {
        private static final String methodName = &quot;getBody&quot;;
        private ClientHttpResponse clientHttpResponse;
        private byte[] body;

        ClientHttpResponseHandler(ClientHttpResponse clientHttpResponse) {
            this.clientHttpResponse = clientHttpResponse;
        }

        @Override
        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            if (StringUtils.equals(methodName, method.getName())) {
                if (Objects.isNull(this.body)) {
                    this.body = StreamUtils.copyToByteArray(this.clientHttpResponse.getBody());
                }
                return new ByteArrayInputStream(this.body == null ? new byte[0] : this.body);
            }
            return method.invoke(this.clientHttpResponse, args);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2186622/202012/2186622-20201201222658919-552733011.png&quot; alt=&quot;image-20201130140437927&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;使用RestTemplate想要显示详细请求信息，和响应信息&lt;/li&gt;
&lt;li&gt;添加拦截器&lt;/li&gt;
&lt;li&gt;拦截器中操作InputSteam导致流关闭，不能重复读Response body&lt;/li&gt;
&lt;li&gt;尝试不关闭流，重置流的方案失败&lt;/li&gt;
&lt;li&gt;使用代理解决 Response body 不能读第二次读的问题
&lt;ul&gt;&lt;li&gt;静态代理（可以重复读Response body了）&lt;/li&gt;
&lt;li&gt;动态代理（可以重复读Response body了）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;静态代理的代码有点啰嗦，动态代理又有点不够味，看来『茴』字不好写呀&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 01 Dec 2020 14:36:00 +0000</pubDate>
<dc:creator>口袋里的猫</dc:creator>
<og:description>使用RestTemplate，显示请求信息，响应信息 这里不讲怎么用RestTemplate具体细节用法，就是一个学习中的过程记录 一个简单的例子 public class App { public</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pi-laoban/p/14071279.html</dc:identifier>
</item>
</channel>
</rss>