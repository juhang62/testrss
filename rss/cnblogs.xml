<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>《痞子衡嵌入式半月刊》 第 7 期 - 痞子衡</title>
<link>http://www.cnblogs.com/henjay724/p/12829344.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/henjay724/p/12829344.html</guid>
<description>&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;145.40556900726&quot;&gt;

&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/cnblogs/pzh_mcu_bi_weekly.PNG&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。&lt;/p&gt;
&lt;p&gt;本期刊是开源项目（GitHub: &lt;a href=&quot;https://github.com/JayHeng/pzh-mcu-bi-weekly&quot;&gt;JayHeng/pzh-mcu-bi-weekly&lt;/a&gt;），欢迎提交 issue，投稿或推荐你知道的嵌入式那些事儿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;上期回顾&lt;/strong&gt; ：&lt;a href=&quot;https://www.cnblogs.com/henjay724/p/12728731.html&quot;&gt;《痞子衡嵌入式半月刊： 第 6 期》&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;唠两句&quot;&gt;唠两句&lt;/h2&gt;
&lt;p&gt;今天是立夏，夏季的第一个节气。立夏表示告别春天，夏天要开始了。今天也是五一小长假最后一天，不知道你的假期如何度过的？痞子衡回了一趟老家，受老家的慢生活感染，不仅饭量见长，睡眠也补得相当充足。在城市里匆忙惯了，适期回趟老家，感受乡土，抚慰心灵，挺好！&lt;/p&gt;
&lt;p&gt;本期共收录 2条资讯、3个项目、2个工具，希望对你有帮助！&lt;/p&gt;
&lt;h2 id=&quot;资讯类&quot;&gt;资讯类&lt;/h2&gt;
&lt;h3 id=&quot;1、github-宣布向所有人免费开放所有核心功能&quot;&gt;&lt;span&gt;1、GitHub 宣布向所有人免费开放所有核心功能&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;近日，GitHub CEO Nat Friedman 在官方博客中正式宣布，GitHub 所有核心功能从此对所有人都免费提供。&lt;/p&gt;
&lt;blockquote readability=&quot;0.94594594594595&quot;&gt;
&lt;p&gt;消息来源: &lt;a href=&quot;https://github.blog/2020-04-14-github-is-now-free-for-teams/&quot;&gt;https://github.blog/2020-04-14-github-is-now-free-for-teams/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/github_free_for_teams.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;本次重大福利更新包括：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;1、此前仅对个人免费的私有仓库，现在对所有账号类型开放，取消协作者数量上限；
2、GitHub Pro 现在将包括 2GB 的 Packages 存储和 10GB 的数据传输；
3、在官宣时间之前注册并已为团队服务付费的用户，订单到期之日按比例退款；
4、自 5 月 14 日起，GitHub 团队每月将为私有仓库提供 3000 分钟的操作时间；
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;提及 GitHub，程序员中无论是新手，还是大神，无论秃顶的还是刚入行满头黑发的都应该知道。GitHub 中的有很多优质的代码可以参考。然而，GitHub并不是完全免费的，但现在 GitHub 又有了一项大动作，确实是程序员的一个相当好的福利。&lt;/p&gt;
&lt;h3 id=&quot;2、英飞凌并购赛普拉斯宣告完成，跃居全球第一车用半导体供应商&quot;&gt;&lt;span&gt;2、英飞凌并购赛普拉斯宣告完成，跃居全球第一车用半导体供应商&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;近日，总部位于圣何塞的赛普拉斯半导体公司正式并入英飞凌科技股份公司，标志着英飞凌史上最大并购案宣告完成。新的英飞凌在汽车电子市场份额预计可达到 13％，一举超过竞争对手恩智浦成为最大的汽车芯片供应商。&lt;/p&gt;
&lt;blockquote readability=&quot;0.83333333333333&quot;&gt;
&lt;p&gt;资讯主页：&lt;a href=&quot;https://www.infineon.com/cms/en/about-infineon/press/press-releases/2019/INFXX201906-074.html&quot;&gt;https://www.infineon.com/cms/en/about-infineon/press/press-releases/2019/INFXX201906-074.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/Cypress_Infineon.PNG&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;随着赛普拉斯的加入，英飞凌将进一步强化其结构性增长驱动，拓展更广泛的应用领域，以加速公司的盈利性增长。赛普拉斯的产品主要有微控制器、连接组件、软件系统以及高性能存储器等，与英飞凌领先的功率半导体、汽车微控制器、传感器以及安全解决方案，形成了高度的优势互补。赛普拉斯强大的研发能力以及在美国和日本市场上的稳固地位，也将为英飞凌的全球客户提供更有力的支持。&lt;/p&gt;
&lt;h2 id=&quot;项目类&quot;&gt;项目类&lt;/h2&gt;
&lt;h3 id=&quot;1、babyos---一套管理功能模块和外设驱动的-mcu-项目开发框架&quot;&gt;&lt;span&gt;1、BabyOS - 一套管理功能模块和外设驱动的 MCU 项目开发框架&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;BabyOS 是由网友 notrynohigh 开发维护的适用于 MCU 项目的一套管理功能模块和外设驱动的框架。&lt;/p&gt;
&lt;blockquote readability=&quot;1.3725490196078&quot;&gt;
&lt;p&gt;项目主页: &lt;a href=&quot;https://github.com/notrynohigh/BabyOS&quot;&gt;https://github.com/notrynohigh/BabyOS&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对项目而言，使用 BabyOS 能缩短开发周期。项目开发时选择适用的功能模块及驱动。直接进入功能代码编写的阶段。对工程师而言，使用 BabyOS 能减少重复工作，调试过的功能模块和驱动代码放入 BabyOS 中进行管理，以后项目可以直接使用，去掉重复调试的工作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/BabyOS_framework.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、easyflash---一款轻巧的嵌入式-flash-存储器库&quot;&gt;&lt;span&gt;2、EasyFlash - 一款轻巧的嵌入式 Flash 存储器库&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;EasyFlash是一款开源的轻量级嵌入式Flash存储器库，方便开发者更加轻松的实现基于Flash存储器的常见应用开发。非常适合智能家居、可穿戴设备、工控、医疗、物联网等需要断电存储功能的产品，资源占用极低，支持各种MCU片上存储器。&lt;/p&gt;
&lt;blockquote readability=&quot;1.4285714285714&quot;&gt;
&lt;p&gt;项目主页: &lt;a href=&quot;https://github.com/armink/EasyFlash&quot;&gt;https://github.com/armink/EasyFlash&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;该库主要有三大实用功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;ENV&lt;/strong&gt; 快速保存产品参数，支持 &lt;strong&gt;写平衡（磨损平衡）&lt;/strong&gt;及 &lt;strong&gt;掉电保护&lt;/strong&gt; 功能&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;IAP&lt;/strong&gt; 封装了IAP常用接口，同时支持Bootloader及Application的升级&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Log&lt;/strong&gt; 无需文件系统，日志可直接存储在Flash上 ，搭配EasyLogger，轻松实现 C日志的Flash存储功能&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/EasyFlash.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;目前EasyFlash的最新版本V4.0支持了更多新特性，支持了增量升级、数据加密及压缩等功能，感兴趣的读者可以去项目主页一探究竟。&lt;/p&gt;
&lt;h3 id=&quot;3、20mhz-dds-awg-generator---最小的基于fpga的dds任意波形发生器&quot;&gt;&lt;span&gt;3、20MHz DDS AWG Generator - 最小的基于FPGA的DDS任意波形发生器&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;来自电子森林苏老师“入门PCB设计的正确姿势”的实战项目作品，不仅蕴含了全面的基础设计要点，也可以说是全球最小的基于FPGA、能产生20MHz频率的DDS任意波形发生器！&lt;/p&gt;
&lt;blockquote readability=&quot;4.0593607305936&quot;&gt;
&lt;p&gt;项目介绍：&lt;a href=&quot;https://mp.weixin.qq.com/s?src=11&amp;amp;timestamp=1588569967&amp;amp;ver=2317&amp;amp;signature=MsKTM-xOWU1qXMkdmN&quot;&gt;https://mp.weixin.qq.com/s?src=11&amp;amp;timestamp=1588569967&amp;amp;ver=2317&amp;amp;signature=MsKTM-xOWU1qXMkdmN&lt;/a&gt;&lt;em&gt;0ESE&lt;/em&gt;sov9Hp20ZqH0O&lt;em&gt;UxEOhIy2NE-lue7ZIwaLN3HwfUlqoo2kv5brtPMDFCuDwfPkfet3o4FbkeeOsSAVzg0UkgkWP&lt;/em&gt;2Ym-xfHNLwaivXo8&amp;amp;new=1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这个项目是用来学习基础的工具，它诞生的意义在于学习PCB设计、FPGA编程、深入体验模电、数电的理论到实际的应用、同PC的通信、上位机软件编写（无论是Labview、Matlab还是其它）等等。&lt;/p&gt;
&lt;p&gt;项目硬件构成：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;1. 核心器件为Lattice的XO2-1200HC-QN32 FPGA
2. CH340E实现USB-UART接口，所有参数均可通过PC上位机进行控制
3. R-2R的电阻网络实现高速DAC的功能
4. AD4851-1配2阶低通滤波器对DAC输出的信号进行成形滤波，截止频率设定为10MHz，最大输出电平为8Vpp，直流偏移可以在-4V ～ 4V之间调节
5. MMCX射频插座方便连接示波器等测试设备
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/20MHz_DDS_AWG_Generator.PNG&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;工具类&quot;&gt;工具类&lt;/h2&gt;
&lt;h3 id=&quot;1、kicad---备受全球创客推崇的开源-pcb-设计软件&quot;&gt;&lt;span&gt;1、KiCad - 备受全球创客推崇的开源 PCB 设计软件&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;KiCad 是一款完全免费开源的 EDA 设计软件，最初由法国工程师 Jean-Pierre Charras 独立开发，在 1992 年时就公布了最早的发行版。目前，KiCad 的开发不再由个人完成，而是由专门的开发者团队进行维护升级。&lt;/p&gt;
&lt;blockquote readability=&quot;1.9444444444444&quot;&gt;
&lt;p&gt;软件主页: &lt;a href=&quot;https://kicad-pcb.org/&quot;&gt;https://kicad-pcb.org/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说到 PCB 设计软件，大家首先想到的肯定是 Altium Designer，Cadence Allegero，或者Eagle等等，不过这些软件的使用，有一个绕不开的问题，那就是版权。网上随手一搜 AD 正版使用一年的价格，至少10W+，这对个人爱好者来说根本无力承担。&lt;/p&gt;
&lt;p&gt;KiCad 免费、开源、兼容性好三大优点使得它现在几乎是创客发起开源项目的首选 PCB 设计软件。下图便是大名鼎鼎的无线电开源项目 HackRF One 的硬件设计，使用得就是 KiCad。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/kicad_pcbnew.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/kicad_3dviewer.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2、千呼万唤始出来！intellij-idea-20201正式发布&quot;&gt;&lt;span&gt;2、千呼万唤始出来！IntelliJ IDEA 2020.1正式发布&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;2020是JetBrains公司成立的第20个年头，4月9号，JetBrains发布了其新十年的首个版本 IntelliJ IDEA 2020.1，添加了对 Java 14 的支持、为部分 Web 和测试框架添加了新的功能，通过数据流分析辅助升级了调试器，新增了 LightEdit 模式，以及还支持从 IDE 直接下载和配置 JDK 的功能。最重要的是它还支持了中文，对于英文不好的同学来说是个很大的福利啊。话不多说，去它的下载主页尝尝鲜。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/biweekly/IntelliJ_2020.1.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;0.74336283185841&quot;&gt;
&lt;p&gt;下载主页: &lt;a href=&quot;https://www.jetbrains.com/idea/whatsnew/?_ga=2.223997853.766751345.1587148177-1945597286.1562144217&quot;&gt;https://www.jetbrains.com/idea/whatsnew/?_ga=2.223997853.766751345.1587148177-1945597286.1562144217&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;欢迎订阅&quot;&gt;欢迎订阅&lt;/h3&gt;
&lt;p&gt;文章会同时发布到我的 &lt;a href=&quot;https://www.cnblogs.com/henjay724/&quot;&gt;博客园主页&lt;/a&gt;、&lt;a href=&quot;https://blog.csdn.net/Henjay724&quot;&gt;CSDN主页&lt;/a&gt;、&lt;a href=&quot;http://weixin.sogou.com/weixin?type=1&amp;amp;query=%E7%97%9E%E5%AD%90%E8%A1%A1%E5%B5%8C%E5%85%A5%E5%BC%8F&quot;&gt;微信公众号&lt;/a&gt; 平台上。&lt;/p&gt;
&lt;p&gt;微信搜索&quot;&lt;strong&gt;痞子衡嵌入式&lt;/strong&gt;&quot;或者扫描下面二维码，就可以在手机上第一时间看了哦。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://henjay724.com/image/github/pzhMcu_qrcode_258x258.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 05 May 2020 00:00:00 +0000</pubDate>
<dc:creator>痞子衡</dc:creator>
<og:description>这里分享嵌入式领域有用有趣的项目/工具以及一些热点新闻，农历年分二十四节气，希望在每个交节之日准时发布一期。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/henjay724/p/12829344.html</dc:identifier>
</item>
<item>
<title>JS中由闭包引发内存泄露的深思 - forcheng</title>
<link>http://www.cnblogs.com/forcheng/p/12828941.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/forcheng/p/12828941.html</guid>
<description>&lt;p&gt;&lt;strong&gt;目录&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一个存在内存泄露的闭包实例
&lt;ul&gt;&lt;li&gt;什么是内存泄露&lt;/li&gt;
&lt;li&gt;JS的垃圾回收机制&lt;/li&gt;
&lt;li&gt;什么是闭包&lt;/li&gt;
&lt;li&gt;什么原因导致了内存泄露&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;参考&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;1.一个存在内存泄露的闭包实例&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var theThing = null;
var replaceThing = function () {
  var originalThing = theThing;
  var unused = function () {
    if (originalThing)
      console.log(&quot;hi&quot;);
  };
  theThing = {
    longStr: new Array(1000000).join('*'),
    someMethod: function () {
      console.log(someMessage);
    }
  };
};
setInterval(replaceThing, 1000);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面代码片段做了一件事情：每隔1秒后调用 replaceThing 函数，全局变量 theThing 得到一个包含一个大数组和一个新闭包（someMethod）的新对象。同时，变量 unused 是一个引用 originalThing 的闭包。&lt;/p&gt;
&lt;p&gt;初看之下，感觉应该不存在什么内存泄露问题。replaceThing 函数在每次调用完之后，应该就会释放或销毁 originalThing 和 unused 变量，毕竟这两个变量只在函数内部声明使用了，不能够在 replaceThing 函数外面被使用。而留在内存中的就只剩每次新分配给全局变量 theThing 的新对象。&lt;/p&gt;
&lt;p&gt;但实际上面的直观感受是错误，因为没有真正理解到闭包的实现原理。为了弄清楚上面的代码为什么存在内存泄露，我们首先需要弄清楚几个概念与原理：什么是内存泄露？JS的垃圾回收机制？什么是闭包？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）什么是内存泄露&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;应用程序不再用到的内存，由于某些原因，没有及时释放，就叫做内存泄漏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）JS的垃圾回收机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;不同的编程语言管理内存的方式各不相同。一些高级编程语言的解释器或运行时嵌入了“垃圾回收器”，通过算法可自动的进行内存的分配与释放管理（比如 JavaScript、Java、C# 等）。另一些则寄希望于开发者自己手动地进行内存的分配与释放管理（比如 C/C++ 等）。&lt;/p&gt;
&lt;p&gt;而JavaScript 是通过垃圾回收器来进行内存管理，其实现是基于标记-清除算法。而这个算法把“对象是否不再需要”简化定义为“对象是否可以获得”。其假定设置一个叫做根（root）的对象（在Javascript里，根是全局对象）。在标记过程，垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。标记完成后就进行清除过程。（可达内存被标记，其余的被当作垃圾回收。）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）什么是闭包&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;开发人员经常错误将闭包简化理解成从父上下文中返回内部函数，或则简单归纳为能够读取其他函数内部变量的函数。&lt;/p&gt;
&lt;p&gt;实际上，根据 ECMAScript，闭包指的是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;从理论角度：所有的函数。因为它们都在创建的时候就将上层上下文的数据保存起来了。哪怕是简单的全局变量也是如此，因为函数中访问全局变量就相当于是在访问自由变量，这个时候使用最外层的作用域。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从实践角度：以下函数才算是闭包：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;在代码中引用了自由变量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;（4）什么原因导致了内存泄露&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们这里主要以实践角度来理解我们所讨论的闭包。&lt;/p&gt;
&lt;p&gt;这里需要弄明白一个问题：为什么创建闭包函数的函数的上下文已经被销毁了（常规理解就是函数调用栈释放，函数内的临时变量被回收等），闭包函数依旧可以读取创建它的函数的内部变量？&lt;/p&gt;
&lt;p&gt;从结果倒推，唯一能解释这一点的就是：虽然创建闭包函数的函数的上下文已经被销毁了，但被闭包函数所引用的变量没有被回收。那具体是如何实现的呢？&lt;/p&gt;
&lt;p&gt;为了深入理解这个问题，这里就需要简单的谈一下函数中的作用域链：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;当前函数的作用域链[[Scope]] = VO / AO + 父级函数的作用域链[[Scope]] 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;补充说明：VO 和 AO 分别表示变量对象和活动对象，而变量对象可以理解为保存了当前上下文数据（变量、函数声明、函数参数）的一个对象，而活动对象是特殊的变量对象，简单理解就是函数的变量对象我们一般称之为活动对象，而在全局上下文里，全局对象自身就是变量对象。&lt;a href=&quot;https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html&quot;&gt;点击查看详细解释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在JS内部实现中，每个函数都会有一个 [[Scope]] 属性，表示当前函数的可以访问的作用域链。其实质上就是一个对象数组，包含了函数能够访问到的所有标识符（变量、函数等），用以查找函数所使用的到的标识符。而数组中从左到右的对象依次对应了由内到外的其他函数（或全局）的活动（变量）对象。另外，在 ECMAScript 中，同一个父上下文中创建的闭包是共用一个 [[Scope]] 属性的。换句话说，同一个函数内部的所有闭包共用这个函数的 [[Scope]] 属性。&lt;/p&gt;
&lt;p&gt;对于闭包函数来说，为了实现其所引用的变量不会被回收，会保留它的作用域链（即 [[Scope]] 属性），不会被垃圾回收器回收。&lt;/p&gt;
&lt;p&gt;那么上面的示例中，闭包函数 unused 与 someMethod 的作用域链如下图所示（函数和对象名加了数字后缀，用以区分replaceThing 函数多次调用而产生的同名函数与对象）&lt;/p&gt;
&lt;p&gt;（1）replaceThing 函数第一次调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/898684/202005/898684-20200504234210289-1141040354.png&quot; alt=&quot;第一次调用的作用域链&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，在 replaceThing 函数第一次调用完，通过全局变量 theThing，可以访问到闭包函数 someMehtod1，因此其作用域链也会被保留，即 replaceThing1.[[Scope]] 将被保留，所以闭包函数 unused1就算没有被使用，也不会被回收。（全局变量直到程序运行结束前都不会被回收）&lt;/p&gt;
&lt;p&gt;（2）replaceThing 函数第二次调用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/898684/202005/898684-20200504234254235-1102499678.png&quot; alt=&quot;第二次调用的作用域链&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，在 replaceThing 函数第二次调用完，通过全局变量 theThing，可以访问到闭包函数 someMehtod2，因此其作用域链也会被保留，即 replaceThing2.[[Scope]] 将被保留，所以闭包函数 unused2 与对象 originalThing2 也将被保留，不会被回收。由于 originalThing2 可以访问到闭包函数 someMehtod1，因此之前第一次被保留的作用域链仍将继续被保留。&lt;/p&gt;
&lt;p&gt;当 replaceThing 函数继续重复调用时，相当于上图中虚线框中的内容不断重复，而且相互之间类似形成一个链表，通过 全局变量 theThing 可以顺着链表到查找到第一次调用产生的对象 [Object1]，这也就导致了垃圾回收器无法回收每次产生的新对象（里面包含一个大数组和一个闭包），造成严重的内存泄漏。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.参考&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Memory_Management&quot;&gt;内存管理- JavaScript | MDN&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5db2beb8e51d455b450a64b4#heading-8&quot;&gt;Chrome 浏览器垃圾回收机制与内存泄漏分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://jinlong.github.io/2016/05/01/4-Types-of-Memory-Leaks-in-JavaScript-and-How-to-Get-Rid-Of-Them/&quot;&gt;4类 JavaScript 内存泄漏及如何避免&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html&quot;&gt;深入理解JavaScript系列（12）：变量对象（Variable Object）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/TomXu/archive/2012/01/18/2312463.html&quot;&gt;深入理解JavaScript系列（14）：作用域链(Scope Chain)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/TomXu/archive/2012/01/31/2330252.html&quot;&gt;深入理解JavaScript系列（16）：闭包（Closures）&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 May 2020 15:45:00 +0000</pubDate>
<dc:creator>forcheng</dc:creator>
<og:description>目录 一个存在内存泄露的闭包实例 什么是内存泄露 JS的垃圾回收机制 什么是闭包 什么原因导致了内存泄露 参考 1.一个存在内存泄露的闭包实例 上面代码片段做了一件事情：每隔1秒后调用 replace</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/forcheng/p/12828941.html</dc:identifier>
</item>
<item>
<title>three.js中的矩阵变换(模型视图投影变换) - charlee44</title>
<link>http://www.cnblogs.com/charlee44/p/12828887.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/charlee44/p/12828887.html</guid>
<description>&lt;p&gt;通过具体的实例，详细验证了webGL/three.js中的矩阵变换(模型视图投影变换)。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;265.3080011752&quot;&gt;


&lt;p&gt;我在&lt;a href=&quot;https://www.cnblogs.com/charlee44/p/11623502.html&quot;&gt;《WebGL简易教程(五)：图形变换(模型、视图、投影变换)》&lt;/a&gt;这篇博文里详细讲解了OpenGL\WebGL关于绘制场景的图形变换过程，并推导了相应的模型变换矩阵、视图变换矩阵以及投影变换矩阵。这里我就通过three.js这个图形引擎，验证一下其推导是否正确，顺便学习下three.js是如何进行图形变换的。&lt;/p&gt;

&lt;h2 id=&quot;21-矩阵运算&quot;&gt;2.1. 矩阵运算&lt;/h2&gt;
&lt;p&gt;three.js已经提供了向量类和矩阵类，定义并且查看一个4阶矩阵类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var m = new THREE.Matrix4();
m.set(11, 12, 13, 14,
    21, 22, 23, 24,
    31, 32, 33, 34,
    41, 42, 43, 44);
console.log(m);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1000410/202005/1000410-20200504233111109-1296986072.png&quot; alt=&quot;imglink1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明THREE.Matrix4内部是列主序存储的，而我们理论描述的矩阵都为行主序。&lt;/p&gt;
&lt;h2 id=&quot;22-模型变换矩阵&quot;&gt;2.2. 模型变换矩阵&lt;/h2&gt;
&lt;p&gt;在场景中新建一个平面：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;// create the ground plane
var planeGeometry = new THREE.PlaneGeometry(60, 20);
var planeMaterial = new THREE.MeshBasicMaterial({
    color: 0xAAAAAA
});
var plane = new THREE.Mesh(planeGeometry, planeMaterial);

// add the plane to the scene
scene.add(plane);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;three.js中场景节点的基类都是Object3D，Object3D包含了3种矩阵对象：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Object3D.matrix: 相对于其父对象的局部模型变换矩阵。&lt;/li&gt;
&lt;li&gt;Object3D.matrixWorld: 对象的全局模型变换矩阵。如果对象没有父对象，则与Object3D.matrix相同。&lt;/li&gt;
&lt;li&gt;Object3D.modelViewMatrix: 表示对象相对于相机坐标系的变换。也就是matrixWorld左乘相机的matrixWorldInverse。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;221-平移矩阵&quot;&gt;2.2.1. 平移矩阵&lt;/h3&gt;
&lt;p&gt;平移这个mesh：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;plane.position.set(15, 8, -10);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据推导得到平移矩阵为：&lt;/p&gt;
&lt;p&gt;\[\left[ \begin{matrix} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; Tx\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; Ty\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; Tz\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{matrix} \right] \]&lt;/p&gt;
&lt;p&gt;输出这个Mesh：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1000410/202005/1000410-20200504233124213-2003266496.png&quot; alt=&quot;imglink2&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;222-旋转矩阵&quot;&gt;2.2.2. 旋转矩阵&lt;/h3&gt;
&lt;h4 id=&quot;2221-绕x轴旋转矩阵&quot;&gt;2.2.2.1. 绕X轴旋转矩阵&lt;/h4&gt;
&lt;p&gt;绕X轴旋转：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;plane.rotation.x = THREE.Math.degToRad(30);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的旋转矩阵：&lt;/p&gt;
&lt;p&gt;\[\left[ \begin{matrix} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0\\ 0 &amp;amp; cosβ &amp;amp; -sinβ &amp;amp; 0\\ 0 &amp;amp; sinβ &amp;amp; cosβ &amp;amp; 0\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{matrix} \right] \]&lt;/p&gt;
&lt;p&gt;输出信息：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1000410/202005/1000410-20200504233137325-1938745765.png&quot; alt=&quot;imglink3&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2222-绕y轴旋转矩阵&quot;&gt;2.2.2.2. 绕Y轴旋转矩阵&lt;/h4&gt;
&lt;p&gt;绕Y轴旋转：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;plane.rotation.y = THREE.Math.degToRad(30);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的旋转矩阵：&lt;/p&gt;
&lt;p&gt;\[\left[ \begin{matrix} cosβ &amp;amp; 0 &amp;amp; sinβ &amp;amp; 0\\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 0\\ -sinβ &amp;amp; 0 &amp;amp; cosβ &amp;amp; 0\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{matrix} \right] \]&lt;/p&gt;
&lt;p&gt;输出信息：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1000410/202005/1000410-20200504233149307-146617756.png&quot; alt=&quot;imglink4&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2223-绕z轴旋转矩阵&quot;&gt;2.2.2.3. 绕Z轴旋转矩阵&lt;/h4&gt;
&lt;p&gt;绕Z轴旋转：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;plane.rotation.z = THREE.Math.degToRad(30);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对应的旋转矩阵：&lt;/p&gt;
&lt;p&gt;\[\left[ \begin{matrix} cosβ &amp;amp; -sinβ &amp;amp; 0 &amp;amp; 0\\ sinβ &amp;amp; cosβ &amp;amp; 0 &amp;amp; 0\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{matrix} \right] \]&lt;/p&gt;
&lt;p&gt;输出信息：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1000410/202005/1000410-20200504233200646-95813364.png&quot; alt=&quot;imglink5&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;23-投影变换矩阵&quot;&gt;2.3. 投影变换矩阵&lt;/h2&gt;
&lt;p&gt;在场景中新建一个Camera：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里创建了一个透视投影的相机，一般建立的都是对称的透视投影，推导的透视投影矩阵为：&lt;/p&gt;
&lt;p&gt;\[P= \left[ \begin{matrix} \frac{1}{aspect*tan⁡(\frac{fovy}{2})} &amp;amp; 0 &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; \frac{1}{tan⁡(\frac{fovy}{2})} &amp;amp; 0 &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; \frac{f+n}{n-f} &amp;amp; \frac{2fn}{n-f} \\ 0 &amp;amp; 0 &amp;amp; -1 &amp;amp; 0 \\ \end{matrix} \right] \]&lt;/p&gt;
&lt;p&gt;为了验证其推导是否正确，输出这个camera，查看projectionMatrix，也就是透视投影矩阵：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1000410/202005/1000410-20200504233216966-263627135.png&quot; alt=&quot;imglink6&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;24-视图变换矩阵&quot;&gt;2.4. 视图变换矩阵&lt;/h2&gt;
&lt;p&gt;通过Camera可以设置视图矩阵：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;camera.position.set(0, 0, 100);   //相机的位置
camera.up.set(0, 1, 0);         //相机以哪个方向为上方
camera.lookAt(new THREE.Vector3(1, 2, 3));          //相机看向哪个坐标
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据&lt;a href=&quot;https://www.cnblogs.com/charlee44/p/11623502.html&quot;&gt;《WebGL简易教程(五)：图形变换(模型、视图、投影变换)》&lt;/a&gt;中的描述，可以通过three.js的矩阵运算来推导其视图矩阵：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;var eye = new THREE.Vector3(0, 0, 100);
var up = new THREE.Vector3(0, 1, 0);
var at = new THREE.Vector3(1, 2, 3);

var N = new THREE.Vector3();
N.subVectors(eye, at); 
N.normalize();
var U = new THREE.Vector3();
U.crossVectors(up, N);
U.normalize();
var V = new THREE.Vector3();
V.crossVectors(N, U);
V.normalize();

var R = new THREE.Matrix4();
R.set(U.x, U.y, U.z, 0,
    V.x, V.y, V.z, 0,
    N.x, N.y, N.z, 0,
    0, 0, 0, 1);  

var T = new THREE.Matrix4(); 
T.set(1, 0, 0, -eye.x,
    0, 1, 0, -eye.y,
    0, 0, 1, -eye.z,
    0, 0, 0, 1);  

var V = new THREE.Matrix4();
V.multiplyMatrices(R, T);   
console.log(V); 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其推导公式如下：&lt;/p&gt;
&lt;p&gt;\[V=R^{-1} T^{-1}= \left[ \begin{matrix} Ux &amp;amp; Uy &amp;amp; Uz &amp;amp; 0 \\ Vx &amp;amp; Vy &amp;amp; Vz &amp;amp; 0 \\ Nx &amp;amp; Ny &amp;amp; Nz &amp;amp; 0 \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\ \end{matrix} \right] * \left[ \begin{matrix} 1 &amp;amp; 0 &amp;amp; 0 &amp;amp; -Tx \\ 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; -Ty\\ 0 &amp;amp; 0 &amp;amp; 1 &amp;amp; -Tz\\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1\\ \end{matrix} \right] = \left[ \begin{matrix} Ux &amp;amp; Uy &amp;amp; Uz &amp;amp; -U·T \\ Vx &amp;amp; Vy &amp;amp; Vz &amp;amp; -V·T \\ Nx &amp;amp; Ny &amp;amp; Nz &amp;amp; -N·T \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \\ \end{matrix} \right] \]&lt;/p&gt;
&lt;p&gt;最后输出它们的矩阵值：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1000410/202005/1000410-20200504233232583-1391840860.png&quot; alt=&quot;imglink7&quot;/&gt;&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1000410/202005/1000410-20200504233246394-1861545661.png&quot; alt=&quot;imglink8&quot;/&gt;&lt;/p&gt;
&lt;p&gt;两者的计算结果基本时一致的。需要注意的是Camera中表达视图矩阵的成员变量是Camera.matrixWorldInverse。它的逻辑应该是视图矩阵与模型矩阵互为逆矩阵，模型矩阵也可以称为世界矩阵，那么世界矩阵的逆矩阵就是视图矩阵了。&lt;/p&gt;

&lt;p&gt;可以通过给着色器传值来验证计算的模型视图投影矩阵（以下称MVP矩阵）是否正确。对于一个任何事情都不做的着色器来说：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;vertexShader: ` 
    void main() { 
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );      
    }`
,

fragmentShader: `       
    void main() {    
        gl_FragColor = vec4(0.556, 0.0, 0.0, 1.0)                   
    }`
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;projectionMatrix和modelViewMatrix分别是three.js中内置的投影矩阵和模型视图矩阵。那么可以做一个简单的验证工作，将计算得到的MVP矩阵传入到着色器中，代替这两个矩阵，如果最终得到的值是正确的，那么就说明计算的MVP矩阵是正确的。&lt;/p&gt;
&lt;h2 id=&quot;31-代码&quot;&gt;3.1. 代码&lt;/h2&gt;
&lt;p&gt;实例代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;

&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;Example 01.01 - Basic skeleton&amp;lt;/title&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot; /&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot; src=&quot;../three/three.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot; src=&quot;../three/controls/TrackballControls.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot; src=&quot;../three/libs/stats.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot; src=&quot;../three/libs/util.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot; src=&quot;MatrixDemo.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;../css/default.css&quot;&amp;gt;
&amp;lt;/head&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;!-- Div which will hold the Output --&amp;gt;
    &amp;lt;div id=&quot;webgl-output&quot;&amp;gt;&amp;lt;/div&amp;gt;

    &amp;lt;!-- Javascript code that runs our Three.js examples --&amp;gt;
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
        (function () {
            // contains the code for the example
            init();
        })();
    &amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;

&amp;lt;/html&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;'use strict';

THREE.StretchShader = {

    uniforms: {   
        &quot;sw&quot; : {type:'b', value : false},
        &quot;mvpMatrix&quot; : {type:'m4',value:new THREE.Matrix4()}    
    },

    // 
    vertexShader: `    
        uniform mat4 mvpMatrix;
        uniform bool sw;
        void main() { 
            if(sw) {
                gl_Position = mvpMatrix * vec4( position, 1.0 );  
            }else{
                gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); 
            }       
        }`
    ,

    //
    fragmentShader: `   
        uniform bool sw; 
        void main() {    
            if(sw) {
                gl_FragColor = vec4(0.556, 0.0, 0.0, 1.0); 
            }else {
                gl_FragColor = vec4(0.556, 0.8945, 0.9296, 1.0); 
            }                    
        }`
};


function init() {
    //console.log(&quot;Using Three.js version: &quot; + THREE.REVISION);   

    // create a scene, that will hold all our elements such as objects, cameras and lights.
    var scene = new THREE.Scene();

    // create a camera, which defines where we're looking at.
    var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);

    // position and point the camera to the center of the scene
    camera.position.set(0, 0, 100);   //相机的位置
    camera.up.set(0, 1, 0);         //相机以哪个方向为上方
    camera.lookAt(new THREE.Vector3(1, 2, 3));          //相机看向哪个坐标
 
    // create a render and set the size
    var renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(new THREE.Color(0x000000));
    renderer.setSize(window.innerWidth, window.innerHeight);

    // add the output of the renderer to the html element
    document.getElementById(&quot;webgl-output&quot;).appendChild(renderer.domElement);

    
    // create the ground plane
    var planeGeometry = new THREE.PlaneGeometry(60, 20);
    // var planeMaterial = new THREE.MeshBasicMaterial({
    //     color: 0xAAAAAA
    // });

    var planeMaterial = new THREE.ShaderMaterial({
        uniforms: THREE.StretchShader.uniforms,
        vertexShader: THREE.StretchShader.vertexShader,
        fragmentShader: THREE.StretchShader.fragmentShader
    });

    var plane = new THREE.Mesh(planeGeometry, planeMaterial);

    // add the plane to the scene
    scene.add(plane);

    // rotate and position the plane    
    plane.position.set(15, 8, -10);
    plane.rotation.x = THREE.Math.degToRad(30);
    plane.rotation.y = THREE.Math.degToRad(45);
    plane.rotation.z = THREE.Math.degToRad(60);
 
    render();
  
    var farmeCount = 0;
    function render() {    
        
        var mvpMatrix = new THREE.Matrix4(); 
        mvpMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);    
        mvpMatrix.multiplyMatrices(mvpMatrix, plane.matrixWorld);   
        
        THREE.StretchShader.uniforms.mvpMatrix.value = mvpMatrix; 
        if(farmeCount % 60 === 0){
            THREE.StretchShader.uniforms.sw.value = !THREE.StretchShader.uniforms.sw.value;
        }          
        
        farmeCount = requestAnimationFrame(render);
        renderer.render(scene, camera);
    }
   
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;32-解析&quot;&gt;3.2. 解析&lt;/h2&gt;
&lt;p&gt;这段代码的意思是，给着色器传入了计算好的MVP矩阵变量mvpMatrix，以及一个开关变量sw。开关变量会每60帧变一次，如果为假，会使用内置的projectionMatrix和modelViewMatrix来计算顶点值，此时场景中的物体颜色会显示为蓝色；如果开关变量为真，则会使用传入的计算好的mvpMatrix计算顶点值，此时场景中的物体颜色会显示为红色。运行截图如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1000410/202005/1000410-20200504233258032-171347303.gif&quot; alt=&quot;imglink9&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到场景中的物体的颜色在红色与蓝色之间来回切换，且物体位置没有任何变化，说明我们计算的MVP矩阵是正确的。&lt;/p&gt;

&lt;p&gt;在使用JS的console.log()进行打印camera对象的时候，会发现如果不调用render()的话（或者单步调式），其内部的matrix相关的成员变量仍然是初始化的值，得不到想要的结果。而console.log()可以认为是异步的，调用render()之后，就可以得到正确的camera对象了。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Mon, 04 May 2020 15:38:00 +0000</pubDate>
<dc:creator>charlee44</dc:creator>
<og:description>通过具体的实例，详细验证了webGL/three.js中的矩阵变换(模型视图投影变换)。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/charlee44/p/12828887.html</dc:identifier>
</item>
<item>
<title>Spring IOC的核心机制：实例化与注入 - 测试轩</title>
<link>http://www.cnblogs.com/zyjimmortalp/p/12828726.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyjimmortalp/p/12828726.html</guid>
<description>&lt;p&gt;上文我们介绍了IOC和DI，IOC是一种设计模式，DI是它的具体实现，有很多的框架都有这样的实现，本文主要以spring框架的实现，来看具体的注入实现逻辑。&lt;/p&gt;

&lt;p&gt;spring将对象加入容器的方式有很多种，最主要的是xml和注解的形式，而当下注解的形式应用更加的广泛，所以这里我们也主要介绍注解注入模式下的相关知识点。&lt;/p&gt;
&lt;p&gt;spring下的注解也是有很多种的，其中应用最为广泛的就是模式注解。&lt;/p&gt;
&lt;h2 id=&quot;模式注解-stereotype-annotations&quot;&gt;模式注解 stereotype annotations&lt;/h2&gt;
&lt;p&gt;咋一看，这是啥，说实话我也不太清楚，官方说的就叫这哈，其实他说的就是平时最常用的那些 &lt;code&gt;@Component @Service @Controller @Repository @Configuration&lt;/code&gt; 注解。&lt;/p&gt;
&lt;p&gt;如果一个类被打上 &lt;code&gt;@Component&lt;/code&gt;注解，那他就会被容器扫描到并加入到容器里去。那这里我们用spring的方式再来实现一下上篇文章的获取英雄的需求。&lt;/p&gt;
&lt;p&gt;先给 &lt;code&gt;Diana&lt;/code&gt;这个英雄打上一个 &lt;code&gt;@Component&lt;/code&gt;注解：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class Diana{
    private String skillName = &quot;Diana R&quot;;

    public Diana() {
    }

    public void q(){
        System.out.println(&quot;Diana Q&quot;);
    }

    public void w(){
        System.out.println(&quot;Diana W&quot;);
    }

    public void e(){
        System.out.println(&quot;Diana E&quot;);
    }

    public void r(){
        System.out.println(this.skillName);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设现在有一个Controller需要用到 &lt;code&gt;Diana&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RestController
public class BannerController {

    @Autowired
    private Diana diana;

    @RequestMapping(value = &quot;/v2/banner&quot;, method = {RequestMethod.GET})
    public String test() {
        diana.r();
        return &quot;Hello SpringBoot&quot;;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;@Autowired&lt;/code&gt;的意思就是说在这里注入一个对象，然后我们启动应用，&lt;/p&gt;
&lt;p&gt;通过浏览器访问 &lt;code&gt;http://localhost:8081/v2/banner&lt;/code&gt;，会发现在控制台会输出 &lt;code&gt;Diana&lt;/code&gt;的r方法的打印内容，说明这里确实拿到了 &lt;code&gt;Diana&lt;/code&gt;这个对象。&lt;/p&gt;

&lt;p&gt;如果我们把 &lt;code&gt;Diana&lt;/code&gt;的 &lt;code&gt;@Component&lt;/code&gt;注解去掉，其他地方不变，再运行程序会发生什么，试试看。&lt;/p&gt;
&lt;p&gt;重新启动的时候会提示我们下面的错误：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1960827/202005/1960827-20200504225856487-1319850683.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看错误提示，说程序没有找到对应的bean，就是说我这里要注入bean了，但是在容器里没有找到。&lt;/p&gt;
&lt;p&gt;这里就会得出一个结论：&lt;strong&gt;容器在初始化后就会给相应的代码片段进行对象的注入&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;从提示信息中可以看到Autowired(required=true)，这里设置的默认是true，表示注入的时候，该对象必须存在，否则就会注入失败。当然这里可设置不报错，Autowired(required=false),这个时候再启动就不会报错了，但是在访问的时候会报空指针异常。&lt;/p&gt;
&lt;p&gt;那这里spring的容器究竟是在什么时候实例化的对象呢,是在访问controller的时候呢，还是在容器启动的时候呢？我们可以通过下面的手段检测一下，在 &lt;code&gt;Diana&lt;/code&gt;的无参构造方法中放一个打印语句，然后再启动程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public Diana() {
    System.out.println(&quot;I am Diana&quot;);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序启动以后，会看到在控制台会显示出构造方法中打印的语句&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1960827/202005/1960827-20200504225858470-1519775606.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就说明在容器启动后把类加载到容器以后，就会实例化一个对象出来。这就又得出一个结论：&lt;strong&gt;容器初始化以后就会对bean进行实例化&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;上面提到容器在确定后就会把对象(也就是bean)实例化，那有没有办法让他不马上实例化？&lt;/p&gt;
&lt;p&gt;spring提供了@Lazy这个注解，用以表明某个bean可以延迟加载，用之前的 &lt;code&gt;Diana&lt;/code&gt;延时一下，给他加上@Lazy这个注解：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
@Lazy
public class Diana{
    private String skillName = &quot;Diana R&quot;;

    public Diana() {
        System.out.println(&quot;I am Diana&quot;);
    }

    public void q(){
        System.out.println(&quot;Diana Q&quot;);
    }

    public void w(){
        System.out.println(&quot;Diana W&quot;);
    }

    public void e(){
        System.out.println(&quot;Diana E&quot;);
    }

    public void r(){
        System.out.println(this.skillName);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次启动程序，会发现在控制台还是会执行构造方法里的打印语句，这是什么情况，不是明明已经加了延迟加载了么？&lt;/p&gt;
&lt;p&gt;这里会设计到spring的一个机制，就是说如果某个bean没有设置延迟加载，这个bean会在容器启动就实例化，并且这个bean里面所依赖的其他bean都会进行过实例化，即使设置了懒加载。&lt;/p&gt;
&lt;p&gt;我们在BannerController里用到了 &lt;code&gt;Diana&lt;/code&gt;这个bean，并把它设置了延迟加载，但是并没有把BannerController也设置成延迟加载，所以容器再实例化BannerController的时候同样会 &lt;code&gt;Diana&lt;/code&gt;这个bean进行实例化。如果要真正做到延迟加载，需要让BannerController也要延迟加载。给它加上@Lazy以后，再启动看一下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1960827/202005/1960827-20200504225859507-1519722427.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候控制就没有那条打印语句的输出内容了，此时我们通过浏览器来访问BannerController的路由，此时就会在控制台输出构造方法里打印语句的输出内容了。&lt;/p&gt;

&lt;p&gt;上文 &lt;code&gt;Diana&lt;/code&gt;的就是一个单独的类，没有实现任何接口，这种实现方式他是有问题的，很难进行扩展，这里不应该一类具体的实现类，而是要应该依赖抽象，这样才能满足开闭原则，让程序具有良好的扩展性。&lt;/p&gt;
&lt;p&gt;这里让 &lt;code&gt;Diana&lt;/code&gt;实现了一 &lt;code&gt;Skill&lt;/code&gt;接口，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public interface Skill {
    void q();
    void w();
    void e();
    void r();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在BannerController注入这里也要改一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Autowired
private Skill diana;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行程序，发先能够运行成功,如果新添加一个英雄的实现类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class Irelia implements Skill {

    public Irelia() {
        System.out.println(&quot;Hello, Irelia&quot;);
    }
    public void q(){
        System.out.println(&quot;Irelia Q&quot;);
    }

    public void w(){
        System.out.println(&quot;Irelia W&quot;);
    }

    public void e(){
        System.out.println(&quot;Irelia E&quot;);
    }

    public void r(){
        System.out.println(&quot;Irelia R&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们再去运行程序，发现还是能运行成功，并且发现注入的是 &lt;code&gt;Diana&lt;/code&gt;而不是 &lt;code&gt;Irelia&lt;/code&gt;,那这里我们可能会问为什么呀，前面好像也没指定注入哪个实现类。&lt;/p&gt;
&lt;p&gt;难道是因为 &lt;code&gt;private Skill diana;&lt;/code&gt;这里写了 &lt;code&gt;diana&lt;/code&gt;么？你还别说，还真是这个原因，这里涉及到spring的注入机制了。&lt;/p&gt;
&lt;p&gt;当spring的IOC容器注入bean的时候，如果发现有多个相同类型的bean时，就会去看它们的名称(name)，如果名称符合要求，就会注入这个名称的bean。每个被容器扫描到的bean都会有一个默认的name，就是它的类名，首字母会小写，比如我们实例中的：BannerController的name就是bannerController，Irelia就是irelia。&lt;/p&gt;
&lt;p&gt;可以试着把 &lt;code&gt;private Skill diana&lt;/code&gt;改成 &lt;code&gt;private Skill skill&lt;/code&gt;，再次运行，就会发生报错：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1960827/202005/1960827-20200504225859891-1619608050.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;提示你找不到响应的bean。这里要明确一点哈，虽然报错了，但是这种写法是标准的，上面那个直接写实现类的名字不是标准的写法。&lt;/p&gt;
&lt;p&gt;那怎么解决这个找不到的问题呢？&lt;/p&gt;
&lt;p&gt;spring提供了一个@Qualifier的注解，给他传入要注入bean的名字，就可以指定注入的bean，@Qualifier(&quot;irelia&quot;)。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;Autowired的注入方式有两种，一种是按照类型注入，一种是按照名称注入，默认是按照类型注入，如果只有一个实现类 &lt;code&gt;Diana&lt;/code&gt;，这里写成 &lt;code&gt;private Skill skill&lt;/code&gt;，运行程序，你会发现是能够注入成功的。因为Skill类型下只有一个实现类，自然就是注入它了。如果有多个实现类，那就会先按照这个类型查找，这个类型下所有到的实现类再按照名称查找，直至找到符合要求的，找不到就报错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;更多关于spring IOC内容，请查看(博客网站)[&lt;a href=&quot;https://www.immortalp.com&quot;&gt;https://www.immortalp.com&lt;/a&gt;]&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.3258426966292&quot;&gt;
&lt;p&gt;欢迎大家去 &lt;a href=&quot;https://www.immortalp.com&quot;&gt;我的博客&lt;/a&gt; 瞅瞅，里面有更多关于测试实战的内容哦！！&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Mon, 04 May 2020 14:59:00 +0000</pubDate>
<dc:creator>测试轩</dc:creator>
<og:description>上文我们介绍了IOC和DI，IOC是一种设计模式，DI是它的具体实现，有很多的框架都有这样的实现，本文主要以spring框架的实现，来看具体的注入实现逻辑。 spring是如何将对象加入容器的 spr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zyjimmortalp/p/12828726.html</dc:identifier>
</item>
<item>
<title>安装KubeSphere - 废物大师兄</title>
<link>http://www.cnblogs.com/cjsblog/p/12828639.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cjsblog/p/12828639.html</guid>
<description>&lt;p&gt;&lt;span&gt;1. KubeSphere 是什么&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504211150291-783308946.png&quot; alt=&quot;&quot; width=&quot;1093&quot; height=&quot;570&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.1. 官方解释&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KubeSphere是一个分布式操作系统，提供以Kubernetes为核心的云原生堆栈，旨在成为第三方应用程序的即插即用架构，以促进其生态系统的发展。 KubeSphere还是一个多租户企业级容器平台，具有全栈自动IT操作和简化的DevOps工作流程。它提供了开发人员友好的向导Web UI，可帮助企业构建更健壮且功能丰富的平台，其中包括企业Kubernetes战略所需的最常用功能，例如Kubernetes资源管理，DevOps（CI / CD），应用程序生命周期管理、监控、日志记录、服务网格、多租户、报警和通知,存储和网络、自动定量、访问控制、GPU的支持等，以及多集群管理、网络策略、注册表管理，更多即将发布的安全增强特性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KubeSphere提供了整合的视图，同时围绕Kubernetes集成了广泛的生态系统工具，并提供一致的用户体验以降低复杂性，并开发了上游Kubernetes中尚不可用的新功能，以减轻Kubernetes的痛苦之处，包括存储，网络 ，安全性和易用性。 KubeSphere不仅允许开发人员和DevOps团队在统一控制台中使用他们喜欢的工具，而且最重要的是，由于这些功能是可插拔和可选的，因此它们与平台松散地结合在一起。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Kubernetes平台，专为DevOps团队量身定制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KubeSphere，以应用为中心的容器平台&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;极简、易用、灵活、高效&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;关于KubeSphere，最好最全面最通俗易懂的一篇文章是《&lt;span&gt;&lt;a href=&quot;https://kubesphere.io/zh-CN/blog/kubesphere-values/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;一文说清 KubeSphere 容器平台的价值&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;》&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://kubesphere.io/zh-CN/blog/kubesphere-values/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://kubesphere.io/zh-CN/blog/kubesphere-values/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504211258727-1673623733.png&quot; alt=&quot;&quot; width=&quot;790&quot; height=&quot;846&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.2. 个人理解&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;&lt;span&gt;KubeSphere，这是国内唯一一个开源的Kubernetes（k8s）发行版，它的开源不涉及任何商业意图，它不属于青云而属于社区，它极大地降低了使用Kubernetes的门槛，它的出现将加速中国企业向云原生迈进的步伐。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;“发行版”的说法常用于Linux操作系统。比如，虽有Linux内核，而Ubuntu、CentOS等等叫做Linux发行版，对应的，Kubernetes就相当于内核，KubeSphere就是Kubernetes的发行版，正常人类是很难使用Linux内核和Kubenetes的，为了让大家用起来，要基于Linux内核和Kubernetes做很多周边配套，Linux和Kubenetes就好像一台光秃秃的汽车发动机，为了把它当车开，你起码得有车架子、轮胎、方向盘、刹车、……等等。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，开源KubeSphere的青云就像一个汽车厂，负责KubeSphere牌汽车各个组件的组装搭配，不过，这个汽车不需要花钱就能获取到，这就是青云开源KubeSphere的实质。它的意义在于加快了大家使用k8s发动机的进程，让大家都能开上KubeSphere牌汽车。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;云原生能帮助企业做数字化转型，帮助企业用数字化转型获取竞争力。而KubeSphere可以让企业更快地上原生，开上汽车。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;span&gt;以上摘抄自https://tech.ifeng.com/c/7u6tUXwXbJU&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我觉得，读完以后，醍醐灌顶，茅塞顿开&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们使用Linux的各种发行版（比如：CentOS、Ubuntu等）与Linux内核交互，极大地降低了使用Linux的门槛，而且像Ubuntu还提供了特别漂亮的桌面版，图像界面式的操作使用起来更方便。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们当然可以使用CMD命令行窗口同Windows系统交互，所有在图形界面上完成的操作都可以通过命令行完成，但是这种操作方式的门槛极高，不利于微软推行Windows桌面操作系统。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;同样的，Kubenetes就相当于内核，而KubeSphere就相当于是Kubernetes的发行版。KubeSphere提供极简体验，向导式UI，极大的降低了使用Kubenetes的门槛。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;记不住Kubenetes命令不要紧，不会写Dockerfile也没关系，使用KubeSphere图像界面以后一起都变得简单了，而且它是以应用为中心的，极大地解放了运维和开发人员的生产力。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;KubeSphere就是Java编程界的Spring。想想看，用了Spring以后你不需要关心各种数据库的连接，各种各样的组件都帮你集成好了，拿来就用。KubeSphere也是一样，开箱即用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2. 安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;就一条命令，挺简单的，但是我装了两天两夜。期间，虚拟机装了好几遍，KubeSphere也重装了很多遍，一遍就是几个小时……&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;话不多说，官方文档（中/英文版）都写的非常清楚，开始安装&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;由于资源限制，我只能在虚拟机里装，这里选择All-in-One模式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先，一定一定要看清楚系统要求，之前用CentOS没装成功，试了很多版本，最后老老实实用Ubuntu18.04&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://ubuntu.com/download/alternative-downloads&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://ubuntu.com/download/alternative-downloads&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504211719571-671922600.png&quot; alt=&quot;&quot; width=&quot;844&quot; height=&quot;173&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下载安装包&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
curl -L https://kubesphere.io/download/stable/v2.1.1 &amp;gt; installer.tar.gz \
&amp;amp;&amp;amp; tar -zxf installer.tar.gz &amp;amp;&amp;amp; cd kubesphere-all-v2.1.1/scripts
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;在安装前一定一定要记得配置镜像加速器 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;例如阿里云容器镜像加速器服务 &lt;span&gt;&lt;a href=&quot;https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
docker_registry_mirrors:
  - https://docker.mirrors.ustc.edu.cn
  - https://registry.docker-cn.com
  - https://mirror.aliyuncs.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;~/kubesphere-all-v2.1.1/conf/common.yaml&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504212941433-1209940929.png&quot; alt=&quot;&quot; width=&quot;931&quot; height=&quot;128&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504212952670-786468921.png&quot; alt=&quot;&quot; width=&quot;896&quot; height=&quot;392&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;执行./install.sh就等着吧（如果要重新安装建议先执行./uninstall.sh）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装了两天，终于看到期待已久的画面了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504213500785-620079483.png&quot; alt=&quot;&quot; width=&quot;944&quot; height=&quot;633&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;各种验证&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://kubesphere.io/docs/installation/verify-components/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://kubesphere.io/docs/installation/verify-components/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://kubesphere.io/docs/zh-CN/installation/verify-components/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://kubesphere.io/docs/zh-CN/installation/verify-components/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504213817353-17179301.png&quot; alt=&quot;&quot; width=&quot;937&quot; height=&quot;586&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504214212614-1621753670.png&quot; alt=&quot;&quot; width=&quot;992&quot; height=&quot;655&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504214242064-1802311353.png&quot; alt=&quot;&quot; width=&quot;996&quot; height=&quot;657&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504214313400-2000935814.png&quot; alt=&quot;&quot; width=&quot;997&quot; height=&quot;658&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;安装完以后，一看资源占用情况，吓一跳，果然只适合企业用户&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504214540546-2065592601.png&quot; alt=&quot;&quot; width=&quot;990&quot; height=&quot;107&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504214557310-1926649706.png&quot; alt=&quot;&quot; width=&quot;987&quot; height=&quot;83&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504214618290-1519946975.png&quot; alt=&quot;&quot; width=&quot;968&quot; height=&quot;497&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504214633984-1417731535.png&quot; alt=&quot;&quot; width=&quot;958&quot; height=&quot;201&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;3. 遇到的问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://kubesphere.io/docs/troubleshooting/installation/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://kubesphere.io/docs/troubleshooting/installation/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;1、container in pod is not available&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
Error from server (BadRequest): container &quot;installer&quot; in pod &quot;ks-installer-7d9fb945c7-6tnl9&quot; is not available　　
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;检查安装日志 ~/kubesphere-all-v2.1.1/logs&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;有一个非常好用的命令是  &lt;span&gt;journalctl -xefu kubelet&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、如何重启 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/874963/202005/874963-20200504220852414-1416633295.png&quot; alt=&quot;&quot; width=&quot;856&quot; height=&quot;243&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、如何重启Kubernetes集群&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我一直有个疑问，如果物理机或者Kubernetes的宿主机宕机或重启以后Kubernetes集群会自动重启吗？如果挂的是master所在的机器，很显然是不会的， 但如果是非master的节点的话不知道没试过。所以，Kubernetes集群的高可用就非常重要了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/high-availability/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ReplicationController确保在任何时候都运行指定数量的pod副本。换句话说，ReplicationController确保一个pod或一组同类的pod总是处于可用状态。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我忽略了Kubernetes有很强的自愈能力&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;自愈（自我修复）：重新启动失败的容器，在节点死亡时替换和重新调度容器，杀死那些不响应用户定义的健康检查的容器，并且在它们准备好提供服务之前不会向客户端通知它们。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在后面安装KubeSphere可插拔的功能组件时，更改common.yaml配置文件后，不需要做什么操作，过一会儿会自动更新容器以应用这些改变。&lt;/span&gt; &lt;/p&gt;

&lt;p&gt;&lt;span&gt;备忘录&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
kubectl get pods --all-namespaces
kubectl get pod -n &amp;lt;namespace&amp;gt;
kubectl logs &amp;lt;pod_name&amp;gt; -n &amp;lt;namespace&amp;gt;

kubectl delete pod &amp;lt;pod_name&amp;gt; -n &amp;lt;namespace&amp;gt;

# 查询systemd日志
journalctl -xefu kubelet

kubectl get services
kubectl get deployments

kubectl cluster-info
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4. 文档&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://kubesphere.io/docs/installation/intro/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://kubesphere.io/docs/installation/intro/&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://kubesphere.io/docs/zh-CN&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://kubesphere.io/docs/zh-CN&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a href=&quot;https://kubesphere.io/docs/zh-CN/installation/intro/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://kubesphere.io/docs/zh-CN/installation/intro/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://kubesphere.io/zh-CN/blogs/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://kubesphere.io/zh-CN/blogs/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://kubesphere.io/zh-CN/blog/kubesphere-values/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://kubesphere.io/zh-CN/blog/kubesphere-values/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://kubesphere.io/docs/zh-CN/introduction/what-is-kubesphere/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://kubesphere.io/docs/zh-CN/introduction/what-is-kubesphere/&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a href=&quot;https://www.kubernetes.org.cn/author/kubesphere&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.kubernetes.org.cn/author/kubesphere&lt;/span&gt;&lt;/a&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 May 2020 14:50:00 +0000</pubDate>
<dc:creator>废物大师兄</dc:creator>
<og:description>1. KubeSphere 是什么 1.1. 官方解释 KubeSphere是一个分布式操作系统，提供以Kubernetes为核心的云原生堆栈，旨在成为第三方应用程序的即插即用架构，以促进其生态系统的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cjsblog/p/12828639.html</dc:identifier>
</item>
<item>
<title>广度优先搜索原理与实践 - huansky</title>
<link>http://www.cnblogs.com/huansky/p/12826857.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huansky/p/12826857.html</guid>
<description>&lt;h2&gt;概论&lt;/h2&gt;
&lt;p&gt;在 &lt;strong&gt;&lt;span&gt;&lt;a id=&quot;cb_post_title_url&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/huansky/p/12821889.html&quot;&gt;&lt;span&gt;深度优先搜索原理与实践（java&lt;/span&gt;&lt;/a&gt;）&lt;/span&gt;&lt;/strong&gt;文章介绍了深度优先搜索算法的理论和实践。本文将介绍与其原理类似的广度优先搜索算法。&lt;/p&gt;
&lt;p&gt;广度优先搜索（也称宽度优先搜索，缩写 BFS，以下采用广度来描述）是连通图的一种遍历算法这一算法也是很多重要的图的算法的原型。Dijkstra 单源最短路径算法和 Prim 最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫 BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。基本过程，BFS 是从根节点开始，沿着树(图)的宽度遍历树(图)的节点。如果所有节点均被访问，则算法中止。一般用队列数据结构来辅助实现 BFS 算法。&lt;/p&gt;
&lt;h2&gt;基本原理&lt;/h2&gt;
&lt;p&gt;对于下面的树而言，BFS 方法首先从根节点1开始，其搜索节点顺序是 1,2,3,4,5,6,7,8。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1402876/201812/1402876-20181210165600134-1573458941.png&quot; alt=&quot;&quot; width=&quot;262&quot; height=&quot;252&quot;/&gt;&lt;/p&gt;

&lt;p&gt;BFS 使用队列 (queue) 来实施算法过程，队列 (queue) 有着先进先出 FIFO (First Input First Output)的特性，&lt;/p&gt;
&lt;p&gt;BFS 操作步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li&gt;从queue中取出队列头的点；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;
&lt;ul&gt;&lt;li class=&quot;_mce_tagged_br&quot;&gt;找出与此点邻接的且尚未遍历的点，进行标记，然后全部放入queue中。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面结合一个图 (graph) 的实例，说明 BFS 的工作过程和原理：&lt;br/&gt;（1）将起始节点1放入队列中，标记为已遍历：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1402876/201812/1402876-20181210165653157-1845400317.png&quot; alt=&quot;&quot; width=&quot;429&quot; height=&quot;216&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （2）从queue中取出队列头的节点1，找出与节点1邻接的节点2,3，标记为已遍历，然后放入queue中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1402876/201812/1402876-20181210165724498-649889295.png&quot; alt=&quot;&quot; width=&quot;431&quot; height=&quot;217&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）从queue中取出队列头的节点2，找出与节点2邻接的节点1,4,5，由于节点1已遍历，排除；标记4,5为已遍历，然后放入queue中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1402876/201812/1402876-20181210165806664-2133405348.png&quot; alt=&quot;&quot; width=&quot;435&quot; height=&quot;219&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（4）从queue中取出队列头的节点3，找出与节点3邻接的节点1,6,7，由于节点1已遍历，排除；标记6,7为已遍历，然后放入queue中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1402876/201812/1402876-20181210165834870-1441419488.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（5）从queue中取出队列头的节点4，找出与节点4邻接的节点2,8，2属于已遍历点，排除；因此标记节点8为已遍历，然后放入queue中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1402876/201812/1402876-20181210165909853-2079926370.png&quot; alt=&quot;&quot; width=&quot;439&quot; height=&quot;221&quot;/&gt;&lt;/p&gt;

&lt;p&gt;（6）从queue中取出队列头的节点5，找出与节点5邻接的节点2,8，2,8均属于已遍历点，不作下一步操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1402876/201812/1402876-20181210165934996-1890637570.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;224&quot;/&gt; &lt;/p&gt;
&lt;p&gt;（7）从queue中取出队列头的节点6，找出与节点6邻接的节点3,8,9，3,8属于已遍历点，排除；因此标记节点9为已遍历，然后放入queue中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1402876/201812/1402876-20181210165955795-736888343.png&quot; alt=&quot;&quot; width=&quot;446&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（8）从queue中取出队列头的节点7，找出与节点7邻接的节点3, 9，3,9属于已遍历点，不作下一步操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1402876/201812/1402876-20181210170014205-1659656728.png&quot; alt=&quot;&quot; width=&quot;446&quot; height=&quot;225&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（9）从queue中取出队列头的节点8，找出与节点8邻接的节点4,5,6，4,5,6属于已遍历点，不作下一步操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1402876/201812/1402876-20181210170031323-1591604088.png&quot; alt=&quot;&quot; width=&quot;445&quot; height=&quot;224&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（10）从queue中取出队列头的节点9，找出与节点9邻接的节点6,7，6,7属于已遍历点，不作下一步操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1402876/201812/1402876-20181210170050346-1329481029.png&quot; alt=&quot;&quot; width=&quot;443&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（11）queue 为空，则遍历结束&lt;/p&gt;
&lt;p&gt;上面过程可以用下面的代码来表示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;private&lt;/span&gt; Map&amp;lt;String, Boolean&amp;gt; status = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;String, Boolean&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Queue&amp;lt;String&amp;gt; queue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;String&amp;gt;&lt;span&gt;();
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; BFSSearch(String startPoint) {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1.把起始点放入queue；&lt;/span&gt;
&lt;span&gt;        queue.add(startPoint);
        status.put(startPoint, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
        bfsLoop();
    }
    
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; bfsLoop() {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;queue.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  1) 从queue中取出队列头的点；更新状态为已经遍历。&lt;/span&gt;
            String currentQueueHeader = queue.poll(); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;出队&lt;/span&gt;
            status.put(currentQueueHeader, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
            System.out.println(currentQueueHeader);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  2) 找出与此点邻接的且尚未遍历的点，进行标记，然后全部放入queue中。&lt;/span&gt;
            List&amp;lt;String&amp;gt; neighborPoints =&lt;span&gt; graph.get(currentQueueHeader);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (String poinit : neighborPoints) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!status.getOrDefault(poinit, &lt;span&gt;false&lt;/span&gt;)) { &lt;span&gt;//&lt;/span&gt;&lt;span&gt;未被遍历&lt;/span&gt;
                    &lt;span&gt;if&lt;/span&gt; (queue.contains(poinit)) &lt;span&gt;continue&lt;/span&gt;&lt;span&gt;;
                    queue.add(poinit);
                    status.put(poinit, &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
                }
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;通用框架&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;其通用框架可以概括为：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;void&lt;/span&gt;&lt;span&gt; bfs(起始点) {
    将起始点放入队列中;
    标记起点访问;
    &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;&lt;span&gt; (如果队列不为空) {  &lt;span&gt;// 一般采用while ，当然也可以使用递归&lt;/span&gt;
        访问队列中队首元素x;
        删除队首元素;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt; (x 所有相邻点) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (该点未被访问过且合法) {
                将该点加入队列末尾;
            　　&lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;  (该结点是目标状态) { &lt;span&gt; // 达到目标，提前结束终止循环&lt;/span&gt;
                    置 flag&lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;;    &lt;br/&gt;&lt;span&gt;　　　　　　　　　　　　break&lt;/span&gt;&lt;span&gt;; 
               }
            }
        }
    }
    队列为空，广搜结束;
}                        &lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;下面来总结下写出 BFS 算法规则：&lt;/p&gt;
&lt;p&gt;通过这个 bfs 框架可以看出该方法主要有以下几个规律：&lt;/p&gt;
&lt;ol readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;起点条件。&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;从哪个点开始访问？是否每个点都需要当作起点？第一次 bfs 调用至关重要。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;邻接点。&lt;/strong&gt;&lt;/span&gt;如何去获取邻接点？通过起点可到达的点。如何保存邻接点？先进先出。一般采用队列。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;循环参数。&lt;/strong&gt;&lt;/span&gt;队列不为空。一个点的所有邻接点都是在一个 while 里面进行添加的，才会进入&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;strong&gt;访问标志。&lt;/strong&gt;&lt;/span&gt;&lt;/strong&gt;为了避免重复访问，需要对已经访问过的节点加上标记，避免重复访问。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;讲完了理论，下面开始进入实战。&lt;/p&gt;

&lt;p&gt;给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。&lt;/p&gt;
&lt;p&gt;岛屿总是被水包围，并且每座岛屿只能由水平方向或竖直方向上相邻的陆地连接形成。&lt;/p&gt;
&lt;p&gt;此外，你可以假设该网格的四条边均被水包围。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
// 输入:
11110
11010
11000
00000
// 输出: 1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;示例 2:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
// 输入:
11000
11000
00100
00011
// 输出: 3
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释: 每座岛屿只能由水平和/或竖直方向上相邻的陆地连接而成。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;题目解答如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; numIslands(&lt;span&gt;char&lt;/span&gt;&lt;span&gt;[][] grid) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (grid == &lt;span&gt;null&lt;/span&gt; || grid.length &amp;lt; 1 || grid[0].length&amp;lt;1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nr =&lt;span&gt; grid.length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nc = grid[0&lt;span&gt;].length;&lt;br/&gt;&lt;span&gt;　　　　　// 每个点都可能是起点
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x =0;x&amp;lt;nr;x++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; y =0;y&amp;lt;nc;y++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (grid[x][y]=='1'&lt;span&gt;) {
                    bfs(grid,x,y);
                    num&lt;/span&gt;++&lt;span&gt;;
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num;
        
    }
&lt;span&gt;　　 // 对于 bfs 来说，只要队列不为空，就可以一直走到头,
    &lt;/span&gt;&lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; bfs(&lt;span&gt;char&lt;/span&gt;[][] grid, &lt;span&gt;int&lt;/span&gt; r, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; c) {
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nr =&lt;span&gt; grid.length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nc = grid[0&lt;span&gt;].length;&lt;br/&gt;&lt;span&gt;　　　　  // 队列，用于保存邻接点
&lt;/span&gt;        Queue&lt;/span&gt;&amp;lt;Integer&amp;gt; neighbors = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();&lt;br/&gt;&lt;span&gt;　　　　　// 这里可以学下，对于二维可以将坐标转化为一个数字
&lt;/span&gt;        neighbors.add(r &lt;/span&gt;* nc +&lt;span&gt; c); 
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt; (!&lt;span&gt;neighbors.isEmpty()) {&lt;br/&gt;&lt;span&gt;　　　　　　　// 每次循环开始的时候，需要移出一个点
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; id =&lt;span&gt; neighbors.remove();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; row = id /&lt;span&gt; nc;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; col = id %&lt;span&gt; nc;&lt;br/&gt;&lt;span&gt;　　　　　　　// 四个邻接点都是在一个while循环里的
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (row - 1 &amp;gt;= 0 &amp;amp;&amp;amp; grid[row-1][col] == '1'&lt;span&gt;) {
                neighbors.add((row&lt;/span&gt;-1) * nc +&lt;span&gt; col);
                grid[row&lt;/span&gt;-1][col] = '0'&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (row + 1 &amp;lt; nr &amp;amp;&amp;amp; grid[row+1][col] == '1'&lt;span&gt;) {
                neighbors.add((row&lt;/span&gt;+1) * nc +&lt;span&gt; col);
                grid[row&lt;/span&gt;+1][col] = '0'&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (col - 1 &amp;gt;= 0 &amp;amp;&amp;amp; grid[row][col-1] == '1'&lt;span&gt;) {
                neighbors.add(row &lt;/span&gt;* nc + col-1&lt;span&gt;);
                grid[row][col&lt;/span&gt;-1] = '0'&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (col + 1 &amp;lt; nc &amp;amp;&amp;amp; grid[row][col+1] == '1'&lt;span&gt;) {
                neighbors.add(row &lt;/span&gt;* nc + col+1&lt;span&gt;);
                grid[row][col&lt;/span&gt;+1] = '0'&lt;span&gt;;
            }
        }
    }
}&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;给定一个包含了一些 0 和 1 的非空二维数组 grid 。&lt;/p&gt;
&lt;p&gt;一个 岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在水平或者竖直方向上相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。&lt;/p&gt;
&lt;p&gt;找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为 0 。)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;137&quot;&gt;
&lt;pre&gt;
[[0,0,1,0,0,0,0,1,0,0,0,0,0],
[0,0,0,0,0,0,0,1,1,1,0,0,0],
[0,1,1,0,1,0,0,0,0,0,0,0,0],
[0,1,0,0,1,1,0,0,1,0,1,0,0],
[0,1,0,0,1,1,0,0,1,1,1,0,0],
[0,0,0,0,0,0,0,0,0,0,1,0,0],
[0,0,0,0,0,0,0,1,1,1,0,0,0],
[0,0,0,0,0,0,0,1,1,0,0,0,0]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于上面这个给定矩阵应返回 6。注意答案不应该是 11 ，因为岛屿只能包含水平或垂直的四个方向的 1 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
[[0,0,0,0,0,0,0,0]]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于上面这个给定的矩阵, 返回 0。&lt;/p&gt;
&lt;p&gt;注意: 给定的矩阵grid 的长度和宽度都不超过 50。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;这道题目和上面的很类似。题目解答如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Solution {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; maxAreaOfIsland(&lt;span&gt;int&lt;/span&gt;&lt;span&gt;[][] grid) {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (grid == &lt;span&gt;null&lt;/span&gt; || grid.length &amp;lt;1 || grid[0].length&amp;lt;1&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; 0&lt;span&gt;;
        }
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rx =&lt;span&gt; grid.length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cy = grid[0&lt;span&gt;].length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; max = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; x =0; x&amp;lt; rx; x++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; y= 0;y&amp;lt;cy; y++&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (grid[x][y]==1&lt;span&gt;) {
                    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num =&lt;span&gt; bfs(grid,x,y);
                    max &lt;/span&gt;=&lt;span&gt; Math.max(max, num);
                }
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; max;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;  bfs (&lt;span&gt;int&lt;/span&gt;[][] grid, &lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y){
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; rx =&lt;span&gt; grid.length;
        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; cy = grid[0&lt;span&gt;].length;&lt;br/&gt;&lt;span&gt;　　　　　// 每次调用就是一个面积
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;int&lt;/span&gt; num = 1&lt;span&gt;;
        grid[x][y] &lt;/span&gt;= 0&lt;span&gt;;
        Queue&lt;/span&gt;&amp;lt;Integer&amp;gt; neQueue = &lt;span&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;&lt;span&gt;();&lt;br/&gt;&lt;span&gt;　　　　　// 这里注意乘以的是col的长度
&lt;/span&gt;        neQueue.add(x&lt;/span&gt;*cy +&lt;span&gt; y);&lt;br/&gt;&lt;span&gt;　　　　 // 队列不为空
        &lt;/span&gt;&lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(!&lt;span&gt;neQueue.isEmpty()) {
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; point =&lt;span&gt; neQueue.remove();
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; nx = point /&lt;span&gt; cy;
            &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; ny = point %&lt;span&gt; cy;&lt;br/&gt;&lt;span&gt;　　　　　　　// 每一个方向都要判断边界
            &lt;/span&gt;&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nx - 1 &amp;gt;= 0 &amp;amp;&amp;amp; grid[nx-1][ny] == 1&lt;span&gt;) {
                neQueue.add((nx&lt;/span&gt;-1) * cy +&lt;span&gt; ny);
                grid[nx&lt;/span&gt;-1][ny] = 0&lt;span&gt;;
                num&lt;/span&gt;++&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (nx + 1 &amp;lt; rx &amp;amp;&amp;amp; grid[nx+1][ny] == 1&lt;span&gt;) {
                neQueue.add((nx&lt;/span&gt;+1) * cy +&lt;span&gt; ny);
                grid[nx&lt;/span&gt;+1][ny] = 0&lt;span&gt;;
                num&lt;/span&gt;++&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ny - 1 &amp;gt;= 0 &amp;amp;&amp;amp; grid[nx][ny-1] == 1&lt;span&gt;) {
                neQueue.add(nx &lt;/span&gt;* cy + ny-1&lt;span&gt;);
                grid[nx][ny&lt;/span&gt;-1] = 0&lt;span&gt;;
                num&lt;/span&gt;++&lt;span&gt;;
            }
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (ny + 1 &amp;lt; cy &amp;amp;&amp;amp; grid[nx][ny+1] == 1&lt;span&gt;) {
                neQueue.add(nx &lt;/span&gt;* cy + ny+1&lt;span&gt;);
                grid[nx][ny&lt;/span&gt;+1] = 0&lt;span&gt;;
                num&lt;/span&gt;++&lt;span&gt;;
            }
        } 
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; num;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;参考文章&lt;/h2&gt;
&lt;h4 class=&quot;postTitle&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/abella/p/10097498.html&quot; target=&quot;_blank&quot;&gt;广度优先遍历（BFS ）（转）&lt;/a&gt;&lt;/h4&gt;
</description>
<pubDate>Mon, 04 May 2020 14:49:00 +0000</pubDate>
<dc:creator>huansky</dc:creator>
<og:description>概论 在&amp;#160;深度优先搜索原理与实践（java）文章介绍了深度优先搜索算法的理论和实践。本文将介绍与其原理类似的广度优先搜索算法。 广度优先搜索（也称宽度优先搜索，缩写 BFS，以下采用广度来描</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huansky/p/12826857.html</dc:identifier>
</item>
<item>
<title>React Hooks总结 - 学霸初养成</title>
<link>http://www.cnblogs.com/V587Chinese/p/12778842.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/V587Chinese/p/12778842.html</guid>
<description>&lt;h2&gt;Hook 前言&lt;/h2&gt;
&lt;h3&gt;什么是Hook&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;自从 16.8 版本开始，hooks 的出现使得你可以在不编写 class 的情况下使用状态管理以及其它 React 的特性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么在 React Hooks 出现之前，class 类组件和 function 函数组件有什么区别？Hooks 出现之后，函数组件又是如何满足原来只有类组件才有的功能的？&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;1.类组件和没有 hooks 加持的函数组件：&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;函数组件常被称为无状态组件，意思就是它内部没有状态管理，只能做一些展示型的组件或者是完全受控组件。因此差别主要体现在：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;函数组件没有内部状态管理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;函数组件内部没有生命周期钩子&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;函数组件不能被获取组件实例 ref，函数组件内也不能获取类组件的 ref&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;2.类组件和有 hooks 加持的函数组件：&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;有了 hooks 加持之后，函数组件具备了状态管理，除了可以使用内置的 hooks ，我们还可以自定义 hooks。&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;类组件有完备的生命周期钩子，而函数组件只能具备：DidMount / WillUnmount / DidUpdate / willUpdate&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;函数组件内部可以通过内置 hook 获取类组件 ref，也可以通过一些 API 的组合使用达到获取函数组件 ref 的功能&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;函数组件具备了针对状态变量的 setter 监听（类似于 vue watch），类组件没有这种 API。（useCallback、useEffect、useMemo等）&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;&lt;span&gt;类组件原本比函数组件更加完整，为什么还需要 hooks？&lt;/span&gt;&lt;/h3&gt;
&lt;h4&gt;&lt;span&gt;这要说到 React 的设计理论：&lt;/span&gt;&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;React 认为，UI 视图是数据的一种视觉映射，即 UI = F(DATA) ，这里的 F 需要负责对输入的数据进行加工、并对数据的变更做出响应&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;公式里的 F 在 React 里抽象成组件，React 是以组件为粒度编排应用的，组件是代码复用的最小单元&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;在设计上，React 采用 props 来接收外部的数据，使用 state 属性来管理组件自身产生的数据（状态），而为了实现（运行时）对数据变更做出响应需要，React 采用基于类 Class 的组件设计&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;除此之外，React 认为组件是有生命周期的，因此开创性地将生命周期的概念引入到了组件设计，从组件的 create 到 destroy 提供了一系列的 API 共开发者使用&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4&gt;&lt;span&gt;类组件 Class Component 的困局&lt;/span&gt;&lt;/h4&gt;
&lt;h6&gt;&lt;span&gt;组件状态逻辑复用困局&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;对于有状态组件的复用，React 团队和社区尝试过许多方案，早期使用 CreateClass + Mixins，使用 Class Component 后又设计了 Render Props 和 HOC，再到后来的 Hooks设计，React 团队对于组件复用的探索一直没有停止。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HOC 和 Render Props 都有自己的缺点，都不是完美的复用方案（详情了解 &lt;a title=&quot;React HOC 和 Render Props&quot; href=&quot;https://www.cnblogs.com/V587Chinese/p/11444842.html&quot; target=&quot;_blank&quot;&gt;React HOC 和 Render Props&lt;/a&gt;），官方团队认为应该为共享状态逻辑提供更好的&lt;/span&gt;&lt;span&gt;原生途径。在 Hooks 加持后，功能相对独立的部分完全抽离到 hook 实现，例如网络请求、登录状态、用户核验等；也可以将 UI 和功能（状态）分离，功能放到 hook 实现，例如表单验证。&lt;/span&gt;&lt;/p&gt;
&lt;h6&gt;&lt;span&gt;复杂组件变得难以理解&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;span&gt;我们经常维护一些组件，它们起初很简单，但是逐渐会被状态逻辑和副作用充斥。在多数情况下，不可能将组件拆分为更小的粒度，因为状态逻辑无处不在。这也给测试带来了挑战。Hook 可将组件中相互关联的部分拆分成更小的函数&lt;/span&gt;&lt;/p&gt;
&lt;h6&gt;&lt;span&gt;JavaScript Class 的缺陷&lt;/span&gt;&lt;/h6&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;this的指向问题（语言缺陷）&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;编译后体积和性能的问题&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;同样功能的类组件和函数组件，在经过 Webpack 编译后体积相差明显，也伴随着一定的性能问题。这是因为 class 在 JavaScript 中本质是函数，在 React 内部也是当做 Function类 来处理的。而函数组件编译后就是一个普通的 function，function 对 JS 引擎是友好的。&lt;/p&gt;
&lt;h2&gt;内置 Hooks&lt;/h2&gt;
&lt;h3&gt;useState&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const [state, setState] = useState(initialState);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;用来承担与类组件中的 state 一样的作用，组件内部的状态管理&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
function () {
  const [ count, setCount ] = useState(0);  
  const onClick = ()  =&amp;gt; { 
    setCount( count + 1 ); 
    // setCount(count =&amp;gt; count + 1);
  }; 
    
  return &amp;lt;div onClick={onClick}&amp;gt;{ count }&amp;lt;/div&amp;gt;  
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;除了直接传入最新的值，还可以函数式更新，这样可以访问到先前的 state。如果你的初始 State 创建比较昂贵时，可以传一个函数给 useState：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
function Table(props) {
  // ⚠️ createRows() 每次渲染都会被调用
  const [rows, setRows] = useState(createRows(props.count));
  // ...
}

function Table(props) {
  // ✅ createRows() 只会被调用一次
  const [rows, setRows] = useState(() =&amp;gt; createRows(props.count));
  // ...
}
&lt;/pre&gt;&lt;/div&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;&lt;span&gt;如果是复杂类型的 state，需要传入修改后的完整的数据，不再像类组件中的 setState 可以自动合并对象，需要手动合并：&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;brush:javascript;gutter:false;&quot;&gt;&lt;span&gt;setState(prevState =&amp;gt; ({...prevState, ...updatedValues}));&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;此外，useReducer 是另一种可选的方案。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;useEffect&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
useEffect(func, [deps]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;可以用来模拟生命周期，即可以完成某些副作用。什么叫副作用？一般我们认为一个函数不应该对外部产生影响，一旦在函数内部有某些影响外部的操作，将其称之为副作用。例如改变 DOM、改变 Window对象（Global）、设置定时器、使用原生API绑定事件等等，如果处理不好，它们可能会产生 bug 并产生破坏。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果只传一个参数，每次组件渲染都会执行回调函数（挂载+跟新），相当于 componentDidMount() + componentDidUpdate()&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;返回值函数：在组件更新前、组件卸载时执行，相当于 componentWillUnmount() + componentWillUpdate()&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
useEffect(() =&amp;gt; { // 每次渲染后执行此函数，获取到的值是最新的
    console.log(&quot;Effect after render&quot;, count);
    return () =&amp;gt; { // 每次执行useEffect前，先执行此函数，获取到的数据是更新之前的值
        console.log(&quot;remove last&quot;, count);
    }
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;第二个参数是依赖列表，当依赖的状态数据发生改变时会执行回调&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1.如果是一个空数组，表示没有依赖项&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;回调函数：只在组件挂载的时候执行一次，相当于 componentDidMount()&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;返回值函数：只在组件卸载的时候执行一次，相当于 componentWillUnmount()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;2.如果有值&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;回调函数：除了具有 componentDidMount()，还当 数组内的变量发生变化时执行 componentDidUpdate()&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;返回值函数：除了具有 componentWillUnmount()，还当 数组内的值发生变化时执行 componentWillUpdate()&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;需要注意的是，&lt;/p&gt;
&lt;p&gt;    1.第二个参数的比较其实是浅比较，传入引用类型进去是无意义的&lt;br/&gt;    2.一个组件内可以使用多个 useEffect，它们相互之间互不影响&lt;br/&gt;    3.useEffect 第一个参数不能是 async 异步函数，因为它总是返回一个 Promise，这不是我们想要的。你可以在其内部定义 async 函数并调用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;useLayoutEffect&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;它与 useEffect 的用法完全一样，作用也基本相同，唯一的不同在于执行时机，它会在所有的 DOM 变更之后同步调用 effect，可以使用它来&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;useEffect 不会阻塞浏览器的绘制任务，它会在页面更新之后才执行。而 useLayoutEffect 跟 componentDidMount 和 componentDidUpdate 的执行时机一样，会阻塞页面渲染，如果当中有耗时任务的话，页面就会卡顿。&lt;/span&gt;&lt;span&gt;大多数情况下 useEffect 比 class 的生命周期函数性能更好，我们应该优先使用它。&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;span&gt;如果你正在将代码从 class 组件迁移到使用 Hook 的函数组件，则需要注意 useLayoutEffect&lt;span&gt; &lt;/span&gt;与 componentDidMount、componentDidUpdate 的调用阶段是一样的。但是，我们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;useReducer&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const [state, dispatch] = useReducer(reducer, initialArg, init);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;useState 的替代方案，它接收一个 (state, action) =&amp;gt; newState 的 reducer 处理函数，并返回当前的 state 和 配套的 dispatch 方法。使用方法与 redux 非常相似。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;某些场景下，useReducer 比 useState 更加适用：&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;当状态变量比较复杂且包含多个子值的时候&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;下一个 state 依赖之前的 state&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
const initialState = {count: 0};

function init(initialCount) {
  return {count: initialCount};
}

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return {count: state.count + 1};
    case 'decrement':
      return {count: state.count - 1};
    default:
      throw new Error();
  }
}

function Counter(props) {
  const [state, dispatch] = useReducer(reducer, initialState);
  // const [state, dispatch] = useReducer(reducer, props.initialCount, init);

  return (
    &amp;lt;&amp;gt;
      Count: {state.count}
      &amp;lt;button onClick={() =&amp;gt; dispatch({type: 'decrement'})}&amp;gt;-&amp;lt;/button&amp;gt;
      &amp;lt;button onClick={() =&amp;gt; dispatch({type: 'increment'})}&amp;gt;+&amp;lt;/button&amp;gt;
    &amp;lt;/&amp;gt;
  );
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此外，它还可以模拟 forceUpdate()&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
const [ignored, forceUpdate] = useReducer(x =&amp;gt; x + 1, 0);

function handleClick() {
   forceUpdate();
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;useCallback&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const memoizedCallback = useCallback(func, [deps]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;useCallback 缓存了方法的引用。它有的作用：&lt;/span&gt;&lt;span&gt;性能优化，父组件更新，传递给子组件的函数指针不会每次都改变，只有当依赖项发生改变的时候才会改变指针。避免了子组件的无谓渲染&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;它的本质是对函数依赖进行分析，依赖变更时才重新执行。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;useMemo &amp;amp; React.memo&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;useMemo 用于缓存一些耗时的计算结果（返回值），只有当依赖项改变时才重新进行计算。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
useCallback(func, [deps])  等同于  useMemo(() =&amp;gt; func, [deps])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;useCallback 缓存的是方法的引用，useMemo 缓存的是方法的返回值，适用场景都是避免不必要的子组件渲染。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在类组件中有 React.PureComponent，与之对应的函数组件可以使用 React.memo，它们都会在自身 re-render 时，对每一个 props 项进行浅对比，如果引用没有发生改变，就不会触发渲染。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;那么，useMemo 和 React.memo 有什么共同点呢？前者可以在组件内部使用，可以拥有比后者更细粒度的依赖控制。它们两个与 useCallback 的本质一样，都是进行依赖控制。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;useContext&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;专门为函数组件提供的 context hook API，可以更加方便地获取 context 的值。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const value = useContext(MyContext);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;useContext(MyContext) 接收一个 context 对象，当前获取到的值由上层组件中距离最近的 &amp;lt;MyContext.Provider&amp;gt; 的 value 决定。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;useContext(MyContext) 相当于之前的 static contextType = MyContext 或者 &amp;lt;MyContext.Consumer&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;&lt;span&gt;useRef&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
const refContainer = useRef(initialValue);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;useRef 返回一个可变的 ref 对象，其 current 属性被初始化为传入的参数。返回的 ref 对象在组件的整个生命周期内保持不变。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注意：此 hook 可以获取 DOM 元素、类组件示例，但无法获取函数组件实例，因为函数组件根本没有实例。如果想让函数组件被获取到 ref，可以使用 useImperativeHandle 来达到这样的效果&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;另外，useRef 获取到的“ref”对象是一个 current 属性可变且可以容纳任意值的通用容器。可以实现如下功能：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;模拟实例变量&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;获取 prevProps、prevState&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
// 当做 class 实例变量
function Timer() {
  const intervalRef = useRef();
 
  useEffect(() =&amp;gt; {
    const id = setInterval(() =&amp;gt; {
      // ...
    });
    intervalRef.current = id;
    return () =&amp;gt; {
      clearInterval(intervalRef.current);
    };
  });
 
  // ...
}
 
// 获取prevProps，prevState
function Counter(props) {
  const [count, setCount] = useState(0);
  const prevProps = useRef(props);
  const prevCount = useRef(count);

  useEffect(() =&amp;gt; {
    prevCount.current = count;
    prevProps.current = props;
  });
 
  return &amp;lt;h1&amp;gt;Now: {count} - {props}, before: {prevCount.current} - {prevProps.current}&amp;lt;/h1&amp;gt;;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;useImperativeHandle&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;useImperativeHandle 可以让你在使用 ref 时自定义对外暴露的属性。官方指出，它应当与 forwardRef 一起使用。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;示例：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
function FancyInput(props, ref) {
  const inputRef = useRef();
  useImperativeHandle(ref, () =&amp;gt; ({
    focus: () =&amp;gt; {
      inputRef.current.focus();
    }
  }));
  return &amp;lt;input ref={inputRef} ... /&amp;gt;;
}
FancyInput = forwardRef(FancyInput);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;此时，通过 ref 获取到 FancyInput 的&quot;实例&quot;，其 current 属性内只有 foucs 属性可供访问&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 04 May 2020 14:04:00 +0000</pubDate>
<dc:creator>学霸初养成</dc:creator>
<og:description>Hook 前言 什么是Hook 自从 16.8 版本开始，hooks 的出现使得你可以在不编写 class 的情况下使用状态管理以及其它 React 的特性。 那么在 React Hooks 出现之前</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/V587Chinese/p/12778842.html</dc:identifier>
</item>
<item>
<title>C# 基础知识系列- 14 IO篇 流的使用 - 月影西下</title>
<link>http://www.cnblogs.com/c7jie/p/12828420.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/c7jie/p/12828420.html</guid>
<description>&lt;p&gt;继续之前的C# IO流，在前几篇小短片中我们大概看了下C# 的基础IO也对文件、目录和路径的操作有了一定的了解。这一篇开始，给大家演示一下流的各种操作。以文件流为例，一起来看看如何操作吧。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注：之前更新了一篇《Spring Cloud 实战日记》，这是一个新的系列，有兴趣的小伙伴可以从我的账号首页进去看看。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;先来看一部分代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        var directory = Directory.GetCurrentDirectory();
        var program = File.Open(&quot;../../../Program.cs&quot;, FileMode.OpenOrCreate);
        // program = File.Open(&quot;Program.cs&quot;, FileMode.OpenOrCreate);
        var buffers = new byte[1024];// 创建一个8k的缓存区
        var list = new List&amp;lt;byte&amp;gt;();
        while(true)
        {
            int length = program.Read(buffers, 0, buffers.Length);
            if(length &amp;lt;=0)
            {
                break;
            }
            list.AddRange(buffers.Take(length));
        }

        program.Close();
        Console.WriteLine(list.Count);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到目前为止，打开了一个流读取当前程序源文件，每次读取到一个字节数组里，然后将数据放到list集合里，在读取完成后关闭这个流。虽然以上流并没有太多意义，但是基本演示了一下流的读取操作。&lt;/p&gt;
&lt;p&gt;注意到注释的那行代码和上一行代码的区别吗？在编译阶段，Directory.GetCurrentDirectory()表示源文件所在目录；在运行阶段，表示程序编译完成的DLL所在目录。&lt;/p&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202005/1266612-20200504215346063-2078723466.png&quot; alt=&quot;image-20200503181653684&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上通过文件流演示了如何读取一个文件，那么我们来简单看看如何通过流写文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        var directory = Directory.GetCurrentDirectory();
        var program = File.Open(&quot;Program.cs&quot;, FileMode.OpenOrCreate);
        var buffers = new byte[1024];// 创建一个8k的缓存区
        var list = new List&amp;lt;byte&amp;gt;();
        while(true)
        {
            int length = program.Read(buffers, 0, buffers.Length);
            if(length &amp;lt;=0)
            {
                break;
            }
            list.AddRange(buffers.Take(length));
        }
        program.Close();
        Console.WriteLine($&quot;已读取：{list.Count}&quot;);
        var tempr = File.Open(&quot;Program_01.cs&quot;, FileMode.OpenOrCreate);
        tempr.Write(list.ToArray(), 0, list.Count);
        tempr.Close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上方法通过读取当前源码文件，然后将数据写入到另一个文件中：”Program_01.cs“。如果运行无误的话，将会得到一个”Program_01.cs“文件。&lt;/p&gt;

&lt;p&gt;普通的流读取和写入都是使用字节数组，这在实际开发中非常不方便，所以C#又在流的基础上开发了流适配器。C#中流适配器是指XXXReader或者XXXWriter，这种类在初始化的时候传入一个流作为操作对象，然后对这个流进行一定的封装，简化了其操作方法。&lt;/p&gt;
&lt;p&gt;现在以StreamReader为例，来看看具体如何使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public StreamReader (System.IO.Stream stream);
public StreamReader (System.IO.Stream stream, System.Text.Encoding encoding);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是两个以流为主要参数的构造方法，不同的是一个指定了文本编码 encoding，另一个默认使用系统的文本编码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public StreamReader (string path);
public StreamReader (string path, System.Text.Encoding encoding);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这两个是通过指定文件的路径，然后打开一个StreamReader对象。&lt;/p&gt;
&lt;p&gt;现在我们来看下这个Reader对象有哪些方法或者说我们常用的方法有哪些吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public override int Read ();
public override int Read (char[] buffer, int index, int count);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;读取字符，与普通的流不同的是，StreamReader的读取是以字符为单位的读取，而char类型与int之间存在一定的转换关系，所以方法Read()的返回值是int。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public override string ReadLine ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法的意思是一次读一行，如果读到末尾则返回null。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public override string ReadToEnd ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法的意思是一次性读完剩余的数据然后返回一个字符串。&lt;/p&gt;
&lt;p&gt;照例，Reader提供了流的关闭和销毁方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public override void Close ();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在让我们来改造一下第一节的示例程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        var reader = new StreamReader(&quot;Program.cs&quot;);
        while(true)
        {
            var str = reader.ReadLine();
            if(str == null)
            {
                break;
            }
            Console.WriteLine(str);
        }
        reader.Close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的意思是读取当前主程序的文件，然后按行打印。打印结果应该类似于：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202005/1266612-20200504215346268-711561172.png&quot; alt=&quot;image-20200503214306875&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是我本地的代码文件。&lt;/p&gt;
&lt;p&gt;简单的介绍了一下StreamReader，然后我们来看一下StreamWriter如何使用。按照我的惯例，先从构造函数来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public StreamWriter (System.IO.Stream stream);
public StreamWriter (System.IO.Stream stream, System.Text.Encoding encoding);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;与StreamReader类似，打开一个允许写的流。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public StreamWriter (string path);
public StreamWriter (string path, bool append);
public StreamWriter (string path, bool append, System.Text.Encoding encoding);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开path对应的文件，然后将数据写入到文件中。append表示当文件存在时，数据是追加到文件末尾还是覆盖文件。&lt;/p&gt;
&lt;p&gt;然后看一下它的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public override void Write (string value);
public override void Write (string format, object arg0, object arg1, object arg2);
public override void Write (string format, params object[] arg);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Write方法提供了很多个重载版本，但是我们只需要关注这三个即可。第一个很简单，直接写一个字符串。如果把第二个方法和第三个方法结合起来，然后再联系一下String.Format我想很多小伙伴就知道怎么使用了。没错，这两个方法的效果就是下面这种方式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;var value = string.Format(string format, params object[] arg);
writer.Write(value);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public override void WriteLine (string value);
public override void WriteLine (string format, object arg0, object arg1, object arg2);
public override void WriteLine (string format, params object[] arg);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同时C#也添加了一组WriteLine的方法，该方法与Write不同的是，WriteLine会在写入数据后向流里追加一个换行符，所以这个方法是写入一行。&lt;/p&gt;
&lt;p&gt;不过，在使用Writer的时候需要注意以下这三个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public override void Flush ();
public override void Close ();
protected override void Dispose (bool disposing);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中Dispose（销毁）是受保护的方法，一般场景中遇不到。Flush表示将Writer的数据推送到基础流里，Close表示关闭Writer顺便关闭基础流。&lt;/p&gt;
&lt;p&gt;在C#中，对Close动作进行了进一步优化。当调用Close方法的时候，系统会自动调用Flush方法将数据推送到基础流中。那么，为什么还提供了Flush呢？因为如果要操作一个大数据或者数据的来源是分批，这时候为了保证之前的数据不会丢失就需要我们手动调用Flush把数据推送给基础流了。&lt;/p&gt;
&lt;p&gt;嗯，所以我们来写个程序验证一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        var reader = new StreamReader(&quot;Program.cs&quot;);
        var writer = new StreamWriter(&quot;Program.cs.txt&quot;);
        while(true)
        {
            var str = reader.ReadLine();
            if(str == null)
            {
                break;
            }
            Console.WriteLine(str);
            writer.WriteLine(str);
        }
        //writer.Close();
        reader.Close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如示例，在注释了 writer.Close(); 之后，程序依然会生成一个Program.cs.txt 文件，但文件是空的。这时候取消注释，就会发现Program已经复制到了Program.cs.txt里。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1. BinaryReader&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用特定的编码将基元数据类型读作二进制值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. BinaryWriter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将二进制中的基元类型写入流并支持用特定的编码写入字符串&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.StringReader&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从字符串中读取字符串&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.StringWriter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将信息写入字符串中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5.XmlReader/XmlWriter&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对xml文件的快速操作&lt;/p&gt;
&lt;p&gt;这几个是出镜率较高的，但仍有很多选手藏在幕后，并非是它们不出镜，而是它们经常活跃在特定的领域里。所以这里就没有做过多的介绍。&lt;/p&gt;

&lt;p&gt;到这里，IO流基础知识介绍完毕。C#基础知识系列，也只剩下《异常篇》、《实战准备篇》以及《C#基础实战篇-文件检索工具》这三大篇章了。C#系列的下一个篇章就是数据访问系列，会介绍AOD.NET、Entity Framework等数据访问框架。&lt;/p&gt;
&lt;p&gt;附：&lt;/p&gt;
&lt;p&gt;上文中提到的System.Text.Encoding是一种文本编码类，表示字符串的编码格式。常用的有 UTF-8，GBK2312等。其中C#在Encoding类添加了几大常用编码格式的静态属性，返回的是Encoding实例。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static System.Text.Encoding UTF8 { get; }
public static System.Text.Encoding ASCII { get; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;2.1052631578947&quot;&gt;
&lt;p&gt;更多内容烦请关注&lt;a href=&quot;https://blogs.attachie.club&quot;&gt;我的博客《高先生小屋》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/1266612/202005/1266612-20200504215346540-940848269.png&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 May 2020 13:54:00 +0000</pubDate>
<dc:creator>月影西下</dc:creator>
<og:description>0. 前言 继续之前的C IO流，在前几篇小短片中我们大概看了下C 的基础IO也对文件、目录和路径的操作有了一定的了解。这一篇开始，给大家演示一下流的各种操作。以文件流为例，一起来看看如何操作吧。 注</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/c7jie/p/12828420.html</dc:identifier>
</item>
<item>
<title>LeetCode 56，57，60，连刷三题不费劲 - TechFlow2019</title>
<link>http://www.cnblogs.com/techflow/p/12828338.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/techflow/p/12828338.html</guid>
<description>&lt;p&gt;本文始发于个人公众号：&lt;strong&gt;TechFlow&lt;/strong&gt;，原创不易，求个关注&lt;/p&gt;
&lt;p&gt;今天是&lt;strong&gt;LeetCode专题的第34篇&lt;/strong&gt;文章，刚好接下来的题目比较简单，很多和之前的做法类似。所以我们今天出一个合集，一口气做完接下来的57、59和60这三题。&lt;/p&gt;
&lt;p&gt;再次申明一下，为了节约篇幅，保证文章的质量，我跳过了LeetCode当中所有的Easy以及少量没什么营养的Medium和Hard的问题。Easy的问题都不是很难，即使是新手一般来说也不需要看题解，仔细想想也应该能搞定。所以就不占用篇幅了，如果大家有比较感兴趣的Easy问题，可以在下方的小程序处给我留言。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;leetcode-57-插入区间&quot;&gt;LeetCode 57 插入区间&lt;/h2&gt;
&lt;p&gt;第一题是57题Insert Interval，插入区间。题意会给定一组区间和一个单独的区间，要求&lt;strong&gt;将这个单独的区间插入区间集合&lt;/strong&gt;，如果有两个区间存在交叉的情况，需要将它们合并，要求合并之后的最终结果。从题意上来看，基本上和我们上一篇文章讲的区间合并问题完全一样。唯一不同的是，在这题当中给定的这一组区间都是&lt;strong&gt;天然有序&lt;/strong&gt;的，我们不需要对它进行排序。&lt;/p&gt;
&lt;p&gt;区间已经有序了，剩下的就很简单了，我们只需要进行插入即可。区间插入的判断条件还是和之前一样，如果A区间的左端点在B区间左端点左侧，那么只要A区间的右侧端点在B区间左端点的右侧即可。所以这题基本上没有难度，就是一道裸题，我也不明白为什么官方给定的难度是Hard。&lt;/p&gt;
&lt;p&gt;我们直接放出代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def insert(self, intervals: List[List[int]], newInterval: List[int]) -&amp;gt; List[List[int]]:
        ret = []
        # l, r记录待插入区间
        l, r = newInterval
        # 记录待插入区间是否完成插入
        flag = False
        
        for x, y in intervals:
            # x, y记录当前区间
            # 如果当前区间在待插入区间左侧，那么将当前区间插入答案
            if y &amp;lt; l:
                ret.append([x, y])
            # 如果当前区间在待插入区间右侧，那么将两个区间都插入答案
            elif r &amp;lt; x:
                if not flag:
                    flag = True
                    ret.append([l, r])
                ret.append([x, y])
            # 否则，说明当前区间与待插入区间可以合并
            # 更新待插入区间的范围
            else:
                l, r = min(l, x), max(r, y)
        # 如果最后还没有完成插入，说明待插入区间大于所有区间
        # 手动插入，防止遗漏
        if not flag:
            ret.append([l, r])
        return ret
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只要理解了区间合并的条件，这题真的没有难度。&lt;/p&gt;
&lt;br/&gt;&lt;h2 id=&quot;leetcode-59-螺旋矩阵ii&quot;&gt;LeetCode 59 螺旋矩阵II&lt;/h2&gt;
&lt;p&gt;前不久我们刚出过螺旋矩阵I的题解，在螺旋矩阵I当中，我们给定了一个矩阵让我们螺旋形去遍历它。这题则相反，给定我们矩阵的长和宽，让我们&lt;strong&gt;生成一个这样的螺旋矩阵&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们来看下样例：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/4/171dfdf8b24615b0?w=678&amp;amp;h=304&amp;amp;f=jpeg&amp;amp;s=9511&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在这题当中，我们使用54题的思路也完全可以解出来，但是这题更加简单了一些。由于是让我们构造一个矩阵，那么我们其实没有必要维护每个方向的边界了。只要出现&lt;strong&gt;出界或者是遇到了已经填好的数字&lt;/strong&gt;那么就说明应该转向了。某种程度上来说，这题应该是I，之前的54题应该是II，因为这题更简单一些。&lt;/p&gt;
&lt;p&gt;如果对54题解法不熟悉的同学，可以点击下方的传送门，学习一下方向数组的使用方法。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyMTM5OTM2NA==&amp;amp;mid=2247485148&amp;amp;idx=1&amp;amp;sn=367f88b8e4863ef2dd57f50a0c931004&amp;amp;chksm=f9dafbf7cead72e16eed47c1aac3cc61894d2f87f2abdcfb3c21eaa036afc9bff1f2206108a4&amp;amp;scene=21#wechat_redirect&quot;&gt;LeetCode54 螺旋矩阵，题目不重要，重要的是这个技巧&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;由于我们不需要维护每个方向的边界，并且移动的步数是固定的，更重要的是，&lt;strong&gt;转向每次最多只会发生一次&lt;/strong&gt;，所以这个流程非常简单，我们直接来看代码即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def generateMatrix(self, n: int) -&amp;gt; List[List[int]]:
        # 初始化答案
        ret = [[0 for _ in range(n)] for _ in range(n)]
        # 初始化方向数组
        fx = [[0, 1], [1, 0], [0, -1], [-1, 0]]
        
        # 初始化方向以及起始点
        dt = 0
        x, y = 0, 0
        
        # n*n的方阵，一共需要填入n*n个数字
        for i in range(n*n):
            ret[x][y] = i+1
            # 移动的下一个位置
            x_, y_ = x+fx[dt][0], y+fx[dt][1]
            # 如果发生超界或者是遇到的数字大于0，说明需要转向
            if x_ &amp;lt; 0 or x_ &amp;gt;= n or y_ &amp;lt; 0 or y_ &amp;gt;= n or ret[x_][y_] &amp;gt; 0:
                dt = (dt + 1) % 4
            # 转向之后的位置
            x, y = x+fx[dt][0], y+fx[dt][1]
    
        return ret
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;leetcode-60-第k个排列&quot;&gt;LeetCode 60 第K个排列&lt;/h2&gt;
&lt;p&gt;这题是一个排列组合问题，给定一个整数n，它代表[1,2,3,...,n]这n个元素的序列。然后还有一个整数K，要求这n个元素从小到大第K个排列。&lt;/p&gt;
&lt;p&gt;这题其实蛮有意思，我觉得可以上hard，但遗憾的是它有一个讨巧的办法，大概也许是这样，所以才被降级成Medium的吧。这个讨巧的办法应该蛮容易想到的，很明显，由于n个数字是确定的，所以最小的排列一定是[1,2,3,...,n]。而我们之前做过一道LeetCode31题，它求的是给定一个排列，然后生成字典序比它大刚好一位的下一个排列。&lt;/p&gt;
&lt;p&gt;既然如此，我们可以&lt;strong&gt;重复使用这个算法K-1次&lt;/strong&gt;，就得到了答案了。对于做过31题的同学而言，这题毫无难度。如果对于31题解法不熟悉的同学可以点击下方传送门，回去复习一下。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzUyMTM5OTM2NA%3D%3D%26mid%3D2247484662%26idx%3D1%26sn%3D92f6f8ded2e1fa4e61e2cceeb13cf451%26chksm%3Df9daf9ddcead70cb9877b585a38bc0d87a6769b5de06549abb64779d150b8b5fa62b3574c439%26scene%3D21%23wechat_redirect&quot;&gt;LeetCode 31：递归、回溯、八皇后、全排列一篇文章全讲清楚&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但其实可以不用这么麻烦，因为Python当中有自带的排列组合的工具库，我们可以直接调用，只用5行代码就可以搞定。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Solution:
    # 引入包
    from itertools import permutations
    def getPermutation(self, n: int, k: int) -&amp;gt; str:
        # 由于最后返回的结果要是string
        # 生成['1','2','3',...,'n']的序列用来计算下一个排列
        base = [str(i) for i in range(1, n+1)]
        # 调用permutations会得到一个按顺序计算排列的生成器
        perms = permutations(base, n)
        for i in range(k):
            # 我们调用k-1次next就能获得答案了
            ret = next(perms)
        return ''.join(ret)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法虽然写起来短平快，但是也有一个重大的问题，就是&lt;strong&gt;耗时很长&lt;/strong&gt;。这个其实很容易算，根据当前排列生成下一个排列的复杂度是&lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;。我们一共需要计算k-1次，所以整体的复杂度就是&lt;span class=&quot;math inline&quot;&gt;\(O(nk)\)&lt;/span&gt;，极端情况下k=n!，所以最差复杂度是&lt;span class=&quot;math inline&quot;&gt;\(n \cdot n!\)&lt;/span&gt;。要知道n个物体的排列一共有n!种，如果k很大，这个复杂度是爆表的。不过这题没有过多为难人，这样的复杂度也能AC。我个人觉得这是一个很遗憾的事情，因为简单的算法也可以AC会导致很多人没有斗志再去研究复杂的算法了。&lt;/p&gt;
&lt;p&gt;最后，我们来看正解。&lt;/p&gt;
&lt;p&gt;正解其实&lt;strong&gt;不涉及任何新的算法和数据结构&lt;/strong&gt;，甚至说穿了一文不值，但是很多人就是很难想到。还是老话题，它需要我们对问题进行深入的思考。&lt;/p&gt;
&lt;p&gt;既然我们一个一个地求下一个排列非常慢，那么我们能不能有快速一点的办法呢？加快速度大概有两种办法，第一种&lt;strong&gt;增加步幅&lt;/strong&gt;，比如之前的方法是每次获取字典序+1的排列， 我们能不能生成字典序+k的排列？第二种想法是我们能不能&lt;strong&gt;直接求解答案&lt;/strong&gt;，直接生成出这个排列？&lt;/p&gt;
&lt;p&gt;简单分析一下会发现第一种是不可行的，或者说是伪命题。因为如果说我们可以想出一个求解字典序+k的算法，那么我们令这个k等于题目中要求的k不就是直接求解答案了？所以说，如果可能存在更好的办法，一定只能是第二种，也就是直接构造答案的方法。那么问题就剩下了，我们怎么直接构造这个答案呢？这就需要我们对排列组合的理解了。&lt;/p&gt;
&lt;p&gt;如果你亲手写过某个集合的全排列，你会发现一些规律。比如说123的全排列好了。我们都知道，它的全排列一共是123,132,213,231,31和321。这个很简单，我们观察一下会发现，123一共三个数字，6种排列。每个数字打头的都是2种，如果换成1234的排列呢？列一下就会知道是6种。如果你找规律你会发现，每个数字开头的种数是(n-1)!。&lt;/p&gt;
&lt;p&gt;如果要推导也很简单，因为&lt;strong&gt;每个数字都是公平的&lt;/strong&gt;，所以每个数字开头的种数都是一样的。而全排列一共有n!种，所以分摊到每个数字头上剩下(n-1)!种。那如果我们已经知道了第一个数字是1，请问第二个数字是2的种类数有多少种？同样的方法可以算出是(n-2)!种。到这里有没有火花闪过的感觉？&lt;/p&gt;
&lt;p&gt;我们来举个例子吧，假设我们现在n=5，我们算一下会知道，一共有120种排列。假设我们要求第100个排列，由于从0开始，所以也就是第99大的排列。那么根据我们刚才说的，我们已经知道每个数字开头的情况都是4！也就是24种，那么我们用99/24得到4，所以开头的数字是第4大的数（第0大的是1），也就是5。答案一下子缩小了很多，那接下来呢？接下来我们用99减去5之前的所有情况，也就是96种，得到3。也就说答案是5开头的第3个排列，那么我再问，第二个数字是多少？&lt;/p&gt;
&lt;p&gt;同样的办法，除去5之后还剩下4个数字，每个数字排第二都有3!也就是6种，我们用3/6=0，应该是第0大的数，也就是1。我们继续，除去5和1之后，还剩3个数字。每个数字排第三的情况有2种，我们用3/2=1，我们应该选择第1大的数，这里剩下的数是2，3，4，所以第三位应该是3。以此类推，我们可以得到每一位的数字。整体的复杂度是O(n)，和上面的方法相比，有了质的突破。&lt;/p&gt;
&lt;p&gt;我把整个计算过程做成了图，有看不懂的小伙伴可以结合一下下图理解：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/4/171dfdfe4a177af3?w=1461&amp;amp;h=1080&amp;amp;f=jpeg&amp;amp;s=57262&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后，我们把这个方法实现即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def getPermutation(self, n: int, k: int) -&amp;gt; str:
        frac = [1 for _ in range(n+1)]
        # 生成一个序列存放所有的元素
        nums = [i for i in range(1, n+1)]
        # 计算每一位的种类数
        for i in range(1, n):
            frac[i] = i * frac[i-1]
            
        ret = ''
        k -= 1
        for i in range(n-1, -1, -1):
            # 计算第i位的数字是当前第几大的数
            cur = k // frac[i]
            # 放完之后取模，表示去除掉之前的所有情况数
            k %= frac[i]
            # 求出当前元素之后，需要从序列当中移除
            ret += str(nums[cur])
            nums.remove(nums[cur])
            
        return ret
&lt;/code&gt;
&lt;/pre&gt;
&lt;br/&gt;&lt;h2 id=&quot;结尾&quot;&gt;结尾&lt;/h2&gt;
&lt;p&gt;到这里三题就算是讲完了，今天的这三道题目或多或少的都和之前的问题有关，这也是我把这三题放在一篇文章当中阐述的原因。&lt;/p&gt;
&lt;p&gt;这三题当中我个人最喜欢第三题，尤其是完美解法。它的整个思路和代码都不复杂，也没有什么特殊的技巧或者是方法，但是如果没有对题目有足够深入的了解是很难想到这个算法的。这其实也是算法题的精髓所在，比赛当中多的是知道解法也做不出来的题目。所以我们要提升算法水平，光学算法是不够的，&lt;strong&gt;也需要对题目有深入理解&lt;/strong&gt;才行。&lt;/p&gt;
&lt;p&gt;今天的文章就到这里，原创不易，需要你的&lt;strong&gt;一个关注&lt;/strong&gt;，你的举手之劳对我来说很重要。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/5/4/171dfdfb4f408ad3?w=258&amp;amp;h=258&amp;amp;f=png&amp;amp;s=23988&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 04 May 2020 13:36:00 +0000</pubDate>
<dc:creator>TechFlow2019</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是 LeetCode专题的第34篇 文章，刚好接下来的题目比较简单，很多和之前的做法类似。所以我们今天出一个合集，一口气做完接下来的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12828338.html</dc:identifier>
</item>
<item>
<title>初识nuxt.js:用nuxt.js对现有vue项目进行SSR服务端渲染改造 - 了、凡</title>
<link>http://www.cnblogs.com/ly612322/p/12828299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ly612322/p/12828299.html</guid>
<description>[unable to retrieve full-text content]最近用vue写了公司部门的官网，但是spa单页面应用首屏加载有些慢，体验不好，而且SEO极不友好，于是学了学nuxt把项目改造成后端渲染。因为是第一次用nuxt，也遇上一些坑，在次记录一下，加深印象。 1.什么是nuxt.js？为什么用它？ nuxt.js是一个基于 Vue.js 的通用应用框架，官</description>
<pubDate>Mon, 04 May 2020 13:29:00 +0000</pubDate>
<dc:creator>了、凡</dc:creator>
<og:description>本文始发于个人公众号： TechFlow ，原创不易，求个关注 今天是 LeetCode专题的第34篇 文章，刚好接下来的题目比较简单，很多和之前的做法类似。所以我们今天出一个合集，一口气做完接下来的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/techflow/p/12828338.html</dc:identifier>
</item>
</channel>
</rss>