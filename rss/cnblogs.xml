<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>python 复制以及更改列表操作 - 无涯987</title>
<link>http://www.cnblogs.com/yhzhao1/p/13334491.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yhzhao1/p/13334491.html</guid>
<description>&lt;ul&gt;&lt;li&gt;题目：设置一个老用户列表和一个新用户列表，检查老用户列表中是否与新注册的用户名字有重复（不区分大小写），老用户列表不能被破坏&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;usernames = ['admin','Tom','john','jack','philip']
usernames_copy = usernames[:]                        #复制列表操作
for i in range(0,len(usernames_copy)):               #更改列表操作
    usernames_copy[i] = usernames_copy[i].lower()
newusers = ['A','B','C','D','tom']
for newuser in newusers:
    if newuser.lower() in usernames_copy:
        print('This username has been used')
    else:
        print(&quot;This username hasn't been used&quot;)
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 18 Jul 2020 00:49:00 +0000</pubDate>
<dc:creator>无涯987</dc:creator>
<og:description>题目：设置一个老用户列表和一个新用户列表，检查老用户列表中是否与新注册的用户名字有重复（不区分大小写），老用户列表不能被破坏 usernames = [&amp;amp;#39;admin&amp;amp;#39;,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yhzhao1/p/13334491.html</dc:identifier>
</item>
<item>
<title>Python3 装饰器解析 - 测试工匠麻辣烫</title>
<link>http://www.cnblogs.com/infuture/p/13305790.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/infuture/p/13305790.html</guid>
<description>&lt;ul&gt;&lt;li&gt;6.1 函数的定义和调用&lt;/li&gt;
&lt;li&gt;6.2 参数传递&lt;/li&gt;
&lt;li&gt;6.3 函数返回值&lt;/li&gt;
&lt;li&gt;6.4 变量作用域&lt;/li&gt;
&lt;li&gt;6.5 匿名函数(lambda)&lt;/li&gt;
&lt;li&gt;6.6 递归函数&lt;/li&gt;
&lt;li&gt;6.7 迭代器&lt;/li&gt;
&lt;li&gt;6.8 生成器&lt;/li&gt;
&lt;li&gt;6.9 装饰器&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;69-装饰器&quot;&gt;6.9 装饰器&lt;/h2&gt;
&lt;p&gt;装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，它也不会改变函数或类的调用方式。&lt;/p&gt;
&lt;p&gt;它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。&lt;/p&gt;
&lt;p&gt;概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。&lt;/p&gt;
&lt;p&gt;装饰器的语法是将@装饰器名，放在被装饰对象上面。&lt;/p&gt;
&lt;p&gt;有两类装饰器：函数装饰器、类装饰器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 函数装饰器的语法
@dec
def func():
    pass
参数说明：
@称为语法糖
dec:装饰器名字
func:被装饰的函数名
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在介绍装饰器之前，先明确几个概念及原则：&lt;/p&gt;
&lt;p&gt;原则：&lt;/p&gt;
&lt;p&gt;Python程序是从上往下顺序执行的,而且碰到函数的定义代码块是不会立即执行的，只有等到该函数被调用时，才会执行其内部的代码块。&lt;/p&gt;
&lt;p&gt;如果一个函数定义了两次，那么后面定义的会覆盖前面的定义。&lt;/p&gt;
&lt;p&gt;在Python中代码的放置位置是有区别的，不能随意摆放，通常函数体要放在调用的语句之前。&lt;/p&gt;
&lt;p&gt;概念：&lt;/p&gt;
&lt;p&gt;函数名、函数体、返回值，函数的内存地址、函数名加括号、函数名被当作参数、函数名加括号被当作参数、返回函数名、返回函数名加括号。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 加操作：无参数
import time


def timer(func):
    def inner():
        t1 = time.time()
        func()
        t2 = time.time()
        return t2 - t1

    return inner


@timer
def add():
    a = 1
    b = 1
    time.sleep(1)
    c = a + b
    print(c)
    return c


add = add()
print(add)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;函数名： &lt;code&gt;timer&lt;/code&gt;、&lt;code&gt;add&lt;/code&gt;、&lt;code&gt;inner&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;函数体：除def那一行外的部分&lt;/p&gt;
&lt;p&gt;返回值： return后面的表达式&lt;/p&gt;
&lt;p&gt;函数的内存地址：&lt;code&gt;id(add)&lt;/code&gt;、&lt;code&gt;id(outer)&lt;/code&gt;等等&lt;/p&gt;
&lt;p&gt;函数名加括号：对函数进行调用，比如&lt;code&gt;add()&lt;/code&gt;、&lt;code&gt;timer(func)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;函数名作为参数： &lt;code&gt;timer(func)&lt;/code&gt;中的&lt;code&gt;func&lt;/code&gt;本身是个函数，但作为参数被传递给了timer函数&lt;/p&gt;
&lt;p&gt;函数名加括号被当做参数：其实就是先调用函数，再将它的返回值当做别的函数的参数，例如&lt;code&gt;timer(add())&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回函数名：&lt;code&gt;return inner&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;返回函数名加括号：&lt;code&gt;return inner()&lt;/code&gt;，其实就是先执行inner函数，再将其返回值作为别的函数的返回值。&lt;/p&gt;
&lt;p&gt;一个装饰器例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;'''
1、@timer,称为语法糖，其作用是将被装饰函数add的函数名作为实参传给装饰器timer函数的形参func，传函数名实际传的是内存指向；
2、函数timer内又嵌套了inner函数，返回值是函数名inner，必须要明确的是，传进去函数名add，返回来inner函数名，结果就是add和inner共同指向在内存中定义inner的起始地址，而此时形参func指向在内存定义add的起始地址，可在调试程序过程中通过id方法打印查看add和inner所指向的内存地址的变化情况。
明确这两点，装饰器就不难理解了。
'''
# 加操作：无参数
import time


def timer(func):
    def inner():
        t1 = time.time()
        func()
        t2 = time.time()
        return t2 - t1

    return inner


@timer
def add():
    a = 1
    b = 1
    time.sleep(1)
    c = a + b
    print(c)
    return c


add = add()
print(add)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 加操作：位置参数
import time


def timer(func):
    def inner(a, b):
        t1 = time.time()
        func(a, b)
        t2 = time.time()
        return t2 - t1

    return inner


@timer
def add(a, b):
    # a = 1
    # b = 1
    time.sleep(1)
    c = a + b
    print(c)
    return c


add = add(1, 1)
print(add)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 加操作：可变参数
import time


def timer(func):
    def inner(*args):
        t1 = time.time()
        func(*args)
        t2 = time.time()
        return t2 - t1

    return inner


@timer
def add(a, b):
    # a = 1
    # b = 1
    time.sleep(1)
    c = a + b
    print(c)
    return c


add = add(1, 1)
print(add)
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 加减乘除操作：可变参数
import time


def timer(func):
    def inner(*args):
        t1 = time.time()
        func(*args)
        t2 = time.time()
        return t2 - t1

    return inner


@timer
def add(a, b):
    # a = 1
    # b = 1
    time.sleep(1)
    c = a + b
    print(c)
    return c


@timer
def plus(a, b):
    # a = 1
    # b = 1
    time.sleep(2)
    c = a - b
    print(c)
    return c


@timer
def multi(a, b):
    # a = 1
    # b = 1
    time.sleep(3)
    c = a * b
    print(c)
    return c


@timer
def div(a, b):
    # a = 1
    # b = 1
    time.sleep(4)
    c = a / b
    print(c)
    return c


add = add(1, 1)
print(add)
plus = plus(2, 1)
print(plus)
multi = multi(3, 1)
print(multi)
div = div(4, 1)
print(div)

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;敬请关注个人微信公众号：测试工匠麻辣烫&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1177587/202007/1177587-20200717131825692-1403107958.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 18 Jul 2020 00:10:00 +0000</pubDate>
<dc:creator>测试工匠麻辣烫</dc:creator>
<og:description>第6章 函数 6.1 函数的定义和调用 6.2 参数传递 6.3 函数返回值 6.4 变量作用域 6.5 匿名函数(lambda) 6.6 递归函数 6.7 迭代器 6.8 生成器 6.9 装饰器 6</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/infuture/p/13305790.html</dc:identifier>
</item>
<item>
<title>架构师最常使用的5种架构模式及其适用场景分析 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/13334445.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/13334445.html</guid>
<description>&lt;p&gt;好莱坞电影中有多少情节？一些电影评论家说只有五个。您可以采用几种架构来实现应用程序？目前大多数程序都使用下面提到的五种架构之一。&lt;/p&gt;
&lt;p&gt;在本文中，我将五种软件架构模式的优缺点以及适合场景提炼出来作为快速参考。你可以在单个系统中使用多个架构模式，它们的组合既是计算机科学，也是一门艺术。&lt;/p&gt;
&lt;h2 id=&quot;一、分层架构&quot;&gt;一、分层架构&lt;/h2&gt;
&lt;p&gt;这种方法可能是最常见的方法，因为它通常围绕数据库构建，并且业务中的许多应用程序自然会倾向于将信息存储在RDBMS的表中。许多比较大的软件框架（例如Java EE，Drupal和Express）都是在这种架构下实现的，因此使用它们构建的许多应用程序自然都来自分层体系结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/zimug/p/images/screenshot_1594936165234.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Model-View-Controller（MVC）分层结构是大多数流行的Web框架提供的标准软件开发方法，显然是分层体系结构。数据持久层上方是服务层，它通常包含业务逻辑和有关数据库中数据类型的信息。视图层位于顶层，通常是CSS，JavaScript和带有动态嵌入式代码的HTML。在中间有一个控制层，该控制层具有用于转换在视图和模型之间移动的数据的各种规则和方法。&lt;/p&gt;
&lt;p&gt;分层架构的优点：每个层可以只集中于自己的功能实现。这使得应用程序：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;容易维护&lt;/li&gt;
&lt;li&gt;容易单元测试&lt;/li&gt;
&lt;li&gt;易于分配单独的“角色”&lt;/li&gt;
&lt;li&gt;易于更新和扩展&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;适当的分层体系结构将开发层面进行隔离，这些层不受其他层的更改的影响，从而使重构更加容易。划分任务并定义单独的层是架构师面临的挑战。当需求很好地适应了模式时，这些层将易于解耦或分层开发。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;适合：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要快速构建的新应用程序&lt;/li&gt;
&lt;li&gt;传统IT部门和流程的企业或业务应用程序&lt;/li&gt;
&lt;li&gt;具有尚不了解其他架构的经验不足的开发人员的团队&lt;/li&gt;
&lt;li&gt;需要严格的可维护性和可测试性标准的应用&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二、事件驱动架构&quot;&gt;二、事件驱动架构&lt;/h2&gt;
&lt;p&gt;事件驱动的体系架构根据数据生成一个“事件”，事件由“消息中间件”或“事件分发管理的中央单元”统一接收，并将事件分配特定类型的代码处理。&lt;/p&gt;
&lt;p&gt;使用JavaScript编程网页涉及编写对诸如鼠标单击或击键之类的事件做出反应的小模块。浏览器本身会协调所有输入，并确保只有正确的代码才能得到正确的事件。浏览器中常见许多不同类型的事件，但是模块仅与相关的事件进行交互。这与分层体系结构非常不同，在分层体系结构中，所有数据通常都将穿过所有层。总体而言，事件驱动的体系结构：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;容易适应复杂，混乱的业务环境&lt;/li&gt;
&lt;li&gt;当出现新的事件类型时，很容易扩展&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果模块之间可以相互影响，则[测试可能会很复杂&lt;/li&gt;
&lt;li&gt;当模块发生故障时，中央单元（或消息中间件）必须有一个事件备份计划。&lt;/li&gt;
&lt;li&gt;消息传递开销可能会降低处理速度，消息中间件必须缓冲以突发形式到达的消息时。&lt;/li&gt;
&lt;li&gt;当事件有非常不同的需求时，为事件开发数据结构可能会很复杂。&lt;/li&gt;
&lt;li&gt;维护基于事务的一致性机制很困难，因为接收事件的模块是解耦和独立的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;适合：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;具有异步数据流的异步系统&lt;/li&gt;
&lt;li&gt;各个数据块仅与多模块中的少数模块交互的应用程序&lt;/li&gt;
&lt;li&gt;用户界面&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三、微内核-多插件架构&quot;&gt;三、微内核-多插件架构&lt;/h2&gt;
&lt;p&gt;许多的应用程序都具有一组核心代码，这些代码在不同的模块下反复使用。例如，开发工具Eclipse将打开文件，批注，编辑文件并启动后台处理器。用于显示文件和对其进行编辑的代码是微内核的一部分。其他的插件扩展了Eclipse，从而扩展了其功能。&lt;/p&gt;
&lt;p&gt;具体到解决方案就是将一些基本的核心的任务代码推入微内核。然后，不同的业务部门可以根据不同类型的声明编写插件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;确定哪些代码是微内核中的内容通常是一门艺术。它应该保留经常被使用的代码。&lt;/li&gt;
&lt;li&gt;一旦许多插件依赖微内核，修改微内核可能非常困难，甚至不可能。唯一的解决方案就是修改插件。&lt;/li&gt;
&lt;li&gt;为内核函数选择正确的粒度很难事先完成，也几乎不可能在后期进行更改。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;适合：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;工具类软件&lt;/li&gt;
&lt;li&gt;在核心代码与边缘代码之间有清晰区分的应用程序&lt;/li&gt;
&lt;li&gt;具有一组固定的核心函数和一组动态规则的应用程序&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四、微服务架构&quot;&gt;四、微服务架构&lt;/h2&gt;
&lt;p&gt;小宝宝既可爱又有趣，但是一旦变大，就很难操纵并且难以维护。微服务架构旨在帮助开发人员避免让自己的宝宝长大，笨拙，僵硬，烦人。它的目标不是创建一个大型程序，而是创建多个不同的小型程序。避免修改一个小bug，就需要重新部署整个大型应用的情况出现。&lt;/p&gt;
&lt;p&gt;这种方法类似于事件驱动和微内核方法，但是主要用于解耦不同模块及任务。在许多情况下，不同的任务可能需要不同的处理量，并且用途可能会有所不同。所以微服务的特点是便于修改、便于扩展。使用负载均衡及服务发现的机制，在用户使用高峰期部署更多的微服务，保证服务的高可用；在用户低频服务时段缩减微服务，从而节省服务器资源。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;并非所有应用程序都可以拆分为相对独立的微服务单元。&lt;/li&gt;
&lt;li&gt;当任务分散在不同的微服务之间时，通信成本会更大。单个请求的响应时长会增加。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;适合：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;快速发展新业务团队&lt;/li&gt;
&lt;li&gt;大型Web应用程序&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五、高速缓存架构&quot;&gt;五、高速缓存架构&lt;/h2&gt;
&lt;p&gt;许多网站都是围绕数据库构建的，只要数据库能够满足负载，它们就可以正常运行。但是当使用量达到顶峰，并且数据库无法跟上用户请求的速度时，整个网站就会瘫痪。将数据存储在内存中可以使许多工作更快，从而大幅度提高用户并发访问的支撑能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意事项：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于内存数据库，事务的支持更加困难。&lt;/li&gt;
&lt;li&gt;开发专业的高速缓存数据的程序，对程序员的技术水平往往要求更高一些（至少比只会写增删改查的程序员要高）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;适合：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;高频点击数据流和用户日志之类的大量数据处理&lt;/li&gt;
&lt;li&gt;低价值数据，有时可能会丢失而不会造成重大后果（比如用户访问量数据）&lt;/li&gt;
&lt;li&gt;读多写少的数据。比如新闻数据，写完之后几乎不改，但是有很多的人看。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;欢迎关注我的博客，里面有很多精品合集&quot;&gt;欢迎关注我的博客，里面有很多精品合集&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;本文转载注明出处（必须带连接，不能只转文字）：&lt;a href=&quot;http://www.zimug.com&quot;&gt;字母哥博客&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;觉得对您有帮助的话，帮我点赞、分享！您的支持是我不竭的创作动力！&lt;/strong&gt; 。另外，笔者最近一段时间输出了如下的精品内容，期待您的关注。&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jul 2020 23:38:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>好莱坞电影中有多少情节？一些电影评论家说只有五个。您可以采用几种架构来实现应用程序？目前大多数程序都使用下面提到的五种架构之一。 在本文中，我将五种软件架构模式的优缺点以及适合场景提炼出来作为快速参考</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/13334445.html</dc:identifier>
</item>
<item>
<title>【Nginx】面试官问我Nginx如何配置WebSocket？我给他现场演示了一番！！ - 冰河团队</title>
<link>http://www.cnblogs.com/binghe001/p/13334279.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/binghe001/p/13334279.html</guid>
<description>&lt;h2 id=&quot;写在前面&quot;&gt;写在前面&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;当今互联网领域，不管是APP还是H5，不管是微信端还是小程序，只要是一款像样点的产品，为了增加用户的交互感和用户粘度，多多少少都会涉及到聊天功能。而对于Web端与H5来说，实现聊天最简单的就是使用WebSocket了。而在实现WebSocket聊天的过程中，后台也往往会部署多个WebSocket服务，多个WebSocket服务之间，可以通过Nginx进行负载均衡。今天，我们就来一起说说Nginx是如何配置WebSocket的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;nginx配置websocket&quot;&gt;Nginx配置WebSocket&lt;/h2&gt;
&lt;p&gt;Nginx配置WebSocket也比较简单，只需要在nginx.conf文件中进行相应的配置。这种方式很简单，但是很有效，能够横向扩展WebSocket服务端的服务能力。&lt;/p&gt;
&lt;p&gt;先直接展示配置文件，如下所示(使用的话直接复制，然后改改ip和port即可)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;map $http_upgrade $connection_upgrade { 
        default upgrade; 
        '' close; 
} 
upstream wsbackend{ 
        server ip1:port1; 
        server ip2:port2; 
        keepalive 1000; 
} 
 
server { 
        listen 20038; 
        location /{ 
                proxy_http_version 1.1; 
                proxy_pass http://wsbackend; 
                proxy_redirect off; 
                proxy_set_header Host $host; 
                proxy_set_header X-Real-IP $remote_addr; 
                proxy_read_timeout 3600s; 
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
                proxy_set_header Upgrade $http_upgrade; 
                proxy_set_header Connection $connection_upgrade; 
        } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们就分别分析上述配置的具体含义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首先：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;map $http_upgrade $connection_upgrade { 
        default upgrade; 
        '' close; 
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示的是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果 $http_upgrade 不为 '' (空)，则 $connection_upgrade 为 upgrade 。&lt;/li&gt;
&lt;li&gt;如果 $http_upgrade 为 '' (空)，则 $connection_upgrade 为 close。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;其次：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;upstream wsbackend{ 
        server ip1:port1; 
        server ip2:port2; 
        keepalive 1000; 
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示的是 nginx负载均衡：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;两台服务器 (ip1:port1)和(ip2:port2) 。&lt;/li&gt;
&lt;li&gt;keepalive 1000 表示的是每个nginx进程中上游服务器保持的空闲连接，当空闲连接过多时，会关闭最少使用的空闲连接.当然，这不是限制连接总数的，可以想象成空闲连接池的大小，设置的值应该是上游服务器能够承受的。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;最后：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;server { 
        listen 20038; 
        location /{ 
                proxy_http_version 1.1; 
                proxy_pass http://wsbackend; 
                proxy_redirect off;
                proxy_set_header Host $host; 
                proxy_set_header X-Real-IP $remote_addr; 
                proxy_read_timeout 3600s; 
                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 
                proxy_set_header Upgrade $http_upgrade; 
                proxy_set_header Connection $connection_upgrade; 
        } 
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;表示的是监听的服务器的配置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;listen 20038 表示 nginx 监听的端口&lt;/li&gt;
&lt;li&gt;locations / 表示监听的路径(/表示所有路径，通用匹配，相当于default)&lt;/li&gt;
&lt;li&gt;proxt_http_version 1.1 表示反向代理发送的HTTP协议的版本是1.1，HTTP1.1支持长连接&lt;/li&gt;
&lt;li&gt;proxy_pass &lt;a href=&quot;http://wsbackend&quot;&gt;http://wsbackend&lt;/a&gt;; 表示反向代理的uri，这里可以使用负载均衡变量&lt;/li&gt;
&lt;li&gt;proxy_redirect off; 表示不要替换路径，其实这里如果是/则有没有都没关系，因为default也是将路径替换到proxy_pass的后边&lt;/li&gt;
&lt;li&gt;proxy_set_header Host $host; 表示传递时请求头不变， $host是nginx内置变量，表示的是当前的请求头，proxy_set_header表示设置请求头&lt;/li&gt;
&lt;li&gt;proxy_set_header X-Real-IP $remote_addr; 表示传递时来源的ip还是现在的客户端的ip&lt;/li&gt;
&lt;li&gt;proxy_read_timeout 3600s； 表的两次请求之间的间隔超过 3600s 后才关闭这个连接，默认的60s，自动关闭的元凶&lt;/li&gt;
&lt;li&gt;proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; 表示X-Forwarded-For头不发生改变&lt;/li&gt;
&lt;li&gt;proxy_set_header Upgrade $http_upgrade; 表示设置Upgrade不变&lt;/li&gt;
&lt;li&gt;proxy_set_header Connection $connection_upgrade; 表示如果 $http_upgrade为upgrade，则请求为upgrade(websocket)，如果不是，就关闭连接&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;好了，今天就聊到这儿吧！别忘了点个赞，给个在看和转发，让更多的人看到，一起学习，一起进步！！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;写在最后&quot;&gt;写在最后&lt;/h2&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果你觉得冰河写的还不错，请微信搜索并关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号，跟冰河学习高并发、分布式、微服务、大数据、互联网和云原生技术，「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号更新了大量技术专题，每一篇技术文章干货满满！不少读者已经通过阅读「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号文章，吊打面试官，成功跳槽到大厂；也有不少读者实现了技术上的飞跃，成为公司的技术骨干！如果你也想像他们一样提升自己的能力，实现技术能力的飞跃，进大厂，升职加薪，那就关注「 &lt;strong&gt;冰河技术&lt;/strong&gt; 」微信公众号吧，每天更新超硬核技术干货，让你对如何提升技术能力不再迷茫！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20200716220443647.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jul 2020 17:10:00 +0000</pubDate>
<dc:creator>冰河团队</dc:creator>
<og:description>写在前面 当今互联网领域，不管是APP还是H5，不管是微信端还是小程序，只要是一款像样点的产品，为了增加用户的交互感和用户粘度，多多少少都会涉及到聊天功能。而对于Web端与H5来说，实现聊天最简单的就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/binghe001/p/13334279.html</dc:identifier>
</item>
<item>
<title>搭建sonarqube分析golang代码 - 虾敏四把刀</title>
<link>http://www.cnblogs.com/flhs/p/13274397.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flhs/p/13274397.html</guid>
<description>&lt;h2 id=&quot;准备postgres&quot;&gt;准备postgres&lt;/h2&gt;
&lt;p&gt;为什么不使用Mysql呢，&lt;a href=&quot;https://docs.sonarqube.org/latest/setup/upgrade-notes/&quot;&gt;因为从7.9就不支持了&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;docker启动postgres&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d \
    --name sonar-postgres \
    -e POSTGRES_PASSWORD=postgres \
    -e PGDATA=/var/lib/postgresql/data/pgdata \
    -v /custom/mount:/var/lib/postgresql/data \
    postgres
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装客户端psql，通过yum安装postgresql-server会附带安装psql。也可以安装pgAdmin。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;yum install postgresql-server
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;连接到服务器&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;psql -h localhost -U postgres -W
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建数据库&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;postgres=# CREATE DATABASE sonarqube WITH OWNER=postgres ENCODING='UTF8' CONNECTION LIMIT=-1;
CREATE DATABASE

postgres=# \l
                                 List of databases
   Name    |  Owner   | Encoding |  Collate   |   Ctype    |   Access privileges   
-----------+----------+----------+------------+------------+-----------------------
 postgres  | postgres | UTF8     | en_US.utf8 | en_US.utf8 | 
 sonarqube | postgres | UTF8     | en_US.utf8 | en_US.utf8 | 
 template0 | postgres | UTF8     | en_US.utf8 | en_US.utf8 | =c/postgres          +
           |          |          |            |            | postgres=CTc/postgres
 template1 | postgres | UTF8     | en_US.utf8 | en_US.utf8 | =c/postgres          +
           |          |          |            |            | postgres=CTc/postgres
(4 rows)

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;docker启动sonarqube&quot;&gt;docker启动sonarqube&lt;/h2&gt;
&lt;p&gt;先创建几个volume用于存储数据&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker volume create sonarqube_data
docker volume create sonarqube_extensions
docker volume create sonarqube_logs
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://hub.docker.com/_/sonarqube&quot;&gt;更改一些系统参数&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;sysctl -w vm.max_map_count=262144
sysctl -w fs.file-max=65536
ulimit -n 65536
ulimit -u 4096
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不设置可能会出现错误：vm.max_map_count 65530 is too low&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;2020.07.09 10:33:43 INFO  es[][o.e.n.Node] initialized
2020.07.09 10:33:43 INFO  es[][o.e.n.Node] starting ...
2020.07.09 10:33:44 INFO  es[][o.e.t.TransportService] publish_address {127.0.0.1:9001}, bound_addresses {127.0.0.1:9001}
2020.07.09 10:33:44 INFO  es[][o.e.b.BootstrapChecks] explicitly enforcing bootstrap checks
ERROR: [1] bootstrap checks failed
[1]: max virtual memory areas vm.max_map_count [65530] is too low, increase to at least [262144]
2020.07.09 10:33:44 INFO  es[][o.e.n.Node] stopping ...
2020.07.09 10:33:44 INFO  es[][o.e.n.Node] stopped
2020.07.09 10:33:44 INFO  es[][o.e.n.Node] closing ...
2020.07.09 10:33:44 INFO  es[][o.e.n.Node] closed
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动sonarqube&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -d --name sonarqube \
    -p 9000:9000 \
    --link sonar-postgres \
    -e SONAR_JDBC_URL=jdbc:postgresql://sonar-postgres/sonarqube \
    -e SONAR_JDBC_USERNAME=postgres \
    -e SONAR_JDBC_PASSWORD=postgres \
    -v sonarqube_data:/opt/sonarqube/data \
    -v sonarqube_extensions:/opt/sonarqube/extensions \
    -v sonarqube_logs:/opt/sonarqube/logs \
    sonarqube:8.3.1-community
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本来是要使用8.4的，但是是因为有个&lt;a href=&quot;https://community.sonarsource.com/t/strange-message-popping-up-using-sonarqube-8-4-unknown-url-api-alm-settings-list/27717&quot;&gt;BUG&lt;/a&gt;就放弃了。该BUG会在8.4.1修改。&lt;/p&gt;
&lt;h2 id=&quot;创建项目&quot;&gt;创建项目&lt;/h2&gt;
&lt;p&gt;访问服务地址http://localhost:9000/，然后登录界面，用户名admin，密码admin登录。&lt;/p&gt;
&lt;p&gt;安装中文包&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/365378/202007/365378-20200709190317527-723916415.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;创建项目&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/365378/202007/365378-20200710173232814-1232916016.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;创建令牌&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/365378/202007/365378-20200710173323020-699346308.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用golangci-lint分析代码&quot;&gt;使用golangci-lint分析代码&lt;/h2&gt;
&lt;p&gt;golangci-lint聚合了很多工具，下面只是作为演示，具体请查看官网。&lt;br/&gt;在项目根目录下新建文件&lt;code&gt;.golangci.yml&lt;/code&gt;。具体示例可查看&lt;a href=&quot;https://github.com/golangci/golangci-lint/blob/master/.golangci.example.yml&quot;&gt;https://github.com/golangci/golangci-lint/blob/master/.golangci.example.yml&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# example link : https://github.com/golangci/golangci-lint/blob/master/.golangci.example.yml
run:
  timeout: 1m
  skip-dirs-use-default: true

linters-settings:
  dupl:
    # tokens count to trigger issue, 150 by default
    threshold: 100

linters:
  enable:
    - dupl
    - golint
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用docker镜像生成xml格式的分析文件，出处&lt;a href=&quot;https://docs.sonarqube.org/latest/analysis/external-issues/&quot;&gt;请见&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ mkdir sonar
$ docker run --rm -v $(pwd):/app -w /app golangci/golangci-lint:v1.27.0 golangci-lint run -v --out-format checkstyle &amp;gt; sonar/golangcilint.xml
level=info msg=&quot;[config_reader] Config search paths: [./ /app /]&quot;
level=info msg=&quot;[config_reader] Used config file .golangci.yml&quot;
level=info msg=&quot;[lintersdb] Active 12 linters: [deadcode dupl errcheck golint gosimple govet ineffassign staticcheck structcheck typecheck unused varcheck]&quot;
............
level=info msg=&quot;[runner] linters took 6.693839801s with stages: goanalysis_metalinter: 6.412033368s, unused: 267.37634ms&quot;
level=info msg=&quot;File cache stats: 9 entries of total size 25.5KiB&quot;
level=info msg=&quot;Memory: 145 samples, avg is 153.5MB, max is 339.1MB&quot;
level=info msg=&quot;Execution took 14.475792265s&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;sonar客户端扫描&quot;&gt;sonar客户端扫描&lt;/h2&gt;
&lt;p&gt;在项目根目录新建一个名为&lt;code&gt;sonar-project.properties&lt;/code&gt;的文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# must be unique in a given SonarQube instance
sonar.projectKey=test
sonar.projectName=test

sonar.host.url=http://localhost:9000

sonar.sources=.
sonar.exclusions=**/*_test.go,**/vendor/**

sonar.tests=.
sonar.test.inclusions=**/*_test.go
sonar.test.exclusions=**/vendor/**

sonar.sourceEncoding=UTF-8

sonar.go.golangci-lint.reportPaths=sonar/golangcilint.xml
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;docker执行扫描客户端&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$ docker run --rm -v $(pwd):/usr/src sonarsource/sonar-scanner-cli
......
INFO: Analysis total time: 4.980 s
INFO: ------------------------------------------------------------------------
INFO: EXECUTION SUCCESS
INFO: ------------------------------------------------------------------------
INFO: Total time: 8.382s
INFO: Final Memory: 13M/50M
INFO: ------------------------------------------------------------------------
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看分析结果&quot;&gt;查看分析结果&lt;/h2&gt;
&lt;p&gt;访问 &lt;a href=&quot;http://localhost:9000&quot;&gt;http://localhost:9000&lt;/a&gt; 查看test项目，就可以看到有问题的代码了。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/365378/202007/365378-20200710175951102-250318290.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jul 2020 17:01:00 +0000</pubDate>
<dc:creator>虾敏四把刀</dc:creator>
<og:description>准备postgres 为什么不使用Mysql呢，因为从7.9就不支持了 docker启动postgres docker run -d \ --name sonar-postgres \ -e POST</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flhs/p/13274397.html</dc:identifier>
</item>
<item>
<title>【原创】linux设备模型之kset/kobj/ktype分析 - LoyenWang</title>
<link>http://www.cnblogs.com/LoyenWang/p/13334196.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LoyenWang/p/13334196.html</guid>
<description>&lt;ul&gt;&lt;li&gt;&lt;code&gt;Read the fucking source code!&lt;/code&gt; --By 鲁迅&lt;/li&gt;
&lt;li&gt;&lt;code&gt;A picture is worth a thousand words.&lt;/code&gt; --By 高尔基&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Kernel版本：4.14&lt;/li&gt;
&lt;li&gt;ARM64处理器，Contex-A53，双核&lt;/li&gt;
&lt;li&gt;使用工具：Source Insight 3.5， Visio&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天来聊一下Linux设备模型的基石：&lt;code&gt;kset/kobject/ktype&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202007/1771657-20200718002252480-648024997.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;sysfs&lt;/code&gt;文件系统提供了一种用户与内核数据结构进行交互的方式，可以通过&lt;code&gt;mount -t sysfs sysfs /sys&lt;/code&gt;来进行挂载；&lt;/li&gt;
&lt;li&gt;Linux设备模型中，设备、驱动、总线组织成拓扑结构，通过&lt;code&gt;sysfs&lt;/code&gt;文件系统以目录结构进行展示与管理；&lt;/li&gt;
&lt;li&gt;Linux设备模型中，总线负责设备和驱动的匹配，设备与驱动都挂在某一个总线上，当它们进行注册时由总线负责去完成匹配，进而回调驱动的&lt;code&gt;probe&lt;/code&gt;函数；&lt;/li&gt;
&lt;li&gt;SoC系统中有&lt;code&gt;spi&lt;/code&gt;, &lt;code&gt;i2c&lt;/code&gt;, &lt;code&gt;pci&lt;/code&gt;等实体总线用于外设的连接，而针对集成在SoC中的外设控制器，Linux内核提供一种虚拟总线&lt;code&gt;platform&lt;/code&gt;用于这些外设控制器的连接，此外&lt;code&gt;platform&lt;/code&gt;总线也可用于没有实体总线的外设；&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;/sys&lt;/code&gt;目录下，&lt;code&gt;bus&lt;/code&gt;用于存放各类总线，其中总线中会存放挂载在该总线上的驱动和设备，比如&lt;code&gt;serial8250&lt;/code&gt;，&lt;code&gt;devices&lt;/code&gt;存放了系统中的设备信息，&lt;code&gt;class&lt;/code&gt;是针对不同的设备进行分类；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上边这些功能的实现，离不开&lt;code&gt;kobject/kset/ktype&lt;/code&gt;机制的支撑，开始旅程吧。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202007/1771657-20200718002306661-1333590176.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;21-kobject&quot;&gt;2.1 kobject&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;kobject&lt;/code&gt;代表内核对象，结构体本身不单独使用，而是嵌套在其他高层结构中，用于组织成拓扑关系；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sysfs&lt;/code&gt;文件系统中一个目录对应一个&lt;code&gt;kobject&lt;/code&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;看看结构体吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct kobject {
        const char              *name;                  /* 名字，对应sysfs下的一个目录 */
        struct list_head        entry;               /* kobject中插入的 list_head结构，用于构造双向链表 */
        struct kobject          *parent;            /* 指向当前kobject父对象的指针，体现在sys中就是包含当前kobject对象的目录对象 */
        struct kset             *kset;                    /* 当前kobject对象所属的集合 */
        struct kobj_type        *ktype;            /* 当前kobject对象的类型 */
        struct kernfs_node      *sd;              /* VFS文件系统的目录项，是设备和文件之间的桥梁，sysfs中的符号链接是通过kernfs_node内的联合体实现的 */
        struct kref             kref;                     /* kobject的引用计数，当计数为0时，回调之前注册的release方法释放该对象 */
#ifdef CONFIG_DEBUG_KOBJECT_RELEASE
        struct delayed_work     release;
#endif
        unsigned int state_initialized:1;                /* 初始化标志位，初始化时被置位 */
        unsigned int state_in_sysfs:1;                  /* kobject在sysfs中的状态，在目录中创建则为1，否则为0 */
        unsigned int state_add_uevent_sent:1;      /* 添加设备的uevent事件是否发送标志，添加设备时向用户空间发送uevent事件，请求新增设备 */
        unsigned int state_remove_uevent_sent:1;  /* 删除设备的uevent事件是否发送标志，删除设备时向用户空间发送uevent事件，请求卸载设备 */
        unsigned int uevent_suppress:1;              /* 是否忽略上报（不上报uevent） */
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;22-kset&quot;&gt;2.2 kset&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;kset&lt;/code&gt;是包含多个&lt;code&gt;kobject&lt;/code&gt;的集合；&lt;/li&gt;
&lt;li&gt;如果需要在&lt;code&gt;sysfs&lt;/code&gt;的目录中包含多个子目录，那需要将它定义成一个&lt;code&gt;kset&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kset&lt;/code&gt;结构体中包含&lt;code&gt;struct kobject&lt;/code&gt;字段，可以使用该字段链接到更上一层的结构，用于构建更复杂的拓扑结构；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sysfs&lt;/code&gt;中的设备组织结构很大程度上根据&lt;code&gt;kset&lt;/code&gt;组织的，&lt;code&gt;/sys/bus&lt;/code&gt;目录就是一个&lt;code&gt;kset&lt;/code&gt;对象，在Linux设备模型中，注册设备或驱动时就将&lt;code&gt;kobject&lt;/code&gt;添加到对应的&lt;code&gt;kset&lt;/code&gt;中；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct kset {
        struct list_head list;        /* 包含在kset内的所有kobject构成一个双向链表 */
        spinlock_t list_lock;
        struct kobject kobj;       /* 归属于该kset的所有的kobject的共有parent */
        const struct kset_uevent_ops *uevent_ops;    /* kset的uevent操作函数集，当kset中的kobject有状态变化时，会回调这个函数集，以便kset添加新的环境变量或过滤某些uevent，如果一个kobject不属于任何kset时，是不允许发送uevent的 */
} __randomize_layout;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;23-ktype&quot;&gt;2.3 ktype&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;kobj_type&lt;/code&gt;用于表征&lt;code&gt;kobject&lt;/code&gt;的类型，指定了删除&lt;code&gt;kobject&lt;/code&gt;时要调用的函数，&lt;code&gt;kobject&lt;/code&gt;结构体中有&lt;code&gt;struct kref&lt;/code&gt;字段用于对&lt;code&gt;kobject&lt;/code&gt;进行引用计数，当计数值为0时，就会调用&lt;code&gt;kobj_type&lt;/code&gt;中的&lt;code&gt;release&lt;/code&gt;函数对&lt;code&gt;kobject&lt;/code&gt;进行释放，这个就有点类似于C++中的智能指针了；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;kobj_type&lt;/code&gt;指定了通过&lt;code&gt;sysfs&lt;/code&gt;显示或修改有关&lt;code&gt;kobject&lt;/code&gt;的信息时要处理的操作，实际是调用&lt;code&gt;show/store&lt;/code&gt;函数；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;struct kobj_type {
        void (*release)(struct kobject *kobj);     /* 释放kobject对象的接口，有点类似面向对象中的析构 */
        const struct sysfs_ops *sysfs_ops;        /* 操作kobject的方法集 */
        struct attribute **default_attrs;
        const struct kobj_ns_type_operations *(*child_ns_type)(struct kobject *kobj);
        const void *(*namespace)(struct kobject *kobj);
};

struct sysfs_ops {      /* kobject操作函数集 */
        ssize_t (*show)(struct kobject *, struct attribute *, char *);
        ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};

/* 所谓的attribute就是内核空间和用户空间进行信息交互的一种方法，例如某个driver定义了一个变量，却希望用户空间程序可以修改该变量，以控制driver的行为，那么可以将该变量以sysfs attribute的形式开放出来 */
struct attribute {
        const char              *name;
        umode_t                 mode;
#ifdef CONFIG_DEBUG_LOCK_ALLOC
        bool                    ignore_lockdep:1;
        struct lock_class_key   *key;
        struct lock_class_key   skey;
#endif
};

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看一下&lt;code&gt;kobject&lt;/code&gt;创建的时候，与&lt;code&gt;ktype&lt;/code&gt;的关系，这样理解起来更顺：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202007/1771657-20200718002321827-1893938589.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;kobject&lt;/code&gt;在创建的时候，默认设置&lt;code&gt;kobj_type&lt;/code&gt;的值为&lt;code&gt;dynamic_kobj_ktype&lt;/code&gt;，通常&lt;code&gt;kobject&lt;/code&gt;会嵌入在其他结构中来使用，因此它的初始化跟特定的结构相关，典型的比如&lt;code&gt;struct device&lt;/code&gt;和&lt;code&gt;struct device_driver&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;在&lt;code&gt;/sys&lt;/code&gt;文件系统中，通过&lt;code&gt;echo/cat&lt;/code&gt;的操作，最终会调用到&lt;code&gt;show/store&lt;/code&gt;函数，而这两个函数的具体实现可以放置到驱动程序中；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;24-结构关系&quot;&gt;2.4 结构关系&lt;/h2&gt;
&lt;p&gt;为了更形象的说明这几个结构体的关系，再来一张图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202007/1771657-20200718002333793-261920011.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;kset&lt;/code&gt;既是&lt;code&gt;kobject&lt;/code&gt;的集合，本身又是一个&lt;code&gt;kobject&lt;/code&gt;，进而可以添加到其他的集合中，从而就可以构建成复杂的拓扑结构，满足&lt;code&gt;/sys&lt;/code&gt;文件夹下的文件组织需求；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果只看&lt;code&gt;kset/kobject&lt;/code&gt;的数据结构组织，可能还是会迷惑，它怎么跟Linux的设备模型相关？这时就不得不提到Linux内核中一个很精妙的存在&lt;code&gt;container_of&lt;/code&gt;，它可以通过成员变量的地址来获取所在结构的地址信息。前文提到过&lt;code&gt;kobject/kset&lt;/code&gt;结构本身不会单独使用，通常都是会嵌套在其他结构中，既然&lt;code&gt;kobjcet/kset&lt;/code&gt;能组织成拓扑结构，那么包含它们的结构同样可以构建这个关系，因为可以通过&lt;code&gt;container_of&lt;/code&gt;就可以找到结构体的首地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202007/1771657-20200718002343647-1527682403.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;结构体A、B、C、D、E同样可以构建拓扑结构关系；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct device&lt;/code&gt;和&lt;code&gt;struct device_driver&lt;/code&gt;结构体中都包含了&lt;code&gt;struct kobject&lt;/code&gt;，而&lt;code&gt;struct bus_type&lt;/code&gt;结构体中包含了&lt;code&gt;struct kset&lt;/code&gt;结构，这个也就对应到前文提到的设备和驱动都添加到总线上，由总线来负责匹配；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;kobject/kset&lt;/code&gt;的相关代码比较简单，毕竟它只是作为一个结构体嵌入其他high-level的结构中，充当纽带的作用。不过，我还是简单的上一张图吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202007/1771657-20200718002354687-857277208.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;完成的工作基本就是分配结构体，初始化各个结构体字段，构建拓扑关系（主要是添加到kset的list中，parent的指向等）等，看懂了结构体的组织，这部分的代码理解起来就很轻松了；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;先上一个原理图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202007/1771657-20200718002407027-793599697.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;41-代码&quot;&gt;4.1 代码&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;linux/kernel.h&amp;gt;
#include &amp;lt;linux/module.h&amp;gt;
#include &amp;lt;linux/slab.h&amp;gt;
#include &amp;lt;linux/kobject.h&amp;gt;

//自定义一个结构，包含了struct kobject子结构
struct test_kobj {
    int value;
    struct kobject kobj;
};

//自定义个属性结构体，包含了struct attribute结构
struct test_kobj_attribute {
    struct attribute attr;
    ssize_t (*show)(struct test_kobj *obj, struct test_kobj_attribute *attr, char *buf);
    ssize_t (*store)(struct test_kobj *obj, struct test_kobj_attribute *attr, const char *buf, size_t count);
};

//声明一个全局结构用于测试
struct test_kobj *obj;

//用于初始化sysfs_ops中的函数指针
static ssize_t test_kobj_attr_show(struct kobject *kobj, struct attribute *attr, char *buf)
{
    struct test_kobj_attribute *test_kobj_attr;
    ssize_t ret = -EIO;

    test_kobj_attr = container_of(attr, struct test_kobj_attribute, attr);
    
    //回调到具体的实现函数
    if (test_kobj_attr-&amp;gt;show)
        ret = test_kobj_attr-&amp;gt;show(container_of(kobj, struct test_kobj, kobj), test_kobj_attr, buf);
    
    return ret;
}

//用于初始化sysfs_ops中的函数指针
static ssize_t test_kobj_attr_store(struct kobject *kobj, struct attribute *attr, const char *buf, size_t count)
{
    struct test_kobj_attribute *test_kobj_attr;
    ssize_t ret = -EIO;

    test_kobj_attr = container_of(attr, struct test_kobj_attribute, attr);
    
    //回调到具体的实现函数
    if (test_kobj_attr-&amp;gt;store)
        ret = test_kobj_attr-&amp;gt;store(container_of(kobj, struct test_kobj, kobj), test_kobj_attr, buf, count);
    
    return ret;
}

//用于初始化kobj_ktype
const struct sysfs_ops test_kobj_sysfs_ops = {
    .show = test_kobj_attr_show,
    .store = test_kobj_attr_store,
};

//用于初始化kobj_ktype，最终用于释放kobject
void obj_release(struct kobject *kobj)
{
    struct test_kobj *obj = container_of(kobj, struct test_kobj, kobj);

    printk(KERN_INFO &quot;test kobject release %s\n&quot;, kobject_name(&amp;amp;obj-&amp;gt;kobj));
    
    kfree(obj);
}

//定义kobj_ktype，用于指定kobject的类型，初始化的时候使用
static struct kobj_type test_kobj_ktype = {
    .release = obj_release,
    .sysfs_ops = &amp;amp;test_kobj_sysfs_ops,
};

//show函数的具体实现
ssize_t name_show(struct test_kobj *obj, struct test_kobj_attribute *attr, char *buffer)
{
    return sprintf(buffer, &quot;%s\n&quot;, kobject_name(&amp;amp;obj-&amp;gt;kobj));
}

//show函数的具体实现
ssize_t value_show(struct test_kobj *obj, struct test_kobj_attribute *attr, char *buffer)
{
    return sprintf(buffer, &quot;%d\n&quot;, obj-&amp;gt;value);
}

//store函数的具体实现
ssize_t value_store(struct test_kobj *obj, struct test_kobj_attribute *attr, const char *buffer, size_t size)
{
    sscanf(buffer, &quot;%d&quot;, &amp;amp;obj-&amp;gt;value);

    return size;
}

//定义属性，最终注册进sysfs系统
struct test_kobj_attribute name_attribute = __ATTR(name, 0664, name_show, NULL);
struct test_kobj_attribute value_attribute = __ATTR(value, 0664, value_show, value_store);
struct attribute *test_kobj_attrs[] = {
    &amp;amp;name_attribute.attr,
    &amp;amp;value_attribute.attr,
    NULL,
};

//定义组
struct attribute_group test_kobj_group = {
    .name = &quot;test_kobj_group&quot;,
    .attrs = test_kobj_attrs,
};

//模块初始化函数
static int __init test_kobj_init(void)
{
    int retval;
    printk(KERN_INFO &quot;test_kobj_init\n&quot;);
    obj = kmalloc(sizeof(struct test_kobj), GFP_KERNEL);
    if (!obj) {
        return -ENOMEM;
    }
    
    obj-&amp;gt;value = 1;
    memset(&amp;amp;obj-&amp;gt;kobj, 0, sizeof(struct kobject));
    //添加进sysfs系统
    kobject_init_and_add(&amp;amp;obj-&amp;gt;kobj, &amp;amp;test_kobj_ktype, NULL, &quot;test_kobj&quot;);

    //在sys文件夹下创建文件
    retval = sysfs_create_files(&amp;amp;obj-&amp;gt;kobj, (const struct attribute **)test_kobj_attrs);
    if (retval) {
        kobject_put(&amp;amp;obj-&amp;gt;kobj);
        return retval;
    }
    
    //在sys文件夹下创建group
    retval = sysfs_create_group(&amp;amp;obj-&amp;gt;kobj, &amp;amp;test_kobj_group);
    if (retval) {
        kobject_put(&amp;amp;obj-&amp;gt;kobj);
        return retval;
    }
    
    return 0;
}

//模块清理函数
static void __exit test_kobj_exit(void)
{
    printk(KERN_INFO &quot;test_kobj_exit\n&quot;);

    kobject_del(&amp;amp;obj-&amp;gt;kobj);
    kobject_put(&amp;amp;obj-&amp;gt;kobj);
    
    return;
}

module_init(test_kobj_init);
module_exit(test_kobj_exit);

MODULE_AUTHOR(&quot;LoyenWang&quot;);
MODULE_LICENSE(&quot;GPL&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;42-makefile&quot;&gt;4.2 Makefile&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;ifneq  ($(KERNELRELEASE),)
obj-m:=test_kobject.o
else
KERDIR := /lib/modules/$(shell uname -r)/build
PWD:=$(shell pwd)
all:
        make -C $(KERDIR) M=$(PWD) modules
clean:
        rm -f *.ko *.o *.symvers *.cmd *.cmd.o modules.* *.mod.c
endif
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Makefile&lt;/code&gt;没有太多好说的，注意&lt;code&gt;Tab&lt;/code&gt;的使用，否则容易出错；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;43-测试结果&quot;&gt;4.3 测试结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202007/1771657-20200718002424014-1053202046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在/sys目录下创建了test_kobj文件夹，在该文件夹下除了&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;外，还有一个&lt;code&gt;test_kobj_group&lt;/code&gt;的子文件夹；&lt;/li&gt;
&lt;li&gt;可以通过&lt;code&gt;cat/echo&lt;/code&gt;的操作，来操作&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;，分别会调用到底层的&lt;code&gt;xxx_show&lt;/code&gt;和&lt;code&gt;xxx_store&lt;/code&gt;函数；&lt;/li&gt;
&lt;li&gt;对着代码看这个图，一目了然；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;草草收场，洗洗睡了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;https://lwn.net/Articles/263200/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;欢迎关注个人公众号，不定期更新内核机制文章 。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771657/202007/1771657-20200718002455827-1633083930.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jul 2020 16:26:00 +0000</pubDate>
<dc:creator>LoyenWang</dc:creator>
<og:description>背 景 Read the fucking source code! --By 鲁迅 A picture is worth a thousand words. --By 高尔基 说明： Kernel版本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LoyenWang/p/13334196.html</dc:identifier>
</item>
<item>
<title>LeetCode-位运算相关题解 - JonPan</title>
<link>http://www.cnblogs.com/panlq/p/13334117.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/panlq/p/13334117.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;em&gt;今日得到： 位运算真的是 666， 计算机基础还有数学知识都很重要.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;leetcode-191-二进制位1的个数&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/number-of-1-bits/submissions/&quot;&gt;LeetCode-191 二进制位1的个数&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;LeetCode上第 191 号问题：编写一个函数，输入是一个无符号整数，返回其二进制表达式中数字位数为 ‘1’ 的个数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;观察一下 n 与 n-1 这两个数的二进制表示：对于 n-1 这个数的二进制来说，相对于 n 的二进制，它的最末位的一个 1 会变成 0，最末位一个 1 之后的 0 会全部变成 1，其它位相同不变。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;比如 n = 8888，其二进制为 &lt;strong&gt;10001010111000&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;则 n - 1 = 8887 ，其二进制为 &lt;strong&gt;10001010110111&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过按位与操作后：n &lt;strong&gt;&amp;amp;&lt;/strong&gt; (n-1) = &lt;strong&gt;10001010110000&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;也就是说：通过 n&amp;amp;(n-1)这个操作，可以起到消除最后一个1的作用。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以可以通过执行 n&amp;amp;(n-1) 操作来消除 n 末尾的 1 ，消除了多少次，就说明有多少个 1 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def hammingWeight(self, n):
        res = 0
        while n != 0:
            res += 1
            n &amp;amp;= (n - 1)
        return res

    def hammingWeight2(self, n):
        res = 0
        while n != 0:
            res += (n &amp;amp; 1)
            n = n &amp;gt;&amp;gt; 1
        return res
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html&quot;&gt;算法-求二进制数中1的个数 多种解法&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;leetcode-231-2的幂&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/power-of-two/&quot;&gt;LeetCode-231 2的幂&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;给定一个整数，编写一个函数来判断它是否是 2 的幂次方。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/778496/202007/778496-20200717234510752-1749252597.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;仔细观察，可以看出 2 的次方数都只有一个 1 ，剩下的都是 0 。根据这个特点，只需要每次判断最低位是否为 1 ，然后向右移位，最后统计 1 的个数即可判断是否是 2 的次方数, 可以使用上一个问题的解法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;def isPowerOfTwo(n):
        res = 0
        while n != 0:
            res += (n &amp;amp; 1)
            n &amp;gt;&amp;gt;= 1
        return res == 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;该题还有一种巧妙的解法。再观察上面的表格，如果一个数是 2 的次方数的话，那么它的二进数必然是最高位为1，其它都为 0 ，那么如果此时我们减 1 的话，则最高位会降一位，其余为 0 的位现在都为变为 1，那么我们把两数相与，就会得到 0&lt;/strong&gt;.&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/778496/202007/778496-20200717235219652-1983918441.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/power-of-two/solution/power-of-two-er-jin-zhi-ji-jian-by-jyd/&quot;&gt;图片来源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如 2 的 3 次方为 8，二进制位 1000 ，那么 &lt;code&gt;8 - 1 = 7&lt;/code&gt;，其中 7 的二进制位 0111&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def isPowerOfTwo(self, n: int) -&amp;gt; bool:
        return (n &amp;gt; 0) and ((n &amp;amp; (n - 1)) == 0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;leetcode-201-闭区间范围内数字按位与&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/bitwise-and-of-numbers-range/&quot;&gt;LeetCode-201. 闭区间范围内数字按位与&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;给定范围 [m, n]，其中 0 &amp;lt;= m &amp;lt;= n &amp;lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgconvert.csdnimg.cn/aHR0cHM6Ly9waWMubGVldGNvZGUtY24uY29tL0ZpZ3VyZXMvMjAxLzIwMV9wcmVmaXgucG5n?x-oss-process=image/format,png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所有这些位字符串的公共前缀也是指定范围的起始和结束编号的公共前缀（即在上面的示例中分别为 9 和 12）,因此，我们可以将问题重新表述为：给定两个整数，要求我们找到她们&lt;strong&gt;二进制字符串的公共前缀&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用191的方法 &lt;code&gt;Brian Kernighan 算法&lt;/code&gt; &lt;code&gt;n &amp;amp; (n-1)&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def rangeBitwiseAnd(self, m: int, n: int) -&amp;gt; int:
        while m &amp;lt; n:
            # turn off rightmost 1-bit
            n = n &amp;amp; (n - 1)
        return m &amp;amp; n
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;找m, n 的最高位1出现的位置 ， 如果不相等，则返回0，如果相等，则找公共前缀。&lt;a href=&quot;https://www.bilibili.com/video/BV1wp4y1X768&quot;&gt;B站视频-位运算练习【LeetCode】&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;leetcode-187重复的dna序列&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/repeated-dna-sequences/&quot;&gt;LeetCode-187.重复的DNA序列&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;所有 DNA 都由一系列缩写为 A，C，G 和 T 的核苷酸组成，例如：“ACGAATTCCG”。在研究 DNA 时，识别 DNA 中的重复序列有时会对研究非常有帮助。&lt;/p&gt;
&lt;p&gt;编写一个函数来查找目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。差点没看懂题 QAQ!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;输入：s = &quot;AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT&quot;
输出：[&quot;AAAAACCCCC&quot;, &quot;CCCCCAAAAA&quot;]
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 普通解法
class Solution:
    def findRepeatedDnaSequences(self, s: str) -&amp;gt; List[str]:
        d = {}
        for i in range(len(s) - 9):
            k = s[i: i+10]
            if k in d:
                d[k] = True
            else:
                d[k] = False

        return [*filter(lambda x: d[x], d)]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该的位运算解法暂时没看懂，先记录着，有点晕了，后面继续看&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/repeated-dna-sequences/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-4-7/&quot;&gt;题解&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;leetcode-36只出现一次的数字&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/single-number/&quot;&gt;LeetCode-36.只出现一次的数字&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;17&quot;&gt;
&lt;p&gt;给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;要求： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入: [2,2,1]
输出: 1
输入: [4,1,2,1,2]
输出: 4
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;这题比较简单，&lt;strong&gt;想到异或运算，相同为0，不同为1&lt;/strong&gt;的规则就可以很快求解了&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;a&lt;/th&gt;
&lt;th&gt;b&lt;/th&gt;
&lt;th&gt;a⊕b&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def singleNumber(self, nums: List[int]) -&amp;gt; int:
        # 非空数组暂时不用判断
                from functools import reduce
        return reduce(lambda a, b: a ^ b, nums)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;leetcode-137只出现一次的数字-ii&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/single-number-ii/&quot;&gt;LeetCode-137.只出现一次的数字 II&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;20&quot;&gt;
&lt;p&gt;给定一个&lt;strong&gt;非空&lt;/strong&gt;整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素。&lt;/p&gt;
&lt;p&gt;要求: 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入: [2,2,3,2]
输出: 3
输入: [0,1,0,1,0,1,99]
输出: 99
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://pic.leetcode-cn.com/28f2379be5beccb877c8f1586d8673a256594e0fc45422b03773b8d4c8418825-Picture1.png&quot; alt=&quot;Picture1.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;3×(&lt;em&gt;a&lt;/em&gt;+&lt;em&gt;b&lt;/em&gt;+&lt;em&gt;c&lt;/em&gt;)−(&lt;em&gt;a&lt;/em&gt;+&lt;em&gt;a&lt;/em&gt;+&lt;em&gt;a&lt;/em&gt;+&lt;em&gt;b&lt;/em&gt;+&lt;em&gt;b&lt;/em&gt;+&lt;em&gt;b&lt;/em&gt;+&lt;em&gt;c&lt;/em&gt;)=2&lt;em&gt;c&lt;/em&gt; 也可以应用在上一题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;## 普通解法
class Solution:
    def singleNumber(self, nums):
        return (3 * sum(set(nums)) - sum(nums)) // 2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;推广到一般情况：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果其他数都出现了 k 次，一个数出现了一次。那么如果 k 是偶数，还是把所有的数异或起来就行了。如果 k 是奇数，那么统计每一位是 1 的个数，然后模 k 取余数就能得到那个单独的数了 。其中有&lt;code&gt;sum = kn + 1&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;位运算的解法是有限状态机+位运算，感觉有点难理解，自己推敲一遍勉强可以理解，自己画一个状态表，然后推导出响应的公式就比较好了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic.leetcode-cn.com/f75d89219ad93c69757b187c64784b4c7a57dce7911884fe82f14073d654d32f-Picture4.png&quot; alt=&quot;Picture4.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我是先看题解1， 在看题解2，才搞明白了。&lt;/p&gt;
&lt;ol readability=&quot;-0.0077519379844961&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/single-number-ii/solution/zi-dong-ji-wei-yun-suan-zui-xiang-xi-de-tui-dao-gu/&quot;&gt;【自动机+位运算】最详细的推导过程&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/single-number-ii/solution/single-number-ii-mo-ni-san-jin-zhi-fa-by-jin407891/&quot;&gt;图片来源：有限状态自动机 + 位运算，清晰图解-此题解清晰&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;几乎每道题都能看到题解2的作者，佩服不已，时而习之，但求甚解。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def singleNumber(self, nums: List[int]) -&amp;gt; int:
        ones, twos = 0, 0
        for num in nums:
            ones = ones ^ num &amp;amp; ~twos
            twos = twos ^ num &amp;amp; ~ones
        return ones
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;leetcode-260-只出现一次的数字-iii&quot;&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/single-number-iii/&quot;&gt;LeetCode-260. 只出现一次的数字 III&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt;，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入: [1,2,1,3,2,5]
输出: [3,5]
&lt;/code&gt;
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;结果输出的顺序并不重要，对于上面的例子， &lt;code&gt;[5, 3]&lt;/code&gt; 也是正确答案。&lt;/li&gt;
&lt;li&gt;你的算法应该具有线性时间复杂度。你能否仅使用常数空间复杂度来实现？&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;根据前面找一个不同数的思路算法，在这里把所有元素都异或，那么得到的结果就是那两个只出现一次的元素异或的结果。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;如果我们把原数组分成两组，只出现过一次的两个数字分别在两组里边，那么问题就转换成之前的老问题了，只需要这两组里的数字各自异或，答案就出来了。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;那么通过什么把数组分成两组呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;放眼到二进制，我们要找的这两个数字是不同的，所以它俩至少有一位是不同的，所以我们可以根据这一位，把数组分成这一位都是 1 的一类和这一位都是 0 的一类，这样就把这两个数分到两组里了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;那么怎么知道那两个数字哪一位不同呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回到我们异或的结果，如果把数组中的所有数字异或，最后异或的结果，其实就是我们要找的两个数字的异或。而异或结果如果某一位是 1，也就意味着当前位两个数字一个是 1 ，一个是 0，也就找到了不同的一位。&lt;/p&gt;
&lt;p&gt;以上思路源于作者：&lt;a href=&quot;https://leetcode-cn.com/problems/single-number-iii/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by-5-8/&quot;&gt;windliang&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;class Solution:
    def FindNumsAppearOnce(self, nums):
        length = len(nums)
        if length &amp;lt;= 0:
            return nums
        result = 0
        # 先将所有数子异或得到一个值
        for num in nums:
            result ^= num
        # 找到这个值最低位二进制位1的位置，根据这个位置来区分两个数组，分别异或求出只出现一次的数字
        firstBitIndex = self.FindFirstBit(result)
        n1, n2 = 0, 0
        for num in nums:
            if self.IsSameBit(num, firstBitIndex):
                n1 ^= num
            else:
                n2 ^= num
        return n1, n2

    def FindFirstBit(self, num):
        indexBit = 0
        while num &amp;amp; 1 == 0:
            indexBit += 1
            num = num &amp;gt;&amp;gt; 1
        return indexBit

    def IsSameBit(self, num, indexBit):
        num = num &amp;gt;&amp;gt; indexBit
        return num &amp;amp; 1
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 解放2
class Solution2:
    def FindNumsAppearOnce(self, nums):
        length = len(nums)
        if length &amp;lt;= 0:
            return []

        diff = 0
        for i in nums:
            diff ^= i
    
        n1, n2 = 0, 0
        minDiff = self.getMinDiff(diff)
        for num in nums:
            if minDiff &amp;amp; num == 0:
                n1 ^= num
        n2 = diff ^ n1
        return n1, n2

    def getMinDiff(self, num):
        # 保留一个低位是1的数字
        # 取负号其实就是先取反，再加 1，需要 补码 的知识。最后再和原数相与就会保留最低位的 1。比如 1010，先取反是 0101，再加 1，就是 0110，再和 1010 相与，就是 0010 了
        return num &amp;amp; (-num)
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;如何得到二进制位只有一个1的数，几种方法&quot;&gt;如何得到二进制位只有一个1的数，几种方法&lt;/h3&gt;
&lt;blockquote readability=&quot;4.1428571428571&quot;&gt;
&lt;p&gt;diff &amp;amp;= -diff ; &lt;a href=&quot;https://leetcode.com/problems/single-number-iii/discuss/68900/Accepted-C%2B%2BJava-O(n)-time-O(1)-space-Easy-Solution-with-Detail-Explanations&quot;&gt;这里&lt;/a&gt; 的做法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;取负号其实就是先取反，再加 1，需要 补码 的知识。最后再和原数相与就会保留最低位的 1。比如 &lt;code&gt;1010&lt;/code&gt;，先取反是 &lt;code&gt;0101&lt;/code&gt;，再加 1，就是 &lt;code&gt;0110&lt;/code&gt;，再和 &lt;code&gt;1010&lt;/code&gt; 相与，就是 &lt;code&gt;0010&lt;/code&gt; 了。&lt;/p&gt;
&lt;blockquote readability=&quot;4.4117647058824&quot;&gt;
&lt;p&gt;diff = (diff &amp;amp; (diff - 1)) ^ diff; &lt;a href=&quot;https://leetcode.com/problems/single-number-iii/discuss/68921/C%2B%2B-solution-O(n)-time-and-O(1)-space-easy-understaning-with-simple-explanation&quot;&gt;这里&lt;/a&gt; 的做法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;n &amp;amp; (n - 1)&lt;/code&gt; 的操作在 191 题 用过，它可以将最低位的 1 置为 0。比如 &lt;code&gt;1110&lt;/code&gt;，先将最低位的 1 置为 0 就变成 &lt;code&gt;1100&lt;/code&gt;，然后再和原数 &lt;code&gt;1110&lt;/code&gt; 异或，就得到了 &lt;code&gt;0010&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;4.2682926829268&quot;&gt;
&lt;p&gt;diff = xor &amp;amp; ~(diff - 1) &lt;a href=&quot;https://leetcode.com/problems/single-number-iii/discuss/68923/Bit-manipulation-beats-99.62&quot;&gt;这里&lt;/a&gt; 的做法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先减 &lt;code&gt;1&lt;/code&gt;，再取反，再相与。比如 &lt;code&gt;1010&lt;/code&gt; 减 &lt;code&gt;1&lt;/code&gt; 就是 &lt;code&gt;1001&lt;/code&gt;，然后取反 &lt;code&gt;0110&lt;/code&gt;，然后和原数 &lt;code&gt;1010&lt;/code&gt; 相与，就是 &lt;code&gt;0010&lt;/code&gt; 了&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;mask=1
while((diff &amp;amp; mask)==0):
    mask &amp;lt;&amp;lt;= 1
# mask 就是我们要构造的了
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://leetcode.com/problems/single-number-iii/discuss/342714/Best-Explanation-C%2B%2B&quot;&gt;这里&lt;/a&gt; 的做法&lt;/p&gt;
&lt;h3 id=&quot;参考资料&quot;&gt;参考资料&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;http://blog.sina.com.cn/s/blog_e68cc97e0102wx8i.html&quot;&gt;补码为什么按位取反再加一&lt;/a&gt;认真看完会有收获的。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;amp;mid=2247484756&amp;amp;idx=1&amp;amp;sn=637e3a62b0be2d6ca10c44820e919a03&amp;amp;chksm=fa0e6ad5cd79e3c312fe2e8ec4577ac37cf5e8370cbdb5b237331ae68319bdf251fd07fd48ea&amp;amp;token=1508886278&amp;amp;lang=zh_CN#rd&quot;&gt;五分钟学算法-面试官，别问我 Bit Operation 了！&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jul 2020 15:51:00 +0000</pubDate>
<dc:creator>JonPan</dc:creator>
<og:description>今日得到： 位运算真的是 666， 计算机基础还有数学知识都很重要. LeetCode-191 二进制位1的个数 LeetCode上第 191 号问题：编写一个函数，输入是一个无符号整数，返回其二进制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/panlq/p/13334117.html</dc:identifier>
</item>
<item>
<title>云原生时代高性能Java框架—Quarkus（一） - 东溪陈姓少年</title>
<link>http://www.cnblogs.com/dongxishaonian/p/13334089.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dongxishaonian/p/13334089.html</guid>
<description>&lt;p&gt;&lt;em&gt;&lt;a href=&quot;http://blog.dongxishaonian.tech/?p=824&quot;&gt;&lt;strong&gt;——— Quarkus&amp;amp;GraalVM介绍、创建并启动第一个项目&lt;/strong&gt;&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;Quarkus系列博文&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;quarkus介绍&quot;&gt;Quarkus介绍&lt;/h2&gt;
&lt;p&gt;Quarkus 是一个为 Java 虚拟机（JVM）和原生编译而设计的全堆栈 Kubernetes 原生 Java 框架，用于专门针对容器优化 Java，并使其成为无服务器、云和 Kubernetes 环境的高效平台。&lt;/p&gt;
&lt;p&gt;Quarkus 可与常用 Java 标准、框架和库协同工作，例如 Eclipse MicroProfile、Apache Kafka、RESTEasy（JAX-RS）、Hibernate ORM（JPA）、Spring、Infinispan、Camel 等。&lt;/p&gt;
&lt;p&gt;Quarkus 的依赖注入解决方案基于 CDI（上下文和依赖注入），且包含一个扩展框架来扩展功能并将其配置、引导并集成到您的应用中。添加&lt;a href=&quot;https://quarkus.io/extensions/&quot;&gt;扩展&lt;/a&gt;就像添加依赖项一样容易；或者，您可以使用 Quarkus 工具。&lt;/p&gt;
&lt;p&gt;此外也是引人注目的一个特点，它还向 GraalVM（一种通用虚拟机，用于运行以多种语言（包括 Java 和 JavaScript）编写的应用）提供正确信息，以便对应用进行原生编译。&lt;/p&gt;
&lt;p&gt;Rad Hat列出了一下清单来表明使用Quarkus的好处：&lt;a href=&quot;https://www.redhat.com/cms/managed-files/cl-4-reasons-try-quarkus-checklist-f19180cs-201909-a4-zh.pdf&quot;&gt;检查清单&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;quarkus与传统java框架对比&quot;&gt;Quarkus与传统Java框架对比&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;http://images.dongxishaonian.tech/quarkus_metrics_graphic_bootmem_wide.png&quot; alt=&quot;img&quot; loading=&quot;lazy&quot;/&gt;Quarkus与传统技术栈对比&lt;/p&gt;
&lt;p&gt;来自官方的一张图，展示了使用Quarkus框架开发项目和使用传统框架开发的一些运行时数据明细对比，可以看到Quarkus项目在JVM中运行时所消耗的内存和接口响应能力要明显好于传统的Java技术栈。而将Quarkus编译成本地可执行文件（本地镜像）之后，其优势可以说非常明显了。&lt;/p&gt;
&lt;h2 id=&quot;graalvm简介&quot;&gt;GraalVM简介&lt;/h2&gt;
&lt;p&gt;GraalVM是一种高性能的虚拟机，它可以显著的提高程序的性能和运行效率，非常适合微服务。其设计初衷是实现可以运行不同语言（Java、JavaScript、基于LLVM的语言（例如C和C ++）以及其他动态语言）编写的应用程序。它消除了不同编程语言之间的隔阂，并实现了多语言共享运行时的互操作性。它可以独立运行，也可以在OpenJDK，Node.js或Oracle数据库的上下文中运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggtxy2x3gej30qo0f0whi.jpg&quot; alt=&quot;GraalVM system diagram&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对于Java应用程序，GraalVM可以带来很多有价值的好处：更快地运行它们，通过脚本语言（JavaScript, R, Python...）提供可扩展性或创建提前编译的本机映像（native-image）。&lt;/p&gt;
&lt;p&gt;更多关于GraalVM的信息可参考：&lt;a href=&quot;http://blog.dongxishaonian.tech/archives/799&quot;&gt;此篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;graalvm安装&quot;&gt;GraalVM安装&lt;/h2&gt;
&lt;p&gt;本文我们使用&lt;a href=&quot;https://sdkman.io/&quot;&gt;SDKMAN&lt;/a&gt;来安装GraalVM。SDKMAN是一款用于在大多数基于Unix的系统上管理多个软件开发套件的并行版本的工具。它提供了一个方便的命令行界面（CLI）和API，用于安装，切换，删除和列出候选人。它以前被称为Groovy enVironment Manager （GVM），受到了非常有用的RVM和rbenv工具的启发，该工具在Ruby社区中广泛使用。&lt;/p&gt;
&lt;h3 id=&quot;安装sdkman&quot;&gt;安装SDKMAN&lt;/h3&gt;
&lt;p&gt;运行如下命令进行安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ curl -s &quot;https://get.sdkman.io&quot; | bash
$ source &quot;$HOME/.sdkman/bin/sdkman-init.sh&quot;   
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行如下命令，验证是否已安装ADKMAN：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ sdk version
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;安装graalvm&quot;&gt;安装GraalVM&lt;/h3&gt;
&lt;p&gt;运行如下命令：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ sdk list java
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到SDKMAN列出了所支持的所有Java发行版&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggtycsyfe9j30wc0bugnb.jpg&quot; alt=&quot;image-20200717142755813&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们找到GraalVM的发行版&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggtydk3m8bj30xm05sdgb.jpg&quot; alt=&quot;image-20200717142840033&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;截至编写本文时，GraalVM的最新版本为20.1.0.r11-grl，所以我们会安装此版本。运行如下命令安装GraalVM：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ sdk install java 20.1.0.r11-grl
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，GraalVM安装完毕！我们可以运行如下命令来判断GraalVM是否已安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;$ java -version
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ggud02g9t0j315i02ywf2.jpg&quot; alt=&quot;image-20200717143216643&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建项目&quot;&gt;创建项目&lt;/h2&gt;
&lt;p&gt;我们有多种方式创建Quarkus项目&lt;/p&gt;
&lt;h3 id=&quot;使用intellij-idea创建quarkus项目&quot;&gt;使用Intellij IDEA创建Quarkus项目&lt;/h3&gt;
&lt;p&gt;点击菜单栏File&amp;gt;New&amp;gt;Project... 创建新项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ggtzgp2cydj319c0qkwhx.jpg&quot; alt=&quot;image-20200717150609041&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击Next，并填写适当的信息，Next&amp;gt;Next...,创建完毕。&lt;/p&gt;
&lt;h3 id=&quot;使用maven命令行创建quarkus项目&quot;&gt;使用Maven命令行创建Quarkus项目&lt;/h3&gt;
&lt;p&gt;运行如下命令，创建Quarkus项目：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;mvn io.quarkus:quarkus-maven-plugin:1.6.0.Final:create \
    -DprojectGroupId=org.acme \
    -DprojectArtifactId=getting-started \
    -DclassName=&quot;org.acme.getting.started.GreetingResource&quot; \
    -Dpath=&quot;/hello&quot;
cd getting-started
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，创建项目完毕！&lt;/p&gt;
&lt;h2 id=&quot;启动项目&quot;&gt;启动项目&lt;/h2&gt;
&lt;p&gt;我们使用IDEA打开项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ggu04ucrrnj31ee0u0td7.jpg&quot; alt=&quot;image-20200717152929281&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Quarkus并没有类似Spring Boot、Helidon之类框架一样的启动类，我们需要通过运行Maven命令来启动项目。&lt;/p&gt;
&lt;p&gt;在IDEA控制台运行如下命令来启动项目:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-bash&quot;&gt;./mvnw compile quarkus:dev
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;启动成功！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ggu08uubvzj32560qk0zj.jpg&quot; alt=&quot;image-20200717153314096&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当然每次运行命令行会显得不便，我们可以通过如下配置来配置项目快捷启动：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ggu0aary6ej30xa08ymzi.jpg&quot; alt=&quot;image-20200717153444892&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击左上角&quot;+&quot;图标添加一个Maven配置如左边栏，在右边栏中的Command line中填入&quot;compile quarkus:dev&quot;，点击OK。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ggu0bahsmuj315w0sqdir.jpg&quot; alt=&quot;image-20200717153542033&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;此时可以点下下图所示图标来便捷启动项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlly1ggu0eytva6j30na01ogln.jpg&quot; alt=&quot;image-20200717153914940&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;运行测试&quot;&gt;运行测试&lt;/h2&gt;
&lt;p&gt;打开项目中的测试类，看到如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@QuarkusTest  //1
public class ExampleResourceTest {
    @Test
    public void testHelloEndpoint() {
        given()
            .when().get(&quot;/hello&quot;)
            .then()
            .statusCode(200) //2
            .body(is(&quot;hello&quot;));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;通过使用@QuarkusTest注解运行程序，可以指示JUnit在测试之前启动应用程序。&lt;/li&gt;
&lt;li&gt;检查HTTP响应状态代码和内容。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;默认情况下，测试将在端口8081上运行，以免与正在运行的应用程序冲突。Quarkus自动将RestAssured配置为使用此端口。如果要测试其他路径，则可以使用@TestHTTPResource注解将被测试的URL直接注入到测试类的字段中。该字段的类型可以是字符串，URL或URI。我们需要为该注解指定测试路径的值。例如，如果我要测试映射到/myservlet的Servlet，只需在测试中添加以下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@QuarkusTest  
public class ExampleResourceTest {
    @TestHTTPResource(&quot;/myservlet&quot;)
    URL testUrl;

    @Test
    public void testHelloEndpoint() {
        given()
            .when().get(testUrl)
            .then()
            .statusCode(200) 
            .body(is(&quot;hello&quot;));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以通过在项目配置文件中配置quarkus.http.test-port属性控制测试端口。 Quarkus还创建了一个名为test.url的系统属性，该属性值将被设置成基础测试URL（BasePath）。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们进入了云原生、微服务的时代，我们告别了大型单体应用的庞大和复杂，并且收获了微服务带来的极大的好处 。但是一些问题也开始接踵而至。随着微小服务的增多，曾经在单个应用上发生的多余无用依赖、Java项目与生俱来的启动过程缓慢、JIT优化问题扩散到了每个微服务上面。而且传统的Java EE规范并没有微服务的模式解决方案，问题很迫切需要解决。幸运的事，随着Quarkus、Helidon等等一些新型Java开发框架的出现缓解了这个局面（以及目前Spring生态也开始了对GraalVM的大力支持），他们使Java变得更加本地化，不管是项目的体量方面还是资源消耗和运行效率方面都有显著提升。&lt;/p&gt;
</description>
<pubDate>Fri, 17 Jul 2020 15:37:00 +0000</pubDate>
<dc:creator>东溪陈姓少年</dc:creator>
<og:description>——— Quarkus&amp;amp;amp;GraalVM介绍、创建并启动第一个项目 Quarkus系列博文 Quarkus&amp;amp;amp;GraalVM介绍、创建并启动第一个项目 构建Quarkus本</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/dongxishaonian/p/13334089.html</dc:identifier>
</item>
<item>
<title>Python 实现邮件发送功能（进阶） - 挖挖土豆</title>
<link>http://www.cnblogs.com/potato-find/p/13334078.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/potato-find/p/13334078.html</guid>
<description>&lt;p&gt;本章主要陈述如何发送图片，包括放在邮件主体中和附件中两种方式&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;129&quot;&gt;
&lt;p&gt;上篇文章已经介绍了利用Python发送文本消息的用法，也在文末遗留了如何发送图片和附件的问题，本章主要来回答这两个问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  本章主要包含知识点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1. 如何将图片放到邮件主体中发送&lt;/p&gt;
&lt;p&gt;2. 如何发送附件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题一： 如何将图片放在邮件主体中发送&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从上篇中应该都已知道，其实发送邮件，就是发送Html格式的字符串，那么发送图片时，可不可以也放到html中去呢？答案是肯定的，但是html中有一个指定图片的地址或来源，那么邮件中该指向何处呢？答案是附件。&lt;/p&gt;
&lt;p&gt;根据这个思路，在发送文本的代码上进行一个优化，先上代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Email4Pic(Email):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        入参为filenames 即图片列表，即可以一次发送多张图片
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, filenames : list):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         super(Email4Pic, self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.filenames =&lt;span&gt; filenames
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; message_init(self, html):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         message =&lt;span&gt; MIMEMultipart()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         message[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;subject&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = Header(self.subject, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         message[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;From&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; self.sender
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         message[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;To&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(self.receiver)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         message[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(self.cc)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解决乱码, html是html格式的str&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         message_context = MIMEText(html, _subtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, _charset=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 邮件正文内容&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        message.attach(message_context)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 邮件加入图片&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         cid =&lt;span&gt; 0
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; filename &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.filenames:
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;             m_file = MIMEBase(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             m_file.add_header(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)     &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将图片放进附件&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             m_file.add_header(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-ID&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + str(cid) + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)      &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 设置图片id&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;             
&lt;span&gt;29&lt;/span&gt;             f = open(filename, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            m_file.set_payload(f.read())
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            encoders.encode_base64(m_file)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            message.attach(m_file)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             cid += 1
&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; message
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; 
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;start……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt;     pic1 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\Administrator\\Pictures\\Python.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;     pic2 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\Administrator\\Pictures\\IMG_9676.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt;     pics =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;    pics.append(pic1)
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;    pics.append(pic2)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     sendpic =&lt;span&gt; Email4Pic(pics)
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; 
&lt;span&gt;47&lt;/span&gt;     sendpic.smtp = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     sendpic.username = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wjian.coming@163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;     sendpic.password = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     sendpic.subject = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test/测试邮件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;51&lt;/span&gt;     sendpic.sender = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wjian.coming@163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt;     sendpic.receiver.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;948001879@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;     sendpic.cc.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;948001879@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt;     strs = &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;&amp;lt;span&amp;gt;This is the first picture&amp;lt;/span&amp;gt;&amp;lt;br&amp;gt; &amp;lt;img src='cid:0'&amp;gt;&amp;lt;br&amp;gt; 
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt; &lt;span&gt;              &amp;lt;span&amp;gt;This is the Second picture&amp;lt;/span&amp;gt;&amp;lt;br&amp;gt; &amp;lt;img src='cid:1'&amp;gt;&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt; 
&lt;span&gt;58&lt;/span&gt; &lt;span&gt;    sendpic.send_email(strs) 
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;没错！发送图片即在原来的父类上做了个子类，并复用了父类中的属性和部分方法（send_email），并在message_init方法基础上添加了图片处理的一些逻辑。&lt;/p&gt;
&lt;p&gt;第6行：即继承父类的属性&lt;/p&gt;
&lt;p&gt;第25~32行：将图片放进附件缓存中，并将每个图片标记ID，再读取后放入邮件主体文本中&lt;/p&gt;
&lt;p&gt;第55~56行：此字符串就是即将发送的html格式文件，其中 &amp;lt;img src='cid:0'&amp;gt; 即读取编号为0的图片，从附件缓存中读取的，作为html文件的图片来源&lt;/p&gt;
&lt;p&gt;第58行：调用父类的send_email方法，发送邮件&lt;/p&gt;
&lt;p&gt;如上执行后，我们看下发送后的效果（&lt;em&gt;图片2太大，没有完全截图出来&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;这样就可以理解，只要编辑好Html就可以发送任意内容啦~&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1949471/202007/1949471-20200717225758853-891632559.png&quot; alt=&quot;&quot; width=&quot;682&quot; height=&quot;554&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;&lt;strong&gt;问题二： 如何发送附件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这时，又有人出来问了，你这是两张图片，那要是100张呢，那不得用附件形式才更合理？ 这正是接下来准备讲的，如何发送附件呢？&lt;/p&gt;
&lt;p&gt;同样，有了上面的经验，我们也写一个子类，只不过这次只要将文件读入附件即可，不需要写到邮件主体中，代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Email4Attr(Email):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        入参为filenames 即文件列表，即可以一次发送多个附件
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;'''&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self, filenames : list):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         super(Email4Attr, self).&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         self.filenames =&lt;span&gt; filenames
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; message_init(self, html):
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         message =&lt;span&gt; MIMEMultipart()
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         message[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;subject&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = Header(self.subject, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         message[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;From&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; self.sender
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         message[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;To&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(self.receiver)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         message[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Cc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.join(self.cc)
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 解决乱码, html是html格式的str&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         message_context = MIMEText(html, _subtype=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;html&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, _charset=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;utf-8&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 邮件正文内容&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        message.attach(message_context)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 邮件加入图片&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; filename &lt;span&gt;in&lt;/span&gt;&lt;span&gt; self.filenames:
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             name = os.path.split(filename)[-1]    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 从绝对路径中取出文件名&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt;             m_file = MIMEBase(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             m_file.add_header(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Content-Disposition&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;attachment&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, filename = name)    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将文件放入附件&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt;             f = open(filename, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;rb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;            m_file.set_payload(f.read())
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;            encoders.encode_base64(m_file)
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;            message.attach(m_file)
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; message
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; 
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;start……&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;     pic1 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\Administrator\\Pictures\\Python.png&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;     pic2 = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:\\Users\\Administrator\\Pictures\\IMG_9676.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;     pics =&lt;span&gt; []
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;    pics.append(pic1)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    pics.append(pic2)
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; 
&lt;span&gt;43&lt;/span&gt;     sendAtt =&lt;span&gt; Email4Attr(pics)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; 
&lt;span&gt;45&lt;/span&gt;     sendAtt.smtp = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;smtp.163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;46&lt;/span&gt;     sendAtt.username = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wjian.coming@163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;     sendAtt.password = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;passwd&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt;     sendAtt.subject = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Test/测试邮件&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt;     sendAtt.sender = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;wjian.coming@163.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;50&lt;/span&gt;     sendAtt.receiver.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;948001879@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     sendAtt.cc.append(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;948001879@qq.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     strs = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Please check the attachment &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt; &lt;span&gt;    sendAtt.send_email(strs)
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;end&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出，与图片不同的地方就是处理内容的方式不同，一个是放在附件中，并标记ID由主体内容读取，一个是直接放到附件中。&lt;/p&gt;
&lt;p&gt;第26行：将文件写入附件中，利用filename这个关键属性命名附件&lt;/p&gt;
&lt;p&gt;如上执行后，我们看下发送后的效果，此时两个图片已经被放进了附件中。对于文件类型的附件，都是一样处理，直接按规则调用就行了，这里就不再示例，有兴趣的伙伴可以自己下来试试呢。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1949471/202007/1949471-20200717231043055-366444236.png&quot; alt=&quot;&quot; width=&quot;586&quot; height=&quot;451&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;



&lt;p&gt;综上，对于邮件的发送只要按照指定的框架即可轻松定制，这里只是做了个指引和参考，如果您有更好的想法，或更难的挑战，不妨评论区留言，我们来互相交流一下啊。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;(希望我的文章能够助你一臂之力，成就更辉煌的你，关注我，我们一起进步)&lt;/em&gt;&lt;/p&gt;

&lt;/div&gt;</description>
<pubDate>Fri, 17 Jul 2020 15:33:00 +0000</pubDate>
<dc:creator>挖挖土豆</dc:creator>
<og:description>本章主要陈述如何发送图片，包括放在邮件主体中和附件中两种方式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/potato-find/p/13334078.html</dc:identifier>
</item>
<item>
<title>设计模式之原型模式 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/prototype-pattern.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/prototype-pattern.html</guid>
<description>&lt;h2 id=&quot;intro-简介&quot;&gt;Intro 简介&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;原型模式，用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;原型模式其实就是从一个对象再创建另外一个可定制的对象而且不需要知道任何创建的细节。&lt;/p&gt;
&lt;h2 id=&quot;实现方式&quot;&gt;实现方式&lt;/h2&gt;
&lt;p&gt;实现方式大致如下：&lt;/p&gt;
&lt;p&gt;在 c# 中可以借助 &lt;code&gt;ICloneable&lt;/code&gt; 接口和 &lt;code&gt;MemberwiseClone&lt;/code&gt; 方法来方便的实现原型模式，需要注意的是这个方法是浅复制，当对象内嵌套了另外一个对象的时候，尤其需要注意。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// 浅复制
public object Clone() =&amp;gt; MemberwiseClone();
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;简单的简历，所有的字段属性都是简单类型&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class SimpleResume : ICloneable
{
    private string _name;
    private string _email;

    private string _timePeriod;
    private string _company;

    public void SetPersonalInfo(string name, string email)
    {
        _name = name;
        _email = email;
    }

    public void SetWorkExperience(string company, string timePeriod)
    {
        _company = company;
        _timePeriod = timePeriod;
    }

    public void Display()
    {
        Console.WriteLine($&quot;{_name} {_email}&quot;);
        Console.WriteLine($&quot;工作经历：{_timePeriod} {_company}&quot;);
    }

    public object Clone() =&amp;gt; MemberwiseClone();
}

var resume = new SimpleResume();
resume.SetPersonalInfo(&quot;小明&quot;, &quot;xiaoming@abc.xyz&quot;);
resume.SetWorkExperience(&quot;xxx公司&quot;, &quot;1990~2000&quot;);
resume.Display();
var resume1 = (SimpleResume)resume.Clone();
resume1.SetWorkExperience(&quot;xxx企业&quot;, &quot;1998~1999&quot;);
resume1.Display();
var resume2 = (SimpleResume)resume.Clone();
resume2.SetPersonalInfo(&quot;xiaohong&quot;, &quot;xiaohong@abc.xyz&quot;);
resume2.Display();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;深复制示例，下面是一个复杂一些的简历，里面包含了一个 &lt;code&gt;WorkExperience&lt;/code&gt; 是另外一个类型，直接浅复制的话_workExperience 仍然指向原来的引用，来看下面的示例是怎么解决这个问题的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class WorkExperience : ICloneable
{
    public string TimePeriod { get; set; }
    public string Company { get; set; }

    public object Clone() =&amp;gt; MemberwiseClone();
}

public class ComplexResume : ICloneable
{
    private readonly WorkExperience _workExperience;
    private string _name;
    private string _email;

    public ComplexResume() =&amp;gt; _workExperience = new WorkExperience();

    private ComplexResume(WorkExperience workExperience) =&amp;gt; _workExperience = (WorkExperience)workExperience.Clone();

    public void SetPersonalInfo(string name, string email)
    {
        _name = name;
        _email = email;
    }

    public void SetWorkExperience(string comapny, string timePeriod)
    {
        _workExperience.Company = comapny;
        _workExperience.TimePeriod = timePeriod;
    }

    public void Show()
    {
        Console.WriteLine($&quot;{_name} {_email}&quot;);
        Console.WriteLine($&quot;Work Experience: {_workExperience.Company} {_workExperience.TimePeriod}&quot;);
    }

    public object Clone() =&amp;gt; new ComplexResume(_workExperience)
    {
        _name = _name,
        _email = _email
    };
}

#region deep copy

var complexResume = new ComplexResume();
complexResume.SetPersonalInfo(&quot;xiaoming&quot;, &quot;xiaoming@abc.xyz&quot;);
complexResume.SetWorkExperience(&quot;xiaomingTecch&quot;, &quot;2001~2005&quot;);
complexResume.Show();

var complexResume1 = (ComplexResume)complexResume.Clone();
complexResume1.SetPersonalInfo(&quot;xiaohong&quot;, &quot;xiaohong@abc.xyz&quot;);
complexResume1.Show();

#endregion deep copy
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;有人一定会说序列化了，当然，你用序列化也是可以做到的，序列化再反序列化得到的也是一个全新的对象，但是对于简单的对象，我觉得用上面这种方式就足够了，而且这种方式是直接操作内存，把对应的数据内存复制一份更加高效&lt;/p&gt;
&lt;p&gt;我们之前搞的推送服务里有一个推送请求的对象，会频繁的使用序列化反序列化来复制一个新的对象，这个场景就很适合使用原型模式来进行处理，高效的创建一个新的对象。&lt;/p&gt;
&lt;p&gt;在需要频繁的复制对象的场景下，都可以考虑使用原型模式来创建新的对象&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Fri, 17 Jul 2020 14:58:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>设计模式之原型模式</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/prototype-pattern.html</dc:identifier>
</item>
</channel>
</rss>