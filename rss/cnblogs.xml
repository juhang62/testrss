<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>点分树学习笔记 - liuchanglc</title>
<link>http://www.cnblogs.com/liuchanglc/p/14282204.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liuchanglc/p/14282204.html</guid>
<description>&lt;h2 id=&quot;点分树&quot;&gt;点分树&lt;/h2&gt;
&lt;p&gt;点分树借鉴了点分治的思想，将分治过程中具有父子关系的重心连边&lt;/p&gt;
&lt;p&gt;形成了一颗高度为 &lt;span class=&quot;math inline&quot;&gt;\(logn\)&lt;/span&gt; 的树&lt;/p&gt;
&lt;p&gt;这样每一次分治时，我们就不用重新去找重心，直接沿着点分树向上跳即可&lt;/p&gt;
&lt;p&gt;和点分治相比，点分树可以支持多组询问&lt;/p&gt;
&lt;p&gt;而且还能够进行修改操作，可以解决一些强制在线的题目&lt;/p&gt;
&lt;p&gt;点分树有两个性质：&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(1\)&lt;/span&gt;、原树上任意两点 &lt;span class=&quot;math inline&quot;&gt;\(p,q\)&lt;/span&gt; 在点分树上的 &lt;span class=&quot;math inline&quot;&gt;\(lca\)&lt;/span&gt; 一定在 &lt;span class=&quot;math inline&quot;&gt;\(p\)&lt;/span&gt; 到 &lt;span class=&quot;math inline&quot;&gt;\(q\)&lt;/span&gt; 的路径上&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(2\)&lt;/span&gt;、点分树的树高是 &lt;span class=&quot;math inline&quot;&gt;\(logn\)&lt;/span&gt; 级别的&lt;/p&gt;
&lt;p&gt;第一个性质决定了我们可以通过向上跳父亲来处理与路径有关的信息&lt;/p&gt;
&lt;p&gt;第二个性质则决定了我们这么做不会 &lt;span class=&quot;math inline&quot;&gt;\(T\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;一般来说，点分树的题都需要我们在节点上维护两个数据结构&lt;/p&gt;
&lt;p&gt;一个存储所有子树对自己的贡献，另一个存储所有子树对父亲的贡献，计算答案时要容斥计算&lt;/p&gt;
&lt;p&gt;因为树高是 &lt;span class=&quot;math inline&quot;&gt;\(logn\)&lt;/span&gt; 的，所以这么做的空间复杂度为 &lt;span class=&quot;math inline&quot;&gt;\(nlogn\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;二维数组肯定开不下，所以经常用 &lt;span class=&quot;math inline&quot;&gt;\(vector\)&lt;/span&gt; 来实现&lt;/p&gt;
&lt;h2 id=&quot;p6329-【模板】点分树--震波&quot;&gt;P6329 【模板】点分树 | 震波&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P6329&quot; target=&quot;_blank&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;分析&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;查询到点 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 距离小于等于 &lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt; 的所有点的权值之和，强制在线，支持修改&lt;/p&gt;
&lt;p&gt;根据点分树的第一个性质，我们可以枚举其它点与点 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的 &lt;span class=&quot;math inline&quot;&gt;\(lca\)&lt;/span&gt; 是哪一个点，这个 &lt;span class=&quot;math inline&quot;&gt;\(lca\)&lt;/span&gt; 一定是点 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 在点分树上的祖先节点&lt;/p&gt;
&lt;p&gt;假设当前枚举到的点是 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;若 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 满足条件，则有 &lt;span class=&quot;math inline&quot;&gt;\(dis(x,lca)+dis(y,lca) \leq k\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;所以只需要查询到 &lt;span class=&quot;math inline&quot;&gt;\(lca\)&lt;/span&gt; 的距离小于等于 &lt;span class=&quot;math inline&quot;&gt;\(k-dis(x,lca)\)&lt;/span&gt; 的点即可&lt;/p&gt;
&lt;p&gt;还要支持修改操作，可以用数状数组维护&lt;/p&gt;
&lt;p&gt;但是这样会有重复的情况&lt;/p&gt;
&lt;p&gt;因为我们只是简单地满足了距离关系，所以 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(y\)&lt;/span&gt; 在原树上的 &lt;span class=&quot;math inline&quot;&gt;\(lca\)&lt;/span&gt; 不一定是当前的节点，还有可能是当前点在点分树上的子节点&lt;/p&gt;
&lt;p&gt;因此要把子节点中距离 &lt;span class=&quot;math inline&quot;&gt;\(lca\)&lt;/span&gt; 的距离小于等于 &lt;span class=&quot;math inline&quot;&gt;\(k-dis(c,lca)\)&lt;/span&gt; 的贡献删除，这和点分治中的容斥是一样的&lt;/p&gt;
&lt;p&gt;但是要注意的是，点分树中的父子节点在原树上基本没有什么关系，所以不能直接在儿子节点的数状数组中把这个贡献减去&lt;/p&gt;
&lt;p&gt;而要另开一个数状数组记录儿子节点在点分树中的子树对其父亲的贡献&lt;/p&gt;
&lt;p&gt;查询时，我们从当前点开始一直跳点分树的父亲，容斥计算贡献&lt;/p&gt;
&lt;p&gt;修改时，也是暴力跳父亲，在数状数组上加入当前贡献与之前贡献的差&lt;/p&gt;
&lt;p&gt;对于一开始就有的价值，我们直接作为修改操作处理&lt;/p&gt;
&lt;p&gt;时间复杂度 &lt;span class=&quot;math inline&quot;&gt;\(mlog^2n\)&lt;/span&gt;&lt;/p&gt;
&lt;h3 id=&quot;代码&quot;&gt;代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;iostream&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#define rg register
inline int read(){
        rg int x=0,fh=1;
        rg char ch=getchar();
        while(ch&amp;lt;'0' || ch&amp;gt;'9'){
                if(ch=='-') fh=-1;
                ch=getchar();
        }
        while(ch&amp;gt;='0' &amp;amp;&amp;amp; ch&amp;lt;='9'){
                x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(ch^48);
                ch=getchar();
        }
        return x*fh;
}
const int maxn=1e5+5;
int h[maxn],tot=1,n,m,latans;
struct asd{
        int to,nxt;
}b[maxn&amp;lt;&amp;lt;1];
void ad(rg int aa,rg int bb){
        b[tot].to=bb;
        b[tot].nxt=h[aa];
        h[aa]=tot++;
}
int siz[maxn],dep[maxn],fa[maxn],son[maxn];
void dfs1(rg int now,rg int lat){
        siz[now]=1;
        dep[now]=dep[lat]+1;
        fa[now]=lat;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat) continue;
                dfs1(u,now);
                siz[now]+=siz[u];
                if(son[now]==0 || siz[u]&amp;gt;siz[son[now]]) son[now]=u;
        }
}
int tp[maxn],val[maxn];
void dfs2(rg int now,rg int top){
        tp[now]=top;
        if(son[now]) dfs2(son[now],top);
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==son[now] || u==fa[now]) continue;
                dfs2(u,u);
        }
}
int getlca(rg int xx,rg int yy){
        while(tp[xx]!=tp[yy]){
                if(dep[tp[xx]]&amp;lt;dep[tp[yy]]) std::swap(xx,yy);
                xx=fa[tp[xx]];
        }
        return dep[xx]&amp;lt;dep[yy]?xx:yy;
}
int getdis(rg int xx,rg int yy){
        return dep[xx]+dep[yy]-2*dep[getlca(xx,yy)];
}
int rt,totsiz,maxsiz[maxn];
bool vis[maxn];
void getroot(rg int now,rg int lat){
        siz[now]=1,maxsiz[now]=0;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat || vis[u]) continue;
                getroot(u,now);
                siz[now]+=siz[u];
                maxsiz[now]=std::max(maxsiz[now],siz[u]);
        }
        maxsiz[now]=std::max(maxsiz[now],totsiz-siz[now]);
        if(maxsiz[now]&amp;lt;maxsiz[rt]) rt=now;
}
int lb(rg int xx){
        return xx&amp;amp;-xx;
}
struct BIT{
        std::vector&amp;lt;int&amp;gt; tr;
        int trsiz;
        void init(rg int now){
                for(rg int i=0;i&amp;lt;=now;i++) tr.push_back(0);
                trsiz=now;
        }
        void ad(rg int wz,rg int val){
                wz=std::min(wz+1,trsiz);
                for(rg int i=wz;i&amp;lt;=trsiz;i+=lb(i)){
                        tr[i]+=val;
                }
        }
        int cx(rg int wz){
                wz=std::min(wz+1,trsiz);
                rg int nans=0;
                for(rg int i=wz;i&amp;gt;0;i-=lb(i)){
                        nans+=tr[i];
                }
                return nans;
        }
}tr1[maxn],tr2[maxn];
int newfa[maxn];
void getsiz(rg int now,rg int lat){
        siz[now]=1;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat || vis[u]) continue;
                getsiz(u,now);
                siz[now]+=siz[u];
        }
}
void predfs(rg int now){
        vis[now]=1;
        getsiz(now,0);
        rg int tmp=siz[now]+3;
        tr1[now].init(tmp);
        tr2[now].init(tmp);
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(vis[u]) continue;
                totsiz=siz[u],rt=0;
                getroot(u,now);
                newfa[rt]=now;
                predfs(rt);
        }
}//构建点分树
void updat(rg int now,rg int nval){
        for(rg int i=now;i;i=newfa[i]){
                tr1[i].ad(getdis(now,i),nval);
        }
        for(rg int i=now;newfa[i];i=newfa[i]){
                tr2[i].ad(getdis(newfa[i],now),nval);
        }
}//更新答案
int solve(rg int now,rg int k){
        rg int nans=tr1[now].cx(k);
        for(rg int i=now;newfa[i];i=newfa[i]){
                rg int tmp=getdis(newfa[i],now);
                if(k&amp;gt;=tmp) nans+=tr1[newfa[i]].cx(k-tmp)-tr2[i].cx(k-tmp);
        }
        return nans;
}//查询答案
int main(){
        memset(h,-1,sizeof(h));
        n=read(),m=read();
        for(rg int i=1;i&amp;lt;=n;i++) val[i]=read();
        rg int aa,bb,cc;
        for(rg int i=1;i&amp;lt;n;i++){
                aa=read(),bb=read();
                ad(aa,bb),ad(bb,aa);
        }
        dfs1(1,0);
        dfs2(1,1);
        maxsiz[0]=0x3f3f3f3f,rt=0,totsiz=n;
        getroot(1,0);
        predfs(rt);
        for(rg int i=1;i&amp;lt;=n;i++) updat(i,val[i]);
        for(rg int i=1;i&amp;lt;=m;i++){
                aa=read(),bb=read(),cc=read();
                bb^=latans,cc^=latans;
                if(aa==0) printf(&quot;%d\n&quot;,latans=solve(bb,cc));
                else {
                        updat(bb,cc-val[bb]);
                        val[bb]=cc;
                }
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;p3241-hnoi2015开店&quot;&gt;P3241 [HNOI2015]开店&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3241&quot; target=&quot;_blank&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;分析-1&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;查询点 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 到所有年龄在区间 &lt;span class=&quot;math inline&quot;&gt;\([l,r]\)&lt;/span&gt; 中妖怪的距离，强制在线&lt;/p&gt;
&lt;p&gt;同样可以在点分树上套数据结构解决&lt;/p&gt;
&lt;p&gt;设当前的点为 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，当前点的儿子节点为 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;那么该点对答案的贡献就是&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;子树中年龄在 &lt;span class=&quot;math inline&quot;&gt;\([l,r]\)&lt;/span&gt; 之间的妖怪到 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的距离之和 - &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 子树中年龄在 &lt;span class=&quot;math inline&quot;&gt;\([l,r]\)&lt;/span&gt; 之间的妖怪到 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的距离之和+(&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;子树中年龄在 &lt;span class=&quot;math inline&quot;&gt;\([l,r]\)&lt;/span&gt; 之间的妖怪个数- &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 子树中年龄在 &lt;span class=&quot;math inline&quot;&gt;\([l,r]\)&lt;/span&gt; 之间的妖怪个数) &lt;span class=&quot;math inline&quot;&gt;\(\times\)&lt;/span&gt; 查询点到节点 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的距离&lt;/p&gt;
&lt;p&gt;因为没有修改操作，所以直接用 &lt;span class=&quot;math inline&quot;&gt;\(vector\)&lt;/span&gt; ，&lt;span class=&quot;math inline&quot;&gt;\(vector\)&lt;/span&gt; 中存储妖怪的年龄以及妖怪到当前点的距离&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(vector\)&lt;/span&gt; 要开两个，一个记录对当前点的贡献，一个记录对父亲节点的贡献&lt;/p&gt;
&lt;p&gt;对于年龄的限制，我们在建好点分树后直接把 &lt;span class=&quot;math inline&quot;&gt;\(vector\)&lt;/span&gt; 中的元素按照年龄从小到大排序&lt;/p&gt;
&lt;p&gt;然后记录一个前缀和，查询时二分即可&lt;/p&gt;
&lt;p&gt;而妖怪的个数就是二分时下标之差&lt;/p&gt;
&lt;p&gt;距离之和直接暴力跳父亲算一下就行了&lt;/p&gt;
&lt;h3 id=&quot;代码-1&quot;&gt;代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;iostream&amp;gt;
#define rg register
inline int read(){
        rg int x=0,fh=1;
        rg char ch=getchar();
        while(ch&amp;lt;'0' || ch&amp;gt;'9'){
                if(ch=='-') fh=-1;
                ch=getchar();
        }
        while(ch&amp;gt;='0' &amp;amp;&amp;amp; ch&amp;lt;='9'){
                x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(ch^48);
                ch=getchar();
        }
        return x*fh;
}
const int maxn=1e6+5;
int h[maxn],tot=1;
struct asd{
        int to,nxt,val;
}b[maxn];
void ad(rg int aa,rg int bb,rg int cc){
        b[tot].to=bb;
        b[tot].nxt=h[aa];
        b[tot].val=cc;
        h[aa]=tot++;
}
int n,q,maxage,x[maxn],siz[maxn],fa[maxn],dep[maxn],son[maxn];
long long dis[maxn];
void dfs1(rg int now,rg int lat){
        fa[now]=lat;
        dep[now]=dep[lat]+1;
        siz[now]=1;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat) continue;
                dis[u]=dis[now]+b[i].val;
                dfs1(u,now);
                siz[now]+=siz[u];
                if(siz[son[now]]&amp;lt;siz[u]) son[now]=u;
        }
}
int tp[maxn];
void dfs2(rg int now,rg int top){
        tp[now]=top;
        if(son[now]) dfs2(son[now],top);
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==son[now] || u==fa[now]) continue;
                dfs2(u,u);
        }
}
int getlca(rg int xx,rg int yy){
        while(tp[xx]!=tp[yy]){
                if(dep[tp[xx]]&amp;lt;dep[tp[yy]]) std::swap(xx,yy);
                xx=fa[tp[xx]];
        }
        return dep[xx]&amp;lt;dep[yy]?xx:yy;
}
long long getdis(rg int xx,rg int yy){
        return dis[xx]+dis[yy]-2LL*dis[getlca(xx,yy)];
}
int maxsiz[maxn],totsiz,rt;
bool vis[maxn];
void getroot(rg int now,rg int lat){
        maxsiz[now]=0,siz[now]=1;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat || vis[u]) continue;
                getroot(u,now);
                siz[now]+=siz[u];
                maxsiz[now]=std::max(maxsiz[now],siz[u]);
        }
        maxsiz[now]=std::max(maxsiz[now],totsiz-siz[now]);
        if(maxsiz[rt]&amp;gt;maxsiz[now]) rt=now;
}
struct Node{
        int age;
        long long dis;
        Node(){}
        Node(rg int aa,rg long long bb){
                age=aa,dis=bb;
        }
        friend bool operator &amp;lt;(const Node&amp;amp; A,const Node&amp;amp; B){
                return A.age&amp;lt;B.age;
        }
};
std::vector&amp;lt;Node&amp;gt; vec[2][maxn];
void getsiz(rg int now,rg int lat){
        siz[now]=1;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat || vis[u]) continue;
                getsiz(u,now);
                siz[now]+=siz[u];
        }
}
int newfa[maxn];
void predfs(rg int now){
        vis[now]=1;
        getsiz(now,0);
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(!vis[u]){
                        rt=0,totsiz=siz[u];
                        getroot(u,now);
                        newfa[rt]=now;
                        predfs(rt);
                }
        }
}
void updat(rg int now){
        for(rg int i=now;i;i=newfa[i]){
                vec[0][i].push_back(Node(x[now],getdis(i,now)));
        }
        for(rg int i=now;newfa[i];i=newfa[i]){
                vec[1][i].push_back(Node(x[now],getdis(newfa[i],now)));
        }
}
long long latans;
int nowsiz;
long long cx(rg int op,rg int now,rg int l,rg int r){
        rg int nl=std::lower_bound(vec[op][now].begin(),vec[op][now].end(),Node(l,0))-vec[op][now].begin()-1;
        rg int nr=std::upper_bound(vec[op][now].begin(),vec[op][now].end(),Node(r,0))-vec[op][now].begin()-1;
        nowsiz=nr-nl;
        if(nr&amp;lt;0) return 0;
        if(nl&amp;lt;0) return vec[op][now][nr].dis;
        return vec[op][now][nr].dis-vec[op][now][nl].dis;
}
long long solve(rg int now,rg int l,rg int r){
        rg long long nans=cx(0,now,l,r);
        rg int sizfa,siznow;
        for(rg int i=now;newfa[i];i=newfa[i]){
                nans+=cx(0,newfa[i],l,r);
                sizfa=nowsiz;
                nans-=cx(1,i,l,r);
                siznow=nowsiz;
                nans+=1LL*(sizfa-siznow)*getdis(newfa[i],now);
        }
        return nans;
}
int main(){
        memset(h,-1,sizeof(h));
        n=read(),q=read(),maxage=read();
        for(rg int i=1;i&amp;lt;=n;i++) x[i]=read();
        rg int aa,bb,cc,l,r;
        for(rg int i=1;i&amp;lt;n;i++){
                aa=read(),bb=read(),cc=read();
                ad(aa,bb,cc);
                ad(bb,aa,cc);
        }
        dfs1(1,0);
        dfs2(1,1);
        maxsiz[0]=0x3f3f3f3f,rt=0,totsiz=n;
        getroot(1,0);
        predfs(rt);
        for(rg int i=1;i&amp;lt;=n;i++) updat(i);
        for(rg int i=1;i&amp;lt;=n;i++){
                std::sort(vec[0][i].begin(),vec[0][i].end());
                std::sort(vec[1][i].begin(),vec[1][i].end());
                for(rg int j=1;j&amp;lt;vec[0][i].size();j++) vec[0][i][j].dis+=vec[0][i][j-1].dis;
                for(rg int j=1;j&amp;lt;vec[1][i].size();j++) vec[1][i][j].dis+=vec[1][i][j-1].dis;
        }
        for(rg int i=1;i&amp;lt;=q;i++){
                aa=read(),bb=read(),cc=read();
                l=std::min((bb+latans)%maxage,(cc+latans)%maxage);
                r=std::max((bb+latans)%maxage,(cc+latans)%maxage);
                latans=solve(aa,l,r);
                printf(&quot;%lld\n&quot;,latans);
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;p3345-zjoi2015幻想乡战略游戏&quot;&gt;P3345 [ZJOI2015]幻想乡战略游戏&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3345&quot; target=&quot;_blank&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;分析-2&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;这道题实际上就是让我们寻找带权重心&lt;/p&gt;
&lt;p&gt;假设当前的点为 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt;，&lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 的子节点为 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt;,&lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 和 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 之间的边权为 &lt;span class=&quot;math inline&quot;&gt;\(len\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果 &lt;span class=&quot;math inline&quot;&gt;\(x\)&lt;/span&gt; 子树内一点 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 更优，那么一定有 &lt;span class=&quot;math inline&quot;&gt;\((totsiz-siz[u]) \times len - siz[u] \times len &amp;lt;0\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因为边权是正的，所以就有 &lt;span class=&quot;math inline&quot;&gt;\(2siz[u]&amp;gt;totsiz\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;显然满足这个条件的儿子只有一个&lt;/p&gt;
&lt;p&gt;因为每一个点的度数不会超过 &lt;span class=&quot;math inline&quot;&gt;\(20\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;因此可以在点分树上暴力地寻找&lt;/p&gt;
&lt;p&gt;注意一定要在点分树上找，不要跑到原树上去找，否则复杂度就假了&lt;/p&gt;
&lt;p&gt;如果用 &lt;span class=&quot;math inline&quot;&gt;\(st\)&lt;/span&gt; 表 &lt;span class=&quot;math inline&quot;&gt;\(O(1)\)&lt;/span&gt; 求 &lt;span class=&quot;math inline&quot;&gt;\(lca\)&lt;/span&gt;，那么复杂度就是 &lt;span class=&quot;math inline&quot;&gt;\(20qlog^2n\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;但实际上跑得还没有树剖快&lt;/p&gt;
&lt;h3 id=&quot;代码-2&quot;&gt;代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;vector&amp;gt;
#include&amp;lt;iostream&amp;gt;
#define rg register
inline int read(){
        rg int x=0,fh=1;
        rg char ch=getchar();
        while(ch&amp;lt;'0' || ch&amp;gt;'9'){
                if(ch=='-') fh=-1;
                ch=getchar();
        }
        while(ch&amp;gt;='0' &amp;amp;&amp;amp; ch&amp;lt;='9'){
                x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(ch^48);
                ch=getchar();
        }
        return x*fh;
}
const int maxn=2e5+5;
int h[maxn],tot=1;
struct asd{
        int to,nxt,val;
}b[maxn&amp;lt;&amp;lt;1];
void ad(rg int aa,rg int bb,rg int cc){
        b[tot].to=bb;
        b[tot].nxt=h[aa];
        b[tot].val=cc;
        h[aa]=tot++;
}
int n,q,x[maxn],siz[maxn],eul[maxn],dfnc,dep[maxn],lg[maxn&amp;lt;&amp;lt;1],st[maxn&amp;lt;&amp;lt;1][22],rk[maxn&amp;lt;&amp;lt;1];
long long dis[maxn];
void dfs(rg int now,rg int lat){
        dep[now]=dep[lat]+1;
        eul[now]=++dfnc;
        rk[dfnc]=now;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat) continue;
                dis[u]=dis[now]+b[i].val;
                dfs(u,now);
                rk[++dfnc]=now;
        }
}
void prest(){
        for(rg int i=2;i&amp;lt;=dfnc;i++) lg[i]=lg[i&amp;gt;&amp;gt;1]+1;
        for(rg int i=1;i&amp;lt;=dfnc;i++) st[i][0]=rk[i];
        for(rg int j=1;j&amp;lt;=20;j++){
                for(rg int i=1;i+(1&amp;lt;&amp;lt;j)-1&amp;lt;=dfnc;i++){
                        if(dep[st[i][j-1]]&amp;lt;dep[st[i+(1&amp;lt;&amp;lt;(j-1))][j-1]]) st[i][j]=st[i][j-1];
                        else st[i][j]=st[i+(1&amp;lt;&amp;lt;(j-1))][j-1];
                }
        }
}
int getlca(rg int xx,rg int yy){
        xx=eul[xx],yy=eul[yy];
        if(xx&amp;gt;yy) std::swap(xx,yy);
        rg int nk=lg[yy-xx+1];
        return dep[st[xx][nk]]&amp;lt;dep[st[yy-(1&amp;lt;&amp;lt;nk)+1][nk]]?st[xx][nk]:st[yy-(1&amp;lt;&amp;lt;nk)+1][nk];
}
long long getdis(rg int xx,rg int yy){
        return dis[xx]+dis[yy]-2LL*dis[getlca(xx,yy)];
}
int maxsiz[maxn],totsiz,rt;
bool vis[maxn];
void getroot(rg int now,rg int lat){
        maxsiz[now]=0,siz[now]=1;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat || vis[u]) continue;
                getroot(u,now);
                siz[now]+=siz[u];
                maxsiz[now]=std::max(maxsiz[now],siz[u]);
        }
        maxsiz[now]=std::max(maxsiz[now],totsiz-siz[now]);
        if(maxsiz[rt]&amp;gt;maxsiz[now]) rt=now;
}
void getsiz(rg int now,rg int lat){
        siz[now]=1;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat || vis[u]) continue;
                getsiz(u,now);
                siz[now]+=siz[u];
        }
}
int newfa[maxn];
std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt; &amp;gt; g[maxn];
void predfs(rg int now){
        vis[now]=1;
        getsiz(now,0);
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(!vis[u]){
                        rt=0,totsiz=siz[u];
                        getroot(u,now);
                        newfa[rt]=now;
                        g[now].push_back(std::make_pair(u,rt));
                        predfs(rt);
                }
        }
}
long long sum1[maxn],sum2[maxn];
int siz1[maxn],siz2[maxn];
void updat(rg int now,rg int val){
        for(rg int i=now;i;i=newfa[i]){
                sum1[i]+=1LL*getdis(now,i)*val;
                siz1[i]+=val;
        }
        for(rg int i=now;newfa[i];i=newfa[i]){
                sum2[i]+=1LL*getdis(now,newfa[i])*val;
                siz2[i]+=val;
        }
}
long long cx(rg int now){
        rg long long nans=sum1[now];
        for(rg int i=now;newfa[i];i=newfa[i]){
                nans+=sum1[newfa[i]];
                nans-=sum2[i];
                nans+=1LL*getdis(newfa[i],now)*(siz1[newfa[i]]-siz2[i]);
        }
        return nans;
}
long long solve(rg int now){
        rg long long tmp=cx(now);
        for(rg int i=0;i&amp;lt;g[now].size();i++){
                if(cx(g[now][i].first)&amp;lt;tmp) return solve(g[now][i].second);
        }
        return tmp;
}
int main(){
        memset(h,-1,sizeof(h));
        n=read(),q=read();
        rg int aa,bb,cc;
        for(rg int i=1;i&amp;lt;n;i++){
                aa=read(),bb=read(),cc=read();
                ad(aa,bb,cc);
                ad(bb,aa,cc);
        }
        dfs(1,0);
        prest();
        maxsiz[0]=0x3f3f3f3f,rt=0,totsiz=n;
        getroot(1,0);
        predfs(rt);
        memset(vis,0,sizeof(vis));
        rt=0,totsiz=n;
        getroot(1,0);
        for(rg int i=1;i&amp;lt;=q;i++){
                aa=read(),bb=read();
                updat(aa,bb);
                printf(&quot;%lld\n&quot;,solve(rt));
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;p2056-zjoi2007捉迷藏&quot;&gt;P2056 [ZJOI2007]捉迷藏&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2056&quot; target=&quot;_blank&quot;&gt;题目传送门&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;分析-3&quot;&gt;分析&lt;/h3&gt;
&lt;p&gt;和其它点分树的题目一样，对于每一个节点我们开两个堆，防止同一个子树内的节点对父亲节点做多次贡献&lt;/p&gt;
&lt;p&gt;一个堆里存点分树中 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 的子树所有点到点分树中 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 的父亲的距离&lt;/p&gt;
&lt;p&gt;另一个堆里存点分树中 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 的所有儿子对 &lt;span class=&quot;math inline&quot;&gt;\(u\)&lt;/span&gt; 贡献的最大值&lt;/p&gt;
&lt;p&gt;那么答案就是第二个堆中最大值与次大值之和&lt;/p&gt;
&lt;p&gt;加入贡献时，我们直接扔到大根堆里就可以了&lt;/p&gt;
&lt;p&gt;删除贡献时，我们再开一个堆，堆里面存储所有已经删除过的元素&lt;/p&gt;
&lt;p&gt;查询时只要不断弹两个堆的堆顶，直到一个堆为空或者两个堆堆顶的元素不相同为止&lt;/p&gt;
&lt;h3 id=&quot;代码-3&quot;&gt;代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include&amp;lt;cstdio&amp;gt;
#include&amp;lt;algorithm&amp;gt;
#include&amp;lt;cstring&amp;gt;
#include&amp;lt;cmath&amp;gt;
#include&amp;lt;queue&amp;gt;
#include&amp;lt;iostream&amp;gt;
#define rg register
inline int read(){
        rg int x=0,fh=1;
        rg char ch=getchar();
        while(ch&amp;lt;'0' || ch&amp;gt;'9'){
                if(ch=='-') fh=-1;
                ch=getchar();
        }
        while(ch&amp;gt;='0' &amp;amp;&amp;amp; ch&amp;lt;='9'){
                x=(x&amp;lt;&amp;lt;1)+(x&amp;lt;&amp;lt;3)+(ch^48);
                ch=getchar();
        }
        return x*fh;
}
const int maxn=1e5+5;
int h[maxn],tot=1;
struct asd{
        int to,nxt;
}b[maxn&amp;lt;&amp;lt;1];
void ad(rg int aa,rg int bb){
        b[tot].to=bb;
        b[tot].nxt=h[aa];
        h[aa]=tot++;
}
int n,q,siz[maxn],fa[maxn],dep[maxn],son[maxn];
void dfs1(rg int now,rg int lat){
        fa[now]=lat;
        dep[now]=dep[lat]+1;
        siz[now]=1;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat) continue;
                dfs1(u,now);
                siz[now]+=siz[u];
                if(siz[son[now]]&amp;lt;siz[u]) son[now]=u;
        }
}
int tp[maxn];
void dfs2(rg int now,rg int top){
        tp[now]=top;
        if(son[now]) dfs2(son[now],top);
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==son[now] || u==fa[now]) continue;
                dfs2(u,u);
        }
}
int getlca(rg int xx,rg int yy){
        while(tp[xx]!=tp[yy]){
                if(dep[tp[xx]]&amp;lt;dep[tp[yy]]) std::swap(xx,yy);
                xx=fa[tp[xx]];
        }
        return dep[xx]&amp;lt;dep[yy]?xx:yy;
}
int getdis(rg int xx,rg int yy){
        return dep[xx]+dep[yy]-2*dep[getlca(xx,yy)];
}
int maxsiz[maxn],totsiz,rt;
bool vis[maxn];
void getroot(rg int now,rg int lat){
        maxsiz[now]=0,siz[now]=1;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat || vis[u]) continue;
                getroot(u,now);
                siz[now]+=siz[u];
                maxsiz[now]=std::max(maxsiz[now],siz[u]);
        }
        maxsiz[now]=std::max(maxsiz[now],totsiz-siz[now]);
        if(maxsiz[rt]&amp;gt;maxsiz[now]) rt=now;
}
void getsiz(rg int now,rg int lat){
        siz[now]=1;
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(u==lat || vis[u]) continue;
                getsiz(u,now);
                siz[now]+=siz[u];
        }
}
int newfa[maxn];
void predfs(rg int now){
        vis[now]=1;
        getsiz(now,0);
        for(rg int i=h[now];i!=-1;i=b[i].nxt){
                rg int u=b[i].to;
                if(!vis[u]){
                        rt=0,totsiz=siz[u];
                        getroot(u,now);
                        newfa[rt]=now;
                        predfs(rt);
                }
        }
}
char s[maxn];
struct Splay{
        std::priority_queue&amp;lt;int&amp;gt; q1;
        std::priority_queue&amp;lt;int&amp;gt; q2;
        void updat(){
                for(;!q1.empty() &amp;amp;&amp;amp; !q2.empty() &amp;amp;&amp;amp; q1.top()==q2.top();){
                    q1.pop();
                    q2.pop();
                }
        }
        void insert(rg int val){
                q1.push(val);
        }
        void pop(rg int val){
                q2.push(val);
        }
        int getmax(){
                updat();
                return q1.top();
        }
        int getsec(){
                updat();
                rg int now1=q1.top();q1.pop();
                updat();
                rg int now2=q1.top();q1.pop();
                q1.push(now1),q1.push(now2);
                return now2;
        }
        int size(){
                return q1.size()-q2.size();
        }
}ansnow[maxn],ansfa[maxn],ans;
void updat(rg int now){
        vis[now]^=1;
        if(vis[now]==0){
                if(ansnow[now].size()&amp;gt;=2) ans.pop(ansnow[now].getmax()+ansnow[now].getsec());
                ansnow[now].insert(0);
                if(ansnow[now].size()&amp;gt;=2) ans.insert(ansnow[now].getmax()+ansnow[now].getsec());
                for(rg int i=now;newfa[i];i=newfa[i]){
                        if(ansnow[newfa[i]].size()&amp;gt;=2) ans.pop(ansnow[newfa[i]].getmax()+ansnow[newfa[i]].getsec());
                        rg int ndis=getdis(now,newfa[i]);
                        if(ansfa[i].size()) ansnow[newfa[i]].pop(ansfa[i].getmax());
                        ansfa[i].insert(ndis);
                        if(ansfa[i].size()) ansnow[newfa[i]].insert(ansfa[i].getmax());
                        if(ansnow[newfa[i]].size()&amp;gt;=2) ans.insert(ansnow[newfa[i]].getmax()+ansnow[newfa[i]].getsec());
                }
        } else {
                if(ansnow[now].size()&amp;gt;=2) ans.pop(ansnow[now].getmax()+ansnow[now].getsec());
                ansnow[now].pop(0);
                if(ansnow[now].size()&amp;gt;=2) ans.insert(ansnow[now].getmax()+ansnow[now].getsec());
                for(rg int i=now;newfa[i];i=newfa[i]){
                        if(ansnow[newfa[i]].size()&amp;gt;=2) ans.pop(ansnow[newfa[i]].getmax()+ansnow[newfa[i]].getsec());
                        rg int ndis=getdis(now,newfa[i]);
                        if(ansfa[i].size()) ansnow[newfa[i]].pop(ansfa[i].getmax());
                        ansfa[i].pop(ndis);
                        if(ansfa[i].size()) ansnow[newfa[i]].insert(ansfa[i].getmax());
                        if(ansnow[newfa[i]].size()&amp;gt;=2) ans.insert(ansnow[newfa[i]].getmax()+ansnow[newfa[i]].getsec());
                }
        }
}
int cnt;
int main(){
        memset(h,-1,sizeof(h));
        n=read();
        rg int aa,bb;
        for(rg int i=1;i&amp;lt;n;i++){
                aa=read(),bb=read();
                ad(aa,bb);
                ad(bb,aa);
        }
        dfs1(1,0);
        dfs2(1,1);
        maxsiz[0]=0x3f3f3f3f,rt=0,totsiz=n;
        getroot(1,0);
        predfs(rt);
        q=read();
        memset(vis,0,sizeof(vis));
        for(rg int i=1;i&amp;lt;=n;i++){
                for(rg int j=i;newfa[j];j=newfa[j]){
                        ansfa[j].insert(getdis(i,newfa[j]));
                }
        }
        for(rg int i=1;i&amp;lt;=n;i++){
                ansnow[i].insert(0);
                if(newfa[i] &amp;amp;&amp;amp; ansfa[i].size()) ansnow[newfa[i]].insert(ansfa[i].getmax());
        }
        for(rg int i=1;i&amp;lt;=n;i++){
                if(ansnow[i].size()&amp;gt;=2) ans.insert(ansnow[i].getmax()+ansnow[i].getsec());
        }
        cnt=n;
        for(rg int i=1;i&amp;lt;=q;i++){
                scanf(&quot;%s&quot;,s+1);
                if(s[1]=='G'){
                        if(cnt==0) printf(&quot;-1\n&quot;);
                        else if(cnt==1) printf(&quot;0\n&quot;);
                        else printf(&quot;%d\n&quot;,ans.getmax());
                } else {
                        aa=read();
                        if(vis[aa]) cnt++;
                        else cnt--;
                        updat(aa);
                }
        }
        return 0;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 15 Jan 2021 22:15:00 +0000</pubDate>
<dc:creator>liuchanglc</dc:creator>
<og:description>点分树学习笔记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liuchanglc/p/14282204.html</dc:identifier>
</item>
<item>
<title>Mybatis的缓存 - 吴楠予</title>
<link>http://www.cnblogs.com/Narule/p/14284868.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Narule/p/14284868.html</guid>
<description>&lt;p&gt;mybatis是一个查询数据库的封装框架，主要是封装提供灵活的增删改sql，开发中，service层能够通过mybatis组件查询和修改数据库中表的数据；作为查询工具，mybatis有使用缓存，这里讲一下mybatis的缓存相关源码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缓存&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在计算机里面，任何信息都有源头，缓存一般指源头信息读取后，放在内存或者其他读取较快的地方，下次读取相同信息不去源头查询而是直接从内存（或者能快速存取的硬件）读取。这样可以减少硬件使用，提高读取速度。&lt;/p&gt;
&lt;p&gt;mybatis也是这样，查询数据库的数据之后，mybatis可以把查询结果缓存到内存，下次查询如果查询语句相同，并且查询相关的表的数据没被修改过，就可以直接返回缓存中的结果，而不用去查询数据库的语句，有效节省了时间。&lt;/p&gt;
&lt;p&gt;简单看一下mybatis一级缓存和二级缓存相关源码，学习使用&lt;/p&gt;
&lt;h2 id=&quot;一级缓存&quot;&gt;一级缓存&lt;/h2&gt;
&lt;p&gt;通过查看源码可知，一级缓存是绑定sqSsession中的，所以每次查询sqlSession不同就失效，相同的sqlSession可以使用一级缓存。&lt;/p&gt;
&lt;p&gt;mybatis默认sqlsession：&lt;code&gt;org.apache.ibatis.session.defaults.DefaultSqlSession&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;构造方法中传入executor（查询执行对象）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public DefaultSqlSession(Configuration configuration, Executor executor, boolean autoCommit) {
    this.configuration = configuration;
    this.executor = executor;
    this.dirty = false;
    this.autoCommit = autoCommit;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;executor中携带一级缓存成员：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  protected BaseExecutor(Configuration configuration, Transaction transaction) {
    this.transaction = transaction;
    this.deferredLoads = new ConcurrentLinkedQueue&amp;lt;&amp;gt;();
    this.localCache = new PerpetualCache(&quot;LocalCache&quot;); //默认一级缓存
    this.localOutputParameterCache = new PerpetualCache(&quot;LocalOutputParameterCache&quot;);
    this.closed = false;
    this.configuration = configuration;
    this.wrapper = this;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查询使用一级缓存逻辑&quot;&gt;查询使用一级缓存逻辑&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;org.apache.ibatis.executor.BaseExecutor.query()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    ErrorContext.instance().resource(ms.getResource()).activity(&quot;executing a query&quot;).object(ms.getId());
    
    List&amp;lt;E&amp;gt; list;
    try {
      queryStack++;
        //localCache 一级缓存
      list = resultHandler == null ? (List&amp;lt;E&amp;gt;) localCache.getObject(key) : null;
        //先从一级缓存中获取，key是通过sql语句生成
      if (list != null) {
        handleLocallyCachedOutputParameters(ms, key, parameter, boundSql);
      } else {
        // 如果缓存中没有 才从数据库查询
        list = queryFromDatabase(ms, parameter, rowBounds, resultHandler, key, boundSql);
      }
    } finally {
      queryStack--;
    }
    return list;
  }

  //从数据库读取数据
  private &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; queryFromDatabase(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql) throws SQLException {
    List&amp;lt;E&amp;gt; list;
    localCache.putObject(key, EXECUTION_PLACEHOLDER);
    try {
      list = doQuery(ms, parameter, rowBounds, resultHandler, boundSql);
    } finally {
      localCache.removeObject(key);//将一级缓存清除
    }
    localCache.putObject(key, list);//返回查询结果之前，先放入一级缓存 刷新
    if (ms.getStatementType() == StatementType.CALLABLE) {
      localOutputParameterCache.putObject(key, parameter);
    }
    return list;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二级缓存&quot;&gt;二级缓存&lt;/h2&gt;
&lt;p&gt;二级缓存mapper中的，默认是开启的，但需要在映射文件mapper.xml中添加&lt;code&gt;&amp;lt;cache/&amp;gt;&lt;/code&gt;标签&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;mapper namespace=&quot;userMapper&quot;&amp;gt;
        &amp;lt;cache/&amp;gt;&amp;lt;!-- 添加cache标签表示此mapper使用二级缓存 --&amp;gt;
&amp;lt;/mapper&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置false可以关闭二级缓存&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-yml&quot;&gt;mybatis:
  configuration:
     cache-enabled: false #默认值为true，表示开启
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;二级缓存的解析&quot;&gt;二级缓存的解析&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;org.apache.ibatis.builder.xml.XMLMapperBuilder&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  private void configurationElement(XNode context) {
    try {
      //...
      cacheElement(context.evalNode(&quot;cache&quot;)); //解析cache标签
    } catch (Exception e) {
      throw new BuilderException(&quot;Error parsing Mapper XML. The XML location is '&quot; + resource + &quot;'. Cause: &quot; + e, e);
    }
  }

  private void cacheElement(XNode context) {
    if (context != null) { // if hava cache tag 如果有cache标签才执行下面的逻辑
      String type = context.getStringAttribute(&quot;type&quot;, &quot;PERPETUAL&quot;);
      Class&amp;lt;? extends Cache&amp;gt; typeClass = typeAliasRegistry.resolveAlias(type);
      String eviction = context.getStringAttribute(&quot;eviction&quot;, &quot;LRU&quot;);
      Class&amp;lt;? extends Cache&amp;gt; evictionClass = typeAliasRegistry.resolveAlias(eviction);
      Long flushInterval = context.getLongAttribute(&quot;flushInterval&quot;);
      Integer size = context.getIntAttribute(&quot;size&quot;);
      boolean readWrite = !context.getBooleanAttribute(&quot;readOnly&quot;, false);
      boolean blocking = context.getBooleanAttribute(&quot;blocking&quot;, false);
      Properties props = context.getChildrenAsProperties();
      builderAssistant.useNewCache(typeClass, evictionClass, flushInterval, size, readWrite, blocking, props);//建立二级缓存
    }
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;org.apache.ibatis.builder.MapperBuilderAssistant.useNewCache()&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  public Cache useNewCache(Class&amp;lt;? extends Cache&amp;gt; typeClass,
      Class&amp;lt;? extends Cache&amp;gt; evictionClass,
      Long flushInterval,
      Integer size,
      boolean readWrite,
      boolean blocking,
      Properties props) {
    Cache cache = new CacheBuilder(currentNamespace)
        .implementation(valueOrDefault(typeClass, PerpetualCache.class))
        .addDecorator(valueOrDefault(evictionClass, LruCache.class))
        .clearInterval(flushInterval)
        .size(size)
        .readWrite(readWrite)
        .blocking(blocking)
        .properties(props)
        .build();
    configuration.addCache(cache);//二级缓存赋值，如果cache标签为空，不会执行此方法，currentCache为空
    currentCache = cache; 
    return cache;
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在映射文件mapper中如果没有cache标签，不会执行上面的useNewCache方法，cache为null，就不会使用二级缓存（相当于失效）。&lt;/p&gt;
&lt;h3 id=&quot;查询使用二级缓存逻辑&quot;&gt;查询使用二级缓存逻辑&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;org.apache.ibatis.executor.CachingExecutor&lt;/code&gt; :&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;  @Override
  public &amp;lt;E&amp;gt; List&amp;lt;E&amp;gt; query(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)
      throws SQLException {
    Cache cache = ms.getCache(); 
    if (cache != null) {//如果二级缓存对象不为空 尝试在二级缓存中获取（没有cache标签此对象就是空）
      flushCacheIfRequired(ms);
      if (ms.isUseCache() &amp;amp;&amp;amp; resultHandler == null) {
        ensureNoOutParams(ms, boundSql);
        @SuppressWarnings(&quot;unchecked&quot;)
        List&amp;lt;E&amp;gt; list = (List&amp;lt;E&amp;gt;) tcm.getObject(cache, key); //从二级缓存中获取数据
        if (list == null) {
          list = delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql); //如果为空，使用delegate查询（BaseExecutor）
          tcm.putObject(cache, key, list); // 查询结果保存到二级缓存
        }
        return list;
      }
    }
    return delegate.query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二级缓存和一级缓存不用想，数据库的数据被修改是要清空缓存的，不然数据有误，至于怎么清空，是另一套逻辑了，mapper中的cache标签可以配置一些参数，比如缓存定期清空。&lt;/p&gt;
&lt;h2 id=&quot;一级二级缓存先后顺序&quot;&gt;一级二级缓存先后顺序&lt;/h2&gt;
&lt;p&gt;mybatis默认是先查询二级缓存，没有，再查看一级缓存，都为空，最后查询数据库&lt;/p&gt;
</description>
<pubDate>Fri, 15 Jan 2021 19:47:00 +0000</pubDate>
<dc:creator>吴楠予</dc:creator>
<og:description>mybatis的一级，二级缓存使用逻辑，什么情况缓存会失效</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Narule/p/14284868.html</dc:identifier>
</item>
<item>
<title>基于医疗知识图谱的问答系统（二）   - 何莫道</title>
<link>http://www.cnblogs.com/upuphe/p/14284807.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/upuphe/p/14284807.html</guid>
<description>&lt;div class=&quot;cnblogs_code&quot; readability=&quot;54&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt;!/usr/bin/env python3&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; coding: utf-8&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; os
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; ahocorasick
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; sklearn.externals &lt;span&gt;import&lt;/span&gt;&lt;span&gt; joblib
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; jieba
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; numpy as np

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; EntityExtractor:
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 构造actree，加速过滤&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; build_actree(self, wordlist):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        构造actree，加速过滤
        :param wordlist:
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 模式匹配, 得到匹配的词和类型。如疾病，疾病别名，并发症，症状&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; entity_reg(self, question):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        模式匹配, 得到匹配的词和类型。如疾病，疾病别名，并发症，症状
        :param question:str
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 当全匹配失败时，就采用相似度计算来找相似的词&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; find_sim_words(self, question):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        当全匹配失败时，就采用相似度计算来找相似的词
        :param question:
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 采用DP方法计算编辑距离&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; editDistanceDP(self, s1, s2):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        采用DP方法计算编辑距离
        :param s1:
        :param s2:
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 计算词语和字典中的词的相似度&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; simCal(self, word, entities, flag):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        计算词语和字典中的词的相似度
        相同字符的个数/min(|A|,|B|)   +  余弦相似度
        :param word: str
        :param entities:List
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 基于特征词分类&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; check_words(self, wds, sent):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        基于特征词分类
        :param wds:
        :param sent:
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取问题的TF-IDF特征&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; tfidf_features(self, text, vectorizer):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        提取问题的TF-IDF特征
        :param text:
        :param vectorizer:
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提取问题的关键词特征&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; other_features(self, text):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        提取问题的关键词特征
        :param text:
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 预测意图&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; model_predict(self, x, model):
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;span&gt;
        预测意图
        :param x:
        :param model:
        :return:
        &lt;/span&gt;&lt;span&gt;&quot;&quot;&quot;&lt;/span&gt;
        &lt;span&gt;pass&lt;/span&gt;

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 实体抽取主函数&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; extractor(self, question):
        &lt;/span&gt;&lt;span&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 15 Jan 2021 16:42:00 +0000</pubDate>
<dc:creator>何莫道</dc:creator>
<og:description>一.问答系统 问答系统从知识领域划分： 封闭领域：封闭领域系统专注于回答特定领域的问题，由于问题领域受限，系统有比较大的发挥空间，可以导入领域知识或将答案来源全部转换成结构性资料来有效提升系统的表现；</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/upuphe/p/14284807.html</dc:identifier>
</item>
<item>
<title>机器学习(一)：5分钟理解机器学习并上手实践 - CaiYongji</title>
<link>http://www.cnblogs.com/takeurhand/p/14284786.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/takeurhand/p/14284786.html</guid>
<description>&lt;p&gt;现在市面上的机器学习教程大多先学习数学基础，然后学机器学习的数学算法，再建立机器学习的数学模型，再学习深度学习，再学习工程化，再考虑落地。这其中每个环节都在快速发展，唯独落地特别困难。我们花费大量时间成本去学习以上内容，成本无疑是特别昂贵的。所以我们不如先“盲人摸象”、“不求甚解”地探索下机器学习，浅尝辄止。如果想到自己的应用场景，再学以致用，深入探索。这无疑是使沉没成本最低的决策。&lt;br/&gt;本教程适合兴趣广泛的人士增加自己知识的广度，从应用的角度谨“使用”机器学习这款工具，是典型的黑盒思维。这非常契合笔者的思维方式，当然也是我个人的格局局限。&lt;br/&gt;本教程会浅显易懂，让你走的很快。但如果你想走的更远还请学习数学。当然我们也只是暂时放下数学，先构建自己的知识体系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先抬头看路，找准适合自己的方向，再埋头赶路，或深耕下去……&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;从手工到工业化再到人工智能，这是把人类从生产活动中逐渐解放的过程。用机器来帮助人们工作，一直是人类的美好愿望。让机器智能化，以此来代替人力做更智能问题，这可以作为人工智能的简单解释。&lt;br/&gt;很多教程或者书籍把人工智能、机器学习、深度学习的关系解释为从属关系，人工智能 &amp;gt; 机器学习 &amp;gt; 深度学习。这种解释不错，但却无法表示他们之间的更深层次的关系。&lt;br/&gt;&lt;strong&gt;机器学习是通过数学方法在数据中寻找解释，以此来实现人工智能的一种手段。而深度学习是参照神经系统在机器学习基础上发展出的一种高级技巧。&lt;/strong&gt; 它们之间是存在一定的依托关系、进化趋势的。&lt;br/&gt;狭义地讲，传统的机器学习是通过数学模型不断求导来找出数据规律的过程。这其中数学模型的选择尤为重要。随着GPU、TPU等算力的发展，算法技术的进步，甚至出现了自动选模型、自动调参的技术。我们可以构建复杂的神经网络结构，只要有足够的算力支持，足够的时间我们可以用深度学习处理非常复杂的任务。所以在代码操作上，深度学习甚至比传统的机器学习对程序员更友好、更易理解。我们先学习传统机器学习而非直接学习深度学习的好处是，我们可以通过对“黑盒”的拆箱来理解机器学习过程，掌握机器学习的概念，我会对其中应用的数学模型进行解释。&lt;/p&gt;
&lt;p&gt;我们先来看一下人工智能产业链的结构，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/678094/202101/678094-20210116002002387-190543355.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到，机器学习的三大基石---算力、算法与数据。机器学习的发展离不开算法数学的进步，同样离不开算力的发展。&lt;br/&gt;在技术层面，机器学习在计算机视觉（CV, Computer Vision）和自然语言处理（NLP, Nature Language Processing）取得了关键的发展和应用。&lt;br/&gt;算法分类上，机器学习分为监督学习、非监督学习、半监督学习、强化学习等。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;监督学习&lt;/strong&gt;：数据样本有标签。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非监督学习&lt;/strong&gt;：数据样本无标签。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;半监督学习&lt;/strong&gt;：数据样本有部分(少量)标签。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;强化学习&lt;/strong&gt;：趋向结果则奖励，偏离结果则惩罚。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所谓Garbage in, Garbage out(垃圾进，垃圾出)。数据是机器学习的重中之重。我们需要花费大量的时间来处理数据，甚至占到整个机器学习任务的90%以上。&lt;br/&gt;比如数据处理过程中的数据采集，如果我们采样的方式欠妥，就可能导致非代表性的数据集，这就导致了采样偏差。&lt;br/&gt;我们的数据可能会有很多无效的数据，我们需要剔除无效的数据，就叫做数据清洗。&lt;br/&gt;我们通过挖掘大量数据来发现不太明显的规律，就称作数据挖掘。&lt;/p&gt;

&lt;p&gt;我们以一款工业化流水线工具TFX为例，看一下机器学习的技术流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/678094/202101/678094-20210116002011802-820784103.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;流程分为数据输入、数据验证、特征工程、训练模型、验证模型、应用良好模型和提供模型六个部分：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;输入数据，并根据需要拆分数据集。&lt;/li&gt;
&lt;li&gt;生成训练数据和服务数据的特征统计信息。通过从训练数据中推断出类型、类别和范围来创建架构。识别训练数据和服务数据中的异常值。&lt;/li&gt;
&lt;li&gt;对数据集执行特征工程。&lt;/li&gt;
&lt;li&gt;训练模型，调整模型的超参数。&lt;/li&gt;
&lt;li&gt;对训练结果进行深入分析，并帮助验证导出的模型。检查模型是否确实可以从基础架构提供服务，并防止推送不良模型。&lt;/li&gt;
&lt;li&gt;将模型部署到服务基础架构。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;我想通过以上解释，大家应该可以对机器学习的实践方法有了一定宏观的了解。&lt;/p&gt;

&lt;p&gt;我们从宏观角度看了机器学习的产业结构、工业化流程，你应该对你自己在机器学习的这些环节中有哪些发挥有了一定的把握。现在我们把视角拉回到微观层面，看看机器是如何学习的。&lt;/p&gt;
&lt;p&gt;我们以摄氏度转换华氏度为例。&lt;br/&gt;传统编程中，我们要求得摄氏度和华氏度的关系，我们必须找出公式：&lt;br/&gt;$$ Fahrenheit = Celsius * 1.8 + 32 $$&lt;/p&gt;
&lt;p&gt;而在对机器学习来说，我们有大量的数据，却需要找出关系。机器学习的过程就是不断求导，以此来找出数学模型，来解释规律的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/678094/202101/678094-20210116002020460-1831737249.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如图所示，我们有摄氏度数据0, 8, 15, 22, 38以及华氏度数据32, 46.4, 59, 71.6, 100.4，机器学习的过程就是找出公式的过程。&lt;br/&gt;其中，摄氏度就是我们的&lt;strong&gt;特征&lt;/strong&gt;，华氏度就是我们的&lt;strong&gt;标签&lt;/strong&gt;，摄氏度与华氏度的关系就是&lt;strong&gt;实例&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;特征&lt;/strong&gt;：我们模型的输入。 在这种情况下，只有一个值-摄氏度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;标签&lt;/strong&gt;：我们的模型预测的输出。 在这种情况下，只有一个值-华氏度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实例&lt;/strong&gt;：训练期间使用的一对输入/输出。 在我们的例子中，是摄氏度/华氏度一对数据，例如，(0, 32), (8, 46.4)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;蓝色的部分表示我们设置好数学函数，然后通过不断的调整权重与偏差不断地&lt;strong&gt;拟合&lt;/strong&gt;数据，最终得到可以表示规律的&lt;strong&gt;模型&lt;/strong&gt;的过程。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;拟合&lt;/strong&gt;：通过训练数据，使模型来概括表示数据的过程。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;模型&lt;/strong&gt;：图结构，包含了训练过程中的权重与偏差的数据。其中的图为由各函数组成的计算结构。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上手代码之前我默认你已经配置好了环境，掌握了Jupyter, Numpy, Pandas, Matplotlib的用法。如果你没有掌握以上技能，请参考我写的配套教程&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;amp;__biz=MzUxMjU4NjI4MQ==&amp;amp;scene=1&amp;amp;album_id=1627166768236412929&amp;amp;count=3#wechat_redirect&quot; target=&quot;_blank&quot;&gt;前置机器学习系列&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import numpy as np
import matplotlib.pyplot as plt
celsius    = [[-40], [-10], [ 0], [ 8], [15], [22], [ 38]]
fahrenheit = [[-40], [ 14], [32], [46.4], [59], [71.6], [100.4]]
plt.scatter(celsius,fahrenheit, c='red', label='real')
plt.xlabel('celsius')
plt.ylabel('fahrenheit')
plt.legend()
plt.grid(True)
plt.title('real data')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如上代码所示，我们准备摄氏度与华氏度的数据，然后通过matplotlib库绘制图像。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/678094/202101/678094-20210116002029835-1875266932.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from sklearn.linear_model import LinearRegression
lr = LinearRegression()
lr.fit(celsius,fahrenheit)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们通过上方仅仅3行代码就训练了数据。&lt;code&gt;LinearRegression&lt;/code&gt;是scikit-learn包下的线性回归方法，是普通的最小二乘线性回归。而&lt;code&gt;fit&lt;/code&gt;就是拟合的意思，以此来训练模型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;celsius_test = [[-50],[-30],[10],[20],[50],[70]]
fahrenheit_test = lr.predict(celsius_test)
plt.scatter(celsius,fahrenheit, c='red', label='real')
plt.scatter(celsius_test,fahrenheit_test, c='orange', label='predicted')
plt.xlabel('celsius')
plt.ylabel('fahrenheit')
plt.legend()
plt.grid(True)
plt.title('estimated vs real data')
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来我们调用&lt;code&gt;lr.predict(celsius_test)&lt;/code&gt;方法来进行预测，以此来检验我们的模型准确度。我们通过下方图像中黄色的点可以看出，我们的模型非常准确。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/678094/202101/678094-20210116002038817-2032125395.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;你就说这玩意简单不简单！&lt;/strong&gt; 咳咳，别嚣张，我们好好玩。&lt;/p&gt;

&lt;p&gt;既然都上手了，我们也试一试深度学习代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import tensorflow as tf
import numpy as np

# prepare data
celsius_q    = np.array([-40, -10,  0,  8, 15, 22,  38],  dtype=float)
fahrenheit_a = np.array([-40,  14, 32, 46.4, 59, 71.6, 100.4],  dtype=float)

# fit model
model = tf.keras.Sequential([tf.keras.layers.Dense(units=1, input_shape=[1])])
model.compile(loss='mean_squared_error', optimizer=tf.keras.optimizers.Adam(0.1))
history = model.fit(celsius_q, fahrenheit_a, epochs=500, verbose=False)
print(&quot;Finished training the model&quot;)

# print loss
import matplotlib.pyplot as plt
plt.xlabel('Epoch Number')
plt.ylabel(&quot;Loss Magnitude&quot;)
plt.plot(history.history['loss'])
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们使用TensorFlow内置的Keras方法创建了1层的神经网络，选择了MSE损失函数以及Adam优化器，训练了500代。&lt;/p&gt;
&lt;p&gt;如下图可以看到，随着代(epoch)数量的增加，损失函数的结果逐渐降低。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/678094/202101/678094-20210116002046908-1359226348.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么什么是损失函数呢？我们在接下来的文章中一探究竟。感谢您的关注公众号【caiyongji】与支持！&lt;/p&gt;

</description>
<pubDate>Fri, 15 Jan 2021 16:21:00 +0000</pubDate>
<dc:creator>CaiYongji</dc:creator>
<og:description>引言 现在市面上的机器学习教程大多先学习数学基础，然后学机器学习的数学算法，再建立机器学习的数学模型，再学习深度学习，再学习工程化，再考虑落地。这其中每个环节都在快速发展，唯独落地特别困难。我们花费大</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/takeurhand/p/14284786.html</dc:identifier>
</item>
<item>
<title>HttpClientFactory 结合 Polly 轻松实现重试机制 - WeihanLi</title>
<link>http://www.cnblogs.com/weihanli/p/httpclientfactory-polly.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weihanli/p/httpclientfactory-polly.html</guid>
<description>&lt;h2 id=&quot;intro&quot;&gt;Intro&lt;/h2&gt;
&lt;p&gt;我们的服务里有一个 API 会去调用第三方的接口，设置了超时时间，最近偶尔会发生超时的情况，微软在提供 &lt;code&gt;HttpClientFactory&lt;/code&gt; 的同时，也提供了一个基于 &lt;code&gt;Polly&lt;/code&gt; 的一个扩展，我们可以借助它轻松地实现重试，熔断等行为。&lt;/p&gt;
&lt;h2 id=&quot;sample&quot;&gt;Sample&lt;/h2&gt;
&lt;p&gt;使用 Polly 扩展需要引用 nuget 包 ：&lt;code&gt;Microsoft.Extensions.Http.Polly&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;services.AddHttpClient(ServiceConst.IterableHttpClientName, x =&amp;gt;
{
    x.Timeout = new TimeSpan(0, 0, 3);
})
    .AddTransientHttpErrorPolicy(builder =&amp;gt;
    {
        return builder.Or&amp;lt;TaskCanceledException&amp;gt;()
            .Or&amp;lt;OperationCanceledException&amp;gt;()
            .Or&amp;lt;TimeoutException&amp;gt;()
            .OrResult(res =&amp;gt; res.StatusCode == HttpStatusCode.TooManyRequests || (int)res.StatusCode &amp;gt;= 500)
            .RetryAsync(5)
            ;
    })
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;AddTransientHttpErrorPolicy&lt;/code&gt; 扩展方法来注册一个 Polly 的 policy，具体可以通过 &lt;code&gt;policyBuilder&lt;/code&gt; 委托来定制自己要处理的情况和 policy 行为，支持方式有很多可以简单的指定重试，也可以指定 &lt;code&gt;WaitANdRetryAsync&lt;/code&gt; 等待一段时间后重试，可以重试一次也可以一直重试下去，非常的灵活，可以根据自己的业务场景进行定制化配置，这里的示例直接是用了简单的重试机制&lt;/p&gt;
&lt;h2 id=&quot;单元测试&quot;&gt;单元测试&lt;/h2&gt;
&lt;p&gt;下面提供了一个测试重试的单元测试，也可以作为使用示例的一个参考：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;
[Fact]
public async Task TaskCanceledException()
{
    var ticks = new ConcurrentBag&amp;lt;long&amp;gt;();
    var retryLimit = 5;

    var services = new ServiceCollection();
    services.AddHttpClient(&quot;test&quot;, x =&amp;gt;
        {
            x.Timeout = TimeSpan.FromSeconds(1);
        })
        .AddTransientHttpErrorPolicy(builder =&amp;gt;
        {
            return builder.Or&amp;lt;TaskCanceledException&amp;gt;()
                    .Or&amp;lt;OperationCanceledException&amp;gt;()
                    .Or&amp;lt;TimeoutException&amp;gt;()
                    .OrResult(res =&amp;gt;
                        res.StatusCode == HttpStatusCode.TooManyRequests || (int)res.StatusCode &amp;gt;= 500)
                    .RetryAsync(retryLimit)
                ;
        })
        .AddHttpMessageHandler(() =&amp;gt; new MockHttpHandler(request =&amp;gt;
        {
            ticks.Add(DateTime.UtcNow.Ticks);
            throw new TaskCanceledException();
        }))

        ;
    await using var provider = services.BuildServiceProvider();
    try
    {
        using var response = await provider.GetRequiredService&amp;lt;IHttpClientFactory&amp;gt;()
            .CreateClient(&quot;test&quot;)
            .GetAsync(&quot;api/test&quot;);
    }
    catch (Exception e)
    {
        Assert.True(e is OperationCanceledException);
    }
    Assert.Equal(retryLimit + 1, ticks.Count);
}

private class MockHttpHandler : DelegatingHandler
{
    private readonly Func&amp;lt;HttpRequestMessage, HttpResponseMessage&amp;gt; _getResponseFunc;

    public MockHttpHandler(Func&amp;lt;HttpRequestMessage, HttpResponseMessage&amp;gt; getResponseFunc)
    {
        _getResponseFunc = getResponseFunc;
    }

    protected override Task&amp;lt;HttpResponseMessage&amp;gt; SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)
    {
        return Task.FromResult(_getResponseFunc(request));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;more&quot;&gt;More&lt;/h2&gt;
&lt;p&gt;除了 &lt;code&gt;AddTransientHttpErrorPolicy&lt;/code&gt; 之外，Polly 扩展还支持 &lt;code&gt;AddPolicyHandler&lt;/code&gt;/&lt;code&gt;AddPolicyHandlerFromRegistry&lt;/code&gt; 扩展方法，有兴趣的可以自己探索一下哈~~&lt;/p&gt;
&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
</description>
<pubDate>Fri, 15 Jan 2021 15:56:00 +0000</pubDate>
<dc:creator>WeihanLi</dc:creator>
<og:description>HttpClientFactory 结合 Polly 轻松实现重试机制</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/weihanli/p/httpclientfactory-polly.html</dc:identifier>
</item>
<item>
<title>Redis 设计与实现 10：五大数据类型之有序集合 - 小新是也</title>
<link>http://www.cnblogs.com/chenchuxin/p/14284737.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenchuxin/p/14284737.html</guid>
<description>&lt;p&gt;有序集合 &lt;code&gt;sorted set&lt;/code&gt; (下面我们叫&lt;code&gt;zset&lt;/code&gt; 吧) 有两种编码方式：压缩列表 &lt;code&gt;ziplist&lt;/code&gt; 和跳表 &lt;code&gt;skiplist&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;编码一：ziplist&quot;&gt;编码一：ziplist&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;zset&lt;/code&gt; 在 &lt;code&gt;ziplist&lt;/code&gt; 中，成员(&lt;code&gt;member&lt;/code&gt;)和分数(&lt;code&gt;score&lt;/code&gt;)是挨在一起的，元素按照分数从小到大存储。&lt;/p&gt;
&lt;p&gt;举个例子，我们用以下命令创建一个&lt;code&gt;zset&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;redis＞ ZADD key 26.1 z 1 a 2 b
(integer) 3
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么这个&lt;code&gt;zset&lt;/code&gt;的结构大致如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210111233930266.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;下面我们来分析一下 &lt;code&gt;zscore&lt;/code&gt; 命令的源码，进一步了解 &lt;code&gt;zset&lt;/code&gt; 是如何利用 &lt;code&gt;ziplist&lt;/code&gt; 存储的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int zsetScore(robj *zobj, sds member, double *score) {
    // ...
    if (zobj-&amp;gt;encoding == OBJ_ENCODING_ZIPLIST) {
        if (zzlFind(zobj-&amp;gt;ptr, member, score) == NULL) return C_ERR;
    }
    // ...
    return C_OK;
}

unsigned char *zzlFind(unsigned char *zl, sds ele, double *score) {
    // eptr 是 member 的指针，sptr 是 score 的指针
    unsigned char *eptr = ziplistIndex(zl,0), *sptr;

    // 遍历 ziplist
    while (eptr != NULL) {
        // 因为 member 和 score 是挨着存储的，所以获取 member 的下一个节点就是 score 啦
        sptr = ziplistNext(zl,eptr);
        serverAssert(sptr != NULL);

        // 对比当前的 member 和要查询的 member 是否相等
        if (ziplistCompare(eptr,(unsigned char*)ele,sdslen(ele))) {
            // 如果相等，则获取分数
            if (score != NULL) *score = zzlGetScore(sptr);
            return eptr;
        }

        // 不相等则继续往下遍历
        eptr = ziplistNext(zl,sptr);
    }
    return NULL;
}

// 获取分数
double zzlGetScore(unsigned char *sptr) {
    unsigned char *vstr;
    unsigned int vlen;
    long long vlong;
    char buf[128];
    double score;

    serverAssert(sptr != NULL);
    // ziplistGet 通过 sptr 指针获取值。根据节点的编码(前文有说到ziplist节点的编码) 对参数赋值
    // 如果是字符串，则赋值到 vstr; 如果是整数，则赋值到 vlong。
    serverAssert(ziplistGet(sptr,&amp;amp;vstr,&amp;amp;vlen,&amp;amp;vlong));

    if (vstr) {
        // 如果是字符串，那么存的就是浮点数
        memcpy(buf,vstr,vlen);
        buf[vlen] = '\0';
        // 字符串转换成浮点数
        score = strtod(buf,NULL);
    } else {
        // 整数类型就直接赋值
        score = vlong;
    }

    return score;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编码二：skiplist&quot;&gt;编码二：skiplist&lt;/h2&gt;
&lt;h3 id=&quot;跳表的实现&quot;&gt;跳表的实现&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;skiplist&lt;/code&gt; 编码的底层实现是跳表。&lt;/p&gt;
&lt;p&gt;下面是跳表的结构图 (图片来自 &lt;a href=&quot;http://1e-gallery.redisbook.com/index.html&quot; target=&quot;_blank&quot;&gt;《Redis 设计与实现》图片集&lt;/a&gt; )&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/26681bd0ed8866a7a3951128a3881902.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;图中最左部分就是 &lt;code&gt;zskiplist&lt;/code&gt; 结构，其代码实现如下(&lt;code&gt;server.h&lt;/code&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct zskiplist {
    // 头指针和尾指针，指向头尾节点
    struct zskiplistNode *header, *tail;
    // 跳表的节点数(不包含头结点，空跳表也会包含头结点)
    unsigned long length;
    // 所有节点中，最大的层数
    int level;
} zskiplist;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;图中右边的四个节点，就是跳表节点 &lt;code&gt;zskiplistNode&lt;/code&gt;，其代码实现如下(&lt;code&gt;server.h&lt;/code&gt;)：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct zskiplistNode {
    // 成员
    sds ele;
    // 分数
    double score;
    // 后退指针，指向前一个节点
    struct zskiplistNode *backward;
    // 层，每个节点可能有很多层，每个层可能指向不同的节点
    struct zskiplistLevel {
        // 前进指针，指向下一个节点
        struct zskiplistNode *forward;
        // 跟下一个节点之间的跨度
        unsigned long span;
    } level[];
} zskiplistNode;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;跳表最重要的一个地方就是层 &lt;code&gt;level&lt;/code&gt;，为什么这么说呢？&lt;/p&gt;
&lt;p&gt;假设&lt;code&gt;zset&lt;/code&gt; 用链表有序存储，如果我们要查找数据，只能从头到尾遍历，时间复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;，效率很低。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210112234452991.png&quot; alt=&quot;链表&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有什么办法提高效率呢？我们可以在上面添加一层索引。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021011223445347.png&quot; alt=&quot;链表加索引&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;可以看出，我们遍历的性能变高了。例如我们想找到 6，先遍历第一层，5 到 7 之间，再往下探，就能找到 6 了！&lt;br/&gt;有读者就发现了，如果数据量很大，那找起来也很慢。&lt;br/&gt;是的，那么怎么解决呢？再往上加索引呗！&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210112235117838.png&quot; alt=&quot;链表再加几层索引&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;这不，链表就变成了跳表了！而上面说的层，就是这些索引啦！最终跳表的查找时间复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(logn)\)&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;我们来看看 &lt;code&gt;zrange&lt;/code&gt; 命令的核心实现，来感受一下跳表的遍历吧&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;zskiplistNode* zslGetElementByRank(zskiplist *zsl, unsigned long rank) {
    zskiplistNode *x;
    unsigned long traversed = 0;
    int i;
    // 层头结点开始
    x = zsl-&amp;gt;header;
    // 层从高到低
    for (i = zsl-&amp;gt;level-1; i &amp;gt;= 0; i--) {
        // 只要遍历的数没有达到 rank，就一直遍历
        while (x-&amp;gt;level[i].forward &amp;amp;&amp;amp; (traversed + x-&amp;gt;level[i].span) &amp;lt;= rank)
        {
            // 每次加上层的跨度
            traversed += x-&amp;gt;level[i].span;
            // 往前走
            x = x-&amp;gt;level[i].forward;
        }
        // 如果这一层走完还没到 rank，那就往下层走，如果还是找不到就继续走，直到走到最底层
        if (traversed == rank) {
            return x;
        }
    }
    return NULL;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;zset-的结构&quot;&gt;zset 的结构&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;skiplist&lt;/code&gt; 编码的 &lt;code&gt;zset&lt;/code&gt; 的结构定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;typedef struct zset {
    dict *dict;
    zskiplist *zsl;
} zset;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结构中包含了一个字典和一个跳表，为什么用了跳表还需要字典呢？&lt;br/&gt;命令&lt;code&gt;zscore&lt;/code&gt;这种单找一个值的，如果只用跳表的话，那么查找的时间复杂度是 &lt;span class=&quot;math inline&quot;&gt;\(O(logn)\)&lt;/span&gt;，加上一个字典可以把时间复杂度缩减为 &lt;span class=&quot;math inline&quot;&gt;\(O(n)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;那么肯定有同学就会说，加一个字典会浪费了很多空间。&lt;br/&gt;的确，多加一个字典肯定会多占用一定的空间，空间换时间是一种常见的做法。不过字典的值指向的对象跟跳表的对象是共用的。&lt;/p&gt;
&lt;p&gt;下图是一个 &lt;code&gt;zset&lt;/code&gt; 的示例，为了方便，把他们指向的字符串对象都分别画出来了，实际上是共享的。(图片来自 &lt;a href=&quot;http://1e-gallery.redisbook.com/index.html&quot; target=&quot;_blank&quot;&gt;《Redis 设计与实现》图片集&lt;/a&gt; )&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/01e7abcbeb6bd6eaa8e21cf4a77e058e.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;源码分析&quot;&gt;源码分析&lt;/h3&gt;
&lt;p&gt;我们来看看 &lt;code&gt;skiplist&lt;/code&gt; 编码下的 &lt;code&gt;zscore&lt;/code&gt; 如何实现吧。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c&quot;&gt;int zsetScore(robj *zobj, sds member, double *score) {
    // 前面其他 ziplist 编码的就省略了...
    // if ...
    else if (zobj-&amp;gt;encoding == OBJ_ENCODING_SKIPLIST) {
        zset *zs = zobj-&amp;gt;ptr;
        // 直接通过 dict 查找，时间复杂度复杂度 O(1)
        dictEntry *de = dictFind(zs-&amp;gt;dict, member);
        if (de == NULL) return C_ERR;
        *score = *(double*)dictGetVal(de);
    }
    
    // ...
    return C_OK;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;编码转换&quot;&gt;编码转换&lt;/h2&gt;
&lt;p&gt;当有序集合对象可以同时满足以下两个条件时，对象使用 &lt;code&gt;ziplist&lt;/code&gt; 编码：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;有序集合保存的元素数量小于128个(可通过 &lt;code&gt;zset-max-ziplist-entries&lt;/code&gt; 修改配置)；&lt;/li&gt;
&lt;li&gt;有序集合保存的所有元素成员的长度都小于64字节(可通过 &lt;code&gt;zset-max-ziplist-value&lt;/code&gt; 修改配置)；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;不能满足以上两个条件的有序集合对象将使用 &lt;code&gt;skiplist&lt;/code&gt; 编码。&lt;/p&gt;
</description>
<pubDate>Fri, 15 Jan 2021 15:48:00 +0000</pubDate>
<dc:creator>小新是也</dc:creator>
<og:description>有序集合有两种编码方式：压缩列表 ziplist 和跳表 skiplist。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chenchuxin/p/14284737.html</dc:identifier>
</item>
<item>
<title>谈谈你不知道的gist - Leader755</title>
<link>http://www.cnblogs.com/leader755/p/14284716.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leader755/p/14284716.html</guid>
<description>&lt;p&gt;1.Gist是什么&lt;br/&gt;关于Gist的详细介绍，请阅读官方文档&lt;a href=&quot;https://help.github.com/en/articles/about-gists&quot; target=&quot;_blank&quot;&gt;About gists&lt;/a&gt;，下面只简略介绍部分功能：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;Gist是一种与其他人共享代码片段和粘贴的简单方法。 当您需要与同事或朋友共享示例代码或技术时，可以使用它。&lt;/li&gt;
&lt;li&gt;GitHub提供了一个平台，可以作为团队（私人仓库）或整个世界（公共仓库）的回购共享整个项目。&lt;/li&gt;
&lt;li&gt;Gist就是小型代码片段的分享. 类似的服务还有如 &lt;a href=&quot;http://pastebin.com/&quot; target=&quot;_blank&quot;&gt;Pastebin&lt;/a&gt; 和 &lt;a href=&quot;http://pastie.org/&quot; target=&quot;_blank&quot;&gt;Pastie&lt;/a&gt;, 但明显出生于Github的Gist更有优势了。&lt;/li&gt;
&lt;li&gt;Gist可以用来写一些东西，然后可以分享，类似笔记软件&lt;/li&gt;
&lt;li&gt;每个Gist都是一个Git库，有版本历史，可以被fork或clone&lt;/li&gt;
&lt;li&gt;Gist有两种：公开的和私有的，私有的不会在你的Gist主页显示，也无法用搜索引擎搜索到，但这个链接是人人都能访问的&lt;/li&gt;
&lt;li&gt;Gist可以搜索、下载、嵌入到网页&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;br/&gt;&lt;h2 id=&quot;2创建新gist-编辑修改gist&quot;&gt;2.创建新Gist, 编辑修改Gist&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://gist.github.com/&quot; target=&quot;_blank&quot;&gt;https://gist.github.com/&lt;/a&gt; , 直接填写内容或者在自己的Gist 右上角上点击 New gist即可&lt;/li&gt;
&lt;li&gt;可以一个Gist多个文件, 使用 Add file 添加即可.&lt;/li&gt;
&lt;li&gt;可以设置indent为空格space还是tab, tab长度, 是否行缩进.&lt;/li&gt;
&lt;li&gt;点 Create secret gist 创建私有代码, Create public gist 创建开放的gist. 前者可以不被搜索到.&lt;/li&gt;
&lt;li&gt;创建Gist后,点选自己的某个Gist, 进去后右上角可进行网上的编辑/修改: Edit, 编辑; Delete, 删除; Star, 标星. 旁边还有举报 . 修改后下方的Update public/secret gist即可保存修改.&lt;/li&gt;
&lt;li&gt;编辑时上方的Make Secret可以转为私有库.&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/241787/1609763853304-4c4752b4-9249-450e-9194-99d2f469b688.png#align=left&amp;amp;display=inline&amp;amp;height=799&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=799&amp;amp;originWidth=1902&amp;amp;size=78557&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1902&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&quot;3浏览gist&quot;&gt;3.浏览Gist&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;&lt;li&gt;左上角可以看到列出自己最近的gist, 右上角See all of your gists可以查看所有自己的Gist.私有gist会显示SECRET标签.&lt;/li&gt;
&lt;li&gt;搜索框可以进行代码搜索(开放gist), 可能搜出相关的代码片段&lt;/li&gt;
&lt;li&gt;点All Gists可以到Discover gists模式, 查看最近发布或被fork的gists(或者别的排序方式). 参考意义不大.&lt;/li&gt;
&lt;li&gt;在浏览Gist时点击右上GithubGist图标或者左上头像选Your Gists即可返回&lt;/li&gt;
&lt;li&gt;在浏览Gist文件时, 点Raw可以看文字的纯代码.&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/241787/1609764783415-9360e86d-2b00-4a87-ad62-c5c18adf8a40.png#align=left&amp;amp;display=inline&amp;amp;height=920&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=920&amp;amp;originWidth=1905&amp;amp;size=113902&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1905&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h2 id=&quot;4分享&quot;&gt;4.分享&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;点击一个gist进去, , 在 Edit菜单下方有几个选项:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;分享 (可选方式框,代码/地址, 复制到黏贴板),
&lt;ul&gt;&lt;li&gt;Embed 是HTML嵌入代码,&lt;/li&gt;
&lt;li&gt;Share是分享链接,&lt;/li&gt;
&lt;li&gt;Clone via HTTPS是https克隆&lt;/li&gt;
&lt;li&gt;Clone via SSH是ssh克隆&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;下载下来使用Github Desktop打开管理,&lt;/li&gt;
&lt;li&gt;Download Zip(下载全部内容并打包).&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/241787/1609764289629-71d68f1e-b8a3-41a5-86c5-38bb1de621e8.png#align=left&amp;amp;display=inline&amp;amp;height=924&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=924&amp;amp;originWidth=1905&amp;amp;size=139893&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1905&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;&amp;lt;script src=&quot;https://gist.github.com/Leader755/93a14d335e6650edbb7fe17e6aedb51d.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;

&lt;h2 id=&quot;5创建vscode的gist的代码片段分享&quot;&gt;5.创建vscode的gist的代码片段分享&lt;/h2&gt;

&lt;h3 id=&quot;1首先在github中创建personal-access-tokens，创建成功将获取到秘钥保存只会展示一次。&quot;&gt;1.首先在github中创建Personal access tokens，创建成功将获取到秘钥保存(只会展示一次)。&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/241787/1609766189892-d932cfab-6169-4c42-8f81-f98011ff28ae.png#align=left&amp;amp;display=inline&amp;amp;height=1055&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=1055&amp;amp;originWidth=1333&amp;amp;size=109198&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1333&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2vscode中插件中搜索share-code并安装&quot;&gt;2.vscode中插件中搜索share code并安装&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/241787/1609766300298-333db3e2-047a-4c62-9543-dcef5a12d9f0.png#align=left&amp;amp;display=inline&amp;amp;height=783&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=783&amp;amp;originWidth=1856&amp;amp;size=179994&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1856&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;/p&gt;

&lt;h3 id=&quot;3设置快捷键并在settingjson中配置github等相关的信息。&quot;&gt;3.设置快捷键并在setting.json中配置github等相关的信息。&lt;/h3&gt;

&lt;h4 id=&quot;1ctrlshiftp打开搜索，输入share-code，并点击设置配置快捷方式&quot;&gt;1&amp;gt;ctrl+shift+p打开搜索，输入share code，并点击设置配置快捷方式&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/241787/1609766482073-5b67a170-7b1b-4cdd-aaef-1c7002fa0276.png#align=left&amp;amp;display=inline&amp;amp;height=119&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=119&amp;amp;originWidth=1156&amp;amp;size=16597&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1156&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/241787/1609766507674-b9797660-1da9-4d42-a545-520a1bbeb853.png#align=left&amp;amp;display=inline&amp;amp;height=98&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=98&amp;amp;originWidth=1446&amp;amp;size=7978&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1446&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h4 id=&quot;2在settingjson中配置以下&quot;&gt;2&amp;gt;在setting.json中配置以下:&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt; //vscode的gist的分享
  &quot;shareCode.github.username&quot;: &quot;Leader755&quot;,
  &quot;shareCode.github.authtoken&quot;: &quot;3751ef6lkgds4e0befkhdwe82f1bccf907b3a6038a22&quot;,//填写自己的
  &quot;shareCode.pastebin.username&quot;: &quot;...&quot;,
  &quot;shareCode.pastebin.authtoken&quot;: &quot;...&quot;,
  &quot;shareCode.gitlab.baseurl&quot;: &quot;...&quot;,
  &quot;shareCode.gitlab.authtoken&quot;: &quot;...&quot;
 //vscode的gist的分享
&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;4vscode中分享代码片段到github&quot;&gt;4.vscode中分享代码片段到github&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://cdn.nlark.com/yuque/0/2021/png/241787/1609766797275-3f9b9ca2-19f2-4204-bde1-2586290dd498.png#align=left&amp;amp;display=inline&amp;amp;height=535&amp;amp;margin=%5Bobject%20Object%5D&amp;amp;name=image.png&amp;amp;originHeight=535&amp;amp;originWidth=1317&amp;amp;size=131759&amp;amp;status=done&amp;amp;style=none&amp;amp;width=1317&quot; alt=&quot;image.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 15 Jan 2021 15:37:00 +0000</pubDate>
<dc:creator>Leader755</dc:creator>
<og:description>1.Gist是什么关于Gist的详细介绍，请阅读官方文档About gists，下面只简略介绍部分功能： Gist是一种与其他人共享代码片段和粘贴的简单方法。 当您需要与同事或朋友共享示例代码或技术时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leader755/p/14284716.html</dc:identifier>
</item>
<item>
<title>.NET 云原生架构师训练营（模块二 基础巩固 敏捷开发）--学习笔记 - MingsonZheng</title>
<link>http://www.cnblogs.com/MingsonZheng/p/14284703.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MingsonZheng/p/14284703.html</guid>
<description>&lt;h2 id=&quot;敏捷介绍&quot;&gt;敏捷介绍&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;敏捷的起源&lt;/li&gt;
&lt;li&gt;敏捷软件开发宣言&lt;/li&gt;
&lt;li&gt;敏捷开发十二原则&lt;/li&gt;
&lt;li&gt;生命周期对比&lt;/li&gt;
&lt;li&gt;敏捷开发的特点&lt;/li&gt;
&lt;li&gt;敏捷的发展&lt;/li&gt;
&lt;li&gt;敏捷的核心&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;敏捷的起源&quot;&gt;敏捷的起源&lt;/h3&gt;
&lt;p&gt;2001年，17个老头子在一起一边滑雪，一边讨论工作，制定了《敏捷软件开发宣言》&lt;/p&gt;
&lt;p&gt;从60年代中期开始到20世纪末，软件行业得到了非常迅猛的发展，软件系统的规模和复杂度也越来越高，行业普遍面临&lt;strong&gt;不满足需求，永远无法交付&lt;/strong&gt;等一系列严重的问题，史称“软件危机”&lt;/p&gt;
&lt;p&gt;从长期积累的经验看，早期阶段的时间投入会影响到后期的经济支出，就是&lt;strong&gt;需求变化发生的越晚，对软件交付的影响越大&lt;/strong&gt;，这是瀑布模式存在产生的核心观点，所以瀑布模式主张非常完整的设计，&lt;strong&gt;拒绝需求变化&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;拒绝变化带来双向的负面效应，软件需求方&lt;strong&gt;得不到自己满意的产品&lt;/strong&gt;，另一方面，由于过度强调计划，&lt;strong&gt;忽视领导者和管理者在团队中起的作用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;针对以上两个负面效应，敏捷软件开发宣言中“&lt;strong&gt;拥抱变化&lt;/strong&gt;”和“&lt;strong&gt;尊重个体&lt;/strong&gt;”成为两个核心的观点&lt;/p&gt;
&lt;h3 id=&quot;敏捷软件开发宣言&quot;&gt;敏捷软件开发宣言&lt;/h3&gt;
&lt;p&gt;敏捷软件开发宣言：&lt;a href=&quot;https://www.scrumcn.com/agile/scrum-knowledge-library/agilevalues.html&quot; target=&quot;_blank&quot;&gt;https://www.scrumcn.com/agile/scrum-knowledge-library/agilevalues.html&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;个体和互动 高于 流程和工具&lt;/li&gt;
&lt;li&gt;工作的软件 高于 详尽的文档&lt;/li&gt;
&lt;li&gt;客户合作 高于 合同谈判&lt;/li&gt;
&lt;li&gt;响应变化 高于 遵循计划&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;敏捷开发十二原则&quot;&gt;敏捷开发十二原则&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;我们最重要的目标，是通过及早和持续不断地交付&lt;strong&gt;有价值的软件&lt;/strong&gt;使客户满意。&lt;/li&gt;
&lt;li&gt;欣然面对需求变化，即使在开发后期也一样。为了客户的竞争优势，敏捷过程掌控变化。&lt;/li&gt;
&lt;li&gt;经常地交付&lt;strong&gt;可工作的软件&lt;/strong&gt;，相隔几星期或一两个月，倾向于采取较短的周期。&lt;/li&gt;
&lt;li&gt;业务人员和开发人员必须&lt;strong&gt;相互合作&lt;/strong&gt;，项目中的每一天都不例外。&lt;/li&gt;
&lt;li&gt;激发个体的斗志，以他们为核心搭建项目。提供所需的环境和支援，辅以&lt;strong&gt;信任&lt;/strong&gt;，从而达成目标。&lt;/li&gt;
&lt;li&gt;不论团队内外，传递信息效果最好效率也最高的方式是&lt;strong&gt;面对面的交谈&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可工作的软件&lt;/strong&gt;是进度的首要度量标准。&lt;/li&gt;
&lt;li&gt;敏捷过程倡导&lt;strong&gt;可持续开发&lt;/strong&gt;。责任人、开发人员和用户要能够共同维持其步调稳定延续。&lt;/li&gt;
&lt;li&gt;坚持不懈地追求&lt;strong&gt;技术卓越和良好设计&lt;/strong&gt;，敏捷能力由此增强。&lt;/li&gt;
&lt;li&gt;以&lt;strong&gt;简洁&lt;/strong&gt;为本，它是极力减少不必要工作量的艺术。&lt;/li&gt;
&lt;li&gt;最好的架构、需求和设计出自&lt;strong&gt;自组织团队&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;团队定期地&lt;strong&gt;反思&lt;/strong&gt;如何能提高成效，并依此&lt;strong&gt;调整&lt;/strong&gt;自身的行为表现。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;生命周期对比&quot;&gt;生命周期对比&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;生命周期&lt;/th&gt;
&lt;th&gt;需求&lt;/th&gt;
&lt;th&gt;活动&lt;/th&gt;
&lt;th&gt;交付&lt;/th&gt;
&lt;th&gt;流程&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;瀑布&lt;/td&gt;
&lt;td&gt;固定的，需求明确&lt;/td&gt;
&lt;td&gt;整个项目进行一次&lt;/td&gt;
&lt;td&gt;一次交付&lt;/td&gt;
&lt;td&gt;强调文档，用里程碑的方式，严格定义各阶段的输入和输出。不走回头路，如果出现返工，付出的代价巨大&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;敏捷&lt;/td&gt;
&lt;td&gt;动态的，贴近客户需求&lt;/td&gt;
&lt;td&gt;重复，直到正确为止&lt;/td&gt;
&lt;td&gt;频繁小的交付&lt;/td&gt;
&lt;td&gt;核心是小版本迭代。短、频、快的沟通与反馈机制，减少客户价值创造过程中的损耗&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;敏捷开发的特点&quot;&gt;敏捷开发的特点&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;小步快跑&lt;/li&gt;
&lt;li&gt;有项目计划，但也要“&lt;strong&gt;拥抱变化&lt;/strong&gt;”&lt;/li&gt;
&lt;li&gt;版本迭代周期内尽量不加任务&lt;/li&gt;
&lt;li&gt;团队配置也要敏捷&lt;/li&gt;
&lt;li&gt;敏捷也需要反思&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;敏捷的发展&quot;&gt;敏捷的发展&lt;/h3&gt;
&lt;p&gt;敏捷发展的3个阶段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在软件行业被定义&lt;/li&gt;
&lt;li&gt;在商业活动中发扬光大&lt;/li&gt;
&lt;li&gt;软件商业活动汇合&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;后面两个阶段的开启受到了以下两个概念的启发：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;精益创业&lt;/li&gt;
&lt;li&gt;持续交付2.0&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;精益创业&quot;&gt;精益创业&lt;/h4&gt;
&lt;p&gt;2021年美国作家埃里克·莱斯出版了《精益创业》一书中的&lt;strong&gt;精简式反馈，以小见大&lt;/strong&gt;等概念与敏捷软件开发迭代模型有很多相似之处&lt;/p&gt;
&lt;p&gt;在 SCRUM 中要求每个迭代&lt;strong&gt;都能交付给有用价值的功能（可以工作的软件）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;埃里克在束中提到的最小可行性产品 MVP 强调用&lt;strong&gt;最快，最简明的方式建立一个可用的产品原型&lt;/strong&gt;，通过这个最简单的产品原型来测试产品是否符合市场预期，并通过不断的快速迭代来修正产品，最终适应市场需求&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202101/1412316-20210115233155594-1328304589.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;定义 MVP 的关键在于，&lt;strong&gt;需要抓住用户的核心完整需求，在之后的迭代中不断地将核心完整需求变的好用&lt;/strong&gt;。要求是那些必不可少的且最后是完整可用的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软件开发终究是为商业活动服务的&lt;/strong&gt;，只有在商业活动也是敏捷的情况下，敏捷软件开发才能发挥最大的威力。可惜的是精益创业的思想产生比软件敏捷开发思维晚了整整11年&lt;/p&gt;
&lt;h4 id=&quot;持续交付20&quot;&gt;持续交付2.0&lt;/h4&gt;
&lt;p&gt;国内 DevOps 专家乔梁在2019年出版了《持续交付2.0：业务引领的DevOps精要》中提出双环模型强调“只有业务方能够以“精益”方式思考，持续交付才能更显威力”，由此软件开发活动与商业活动有了完整统一的方法论模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1412316/202101/1412316-20210115233206526-1962562452.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提问：用户需要什么&lt;/li&gt;
&lt;li&gt;锚定：背后的真正需求&lt;/li&gt;
&lt;li&gt;共创：业务，销售，开发人员一起思考解决方案&lt;/li&gt;
&lt;li&gt;精炼，决策&lt;/li&gt;
&lt;li&gt;构建&lt;/li&gt;
&lt;li&gt;运行&lt;/li&gt;
&lt;li&gt;监测：埋点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;监测环节为精益创业中产品的验证提供数据支持，通过数据来反馈产品是否符合用户预期&lt;/p&gt;
&lt;h3 id=&quot;敏捷的核心&quot;&gt;敏捷的核心&lt;/h3&gt;
&lt;p&gt;变化来自于哪里？&lt;/p&gt;
&lt;p&gt;从2001年的敏捷宣言核心观点来看“拥抱变化”，多数的变化可以认为是需求&lt;/p&gt;
&lt;p&gt;需求的变化有两种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;一种是需求没有变，是没有理解透（很多复杂的细分行业B端产品）&lt;/li&gt;
&lt;li&gt;另外一种是提出需求的人自己没有想清楚（很多创新型产品，互联网行业居多）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
&lt;p&gt;欢迎转载、使用、重新发布，但务必保留文章署名 郑子铭 （包含链接： &lt;a href=&quot;http://www.cnblogs.com/MingsonZheng/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/MingsonZheng/&lt;/a&gt; ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。&lt;/p&gt;
&lt;p&gt;如有任何疑问，请与我联系 (MingsonZheng@outlook.com) 。&lt;/p&gt;
</description>
<pubDate>Fri, 15 Jan 2021 15:32:00 +0000</pubDate>
<dc:creator>MingsonZheng</dc:creator>
<og:description>2.7.1 敏捷开发 敏捷介绍 敏捷的起源 敏捷软件开发宣言 敏捷开发十二原则 生命周期对比 敏捷开发的特点 敏捷的发展 敏捷的核心 敏捷的起源 2001年，17个老头子在一起一边滑雪，一边讨论工作，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MingsonZheng/p/14284703.html</dc:identifier>
</item>
<item>
<title>Mysql基本数据类型 - Sherlockmmc</title>
<link>http://www.cnblogs.com/Sherlockmmc/p/14284687.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Sherlockmmc/p/14284687.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1591156/202101/1591156-20210115232024427-709125156.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;strong&gt;Float&lt;span class=&quot;md-plain&quot;&gt;和&lt;span class=&quot;md-empty&quot;&gt;&lt;span class=&quot;md-plain md-expand&quot;&gt;Double&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;MySQL将四个字节用于单精度值，并将八个字节用于双精度值。Float、DOUBLE类型代表近似数值。对于FLOAT，SQL标准允许对FLOAT括号中的关键字后面的位以精度（但不允许指数的范围）进行可选的规范。由于浮点值是近似值而不是作为精确值存储的，因此在比较中尝试将它们视为精确值可能会导致问题。它们还受平台或 实现依赖性的约束。如果需要表示的精确度很高时，如货币数据，最好使用decimal。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;DECIMAL&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;DECIMAL以字符串的形式存储, 可能的最大取值范围与 DOUBLE 相同，但是有效的取值范围由 M 和 D 决定。DECIMAL(M,D)如果改变 M 而固定 D，则取值范围将随 M 的变大而变大。M的默认值为10，D的默认值是0.（精确的行为是特定于操作系统的，但是通常效果是将其截断为允许的位数。）&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;例如 decimal(5,2)，5是精度，2是小数位数。精度表示值存储的有效位数，小数位数表示小数点后可以存储的位数。所以可以表示为123.12&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;浮点数相对于定点数的优点是在长度一定的情况下，浮点数能够表示更大的范围；但缺点是会引起精度问题。并且两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;TIMESTAMP&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;&lt;span&gt;&lt;strong&gt;与&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;&lt;span&gt;&lt;strong&gt;DATETIME&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;TIMESTAMP 与 DATETIME 除了存储字节和支持的范围不同外，还有一个最大的区别是：DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；而 TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;BINARY&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;&lt;span&gt;&lt;strong&gt;和&lt;/strong&gt; &lt;span class=&quot;md-plain&quot;&gt;&lt;span&gt;&lt;strong&gt;VARBINARY&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;BINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;在将数据转换为二进制数据时，SQL Server会对生成的二进制数据进行填充或截断。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;当BINARY被存储的值，它们被右侧填充垫值到指定的长度。填充值为0x00（零字节）。值在0x00插入时用右填充，不会删除尾随字节以进行检索。所有字节在比较中都很重要，包括ORDER BY和DISTINCT操作。 0x00比较中，空间和空间有所不同，0x00先于空间进行 排序。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;示例：对于BINARY(3)列， 在插入时'a '变为 'a \0'。 插入时'a\0'变为'a\0\0'。两个插入的值均保持不变以进行检索。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对于VARBINARY，没有用于插入的填充，也没有剥离任何字节以进行检索。所有字节在比较中都很重要，包括ORDER BY和DISTINCT操作。 0x00比较中，空间和空间有所不同，0x00先于空间进行 排序。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;对于那些删除尾部填充字节或比较将其忽略的情况，如果一列具有要求唯一值的索引，则将仅尾部填充字节数不同的值插入该列会导致重复键错误。例如，如果表包含'a'，则尝试存储'a\0'会导致重复键错误。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span&gt;&lt;strong&gt;BLOB&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p&quot;&gt;&lt;span class=&quot;md-plain&quot;&gt;BLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。&lt;/span&gt;&lt;/p&gt;
&lt;p class=&quot;md-end-block md-p md-focus&quot;&gt; &lt;/p&gt;
</description>
<pubDate>Fri, 15 Jan 2021 15:24:00 +0000</pubDate>
<dc:creator>Sherlockmmc</dc:creator>
<og:description>Float和Double MySQL将四个字节用于单精度值，并将八个字节用于双精度值。Float、DOUBLE类型代表近似数值。对于FLOAT，SQL标准允许对FLOAT括号中的关键字后面的位以精度（</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Sherlockmmc/p/14284687.html</dc:identifier>
</item>
<item>
<title>Jenkins上实现Python + Jenkins + Allure Report 接口自动化测试持续集成，并生成allure-report测试报告 - 尘世风</title>
<link>http://www.cnblogs.com/feng0815/p/14284679.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feng0815/p/14284679.html</guid>
<description>&lt;ul&gt;&lt;li&gt;接口功能测试应用：&lt;a href=&quot;http://www.weather.com.cn/data/cityinfo/&quot; target=&quot;_blank&quot;&gt;http://www.weather.com.cn/data/cityinfo/&lt;/a&gt;&amp;lt;city_code&amp;gt;.html&lt;/li&gt;
&lt;li&gt;测试功能：获取对应城市的天气预报&lt;/li&gt;
&lt;li&gt;源码：Python&lt;/li&gt;
&lt;li&gt;功能包： HttpClient&lt;/li&gt;
&lt;li&gt;请求方法：Get&lt;/li&gt;
&lt;li&gt;自动化测试框架：pytest&lt;/li&gt;
&lt;li&gt;源码位置：&lt;a href=&quot;https://github.com/shifengboy/iInterface_python&quot; target=&quot;_blank&quot;&gt;https://github.com/shifengboy/iInterface_python&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;&lt;li&gt;HttpClient：网络http请求类&lt;/li&gt;
&lt;li&gt;Weather：测试用例类&lt;/li&gt;
&lt;li&gt;Readme.md: 说明&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1新建一个自由风格的项目&quot;&gt;1.新建一个自由风格的项目&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210115230744353-1919403184.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;2添加项目描述和运行节点&quot;&gt;2.添加项目描述和运行节点&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210115230908289-1319887934.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;3添加git源码&quot;&gt;3.添加git源码&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210115231007060-1781076447.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;4构建项目命令&quot;&gt;4.构建项目命令&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210115231534821-1162752425.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;构建命令&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;. ~/.bash_profile
# 进入到项目目录
cd iInterface_python
# 安装项目所需依赖
pip3 install -r requirements.txt
# 运行项目并生成allure报告
pytest -vs test/weather_test.py --alluredir=./allure-results --clean-alluredir
# 打开报告
allure generate ./allure-results -o ./allure-reports --clean 
# 删除已存在的报告包
rm -rf allure-reports.zip
# 生成新报告包，用于发送邮件
zip -r allure-reports.zip allure-reports
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;5添加allure报告路径&quot;&gt;5.添加allure报告路径&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210115231636795-1187741561.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;6添加邮件配置&quot;&gt;6.添加邮件配置&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210115231817776-1035269417.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;保存，构建&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210115231936325-1129645268.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;生成的allure报告&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1024536/202101/1024536-20210115232011149-1014034113.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 15 Jan 2021 15:20:00 +0000</pubDate>
<dc:creator>尘世风</dc:creator>
<og:description>#项目介绍 接口功能测试应用：http://www.weather.com.cn/data/cityinfo/&amp;amp;lt;city_code&amp;amp;gt;.html 测试功能：获取对应城市的天气</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feng0815/p/14284679.html</dc:identifier>
</item>
</channel>
</rss>