<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>基于 HTML5 WebGL 的民航客机飞行监控系统 - HT学习笔记</title>
<link>http://www.cnblogs.com/htdaydayup/p/11233646.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/htdaydayup/p/11233646.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;前些日子出差，在飞机上看到头顶的监控面板，除了播放电视剧和广告之外，还会时不时的切换到一个飞机航行的监控系统，不过整个监控系统让人感到有一点点的简陋，所以我就突发奇想制作了一个采用 HT for Web 的升级版监控系统，demo 的效果还行，发出来大家相互学习下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201907/1496396-20190724071728114-1062662960.gif&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.hightopo.com/demo/flight-monitor/&quot;&gt;demo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;实现过程&quot;&gt;实现过程&lt;/h2&gt;
&lt;h3 id=&quot;云中穿行效果&quot;&gt;云中穿行效果&lt;/h3&gt;
&lt;p&gt;为了达到飞机云中穿行的效果，最开始我遇到的问题是飞机飞行的层次感，也就通常所说的透视效果，这里我采用的是云通道和云背景以不同的速度流动，制造一种飞行的透视效果。&lt;/p&gt;
&lt;p&gt;云我采用的是贴图的方式呈现的，但是仅仅是贴图会遮挡天空和飞机，非常影响飞机飞行的观感，所以我开启了相应图元的 &lt;code&gt;transparent&lt;/code&gt; 和 &lt;code&gt;opacity&lt;/code&gt; ，云背景和云通道设置不同的透明度，不仅增加了层次感，还会让人产生云朵从眼前飘过的错觉。&lt;/p&gt;
&lt;p&gt;云通道采用的是 &lt;code&gt;ht.Polyline&lt;/code&gt; 类型，通道缩放拉大了 Y 轴的比例，使云通道有更大的纵向空间，设置 &lt;code&gt;reverse.flip&lt;/code&gt; 背拷贝使云通道内部也显示出贴图，仿佛让飞机置身于云海中穿梭；云背景采用 &lt;code&gt;ht.Node&lt;/code&gt; 类型，只设置一个面显示充当云背景。&lt;/p&gt;
&lt;p&gt;整体的云流动效果采用 &lt;code&gt;offset&lt;/code&gt; 偏移实现，改变相应图元或相应图元面的贴图偏移量来达到飞机云中穿行的效果， 代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var i = 1, 
    p = 0;
setInterval(() =&amp;gt; {
    i -= 0.1; p += 0.005;
    clouds.s('shape3d.uv.offset', [i, 0]);
    cloudBackground.s('all.uv.offset', [p, 0]);
}, 100);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;升降颠簸效果&quot;&gt;升降颠簸效果&lt;/h3&gt;
&lt;p&gt;虽然达到了飞机云中穿行的效果，但是如果飞机只是直直的飞行，那也会降低飞行的实感，相信坐过飞机的朋友肯定都遇到过因气流产生的颠簸，也经常感受到飞机飞行途中的爬升和下降，这其实是因为飞机的航线并不是一直固定在一个高度上，有时会爬升有时会下降，所以我就用 &lt;strong&gt;ht-animation.js&lt;/strong&gt; HT 动画扩展插件去实现飞机颠簸效果，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;dm.enableAnimation(20);
plane.setAnimation({
    back1: {
        from: 0,
        to: 160,
        easing: 'Cubic.easeInOut',
        duration: 8000,
        next: &quot;up1&quot;,
        onUpdate: function (value) {
            value = parseInt(value);
            var p3 = this.p3();
            this.p3(value, p3[1], p3[2]);
        }
    },
    //...省略相似
    start: [&quot;back1&quot;]
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;球扇形视角限制&quot;&gt;球扇形视角限制&lt;/h3&gt;
&lt;p&gt;飞行效果完善之后，这时我就遇到了一个比较棘手的问题，因为实际上虽然看着飞机是在云海中穿梭，但是仅仅是在通道中飞行，背景其实也只是平面贴图，所以当视角到达某种程度的时候就会有强烈的违和感和不真实感，就需要一个视角限制，使视角的调整刚刚好在一个范围内。&lt;/p&gt;
&lt;p&gt;视角限制的话一般是限制 g3d 的 &lt;code&gt;eye&lt;/code&gt; 和 &lt;code&gt;center&lt;/code&gt; ，不太了解的朋友可以去看 hightopo 官网中的 3d 手册，里面有详细的说明，这里我就不再赘述了；因为视角范围的关系，所以我决定固定 &lt;code&gt;center&lt;/code&gt; 的位置，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;g3d.addPropertyChangeListener(e =&amp;gt; {
    // 固定中心点
    if (e.property === 'center') {
        e.newValue[0] = center[0];
        e.newValue[1] = center[1];
        e.newValue[2] = center[2];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后再把 &lt;code&gt;eye&lt;/code&gt; 限制在某一个范围内就大功告成了，然而这里却并不是那么简单，最开始我把 &lt;code&gt;eye&lt;/code&gt; 限制在一个立方体的空间内，但交互效果很不理想，考虑到 g3d 默认交互中，鼠标拖拽平移视角变换时，实际上 &lt;code&gt;eye&lt;/code&gt; 是在一个以 &lt;code&gt;center&lt;/code&gt; 为球心的球面上运动的，所以我决定从这个球中挖出来一块作为 &lt;code&gt;eye&lt;/code&gt; 的限制空间，也就是球扇形，不太理解的朋友可以参考这个图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201907/1496396-20190724071800791-1365607036.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;球扇形视角限制，一共需要三个参数，分别是中心参考轴、中心轴和外边所成角度、所在球限制半径，其中中心参考轴可根据初始 &lt;code&gt;eye&lt;/code&gt; 和 &lt;code&gt;center&lt;/code&gt; 的连接延长线确定，所在球限制半径又分最大限制和最小限制，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function limitEye(g3d, eye, center, options) {
    var limitMaxL   = options.limitMaxL,
        limitMinL   = options.limitMinL,
        limitA      = options.limitA;

    g3d.addPropertyChangeListener(e =&amp;gt; {
        // 固定中心点
        if (e.property === 'center') {
            e.newValue[0] = center[0];
            e.newValue[1] = center[1];
            e.newValue[2] = center[2];
        }
        // 限制视角
        if (e.property === 'eye') {
            var newEyeV = new ht.Math.Vector3(e.newValue),
                centerV = new ht.Math.Vector3(center),
                refEyeV = new ht.Math.Vector3(eye),
                refVector = refEyeV.clone().sub(centerV),
                newVector = newEyeV.clone().sub(centerV);

            if (centerV.distanceTo(newEyeV) &amp;gt; limitMaxL) {
                newVector.setLength(limitMaxL);
                e.newValue[0] = newVector.x;
                e.newValue[1] = newVector.y;
                e.newValue[2] = newVector.z;
            }
            if (centerV.distanceTo(newEyeV) &amp;lt; limitMinL) {
                newVector.setLength(limitMinL);
                e.newValue[0] = newVector.x;
                e.newValue[1] = newVector.y;
                e.newValue[2] = newVector.z;
            }
            if (newVector.angleTo(refVector) &amp;gt; limitA) {
                var oldLength = newVector.length(),
                    oldAngle  = newVector.angleTo(refVector),
                    refLength = oldLength * Math.cos(oldAngle),
                    vertVector,
                    realVector,
                    realEye;

                refVector.setLength(refLength);

                newEyeV = newVector.clone().add(centerV);
                refEyeV = refVector.clone().add(centerV);
                vertVector = newEyeV.clone().sub(refEyeV);
                vertLength = refLength * Math.tan(limitA);

                vertVector.setLength(vertLength);

                realVector = vertVector.clone().add(refEyeV).sub(centerV);

                realVector.setLength(oldLength);

                realEye = realVector.clone().add(centerV);

                // 防止移动角度大于 180 度，视角反转
                if (oldAngle &amp;gt; Math.PI / 2) {
                    realEye.negate();
                }

                e.newValue[0] = realEye.x;
                e.newValue[1] = realEye.y;
                e.newValue[2] = realEye.z;
            }  
        }
    })
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201907/1496396-20190724071833361-1224844908.gif&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;飞机监控系统&quot;&gt;飞机监控系统&lt;/h3&gt;
&lt;p&gt;当然作为监控系统，自然要有监控了，增加右下角的小地图，并提供三种模式，分别是聚焦飞机，聚焦飞行轨迹和聚焦地图，并根据飞机的飞行方向控制飞行轨迹的流动效果，其中聚焦飞机会跟随飞机移动进行 &lt;code&gt;fitData&lt;/code&gt;，使飞机一直处于小地图的中心，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var fitFlowP = function (e) {
    if (e.property === 'position' &amp;amp;&amp;amp; e.data === plane) {
        mapGV.fitData(plane, false);
    }
};
buttonP.s({
    'interactive': true,
    'onClick': function (event, data, view, point, width, height) {
        map.a('fitDataTag', 'plane2D');
        mapGV.fitData(plane, false);
        mapDM.md(fitFlowP);
    }
});
buttonL.s({
    'interactive': true,
    'onClick': function (event, data, view, point, width, height) {
        mapDM.umd(fitFlowP);
        map.a('fitDataTag', 'flyLine');
        mapGV.fitData(flyLine, false);
    }
});
// ...省略&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201907/1496396-20190724071927107-455378469.gif&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;增加鼠标移到飞机相应位置进行名称的提示、双击后显示飞机相应位置的信息面板并将视角聚焦到面板上、点击飞机任意地方切换回飞机飞行模式等效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201907/1496396-20190724072013493-1014627117.gif&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;左侧增加监控面板替代上面提到的双击相应位置这步操作直接聚焦到相应位置的信息面板上，这里按钮开启了交互并添加了相应的交互逻辑，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;button_JC.s({
    'interactive': true,
    'onClick': function (event, data, view, point, width, height) {
        event.preventDefault();
        let g3d = G.g3d,
            g3dDM = G.g3d.dm();
        g3d.fireInteractorEvent({
            kind: 'doubleClickData',
            data: g3dDM.getDataByTag(data.getTag())
        })
    }
});
//...省略&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201907/1496396-20190724072052557-1139156439.gif&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;天空渲染效果&quot;&gt;天空渲染效果&lt;/h3&gt;
&lt;p&gt;既然是监控系统肯定是 24 小时无差别的监控，这就涉及到一个问题，我总不可能半夜的时候飞机也从瓦蓝瓦蓝的天空上飞过，这就很欠缺真实性了，所以要有一个天空从亮到暗再从暗到亮的过程，这个过程我暂定到 06:00-06:30 和19:00-19:30 这两个时间段。&lt;/p&gt;
&lt;p&gt;天空采用的是 &lt;code&gt;shape3d : 'sphere'&lt;/code&gt; 球形，包裹整个场景，然后使用 &lt;code&gt;reverse.flip&lt;/code&gt; 背拷贝 和 &lt;code&gt;blend&lt;/code&gt; 染色，之后天空就可以渲染成我想要的颜色，如果按照时间改变天空明暗只要改变染色值就可以了。&lt;/p&gt;
&lt;p&gt;但是由于白天和晚上光照情况的不同，云反射光的强度也不同，就导致了白天和晚上云的差异，所以也要调整云道和云背景的贴图的 &lt;code&gt;opacity&lt;/code&gt; 透明度，晚间更为透明度，代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;if ((hour &amp;gt; 6 &amp;amp;&amp;amp; hour &amp;lt; 19) || (hour == 6 &amp;amp;&amp;amp; minutes &amp;gt;= 30)) {
    timePane &amp;amp;&amp;amp; timePane.a({
        'morning.visible': false,
        'day.visible': true,
        'dusk.visible': false,
        'night.visible': false,
        'day.opacity': 1
    })
    skyBox.s({
        &quot;shape3d.blend&quot;: 'rgb(127, 200, 240)',
    })
    cloudBackground.s({
        &quot;back.opacity&quot;: 0.7,
    })
    clouds.s({
        &quot;shape3d.opacity&quot;: 0.7,
    })
} else if ((hour &amp;lt; 6 || hour &amp;gt; 19) || (hour == 19 &amp;amp;&amp;amp; minutes &amp;gt;= 30)) {
//...省略
} else if (hour == 6 &amp;amp;&amp;amp; minutes &amp;lt; 15 ) {
//...省略
} else if (hour == 6 &amp;amp;&amp;amp; minutes &amp;gt;= 15 &amp;amp;&amp;amp; minutes &amp;lt; 30) {
//...省略
} else if (hour == 19 &amp;amp;&amp;amp; minutes &amp;lt; 15) {
//...省略
} else if (hour == 19 &amp;amp;&amp;amp; minutes &amp;gt;= 15 &amp;amp;&amp;amp; minutes &amp;lt; 30) {
//...省略
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201907/1496396-20190724072149277-857090484.gif&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里我还增加了对右上角时间面板时间状态图标的支持，并增加了图标切换时的渐隐渐显效果，同时给时间面板状态图标位置增加了点击切换到下一时间状态的功能。&lt;/p&gt;
&lt;p&gt;为了演示效果我增加了时间倍速按钮，下图是 500 倍时间流速下的变化情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1496396/201907/1496396-20190724072244974-407420923.gif&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;通过这个 demo ，我发现生活中有很多没有被人所注意到的细节都存在数据可视化的可能，在这个大数据的时代更多的可能性值得被人发掘出来，不要错个身边每一个值得数据可视化的细节，这样不仅可以更好的挖掘 HT for Web 的潜力，也可以加强自身身为一个程序员的综合素质。&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jul 2019 00:33:00 +0000</pubDate>
<dc:creator>HT学习笔记</dc:creator>
<og:description>前言 前些日子出差，在飞机上看到头顶的监控面板，除了播放电视剧和广告之外，还会时不时的切换到一个飞机航行的监控系统，不过整个监控系统让人感到有一点点的简陋，所以我就突发奇想制作了一个采用 HT for</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/htdaydayup/p/11233646.html</dc:identifier>
</item>
<item>
<title>.net持续集成sonarqube篇之sonarqube基本操作(一) - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11235627.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11235627.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/11204826.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Sonarqube Web管理界面虽然设计的简洁大方,也非常直观,但是由于功能繁多,这对快速入手以及快速定位到想要的功能都是一个挑战,在以后的几个小节里我们简要介绍.&lt;/p&gt;
&lt;h2 id=&quot;owerview概览&quot;&gt;OwerView(概览)&lt;/h2&gt;
&lt;p&gt;概览界面主要展示了项目lint的统计信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190724081710099-1146826919.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到这些栏目栏目大都是统计数字,并且带有链接,点击链接则可以看到详细信息.其实中有些栏目的统计数字旁边带有带圈的英文字母,这些字母中,从A到E质量依次下降,颜色逐渐由绿色变为红色.项目管理者可以根据这些评级和颜色大致了解某一主题的健康状况.&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;其中单元测试覆盖率为0%,这是因为单元测试覆盖率报告需要额外集成,我们会在后面章节讲述如何集成单元测试覆盖率报告.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190724081659798-2017509627.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到栏目标题后面有一个类似冒泡的图标,点击这个图标可以进入图表展示界面,如下图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190724081653735-863090752.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个图表初看可能会感觉一头雾水,不知道是干什么的,实际上非常容易看.圆圈大小代表某一个类bug的多少,我们把鼠标移动到图上最大的圆圈上,鼠标指针变成手状,这时候出现一个如下图示悬浮面板&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190724081646466-1673428891.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过这个面板我们可以看出出现bug的类名,bug数量,评级等信息.而颜色则代表bug的严重程度.通过这个图表面板,管理员很容易看到bug的分布情况和,从而做出决策.&lt;/p&gt;
&lt;h2 id=&quot;code标签&quot;&gt;Code标签&lt;/h2&gt;
&lt;p&gt;界面上与Overview导航标签平级的标签还有Issues,Measure,Code,Activity等.其中Issues为解决bug的主面板,我们将用单独一节来讲,这里介绍一下&lt;code&gt;code&lt;/code&gt;标签下的内容.&lt;/p&gt;
&lt;p&gt;我们点击code标签,内容如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190724081639551-1336969422.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到,这里是把源代码按项目名来划分的(这里的每一个项目都和一个csproj项目对应),这样我们很容易定位到自己的代码.并且我们还可以通过搜索栏输入类名来快速定位到某一个类.&lt;/p&gt;
&lt;p&gt;我们点击类名进入到某一个类,便可以看到它的代码,如下图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.cnblogs.com/tylerzhou/p/images/QQ截图20180821151548.png&quot; alt=&quot;avatar&quot;/&gt;)&lt;/p&gt;
&lt;p&gt;通过右上方的信息栏我们便可以很清楚地看到这个文件的代码行数,问题数和覆盖率.&lt;/p&gt;
&lt;p&gt;我们往下翻页可以看到如下图示内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190724081633852-502624777.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中红色竖杠代表单元测试没有覆盖,由于我们没有集成单元测试,所以这里可以暂时不以理会.&lt;br/&gt;红杠右边的带有红圈的标识则为需要处理的问题.我们点击红圈则会出现一个悬浮窗口显示问题的描述和修改建议等.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/811801/201907/811801-20190724081627458-1427811556.png&quot; alt=&quot;avatar&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jul 2019 00:19:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' Sonarqube Web管理界面虽然设计的简洁大方,也非常直观,但是由于功能繁多,这对快速入手以及快速定位到想要的功能都是一个挑战,在以后的几个小节里我们简要介绍. OwerView(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11235627.html</dc:identifier>
</item>
<item>
<title>一文带你实现RPC框架 - 代码无止境</title>
<link>http://www.cnblogs.com/endless-code/p/11235624.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/endless-code/p/11235624.html</guid>
<description>&lt;blockquote readability=&quot;3.943661971831&quot;&gt;
&lt;p&gt;想要获取更多文章可以访问我的博客 - &lt;a href=&quot;https://itweknow.cn&quot;&gt;代码无止境&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在大部分的互联网公司都会采用微服务架构，但具体实现微服务架构的方式有所不同，主流上分为两种，一种是基于Http协议的远程调用，另外一种是基于RPC方式的调用。两种方式都有自己的代表框架，前者是著名的Spring Cloud，后者则是有阿里巴巴开源的Dubbo，二者都被广泛的采用。今天这篇文章，我们就一起来了解一下RPC，并且和大家一起动手实现一个简单的RPC框架的Demo。&lt;/p&gt;
&lt;h3 id=&quot;什么是rpc&quot;&gt;什么是RPC&lt;/h3&gt;
&lt;p&gt;RPC是一种远程调用过程，是一种通过网络远程调用其他服务的协议。通俗的说就是，A通过打电话的方式让B帮忙办一件事，B办完事后将结果告知A。 我们下面通过一张图来大概了解一下在一个完整的RPC框架中存在的角色以及整个远程调用的过程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/23/16c1f6844728263d?w=1060&amp;amp;h=824&amp;amp;f=png&amp;amp;s=15546&quot; alt=&quot;Dubbo框架&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的图可以看出来，在RPC框架中主要有以下4个角色：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;registry - 注册中心，当服务提供者启动时会向注册中心注册，然后注册中心会告知所有的消费者有新的服务提供者。&lt;/li&gt;
&lt;li&gt;provider - 服务提供者，远程调用过程中的被消费方。&lt;/li&gt;
&lt;li&gt;consumer - 服务消费者，远程调用过程中的消费方。&lt;/li&gt;
&lt;li&gt;monitor - 监视器，它主要负责统计服务的消费和调用情况。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;启动服务提供者后，服务提供者会以异步的方式向注册中心注册。然后启动服务消费者，它会订阅注册中心中服务提供者列表，当有服务提供者的信息发生改变时，注册中心会通知所有的消费者。当消费者发起远程调用时，会通过动态代理将需要请求的参数以及方法签名等信息通过Netty发送给服务提供者，服务提供者收到调用的信息后调用对应的方法并将产生的结果返回给消费者，这样就完成了一个完整的远程调用。当然了这个过程中可能还会将调用信息异步发送给monitor用于监控和统计。&lt;/p&gt;
&lt;p&gt;阅读过上面的内容后，你应该对RPC框架有了一个大概的认识。为了更好更深入的了解RPC框架的原理，下面我们就一起来动手实现一个简单的RPC框架吧。&lt;/p&gt;
&lt;h3 id=&quot;框架核心部分&quot;&gt;框架核心部分&lt;/h3&gt;
&lt;p&gt;首先我们要实现的是整个RPC框架的核心部分，这部分的主要包含以下内容：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;RPC服务的注解的实现。&lt;/li&gt;
&lt;li&gt;服务提供者初始化、注册、以及响应远程调用的实现。&lt;/li&gt;
&lt;li&gt;服务消费者订阅注册中心、监听服务提供者的变化的实现。&lt;/li&gt;
&lt;li&gt;动态代理的实现。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;整个核心部分将以一个&lt;code&gt;Spring Boot Starter&lt;/code&gt;的形式实现，这样我们可以很方便的在Spring Boot项目中使用它。&lt;/p&gt;
&lt;h4 id=&quot;注解&quot;&gt;注解&lt;/h4&gt;
&lt;p&gt;我们需要使用一个注解来标识服务提供者所提供服务的实现类，方便在初始化的时候将其交由Spring管理，也只有这样我们才可以在远程调用发生时可以找到它们。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Component
public @interface RpcService {

    Class&amp;lt;?&amp;gt; value();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;value&lt;/code&gt;属性用来标记这个服务的实现类对应的接口，RPC框架中服务提供者和消费者之间会共同引用一个服务接口的包，当我们需要远程调用的时候实际上只需要调用接口中定义的方法即可。&lt;br/&gt;除了一个标识服务实现类的注解之外，我们还需要一个标识服务消费者注入服务实现的注解&lt;code&gt;@RpcConsumer&lt;/code&gt;，被其修饰的属性在初始化的时候都会被我们设置上动态代理，这一点在后面会详细讲到，我们先来看下它的具体实现吧。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Component
public @interface RpcConsumer {

    /**
     * 服务名称
     * @return
     */
    String providerName();

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;服务提供者&quot;&gt;服务提供者&lt;/h4&gt;
&lt;p&gt;服务提供者启动的时候，我们RPC框架需要做以下几件事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;扫描服务提供者中所有提供服务的类（被&lt;code&gt;@RpcService&lt;/code&gt;修饰的类），并将其交由BeanFactory管理。&lt;/li&gt;
&lt;li&gt;启动Netty服务端，用来收到消费者的调用消息，并且返回调用结果。&lt;/li&gt;
&lt;li&gt;向注册中心注册，本例中使用的注册中心是Zookeeper。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这部分我们定义了一个&lt;code&gt;ProviderAutoConfiguration&lt;/code&gt;类来实现这几个步骤，&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@PostConstruct
public void  init() {
    logger.info(&quot;rpc server start scanning provider service...&quot;);
    Map&amp;lt;String, Object&amp;gt; beanMap = this.applicationContext.getBeansWithAnnotation(RpcService.class);
    if (null != beanMap &amp;amp;&amp;amp; !beanMap.isEmpty()) {
        beanMap.entrySet().forEach(one -&amp;gt; {
            initProviderBean(one.getKey(), one.getValue());
        });
    }
    logger.info(&quot;rpc server scan over...&quot;);
    // 如果有服务的话才启动netty server
    if (!beanMap.isEmpty()) {
        startNetty(rpcProperties.getPort());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看上面的代码，首先我们获取到了所有被&lt;code&gt;@RpcService&lt;/code&gt;注解修饰的实体，并且调用了&lt;code&gt;initProviderBean&lt;/code&gt;方法逐一对其处理，然后我们启动了Netty。那么我们需要在&lt;code&gt;initProviderBean&lt;/code&gt;方法中做些什么呢？其实很简单，就是逐一将其交由&lt;code&gt;BeanFactory&lt;/code&gt;管理。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private void initProviderBean(String beanName, Object bean) {
    RpcService rpcService = this.applicationContext
                .findAnnotationOnBean(beanName, RpcService.class);
    BeanFactory.addBean(rpcService.value(), bean);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将服务实现类交由Spring管理之后，我们还需要启动Netty用来接收远程调用信息，启动Netty的代码在这里我就不全部粘出来了，大家可以在&lt;a href=&quot;https://github.com/ganchaoyang/spring-tutorial/tree/master/sb-rpc&quot;&gt;源码&lt;/a&gt;中查看。在Netty启动成功之后，其实我们还执行了下面的代码，用来向ZK注册。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;new RegistryServer(rpcProperties.getRegisterAddress(),
                    rpcProperties.getTimeout(), rpcProperties.getServerName(),
                    rpcProperties.getHost(), port)
                    .register();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;整个注册的过程也非常容易理解，首先是创建了一个ZK连接，然后是判断是否有&lt;code&gt;/rpc&lt;/code&gt;的根节点，如果没有的话就创建一个，最后就是在根节点下创建一个&lt;code&gt;EPHEMERAL_SEQUENTIAL&lt;/code&gt;类型的节点，这种类型的节点在ZK重启之后会自动清除，这样可以保证注册中心重启后会自动清除服务提供者的信息。而在节点中会存储服务提供者的名称，IP地址以及端口号的信息，这样RPC框架就可以根据这些信息顺利的定位到服务提供者。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void register() throws ZkConnectException {
    try {
        // 获取zk连接
        ZooKeeper zooKeeper = new ZooKeeper(addr, timeout, event -&amp;gt; {
            logger.info(&quot;registry zk connect success...&quot;);
        });
        if (zooKeeper.exists(Constants.ZK_ROOT_DIR, false) == null) {
            zooKeeper.create(Constants.ZK_ROOT_DIR, Constants.ZK_ROOT_DIR.getBytes(),ZooDefs.Ids.OPEN_ACL_UNSAFE,
                    CreateMode.PERSISTENT);
        }
        zooKeeper.create(Constants.ZK_ROOT_DIR + &quot;/&quot; + serverName,
                (serverName + &quot;,&quot;+ host + &quot;:&quot; + port).getBytes(),
                ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
        logger.info(&quot;provider register success {}&quot;, serverName);
    } catch (Exception e) {
        throw new ZkConnectException(&quot;register to zk exception,&quot; + e.getMessage(), e.getCaus());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;就这样我们RPC框架与服务提供者相关的内容就完成了，接下来要完成的是服务消费者部分。&lt;/p&gt;
&lt;h4 id=&quot;服务消费者&quot;&gt;服务消费者&lt;/h4&gt;
&lt;p&gt;对于服务消费者，我们框架需要对它的处理就是，为所有的RPC服务（被&lt;code&gt;@RpcConsumer&lt;/code&gt;修饰的属性）设置上动态代理。具体的设置代码如下所示（PS:这段代码写在&lt;code&gt;ConsumerAutoConfiguration&lt;/code&gt;类中哦）：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Bean
public BeanPostProcessor beanPostProcessor() {
    return new BeanPostProcessor() {
        @Override
        public Object postProcessBeforeInitialization(Object bean, String beanName)
                throws BeansException {
            Class&amp;lt;?&amp;gt; objClz = bean.getClass();
            for (Field field : objClz.getDeclaredFields()) {
                RpcConsumer rpcConsumer = field.getAnnotation(RpcConsumer.class);
                if (null != rpcConsumer) {
                    Class&amp;lt;?&amp;gt; type = field.getType();
                    field.setAccessible(true);
                    try {
                        field.set(bean, rpcProxy.create(type, rpcConsumer.providerName()));
                    } catch (IllegalAccessException e) {
                        e.printStackTrace();
                    } finally {
                        field.setAccessible(false);
                    }
                }
            }
            return bean;
        }
    };
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;BeanPostProcessor&lt;/code&gt;也称为Bean后置处理器，它是Spring中定义的接口，在Spring容器的创建过程中（具体为Bean初始化前后）会回调BeanPostProcessor中定义的两个方法。上面实现的&lt;code&gt;postProcessBeforeInitialization&lt;/code&gt;是在Bean初始化之前调用的，还有一个&lt;code&gt;postProcessAfterInitialization&lt;/code&gt;方法是在Bean初始化之后调用的。&lt;br/&gt;如上面代码所示，我们会在每一个带有&lt;code&gt;@RpcConsumer&lt;/code&gt;的实例初始化之前利用反射机制为其设置一个&lt;code&gt;RpcProxy&lt;/code&gt;的代理，可以看到我们在创建这个动态代理的时候还需要服务提供者的名称，这是因为在动态代理的实现里面需要使用服务提供者的名称来查询服务提供者的地址信息。那么这个动态代理的实现又是怎样的呢？这就是我们下一步需要做的事情。&lt;/p&gt;
&lt;h4 id=&quot;动态代理&quot;&gt;动态代理&lt;/h4&gt;
&lt;p&gt;在这个RPC框架里面动态代理主要实现的内容就是，当服务消费者调用服务提供者提供的接口时，将调用信息通过Netty发送给对应的服务调用者，然后由服务提供者完成相关的处理并且将处理结果返回给服务消费者。下面我们就一起来看一下&lt;code&gt;RpcProxy&lt;/code&gt;的是如何实现这部分功能的。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Component
public class RpcProxy {

    @Autowired
    private ServiceDiscovery serviceDiscovery;

    public &amp;lt;T&amp;gt; T create(Class&amp;lt;?&amp;gt; interfaceClass, String providerName) {
        return (T) Proxy.newProxyInstance(interfaceClass.getClassLoader(), new Class&amp;lt;?&amp;gt;[]{interfaceClass},
                (proxy, method, args) -&amp;gt; {
            // 通过netty向Rpc服务发送请求。
            // 构建一个请求。
            RpcRequest request = new RpcRequest();
            request.setRequestId(UUID.randomUUID().toString())
                    .setClassName(method.getDeclaringClass().getName())
                    .setMethodName(method.getName())
                    .setParamTypes(method.getParameterTypes())
                    .setParams(args);
            // 获取一个服务提供者。
            ProviderInfo providerInfo = serviceDiscovery.discover(providerName);
            // 解析服务提供者的地址信息，数组第一个元素为ip地址，第二个元素为端口号。
           String[] addrInfo = providerInfo.getAddr().split(&quot;:&quot;);
            String host = addrInfo[0];
            int port = Integer.parseInt(addrInfo[1]);
            RpcClient rpcClient = new RpcClient(host, port);
            // 使用Netty向服务提供者发送调用消息，并接收请求结果。
            RpcResponse response = rpcClient.send(request);
            if (response.isError()) {
                throw response.getError();
            } else {
                return response.getResult();
            }
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实在代理里面首先我们会构造请求信息实体，然后会根据服务提供者的名称获取一个服务提供者的地址，最后再将请求信息发送给服务提供者并接收调用结果。获取服务提供者的方法会在后面消费者和提供者的通用配置里面讲解。我们在这里重点来看一下发送调用信息并接收调用结果的实现。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class RpcClient extends SimpleChannelInboundHandler&amp;lt;RpcResponse&amp;gt; {
    
    ... 此处省略对象属性信息，可查看源码。

    public RpcResponse send(RpcRequest request){
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        try {
            ... 此处省略Netty相关配置，可查看源码。
            // 连接服务器
            ChannelFuture channelFuture = bootstrap.connect(host, port).sync();
            channelFuture.channel().writeAndFlush(request).sync();
            future = new CompletableFuture&amp;lt;&amp;gt;();
            future.get();
            if (response != null) {
                // 关闭netty连接。
                channelFuture.channel().closeFuture().sync();
            }
            return response;
        } catch (Exception e) {
            logger.error(&quot;client send msg error,&quot;, e);
            return null;
        } finally {
            workerGroup.shutdownGracefully();
        }
    }

    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext,
                                RpcResponse rpcResponse) throws Exception {
        logger.info(&quot;client get request result,{}&quot;, rpcResponse);
        this.response = rpcResponse;
        future.complete(&quot;&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的代码可以看出向服务提供者发送消息是异步的，我们通过&lt;code&gt;CompletableFuture&lt;/code&gt;的&lt;code&gt;get()&lt;/code&gt;方法阻塞当前线程，直到接收到调用结果（PS:我们在&lt;code&gt;channelRead0&lt;/code&gt;方法中收到返回结果后会将其设置成完成状态）。看到这里，你可能会问服务提供者收到调用请求信息后如何处理的呢？具体的处理逻辑我们写在了&lt;code&gt;ServerHandler&lt;/code&gt;这个类中，可以看出在&lt;code&gt;channelRead0&lt;/code&gt;方法收到一条调用信息之后，调用&lt;code&gt;handle&lt;/code&gt;方法来处理具体的调用过程，在&lt;code&gt;handle&lt;/code&gt;方法中会使用反射机制找到所调用方法的具体实现，然后执行调用过程并获取结果，最后再使用Netty将结果返回给消费者服务。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ServerHandler extends SimpleChannelInboundHandler&amp;lt;RpcRequest&amp;gt; {

    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext,
                                RpcRequest request) throws Exception {
        logger.info(&quot;provider accept request,{}&quot;, request);
        // 返回的对象。
        RpcResponse rpcResponse = new RpcResponse();
        // 将请求id原路带回
        rpcResponse.setRequestId(request.getRequestId());
        try {
            Object result = handle(request);
            rpcResponse.setResult(result);
        } catch (Exception e) {
            rpcResponse.setError(e);
        }
        channelHandlerContext.writeAndFlush(rpcResponse).addListener(ChannelFutureListener.CLOSE);
    }

    private Object handle(RpcRequest request) throws Exception {
        String className = request.getClassName();
        Class&amp;lt;?&amp;gt; objClz = Class.forName(className);
        Object o = BeanFactory.getBean(objClz);
        // 获取调用的方法名称。
        String methodName = request.getMethodName();
        // 参数类型
        Class&amp;lt;?&amp;gt;[] paramsTypes = request.getParamTypes();
        // 具体参数。
        Object[] params = request.getParams();
        // 调用实现类的指定的方法并返回结果。
        Method method = objClz.getMethod(methodName, paramsTypes);
        Object res = method.invoke(o, params);
        return res;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;消费者和提供者的通用配置&quot;&gt;消费者和提供者的通用配置&lt;/h4&gt;
&lt;p&gt;除了&lt;code&gt;ProviderAutoConfiguration&lt;/code&gt;和&lt;code&gt;ConsumerAutoConfiguration&lt;/code&gt;两个配置类，我们还定义了一个&lt;code&gt;RpcAutoConfiguration&lt;/code&gt;类来配置一些其他的东西，如下所示。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class RpcAutoConfiguration {
    ...

    @Bean
    @ConditionalOnMissingBean
    public ServiceDiscovery serviceDiscovery() {
        ServiceDiscovery serviceDiscovery =
                null;
        try {
            serviceDiscovery = new ServiceDiscovery(rpcProperties.getRegisterAddress());
        } catch (ZkConnectException e) {
            logger.error(&quot;zk connect failed:&quot;, e);
        }
        return serviceDiscovery;
    }

    @Bean
    @ConditionalOnMissingBean
    public RpcProxy rpcProxy() {
        RpcProxy rpcProxy = new RpcProxy();
        rpcProxy.setServiceDiscovery(serviceDiscovery());
        return rpcProxy;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个配置类里面，主要初始化了一个&lt;code&gt;ServiceDiscovery&lt;/code&gt;的对象以及一个&lt;code&gt;RpcProxy&lt;/code&gt;的对象。其中&lt;code&gt;RpcProxy&lt;/code&gt;是动态代理，在上面我们已经详细了解过了。那么这里就来着重了解一下&lt;code&gt;ServiceDiscovery&lt;/code&gt;是干啥的吧。&lt;br/&gt;大家还记得我们在文章开始的时候贴出来的那张图片吗？在服务消费者初始化的时候会去订阅服务提供者内容的变化，&lt;code&gt;ServiceDiscovery&lt;/code&gt;的主要功能就是这个，其主要代码如下所示（如果你需要完整的代码，可以查看本文&lt;a href=&quot;https://github.com/ganchaoyang/spring-tutorial/tree/master/sb-rpc&quot;&gt;源码&lt;/a&gt;）。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class ServiceDiscovery {

    // 存储服务提供者的信息。
    private volatile List&amp;lt;ProviderInfo&amp;gt; dataList = new ArrayList&amp;lt;&amp;gt;();

    public ServiceDiscovery(String registoryAddress) throws ZkConnectException {
        try {
            // 获取zk连接。
            ZooKeeper zooKeeper = new ZooKeeper(registoryAddress, 2000, new Watcher() {
                @Override
                public void process(WatchedEvent event) {
                    logger.info(&quot;consumer connect zk success!&quot;);
                }
            });
            watchNode(zooKeeper);
        } catch (Exception e) {
            throw new ZkConnectException(&quot;connect to zk exception,&quot; + e.getMessage(), e.getCause());
        }
    }

    /**
     * 监听服务提供者的变化
     */
    public void watchNode(final ZooKeeper zk) {
        ...
    }

    /**
     * 获取一个服务提供者
     */
    public ProviderInfo discover(String providerName) {
        ....
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个类的构造方法里面，我们和ZK注册中心建立了一个连接，并且在&lt;code&gt;watchNode&lt;/code&gt;方法中监听服务提供者节点的变化，当有服务提供者信息有变化时会去修改&lt;code&gt;dataList&lt;/code&gt;里的内容，这样可以保证在服务本地维持一份可用的服务提供者的信息。而在远程调用发生的时候我们会通过&lt;code&gt;discover&lt;/code&gt;方法（PS：前面有见到过哦）去&lt;code&gt;dataList&lt;/code&gt;里面寻找一个可用的服务提供者来提供服务。&lt;/p&gt;
&lt;h4 id=&quot;starter的配置&quot;&gt;Starter的配置&lt;/h4&gt;
&lt;p&gt;我们还需要在&lt;code&gt;resources&lt;/code&gt;目录下新建一个&lt;code&gt;META-INF&lt;/code&gt;目录，然后在该目录下新建一个&lt;code&gt;spring.factories&lt;/code&gt;文件，里面的内容如下面代码所示。它主要是用来指定在Spring Boot项目启动的时候需要加载的其他配置。如果你有不明白的地方可以查询一下Spring Boot自定义Stater的相关内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
cn.itweknow.sbrpccorestarter.config.RpcAutoConfiguration,\
cn.itweknow.sbrpccorestarter.config.ProviderAutoConfiguration,\
cn.itweknow.sbrpccorestarter.config.ConsumerAutoConfiguration&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这一步我们框架的核心部分就完成了，它将会以一个&lt;code&gt;Spring Boot Stater&lt;/code&gt;的形式提供给服务提供者和服务消费者使用，接下来我们就将分别定义一个服务提供者和一个消费者来测试我们自己实现的RPC框架。&lt;/p&gt;
&lt;h3 id=&quot;创建服务提供者&quot;&gt;创建服务提供者&lt;/h3&gt;
&lt;p&gt;在创建服务提供者之前，我们需要新建一个与服务消费者之间共享的服务接口。因为前面提到过，在服务消费者眼里的远程调用实际上就是调用本地的接口方法而已。在这个项目里我们就创建了一个&lt;code&gt;HelloRpcService.java&lt;/code&gt;的接口，如下所示：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface HelloRpcService {
    String sayHello();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在接口定义完成之后，我们就来创建我们的服务提供者，并且实现上面定义的&lt;code&gt;HelloRpcService&lt;/code&gt;接口。在服务提供者服务里还需要依赖RPC框架的核心Starter以及服务接口包，我们需要在&lt;code&gt;pom.xml&lt;/code&gt;中添加下面的依赖。&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;cn.itweknow&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sb-rpc-core-starter&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;

&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;cn.itweknow&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;sb-rpc-api&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.0.1-SNAPSHOT&amp;lt;/version&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;添加完依赖后，我们就来看下&lt;code&gt;HelloRpcService&lt;/code&gt;的具体实现吧：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RpcService(HelloRpcService.class)
public class HelloRpcServiceImpl implements HelloRpcService {
    
    @Override
    public String sayHello() {
        return &quot;Hello RPC!&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实现很简单，主要是要需要在实现类上加上&lt;code&gt;@RpcService&lt;/code&gt;注解，这样在项目启动的时候RPC框架才会扫描到它，并将其交给&lt;code&gt;BeanFactory&lt;/code&gt;管理。接下来还需要配置的是一些RPC框架需要的配置项，包括服务名称，ZK的地址以及Netty启动的端口等信息。这些信息在框架是通过&lt;code&gt;RpcProperties&lt;/code&gt;这个配置类来读取的，有兴趣的同学可以在&lt;a href=&quot;https://github.com/ganchaoyang/spring-tutorial/tree/master/sb-rpc&quot;&gt;源码&lt;/a&gt;中找到它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;spring.rpc.host=localhost
# netty服务的端口号
spring.rpc.port=21810
# zk地址
spring.rpc.register-address=localhost:2181
spring.rpc.server-name=provider
# 连接zk的超时时间
spring.rpc.timeout=2000&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;创建服务消费者&quot;&gt;创建服务消费者&lt;/h3&gt;
&lt;p&gt;服务消费者同样也需要RPC核心框架的Starter以及服务接口的依赖，和RPC框架的一些基础配置项，和服务提供者类似，这里就不粘出来了。这里需要说明的一点是，为了方便测试，服务消费者是一个Web服务，所以它还添加了&lt;code&gt;spring-boot-starter-web&lt;/code&gt;的依赖。下面我们就一起来看下服务消费者是如何调用远程服务的吧。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@RestController
@RequestMapping(&quot;/hello-rpc&quot;)
public class HelloRpcController {


    @RpcConsumer(providerName = &quot;provider&quot;)
    private HelloRpcService helloRpcService;

    @GetMapping(&quot;/hello&quot;)
    public String hello() {
        return helloRpcService.sayHello();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在消费者服务中写了一个hello的接口，在接口里面调用了&lt;code&gt;HelloRpcService&lt;/code&gt;接口里的&lt;code&gt;sayHello()&lt;/code&gt;方法，看过前面内容的同学应该知道，被&lt;code&gt;@RpcConsumer&lt;/code&gt;修饰的&lt;code&gt;helloRpcService&lt;/code&gt;属性在初始化的时候会为其设置一个动态代理，当我们调用这个接口里面的方法时，会通过Netty向服务提供者发送调用信息，然后由服务提供者调用相应方法并返回结果。&lt;br/&gt;到这一步，我们可以说完成了一个简单的RPC框架以及其使用，下面我们就一起来验证一下结果吧。&lt;/p&gt;
&lt;h3 id=&quot;测试&quot;&gt;测试&lt;/h3&gt;
&lt;p&gt;在测试之前我们需要在自己本地电脑上安装Zookeeper，具体的安装方式非常简单。可以参考这篇文章。&lt;br/&gt;安装好Zookeeper后，我们需要完成以下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;启动Zookeeper。&lt;/li&gt;
&lt;li&gt;启动服务提供者。&lt;/li&gt;
&lt;li&gt;启动服务消费者。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第一次启动服务消费者的过程中，你的控制台可以能会报一个找不到&lt;code&gt;/rpc&lt;/code&gt;节点的错误，产生这个错误的原因是我们在第一次启动的时候ZK里面并不存在&lt;code&gt;/rpc&lt;/code&gt;这个节点，但是如果你仔细研究&lt;a href=&quot;https://github.com/ganchaoyang/spring-tutorial/tree/master/sb-rpc&quot;&gt;源码&lt;/a&gt;的话，会发现当这个节点不存在的时候，我们会创建一个。所以直接忽略这个异常即可。完成以上几步之后，我们只需要在浏览器中访问&lt;code&gt;http://127.0.0.1:8080/hello-rpc/hello&lt;/code&gt;，如果你看到了下面的结果，那么恭喜你，整个RPC框架完美的运行成功了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/7/23/16c1f68443ff3238?w=755&amp;amp;h=155&amp;amp;f=png&amp;amp;s=6425&quot; alt=&quot;远程调用结果&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;结束语&quot;&gt;结束语&lt;/h3&gt;
&lt;p&gt;本文的主要内容是和大家一起完成了一个Demo版的RPC框架，其主要目的是让大家更深刻的理解RPC的原理以及其调用过程。当然由于文章篇幅的原因，很多代码没有直接在文中给出，您可以在Github上找到&lt;a href=&quot;https://github.com/ganchaoyang/spring-tutorial/tree/master/sb-rpc&quot;&gt;完整的实现&lt;/a&gt;。如果您有什么问题可以在Github上提交Issue或者发送邮件到我的邮箱（gancy.programmer@gmail.com），如果您觉得这篇文章写的还行的话，希望您能给我个Star，这是对我最好的鼓励。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;PS:学习不止，码不停蹄！如果您喜欢我的文章，就关注我吧！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;https://g-blog.oss-cn-beijing.aliyuncs.com/image/qrcode_for_gh_526c6f450b21_258.jpg&quot; alt=&quot;扫码关注“代码无止境”&quot;/&gt;&lt;/div&gt;
</description>
<pubDate>Wed, 24 Jul 2019 00:16:00 +0000</pubDate>
<dc:creator>代码无止境</dc:creator>
<og:description>想要获取更多文章可以访问我的博客 '代码无止境' 。 现在大部分的互联网公司都会采用微服务架构，但具体实现微服务架构的方式有所不同，主流上分为两种，一种是基于Http协议的远程调用，另外一种是基于RP</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/endless-code/p/11235624.html</dc:identifier>
</item>
<item>
<title>使用Mxnet基于skip-gram模型实现word2vect - Fate0729</title>
<link>http://www.cnblogs.com/xiaobingqianrui/p/11235604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaobingqianrui/p/11235604.html</guid>
<description>&lt;p&gt;&lt;strong&gt;使用skip-gram模式实现word2vect，然后在jaychou_lyrics.txt数据集上应用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;jaychou_lyrics.txt数据集收录了周杰伦从第一张专辑到第十张专辑&amp;lt;跨时代&amp;gt;中的歌词，比如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;想要有直升机&lt;br/&gt;想要和你飞到宇宙去&lt;br/&gt;想要和你融化在一起&lt;br/&gt;融化在宇宙里&lt;br/&gt;我每天每天每天在想想想想著你&lt;br/&gt;这样的甜蜜&lt;br/&gt;让我开始乡相信命运&lt;br/&gt;感谢地心引力&lt;br/&gt;让我碰到你&lt;br/&gt;漂亮的让我面红的可爱女人&lt;br/&gt;温柔的让我心疼的可爱女人&lt;br/&gt;透明的让我感动的可爱女人&lt;br/&gt;坏坏的让我疯狂的可爱女人&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;传统方法的局限性&quot;&gt;2.1 传统方法的局限性&lt;/h2&gt;
&lt;p&gt;  我们知道，分词后的数据是不能直接拿到模型里去训练的，我们需要把词语转换成词向量才能进行模型的训练，这样一个词可以有一个多维的词向量组成。&lt;/p&gt;
&lt;p&gt;  传统的方法是one-hot encoding，即用一个长向量来表示一个词，向量的长度为词典的大小，向量的分量只有一个1，其余全为0，1的位置即对应改词在词典中的位置，如电脑表示为：[0 0 0 0 0 1 0 0 0 0 ]，耳机表示为[0 0 0 0 0 0 0 1 0 ]这种方式如果采用稀疏存储，表达简洁，占用空间少，但是这种方法也有几个缺点，一是容易受维数灾难的困扰，尤其是将其用于 Deep Learning的一些算法时；二是不能很好地刻画词与词之间的相似性，即任意两个词之间都是孤立的。光从这两个向量中看不出两个词是否有关系，损失大部分信息，导致结果会有较大偏差。&lt;/p&gt;
&lt;h2 id=&quot;word2vec方法的优势&quot;&gt;2.2 Word2Vec方法的优势&lt;/h2&gt;
&lt;p&gt;  在1968年Hinton又提出了Distributed REpresentation，可以解决One-hot encoding的缺点。其基本想法是直接用一个普通的向量表示一个词，这种向量一般长成这个样子：[0.792, −0.177, −0.107, 0.109, −0.542, ...]，也就是普通的向量表示形式。维度以 50 维和 100 维比较常见。当然一个词怎么表示成这么样的一个向量需要通过训练得到，训练方法较多，word2vec是最常见的一种。需要注意的是，每个词在不同的语料库和不同的训练方法下，得到的词向量可能是不一样的。词向量一般维数不高，一般情况下指定100、500维就可以了，所以用起来维数灾难的机会现对于one-hot representation表示就大大减少了。&lt;/p&gt;
&lt;p&gt;  由于是用向量表示，而且用较好的训练算法得到的词向量的向量一般是有空间上的意义的，也就是说，将所有这些向量放在一起形成一个词向量空间，而每一向量则为该空间中的一个点，在这个空间上的词向量之间的距离度量也可以表示对应的两个词之间的“距离”。所谓两个词之间的“距离”，就是这两个词之间的语法，语义之间的相似性。&lt;/p&gt;
&lt;p&gt;  一个比较爽的应用方法是，得到词向量后，假如对于某个词A，想找出这个词最相似的词，在建立好词向量后的情况，对计算机来说，只要拿这个词的词向量跟其他词的词向量一一计算欧式距离或者cos距离，得到距离最小的那个词，就是它最相似的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注:&lt;/strong&gt;这里偷了个懒，以上内容摘抄自博客园博主Charlotte77，记得大佬曾对词向量有过一段描述，写的非常清楚，于是找来copy了下,在这里感谢博主的分享&lt;/p&gt;
&lt;p&gt;下面再简单介绍下word2vect的两种模型，skip-gram模型和cbow模型&lt;/p&gt;
&lt;h2 id=&quot;cbow模型&quot;&gt;2.3 CBOW模型&lt;/h2&gt;
&lt;p&gt;CBOW模型包含三层:输入层、映射层、输出层，其架构如下图:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201907/1117865-20190724080243540-1627335053.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  w(t)为输入词，在已知词w(t)的前提下预测w(t)的上下文w(t-2)、w(t-1)、w(t+1)、w(t+2),条件概率为:&lt;span class=&quot;math inline&quot;&gt;\(p(w|context(w))\)&lt;/span&gt;。目标函数为:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum logp(w|context(w))\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;  CBOW模型训练其实就是根据某个词前后若干个词来预测该词，这其实可以看出是多分类，最朴素的想法就是直接使用softmax来分别计算每个词对应的归一化的概率，但对于动辄十几万词汇量的场景中使用softmax计算量太大，于是需要用一种二分类组合形式的hierarchical softmax,即输出一颗二叉树&lt;/p&gt;
&lt;h2 id=&quot;skip-gram模型&quot;&gt;2.4 Skip-Gram模型&lt;/h2&gt;
&lt;p&gt;  Skip-Gram模型包含三层:输入层、映射层、输出层，其架构如下图:&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201907/1117865-20190724080300985-1491421765.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;w(t)为输入词，在已知词w(t)的前提下预测w(t)的上下文w(t-2)、w(t-1)、w(t+1)、w(t+2),条件概率为:&lt;span class=&quot;math inline&quot;&gt;\(p(context(w)|w)\)&lt;/span&gt;。目标函数为:&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[\sum logp(context(w)|w)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;Skip-Gram的基本思想是通过已知词的前提下预测其上下文的词，通过一个例子来说明，假设有个句子：&lt;/p&gt;
&lt;p&gt;i love green eggs and ham&lt;/p&gt;
&lt;p&gt;接下来，根据Skip-Gram算法基本思想，把这个语句生成由系列(输入，输出)构成的数据集，当上下文窗口大小为1时，love的上下文为[i，green],green的上下文为[love,eggs],依次类推。上面的数据集可以转换成：&lt;/p&gt;
&lt;p&gt;datasets = [[love，i],[love，green],[green，love],[green，egges],...,[and，eggs],[and，ham]]&lt;/p&gt;

&lt;p&gt;(1). 对数据集进行预处理，对数据集进行分词处理、提取特征词、建议词索引&lt;br/&gt;(2). 二次采样，降低高频词概率&lt;br/&gt;(3). 提取中心词和背景词&lt;br/&gt;(4). 负采样&lt;br/&gt;(5). 构建模型训练数据&lt;br/&gt;(6). 定义和训练模型&lt;/p&gt;

&lt;p&gt;(1). 中心词和背景词的提取方式&lt;br/&gt;(2). 为什么要进行负采样，怎样进行负采样&lt;br/&gt;(3). 当背景词和负样本词窗口大小不固定时，该如何对数据进行建模&lt;br/&gt;(4). 明确损失函数的计算方式&lt;/p&gt;
&lt;p&gt;这里就不作解答了，答案都在代码里面&lt;/p&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import random
import math
import zipfile
import jieba
import collections
import time
import mxnet as mn
from mxnet import nd,autograd,initializer
from mxnet.gluon import data as gdata
from mxnet.gluon import nn,trainer
from mxnet.gluon import loss as gloss&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;读数据文集获得数据集&quot;&gt;5.1 读数据文集，获得数据集&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 读数据文集，获得数据集
def load_dataset(file):
    dataset = []
    with zipfile.ZipFile(file) as zf:
        with zf.open(zf.namelist()[0]) as pf:
            for line in pf.readlines():
                line = line.decode('utf-8', 'ignore').strip()
                dataset.append(line)
    return dataset&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;datafile = '.\\datasets\\jaychou_lyrics.txt.zip'
dataset = load_dataset(datafile)
print(dataset[:3])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;['想要有直升机', '想要和你飞到宇宙去', '想要和你融化在一起']&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;进行分词处理&quot;&gt;5.2 进行分词处理&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def check_contain_chinese(check_str):
        '''
        判断邮件中的字符是否有中文
        '''
        for ch in check_str:
            if u'\u4e00' &amp;lt;= ch &amp;lt;= u'\u9fff':
                return True
        return False&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def proc_dataset_by_jieba(dataset):
    sentences = []
    for line in dataset:
        sentence = []
        seg_list = jieba.cut(line,cut_all= False)
        for word in seg_list:
            if not check_contain_chinese(word):
                continue
            sentence.append(word)
        sentences.append(sentence)
    return sentences&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sentences_by_jieba = proc_dataset_by_jieba(dataset)
print('ori words len:',sum([len(sentence) for sentence in sentences_by_jieba]))
print(sentences_by_jieba[:10])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;ori words len: 33825
[['想要', '有', '直升机'], ['想要', '和', '你', '飞到', '宇宙', '去'], ['想要', '和', '你', '融化', '在', '一起'], ['融化', '在', '宇宙', '里'], ['我', '每天', '每天', '每天', '在', '想想', '想想', '著', '你'], ['这样', '的', '甜蜜'], ['让', '我', '开始', '乡', '相信', '命运'], ['感谢', '地心引力'], ['让', '我', '碰到', '你'], ['漂亮', '的', '让', '我', '面红', '的', '可爱', '女人']]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;建立词索引&quot;&gt;5.3 建立词索引&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;counter = collections.Counter([word for sentence in sentences_by_jieba for word in sentence])
cabulary_numbers_dict = dict(filter(lambda x:x[1] &amp;gt;= 5, counter.items())) # {词:词出现的次数}

index_to_word = [word for word,_ in cabulary_numbers_dict.items()]   # 根据索引查找词
word_to_index = {word:index for index,word in enumerate(index_to_word)} # 根据词得到索引

# 将原始数据集转换为索引
sentences_to_index = []
for sentence in sentences_by_jieba:
    sentence_to_index = []
    for word in sentence:
        if word in index_to_word:
            sentence_to_index.append(word_to_index[word]) 
    sentences_to_index.append(sentence_to_index)

print('sentences_to_index len:',len(sentences_to_index))
print('words len:',sum([len(sentence_index) for sentence_index in sentences_to_index]))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;sentences_to_index len: 5819
words len: 25429&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二次抽样&quot;&gt;5.4 二次抽样&lt;/h2&gt;
&lt;p&gt;二次抽样：文本数据中一般会出现一些高频词，通常来说，在一个背景窗口，一个词和较低频词同时出现比和较高频词同时出现对训练词嵌入更有益，因此，训练词嵌入模型时可以对词进行二次采样，具体来说，数据集中每个被索引词&lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;将有一定的概率被丢弃，该丢弃的概率为&lt;span class=&quot;math display&quot;&gt;\[P(w_i) = max(1- \sqrt{\frac{t}{f(w_i)}},0)\]&lt;/span&gt;&lt;br/&gt;其中&lt;span class=&quot;math inline&quot;&gt;\(f(w_i)\)&lt;/span&gt;是数据集中词&lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;的个数与总次数的比，常数t是一个超参数，实验中设为&lt;span class=&quot;math inline&quot;&gt;\(10^{-4}\)&lt;/span&gt;,可见当&lt;span class=&quot;math inline&quot;&gt;\(f(w_i) &amp;gt; t\)&lt;/span&gt;时，才有可能在二次采样中丢弃该词&lt;span class=&quot;math inline&quot;&gt;\(w_i\)&lt;/span&gt;,并且越高频的词被丢弃的概率越大&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def throw_word(index):
    temp = 1- math.sqrt(1e-4 / cabulary_numbers_dict[index_to_word[index]] * len(dataset_to_index))
    return random.uniform(0,1) &amp;lt; temp

subsampled_sentences_index = [[word_index for word_index in sentence_index if not throw_word(word_index)]
                      for sentence_index in sentences_to_index]
print('subsampled_words len:',sum([len(sentence_index) for sentence_index in subsampled_sentences_index]))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;subsampled_words len: 7187&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;经过二次抽样后，我们发现从原始词汇数33825---&amp;gt;25429----&amp;gt;7187&lt;/p&gt;
&lt;h2 id=&quot;提取中心词和背景词&quot;&gt;5.5 提取中心词和背景词&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;下面在提取背景词时采用的是非固定窗长&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def get_centers_and_contexts(sentences,max_window_size):
    centers,contexts= [], []
    for sentence in sentences:
        if len(sentence) &amp;lt; 2:  # 每个句子至少要有两个词才能组成一对'中心词-背景词'
            continue
        centers += sentence
        for center_index in range(len(sentence)):
            window_size = random.randint(1,max_window_size)
            indexs = list(range(max(0,center_index- window_size),min(len(sentence),center_index + window_size + 1)))
            indexs.remove(center_index) # 将中心词排除在背景词之外
            contexts.append([sentence[index] for index in indexs])
    return centers,contexts&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;all_centers,all_contexts = get_centers_and_contexts(subsampled_sentences_index,2)
print('中心词个数:',len(all_centers))
print('中心词对应的上下文列表数:',len(all_contexts))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;中心词个数: 5110
中心词对应的上下文列表数: 5110&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;负采样&quot;&gt;5.6 负采样&lt;/h2&gt;
&lt;p&gt;使用负采样来进行近似训练,对于一对中心词和背景词，我们随机采样K个噪音词，根据word2vect论文的建议，噪音词采样概率&lt;span class=&quot;math inline&quot;&gt;\(P(w)\)&lt;/span&gt;设为w词频与总词频之比的0.75次方&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def get_negatives(all_contexts, sampling_weights,k):
    all_negatives = []
    neg_candidates = []
    population = list(range(len(sampling_weights)))
    
    i = 0
    for contexts in all_contexts:
        negatives = []
        while(len(negatives) &amp;lt; len(contexts) * k):
            if i == len(neg_candidates):
                neg_candidates = random.choices(population, sampling_weights, k=int(1e5))
                i = 0
            neg = neg_candidates[i]
            i = i + 1
            if neg not in set(contexts):
                negatives.append(neg)
        all_negatives.append(negatives)
    return all_negatives&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;sampling_weights = [cabulary_numbers_dict[word]**0.75 for word in index_to_word]
all_negatives = get_negatives(all_contexts,sampling_weights,5)
print('中心词对应的负样本列表数:',len(all_negatives))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;中心词对应的负样本列表数: 5110&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;构造数据集&quot;&gt;5.7 构造数据集&lt;/h2&gt;
&lt;p&gt;前面我们已经得到了中心词列表、与中心词对应的上下文列表和与中心词对应的负样本列表，接下来构建数据集，即模型训练数据&lt;/p&gt;
&lt;p&gt;数据集格式：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201907/1117865-20190724080338299-1758555226.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def build_batch_data(data):
    '''
    data数据由三部分组成：center,context,negative
    '''
    maxlen = max(len(context) + len(negative) for _,context,negative in data)
    centers = []
    context_negatives = []
    masks = []
    labels = []
    
    for center,context,negative in data:
        curlen = len(context) + len(negative)
        centers.append(center)
        context_negatives.append(context + negative + [0]*(maxlen - curlen))
        masks.append([1]*curlen + [0]*(maxlen - curlen))
        labels.append([1]*len(context) + [0]*(maxlen-len(context)))
        
    return (nd.array(centers).reshape((-1,1)), 
            nd.array(context_negatives),
            nd.array(masks),
            nd.array(labels))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;batch_size = 512
dataset = gdata.ArrayDataset(all_centers,all_contexts,all_negatives)
data_iter = gdata.DataLoader(dataset, batch_size, shuffle=True, batchify_fn=build_batch_data)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;for batch in data_iter:
    for name,data in zip(['centers','context_negatives','masks','labels'],batch):
        print(name,'shape:',data.shape)
    break&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;centers shape: (512, 1)
context_negatives shape: (512, 24)
masks shape: (512, 24)
labels shape: (512, 24)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;定义和训练模型&quot;&gt;5.8 定义和训练模型&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def skip_gram(center,context_and_negative, embed_c,embed_cn):
    c = embed_c(center)
    cn = embed_cn(context_and_negative)
    return nd.batch_dot(c,cn.swapaxes(1,2))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;embed_size = 100         # 嵌入层大小
net = nn.Sequential()
net.add(nn.Embedding(input_dim = len(index_to_word), output_dim=embed_size),  # 中心词嵌入层
       nn.Embedding(input_dim = len(index_to_word), output_dim=embed_size))   # 背景词和负样本嵌入层
loss = gloss.SigmoidBinaryCrossEntropyLoss()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def train(net,learnint_rate,epochs,ctx=mn.gpu()):
    net.initialize(init=initializer.Xavier(),ctx=ctx,force_reinit=True)
    trainer_op = trainer.Trainer(net.collect_params(),'adam', {'learning_rate':learnint_rate})
    
    for epoch in range(epochs):
        start,loss_sum,n = time.time(),0.0, 0
        for batch in data_iter:
            center,context_negative, mask, label = [data.as_in_context(ctx) for data in batch]
            with autograd.record():
                pred = skip_gram(center,context_negative,net[0],net[1])
                loss_val = (loss(pred.reshape(label.shape),label,mask) * mask.shape[1] / mask.sum(axis=1))
            loss_val.backward()
            trainer_op.step(batch_size)
            loss_sum += loss_val.sum().asscalar()
            n += loss_val.size
        print('epoch:%d,loss:%.2f,time %.2f' %(epoch+1, loss_sum / n,time.time() - start))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;train(net,0.01,20)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;epoch:1,loss:0.69,time 0.33
epoch:2,loss:0.64,time 0.27
epoch:3,loss:0.52,time 0.25
epoch:4,loss:0.38,time 0.23
epoch:5,loss:0.30,time 0.22
epoch:6,loss:0.23,time 0.22
epoch:7,loss:0.17,time 0.23
epoch:8,loss:0.12,time 0.22
epoch:9,loss:0.09,time 0.22
epoch:10,loss:0.07,time 0.23
epoch:11,loss:0.06,time 0.22
epoch:12,loss:0.05,time 0.23
epoch:13,loss:0.04,time 0.23
epoch:14,loss:0.04,time 0.22
epoch:15,loss:0.03,time 0.22
epoch:16,loss:0.03,time 0.22
epoch:17,loss:0.03,time 0.22
epoch:18,loss:0.03,time 0.22
epoch:19,loss:0.03,time 0.22
epoch:20,loss:0.02,time 0.27&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;词向量可视化&quot;&gt;5.9 词向量可视化&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;from sklearn.manifold import TSNE
import matplotlib.pyplot as plt
num_points = 200  

# TSNE提供了一种有效的降维方式，让我们对高于2维数据的聚类结果以二维的方式展示出来
tsne = TSNE(perplexity=30,n_components=2,init='pca',n_iter=5000)

embeddings = net[0].weight.data().asnumpy()
two_d_embeddings = tsne.fit_transform(embeddings[0:num_points,:])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import matplotlib

#解决中文显示乱码的问题
matplotlib.rcParams['font.sans-serif'] = ['SimHei']
matplotlib.rcParams['axes.unicode_minus'] = False

def plot(embeddings,labels):
    plt.figure(figsize=(16,20))
    for i,label in enumerate(labels):
        x,y = embeddings[i,:]
        plt.scatter(x,y)
        plt.annotate(label,(x,y),xytext=(5,2),textcoords='offset points',ha='right',va='bottom')
    plt.show()
words = [index_to_word[i] for i in range(num_points)]
plot(two_d_embeddings,words)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1117865/201907/1117865-20190724080352817-1998901273.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从上图，你能唱出几句周董的歌？&lt;/strong&gt;，代码和数据集均已上传到github&lt;/p&gt;
</description>
<pubDate>Wed, 24 Jul 2019 00:11:00 +0000</pubDate>
<dc:creator>Fate0729</dc:creator>
<og:description>1. 需求 使用skip gram模式实现word2vect，然后在jaychou_lyrics.txt数据集上应用 jaychou_lyrics.txt数据集收录了周杰伦从第一张专辑到第十张专辑中的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaobingqianrui/p/11235604.html</dc:identifier>
</item>
<item>
<title>云阶月地，关锁千重(一.公平和非公平) - Java极客技术</title>
<link>http://www.cnblogs.com/justdojava/p/11211838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/justdojava/p/11211838.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/laEmibHFxFw6FIf5Fu0lM7yfOx2FibL3SlFUoxQibVUBicYSbrJTB1Ja7mjZe6GV3Gw5570zrZQbA2IbxntQMRicFbQ/640?wx_fmt=png&quot; alt=&quot;&quot; data-ratio=&quot;0.9836065573770492&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;305&quot;/&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看到文章的标题是不是很诧异，一个搞技术的为什么要搞这么文艺的话题呢？标题说关锁千重，是不是很形象，我们在开发中的锁不也是多种多样么？&lt;/p&gt;
&lt;h3&gt;Lock&lt;/h3&gt;
&lt;p&gt;既然之前说了锁千重，那锁到底有多少种，他们的分类又是怎么区分的，为什么这么区分？我来给大家解释一下。&lt;/p&gt;
&lt;h3&gt;为什么加锁？&lt;/h3&gt;
&lt;p&gt;面试中有很多时候会问到，为什么加锁？加锁是起到什么作用？&lt;/p&gt;
&lt;p&gt;而实际上在我们的开发过程中会出现并发的情况，比如说两个人几乎同时点击了某一个按钮，这个时候就可以简单的理解成并发，那么到底谁先谁后？ 程序中就很可能出现错误，当资源出现共享的时候，就会开始涉及到并发了，这个时候我们就可能会用到锁了，来锁住某一个资源，等我用过之后，你才能动。 这就是为什么使用锁。&lt;/p&gt;
&lt;h3&gt;锁的分类&lt;/h3&gt;
&lt;p&gt;1.公平锁/非公平锁&lt;/p&gt;
&lt;p&gt;2.可重入锁&lt;/p&gt;
&lt;p&gt;3.独享锁/共享锁&lt;br/&gt;4.互斥锁/读写锁&lt;br/&gt;5.乐观锁/悲观锁&lt;br/&gt;6.分段锁&lt;br/&gt;7.偏向锁/轻量级锁/重量级锁&lt;br/&gt;8.自旋锁&lt;/p&gt;

&lt;p&gt;第一次分享，我们就先说这个公平锁和非公平锁。之后会在后序的文章中继续解析！&lt;/p&gt;
&lt;p&gt;何为公平？何为非公平？在我们日常生活中的理解不就是对等的就是公平，不对等的就是不公平？ 其实差不多的。&lt;/p&gt;
&lt;p&gt;公平锁是指多个线程按照申请锁的顺序来获取锁&lt;/p&gt;
&lt;p&gt;非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。&lt;/p&gt;

&lt;p&gt;在JAVA的代码中什么是公平锁什么又是非公平的锁呢？&lt;/p&gt;
&lt;p&gt;一种是使用Java自带的关键字synchronized对相应的类或者方法以及代码块进行加锁，&lt;/p&gt;
&lt;p&gt;而另一种是ReentrantLock，前者只能是非公平锁，而后者是默认非公平但可实现公平的一把锁。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/laEmibHFxFw724InD5jlZDAXpDpDcTic2ONibyaTgW2picvdIcNXbDPglAb59b6JEq2X4WBBvourK5E2F7ctdOKZ9w/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.6528189910979229&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;337&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的类图看起来很不舒服，因为关于ReentrantLock这个锁，确实是没有很好的配图，我们可以自己画出来理解一下&lt;/p&gt;
&lt;p&gt;我们先看非公平锁，我画图大家理解一下，就像公共厕所，不要嫌弃恶心，但是绝对容易理解&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/laEmibHFxFw724InD5jlZDAXpDpDcTic2OhBniawllTFWloGcnP8ic1fkXkelh1RPZFiab1DGLg1feIK1icjU77EAOkA/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5954922894424673&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;843&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面这幅图，加入说图中的管理员是Lock，然后现在A来了，说我要去厕所，这时候管理员一看，厕所没人，那好你进去把，然后A就进去了。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/laEmibHFxFw724InD5jlZDAXpDpDcTic2OgvNVEvXL2Q6Nxia6DAwlJRzcyEiaG2sKWEiabueN6ICGVribD3EsWV2jdA/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.8174442190669371&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;493&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候WC里面是有A的，正在进行式，这时候B来了，B也想去厕所&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/laEmibHFxFw724InD5jlZDAXpDpDcTic2OJ20BdOQf5jicbXZow6elhIRan65KcR2aovfibBZ7HbYhsSPib5y7OH27A/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.554945054945055&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;910&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是这个时候WC里面是有A的，然后管理员Lock看了一下，里面有人，排队把。。。&lt;/p&gt;
&lt;p&gt;然后这B就得憋着，去进入队列去排队，然后又来了个C，这时候A还在里面，C只能也去排队，&lt;/p&gt;
&lt;p&gt;就是这个样子的&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/laEmibHFxFw724InD5jlZDAXpDpDcTic2Oql9hycdWDWhEOkXdouvyckKNjf0DmVPXv2icFIV6DjMQ8orAJ3VOlUg/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.8626543209876543&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;648&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时候又过了一小会来了个D，也想去WC，这时候A恰好结束了，&lt;/p&gt;
&lt;p&gt;这时候非公平锁就上场了，Lock管理员一看，里面没人，D你进去把，这时候就是这样的。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/laEmibHFxFw724InD5jlZDAXpDpDcTic2OiaPF3Omia7uzGkDdSVqBnVY39oOgQ8sgbdqoibgj1WA9Uzk14aj1yCbDw/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.8640483383685801&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;662&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后这时候因为A出来了之后说，我结束了，然后B正准备进去的时候，里面又有了D，这就是出现了非公平锁&lt;/p&gt;
&lt;p&gt;而非公平锁的调用就是 A被Lock --&amp;gt; B去wait--&amp;gt; C在B后面wait --&amp;gt; A结束了，unlock --&amp;gt;非公平锁compareAndSetState(0, acquires),里面没人 --&amp;gt;D被Lock 这时候A释放锁lock.release，--&amp;gt;结果晚了一步，没进去，只能继续等着&lt;/p&gt;
&lt;p&gt;这就是非公平锁的简单的一种理解，道理其实挺简单的， 而公平锁就不一样了，Lock管理员会告诉新来的D，你前面已经有好几个在排号的了，你想进去，去后边排队。&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;rich_pages&quot; src=&quot;https://mmbiz.qpic.cn/mmbiz_png/laEmibHFxFw724InD5jlZDAXpDpDcTic2OD7k7qnrQjdDjGDaZSLF588rzg7LaDnAUxP3FVGd0txH4icibAV9Myvrw/640?wx_fmt=png&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-ratio=&quot;0.5791399817017383&quot; data-s=&quot;300,640&quot; data-type=&quot;png&quot; data-w=&quot;1093&quot;/&gt;&lt;/p&gt;
&lt;p&gt;公平锁的调用是这样子的。&lt;/p&gt;
&lt;p&gt;前面其实都是一样的，但是当D来的时候就不一样了，&lt;/p&gt;
&lt;p&gt;D来的时候--&amp;gt;lock知道了--&amp;gt;直接调用hasQueuedPredecessors()告诉D有人在排队，你去后边排队，这样子下来就实实在在的保证了公平了。&lt;/p&gt;
&lt;p&gt;接下来我们看看ReentrantLock的源代码实现，然后解释一下&lt;/p&gt;
&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;非公平&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;public class ReentrantLock implements Lock, java.io.Serializable {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        /*同步器提供所有实现机制 */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        private final Sync sync;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        此锁的同步控制基础。将转换为下面的公平和非公平版本。使用AQS状态表示锁定的保持数。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       abstract static class Sync extends AbstractQueuedSynchronizer {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           private static final long serialVersionUID = -5179523762034025860L;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            执行{@link Lock＃lock}。子类化x的主要原因是允许非公平版本的快速路径。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           abstract void lock();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            * 执行非公平的tryLock。 tryAcquire在子类中实现，但两者都需要tryf方法的非公平尝试。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                注意在这里执行的是非公平锁也就是说在判断方法compareAndSerState的时候，&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                新的线程可能抢占已经排队的线程的锁的使用权&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           final boolean nonfairTryAcquire(int acquires) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               final Thread current = Thread.currentThread();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               int c = getState();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               //状态为0，说明当前没有线程占有锁&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               if (c == 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   if (compareAndSetState(0, acquires)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                       setExclusiveOwnerThread(current);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                       return true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               else if (current == getExclusiveOwnerThread()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   int nextc = c + acquires;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   if (nextc &amp;lt; 0) // overflow&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                       throw new Error(&quot;Maximum lock count exceeded&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   setState(nextc);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   return true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               return false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           protected final boolean tryRelease(int releases) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               int c = getState() - releases;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               if (Thread.currentThread() != getExclusiveOwnerThread())&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   throw new IllegalMonitorStateException();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               boolean free = false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               if (c == 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   free = true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                   setExclusiveOwnerThread(null);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               setState(c);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               return free;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           protected final boolean isHeldExclusively() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               // While we must in general read state before owner,&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               // we don't need to do so to check if current thread is owner&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               return getExclusiveOwnerThread() == Thread.currentThread();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           final ConditionObject newCondition() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               return new ConditionObject();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           // Methods relayed from outer class&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           final Thread getOwner() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               return getState() == 0 ? null : getExclusiveOwnerThread();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           final int getHoldCount() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               return isHeldExclusively() ? getState() : 0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           final boolean isLocked() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               return getState() != 0;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            从流中重构实例（即反序列化它）。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           private void readObject(java.io.ObjectInputStream s)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               throws java.io.IOException, ClassNotFoundException {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               s.defaultReadObject();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;               setState(0); // reset to unlocked state&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;           }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;       }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;}}&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;上面的源码都是说的是非公平锁的，我们在看看源码中对公平锁又是怎么进行定义的！&lt;/p&gt;

&lt;pre class=&quot;code-snippet__js code-snippet code-snippet_nowrap&quot; data-lang=&quot;公平&quot;&gt;
&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        同步对象以进行公平锁定&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;     */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    static final class FairSync extends Sync {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        private static final long serialVersionUID = -3000897897090466540L;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        final void lock() {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            acquire(1);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        /**&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         tryAcquire的公平版本。除非递归呼叫或没有服务员或是第一个，否则不授予访问权限。&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            在这里有一个hasQueuedPredecessors的方法，就是这个方法来保证我们不论是新的线程还是已经在进行排队的线程都顺序的去使用锁&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;         */&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        protected final boolean tryAcquire(int acquires) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            final Thread current = Thread.currentThread();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            int c = getState();&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            if (c == 0) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (!hasQueuedPredecessors() &amp;amp;&amp;amp;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    compareAndSetState(0, acquires)) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    setExclusiveOwnerThread(current);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    return true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            else if (current == getExclusiveOwnerThread()) {&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                int nextc = c + acquires;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                if (nextc &amp;lt; 0)&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                    throw new Error(&quot;Maximum lock count exceeded&quot;);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                setState(nextc);&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;                return true;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;            return false;&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;        }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;code&gt;&lt;span class=&quot;code-snippet_outer&quot;&gt;​&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;解释完了，我们来做个总结 总结一：&lt;/p&gt;
&lt;p&gt;1.公平锁：老的线程排队使用锁，新线程仍然排队使用锁。2.非公平锁：老的线程排队使用锁；但是新的线程是极有可能抢占已经在排队的线程的锁。&lt;/p&gt;
&lt;p&gt;以后我会更新关于锁的一些文章，希望大家能够指点一下，也能够共同的讨论进步，谢谢！&lt;/p&gt;
&lt;p&gt;​&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;strong&gt;&lt;br class=&quot;Apple-interchange-newline&quot;/&gt;
Java 极客技术公众号，是由一群热爱 Java 开发的技术人组建成立，专注分享原创、高质量的 Java 文章。&lt;/strong&gt;&lt;strong&gt;如果您觉得我们的文章还不错，请帮忙赞赏、在看、转发支持，鼓励我们分享出更好的文章。&lt;/strong&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;关注公众号，大家可以在公众号后台回复“博客园”，免费获得作者 Java 知识体系/面试必看资料。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://mmbiz.qpic.cn/mmbiz_jpg/laEmibHFxFw4HxcgPDQRiaQcGWmoqB7Fj8MuG51ic0QUXT2Ytq1NRiawzPNfQzjZzAWbv8JfD3ejia1ibvUYQOqFDqIw/640?wx_fmt=jpeg&quot; alt=&quot;&quot; data-copyright=&quot;0&quot; data-cropselx1=&quot;0&quot; data-cropselx2=&quot;220&quot; data-cropsely1=&quot;0&quot; data-cropsely2=&quot;123&quot; data-ratio=&quot;1&quot; data-s=&quot;300,640&quot; data-type=&quot;jpeg&quot; data-w=&quot;258&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 23 Jul 2019 23:31:00 +0000</pubDate>
<dc:creator>Java极客技术</dc:creator>
<og:description>看到文章的标题是不是很诧异，一个搞技术的为什么要搞这么文艺的话题呢？标题说关锁千重，是不是很形象，我们在开发中的锁不也是多种多样么？ Lock 既然之前说了锁千重，那锁到底有多少种，他们的分类又是怎么</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/justdojava/p/11211838.html</dc:identifier>
</item>
<item>
<title>JAVA面试题 请谈谈你对Sychronized关键字的理解？ - Java蚂蚁</title>
<link>http://www.cnblogs.com/marsitman/p/11235552.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/marsitman/p/11235552.html</guid>
<description>&lt;p&gt;&lt;strong&gt;面试官：sychronized关键字有哪些特性？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;应聘者：&lt;/strong&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以用来修饰方法;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以用来修饰代码块;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以用来修饰静态方法;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;可以保证线程安全;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持锁的重入;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;sychronized使用不当导致死锁;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;了解sychronized之前,我们先来看一下几个常见的概念:内置锁、互斥锁、对象锁和类锁。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;内置锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;在Java中每一个对象都可以作为同步的锁，那么这些锁就被称为内置锁。线程进入同步代码块或方法的时候会自动获得该锁，在退出同步代码块或方法时会释放该锁。获得内置锁的唯一途径就是进入这个锁的保护的同步代码块或方法。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;互斥锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;内置锁同时也是一个互斥锁，这就是意味着最多只有一个线程能够获得该锁，当线程A尝试去获得线程B持有的内置锁时，线程A必须等待或者阻塞，直到线程B抛出异常或者正常执行完毕释放这个锁；如果B线程不释放这个锁，那么A线程将永远等待下去。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;对象锁和类锁&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对象锁和类锁在锁的概念上基本上和内置锁是一致的，但是，两个锁实际是有很大的区别的。&lt;/p&gt;
&lt;p&gt;一个对象无论有多少个同步方法区，它们共用一把锁，某一时刻某个线程已经进入到某个synchronzed方法，那么在该方法没有执行完毕前，其他线程无法访问该对象的任何synchronzied 方法的，但可以访问非synchronzied方法。&lt;/p&gt;
&lt;p&gt;如果synchronized方法是static的，那么当线程访问该方法时，它锁的并不是synchronized方法所在的对象，而是synchronized方法所在对象的对应的Class对象，&lt;/p&gt;
&lt;p&gt;因为java中无论一个类有多少个对象，这些对象会对应唯一一个Class对象，因此当线程分别访问同一个类的两个对象的static，synchronized方法时，他们的执行也是按顺序来的，也就是说一个线程先执行，一个线程后执行。&lt;/p&gt;
&lt;p&gt; &lt;strong&gt;synchronized的用法：修饰方法和修饰代码块，&lt;/strong&gt;下面分别分析这两种用法在对象锁和类锁上的效果。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;对象锁的synchronized修饰方法和代码块&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class TestSynchronized {
    public void test1() {
        synchronized (this) {
            int i = 5;
            while (i-- &amp;gt; 0) {
                System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException ie) {
                }
            }
        }
    }

    public synchronized void test2() {
        int i = 5;
        while (i-- &amp;gt; 0) {
            System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException ie) {
            }
        }
    }

    public static void main(String[] args) {
        final TestSynchronized myt2 = new TestSynchronized();
        Thread test1 = new Thread(new Runnable() {
            public void run() {
                myt2.test1();
            }
        }, &quot;test1&quot;);
        Thread test2 = new Thread(new Runnable() {
            public void run() {
                myt2.test2();
            }
        }, &quot;test2&quot;);
        test1.start();
        test2.start();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;打印结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
test2 : 4
test2 : 3
test2 : 2
test2 : 1
test2 : 0
test1 : 4
test1 : 3
test1 : 2
test1 : 1
test1 : 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述的代码，第一个方法用了同步代码块的方式进行同步，传入的对象实例是this，表明是当前对象；第二个方法是修饰方法的方式进行同步。因为第一个同步代码块传入的this，所以两个同步代码所需要获得的对象锁都是同一个对象锁，下面main方法时分别开启两个线程，分别调用test1和test2方法，那么两个线程都需要获得该对象锁，另一个线程必须等待。上面也给出了运行的结果可以看到：直到test2线程执行完毕，释放掉锁，test1线程才开始执行。这里test2方法先抢到CPU资源，故它先执行，它获得了锁，它执行完毕后，test1才开始执行。&lt;/p&gt;
&lt;p&gt;如果我们把test2方法的synchronized关键字去掉，执行结果会如何呢？　&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
test1 : 4
test2 : 4
test2 : 3
test2 : 2
test2 : 1
test2 : 0
test1 : 3
test1 : 2
test1 : 1
test1 : 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们可以看到，结果输出是交替着进行输出的，这是因为，某个线程得到了对象锁，但是另一个线程还是可以访问没有进行同步的方法或者代码。进行了同步的方法（加锁方法）和没有进行同步的方法（普通方法）是互不影响的，一个线程进入了同步方法，得到了对象锁，其他线程还是可以访问那些没有同步的方法（普通方法）。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;类锁的修饰（静态）方法和代码块&lt;/strong&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class TestSynchronized {
    public void test1() {
        synchronized (TestSynchronized.class) {
            int i = 5;
            while (i-- &amp;gt; 0) {
                System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
                try {
                    Thread.sleep(500);
                } catch (InterruptedException ie) {
                }
            }
        }
    }

    public static synchronized void test2() {
        int i = 5;
        while (i-- &amp;gt; 0) {
            System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException ie) {
            }
        }
    }

    public static void main(String[] args) {
        final TestSynchronized myt2 = new TestSynchronized();
        Thread test1 = new Thread(new Runnable() {
            public void run() {
                myt2.test1();
            }
        }, &quot;test1&quot;);
        Thread test2 = new Thread(new Runnable() {
            public void run() {
                TestSynchronized.test2();
            }
        }, &quot;test2&quot;);
        test1.start();
        test2.start();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
test1 : 4
test1 : 3
test1 : 2
test1 : 1
test1 : 0
test2 : 4
test2 : 3
test2 : 2
test2 : 1
test2 : 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类锁修饰方法和代码块的效果和对象锁是一样的，因为类锁只是一个抽象出来的概念，只是为了区别静态方法的特点，因为静态方法是所有对象实例共用的，所以对应着synchronized修饰的静态方法的锁也是唯一的，所以抽象出来个类锁。其实这里的重点在下面这块代码，synchronized同时修饰静态和非静态方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class TestSynchronized {
    public synchronized void test1() {
        int i = 5;
        while (i-- &amp;gt; 0) {
            System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException ie) {
            }
        }
    }

    public static synchronized void test2() {
        int i = 5;
        while (i-- &amp;gt; 0) {
            System.out.println(Thread.currentThread().getName() + &quot; : &quot; + i);
            try {
                Thread.sleep(500);
            } catch (InterruptedException ie) {
            }
        }
    }

    public static void main(String[] args) {
        final TestSynchronized myt2 = new TestSynchronized();
        Thread test1 = new Thread(new Runnable() {
            public void run() {
                myt2.test1();
            }
        }, &quot;test1&quot;);
        Thread test2 = new Thread(new Runnable() {
            public void run() {
                TestSynchronized.test2();
            }
        }, &quot;test2&quot;);
        test1.start();
        test2.start();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出结果如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
test1 : 4
test2 : 4
test1 : 3
test2 : 3
test2 : 2
test1 : 2
test2 : 1
test1 : 1
test1 : 0
test2 : 0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面代码synchronized同时修饰静态方法和实例方法，但是运行结果是交替进行的，这证明了类锁和对象锁是两个不一样的锁，控制着不同的区域，它们是互不干扰的。同样，线程获得对象锁的同时，也可以获得该类锁，即同时获得两个锁，这是允许的。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;synchronized是如何保证线程安全的&lt;/strong&gt;&lt;/span&gt;　　&lt;/p&gt;
&lt;p&gt;如果有多个线程在同时运行，而这些线程可能会同时运行这段代码。程序每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。&lt;/p&gt;
&lt;p&gt;我们通过一个案例，演示线程的安全问题：&lt;/p&gt;
&lt;p&gt;我们来模拟一下火车站卖票过程，总共有100张票，总共有三个窗口卖票。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class SellTicket {
    public static void main(String[] args) {
        // 创建票对象
        Ticket ticket = new Ticket();
        // 创建3个窗口
        Thread t1 = new Thread(ticket, &quot;窗口1&quot;);
        Thread t2 = new Thread(ticket, &quot;窗口2&quot;);
        Thread t3 = new Thread(ticket, &quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}

// 模拟票
class Ticket implements Runnable {
    // 共100票
    int ticket = 100;

    @Override
    public void run() {
        // 模拟卖票
        while (true) {
            if (ticket &amp;gt; 0) {
                // 模拟选坐的操作
                try {
                    Thread.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(Thread.currentThread().getName() + &quot;正在卖票:&quot;
                        + ticket--);
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;运行结果发现：上面程序出现了问题&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot;&gt;&lt;li&gt;
&lt;p&gt;票出现了重复的票&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;错误的票 0、-1&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实，线程安全问题都是由全局变量及静态变量引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，这个全局变量是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。&lt;/p&gt;

&lt;p&gt;那么出现了上述问题，我们应该如何解决呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程同步（线程安全处理Synchronized）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;java中提供了线程同步机制，它能够解决上述的线程安全问题。&lt;/p&gt;
&lt;p&gt;线程同步的方式有两种：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步代码块&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步代码块: 在代码块声明上 加上synchronized&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
synchronized (锁对象) {
    可能会产生线程安全问题的代码
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同步代码块中的锁对象可以是任意的对象；但多个线程时，要使用同一个锁对象才能够保证线程安全。&lt;/p&gt;
&lt;p&gt;使用同步代码块，对火车站卖票案例中Ticket类进行如下代码修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class SellTicket {
    public static void main(String[] args) {
        // 创建票对象
        Ticket ticket = new Ticket();
        // 创建3个窗口
        Thread t1 = new Thread(ticket, &quot;窗口1&quot;);
        Thread t2 = new Thread(ticket, &quot;窗口2&quot;);
        Thread t3 = new Thread(ticket, &quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}

// 模拟票
class Ticket implements Runnable {
    // 共100票
    int ticket = 100;

    Object lock = new Object();

    @Override
    public void run() {
        // 模拟卖票
        while (true) {
            // 同步代码块
            synchronized (lock) {
                if (ticket &amp;gt; 0) {
                    // 模拟选坐的操作
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName()
                            + &quot;正在卖票:&quot; + ticket--);
                }
            }
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当使用了同步代码块后，上述的线程的安全问题，解决了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;同步方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;同步方法：在方法声明上加上synchronized&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public synchronized void method(){
       可能会产生线程安全问题的代码
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;同步方法中的锁对象是 this&lt;/p&gt;
&lt;p&gt;使用同步方法，对火车站卖票案例中Ticket类进行如下代码修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class SellTicket {
    public static void main(String[] args) {
        // 创建票对象
        Ticket ticket = new Ticket();
        // 创建3个窗口
        Thread t1 = new Thread(ticket, &quot;窗口1&quot;);
        Thread t2 = new Thread(ticket, &quot;窗口2&quot;);
        Thread t3 = new Thread(ticket, &quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
    }
}

// 模拟票
class Ticket implements Runnable {
    // 共100票
    int ticket = 100;

    Object lock = new Object();

    @Override
    public void run() {
        // 模拟卖票
        while (true) {
            // 同步方法
            method();
        }
    }

    // 同步方法,锁对象this
    public synchronized void method() {
        if (ticket &amp;gt; 0) {
            // 模拟选坐的操作
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(Thread.currentThread().getName() + &quot;正在卖票:&quot;
                    + ticket--);
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;synchronized支持锁的重入吗？&lt;/strong&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;我们先来看下面一段代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class ReentrantLockDemo {
    public synchronized void a() {
        System.out.println(&quot;a&quot;);
        b();
    }

    private synchronized void b() {
        System.out.println(&quot;b&quot;);
    }

    public static void main(String[] args) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                ReentrantLockDemo d = new ReentrantLockDemo();
                d.a();
            }
        }).start();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述的代码，我们分析一下，两个方法，方法a和方法b都被synchronized关键字修饰，锁对象是当前对象实例，按照上文我们对synchronized的了解，如果调用方法a,在方法a还没有执行完之前，我们是不能执行方法b的，方法a必须先释放锁，方法b才能执行，方法b处于等待状态，那样不就形成死锁了吗？那么事实真的如分析一致吗？&lt;/p&gt;
&lt;p&gt;运行结果发现：&lt;/p&gt;

&lt;p&gt;代码很快就执行完了，实验结果与分析不一致，这就引入了另外一个概念：重入锁。在 java 内部，同一线程在调用自己类中其他 synchronized 方法/块或调用父类的 synchronized 方法/块都不会阻碍该线程的执行。就是说同一线程对同一个对象锁是可重入的，而且同一个线程可以获取同一把锁多次，也就是可以多次重入。在JDK1.5后对synchronized关键字做了相关优化。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;synchronized死锁问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;同步锁使用的弊端：当线程任务中出现了多个同步(多个锁)时，如果同步中嵌套了其他的同步。这时容易引发一种现象：程序出现无限等待，这种现象我们称为死锁。这种情况能避免就避免掉。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
synchronzied(A锁){
    synchronized(B锁){
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们进行下死锁情况的代码演示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class DeadLock {
    Object obj1 = new Object();
    Object obj2 = new Object();

    public void a() {
        synchronized (obj1) {
            synchronized (obj2) {
                System.out.println(&quot;a&quot;);
            }
        }
    }

    public void b() {
        synchronized (obj2) {
            synchronized (obj1) {
                System.out.println(&quot;b&quot;);
            }
        }
    }

    public static void main(String[] args) {
        DeadLock d = new DeadLock();
        new Thread(new Runnable() {
            @Override
            public void run() {
                d.a();
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                d.b();
            }
        }).start();
    }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述的代码，我们分析一下，两个方法，我们假设两个线程T1,T2，T1运行到方法a了，拿到了obj1这把锁，此时T2运行到方法b了，拿到了obj2这把锁，T1要往下执行，就必须等待T2释放了obj2这把锁，线程T2要往下面执行，就必须等待T1释放了持有的obj1这把锁，他们两个互相等待，就形成了死锁。&lt;/p&gt;
&lt;p&gt;为了演示的更明白，需要让两个方法执行过程中睡眠10ms，要不然很难看到现象，因为计算机执行速度贼快&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class DeadLock {
    Object obj1 = new Object();
    Object obj2 = new Object();

    public void a() {
        synchronized (obj1) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (obj2) {
                System.out.println(&quot;a&quot;);
            }
        }
    }

    public void b() {
        synchronized (obj2) {
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (obj1) {
                System.out.println(&quot;b&quot;);
            }
        }
    }

    public static void main(String[] args) {
        DeadLock d = new DeadLock();
        new Thread(new Runnable() {
            @Override
            public void run() {
                d.a();
            }
        }).start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                d.b();
            }
        }).start();
    }

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;感兴趣的童鞋，下去可以试一下，程序执行不完，永远处于等待状态。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;sychronized是隐式锁，是JVM底层支持的关键字，由JVM来维护；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;单体应用下，多线程并发操作时，使用sychronized关键字可以保证线程安全;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;sychronized可以用来修饰方法和代码块，此时锁是当前对象实例，修饰静态方法时，锁是对象的class字节码文件;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;一个线程进入了sychronized修饰的同步方法，得到了对象锁，其他线程还是可以访问那些没有同步的方法（普通方法）;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;sychronized支持锁的重入;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者：&lt;a href=&quot;https://www.cnblogs.com/marsitman/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Java蚂蚁&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;出处：&lt;a href=&quot;https://www.cnblogs.com/marsitman/p/11235552.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;https://www.cnblogs.com/marsitman/p/11235552.html&lt;/span&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;版权：转载请在文章明显位置注明作者及出处。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Jul 2019 23:09:00 +0000</pubDate>
<dc:creator>Java蚂蚁</dc:creator>
<og:description>面试官：sychronized关键字有哪些特性？ 应聘者： 可以用来修饰方法; 可以用来修饰代码块; 可以用来修饰静态方法; 可以保证线程安全; 支持锁的重入; sychronized使用不当导致死锁</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/marsitman/p/11235552.html</dc:identifier>
</item>
<item>
<title>多个module实体类集合打一个jar包并上传至远程库 - 神牛003</title>
<link>http://www.cnblogs.com/wangrudong003/p/11235481.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangrudong003/p/11235481.html</guid>
<description>
&lt;p&gt;本章内容主要分享多个module中的实体类集合生成到一个jar包中，并且发布到远程库；这里采用maven-assembly-plugin插件的功能来操作打包，内容不长却贴近实战切值得拥有，主要节点内容如：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;多个module实体类集合打jar包&lt;/li&gt;
&lt;li&gt;jar包打入本地库&lt;/li&gt;
&lt;li data-spm-anchor-id=&quot;a2c4e.11153940.0.i3.6cc315bafVM3tJ&quot;&gt;jar包上传至远程库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先假设下我们拥有多个module，每个module中有一些接口或公用方法的参数实体和响应实体，再或者有公用枚举，此时为了合作方对接方便，我们需要吧这些个实体类、枚举、接口等集合到一个jar包中，提供给合作方使用;&lt;/p&gt;
&lt;p&gt;这里我们可以在项目工程下再创建一个空的module，里面不用包含任何代码，但是需要在pom中加入assmebly插件如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &amp;lt;plugins&amp;gt;
&lt;span&gt; 2&lt;/span&gt;             &amp;lt;plugin&amp;gt;
&lt;span&gt; 3&lt;/span&gt;                 &amp;lt;artifactId&amp;gt;maven-assembly-plugin&amp;lt;/artifactId&amp;gt;
&lt;span&gt; 4&lt;/span&gt;                 &amp;lt;version&amp;gt;&lt;span&gt;3.1&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&amp;lt;/version&amp;gt;
&lt;span&gt; 5&lt;/span&gt;                 &amp;lt;executions&amp;gt;
&lt;span&gt; 6&lt;/span&gt;                     &amp;lt;execution&amp;gt;
&lt;span&gt; 7&lt;/span&gt;                         &amp;lt;id&amp;gt;${project.artifactId}&amp;lt;/id&amp;gt;
&lt;span&gt; 8&lt;/span&gt;                         &amp;lt;phase&amp;gt;package&amp;lt;/phase&amp;gt;
&lt;span&gt; 9&lt;/span&gt;                         &amp;lt;goals&amp;gt;
&lt;span&gt;10&lt;/span&gt;                             &amp;lt;goal&amp;gt;single&amp;lt;/goal&amp;gt;
&lt;span&gt;11&lt;/span&gt;                         &amp;lt;/goals&amp;gt;
&lt;span&gt;12&lt;/span&gt;                         &amp;lt;configuration&amp;gt;
&lt;span&gt;13&lt;/span&gt;                             &amp;lt;appendAssemblyId&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/appendAssemblyId&amp;gt;
&lt;span&gt;14&lt;/span&gt;                             &amp;lt;descriptors&amp;gt;
&lt;span&gt;15&lt;/span&gt;                                 &amp;lt;descriptor&amp;gt;${project.basedir}/src/main/assembly/assembly.xml&amp;lt;/descriptor&amp;gt;
&lt;span&gt;16&lt;/span&gt;                             &amp;lt;/descriptors&amp;gt;
&lt;span&gt;17&lt;/span&gt;                         &amp;lt;/configuration&amp;gt;
&lt;span&gt;18&lt;/span&gt;                     &amp;lt;/execution&amp;gt;
&lt;span&gt;19&lt;/span&gt;                 &amp;lt;/executions&amp;gt;
&lt;span&gt;20&lt;/span&gt;             &amp;lt;/plugin&amp;gt;
&lt;span&gt;21&lt;/span&gt;         &amp;lt;/plugins&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;assmebly插件对应一个assembly.xml配置文件，该配置文件主要包含要打入的实体类，接口等的class类路径；没错我们主要通过吧class类文件加入到jar中，来完成我们开放的实体类等信息，assembly.xml文件信息如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &amp;lt;assembly xmlns=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://maven.apache.org/ASSEMBLY/2.0.0&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; xmlns:xsi=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/2001/XMLSchema-instance&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;           xsi:schemaLocation=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://maven.apache.org/ASSEMBLY/2.0.0&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;           http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.apache.org/xsd/assembly-2.0.0.xsd&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;           http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;maven.apache.org/ASSEMBLY/2.0.0 &quot;&amp;gt;&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;     &amp;lt;id&amp;gt;RELEASE&amp;lt;/id&amp;gt;
&lt;span&gt; 6&lt;/span&gt;     &amp;lt;formats&amp;gt;
&lt;span&gt; 7&lt;/span&gt;         &amp;lt;format&amp;gt;jar&amp;lt;/format&amp;gt;
&lt;span&gt; 8&lt;/span&gt;     &amp;lt;/formats&amp;gt;
&lt;span&gt; 9&lt;/span&gt;     &amp;lt;includeBaseDirectory&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/includeBaseDirectory&amp;gt;
&lt;span&gt;10&lt;/span&gt;     &amp;lt;fileSets&amp;gt;
&lt;span&gt;11&lt;/span&gt;         &amp;lt;!-- 打包项目本身编译class文件 --&amp;gt;
&lt;span&gt;12&lt;/span&gt;         &amp;lt;fileSet&amp;gt;
&lt;span&gt;13&lt;/span&gt;             &amp;lt;directory&amp;gt;${project.build.directory}/classes&amp;lt;/directory&amp;gt;
&lt;span&gt;14&lt;/span&gt;             &amp;lt;outputDirectory&amp;gt;&amp;lt;/outputDirectory&amp;gt;
&lt;span&gt;15&lt;/span&gt;         &amp;lt;/fileSet&amp;gt;
&lt;span&gt;16&lt;/span&gt;         &amp;lt;!-- api包class文件 --&amp;gt;
&lt;span&gt;17&lt;/span&gt;         &amp;lt;fileSet&amp;gt;
&lt;span&gt;18&lt;/span&gt;             &amp;lt;directory&amp;gt;${project.parent.basedir}/api/target/classes&amp;lt;/directory&amp;gt;
&lt;span&gt;19&lt;/span&gt;             &amp;lt;includes&amp;gt;
&lt;span&gt;20&lt;/span&gt;                 &amp;lt;include&amp;gt;com/kuku/api/core/provider&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*&amp;lt;/include&amp;gt;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            &amp;lt;/includes&amp;gt;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            &amp;lt;outputDirectory&amp;gt;&amp;lt;/outputDirectory&amp;gt;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        &amp;lt;/fileSet&amp;gt;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        &amp;lt;!-- domain包class文件 --&amp;gt;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        &amp;lt;fileSet&amp;gt;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;            &amp;lt;directory&amp;gt;${project.parent.basedir}/domain/target/classes&amp;lt;/directory&amp;gt;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;            &amp;lt;includes&amp;gt;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                &amp;lt;include&amp;gt;com/kuku/domain/master/**&amp;lt;/include&amp;gt;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                &amp;lt;include&amp;gt;com/kuku/domain/work/dao/**&amp;lt;/include&amp;gt;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                &amp;lt;include&amp;gt;com/kuku/domain/work/model/**&amp;lt;/include&amp;gt;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                &amp;lt;include&amp;gt;entity/**&amp;lt;/include&amp;gt;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            &amp;lt;/includes&amp;gt;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;            &amp;lt;outputDirectory&amp;gt;&amp;lt;/outputDirectory&amp;gt;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;        &amp;lt;/fileSet&amp;gt;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        &amp;lt;!-- common包class文件 --&amp;gt;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        &amp;lt;fileSet&amp;gt;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;            &amp;lt;directory&amp;gt;${project.parent.basedir}/common/target/classes&amp;lt;/directory&amp;gt;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            &amp;lt;outputDirectory&amp;gt;&amp;lt;/outputDirectory&amp;gt;
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        &amp;lt;/fileSet&amp;gt;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        &amp;lt;!-- 打包resources下的配置文件 --&amp;gt;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        &amp;lt;fileSet&amp;gt;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            &amp;lt;directory&amp;gt;${project.basedir}/src/main/resources&amp;lt;/directory&amp;gt;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;            &amp;lt;outputDirectory&amp;gt;conf&amp;lt;/outputDirectory&amp;gt;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            &amp;lt;filtered&amp;gt;true&amp;lt;/filtered&amp;gt;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            &amp;lt;includes&amp;gt;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;                &amp;lt;include&amp;gt;static/**&amp;lt;/include&amp;gt;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                &amp;lt;include&amp;gt;templates/**&amp;lt;/include&amp;gt;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                &amp;lt;include&amp;gt;*&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;*&amp;lt;/include&amp;gt;
&lt;span&gt;49&lt;/span&gt;             &amp;lt;/includes&amp;gt;
&lt;span&gt;50&lt;/span&gt;         &amp;lt;/fileSet&amp;gt;
&lt;span&gt;51&lt;/span&gt;     &amp;lt;/fileSets&amp;gt;
&lt;span&gt;52&lt;/span&gt;     &amp;lt;!--&amp;lt;dependencySets&amp;gt;--&amp;gt;
&lt;span&gt;53&lt;/span&gt;         &amp;lt;!--&amp;lt;dependencySet&amp;gt;--&amp;gt;
&lt;span&gt;54&lt;/span&gt;             &amp;lt;!--&amp;lt;useProjectArtifact&amp;gt;&lt;span&gt;false&lt;/span&gt;&amp;lt;/useProjectArtifact&amp;gt;--&amp;gt;
&lt;span&gt;55&lt;/span&gt;             &amp;lt;!--&amp;lt;outputDirectory&amp;gt;lib&amp;lt;/outputDirectory&amp;gt;--&amp;gt;
&lt;span&gt;56&lt;/span&gt;             &amp;lt;!--&amp;lt;scope&amp;gt;runtime&amp;lt;/scope&amp;gt;--&amp;gt;
&lt;span&gt;57&lt;/span&gt;         &amp;lt;!--&amp;lt;/dependencySet&amp;gt;--&amp;gt;
&lt;span&gt;58&lt;/span&gt;     &amp;lt;!--&amp;lt;/dependencySets&amp;gt;--&amp;gt;
&lt;span&gt;59&lt;/span&gt; &amp;lt;/assembly&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;来到此处我们配置就完成了，上面主要目的是去target/classes目录下查找生成的.class文件打入jar包中，具体效果就不展示了各自尝试吧。&lt;/p&gt;

&lt;p&gt;如果没有远程库或权限，可以考虑把jar包install到本地工程库，通常情况下通过mvn install即可完成；本地库路径一般在安装mvn指定，成功install后可以看到这几种文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/348819/201907/348819-20190724021457303-628101226.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;通常公司内部或组内协助完成项目，都会吧接口实体、枚举、公用的方法等打包放入公司内网的库中；假如我们有上传包到内网库的权限，可以首先配置mvn的settings.xml的servers节点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &amp;lt;servers&amp;gt;
&lt;span&gt;2&lt;/span&gt;     &amp;lt;server&amp;gt;
&lt;span&gt;3&lt;/span&gt;         &amp;lt;id&amp;gt;release&amp;lt;/id&amp;gt;
&lt;span&gt;4&lt;/span&gt;         &amp;lt;username&amp;gt;shenniu003&amp;lt;/username&amp;gt;
&lt;span&gt;5&lt;/span&gt;         &amp;lt;password&amp;gt;shenniu003&amp;lt;/password&amp;gt;
&lt;span&gt;6&lt;/span&gt;     &amp;lt;/server&amp;gt;
&lt;span&gt;7&lt;/span&gt; &amp;lt;/servers&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后在项目pom中增加如下配置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt;     &amp;lt;distributionManagement&amp;gt;
&lt;span&gt;2&lt;/span&gt;         &amp;lt;repository&amp;gt;
&lt;span&gt;3&lt;/span&gt;             &amp;lt;id&amp;gt;release&amp;lt;/id&amp;gt;
&lt;span&gt;4&lt;/span&gt;             &amp;lt;url&amp;gt;http:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;102.0.102.10/nexus/content/repositories/releases/&amp;lt;/url&amp;gt;&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;             &amp;lt;name&amp;gt;provider&amp;lt;/name&amp;gt;
&lt;span&gt;6&lt;/span&gt;         &amp;lt;/repository&amp;gt;
&lt;span&gt;7&lt;/span&gt;     &amp;lt;/distributionManagement&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;再然后执行mvn deploy命令(idea可以鼠标右键deploy选择run)，该命令会打项目的jar并上传到指定的url内网库地址上。&lt;/p&gt;
</description>
<pubDate>Tue, 23 Jul 2019 18:17:00 +0000</pubDate>
<dc:creator>神牛003</dc:creator>
<og:description>本章内容主要分享多个module中的实体类集合生成到一个jar包中，并且发布到远程库；这里采用maven-assembly-plugin插件的功能来操作打包，内容不长却贴近实战切值得拥有，主要节点内容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangrudong003/p/11235481.html</dc:identifier>
</item>
<item>
<title>.Net微信网页开发之使用微信JS-SDK自定义微信分享内容 - 追逐时光</title>
<link>http://www.cnblogs.com/Can-daydayup/p/11135983.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Can-daydayup/p/11135983.html</guid>
<description>&lt;h2&gt;第一步、微信JS-SDK的使用步骤，配置信息的生成获取讲解：&lt;/h2&gt;
&lt;p&gt;　　关于JS-SDK的使用步骤和timestamp(时间戳)，nonceStr(随机串)，signature(签名)，access_token(接口调用凭据)生成获取的详细说明在这里：&lt;a href=&quot;https://www.cnblogs.com/Can-daydayup/p/11124092.html&quot;&gt;https://www.cnblogs.com/Can-daydayup/p/11124092.html&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;第二步、调用微信JS-SDK自定义分享内容接口：&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注入权限验证配置&lt;/span&gt;
&lt;span&gt;wx.config({
    debug: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。&lt;/span&gt;
    appId: '', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，公众号的唯一标识&lt;/span&gt;
    timestamp: , &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，生成签名的时间戳&lt;/span&gt;
    nonceStr: '', &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，生成签名的随机串&lt;/span&gt;
    signature: '',&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，签名&lt;/span&gt;
    jsApiList: ['updateAppMessageShareData','updateTimelineShareData'] &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 必填，分享朋友和分享朋友圈接口列表&lt;/span&gt;
&lt;span&gt;});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义分享的内容&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; title=&quot;店铺好礼豪情大派送&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; link='xxx.xxx.com'&lt;span&gt;//&lt;/span&gt;&lt;span&gt;分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致&lt;/span&gt;
&lt;span&gt;var&lt;/span&gt; desc=&quot;好礼一起享，进店铺领取优惠券可享更多优惠哟！&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; imgUrl =&quot;图片地址&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意一定要是可以访问的，否则没有用&lt;/span&gt;


&lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化&lt;/span&gt;
wx.ready(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(){

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义“分享给朋友”及“分享到QQ”按钮的分享内容（1.4.0）&lt;/span&gt;
wx.ready(&lt;span&gt;function&lt;/span&gt; () {   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需在用户可能点击分享按钮前就先调用&lt;/span&gt;
&lt;span&gt;    wx.updateAppMessageShareData({ 
        title: title, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分享标题&lt;/span&gt;
        desc: desc, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分享描述&lt;/span&gt;
        link: link, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致&lt;/span&gt;
        imgUrl: imgUrl , &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分享图标&lt;/span&gt;
        success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置成功&lt;/span&gt;
          alert(&quot;分享成功&quot;&lt;span&gt;);
        }
    })
});


&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;自定义“分享到朋友圈”及“分享到QQ空间”按钮的分享内容（1.4.0）&lt;/span&gt;
&lt;span&gt;
wx.ready(&lt;/span&gt;&lt;span&gt;function&lt;/span&gt; () {      &lt;span&gt;//&lt;/span&gt;&lt;span&gt;需在用户可能点击分享按钮前就先调用&lt;/span&gt;
&lt;span&gt;    wx.updateTimelineShareData({ 
        title: title, &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分享标题&lt;/span&gt;
        link: link, &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分享链接，该链接域名或路径必须与当前页面对应的公众号JS安全域名一致&lt;/span&gt;
        imgUrl: imgUrl , &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 分享图标&lt;/span&gt;
        success: &lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
          &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 设置成功&lt;/span&gt;
          alert(&quot;分享成功&quot;&lt;span&gt;);
        }
    })
});&lt;br/&gt;});
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;第三步、通过点击微信右上角的按钮，找到微信分享：&lt;/h2&gt;
&lt;p&gt;注意：你在微信中无法定义事件去主动触发微信分享，需要点击微信右上角的按钮然后就能够找到微信分享。&lt;/p&gt;
&lt;p&gt;效果图，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1336199/201907/1336199-20190705011319615-429124730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 23 Jul 2019 17:14:00 +0000</pubDate>
<dc:creator>追逐时光</dc:creator>
<og:description>第一步、微信JS-SDK的使用步骤，配置信息的生成获取讲解： 关于JS-SDK的使用步骤和timestamp(时间戳)，nonceStr(随机串)，signature(签名)，access_token</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Can-daydayup/p/11135983.html</dc:identifier>
</item>
<item>
<title>简单分析线程获取ReentrantReadWriteLock 读锁的规则 - kingsleylam</title>
<link>http://www.cnblogs.com/kingsleylam/p/11235293.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kingsleylam/p/11235293.html</guid>
<description>&lt;p&gt; &lt;span&gt;&lt;strong&gt;1. 问题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;最近有同事问了我一个问题，在Java编程中，当有一条线程要获取ReentrantReadWriteLock的读锁，此时已经有其他线程获得了读锁，AQS队列里也有线程在等待写锁。由于读锁是共享锁，当前线程是马上获得读锁，还是排队？如果是马上获得读锁，那岂不是阻塞的等待写锁的线程有可能一直（或长时间）拿不到写锁（写锁饥饿）？&lt;/p&gt;
&lt;p&gt;带着这个问题，我打开读写锁的源码，来看一下JDK是怎么实现的。（注：读写锁指ReentrantReadWriteLock, 以下说到的读锁和写锁，都是指属于同一个读写锁的情况。读锁和共享锁，写锁和独占锁，在这里是同样的意思。如无特殊说明，提到的模式都是默认的非公平模式）&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2. JUC万物皆有AQS&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;2.1 读锁的实现。&lt;/p&gt;
&lt;p&gt;先来看看读锁的实现。持有一个AQS，所以说，JUC万物皆有AQS（大雾）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201907/452847-20190723220320174-499195337.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顺便提一下写锁，写锁也是类似的实现，而且传入的是同一个读写锁，那么读锁和写锁，都拥有同一个AQS，这样才能实现互相阻塞。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201907/452847-20190723220546875-802260300.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201907/452847-20190723220627004-133888699.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;读锁是共享模式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201907/452847-20190723220728575-318242553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.2 tryAcquireShared(int arg)的实现。&lt;/p&gt;
&lt;p&gt;熟悉AQS的同学就知道，共享锁的实现，AQS已经写好了流程。但留下了一个钩子，tryAcquireShared(int arg) 供各种场景实现。&lt;/p&gt;
&lt;p&gt;那么我们就来看看，读写锁里面，共享锁（读锁）是怎么实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201907/452847-20190723221418008-494706807.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201907/452847-20190723221551698-1504864227.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step1. 红框一，如果当前已经有线程持有了独占锁（即写锁），且不是当前线程持有，那么无法重入，直接返回-1，获取共享锁失败。&lt;/p&gt;
&lt;p&gt;step2. 如果step1的情况被排除，那么进行readerShouldBlock()的判断。在读写锁中，AQS有两种实现，公平和非公平模式，默认是非公平模式。&lt;/p&gt;
&lt;p&gt;也就是说，上面所说的sync变量的实际类型，可以是公平模式，也可以是非公平模式。&lt;/p&gt;
&lt;p&gt;因此，readerShouldBlock()也有公平和非公平两种不同的实现。&lt;/p&gt;
&lt;p&gt;公平模式下，只要前面有阻塞排队的节点，就返回true，表示不能抢占。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201907/452847-20190723223040986-1453489076.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;非公平模式下，看看第一个等待的阻塞节点是不是独占式的，如果是，返回true，有可能不可以抢在人家前面（为什么是有可能？要考虑可重入的场景，下面分析）。这是为了避免写锁饥饿。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201907/452847-20190723223352004-8244041.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;所以，如果readerShouldBlock()返回false，并且读锁获取的总次数不溢出，且CAS成功，说明获取共享锁成功，下面进入if块，设置一些变量，并将当前线程持有的该读锁的次数递增加1，返回成功标志。&lt;/p&gt;
&lt;p&gt;看到这里，也许你会有疑惑，仅仅是因为CAS失败，就获取共享锁失败了吗？而且，ReentrantReadWriteLock是一个可重入锁，这里也没看到有重入的地方啊。&lt;/p&gt;
&lt;p&gt;别急，如果step2失败，会进入step3，到第三个红框，进入fullTryAcquireShared(Thread current)方法。&lt;/p&gt;
&lt;p&gt;2.3  final int fullTryAcquireShared(Thread current)&lt;/p&gt;
&lt;p&gt;这个方法比较长，里面用了for(;;) 自旋CAS，为什么呢？因为CAS还是可能会失败啊……失败就得继续再尝试一把。&lt;/p&gt;
&lt;p&gt;我就贴出for(;;) 里的代码，分为两段，第一段判断是否可以尝试获取锁（与上面类似，加了重入的判断），第二段CAS和成功后的一些操作。&lt;/p&gt;
&lt;p&gt;先看第一段，判断是否可以尝试获取锁。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201907/452847-20190723224855049-1379659362.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step1. 如果有线程持有独占锁，并且不是当前线程，返回失败标志-1。如果是当前线程，由于可重入的语义，通过了判断，直接跑到第二段代码了。说明在持有独占锁的情况下可以获取共享锁（锁降级）。&lt;/p&gt;
&lt;p&gt;step2. 如果当前没有线程持有独占锁，那么再来看看熟悉的readerShouldBlock()。通过上面的分析我们知道，在公平模式下有节点在阻塞就得排队，在非公平模式下有可能不可以抢在人家前面。为什么是有可能？因为要考虑可重入的场景。&lt;/p&gt;
&lt;p&gt;如果firstReader是当前线程，或者当前线程的cachedHoldCounter变量的count不为0（表示当前线程已经持有了该共享锁），均说明当前线程已经持有共享锁，此次获取共享锁是重入，这也是允许的，可以通过判断。&lt;/p&gt;
&lt;p&gt;如果可以顺利通过上面两步判断，说明获取共享锁成功，下面开始熟悉的CAS。 &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201907/452847-20190723225817422-1946753775.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;失败了咋办？别忘记是自旋啊，外层是for(;;)，那就再来一发~~。当然还得再来一遍第一段的判断。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3. 结论&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;经过上面的分析，可以来回答我的同事的问题了。&lt;/p&gt;
&lt;p&gt;在Java编程中，当有一条线程要获取ReentrantReadWriteLock的读锁，此时已经有其他线程获得了读锁，AQS队列里也有线程在等待写锁。由于读锁是共享锁，当前线程是马上获得读锁，还是排队？如果是马上获得读锁，那岂不是阻塞的等待写锁的线程有可能一直（或长时间）拿不到写锁（写锁饥饿）？&lt;/p&gt;
&lt;p&gt;1.如果已经有线程持有独占锁&lt;/p&gt;
&lt;p&gt;1.1 该线程不是当前线程，不用想了，乖乖排队；&lt;/p&gt;
&lt;p&gt;1.2 该线程就是当前线程，重入，CAS获取共享锁；&lt;/p&gt;
&lt;p&gt;2.如果没有线程持有独占锁，检查当前线程是否需要block(readerShouldBlock方法）。&lt;/p&gt;
&lt;p&gt;block的判断，有两种模式，公平和非公平（默认模式）。如果不需要block, 必须满足：公平模式下，没有节点在AQS等待；非公平模式下，AQS第一个等待的节点不是独占式的；&lt;/p&gt;
&lt;p&gt;2.1 不需要block，可以CAS获取共享锁；&lt;/p&gt;
&lt;p&gt;2.2 需要block；&lt;/p&gt;
&lt;p&gt;2.2.1 当前线程已经持有了共享锁，重入，还是可以CAS获取共享锁；&lt;/p&gt;
&lt;p&gt;2.2.2 当前线程前没有已经持有共享锁，则获取失败，只能排队。&lt;/p&gt;

&lt;p&gt;上面是根据代码逻辑整理的，可以换为更简洁的语言。&lt;/p&gt;
&lt;p&gt;如果当前线程已经持有独占锁或共享锁（重入）或不需要block，则CAS获取共享锁；否则，排队。&lt;/p&gt;
&lt;p&gt;在问题的场景中，当前线程并没有获取到写锁或读锁，不能重入；非公平模式下AQS中第一个等待的是想要获取独占锁的节点（公平模式不赘述），必须block，所以当前线程只能排队，并不会出现阻塞的想获取写锁的节点一直拿不到写锁的情况。&lt;/p&gt;
&lt;p&gt; 为什么知道等待写锁的节点一定是第一个等待的节点呢？因为如果它前面还有节点，获取到读锁的节点会唤醒后面同样等待读锁的节点（共享锁的特点），所以等待写锁的节点，大概率是第一个节点（也有可能等待读锁的节点还没被唤醒，当然这是瞬时发生的，这种场景应该小概率吧……）。我想，这也是readerShouldBlock()要判断第一个等待节点的原因吧。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4. 举个栗子&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.khlin.my.test;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; 
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.concurrent.locks.ReentrantReadWriteLock;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; 
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RRWLockTest {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; InterruptedException {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;final&lt;/span&gt; ReentrantReadWriteLock LOCK = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReentrantReadWriteLock();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; 
&lt;span&gt;10&lt;/span&gt;         Thread reader1 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                    LOCK.readLock().lock();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     System.out.println(&quot;reader1 locked.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                     Thread.sleep(3000L&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                     System.out.println(&quot;reader1 finished.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                    e.printStackTrace();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                    LOCK.readLock().unlock();
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; 
&lt;span&gt;25&lt;/span&gt;         Thread reader2 = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                    LOCK.readLock().lock();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     System.out.println(&quot;reader2 locked.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     System.out.println(&quot;reader2 finished.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    LOCK.readLock().unlock();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt;         Thread writer = &lt;span&gt;new&lt;/span&gt; Thread(&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Runnable() {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; run() {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                    LOCK.writeLock().lock();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                     System.out.println(&quot;writer locked.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                     System.out.println(&quot;writer finished.&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 }&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                    LOCK.writeLock().unlock();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        });
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        reader1.start();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         Thread.sleep(1000L&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;        writer.start();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;         Thread.sleep(1000L&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;        reader2.start();
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;reader1获取了读锁，正在执行，随后writer来获取写锁，失败，入队等待。reader2由于writer正在等待（通过readerShouldBlock判断），无法获取读锁，入队，等待。输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201907/452847-20190724003100240-1969320457.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果把writer去掉，虽然reader1还没执行完，但reader2可以马上获得读锁，无需等待。把上面第49，50行注释掉，输出如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/452847/201907/452847-20190724003241358-671916208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 23 Jul 2019 16:38:00 +0000</pubDate>
<dc:creator>kingsleylam</dc:creator>
<og:description>1. 问题 最近有同事问了我一个问题，在Java编程中，当有一条线程要获取ReentrantReadWriteLock的读锁，此时已经有其他线程获得了读锁，AQS队列里也有线程在等待写锁。由于读锁是共</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kingsleylam/p/11235293.html</dc:identifier>
</item>
<item>
<title>Nodejs监控Apple召回计划&amp;邮件提醒 - wangmeijian</title>
<link>http://www.cnblogs.com/wangmeijian/p/11225845.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangmeijian/p/11225845.html</guid>
<description>&lt;p&gt;最近，我的13寸 MacBook Pro 2015款电池膨胀了&lt;/p&gt;
&lt;p&gt;把笔记本平放在桌面，四个脚中的前两个无法落地，笔记本盖合上之后，屏幕上会印上键盘的纹路，也就是说，笔记本C面D面变形了，已经购买超过3年，售后不给换，同年生产的15寸的MacBook Pro因为同样的问题出了电池召回计划，我想着再坚持一下，看看13寸的会不会也出召回计划&lt;/p&gt;
&lt;p&gt;Apple的召回计划全都更新在这里&lt;a href=&quot;https://support.apple.com/zh-cn/exchange_repair&quot;&gt;https://support.apple.com/zh-cn/exchange_repair&lt;/a&gt;，每天手动去查看一次，不太对得起这台笔记本，干脆写了一个爬虫监控这个页面，有最新消息就邮件通知我，对笔记本来说，也算是“自己的事情自己做”&lt;/p&gt;
&lt;p&gt;首先利用axios加载页面，cheerio负责解析，然后找到最新一篇召回计划的标题和链接&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
import axios from 'axios'&lt;span&gt;;
import async from &lt;/span&gt;'async'&lt;span&gt;;
import cheerio from &lt;/span&gt;'cheerio'&lt;span&gt;;

const URL &lt;/span&gt;= 'https://support.apple.com/zh-cn/exchange_repair'&lt;span&gt;;
const homePage &lt;/span&gt;=&lt;span&gt; await axios.get(URL);
const $ &lt;/span&gt;=&lt;span&gt; cheerio.load(homePage.data);
const firstRepair &lt;/span&gt;= $('.as-columns .table-responsive .icon-chevronright'&lt;span&gt;);
const firstTitle &lt;/span&gt;= firstRepair.eq(0&lt;span&gt;).text();
const firstHref &lt;/span&gt;= firstRepair.closest('a').attr('href');
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;比对标题的开头，是不是以“13 英寸 MacBook Pro”开头的，如果是，用nodemailer以我qq邮箱的身份发邮件给我（发到我的gmail邮箱）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import nodemailer from 'nodemailer'&lt;span&gt;;&lt;br/&gt;import path from 'path';&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
const reg = /^13 英寸 MacBook Pro/&lt;span&gt;g;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建传输器对象&lt;/span&gt;
let transporter &lt;/span&gt;=&lt;span&gt; nodemailer.createTransport({
    service: &lt;/span&gt;'qq'&lt;span&gt;,
    port: &lt;/span&gt;465&lt;span&gt;,
    secureConnection: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
    auth: {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发件人地址&lt;/span&gt;
        user: 'xxxx@qq.com'&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; SMTP授权码&lt;/span&gt;
        pass: 'xxxx'&lt;span&gt;
    }
});

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有针对MacBook Pro 13寸的新召回计划，邮件我&lt;/span&gt;
&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (reg.test(firstTitle)) {
    let mailOptions &lt;/span&gt;=&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发件人&lt;/span&gt;
        from: '&quot;【我的定时任务】&quot;xxxx@qq.com'&lt;span&gt;, 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 收件人&lt;/span&gt;
        to: 'wangmeijian2016@gmail.com'&lt;span&gt;, 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 邮件主题&lt;/span&gt;
        subject: '有针对MacBook Pro 13寸的新召回计划了'&lt;span&gt;, 
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送text或者html格式&lt;/span&gt;
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; text: 'Hello world?',&lt;/span&gt;
        html: `&amp;lt;div&amp;gt;
            &amp;lt;h3&amp;gt;&amp;lt;a style=&quot;color: black&quot; href=&quot;https://support.apple.com${firstHref}&quot; target=&quot;_blank&quot;&amp;gt;${firstTitle}&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;
            &amp;lt;img src=&quot;cid:01&quot; /&amp;gt;
        &amp;lt;/div&amp;gt;`,
        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 附件&lt;/span&gt;
&lt;span&gt;        attachments: [
            {
                filename: &lt;/span&gt;'Apple.png'&lt;span&gt;,
                path: path.resolve(__dirname, &lt;/span&gt;'Apple.png'&lt;span&gt;),
                cid: &lt;/span&gt;'01'&lt;span&gt;,
            }
        ]
    };

    transporter.sendMail(mailOptions, (err, info) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; console.log(err);
        }
    });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中transporter里的pass不是邮箱密码，而是SMTP授权码，就是授权nodejs用我的qq邮箱发邮件，在qq邮箱【设置】-【账户】里面开启SMTP服务并获取SMTP授权码&lt;/p&gt;
&lt;p&gt;你可能注意到我在邮件HTML模板里加入了一张图片Apple.png，并且这张图片的来源就是附件，给附件加个cid就可以在模板里引用了，图片是邮件HTML模板唯一可以引用的外部资源，其他包括字体文件、视频、js文件等都不可引用&lt;/p&gt;
&lt;p&gt;另外需要注意的是，我将召回计划的标题颜色设置为黑色，用的是行间样式，是考虑到两个问题&lt;/p&gt;
&lt;p&gt;一是兼容性问题，部分邮箱客户端会过滤掉style标签&lt;/p&gt;
&lt;p&gt;二是行间样式权重高，web版gmail会给a链接增加一个样式类，设置链接的字体颜色为蓝色，我利用样式权重高的特性，将浏览器给的样式覆盖，从而达到我要的效果&lt;/p&gt;
&lt;p&gt;做了个测试，字体颜色前后对比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664733/201907/664733-20190724000754489-1574752624.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多类似兼容性去&lt;a href=&quot;https://www.campaignmonitor.com/css/box-model/border-bottom/&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;查询 &lt;/p&gt;
&lt;p&gt;mailOptions还有更多配置，如CC抄送等，更多配置请到&lt;a href=&quot;https://nodemailer.com/message/&quot; target=&quot;_blank&quot;&gt;这里&lt;/a&gt;查看&lt;/p&gt;
&lt;p&gt;回到正题，我的需求是每天自动查看一次，此处需要一个定时任务，交给node-schedule&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
import schedule from 'node-schedule'&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每天上午9点执行&lt;/span&gt;
schedule.scheduleJob('0 9 * * *', () =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每天到点干某事&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;综上，完整代码如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * 定时查看Apple召回计划&amp;amp;邮件提醒
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
import schedule from &lt;/span&gt;'node-schedule'&lt;span&gt;;
import axios from &lt;/span&gt;'axios'&lt;span&gt;;
import async from &lt;/span&gt;'async'&lt;span&gt;;
import cheerio from &lt;/span&gt;'cheerio'&lt;span&gt;;
import nodemailer from &lt;/span&gt;'nodemailer'&lt;span&gt;;
import dayjs from &lt;/span&gt;'dayjs'&lt;span&gt;;
import path from &lt;/span&gt;'path'&lt;span&gt;;

const formatString &lt;/span&gt;= 'YYYY-MM-DD HH:mm'&lt;span&gt;;
const timestamp &lt;/span&gt;= () =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; dayjs().format(formatString);
}
const reptile &lt;/span&gt;= async () =&amp;gt;&lt;span&gt; {
    const URL &lt;/span&gt;= 'https://support.apple.com/zh-cn/exchange_repair'&lt;span&gt;;
    const homePage &lt;/span&gt;=&lt;span&gt; await axios.get(URL);
    const $ &lt;/span&gt;=&lt;span&gt; cheerio.load(homePage.data);
    const firstRepair &lt;/span&gt;= $('.as-columns .table-responsive .icon-chevronright'&lt;span&gt;);
    const firstTitle &lt;/span&gt;= firstRepair.eq(0&lt;span&gt;).text();
    const firstHref &lt;/span&gt;= firstRepair.closest('a').attr('href'&lt;span&gt;);
    const reg &lt;/span&gt;= /^13 英寸 MacBook Pro/&lt;span&gt;g;

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 创建传输器对象&lt;/span&gt;
    let transporter =&lt;span&gt; nodemailer.createTransport({
        service: &lt;/span&gt;'qq'&lt;span&gt;,
        port: &lt;/span&gt;465&lt;span&gt;,
        secureConnection: &lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
        auth: {
            user: &lt;/span&gt;'xxx@qq.com'&lt;span&gt;,
            pass: &lt;/span&gt;'xxx'&lt;span&gt;
        }
    });

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 有针对MacBook Pro 13寸的新召回计划，邮件我&lt;/span&gt;
    &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (reg.test(firstTitle)) {
        let mailOptions &lt;/span&gt;=&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发件人&lt;/span&gt;
            from: '&quot;【我的定时任务】&quot;xxx@qq.com'&lt;span&gt;, 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 收件人&lt;/span&gt;
            to: 'wangmeijian2016@gmail.com'&lt;span&gt;, 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 邮件主题&lt;/span&gt;
            subject: '有针对MacBook Pro 13寸的新召回计划了'&lt;span&gt;, 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 发送text或者html格式&lt;/span&gt;
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; text: 'Hello world?',&lt;/span&gt;
            html: `&amp;lt;div&amp;gt;
                &amp;lt;h3&amp;gt;&amp;lt;a style=&quot;color: black&quot; href=&quot;https://support.apple.com${firstHref}&quot; target=&quot;_blank&quot;&amp;gt;${firstTitle}&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;
                &amp;lt;img src=&quot;cid:01&quot; /&amp;gt;
            &amp;lt;/div&amp;gt;`,
            &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 附件&lt;/span&gt;
&lt;span&gt;            attachments: [
                {
                    filename: &lt;/span&gt;'Apple.png'&lt;span&gt;,
                    path: path.resolve(__dirname, &lt;/span&gt;'Apple.png'&lt;span&gt;),
                    cid: &lt;/span&gt;'01'&lt;span&gt;,
                }
            ]
        };

        transporter.sendMail(mailOptions, (err, info) &lt;/span&gt;=&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (err) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; console.log(err);
            } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
                console.log(`${timestamp()}：邮件已发送&lt;/span&gt;~&lt;span&gt;`);
            }
        });
    }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;{
        console.log(`${timestamp()}：Apple暂无新召回计划&lt;/span&gt;~&lt;span&gt;`);
    }
};
reptile();
console.log(`${timestamp()}：定时任务执行中……`);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 每天上午9点执行&lt;/span&gt;
schedule.scheduleJob('0 9 * * *', () =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        reptile();
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (err) {
        console.log(err);
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于nodejs不能直接执行ES6，需要配置一下环境&lt;/p&gt;
&lt;p&gt;一、安装babel-node&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm i -g @babel/core @babel/node
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;二、安装 presets 并配置 .babelrc 文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm i @babel/preset-env --save-dev
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置.babelrc &lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
  &lt;/span&gt;&quot;presets&quot;: [ &quot;@babel/preset-env&quot;&lt;span&gt; ]
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;OK，可以执行了&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
babel-node xxx.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/664733/201907/664733-20190724000326005-1330352609.png&quot; alt=&quot;&quot; width=&quot;500&quot;/&gt;&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;

&lt;p&gt;本文地址：&lt;a id=&quot;Editor_Edit_hlEntryLink&quot; title=&quot;view: 我的MacBook Pro电池膨胀了&quot; href=&quot;https://www.cnblogs.com/wangmeijian/p/11225845.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/wangmeijian/p/11225845.html&lt;/a&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 23 Jul 2019 16:24:00 +0000</pubDate>
<dc:creator>wangmeijian</dc:creator>
<og:description>最近，我的13寸 MacBook Pro 2015款电池膨胀了 把笔记本平放在桌面，四个脚中的前两个无法落地，笔记本盖合上之后，屏幕上会印上键盘的纹路，也就是说，笔记本C面D面变形了，已经购买超</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wangmeijian/p/11225845.html</dc:identifier>
</item>
</channel>
</rss>