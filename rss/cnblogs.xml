<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>数据挖掘入门系列教程（十）之k-means算法 - 段小辉</title>
<link>http://www.cnblogs.com/xiaohuiduan/p/12758121.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohuiduan/p/12758121.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;这一次我们来讲一下比较轻松简单的数据挖掘的算法——K-Means算法。K-Means算法是一种&lt;strong&gt;无监督&lt;/strong&gt;的聚类算法。什么叫无监督呢？就是对于训练集的数据，在训练的过程中，并没有告诉训练算法某一个数据属于哪一个类别。对于K-Means算法来说，他就是通过某一些骚操作，将一堆“相似”的数据聚集在一起然后当作同一个类别。例如下图：最后将数据聚集成了3个类别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200423014021827-1244420376.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;p&gt;K-Means算法中的&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;就是代表类别的个数，它可以根据用户的需求进行确定，也可以使用某一些方法进行确定（比如说elbow method）。&lt;/p&gt;
&lt;h2 id=&quot;算法&quot;&gt;算法&lt;/h2&gt;
&lt;h3 id=&quot;算法简介&quot;&gt;算法简介&lt;/h3&gt;
&lt;p&gt;对于给定的样本集&lt;span class=&quot;math inline&quot;&gt;\(D=\left\{\boldsymbol{x}_{1}, \boldsymbol{x}_{2}, \ldots, \boldsymbol{x}_{m}\right\}\)&lt;/span&gt;，k-means算法针对聚类所得到的簇为&lt;span class=&quot;math inline&quot;&gt;\(\mathcal{C}=\left\{C_{1}, C_{2}, \ldots, C_{k}\right\}\)&lt;/span&gt;，则划分的最小化平方误差为：&lt;/p&gt;
&lt;p&gt;\[\begin{equation} E=\sum_{i=1}^{k} \sum_{\boldsymbol{x} \in C_{i}}\left\|\boldsymbol{x}-\boldsymbol{\mu}_{i}\right\|_{2}^{2} \\ 其中\boldsymbol{\mu}_{i}=\frac{1}{\left|C_{i}\right|} \sum_{\boldsymbol{x} \in C_{i}}x \end{equation} \]&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;越小则表示数据集样本中相似度越高。我们想得到最小的&lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;，但是直接求解并不容易，因此我们采用启发式算法进行求解。&lt;/p&gt;
&lt;h3 id=&quot;算法流程&quot;&gt;算法流程&lt;/h3&gt;
&lt;p&gt;算法的流程很简单，如下所示：&lt;/p&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;选取初始化质心&lt;/p&gt;
&lt;p&gt;首先假如我们有如下的数据集，我们随机选取&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个点（称之为质心，这里&lt;span class=&quot;math inline&quot;&gt;\(k =3\)&lt;/span&gt;），也就是下图中红绿蓝三个点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200423014022039-619565911.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot; readability=&quot;6.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;计算数据集样本中其它的点到质心的距离，然后选取最近质心的类别作为自己的类别。&lt;/p&gt;
&lt;p&gt;我们可以将其理解为“近朱者赤近墨者黑”，对于样本点来说，哪个质心离我近，我就认谁做“爸爸”。同时对于“距离”，有很多种计算方式，比如说“欧氏距离”，“曼哈顿距离”等等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200423014022277-159414124.png&quot; alt=&quot;img&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;重新计算质心&lt;/p&gt;
&lt;p&gt;通过上面的步骤我们就得到了3个簇，然后我们从这三个簇中重新选举质心，也就是我们选举出一个新的“爸爸”，这个&quot;爸爸&quot;可以为样本点（比如说红点），也可以不是样本中的点（比如说蓝点和绿色点）。选举方式很简单，就是计算每一个簇中样本点的平均值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200423014022535-12926835.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;重新进行划分&lt;/p&gt;
&lt;p&gt;按照第二步的计算方法重新对样本进行划分。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200423014022752-836847269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;重复第3，4步骤，直到达到某一个阈值&lt;/p&gt;
&lt;p&gt;这个阈值可以是迭代的轮数，也可以是当质心不发生改变的时候或者质心变化的幅度小于某一个值得时候停止迭代。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里引用《西瓜书》中得算法步骤：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200423014023049-1512577407.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;算法gif图如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200423014023460-1075450392.gif&quot; alt=&quot;gif of k-means&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;算法的优化&quot;&gt;算法的优化&lt;/h2&gt;
&lt;p&gt;K-Means算法的步骤就如上所示，但是实际上里面还有一些细节可以进行优化。&lt;/p&gt;
&lt;h3 id=&quot;k-means算法&quot;&gt;K-Means++算法&lt;/h3&gt;
&lt;p&gt;在上面我们讨论了k-means算法的流程，当时我们可以仔细想一想，如果在第一步初始化质心的步骤中，如果质心选择的位置不是特别的好，比如说三个点挨在一起，那这样，我们必定会需要使用大量的迭代步骤。同时它还可能影响着最后簇的结果。为了解决这个误差，我们可以选择一组随机的初始化质心，然后选取最小的&lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;值（也就是是最小化平方误差最小）。&lt;/p&gt;
&lt;p&gt;当然，我们也有其他的方法。&lt;/p&gt;
&lt;p&gt;K-Means++算法与上面传统的K-means算法不同的点就在于它使用了一定的方法使得算法中的第一步（初始化质心）变得比较合理，而不是随机的选择质心。算法的步骤如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;从输入样本中随机选择一个样本作为质心&lt;span class=&quot;math inline&quot;&gt;\(\mu_1\)&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;对于数据集中的每一个样本&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;，计算它他与已选择的质心&lt;span class=&quot;math inline&quot;&gt;\(\mu_r\)&lt;/span&gt;的距离，设样本&lt;span class=&quot;math inline&quot;&gt;\(x_i\)&lt;/span&gt;到质心的距离为&lt;span class=&quot;math inline&quot;&gt;\(D(x_i)\)&lt;/span&gt; 【这个距离肯定是离质心的最短距离】，因此&lt;span class=&quot;math inline&quot;&gt;\(D(x_i) = arg\;min||x_i- \mu_r||_2^2\;\;r=1,2,...k_{selected}\)&lt;/span&gt;。&lt;/li&gt;
&lt;li&gt;选择一个新的数据样本作为新的质心，选择的原则为：&lt;span class=&quot;math inline&quot;&gt;\(D(x_i)\)&lt;/span&gt;越大，被选择的概率也就越大。&lt;/li&gt;
&lt;li&gt;重复2，3步骤直到选取出&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个质心。&lt;/li&gt;
&lt;li&gt;运行传统k-means算法中的第2，3，4，5步。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;K-Means++实际上就是改变了初始化质心的步骤，其他的步骤并没有发生改变。&lt;/p&gt;
&lt;h3 id=&quot;k-means算法中距离计算的优化&quot;&gt;K-Means算法中距离计算的优化&lt;/h3&gt;
&lt;p&gt;假设我们有&lt;span class=&quot;math inline&quot;&gt;\(n+k\)&lt;/span&gt;个样本（其中有&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个质心），毋庸置疑，我们需要计算&lt;span class=&quot;math inline&quot;&gt;\(n\)&lt;/span&gt;个样本到&lt;span class=&quot;math inline&quot;&gt;\(k\)&lt;/span&gt;个质心的距离。这一步我们可以稍微的简化一下。运用三角形两边之和大于第三边我们可以知道：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200423014023849-2011918069.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;\[a+b \gt c\\ a - b \lt c \\ 因此则有：\\ b \geq max\{0,a - c\} \\ 若2a \le c,则有\\ a \le b \\ \]&lt;/p&gt;
&lt;p&gt;利用上面的这两条规矩，我们就可以在一定程度上简化计算。&lt;/p&gt;
&lt;h2 id=&quot;k值的确定&quot;&gt;K值的确定&lt;/h2&gt;
&lt;p&gt;前面我们说过&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;值代表着簇数，我们可以按照需求来给定，也可以通过计算的方法给一个比较合理的&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;值。下面就来介绍一下“elbow method”来确定合理的&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;值，关于更多的方法，可以参考一下&lt;a href=&quot;https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set&quot;&gt;维基百科&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;elbow-method&quot;&gt;Elbow Method&lt;/h3&gt;
&lt;p&gt;Elbow Method原理很简单，我们给定&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;的一个范围，比如说是从0~10，然后我们分别计算每一个K值对应的SSE，也就是前面的最小化平方误差&lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;，然后我们再将每一个&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;值对应的SSE画出来。可以很简单的知道，随着&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;值的增大，SSE会趋向于0（假如每一个样本点都是质心，那么对应的距离&lt;span class=&quot;math inline&quot;&gt;\(E\)&lt;/span&gt;就是0了）。我们往往希望得到一个较小的SSE，同时保证&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;值也比较小。&lt;/p&gt;
&lt;p&gt;我们可以将&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;值对应的SSE图看成一个手臂，则我们选取的&lt;span class=&quot;math inline&quot;&gt;\(K\)&lt;/span&gt;的地方就是“肘（elbow）”这个地方，这里是拐弯最大的地方。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200423014024079-111386207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;基于sklearn的k-means算法使用&quot;&gt;基于sklearn的K-Means算法使用&lt;/h2&gt;
&lt;h3 id=&quot;产生数据集&quot;&gt;产生数据集&lt;/h3&gt;
&lt;p&gt;首先的首先，我们需要一个数据集，这里我们使用sklearn中的&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.datasets.make_blobs.html&quot;&gt;make_blobs&lt;/a&gt;来生成各向同性高斯团簇。然后再将数据进行画图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import matplotlib.pyplot as plt
import sklearn.datasets as ds
import matplotlib.colors
# 数据集的个数
data_num = 1000
# k值，同时也是生成数据集的中心点
k_num  = 4

# 生成聚类数据，默认n_features为二，代表二维数据，centers表示生成数据集的中心点个数，random_state随机种子
data,y=ds.make_blobs(n_samples=data_num,centers=k_num,random_state=0)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;data&lt;/code&gt;为二维坐标，&lt;code&gt;y&lt;/code&gt;为数据标签，从0到3。画图代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;# 不同的数据簇用不同的颜色表示
data_colors = matplotlib.colors.ListedColormap(['red','blue','yellow','Cyan'])
# data为二维数据
plt.scatter(data[:,0],data[:,1],c=y,cmap=data_colors)
plt.title(&quot;orginal data&quot;)
plt.grid()
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;画图如下所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200423014024387-816219013.png&quot; alt=&quot;k-means数据集&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用k-means&quot;&gt;使用k-means&lt;/h3&gt;
&lt;p&gt;我们可以使用cluster包下的&lt;a href=&quot;https://scikit-learn.org/stable/modules/generated/sklearn.cluster.KMeans.html?highlight=k%20means#sklearn.cluster.KMeans&quot;&gt;KMeans&lt;/a&gt;来使用k-means算法，具体参数可以看官方文档。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;'''
sklearn.cluster.KMeans(
        n_clusters=8, 
        init='k-means++', 
        n_init=10, 
        max_iter=300, 
        tol=0.0001, 
        precompute_distances='auto', 
        verbose=0, 
        random_state=None, 
        copy_x=True, 
        n_jobs=1, 
        algorithm='auto' )
参数说明：
(1)n_clusters:簇的个数，也就是k值
(2)init: 初始簇中心的方式，可以为k-means++,也可以为random
(3)n_init: k-means算法在不同随机质心情况下迭代的次数，最后的结果会输出最好的结果
(4)max_iter: k-means算法最大的迭代次数
(5)tol: 关于收敛的相对公差
(8)random_state: 初始化质心的随机种子
(10)n_jobs: 并行工作，-1代表使用所有的处理器
'''
from sklearn.cluster import KMeans
model=KMeans(n_clusters=k_num,init='k-means++')
# 训练
model.fit(data)
# 分类预测
y_pre= model.predict(data)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们可以将预测分类结果画出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;plt.scatter(data[:,0],data[:,1],c=y_pre,cmap=data_colors)
plt.title(&quot;k-means' result&quot;)
plt.grid()
plt.show()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200423014024661-582716643.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;当然，k-means对于某一些分类任务还是比较困难，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1439869/202004/1439869-20200423014025001-1617669862.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显，我们应该将数据分成内圈和外圈，但是呢，使用k-means算法后，将数据集分成了上下两个部分，这样肯定是不对的。&lt;/p&gt;
&lt;p&gt;总的来说，k-means算法还是比较简单的，没有什么复杂的地方，也易于实现。&lt;/p&gt;
&lt;p&gt;项目地址：&lt;a href=&quot;https://github.com/xiaohuiduan/data_mining/tree/master/k-means&quot;&gt;Github&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;参考&quot;&gt;参考&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/K-means_clustering&quot;&gt;k-means clustering&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;《西瓜书》&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/pinard/p/6164214.html&quot;&gt;K-Means聚类算法原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Determining_the_number_of_clusters_in_a_data_set&quot;&gt;Determining the number of clusters in a data set&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Elbow_method_(clustering)&quot;&gt;elbow method&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description>
<pubDate>Wed, 22 Apr 2020 17:44:00 +0000</pubDate>
<dc:creator>段小辉</dc:creator>
<og:description>简介 这一次我们来讲一下比较轻松简单的数据挖掘的算法——K Means算法。K Means算法是一种 无监督 的聚类算法。什么叫无监督呢？就是对于训练集的数据，在训练的过程中，并没有告诉训练算法某一个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiaohuiduan/p/12758121.html</dc:identifier>
</item>
<item>
<title>SpringBoot全局异常处理与定制404页面 - 小鱼吃猫</title>
<link>http://www.cnblogs.com/Lyn4ever/p/12757947.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lyn4ever/p/12757947.html</guid>
<description>&lt;p&gt;使用SpringBoot创建的web项目中，当我们请求的页面不存在(http状态码为404)，或者器发生异常(http状态码一般为500)时，SpringBoot就会给我们返回错误信息。 也就是说，在SpringBoot的web项目中，会自动创建一个/error的错误接口，来返回错误信息。但是针对不同的访问方式，会有以下两种不同的返回信息。这主要取决于你访问时的http头部信息的```Accept```这个值来指定你可以接收的类型有哪些 * 使用浏览器访问时的头信息及其返回结果&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;156&quot;&gt;
&lt;h2 id=&quot;一、错误处理原理分析&quot;&gt;一、错误处理原理分析&lt;/h2&gt;
&lt;p&gt;使用SpringBoot创建的web项目中，当我们请求的页面不存在(http状态码为404)，或者器发生异常(http状态码一般为500)时，SpringBoot就会给我们返回错误信息。&lt;/p&gt;
&lt;p&gt;也就是说，在SpringBoot的web项目中，会自动创建一个/error的错误接口，来返回错误信息。但是针对不同的访问方式，会有以下两种不同的返回信息。这主要取决于你访问时的http头部信息的&lt;code&gt;Accept&lt;/code&gt;这个值来指定你可以接收的类型有哪些&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用浏览器访问时的头信息及其返回结果&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;Accept: text/html
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200422215925.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用其他设备，如手机客户端等访问时头部信息及其返回结果（一般是在前后端分离的架构中）&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-Accept:&quot;&gt;Accept: */*
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200422215908.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二、进行错误处理&quot;&gt;二、进行错误处理&lt;/h2&gt;
&lt;p&gt;处理异常主要有两种方式：&lt;/p&gt;
&lt;h3 id=&quot;1-使用springboot的自动配置原理进行异常处理&quot;&gt;1. 使用SpringBoot的自动配置原理进行异常处理&lt;/h3&gt;
&lt;p&gt;SpringBoot自动配置了一个类&lt;code&gt;ErrorMvcAutoConfiguration&lt;/code&gt;来处理处理异常，有兴趣的可以去看一下，然后在这个类中定义一个错误的BasicErrorController类，主要代码有如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Controller
@RequestMapping({&quot;${server.error.path:${error.path:/error}}&quot;})
public class BasicErrorController extends AbstractErrorController {

        /**
         * 错误的页面响应 
         */
    @RequestMapping(produces = {&quot;text/html&quot;})
    public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {
        HttpStatus status = this.getStatus(request);
        Map&amp;lt;String, Object&amp;gt; model = Collections.unmodifiableMap(this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.TEXT_HTML)));
        response.setStatus(status.value());
        // 得到一个modelAndView对象
        ModelAndView modelAndView = this.resolveErrorView(request, response, status, model);
        return modelAndView != null ? modelAndView : new ModelAndView(&quot;error&quot;, model);
    }
                
  /**
   * 错误的json响应
   */
    @RequestMapping
    public ResponseEntity&amp;lt;Map&amp;lt;String, Object&amp;gt;&amp;gt; error(HttpServletRequest request) {
        HttpStatus status = this.getStatus(request);
        if (status == HttpStatus.NO_CONTENT) {
            return new ResponseEntity(status);
        } else {
            Map&amp;lt;String, Object&amp;gt; body = this.getErrorAttributes(request, this.isIncludeStackTrace(request, MediaType.ALL));
            return new ResponseEntity(body, status);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;多的代码就不深究了，感兴趣的可以去看一下。上边的代码也就是说，针对不同的请求方式，会返回不同的结果，其关键在于 &lt;code&gt;@RequestMapping&lt;/code&gt;注解的&lt;code&gt;produces = {&quot;text/html&quot;}&lt;/code&gt;属性上&lt;/p&gt;
&lt;h4 id=&quot;1）、返回一个错误页面，如404、500等。&quot;&gt;1）、返回一个错误页面，如404、500等。&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;有模板引擎的情况（可以用于渲染页面）&quot;&gt;有模板引擎的情况（可以用于渲染页面）&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;项目中使用的了模板引擎，如：thymeleaf 、freemarker等做为页面的渲染时。在templates创建/error文件夹并添加错误的状态码对应的.html文件，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200422225905.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这里的404和500就是确定的错误状态码，而4xx表示其他的4开头的错误，如400，401等。当然可以为每一个状态码都设置对应的错误页面，但是这样做，并没有什么好处，所以就直接使用4xx.html这样的泛指代替了。&lt;/p&gt;
&lt;p&gt;可以在我们错误页面中获取到如下信息（就是ModelAndView对象中的内容）：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;字段名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;timstamp&lt;/td&gt;
&lt;td&gt;时间戳&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;status&lt;/td&gt;
&lt;td&gt;错误状态码&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;error&lt;/td&gt;
&lt;td&gt;错误提示&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;exception&lt;/td&gt;
&lt;td&gt;异常对象&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;message&lt;/td&gt;
&lt;td&gt;异常消息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;path&lt;/td&gt;
&lt;td&gt;页面路径&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;细心的小伙伴会发现，这个其实就是当你用手机请求时返回的json内容&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如：在代码中加入上边信息，然后在在后端写一个错误代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@RequestMapping(&quot;haserror&quot;)
@ResponseBody
public Object myError(){
  int i =10/0;
  return &quot;something is error&quot;;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;这是一个错误页面：
&amp;lt;ul&amp;gt;
    &amp;lt;li&amp;gt;错误状态码：[[${status}]]&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;错误消息：[[${error}]]&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;异常对象：[[${exception}]]&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;异常消息：[[${message}]]&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;当前时间：[[${timestamp}]]&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200422231618.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;h5 id=&quot;没有模板引擎的情况&quot;&gt;没有模板引擎的情况&lt;/h5&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当项目中没有使用模板引擎的时候，就将整个error文件夹移到static文件夹下就可以了。&lt;/p&gt;
&lt;p&gt;不过此时并不能获取上边的那些信息了，因为这本就是静态资源，没有模板引擎进行渲染&lt;/p&gt;
&lt;h4 id=&quot;2）、返回对应的json串&quot;&gt;2）、返回对应的json串&lt;/h4&gt;
&lt;p&gt;这个并没有什么好说的，返回的就是一个json字符串。格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
&quot;timestamp&quot;: &quot;2020-04-22T16:13:37.506+0000&quot;,
&quot;status&quot;: 500,
&quot;error&quot;: &quot;Internal Server Error&quot;,
&quot;message&quot;: &quot;/ by zero&quot;,
&quot;path&quot;: &quot;/hello/haserror&quot;,
&quot;reason&quot;: &quot;完了，你写的代码又产生了一次线上事故&quot;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3）、自定义页面返回信息&quot;&gt;3）、自定义页面返回信息&lt;/h4&gt;
&lt;p&gt;这才是最重要的内容，因为这个信息不仅是做为json返回的，也是可以在上边的错误页面中拿到，也可以直接返回一个json。其实也很简单，就是在Spring容器中添加一个&lt;code&gt;ErrorAttributes&lt;/code&gt;对象就可以了，这里我选择继承它的一个子类。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Component
public class MyErrorAttributes extends DefaultErrorAttributes {
    @Override
    public Map&amp;lt;String, Object&amp;gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) {
        //调用父类的方法，会自动获取内置的那些属性，如果你不想要，可以不调用这个
        Map&amp;lt;String, Object&amp;gt; errorAttributes = super.getErrorAttributes(webRequest, includeStackTrace);

        //添加自定义的属性
        errorAttributes.put(&quot;reason&quot;,&quot;完了，你写的代码又产生了一次线上事故&quot;);
        // 你可以看一下这个方法的参数webRequest这个对象，我相信你肯定能发现好东西

        return errorAttributes;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这就可以了，用两种请求方式分别测试一个我们的这个自定义属性是否可用：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/lyn4ever/picgo-img/raw/master/img/20200422234555.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-使用aop的异常通知进行处理（推荐）&quot;&gt;2. 使用AOP的异常通知进行处理（推荐）&lt;/h3&gt;
&lt;p&gt;它的原理就是获取一个全局的异常通知，然后进行处理。我们只需要在项目中写下边代码就可以了（其实上边也只是写了一个自定义异常信息的类）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@ControllerAdvice
public class ErrroAcvice {

    /**
     * 全局捕获异常的切面类
     * @param request 请求对象，可不传
     * @param response 响应对象，可不传
     * @param e 异常类(这个要和你当前捕获的异常类是同一个)
     */
    @ExceptionHandler(Exception.class) //也可以只对一个类进行捕获
    public void errorHandler(HttpServletRequest request, HttpServletResponse response,Exception e){
        /*
         * You can do everything you want to do
         * 这里你拿到了request和response对象，你可以做任何你想做的事
         * 比如：
         *      1.用request从头信息中拿到Accept来判断是请求方可接收的类型从而进行第一个方法的判断
         *      2.如果你也想返回一个页面，使用response对象进行重定向到自己的错误页面就可以了
         *  3.你甚至还拿到了异常对象
         */
      
        String accept = request.getHeader(&quot;Accept&quot;);
                                // 根据这个字符串来判断做出什么响应     
      
        try {
            response.setStatus(500);
            response.getWriter().write(&quot;hello&quot;);
        } catch (IOException ex) {
            ex.printStackTrace();
        }
      
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3-两种方法对比：&quot;&gt;3. 两种方法对比：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;第一种方法，就是在当前项目中放置一些错误状态码的页面让SpringBoot去查找。也支持自定义返回的错误信息&lt;/li&gt;
&lt;li&gt;第二种方法，就是直接使用AOP的思想，进行异常通知处理，自由性很大。&lt;/li&gt;
&lt;li&gt;我个人建议使用第二种方法，因为自由度很高，可以根据自己的业务逻辑进行随时改变，而且还有一个很大的用处。下一篇文章会有个很好的例子&lt;/li&gt;
&lt;li&gt;使用了第二种方式后，通过第一种方式放置的错误页面和自定义错误信息全部失效&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;三、代码地址：&quot;&gt;三、代码地址：&lt;/h3&gt;
&lt;p&gt;关注微信公众号:小鱼与Java，后台回复&quot;2000&quot;获取&lt;br/&gt;&lt;img src=&quot;https://lyn4ever.gitee.io/img/wx/gzh2.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Wed, 22 Apr 2020 16:16:00 +0000</pubDate>
<dc:creator>小鱼吃猫</dc:creator>
<og:description>使用SpringBoot创建的web项目中，当我们请求的页面不存在(http状态码为404)，或者器发生异常(http状态码一般为500)时，SpringBoot就会给我们返回错误信息。  也就是说，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Lyn4ever/p/12757947.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 WebGL 的高炉炼铁厂可视化系统 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/12753451.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/12753451.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421030641253-971646176.gif&quot; class=&quot;desc_img&quot;/&gt; 在当今工业4.0 新时代的推动下，不仅迎来了 工业互联网 的发展，还开启了 5G 时代的新次元。而伴随着带宽的提升，网络信息飞速发展，能源管控上与实时预警在工业互联网中也占着举足轻重的地位，而对于高炉炼铁的发展上来看，目前已完成国内260座高炉的数字化和智能化落地，并推动炼铁大数据平台在俄罗斯、越南、伊朗、印尼等“一带一路”国家钢铁企业中应用，充分体现了高炉智能化大屏产业应运而生。我们将使用 Hightopo（以下简称 HT ）的 HT for Web 产品上的 web 组态跟大家介绍一下通过 2/3D 融合搭建的高炉炼铁厂可视化系统。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;143.61481009727&quot;&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      在当今 &lt;strong&gt;工业4.0 &lt;/strong&gt;新时代的推动下，不仅迎来了 &lt;strong&gt;工业互联网 &lt;/strong&gt;的发展，还开启了 &lt;strong&gt;5G&lt;/strong&gt; 时代的新次元。而伴随着带宽的提升，网络信息飞速发展，能源管控上与实时预警在工业互联网中也占着举足轻重的地位，而对于高炉炼铁的发展上来看，目前已完成国内260座高炉的数字化和智能化落地，并推动炼铁大数据平台在俄罗斯、越南、伊朗、印尼等“一带一路”国家钢铁企业中应用，充分体现了高炉智能化大屏产业应运而生。我们将使用 &lt;strong&gt;Hightopo&lt;/strong&gt;（以下简称 HT ）的 &lt;strong&gt;HT for Web&lt;/strong&gt; 产品上的 &lt;strong&gt;web&lt;/strong&gt; 组态跟大家介绍一下通过 2/3D 融合搭建的高炉炼铁厂可视化系统。&lt;/p&gt;
&lt;p&gt;      HT 可以快速实现丰富的 &lt;strong&gt;2D 组态&lt;/strong&gt;和 &lt;strong&gt;3D 组态&lt;/strong&gt;效果，可以根据需求发挥自己的想象，玩转很多新奇的功能，并且通过优势互补的作用下，完善出一套完整的可视化系统解决方案。所以在可视化系统的实现上，3D 场景采用以 &lt;strong&gt;HT &lt;/strong&gt;轻量化 HTML5/WebGL 建模的方案，实现快速建模、运行时轻量化到甚至手机终端浏览器即可 3D 可视化运维的良好效果；而在对应的 2D 图纸上，使用特有的矢量，在各种比例下不失真，加上布局机制，解决了不同屏幕比例下的展示问题。&lt;/p&gt;

&lt;p&gt;本文将从以下三个方面与大家分享高炉炼铁厂在大屏展示上的实现：&lt;/p&gt;
&lt;p&gt;      1、&lt;strong&gt;页面搭建&lt;/strong&gt;：介绍基础的 2D 图纸与 3D 场景融合的项目搭建；&lt;/p&gt;
&lt;p&gt;      2、&lt;strong&gt;数据对接&lt;/strong&gt;：进行面板数据的对接展示；&lt;/p&gt;
&lt;p&gt;      3、&lt;strong&gt;动画实现&lt;/strong&gt;：铁水罐车运输、传送带运送以及场景漫游的实现；&lt;/p&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;界面简介及效果预览&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      在整个高炉炼铁厂可视化系统的 2D 面板上，呈现了昨日历史与今日实时的一些重要预警数据，在管控上能起到实时监控的作用，也能与历史数据进行对比，从而使生产与安全达到预期的预警效果；其次 3D 场景通过轻量化的模型呈现出一座高炉炼铁厂的基本运作流程以及铁水罐车运送钢铁的动画，加上环绕的漫游效果，起到全方位的实时监控状态的变化。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421030641253-971646176.gif&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;代码实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;一、页面搭建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        在内容实现上，采用了 HT 轻量化模型以及 web 组态，以 2/3D 结合的方式，通过的 json 反序列化得到 2D 图纸和 3D 场景的完整呈现。首先会通过创建 &lt;strong&gt;ht.graph.GraphView&lt;/strong&gt; 和 &lt;strong&gt;ht.graph3d.Graph3dView&lt;/strong&gt; 来呈现 2D 和 3D 的内容。 2D 视图组件和 3D 视图组件进行 deserialize() 反序列化对应的 url 寄存的 json 呈现出场景与图纸的内容，两者通过对数据模型 DataModel 里的子元素设置标签来进行数据绑定，实现功能上的展示。&lt;/p&gt;
&lt;div readability=&quot;21.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 三维拓扑视图
let g2d = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.graph.GraphView();
let g3dDm =&lt;span data-mce-=&quot;&quot;&gt; g2d.dm();
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 三维拓扑视图
let g3d = &lt;span data-mce-=&quot;&quot;&gt;new&lt;span data-mce-=&quot;&quot;&gt; ht.graph3d.Graph3dView();
let g3dDm =&lt;span data-mce-=&quot;&quot;&gt; g3d.dm(); 
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 2D 视图组件和 3D 视图组件进行反序列化
g2d.deserialize('displays/index.json'&lt;span data-mce-=&quot;&quot;&gt;);
g3d.deserialize('scenes/index.json');&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;        在内容呈现上还需要将组件加入到 body 下，一般 2/3D 结合的项目上，都会使用 2D 组件加入到 3D 组件的根 div 下，然后 3D 组件再加入到 body下的方式实现面板与场景的加载。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将 3D 组件加入到 body 下
&lt;span data-mce-=&quot;&quot;&gt;g3d.addToDOM();
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将 2D 组件加入到 3D 组件的根 div 下，父子 DOM 事件会冒泡，这样不会影响 3D 场景的交互
g2d.addToDOM(g3d.getView());&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      同时，在交互与呈现上改变了一些实现方式。例如，修改了左右键的交互方式，设置左键点击旋转 3D 场景，右键点击为 pan 抓图的场景移动方式。其次，在点击 2D 有点到图元像素时，我们希望不触发 3D 的交互，例如在对 2D 面板表格中用滚轮滑动的时候，会触发 3D 场景的缩放，这里通过监听 moudedown、touchstart 和 wheel 三种交互来进行控制，对于 wheel 的监听方式，为了保证兼容性就通过封装一个 getWheelEventName() 的方法来得到事件名。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 修改左右键交互方式
let mapInteractor = &lt;span data-mce-=&quot;&quot;&gt;new ht.graph3d.MapInteractor(&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.g3d);
g3d.setInteractors([mapInteractor]);
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置修改最大仰角为 PI / 2
mapInteractor.maxPhi = Math.PI / 2&lt;span data-mce-=&quot;&quot;&gt;;

&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 避免 2D 与 3D 交互重叠
let div2d =&lt;span data-mce-=&quot;&quot;&gt; g2d.getView();
const handler = e =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (g2d.getDataAt(e)) {
        e.stopPropagation();
    }
};
div2d.addEventListener('mousedown'&lt;span data-mce-=&quot;&quot;&gt;, handler);
div2d.addEventListener('touchstart'&lt;span data-mce-=&quot;&quot;&gt;, handler);
div2d.addEventListener(getWheelEventName(div2d), handler);

&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 在一个 HTMLElement 上，可能支持下面三个事件的一种或者两种，但实际回调只会回调一种事件，优先回调标准事件，触发标准事件后，不会触发兼容性事件
&lt;span data-mce-=&quot;&quot;&gt;function&lt;span data-mce-=&quot;&quot;&gt; getWheelEventName(element) {
    &lt;span data-mce-=&quot;&quot;&gt;if ('onwheel' &lt;span data-mce-=&quot;&quot;&gt;in&lt;span data-mce-=&quot;&quot;&gt; element) {
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 标准事件
        &lt;span data-mce-=&quot;&quot;&gt;return 'wheel'&lt;span data-mce-=&quot;&quot;&gt;;
    } &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (document.onmousewheel !==&lt;span data-mce-=&quot;&quot;&gt; undefined) {
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通用旧版事件
        &lt;span data-mce-=&quot;&quot;&gt;return 'mousewheel'&lt;span data-mce-=&quot;&quot;&gt;;
    } &lt;span data-mce-=&quot;&quot;&gt;else&lt;span data-mce-=&quot;&quot;&gt; {
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 旧版 Firefox 事件
        &lt;span data-mce-=&quot;&quot;&gt;return 'DOMMouseScroll'&lt;span data-mce-=&quot;&quot;&gt;;
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;二、数据对接&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      在 2D 面板的呈现上，会有许多的图表数据信息，我们可以通过访问后台数据接口得到数据，然后在 2D 或者 3D 对应的组件上取得相应的数据模型 dataModel，通过对数据模型里设置唯一的标识 tag 的子节点进行对接数据就可以了。例如现在我们要对 2D 面板的数据进行绑定，我们只需要通过 2D 组件的 g2d 得到数据模型，通过 g2d.dm().getDataByTag(tag) 就可以得到设置有唯一标识的 tag 节点，来对接数据或者设置状态展示了。&lt;/p&gt;
&lt;p&gt;      对于数据接口的获取，可以运用主流的 jQuery 框架下的 &lt;strong&gt;ajax&lt;/strong&gt;、基于 promise 的 HTTP 库的 &lt;strong&gt;axios  &lt;/strong&gt;通过轮询调用接口实时获取数据或者使用 HTML5 提供的一种在单个 TCP 连接上进行全双工通讯的协议 &lt;strong&gt;WebSocket&lt;/strong&gt;，可以双向进行数据传输，在选择运用上可以匹配自己的实现需求，而本系统是采用通过 axios 调用接口获取实时数据。&lt;/p&gt;
&lt;div readability=&quot;14&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 昨日利用系数数据对接
axios.get('/yesterdayUse').then(res =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    setBindingDatasWithAnim(dm, res, undefined, v =&amp;gt; v.toFixed(2&lt;span data-mce-=&quot;&quot;&gt;));
});
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 昨日燃料比数据对接
axios.get('/yesterdayFuel').then(res =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    setBindingDatasWithAnim(dm, res, undefined, v =&amp;gt; v.toFixed(2&lt;span data-mce-=&quot;&quot;&gt;));
});
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 昨日入炉品位数据对接
axios.get('/yesterdayIn').then(res =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    setBindingDatasWithAnim(dm, res, undefined, v =&amp;gt; v.toFixed(2&lt;span data-mce-=&quot;&quot;&gt;));
});
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 昨日燃气利用率数据对接
axios.get('/yesterdayCoal').then(res =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    setBindingDatasWithAnim(dm, res, undefined, v =&amp;gt; v.toFixed(2&lt;span data-mce-=&quot;&quot;&gt;));
});
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 实时警报信息面板表格轮询载入数据进行滚动播放
&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.addTableRow();
setInterval(() =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.addTableRow();
}, 5000);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;

&lt;p&gt;      通过 axios 轮询调用接口，实时获取安全指数和实时数据信息（风量、风温和富氧量）：&lt;/p&gt;
&lt;div readability=&quot;26.7421875&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;requestData() {
    let dm = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.view.dm();
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 安全指数数据对接并载入圆环动画
    axios.get('/levelData').then(res =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        setBindingDatasWithAnim(dm, res, 800, v =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; Math.round(v));
    });
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 实时数据(风量、风温和富氧量)数据对接并载入进度条动画
    axios.post('/nature'&lt;span data-mce-=&quot;&quot;&gt;, [
        'windNumber', 'windTemp', 'oxygenNumber'&lt;span data-mce-=&quot;&quot;&gt;
    ]).then(res =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        setBindingDatasWithAnim(dm, res, 800, v =&amp;gt; parseFloat(v.toFixed(1&lt;span data-mce-=&quot;&quot;&gt;)));
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421032226667-1286977542.gif&quot; alt=&quot;&quot; width=&quot;219&quot; height=&quot;281&quot;/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421032200467-1255980283.gif&quot; alt=&quot;&quot; width=&quot;183&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;p&gt;       对接数据后，实现一些圆环或者进度条值的增减动画，其本质上是运用 HT 自带的动画函数 &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/beginners/ht-beginners-guide.html?search=startAnim&amp;amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0&quot; target=&quot;_blank&quot;&gt;ht.Default.startAnim()&lt;/a&gt;，通过判断数据绑定的属性后，设定新值与旧值差额的范围动画，然后用户定义函数 easing 参数通过数学公式来控制动画的运动的快慢，例如匀速变化、先慢后快等效果。&lt;/p&gt;
&lt;p&gt;       这里通过动画函数封装了一个差值的动画效果，参数如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;node：&lt;/strong&gt;动画处理的节点；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;name：&lt;/strong&gt;数据绑定的名称；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;value：&lt;/strong&gt;数据绑定的值；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;format：&lt;/strong&gt;绑定数据值的格式规范；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;accesstype：&lt;/strong&gt;数据绑定的属性从属 ；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;duration：&lt;/strong&gt;动画时间； &lt;/li&gt;
&lt;/ul&gt;&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
setValueWithAnimation (node, name, value, format, accesstype = 's', duration = 300&lt;span data-mce-=&quot;&quot;&gt;) {
    let oldValue;
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 判断数据绑定为自定义属性 attr 后根据绑定名字取出旧值
    &lt;span data-mce-=&quot;&quot;&gt;if (accesstype === 'a'&lt;span data-mce-=&quot;&quot;&gt;) {
        oldValue =&lt;span data-mce-=&quot;&quot;&gt; node.a(name);
    }
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 判断数据绑定为样式属性 style 后根据绑定名字取出旧值
    &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (accesstype === 's'&lt;span data-mce-=&quot;&quot;&gt;) {
        oldValue =&lt;span data-mce-=&quot;&quot;&gt; node.s(name);
    }
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 默认通过取值器 getter 得到数据绑定的值
    &lt;span data-mce-=&quot;&quot;&gt;else&lt;span data-mce-=&quot;&quot;&gt; {
        oldValue =&lt;span data-mce-=&quot;&quot;&gt; node[ht.Default.getter(name)]();
    }
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置新旧值的差额
    let range = value -&lt;span data-mce-=&quot;&quot;&gt; oldValue;
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 执行动画函数
&lt;span data-mce-=&quot;&quot;&gt;    ht.Default.startAnim({
        duration: duration,
        easing: &lt;span data-mce-=&quot;&quot;&gt;function (t) { &lt;span data-mce-=&quot;&quot;&gt;return 1 - (--t) * t * t *&lt;span data-mce-=&quot;&quot;&gt; t; },
        action: (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 新值增长的动画范围
            let newValue = oldValue + range *&lt;span data-mce-=&quot;&quot;&gt; v;
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 判断有格式则制定数据格式
            &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (format) {
                newValue =&lt;span data-mce-=&quot;&quot;&gt; format(newValue);
            }
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 判断数据绑定为自定义属性 attr 后设定新值
            &lt;span data-mce-=&quot;&quot;&gt;if (accesstype === 'a'&lt;span data-mce-=&quot;&quot;&gt;) {
                node.a(name, newValue);
            }
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 判断数据绑定为样式属性 style 后设定新值
            &lt;span data-mce-=&quot;&quot;&gt;else &lt;span data-mce-=&quot;&quot;&gt;if (accesstype === 's'&lt;span data-mce-=&quot;&quot;&gt;) {
                node.s(name, newValue);
            }
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 默认通过存值器 setter 设置数据绑定的新值
            &lt;span data-mce-=&quot;&quot;&gt;else&lt;span data-mce-=&quot;&quot;&gt; {
                node[ht.Default.setter(name)]()(node, newValue);
            }
        }
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;div readability=&quot;12.537216828479&quot;&gt;      我们时常会在公开的预警场合或者宣传场合看见轮播滚动的数据信息，采用这种方法在公示的同时也不会遗漏掉任何一条数据信息，如果搭配上一些例如淡入淡出的过场效果，更会吸引关注的眼球。而对于实时警报信息的面板表格的实现，也是在添加新数据时，实现了一种过渡的 UI 交互上的沉浸感，主要还是运用了 HT 自带的动画函数 &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/beginners/ht-beginners-guide.html?search=startAnim&amp;amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0&quot; target=&quot;_blank&quot;&gt;ht.Default.startAnim()&lt;/a&gt;，横向通过滚动 100 宽度并数据透明度慢慢浮现，纵向采用向下偏移一行表格行高 54 来添加新的警报信息。&lt;/div&gt;
&lt;div readability=&quot;10&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;addTableRow() {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取表格节点
    let table = &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.right3;
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过 axios 的 promise 请求接口数据
    axios.get('getEvent').then(res =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 获取表格节点滚动信息的数据绑定
        let tableData = table.a('dataSource'&lt;span data-mce-=&quot;&quot;&gt;);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过向 unshift() 方法可向滚动信息数组的开头添加一个或更多元素
&lt;span data-mce-=&quot;&quot;&gt;        tableData.unshift(res);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 初始化表格的纵向偏移
        table.a('ty', -54&lt;span data-mce-=&quot;&quot;&gt;);
        &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 开启表格滚动动画
&lt;span data-mce-=&quot;&quot;&gt;        ht.Default.startAnim({
            duration: 600&lt;span data-mce-=&quot;&quot;&gt;,
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 动画执行函数 action
            action: (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                table.a({
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过添加数据后，横向滚动 100
                    'firstRowTx': 100 * (1 -&lt;span data-mce-=&quot;&quot;&gt; v),
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 第一行行高出现的透明度渐变效果
                    'firstRowOpacity'&lt;span data-mce-=&quot;&quot;&gt;: v,
                    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 纵向偏移 54 的高度
                    'ty': (v - 1) * 54&lt;span data-mce-=&quot;&quot;&gt;
                });
            }
        });
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;三、动画实现&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      在静态的场景以及面板下，很难直观地去体现一个 2/3D 嵌合的系统的优越性。动画却是赋予生命灵魂的所在，一个恰到好处的 UI 动画设计可以使面板的交互体验鲜活起来，而在 3D 场景中，通过一组简单形象的铁水罐车运输和传送带运送可以让人清晰地明白生产运输的流程，对于模型建筑的管控，利用好视角切入点，我们可以设置全方位的沉浸式漫游巡视。综上，通过轻量模型场景与矢量组件面板的优势叠加，可以呈现出一套灵活的高炉炼铁厂生产预警系统。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421115032044-1678050271.gif&quot; alt=&quot;&quot; width=&quot;697&quot; height=&quot;322&quot;/&gt;&lt;/div&gt;
&lt;p&gt;      在漫游巡视下，为了更全方位地体现场景，我们通过裁剪的方式来显示和隐藏两侧的面板数据，以下以隐藏面板的裁剪动画为例：&lt;/p&gt;
&lt;div readability=&quot;21.295852073963&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;hidePanel() {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将左侧数据绑定裁剪的子元素存放进一个数组里
    let leftStartClipIndexs = (() =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        let arr =&lt;span data-mce-=&quot;&quot;&gt; [];
        &lt;span data-mce-=&quot;&quot;&gt;for (let i = 1; i &amp;lt;= 4; i++) arr.push(&lt;span data-mce-=&quot;&quot;&gt;this['left' + i].s('clip.percentage'&lt;span data-mce-=&quot;&quot;&gt;));
        &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt; arr;
    })();
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 将右侧数据绑定裁剪的子元素存放进一个数组里
    let rightStartClipIndexs = (() =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        let arr =&lt;span data-mce-=&quot;&quot;&gt; [];
        &lt;span data-mce-=&quot;&quot;&gt;for (let i = 1; i &amp;lt;= 3; i++) arr.push(&lt;span data-mce-=&quot;&quot;&gt;this['right' + i].s('clip.percentage'&lt;span data-mce-=&quot;&quot;&gt;));
        &lt;span data-mce-=&quot;&quot;&gt;return&lt;span data-mce-=&quot;&quot;&gt; arr;
    })();
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置面板裁剪的延迟时间，使得视觉上更有层次感
    let delayArrays = [400, 800, 1200, 1600&lt;span data-mce-=&quot;&quot;&gt;];
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 动画执行函数
    let action = (index) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        ht.Default.startAnim({
            duration: 700&lt;span data-mce-=&quot;&quot;&gt;,
            easing: Easing.swing,
            action: (v, t) =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
                &lt;span data-mce-=&quot;&quot;&gt;this['left' + index].s('clip.percentage', leftStartClipIndexs[index - 1] + (0 - leftStartClipIndexs[index - 1]) *&lt;span data-mce-=&quot;&quot;&gt; v);
                &lt;span data-mce-=&quot;&quot;&gt;this['right' + index].s('clip.percentage', rightStartClipIndexs[index - 1] + (0 - rightStartClipIndexs[index - 1]) *&lt;span data-mce-=&quot;&quot;&gt; v);
            }
        });
    };
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 通过判定延迟时间数组的长度，回调 action 动画的执行
    &lt;span data-mce-=&quot;&quot;&gt;for (let i = 0, l = delayArrays.length; i &amp;lt; l; i++&lt;span data-mce-=&quot;&quot;&gt;) {
        ht.Default.callLater(action, &lt;span data-mce-=&quot;&quot;&gt;this, [i + 1&lt;span data-mce-=&quot;&quot;&gt;], delayArrays.shift());
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      data.s('clip.percentage') 是 HT 节点自带的样式属性，其本质意义就是可以通过指定的方向进行对于整个矢量图标的裁剪：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421145607969-1042774123.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      一部电影可以通过各种镜头的切换下呈现不尽相同的叙事效果，日剧夕阳下热血跑的急速切换或者幽暗角落下惊恐的淡入淡出，都是一种叙事的处理手段。在 HT 设定的 3D 场景中同样地也存在着许许多多叙述的手法，最为基础的设定就是通过场景中的主观眼睛 &lt;strong&gt;eye&lt;/strong&gt; 和场景中心 &lt;strong&gt;center&lt;/strong&gt; 来搭配各种动画的实现，可以自己设定值的方法函数来修改，也可以通过 HT 自身封装的方法函数来处理，例如 &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/3d/ht-3d-guide.html?search=flyTo&amp;amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0&quot; target=&quot;_blank&quot;&gt;flyTo()&lt;/a&gt; 和 &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/3d/ht-3d-guide.html?search=moveCamera&amp;amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0&quot; target=&quot;_blank&quot;&gt;moveCamera()&lt;/a&gt; 就是最为基础的相机动画，有兴趣的话可以了解一下，自己动手尝试搭配，肯定能最大地发挥 3D 场景的优势所在。&lt;/p&gt;
&lt;/div&gt;
&lt;div&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421115753431-1880870240.gif&quot; alt=&quot;&quot; width=&quot;649&quot; height=&quot;300&quot;/&gt;&lt;/div&gt;
&lt;div readability=&quot;10.496183206107&quot;&gt;      漫游动画是为了更好地从不同的视角去巡视场景，只要通过设置几组眼睛视角，运用 &lt;strong&gt;HT&lt;/strong&gt; 的 &lt;a href=&quot;https://www.hightopo.com/guide2/ht/guide/core/3d/ht-3d-guide.html?search=moveCamera&amp;amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0&quot; target=&quot;_blank&quot;&gt;moveCamera()&lt;/a&gt; 相机视角移动的动画，依次去对应眼睛的视角就可以自动地切换不同视角下场景的效果。&lt;/div&gt;
&lt;div readability=&quot;50.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;58&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 默认设置的眼睛视角数组
const ROAM_EYES =&lt;span data-mce-=&quot;&quot;&gt; [
    [1683.6555274005063, 939.9999999999993, 742.6554147474625&lt;span data-mce-=&quot;&quot;&gt;],
    [1717.1004359371925, 512.9256996098727, -1223.5575465999652&lt;span data-mce-=&quot;&quot;&gt;],
    [-181.41773461002046, 245.58303266170844, -2043.6755074222654&lt;span data-mce-=&quot;&quot;&gt;],
    [-1695.7113902533574, 790.0214102589537, -877.645744191523&lt;span data-mce-=&quot;&quot;&gt;],
    [-1848.1700283399357, 1105.522705042774, 1054.1519814237804&lt;span data-mce-=&quot;&quot;&gt;],
    [-108, 940, 1837&lt;span data-mce-=&quot;&quot;&gt;]
];
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 开启相机移动漫游动画
&lt;span data-mce-=&quot;&quot;&gt;playRoam() {
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置场景眼睛视角
    let eye = ROAM_EYES[&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.roamIndex];
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 开启相机视角移动动画 moveCamera
    &lt;span data-mce-=&quot;&quot;&gt;this._roamAnim = &lt;span data-mce-=&quot;&quot;&gt;this.view.moveCamera(eye, [0, 0, 0&lt;span data-mce-=&quot;&quot;&gt;], {
        duration: &lt;span data-mce-=&quot;&quot;&gt;this.roamIndex ? 3000 : 4000&lt;span data-mce-=&quot;&quot;&gt;,
        easing: Easing.easeOut,
        finishFunc: () =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
            &lt;span data-mce-=&quot;&quot;&gt;this.roamIndex ++&lt;span data-mce-=&quot;&quot;&gt;;
            let nextEye = ROAM_EYES[&lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.roamIndex];
            &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 判断是否有下一组眼睛视角，有的话继续执行相机视角移动动画，反之则重置漫游动画
            &lt;span data-mce-=&quot;&quot;&gt;if&lt;span data-mce-=&quot;&quot;&gt; (nextEye) {
                &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.playRoam();
            }
            &lt;span data-mce-=&quot;&quot;&gt;else&lt;span data-mce-=&quot;&quot;&gt; {
                &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 事件派发执行显示面板动画
&lt;span data-mce-=&quot;&quot;&gt;                event.fire(EVENT_SHOW_PANEL);
                &lt;span data-mce-=&quot;&quot;&gt;this&lt;span data-mce-=&quot;&quot;&gt;.resetRoam();
            }
        }
    });
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;      如果说场景视角漫游是一种大局&lt;strong&gt;整体&lt;/strong&gt;观的体现，那么铁水罐车装载与运输以及传送带的运送则是一个高炉炼铁流程的&lt;strong&gt;拼图&lt;/strong&gt;。通过一系列动画流程的表达，你会很清晰地发现，特定的 3D 场景下的讲解说明具有完整的故事串联性。&lt;/p&gt;
&lt;p&gt;      以下是铁水罐车装载与运输的动画流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421181355269-359764551.png&quot; alt=&quot;&quot; width=&quot;740&quot; height=&quot;169&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      在 3D 场景中是用 x, y, z 来分别表示三个轴，通过不断修改节点的 3D 坐标就可以实现位移效果 car.setPosition3d(x, y, z)，而对于铁水罐车上的装载标签则使用吸附的功能，使其吸附在铁水罐车上就能跟着一起行驶移动，然后在指定的空间坐标位置上通过 car.s('3d.visible', true | false) 来控制铁水罐车的出现与隐藏的效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421153533851-760636210.gif&quot; alt=&quot;&quot; width=&quot;468&quot; height=&quot;213&quot;/&gt;&lt;/p&gt;

&lt;p&gt;      而关于传送带上煤块、铁矿的传输和管道气体流通的指示，通过使用 UV 纹理贴图的偏移来实现会方便很多，先来看看效果上的呈现：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421154946034-429797488.gif&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;293&quot;/&gt;  &lt;img src=&quot;https://img2020.cnblogs.com/blog/1496396/202004/1496396-20200421155012282-285762301.gif&quot; alt=&quot;&quot; width=&quot;548&quot; height=&quot;294&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;wrong-dom-ele&quot;&gt;      对于三维模型，有两个重要的坐标系统，就是顶点的位置坐标（X、Y、Z）以及 UV 坐标。形象地说，UV 就是贴图影射到模型表面的依据，U 和 V 分别是图片在显示器水平、垂直方向上的坐标，取值一般都是0~1。而传送带以及管道的指示就是用这种方法实现的，HT 的模型节点自带 uv 值的样式属性，我们只需要不断地控制其偏移变化，就能实现传输的效果：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 设置初始偏移值
let offset1 = 0, trackOffset = 0&lt;span data-mce-=&quot;&quot;&gt;;
&lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 一直调用设置偏移值
setInterval(() =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
    flows.each(node =&amp;gt;&lt;span data-mce-=&quot;&quot;&gt; {
        node.s({
            'top.uv.offset': [-offset1, 0&lt;span data-mce-=&quot;&quot;&gt;],
            'front.uv.offset': [-offset1, 0&lt;span data-mce-=&quot;&quot;&gt;],
        });
    });
    track.s('shape3d.uv.offset', [0, -&lt;span data-mce-=&quot;&quot;&gt;trackOffset]);
    &lt;span data-mce-=&quot;&quot;&gt;//&lt;span data-mce-=&quot;&quot;&gt; 偏移值增加
    offset1 += 0.1&lt;span data-mce-=&quot;&quot;&gt;;
    trackOffset += 0.03&lt;span data-mce-=&quot;&quot;&gt;;
}, 100);&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;/div&gt;
&lt;p&gt;&lt;span data-mce-=&quot;&quot;&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;      &lt;strong&gt;数字化 &lt;/strong&gt;和 &lt;strong&gt;智能化 &lt;/strong&gt;大屏管控是 &lt;strong&gt;工业互联网 &lt;/strong&gt;的发展趋势，在很大程度上解放了人力和劳力，在信息飞速传讯的时代，大数据可视化和智能管控的结合，会演绎出许多惊奇的效果碰撞。对实时数据监管下，预警信息也相当重要，保障生产有序进行的同时，我们也要关注安全问题，所以在大屏上呈现的许多内容，都极其具有行业跟上工业互联网的步伐代表性。&lt;/p&gt;


&lt;/div&gt;</description>
<pubDate>Wed, 22 Apr 2020 16:09:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 在当今&amp;#160;工业4.0&amp;#160;新时代的推动下，不仅迎来了&amp;#160;工业互联网&amp;#160;的发展，还开启了&amp;#160;5G&amp;#160;时代的新次元。而伴随着带宽的提升，网络信息飞速发展</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/12753451.html</dc:identifier>
</item>
<item>
<title>NIO教程 ——检视阅读 - 卡斯特梅的雨伞</title>
<link>http://www.cnblogs.com/castamere/p/12757885.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/castamere/p/12757885.html</guid>
<description>&lt;p&gt;NIO教程 ——检视阅读&lt;/p&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;BIO,NIO,AIO 总结&lt;/p&gt;
&lt;p&gt;Java NIO浅析&lt;/p&gt;
&lt;p&gt;Java NIO 教程——极客，蓝本&lt;/p&gt;
&lt;p&gt;Java NIO 系列教程 ——并发编程网&lt;/p&gt;
&lt;p&gt;BIO,NIO——知乎&lt;/p&gt;
&lt;p&gt;NIO 入门——IBM&lt;/p&gt;
&lt;p&gt;Java NIO教程 ——易百&lt;/p&gt;
&lt;p&gt;Java NIO Tutorial英文版&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;首先Java中的IO有以下三种：
BIO(Blocking IO)  同步式阻塞IO
NIO(Non-BlockingIO/New IO)  同步式非阻塞IO   JDK1.4提供 
AIO(AsynchronousIO)  异步式非阻塞IO  JDK1.8提供
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;略读：&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;ibm&lt;/p&gt;
&lt;p&gt;NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。&lt;/p&gt;
&lt;p&gt;原来的 I/O 库(在 java.io.*中) 与 NIO 最重要的区别是数据打包和传输的方式。正如前面提到的，原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。&lt;/p&gt;
&lt;p&gt;通道和 缓冲区是 NIO 中的核心对象，几乎在每一个 I/O 操作中都要使用它们。&lt;/p&gt;
&lt;p&gt;通道是对原 I/O 包中的流的模拟。到任何目的地(或来自任何地方)的所有数据都必须通过一个 Channel 对象。一个 Buffer 实质上是一个容器对象。发送给一个通道的所有对象都必须首先放到缓冲区中；同样地，从通道中读取的任何数据都要读到缓冲区中。&lt;/p&gt;
&lt;p&gt;Buffer 是一个对象， 它包含一些要写入或者刚读出的数据。 在 NIO 中加入 Buffer 对象，体现了新库与原 I/O 的一个重要区别。在面向流的 I/O 中，您将数据直接写入或者将数据直接读到 Stream 对象中 。&lt;/p&gt;
&lt;p&gt;缓冲区实质上是一个数组。通常它是一个字节数组，但是也可以使用其他种类的数组。但是一个缓冲区不 仅仅 是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。&lt;/p&gt;
&lt;p&gt;Channel是一个对象，可以通过它读取和写入数据。拿 NIO 与原来的 I/O 做个比较，通道就像是流。&lt;/p&gt;
&lt;p&gt;通道与流的不同之处在于通道是双向的。而流只是在一个方向上移动(一个流必须是 InputStream 或者 OutputStream 的子类)， 而 通道可以用于读、写或者同时用于读写。&lt;/p&gt;
&lt;p&gt;因为它们是双向的，所以通道可以比流更好地反映底层操作系统的真实情况。特别是在 UNIX 模型中，底层操作系统通道是双向的。&lt;/p&gt;
&lt;p&gt;在 NIO 系统中，任何时候执行一个读操作，您都是从通道中读取，但是您不是 直接 从通道读取。因为所有数据最终都驻留在缓冲区中，所以您是从通道读到缓冲区中。&lt;/p&gt;
&lt;p&gt;因此读取文件涉及三个步骤：(1) 从 FileInputStream 获取 Channel，(2) 创建 Buffer，(3) 将数据从 Channel 读到 Buffer中。&lt;/p&gt;
&lt;p&gt;clear() 方法重设缓冲区，使它可以接受读入的数据。 flip() 方法让缓冲区可以将新读入的数据写入另一个通道。&lt;/p&gt;
&lt;p&gt;flip&lt;/p&gt;
&lt;p&gt;现在我们要将数据写到输出通道中。在这之前，我们必须调用 flip() 方法。这个方法做两件非常重要的事：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它将 limit 设置为当前 position。&lt;/li&gt;
&lt;li&gt;它将 position 设置为 0。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;clear&lt;/p&gt;
&lt;p&gt;最后一步是调用缓冲区的 clear() 方法。这个方法重设缓冲区以便接收更多的字节。 Clear 做两种非常重要的事情：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;它将 limit 设置为与 capacity 相同。&lt;/li&gt;
&lt;li&gt;它设置 position 为 0。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;read() 和 write() 调用得到了极大的简化，因为许多工作细节都由缓冲区完成了。 clear() 和 flip() 方法用于让缓冲区在读和写之间切换。&lt;/p&gt;
&lt;p&gt;创建不同类型的缓冲区以达到不同的目的，如可保护数据不被修改的 只读 缓冲区，和直接映射到底层操作系统缓冲区的 直接 缓冲区。&lt;/p&gt;
&lt;p&gt;使用静态方法 allocate() 来分配缓冲区：&lt;/p&gt;
&lt;p&gt;ByteBuffer buffer = ByteBuffer.allocate( 1024 );&lt;/p&gt;
&lt;p&gt;将一个现有的数组转换为缓冲区，如下所示：&lt;/p&gt;
&lt;p&gt;byte array[] = new byte[1024];``ByteBuffer buffer = ByteBuffer.wrap( array );&lt;/p&gt;
&lt;p&gt;本例使用了 wrap() 方法将一个数组包装为缓冲区。必须非常小心地进行这类操作。一旦完成包装，底层数据就可以通过缓冲区或者直接访问。&lt;/p&gt;
&lt;p&gt;创建一个包含槽 3 到槽 6 的子缓冲区。在某种意义上，子缓冲区就像原来的缓冲区中的一个窗口 。&lt;/p&gt;
&lt;p&gt;窗口的起始和结束位置通过设置 position 和 limit 值来指定，然后调用 Buffer 的 slice() 方法：&lt;/p&gt;
&lt;p&gt;buffer.position( 3 );&lt;code&gt;buffer.limit( 7 );&lt;/code&gt;ByteBuffer slice = buffer.slice();&lt;/p&gt;
&lt;p&gt;片是缓冲区的 子缓冲区。不过， 片段和 缓冲区共享同一个底层数据数组&lt;/p&gt;
&lt;p&gt;只读缓冲区非常简单 ― 您可以读取它们，但是不能向它们写入。可以通过调用缓冲区的 asReadOnlyBuffer() 方法，将任何常规缓冲区转换为只读缓冲区，这个方法返回一个与原缓冲区完全相同的缓冲区(并与其共享数据)，只不过它是只读的。&lt;/p&gt;
&lt;p&gt;只读缓冲区对于保护数据很有用。在将缓冲区传递给某个对象的方法时，您无法知道这个方法是否会修改缓冲区中的数据。创建一个只读的缓冲区可以 保证 该缓冲区不会被修改。&lt;/p&gt;
&lt;p&gt;不能将只读的缓冲区转换为可写的缓冲区。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//直接缓冲区
ByteBuffer buffer = ByteBuffer.allocateDirect( 1024 );
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分散/聚集 I/O&lt;/p&gt;
&lt;p&gt;通道可以有选择地实现两个新的接口： ScatteringByteChannel 和 GatheringByteChannel。一个 ScatteringByteChannel是一个具有两个附加读方法的通道：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;long read( ByteBuffer[] dsts );&lt;/li&gt;
&lt;li&gt;long read( ByteBuffer[] dsts, int offset, int length );&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些 long read() 方法很像标准的 read 方法，只不过它们不是取单个缓冲区而是取一个缓冲区数组。缓冲区数组就像一个大缓冲区。&lt;/p&gt;
&lt;p&gt;以socket.read()为例子：&lt;/p&gt;
&lt;p&gt;传统的BIO里面socket.read()，如果TCP RecvBuffer里没有数据，函数会一直阻塞，直到收到数据，返回读到的数据。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;meituan&lt;/p&gt;
&lt;p&gt;对于NIO，如果TCP RecvBuffer有数据，就把数据从网卡读到内存，并且返回给用户；反之则直接返回0，永远不会阻塞。&lt;/p&gt;
&lt;p&gt;最新的AIO(Async I/O)里面会更进一步：不但等待就绪是非阻塞的，就连数据从网卡到内存的过程也是异步的。&lt;/p&gt;
&lt;p&gt;换句话说，BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”。&lt;/p&gt;
&lt;p&gt;NIO一个重要的特点是：socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高）。&lt;/p&gt;
&lt;p&gt;回忆BIO模型，之所以需要多线程，是因为在进行I/O操作的时候，一是没有办法知道到底能不能写、能不能读，只能”傻等”，即使通过各种估算，算出来操作系统没有能力进行读写，也没法在socket.read()和socket.write()函数中返回，这两个函数无法进行有效的中断。所以除了多开线程另起炉灶，没有好的办法利用CPU。&lt;/p&gt;
&lt;p&gt;NIO的读写函数可以立刻返回，这就给了我们不开线程利用CPU的最好机会：如果一个连接不能读写（socket.read()返回0或者socket.write()返回0），我们可以把这件事记下来，记录的方式通常是在Selector上注册标记位，然后切换到其它就绪的连接（channel）继续进行读写。&lt;/p&gt;
&lt;p&gt;NIO的主要事件有几个：读就绪、写就绪、有新连接到来。&lt;/p&gt;
&lt;p&gt;仔细分析一下我们需要的线程，其实主要包括以下几种： 1. 事件分发器，单线程选择就绪的事件。 2. I/O处理器，包括connect、read、write等，这种纯CPU操作，一般开启CPU核心个线程就可以。 3. 业务线程，在处理完I/O后，业务一般还会有自己的业务逻辑，有的还会有其他的阻塞I/O，如DB操作，RPC等。只要有阻塞，就需要单独的线程。&lt;/p&gt;
&lt;p&gt;NIO给我们带来了些什么：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;事件驱动模型&lt;/li&gt;
&lt;li&gt;避免多线程&lt;/li&gt;
&lt;li&gt;单线程处理多任务&lt;/li&gt;
&lt;li&gt;非阻塞I/O，I/O读写不再阻塞，而是返回0&lt;/li&gt;
&lt;li&gt;基于block的传输，通常比基于流的传输更高效&lt;/li&gt;
&lt;li&gt;更高级的IO函数，zero-copy&lt;/li&gt;
&lt;li&gt;IO多路复用大大提高了Java网络应用的可伸缩性和实用性&lt;/li&gt;
&lt;/ul&gt;&lt;hr/&gt;&lt;p&gt;BIO,NIO,AIO 总结&lt;/p&gt;
&lt;p&gt;如何区分 “同步/异步 ”和 “阻塞/非阻塞” 呢？&lt;/p&gt;
&lt;p&gt;同步/异步是从行为角度描述事物的，而阻塞和非阻塞描述的当前事物的状态（等待调用结果时的状态）。&lt;/p&gt;
&lt;p&gt;阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发。&lt;/p&gt;
&lt;p&gt;Buffer是一个对象，它包含一些要写入或者要读出的数据。在NIO类库中加入Buffer对象，体现了新库与原I/O的一个重要区别。在面向流的I/O中·可以将数据直接写入或者将数据直接读到 Stream 对象中。虽然 Stream 中也有 Buffer 开头的扩展类，但只是流的包装类，还是从流读到缓冲区，而 NIO 却是直接读到 Buffer 中进行操作。&lt;/p&gt;
&lt;p&gt;NIO 通过Channel（通道） 进行读写。&lt;/p&gt;
&lt;p&gt;通道是双向的，可读也可写，而流的读写是单向的。无论读写，通道只能和Buffer交互。因为 Buffer，通道可以异步地读写。&lt;/p&gt;
&lt;p&gt;NIO有选择器，而IO没有。&lt;/p&gt;
&lt;p&gt;选择器用于使用单个线程处理多个通道。因此，它需要较少的线程来处理这些通道。线程之间的切换对于操作系统来说是昂贵的。 因此，为了提高系统效率选择器是有用的。&lt;/p&gt;
&lt;p&gt;AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的IO模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。&lt;/p&gt;
&lt;p&gt;每当要从缓存区的时候读取数据时，就调用filp()“切换成读模式”。&lt;/p&gt;
&lt;p&gt;读完我们还想写数据到缓冲区，那就使用clear()函数，这个函数会“清空”缓冲区 。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;简介&lt;/p&gt;
&lt;p&gt;NIO中的N可以理解为Non-blocking ，不单纯是New 。&lt;/p&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;标准的IO编程接口是面向字节流和字符流的。而NIO是面向通道和缓冲区的，数据总是从通道中读到buffer缓冲区内，或者从buffer写入到通道中。&lt;/li&gt;
&lt;li&gt;Java NIO使我们可以进行非阻塞IO操作。比如说，单线程中从通道读取数据到buffer，同时可以继续做别的事情，当数据读取到buffer中后，线程再继续处理数据。写数据也是一样的。&lt;/li&gt;
&lt;li&gt;NIO中有一个“slectors”的概念。selector可以检测多个通道的事件状态（例如：链接打开，数据到达）这样单线程就可以操作多个通道的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;概览&lt;/p&gt;
&lt;p&gt;NIO包含下面3个核心的组件，Channel,Buffer和Selector组成了这个核心的API：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Channels ——通道&lt;/li&gt;
&lt;li&gt;Buffers ——缓冲区&lt;/li&gt;
&lt;li&gt;Selectors ——选择器&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;通常来说NIO中的所有IO都是从Channel开始的。Channel和流有点类似。通过Channel，我们即可以从Channel把数据写到Buffer中，也可以把数据冲Buffer写入到Channel 。&lt;/p&gt;
&lt;p&gt;有很多的Channel，Buffer类型。下面列举了主要的几种：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileChannel&lt;/li&gt;
&lt;li&gt;DatagramChannel&lt;/li&gt;
&lt;li&gt;SocketChannel&lt;/li&gt;
&lt;li&gt;ServerSocketChannel&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正如你看到的，这些channel基于于UDP和TCP的网络IO，以及文件IO。 和这些类一起的还有其他一些比较有趣的接口，在本节中暂时不多介绍。为了简洁起见，我们会在必要的时候引入这些概念。 下面是核心的Buffer实现类的列表：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ByteBuffer&lt;/li&gt;
&lt;li&gt;CharBuffer&lt;/li&gt;
&lt;li&gt;DoubleBuffer&lt;/li&gt;
&lt;li&gt;FloatBuffer&lt;/li&gt;
&lt;li&gt;IntBuffer&lt;/li&gt;
&lt;li&gt;LongBuffer&lt;/li&gt;
&lt;li&gt;ShortBuffer&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些Buffer涵盖了可以通过IO操作的基础类型：byte,short,int,long,float,double以及characters. NIO实际上还包含一种MappedBytesBuffer,一般用于和内存映射的文件。&lt;/p&gt;
&lt;p&gt;选择器允许单线程操作多个通道。如果你的程序中有大量的链接，同时每个链接的IO带宽不高的话，这个特性将会非常有帮助。比如聊天服务器。 下面是一个单线程中Slector维护3个Channel的示意图：&lt;/p&gt;
&lt;p&gt;要使用Selector的话，我们必须把Channel注册到Selector上，然后就可以调用Selector的select()方法。这个方法会进入阻塞，直到有一个channel的状态符合条件。当方法返回后，线程可以处理这些事件。&lt;/p&gt;
&lt;p&gt;Java NIO Channel通道&lt;/p&gt;
&lt;p&gt;Java NIO Channel通道和流非常相似，主要有以下3点区别：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;通道可以读也可以写，流一般来说是单向的（只能读或者写）。&lt;/li&gt;
&lt;li&gt;通道可以异步读写。&lt;/li&gt;
&lt;li&gt;通道总是基于缓冲区Buffer来读写。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Channel的实现&lt;/p&gt;
&lt;p&gt;下面列出Java NIO中最重要的集中Channel的实现：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FileChannel&lt;/li&gt;
&lt;li&gt;DatagramChannel&lt;/li&gt;
&lt;li&gt;SocketChannel&lt;/li&gt;
&lt;li&gt;ServerSocketChannel&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;FileChannel用于文件的数据读写。 DatagramChannel用于UDP的数据读写。 SocketChannel用于TCP的数据读写。 ServerSocketChannel允许我们监听TCP链接请求，每个请求会创建会一个SocketChannel.&lt;/p&gt;
&lt;p&gt;RandomAccessFile扩展：&lt;/p&gt;
&lt;p&gt;RandomAccessFile（随机访问文件）类。该类是Java语言中功能最为丰富的文件访问类 。RandomAccessFile类支持“随机访问”方式，这里“随机”是指可以跳转到文件的任意位置处读写数据。在访问一个文件的时候，不必把文件从头读到尾，而是希望像访问一个数据库一样“随心所欲”地访问一个文件的某个部分，这时使用RandomAccessFile类就是最佳选择。&lt;/p&gt;
&lt;p&gt;四种模式：R RW RWD RWS&lt;/p&gt;
&lt;p&gt;r 以只读的方式打开文本，也就意味着不能用write来操作文件&lt;br/&gt;rw 读操作和写操作都是允许的&lt;br/&gt;rws 每当进行写操作，同步的刷新到磁盘，刷新内容和元数据&lt;br/&gt;rwd 每当进行写操作，同步的刷新到磁盘，刷新内容&lt;/p&gt;
&lt;p&gt;RandomAccessFile的用处：&lt;/p&gt;
&lt;p&gt;1、大型文本日志类文件的快速定位获取数据：&lt;/p&gt;
&lt;p&gt;得益于seek的巧妙设计，我认为我们可以从超大的文本中快速定位我们的游标，例如每次存日志的时候，我们可以建立一个索引缓存，索引是日志的起始日期，value是文本的poiniter 也就是光标，这样我们可以快速定位某一个时间段的文本内容&lt;/p&gt;
&lt;p&gt;2、并发读写&lt;/p&gt;
&lt;p&gt;也是得益于seek的设计，我认为多线程可以轮流操作seek控制光标的位置，从未达到不同线程的并发写操作。&lt;/p&gt;
&lt;p&gt;3、更方便的获取二进制文件&lt;/p&gt;
&lt;p&gt;通过自带的读写转码（readDouble、writeLong等），我认为可以快速的完成字节码到字符的转换功能，对使用者来说比较友好。&lt;/p&gt;
&lt;p&gt;RandomAccessFile参考&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class FileChannelTest {

    public static void main(String[] args) throws IOException {
        RandomAccessFile file = new RandomAccessFile(&quot;D:\\text\\1_loan.sql&quot;, &quot;r&quot;);
        //mode只有4中，如果不是读写的mode或者给的不是4种中的，就会报错。
        RandomAccessFile copyFile = new RandomAccessFile(&quot;D:\\text\\1_loan_copy.sql&quot;, &quot;r&quot;);
        try {
            FileChannel fileChannel = file.getChannel();
            FileChannel copyFileChannel = copyFile.getChannel();
            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
            int read = fileChannel.read(byteBuffer);
            while (read != -1) {
                System.out.println(&quot;read:&quot; + read);
                //byteBuffer缓冲区切换为读模式
                byteBuffer.flip();
                copyFileChannel.write(byteBuffer);
                //“清空”byteBuffer缓冲区，以满足后续写入操作
                byteBuffer.clear();
                //注意，每次读时都要返回读后的状态read值赋值给循环判断体read，否则会陷入死循环true
                read = fileChannel.read(byteBuffer);
            }
        } finally {
            file.close();
            copyFile.close();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;RandomAccessFile copyFile = new RandomAccessFile(&quot;D:\\text\\1_loan_copy.sql&quot;, &quot;w&quot;);
//因为没有&quot;w&quot;的mode
Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Illegal mode &quot;w&quot; must be one of &quot;r&quot;, &quot;rw&quot;, &quot;rws&quot;, or &quot;rwd&quot;
        at java.io.RandomAccessFile.&amp;lt;init&amp;gt;(RandomAccessFile.java:221)
        
RandomAccessFile copyFile = new RandomAccessFile(&quot;D:\\text\\1_loan_copy.sql&quot;, &quot;r&quot;);
//因为没有&quot;w&quot;的权限
Exception in thread &quot;main&quot; java.nio.channels.NonWritableChannelException
        at sun.nio.ch.FileChannelImpl.write(FileChannelImpl.java:194)
        at com.niotest.FileChannelTest.main(FileChannelTest.java:33)    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NIO Buffer缓冲区&lt;/p&gt;
&lt;p&gt;Java NIO Buffers用于和NIO Channel交互。正如你已经知道的，我们从channel中读取数据到buffers里，从buffer把数据写入到channels.&lt;/p&gt;
&lt;p&gt;buffer本质上就是一块内存区，可以用来写入数据，并在稍后读取出来。这块内存被NIO Buffer包裹起来，对外提供一系列的读写方便开发的接口。&lt;/p&gt;
&lt;p&gt;Buffer基本用法&lt;/p&gt;
&lt;p&gt;利用Buffer读写数据，通常遵循四个步骤：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;把数据写入buffer；&lt;/li&gt;
&lt;li&gt;调用flip；&lt;/li&gt;
&lt;li&gt;从Buffer中读取数据；&lt;/li&gt;
&lt;li&gt;调用buffer.clear()或者buffer.compact()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当写入数据到buffer中时，buffer会记录已经写入的数据大小。当需要读数据时，通过flip()方法把buffer从写模式调整为读模式；在读模式下，可以读取所有已经写入的数据。&lt;/p&gt;
&lt;p&gt;当读取完数据后，需要清空buffer，以满足后续写入操作。清空buffer有两种方式：调用clear()或compact()方法。clear会清空整个buffer，compact则只清空已读取的数据，未被读取的数据会被移动到buffer的开始位置，写入位置则近跟着未读数据之后。&lt;/p&gt;
&lt;p&gt;Buffer的容量，位置，上限（Buffer Capacity, Position and Limit）&lt;/p&gt;
&lt;p&gt;buffer缓冲区实质上就是一块内存，用于写入数据，也供后续再次读取数据。这块内存被NIO Buffer管理，并提供一系列的方法用于更简单的操作这块内存。&lt;/p&gt;
&lt;p&gt;一个Buffer有三个属性是必须掌握的，分别是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;capacity容量&lt;/li&gt;
&lt;li&gt;position位置&lt;/li&gt;
&lt;li&gt;limit限制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;position和limit的具体含义取决于当前buffer的模式。capacity在两种模式下都表示容量。&lt;/p&gt;
&lt;p&gt;下面有张示例图，描诉了不同模式下position和limit的含义：&lt;/p&gt;
&lt;p&gt;容量（Capacity）&lt;/p&gt;
&lt;p&gt;作为一块内存，buffer有一个固定的大小，叫做capacity容量。也就是最多只能写入容量值的字节，整形等数据。一旦buffer写满了就需要清空已读数据以便下次继续写入新的数据。&lt;/p&gt;
&lt;p&gt;位置（Position）&lt;/p&gt;
&lt;p&gt;当写入数据到Buffer的时候需要中一个确定的位置开始，默认初始化时这个位置position为0，一旦写入了数据比如一个字节，整形数据，那么position的值就会指向数据之后的一个单元，position最大可以到capacity-1.&lt;/p&gt;
&lt;p&gt;当从Buffer读取数据时，也需要从一个确定的位置开始。buffer从写入模式变为读取模式时，position会归零，每次读取后，position向后移动。&lt;/p&gt;
&lt;p&gt;上限（Limit）&lt;/p&gt;
&lt;p&gt;在写模式，limit的含义是我们所能写入的最大数据量。它等同于buffer的容量。&lt;/p&gt;
&lt;p&gt;一旦切换到读模式，limit则代表我们所能读取的最大数据量，他的值等同于写模式下position的位置。&lt;/p&gt;
&lt;p&gt;数据读取的上限时buffer中已有的数据，也就是limit的位置（原写模式下position所指的位置）。&lt;/p&gt;
&lt;p&gt;Buffer Types&lt;/p&gt;
&lt;p&gt;Java NIO有如下具体的Buffer类型：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ByteBuffer&lt;/li&gt;
&lt;li&gt;MappedByteBuffer&lt;/li&gt;
&lt;li&gt;CharBuffer&lt;/li&gt;
&lt;li&gt;DoubleBuffer&lt;/li&gt;
&lt;li&gt;FloatBuffer&lt;/li&gt;
&lt;li&gt;IntBuffer&lt;/li&gt;
&lt;li&gt;LongBuffer&lt;/li&gt;
&lt;li&gt;ShortBuffer&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正如你看到的，Buffer的类型代表了不同数据类型，换句话说，Buffer中的数据可以是上述的基本类型；&lt;/p&gt;
&lt;p&gt;分配一个Buffer（Allocating a Buffer）&lt;/p&gt;
&lt;p&gt;为了获取一个Buffer对象，你必须先分配。每个Buffer实现类都有一个allocate()方法用于分配内存。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
    CharBuffer charBuffer = CharBuffer.allocate(48);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;写入数据到Buffer（Writing Data to a Buffer）&lt;/p&gt;
&lt;p&gt;写数据到Buffer有两种方法：&lt;/p&gt;
&lt;ul readability=&quot;1.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从Channel中写数据到Buffer&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;手动写数据到Buffer，调用put方法&lt;/p&gt;
&lt;p&gt;//从Channel中写数据到Buffer&lt;br/&gt;int read = fileChannel.read(byteBuffer);&lt;br/&gt;//调用put方法写&lt;br/&gt;buf.put(3);&lt;br/&gt;//把数据写到特定的位置&lt;br/&gt;public ByteBuffer put(int i, byte x);&lt;br/&gt;//把一个具体类型数据写入buffer&lt;br/&gt;public ByteBuffer putInt(int x)；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;flip()——翻转&lt;/p&gt;
&lt;p&gt;flip()方法可以把Buffer从写模式切换到读模式。调用flip方法会把position归零，并设置limit为之前的position的值。 也就是说，现在position代表的是读取位置，limit标示的是已写入的数据位置。&lt;/p&gt;
&lt;p&gt;从Buffer读取数据（Reading Data from a Buffer）&lt;/p&gt;
&lt;p&gt;冲Buffer读数据也有两种方式。&lt;/p&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;从buffer读数据到channel。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;从buffer直接读取数据，调用get方法。&lt;/p&gt;
&lt;p&gt;//读取数据到channel的例子：&lt;br/&gt;int bytesWritten = inChannel.write(buf);&lt;br/&gt;//调用get读取数据的例子：&lt;br/&gt;byte aByte = buf.get();&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;rewind()——倒带&lt;/p&gt;
&lt;p&gt;Buffer.rewind()方法将position置为0，这样我们可以重复读取buffer中的数据。limit保持不变。&lt;/p&gt;
&lt;p&gt;clear() and compact()&lt;/p&gt;
&lt;p&gt;一旦我们从buffer中读取完数据，需要复用buffer为下次写数据做准备。只需要调用clear或compact方法。&lt;/p&gt;
&lt;p&gt;clear方法会重置position为0，limit为capacity，也就是整个Buffer清空。实际上Buffer中数据并没有清空，我们只是把标记为修改了。（重新写入的时候这些存在的数据就会被新的数据覆盖）&lt;/p&gt;
&lt;p&gt;如果Buffer还有一些数据没有读取完，调用clear就会导致这部分数据被“遗忘”，因为我们没有标记这部分数据未读。&lt;/p&gt;
&lt;p&gt;针对这种情况，如果需要保留未读数据，那么可以使用compact（）。 因此compact()和clear()的区别就在于对未读数据的处理，是保留这部分数据还是一起清空。&lt;/p&gt;
&lt;p&gt;mark() and reset()&lt;/p&gt;
&lt;p&gt;通过mark方法可以标记当前的position，通过reset来恢复mark的位置，这个非常像canva的save和restore：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;buffer.mark();

//call buffer.get() a couple of times, e.g. during parsing.

buffer.reset();  //set position back to mark.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;equals() and compareTo()&lt;/p&gt;
&lt;p&gt;可以用eqauls和compareTo比较两个buffer&lt;/p&gt;
&lt;p&gt;equals()&lt;/p&gt;
&lt;p&gt;判断两个buffer相对，需满足：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类型相同&lt;/li&gt;
&lt;li&gt;buffer中剩余字节数相同&lt;/li&gt;
&lt;li&gt;所有剩余字节相等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从上面的三个条件可以看出，equals只比较buffer中的部分内容，并不会去比较每一个元素。&lt;/p&gt;
&lt;p&gt;compareTo()&lt;/p&gt;
&lt;p&gt;compareTo也是比较buffer中的剩余元素，只不过这个方法适用于比较排序的：&lt;/p&gt;
&lt;p&gt;NIO Scatter (分散)/ Gather(聚集)&lt;/p&gt;
&lt;p&gt;——分散读和聚集写的场景。&lt;/p&gt;
&lt;p&gt;Java NIO发布时内置了对scatter / gather的支持。scatter / gather是通过通道读写数据的两个概念。&lt;/p&gt;
&lt;p&gt;Scattering read指的是从通道读取的操作能把数据写入多个buffer，也就是scatters代表了数据从一个channel到多个buffer的过程。&lt;/p&gt;
&lt;p&gt;gathering write则正好相反，表示的是从多个buffer把数据写入到一个channel中。&lt;/p&gt;
&lt;p&gt;Scatter/gather在有些场景下会非常有用，比如需要处理多份分开传输的数据。举例来说，假设一个消息包含了header和body，我们可能会把header和body保存在不同独立buffer中，这种分开处理header与body的做法会使开发更简明。&lt;/p&gt;
&lt;p&gt;Scattering Reads&lt;/p&gt;
&lt;p&gt;&quot;scattering read&quot;是把数据从单个Channel写入到多个buffer，下面是示意图：&lt;/p&gt;
&lt;p&gt;观察代码可以发现，我们把多个buffer写在了一个数组中，然后把数组传递给channel.read()方法。read()方法内部会负责把数据按顺序写进传入的buffer数组内。一个buffer写满后，接着写到下一个buffer中。&lt;/p&gt;
&lt;p&gt;实际上，scattering read内部必须写满一个buffer后才会向后移动到下一个buffer，因此这并不适合消息大小会动态改变的部分，也就是说，如果你有一个header和body，并且header有一个固定的大小（比如128字节）,这种情形下可以正常工作。&lt;/p&gt;
&lt;p&gt;athering Writes&lt;/p&gt;
&lt;p&gt;&quot;gathering write&quot;把多个buffer的数据写入到同一个channel中.&lt;/p&gt;
&lt;p&gt;似的传入一个buffer数组给write，内部机会按顺序将数组内的内容写进channel，这里需要注意，写入的时候针对的是buffer中position到limit之间的数据。也就是如果buffer的容量是128字节，但它只包含了58字节数据，那么写入的时候只有58字节会真正写入。因此gathering write是可以适用于可变大小的message的，这和scattering reads不同。&lt;/p&gt;
&lt;p&gt;NIO Channel to Channel Transfers通道传输接口&lt;/p&gt;
&lt;p&gt;在Java NIO中如果一个channel是FileChannel类型的，那么他可以直接把数据传输到另一个channel。这个特性得益于FileChannel包含的transferTo和transferFrom两个方法。&lt;/p&gt;
&lt;p&gt;transferFrom()——目标channel用，参数为源数据channel。&lt;/p&gt;
&lt;p&gt;transferFrom的参数position和count表示目标文件的写入位置和最多写入的数据量。如果通道源的数据小于count那么就传实际有的数据量。 另外，有些SocketChannel的实现在传输时只会传输哪些处于就绪状态的数据，即使SocketChannel后续会有更多可用数据。因此，这个传输过程可能不会传输整个的数据。&lt;/p&gt;
&lt;p&gt;transferTo()——源数据用，参数为目标channel&lt;/p&gt;
&lt;p&gt;SocketChannel的问题也存在于transferTo.SocketChannel的实现可能只在发送的buffer填充满后才发送，并结束。&lt;/p&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ChannelTransferTest {

    public static void main(String[] args) throws IOException {
        RandomAccessFile fromfile = new RandomAccessFile(&quot;D:\\text\\1_loan.sql&quot;, &quot;rw&quot;);
        //mode只有4中，如果不是读写的mode或者给的不是4种中的，就会报错。
        RandomAccessFile toFile = new RandomAccessFile(&quot;D:\\text\\1_loan_copy.sql&quot;, &quot;rw&quot;);

        FileChannel fromfileChannel = fromfile.getChannel();
        FileChannel toFileChannel = toFile.getChannel();
        //==========================transferTo=================================
        //transferTo方法把fromfileChannel数据传输到另一个toFileChannel
        //long transferSize = fromfileChannel.transferTo(0, fromfileChannel.size(), toFileChannel);
        //System.out.println(transferSize);

        //=============================transferFrom==============================
        //把数据从通道源传输到toFileChannel,相比通过buffer读写更加的便捷
        long transferSize1 = toFileChannel.transferFrom(fromfileChannel, 0, fromfileChannel.size());
        //参数position和count表示目标文件的写入位置和最多写入的数据量
        //long transferSize1 = toFileChannel.transferFrom(fromfileChannel, 0, fromfileChannel.size()-1000);
        //如果通道源的数据小于count那么就传实际有的数据量。
        //long transferSize1 = toFileChannel.transferFrom(fromfileChannel, 0, fromfileChannel.size()+1000);
        System.out.println(transferSize1);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NIO Selector选择器&lt;/p&gt;
&lt;p&gt;Selector是Java NIO中的一个组件，用于检查一个或多个NIO Channel的状态是否处于可读、可写。如此可以实现单线程管理多个channels,也就是可以管理多个网络链接。&lt;/p&gt;
&lt;p&gt;为什么使用Selector&lt;/p&gt;
&lt;p&gt;用单线程处理多个channels的好处是我需要更少的线程来处理channel。实际上，你甚至可以用一个线程来处理所有的channels。从操作系统的角度来看，切换线程开销是比较昂贵的，并且每个线程都需要占用系统资源，因此暂用线程越少越好。&lt;/p&gt;
&lt;p&gt;需要留意的是，现代操作系统和CPU在多任务处理上已经变得越来越好，所以多线程带来的影响也越来越小。如果一个CPU是多核的，如果不执行多任务反而是浪费了机器的性能。不过这些设计讨论是另外的话题了。简而言之，通过Selector我们可以实现单线程操作多个channel。&lt;/p&gt;
&lt;p&gt;创建Selector&lt;/p&gt;
&lt;p&gt;创建一个Selector可以通过Selector.open()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Selector selector = Selector.open();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注册Channel到Selector上&lt;/p&gt;
&lt;p&gt;先把Channel注册到Selector上，这个操作使用SelectableChannel的register()。SocketChannel等都有继承此抽象类。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;channel.configureBlocking(false);
SelectionKey key = channel.register(selector, SelectionKey.OP_READ);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Channel必须是非阻塞的。所以FileChannel不适用Selector，因为FileChannel不能切换为非阻塞模式。Socket channel可以正常使用。&lt;/p&gt;
&lt;p&gt;注意register的第二个参数，这个参数是一个“关注集合”，代表我们关注的channel状态，有四种基础类型可供监听：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Connect——连接就绪&lt;/li&gt;
&lt;li&gt;Accept——可连接就绪&lt;/li&gt;
&lt;li&gt;Read——读就绪&lt;/li&gt;
&lt;li&gt;Write——写就绪&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;一个channel触发了一个事件也可视作该事件处于就绪状态。因此当channel与server连接成功后，那么就是“连接就绪”状态。server channel接收请求连接时处于“可连接就绪”状态。channel有数据可读时处于“读就绪”状态。channel可以进行数据写入时处于“写就绪”状态。&lt;/p&gt;
&lt;p&gt;上述的四种就绪状态用SelectionKey中的常量表示如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;SelectionKey.OP_CONNECT&lt;/li&gt;
&lt;li&gt;SelectionKey.OP_ACCEPT&lt;/li&gt;
&lt;li&gt;SelectionKey.OP_READ&lt;/li&gt;
&lt;li&gt;SelectionKey.OP_WRITE&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果对多个事件感兴趣可利用位的或运算结合多个常量，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int interestSet = SelectionKey.OP_READ | SelectionKey.OP_WRITE;  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SelectionKey's&lt;/p&gt;
&lt;p&gt;在上一小节中，我们利用register方法把Channel注册到了Selectors上，这个方法的返回值是SelectionKeys，这个返回的对象包含了一些比较有价值的属性：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;The interest set&lt;/li&gt;
&lt;li&gt;The ready set&lt;/li&gt;
&lt;li&gt;The Channel&lt;/li&gt;
&lt;li&gt;The Selector&lt;/li&gt;
&lt;li&gt;An attached object (optional)&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Interest Set&lt;/p&gt;
&lt;p&gt;这个“关注集合”实际上就是我们希望处理的事件的集合，它的值就是注册时传入的参数，我们可以用按为与运算把每个事件取出来：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int interestSet = selectionKey.interestOps();

boolean isInterestedInAccept  = interestSet &amp;amp; SelectionKey.OP_ACCEPT;
boolean isInterestedInConnect = interestSet &amp;amp; SelectionKey.OP_CONNECT;
boolean isInterestedInRead    = interestSet &amp;amp; SelectionKey.OP_READ;
boolean isInterestedInWrite   = interestSet &amp;amp; SelectionKey.OP_WRITE; 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Ready Set&lt;/p&gt;
&lt;p&gt;&quot;就绪集合&quot;中的值是当前channel处于就绪的值，一般来说在调用了select方法后都会需要用到就绪状态&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int readySet = selectionKey.readyOps();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从“就绪集合”中取值的操作类似于“关注集合”的操作，当然还有更简单的方法，SelectionKey提供了一系列返回值为boolean的的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;selectionKey.isAcceptable();
selectionKey.isConnectable();
selectionKey.isReadable();
selectionKey.isWritable();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Channel + Selector&lt;/p&gt;
&lt;p&gt;从SelectionKey操作Channel和Selector非常简单：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Channel  channel  = selectionKey.channel();
Selector selector = selectionKey.selector();  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Attaching Objects&lt;/p&gt;
&lt;p&gt;我们可以给一个SelectionKey附加一个Object，这样做一方面可以方便我们识别某个特定的channel，同时也增加了channel相关的附加信息。例如，可以把用于channel的buffer附加到SelectionKey上：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;selectionKey.attach(theObject);

Object attachedObj = selectionKey.attachment();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;附加对象的操作也可以在register的时候就执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从Selector中选择channel&lt;/p&gt;
&lt;p&gt;一旦我们向Selector注册了一个或多个channel后，就可以调用select来获取channel。select方法会返回所有处于就绪状态的channel。 select方法具体如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;int select()&lt;/li&gt;
&lt;li&gt;int select(long timeout)&lt;/li&gt;
&lt;li&gt;int selectNow()&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;select()方法在返回channel之前处于阻塞状态。 select(long timeout)和select做的事一样，不过他的阻塞有一个超时限制。&lt;/p&gt;
&lt;p&gt;selectNow()不会阻塞，根据当前状态立刻返回合适的channel。&lt;/p&gt;
&lt;p&gt;select()方法的返回值是一个int整形，代表有多少channel处于就绪了。也就是自上一次select后有多少channel进入就绪。举例来说，假设第一次调用select时正好有一个channel就绪，那么返回值是1，并且对这个channel做任何处理，接着再次调用select，此时恰好又有一个新的channel就绪，那么返回值还是1，现在我们一共有两个channel处于就绪，但是在每次调用select时只有一个channel是就绪的。&lt;/p&gt;
&lt;p&gt;selectedKeys()&lt;/p&gt;
&lt;p&gt;在调用select并返回了有channel就绪之后，可以通过选中的key集合来获取channel，这个操作通过调用selectedKeys()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Set&amp;lt;SelectionKey&amp;gt; selectedKeys = selector.selectedKeys();    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;还记得在register时的操作吧，我们register后的返回值就是SelectionKey实例，也就是我们现在通过selectedKeys()方法所返回的SelectionKey。&lt;/p&gt;
&lt;p&gt;遍历这些SelectionKey可以通过如下方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Set&amp;lt;SelectionKey&amp;gt; selectedKeys = selector.selectedKeys();

Iterator&amp;lt;SelectionKey&amp;gt; keyIterator = selectedKeys.iterator();

while(keyIterator.hasNext()) {

    SelectionKey key = keyIterator.next();

    if(key.isAcceptable()) {
        // a connection was accepted by a ServerSocketChannel.

    } else if (key.isConnectable()) {
        // a connection was established with a remote server.

    } else if (key.isReadable()) {
        // a channel is ready for reading

    } else if (key.isWritable()) {
        // a channel is ready for writing
    }

    keyIterator.remove();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述循环会迭代key集合，针对每个key我们单独判断他是处于何种就绪状态。&lt;/p&gt;
&lt;p&gt;注意：keyIterater.remove()方法的调用，Selector本身并不会移除SelectionKey对象，这个操作需要我们手动执行。当下次channel处于就绪是，Selector任然会吧这些key再次加入进来。&lt;/p&gt;
&lt;p&gt;SelectionKey.channel返回的channel实例需要强转为我们实际使用的具体的channel类型，例如ServerSocketChannel或SocketChannel.&lt;/p&gt;
&lt;p&gt;wakeUp()&lt;/p&gt;
&lt;p&gt;由于调用select而被阻塞的线程，可以通过调用Selector.wakeup()来唤醒即便此时已然没有channel处于就绪状态。具体操作是，在另外一个线程调用wakeup，被阻塞与select方法的线程就会立刻返回。&lt;/p&gt;
&lt;p&gt;close()&lt;/p&gt;
&lt;p&gt;当操作Selector完毕后，需要调用close方法。close的调用会关闭Selector并使相关的SelectionKey都无效。channel本身不会被关闭。&lt;/p&gt;
&lt;p&gt;示例：首先打开一个Selector,然后注册channel，最后监听Selector的状态。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class NIOServer {

    public static void main(String[] args) throws IOException {

        // 1.获取通道
        ServerSocketChannel server = ServerSocketChannel.open();

        // 2.切换成非阻塞模式
        server.configureBlocking(false);

        // 3. 绑定连接
        server.bind(new InetSocketAddress(6666));

        // 4. 获取选择器
        Selector selector = Selector.open();

        // 4.1将通道注册到选择器上，指定接收“监听通道”事件
        server.register(selector, SelectionKey.OP_ACCEPT);

        // 5. 轮训地获取选择器上已“就绪”的事件---&amp;gt;只要select()&amp;gt;0，说明已就绪
        while (selector.select() &amp;gt; 0) {
            // 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件)
            Iterator&amp;lt;SelectionKey&amp;gt; iterator = selector.selectedKeys().iterator();

            // 7. 获取已“就绪”的事件，(不同的事件做不同的事)
            while (iterator.hasNext()) {

                SelectionKey selectionKey = iterator.next();

                // 接收事件就绪
                if (selectionKey.isAcceptable()) {

                    // 8. 获取客户端的链接
                    SocketChannel client = server.accept();

                    // 8.1 切换成非阻塞状态
                    client.configureBlocking(false);

                    // 8.2 注册到选择器上--&amp;gt;拿到客户端的连接为了读取通道的数据(监听读就绪事件)
                    client.register(selector, SelectionKey.OP_READ);

                } else if (selectionKey.isReadable()) { // 读事件就绪

                    // 9. 获取当前选择器读就绪状态的通道
                    SocketChannel client = (SocketChannel) selectionKey.channel();

                    // 9.1读取数据
                    ByteBuffer buffer = ByteBuffer.allocate(1024);

                    // 9.2得到文件通道，将客户端传递过来的图片写到本地项目下(写模式、没有则创建)
                    FileChannel outChannel = FileChannel.open(Paths.get(&quot;2_loan.sql&quot;), StandardOpenOption.WRITE, StandardOpenOption.CREATE);

                    while (client.read(buffer) &amp;gt; 0) {
                        // 在读之前都要切换成读模式
                        buffer.flip();

                        outChannel.write(buffer);

                        // 读完切换成写模式，能让管道继续读取文件的数据
                        buffer.clear();
                    }
                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                    byteBuffer.put(&quot;yeah,i know,i got your message!&quot;.getBytes());
                    byteBuffer.flip();
                    client.write(byteBuffer);
                }
                // 10. 取消选择键(已经处理过的事件，就应该取消掉了)
                iterator.remove();
            }
        }
    }
}

public class NIOClientTwo {

    public static void main(String[] args) throws IOException {

        // 1. 获取通道
        SocketChannel socketChannel = SocketChannel.open(new InetSocketAddress(&quot;127.0.0.1&quot;, 6666));

        // 1.1切换成非阻塞模式
        socketChannel.configureBlocking(false);

        // 1.2获取选择器
        Selector selector = Selector.open();

        // 1.3将通道注册到选择器中，获取服务端返回的数据
        socketChannel.register(selector, SelectionKey.OP_READ);

        // 2. 发送一张图片给服务端吧
        FileChannel fileChannel = FileChannel.open(Paths.get(&quot;D:\\text\\1_loan.sql&quot;), StandardOpenOption.READ);

        // 3.要使用NIO，有了Channel，就必然要有Buffer，Buffer是与数据打交道的呢
        ByteBuffer buffer = ByteBuffer.allocate(1024);

        // 4.读取本地文件(图片)，发送到服务器
        while (fileChannel.read(buffer) != -1) {

            // 在读之前都要切换成读模式
            buffer.flip();

            socketChannel.write(buffer);

            // 读完切换成写模式，能让管道继续读取文件的数据
            buffer.clear();
        }


        // 5. 轮训地获取选择器上已“就绪”的事件---&amp;gt;只要select()&amp;gt;0，说明已就绪
        while (selector.select() &amp;gt; 0) {
            // 6. 获取当前选择器所有注册的“选择键”(已就绪的监听事件)
            Iterator&amp;lt;SelectionKey&amp;gt; iterator = selector.selectedKeys().iterator();

            // 7. 获取已“就绪”的事件，(不同的事件做不同的事)
            while (iterator.hasNext()) {

                SelectionKey selectionKey = iterator.next();

                // 8. 读事件就绪
                if (selectionKey.isReadable()) {

                    // 8.1得到对应的通道
                    SocketChannel channel = (SocketChannel) selectionKey.channel();

                    ByteBuffer responseBuffer = ByteBuffer.allocate(1024);

                    // 9. 知道服务端要返回响应的数据给客户端，客户端在这里接收
                    int readBytes = channel.read(responseBuffer);

                    if (readBytes &amp;gt; 0) {
                        // 切换读模式
                        responseBuffer.flip();
                        System.out.println(new String(responseBuffer.array(), 0, readBytes));
                    }
                }
                // 10. 取消选择键(已经处理过的事件，就应该取消掉了)
                iterator.remove();
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NIO FileChannel文件通道&lt;/p&gt;
&lt;p&gt;Java NIO中的FileChannel是用于连接文件的通道。通过文件通道可以读、写文件的数据。Java NIO的FileChannel是相对标准Java IO API的可选接口。&lt;/p&gt;
&lt;p&gt;FileChannel不可以设置为非阻塞模式，他只能在阻塞模式下运行。&lt;/p&gt;
&lt;p&gt;打开文件通道&lt;/p&gt;
&lt;p&gt;在使用FileChannel前必须打开通道，打开一个文件通道需要通过输入/输出流或者RandomAccessFile，下面是通过RandomAccessFile打开文件通道的案例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;RandomAccessFile aFile = new RandomAccessFile(&quot;D:\text\1_loan.sql&quot;, &quot;rw&quot;);
FileChannel inChannel = aFile.getChannel();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从文件通道内读取数据&lt;/p&gt;
&lt;p&gt;读取文件通道的数据可以通过read方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ByteBuffer buf = ByteBuffer.allocate(48);
int bytesRead = inChannel.read(buf);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先开辟一个Buffer，从通道中读取的数据会写入Buffer内。接着就可以调用read方法，read的返回值代表有多少字节被写入了Buffer，返回-1则表示已经读取到文件结尾了。&lt;/p&gt;
&lt;p&gt;向文件通道写入数据&lt;/p&gt;
&lt;p&gt;写数据用write方法，入参是Buffer：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

buf.flip();

while(buf.hasRemaining()) {
    channel.write(buf);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里的write调用写在了wihle循环汇总，这是因为write不能保证有多少数据真实被写入，因此需要循环写入直到没有更多数据。&lt;/p&gt;
&lt;p&gt;关闭通道&lt;/p&gt;
&lt;p&gt;操作完毕后，需要把通道关闭：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;channel.close();    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FileChannel Position&lt;/p&gt;
&lt;p&gt;当操作FileChannel的时候读和写都是基于特定起始位置的（position），获取当前的位置可以用FileChannel的position()方法，设置当前位置可以用带参数的position(long pos)方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//获取当前的位置
long position = fileChannel.position();
//设置当前位置为pos +123
fileChannel.position(pos +123);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设我们把当前位置设置为文件结尾之后，那么当我们视图从通道中读取数据时就会发现返回值是-1，表示已经到达文件结尾了。 如果把当前位置设置为文件结尾之后，再向通道中写入数据，文件会自动扩展以便写入数据，但是这样会导致文件中出现类似空洞，即文件的一些位置是没有数据的。&lt;/p&gt;
&lt;p&gt;FileChannel Size&lt;/p&gt;
&lt;p&gt;size()方法可以返回FileChannel对应的文件的文件大小：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;long fileSize = channel.size();    
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FileChannel Truncate&lt;/p&gt;
&lt;p&gt;利用truncate方法可以截取指定长度的文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;FileChannel truncateFile = fileChannel.truncate(1024);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FileChannel Force&lt;/p&gt;
&lt;p&gt;force方法会把所有未写磁盘的数据都强制写入磁盘。这是因为在操作系统中出于性能考虑回把数据放入缓冲区，所以不能保证数据在调用write写入文件通道后就及时写到磁盘上了，除非手动调用force方法。 force方法需要一个布尔参数，代表是否把meta data也一并强制写入。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;channel.force(true);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NIO SocketChannel套接字通道&lt;/p&gt;
&lt;p&gt;在Java NIO体系中，SocketChannel是用于TCP网络连接的套接字接口，相当于Java网络编程中的Socket套接字接口。创建SocketChannel主要有两种方式，如下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;打开一个SocketChannel并连接网络上的一台服务器。&lt;/li&gt;
&lt;li&gt;当ServerSocketChannel接收到一个连接请求时，会创建一个SocketChannel。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;建立一个SocketChannel连接&lt;/p&gt;
&lt;p&gt;打开一个SocketChannel可以这样操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;SocketChannel socketChannel = SocketChannel.open();
socketChannel.connect(new InetSocketAddress(&quot;http://www.google.com&quot;, 80));  
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关闭一个SocketChannel连接&lt;/p&gt;
&lt;p&gt;关闭一个SocketChannel只需要调用他的close方法，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;socketChannel.close();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从SocketChannel中读数据&lt;/p&gt;
&lt;p&gt;从一个SocketChannel连接中读取数据，可以通过read()方法，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = socketChannel.read(buf);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先需要开辟一个Buffer。从SocketChannel中读取的数据将放到Buffer中。&lt;/p&gt;
&lt;p&gt;接下来就是调用SocketChannel的read()方法.这个read()会把通道中的数据读到Buffer中。read()方法的返回值是一个int数据，代表此次有多少字节的数据被写入了Buffer中。如果返回的是-1,那么意味着通道内的数据已经读取完毕，到底了（链接关闭）。&lt;/p&gt;
&lt;p&gt;向SocketChannel写数据&lt;/p&gt;
&lt;p&gt;向SocketChannel中写入数据是通过write()方法，write也需要一个Buffer作为参数。下面看一下具体的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip();
while(buf.hasRemaining()) {
    channel.write(buf);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;非阻塞模式&lt;/p&gt;
&lt;p&gt;我们可以把SocketChannel设置为non-blocking（非阻塞）模式。这样的话在调用connect(), read(), write()时都是异步的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;socketChannel.configureBlocking(false);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;connect()&lt;/p&gt;
&lt;p&gt;如果我们设置了一个SocketChannel是非阻塞的，那么调用connect()后，方法会在链接建立前就直接返回。为了检查当前链接是否建立成功，我们可以调用finishConnect(),如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;socketChannel.configureBlocking(false);
socketChannel.connect(new InetSocketAddress(&quot;http://www.google.com&quot;, 80));

while(! socketChannel.finishConnect() ){
    //wait, or do something else...    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;write()&lt;/p&gt;
&lt;p&gt;在非阻塞模式下，调用write()方法不能确保方法返回后写入操作一定得到了执行。因此我们需要把write()调用放到循环内。这和前面在讲write()时是一样的，此处就不在代码演示。&lt;/p&gt;
&lt;p&gt;read()&lt;/p&gt;
&lt;p&gt;在非阻塞模式下，调用read()方法也不能确保方法返回后，确实读到了数据。因此我们需要自己检查的整型返回值，这个返回值会告诉我们实际读取了多少字节的数据。&lt;/p&gt;
&lt;p&gt;Selector结合非阻塞模式&lt;/p&gt;
&lt;p&gt;SocketChannel的非阻塞模式可以和Selector很好的协同工作。把一个或多个SocketChannel注册到一个Selector后，我们可以通过Selector指导哪些channels通道是处于可读，可写等等状态的。&lt;/p&gt;
&lt;p&gt;NIO ServerSocketChannel服务端套接字通道&lt;/p&gt;
&lt;p&gt;在Java NIO中，ServerSocketChannel是用于监听TCP链接请求的通道，正如Java网络编程中的ServerSocket一样。&lt;/p&gt;
&lt;p&gt;ServerSocketChannel实现类位于java.nio.channels包下面。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;void test() throws IOException {
    //打开一个ServerSocketChannel我们需要调用他的open()方法
    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.socket().bind(new InetSocketAddress(9999));
    while(true) {
        SocketChannel socketChannel = serverSocketChannel.accept();
        //do something with socketChannel...
        if (socketChannel.isConnected()) {
            break;
        }
    }
    //关闭一个ServerSocketChannel我们需要调用close()方法
    serverSocketChannel.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;监听链接&lt;/p&gt;
&lt;p&gt;通过调用accept()方法，我们就开始监听端口上的请求连接。当accept()返回时，他会返回一个SocketChannel连接实例，实际上accept()是阻塞操作，他会阻塞带去线程知道返回一个连接； 很多时候我们是不满足于监听一个连接的，因此我们会把accept()的调用放到循环中，就像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;while(true){
    SocketChannel socketChannel = serverSocketChannel.accept();
    //do something with socketChannel...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然我们可以在循环体内加上合适的中断逻辑，而不是单纯的在while循环中写true，以此来结束循环监听；&lt;/p&gt;
&lt;p&gt;非阻塞模式&lt;/p&gt;
&lt;p&gt;实际上ServerSocketChannel是可以设置为非阻塞模式的。在非阻塞模式下，调用accept()函数会立刻返回，如果当前没有请求的链接，那么返回值为空null。因此我们需要手动检查返回的SocketChannel是否为空，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();

serverSocketChannel.socket().bind(new InetSocketAddress(9999));
//设置为非阻塞模式
serverSocketChannel.configureBlocking(false);
while(true){
    SocketChannel socketChannel = serverSocketChannel.accept();

    if(socketChannel != null){
        //do something with socketChannel...
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Non-blocking Server非阻塞服务器&lt;/p&gt;
&lt;p&gt;非阻塞服务器代码&lt;/p&gt;
&lt;p&gt;非阻塞IO通道（Non-blocking IO Pipelines）&lt;/p&gt;
&lt;p&gt;非阻塞的IO管道（Non-blocking IO Pipelines）可以看做是整个非阻塞IO处理过程的链条。包括在以非阻塞形式进行的读与写操作。&lt;/p&gt;
&lt;p&gt;一个非阻塞的IO管道不必同时需要读和写数据，通常来说有些管道只需要读数据，而另一些管道则只需写数据。&lt;/p&gt;
&lt;p&gt;当然一个非阻塞的IO管道他也可以同时从多个Channel中读取数据，例如同时从多个SocketChannel中读取数据；&lt;/p&gt;
&lt;p&gt;非阻塞和阻塞通道比较（Non-blocking vs. Blocking IO Pipelines）&lt;/p&gt;
&lt;p&gt;非阻塞IO管道和阻塞IO管道之间最大的区别是他们各自如何从Channel（套接字socket或文件file）读写数据。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;IO管道通常直接从流中（来自于socket活file的流）读取数据，然后把数据分割为连续的消息。这个处理与我们读取流信息，用tokenizer进行解析非常相似，不同的是我们在这里会把数据流分割为更大一些的消息块。&lt;/li&gt;
&lt;li&gt;一个阻塞IO管道的使用可以和输入流一样调用，每次从Channel中读取一个字节的数据，阻塞自身直到有数据可读。&lt;/li&gt;
&lt;li&gt;使用阻塞IO大大简化了Message Reader的实现成本。阻塞的Message Reader无需关注没有数据返回的情形，无需关注返回部分数据或者数据解析需要被复用的问题。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;阻塞IO通道的缺点（Blocking IO Pipeline Drawbacks）&lt;/p&gt;
&lt;p&gt;上面提到了阻塞的Message Reader易于实现，但是阻塞也给他带了不可避免的缺点，必须为每个数据数量都分配一个单独线程。原因就在于IO接口在读取数据时在有数据返回前会一直被阻塞住。这直接导致我们无法用单线程来处理一个流没有数据返回时去读取其他的流。每当一个线程尝试去读取一个流的数据，这个线程就会被阻塞直到有数据真正返回。&lt;/p&gt;
&lt;p&gt;如果这样的IO管道运用到服务器去处理高并发的链接请求，服务器将不得不为每一个到来的链接分配一个单独的线程。如果并发数不高比如每一时刻只有几百并发，也行不会有太大问题。一旦服务器的并发数上升到百万级别，这种设计就缺乏伸缩性。每个线程需要为堆栈分配320KB（32位JVM）到1024KB(64位JVM)的内存空间。这就是说如果有1,000,000个线程，需要1TB的内存。而这些在还没开始真正处理接收到的消息前就需要（消息处理中还需要为对象开辟内存）。&lt;/p&gt;
&lt;p&gt;为了减少线程数，很多服务器都设计了线程池，把所有接收到的请求放到队列内，每次读取一条连接进行处理。这种设计可以用下图表示：&lt;/p&gt;
&lt;p&gt;但是这种设计要求缓冲的连接进程发送有意义的数据。如果这些连接长时间处于非活跃的状态，那么大量非活跃的连接会阻塞线程池中的所有线程。这会导致服务器的响应速度特别慢甚至无响应。&lt;/p&gt;
&lt;p&gt;有些服务器为了减轻这个问题，采取的操作是适当增加线程池的弹性。例如，当线程池所有线程都处于饱和时，线程池可能会自动扩容，启动更多的线程来处理事务。这个解决方案会使得服务器维护大量不活跃的链接。但是需要谨记服务器所能开辟的线程数是有限制的。所有当有1,000,000个低速的链接时（大量非活跃链接时），服务器还是不具备伸缩性。&lt;/p&gt;
&lt;p&gt;基础的非阻塞通道设计（Basic Non-blocking IO Pipeline Design）&lt;/p&gt;
&lt;p&gt;一个非阻塞的IO通道可以用单线程读取多个数据流。这个前提是相关的流可以切换为非阻塞模式（并不是所有流都可以以非阻塞形式操作，FileChannel就不能切换非阻塞模式）。在非阻塞模式下，读取一个流可能返回0个或多个字节。如果流还没有可供读取的数据那么就会返回0，其他大于1的返回都表明这是实际读取到的数据；&lt;/p&gt;
&lt;p&gt;为了避开没有数据可读的流，我们结合Java NIO中的Selector。一个Selector可以注册多个SelectableChannel实例。当我们调用select()或selectorNow()方法时Selector会返回一个有数据可读的SelectableChannel实例。这个设计可以如下插图：&lt;/p&gt;
&lt;p&gt;读取部分信息(Reading Partial Messages)&lt;/p&gt;
&lt;p&gt;当我们冲SelectableChannel中读取一段数据后，我们并不知道这段数据是否是完整的一个message。因为一个数据段可能包含部分message，也就是说即可能少于一个message，也可能多一个message（0到多个message），正如下面这张插图所示意的那样：&lt;/p&gt;
&lt;p&gt;要处理这种截断的message，我们会遇到两个问题（非阻塞读取数据时）：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;检测数据段中是否包含一个完整的message&lt;/li&gt;
&lt;li&gt;在message剩余部分获取到之前，我们如何处理不完整的message&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;检测完整message要求Message Reader查看数据段中的数据是否至少包含一个完整的message。如果包含一个或多个完整message，这些message可以被下发到通道中处理。查找完整message的过程是个大量重复的操作，所以这个操作必须是越快越好的。&lt;/p&gt;
&lt;p&gt;当数据段中有一个不完整的message时，无论不完整消息是整个数据段还是说在完整message前后，这个不完整的message数据都需要在剩余部分获得前存储起来。&lt;/p&gt;
&lt;p&gt;检查message完整性和存储不完整message都是Message Reader的职责。为了避免混淆来自不同Channel的数据，我们为每一个Channel分配一个Message Reader。整个设计大概是这样的：&lt;/p&gt;
&lt;p&gt;当我们通过Selector获取到一个有数据可以读取的Channel之后，该Channel关联的Message Reader会读取数据，并且把数据打断为Message块。得到完整的message后就可以通过通道下发到其他组件进行处理。&lt;/p&gt;
&lt;p&gt;一个Message Reader自然是协议相关的。他需要知道message的格式以便读取。如果我们的服务器是跨协议复用的，那他必须实现Message Reader的协议-大致类似于接收一个Message Reader工厂作为配置参数。&lt;/p&gt;
&lt;p&gt;存储不完整的Message（Storing Partial Messages）&lt;/p&gt;
&lt;p&gt;现在我们已经明确了由Message Reader负责不完整消息的存储直到接收到完整的消息。现在我们还需要知道这个存储过程需要如何来实现。&lt;/p&gt;
&lt;p&gt;在设计的时候我们需要考虑两个关键因素：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;我们希望在拷贝消息数据的时候数据量能尽可能的小，拷贝量越大则性能相对越低；&lt;/li&gt;
&lt;li&gt;我们希望完整的消息是以顺序的字节存储，这样方便进行数据的解析；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;为每个Message Reade分配Buffer（A Buffer Per Message Reader）&lt;/p&gt;
&lt;p&gt;固定大小buffer&lt;/p&gt;
&lt;p&gt;显然不完整的消息数据需要存储在某种buffer中。比较直接的办法是我们为每个Message Reader都分配一个内部的buffer成员。但是，多大的buffer才合适呢？这个buffer必须能存储下一个message最大的大小。如果一个message最大是1MB，那每个Message Reader内部的buffer就至少有1MB大小。&lt;/p&gt;
&lt;p&gt;在百万级别的并发链接数下，1MB的buffer基本没法正常工作。举例来说，1,000,000 x 1MB就是1TB的内存大小！如果消息的最大数据量是16MB又需要多少内存呢？128MB呢？&lt;/p&gt;
&lt;p&gt;缺点：这种直接分配一个message最大的大小值的buffer是非常浪费空间的。&lt;/p&gt;
&lt;p&gt;可伸缩Buffer（Resizable Buffers）&lt;/p&gt;
&lt;p&gt;另一个方案是在每个Message Reader内部维护一个容量可变的buffer。一个可变的buffer在初始化时占用较少空间，在消息变得很大超出容量时自动扩容。这样每个链接就不需要都占用比如1MB的空间。每个链接只使用承载下一个消息所必须的内存大小。&lt;/p&gt;
&lt;p&gt;容量可变的buffer优点就是高效利用内存空间，不会浪费内存。&lt;/p&gt;
&lt;p&gt;要实现一个可伸缩的buffer有几种不同的办法。每一种都有它的优缺点，下面几个小结我会逐一讨论它们。&lt;/p&gt;
&lt;p&gt;拷贝扩容（Resize by Copy）&lt;/p&gt;
&lt;p&gt;第一种实现可伸缩buffer的办法是初始化buffer的时候只申请较少的空间，比如4KB。如果消息超出了4KB的大小那么开赔一个更大的空间，比如8KB，然后把4KB中的数据拷贝纸8KB的内存块中。&lt;/p&gt;
&lt;p&gt;拷贝方式扩容的优点：一个消息的全部数据都被保存在了一个连续的字节数组中。这使得数据解析变得更加容易。&lt;/p&gt;
&lt;p&gt;缺点：会增加大量的数据拷贝操作。&lt;/p&gt;
&lt;p&gt;拷贝扩容操作举例分析：&lt;/p&gt;
&lt;p&gt;为了减少数据的拷贝操作，你可以分析整个消息流中的消息大小，一次来找到最适合当前机器的可以减少拷贝操作的buffer大小。例如，你可能会注意到觉大多数的消息都是小于4KB的，因为他们仅仅包含了一个非常请求和响应。这意味着消息的处所荣校应该设置为4KB。&lt;/p&gt;
&lt;p&gt;同时，你可能会发现如果一个消息大于4KB，很可能是因为他包含了一个文件。你会可能注意到 大多数通过系统的数据都是小于128KB的。所以我们可以在第一次扩容设置为128KB。&lt;/p&gt;
&lt;p&gt;最后你可能会发现当一个消息大于128KB后，没有什么规律可循来确定下次分配的空间大小，这意味着最后的buffer容量应该设置为消息最大的可能数据量。&lt;/p&gt;
&lt;p&gt;结合这三次扩容时的大小设置，可以一定程度上减少数据拷贝。4KB以下的数据无需拷贝。在1百万的连接下需要的空间例如1,000,000x4KB=4GB，目前（2015）大多数服务器都扛得住。4KB到128KB会仅需拷贝一次，即拷贝4KB数据到128KB的里面。消息大小介于128KB和最大容量的时需要拷贝两次。首先4KB数据被拷贝第二次是拷贝128KB的数据，所以总共需要拷贝132KB数据。假设没有很多的消息会超过128KB，那么这个方案还是可以接受的。&lt;/p&gt;
&lt;p&gt;当一个消息被完整的处理完毕后，它占用的内容应当即刻被释放。这样下一个来自同一个链接通道的消息可以从最小的buffer大小重新开始。这个操作是必须的如果我们需要尽可能高效地复用不同链接之间的内存。大多数情况下并不是所有的链接都会在同一时刻需要大容量的buffer。&lt;/p&gt;
&lt;p&gt;笔者写了一个完整的教程阐述了如何实现一个内存buffer使其支持扩容：Resizable Arrays 。这个教程也附带了一个指向GitHub上的源码仓地址，里面有实现方案的具体代码。&lt;/p&gt;
&lt;p&gt;追加扩容（Resize by Append）&lt;/p&gt;
&lt;p&gt;另一种实现buffer扩容的方案是让buffer包含几个数组。当需要扩容的时候只需要在开辟一个新的字节数组，然后把内容写到里面去。&lt;/p&gt;
&lt;p&gt;这种扩容也有两个具体的办法。一种是开辟单独的字节数组，然后用一个列表把这些独立数组关联起来。另一种是开辟一些更大的，相互共享的字节数组切片，然后用列表把这些切片和buffer关联起来。个人而言，笔者认为第二种切片方案更好一点点，但是它们之前的差异比较小&lt;/p&gt;
&lt;p&gt;这种追加扩容的方案不管是用独立数组还是切片都有一个优点，那就是写数据的时候不需要额外的拷贝操作。所有的数据可以直接从socket（Channel）中拷贝至数组活切片当中。&lt;/p&gt;
&lt;p&gt;这种方案的缺点也很明显，就是数据不是存储在一个连续的数组中。这会使得数据的解析变得更加复杂，因为解析器不得不同时查找每一个独立数组的结尾和所有数组的结尾。正因为我们需要在写数据时查找消息的结尾，这个模型在设计实现时会相对不那么容易。&lt;/p&gt;
&lt;p&gt;TLV编码消息(TLV Encoded Messages)&lt;/p&gt;
&lt;p&gt;有些协议的消息消失采用的是一种TLV格式（Type, Length, Value）。这意味着当消息到达时，消息的完整大小存储在了消息的开始部分。我们可以立刻判断为消息开辟多少内存空间。&lt;/p&gt;
&lt;p&gt;优点：TLV编码是的内存管理变得更加简单。我们可以立刻知道为消息分配多少内存。即便是不完整的消息，buffer结尾后面也不会有浪费的内存。&lt;/p&gt;
&lt;p&gt;缺点：我们需要在消息的全部数据接收到之前就开辟好需要用的所有内存。因此少量链接慢，但发送了大块数据的链接会占用较多内存，导致服务器无响应。&lt;/p&gt;
&lt;p&gt;解决上诉问题的一个变通办法是使用一种内部包含多个TLV的消息格式。这样我们为每个TLV段分配内存而不是为整个的消息分配，并且只在消息的片段到达时才分配内存。但是消息片段很大时，任然会出现一样的问题。&lt;/p&gt;
&lt;p&gt;另一个办法是为消息设置超时，如果长时间未接收到的消息（比如10-15秒）。这可以让服务器从偶发的并发处理大块消息恢复过来，不过还是会让服务器有一段时间无响应。另外恶意的DoS攻击会导致服务器开辟大量内存。&lt;/p&gt;
&lt;p&gt;TLV编码使得内存管理更加简单，这也是HTTP1.1协议让人觉得是一个不太优良的的协议的原因。正因如此，HTTP2.0协议在设计中也利用TLV编码来传输数据帧。也是因为这个原因我们设计了自己的利用TLV编码的网络协议VStack.co。&lt;/p&gt;
&lt;p&gt;写不完整的消息（Writing Partial Messages）&lt;/p&gt;
&lt;p&gt;在非阻塞IO管道中，写数据也是一个不小的挑战。当你调用一个非阻塞模式Channel的write()方法时，无法保证有多少机字节被写入了ByteBuffer中。write方法返回了实际写入的字节数，所以跟踪记录已被写入的字节数也是可行的。这就是我们遇到的问题：持续记录被写入的不完整的消息直到一个消息中所有的数据都发送完毕。&lt;/p&gt;
&lt;p&gt;为了避免多个消息传递到Message Writer超出他所能处理到Channel的量，我们需要让到达的消息进入队列。Message Writer则尽可能快的将数据写到Channel里。&lt;/p&gt;
&lt;p&gt;为了使Message Writer能够持续发送刚才已经发送了一部分的消息，Message Writer需要被一直调用，这样他就可以发送更多数据。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;如果你有大量的链接，你会持有大量的Message Writer实例。检查比如1百万的Message Writer实例是来确定他们是否处于可写状态是很慢的操作。首先，许多Message Writer可能根本就没有数据需要发送。我们不想检查这些实例。其次，不是所有的Channel都处于可写状态。我们不想浪费时间在这些非写入状态的Channel。&lt;/p&gt;
&lt;p&gt;为了检查一个Channel是否可写，可以把它注册到Selector上。但是我们不希望把所有的Channel实例都注册到Selector。试想一下，如果你有1百万的链接，这里面大部分是空闲的，把1百万链接都祖册到Selector上。然后调用select方法的时候就会有很多的Channel处于可写状态。你需要检查所有这些链接中的Message Writer以确认是否有数据可写。&lt;/p&gt;
&lt;p&gt;为了避免检查所有的这些Message Writer，以及那些根本没有消息需要发送给他们的Channel实例，我么可以采用两步策略：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当有消息写入到Message Writer中后，把它关联的Channel注册到Selector上（如果还未注册的话）。&lt;/li&gt;
&lt;li&gt;当服务器有空的时候，可以检查Selector看看注册在上面的Channel实例是否处于可写状态。每个可写的channel，使其Message Writer向Channel中写入数据。如果Message Writer已经把所有的消息都写入Channel，把Channel从Selector上解绑。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这两个小步骤确保只有有数据要写的Channel才会被注册到Selector。&lt;/p&gt;
&lt;p&gt;集成（Putting it All Together）&lt;/p&gt;
&lt;p&gt;正如你所知到的，一个被阻塞的服务器需要时刻检查当前是否有新的完整消息抵达。在一个消息被完整的收到前，服务器可能需要检查多次。检查一次是不够的。&lt;/p&gt;
&lt;p&gt;类似的，服务器也需要时刻检查当前是否有任何可写的数据。如果有的话，服务器需要检查相应的链接看他们是否处于可写状态。仅仅在消息第一次进入队列时检查是不够的，因为一个消息可能被部分写入。&lt;/p&gt;
&lt;p&gt;总而言之，一个非阻塞的服务器要三个管道，并且经常执行：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;读数据管道，用来检查打开的链接是否有新的数据到达；&lt;/li&gt;
&lt;li&gt;处理数据管道，负责处理接收到的完整消息；&lt;/li&gt;
&lt;li&gt;写数据管道，用于检查是否有数据可以写入打开的连接中；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这三个管道在循环中重复执行。你可以尝试优化它的执行。比如，如果没有消息在队列中等候，那么可以跳过写数据管道。或者，如果没有收到新的完整消息，你甚至可以跳过处理数据管道。&lt;/p&gt;
&lt;p&gt;下面这张流程图阐述了这整个服务器循环过程：&lt;/p&gt;
&lt;p&gt;服务器线程模型（Server Thread Model）&lt;/p&gt;
&lt;p&gt;我们在GitHub上的源码中实现的非阻塞IO服务使用了一个包含两条线程的线程模型。第一个线程负责从ServerSocketChannel接收到达的链接。另一个线程负责处理这些链接，包括读消息，处理消息，把响应写回到链接。这个双线程模型如下：&lt;/p&gt;
&lt;p&gt;NIO DatagramChannel数据报通道&lt;/p&gt;
&lt;p&gt;一个Java NIO DatagramChannel是一个可以发送、接收UDP数据包的通道。由于UDP是面向无连接的网络协议，我们不可用像使用其他通道一样直接进行读写数据。正确的做法是发送、接收数据包。&lt;/p&gt;
&lt;p&gt;打开一个DatagramChannel（Opening a DatagramChannel）&lt;/p&gt;
&lt;p&gt;打开一个DatagramChannel你这么操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;DatagramChannel channel = DatagramChannel.open();
channel.socket().bind(new InetSocketAddress(9999));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述示例中，我们打开了一个DatagramChannel，它可以在9999端口上收发UDP数据包。&lt;/p&gt;
&lt;p&gt;接收数据（Receiving Data）&lt;/p&gt;
&lt;p&gt;接收数据，直接调用DatagramChannel的receive()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
channel.receive(buf);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;receive()方法会把接收到的数据包中的数据拷贝至给定的Buffer中。如果数据包的内容超过了Buffer的大小，剩余的数据会被直接丢弃。&lt;/p&gt;
&lt;p&gt;发送数据（Sending Data）&lt;/p&gt;
&lt;p&gt;发送数据是通过DatagramChannel的send()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String newData = &quot;New String to wrte to file...&quot;               +System.currentTimeMillis();
ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());
buf.flip();
int byteSent = channel.send(buf, new InetSocketAddress(&quot;java.com&quot;, 80));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上述示例会把一个字符串发送到“java.com”服务器的UDP端口80.目前这个端口没有被任何程序监听，所以什么都不会发生。当发送了数据后，我们不会收到数据包是否被接收的的通知，这是由于UDP本身不保证任何数据的发送问题。&lt;/p&gt;
&lt;p&gt;链接特定机器地址（Connecting to a Specific Address）&lt;/p&gt;
&lt;p&gt;DatagramChannel实际上是可以指定到网络中的特定地址的。由于UDP是面向无连接的，这种链接方式并不会创建实际的连接，这和TCP通道类似。确切的说，他会锁定DatagramChannel,这样我们就只能通过特定的地址来收发数据包。&lt;/p&gt;
&lt;p&gt;看一个例子先：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;channel.connect(new InetSocketAddress(&quot;jenkov.com&quot;), 80));
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当连接上后，可以向使用传统的通道那样调用read()和Writer()方法。区别是数据的读写情况得不到保证。下面是几个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int bytesRead = channel.read(buf);    
int bytesWritten = channel.write(buf);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DataGramChannelClient {

    public static void main(String[] args) throws IOException {
        //open a datagramChannel
        DatagramChannel datagramChannel = DatagramChannel.open();
        try {
            //set non-blocking style
            datagramChannel.configureBlocking(false);

            //create a byteBuffer
            ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
            //get test data from console
            Scanner scanner = new Scanner(System.in);

            while (scanner.hasNext()) {
                String next = scanner.next();
                byteBuffer.put(next.getBytes());
                byteBuffer.flip();
                //Sending Data
                datagramChannel.send(byteBuffer, new InetSocketAddress(&quot;127.0.0.1&quot;, 9999));
                byteBuffer.clear();
            }
        } finally {
            datagramChannel.close();
        }
    }
}



public class DataGramChannelServer {

    public static void main(String[] args) throws IOException {
        //打开了一个DatagramChannel，它可以在9999端口上收发UDP数据包。
        DatagramChannel datagramChannel = DatagramChannel.open();
        datagramChannel.configureBlocking(false);
        datagramChannel.bind(new InetSocketAddress(9999));
        Selector selector = Selector.open();
        //注意要把数据报通道注册到selector上，否则不能检测到请求
        datagramChannel.register(selector, SelectionKey.OP_READ);

        while (selector.select() &amp;gt; 0) {
            Set&amp;lt;SelectionKey&amp;gt; selectionKeys = selector.selectedKeys();
            Iterator&amp;lt;SelectionKey&amp;gt; keyIterator = selectionKeys.iterator();
            while (keyIterator.hasNext()) {
                SelectionKey selectionKey = keyIterator.next();
                if (selectionKey.isAcceptable()) {
                    System.out.println(&quot;ready Acceptable&quot;);
                } else if (selectionKey.isReadable()) {
                    System.out.println(&quot;ready Readable&quot;);
                    ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
                    datagramChannel.receive(byteBuffer);
                    byteBuffer.flip();
                    //System.out.println(new String(byteBuffer.array()));//this(bytes, 0, bytes.length); byteBuffer不一定是读满的，所有用下面的limit
                    System.out.println(new String(byteBuffer.array(),0,byteBuffer.limit()));
                    byteBuffer.clear();
                }
            }
            keyIterator.remove();
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NIO Pipe管道&lt;/p&gt;
&lt;p&gt;一个Java NIO的管道是两个线程间单向传输数据的连接。一个管道（Pipe）有一个source channel和一个sink channel(没想到合适的中文名)。我们把数据写到sink channel中，这些数据可以同过source channel再读取出来。&lt;/p&gt;
&lt;p&gt;下面是一个管道的示意图：&lt;/p&gt;
&lt;p&gt;创建管道(Creating a Pipe)&lt;/p&gt;
&lt;p&gt;打开一个管道通过调用Pipe.open()工厂方法，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Pipe pipe = Pipe.open();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;向管道写入数据（Writing to a Pipe）&lt;/p&gt;
&lt;p&gt;向管道写入数据需要访问他的sink channel：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Pipe.SinkChannel sinkChannel = pipe.sink();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来就是调用write()方法写入数据了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String newData = &quot;New String to write to file...&quot; + System.currentTimeMillis();

ByteBuffer buf = ByteBuffer.allocate(48);
buf.clear();
buf.put(newData.getBytes());

buf.flip();

while(buf.hasRemaining()) {
    sinkChannel.write(buf);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从管道读取数据（Reading from a Pipe）&lt;/p&gt;
&lt;p&gt;类似的从管道中读取数据需要访问他的source channel：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Pipe.SourceChannel sourceChannel = pipe.source();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来调用read()方法读取数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ByteBuffer buf = ByteBuffer.allocate(48);

int bytesRead = inChannel.read(buf);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意这里read()的整形返回值代表实际读取到的字节数。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class PipeTest {

    public static void main(String[] args) throws IOException {
        Pipe pipe = Pipe.open();
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);

        //通过缓冲区向管道写入数据
        Pipe.SinkChannel sinkChannel = pipe.sink();
        byteBuffer.put(&quot;i am pipe&quot;.getBytes());
        byteBuffer.flip();
        sinkChannel.write(byteBuffer);

        //通过缓冲区从管道读数据
        //先要重置缓冲区
        byteBuffer.clear();
        Pipe.SourceChannel sourceChannel = pipe.source();
        int length = sourceChannel.read(byteBuffer);
        //缓冲区转为读模式
        byteBuffer.flip();
        System.out.println(new String(byteBuffer.array(),0,length));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NIO vs. IO&lt;/p&gt;
&lt;p&gt;问题：&lt;/p&gt;
&lt;p&gt;当学习Java的NIO和IO时，有个问题会跳入脑海当中：什么时候该用IO，什么时候用NIO？两者之间的区别，使用场景以及他们是如何影响代码设计的。&lt;/p&gt;
&lt;p&gt;NIO和IO之间的主要差异（Mian Differences Between Java NIO and IO）&lt;/p&gt;
&lt;p&gt;下面这个表格概括了NIO和IO的主要差异。我们会针对每个差异进行解释。&lt;/p&gt;
&lt;p&gt;IO NIO&lt;br/&gt;Stream oriented Buffer oriented&lt;br/&gt;Blocking IO No blocking IO&lt;br/&gt;Selectors&lt;/p&gt;
&lt;p&gt;即：&lt;/p&gt;
&lt;p&gt;IO NIO&lt;br/&gt;面向流 面向缓冲&lt;br/&gt;阻塞IO 非阻塞IO&lt;br/&gt;无 选择器&lt;/p&gt;
&lt;p&gt;面向流和面向缓冲区比较(Stream Oriented vs. Buffer Oriented)&lt;/p&gt;
&lt;p&gt;1、第一个重大差异是IO是面向流的，而NIO是面向缓冲区的。这句话是什么意思呢？&lt;/p&gt;
&lt;p&gt;Java IO面向流意思是我们每次从流当中读取一个或多个字节。怎么处理读取到的字节是我们自己的事情。他们不会再任何地方缓存。再有就是我们不能在流数据中向前后移动。如果需要向前后移动读取位置，那么我们需要首先为它创建一个缓存区。&lt;/p&gt;
&lt;p&gt;Java NIO是面向缓冲区的，这有些细微差异。数据是被读取到缓存当中以便后续加工。我们可以在缓存中向前向后移动。这个特性给我们处理数据提供了更大的弹性空间。当然我们仍然需要在使用数据前检查缓存中是否包含我们需要的所有数据。另外需要确保在往缓冲中写入数据时避免覆盖了已经写入但是还未被处理的数据。&lt;/p&gt;
&lt;p&gt;2、阻塞和非阻塞IO比较（Blocking vs. No-blocking IO）&lt;/p&gt;
&lt;p&gt;Java IO的各种流都是阻塞的。这意味着一个线程一旦调用了read(),write()方法，那么该线程就被阻塞住了，直到读取到数据或者数据完整写入了。在此期间线程不能做其他任何事情。&lt;/p&gt;
&lt;p&gt;Java NIO的非阻塞模式使得线程可以通过channel来读数据，并且是返回当前已有的数据，或者什么都不返回。如果当前没有数据可读的话。这样一来线程不会被阻塞住，它可以继续向下执行其他事情。&lt;/p&gt;
&lt;p&gt;通常线程在调用非阻塞操作后，会通知处理其他channel上的IO操作。因此一个线程可以管理多个channel的输入输出。&lt;/p&gt;
&lt;p&gt;3、Selectors&lt;/p&gt;
&lt;p&gt;Java NIO的selector允许一个单一线程监听多个channel输入。我们可以注册多个channel到selector上，然后用一个线程来挑出一个处于可读或者可写状态的channel。selector机制使得单线程管理过个channel变得容易。&lt;/p&gt;
&lt;p&gt;NIO和IO是如何影响程序设计的（How NIO and IO Influences Application Design）&lt;/p&gt;
&lt;p&gt;开发中选择NIO或者IO会在多方面影响程序设计：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使用NIO、IO的API调用类&lt;/li&gt;
&lt;li&gt;数据处理&lt;/li&gt;
&lt;li&gt;处理数据需要的线程数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;API调用(The API Calls)&lt;/p&gt;
&lt;p&gt;显而易见使用NIO的API接口和使用IO时是不同的。不同于直接从InputStream读取字节，我们的数据需要先写入到buffer中，然后再从buffer中处理它们。&lt;/p&gt;
&lt;p&gt;数据处理（The Processing of Data）&lt;/p&gt;
&lt;p&gt;数据的处理方式也随着是NIO或IO而异。&lt;/p&gt;
&lt;p&gt;BIO下数据处理是阻塞的，一旦数据方法处理返回时数据就一定能读取到或写入好了，不会有只做一半的情况，且不能在流数据中向前后移动。而NIO是非阻塞的，在读取或写入数据缓冲区时是不能确定数据是否已经完整读完的，可能需要多次检查数据完整性。&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;在IO设计中，我们从InputStream或者Reader中读取字节。假设我们现在需要处理一个按行排列的文本数据，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Name: Anna
Age: 25
Email: anna@mailserver.com
Phone: 1234567890
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个处理文本行的过程大概是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;InputStream input = ... ; // get the InputStream from the client socket

BufferedReader reader = new BufferedReader(new InputStreamReader(input));

String nameLine   = reader.readLine();
String ageLine    = reader.readLine();
String emailLine  = reader.readLine();
String phoneLine  = reader.readLine();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;请注意处理状态由程序执行多久决定。换句话说，一旦reader.readLine()方法返回，你就知道肯定文本行就已读完， readline()阻塞直到整行读完，这就是原因。你也知道此行包含名称；同样，第二个readline()调用返回的时候，你知道这行包含年龄等。 正如你可以看到，该处理程序仅在有新数据读入时运行，并知道每步的数据是什么。一旦正在运行的线程已处理过读入的某些数据，该线程不会再回退数据（大多如此）。下图也说明了这条原则：&lt;/p&gt;
&lt;p&gt;而一个NIO的实现会有所不同，下面是一个简单的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ByteBuffer buffer = ByteBuffer.allocate(48); 
int bytesRead = inChannel.read(buffer); 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意第二行，从通道读取字节到ByteBuffer。当这个方法调用返回时，你不知道你所需的所有数据是否在缓冲区内。你所知道的是，该缓冲区包含一些字节，这使得处理有点困难。假设第一次 read(buffer)调用后，读入缓冲区的数据只有半行，例如，“Name:An”，你能处理数据吗？显然不能，需要等待，直到整行数据读入缓存，在此之前，对数据的任何处理毫无意义。所以，你怎么知道是否该缓冲区包含足够的数据可以处理呢？好了，你不知道。发现的方法只能查看缓冲区中的数据。其结果是，在你知道所有数据都在缓冲区里之前，你必须检查几次缓冲区的数据。这不仅效率低下，而且可以使程序设计方案杂乱不堪。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ByteBuffer buffer = ByteBuffer.allocate(48);   

int bytesRead = inChannel.read(buffer);   

while(! bufferFull(bytesRead) ) {   
       bytesRead = inChannel.read(buffer);   
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;bufferFull()方法必须跟踪有多少数据读入缓冲区，并返回真或假，这取决于缓冲区是否已满。换句话说，如果缓冲区准备好被处理，那么表示缓冲区满了。&lt;/p&gt;
&lt;p&gt;bufferFull()方法扫描缓冲区，但必须保持在bufferFull（）方法被调用之前状态相同。如果没有，下一个读入缓冲区的数据可能无法读到正确的位置。这是不可能的，但却是需要注意的又一问题。&lt;/p&gt;
&lt;p&gt;如果缓冲区已满，它可以被处理。如果它不满，并且在你的实际案例中有意义，你或许能处理其中的部分数据。但是许多情况下并非如此。下图展示了“缓冲区数据循环就绪”：&lt;/p&gt;
&lt;p&gt;小结&lt;/p&gt;
&lt;p&gt;NIO允许我们只用一条线程来管理多个通道（网络连接或文件），随之而来的代价是解析数据相对于阻塞流来说可能会变得更加的复杂。&lt;/p&gt;
&lt;p&gt;如果你需要同时管理成千上万的链接，这些链接只发送少量数据，例如聊天服务器，用NIO来实现这个服务器是有优势的。类似的，如果你需要维持大量的链接，例如P2P网络，用单线程来管理这些 链接也是有优势的。这种单线程多连接的NIO设计图：&lt;/p&gt;
&lt;p&gt;如果链接数不是很多，但是每个链接的占用较大带宽，每次都要发送大量数据，那么使用传统的IO设计服务器可能是最好的选择。下面是经典IO服务设计图：&lt;/p&gt;
&lt;p&gt;NIO Path路径&lt;/p&gt;
&lt;p&gt;Java的path接口是作为Java NIO 2的一部分是Java6,7中NIO的升级增加部分。Path在Java 7新增的。相关接口位于java.nio.file包下，所以Path接口的完整名称是java.nio.file.Path.&lt;/p&gt;
&lt;p&gt;一个Path实例代表一个文件系统内的路径。path可以指向文件也可以指向目录。可以是相对路径也可以是绝对路径。绝对路径包含了从根目录到该文件（目录）的完整路径。相对路径包含该文件（目录）相对于其他路径的路径。&lt;/p&gt;
&lt;p&gt;在很多情况下java.no.file.Path接口和java.io.File比较相似，但是他们之间存在一些细微的差异。尽管如此，在大多数情况下，我们都可以用Path接口来替换File相关类。&lt;/p&gt;
&lt;p&gt;创建Path实例（Creating a Path Instance）&lt;/p&gt;
&lt;p&gt;为了使用java.nio.file.Path实例我们必须创建Path对象。创建Path实例可以通过Paths的工厂方法get（）。&lt;/p&gt;
&lt;p&gt;注意Paths.get(&quot;c:\data\myfile.txt&quot;)的调用。这个方法会创建一个Path实例，换句话说Paths.get()是Paths的一个工厂方法。&lt;/p&gt;
&lt;p&gt;创建绝对路径（Creating an Absolute Path）&lt;/p&gt;
&lt;p&gt;创建绝对路径只需要调动Paths.get()这个工厂方法，同时传入绝对文件。这是一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path path = Paths.get(&quot;c:\\data\\myfile.txt&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对路径是c:\data\myfile.txt，里面的双斜杠\字符是Java 字符串中必须的，因为\是转义字符，表示后面跟的字符在字符串中的真实含义。双斜杠\表示\自身。&lt;/p&gt;
&lt;p&gt;上面的路径是Windows下的文件系统路径表示。在Unixx系统中（Linux, MacOS,FreeBSD等）上述的绝对路径长得是这样的：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path path = Paths.get(&quot;/home/jakobjenkov/myfile.txt&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;他的绝对路径是/home/jakobjenkov/myfile.txt。 如果在Windows机器上使用用这种路径，那么这个路径会被认为是相对于当前磁盘的。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;/home/jakobjenkov/myfile.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个路径会被理解其C盘上的文件，所以路径又变成了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;C:/home/jakobjenkov/myfile.txt
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建相对路径（Creating a Relative Path）&lt;/p&gt;
&lt;p&gt;相对路径是从一个路径（基准路径）指向另一个目录或文件的路径。完整路径实际上等同于相对路径加上基准路径。&lt;/p&gt;
&lt;p&gt;Java NIO的Path类可以用于相对路径。创建一个相对路径可以通过调用Path.get(basePath, relativePath),下面是一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path projects = Paths.get(&quot;d:\\data&quot;, &quot;projects&quot;);
Path file     = Paths.get(&quot;d:\\data&quot;, &quot;projects\\a-project\\myfile.txt&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一行创建了一个指向d:\data\projects的Path实例。第二行创建了一个指向d:\data\projects\a-project\myfile.txt的Path实例。 在使用相对路径的时候有两个特殊的符号：&lt;/p&gt;
&lt;p&gt;.表示的是当前目录，例如我们可以这样创建一个相对路径：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path currentDir = Paths.get(&quot;.&quot;);
System.out.println(currentDir.toAbsolutePath());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;currentDir的实际路径就是当前代码执行的目录。 如果在路径中间使用了.那么他的含义实际上就是目录位置自身，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path currentDir = Paths.get(&quot;d:\\data\\projects\.\a-project&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上诉路径等同于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;d:\data\projects\a-project
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;..表示父目录或者说是上一级目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path parentDir = Paths.get(&quot;..&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个Path实例指向的目录是当前程序代码的父目录。 如果在路径中间使用..那么会相应的改变指定的位置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String path = &quot;d:\\data\\projects\\a-project\\..\\another-project&quot;;
Path parentDir2 = Paths.get(path);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个路径等同于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;d:\data\projects\another-project
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;.和..也可以结合起来用，这里不过多介绍。&lt;/p&gt;
&lt;p&gt;Path.normalize()&lt;/p&gt;
&lt;p&gt;Path的normalize()方法可以把路径规范化。也就是把.和..都等价去除：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String originalPath = &quot;d:\\data\\projects\\a-project\\..\\another-project&quot;;

Path path1 = Paths.get(originalPath);
System.out.println(&quot;path1 = &quot; + path1);

Path path2 = path1.normalize();
System.out.println(&quot;path2 = &quot; + path2);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码的输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;path1 = d:\data\projects\a-project\..\another-project
path2 = d:\data\projects\another-project
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import java.nio.file.Path;
import java.nio.file.Paths;
public class PathTest {
    public static void main(String[] args) {
        //创建Path实例
        Path path = Paths.get(&quot;c:\\data\\myfile.txt&quot;);
        //创建绝对路径（Creating an Absolute Path）
        Path path1 = Paths.get(&quot;c:\\data\\myfile.txt&quot;);
        //创建相对路径
        Path path2 = Paths.get(&quot;d:\\data&quot;, &quot;projects\\a-project\\myfile.txt&quot;);
        //Path的normalize()方法可以把路径规范化
        String originalPath = &quot;d:\\data\\projects\\a-project\\..\\another-project&quot;;

        Path path3 = Paths.get(originalPath);
        System.out.println(&quot;path3 = &quot; + path3);

        Path path4 = path3.normalize();
        System.out.println(&quot;path4 = &quot; + path4);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NIO Files&lt;/p&gt;
&lt;p&gt;Java NIO中的Files类（java.nio.file.Files）提供了多种操作文件系统中文件的方法。本节教程将覆盖大部分方法。Files类包含了很多方法，所以如果本文没有提到的你也可以直接查询JavaDoc文档。&lt;/p&gt;
&lt;p&gt;java.nio.file.Files类是和java.nio.file.Path相结合使用的，所以在用Files之前确保你已经理解了Path类。&lt;/p&gt;
&lt;p&gt;Files.exists()&lt;/p&gt;
&lt;p&gt;Files.exits()方法用来检查给定的Path在文件系统中是否存在。 在文件系统中创建一个原本不存在的Path是可行的。例如，你想新建一个目录，那么先创建对应的Path实例，然后创建目录。&lt;/p&gt;
&lt;p&gt;由于Path实例可能指向文件系统中的不存在的路径，所以需要用Files.exists()来确认。&lt;/p&gt;
&lt;p&gt;下面是一个使用Files.exists()的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path path = Paths.get(&quot;data/logging.properties&quot;);

boolean pathExists =
        Files.exists(path,
            new LinkOption[]{ LinkOption.NOFOLLOW_LINKS});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个示例中，我们首先创建了一个Path对象，然后利用Files.exists()来检查这个路径是否真实存在。&lt;/p&gt;
&lt;p&gt;注意Files.exists()的的第二个参数。他是一个数组，这个参数直接影响到Files.exists()如何确定一个路径是否存在。在本例中，这个数组内包含了LinkOptions.NOFOLLOW_LINKS，表示检测时不包含符号链接文件。&lt;/p&gt;
&lt;p&gt;Files.createDirectory()&lt;/p&gt;
&lt;p&gt;Files.createDirectory()会创建Path表示的路径，下面是一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path path = Paths.get(&quot;data/subdir&quot;);

try {
    Path newDir = Files.createDirectory(path);
} catch(FileAlreadyExistsException e){
    // the directory already exists.
} catch (IOException e) {
    //something else went wrong
    e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一行创建了一个Path实例，表示需要创建的目录。接着用try-catch把Files.createDirectory()的调用捕获住。如果创建成功，那么返回值就是新创建的路径。&lt;/p&gt;
&lt;p&gt;如果目录已经存在了，那么会抛出java.nio.file.FileAlreadyExistException异常。如果出现其他问题，会抛出一个IOException。比如说，要创建的目录的父目录不存在，那么就会抛出IOException。父目录指的是你要创建的目录所在的位置。也就是新创建的目录的上一级父目录。&lt;/p&gt;
&lt;p&gt;Files.copy()&lt;/p&gt;
&lt;p&gt;Files.copy()方法可以吧一个文件从一个地址复制到另一个位置。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path sourcePath      = Paths.get(&quot;data/logging.properties&quot;);
Path destinationPath = Paths.get(&quot;data/logging-copy.properties&quot;);

try {
    Files.copy(sourcePath, destinationPath);
} catch(FileAlreadyExistsException e) {
    //destination file already exists
} catch (IOException e) {
    //something else went wrong
    e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个例子当中，首先创建了原文件和目标文件的Path实例。然后把它们作为参数，传递给Files.copy(),接着就会进行文件拷贝。&lt;/p&gt;
&lt;p&gt;如果目标文件已经存在，就会抛出java.nio.file.FileAlreadyExistsException异常。类似的目标地址路径不对，也会抛出IOException。&lt;/p&gt;
&lt;p&gt;覆盖已经存在的文件(Overwriting Existing Files)&lt;/p&gt;
&lt;p&gt;copy操作可以强制覆盖已经存在的目标文件。下面是具体的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path sourcePath      = Paths.get(&quot;data/logging.properties&quot;);
Path destinationPath = Paths.get(&quot;data/logging-copy.properties&quot;);

try {
    Files.copy(sourcePath, destinationPath,
            StandardCopyOption.REPLACE_EXISTING);
} catch(FileAlreadyExistsException e) {
    //destination file already exists
} catch (IOException e) {
    //something else went wrong
    e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意copy方法的第三个参数，这个参数决定了是否可以覆盖文件。&lt;/p&gt;
&lt;p&gt;Files.move()&lt;/p&gt;
&lt;p&gt;Java NIO的Files类也包含了移动的文件的接口。移动文件和重命名是一样的，但是还会改变文件的目录位置。java.io.File类中的renameTo()方法与之功能是一样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path sourcePath      = Paths.get(&quot;data/logging-copy.properties&quot;);
Path destinationPath = Paths.get(&quot;data/subdir/logging-moved.properties&quot;);

try {
    Files.move(sourcePath, destinationPath,
            StandardCopyOption.REPLACE_EXISTING);
} catch (IOException e) {
    //moving file failed.
    e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先创建源路径和目标路径的，原路径指的是需要移动的文件的初始路径，目标路径是指需要移动到的位置。&lt;/p&gt;
&lt;p&gt;这里move的第三个参数也允许我们覆盖已有的文件。&lt;/p&gt;
&lt;p&gt;Files.delete()&lt;/p&gt;
&lt;p&gt;Files.delete()方法可以删除一个文件或目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path path = Paths.get(&quot;data/subdir/logging-moved.properties&quot;);

try {
    Files.delete(path);
} catch (IOException e) {
    //deleting file failed
    e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先创建需要删除的文件的path对象。接着就可以调用delete了。&lt;/p&gt;
&lt;p&gt;Files.walkFileTree()&lt;/p&gt;
&lt;p&gt;Files.walkFileTree()方法具有递归遍历目录的功能。walkFileTree接受一个Path和FileVisitor作为参数。Path对象是需要遍历的目录，FileVistor则会在每次遍历中被调用。&lt;/p&gt;
&lt;p&gt;下面先来看一下FileVisitor这个接口的定义：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface FileVisitor {

    public FileVisitResult preVisitDirectory(
        Path dir, BasicFileAttributes attrs) throws IOException;

    public FileVisitResult visitFile(
        Path file, BasicFileAttributes attrs) throws IOException;

    public FileVisitResult visitFileFailed(
        Path file, IOException exc) throws IOException;

    public FileVisitResult postVisitDirectory(
        Path dir, IOException exc) throws IOException {

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FileVisitor需要调用方自行实现，然后作为参数传入walkFileTree().FileVisitor的每个方法会在遍历过程中被调用多次。如果不需要处理每个方法，那么可以继承他的默认实现类SimpleFileVisitor，它将所有的接口做了空实现。&lt;/p&gt;
&lt;p&gt;下面看一个walkFileTree()的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Files.walkFileTree(path, new FileVisitor&amp;lt;Path&amp;gt;() {
  @Override
  public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
    System.out.println(&quot;pre visit dir:&quot; + dir);
    return FileVisitResult.CONTINUE;
  }

  @Override
  public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
    System.out.println(&quot;visit file: &quot; + file);
    return FileVisitResult.CONTINUE;
  }

  @Override
  public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
    System.out.println(&quot;visit file failed: &quot; + file);
    return FileVisitResult.CONTINUE;
  }

  @Override
  public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
    System.out.println(&quot;post visit directory: &quot; + dir);
    return FileVisitResult.CONTINUE;
  }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;FileVisitor的方法会在不同时机被调用： preVisitDirectory()在访问目录前被调用。postVisitDirectory()在访问后调用。&lt;/p&gt;
&lt;p&gt;visitFile()会在整个遍历过程中的每次访问文件都被调用。他不是针对目录的，而是针对文件的。visitFileFailed()调用则是在文件访问失败的时候。例如，当缺少合适的权限或者其他错误。&lt;/p&gt;
&lt;p&gt;上述四个方法都返回一个FileVisitResult枚举对象。具体的可选枚举项包括：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CONTINUE&lt;/li&gt;
&lt;li&gt;TERMINATE&lt;/li&gt;
&lt;li&gt;SKIP_SIBLINGS&lt;/li&gt;
&lt;li&gt;SKIP_SUBTREE&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;返回这个枚举值可以让调用方决定文件遍历是否需要继续。 CONTINE表示文件遍历和正常情况下一样继续。&lt;/p&gt;
&lt;p&gt;TERMINATE表示文件访问需要终止。&lt;/p&gt;
&lt;p&gt;SKIP_SIBLINGS表示文件访问继续，但是不需要访问其他同级文件或目录。&lt;/p&gt;
&lt;p&gt;SKIP_SUBTREE表示继续访问，但是不需要访问该目录下的子目录。这个枚举值仅在preVisitDirectory()中返回才有效。如果在另外几个方法中返回，那么会被理解为CONTINE。&lt;/p&gt;
&lt;p&gt;Searching For Files&lt;/p&gt;
&lt;p&gt;下面看一个例子，我们通过walkFileTree()来寻找一个README.txt文件：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path rootPath = Paths.get(&quot;data&quot;);
String fileToFind = File.separator + &quot;README.txt&quot;;

try {
  Files.walkFileTree(rootPath, new SimpleFileVisitor&amp;lt;Path&amp;gt;() {

    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
      String fileString = file.toAbsolutePath().toString();
      //System.out.println(&quot;pathString = &quot; + fileString);

      if(fileString.endsWith(fileToFind)){
        System.out.println(&quot;file found at path: &quot; + file.toAbsolutePath());
        return FileVisitResult.TERMINATE;
      }
      return FileVisitResult.CONTINUE;
    }
  });
} catch(IOException e){
    e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Deleting Directies Recursively&lt;/p&gt;
&lt;p&gt;Files.walkFileTree()也可以用来删除一个目录以及内部的所有文件和子目。Files.delete()只用用于删除一个空目录。我们通过遍历目录，然后在visitFile()接口中三次所有文件，最后在postVisitDirectory()内删除目录本身。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path rootPath = Paths.get(&quot;data/to-delete&quot;);

try {
  Files.walkFileTree(rootPath, new SimpleFileVisitor&amp;lt;Path&amp;gt;() {
    @Override
    public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
      System.out.println(&quot;delete file: &quot; + file.toString());
      Files.delete(file);
      return FileVisitResult.CONTINUE;
    }

    @Override
    public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
      Files.delete(dir);
      System.out.println(&quot;delete dir: &quot; + dir.toString());
      return FileVisitResult.CONTINUE;
    }
  });
} catch(IOException e){
  e.printStackTrace();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class FileTest {

    public static void main(String[] args) throws IOException {
        //创建绝对路径
        Path path = Paths.get(&quot;D:\\text\\file\\testfile.txt&quot;);//false
        //Path path = Paths.get(&quot;D:\\text\\1_loan.sql&quot;);//true
        //Path path = Paths.get(&quot;D:\\text\\test1\\1_loan.sql&quot;);//false
        //检查给定的Path在文件系统中是否存在,NOFOLLOW_LINKS:表示检测时不包含符号链接文件
        boolean exists = Files.exists(path, new LinkOption[]{LinkOption.NOFOLLOW_LINKS});
        //默认不传的话是包含符号链接文件的
        //boolean exists = Files.exists(path);
        System.out.println(&quot;exists =&quot; + exists);

        //路径格式可以是这两种
        Path filePath = Paths.get(&quot;D:\\text\\file&quot;);
        //Path filePath = Paths.get(&quot;D:/text/file_copy&quot;);

        //返回值就是新创建的路径.创建文件夹
        //Path directoryPath = Files.createDirectory(filePath);
        //createDirectory directoryPath=D:\text\file
        //System.out.println(&quot;createDirectory directoryPath=&quot; + directoryPath);

        //返回值就是新创建的路径.创建文件夹
        //Path rtfilePath = Files.createFile(path);
        //createFile rtfilePath=D:\text\file\testfile.txt
        //System.out.println(&quot;createFile rtfilePath=&quot; + rtfilePath);

        //Path path1 = Paths.get(&quot;D:\\text\\file\\subfile\\testfile.sql&quot;);
        //NoSuchFileException: D:\text\file\subfile\testfile.sql because subfile not exist
        //Path rtpath1 = Files.createFile(path1);
        //System.out.println(&quot;createFile rtpath1=&quot; + rtpath1);

        //Path path2 = Paths.get(&quot;D:\\text\\file\\subfile\\testfile.sql&quot;);
        //创建连续不存在的文件夹，不存在就创建，不过只能创建文件夹，不能连同文件创建，文件要另外创建
        //Path rtpath2 = Files.createDirectories(path2);
        //createFile rtpath2=D:\text\file\subfile\testfile.sql
        //System.out.println(&quot;createFile rtpath2=&quot; + rtpath2);


        //copy
        Path sourcePath = Paths.get(&quot;D:\\text\\file\\testfile.txt&quot;);
        Path destinationPath = Paths.get(&quot;D:\\text\\file\\testfile_copy.txt&quot;);
        //copy =D:\text\file\testfile_copy.txt
        //copy的目标路径文件不能存在，否则抛java.nio.file.FileAlreadyExistsException: D:\text\file\testfile_copy.txt异常
        //Path copy = Files.copy(sourcePath, destinationPath);
        //copy操作可以强制覆盖已经存在的目标文件,传入参数 StandardCopyOption.REPLACE_EXISTING
        //Path copy = Files.copy(sourcePath, destinationPath,StandardCopyOption.REPLACE_EXISTING);
        //System.out.println(&quot;copy =&quot; + copy);


        //move:移动文件和重命名是一样的
        //Path sourcePathM = Paths.get(&quot;D:\\text\\file\\testfile.txt&quot;);
        //Path destinationPathM = Paths.get(&quot;D:\\text\\file\\testfile_move.txt&quot;);
        //Path move = Files.move(sourcePathM, destinationPathM);
        //move操作可以强制覆盖已经存在的目标文件,传入参数 StandardCopyOption.REPLACE_EXISTING
        //原有的testfile.txt将被移动或重命名而不存在了，如果有目标文件testfile_move.txt存在，则会被覆盖
        //Path move = Files.move(sourcePathM, destinationPathM,StandardCopyOption.REPLACE_EXISTING);
        //System.out.println(&quot;move =&quot; + move);

        //delete 删除一个文件或目录
        //Path deletePath = Paths.get(&quot;D:\\text\\file\\testfile_move.txt&quot;);
        //Exception in thread &quot;main&quot; java.nio.file.NoSuchFileException: D:\text\file\testfile_move.txt
        //要求要删除的文件或目录必须存在，否则报错
        //Files.delete(deletePath);
        //存在才删除
        //Files.deleteIfExists(deletePath);


        Path rootPath = Paths.get(&quot;D:&quot;);
         final String fileToFind = File.separator + &quot;README.txt&quot;;

        try {
            Files.walkFileTree(rootPath, new SimpleFileVisitor&amp;lt;Path&amp;gt;() {

                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    String fileString = file.toAbsolutePath().toString();
                    //System.out.println(&quot;pathString = &quot; + fileString);

                    if(fileString.endsWith(fileToFind)){
                        System.out.println(&quot;file found at path: &quot; + file.toAbsolutePath());
                        return FileVisitResult.TERMINATE;
                    }
                    return FileVisitResult.CONTINUE;
                }
            });
        } catch(IOException e){
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;NIO AsynchronousFileChannel异步文件通道（AIO）&lt;/p&gt;
&lt;p&gt;Java7中新增了AsynchronousFileChannel作为nio的一部分。AsynchronousFileChannel使得数据可以进行异步读写。&lt;/p&gt;
&lt;p&gt;创建AsynchronousFileChannel（Creating an AsynchronousFileChannel）&lt;/p&gt;
&lt;p&gt;AsynchronousFileChannel的创建可以通过open()静态方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path path = Paths.get(&quot;data/test.xml&quot;);

AsynchronousFileChannel fileChannel =
    AsynchronousFileChannel.open(path, StandardOpenOption.READ);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;open()的第一个参数是一个Path实体，指向我们需要操作的文件。 第二个参数是操作类型。上述示例中我们用的是StandardOpenOption.READ，表示以读的形式操作文件。&lt;/p&gt;
&lt;p&gt;读取数据（Reading Data）&lt;/p&gt;
&lt;p&gt;读取AsynchronousFileChannel的数据有两种方式。每种方法都会调用AsynchronousFileChannel的一个read()接口。下面分别看一下这两种写法。&lt;/p&gt;
&lt;p&gt;1、通过Future读取数据（Reading Data Via a Future）&lt;/p&gt;
&lt;p&gt;第一种方式是调用返回值为Future的read()方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Future&amp;lt;Integer&amp;gt; operation = fileChannel.read(buffer, 0);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式中，read()接受一个ByteBuffer作为第一个参数，数据会被读取到ByteBuffer中。第二个参数是开始读取数据的位置。&lt;/p&gt;
&lt;p&gt;read()方法会立刻返回，即使读操作没有完成。我们可以通过isDone()方法检查操作是否完成。&lt;/p&gt;
&lt;p&gt;下面是一个略长的示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; AsynchronousFileChannel fileChannel = 
    AsynchronousFileChannel.open(path, StandardOpenOption.READ);

ByteBuffer buffer = ByteBuffer.allocate(1024);
long position = 0;

Future&amp;lt;Integer&amp;gt; operation = fileChannel.read(buffer, position);

while(!operation.isDone());

buffer.flip();
byte[] data = new byte[buffer.limit()];
buffer.get(data);
System.out.println(new String(data));
buffer.clear();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个例子中我们创建了一个AsynchronousFileChannel，然后创建一个ByteBuffer作为参数传给read。接着我们创建了一个循环来检查是否读取完毕isDone()。这里的循环操作比较低效，它的意思是我们需要等待读取动作完成。&lt;/p&gt;
&lt;p&gt;一旦读取完成后，我们就可以把数据写入ByteBuffer，然后输出。&lt;/p&gt;
&lt;p&gt;2、通过CompletionHandler读取数据（Reading Data Via a CompletionHandler）&lt;/p&gt;
&lt;p&gt;另一种方式是调用接收CompletionHandler作为参数的read()方法。下面是具体的使用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;fileChannel.read(buffer, position, buffer, new CompletionHandler&amp;lt;Integer, ByteBuffer&amp;gt;() {
    @Override
    public void completed(Integer result, ByteBuffer attachment) {
        System.out.println(&quot;result = &quot; + result);

        attachment.flip();
        byte[] data = new byte[attachment.limit()];
        attachment.get(data);
        System.out.println(new String(data));
        attachment.clear();
    }

    @Override
    public void failed(Throwable exc, ByteBuffer attachment) {

    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，一旦读取完成，将会触发CompletionHandler的completed()方法，并传入一个Integer和ByteBuffer。前面的整形表示的是读取到的字节数大小。第二个ByteBuffer也可以换成其他合适的对象方便数据写入。 如果读取操作失败了，那么会触发failed()方法。&lt;/p&gt;
&lt;p&gt;写数据（Writing Data）&lt;/p&gt;
&lt;p&gt;和读数据类似某些数据也有两种方式，调动不同的的write()方法，下面分别看介绍这两种方法。&lt;/p&gt;
&lt;p&gt;通过Future写数据（Writing Data Via a Future）&lt;/p&gt;
&lt;p&gt;通过AsynchronousFileChannel我们可以异步写数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path path = Paths.get(&quot;data/test-write.txt&quot;);
AsynchronousFileChannel fileChannel = 
    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);

ByteBuffer buffer = ByteBuffer.allocate(1024);
long position = 0;

buffer.put(&quot;test data&quot;.getBytes());
buffer.flip();

Future&amp;lt;Integer&amp;gt; operation = fileChannel.write(buffer, position);
buffer.clear();

while(!operation.isDone());

System.out.println(&quot;Write done&quot;);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先把文件以写方式打开，接着创建一个ByteBuffer作为写入数据的目的地。再把数据进入ByteBuffer。最后检查一下是否写入完成。 需要注意的是，这里的文件必须是已经存在的，否则在尝试write数据是会抛出一个java.nio.file.NoSuchFileException.&lt;/p&gt;
&lt;p&gt;检查一个文件是否存在可以通过下面的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;if(!Files.exists(path)){
    Files.createFile(path);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过CompletionHandler写数据（Writing Data Via a CompletionHandler）&lt;/p&gt;
&lt;p&gt;我们也可以通过CompletionHandler来写数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Path path = Paths.get(&quot;data/test-write.txt&quot;);
if(!Files.exists(path)){
    Files.createFile(path);
}
AsynchronousFileChannel fileChannel = 
    AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);

ByteBuffer buffer = ByteBuffer.allocate(1024);
long position = 0;

buffer.put(&quot;test data&quot;.getBytes());
buffer.flip();

fileChannel.write(buffer, position, buffer, new CompletionHandler&amp;lt;Integer, ByteBuffer&amp;gt;() {

    @Override
    public void completed(Integer result, ByteBuffer attachment) {
        System.out.println(&quot;bytes written: &quot; + result);
    }

    @Override
    public void failed(Throwable exc, ByteBuffer attachment) {
        System.out.println(&quot;Write failed&quot;);
        exc.printStackTrace();
    }
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同样当数据吸入完成后completed()会被调用，如果失败了那么failed()会被调用。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AIOTest {

    public static void main1(String[] args) throws IOException {
        //通过Future读取数据
        Path path = Paths.get(&quot;D:/test/file/README.txt&quot;);
        AsynchronousFileChannel asynChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        Future&amp;lt;Integer&amp;gt; future = asynChannel.read(byteBuffer, 0);
        while (!future.isDone()) {
            //等待读取动作完成
        };
        byteBuffer.flip();
        //有以下两种输出方式，本质上都是把缓冲区byteBuffer转为byte数组，再用new String接收
        //System.out.println(new String(byteBuffer.array(),0,byteBuffer.limit()));
        byte[] data = new byte[byteBuffer.limit()];
        byteBuffer.get(data);
        //设置编码格式
        //System.out.println(new String(data, StandardCharsets.UTF_8));
        //不设置编码格式时取的是系统默认的编码格式。在linux中是utf-8
        System.out.println(new String(data));
        byteBuffer.clear();
        asynChannel.close();
    }

    public static void main2(String[] args) throws IOException {
        //通过CompletionHandler读取数据
        Path path = Paths.get(&quot;D:/test/file/README.txt&quot;);
        AsynchronousFileChannel asynChannel = AsynchronousFileChannel.open(path, StandardOpenOption.READ);
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        asynChannel.read(byteBuffer, 0, byteBuffer, new CompletionHandler&amp;lt;Integer, ByteBuffer&amp;gt;() {
            @Override
            public void completed(Integer result, ByteBuffer attachment) {
                System.out.println(&quot;result = &quot; + result);
                attachment.flip();
                byte[] data = new byte[attachment.limit()];
                attachment.get(data);
                System.out.println(new String(data));
                attachment.clear();
            }

            @Override
            public void failed(Throwable exc, ByteBuffer attachment) {
                System.out.println(&quot;result failed &quot; + exc.getMessage());
            }
        });
        asynChannel.close();
    }

    public static void main3(String[] args) throws IOException {
        //通过Future写数据
        Path path = Paths.get(&quot;D:/test/file/README_WRITE.txt&quot;);
        //若文件不存在则创建一个
        if (!Files.exists(path)){
            Files.createFile(path);
        }
        AsynchronousFileChannel asynChannel = AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        byteBuffer.put(&quot;i am batman,and i am rich&quot;.getBytes());
        byteBuffer.flip();
        Future&amp;lt;Integer&amp;gt; future = asynChannel.write(byteBuffer, 0);
        byteBuffer.clear();
        while (!future.isDone()){
        }
        System.out.println(&quot;Write done&quot;);
        asynChannel.close();
    }

    public static void main(String[] args) throws IOException {
        //通过CompletionHandler写数据
        Path path = Paths.get(&quot;D:/test/file/README_WRITE.txt&quot;);
        //若文件不存在则创建一个
        if (!Files.exists(path)){
            Files.createFile(path);
        }
        AsynchronousFileChannel asynChannel = AsynchronousFileChannel.open(path, StandardOpenOption.WRITE);
        ByteBuffer byteBuffer = ByteBuffer.allocate(1024);
        byteBuffer.put(&quot;i am batman,and i am rich&quot;.getBytes());
        byteBuffer.flip();
        asynChannel.write(byteBuffer, 0, byteBuffer, new CompletionHandler&amp;lt;Integer, ByteBuffer&amp;gt;() {
            @Override
            public void completed(Integer result, ByteBuffer attachment) {
                System.out.println(&quot;Write done&quot;);
                System.out.println(&quot;bytes written: &quot; + result);
            }

            @Override
            public void failed(Throwable exc, ByteBuffer attachment) {
                System.out.println(&quot;bytes written failes: &quot; + exc.getMessage());
            }
        });
        asynChannel.close();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;疑问：&lt;/p&gt;
&lt;p&gt;Q:NIO的具体使用场景都有哪些？网络连接？学习NIO的目的？&lt;/p&gt;
&lt;p&gt;Q:Linux的五种IO模型?与java的io模型的关系？&lt;/p&gt;
&lt;p&gt;《漫话：如何给女朋友解释什么是Linux的五种IO模型？》&lt;/p&gt;
&lt;p&gt;Q:equals()判断两个buffer相对，需满足：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类型相同&lt;/li&gt;
&lt;li&gt;buffer中剩余字节数相同&lt;/li&gt;
&lt;li&gt;所有剩余字节相等&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;从上面的三个条件可以看出，equals只比较buffer中的部分内容，并不会去比较每一个元素。&lt;/p&gt;
&lt;p&gt;所有剩余字节相等是指如果这个buffer有被读或者写过，只比较他们剩余没有读或者写的部分是么？&lt;/p&gt;
&lt;p&gt;Q:FileChannel不能切换为非阻塞模式,都有哪些Channel可以切换为非阻塞模式？&lt;/p&gt;
&lt;p&gt;Q:select()方法的返回值是一个int整形，代表有多少channel处于就绪了。也就是自上一次select后有多少channel进入就绪。举例来说，假设第一次调用select时正好有一个channel就绪，那么返回值是1，并且对这个channel做任何处理，接着再次调用select，此时恰好又有一个新的channel就绪，那么返回值还是1，现在我们一共有两个channel处于就绪，但是在每次调用select时只有一个channel是就绪的。每次调用select时只有一个channel是就绪的?为什么？&lt;/p&gt;
&lt;p&gt;Q:如何检查message完整性？&lt;/p&gt;
&lt;p&gt;Q:一个Message Reader自然是协议相关的？都有哪些协议？协议的作用是为了约定规范么？&lt;/p&gt;
&lt;p&gt;Q:UDP是面向无连接的网络协议,什么叫无连接的网络协议？&lt;/p&gt;
&lt;p&gt;Q:面向流和面向缓冲区的区别，我们不能在流数据中向前后移动。如果需要向前后移动读取位置，那么我们需要首先为它创建一个缓存区？怎么在缓冲区中向前后移动？&lt;/p&gt;
&lt;p&gt;Q:针对作者画的NIO和BIO这两个交互图不能很明确得观察有什么不同，特别是BIO前面部分，和NIO后面部分没有画出来，后面部分也是多线程处理啊?不同点是是否阻塞进行连接还是非阻塞连接吧？&lt;/p&gt;
&lt;p&gt;NIO:&lt;/p&gt;
&lt;p&gt;BIO:&lt;/p&gt;
&lt;p&gt;Q:NIO Path路径(java.nio.file.Path )和之前的BIOPath路径( java.io.File )有什么区别？在使用时怎么选择？&lt;/p&gt;
&lt;p&gt;其他：&lt;/p&gt;
&lt;p&gt;在用main方法测试时怎么给String args[] 参数赋值？&lt;/p&gt;
&lt;p&gt;1、直接在代码中给args参数赋值一个我们想要的数组。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; static public void main(String args[]) throws Exception {
        args = new String[]{&quot;D:\\text\\1_loan.sql&quot;, &quot;D:\\text\\1_loan_copy.sql&quot;};
  //....   
  }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2、在idea里的运行debug时可以设置program arguments,以空格符分开参数。&lt;/p&gt;
&lt;p&gt;二、注意当copy其他java类进来时，如果引用类的包名路径不同，会导致报错，且还不能引用正确路径上的类，这时候要点开import 里引用的错误包路径的类引用路径，删除了重新引入。快捷键 ctrl + alt + o。&lt;/p&gt;
&lt;p&gt;三、符号链接文件：与硬连接相对应，Lnux系统中还存在另一种连接，称为符号连接（Symbilc Link），也叫软连接。软链接文件有点类似于Windows的快捷方式 。&lt;/p&gt;
&lt;p&gt;什么是linux下的符号链接文件&lt;/p&gt;
</description>
<pubDate>Wed, 22 Apr 2020 15:59:00 +0000</pubDate>
<dc:creator>卡斯特梅的雨伞</dc:creator>
<og:description>NIO教程 ——检视阅读 参考 BIO,NIO,AIO 总结 Java NIO浅析 Java NIO 教程——极客，蓝本 Java NIO 系列教程 ——并发编程网 BIO,NIO——知乎 NIO 入</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/castamere/p/12757885.html</dc:identifier>
</item>
<item>
<title>kafka消息分区机制原理 - 李福春</title>
<link>http://www.cnblogs.com/snidget/p/12757698.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/snidget/p/12757698.html</guid>
<description>&lt;p&gt;kafka如何支撑海量消息的集中写入？&lt;/p&gt;
&lt;p&gt;答案就是消息分区。&lt;/p&gt;
&lt;p&gt;核心思想是：负载均衡，采用合适的分区策略把消息写到不同的broker上的分区中；&lt;/p&gt;
&lt;p&gt;其它的产品中有类似的思想。&lt;/p&gt;
&lt;p&gt;比如monogodb, es 里面叫做 shard;   hbase叫region,  cassdra叫vnode;&lt;/p&gt;

&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;即  topic -&amp;gt; partition -&amp;gt; message ;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200422231752925-1143440865.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;topic是逻辑上的消息容器；&lt;/p&gt;
&lt;p&gt;partition实际承载消息，分布在不同的kafka的broke上；&lt;/p&gt;
&lt;p&gt;message即具体的消息。&lt;/p&gt;

&lt;h2 id=&quot;round-robin轮询&quot;&gt;round-robin轮询&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200422231753191-897815837.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;消息按照分区挨个的写。&lt;/p&gt;
&lt;h2 id=&quot;randomness随机分区&quot;&gt;randomness随机分区&lt;/h2&gt;
&lt;p&gt;随机的找一个分区写入，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;PartitionInfo&amp;gt; partitions = cluster.partitionsForTopic(topic);
return ThreadLocalRandom.current().nextInt(partitions.size());
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200422231753438-84312085.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;key&quot;&gt;key&lt;/h2&gt;
&lt;p&gt;相同的key的消息写到固定的分区中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200422231753668-882720335.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;自定义分区&quot;&gt;自定义分区&lt;/h2&gt;
&lt;p&gt;必须完成两步：&lt;/p&gt;
&lt;p&gt;1，自定义分区实现类，需要实现org.apache.kafka.clients.producer.Partitioner接口。&lt;/p&gt;
&lt;p&gt;主要是实现下面的方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;int partition(String topic, Object key, byte[] keyBytes, 
              Object value, byte[] valueBytes, Cluster cluster);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;比如按照区域分区。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;List&amp;lt;PartitionInfo&amp;gt; partitions = cluster.partitionsForTopic(topic);
return partitions.stream().filter(p -&amp;gt; isSouth(p.leader().host()))
    .map(PartitionInfo::partition).findAny().get();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;2，显示配置生产者端的参数partitioner.class为具体的类&lt;/p&gt;
&lt;p&gt;系统默认：如果消息有key,按照key分区策略，否则按照轮询策略。&lt;/p&gt;

&lt;p&gt;kafka的分区实现消息的高吞吐量的主要依托，主要是实现了写的负载均衡。可以指定各种负载均衡算法。&lt;br/&gt;负载均衡算法非常重要，需要极力避免消息分区不均的情况，可能给消费者带来性能瓶颈。&lt;/p&gt;
&lt;p&gt;小结如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200422231754485-2011966852.png&quot; alt=&quot;image.png&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;原创不易，点赞关注支持一下吧！转载请注明出处，让我们互通有无，共同进步，欢迎沟通交流。&lt;br/&gt;我会持续分享Java软件编程知识和程序员发展职业之路，欢迎关注，我整理了这些年编程学习的各种资源，关注公众号‘李福春持续输出’，发送'学习资料'分享给你！&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/other/268922/202004/268922-20200422231754799-1572832564.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Wed, 22 Apr 2020 15:18:00 +0000</pubDate>
<dc:creator>李福春</dc:creator>
<og:description>背景 kafka如何支撑海量消息的集中写入？ 答案就是消息分区。 核心思想是：负载均衡，采用合适的分区策略把消息写到不同的broker上的分区中； 其它的产品中有类似的思想。 比如monogodb,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/snidget/p/12757698.html</dc:identifier>
</item>
<item>
<title>Unity ML-agents 一、初次尝试 - ITryagain</title>
<link>http://www.cnblogs.com/csu-lmw/p/12757518.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/csu-lmw/p/12757518.html</guid>
<description>&lt;p&gt;曾在高二寒假的时候，跟表哥在外面玩，当时他问我有没有想过以后要做什么，我愣了一下，回答不上来。是的，从没想过以后要做什么，只是一直在完成学校、老师安排的任务，于是那之后半年，我一直在思考，大学要学什么。在大二下期中之后，我觉得自己还是对游戏更感兴趣，便想到以后想做游戏。于是，高考后填志愿，填的都是计算机专业。在大一的时候，自学了一段时间的 Unity，到大二在实验室接触强化学习之后，就想着用 RL 来做游戏 AI，但后来一直在做数据挖掘相关的内容，基本上以参加比赛为主。直到去年参加上海的谷歌开发者节，了解到 ML-agents 之后，就十分的想尝试。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1413964/202004/1413964-20200422212402672-81101745.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后由于疫情，直到现在还在家里咸鱼，前段时间一边咸鱼一边投简历，奈何自己水平太低又偏偏想投算法岗，直到现在也没有几次面试机会 orz。最近就想继续当年未完成的 Unity 的学习，顺便学习 ML-agents，回到原点，重新出发。&lt;/p&gt;

&lt;h2 id=&quot;环境配置&quot;&gt;环境配置&lt;/h2&gt;
&lt;p&gt;既然要尝试，肯定免不了环境配置&lt;br/&gt;目前我的环境为：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Win10&lt;/li&gt;
&lt;li&gt;Tensorflow 2.0&lt;/li&gt;
&lt;li&gt;ML-agents 0.15.0&lt;/li&gt;
&lt;li&gt;Unity 2019.3.1f1&lt;br/&gt;关于 Tensorflow 2.0 的安装，参考我之前的&lt;a href=&quot;https://www.cnblogs.com/csu-lmw/p/12196670.html&quot;&gt;博客&lt;/a&gt;，Unity 的安装，推荐先下载 Unity Hub，通过 Unity Hub 可以管理不同版本的 Unity，&lt;a href=&quot;https://unity3d.com/cn/get-unity/download&quot;&gt;下载戳这里&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1413964/202004/1413964-20200422214559586-710050584.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ML-agents 的安装有两种方式&lt;br/&gt;一是直接 pip&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install mlagents
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;二是从官方 &lt;a href=&quot;https://github.com/Unity-Technologies/ml-agents/tree/release-0.15.0&quot;&gt;github&lt;/a&gt; 中 clone 整个项目，然后 cd 到目录中&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;pip install -e ./ml-agents-envs
pip install -e ./ml-agents
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，环境配置就算完成了&lt;/p&gt;
&lt;h2 id=&quot;跑个-demo-先吧&quot;&gt;跑个 Demo 先吧&lt;/h2&gt;
&lt;p&gt;在 Unity Hub 中导入刚刚从 github 上 clone 的项目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1413964/202004/1413964-20200422215900168-1928155446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择 Unity 版本之后打开&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1413964/202004/1413964-20200422220011221-1335424446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后打开 3DBall 这个场景&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1413964/202004/1413964-20200422220231013-354894167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击运行的话可以直接看到效果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1413964/202004/1413964-20200422223013956-858927575.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着，开始尝试自己训练，打开命令行，进入到之前 clone 下来的项目目录中，并在目录中创建一个名为 summaries 的文件夹&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1413964/202004/1413964-20200422223243938-1090620246.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;然后输入&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mlagents-learn config/trainer_config.yaml --run-id=test --train
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1413964/202004/1413964-20200422223707016-1579473105.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在出现图标之后，切换到 Unity 运行项目，就可以看见开始训练了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1413964/202004/1413964-20200422223749894-1326804646.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出来一开的效果是很差的，完全控制不好，这次训练大概训练 40w+ 步，到后面就很稳了&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：项目目录中尽量不要出现中文，下午在尝试的时候一直报错，后来更改目录之后发现成功了，不清楚是不是路径中有中文的原因&lt;/em&gt;&lt;br/&gt;报错内容&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt; &quot;The Unity environment took too long to respond. Make sure that :\n&quot;
mlagents_envs.exception.UnityTimeOutException: The Unity environment took too long to respond. Make sure that :
         The environment does not need user interaction to launch
         The Agents are linked to the appropriate Brains
         The environment and the Python interface have compatible versions.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;训练完成后，我们可以在 models 目录下看到刚刚训练好的模型，重命名一下，然后把模型拖到 TFModel 目录中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1413964/202004/1413964-20200422224433601-1972041047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;接着打开 prefabs 中的 3DBall，点击其中的 agent，然后将 Behavior 改成我们刚刚拖到 TFModel 目录中的模型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1413964/202004/1413964-20200422224636551-1792309846.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击运行，发现控制的十分稳定，跟一开始差不多。至此，初试完毕。&lt;/p&gt;

&lt;p&gt;这里我们安装配置了 ML-agnets 的相关环境，并运行了个 Demo 来熟悉了遍流程，后面将开始尝试自己搭建环境，训练 AI，也不知道能不能捣鼓出来，23333。&lt;/p&gt;
</description>
<pubDate>Wed, 22 Apr 2020 15:01:00 +0000</pubDate>
<dc:creator>ITryagain</dc:creator>
<og:description>前言 曾在高二寒假的时候，跟表哥在外面玩，当时他问我有没有想过以后要做什么，我愣了一下，回答不上来。是的，从没想过以后要做什么，只是一直在完成学校、老师安排的任务，于是那之后半年，我一直在思考，大学要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/csu-lmw/p/12757518.html</dc:identifier>
</item>
<item>
<title>[Abp vNext 入坑分享] - 2.简化项目结构 - 二B方案程序员</title>
<link>http://www.cnblogs.com/twoBcoder/p/12756094.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/twoBcoder/p/12756094.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、简要说明&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本篇文章根据我自己的需要对项目结果进行简化，让项目结构更符合我自己的要求,同时让项目跑起来。&lt;strong&gt;仅供参考&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、具体步骤&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1&lt;/strong&gt;卸载掉对我来说目前使用不上的项目，identityserver,mongodb,httpapi.client,以及对应的test项目&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200422212331143-892351201.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.2&lt;/strong&gt;删除掉下图红框中的包与类文件，由于我后期会创建一个独立的项目来做migrations，所以不需要在HttpApi.Host里面直接使用EF相关的操作，而且个人认为这样会模糊掉abpvnext的层级，混乱了层级的职责。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200422212341883-1675634480.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200422212408108-40167856.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;上图的报错都是由于我删除了相关的包引起的，因此跳转到相关文件中，把所有的报错行，全部删除。同时由于我没有启用redis的服务，所以要把下图的redis服务也先行注释掉。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200422212422858-447175059.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.3&lt;/strong&gt;将启动模式修改成：如下图，同时把原来输出日志到文件的模式修改成：console(),以便在控制台时能很直观的看到Log。调试项目，则可以启动成功了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200422212436665-1186025438.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200422212456387-300866712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200422212504186-782356826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.4&lt;/strong&gt;在src下面增加DbMigrations类库，注意：此处只能选择.netcore类型的类库，不能是只属于netstandard这样会导致无法使用。创建后的样子如下，这样就可以使用此项目进行migration操作了，且不会影响主线代码。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1010868/202004/1010868-20200422212517458-484071892.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.&lt;/strong&gt;&lt;strong&gt;关于DbM_LearnDbContext这个类，如果你能保证整个项目的所有开发人员都只能使用codefirst进行开发的话，可以直接继承主的LearnDbContext，这样LearnDbContext的所有DbSet都会得到继承，则不需要再重复写dbset。&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.&lt;/strong&gt;&lt;strong&gt;若是&lt;/strong&gt;&lt;strong&gt;codefirst&lt;/strong&gt;&lt;strong&gt;与&lt;/strong&gt;&lt;strong&gt;dbfirst&lt;/strong&gt;&lt;strong&gt;混用的情况，则不要继承&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.&lt;/strong&gt;&lt;strong&gt;单纯&lt;/strong&gt;&lt;strong&gt;dbfirst&lt;/strong&gt;&lt;strong&gt;的话，此项目可以去掉&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 Apr 2020 14:52:00 +0000</pubDate>
<dc:creator>二B方案程序员</dc:creator>
<og:description>一、简要说明 本篇文章根据我自己的需要对项目结果进行简化，让项目结构更符合我自己的要求,同时让项目跑起来。仅供参考 二、具体步骤 2.1卸载掉对我来说目前使用不上的项目，identityserver,</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/twoBcoder/p/12756094.html</dc:identifier>
</item>
<item>
<title>CoreDNS解析异常记录 - 渣渣辉</title>
<link>http://www.cnblogs.com/Dev0ps/p/12757309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Dev0ps/p/12757309.html</guid>
<description>&lt;div readability=&quot;23.5&quot;&gt;

&lt;p&gt;异常情况：集群是用kubespray部署的4个worknode,coredns默认部署2个deployment。今天发现部署了coredns的node上的pod正常解析内部域名，而另外2个未运行coredns的node却无法解析。&lt;/p&gt;
&lt;p&gt; 配置文件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271786/202004/1271786-20200422222144114-719787868.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 下图中我们看到coredns2个pod分别在node1与node2上，只要分配到这2节点上的deployment都可以正常解析。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271786/202004/1271786-20200422222044710-1208716782.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其他节点无法解析：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1271786/202004/1271786-20200422222547228-764123792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 处理过程：&lt;/p&gt;
&lt;p&gt;正常来说所有的pod都是通过coredns来进行集群内域名解析的，我也搞不清楚为啥其他两个node没有跑coredns则就无法解析后面再研究。所以我临时的解决方法是扩容coredns让每个node都跑。&lt;/p&gt;
&lt;p&gt;1、修改 ConfigMap 中的 dns-autoscaler（coredns自动扩容保证高可用）&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
kubectl edit configmap dns-autoscaler --namespace=kube-system
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、修改key：linear&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;coresPerReplica： 按照核心数目来计算副本集（replicas = cores / coresPerReplica）&lt;/li&gt;
&lt;li&gt;nodesPerReplica：按照节点数目来计算副本集（replicas = nodes / nodesPerReplica）&lt;/li&gt;
&lt;li&gt;min：最小副本数（默认为2，我先有4个节点改为4）&lt;/li&gt;
&lt;li&gt;max：最大副本数&lt;/li&gt;
&lt;li&gt;preventSinglePointFailure：防止单点故障&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;公式&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:csharp;gutter:true;&quot;&gt;
replicas = max( ceil( cores × 1/coresPerReplica ) , ceil( nodes × 1/nodesPerReplica ) )
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1271786/202004/1271786-20200422224314190-1538005773.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 22 Apr 2020 14:43:00 +0000</pubDate>
<dc:creator>渣渣辉</dc:creator>
<og:description>CoreDNS解析异常记录 异常情况：集群是用kubespray部署的4个worknode,coredns默认部署2个deployment。今天发现部署了coredns的node上的pod正常解析内部</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Dev0ps/p/12757309.html</dc:identifier>
</item>
<item>
<title>LeetCode#160-Intersection of Two Linked Lists-相交链表 - 鹿呦呦</title>
<link>http://www.cnblogs.com/sunshineliulu/p/12757475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunshineliulu/p/12757475.html</guid>
<description>&lt;h4 id=&quot;一、题目&quot;&gt;一、题目&lt;/h4&gt;
&lt;p&gt;编写一个程序，找到两个单链表相交的起始节点。&lt;br/&gt;如下面的两个链表：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/953680/202004/953680-20200422224011134-1127771856.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;在节点 c1 开始相交。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/953680/202004/953680-20200422224042223-1590613695.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个列表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例 2:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/953680/202004/953680-20200422224142451-744725562.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入：intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Reference of the node with value = 2
输入解释：相交节点的值为 2 （注意，如果两个列表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [0,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例 3:&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/953680/202004/953680-20200422224152646-939689882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
输入解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。由
于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
解释：这两个链表不相交，因此返回 null。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果两个链表没有交点，返回 null.&lt;/li&gt;
&lt;li&gt;在返回结果后，两个链表仍须保持原有的结构。&lt;/li&gt;
&lt;li&gt;可假定整个链表结构中没有循环。&lt;/li&gt;
&lt;li&gt;程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存。&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;二、题解&quot;&gt;二、题解&lt;/h4&gt;
&lt;ul&gt;&lt;li&gt;题解1：哈希表&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;遍历链表 A 并将每个节点的地址/引用存储在哈希表中。&lt;br/&gt;然后检查链表 B 中的每一个节点是否在哈希表中。若在，则为相交结点。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
 func getIntersectionNode(headA, headB *ListNode) *ListNode {
    var s [] *ListNode
    
    for headA != nil {
        s = append(s, headA)
        headA = headA.Next
    }
    for headB != nil {
        for _,v := range(s) {
            if v == headB {
                return headB
            }
        }
        headB = headB.Next
    }
    return nil
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;题解2：链表拼接法&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当链表 A 走到尾部的 null 时，转到链表 B 的头节点继续走；&lt;br/&gt;当链表 B 走到尾部的 null 时，转到链表 A 的头节点继续走；&lt;br/&gt;若两链表相交，则 A 和 B 一定相遇。&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/953680/202004/953680-20200422223908222-929848698.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;如上图：初始化 &lt;code&gt;pA = headA&lt;/code&gt;, &lt;code&gt;pB = headB&lt;/code&gt;，开始遍历。&lt;br/&gt;pA会先到达链表尾，当pA到达末尾时，重置pA为headB；同样的，当pB到达末尾时，重置pB为headA。当pA与pB相遇时，必然就是两个链表的交点。&lt;/p&gt;
&lt;p&gt;为什么要这样处理？因为对 &lt;code&gt;pA&lt;/code&gt; 而言，走过的路程为 &lt;code&gt;a+c+b&lt;/code&gt;，对 &lt;code&gt;pB&lt;/code&gt; 而言，为 &lt;code&gt;b+c+a&lt;/code&gt;，显然 &lt;code&gt;a+c+b = b+c+a&lt;/code&gt;，这就是该算法的核心原理。&lt;/p&gt;
&lt;p&gt;即使两个链表没有相交点，仍然可以统一处理，因为这种情况意味着相交点就是 &lt;code&gt;null&lt;/code&gt;，也就是上图中的公共部分c没有了，从而递推式变成了 &lt;code&gt;pA: a+b&lt;/code&gt;，&lt;code&gt;pB: b+a&lt;/code&gt;，同样是成立的。&lt;/p&gt;
&lt;p&gt;时间复杂度：O(m+n)，空间复杂度：O(1)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/953680/202004/953680-20200422224629338-1920982338.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
 func getIntersectionNode(headA, headB *ListNode) *ListNode {
    if (headA == nil || headB == nil) {
        return nil
    }
    pA, pB := headA, headB
    for pA != pB {
        if pA == nil {
            pA = headB 
        } else {
            pA = pA.Next
        }
        if pB == nil {
            pB = headA
        } else {
            pB = pB.Next
        }
    }
    return pA
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;题解3：消除链表长度差&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;两个单链表，有公共结点，则必然尾部公用；&lt;/p&gt;
&lt;p&gt;分别找出链表 1 和链表 2 的长度，长的链表减去短的链表得出一个 n 值；&lt;/p&gt;
&lt;p&gt;长的链表先走 n 步，两个链表再同时移动，则两个链表相交点就是第一个公共结点。&lt;/p&gt;
&lt;p&gt;时间复杂度：O(n)，空间复杂度：O(1)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/953680/202004/953680-20200422223930093-1325746530.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func getIntersectionNode(headA, headB *ListNode) *ListNode {
    if headA == nil || headB == nil {
        return nil
    }
    lenA := getLen(headA)
    lenB := getLen(headB)

    //计算链表长度差 n，长的先移动 n 步
    if (lenA &amp;gt; lenB) {// 链表A比链表B长，A先移动
        for i := 0; i &amp;lt; lenA - lenB; i++ {
            headA = headA.Next
        }
    } else {// 链表B比链表A长，B先移动
        for i := 0; i &amp;lt; lenB - lenA; i++ {
            headB = headB.Next
        }
    }
    
    for headA != nil {
        if headA == headB {
            return headA
        }
        headA = headA.Next
        headB = headB.Next
    }
    return nil;
}

//获取链表长度
func getLen(head *ListNode) int {
    var len int
    for head != nil {
        len++
        head = head.Next
    }
    return len
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;后记&quot;&gt;后记&lt;/h4&gt;
&lt;p&gt;这道题也是面试题中经常遇到的“两个链表的第一个公共节点”。虽然难度是“简单”，但对我来说一点也不简单。看评论和题解涨了很多姿势。&lt;/p&gt;
&lt;p&gt;而且，一开始用的是 PHP，可怎么都通不过，不得不用 Go 重写了一遍，倒是很快通过了。&lt;/p&gt;
&lt;p&gt;附上 PHP 版本：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;题解1 PHP版本&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;class ListNode {
    public $val = 0;
    public $next = null;
    function __construct($val) { 
        $this-&amp;gt;val = $val; 
    }
}

/**
 * @param ListNode $headA
 * @param ListNode $headB
 * @return ListNode
 */
function getIntersectionNode($headA, $headB) {
    $hashMap = [];
    while ($headA) {
        $hashMap[] = $headA;
        $headA = $headA-&amp;gt;next;
    }
    while ($headB) {
        if (in_array($headB, $hashMap)) {
            return $headB;
        }
        $headB = $headB-&amp;gt;next;
    }
    return null;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;题解2 PHP版本&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;function getIntersectionNode($headA, $headB) {
    if ($headA == null || $headB == null) {
        return null;
    }

    $pA = $headA;
    $pB = $headB;
    while ($pA != $pB) {
        $pA = $pA == null ? $headB : $pA-&amp;gt;next;
        $pB = $pB == null ? $headA : $pB-&amp;gt;next;
    }
    return $pA;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;题解3 PHP版本&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-php&quot;&gt;function getIntersectionNode($headA, $headB) {
    $lenA = getListLength($headA);
    $lenB = getListLength($headB);

    $diffLen = $lenA &amp;gt; $lenB ? $lenA - $lenB : $lenB - $lenA;
    $headLong = $lenA &amp;gt; $lenB ? $headA : $headB;
    $headShort = $lenA &amp;gt; $lenB ? $headB : $headA;

    //先在长链表上走几步，再同时在两个链表上遍历
    for ($i = 0; $i &amp;lt; $diffLen; $i++) {
        $headLong = $headLong-&amp;gt;next;
    }
    while ($headLong != $headShort) {
        $headLong = $headLong-&amp;gt;next;
        $headShort = $headShort-&amp;gt;next;
    }
    return $headLong;
}

/**
 * 获取链表的长度
 */
function getListLength($head)
{
    $length = 0;
    $current = $head;
    while ($current != null) {
        $length++;
        $current = $current-&amp;gt;next;
    }
    return $length;
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 22 Apr 2020 14:43:00 +0000</pubDate>
<dc:creator>鹿呦呦</dc:creator>
<og:description>LeetCode#160-Intersection of Two Linked Lists-相交链表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sunshineliulu/p/12757475.html</dc:identifier>
</item>
<item>
<title>python 异步 I/O - 虫师</title>
<link>http://www.cnblogs.com/fnng/p/12757395.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fnng/p/12757395.html</guid>
<description>&lt;p&gt;如果你想了解异步编程，那么必然会涉及出许多相关概念。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;堵塞/非堵塞&lt;/li&gt;
&lt;li&gt;同步/异步&lt;/li&gt;
&lt;li&gt;多进程/多线程/协程&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;为什么我要学习这个话，因为我想搞懂异步框架和异步接口的调用。所以，我的学习路线是这样的：&lt;/p&gt;
&lt;p&gt;1.python异步编程&lt;br/&gt;2.python Web异步框架（tornado/sanic）&lt;br/&gt;3.异步接口调用（aiohttp/httpx）&lt;/p&gt;
&lt;p&gt;那么异步编程有什么好处？在某些场景下它可以提高性能。我们知道CPU的速度快于磁盘、网络等IO。一旦遇到IO操作，如读写文件、发送网络数据时，就需要等待IO操作完成，才能进行下一步操作。这种情况称为同步IO。我们可以使用多线程来解决这类问题，另一种方式是通过异步。&lt;/p&gt;
&lt;p&gt;python在3.4版本引入asyncio，到 3.5版本又加入async/await来简化异步的使用。&lt;/p&gt;
&lt;p&gt;先来举个简单的例子，假如，你和女朋友逛街。你的目的是去看新上市的华为P40手机，而你女朋友是去看新款的衣服。你们的逛街流程是这样的。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import time


def clothes_shop():
    print(&quot;女朋友看衣服..&quot;)
    time.sleep(8)
    print(&quot;...出来了&quot;)


def huawei_shop():
    print(&quot;体验手机..&quot;)
    time.sleep(5)
    print(&quot;...出来了&quot;)

print(time.ctime(), &quot;开始逛街&quot;)
clothes_shop()
huawei_shop()
print(time.ctime(), &quot;结束.&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thu Apr 16 00:08:22 2020 开始逛街
女朋友看衣服..
...出来了
体验手机..
...出来了
Thu Apr 16 00:08:35 2020 结束.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设单位是分钟，你们总共耗时13分钟。&lt;/p&gt;
&lt;p&gt;接下来，看看用异步是如何处理的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;import asyncio
import time


async def shop(delay, what):
    print(what)
    await asyncio.sleep(delay)
    print(&quot;...出来了&quot;)


async def main():
    task1 = asyncio.create_task(shop(8, '女朋友看衣服..'))
    task2 = asyncio.create_task(shop(5, '体验手机..'))

    print(time.ctime(), &quot;开始逛街&quot;)
    await task1
    await task2
    print(time.ctime(), &quot;结束.&quot;)


asyncio.run(main())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 async/await 语法进行声明，是编写 asyncio 应用的推荐方式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;async 声明一个函数为异步函数。&lt;/li&gt;
&lt;li&gt;await 声明处理比较耗费时的动作。&lt;/li&gt;
&lt;li&gt;asyncio.run() 函数用来运行最高层级的入口点 main() 函数。&lt;/li&gt;
&lt;li&gt;asyncio.create_task() 函数用来并发运行作为 asyncio 任务 的多个协程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;其实，思路非常简单，就是你和女朋友各逛各自的，先出来的等等对方。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;严重警告！提醒广大直男，现实生活中千万不要这么思考问题。一定要陪女朋友一起看衣服，还要主动去付钱。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;来看看运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Thu Apr 16 00:19:19 2020 开始逛街
女朋友看衣服..
体验手机..
...出来了
...出来了
Thu Apr 16 00:19:27 2020 结束.
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;假设单位是分钟，只需要8分钟搞定。&lt;/p&gt;
&lt;p&gt;通过上面的例子，可以看到 task1、task2仍然有前后顺序，这种前后顺序的时间可以忽略不计。但是，我们也是可以使用asyncio.gather()方法并发运行任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-python&quot;&gt;#……

async def main():
    print(time.ctime(), &quot;开始逛街&quot;)
    await asyncio.gather(
        shop(8, '女朋友看衣服..'),
        shop(5, '体验手机..')
    )
    print(time.ctime(), &quot;结束.&quot;)

asyncio.run(main())
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果同上，这里就不再贴了。&lt;/p&gt;
&lt;p&gt;参考：&lt;a href=&quot;https://docs.python.org/zh-cn/3/library/asyncio.html&quot;&gt;https://docs.python.org/zh-cn/3/library/asyncio.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 22 Apr 2020 14:31:00 +0000</pubDate>
<dc:creator>虫师</dc:creator>
<og:description>python 异步 I/O</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/fnng/p/12757395.html</dc:identifier>
</item>
</channel>
</rss>