<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Ansible常用模块 - IMSCZ</title>
<link>http://www.cnblogs.com/IMSCZ/p/12057969.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/IMSCZ/p/12057969.html</guid>
<description>&lt;h2 id=&quot;ansible模块&quot;&gt;Ansible模块&lt;/h2&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 环境
`# ansible: 172.16.1.61
cat /etc/ansible/hosts
[web]
web1:   172.16.1.7
web2:  172.16.1.8
web3:  172.16.1.9&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;ssh免密钥配置&quot;&gt;1. ssh免密钥配置&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ssk-keygen   # 创建密钥
sshpass -p'123456'  ssh-copy-id -i ~/.ssh/id_rsa.pub root@172.16.1.7    # 推送密钥至远端&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;ad-hoc&quot;&gt;2. Ad-Hoc&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;`# ad-hoc 表示临时命令,不会保存
`# ansible中有两种模式,分别是ad-hoc模式和playbook模式

#使用场景
`# 在多台机器上,查看某个进程是否启动
`# 在多台机器上,拷贝指定日志文件到本地&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;ad-hoc命令格式&quot;&gt;3. Ad-Hoc命令格式&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;命令 + 主机组名称 + 指定模块 + 模块动作 + 具体命令&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;command命令模块-shell&quot;&gt;4. command命令模块( shell )&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;`# command 为默认模块,可以不指定;
ansible web -a &quot;hostname&quot;

`# 特殊操作可以使用shell模块,同样是命令模块
ansible web -m shell -a &quot;ifconfig |grep eth0 &quot; -f 50
`# -f = forks /etc/ansible/ansible.cfg   #结果返回的数量&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;script脚本模块&quot;&gt;5. script脚本模块&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;ansible web -m script -a &quot;/scripts/check_flog.sh&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;yum-安装软件模块&quot;&gt;6. yum 安装软件模块&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;`# name         指定要安装的软件包名称;
`# state        指定使用yum的方法; (installed,persent #安装) (removed,absent #移除软件包)  (latest #安装最新)
`# exclude      排除
`# enablerepo       指定yum仓库
`# disablerepo      安装时不使用哪个仓库
ansible web -m yum -a &quot;name=nginx state=installed&quot;

ansible web -m yum -a &quot;name=nginx state=latest&quot;

ansible web -m yum -a &quot;name=nginx enablerepo=epel state=present&quot;

ansible web -m yum -a &quot;name=http://192.168.16.236/zabbix/4.0/rhel/7/x86_64/zabbix-agent-4.0.0-2.el7.x86_64.rpm state=present &quot;

ansible web -m yum -a &quot;name='*' state=latest exclude=&quot;kernel*&quot;&quot;

ansible web -m yum -a &quot;name=nginx state=abent&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;copy-拷贝模块&quot;&gt;7. copy 拷贝模块&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;`# src          源文件
`# dest         目标路径
`# backup           对推送过去的文件,进行备份
`# content          直接批量的在被管理端的文件中添加内容
`# group        指定属组
`# owner        指定属主
`# mode         指定权限
ansible web -m copy -a 'src=/etc/yum.repos.d/nginx.repo dest=/tmp/owner=root group=root mode=600 backup=yes'

ansible web -m copy -a &quot;src=/etc/nginx/nginx.conf dest=/etc/nginx/nginx.conf owner=root group=root mode=0644 backup=yes&quot;

# 直接向远端文件内写入数据信息,并且会覆盖远端文件内原有数据信息
ansible web -m copy -a &quot;content='test' dest=/tmp/dtest.txt&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;systemd-启动服务模块&quot;&gt;8.systemd 启动服务模块&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;`# name         服务名称
`# state        操作  ( started  stopped  restarted  reloaded )
`# enabled          是否开机自启动 yes|no
ansible web -m systemd -a &quot;name=nginx state=started&quot;

ansible web -m systemd -a &quot;name=nginx state=started enabled=yes&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;file-文件配置模块&quot;&gt;9.file 文件配置模块&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;`# path      指定远程主机目录或文件信息
`# recures   递归授权
`# state     类型或动作 --&amp;gt;
        `# --&amp;gt; directory    创建目录    
        `# --&amp;gt; touch        创建文件  
        `# --&amp;gt; link     创建链接文件 
        `# --&amp;gt; absent       删除文件或目录 
        `# --&amp;gt; mode     指定权限  
        `# --&amp;gt; owner        指定属主
        `# --&amp;gt; group        指定属组
ansible web -m file -a &quot;path=/tmp/test state=directory&quot;

ansible web -m file -a &quot;path=/tmp/test state=touch mode=555 owner=root group=root&quot;

ansible web -m file -a &quot;src=/tmp/test path=/tmp/test_link state=link&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;group模块&quot;&gt;10. group模块&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;`# name         指定创建的组名
`# gid          指定组的gid
`# state        状态 --&amp;gt;
            `# --&amp;gt; absent  移除远端主机的组
            `# --&amp;gt; present 创建远端主机的组
ansible web -m group -a &quot; name=www gid=666 state=present&quot;

ansible web -m group -a &quot; name=www state=absent&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;user模块&quot;&gt;11. user模块&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;`# name         指定创建的用户名
`# uid          指定用户uid
`# group        指定用户组名称
`# groups       指定附加组名称
`# password     给用户添加密码
`# shell        指定用户登录shell
`# create_home          是否创建家目录
`# system       指定系统用户
ansible web -m user -a &quot;name=www uid=666 shell=/sbin/nologin create_home=no&quot;

`# 将明文密码进行hash加密,然后进行用户创建
ansilbe all -i localhost, -m debug -a &quot;msg={{'password' | password_hash('sha512', 'mysecretsalt' ) }}&quot;  ;
 &quot;msg&quot;: &quot;$6$mysecretsalt$ZB9R8AirQYAXhtfhOo2qdJz52FyNI6v3L6Uc3KNRP.arBKIYpcuEyQewT5qBAHoyQFwHkW6Z551Ql.cZ53GeY0&quot;
ansible web -m user -a 'name=mysql password=&quot;$6$mysecretsalt$ZB9R8AirQYAXhtfhOo2qdJz52FyNI6v3L6Uc3KNRP.arBKIYpcuEyQewT5qBAHoyQFwHkW6Z551Ql.cZ53GeY0&quot;'&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;mount-挂载&quot;&gt;12. mount 挂载&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;`# src          源设备( 磁盘|光盘|远程共享地址 )
`# path         挂载点
`# fstype       设备类型  --&amp;gt; nfs  xfs  ext4   iso9660
`# opts         挂载选项    defaults
`# stste        状态 --&amp;gt;
            `# --&amp;gt; absent  | mounted   永久挂载
                        `# --&amp;gt; present | unmounted 临时挂载
ansible web -m mount -a &quot;src=172.16.1.31:/data/blog path=/opt fstype=nfs opts=defaults state=mounted&quot;

ansible web -m mount -a &quot;src=172.16.1.31:/data/blog path=/opt fstype=nfs opts=defaults state=unmounted&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;selinux&quot;&gt;13. selinux&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;`# 关闭selinux
ansible web -m selinux -a &quot;state=disabled&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;firewalld&quot;&gt;14. firewalld&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;`# zone         指定区域 默认public
`# service      指定服务名称
`# port         指定端口
`# state        启用或禁止
`# masquerade           开机地址伪装是否开启 yes|no
`# immediate            临时生效 yes | no
`# permanent            永久生效
`# source           来源IP
`# rich_rule:   rule service name=&quot;ftp&quot; audit limit value=&quot;1/m&quot; accept
ansible web -m firewalld -a &quot;zone=public  service=http state=enabled immediate=yes permanent=yes&quot;
ansible web -m firewalld -a &quot;zone=public  port=80/tcp state=enabled immediate=yes permanent=yes&quot;

`# 将5555端口转发到 172.16.1.7 22  端口 开启masquerade地址伪装`
ansible web -m firewalld -a &quot;zone=public rich_rule='rule family=ipv4 forward-port port=5555 protocol=tcp to-port=22 to-addr=172.16.1.7'  state=enabled immediate=yes&quot;

ansible web -m firewalld -a &quot;zone=public masquerade=yes state=enabled immediate=yes&quot;

`# 配置基于来源IP  10.0.0.1主机 放行 22 端口`
ansible web -m firewalld -a &quot;zone=public rich_rule='rule family=ipv4 source address=10.0.0.100/32 service name=ssh accept'  state=enabled immediate=yes&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;cron-定时任务模块&quot;&gt;15. cron 定时任务模块&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;

`# 添加一个定时任务
ansible web -m cron -a &quot;name='Backup scripts' minute=00 hour=05 user=root job='/bin/bash /scripts/check_data.sh &amp;amp;&amp;gt;/dev/null'&quot;

`# 删除定时任务
ansible web -m cron -a &quot;name='Backup scripts' minute=00 hour=05 user=root job='/bin/bash /scripts/check_data.sh &amp;amp;&amp;gt;/dev/null' state=absent&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;yum_repository-源仓库模块&quot;&gt;16.yum_repository 源仓库模块&lt;/h5&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;`# name             仓库名称,文件的名称
`# description                  描述
`# baseurl          仓库地址
`# enabled          是否启用该仓库yes
`# gpgcheck         不对下载的包检查

ansible web -m yum_repository -a 'name=rpmforge description=&quot;RPMforge YUM Repo&quot; baseurl=&quot;https://mirrors.tuna.tsinghua.edu.cn/centos/$releasever/os/$basearch/&quot; enabled=yes gpgcheck=no'&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 18 Dec 2019 00:36:00 +0000</pubDate>
<dc:creator>IMSCZ</dc:creator>
<og:description>Ansible模块 bash 环境 ` ansible: 172.16.1.61 cat /etc/ansible/hosts [web] web1:	172.16.1.7 web2: 172.16.</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/IMSCZ/p/12057969.html</dc:identifier>
</item>
<item>
<title>Mybatis中#{}与${}的区别 - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11991027.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11991027.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在开发中使用Mybatis经常使用到#{}与${}，依旧有很多开发者对二者的使用不是很清晰，正所谓好记性不如烂笔头，特此总结一下。&lt;/p&gt;
&lt;p&gt;在mybatis中动态 sql 是其主要特性之一，在 mapper 中定义的参数传到 xml 中之后，在执行操作之前 mybatis 会对其进行动态解析。mybatis 提供了两种支持动态 sql 的语法：#{} 以及 $ {}，其最大的区别则是&lt;span&gt;&lt;strong&gt;#{}方式能够很大程度防止sql注入(安全)，${}方式无法防止Sql注入&lt;/strong&gt;&lt;/span&gt;。什么？？不懂什么是Sql注入？额。。。Sql注入指的是程序解析时会将你传入的参数作为原来SQL语句的一部分，打乱原来SQL的结构，而通常我们只是需要传入一个参数而已.&lt;/p&gt;
&lt;h2 id=&quot;彻底理解sql注入&quot;&gt;彻底理解SQL注入&lt;/h2&gt;
&lt;p&gt;什么？还不懂SQL注入，我湖了QAQ。。。那就来个最简单的例子：一般开发，肯定是在前台有两个输入框，一个用户名，一个密码，会在后台里，读取前台传入的这两个参数，拼成一段SQL，例如： select count(1) from tab where usesr=userinput and pass = passinput,把这段SQL连接数据后，看这个用户名/密码是否存在，如果存在的话，就可以登陆成功了，如果不存在，就报一个登陆失败的错误。对吧。&lt;br/&gt;但是有这样的情况，这段SQL是根据用户输入拼出来，如果用户故意输入可以让后台解析失败的字符串，这就是SQL注入，例如，用户在输入密码的时候，输入 '''' ' or 1=1'', 这样，后台的程序在解析的时候，拼成的SQL语句，可能是这样的： select count(1) from tab where user=userinput and pass='' or 1=1; 看这条语句，可以知道，在解析之后，用户没有输入密码，加了一个恒等的条件 1=1，这样，这段SQL执行的时候，返回的 count值肯定大于1的，如果程序的逻辑没加过多的判断，这样就能够使用用户名 userinput登陆，而不需要密码。&lt;br/&gt;防止SQL注入，首先要对密码输入中的单引号进行过滤，再在后面加其它的逻辑判断，或者不用这样的动态SQL拼&lt;/p&gt;
&lt;h2 id=&quot;关于&quot;&gt;关于 # { }&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;1、#{}表示一个占位符号 相当于 &lt;code&gt;jdbc&lt;/code&gt;中的 &lt;span&gt;&lt;strong&gt;?&lt;/strong&gt;&lt;/span&gt; 符号&lt;br/&gt;#{}实现的是向prepareStatement中的预处理语句中设置参数值，sql语句中#{}表示一个占位符即?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;2、#{}将传入的数据都当成一个字符串，会对自动传入的数据加一个&lt;span&gt;双引号&lt;/span&gt;。如：&lt;code&gt;select * from user where id= #{user_id}&lt;/code&gt;，如果传入的值是11,那么解析成sql时的值为&lt;code&gt;where id=&quot;11&quot;&lt;/code&gt; ，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;3、如果sql语句中只有&lt;code&gt;一个参数&lt;/code&gt;,此时参数名称可以&lt;code&gt;随意定义&lt;/code&gt;&lt;br/&gt;如果sql语句有&lt;span&gt;&lt;strong&gt;多&lt;/strong&gt;&lt;/span&gt;个参数,此时参数名称应该是与当前表关联[实体类的属性名]或则[Map集合关键字]，&lt;span&gt;&lt;strong&gt;不能随便写，必须对应&lt;/strong&gt;&lt;/span&gt;！如下图&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/5/16ed59740e555b8a?w=1421&amp;amp;h=352&amp;amp;f=png&amp;amp;s=171098&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;关于-1&quot;&gt;关于$ { }&lt;/h2&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;1、$ {}将传入的数据&lt;span&gt;直接显示生成&lt;/span&gt;在sql中。如：&lt;code&gt;select * from user where id= $ {user_id}&lt;/code&gt;，如果传入的值是11,那么解析成sql时的值为&lt;code&gt;where id=11&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;2、&lt;code&gt;$ {value}&lt;/code&gt;中&lt;code&gt;value&lt;/code&gt;值有限制只能写对应的value值&lt;span&gt;不能随便写，&lt;/span&gt;因为&lt;code&gt;${}&lt;/code&gt;不会自动进行jdbc类型转换&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;3、简单来说,在&lt;code&gt;JDBC&lt;/code&gt;不支持使用占位符的地方,都可以使用&lt;code&gt;${}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;mybatis中与的区别&quot;&gt;Mybatis中#{}与${}的区别&lt;/h2&gt;
&lt;p&gt;简单来说区别就是&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;#{}方式能够很大程度防止sql注入(安全)，${}方式无法防止Sql注入&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在&lt;code&gt;JDBC&lt;/code&gt;能使用占位符的地方,最好优先使用&lt;code&gt;#{}&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;在&lt;code&gt;JDBC&lt;/code&gt;不支持使用占位符的地方,就只能使用&lt;code&gt;${}&lt;/code&gt;，典型情况就是 &lt;span&gt;&lt;strong&gt;动态参数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如 有两张表,分别是&lt;code&gt;emp_2017&lt;/code&gt; 和 &lt;code&gt;emp_2018&lt;/code&gt; .如果需要在查询语句中 &lt;span&gt;&lt;strong&gt;动态指定表名&lt;/strong&gt;&lt;/span&gt;,就只能使用${}&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;select&amp;gt;
      select *  from emp_ ${year}
&amp;lt;select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再比如MyBatis &lt;span&gt;&lt;strong&gt;排序时使用&lt;code&gt;order by&lt;/code&gt; 动态参数&lt;/strong&gt;&lt;/span&gt;时,此时也只能使用${}&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;select&amp;gt;
       select  *  from dept order by ${name}
&amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;代码案例&quot;&gt;代码案例&lt;/h2&gt;
&lt;p&gt;一般# {}与$ {}用的比较多的地方是模糊查询方面，所以下面来一个模糊查询的案例&lt;/p&gt;
&lt;h2 id=&quot;使用案例&quot;&gt;&lt;strong&gt;使用#{}案例&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、映射文件&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在User.xml配置文件中添加如下内容：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- 如果返回多个结果，mybatis会自动把返回的结果放在list容器中 --&amp;gt;
    &amp;lt;!-- resultType的配置和返回一个结果的配置一样 --&amp;gt;
    &amp;lt;select id=&quot;queryUserByUsername1&quot; parameterType=&quot;string&quot;
        resultType=&quot;cn.itcast.mybatis.pojo.User&quot;&amp;gt;
        SELECT * FROM `user` WHERE username LIKE #{username}
    &amp;lt;/select&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2、测试程序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;MybatisTest中添加测试方法如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@Test
    public void testQueryUserByUsername1() throws Exception {
        // 4. 创建SqlSession对象
        SqlSession sqlSession = sqlSessionFactory.openSession();

        // 5. 执行SqlSession对象执行查询，获取结果User
        // 查询多条数据使用selectList方法
        List&amp;lt;Object&amp;gt; list = sqlSession.selectList(&quot;queryUserByUsername1&quot;, &quot;%王%&quot;);

        // 6. 打印结果
        for (Object user : list) {
            System.out.println(user);
        }

        // 7. 释放资源
        sqlSession.close();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试效果如下图：&lt;br/&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/5/16ed59740ddf0b21?w=693&amp;amp;h=116&amp;amp;f=png&amp;amp;s=40653&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用-案例&quot;&gt;&lt;strong&gt;使用$ {}案例&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、映射文件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在User.xml配置文件中添加如下内容：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!-- 如果传入的参数是简单数据类型，${}里面必须写value --&amp;gt;
    &amp;lt;select id=&quot;queryUserByUsername2&quot; parameterType=&quot;string&quot;
        resultType=&quot;cn.itcast.mybatis.pojo.User&quot;&amp;gt;
        SELECT * FROM `user` WHERE username LIKE '%${value}%'
    &amp;lt;/select&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2.测试程序：&lt;/strong&gt;&lt;br/&gt;MybatisTest中添加测试方法如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;@Test
public void testQueryUserByUsername2() throws Exception {
    // 4. 创建SqlSession对象
    SqlSession sqlSession = sqlSessionFactory.openSession();

    // 5. 执行SqlSession对象执行查询，获取结果User
    // 查询多条数据使用selectList方法
    List&amp;lt;Object&amp;gt; list = sqlSession.selectList(&quot;queryUserByUsername2&quot;, &quot;王&quot;);

    // 6. 打印结果
    for (Object user : list) {
        System.out.println(user);
    }

    // 7. 释放资源
    sqlSession.close();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然两个案例效果一致！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/3/16ec91dd7ed90e8e?w=1430&amp;amp;h=544&amp;amp;f=png&amp;amp;s=499085&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 18 Dec 2019 00:32:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>前言 在开发中使用Mybatis经常使用到 {}与${}，依旧有很多开发者对二者的使用不是很清晰，正所谓好记性不如烂笔头，特此总结一下。 在mybatis中动态 sql 是其主要特性之一，在 mapp</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11991027.html</dc:identifier>
</item>
<item>
<title>【玩转SpringBoot】用好条件相关注解，开启自动配置之门 - 编程新说(李新杰)</title>
<link>http://www.cnblogs.com/lixinjie/p/playing-springboot-002.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/playing-springboot-002.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;br/&gt;自动配置隐含两层含义，要搞清楚&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;上帝让程序员的发量减少，是为了让他变得更聪明，如果有一天聪明到了极点，那就是绝顶聪明。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;据说在大脑高速运转下，这样更有利于散热，不至于核心温度过高而产生告警。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;聪明的大脑是用来思考的，现在就来深入思考和分析下自动配置。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;自动配置包含两层意思，一个是配置，一个是自动。这不废话嘛。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;配置存在的一个前提是，要有选择才行，如果没得选择，就不用谈配置了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;比如十几年前读大学时，无论是回家还是去学校，都只能坐最便宜的硬座。因为没得选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;现在情况就不一样了，高铁、动车、飞机都可以了。有了选择，就可以谈配置了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;所以配置就是在一些可选项里做出选择，既然是选择，就需要有选择的依据/理由。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果距离不太远的话，选择高铁，这样在花费的时间和金钱上是相对均衡的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果此时想稍微省点钱的话，选择动车，不过花的时间稍多些。也算一种取舍吧。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果距离太远的话，选择飞机，这样时间和金钱上才是最均衡的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这些列举出来的影响选择的因素，其实就是“条件”。因此，配置就是根据条件做出选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那自动的意思就是，使用工具或一套程序根据条件做出选择，最后只把结果告诉我们即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就是说，我们不参与选择的过程，我们只需提供一些和“条件”相关的信息即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;Spring的风格，万物皆可注解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;通过上一小节，我们成功的把自动配置转化为条件和工具。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;回到程序里，条件指的是什么？如果不知道的话，那条件语句指的是什么？&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;就是if...else，要根据条件做出判断，所以条件就是某种形式的程序代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;那工具呢？就是一些常用代码或算法的集合嘛。也是某种形式的程序代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;条件和工具已经被成功的转化为了程序代码，现在来看，自动配置就等于程序代码。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;关键是这个程序代码是让我们来写吗？如果是的话，那可就产生悖论了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为配置通常意味着不写代码，如果还要写代码的话，那就不叫配置了，叫搞笑了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因此，条件和工具的程序代码，SpringBoot都写好了，并通过注解进行了封装。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最后把这些注解暴露出来，供用户使用，这就是条件注解的由来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;用户可以通过设置注解属性把“条件”相关信息传递进去，让底层的“工具”进行判断和选择。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;最终，不同的条件产生了不同的行为，达到了自动配置的目的。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;官方提供的常用条件注解&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为Spring的核心是基于bean的，所以这些条件注解主要是影响bean的注册。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;因为注册的bean不同了，最后对外呈现的行为就不同了。不就是自动配置了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;一、最常用的应该是@Profile注解了&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;根据不同的环境可以注册不同的bean，如下图01：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134725654-1790403847.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;首先，不激活任何环境，执行一下，结果如下图02：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134741863-502214583.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;可以看到，没有激活任何环境，所以默认是default。因此Default类就被注册了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;然后，激活一下prod环境，在IDE里设置一下，如下图03：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134759775-554913621.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;再次运行一下，结果如下图04：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134807562-143199320.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;可以看到，prod环境被激活了，所以Prod类就被注册了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;SpringBoot内置了一些注解，如下图05：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134818715-1572108920.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;我们关注一些常用的就可以了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;二、@ConditionalOnProperty注解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个注解用于检测Environment中的指定属性是否存在或等于某个指定的值。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图06：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134830748-1011282566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;如havingValue属性没有指定的话，那么只要实际属性值不等于false，都算匹配成功。如果指定了，那就必须要一样才行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;matchIfMissing属性就是说，如果没有发现这个属性，算不算匹配上，设置为true就算，false就不算，默认为不算。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;请看配置文件，如下图07：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134841826-1822015580.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;很明显，这是可以匹配上的，运行一下，结果如下图08：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134903999-924700272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;可以看到，对应的类被注册了bean定义。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;三、@ConditionalOnClass注解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个注解用于检测类路径里是否包含某个类，其实就是确定是否引入了指定的依赖。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图09：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134912615-1291461604.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;因为我用的JDK1.8，肯定有这个类，所以会匹配上，结果如下图10：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134920460-1239954025.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：@ConditionalOnMissingClass注解原理一样，只不过是否定性的匹配而已。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;四、@ConditionalOnBean注解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个注解用于检测容器中是否包含指定的bean。如下图11：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134929511-1158219991.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;除了可以用Class&amp;lt;?&amp;gt;指定bean外，还可以使用类的全名称，还可以使用bean名称（即beanName）。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;还可以使用注解指定是否包含标有该注解的bean。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;示例中是通过Class&amp;lt;?&amp;gt;来指定的，而且指定的是之前注册过的bean，所以一定能匹配上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;执行结果如下图12：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134938927-1986608049.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;strong&gt;&lt;span&gt;注&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：@ConditionalOnMissingBean注解原理一样，只不过是否定性的匹配而已。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;五、@ConditionalOnSingleCandidate注解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个注解用于检测容器中能够匹配上的候选bean是否只有一个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;只有一个是什么意思呢？就是某个类只注册了一次，这时就是只有一个。比如Boss类。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;但是员工可以有多个，所以就会有多个Staff类被注册。此时就不满足条件了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如果此时还想满足的话，就必须在其中一个Staff类注册时标上&lt;/span&gt;&lt;span&gt;@Primary&lt;/span&gt;&lt;span&gt;注解。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;如下图13：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134951046-1029111762.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;因为我们指定的bean只注册了一次，所以一定满足条件。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;执行结果如下图14：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215134959772-2052012668.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;六、@ConditionalOnResource注解&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;这个注解用于检测类路径中是否包含指定的资源。一般也就是文件了。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来检测下配置文件，如下图15：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215135007378-180387028.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;肯定是存在的，执行结果如下图16：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215135015339-129123777.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;自定义条件注解&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;需要实现一个条件接口，如下图17：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215135024831-606407838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;只有一个方法，返回true表示匹配上，false则相反。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法的第一个参数，是一个上下文，如下图18：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215135041542-233748894.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;这里有很多的东西供我们使用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;方法的第二个参数，是最终标有我们定义好的条件注解的那个类，这个一定要明白。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;我们来定义两个和操作系统对应的注解，一个用于Windows，一个用于Linux。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Windows版本的实现，如下图19：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215135105310-822640517.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;从Environment中读出操作系统的名称，看是否包含windows即可。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Linux版本的实现，如下图20：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215135115993-1894405447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;原理和刚刚的一样。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;再定义两个注解，分别和这两个条件实现类关联起来。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;Windows版本的，如下图21&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215135125837-150808650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;Linux版本的，如下图22：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215135137169-1724321833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;然后开始试用一下这两个条件注解，如下图23：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215135147360-560516367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;因为我用的是Windows，所以肯定只有@Windows注解可以匹配。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;执行结果如下图24：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215135157014-1268774477.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;这只是一个简单的示例，可以根据自己的需要定义更加复杂的，但是原理和流程都是一样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 玩转SpringBoot系列文章 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484558&amp;amp;idx=1&amp;amp;sn=6da1a74d280f4f2a41cbf5874ed620e0&amp;amp;chksm=fc333f7ecb44b668f8d18be8efa436d8052d98874f843a8edf314141c7a4bb4bcb2345ab5ae4&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【玩转SpringBoot】配置文件yml的正确打开姿势&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 品Spring系列文章 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484229&amp;amp;idx=1&amp;amp;sn=b552914c42963d06306d35f1d8332284&amp;amp;chksm=fc3338b5cb44b1a39d0762b2fd94d8870fcbc520b0713964d9a453d8466d781897707de8cd8f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：bean定义上梁山&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484244&amp;amp;idx=1&amp;amp;sn=d500b3ed748331687028b78d567222a8&amp;amp;chksm=fc3338a4cb44b1b23f5dd9bef1cc66950a1ded23151a05b38716f4ec46ff960cdda5d8022e8f&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：实现bean定义时采用的“先进生产力”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484249&amp;amp;idx=1&amp;amp;sn=dfbdca65a2b64b0ac951f90b301e73a0&amp;amp;chksm=fc3338a9cb44b1bfafee072597430dae91d4dd8b4787e4af0896f9ce45b258fd5d3634169a5d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：注解终于“成功上位”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484259&amp;amp;idx=1&amp;amp;sn=791a5726b9b7bf41e4e64053cfbc7ffa&amp;amp;chksm=fc333893cb44b1851d2052423392551ca9188c4fc0a33f412ddda13af9e0dc6655966a668964&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：能工巧匠们对注解的“加持”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484301&amp;amp;idx=1&amp;amp;sn=a5557c4c285cb07a052238d3de2a2585&amp;amp;chksm=fc33387dcb44b16b487edee0ab4c755de394d19dd4a0acd2532af0e49e95eb7988628e93157b&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot和Spring到底有没有本质的不同？&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484319&amp;amp;idx=1&amp;amp;sn=89d925e6128109444c2ec40111a9f217&amp;amp;chksm=fc33386fcb44b179dcee6ef522e2252420658c0342759a9d6d9795bf90b144f6284c72fe808d&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：负责bean定义注册的两个“排头兵”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484337&amp;amp;idx=1&amp;amp;sn=398a1f718cc8b5a711ba9f45a6d9074b&amp;amp;chksm=fc333841cb44b157da33d685daedda001cb59abb64aa6152c3d4096d43c8d92bff8ae5d084ed&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot轻松取胜bean定义注册的“第一阶段”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484358&amp;amp;idx=1&amp;amp;sn=21fc717c7815ae41103e3e2e4f5520df&amp;amp;chksm=fc333836cb44b120fd9073b6075580109d5665afbd0f50abe43e8a5aea42e066c759dcdb8157&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：SpringBoot发起bean定义注册的“二次攻坚战”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484369&amp;amp;idx=1&amp;amp;sn=ac9d591014074f49a96bc9f3ed7cca4a&amp;amp;chksm=fc333821cb44b137f3c0c7c24b88fc5b3edfa0dc530366b884a3813759ae6fb32c1974e506de&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：注解之王@Configuration和它的一众“小弟们”&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484403&amp;amp;idx=1&amp;amp;sn=f10760d51119f91b5c18d3267ebbd1eb&amp;amp;chksm=fc333803cb44b115a6fcab3e264233514f90fd8874f038361aaa174e8c73bb7f2a31d96f9099&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：bean工厂后处理器的调用规则&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484414&amp;amp;idx=1&amp;amp;sn=16391934efdc318c65251d311a6cc61c&amp;amp;chksm=fc33380ecb44b1183af1d82647996fb5ec24a3cc977b028671cb62f91edcc421542e92ecbe92&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：详细解说bean后处理器&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484431&amp;amp;idx=1&amp;amp;sn=29a6cc3aa9959c04512864ee59365f6b&amp;amp;chksm=fc333fffcb44b6e9cce30ca85ee1c8a32fd5e5597cd27d45a1c1a6bc3bd59b004df3cc66ea22&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：对@PostConstruct和@PreDestroy注解的处理方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484448&amp;amp;idx=1&amp;amp;sn=dc0e6d9b0ddd8168d749b90069999c03&amp;amp;chksm=fc333fd0cb44b6c68127c6a1e8b9c91891ef4ee37df40e7c85d2b67bd058d3c59e5e51d06101&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：对@Resource注解的处理方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484462&amp;amp;idx=1&amp;amp;sn=d492ff48764329f37abd452b0b4e1287&amp;amp;chksm=fc333fdecb44b6c8b6634ac340a63c9271d22a08e53d3adaeef5e487658a425122b45f84fd20&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：对@Autowired和@Value注解的处理方法&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484505&amp;amp;idx=1&amp;amp;sn=98e154a00e7782ec8fb9ca2d6295dfcd&amp;amp;chksm=fc333fa9cb44b6bf0283da8353aba4cca8267315c91e18765dfebc4aa70da96394b9b374e078&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：真没想到，三十步才能完成一个bean实例的创建&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484532&amp;amp;idx=1&amp;amp;sn=09a007062e2d5835a253f14f9269d9b0&amp;amp;chksm=fc333f84cb44b692b4db0a7140776eefe746f52ca03bd522582d35752fc3ed3ff5eb6087feb8&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：关于@Scheduled定时任务的思考与探索，结果尴尬了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&amp;gt;&amp;gt;&amp;gt; 热门文章集锦 &amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484219&amp;amp;idx=1&amp;amp;sn=e6c39138e44ce8f0c91aba4873fb42cd&amp;amp;chksm=fc3338cbcb44b1dde7ae372ed66b40bdf4f755d711008810eb837a8f78d884f00956ae7ce7a7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;毕业10年，我有话说&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483949&amp;amp;idx=1&amp;amp;sn=200c9ac4f8e4e877b0b253d45205712a&amp;amp;chksm=fc3339ddcb44b0cb5ac2957dbed41b2f9e11fbba14967d00f97012806a9d6af364b0f8135eee&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何面试别人List相关知识的，深度有点长文&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483989&amp;amp;idx=1&amp;amp;sn=cf9ce5c3f7981c16b71047b868b1c1ab&amp;amp;chksm=fc3339a5cb44b0b3df524ce684e8cd76ab6d15a2ccf26ec2425ecbcdd26bc777b95a06994189&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;我是如何在毕业不久只用1年就升为开发组长的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247483994&amp;amp;idx=1&amp;amp;sn=fb09e943331e89abcb99d8304ea6b677&amp;amp;chksm=fc3339aacb44b0bc2a120c79efebb46a43ce5b4d3148992d86b2841a89bb46bf5d8863e065ea&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;爸爸又给Spring MVC生了个弟弟叫Spring WebFlux&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484017&amp;amp;idx=1&amp;amp;sn=a2055640b142fc4cfa5a9901d22ec57f&amp;amp;chksm=fc333981cb44b09782c196da25dc613b38a9ede52de073bfaaaef6214a9deb294b6527091892&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Spring事务时“套路”对方的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484029&amp;amp;idx=1&amp;amp;sn=44b05473af37fe008bb9659a35d1a9de&amp;amp;chksm=fc33398dcb44b09bbd25a7e14e7100419988479fbeb4bda7787f1b93dd932ec699dfd793df04&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】Spring事务面试考点吐血整理（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484158&amp;amp;idx=1&amp;amp;sn=1ca952ba9166c5ccf0e3f40622335fc5&amp;amp;chksm=fc33390ecb44b01898bb2500ba61a15e38487a23f5c0405d738cc4c272cd705d2dbbf1a3f8e7&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】我是如何在面试别人Redis相关知识时“软怼”他的&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484164&amp;amp;idx=1&amp;amp;sn=390d911b19812d22aebd3f0f6522004c&amp;amp;chksm=fc3338f4cb44b1e20bc2344474586934a2b148f92eefdaecf134d57af10f64310579e196904a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】吃透了这些Redis知识点，面试官一定觉得你很NB（干货 | 建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484184&amp;amp;idx=1&amp;amp;sn=37007efde0cc93e48c55a133dc9cc8d4&amp;amp;chksm=fc3338e8cb44b1fea0ed4af7f01de658e8a1bc7f573cb5bde2701d9b09ba14747139d2bcea39&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果你这样回答“什么是线程安全”，面试官都会对你刮目相看（建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484195&amp;amp;idx=1&amp;amp;sn=95c3acdaeb0f6a1d61f152550c3d2669&amp;amp;chksm=fc3338d3cb44b1c55f6046f6280da863d3514cca3ce50ef29e2d53b0eafe2b7efef062c51c27&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】迄今为止把同步/异步/阻塞/非阻塞/BIO/NIO/AIO讲的这么清楚的好文章（快快珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484201&amp;amp;idx=1&amp;amp;sn=7cf45aff64eecdff58d2acea8fb7c9fa&amp;amp;chksm=fc3338d9cb44b1cfc6b5c797a005c91ed19b0dd06587fdfb2e7b553e2b03104a145380a7a990&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】一篇文章帮你彻底搞清楚“I/O多路复用”和“异步I/O”的前世今生（深度好文，建议珍藏）&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484206&amp;amp;idx=1&amp;amp;sn=9547fdad111ac1a8ac9311cb9e76b9dc&amp;amp;chksm=fc3338decb44b1c89aee789e80e32989ea43232321397cc265c99b1d0ce4057e6563bc00a3d3&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;【面试】如果把线程当作一个人来对待，所有问题都瞬间明白了&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484214&amp;amp;idx=1&amp;amp;sn=0f677e8b0d61b5a5317a274cc8b33cbc&amp;amp;chksm=fc3338c6cb44b1d06aa20533aafb0b7b709b3bd88dbf6af6b8f3cb91288e4afc585ecb77489a&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;Java多线程通关———基础知识挑战&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://mp.weixin.qq.com/s?__biz=MzU1NzY1Nzc1OQ==&amp;amp;mid=2247484224&amp;amp;idx=1&amp;amp;sn=78a994d8311dd0abf3f9419108ff363a&amp;amp;chksm=fc3338b0cb44b1a6803dbeb8540c17ce753f1878e3b7cc86cf6508e81dc32736f84d7224f166&amp;amp;scene=21#wechat_redirect&quot; target=&quot;_blank&quot; data-itemshowtype=&quot;0&quot; data-linktype=&quot;2&quot;&gt;&lt;span&gt;品Spring：帝国的基石&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;作者&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;是工作超过&lt;/span&gt;&lt;span&gt;&lt;strong&gt;10年&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;的码农，现在任架构师。喜欢研究技术，崇尚简单快乐。&lt;/span&gt;&lt;span&gt;&lt;strong&gt;追求以通俗易懂的语言解说技术，希望所有的读者都能看懂并记住。&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;下面是公众号的二维码，欢迎关注！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/76066/201912/76066-20191215135208590-1626983083.jpg&quot; alt=&quot;&quot;/&gt;  &lt;/p&gt;
</description>
<pubDate>Wed, 18 Dec 2019 00:18:00 +0000</pubDate>
<dc:creator>编程新说(李新杰)</dc:creator>
<og:description>自动配置隐含两层含义，要搞清楚上帝让程序员的发量减少，是为了让他变得更聪明，如果有一天聪明到了极点，那就是绝顶聪明。据说在大脑高速运转下，这样更有利于散热，不至于核心温度过高而产生告警。聪明的大脑是用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lixinjie/p/playing-springboot-002.html</dc:identifier>
</item>
<item>
<title>一次框架性能的比较，引起了我对搭建web框架的兴趣 - SexyPhoenix</title>
<link>http://www.cnblogs.com/SexyPhoenix/p/12035309.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SexyPhoenix/p/12035309.html</guid>
<description>&lt;h4 id=&quot;背景&quot;&gt;背景&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;一次无意的访问，点击到了一个专门做PHP性能测试的网站，看这里&lt;a href=&quot;http://www.phpbenchmarks.com/en/&quot;&gt;PHP Benchmarks&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在里面发现了框架性能测试的结果，发现Laravel的框架性能尽然是最低的。瞬间受到了一万点的暴击，谁让最近一直用Laravel开发项目的呢。&lt;/p&gt;
&lt;p&gt;说到底还是Laravel好用呀，方便不说，各方面支持的也不错，业务方面做的也是内部系统，哪怕性能慢点，也可以用前后端分离、负载均衡等手段解决掉，大体上也是够用。&lt;/p&gt;
&lt;p&gt;不过，作为一个开发人员，理想还是要有的，这时就在想能不能采取Laravel框架的优点，用到什么就装什么，去掉一些请求到响应之间用不到的组件，精简框架。&lt;/p&gt;
&lt;p&gt;之前也熟读过Laravel的源码，知道它的底层用的是Symfony的组件，毕竟没必要重复的造轮子。那么我们的框架之旅也将基于Symfony组件。。。&lt;/p&gt;
&lt;h4 id=&quot;目录&quot;&gt;目录&lt;/h4&gt;
&lt;hr/&gt;&lt;p&gt;一、Composer运行机制&lt;/p&gt;
&lt;p&gt;二、框架前期准备&lt;/p&gt;
&lt;p&gt;三、HttpFoundation组件封装Request、Response&lt;/p&gt;
&lt;p&gt;四、路由处理&lt;/p&gt;
&lt;p&gt;五、控制器处理相应功能（C）&lt;/p&gt;
&lt;p&gt;六、分离模板（V）&lt;/p&gt;
&lt;p&gt;七、分离模型（M）&lt;/p&gt;
&lt;p&gt;八、剥离核心代码&lt;/p&gt;
&lt;p&gt;九、优化框架&lt;/p&gt;
&lt;p&gt;十、依赖注入（Dependency Injection）&lt;/p&gt;
&lt;h4 id=&quot;正文&quot;&gt;正文&lt;/h4&gt;
&lt;hr/&gt;&lt;h6 id=&quot;一composer运行机制&quot;&gt;一、Composer运行机制&lt;/h6&gt;
&lt;p&gt;Composer的使用最关键的得益于&lt;a href=&quot;https://www.php-fig.org/psr/&quot;&gt;PHP标准规范&lt;/a&gt;的出现，特别是其中的psr4，&lt;strong&gt;&lt;em&gt;自动加载规范&lt;/em&gt;&lt;/strong&gt;，规范了如何指定文件路径从而自动加载类定义，以及自动加载文件的位置。&lt;/p&gt;
&lt;p&gt;既然讲到php文件的加载，我们就要聊一聊PHP的加载机制了。&lt;/p&gt;
&lt;p&gt;在早前时，加载文件用的都是include、require，但这种加载有很大的局限性，相信同学们都知道，无论用到用不到都要加载大量的文件，相当繁琐。&lt;/p&gt;
&lt;p&gt;于是就出现了&lt;strong&gt;&lt;em&gt;autoload加载机制&lt;/em&gt;&lt;/strong&gt;，它可以实现懒加载。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;function __autoload($class)
{
    require_once ($class.&quot;.php&quot;);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当程序引用了未加载的类，就会自动调用__autoload方法，只要维护了__autoload方法，就可以懒加载文件。&lt;/p&gt;
&lt;p&gt;但这里有一个很大的问题，就是程序中只能定义一次__autoload，这就需要花大尽力在__autoload中维护文件和空间的对应关系，特别是在大型项目，多人合作中更是繁琐。&lt;/p&gt;
&lt;p&gt;而解决这个问题就是&lt;strong&gt;&lt;em&gt;SPL Autoload&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;SPL Autoload：__autoload调用堆栈。&lt;/p&gt;
&lt;p&gt;怎么理解这个堆栈呢，举个例子。&lt;/p&gt;
&lt;p&gt;现有的框架比如ThinkPHP、Laravel等都有一个vendor目录，用于存放第三方库，现在vendor下有两个库。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;monolog 处理系统日志&lt;br/&gt;guzzlehttp 处理HTTP&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当程序引用这两个库的命名空间，并调用monolog、guzzlehttp下面的类时，发现调用的类文件都能被找到。&lt;/p&gt;
&lt;p&gt;这主要原理是&lt;strong&gt;monolog、guzzlehttp都自定义了类似autoload的方法，然后用spl_autoload_register将方法注册到了SPL堆栈中&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这样的话，当程序调用类的时候，就会统一到SPL堆栈中寻找注册到堆栈中的autoload方法，并加载相应的文件。&lt;/p&gt;
&lt;p&gt;以上就是php加载文件的方式，下面就用实战谈一谈composer的运行机制。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建composer项目&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# mkdir phoenix
# cd phoenix
composer init&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;phoenix是接下来搭建的框架名。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423266/201912/423266-20191213145722779-1166036017.png&quot; alt=&quot;1&quot;/&gt;&lt;/p&gt;
&lt;p&gt;创建成功后，发现当前文件夹下会生成一个composer.json文件，里面是刚写入的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer dump&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423266/201912/423266-20191213151529602-1061437579.png&quot; alt=&quot;2&quot;/&gt;&lt;/p&gt;
&lt;p&gt;tree后，就会发现多了一个vendor的目录，里面的autoload.php以及composer文件夹下文件就是&lt;strong&gt;整个框架的加载核心&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接下来看一遍这些文件。&lt;/p&gt;
&lt;p&gt;在整个框架中，第一行必然要引用 vendor/autoload.php 文件，毕竟这是加载核心，那么就从autoload.php看起。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# autoload.php
require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInit599fa618dd1395bdde5fc3a08ff3e4e6::getLoader(); &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;只调用了autoload_real.php里面的getLoader()方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#autoload_real.php 精简后的代码

public static function loadClassLoader($class)
{
    if ('Composer\Autoload\ClassLoader' === $class) {
        require __DIR__ . '/ClassLoader.php';
    }
}

public static function getLoader()
{
    #创建ClassLoader类
    spl_autoload_register(array('ComposerAutoloaderInit599fa618dd1395bdde5fc3a08ff3e4e6', 'loadClassLoader'), true, true);

    #初始化ClassLoader对象（主要就是将命名空间和文件的映射写入ClassLoader的属性中）
    self::$loader = $loader = new \Composer\Autoload\ClassLoader();

    spl_autoload_unregister(array('ComposerAutoloaderInit599fa618dd1395bdde5fc3a08ff3e4e6', 'loadClassLoader')); 
     
    #loadClass方法（类似autoload方法）注册到 SPL Autoload
    $loader-&amp;gt;register(true);   
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;autoload_real.php 的作用就是引入ClassLoader类、初始化ClassLoader类，并注册到SPL堆栈中。&lt;/p&gt;
&lt;p&gt;ClassLoader类中有很多属性，这些属性的作用也很简单：&lt;strong&gt;主要就是方便后面程序快速的通过命名空间找到它所映射的类文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;具体用到这些属性的方法就在ClassLoader类中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ClassLoader.php
# 一个快速找到文件的算法，很有意思，感兴趣的可以研究下
# 主要通过首字符找到命名空间以及长度，再根据命名空间以及长度找到文件

private function findFileWithExtension($class, $ext)
{
    ......
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么ClassLoader类属性里面的值是什么时候写入的呢？&lt;/p&gt;
&lt;p&gt;答案很简单：&lt;strong&gt;当为项目安装组件时，即composer require xxx时，会更新ClassLoader类的属性值，也就是将命名空间和文件地址做一个关联&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接下来看看它的register方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ClassLoader.php 
public function register($prepend = false)
{
    spl_autoload_register(array($this, 'loadClass'), true, $prepend);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看，其实很简单，就是将loadClass注册到SPL堆栈中。&lt;/p&gt;
&lt;p&gt;那么现在就很清楚了，当程序使用了一个还未加载的类时，会调用什么方法？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然是loadClass方法&lt;/strong&gt;，再来看看loadClass方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# ClassLoader.php 
public function loadClass($class)
{
    if ($file = $this-&amp;gt;findFile($class)) {
        includeFile($file);

        return true;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;根据方法的名称就能看出它的功能：1、找到文件 2、加载文件。&lt;/p&gt;
&lt;p&gt;总结一下Composer的运行机制：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、在composer require安装时，更新ClassLoader类的属性&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、运行对象时（new \Test()），如果未加载就会执行loadClass()，通过首字符找到命名空间以及长度，再根据命名空间以及长度找到文件，最后include文件&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;以上就是Composer的运行机制，接下来，就进入真正的框架搭建了。&lt;/p&gt;
&lt;h6 id=&quot;二框架前期准备&quot;&gt;二、框架前期准备&lt;/h6&gt;
&lt;p&gt;在正式进入搭建框架之前，先看下整体的架构图以及一些前期准备。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423266/201912/423266-20191216152622204-972117713.png&quot; alt=&quot;3&quot;/&gt;&lt;/p&gt;
&lt;p&gt;整个架构跟Laravel、ThinkPHP等框架是差不多的，&lt;strong&gt;一次请求，一次返回，一个入口，中间根据路由规则交给相应的控制器去执行，在控制器中处理数据以及视图&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;接下来做一些前期准备，进入phoenix项目。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# vi index.php 一个入口
ini_set('display_errors', 1); # 显示错误
error_reporting(-1);

require_once __DIR__.'/vendor/autoload.php'; # 引入核心加载类

$name = $_GET['name'];
dump($name);&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;# dump()
composer require symfony/var-dumper  # 类似var_dump，输出的变量体验更好些。&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置Nginx，访问域名为：http://dev.phoenix.goods/?name=SexyPhoenix， 可以正常显示SexyPhoenix。&lt;/p&gt;
&lt;h6 id=&quot;三httpfoundation组件封装requestresponse&quot;&gt;三、HttpFoundation组件封装Request、Response&lt;/h6&gt;
&lt;p&gt;现有的程序只是一个面向过程的代码，一个简单的请求，响应。&lt;/p&gt;
&lt;p&gt;对于搭建web框架，这种痛苦写法当然是要被舍弃的，OOP编程才是正路。&lt;/p&gt;
&lt;p&gt;既然要面向对象编程，首先要做的就是对流程中的Request、Response进行封装。而Symfony中专门的组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer require symfony/http-foundation&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.symfonychina.com/doc/current/components/http_foundation.html&quot;&gt;HttpFoundation组件使用说明&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;改造代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# index.php

ini_set('display_errors', 1);
error_reporting(-1);

require_once __DIR__.'/vendor/autoload.php';

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;

$request = Request::createFromGlobals(); # 创建request对象

$name = $request-&amp;gt;get('name', 'World'); # 获取参数，可移入控制器或从模型得到数据

$response = new Response();

$response-&amp;gt;setContent('&amp;lt;b&amp;gt;Hello '.$name.'&amp;lt;/b&amp;gt;'); # 设置内容，可用view处理

$response-&amp;gt;send(); # 返回&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面来做一个简单的分析。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$request = Request::createFromGlobals();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一行代码，是相当重要的，它从对象层面上处理了php的全局变量，例如 GET，POST，SESSION......。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423266/201912/423266-20191216162350741-1176737770.png&quot; alt=&quot;4&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样处理就可以轻易的从request对象中获取所需要的信息以及对请求头等信息的修改。&lt;/p&gt;
&lt;p&gt;后期路由这些附加的信息也是存在request的attributes属性中，及其好用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$response = new Response();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过response对象，可以轻易的控制返回的信息。比如头信息的各种缓存策略......&lt;/p&gt;
&lt;h6 id=&quot;四路由处理&quot;&gt;四、路由处理&lt;/h6&gt;
&lt;p&gt;从架构图上看，接着就要处理路由了。&lt;/p&gt;
&lt;p&gt;phoneix框架用了普遍的做法，统一index.php入口。&lt;/p&gt;
&lt;p&gt;那么下面要做的就是如何将路由的附加参数和要处理的控制器进行映射。&lt;/p&gt;
&lt;p&gt;对于路由一般框架都是通过配置来的，这里也一样做成可配置，方便。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Yaml格式配置路由&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在phoenix项目下，创建routes文件夹，在routes下继续创建web.yaml文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dashboard:
    path: /dashboard
    defaults: { 
        _controller: 'App\Http\Controllers\DashboardController::index'
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下载symfony的Config组件、Yaml组件、Routing组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer require symfony/config
composer require symfony/yaml
composer require symfony/routing&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;http://www.symfonychina.com/doc/current/components/config.html&quot;&gt;Config组件使用说明&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;更新代码&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# index.php
ini_set('display_errors', 1);
error_reporting(-1);

require_once __DIR__.'/vendor/autoload.php';

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Loader\YamlFileLoader; # add 
use Symfony\Component\Config\FileLocator; # add

$request = Request::createFromGlobals();

$fileLoader = new YamlFileLoader(new FileLocator(array(__DIR__))); # add
$collection = $fileLoader-&amp;gt;load('routes/web.yaml'); # add

$name = $request-&amp;gt;get('name', 'World');

$response = new Response();

$response-&amp;gt;setContent('&amp;lt;b&amp;gt;Hello '.$name.'&amp;lt;/b&amp;gt;');

$response-&amp;gt;send();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;dump($collection)，可以看到返回了路由的Collection对象，里面有定义的路由。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423266/201912/423266-20191216173526032-1113725550.png&quot; alt=&quot;5&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候，框架只是得到了定义的路由，但还没有和URL做映射，下面改造继续。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;URL和配置路由映射&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ini_set('display_errors', 1);
error_reporting(-1);

require_once __DIR__.'/vendor/autoload.php';

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Loader\YamlFileLoader;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\Routing\RequestContext; # add
use Symfony\Component\Routing\Matcher\UrlMatcher; # add

$request = Request::createFromGlobals();

$fileLoader = new YamlFileLoader(new FileLocator(array(__DIR__)));
$collection = $fileLoader-&amp;gt;load('routes/web.yaml');

#解析url
$context = new RequestContext(); # add 
$context-&amp;gt;fromRequest($request); # add

#初始化UrlMatcher
$matcher    = new UrlMatcher($collection, $context); # add

#url和路由配置映射
$route = $matcher-&amp;gt;match($request-&amp;gt;getPathInfo()) # add

$name = $request-&amp;gt;get('name', 'World');

$response = new Response();

$response-&amp;gt;setContent('&amp;lt;b&amp;gt;Hello '.$name.'&amp;lt;/b&amp;gt;');

$response-&amp;gt;send();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继续分析。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$context = new RequestContext();
$context-&amp;gt;fromRequest($request);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;context对象主要就是对url进行解析。现在的域名：http://dev.phoenix.goods/dashboard&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423266/201912/423266-20191216172105588-728636732.png&quot; alt=&quot;6&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然解析出url的参数，就要用解析出的参数和配置中的路由做精准关联了，初始化matcher，传入路由配置和url对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423266/201912/423266-20191216172356617-467806567.png&quot; alt=&quot;7&quot;/&gt;&lt;/p&gt;
&lt;p&gt;得到url和配置中的路由的映射。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;$route = $matcher-&amp;gt;match($request-&amp;gt;getPathInfo());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423266/201912/423266-20191216173144227-1036602336.png&quot; alt=&quot;8&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;五控制器处理相应功能c&quot;&gt;五、控制器处理相应功能（C）&lt;/h6&gt;
&lt;p&gt;在路由处理中，框架已经得到了路由和控制器的关联关系。下面就要执行相应的控制器（上面的_controller值）。&lt;/p&gt;
&lt;p&gt;首先，在phoenix项目下，创建app/Http/Controllers/DashboardController.php（仿造Laravel的目录结构）。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# DashboardController.php
namespace App\Http\Controllers; # 注意这里App命名空间，自己定义，并没有注册到autoload

class DashboardController{

    public function index()
    {
        echo 'Hello SexyPhoenix';
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;App命名空间是框架定义的，需要注册后，才能用，打开项目的composer.json文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# composer.json

&quot;autoload&quot;: {
    &quot;psr-4&quot;: {
        &quot;App\\&quot;: &quot;app/&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;composer dump-autoload # 更新命名空间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，控制器的准备工作就做完了，接下来的问题就是如果利用得到的路由和控制器的映射关系去执行控制器，也就是下面的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;App\Http\Controllers\DashboardController::index&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实也很简单，就是用&quot;::&quot;分隔，得到两个值，一个是类名，一个是方法名，再用php的call_user_func去执行。&lt;/p&gt;
&lt;p&gt;但自己去写可能过去粗暴，可用性低，在执行前，要先判断DashboardController类是否存在，index方法是否存在，index方法的权限，是否是公共方法，以及各种参数等等，&lt;/p&gt;
&lt;p&gt;自己去写的话，会很麻烦，为了方便，继续用symfony的组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer require symfony/http-kernel&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;http-kernel组件，是框架的内核，很重要的组件，它提供了各种钩子，及其方便框架扩展，也提供了控制器及其参数的“解析器”（这里需要了解下&lt;a href=&quot;https://www.php.net/manual/zh/book.reflection.php&quot;&gt;php的反射机制&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;更新index.php代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# index.php
......
use Symfony\Component\HttpKernel\Controller\ControllerResolver; # add
use Symfony\Component\HttpKernel\Controller\ArgumentResolver; # add

......

$route = $matcher-&amp;gt;match($request-&amp;gt;getPathInfo());
$request-&amp;gt;attributes-&amp;gt;add($route); # add 将路由映射关系写入request对象的附加属性中。

$controller = (new ControllerResolver())-&amp;gt;getController($request); # add 处理控制器
$arguments = (new ArgumentResolver())-&amp;gt;getArguments($request, $controller); # add 处理方法的参数

$response = call_user_func_array($controller, $arguments);

$response-&amp;gt;send();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新DashboardController.php代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace App\Http\Controllers;

use Symfony\Component\HttpFoundation\Request; # add
use Symfony\Component\HttpFoundation\Response;# add

class DashboardController{

    public function index(Request $request) # # add
    {   
        $name = $request-&amp;gt;get('name', 'world'); # add

        return new Response('Hello '.$name); # add
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;用http-kernel好处就是可以处理各种问题，比如Request作为参数注入。&lt;/p&gt;
&lt;p&gt;访问 http://dev.phoenix.goods/dashboard?name=SexyPhoenix， 得到 Hello SexyPhoenix。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.symfonychina.com/doc/current/components/http_kernel.html&quot;&gt;http-kernel组件的使用说明&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h6 id=&quot;六分离模板v&quot;&gt;六、分离模板（V）&lt;/h6&gt;
&lt;p&gt;现在的框架只是简单的输出字符串，在正式环境中当然不可能这么简单，要能够返回正常的HTML页面。&lt;/p&gt;
&lt;p&gt;而复杂的HTML也不能放在控制器中处理，需要分离出来，单独处理。Symfony为框架同样提供了相关的组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer require symfony/templating&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.symfonychina.com/doc/current/components/templating.html&quot;&gt;Templating组件使用说明&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;处理框架的目录结构。&lt;/p&gt;
&lt;p&gt;在phoenix项目下，创建resources/views文件夹，继续在views下创建dashboard.php文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# dashboard.php
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;utf-8&quot;&amp;gt;
        &amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&amp;gt;
        &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&amp;gt;
        &amp;lt;title&amp;gt;Phoenix&amp;lt;/title&amp;gt;
        &amp;lt;style&amp;gt;
            html, body {
                color: #000;
                font-family: 'Raleway', sans-serif;
                font-weight: 100;
                height: 100vh;
                margin: 0;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div&amp;gt;
            &amp;lt;h2&amp;gt;Hello, &amp;lt;b&amp;gt;&amp;lt;?php echo $name?&amp;gt;&amp;lt;/b&amp;gt;&amp;lt;/h2&amp;gt;
            &amp;lt;h3&amp;gt;your mailbox：&amp;lt;?php echo $email?&amp;gt;&amp;lt;/h3&amp;gt;
            &amp;lt;h3&amp;gt;your github：&amp;lt;?php echo $github?&amp;gt;&amp;lt;/h3&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在app/Http/Controllers下创建Controller.php文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Controller.php

namespace App\Http\Controllers;

use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Templating\PhpEngine;
use Symfony\Component\Templating\TemplateNameParser;
use Symfony\Component\Templating\Loader\FilesystemLoader;

class Controller {

    /**
     * $templete 模板文件
     * $data 数据
     */
    public function render($templete, array $data)
    {
        return new Response(
            (new PhpEngine(
                new TemplateNameParser(), 
                new FilesystemLoader(getcwd().'/resources/views/%name%')
            ))
            -&amp;gt;render($templete, $data)
        );
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;改造DashboardController.php 代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace App\Http\Controllers;

use Symfony\Component\HttpFoundation\Request;

class DashboardController extends Controller{ # 继承Controller

    public function index(Request $request)
    {   
        $name = $request-&amp;gt;get('name', 'world');

        $data = [
            'name'   =&amp;gt; $name,
            'email'  =&amp;gt; 'sexyphoenix@163.com',
            'github' =&amp;gt; 'https://github.com/SexyPhoenix'
        ];

        return $this-&amp;gt;render('dashboard.php', $data);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问 http://dev.phoenix.goods/dashboard?name=SexyPhoenix， 页面正常显示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/423266/201912/423266-20191217110058798-361085110.png&quot; alt=&quot;9&quot;/&gt;&lt;/p&gt;
&lt;h6 id=&quot;七分离模型m&quot;&gt;七、分离模型（M）&lt;/h6&gt;
&lt;p&gt;分离完模板后，架构的数据还是在控制器中处理，同样要做分离。不过这一步，同学们可以根据自己的意愿来，比如你可以添加仓库层、服务层等。&lt;/p&gt;
&lt;p&gt;这里就做简单点，在app目录下，创建Models文件夹，继续创建User.php文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# User.php
namespace App\Models;

class User {
    
    protected $emails = [];

    protected $githubs = [];

    public function getEmailByName(string $name)
    {
        $this-&amp;gt;setEmails();

        return array_key_exists($name, $this-&amp;gt;emails) ? $this-&amp;gt;emails[$name] : ''; 
    }

    public function getGithubByName($name)
    {
        $this-&amp;gt;setGithubs();

        return array_key_exists($name, $this-&amp;gt;githubs) ? $this-&amp;gt;githubs[$name] : ''; 
    }

    public function setEmails()
    {
        $this-&amp;gt;emails = [
            'SexyPhoenix' =&amp;gt; 'sexyphoenix@163.com'
        ];
    }

    public function setGithubs()
    {
        $this-&amp;gt;githubs = [
            'SexyPhoenix' =&amp;gt; 'https://github.com/SexyPhoenix'
        ];
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新DashboardController.php。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# DashboardController.php
......
use App\Models\User #add 
......

public function index(Request $request)
{
    $name = $request-&amp;gt;get('name', 'world');

    $user = new User(); # add
    $data = [
        'name'   =&amp;gt; $name,
        'email'  =&amp;gt; $user-&amp;gt;getEmailByName($name),  # update
        'github' =&amp;gt; $user-&amp;gt;getGithubByName($name),# update
    ];

    return $this-&amp;gt;render('dashboard.php', $data);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问页面，正常显示。&lt;/p&gt;
&lt;h6 id=&quot;八剥离核心代码&quot;&gt;八、剥离核心代码&lt;/h6&gt;
&lt;p&gt;框架的基本架构已经搭建完成，但此时的核心代码都写在了index.php里面，另写项目的话，无法复用此架构，接下来剥离出核心代码。&lt;/p&gt;
&lt;p&gt;在phoenix项目下创建Core文件夹，继续创建Phoenix.php文件，移入核心代码并优化。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Phoenix.php

namespace Core; #注意此命名空间需要注册

use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Loader\YamlFileLoader;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\Matcher\UrlMatcher;
use Symfony\Component\HttpKernel\Controller\ControllerResolver;
use Symfony\Component\HttpKernel\Controller\ArgumentResolver;

class Phoenix {

    public $request;

    public $routeMap;

    public function handle(Request $request)
    {
        $this-&amp;gt;request = $request;

        try {

            //url map
            $this-&amp;gt;getRouteMap();

            $this-&amp;gt;setRequestRoute();

            $controller = (new ControllerResolver())-&amp;gt;getController($request);
            $arguments = (new ArgumentResolver())-&amp;gt;getArguments($request, $controller);

            return call_user_func_array($controller, $arguments);   

        } catch(\Exception $e) {

            return new Response('File Not Found', 404);
        }
    }

    public function setRequestRoute()
    {
        $this-&amp;gt;request-&amp;gt;attributes-&amp;gt;add($this-&amp;gt;routeMap-&amp;gt;match($this-&amp;gt;request-&amp;gt;getPathInfo()));
    }

    public function getRouteMap()
    {    
        $this-&amp;gt;routeMap = new UrlMatcher(
            $this-&amp;gt;getCollection(), 
            (new RequestContext())-&amp;gt;fromRequest($this-&amp;gt;request)
        );
    }

    public function getCollection()
    {
        return (
            new YamlFileLoader(
               new FileLocator(array(getcwd()))
            )
        )-&amp;gt;load('routes/web.yaml');
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新index.php代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ini_set('display_errors', 1);
error_reporting(-1);

require_once __DIR__.'/vendor/autoload.php';

$kernel = new Core\Phoenix();

$response = $kernel-&amp;gt;handle(
    Symfony\Component\HttpFoundation\Request::createFromGlobals()
);

$response-&amp;gt;send();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注册Core命名空间，打开composer.json文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# composer.json
&quot;autoload&quot;: {
    &quot;psr-4&quot;: {
        &quot;App\\&quot;: &quot;app/&quot;,
        &quot;Core\\&quot;: &quot;core/&quot;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;composer dump-autoload # 更新命名空间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;刷新页面，显示正常。&lt;/p&gt;
&lt;h6 id=&quot;九优化框架&quot;&gt;九、优化框架&lt;/h6&gt;
&lt;p&gt;在前面用到HttpKernel组件时，为什么介绍它是框架的内核呢？&lt;/p&gt;
&lt;p&gt;因为HttpKernel里面有个很重要的概念，&lt;strong&gt;派遣事件，给注册过的不同监听器监听&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;是用Mediator模式设计的，这种模式带来的好处，就是使框架的扩展性得到极大的提高。&lt;/p&gt;
&lt;p&gt;在请求到响应之前设计了八种钩子，方便后期扩展，详情看下面的链接。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/symfony/symfony/blob/3.1/src/Symfony/Component/HttpKernel/KernelEvents.php&quot;&gt;KernelEvents钩子介绍&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同时，也可以用另一种监听事件的方式，通过一个event subscriber（事件订阅器），向派遣器精确通报它要订阅哪些事件。下面对路由优化时，会用到这。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.symfonychina.com/doc/current/components/event_dispatcher.html&quot;&gt;EventDispatcher组件使用说明&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;HttpKernel组件的功能仅止于此吗？ 当然不，&lt;strong&gt;它里面有一个很重要的类“HttpKernel类”，将框架的核心Core/Phoenix.php的程序都实现了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;只要phoenix框架核心类Phoenix继承HttpKernel，并调用它的构造方法就行了。&lt;/p&gt;
&lt;p&gt;下面来改造Core/Phoenix.php代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# Phoenix.php
namespace Core;

use Symfony\Component\HttpFoundation\RequestStack; # add
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\Routing\Loader\YamlFileLoader;
use Symfony\Component\Config\FileLocator;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\Matcher\UrlMatcher;
use Symfony\Component\EventDispatcher\EventDispatcher; # add
use Symfony\Component\HttpKernel\HttpKernel; # add 
use Symfony\Component\HttpKernel\Controller\ControllerResolver;
use Symfony\Component\HttpKernel\Controller\ArgumentResolver;
use Symfony\Component\HttpKernel\EventListener\RouterListener;

class Phoenix extends HttpKernel{ # 继承HttpKernel

    public function __construct()
    {
        $matcher      = new UrlMatcher($this-&amp;gt;getCollection(), new RequestContext());
        $requestStack = new RequestStack();

        $dispatcher   = new EventDispatcher();
        $dispatcher-&amp;gt;addSubscriber(new RouterListener($matcher,  $requestStack)); # 订阅路由
        
        # HttpKernel的构造函数，可以点下面的链接进去看看
        parent::__construct(

            $dispatcher,
            new ControllerResolver(),
            $requestStack,
            new ArgumentResolver()
        );
    }

    public function getCollection()
    {
        return (
            new YamlFileLoader(
               new FileLocator(array(getcwd()))
            )
        )-&amp;gt;load('routes/web.yaml');
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/symfony/symfony/blob/3.1/src/Symfony/Component/HttpKernel/HttpKernel.php&quot;&gt;HttpKernel类&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;index.php的代码不用变，HttpKernel类里面也有handle方法。建议同学们看看HttpKernel类的源码。&lt;/p&gt;
&lt;h6 id=&quot;十依赖注入dependency-injection&quot;&gt;十、依赖注入（Dependency Injection）&lt;/h6&gt;
&lt;p&gt;Phoenix类继承了HttpKernel，是整个架构的核心，在框架里面定义了“路由监听”，但如果框架不仅仅要对路由进行监听，还要对response阶段进行监听呢？是不是继续修改Phoenix类呢？&lt;/p&gt;
&lt;p&gt;这样的设计对于框架来说，是绝对不友好的。那有没有方法解决呢？&lt;/p&gt;
&lt;p&gt;当然有，可以通过在外面注入对象，框架通过type检测，自动引入相关对象。&lt;/p&gt;
&lt;p&gt;首先下载Symfony的DependencyInjection组件。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;composer require symfony/dependency-injection&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在core文件夹下创建container.php文件&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# container.php
namespace Core;

use Symfony\Component\DependencyInjection;
use Symfony\Component\DependencyInjection\Reference;
use Symfony\Component\DependencyInjection\ContainerBuilder;
use Symfony\Component\Routing\Loader\YamlFileLoader;
use Symfony\Component\Config\FileLocator;

$app = new ContainerBuilder();
$app-&amp;gt;register('context', 'Symfony\Component\Routing\RequestContext');
$app-&amp;gt;register('matcher', 'Symfony\Component\Routing\Matcher\UrlMatcher')
    -&amp;gt;setArguments(array(getCollection(), new Reference('context')));

$app-&amp;gt;register('request_stack', 'Symfony\Component\HttpFoundation\RequestStack');
$app-&amp;gt;register('controller_resolver', 'Symfony\Component\HttpKernel\Controller\ControllerResolver');
$app-&amp;gt;register('argument_resolver', 'Symfony\Component\HttpKernel\Controller\ArgumentResolver');
    
$app-&amp;gt;register('listener.router', 'Symfony\Component\HttpKernel\EventListener\RouterListener') # 路由监听
    -&amp;gt;setArguments(array(new Reference('matcher'), new Reference('request_stack')));

$app-&amp;gt;register('dispatcher', 'Symfony\Component\EventDispatcher\EventDispatcher')
    -&amp;gt;addMethodCall('addSubscriber', array(new Reference('listener.router')));            

$app-&amp;gt;register('phoenix', 'Core\Phoenix')
-&amp;gt;setArguments(array(
    new Reference('dispatcher'),
    new Reference('controller_resolver'),
    new Reference('request_stack'),
    new Reference('argument_resolver'),
));


return $app;

function getCollection()
{
    return (
        new YamlFileLoader(
           new FileLocator(array(getcwd()))
        )
    )-&amp;gt;load('routes/web.yaml');
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;别名和对象一一对应，后面可以通过别名获取对象。&lt;/p&gt;
&lt;p&gt;去掉core/phoenix.php里面的代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;namespace Core;

use Symfony\Component\HttpKernel\HttpKernel;

class Phoenix extends HttpKernel{

    // public function __construct()
    // {
    //     $matcher      = new UrlMatcher($this-&amp;gt;getCollection(), new RequestContext());
    //     $requestStack = new RequestStack();

    //     $dispatcher   = new EventDispatcher();
    //     $dispatcher-&amp;gt;addSubscriber(new RouterListener($matcher,  $requestStack));

    //     parent::__construct(

    //         $dispatcher,
    //         new ControllerResolver(),
    //         $requestStack,
    //         new ArgumentResolver()
    //     );
    // }

    // public function getCollection()
    // {
    //     return (
    //         new YamlFileLoader(
    //            new FileLocator(array(getcwd()))
    //         )
    //     )-&amp;gt;load('routes/web.yaml');
    // }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;更新index.php代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;ini_set('display_errors', 1);
error_reporting(-1);

require_once __DIR__.'/vendor/autoload.php';

$app = require_once __DIR__.'/core/container.php'; # add 

$response = $app-&amp;gt;get('phoenix') # 通过别名获取
    -&amp;gt;handle(
        Symfony\Component\HttpFoundation\Request::createFromGlobals()
    );

$response-&amp;gt;send();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;访问 http://dev.phoenix.goods/dashboard?name=SexyPhoenix， 显示正常。&lt;/p&gt;
&lt;p&gt;到这里，框架的整个基本设计就结束了，之后需要什么功能，就可以自己用composer安装组件了,composer还是很好用的。&lt;/p&gt;
&lt;p&gt;同学们如果有什么疑问的，欢迎在评论区一起交流，ヾ(●´∀｀●) 。&lt;/p&gt;
&lt;p&gt;最后，附一份最终代码 &lt;a href=&quot;https://github.com/SexyPhoenix/phoenix&quot;&gt;phoenix web 架构&lt;/a&gt;。&lt;/p&gt;
&lt;blockquote readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://www.symfonychina.com/doc/current/create_framework/index.html&quot;&gt;参考Symfony官网 - 创建你自己的框架&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Tue, 17 Dec 2019 23:44:00 +0000</pubDate>
<dc:creator>SexyPhoenix</dc:creator>
<og:description>背景 一次无意的访问，点击到了一个专门做PHP性能测试的网站，看这里 'PHP Benchmarks' 。 在里面发现了框架性能测试的结果，发现Laravel的框架性能尽然是最低的。瞬间受到了一万点的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/SexyPhoenix/p/12035309.html</dc:identifier>
</item>
<item>
<title>PHP 7.4.0发布！一起看看有哪些新特性 - 有痣青年</title>
<link>http://www.cnblogs.com/zydj333/p/12057854.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zydj333/p/12057854.html</guid>
<description>&lt;p&gt;PHP 7.4.0 发布了，此版本标志着 PHP 7 系列的第四次特性更新。&lt;/p&gt;
&lt;p&gt;看了英文手册后，发现其进行了许多改进，并带来了一些新特性，现在将这些新特性您：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1.&lt;span&gt;Typed Properties&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; 类型属性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类属性现在支持类型声明，以下示例将强制 $User-&amp;gt; id 只能分配 int 值，而 $User-&amp;gt; name 只能分配 string 值。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; User {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; int &lt;span&gt;$id&lt;/span&gt;&lt;span&gt;;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; &lt;span&gt;$name&lt;/span&gt;&lt;span&gt;;

}

&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;● 它们自PHP 7.4起可用。&lt;/p&gt;
&lt;p&gt;● 它们只在类中可用，并且需要访问修饰符:public、protected、private、var。&lt;/p&gt;
&lt;p&gt;● 除了void和callable之外，所有类型都是允许的。&lt;/p&gt;
&lt;p&gt;PHP是我们喜欢和讨厌的一种动态语言，它将强制类型转换做的太好，有时也会引起反作用。假设您在期望整数的地方传递了一个字符串，PHP将尝试自动转换该字符串：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Bar

{

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; int &lt;span&gt;$i&lt;/span&gt;&lt;span&gt;;

}

&lt;/span&gt;&lt;span&gt;$bar&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar;

&lt;/span&gt;&lt;span&gt;$bar&lt;/span&gt;-&amp;gt;i = '1'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果不喜欢这种行为，可以通过声明严格类型来禁用它：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;declare&lt;/span&gt;(strict_types=1&lt;span&gt;);&lt;/span&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt;$bar&lt;/span&gt; = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Bar;

&lt;/span&gt;&lt;span&gt;$bar&lt;/span&gt;-&amp;gt;i = '1'; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1&lt;/span&gt;
&lt;span&gt;
Fatal error&lt;/span&gt;: Uncaught TypeError:&lt;span&gt; 

Typed property Bar&lt;/span&gt;::&lt;span&gt;$i&lt;/span&gt; must be int, &lt;span&gt;string&lt;/span&gt; used&lt;/em&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;2.&lt;span&gt;Arrow Functions&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; 箭头函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;箭头函数提供了用于定义具有隐式按值作用域绑定的函数的简写语法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;$factor&lt;/span&gt; = 10&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;$nums&lt;/span&gt; = &lt;span&gt;array_map&lt;/span&gt;(fn(&lt;span&gt;$n&lt;/span&gt;) =&amp;gt; &lt;span&gt;$n&lt;/span&gt; * &lt;span&gt;$factor&lt;/span&gt;, [1, 2, 3, 4&lt;span&gt;]);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; $nums = array(10, 20, 30, 40);&lt;/span&gt;

?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;● 自PHP 7.4起可用&lt;/p&gt;
&lt;p&gt;● 他们以fn关键字开头&lt;/p&gt;
&lt;p&gt;● 它们只能有一个表达式，即return语句&lt;/p&gt;
&lt;p&gt;● 不允许return关键字&lt;/p&gt;
&lt;p&gt;● 参数和返回类型可以是类型提示&lt;/p&gt;
&lt;p&gt;您没看错：短闭包只能有一个表达式。这意味着您不能包含多行。&lt;/p&gt;
&lt;p&gt;理由如下：&lt;/p&gt;
&lt;p&gt;简短闭包的目标是减少冗长。fn当然在所有情况下都比function短。然而，如果您处理的是多行函数，那么使用短闭包所获得的好处就更少。&lt;/p&gt;
&lt;p&gt;毕竟，按照定义，多行闭包已经更加冗长；因此能够跳过两个关键字（function和return）不会有太大的区别。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3.&lt;span&gt;Limited Return Type Covariance and Argument Type Contravariance&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; 有限返回类型协变与参数类型逆变&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;仅当使用自动加载时，才提供完全协变/逆变支持。在单个文件中，只能使用非循环类型引用，因为所有类在被引用之前都必须可用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; A {}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; B &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; A {}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Producer {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; method():&lt;span&gt; A {}

}

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; ChildProducer &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Producer {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; method():&lt;span&gt; B {}

}

&lt;/span&gt;?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;4.&lt;span&gt;Unpacking Inside Arrays&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; 打包内部数组&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;&lt;span&gt;$parts&lt;/span&gt; = ['apple', 'pear'&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;$fruits&lt;/span&gt; = ['banana', 'orange', ...&lt;span&gt;$parts&lt;/span&gt;, 'watermelon'&lt;span&gt;];

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ['banana', 'orange', 'apple', 'pear', 'watermelon'];&lt;/span&gt;

?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;5.&lt;span&gt;Numeric Literal Separator&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; 数值文字分隔符&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;数字文字可以在数字之间包含下划线。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;?&lt;span&gt;php

&lt;/span&gt;6.674_083e-11; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; float&lt;/span&gt;
&lt;span&gt;
299_792_458;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; decimal&lt;/span&gt;
&lt;span&gt;
0xCAFE_F00D;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; hexadecimal&lt;/span&gt;
&lt;span&gt;
0b0101_1111;   &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; binary&lt;/span&gt;

?&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;限制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;唯一的限制是数字文字中的每个下划线必须直接位于两个数字之间。这条规则意味着下面的用法都不是有效的数字文字:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
_100; 
&lt;span&gt;
100_;       &lt;/span&gt;
&lt;span&gt;
1__1;       &lt;/span&gt;
&lt;span&gt;
1_&lt;/span&gt;.0; 1._0; 
&lt;span&gt;
0x_123;     &lt;/span&gt;
&lt;span&gt;
0b_101;     &lt;/span&gt;
&lt;span&gt;
1_e2; 1e_2; &lt;/span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;PHP功能不受影响&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在数字文字的数字之间添加下划线不会改变其值。下划线在词法分析阶段被删除，因此运行时不受影响。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var_dump&lt;/span&gt;(1_000_000); &lt;span&gt;//&lt;/span&gt;&lt;span&gt; int(1000000)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;6.&lt;span&gt;Weak References&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; 弱引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;弱引用可以保留对对象的引用，不会阻止对象被销毁。&lt;/p&gt;
&lt;p&gt;弱引用允许保留对对象的引用，而该对象不会阻止对象被销毁;它们对于实现类似缓存的结构非常有用。&lt;/p&gt;
&lt;p&gt;原则上，弱引用对象并不复杂，只需要(ab)使用Zend或下面的层，因为我们不直接支持它。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WeakReference {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; create(&lt;span&gt;object&lt;/span&gt; &lt;span&gt;$object&lt;/span&gt;) :&lt;span&gt; WeakReference;
  
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; get() : ?&lt;span&gt;object&lt;/span&gt;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;7.&lt;span&gt;Allow Exceptions from __toString()&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; 允许从 __toString() 抛出异常&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在允许从 __toString() 引发异常，以往这会导致致命错误，字符串转换中现有的可恢复致命错误已转换为 Error 异常。&lt;/p&gt;
&lt;p&gt;7.4以前禁止从__toString()抛出异常，如果__toString()异常，将导致致命错误。&lt;/p&gt;
&lt;p&gt;从技术角度来看，这种限制最终是无效的，因为字符串转换期间的异常仍然可以由将可恢复错误转换为异常的错误处理程序触发:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;set_error_handler&lt;/span&gt;(&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {

    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;Exception&lt;/span&gt;&lt;span&gt;();

});

&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {

    (&lt;/span&gt;&lt;span&gt;string&lt;/span&gt;) &lt;span&gt;new&lt;/span&gt;&lt;span&gt; stdClass;

} &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt; (&lt;span&gt;Exception&lt;/span&gt; &lt;span&gt;$e&lt;/span&gt;&lt;span&gt;) {

    &lt;/span&gt;&lt;span&gt;echo&lt;/span&gt; &quot;(string) threw an exception...\n&quot;&lt;span&gt;;

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，将“不能转换为字符串”和“__toString()必须返回一个字符串值”可恢复的致命错误转换为正确的错误异常，这与PHP 7中建立的错误策略一致。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8.&lt;span&gt;Opcache Preloading&lt;/span&gt;&lt;/strong&gt;&lt;strong&gt; Opcache 预加载&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新增 Opcache 预加载支持。&lt;/p&gt;
&lt;p&gt;在PHP 7.4中，添加了对预加载的支持，这是一个可以显著提高代码性能的特性。&lt;/p&gt;
&lt;p&gt;简而言之，这是它的工作方式：&lt;/p&gt;
&lt;p&gt;● 为了预加载文件，您需要编写一个自定义PHP脚本&lt;/p&gt;
&lt;p&gt;● 该脚本在服务器启动时执行一次&lt;/p&gt;
&lt;p&gt;● 所有预加载的文件在内存中都可用于所有请求&lt;/p&gt;
&lt;p&gt;● 在重新启动服务器之前，对预加载文件所做的更改不会产生任何影响&lt;/p&gt;
&lt;p&gt;虽然预加载是建立在opcache之上的，但它并不是完全一样的。Opcache将获取您的PHP源文件，将其编译为“ opcodes”，然后将这些编译后的文件&lt;strong&gt;&lt;span&gt;存储在磁盘上&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;您可以将操作码看作是代码的底层表示，在运行时很容易解释。因此，opcache会跳过源文件和PHP解释器在运行时实际需要之间的转换步骤。巨大的胜利！&lt;/p&gt;
&lt;p&gt;但我们还有更多的收获。Opcached文件不知道其他文件。如果类A是从类B扩展而来的，那么仍然需要在运行时将它们链接在一起。此外，opcache执行检查以查看源文件是否被修改，并将基于此使其缓存失效。&lt;/p&gt;
&lt;p&gt;因此，这就是预加载发挥作用的地方：它不仅将源文件编译为操作码，而且还将相关的类、特征和接口链接在一起。然后，它将这个“已编译”的可运行代码blob(即:PHP解释器可以使用的代码)&lt;strong&gt;&lt;span&gt;保存在内存中&lt;/span&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在，当请求到达服务器时，它可以使用已经加载到内存中的部分代码库，而不会产生任何开销。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;为了进行预加载，开发人员必须告知服务器要加载哪些文件。这是用一个简单的PHP脚本完成的，确实没有什么困难。&lt;/p&gt;
&lt;p&gt;规则很简单：&lt;/p&gt;
&lt;p&gt;● 您提供一个预加载脚本，并使用opcache.preload命令将其链接到您的php.ini文件中。&lt;/p&gt;
&lt;p&gt;● 您要预加载的每个PHP文件都应该传递到opcache_compile_file()，或者在预加载脚本中只需要一次。&lt;/p&gt;
&lt;p&gt;假设您想要预加载一个框架，例如Laravel。您的脚本必须遍历vendor/laravel目录中的所有PHP文件，并将它们一个接一个地添加。&lt;/p&gt;
&lt;p&gt;在php.ini中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
opcache.preload=/path/to/project/preload.php
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是一个虚拟的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$files&lt;/span&gt; = &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 要预加载的文件数组 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$files&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$file&lt;/span&gt;&lt;span&gt;) {

    opcache_compile_file(&lt;/span&gt;&lt;span&gt;$file&lt;/span&gt;&lt;span&gt;);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;有一个警告！为了预加载文件，还&lt;span&gt;&lt;strong&gt;必须预加载它们的依赖项（接口，特征和父类）&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;如果类依赖项有任何问题，则会在服务器启动时通知您：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Can'&lt;span&gt;t preload unlinked class

Illuminate\Database\Query\JoinClause: 

Unknown parent 

Illuminate\Database\Query\Builder&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这不是一个致命的问题，您的服务器可以正常工作。但你不会得到所有你想要的预加载文件。&lt;/p&gt;
&lt;p&gt;幸运的是，还有一种确保链接文件也被加载的方法：您可以使用require_once代替opcache_compile_file，让已注册的autoloader(可能是composer的)负责其余的工作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;$files&lt;/span&gt; = &lt;span&gt;/*&lt;/span&gt;&lt;span&gt; 要预加载的文件数组 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;foreach&lt;/span&gt; (&lt;span&gt;$files&lt;/span&gt; &lt;span&gt;as&lt;/span&gt; &lt;span&gt;$file&lt;/span&gt;&lt;span&gt;) {

    &lt;/span&gt;&lt;span&gt;require_once&lt;/span&gt;(&lt;span&gt;$file&lt;/span&gt;&lt;span&gt;);

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一些需要注意的地方。例如，如果您试图预加载Laravel，那么框架中的一些类依赖于其他尚不存在的类。例如，文件系统缓存类\ lighting \ filesystem \ cache依赖于\League\Flysystem\Cached\Storage\AbstractCache，如果您从未使用过文件系统缓存，则可能无法将其安装到您的项目中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;＃有效吗？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这当然是最重要的问题:所有文件都正确加载了吗?您可以简单地通过重新启动服务器来测试它，然后将&lt;span&gt;opcache_get_status()&lt;/span&gt;的输出转储到PHP脚本中。您将看到它有一个名为preload_statistics的键，它将列出所有预加载的函数、类和脚本;以及预加载文件消耗的内存。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;＃性能&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在到最重要的问题：预加载真的能提高性能吗?&lt;/p&gt;
&lt;p&gt;答案是肯定的：我进行了一些基准测试。&lt;/p&gt;
&lt;p&gt;有趣的是，您可以决定仅预加载代码库中经常使用的类。基准测试显示，只加载大约100个热门类，实际上可以获得比预加载所有类更好的性能收益。预加载全部类，性能提升13%，而预加载热门类，则提升有17%。&lt;/p&gt;
&lt;p&gt;当然，应该预加载哪些类取决于您的项目。明智的做法是在开始时尽可能多地预加载。&lt;/p&gt;
&lt;p&gt;此外还有一些弃用，以及从核心中删除一些扩展，详情查看英文原版手册：&lt;/p&gt;
&lt;p&gt;https://www.php.net/manual/zh/migration74.new-features.php&lt;/p&gt;
</description>
<pubDate>Tue, 17 Dec 2019 19:49:00 +0000</pubDate>
<dc:creator>有痣青年</dc:creator>
<og:description>PHP 7.4.0 发布了，此版本标志着 PHP 7 系列的第四次特性更新。 看了英文手册后，发现其进行了许多改进，并带来了一些新特性，现在将这些新特性您： 1.Typed Properties&amp;#1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zydj333/p/12057854.html</dc:identifier>
</item>
<item>
<title>使用@babel/preset-typescript取代awesome-typescript-loader和ts-loader - 韩子卢</title>
<link>http://www.cnblogs.com/vvjiang/p/12057811.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/vvjiang/p/12057811.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前写过一篇旧React项目安装并使用TypeScript的文章：&lt;a href=&quot;https://www.cnblogs.com/vvjiang/p/11944912.html&quot;&gt;在React旧项目中安装并使用TypeScript的实践&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;博客里使用awesome-typescript-loader对Typescript代码进行检测和转换。&lt;/p&gt;
&lt;p&gt;而这几天又修改了一下自己的脚手架，使用@babel/preset-typescript来处理Typescript。&lt;/p&gt;
&lt;h2 id=&quot;回顾awesome-typescript-loader方案&quot;&gt;回顾awesome-typescript-loader方案&lt;/h2&gt;
&lt;p&gt;谈@babel/preset-typescript的优越性之前，还是先说下awesome-typescript-loader方案是如何对TypeScript进行处理的。&lt;/p&gt;
&lt;p&gt;首先我们需要知道TypeScript是一个将TypeScript转换为指定版本JS代码的编译器，而Babel同样是一个将新版本JS新语法转换为低版本JS代码的编译器。&lt;/p&gt;
&lt;p&gt;所以我们之前的方案每次修改了一点代码，都会将TS代码传递给TypeScript转换为JS，然后再将这份JS代码传递给Babel转换为低版本JS代码。&lt;/p&gt;
&lt;p&gt;因此我们需要配置两个编译器，并且每次做了一点更改，都会经过两次编译。&lt;/p&gt;
&lt;h2 id=&quot;babelpreset-typescript方案&quot;&gt;@babel/preset-typescript方案&lt;/h2&gt;
&lt;p&gt;介绍这个方案之前，我需要列出我参考的一篇译文：&lt;a href=&quot;https://juejin.im/post/5c822e426fb9a04a0a5ffb49&quot;&gt;[译] TypeScript 和 Babel：一场美丽的婚姻&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;这里提到这是 TypeScript 和 Babel 团队长达一年的官方合作成果，所以至少我们不用担心这是个野生方案会烂尾。&lt;/p&gt;
&lt;p&gt;核心提炼一下：@babel/preset-typescript和@babel/preset-react类似，是将特殊的语法转换为JS。&lt;/p&gt;
&lt;p&gt;但是有点区别的是，@babel/preset-typescript是直接移除TypeScript，转为JS，这使得它的编译速度飞快。&lt;/p&gt;
&lt;p&gt;并且只需要管理Babel一个编译器就行了，因为我将脚手架中的typescript库卸载后，依然可以完美运行。&lt;/p&gt;
&lt;p&gt;而且重要的是你写的TypeScript不会再进行类型检测，使得你改动代码后中断运行的页面。&lt;/p&gt;
&lt;h2 id=&quot;所以检测呢&quot;&gt;所以，检测呢？&lt;/h2&gt;
&lt;p&gt;我写TypeScript就是用来搞类型检测的啊，你安装了TypeScript，写了TS代码然后再用@babel/preset-typescript移除不是多此一举吗？&lt;/p&gt;
&lt;p&gt;不，并不是多此一举。&lt;/p&gt;
&lt;p&gt;还记得前面那篇译文吗？&lt;/p&gt;
&lt;p&gt;它的方案是使用ESLint，用@typescript-eslint配置ESLint来达到检测的目的。&lt;/p&gt;
&lt;p&gt;而我们的方案呢？&lt;/p&gt;
&lt;p&gt;我们是高贵的VSCode玩家，咱们自带TS检测，所以这一步咱们可以略过。&lt;/p&gt;
&lt;h2 id=&quot;一些缺陷&quot;&gt;一些缺陷&lt;/h2&gt;
&lt;p&gt;上方译文中提到了此方案的以下四个缺陷：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Namespace语法不推荐，改用标准的 ES6 module（import/export）。&lt;/li&gt;
&lt;li&gt;不支持x 语法转换类型，改用x as newtype。&lt;/li&gt;
&lt;li&gt;const 枚举&lt;/li&gt;
&lt;li&gt;历史遗留风格的 import/export 语法。比如：import foo = require(...) 和 export = foo。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;第1条和第4条不用，而且已经过时了。&lt;br/&gt;第2条缺陷改一下语法就好了，这个语法会直接提示语法报错，很好改，问题不大。&lt;br/&gt;第3条缺陷已经没有了，亲测可用。&lt;/p&gt;
&lt;h2 id=&quot;替换步骤&quot;&gt;替换步骤&lt;/h2&gt;
&lt;p&gt;要使用@babel/preset-typescript，务必确保你是Babel7+。&lt;/p&gt;
&lt;p&gt;如果不是Babel7+用户，可以运行考虑运行下面的两条命令升级：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm install babel-upgrade -g

babel-upgrade --write&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后我们安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;npm i --save @babel/preset-typescript&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后将之前在webpack中配置解析tsx的部分去掉，改为：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module: {
  rules: [
    //...
    {
      test: /\.tsx?$/,
      exclude: /node_modules/,
      loader: 'babel-loader',
      options: {
        presets: [
          '@babel/preset-env',
          '@babel/preset-react',
          '@babel/preset-typescript'
        ]
      }
    }
    //...
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ant-design的按需加载&quot;&gt;Ant Design的按需加载&lt;/h2&gt;
&lt;p&gt;必须要把这个东西单独拎出来说，太坑了。&lt;/p&gt;
&lt;p&gt;之前的方案咱们使用的是ts-import-plugin来处理的。&lt;/p&gt;
&lt;p&gt;所以下意识我觉得这个地方会很麻烦，网上搜各种方案。&lt;/p&gt;
&lt;p&gt;然而必然是没有答案的，要么就是ts-import-plugin，要么就是和create-react-app结合在一起的那种。&lt;/p&gt;
&lt;p&gt;实际上咱们只需要升级一下babel-plugin-import到最新就可以了。&lt;/p&gt;
&lt;p&gt;我之前就是因为babel-plugin-import版本太低，导致只对js文件有效，对ts文件无效。&lt;/p&gt;
&lt;p&gt;然后配置一下babel-plugin-import即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;module: {
  rules: [
    //...
    {
      test: /\.tsx?$/,
      exclude: /node_modules/,
      loader: 'babel-loader',
      options: {
        presets: [
          '@babel/preset-env',
          '@babel/preset-react',
          '@babel/preset-typescript'
        ],
        plugins: [
          ['import', { libraryName: 'antd', style: 'css' }], // `style: true` 会加载 less 文件
        ],
      }
    }
    //...
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这次升级花的最多时间就在ant-design的按需加载上，其它的东西其实都很好配置，无非是知识点零散些罢了。&lt;/p&gt;
&lt;p&gt;说实话很感谢那篇译文，但是读起来还是觉得有点生硬。&lt;/p&gt;
&lt;p&gt;所以另外一个花时间的点，就是如何有条理地把为什么升级阐述清楚。&lt;/p&gt;
&lt;p&gt;这里再附上参考项目：&lt;a href=&quot;https://github.com/vvjiang/webpack4Hanzilu&quot;&gt;脚手架项目&lt;/a&gt;。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Dec 2019 17:44:00 +0000</pubDate>
<dc:creator>韩子卢</dc:creator>
<og:description>前言 之前写过一篇旧React项目安装并使用TypeScript的文章： '在React旧项目中安装并使用TypeScript的实践' 。 博客里使用awesome typescript loader</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/vvjiang/p/12057811.html</dc:identifier>
</item>
<item>
<title>首创诠释docker的Formulas: Windows 7 + Tiny Linux 4.19 + XFS + Vmware Workstation = super machine (docker从零开始时记，Follow me and you go) - A.Z</title>
<link>http://www.cnblogs.com/A-Z/p/docker_4-19_win7_vmware.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/A-Z/p/docker_4-19_win7_vmware.html</guid>
<description>&lt;p&gt;&lt;span&gt; 不少人从来没有接触过docker,或者仅仅是听说过,本文试图从原点开始深入了解docker的全貌,剖析docker的基础概念,让我们一起开始docker之旅~~~&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h3&gt;&lt;span&gt;开场：什么是docker&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;docker是一个容器平台。&lt;/p&gt;
&lt;p&gt;这是我最直接的定义,打字间我即兴查了一下wiki,引证了以上单句&lt;/p&gt;
&lt;blockquote readability=&quot;7.7318181818182&quot;&gt;
&lt;p&gt;&lt;strong&gt;Docker&lt;/strong&gt; is a set of platform as a service (PaaS) products that use &lt;a title=&quot;OS-level virtualization&quot; href=&quot;https://en.wikipedia.org/wiki/OS-level_virtualization&quot;&gt;OS-level virtualization&lt;/a&gt; to deliver software in packages called containers. Containers are isolated from one another and bundle their own software, libraries and configuration files; they can communicate with each other through well-defined channels. All containers are run by a single &lt;a title=&quot;Kernel (operating system)&quot; href=&quot;https://en.wikipedia.org/wiki/Kernel_(operating_system)&quot;&gt;operating-system kernel&lt;/a&gt; and are thus more lightweight than &lt;a title=&quot;Virtual machine&quot; href=&quot;https://en.wikipedia.org/wiki/Virtual_machine&quot;&gt;virtual machines&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt; &lt;span&gt;目标：为什么用docker&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;docker可以提供即开即用的特定OS环境,并且简化对相关OS的依赖或者部署周期&lt;/p&gt;
&lt;p&gt;这是我的看法,互联网工作者几乎99.9%都是以App或者Service作为导向,而实际使用中docker不仅仅是为了快速部署,容灾热备,换句话说docker不仅仅是和应用相关&lt;/p&gt;
&lt;p&gt;docker适合一切以环境导向的联合部署作业(TASK-oriented)&lt;/p&gt;
&lt;p&gt;例子：一个简单的网络型app和这个app依赖的复杂网络设置&lt;/p&gt;
&lt;p&gt;例子：一个简单的用户态服务和一个复杂的定制化LINUX OS,如OPENWRT&lt;/p&gt;
&lt;p&gt;例子：一个简单的源码文件夹和一个复杂的跨架构工具链&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;概念：docker的逻辑结构&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;docker是vm的包装,docker-machine是docker开始的地方,这里存在并且一直被忽视一个非常关键的适配桥接：driver&lt;/p&gt;
&lt;p&gt;machine的特性start/stop和driver的模型决定了另一端一定存在一种虚拟化支持,也就是说docker不是虚拟化的全部而只是一个名词的概要,docker离不开虚拟化&lt;/p&gt;
&lt;p&gt;理由非常简单而且明确：docker-machine和dock-cli到组成的engine,编译88%以上的&lt;span&gt;源码语言go&lt;/span&gt;.&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;体验：从WINDOWS 10到WINDOWS 7不同的docker产品，一样的基础构成&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;-跟随docker for windows一路走来,docker以非常匀速的方式在不停演化,一切都在意料之中&lt;/p&gt;
&lt;p&gt;Docker Desktop for Windows是伴随着Hyper-V(win 7无缘的本质)的联合体,这里诞生出一个moby,作为整个产品的特异化核心&lt;/p&gt;
&lt;p&gt;Docker Desktop for Mac是伴随着linuxkit+qemu的联合体,这里又又诞生出一个moby,作为整个产品的特异化核心&lt;/p&gt;
&lt;p&gt;Docker Toolbox是伴随着Docker Desktop发展的弃婴(巨大的甲骨婴),本文,我们（我和我的看官们）将抛弃一个时代失败品Oracle VM VirtualBox,抽丝剥茧boot2docker,迎来本篇的内涵Vmware&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;深化：在Window 7上非常规的使用Vmware Workstation和docker&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如果你仅仅猜到了开始,看到我blah-blah-blah码了几百字就应该会猜到,hehe以下都是精华浓缩版,因为困了,要睡觉了&lt;/p&gt;
&lt;p&gt;长话短说,短话精缩,Win 7上使用workstation太通常了,稍微有一些虚拟化经验的都知道微软有Virtual PC.而它的对面就是Vmware.&lt;/p&gt;
&lt;p&gt;显然Virtual PC挑不动docker这根大梁所以Hyper-V才能独树一帜(没有细分的产品)&lt;/p&gt;
&lt;p&gt;准备好docker vmware driver就开始吧,我用的是大家不太常见的driver,没有任何start说明&lt;/p&gt;
&lt;p&gt;我的docker和vmware都没有安装在缺省路径,这时必须要动动脑筋,soft/hard link可以解决问题&lt;/p&gt;
&lt;p&gt;我的超高T级HGST氦气盘没有在缺省路径,所以我们准备把VM放在这个仓储上必须提供storepath的环境变量,我在go文件中确认过cli上下文，或者系统级别都提供支持&lt;/p&gt;
&lt;p&gt;我的docker动辄几百G,从export容器的从容不迫到更新image:latest,tar到文件,4.14kernel必然的某些特定错误,不难看出4.19的适用面更广也支持度也高于通俗的4.14kernel&lt;/p&gt;
&lt;p&gt;XFS提供了很好的并行IO性能&lt;/p&gt;
&lt;p&gt;关键语句是修改start.sh执行${DOCKER_MACHINE}&quot; create -d vmware --vmware-boot2docker-url=&quot;file://\????????.iso&quot;,此处应有掌声,因为经历了几次失败后我发现失败的路径是docker的安装盘，所以可以逃避失败删除boot2docker-url在覆盖cache后等一段时间,或者如上所示干脆把盘符省去,后面的路径都是有效的,不知道是不是start.bat没有问题&lt;/p&gt;
&lt;p&gt;当然可以看一下创建时的调试输出,一般不看也是一件很省心的事情,应该一切顺利&lt;/p&gt;
&lt;p&gt;env可以输出环境变量,cmd/ps可以看到SET版本,bash看到export版本&lt;/p&gt;
&lt;p&gt;然后在困意中,我贴出本文最佳,之2幅图片在结尾,一如既往,&lt;span&gt;所有的内涵都在图片里，&lt;span&gt;所有的内涵都在图片里，&lt;span&gt;所有的内涵都在图片里&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;提前 To be continued.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;(睡了还爬起来补充,忘了的内容,非常重要,不嵌在上面了,最近Docker Desktop for Windows提供了WSL的支持,请遵循我的最佳实践不用的时候关闭，关闭后台)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;hr/&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/A-Z/117549/o_docker%20info%204.19.PNG&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;NaN&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/A-Z/117549/o_docker%20version.PNG&quot; alt=&quot;&quot; width=&quot;620&quot; height=&quot;NaN&quot;/&gt;&lt;/p&gt;

&lt;hr/&gt;
</description>
<pubDate>Tue, 17 Dec 2019 16:29:00 +0000</pubDate>
<dc:creator>A.Z</dc:creator>
<og:description>这一篇负基础看完就能学会的博文，不论是想学习新知识还是感受博主的欧气，请点推荐或支持</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/A-Z/p/docker_4-19_win7_vmware.html</dc:identifier>
</item>
<item>
<title>SpringAOP在web应用中的使用 - 小鱼吃猫</title>
<link>http://www.cnblogs.com/Lyn4ever/p/12057672.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Lyn4ever/p/12057672.html</guid>
<description>&lt;p&gt;之前的aop是通过手动创建代理类来进行通知的，但是在日常开发中，我们并不愿意在代码中硬编码这些代理类，我们更愿意使用DI和IOC来管理aop代理类。Spring为我们提供了以下方式来使用aop框架&lt;/p&gt;
&lt;h2 id=&quot;一以声明的方式配置aop就是使用xml配置文件&quot;&gt;一、以声明的方式配置AOP（就是使用xml配置文件）&lt;/h2&gt;
&lt;h3 id=&quot;使用proxyfactorybean的方式&quot;&gt;1.使用ProxyFactoryBean的方式：&lt;/h3&gt;
&lt;p&gt;ProxyFactoryBean类是FactoryBean的一个实现类，它允许指定一个bean作为目标，并且为该bean提供一组通知和顾问（这些通知和顾问最终会被合并到一个AOP代理中）它和我们之前的ProxyFactory都是Advised的实现。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;以下是一个简单的例子：一个学生和一个老师，老师会告诉学生应该做什么。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Student {

    public void talk() {
        System.out.println(&quot;I am a boy&quot;);
    }

    public void walk() {
        System.out.println(&quot;I am walking&quot;);
    }

    public void sleep() {
        System.out.println(&quot;I want to sleep&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;老师类&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Teacher {

    private Student student;

    public void tellStudent(){
        student.sleep();
        student.talk();
    }

    public Student getStudent() {
        return student;
    }

    public void setStudent(Student student) {
        this.student = student;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.lyn4ever.aop;

import org.aspectj.lang.JoinPoint;

public class AuditAdvice implements MethodBeforeAdvice {
    @Override
    public void before(Method method, Object[] objects, @Nullable Object o) throws Throwable {
        System.out.println(&quot;这个方法被通知了&quot; + method.getName());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;然后就使用spring的IOC来管理这个通知类,在xml配置文件中声明如下：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/util
       https://www.springframework.org/schema/util/spring-util.xsd&quot;&amp;gt;

    &amp;lt;!--注入student--&amp;gt;
    &amp;lt;bean name=&quot;student&quot; class=&quot;cn.lyn4ever.aop.aopconfig.Student&quot;&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--注入teacher--&amp;gt;
    &amp;lt;bean name=&quot;teacher&quot; class=&quot;cn.lyn4ever.aop.aopconfig.Teacher&quot;&amp;gt;
        &amp;lt;!--注意,这个student的属性要是上边的代理类,而不是能student--&amp;gt;
        &amp;lt;!--&amp;lt;property name=&quot;student&quot; ref=&quot;student&quot;/&amp;gt;--&amp;gt;
        &amp;lt;property name=&quot;student&quot; ref=&quot;proxyOne&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--注入我们创建的通知类--&amp;gt;
    &amp;lt;bean id=&quot;advice&quot; class=&quot;cn.lyn4ever.aop.aopconfig.AuditAdvice&quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;!--创建代理类，使用前边写的通知进行通知，这样会使这个类上的所有方法都被通知--&amp;gt;
    &amp;lt;bean name=&quot;proxyOne&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot; p:target-ref=&quot;student&quot;
          p:interceptorNames-ref=&quot;interceptorNames&quot;&amp;gt;
        &amp;lt;!--因为interceptorNames的属性是一个可变参数,也就是一个list--&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--在上边引入了util的名称空间,简化了书写--&amp;gt;
    &amp;lt;util:list id=&quot;interceptorNames&quot;&amp;gt;
        &amp;lt;value&amp;gt;advice&amp;lt;/value&amp;gt;
    &amp;lt;/util:list&amp;gt;
&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
        GenericXmlApplicationContext context = new GenericXmlApplicationContext();
        context.load(&quot;application1.xml&quot;);
        context.refresh();

        Teacher teacher = (Teacher) context.getBean(&quot;teacherOne&quot;);
        teacher.tellStudent();

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;运行结果没有问题&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Lyn4ever29/img/master/gitnote/2019/12/17/1576590681502-1576590681505.png&quot; alt=&quot;SpringAop在web应用中的使用&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;以上是通过直接创建通知的方式，接下来我们试一个创建一个切入点（因为以上是对类中所有方法都进行通知，这时我们使用切入点只对其中部分方法进行通知）,在xml配置文件中添加如下。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:util=&quot;http://www.springframework.org/schema/util&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/util
       https://www.springframework.org/schema/util/spring-util.xsd&quot;&amp;gt;

    &amp;lt;!--注入student--&amp;gt;
    &amp;lt;bean name=&quot;student&quot; class=&quot;cn.lyn4ever.aop.aopconfig.Student&quot;&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--注入teacher--&amp;gt;
    &amp;lt;bean name=&quot;teacherOne&quot; class=&quot;cn.lyn4ever.aop.aopconfig.Teacher&quot;&amp;gt;
        &amp;lt;!--注意,这个student的属性要是上边的代理类,而不是能student--&amp;gt;
        &amp;lt;!--&amp;lt;property name=&quot;student&quot; ref=&quot;student&quot;/&amp;gt;--&amp;gt;
        &amp;lt;property name=&quot;student&quot; ref=&quot;proxyOne&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--注入我们创建的通知类--&amp;gt;
    &amp;lt;bean id=&quot;advice&quot; class=&quot;cn.lyn4ever.aop.aopconfig.AuditAdvice&quot;&amp;gt;&amp;lt;/bean&amp;gt;

    &amp;lt;!--创建代理类，使用前边写的通知进行通知，这样会使这个类上的所有方法都被通知--&amp;gt;
    &amp;lt;bean name=&quot;proxyOne&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot; p:target-ref=&quot;student&quot;
          p:interceptorNames-ref=&quot;interceptorNames&quot;&amp;gt;
        &amp;lt;!--因为interceptorNames的属性是一个可变参数,也就是一个list--&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;!--在上边引入了util的名称空间,简化了书写--&amp;gt;
    &amp;lt;util:list id=&quot;interceptorNames&quot;&amp;gt;
        &amp;lt;value&amp;gt;advice&amp;lt;/value&amp;gt;
    &amp;lt;/util:list&amp;gt;


    &amp;lt;!--以下是使用切入点的方式来进行通知,上边的代码和上一个配置文件一样,没有修改--&amp;gt;
    &amp;lt;!--sutdent基本bean,我们继续使用--&amp;gt;

    &amp;lt;bean name=&quot;teacherTwo&quot; p:student-ref=&quot;proxyTwo&quot; class=&quot;cn.lyn4ever.aop.aopconfig.Teacher&quot;/&amp;gt;

    &amp;lt;bean id=&quot;proxyTwo&quot; class=&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;
          p:target-ref=&quot;student&quot; p:interceptorNames-ref=&quot;interceptorAdvisorNames&quot;&amp;gt;
    &amp;lt;/bean&amp;gt;

    &amp;lt;util:list id=&quot;interceptorAdvisorNames&quot;&amp;gt;
        &amp;lt;value&amp;gt;advisor&amp;lt;/value&amp;gt;
    &amp;lt;/util:list&amp;gt;

    &amp;lt;!--配置切入点bean--&amp;gt;
    &amp;lt;bean id=&quot;advisor&quot; class=&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;
          p:advice-ref=&quot;advice&quot;&amp;gt;
        &amp;lt;property name=&quot;pointcut&quot;&amp;gt;
            &amp;lt;!--这个切入点我们用了一个匿名bean来写aspectJ的表达式,当然也可以用其他的类型切入点,这个在上边链接中能看到--&amp;gt;
            &amp;lt;bean class=&quot;org.springframework.aop.aspectj.AspectJExpressionPointcut&quot;
                  p:expression=&quot;execution(* talk*(..))&quot;/&amp;gt;
        &amp;lt;/property&amp;gt;

    &amp;lt;/bean&amp;gt;

&amp;lt;/beans&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Lyn4ever29/img/master/gitnote/2019/12/17/1576591483194-1576591483199.png&quot; alt=&quot;SpringAop在web应用中的使用&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;上图中的那个aspectj表达式写错了，在代码中有正确的&lt;br/&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Lyn4ever29/img/master/gitnote/2019/12/17/1576591830248-1576591830251.png&quot; alt=&quot;title&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;使用aop名称空间&quot;&gt;2.使用aop名称空间&lt;/h3&gt;
&lt;p&gt;在xml中引入如下的名称空间，为了不被影响，我册了其他多余的名称空间。然后很普通地注入我们之前那三个bean&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd
  &quot;&amp;gt;

    &amp;lt;!--通过普通的方式来注入三个bean--&amp;gt;
    &amp;lt;!--注入student--&amp;gt;
    &amp;lt;bean name=&quot;student&quot; class=&quot;cn.lyn4ever.aop.aopconfig.Student&quot;/&amp;gt;
    &amp;lt;!--注入teacher--&amp;gt;
    &amp;lt;bean name=&quot;teacherOne&quot; class=&quot;cn.lyn4ever.aop.aopconfig.Teacher&quot;&amp;gt;
        &amp;lt;property name=&quot;student&quot; ref=&quot;student&quot;/&amp;gt;
    &amp;lt;/bean&amp;gt;
    &amp;lt;!--注入我们创建的通知类--&amp;gt;
    &amp;lt;bean id=&quot;advice&quot; class=&quot;cn.lyn4ever.aop.proxyfactory.BeforeAdvice&quot;/&amp;gt;


    &amp;lt;aop:config&amp;gt;
        &amp;lt;aop:pointcut id=&quot;talkExecution&quot; expression=&quot;execution(* talk*(..))&quot;/&amp;gt;
        &amp;lt;aop:aspect ref=&quot;advice&quot;&amp;gt;
            &amp;lt;!--这个方法就是我们在自定义通知类中之写的方法--&amp;gt;
            &amp;lt;aop:before method=&quot;beforeSaySomething&quot; pointcut-ref=&quot;talkExecution&quot;/&amp;gt;
            &amp;lt;!--当然,还可以配置其他通知类型--&amp;gt;
        &amp;lt;/aop:aspect&amp;gt;
    &amp;lt;/aop:config&amp;gt;



&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个配置中，我们还可以配置其他类型的通知，但是这个method属性一定要写我们自定义的那个通知类中的方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Lyn4ever29/img/master/gitnote/2019/12/17/1576592872978-1576592872980.png&quot; alt=&quot;SpringAop在web应用中的使用&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在aop:pointcut中写expression时还支持如下语法：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;aop:pointcut id=&quot;talkExecution&quot; expression=&quot;execution(* talk*(..)) and args(String) and bean(stu*)&quot;/&amp;gt;
&amp;lt;!--
中间的这个and表示和，也可以用or来表示或
args(String) 意思是参数类型是string,也可是自定义的类，这个后边有例子
bean(stu*) 意思是bean的id是以stu开头的，常用的就是用bean(*Service*)来表示服务层的bean
--&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用aspectj样式注解方式&quot;&gt;3.使用@AspectJ样式注解方式&lt;/h3&gt;
&lt;p&gt;虽然是通过注解的方式来声明注解类，但是还是需要在xml中配置一点点内容（通过注解的方式也可以配置，但是在springboot中要使用的话有更方便的方式）&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;为了方便，就只写了一个HighStudent，而且直接调用它的方法，不依赖于外部的teacher实例来调用&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.lyn4ever.aop.aspectj;

import cn.lyn4ever.aop.aopconfig.Teacher;
import org.springframework.stereotype.Component;

/**
 * 声明这是一个SpringBean,由Spring来管理它
 */
@Component
public class HighStudent {

    public void talk() {
        System.out.println(&quot;I am a boy&quot;);
    }

    public void walk() {
        System.out.println(&quot;I am walking&quot;);
    }

    /**
     * 这个方法添加一个teacher来做为参数,为了配置后边切入点中的args()
     * @param teacher
     */
    public void sleep(Teacher teacher) {
        System.out.println(&quot;I want to sleep&quot;);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;创建切面类&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.lyn4ever.aop.aspectj;

import cn.lyn4ever.aop.aopconfig.Teacher;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

/**
 * 声明切面类,也就是包括切点和通知
 */
@Component //声明交由spring管理
@Aspect //表示这是一个切面类
public class AnnotatedAdvice {

    /*
    创建切入点,当然也可以是多个
     */
    @Pointcut(&quot;execution(* talk*(..))&quot;)
    public void talkExecution(){}

    @Pointcut(&quot;bean(high*)&quot;)//这里为什么是high,因为我们这回测试bean是highStudent
    public void beanPoint(){}

    @Pointcut(&quot;args(value)&quot;)
    public void argsPoint(Teacher value){}

    /*
    创建通知,当然也可以是多个
    这个注解的参数就是上边的切入点方法名,注意有的还带参数
    这个通知方法的参数和之前一样,榀加JoinPoint,也可不加
     */
    @Before(&quot;talkExecution()&quot;)
    public void doSomethingBefore(JoinPoint joinPoint){
        System.out.println(&quot;before: Do Something&quot;+joinPoint.getSignature().getName()+&quot;()&quot;);
    }

    /**
     * 环绕通知请加上ProceedingJoinPoint参数 ,它是joinPoint的子类
     * 因为你要放行方法的话,必须要加这个
     * @param joinPoint
     * @param teacher
     */
    @Around(&quot;argsPoint(teacher) &amp;amp;&amp;amp; beanPoint()&quot;)
    public Object doSomethindAround(ProceedingJoinPoint joinPoint, Teacher teacher) throws Throwable {
        System.out.println(&quot;Around: Before Do Something&quot;+joinPoint.getSignature().getName()+&quot;()&quot;);
        Object proceed = joinPoint.proceed();
        System.out.println(&quot;Around: After Do Something&quot;+joinPoint.getSignature().getName()+&quot;()&quot;);

        return proceed;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;xml中配置开启扫描注解&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/aop
       http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;&amp;gt;

    &amp;lt;!--通知Spring扫描@Aspect注解--&amp;gt;
    &amp;lt;aop:aspectj-autoproxy/&amp;gt;

    &amp;lt;!--配置扫描包,扫描@Component--&amp;gt;
    &amp;lt;context:component-scan base-package=&quot;cn.lyn4ever.aop.aspectj&quot;/&amp;gt;

&amp;lt;/beans&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;使用Java注解配置的方式配置扫描注解&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;
@Configuration //声明这是一个配置类
@ComponentScan(&quot;cn.lyn4ever.aop.aspectj&quot;)
@EnableAspectJAutoProxy(proxyTargetClass = true)//相当于xml中的&amp;lt;aop:aspectj-autoproxy/&amp;gt;
public class BeanConfig {
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;测试方法&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;package cn.lyn4ever.aop.aspectj;

import cn.lyn4ever.aop.aopconfig.Teacher;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import org.springframework.context.support.GenericApplicationContext;
import org.springframework.context.support.GenericXmlApplicationContext;

public class AspectMain {
    public static void main(String[] args) {
//        xmlConfig();
        javaConfig();

    }

    private static void javaConfig() {
        GenericApplicationContext context = new AnnotationConfigApplicationContext(BeanConfig.class);
        HighStudent student = (HighStudent) context.getBean(&quot;highStudent&quot;);
        student.sleep(new Teacher());//应该被环绕通知
        System.out.println();

        student.talk();//前置通知
        System.out.println();

        student.walk();//不会被通知
        System.out.println();
    }

    private static void xmlConfig(){
        GenericXmlApplicationContext context = new GenericXmlApplicationContext();
        context.load(&quot;application_aspect.xml&quot;);
        context.refresh();

        HighStudent student = (HighStudent) context.getBean(&quot;highStudent&quot;);
        student.sleep(new Teacher());//应该被环绕通知
        System.out.println();

        student.talk();//前置通知
        System.out.println();

        student.walk();//不会被通知
        System.out.println();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/Lyn4ever29/img/master/gitnote/2019/12/17/1576596954542-1576596954545.png&quot; alt=&quot;SpringAOP在web应用中的使用&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Lyn4ever29/RequireSpring&quot;&gt;项目代码地址,如果觉得还不错的话,给个star吧&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 17 Dec 2019 15:59:00 +0000</pubDate>
<dc:creator>小鱼吃猫</dc:creator>
<og:description>之前的aop是通过手动创建代理类来进行通知的，但是在日常开发中，我们并不愿意在代码中硬编码这些代理类，我们更愿意使用DI和IOC来管理aop代理类。Spring为我们提供了以下方式来使用aop框架 一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Lyn4ever/p/12057672.html</dc:identifier>
</item>
<item>
<title>Java自定义注解 - freshchen</title>
<link>http://www.cnblogs.com/freshchen/p/12057465.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freshchen/p/12057465.html</guid>
<description>&lt;h2 id=&quot;概念&quot;&gt;概念&lt;/h2&gt;
&lt;h3 id=&quot;作用&quot;&gt;作用&lt;/h3&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;构建或者运行阶段提供一些元数据，不影响正常运行逻辑，简化开发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;内置注解&quot;&gt;内置注解&lt;/h3&gt;
&lt;p&gt;Java提供了一些内置注解，并且实现了相关功能&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Override 检查该方法是否是重载方法，如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误&lt;/li&gt;
&lt;li&gt;@Deprecated 标记过时方法。如果使用该方法，会报编译警告&lt;/li&gt;
&lt;li&gt;@SuppressWarnings 指示编译器去忽略注解中声明的警告&lt;/li&gt;
&lt;li&gt;@SafeVarargs 忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告&lt;/li&gt;
&lt;li&gt;@FunctionalInterface 开始支持，标识一个匿名函数或函数式接口&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;元注解&quot;&gt;元注解&lt;/h3&gt;
&lt;p&gt;Java提供了一些注解来构建自定义注解&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;@Retention 指定生命周期
&lt;ul&gt;&lt;li&gt;RetentionPolicy.RUNTIME：运行时可以被反射捕获到&lt;/li&gt;
&lt;li&gt;RetentionPolicy.CLASS：注解会保留在.class字节码文件中，这是注解的默认选项，运行中获取不到&lt;/li&gt;
&lt;li&gt;RetentionPolicy.SOURCE：只在编译阶段有用，不被保存到class文件中&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;@Target 指定注解可以加在哪里
&lt;ul&gt;&lt;li&gt;ElementType.ANNOTATION_TYPE：只能用于定义其他注解&lt;/li&gt;
&lt;li&gt;ElementType.CONSTRUCTOR&lt;/li&gt;
&lt;li&gt;ElementType.FIELD&lt;/li&gt;
&lt;li&gt;ElementType.LOCAL_VARIABLE&lt;/li&gt;
&lt;li&gt;ElementType.METHOD&lt;/li&gt;
&lt;li&gt;ElementType.PACKAGE&lt;/li&gt;
&lt;li&gt;ElementType.PARAMETER&lt;/li&gt;
&lt;li&gt;ElementType.TYPE： 可以是类、接口、枚举或注释&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;@Inherited 使用了注解的类的子类会继承这个注解&lt;/li&gt;
&lt;li&gt;@Documented 用于在JavaDoc中生成&lt;/li&gt;
&lt;li&gt;@Repeatable 标识某注解可以在同一个声明上使用多次&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实践&quot;&gt;实践&lt;/h2&gt;
&lt;p&gt;首先我们定义两个比较常见作用域的自定义注解，在开发过程中我们一般都是定义运行时的注解，编译时的注解一般都是实现APT，用于一些编译时候的校验和生成字节码，代表的有Lombok框架。&lt;/p&gt;
&lt;h3 id=&quot;自定义注解&quot;&gt;自定义注解&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Inherited
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@interface Hello {
    String value() default &quot;&quot;;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Inherited
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
@interface Chinese {
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;注解功能实现&quot;&gt;注解功能实现&lt;/h3&gt;
&lt;h4 id=&quot;jdk动态代理&quot;&gt;JDK动态代理&lt;/h4&gt;
&lt;p&gt;现在我们有了自定义注解但是他没有实现任何功能，就只起装饰作用，下面我们来模拟一个场景，一个Person类有order行为，我们希望通过注解在点单前加上打招呼，Person有一个属性name，我们希望校验这个人名字由汉字组成&lt;/p&gt;
&lt;h5 id=&quot;bean&quot;&gt;Bean&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Person implements Action {

    @Chinese
    private String name;

    @Override
    @Hello(&quot;服务员&quot;)
    public void order() {
        System.out.println(&quot;可以给我一个汉堡包么？&quot;);
    }

    public Person(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public Person() {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;代理&quot;&gt;代理&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Proxys implements InvocationHandler {

    private Object target;

    public Proxys(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        String methodName = method.getName();
        if (this.target instanceof Person) {
            Person person = (Person) this.target;
            // 判断Person类，name字段有没有加Chinese注解
            if (person.getClass()
                    .getDeclaredField(&quot;name&quot;)
                    .isAnnotationPresent(Chinese.class)) {
                // 判断名字是不是汉字
                if (Objects.nonNull(person.getName()) &amp;amp;&amp;amp;
                        !person.getName().matches(&quot;[\\u4E00-\\u9FA5]+&quot;)) {
                    throw new IllegalArgumentException(&quot;Person Name is not chinese&quot;);
                }
            }
            Method targetMethod = person.getClass().getMethod(methodName);
            if (&quot;order&quot;.equals(methodName)) {
                // 拦截接口实现类中order方法判断是否有Hello注解
                if (targetMethod.isAnnotationPresent(Hello.class)) {
                    System.out.println(&quot;你好,&quot; +
                            targetMethod.getAnnotation(Hello.class).value());
                } else if (method.isAnnotationPresent(Hello.class)) { // 拦截接口中order方法判断是否有Hello注解
                    System.out.println(&quot;你好,&quot; +
                            method.getAnnotation(Hello.class).value());
                }
                return method.invoke(this.target, args);
            }
        }
        return null;
    }

    public static Object getProxy(Object action) {
        Proxys handler = new Proxys(action);
        return Proxy.newProxyInstance(
                action.getClass().getClassLoader(),
                action.getClass().getInterfaces(),
                handler);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;测试&quot;&gt;测试&lt;/h5&gt;
&lt;p&gt;可以看到我们的注解起到效果了&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class Test {

    public static void main(String[] args) {
        Action person1 = (Action) Proxys.getProxy(new Person(&quot;匿名&quot;));
        person1.order();
        Action person2 = (Action) Proxys.getProxy(new Person(&quot;Sun&quot;));
        person2.order();
    }

    /**
     * 输出：
     * 你好,服务员
     * 可以给我一个汉堡包么？
     * Exception in thread &quot;main&quot; java.lang.IllegalArgumentException: Person Name is not chinese
     *  at reflect.annotations.Proxys.invoke(Proxys.java:32)
     *  at com.sun.proxy.$Proxy0.order(Unknown Source)
     *  at reflect.annotations.Test.main(Test.java:9)
     */
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;spring-aop&quot;&gt;Spring AOP&lt;/h4&gt;
&lt;p&gt;目前Spring框架用的比较多，我们定义和上面一样的hello注解&lt;/p&gt;
&lt;h5 id=&quot;切面&quot;&gt;切面&lt;/h5&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Aspect
@Component
public class HelloAspect {

    @Pointcut(&quot;@ (com.github.freshchen.springbootcore.annotation.Hello)&quot;)
    private void pointcut(){}

    @Before(&quot;pointcut() &amp;amp;&amp;amp; @annotation(hello)&quot;)
    public void hello(Hello hello){
        System.out.println(&quot;你好，&quot; + hello.value());
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;测试-1&quot;&gt;测试&lt;/h5&gt;
&lt;p&gt;同样起到了效果，Spring真香&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@SpringBootApplication
public class SpringbootCoreApplication {

    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(SpringbootCoreApplication.class, args);
        Person person = context.getBean(&quot;person&quot;, Person.class);
        person.order();
    }

    /**
     * 输出：
     * 你好，服务员
     * 可以给我一个汉堡包么？
     */

}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 17 Dec 2019 15:07:00 +0000</pubDate>
<dc:creator>freshchen</dc:creator>
<og:description>概念 作用 构建或者运行阶段提供一些元数据，不影响正常运行逻辑，简化开发 内置注解 Java提供了一些内置注解，并且实现了相关功能 @Override 检查该方法是否是重载方法，如果发现其父类，或者是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/freshchen/p/12057465.html</dc:identifier>
</item>
<item>
<title>代码检查又一利器：ArchUnit - Jackeyzhe</title>
<link>http://www.cnblogs.com/Jackeyzhe/p/12057437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Jackeyzhe/p/12057437.html</guid>
<description>&lt;p&gt;Code Review总是让人又爱又恨，它可以帮助我们在提测之前发现很多代码中比较“丢人”的问题，但是，Code Review通常会比写代码更加耗费精力，因为你需要理解别人的代码，而为了这一目的，往往需要很多次的沟通。&lt;/p&gt;
&lt;p&gt;人们常说“见字如面”。我认为代码也是一样，看到一个人的代码，就会对这个人有一个大概的印象。例如，当你看到一段代码写的非常随意，随意的格式、随意的命名、随意的封装，然后又没有单元测试，那我们一般会认为这段代码的作者是一个不够严谨、做事随意、有些懒惰，又对自己的代码责任心不强的人。如果你不是这样的人，那就需要花费更多的力气向同事证明自己。而如果在代码中做好每一个细节，严格遵循编码规范，单元测试覆盖率比较高，那么同事对你的第一印象一定是这个人还是比较可靠的，跟他合作应该比较愉快。&lt;/p&gt;
&lt;p&gt;说了这么多，其实就是想强调Code Review的重要性。那么既然它这么重要，但又给我们带来了更大的工作量。作为程序员，我们一定会想，能不能自动化？答案当然是可以。事实上现在也有很多公司实现了自动化，例如自动进行静态代码分析来确保代码质量，利用类似&lt;a href=&quot;https://cobertura.github.io/cobertura/&quot;&gt;Cobertura&lt;/a&gt;这样的工具来检查单元测试覆盖程度等等。但是这并不能完全保证代码的整洁性和可靠性。&lt;/p&gt;
&lt;p&gt;有了这些工具之后Code Review轻松了许多，但是这些工具的安装、使用也是需要花费很高的成本的。所以我想给大家介绍的是一个使用简单、方便的工具来帮我完成这些任务。在介绍之前，我们先来想一想我们平时在Review别人代码时可能会注意哪些问题。这里我简单列出来了一些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抛出的异常不能太过广泛&lt;/li&gt;
&lt;li&gt;不能写&lt;code&gt;System.out&lt;/code&gt;，而是要用日志输出&lt;/li&gt;
&lt;li&gt;不能使用&lt;code&gt;java.util.logging&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果使用贫血模型开发，每个类需要放到对应的包中&lt;/li&gt;
&lt;li&gt;接口不能放在实现类的包中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Service&lt;/code&gt;层代码不能访问&lt;code&gt;Controller&lt;/code&gt;层代码&lt;/li&gt;
&lt;li&gt;合理使用第三方库&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些事情以前我们都是靠人工来检查，直到我发现了&lt;a href=&quot;https://www.archunit.org/&quot;&gt;ArchUnit&lt;/a&gt;这个库。感觉像是抓住了自动化道路上的救命稻草。&lt;/p&gt;
&lt;h3 id=&quot;什么是archunit&quot;&gt;什么是ArchUnit？&lt;/h3&gt;
&lt;p&gt;ArchUnit的官方网站是 &lt;a href=&quot;https://www.archunit.org/&quot;&gt;https://www.archunit.org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网中原话介绍是&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;ArchUnit is a free, simple and extensible library for checking the architecture of your Java code using any plain Java unit test framework.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思是ArchUnit是一款免费、简单可扩展的库，它可以使用任何Java单元测试框架来检查Java代码的架构。&lt;/p&gt;
&lt;p&gt;也就是说，它的主要功能是用来检查代码结构的。那么怎么使用呢？&lt;/p&gt;
&lt;h3 id=&quot;如何使用&quot;&gt;如何使用？&lt;/h3&gt;
&lt;p&gt;ArchUnit的简单绝对不是空谈，如果你是maven项目，只需要在pom.xml文件中添加如下依赖：&lt;/p&gt;
&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;&amp;lt;dependency&amp;gt;
    &amp;lt;groupId&amp;gt;com.tngtech.archunit&amp;lt;/groupId&amp;gt;
    &amp;lt;artifactId&amp;gt;archunit&amp;lt;/artifactId&amp;gt;
    &amp;lt;version&amp;gt;0.12.0&amp;lt;/version&amp;gt;
    &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你是Gradle项目，使用起来同样非常简单&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;dependencies {
    testCompile 'com.tngtech.archunit:archunit:0.8.0'
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当你添加了依赖以后，就可以为我们前面提到的规则写测试用例了。&lt;/p&gt;
&lt;p&gt;当然，也有一些内建的通用规则，它们定义在&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;com.tngtech.archunit.library.GeneralCodingRules&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个类中。关于内建规则的细节，可以查看&lt;a href=&quot;https://www.archunit.org/userguide/html/000_Index.html#_general_coding_rules&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;自定义规则&quot;&gt;自定义规则&lt;/h3&gt;
&lt;p&gt;除了内建规则以外，ArchUnit也支持你定义自己需要的规则，至于如何定义规则，文档中都有详细的介绍。当然，也可以参考这个例子来写一些规则。 &lt;a href=&quot;https://github.com/TNG/ArchUnit-Examples&quot; class=&quot;uri&quot;&gt;https://github.com/TNG/ArchUnit-Examples&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;如何执行&quot;&gt;如何执行&lt;/h3&gt;
&lt;p&gt;规则定义好以后如何执行呢？我们说ArchUnit使用起来非常简单，如果需要测试，对maven项目来说只需要执行命令&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mvn test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而对于Gradle项目来说，只要执行命令&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;gradle test&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;ArchUnit看起来是一个很酷的三方库，我并没有在使用层面做过多介绍，因为我也在摸索中，感兴趣的朋友可以和我一起交流。&lt;/p&gt;
</description>
<pubDate>Tue, 17 Dec 2019 14:59:00 +0000</pubDate>
<dc:creator>Jackeyzhe</dc:creator>
<og:description>Code Review总是让人又爱又恨，它可以帮助我们在提测之前发现很多代码中比较“丢人”的问题，但是，Code Review通常会比写代码更加耗费精力，因为你需要理解别人的代码，而为了这一目的，往往</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Jackeyzhe/p/12057437.html</dc:identifier>
</item>
</channel>
</rss>