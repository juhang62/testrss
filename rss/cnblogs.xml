<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Linux重定向与管道 - Hopkins'Cybernetics</title>
<link>http://www.cnblogs.com/HopkinsCybn/p/10204928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/HopkinsCybn/p/10204928.html</guid>
<description>&lt;div readability=&quot;13.5&quot;&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/441226/201901/441226-20190101153509690-1915114315.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;程序执行时默认会打开3个流，标准输入、标准输出、标准错误。&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;Redirection&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
　　The shell interprets the symbols &amp;lt;,&amp;gt;, and &amp;gt;&amp;gt; as instructions to reroute a command&lt;span&gt;'&lt;/span&gt;&lt;span&gt;s input or output to or from a file.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;Pipes&lt;/span&gt;&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
　　To connect the STDOUT of one command to the STDIN of another use the | symbol, commonly known as a pipe.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;重定向：用于输入和输出文件（流）&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;管道：用于将前一个命令（程序）的输出作为另外一个命令（程序）的输入。&lt;/p&gt;
&lt;p&gt;
&lt;h3&gt;重定向Redirection&lt;/h3&gt;
1、重定向到一个文件&lt;/p&gt;
&lt;p&gt;&amp;gt;：将输出STDOUT/STDERR重定向到一个文件，如果文件存在，就先清空文件内容，再保存；如果不存在，就创建一个新文件。&lt;br/&gt;&amp;gt;&amp;gt;：将输出STDOUT/STDERR重定向追加到一个文件。如果文件存在，则追加到文件最后；如果不存在，则创建一个新文件。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;2、将文件重定向到一个命令或者程序的输入STDIN&lt;/p&gt;
&lt;p&gt;&amp;lt;读取文件，并将内容重定向到命令或者程序的STDIN&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;3、重定向标准输出STDERR&lt;/p&gt;
&lt;p&gt;2&amp;gt;file&lt;br/&gt;2&amp;gt;&amp;amp;1&lt;/p&gt;
&lt;div&gt;
&lt;h3&gt;管道Pipe&lt;/h3&gt;
&lt;p&gt;[command1] | [command2]&lt;/p&gt;
&lt;/div&gt;


&lt;p&gt;
&lt;h2 id=&quot;welcome&quot;&gt; &lt;/h2&gt;
&lt;/p&gt;


</description>
<pubDate>Tue, 01 Jan 2019 07:32:00 +0000</pubDate>
<dc:creator>Hopkins&amp;#39;Cybernetics</dc:creator>
<og:description>程序执行时默认会打开3个流，标准输入、标准输出、标准错误。 Redirection The shell interprets the symbols &lt;,&gt;, and &gt;&gt; a</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/HopkinsCybn/p/10204928.html</dc:identifier>
</item>
<item>
<title>Fiddler原理~知多少? - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/10204856.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/10204856.html</guid>
<description>&lt;p&gt;首先我们学习Fidder这个工具，我们就应该去了解它的基本东西，比如这个单词的意思。Fiddler叫：小提琴、骗子的意思。&lt;/p&gt;
&lt;h2&gt;那么它是干什么的呢？&lt;/h2&gt;
&lt;blockquote readability=&quot;11.668965517241&quot;&gt;
&lt;p&gt;Fiddler是一个http协议调试代理工具，它能够记录并检查所有你的电脑和互联网之间的http通讯，设置断点，查看所有的“进出”Fiddler的数据（指&lt;a href=&quot;https://baike.baidu.com/item/cookie/1119&quot; target=&quot;_blank&quot; data-lemmaid=&quot;1119&quot;&gt;cookie&lt;/a&gt;,html,js,css等文件）。 Fiddler 要比其他的网络调试器要更加简单，因为它不仅仅暴露http通讯还提供了一个用户友好的格式，Fiddler 是用C#写出来的,它包含一个简单却功能强大的基于JScript .NET 事件脚本子系统，它的灵活性非常棒，可以支持众多的http调试任务，并且能够使用&lt;a href=&quot;https://baike.baidu.com/item/.net%E6%A1%86%E6%9E%B6&quot; target=&quot;_blank&quot;&gt;.net框架&lt;/a&gt;语言进行扩展。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么从简介中可以看到，他是一个http协议的调试工具，那HTTP协议是干什么呢？&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;HTTP（HyperText Transport Protocol）是超文本传输协议的缩写，它用于传送WWW方式的数据，关于HTTP协议的详细内容请参考RFC2616。HTTP协议采用了请求/响应模型。客户端向服务器发送一个请求，请求头包含请求的方法、URL、协议版本、以及包含请求修饰符、客户信息和内容的类似于MIME的消息结构。服务器以一个状态行作为响应，响应的内容包括消息协议的版本，成功或者错误编码加上包含服务器信息、实体元信息以及可能的实体内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;刚才我说fiddler是个骗子，那它怎么骗的啊，我们来打开一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190101150438499-971688985.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;刚刚打开没多久，这些列表就会慢慢的加进来，这是什么呢？这是来自于你电脑上的http请求的信息。实际上fiddler打开之后就已经进行代理了。&lt;/p&gt;
&lt;h2&gt;Fiddler的原理&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190101150808474-2092251516.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;左侧是我们的客户端，就是一些终端，那它访问各种网站的时候，会通过http请求通过进行fiddler进行代理，然后再通过fiddler的转发请求服务器，服务器再通过response进行响应，反正就是通过fiddler是个中间层。就是这么个意思。当然，在打开fiddler的时候就已经打开代理了。它是如何进行代理的呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190101151201582-783332536.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为什么我们打开应用或者说软件就会被fiddler进行代理呢？我们随便打开个页面，例如百度新闻。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190101151530831-1212780446.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们发现，我们只要干什么事，都被会被他们截取，他们究竟是干了什么邪门的事情？我们打开浏览器的设置-搞基-系统-代理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190101151752121-757125650.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如下图，我们逐一打开，发现其中的端口号和我们的Fiddler工具中的设置端口一毛一样，这就是代理工具关键。当然这也是fiddler修改的。意思就是中间经过了个人，就是这个代理工具，fiddler，所以它能抓到这个包。&lt;/p&gt;
&lt;p&gt;其中需要注意的是，当fiddler一关闭，那么这个代理就会被关闭，也就变成灰色的了。&lt;/p&gt;
&lt;p&gt;如果是其他浏览器，有可能打开fiddler那个代理可能不会自动开启，需要你自己找，自己开，自己关。。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190101151946341-691074563.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 01 Jan 2019 07:29:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>首先我们学习Fidder这个工具，我们就应该去了解它的基本东西，比如这个单词的意思。Fiddler叫：小提琴、骗子的意思。 那么它是干什么的呢？ Fiddler是一个http协议调试代理工具，它能够记</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/10204856.html</dc:identifier>
</item>
<item>
<title>如何在启用JWT Token的.NET Core WebApi项目中下载文件 - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10204918.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10204918.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190101152546871-1196362654.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;前几天，做项目的时候遇到一个文件下载的问题。当前系统是一个前后端分离的项目，前端是一个AngularJs项目, 后端是一个.NET Core WebApi项目。后端的Api项目使用了Jwt Token授权，所以每个Api请求都需要传递一个Bearer Token。&lt;/p&gt;
&lt;p&gt;这一切都看起来理所当然，但是当需要从WebApi下载文件的时候，出现了问题。以前下载文件的时候，我们可以在Javascript中使用&lt;code&gt;window.open('[文件下载Api]')&lt;/code&gt;的方式下载文件，但是这个方法不能接收Bearer Token, 所以就会导致文件下载失败，返回一个401未授权的响应码。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;可能有的同学会将这个文件下载Api设置成允许匿名访问，但是这样会导致系统不安全。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;那么有什么好一点的方式可以解决这个问题呢？&lt;/p&gt;

&lt;h2 id=&quot;使用blob对象&quot;&gt;使用Blob对象&lt;/h2&gt;
&lt;p&gt;Blob对象可以看做是Javascript中的二进制容器, 它可以存储文件的二进制流。所以我们可以通过如下思路完成文件下载：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;创建一个异步请求来下载文件的二进制流，这个请求的头部需要附加Bearer Token，在方法回调中，我们将文件二进制流保存在一个Blob对象中&lt;/li&gt;
&lt;li&gt;我们使用Javascript添加一个虚拟的超链接，超链接的href属性指向了刚刚的Blob对象。&lt;/li&gt;
&lt;li&gt;我们通过模拟点击这个虚拟的超链接，来完成文件下载的功能。&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;let anchor = document.createElement(&quot;a&quot;);
let file = 'https://www.example.com/api/getFiles/'+fileId;

let headers = new Headers();
headers.append('Authorization', 'Bearer MY-TOKEN');

fetch(file, { headers })
    .then(response =&amp;gt; response.blob())
    .then(blobby =&amp;gt; {
        let objectUrl = window.URL.createObjectURL(blobby);

        anchor.href = objectUrl;
        anchor.download = 'some-file.pdf';
        anchor.click();

        window.URL.revokeObjectURL(objectUrl);
    });&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方案有两个缺点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;就是只有当文件流完全读取到Blob对象中之后，才会触发真正的文件下载。因此如果文件内容过大话，浏览器会有一个长时间的静止，当文件流全部加载到Blob对象之后，才会触发下载操作。所以这里可能需要添加自己添加一个Loading效果，给用户一些提示。&lt;/li&gt;
&lt;li&gt;并不是所有的浏览器都支持Blob对象，在一些老的浏览器中Blob对象是不被支持的。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;使用asp.net-core中的data-protection&quot;&gt;使用ASP.NET Core中的Data Protection&lt;/h2&gt;
&lt;p&gt;在之前的博客中，我有讲解过&lt;a href=&quot;https://www.cnblogs.com/lwqlun/p/9726191.html&quot;&gt;ASP.NET Core中的Data Protection功能&lt;/a&gt;, 我们可以使用Data Protection将一些敏感信息加密。所以这里我们可以将一个需要授权才能使用下载文件的Api, 替换成2个Api&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第一个Api是需要授权的，它主要负责查看文件ID是否存在，如果存在，就使用Data Protection, 将这个ID加密，并返回给前端，这个ID的加密时效设置为5秒。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;第二个Api是不需要授权的，允许匿名访问。它接收前一个Api提供的加密ID, 如果ID可以解密成功，就返回这个ID对应的文件流。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;第一个Api的实例代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[HttpGet]
[Route(&quot;~/api/file_links/{fileId}&quot;)]
public IActionResult GetFileLink(Guid fileId)
{
    if (_files.Any(p =&amp;gt; p.FileId == fileId))
    {
        var matchedFile = _files.First(p =&amp;gt; p.FileId == fileId);

        return Content(this.protector.Protect(matchedFile.FileId.ToString(),
            TimeSpan.FromSeconds(5)));
    }

    return StatusCode(500);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二个Api的实例代码：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;[HttpGet]
[AllowAnonymous]
[Route(&quot;~/api/raw_files/{id}&quot;)]
public IActionResult GetRawFile(string id)
{
    try
    {
        var rawId = Guid.Parse(this.protector.Unprotect(id));
        var matchedFile = _files.First(p =&amp;gt; p.FileId == rawId);
        matchedFile.FileContent.Position = 0;

        return File(matchedFile.FileContent, &quot;text/plain&quot;, &quot;helloWorld.txt&quot;);
    }
    catch
    {
        return StatusCode(401);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;使用这种方式，虽然我们开放了一个未经授权就可以访问的Api入口，但是由于使用了Data Protection, 所以对于非法的请求，系统也可以进行一定的屏蔽。&lt;/p&gt;
&lt;h2 id=&quot;最终效果&quot;&gt;最终效果&lt;/h2&gt;
&lt;p&gt;针对以上2种下载方式，我创建了一个小项目，项目地址：&lt;a href=&quot;https://github.com/lamondlu/Sample_DownloadFileInAuth&quot; class=&quot;uri&quot;&gt;https://github.com/lamondlu/Sample_DownloadFileInAuth&lt;/a&gt;, 打开之后页面如下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190101152605643-1837447473.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;普通下载&quot;&gt;普通下载&lt;/h3&gt;
&lt;p&gt;由于缺少Token, 所以下载失败，返回401&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190101152610983-1069880043.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用blob下载&quot;&gt;使用Blob下载&lt;/h3&gt;
&lt;p&gt;使用Blob下载之后，文件下载成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190101152618011-195640675.png&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;使用data-protection&quot;&gt;使用Data Protection&lt;/h3&gt;
&lt;p&gt;使用Data Protection后，文件下载成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201901/65831-20190101152625135-1305165946.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;本文只算抛砖引玉，如果大家有更好的解决方案，欢迎一起讨论。&lt;/p&gt;
</description>
<pubDate>Tue, 01 Jan 2019 07:29:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>背景 前几天，做项目的时候遇到一个文件下载的问题。当前系统是一个前后端分离的项目，前端是一个AngularJs项目, 后端是一个.NET Core WebApi项目。后端的Api项目使用了Jwt To</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10204918.html</dc:identifier>
</item>
<item>
<title>再见2018，感谢你的一路陪伴 - 56899◎か</title>
<link>http://www.cnblogs.com/qy1234/p/10204750.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qy1234/p/10204750.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/992081/201901/992081-20190101143219713-463657322.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;人生实苦，但苦中有乐；生活虽难，但难中有福。这个世界，总有人会在默默关心你、爱着你。希望你能相信，你的生活很好，你自己也很好；你的过去很好，你的未来也会很好的。再见了，2018；你好呀，2019。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;——by圈姐&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#再见2018# 感恩，感谢一路帮助我所有的人&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;     时光匆匆，一年终将过去，再见2018。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;默默回想这一年，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;只想真诚的说一声：&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;这一年，感谢有你！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; 感谢有你的陪伴&lt;/strong&gt;&lt;/span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;   &lt;span&gt;&lt;span&gt;感谢你的一路陪伴，&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt; 感谢你在我身体糟糕情况，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;  你的不弃，并鼓励我一切会过去，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;生活会越来越好；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;    感谢你在我职场中遇到困惑时候的，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;    给我解惑,&lt;/span&gt;&lt;span&gt;并鼓励我换新的环境，&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;  支持我想做的事情；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;     感谢你在我没有工作时候的，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;     你已帮我一份新的工作，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;       并鼓励我从哪跌倒就从哪站起；&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;  感谢有你，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; 是你教会我为人处世，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;       是你教会我如何去学习，&lt;/span&gt;&lt;span&gt;     &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;   是你让我变得更坚强，更自信，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;  这些温暖，让我成为更好的自己&lt;/strong&gt;&lt;strong&gt;！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;感谢陌生人的援手&lt;/strong&gt;&lt;/span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;我们是匆匆的行者，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;无意间有了交集，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;匆匆相见，但不曾忘却。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;每一个陌生温暖，&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;都像是清晨的阳光，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;虽不炙热，却让人难以忘怀。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;感谢曾经伤害我们的人&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;每一次嘲笑和打击，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;都让我们如同浴火的凤凰，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;变成更坚强的自己。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;感谢人生每一个关口给你提醒的人&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;他的语言也许简单尖锐，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;但是却让你少了许多辛苦与迷茫。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;感谢生命中的那些过客，&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;你们的离去与来到，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;让我们明白缘来缘去，生命无常，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;珍惜每一次相遇和告别。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;这一年，感谢你，与我相知&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;陪我走过风风雨雨，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;即便是长路漫漫，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;我也从不缺少，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;为我遮风挡雨的那把伞，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;和一个可以依靠的臂膀。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;是你们给了我生命中一点一滴的温暖，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;这些温暖，使我远离阴霾，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;这些温暖，使我成为善良的人，&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt;&lt;strong&gt;这些温暖，让我成为更好的自己！&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 Jan 2019 06:27:00 +0000</pubDate>
<dc:creator>56899◎か</dc:creator>
<og:description>人生实苦，但苦中有乐；生活虽难，但难中有福。这个世界，总有人会在默默关心你、爱着你。希望你能相信，你的生活很好，你自己也很好；你的过去很好，你的未来也会很好的。再见了，2018；你好呀，2019。 —</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qy1234/p/10204750.html</dc:identifier>
</item>
<item>
<title>Android——LruCache源码解析 - zxzhang</title>
<link>http://www.cnblogs.com/ZhaoxiCheung/p/Android-LruCache-Source-Analysis.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZhaoxiCheung/p/Android-LruCache-Source-Analysis.html</guid>
<description>&lt;p&gt;以下针对 Android API 26 版本的源码进行分析。&lt;br/&gt;在了解&lt;code&gt;LruCache&lt;/code&gt;之前，最好对&lt;code&gt;LinkedHashMap&lt;/code&gt;有初步的了解，&lt;code&gt;LruCache&lt;/code&gt;的实现主要借助&lt;code&gt;LinkedHashMap&lt;/code&gt;。&lt;code&gt;LinkedHashMap&lt;/code&gt;的源码解析，可阅读&lt;a href=&quot;https://www.cnblogs.com/ZhaoxiCheung/p/Java-LinkedHashMap-Source-Analysis.html&quot;&gt;Java——LinkedHashMap源码解析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;span id=&quot;概述&quot;&gt;概述&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  &lt;code&gt;LruCahce&lt;/code&gt;其 Lru 是 Least Recently Used 的缩写，即最近最少使用，是包含对有限数量值的强引用的缓存。每当一个值被访问，它将被移到队尾。当缓存达到指定的数量时，位于队头的值将被移除，并且可能被 GC 回收。如果缓存的值包含需要显式释放的资源，那么需要重写&lt;code&gt;entryRemoved&lt;/code&gt;方法。如果 key 对应的缓存未命中，通过重写&lt;code&gt;create&lt;/code&gt;方法创建对应的 value。这可以简化代码调用：即使存在缓存未命中，也允许假设始终返回一个值。&lt;br/&gt;  默认情况下，缓存大小以条目数量度量。在不同缓存对象下，通过重写&lt;code&gt;sizeOf&lt;/code&gt;方法测量 key-value 缓存的大小。例如如下的例子，这个缓存限制了 4MiB 大小的位图：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;int cacheSize = 4 * 1024 * 1024; // 4MiB
LruCache&amp;lt;String, Bitmap&amp;gt; bitmapCache = new LruCache&amp;lt;String, Bitmap&amp;gt;(cacheSize) {
    protected int sizeOf(String key, Bitmap value) {
        return value.getByteCount();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  这个类是线程安全的，通过在缓存上执行同步操作来以原子方式执行多个缓存操作：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;synchronized (cache) {
    if (cache.get(key) == null) {
        cache.put(key, value);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  这个类不允许空值作为 key 或者 value，对于&lt;code&gt;get&lt;/code&gt;、&lt;code&gt;put&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt;方法返回&lt;code&gt;null&lt;/code&gt;值是明确的行为：缓存中不存在这个键。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;h3 id=&quot;主要字段&quot;&gt;主要字段&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;    //LruCache 主要借助 LinkedHashMap 按元素访问顺序的迭代顺序（此时 accessOrder = true）来实现
    private final LinkedHashMap&amp;lt;K, V&amp;gt; map;

    /** 不同 key-value 条目下缓存的大小，不一定是 key-value 条目的数量 */
    private int size;
    //缓存大小的最大值
    private int maxSize;
    
    //存储的 key-value 条目的个数
    private int putCount;
    //创建 key 对应的 value 的次数
    private int createCount;
    //缓存移除的次数
    private int evictionCount;
    //缓存命中的次数
    private int hitCount;
    //缓存未命中的次数
    private int missCount;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;构造函数&quot;&gt;构造函数&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * maxSize 对于缓存没有重写 sizeOf 方法的时候，这个数值指定了缓存中可以容纳的最大条目的数量；
 * 对于其他缓存，这是缓存中条目大小的最大总和。
 */
public LruCache(int maxSize) {
    if (maxSize &amp;lt;= 0) {
        throw new IllegalArgumentException(&quot;maxSize &amp;lt;= 0&quot;);
    }
    this.maxSize = maxSize;

    //指定了哈希表初始容量为0，负载因子为0.75，迭代顺序为按照条目访问顺序
    //因此在有对条目进行访问的操作的时候，条目都会被放置到队尾，具体细节详看 LinkedHashMap 的解析
    this.map = new LinkedHashMap&amp;lt;K, V&amp;gt;(0, 0.75f, true);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;size操作&quot;&gt;Size操作&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;LruCache&lt;/code&gt;在默认情况下，&lt;u&gt;size&lt;/u&gt; 指的是 key-value 条目的个数，当重写&lt;code&gt;sizeOf&lt;/code&gt;函数时，可以自定义 key-value 条目的单位大小，如&lt;a href=&quot;http://www.cnblogs.com/ZhaoxiCheung/p/Android-LruCache-Source-Analysis.html#概述&quot;&gt;概述&lt;/a&gt;中位图的例子，其通过重写&lt;code&gt;sizeOf&lt;/code&gt;函数，返回的大小值并非是 1，而是不同&lt;code&gt;Bitmap&lt;/code&gt;对象的字节大小。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 以用户定义的单位返回 key-value 条目的大小
 * 默认实现返回1，因此 size 是条目数，max size是最大条目数
 * 条目的大小在缓存中时不得更改
 */
protected int sizeOf(K key, V value) {
    return 1;
}

private int safeSizeOf(K key, V value) {
    int result = sizeOf(key, value);
    if (result &amp;lt; 0) {
        throw new IllegalStateException(&quot;Negative size: &quot; + key + &quot;=&quot; + value);
    }
    return result;
}

/**
 * 删除最旧的条目，直到剩余条目总数小于等于指定的大小。
 */
public void trimToSize(int maxSize) {
    while (true) {
        K key;
        V value;
        synchronized (this) {
            if (size &amp;lt; 0 || (map.isEmpty() &amp;amp;&amp;amp; size != 0)) {
                throw new IllegalStateException(getClass().getName()
                        + &quot;.sizeOf() is reporting inconsistent results!&quot;);
            }

            //哈希表中条目的大小小于指定的大小即终止
            if (size &amp;lt;= maxSize) {
                break;
            }
            
            //获取哈希表中最旧的条目
            Map.Entry&amp;lt;K, V&amp;gt; toEvict = map.eldest();

            //哈希表为空，终止
            if (toEvict == null) {
                break;
            }

            key = toEvict.getKey();
            value = toEvict.getValue();
            map.remove(key);
            size -= safeSizeOf(key, value);

            //移除元素的次数
            evictionCount++;
        }

        //此处 evicted 为 true，表明是为了腾出空间而进行的删除条目操作
        entryRemoved(true, key, value, null);
    }
}

/**
 * 调整缓存的大小
 */
public void resize(int maxSize) {
    if (maxSize &amp;lt;= 0) {
        throw new IllegalArgumentException(&quot;maxSize &amp;lt;= 0&quot;);
    }

    synchronized (this) {
        this.maxSize = maxSize;
    }
    trimToSize(maxSize);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;查询&quot;&gt;查询&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 指定 key 对应的 value 值存在时返回，否则通过 create 方法创建相应的 key-value 对。
 * 如果对应的 value 值被返回，那么这个 key-value 对将被移到队尾。
 * 当返回 null 时，表明没有对应的 value 值并且也无法被创建
 */
public final V get(K key) {
    //缓存不允许 key 值为 null，因此对于查询 null 的键可直接抛出异常
    if (key == null) {
        throw new NullPointerException(&quot;key == null&quot;);
    }

    V mapValue;
    synchronized (this) {
        mapValue = map.get(key);
        //缓存命中
        if (mapValue != null) {
            hitCount++;
            return mapValue;
        }
        //缓存未命中
        missCount++;
    }

    /*
     * 尝试创建一个 value 值，这可能需要花费较长的时间完成，当 create 返回时，哈希表可能变得不同
     * 如果在 create 工作时向哈希表添加了一个冲突的值（key 已经有对应的 value 值，但 create 方法返回了一个不同的 value 值）
     * 那么将该值保留在哈希表中并释放创建的值。
     */
    V createdValue = create(key);
    if (createdValue == null) {
        return null;
    }

    synchronized (this) {
        //缓存创建的次数
        createCount++;
        mapValue = map.put(key, createdValue);

        if (mapValue != null) {
            // mapValue 不为 null，说明存在一个冲突值，保留之前的 value 值
            map.put(key, mapValue);
        } else {
            size += safeSizeOf(key, createdValue);
        }
    }

    if (mapValue != null) {
        entryRemoved(false, key, createdValue, mapValue);
        return mapValue;
    } else {
        trimToSize(maxSize);
        return createdValue;
    }
}

/**
 * 在缓存未命中之后调用以计算相应 key 的 value。
 * 当能计算 key 对应的 value 时，返回 value，否则返回 null。默认实现一律返回 null 值。
 *
 * 这个方法在被调用的时候没有添加额外的同步操作，因此其他线程可能在这个方法执行时访问缓存
 *
 * 如果 key 对应的 value 存储在缓存中，那么通过 create 创建的 value 将通过 entryRemoved 方法释放。
 * 这种情况主要发生在：当多个线程同时请求相同的 key （导致创建多个值）时，或者当一个线程调用 put 而另一个线程为其创建值时
 */
protected V create(K key) {
    return null;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;存储&quot;&gt;存储&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 对于 key，缓存其相应的 value，key-value 条目放置于队尾
 *
 * @return 返回先前 key 对应的 value 值
 */
public final V put(K key, V value) {
    if (key == null || value == null) {
        throw new NullPointerException(&quot;key == null || value == null&quot;);
    }

    V previous;
    synchronized (this) {
        putCount++;
        size += safeSizeOf(key, value);
        previous = map.put(key, value);
        if (previous != null) {
            size -= safeSizeOf(key, previous);
        }
    }

    if (previous != null) {
        //evicted 为 true，表明不是为了腾出空间而进行的删除操作
        entryRemoved(false, key, previous, value);
    }

    trimToSize(maxSize);
    return previous;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;删除&quot;&gt;删除&lt;/h3&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * 删除 key 对应的条目
 *
 * 返回 key 对应的 value值
 */
public final V remove(K key) {
    if (key == null) {
        throw new NullPointerException(&quot;key == null&quot;);
    }

    V previous;
    synchronized (this) {
        previous = map.remove(key);
        if (previous != null) {
            size -= safeSizeOf(key, previous);
        }
    }

    if (previous != null) {
        entryRemoved(false, key, previous, null);
    }

    return previous;
}

/**
 * 当条目需要被移除或删除时调用
 * 当一个值被移除以腾出空间，通过调用 remove 删除，或者被 put 调用替换值时，会调用此方法。默认实现什么也不做
 *
 * 这个方法在被调用的时候没有添加额外的同步操作，因此其他线程可能在这个方法执行时访问缓存
 *
 * @param evicted true 表明条目正在被删除以腾出空间，false 表明删除是由 put 或 remove 引起的（并非是为了腾出空间）
 *
 * @param newValue key 的新值。如果非 null，则此删除是由 put 引起的。否则它是由 remove引起的
 */
protected void entryRemoved(boolean evicted, K key, V oldValue, V newValue) {}&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 01 Jan 2019 06:23:00 +0000</pubDate>
<dc:creator>zxzhang</dc:creator>
<og:description>以下针对 Android API 26 版本的源码进行分析。 在了解 之前，最好对 有初步的了解， 的实现主要借助 。`LinkedHashMap`的源码解析，可阅读</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZhaoxiCheung/p/Android-LruCache-Source-Analysis.html</dc:identifier>
</item>
<item>
<title>JDK源码分析系列-ArrayList - 老码畜</title>
<link>http://www.cnblogs.com/laomachu/p/10204727.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laomachu/p/10204727.html</guid>
<description>&lt;div readability=&quot;69&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;span&gt; 将指定元素e加入到elementData数组中
&lt;span&gt;public &lt;span&gt;boolean&lt;span&gt; add(E e) {
    &lt;span&gt;//&lt;span&gt; 检查是否需要扩容，如果需要则执行扩容操作
    ensureCapacityInternal(size + 1);  &lt;span&gt;//&lt;span&gt; Increments modCount!!
    &lt;span&gt;//&lt;span&gt; 将新元素赋值给底层数组对应的size++的位置
    elementData[size++] =&lt;span&gt; e;
    &lt;span&gt;return &lt;span&gt;true&lt;span&gt;;
}

&lt;span&gt;//&lt;span&gt; 将指定元素添加至指定索引的位置，
&lt;span&gt;//&lt;span&gt; 1. index位置元素及其后所有有效元素（使用size计算）进行复制并从index+1处进行粘贴; 
&lt;span&gt;//&lt;span&gt; 2. 将element设置为index位置的元素；
&lt;span&gt;public &lt;span&gt;void add(&lt;span&gt;int&lt;span&gt; index, E element) {
    &lt;span&gt;//&lt;span&gt; 检查index位置是否越界
&lt;span&gt;    rangeCheckForAdd(index);
    &lt;span&gt;//&lt;span&gt; 检查是否需要扩容，如果需要则执行扩容操作
    ensureCapacityInternal(size + 1);&lt;span&gt;&lt;span&gt;
    &lt;span&gt;//&lt;span&gt; 完成元素的拷贝移动, 如：
    &lt;span&gt;//&lt;span&gt; elementData = [A, B, C, null, null, null, null, null, null, null]
    &lt;span&gt;//&lt;span&gt; add(1, D)
    &lt;span&gt;//&lt;span&gt; elementData = [A, B, B, C, null, null, null, null, null, null]
    System.arraycopy(elementData, index, elementData, index + 1, size -&lt;span&gt; index);
    &lt;span&gt;//&lt;span&gt; 将新元素赋值给底层数组对应的索引位置 elementData = [A, D, B, C, null, null, null, null, null, null]
    elementData[index] =&lt;span&gt; element;
    &lt;span&gt;//&lt;span&gt; 有效元素size+1
    size++&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;span&gt; 删除首次匹配到的指定元素
&lt;span&gt;public &lt;span&gt;boolean&lt;span&gt; remove(Object o) {
    &lt;span&gt;//&lt;span&gt; 如果删除的元素是null，则不能使用equal判断，故此处进行分支逻辑处理
    &lt;span&gt;if (o == &lt;span&gt;null&lt;span&gt;) {
        &lt;span&gt;for (&lt;span&gt;int index = 0; index &amp;lt; size; index++&lt;span&gt;)
            &lt;span&gt;if (elementData[index] == &lt;span&gt;null&lt;span&gt;) {
                fastRemove(index);
                &lt;span&gt;return &lt;span&gt;true&lt;span&gt;;
            }
    } &lt;span&gt;else&lt;span&gt; {
        &lt;span&gt;for (&lt;span&gt;int index = 0; index &amp;lt; size; index++&lt;span&gt;)
            &lt;span&gt;//&lt;span&gt; 使用equals判断对象内容是否相等
            &lt;span&gt;if&lt;span&gt; (o.equals(elementData[index])) {
                fastRemove(index);
                &lt;span&gt;return &lt;span&gt;true&lt;span&gt;;
            }
    }
    &lt;span&gt;return &lt;span&gt;false&lt;span&gt;;
}

&lt;span&gt;//&lt;span&gt; 删除指定索引位置的元素
&lt;span&gt;public E remove(&lt;span&gt;int&lt;span&gt; index) {
    &lt;span&gt;//&lt;span&gt; 检查参数索引值是否越界
&lt;span&gt;    rangeCheck(index);
    &lt;span&gt;//&lt;span&gt; 修改次数自增
    modCount++&lt;span&gt;;
    &lt;span&gt;//&lt;span&gt; 获取要删除的元素
    E oldValue =&lt;span&gt; elementData(index);
    &lt;span&gt;//&lt;span&gt; 从index+1处开始复制并在index处进行粘贴
    &lt;span&gt;//&lt;span&gt; 如： elementData=[A, B, C, D]
    &lt;span&gt;//&lt;span&gt; 删除index=1位置的元素B，调用arrayCopy方法后, elementData=[A, C, D, D]
    &lt;span&gt;//&lt;span&gt; 赋值最后一个元素为null，等待gc回收，则 elementData=[A, C, D, null]
    &lt;span&gt;int numMoved = size - index - 1&lt;span&gt;;
    &lt;span&gt;if (numMoved &amp;gt; 0&lt;span&gt;)
        System.arraycopy(elementData, index+1&lt;span&gt;, elementData, index, numMoved);
    &lt;span&gt;//&lt;span&gt; size自减，将最后一个元素赋值为null，用于gc该多余元素
    elementData[--size] = &lt;span&gt;null; &lt;span&gt;//&lt;span&gt; clear to let GC do its work
    &lt;span&gt;//&lt;span&gt; 返回被删除元素的引用
    &lt;span&gt;return&lt;span&gt; oldValue;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;div readability=&quot;68&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;span&gt; 内部动态扩容实现
&lt;span&gt;//&lt;span&gt; minCapacity为最小容量，即容纳有效元素所需的容量，add操作时minCapacity为size + 1/numNew
&lt;span&gt;private &lt;span&gt;void ensureCapacityInternal(&lt;span&gt;int&lt;span&gt; minCapacity) {
    &lt;span&gt;//&lt;span&gt; 首次add，底层数据为空数组，则minCapacity为10
    &lt;span&gt;if (elementData ==&lt;span&gt; EMPTY_ELEMENTDATA) {
        minCapacity =&lt;span&gt; Math.max(DEFAULT_CAPACITY, minCapacity);
    }
    &lt;span&gt;//&lt;span&gt; 确认精确的新容量
&lt;span&gt;    ensureExplicitCapacity(minCapacity);
}

&lt;span&gt;private &lt;span&gt;void ensureExplicitCapacity(&lt;span&gt;int&lt;span&gt; minCapacity) {
    modCount++&lt;span&gt;;
    &lt;span&gt;//&lt;span&gt; 如果所需的容量大于当前实际容量，则进行扩容
    &lt;span&gt;if (minCapacity - elementData.length &amp;gt; 0&lt;span&gt;)
        grow(minCapacity);
}

&lt;span&gt;private &lt;span&gt;void grow(&lt;span&gt;int&lt;span&gt; minCapacity) {
    &lt;span&gt;//&lt;span&gt; 当前实际容量
    &lt;span&gt;int oldCapacity =&lt;span&gt; elementData.length;
    &lt;span&gt;//&lt;span&gt; 计算新容量，实际容量 * 1.5，1.5为时间与空间的权衡，扩容太大，则浪费空间，扩容太小，则发生频繁扩容，则耗费性能
    &lt;span&gt;int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1&lt;span&gt;);
    &lt;span&gt;//&lt;span&gt; 新的容量比所需的容量小，即：现有容量扩容1.5倍后仍然不够，则使用所需容量进行扩容，当首次添加元素时，新容量为0，所需容量为10，则新容量为10
    &lt;span&gt;if (newCapacity - minCapacity &amp;lt; 0&lt;span&gt;)
        newCapacity =&lt;span&gt; minCapacity;
    &lt;span&gt;//&lt;span&gt; 如果新容量大于最大容量，则触发hugeCapacity操作 
    &lt;span&gt;//&lt;span&gt; MAX_ARRAY_SIZE为Integer.MAX_VALUE - 8, -8为防止内存溢出，见源码MAX_ARRAY_SIZE常量注释
    &lt;span&gt;if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0&lt;span&gt;)
        newCapacity =&lt;span&gt; hugeCapacity(minCapacity);
    &lt;span&gt;//&lt;span&gt; 数组复制，根据新容量大小，进行扩容
    elementData =&lt;span&gt; Arrays.copyOf(elementData, newCapacity);
}

&lt;span&gt;//&lt;span&gt; java.util.Arrays中的copyOf实现
&lt;span&gt;//&lt;span&gt; 如：original = [0, 1, 2, ...., 9 ] 当前容量oldCapacity=10， 新容量newCapacity=10*1.5=15，则
&lt;span&gt;//&lt;span&gt; 1、创建一个容量为15的新数组copy， elementData = [null, null, null, ...., null]
&lt;span&gt;//&lt;span&gt; 2、将原数组original元素复制到新数组copy中，返回新数组 copy = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, null, null, null, null]
&lt;span&gt;public &lt;span&gt;static &amp;lt;T,U&amp;gt; T[] copyOf(U[] original, &lt;span&gt;int newLength, Class&amp;lt;? &lt;span&gt;extends T[]&amp;gt;&lt;span&gt; newType) {
       &lt;span&gt;//&lt;span&gt; 开辟新数组，大小为newCapacity
       T[] copy = ((Object)newType == (Object)Object[].&lt;span&gt;class&lt;span&gt;)
           ? (T[]) &lt;span&gt;new&lt;span&gt; Object[newLength]
           : (T[]) Array.newInstance(newType.getComponentType(), newLength);
        &lt;span&gt;//&lt;span&gt; 将已有数组original元素复制到新数组copy中
       System.arraycopy(original, 0, copy, 0&lt;span&gt;,
                        Math.min(original.length, newLength));
       &lt;span&gt;return&lt;span&gt; copy;
}

&lt;span&gt;/**&lt;span&gt;
* 有些虚拟机数组对象中存在8个字节的对象头，所以此处-8目的为减少OOM的可能性
* 如果超过了MAX_ARRAY_SIZE，那么扩容至Integer.MAX_VALUE
&lt;span&gt;*/
&lt;span&gt;private &lt;span&gt;static &lt;span&gt;final &lt;span&gt;int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8&lt;span&gt;;

&lt;span&gt;private &lt;span&gt;static &lt;span&gt;int hugeCapacity(&lt;span&gt;int&lt;span&gt; minCapacity) {
    &lt;span&gt;if (minCapacity &amp;lt; 0) &lt;span&gt;//&lt;span&gt; overflow
        &lt;span&gt;throw &lt;span&gt;new&lt;span&gt; OutOfMemoryError();
    &lt;span&gt;//&lt;span&gt; 最大扩容Integer.MAX_VALUE，即：整数上限值
    &lt;span&gt;return (minCapacity &amp;gt; MAX_ARRAY_SIZE) ?&lt;span&gt;
        Integer.MAX_VALUE :
        MAX_ARRAY_SIZE;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;span&gt;虽然ArrayList实现了Serializable接口， 但elementData为瞬态的，作者不希望使用默认的序列化方法对elementData进行序列化。原因为elementData包含占位元素，直接序列化后会导致序列化后的内容比较大，浪费空间及序列化的效率，所以ArrayList中重写writeObjec和readObject方法，writeObjec实现了对elementData中有效元素进行序列化的过程，readObject为反序列化过程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;&lt;span&gt;序列化：ObjectOutputStream.&lt;span&gt;defaultWriteObject序列化非 transient内容 -&amp;gt; ArrayList的writeObject序列化transient的elementData。参考 ObjectOutputStream。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;&lt;div readability=&quot;27.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;private &lt;span&gt;void&lt;span&gt; writeObject(java.io.ObjectOutputStream s)
    &lt;span&gt;throws&lt;span&gt; java.io.IOException{
    &lt;span&gt;//&lt;span&gt; Write out element count, and any hidden stuff
    &lt;span&gt;int expectedModCount =&lt;span&gt; modCount;
    &lt;span&gt;//&lt;span&gt; 序列化非瞬态内容
&lt;span&gt;    s.defaultWriteObject();

    &lt;span&gt;//&lt;span&gt; Write out size as capacity for behavioural compatibility with clone()
    &lt;span&gt;//&lt;span&gt; 序列化实际大小size
&lt;span&gt;    s.writeInt(size);
    &lt;span&gt;//&lt;span&gt; 按size序列化底层数组元素
    &lt;span&gt;//&lt;span&gt; Write out all elements in the proper order.
    &lt;span&gt;for (&lt;span&gt;int i=0; i&amp;lt;size; i++&lt;span&gt;) {
        s.writeObject(elementData[i]);
    }

    &lt;span&gt;if (modCount !=&lt;span&gt; expectedModCount) {
        &lt;span&gt;throw &lt;span&gt;new&lt;span&gt; ConcurrentModificationException();
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Vector的源码实现与ArrayList继承关系一致，底层均基于数组实现且初始默认长度均为10，实现方式基本相同，所以这里不再另起文章进行源码分析，这里对Vector与ArrayList的区别进行梳理：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;1、Vector是线程安全，而ArrayList是非线程安全的；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Vector类中的关键方法使用了Synchronized进行修饰，多线程同步执行，保障安全性，自然也牺牲了性能。&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;43&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public &lt;span&gt;synchronized &lt;span&gt;boolean&lt;span&gt; add(E e) {
    modCount++&lt;span&gt;;
    ensureCapacityHelper(elementCount + 1&lt;span&gt;);
    elementData[elementCount++] =&lt;span&gt; e;
    &lt;span&gt;return &lt;span&gt;true&lt;span&gt;;
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;2、Vector允许自定义指定扩容增长因子，默认扩容增量100%，ArrayList扩容增量固定为50%；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public&lt;span&gt; Vector() {
    &lt;span&gt;this(10&lt;span&gt;);
}
&lt;span&gt;public Vector(&lt;span&gt;int&lt;span&gt; initialCapacity) {
    &lt;span&gt;this(initialCapacity, 0&lt;span&gt;);
}
&lt;span&gt;public Vector(&lt;span&gt;int initialCapacity, &lt;span&gt;int&lt;span&gt; capacityIncrement) {
    &lt;span&gt;super&lt;span&gt;();
    &lt;span&gt;if (initialCapacity &amp;lt; 0&lt;span&gt;)
        &lt;span&gt;throw &lt;span&gt;new IllegalArgumentException(&quot;Illegal Capacity: &quot;+&lt;span&gt;
                                           initialCapacity);
    &lt;span&gt;this.elementData = &lt;span&gt;new&lt;span&gt; Object[initialCapacity];
    &lt;span&gt;this.capacityIncrement =&lt;span&gt; capacityIncrement;
}
&lt;span&gt;public Vector(Collection&amp;lt;? &lt;span&gt;extends E&amp;gt;&lt;span&gt; c) {
    elementData =&lt;span&gt; c.toArray();
    elementCount =&lt;span&gt; elementData.length;
    &lt;span&gt;//&lt;span&gt; c.toArray might (incorrectly) not return Object[] (see 6260652)
    &lt;span&gt;if (elementData.getClass() != Object[].&lt;span&gt;class&lt;span&gt;)
        elementData = Arrays.copyOf(elementData, elementCount, Object[].&lt;span&gt;class&lt;span&gt;);
}
&lt;span&gt;private &lt;span&gt;void grow(&lt;span&gt;int&lt;span&gt; minCapacity) {
    &lt;span&gt;//&lt;span&gt; overflow-conscious code
    &lt;span&gt;int oldCapacity =&lt;span&gt; elementData.length;
    &lt;span&gt;int newCapacity = oldCapacity + ((capacityIncrement &amp;gt; 0) ?&lt;span&gt; capacityIncrement : oldCapacity);
    &lt;span&gt;if (newCapacity - minCapacity &amp;lt; 0&lt;span&gt;)
        newCapacity =&lt;span&gt; minCapacity;
    &lt;span&gt;if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0&lt;span&gt;)
        newCapacity =&lt;span&gt; hugeCapacity(minCapacity);
    elementData =&lt;span&gt; Arrays.copyOf(elementData, newCapacity);
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3、Vector的底层数组不是瞬态的且序列化只重写了writeObject方法；&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;span&gt; 未使用transient修饰
&lt;span&gt;protected&lt;span&gt; Object[] elementData;

&lt;span&gt;//&lt;span&gt; 重写writeObject方法与ArrayList不同
&lt;span&gt;private &lt;span&gt;void writeObject(java.io.ObjectOutputStream s) &lt;span&gt;throws&lt;span&gt; java.io.IOException {
    &lt;span&gt;//&lt;span&gt; 获取缓冲中的持久化字段对象
    &lt;span&gt;final java.io.ObjectOutputStream.PutField fields =&lt;span&gt; s.putFields();
    &lt;span&gt;final&lt;span&gt; Object[] data;
    &lt;span&gt;//&lt;span&gt; 同步将capacityIncrement、elementCount添加至持久化字段对象中
  &lt;span&gt;//&lt;span&gt;复制底层数组
    &lt;span&gt;synchronized (&lt;span&gt;this&lt;span&gt;) {
        fields.put(&quot;capacityIncrement&quot;&lt;span&gt;, capacityIncrement);
        fields.put(&quot;elementCount&quot;&lt;span&gt;, elementCount);
        data =&lt;span&gt; elementData.clone();
    }
    &lt;span&gt;//&lt;span&gt; 将复制后的底层数组添加至持久化字段对象中
    fields.put(&quot;elementData&quot;&lt;span&gt;, data);
    &lt;span&gt;//&lt;span&gt; 将持久化字段对象写入流
&lt;span&gt;    s.writeFields();
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;4、Vector具有一些特有的方法&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;public &lt;span&gt;synchronized&lt;span&gt; E firstElement() { ... }
&lt;span&gt;public &lt;span&gt;synchronized&lt;span&gt; E lastElement() { ... }
&lt;span&gt;public &lt;span&gt;synchronized &lt;span&gt;void removeElementAt(&lt;span&gt;int&lt;span&gt; index) { ... }
&lt;span&gt;public &lt;span&gt;synchronized &lt;span&gt;void insertElementAt(E obj, &lt;span&gt;int&lt;span&gt; index) { ... }
&lt;span&gt;public &lt;span&gt;synchronized &lt;span&gt;void&lt;span&gt; addElement(E obj) { ... }
.......&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;Iterator（迭代器）：容器类通过实现Iterable接口来定义获取迭代器对象的方法，通过实现Iterator接口来定义一个迭代器。通过迭代器对象，使访问容器的代码逻辑从容器实现代码中剥离，使用者只需要通过迭代器的操作即可对容器进行遍历，无需了解容器的内部结构，消除了容器由于内部结构不同而导致遍历方式的差异，即迭代器模式的思想。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;fail-fast（快速失败）&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;对于非并发容器当使用迭代器遍历时，当前线程或另一个线程通过调用容器的方法如add/remove等改变了容器结构，那么容器在迭代过程中会抛出ConcurrentModificationException运行时异常而终止后续迭代过程的机制。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;下面通过ArrayList的源码来分析Iterator和fail-fast，ArrayList集成AbstractList抽象类，AbstractList继承AbstractCollection抽象类并实现了该抽象类的iterator方法：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;20.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;span&gt; 操作计数
&lt;span&gt;protected &lt;span&gt;transient &lt;span&gt;int modCount = 0&lt;span&gt;;
&lt;span&gt;//&lt;span&gt; 获取一个迭代器对象
&lt;span&gt;public Iterator&amp;lt;E&amp;gt;&lt;span&gt; iterator() {
    &lt;span&gt;return &lt;span&gt;new&lt;span&gt; Itr();
}
&lt;span&gt;//&lt;span&gt;迭代器类，AbstractList抽象类中的私有内部类，实现了Iterator接口
&lt;span&gt;private &lt;span&gt;class Itr &lt;span&gt;implements Iterator&amp;lt;E&amp;gt;&lt;span&gt; {
    &lt;span&gt;//&lt;span&gt; 下一个元素的索引
    &lt;span&gt;int cursor = 0&lt;span&gt;;
    &lt;span&gt;//&lt;span&gt; 上一个元素的索引，当调用remove方法时重置为-1
    &lt;span&gt;int lastRet = -1&lt;span&gt;;
    &lt;span&gt;//&lt;span&gt; 迭代器实例化时将期待的modCount值初始化为当前的modCount值，用于快速失败检查
    &lt;span&gt;int expectedModCount =&lt;span&gt; modCount;
    &lt;span&gt;//&lt;span&gt; 判断是否存在下一个元素
    &lt;span&gt;public &lt;span&gt;boolean&lt;span&gt; hasNext() {
        &lt;span&gt;//&lt;span&gt; 下一个元素的索引不等于总的底层数组长度，则说明还有下一个元素
        &lt;span&gt;return cursor !=&lt;span&gt; size();
    }
    &lt;span&gt;//&lt;span&gt; 获取下一个元素
    &lt;span&gt;public&lt;span&gt; E next() {
        &lt;span&gt;//&lt;span&gt; 检查底层数组结构是否发生修改，即判断迭代器初始化时备份的expectedModCount的值和当前的modCount是否相等
        &lt;span&gt;//&lt;span&gt; 不等，则抛出ConcurrentModificationException
&lt;span&gt;        checkForComodification();
        &lt;span&gt;try&lt;span&gt; {
            &lt;span&gt;//&lt;span&gt; 将当前下一个元素的索引赋值给i
            &lt;span&gt;int i =&lt;span&gt; cursor;
            &lt;span&gt;//&lt;span&gt; 获取下一个元素
            E next =&lt;span&gt; get(i);
            &lt;span&gt;//&lt;span&gt; 将当前下一个元素索引作为上一个元素索引
            lastRet =&lt;span&gt; i;
            &lt;span&gt;//&lt;span&gt; 重置cursor指向新的next索引
            cursor = i + 1&lt;span&gt;;
            &lt;span&gt;//&lt;span&gt; 返回next对象
            &lt;span&gt;return&lt;span&gt; next;
        } &lt;span&gt;catch&lt;span&gt; (IndexOutOfBoundsException e) {
            &lt;span&gt;//&lt;span&gt; 如果数组越界则优先判断是否发生了并发修改，如果是优先抛出ConcurrentModificationException
&lt;span&gt;            checkForComodification();
            &lt;span&gt;//&lt;span&gt; 否则 抛出NoSuchElementException
            &lt;span&gt;throw &lt;span&gt;new&lt;span&gt; NoSuchElementException();
        }
    }
    
    &lt;span&gt;//&lt;span&gt; 迭代器对象的删除操作
    &lt;span&gt;public &lt;span&gt;void&lt;span&gt; remove() {
        &lt;span&gt;//&lt;span&gt; 迭代器对象未吊用过next()方法便调用remove方法的话，会抛出IllegalStateException
        &lt;span&gt;if (lastRet &amp;lt; 0&lt;span&gt;)
            &lt;span&gt;throw &lt;span&gt;new&lt;span&gt; IllegalStateException();
       
         &lt;span&gt;//&lt;span&gt; 并发修改异常判断
&lt;span&gt;        checkForComodification();
        
        &lt;span&gt;try&lt;span&gt; {
            &lt;span&gt;//&lt;span&gt; 根据索引删除元素
            AbstractList.&lt;span&gt;this&lt;span&gt;.remove(lastRet);
            &lt;span&gt;//&lt;span&gt; 下一元素索引减1
            &lt;span&gt;if (lastRet &amp;lt;&lt;span&gt; cursor)
                cursor--&lt;span&gt;;
            &lt;span&gt;//&lt;span&gt;重置上一元素/当前元素索引
            lastRet = -1&lt;span&gt;;
            &lt;span&gt;//&lt;span&gt; 更新 expectedModCount，所以单线程迭代过程中，通过迭代器对象的remove方法删除元素，不会导致并发修改异常
            expectedModCount =&lt;span&gt; modCount;
        } &lt;span&gt;catch&lt;span&gt; (IndexOutOfBoundsException e) {
            &lt;span&gt;throw &lt;span&gt;new&lt;span&gt; ConcurrentModificationException();
        }
    }
    &lt;span&gt;//&lt;span&gt; fail-fast检查
    &lt;span&gt;final &lt;span&gt;void&lt;span&gt; checkForComodification() {
        &lt;span&gt;if (modCount !=&lt;span&gt; expectedModCount)
            &lt;span&gt;throw &lt;span&gt;new&lt;span&gt; ConcurrentModificationException();
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;通过源码可以发现：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、迭代器调用next()方法时才会进行fail-fast检查；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、单线程场景，在迭代过程中通过调用容器对象自身的add/remove操作修改了modCount，那么在下次next()方法调用时会发生ConcurrentModificationException，所以可以使用迭代器对象自身的remove方法进行删除；&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;17.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;span&gt; 错误方式
List&amp;lt;String&amp;gt; list = &lt;span&gt;new ArrayList&amp;lt;&amp;gt;(3&lt;span&gt;);
list.add(&quot;a&quot;&lt;span&gt;);
list.add(&quot;b&quot;&lt;span&gt;);
list.add(&quot;c&quot;&lt;span&gt;);
Iterator&amp;lt;String&amp;gt; iterator =&lt;span&gt; list.iterator();
&lt;span&gt;while&lt;span&gt; (iterator.hasNext()) {
    &lt;span&gt;//&lt;span&gt; 第二次遍历时调用next()方法时，会抛出ConcurrentModificationException
&lt;span&gt;    iterator.next();
    list.remove(0&lt;span&gt;);
}

&lt;span&gt;//&lt;span&gt; 正确方式
&lt;span&gt;while&lt;span&gt; (iterator.hasNext()) {
   iterator.next();
   iterator.remove();
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;3、多线程场景，因为迭代器对象是线程私有的，也就是expectedModCount是线程私有的，线程一迭代遍历，线程二调用了迭代器的remove修改了容器对象的modCount，那么进行迭代遍历的线程一也会发生ConcurrentModificationException，所以可以使用CopyOnWriteArrayList容器，详见《CopyOnWriteArrayList源码分析》；&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;fail-safe(安全失败)&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;CopyOnWriteArrayList等JUC包下的容器都具有安全失败的特性，在迭代器初始化时快照容器内容，迭代遍历的是容器的内容的快照，所以其他线程对容器结构的修改不会被迭代器感知到，也就不会抛出ConcurrentModificationException。以CopyOnWriteArrayList源码为例：&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;8.5&quot;&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;//&lt;span&gt; 迭代器对象获取方法
&lt;span&gt;public Iterator&amp;lt;E&amp;gt;&lt;span&gt; iterator() {
    &lt;span&gt;//&lt;span&gt; 获取当前数组从索引为0的位置实例化一个迭代器对象
    &lt;span&gt;return &lt;span&gt;new COWIterator&amp;lt;E&amp;gt;(getArray(), 0&lt;span&gt;);
}

&lt;span&gt;private &lt;span&gt;static &lt;span&gt;class COWIterator&amp;lt;E&amp;gt; &lt;span&gt;implements ListIterator&amp;lt;E&amp;gt;&lt;span&gt; {
    &lt;span&gt;//&lt;span&gt; 迭代器内部对原数组的引用进行了快照（浅拷贝），final修饰，构造函数中初始化，迭代器遍历操作针对该快照完成
    &lt;span&gt;private &lt;span&gt;final&lt;span&gt; Object[] snapshot;
    &lt;span&gt;/**&lt;span&gt; Index of element to be returned by subsequent call to next.  &lt;span&gt;*/
    &lt;span&gt;private &lt;span&gt;int&lt;span&gt; cursor;

    &lt;span&gt;private COWIterator(Object[] elements, &lt;span&gt;int&lt;span&gt; initialCursor) {
        cursor =&lt;span&gt; initialCursor;
        snapshot =&lt;span&gt; elements;
    }
    
    .....
    
    &lt;span&gt;//&lt;span&gt; 该迭代器与ArrayList不同，不支持remove方法
    &lt;span&gt;public &lt;span&gt;void&lt;span&gt; remove() {
        &lt;span&gt;throw &lt;span&gt;new&lt;span&gt; UnsupportedOperationException();
    }
    &lt;span&gt;//&lt;span&gt; 不支持通过迭代器进行set
    &lt;span&gt;public &lt;span&gt;void&lt;span&gt; set(E e) {
        &lt;span&gt;throw &lt;span&gt;new&lt;span&gt; UnsupportedOperationException();
    }
    &lt;span&gt;//&lt;span&gt; 不支持通过迭代器进行add
    &lt;span&gt;public &lt;span&gt;void&lt;span&gt; add(E e) {
        &lt;span&gt;throw &lt;span&gt;new&lt;span&gt; UnsupportedOperationException();
    }
}&lt;span&gt; &lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Tue, 01 Jan 2019 06:15:00 +0000</pubDate>
<dc:creator>老码畜</dc:creator>
<og:description>1、ArrayList本质 数组 + 动态扩容实现的数据列表。 初始为空数组，故每次添加元素时进行扩容判断，首次添加，默认初始化大小为10，见下文扩容内容。 private static f</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/laomachu/p/10204727.html</dc:identifier>
</item>
<item>
<title>学习字典才联想到要和 JSP 说再见了 - 余同学的开发之路</title>
<link>http://www.cnblogs.com/YJK923/p/10199165.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/YJK923/p/10199165.html</guid>
<description>&lt;p&gt;最开始只是想让页面能够映射出我的字典值，然而却发现了更大的问题。&lt;/p&gt;

&lt;p&gt;假如你自己做一个 demo ，需要前台页面映射出字典数据你会怎么做呢？大致的思路应该是有的，准备字典，准备数据，然后将两部分进行映射。&lt;/p&gt;

&lt;p&gt;在做的过程中，我也在思考，该如何保存字典数据呢？有一种比较简单的方法，这种方法也很是巧妙，使用一个工具类，使用枚举法来保存字典值。在该类中还可以加载配置文件。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
import java.io.IOException;
import java.util.Properties;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class Keys {

    private final static Logger logger = LoggerFactory.getLogger(BaseDictUtil.class);

    public static String project_name;

    // 加载配置文件 
    static {
        logger.info(&quot;======= Start load Properties =====&quot;);
        Properties webapp_prop = new Properties();
        try {
            webapp_prop.load(BaseDictUtil.class.getResource(&quot;/webapp.properties&quot;).openStream());
            project_name = webapp_prop.getProperty(&quot;webapp_project_name&quot;);

            logger.info(&quot;======= End load Properties =====&quot;);   
        } catch (IOException e) {
            logger.error(e.getMessage(), e);
        }
    }

    // 配置性别字典
    public enum Gender {
        Gender_1(&quot;男生&quot;, 1), Gender_2(&quot;女生&quot;, 2);

        public static String getName(int index) {
            for (Gender c : Gender.values()) {
                if (c.getIndex() == index) {
                    return c.name;
                }
            }
            return null;
        }

        private Gender(String name, int index) {
            this.name = name;
            this.index = index;
        }

        private String name;

        private int index;

        public String getName() {
            return name;
        }

        public void setName(String name) {
            this.name = name;
        }

        public int getIndex() {
            return index;
        }

        public void setIndex(int index) {
            this.index = index;
        }
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面这种方式，在字典很少的情况下，用起来方便快捷，但是有个问题很明显，若是需要新添加一个字典还要改动代码，很是麻烦。&lt;/p&gt;

&lt;p&gt;下面看一下另外一种方式，也是用的比较多的一种，这种方法就需要使用数据库了，把字典统一保存保存在一张表中，当项目启动的时候加载到一个 Map 中。&lt;/p&gt;

&lt;p&gt;Map 中的值有一定的规律，map 的就 key 怎么定义看你自己，一般是将字典先分组再取对应关系。比方说城市组的代号是 city，在 city 下的 001 代表的是北京。那 Map 的结构可以是 city 为主键 value 是一个子 Map。子 Map 中存放的就是城市编号和具体城市的映射。&lt;/p&gt;

&lt;p&gt;我在网上看到另一种分组的，拿过来和大家分享一下。一条 dict 记录可以分为哪个表下的哪个字段什么值，表示的什么值，对应到数据库和 Map 中我们可以这样设计。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1453063/201812/1453063-20181230131944834-1312924192.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;而 Map 中的 key 为 tableName_fieldName_fieldValue 值为 field_detail 。同样的在这里我们可以加载配置文件到 Map 中，这里可以选择加载一些系统级的配置。&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:java;gutter:true;&quot;&gt;
public class BaseDictUtil {

    @Autowired
    private static BaseDictDao dicDao;

    private static HashMap&amp;lt;String, String&amp;gt; hashMap = new HashMap&amp;lt;&amp;gt;();

    private final static Logger logger = LoggerFactory.getLogger(BaseDictUtil.class);

    // 静态方法在程序启动的时候只加载一次，这样为了让查询方法只去数据库查询一次
    static {
        // 获取应用上下文对象
        @SuppressWarnings(&quot;resource&quot;)
        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext-dao.xml&quot;);
        // 获取dicDao实例
        dicDao = ctx.getBean(BaseDictDao.class);
        queryDic();
    }

    // 加载配置文件
    static {
        logger.info(&quot;======= Start load Properties =====&quot;);
        Properties webapp_prop = new Properties();
        Properties base_prop = new Properties();
        try {
            webapp_prop.load(BaseDictUtil.class.getResource(&quot;/webapp.properties&quot;).openStream());
            hashMap.put(&quot;webapp_project_name&quot;, webapp_prop.getProperty(&quot;webapp_project_name&quot;));

            base_prop.load(BaseDictUtil.class.getResource(&quot;/base_dict.properties&quot;).openStream());
            hashMap.put(&quot;base_dict.dict_type_code.001&quot;, base_prop.getProperty(&quot;base_dict.dict_type_code.001&quot;));

            logger.info(&quot;======= End load Properties =====&quot;);   
        } catch (IOException e) {
            logger.error(e.getMessage(), e);
        }
    }


    // 从数据库中取值放入到HashMap中
    public static void queryDic() {
        List&amp;lt;BaseDict&amp;gt; dics = dicDao.selectAll();
        for (int i = 0; i &amp;lt; dics.size(); i++) {
            BaseDict dic = dics.get(i);
            String tableName = dic.getTable_name();
            String fieldName = dic.getField_name();
            String fieldValue = dic.getField_value();
            String key = tableName + &quot;_&quot; + fieldName + &quot;_&quot; + fieldValue;
            String value = dic.getField_detail();
            logger.info(key + &quot; ---&amp;gt; &quot; + value);
            hashMap.put(key, value);
        }
    }

    public static String getFieldDetail(String tableName, String fieldName, String fieldValue) {
        StringBuilder sb = new StringBuilder();
        StringBuilder keySb = sb.append(tableName).append(&quot;_&quot;).append(fieldName).append(&quot;_&quot;).append(fieldValue);
        String key = keySb.toString();
        String value = hashMap.get(key);
        return value;
    }

    public static String getProperties(String key) {
        return hashMap.get(key);
    }

    public static void main(String[] args) {
        String detail = BaseDictUtil.getFieldDetail(&quot;customer&quot;, &quot;cust_level&quot;, &quot;2&quot;);
        System.out.println(detail);

        System.out.println(getProperties(&quot;webapp_project_name&quot;));
    }
}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;到上面为止，我们已经把字典处理好了，获取实体中的数据很简单，但是现在来了一个问题，我们该如何将两者结合起来，是先在后台处理好数据传到前台还是分别传到前台再由前台处理映射关系呢？&lt;/p&gt;

&lt;p&gt;这个问题可真的难为我了，有一个很蠢的办法，获取实体数据的时候我们一条一条的映射，最终返回给前台处理好的结果。可作为一个后台工程师，这不是我想的，然而，处理前台我功力又不行。唉&lt;/p&gt;

&lt;p&gt;功能的事到此就结束了，后面主要想谈谈关于前后端分离的事，之前前后台不分家，后端工程师是又当爹又当妈。既要处理数据又要处理页面，很恶心。&lt;/p&gt;

&lt;p&gt;但是曙光来了，现在提倡前后台分离，作为后端工程师的我来说，那真的是高兴呀。随之而来的就是 JSP 页面被抛弃了，改用 HTML + JS 或是前段框架 + JS 。&lt;/p&gt;

&lt;p&gt;为什么要抛弃 JSP 呢 ？&lt;/p&gt;
&lt;p&gt;1、数据和静态资源都放在一起，各种请求 CSS、JS、图片的请求会增加服务器的压力。&lt;/p&gt;

&lt;p&gt;2、JSP 必须要在支持Java 的 web 容器中运行（类如 tomcat），无法使用 nginx。&lt;/p&gt;

&lt;p&gt;3、第一次请求 JSP 必须在 web 容器中将 JSP 转化为 Servlet，所以首次访问比较慢。&lt;/p&gt;

&lt;p&gt;4、JSP 页面中内容比较杂，有 html、各种标签、JS ，给前端看前端头疼，给后端看后端头疼，不易分工。&lt;/p&gt;

&lt;p&gt;5、如果 JSP 中的内容很多，页面响应会很慢，因为是同步加载。&lt;/p&gt;

&lt;p&gt;以前开发步骤是这样&lt;/p&gt;
&lt;p&gt;1、客户端发出请求。&lt;br/&gt;2、服务端的 Servlet 或 Controller 接收请求（路由规则由后端制定，整个项目开发的权重大部分在后端）。&lt;br/&gt;3、调用 service、dao 代码完成业务逻辑。&lt;br/&gt;4、返回 JSP。&lt;br/&gt;5、JSP 展现一些动态的代码。&lt;/p&gt;

&lt;p&gt;前后端分离之后是这样&lt;/p&gt;
&lt;p&gt;1、浏览器发送请求。&lt;br/&gt;2、直接到达 html 页面（路由规则由前端制定，整个项目开发的权重前移）。&lt;br/&gt;3、html 页面负责调用服务端接口产生数据（通过 ajax 等等）。&lt;br/&gt;4、填充 html，展现动态效果。&lt;/p&gt;

&lt;p&gt;而前后端更多的是采用 JSON 来进行数据交互，通过 ajax 来异步加载数据，所以一个项目不管数据量多么复杂，都可以轻松的访问，不像以前那样通过一个请求一股脑的把所有的数据都返回。&lt;/p&gt;

&lt;p&gt;说了这么多前后端分离的好，然，我自己写的 demo 并没有前台来照顾，不说了，默默的搬砖去了……&lt;/p&gt;
</description>
<pubDate>Tue, 01 Jan 2019 05:51:00 +0000</pubDate>
<dc:creator>余同学的开发之路</dc:creator>
<og:description>最开始只是想让页面能够映射出我的字典值，然而却发现了更大的问题。 假如你自己做一个 demo ，需要前台页面映射出字典数据你会怎么做呢？大致的思路应该是有的，准备字典，准备数据，然后将两部分进行映射。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/YJK923/p/10199165.html</dc:identifier>
</item>
<item>
<title>2018年终总结（二）得和失 - 虚生</title>
<link>http://www.cnblogs.com/dylancao/p/10204647.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dylancao/p/10204647.html</guid>
<description>&lt;p&gt;　　2018年，可以说是我职业生涯中最丰富的一年，今年，比过去几年的经历的总和还要丰富。2018，经历了全国范围内的面试，从北京到深圳，从上海到杭州，都留下了我的足迹。2018，经历了人生不同角色的转换，创业公司的技术合伙人，成熟公司的技术顾问，还有一个以外包身份给公司打工。这些经历，或多或少的都在我身上留下一些印记，在2018将要结束的以后，是要好好总结一下。这些经历告诉了我什么？从这些经历中，我得到了什么？又失去了什么呢？&lt;br/&gt;　　今年，汲取了上次没有好好找工作就匆忙作出选择的教训，想要离职的时候，去找了很多公司面试，经历了本领域大大小小很多公司，从和这些公司的面试官打交道的过程中，我学习到了很多很多，也意识到了自己很多方面的不足，原来，很多公司只是想找一个低成本的干活的，他们所有冠冕堂皇的理由背后只有一条是真的--就是物美价廉。当你知道了客户这个隐形需求的时候，很多东西都变得释然了。把找一份工作当成自己事业的是非常不明智的选择，对你一个职场人来说，能提升技能和经验才是最值得的选择。在人才市场中，不要因为被拒绝而妄自菲薄，因为很多面试官都没有搞清楚他需要什么样子的人，很多情况下，他只需要一个熟练操作工，或者只是和你聊的投机，而不会考虑给你一个实现理想的地方。人家给你offer很多时候也不是因为你比较牛逼，很多时候，公司仅仅需要一个低成本一点的打工仔而已。你的资历和以前的待遇，很多时候是顶不过一个成本优势。在这个严酷的职场中，你的成本和优势是时刻在变换，时刻保持战斗力和快速学习的能力，才能把生活过的好一些。&lt;br/&gt;　　从这些面试和交流中，我也意识到了自己某些方面的严重不足，比如，英语，由于自己没有在外企待过，也没有国外留学的经历，导致自己的英语水平实在堪忧，这样的结果是错过了几个理想的去处，没能抓住这些机会成为国际化的人才。接下来的的2019，英语不好的这个问题要好好想一下办法，也把英语水平提升上去。还有一个比较大的问题就是计算机基础知识，由于不是科班出身，半路出家学的计算机，知识不成体系，并且很多方面缺乏理论素养，这些问题在和高手过招的时候，就暴露了很多不足。在未来的一年中，也要加强这方面的训练。&lt;br/&gt;　　假如只是在一个公司中不停的coding，是很难意识到的自身的这些不足的。这些找工作的经历让我清醒了很多，让我清楚的看到了自己的价值和不足。&lt;br/&gt;　　·在后面的创业中，我也学习到了很多和以前不一样的东西，这些会是我人生中很大的财富。&lt;br/&gt;　　一个就是勇于尝试，翻译成英文就是just try。在自己面对未知的航道时，这个简直太重要了，以前在公司，都是有人指点或者一起讨论，很多情况下，能找到人告诉你怎么做，可是，在创业的时候，有太多的未知的东西需要你尝试后才能确定是否适合你，或者是是否是对的，创业的时间紧迫不会给你太多的犹豫时间，所以，面对很多困难，勇于尝试简直是太重要了，很多问题都是在尝试后才有更深的感悟，更进一步的前进的。在年底的时候，just try已经成为我的口头禅了，在不断尝试的过程中，我不断的积累相关的经验。成长也是飞速的。&lt;br/&gt;　　一个是乐观面对未知。以前，当有搞不定的问题时，我总是有点焦虑，问题搞不定怎么办呢？在经历了无数次问题无法解决后，我就突然释然了。在创业的路上，最大的确定就是不确定。最大的问题就是没有问题。当理解到问题是生活的常态时，突然就不再焦虑了。我来就是为了解决问题的，没有问题个人的价值就不存在了。平静的去面对和解决遇到的各种问题，这些问题不会因你的着急而变得容易的，很多时候，问题只会随着你凌乱的心绪而变得更加复杂，所以说，当面对的问题多了，你就会多一分坦然。看来悲观的人还是经历太少，等经历多了，就会多一分坦然和淡定。乐观面对未知，这是我在2018的经历中认识到的一个可以改变心态的东西。&lt;br/&gt;　　一个是量力而行。在2018年结束的时候，生活给我开了一个玩笑，自己最赚钱的一个项目失败了，本来靠着这个现金牛，三年之内把其它业务做起来的，这样的话，新项目的风险可以降低到最低。天有不测风云，同时展开的项目太多，时间点又没有把控好，在几个项目都在最紧要的节点出现了分神乏术。导致了现金牛项目的破产。在事后我一直思考，什么原因导致了现在结局？思来想去，最重要的原因就是太高估了自己，以为自己是斗战胜佛，能同时搞定很多项目，把很多古人的言传身教抛到了身后，才落到如此的下场。在接下来的2019，这个是要牢记于心的，千万不能再犯类似的错误，一个时间段不能超过两件事。切记切记，处事有何定凭，但求此心过得去；立业无论大小，总要此身做得来。老祖宗的话还是要听的。&lt;br/&gt;　　2018，在得失中，就这样走完了。今年暴露的问题和弱点，在2019好好去修补吧。人总是在经历中不断的成长，总之，在这个2018的年份，有太多的成长值得我欣慰。&lt;br/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 01 Jan 2019 05:37:00 +0000</pubDate>
<dc:creator>虚生</dc:creator>
<og:description>2018年，可以说是我职业生涯中最丰富的一年，今年，比过去几年的经历的总和还要丰富。2018，经历了全国范围内的面试，从北京到深圳，从上海到杭州，都留下了我的足迹。2018，经历了人生不同角色的转换，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dylancao/p/10204647.html</dc:identifier>
</item>
<item>
<title>surging 微服务引擎 1.0 正式发布 - fanly11</title>
<link>http://www.cnblogs.com/fanliang11/p/10204636.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/fanliang11/p/10204636.html</guid>
<description>&lt;p&gt;surging &lt;span class=&quot;flex-auto mb-2&quot;&gt;&lt;span class=&quot;text-gray-dark mr-2&quot;&gt;是一个分布式微服务引擎,提供高性能RPC远程服务调用，服务引擎支持http、TCP、WS、Mqtt协议,采用Zookeeper、Consul作为surging服务的注册中心，集成了哈希一致性，随机，轮询、压力最小优先作为负载均衡的算法，底层协议集成采用的组件是dotnetty、&lt;span&gt;&lt;span&gt;&lt;span&gt;websocket-sharp&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;、&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;Kestrel&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;。支持通过docker hub 部署服务引擎，也可以通过nuget 引用组件的方式自定义服务引擎。&lt;/p&gt;
&lt;p&gt;surging 已完成了生成环境的稳定部署,支持超过千台机器服务的水平扩展，可以支持超过1000个的serviceroutes部署，可以支持单台30000个物联网设备，平均单次访问性能可以达到0.11ms(机器的不同，所验证的结果不同，升级.netcore 2.2 使用分层编译性能会更高)&lt;/p&gt;
&lt;p&gt;以上数据是通过本人测试，还有一些是通过别人的提供的数据获得。基本上数据都是来自于8核16G的服务器，下面我们来看看如何从各个渠道去构建surging 服务引擎&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;构建服务引擎&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;一、通过开源源码进行构建&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;有部分人员通过引用源码进行开发，可能是这样更容易调试，或者是实时同步surging， surging 是MIT协议，可以随便捣鼓，开源地址如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/dotnetcore/surging&quot; target=&quot;_blank&quot;&gt;https://github.com/dotnetcore/surging&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;二、通过docker hub 进行构建部署&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;首先如果是自定义服务引擎，可以把镜像引擎上传到docker hub 镜像库，然后可以根据镜像库做服务编排，以下是所有上传的surging 镜像&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201901/192878-20190101131024461-1674730957.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;也可以通过以下方式获取官方的服务引擎&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;通过以下命令进行构建&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;docker pull serviceengine/surging:v1.0&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;通过以下命令进行运行&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;container&quot; readability=&quot;12&quot;&gt;
&lt;p&gt;&lt;code class=&quot;csharp preprocessor&quot;&gt;#docker run --name surgingserver_v1.0 --env Mapping_ip=192.168.249.162 --env Mapping_Port=198 --env RootPath=/home/fanly --env&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;csharp plain&quot;&gt;Register_Conn=192.168.249.162:8500 --env EventBusConnection=172.17.0.4 --env Surging_Server_IP=0.0.0.0 -v /home/fanly:/home/fanly -it -p 198:198 serviceengine/surging:v1.0&lt;br/&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如下图所示&lt;/p&gt;
&lt;div class=&quot;line number2 index1 alt1&quot; readability=&quot;7&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201901/192878-20190101130359415-1728491737.png&quot; alt=&quot;&quot;/&gt;&lt;h3&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;三、通过nuget 进行构建部署&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;

可以通过nuget 包安装相关组件，如下图

&lt;/div&gt;
&lt;div class=&quot;line number2 index1 alt1&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201901/192878-20190101130737659-1090363606.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;

&lt;div class=&quot;line number2 index1 alt1&quot; readability=&quot;7.5&quot;&gt;
&lt;h2&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;四、通过rancher 进行管理和服务编排&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;如下图所示&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201901/192878-20190101131803308-1265046640.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div readability=&quot;10&quot;&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/192878/201901/192878-20190101132000385-1058014558.png&quot; alt=&quot;&quot;/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;未来展望&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对于surging迄今为止所取得的进展感到非常兴奋，有部分已经使用surging用在了生产环境，并且对于surging的性能非常满意，对于surging未来的规划是维护现有的组件，并且扩展其它常用的协议，比如RTP、RTSP、RTMP ，还有就是做管理中心，包括了发布管理，配置管理，监控中心，异常通知，组件应用中心等功能，这里也感谢大家对于surging 的贡献与支持，也期待大家共同一起完善surging ，一起支持.net core 的生态。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

</description>
<pubDate>Tue, 01 Jan 2019 05:36:00 +0000</pubDate>
<dc:creator>fanly11</dc:creator>
<og:description>surging 是一个分布式微服务引擎,提供高性能RPC远程服务调用，服务引擎支持http、TCP、WS、Mqtt协议,采用Zookeeper、Consul作为surging服务的注册中心，集成了哈希</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/fanliang11/p/10204636.html</dc:identifier>
</item>
<item>
<title>python装饰器2：进阶 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10204617.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10204617.html</guid>
<description>&lt;p&gt;本文是装饰器相关内容的第二篇，接上一篇&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/10198247.html&quot;&gt;python函数装饰器详解&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;函数装饰器装饰方法&quot;&gt;函数装饰器装饰方法&lt;/h2&gt;
&lt;p&gt;函数装饰器装饰普通函数已经很容易理解了：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@decorator
def func():...

#等价于
def func():...
func = decorator(func)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果装饰器是带参装饰器，那么等价的形式大概是这样的(和装饰器的编码有关，但最普遍的编码形式如下)：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@decorator(x, y, z)
def func():...

# 等价于
def func():...
func = decorator(x, y, z)(func)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的函数装饰器也可以去装饰类中的方法。看下面的方法装饰形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class cls:
    @decorator
    def method(self,arg1,arg2):
        ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class cls:
    def method(self,arg1,arg2):
        ...
    method = decorator(method)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在decorator的编码中，仍然像普通的函数装饰器一样编写即可。例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def decorator(F):
    @wraps(F)
    def wrapper(*args, **kwargs):
        ...    # args[0] = self_instance
               # args[1]开始才是手动传给method的参数
    return wrapper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但必须要考虑到method的第一个参数self，所以包装器wrapper()的第一个参数也是self。&lt;/p&gt;
&lt;p&gt;如此一来，函数装饰器既可以装饰函数，又可以装饰方法。&lt;/p&gt;
&lt;p&gt;下面是一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from functools import wraps

def decorator(F):
    @wraps(F)
    def wrapper(*args, **kwargs):
        result = F(*args, **kwargs)
        print(args)
        return result
    return wrapper

@decorator
def func(x,y):
    return x + y

print(func(3, 4))

print(&quot;-&quot; * 30)

class cls:
    @decorator
    def method(self, x, y):
        return x + y

c = cls()
print(c.method(3, 4))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(3, 4)
7
------------------------------
(&amp;lt;__main__.cls object at 0x01DF1C50&amp;gt;, 3, 4)
7&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;让类称为装饰器&quot;&gt;让类称为装饰器&lt;/h2&gt;
&lt;p&gt;不仅函数可以作为装饰器，类也可以作为装饰器去装饰其它对象。&lt;/p&gt;
&lt;h3 id=&quot;如何让类作为装饰器&quot;&gt;如何让类作为装饰器&lt;/h3&gt;
&lt;p&gt;要让类作为装饰器，先看装饰的形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Decorator:
    ...

@Decorator
def func():
    ...

func(arg1, arg2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果成功装饰，那么它等价于：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def func(): ...
func = Decorator(func)

func(arg1, arg2)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这和函数装饰器看上去是一样的，但区别在于Decorator这里是一个类，而不是函数，且&lt;code&gt;Decorator(func)&lt;/code&gt;表示的是创建一个Decorator类的实例对象，所以这里赋值符号左边的func是一个对象。所有后面的&lt;code&gt;func(arg1, arg2)&lt;/code&gt;是调用对象，而不是调用函数。&lt;/p&gt;
&lt;p&gt;要让实例对象成为可调用对象，它必须实现&lt;code&gt;__call__&lt;/code&gt;方法，所以应该在Decorator类中定义一个&lt;code&gt;__call__&lt;/code&gt;。而且每次调用实例对象的时候，都是在调用&lt;code&gt;__call__&lt;/code&gt;，这里的&lt;code&gt;__call__&lt;/code&gt;对等于函数装饰器中的包装器&lt;code&gt;wrapper&lt;/code&gt;，所以它的参数和逻辑应当和wrapper一样。&lt;/p&gt;
&lt;p&gt;如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Decorator():
    def __call__(self, *args, **kwargs):
        ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看&lt;code&gt;func = Decorator(func)&lt;/code&gt;，func是Decorator类创建实例的参数，所以Decorator类还必须实现一个&lt;code&gt;__init__&lt;/code&gt;方法，接受func作为参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Decorator:
    def __init__(self, func):
        ...
    def __call__(self, *args, **kwargs):
        ...&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;元数据问题&quot;&gt;元数据问题&lt;/h3&gt;
&lt;p&gt;这样的装饰器已经能正常工作了，但是会丢失func的元数据信息。所以，必须使用functools的wraps()保留func的元数据：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;from functools import wraps

class Decorator:
    def __init__(self, func):
        wraps(func)(self)
        ...
    def __call__(self, *args, **kwargs):
        ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么是&lt;code&gt;wraps(func)(self)&lt;/code&gt;？这里显然不能&lt;code&gt;@wraps(func)&lt;/code&gt;的方式装饰包装器，所以只能使用wraps()的原始函数形式。在wraps()装饰函数包装器wrapper的时候，&lt;code&gt;@wraps(func)&lt;/code&gt;等价于&lt;code&gt;wrapper = wraps(func)(wrapper)&lt;/code&gt;，所以这里&lt;code&gt;wraps(func)(self)&lt;/code&gt;的作用也是很明显的：保留func的元数据，并装饰self。被装饰的self是什么？是Decorator的实例对象，因为Decorator类实现了&lt;code&gt;__call__&lt;/code&gt;，所以self是可调用的，所以这里的self类似于函数装饰器返回的wrapper函数(实际上self是Decorator(func)返回的各个实例对象)。&lt;/p&gt;
&lt;h3 id=&quot;类作为装饰器的参数问题&quot;&gt;类作为装饰器的参数问题&lt;/h3&gt;
&lt;p&gt;虽然self是Decorator的可调用实例对象，但是上面的代码中self并不具有func属性，也就是说无法从self去调用func()函数，这似乎使得整个过程都崩塌了：废了老大的劲去解决各种装饰器上的问题，结果却不能调用被装饰的函数。&lt;/p&gt;
&lt;p&gt;有两种方式可以解决这个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在&lt;code&gt;__init__&lt;/code&gt;中使用&lt;code&gt;self.func = func&lt;/code&gt;保留func对象作为装饰器的一个属性&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;在使用wraps()后直接在包装器&lt;code&gt;__call__&lt;/code&gt;中使用&lt;code&gt;__wrapped__&lt;/code&gt;调用原始func函数&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这两种方式其实是等价的，因为&lt;code&gt;self.func&lt;/code&gt;和&lt;code&gt;__wrapped__&lt;/code&gt;都指向原始的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def __init__(self,func):
    wraps(func)(self)
    self.func = func
def __call__(self, *args, **kwargs):
    result = self.func(*args, **kwargs)

#-------------------------------

def __init__(self, func):
    wraps(func)(self)
def __call__(self, *args, **kwargs):
    result = self.__wrapped__(*args, **kwargs)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但这两种方式都有缺陷，缺陷在于装饰类中方法时。(注：在装饰普通函数、类方法的时候，上面的方式不会出错)&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class cls:
    @decorator
    def method(self, x, y):...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为&lt;code&gt;self.func&lt;/code&gt;和&lt;code&gt;__wrapped__&lt;/code&gt;装饰cls中的方法时指向的都是cls的类变量(只不过这个属性是装饰器类decorator的实例对象而已)，作为类变量，它无法保存cls的实例对象，也就是说&lt;code&gt;method(self, x, y)&lt;/code&gt;的self对装饰器是不可见的。&lt;/p&gt;
&lt;p&gt;用一个示例解释更容易：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import types
from functools import wraps

# 作为装饰器的类
class decorator:
    def __init__(self,func):
        self.func = func
    def __call__(self, *args, **kwargs):
        print(&quot;(1): &quot;,self)      # (1)
        print(&quot;(2): &quot;,self.func) # (2)
        print(&quot;(3): &quot;,args)      # (3)
        return self.func(*args, **kwargs)

class cls:
    @decorator
    def method(self, x, y):
        return x + y

c = cls()
print(&quot;(4): &quot;,c.method)      # (4)
print(c.method(3, 4))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(4):  &amp;lt;__main__.decorator object at 0x03261630&amp;gt;
(1):  &amp;lt;__main__.decorator object at 0x03261630&amp;gt;
(2):  &amp;lt;function cls.method at 0x032C2738&amp;gt;
(3):  (3, 4)
Traceback (most recent call last):  File &quot;g:/pycode/scope.py&quot;, line 21, in &amp;lt;module&amp;gt;
    print(c.method(3, 4))
  File &quot;g:/pycode/scope.py&quot;, line 12, in __call__    return self.func(*args, **kwargs)
TypeError: method() missing 1 required positionalargument: 'y'&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意观察上面&lt;code&gt;__call__&lt;/code&gt;中输出的几个对象：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;self对应的是decorator的实例对象method，而非cls的实例对象c，看输出结果的前两行即可知&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;self.func指向的是原始方法method，它是类变量，是类方法(函数)，是装饰器赋予它作为函数的。也就是说，self.func指向的不是对象方法，而是类方法，类方法不会自动传递实例对象&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;args中保存的参数列表是(3, 4)，但是cls.method中多了一个self位置参数，使得3赋值给了self，4被赋值给了x，y成了多余的，所以最后报错需要位置参数y。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果将上面的method()的定义修改一下，把self去掉，将会正确执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class cls:
    @decorator
    def method(x, y):
        return x + y&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;执行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(4):  &amp;lt;__main__.decorator object at 0x03151630&amp;gt;
(1):  &amp;lt;__main__.decorator object at 0x03151630&amp;gt;
(2):  &amp;lt;function cls.method at 0x031B2738&amp;gt;
(3):  (3, 4)
7&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因此参数问题必须解决。解决方案是进行判断：如果是通过实例对象触发的方法调用(即c.method())，就将外部函数通过&lt;code&gt;types.MethodType()&lt;/code&gt;链接到这个实例对象中，否则就返回原始self(因为它指向被装饰的原始对象)。&lt;/p&gt;
&lt;p&gt;这需要借助描述符来实现，关于这一段的解释，我觉得直接看代码自行脑部更佳。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class decorator:
    def __init__(self,func):
        wraps(func)(self)
        self.func = func
    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs)
    def __get__(self, instance, owner):
        # 如果不是通过对象来调用的
        if instance is None:
            return self
        else:
            return types.MethodType(self, instance)

class cls:
    @decorator
    def method(self, x, y):
        return x + y

c = cls()
print(c.method(3, 4))  # 调用__get__后调用__call__&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;__wrapped__&lt;/code&gt;也一样可行：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class decorator():
    def __init__(self, func):
        wraps(func)(self)
    def __call__(self, *args, **kwargs):
        return self.__wrapped__(*args, **kwargs)
    def __get__(self, instance, owner):
        if instance is None:
            return self
        else:
            return types.MethodType(self, instance)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;装饰时是否带参数&quot;&gt;装饰时是否带参数&lt;/h2&gt;
&lt;p&gt;如果要让作为装饰器的类在装饰时带参数，就像函数装饰器带参一样&lt;code&gt;decorator(x,y,z)(func)&lt;/code&gt;，可以将参数定义在&lt;code&gt;__init__&lt;/code&gt;上进行处理，然后在&lt;code&gt;__call__&lt;/code&gt;中封装一层。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class Decorator:
    def __init__(self, *args, **kwargs):
        ... do something with args ...
    def __call__(self, func):
        def wrapper(*args, **kwargs):
            return func(*args, **kwargs)
        return wrapper&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和函数装饰器一样，如果想要达到下面这种既能无参装饰，又能带参装饰：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;@Decorator         # 无参装饰
@Decorator(x,y,z)  # 带参装饰
@Decorator()       # 带参装饰，只不过没给参数&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以直接在&lt;code&gt;__init__&lt;/code&gt;上进行参数有无的判断：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import types
from functools import wraps, partial

class Decorator:
    def __init__(self, func=None, arg1=1, arg2=2, arg3=3):
        # 带参装饰器
        if func is None:
            self.func = partial(Decorator, arg1=arg1, arg2=arg2, arg3=arg3)
        else:       # 无参装饰器
            wraps(func)(self)
            self.func = func

    def __call__(self, *args, **kwargs):
        return self.func(*args, **kwargs)

    def __get__(self, instance, owner):
        if instance is None:
            return self
        else:
            return types.MethodType(self, instance)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样的限制是装饰器如果带参数时，必须使用keyword方式指定参数。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 带参装饰普通函数，使用keywords参数方式
@Decorator(arg1=1, arg2=3, arg3=5)
def func(x, y):
    return x + y

print(func(11, 22))

print('-' * 30)

# 无参装饰普通函数
@Decorator
def func1(x, y):
    return x + y

print(func1(111, 22))

print('-' * 30)

# 无参装饰方法
class cls:
    @Decorator
    def method(self, x, y):
        return x + y

c = cls()
print(c.method(3, 4))

print('-' * 30)

# 带参装饰方法
class cls1:
    @Decorator(arg1=1, arg2=3, arg3=5)
    def method(self, x, y):
        return x + y

cc = cls1()
print(cc.method(3, 4))&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结类作为装饰器的通用格式&quot;&gt;总结：类作为装饰器的通用格式&lt;/h2&gt;
&lt;p&gt;如果不考虑装饰时是否带参数的问题，根据上面的一大堆分析，类作为装饰器时的通用代码格式如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;import types
from functools import wraps

class Decorator:
    def __init__(self, func):
        wraps(func)(self)
        # self.func = func

    def __call__(self, *args, **kwargs):
        # return self.func(*args, **kwargs)
        # return self.__wrapped__(*args, **kwargs)

    def __get__(self, instance, owner):
        if instance is None:
            return self
        else:
            return types.MethodType(self, instance)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于选择&lt;code&gt;self.func&lt;/code&gt;的方式，还是&lt;code&gt;self.__wrapped__&lt;/code&gt;的方式，随意。&lt;/p&gt;
&lt;p&gt;如果需要考虑装饰时带参数问题，那么参考上一小节内容。&lt;/p&gt;
&lt;h2 id=&quot;选择类谁作为装饰器&quot;&gt;选择类谁作为装饰器？&lt;/h2&gt;
&lt;p&gt;函数可以作为装饰器，类也可以作为装饰器。它们也都能处理处理各种需求，但是类作为装饰器的时候解释了好大一堆，非常麻烦。所以，如果可以的话，选择函数作为装饰器一般会是最佳方案。&lt;/p&gt;
</description>
<pubDate>Tue, 01 Jan 2019 05:19:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>本文是装饰器相关内容的第二篇，接上一篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10204617.html</dc:identifier>
</item>
</channel>
</rss>