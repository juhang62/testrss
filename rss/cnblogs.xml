<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>如何在ASP.NET Core程序启动时运行异步任务（3） - LamondLu</title>
<link>http://www.cnblogs.com/lwqlun/p/10363803.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lwqlun/p/10363803.html</guid>
<description>&lt;blockquote readability=&quot;2.7222222222222&quot;&gt;
&lt;p&gt;原文：&lt;a href=&quot;https://andrewlock.net/running-async-tasks-on-app-startup-in-asp-net-core-part-3/&quot;&gt;Running async tasks on app startup in ASP.NET Core (Part 3)&lt;/a&gt;&lt;br/&gt;作者：Andrew Lock&lt;br/&gt;译者：Lamond Lu&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190212073139366-1114134850.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之前我写了两篇有关在ASP.NET Core中运行异步任务的博文，本篇博文是对之前两篇博文中演示示例和实现方法的简短跟进。&lt;/p&gt;
&lt;p&gt;你可以通过以下链接查看之前的博文。&lt;/p&gt;

&lt;p&gt;在之前博客中，我收到的最常见的反馈是关于我在描述问题时使用的例子。在我最初的博客中，我列举了3种可能场景，在这3种场景中，你希望在ASP.NET Core应用启动时运行一些异步任务。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查强类型配置是否合法&lt;/li&gt;
&lt;li&gt;使用数据库或者API填充缓存&lt;/li&gt;
&lt;li&gt;运行数据库迁移&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;对于前两种场景，没有任何问题，但是对于数据库迁移，一些博友提出了一些疑问。其实在两篇博文中我一直都反复说明，数据库迁移作为启动任务不是一个很好的方案，这里我只是想用它作为一个说明如何在ASP.NET Core程序启动时运行异步任务的例子。现在来看，当时使用这个例子是非常失败的。&lt;/p&gt;

&lt;p&gt;那么为什么在ASP.NET Core应用启动时，运行数据库迁移任务会是一个问题呢？毕竟，在应用程序开始处理请求之前，你肯定要完成数据库迁移！&lt;/p&gt;
&lt;p&gt;其实这里其实有3个问题：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;数据库迁移是应该是单线程的&lt;/li&gt;
&lt;li&gt;迁移数据库需要更多的权限&lt;/li&gt;
&lt;li&gt;开发人员不太喜欢直接运行数据库迁移&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们依次说明一下。&lt;/p&gt;
&lt;h2 id=&quot;数据库迁移应该是单线程的&quot;&gt;数据库迁移应该是单线程的&lt;/h2&gt;
&lt;p&gt;扩展一个Web应用最常用的方式之一是进行横向扩展，启动多个运行实例并使用负载均衡分发请求&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190212073148438-388345212.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种Web集群扩展的方案是非常有效的，特别是当当前应用是无状态的（请求被分发到各个应用程序中，如果一个应用程序崩溃，其他的Web应用实例依然可以处理请求）。&lt;/p&gt;
&lt;p&gt;但是不幸的是，如果尝试将数据库迁移作为应用启动任务，你很可能就会遇到问题。如果有超过1个以上的实例同时启动，多个数据库迁移任务将同时运行。&lt;/p&gt;
&lt;p&gt;虽然并不能保证你一定会遇到麻烦，但除非你非常小心地确保幂等更新和错误处理，否则你很可能会陷入困境。&lt;/p&gt;
&lt;p&gt;你肯定不希望使用这种方法，因为它可能产生的数据库完整性问题。 这里一个更好的选择是先启动单个实例完成迁移操作。 这样数据库迁移任务变成一个单线程任务，自然也就避开最严重的危险。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190212073203768-1053293361.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种方法比将数据库迁移作为启动任务运行更有意义，但它更安全，更容易实现。&lt;/p&gt;
&lt;p&gt;当然，这不是唯一的选择。 如果你对启动任务迁移的想法有所了解，那么你可以使用分布式锁来确保只有一个应用程序实例来运行迁移脚本。 然而，这并没有解决第二个问题......&lt;/p&gt;
&lt;h2 id=&quot;迁移通常需要更多的权限&quot;&gt;迁移通常需要更多的权限&lt;/h2&gt;
&lt;p&gt;通常来说，最佳实践是你必须限制你的应用程序，以便他们只有权访问和修改所需的资源。 如果报表应用只需要读取销售数据，那么它应该无法修改它们，或者更改数据库表结构！ 为指定的连接字符串配置可操作的权限，可以防止在的的应用出现安全问题时产生大量影响。&lt;/p&gt;
&lt;p&gt;如果你正在使用Web应用程序本身来运行数据库迁移，那么该Web应用程序自然需要数据库权限才能执行高风险活动，例如修改数据库表结构，更改权限或更新/删除数据。 你真的希望您的Web应用程序能够删除你的学生表吗？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/65831/201902/65831-20190212073216492-283373394.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;同样，你可以使用一些特定的实现，例如，与正常的数据库访问相比，使用不同的连接字符串进行迁移。 但是，如果使用外部迁移过程，你根本无法锁定Web应用程序进程。&lt;/p&gt;
&lt;h2 id=&quot;开发人员不习惯直接运行ef-core迁移&quot;&gt;开发人员不习惯直接运行EF Core迁移&lt;/h2&gt;
&lt;p&gt;这是一个不那么明显的观点，但是很多人表示在生产环境中使用EF Core迁移工具可能不是一个好主意。&lt;/p&gt;
&lt;p&gt;就个人而言，我已经有1年多没有在生产环境中使用EF Core迁移了，到目前为止迁移工具肯定已经有所改善。 话虽如此，我仍然看到一些问题：&lt;/p&gt;
&lt;p&gt;就我自己而言，我经常使用DbUp和FluentMigrator，而不会使用EF Core迁移。我发现它们都运行良好。&lt;/p&gt;
&lt;p&gt;因此，如果数据库迁移任务不适合应用启动任务示例，那么哪些任务才是比较适合的呢？&lt;/p&gt;

&lt;p&gt;虽然在之前的博文中我已经反复提到了一些例子，但我还是将在下面再次描述它们。这里其他博友还给我一些有趣的补充。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;检查强类型配置是否有效。ASP.NET Core 2.2引入了配置验证，但它只在首次访问&lt;code&gt;IOptions&lt;/code&gt; 类时执行此操作。 正如我在之前文章中所描述的那样，你可能希望在应用启动时进行验证，以确保你的环境和配置有效。&lt;/li&gt;
&lt;li&gt;填充缓存。 你的应用程序可能需要来自文件系统或远程服务的数据，它只需要加载一次，但加载需要耗费相当多的资源，所以在应用程序启动之前加载此数据可减少请求延迟。&lt;/li&gt;
&lt;li&gt;预连接到数据库和/或外部服务。 以类似的方式，你可以通过连接到数据库或其他外部服务来填充数据库连接池。 这些通常是相对昂贵的操作，因此是很好的用例。&lt;/li&gt;
&lt;li&gt;预编译加载应用中所有的单例服务。我认为这个一个非常有趣的想法，通过预加载依赖注入容器中注册的单例服务，你可以减少请求的响应时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我完全同意有关数据库迁移的反馈。 当这不是一个好主意时，将它们用作启动任务的示例有点误导，特别是因为我个人不使用我所描述的方法！&lt;/p&gt;
&lt;p&gt;然而，很多人都同意我所描述的另外一种方法 - 在启动Kestrel服务器和处理请求之前运行启动任务。&lt;/p&gt;
&lt;p&gt;这里Damian Hickey针对这个方案提出了一个问题，他建议尽快启动Kestrel服务器。 他建议在所有启动任务完成后，使用运行健康检查向负载均衡器发出信号，表明应用程序已准备好开始接收请求。 与此同时，所有非健康检查流量（如果负载均衡器正在执行此任务，则不应该有任何流量）将收到503服务不可用。&lt;/p&gt;
&lt;p&gt;这种方法的主要好处是它可以避免网络超时。 一般来说，应用程序最好能尽快的针对请求返回错误代码，而不是根本不响应请求，并导致客户端超时。 这减少了客户端所需的资源数量。 通过较早启动Kestrel服务器，应用程序可以更早地开始响应请求，即使响应是“未就绪”响应。&lt;/p&gt;
&lt;p&gt;这实际上与我在第一篇文章中描述的方法非常相似，但是我没有选用它了，因为它太复杂了，而且没有达到我设定的目标。 从技术上来说，在那篇文章中，我只是关注在Kestrel服务器启动之前运行任务的方法，健康检查方法不能完成这个功能。&lt;/p&gt;
&lt;p&gt;然而，Damian提出的问题让我再次思考。 在我下一篇博客中，我将描述如何使用ASP.NET Core 2.2的健康检查功能向负载均衡器发送信号，表明应用程序已经完成了所有启动任务。&lt;/p&gt;

&lt;p&gt;在这篇文章中，我分享了我之前关于在ASP.NET Core应用程序启动时运行异步任务的一些反馈。 这里最大的问题是我选择使用EF Core数据库迁移作为启动任务的示例。 数据库迁移不适合在应用程序启动时运行，因为它们通常需要由单个进程运行，并且需要比更多的数据库权限。&lt;/p&gt;
&lt;p&gt;我提供了一些比较适合作为的启动任务的场景，并且描述了Damian给出的建议 - 尽快启动Kestrel服务器，并使用运行状况检查来指示任务何时完成。 我将在下一篇文章中描述如何实现这一功能。&lt;/p&gt;
</description>
<pubDate>Mon, 11 Feb 2019 23:33:00 +0000</pubDate>
<dc:creator>LamondLu</dc:creator>
<og:description>原文： 'Running async tasks on app startup in ASP.NET Core (Part 3)' 作者：Andrew Lock 译者：Lamond Lu 之前我写了两</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lwqlun/p/10363803.html</dc:identifier>
</item>
<item>
<title>《组织行为学》--个体行为整理及个人感悟 - 超大的雪童子</title>
<link>http://www.cnblogs.com/yangsy0915/p/10363754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangsy0915/p/10363754.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;一、能力&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　人的能力各有长短，这是不争的事实。但是，个体能力的发展的不平衡未必就意味着孰优孰劣。人的能力是有差异的，应该善于根据人的能力特点去使用他们，尽量兼收并蓄。而不要有所弃有所取。要不拘一格地使用人才。&lt;/p&gt;
&lt;p&gt;　　那么从管理的角度出发，了解能力的个别差异，根本目的在于根据每个员工的能力特点安排给他们合适的工作，从而充分发挥人力资源。人能尽其才，才能尽其力。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（1）什么是能力？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　能力指的是一种心理素质，是顺利完成某种活动的心理条件。人的能力是各种各样的，通常可以分为一般能，特殊能力和创造力。一般能力是指在完成不同种类的活动中都表现出来的能力，如观察力、记忆力、抽象概括力、想象力、创造力等，其中抽象概括力是一般能力的核心，平时我们所说的智力，就是一般能力。特殊能力是指适用于某个特殊领域的能力。创造力是指，创造新概念、新事物、新产品的能力。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）智力的结构&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　美国心理学家瑟斯顿提出了基本心智能力构成的七个维度：&lt;/p&gt;
&lt;p&gt;　　　　1、语文理解，即理解语文含义的能力。&lt;/p&gt;
&lt;p&gt;　　　　2、语句流畅，能够迅速做出反应的语文能力。&lt;/p&gt;
&lt;p&gt;　　　　3、数字运算，能够迅速而正确地进行计算的能力。&lt;/p&gt;
&lt;p&gt;　　　　4、空间关系，方位辨别及空间关系判断能力。&lt;/p&gt;
&lt;p&gt;　　　　5、联想记忆，有关两个事物之间联系的机械记忆能力。&lt;/p&gt;
&lt;p&gt;　　　　6、知觉速度，能否凭视觉迅速辨别事物异同的能力。&lt;/p&gt;
&lt;p&gt;　　　　7、一般推理，能否根据经验做出归纳推理的能力。&lt;/p&gt;
&lt;p&gt;　　　　英国心理学家提出智力层次是按层次排列的。其中最高层次是普遍因素，即人的基本心理能量，是决定一个人智力高低的主要成分。第二层分为两大群，即言语和教育方面的因素、操作和机械方面的因素，叫大群因素。第三层为小群因素，包括言语理解、数量、教育机械信息、空间信息等内容。第四层次为特殊因素，即完成具体工作时需要的特殊技能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190212000133104-2087241228.jpg&quot; alt=&quot;&quot; width=&quot;712&quot; height=&quot;250&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（3）智力的测量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　概括来说，当工作中需要进行信息加工越多时，较高的总体智力水平和言语能力是成功完成此项工作的必要保证。然而，高智商并非是所有工作的前提条件。在很多工作中，员工的行为具有高度规范性，很少有机会使他们表现出差异。此时，高智商与工作绩效之间可以说相关性并不大，相反，一些非智力因素的影响更强烈。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（4）新兴的智力理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　美国心理学家加德纳提出智力多元论，认为智力应该包括：认知智力、社会智力、情绪智力和文化智力。&lt;/p&gt;
&lt;p&gt;　　　　认知智力指的是传统智力测验中一直关心的那部分潜能。&lt;/p&gt;
&lt;p&gt;　　　　社会智力指的是一个人与他人建立有效联系的能力。&lt;/p&gt;
&lt;p&gt;　　　　情绪智力是一种识别、理解和管理情绪的能力。&lt;/p&gt;
&lt;p&gt;　　　　文化智力则是对跨文化的差异具有敏感性，并能够在跨文化的情景中成功运作的能力。&lt;/p&gt;
&lt;p&gt;　　　　美国耶鲁大学教授斯滕伯格也提出智力的三元论：&lt;/p&gt;
&lt;p&gt;　　　　1、组合性智力：指个体在问题情境中，运用知识分析资料，经由思考、判断、推理以达到问题解决的能力。传统智力测验中测得的智商，代表的就是这副本智力。&lt;/p&gt;
&lt;p&gt;　　　　2、经验性智力：指个体运用已有经验处理新问题时，整合不同观念二形成的顿悟或创造力的能力。&lt;/p&gt;
&lt;p&gt;　　　　3、实用性智力：指个体在日常生活中，运用学得的知识经验以处理其日常事务的能力。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（5）特殊能力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　特殊能力指的是在某种专业活动中表现出来的能力，它是顺利完成专业活动的心理条件。例如：画家需要形象记忆力、色彩鉴别力、视觉想象力等；音乐家需要音质辨别力、音调记忆力以及节奏比较能力等。现代企业家需要决策能力、组织与计划能力、人际协调能力等。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（6）创造力及其测量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　一个具有创造力的人往往能超脱具体的知觉情景、思维定势、传统观念的束缚，在习以为常的事务和现象中发现新的联系。有关创造力与智力之间的关系，研究大致显示出这样一个趋势，创造力与智力之间存在某种程度的相关，但并无高相关。“对重要的创造行为来说”，个体必须达到某种智慧的阈限--要具备最低限度的智力水平。&lt;/p&gt;
&lt;p&gt;　　　　那么吉尔福特对创造力进行了较为系统的研究，认为可以通过思维的流畅性、变通性和独特性三方面来衡量创造力的高低。&lt;/p&gt;
&lt;p&gt;　　　　1、流畅性：指的是单位时间内产生多种反应的数量。高创造力的人，能在短时间内相处数量较多的项目，即反应迅速而且出众。&lt;/p&gt;
&lt;p&gt;　　　　2、变通性：指的是做出不同反应的范围或维度。范围越大、维度越多，说明变通性越强。变通性强的人，在解决问题时能触类旁通，举一反三，不拘泥于现有的常规模式。&lt;/p&gt;
&lt;p&gt;　　　　3、独特性：指的是能对问题提出超乎寻常的、角度独特的见解，不受已有观念的束缚和限制。对于创造力的测验，不强调对现成只是的记忆与理解，更强调独特和异乎寻常。&lt;/p&gt;
&lt;p&gt;　　（7）能力--工作的匹配&lt;/p&gt;
&lt;p&gt;　　　　当能力与工作彼此匹配时，员工的工作绩效水平就会提高。当员工的能力远远超过工作要求而造成能力与工作要求不匹配时，也会出现问题，它会降低员工的工作满意度。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二、人格&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;（1）什么是人格？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　心理学家使用人格这一概念来描述个体整个心理系统的形成和发展，这个独特的整合系统是个体区别于其他人的稳定而统一的心理品质的综合。特点如下：&lt;/p&gt;
&lt;p&gt;　　　　1、独特性：一个人的人格是在遗传、环境、教育等先天及后天因素的交互作用下形成的。&lt;/p&gt;
&lt;p&gt;　　　　2、稳定性：偶然发生的心里特性不能称为人格。强调人格的稳定性也并不意味着它在人的一生中是一成不变的，随着生理的成熟和环境的改变，人格也可能发生或多或少的变化。&lt;/p&gt;
&lt;p&gt;　　　　3、综合性：人格是由多种成分构成的一个有机整体，具有内在的一致性，受自我意识的调节和控制。&lt;/p&gt;
&lt;p&gt;　　　　4、功能性：人格决定了一个人的生活方式，甚至决定一个人的命运，因而是人生成百的根源之一。当面对挫折和失败时，坚强者能奋发图强，懦弱者一句不振。这就是人格功能性的表现。&lt;/p&gt;
&lt;p&gt;　　　　那么人格是如何形成的？现代学者普遍认为，人格是由遗传和环境两方面因素构成的，同时还受到情景条件的调节。人格特点受到环境的一姑娘，它包括我们成长的文化背景，早年的生活条件，家庭，朋友和社会群体的规范等等。这些环境因素对于人格的塑造起着十分重要的作用。&lt;/p&gt;
&lt;p&gt;　　　　同时，还有情景，个体的人格虽然从总体来说是稳定持久的，但在不同情境下根据需要而有所改变。例如，同是一个外向健谈的人，在参加招聘面试和在咖啡馆里与好友聊天，他的谈话方式、行为特点将会表现出极大差异。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）卡特尔的人格特质理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　人格是一个复杂的心理结构系统，其中包括多种持久而稳定的人格特质。这些特质是人类共有的，但是特质的数量和组合因人而异，因而导致人格方面的个体差异。采用因素分析的做法，最终确定了16种稳定而持久的人格因素，称之为人格的主要特质或根源特质。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190212004032722-766077751.jpg&quot; alt=&quot;&quot; width=&quot;780&quot; height=&quot;427&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（3）大五模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　有五项人格维度构成了所有人格因素的基础，并包括了人格当中的大多数明显变异：&lt;/p&gt;
&lt;p&gt;　　　　1、外倾性：该维度描述的是个体对关系的舒适感程度。外倾性喜欢群居、善于言谈、具有决断性。内倾者倾向于封闭内向、胆小害羞、安静少语。&lt;/p&gt;
&lt;p&gt;　　　　2、随和性：该维度描述的是个体服从他人的倾向性。随和性较高的人更为合作、激情和信赖他人；随和性较低的人则是冷淡的、敌对的和不受欢迎的。&lt;/p&gt;
&lt;p&gt;　　　　3、责任心：该维度是对信誉的测量。高度责任心的人是负责的，有条不紊的、值得信赖的、持之以恒的。在该维度上得分低的人容易精力分散、缺乏规划性、且不可信赖。&lt;/p&gt;
&lt;p&gt;　　　　4、情绪稳定性：该维度刻画的是个体承受压力的能力，积极的情绪是平和、自信、安全的；消极的情绪稳定性者是紧张、焦虑、失望和缺乏安全感的。&lt;/p&gt;
&lt;p&gt;　　　　5、经验开放性：该维度针对于个体在新奇方面的兴趣和热衷程度。开放性非常高的人富有创造性、凡事好奇、具有艺术的敏感性；开放性维度非常低的人很保守，对熟悉的事务感到舒适和满足。&lt;/p&gt;
&lt;p&gt;　　　　不少研究表明，大五人格维度与工作绩效之间有着重要的关系。工作绩效使用三个指标进行界定：绩效评估，培训效果，以及人事资料。对于各行各业的人员来说，责任感这一维度都可以预测其工作绩效。“占绝对优势的证据表明”，哪些可以新来的、细致周到的、做事有条不紊的、勤奋刻苦的、持之以恒的、成就取向的个体，在绝大多数职业当中，回去的更高的工作业绩。在责任意识上得分较高的个体，也会在工作相关知识方面水平更高，这可能是由于高责任感的人会在工作中付出更多的努力。二较高的工作知识水平，又会带来较高的工作绩效水平。&lt;/p&gt;
&lt;p&gt;　　　　大五中其他人各维度的预测力，取决于绩效标准和职业群两项因素。比如，外倾性可以预测管理和销售岗位的工作绩效。同时，经验开放性对于培训效果的预测也非常重要，这一点也合乎逻辑的，在这一方面比较意外的研究结果是：情绪稳定性与工作绩效无明显相关，凭直觉人们都认为，平和而有安全感的人应该比焦虑不安的人工作干得更好。一些研究者表明，可能只有那些在情绪稳定性方面得分相对较高的人们才会保住自己的工作，而研究样本均选择的是在职受聘员工，因此，他们之间的差异非常小。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（4）麦尔斯--布瑞格斯类型指标（MBTI）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　可以说是目前使用最广泛的人格测验之一。MBTI在四个维度上对他进行区分：外向的或内向的（E或I）、领悟的或直觉的（S或N）、思维的或情感的（T或F）、感知的或判断的（P或J）。&lt;/p&gt;
&lt;p&gt;　　　　INTJ型是幻想者，他们有创造性思维，并有强大的内驱力实现自己的想法和目标，他们的特点是怀疑、批判、独立、决断，甚至常常有些顽固。&lt;/p&gt;
&lt;p&gt;　　　　ESTJ型人是组织者，他们现实、理性、果断、实事求是，具有从事商业和机械工作的天生头脑，擅长组织和操控活动。&lt;/p&gt;
&lt;p&gt;　　　　ENTP型则为抽象思考者，他们喜欢革新、特立独行、多才多艺、对创业想法感兴趣。这种人在解决挑战性任务方面资源丰富，但在处理常规工作方面则较为消极。&lt;/p&gt;
&lt;p&gt;　　　　但目前对该测验的信度和效度尚缺乏有力的证据，因此，对这一量表的使用应采取审慎的态度。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;三、与组织行为有关的人格特点&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　他们分别是：控制点、权术注意、自尊、自我监控、冒险倾向、A型人格和B型人格&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（1）控制点&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　我们把个体对于自己是否掌握命运的认知，称之为控制点。一些人认为自己是命运的主人，一些人认为自己受命运的操控。前者认为自己可以控制命运，我们称之为内控型，后者认为自己被外界的力量所左右，我们称之为外控型。&lt;/p&gt;
&lt;p&gt;　　　　大量内控和外控的比较研究一致表明，外控型人相比内控型人对工作更不满意、缺勤率更高、对工作环境更为书院，对工作卷入程度更低。另外，外控型人采取主动行动的可能性更低。&lt;/p&gt;
&lt;p&gt;　　　　内控者在决策之前积极搜寻信息，对获得成功又更强烈的动机，更倾向于控制自己的环境。因此，内控这在复杂的工作中做的更好，包括绝大多数管理需要进行复杂的信息加工和学习活动。内控者也适于从事要求创造性和独立性的工作活动。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）权术主义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　为了达到目的，可以不择手段，这是高权术主义者一贯的思想准则。更喜欢操控和控制别人，赢得利益更多，更难被别人说服，却更多地说服别人。当然，这些结果也受到情景因素的调节。高权术主义者会是好员工吗？答案取决于他们从事的工作类型，以及在评估绩效时是否考虑其道德内涵。对于需要谈判技能的工作和成功能带来实质效益的工作，高权术主义者会十分出色，但行为需要有绝对的规范标准。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（3）自尊&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　人们喜爱或不喜爱自己的程度各有不同，这一特质成为自尊。自尊心强的人相信自己拥有工作成功所必需的大多数能力。另外，自尊心强的人在工作选择上会更冒险，更可能选择那些非传统性的工作。从管理的角度来看，自尊心弱的人更关注取悦他人，他们很少站在不受欢迎的立场上。人们还发现自尊与工作满意度之间存在正相关，大量研究证实自尊心强者比自尊心弱者对他们的工作更为满意。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（4）自我监控&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　指的是个体根据外部情景因素调整自己行为的能力。高自我监控者更善于根据外部环境的因素来调整自己的行为。他们对环境线索十分敏感，能根据不同情境采取不同行为，并能够使公开的角色与私人的自我之间表现出极大差异。低自我监控者则很难通过这种方式伪装自己，他们倾向于在各种情境下都表现出自己的真实情景和态度。&lt;/p&gt;
&lt;p&gt;　　　　高自我监控者比低自我监控者更关注他人的活动，行为更符合习俗。另外，高自我监控的管理者在职业中会较为灵活应变，得到更多的晋升机会，更可能在组织中占据核心位置，因为高自我监控者能够在不同的观众面前呈现出不同的“面孔”。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（5）冒险性&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　这种接受或会比风险的倾向性影响到管理者做决策所用的时间以及做决策之前需要的信息量。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（6）A型人格与B型人格&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　A型人格表现为：1、运动、走路、吃饭通常节奏很快；2、对很多事情的进展速度感到不耐烦；3、总是试图同时做两件以上的事情；4、无法打发休闲时光；5、着迷于数字，他们的成功是以每件事中自己获益多少进行定量衡量的。&lt;/p&gt;
&lt;p&gt;　　　　B型人格表现为很少受到这种欲望的折磨，注入要活的越来越多的东西，或无休止地压缩完成工作的时间。&lt;/p&gt;
&lt;p&gt;　　　　A型人格常常处于中高度的焦虑状态之中。他们总是体验到一种时间上的紧迫性，有着强烈的竞争意识，不断给自己加压要在最短的时间内干更多的事情。A型人格者常常被评价为工作积极、勤奋努力、能力强、富于进去、成功动机高。但是，在组织中A型人格倾向于放弃对质量的追求，而仅仅追求数量，然而在企业当中晋升“常常授予哪些睿智而非匆忙、机敏而非敌意、有创造性而不仅有好胜心的人”。&lt;/p&gt;
&lt;p&gt;四、人格与工作的匹配&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190212012807937-1139013083.jpg&quot; alt=&quot;&quot; width=&quot;743&quot; height=&quot;392&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190212012924522-2147172090.jpg&quot; alt=&quot;&quot; width=&quot;529&quot; height=&quot;399&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在六边形中两个领域越接近，则两者越具有相容性。对角线上相对的类型最不一致。在现实生活中，单纯属于某一类人格的人极为少见。大多数都是集中类型的结合，但其中必以某种类型为主导。&lt;/p&gt;

&lt;h2&gt;&lt;strong&gt;三、学习&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　&lt;strong&gt;（1）什么是学习？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　学习并不仅仅局限在学校里所从事的活动。实际上我们每个人都活到老，学到老，学习可以发生在任何时间或地点。心理学家对学习的定义是：在经验的作用下而发生的相对持久的行为改变。&lt;/p&gt;
&lt;p&gt;　　　　1、显然，我们无法看到任何人的学习。如果一个人的行为、活动、反应这些作为经验的结果与过去的方式有所不同时，就意味着学习已经发生了。&lt;/p&gt;
&lt;p&gt;　　　　2、学习以行为的变化为标志。这种变化可能向着有力的方向，也可能向着不利的方向。&lt;/p&gt;
&lt;p&gt;　　　　3、这种变化应该是相对持久的。暂时的变化可能仅仅是反射的结果，而不是学习的结果。&lt;/p&gt;
&lt;p&gt;　　　　4、只有行为活动出现了变化，学习才会发生。如果个体仅仅在思维过程火灾态度上发生了变化，而行为未发生相应变化，则不能称为学习。&lt;/p&gt;
&lt;p&gt;　　　　5、学习必须包含某种类型的经验。这些经验可以通过直接方式得到，如观察或实践，也可以通过间接方式得到，如阅读书籍。那么这种经验是否导致了相对持久的行为变化？如果回答是，我们可以说学习发生了。&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;（2）学习理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　人类的行为是在后天环境中通过条件反射的方式建立的，在行为的习得过程中，强化是一项必不可少的因素，它使外界刺激与学习者的反应之间建立起条件反射，并通过不断重复而使两者的联系进一步加强和巩固，从而达到我们所说的“学会了”的地步。 那么条件刺激公国与无条件刺激反复结合，最终会使条件刺激单独存在时也能够引起一定的反应，这样，原来与有机体无关的刺激就具有了一种引起有机体反应的力量。&lt;/p&gt;
&lt;p&gt;　　　　巴甫洛夫认为，人类一切的培育、学习和训练，一切可能的习惯都是通过很长系列的条件反射而形成的。也就是说，在人类的学习过程中，可以把已形成的条件刺激作为无条件刺激，在此基础上可以建立新的条件反射，从而形成二级或高级条件反射。正是在这种学习过程中，使我们一步步成长，一天天进步。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;1、操作性条件反射说&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　刺激引起反应这一规律。斯金纳认为，操作性条件反射与两个一般性原则相联系：（1）任何反应如果紧随以强化（奖励）刺激，这个反应都有重复出现的趋向。（2）任何能提高操作反应率的刺激都是强化刺激。应用这个道理，我们完全可以塑造和改变人类的行为，只要我们对于所期望的行为提供奖励就可以。当预期行为出现后立即强化，再出现，再强化。这样，我们所期望的这种行为再度发生的比率就上升了。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;2、社会学习理论&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　个体不仅通过直接经验进行学习，还通过观察或聆听发生在他人身上的事情而学习。如，我们观察的榜样，父母、教师、同伴、上司等。学会了很多东西。这种人为我们可以通过观察和直接经验两种途径进行学习的观点，称为社会学习理论。榜样对个体的影响包括四个过程：&lt;/p&gt;
&lt;p&gt;　　　　　　注意过程：只有当人们认识并注意到榜样的重要特点时，才会向榜样学习。最容易受到影响的榜样具有这些特点：有吸引力的，反复出现的，对我们重要的，与我们相似的。&lt;/p&gt;
&lt;p&gt;　　　　　　保持过程：榜样的影响取决于当榜样不再真正出现时，个体对榜样活动的记忆程度。&lt;/p&gt;
&lt;p&gt;　　　　　　动力复制过程：个体通过观察榜样而看到一种新行为之后，观察必须要把“看到过程”转化成“做的过程”。&lt;/p&gt;
&lt;p&gt;　　　　　　强化过程：如果提供了积极的诱因或奖励，将会激发个体从事榜样行为。人们对受到强化的行为将会给予更多关注，学习的效果更好，表现的更频繁。&lt;/p&gt;
&lt;p&gt;　　　　&lt;strong&gt;3、行为塑造：强化的运用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　学习不但发生于工作之前还发生于工作过程当中，作为管理者应该利用学习规律指导员工的行为，使他们的行为对组织最有利。个体的行为之所以能形成或发生变化，其根本原因是强化的作用，因此，对强化的加以控制也就意味着对行为的控制。管理者通过对强化进行系统控制的方式，从而指导个体学习、塑造个体行为的过程，叫做行为塑造。&lt;/p&gt;
&lt;p&gt;　　　　　　根据强化的层级，可以把强化分为一级强化和二级强化两类。一级强化物满足的是人与动物的基本生理需要，如食物、水、安全等等。二级强化指的是一个中性刺激在与一级强化物反复联合后，就能获得自身的强化性质。比如尊严、赞赏、认可等。在组织环境中，提供的绝大多数是二级强化物，这些强化物本身并不能满足员工的基本需求。&lt;/p&gt;
&lt;p&gt;　　　　　　根据强化的程序，又可以把强化划分为两大类：连续强化 和 间断强化。连续强化指的是每次理想行为出现时，都给予强化。间接强化指的是，选取理想行为中的一部分进行强化，间断强化是我们日常生活中更为常用的强化方式。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190212021322380-538874332.jpg&quot; alt=&quot;&quot; width=&quot;880&quot; height=&quot;271&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　　　　　在日常生活中，强化并不总是连续的，大多数情况下只是间接强化，这种强化对人的行为仍然起到极大的促进作用。斯金纳进一步对间接强化进行了探讨，并总结出了一些强化的规律。间接强化又可以根据两个维度划分为四种方式。&lt;/p&gt;
&lt;p&gt;　　　　　　1、定时距强化方式：每隔一定的固定时间段给予一次强化，这种类型的强化关键变量在于时间，而且必须持续进行。例如我们每月定期拿到的功罪就属于这种强化方式。&lt;/p&gt;
&lt;p&gt;　　　　　　2、变时距强化方式：根据时间分配，但具体时间却是不可预测的。例如老师在新学期开始告诉学生，学期中间将进行5次小测验作为平时成绩，但什么时候却不得而知。&lt;/p&gt;
&lt;p&gt;　　　　　　3、定比率强化方式：强化过程中，个体反应达到了一定数目之后，就给予奖励。&lt;/p&gt;
&lt;p&gt;　　　　　　4、变比率强化方式：以次数不定的间隔来进行强化。例如，赌场中的老虎游戏机的设计原理也是如此，你不断给机器输入钱币，有时好运连连、财运如流水，有时血本无归。在行为塑造方面，通常这种方式的强化效果最好，因为行为反应最不容易因为不强化而消退，而且反应重复出现的频率也最高。&lt;/p&gt;
&lt;p&gt;　　　　　　可变方式的强化会禅城更高的反应几率和更稳定一致的行为，因为这种方式中，包含着相当多的不确定和难以预料的因素，个体为了得到奖励，就必须时刻保持着警觉性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190212022333234-1853846141.jpg&quot; alt=&quot;&quot; width=&quot;826&quot; height=&quot;254&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/820234/201902/820234-20190212022404096-107428182.jpg&quot; alt=&quot;&quot; width=&quot;823&quot; height=&quot;214&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;个人感悟&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;　　我们通过本章，可以以第三视角来审视自己，找出属于自己的特质，顺着自身的特质发展与学习强化，达到自己想要成为的那样的人。&lt;/p&gt;
&lt;p&gt;　　与此同时现实中我们通过对于不同人的特质的洞察与把握，能够用对方所能接收的方式，进行沟通交流，从而促进合作的达成。&lt;/p&gt;
&lt;p&gt;　　如果是管理者，可对不同特质的人进行规范及行为强化，增强组织生产率及组织机制。&lt;/p&gt;
&lt;p&gt;　　那么再扩展一下会发现，其实很多的APP产品都是在利用人性的特点，来对定向人群的营销，因为人的内心总归是渴望被认同、被关注以及获得奖励。&lt;/p&gt;
</description>
<pubDate>Mon, 11 Feb 2019 18:25:00 +0000</pubDate>
<dc:creator>超大的雪童子</dc:creator>
<og:description>一、能力 人的能力各有长短，这是不争的事实。但是，个体能力的发展的不平衡未必就意味着孰优孰劣。人的能力是有差异的，应该善于根据人的能力特点去使用他们，尽量兼收并蓄。而不要有所弃有所取。要不拘一格地使用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangsy0915/p/10363754.html</dc:identifier>
</item>
<item>
<title>JVM平台上的响应式流（Reactive Streams）规范 - 李新杰</title>
<link>http://www.cnblogs.com/lixinjie/p/a-reactive-streams-specification-on-jvm.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lixinjie/p/a-reactive-streams-specification-on-jvm.html</guid>
<description>&lt;section class=&quot;&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;93802&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;&quot; data-brushtype=&quot;text&quot;&gt;&lt;span&gt;Reactive Streams&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;响应式流是一个倡议，用来为具有非阻塞后压的异步流处理提供一个标准。大家努力的目标集中在运行时环境（JVM和JavaScript）和网络协议上。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;注：响应式流其实就是一个规范，本文讲解的正是这个规范，且这个规范已经被引入到JDK9里了。&lt;br/&gt;&lt;/p&gt;


&lt;section class=&quot;&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;94007&quot;&gt;&lt;section&gt;&lt;section/&gt;&lt;section&gt;&lt;section/&gt;&lt;section/&gt;&lt;section/&gt;&lt;/section&gt;&lt;section readability=&quot;3&quot;&gt;&lt;section data-autoskip=&quot;1&quot; class=&quot;&quot; readability=&quot;6&quot;&gt;&lt;p&gt;&lt;span&gt;后压：就是下游出现了问题，得不到解决时，这个问题就会逆流而上，继而影响上游。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;如果一个路口红绿灯坏了造成堵车，如果不管的话，用不了太长时间，车就会堵到上一个路口，如果再不管的话，整条路都会被赌满。&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;

&lt;section class=&quot;&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;93802&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;&quot; data-brushtype=&quot;text&quot;&gt;&lt;span&gt;JDK9里的java.util.concurrent.Flow&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;本规范里的这些接口在JDK9的java.util.concurrent.Flow里都已经可用，它们在语义上与响应式流的各接口基本上一比一相等。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;这意味着将有一个迁移周期，直至第三方库都采用JDK里的新类型，这个周期自然希望短一些。&lt;/p&gt;&lt;p&gt;这取决于第三方库的完整语义相等，和Reactive Streams和JDK的Flow之间的适配器库和一个与JDK的Flow类型可直接兼容的TCK。&lt;/p&gt;


&lt;section class=&quot;&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;94007&quot;&gt;&lt;section&gt;&lt;section/&gt;&lt;section&gt;&lt;section/&gt;&lt;section/&gt;&lt;section/&gt;&lt;/section&gt;&lt;section readability=&quot;2.5&quot;&gt;&lt;section data-autoskip=&quot;1&quot; class=&quot;&quot; readability=&quot;5&quot;&gt;&lt;p&gt;&lt;span&gt;因为这个标准在JDK9才引入，在此之前一些第三方库都已经存在，所以需要一个过渡阶段，让第三方库慢慢采用JDK的标准。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;TCK是一个工具，下文有介绍。&lt;/span&gt;&lt;/p&gt;
&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;

&lt;section class=&quot;&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;93802&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;&quot; data-brushtype=&quot;text&quot;&gt;&lt;span&gt;Goals, Design and Scope&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;处理流数据，尤其是在线数据，它们的量是无法预知的，在一个异步系统中要求格外小心。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;最重要的问题是资源的消耗需要被小心地控制，以便一个快速的数据源不会淹没流的目的地（下游）。&lt;/p&gt;&lt;p&gt;需要异步的目的是为了并行地使用计算资源，如协调网络上多个主机，或一个机器的多个CPU核。&lt;/p&gt;&lt;p&gt;响应式流的主要目标是控制横穿一个异步边界的流数据的交换。&lt;/p&gt;&lt;p&gt;考虑到向另一个线程或线程池传递元素，同时确保接收端不被强迫缓冲任意数量的数据。&lt;/p&gt;&lt;p&gt;换句话说，后压是这个模型的一个必须部分，目的是允许队列在被界定的线程之间进行调节（斡旋）。&lt;/p&gt;&lt;p&gt;如果后压信号是同步的，异步处理的好处将被否定，因此对一个响应式流实现的所有方面的完全非阻塞和异步行为的授权需要小心一些。&lt;/p&gt;&lt;p&gt;这个规范的意图就是允许创建许多种一致的实现，它们凭借遵守规则将能够平滑地互操作，在一个流应用的整个处理图中保留前文提到的好处和特征。&lt;/p&gt;&lt;p&gt;需要注意的是流操作的精确特性（转化，分割，合并等）并没有被这个规范包括。响应式流只关心在不同的API组件间调节流数据。在他们的开发中，已经非常细心地确保所有组合流的基本方式都能够被表达。&lt;/p&gt;&lt;p&gt;总之，响应式流是JVM上面向流的库的一个标准和规范：&lt;/p&gt;&lt;p&gt;处理一个潜在的无限数目元素，&lt;br/&gt;依次地，&lt;br/&gt;异步地在组件间传递元素，&lt;br/&gt;带有强制的非阻塞后压。&lt;/p&gt;&lt;p&gt;响应式流规范由以下部分组成：&lt;/p&gt;&lt;p&gt;1、API规定了需要实现的响应式流类型，并且在不同的实现间完成互操作性。&lt;/p&gt;&lt;p&gt;2、技术兼容性工具（TCK）是一个标准的测试套件，用于各种实现的一致性测试。&lt;/p&gt;&lt;p&gt;各种实现可以自由地实现规范中没有提到的额外特性，只要它们遵从API要求和在TCK中通过测试。&lt;/p&gt;
&lt;section class=&quot;&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;93802&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;&quot; data-brushtype=&quot;text&quot;&gt;&lt;span&gt;API Components&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;API由以下组件组成，响应式流的实现必须提供它们：&lt;/span&gt;&lt;/p&gt;&lt;p&gt;1、Publisher，发布者（生产者）&lt;br/&gt;2、Subscriber，订阅者（消费者）&lt;br/&gt;3、Subscription，订阅&lt;br/&gt;4、Processor，处理者&lt;/p&gt;&lt;p&gt;它们其实是4个接口，先睹为快：&lt;br/&gt;&lt;/p&gt;

&lt;section class=&quot;&quot; readability=&quot;7&quot;&gt;&lt;pre readability=&quot;7.5&quot;&gt;
&lt;code class=&quot;&quot; readability=&quot;9&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Publisher&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(Subscriber&amp;lt;? &lt;span class=&quot;&quot;&gt;super&lt;/span&gt; T&amp;gt; s)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;p&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Subscriber&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;onSubscribe&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(Subscription s)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(Throwable t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;onComplete&lt;/span&gt;&lt;span class=&quot;&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Subscription&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;request&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(&lt;span class=&quot;&quot;&gt;long&lt;/span&gt; n)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;cancel&lt;/span&gt;&lt;span class=&quot;&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Processor&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;R&lt;/span&gt;&amp;gt; &lt;span class=&quot;&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Subscriber&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;T&lt;/span&gt;&amp;gt;, &lt;span class=&quot;&quot;&gt;Publisher&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;R&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;/p&gt;&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;一个发布者是一个潜在的无限数量的序列元素的一个提供者，按照收到的来自于它的订阅者的需要来发布这些元素。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;作为对发布者的subscribe(Subscriber)方法调用的响应，对于订阅者上的方法的可能调用顺序按下面的协议给出：&lt;/p&gt;&lt;p&gt;&lt;span&gt;onSubscribe onNext* (onError | onComplete)?&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这意味着onSubscribe方法总是被调用，后面跟着一个可能的无限数量onNext方法调用（因为订阅者的请求）。如果失败的话，后跟一个onError方法调用，或当没有更多的元素可用时，是一个onComplete方法调用，只要这个Subscription（订阅关系）没有被取消。&lt;/span&gt;&lt;/p&gt;


&lt;section class=&quot;&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;93802&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;&quot; data-brushtype=&quot;text&quot;&gt;&lt;span&gt;Glossary&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;
&lt;p&gt;&lt;span&gt;术语，释义&lt;br/&gt;Signal，本义是信号。作为一个名词，指的是这些方法onSubscribe，onNext，onComplete，onError，request(n)或cancel中的一个。作为一个动词，指的是调用这些方法中的一个。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;表面上可以理解为发信号进行通知，本质上也是通过方法调用来实现的。&lt;/p&gt;&lt;p&gt;Demand，本义是需求。作为一个名词，指的是一个订阅者（向发布者）请求的一定数量的元素，它还没有被发布者分发。作为一个动词，指的是请求更多元素的行为动作。&lt;/p&gt;&lt;p&gt;可以看作是订阅者向发布者发出的需求/动作，想要获取更多的元素。发布者暂时还没有回应。&lt;/p&gt;&lt;p&gt;Synchronous(ly)，本义是同步的。指的是在调用线程上执行（没有新开线程）。&lt;/p&gt;&lt;p&gt;Return normally，本义是正常返回。指的是仅返回已声明过的类型的值给调用者。如果想发送一个失败给订阅者，唯一合法的方式是通过onError（回调）方法。&lt;/p&gt;&lt;p&gt;Responsivity，本义是响应度。指的是已准备就绪有能力来做出响应。在这个文档里用来指示不同的组件不应该互相削弱响应的能力。&lt;/p&gt;&lt;p&gt;Non-obstructing（堵塞），本义是不堵塞。指的是描述一个方法的质量（品质），即在调用线程上尽可能快地执行完。这意味着，例如，避免重的计算和其它将拖住调用者线程执行的事情（因为没有新开线程）。&lt;/p&gt;&lt;p&gt;Terminal state，本义是终止状态。对于一个发布者，指的是当onComplete或者onError已经被调用。对于一个订阅者，指的是当一个onComplete或onError（回调方法）已经收到。&lt;/p&gt;&lt;p&gt;NOP，指的是执行对于调用线程来说没有可检测到的影响，能够像这样安全地被调用任意次。&lt;/p&gt;&lt;p&gt;External synchronization，本义是外部同步。为了线程安全的目的，协调访问在这个规范里定义的结构之外被实现，使用的技术像但不限于atomics，monitors或locks。&lt;/p&gt;&lt;p&gt;Thread-safe，能够安全地被同步或异步调用，不需要外部的同步来确保程序的正确性。&lt;/p&gt;
&lt;section class=&quot;&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;93802&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;&quot; data-brushtype=&quot;text&quot;&gt;&lt;span&gt;SPECIFICATION&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;Publisher&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Publisher&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(Subscriber&amp;lt;? &lt;span class=&quot;&quot;&gt;super&lt;/span&gt; T&amp;gt; s)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1、一个发布者对一个订阅者的onNext调用总次数必须总是小于或等于订阅者的Subscription请求的元素总数。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、一个发布者可能调用的onNext次数比要求的少，然后通过调用onComplete或onError来终止Subscription。&lt;/p&gt;&lt;p&gt;3、对一个订阅者的onSubscribe，onNext，onError和onComplete调用必须以一个线程安全的方式进行，如果被多个线程执行，使用external synchronization。&lt;/p&gt;&lt;p&gt;4、如果一个发布者失败，它必须调用一个onError。&lt;/p&gt;&lt;p&gt;5、如果一个发布者成功地终止（对于有限流），它必须调用一个onComplete。&lt;/p&gt;&lt;p&gt;6、如果一个发布者调用一个订阅者上的onError或onComplete方法，那个订阅者的Subscription必须认为已被取消。&lt;/p&gt;&lt;p&gt;7、一旦一个terminal state已经被调用（onError，onComplete），它要求没有进一步的调用发生。&lt;/p&gt;&lt;p&gt;8、如果一个订阅被取消，它的订阅者必须最终停止被调用。&lt;/p&gt;&lt;p&gt;9、发布者的subscribe方法里必须在早于对订阅者上的任何方法调用之前先调用onSubscribe方法，且必须return normally。当订阅者是null的时候，此时必须向调用者抛出java.lang.NullPointerException异常。对于其它任何情况，通知失败（或拒绝订阅者）的唯一合法方式是调用onError。&lt;/p&gt;&lt;p&gt;10、发布者的subscribe方法可能被调用任意多次，但是每次必须使用一个不同的订阅者。&lt;/p&gt;&lt;p&gt;11、一个发布者可以支持多个订阅者，并决定每一个订阅是单播或多播。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Subscriber&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Subscriber&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;T&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;onSubscribe&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(Subscription s)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;onNext&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(T t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;onError&lt;/span&gt;&lt;span class=&quot;&quot;&gt;(Throwable t)&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;onComplete&lt;/span&gt;&lt;span class=&quot;&quot;&gt;()&lt;/span&gt;&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1、一个订阅者必须通过订阅（Subscription）的request(long n)方法声明需求，然后接收onNext调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、如果一个订阅者怀疑它的调用处理将消极地影响它的发布者的响应度，建议异步地分发它的调用。&lt;/p&gt;&lt;p&gt;3、订阅者的onComplete()和onError(Throwable t)这两个方法里禁止调用订阅或发布者上的任何方法。&lt;/p&gt;&lt;p&gt;4、订阅者的onComplete()和onError(Throwable t)这两个方法在接收到调用后必须认为订阅已经被取消。&lt;/p&gt;&lt;p&gt;5、一个订阅者必须在收到onSubscriber之后调用指定订阅上的cancel()方法取消该订阅，如果它已经有一个活动的订阅。&lt;/p&gt;&lt;p&gt;6、一个订阅者必须调用订阅的cancel()方法，如果这个订阅不再需要的话。&lt;/p&gt;&lt;p&gt;7、一个订阅者必须确保所有对订阅发生的调用都来自于同一个线程或为它们各自提供external synchronization。&lt;/p&gt;&lt;p&gt;8、一个订阅者必须准备好接收一到多个onNext调用，在已经调用过订阅的cancel()方法之后如果还有请求的元素即将发送。订阅的cancel()方法并不保证立即执行底层的清理操作。&lt;/p&gt;&lt;p&gt;9、一个订阅者必须准备好接收一个onComplete调用，不管之前有或没有调用过订阅的request(long n)方法。&lt;/p&gt;&lt;p&gt;10、一个订阅者必须准备好接收一个onError调用，不管之前有或没有调用过订阅的request(long n)方法。&lt;/p&gt;&lt;p&gt;11、一个订阅者必须确保它的所有的方法调用发生在它们各自的处理之前。该订阅者必须小心合适地发布调用到它的处理逻辑。&lt;/p&gt;&lt;p&gt;12、订阅者的onSubscribe方法必须最多被调用一次，对于一个给定的订阅者。&lt;/p&gt;&lt;p&gt;13、对onSubscribe，onNext，onError或onComplete的调用必须return normally，除了当提供的任何参数是null时，这种情况必须向调用者抛出一个java.lang.NullPointerException异常。对于其它情况，对于一个订阅者来说，去通知一个失败的唯一合法的方式是取消它的订阅。在这个规则被违反的情况下，任何与该订阅者关联的订阅必须被认为是取消的，调用者必须激发这个错误条件，以一种对于运行环境来说是足够的方式。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Subscription&lt;/span&gt;&lt;/p&gt;
&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Subscription&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;request&lt;/span&gt;(&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;long&lt;/span&gt; n&lt;/span&gt;)&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;&quot;&gt;cancel&lt;/span&gt;()&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;

&lt;p&gt;&lt;span&gt;1、订阅的request和cancel方法必须在它的订阅者上下文里被调用。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、订阅必须允许订阅者在onNext或onComplete方法里同步地调用订阅的request方法。&lt;/p&gt;&lt;p&gt;3、订阅的request方法必须放置一个关于发布者和订阅者间的同步递归调用的上界。&lt;/p&gt;&lt;p&gt;4、订阅的request方法应该尊重它的调用者的响应度，通过以一个适时的方式返回。&lt;/p&gt;&lt;p&gt;5、调用的cancel方法必须尊重它的调用者的响应度，通过以一个适时的方式返回，必须是幂等的和线程安全的。&lt;/p&gt;&lt;p&gt;6、在订阅取消之后，额外的request(long n)调用必须是NOP。&lt;/p&gt;&lt;p&gt;7、在订阅取消之后，额外的cancel()调用必须时NOP。&lt;/p&gt;&lt;p&gt;8、当订阅没有被取消时，request(long n)方法必须注册给定数目的额外元素，这些元素将被生产并分发给各自的订阅者。&lt;/p&gt;&lt;p&gt;9、当订阅没有被取消时，request(long n)必须使用一个java.lang.IllegalArgumentException异常来调用onError，如果参数小于等于0。引起的原因应该解释为不是正数的调用是非法的。&lt;/p&gt;&lt;p&gt;10、当订阅没有被取消，request(long n)可以同步地调用这个（或其它）订阅者上的onNext。&lt;/p&gt;&lt;p&gt;11、当订阅没有被取消，request(long n)可以同步地调用这个（或其它）订阅者上的onComplete或onError。&lt;/p&gt;&lt;p&gt;12、当订阅没有被取消，cancel()必须请求发布者最终停止调用它的订阅者上的方法。这个操作不要求立即影响订阅。&lt;/p&gt;&lt;p&gt;13、当订阅没有被取消，cancel()必须请求发布者最终删除对相关订阅者的任何引用。&lt;/p&gt;&lt;p&gt;14、当订阅没有被取消，调用cancel()可以引起发布者（如果是有状态的）进入关闭状态，如果在此刻没有其它的订阅存在。&lt;/p&gt;&lt;p&gt;15、调用订阅的cancel方法必须是return normally。&lt;/p&gt;&lt;p&gt;16、调用订阅的request方法必须是return normally。&lt;/p&gt;&lt;p&gt;17、一个订阅必须支持无数次地调用request方法，必须支持到2^63 - 1（Long.MAX_VALUE）次。如果一个需求等于或大于2^63 - 1（Long.MAX_VALUE），或许被发布者认为是真正的无界。&lt;/p&gt;&lt;p&gt;一个订阅被一个发布者和一个订阅者共享，目的是为了在它们之间调节数据交换。这也是为什么subscribe()方法并没有返回创建的那个订阅而是返回void的原因。这个订阅只能通过onSubscriber回调方法传给订阅者。&lt;/p&gt;&lt;p&gt;&lt;span&gt;Processor&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;

&lt;section class=&quot;&quot; readability=&quot;4&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Processor&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;T&lt;/span&gt;, &lt;span class=&quot;&quot;&gt;R&lt;/span&gt;&amp;gt; &lt;span class=&quot;&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;&quot;&gt;Subscriber&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;T&lt;/span&gt;&amp;gt;, &lt;span class=&quot;&quot;&gt;Publisher&lt;/span&gt;&amp;lt;&lt;span class=&quot;&quot;&gt;R&lt;/span&gt;&amp;gt; &lt;/span&gt;{&lt;p&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;1、一个处理器表示一个处理阶段，它既是一个订阅者又是一个发布者，必须遵守它们两者的契约。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;2、一个处理器可以选择恢复一个onError调用。如果它选择这样做，必须认为订阅被取消，否则必须立即传播onError调用到它的订阅者。&lt;/p&gt;&lt;p&gt;在不被强制时，当最后一个订阅者取消它的订阅时，取消一个处理器的上游订阅是一个好主意，可以让这个取消调用往上游传播。&lt;/p&gt;
&lt;section class=&quot;&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;93802&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;&quot; data-brushtype=&quot;text&quot;&gt;&lt;span&gt;Asynchronous vs Synchronous Processing&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;响应式流API要求所有的元素处理（onNext调用）或终止调用（onError，onComplete）禁止阻塞发布者。然而，每一个on*（以on开头的方法）处理器可以同步地处理事件，也可以异步地处理。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;看下面这个示例：&lt;br/&gt;&lt;/p&gt;

&lt;section class=&quot;&quot; readability=&quot;2&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;&lt;span class=&quot;&quot;&gt;nioSelectorThreadOrigin&lt;/span&gt; map(f) filter(p) consumeTo(toNioSelectorOutput)&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;它有一个异步的来源和异步的目的地。让我们假设来源和目的地都是selector事件循环。Subscription.request(n)必须是一个链接从目的地到来源。这就是现在每一个实现都能选择如何做这些的地方。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;下面使用管道操作符（|）来调用异步边界（队列和调度器），R#表示资源（可能是线程）。&lt;br/&gt;&lt;/p&gt;

&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;nioSelectorThreadOrigin &lt;span class=&quot;&quot;&gt;| map(f) |&lt;/span&gt; filter(p) &lt;span class=&quot;&quot;&gt;| consumeTo(toNioSelectorOutput)&lt;br/&gt;-------------- R1 ----  |&lt;/span&gt; - R2 - &lt;span class=&quot;&quot;&gt;| -- R3 --- |&lt;/span&gt; ---------- R4 ----------------&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;在这个示例中，这3个消费者中的每一个，map，filter和consumeTo异步地调度work。它们可能在同一个事件循环上，也可能是分离的线程。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;看下面这个示例&lt;br/&gt;&lt;/p&gt;

&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;nioSelectorThreadOrigin map(f) filter(p) | consumeTo(toNioSelectorOutput)&lt;br/&gt;&lt;span class=&quot;&quot;&gt;------------------- R1 ----------------- | ---------- R2 ----------------&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;
&lt;p&gt;&lt;span&gt;&lt;br/&gt;这里只有最后一步是异步地调度，通过把work添加到NioSelectorOutput事件循环。map和filter步骤都在来源线程上同步地执行。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;或者另一种实现把这些操作都安装到最终消费者那里：&lt;br/&gt;&lt;/p&gt;

&lt;section class=&quot;&quot; readability=&quot;3&quot;&gt;&lt;pre&gt;
&lt;code class=&quot;&quot;&gt;nioSelectorThreadOrigin | &lt;span class=&quot;&quot;&gt;map&lt;/span&gt;(f) filter(p) consumeTo(toNioSelectorOutput)&lt;br/&gt;--------- R1 ---------- | ------------------ R2 -------------------------&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;&lt;/section&gt;&lt;p&gt;所有这些变体都是“异步流”。它们都有自己的位置，每一个有不同的权衡包括性能和实现复杂度。&lt;/p&gt;&lt;p&gt;响应式流允许实现灵活性来管理资源和调度，混合异步和同步处理，在一个非阻塞，异步，动态的推拉式流的限制内。&lt;/p&gt;&lt;p&gt;为了允许所有参与API元素（Publisher/Subscription/Subscriber/Processor）的完全的异步实现，这些接口定义的所有方法都返回void。&lt;/p&gt;
&lt;section class=&quot;&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;93802&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;&quot; data-brushtype=&quot;text&quot;&gt;&lt;span&gt;Subscriber controlled queue bounds&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;p&gt;&lt;span&gt;其中一个底层设计原则是，所有缓冲区大小都是有界的，这些界限必须是知道的，且由订阅者控制。这些界限用元素数目（它依次转化为onNext的调用次数）这样的术语来表达。任何实现的目标都是为了支持无限流（尤其是高输出速率流），一般需要强迫界限都沿着避免OOM错误和限制资源使用的方式。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;因为后压是强制的，使用无界缓冲区能够被避免。一般来说，只有在当一个队列可能无界增长时，此时也是发布者端比订阅者端保持一个更高的速率，且持续了一段较大的时间，但是这种情形是被后压来处理的。&lt;/p&gt;&lt;p&gt;队列界限能够被控制通过一个订阅者为了适合数目的元素而调用需求。在任何时候订阅者都知道：&lt;/p&gt;&lt;p&gt;请求的总元素数目：P&lt;br/&gt;已经处理的元素数目：N&lt;/p&gt;&lt;p&gt;然后最大数量的元素可能达到是P - N，直到更多的需求被发送通知给发布者。这种情况下，订阅者也知道在它的输入缓冲区里的元素数目B，然后这个界限可以被重新精确为P - B - N。&lt;/p&gt;&lt;p&gt;这些界限必须被一个发布者尊重，独立于无论它表示的源是能够被后压的或不能。在这种源的生产速率不能被影响的情形下，例如钟表的滴滴答答或鼠标的移动，发布者必须选择要么缓冲元素或抛弃元素来遵守这个强加的界限。&lt;/p&gt;&lt;p&gt;订阅者在接收一个元素后发一个请求获取另一个元素，可以有效地实现一个停止和等待协议，这里这个需求信号和一个ACK（回应）相等。通过提需求的方式获取多个元素，ACK花销是分期偿还的。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;这是值的注意的，订阅者被允许在任何时间点发信号提出需求，允许它是为了避免发布者和订阅者之间不必要的延迟（例如，保持它的输入缓冲区是满的，不需要等待完整的往返时间）。&lt;/span&gt;&lt;/p&gt;


&lt;section class=&quot;&quot; data-tools=&quot;135编辑器&quot; data-id=&quot;93802&quot;&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;&lt;section&gt;//&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section class=&quot;&quot; data-brushtype=&quot;text&quot;&gt;&lt;span&gt;Legal&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;section&gt;&lt;section&gt;&lt;span&gt;//&lt;/span&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;&lt;/section&gt;

&lt;p&gt;&lt;span&gt;这个工程是一个协作成果，完成它的工程师来自于Kaazing，Lightbend，Netflix，Pivotal，Red Hat，Twitter和许多其他公司。代码被开放到公共领域是为了允许感兴趣的团体自由地使用，它们想创建一个兼容性的实现。详细内容请查看COPYING。&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Mon, 11 Feb 2019 17:04:00 +0000</pubDate>
<dc:creator>李新杰</dc:creator>
<og:description>响应式流是一个倡议，用来为具有非阻塞后压的异步流处理提供一个标准。大家努力的目标集中在运行时环境（JVM和JavaScript）和网络协议上。 注：响应式流其实就是一个规范，本文讲解的正是这个规范，且</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lixinjie/p/a-reactive-streams-specification-on-jvm.html</dc:identifier>
</item>
<item>
<title>SpringBoot(二十七)整合Redis之分布式锁 - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/redis_lock.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/redis_lock.html</guid>
<description>&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;29.924050632911&quot;&gt;
&lt;blockquote readability=&quot;7.780534351145&quot;&gt;
&lt;p&gt;在之前的一篇文章(&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://www.cnblogs.com/toutou/p/java_lock.html&quot; target=&quot;_blank&quot;&gt;《Java分布式锁,搞懂分布式锁实现看这篇文章就对了》&lt;/a&gt;)，已经介绍过几种java分布式锁，今天来个Redis分布式锁的demo。redis 现在已经成为系统缓存的必备组件，针对缓存读取更新操作，通常我们希望当缓存过期之后能够只有一个请求去更新缓存，其它请求依然使用旧的数据。这就需要用到锁，因为应用服务多数以集群方式部署，因此这里的锁就必需要是分布式锁才能符合需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;学习本章节之前，建议依次阅读以下文章，更好的串联全文内容，如已掌握以下列出知识点，请跳过：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506684/201901/506684-20190125152405899-1222483389.png&quot; alt=&quot;请叫我头头哥_SpringBoot(二十七)整合Redis之分布式锁&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;h2 id=&quot;_nav_0&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;简单实现&lt;/h2&gt;
&lt;p&gt;锁是针对某个资源的状态，保证其访问的互斥性，在实际使用当中，这个状态一般是一个字符串。使用 Redis 实现锁，主要是将状态放到 Redis 当中，利用其原子性，当其他线程访问时，如果 Redis 中已经存在这个状态，就不允许之后的一些操作。spring boot使用Redis的操作主要是通过RedisTemplate(或StringRedisTemplate )来实现。&lt;/p&gt;
&lt;p&gt;1.1 将锁状态放入 Redis：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redisTemplate.opsForValue().setIfAbsent(&quot;lockkey&quot;, &quot;value&quot;); // setIfAbsent如果键不存在则新增,存在则不改变已经有的值。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1.2 设置锁的过期时间&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redisTemplate.expire(&quot;lockkey&quot;, 30000, TimeUnit.MILLISECONDS);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1.3 删除/解锁&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redisTemplate.opsForValue().get(&quot;lockkey&quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这么就是简单实现，但是1.1和1.2这么做，这两步违背了原子性，也就是一旦锁被创建，而没有设置过期时间，则锁会一直存在。&lt;/p&gt;
&lt;p&gt;1.4 获取锁&lt;/p&gt;
&lt;p&gt;&lt;code&gt;redisTemplate.delete(&quot;lockkey&quot;);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;1.5 解决方案&lt;/p&gt;
&lt;p&gt;spring data的 RedisTemplate 当中并没有这样的方法。但是在jedis当中是有这种原子操作的方法的，需要通过 RedisTemplate 的 execute 方法获取到jedis里操作命令的对象.&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
String result = template.execute(&lt;span&gt;new&lt;/span&gt; RedisCallback&amp;lt;String&amp;gt;&lt;span&gt;() {
            @Override
            &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String doInRedis(RedisConnection connection) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; DataAccessException {
                JedisCommands commands &lt;/span&gt;=&lt;span&gt; (JedisCommands) connection.getNativeConnection();
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; commands.set(key, &quot;锁定的资源&quot;, &quot;NX&quot;, &quot;PX&quot;, 3000&lt;span&gt;);
            }
        });&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意： Redis 从2.6.12版本开始 set 命令支持 NX 、 PX 这些参数来达到 setnx 、 setex 、 psetex 命令的效果，文档参见： &lt;a title=&quot;请叫我头头哥&quot; href=&quot;http://doc.redisfans.com/string/set.html&quot; target=&quot;_blank&quot;&gt;SET — Redis 命令参考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NX： 表示只有当锁定资源不存在的时候才能 SET 成功。利用 Redis 的原子性，保证了只有第一个请求的线程才能获得锁，而之后的所有线程在锁定资源被释放之前都不能获得锁。&lt;/p&gt;
&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;锁的进阶&lt;/h2&gt;
&lt;p&gt;模拟一个比较常见的秒杀场景，这时候就需要用到锁。&lt;/p&gt;
&lt;p&gt;2.1 创建RedisLockHelper&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.common;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.google.common.base.Strings;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.extern.slf4j.Slf4j;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.data.redis.core.StringRedisTemplate;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by toutou on 2019/1/27.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
@Slf4j
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisLockHelper {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; StringRedisTemplate stringRedisTemplate;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 加锁
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; targetId   targetId - 商品的唯一标志
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; timeStamp  当前时间+超时时间 也就是时间戳
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; lock(String targetId,String timeStamp){
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt;(stringRedisTemplate.opsForValue().setIfAbsent(targetId,timeStamp)){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对应setnx命令，可以成功设置,也就是key不存在&lt;/span&gt;
            &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 判断锁超时 - 防止原来的操作异常，没有运行解锁操作  防止死锁&lt;/span&gt;
        String currentLock =&lt;span&gt; stringRedisTemplate.opsForValue().get(targetId);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 如果锁过期 currentLock不为空且小于当前时间&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(!Strings.isNullOrEmpty(currentLock) &amp;amp;&amp;amp; Long.parseLong(currentLock) &amp;lt;&lt;span&gt; System.currentTimeMillis()){
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 获取上一个锁的时间value 对应getset，如果lock存在&lt;/span&gt;
            String preLock =&lt;span&gt;stringRedisTemplate.opsForValue().getAndSet(targetId,timeStamp);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 假设两个线程同时进来这里，因为key被占用了，而且锁过期了。获取的值currentLock=A(get取的旧的值肯定是一样的),两个线程的timeStamp都是B,key都是K.锁时间已经过期了。
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 而这里面的getAndSet一次只会一个执行，也就是一个执行之后，上一个的timeStamp已经变成了B。只有一个线程获取的上一个值会是A，另一个线程拿到的值是B。&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt;(!Strings.isNullOrEmpty(preLock) &amp;amp;&amp;amp;&lt;span&gt; preLock.equals(currentLock) ){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; preLock不为空且preLock等于currentLock，也就是校验是不是上个对应的商品时间戳，也是防止并发&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
    }


    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 解锁
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; target
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; timeStamp
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; unlock(String target,String timeStamp){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            String currentValue &lt;/span&gt;=&lt;span&gt; stringRedisTemplate.opsForValue().get(target);
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!Strings.isNullOrEmpty(currentValue) &amp;amp;&amp;amp;&lt;span&gt; currentValue.equals(timeStamp) ){
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 删除锁状态&lt;/span&gt;
&lt;span&gt;                stringRedisTemplate.opsForValue().getOperations().delete(target);
            }
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception e) {
            log.error(&lt;/span&gt;&quot;警报！警报！警报！解锁异常{}&quot;&lt;span&gt;,e);
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个是Redis加锁和解锁的工具类，里面使用的主要是两个命令，SETNX和GETSET。&lt;/p&gt;
&lt;p&gt;SETNX命令 将key设置值为value，如果key不存在，这种情况下等同SET命令。 当key存在时，什么也不做&lt;/p&gt;
&lt;p&gt;GETSET命令 先查询出原来的值，值不存在就返回nil。然后再设置值 对应的Java方法在代码中提示了。 注意一点的是，Redis是单线程的！所以在执行GETSET和SETNX不会存在并发的情况。&lt;/p&gt;
&lt;p&gt;2.2 创建Controller模拟秒杀场景&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.demo.controller;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; com.demo.common.RedisLockHelper;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; lombok.extern.slf4j.Slf4j;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.factory.annotation.Autowired;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RequestMapping;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.web.bind.annotation.RestController;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Created by toutou on 2019/1/27.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
@Slf4j
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RedisController {

    @Autowired
    RedisLockHelper redisLockHelper;

    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 超时时间 5s
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; TIMEOUT = 5*1000&lt;span&gt;;

    @RequestMapping(value &lt;/span&gt;= &quot;/seckilling&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String Seckilling(String targetId){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加锁&lt;/span&gt;
        &lt;span&gt;long&lt;/span&gt; time = System.currentTimeMillis() +&lt;span&gt; TIMEOUT;
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(!&lt;span&gt;redisLockHelper.lock(targetId,String.valueOf(time))){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;排队人数太多，请稍后再试.&quot;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; surplusCount = 0&lt;span&gt;;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 查询该商品库存，为0则活动结束 e.g. getStockByTargetId&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;(surplusCount==0&lt;span&gt;){
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;活动结束.&quot;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 下单 e.g. buyStockByTargetId

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减库存 不做处理的话，高并发下会出现超卖的情况，下单数，大于减库存的情况。虽然这里减了，但由于并发，减的库存还没存到map中去。新的并发拿到的是原来的库存&lt;/span&gt;
            surplusCount =surplusCount-1&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;{
                Thread.sleep(&lt;/span&gt;100);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;模拟减库存的处理时间&lt;/span&gt;
            }&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (InterruptedException e){
                e.printStackTrace();
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 减库存操作数据库 e.g. updateStockByTargetId

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; buyStockByTargetId 和 updateStockByTargetId 可以同步完成(或者事物)，保证原子性。&lt;/span&gt;
&lt;span&gt;        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;解锁&lt;/span&gt;
&lt;span&gt;        redisLockHelper.unlock(targetId,String.valueOf(time));

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;恭喜您，秒杀成功。&quot;&lt;span&gt;;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其他参考资料：&lt;/p&gt;
&lt;p&gt;注：本文中很多内容来自以上链接的学习心得，感谢以上人员分享，也请转载本文的各站保持以上链接。&lt;/p&gt;
&lt;h2 id=&quot;_nav_2&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://github.com/toutouge/javademo/tree/master/hellospringboot&quot; target=&quot;_blank&quot;&gt;https://github.com/toutouge/javademo/tree/master/hellospringboot&lt;/a&gt;&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot; href=&quot;javascript:void(0);&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Mon, 11 Feb 2019 15:28:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>在之前的一篇文章(《Java分布式锁,搞懂分布式锁实现看这篇文章就对了》)，已经介绍过几种java分布式锁，今天来个Redis分布式锁的demo。redis 现在已经成为系统缓存的必备组件，针对缓存读</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/toutou/p/redis_lock.html</dc:identifier>
</item>
<item>
<title>浅析MySQL 8忘记密码处理方式 - Alan_beijing</title>
<link>http://www.cnblogs.com/wangjiming/p/10363357.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangjiming/p/10363357.html</guid>
<description>&lt;p&gt;        对MySQL有研究的读者，可能会发现MySQL更新很快，在安装方式上，MySQL提供了两种经典安装方式：解压式和一键式，虽然是两种安装方式，但我更提倡选择解压式安装，不仅快，还干净。在操作系统上，MySQL也支持多类型操作系统，如linux,windows等，如下为MySQL几个重大变化的操作系统。&lt;/p&gt;
&lt;p&gt;     &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211231436032-746928616.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      通过研究分析，不难发现：MySQL从低版本向高版本迭代变化的过程，越来越严谨的安全性是其一大特点之一，我们举个例子，在版本6前，当忘记密码，重置密码，非常方面，只需使用执行如下两步即可：&lt;/p&gt;
&lt;p&gt;      步骤一：跳过权限表&lt;/p&gt;
&lt;p&gt;           mysqld –skip-grant-tables&lt;/p&gt;
&lt;p&gt;      步骤二：将密码置空&lt;/p&gt;
&lt;p&gt;          UPDATE user SET authentication_string='' WHERE user='root';&lt;/p&gt;
&lt;p&gt;    然而，这个方案，却在MySQL8不适用。&lt;/p&gt;
&lt;p&gt;     本篇文章将来解决MySQL 8忘记密码重置密码问题。主要包括三方面类容&lt;/p&gt;
&lt;p&gt;      内容一：简述解压式安装MySQL 8&lt;/p&gt;
&lt;p&gt;      内容二：忘记密码重置密码解决方案一&lt;/p&gt;
&lt;p&gt;      内容三：忘记密码重置密码解决方案二&lt;/p&gt;
&lt;p&gt;&lt;span&gt;一   安装&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; 1.在官网下载安装包(官网提供两种安装方式:可视化安装方式和解压式)，本示例以基于解压式。官网下载地址https://dev.mysql.com/downloads/mysql/&lt;/p&gt;
&lt;p&gt;2.将安装包解压，放在 C:\MySQL 目录下面&lt;/p&gt;
&lt;p&gt;3.配置环境变量&lt;/p&gt;
&lt;p&gt;MySQL_HOME=&quot;C:\MySQL\mysql-8.0.15-winx64&quot;&lt;/p&gt;
&lt;p&gt;PATH=&quot;%MySQL_HOME%\bin&quot;&lt;/p&gt;
&lt;p&gt;4.以管理员身份打开dos&lt;/p&gt;
&lt;p&gt;（1）启动服务&lt;/p&gt;
&lt;p&gt;mysqld --install&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211215426116-925107746.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;(2)初始化并产生初始化密码(MySQL7+没有data目录，初始话安装data目录)&lt;/p&gt;
&lt;p&gt;mysqld --initialize --user=mysql --console&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211215515693-176435662.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（3）启动服务&lt;/p&gt;
&lt;p&gt;net start mysql&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdnimg.cn/20190211202952332.png&quot; alt=&quot;&quot; width=&quot;350&quot; height=&quot;67&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（4）登录&lt;/p&gt;
&lt;p&gt;账号root,密码为初始话产生的临时密码A*v)(Ivw7xjQ，登录后，需要改变&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211215648891-474992733.png&quot; alt=&quot;&quot; width=&quot;764&quot; height=&quot;259&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（5）更改root密码&lt;/p&gt;
&lt;p&gt;格式：alter user '用户名'@'登录主机' identified by '密码(自定义)';&lt;/p&gt;
&lt;p&gt;&lt;img class=&quot;has&quot; src=&quot;https://img-blog.csdnimg.cn/20190211203625804.png&quot; alt=&quot;&quot; width=&quot;583&quot; height=&quot;49&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（6）新密码登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211215751930-663054808.png&quot; alt=&quot;&quot; width=&quot;760&quot; height=&quot;223&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（7）扩展命令&lt;/p&gt;
&lt;p&gt;移除服务：mysql --remove&lt;/p&gt;
&lt;p&gt;停止mysql服务：mysql stop mysql&lt;/p&gt;
&lt;p&gt;退出mysql:exit&lt;/p&gt;
&lt;p&gt;&lt;span&gt;二   解决忘记密码问题&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt; （一）方案一&lt;/p&gt;
&lt;p&gt;1.管理员身份进入dos&lt;/p&gt;
&lt;p&gt;2.停止mysql服务&lt;/p&gt;
&lt;p&gt;net stop mysql&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211215851020-500173490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.无密码启动&lt;/p&gt;
&lt;p&gt;mysqld --console --skip-grant-tables --shared-memory&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220047323-446829084.png&quot; alt=&quot;&quot; width=&quot;772&quot; height=&quot;162&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.另启一个dos窗口，无密码登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220216790-1402446041.png&quot; alt=&quot;&quot; width=&quot;775&quot; height=&quot;553&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.清空密码&lt;/p&gt;
&lt;p&gt;注意：authentication_string采用的是plugin加密方式，故设置为空，不要设置为其他值&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220917601-723959755.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6.启动服务&lt;/p&gt;
&lt;p&gt;关闭打开的两个dos窗口，然后以管理员身份重新打开一个dos窗口，启动服务&lt;/p&gt;
&lt;p&gt;net start mysql&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220447894-1840845109.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7.无密码登录&lt;/p&gt;
&lt;p&gt;mysql -u root&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220517407-672999190.png&quot; alt=&quot;&quot; width=&quot;801&quot; height=&quot;258&quot;/&gt;&lt;/p&gt;
&lt;p&gt;8.重新设置密码&lt;/p&gt;
&lt;p&gt;修改后，就可以用新密码登录了。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220550893-959459183.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9.新密码登录&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211220757099-1329595512.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（二）方案二：利用参数 --init-file参数&lt;/p&gt;
&lt;p&gt;1.停止服务&lt;/p&gt;
&lt;p&gt;net stop mysql&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211230205266-1530696167.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2.在c:\MySQL 目录下创建ResetPWD.txt文件，文件内容为&lt;/p&gt;
&lt;p&gt;ALTER USER 'root'@'localhost' IDENTIFIED BY '123456';&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211230335449-2035767987.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.执行ResetPWD.txt文件&lt;/p&gt;
&lt;p&gt;mysqld --init-file=c:\mysql\ResetPWD.txt --console，执行完毕后，关闭dos窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211230533360-1379416166.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.启动mysql&lt;/p&gt;
&lt;p&gt;net start mysql&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211230703644-1094292926.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5.用新密码登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1066923/201902/1066923-20190211230744258-1919296969.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;三  版权区&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;ul&gt;&lt;li&gt;感谢您的阅读，若有不足之处，欢迎指教，共同学习、共同进步。&lt;/li&gt;
&lt;li&gt;博主网址：http://www.cnblogs.com/wangjiming/。&lt;/li&gt;
&lt;li&gt;极少部分文章利用读书、参考、引用、抄袭、复制和粘贴等多种方式整合而成的，大部分为原创。&lt;/li&gt;
&lt;li&gt;如您喜欢，麻烦推荐一下；如您有新想法，欢迎提出，邮箱：2098469527@qq.com。&lt;/li&gt;
&lt;li&gt;可以转载该博客，但必须著名博客来源。&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt; &lt;/h2&gt;

</description>
<pubDate>Mon, 11 Feb 2019 15:26:00 +0000</pubDate>
<dc:creator>Alan_beijing</dc:creator>
<og:description>对MySQL有研究的读者，可能会发现MySQL更新很快，在安装方式上，MySQL提供了两种经典安装方式：解压式和一键式，虽然是两种安装方式，但我更提倡选择解压式安装，不仅快，还干净。在操作系统上，My</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangjiming/p/10363357.html</dc:identifier>
</item>
<item>
<title>如何优雅的在Java应用中实现全局枚举处理 - 史亚健</title>
<link>http://www.cnblogs.com/shiyajian/p/10363554.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shiyajian/p/10363554.html</guid>
<description>&lt;h2 id=&quot;背景描述&quot;&gt;背景描述&lt;/h2&gt;
&lt;p&gt;为了表达某一个属性，具备一组可选的范围，我们一般会采用两种方式。枚举类和数据字典，两者具有各自的优点。枚举类写在Java代码中，方便编写相应的判断逻辑，代码可读性高，枚举类中的属性是可提前预估和确定的。数据字典，一般保存在数据库，不便于编写判断和分支逻辑，因为数据如果有所变动，那么对应的代码逻辑很有可能失效，强依赖数据库数据的正确性，数据字典中对应的属性对业务影响并不大，日常开发中常用做分类，打标签使用，属性的多少无法估计。&lt;/p&gt;
&lt;p&gt;目前基本上没有一个很好的全局处理枚举类的方案，所以我就自己综合各方面资料写了一个。&lt;/p&gt;
&lt;h2 id=&quot;代码&quot;&gt;代码&lt;/h2&gt;
&lt;p&gt;架构还在不断完善中，代码不一定可以跑起来，不过关于枚举的配置已经完成，大家可以阅读并参考借鉴：&lt;a href=&quot;https://github.com/Shiyajian/pretty-demo.git&quot;&gt;pretty-demo&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;大多数公司处理枚举的时候，会自定义一个枚举转换工具类，或者在枚举类中编写一个静态方法实现Integer转换枚举的方式。比如：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 静态方法方式
public enum GenderEnum {

     // 代码略
    
     public static GenderEnum get(int value) {
         for (GenderEnum item : GenderEnum.values()) {
            if (value == item.getValue()) {
                 return item;
             }
         }
         return null;
     }
}
// 工具类方式
public class EnumUtil {

    public static &amp;lt;E extends Enumerable&amp;gt; E of(@Nonnull Class&amp;lt;E&amp;gt; classType, int value) {
        for (E enumConstant : classType.getEnumConstants()) {
            if (value == enumConstant.getValue()) {
                return enumConstant;
            }
        }
        return null;
    }

}

GenderEnum gender = EnumUtil.of(GenderEnum.class,1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这种方式很麻烦，或者需要手动编写对应的静态方法，或者需要手动调用工具类进行转换。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;解决方案&lt;/h2&gt;
&lt;p&gt;为了方便起见，我做了一个全局枚举值转换的方案，这个方案可以实现前端通过传递int到服务端，服务端自动转换成枚举类，进行相应的业务判断之后，再以数字的形式存到数据库；我们在查数据的时候，又能将数据库的数字转换成java枚举类，在处理完对应的业务逻辑之后，将枚举和枚举类对应的展示信息一起传递到前台，前台不需要维护这个枚举类和展示信息的对应关系，同时展示信息支持国际化处理，具体的方案如下：&lt;/p&gt;
&lt;p&gt;1、基于约定大于配置的原则，制定统一的枚举类的编写规则。大概规则如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;每个枚举类有两个字段: int value（存数据库），String key（通过key找对应的i18n文本信息）。这块需要细细讨论下，枚举值通常存数据库有存int值，也有存String值，各有利弊。存int的好处就是体积小，如果枚举的值是包含规律的，比如-1是删除，0是预处理，1是处理，2是处理完成，那么我们所有非删除数据，我们可以不使用 status in ( 0,1,2)这种方式，而转换为 status &amp;gt;= 0 ; 存String的话，好处就是可读性高，直接能从数据库的值中明白对应的状态，劣势就是占的体积大点。当然这些都是相对的，存int的时候，我们可以完善好注释，也具备好的可读性。如果int换成String，占的体积多的那一点，其实也可以忽略不计的。&lt;/li&gt;
&lt;li&gt;枚举枚举类需要继承统一接口，提供相应的方法供通用处理枚举时候使用。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是枚举接口和一个枚举示例：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public interface Enumerable&amp;lt;E extends Enumerable&amp;gt; {

    /**
     * 获取在i18n文件中对应的 key
     * @return key
     */
    @Nonnull
    String getKey();

    /**
     * 获取最终保存到数据库的值
     * @return 值
     */
    @Nonnull
    int getValue();

    /**
     * 获取 key 对应的文本信息
     * @return 文本信息
     */
    @Nonnull
    default String getText() {
        return I18nMessageUtil.getMessage(this.getKey(), null);
    }
}
public enum GenderEnum implements Enumerable {

    /** 男 */
    MALE(1, &quot;male&quot;),

    /** 女 */
    FEMALE(2, &quot;female&quot;);

    private int value;

    private String key;

    GenderEnum(int value, String key) {
        this.value = value;
        this.key = key;
    }

    @Override
    public String getKey() {
        return this.key;
    }

    @Override
    public int getValue() {
        return this.value;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们要做的就是，每个我们编写的枚举类，都需要按这样的方式进行编写，按照规范定义的枚举类方便下面统一编写。&lt;/p&gt;
&lt;p&gt;2、我们分析下controller层面的数据进和出，从而处理好枚举类和int值的转换，在Spring MVC中，框架帮我们做了数据类型的转换，所以我们以 Spring MVC作为切入点。前台发送到服务端的请求，一般有参数在url中和body中两种方式为主，分别以get请求和post请求配合@RequestBody为代表。&lt;/p&gt;
&lt;p&gt;【入参】get方法为代表，请求的MediaType为&quot;application/x-www-form-urlencoded&quot;，此时将 int 转换成枚举，我们注册一个新的Converter，如果spring MVC判断到一个值要转换成我们定义的枚举类对象时，调用我们设定的这个转换器&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
public class MvcConfiguration implements WebMvcConfigurer, WebBindingInitializer {

    /**
     * [get]请求中，将int值转换成枚举类
     * @param registry
     */
    @Override
    public void addFormatters(FormatterRegistry registry) {
        registry.addConverterFactory(new EnumConverterFactory());
    }
}

public class EnumConverterFactory implements ConverterFactory&amp;lt;String, Enumerable&amp;gt; {

    private final Map&amp;lt;Class, Converter&amp;gt; converterCache = new WeakHashMap&amp;lt;&amp;gt;();

    @Override
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    public &amp;lt;T extends Enumerable&amp;gt; Converter&amp;lt;String, T&amp;gt; getConverter(@Nonnull Class&amp;lt;T&amp;gt; targetType) {
        return converterCache.computeIfAbsent(targetType,
                k -&amp;gt; converterCache.put(k, new EnumConverter(k))
        );
    }

    protected class EnumConverter&amp;lt;T extends Enumerable&amp;gt; implements Converter&amp;lt;Integer, T&amp;gt; {

        private final Class&amp;lt;T&amp;gt; enumType;

        public EnumConverter(@Nonnull Class&amp;lt;T&amp;gt; enumType) {
            this.enumType = enumType;
        }

        @Override
        public T convert(@Nonnull Integer value) {
            return EnumUtil.of(this.enumType, value);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;【入参】post为代表，将 int 转换成枚举。这块我们和前台达成一个约定（ Ajax中applicationType），所有在body中的数据必须为json格式。同样后台@RequestBody对应的参数的请求的MediaType为&quot;application/json&quot;，spring MVC中对于Json格式的数据，默认使用 Jackson2HttpMessageConverter。在Jackson转换成实体时候，有@JsonCreator和@JsonValue两个注解可以用，但是感觉还是有点麻烦。为了统一处理，我们需要修改Jackson对枚举类的序列化和反序列的支持。配置如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;@Configuration
@Slf4j
public class JacksonConfiguration {

    /**
     * Jackson的转换器
     * @return
     */
    @Bean
    @Primary
    @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
    public MappingJackson2HttpMessageConverter mappingJacksonHttpMessageConverter() {
        final MappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();
        ObjectMapper objectMapper = converter.getObjectMapper();
        // Include.NON_EMPTY 属性为 空（&quot;&quot;） 或者为 NULL 都不序列化，则返回的json是没有这个字段的。这样对移动端会更省流量
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
        // 反序列化时候，遇到多余的字段不失败，忽略
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        // 允许出现特殊字符和转义符
        objectMapper.configure(JsonParser.Feature.ALLOW_UNQUOTED_CONTROL_CHARS, true);
        // 允许出现单引号
        objectMapper.configure(JsonParser.Feature.ALLOW_SINGLE_QUOTES, true);
        SimpleModule customerModule = new SimpleModule();
        customerModule.addDeserializer(String.class, new StringTrimDeserializer(String.class));
        customerModule.addDeserializer(Enumerable.class, new EnumDeserializer(Enumerable.class));
        customerModule.addSerializer(Enumerable.class, new EnumSerializer(Enumerable.class));
        objectMapper.registerModule(customerModule);
        converter.setSupportedMediaTypes(ImmutableList.of(MediaType.TEXT_HTML, MediaType.APPLICATION_JSON));
        return converter;
    }

}
public class EnumDeserializer&amp;lt;E extends Enumerable&amp;gt; extends StdDeserializer&amp;lt;E&amp;gt; {

    private Class&amp;lt;E&amp;gt; enumType;

    public EnumDeserializer(@Nonnull Class&amp;lt;E&amp;gt; enumType) {
        super(enumType);
        this.enumType = enumType;
    }

    @Override
    public E deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException {
        return EnumUtil.of(this.enumType, jsonParser.getIntValue());
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;【出参】当我们查询出结果，要展示给前台的时候，我们会对结果集增加@ResponseBody注解，这时候会调用Jackson的序列化方法，所以我们增加了枚举类的序列配置。如果我们只简单的将枚举转换成 int 给前台，那么前台需要维护这个枚举类的 int 和对应展示信息的关系。所以这块我们将值和展示信息一同返给前台，减轻前台的工作压力。&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;// 注册枚举类序列化处理类
customerModule.addSerializer(Enumerable.class, new EnumSerializer(Enumerable.class));

public class EnumSerializer extends StdSerializer&amp;lt;Enumerable&amp;gt; {

    public EnumSerializer(@Nonnull Class&amp;lt;Enumerable&amp;gt; type) {
        super(type);
    }

    @Override
    public void serialize(Enumerable enumerable, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeStartObject();
        jsonGenerator.writeNumberField(&quot;value&quot;, enumerable.getValue());
        jsonGenerator.writeStringField(&quot;text&quot;, enumerable.getText());
        jsonGenerator.writeEndObject();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样关于入参和出参的配置都完成了，我们可以保证，所有前台传递到后台的 int 都会自动转换成枚举类。如果返回的数据有枚举类，枚举类也会包含值和展示文本，方便简单。&lt;/p&gt;
&lt;p&gt;3、存储层关于枚举类的转换。这里选的 ORM 框架为 Mybatis ，但是你如果翻看&lt;a href=&quot;http://www.mybatis.org/mybatis-3/zh/configuration.html&quot;&gt;官网&lt;/a&gt;，官网的资料只提供了两个方案，就是通过枚举隐藏字段name和ordinal的转换，没有一个通用枚举的解决方案。但是通过翻看 github 中的 &lt;a href=&quot;https://github.com/mybatis/mybatis-3/issues/970&quot;&gt;issue&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/mybatis/mybatis-3/releases/tag/mybatis-3.4.5&quot;&gt;release&lt;/a&gt; 记录，发现在 3.4.5版本中就提供了对应的自定义枚举处理配置，这块不需要我们做过多的配置，我们直接增加 mybatis-spring-boot-starter 的依赖，直接配置对应的Yaml 文件就实现了功能。&lt;/p&gt;
&lt;pre class=&quot;yml&quot;&gt;
&lt;code&gt;application.yml
--
mybatis:
  configuration:
    default-enum-type-handler: github.shiyajian.pretty.config.enums.EnumTypeHandler&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class EnumTypeHandler&amp;lt;E extends Enumerable&amp;gt; extends BaseTypeHandler&amp;lt;E&amp;gt; {

    private Class&amp;lt;E&amp;gt; enumType;

    public EnumTypeHandler() { /* instance */ }


    public EnumTypeHandler(@Nonnull Class&amp;lt;E&amp;gt; enumType) {
        this.enumType = enumType;
    }

    @Override
    public void setNonNullParameter(PreparedStatement preparedStatement, int i, E e, JdbcType jdbcType) throws SQLException {
        preparedStatement.setInt(i, e.getValue());
    }

    @Override
    public E getNullableResult(ResultSet rs, String columnName) throws SQLException {
        int value = rs.getInt(columnName);
        return rs.wasNull() ? null : EnumUtil.of(this.enumType, value);
    }

    @Override
    public E getNullableResult(ResultSet rs, int columnIndex) throws SQLException {
        int value = rs.getInt(columnIndex);
        return rs.wasNull() ? null : EnumUtil.of(this.enumType, value);
    }

    @Override
    public E getNullableResult(CallableStatement cs, int columnIndex) throws SQLException {
        int value = cs.getInt(columnIndex);
        return cs.wasNull() ? null : EnumUtil.of(this.enumType, value);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样我们就完成了从前台页面到业务代码到数据库的存储，从数据库查询到业务代码再到页面的枚举类转换。整个项目中完全不需要再手动去处理枚举类了。我们的开发流程简单了很多。&lt;/p&gt;
&lt;h2 id=&quot;结语&quot;&gt;结语&lt;/h2&gt;
&lt;p&gt;一个好的方案并不需要多么高大上的技术，比如各种反射，各种设计模式，只要设计合理，就是简单易用，类似中国古代的榫卯。&lt;/p&gt;
&lt;p&gt;ps: 打算3月中旬辞职去杭州，3年多点，有需要招人的可以先交流交流：微信（q408859832），个人吹牛扯淡技术探讨qq群（757696438）&lt;/p&gt;
</description>
<pubDate>Mon, 11 Feb 2019 15:05:00 +0000</pubDate>
<dc:creator>史亚健</dc:creator>
<og:description>背景描述 为了表达某一个属性，具备一组可选的范围，我们一般会采用两种方式。枚举类和数据字典，两者具有各自的优点。枚举类写在Java代码中，方便编写相应的判断逻辑，代码可读性高，枚举类中的属性是可提前预</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shiyajian/p/10363554.html</dc:identifier>
</item>
<item>
<title>多媒体文件格式（四）：TS 格式 - 灰色飘零</title>
<link>http://www.cnblogs.com/renhui/p/10362640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/renhui/p/10362640.html</guid>
<description>&lt;p&gt;TS是一种音视频封装格式，全称为MPEG2-TS。其中TS即&quot;Transport Stream&quot;的缩写。&lt;/p&gt;
&lt;p&gt;先简要介绍一下什么是MPEG2-TS：&lt;/p&gt;
&lt;p&gt;DVD的音视频格式为MPEG2-PS，全称是Program Stream。而TS的全称则是Transport Stream。MPEG2-PS主要应用于存储的具有固定时长的节目，如DVD电影，而MPEG-TS则主要应用于实时传送的节目，比如实时广播的电视节目。这两种格式的主要区别是什么呢？简单地打个比喻说，你将DVD上的VOB文件的前面一截cut掉（或者干脆就是数据损坏），那么就会导致整个文件无法解码了，而电视节目是你任何时候打开电视机都能解码（收看）的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，MPEG2-TS格式的特点就是要求从视频流的任一片段开始都是可以独立解码的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们可以看出，TS格式是主要用于直播的码流结构，具有很好的容错能力。通常TS流的后缀是.ts、.mpg或者.mpeg，多数播放器直接支持这种格式的播放。TS流中不包含快速seek的机制，只能通过协议层实现seek。HLS协议基于TS流实现的。&lt;/p&gt;
&lt;p&gt;TS格式分析工具：&lt;a href=&quot;https://pan.baidu.com/s/1wh1Ajxwv8T0vHwAYjI6PJA&quot; target=&quot;_blank&quot;&gt;https://pan.baidu.com/s/1wh1Ajxwv8T0vHwAYjI6PJA&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;TS文件（流）可以分为三层：TS层（Transport Stream）、PES层（Packet Elemental Stream）、ES层（Elementary Stream）。&lt;/p&gt;
&lt;p&gt;ES层就是音视频数据，PES层是在音视频数据上加了时间戳等对数据帧的说明信息，TS层是在PES层上加入了数据流识别和传输的必要信息。TS文件（码流）由多个TS Packet组成的。&lt;/p&gt;
&lt;p&gt;下图是TS文件（码流）的分层结构图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682616/201902/682616-20190211204923332-1306467199.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;原图可以在：&lt;a href=&quot;https://github.com/renhui/Thinking-in-AV/blob/master/%E5%A4%9A%E5%AA%92%E4%BD%93%E6%A0%BC%E5%BC%8F/TS/1.TS%E5%88%86%E5%B1%82%E7%BB%93%E6%9E%84.jpg&quot; target=&quot;_blank&quot;&gt;https://github.com/renhui/Thinking-in-AV/blob/master/多媒体格式/TS/1.TS分层结构.jpg&lt;/a&gt; 查看。&lt;/p&gt;

&lt;p&gt;TS包大小固定为188字节，TS层分为三个部分：TS Header、Adaptation Field、Payload。&lt;/p&gt;
&lt;p&gt;TS Header固定4个字节；Adaptation Field可能存在也可能不存在，主要作用是给不足188字节的数据做填充；Payload是PES数据。&lt;/p&gt;
&lt;h3&gt;1. TS Header&lt;/h3&gt;
&lt;p&gt;TS包的包头提供关于传输方面的信息。&lt;/p&gt;
&lt;p&gt;TS包的包头长度不固定，前4个字节是固定的，后面可能跟有自适应字段（适配域）。4个字节是最小包头。&lt;/p&gt;
&lt;p&gt;包头的结构体字段如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;sync_byte（同步字节）：固定为0x47;该字节由解码器识别，使包头和有效负载可相互分离。&lt;/li&gt;
&lt;li&gt;transport_error_indicator（传输错误标志）：‘1’表示在相关的传输包中至少有一个不可纠正的错误位。当被置1后，在错误被纠正之前不能重置为0。&lt;/li&gt;
&lt;li&gt;payload_unit_start_indicator（负载起始标志）：为1时，表示当前TS包的有效载荷中包含PES或者PSI的起始位置；在前4个字节之后会有一个调整字节，其的数值为后面调整字段的长度length。因此有效载荷开始的位置应再偏移1+[length]个字节。&lt;/li&gt;
&lt;li&gt;transport_priority（传输优先级标志）：‘1’表明当前TS包的优先级比其他具有相同PID， 但此位没有被置‘1’的TS包高。&lt;/li&gt;
&lt;li&gt;PID：指示存储与分组有效负载中数据的类型。&lt;/li&gt;
&lt;li&gt;transport_scrambling_control（加扰控制标志）：表示TS流分组有效负载的加密模式。空包为‘00’，如果传输包包头中包括调整字段，不应被加密。其他取值含义是用户自定义的。&lt;/li&gt;
&lt;li&gt;adaptation_field_control（适配域控制标志）：表示包头是否有调整字段或有效负载。‘00’为ISO/IEC未来使用保留；‘01’仅含有效载荷，无调整字段；‘10’ 无有效载荷，仅含调整字段；‘11’ 调整字段后为有效载荷，调整字段中的前一个字节表示调整字段的长度length，有效载荷开始的位置应再偏移[length]个字节。空包应为‘10’。&lt;/li&gt;
&lt;li&gt;continuity_counter（连续性计数器）：随着每一个具有相同PID的TS流分组而增加，当它达到最大值后又回复到0。范围为0~15。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. TS Adaptation Field&lt;/h3&gt;
&lt;p&gt;Adaptation Field的长度要包含传输错误指示符标识的一个字节。&lt;/p&gt;
&lt;p&gt;PCR是节目时钟参考，PCR、DTS、PTS都是对同一个系统时钟的采样值，PCR是递增的，因此可以将其设置为DTS值，音频数据不需要PCR。&lt;/p&gt;
&lt;p&gt;打包TS流时PAT和PMT表是没有Adaptation Field的，不够的长度直接补0xff即可。&lt;/p&gt;
&lt;p&gt;视频流和音频流都需要加adaptation field，通常加在一个帧的第一个ts包和最后一个ts包里，中间的ts包不加。&lt;/p&gt;
&lt;h3 id=&quot;ts包负载部分&quot;&gt;3. TS Payload&lt;/h3&gt;
&lt;p&gt;TS包中Payload所传输的信息包括两种类型：视频、音频的PES包以及辅助数据；节目专用信息PSI。&lt;/p&gt;
&lt;p&gt;TS包也可以是空包。空包用来填充TS流，可能在重新进行多路复用时被插入或删除。&lt;/p&gt;
&lt;p&gt;视频、音频的ES流需进行打包形成视频、音频的 PES流。辅助数据（如图文电视信息）不需要打成PES包。&lt;/p&gt;

&lt;h3&gt;1. PES层&lt;/h3&gt;
&lt;p&gt;PES结构如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/682616/201902/682616-20190211214448146-501104692.png&quot; alt=&quot;&quot; width=&quot;600&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的结构图可以看出，PES层是在每一个视频/音频帧上加入了时间戳等信息，PES包内容很多，下面我们说明一下最常用的字段：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;pes start code：开始码，固定为0x000001。&lt;/li&gt;
&lt;li&gt;stream id：音频取值（0xc0-0xdf），通常为0xc0；视频取值（0xe0-0xef），通常为0xe0。&lt;/li&gt;
&lt;li&gt;pes packet length：后面pes数据的长度，0表示长度不限制，只有视频数据长度会超过0xffff。&lt;/li&gt;
&lt;li&gt;pes data length：后面数据的长度，取值5或10。&lt;/li&gt;
&lt;li&gt;pts：33bit值&lt;/li&gt;
&lt;li&gt;dts：33bit值&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于时间戳PTS和DTS的说明：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;PTS是显示时间戳、DTS是解码时间戳。&lt;/li&gt;
&lt;li&gt;视频数据两种时间戳都需要，音频数据的PTS和DTS相同，所以只需要PTS。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;有PTS和DTS两种时间戳是B帧引起的，I帧和P帧的PTS等于DTS。如果一个视频没有B帧，则PTS永远和DTS相同。&lt;/p&gt;
&lt;p&gt;从文件中顺序读取视频帧，取出的帧顺序和DTS顺序相同。DTS算法比较简单，初始值 + 增量即可，PTS计算比较复杂，需要在DTS的基础上加偏移量。&lt;/p&gt;
&lt;p&gt;音频的PES中只有PTS（同DTS），视频的I、P帧两种时间戳都要有，视频B帧只要PTS（同DTS）。&lt;/p&gt;
&lt;h3&gt;2. ES 层&lt;/h3&gt;
&lt;p&gt;ES层指的就是音视频数据。&lt;/p&gt;
&lt;p&gt;一般的，视频为H.264视频，音频为AAC音频。&lt;/p&gt;

&lt;h3&gt;1. TS 流生成流程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;将原始音视频数据压缩之后，压缩结果组成一个基本码流（ES）。&lt;/li&gt;
&lt;li&gt;对ES（基本码流）进行打包形成PES。&lt;/li&gt;
&lt;li&gt;在PES包中加入时间戳信息(PTS/DTS)。&lt;/li&gt;
&lt;li&gt;将PES包内容分配到一系列固定长度的传输包（TS Packet）中。&lt;/li&gt;
&lt;li&gt;在传输包中加入定时信息(PCR)。&lt;/li&gt;
&lt;li&gt;在传输包中加入节目专用信息(PSI) 。&lt;/li&gt;
&lt;li&gt;连续输出传输包形成具有恒定比特率的MPEG-TS流。&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;2. TS 流解析流程&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;复用的MPEG-TS流中解析出TS包；&lt;/li&gt;
&lt;li&gt;从TS包中获取PAT及对应的PMT；&lt;/li&gt;
&lt;li&gt;从而获取特定节目的音视频PID；&lt;/li&gt;
&lt;li&gt;通过PID筛选出特定音视频相关的TS包，并解析出PES；&lt;/li&gt;
&lt;li&gt;从PES中读取到PTS/DTS，并从PES中解析出基本码流ES；&lt;/li&gt;
&lt;li&gt;将ES交给解码器，获得压缩前的原始音视频数据。&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Mon, 11 Feb 2019 14:59:00 +0000</pubDate>
<dc:creator>灰色飘零</dc:creator>
<og:description>一、TS 格式标准介绍 TS是一种音视频封装格式，全称为MPEG2-TS。其中TS即&quot;Transport Stream&quot;的缩写。 先简要介绍一下什么是MPEG2-TS： DVD的音</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/renhui/p/10362640.html</dc:identifier>
</item>
<item>
<title>Python中的@property装饰器 - szjshuffle</title>
<link>http://www.cnblogs.com/szjshuffle/p/10363463.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/szjshuffle/p/10363463.html</guid>
<description>&lt;p&gt;要了解@property的用途，首先要了解如何创建一个属性。&lt;/p&gt;
&lt;p&gt;一般而言，属性都通过__init__方法创建，比如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(object):
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self,name,score):
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         self.name=&lt;span&gt;name
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         self.score=score
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建实例，运行结果：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; tim=Student(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Tim&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,97&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; tim.score=100
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;tim.score 
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 100 
&lt;span&gt;5&lt;/span&gt; mary=Student(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mary&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,90&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; &lt;span&gt;mary.score 
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; 90
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是这样子有2个坏处：&lt;/p&gt;
&lt;p&gt;1.__init__ 中定义的属性是可变的，如果一个系统的开发人员在知道属性名的情况下，就可以进行随意更改(尽管可能是在无意识的情况下)，如果一不小心篡改了，后台排查很难！&lt;/p&gt;
&lt;p&gt;2.不利于进行参数检查，比如：score属性范围本该是[0,100],但如果输成了1000也不会报错。&lt;/p&gt;
&lt;p&gt;因此，一个标准的创建属性流程如下:&lt;/p&gt;
&lt;p&gt;1.定义三个跟属性(本例中是score)相关的函数：&lt;/p&gt;
&lt;p&gt;get(用于返回score属性)&lt;/p&gt;
&lt;p&gt;set(用于设定score属性)&lt;/p&gt;
&lt;p&gt;del(用于删除score属性)&lt;/p&gt;
&lt;p&gt;在set函数中，可以添加一些取值范围，比如[0,100].此外，为了私有化属性，前面可以加上__。&lt;/p&gt;
&lt;p&gt;这样就做到了既能通过创建实例设定属性，又不让开发人员轻易修改score属性。&lt;/p&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getScore(self):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setScore(self,score):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; score&amp;gt;100 &lt;span&gt;or&lt;/span&gt; score&amp;lt;&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; ValueError (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;score is out of range.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             self.&lt;span&gt;__score&lt;/span&gt;=&lt;span&gt;score
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; delScore(self):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;del&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样，一旦score取值不在设定范围内，就会报错！&lt;/p&gt;
&lt;p&gt;创建一个实例，能够正常运行：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; Mary=&lt;span&gt;Student()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; Mary.setScore(90&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; &lt;span&gt;Mary.getScore()
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 90
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是，通过方法getScore()查看分数似乎还是有点繁琐，能不能把它当作一个属性去调用呢?至少调用不需要输入()嘛！&lt;/p&gt;
&lt;p&gt;当然是可以的。&lt;/p&gt;
&lt;p&gt;办法就是通过装饰器：@property&lt;/p&gt;
&lt;p&gt;通过给getScore,setScore,delScore三个方法分别添加三个装饰器，就可以直接把这三个方法作为属性去调用了！&lt;/p&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getScore(self):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @getScore.setter
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setScore(self,score):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; score&amp;gt;100 &lt;span&gt;or&lt;/span&gt; score&amp;lt;&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; ValueError (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;score is out of range.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             self.&lt;span&gt;__score&lt;/span&gt;=&lt;span&gt;score
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @getScore.deleter
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; delScore(self):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;del&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; tim=&lt;span&gt;Student()
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; tim.setScore=90
&lt;span&gt;3&lt;/span&gt; &lt;span&gt;tim.getScore
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; 90
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;非常神奇！方法居然变成了属性，为什么呢？&lt;/p&gt;
&lt;p&gt;因为装饰器@property本质上是一个property()函数，property()函数也是一个装饰器。&lt;/p&gt;
&lt;p&gt;一般的装饰器是用在普通函数上，而@property是用在类内的方法上。&lt;/p&gt;
&lt;p&gt;property()函数包含了三个部分：getter,setter,deleter。&lt;/p&gt;
&lt;p&gt;因为setter和deleter是property()的第二和第三个参数，不能直接套用@语法。&lt;/p&gt;
&lt;p&gt;因此，本质上@property相当于getter部分，@setScore.setter相当于setter部分,@delScore.deleter相当于deleter部分。&lt;/p&gt;
&lt;p&gt;所以，上面的代码本质上等价于：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; getScore(self):
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; setScore(self,score):
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; score&amp;gt;100 &lt;span&gt;or&lt;/span&gt; score&amp;lt;&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; ValueError (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;score is out of range.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             self.&lt;span&gt;__score&lt;/span&gt;=&lt;span&gt;score
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     
&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; delScore(self):
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;del&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     
&lt;span&gt;14&lt;/span&gt;     score=property(getScore,setScore,delScore,&lt;span&gt;'&lt;/span&gt;&lt;span&gt;description&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后，为了函数名美观，可以把函数名字改成Score():&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Student(object):
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    @property
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Score(self):
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    @Score.setter
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; Score(self,score):
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; score&amp;gt;100 &lt;span&gt;or&lt;/span&gt; score&amp;lt;&lt;span&gt;0:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;raise&lt;/span&gt; ValueError (&lt;span&gt;'&lt;/span&gt;&lt;span&gt;score is out of range.&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             self.&lt;span&gt;__score&lt;/span&gt;=&lt;span&gt;score
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    @Score.deleter
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;def&lt;/span&gt;&lt;span&gt; delScore(self):
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;del&lt;/span&gt; self.&lt;span&gt;__score&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; tim=&lt;span&gt;Student()
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; tim.Score=90
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;tim.Score
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 90
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 几篇个人觉得写的比较清楚的文章：&lt;/p&gt;
&lt;p&gt;http://www.runoob.com/python/python-func-property.html&lt;/p&gt;
&lt;p&gt;https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/00143186781871161bc8d6497004764b398401a401d4cce000&lt;/p&gt;
&lt;p&gt;https://www.cnblogs.com/cicaday/p/python-decorator.html&lt;/p&gt;
</description>
<pubDate>Mon, 11 Feb 2019 14:37:00 +0000</pubDate>
<dc:creator>szjshuffle</dc:creator>
<og:description>要了解@property的用途，首先要了解如何创建一个属性。 一般而言，属性都通过__init__方法创建，比如： 创建实例，运行结果： 但是这样子有2个坏处： 1.__init__ 中定义的属性是可</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/szjshuffle/p/10363463.html</dc:identifier>
</item>
<item>
<title>DirectX11--深入理解与使用缓冲区资源 - X_Jun</title>
<link>http://www.cnblogs.com/X-Jun/p/10359345.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/X-Jun/p/10359345.html</guid>
<description>&lt;p&gt;在Direct3D 11中，缓冲区属于其中一种资源类型，它在内存上的布局是一维线性的。根据HLSL支持的类型以及C++的使用情况，缓冲区可以分为下面这些类型：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;顶点缓冲区(Vertex Buffer)&lt;/li&gt;
&lt;li&gt;索引缓冲区(Index Buffer)&lt;/li&gt;
&lt;li&gt;常量缓冲区(Constant Buffer)&lt;/li&gt;
&lt;li&gt;有类型的缓冲区(Typed Buffer)&lt;/li&gt;
&lt;li&gt;结构化缓冲区(Structured Buffer)&lt;/li&gt;
&lt;li&gt;追加/消耗缓冲区(Append/Consume Buffer)&lt;/li&gt;
&lt;li&gt;字节地址缓冲区(Byte Address Buffer)(未完工)&lt;/li&gt;
&lt;li&gt;间接参数缓冲区(Indirect Argument Buffer)(未完工)&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;因此这一章主要讲述上面这些资源的创建和使用方法&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;顾名思义，顶点缓冲区存放的是一连串的顶点数据，尽管缓冲区的数据实际上还是一堆二进制流，但在传递给输入装配阶段的时候，就会根据顶点输入布局将其装配成HLSL的顶点结构体数据。顶点缓冲区的数据可以用自定义的顶点结构体数组来初始化。顶点可以包含的成员有：顶点坐标(必须有)，顶点颜色，顶点法向量，纹理坐标，顶点切线向量等等。每个顶点的成员必须匹配合适的DXGI数据格式。&lt;/p&gt;
&lt;p&gt;当然，纯粹的顶点数组只是针对单个物体而言的。如果需要绘制大量相同的物体，需要同时用到多个顶点缓冲区。这允许你将顶点数据分开成多个顶点缓冲区来存放。&lt;/p&gt;
&lt;p&gt;这里还提供了顶点缓冲区的另一种形式：&lt;strong&gt;实例缓冲区&lt;/strong&gt;。我们可以提供一到多个的顶点缓冲区，然后再提供一个实例缓冲区。其中实例缓冲区存放的可以是物体的世界矩阵、世界矩阵的逆转置、材质等。这样做可以减少大量重复数据的产生，以及减少大量的CPU绘制调用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215032093-2131246589.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;createvertexbuffer函数--创建顶点缓冲区&quot;&gt;CreateVertexBuffer函数--创建顶点缓冲区&lt;/h2&gt;
&lt;p&gt;顶点缓冲区的创建需要区分下面两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;顶点数据是否需要动态更新&lt;/li&gt;
&lt;li&gt;是否需要绑定到流输出&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果顶点缓冲区在创建的时候提供了&lt;code&gt;D3D11_SUBRESOURCE_DATA&lt;/code&gt;来完成初始化，并且之后都不需要更新，则可以使用&lt;code&gt;D3D11_USAGE_IMMUTABLE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果顶点缓冲区需要频繁更新，则可以使用&lt;code&gt;D3D11_USAGE_DYNAMIC&lt;/code&gt;，并允许CPU写入(&lt;code&gt;D3D11_CPU_ACCESS_WRITE&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;如果顶点缓冲区需要绑定到流输出，则说明顶点缓冲区需要允许GPU写入，可以使用&lt;code&gt;D3D11_USAGE_DEFAULT&lt;/code&gt;，并且需要提供绑定标签&lt;code&gt;D3D11_BIND_STREAM_OUTPUT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下图说明了顶点缓冲区可以绑定的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215043698-1412046354.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;顶点缓冲区不需要创建资源视图，它可以直接绑定到输入装配阶段或流输出阶段。&lt;/p&gt;
&lt;p&gt;创建顶点缓冲区和一般的创建缓冲区函数如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ------------------------------
// CreateBuffer函数
// ------------------------------
// 创建缓冲区
// [In]d3dDevice            D3D设备
// [In]data                 初始化结构化数据
// [In]byteWidth            缓冲区字节数
// [Out]structuredBuffer    输出的结构化缓冲区
// [In]usage                资源用途
// [In]bindFlags            资源绑定标签
// [In]cpuAccessFlags       资源CPU访问权限标签
// [In]structuredByteStride 每个结构体的字节数
// [In]miscFlags            资源杂项标签
HRESULT CreateBuffer(
    ID3D11Device * d3dDevice,
    void * data,
    UINT byteWidth,
    ID3D11Buffer ** buffer,
    D3D11_USAGE usage,
    UINT bindFlags,
    UINT cpuAccessFlags,
    UINT structureByteStride,
    UINT miscFlags)
{
    D3D11_BUFFER_DESC bufferDesc;
    bufferDesc.Usage = usage;
    bufferDesc.ByteWidth = byteWidth;
    bufferDesc.BindFlags = bindFlags;
    bufferDesc.CPUAccessFlags = cpuAccessFlags;
    bufferDesc.StructureByteStride = structureByteStride;
    bufferDesc.MiscFlags = miscFlags;

    D3D11_SUBRESOURCE_DATA initData;
    ZeroMemory(&amp;amp;initData, sizeof(initData));
    initData.pSysMem = data;

    return d3dDevice-&amp;gt;CreateBuffer(&amp;amp;bufferDesc, &amp;amp;initData, buffer);
}


// ------------------------------
// CreateVertexBuffer函数
// ------------------------------
// [In]d3dDevice            D3D设备
// [In]data                 初始化数据
// [In]byteWidth            缓冲区字节数
// [Out]vertexBuffer        输出的顶点缓冲区
// [InOpt]dynamic           是否需要CPU经常更新
// [InOpt]streamOutput      是否还用于流输出阶段(不能与dynamic同时设为true)
HRESULT CreateVertexBuffer(
    ID3D11Device * d3dDevice,
    void * data,
    UINT byteWidth,
    ID3D11Buffer ** vertexBuffer,
    bool dynamic,
    bool streamOutput)
{
    UINT bindFlags = D3D11_BIND_VERTEX_BUFFER;
    D3D11_USAGE usage;
    UINT cpuAccessFlags = 0;
    if (dynamic &amp;amp;&amp;amp; streamOutput)
    {
        return E_INVALIDARG;
    }
    else if (!dynamic &amp;amp;&amp;amp; !streamOutput)
    {
        usage = D3D11_USAGE_IMMUTABLE;
    }
    else if (dynamic)
    {
        usage = D3D11_USAGE_DYNAMIC;
        cpuAccessFlags |= D3D11_CPU_ACCESS_WRITE;
    }
    else
    {
        bindFlags |= D3D11_BIND_STREAM_OUTPUT;
        usage = D3D11_USAGE_DEFAULT;
    }

    return CreateBuffer(d3dDevice, data, byteWidth, vertexBuffer,
        usage, bindFlags, cpuAccessFlags, 0, 0);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;索引缓冲区通常需要与顶点缓冲区结合使用，它的作用就是以索引的形式来引用顶点缓冲区中的某一顶点，并按索引缓冲区的顺序和图元类型来组装图元。它可以有效地减少顶点缓冲区中重复的顶点数据，从而减小网格模型占用的数据大小。使用相同的索引值就可以多次引用同一个顶点。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215108808-171970242.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;索引缓冲区的使用不需要创建资源视图，它仅用于输入装配阶段，并且在装配的时候你需要指定每个索引所占的字节数：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DXGI_FORMAT_R8_UINT&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;0-255&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;DXGI_FORMAT_R16_UINT&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;0-65535&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;DXGI_FORMAT_R32_UINT&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;0-2147483647&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;将索引缓冲区绑定到输入装配阶段后，你就可以用带Indexed的Draw方法，指定起始索引偏移值和索引数目来进行绘制。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215056328-435995086.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;createindexbuffer函数--创建索引缓冲区&quot;&gt;CreateIndexBuffer函数--创建索引缓冲区&lt;/h2&gt;
&lt;p&gt;索引缓冲区的创建只考虑数据是否需要动态更新。&lt;/p&gt;
&lt;p&gt;如果索引缓冲区在创建的时候提供了&lt;code&gt;D3D11_SUBRESOURCE_DATA&lt;/code&gt;来完成初始化，并且之后都不需要更新，则可以使用&lt;code&gt;D3D11_USAGE_IMMUTABLE&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果索引缓冲区需要频繁更新，则可以使用&lt;code&gt;D3D11_USAGE_DYNAMIC&lt;/code&gt;，并允许CPU写入(&lt;code&gt;D3D11_CPU_ACCESS_WRITE&lt;/code&gt;)。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ------------------------------
// CreateIndexBuffer函数
// ------------------------------
// [In]d3dDevice            D3D设备
// [In]data                 初始化数据
// [In]byteWidth            缓冲区字节数
// [Out]indexBuffer         输出的索引缓冲区
// [InOpt]dynamic           是否需要CPU经常更新
HRESULT CreateIndexBuffer(
    ID3D11Device * d3dDevice,
    void * data,
    UINT byteWidth,
    ID3D11Buffer ** indexBuffer,
    bool dynamic)
{
    D3D11_USAGE usage;
    UINT cpuAccessFlags = 0;
    if (dynamic)
    {
        usage = D3D11_USAGE_DYNAMIC;
        cpuAccessFlags |= D3D11_CPU_ACCESS_WRITE;
    }
    else
    {
        usage = D3D11_USAGE_IMMUTABLE;
    }

    return CreateBuffer(d3dDevice, data, byteWidth, indexBuffer,
        usage, D3D11_BIND_INDEX_BUFFER, cpuAccessFlags, 0, 0);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;常量缓冲区是我们接触到的第一个可以给所有可编程着色器程序使用的缓冲区。由于着色器函数的形参没法从C++端传入，我们只能通过类似全局变量的方式来让着色器函数访问，这些参数被打包在一个常量缓冲区中。而C++可以通过创建对应的常量缓冲区来绑定到HLSL对应的&lt;code&gt;cbuffer&lt;/code&gt;，以实现从C++到HLSL的数据的传递。C++的常量缓冲区是以字节流来对待；而HLSL的&lt;code&gt;cbuffer&lt;/code&gt;内部可以像结构体那样包含各种类型的参数，而且还需要注意它的打包规则。&lt;/p&gt;
&lt;p&gt;关于常量缓冲区，有太多值得需要注意的细节了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个着色器阶段最多允许15个常量缓冲区，并且每个缓冲区最多可以容纳4096个标量。HLSL的&lt;code&gt;cbuffer&lt;/code&gt;需要指定&lt;code&gt;register(b#)&lt;/code&gt;, &lt;code&gt;#&lt;/code&gt;的范围为0到14&lt;/li&gt;
&lt;li&gt;在C++创建常量缓冲区时大小必须为16字节的倍数，因为HLSL的常量缓冲区本身以及对它的读写操作需要严格按16字节对齐&lt;/li&gt;
&lt;li&gt;对常量缓冲区的成员使用&lt;code&gt;packoffset&lt;/code&gt;修饰符可以指定起始向量和分量位置&lt;/li&gt;
&lt;li&gt;在更新常量缓冲区时由于数据是提交完整的字节流数据到GPU，会导致HLSL中&lt;code&gt;cbuffer&lt;/code&gt;的所有成员都被更新。为了减少不必要的更新，可以根据这些参数的更新频率划分出多个常量缓冲区以节省带宽资源&lt;/li&gt;
&lt;li&gt;一个着色器在使用了多个常量缓冲区的情况下，这些常量缓冲区不能出现同名参数&lt;/li&gt;
&lt;li&gt;单个常量缓冲区可以同时绑定到不同的可编程着色器阶段，因为这些缓冲区都是只读的，不会导致内存访问冲突。一个包含常量缓冲区的&lt;code&gt;*.hlsli&lt;/code&gt;文件同时被多个着色器文件引用，只是说明这些着色器使用相同的常量缓冲区布局，如果该缓冲区需要在多个着色器阶段使用，你还需要在C++同时将相同的常量缓冲区绑定到各个着色器阶段上&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215144897-601823991.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;下面是一个HLSL常量缓冲区的例子(注释部分可省略，效果等价)：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;cbuffer CBChangesRarely : register(b2)
{
    matrix gView /* : packoffset(c0) */;
    float3 gSphereCenter /* : packoffset(c4.x) */;
    float gSphereRadius /* : packoffset(c4.w) */;
    float3 gEyePosW /* : packoffset(c5.x) */;
    float gPad /* : packoffset(c5.w) */;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;createconstantbuffer函数--创建常量缓冲区&quot;&gt;CreateConstantBuffer函数--创建常量缓冲区&lt;/h2&gt;
&lt;p&gt;常量缓冲区的创建需要区分下面两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;是否需要CPU经常更新&lt;/li&gt;
&lt;li&gt;是否需要GPU更新&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果常量缓冲区在创建的时候提供了&lt;code&gt;D3D11_SUBRESOURCE_DATA&lt;/code&gt;来完成初始化，并且之后都不需要更新，则可以使用&lt;code&gt;D3D11_USAGE_IMMUTABLE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果常量缓冲区需要频繁更新，则可以使用&lt;code&gt;D3D11_USAGE_DYNAMIC&lt;/code&gt;，并允许CPU写入(&lt;code&gt;D3D11_CPU_ACCESS_WRITE&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;如果常量缓冲区在较长的一段时间才需要更新一次，则可以考虑使用&lt;code&gt;D3D11_USAGE_DEFAULT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;下图说明了常量缓冲区可以绑定的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215154372-1799058996.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;常量缓冲区的使用同样不需要创建资源视图。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ------------------------------
// CreateConstantBuffer函数
// ------------------------------
// [In]d3dDevice            D3D设备
// [In]data                 初始化数据
// [In]byteWidth            缓冲区字节数，必须是16的倍数
// [Out]indexBuffer         输出的索引缓冲区
// [InOpt]cpuUpdates        是否允许CPU更新
// [InOpt]gpuUpdates        是否允许GPU更新
HRESULT CreateConstantBuffer(
    ID3D11Device * d3dDevice,
    void * data,
    UINT byteWidth,
    ID3D11Buffer ** constantBuffer,
    bool cpuUpdates,
    bool gpuUpdates)
{
    D3D11_USAGE usage;
    UINT cpuAccessFlags = 0;
    if (cpuUpdates &amp;amp;&amp;amp; gpuUpdates)
    {
        return E_INVALIDARG;
    }
    else if (!cpuUpdates &amp;amp;&amp;amp; !gpuUpdates)
    {
        usage = D3D11_USAGE_IMMUTABLE;
    }
    else if (cpuUpdates)
    {
        usage = D3D11_USAGE_DYNAMIC;
        cpuAccessFlags |= D3D11_CPU_ACCESS_WRITE;
    }
    else
    {
        usage = D3D11_USAGE_DEFAULT;
    }

    return CreateBuffer(d3dDevice, data, byteWidth, constantBuffer,
        usage, D3D11_BIND_CONSTANT_BUFFER, cpuAccessFlags, 0, 0);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;这是一种创建和使用起来最简单的缓冲区，但实际使用频率远不如上面所讲的三种缓冲区。它的数据可以在HLSL被解释成基本HLSL类型的数组形式。&lt;/p&gt;
&lt;p&gt;在HLSL中，如果是只读的缓冲区类型，则声明方式如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Buffer&amp;lt;float4&amp;gt; gBuffer : register(t0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要留意的是，当前缓冲区和纹理需要共用纹理寄存器，即t#，因此要注意和纹理避开使用同一个寄存器槽。&lt;/p&gt;
&lt;p&gt;如果是可读写的缓冲区类型，则声明方式如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;RWBuffer&amp;lt;float4&amp;gt; gRWBuffer : register(u0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有类型的缓冲区具有下面的方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;void GetDimensions(out uint)&lt;/td&gt;
&lt;td&gt;获取资源各个维度下的大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T Load(in int)&lt;/td&gt;
&lt;td&gt;按一维索引读取缓冲区数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T Operator&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Buffer&lt;/code&gt;仅允许读取，&lt;code&gt;RWBuffer&lt;/code&gt;允许读写&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;有类型的缓冲区需要创建着色器资源视图以绑定到对应的着色器阶段。由于HLSL的语法知识定义了有限的类型和元素数目，但在&lt;code&gt;DXGI_FORMAT&lt;/code&gt;中，有许多种成员都能够用于匹配一种HLSL类型。比如，HLSL的&lt;code&gt;float4&lt;/code&gt;你可以使用&lt;code&gt;DXGI_FORMAT_R32G32B32A32_FLOAT&lt;/code&gt;, &lt;code&gt;DXGI_FORMAT_R16G16B16A16_FLOAT&lt;/code&gt;或&lt;code&gt;DXGI_FORMAT_R8G8B8A8_UNORM&lt;/code&gt;。而HLSL的&lt;code&gt;int2&lt;/code&gt;你可以使用&lt;code&gt;DXGI_FORMAT_R32G32_SINT&lt;/code&gt;，&lt;code&gt;DXGI_FORMAT_R16G16_SINT&lt;/code&gt;或&lt;code&gt;DXGI_FORMAT_R8G8_SINT&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215228991-1520906562.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;createtypedbuffer函数--创建有类型的缓冲区&quot;&gt;CreateTypedBuffer函数--创建有类型的缓冲区&lt;/h2&gt;
&lt;p&gt;有类型的缓冲区通常需要绑定到着色器上作为资源使用，因此需要将&lt;code&gt;bindFlags&lt;/code&gt;设为&lt;code&gt;D3D11_BIND_SHADER_RESOURCE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;此外，有类型的缓冲区的创建需要区分下面两种情况：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;是否允许CPU写入/读取&lt;/li&gt;
&lt;li&gt;是否允许GPU写入&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;如果缓冲区在创建的时候提供了&lt;code&gt;D3D11_SUBRESOURCE_DATA&lt;/code&gt;来完成初始化，并且之后都不需要更新，则可以使用&lt;code&gt;D3D11_USAGE_IMMUTABLE&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果缓冲区需要频繁更新，则可以使用&lt;code&gt;D3D11_USAGE_DYNAMIC&lt;/code&gt;，并允许CPU写入(&lt;code&gt;D3D11_CPU_ACCESS_WRITE&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;如果缓冲区需要允许GPU写入，说明后面可能需要创建UAV绑定到&lt;code&gt;RWBuffer&amp;lt;T&amp;gt;&lt;/code&gt;，为此还需要给&lt;code&gt;bindFlags&lt;/code&gt;添加&lt;code&gt;D3D11_BIND_UNORDERED_ACCESS&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果缓冲区的数据需要读出到内存，则可以使用&lt;code&gt;D3D11_USAGE_STAGING&lt;/code&gt;，并允许CPU读取(&lt;code&gt;D3D11_CPU_ACCESS_READ&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;下图说明了有类型的(与结构化)缓冲区可以绑定的位置：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215247062-280596029.png&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ------------------------------
// CreateTypedBuffer函数
// ------------------------------
// [In]d3dDevice            D3D设备
// [In]data                 初始化数据
// [In]byteWidth            缓冲区字节数
// [Out]typedBuffer         输出的有类型的缓冲区
// [InOpt]cpuUpdates        是否允许CPU更新
// [InOpt]gpuUpdates        是否允许使用RWBuffer
HRESULT CreateTypedBuffer(
    ID3D11Device * d3dDevice,
    void * data,
    UINT byteWidth,
    ID3D11Buffer ** typedBuffer,
    bool cpuUpdates,
    bool gpuUpdates)
{
    UINT bindFlags = D3D11_BIND_SHADER_RESOURCE;
    D3D11_USAGE usage;
    UINT cpuAccessFlags = 0;
    if (cpuUpdates &amp;amp;&amp;amp; gpuUpdates)
    {
        bindFlags = 0;
        usage = D3D11_USAGE_STAGING;
        cpuAccessFlags |= D3D11_CPU_ACCESS_READ;
    }
    else if (!cpuUpdates &amp;amp;&amp;amp; !gpuUpdates)
    {
        usage = D3D11_USAGE_IMMUTABLE;
    }
    else if (cpuUpdates)
    {
        usage = D3D11_USAGE_DYNAMIC;
        cpuAccessFlags |= D3D11_CPU_ACCESS_WRITE;
    }
    else
    {
        usage = D3D11_USAGE_DEFAULT;
        bindFlags |= D3D11_BIND_UNORDERED_ACCESS;
    }

    return CreateBuffer(d3dDevice, data, byteWidth, typedBuffer,
        usage, bindFlags, cpuAccessFlags, 0, 0);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于追加/消耗缓冲区，我们后面再讨论。&lt;/p&gt;
&lt;p&gt;如果我们希望它作为&lt;code&gt;Buffer&amp;lt;float4&amp;gt;&lt;/code&gt;使用，则需要创建着色器资源视图：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
srvDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
srvDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
srvDesc.Buffer.FirstElement = 0;            // 起始元素的索引
srvDesc.Buffer.NumElements = numElements;   // 元素数目

HR(md3dDevice-&amp;gt;CreateShaderResourceView(mBuffer.Get(), &amp;amp;srvDesc, mBufferSRV.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果我们希望它作为&lt;code&gt;RWBuffer&amp;lt;float4&amp;gt;&lt;/code&gt;使用，则需要创建无序访问视图：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_UNORDERED_ACCESS_VIEW_DESC uavDesc;
uavDesc.Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
uavDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
uavDesc.Buffer.FirstElement = 0;            // 起始元素的索引
uavDesc.Buffer.Flags = 0;
uavDesc.Buffer.NumElements = numElements;   // 元素数目

md3dDevice-&amp;gt;CreateUnorderedAccessView(mBuffer.Get(), &amp;amp;uavDesc, mBufferUAV.GetAddressOf());&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;将缓冲区保存的结果拷贝到内存&quot;&gt;将缓冲区保存的结果拷贝到内存&lt;/h2&gt;
&lt;p&gt;由于这些缓冲区仅支持GPU读取，我们需要另外新建一个缓冲区以允许它CPU读取和GPU写入(STAGING)，然后将保存结果的缓冲区拷贝到该缓冲区，再映射出内存即可：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;HR(CreateTypedBuffer(md3dDevice.Get(), nullptr, sizeof data,
    mBufferOutputCopy.GetAddressOf(), true, true));

md3dImmediateContext-&amp;gt;CopyResource(mVertexOutputCopy.Get(), mVertexOutput.Get());
D3D11_MAPPED_SUBRESOURCE mappedData;
HR(md3dImmediateContext-&amp;gt;Map(mVertexOutputCopy.Get(), 0, D3D11_MAP_READ, 0, &amp;amp;mappedData));
memcpy_s(data, sizeof data, mappedData.pData, sizeof data);
md3dImmediateContext-&amp;gt;Unmap(mVertexOutputCopy.Get(), 0);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;结构化缓冲区可以说是缓冲区的复合形式，它允许模板类型&lt;code&gt;T&lt;/code&gt;是用户自定义的类型，即缓冲区存放的内容可以被解释为结构体数组。&lt;/p&gt;
&lt;p&gt;现在HLSL有如下结构体：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;struct Data
{
    float3 v1;
    float2 v2;
};&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是只读的结构化缓冲区，则声明方式如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;StructuredBuffer&amp;lt;Data&amp;gt; gStructuredBuffer : register(t0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果是可读写的结构化缓冲区类型，则声明方式如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;RWStructuredBuffer&amp;lt;Data&amp;gt; gRWStructuredBuffer : register(u0);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结构化缓冲区也具有下面的方法：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;4&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;void GetDimensions(out uint)&lt;/td&gt;
&lt;td&gt;获取资源各个维度下的大小&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T Load(in int)&lt;/td&gt;
&lt;td&gt;按一维索引读取结构化缓冲区数据&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;T Operator&lt;/td&gt;
&lt;td&gt;&lt;code&gt;StructuredBuffer&lt;/code&gt;仅允许读取，&lt;code&gt;RWStructuredBuffer&lt;/code&gt;允许读写&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215255507-154448541.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;createstructuredbuffer函数--创建结构化缓冲区&quot;&gt;CreateStructuredBuffer函数--创建结构化缓冲区&lt;/h2&gt;
&lt;p&gt;结构化缓冲区的创建和有类型的缓冲区创建比较相似，区别在于：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;需要在&lt;code&gt;MiscFlags&lt;/code&gt;指定&lt;code&gt;D3D11_RESOURCE_MISC_BUFFER_STRUCTURED&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;需要额外提供&lt;code&gt;structureByteStride&lt;/code&gt;说明结构体的大小&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;// ------------------------------
// CreateStructuredBuffer函数
// ------------------------------
// 如果需要创建Append/Consume Buffer，需指定cpuUpdates为false, gpuUpdates为true
// [In]d3dDevice            D3D设备
// [In]data                 初始化数据
// [In]byteWidth            缓冲区字节数
// [In]structuredByteStride 每个结构体的字节数
// [Out]structuredBuffer    输出的结构化缓冲区
// [InOpt]cpuUpdates        是否允许CPU更新
// [InOpt]gpuUpdates        是否允许使用RWStructuredBuffer
HRESULT CreateStructuredBuffer(
    ID3D11Device * d3dDevice,
    void * data,
    UINT byteWidth,
    UINT structuredByteStride,
    ID3D11Buffer ** structuredBuffer,
    bool cpuUpdates,
    bool gpuUpdates)
{
    UINT bindFlags = D3D11_BIND_SHADER_RESOURCE;
    D3D11_USAGE usage;
    UINT cpuAccessFlags = 0;
    if (cpuUpdates &amp;amp;&amp;amp; gpuUpdates)
    {
        bindFlags = 0;
        usage = D3D11_USAGE_STAGING;
        cpuAccessFlags |= D3D11_CPU_ACCESS_READ;
    }
    else if (!cpuUpdates &amp;amp;&amp;amp; !gpuUpdates)
    {
        usage = D3D11_USAGE_IMMUTABLE;
    }
    else if (cpuUpdates)
    {
        usage = D3D11_USAGE_DYNAMIC;
        cpuAccessFlags |= D3D11_CPU_ACCESS_WRITE;
    }
    else
    {
        usage = D3D11_USAGE_DEFAULT;
        bindFlags |= D3D11_BIND_UNORDERED_ACCESS;
    }

    return CreateBuffer(d3dDevice, data, byteWidth, structuredBuffer,
        usage, bindFlags, cpuAccessFlags, structuredByteStride, 
        D3D11_RESOURCE_MISC_BUFFER_STRUCTURED);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;无论是SRV还是UAV，在指定&lt;code&gt;Format&lt;/code&gt;时只能指定&lt;code&gt;DXGI_FORMAT_UNKNOWN&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果我们希望它作为&lt;code&gt;StructuredBuffer&amp;lt;Data&amp;gt;&lt;/code&gt;使用，则需要创建着色器资源视图：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_SHADER_RESOURCE_VIEW_DESC srvDesc;
srvDesc.Format = DXGI_FORMAT_UNKNOWN;
srvDesc.ViewDimension = D3D11_SRV_DIMENSION_BUFFER;
srvDesc.Buffer.FirstElement = 0;            // 起始元素的索引
srvDesc.Buffer.NumElements = numElements;   // 元素数目

HR(md3dDevice-&amp;gt;CreateShaderResourceView(mBuffer.Get(), &amp;amp;srvDesc, mBufferSRV.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果我们希望它作为&lt;code&gt;RWStructuredBuffer&amp;lt;float4&amp;gt;&lt;/code&gt;使用，则需要创建无序访问视图：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_UNORDERED_ACCESS_VIEW_DESC uavDesc;
uavDesc.Format = DXGI_FORMAT_UNKNOWN;
uavDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
uavDesc.Buffer.FirstElement = 0;            // 起始元素的索引
uavDesc.Buffer.Flags = 0;
uavDesc.Buffer.NumElements = numElements;   // 元素数目

md3dDevice-&amp;gt;CreateUnorderedAccessView(mBuffer.Get(), &amp;amp;uavDesc, mBufferUAV.GetAddressOf());&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;追加缓冲区和消耗缓冲区类型实际上是结构化缓冲区的特殊变体资源。因为涉及到修改操作，它们都只能以无序访问视图的方式来使用。如果你只是希望这些结构体数据经过着色器变换并且不需要考虑最终的输出顺序要一致，那么使用这两个缓冲区是一种不错的选择。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;ConsumeStructuredBuffer&amp;lt;float3&amp;gt; gVertexIn : register(u0);
AppendStructuredBuffer&amp;lt;float3&amp;gt; gVertexOut : register(u1);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在HLSL中，&lt;code&gt;AppendStructuredBuffer&lt;/code&gt;仅提供了&lt;code&gt;Append&lt;/code&gt;方法用于尾端追加成员；而&lt;code&gt;ConsumeStructuredBuffer&lt;/code&gt;则仅提供了&lt;code&gt;Consume&lt;/code&gt;方法用于消耗尾端成员。这两种操作实际上可以看做是对栈的操作。此外，你也可以使用&lt;code&gt;GetDimensions&lt;/code&gt;方法来获取当前缓冲区还剩下多少元素。&lt;/p&gt;
&lt;p&gt;一旦某个线程消耗了一个数据元素，就不能再被另一个线程给消耗掉，并且一个线程将只消耗一个数据。需要注意的是，因为线程之间的执行顺序是不确定的，因此无法根据线程ID来确定当前消耗的是哪个索引的资源。&lt;/p&gt;
&lt;p&gt;此外，追加/消耗缓冲区实际上并不能动态增长，你必须在创建缓冲区的时候就要分配好足够大的空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1172605/201902/1172605-20190211215309027-307056265.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;追加消耗缓冲区的创建&quot;&gt;追加/消耗缓冲区的创建&lt;/h2&gt;
&lt;p&gt;追加/消耗缓冲区可以经由&lt;code&gt;CreateStructuredBuffer&lt;/code&gt;函数来创建，需要指定&lt;code&gt;cpuUpdates&lt;/code&gt;为&lt;code&gt;false&lt;/code&gt;, &lt;code&gt;gpuUpdates&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;比较关键的是UAV的创建，需要像结构化缓冲区一样指定&lt;code&gt;Format&lt;/code&gt;为&lt;code&gt;DXGI_FORMAT_UNKNOWN&lt;/code&gt;。并且无论是追加缓冲区，还是消耗缓冲区，都需要在&lt;code&gt;Buffer.Flags&lt;/code&gt;中指定&lt;code&gt;D3D11_BUFFER_UAV_FLAG_APPEND&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;D3D11_UNORDERED_ACCESS_VIEW_DESC uavDesc;
uavDesc.Format = DXGI_FORMAT_UNKNOWN;
uavDesc.ViewDimension = D3D11_UAV_DIMENSION_BUFFER;
uavDesc.Buffer.FirstElement = 0;            // 起始元素的索引
uavDesc.Buffer.Flags = D3D11_BUFFER_UAV_FLAG_APPEND;
uavDesc.Buffer.NumElements = numElements;   // 元素数目
HR(md3dDevice-&amp;gt;CreateUnorderedAccessView(mVertexInput.Get(), &amp;amp;uavDesc, mVertexInputUAV.GetAddressOf()));&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在将UAV绑定到着色器时，如果是追加缓冲区，通常需要指定初始元素数目为0，然后提供给&lt;code&gt;ID3D11DeviceContext::*SSetUnorderedAccessViews&lt;/code&gt;方法的最后一个参数：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;UINT initCounts[1] = { 0 };
md3dImmediateContext-&amp;gt;CSSetUnorderedAccessViews(0, 1, mVertexInputUAV.GetAddressOf(), initCounts);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;而如果是消耗缓冲区，则需要指定初始元素数目：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;UINT initCounts[1] = { numElements };
md3dImmediateContext-&amp;gt;CSSetUnorderedAccessViews(1, 1, mVertexInputUAV.GetAddressOf(), initCounts);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;(未完待续)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;http://www.cnblogs.com/X-Jun/p/9028764.html&quot;&gt;DirectX11 With Windows SDK完整目录&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/MKXJun/DirectX11-With-Windows-SDK&quot;&gt;Github项目源码&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;欢迎加入QQ群: 727623616 可以一起探讨DX11，以及有什么问题也可以在这里汇报。&lt;/strong&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 11 Feb 2019 14:17:00 +0000</pubDate>
<dc:creator>X_Jun</dc:creator>
<og:description>前言 在Direct3D 11中，缓冲区属于其中一种资源类型，它在内存上的布局是一维线性的。根据HLSL支持的类型以及C++的使用情况，缓冲区可以分为下面这些类型： 1. 顶点缓冲区(Vertex B</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/X-Jun/p/10359345.html</dc:identifier>
</item>
<item>
<title>自定义npm包的创建、发布、更新和撤销 - 前端路上的小兵</title>
<link>http://www.cnblogs.com/shcrk/p/10363369.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shcrk/p/10363369.html</guid>
<description>&lt;h3&gt;大纲&lt;/h3&gt;
&lt;p&gt;1、准备&lt;br/&gt;2、自定义npm包&lt;br/&gt;3、发布自定义npm包&lt;br/&gt;4、引用npm包&lt;br/&gt;5、更新npm包&lt;br/&gt;6、撤销发布的npm包&lt;/p&gt;
&lt;h3&gt;简书原文&lt;/h3&gt;
&lt;p&gt;https://www.jianshu.com/p/d737bc5df5b7&lt;/p&gt;
&lt;h3&gt;1、准备&lt;/h3&gt;
&lt;h4&gt;1.1、注册npm用户&lt;/h4&gt;
&lt;p&gt;npm官网(https://www.npmjs.com/)&lt;/p&gt;
&lt;h4&gt;1.2、安装nodeJs&lt;/h4&gt;
&lt;p&gt;Node.js官网(http://nodejs.cn/)&lt;/p&gt;
&lt;h4&gt;1.3、编辑器&lt;/h4&gt;
&lt;p&gt;我使用的是编辑器vscode进行操作的，读者也可以打开控制台进入到对应目录中进行操作&lt;/p&gt;
&lt;h3&gt;2、创建自己的npm包&lt;/h3&gt;
&lt;h4&gt;2.1、创建一个空的文件夹,进入&lt;/h4&gt;
&lt;h4&gt;2.2、创建一个默认的npm包&lt;/h4&gt;
&lt;p&gt;在当前文件夹中执行控制台命令：&lt;/p&gt;

&lt;p&gt;1、执行npm init之后需要一步一步的填写对应信息，这些信息也就是你的npm的信息,在生成的package.json中会自动填入(如下图)&lt;br/&gt;2、可以执行npm init -y, 这样就会帮你创建一个默认配置的package.json而不需要自己一步步配置&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
//默认配置的package.json如下所示：
{
  &quot;name&quot;: &quot;npm-demo&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;main&quot;: &quot;index.js&quot;,
  &quot;scripts&quot;: {
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;amp;&amp;amp; exit 1&quot;
  },
  &quot;keywords&quot;: [],
  &quot;author&quot;: &quot;&quot;,
  &quot;license&quot;: &quot;ISC&quot;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211215052925-1193238314.png&quot; alt=&quot;&quot; width=&quot;804&quot; height=&quot;433&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.3、创建一个index.js文件作为包入口文件&lt;/h4&gt;
&lt;p&gt; 当然这是默认的入口文件,如果有其他想法的话，完全可以在package.json中进行修改。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211215125180-123945023.png&quot; alt=&quot;&quot; width=&quot;581&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.4、index.js&lt;/h4&gt;
&lt;p&gt; index.js就是你这个包的入口文件,你可以在里面做你想要的操作&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211215201844-1217736904.png&quot; alt=&quot;&quot; width=&quot;847&quot; height=&quot;449&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;2.5、node index.js&lt;/h4&gt;
&lt;p&gt; 最简单的内容就是打印一个日志,这时候你可以通过执行node index.js来执行index.js中的内容,可以看到控制台中打印出了你想要的信息&lt;/p&gt;
&lt;h4&gt; 2.6、改进index.js&lt;/h4&gt;
&lt;p&gt; 当然我们不可能就为了打印一个日志而创建一个npm包，我们需要可以引入这个npm包并调用这个包中的一些方法,因此我们队这个npm包中的index.js中的内容进行完善一些。&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
exports.testDemo = function() {
  console.log(&quot;this is test demo!!!!!!&quot;);
};
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3、发布npm包&lt;/h3&gt;
&lt;h4&gt;3.1、登录npm(添加用户)&lt;/h4&gt;
&lt;p&gt; 添加npm用户,或者说登录你的npm账号&lt;br/&gt;执行： npm adduser&lt;br/&gt;然后会提示你输入你的用户名和密码以及邮箱,如果输入正确会提示你成功登录&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211215326019-2138488470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3.2、npm publish&lt;/h4&gt;
&lt;p&gt;当你成功登录之后,就可以发布你的npm包了。&lt;br/&gt;执行： npm publish&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211215353650-802627702.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;3.3、注意：&lt;/h4&gt;
&lt;p&gt; 可能你在publish的时候会出现如下错误&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211220643633-86176425.png&quot; alt=&quot;&quot; width=&quot;660&quot; height=&quot;295&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么可能性有两个：&lt;br/&gt;1、你没有执行npm adduser进行登录&lt;br/&gt;2、可能你的包名重复了。&lt;br/&gt;如这里的npm-demo可能重复了所以导致无法publish上,这时最简单的方法是改包名,加上一个特殊的标志即可,改包名只需要对package.json中的name进行修改即可。(此处我将npm-demo改成npm-demo-crk之后再次执行npm publish就成功了)&lt;/p&gt;
&lt;h3&gt; 4、引用npm包&lt;/h3&gt;
&lt;h4&gt; 4.1、创建一个案例&lt;/h4&gt;
&lt;p&gt;想要引用npm包首先你要有个基本的案例,创建这个案例的方法和创建npm包其实是差不多的:&lt;br/&gt;执行：npm init -y&lt;br/&gt;创建一个index.js的入口文件&lt;br/&gt;这样就创建了一个案例了.&lt;/p&gt;
&lt;h4&gt; 4.2、下载依赖包&lt;/h4&gt;
&lt;p&gt;创建完案例之后就是引入npm包了&lt;br/&gt;执行：npm install -save-dev crk-demo-crk&lt;br/&gt;(或者： npm install crk-demo-crk)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211220827536-782765104.png&quot; alt=&quot;&quot; width=&quot;814&quot; height=&quot;404&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;4.3、调用npm包中的文件&lt;/h4&gt;
&lt;p&gt; 通过require来调用文件从而引用npm包中的方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
var test = require(&quot;npm-demo-crk&quot;);
test.testDemo();
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.4、运行&lt;/h4&gt;
&lt;p&gt; 执行命令即可运行案例,可以看到控制台成功调用了方法打印出了日志&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
node index.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211221014445-1683869888.png&quot; alt=&quot;&quot; width=&quot;615&quot; height=&quot;288&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;5、更新npm包&lt;/h3&gt;
&lt;h4&gt;5.1、更改版本号&lt;/h4&gt;
&lt;p&gt;最简单方式无非就是改package.json关于版本&lt;br/&gt;或者可以执行命令： npm version 1.0.1 同样可以起到作用&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211221049217-1384828274.png&quot; alt=&quot;&quot; width=&quot;568&quot; height=&quot;243&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5.2、更新版本——发布版本&lt;/h4&gt;
&lt;p&gt;更新npm包同样是执行npm publish即可，&lt;br/&gt;可以看到publish的包已经更新了&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211221118249-683811819.png&quot; alt=&quot;&quot; width=&quot;603&quot; height=&quot;308&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;5.3、更新依赖包&lt;/h4&gt;
&lt;p&gt;同样是执行： npm install -save-dev crk-demo-crk&lt;br/&gt;这样会更新最新的包到node_module中&lt;br/&gt;当然可能由于各种原因导致你更新的包还没有在npm上更新或者说你更新下来的依旧是旧的包。&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211221146545-172039561.png&quot; alt=&quot;&quot; width=&quot;840&quot; height=&quot;437&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;6、撤销发布的npm包&lt;/h3&gt;
&lt;p&gt;我们现在发布的这个npm包只是测试用的或者只是用作其他作用而不是要发布到网上真的使用的，最好还是撤销下来。&lt;br/&gt;执行命令： npm --force unpublish npm-demo-crk&lt;br/&gt;需要注意的是：&lt;br/&gt;1、撤销npm包需要加上 --force强制执行才可以实现;&lt;br/&gt;2、撤销的包不能立马再次发布&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211221220741-129789008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;撤销的包不能立马再次发布&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1424035/201902/1424035-20190211221228106-2067920713.png&quot; alt=&quot;&quot; width=&quot;709&quot; height=&quot;284&quot;/&gt;&lt;/p&gt;
&lt;h4&gt;参考网址&lt;/h4&gt;
&lt;p&gt;https://docs.npmjs.com/creating-and-publishing-unscoped-public-packages&lt;br/&gt;https://www.jianshu.com/p/9a9ed7eaf655&lt;br/&gt;https://www.cnblogs.com/marymei0107/p/6339710.html&lt;/p&gt;

</description>
<pubDate>Mon, 11 Feb 2019 14:15:00 +0000</pubDate>
<dc:creator>前端路上的小兵</dc:creator>
<og:description>大纲 1、准备2、自定义npm包3、发布自定义npm包4、引用npm包5、更新npm包6、撤销发布的npm包 简书原文 https://www.jianshu.com/p/d737bc5df5b7 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shcrk/p/10363369.html</dc:identifier>
</item>
</channel>
</rss>