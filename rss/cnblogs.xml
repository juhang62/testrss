<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>js原型链 - java小新人</title>
<link>http://www.cnblogs.com/wyq1995/p/11103179.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wyq1995/p/11103179.html</guid>
<description>&lt;p&gt;　　说实话js这门语言以前没有仔细研究过，现在研究起来感觉好麻烦，对于原型链这个说法我也是刚接触不久，就试着说说我的理解吧！&lt;/p&gt;
&lt;p&gt;　　关于上一篇我们说了js整个函数体系结构，想了解的可以&lt;a href=&quot;https://www.cnblogs.com/wyq1995/p/11015784.html&quot; target=&quot;_blank&quot;&gt;点击这里&lt;/a&gt;，这里随便找到一些对原型的小测试，你可以看看会不会，其中Person是一个构造函数，person1是构造函数的一个实例；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　person1.__proto__&lt;/code&gt; 是什么？//person1.__proto__ == Person.prototype&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　Person.__proto__&lt;/code&gt; 是什么？//&lt;code&gt;Person.__proto__&lt;/code&gt;  == Function.prototype&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　Person.prototype.__proto__&lt;/code&gt; 是什么？//Person.prototype.__proto__ == Object.prototype&lt;/p&gt;
&lt;p&gt;&lt;code&gt;　　Object.__proto__&lt;/code&gt; 是什么？//Object.__proto__ == Function.prototype&lt;/p&gt;
&lt;p&gt;　　&lt;code&gt;Object.prototype__proto__&lt;/code&gt; 是什么？//Object.prototype__proto__ == null&lt;/p&gt;
&lt;p&gt;知道了这些就差不多了，我们继续看；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.特殊的Math和JSON&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　这两个内置对象有点不同，上次还没有注意看，因为其他的内置对象都是Function的实例，比如Date，Number等，举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
Date &lt;span&gt;instanceof&lt;/span&gt; Function &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
Date.constructor == Function &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
Date.__proto__ == Function.prototype &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　但是当我们用Math对象和JSON对象测试的时候确实false，其实可以把Math和JSON对象看作Object的实例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
//Math和JSON一样，这里以Math为例&lt;br/&gt;Math &lt;span&gt;instanceof&lt;/span&gt; Object &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
Math.constructor == Object &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
Math.__proto__ == Object.prototype &lt;span&gt;//&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这两个对象比较特殊，注意一下和其他的内置对象一定要分开！！！&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.继承&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　继承可以说是每一个面向对象语言肯定有的，因为符合我们现实的想法，子承父业嘛！如果你爸比较有钱，你继承了几个亿的家产肯定一生无忧；如果你爸是个普通人，那即使继承了家产也没有多少啊！还是要靠自己奋斗。&lt;/p&gt;
&lt;p&gt;　　在js中的继承也一个样，如果一个构造函数设计得很好，那么儿子等后代就会很舒服啊！继承的话，从Object开始，下图所示，你看Object中你觉得哪个部分最重要，应该被继承下去，当然是原型啊！所以说继承就是指的是原型中的所有东西都会被继承到后代中。。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201906/1368608-20190628140810216-327622301.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　我们可以验证一下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Object.prototype.say = &lt;span&gt;function&lt;/span&gt;(){alert(&quot;你好！&quot;&lt;span&gt;)};
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; obj = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
obj.say();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;页面会有弹窗“你好！“，说明在obj实例中调用的say方法其实就是调用的是Object中原型中的say方法&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt;还可以用另外一个方式，就是用Math或者JSON对象也会有同样的效果&lt;/span&gt;
Object.prototype.say = &lt;span&gt;function&lt;/span&gt;(){alert(&quot;你好！&quot;&lt;span&gt;)};
Math.say();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　这个可能有点晦涩难懂，不要紧我们继续往下看！看了他们的调用机制就懂了；&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.js方法调用机制&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　简单测试一下,我就是分别在Object原型内外，构造函数Person原型内外，以及per实例中写了一些方法，可能很多人看着都头晕了。。。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
Object.say = &lt;span&gt;function&lt;/span&gt;(){alert(&quot;object----say&quot;&lt;span&gt;)}
Object.listen &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(){alert(&quot;object----listen&quot;&lt;span&gt;)}
Object.prototype.say &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(){alert(&quot;Object.prototype---say&quot;&lt;span&gt;)};
Object.prototype.listen &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(){alert(&quot;Object.prototype---listen&quot;&lt;span&gt;)};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; Person = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Function();
Person.say &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(){alert(&quot;Person&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;say&quot;&lt;span&gt;)};
Person.run &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(){alert(&quot;Person&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;run&quot;&lt;span&gt;)};&lt;br/&gt;Person.listen = function(){alert(&quot;Person&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;listen&quot;)};
Person.prototype.say &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(){alert(&quot;Person.prototype&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;say&quot;&lt;span&gt;)};
Person.prototype.run &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(){alert(&quot;Person.prototype&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;run&quot;&lt;span&gt;)};

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; per = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
per.say &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(){alert(&quot;per+++++++say&quot;&lt;span&gt;)};

per.say();    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;per+++++++say&lt;/span&gt;
per.listen();     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Object.prototype---listen&lt;/span&gt;
per.run();     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;Person.prototype&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;run&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt; 　　上面的太繁琐，没耐心看就算了，我就说说我得出的结论：原型外面的函数（也可以叫做方法）不会被继承，也就是说只要是在原型外面的函数只能自己用，不能给后代用；而对于原型里面的函数，对于后代来说是可见的，&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1368608/201906/1368608-20190628150700320-609328232.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　注意：图中我为了看起来简洁，省略了一点东西，就是那么__proto__属性，为什么实例能够找到它爸爸构造函数的原型呢？就是通过这个属性，而构造函数中也有一个__proto__属性，指向Object的原型，通过这个原型的话，我们的实例就能够慢慢往上找原型，一直可以找到Object的原型，这就是所谓的原型链。。。。&lt;/p&gt;
&lt;p&gt;　　所以根据这个特性，js一开始就在Object的原型中放置了一些常用的函数，所以自定义构造函数的实例一开始就可以调用一些方法，这些方法不是我们定义的，而是官方帮你先放到Object的原型中的，当然你也可以在实例或构造函数中弄个同样名字的函数，将官方那个给覆盖掉。。。。。&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.js中方法类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　我js中的方法大概分为三种（对于js这样的语言来说，没有类的概念好不爽，我们就把构造函数看作类吧。。。。）：类方法，实例方法，原型方法　　&lt;/p&gt;
&lt;p&gt;　　那么这三种方法到底是干嘛的呢？我就随便举个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; Person = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;(name){
            &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
            &lt;/span&gt;&lt;span&gt;this.say = function(){alert(&quot;say.....&quot;)};//实例方法&lt;/span&gt;
&lt;span&gt;        }
Person.say &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;(){alert(&quot;Person say.....&quot;)}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;类方法，只能通过构造函数名来调用&lt;/span&gt;
Person.prototype.say=&lt;span&gt;function&lt;/span&gt;(){alert(&quot;prototype say.....&quot;)}&lt;span&gt;//&lt;/span&gt;&lt;span&gt;原型方法&lt;/span&gt;

&lt;span&gt;var&lt;/span&gt; per = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
per.say();&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用实例方法,注意当实例方法和原型方法同名的时候优先调用实例方法，如果实例方法没有say方法，那就会调用原型中的say方法&lt;/span&gt;
Person.say();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用类方法&lt;/span&gt;
Person.prototype.say();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用原型方法&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;5总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　怎么说呢？感觉js结构太糟糕了，看了好久才知道一个大概的轮廓，还有很多的东西没看到，比如我们知道原型其实是一个当前构造函数的实例，那么我们可不可以把其他对象的实例赋值过来呢？比如Student.prototype = new Person(),这样行吗？当然可以，这样的话可以让Student的实例访问Person的原型的方法，实现了继承。。。。&lt;/p&gt;
&lt;p&gt;　　哎，有机会再来啃js吧，还有好多东西要看。。。。由于看js没多久，有什么说得有误的地方欢迎指出！&lt;/p&gt;
</description>
<pubDate>Sat, 29 Jun 2019 00:45:00 +0000</pubDate>
<dc:creator>java小新人</dc:creator>
<og:description>说实话js这门语言以前没有仔细研究过，现在研究起来感觉好麻烦，对于原型链这个说法我也是刚接触不久，就试着说说我的理解吧！ 关于上一篇我们说了js整个函数体系结构，想了解的可以点击这里，这里随便找到一些</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wyq1995/p/11103179.html</dc:identifier>
</item>
<item>
<title>What？Tomcat-竟然也算中间件？ - 江南一点雨</title>
<link>http://www.cnblogs.com/lenve/p/11105604.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lenve/p/11105604.html</guid>
<description>&lt;p&gt;关于 MyCat 的铺垫文章已经写了两篇了：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/bcyjBgEqg6Or5zdi4jHaiA&quot;&gt;MySQL 只能做小项目？松哥要说几句公道话！&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/qUGANVj2mmoMwUZEV5Zc1w&quot;&gt;北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;今天是最后一次铺垫，后面就可以迎接大 Boss 了！&lt;/p&gt;
&lt;p&gt;本来今天就该讲 MyCat 了，但是我发现还有一个概念值得和大家聊一下，那就是 Java 中间件！&lt;/p&gt;
&lt;p&gt;因为 MyCat 是一个&lt;strong&gt;分布式数据库中间件&lt;/strong&gt;，要理解 MyCat ，那你就得先知道到底什么是中间件！&lt;/p&gt;
&lt;p&gt;松哥去年在一次外训中专门讲过中间件，本来想直接和大家分享一下讲稿，但是没找到，所以又动手敲了下。&lt;/p&gt;

&lt;p&gt;说起中间件，很多人首先想到的就是消息中间件，那么除了消息中间件呢？其实我们日常开发中，接触到的中间件太多了，我们来看维基百科上的一段介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;中间件（英语：Middleware），又译中间件、中介层，是提供系统软件和应用软件之间连接的软件，以便于软件各部件之间的沟通。在现代信息技术应用框架如 Web 服务、面向服务的体系结构等项目中应用比较广泛。如数据库、Apache 的 Tomcat ，IBM 公司的 WebSphere ,BEA 公司的 WebLogic 应用服务器，东方通公司的 Tong 系列中间件，以及 Kingdee 公司的等都属于中间件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;看到这个，你可能会大吃一惊，原来我们不知不觉不知不觉中已经用过这么多中间件了！甚至连 Tomcat 也是一个中间件！&lt;/p&gt;
&lt;p&gt;中间件，顾名思义，就是连接在两个软件之间的东西，是软件之间的一个粘合剂，一个胶水一样的东西。它位于操作系统和我们的应用程序之间，可以让开发者方便地处理通信、输入和输出，使开发者能够专注于自己的业务逻辑开发。&lt;/p&gt;
&lt;p&gt;这么一说，好像 Tomcat 确实还有点像中间件！位于我们的操作系统和应用程序之间！&lt;/p&gt;

&lt;p&gt;中间件有很多，早在 1998 年 IDC 公司就将中间件分成了 6 大类，国内 2005 年之前出版的中间件相关的书上，很多都是按照这 6 大类来分的，分别是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;终端仿真/屏幕转换&lt;/li&gt;
&lt;li&gt;数据访问中间件（UDA）&lt;/li&gt;
&lt;li&gt;远程过程调用中间件（RPC）&lt;/li&gt;
&lt;li&gt;消息中间件（MOM）&lt;/li&gt;
&lt;li&gt;交易中间件（TPM）&lt;/li&gt;
&lt;li&gt;对象中间件&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里边除了消息中间件和交易中间件大家可能听说过之外，其他的中间件估计都很少听说，这是因为时代在变化，有的中间件慢慢被淘汰了（例如 终端仿真/屏幕转换 中间件），有的则慢慢合并到其他框架中去了（例如 远程过程调用中间件）。&lt;/p&gt;

&lt;p&gt;那么什么是数据库中间件呢？&lt;/p&gt;
&lt;p&gt;前面文章我们提到，如果数据量比较大的话，我们需要对数据进行分库分表，分完之后，原本存在一个数据库中的数据，现在就存在多个数据库中了，那么我们的项目结构可能就是下面这个样子了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.javaboy.org/images/mysql/6-1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们要在 Java 代码中配置复杂的多数据源，配置读写分离，数据查询的时候还要进行数据的预处理，例如从多个 DB 上加载到的数据要先进行排序、过滤等等操作，这样我们的 Java 代码就参杂了很多业务无关的方法，而且这些参杂进来的代码，大多数都还是重复的。&lt;/p&gt;
&lt;p&gt;为了使开发人员，将更多精力放到业务上，我们引入数据库中间件，像下面这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.javaboy.org/images/mysql/6-2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这张图非常形象的说明了什么是中间件！一个介于两个应用程序之间的东西。引入 MyCat 中间件之后，我们的应用程序将只需要连接 MyCat 就行了，再由 MyCat 去操作各种不同的 DB，各个分布式数据库的排序、结果集合并、数据过滤等操作都在 MyCat 中完成，这样我们的 Java 应用又可以专注于业务的开发了，那些繁琐的重复的操作，又交给 MyCat 去完成。&lt;/p&gt;
&lt;p&gt;如果没有数据库中间件，那么我们的 Java 应用程序将直接面对分片集群，数据源切换、事务处理、数据聚合等等众多问题，这样原本该是专注于业务的 Java 应用程序，将会花大量的工作来处理分片后的问题，而且大部分的代码又都是重复的！&lt;/p&gt;
&lt;p&gt;有了数据库中间件，应用只需要集中与业务处理，大量的通用的数据聚合，事务，数据源切换都由中间件来处理，中间件的性能与处理能力将直接决定应用的读写性能，所以在项目中选择一款好的数据库中间件至关重要。&lt;/p&gt;

&lt;p&gt;好了，本文就简单介绍下中间件的基本概念，下文就可以正式开始聊分布式数据库中间件了！&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果小伙伴觉得松哥自己写的技术文章还过得去的话，欢迎积极转发，松哥每隔 15 天会根据微信后台数据，选一个分享转发最多的一位小伙伴，送一本松哥自己的签名书或者 Java 领域的经典书籍，欢迎大家积极参与，下一次开奖时间在下周。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;a href=&quot;http://www.mycat.io/&quot;&gt;MyCat 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;曾宪杰.大型网站系统与Java中间件实践[M].北京：电子工业出版社，2014.&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;关注公众号【江南一点雨】，专注于 Spring Boot+微服务以及前后端分离等全栈技术，定期视频教程分享，关注后回复 Java ，领取松哥为你精心准备的 Java 干货！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.javaboy.org/images/sb/javaboy.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 29 Jun 2019 00:44:00 +0000</pubDate>
<dc:creator>江南一点雨</dc:creator>
<og:description>关于 MyCat 的铺垫文章已经写了两篇了： 1. 'MySQL 只能做小项目？松哥要说几句公道话！' 2. '北冥有 Data，其名为鲲，鲲之大，一个 MySQL 放不下！' 今天是最后一次铺垫，后</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lenve/p/11105604.html</dc:identifier>
</item>
<item>
<title>再说Java集合，subList之于ArrayList - 工匠初心</title>
<link>http://www.cnblogs.com/LiaHon/p/11105573.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/LiaHon/p/11105573.html</guid>
<description>&lt;p&gt;上一章说了&lt;a href=&quot;https://www.cnblogs.com/LiaHon/p/11089988.html&quot;&gt;很多ArrayList相关的内容&lt;/a&gt;，但还有一块儿内容没说到，那就是subList方法。先看一段代码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static void testSubList() {
    List&amp;lt;String&amp;gt; stringList = new ArrayList&amp;lt;&amp;gt;();
    stringList.add(&quot;牛魔王&quot;);
    stringList.add(&quot;蛟魔王&quot;);
    stringList.add(&quot;鹏魔王&quot;);
    stringList.add(&quot;狮驼王&quot;);
    stringList.add(&quot;猕猴王&quot;);
    stringList.add(&quot;禺贼王&quot;);
    stringList.add(&quot;美猴王&quot;);

    List&amp;lt;String&amp;gt; substrings = stringList.subList(3,5);
    System.out.println(substrings.toString());
    System.out.println(substrings.size());
    substrings.set(1, &quot;猪八戒&quot;);
    System.out.println(substrings.toString());
    System.out.println(stringList.toString());
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看看执行结果如何？&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[狮驼王, 猕猴王]
2
[狮驼王, 猪八戒]
[牛魔王, 蛟魔王, 鹏魔王, 狮驼王, 猪八戒, 禺贼王, 美猴王]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第一和第二的执行结果，非常容易理解，subList()方法作用就是截取集合stringList中一个范围内的元素。&lt;/p&gt;
&lt;p&gt;第三和第四的执行结果都值得分析了，首先截取的字符串集合值为 &lt;strong&gt;[狮驼王, 猕猴王]&lt;/strong&gt; ，但因为猕猴王在大雷音寺被美猴王打死了，我们用猪八戒来代替猕猴王；&lt;/p&gt;
&lt;p&gt;因此我们通过&lt;strong&gt;substrings.set(1, &quot;猪八戒&quot;)&lt;/strong&gt;，将这个集合中第二个位置的值&lt;strong&gt;“猕猴王”&lt;/strong&gt;设置为&lt;strong&gt;“猪八戒”&lt;/strong&gt;，最终打印出来的结果也正是我们所预期的；但同时我们打印原集合stringList，发现其中的&lt;strong&gt;“猕猴王”&lt;/strong&gt;也变成了&lt;strong&gt;“猪八戒”&lt;/strong&gt;。这就比较奇怪了，两个问题：&lt;/p&gt;
&lt;p&gt;1.我们操作的是截取后的集合，为什么原集合会变？&lt;/p&gt;
&lt;p&gt;2.我们设置截取后某个位置（如第2个位置）的值，原集合改变的却不是对应位置的值？&lt;/p&gt;
&lt;h2 id=&quot;一.-sublist原理初探&quot;&gt;一. subList原理初探&lt;/h2&gt;
&lt;p&gt;接下来我们带着问题寻找答案，我们看一下subList()的源码&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;/**
 * Returns a view of the portion of this list between the specified
 * {@code fromIndex}, inclusive, and {@code toIndex}, exclusive.  (If 
 * {@code fromIndex} and {@code toIndex} are equal, the returned list is 
 * empty.)  The returned list is backed by this list, so non-structural
 * changes in the returned list are reflected in this list, and vice-versa.
 * The returned list supports all of the optional list operations.
 *
 * &amp;lt;p&amp;gt;This method eliminates the need for explicit range operations (of
 * the sort that commonly exist for arrays).  Any operation that expects
 * a list can be used as a range operation by passing a subList view
 * instead of a whole list.  For example, the following idiom
 * removes a range of elements from a list:
 * &amp;lt;pre&amp;gt;
 *      list.subList(from, to).clear();
 * &amp;lt;/pre&amp;gt;
 * Similar idioms may be constructed for {@link #indexOf(Object)} and
 * {@link #lastIndexOf(Object)}, and all of the algorithms in the
 * {@link Collections} class can be applied to a subList.
 *
 * &amp;lt;p&amp;gt;The semantics of the list returned by this method become undefined if
 * the backing list (i.e., this list) is &amp;lt;i&amp;gt;structurally modified&amp;lt;/i&amp;gt; in
 * any way other than via the returned list.  (Structural modifications are
 * those that change the size of this list, or otherwise perturb it in such
 * a fashion that iterations in progress may yield incorrect results.)
 *
 * @throws IndexOutOfBoundsException {@inheritDoc}
 * @throws IllegalArgumentException {@inheritDoc}
 */
public List&amp;lt;E&amp;gt; subList(int fromIndex, int toIndex) {
    subListRangeCheck(fromIndex, toIndex, size);
    return new SubList(this, 0, fromIndex, toIndex);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看注释，大概有以下几个意思&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;返回的是原集合在fromIndex和toIndex之间的元素的视图，虽然为视图，但支持集合的所有方法；&lt;/li&gt;
&lt;li&gt;当fromIndex和toIndex相同时，返回空的视图；&lt;/li&gt;
&lt;li&gt;任何对截取的视图的操作都会被原集合所取代；&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;看注释仅能知道我们例子最后的运行结果是正常的，但是对原理也还并不是特别清楚。我们继续看源码。&lt;/p&gt;
&lt;p&gt;首先我们在例子中调用subList(3, 5)时，是new了一个SubList，这个SubList是ArrayList内部类，继承了AbstractList&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;private class SubList extends AbstractList&amp;lt;E&amp;gt; implements RandomAccess {
    private final AbstractList&amp;lt;E&amp;gt; parent;
    private final int parentOffset;
    private final int offset;
    int size;

    SubList(AbstractList&amp;lt;E&amp;gt; parent, int offset, int fromIndex, int toIndex) {
        this.parent = parent;
        this.parentOffset = fromIndex;
        this.offset = offset + fromIndex;
        this.size = toIndex - fromIndex;
        this.modCount = ArrayList.this.modCount;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从这个内部类的源码中，我们可以看到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;&lt;li&gt;SubList并没有像ArrayList一样定义Object[]来存放数据，而定义了一个变量parent来保存传递的原集合；&lt;/li&gt;
&lt;li&gt;定义了一个offset用于保存进行偏移量，当对SubList修改时，就可以通过偏移量找到parent中对应的位置；&lt;/li&gt;
&lt;li&gt;定义了size用来表示我们在parent集合中可见范围是多少；&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1677914/201906/1677914-20190629082706329-339604873.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有了上面的说明，其实SubList的原理已经很清晰了，接下来，我们用SubList中常用的方法来印证一下。&lt;/p&gt;
&lt;h2 id=&quot;二.-adde-e方法&quot;&gt;二. add(E e)方法&lt;/h2&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;substrings.add(&quot;九头蛇&quot;);
System.out.println(substrings.toString());
System.out.println(stringList.toString());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着上面的例子，在substrings中添加“九头蛇”，按照规则，add()方法添加元素会在集合的最后，也就是说substrings的第3个位置（下标为2），对应parent原集合的位置下标就是2+3=5，会在stringList第六个位置插入“九头蛇”。看一下输出的结果&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;[狮驼王, 猪八戒, 九头蛇]
[牛魔王, 蛟魔王, 鹏魔王, 狮驼王, 猪八戒, 九头蛇, 禺贼王, 美猴王]&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到结果的确如此，那么我们在看一下add(E e)，在SubList这个内部类里面并没有发现该方法，因此我去父类中找。&lt;/p&gt;
&lt;p&gt;在AbstractList中找到了&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public boolean add(E e) {
    add(size(), e);
    return true;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来，我们在SubList中找到了实现方法&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public void add(int index, E e) {
    rangeCheckForAdd(index);
    checkForComodification();
    parent.add(parentOffset + index, e);
    this.modCount = parent.modCount;
    this.size++;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;很明显，源代码和我们开始的分析是一致的，当然在添加之间需要进行空间容量判断，是否足以添加新的元素，扩容规则，我们上一章已经讲过。&lt;/p&gt;
&lt;h2 id=&quot;三.-其他方法&quot;&gt;三. 其他方法&lt;/h2&gt;
&lt;p&gt;关于SubList的其他方法，其实和add原理一样，不论是set(int index, E e)，get(int index)，addAll(Collection&amp;lt;? extends E&amp;gt; c)，remove(int index)，都是先判断当前传入的位置索引是否正确（如是否大于size，小于0等），再根据规则计算出原集合中的位置下标，最终完成对集合的操作。&lt;/p&gt;
&lt;h2 id=&quot;四.-总结&quot;&gt;四. 总结&lt;/h2&gt;
&lt;p&gt;本文续接上一章ArrayList原理及使用，对ArrayList中的常用方法subList进行了剖析，从源码的角度对通过subList方法得到的集合和原集合有何关系，有何不同点，从而避免工作中遇到各种坑，若有不对之处，请批评指正，望共同进步，谢谢！&lt;/p&gt;
</description>
<pubDate>Sat, 29 Jun 2019 00:29:00 +0000</pubDate>
<dc:creator>工匠初心</dc:creator>
<og:description>本文续接上一章ArrayList原理及使用，对ArrayList中的常用方法subList进行了剖析，从源码的角度对通过subList方法得到的集合和原集合有何关系，有何不同点，从而避免工作中遇到各种</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/LiaHon/p/11105573.html</dc:identifier>
</item>
<item>
<title>WebGL场景的两种地面构造方法 - ljzc002</title>
<link>http://www.cnblogs.com/ljzc002/p/11105496.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ljzc002/p/11105496.html</guid>
<description>&lt;p&gt;总述：&lt;br/&gt;大部分3D编程都涉及到地面元素，在场景中我们使用地面作为其他物体的承载基础，同时也用地面限制场景使用者的移动范围，还可以通过设置地块的属性为场景的不同位置设置对应的计算规则。本文在WebGL平台上借助Babylon.js库探索并实现了两种地面构造方法，除了两种确定的构造方法外，本文还包含了对一些其他选择的探讨和一些对电子游戏艺术的看法。建议在阅读本文前，先学习3D编程入门知识和Babylon.js的官方入门教程，前者可以在 https://space.bilibili.com/25346426/channel/detail?cid=14552找到一些介绍基础概念的视频教程，后者可以在https://github.com/ljzc002/ljzc002.github.io/tree/master/BABYLON101找到英中对照版本，本篇文章所用到的代码可以在https://github.com/ljzc002/ljzc002.github.io/tree/master/EmptyTalk下载。&lt;/p&gt;
&lt;p&gt;一、方法一——使用标准地块拼装构造地面&lt;br/&gt;1、我们先制作5种标准地块：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629063023340-153561358.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;标准地块都是边长为1的正方体，每一种标准地块使用对应的纹理表示特定的地貌，我们可以用这些标准地块的复制体拼接成复杂的地面构造。在本文中我使用正方体作为标准地块，垂直排布的生成地形，你也可以使用六棱柱等其他形状作为标准地块，或者将地块绕y轴旋转一些角度后进行排布。&lt;br/&gt;制作标准地块的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; size_per=1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个单元格的尺寸&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; obj_landtype=&lt;span&gt;{};
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立网格&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; box_grass=&lt;span&gt;new&lt;/span&gt; BABYLON.MeshBuilder.CreateBox(&quot;box_grass&quot;&lt;span&gt;,{size:size_per},scene);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; box_tree=&lt;span&gt;new&lt;/span&gt; BABYLON.MeshBuilder.CreateBox(&quot;box_tree&quot;&lt;span&gt;,{size:size_per},scene);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; box_stone=&lt;span&gt;new&lt;/span&gt; BABYLON.MeshBuilder.CreateBox(&quot;box_stone&quot;&lt;span&gt;,{size:size_per},scene);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; box_shallowwater=&lt;span&gt;new&lt;/span&gt; BABYLON.MeshBuilder.CreateBox(&quot;box_shallowwater&quot;&lt;span&gt;,{size:size_per},scene);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; box_deepwater=&lt;span&gt;new&lt;/span&gt; BABYLON.MeshBuilder.CreateBox(&quot;box_deepwater&quot;&lt;span&gt;,{size:size_per},scene);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         box_grass.renderingGroupId = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         box_tree.renderingGroupId = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         box_stone.renderingGroupId = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         box_shallowwater.renderingGroupId = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         box_deepwater.renderingGroupId = 2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         box_grass.position.y=-100*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         box_tree.position.y=-101*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         box_stone.position.y=-102*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         box_shallowwater.position.y=-103*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         box_deepwater.position.y=-104*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         obj_landtype.box_grass=&lt;span&gt;box_grass;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         obj_landtype.box_tree=&lt;span&gt;box_tree;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         obj_landtype.box_stone=&lt;span&gt;box_stone;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         obj_landtype.box_shallowwater=&lt;span&gt;box_shallowwater;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         obj_landtype.box_deepwater=&lt;span&gt;box_deepwater;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        OptimizeMesh(box_grass);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        OptimizeMesh(box_tree);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;        OptimizeMesh(box_stone);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        OptimizeMesh(box_shallowwater);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;        OptimizeMesh(box_deepwater);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立材质&lt;/span&gt;
&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; mat_grass = &lt;span&gt;new&lt;/span&gt; BABYLON.StandardMaterial(&quot;mat_grass&quot;, scene);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;         mat_grass.diffuseTexture = &lt;span&gt;new&lt;/span&gt; BABYLON.Texture(&quot;../../ASSETS/IMAGE/LANDTYPE/grass.jpg&quot;&lt;span&gt;, scene);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        mat_grass.freeze();
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         box_grass.material=&lt;span&gt;mat_grass;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; mat_tree = &lt;span&gt;new&lt;/span&gt; BABYLON.StandardMaterial(&quot;mat_tree&quot;, scene);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         mat_tree.diffuseTexture = &lt;span&gt;new&lt;/span&gt; BABYLON.Texture(&quot;../../ASSETS/IMAGE/LANDTYPE/yulin.png&quot;&lt;span&gt;, scene);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;        mat_tree.freeze();
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;         box_tree.material=&lt;span&gt;mat_tree;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; mat_stone = &lt;span&gt;new&lt;/span&gt; BABYLON.StandardMaterial(&quot;mat_stone&quot;, scene);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;         mat_stone.diffuseTexture = &lt;span&gt;new&lt;/span&gt; BABYLON.Texture(&quot;../../ASSETS/IMAGE/LANDTYPE/stone.png&quot;&lt;span&gt;, scene);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;        mat_stone.freeze();
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         box_stone.material=&lt;span&gt;mat_stone;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; mat_shallowwater = &lt;span&gt;new&lt;/span&gt; BABYLON.StandardMaterial(&quot;mat_shallowwater&quot;, scene);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         mat_shallowwater.diffuseTexture = &lt;span&gt;new&lt;/span&gt; BABYLON.Texture(&quot;../../ASSETS/IMAGE/LANDTYPE/lake.png&quot;&lt;span&gt;, scene);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        mat_shallowwater.freeze();
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;         box_shallowwater.material=&lt;span&gt;mat_shallowwater;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; mat_deepwater = &lt;span&gt;new&lt;/span&gt; BABYLON.StandardMaterial(&quot;mat_deepwater&quot;, scene);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;47&lt;/span&gt;         mat_deepwater.diffuseTexture = &lt;span&gt;new&lt;/span&gt; BABYLON.Texture(&quot;../../ASSETS/IMAGE/LANDTYPE/sea.png&quot;&lt;span&gt;, scene);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;        mat_deepwater.freeze();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;         box_deepwater.material=mat_deepwater;        
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码制作了“草地”、“森林”、“岩石”、“浅水”、“深水”五种标准地块，对于地块的网格，使用OptimizeMesh方法进行了一些显示优化，OptimizeMesh方法内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; OptimizeMesh(mesh)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         mesh.convertToFlatShadedMesh();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;使用顶点颜色计算代替片元颜色计算&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         mesh.freezeWorldMatrix();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;冻结世界坐标系&lt;/span&gt;
&lt;span&gt;5&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt; mesh.material.needDepthPrePass = true;//启用深度预通过&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;mesh.convertToUnIndexedMesh();//使用三角形绘制代替索引绘制&lt;/span&gt;
&lt;span&gt;7&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于地块材质，使用freeze方法冻结了材质对象的属性，避免渲染引擎频繁刷新材质状态。&lt;/p&gt;
&lt;p&gt;2、接下来我们用草地地块拼接一个最简单的平原地形&lt;br/&gt;地形渲染效果如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629063444103-11997569.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这片草原是由10201个草地地块拼接而成的，这里我使用了OpenGL的“多实例渲染”技术，来降低绘制大量重复对象对计算性能的消耗，Babylon.js库在createInstance方法中封装了这一技术：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; arr_instance=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; segs_x=100;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;横向分段次数&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; segs_y=100;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;纵向分段次数&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;以高度0为海平面，以xy00为大地原点&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;形成初始地块:101*101个格子，中心格的中心是原点&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;=segs_x;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             arr_instance[i]=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;=segs_y;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 arr_instance[i][j]=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; instance=obj_landtype.box_grass.createInstance(&quot;ground_&quot;+i+&quot;_&quot;+j+&quot;_0&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 instance.mydata={i:i,j:j,k:0&lt;span&gt;,landclass:obj_landtype.box_grass};
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 instance.position=&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3((i-(segs_x/2))*size_per,0,(j-(segs_y/2))*size_per);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;xz方向上都是从负向正堆叠&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                 arr_instance[i][j].push(instance);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把每个实例用全局对象保存起来&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里我们为每个实例对象设置了一个mydata属性，将地块的一些信息保存到这个属性里，以备之后的场景交互使用。&lt;/p&gt;
&lt;p&gt;3、为单元格标记xz方向上的索引&lt;/p&gt;
&lt;p&gt;现在每个地块都是沿着x轴和z轴整齐排列的，为方便区分，我们将xz平面上的每个方块位置叫做“单元格”，每个单元格中可能有多个地块实例。每个单元格的位置以其x、z轴上的索引表示，我们现在需要一种方式将这一索引值显示出来。&lt;br/&gt;这里我们先尝试为每个单元格显示一个索引文本，渲染效果如下：（可以访问https://ljzc002.github.io/EmptyTalk/HTML/TEST/testfloor.html查看）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629063908511-612281646.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看出标记效果并不是很理想，同时数以万计的索引文本也降低了场景的渲染速度，这种方法可能并不适用于当前的单元格标记需求，但包含的技术可能用在其他地方：&lt;/p&gt;
&lt;p&gt;a、首先建立一个精灵管理器以及一张包含数字和减号的图片&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;准备十种数字以及减号的纹理&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;var&lt;/span&gt; can_temp=document.createElement(&quot;canvas&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         can_temp.width=132&lt;span&gt;//&lt;/span&gt;&lt;span&gt;264;&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;         can_temp.height=24&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; context=can_temp.getContext(&quot;2d&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         context.fillStyle=&quot;rgba(0,0,0,0)&quot;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;完全透明的背景&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;         context.fillRect(0,0&lt;span&gt;,can_temp.width,can_temp.height);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         context.fillStyle = &quot;#ffffff&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         context.font = &quot;bold 24px monospace&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;10;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             context.fillText(i,i*12,24&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         context.fillText(&quot;-&quot;,120,24&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;context.fillText(&quot;0123456789-&quot;,0,24);//默认为半角，为了在作为精灵使用时整齐的分块必须一个一个单独绘制&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; png=can_temp.toDataURL(&quot;image/png&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成PNG图片&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立精灵管理器&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; spriteManager = &lt;span&gt;new&lt;/span&gt; BABYLON.SpriteManager(&quot;spriteManager&quot;, png, (segs_x+1)*(segs_y+1)*7, 24&lt;span&gt;, scene);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         spriteManager.renderingGroupId=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         spriteManager.cellWidth=12&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         spriteManager.cellHeight=24;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b、在生成地块实例的循环里加入精灵生成代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加精灵，估计地图最大为1000*1000&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; number1 = &lt;span&gt;new&lt;/span&gt; BABYLON.Sprite(&quot;number1&quot;&lt;span&gt;, spriteManager);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; number2 = &lt;span&gt;new&lt;/span&gt; BABYLON.Sprite(&quot;number2&quot;&lt;span&gt;, spriteManager);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; number3 = &lt;span&gt;new&lt;/span&gt; BABYLON.Sprite(&quot;number3&quot;&lt;span&gt;, spriteManager);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; number4 = &lt;span&gt;new&lt;/span&gt; BABYLON.Sprite(&quot;number4&quot;&lt;span&gt;, spriteManager);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; number5 = &lt;span&gt;new&lt;/span&gt; BABYLON.Sprite(&quot;number5&quot;&lt;span&gt;, spriteManager);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; number6 = &lt;span&gt;new&lt;/span&gt; BABYLON.Sprite(&quot;number6&quot;&lt;span&gt;, spriteManager);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; number7 = &lt;span&gt;new&lt;/span&gt; BABYLON.Sprite(&quot;number7&quot;&lt;span&gt;, spriteManager);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为缺少的数位填充0，生成三位数字&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;                 stri=(i+1000+&quot;&quot;).substr(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 strj=(j+1000+&quot;&quot;).substr(1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; 
&lt;span&gt;13&lt;/span&gt;                 number1.cellIndex=parseInt(stri[0&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 number2.cellIndex=parseInt(stri[1&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 number3.cellIndex=parseInt(stri[2&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 number4.cellIndex=10;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;减号&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 number5.cellIndex=parseInt(strj[0&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 number6.cellIndex=parseInt(strj[1&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 number7.cellIndex=parseInt(strj[2&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;定位精灵，7个精灵垂直排列作为一条文本&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;                 number1.size=0.2*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                 number1.position=&lt;span&gt;instance.position.clone();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;                 number1.position.y=2*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                 number1.position.x+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 number1.position.z+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; 
&lt;span&gt;27&lt;/span&gt;                 number2.size=0.2*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 number2.position=&lt;span&gt;instance.position.clone();
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 number2.position.y=1.8*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 number2.position.x+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 number2.position.z+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 number3.size=0.2*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 number3.position=&lt;span&gt;instance.position.clone();
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                 number3.position.y=1.6*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 number3.position.x+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 number3.position.z+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 number4.size=0.2*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 number4.position=&lt;span&gt;instance.position.clone();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 number4.position.y=1.4*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                 number4.position.x+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 number4.position.z+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 number5.size=0.2*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 number5.position=&lt;span&gt;instance.position.clone();
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 number5.position.y=1.2*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 number5.position.x+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 number5.position.z+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                 number6.size=0.2*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 number6.position=&lt;span&gt;instance.position.clone();
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                 number6.position.y=1.0*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                 number6.position.x+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                 number6.position.z+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 number7.size=0.2*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;                 number7.position=&lt;span&gt;instance.position.clone();
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 number7.position.y=0.8*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 number7.position.x+=0.3*&lt;span&gt;size_per;
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 number7.position.z+=0.3*size_per;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;考虑到计算性能，这里使用精灵作为文本的载体（但建立了7万多个精灵之后，帧率还是降低了很多），因为水平排列的精灵在相机水平移动时会相互遮挡，所以垂直排列精灵来降低影响，也许可以通过重设精灵的旋转轴位置来彻底解决这一问题。&lt;/p&gt;
&lt;p&gt;除了为每个地块标注索引之外，我们还可以使用带有索引的小地图、在单独的视口中显示选定地块的特写、在选定地块旁边生成标记等等方式来标明地块的索引，后文将使用在场景中放置参考物的方式来标示地块索引。&lt;/p&gt;
&lt;p&gt;4、生成地形起伏&lt;br/&gt;我们抬升了xz平面中左下角的两格单元格，并将这两个单元设为“岩石”地貌：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629064354155-1539840525.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;a、首先建立两个工具方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;49&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;disposeCube(0,0)&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt; disposeCube(i,j)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移除一个xz位置上的所有可能存在的方块&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr_instance[i][j].length;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; k=0;k&amp;lt;len;k++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; instance=&lt;span&gt;arr_instance[i][j][k];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;            instance.dispose();
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             instance=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在指定单元格、指定高度建立指定类型的地块&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;createCube(0,0,2,obj_landtype.box_stone)&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;i，j必定是整数，k可能是小数,都表示单位长度的数量&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; createCube(i,j,k,landclass)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; instance=landclass.createInstance(&quot;ground_&quot;+i+&quot;_&quot;+j+&quot;_&quot;+&lt;span&gt;k);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         instance.mydata=&lt;span&gt;{i:i,j:j,k:k,landclass:landclass};
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         instance.position=&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3((i-(segs_x/2))*size_per,k*size_per,(j-(segs_y/2))*size_per);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;都是从负向正堆叠？-》规定每个单元格的地块数组都是从低到高排列&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;arr_instance[i][j].push(instance);&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        arr_instance[i][j].unshift(instance);
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b、接下来修改一些被选中的单元格&lt;/p&gt;
&lt;p&gt;我们把“被选中的单元格”放在一个数组里，将这个数组命名为“配置数组”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;用对应的方块填充一条路径上所有的xz单元格，先清空单元格内原有方块，然后在指定高度建立一个方块&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ，接着比对所有周围方块的高度（比对四个方向），填补漏出的部分，在填补时注意越低的方块在数组中越靠前。&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;createCubePath([{i:0,j:0,k:1,landclass:obj_landtype.box_stone},{i:1,j:1,k:2.5,landclass:obj_landtype.box_stone}])&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;    
&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; createCubePath(cubepath)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;cubepath.length;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于每一个xz单元格&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cube=&lt;span&gt;cubepath[i];
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            disposeCube(cube.i,cube.j);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;            createCube(cube.i,cube.j,cube.k,cube.landclass);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初次绘制后进行二次对比，初次绘制的必定是xz单元格中的最高点&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; index=0;index&amp;lt;len;index++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; cube=&lt;span&gt;cubepath[index];
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; i=&lt;span&gt;cube.i;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; j=&lt;span&gt;cube.j;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; k=&lt;span&gt;cube.k;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;上右下左&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;取四方的最高&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; k1=999&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arr_instance[i])
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; arr1=arr_instance[i][j+1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arr1)
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; ins_cube1=arr1[arr1.length-1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     k1=&lt;span&gt;ins_cube1.mydata.k;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; k2=999&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(arr_instance[i+1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; arr2=arr_instance[i+1&lt;span&gt;][j];
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arr2) {
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; ins_cube2 = arr2[arr2.length - 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     k2=&lt;span&gt;ins_cube2.mydata.k;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; k3=999&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arr_instance[i])
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; arr3=arr_instance[i][j-1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arr3) {
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; ins_cube3=arr3[arr3.length-1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     k3=&lt;span&gt;ins_cube3.mydata.k;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; k4=999&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(arr_instance[i-1&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; arr4=arr_instance[i-1][j+1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(arr4) {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; ins_cube4=arr4[arr4.length-1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                     k4=&lt;span&gt;ins_cube4.mydata.k;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;          
&lt;span&gt;61&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在四方最高中找最低&lt;/span&gt;
&lt;span&gt;62&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; mink=&lt;span&gt;Math.min(k1,k2,k3,k4);
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt; 
&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; len2=Math.floor((k-mink)/size_per);
&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; index2=1;index2&amp;lt;=len2;index2++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;                 createCube(i,j,k-&lt;span&gt;index2,cube.landclass);
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;arr_instance[i][j].unshift()&lt;/span&gt;
&lt;span&gt;69&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;71&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码包含两个循环，第一个循环负责放置选中单元格中最高的那个地块，第二个循环则负责填充最高地块下面的支撑，比如高山的山体或者深谷的谷壁。这种填充是靠比较选中的单元格和四面单元格的高度实现的，这个算法的一个缺点是在需要生成低谷时，谷地周围的一圈高度不变的平地也需要放入配置数组，否则地形会出现断裂。&lt;br/&gt;直接在浏览器控制台中执行createCubePath([{i:0,j:0,k:1,landclass:obj_landtype.box_stone},{i:1,j:1,k:2.5,landclass:obj_landtype.box_stone}])命令即可改变地形。这里你可能想要看到那种“在场景中拖动鼠标地形随之起伏”的效果，但我认为这种运行时代码注入的控制方式反而是WebGL技术相对于传统桌面3D程序的一大优势，借此我们可能实现远超传统ui的精细化控制。&lt;/p&gt;
&lt;p&gt;可以访问https://ljzc002.github.io/EmptyTalk/HTML/TEST/testfloor2.html进行测试&lt;/p&gt;
&lt;p&gt;5、小结&lt;br/&gt;综上我们编写了一个简单的地形生成方法，但还有更多的工作没有做，我们需要一些根据某种规则生成配置数组的方法、一些根据规则在同一单元格的不同高度分配不同地块的方法（关于地形规则的制定也许可以参考这篇随机生成行星表面地形的文章https://www.cnblogs.com/ljzc002/p/9134272.html），对于不习惯控制台输入的使用者还要考虑编写实用的交互ui。这种空间上离散的地形比较适合编写时间上离散的回合制3D场景，接下来我们将要讨论更适合即时3D场景的连续地形。&lt;/p&gt;
&lt;p&gt;二、第二种方法——改进的地面网格&lt;/p&gt;
&lt;p&gt;1、Babylon.js内置地面网格的不足&lt;br/&gt;Babylon.js内置了一种平面地面网格和一种高度图地面网格，但这两钟网格存在一些不足：&lt;br/&gt;甲：只能设置相同的x向分段数和z向分段数&lt;br/&gt;乙：地面网格里没有xz索引信息，只能通过修改底层顶点位置改变地形&lt;br/&gt;丙：无法表现垂直断崖和反斜面之类变化剧烈的地形&lt;/p&gt;
&lt;p&gt;详细解释一下问题丙，地面网格的顶点排布如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629065759702-126755067.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用者将发现他无法在HAOG单元格和ABCO单元格之间生成垂直断崖，因为地面网格使用的是“简化的网格”，在AO两处都各只有一个顶点，无法表现悬崖的上下两边，这时使用者只好使用尽量小的单元格生成尽量陡的斜坡来模拟悬崖（这一点正好和无法生成斜坡的地块拼接法完全相反）。另一方面，每个顶点（比如顶点O）周围的六条楞线夹角并不均匀，难以生成端正的形状。&lt;/p&gt;
&lt;p&gt;计划用“条带网格”替换地面网格来解决问题甲和问题乙，但条带网格的顶点排布规律与地面网格类似，问题丙仍然存在。&lt;br/&gt;经过观察，问题丙只在地形变化剧烈时表现明显，所以决定用条带网格表现较为平缓的地形大势（代码里命名为ground_base），把一些专门定制的“地形附着物网格”（也就是模型）放置在ground_base之上表现剧烈变化的地形，如果需要，再使用某种方式将ground_base与地形附着物融合在一起。&lt;/p&gt;
&lt;p&gt;2、生成类似方法一的平坦草原地形，并标注xz索引&lt;br/&gt;渲染效果如下：（可以访问https://ljzc002.github.io/EmptyTalk/HTML/TEST/testframe2.html查看效果）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629070116539-2067405340.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;括号中是当前指示物坐标，括号后是xz索引值&lt;/p&gt;
&lt;p&gt;a、设置纹理重复&lt;br/&gt;与地块拼接法不同，条带网默认用一张纹理图包覆全体顶点，为了能像方法一一样一格一格的显示地块，对地块材质代码做如下修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; mat_grass = &lt;span&gt;new&lt;/span&gt; BABYLON.StandardMaterial(&quot;mat_grass&quot;, scene);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;
&lt;span&gt;2&lt;/span&gt;         mat_grass.diffuseTexture = &lt;span&gt;new&lt;/span&gt; BABYLON.Texture(&quot;../../ASSETS/IMAGE/LANDTYPE/grass.jpg&quot;&lt;span&gt;, scene);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         mat_grass.diffuseTexture.uScale = segs_x+1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;纹理重复效果&lt;/span&gt;
&lt;span&gt;4&lt;/span&gt;         mat_grass.diffuseTexture.vScale = segs_z+1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         mat_grass.freeze();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b、生成条带网格地面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; arr_path=[];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路径数组&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;=segs_x+1;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; posx=(i-((segs_x+1)/2))*size_per;
&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; path=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;=segs_z+1;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; posz=(j-((segs_z+1)/2))*size_per;
&lt;span&gt; 9&lt;/span&gt;                 path.push(&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(posx,0&lt;span&gt;,posz));
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;            arr_path.push(path);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         ground_base=BABYLON.MeshBuilder.CreateRibbon(&quot;ground_base&quot;
&lt;span&gt;14&lt;/span&gt;             ,{pathArray:arr_path,updatable:&lt;span&gt;true&lt;/span&gt;,closePath:&lt;span&gt;false&lt;/span&gt;,closeArray:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,sideOrientation:BABYLON.Mesh.DOUBLESIDE});
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         ground_base.sideOrientation=&lt;span&gt;BABYLON.Mesh.DOUBLESIDE;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         ground_base.material=&lt;span&gt;mat_grass;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         ground_base.renderingGroupId=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         ground_base.metadata=&lt;span&gt;{};
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         ground_base.metadata.arr_path=&lt;span&gt;arr_path;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         obj_ground.ground_base=ground_base;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意需要把CreateRibbon方法参数中的updatable属性设为true，否则建立条带网格之后将不能修改地形。&lt;/p&gt;
&lt;p&gt; c、制作一些蓝色小球作为地形参照物：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;5个蓝色小球&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;var&lt;/span&gt; mesh_sphereup=&lt;span&gt;new&lt;/span&gt; BABYLON.MeshBuilder.CreateSphere(&quot;mesh_sphereup&quot;,{diameter:0.5&lt;span&gt;},scene);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         mesh_sphereup.material=&lt;span&gt;mat_blue;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         mesh_sphereup.renderingGroupId=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         mesh_sphereup.direction=&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(0,-1,2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         mesh_sphereup.isPickable=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         mesh_sphereup.rayHelper = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         obj_plane.mesh_sphereup=&lt;span&gt;mesh_sphereup;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; mesh_sphereright=&lt;span&gt;new&lt;/span&gt; BABYLON.MeshBuilder.CreateSphere(&quot;mesh_sphereright&quot;,{diameter:0.5&lt;span&gt;},scene);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         mesh_sphereright.material=&lt;span&gt;mat_blue;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         mesh_sphereright.renderingGroupId=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         mesh_sphereright.direction=&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(2,-1,0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         mesh_sphereright.isPickable=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         mesh_sphereright.rayHelper = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         obj_plane.mesh_sphereright=&lt;span&gt;mesh_sphereright;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; mesh_spheredown=&lt;span&gt;new&lt;/span&gt; BABYLON.MeshBuilder.CreateSphere(&quot;mesh_spheredown&quot;,{diameter:0.5&lt;span&gt;},scene);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         mesh_spheredown.material=&lt;span&gt;mat_blue;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         mesh_spheredown.renderingGroupId=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         mesh_spheredown.direction=&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(0,-1,-2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         mesh_spheredown.isPickable=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         mesh_spheredown.rayHelper = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         obj_plane.mesh_spheredown=&lt;span&gt;mesh_spheredown;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; mesh_sphereleft=&lt;span&gt;new&lt;/span&gt; BABYLON.MeshBuilder.CreateSphere(&quot;mesh_sphereleft&quot;,{diameter:0.5&lt;span&gt;},scene);
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         mesh_sphereleft.material=&lt;span&gt;mat_blue;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         mesh_sphereleft.renderingGroupId=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         mesh_sphereleft.direction=&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(-2,-1,0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         mesh_sphereleft.isPickable=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         mesh_sphereleft.rayHelper = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         obj_plane.mesh_sphereleft=&lt;span&gt;mesh_sphereleft;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; mesh_spheremiddle=&lt;span&gt;new&lt;/span&gt; BABYLON.MeshBuilder.CreateSphere(&quot;mesh_spheremiddle&quot;,{diameter:0.5&lt;span&gt;},scene);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         mesh_spheremiddle.material=&lt;span&gt;mat_blue;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         mesh_spheremiddle.renderingGroupId=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;         mesh_spheremiddle.direction=&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(0,-1,0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;         mesh_spheremiddle.isPickable=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;         mesh_spheremiddle.rayHelper = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         obj_plane.mesh_spheremiddle=&lt;span&gt;mesh_spheremiddle;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为每个小球绑定一个gui标签&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj_plane)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; label = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BABYLON.GUI.Rectangle(key);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             label.background = &quot;black&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;             label.height = &quot;30px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             label.alpha = 0.5&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             label.width = &quot;240px&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;             label.cornerRadius = 20&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             label.thickness = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;             label.linkOffsetY = 30;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;位置偏移量？？&lt;/span&gt;
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;            fsUI.addControl(label);
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;            label.linkWithMesh(obj_plane[key]);
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; text1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BABYLON.GUI.TextBlock();
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;             text1.text = &quot;&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;             text1.color = &quot;white&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            label.addControl(text1);
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             label.isVisible=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;label.layerMask=2;&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;             label.text=&lt;span&gt;text1;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;             obj_plane[key].lab=&lt;span&gt;label;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;         }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以访问https://www.cnblogs.com/ljzc002/p/7699162.html 查看Babylon.js gui功能的中文文档&lt;/p&gt;
&lt;p&gt;d、根据相机的位置修改路标的位置：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;scene.registerAfterRender(
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;更新5个标记球的位置&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; origin=&lt;span&gt;camera0.position;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; length=200&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj_plane)
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;obj_plane[key];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; direction=&lt;span&gt;mesh.direction;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; ray = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BABYLON.Ray(origin, direction, length);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;if(mesh.rayHelper)
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;                        mesh.rayHelper.dispose();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;                    }&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;mesh.rayHelper = new BABYLON.RayHelper(ray);//这时还没有_renderLine属性&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;mesh.rayHelper._renderLine.renderingGroupId=2;&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;mesh.rayHelper.show(scene);//连续使用两次show会崩溃？&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;难道一帧里只能用一个pick？&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(key);&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; hit =&lt;span&gt; scene.pickWithRay(ray,predicate);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (hit.pickedMesh){
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;console.log(key+&quot;2&quot;);&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                         mesh.isVisible=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; posp=&lt;span&gt;hit.pickedPoint;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                         mesh.position=&lt;span&gt;posp.clone();
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         mesh.lab.isVisible=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;显示命中点的坐标以及命中点所在方块的左下角的两层索引&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; index_x=Math.floor((posp.x+(segs_x+1)*size_per/2)/&lt;span&gt;size_per);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; index_z=Math.floor((posp.z+(segs_z+1)*size_per/2)/&lt;span&gt;size_per);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                         mesh.lab.text.text=&quot;(&quot;+posp.x.toFixed(2)+&quot;,&quot;+posp.y.toFixed(2)+&quot;,&quot;+posp.z.toFixed(2)+&quot;)*&quot;
&lt;span&gt;31&lt;/span&gt;                             +index_x+&quot;-&quot;+&lt;span&gt;index_z;
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                     {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没命中地面则不显示路标&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                         mesh.lab.isVisible=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                         mesh.isVisible=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; 
&lt;span&gt;41&lt;/span&gt; 
&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;        )
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt; predicate(mesh){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;过滤网格，只允许射线击中地面系网格，&lt;/span&gt;
&lt;span&gt;45&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (mesh.name.substr(0,6)==&quot;ground&quot;&lt;span&gt;){
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码在每次渲染后执行，从相机出发向五个方位发射5条射线，将射线和地面的交点做为路标放置点，同时修改gui文本内容。曾经尝试在这里使用RayHelper功能显示射线，但发现在未渲染前RayHelper无法设置渲染组，而渲染后的RayHelper又需立刻换成新对象，旧的渲染组属性作废，希望官方能够优化rayHelper的用法，如果确实需要显示射线，也许可以用Line功能代替rayHelper。&lt;/p&gt;
&lt;p&gt;e、对一些选定的顶点施加矩阵变化：&lt;/p&gt;
&lt;p&gt;在控制台中执行TransVertex(obj_ground.ground_base,[[0,0],[0,1],[1,0]],BABYLON.Matrix.Translation(0,2,0))抬起了左下角的三个顶点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629070922019-286126792.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;TransVertex方法如下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; TransVertex(mesh,arr,matrix)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr.length;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; arr_path=&lt;span&gt;mesh.metadata.arr_path;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;移动路径数组里的每个顶点&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;         {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意这里操纵的是路径数组而非底层的顶点数据&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;             arr_path[arr[i][0]][arr[i][1]]=BABYLON.Vector3.TransformCoordinates(arr_path[arr[i][0]][arr[i][1&lt;span&gt;]],matrix);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         mesh=&lt;span&gt;BABYLON.MeshBuilder.CreateRibbon(mesh.name
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             ,{pathArray:arr_path,updatable:&lt;span&gt;true&lt;/span&gt;,instance:mesh,closePath:&lt;span&gt;false&lt;/span&gt;,closeArray:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,sideOrientation:BABYLON.Mesh.DOUBLESIDE});
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与方法一的地块抬升类似，这里也需要一些生成“配置数组”和分配变化方式的方法，下面将编写几个简单的此类方法。&lt;/p&gt;
&lt;p&gt;2、生成带有随机起伏的圆形山丘&lt;/p&gt;
&lt;p&gt;渲染效果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629071107475-1845927598.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码实现：&lt;br/&gt;a、选取一定范围内的顶点：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选取区域，将区域条件转为路径索引，这里应该有多种多样的选取方法&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;选取距某个点一定距离的顶点&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;FindZoneBYDistance(obj_ground.ground_base,new BABYLON.Vector3(-50,0,-50),45)&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; FindZoneBYDistance(mesh,pos,distance)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; arr_res=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; arr_path=&lt;span&gt;mesh.metadata.arr_path;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr_path.length;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于每一条路径&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; path=&lt;span&gt;arr_path[i];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; len2=&lt;span&gt;path.length;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;len2;j++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于路径上的每一个顶点&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; vec=&lt;span&gt;path[j];
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; length=pos.clone().subtract(vec).length();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到这个顶点到参数位置的距离&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(length&amp;lt;=distance)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果在参数位置的一定范围内&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;                    arr_res.push([i,j,length]);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr_res;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;只考虑XZ平面上的距离&lt;/span&gt;
&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; FindZoneBYDistanceXZ(mesh,pos,distance)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; arr_res=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; arr_path=&lt;span&gt;mesh.metadata.arr_path;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr_path.length;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于每一条路径&lt;/span&gt;
&lt;span&gt;32&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; path=&lt;span&gt;arr_path[i];
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; len2=&lt;span&gt;path.length;
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;len2;j++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于路径上的每一个顶点&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; vec=&lt;span&gt;path[j];
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; vec2=&lt;span&gt;pos.clone().subtract(vec)
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; length=Math.pow(vec2.x*vec2.x+vec2.z*vec2.z,0.5);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取到这个顶点到参数位置的距离&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(length&amp;lt;=(distance))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果在参数位置的一定范围内&lt;/span&gt;
&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                    arr_res.push([i,j,length]);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr_res;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;b、用梯度随机法生成起伏不平但又符合大势的山头：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;按照一定规则进行矩阵变换：这里应该有多种多样的插值方法&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个是越靠近pos点提高的越多，仿照粒子系统的梯度用法&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; TransVertexGradiently(mesh,arr,arr_gradient)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr.length;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len2=&lt;span&gt;arr_gradient.length;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; arr_path=&lt;span&gt;mesh.metadata.arr_path;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于每一个要变换的顶点&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; matrix=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; arr2=&lt;span&gt;arr[i];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; vec=arr_path[arr2[0]][arr2[1]];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;vec并非基础量，但为什么不能直接修改？&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; dis=arr2[2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(dis&amp;lt;arr_gradient[0][0&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 dis=arr_gradient[0][0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(dis&amp;gt;arr_gradient[len2-1][0&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 dis=arr_gradient[len2-1][0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;接下来遍历梯度数组，规定梯度必是从低到高排列的&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=1;j&amp;lt;len2;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; gradient=&lt;span&gt;arr_gradient[j];
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(dis&amp;lt;=gradient[0&lt;span&gt;])
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算这一梯度插值层级&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;前一个梯度&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; gradient0=arr_gradient[j-1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;比率&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; ratio=((dis-gradient0[0])/(gradient[0]-gradient0[0]));
&lt;span&gt;32&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;小端&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; a=gradient0[1]+(gradient[1]-gradient0[1])*&lt;span&gt;ratio;
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;大端&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; b=gradient0[2]+(gradient[2]-gradient0[2])*&lt;span&gt;ratio;
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;在范围内取随机高度&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; c=b-&lt;span&gt;a;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; res=a+c*&lt;span&gt;Math.random();
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;                     matrix=&lt;span&gt;new&lt;/span&gt; BABYLON.Matrix.Translation(0,res,0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(matrix)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 arr_path[arr2[0]][arr2[1]]=BABYLON.Vector3.TransformCoordinates(arr_path[arr2[0]][arr2[1&lt;span&gt;]],matrix);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;         mesh=&lt;span&gt;BABYLON.MeshBuilder.CreateRibbon(mesh.name
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;             ,{pathArray:arr_path,updatable:&lt;span&gt;true&lt;/span&gt;,instance:mesh,closePath:&lt;span&gt;false&lt;/span&gt;,closeArray:&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,sideOrientation:BABYLON.Mesh.DOUBLESIDE});
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;代码中的梯度随机算法可以参考Babylon.js入门教程中关于粒子系统的章节。&lt;/p&gt;
&lt;p&gt;实现图中效果所用的命令为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;108&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; TransVertexGradiently(obj_ground.ground_base,FindZoneBYDistance(obj_ground.ground_base,&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(-50,0,-50),45&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;             ,[[0,29,30],[15,14,15],[30,11,12],[45,0,1&lt;span&gt;]]);
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         TransVertexGradiently(obj_ground.ground_base,FindZoneBYDistance(obj_ground.ground_base,&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(-50,0,50),30&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             ,[[0,14,15],[15,4,5],[30,0,1&lt;span&gt;]]);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         TransVertexGradiently(obj_ground.ground_base,FindZoneBYDistance(obj_ground.ground_base,&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(50,0,-50),30&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             ,[[0,14,15],[15,4,5],[30,0,1&lt;span&gt;]]);
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         TransVertexGradiently(obj_ground.ground_base,FindZoneBYDistance(obj_ground.ground_base,&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(-50,0,0),30&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             ,[[0,14,15],[15,4,5],[30,0,1&lt;span&gt;]]);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         TransVertexGradiently(obj_ground.ground_base,FindZoneBYDistance(obj_ground.ground_base,&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(0,0,-50),30&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             ,[[0,14,15],[15,4,5],[30,0,1]]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;你也可以直接把这些命令写在程序的地形初始化部分，这会比运行时注入代码执行更快。&lt;br/&gt;ground_base处理完毕后，我们开始添加地形附着物。&lt;/p&gt;
&lt;p&gt;3、贴合丘陵地形的森林和保持水平的湖泊&lt;br/&gt;森林和湖泊的效果如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629071316208-462910322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;树木随着地势生长，所以表示森林的地形附着物要具备和山丘相同的地形起伏，水面则平滑如镜，无论水下情况如何地形附着物都要保持平整。同时这两种地形附着物还应具有和ground_base同步的纹理重复效果。&lt;br/&gt;代码实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;48&quot;&gt;
&lt;pre&gt;
&lt;span&gt;  1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;关键难点在于如何提取和重组地形网格的顶点、索引、uv，这种贴合纹理也可以用在模型表面绘制上&lt;/span&gt;
&lt;span&gt;  2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; MakeLandtype1(mesh,arr,mat,name,sameheight,height)
&lt;/span&gt;&lt;span&gt;  3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;  4&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;ground_base的顶点数据&lt;/span&gt;
&lt;span&gt;  5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; vb=mesh.geometry._vertexBuffers;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地面网格的顶点数据&lt;/span&gt;
&lt;span&gt;  6&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; data_pos=vb.position._buffer._data;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;顶点位置数据&lt;/span&gt;
&lt;span&gt;  7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; data_index=mesh.geometry._indices;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;网格索引数据&lt;/span&gt;
&lt;span&gt;  8&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; data_uv=vb.uv._buffer._data;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地面网格的纹理坐标数据&lt;/span&gt;
&lt;span&gt;  9&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len_index=&lt;span&gt;data_index.length;
&lt;/span&gt;&lt;span&gt; 10&lt;/span&gt; 
&lt;span&gt; 11&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr.length;
&lt;/span&gt;&lt;span&gt; 12&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; arr_path=mesh.metadata.arr_path;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;路径数组&lt;/span&gt;
&lt;span&gt; 13&lt;/span&gt; 
&lt;span&gt; 14&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;要生成的地形附着物的顶点数据&lt;/span&gt;
&lt;span&gt; 15&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; arr_index=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt; 16&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; data_pos2=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt; 17&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; data_index2=[];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二次循环时填充&lt;/span&gt;
&lt;span&gt; 18&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; data_uv2=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt; 19&lt;/span&gt;         console.log(&quot;开始生成地形附着物&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 20&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成顶点数组、纹理坐标数组&lt;/span&gt;
&lt;span&gt; 21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++){&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于每一个选中的路径节点&lt;/span&gt;
&lt;span&gt; 22&lt;/span&gt; 
&lt;span&gt; 23&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; int0=arr[i][0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 24&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; int1=arr[i][1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 25&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; vec=arr_path[int0][int1];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取到路径数组中的一个Vector3对象&lt;/span&gt;
&lt;span&gt; 26&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里有两种思路，一是从顶点数据入手，完全复刻地形的高度；二是从条带的路径索引入手，可以更贴近的生成附着物的多边形轮廓，但在高度方面可能不精确（不贴合），&lt;/span&gt;
&lt;span&gt; 27&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;-&amp;gt;结合使用二者？《-可以实现但过于复杂&lt;/span&gt;
&lt;span&gt; 28&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;假设路径数组和顶点数据是一一对应的？同时假设每一条路径的长度都和第一条相同，如果先剔除三角形就无法这样使用了！&lt;/span&gt;
&lt;span&gt; 29&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; index_v=int0*arr_path[0].length+int1&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个顶点的索引&lt;/span&gt;
&lt;span&gt; 30&lt;/span&gt;             arr_index.push(index_v);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将ground_base中的每次对应的顶点绘制保存起来&lt;/span&gt;
&lt;span&gt; 31&lt;/span&gt; &lt;span&gt;            data_pos2.push(vec.x);
&lt;/span&gt;&lt;span&gt; 32&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(sameheight)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果要求所有顶点等高，则取设定高度&lt;/span&gt;
&lt;span&gt; 33&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 34&lt;/span&gt; &lt;span&gt;                data_pos2.push(height);
&lt;/span&gt;&lt;span&gt; 35&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 36&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt; 37&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 38&lt;/span&gt; &lt;span&gt;                data_pos2.push(vec.y);
&lt;/span&gt;&lt;span&gt; 39&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt; 40&lt;/span&gt; &lt;span&gt;            data_pos2.push(vec.z);
&lt;/span&gt;&lt;span&gt; 41&lt;/span&gt;             data_uv2.push(data_uv[index_v*2&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 42&lt;/span&gt;             data_uv2.push(data_uv[index_v*2+1&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt; 43&lt;/span&gt; 
&lt;span&gt; 44&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 45&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成附着物的索引数组&lt;/span&gt;
&lt;span&gt; 46&lt;/span&gt;         len=&lt;span&gt;arr_index.length;
&lt;/span&gt;&lt;span&gt; 47&lt;/span&gt;         console.log(&quot;开始设定地形附着物的索引&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 48&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于每个顶点索引，它可能被用到多次&lt;/span&gt;
&lt;span&gt; 49&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 50&lt;/span&gt;             console.log(i+&quot;/&quot;+&lt;span&gt;len);
&lt;/span&gt;&lt;span&gt; 51&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; index_v=&lt;span&gt;arr_index[i];
&lt;/span&gt;&lt;span&gt; 52&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;len_index;j+=3)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历ground_base的索引数组，找到所有被绘制的顶点&lt;/span&gt;
&lt;span&gt; 53&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt; 54&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; num2=-1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 55&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; num3=-1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 56&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var arr_temp=[];&lt;/span&gt;
&lt;span&gt; 57&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; flag_type=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 58&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(index_v==data_index[j])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三角形的第一个顶点&lt;/span&gt;
&lt;span&gt; 59&lt;/span&gt;                     {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在这里要考虑另两个顶点是否在附着物范围内，如果在，则使用附着物纹理，如果不在则使用混合纹理？？&lt;/span&gt;
&lt;span&gt; 60&lt;/span&gt;                         num2=data_index[j+1];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;*3;//实际去顶点数组中取顶点时要乘以3，但作为顶点索引时不用乘以3&lt;/span&gt;
&lt;span&gt; 61&lt;/span&gt;                         num3=data_index[j+2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 62&lt;/span&gt;                         flag_type=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 63&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 64&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(index_v==data_index[j+1])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三角形的第二个顶点&lt;/span&gt;
&lt;span&gt; 65&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 66&lt;/span&gt;                         num2=&lt;span&gt;data_index[j];
&lt;/span&gt;&lt;span&gt; 67&lt;/span&gt;                         num3=data_index[j+2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 68&lt;/span&gt;                         flag_type=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 69&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 70&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(index_v==data_index[j+2])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三角形的第三个顶点&lt;/span&gt;
&lt;span&gt; 71&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 72&lt;/span&gt;                         num2=&lt;span&gt;data_index[j];
&lt;/span&gt;&lt;span&gt; 73&lt;/span&gt;                         num3=data_index[j+1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 74&lt;/span&gt;                         flag_type=3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 75&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 76&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(num2!=-1&amp;amp;&amp;amp;num3!=-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 77&lt;/span&gt;                 {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查看num2和num3这两个索引对应的顶点，在不在选定顶点范围内，如果不在则不在附着物里绘制这个三角形&lt;/span&gt;
&lt;span&gt; 78&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;(其实更好的方案是，如果不在，则绘制地形网格和附着物的混合纹理)&lt;/span&gt;
&lt;span&gt; 79&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; flag2=-1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 80&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; flag3=-1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 81&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i2=0;i2&amp;lt;len;i2++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 82&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt; 83&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; index2=&lt;span&gt;arr_index[i2];
&lt;/span&gt;&lt;span&gt; 84&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;(index2==&lt;span&gt;num2)
&lt;/span&gt;&lt;span&gt; 85&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt; 86&lt;/span&gt;                             flag2=i2;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在新的顶点数组中找到这个顶点的索引&lt;/span&gt;
&lt;span&gt; 87&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt; 88&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;(index2==&lt;span&gt;num3)
&lt;/span&gt;&lt;span&gt; 89&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt; 90&lt;/span&gt;                             flag3=&lt;span&gt;i2;
&lt;/span&gt;&lt;span&gt; 91&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt; 92&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;(flag2!=-1&amp;amp;&amp;amp;flag3!=-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 93&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt; 94&lt;/span&gt;                             &lt;span&gt;break&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;都已经找到&lt;/span&gt;
&lt;span&gt; 95&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt; 96&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt; 97&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(flag2!=-1&amp;amp;&amp;amp;flag3!=-1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 98&lt;/span&gt;                     {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果这个三角形的三个顶点都属于地形附着物&lt;/span&gt;
&lt;span&gt; 99&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;(flag_type==1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;100&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;101&lt;/span&gt; &lt;span&gt;                            data_index2.push(i);
&lt;/span&gt;&lt;span&gt;102&lt;/span&gt; &lt;span&gt;                            data_index2.push(flag2);
&lt;/span&gt;&lt;span&gt;103&lt;/span&gt; &lt;span&gt;                            data_index2.push(flag3);
&lt;/span&gt;&lt;span&gt;104&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(flag_type==2&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;106&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;107&lt;/span&gt; &lt;span&gt;                            data_index2.push(flag2);
&lt;/span&gt;&lt;span&gt;108&lt;/span&gt; &lt;span&gt;                            data_index2.push(i);
&lt;/span&gt;&lt;span&gt;109&lt;/span&gt; &lt;span&gt;                            data_index2.push(flag3);
&lt;/span&gt;&lt;span&gt;110&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;111&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(flag_type==3&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;112&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;113&lt;/span&gt; &lt;span&gt;                            data_index2.push(flag2);
&lt;/span&gt;&lt;span&gt;114&lt;/span&gt; &lt;span&gt;                            data_index2.push(flag3);
&lt;/span&gt;&lt;span&gt;115&lt;/span&gt; &lt;span&gt;                            data_index2.push(i);
&lt;/span&gt;&lt;span&gt;116&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;117&lt;/span&gt; 
&lt;span&gt;118&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;119&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;120&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;121&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;122&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数据整理完毕，开始生成几何体&lt;/span&gt;
&lt;span&gt;123&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; normals=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;124&lt;/span&gt;         BABYLON.VertexData.ComputeNormals(data_pos2, data_index2, normals);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算法线&lt;/span&gt;
&lt;span&gt;125&lt;/span&gt;         BABYLON.VertexData._ComputeSides(0, data_pos2, data_index2, normals, data_uv2);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据法线分配纹理朝向&lt;/span&gt;
&lt;span&gt;126&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; vertexData= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BABYLON.VertexData();
&lt;/span&gt;&lt;span&gt;127&lt;/span&gt;         vertexData.indices = data_index2;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引&lt;/span&gt;
&lt;span&gt;128&lt;/span&gt;         vertexData.positions =&lt;span&gt; data_pos2;
&lt;/span&gt;&lt;span&gt;129&lt;/span&gt;         vertexData.normals = normals;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;position改变法线也要改变！！！！&lt;/span&gt;
&lt;span&gt;130&lt;/span&gt;         vertexData.uvs =&lt;span&gt; data_uv2;
&lt;/span&gt;&lt;span&gt;131&lt;/span&gt; 
&lt;span&gt;132&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BABYLON.Mesh(name,scene);
&lt;/span&gt;&lt;span&gt;133&lt;/span&gt;         vertexData.applyToMesh(mesh, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;134&lt;/span&gt;         mesh.vertexData=&lt;span&gt;vertexData;
&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;         mesh.renderingGroupId=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;136&lt;/span&gt;         mesh.material=&lt;span&gt;mat;
&lt;/span&gt;&lt;span&gt;137&lt;/span&gt;         obj_ground[name]=&lt;span&gt;mesh;
&lt;/span&gt;&lt;span&gt;138&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;提取ground_base的地形时有多种可选的算法，假设ground_base的顶点排布如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629071624629-297815472.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设ABF右上侧包括ABF在内的所有顶点都被选中，则我们可能只提取图中画斜线的单元格，也可能提取ACF右上的所有三角形（比前者多了ABC部分），还可能提取AF右上的所有区域（这时需要添加额外的三角形，假设JIHG与CDEF高度不同，则又要考虑不同的额外三角形生成方式），或者提取所有和ABCDEF相邻的单元格。。。不同的提取方法会产生不同的地形细节效果，这里我选择第二种提取方法。&lt;/p&gt;
&lt;p&gt;在处理不同纹理交界处时也存在多种不同的选择，比如基于三角形的实际位置让纹理相互交错，或者在交界处使用混合两种纹理图的过渡纹理等等，这里我简单的保持每种地貌的原本纹理，用后绘制的覆盖先绘制的，用靠近相机的遮挡远离相机的。&lt;/p&gt;
&lt;p&gt;生成上图的命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; MakeLandtype1(obj_ground.ground_base,FindZoneBYDistanceXZ(obj_ground.ground_base,&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(-50,0,10),30&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;             ,mat_tree,&quot;ground_tree1&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         MakeLandtype1(obj_ground.ground_base,FindZoneBYDistanceXZ(obj_ground.ground_base,&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(0,0,0),35&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;             ,mat_shallowwater,&quot;ground_shallowwater1&quot;,&lt;span&gt;true&lt;/span&gt;,0);
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;4、向地形中导入预制的模型生成剧烈变化的地形&lt;br/&gt;向场景中加入了一个“坠毁的宇宙飞船”模型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629072204642-458937965.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从下面看：（左边只显示森林纹理并不是因为草地三角形不存在，而是因为网格位置和渲染组都相同时，后绘制的三角形会覆盖先绘制的三角形）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629074225726-1632055825.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用单纯的地面网格是难以生成图中的反斜面地形的。&lt;br/&gt;导入Babylon格式模型的代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果这里load一个相同内容的txt文件，会报警告，但似乎也成功导入了！！&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; ImportMesh(objname,filepath,filename,obj_p)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        BABYLON.SceneLoader.ImportMesh(objname, filepath, filename, scene
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             , &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (newMeshes, particleSystems, skeletons)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;载入完成的回调函数&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; mesh=newMeshes[0&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 mesh.position=&lt;span&gt;obj_p.position;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 mesh.rotation=&lt;span&gt;obj_p.rotation;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 mesh.scaling=&lt;span&gt;obj_p.scaling;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 mesh.name=&lt;span&gt;obj_p.name;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 mesh.id=&lt;span&gt;obj_p.name;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; mat=&lt;span&gt;obj_p.material.clone();
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 mat.backFaceCulling=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 mat.name=&lt;span&gt;obj_p.material.name;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 mesh.material=&lt;span&gt;mat;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 mesh.renderingGroupId=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 mesh.sideOrientation=&lt;span&gt;BABYLON.Mesh.DOUBLESIDE;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 obj_ground[obj_p.name]=&lt;span&gt;mesh;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; ImportMesh(&quot;&quot;,&quot;../../ASSETS/SCENE/&quot;,&quot;SpaceCraft.babylon&quot;
&lt;span&gt;2&lt;/span&gt;             ,{position:&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(10,-2,10),rotation:&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(0,-Math.PI/4,Math.PI/6&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;                 ,scaling:&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(1,1,1),name:&quot;ground_spacecraft&quot;
&lt;span&gt;4&lt;/span&gt;                 ,material:mat_stone});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;5、保存地面编辑进度&lt;br/&gt;你可能想在做完一些操作后将当前的场景保存起来以备再次载入。&lt;/p&gt;
&lt;p&gt;a、存档代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;52&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;导出正在编辑的地面工程，其中地面网格保持metadata属性，下载文本时参考xlsx的方式&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; ExportObjGround()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; obj_scene=MakeBasicBabylon();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立一个基础场景所需的全部属性&lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(key &lt;span&gt;in&lt;/span&gt; obj_ground)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在Babylon文件中不配置材质，在导入后能否自动对应新场景中的材质id?-》可以，但是会报警告&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; obj_mesh=&lt;span&gt;{};
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;obj_ground[key];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             obj_mesh.name=&lt;span&gt;mesh.name;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             obj_mesh.id=&lt;span&gt;mesh.id;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;             obj_mesh.materialId=&lt;span&gt;mesh.material.name;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;             obj_mesh.position=&lt;span&gt;[mesh.position.x,mesh.position.y,mesh.position.z];
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             obj_mesh.rotation=&lt;span&gt;[mesh.rotation.x,mesh.rotation.y,mesh.rotation.z];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             obj_mesh.scaling=&lt;span&gt;[mesh.scaling.x,mesh.scaling.y,mesh.scaling.z];
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             obj_mesh.isVisible=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             obj_mesh.isEnabled=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             obj_mesh.checkCollisions=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             obj_mesh.billboardMode=0&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             obj_mesh.receiveShadows=&lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             obj_mesh.renderingGroupId=&lt;span&gt;mesh.renderingGroupId;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             obj_mesh.metadata=&lt;span&gt;mesh.metadata;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             obj_mesh.sideOrientation=&lt;span&gt;mesh.sideOrientation;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(mesh.geometry)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是有实体的网格&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; vb=&lt;span&gt;mesh.geometry._vertexBuffers;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 obj_mesh.positions=&lt;span&gt;BuffertoArray2(vb.position._buffer._data);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 obj_mesh.normals=&lt;span&gt;BuffertoArray2(vb.normal._buffer._data);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 obj_mesh.uvs=&lt;span&gt; BuffertoArray2(vb.uv._buffer._data);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                 obj_mesh.indices=&lt;span&gt;BuffertoArray2(mesh.geometry._indices);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 obj_mesh.subMeshes=&lt;span&gt;[{
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                     'materialIndex': 0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                     'verticesStart': 0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                     'verticesCount'&lt;span&gt;: mesh.geometry._totalVertices,
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     'indexStart': 0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                     'indexCount'&lt;span&gt;: mesh.geometry._indices.length,
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                }];
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt;                 obj_mesh.parentId=mesh.parent?mesh.parent.id:&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;非实体网格&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                 obj_mesh.positions=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;                 obj_mesh.normals=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 obj_mesh.uvs=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 obj_mesh.indices=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                 obj_mesh.subMeshes=&lt;span&gt;[{
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     'materialIndex': 0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;                     'verticesStart': 0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                     'verticesCount': 0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;                     'indexStart': 0&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     'indexCount': 0
&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                }];
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt;                 obj_mesh.parentId=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; &lt;span&gt;            obj_scene.meshes.push(obj_mesh);
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; str_data=&lt;span&gt;JSON.stringify(obj_scene);
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;试试看行不行-》行&lt;/span&gt;
&lt;span&gt;58&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tmpDown = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Blob([s2ab(str_data)]
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;            ,{
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;                 type: &quot;&quot;
&lt;span&gt;61&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;         saveAs(tmpDown,&quot;ObjGround.babylon&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中MakeBasicBabylon方法保存了一个最基础的场景对象所需的数据：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;55&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立一个最基础的Babylon对象结构&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; MakeBasicBabylon()
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; obj_scene=
&lt;span&gt; 5&lt;/span&gt;             {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;最简场景对象&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                 'autoClear': &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 'clearColor': [0,0,0&lt;span&gt;],
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 'ambientColor': [0,0,0&lt;span&gt;],
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 'gravity': [0,-9.81,0&lt;span&gt;],
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                 'cameras'&lt;span&gt;:[],
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                 'activeCamera': &lt;span&gt;null&lt;/span&gt;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                 'lights'&lt;span&gt;:[],
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                 'materials'&lt;span&gt;:[],
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 'geometries'&lt;span&gt;: {},
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;                 'meshes'&lt;span&gt;: [],
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 'multiMaterials'&lt;span&gt;: [],
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;                 'shadowGenerators'&lt;span&gt;: [],
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 'skeletons'&lt;span&gt;: [],
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 'sounds': []&lt;span&gt;//&lt;/span&gt;&lt;span&gt;,&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;'metadata':{'walkabilityMatrix':[]}&lt;/span&gt;
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;            };
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj_scene;
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;BuffertoArray2是一个将buffer型数据转为数组的方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; BuffertoArray2(arr)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; arr2=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr.length;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;            arr2.push(arr[i]);
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; arr2;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;保存Babylon模型文件时使用了 https://www.jianshu.com/p/9a465d7d1448博客介绍的文件导出方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; s2ab(s) {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (&lt;span&gt;typeof&lt;/span&gt; ArrayBuffer !== 'undefined'&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; buf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ArrayBuffer(s.length);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; view = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Uint8Array(buf);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i != s.length; ++i) view[i] = s.charCodeAt(i) &amp;amp; 0xFF&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; buf;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; buf = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array(s.length);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; i = 0; i != s.length; ++i) buf[i] = s.charCodeAt(i) &amp;amp; 0xFF&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; buf;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     saveAs=&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(obj, fileName)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; tmpa = document.createElement(&quot;a&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         tmpa.download = fileName || &quot;下载&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         tmpa.href =&lt;span&gt; URL.createObjectURL(obj);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;        tmpa.click();
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;         setTimeout(&lt;span&gt;function&lt;/span&gt;&lt;span&gt; () {
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;            URL.revokeObjectURL(obj);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         }, 100&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     };
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;6、小结：&lt;/p&gt;
&lt;p&gt;以上内容可以访问https://ljzc002.github.io/EmptyTalk/HTML/TEST/testframe3.html进行测试&lt;/p&gt;
&lt;p&gt;在之前研究基于编程的模型编辑器时（ https://www.cnblogs.com/ljzc002/p/9353101.html，https://www.cnblogs.com/ljzc002/p/9473438.html  ），如何在自定义的模型上绘制纹理一直是一个难题，曾经在更早期的编辑器Demo（https://www.cnblogs.com/ljzc002/p/6884252.html）中尝试过用选择三角形设置图素，之后按照图素生成图片的方式绘制纹理图，但也只能作为原理解释Demo而难以实用。这里编写的贴合表面的附着物算法在稍加修改后将可以解决在一个模型上绘制多种纹理的难题。当然，这种“纹理附着物”的方法会在一个模型中建立多个网格，并且在网格相互覆盖的地方产生一些多余的三角形，在后文中我将尝试用“降雨法”剔除这些多余的三角形。（事实上剔除多余三角形后渲染速度并没有提升很多。。。）&lt;/p&gt;
&lt;p&gt;三、&lt;/p&gt;
&lt;p&gt;使用降雨法剔除被遮挡的三角形&lt;br/&gt;1、首先导入我们之前保存的存档，执行以下命令导入之前做好的一个存档：&lt;/p&gt;
&lt;p&gt;ImportObjGround(&quot;../../ASSETS/SCENE/&quot;,&quot;ObjGround.babylon&quot;,webGLStart3);&lt;/p&gt;
&lt;p&gt;ImportObjGround方法代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; ImportObjGround(filepath,filename,func)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         BABYLON.SceneLoader.ImportMesh(&quot;&quot;&lt;span&gt;, filepath, filename, scene
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             , &lt;span&gt;function&lt;/span&gt;&lt;span&gt; (newMeshes, particleSystems, skeletons)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;载入完成的回调函数&lt;/span&gt;
&lt;span&gt; 6&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;newMeshes.length;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;                 &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;len;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;newMeshes[i];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;                     mesh.renderingGroupId=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;                     mesh.sideOrientation=&lt;span&gt;BABYLON.Mesh.DOUBLESIDE;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;                     obj_ground[mesh.name]=&lt;span&gt;mesh;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(mesh.name==&quot;ground_base&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                     {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明顶点位置是可变的！！&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                         mesh.markVerticesDataAsUpdatable(BABYLON.VertexBuffer.PositionKind&lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实就是“position”，除此之外还有“normal”等&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;                             ,&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(mesh.metadata&amp;amp;&amp;amp;&lt;span&gt;mesh.metadata.arr_path)
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;要把array重新变成Vector3！！！！&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; arr_path=&lt;span&gt;mesh.metadata.arr_path;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                         &lt;span&gt;var&lt;/span&gt; len1=&lt;span&gt;arr_path.length;
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;len1;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; path=&lt;span&gt;arr_path[j];
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; len2=&lt;span&gt;path.length;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; k=0;k&amp;lt;len2;k++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; vec=&lt;span&gt;path[k];
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;                                 &lt;span&gt;var&lt;/span&gt; vec2=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BABYLON.Vector3(vec.x,vec.y,vec.z);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                                 path[k]=&lt;span&gt;vec2;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                 func();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;导入完成后执行&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;        );
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里要注意的是，导入模型后网格的updatable属性会自动变为false，这时需要使用markVerticesDataAsUpdatable方法重新激活网格的更新能力。同时Babylon.js的Vector3对象在转为JSON字符串时，会自动的退化为JavaScript的Object对象，我们在载入时需要重新将它转为Vector3。&lt;/p&gt;
&lt;p&gt;2、准备下雨&lt;/p&gt;
&lt;p&gt;降雨算法并不复杂，思路是从相机可能的观察方向发出密集的射线，如果射线击中某一三角形，则把三角形的三个顶点“淋湿”（所有淋湿的顶点组成“淋湿数组”），在降雨完成后，剔除掉没有淋湿的顶点及对应顶点索引，使模型得到简化。&lt;br/&gt;与传统的网格融合方法相比，降雨法不会在网格的接口处生成大量不受控的三角形；与传统网格简化方法相比，则不会丢弃可见的三角形细节；缺点则是计算耗时较长（也许可以优化？）&lt;br/&gt;首先准备下雨：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; PrepareRain()
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         console.log(&quot;准备下雨&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         mesh_DropFrom=&lt;span&gt;new&lt;/span&gt; BABYLON.Mesh(&quot;mesh_DropFrom&quot;&lt;span&gt;,scene);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj_ground)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;obj_ground[key];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{};
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             obj.vb=mesh.geometry._vertexBuffers;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地面网格的顶点数据&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             obj.data_pos=obj.vb.position._buffer._data;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;顶点位置数据&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             obj.data_index=mesh.geometry._indices;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;网格索引数据&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             obj.data_uv=obj.vb.uv._buffer._data;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地面网格的纹理坐标数据&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             obj.len_index=&lt;span&gt;obj.data_index.length;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             obj.len_pos=obj.data_pos.length/3;
&lt;span&gt;15&lt;/span&gt;             obj.data_wet=[];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个顶点是否被淋湿&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;obj.len_pos;i+=1&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 obj.data_wet.push(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             obj.arr_index=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             obj.data_pos2=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             obj.data_index2=[];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二次循环时填充&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;             obj.data_uv2=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;             obj_wet[key]=&lt;span&gt;obj;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;         console.log(&quot;准备完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; PrepareRain2()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;         console.log(&quot;读取本地淋湿数组&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;         mesh_DropFrom=&lt;span&gt;new&lt;/span&gt; BABYLON.Mesh(&quot;mesh_DropFrom&quot;&lt;span&gt;,scene);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj_ground)
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;obj_ground[key];
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;{};
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;             obj.vb=mesh.geometry._vertexBuffers;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地面网格的顶点数据&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;             obj.data_pos=obj.vb.position._buffer._data;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;顶点位置数据&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt;             obj.data_index=mesh.geometry._indices;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;网格索引数据&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt;             obj.data_uv=obj.vb.uv._buffer._data;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;地面网格的纹理坐标数据&lt;/span&gt;
&lt;span&gt;40&lt;/span&gt;             obj.len_index=&lt;span&gt;obj.data_index.length;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;             obj.len_pos=obj.data_pos.length/3;
&lt;span&gt;42&lt;/span&gt;             obj.data_wet=localStorage.getItem(key);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;每个顶点是否被淋湿&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;             obj.arr_index=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;             obj_wet[key]=&lt;span&gt;obj;
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;         console.log(&quot;准备完毕&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;第一个方法提取出了降雨所需的地面对象中的每个网格的数据，其中obj.data_wet是一个长度与顶点数组相同的的全零数组，0表示没有淋湿。第二个方法，则从浏览器的本地存储中读取已经算好的淋湿数组，用预先算好的数据节省下雨所需的时间。mesh_DropFrom网格则是后面降雨所用到的参照物网格。&lt;/p&gt;
&lt;p&gt;3、开始下雨（这时一个非常耗时的计算）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;94&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;//&lt;/span&gt;&lt;span&gt;宽度分段、深度分段、每块尺寸（在这个尺寸内有四条射线）,“射线”长度,所有射线出发点的中心&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DropRain(100,100,1,100,new BABYLON.Vector3(0,50,0),new BABYLON.Vector3(0,0,0))&lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;DropRain(200,200,0.5,100,new BABYLON.Vector3(0,50,0),new BABYLON.Vector3(0,0,0))&lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; DropRain(count_x,count_z,size,length,from,to)
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         mesh_DropFrom.position=&lt;span&gt;from;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         mesh_DropFrom.lookAt(to);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这时网格的WorldMatrix和AbsoulutPosition还未改变！！&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;其实应该是网格的负Y方向指向to！！！！这个矩阵的最终效果应该是x，y，z左移一位&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;        mesh_DropFrom.computeWorldMatrix();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; matrix=mesh_DropFrom.getWorldMatrix();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;取参考网格的世界矩阵&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; size41=size/4;
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; direction=to.subtract(from);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;雨丝在世界坐标系中的方向&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;遍历101*101个方块，降雨角度不同时设计不同的分段数&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;         console.log(&quot;开始下雨&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;=count_x;i++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;=count_z;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                 console.log(i+&quot;/&quot;+count_x+&quot;_&quot;+j+&quot;/&quot;+&lt;span&gt;count_z);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; arr_wet=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; pos0=&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3((j-(count_z/2))*size,(i-(count_x/2))*size,0);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;预先右移一位？&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;左上，右上，右下，左下&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;建立四条射线，局部坐标系中的变换&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; pos1=BABYLON.Vector3.TransformCoordinates(pos0.clone().add(&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(size41,-size41,0&lt;span&gt;)),matrix);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; pos2=BABYLON.Vector3.TransformCoordinates(pos0.clone().add(&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(size41,size41,0&lt;span&gt;)),matrix);
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; pos3=BABYLON.Vector3.TransformCoordinates(pos0.clone().add(&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(-size41,size41,0&lt;span&gt;)),matrix);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; pos4=BABYLON.Vector3.TransformCoordinates(pos0.clone().add(&lt;span&gt;new&lt;/span&gt; BABYLON.Vector3(-size41,-size41,0&lt;span&gt;)),matrix);
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var ray=new BABYLON.Ray(new BABYLON.Vector3(-50,50,0), new BABYLON.Vector3(0,-1,0), 100);&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ray1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BABYLON.Ray(pos1, direction, length);
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ray2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BABYLON.Ray(pos2, direction, length);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ray3 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BABYLON.Ray(pos3, direction, length);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; ray4 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BABYLON.Ray(pos4, direction, length);
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于每一束射线，如果击中的第一个网格不是&quot;ground_alpha&quot;,则只淋湿第一个网格&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt; ，否则还如此检查第二个，四条射线的检查结果都放在同一数组中&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;                 &lt;span&gt;//&lt;/span&gt;&lt;span&gt;，击中了处于相同位置的ground_base和其他ground，优先选拔其他ground&lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;                 testRay(ray1,size);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;检查射线淋湿的网格&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                testRay(ray2,size);
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt; &lt;span&gt;                testRay(ray3,size);
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                testRay(ray4,size);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;为了节省时间，把淋湿数组保存在本地存储里&lt;/span&gt;
&lt;span&gt;43&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj_wet)
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;            localStorage.setItem(key,obj_wet[key].data_wet);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt;         console.log(&quot;降雨结束&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;考虑到可能斜着下雨，我们使用矩阵变换调整每一条雨丝的起点和方向，在mesh_DropFrom的局部坐标系中，每条雨丝的降雨起点都像地块单元格一样平整的排列，用lookAt方法将mesh_DropFrom倾斜一些则所有雨丝也跟着倾斜了。这里要注意的是lookAt方法默认将mesh_DropFrom的“正面”指向目标（to），而我们需要的则是将mesh_DropFrom的“下面”指向目标，这一差异会使得最终世界坐标系中的的坐标左移一位，也就是（x,y,z）变成了（y,z,x）,所以我们在mesh_DropFrom的局部坐标系内计算时就预先将坐标右移一位。&lt;/p&gt;
&lt;p&gt;降雨的示意图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629073752937-1668848816.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从每个mesh_DropFrom的“单元格”中射出四条射线，使用testRay方法判断这些射线与地面网格的接触情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; sort_compare(a,b)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; a.distance-&lt;span&gt;b.distance;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;function&lt;/span&gt;&lt;span&gt; testRay(ray,size)
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; arr=scene.multiPickWithRay(ray,predicate);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;射线的多重选取，这样获取的arr并不是按distance顺序排序的！！！！&lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;arr.length;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         arr.sort(sort_compare)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;按距离从近到远排序&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; lastHit=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; k=0;k&amp;lt;len;k++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于这条射线击中的每个三角形&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; hit=&lt;span&gt;arr[k];
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;hit.pickedMesh;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; distance=&lt;span&gt;hit.distance;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt;(mesh)
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(lastHit)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经有上一层&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;                 {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果上一层是半透明的，则下一层必定被淋湿，如果上一层是ground_base，则要看两层之间的距离&lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(lastHit.pickedMesh.name.substr(0,11)==&quot;ground_base&quot;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;((distance-lastHit.distance)&amp;gt;(size/1000))//如果距离太大，则不会淋湿
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;                            getWet(lastHit);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果距离较近，则优先淋湿地形附着物&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;                            getWet(hit);
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;没有上一层&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt;                     &lt;span&gt;if&lt;/span&gt;(mesh.name.substr(0,11)!=&quot;ground_base&quot;)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果是地面网格，则还不确定是否淋湿，其他网格必定淋湿&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; &lt;span&gt;                        getWet(hit);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                     &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(k==(len-1))&lt;span&gt;//&lt;/span&gt;&lt;span&gt;已经遍历到最后一层&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt; &lt;span&gt;                        getWet(hit);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                 &lt;span&gt;var&lt;/span&gt; name=&lt;span&gt;mesh.name;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(name&amp;amp;&amp;amp;(name.substr(0,12)==&quot;ground_alpha&quot;||name.substr(0,11)==&quot;ground_base&quot;&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                     lastHit=&lt;span&gt;hit;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt;                 &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     lastHit=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;                     &lt;span&gt;break&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果上一层就是其他类型的网格，则不再继续深入检测&lt;/span&gt;
&lt;span&gt;52&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;55&lt;/span&gt; &lt;span&gt;            {
&lt;/span&gt;&lt;span&gt;56&lt;/span&gt;                 lastHit=&lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;                 &lt;span&gt;break&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里将可能出现的地形网格分为三类：半透明地形网格(以ground_alpha为前缀)，基础地形网格（以ground_base为前缀），地形附着物网格（以ground为前缀），规定半透明网格不会阻挡雨水，附着物网格和基础网格距离较近时附着物网格优先淋湿。&lt;br/&gt;确定会淋湿后，用getWet方法将三角形的顶点放入淋湿数组：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt;&lt;span&gt; getWet(hit)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;hit.pickedMesh;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; name=&lt;span&gt;mesh.name;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; faceId=&lt;span&gt;hit.faceId;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; indices =&lt;span&gt; mesh.getIndices();
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; index0 = indices[faceId * 3&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; index1 = indices[faceId * 3 + 1&lt;span&gt;];
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; index2 = indices[faceId * 3 + 2&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;var&lt;/span&gt; wet=obj_wet[name];&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个顶点被淋湿&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;         wet.data_wet[index0]=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         wet.data_wet[index1]=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         wet.data_wet[index2]=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、根据淋湿数组剔除三角形：（这是一个更加耗时的计算）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;function&lt;/span&gt; SpliceRain(obj_ground)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过改变数据结构，可以只测试其中的一个网格&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; key &lt;span&gt;in&lt;/span&gt;&lt;span&gt; obj_ground)
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;             console.log(&quot;清理&quot;+&lt;span&gt;key);
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; obj=&lt;span&gt;obj_wet[key];
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; len=&lt;span&gt;obj.len_pos;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data_wet=obj.data_wet;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;淋湿数组，长度是顶点数组的三分之一&lt;/span&gt;
&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data_pos=obj.data_pos;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;顶点数组&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data_index=obj.data_index&lt;span&gt;//&lt;/span&gt;&lt;span&gt;顶点索引&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; data_uv=obj.data_uv&lt;span&gt;//&lt;/span&gt;&lt;span&gt;纹理坐标&lt;/span&gt;
&lt;span&gt;12&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;var count_splice=0;&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; i=0;i&amp;lt;data_wet.length;i++)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;对于每一个顶点,这里一定要注意顺序&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt;             {&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果这个顶点没有被淋湿，则要清除这个顶点，如果不清除顶点只是清除索引，能不能快一些？&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt;                 console.log(i+&quot;/&quot;+&lt;span&gt;data_wet.length);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;                 &lt;span&gt;if&lt;/span&gt;(!data_wet[i])&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有淋湿&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;                {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;                     data_pos.splice(i*3,3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;                     data_uv.splice(i*2,2&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;                     data_wet.splice(i,1&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; 
&lt;span&gt;22&lt;/span&gt;                     &lt;span&gt;//&lt;/span&gt;&lt;span&gt;count_splice++;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;                     &lt;span&gt;var&lt;/span&gt; len2=&lt;span&gt;obj.len_index;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;                     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;var&lt;/span&gt; j=0;j&amp;lt;obj.len_index;j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;                    {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;                         &lt;span&gt;if&lt;/span&gt;(data_index[j]&amp;gt;i)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果这个索引值大于被剔除的顶点&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;                             data_index[j]-=1;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;count_splice;&lt;/span&gt;
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;                         &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(data_index[j]==i)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果这个索引正是被剔除的顶点&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;                        {
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;                             &lt;span&gt;var&lt;/span&gt; int_temp=j%3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;                             &lt;span&gt;if&lt;/span&gt;(int_temp==0)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三角形的第一个顶点&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;35&lt;/span&gt;                                 data_index.splice(j,3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;                                 j-=1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;                             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(int_temp==1)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三角形的第二个顶点&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;                                 data_index.splice(j-1,3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;                                 j-=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;                             &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(int_temp==2)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;三角形的第三个顶点&lt;/span&gt;
&lt;span&gt;44&lt;/span&gt; &lt;span&gt;                            {
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt;                                 data_index.splice(j-2,3&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;                                 j-=3&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; &lt;span&gt;                            }
&lt;/span&gt;&lt;span&gt;48&lt;/span&gt; &lt;span&gt;                        }
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt; &lt;span&gt;                    }
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;                     i--&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt; &lt;span&gt;                }
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; &lt;span&gt;            }
&lt;/span&gt;&lt;span&gt;53&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;剔除之后开始生成网格&lt;/span&gt;
&lt;span&gt;54&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; normals=&lt;span&gt;[];
&lt;/span&gt;&lt;span&gt;55&lt;/span&gt;             BABYLON.VertexData.ComputeNormals(data_pos, data_index, normals);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;计算法线&lt;/span&gt;
&lt;span&gt;56&lt;/span&gt;             BABYLON.VertexData._ComputeSides(0, data_pos, data_index, normals, data_uv);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;根据法线分配纹理朝向&lt;/span&gt;
&lt;span&gt;57&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; vertexData= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; BABYLON.VertexData();
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;             vertexData.indices = data_index;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;索引&lt;/span&gt;
&lt;span&gt;59&lt;/span&gt;             vertexData.positions =&lt;span&gt; data_pos;
&lt;/span&gt;&lt;span&gt;60&lt;/span&gt;             vertexData.normals = normals;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;position改变法线也要改变！！！！&lt;/span&gt;
&lt;span&gt;61&lt;/span&gt;             vertexData.uvs =&lt;span&gt; data_uv;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt; 
&lt;span&gt;63&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; mesh=&lt;span&gt;obj_ground[key];
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; mat=&lt;span&gt;mesh.material;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; pos=&lt;span&gt;mesh.position;
&lt;/span&gt;&lt;span&gt;66&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; rot=&lt;span&gt;mesh.rotation;
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;             &lt;span&gt;var&lt;/span&gt; scal=&lt;span&gt;mesh.scaling;
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt; &lt;span&gt;            mesh.dispose();
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;             mesh=&lt;span&gt;new&lt;/span&gt;&lt;span&gt; BABYLON.Mesh(key,scene);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;mesh&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt;             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;mesh=new BABYLON.Mesh(name,scene);&lt;/span&gt;
&lt;span&gt;72&lt;/span&gt;             vertexData.applyToMesh(mesh, &lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;             mesh.vertexData=&lt;span&gt;vertexData;
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;             mesh.sideOrientation=&lt;span&gt;BABYLON.Mesh.DOUBLESIDE;
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;             mesh.renderingGroupId=2&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;76&lt;/span&gt;             mesh.material=&lt;span&gt;mat;
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;             mesh.position=&lt;span&gt;pos;
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;             mesh.rotation=&lt;span&gt;rot;
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;             mesh.scaling=&lt;span&gt;scal;
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;             obj_ground[key]=&lt;span&gt;mesh;
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;82&lt;/span&gt;     }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里需要从顶点数组和顶点索引数组中剔除未淋湿的顶点，同时要根据顶点数目的变化减小顶点索引数组中所有超过剔除顶点的值。其他的计算和生成地形附着物相似。&lt;br/&gt;剔除之后的渲染效果如图所示：&lt;/p&gt;
&lt;p&gt;较稀疏的雨丝：（DropRain(100,100,1,100,new BABYLON.Vector3(0,50,0),new BABYLON.Vector3(0,0,0))）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629074129757-1255065380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629074148380-660868637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，没有被淋湿的浅水三角形被剔除了，另一方面因为飞船的网格比雨丝更密集，很多网格没有被淋湿。&lt;/p&gt;
&lt;p&gt;较密集的雨丝：（DropRain(200,200,0.5,100,new BABYLON.Vector3(0,50,0),new BABYLON.Vector3(0,0,0))）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629074632081-1357031544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/657116/201906/657116-20190629074646852-1664796866.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到模型中还存在一些空洞，再添加一些其他方向的小规模降雨即可解决。&lt;br/&gt;除了这种类似“方向光”的降雨方法外，还可以根据实际需要编写其他的降雨方式，比如参考“点光源”从一个点向周围发出射线，也可以使用一些边界判断方法直接剔除一定范围内的所有顶点（边界判断方法可以参考 https://www.cnblogs.com/ljzc002/p/10168547.html）&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;地基已经搭好，接下来可以向场景中添加各种角色并进行互动了。&lt;/p&gt;
</description>
<pubDate>Fri, 28 Jun 2019 23:51:00 +0000</pubDate>
<dc:creator>ljzc002</dc:creator>
<og:description>总述：大部分3D编程都涉及到地面元素，在场景中我们使用地面作为其他物体的承载基础，同时也用地面限制场景使用者的移动范围，还可以通过设置地块的属性为场景的不同位置设置对应的计算规则。本文在WebGL平台</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ljzc002/p/11105496.html</dc:identifier>
</item>
<item>
<title>asp.net core 系列之Startup - Vincent-yuan</title>
<link>http://www.cnblogs.com/Vincent-yuan/p/11105523.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Vincent-yuan/p/11105523.html</guid>
<description>&lt;p class=&quot;p&quot;&gt;&lt;span&gt;这篇文章简单记录&lt;/span&gt; ASP.NET Core中 ，startup类的一些使用。&lt;/p&gt;
&lt;h2 class=&quot;p&quot;&gt; 一.前言&lt;/h2&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;在&lt;/span&gt; Startup类中，一般有两个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ConfigureServices 方法: 用来配置应用的 service 。 &lt;/li&gt;
&lt;li&gt;Configure 方法：创建应用的请求处理管道&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;p&quot;&gt;&lt;span&gt;它们都在应用启动时，被&lt;/span&gt;ASP.NET Core runtime 调用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use this method to add services to the container.&lt;/span&gt;
    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services&lt;/span&gt;)
    {
        ...
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Use this method to configure the HTTP request pipeline.&lt;/span&gt;
    &lt;span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt; Configure(IApplicationBuilder app&lt;/span&gt;)
    {
        ...
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt; &lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;当应用的&lt;/span&gt; host 被built(建立)时，Startup类被指定到应用中。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;而在&lt;/span&gt; Program 中，当 host builder 上的 Build 被调用时，应用的 host 被 built 。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;而&lt;/span&gt;Startup类是通过调用WebHostBuilderExtensions.UseStartup&amp;lt;TStartup&amp;gt;方法指定的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        CreateWebHostBuilder(args).&lt;span&gt;Build()&lt;/span&gt;.Run(); &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Build方法被调用时，应用的host被建立，同时Startup被指定到应用中&lt;/span&gt;
&lt;span&gt;    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateWebHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
        WebHost.CreateDefaultBuilder(args)
            .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p class=&quot;p&quot;&gt;在startup类中，一种依赖注入的常见用法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IHostingEnvironment _env;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IConfiguration _config;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; ILoggerFactory _loggerFactory;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;&lt;span&gt; Startup(IHostingEnvironment env, IConfiguration config, 
        ILoggerFactory loggerFactory&lt;/span&gt;)
    {
        _env &lt;/span&gt;=&lt;span&gt; env;
        _config &lt;/span&gt;=&lt;span&gt; config;
        _loggerFactory &lt;/span&gt;=&lt;span&gt; loggerFactory;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; logger = _loggerFactory.CreateLogger&amp;lt;Startup&amp;gt;&lt;span&gt;();

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (_env.IsDevelopment())
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Development service configuration&lt;/span&gt;
&lt;span&gt;
            logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Development environment&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }
        &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Non-development service configuration&lt;/span&gt;&lt;span&gt;
            logger.LogInformation($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Environment: {_env.EnvironmentName}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Configuration is available during startup.
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Examples:
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   _config[&quot;key&quot;]
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;   _config[&quot;subsection:suboption1&quot;]&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p class=&quot;p&quot;&gt;&lt;span&gt;注入&lt;/span&gt;IHostingEnvironment ， 当定义不同环境的Startup （例如，StartupDevelopment 等），在运行时，选择合适的Startup。 &lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;二.ConfigureServices方法&lt;/strong&gt;&lt;/h2&gt;
&lt;p class=&quot;p&quot;&gt;它有三个特点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;可选的&lt;/span&gt; &lt;/li&gt;
&lt;li&gt;&lt;span&gt;在调用&lt;/span&gt;Configure方法之前调用 ConfigureServices&lt;/li&gt;
&lt;li&gt;Configuration options 按约定设置&lt;/li&gt;
&lt;/ul&gt;&lt;p class=&quot;p&quot;&gt;1. 比较典型的是调用 Add{Service} 和 services.Configure{Service} 。例如：&lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/en-us/aspnet/core/security/authentication/identity?view=aspnetcore-2.2#pw&quot; data-linktype=&quot;relative-path&quot;&gt;Configure Identity services&lt;/a&gt;.&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190629070458247-604380829.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;2. host 可能会 在Startup方法被调用之前，配置一些服务。 例如： &lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/index?view=aspnetcore-2.2#host&quot; data-linktype=&quot;relative-path&quot;&gt;The host&lt;/a&gt;.&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190629070607110-1900052913.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;在startup被调用之前，CreateDefaultBuilder方法配置了一个host 。&lt;/p&gt;
&lt;p class=&quot;p&quot;&gt;3. Add{Service}是IServiceCollection的扩展方法，下面是一些使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    services.AddDbContext&lt;/span&gt;&amp;lt;ApplicationDbContext&amp;gt;(options =&amp;gt;&lt;span&gt;
        options.UseSqlServer(
            Configuration.GetConnectionString(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DefaultConnection&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)));
    services.AddDefaultIdentity&lt;/span&gt;&amp;lt;IdentityUser&amp;gt;&lt;span&gt;()
        .AddDefaultUI(UIFramework.Bootstrap4)
        .AddEntityFrameworkStores&lt;/span&gt;&amp;lt;ApplicationDbContext&amp;gt;&lt;span&gt;();


    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Add application services. 添加应用的服务&lt;/span&gt;
    services.AddTransient&amp;lt;IEmailSender, AuthMessageSender&amp;gt;&lt;span&gt;();
    services.AddTransient&lt;/span&gt;&amp;lt;ISmsSender, AuthMessageSender&amp;gt;&lt;span&gt;();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;添加 services 到 service container 使它们在应用和Configure方法中可用。&lt;span&gt;services方法可以通过 dependency injection 或 ApplicationServices 解析。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;三.The Configure method&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Configure方法用来指定应用怎样 处理HTTP request&lt;/span&gt;。请求管道(request pipeline)通过添加中间组件到IApplicationBuilder实例中来配置。&lt;/p&gt;
&lt;p&gt;ASP.NET Core 模板 配置的管道：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
    {
        app.UseDeveloperExceptionPage();
    }
    &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
    {
        app.UseExceptionHandler(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/Error&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        app.UseHsts();
    }

    app.UseHttpsRedirection();
    app.UseStaticFiles();
    app.UseCookiePolicy();

    app.UseMvc();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;使用Use扩展方法添加一个或多个中间组件到请求管道&lt;/span&gt;。例如，UseMvc扩展方法添加 Routing Middleware 到请求管道 并且配置MVC 作为一个默认的处理器。&lt;/p&gt;
&lt;h2&gt;四.Convenience methods&lt;/h2&gt;
&lt;p&gt;不使用Startup类配置services和request processing pipeline。在host builder 上调用ConfigureServices和Configure的简便方法。如果存在多个ConfigureServices的调用，会依次添加。如果存在多个Configure方法的调用，最后一个Configure的调用会被使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IHostingEnvironment HostingEnvironment { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IConfiguration Configuration { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
    {
        CreateWebHostBuilder(args).Build().Run();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder CreateWebHostBuilder(&lt;span&gt;string&lt;/span&gt;[] args) =&amp;gt;&lt;span&gt;
        WebHost.CreateDefaultBuilder(args)
            .ConfigureAppConfiguration((hostingContext, config) &lt;/span&gt;=&amp;gt;&lt;span&gt;
            {
            })
            &lt;span&gt;.ConfigureServices(services &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;
            {
                ...
            })
            &lt;span&gt;.Configure(app &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&amp;gt;&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; loggerFactory =&lt;span&gt; app.ApplicationServices
                    .GetRequiredService&lt;/span&gt;&amp;lt;ILoggerFactory&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; logger = loggerFactory.CreateLogger&amp;lt;Program&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; env = app.ApplicationServices.GetRequiredServices&amp;lt;IHostingEnvironment&amp;gt;&lt;span&gt;();
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; config = app.ApplicationServices.GetRequiredServices&amp;lt;IConfiguration&amp;gt;&lt;span&gt;();

                logger.LogInformation(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Logged in Configure&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (env.IsDevelopment())
                {
                    ...
                }
                &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
                {
                    ...
                }

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configValue = config[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;subsection:suboption1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;];

                ...
            });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五.Extend Startup with startup filters (使用startup filter扩展 Startup)&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;使用 IStartupFilter ，在应用的Configure 中间件管道的开头或末尾配置中间件&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;IStartupFilter 实现Configure方法，它会接收和返回一个Action&amp;lt;IApplicationBuilder&amp;gt;。而IApplicationBuilder定义了一个类来配置一个应用的请求管道。&lt;/p&gt;
&lt;p&gt;这些filters会按照添加到services container的顺序被调用。&lt;/p&gt;
&lt;p&gt;下面是一个例子：&lt;/p&gt;
&lt;p&gt;RequestSetOptionsMiddleware&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RequestSetOptionsMiddleware
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; RequestDelegate _next;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; IOptions&amp;lt;AppOptions&amp;gt;&lt;span&gt; _injectedOptions;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; RequestSetOptionsMiddleware(
        RequestDelegate next, IOptions&lt;/span&gt;&amp;lt;AppOptions&amp;gt;&lt;span&gt; injectedOptions)
    {
        _next &lt;/span&gt;=&lt;span&gt; next;
        _injectedOptions &lt;/span&gt;=&lt;span&gt; injectedOptions;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt;&lt;span&gt; Task Invoke(HttpContext httpContext)
    {
        Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;RequestSetOptionsMiddleware.Invoke&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;&lt;span&gt;var&lt;/span&gt; option = httpContext.Request.Query[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;option&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;]&lt;/span&gt;; //取请求中的option参数

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;string&lt;/span&gt;&lt;span&gt;.IsNullOrWhiteSpace(option))
        {
            &lt;span&gt;_injectedOptions.Value.Option &lt;/span&gt;&lt;/span&gt;&lt;span&gt;=&lt;/span&gt;&lt;span&gt;&lt;span&gt; WebUtility.HtmlEncode(option)&lt;/span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _next(httpContext);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;RequestSetOptionsMiddleware 中间件被配置在 RequestSetOptionsStartupFilter 类中：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; RequestSetOptionsStartupFilter : IStartupFilter
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Action&amp;lt;IApplicationBuilder&amp;gt; Configure(Action&amp;lt;IApplicationBuilder&amp;gt;&lt;span&gt; next)
    {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; builder =&amp;gt;&lt;span&gt;
        {
            &lt;span&gt;builder.UseMiddleware&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;RequestSetOptionsMiddleware&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;()&lt;/span&gt;;
            next(builder);
        };
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;IStartupFilter 在 ConfigureServices中被注册到 service container， 并且从Startup类的外部增强Startup：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;WebHost.CreateDefaultBuilder(args)
    .ConfigureServices(services &lt;/span&gt;=&amp;gt;&lt;span&gt;
    {
        &lt;span&gt;services.AddTransient&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;span&gt;IStartupFilter, 
            RequestSetOptionsStartupFilter&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;();&lt;/span&gt;
    })
    .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;()
    .Build();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当option的查询字符串存在时，中间件会在MVC中间件之前处理这个值&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1182288/201906/1182288-20190629074017776-1784151278.png&quot; alt=&quot;&quot; width=&quot;716&quot; height=&quot;286&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;中间件的执行顺序是按照IStartupFilter的注册顺序&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;六. 补充&lt;/h2&gt;
&lt;p&gt;这里晚上补充下 &lt;a class=&quot;xref&quot; href=&quot;https://docs.microsoft.com/dotnet/api/microsoft.aspnetcore.builder.iapplicationbuilder.applicationservices&quot; data-linktype=&quot;external&quot;&gt;ApplicationServices&lt;/a&gt; 解析services的使用&lt;/p&gt;
&lt;p&gt;参考网址：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup?view=aspnetcore-2.2&quot;&gt;https://docs.microsoft.com/en-us/aspnet/core/fundamentals/startup?view=aspnetcore-2.2&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Jun 2019 23:49:00 +0000</pubDate>
<dc:creator>Vincent-yuan</dc:creator>
<og:description>这篇文章简单记录 ASP.NET Core中 ，startup类的一些使用。 一.前言 在 Startup类中，一般有两个方法： ConfigureServices 方法: 用来配置应用的 servi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Vincent-yuan/p/11105523.html</dc:identifier>
</item>
<item>
<title>重定向Redirect 的知识 - 飞翔码农</title>
<link>http://www.cnblogs.com/feixiangmanon/p/11105239.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/feixiangmanon/p/11105239.html</guid>
<description>&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;今天下班的时候看到了一些重定向的基础知识，也算开了眼界。以前也经常使用301和302，但从来没有使用过和了解过其他的3XX的状态码，发现原来里面涉及的知识和解决的问题的还不少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;重定向的流程&quot;&gt;重定向的流程&lt;/h3&gt;
&lt;p&gt;浏览器首先访问服务器A的URL，服务器A返回带着location为B的URL的 header 和3XX的状态码，浏览器读取响应的3XX状态码，获取到头部的 location，然后跳转到服务器B的URL。&lt;br/&gt;需要知道的，跳转是浏览器发起的。如果服务器给一个非浏览器的终端返回了3XX的状态码，那有可能是无法完成重定向的。&lt;br/&gt;某年，有个应该用已经运行很很长时间了，PHP写的API接口。一直使用的是HTTP，经常被劫持，然后领导想替换成加密的HTTPS，但是客户端不能发版。后来服务器端就考虑把全站的接口从HTTP 302到HTTPS，讨论这个方案的可行性。如果知道上面的流程和知识这个方案立马就PASS了。&lt;/p&gt;
&lt;h3 id=&quot;永久重定向&quot;&gt;永久重定向&lt;/h3&gt;
&lt;p&gt;表示资源永久性的跳转到新的URL。&lt;br/&gt;一个比较常见的案例就是老站迁移到新站，老站直接关闭后，老站的页面已经被搜索引擎收录了，这个时候使用永久重定向方案。&lt;br/&gt;永久重定向两个状态码&lt;br/&gt;301，重定向请求通常会使用GET方法，不管原请求使用的是何种方法。&lt;br/&gt;308，为了补充301.重定向必须使用原请求的方法和包体访问。&lt;/p&gt;
&lt;h3 id=&quot;临时重定向&quot;&gt;临时重定向&lt;/h3&gt;
&lt;p&gt;表示资源只是临时跳转到新的URL&lt;br/&gt;临时重定向一共有五个状态码，常用也就相对应的两个302和307.&lt;br/&gt;302，重定向请求通常会使用GET方法，不管原请求使用的是何种方法。&lt;br/&gt;303，并不表示资源变更，只是表示用新的URL的响应代替原请求。不管原请求使用的是何种方法。基本跟302一致，所以市面很少用303，都是使用302.&lt;br/&gt;307，为了补充302.重定向必须使用原请求的方法和包体访问。&lt;br/&gt;百度就是使用的307跳转，浏览器输入http://www.baidu.com 会307 到https://www.baidu.com&lt;/p&gt;
&lt;p&gt;300，该请求有多种可能的响应，浏览器可以选择它们其中的一个。服务器没有任何标准可以遵循去代替用户来进行选择。&lt;br/&gt;304，告诉浏览器，所请求的内容距离上次访问并没有变化。 可以直接从浏览器缓存里获取该资源。&lt;br/&gt;后面两种不常用。&lt;/p&gt;
&lt;p&gt;使用比较多就是301 302 307 308&lt;/p&gt;
&lt;h3 id=&quot;循环重定向的问题&quot;&gt;循环重定向的问题&lt;/h3&gt;
&lt;p&gt;ERR_TOO_MANY_REDIRECTS&lt;br/&gt;这个报错挺常见的。如果访问A页面然后重定向访问B，然后B又让重定向访问A，这样就是循环重定向了。多次重定向也会报这个错。&lt;/p&gt;
&lt;p&gt;生产环境遇到过一次，有一次日志上发现有ERR_TOO_MANY_REDIRECTS的报错，但是在Nginx的配置上没有找到 3XX的跳转代码啊，那怎么循环跳转的。后来看到了这段配置&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    location / {
        try_files $uri $uri/ /index.html$is_args$args;
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;后来发现根目录下没有index.html，uri不存在，然后uri/目录也不存在，最后发起一个内部子请求到index.html.index.html不存在，又到location，反复重定向。最后报错 ERR_TOO_MANY_REDIRECTS。&lt;/p&gt;
</description>
<pubDate>Fri, 28 Jun 2019 23:36:00 +0000</pubDate>
<dc:creator>飞翔码农</dc:creator>
<og:description>今天下班的时候看到了一些重定向的基础知识，也算开了眼界。以前也经常使用301和302，但从来没有使用过和了解过其他的3XX的状态码，发现原来里面涉及的知识和解决的问题的还不少。 重定向的流程 浏览器首</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/feixiangmanon/p/11105239.html</dc:identifier>
</item>
<item>
<title>Exceptionless（二） - 使用进阶 - markjiang7m2</title>
<link>http://www.cnblogs.com/markjiang7m2/p/11100563.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/markjiang7m2/p/11100563.html</guid>
<description>&lt;blockquote readability=&quot;2.5238095238095&quot;&gt;
&lt;p&gt;作者：markjiang7m2&lt;br/&gt;原文地址：&lt;a href=&quot;https://www.cnblogs.com/markjiang7m2/p/11100563.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/markjiang7m2/p/11100563.html&lt;/a&gt;&lt;br/&gt;官网地址：&lt;a href=&quot;http://letyouknow.net&quot; class=&quot;uri&quot;&gt;http://letyouknow.net&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;https://www.cnblogs.com/markjiang7m2/p/11020140.html&quot;&gt;Exceptionless - .Net Core开源日志框架&lt;/a&gt;中就说到如何对Exceptionless进行本地化部署，不过我也跟大家说了，仅限于能用的阶段。那今天我就继续来探讨一下如何再用好。&lt;/p&gt;
&lt;h3 id=&quot;后台运行服务&quot;&gt;后台运行服务&lt;/h3&gt;
&lt;p&gt;上次我就是直接通过脚本&lt;code&gt;Start-ElasticSearch.ps1&lt;/code&gt;启动ElasticSearch和Kibana服务，但是大家也能看到，服务是运行起来了，同时还有两个命令窗口，如果一个不小心把窗口关闭了，服务也就关闭了，而且一旦服务器重启了，这两个服务也不会自动启动。&lt;br/&gt;我这里先暂时把Kibana扔一边去，来看看ElasticSearch服务。ElasticSearch是直接有脚本支持将ElasticSearch安装为Windows服务，在后台运行。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/Sevenm2/cnblogsPic/raw/master/Exceptionless/less_23_searchservicebat.png&quot; alt=&quot;less_23_searchservicebat&quot;/&gt;&lt;/p&gt;
&lt;p&gt;就是这个&lt;code&gt;elasticsearch-service.bat&lt;/code&gt;脚本，支持一下参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;install&lt;/strong&gt; 将Elasticsearch作为服务安装&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;remove&lt;/strong&gt; 删除已安装的Elasticsearch服务（并在启动时停止服务）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;start&lt;/strong&gt; 启动Elasticsearch服务（如果已安装）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;stop&lt;/strong&gt; 停止Elasticsearch服务（如果启动）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;manager&lt;/strong&gt; 启动一个GUI来管理已安装的服务&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;安装&lt;/strong&gt;&lt;br/&gt;命令行，进入到&lt;code&gt;elasticsearch-service.bat&lt;/code&gt;所在的目录，然后执行下面的脚本&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;elasticsearch-service.bat install&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/Sevenm2/cnblogsPic/raw/master/Exceptionless/less_25_servicestarted.png&quot; alt=&quot;less_25_servicestarted&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个时候我们可以直接在浏览器访问&lt;code&gt;9200&lt;/code&gt;端口看看服务是否正常&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/Sevenm2/cnblogsPic/raw/master/Exceptionless/less_26_serviceconfirm.png&quot; alt=&quot;less_26_serviceconfirm&quot;/&gt;&lt;/p&gt;
&lt;p&gt;继续使用上次部署好的Exceptionless&lt;br/&gt;（如何使用IIS部署Exceptionless Web服务，请看&lt;a href=&quot;https://www.cnblogs.com/markjiang7m2/p/11020140.html&quot;&gt;Exceptionless - .Net Core开源日志框架&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;因为我是直接用回之前ElasticSearch的节点，而且也没有清空数据，所以可以直接用之前注册的账号重新登录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/Sevenm2/cnblogsPic/raw/master/Exceptionless/less_27_weblogin.png&quot; alt=&quot;less_27_weblogin&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也是成功的，ElasticSearch服务已经运行在后台了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自动启动&lt;/strong&gt;&lt;br/&gt;通过ElasticSearch提供的GUI可以将服务设置为自动启动&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;elasticsearch-service.bat manager&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将&lt;code&gt;Startup Type&lt;/code&gt;选择为&lt;code&gt;Automatic&lt;/code&gt;，再点击OK保存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/Sevenm2/cnblogsPic/raw/master/Exceptionless/less_28_serviceauto.png&quot; alt=&quot;less_28_serviceauto&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样，即使服务器重启了，我们的ElasticSearch服务也会自动启动&lt;/p&gt;
&lt;p&gt;其实，有玩过Windows服务的朋友一定知道，上面的一些操作在Windows自带的服务管理器也能完成&lt;/p&gt;
&lt;p&gt;同时按下&quot;WIN+R&quot; 打开服务的命令运行窗口。在服务运行窗口中输入services.msc&lt;/p&gt;
&lt;p&gt;在列表中也可以找到ElasticSearch服务，双击打开属性窗口，跟刚刚的GUI操作就是一样的了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/Sevenm2/cnblogsPic/raw/master/Exceptionless/less_29_windowsservice.png&quot; alt=&quot;less_29_windowsservice&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;再看web.config&quot;&gt;再看Web.config&lt;/h3&gt;
&lt;p&gt;上次我只是改了Exceptionless的端口设置，其实这里面还包含很多配置信息&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;add name=&quot;RedisConnectionString&quot; connectionString=&quot;localhost:6379,abortConnect=false&quot; /&amp;gt;
&amp;lt;add name=&quot;ElasticSearchConnectionString&quot; connectionString=&quot;http://localhost:9200&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;官方是建议大家安装和配置Redis，这样就可以同时运行多个实例，并且重启不会丢失状态，强烈建议在Linux上运行Redis 3.0+版本，&lt;code&gt;RedisConnectionString&lt;/code&gt;就是Redis的连接串&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ElasticSearchConnectionString&lt;/code&gt;是必须的，指向ElasticSearch服务，如果有多个节点，则使用&lt;code&gt;,&lt;/code&gt;隔开&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;!-- Exceptionless Web 基础Url --&amp;gt;
&amp;lt;add key=&quot;BaseURL&quot; value=&quot;http://localhost:50001/#&quot; /&amp;gt;
&amp;lt;!-- 是否启用ssl --&amp;gt;
&amp;lt;add key=&quot;EnableSSL&quot; value=&quot;false&quot; /&amp;gt;
&amp;lt;!-- 
Dev: Use this mode when debugging. (Outbound emails will not be sent)
QA: Use this mode when deployed to staging. (Outbound emails restricted)
Production: Use this mode when deployed to production.
--&amp;gt;
&amp;lt;add key=&quot;WebsiteMode&quot; value=&quot;Production&quot; /&amp;gt;
&amp;lt;!-- Controls whether users can signup. --&amp;gt;
&amp;lt;add key=&quot;EnableAccountCreation&quot; value=&quot;true&quot; /&amp;gt;
&amp;lt;!-- Controls whether daily summary emails are sent --&amp;gt;
&amp;lt;add key=&quot;EnableDailySummary&quot; value=&quot;true&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网站模式WebsiteMode主要是限制邮件发送，默认值是Dev，不发送邮件，所以我这里设置为Production&lt;/p&gt;
&lt;p&gt;邮件发送配置，记得跟上面的WebsiteMode一起配置&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;&amp;lt;add key=&quot;SmtpHost&quot; value=&quot;smtp.qq.com&quot; /&amp;gt;
&amp;lt;add key=&quot;SmtpPort&quot; value=&quot;25&quot; /&amp;gt;
&amp;lt;add key=&quot;SmtpEncryption&quot; value=&quot;SSL&quot; /&amp;gt;
&amp;lt;add key=&quot;SmtpUser&quot; value=&quot;xxx@qq.com&quot; /&amp;gt;
&amp;lt;add key=&quot;SmtpPassword&quot; value=&quot;xxx&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;我在案例中使用的是自己的qq邮箱。我在qq邮箱中已经开启了SMTP服务，并且也通过一个控制台应用程序测试可以发送邮件。&lt;br/&gt;但是在Exceptionless这里一样的设置就是不行，在Web中点击发送邮件，log记录错误如下：&lt;br/&gt;&lt;strong&gt;ERROR MailMessageJob Job run &quot;MailMessageJob&quot; failed: 由于意外的数据包格式，握手失败。 System.IO.IOException: 由于意外的数据包格式，握手失败。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;清除Url&lt;/strong&gt;&lt;br/&gt;我们现在使用的Url都会带有&lt;code&gt;#!&lt;/code&gt;，例如&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;http://localhost:50001/#!/type/error/dashboard&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以按照下面步骤清除字符&lt;code&gt;#!&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先保证你的IIS是否已经安装了重写模块，可通过双击IIS中的&lt;code&gt;模块&lt;/code&gt;查看是否包含了&lt;code&gt;RewriteModule&lt;/code&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;更新&lt;code&gt;Web.config&lt;/code&gt;文件
&lt;ul&gt;&lt;li&gt;释放出在&lt;code&gt;system.webServer&lt;/code&gt;中的&lt;code&gt;rewrite&lt;/code&gt;节点&lt;/li&gt;
&lt;li&gt;删除&lt;code&gt;BaseURL&lt;/code&gt;值中的&lt;code&gt;/#&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;注释了在&lt;code&gt;system.webServer\modules&lt;/code&gt;中的&lt;code&gt;&amp;lt;remove name=&quot;RewriteModule&quot; /&amp;gt;&lt;/code&gt;标签&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;修改&lt;code&gt;app.config.77fc9ddd679d37dc.js&lt;/code&gt;文件中&lt;code&gt;USE_HTML5_MODE&lt;/code&gt;的值为&lt;code&gt;true&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;进程外运行作业&lt;/strong&gt;&lt;br/&gt;默认情况下，所有作业都在当前的Web进程中运行。如果发现事件处理开始变慢的时候，可以启动并扩展多个作业实例。通过在进程外运行作业，可以确保所有作业是否正常运行。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先是要配置安装Redis，这样可以保证Exceptionless与作业之间能够进行通信&lt;/li&gt;
&lt;li&gt;更新&lt;code&gt;Web.config&lt;/code&gt;中的&lt;code&gt;RunJobsInProcess&lt;/code&gt;值为&lt;code&gt;false&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;更新作业的配置，有两种方法可选：
&lt;ul&gt;&lt;li&gt;使用环境变量进行配置Exceptionless。新增环境变量Exceptionless_{SETTING NAME} (例如: Exceptionless_BaseURL, Exceptionless_ElasticSearchConnectionString)。这是官方推荐的方法，因为它更简单，而且当部署到azure时非常好用&lt;/li&gt;
&lt;li&gt;打开App_Data\jobs文件夹，然后按照在根目录中&lt;code&gt;Web.config&lt;/code&gt;的配置，再重新配置每个作业的&lt;code&gt;xxx.exe.config&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;在每个作业文件夹中都有一个&lt;code&gt;run.bat&lt;/code&gt;文件，双击它就会运行这个作业。当然，也可以将这些作业全部设置为Windows服务在后台运行&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;更多设置&lt;/strong&gt;&lt;br/&gt;除了上面提到的设置，Exceptionless还支持很多自定义配置，下面是全部的设置列表，大家可根据自己的需要进行定制&lt;br/&gt;列表按照这个格式进行排列：设置项 (数据类型，默认值)&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;EnableSSL (bool)
BaseURL (string)
InternalProjectId (string, &quot;54b56e480ef9605a88a13153&quot;)
WebsiteMode (WebsiteMode, &quot;Dev&quot;)
AppScope (string, String.Empty)
TestEmailAddress (string)
AllowedOutboundAddresses (List&amp;lt;string&amp;gt;, &quot;exceptionless.io&quot;)
RunJobsInProcess (bool, true)
BotThrottleLimit (int, 25)
ApiThrottleLimit (int, Int32.MaxValue)
EventSubmissionDisabled (bool)
MaximumEventPostSize (long, 1000000)
MaximumRetentionDays (int, 180)
EnableDailySummary (bool)
MetricsServerName (string, &quot;127.0.0.1&quot;)
MetricsServerPort (int, 8125)
EnableMetricsReporting (bool)
RedisConnectionString (string)
EnableRedis (bool)
DisableSnapshotJobs (bool)
DisableIndexConfiguration (bool)
ElasticSearchConnectionString (string)
ElasticSearchNumberOfShards (int, 1)
ElasticSearchNumberOfReplicas (int)
EnableElasticsearchTracing (bool)
LdapConnectionString (string)
EnableActiveDirectoryAuth (bool)
EnableSignalR (bool, true)
Version (string)
EnableIntercom (bool)
IntercomAppSecret (string)
EnableAccountCreation (bool, true)
MicrosoftAppId (string)
MicrosoftAppSecret (string)
FacebookAppId (string)
FacebookAppSecret (string)
GitHubAppId (string)
GitHubAppSecret (string)
GoogleAppId (string)
GoogleAppSecret (string)
GoogleGeocodingApiKey (string)
EnableBilling (bool)
StripeApiKey (string)
StorageFolder (string)
AzureStorageConnectionString (string)
EnableAzureStorage (bool)
BulkBatchSize (int, 1000)
SmtpHost (string)
SmtpPort (int, 587)
SmtpEnableSsl (bool, true)
SmtpUser (string)
SmtpPassword (string)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;更多日志类型&quot;&gt;更多日志类型&lt;/h3&gt;
&lt;p&gt;Exceptionless除了支持记录Exception，也可以记录LogMessage、Broken Links 、Feature Usages&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;LogMessage&lt;/strong&gt;&lt;br/&gt;LogMessage支持多种级别的日志信息&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Other&lt;/li&gt;
&lt;li&gt;Trace&lt;/li&gt;
&lt;li&gt;Debug&lt;/li&gt;
&lt;li&gt;Info&lt;/li&gt;
&lt;li&gt;Warn&lt;/li&gt;
&lt;li&gt;Error&lt;/li&gt;
&lt;li&gt;Fatal&lt;/li&gt;
&lt;li&gt;Off&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;用法也很简单，直接在你想要记录日志的地方直接加一句&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;ExceptionlessClient.Default.CreateLog(&quot;日志信息&quot;, LogLevel.Debug).AddTags(&quot;tag1&quot;, &quot;tag2&quot;).Submit();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以我们在应用的过程中，可以添加一个统一的接口&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public interface ILogger
{
    void Debug(string message, params string[] tags);
    void Error(string message, params string[] tags);
    void Fatal(string message, params string[] tags);
    void Info(string message, params string[] tags);
    void Off(string message, params string[] tags);
    void Other(string message, params string[] tags);
    void Trace(string message, params string[] tags);
    void Warn(string message, params string[] tags);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;using Exceptionless;
using Exceptionless.Logging;&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ExceptionlessLogger : ILogger
{
    public void Debug(string message, params string[] tags)
    {
        ExceptionlessClient.Default.CreateLog(message, LogLevel.Debug).AddTags(tags).Submit();
    }

    public void Error(string message, params string[] tags)
    {
        ExceptionlessClient.Default.CreateLog(message, LogLevel.Error).AddTags(tags).Submit();
    }

    public void Fatal(string message, params string[] tags)
    {
        ExceptionlessClient.Default.CreateLog(message, LogLevel.Fatal).AddTags(tags).Submit();
    }

    public void Info(string message, params string[] tags)
    {
        ExceptionlessClient.Default.CreateLog(message, LogLevel.Info).AddTags(tags).Submit();
    }

    public void Off(string message, params string[] tags)
    {
        ExceptionlessClient.Default.CreateLog(message, LogLevel.Off).AddTags(tags).Submit();
    }

    public void Other(string message, params string[] tags)
    {
        ExceptionlessClient.Default.CreateLog(message, LogLevel.Other).AddTags(tags).Submit();
    }

    public void Trace(string message, params string[] tags)
    {
        ExceptionlessClient.Default.CreateLog(message, LogLevel.Trace).AddTags(tags).Submit();
    }

    public void Warn(string message, params string[] tags)
    {
        ExceptionlessClient.Default.CreateLog(message, LogLevel.Warn).AddTags(tags).Submit();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后在&lt;code&gt;Startup.cs&lt;/code&gt;的&lt;code&gt;ConfigureServices&lt;/code&gt;方法注入&lt;code&gt;ExceptionlessLogger&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void ConfigureServices(IServiceCollection services)
{
    services.AddSingleton&amp;lt;ILogger, ExceptionlessLogger&amp;gt;();
    services.AddMvc().SetCompatibilityVersion(CompatibilityVersion.Version_2_2);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就可以更方便地使用了&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public class ValuesController : ControllerBase
{
    public ILogger _logger;
    public ValuesController(ILogger logger)
    {
        _logger = logger;
    }
    
    // GET api/values/{id}
    [HttpGet(&quot;{id}&quot;)]
    public ActionResult&amp;lt;string&amp;gt; Get(int id)
    {
        try
        {
            _logger.Info(&quot;Test msg&quot;, &quot;tag1&quot;, &quot;tag2&quot;);
            throw new Exception();
        }
        catch (Exception ex)
        {
            ex.ToExceptionless().AddTags(&quot;tag1&quot;, &quot;tag2&quot;).Submit();
        }
        return $&quot;value {id}&quot;;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Broken Links&lt;/strong&gt;&lt;br/&gt;记录404找不到请求的日志&lt;/p&gt;
&lt;p&gt;像我这里没有添加favicon.ico图标，使用Chrome浏览器会自动请求这个资源，因此，Exceptionless就记录了这样的日志&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/Sevenm2/cnblogsPic/raw/master/Exceptionless/less_30_brokenlinks.png&quot; alt=&quot;less_30_brokenlinks&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以直接在Api服务中调用如下面语句添加这种类型的日志&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;ExceptionlessClient.Default.CreateNotFound(&quot;404 not found&quot;).SetType(&quot;404&quot;).SetSource($&quot;api/values/{id}&quot;);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Feature Usages&lt;/strong&gt;&lt;br/&gt;类似的也可以添加Feature Usages日志&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;ExceptionlessClient.Default.CreateFeatureUsage(&quot;Feature 1&quot;).SetSource($&quot;api/values/{id}&quot;).SetType(&quot;FeatureType&quot;).Submit();&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;事件&quot;&gt;事件&lt;/h3&gt;
&lt;p&gt;上面所说的所有日志类型，最终都会通过事件进行记录，Exceptionless也支持我们直接记录一个事件&lt;/p&gt;
&lt;p&gt;例子如下：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;var dataDic = new Exceptionless.Models.DataDictionary();
dataDic.Add(&quot;key&quot;, &quot;value&quot;);
ExceptionlessClient.Default.SubmitEvent(new Exceptionless.Models.Event
{
    Count = 1,
    Date = DateTime.Now,
    Data = dataDic,
    Geo = &quot;geo&quot;,
    Message = &quot;message&quot;,
    ReferenceId = &quot;referencelId&quot;,
    Source = &quot;source&quot;,
    Tags = new Exceptionless.Models.TagSet() { &quot;tags&quot; },
    Type = &quot;type&quot;
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Exceptionless同时也支持我们捕获事件提交过程和事件提交后的事件，这样我们就可以在过程中做一些操作，例如可以忽略&lt;code&gt;404&lt;/code&gt;的请求，或者针对某些特殊日志返回某些信息&lt;/p&gt;
&lt;p&gt;为了代码的整洁，可以将Exceptionless的配置单独放到一个cs文件中&lt;/p&gt;
&lt;p&gt;添加一个&lt;code&gt;ExceptionlessBuilderExtensions&lt;/code&gt;类&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public static class ExceptionlessBuilderExtensions
{
    public static IApplicationBuilder UseExceptionless(this IApplicationBuilder app, IConfiguration configuration)
    {
        ExceptionlessClient.Default.Configuration.ApiKey = configuration[&quot;Exceptionless:ApiKey&quot;];
        ExceptionlessClient.Default.Configuration.ServerUrl = configuration[&quot;Exceptionless:ServerUrl&quot;];
        ExceptionlessClient.Default.SubmittingEvent += OnSubmittingEvent;
        app.UseExceptionless();

        return app;
    }

    private static void OnSubmittingEvent(object sender, EventSubmittingEventArgs e)
    {
        if (e.Event.IsNotFound())
        {
            e.Cancel = true;//取消事件提交
            return;
        }

        // 修改日志信息
        if (e.Event.Source == &quot;sourceA&quot;)
        {
            e.Event.AddTags(&quot;systemLog&quot;);
        }

        //TODO:
    }

    private static void OnSubmittedEvent(object sender, EventSubmittedEventArgs e)
    {
        // 做点什么东西
        if (e.Event.Source == &quot;sourceA&quot;)
        {
            //TODO:
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后修改&lt;code&gt;Startup.cs&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public void Configure(IApplicationBuilder app, IHostingEnvironment env)
{
    ……

    app.UseExceptionless(Configuration);

    ……
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;exceptionless-日志查询&quot;&gt;Exceptionless 日志查询&lt;/h3&gt;
&lt;p&gt;Exceptionless Web站点已经帮我们做好项目、时间、日志类型的分类，大家可以很直观地进行操作查询。&lt;br/&gt;我这里要关注的是&lt;code&gt;Filter&lt;/code&gt;查询&lt;/p&gt;
&lt;p&gt;前面记录日志的时候，有添加了&lt;code&gt;tag&lt;/code&gt;、&lt;code&gt;Type&lt;/code&gt;等信息，这时候就可以使用Filter进行查询了。&lt;br/&gt;语法：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[FilterType]:[value1] {or} {[value2]}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;or&lt;/strong&gt;是用于查询多个该类型值的日志时使用&lt;/p&gt;
&lt;p&gt;例如：tag:tag1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/Sevenm2/cnblogsPic/raw/master/Exceptionless/less_32_filtertag.png&quot; alt=&quot;less_32_filtertag&quot;/&gt;&lt;/p&gt;
&lt;p&gt;列几个可能比较常用的&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;source:&quot;my log source&quot; or &quot;my log source&quot;&lt;/li&gt;
&lt;li&gt;type:error&lt;/li&gt;
&lt;li&gt;level:Error&lt;/li&gt;
&lt;li&gt;ip:127.0.0.1&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果是要同时输入多种类型的条件：&lt;/p&gt;
&lt;pre class=&quot;shell&quot;&gt;
&lt;code&gt;[FilterType]:[value] {OR|AND} {[FilterType]:[value]}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如：tag:tag1 OR ip:127.0.0.1&lt;/p&gt;
&lt;p&gt;更多的语法可以看官网说明&lt;br/&gt;&lt;a href=&quot;https://github.com/exceptionless/Exceptionless/wiki/Filtering-Searching&quot; target=&quot;_blank&quot;&gt;https://github.com/exceptionless/Exceptionless/wiki/Filtering-Searching&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;在这篇文章中，我基本就是顺着Exceptionless Self Hosting的介绍做了一遍，不过有一些东西因为没有实际环境，所以也没有去做，然后我这个也只是一个Demo，暂时也没有做相关的压力测试，所以也不知道这货真正在生产环境大量用起来的时候会有一些什么表现，会不会踩到什么坑。欢迎大家在留言区跟我一起交流。今天就先跟大家介绍到这里，希望大家能持续关注我们。&lt;/p&gt;
&lt;blockquote readability=&quot;3.3703703703704&quot;&gt;
&lt;p&gt;参考文献&lt;br/&gt;本文在编写过程中引用或参考了以下文章中的部分内容，如有侵权，请联系修改或删除。&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/edisonchou/p/exceptionless_deployment_on_production_env_introduction.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/edisonchou/p/exceptionless_deployment_on_production_env_introduction.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/ants/p/8580890.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/ants/p/8580890.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 28 Jun 2019 23:31:00 +0000</pubDate>
<dc:creator>markjiang7m2</dc:creator>
<og:description>在上一篇文章Exceptionless - .Net Core开源日志框架中就说到如何对Exceptionless进行本地化部署，不过我也跟大家说了，仅限于能用的阶段。那今天我就继续来探讨一下如何再用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/markjiang7m2/p/11100563.html</dc:identifier>
</item>
<item>
<title>ChannelPipeline----贯穿io事件处理的大动脉 - _朱葛</title>
<link>http://www.cnblogs.com/zhuge134/p/11105485.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuge134/p/11105485.html</guid>
<description>&lt;p&gt;上一篇，我们分析了NioEventLoop及其相关类的主干逻辑代码，我们知道netty采用线程封闭的方式来避免多线程之间的资源竞争，最大限度地减少并发问题，减少锁的使用，因而能够有效减低线程切换的开销，减少cpu的使用时间。此外，我们还简单分析了netty对于线程组的封装EventLoopGroup，目前一般采用roundRobin的方式在多个线程上均匀地分配channel。通过前面几篇文章的分析，我们已经对channel的初始化，注册到EventLoop上，SingleThreadEventLoop的线程启动过程以及线程中运行的代码逻辑有了一些了解，此外我们也分析了用于处理基于TCP协议的io事件的NioEventLoop类的具体的循环逻辑，通过对代码的详细分析，我们了解了对于connect,write,read,accept事件的不同处理逻辑，但是对于write和read事件的处理逻辑我们并没有分析的很详细，因为这些事件的处理涉及到netty中另一个很重要的模块，ChannelPipeline以及一系列相关的类如Channel, ChannelHandler, ChannelhandlerContext等的理解，netty中的事件处理采用了经典的责任链(responsbility chain)的的设计模式，这种设计模式使得netty的io事件处理框架易于扩展，并且为业务逻辑提供了一个很好的抽象模型，大大降低了netty的使用难度，使得io事件的处理变得更符合思维习惯。&lt;br/&gt;好了，废话了那么多，其实主要是想把前面分析的几篇的文章做一个小结和回顾，然后引出本篇的主题--netty的io事件处理链模式。&lt;br/&gt;因为netty的代码结构相对来说还是很规整，它的模块之间的边界划分比较明确，EventLoop作为io事件的“发源地”，与其交互的对象是Channel类，而ChannelPipeline，ChannelhandlerContext, ChannelHandler等几个类则是与Channel交互，他们并不直接与EventLoop交互。&lt;/p&gt;
&lt;h3 id=&quot;channelpipeline的结构图&quot;&gt;ChannelPipeline的结构图&lt;/h3&gt;
&lt;p&gt;首先每一个Channel在初始化的时候就会创建一个ChannelPipeline，这点我们在前面分析NioSocketChannel的初始化时也分析到了。目前ChannelPipeline的实现只有DefaultChannelPipeline一种，所以我们也以DefaultChannelPipeline来分析。DefaultChannelPipeline内部有一个双向链表结构，这个链表的每个节点都是一个AbstractChannelHandlerContext类型的节点，DefaultChannelPipeline刚初始化时就会创建两个初始节点，分别是HeadContext和TailContext，这两个节点也并不完全是标记节点，他们都有各自实际的作用，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1655487/201906/1655487-20190629042755411-31891771.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;HeadContext，实现了bind,connect,disconnect,close，write，flush等等几个方法，基本都是通过直接调用unsafe的相关方法实现的。而对于其他的方法基本都是通过调用AbstractChannelHandlerContext的fire方法将事件传给下一个节点。&lt;/li&gt;
&lt;li&gt;TailContext, 主要用于处理写数据几乎没有实现任何逻辑，它的功能几乎全部继承自AbstractChannelHandlerContext，而AbstractChannelHandlerContext对于大部分事件处理的实现都是简单地将事件向下一个节点传递。注意，这里下一个节点不一定是前一个还是后一个，要根据具体事件类型或者具体的操作而定，对于ChannelOutboundInvoker接口中的方法都是从尾节点向首节点传递事件，而对于ChannelInboundInvoker接口中的方法都是从首节点往尾节点传递。我们可以形象地理解为，首节点是最靠近socket的，而尾节点是最原理socket的，所以有数据进来时，产生的读事件最先从首节点开始向后传递，当有写数据的动作时，则会从尾节点向头结点传递。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面，我们以两个最重要的事件读事件和写事件，来分析netty的这种链式处理结构到底是怎么运转的。&lt;/p&gt;
&lt;h3 id=&quot;读事件&quot;&gt;读事件&lt;/h3&gt;
&lt;p&gt;首先，我们需要找到一个产生读事件并调用相关方法使得读事件开始传递的例子，很自然我们应该想到在EventLoop中会产生读事件。&lt;br/&gt;如下，就是NioEventLoop中对于读事件的处理，通过调用NioUnsafe.read方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;       // 处理read和accept事件
        if ((readyOps &amp;amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {
            unsafe.read();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们继续看NioByteUnsafe.read方法，这个方法我们之前在分析NioEventLoop事件处理逻辑时提到过，这个方法首先会通过缓冲分配器分配一个缓冲，然后从channel(也就是socket)中将数据读到缓冲中，每读一个缓冲，就会触发一个读事件，我们看具体的触发读事件的调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;            do {
                // 分配一个缓冲
                byteBuf = allocHandle.allocate(allocator);
                // 将通道的数据读取到缓冲中
                allocHandle.lastBytesRead(doReadBytes(byteBuf));
                // 如果没有读取到数据，说明通道中没有待读取的数据了，
                if (allocHandle.lastBytesRead() &amp;lt;= 0) {
                    // nothing was read. release the buffer.
                    // 因为没读取到数据，所以应该释放缓冲
                    byteBuf.release();
                    byteBuf = null;
                    // 如果读取到的数据量是负数，说明通道已经关闭了
                    close = allocHandle.lastBytesRead() &amp;lt; 0;
                    if (close) {
                        // There is nothing left to read as we received an EOF.
                        readPending = false;
                    }
                    break;
                }

                // 更新Handle内部的簿记量
                allocHandle.incMessagesRead(1);
                readPending = false;
                // 向channel的处理器流水线中触发一个事件，
                // 让取到的数据能够被流水线上的各个ChannelHandler处理
                pipeline.fireChannelRead(byteBuf);
                byteBuf = null;
                // 这里根据如下条件判断是否继续读：
                // 上一次读取到的数据量大于0，并且读取到的数据量等于分配的缓冲的最大容量，
                // 此时说明通道中还有待读取的数据
            } while (allocHandle.continueReading());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了代码逻辑的完整性，我这里把整个循环的代码都贴上来，其实我们要关注的仅仅是pipeline.fireChannelRead(byteBuf)这一句，好了，现在我们找到ChannelPipeline触发读事件的入口方法，我们顺着这个方法，顺藤摸瓜就能一步步理清事件的传递过程了。&lt;/p&gt;
&lt;h4 id=&quot;defaultchannelpipeline.firechannelread&quot;&gt;DefaultChannelPipeline.fireChannelRead&lt;/h4&gt;
&lt;p&gt;如果我们看一下ChannelPipeline接口，这里面的方法名都是以fire开头的，实际就是想表达这些方法都是触发了一个事件，然后这个事件就会在内部的处理器链表中传递。&lt;br/&gt;我们看到这里调用了一个静态方法，并且以头结点为参数，也就是说事件传递是从头结点开始的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final ChannelPipeline fireChannelRead(Object msg) {
    AbstractChannelHandlerContext.invokeChannelRead(head, msg);
    return this;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;abstractchannelhandlercontext.invokechannelreadfinal-abstractchannelhandlercontext-next-object-msg&quot;&gt;AbstractChannelHandlerContext.invokeChannelRead(final AbstractChannelHandlerContext next, Object msg)&lt;/h4&gt;
&lt;p&gt;可以看到，这个方法中通过调用invokeChannelRead执行处理逻辑&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) {
    // 维护引用计数，主要是为了侦测资源泄漏问题
    final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next);
    EventExecutor executor = next.executor();
    if (executor.inEventLoop()) {
        // 调用invokeChannelRead执行处理逻辑
        next.invokeChannelRead(m);
    } else {
        executor.execute(new Runnable() {
            @Override
            public void run() {
                next.invokeChannelRead(m);
            }
        });
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;abstractchannelhandlercontext.invokechannelreadobject-msg&quot;&gt;AbstractChannelHandlerContext.invokeChannelRead(Object msg)&lt;/h4&gt;
&lt;p&gt;这里可以看到，AbstractChannelHandlerContext通过自己内部的handler对象来实现读数据的逻辑。这也体现了ChannelHandlerContext在整个结构中的作用，其实它是起到了在ChannelPipeline和handler之间的一个中间人的角色，那我们要问：既然ChannelHandlerContext不起什么实质性的作用，那为什么要多这一个中间层呢，这样设计的好处是什么？我认为这样设计其实是为了尽最大可能对使用者屏蔽netty框架的细节，试想如果没有这个context的中间角色，使用者必然要详细地了解ChannelPipeline，并且还要考虑事件传递是找下一个节点，还要考虑下一个节点应该沿着链表的正序找还是沿着链表 倒叙找，所以这里ChannelHandlerContext的角色我认为最大的作用就是封装了链表的逻辑，并且封装了不同类型操作的传播方式。当然也起到了一些引用传递的作用，如channel引用可以简介地传递给用户。&lt;br/&gt;好了，回到正题，从前面的方法中我们知道读事件最先是从HeadContext节点开始的，所以我们看一下HeadContext的channelRead方法（因为HeadContext也实现了handler方法，并且返回的就是自身）&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void invokeChannelRead(Object msg) {
    // 如果这个handler已经准备就绪，那么就执行处理逻辑
    // 否则将事件传递给下一个处理器节点
    if (invokeHandler()) {
        try {
            // 调用内部的handler的channelRead方法
            ((ChannelInboundHandler) handler()).channelRead(this, msg);
        } catch (Throwable t) {
            notifyHandlerException(t);
        }
    } else {
        fireChannelRead(msg);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;headcontext.channelread&quot;&gt;HeadContext.channelRead&lt;/h4&gt;
&lt;p&gt;这里的调用也是一个重要的注意点，这里调用了ChannelHandlerContext.fireChannelRead方法，这正是事件传播的方法，fire开头的方法的作用就是将当前的操作（或者叫事件）从当前处理节点传递给下一个处理节点。这样就实现了事件在链表中的传播。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   public void channelRead(ChannelHandlerContext ctx, Object msg) {
        ctx.fireChannelRead(msg);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;小结&quot;&gt;小结&lt;/h3&gt;
&lt;p&gt;到这里我们先暂停一下，总结一下读事件（或者是读操作）在ChannelPipeline内部的传播机制，其实很简单，&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先外部调用者会通过unsafe最终调用ChannelPipeline.fireChannelRead方法，并将从channel中读取到的数据作为参数传进来&lt;/li&gt;
&lt;li&gt;以头结点作为参数调用静态方法AbstractChannelHandlerContext.fireChannelRead&lt;/li&gt;
&lt;li&gt;然后头结点HeadContext开始调用节点的invokeChannelRead方法（即ChannelHandlerContext的invokeChannelRead方法），&lt;/li&gt;
&lt;li&gt;invokeChannelRead方法会调用当前节点的handler对象的channelRead方法执行处理逻辑&lt;/li&gt;
&lt;li&gt;handler对象的channelRead方法中可以调用AbstractChannelHandlerContext.fireChannelRead将这个事件传递到下一个节点&lt;/li&gt;
&lt;li&gt;这样事件就能够沿着链条不断传递下去，当然如果业务处理需要，完全可以在某个节点将事件的传递终止，也就是在这个节点不调用ChannelHandlerContext.fireChannelRead&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;写事件&quot;&gt;写事件&lt;/h3&gt;
&lt;p&gt;此外，我们分析一下写数据的操作是怎么传播的。分析写数据操作的入口并不想读事件那么好找，在netty中用户的代码中写数据最终都是被放到内部的缓冲中，当NioEventLoop中监听到底层的socket可以写数据的事件时，实际上是吧当前缓冲中的数据发送到socket中，而对于用户来讲，是接触不到socketChannel这一层的。&lt;br/&gt;根据前面的分析，我们知道，用户一般都会与Channel,ChannelHandler, ChannelhandlerContext这几种类打交道，写数据的操作也是通过Channel的write和writeAndFlush触发的，这两个方法区别在于writeAndFlush在写完数据后还会触发一次刷写操作，将缓冲中的数据实际写入到socket中。&lt;/p&gt;
&lt;h4 id=&quot;abstractchannel.write&quot;&gt;AbstractChannel.write&lt;/h4&gt;
&lt;p&gt;仍然是将操作交给内部的ChannelPipeline,触发流水线操作&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public ChannelFuture write(Object msg, ChannelPromise promise) {
    return pipeline.write(msg, promise);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;defaultchannelpipeline.write&quot;&gt;DefaultChannelPipeline.write&lt;/h4&gt;
&lt;p&gt;这里可以很清楚地看出来，写数据的操作从为节点开始，但是TailContext并未重写write方法，所以最终调用的还是AbstractChannelHandlerContext中的相应方法。&lt;br/&gt;我们沿着调用链往下走，发现write系列的方法其实是将写操作传递给了下一个ChannelOutboundHandler类型的处理节点，注意这里是从尾节点向前找，遍历链表的顺序和读数据正好相反。&lt;br/&gt;真正调用&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final ChannelFuture write(Object msg, ChannelPromise promise) {
    return tail.write(msg, promise);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;abstractchannelhandlercontext.write&quot;&gt;AbstractChannelHandlerContext.write&lt;/h4&gt;
&lt;p&gt;从这个方法可以明显地看出来，write方法将写操作交给了下一个ChannelOutboundHandler类型的处理器节点。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void write(Object msg, boolean flush, ChannelPromise promise) {
    ObjectUtil.checkNotNull(msg, &quot;msg&quot;);
    try {
        if (isNotValidPromise(promise, true)) {
            ReferenceCountUtil.release(msg);
            // cancelled
            return;
        }
    } catch (RuntimeException e) {
        ReferenceCountUtil.release(msg);
        throw e;
    }

    // 沿着链表向前遍历，找到下一个ChannelOutboundHandler类型的处理器节点
    final AbstractChannelHandlerContext next = findContextOutbound(flush ?
            (MASK_WRITE | MASK_FLUSH) : MASK_WRITE);
    final Object m = pipeline.touch(msg, next);
    EventExecutor executor = next.executor();
    if (executor.inEventLoop()) {
        if (flush) {
            // 调用AbstractChannelHandlerContext.invokeWriteAndFlush方法执行真正的写入逻辑
            next.invokeWriteAndFlush(m, promise);
        } else {
            next.invokeWrite(m, promise);
        }
    } else {
        // 如果当前是异步地写入数据，那么需要将写入的逻辑封装成一个任务添加到EventLoop的任务对队列中
        final AbstractWriteTask task;
        if (flush) {
            task = WriteAndFlushTask.newInstance(next, m, promise);
        }  else {
            task = WriteTask.newInstance(next, m, promise);
        }
        if (!safeExecute(executor, task, promise, m)) {
            // We failed to submit the AbstractWriteTask. We need to cancel it so we decrement the pending bytes
            // and put it back in the Recycler for re-use later.
            //
            // See https://github.com/netty/netty/issues/8343.
            task.cancel();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;abstractchannelhandlercontext.invokewrite&quot;&gt;AbstractChannelHandlerContext.invokeWrite&lt;/h4&gt;
&lt;p&gt;我们接着看invokeWrite0方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void invokeWrite(Object msg, ChannelPromise promise) {
    if (invokeHandler()) {
        invokeWrite0(msg, promise);
    } else {
        write(msg, promise);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;abstractchannelhandlercontext.invokewrite0&quot;&gt;AbstractChannelHandlerContext.invokeWrite0&lt;/h4&gt;
&lt;p&gt;这里可以清楚地看到，最终是调用了handler的write方法执行真正的写入逻辑，这个逻辑实际上就是有用户自己实现的。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;private void invokeWrite0(Object msg, ChannelPromise promise) {
    try {
        // 调用当前节点的handler的write方法执行真正的写入逻辑
        ((ChannelOutboundHandler) handler()).write(this, msg, promise);
    } catch (Throwable t) {
        notifyOutboundHandlerException(t, promise);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里，我们已经知道写入的操作是怎么从尾节点开始，也知道了通过调用当前处理节点的AbstractChannelHandlerContext.write方法可以将写入操作传递给下一个节点，那么数据经过层层传递后，最终是怎么写到socket中的呢？回答这个问题，我们需要看一下HeadContext的代码！我们知道写入的操作是从尾节点向前传递的，那么头节点HeadContext就是传递的最后一个节点。&lt;/p&gt;
&lt;h4 id=&quot;headcontext.write&quot;&gt;HeadContext.write&lt;/h4&gt;
&lt;p&gt;最终调用了unsafe.write方法。&lt;br/&gt;在AbstractChannel.AbstractUnsafe的实现中，write方法将经过前面一系列处理器处理过的数据存放到内部的缓冲中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) {
        unsafe.write(msg, promise);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;刷写操作的传递&quot;&gt;刷写操作的传递&lt;/h3&gt;
&lt;p&gt;前面我们提到，写数据的操作除了write还有writeAndFlush，这个操作除了写数据，还会紧接着执行一次刷写操作。刷写操作也会从尾节点向前传递，最终传递到头结点HeadContext，其中的flush方法如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;    public void flush(ChannelHandlerContext ctx) {
        unsafe.flush();
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在AbstractChannel.AbstractUnsafe的实现中，flush操作会将前面存储在内部缓冲区中的数据吸入到socket中，从而完成刷写。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本节，我们主要通过io事件处理中最重要的两种事件，即读事件和写事件为切入点 详细分析了netty中对于这两种事件的处理方法。其中写数据的事件与我们之前在jdk nio中建立起的印象差别还是不大的，都是对从socket中读取的数据进行处理，但是写事件跟jdk nio中的概念就有较大差别了，因为netty对数据的写入做了很大的改变和优化，用户代码中通过channel调用相关的写数据的方法，这个方法会触发处理器链条上的所有相关的处理器对待写入的数据进行加工，最后在头结点HeadCOntext中被写入channel内部的缓冲区，通过flush操作将缓冲的数据写入socket中。&lt;br/&gt;这里面最重要的也是最值得我们学习的一点就是责任链模式，显然，这又是一次对责任链模式的成功运用，是的框架的扩展性大大增强，而且面向用户的接口更加容易理解，简单易用，向用户屏蔽了大部分框架实现细节。&lt;/p&gt;
</description>
<pubDate>Fri, 28 Jun 2019 20:29:00 +0000</pubDate>
<dc:creator>_朱葛</dc:creator>
<og:description>ChannelPipeline贯穿io事件处理的大动脉 上一篇，我们分析了NioEventLoop及其相关类的主干逻辑代码，我们知道netty采用线程封闭的方式来避免多线程之间的资源竞争，最大限度地减</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhuge134/p/11105485.html</dc:identifier>
</item>
<item>
<title>【JavaScript】彻底明白this在函数中的指向 - 彭胜光</title>
<link>http://www.cnblogs.com/pengshengguang/p/11105323.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pengshengguang/p/11105323.html</guid>
<description>&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;一、this，其实可以类比成人&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　说到this的话，我们在js中主要研究的都是函数中的this，在javascript中，this代表当前行为的执行主体，而context代表的是当前行为执行的的环境（区域）。&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　例如男神在北理珠吃饭，这句话分别代表的含义如下&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　男神    --&amp;gt;&amp;gt; 主体（this）&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　吃饭    --&amp;gt;&amp;gt; 函数（function）&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　北理珠 --&amp;gt;&amp;gt; 环境（context）&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　 --&amp;gt;&amp;gt;说明：吃饭是函数，男神是函数的主体，北理珠就是当前行为的执行环境（context），主体跟上下文没有必然的联系，主体只与函数有关系；就好像男神吃饭，其实哪里都可以吃饭，吃饭这个动作的主体永远都是男神，环境是可以变化的。&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　--&amp;gt;&amp;gt;&lt;span data-darkreader-inline-color=&quot;&quot;&gt;&lt;strong&gt;结论：上面，其实也可以说明，this指的是谁，和函数在哪里定义和执行是没有任何关系的。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;二、在函数中，如何区分this&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　&lt;span data-darkreader-inline-color=&quot;&quot;&gt;　&lt;span data-darkreader-inline-color=&quot;&quot;&gt;1、函数执行，首先看函数名前面是否有“.” ，有的话， “.”前面是谁，this就是谁；没有的话this就是window&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&lt;span&gt;//例子一
console.log(this);
function eat() {
    console.log(this); //this-&amp;gt;window
}
~function() {
    eat(); //this-&amp;gt;window
}();

//例子二
function fn() {
    console.log(this);  
}
var obj = {fn: fn};
fn(); //this-&amp;gt;window
obj.fn() //this-&amp;gt;obj

//例子三
function sum() {
    fn();  
}
sum(); //this-&amp;gt;window

//例子四
var oo = {
    sum: function() {
        console.log(this);
        fn();
    }
}
oo.sum(); //首先sum函数里面，第一个输出this为oo；之后执行fn()，this为window
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　&lt;span data-darkreader-inline-color=&quot;&quot;&gt;　&lt;span data-darkreader-inline-color=&quot;&quot;&gt;2、立即执行函数中的this永远都是window&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&lt;span&gt;(function() {
    console.log(this); // this-&amp;gt;window
})()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　&lt;span data-darkreader-inline-color=&quot;&quot;&gt;　&lt;span data-darkreader-inline-color=&quot;&quot;&gt;3、给元素的某一事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前元素&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&lt;span&gt;function fn() {
    console.log(this);
}
//例子一
document.getElementById(&quot;div1&quot;).onclick = fn; //this -&amp;gt; dom元素
//例子二
document.getElementById(&quot;div1&quot;).onclick = function() {
    console.log(this); // this-&amp;gt;#div
    fn(); // this-&amp;gt;window
}
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　&lt;span data-darkreader-inline-color=&quot;&quot;&gt;　结论： 找到函数在哪里执行的，有点，this就是点前面东西；没点，this就是window&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;三、使用this分析一道面试题&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&lt;span&gt;var  num = 20;
var obj = {
    num: 30,
    fn: (function(num) {
        this.num *= 3;
        num += 15;
        var num  = 45;
        return function() {
            this.num *= 4;
            num + =20;
            console.log(num);
        }
    })
};
var fn = obj.fn;
fn(); // -&amp;gt;65
obj.fn(); // -&amp;gt;85
console.log(window.num, obj.num) // -&amp;gt;240, 120
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　　上面代码使用堆栈图来描述，如下，首先正方形代表栈内存（函数执行环境，context），圆边方形代表堆内存（用来存放字符串）。&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1254758/201906/1254758-20190627235003085-1841284860.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　第一步，形成一个js执行环境，window作用域，首先预解释（声明var，声明+定义function）；&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　第二步，代码由上往下执行，num = 20, obj = 引用数据类型（数据存在堆内存里面）&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　第三步，因为obj.fn是立即执行函数，所以形成一个私有作用域A，执行fn里面的函数，因为fn里面的函数返回值为function，return值被外面的obj.fn引用了，这个立即执行函数A作用域不销毁。&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　第四步，window作用域下面的代码继续往下执行。&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;&lt;strong&gt;四、this实践运用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　现在有这样一个需求，要求做一个累加器，每点击一次，就累加1。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:javascript;collapse:true;;gutter:true;&quot;&gt;
&lt;span&gt;var oBtn = document.getElementById(&quot;btn&quot;);
var spanNum = document.getElementById(&quot;spanNum&quot;);
// 方法一
// 利用全局作用域不销毁的原理，把需要累加的数字定义为全局变量
var count = 0;
oBtn.onclikc = function() {
    count++;
    spanNuM.innerText = count;  
}
// 弊端：在项目中为了防止全局变量之间的冲突，我们一般是禁止或者减少使用全局变量的

// 方法二
// 形成一个不销毁的私有作用域保存我们需要累积的数据
// 1）
(function() {
    var count = 0;
    oBtn.onclick = function() {
        ++count;
        spanNum.innerText = count;
    } 
})
// 2）
oBtn.onclick = (function() {
    var count = 0;
    return function() {
        ++count;
        spanNum.innerText = count;
    }
})
// 上面的两种写法都是表达同一个意思
// 弊端：有一个不销毁的私有作用域，占那么一点点内存

// 方法三
// 利用innerHTML的方式处理，每点击一次都需要到页面获取最新的值，然后累加，最后把结果放进去
oBtn.onclick = function() {
    ++spanNum.innerHTML;  
}
// 弊端：innerHTML获取的时候本来就需要浏览器去处理，每一次都需要把页面的内存先转化为字符串，然后累加，累加完重新添加回去，当重新添加的时候浏览器需要重现渲染一遍页面。

// 方法四
// 利用自定义属性存储（推荐！）
oBtn.count = 0;
oBtn.onclick = function() {
    spanNum.innerTxt = ++this.count;    
}
//注意，这里的count只是对象的一个属性，它既不是全局变量，也不是局部变量哦。
&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/p&gt;
&lt;p data-darkreader-inline-color=&quot;&quot;&gt;&lt;span&gt;　　END&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 28 Jun 2019 15:48:00 +0000</pubDate>
<dc:creator>彭胜光</dc:creator>
<og:description>一、this，其实可以类比成人 说到this的话，我们在js中主要研究的都是函数中的this，在javascript中，this代表当前行为的执行主体，而context代表的是当前行为执行的的环境（区</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/pengshengguang/p/11105323.html</dc:identifier>
</item>
<item>
<title>.NET中生成水印更好的方法 - 周杰的代码骚操作</title>
<link>http://www.cnblogs.com/sdflysha/p/better-way-to-generate-watermark.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sdflysha/p/better-way-to-generate-watermark.html</guid>
<description>&lt;p&gt;为了保护知识产权，防止资源被盗用，水印在博客、网店等场景中非常常见。&lt;/p&gt;
&lt;p&gt;本文首先演示了基于&lt;code&gt;System.Drawing.Image&lt;/code&gt;做正常操作。然后基于&lt;code&gt;Direct2D&lt;/code&gt;/&lt;code&gt;WIC&lt;/code&gt;/&lt;code&gt;DirectWrite&lt;/code&gt;，演示了一种全新、不同的“&lt;strong&gt;骚&lt;/strong&gt;”操作。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;System.Drawing.Image&lt;/code&gt;原生属于&lt;code&gt;GDI&lt;/code&gt;的一部分，是Windows Only，但随着NuGet包&lt;a href=&quot;https://www.nuget.org/packages/System.Drawing.Common/&quot;&gt;System.Drawing.Common&lt;/a&gt;的发布，现在&lt;code&gt;System.Drawing.Image&lt;/code&gt;已经支持&lt;code&gt;linux&lt;/code&gt;：&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;Install-Package System.Drawing.Common -Version 4.5.1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下代码演示了如何从给图片加水印：&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// 加水印
var watermarkedStream = new MemoryStream();
using (var img = Image.FromStream(File.OpenRead(@&quot;D:\_\WatermarkDemo.png&quot;)))
{
    using (var graphic = Graphics.FromImage(img))
    {
        var font = new Font(&quot;微软雅黑&quot;, 30, FontStyle.Bold, GraphicsUnit.Pixel);
        var color = Color.FromArgb(128, 255, 255, 255);
        var brush = new SolidBrush(color);
        var point = new Point(img.Width - 130, img.Height - 50);

        graphic.DrawString(&quot;水印在此&quot;, font, brush, point);
        img.Save(watermarkedStream, ImageFormat.Png);
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果如图（没有黄色剪头）：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201906/233608-20190628225946608-1103120365.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;附：Edi.Wang做了一个NuGet包，可以轻松地配置水印参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;NuGet：https://github.com/EdiWang/Edi.ImageWatermark&lt;/li&gt;
&lt;li&gt;文章：https://edi.wang/post/2018/10/12/add-watermark-to-uploaded-image-aspnet-core&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Direct2D&lt;/code&gt;源于&lt;code&gt;Windows 8&lt;/code&gt;/&lt;code&gt;IE 10&lt;/code&gt;，安装&lt;code&gt;IE 10&lt;/code&gt;之后，&lt;code&gt;Windows 7&lt;/code&gt;也能用。&lt;code&gt;Direct2D&lt;/code&gt;基于&lt;code&gt;Direct3D&lt;/code&gt;，很显然，是Windows Only的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Direct2D&lt;/code&gt;是&lt;code&gt;Windows&lt;/code&gt;下一代的2D渲染库，随着&lt;code&gt;Direct2D&lt;/code&gt;一起发布的，还有&lt;code&gt;Windows Imaging Component&lt;/code&gt;（简称&lt;code&gt;WIC&lt;/code&gt;）和&lt;code&gt;DirectWrite&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;相关说明和文档链接：&lt;/p&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;2.865671641791&quot;&gt;&lt;tr class=&quot;odd&quot; readability=&quot;1.9148936170213&quot;&gt;&lt;td&gt;&lt;code&gt;Direct2D&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;基于硬件加速的2D图形渲染&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/direct2d/direct2d-portal&quot;&gt;Go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;1.8918918918919&quot;&gt;&lt;td&gt;&lt;code&gt;WIC&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;高性能图片编码、解码&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/wic/-wic-about-windows-imaging-codec&quot;&gt;Go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;1.9166666666667&quot;&gt;&lt;td&gt;&lt;code&gt;DirectWrite&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;基于硬件加速的文字渲染&lt;/td&gt;
&lt;td&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/desktop/directwrite/direct-write-portal&quot;&gt;Go&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;如果您打开链接看了一眼，就不难看出，这些技术都是基于&lt;code&gt;COM&lt;/code&gt;的，但我们使用&lt;code&gt;.NET&lt;/code&gt;，不是吗？&lt;/p&gt;
&lt;h2 id=&quot;好在我们有sharpdx&quot;&gt;好在我们有&lt;code&gt;SharpDX&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SharpDX&lt;/code&gt;对这些&lt;code&gt;DirectX&lt;/code&gt;技术做了封装，在这个Demo中，我们需要安装&lt;code&gt;SharpDX.Direct2D1&lt;/code&gt;和&lt;code&gt;SharpDX.Mathematics&lt;/code&gt;两个包：&lt;/p&gt;
&lt;pre class=&quot;powershell&quot;&gt;
&lt;code&gt;Install-Package SharpDX.Direct2D1 -Version 4.2.0
Install-Package SharpDX.Mathematics -Version 4.2.0&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下代码演示了如何使用&lt;code&gt;SharpDX.Direct2D1&lt;/code&gt;给图片加水印：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using D2D = SharpDX.Direct2D1;
using DWrite = SharpDX.DirectWrite;
using SharpDX;
using SharpDX.IO;
using WIC = SharpDX.WIC;

MemoryStream AddWatermark(Stream fileName, string watermarkText)
{
    using (var wic = new WIC.ImagingFactory2())
    using (var d2d = new D2D.Factory())
    using (var image = CreateWicImage(wic, fileName))
    using (var wicBitmap = new WIC.Bitmap(wic, image.Size.Width, image.Size.Height, WIC.PixelFormat.Format32bppPBGRA, WIC.BitmapCreateCacheOption.CacheOnDemand))
    using (var target = new D2D.WicRenderTarget(d2d, wicBitmap, new D2D.RenderTargetProperties()))
    using (var bmpPicture = D2D.Bitmap.FromWicBitmap(target, image))
    using (var dwriteFactory = new SharpDX.DirectWrite.Factory())
    using (var brush = new D2D.SolidColorBrush(target, new Color(0xff, 0xff, 0xff, 0x7f)))
    {
        target.BeginDraw();
        {
            target.DrawBitmap(bmpPicture, new RectangleF(0, 0, target.Size.Width, target.Size.Height), 1.0f, D2D.BitmapInterpolationMode.Linear);
            target.DrawRectangle(new RectangleF(0, 0, target.Size.Width, target.Size.Height), brush);
            var textFormat = new DWrite.TextFormat(dwriteFactory, &quot;微软雅黑&quot;, DWrite.FontWeight.Bold, DWrite.FontStyle.Normal, 30.0f);
            target.DrawText(watermarkText, textFormat, new RectangleF(target.Size.Width - 130, target.Size.Height - 50, int.MaxValue, int.MaxValue), brush);
        }
        target.EndDraw();

        var ms = new MemoryStream();
        SaveD2DBitmap(wic, wicBitmap, ms);
        return ms;
    }
}

void SaveD2DBitmap(WIC.ImagingFactory wicFactory, WIC.Bitmap wicBitmap, Stream outputStream)
{
    using (var encoder = new WIC.BitmapEncoder(wicFactory, WIC.ContainerFormatGuids.Png))
    {
        encoder.Initialize(outputStream);
        using (var frame = new WIC.BitmapFrameEncode(encoder))
        {
            frame.Initialize();
            frame.SetSize(wicBitmap.Size.Width, wicBitmap.Size.Height);

            var pixelFormat = wicBitmap.PixelFormat;
            frame.SetPixelFormat(ref pixelFormat);
            frame.WriteSource(wicBitmap);

            frame.Commit();
            encoder.Commit();
        }
    }
}

WIC.FormatConverter CreateWicImage(WIC.ImagingFactory wicFactory, Stream stream)
{
    using (var decoder = new WIC.PngBitmapDecoder(wicFactory))
    {
        var decodeStream = new WIC.WICStream(wicFactory, stream);
        decoder.Initialize(decodeStream, WIC.DecodeOptions.CacheOnLoad);
        using (var decodeFrame = decoder.GetFrame(0))
        {
            var converter = new WIC.FormatConverter(wicFactory);
            converter.Initialize(decodeFrame, WIC.PixelFormat.Format32bppPBGRA);
            return converter;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;调用方式：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;File.WriteAllBytes(@&quot;D:\_\Demo2.png&quot;, AddWatermark(File.OpenRead(@&quot;D:\_\WatermarkDemo.png&quot;), &quot;水印在此&quot;).ToArray());&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;效果也是一切正常：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201906/233608-20190628225957580-52628970.png&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;System.Drawing&lt;/code&gt;只花了14行，&lt;code&gt;Direct2D&lt;/code&gt;却需要整整60行！复杂程度惊人！为什么要舍简单求复杂呢？&lt;/p&gt;
&lt;p&gt;因为&lt;code&gt;System.Drawing&lt;/code&gt;没有硬件加速，而且生成的图片也没有反走样(&lt;code&gt;Anti-aliasing&lt;/code&gt;)，这导致使用&lt;code&gt;System.Drawing&lt;/code&gt;相比之下较慢，而且生成图片的效果稍差：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/233608/201906/233608-20190628225832847-2025041589.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;很明显可以看出，&lt;code&gt;Direct2D&lt;/code&gt;生成的图片更平滑。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;作者：周杰&lt;br/&gt;出处：https://www.cnblogs.com/sdflysha&lt;br/&gt;本文采用 &lt;a rel=&quot;license&quot; href=&quot;https://creativecommons.org/licenses/by-nc-sa/2.5/cn/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 2.5 中国大陆许可协议&lt;/a&gt; 进行许可，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文连接。&lt;/p&gt;
</description>
<pubDate>Fri, 28 Jun 2019 15:47:00 +0000</pubDate>
<dc:creator>周杰的代码骚操作</dc:creator>
<og:description>.NET中生成水印更好的方法 为了保护知识产权，防止资源被盗用，水印在博客、网店等场景中非常常见。 本文首先演示了基于 做正常操作。然后基于 /`WIC DirectWrite`，演示了一种全新、不同</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sdflysha/p/better-way-to-generate-watermark.html</dc:identifier>
</item>
</channel>
</rss>