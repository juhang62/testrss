<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>无聊吗？写个【飞机大战】来玩吧(上篇) - web前端talk</title>
<link>http://www.cnblogs.com/migufe/p/10872984.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/migufe/p/10872984.html</guid>
<description>&lt;h2&gt;&lt;strong&gt;01前言介绍&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;微信小游戏是基于微信客户端的游戏，它即点即玩，无需下载安装，体验轻便，可以和微信内的好友一起玩，比如PK、围观等，享受小游戏带来的乐趣。那如何开发一款属于自己的小游戏呢？&lt;/p&gt;

&lt;p&gt;源码地址:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/A123asdo11/aircraft_war&quot; target=&quot;_blank&quot;&gt;https://github.com/A123asdo11/aircraft_war&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;（新版ccc已无法正常使用，需要修复，文章作者花费了大量的时间和精力，在ccc2.0以上版本进行了修复，并在微信小游戏正常运行）&lt;/p&gt;

&lt;h2&gt;02&lt;strong&gt;微信小游戏飞机大战简介&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、大事记 　&lt;/strong&gt;　&lt;/p&gt;
&lt;p&gt;经典飞机大战是腾讯交流软件微信5.0版本在2013年8月推出的软件内置经典小游戏。微信早已正式发布微信内置飞机大战游戏，目前该游戏已经下线。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、玩法介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;玩家点击开始游戏并移动自己的大飞机，在躲避迎面而来的其它飞机时，大飞机通过发射炮弹打掉其它小飞机来赢取分数。一旦撞上其它飞机，游戏就结束。&lt;/p&gt;
&lt;p&gt;此时，界面中会显示此次玩家的飞机大战分数。点击历史成绩后可看到“历史成绩排行榜”。点击重新挑战可继续重玩。点击退出游戏后，回到开始游戏等待页。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、游戏介绍&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1）、首先要清楚飞机的分数，小飞机1000分。 中飞机4000分。 大飞机16000分。 尽量别招惹中大飞机很容易来不及打爆就下来了或者后面又跟着中大飞机。&lt;/p&gt;
&lt;p&gt;2）、手机屏幕要敏感度高，用大屏幕的pad或者长点的手机玩比较有优势。（因为能提前看到前面的障碍物）&lt;/p&gt;
&lt;p&gt;3）、要尽量活的长，安全第一。安全的时候，就是开始比较慢的时候，可以多打一些小飞机,积累分数；遇到飞船，前面可以出击，需要击打一段时间才能摧毁。&lt;/p&gt;
&lt;p&gt;4）、如果吃到了蓝色的双色炮弹，请不要犹豫，尽量找多的，大的地方打。最好身边保留一个炸弹，关键时刻救急，后面的速度很快， 飞机很密集。&lt;/p&gt;
&lt;p&gt;5）、去洗手，手上、屏幕上不能汗渍，水渍、油渍等影响发挥。保持手指、屏幕的顺滑。&lt;/p&gt;
&lt;p&gt;6）、和传统的飞机射击游戏一样，此游戏飞机也不是被碰到就会死，而是飞机有一个点，大概就是最中心那一块，只要不被敌机碰到那一块，而是碰到两边翅膀，那么飞机就不会爆炸，不过这个方法不好掌握，活用的方法是，躲在屏幕的最左或最右，把中心部分隐藏住。&lt;/p&gt;
&lt;p&gt;7）、如果飞机打光了，可以向好友索要，如果好友在一定时间没给你，或者没有好友给你飞机，其实也不用着急到了一定时间，飞机就可以刷出来了，又能继续刷分咯。&lt;/p&gt;
&lt;p&gt;8）、游戏界面预览&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515233846137-1937478264.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;想体验游戏的用户请关注我们公众号：&lt;strong&gt;Web前端Talk&lt;/strong&gt;，并在后台回复，“&lt;strong&gt;我要体验&lt;/strong&gt;”，我们将随机抽取幸运玩家。名额有限哦！！！&lt;/p&gt;

&lt;h2&gt;03&lt;strong&gt;游戏场景设计&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、开始场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A、主界面（公共背景图，动画小飞机）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234004094-465080841.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B、开始游戏按钮&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234018337-160807819.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、游戏场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt; A、英雄机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234033436-2089124240.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;①、子弹（无限，红色）、超级子弹（有限，蓝色）、子弹碰撞敌机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234047953-131083787.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;②、英雄机移动、子弹跟随移动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234100464-597095680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;③、主角与敌机碰撞&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234111945-85626459.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;B、敌机&lt;/p&gt;
&lt;p&gt;①、小、中、大敌机随机生成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234125177-1004374135.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;②、敌机生命值，获得分数&lt;/p&gt;
&lt;p&gt;C、BUFF&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234137120-2017754356.png&quot; alt=&quot;&quot;/&gt;（炸弹）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234144305-2058381408.png&quot; alt=&quot;&quot;/&gt;（超级子弹，蓝色弹夹）&lt;/p&gt;
&lt;p&gt;D、分数、炸弹夹&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、GameOver场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;A、主角碰撞敌机后游戏结束，展示当前获得分数&lt;/p&gt;
&lt;p&gt;B、主界面上方展示历史最高分数&lt;/p&gt;
&lt;p&gt;C、玩家可选择按钮，重新挑战、历史得分、退出游戏&lt;/p&gt;

&lt;p&gt;Cocos creator工具预览&lt;/p&gt;
&lt;p&gt;目录结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234213411-1890075781.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Scene：场景，&lt;/p&gt;
&lt;p&gt;Script：脚本，所有脚本都在这里，&lt;/p&gt;
&lt;p&gt;Texture：图片资源以及图集资源，&lt;/p&gt;
&lt;p&gt;Animation：动画元素，&lt;/p&gt;
&lt;p&gt;Prefab：预载体资源，用于重复利用节点&lt;/p&gt;
&lt;p&gt;Sound：音乐资源&lt;/p&gt;

&lt;p&gt;层级管理器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234225527-388545680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Canvas：画布，开发者用于在画布中创建精灵，节点等内容。&lt;/p&gt;

&lt;p&gt;MainCamera：摄像机，玩家观察游戏世界的窗口，一个场景至少有一个摄像机，用于渲染场景，另外可新增空节点，UI节点，渲染节点；&lt;/p&gt;

&lt;h2&gt;04&lt;strong&gt;方案实现 &lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;使用cocos creator开发创建场景scene，分别为：start（开始页）、main（游戏主页）、historyScore（历史分数页）、end（游戏结束页）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1、公共部分&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设计所有场景自适应宽高尺寸，size为w：640，h：1136，选中层级里的canvas元素&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234251994-738474573.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; canvas层级下创建sprite，并在资源管理器Texture拖动background到spriteFrame&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234304825-147746666.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2、开始页&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;标题，新增sprite，拖入“shoot_copyright“&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234318736-1581939565.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234327151-580109093.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小飞机动画，新增animation节点，将资源管理下animation文件夹下的game_loading拖入至default Clip，clips是可以通过脚本访问的动画clip列表，勾选playOnLoad即游戏运行后自动播放动画&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234338693-1427577854.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;开始按钮，新增button节点，自带label文本节点，可先设置按钮背景图，再改label为“开始游戏”&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234350643-1977593368.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击开始游戏触发场景切换，在资源管理Script文件夹下新增start.js，主要申明动画节点对象，properties是脚本对象里的自定义属性，可用于拖入节点，编辑等操作；&lt;/p&gt;
&lt;p&gt;将start.js拖入至层级canvas下，并将game_loading动画节点拖入至GameLoading中；&lt;/p&gt;
&lt;p&gt;button按钮需设置Click Events为1，添加层级中的start节点，设置函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234402502-450982122.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码说明：&lt;/p&gt;
&lt;p&gt;this.game_loading.getComponent(cc.Animation);//是获取当前属性game_loading动画节点&lt;/p&gt;
&lt;p&gt;gameloading&amp;amp;&amp;amp;gameloading.play();//当该节点对象存在时，执行动画播放事件play()&lt;/p&gt;
&lt;p&gt;cc.director.preloadScene('main');//使用cc.director导演对象调用preloadScene预加载main场景&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、游戏主页（事件拆分）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;暂停按钮，分数，炸弹夹，新增button、label、sprite（子节点label）；&lt;/p&gt;
&lt;p&gt;设置暂停按钮普通状态和按下等背景图（达到按下状态变化） &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234419045-913047200.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绑定点击事件pauseClick &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234430296-802312838.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;代码说明：&lt;/p&gt;
&lt;p&gt;根据当前节点对象eState值判断是否等于游戏常量值，为1时，游戏暂停，停止飞机、子弹、英雄机、背景音乐执行事件；为2时，游戏继续，飞机、子弹、英雄机、背景音乐开始执行；&lt;/p&gt;
&lt;p&gt;分数和炸弹夹展示，英雄机的子弹碰撞敌机销毁后加分、英雄机主体碰撞BUFF后改变炸弹夹展示英雄机，作为主要节点，使用sprite作为飞机模型，绑定hero.js，添加polygonCollider碰撞组件，添加animation组件作为英雄机动态化。&lt;/p&gt;
&lt;p&gt;hero.js主要设置4个属性，主角碰撞敌机后爆炸预制资源、游戏结束音乐、main主函数节点、主角子弹组生成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234446436-513526930.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当主角碰撞时执行onCollisionEnter事件。判断其碰撞的节点是BUFF还是敌机。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234456864-1387549119.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;敌机随机从顶部外向下生成，共3种敌机，小、中、大；&lt;/p&gt;
&lt;p&gt;name：敌机名称，&lt;/p&gt;
&lt;p&gt;freqTime：敌机生成时间（s），&lt;/p&gt;
&lt;p&gt;initPollCount：初始对象池，&lt;/p&gt;
&lt;p&gt;prefab：预制体&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234513490-1623994180.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有对象池之后，随机生成敌机，并给每个敌机绑定回收机制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234524880-1025822476.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;英雄机与敌机的碰撞&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234540023-36394507.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234546527-1505951132.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;绿色连接线为多边缘碰撞，需碰撞组件生成。&lt;/p&gt;
&lt;p&gt;子弹生成与碰撞&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234559673-871294060.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4、Game Over页&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;渲染当前分数，根据cc.sys.localStorage保存的本地数据获取并设置label的string属性&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234614134-1203939892.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;给每个按钮button绑定对应事件 &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234626215-1280507251.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;5、历史成绩页&lt;/p&gt;
&lt;p&gt;Sprite作为背景框架列表，scrollview作为滚动容器组件，加上mask遮罩层组件，加上scrollbar实现内容在可视区域内展示，场景加载时，会遍历分数对象，在根据cc.instantiate克隆该prefab节点，用于添加子节点到scrollContent节点内容中，并初始化该子节点的展示内容score和time；&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1683421/201905/1683421-20190515234638422-2092305544.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;end~~&lt;/p&gt;
&lt;p&gt;以上就是所有场景scene对应的功能。&lt;/p&gt;
&lt;p&gt;还有下期小游戏说明，敬请期待哦~~&lt;/p&gt;
&lt;p&gt;在公众号后台回复“我要体验”让程序员小哥哥拉你体验游戏哦~~&lt;/p&gt;

</description>
<pubDate>Wed, 15 May 2019 15:52:00 +0000</pubDate>
<dc:creator>web前端talk</dc:creator>
<og:description>01前言介绍 微信小游戏是基于微信客户端的游戏，它即点即玩，无需下载安装，体验轻便，可以和微信内的好友一起玩，比如PK、围观等，享受小游戏带来的乐趣。那如何开发一款属于自己的小游戏呢？ 源码地址: h</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/migufe/p/10872984.html</dc:identifier>
</item>
<item>
<title>数据加载 - 咸鱼Chen</title>
<link>http://www.cnblogs.com/nickchen121/p/10872939.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nickchen121/p/10872939.html</guid>
<description>&lt;ul&gt;&lt;li&gt;boston housing
&lt;ul&gt;&lt;li&gt;Boston housing price regression dataset&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;mnist/fashion mnist
&lt;ul&gt;&lt;li&gt;MNIST/Fashion-MNIST dataset&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;cifar10/100
&lt;ul&gt;&lt;li&gt;small images classification dataset&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;imdb
&lt;ul&gt;&lt;li&gt;sentiment classification dataset&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mnist&quot;&gt;MNIST&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/nickchen121/1461163/o_14-%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD-mnist%E6%95%B0%E6%8D%AE%E9%9B%86.jpg&quot; alt=&quot;14-数据加载-mnist数据集.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import tensorflow as tf
from tensorflow import keras&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# train: 60k | test: 10k
(x, y), (x_test, y_test) = keras.datasets.mnist.load_data()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;x.shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(60000, 28, 28)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y.shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(60000,)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 0纯黑、255纯白
x.min(), x.max(), x.mean()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;(0, 255, 33.318421449829934)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;x_test.shape, y_test.shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;((10000, 28, 28), (10000,))&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y[:4]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;array([5, 0, 4, 1], dtype=uint8)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 0-9有10种分类结果
y_onehot = tf.one_hot(y, depth=10)
y_onehot[:2]&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;tf.Tensor: id=13, shape=(2, 10), dtype=float32, numpy=
array([[0., 0., 0., 0., 0., 1., 0., 0., 0., 0.],
       [1., 0., 0., 0., 0., 0., 0., 0., 0., 0.]], dtype=float32)&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;cifar10100&quot;&gt;CIFAR10/100&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;10个大类中有100个小类&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/nickchen121/1461163/o_14-%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD-CIFAR.jpg&quot; alt=&quot;14-数据加载-CIFAR.jpg&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# train: 50k | test: 10k
(x, y), (x_test, y_test) = keras.datasets.cifar10.load_data()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;x.shape,y.shape,x_test.shape,y_test.shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;x.min(),x.max()&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;y[:4]&lt;/code&gt;
&lt;/pre&gt;

&lt;ul&gt;&lt;li&gt;from_tensor_slices()&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;db =  tf.data.Dataset.from_tensor_slices(x_test)
next(iter(db)).shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;db = tf.data.Dataset.from_tensor_slices((x_test,y_test))
next(iter(db))[0].shape&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;shuffle&quot;&gt;.shuffle&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;打乱数据&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;db = tf.data.Dataset.from_tensor_slices(x_test,y_test)
db = db.shuffle(10000)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;map&quot;&gt;.map&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数据预处理&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def preprocess(x,y):
    x = tf.cast(x,dtype=tf.float32)/255.
    y = tf.cast(y,dtype=tf.int32)
    y = tf.one_hot(y,depty=10)
    return x,y&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;db2 = db.map(preprocess)&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;res = next(iter(db2))
res[0].shape,res[1].shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;res[1][:2]&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;batch&quot;&gt;.batch&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;一次性得到多张照片&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;db3 = db2.batch(32)
res = next(iter(db3))
res[0].shape,res[1].shape&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;db_iter = iter(db3)
while True:
    next(db_iter)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;repeat&quot;&gt;.repeat()&lt;/h2&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 迭代不退出
db4 = db3.repeat()
# 迭代两次退出
db3 = db3.repeat(2)&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def prepare_mnist_features_and_labels(x,y):
    x = tf.cast(x,tf.float32)/255.
    y = tf.cast(y,tf.int64)
    return x,y

def mnist_dataset():
    (x,y),(x_val,y_val)=datasets.fashion_mnist.load_data()
    y  =tf.one_hot(y,depth=10)
    y_val = tf.one_hot(y_val,depth=10)
    
    ds = tf.data.Dataset.from_tensor_slices((x,y))
    ds = ds.map(prepare_mnist_features_and_labels)
    ds =  ds.shffle(60000).batch(100)
    ds_val = tf.data.Dataset.from_tensor_slices((x_val,y_val))
    ds_val = ds_val.map(prepare_mnist_features_and_labels)
    ds_val = ds_val.shuffle(10000).batch(100)
    return ds,ds_val&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 15 May 2019 15:40:00 +0000</pubDate>
<dc:creator>咸鱼Chen</dc:creator>
<og:description>TensorFlow2之数据加载</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nickchen121/p/10872939.html</dc:identifier>
</item>
<item>
<title>学习RadonDB源码（一） - wingsless</title>
<link>http://www.cnblogs.com/wingsless/p/10872892.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wingsless/p/10872892.html</guid>
<description>&lt;h2 id=&quot;可能是开始也可能是结束&quot;&gt;1. 可能是开始也可能是结束&lt;/h2&gt;
&lt;p&gt;RadonDB是国内知名云服务提供商青云开源的一款产品，下面是一段来自官方的介绍：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;QingCloud RadonDB 是基于 MySQL 研发的新一代分布式关系型数据库，可无限水平扩展，支持分布式事务，具备金融级数据强一致性，满足企业级核心数据库对大容量、高并发、高可靠及高可用的极致要求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;做DBA的都知道关系型数据库在分布式数据库方面堪称举步维艰，虽然很多高手或者公司都开源了自己的中间件，但是很少有公司像青云这样将自己商用的成套解决方案直接开源的。可能开源版本和商用版本之间有很多功能差异，不过从解决方案的完整性角度来看，RadonDB堪称是良心产品了。&lt;/p&gt;
&lt;p&gt;而且RadonDB的还有一个明显的好处是用Go编写的，而且现在的代码量也不算大，对于一个学习Go语言的人来说这是一个极好的项目。另外还有一点，RadonDB模拟了完整的MySQL Server端，里面有一项核心的东西叫做SQL解析器和优化器的，刚好可以借此机会从源码角度学习一下其思想。要知道MySQL虽然开源，但是整个项目都是用C编写的，很难看懂。&lt;/p&gt;
&lt;p&gt;我打算用闲暇时间好好学习一下RadonDB源码，当然我可能半途而废，所以，这一篇可能是开始也可能是结束。&lt;/p&gt;
&lt;h2 id=&quot;入口的radon.go文件&quot;&gt;2. 入口的radon.go文件&lt;/h2&gt;
&lt;p&gt;这个文件在“radon/src/radon”目录下，代码只有区区82行，不过这是整个RadonDB的入口。&lt;/p&gt;
&lt;p&gt;这段代码中利用了不少flag包用于接收参数，首先映入眼帘的是一堆import，此处就不加赘述了，因为毕竟只是引入了包，至于做什么的，代码写了就能知道。&lt;/p&gt;
&lt;p&gt;接下来是包的初始化：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;var (
    flagConf string
)

func init() {
    flag.StringVar(&amp;amp;flagConf, &quot;c&quot;, &quot;&quot;, &quot;radon config file&quot;)
    flag.StringVar(&amp;amp;flagConf, &quot;config&quot;, &quot;&quot;, &quot;radon config file&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;flag是一个很好用的包，用于接收命令行参数，至于怎么用可以参考网上的资料。这个init()函数很有意思，这个函数会在很多书的“包初始化”一节来讲述，其实记住几个顺序就可以：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;初始化导入的包；&lt;/li&gt;
&lt;li&gt;在包级别为声明的变量计算并分配初始值；&lt;/li&gt;
&lt;li&gt;执行包内的init函数。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这是包的初始化顺序，那么回到radon.go，初始化顺序也是一目了然的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;init函数不能被引用&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来是一个简单的usage函数：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func usage() {
    fmt.Println(&quot;Usage: &quot; + os.Args[0] + &quot; [-c|--config] &amp;lt;radon-config-file&amp;gt;&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;仅仅是为了打印命令行的帮助，在引用的时候才有效，现在只是声明。&lt;/p&gt;
&lt;p&gt;而后就是程序的主入口main函数了，这段函数的最开始就执行了这样一句：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;runtime.GOMAXPROCS(runtime.NumCPU())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;声明了逻辑处理单元，数量和CPU核数相当，这一点在之前讲goroutine的笔记中讲述过。&lt;/p&gt;
&lt;p&gt;紧接着，程序将获得一些关键的环境信息：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;build := build.GetInfo()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;虽然只有一句，但是背后的东西还是很丰富的：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func GetInfo() Info {
    return Info{
        GoVersion: runtime.Version(),
        Tag:       &quot;8.0.0-&quot; + tag,
        Time:      time,
        Git:       git,
        Platform:  platform,
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这是一种典型的结构体的初始化方式，如果对结构体不熟悉，建议也是百度一下相关资料。&lt;/p&gt;
&lt;p&gt;这些打印出信息的东西无非就是一些显示输出，跟我们平时启动Spring的时候打印那个炫酷的SPRING banner没什么区别，接来下才是处理一些要紧的东西，比如处理配置：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    // config
    flag.Usage = func() { usage() }
    flag.Parse()
    if flagConf == &quot;&quot; {
        usage()
        os.Exit(0)
    }

    conf, err := config.LoadConfig(flagConf)
    if err != nil {
        log.Panic(&quot;radon.load.config.error[%v]&quot;, err)
    }
    log.SetLevel(conf.Log.Level)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中的&lt;code&gt;flag.Usage&lt;/code&gt;是函数变量，函数变量是一个新颖的概念，举一个例子说明：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func square(n int) int { return n*n }

f := square
//打印9
fmt.Println(f(3))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;flag包中的Usage本身就是个函数变量。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上面这段业务代码主要做了这么几件事情：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;解析flag，得到命令行参数；&lt;/li&gt;
&lt;li&gt;判断参数是否为空，为空则打印使用说明并退出；&lt;/li&gt;
&lt;li&gt;加载配置项，并做异常处理；&lt;/li&gt;
&lt;li&gt;设置日志级别。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们先不说紧接着要启动的Monitor了，这是一个性能指标监控，并不在我的学习范围内。&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    // Proxy.
    proxy := proxy.NewProxy(log, flagConf, build.Tag, conf)
    proxy.Start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代理是每个人写程序都挺喜欢写的名字。proxy是一个自行编写的包，我们来看看NewProxy的时候做了什么：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;func NewProxy(log *xlog.Log, path string, serverVersion string, conf *config.Config) *Proxy {
    audit := audit.NewAudit(log, conf.Audit)
    router := router.NewRouter(log, conf.Proxy.MetaDir, conf.Router)
    scatter := backend.NewScatter(log, conf.Proxy.MetaDir)
    syncer := syncer.NewSyncer(log, conf.Proxy.MetaDir, conf.Proxy.PeerAddress, router, scatter)
    plugins := plugins.NewPlugin(log, conf, router, scatter)
    return &amp;amp;Proxy{
        log:           log,
        conf:          conf,
        confPath:      path,
        audit:         audit,
        router:        router,
        scatter:       scatter,
        syncer:        syncer,
        plugins:       plugins,
        sessions:      NewSessions(log),
        iptable:       NewIPTable(log, conf.Proxy),
        throttle:      xbase.NewThrottle(0),
        serverVersion: serverVersion,
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码倒是很简单，就是利用入参中的配置项，声明了一系列的变量，并将这些变量封装在一个结构体内，然后返回。至于这些变量都是干什么的，我下次再说，这次只跟踪主流程。&lt;/p&gt;
&lt;p&gt;紧接着看看启动都做了什么：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Start used to start the proxy.
func (p *Proxy) Start() {
    log := p.log
    conf := p.conf
    audit := p.audit
    iptable := p.iptable
    syncer := p.syncer
    router := p.router
    scatter := p.scatter
    plugins := p.plugins
    sessions := p.sessions
    endpoint := conf.Proxy.Endpoint
    throttle := p.throttle
    serverVersion := p.serverVersion

    log.Info(&quot;proxy.config[%+v]...&quot;, conf.Proxy)
    log.Info(&quot;log.config[%+v]...&quot;, conf.Log)

    if err := audit.Init(); err != nil {
        log.Panic(&quot;proxy.audit.init.panic:%+v&quot;, err)
    }
    // 省略了一大堆，为了节省篇幅

    spanner := NewSpanner(log, conf, iptable, router, scatter, sessions, audit, throttle, plugins, serverVersion)
    if err := spanner.Init(); err != nil {
        log.Panic(&quot;proxy.spanner.init.panic:%+v&quot;, err)
    }
    svr, err := driver.NewListener(log, endpoint, spanner)
    if err != nil {
        log.Panic(&quot;proxy.start.error[%+v]&quot;, err)
    }
    p.spanner = spanner
    p.listener = svr
    log.Info(&quot;proxy.start[%v]...&quot;, endpoint)
    go svr.Accept()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个Start函数看起来好像Java中的构造器，做的事情也和构造器有点相似，就是赋值，不过它还能做多的事情，比如说启动了一个监听：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;svr, err := driver.NewListener(log, endpoint, spanner)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有了监听之后，就可以启动一个goroutine了，而且是有条件的存活的：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;go svr.Accept()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里的条件就是Accept要做什么：&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;Accept runs an accept loop until the listener is closed.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在listener关闭之前，Accept将始终运行一个循环，也就是说这个goroutine会一直生存下去。&lt;/p&gt;
&lt;p&gt;到这一步proxy就算启动起来了，然后就会去启动Admin了：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    // Admin portal.
    admin := ctl.NewAdmin(log, proxy)
    admin.Start()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;按照惯例看看NewAdmin在干什么：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// NewAdmin creates the new admin.
func NewAdmin(log *xlog.Log, proxy *proxy.Proxy) *Admin {
    return &amp;amp;Admin{
        log:   log,
        proxy: proxy,
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码逻辑很简单，就是返回一个Admin结构体的指针。而Admin结构体是这样的：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Admin tuple.
type Admin struct {
    log    *xlog.Log
    proxy  *proxy.Proxy
    server *http.Server
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看，之前的代码里没有对server进行赋值，这是为什么？答案在Start函数里：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;// Start starts http server.
func (admin *Admin) Start() {
    api := rest.NewApi()
    router, err := admin.NewRouter()
    if err != nil {
        panic(err)
    }

    api.SetApp(router)
    handlers := api.MakeHandler()
    admin.server = &amp;amp;http.Server{Addr: admin.proxy.PeerAddress(), Handler: handlers}

    go func() {
        log := admin.log
        log.Info(&quot;http.server.start[%v]...&quot;, admin.proxy.PeerAddress())
        if err := admin.server.ListenAndServe(); err != http.ErrServerClosed {
            log.Panic(&quot;%v&quot;, err)
        }
    }()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里是一系列的Http操作，对server的赋值就在其中，此时会把默认IP，端口等等信息都写入到server中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2921521-bd14d6d56526a5f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;默认值&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一看代码我就知道RadonDB要用3308端口进行连接，而起管理端口就注册在8080。&lt;/p&gt;
&lt;p&gt;好了，这些都很容易明白，此时Start函数只需要启动一个goroutine就可以了。关键在这里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2921521-b7f5b40c51d859e3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;启动&quot;/&gt;&lt;/p&gt;
&lt;p&gt;看名字就知道这是干什么的，监听并维护一个服务，看看其注释：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2921521-be10dcb35a13d6eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;注释&quot;/&gt;&lt;/p&gt;
&lt;p&gt;那么这样一来，服务就启动起来了，当然后面还会有stop函数，就不再详解了。有意思的是，可以注意这几句：&lt;/p&gt;
&lt;pre class=&quot;go&quot;&gt;
&lt;code&gt;    // Handle SIGINT and SIGTERM.
    ch := make(chan os.Signal)
    signal.Notify(ch, syscall.SIGINT, syscall.SIGTERM)
    log.Info(&quot;radon.signal:%+v&quot;, &amp;lt;-ch)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这几句声明了一个通道，一个Signal类型的通道，可以用于接收系统调用，SIGINT一般是ctrl-c，SIGTERM一般是kill。在发生这两个系统调用后，系统开始关闭。&lt;/p&gt;
&lt;h2 id=&quot;小结&quot;&gt;3. 小结&lt;/h2&gt;
&lt;p&gt;Go语言还是简单的，至少现在看来，这些代码我是都能看懂的，而我学习Go语言的时间也不过两周。&lt;/p&gt;
&lt;p&gt;我希望能借着RadonDB的开源，学会关键的优化器和SQL解析器的思想。&lt;/p&gt;
</description>
<pubDate>Wed, 15 May 2019 15:28:00 +0000</pubDate>
<dc:creator>wingsless</dc:creator>
<og:description>1. 可能是开始也可能是结束 RadonDB是国内知名云服务提供商青云开源的一款产品，下面是一段来自官方的介绍： QingCloud RadonDB 是基于 MySQL 研发的新一代分布式关系型数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wingsless/p/10872892.html</dc:identifier>
</item>
<item>
<title>windows安装mingw和LuaJIT - 堕落门徒</title>
<link>http://www.cnblogs.com/cord/p/10872869.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cord/p/10872869.html</guid>
<description>&lt;h3 id=&quot;安装mingw64&quot;&gt;1，安装mingw64&lt;/h3&gt;
&lt;p&gt;先下载mingw64压缩包(不建议下载exe安装包，在线安装太慢)，地址如下：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://nchc.dl.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/seh/x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z&quot;&gt;https://nchc.dl.sourceforge.net/project/mingw-w64/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/8.1.0/threads-posix/seh/x86_64-8.1.0-release-posix-seh-rt_v6-rev0.7z&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;下载之后解压到某路径，然后将其中的bin路径添加至系统path路径，例如&lt;code&gt;E:\Program Files\mingw64\bin&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;检查是否安装成功：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;C:\Users\cord&amp;gt;gcc -v
Using built-in specs.
COLLECT_GCC=gcc
COLLECT_LTO_WRAPPER=E:/Program\ Files/mingw64/bin/../libexec/gcc/x86_64-w64-mingw32/8.1.0/lto-wrapper.exe
Target: x86_64-w64-mingw32
......
Thread model: posix
gcc version 8.1.0 (x86_64-posix-seh-rev0, Built by MinGW-W64 project)&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;编译安装luajit&quot;&gt;2，编译安装luajit&lt;/h3&gt;
&lt;p&gt;下载luajit：&lt;a href=&quot;http://luajit.org/download/LuaJIT-2.1.0-beta3.zip&quot; class=&quot;uri&quot;&gt;http://luajit.org/download/LuaJIT-2.1.0-beta3.zip&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;解压&lt;code&gt;LuaJIT-2.1.0-beta3.zip&lt;/code&gt;并用cmd进入文件夹执行编译命令&lt;code&gt;mingw32-make&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;E:\&amp;gt;cd LuaJIT-2.1.0-beta3

E:\LuaJIT-2.1.0-beta3&amp;gt;mingw32-make
&quot;==== Building LuaJIT 2.1.0-beta3 ====&quot;
mingw32-make -C src
mingw32-make[1]: Entering directory 'E:/LuaJIT-2.1.0-beta3/src'
&quot;HOSTCC    host/minilua.o&quot;
.......
&quot;CC        lj_lib.o&quot;
&quot;CC        lj_alloc.o&quot;
lj_alloc.c:154:14: warning: 'DIRECT_MMAP' defined but not used [-Wunused-function]
 static void *DIRECT_MMAP(size_t size)
              ^~~~~~~~~~~
...              
&quot;CC        lib_init.o&quot;
&quot;DYNLINK   lua51.dll&quot;
&quot;CC        luajit.o&quot;
&quot;BUILDVM   jit/vmdef.lua&quot;
&quot;LINK      luajit.exe&quot;
&quot;OK        Successfully built LuaJIT&quot;
mingw32-make[1]: Leaving directory 'E:/LuaJIT-2.1.0-beta3/src'
&quot;==== Successfully built LuaJIT 2.1.0-beta3 ====&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;编译完成之后，将src下面的&lt;code&gt;luajit.exe&lt;/code&gt;和&lt;code&gt;lua51.dll&lt;/code&gt;两个文件拷贝到新建的&lt;code&gt;E:/LuaJIT&lt;/code&gt;文件夹下面，并将src下面的&lt;code&gt;jit&lt;/code&gt;文件夹拷贝到&lt;code&gt;E:/LuaJIT/lua&lt;/code&gt;下面，整体目录结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;E:\&amp;gt;tree /F luajit
卷 E 的文件夹 PATH 列表
卷序列号为 5EA5-2C1D
E:\LUAJIT
│  lua51.dll
│  luajit.exe
│
└─lua
    └─jit
            bc.lua
            bcsave.lua
            dis_arm.lua
            dis_arm64.lua
            dis_arm64be.lua
            dis_mips.lua
            dis_mips64.lua
            dis_mips64el.lua
            dis_mipsel.lua
            dis_ppc.lua
            dis_x64.lua
            dis_x86.lua
            dump.lua
            p.lua
            v.lua
            vmdef.lua
            zone.lua&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后将&lt;code&gt;E:/LuaJIT&lt;/code&gt;加入path路径。&lt;/p&gt;
&lt;p&gt;检验安装结果：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;C:\Users\cord&amp;gt;luajit -v
LuaJIT 2.1.0-beta3 -- Copyright (C) 2005-2017 Mike Pall. http://luajit.org/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;测试：&lt;/p&gt;
&lt;p&gt;创建一个lua脚本&lt;code&gt;test.lua&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;lua&quot;&gt;
&lt;code&gt;print(&quot;hello world&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后使用luajit进行编译生成bytecode ：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;E:\Test\lua&amp;gt;luajit -b test.lua 1.lua&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;会发现路径下生成了1.lua的文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附&lt;/strong&gt;：如果使用luajit的时候出现&lt;code&gt;luajit: unknown luaJIT command or jit.* modules not installed&lt;/code&gt;的错误，说明lua模块放置的路径有问题，可以通过&lt;code&gt;luajit -e &quot;require('jit.bcsave')&quot;&lt;/code&gt;命令测试一下luajit的模块搜索路径：&lt;/p&gt;
&lt;pre class=&quot;cmd&quot;&gt;
&lt;code&gt;E:\Test\lua&amp;gt;luajit -e &quot;require('jit.bcsave')&quot;
luajit: (command line):1: module 'jit.bcsave' not found:
        no field package.preload['jit.bcsave']
        no file '.\jit\bcsave.lua'
        no file 'E:\LuaJIT\lua\jit\bcsave.lua'
        no file 'E:\LuaJIT\lua\jit\bcsave\init.lua'
        no file '.\jit\bcsave.dll'
        no file 'E:\LuaJIT\jit\bcsave.dll'
        no file 'E:\LuaJIT\loadall.dll'
        no file '.\jit.dll'
        no file 'E:\LuaJIT\jit.dll'
        no file 'E:\LuaJIT\loadall.dll'
stack traceback:
        [C]: in function 'require'
        (command line):1: in main chunk
        [C]: at 0x00402060&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;也就是安装后的jit文件夹最好放到编译包&lt;code&gt;luajit.exe&lt;/code&gt;的同级包的lua文件夹下&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://tutel.me/c/programming/questions/44166483/luajit+on+windows+10+unknown+luajit+command+or+jit&quot; class=&quot;uri&quot;&gt;https://tutel.me/c/programming/questions/44166483/luajit+on+windows+10+unknown+luajit+command+or+jit&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/mydreamremindme/article/details/51372391&quot; class=&quot;uri&quot;&gt;https://blog.csdn.net/mydreamremindme/article/details/51372391&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 May 2019 15:20:00 +0000</pubDate>
<dc:creator>堕落门徒</dc:creator>
<og:description>1，安装mingw64 先下载mingw64压缩包(不建议下载exe安装包，在线安装太慢)，地址如下： 'https://nchc.dl.sourceforge.net/project/mingw w</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cord/p/10872869.html</dc:identifier>
</item>
<item>
<title>C语言conio.h部分解释 - 400BadRequest</title>
<link>http://www.cnblogs.com/qq2220545672/p/C_conio_h.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qq2220545672/p/C_conio_h.html</guid>
<description>&lt;p&gt;#include &amp;lt;conio.h&amp;gt;&lt;/p&gt;&lt;p&gt;int getch(void);&lt;br/&gt;// 从控制台得到下一个字符，以ASCII值返回，并不在屏幕显示该字符&lt;/p&gt;&lt;p&gt;int getche(void);&lt;br/&gt;// 从控制台得到下一个字符，以ASCII值返回&lt;/p&gt;&lt;p&gt;int kbhit(void);&lt;br/&gt;// 判断控制台是否仍有未输入的字符。若有，则返回1，否则返回0&lt;/p&gt;&lt;p&gt;int putch(int);&lt;br/&gt;// 将一个整型数以ASCII码形式输出至控制台，输出成功则返回该整形数&lt;br/&gt;int ungetch(int);&lt;br/&gt;// 将一个整型数以ASCII码形式输出至输入流，输出成功则返回该整型数&lt;br/&gt;// 这里并不会在控制台多输出信息&lt;/p&gt;
&lt;p&gt;//一个示例&lt;br/&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/p&gt;&lt;p&gt;int main(int argc, char const *argv[])&lt;br/&gt;{&lt;br/&gt;    char a;&lt;/p&gt;&lt;p&gt;    // 输入一个字符给a，使用getch则不会在控制台显示，&lt;br/&gt;    // 可以换成使用getche，则会在控制台显示&lt;br/&gt;    a = getch();&lt;/p&gt;&lt;p&gt;    // 将字符a，输出至输入流&lt;br/&gt;    ungetch(a);&lt;/p&gt;&lt;p&gt;    // 这里判断是否有一个待输入的字符&lt;br/&gt;    while (kbhit() == 1) {&lt;br/&gt;        // 如果有待输入的字符，就将其输入给a&lt;br/&gt;        // 这里可以改成getch，因为不是从控制台输入的，无影响&lt;br/&gt;        a = getche();&lt;br/&gt;        putch(a);&lt;br/&gt;    }&lt;br/&gt;    return 0;&lt;br/&gt;}&lt;/p&gt;

&lt;p&gt;/*&lt;/p&gt;
&lt;p&gt;以上所有可以直接复制运行&lt;/p&gt;
&lt;p&gt;转载请注明出处&lt;/p&gt;
&lt;p&gt;*/&lt;/p&gt;
</description>
<pubDate>Wed, 15 May 2019 15:09:00 +0000</pubDate>
<dc:creator>400BadRequest</dc:creator>
<og:description>#include &lt;conio.h&gt;int getch(void);// 从控制台得到下一个字符，以ASCII值返回，并不在屏幕显示该字符int getche(void);// 从控制台得</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qq2220545672/p/C_conio_h.html</dc:identifier>
</item>
<item>
<title>从阿里中台战略看企业IT架构转型之道 - Edison Chou</title>
<link>http://www.cnblogs.com/edisonchou/p/alibaba_it_architect_tranformation_study_notes.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/edisonchou/p/alibaba_it_architect_tranformation_study_notes.html</guid>
<description>&lt;p&gt;&lt;em&gt;此文是我阅读《企业IT架构转型之道》一书的学习笔记，所有内容出自钟华老师的这本书。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;　　在加入X公司后，开始了微服务架构的实践，也开始了共享平台服务的建设，在这方面阿里巴巴的中台战略是一个较好的参考。于是，领导就赠了这么一本《&lt;a href=&quot;http://item.jd.com/12176278.html&quot; target=&quot;_blank&quot;&gt;企业IT架构转型之道&lt;/a&gt;》给我，希望我学以致用，更多的是有这样的一个眼界去指导我们的中台架构设计。因此，我花了两周时间快速地阅读了一下此书，总结了此文作为学习笔记以供日后复习用。此书的确讲了一些干货，虽然很多内容留于表面，但是对于中台的定义和思考，建设中台的方法以及阿里中间件有比较完整的描述，和多年前出版的《&lt;a href=&quot;https://item.jd.com/11236743.html&quot; target=&quot;_blank&quot;&gt;淘宝技术这十年&lt;/a&gt;》以及《&lt;a href=&quot;https://item.jd.com/11322972.html&quot; target=&quot;_blank&quot;&gt;大型网站技术架构-核心原理与案例分析&lt;/a&gt;》一样，是一本值得学习的好书。&lt;/p&gt;

&lt;h2&gt;Part 1 阿里中台战略引发的思考&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;起源自2008年阿里巴巴三大电商体系的技术支持架构
&lt;ul&gt;&lt;li&gt;1688、淘宝、天猫三套电商体系架构完全独立&lt;/li&gt;
&lt;li&gt;三座烟囱分别矗立支撑阿里巴巴最核心的电商业务&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;烟囱式系统建设系统对企业的“三大”弊端
&lt;ul&gt;&lt;li&gt;重复功能建设和维护带来的重复投资&lt;/li&gt;
&lt;li&gt;打通“烟囱式”系统间交互的集成和协作成本高昂&lt;/li&gt;
&lt;li&gt;不利于业务的沉淀和持续发展 =&amp;gt; &lt;span&gt;&lt;strong&gt;对企业伤害最大&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;企业信息中心的组织职能是业务支持？&lt;/span&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;问题核心在于IT信息部门在现有模式下大多被高管定位为业务支持的部门 =&amp;gt; 一个花钱的成本中心&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;问题原因在于IT信息部门的人员不懂业务 =&amp;gt; 这里的懂业务是指“&lt;span&gt;&lt;strong&gt;能对业务的下一步发展有着自己的理解和看法&lt;/strong&gt;&lt;/span&gt;，对业务流程如何进一步优化能更好的地提升业务，甚至对企业现有的业务提出创新的想法，为企业带来新的业务增长点。”&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;问题结果导致了IT信息部门的人员很少能在一个业务领域做足够的业务沉淀 =&amp;gt; 对业务知其然而不知其所以然&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190424085452971-664559800.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;“烟囱式”的系统建设模式&lt;/p&gt;
&lt;h2&gt;Part 2 构建业务中台的基础—共享服务体系&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;SOA架构的核心价值
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;服务重用&lt;/strong&gt; &lt;span&gt;=&amp;gt; 从服务重用到共享服务&lt;/span&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;共享服务体系的建设：克服“烟囱式”架构的三大弊端
&lt;ul&gt;&lt;li&gt;避免重复功能建设和维护带来的成本浪费 =&amp;gt; 没有实现系统业务互通的诉求&lt;/li&gt;
&lt;li&gt;最大程度避免打通不同系统间实现业务交互带来的集成和协作成本 =&amp;gt; 各个应用在核心业务层已经实现了统一和畅通&lt;/li&gt;
&lt;li&gt;能够很好地培养出特定领域的专家 =&amp;gt; “&lt;span&gt;&lt;strong&gt;既精通业务，又熟悉技术&lt;/strong&gt;&lt;/span&gt;”的复合型人才&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;企业信息中心组织阵型的调整
&lt;ul&gt;&lt;li&gt;针对共享服务体系重新组织人员，使成员有机会成为业务领域的专家（复合型人才）&lt;/li&gt;
&lt;li&gt;最核心的角色是架构师，他们会是各服务中心的业务负责人&lt;/li&gt;
&lt;li&gt;信息团队会从“业务支持”的组织职能转向&lt;span&gt;&lt;strong&gt;基于企业核心业务和数据进行运营的团队&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190424091920197-938150062.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;阿里巴巴的“大中台”体系建设&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;在阅读这一部分时，个人最大的感触就在于企业信息中心的境遇，我所在的公司是一个传统行业，我们部门是从2018年末开始扩建的信息中心，和广大企业信息中心一样，虽然无一不被认可信息部门对企业发展的重要地位，行政级别也和核心业务部门的级别相当，但是实际情况却是没有同样平等的话语权，因为在高层领导的眼里就只是单纯把信息中心定位为了业务支持部门，是一个花钱的成本中心。而造成这样处境的原因，也很赞同钟华老师在书中的观点，那就是信息部门的员工不懂业务，这里的不懂业务是指&lt;strong&gt;能对业务的下一步发展有着自己的理解和看法&lt;/strong&gt;，对业务流程如何进一步优化能更好的地提升业务，甚至对企业现有的业务提出创新的想法，为企业带来新的业务增长点。而要提高信息部门的员工对于业务的精进，需要建设类似阿里巴巴的共享服务中心，服务需要不断的业务滋养才能足够强大地支持前线的士兵，也只有在滋养中才能从最初提供单薄业务功能的服务组件成长为企业最为宝贵的IT资产。正如钟华老师所示，未来在整个社会进入开放共享的时代，企业最大的价值将会是基于核心业务和数据进行对外开放的运营，到那时信息部门的共享服务体系将成为企业最为宝贵的资产。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;Part 3 分布式服务框架的选择&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;“中心化”与“去中心化”服务框架的对比
&lt;ul&gt;&lt;li&gt;服务调用方式的不同带来业务的响应和扩展成本：基于ESB的响应速度慢（因为网络开销大一倍），而要扩展ESB需要承担软硬件的不小投入（比如巨大的授权费）&lt;/li&gt;
&lt;li&gt;“&lt;strong&gt;雪崩&lt;/strong&gt;”效应束缚了“中心化”服务框架的扩展能力：不适合互联网企业的根本原因，因为一旦雪崩故障恢复的时间和成本都非常高昂！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;阿里巴巴的分布式服务框架HSF
&lt;ul&gt;&lt;li&gt;组成部分：服务提供者、服务调用者、地址服务器（Nginx）、配置服务器（服务注册&amp;amp;发现）、Diamond服务器（类似于Zookeeper）&lt;/li&gt;
&lt;li&gt;工作原理：服务节点对配置服务器列表的获取、服务的注册发布、服务的订阅、服务规则的推送（如果需要）、服务交互&lt;/li&gt;
&lt;li&gt;核心能力：Netty+Hession数据序列化协议实现服务交互（大并发量下的高性能）、容错机制（长连接+秒级感知）、线性扩展（增加服务实例即可扩展服务能力）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;关于微服务
&lt;ul&gt;&lt;li&gt;阿里巴巴2009年开始的共享服务体系算得上是微服务实践的先驱&lt;/li&gt;
&lt;li&gt;从本质上说，&lt;strong&gt;微服务是SOA的一种演变后的形态，与SOA的方法和原则没有&lt;span&gt;本质&lt;/span&gt;上的差别&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;微服务与SOA的两点最鲜明差异在于：
&lt;ul&gt;&lt;li&gt;传统SOA架构基于“中心化”的ESB构建，而微服务采用的是系统提供服务的方式实现系统间的互通；&lt;/li&gt;
&lt;li&gt;传统SOA实施的方式是项目制，而微服务是以做产品的方式让服务在业务发展过程中快速演化；&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;概念一时爽，问题一堆堆：
&lt;ul&gt;&lt;li&gt;微服务化的应用架构的有效服务管控？&lt;/li&gt;
&lt;li&gt;分布式事务的难题？&lt;/li&gt;
&lt;li&gt;自动化运维和平台稳定性？&lt;/li&gt;
&lt;li&gt;微服务的服务设计？=&amp;gt; DDD&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;微服务不是“免费的午餐”，阿里巴巴2009年开始的共享服务体系建设历程算得上是微服务架构的建设过程。正如钟华老师所说，“罗马不是一天建成的”，企业如果要构建微服务架构体系，也是需要多一份耐心的，通过服务能力在业务发展过程中的不断沉淀，当业务的能力沉淀到一个阶段后，才能真正感受到微服务架构给企业的业务发展带来的长远价值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Part 4 共享服务中心建设原则&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;服务中心的三个特征
&lt;ul&gt;&lt;li&gt;服务中心是伴随业务不断发展的：不做过于超前的设计，也不做过于理想化的架构&lt;/li&gt;
&lt;li&gt;服务中心的服务形态多样化：接口、工具、数据...&lt;/li&gt;
&lt;li&gt;一个服务中心还可以进一步划分：单个服务模块、多个服务模块...&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;服务中心的划分原则
&lt;ul&gt;&lt;li&gt;更多靠的是架构设计经验总结，很难给出精确的量化指标&lt;/li&gt;
&lt;li&gt;一般来说会兼顾3个方面的需求：
&lt;ul&gt;&lt;li&gt;设计 =&amp;gt; 遵循面向对象的分析和设计方法论&lt;/li&gt;
&lt;li&gt;运营 =&amp;gt; 服务中心应该是一个完整额业务模型&lt;/li&gt;
&lt;li&gt;工程 =&amp;gt; 综合评估业务层对服务中心在DB、业务以及运营方面的需求和技术上需要的投入&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;实际中的一些基本原则：
&lt;ul&gt;&lt;li&gt;高内聚、低耦合原则&lt;/li&gt;
&lt;li&gt;数据完整性原则：特别强调大数据思维&lt;/li&gt;
&lt;li&gt;业务可运营性原则：服务中心是承载业务逻辑、沉淀业务数据、产生业务价值的业务单元&lt;/li&gt;
&lt;li&gt;渐进性的建设原则：小步快跑，服务化从简单开始！&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt; &lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;记得张逸老师在《领域驱动战略设计实践》课程中的开篇提到他向DDD大师Eric Evans提问“如何正确地识别限界上下文？”，结果Eric Evans思考了一会儿，严肃地回答了一句：“By experience！”。这是一个正确的废话，但好像又蛮有道理。对于共享服务中心的建设和划分来说，也同样如此，更多的是依靠架构设计经验的总结，作者也很难给出一些具体问题给出一个精确的量化指标。正如作者所说，架构本来就是一个追求平衡的艺术，不仅是设计原则上的平衡，还要在技术、成本、资源、性能、团队等各方面进行平衡，以最高效地解决主要问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Part 5 数据拆分实现数据库能力线性扩展&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;数据库分库分表的实践
&lt;ul&gt;&lt;li&gt;阿里巴巴分布式数据层平台发展演变：Cobar(2006) =&amp;gt; TDDL(2008) =&amp;gt; DRDS(2014)&lt;/li&gt;
&lt;li&gt;数据尽可能平均拆分：需要结合业务数据的结构和业务场景来决定&lt;/li&gt;
&lt;li&gt;尽量减少事务边界：“事务边界”指单个SQL语句在后端数据库上同时执行的数量&lt;/li&gt;
&lt;li&gt;异构索引表尽量降低全表扫描频率：“拿空间换时间”，阿里巴巴的精卫填海产品&lt;/li&gt;
&lt;li&gt;将多条件频繁查询引入搜索引擎平台：采用专业搜索引擎平台提供搜索服务，Lucene、Solr、ElasticSearch&lt;/li&gt;
&lt;li&gt;简单就是美：“数据尽可能平均拆分”作为第一优先考虑，82法则&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;阿里巴巴的分布式数据层平台发展的演变可谓是一部技术驱动变革的历程，经历了一个又一个的技术难题，出现了一个又一个的开源/商用产品，提高了阿里巴巴的效率。印象深刻的地方在于，我们都有一个印象就是在数据库开发和调用时，要充分利用索引，避免全表扫描。但是，作者说到在真实的业务场景中很难完全避免全表扫描，比如对于订单进行复杂的分布式条件检索的时候，就会需要采用全表扫描，将查询语句同时推送到后端的数据库中才能实现该场景。但是，因为调用量不会很频繁，而且计算的数据量并不大，所以整体上不会给DB产生太大的影响。另外一个点就是，从系统风险的角度来看，以82法则，在实际中，作者建议仅对那些在80%情况下访问的那20%的场景进行如数据异构索引这样的处理，达到这类场景的性能最优化，而对于其他80%偶尔出现跨库join、全表扫描的场景，采取最为简单直接的方式往往就是最有效的方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Part 6 异步与缓存原则&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;异步化
&lt;ul&gt;&lt;li&gt;业务流程异步化：服务异步调用，提升大量远程服务线性调用带来的性能问题&lt;/li&gt;
&lt;li&gt;数据库事务异步化：将大事务拆分成小事务，提升吞吐量和事务操作的响应时间
&lt;ul&gt;&lt;li&gt;事务 =&amp;gt; 核心是ACID&lt;/li&gt;
&lt;li&gt;柔性事务 =&amp;gt; 基础是CAP理论和BASE理论，因为互联网应用最核心的需求是高可用（BASE中的BA）
&lt;ul&gt;&lt;li&gt;解决分布式问题的机制：①日志和补偿机制、②可靠的消息传递、③无锁实现（避免事务回滚、辅助业务变化明细表、乐观锁等）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ACID与BASE一般在系统中会结合使用，追求最终一致性&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缓存
&lt;ul&gt;&lt;li&gt;小库存商品秒杀典型架构
&lt;ul&gt;&lt;li&gt;核心问题：处理好商品的库存的扣减，不出现超卖的情况&lt;/li&gt;
&lt;li&gt;核心方案：
&lt;ul&gt;&lt;li&gt;缓存商品的详细信息（包括库存），不直接访问后端数据库&lt;/li&gt;
&lt;li&gt;商品库存使用乐观锁，避免出现超卖&lt;/li&gt;
&lt;li&gt;商品库存控制业务流，只在下单环节才对数据库访问，降低数据库访问频率&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;大库存商品大促架构
&lt;ul&gt;&lt;li&gt;核心问题：处理好库存更新的准确与用户等待时间的平衡&lt;/li&gt;
&lt;li&gt;核心方案：
&lt;ul&gt;&lt;li&gt;将缓存提升到为库存操作提供事务支持的角色 =&amp;gt; 将订单交易创建环节在缓存服务器中运行，提高响应速度&lt;/li&gt;
&lt;li&gt;借助消息队列实现缓存服务器中的库存修改线性处理&lt;/li&gt;
&lt;li&gt;缓存服务故障时通过缓存数据和数据库订单信息还原订单处理的最新状态&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;异步化与缓存两个技术都和我们的系统性能有很大的关联，在分布式应用架构中，如果没有这两项技术的引入，相信设计出来的应用很难有优质的性能表现。淘宝平台是一个典型的分布式服务架构，通过业务流程异步化提升了性能，分库分表后又在异步操作场景下实现了事务一致性与数据库处理性能的平衡。最后，通过适当使用缓存技术实现了商品秒杀场景下的技术架构，这都是我们需要学习和借鉴的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201905/381412-20190514232428556-22457319.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;小库存商品秒杀场景订单处理流程图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201905/381412-20190514232543058-1625306272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;大库存商品秒杀场景订单处理流程图&lt;/p&gt;
&lt;h2&gt;Part 7 打造数字化运营能力&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;业务服务化带来的问题&lt;br/&gt;&lt;ul&gt;&lt;li&gt;服务调用关系纷繁复杂，难以定位问题&lt;/li&gt;
&lt;li&gt;不同角色的技术人员需要一些列的管控&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;分布式服务调用链路平台
&lt;ul&gt;&lt;li&gt;阿里巴巴内部实现：“鹰眼”平台，JStorm流式计算引擎&lt;/li&gt;
&lt;li&gt;核心思路：埋点和输出日志&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;海量日志分布式处理平台
&lt;ul&gt;&lt;li&gt;阿里巴巴内部实现：TLog平台，日志处理流程“所见即所得”&lt;/li&gt;
&lt;li&gt;日志收集控制：遇到大量请求时只记录其中一部分数据，而非全量收集&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;实现初步的分布式服务体系之后，我们的平台必然会变成一个比较复杂的交互链路网，这会对我们的管控带来一些问题，比如服务调用链监控、服务运行状态是否正常，如何提供关键指标以实现精准营销等等。好在无论是商用产品还是开源产品，都有了比较成熟的技术方案，我司已经在调研学习Skywalking和ElasticSearch，以后有机会做这方面的分享。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;　　&lt;strong&gt;在此推荐一波Skywalking：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/savorboard/p/asp-net-core-skywalking.html&quot;&gt;在 ASP.NET Core 中集成 Skywalking APM&lt;/a&gt; （from savorboard 杨晓东）&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/liuhaoyang/p/skywalking-dotnet-v02-release.html&quot; target=&quot;_blank&quot;&gt;Apache SkyWalking 为.NET Core带来开箱即用的分布式追踪和应用性能监控&lt;/a&gt; （from Lemon 刘浩杨）&lt;/p&gt;
&lt;p&gt;　　&lt;a href=&quot;https://www.cnblogs.com/huangxincheng/p/9666930.html&quot;&gt;使用docker-compose 一键部署你的分布式调用链跟踪框架Skywalking&lt;/a&gt; （from 一线码农 黄星辰）&lt;/p&gt;
&lt;p&gt;　　&lt;em&gt;更多Skywalking分享&lt;/em&gt;：&lt;a href=&quot;https://github.com/OpenSkywalking/Community&quot; target=&quot;_blank&quot;&gt;https://github.com/OpenSkywalking/Community&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/575322/201805/575322-20180523224851712-869373885.png&quot; alt=&quot;Skywalking Demo&quot; width=&quot;2876&quot; height=&quot;1518&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Skywalking中的请求调用链拓扑视图&lt;/p&gt;
&lt;h2&gt;Part 8 打造平台稳定性能力&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;提高稳定性的实践&lt;br/&gt;&lt;ul&gt;&lt;li&gt;限流和降级：限流相当于电路保险丝，而降级则是为保证核心服务而牺牲自己，阿里巴巴自研Sentinel限流平台&lt;/li&gt;
&lt;li&gt;流量调度：通过实时指标监控，对预计发生故障的服务进行下线等操作，以避免单点或局部故障&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;业务开关：通过集中化管理业务API操作开关，阿里巴巴自研Switch平台&lt;/li&gt;
&lt;li&gt;容量压测及评估规划：将线上真实流量引到压测服务器，并差异化分析对线上服务器的增减提供实时参考决策&lt;/li&gt;
&lt;li&gt;全链路压测：每个环节都参加的实战演习，例如双11实战演习&lt;/li&gt;
&lt;li&gt;业务一致性平台：保证业务与数据一致的业务稳定性，实时检测业务不一致的问题，阿里巴巴自研BCR业务审计平台&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　＃Sential Github: &lt;a href=&quot;https://github.com/alibaba/Sentinel&quot; target=&quot;_blank&quot;&gt;https://github.com/alibaba/Sentinel&lt;/a&gt; （轻量级的流量控制、熔断降级 Java 库）&lt;/p&gt;
&lt;p&gt;　　＃Sential Wiki：&lt;a href=&quot;https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D&quot; target=&quot;_blank&quot;&gt;分布式系统的流量防卫兵&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201905/381412-20190515090730327-638148100.png&quot; alt=&quot;Sential Main Features&quot; width=&quot;1470&quot; height=&quot;686&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Sentinel 的主要特性&lt;/p&gt;
&lt;h2&gt;Part 9 共享服务中心对内和对外的协作共享&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;共享服务平台的建设思路
&lt;ul&gt;&lt;li&gt;Step1.找到一个合适的服务化对象：比如API&lt;/li&gt;
&lt;li&gt;Step2.建设对象服务化的基础设施：比如结构化包装，让API成为治理良好的组件服务&lt;/li&gt;
&lt;li&gt;Step3.服务化实施阶段：循序渐进的过程，三个阶段参考
&lt;ul&gt;&lt;li&gt;API as Service =&amp;gt; 服务化的第一步&lt;/li&gt;
&lt;li&gt;Product as Service =&amp;gt; 大量业务API升级为服务化平台的组件服务&lt;/li&gt;
&lt;li&gt;Solution as Service =&amp;gt; 经过长时间的沉淀可以形成解决方案，如海外淘宝解决方案&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Step4.增强服务和基础设施实现服务的精细治理&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对内：共享服务平台的协作
&lt;ul&gt;&lt;li&gt;与业务方的协作：以服务为对象建立一个在线市场，三大角色
&lt;ul&gt;&lt;li&gt;共享服务平台 =&amp;gt; SPAS&lt;/li&gt;
&lt;li&gt;服务提供者 =&amp;gt; 商品、交易、店铺、物流等&lt;/li&gt;
&lt;li&gt;服务消费者 =&amp;gt; 商品、交易、店铺、物流等 （消费者通常也是提供者）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;与前端应用协作：服务提供者与消费者，相辅相成，共同发展
&lt;ul&gt;&lt;li&gt;阿里巴巴的一些实践：紧密沟通，分歧升级、岗位轮转（换位思考）、业务沉淀及共建&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对内：业务中台绩效考核
&lt;ul&gt;&lt;li&gt;No.1 服务的稳定：比如一年只允许两次P1故障&lt;/li&gt;
&lt;li&gt;No.2 持续业务创新：鼓励业务中台运营团队业务创新，包容业务创新引起的故障&lt;/li&gt;
&lt;li&gt;No.3 服务接入量：考量服务能力的专业度以及对外的服务运营能力&lt;/li&gt;
&lt;li&gt;No.4 客户满意度：对中台服务运营团队起到督促作用&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;对外：开放能力构建生态
&lt;ul&gt;&lt;li&gt;核心内容：&lt;span&gt;&lt;strong&gt;将自身平台中的数据以服务的方式对外进行开放，从而吸引众多外部群体基于这些服务提供增值服务，持续地为客户提供优质的运营平台能力，从而最终构建基于开放平台的生态体系。&lt;/strong&gt;&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;在这部分内容里边，印象最深刻的还是作者提到在互联网转型时，很多人想要构建生态，但却没搞清楚“生态”和“上下游”的关系，它们之间的最本质的区别在于：在“上下游”模式中整个体系中所有的参与者都是被动的使用者，而“生态”模式中的参与者确是主动使用者，他们会持续地往整个体系中注入自己的智慧和创新的源泉，不断贡献自己的价值，只有这样的模式才能打造出企业所希望的生态效果。而传统企业现在应该着眼于企业内部的核心业务能力的打造，等到有一天需要通过能力开放的方式拓展企业业务边界或构建生态的时候，这些沉淀的服务会是企业最大的资产，而信息中心部门也不会只是一个成本中心，而有可能变为对外进行能力输出的关键运营部门。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2&gt;Part 10 大型央企互联网转型&lt;/h2&gt;
&lt;p&gt;　　阿里巴巴协助国内某大型央企在90天构建出了一个B2B电商平台，整体平台架构基于阿里巴巴的共享服务理念和阿里云飞天Aliware的一系列产品，现在已经成为了国有大型企业进行互联网业务成功转型的标杆性项目。&lt;/p&gt;
&lt;h2&gt;Part 11时尚行业品牌公司互联网转型&lt;/h2&gt;
&lt;p&gt;　　某服装品牌民营企业基于阿里巴巴的共享服务架构完成了企业全渠道分销平台的重构，解决了高库存和高流单率的难题，实现了O2O的融合，建立了以客户体验为中心的系统架构，为企业在同行业的竞争中建立了差异化的竞争能力。&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;PS：&lt;/strong&gt;&lt;/em&gt;2014年开始，国家就开始倡导“互联网+”的转型，越来越多的传统企业加入到互联网转型的浪潮，像我司一样的传统家居企业也开始了转型，于是开始建设信息中心，于是我就来了... 幸运的是，我司已经在成都地区小有名气，并且是一个知名的品牌，接下来要做的，借用作者的原话就是需要我们信息中心能够更好地使用互联网技术、利用互联网服务、借鉴互联网企业的运营模式，更好地实现价值链中各节点的连接，让流程更加透明，业务更加可视，最终能够挖掘企业的瓶颈，更好地满足消费者的需求，以获得更好的成长。对我个人而言，在此期间能够积累和沉淀更多的经验是最重要的，加油！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/381412/201904/381412-20190420153730536-341629828.jpg&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;p&gt;钟华，《企业IT架构转型之道-阿里巴巴中台战略思想与架构实战》&lt;/p&gt;
&lt;p&gt;James，《给架构师的推荐-企业IT架构转型之道》&lt;/p&gt;
&lt;p&gt;马崇，《企业IT架构转型之道的思考》&lt;/p&gt;

&lt;div id=&quot;Copyright&quot; readability=&quot;8.2242990654206&quot;&gt;
&lt;p&gt;&lt;span&gt;作者：&lt;a title=&quot;author&quot; href=&quot;http://www.edisonchou.cn&quot; target=&quot;_blank&quot;&gt;周旭龙&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;出处：&lt;a title=&quot;from&quot; href=&quot;http://edisonchou.cnblogs.com&quot; target=&quot;_blank&quot;&gt;http://edisonchou.cnblogs.com&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Wed, 15 May 2019 14:42:00 +0000</pubDate>
<dc:creator>Edison Chou</dc:creator>
<og:description>此文是我阅读《企业IT架构转型之道》一书的学习笔记，所有内容出自钟华老师的这本书。 零、为何读《企业IT架构转型之道》 在加入X公司后，开始了微服务架构的实践，也开始了共享平台服务的建设，在这方面阿里</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/edisonchou/p/alibaba_it_architect_tranformation_study_notes.html</dc:identifier>
</item>
<item>
<title>WebGL three.js学习笔记 6种类型的纹理介绍及应用 - nsytsqdtn</title>
<link>http://www.cnblogs.com/nsytsqdtn/p/10872682.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nsytsqdtn/p/10872682.html</guid>
<description>&lt;h2 id=&quot;webgl-three.js学习笔记-6种类型的纹理介绍及应用&quot;&gt;WebGL three.js学习笔记 6种类型的纹理介绍及应用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;本文所使用到的demo演示：&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;反光效果demo演示因为是加载的模型所以速度会慢&quot;&gt;&lt;a href=&quot;https://nsytsqdtn.github.io/demo/environment_map/environment_map.html&quot;&gt;反光效果Demo演示&lt;/a&gt;（因为是加载的模型，所以速度会慢）&lt;/h2&gt;
&lt;h2 id=&quot;一普通纹理&quot;&gt;（一）普通纹理&lt;/h2&gt;
&lt;p&gt;计算机图形学中的纹理既包括通常意义上物体表面的纹理即使物体表面呈现凹凸不平的沟纹，同时也包括在物体的光滑表面上的彩色图案，所谓的纹理映射就是在物体的表面上绘制彩色的图案。&lt;/p&gt;
&lt;p&gt;在three.js中使用纹理可以实现很多不同的效果，但是最基本的就是为网格体的每个像素指定颜色。等同于将一张纹理图片应用在一个几何体的材质上。&lt;/p&gt;
&lt;p&gt;使用的方式很简单，只需要设置&lt;br/&gt;&lt;strong&gt;material.map = 需要设置的纹理对象&lt;/strong&gt;&lt;br/&gt;纹理对象的获得方式也很简单,只需要使用THREE.TextureLoader().load(url)函数就可以为url指定路径的纹理图片创建一个对象。具体的使用方式如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let texture = new THREE.TextureLoader().load(&quot;../../../Image/metal-rust.jpg&quot;);
        let material = new THREE.MeshBasicMaterial();
        material.map = texture;
        let geometry = new THREE.BoxGeometry(10,10,10);
        let cube = new THREE.Mesh(geometry,material);
        scene.add(cube);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中，&quot;../../../Image/metal-rust.jpg&quot;是我使用的纹理的路径,图片就是下面这一张&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190514221053811.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;纹理贴图1&quot;/&gt;&lt;br/&gt;创建出来的带有上图纹理的cube就是这样的&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190514220845261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;普通纹理&quot;/&gt;&lt;br/&gt;&lt;strong&gt;除了THREE.TextureLoader()这个加载器以为，three.js还为我们提供了其他自定义的加载器，如dds格式，pvr格式，tga格式。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;就拿tga格式举例，我们要加载tga格式的纹理，首先需要引用TGALoader.js这个文件，然后创建一个tga格式的加载器&lt;br/&gt;&lt;strong&gt;let loader = new THREE.TGALoader();&lt;/strong&gt;&lt;br/&gt;我们就可以使用loader这个加载器，像上面一样的加载tga格式的纹理了。&lt;br/&gt;具体代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let loader = new THREE.TGALoader();
        let texture = loader.load(&quot;../../../Image/crate_color8.tga&quot;);
        let material = new THREE.MeshBasicMaterial();
        material.map = texture;
        let geometry = new THREE.BoxGeometry(10,10,10);
        let cube = new THREE.Mesh(geometry,material);
        scene.add(cube);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面是我使用的tga格式的纹理图片（只能上传截图，tga格式图片的这里上传不了）&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190514222014706.png&quot; alt=&quot;tga纹理图片&quot;/&gt;&lt;br/&gt;运行出来是这个样子的&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019051422204536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;tga纹理&quot;/&gt;&lt;br/&gt;&lt;strong&gt;其他格式的加载也是和tga格式加载方法一样的，只需要引入相应的js文件就可以使用了。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;二凹凸贴图&quot;&gt;（二）凹凸贴图&lt;/h2&gt;
&lt;p&gt;凹凸纹理用于为材质添加厚度与深度，如字面意思一样，可以让材质看上去是凹凸不平的。凹凸贴图只包含像素的相对高度，像素的密集程度定义凹凸的高度，所以想要让物体好看，首先还是应该设置一个普通的纹理，再在这个基础上添加一个凹凸纹理，就可以实现凹凸不平的物体效果。&lt;br/&gt;凹凸贴图的创建方法很简单，和普通纹理类似，只是我们设置的不是map，而是bumpMap&lt;br/&gt;&lt;strong&gt;material.bumpMap = 需要设置的纹理对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特别需要注意的是，这里的材质只能使用MeshPhongMaterial，凹凸贴图才会有效果。&lt;/strong&gt;&lt;br/&gt;具体的设置方法如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let geom = new THREE.BoxGeometry(10, 10, 10);
        
        //创建普通纹理材质
        let texture = new THREE.TextureLoader().load(&quot;../../../Image/stone.jpg&quot;);
        let material = new THREE.MeshPhongMaterial({
            map:texture
        });
        cube = new THREE.Mesh(geom,material);
        cube.position.set(-7,0,0);
        scene.add(cube);

        //创建凹凸纹理材质
        let bumpTexture = new THREE.TextureLoader().load(&quot;../../../Image/stone-bump.jpg&quot;);
        let bumpMaterial = new THREE.MeshPhongMaterial({
            map:texture,
            bumpMap:bumpTexture,
            bumpScale:2
        });
        bumpCube = new THREE.Mesh(geom,bumpMaterial);
        bumpCube.position.set(7,0,0);
        scene.add(bumpCube);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其中material.bumpScale可以设置凹凸的高度，如果为负值，则表示的是深度。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;运行程序截图如下：&lt;br/&gt;左边材质的是普通的纹理贴图，右边的材质是带有凹凸纹理的，当前bumpScale设置的是2，两者看上去有比较明显的不同&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515123400191.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;凹凸纹理&quot;/&gt;&lt;br/&gt;使用的纹理图片如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190514224028694.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;纹理2&quot;/&gt;&lt;br/&gt;凹凸纹理图片：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190514224059660.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;凹凸纹理&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们可以发现，凹凸图只包含了像素的相对高度，没有任何的倾斜的方向信息，所以使用凹凸纹理能表达的深度信息有限，如果想用实现更多的细节可以使用下面介绍的法向贴图。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;三法向贴图&quot;&gt;(三）法向贴图&lt;/h2&gt;
&lt;p&gt;法向贴图保存的不是高度的信息，而是法向量的信息，我们使用法向贴图，只需要很少的顶点和面就可以实现很丰富的细节。&lt;br/&gt;同样的，实现法向贴图和凹凸贴图也很类似，只需要设置&lt;br/&gt;&lt;strong&gt;material.normalMap = 需要设置的纹理对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同样也是在MeshPhongMaterial材质中才有效果，还要注意的一点是设置normalScale指定材质的凹凸程度时，normalScale需要接受的是一个THREE.Vector2类型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体的代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let geom = new THREE.BoxGeometry(10, 10, 10);

        //创建普通纹理材质
        let texture = new THREE.TextureLoader().load(&quot;../../../Image/plaster.jpg&quot;);
        let material = new THREE.MeshPhongMaterial({
            map:texture
        });
        cube = new THREE.Mesh(geom,material);
        cube.position.set(-7,0,0);
        scene.add(cube);

        //创建凹凸纹理材质
        let normalTexture = new THREE.TextureLoader().load(&quot;../../../Image/plaster-normal.jpg&quot;);
        let normalMaterial = new THREE.MeshPhongMaterial({
            map:texture,
            normalMap:normalTexture,
            normalScale:new THREE.Vector2(1,1)
        });
        normalCube = new THREE.Mesh(geom,normalMaterial);
        normalCube.position.set(7,0,0);
        scene.add(normalCube);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;场景如下图，右边的是带有法向纹理的物体，明显感觉出材质的细节多出来了很多。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515171128156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;法向贴图&quot;/&gt;&lt;br/&gt;用到的纹理图&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515181055978.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;plaster&quot;/&gt;&lt;br/&gt;法向纹理图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515181118536.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;plaster-normal&quot;/&gt;&lt;br/&gt;虽然法向纹理能带给物体更逼真的效果，但是想要创建法向纹理图，本身就比较困难，需要ps或者blender这样的特殊工具。&lt;/p&gt;
&lt;h2 id=&quot;四光照贴图&quot;&gt;(四）光照贴图&lt;/h2&gt;
&lt;p&gt;如果我们想在场景中添加阴影，three.js给我们提供了renderer.shadowMapEnabled = true这个办法，但是这对于资源的消耗是很大的。如果我们只是需要对静态的物体添加阴影效果，我们就有一种开销很小的办法，那就是光照贴图。&lt;br/&gt;光照贴图是预先渲染好的阴影贴图，可以用来模拟真实的阴影。我们能使用这种技术创建出分辨率很高的阴影，并且不会损耗渲染的性能。因为是提前根据场景渲染好的，所以只对静态的场景有效。&lt;/p&gt;
&lt;p&gt;比如下面这张光照贴图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019051519065692.png&quot; alt=&quot;光照贴图&quot;/&gt;&lt;br/&gt;设置光照贴图的方式很简单，只需要设置&lt;br/&gt;&lt;strong&gt;material.lightMap = 需要设置的纹理对象&lt;/strong&gt;&lt;br/&gt;和前面两个没什么太大的区别。当纹理设置好以后，我们还需要把我们的物体摆放在正确的位置，这样阴影效果才会真实的显现出来。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let lightMap = new THREE.TextureLoader().load(&quot;../../../Image/lm-1.png&quot;);
        let map =  new THREE.TextureLoader().load(&quot;../../../Image/floor-wood.jpg&quot;);
        //创建地板
        let planeGeo = new THREE.PlaneGeometry(95,95,1,1);
        planeGeo.faceVertexUvs[1] = planeGeo.faceVertexUvs[0];
        let planeMat = new THREE.MeshBasicMaterial({
            color:0x999999,
            lightMap:lightMap,//在地板的材质上添加光照贴图
            map:map//地板的普通纹理材质
        });
        let plane = new THREE.Mesh(planeGeo,planeMat);
        plane.rotation.x = -Math.PI / 2;
        plane.position.y = 0;
        scene.add(plane);

        //创建大的cube
        var boxGeo = new THREE.BoxGeometry(12,12,12);
        var material = new THREE.MeshBasicMaterial();
        material.map = new THREE.TextureLoader().load(&quot;../../../Image/stone.jpg&quot;);
        var box = new THREE.Mesh(boxGeo,material);
        box.position.set(0.9,6,-12);
        scene.add(box);

        //创建小的cube
        var boxGeo = new THREE.BoxGeometry(6, 6, 6);
        var material = new THREE.MeshBasicMaterial();
        material.map = new THREE.TextureLoader().load(&quot;../../../Image/stone.jpg&quot;);
        var box = new THREE.Mesh(boxGeo,material);
        box.position.set(-13.2, 3, -6);
        scene.add(box);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;其中，planeGeo.faceVertexUvs[1] = planeGeo.faceVertexUvs[0] 这句话是我们需要明确的指定光照贴图的uv映射（将纹理的哪一部分应用在物体表面）这样才能将光照贴图的使用和其他的纹理分别开来。&lt;/strong&gt;&lt;br/&gt;planeGeo.faceVertexUvs保存的就是几何体面的uv映射信息，我们将faceVertexUvs[0]层的信息保存到faceVertexUvs[1]层&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;faceVertexUvs的官方文档解释：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;.faceVertexUvs : Array&lt;br/&gt;Array of face UV layers, used for mapping&lt;br/&gt;textures onto the geometry. Each UV layer is an array of UVs matching&lt;br/&gt;the order and number of vertices in faces.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;运行结果如图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515195606842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;光照贴图&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;五高光贴图&quot;&gt;(五）高光贴图&lt;/h2&gt;
&lt;p&gt;高光是光源照射到物体然后反射到人的眼睛里时,物体上最亮的那个点就是高光，高光不是光,而是物体上最亮的部分。&lt;br/&gt;而高光贴图就是高光贴图是反应光线照射在物体表面的高光区域时所产生的环境反射，它的作用是反映物体高光区域效果。&lt;/p&gt;
&lt;p&gt;通过高光贴图，我们可以为材质创建一个闪亮的、色彩明快的贴图。高光贴图的黑色部分会暗淡，而白色的部分会比较的亮。&lt;br/&gt;创建高光贴图的方法也和前面差不多&lt;br/&gt;&lt;strong&gt;material.specularMap= 需要设置的纹理对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;具体的代码如下:&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let map = new THREE.TextureLoader().load(&quot;../../../Image/Earth.png&quot;);
        let specularMap = new THREE.TextureLoader().load(&quot;../../../Image/EarthSpec.png&quot;);
        let normalMap = new THREE.TextureLoader().load(&quot;../../../Image/EarthNormal.png&quot;);
        let sphereMaterial = new THREE.MeshPhongMaterial({
            map:map,
            specularMap:specularMap,
            normalMap:normalMap,
            normalScale:THREE.Vector2(2,2),
            specular:0x0000ff,
            shininess:2
        });
        let sphereGeometry = new THREE.SphereGeometry(30,30,30);
        let sphere = new THREE.Mesh(sphereGeometry,sphereMaterial);
        scene.add(sphere);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码创建了一个球体，并为球体的材质贴上了普通纹理，法向纹理和高光纹理，其中specular属性可以决定反光的颜色，shininess可以决定发光的亮度。&lt;/p&gt;
&lt;p&gt;运行出来的样子如下：&lt;br/&gt;可以看到，海洋的地方比较亮，而大陆的的颜色相对较暗。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515203936321.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;高光贴图&quot;/&gt;&lt;/p&gt;

&lt;p&gt;用到的几张纹理图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515202513560.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;纹理&quot;/&gt;&lt;br/&gt;高光纹理：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515202532285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;高光纹理&quot;/&gt;&lt;br/&gt;法向纹理：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515202548765.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;法向纹理&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六环境贴图&quot;&gt;(六）环境贴图&lt;/h2&gt;
&lt;p&gt;如果我们想要在场景中创建反光的物体，通常会使用光线追踪的算法，但是这对cpu的消耗是巨大的，但是环境贴图就给我们创造了更容易的方法，我们只需要使用给物体的材质贴上环境贴图，就可以模拟反光的效果。&lt;/p&gt;
&lt;p&gt;首先我们的场景需要有一个环境，这个环境我们可以使用CubeTextureLoader()来创建。在前面的文章里曾经介绍过如何创建360度全景的环境，这个CubeTextureLoader()和那里面用到的其实是一样的，只是版本的更替，现在更多使用这个函数。&lt;br/&gt;具体用法是：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let cubeMap = new THREE.CubeTextureLoader().setPath(
        &quot;../../../Image/MapCube/Bridge2/&quot;).load(
            [
                'posx.jpg',
                'negx.jpg',
                'posy.jpg',
                'negy.jpg',
                'posz.jpg',
                'negz.jpg'
            ]);
        scene = new THREE.Scene();
        scene.background = cubeMap;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在前面的文章已经介绍过，这里就不再赘述。&lt;br/&gt;创建cubeMap所用到的图片在http://www.humus.name/index.php?page=Textures可以直接下载。&lt;/p&gt;
&lt;p&gt;我们有了一个可以反射的环境以后，就可以开始为我们的物体创建材质贴图了。&lt;br/&gt;创建材质贴图的方式和前面还是差不多&lt;br/&gt;&lt;strong&gt;material.envMap = scene.background;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;scene.background就是我们刚刚所创建的场景的背景，这样材质的环境贴图就相当于贴上了周围环境，从摄像机去看物体的话，看上去就是对环境有一个反射的效果了。&lt;/p&gt;
&lt;p&gt;创建的代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;       function initObject()
       {
       let material = new THREE.MeshPhongMaterial();
       material.envMap = scene.background;
       let boxGeometry = new THREE.BoxGeometry(5,50,50);
       let box = new THREE.Mesh(boxGeometry,material);
       box.position.set(-70,0,-10);
       box.rotation.y-=Math.PI/2;
       scene.add(box);
       let sphereGeometry = new THREE.SphereGeometry(30,30,30);
       let sphere = new THREE.Mesh(sphereGeometry,material);
       sphere.position.set(70,0,-10);
       scene.add(sphere);
       }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;和前面的代码没有太大的区别，这里主要是创建了两个物体，都使用的相同环境贴图的材质。&lt;/p&gt;
&lt;p&gt;运行的结果：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515220613202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;环境贴图&quot;/&gt;&lt;br/&gt;可以看到，这两个物体都对环境有反射的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;值得注意的是，我们使用环境贴图创建的材质仅仅静态的环境贴图。我们只能看到物体上面有周围环境的反射，看不到物体对其他物体的反射。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果我们要看到物体对其他物体的反射，我们可以使用一个新的对象——cubeCamera&lt;/strong&gt;&lt;br/&gt;创建cubeCamera的方法很简单.&lt;br/&gt;&lt;strong&gt;let cubeCamera = new THREE.CubeCamera(0.1, 2000, 2048);&lt;br/&gt;scene.add(cubeCamera);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;其中：&lt;br/&gt;&lt;strong&gt;第一个参数0.1是相机的近裁剪距离&lt;br/&gt;第二个参数2000是相机远裁剪距离&lt;br/&gt;第三个参数2048是相机分辨率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用THREE.CubeCamera可以为场景中所要渲染的物体创建快照，并使用这些快照创建CubeMap对象。但是需要确保摄像机被放置在THREE.Mesh网格上你所想显示反射的位置上。例如，我们想在球体的中心显示反射，由于球体所处的位置是(0, 0, 0),所以我们没有显示的指定THREE.CubeCamera的位置。我们只是将动态反射应用于球体上，所以把它的envMap设置为cubeCamera.renderTarget&lt;br/&gt;&lt;strong&gt;即material.envMap = cubeCamera.renderTarget;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;简单来说，就是把我们所要显示反射的“镜子”的material.envMap设置为cubeCamera.renderTarget，同时还要把cubeCamera的位置设置到镜子的位置，cubeCamera.position.copy(镜子.position);&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;        let loader = new THREE.STLLoader();
        loader.load(&quot;../../../asset/LibertStatue.obj.stl&quot;,function (bufferGeometry)
        {
            let material = new THREE.MeshBasicMaterial();
            material.envMap=scene.background;
            obj = new THREE.Mesh(bufferGeometry,material);
            obj.scale.set(50,50,50);
            scene.add(obj);
        });//加载stl模型
       
        let cubeMaterial = new THREE.MeshPhongMaterial();
        cubeMaterial.envMap = cubeCamera.renderTarget;
        let boxGeometry = new THREE.BoxGeometry(3, 400, 400);
        let box = new THREE.Mesh(boxGeometry, cubeMaterial);
        box.position.set(0, 0, -300);
        box.rotation.y -= Math.PI / 2;
        scene.add(box);
        cubeCamera.position.copy(box.position);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这段代码中，我们从外部加载了一个stl格式的模型，也可以就使用简单的几何体来演示。下面的一部分代码就创建了可以反射的镜子。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;最后，我们还需要在render()中添加cubeCamera.update(renderer, scene)用cubeCamera进行渲染&lt;/strong&gt;&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;function render()
    {
        if(obj) obj.rotation.y+=0.02;
        cubeCamera.update(renderer, scene);
        stats.update();
        renderer.clear();
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行后的情况如下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190515222459959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25zeXRzcWR0bg==,size_16,color_FFFFFF,t_70&quot; alt=&quot;cubeCamera&quot;/&gt;&lt;br/&gt;我们可以看到我们加载的stl模型在我们创建的镜子中反射出来了，并且会根据模型的移动，镜子的反射也会自动变化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;以上就是介绍的全部类型的纹理。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;反光效果demo的完整代码&quot;&gt;反光效果demo的完整代码：&lt;/h2&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&quot;en&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
    &amp;lt;title&amp;gt;Environment Map&amp;lt;/title&amp;gt;
    &amp;lt;script src=&quot;../../../import/three.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;../../../import/stats.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;../../../import/Setting.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;../../../import/OrbitControls.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;script src=&quot;../../../import/STLLoader.js&quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;style type=&quot;text/css&quot;&amp;gt;
        body {
            border: none;
            cursor: pointer;
            width: 100%;
            height: 1000px;
            /*全屏显示的设置*/
            margin: 0;
            overflow: hidden; /*消除浏览器的滚动条*/

        }

        /*加载动画*/
        #loading {
            width: 100%;
            height: 850px;
            background-color: #333333;
        }

        #spinner {
            width: 100px;
            height: 100px;
            position: fixed;
            top: 50%;
            left: 50%;
        }

        .double-bounce1, .double-bounce2 {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background-color: #67CF22;
            opacity: 0.6;
            position: absolute;
            top: 0;
            left: 0;
            -webkit-animation: bounce 2.0s infinite ease-in-out;
            animation: bounce 2.0s infinite ease-in-out;
        }

        .double-bounce2 {
            -webkit-animation-delay: -1.0s;
            animation-delay: -1.0s;
        }

        @-webkit-keyframes bounce {
            0%, 100% {
                -webkit-transform: scale(0.0)
            }
            50% {
                -webkit-transform: scale(1.0)
            }
        }

        @keyframes bounce {
            0%, 100% {
                transform: scale(0.0);
                -webkit-transform: scale(0.0);
            }
            50% {
                transform: scale(1.0);
                -webkit-transform: scale(1.0);
            }
        }
    &amp;lt;/style&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body onload=&quot;Start()&quot;&amp;gt;
&amp;lt;!--加载动画的div--&amp;gt;
&amp;lt;div id=&quot;loading&quot;&amp;gt;
    &amp;lt;div id=&quot;spinner&quot;&amp;gt;
        &amp;lt;div class=&quot;double-bounce1&quot;&amp;gt;&amp;lt;/div&amp;gt;
        &amp;lt;div class=&quot;double-bounce2&quot;&amp;gt;&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;script&amp;gt;
    let camera, renderer, scene, cubeCamera, light;
    let controller;

    function initThree()
    {
        //渲染器初始化
        renderer = new THREE.WebGLRenderer({
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x333333);
        document.body.appendChild(renderer.domElement);//将渲染添加到body中
        //初始化摄像机，这里使用透视投影摄像机
        camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 10000);
        camera.position.set(20, 15, 200);
        camera.up.x = 0;//设置摄像机的上方向为哪个方向，这里定义摄像的上方为Y轴正方向
        camera.up.y = 1;
        camera.up.z = 0;
        camera.lookAt(0, 0, 0);

        let cubeMap = new THREE.CubeTextureLoader().setPath(&quot;../../../Image/MapCube/Bridge2/&quot;).load(
            [
                'posx.jpg',
                'negx.jpg',
                'posy.jpg',
                'negy.jpg',
                'posz.jpg',
                'negz.jpg'
            ]);
        scene = new THREE.Scene();
        scene.background = cubeMap;

        cubeCamera = new THREE.CubeCamera(0.1, 1000, 2048);
        scene.add(cubeCamera);
        //相机的移动
        controller = new THREE.OrbitControls(camera, renderer.domElement);
        controller.target = new THREE.Vector3(0, 0, 0);

        light = new THREE.AmbientLight(0xffffff);
        light.position.set(-50, -50, -50);
        scene.add(light);
    }
    
     let obj;
    function initObject()
    {
        let loader = new THREE.STLLoader();
        loader.load(&quot;../../../asset/LibertStatue.obj.stl&quot;,function (bufferGeometry)
        {
            let material = new THREE.MeshBasicMaterial();
            material.envMap=scene.background;
            obj = new THREE.Mesh(bufferGeometry,material);
            obj.scale.set(50,50,50);
            scene.add(obj);
            console.log(obj);
        });
        let cubeMaterial = new THREE.MeshPhongMaterial();
        cubeMaterial.envMap = cubeCamera.renderTarget;
        let boxGeometry = new THREE.BoxGeometry(3, 400, 400);
        let box = new THREE.Mesh(boxGeometry, cubeMaterial);
        box.position.set(0, 0, -300);
        box.rotation.y -= Math.PI / 2;
        scene.add(box);
        cubeCamera.position.copy(box.position);
        document.getElementById('loading').style.display = 'none';
    }
    //渲染函数
    function render()
    {
        if(obj) obj.rotation.y+=0.02;
        cubeCamera.update(renderer, scene);
        stats.update();
        renderer.clear();
        requestAnimationFrame(render);
        renderer.render(scene, camera);
    }

    //功能函数
    function setting()
    {
        loadFullScreen();
        loadAutoScreen(camera, renderer);
        loadStats();
    }

    //运行主函数
    function Start()
    {
        initThree();
        initObject();
        setting();
        render();
    }
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Wed, 15 May 2019 14:39:00 +0000</pubDate>
<dc:creator>nsytsqdtn</dc:creator>
<og:description>WebGL three.js学习笔记 6种类型的纹理介绍及应用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nsytsqdtn/p/10872682.html</dc:identifier>
</item>
<item>
<title>mysql数据库的索引 - 王森</title>
<link>http://www.cnblogs.com/wangsen/p/10864136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wangsen/p/10864136.html</guid>
<description>&lt;p&gt;索引是对数据库表中一列或多列的值【排好序】的数据结构。&lt;/p&gt;

&lt;p&gt;因为创建索引可以大大提高系统的查询性能。&lt;/p&gt;

&lt;p&gt;简单的理解：一张数据量比较大的表格如果没有添加任何索引，那我们在执行查询的时候&lt;br/&gt;就会是进行全表扫描，逐行比对，这样的读取效率肯定很低，如果我们为数据创建了索引&lt;br/&gt;索引的实现方式又是支持快速查询的这样我们只需要先查询索引中符合条件的，&lt;br/&gt;然后再通过索引指向的数据行位置就可以实现快速定位数据了，不用全表扫描了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514202705200-893647725.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据库索引是存储在磁盘上，当表中的数据量比较大时，索引的大小也跟着增长，达到几个G甚至更多。&lt;br/&gt;当我们利用索引进行查询的时候，不可能把索引全部加载到内存中，只能逐一加载每个磁盘页，这里的磁盘页就对应索引树的节点。&lt;/p&gt;

&lt;h2 id=&quot;哈希表&quot;&gt;哈希表&lt;/h2&gt;
&lt;p&gt;哈希表可能会出现哈希冲突。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514193333407-1719669551.png&quot;/&gt;&lt;br/&gt;最主要的原因是它不支持范围查询。&lt;/p&gt;
&lt;h2 id=&quot;完全平衡二叉树&quot;&gt;完全平衡二叉树&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514194148934-64409339.png&quot;/&gt;&lt;br/&gt;如图如果一个树的高度很大，如果查询的数据刚好在叶子节点那经历的磁盘Io的次数就是这个数的高度。&lt;br/&gt;所以极端情况下平衡二叉树也不是优选。&lt;/p&gt;
&lt;h2 id=&quot;b-tree&quot;&gt;B-Tree&lt;/h2&gt;
&lt;p&gt;先说说几个概念：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;度（节点的数据存储个数）也就是说B-Tree上的一个节点可以存储多个数据。&lt;/li&gt;
&lt;li&gt;叶节点具有相同的深度&lt;/li&gt;
&lt;li&gt;叶节点的指针为空&lt;/li&gt;
&lt;li&gt;节点中的数据从左到右递增排列&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514201732286-701828340.png&quot;/&gt;&lt;br/&gt;这的确解决了树的高度问题，因为：B-Tree的节点可以存储多个值，高度肯定小于平衡二叉树，磁盘io的次数也会少。&lt;br/&gt;但是在范围查找方面较比B+Tree差点。&lt;br/&gt;题外话：B-Tree和BTree是一种树。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;btree&quot;&gt;B+Tree&lt;/h2&gt;
&lt;p&gt;B+Tree是B-Tree的变种，&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514201440659-157658732.png&quot;/&gt;&lt;br/&gt;B+树的表示要比B树要“胖”，原因在于B+树中的非叶子节点会冗余一份在叶子节点中，并且叶子节点之间用指针相连。&lt;/p&gt;
&lt;p&gt;mysql的实现中，B+Tree是把非叶子节点中只存储索引，不存储数据，只有叶子节点存储数据，这样节点中的空间更多的存储了索引，增加了度。&lt;br/&gt;最大程度的降低了树的高度，再加上一个节点的大小设置成为一页或页的倍数，一次磁盘io就可以读出了一个节点中的很多数据。&lt;br/&gt;加载到内存中再进行查找就很快了&lt;/p&gt;
&lt;p&gt;所以最后总结：&lt;br/&gt;使用B+Tree:可以提高查询索引时的磁盘IO效率，并且可以提高范围查询的效率，并且B+树里的元素也是有序的。&lt;/p&gt;

&lt;h2 id=&quot;myisam中的btree&quot;&gt;MyISAM中的B+Tree&lt;/h2&gt;
&lt;p&gt;MYISAM中叶子节点的数据区域存储的是数据记录的地址.&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514203511745-1871330661.png&quot;/&gt;&lt;br/&gt;MyISAM的索引是单独一个文件存放的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514203630245-256594033.png&quot;/&gt;&lt;br/&gt;MyISAM中的主键索引和辅助引是没有区别的，其叶子节点存放的都是数据记录的地址。&lt;/p&gt;
&lt;h2 id=&quot;innodb中的btree&quot;&gt;InnoDB中的B+Tree&lt;/h2&gt;
&lt;p&gt;InnoDB中的叶子节点数据区域存储的内容和主键索引和辅助索引引有关。&lt;br/&gt;如果是主键索引存储的就是索引+数据（index+data）&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514203936039-1715498943.png&quot;/&gt;&lt;br/&gt;Innodb的主键索引要比MyISAM的主键索引查询效率要高，因为找到主键索引就找到了数据,MyISAM还有通过地址查询一次。&lt;br/&gt;如果是辅助索引存储的是主键的值&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514204130408-1994293907.png&quot;/&gt;&lt;br/&gt;因此可以看出InnoDB的辅助索引会发生两次，一次通过辅助索引查询主键索引，一次是通过主键索引查询到数据。&lt;/p&gt;
&lt;p&gt;InnoDB的索引是和数据文件放在一起的。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190514205023672-1191913641.png&quot;/&gt;&lt;/p&gt;

&lt;h2 id=&quot;聚集索引&quot;&gt;聚集索引&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;数据行的物理顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;非聚集索引&quot;&gt;非聚集索引&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;数据行的物理顺序与列值的逻辑顺序不相同，一个表中可以拥有多个非聚集索引。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;叶子节点存放的不是实际数据，而是指向实际数据的指针。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/506422/201905/506422-20190515193737476-1534361388.png&quot;/&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;聚集索引以外的索引都是非聚集索引,细分可以分为：普通索引，唯一索引，全文索引&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;注意&quot;&gt;注意：&lt;/h2&gt;
&lt;p&gt;InnoDB 主键使用的是聚簇索引，MyISAM 不管是主键索引，还是二级索引使用的都是非聚簇索引&lt;/p&gt;

&lt;h2 id=&quot;什么样的字段适合建索引&quot;&gt;什么样的字段适合建索引&lt;/h2&gt;
&lt;p&gt;索引是建立在数据库表中的某些列的上面。因此，在创建索引的时候，应该仔细考虑在哪些列上可以创建索引，在哪些列上不能创建索引。 一般来说，应该在具备下述特性的列上创建索引：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;第一、在经常需要搜索的列上，可以加快搜索的速度；&lt;/li&gt;
&lt;li&gt;第二、在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；&lt;/li&gt;
&lt;li&gt;第三、在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；&lt;/li&gt;
&lt;li&gt;第四、在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；&lt;/li&gt;
&lt;li&gt;第五、在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；&lt;/li&gt;
&lt;li&gt;第六、在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。&lt;br/&gt;建立索引，一般按照select的where条件来建立，&lt;br/&gt;比如： select的条件是where f1 and f2，那么如果我们在字段f1或字段f2上建立索引是没有用的，只有在字段f1和f2上同时建立索引才有用等。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;什么样的字段不适合建立索引&quot;&gt;什么样的字段不适合建立索引&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;对于那些在查询中很少使用或者参考的列不应该创建索引&lt;/li&gt;
&lt;li&gt;对于那些只有很少数据值的列也不应该增加索引，比如：性别，状态，这是因为，由于这些列的取值很少，创建索引效果也不明显。&lt;/li&gt;
&lt;li&gt;对于那些定义为text, image和bit数据类型的列不应该增加索引&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/wangsen/p/10871996.html&quot;&gt;mysql常见的优化策略&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;数据结构：&lt;a href=&quot;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&quot; class=&quot;uri&quot;&gt;https://www.cs.usfca.edu/~galles/visualization/Algorithms.html&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg3MTA1MDU2Ng==&amp;amp;mid=2247483698&amp;amp;idx=1&amp;amp;sn=63eee2f67bc05d46e0b40f9999e5c736&amp;amp;chksm=ce853d1bf9f2b40d7845f6a4c5c9bfe32397d87236347a7adf85d18ea1c79b9ee7d6bb80bd19&amp;amp;mpshare=1&amp;amp;scene=1&amp;amp;srcid=0513oct1Eqn0fDWPuOMAZbyd&amp;amp;key=e5c9f0f84d46755059bc9825949648193177cb6fd6739c17c3f6751e70d598c6406dd4bcf7a030cfbb7dcc7663bd484ab3f3035073dc7b4a31974678d2aa7b044fd9200304cf8dfb95a0a0ea46984990&amp;amp;ascene=1&amp;amp;uin=NzkwMDM0MjYy&amp;amp;devicetype=Windows+10&amp;amp;version=62060739&amp;amp;lang=zh_CN&amp;amp;pass_ticket=%2BgyuPXnOA9g6lE0%2BamAQvTP2lKLvQ6X665z6wjditKxEPRnxoLkK66gbugtCj0lU&quot;&gt;面试必备之Mysql索引底层原理分析&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/sinat_27602945/article/details/80118362&quot;&gt;为什么数据库选B-tree或B+tree而不是二叉树作为索引结构&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.jianshu.com/p/fd49b1510dfd&quot;&gt;关于B-树问题的演示图解&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 May 2019 12:50:00 +0000</pubDate>
<dc:creator>王森</dc:creator>
<og:description>什么是索引 索引是对数据库表中一列或多列的值【排好序】的数据结构。 为什么要加索引 因为创建索引可以大大提高系统的查询性能。 怎么提高查询性能的 简单的理解：一张数据量比较大的表格如果没有添加任何索引</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wangsen/p/10864136.html</dc:identifier>
</item>
<item>
<title>【Java】ServiceLoader源码分析 - 松饼人</title>
<link>http://www.cnblogs.com/a526583280/p/10871795.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/a526583280/p/10871795.html</guid>
<description>&lt;p&gt;ServiceLoader主要的功能是用来完成对SPI的provider的加载。&lt;/p&gt;
&lt;p&gt;先看下它的成员：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ServiceLoader&amp;lt;S&amp;gt;
&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;implements&lt;/span&gt; Iterable&amp;lt;S&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; String PREFIX = &quot;META-INF/services/&quot;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; 
&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The class or interface representing the service being loaded&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Class&amp;lt;S&amp;gt;&lt;span&gt; service;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; 
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The class loader used to locate, load, and instantiate providers&lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; ClassLoader loader;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The access control context taken when the ServiceLoader is created&lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; AccessControlContext acc;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; Cached providers, in instantiation order&lt;/span&gt;
&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; LinkedHashMap&amp;lt;String,S&amp;gt; providers = &lt;span&gt;new&lt;/span&gt; LinkedHashMap&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt;     &lt;span&gt;//&lt;/span&gt;&lt;span&gt; The current lazy-lookup iterator&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt;&lt;span&gt; LazyIterator lookupIterator;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;     
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;         
&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到他首先是实现了Iterable接口，可以迭代。&lt;br/&gt;PREFIX：指明了路径是在&quot;META-INF/services/&quot;下。&lt;br/&gt;service：表示正在加载的服务的类或接口。&lt;br/&gt;loader：使用的类加载器。&lt;br/&gt;acc：创建ServiceLoader时获取的访问控制上下文。&lt;br/&gt;providers ：缓存的服务提供集合。&lt;br/&gt;lookupIterator：是其内部使用的迭代器，用于类的懒加载，只有在迭代时加载。&lt;/p&gt;
&lt;p&gt;其构造方法是一个private方法，不对外提供，在使用时我们需要调用其静态的load方法，由其自身产生ServiceLoader对象：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt;&lt;span&gt; service) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         ClassLoader cl =&lt;span&gt; Thread.currentThread().getContextClassLoader();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ServiceLoader.load(service, cl);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; 
&lt;span&gt;6&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; load(Class&amp;lt;S&amp;gt;&lt;span&gt; service,
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;                                            ClassLoader loader) {
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServiceLoader&amp;lt;&amp;gt;&lt;span&gt;(service, loader);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到对load方法进行了重载，其中参数service是要加载的类；单参方法没有类加载器，使用的是当前线程的类加载器；最后调用的是双参的load方法；而双参的load方法也很简单，只是直接调用ServiceLoader的构造方法，实例化了一个对象。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; ServiceLoader(Class&amp;lt;S&amp;gt;&lt;span&gt; svc, ClassLoader cl) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         service = Objects.requireNonNull(svc, &quot;Service interface cannot be null&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         loader = (cl == &lt;span&gt;null&lt;/span&gt;) ?&lt;span&gt; ClassLoader.getSystemClassLoader() : cl;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         acc = (System.getSecurityManager() != &lt;span&gt;null&lt;/span&gt;) ? AccessController.getContext() : &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; &lt;span&gt;        reload();
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到其构造方法逻辑依旧很简单，首先是判断传入的svc（即传入的service）是否为空，若是为空直接报异常，否则给service 成员赋值：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T requireNonNull(T obj, String message) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (obj == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NullPointerException(message);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; obj;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后给进行cl的非空判断，给loader 成员赋值；接着给acc 成员赋值，其根据是否设置了安全管理器SecurityManager来赋值；最后调用reload方法。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; reload() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt; &lt;span&gt;        providers.clear();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         lookupIterator = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; LazyIterator(service, loader);
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到reload方法是一个public方法，那么在每次调用reload时就需要将之前加载的清空掉，所以直接使用providers这个map的clear方法清空掉缓存；接着使用刚才赋值后的service和loader产生一个LazyIterator对象赋值给lookupIterator成员。&lt;/p&gt;
&lt;p&gt;LazyIterator是ServiceLoader的内部类，其定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; LazyIterator
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;implements&lt;/span&gt; Iterator&amp;lt;S&amp;gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     Class&amp;lt;S&amp;gt;&lt;span&gt; service;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    ClassLoader loader;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     Enumeration&amp;lt;URL&amp;gt; configs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     Iterator&amp;lt;String&amp;gt; pending = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     String nextName = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     
&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;private&lt;/span&gt; LazyIterator(Class&amp;lt;S&amp;gt;&lt;span&gt; service, ClassLoader loader) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.service =&lt;span&gt; service;
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;         &lt;span&gt;this&lt;/span&gt;.loader =&lt;span&gt; loader;
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    ......
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里就可以看到ServiceLoader的实际加载过程就交给了LazyIterator来做，将ServiceLoader的service和loader成员分别赋值给了LazyIterator的service和loader成员。&lt;br/&gt;configs是服务的URL枚举；&lt;br/&gt;pending是保存要加载的服务的名称集合；&lt;br/&gt;nextName是下一个要加载的服务名称；&lt;/p&gt;
&lt;p&gt;ServiceLoader实现了Iterable接口，其实现的iterator方法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; Iterator&amp;lt;S&amp;gt;&lt;span&gt; iterator() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Iterator&amp;lt;S&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         Iterator&amp;lt;Map.Entry&amp;lt;String,S&amp;gt;&amp;gt;&lt;span&gt; knownProviders
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;             =&lt;span&gt; providers.entrySet().iterator();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     
&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNext() {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (knownProviders.hasNext())
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; lookupIterator.hasNext();
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     
&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; S next() {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (knownProviders.hasNext())
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;                 &lt;span&gt;return&lt;/span&gt;&lt;span&gt; knownProviders.next().getValue();
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt;&lt;span&gt; lookupIterator.next();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     
&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    };
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到它是直接创建了一个Iterator对象返回；其knownProviders成员直接获取providers的entrySet集合的迭代器；在hasNext和next方法中我们可以看到，它是先通过判断knownProviders里有没有（即providers），若没有再去lookupIterator中找；&lt;br/&gt;前面我们可以看到providers里并没用put任何东西，那么就说明put操作也是在lookupIterator中完成的。&lt;/p&gt;
&lt;p&gt;先看到lookupIterator的next方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; S next() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    &lt;span&gt;if&lt;/span&gt; (acc == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextService();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;         PrivilegedAction&amp;lt;S&amp;gt; action = &lt;span&gt;new&lt;/span&gt; PrivilegedAction&amp;lt;S&amp;gt;&lt;span&gt;() {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;             &lt;span&gt;public&lt;/span&gt; S run() { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; nextService(); }
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;        };
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; AccessController.doPrivileged(action, acc);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先根据判断acc是否为空，若为空则说明没有设置安全策略直接调用nextService方法，否则以特权方式调用nextService方法。&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt;&lt;span&gt; S nextService() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;hasNextService())
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NoSuchElementException();
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     String cn =&lt;span&gt; nextName;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     nextName = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     Class&amp;lt;?&amp;gt; c = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         c = Class.forName(cn, &lt;span&gt;false&lt;/span&gt;&lt;span&gt;, loader);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (ClassNotFoundException x) {
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;        fail(service,
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;              &quot;Provider &quot; + cn + &quot; not found&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;service.isAssignableFrom(c)) {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        fail(service,
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;              &quot;Provider &quot; + cn  + &quot; not a subtype&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         S p =&lt;span&gt; service.cast(c.newInstance());
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        providers.put(cn, p);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt;&lt;span&gt; p;
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable x) {
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        fail(service,
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;              &quot;Provider &quot; + cn + &quot; could not be instantiated&quot;&lt;span&gt;,
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;             x);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Error();          &lt;span&gt;//&lt;/span&gt;&lt;span&gt; This cannot happen&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;首先根据hasNextService方法判断，若为false直接抛出NoSuchElementException异常，否则继续执行。&lt;/p&gt;
&lt;p&gt;hasNextService方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; hasNextService() {
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (nextName != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (configs == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;             String fullName = PREFIX +&lt;span&gt; service.getName();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (loader == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;                 configs =&lt;span&gt; ClassLoader.getSystemResources(fullName);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;             &lt;span&gt;else&lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;                 configs =&lt;span&gt; loader.getResources(fullName);
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException x) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;             fail(service, &quot;Error locating configuration files&quot;&lt;span&gt;, x);
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; ((pending == &lt;span&gt;null&lt;/span&gt;) || !&lt;span&gt;pending.hasNext()) {
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;configs.hasMoreElements()) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;         pending =&lt;span&gt; parse(service, configs.nextElement());
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;     nextName =&lt;span&gt; pending.next();
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;hasNextService方法首先根据nextName成员是否为空判断，若不为空，则说明已经初始化过了，直接返回true，否则继续执行。接着configs成员是否为空，configs 是一个URL的枚举，若是configs 没有初始化，就需要对configs初始化。&lt;br/&gt;configs初始化逻辑也很简单，首先根据PREFIX前缀加上PREFIX的全名得到完整路径，再根据loader的有无，获取URL的枚举。其中fail方法时ServiceLoader的静态方法，用于异常的处理，后面给出。&lt;br/&gt;在configs初始化完成后，还需要完成pending的初始化或者添加。&lt;br/&gt;可以看到只有当pending为null，或者没有元素时才进行循环。循环时若是configs里没有元素，则直接返回false；否则调用ServiceLoader的parse方法，通过service和URL给pending赋值；&lt;/p&gt;
&lt;p&gt;parse方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; Iterator&amp;lt;String&amp;gt; parse(Class&amp;lt;?&amp;gt;&lt;span&gt; service, URL u)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServiceConfigurationError {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     InputStream in = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     BufferedReader r = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     ArrayList&amp;lt;String&amp;gt; names = &lt;span&gt;new&lt;/span&gt; ArrayList&amp;lt;&amp;gt;&lt;span&gt;();
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;     &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt;         in =&lt;span&gt; u.openStream();
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         r = &lt;span&gt;new&lt;/span&gt; BufferedReader(&lt;span&gt;new&lt;/span&gt; InputStreamReader(in, &quot;utf-8&quot;&lt;span&gt;));
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; lc = 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;while&lt;/span&gt; ((lc = parseLine(service, u, r, lc, names)) &amp;gt;= 0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException x) {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         fail(service, &quot;Error reading configuration file&quot;&lt;span&gt;, x);
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;     } &lt;span&gt;finally&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (r != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) r.close();
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (in != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) in.close();
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;         } &lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (IOException y) {
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;             fail(service, &quot;Error closing configuration file&quot;&lt;span&gt;, y);
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; names.iterator();
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到parse方法直接通过URL打开输入流，通过parseLine一行一行地读取将结果保存在names数组里。&lt;/p&gt;
&lt;p&gt;parseLine方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; parseLine(Class&amp;lt;?&amp;gt; service, URL u, BufferedReader r, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; lc,
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;                           List&amp;lt;String&amp;gt;&lt;span&gt; names)
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServiceConfigurationError {
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt;     String ln =&lt;span&gt; r.readLine();
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ln == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; -1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; ci = ln.indexOf('#'&lt;span&gt;);
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (ci &amp;gt;= 0) ln = ln.substring(0&lt;span&gt;, ci);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     ln =&lt;span&gt; ln.trim();
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; n =&lt;span&gt; ln.length();
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (n != 0&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; ((ln.indexOf(' ') &amp;gt;= 0) || (ln.indexOf('\t') &amp;gt;= 0&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;             fail(service, u, lc, &quot;Illegal configuration-file syntax&quot;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;         &lt;span&gt;int&lt;/span&gt; cp = ln.codePointAt(0&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;Character.isJavaIdentifierStart(cp))
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;             fail(service, u, lc, &quot;Illegal provider-class name: &quot; +&lt;span&gt; ln);
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = Character.charCount(cp); i &amp;lt; n; i +=&lt;span&gt; Character.charCount(cp)) {
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;             cp =&lt;span&gt; ln.codePointAt(i);
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt; (!Character.isJavaIdentifierPart(cp) &amp;amp;&amp;amp; (cp != '.'&lt;span&gt;))
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;                 fail(service, u, lc, &quot;Illegal provider-class name: &quot; +&lt;span&gt; ln);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt; (!providers.containsKey(ln) &amp;amp;&amp;amp; !&lt;span&gt;names.contains(ln))
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;            names.add(ln);
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; lc + 1&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;parseLine方法就是读该URL对应地文件地一行，可以看到通过对“#”的位置判断，忽略注释，并且剔除空格，接着是一系列的参数合法检验，然后判断providers和names里是否都没包含这个服务名称，若都没包含names直接add，最后返回下一行的行标；&lt;/p&gt;
&lt;p&gt;当parse将所有内容读取完毕，返回names.iterator()赋值给hasNextService中的pending。循环结束，获取pending中的第一个元素赋值给nextName，返回true，hasNextService方法结束。&lt;/p&gt;
&lt;p&gt;在nextService方法往下执行时，先用cn保存nextName的值，再让nextName=null，为下一次的遍历做准备；接着通过类加载，加载名为cn的类，再通过该类实例化对象，并用providers缓存起来，最后返回该实例对象。&lt;/p&gt;
&lt;p&gt;其中cast方法是判断对象是否合法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt;&lt;span&gt; T cast(Object obj) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt; (obj != &lt;span&gt;null&lt;/span&gt; &amp;amp;&amp;amp; !&lt;span&gt;isInstance(obj))
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;         &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ClassCastException(cannotCastMsg(obj));
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T) obj;
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;至此ServiceLoader的迭代器的next方法结束。其hasNext方法与其类似，就不详细分析了。&lt;/p&gt;
&lt;p&gt;而其remove方法就更直接，直接抛出异常来避免可能出现的危险情况：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; remove() {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UnsupportedOperationException();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;其中使用到的静态fail方法只是抛出异常：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fail(Class&amp;lt;?&amp;gt;&lt;span&gt; service, String msg, Throwable cause)
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServiceConfigurationError {
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServiceConfigurationError(service.getName() + &quot;: &quot; +&lt;span&gt; msg,
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;                                            cause);
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; 
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fail(Class&amp;lt;?&amp;gt;&lt;span&gt; service, String msg)
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServiceConfigurationError {
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; ServiceConfigurationError(service.getName() + &quot;: &quot; +&lt;span&gt; msg);
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; 
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; fail(Class&amp;lt;?&amp;gt; service, URL u, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; line, String msg)
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;         &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServiceConfigurationError {
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;     fail(service, u + &quot;:&quot; + line + &quot;: &quot; +&lt;span&gt; msg);
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;ServiceLoader除了load的两个方法外还有个loadInstalled方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;S&amp;gt; ServiceLoader&amp;lt;S&amp;gt; loadInstalled(Class&amp;lt;S&amp;gt;&lt;span&gt; service) {
&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;     ClassLoader cl =&lt;span&gt; ClassLoader.getSystemClassLoader();
&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;     ClassLoader prev = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt; (cl != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;5&lt;/span&gt;         prev =&lt;span&gt; cl;
&lt;/span&gt;&lt;span&gt;6&lt;/span&gt;         cl =&lt;span&gt; cl.getParent();
&lt;/span&gt;&lt;span&gt;7&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;8&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt;&lt;span&gt; ServiceLoader.load(service, prev);
&lt;/span&gt;&lt;span&gt;9&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法与load方法不同在于loadInstalled使用的是扩展类加载器，而load使用的是传入进来的或者是线程的上下文类加载器，其他都一样。&lt;/p&gt;

&lt;p&gt;ServiceLoader源码分析到此全部结束。&lt;/p&gt;

</description>
<pubDate>Wed, 15 May 2019 12:01:00 +0000</pubDate>
<dc:creator>松饼人</dc:creator>
<og:description>ServiceLoader主要的功能是用来完成对SPI的provider的加载。 先看下它的成员： 可以看到他首先是实现了Iterable接口，可以迭代。PREFIX：指明了路径是在&quot;MET</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/a526583280/p/10871795.html</dc:identifier>
</item>
<item>
<title>令牌Token和会话Session原理与攻略 - 朝野布告</title>
<link>http://www.cnblogs.com/huangsheng/p/10736796.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huangsheng/p/10736796.html</guid>
<description>&lt;p&gt;        本篇文章将从无到完整的登录框架或API详细讲述登录令牌原理、攻略等安全点。&lt;/p&gt;
&lt;p&gt;        有些协议或框架也喜欢把令牌叫票据（Ticket），不论是APP还是Web浏览器，很多框架或协议都用到了本文所说的这套类似的认证机制（客户端各种加密用户名密码当我没说），这里的以Asp.net core下Web登录和验证为例子进行讲述，但原理攻略和语言、框架都无关。&lt;/p&gt;

&lt;p&gt;目录：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp1&quot;&gt;一、过程与原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp2&quot;&gt;二、Demo数据库结构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp3&quot;&gt;三、Demo源码介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp4&quot;&gt;四、构建与验证Token&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp5&quot;&gt;五、Token失效与登录唯一性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp6&quot;&gt;六、CAS/SSO单点登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp7&quot;&gt;七、URL授权验证与扫码登录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp8&quot;&gt;八、Session实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.cnblogs.com/huangsheng/p/10736796.html#acp9&quot;&gt;九、关于Token刷新&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;本片文章Demo：&lt;a href=&quot;https://github.com/chaoyebugao/AcctAuthDemo&quot;&gt;https://github.com/chaoyebugao/AcctAuthDemo&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;acp1&quot;&gt; &lt;/p&gt;

&lt;h2&gt;一、过程与原理 &lt;/h2&gt;
&lt;div&gt;&lt;a href=&quot;https://www.processon.com/view/link/5cc5804ae4b09b16ffcb7d60&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;令牌授权过程&quot; src=&quot;http://assets.processon.com/chart_image/5cc5804ae4b0bab9096bd889.png&quot; alt=&quot;令牌授权过程&quot; width=&quot;806&quot; height=&quot;600&quot;/&gt;&lt;/a&gt;&lt;/div&gt;

&lt;p&gt;令牌机制简单过程（点击查看大图）&lt;/p&gt;
&lt;p&gt;        首先，这套机制使用场景是登录授权和身份验证，可以用在Web上，也可以用在API的访问控制上。这套机制其实和很多无状态框架登录/授权验证协议类似，这里讲的其实和OAuth2.0里面授权码模式的原理是一样的(authorization code)，只不过我们在这里将其步骤拆分，了解其原理和实现，以后搭建项目应用才能庖丁解牛。还有一点，很多框架的授权机制都太繁重且并不能灵活应用，这时候就可以自己搭一个。&lt;/p&gt;
&lt;p&gt;        首先，用户使用终端向服务器提供可信凭证（一般登录是用户名密码，微信公众平台是appid+appsecret），服务端确认凭证正确，则返回授权的令牌（以下称Token）。这个Token是随机的字符串且与本次授权唯一相关。返回Token给终端的同时服务端也要一并保存Token，这样终端和服务端都只认Token，终端所有请求发送都需要携带此Token，服务端会验证和控制此Token。此时Token就有两个，一个是终端Token，一个是服务端Token，其中一个不对或没有，服务端都是拒绝的。&lt;/p&gt;
&lt;p&gt;        举个例子，你上12306购票，购买过程就是授权你Token的过程，你的纸质票就是Token，另外一半对应的Token保存在12306那的DB里头，所有门闸就是网关，当你过门闸时会验证你Token是否对应DB的Token。你下车后，12306就把DB的Token标记处理掉，这样服务端就不会再认你手上的纸质票，票也就作废了。&lt;/p&gt;
&lt;p&gt;        围绕这一机制，我们将讲述CAS单点登录、令牌授权与身份验证、Session实现、防重放攻击、登录唯一性、URL授权验证（用于验证邮箱等）等&lt;/p&gt;
&lt;p id=&quot;acp2&quot;&gt; &lt;/p&gt;

&lt;h2&gt;二、Demo数据库结构&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/563206/201905/563206-20190515152119061-754303208.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;设备表：用于识别、记录不同的设备，同一设备应该有唯一的标记Id，下面详说&lt;/p&gt;
&lt;p&gt;令牌表：用于持久化令牌，ExpireAt为过期时间，Token即令牌字符串，根据UserId与用户表相关联，根据DeviceId与设备表相关联&lt;/p&gt;
&lt;p&gt;用户表：用户表，保存用户名密码等&lt;/p&gt;
&lt;p&gt;设备表和设备标记（DeviceId）是可有可无的，可以根据实际业务来处理，有必要的话再增加其他相关联的数据和表&lt;/p&gt;
&lt;p id=&quot;acp3&quot;&gt; &lt;/p&gt;

&lt;h2&gt;三、Demo源码介绍&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;用户注册、登录、注销登录入口&quot; src=&quot;https://img2018.cnblogs.com/blog/563206/201905/563206-20190515170911612-223364984.png&quot; alt=&quot;用户Controller&quot; width=&quot;662&quot; height=&quot;479&quot;/&gt; &lt;/p&gt;
&lt;p&gt;&lt;img title=&quot;验证入库&quot; src=&quot;https://img2018.cnblogs.com/blog/563206/201905/563206-20190515171230222-608122276.png&quot; alt=&quot;HomeController&quot; width=&quot;459&quot; height=&quot;172&quot;/&gt;&lt;/p&gt;
&lt;p&gt;UserController - 用户注册、登录、注销登录&lt;/p&gt;
&lt;p&gt;HomeController - Index - 默认启动页，Token验证页&lt;/p&gt;
&lt;p id=&quot;acp4&quot;&gt; &lt;/p&gt;

&lt;h2&gt;四、构建与验证Token&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/563206/201905/563206-20190515154042575-972564652.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;构建Token&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/563206/201905/563206-20190515163040423-1784808511.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证Token&lt;/p&gt;
&lt;p&gt;        Token的构建发生在用户提供的凭证（如用户名密码）被服务端确认无误之后。一次登录/授权的Token分两部分，服务端持有的我们叫数据库Token，用户端（Endpoint）持有的叫终端Token。终端Token可以是任意的随机字符串构成，所以这里最后要根据登录情况来求得哈希值即终端Token本身。因为后面要根据终端Token来查询处理数据库Token记录，所以他们必须有种关联，这种关联就是如上图所示，终端Token+设备Id得到的哈希值即数据库Token本身。&lt;/p&gt;
&lt;p&gt;        可以看出，整个生成过程是单向不可逆的，验证也只能是单向验证，所以生成关系是这样的：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.processon.com/view/link/5cdbcf56e4b0f34230cd3066&quot; target=&quot;_blank&quot;&gt;&lt;img title=&quot;授权Token构建关系图&quot; src=&quot;http://assets.processon.com/chart_image/5cdbcf56e4b005286482c890.png&quot; alt=&quot;授权Token构建关系图&quot; width=&quot;348&quot; height=&quot;356&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;授权Token构建关系图&lt;/p&gt;

&lt;p&gt;        这里有几点要注意的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;终端Token应该有足够的长度，且每次应随机生成，因此才有Guid.NewGuid()参与求值&lt;/li&gt;
&lt;li&gt;终端Token参与生成的userId、name和inputPassword是起到了盐作用，让整个构建更加复杂&lt;/li&gt;
&lt;li&gt;不论是终端Token还是数据库Token都不应该可逆加密处理任何内容，因为可解密的话不论是终端还是数据库数据泄露的，都有被破解的风险，所以用哈希求值是最合适的&lt;/li&gt;
&lt;li&gt;构建数据库Token有deviceId参与，这样每次Token就只能是对应的deviceId才能被验证，这样就起了绑定作用。除了deviceId还可以绑定其他场景相关的，比如IP地址、终端类型&lt;/li&gt;
&lt;li&gt;日志最好不要记录任何Token&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        两部分Token构建好之后，终端Token将被返回给终端，数据库Token持久化到服务端中。终端和数据库都要将各自的Token和场景信息持久化，Demo里面终端Token和deviceId放到了Cookie中。每次请求的终端都需要提交终端Token和绑定用的场景信息(deviceId)，因为验证的时候数据库Token保存的是由它们哈希过来的值，因此验证的时候也是使用一样的构建过程（即Demo里面的BuildDatabaseToken方法），这样终端Token和数据库Token就有了对应关系。得到数据库Token就能在数据库里面查找了（即上图的loginTokenRepository.FindUser方法）。Demo的验证页面是Home/Index，里面使用了过滤器CheckLoginTokenActionFilterAttribute做验证，在需要验证的Controller或Action上做ServiceFilter属性标记处理即可。&lt;/p&gt;
&lt;p&gt;        这里有几点要注意的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果使用Http做接口且有App接入，不方便地支持Cookie机制的话可以改为放在请求头中&lt;/li&gt;
&lt;li&gt;如果使用Http且为Web浏览器，终端Token保存的Cookie应该设为HttpOnly，让JS不可触碰&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        到这里童鞋们知道为什么Token拆成两部分了吗？整个Token授权过程是单向不可逆的，而且每个用户都有自己的哈希盐来生成Token，这样能避免哈希值被批量暴力破解，即使终端Token和数据库Token都泄露了你也对应不上。试想一下如果不是这样而是终端数据库的Token是相同的，那一旦数据库泄露那么黑客就能模拟Token进行登录/授权了。另外数据库Token哈希过后长度变短，查询性能也能提高，毕竟每个请求都需要进行验证，查询频率是很高的。&lt;/p&gt;
&lt;p id=&quot;acp5&quot;&gt; &lt;/p&gt;

&lt;h2&gt;五、Token失效与登录唯一性&lt;/h2&gt;
&lt;p&gt;        不论是终端Token还是服务端Token都要有失效机制，时间越短越安全，但也要结合使用场景需求来设定时长。终端Token如果是Cookie的话直接用Cookie的过期时间即可，并且要和数据库Token的过期时间一致。数据库Token生成的时候也要指定过期时间，Demo里面数据库保存的字段为ExpireAt。一般有以下几种失效情况：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;到了过期时间&lt;/li&gt;
&lt;li&gt;用户修改账户关键信息，服务端需要主动将旧的Token全部作废掉，如修改密码&lt;/li&gt;
&lt;li&gt;用户注销登录&lt;/li&gt;
&lt;li&gt;用户使用Token刷新机制&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;        另外，如果需求是一种终端只能一个登录，比如Web和App可以保持同时登录但App只能有一个登录，数据库Token还得绑定“终端类型”，这样在最新一次登录的时候把相同的终端类型的旧的数据库Token全部作废掉就好了。&lt;/p&gt;
&lt;p&gt;        可以看出，服务端的保有的数据库Token可以有效控制其授权，达到访问控制的目的。&lt;/p&gt;
&lt;p id=&quot;acp6&quot;&gt; &lt;/p&gt;

&lt;h2&gt;六、CAS/SSO单点登录&lt;/h2&gt;
&lt;p&gt;        CAS即中央认证服务，SSO即SSO即单点登录。很多时候这两个会放在一起说，其实CAS是一套解决方案，SSO是一种机制描述。如果我们使用的是Http-Web那么我们如何实现我们自己的SSO呢？很简单，把Token和绑定的场景信息提升到同一个域下即可。比如有总部和门店两个系统分别使用了hq.xxxx.com/store.xxxx.com子域名，那不管从哪个系统登录，login_token和deviceId这两个Cookie放在顶级域.xxxx.com下即可，这样所有子系统都能访问得到它们，继而都保有登录/授权状态。有没有发现登录新浪微博后，输入weibo.com都会先跳转到sso然后再跳转回来，这个也差不多，这也是为什么你登录了新浪微博，你新浪博客也是登录了的状态。&lt;/p&gt;
&lt;p id=&quot;acp7&quot;&gt; &lt;/p&gt;

&lt;h2&gt;七、URL授权验证与扫码登录&lt;/h2&gt;
&lt;p&gt;        当我们需要进行邮箱验证的时候，有可能是用户登录和邮箱不是一个终端的，这时候我们就需要进行URL授权验证来避免用户再次进行登录。其原理很简单，在用户点击验证的链接上面附上URL授权令牌即可（下面简称URL Token），这个URL Token与登录Token不应该有关系所以应当单独保存。生成一个URL Token，服务端再对应保存类似的服务端Token，这样就有了【URL Token】 - 【服务端Token】 - 【用户】这样的对应关系。当用户在有效期内点击后，服务端获得URL Token也就能进行授权或验证。&lt;/p&gt;
&lt;p&gt;        扫码登录的场景复杂一些，终端生成的二维码其实就是一个Token（我们称之为QR Token）这个Token是和终端绑定的。用户拿App扫了QR码，其实就是在App内同时提交QR Token和用户信息，用户确认可以登录后服务端会颁发登录Token给终端，这样终端就是登录状态了，这一步也就是上面构建和验证登录Token的过程。实际扫码登录需要实现即时通讯，这样终端才能做出相应的反应。另外QR Token也是一样有过期时间的，因此那些扫码登录的页面会做二维码自动刷新的。&lt;/p&gt;
&lt;p id=&quot;acp8&quot;&gt; &lt;/p&gt;

&lt;h2&gt;八、Session实现&lt;/h2&gt;
&lt;p&gt;        其实有些童鞋会纳闷，完善的框架都会提供Session操作，其原理是一样的，那为什么我们还这么“造作”呢？原因有二，框架自带的可能过重，比如我就很不喜欢asp.net自带的授权认证机制，微软弄得一套一套的，简直就是全家桶，笨重，自己实现一个能定制化且轻量。第二，考虑类似上面的功能实现，自己做能更灵活地实现。&lt;/p&gt;
&lt;p&gt;        我们已经实现了登录/授权和验证，接下来我们只要想办法把一些数据和Token绑定在一起，并放在缓存中，这些数据就是Session了。我一般的做法是封装一个SessionService，然后定义一套Session接口。一个Session数据由TokenKey-Value组成，如果Token失效，则清理所有对应的TokenKey数据即可。就是这么简单粗暴，不同的缓存组件实现不尽相同。&lt;/p&gt;
&lt;p id=&quot;acp9&quot;&gt; &lt;/p&gt;

&lt;h2&gt;九、关于Token刷新&lt;/h2&gt;
&lt;p&gt;        OAuth 2.0里面有提供Token刷新服务，即终端持有的Token快过期的时候，终端可以再调用刷新接口来替换快过期的Token，达到永续状态。简单来说就是请求新的Token，请求时旧Token作废掉，实现并不复杂，参见：&lt;a href=&quot;https://www.cnblogs.com/blowing00/p/4524132.html&quot; target=&quot;_blank&quot;&gt;Oauth2.0（三）：Access Token 与 Refresh Token&lt;/a&gt;&lt;/p&gt;
&lt;p id=&quot;acp10&quot;&gt; &lt;/p&gt;

&lt;h2&gt;十、防重放攻击与签名机制&lt;/h2&gt;
&lt;p&gt;        重放攻击(Replay Attacks)又叫重播攻击，防范这个其实和本文讨论的主题没关系。完整实现的接口都有实现，欲知详情，等我下一篇。&lt;/p&gt;

&lt;p&gt;        花了好几天来写了这篇文章，同时也是自己对这一技术点的总结归纳，有不对的地方还请指正。&lt;/p&gt;

&lt;p&gt;相关链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dudu/p/4578511.html&quot; target=&quot;_blank&quot;&gt;ASP.NET Web API与Owin OAuth：调用与用户相关的Web API&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140183&quot; target=&quot;_blank&quot;&gt;微信公众平台技术文档 - 获取access_token&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 15 May 2019 11:56:00 +0000</pubDate>
<dc:creator>朝野布告</dc:creator>
<og:description>本篇文章将从无到完整的登录框架或API详细讲述登录令牌原理、攻略等安全点。 有些协议或框架也喜欢把令牌叫票据（Ticket），不论是APP还是Web浏览器，很多框架或协议都用到了本文所说的这套类似的认</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/huangsheng/p/10736796.html</dc:identifier>
</item>
</channel>
</rss>