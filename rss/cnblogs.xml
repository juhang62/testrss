<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【QT】 Qt多线程的“那些事” - 李春港</title>
<link>http://www.cnblogs.com/lcgbk/p/13967448.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lcgbk/p/13967448.html</guid>
<description>&lt;p&gt;在我们开发Qt程序时，会经常用到多线程和信号槽的机制，将耗时的事务放到单独的线程，将其与GUI线程独立开，然后通过信号槽的机制来进行数据通信，避免GUI界面假死的情况。例如：使用QT实现文件的传送，并且GUI界面需要实时显示发送的进度，这时就需要将耗时的文件数据操作放到&lt;strong&gt;独立的线程&lt;/strong&gt;中，然后把已传送的进度数据通过&lt;strong&gt;信号&lt;/strong&gt;发送到&lt;strong&gt;GUI线程&lt;/strong&gt;，GUI主线程接收到信号后通过&lt;strong&gt;槽函数&lt;/strong&gt;来更新UI，这样界面就不会出现假死的情况了。&lt;br/&gt;&lt;strong&gt;多线程&lt;/strong&gt;和&lt;strong&gt;信号槽机制&lt;/strong&gt;都是QT的关键技术之一。理解清楚这两个技术点的关系，会让你在开发过程中少走些弯路，少踩一些坑。本文章会介绍多种Qt多线程的实现方法，但是主要还是介绍有关于 &lt;strong&gt;信号槽机制的多线程&lt;/strong&gt; 实现方法。在学习QT&lt;strong&gt;多线程&lt;/strong&gt;的&quot;那些事&quot;前，我们不妨先思考下以下的一些问题，然后再带着问题继续往下看，这样可能会有更好的理解：&lt;br/&gt;【1】&lt;strong&gt;如何正确使用QT的多线程？&lt;/strong&gt;&lt;br/&gt;【2】&lt;strong&gt;线程start后，哪里才是线程正在启动的地方？&lt;/strong&gt;&lt;br/&gt;【3】&lt;strong&gt;如何正确结束子线程以及资源释放？&lt;/strong&gt;&lt;br/&gt;【4】&lt;strong&gt;重复调用QThread::start、QThread::quit()或QThread::exit()、QThread::terminate函数会有什么影响？&lt;/strong&gt;&lt;br/&gt;【5】&lt;strong&gt;调用QThread::quit()或QThread::exit()、QThread::terminate函数会不会立刻停止线程？&lt;/strong&gt;&lt;br/&gt;【6】&lt;strong&gt;多线程之间是怎么进行通信的？&lt;/strong&gt;&lt;br/&gt;【7】&lt;strong&gt;如何在子线程中启动信号与槽的机制？&lt;/strong&gt;&lt;br/&gt;【8】&lt;strong&gt;QT中多线程之间的信号和槽是如何发送或执行的？&lt;/strong&gt;&lt;br/&gt;【9】&lt;strong&gt;如何正确使用信号与槽机制？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我会通过我以前踩过的坑和开发经验，并且通过一些实例来总结一下&lt;strong&gt;QT多线程&lt;/strong&gt;和&lt;strong&gt;QT信号槽机制&lt;/strong&gt;的知识点。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;这个是本文章实例的源码地址：&lt;a href=&quot;https://gitee.com/CogenCG/QThreadExample.git&quot;&gt;https://gitee.com/CogenCG/QThreadExample.git&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;本章会挑出QThread源码中部分重点代码来说明QThread启动到结束的过程是怎么调度的。其次因为到了Qt4.4版本，Qt的多线程就有所变化，所以本章会以Qt4.0.1和Qt5.6.2版本的源码来进行浅析。&lt;/p&gt;
&lt;h2 id=&quot;21-qthread类的定义源码&quot;&gt;2.1 QThread类的定义源码&lt;/h2&gt;
&lt;p&gt;Qt4.0.1版本源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifndef QT_NO_THREAD
class Q_CORE_EXPORT QThread : public QObject
{
public:
    ...//省略
    explicit QThread(QObject *parent = 0);
    ~QThread();
    ...//省略
    void exit(int retcode = 0);

public slots:
    void start(QThread::Priority = InheritPriority); //启动线程函数
    void terminate(); //强制退出线程函数
    void quit(); //线程退出函数
    ...//省略
signals:
    void started(); //线程启动信号
    void finished(); //线程结束信号
    ...//省略
    
protected:
    virtual void run() = 0;
    int exec();
    ...//省略
};
#else // QT_NO_THREAD
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Qt5.6.2版本源码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifndef QT_NO_THREAD
class Q_CORE_EXPORT QThread : public QObject
{
    Q_OBJECT
public:
    ...//省略
    explicit QThread(QObject *parent = Q_NULLPTR);
    ~QThread();
    ...//省略
    void exit(int retcode = 0); //线程退出函数
    ...//省略
public Q_SLOTS:
    void start(Priority = InheritPriority); //启动线程函数
    void terminate(); //强制退出线程函数
    void quit(); //线程退出函数
    ...//省略
Q_SIGNALS:
    void started(QPrivateSignal); //线程启动信号
    void finished(QPrivateSignal); //线程结束信号
    
protected:
    virtual void run();
    int exec();
    ...//省略
};
#else // QT_NO_THREAD
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从以上两个版本的代码可以看出，这些函数在声明上基本没什么差异，但是仔细看，两个版本的 &lt;strong&gt;run()&lt;/strong&gt; 函数声明的是不是不一样？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Qt4.0.1版本&lt;strong&gt;run()&lt;/strong&gt; 函数是纯虚函数，即此类为抽象类不可以创建实例，只可以创建指向该类的指针，也就是说如果你需要使用QThread来实现多线程，就必须实现QThread的派生类并且实现 &lt;strong&gt;run()&lt;/strong&gt; 函数；&lt;/li&gt;
&lt;li&gt;Qt5.6.2版本的&lt;strong&gt;run()&lt;/strong&gt; 函数是虚函数，继承QThread类时，可以重新实现 &lt;strong&gt;run()&lt;/strong&gt; 函数，也可以不实现。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;注：我查看了多个Qt版本的源码，发现出现以上差异的版本是从Qt4.4开始的。从Qt4.4版本开始，QThread类就不再是抽象类了。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;22-qthreadstart源码&quot;&gt;2.2 QThread::start()源码&lt;/h2&gt;
&lt;p&gt;再来看看QThread::start()源码，Qt4.0.1版本和Qt5.6.2版本此部分的源码大同小异，所以以Qt5.6.2版本的源码为主，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void QThread::start(Priority priority)
{
    Q_D(QThread);
    QMutexLocker locker(&amp;amp;d-&amp;gt;mutex);
 
    if (d-&amp;gt;isInFinish) {
        locker.unlock();
        wait();
        locker.relock();
    }
 
    if (d-&amp;gt;running)
        return;
        
    ... ... // 此部分是d指针配置
 
#ifndef Q_OS_WINRT

    ... ... // 此部分为注释
    
    d-&amp;gt;handle = (Qt::HANDLE) _beginthreadex(NULL, d-&amp;gt;stackSize, QThreadPrivate::start,
                                            this, CREATE_SUSPENDED, &amp;amp;(d-&amp;gt;id));
#else // !Q_OS_WINRT
    d-&amp;gt;handle = (Qt::HANDLE) CreateThread(NULL, d-&amp;gt;stackSize, (LPTHREAD_START_ROUTINE)QThreadPrivate::start,
                                            this, CREATE_SUSPENDED, reinterpret_cast&amp;lt;LPDWORD&amp;gt;(&amp;amp;d-&amp;gt;id));
#endif // Q_OS_WINRT
 
    if (!d-&amp;gt;handle) {
        qErrnoWarning(errno, &quot;QThread::start: Failed to create thread&quot;);
        d-&amp;gt;running = false;
        d-&amp;gt;finished = true;
        return;
    }
 
    int prio;
    d-&amp;gt;priority = priority;
    switch (d-&amp;gt;priority) {
    
    ... ... // 此部分为线程优先级配置
    
    case InheritPriority:
    default:
        prio = GetThreadPriority(GetCurrentThread());
        break;
    }
 
    if (!SetThreadPriority(d-&amp;gt;handle, prio)) {
        qErrnoWarning(&quot;QThread::start: Failed to set thread priority&quot;);
    }
 
    if (ResumeThread(d-&amp;gt;handle) == (DWORD) -1) {
        qErrnoWarning(&quot;QThread::start: Failed to resume new thread&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;挑出里面的重点来说明：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）Q_D()宏定义&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在看源码的时候，当时比较好奇start函数的第一条语句 &lt;strong&gt;Q_D()宏定义&lt;/strong&gt; 是什么意思，所以就看了下源码，在此也顺便讲讲，&lt;strong&gt;Q_D()&lt;/strong&gt; 源码是一个&lt;strong&gt;宏定义&lt;/strong&gt;，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#define Q_D(Class) Class##Private * const d = d_func()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此处利用了预处理宏里的 ## 操作符：连接前后两个符号，变成一个新的符号。将Q_D(QThread)展开后，变成：QThreadPrivate * const d = d_func()。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）_beginthreadex()函数&lt;/strong&gt;&lt;br/&gt;上面d-&amp;gt;handle = (Qt::HANDLE) _beginthreadex ( NULL, d-&amp;gt;stackSize, QThreadPrivate::start, this, CREATE_SUSPENDED, &amp;amp;( d-&amp;gt;id ) ) 语句中的函数是创建线程的函数，其原型以及各参数的说明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;unsigned long _beginthreadex( 
 
void *security,       // 安全属性，NULL为默认安全属性
 
unsigned stack_size,  // 指定线程堆栈的大小。如果为0，则线程堆栈大小和创建它的线程的相同。一般用0
 
unsigned ( __stdcall *start_address )( void * ), 
                      // 指定线程函数的地址，也就是线程调用执行的函数地址(用函数名称即可，函数名称就表示地址)
 
void *arglist,        // 传递给线程的参数的指针，可以通过传入对象的指针，在线程函数中再转化为对应类的指针
                        //如果传入this，这个this表示调用QThread::start的对象地址，也就是QThread或者其派生类对象本身
 
unsigned initflag,    // 线程初始状态，0:立即运行；CREATE_SUSPEND：suspended（悬挂）
 
unsigned *thrdaddr    // 用于记录线程ID的地址
 
);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;23-qthreadprivatestart源码&quot;&gt;2.3 QThreadPrivate::start()源码&lt;/h2&gt;
&lt;p&gt;从QThread::start()源码可以知道，QThreadPrivate::start是重点，其实际就是调用了QThreadPrivate::start(this)，这个 &lt;strong&gt;this&lt;/strong&gt; 表示调用QThread::start的对象地址，也就是QThread或者其派生类对象本身。因为两个Qt版本此部分的源码大同小异，所以本部分主要是以5.6.2版本的源码为主，其源码以及说明如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;// 参数arg就是上面所说的this
unsigned int __stdcall QT_ENSURE_STACK_ALIGNED_FOR_SSE QThreadPrivate::start(void *arg)
{
    QThread *thr = reinterpret_cast&amp;lt;QThread *&amp;gt;(arg);
    QThreadData *data = QThreadData::get2(thr);
 
    // 创建线程局部存储变量，存放线程id
    qt_create_tls();
    TlsSetValue(qt_current_thread_data_tls_index, data);
    data-&amp;gt;threadId = reinterpret_cast&amp;lt;Qt::HANDLE&amp;gt;(quintptr(GetCurrentThreadId()));
 
    QThread::setTerminationEnabled(false);
 
    {
        QMutexLocker locker(&amp;amp;thr-&amp;gt;d_func()-&amp;gt;mutex);
        data-&amp;gt;quitNow = thr-&amp;gt;d_func()-&amp;gt;exited;
    }
 
    if (data-&amp;gt;eventDispatcher.load()) // custom event dispatcher set?
        data-&amp;gt;eventDispatcher.load()-&amp;gt;startingUp();
    else
        createEventDispatcher(data);
        
    ...//省略
    
    emit thr-&amp;gt;started(QThread::QPrivateSignal()); // 发射线程启动信号
    QThread::setTerminationEnabled(true);
    thr-&amp;gt;run(); // 调用QThread::run()函数 -- 线程函数
 
    finish(arg); //结束线程
    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由上述源码可以看出，实际上 &lt;strong&gt;run()&lt;/strong&gt; 函数是在这里调用的，并且发出了 &lt;strong&gt;started()&lt;/strong&gt; 启动信号，等到 &lt;strong&gt;run()&lt;/strong&gt; 函数执行完毕，最后是调用了 &lt;strong&gt;QThreadPrivate::finish&lt;/strong&gt; 函数结束线程，并且在finish内会发出 &lt;strong&gt;QThread::finished()&lt;/strong&gt; 线程已结束的信号。&lt;/p&gt;
&lt;h2 id=&quot;24-qthreadrun源码&quot;&gt;2.4 QThread::run()源码&lt;/h2&gt;
&lt;p&gt;再看看QThread::run()函数的源码。在上面 《2.1 QThread类的定义源码》的小节，我们可以看到两个Qt版本声明此方法的方式不一样，Qt-4.0版本将此定义为了纯虚函数，而Qt-5.6版本将此定义为了虚函数，那我们就看看Qt-5.6版本中，QThread::run()是如何定义的，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void QThread::run()
{
    (void) exec();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;每一个 Qt 应用程序至少有一个 &lt;strong&gt;事件循环&lt;/strong&gt; ，就是调用了 &lt;strong&gt;QCoreApplication::exec()&lt;/strong&gt; 的那个事件循环。不过，QThread也可以开启事件循环。只不过这是一个受限于线程内部的事件循环。因此我们将处于调用main()函数的那个线程，并且由 &lt;strong&gt;QCoreApplication::exec()&lt;/strong&gt; 创建开启的那个事件循环成为 &lt;strong&gt;主事件循环&lt;/strong&gt; ，或者直接叫 &lt;strong&gt;主循环&lt;/strong&gt; 。注意，QCoreApplication::exec()只能在调用main()函数的线程调用。主循环所在的线程就是主线程，也被成为 GUI 线程，因为所有有关 GUI 的操作都必须在这个线程进行。QThread的局部事件循环则可以通过在 &lt;strong&gt;QThread::run()&lt;/strong&gt; 中调用 &lt;strong&gt;QThread::exec()&lt;/strong&gt; 开启。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;我们通过以上源码可以看到，它的定义很简单，就是调用了一个函数：&lt;strong&gt;QThread::exec()&lt;/strong&gt; 开启线程中的 &lt;strong&gt;事件循环&lt;/strong&gt; ，我们也可以通过继承QThread，重写run()函数的方式，让其实现相对复杂的逻辑代码。如果你的线程需要将某些槽函数在本线程完成的话，就必须开启事件循环，否则在线程内无法响应各种信号并作出相应的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;小结：&lt;/strong&gt; 比Qt-4.4版本更早的版本中，我们使用QThread启动线程时，就必须要实现继承于QThread的派生类，并且一定要重写run函数，若需要使用事件循环，就需要在run函数中添加exec()。到了Qt4.4版本之后（包括Qt4.4版本），QThread就不是抽象类了，不派生也可以实例化，在不重写QThread::run()方法，start启动线程是默认启动事件循环的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注：当程序跑到了exec()代码时，位于exec()后面的代码就不会再被执行，除非我们使用quit、exit等退出语句来退出事件循环，退出后，程序才会继续执行位于exec()后面的代码。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;25-qthreadquit、qthreadexit、qthreadterminate源码&quot;&gt;2.5 QThread::quit()、QThread::exit()、QThread::terminate()源码&lt;/h2&gt;
&lt;p&gt;线程停止函数的区别，从Qt源码来分析：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）QThread::quit()、QThread::exit()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//QThread::quit()声明
void quit();
//QThread::quit()定义
void QThread::quit()
{ exit(); }

//QThread::exit()声明
void exit(int retcode = 0);
//QThread::exit()定义
void QThread::exit(int returnCode)
{
    Q_D(QThread);
    QMutexLocker locker(&amp;amp;d-&amp;gt;mutex);
    d-&amp;gt;exited = true;
    d-&amp;gt;returnCode = returnCode;
    d-&amp;gt;data-&amp;gt;quitNow = true;
    for (int i = 0; i &amp;lt; d-&amp;gt;data-&amp;gt;eventLoops.size(); ++i) {
        QEventLoop *eventLoop = d-&amp;gt;data-&amp;gt;eventLoops.at(i);
        eventLoop-&amp;gt;exit(returnCode);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由以上源码可知，&lt;strong&gt;QThread::quit()&lt;/strong&gt; 和 &lt;strong&gt;QThread::exit(0)&lt;/strong&gt; 的调用是等效的，都是告诉线程的事件循环，以返回码0（成功）退出。如果线程没有事件，则此函数不执行任何操作，也就是无效的。当线程拥有事件循环并且正处于 &lt;strong&gt;事件循环（QThread::exec()）&lt;/strong&gt; 的状态时，调用 &lt;strong&gt;QThread::quit()或者QThread::exit()&lt;/strong&gt; 线程就会马上停止，否则不会立刻停止线程，直到线程处于事件循环也就是正在执行 &lt;strong&gt;QThread::exec()&lt;/strong&gt; 时，才会停止线程。&lt;/p&gt;
&lt;p&gt;如果重复调用 &lt;strong&gt;QThread::quit()或者QThread::exit()&lt;/strong&gt; 会有什么影响吗？&lt;br/&gt;重复调用 &lt;strong&gt;QThread::quit()或者QThread::exit()&lt;/strong&gt; 也不会有什么影响，因为只有拥有事件循环的线程，这两个函数才会生效停止线程的功能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）QThread::terminate()&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;void QThread::terminate()
{
    Q_D(QThread);
    QMutexLocker locker(&amp;amp;d-&amp;gt;mutex);
    if (!d-&amp;gt;running)
        return;
    if (!d-&amp;gt;terminationEnabled) {
        d-&amp;gt;terminatePending = true;
        return;
    }

// Calling ExitThread() in setTerminationEnabled is all we can do on WinRT
#ifndef Q_OS_WINRT
    TerminateThread(d-&amp;gt;handle, 0);
#endif
    QThreadPrivate::finish(this, false); //结束线程函数
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这个函数定义的最后一个语句，是调用了 &lt;strong&gt;QThreadPrivate::finish(this, false);&lt;/strong&gt; 函数，其函数作用是直接退出线程，无论线程是否开启了事件循环都会生效，会马上终止一个线程，但这个函数存在非常不安定因素，&lt;strong&gt;不推荐使用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果重复调用 &lt;strong&gt;QThread::terminate()&lt;/strong&gt; 会有什么影响吗？&lt;br/&gt;没有影响。我们可以看到函数体里面的第三条语句，它首先会判断线程是否还在运行中，如果不是，会直接退出函数，就不会继续往下执行调用&lt;strong&gt;QThreadPrivate::finish(this, false);&lt;/strong&gt; 函数了。&lt;/p&gt;
&lt;h2 id=&quot;26-章节小结&quot;&gt;2.6 章节小结&lt;/h2&gt;
&lt;p&gt;相信看了以上的一些QThread源码，都大概知道了QThread类的本质以及QThread开启到结束的过程。这里我再简单总结下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）QThread的本质：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;QThread 是用来管理线程的，它所依附的线程和它管理的线程并不是同一个东西；&lt;/li&gt;
&lt;li&gt;QThread 所依附的线程，就是执行 QThread t 或 QThread * t=new QThread 所在的线程；&lt;/li&gt;
&lt;li&gt;QThread 管理的线程，就是 run 启动的线程，也就是次线程。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;（2）在这里针对Qt4.4版本之后（包括Qt4.4版本）简单汇总一下线程启动到结束的过程：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;QThread对象或者QThread派生类对象显式调用QThread类中的外部start()方法；&lt;/li&gt;
&lt;li&gt;QThread::start()方法再调用QThreadPrivate::start()方法；&lt;/li&gt;
&lt;li&gt;在QThreadPrivate::start()方法内调用了QThread::run()虚函数，对使用者来说到了这里才是真正进入了一个新的线程里面。也就是说定义QThread对象或者QThread派生类对象的时候，还是在原来的线程里面，只有进入run函数才是进入了新的线程；&lt;/li&gt;
&lt;li&gt;在QThreadPrivate::start()方法调用QThread::run()虚函数结束后，就会继续调用QThreadPrivate::finish()函数来结束线程，并发出线程结束的信号finished()。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;（3）QThread::quit()、QThread::exit()、QThread::terminate()：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对线程重复使用这三个停止线程的函数，没有任何影响；&lt;/li&gt;
&lt;li&gt;尽量不要使用QThread::terminate()停止线程，此方式是强制退出线程，没有安全保障。&lt;/li&gt;
&lt;li&gt;调用QThread::quit()和QThread::exit()一样。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;（4）Qt各版本QThread类的变化：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Qt4.4版本之前QThread类是属于抽象类， Qt4.4版本之后（包括4.4版本）不是抽象类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Qt的多线程实现方法主要有四种形式：子类化QThread、子类化QObject+moveToThread、继承QRunnable+QThreadPool、QtConcurrent::run()+QThreadPool。本文章会注重介绍前两种实现方法：子类化QThread、子类化QObject+moveToThread，也会简单介绍后两种的使用。&lt;br/&gt;&lt;em&gt;&lt;strong&gt;注：QtConcurrent、QRunnable以及QThreadPool的类，在Qt-4.4版本才开始有。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;31-子类化qthread&quot;&gt;3.1 子类化QThread&lt;/h2&gt;
&lt;p&gt;子类化QThread来实现多线程， QThread只有run函数是在新线程里的，其他所有函数都在QThread生成的线程里。正确启动线程的方法是调用QThread::start()来启动，如果直接调用run成员函数，这个时候并不会有新的线程产生（ &lt;strong&gt;原因：&lt;/strong&gt; 可以查看第一章，run函数是怎么被调用的）&lt;/p&gt;
&lt;h3 id=&quot;311-步骤&quot;&gt;3.1.1 步骤&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;子类化 QThread；&lt;/li&gt;
&lt;li&gt;重写run，将耗时的事件放到此函数执行；&lt;/li&gt;
&lt;li&gt;根据是否需要事件循环，若需要就在run函数中调用 QThread::exec() ，开启线程的事件循环。事件循环的作用可以跳到《2.4 QThread::run()源码》小节进行阅读；&lt;/li&gt;
&lt;li&gt;为子类定义信号和槽，由于槽函数并不会在新开的线程运行，所以需要在构造函数中调用 moveToThread(this)。 &lt;em&gt;&lt;strong&gt;注意：虽然调用moveToThread(this)可以改变对象的线程依附性关系，但是QThread的大多数成员方法是线程的控制接口，QThread类的设计本意是将线程的控制接口供给旧线程（创建QThread对象的线程）使用。所以不要使用moveToThread()将该接口移动到新创建的线程中，调用moveToThread(this)被视为不好的实现。&lt;/strong&gt;&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来会通过《使用线程来实现计时器，并实时在UI上显示》的实例来说明不使用事件循环和使用事件循环的情况。（此实例使用QTimer会更方便，此处为了说明QThread的使用，故使用线程来实现）&lt;/p&gt;
&lt;h3 id=&quot;312-不使用事件循环实例&quot;&gt;3.1.2 不使用事件循环实例&lt;/h3&gt;
&lt;p&gt;InheritQThread.hpp&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;class InheritQThread:public QThread
{
    Q_OBJECT
public:
    InheritQThread(QObject *parent = Q_NULLPTR):QThread(parent){
        
    }
    
    void StopThread(){
        QMutexLocker lock(&amp;amp;m_lock);
        m_flag = false;
    }
    
protected:
    //线程执行函数
    void run(){
        qDebug()&amp;lt;&amp;lt;&quot;child thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();
        int i=0;
        m_flag = true;
        
        while(1)
        {
            ++i;
            emit ValueChanged(i); //发送信号不需要事件循环机制
            QThread::sleep(1);
            
            {
                QMutexLocker lock(&amp;amp;m_lock);
                if( !m_flag )
                    break;
            }
            
        }
    }
    
signals:
    void ValueChanged(int i);
    
public:
    bool m_flag;
    QMutex m_lock;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mainwindow.hpp&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;class MainWindow : public QMainWindow
{
    Q_OBJECT
public:
    explicit MainWindow(QWidget *parent = nullptr) :
        QMainWindow(parent),
        ui(new Ui::MainWindow){
        ui-&amp;gt;setupUi(this);
        
        qDebug()&amp;lt;&amp;lt;&quot;GUI thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();
        WorkerTh = new InheritQThread(this);
        connect(WorkerTh, &amp;amp;InheritQThread::ValueChanged, this, &amp;amp;MainWindow::setValue);
    }
    
    ~MainWindow(){
        delete ui;
    }
    
public slots:
    void setValue(int i){
        ui-&amp;gt;lcdNumber-&amp;gt;display(i);
    }
    
private slots:
    void on_startBt_clicked(){
        WorkerTh-&amp;gt;start();
    }
    
    void on_stopBt_clicked(){
        WorkerTh-&amp;gt;StopThread();
    }
    
    void on_checkBt_clicked(){
        if(WorkerTh-&amp;gt;isRunning()){
            ui-&amp;gt;label-&amp;gt;setText(&quot;Running&quot;);
        }else{
            ui-&amp;gt;label-&amp;gt;setText(&quot;Finished&quot;);
        }
    }
    
private:
    Ui::MainWindow *ui;
    InheritQThread *WorkerTh;
};
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;在使用多线程的时候，如果出现共享资源使用，需要注意资源抢夺的问题，例如上述InheritQThread类中m_flag变量就是一个多线程同时使用的资源，上面例子使用 &lt;strong&gt;QMutexLocker+QMutex&lt;/strong&gt; 的方式对临界资源进行安全保护使用，其实际是使用了 &lt;strong&gt;RAII技术：&lt;/strong&gt;（Resource Acquisition Is Initialization）,也称为“资源获取就是初始化”，是C++语言的一种管理资源、避免泄漏的惯用法。C++标准保证任何情况下，已构造的对象最终会销毁，即它的析构函数最终会被调用。简单的说，RAII 的做法是使用一个对象，在其构造时获取资源，在对象生命期控制对资源的访问使之始终保持有效，最后在对象析构的时候释放资源。具体 &lt;strong&gt;QMutexLocker+QMutex&lt;/strong&gt; 互斥锁的原理以及使用方法，在这里就不展开说了，这个知识点网上有很多非常好的文章。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）在不点【start】按键的时候，点击【check thread state】按钮检查线程状态，该线程是未开启的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084723787-1611914682.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）按下【start】后效果如下，并查看终端消息打印信息：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084733578-1903993697.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084741904-597783526.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;只有调用了QThread::start()后，子线程才是真正的启动，并且只有在run()函数才处于子线程内。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）我们再试一下点击【stop】按钮，然后检查线程的状态：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084759490-1692035963.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击【stop】按钮使 m_flag = false， 此时run函数也就可以跳出死循环，并且停止了线程的运作，之后我们就不能再次使用该线程了，也许有的人说，我再一次start不就好了吗？再一次start已经不是你刚才使用的线程了，这是start的是一个全新的线程。到此子类化 QThread ，不使用事件循环的线程使用就实现了，就这么简单。&lt;/p&gt;
&lt;h3 id=&quot;313-使用事件循环实例&quot;&gt;3.1.3 使用事件循环实例&lt;/h3&gt;
&lt;p&gt;run函数中的 while 或者 for 循环执行完之后，如果还想让线程保持运作，后期继续使用，那应该怎么做？&lt;br/&gt;可以启动子线程的事件循环，并且使用信号槽的方式继续使用子线程。&lt;strong&gt;注意：一定要使用信号槽的方式，否则函数依旧是在创建QThread对象的线程执行。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在run函数中添加QThread::exec()来启动事件循环。（&lt;em&gt;&lt;strong&gt;注意：&lt;/strong&gt; 在没退出事件循环时，QThread::exec()后面的语句都无法被执行，退出后程序会继续执行其后面的语句&lt;/em&gt;）；&lt;/li&gt;
&lt;li&gt;为QThread子类定义信号和槽；&lt;/li&gt;
&lt;li&gt;在QThread子类构造函数中调用 moveToThread(this)（&lt;em&gt;&lt;strong&gt;注意：&lt;/strong&gt; 可以实现构造函数在子线程内执行，但此方法不推荐，更好的方法会在后面提到&lt;/em&gt;）。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接着上述的实例，在InheritQThread类构造函数中添加并且调用moveToThread(this)；在run函数中添加exec()；并定义槽函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;/**************在InheritQThread构造函数添加moveToThread(this)**********/
InheritQThread(QObject *parent = Q_NULLPTR):QThread(parent){
        moveToThread(this); 
    }

/**************在InheritQThread::run函数添加exec()***************/
void run(){
    qDebug()&amp;lt;&amp;lt;&quot;child thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();

    int i=0;
    m_flag = true;

    while(1)
    {
        ++i;

        emit ValueChanged(i);
        QThread::sleep(1);

        {
            QMutexLocker lock(&amp;amp;m_lock);
            if( !m_flag )
                break;
        }
    }
    
    exec(); //开启事件循环
    }

/************在InheritQThread类中添加QdebugSlot()槽函数***************/
public slots:
    void QdebugSlot(){
        qDebug()&amp;lt;&amp;lt;&quot;QdebugSlot function is in thread:&quot;&amp;lt;&amp;lt;QThread::currentThreadId();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在MainWindow类中添加QdebugSignal信号；在构造函数中将QdebugSignal信号与InheritQThread::QdebugSlot槽函数进行绑；添加一个发送QdebugSignal信号的按钮：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;/**********在MainWindow构造函数中绑定信号槽******************/
explicit MainWindow(QWidget *parent = nullptr) :
    QMainWindow(parent),
    ui(new Ui::MainWindow){

    qDebug()&amp;lt;&amp;lt;&quot;GUI thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();

    ui-&amp;gt;setupUi(this);
    WorkerTh = new InheritQThread(this);
    connect(WorkerTh, &amp;amp;InheritQThread::ValueChanged, this, &amp;amp;MainWindow::setValue);
    connect(this, &amp;amp;MainWindow::QdebugSignal, WorkerTh, &amp;amp;InheritQThread::QdebugSlot); //绑定信号槽
}

/********MainWindow类中添加信号QdebugSignal槽以及按钮事件槽函数**********/
signals:
    void QdebugSignal(); //添加QdebugSignal信号
private slots:
    //按钮的事件槽函数
    void on_SendQdebugSignalBt_clicked()
    {
        emit QdebugSignal();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实现事件循环的程序已修改完成，来看下效果：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）在运行的时候为什么会出现以下警告？&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;QObject::moveToThread: Cannot move objects with a parent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看到MainWindow类中是这样定义InheritQThread类对象的：WorkerTh = new InheritQThread(this)。如果需要使用moveToThread()来改变对象的依附性，其创建时不能够带有父类。将语句改为：WorkerTh = new InheritQThread()即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）修改完成后，点击【start】启动线程，然后点击【stop】按钮跳出run函数中的while循环，最后点击【check thread state】按钮来检查线程的状态，会是什么样的情况呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084822289-897857122.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看到，线程依旧处于运行状态，这是因为run函数中调用了exec()，此时线程正处于事件循环中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）接下来再点击【Send QdebugSignal】按钮来发送QdebugSignal信号。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084830643-448237547.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由终端的打印信息得知，InheritQThread::QdebugSlot槽函数是在子线程中执行的。&lt;/p&gt;
&lt;h3 id=&quot;314-子类化qthread线程的信号与槽&quot;&gt;3.1.4 子类化QThread线程的信号与槽&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084845770-1197912301.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可知，事件循环是一个无止尽循环，事件循环结束之前，exec()函数后的语句无法得到执行。只有槽函数所在线程开启了事件循环，它才能在对应信号发射后被调用。无论事件循环是否开启，信号发送后会直接进入槽函数所依附的线程的事件队列，然而，只有开启了事件循环，对应的槽函数才会在线程中得到调用。下面通过几种情况来验证下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）代码和《3.1.3 使用事件循环》小节的代码一样，然后进行如下的操作：点击【start】按钮-&amp;gt;再点击【Send QdebugSignal】按钮，这个时候槽函数会不会被执行呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084858075-968799295.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084908085-1776056869.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这种情况无论点多少次发送QdebugSignal信号，InheritQThread::QdebugSlot槽函数都不会执行。因为当前线程还处于while循环当中，如果需要实现槽函数在当前线程中执行，那么当前线程就应该处于事件循环的状态，也就是正在执行exec()函数。所以如果需要InheritQThread::QdebugSlot槽函数执行，就需要点击【stop】按钮退出while循环，让线程进入事件循环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）在《3.1.3 使用事件循环》小节的代码基础上，把InheritQThread::run函数删除，然后进行如下的操作：点击【start】启动线程-&amp;gt;点击【stop】按钮跳出run函数中的while循环进入事件循环-&amp;gt;点击【Send QdebugSignal】按钮来发送QdebugSignal信号，会有什么结果呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;结果会和上面第一种情况一样，虽然信号已经在子线程的事件队列上，但是由于子线程没有事件循环，所以槽函数永远都不会被执行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（3）在上面《3.1.3 使用事件循环》小节的代码基础上，将InheritQThread构造函数中的 moveToThread(this) 去除掉。进行如下操作：点击【start】启动线程-&amp;gt;点击【stop】按钮跳出run函数中的while循环进入事件循环-&amp;gt;点击【Send QdebugSignal】按钮来发送QdebugSignal信号，会有什么结果呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084915634-2044996175.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图可以看出InheritQThread::QdebugSlot槽函数居然是在GUI主线程中执行了。因为InheritQThread对象我们是在主线程中new出来的，如果不使用moveToThread(this)来改变对象的依附性关系，那么InheritQThread对象就是属于GUI主线程，根据connect信号槽的执行规则，最终槽函数会在对象所依赖的线程中执行。&lt;strong&gt;信号与槽绑定的connect函数的细节会在后面的《跨线程的信号槽》章节进行单独介绍。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&quot;315-如何正确退出线程并释放资源&quot;&gt;3.1.5 如何正确退出线程并释放资源&lt;/h3&gt;
&lt;p&gt;InheritQThread类的代码不变动，和上述的代码一样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifndef INHERITQTHREAD_H
#define INHERITQTHREAD_H
#include &amp;lt;QThread&amp;gt;
#include &amp;lt;QMutex&amp;gt;
#include &amp;lt;QMutexLocker&amp;gt;
#include &amp;lt;QDebug&amp;gt;

class InheritQThread:public QThread
{
    Q_OBJECT

public:
    InheritQThread(QObject *parent = Q_NULLPTR):QThread(parent){
        moveToThread(this);
    }

    void StopThread(){
        QMutexLocker lock(&amp;amp;m_lock);
        m_flag = false;
    }

protected:
    //线程执行函数
    void run(){
        qDebug()&amp;lt;&amp;lt;&quot;child thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();

        int i=0;
        m_flag = true;

        while(1)
        {
            ++i;

            emit ValueChanged(i);
            QThread::sleep(1);

            {
                QMutexLocker lock(&amp;amp;m_lock);
                if( !m_flag )
                    break;
            }
        }

        exec();
    }

signals:
    void ValueChanged(int i);

public slots:
    void QdebugSlot(){
        qDebug()&amp;lt;&amp;lt;&quot;QdebugSlot function is in thread:&quot;&amp;lt;&amp;lt;QThread::currentThreadId();
    }

public:
    bool m_flag;
    QMutex m_lock;
};

#endif // INHERITQTHREAD_H
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;MainWindow类添加ExitBt、TerminateBt两个按钮，用于调用WorkerTh-&amp;gt;exit(0)、WorkerTh-&amp;gt;terminate()退出线程函数。由《2.5 QThread::quit()、QThread::exit()、QThread::terminate()源码》小节得知调用quit和exit是一样的，所以本处只添加了ExitBt按钮：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &amp;lt;QMainWindow&amp;gt;
#include &quot;ui_mainwindow.h&quot;
#include &quot;InheritQThread.h&quot;
#include &amp;lt;QThread&amp;gt;
#include &amp;lt;QDebug&amp;gt;

namespace Ui {
class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = nullptr) :
        QMainWindow(parent),
        ui(new Ui::MainWindow){

        qDebug()&amp;lt;&amp;lt;&quot;GUI thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();

        ui-&amp;gt;setupUi(this);
        WorkerTh = new InheritQThread();
        connect(WorkerTh, &amp;amp;InheritQThread::ValueChanged, this, &amp;amp;MainWindow::setValue);

        connect(this, &amp;amp;MainWindow::QdebugSignal, WorkerTh, &amp;amp;InheritQThread::QdebugSlot);
    }

    ~MainWindow(){
        delete ui;
    }

signals:
    void QdebugSignal();

public slots:
    void setValue(int i){
        ui-&amp;gt;lcdNumber-&amp;gt;display(i);
    }

private slots:
    void on_startBt_clicked(){
        WorkerTh-&amp;gt;start();
    }

    void on_stopBt_clicked(){
        WorkerTh-&amp;gt;StopThread();
    }

    void on_checkBt_clicked(){
        if(WorkerTh-&amp;gt;isRunning()){
            ui-&amp;gt;label-&amp;gt;setText(&quot;Running&quot;);
        }else{
            ui-&amp;gt;label-&amp;gt;setText(&quot;Finished&quot;);
        }
    }

    void on_SendQdebugSignalBt_clicked(){
        emit QdebugSignal();
    }

    void on_ExitBt_clicked(){
        WorkerTh-&amp;gt;exit(0);
    }

    void on_TerminateBt_clicked(){
        WorkerTh-&amp;gt;terminate();
    }

private:
    Ui::MainWindow *ui;
    InheritQThread *WorkerTh;
};

#endif // MAINWINDOW_H
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行上述的例程，点击【start】启动线程按钮，然后直接点击【exit(0)】或者【terminate()】，这样会直接退出线程吗？&lt;br/&gt;点击【exit(0)】按钮（猛点）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084923227-512934737.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;点击【terminate()】按钮（就点一点）&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084935659-119194312.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上述情况我们可以看到上面例程的线程启动之后，无论怎么点击【start】按钮，线程都不会退出，点击【terminate()】按钮的时候就会立刻退出当前线程。由《2.5 QThread::quit()、QThread::exit()、QThread::terminate()源码》小节可以得知，若使用QThread::quit()、QThread::exit()来退出线程，该线程就必须要在事件循环的状态（也就是正在执行exec()），线程才会退出。而QThread::terminate()不管线程处于哪种状态都会强制退出线程，但这个函数存在非常多不安定因素，不推荐使用。我们下面来看看如何正确退出线程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）如何正确退出线程？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果线程内没有事件循环，那么只需要用一个标志变量来跳出run函数的while循环，这就可以正常退出线程了。&lt;/li&gt;
&lt;li&gt;如果线程内有事件循环，那么就需要调用QThread::quit()或者QThread::exit()来结束事件循环。像刚刚举的例程，不仅有while循环，循环后面又有exec()，那么这种情况就需要先让线程跳出while循环，然后再调用QThread::quit()或者QThread::exit()来结束事件循环。如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084943461-1339446051.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;注意：尽量不要使用QThread::terminate()来结束线程，这个函数存在非常多不安定因素。&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）如何正确释放线程资源？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;退出线程不代表线程的资源就释放了，退出线程只是把线程停止了而已，那么QThread类或者QThread派生类的资源应该如何释放呢？直接 delete QThread类或者派生类的指针吗？当然不能这样做，&lt;strong&gt;千万别手动delete线程指针，手动delete会发生不可预料的意外。理论上所有QObject都不应该手动delete，如果没有多线程，手动delete可能不会发生问题，但是多线程情况下delete非常容易出问题，那是因为有可能你要删除的这个对象在Qt的事件循环里还排队，但你却已经在外面删除了它，这样程序会发生崩溃。&lt;/strong&gt; 线程资源释放分为两种情况，一种是在创建QThread派生类时，添加了父对象，例如在MainWindow类中WorkerTh = new InheritQThread(this)让主窗体作为InheritQThread对象的父类；另一种是不设置任何父类，例如在MainWindow类中WorkerTh = new InheritQThread()。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;1、创建QThread派生类，有设置父类的情况：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这种情况，QThread派生类的资源都让父类接管了，当父对象被销毁时，QThread派生类对象也会被父类delete掉，我们无需显示delete销毁资源。但是子线程还没结束完，主线程就destroy掉了(WorkerTh的父类是主线程窗口，主线程窗口如果没等子线程结束就destroy的话，会顺手把WorkerTh也delete这时就会奔溃了)。 &lt;strong&gt;注意：这种情况不能使用moveToThread(this)改变对象的依附性。&lt;/strong&gt; 因此我们应该把上面MainWindow类的构造函数改为如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;~MainWindow(){
    WorkerTh-&amp;gt;StopThread();//先让线程退出while循环
    WorkerTh-&amp;gt;exit();//退出线程事件循环
    WorkerTh-&amp;gt;wait();//挂起当前线程，等待WorkerTh子线程结束
    delete ui;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;2、创建QThread派生类，没有设置父类的情况：&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;也就是没有任何父类接管资源了，又不能直接delete QThread派生类对象的指针，但是QObject类中有 &lt;strong&gt;void QObject::deleteLater () [slot]&lt;/strong&gt; 这个槽，这个槽非常有用，后面会经常用到它用于安全的线程资源销毁。我们通过以上的《2.3 QThreadPrivate::start()源码》小节可知线程结束之后会发出 &lt;strong&gt;QThread::finished()&lt;/strong&gt; 的信号，我们将这个信号和 &lt;strong&gt;deleteLater&lt;/strong&gt; 槽绑定，线程结束后调用deleteLater来销毁分配的内存。&lt;br/&gt;在MainWindow类构造函数中，添加以下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;connect(WorkerTh, &amp;amp;QThread::finished, WorkerTh, &amp;amp;QObject::deleteLater) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;~MainWindow()析构函数可以把 wait()函数去掉了，因为该线程的资源已经不是让主窗口来接管了。当我们启动线程之后，然后退出主窗口或者直接点击【stop】+【exit()】按钮的时候，会出现以下的警告：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QThread::wait: Thread tried to wait on itself
QThread: Destroyed while thread is still running
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了让子线程能够响应信号并在子线程执行槽函数，我们在InheritQThread类构造函数中添加了 &lt;strong&gt;moveToThread(this)&lt;/strong&gt; ，此方法是官方极其不推荐使用的方法。那么现在我们就遇到了由于这个方法引发的问题，我们把moveToThread(this)删除，程序就可以正常结束和释放资源了。那如果要让子线程能够响应信号并在子线程执行槽函数，这应该怎么做？在下面的章节会介绍一个官方推荐的《子类化QObject+moveToThread》的方法。&lt;/p&gt;
&lt;h3 id=&quot;316-小结&quot;&gt;3.1.6 小结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;QThread只有run函数是在新线程里；&lt;/li&gt;
&lt;li&gt;如果必须需要实现在线程内执行槽的情景，那就需要在QThread的派生类构造函数中调用moveToThread(this)，并且在run函数内执行QThread::exec()开启事件循环；（极其不推荐使用moveToThread(this)，下一节会介绍一种安全可靠的方法）&lt;/li&gt;
&lt;li&gt;若需要使用事件循环，需要在run函数中调用QThread::exec()；&lt;/li&gt;
&lt;li&gt;尽量不要使用terminate()来结束线程，可以使用bool标志位退出或者在线程处于事件循环时调用QThread::quit、QThread::exit来退出线程；&lt;/li&gt;
&lt;li&gt;善用QObject::deleteLater来进行内存管理；&lt;/li&gt;
&lt;li&gt;在QThread执行start函数之后，run函数还未运行完毕，再次start，不会发生任何结果；&lt;/li&gt;
&lt;li&gt;子类化QThread多线程的方法适用于后台执行长时间的耗时操作、单任务执行的、无需在线程内执行槽的情景。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;32-子类化qobjectmovetothread&quot;&gt;3.2 子类化QObject+moveToThread&lt;/h2&gt;
&lt;p&gt;从QThread源码可知，在Qt4.4之前，run 是纯虚函数，必须子类化QThread来实现run函数。而从Qt4.4开始，QThread不再支持抽象类，run 默认调用 QThread::exec() ，不需要子类化QThread，只需要子类化一个QObject，通过QObject::moveToThread将QObject派生类移动到线程中即可。这是官方推荐的方法，而且使用灵活、简单、安全可靠。如果线程要用到事件循环，使用继承QObject的多线程方法无疑是一个更好的选择。&lt;br/&gt;这个小节主要是说一下，子类化QObject+moveToThread的多线程使用方法以及一些注意问题，其中有很多细节的问题其实和《3.1 子类化QThread》这个小节是一样的，在这里就不再多说了，不明白的可以到上一节找找答案。&lt;/p&gt;
&lt;h3 id=&quot;321-步骤&quot;&gt;3.2.1 步骤&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;写一个继承QObject的类，将需要进行复杂耗时的逻辑封装到槽函数中，作为线程的入口，入口可以有多个；&lt;/li&gt;
&lt;li&gt;在旧线程创建QObject派生类对象和QThread对象，最好使用堆分配的方式创建(new)，并且最好不要为此两个对象设置父类，便于后期程序的资源管理；&lt;/li&gt;
&lt;li&gt;把obj通过moveToThread方法转移到新线程中，此时obj不能有任何的父类；&lt;/li&gt;
&lt;li&gt;把线程的finished信号和obj对象、QThread对象的 QObject::deleteLater 槽连接，这个信号槽必须连接，否则会内存泄漏；如果QObject的派生类和QThread类指针是需要重复使用，那么就需要处理由对象被销毁之前立即发出的 QObject::destroyed 信号，将两个指针设置为nullptr，避免出现野指针；&lt;/li&gt;
&lt;li&gt;将其他信号与QObject派生类槽连接，用于触发线程执行槽函数里的任务；&lt;/li&gt;
&lt;li&gt;初始化完后调用 QThread::start() 来启动线程，默认开启事件循环；&lt;/li&gt;
&lt;li&gt;在逻辑结束后，调用 QThread::quit 或者 QThread::exit 退出线程的事件循环。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;322-实例&quot;&gt;3.2.2 实例&lt;/h3&gt;
&lt;p&gt;写一个继承QObject的类：InheritQObject，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifndef INHERITQOBJECT_H
#define INHERITQOBJECT_H

#include &amp;lt;QObject&amp;gt;
#include &amp;lt;QThread&amp;gt;
#include &amp;lt;QMutex&amp;gt;
#include &amp;lt;QMutexLocker&amp;gt;
#include &amp;lt;QDebug&amp;gt;

class InheritQObject : public QObject
{
    Q_OBJECT
public:
    explicit InheritQObject(QObject *parent = 0) : QObject(parent){

    }

    //用于退出线程循环计时的槽函数
    void StopTimer(){
        qDebug()&amp;lt;&amp;lt;&quot;Exec StopTimer thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();
        QMutexLocker lock(&amp;amp;m_lock);
        m_flag = false;
    }

signals:
    void ValueChanged(int i);

public slots:
    void QdebugSlot(){
        qDebug()&amp;lt;&amp;lt;&quot;Exec QdebugSlot thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();
    }

    //计时槽函数
    void TimerSlot(){
        qDebug()&amp;lt;&amp;lt;&quot;Exec TimerSlot thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();

        int i=0;
        m_flag = true;

        while(1)
        {
            ++i;

            emit ValueChanged(i);
            QThread::sleep(1);

            {
                QMutexLocker lock(&amp;amp;m_lock);
                if( !m_flag )
                    break;
            }
        }
    }

private:
    bool m_flag;
    QMutex m_lock;
};

#endif // INHERITQOBJECT_H
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;mainwindow主窗口类，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &amp;lt;QMainWindow&amp;gt;
#include &quot;ui_mainwindow.h&quot;
#include &quot;InheritQObject.h&quot;
#include &amp;lt;QThread&amp;gt;

namespace Ui {
class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = 0) :
        QMainWindow(parent),
        ui(new Ui::MainWindow){

        qDebug()&amp;lt;&amp;lt;&quot;GUI thread = &quot;&amp;lt;&amp;lt;QThread::currentThreadId();

        ui-&amp;gt;setupUi(this);

        //创建QThread线程对象以及QObject派生类对象，注意：都不需要设置父类
        m_th = new QThread();
        m_obj = new InheritQObject();
        
        //改变m_obj的线程依附关系
        m_obj-&amp;gt;moveToThread(m_th);

        //释放堆空间资源
        connect(m_th, &amp;amp;QThread::finished, m_obj, &amp;amp;QObject::deleteLater);
        connect(m_th, &amp;amp;QThread::finished, m_th, &amp;amp;QObject::deleteLater);
        //设置野指针为nullptr
        connect(m_th, &amp;amp;QObject::destroyed, this, &amp;amp;MainWindow::SetPtrNullptr);
        connect(m_obj, &amp;amp;QObject::destroyed, this, &amp;amp;MainWindow::SetPtrNullptr);
        //连接其他信号槽，用于触发线程执行槽函数里的任务
        connect(this, &amp;amp;MainWindow::StartTimerSignal, m_obj, &amp;amp;InheritQObject::TimerSlot);
        connect(m_obj, &amp;amp;InheritQObject::ValueChanged, this, &amp;amp;MainWindow::setValue);
        connect(this, &amp;amp;MainWindow::QdebugSignal, m_obj, &amp;amp;InheritQObject::QdebugSlot);

        //启动线程，线程默认开启事件循环，并且线程正处于事件循环状态
        m_th-&amp;gt;start();
    }

    ~MainWindow(){
        delete ui;
    }

signals:
    void StartTimerSignal();
    void QdebugSignal();

private slots:
    //触发线程执行m_obj的计时槽函数
    void on_startBt_clicked(){
        emit StartTimerSignal();
    }

    //退出计时槽函数
    void on_stopBt_clicked(){
        m_obj-&amp;gt;StopTimer();
    }

    //检测线程状态
    void on_checkBt_clicked(){
        if(m_th-&amp;gt;isRunning()){
            ui-&amp;gt;label-&amp;gt;setText(&quot;Running&quot;);
        }else{
            ui-&amp;gt;label-&amp;gt;setText(&quot;Finished&quot;);
        }
    }

    void on_SendQdebugSignalBt_clicked(){
        emit QdebugSignal();
    }

    //退出线程
    void on_ExitBt_clicked(){
        m_th-&amp;gt;exit(0);
    }

    //强制退出线程
    void on_TerminateBt_clicked(){
        m_th-&amp;gt;terminate();
    }

    //消除野指针
    void SetPtrNullptr(QObject *sender){
        if(qobject_cast&amp;lt;QObject*&amp;gt;(m_th) == sender){
            m_th = nullptr;
            qDebug(&quot;set m_th = nullptr&quot;);
        }

        if(qobject_cast&amp;lt;QObject*&amp;gt;(m_obj) == sender){
            m_obj = nullptr;
            qDebug(&quot;set m_obj = nullptr&quot;);
        }
    }

    //响应m_obj发出的信号来改变时钟
    void setValue(int i){
            ui-&amp;gt;lcdNumber-&amp;gt;display(i);
    }

private:
    Ui::MainWindow *ui;
    QThread *m_th;
    InheritQObject *m_obj;
};

#endif // MAINWINDOW_H
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过以上的实例可以看到，我们无需重写 QThread::run 函数，也无需显式调用 QThread::exec 来启动线程的事件循环了，通过QT源码可以知道，只要调用 QThread::start 它就会自动执行 QThread::exec 来启动线程的事件循环。&lt;br/&gt;第一种多线程的创建方法（继承QThread的方法），如果run函数里面没有死循环也没有调用exec开启事件循环的话，就算调用了 QThread::start 启动线程，最终过一段时间，线程依旧是会退出，处于finished的状态。那么这种方式会出现这样的情况吗？我们直接运行上面的实例，然后过段时间检查线程的状态：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084952140-1219441197.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;发现线程是一直处于运行状态的。那接下来我们说一下应该怎么正确使用这种方式创建的线程并正确退出线程和释放资源。&lt;/p&gt;
&lt;h3 id=&quot;323-如何正确使用线程（信号槽）和创建线程资源&quot;&gt;3.2.3 如何正确使用线程（信号槽）和创建线程资源&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）如何正确使用线程？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果需要让线程去执行一些行为，那就必须要正确使用信号槽的机制来触发槽函数，其他的方式调用槽函数都只是在旧线程中执行，无法达到预想效果。在多线程中信号槽的细节，会在《三、跨线程的信号槽》章节来讲解，这里我们先简单说如何使用信号槽来触发线程执行任务先。&lt;br/&gt;通过以上的实例得知，MainWindow 构造函数中使用了connect函数将 StartTimerSignal() 信号和 InheritQObject::TimerSlot() 槽进行了绑定，代码语句如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;connect(this, &amp;amp;MainWindow::StartTimerSignal, m_obj, &amp;amp;InheritQObject::TimerSlot);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当点击【startTime】按钮发出 StartTimerSignal() 信号时，这个时候就会触发线程去执行 InheritQObject::TimerSlot() 槽函数进行计时。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113084959172-650294911.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上面的打印信息得知，InheritQObject::TimerSlot() 槽函数的确是在一个新的线程中执行了。在上面继承QThread的多线程方法中也有说到，在这个时候去执行QThread::exit或者是QThread::quit是无效的，退出的信号会一直挂在消息队列里，只有点击了【stopTime】按钮让线程退出 while 循环，并且线程进入到事件循环 ( exec() ) 中，才会生效，并退出线程。&lt;/p&gt;
&lt;p&gt;如果将【startTime】按钮不是发出 StartTimerSignal() 信号，而是直接执行InheritQObject::TimerSlot() 槽函数，会是怎么样的结果呢？代码修改如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//触发线程执行m_obj的计时槽函数
void on_startBt_clicked(){
    m_obj-&amp;gt;TimerSlot();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113085008398-1723558757.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113085018190-518922572.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们会发现界面已经卡死，InheritQObject::TimerSlot() 槽函数是在GUI主线程执行的，这就导致了GUI界面的事件循环无法执行，也就是界面无法被更新了，所以出现了卡死的现象。所以要使用信号槽的方式来触发线程工作才是有效的，不能够直接调用obj里面的成员函数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）如何正确创建线程资源？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一些资源我们可以直接在旧线程中创建（也就是不通过信号槽启动线程来创建资源），在新线程也可以直接使用，例如实例中的bool m_flag和QMutex m_lock变量都是在就线程中定义的，在新线程也可以使用。但是有一些资源，如果你需要在新线程中使用，那么就必须要在新线程创建，例如定时器、网络套接字等，下面以定时器作为例子，代码按照下面修改：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;/**********在InheritQObject类中添加QTimer *m_timer成员变量*****/
QTimer *m_timer;

/**********在InheritQObject构造函数创建QTimer实例*****/
m_timer = new QTimer();

/**********在InheritQObject::TimerSlot函数使用m_timer*****/
m_timer-&amp;gt;start(1000);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行点击【startTime】按钮的时候，会出现以下报错：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;QObject::startTimer: Timers cannot be started from another thread
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由此可知，QTimer是不可以跨线程使用的，所以将程序修改成如下，将QTimer的实例创建放到线程里面创建：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;/*********在InheritQObject类中添加Init的槽函数，将需要初始化创建的资源放到此处********/
public slots:
    void Init(){
        m_timer = new QTimer();
    }
    
/********在MainWindow类中添加InitSiganl()信号，并绑定信号槽***********/
//添加信号
signals:
    void InitSiganl();
    
//在MainWindow构造函数添加以下代码
connect(this, &amp;amp;MainWindow::InitSiganl, m_obj, &amp;amp;InheritQObject::Init); //连接信号槽
emit InitSiganl(); //发出信号，启动线程初始化QTimer资源
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样QTimer定时器就属于新线程，并且可以正常使用啦。网络套接字QUdpSocket、QTcpSocket等资源同理处理就可以了。&lt;/p&gt;
&lt;h3 id=&quot;324-如何正确退出线程并释放资源&quot;&gt;3.2.4 如何正确退出线程并释放资源&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;（1）如何正确退出线程？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;正确退出线程的方式，其实和上面《3.1.5 如何正确退出线程并释放资源》小节所讲到的差不多，就是要使用 quit 和 exit 来退出线程，避免使用 terminate 来强制结束线程，有时候会出现异常的情况。例如以上的实例，启动之后，直接点击 【terminate】按钮，界面就会出现卡死的现象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（2）如何正确释放线程资源？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在上面《3.1.5 如何正确退出线程并释放资源》小节也有讲到，千万别手动delete QThread类或者派生类的线程指针，手动delete会发生不可预料的意外。理论上所有QObject都不应该手动delete，如果没有多线程，手动delete可能不会发生问题，但是多线程情况下delete非常容易出问题，那是因为有可能你要删除的这个对象在Qt的事件循环里还排队，但你却已经在外面删除了它，这样程序会发生崩溃。所以需要 &lt;strong&gt;善用QObject::deleteLater 和 QObject::destroyed来进行内存管理&lt;/strong&gt;。如上面实例使用到的代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//释放堆空间资源
connect(m_th, &amp;amp;QThread::finished, m_obj, &amp;amp;QObject::deleteLater);
connect(m_th, &amp;amp;QThread::finished, m_th, &amp;amp;QObject::deleteLater);
//设置野指针为nullptr
connect(m_th, &amp;amp;QObject::destroyed, this, &amp;amp;MainWindow::SetPtrNullptr);
connect(m_obj, &amp;amp;QObject::destroyed, this, &amp;amp;MainWindow::SetPtrNullptr);

//消除野指针
void SetPtrNullptr(QObject *sender){
    if(qobject_cast&amp;lt;QObject*&amp;gt;(m_th) == sender){
        m_th = nullptr;
        qDebug(&quot;set m_th = nullptr&quot;);
    }

    if(qobject_cast&amp;lt;QObject*&amp;gt;(m_obj) == sender){
        m_obj = nullptr;
        qDebug(&quot;set m_obj = nullptr&quot;);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当我们调用线程的 quit 或者 exit 函数，并且线程到达了事件循环的状态，那么线程就会在结束并且发出 QThread::finished 的信号来触发 QObject::deleteLater 槽函数，QObject::deleteLater就会销毁系统为m_obj、m_th对象分配的资源。这个时候m_obj、m_th指针就属于野指针了，所以需要根据QObject类或者QObject派生类对象销毁时发出来的 QObject::destroyed 信号来设置m_obj、m_th指针为nullptr，避免野指针的存在。&lt;br/&gt;运行上面的实例，然后点击【exit】按钮，结果如下图：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113085026302-2041351292.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;325-小结&quot;&gt;3.2.5 小结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;这种QT多线程的方法，实现简单、使用灵活，并且思路清晰，相对继承于QThread类的方式更有可靠性，这种方法也是官方推荐的实现方法。如果线程要用到事件循环，使用继承QObject的多线程方法无疑是一个更好的选择；&lt;/li&gt;
&lt;li&gt;创建QObject派生类对象不能带有父类；&lt;/li&gt;
&lt;li&gt;调用QThread::start是默认启动事件循环；&lt;/li&gt;
&lt;li&gt;必须需要使用信号槽的方式使用线程；&lt;/li&gt;
&lt;li&gt;需要注意跨线资源的创建，例如QTimer、QUdpSocket等资源，如果需要在子线程中使用，必须要在子线程创建；&lt;/li&gt;
&lt;li&gt;要善用QObject::deleteLater 和 QObject::destroyed来进行内存管理 ；&lt;/li&gt;
&lt;li&gt;尽量避免使用terminate强制退出线程，若需要退出线程，可以使用quit或exit；&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;33-继承qrunnableqthreadpool&quot;&gt;3.3 继承QRunnable+QThreadPool&lt;/h2&gt;
&lt;p&gt;此方法个人感觉使用的相对较少，在这里只是简单介绍下使用的方法。我们可以根据使用的场景来选择方法。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;此方法和QThread的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;与外界通信方式不同。由于QThread是继承于QObject的，但QRunnable不是，所以在QThread线程中，可以直接将线程中执行的结果通过信号的方式发到主程序，而QRunnable线程不能用信号槽，只能通过别的方式，等下会介绍；&lt;/li&gt;
&lt;li&gt;启动线程方式不同。QThread线程可以直接调用start()函数启动，而QRunnable线程需要借助QThreadPool进行启动；&lt;/li&gt;
&lt;li&gt;资源管理不同。QThread线程对象需要手动去管理删除和释放，而QRunnable则会在QThreadPool调用完成后自动释放。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来就来看看QRunnable的用法、使用场景以及注意事项；&lt;/p&gt;
&lt;h3 id=&quot;331-步骤&quot;&gt;3.3.1 步骤&lt;/h3&gt;
&lt;p&gt;要使用QRunnable创建线程，步骤如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;继承QRunnable。和QThread使用一样， 首先需要将你的线程类继承于QRunnable；&lt;/li&gt;
&lt;li&gt;重写run函数。还是和QThread一样，需要重写run函数；&lt;/li&gt;
&lt;li&gt;使用QThreadPool启动线程。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;332-实例&quot;&gt;3.3.2 实例&lt;/h3&gt;
&lt;p&gt;继承于QRunnable的类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifndef INHERITQRUNNABLE_H
#define INHERITQRUNNABLE_H

#include &amp;lt;QRunnable&amp;gt;
#include &amp;lt;QWidget&amp;gt;
#include &amp;lt;QDebug&amp;gt;
#include &amp;lt;QThread&amp;gt;

class CusRunnable : public QRunnable
{
public:
    explicit CusRunnable(){
    }

    ~CusRunnable(){
        qDebug() &amp;lt;&amp;lt; __FUNCTION__;
    }

    void run(){
        qDebug() &amp;lt;&amp;lt; __FUNCTION__ &amp;lt;&amp;lt; QThread::currentThreadId();
        QThread::msleep(1000);
    }
};

#endif // INHERITQRUNNABLE_H
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;主界面类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifndef MAINWINDOW_H
#define MAINWINDOW_H

#include &amp;lt;QMainWindow&amp;gt;
#include &quot;ui_mainwindow.h&quot;
#include &quot;InheritQRunnable.h&quot;
#include &amp;lt;QThreadPool&amp;gt;
#include &amp;lt;QDebug&amp;gt;

namespace Ui {
class MainWindow;
}

class MainWindow : public QMainWindow
{
    Q_OBJECT

public:
    explicit MainWindow(QWidget *parent = 0) :
        QMainWindow(parent),
        ui(new Ui::MainWindow){
        ui-&amp;gt;setupUi(this);

        m_pRunnable = new CusRunnable();
        qDebug() &amp;lt;&amp;lt; __FUNCTION__  &amp;lt;&amp;lt; QThread::currentThreadId();
        QThreadPool::globalInstance()-&amp;gt;start(m_pRunnable);
    }

    ~MainWindow(){
        qDebug() &amp;lt;&amp;lt; __FUNCTION__ ;
        delete ui;
    }

private:
    Ui::MainWindow *ui;
    CusRunnable * m_pRunnable = nullptr;
};

#endif // MAINWINDOW_H
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;直接运行以上实例，结果输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;MainWindow 0x377c
run 0x66ac
~CusRunnable
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到这里打印的线程ID是不同的，说明是在不同线程中执行，而线程执行完后就自动进入到析构函数中， 不需要手动释放。&lt;/p&gt;
&lt;h3 id=&quot;333-启动线程的方式&quot;&gt;3.3.3 启动线程的方式&lt;/h3&gt;
&lt;p&gt;上面我们说到要启动QRunnable线程，需要QThreadPool配合使用，而调用方式有两种：全局线程池和非全局线程池。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）使用全局线程池启动&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;QThreadPool::globalInstance()-&amp;gt;start(m_pRunnable);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（2）使用非全局线程池启动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该方式可以控制线程最大数量， 以及其他设置，比较灵活，具体参照帮助文档。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;QThreadPool       threadpool;
threadpool.setMaxThreadCount(1);
threadpool.start(m_pRunnable);
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;334-如何与外界通信&quot;&gt;3.3.4 如何与外界通信&lt;/h3&gt;
&lt;p&gt;前面我们提到，因为QRunnable没有继承于QObject，所以没法使用信号槽与外界通信，那么，如果要在QRunnable线程中和外界通信怎么办呢，通常有两种做法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;使用多继承。让我们的自定义线程类同时继承于QRunnable和QObject，这样就可以使用信号和槽，但是多线程使用比较麻烦，特别是继承于自定义的类时，容易出现接口混乱，所以在项目中尽量少用多继承。&lt;/li&gt;
&lt;li&gt;使用QMetaObject::invokeMethod。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;接下来只介绍使用QMetaObject::invokeMethod来通信：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;QMetaObject::invokeMethod&lt;/strong&gt; 函数定义如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;static bool QMetaObject::invokeMethod(
                         QObject *obj, const char *member,
                         Qt::ConnectionType,
                         QGenericReturnArgument ret,
                         QGenericArgument val0 = QGenericArgument(Q_NULLPTR),
                         QGenericArgument val1 = QGenericArgument(),
                         QGenericArgument val2 = QGenericArgument(),
                         QGenericArgument val3 = QGenericArgument(),
                         QGenericArgument val4 = QGenericArgument(),
                         QGenericArgument val5 = QGenericArgument(),
                         QGenericArgument val6 = QGenericArgument(),
                         QGenericArgument val7 = QGenericArgument(),
                         QGenericArgument val8 = QGenericArgument(),
                         QGenericArgument val9 = QGenericArgument())；
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该函数就是尝试调用obj的member函数，可以是信号、槽或者Q_INVOKABLE声明的函数（能够被Qt元对象系统唤起），只需要将函数的名称传递给此函数，调用成功返回true，失败返回false。member函数调用的返回值放在ret中，如果调用是异步的，则不能计算返回值。你可以将最多10个参数（val0、val1、val2、val3、val4、val5、val6、val7、val8和val9）传递给member函数，必须使用Q_ARG()和Q_RETURN_ARG()宏封装参数，Q_ARG()接受类型名 + 该类型的常量引用；Q_RETURN_ARG()接受一个类型名 + 一个非常量引用。&lt;/p&gt;
&lt;p&gt;QMetaObject::invokeMethod可以是异步调用，也可以是同步调用。这取决与它的连接方式Qt::ConnectionType type：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果类型是Qt::DirectConnection，则会立即调用该成员，同步调用。&lt;/li&gt;
&lt;li&gt;如果类型是Qt::QueuedConnection，当应用程序进入主事件循环时，将发送一个QEvent并调用该成员，异步调用。&lt;/li&gt;
&lt;li&gt;如果类型是Qt::BlockingQueuedConnection，该方法将以与Qt::QueuedConnection相同的方式调用，不同的地方：当前线程将阻塞，直到事件被传递。使用此连接类型在同一线程中的对象之间通信将导致死锁。&lt;/li&gt;
&lt;li&gt;如果类型是Qt::AutoConnection，如果obj与调用者在同一线程，成员被同步调用；否则，它将异步调用该成员。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们在主界面中定一个函数，用于更新界面内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;Q_INVOKABLE void setText(QString msg){
    ui-&amp;gt;label-&amp;gt;setText(msg);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;继承于QRunnable的线程类，修改完成如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#ifndef INHERITQRUNNABLE_H
#define INHERITQRUNNABLE_H

#include &amp;lt;QRunnable&amp;gt;
#include &amp;lt;QWidget&amp;gt;
#include &amp;lt;QDebug&amp;gt;
#include &amp;lt;QThread&amp;gt;

class CusRunnable : public QRunnable
{
public:
    //修改构造函数
    explicit CusRunnable(QObject *obj):m_pObj(obj){
    }

    ~CusRunnable(){
        qDebug() &amp;lt;&amp;lt; __FUNCTION__;
    }

    void run(){
        qDebug() &amp;lt;&amp;lt; __FUNCTION__ &amp;lt;&amp;lt; QThread::currentThreadId();
        QMetaObject::invokeMethod(m_pObj,&quot;setText&quot;,Q_ARG(QString,&quot;hello world!&quot;)); //此处与外部通信
        QThread::msleep(1000);
    }

private:
    QObject * m_pObj = nullptr; //定义指针
};

#endif // INHERITQRUNNABLE_H
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建线程对象时，需要将主界面对象传入线程类，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;m_pRunnable = new CusRunnable(this);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;到这里也就实现了线程与外部通信了，运行效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2085020/202011/2085020-20201113085037182-1784973968.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;335-小结&quot;&gt;3.3.5 小结&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;使用该方法实现的多线程，线程中的资源无需用户手动释放，线程执行完后会自动回收资源；&lt;/li&gt;
&lt;li&gt;和继承QThread的方法一样需要继承类，并且重新实现run函数；&lt;/li&gt;
&lt;li&gt;需要结合QThreadPool线程池来使用；&lt;/li&gt;
&lt;li&gt;与外界通信可以使用如果使用信号槽机制会比较麻烦，可以使用QMetaObject::invokeMethod的方式与外界通信。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;34-qtconcurrentrunqthreadpool&quot;&gt;3.4 QtConcurrent::run()+QThreadPool&lt;/h2&gt;
&lt;p&gt;在QT开发的场景中，个人觉得此方法使用的也比较少，所以本文只作一个简单使用的介绍。QtConcurrent 是命名空间 (namespace)，它提供了高层次的函数接口 (APIs)，使所写程序，可根据计算机的 CPU 核数，自动调整运行的线程数目。本文以 Qt 中的 QtConcurrent::run() 函数为例，介绍如何将函数运行在单独的线程中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;（1）使用 QtConcurrent 模块，需要在 .pro 中添加：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;QT += concurrent
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（2）将一个普通函数运行在单独线程：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;#include &amp;lt;QApplication&amp;gt;
#include &amp;lt;QDebug&amp;gt;
#include &amp;lt;QThread&amp;gt;
#include &amp;lt;QtConcurrent&amp;gt;

void fun1(){
    qDebug()&amp;lt;&amp;lt;__FUNCTION__&amp;lt;&amp;lt;QThread::currentThread();
}

void fun2(QString str1, QString str2){
    qDebug()&amp;lt;&amp;lt;__FUNCTION__&amp;lt;&amp;lt;str1+str2&amp;lt;&amp;lt;QThread::currentThread();
}

int fun3(int i, int j){
    qDebug()&amp;lt;&amp;lt;__FUNCTION__&amp;lt;&amp;lt;QThread::currentThread();
    return i+j;
}

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);

    qDebug()&amp;lt;&amp;lt;__FUNCTION__&amp;lt;&amp;lt;QThread::currentThread();

    //无参数的普通函数
    QFuture&amp;lt;void&amp;gt; fut1 = QtConcurrent::run(fun1);

    //有参数的普通函数
    QFuture&amp;lt;void&amp;gt; fut2 = QtConcurrent::run(fun2, QString(&quot;Thread&quot;),QString(&quot; 2&quot;));

    //获取普通函数的返回值
    int i=1, j=2;
    QFuture&amp;lt;int&amp;gt; fut3 = QtConcurrent::run(fun3, i, j);
    qDebug()&amp;lt;&amp;lt;&quot;ret:&quot;&amp;lt;&amp;lt;fut3.result();

    //以上的例子，如果要为其指定线程池，可以将线程池的指针作为第一个参数传递进去
    QThreadPool pool;
    QFuture&amp;lt;void&amp;gt; fut4 = QtConcurrent::run(&amp;amp;pool, fun1);

    fut1.waitForFinished();
    fut2.waitForFinished();
    fut3.waitForFinished();
    fut4.waitForFinished();

    return a.exec();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;qMain QThread(0xf380590)
fun2 &quot;Thread 2&quot; QThread(0x1ca7c758, name = &quot;Thread (pooled)&quot;)
fun1 QThread(0x1ca7c6d8, name = &quot;Thread (pooled)&quot;)
fun3 QThread(0x1ca7c5b8, name = &quot;Thread (pooled)&quot;)
ret: 3
fun1 QThread(0x1ca7c438, name = &quot;Thread (pooled)&quot;)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;（3）将类中的成员函数单独运行在线程中：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;将类中的成员函数运行在某一个线程中，可将指向该类实例的引用或指针作为 QtConcurrent::run 的第一个参数传递进去，常量成员函数一般传递常量引用 (const reference)，而非常量成员函数一般传递指针 (pointer)。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;常量成员函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在一个单独的线程中，调用 QByteArray 的常量成员函数 split()，传递给 run() 函数的参数是 bytearray&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;//常量成员函数QByteArray::split()
QByteArray bytearray = &quot;hello,world&quot;;
QFuture&amp;lt;QList&amp;lt;QByteArray&amp;gt; &amp;gt; future = QtConcurrent::run(bytearray, &amp;amp;QByteArray::split, ',');
QList&amp;lt;QByteArray&amp;gt; result = future.result();
qDebug()&amp;lt;&amp;lt;&quot;result:&quot;&amp;lt;&amp;lt;result;
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;非常量成员函数&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在一个单独的线程中，调用 QImage 的非常量成员函数 invertPixels()，传递给 run() 函数的参数是 &amp;amp;image&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;QImage image = ...;
QFuture&amp;lt;void&amp;gt; future = QtConcurrent::run(&amp;amp;image, &amp;amp;QImage::invertPixels, QImage::InvertRgba);
...
future.waitForFinished();  // At this point, the pixels in 'image' have been inverted
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;线程的信号槽机制需要开启线程的事件循环机制，即调用QThread::exec()函数开启线程的事件循环。&lt;/p&gt;
&lt;p&gt;Qt信号-槽连接函数原型如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;bool QObject::connect ( const QObject * sender, const char * signal, const QObject * receiver, const char *method, Qt::ConnectionType type = Qt::AutoConnection ) 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Qt支持5种连接方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Qt::DirectConnection（直连方式）&lt;/strong&gt;（信号与槽函数关系类似于函数调用，同步执行）&lt;br/&gt;当信号发出后，相应的槽函数将立即被调用。emit语句后的代码将在所有槽函数执行完毕后被执行。当信号发射时，槽函数将直接被调用。无论槽函数所属对象在哪个线程，槽函数都在发射信号的线程内执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Qt::QueuedConnection（队列方式）&lt;/strong&gt;（此时信号被塞到事件队列里，信号与槽函数关系类似于消息通信，异步执行）&lt;br/&gt;当信号发出后，排队到信号队列中，需等到接收对象所属线程的事件循环取得控制权时才取得该信号，调用相应的槽函数。emit语句后的代码将在发出信号后立即被执行，无需等待槽函数执行完毕。当控制权回到接收者所依附线程的事件循环时，槽函数被调用。槽函数在接收者所依附线程执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Qt::AutoConnection（自动方式）&lt;/strong&gt; &lt;br/&gt;Qt的默认连接方式，如果信号的发出和接收信号的对象同属一个线程，那个工作方式与直连方式相同；否则工作方式与队列方式相同。如果信号在接收者所依附的线程内发射，则等同于直接连接如果发射信号的线程和接受者所依附的线程不同，则等同于队列连接&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Qt::BlockingQueuedConnection&lt;/strong&gt;（信号和槽必须在不同的线程中，否则就产生死锁) &lt;br/&gt;槽函数的调用情形和Queued Connection相同，不同的是当前的线程会阻塞住，直到槽函数返回。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Qt::UniqueConnection&lt;/strong&gt;&lt;br/&gt;与默认工作方式相同，只是不能重复连接相同的信号和槽，因为如果重复连接就会导致一个信号发出，对应槽函数就会执行多次。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果没有特殊的要求我们connect函数选择默认的连接方式就好，也就是connect的第五个参数不填写就ok，例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-cpp&quot;&gt;connect(m_obj, &amp;amp;QObject::destroyed, this, &amp;amp;MainWindow::SetPtrNullptr);
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;本文章分析了部分QThread源码，讲解了四种QT多线程的实现方法，以及多线程信号槽连接的知识点。接下来我再简单对以上四种QT多线程的实现方法，总结一下哪种情况该使用哪种 Qt 线程技术：&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;需要线程的生命周期&lt;/th&gt;
&lt;th&gt;开发场景&lt;/th&gt;
&lt;th&gt;解决方案&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;10&quot;&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;单次调用&lt;/td&gt;
&lt;td&gt;在其他的线程中运行一个方法，当方法运行结束后退出线程。&lt;/td&gt;
&lt;td&gt;（1）编写一个函数，然后利用 QtConcurrent::run()运行它；（2）从QRunnable 派生一个类，并利用全局线程池QThreadPool::globalInstance()-&amp;gt;start()来运行它。（3） 从QThread派生一个类, 重载QThread::run() 方法并使用QThread::start()来运行它。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;单次调用&lt;/td&gt;
&lt;td&gt;一个耗时的操作必须放到另一个线程中运行。在这期间，状态信息必须发送到GUI线程中。&lt;/td&gt;
&lt;td&gt;使用 QThread,，重载run方法并根据情况发送信号。.使用queued信号/槽连接来连接信号与GUI线程的槽。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;常驻&lt;/td&gt;
&lt;td&gt;有一对象位于另一个线程中，将让其根据不同的请求执行不同的操作。这意味与工作者线程之间的通信是必须的。&lt;/td&gt;
&lt;td&gt;从QObject 派生一个类并实现必要的槽和信号，将对象移到一个具有事件循环的线程中，并通过queued信号/槽连接与对象进行通信。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;当然QT还有其他实现多线程的方法，例如使用QtConcurrent::map()函数、QSocketNotifier，具体怎么使用，这里就不再过多介绍了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;这个是本文章实例的源码地址：&lt;a href=&quot;https://gitee.com/CogenCG/QThreadExample.git&quot;&gt;https://gitee.com/CogenCG/QThreadExample.git&lt;/a&gt;&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Nov 2020 00:52:00 +0000</pubDate>
<dc:creator>李春港</dc:creator>
<og:description>一、前言 在我们开发Qt程序时，会经常用到多线程和信号槽的机制，将耗时的事务放到单独的线程，将其与GUI线程独立开，然后通过信号槽的机制来进行数据通信，避免GUI界面假死的情况。例如：使用QT实现文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/lcgbk/p/13967448.html</dc:identifier>
</item>
<item>
<title>从规范的角度解析对象 — 原始值转换 - 技术漫谈</title>
<link>http://www.cnblogs.com/leviding/p/13967450.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leviding/p/13967450.html</guid>
<description>&lt;p&gt;对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。这里有三种类型（hint）：&quot;string&quot;，&quot;number&quot; 和 &quot;default&quot;。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;206.71251964379&quot;&gt;

&lt;p&gt;当对象相加 &lt;code&gt;obj1 + obj2&lt;/code&gt;，相减 &lt;code&gt;obj1 - obj2&lt;/code&gt;，或者使用 &lt;code&gt;alert(obj)&lt;/code&gt; 打印时会发生什么？&lt;/p&gt;
&lt;p&gt;在这种情况下，对象会被自动转换为原始值，然后执行操作。&lt;/p&gt;
&lt;p&gt;在 &lt;a href=&quot;https://zh.javascript.info/object-toprimitive&quot;&gt;类型转换&lt;/a&gt; 一章中，我们已经看到了数值，字符串和布尔转换的规则。但是我们没有讲对象的转换规则。现在我们已经掌握了方法（method）和 symbol 的相关知识，可以开始学习对象原始值转换了。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;所有的对象在布尔上下文（context）中均为 &lt;code&gt;true&lt;/code&gt;。所以对于对象，不存在 to-boolean 转换，只有字符串和数值转换。&lt;/li&gt;
&lt;li&gt;数值转换发生在对象相减或应用数学函数时。例如，&lt;code&gt;Date&lt;/code&gt; 对象（将在 &lt;a href=&quot;https://zh.javascript.info/date&quot;&gt;日期和时间&lt;/a&gt; 一章中介绍）可以相减，&lt;code&gt;date1 - date2&lt;/code&gt; 的结果是两个日期之间的差值。&lt;/li&gt;
&lt;li&gt;至于字符串转换 —— 通常发生在我们像 &lt;code&gt;alert(obj)&lt;/code&gt; 这样输出一个对象和类似的上下文中。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;toprimitive&quot;&gt;ToPrimitive&lt;/h2&gt;
&lt;p&gt;我们可以使用特殊的对象方法，对字符串和数值转换进行微调。&lt;/p&gt;
&lt;p&gt;下面是三个类型转换的变体，被称为 &quot;hint&quot;，在 &lt;a href=&quot;https://tc39.github.io/ecma262/#sec-toprimitive&quot;&gt;规范&lt;/a&gt; 中有详细介绍（译注：当一个对象被用在需要原始值的上下文中时，例如，在 &lt;code&gt;alert&lt;/code&gt; 或数学运算中，对象会被转换为原始值）：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;&quot;string&quot;&lt;/code&gt;: 对象到字符串的转换，当我们对期望一个字符串的对象执行操作时，如 &quot;alert&quot;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// 输出
alert(obj);

// 将对象作为属性键
anotherObj[obj] = 123;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&quot;number&quot;&lt;/code&gt;: 对象到数字的转换，例如当我们进行数学运算时：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// 显式转换
let num = Number(obj);

// 数学运算（除了二进制加法）
let n = +obj; // 一元加法
let delta = date1 - date2;

// 小于/大于的比较
let greater = user1 &amp;gt; user2;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;&quot;default&quot;&lt;/code&gt;: 在少数情况下发生，当运算符“不确定”期望值的类型时。&lt;/p&gt;
&lt;p&gt;例如，二进制加法 &lt;code&gt;+&lt;/code&gt; 可用于字符串（连接），也可以用于数字（相加），所以字符串和数字这两种类型都可以。因此，当二元加法得到对象类型的参数时，它将依据 &lt;code&gt;&quot;default&quot;&lt;/code&gt; hint 来对其进行转换。&lt;/p&gt;
&lt;p&gt;此外，如果对象被用于与字符串、数字或 symbol 进行 &lt;code&gt;==&lt;/code&gt; 比较，这时到底应该进行哪种转换也不是很明确，因此使用 &lt;code&gt;&quot;default&quot;&lt;/code&gt; hint。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;// 二元加法使用默认 hint
let total = obj1 + obj2;

// obj == number 使用默认 hint
if (user == 1) { ... };
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;像 &lt;code&gt;&amp;lt;&lt;/code&gt; 和 &lt;code&gt;&amp;gt;&lt;/code&gt; 这样的小于/大于比较运算符，也可以同时用于字符串和数字。不过，它们使用 &quot;number&quot; hint，而不是 &quot;default&quot;。这是历史原因。&lt;/p&gt;
&lt;p&gt;实际上，我们没有必要记住这些奇特的细节，除了一种情况（&lt;code&gt;Date&lt;/code&gt; 对象，我们稍后会学到它）之外，所有内建对象都以和 &lt;code&gt;&quot;number&quot;&lt;/code&gt; 相同的方式实现 &lt;code&gt;&quot;default&quot;&lt;/code&gt; 转换。我们也可以这样做。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;没有 &quot;boolean&quot; hint&lt;/strong&gt;&lt;br/&gt;请注意 —— 只有三种 hint。就这么简单。&lt;/p&gt;
&lt;p&gt;没有 &quot;boolean&quot; hint（在布尔上下文中所有对象都是 &lt;code&gt;true&lt;/code&gt;）或其他任何东西。如果我们将 &lt;code&gt;&quot;default&quot;&lt;/code&gt; 和 &lt;code&gt;&quot;number&quot;&lt;/code&gt; 视为相同，就像大多数内建函数一样，那么就只有两种转换了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为了进行转换，JavaScript 尝试查找并调用三个对象方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用 &lt;code&gt;obj[Symbol.toPrimitive](hint)&lt;/code&gt; —— 带有 symbol 键 &lt;code&gt;Symbol.toPrimitive&lt;/code&gt;（系统 symbol）的方法，如果这个方法存在的话，&lt;/li&gt;
&lt;li&gt;否则，如果 hint 是 &lt;code&gt;&quot;string&quot;&lt;/code&gt; —— 尝试 &lt;code&gt;obj.toString()&lt;/code&gt; 和 &lt;code&gt;obj.valueOf()&lt;/code&gt;，无论哪个存在。&lt;/li&gt;
&lt;li&gt;否则，如果 hint 是 &lt;code&gt;&quot;number&quot;&lt;/code&gt; 或 &lt;code&gt;&quot;default&quot;&lt;/code&gt; —— 尝试 &lt;code&gt;obj.valueOf()&lt;/code&gt; 和 &lt;code&gt;obj.toString()&lt;/code&gt;，无论哪个存在。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;symboltoprimitive&quot;&gt;Symbol.toPrimitive&lt;/h2&gt;
&lt;p&gt;我们从第一个方法开始。有一个名为 &lt;code&gt;Symbol.toPrimitive&lt;/code&gt; 的内建 symbol，它被用来给转换方法命名，像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;obj[Symbol.toPrimitive] = function(hint) {
  // 返回一个原始值
  // hint = &quot;string&quot;、&quot;number&quot; 和 &quot;default&quot; 中的一个
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;例如，这里 &lt;code&gt;user&lt;/code&gt; 对象实现了它：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;let user = {
  name: &quot;John&quot;,
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == &quot;string&quot; ? `{name: &quot;${this.name}&quot;}` : this.money;
  }
};

// 转换演示：
alert(user); // hint: string -&amp;gt; {name: &quot;John&quot;}
alert(+user); // hint: number -&amp;gt; 1000
alert(user + 500); // hint: default -&amp;gt; 1500
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从代码中我们可以看到，根据转换的不同，&lt;code&gt;user&lt;/code&gt; 变成一个自描述字符串或者一个金额。单个方法 &lt;code&gt;user[Symbol.toPrimitive]&lt;/code&gt; 处理了所有的转换情况。&lt;/p&gt;
&lt;h2 id=&quot;tostringvalueof&quot;&gt;toString/valueOf&lt;/h2&gt;
&lt;p&gt;方法 &lt;code&gt;toString&lt;/code&gt; 和 &lt;code&gt;valueOf&lt;/code&gt; 来自上古时代。它们不是 symbol（那时候还没有 symbol 这个概念），而是“常规的”字符串命名的方法。它们提供了一种可选的“老派”的实现转换的方法。&lt;/p&gt;
&lt;p&gt;如果没有 &lt;code&gt;Symbol.toPrimitive&lt;/code&gt;，那么 JavaScript 将尝试找到它们，并且按照下面的顺序进行尝试：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;对于 &quot;string&quot; hint，&lt;code&gt;toString -&amp;gt; valueOf&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;其他情况，&lt;code&gt;valueOf -&amp;gt; toString&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些方法必须返回一个原始值。如果 &lt;code&gt;toString&lt;/code&gt; 或 &lt;code&gt;valueOf&lt;/code&gt; 返回了一个对象，那么返回值会被忽略（和这里没有方法的时候相同）。&lt;/p&gt;
&lt;p&gt;默认情况下，普通对象具有 &lt;code&gt;toString&lt;/code&gt; 和 &lt;code&gt;valueOf&lt;/code&gt; 方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;toString&lt;/code&gt; 方法返回一个字符串 &lt;code&gt;&quot;[object Object]&quot;&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;valueOf&lt;/code&gt; 方法返回对象自身。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面是一个示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;let user = {name: &quot;John&quot;};

alert(user); // [object Object]
alert(user.valueOf() === user); // true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;所以，如果我们尝试将一个对象当做字符串来使用，例如在 &lt;code&gt;alert&lt;/code&gt; 中，那么在默认情况下我们会看到 &lt;code&gt;[object Object]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里提到默认值 &lt;code&gt;valueOf&lt;/code&gt; 只是为了完整起见，以避免混淆。正如你看到的，它返回对象本身，因此被忽略。别问我为什么，那是历史原因。所以我们可以假设它根本就不存在。&lt;/p&gt;
&lt;p&gt;让我们实现一下这些方法。&lt;/p&gt;
&lt;p&gt;例如，这里的 &lt;code&gt;user&lt;/code&gt; 执行和前面提到的那个 &lt;code&gt;user&lt;/code&gt; 一样的操作，使用 &lt;code&gt;toString&lt;/code&gt; 和 &lt;code&gt;valueOf&lt;/code&gt; 的组合（而不是 &lt;code&gt;Symbol.toPrimitive&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;let user = {
  name: &quot;John&quot;,
  money: 1000,

  // 对于 hint=&quot;string&quot;
  toString() {
    return `{name: &quot;${this.name}&quot;}`;
  },

  // 对于 hint=&quot;number&quot; 或 &quot;default&quot;
  valueOf() {
    return this.money;
  }

};

alert(user); // toString -&amp;gt; {name: &quot;John&quot;}
alert(+user); // valueOf -&amp;gt; 1000
alert(user + 500); // valueOf -&amp;gt; 1500
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，执行的动作和前面使用 &lt;code&gt;Symbol.toPrimitive&lt;/code&gt; 的那个例子相同。&lt;/p&gt;
&lt;p&gt;通常我们希望有一个“全能”的地方来处理所有原始转换。在这种情况下，我们可以只实现 &lt;code&gt;toString&lt;/code&gt;，就像这样：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;let user = {
  name: &quot;John&quot;,

  toString() {
    return this.name;
  }
};

alert(user); // toString -&amp;gt; John
alert(user + 500); // toString -&amp;gt; John500
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果没有 &lt;code&gt;Symbol.toPrimitive&lt;/code&gt; 和 &lt;code&gt;valueOf&lt;/code&gt;，&lt;code&gt;toString&lt;/code&gt; 将处理所有原始转换。&lt;/p&gt;
&lt;h2 id=&quot;返回类型&quot;&gt;返回类型&lt;/h2&gt;
&lt;p&gt;关于所有原始转换方法，有一个重要的点需要知道，就是它们不一定会返回 &quot;hint&quot; 的原始值。&lt;/p&gt;
&lt;p&gt;没有限制 &lt;code&gt;toString()&lt;/code&gt; 是否返回字符串，或 &lt;code&gt;Symbol.toPrimitive&lt;/code&gt; 方法是否为 hint &quot;number&quot; 返回数字。&lt;/p&gt;
&lt;p&gt;唯一强制性的事情是：这些方法必须返回一个原始值，而不是对象。&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;strong&gt;历史原因&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于历史原因，如果 &lt;code&gt;toString&lt;/code&gt; 或 &lt;code&gt;valueOf&lt;/code&gt; 返回一个对象，则不会出现 error，但是这种值会被忽略（就像这种方法根本不存在）。这是因为在 JavaScript 语言发展初期，没有很好的 &quot;error&quot; 的概念。&lt;/p&gt;
&lt;p&gt;相反，&lt;code&gt;Symbol.toPrimitive&lt;/code&gt; &lt;strong&gt;必须&lt;/strong&gt; 返回一个原始值，否则就会出现 error。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;进一步的转换&quot;&gt;进一步的转换&lt;/h2&gt;
&lt;p&gt;我们已经知道，许多运算符和函数执行类型转换，例如乘法 &lt;code&gt;*&lt;/code&gt; 将操作数转换为数字。&lt;/p&gt;
&lt;p&gt;如果我们将对象作为参数传递，则会出现两个阶段：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;对象被转换为原始值（通过前面我们描述的规则）。&lt;/li&gt;
&lt;li&gt;如果生成的原始值的类型不正确，则继续进行转换。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;let obj = {
  // toString 在没有其他方法的情况下处理所有转换
  toString() {
    return &quot;2&quot;;
  }
};

alert(obj * 2); // 4，对象被转换为原始值字符串 &quot;2&quot;，之后它被乘法转换为数字 2。
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol&gt;&lt;li&gt;乘法 &lt;code&gt;obj * 2&lt;/code&gt; 首先将对象转换为原始值（字符串 &quot;2&quot;）。&lt;/li&gt;
&lt;li&gt;之后 &lt;code&gt;&quot;2&quot; * 2&lt;/code&gt; 变为 &lt;code&gt;2 * 2&lt;/code&gt;（字符串被转换为数字）。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;二元加法在同样的情况下会将其连接成字符串，因为它更愿意接受字符串：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;let obj = {
  toString() {
    return &quot;2&quot;;
  }
};

alert(obj + 2); // 22（&quot;2&quot; + 2）被转换为原始值字符串 =&amp;gt; 级联
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。&lt;/p&gt;
&lt;p&gt;这里有三种类型（hint）：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;&quot;string&quot;&lt;/code&gt;（对于 &lt;code&gt;alert&lt;/code&gt; 和其他需要字符串的操作）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;number&quot;&lt;/code&gt;（对于数学运算）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&quot;default&quot;&lt;/code&gt;（少数运算符）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;规范明确描述了哪个运算符使用哪个 hint。很少有运算符“不知道期望什么”并使用 &lt;code&gt;&quot;default&quot;&lt;/code&gt; hint。通常对于内建对象，&lt;code&gt;&quot;default&quot;&lt;/code&gt; hint 的处理方式与 &lt;code&gt;&quot;number&quot;&lt;/code&gt; 相同，因此在实践中，最后两个 hint 常常合并在一起。&lt;/p&gt;
&lt;p&gt;转换算法是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;调用 &lt;code&gt;obj[Symbol.toPrimitive](hint)&lt;/code&gt; 如果这个方法存在，&lt;/li&gt;
&lt;li&gt;否则，如果 hint 是 &lt;code&gt;&quot;string&quot;&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;尝试 &lt;code&gt;obj.toString()&lt;/code&gt; 和 &lt;code&gt;obj.valueOf()&lt;/code&gt;，无论哪个存在。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;否则，如果 hint 是 &lt;code&gt;&quot;number&quot;&lt;/code&gt; 或者 &lt;code&gt;&quot;default&quot;&lt;/code&gt;
&lt;ul&gt;&lt;li&gt;尝试 &lt;code&gt;obj.valueOf()&lt;/code&gt; 和 &lt;code&gt;obj.toString()&lt;/code&gt;，无论哪个存在。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在实践中，为了便于进行日志记录或调试，对于所有能够返回一种“可读性好”的对象的表达形式的转换，只实现以 &lt;code&gt;obj.toString()&lt;/code&gt; 作为全能转换的方法就够了。&lt;/p&gt;
&lt;hr/&gt;&lt;blockquote readability=&quot;4.4019138755981&quot;&gt;
&lt;p&gt;现代 JavaScript 教程：开源的现代 JavaScript 从入门到进阶的优质教程。&lt;a href=&quot;https://zh-hans.reactjs.org/docs/getting-started.html#javascript-resources&quot;&gt;React 官方文档推荐，与 MDN 并列的 JavaScript 学习教程&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在线免费阅读：&lt;a href=&quot;https://zh.javascript.info&quot;&gt;https://zh.javascript.info&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;微信扫描下方二维码，关注公众号「技术漫谈」，订阅更多精彩内容。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d62b21deb3b47f7bd7c610d3c658da2~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 13 Nov 2020 00:52:00 +0000</pubDate>
<dc:creator>技术漫谈</dc:creator>
<og:description>对象到原始值的转换，是由许多期望以原始值作为值的内建函数和运算符自动调用的。这里有三种类型（hint）：'string'，'number' 和 'default'。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leviding/p/13967450.html</dc:identifier>
</item>
<item>
<title>ASP.NET Core应用基本编程模式[3]：配置多种使用形式 - Artech</title>
<link>http://www.cnblogs.com/artech/p/asp-net-core-program-model-3.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/asp-net-core-program-model-3.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;34&quot;&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/artech/158198/o_200308031938inside-asp-net-core.png&quot; class=&quot;desc_img&quot;/&gt;IHostBuilder接口中定义了ConfigureHostConfiguration方法和ConfigureAppConfiguration方法，它们可以帮助我们设置面向宿主（IHost对象）和应用（承载服务）的配置。针对配置的初始化也可以借助IWebHostBuilder接口来完成。&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;162.07970479705&quot;&gt;
&lt;p&gt;通过《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-09-02.html&quot;&gt;服务承载系统[2]: 承载长时间运行的服务[下篇]&lt;/a&gt;》的介绍可知，IHostBuilder接口中定义了ConfigureHostConfiguration方法和ConfigureAppConfiguration方法，它们可以帮助我们设置面向宿主（IHost对象）和应用（承载服务）的配置。针对配置的初始化也可以借助IWebHostBuilder接口来完成。[本文节选自《ASP.NET Core 3框架揭秘》第11章, 更多关于ASP.NET Core的文章请点&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-3.html&quot;&gt;这里&lt;/a&gt;]&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;目录&lt;br/&gt;一、初始化配置&lt;br/&gt;二、以键值对形式读取和修改配置&lt;br/&gt;三、合并配置&lt;br/&gt;四、注册IConfigurationSource&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当IWebHostBuilder对象被创建的时候，它会将当前的环境变量作为配置源来创建承载最初配置数据的IConfiguration对象，但它只会选择名称以“ASPNETCORE_”为前缀的环境变量（通过静态类型Host的CreateDefaultBuilder方法创建的HostBuilder默认选择的是前缀为“DOTNET_”的环境变量）。在演示针对环境变量的初始化配置之前，需要先解决配置的消费问题，即如何获取配置数据。&lt;/p&gt;
&lt;p&gt;前面演示了针对Startup类型的构造函数注入，表示配置的IConfiguration对象是能够注入Startup类型构造函数中的两个服务对象之一。接下来我们采用Options模式来消费以环境变量形式提供的配置，如下所示的FoobarOptions是我们定义的Options类型。在注册的Startup类型中，可以直接在构造函数中注入IConfiguration服务，并在ConfigureServices方法中将其映射为FoobarOptions类型。在Configure方法中，可以通过注入的IOptions&amp;lt;FoobarOptions&amp;gt;服务得到通过配置绑定的FoobarOptions对象，并将其序列化成JSON字符串。在通过调用IApplicationBuilder的Run方法注册的中间件中，这个JSON字符串直接作为请求的响应内容。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Environment.SetEnvironmentVariable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASPNETCORE_FOOBAR:FOO&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Environment.SetEnvironmentVariable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASPNETCORE_FOOBAR:BAR&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        Environment.SetEnvironmentVariable(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ASPNETCORE_Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt; builder.UseStartup&amp;lt;Startup&amp;gt;&lt;span&gt;())
            .Build()
            .Run();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Startup
    {
        &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IConfiguration _configuration;  
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Startup(IConfiguration configuration)  =&amp;gt; _configuration =&lt;span&gt; configuration;
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; ConfigureServices(IServiceCollection services) =&amp;gt; services.Configure&amp;lt;FoobarOptions&amp;gt;&lt;span&gt;(_configuration);
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Configure(IApplicationBuilder app, IOptions&amp;lt;FoobarOptions&amp;gt;&lt;span&gt; optionsAccessor)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; options =&lt;span&gt; optionsAccessor.Value;
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; json =&lt;span&gt; JsonConvert.SerializeObject(options, Formatting.Indented);
            app.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt; context =&amp;gt;&lt;span&gt;
            {
                context.Response.ContentType &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;                
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; context.Response.WriteAsync($&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;pre&amp;gt;{json}&amp;lt;/pre&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            });
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FoobarOptions
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Foobar Foobar { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Baz { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; } 
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foobar
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Foo { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Bar { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了能够提供绑定为FoobarOptions对象的原始配置，我们在Main方法中设置了3个对应的环境变量，这些环境变量具有相同的前缀“ASPNETCORE_”。应用程序启动之后，如果利用浏览器访问该应用，得到的输出结果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201113084511760-1811112566.png&quot;&gt;&lt;img width=&quot;348&quot; height=&quot;203&quot; title=&quot;12&quot; alt=&quot;12&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201113084512501-1028512132.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-05-03.html&quot;&gt;配置[3]：配置模型总体设计&lt;/a&gt;》对配置模型进行了深入分析，由此可知，IConfiguration对象是以字典的结构来存储配置数据的，该接口定义的索引可供我们以键值对的形式来读取和修改配置数据。在ASP.NET Core应用中，我们可以通过调用定义在IWebHostBuilder接口的GetSetting方法和UseSetting方法达到相同的目的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWebHostBuilder
{
    &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; GetSetting(&lt;span&gt;string&lt;/span&gt;&lt;span&gt; key);
    IWebHostBuilder UseSetting(&lt;/span&gt;&lt;span&gt;string&lt;/span&gt; key, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value);
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面演示的实例采用环境变量来提供最终绑定为FoobarOptions对象的原始配置，这样的配置数据也可以通过如下所示的方式调用IWebHostBuilder接口的UseSetting方法来提供。修改后的应用程序启动之后，如果利用浏览器访问该应用，同样可以得到上图所示的输出结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .UseSetting(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar:Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .UseSetting(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar:Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .UseSetting(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;())
        .Build()
        .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置不仅仅供应用程序来使用，ASP.NET Core框架自身的很多特性也都可以通过配置进行定制。如果希望通过修改配置来控制ASP.NET Core框架的某些行为，就需要先知道对应的配置项的名称是什么。例如，ASP.NET Core应用的服务器默认使用launchSettings.json文件定义的监听地址，但是我们可以通过修改配置采用其他的监听地址。包括端口在内的监听地址是通过名称为urls的配置项来控制的，如果记不住这个配置项的名称，也可以直接使用定义在WebHostDefaults中对应的只读属性ServerUrlsKey，该静态类型中还提供了其他一些预定义的配置项名称，所以这也是一个比较重要的类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebHostDefaults
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; ServerUrlsKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;针对上面演示的这个实例，如果希望为服务器设置不同的监听地址，直接调用IWebHostBuilder接口的UseSetting方法将新的地址作为urls配置项的内容即可。既然配置项被命名为urls，就意味着服务器的监听地址不仅限于一个，如果希望设置多个监听地址，我们可以采用分号作为分隔符。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .UseSetting(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar:Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .UseSetting(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar:Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .UseSetting(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .UseSetting(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;urls&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://0.0.0.0:8888;http://0.0.0.0:9999&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;())
        .Build()
        .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;为了使实例程序采用不同的监听地址，可以采用如上所示的方式调用IWebHostBuilder接口的UseSetting方法设置两个针对8888和9999端口号的监听地址。由图11-13所示的程序启动后的输出结果可以看出，服务器确实采用我们指定的两个地址监听请求，通过浏览器针对这两个地址发送的请求能够得到相同的结果。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201113084513115-941277094.png&quot;&gt;&lt;img width=&quot;451&quot; height=&quot;224&quot; title=&quot;13&quot; alt=&quot;13&quot; src=&quot;https://img2020.cnblogs.com/blog/19327/202011/19327-20201113084513529-172672655.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;除了调用UseSetting方法设置urls配置项来修改服务器的监听地址，直接调用IWebHostBuilder接口的UseUrls扩展方法也可以达到相同的目的。另外，我们提供的监听地址只能包含主机名称/IP地址（Host/IP）和端口号，不能包含基础路径（PathBase）。如果我们提供“http://0.0.0.0/3721/foobar”这样一个URL，系统会抛出一个InvalidOperationException类型的异常。基础路径可以通过注册中间件的方式进行设置。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostingAbstractionsWebHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder UseUrls(&lt;span&gt;this&lt;/span&gt; IWebHostBuilder hostBuilder, &lt;span&gt;params&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] urls);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;在启动一个ASP.NET Core应用时，我们可以自行创建一个承载配置的IConfiguration对象，并通过调用IWebHostBuilder接口的UseConfiguration扩展方法将它与应用自身的配置进行合并。如果应用自身存在重复的配置项，那么该配置项的值会被指定的IConfiguration对象覆盖。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HostingAbstractionsWebHostBuilderExtensions
{
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder UseConfiguration(&lt;span&gt;this&lt;/span&gt;&lt;span&gt; IWebHostBuilder hostBuilder, IConfiguration configuration);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果前面演示的实例需要采用这种方式来提供配置，我们可以对程序代码做如下修改。如下面的代码片段所示，我们创建了一个ConfigurationBuilder对象，并通过调用AddInMemory&lt;br/&gt;Collection扩展方法注册了一个MemoryConfigurationSource对象，它提供了绑定FoobarOptions对象所需的所有配置数据。我们最终利用ConfigurationBuilder创建出一个IConfiguration对象，并通过调用上述UseConfiguration方法将提供的配置数据合并到当前应用中。修改后的应用程序启动之后，如果利用浏览器访问该应用，同样会得到图11-12所示的输出结果。（S1115）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; configuration = &lt;span&gt;new&lt;/span&gt; ConfigurationBuilder().AddInMemoryCollection(&lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
            {
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar:Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar:Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;]     = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
            })
            .Build();

        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
            .UseConfiguration(configuration)
            .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;())
        .Build()
        .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;配置系统最大的特点是可以注册不同的配置源。借助IWebHostBuilder接口的UseConfiguration扩展方法，虽然可以将利用配置系统提供的IConfiguration对象应用到ASP.NET Core程序中，但是这样的整合方式总显得不够彻底，更加理想的方式应该是可以直接在ASP.NET Core应用中注册IConfigurationSource对象。&lt;/p&gt;
&lt;p&gt;针对IConfigurationSource的注册可以调用IWebHostBuilder接口的ConfigureAppConfiguration方法来完成，该方法与在IHostBuilder接口上定义的同名方法基本上是等效的。如下面的代码片段所示，这个方法的参数是一个类型为Action&amp;lt;WebHostBuilderContext, IConfigurationBuilder&amp;gt;的委托对象，这意味着我们可以就承载上下文对配置做针对性设置。如果设置与当前承载上下文无关，我们还可以调用ConfigureAppConfiguration方法重载，该方法的参数类型为Action&amp;lt;IConfigurationBuilder&amp;gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IWebHostBuilder
{
    IWebHostBuilder ConfigureAppConfiguration(Action&lt;/span&gt;&amp;lt;WebHostBuilderContext, IConfigurationBuilder&amp;gt;&lt;span&gt; configureDelegate);
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WebHostBuilderExtensions
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; IWebHostBuilder ConfigureAppConfiguration(&lt;span&gt;this&lt;/span&gt; IWebHostBuilder hostBuilder, Action&amp;lt;IConfigurationBuilder&amp;gt;&lt;span&gt; configureDelegate);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于上面演示的这个程序来说，如果将针对IWebHostBuilder接口的UseConfiguration方法的调用替换成如下所示的针对ConfigureAppConfiguration方法的调用，依然可以达到相同的目的。修改后的应用程序启动之后，如果利用浏览器访问该应用，同样会得到上图所示的输出结果。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {       
        Host.CreateDefaultBuilder().ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt; builder.ConfigureAppConfiguration(config =&amp;gt;&lt;span&gt; config
                .AddInMemoryCollection(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Dictionary&amp;lt;&lt;span&gt;string&lt;/span&gt;, &lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt;
                {
                    [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar:Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foo&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar:Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bar&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
                    [&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;] = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Baz&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
                }))
            .UseStartup&lt;/span&gt;&amp;lt;Startup&amp;gt;&lt;span&gt;())
        .Build()
        .Run();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-1.html&quot;&gt;ASP.NET Core编程模式[1]：管道式的请求处理&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-2.html&quot;&gt;ASP.NET Core编程模式[2]：依赖注入的运用&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-3.html&quot;&gt;ASP.NET Core编程模式[3]：配置多种使用形式&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-4.html&quot;&gt;ASP.NET Core编程模式[4]：基于承载环境的编程&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/artech/p/asp-net-core-program-model-5.html&quot;&gt;ASP.NET Core编程模式[5]：如何放置你的初始化代码&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 13 Nov 2020 00:45:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>目录一、初始化配置 二、以键值对形式读取和修改配置 三、合并配置 四、注册IConfigurationSource 一、初始化配置 二、以键值对形式读取和修改配置 三、合并配置 四、注册IConfig</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/asp-net-core-program-model-3.html</dc:identifier>
</item>
<item>
<title>为什么大多数IOC容器使用ApplicationContext，而不用BeanFactory - 锅外的大佬</title>
<link>http://www.cnblogs.com/liululee/p/13967437.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liululee/p/13967437.html</guid>
<description>&lt;h2 id=&quot;1-引言&quot;&gt;1. 引言&lt;/h2&gt;
&lt;p&gt;Spring框架附带了两个IOC容器– &lt;em&gt;&lt;a href=&quot;https://www.baeldung.com/spring-beanfactory&quot;&gt;BeanFactory&lt;/a&gt;&lt;/em&gt; 和 &lt;em&gt;&lt;a href=&quot;https://www.baeldung.com/spring-classpathxmlapplicationcontext&quot;&gt;ApplicationContext&lt;/a&gt;&lt;/em&gt;. &lt;em&gt;BeanFactory&lt;/em&gt;是IOC容器的最基本版本，&lt;em&gt;ApplicationContext&lt;/em&gt;扩展了&lt;em&gt;BeanFactory&lt;/em&gt;的功能。&lt;br/&gt;那么本篇文章中，我们将通过实际例子了解这两个IOC容器之间的显著差异。&lt;/p&gt;
&lt;h2 id=&quot;2-延迟加载-vs-预加载&quot;&gt;2. 延迟加载 vs. 预加载&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;BeanFactory 按需加载bean，而 ApplicationContext 则在启动&lt;/strong&gt;时加载所有bean。因此，&lt;em&gt;BeanFactory&lt;/em&gt;与&lt;em&gt;ApplicationContext&lt;/em&gt;相比是轻量级的。让我们用一个例子来理解它。&lt;/p&gt;
&lt;h3 id=&quot;21--beanfactory-延迟加载&quot;&gt;2.1. &lt;em&gt;BeanFactory&lt;/em&gt; 延迟加载&lt;/h3&gt;
&lt;p&gt;假设我们有一个名为 &lt;em&gt;Student&lt;/em&gt; 单例Bean：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Student {
    public static boolean isBeanInstantiated = false;
 
    public void postConstruct() {
        setBeanInstantiated(true);
    }
 
    //standard setters and getters
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们将把 &lt;em&gt;postConstruct()&lt;/em&gt; 方法定义为&lt;em&gt;BeanFactory&lt;/em&gt;配置文件 &lt;em&gt;ioc-container-difference-example.xml&lt;/em&gt; 中的 &lt;em&gt;init method&lt;/em&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;bean id=&quot;student&quot; class=&quot;com.baeldung.ioccontainer.bean.Student&quot; init-method=&quot;postConstruct&quot;/&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，让我们编写一个测试用例来创建一个&lt;em&gt;BeanFactory&lt;/em&gt; 来检查它是否加载了&lt;em&gt;Student&lt;/em&gt; bean：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenBFInitialized_thenStudentNotInitialized() {
    Resource res = new ClassPathResource(&quot;ioc-container-difference-example.xml&quot;);
    BeanFactory factory = new XmlBeanFactory(res);
    
    assertFalse(Student.isBeanInstantiated());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，&lt;strong&gt;没有初始化 Student 对象&lt;/strong&gt;。换句话说，&lt;strong&gt;只有 BeanFactory 被初始化了&lt;/strong&gt;。只有当我们显式调用&lt;em&gt;getBean()&lt;/em&gt;方法&lt;em&gt;时，&lt;/em&gt;BeanFactory 中定义的 &lt;em&gt;bean&lt;/em&gt; 才会被加载。&lt;br/&gt;让我们检查一下 &lt;em&gt;Student&lt;/em&gt; bean 的初始化情况，我们手动调用 &lt;em&gt;getBean()&lt;/em&gt; 方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenBFInitialized_thenStudentInitialized() {
    Resource res = new ClassPathResource(&quot;ioc-container-difference-example.xml&quot;);
    BeanFactory factory = new XmlBeanFactory(res);
    Student student = (Student) factory.getBean(&quot;student&quot;);
 
    assertTrue(Student.isBeanInstantiated());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，&lt;em&gt;Student&lt;/em&gt; bean 成功加载。因此，&lt;em&gt;BeanFactory&lt;/em&gt; 只在需要时加载bean。&lt;/p&gt;
&lt;h3 id=&quot;22-applicationcontext-预加载&quot;&gt;2.2. &lt;em&gt;ApplicationContext&lt;/em&gt; 预加载&lt;/h3&gt;
&lt;p&gt;现在，让我们用&lt;em&gt;ApplicationContext&lt;/em&gt;代替&lt;em&gt;BeanFactory&lt;/em&gt;&lt;br/&gt;我们只定义&lt;em&gt;ApplicationContext，&lt;/em&gt;它将使用预加载策略立即加载所有bean：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenAppContInitialized_thenStudentInitialized() {
    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ioc-container-difference-example.xml&quot;);
    
    assertTrue(Student.isBeanInstantiated());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;在这里，即使我们没有调用 getBean() 方法，也会创建 Student 对象&lt;/strong&gt;&lt;br/&gt;&lt;em&gt;ApplicationContext&lt;/em&gt; 被认为是一个沉重的IOC容器，因为它的预加载策略在启动时加载所有bean。&lt;em&gt;相比之下，BeanFactory&lt;/em&gt; 是轻量级的，在内存受限的系统中非常方便。尽管如此，大多数用例仍然首选使用 ApplicationContext，这是为什么呢？&lt;/p&gt;
&lt;h2 id=&quot;3-企业应用程序功能&quot;&gt;3. 企业应用程序功能&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;ApplicationContext&lt;/em&gt; 以更面向框架的风格增强了&lt;em&gt;BeanFactory&lt;/em&gt;，并提供了一些适用于企业应用程序的功能。&lt;/p&gt;
&lt;p&gt;例如，它提供了消息传递（i18n或国际化）功能、事件发布功能、基于注释的依赖注入，以及与Spring AOP特性的简单集成。&lt;/p&gt;
&lt;p&gt;除此之外，&lt;em&gt;ApplicationContext&lt;/em&gt;几乎支持所有类型的 bean 作用域，但是&lt;em&gt;BeanFactory&lt;/em&gt;只支持两个作用域——&lt;em&gt;Singleton&lt;/em&gt;和&lt;em&gt;Prototype&lt;/em&gt;。因此，在构建复杂的企业应用程序时，最好使用&lt;em&gt;ApplicationContext&lt;/em&gt;。&lt;/p&gt;
&lt;h2 id=&quot;4-自动注册beanfactorypostprocessor和beanpostprocessor&quot;&gt;4. 自动注册&lt;em&gt;BeanFactoryPostProcessor&lt;/em&gt;和&lt;em&gt;BeanPostProcessor&lt;/em&gt;&lt;/h2&gt;
&lt;p&gt;**ApplicationContext 在启动时自动注册 BeanFactoryPostProcessor 和 BeanPostProcessor **。然而，&lt;em&gt;BeanFactory&lt;/em&gt;不会自动注册这些接口。&lt;/p&gt;
&lt;h3 id=&quot;41-在-beanfactory-中注册&quot;&gt;4.1. 在 BeanFactory 中注册&lt;/h3&gt;
&lt;p&gt;为了理解，让我们写两个类。&lt;br/&gt;首先，我们有&lt;em&gt;CustomBeanFactoryPostProcessor&lt;/em&gt;类，它实现了&lt;em&gt;BeanFactoryPostProcessor&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CustomBeanFactoryPostProcessor implements BeanFactoryPostProcessor {
    private static boolean isBeanFactoryPostProcessorRegistered = false;
    
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory){
        setBeanFactoryPostProcessorRegistered(true);
    }
 
    // standard setters and getters
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我们重写了 &lt;em&gt;postProcessBeanFactory()&lt;/em&gt; 方法来检查它的注册。&lt;br/&gt;其次，我们还有另一个类，&lt;em&gt;CustomBeanPostProcessor&lt;/em&gt;，它实现了&lt;em&gt;BeanPostProcessor&lt;/em&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class CustomBeanPostProcessor implements BeanPostProcessor {
    private static boolean isBeanPostProcessorRegistered = false;
    
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName){
        setBeanPostProcessorRegistered(true);
        return bean;
    }
 
    //standard setters and getters
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我们重写了 &lt;em&gt;PostProcessBeforeAlization()&lt;/em&gt; 方法来检查其注册。&lt;br/&gt;另外，我们在 &lt;em&gt;ioc-container-difference-example.xml&lt;/em&gt; 配置文件中配置了这两个类：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;bean id=&quot;customBeanPostProcessor&quot; 
  class=&quot;com.baeldung.ioccontainer.bean.CustomBeanPostProcessor&quot; /&amp;gt;
&amp;lt;bean id=&quot;customBeanFactoryPostProcessor&quot; 
  class=&quot;com.baeldung.ioccontainer.bean.CustomBeanFactoryPostProcessor&quot; /&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;让我们看一个测试用例来检查这两个类是否在启动期间自动注册：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenBFInitialized_thenBFPProcessorAndBPProcessorNotRegAutomatically() {
    Resource res = new ClassPathResource(&quot;ioc-container-difference-example.xml&quot;);
    ConfigurableListableBeanFactory factory = new XmlBeanFactory(res);
 
    assertFalse(CustomBeanFactoryPostProcessor.isBeanFactoryPostProcessorRegistered());
    assertFalse(CustomBeanPostProcessor.isBeanPostProcessorRegistered());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从我们的测试中我们可以看到，&lt;strong&gt;自动注册并没有发生&lt;/strong&gt;。&lt;br/&gt;&lt;strong&gt;现在，让我们看看一个测试用例，手动将它们添加到 BeanFactory：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenBFPostProcessorAndBPProcessorRegisteredManually_thenReturnTrue() {
    Resource res = new ClassPathResource(&quot;ioc-container-difference-example.xml&quot;);
    ConfigurableListableBeanFactory factory = new XmlBeanFactory(res);
 
    CustomBeanFactoryPostProcessor beanFactoryPostProcessor 
      = new CustomBeanFactoryPostProcessor();
    beanFactoryPostProcessor.postProcessBeanFactory(factory);
    assertTrue(CustomBeanFactoryPostProcessor.isBeanFactoryPostProcessorRegistered());
 
    CustomBeanPostProcessor beanPostProcessor = new CustomBeanPostProcessor();
    factory.addBeanPostProcessor(beanPostProcessor);
    Student student = (Student) factory.getBean(&quot;student&quot;);
    assertTrue(CustomBeanPostProcessor.isBeanPostProcessorRegistered());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里，我们使用 &lt;em&gt;postProcessBeanFactory()&lt;/em&gt; 方法注册 &lt;em&gt;CustomBeanFactoryPostProcessor&lt;/em&gt;，使用 &lt;em&gt;addBeanPostProcessor()&lt;/em&gt; 方法注册&lt;em&gt;CustomBeanPostProcessor&lt;/em&gt;。在这种情况下，它们都注册成功。&lt;/p&gt;
&lt;h3 id=&quot;42-在-applicationcontext-中注册&quot;&gt;4.2. 在 &lt;em&gt;ApplicationContext&lt;/em&gt; 中注册&lt;/h3&gt;
&lt;p&gt;如前所述，&lt;em&gt;ApplicationContext&lt;/em&gt;会自动注册这两个类，而无需编写额外的代码。&lt;br/&gt;让我们在单元测试中验证此行为：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Test
public void whenAppContInitialized_thenBFPostProcessorAndBPostProcessorRegisteredAutomatically() {
    ApplicationContext context 
      = new ClassPathXmlApplicationContext(&quot;ioc-container-difference-example.xml&quot;);
 
    assertTrue(CustomBeanFactoryPostProcessor.isBeanFactoryPostProcessorRegistered());
    assertTrue(CustomBeanPostProcessor.isBeanPostProcessorRegistered());
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到，&lt;strong&gt;这两个类的自动注册都是成功的&lt;/strong&gt;。&lt;br/&gt;因此，&lt;strong&gt;建议使用ApplicationContext&lt;/strong&gt;，因为Spring2.0（及更高版本）大量使用&lt;em&gt;BeanPostProcessor&lt;/em&gt;。&lt;br/&gt;还有一点值得注意的是&lt;strong&gt;如果使用的是普通的 BeanFactory，那么事务和AOP之类的功能将不会生效&lt;/strong&gt;（除非你编写额外的代码实现，那就另当别论了）。这样可能会导致代码很混乱，因为配置看起来貌似没毛病。&lt;/p&gt;
&lt;h2 id=&quot;5-写在结尾&quot;&gt;5. 写在结尾&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;ApplicationContext&lt;/em&gt; 提供了一些高级功能，包括一些面向企业应用程序的功能，而&lt;em&gt;BeanFactory&lt;/em&gt;只提供了基本功能。因此，一般建议使用 &lt;em&gt;ApplicationContext&lt;/em&gt; ，只有在内存消耗非常关键的情况下，我们才应该考虑去使用BeanFactory。&lt;br/&gt;如果你觉得文章还不错，记得关注公众号： 锅外的大佬&lt;br/&gt;&lt;a href=&quot;http://developlee.top&quot;&gt;刘一手的博客&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Nov 2020 00:43:00 +0000</pubDate>
<dc:creator>锅外的大佬</dc:creator>
<og:description>1. 引言 Spring框架附带了两个IOC容器– BeanFactory 和 ApplicationContext. BeanFactory是IOC容器的最基本版本，ApplicationConte</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liululee/p/13967437.html</dc:identifier>
</item>
<item>
<title>自制 os 极简教程1：写一个操作系统有多难 - 闪客sun</title>
<link>http://www.cnblogs.com/flashsun/p/13967422.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/flashsun/p/13967422.html</guid>
<description>&lt;p&gt;为什么叫极简教程呢？听我慢慢说&lt;/p&gt;
&lt;p&gt;不知道正在阅读本文的你，是否是因为想自己动手写一个操作系统。我觉得可能每个程序员都有个操作系统梦，或许是想亲自动手写出来一个，或许是想彻底吃透操作系统的知识。不论是为了满足程序员们自带的成就感，还是为了面试找工作时能更深入地和面试官探讨（装逼）。&lt;/p&gt;
&lt;h2 id=&quot;写一个操作系统有多难&quot;&gt;写一个操作系统有多难&lt;/h2&gt;
&lt;p&gt;会者不难，难者不会。&lt;/p&gt;
&lt;h4 id=&quot;冷启动&quot;&gt;冷启动&lt;/h4&gt;
&lt;p&gt;对于零基础的人，甚至是计算机知识零基础的人来说，难。难点并不在于操作系统的代码量本身，而在于任何一个事物发展初期都会遇到的困境，&lt;strong&gt;冷启动&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我不知道应该看哪本书作为入门书籍，甚至不知道应该看书还是看网络上的文章，还是找一个领路者带你入门，甚至还在被一些讨论自己做一个操作系统到底有没有意义这个问题纠结着。&lt;/p&gt;
&lt;p&gt;好多人在这个冷启动时期，就被弄得没脾气了。&lt;/p&gt;
&lt;p&gt;你可能比较幸运，找到了一本入门书籍，刚好作者的文笔和思路比较对你的胃口，于是度过了冷启动时期。&lt;/p&gt;
&lt;p&gt;但你也可能不太幸运，找了一本难读的书籍，或者是优秀的作品但刚好不对你的胃口，于是就从入门到放弃了。&lt;/p&gt;
&lt;p&gt;我当时的第一本启蒙书籍，是《&lt;strong&gt;30 天自制操作系统&lt;/strong&gt;》，好多人的第一本可能也是这个，因为书的标题就直戳了当地写了 &lt;strong&gt;自制操作系统&lt;/strong&gt; 这几个字，而且一看哇 30 天就能搞定，一下让好多不敢跨出第一步的人有了信心。&lt;/p&gt;
&lt;p&gt;这本书会把读者当作完全没有计算机基础的小白，所以很多地方非常友好，跟着它走一遍完全可以让你度过冷启动时期了。&lt;/p&gt;
&lt;p&gt;但这本书同样也有让人想中途放弃的一些点，比如我就很烦这些地方。一个是它从官网上下载的源码是&lt;strong&gt;日语注释&lt;/strong&gt;的，搞的当时我好多地方还找我朋友帮我翻译。另一个是他用的工具都是这个作者&lt;strong&gt;自己写的&lt;/strong&gt;，这固然比较牛逼，但我就想难不成做操作系统连个现成的业界常用的工具也没有么，我学了你的工具也没有普适性啊。再有就是作者后面的篇幅花好多时间讲图形界面要怎么做，怎么在屏幕上画一个个方框作为窗口，还想互不影响。这个因人而异吧，我是觉得不必花费如此大的篇幅，这不是想写操作系统的人的痛点所在。&lt;/p&gt;
&lt;p&gt;总之，通过一本书，或者一篇文章，或者一个领路人的带领之下，你迈出了第一步，度过了冷启动时期，来到了&lt;strong&gt;初期&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;初期&quot;&gt;初期&lt;/h4&gt;
&lt;p&gt;你照葫芦画瓢，一个指令都不敢修改，终于照着书上的代码，成功在一个虚拟机或者真机上看到了“hello world”，或者牛逼一点看到了 AAABBB 线程切换方式交替打印的字符串。&lt;/p&gt;
&lt;p&gt;这时候你写操作系统的恐惧已经没有了，但你不满足于现状，因为这个“hello world”并不是你自己的东西，你甚至都不知道里面的代码是什么含义，可能当时只是 copy 过来的。&lt;/p&gt;
&lt;p&gt;你不在需要一个手把手教你的书籍，更多的是需要告诉你通用的原理，以及操作系统思想的书籍。&lt;/p&gt;
&lt;p&gt;我在这个时期的书籍是《&lt;strong&gt;操作系统真相还原&lt;/strong&gt;》，这本书一上来就讲述了一些你可能感到困惑的问题，&lt;/p&gt;
&lt;blockquote readability=&quot;19&quot;&gt;
&lt;p&gt;0.1 操作系统是什么&lt;/p&gt;
&lt;p&gt;0.2 你想研究到什么程度&lt;/p&gt;
&lt;p&gt;0.3 写操作系统，哪些需要我来做&lt;/p&gt;
&lt;p&gt;0.4 软件是如何访问硬件的&lt;/p&gt;
&lt;p&gt;0.5 应用程序是什么，和操作系统是如何配合到一起的&lt;/p&gt;
&lt;p&gt;0.6 为什么称为“陷入”内核&lt;/p&gt;
&lt;p&gt;0.7 内存访问为什么要分段&lt;/p&gt;
&lt;p&gt;0.8 什么是平坦模型&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我一看这目录我的妈呀，这不就是我读完《30 天自制操作系统》后所产生的疑问么！于是这本书可以说是我在这条路上，读的最爽的书，一个个疑问就是在这本书里被一一找到答案的。&lt;/p&gt;
&lt;p&gt;不过其实我觉得对于有计算机基础并且还不错的人来说，这本书完全可以作为冷启动时期的第一本书了。&lt;/p&gt;
&lt;p&gt;这本书不会像 30 天一样，在手把手这种细节上下太大功夫，比如 30 天这本书很逗，居然在教你如何用键盘按出 512 个 0 这个问题上写了好多行，还说你家如果有小猫的话可以棒棒忙。所以这本书的篇幅会放在一些真正重点的问题上。&lt;/p&gt;
&lt;p&gt;你读完这本书，结合着网上的资料和自己动手实践，已经可以用自由意志来对照葫芦画瓢的操作系统进行微调了。此时你已经成功度过了初期，开始向&lt;strong&gt;中期&lt;/strong&gt;迈进！&lt;/p&gt;
&lt;p&gt;不过别看一句话就总结完了，这中间你很可能会放弃，因为单单这本书的知识量就非常庞大了，如果之前从没有接触过，想要消化它，不是一件简单的事。&lt;/p&gt;
&lt;p&gt;比如我在这个阶段，就中途放弃过两三次，因为我老想着跳过一些我觉得“没用的”章节，可往往都是看到后面，又要重新翻回来把前面的补上。有的时候也因为，明明和书上写的一样，但我的程序就是报错，导致后面的没法进行。操作系统就是这样，前面的加载 loader、设置中断、设置分段分页、进入保护模式这些步骤是串行的，每一步都不能出一丁点错误，否则后面的步骤会被前面的步骤卡住，遇到问题没法跳过，就像你做一张数学试卷，必须从第一题开始顺序做到最后一题，而且前面的正确了才能往后继续做一样。&lt;/p&gt;
&lt;h4 id=&quot;中期&quot;&gt;中期&lt;/h4&gt;
&lt;p&gt;千辛万苦来到中期，这里的人可能已经不多了，但到了这里你会认识一大批和你一样在挣扎的人，新世界的大门可能就此打开，所以对你来说，其实你会觉得自己做操作系统的人好多啊，而且高手如云。&lt;/p&gt;
&lt;p&gt;因为虽然你可以按照自己的意志对写好的操作系统有一些微调，也对操作系统的各个部分有了一个模糊的认识，但总是甩不开你所看的书的影子，简单说就是&lt;strong&gt;没见识&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我当时呢，就被《操作系统真相还原》里的操作系统的思路舒服着，总是认为就应该把内核映射到内存高端的空间上，要用很取巧的办法设计页表。总之就是见识少，因为只知道一种实现方式，所以觉得天下的操作系统都是这个鬼样。&lt;/p&gt;
&lt;p&gt;因为好歹是有点知识量在了，这个阶段一些操作系统领域的大牛（反正是比你厉害很多的人啦），会稍稍理一理你了，可能语气会从原来的拉黑，变成“哦”，再到现在的“嗯嗯”。你也会加入到一些群或者一些社区当中，认识更多的大佬。你会发现，你眼中的这个操作系统，在他们眼里就是个其中一种很常规的或者说很过时的方式而已。于是乎你在慢慢的影响下，也打开了思路，决定了解更多的操作系统。&lt;/p&gt;
&lt;p&gt;我呢，当时的选择是&lt;strong&gt;阅读 linux 源码，并尝试仿写一个&lt;/strong&gt;（最后仿写这一步放弃了）。&lt;/p&gt;
&lt;p&gt;这我感觉，只要这一步你的选择是了解一款经典的操作系统，那还能选什么呢，只能是 linux 吧哈哈。&lt;/p&gt;
&lt;p&gt;这一时期的书籍呢，也比较多，我的话是通过《&lt;strong&gt;linux 内核设计的艺术&lt;/strong&gt;》来简单了解 linux 的整个流程和脉络，再通过《&lt;strong&gt;linux 内核完全注释&lt;/strong&gt;》配合着 linux 的源码进行重点源码逐行了解，还通过和一款开源操作系统 bookos 的作者进行交流，进一步了解一个成熟操作系统需要考虑的问题。&lt;/p&gt;
&lt;p&gt;linux 有些了解后，便通过仿写的形式来进一步加深理解。但仿写最终放弃了，因为即便是 linux0.11 的源代码，里面都非常复杂，完全仿写还是很费时间的。于是便将自己认为纯苦力的工作简化，比如 linux 会根据内存大小来划分内存区域，我就直接写死了 32M 内存。再比如 linux 支持的硬盘数是动态变化的，我就直接只支持一块硬盘，这样里面好多数组，for 循环，就都展开了，我觉得对理解一个操作系统，这些工作无关紧要。&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;这里说个小插曲，读 linux 源码，有时候差点没把我气死。linus 这个人太调皮了，好多地方的注释写的大概是这种风格。/*_ emm，这里我也不知道有啥用，不过先写上吧，我乐意，嘿嘿 _/&lt;br/&gt;对于正在苦苦理解源码的我，简直不友好&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这时候找书便不再是你的难题了，你会自发的去找自己需要的书籍，并且每个人想关注的点不同，也会找不同的侧重点去深入了解。比如 linux 早期版本中是没有网络模块的，所以如果侧重点在网络编程，那就专门找如《&lt;strong&gt;linux 内核网络模型&lt;/strong&gt;》这种书。有时候一些驱动程序，和一些比较好的操作系统变编程习惯，我也会通过如《&lt;strong&gt;一个 64 位操作系统的实现&lt;/strong&gt;》这类书的部分章节来强化。&lt;/p&gt;
&lt;p&gt;而且这个阶段你不在寂寞，会有很多同行者和你一起，也会有很多小白请教你问题。&lt;/p&gt;
&lt;h4 id=&quot;后期&quot;&gt;后期&lt;/h4&gt;
&lt;p&gt;此时，一个操作系统的框架，你应该已经摸清楚了，但你不可能深入每一个细节。此时，也不是坚不坚持的问题了，而是选择的问题。你要你的操作系统不但支持 x86 还支持 arm 么？你要把各种驱动程序都完善么？你要做优美的图形化界面么？你要深入学习显卡方面的编程么？你要加入制作国产操作系统的大军么？&lt;/p&gt;
&lt;p&gt;我的选择是不，所以我止步于此了。&lt;/p&gt;
&lt;p&gt;因为我当初决定入坑的时候，是为了对我现在所做的工作有更深入的理解。我是个软件工程师，是 Java 程序员，并不是专门做嵌入式，专门做内核开发的从业者。所以我认为再往后继续深入可以，但已经没必要向前中期那样集中火力搞了，而是利用闲散时间能多了解就多了解，按需学习。&lt;/p&gt;
&lt;p&gt;当然你也可以选择继续，我觉得不论是止步于此，还是继续往下走，都是有好处的。&lt;/p&gt;
&lt;h2 id=&quot;我的经历小结&quot;&gt;我的经历小结&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;冷启动：《30 天自制操作系统》&lt;/li&gt;
&lt;li&gt;初期：《操作系统真相还原》&lt;/li&gt;
&lt;li&gt;中期：《linux 内核设计的艺术》《linux 内核完全注释》+ linux0.11 源码&lt;/li&gt;
&lt;li&gt;后期：止步&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;这个系列要写什么&quot;&gt;这个系列要写什么&lt;/h2&gt;
&lt;p&gt;要写一个极简的操作系统教程，带你入坑&lt;/p&gt;
&lt;p&gt;如果说属于上述哪个阶段的教程的话，我觉得处于&lt;strong&gt;冷冷启动阶段&lt;/strong&gt;，因为无论是冷启动、初期还是中期，都有让人放弃的点，而这个冷冷启动阶段的&lt;strong&gt;极简教程&lt;/strong&gt;，会让你在上面的各个阶段，都不那么容易放弃。&lt;/p&gt;
&lt;p&gt;我曾经写过这样的系列，但一开始总是定很大的目标，期待读者除了我的系列文章外，不需要读任何资料就可以完全按照我的教程完成一个操作系统的制作，但往往很不现实，也没有必要，完全不是一个系列文章该做的事。下面是我在博客园折腾的&lt;strong&gt;系列们&lt;/strong&gt;...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1096103/202011/1096103-20201113083503329-1222636453.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;系列文章无法做到足够细致，只有&lt;strong&gt;大部头的书籍&lt;/strong&gt;才能做到这一点。但上面的每一本书，部头真的都非常大，&lt;strong&gt;很容易让人放弃&lt;/strong&gt;，从而错失一本好书和一个入坑的机会，我在每本书上都放弃过两三次。而网上，简单的自制操作系统的文章，又过于简单，完全无法让人达到入坑的标准。&lt;/p&gt;
&lt;p&gt;所以为了解决这个痛点，我决定根据自己的经历，结合书本上的知识，反思之前写过的教程中的一些缺点，出这样一个极简教程的系列，其&lt;strong&gt;知识密度介于大部头书籍和网上的文章之间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;该教程的核心目标是，让读者对制作一个&lt;strong&gt;操作系统的核心流程&lt;/strong&gt;，&lt;strong&gt;应该掌握的知识&lt;/strong&gt;，&lt;strong&gt;需要经历的过程&lt;/strong&gt;，和&lt;strong&gt;需要克服的心理障碍&lt;/strong&gt;，做到心中有数，不再畏惧，做好入坑自制操作系统的正确姿势。并且在深入学习的过程中，不断的会有“哦，原来这个系列说的 xxx 就是这个意思呀”的正向反馈，这一点是非常重要的。&lt;br/&gt;因为技术的学习过程中之所以会放弃，一个原因是&lt;strong&gt;兴趣不够&lt;/strong&gt;，另一个原因就是“我理解了”这种&lt;strong&gt;正向反馈&lt;/strong&gt;不够。那本系列，我希望会在你后续深入学习的过程中，这个系列的影子会一直陪伴你，给你这种正向反馈和继续下去的动力，当然，最好还能让你提升兴趣，甚至让本不想亲手制作操作系统的人，也打开这个新世界的大门。&lt;/p&gt;
&lt;p&gt;本来还想写个目录，后来想想算了，中途的思路很可能要根据实际情况来调整，就当作给大家的期待吧。&lt;/p&gt;
&lt;h2 id=&quot;先送你一份入坑礼物&quot;&gt;先送你一份入坑礼物&lt;/h2&gt;
&lt;p&gt;这可能是 &lt;strong&gt;全网最简单的操作系统 demo&lt;/strong&gt;，啥也不能干，就做到了能接受键盘参数往屏幕上打印。最诱人的一点就是，如果你是 Windows 操作系统，你直接源码下载下来，点击 run.bat，&lt;strong&gt;不用安装任何环境，直接就可以运行&lt;/strong&gt;。这可能是好多入坑小伙伴梦寐以求的一个 demo 吧，地址奉上：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gitee.com/sunym1993/flash-4th-os.git&quot;&gt;https://gitee.com/sunym1993/flash-4th-os.git&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为什么是 flash-4th-os 呢？因为我英文名叫 Flash，然后我写的前三次都放弃了，这是我写的第四个，哈哈哈。&lt;/p&gt;
&lt;p&gt;有任何问题随时回复公众号，我会时常查看并回复。如果想私聊，也可以公众号留下你的微信，我会加你&lt;/p&gt;
&lt;p&gt;好的，那我们就敬请期待吧！&lt;/p&gt;
</description>
<pubDate>Fri, 13 Nov 2020 00:36:00 +0000</pubDate>
<dc:creator>闪客sun</dc:creator>
<og:description>为什么叫极简教程呢？听我慢慢说 不知道正在阅读本文的你，是否是因为想自己动手写一个操作系统。我觉得可能每个程序员都有个操作系统梦，或许是想亲自动手写出来一个，或许是想彻底吃透操作系统的知识。不论是为了</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/flashsun/p/13967422.html</dc:identifier>
</item>
<item>
<title>[.Net Core 3.0+/.Net 5] System.Text.Json中时间格式化 - Rayom</title>
<link>http://www.cnblogs.com/Rayom/p/13967415.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Rayom/p/13967415.html</guid>
<description>&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;.Net Core 3.0开始全新推出了一个名为&lt;code&gt;System.Text.Json&lt;/code&gt;的Json解析库，用于序列化和反序列化Json，此库的设计是为了取代&lt;code&gt;Json.Net(Newtonsoft.Json)&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;时间格式化的不足&quot;&gt;时间格式化的不足&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;System.Text.Json&lt;/code&gt;的优点就不说了，来说一下不完善的地方，毕竟一个新事物出来，不可能十全十美的，用的最多的就是时间的格式化&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;官方文档：在 System.Text.Json 中，具有内置支持的唯一格式是 &lt;strong&gt;&lt;code&gt;ISO 8601-1:2019&lt;/code&gt;&lt;/strong&gt;，因为它被广泛采用、意义明确并且可精确地进行往返。 若要使用任何其他格式，请创建自定义转换器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4.705035971223&quot;&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;ISO 8601-1:2019&lt;/code&gt;&lt;/strong&gt;通俗的说就是时间格式化为&lt;strong&gt;&lt;code&gt;2020-11-11T21:08:18&lt;/code&gt;&lt;/strong&gt;。&lt;strong&gt;&lt;code&gt;ISO 8601-1:2019&lt;/code&gt;&lt;/strong&gt;标准参考：&lt;a href=&quot;https://www.iso.org/standard/70907.html&quot;&gt;ISO官网&lt;/a&gt; | &lt;a href=&quot;https://baike.baidu.com/item/ISO%208601/3910715&quot;&gt;百度百科&lt;/a&gt; | &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_8601&quot;&gt;wikipedia&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但我们一般用的时候不想要这种格式，因为中间有一个&lt;code&gt;T&lt;/code&gt;，前端处理起来很麻烦，最好还是返回指定的时间格式，例如：&lt;code&gt;yyyy-MM-dd&lt;/code&gt;、&lt;code&gt;yyyy-MM-dd HH:mm:ss&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;既然官方不内置提供指定时间格式化的方式，那就没办法了吗，查阅文档发现，虽然无法简单的实现功能，但是可以通过创建自定义转换器来实现相应功能&lt;/p&gt;
&lt;p&gt;文档地址：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/dotnet/standard/serialization/system-text-json-migrate-from-newtonsoft-how-to#specify-date-format&quot;&gt;微软官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是一个自定义时间转化器的完整实现：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class DateTimeConverterUsingDateTimeParse : JsonConverter&amp;lt;DateTime&amp;gt;
{
    public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        return DateTime.Parse(reader.GetString());
    }

    public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)
    {
        writer.WriteStringValue(value.ToString(&quot;yyyy-MM-dd HH:mm:ss&quot;));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用&quot;&gt;使用&lt;/h3&gt;
&lt;p&gt;代码看起来非常简单是不是，只需要重写&lt;code&gt;Read&lt;/code&gt;和&lt;code&gt;Write&lt;/code&gt;，但是我们只是写了一个自定义转换器，怎么让它生效呢，请往下看：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;JsonSerializer.Serialize()&lt;/code&gt;和&lt;code&gt;JsonSerializer.Deserialize()&lt;/code&gt;方法都接受一个&lt;code&gt;JsonSerializerOptions&lt;/code&gt;类型的配置项参数&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;JsonSerializerOptions&lt;/code&gt;添加&lt;code&gt;Converters&lt;/code&gt;就可以了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JsonSerializerOptions options = new JsonSerializerOptions()
{
    Converters.Add(new DateTimeConverterUsingDateTimeParse())
}

string jsonString = JsonSerializer.Serialize(data, options);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至此，我们已经实现使用&lt;code&gt;System.Text.Json&lt;/code&gt;库指定时间格式字符串进行序列化和反序列化，你甚至可以把&lt;code&gt;yyyy-MM-dd HH:mm:ss&lt;/code&gt;做成参数来更自由的指定格式化字符串&lt;/p&gt;
&lt;h3 id=&quot;基准测试&quot;&gt;基准测试&lt;/h3&gt;
&lt;p&gt;但是凡事有利就有弊，官方文档也说得很清楚了：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用自定义转换器与使用序列化程序的本机实现相比，此方法的性能大大降低&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有人就想知道了，到底会影响多少性能呢，我进行了一项基准测试，序列化100000条数据，包含时间处理，模型如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Dto
{
    public string Name { get; set; }

    public string Phone { get; set; }

    public DateTime DateTime { get; set; }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-ini&quot;&gt;
BenchmarkDotNet=v0.12.1, OS=Windows 10.0.19042
Intel Core i7-6700K CPU 4.00GHz (Skylake), 1 CPU, 8 logical and 4 physical cores
.NET Core SDK=5.0.100-rc.2.20479.15
  [Host]     : .NET Core 3.1.9 (CoreCLR 4.700.20.47201, CoreFX 4.700.20.47203), X64 RyuJIT  [AttachedDebugger]
  DefaultJob : .NET Core 3.1.9 (CoreCLR 4.700.20.47201, CoreFX 4.700.20.47203), X64 RyuJIT

  System.Text.Json Version 5.0.0
  Newtonsoft.Json Version 12.0.3
&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Method&lt;/th&gt;
&lt;th&gt;Mean&lt;/th&gt;
&lt;th&gt;Error&lt;/th&gt;
&lt;th&gt;StdDev&lt;/th&gt;
&lt;th&gt;Gen 0&lt;/th&gt;
&lt;th&gt;Gen 1&lt;/th&gt;
&lt;th&gt;Gen 2&lt;/th&gt;
&lt;th&gt;Allocated&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;SystemTextJsonConverterDate&lt;/td&gt;
&lt;td&gt;67.36 ms&lt;/td&gt;
&lt;td&gt;0.489 ms&lt;/td&gt;
&lt;td&gt;0.458 ms&lt;/td&gt;
&lt;td&gt;2250.0000&lt;/td&gt;
&lt;td&gt;750.0000&lt;/td&gt;
&lt;td&gt;750.0000&lt;/td&gt;
&lt;td&gt;52.15 MB&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;SystemTextJson&lt;/td&gt;
&lt;td&gt;53.26 ms&lt;/td&gt;
&lt;td&gt;0.231 ms&lt;/td&gt;
&lt;td&gt;0.180 ms&lt;/td&gt;
&lt;td&gt;500.0000&lt;/td&gt;
&lt;td&gt;500.0000&lt;/td&gt;
&lt;td&gt;500.0000&lt;/td&gt;
&lt;td&gt;48.67 MB&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;NewtonsoftJsonConverterDate&lt;/td&gt;
&lt;td&gt;123.42 ms&lt;/td&gt;
&lt;td&gt;1.847 ms&lt;/td&gt;
&lt;td&gt;1.727 ms&lt;/td&gt;
&lt;td&gt;5800.0000&lt;/td&gt;
&lt;td&gt;2200.0000&lt;/td&gt;
&lt;td&gt;600.0000&lt;/td&gt;
&lt;td&gt;51.61 MB&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;NewtonsoftJson&lt;/td&gt;
&lt;td&gt;109.41 ms&lt;/td&gt;
&lt;td&gt;0.977 ms&lt;/td&gt;
&lt;td&gt;0.913 ms&lt;/td&gt;
&lt;td&gt;4800.0000&lt;/td&gt;
&lt;td&gt;2000.0000&lt;/td&gt;
&lt;td&gt;600.0000&lt;/td&gt;
&lt;td&gt;50.82 MB&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;结语&quot;&gt;结语&lt;/h3&gt;
&lt;p&gt;可以看到性能确实会有影响，但是可以忽略不计了，100000条才差10ms。&lt;/p&gt;
&lt;p&gt;同时可以发现&lt;code&gt;System.Text.Json&lt;/code&gt;性能是&lt;code&gt;Newtonsoft.Json&lt;/code&gt;的两倍&lt;/p&gt;
&lt;p&gt;推荐大家以后在满足需求的情况下尽量使用内置的&lt;code&gt;System.Text.Json&lt;/code&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 13 Nov 2020 00:34:00 +0000</pubDate>
<dc:creator>Rayom</dc:creator>
<og:description>简介 .Net Core 3.0开始全新推出了一个名为System.Text.Json的Json解析库，用于序列化和反序列化Json，此库的设计是为了取代Json.Net(Newtonsoft.Jso</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Rayom/p/13967415.html</dc:identifier>
</item>
<item>
<title>MySql索引使用策略 - CoolYYD</title>
<link>http://www.cnblogs.com/CoolYYD/p/13704593.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CoolYYD/p/13704593.html</guid>
<description>&lt;h2 class=&quot;NewStyle15&quot;&gt;&lt;strong&gt;索引优点&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.可以通过建立唯一索引或者主键索引,保证数据的唯一性.&lt;br/&gt;2.提高检索的数据性能&lt;br/&gt;3.在表连接的连接条件 可以加速表与表直接的相连 &lt;br/&gt;4.建立索引,在查询中使用索引 可以提高性能&lt;/p&gt;
&lt;h2 class=&quot;NewStyle15&quot;&gt;&lt;strong&gt;索引缺点&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.在创建索引和维护索引 会耗费时间,随着数据量的增加而增加&lt;br/&gt;2.索引文件会占用物理空间,除了数据表需要占用物理空间之外,每一个索引还会占用一定的物理空间&lt;br/&gt;3.当对表的数据进行 INSERT,UPDATE,DELETE 的时候,索引也要动态的维护,这样就会降低数据的维护速度,&lt;/p&gt;
&lt;p&gt;(建立索引会占用磁盘空间的索引文件。一般情况这个问题不太严重，但如果你在一个大表上创建了多种组合索引，索引文件的会膨胀很快)。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;使用索引需要注意的地方&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.在经常需要搜索的列上,可以加快索引的速度&lt;br/&gt;2.主键列上可以确保列的唯一性&lt;br/&gt;3.在表与表的而连接条件上加上索引,可以加快连接查询的速度&lt;br/&gt;4.在经常需要排序(order by),分组(group by)和的distinct 列上加索引 可以加快排序查询的时间,  (单独order by 用不了索引，索引考虑加where 或加limit)&lt;br/&gt;5.在一些where 之后的 &amp;lt; &amp;lt;= &amp;gt; &amp;gt;= BETWEEN IN 以及某个情况下的like 建立字段的索引(B-TREE)&lt;/p&gt;
&lt;p&gt;6.like语句的 如果你对nickname字段建立了一个索引.当查询的时候的语句是 nickname lick '%ABC%' 那么这个索引讲不会起到作用.而nickname lick 'ABC%' 那么将可以用到索引&lt;/p&gt;
&lt;p&gt;7.索引不会包含NULL列,如果列中包含NULL值都将不会被包含在索引中,复合索引中如果有一列含有NULL值那么这个组合索引都将失效,一般需要给默认值0或者 ' '字符串&lt;/p&gt;
&lt;p&gt;8.使用短索引,如果你的一个字段是Char(32)或者int(32),在创建索引的时候指定前缀长度 比如前10个字符 (前提是多数值是唯一的..)那么短索引可以提高查询速度,并且可以减少磁盘的空间,也可以减少I/0操作.&lt;/p&gt;
&lt;p&gt;9.不要在列上进行运算,这样会使得mysql索引失效,也会进行全表扫描&lt;/p&gt;
&lt;p&gt;10.选择越小的数据类型越好,因为通常越小的数据类型通常在磁盘,内存,cpu,缓存中 占用的空间很少,处理起来更快&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;什么情况下不创建索引&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;1.查询中很少使用到的列 不应该创建索引,如果建立了索引然而还会降低mysql的性能和增大了空间需求.&lt;br/&gt;2.很少数据的列也不应该建立索引,比如 一个性别字段 0或者1,在查询中,结果集的数据占了表中数据行的比例比较大,mysql需要扫描的行数很多,增加索引,并不能提高效率&lt;br/&gt;3.定义为text和image和bit数据类型的列不应该增加索引,&lt;br/&gt;4.当表的修改(UPDATE,INSERT,DELETE)操作远远大于检索(SELECT)操作时不应该创建索引,这两个操作是互斥的关系&lt;/p&gt;
</description>
<pubDate>Fri, 13 Nov 2020 00:15:00 +0000</pubDate>
<dc:creator>CoolYYD</dc:creator>
<og:description>MySql索引 索引优点 1.可以通过建立唯一索引或者主键索引,保证数据的唯一性.2.提高检索的数据性能3.在表连接的连接条件 可以加速表与表直接的相连&amp;#160;4.建立索引,在查询中使用索引 可以</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CoolYYD/p/13704593.html</dc:identifier>
</item>
<item>
<title>MySQL全面瓦解9：查询的排序、分页相关 - 翁智华</title>
<link>http://www.cnblogs.com/wzh2010/p/13843024.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wzh2010/p/13843024.html</guid>
<description>&lt;h3&gt;概述&lt;/h3&gt;
&lt;p&gt;数据库中的数据直接呈现出来一般不是我们想要的，所以我们上两节演示了如何对数据进行过滤的方法。除了对数据进行过滤，&lt;/p&gt;
&lt;p&gt;我们可能还需要对数据进行排序，比如想从列表中了解消费最高的项，就可能需要对金额字段做降序排序，想看年龄从小到大的分布情况，就可能需要对user表的age字段进行升序排序。&lt;/p&gt;
&lt;p&gt;也可能需要对数据进行限制，比如我们需要对付款的1~10，11~20，21~30 名的用户分别赠予不同的礼品，这时候对数据的限制就很有用了。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;备注：下面脚本中[]包含的表示可选，| 分隔符表示可选其一。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;数据排序 order by&lt;/h3&gt;
&lt;p&gt;语法格式如下：&lt;/p&gt;
&lt;p&gt;1、&lt;span&gt;需要排序的字段跟在&lt;/span&gt;&lt;code&gt;order by&lt;/code&gt;&lt;span&gt;之后；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、&lt;/span&gt;&lt;span&gt;asc 和 desc表示排序的规则，asc：升序，desc：降序，默认为升序 asc；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、&lt;/span&gt;排序可以指定多次字段，&lt;span&gt;多字段排序之间用逗号隔开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、多字段排序中，&lt;/span&gt;越靠前优先级越高，下面中cname1优先排序，当cname1等值的时候，cname2开始排序，直至所有字段都排序完。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; cname &lt;span&gt;from&lt;/span&gt; tname order by cname1 [asc|desc],cname2 [asc|desc]...;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;单个字段排序&lt;/h4&gt;
&lt;p&gt;举个例子，在销售额中通按照交易的订单进行金额额度降序的方式显示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 3&lt;/span&gt; | orderid | account | amount  | goods |
&lt;span&gt; 4&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 5&lt;/span&gt; |       &lt;span&gt;8&lt;/span&gt; | brand   | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |       &lt;span&gt;9&lt;/span&gt; | hen     | &lt;span&gt;1752.02&lt;/span&gt; |     &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |      &lt;span&gt;10&lt;/span&gt; | helyn   | &lt;span&gt;88.5&lt;/span&gt;    |     &lt;span&gt;4&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |      &lt;span&gt;11&lt;/span&gt; | sol     | &lt;span&gt;1007.9&lt;/span&gt;  |    &lt;span&gt;11&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |      &lt;span&gt;12&lt;/span&gt; | diny    | &lt;span&gt;12&lt;/span&gt;      |     &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; |      &lt;span&gt;13&lt;/span&gt; | weng    | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; |      &lt;span&gt;14&lt;/span&gt; | sally   | &lt;span&gt;99.71&lt;/span&gt;   |     &lt;span&gt;9&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;7&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;14&lt;/span&gt; 
&lt;span&gt;15&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order order by amount desc;
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;17&lt;/span&gt; | orderid | account | amount  | goods |
&lt;span&gt;18&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;19&lt;/span&gt; |       &lt;span&gt;9&lt;/span&gt; | hen     | &lt;span&gt;1752.02&lt;/span&gt; |     &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt;20&lt;/span&gt; |      &lt;span&gt;11&lt;/span&gt; | sol     | &lt;span&gt;1007.9&lt;/span&gt;  |    &lt;span&gt;11&lt;/span&gt; |
&lt;span&gt;21&lt;/span&gt; |      &lt;span&gt;14&lt;/span&gt; | sally   | &lt;span&gt;99.71&lt;/span&gt;   |     &lt;span&gt;9&lt;/span&gt; |
&lt;span&gt;22&lt;/span&gt; |      &lt;span&gt;10&lt;/span&gt; | helyn   | &lt;span&gt;88.5&lt;/span&gt;    |     &lt;span&gt;4&lt;/span&gt; |
&lt;span&gt;23&lt;/span&gt; |       &lt;span&gt;8&lt;/span&gt; | brand   | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt;24&lt;/span&gt; |      &lt;span&gt;13&lt;/span&gt; | weng    | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;25&lt;/span&gt; |      &lt;span&gt;12&lt;/span&gt; | diny    | &lt;span&gt;12&lt;/span&gt;      |     &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;26&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;7&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;多个字段排序&lt;/h4&gt;
&lt;p&gt;多个字段排序用逗号隔开，优先级从左到右逐次递减，如下图，如果金额一致，则按照购买商品数量从多到少排序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order order by amount desc,goods desc;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 3&lt;/span&gt; | orderid | account | amount  | goods |
&lt;span&gt; 4&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 5&lt;/span&gt; |       &lt;span&gt;9&lt;/span&gt; | hen     | &lt;span&gt;1752.02&lt;/span&gt; |     &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |      &lt;span&gt;11&lt;/span&gt; | sol     | &lt;span&gt;1007.9&lt;/span&gt;  |    &lt;span&gt;11&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |      &lt;span&gt;14&lt;/span&gt; | sally   | &lt;span&gt;99.71&lt;/span&gt;   |     &lt;span&gt;9&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |      &lt;span&gt;10&lt;/span&gt; | helyn   | &lt;span&gt;88.5&lt;/span&gt;    |     &lt;span&gt;4&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |      &lt;span&gt;13&lt;/span&gt; | weng    | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; |       &lt;span&gt;8&lt;/span&gt; | brand   | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; |      &lt;span&gt;12&lt;/span&gt; | diny    | &lt;span&gt;12&lt;/span&gt;      |     &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;7&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;按alias排序&lt;/h4&gt;
&lt;p&gt;按照别名排序或者做条件查询的目的都是为了简化代码，方便使用，别名可以是英文，也可以是中文：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; account &lt;span&gt;as&lt;/span&gt; &lt;span&gt;ac&lt;/span&gt;,amount &lt;span&gt;as&lt;/span&gt; &lt;span&gt;am&lt;/span&gt;,goods &lt;span&gt;as&lt;/span&gt; &lt;span&gt;gd&lt;/span&gt; &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order order by &lt;span&gt;am,gd desc&lt;/span&gt;;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;    
&lt;span&gt; 3&lt;/span&gt; +-------+---------+----+
&lt;span&gt; 4&lt;/span&gt; | ac    | am      | gd |
&lt;span&gt; 5&lt;/span&gt; +-------+---------+----+
&lt;span&gt; 6&lt;/span&gt; | diny  | &lt;span&gt;12&lt;/span&gt;      |  &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; | weng  | &lt;span&gt;52.2&lt;/span&gt;    |  &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; | brand | &lt;span&gt;52.2&lt;/span&gt;    |  &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; | helyn | &lt;span&gt;88.5&lt;/span&gt;    |  &lt;span&gt;4&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; | sally | &lt;span&gt;99.71&lt;/span&gt;   |  &lt;span&gt;9&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; | sol   | &lt;span&gt;1007.9&lt;/span&gt;  | &lt;span&gt;11&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; | hen   | &lt;span&gt;1752.02&lt;/span&gt; |  &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt;13&lt;/span&gt; +-------+---------+----+
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;7&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h4&gt;字段排序中使用函数&lt;/h4&gt;
&lt;p&gt;下面使用了abs取绝对值函数，所以在 am字段降序排序中，-99.99 排在 99.71之上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 3&lt;/span&gt; | orderid | account | amount  | goods |
&lt;span&gt; 4&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 5&lt;/span&gt; |       &lt;span&gt;8&lt;/span&gt; | brand   | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |       &lt;span&gt;9&lt;/span&gt; | hen     | &lt;span&gt;1752.02&lt;/span&gt; |     &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |      &lt;span&gt;10&lt;/span&gt; | helyn   | &lt;span&gt;88.5&lt;/span&gt;    |     &lt;span&gt;4&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |      &lt;span&gt;11&lt;/span&gt; | sol     | &lt;span&gt;1007.9&lt;/span&gt;  |    &lt;span&gt;11&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |      &lt;span&gt;12&lt;/span&gt; | diny    | &lt;span&gt;12&lt;/span&gt;      |     &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; |      &lt;span&gt;13&lt;/span&gt; | weng    | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; |      &lt;span&gt;14&lt;/span&gt; | sally   | &lt;span&gt;99.71&lt;/span&gt;   |     &lt;span&gt;9&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; |      &lt;span&gt;15&lt;/span&gt; | brand1  | -&lt;span&gt;99.99&lt;/span&gt;  |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;13&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; account &lt;span&gt;as&lt;/span&gt; ac,amount &lt;span&gt;as&lt;/span&gt; am,goods &lt;span&gt;as&lt;/span&gt; gd &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order order by abs(am) desc;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt;    
&lt;span&gt;18&lt;/span&gt; +--------+---------+----+
&lt;span&gt;19&lt;/span&gt; | ac     | am      | gd |
&lt;span&gt;20&lt;/span&gt; +--------+---------+----+
&lt;span&gt;21&lt;/span&gt; | hen    | &lt;span&gt;1752.02&lt;/span&gt; |  &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt;22&lt;/span&gt; | sol    | &lt;span&gt;1007.9&lt;/span&gt;  | &lt;span&gt;11&lt;/span&gt; |
&lt;span&gt;23&lt;/span&gt; | brand1 | -&lt;span&gt;99.99&lt;/span&gt;  |  &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;24&lt;/span&gt; | sally  | &lt;span&gt;99.71&lt;/span&gt;   |  &lt;span&gt;9&lt;/span&gt; |
&lt;span&gt;25&lt;/span&gt; | helyn  | &lt;span&gt;88.5&lt;/span&gt;    |  &lt;span&gt;4&lt;/span&gt; |
&lt;span&gt;26&lt;/span&gt; | brand  | &lt;span&gt;52.2&lt;/span&gt;    |  &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt;27&lt;/span&gt; | weng   | &lt;span&gt;52.2&lt;/span&gt;    |  &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;28&lt;/span&gt; | diny   | &lt;span&gt;12&lt;/span&gt;      |  &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;29&lt;/span&gt; +--------+---------+----+
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;与Where条件结合使用&lt;/h4&gt;
&lt;p&gt;order 在 where 条件之后，根据where已经过滤好的数据再进行排序。下面是过滤出购买金额&amp;gt;80 且 购买数量&amp;gt;5的数据，并且按照价格降序排序。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 3&lt;/span&gt; | orderid | account | amount  | goods |
&lt;span&gt; 4&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 5&lt;/span&gt; |       &lt;span&gt;8&lt;/span&gt; | brand   | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |       &lt;span&gt;9&lt;/span&gt; | hen     | &lt;span&gt;1752.02&lt;/span&gt; |     &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |      &lt;span&gt;10&lt;/span&gt; | helyn   | &lt;span&gt;88.5&lt;/span&gt;    |     &lt;span&gt;4&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |      &lt;span&gt;11&lt;/span&gt; | sol     | &lt;span&gt;1007.9&lt;/span&gt;  |    &lt;span&gt;11&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |      &lt;span&gt;12&lt;/span&gt; | diny    | &lt;span&gt;12&lt;/span&gt;      |     &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; |      &lt;span&gt;13&lt;/span&gt; | weng    | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; |      &lt;span&gt;14&lt;/span&gt; | sally   | &lt;span&gt;99.71&lt;/span&gt;   |     &lt;span&gt;9&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; |      &lt;span&gt;15&lt;/span&gt; | brand1  | -&lt;span&gt;99.99&lt;/span&gt;  |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;13&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t_order &lt;span&gt;where&lt;/span&gt; amount&amp;gt;&lt;span&gt;80&lt;/span&gt; and goods&amp;gt;&lt;span&gt;5&lt;/span&gt;&lt;span&gt; order by amount desc;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;18&lt;/span&gt; | orderid | account | amount  | goods |
&lt;span&gt;19&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;20&lt;/span&gt; |       &lt;span&gt;9&lt;/span&gt; | hen     | &lt;span&gt;1752.02&lt;/span&gt; |     &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt;21&lt;/span&gt; |      &lt;span&gt;11&lt;/span&gt; | sol     | &lt;span&gt;1007.9&lt;/span&gt;  |    &lt;span&gt;11&lt;/span&gt; |
&lt;span&gt;22&lt;/span&gt; |      &lt;span&gt;14&lt;/span&gt; | sally   | &lt;span&gt;99.71&lt;/span&gt;   |     &lt;span&gt;9&lt;/span&gt; |
&lt;span&gt;23&lt;/span&gt; +---------+---------+---------+-------+
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;数据limit&lt;/h3&gt;
&lt;p&gt;很多时候我们过滤出符合要求的数据之后，还需要得到这些数据中的某一个具体区间，比如对付款超过1000的用户的第1~10，11~20，21~30 名分别赠予不同的礼品，这时候就要使用limit操作了。&lt;/p&gt;
&lt;p&gt;limit用来限制select查询返回的数据，常用于数据排行或者分页等情况。&lt;/p&gt;
&lt;p&gt;语法格式如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; cname &lt;span&gt;from&lt;/span&gt; tname limit [offset,] count;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;1、&lt;span&gt;offset表示偏移量，就是指跳过的行数，可以省略不写，默认为0，表示跳过0行，如 limit 8 等同于 limit 0,8。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、&lt;/span&gt;&lt;span&gt;count：跳过偏移量offset之后开始取的数据行数，有count行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、&lt;/span&gt;&lt;span&gt;limit中offset和count的值不能用表达式。&lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;获取前n条记录&lt;/h4&gt;
&lt;p&gt;如下图，limit n 和 limit 0,n 是一致的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 3&lt;/span&gt; | orderid | account | amount  | goods |
&lt;span&gt; 4&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 5&lt;/span&gt; |       &lt;span&gt;8&lt;/span&gt; | brand   | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |       &lt;span&gt;9&lt;/span&gt; | hen     | &lt;span&gt;1752.02&lt;/span&gt; |     &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |      &lt;span&gt;10&lt;/span&gt; | helyn   | &lt;span&gt;88.5&lt;/span&gt;    |     &lt;span&gt;4&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |      &lt;span&gt;11&lt;/span&gt; | sol     | &lt;span&gt;1007.9&lt;/span&gt;  |    &lt;span&gt;11&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |      &lt;span&gt;12&lt;/span&gt; | diny    | &lt;span&gt;12&lt;/span&gt;      |     &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; |      &lt;span&gt;13&lt;/span&gt; | weng    | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; |      &lt;span&gt;14&lt;/span&gt; | sally   | &lt;span&gt;99.71&lt;/span&gt;   |     &lt;span&gt;9&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; |      &lt;span&gt;15&lt;/span&gt; | brand1  | -&lt;span&gt;99.99&lt;/span&gt;  |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;13&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t_order limit &lt;span&gt;2&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;;
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;19&lt;/span&gt; | orderid | account | amount  | goods |
&lt;span&gt;20&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;21&lt;/span&gt; |       &lt;span&gt;8&lt;/span&gt; | brand   | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt;22&lt;/span&gt; |       &lt;span&gt;9&lt;/span&gt; | hen     | &lt;span&gt;1752.02&lt;/span&gt; |     &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt;23&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t_order limit &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;2&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;28&lt;/span&gt; | orderid | account | amount  | goods |
&lt;span&gt;29&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;30&lt;/span&gt; |       &lt;span&gt;8&lt;/span&gt; | brand   | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt;31&lt;/span&gt; |       &lt;span&gt;9&lt;/span&gt; | hen     | &lt;span&gt;1752.02&lt;/span&gt; |     &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt;32&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;33&lt;/span&gt; &lt;span&gt;2&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;limit限制单条记录&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;这边我们获取支付金额中最大和最小的的一条记录。可以先使用 order 条件进行排序，然后limit 第1条记录即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt;  &lt;span&gt;1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt;  &lt;span&gt;2&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 3&lt;/span&gt;  &lt;span&gt;3&lt;/span&gt; | orderid | account | amount  | goods |
&lt;span&gt; 4&lt;/span&gt;  &lt;span&gt;4&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 5&lt;/span&gt;  &lt;span&gt;5&lt;/span&gt; |       &lt;span&gt;8&lt;/span&gt; | brand   | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt;  &lt;span&gt;6&lt;/span&gt; |       &lt;span&gt;9&lt;/span&gt; | hen     | &lt;span&gt;1752.02&lt;/span&gt; |     &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt;  &lt;span&gt;7&lt;/span&gt; |      &lt;span&gt;10&lt;/span&gt; | helyn   | &lt;span&gt;88.5&lt;/span&gt;    |     &lt;span&gt;4&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt;  &lt;span&gt;8&lt;/span&gt; |      &lt;span&gt;11&lt;/span&gt; | sol     | &lt;span&gt;1007.9&lt;/span&gt;  |    &lt;span&gt;11&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt;  &lt;span&gt;9&lt;/span&gt; |      &lt;span&gt;12&lt;/span&gt; | diny    | &lt;span&gt;12&lt;/span&gt;      |     &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; |      &lt;span&gt;13&lt;/span&gt; | weng    | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;11&lt;/span&gt; |      &lt;span&gt;14&lt;/span&gt; | sally   | &lt;span&gt;99.71&lt;/span&gt;   |     &lt;span&gt;9&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;12&lt;/span&gt; |      &lt;span&gt;15&lt;/span&gt; | brand1  | -&lt;span&gt;99.99&lt;/span&gt;  |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;13&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;14&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; &lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;16&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t_order &lt;span&gt;where amount&amp;gt;0 order by amount desc limit 1;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;17&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;18&lt;/span&gt; &lt;span&gt;18&lt;/span&gt; | orderid | account | amount  | goods |
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;19&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;20&lt;/span&gt; &lt;span&gt;20&lt;/span&gt; |       &lt;span&gt;9&lt;/span&gt; | hen     | &lt;span&gt;1752.02&lt;/span&gt; |     &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt;21&lt;/span&gt; &lt;span&gt;21&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;22&lt;/span&gt; &lt;span&gt;22&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt; &lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;24&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t_order &lt;span&gt;where amount&amp;gt;0 order by amount asc limit 1;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;25&lt;/span&gt; +---------+---------+--------+-------+
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;26&lt;/span&gt; | orderid | account | amount | goods |
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;27&lt;/span&gt; +---------+---------+--------+-------+
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;28&lt;/span&gt; |      &lt;span&gt;12&lt;/span&gt; | diny    | &lt;span&gt;12&lt;/span&gt;     |     &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt;29&lt;/span&gt; &lt;span&gt;29&lt;/span&gt; +---------+---------+--------+-------+
&lt;span&gt;30&lt;/span&gt; &lt;span&gt;30&lt;/span&gt; &lt;span&gt;1&lt;/span&gt; row &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;31&lt;/span&gt;  
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;获取(m,n)区间记录&lt;/h4&gt;
&lt;p&gt;即跳过m条，获取n条，示例如下，我们跳过两条，从第三条开始，连取四条的操作：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; t_order order by amount;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 3&lt;/span&gt; | orderid | account | amount  | goods |
&lt;span&gt; 4&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt; 5&lt;/span&gt; |      &lt;span&gt;15&lt;/span&gt; | brand1  | -&lt;span&gt;99.99&lt;/span&gt;  |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt; 6&lt;/span&gt; |      &lt;span&gt;12&lt;/span&gt; | diny    | &lt;span&gt;12&lt;/span&gt;      |     &lt;span&gt;1&lt;/span&gt; |
&lt;span&gt; 7&lt;/span&gt; |       &lt;span&gt;8&lt;/span&gt; | brand   | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt; 8&lt;/span&gt; |      &lt;span&gt;13&lt;/span&gt; | weng    | &lt;span&gt;52.2&lt;/span&gt;    |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt; 9&lt;/span&gt; |      &lt;span&gt;10&lt;/span&gt; | helyn   | &lt;span&gt;88.5&lt;/span&gt;    |     &lt;span&gt;4&lt;/span&gt; |
&lt;span&gt;10&lt;/span&gt; |      &lt;span&gt;14&lt;/span&gt; | sally   | &lt;span&gt;99.71&lt;/span&gt;   |     &lt;span&gt;9&lt;/span&gt; |
&lt;span&gt;11&lt;/span&gt; |      &lt;span&gt;11&lt;/span&gt; | sol     | &lt;span&gt;1007.9&lt;/span&gt;  |    &lt;span&gt;11&lt;/span&gt; |
&lt;span&gt;12&lt;/span&gt; |       &lt;span&gt;9&lt;/span&gt; | hen     | &lt;span&gt;1752.02&lt;/span&gt; |     &lt;span&gt;7&lt;/span&gt; |
&lt;span&gt;13&lt;/span&gt; +---------+---------+---------+-------+
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;8&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; t_order &lt;span&gt;order by amount limit 2,4;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; +---------+---------+--------+-------+
&lt;span&gt;18&lt;/span&gt; | orderid | account | amount | goods |
&lt;span&gt;19&lt;/span&gt; +---------+---------+--------+-------+
&lt;span&gt;20&lt;/span&gt; |       &lt;span&gt;8&lt;/span&gt; | brand   | &lt;span&gt;52.2&lt;/span&gt;   |     &lt;span&gt;2&lt;/span&gt; |
&lt;span&gt;21&lt;/span&gt; |      &lt;span&gt;13&lt;/span&gt; | weng    | &lt;span&gt;52.2&lt;/span&gt;   |     &lt;span&gt;5&lt;/span&gt; |
&lt;span&gt;22&lt;/span&gt; |      &lt;span&gt;10&lt;/span&gt; | helyn   | &lt;span&gt;88.5&lt;/span&gt;   |     &lt;span&gt;4&lt;/span&gt; |
&lt;span&gt;23&lt;/span&gt; |      &lt;span&gt;14&lt;/span&gt; | sally   | &lt;span&gt;99.71&lt;/span&gt;  |     &lt;span&gt;9&lt;/span&gt; |
&lt;span&gt;24&lt;/span&gt; +---------+---------+--------+-------+
&lt;span&gt;25&lt;/span&gt; &lt;span&gt;4&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;分页的做法与这个类似，我们程序业务上看到的分页一般有 pageIndex，pageSize等参数，我们通常的做法是 limit pageIndex*pageSize,pageSize。&lt;/p&gt;
&lt;p&gt;这边假设有31条数据，每页数量pageSize=10，页面索引pageIndex默认0，则第一页就是 limit 0,10，第二页 limit10,10，第三页 limit 20,10，第四页 limit 30,10。&lt;/p&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;p&gt;1、limit 后面不能使用表达式，只能使用明确的数值，否则会爆出异常，比如 limit 0*10,10，是不对的，这个上面提过了。&lt;/p&gt;
&lt;p&gt;2、limit后续的数值只能是正整数和0，也就是说，不能是负数，否则同样会报错。&lt;/p&gt;
&lt;p&gt;3、排序字段的值相同情况下，排序后分页会出现混乱重复的情况。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第3点详细说明下：假如根据age排序，但是有多个age都是20岁的同学，这时候我们3条记录一页，就会出现分页混乱数据重复。因为年龄相同的人有多个，这是几个人的排序在每次查询的时候会有不确定性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;举个例子，下面的分页，混乱了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user3;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +----+------+-------+
&lt;span&gt; 3&lt;/span&gt; | id | age  | name  |
&lt;span&gt; 4&lt;/span&gt; +----+------+-------+
&lt;span&gt; 5&lt;/span&gt; |  &lt;span&gt;1&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | brand |
&lt;span&gt; 6&lt;/span&gt; |  &lt;span&gt;2&lt;/span&gt; |   &lt;span&gt;22&lt;/span&gt; | sol   |
&lt;span&gt; 7&lt;/span&gt; |  &lt;span&gt;3&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | helen |
&lt;span&gt; 8&lt;/span&gt; |  &lt;span&gt;4&lt;/span&gt; | &lt;span&gt;19.5&lt;/span&gt; | diny  |
&lt;span&gt; 9&lt;/span&gt; |  &lt;span&gt;6&lt;/span&gt; |   &lt;span&gt;19&lt;/span&gt; | a     |
&lt;span&gt;10&lt;/span&gt; |  &lt;span&gt;7&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | b     |
&lt;span&gt;11&lt;/span&gt; |  &lt;span&gt;8&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | c     |
&lt;span&gt;12&lt;/span&gt; |  &lt;span&gt;9&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | d     |
&lt;span&gt;13&lt;/span&gt; | &lt;span&gt;10&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | e     |
&lt;span&gt;14&lt;/span&gt; | &lt;span&gt;11&lt;/span&gt; |   &lt;span&gt;23&lt;/span&gt; | f     |
&lt;span&gt;15&lt;/span&gt; +----+------+-------+
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; user3 order by age limit &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;; 
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt; +----+------+-------+
&lt;span&gt;20&lt;/span&gt; | id | age  | name  |
&lt;span&gt;21&lt;/span&gt; +----+------+-------+
&lt;span&gt;22&lt;/span&gt; |  &lt;span&gt;6&lt;/span&gt; |   &lt;span&gt;19&lt;/span&gt; | a     |
&lt;span&gt;23&lt;/span&gt; |  &lt;span&gt;4&lt;/span&gt; | &lt;span&gt;19.5&lt;/span&gt; | diny  |
&lt;span&gt;24&lt;/span&gt; |  &lt;span&gt;3&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | helen |
&lt;span&gt;25&lt;/span&gt; +----+------+-------+
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; user3 order by age limit &lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt;  
&lt;span&gt;30&lt;/span&gt; +----+-----+-------+
&lt;span&gt;31&lt;/span&gt; | id | age | name  |
&lt;span&gt;32&lt;/span&gt; +----+-----+-------+
&lt;span&gt;33&lt;/span&gt; |  &lt;span&gt;3&lt;/span&gt; |  &lt;span&gt;20&lt;/span&gt; | helen |
&lt;span&gt;34&lt;/span&gt; |  &lt;span&gt;7&lt;/span&gt; |  &lt;span&gt;20&lt;/span&gt; | b     |
&lt;span&gt;35&lt;/span&gt; |  &lt;span&gt;8&lt;/span&gt; |  &lt;span&gt;20&lt;/span&gt; | c     |
&lt;span&gt;36&lt;/span&gt; +----+-----+-------+
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; 
&lt;span&gt;39&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; user3 order by age limit &lt;span&gt;6&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;  
&lt;span&gt;41&lt;/span&gt; +----+-----+-------+
&lt;span&gt;42&lt;/span&gt; | id | age | name  |
&lt;span&gt;43&lt;/span&gt; +----+-----+-------+
&lt;span&gt;44&lt;/span&gt; |  &lt;span&gt;7&lt;/span&gt; |  &lt;span&gt;20&lt;/span&gt; | b     |
&lt;span&gt;45&lt;/span&gt; |  &lt;span&gt;3&lt;/span&gt; |  &lt;span&gt;20&lt;/span&gt; | helen |
&lt;span&gt;46&lt;/span&gt; |  &lt;span&gt;2&lt;/span&gt; |  &lt;span&gt;22&lt;/span&gt; | sol   |
&lt;span&gt;47&lt;/span&gt; +----+-----+-------+
&lt;span&gt;48&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们的做法是使用重复值字段做排序的时候再加个唯一依据（一般可以设主键），就不会混乱了。&lt;/p&gt;
&lt;p&gt;如下示例，正常了：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt;&lt;span&gt; user3;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; +----+------+-------+
&lt;span&gt; 3&lt;/span&gt; | id | age  | name  |
&lt;span&gt; 4&lt;/span&gt; +----+------+-------+
&lt;span&gt; 5&lt;/span&gt; |  &lt;span&gt;1&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | brand |
&lt;span&gt; 6&lt;/span&gt; |  &lt;span&gt;2&lt;/span&gt; |   &lt;span&gt;22&lt;/span&gt; | sol   |
&lt;span&gt; 7&lt;/span&gt; |  &lt;span&gt;3&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | helen |
&lt;span&gt; 8&lt;/span&gt; |  &lt;span&gt;4&lt;/span&gt; | &lt;span&gt;19.5&lt;/span&gt; | diny  |
&lt;span&gt; 9&lt;/span&gt; |  &lt;span&gt;6&lt;/span&gt; |   &lt;span&gt;19&lt;/span&gt; | a     |
&lt;span&gt;10&lt;/span&gt; |  &lt;span&gt;7&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | b     |
&lt;span&gt;11&lt;/span&gt; |  &lt;span&gt;8&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | c     |
&lt;span&gt;12&lt;/span&gt; |  &lt;span&gt;9&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | d     |
&lt;span&gt;13&lt;/span&gt; | &lt;span&gt;10&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | e     |
&lt;span&gt;14&lt;/span&gt; | &lt;span&gt;11&lt;/span&gt; |   &lt;span&gt;23&lt;/span&gt; | f     |
&lt;span&gt;15&lt;/span&gt; +----+------+-------+
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;10&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; 
&lt;span&gt;18&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; user3 &lt;span&gt;order by age,id&lt;/span&gt; limit &lt;span&gt;0&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;  
&lt;span&gt;20&lt;/span&gt; +----+------+-------+
&lt;span&gt;21&lt;/span&gt; | id | age  | name  |
&lt;span&gt;22&lt;/span&gt; +----+------+-------+
&lt;span&gt;23&lt;/span&gt; |  &lt;span&gt;6&lt;/span&gt; |   &lt;span&gt;19&lt;/span&gt; | a     |
&lt;span&gt;24&lt;/span&gt; |  &lt;span&gt;4&lt;/span&gt; | &lt;span&gt;19.5&lt;/span&gt; | diny  |
&lt;span&gt;25&lt;/span&gt; |  &lt;span&gt;1&lt;/span&gt; |   &lt;span&gt;20&lt;/span&gt; | brand |
&lt;span&gt;26&lt;/span&gt; +----+------+-------+
&lt;span&gt;27&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt; 
&lt;span&gt;29&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; user3&lt;span&gt; order by age,id&lt;/span&gt; limit &lt;span&gt;3&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;  
&lt;span&gt;31&lt;/span&gt; +----+-----+-------+
&lt;span&gt;32&lt;/span&gt; | id | age | name  |
&lt;span&gt;33&lt;/span&gt; +----+-----+-------+
&lt;span&gt;34&lt;/span&gt; |  &lt;span&gt;3&lt;/span&gt; |  &lt;span&gt;20&lt;/span&gt; | helen |
&lt;span&gt;35&lt;/span&gt; |  &lt;span&gt;7&lt;/span&gt; |  &lt;span&gt;20&lt;/span&gt; | b     |
&lt;span&gt;36&lt;/span&gt; |  &lt;span&gt;8&lt;/span&gt; |  &lt;span&gt;20&lt;/span&gt; | c     |
&lt;span&gt;37&lt;/span&gt; +----+-----+-------+
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;span&gt;39&lt;/span&gt; 
&lt;span&gt;40&lt;/span&gt; mysql&amp;gt; &lt;span&gt;select&lt;/span&gt; * &lt;span&gt;from&lt;/span&gt; user3 &lt;span&gt;order by age,id&lt;/span&gt; limit &lt;span&gt;6&lt;/span&gt;,&lt;span&gt;3&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;  
&lt;span&gt;42&lt;/span&gt; +----+-----+------+
&lt;span&gt;43&lt;/span&gt; | id | age | name |
&lt;span&gt;44&lt;/span&gt; +----+-----+------+
&lt;span&gt;45&lt;/span&gt; |  &lt;span&gt;9&lt;/span&gt; |  &lt;span&gt;20&lt;/span&gt; | d    |
&lt;span&gt;46&lt;/span&gt; | &lt;span&gt;10&lt;/span&gt; |  &lt;span&gt;20&lt;/span&gt; | e    |
&lt;span&gt;47&lt;/span&gt; |  &lt;span&gt;2&lt;/span&gt; |  &lt;span&gt;22&lt;/span&gt; | sol  |
&lt;span&gt;48&lt;/span&gt; +----+-----+------+
&lt;span&gt;49&lt;/span&gt; &lt;span&gt;3&lt;/span&gt; rows &lt;span&gt;in&lt;/span&gt; &lt;span&gt;set&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;上述总结&lt;/h3&gt;
&lt;p&gt;1、order by cname [asc|desc] 用于对查询结果排序，asc为升序，desc为降序，可以省略，省略情况下默认为asc。&lt;/p&gt;
&lt;p&gt;2、limit用来限制查询结果返回的行数，包含2个参数（offset，count），offset：表示跳过多少行，count：表示跳过offset行之后取的行数。limit中offset可以省略，默认值为0；limit中offset 和 count都必须大于等于0；limit中offset和count的值不能用表达式。&lt;/p&gt;
&lt;p&gt;3、分页排序时，排序字段不要有重复值，重复值情况下可能会导致分页结果混乱，建议在后面加一个主键排序。&lt;/p&gt;
</description>
<pubDate>Fri, 13 Nov 2020 00:07:00 +0000</pubDate>
<dc:creator>翁智华</dc:creator>
<og:description>概述 数据库中的数据直接呈现出来一般不是我们想要的，所以我们上两节演示了如何对数据进行过滤的方法。除了对数据进行过滤， 我们可能还需要对数据进行排序，比如想从列表中了解消费最高的项，就可能需要对金额字</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/wzh2010/p/13843024.html</dc:identifier>
</item>
<item>
<title>Facebook 的神仙组长什么样？ - 码农田小齐</title>
<link>http://www.cnblogs.com/nycsde/p/13967362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nycsde/p/13967362.html</guid>
<description>&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;em&gt;这里是《齐姐聊大厂》系列的第 14 篇&lt;/em&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span&gt;&lt;strong&gt;每周五早上 8 点，与你唠唠大厂的那些事&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;号外号外！前 12 篇已出 PDF：公粽号后台回复「大厂」即可获得！&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://tva1.sinaimg.cn/large/0081Kckwly1gkn6f6h1lwj30jc0jl0vh.jpg&quot; alt=&quot;&quot;/&gt;&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;小齐说：&lt;/p&gt;
&lt;p&gt;这篇文章是来自阿米粥的分享，他今年暑假在 Facebook 实习，跟大家完整的分享从申请面试到实习结束的整个过程，让我们一起来感受下吧～&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;时间线&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是 2019 年 9 月底找朋友内推的 facebook software engineer summer internship 岗位，fb 的 hr 工作效率很高，3 个工作日之内就有了邮件回复，说在看简历。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;10 月初的时候某个周四收到短信，说下周三有面试官来学校宣讲会，问我有没有兴趣直接参加面试，白板作答。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;第一轮通过后，第二轮是电面。之后收到邮件约了 10 月 30 日早上的第三次加面（也是电面），在当天下午就拿到了 offer（再次感叹工作效率）。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;实习&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我是 2020 年 6 月开始的 summer internship，做的是 ios 类的开发工作。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为今年是在家工作，也有了不一样的工作体验，开始是一些设置，有很详细教学，跟着一步一步来很快就能上路。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的 mentor 是一个国人小哥，我们早在今年 4 月份左右就有了邮件联系，主要是问他有没有什么推荐的书籍可以提前阅读熟悉工作语言（我是第一次做 ios，没有经验，略紧张）。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;没想到小哥长篇大论写了 500 字的小作文回复我，大概意思就是他也是实习生转正的，可以理解我的心情，但是不用太过紧张，工作起来啥都会了。但是也&lt;strong&gt;推荐了两本基础的书&lt;/strong&gt;，让我有时间可以学习学习（事实证明真的很有用，因为读了这两本书我看 code 非常熟悉，不用去查询 syntax 这些内容，直接就能理解到）。&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;9&quot;&gt;
&lt;p&gt;&lt;span&gt;❝&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;小齐问：哪些书呢？&lt;/p&gt;
&lt;p&gt;&quot;Objective-C Programming: The Big Nerd Ranch Guide&quot; pretty good for beginners, and &quot;Effective Objective-C 2.0&quot; for more advanced topics and tricks.&lt;/p&gt;
&lt;span&gt;❞&lt;/span&gt;&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，我也自己找了一些 tutorial，例如 Stanford 的 ios 课来学习，这些前期的准备工作真的为我后面无比顺利的实习打下了坚实的基础。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在收到分组信息知道自己的 mentor 的邮箱后，去打个招呼，简短介绍一下自己，了解一下这个组是干嘛的，开发 app 的话是开发哪个功能，提前熟悉一下准没错；如果不熟悉工作语言，也可以像我一样问问 mentor 有没有推荐的学习材料。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6 月份开始实习后，我发现自己进到了一个神仙组。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;mentor 在第一周每天都和我视频电话，手把手带我熟悉各种工具，发消息必秒回，无法文字解释清楚的直接共享屏幕教我，并且跟我说，你不要觉得现在问题多不好意思或者怎么样，也不要自己钻一样东西钻几个小时不问，不仅浪费时间我也没办法知道你的问题和进度。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为前期的问题都能得到很快的解决，我在第一周就做完了第二周要做的活。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;此外，每周的组会上，老板也会问我对工作有什么想法和意见，进度怎么样了，觉得难了简单了等等。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我的两个 mentor 中有一个是工作狂，就是随时随地晚上 11 点找他他都在的那种，所以我写的东西基本是全天候都有人 review，效率极高。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;组内的人都非常友好，我的 mentor 帮我和 design 的人拉了一个群，我有一些 design 方面要求不清楚的都能直接和 designer 沟通。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;实习期中 review 的时候我已经把整个 project 做完了，manager 知道后也很开心，专门开了一个会问我你对什么方面感兴趣，接下来的五周你就可以做你感兴趣的活。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;为了拿 return offer 其实我有点功利，我就说现在组里有什么比较紧急的活要做吗，我做这些就好了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;manager 就派了一些组内 priority 较高的活给我，所以后半段的时间我基本都在帮组里解决一些 priority 较高，且我能 handle 的事情。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;hr 组织的活动也挺有意思的，每周都有和本学校的 intern 的 tea time。大家互相了解一下，增进校友感情。每周我们有组内 intern happy hour（intern 和 mentor 一起），每两周有 team happy hour。气氛轻松活跃，每周的 happy hour 就是最好的放松时间。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 fb 实习的这段经历让我觉得我时刻都是被人关注着的。mentor 随 call 随到，manager 每周都来过问感受，hr 也问过三次情况。感觉公司很注重实习生的体验，也想要对自己的不足有所改进。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后离职的时候组里每个 member 都发了一段话给我，非常感动，希望今后也有机会继续合作。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;建议&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;最后说一些自己的建议和感想吧：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;前期不懂就问，不要自己想两三个小时浪费时间。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;中后期自己多查文件，找网上的例子或者类似的代码，尝试自己解决实在不行再问，不要浪费 mentor 时间。 重复的问题最好不要犯第二遍。一些比较复杂的 setting 或者操作要有个记录，避免下次又去问 mentor 耽搁大家的时间，他也可能会怀疑你的学习能力。我也知道一些 intern 说自己的 mentor 不负责或者不好，如果觉得自己不被平等待遇了，一定要尽早反馈给 manager 或 intern director，尽早让他们知道你的处境，不然后期根本没办法翻盘。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;中期 review 如果是 no trend to offer，也不要自暴自弃，大批的人后期逆风翻盘的。主要是要看 mentor 和 peer mentor 给的意见，有哪些要改进的，他们都会就 axes 说的很清楚。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;要善于和勇于 mentor 沟通，不要害怕。可以问 mentor，你觉得我现在哪里还能改进的，大部分 mentor 都是乐于解答的。这样自己也能尽快知道自己的不足，加以改进。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;总的来说，在 fb 的实习经历体验非常好，也顺利拿到了 return offer，明年 2 月份就入职了。我知道今年工作不好找，希望大家不要气馁，祝大家都能拿到 offer！&lt;/p&gt;
</description>
<pubDate>Fri, 13 Nov 2020 00:04:00 +0000</pubDate>
<dc:creator>码农田小齐</dc:creator>
<og:description>这里是《齐姐聊大厂》系列的第 14 篇 每周五早上 8 点，与你唠唠大厂的那些事 号外号外！前 12 篇已出 PDF：公粽号后台回复「大厂」即可获得！ ❝ 小齐说： 这篇文章是来自阿米粥的分享，他今年</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/nycsde/p/13967362.html</dc:identifier>
</item>
<item>
<title>[C#.NET 拾遗补漏]12：死锁和活锁的发生及避免 - 精致码农</title>
<link>http://www.cnblogs.com/willick/p/13967346.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/willick/p/13967346.html</guid>
<description>&lt;p&gt;多线程编程时，如果涉及同时读写共享数据，就要格外小心。如果共享数据是独占资源，则要对共享数据的读写进行排它访问，最简单的方式就是加锁。锁也不能随便用，否则可能会造成死锁和活锁。本文将通过示例详细讲解死锁和活锁是如何发生的​，以及如何避免它们。​&lt;/p&gt;
&lt;h2 id=&quot;避免多线程同时读写共享数据&quot;&gt;避免多线程同时读写共享数据&lt;/h2&gt;
&lt;p&gt;在实际开发中，难免会遇到多线程读写共享数据的需求。比如在某个业务处理时，先获取共享数据（比如是一个计数），再利用共享数据进行某些计算和业务处理，最后把共享数据修改为一个新的值。由于是多个线程同时操作，某个线程取得共享数据后，紧接着共享数据可能又被其它线程修改了，那么这个线程取得的数据就是错误的旧数据。我们来看一个具体代码示例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static int count { get; set; }

static void Main(string[] args)
{
    for (int i = 1; i &amp;lt;= 2; i++)
    {
        var thread = new Thread(ThreadMethod);
        thread.Start(i);
        Thread.Sleep(500);
    }
}

static void ThreadMethod(object threadNo)
{
    while (true)
    {
        var temp = count;
        Console.WriteLine(&quot;线程 &quot; + threadNo + &quot; 读取计数&quot;);
        Thread.Sleep(1000); // 模拟耗时工作
        count = temp + 1;
        Console.WriteLine(&quot;线程 &quot; + threadNo + &quot; 已将计数增加至: &quot; + count);
        Thread.Sleep(1000);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例中开启了两个独立的线程开始工作并计数，假使当 &lt;code&gt;ThreadMethod&lt;/code&gt; 被执行第 4 次的时候（即此刻 &lt;code&gt;count&lt;/code&gt; 值应为 4），&lt;code&gt;count&lt;/code&gt; 值的变化过程应该是：1、2、3、4，而实际运行时计数的的变化却是：1、1、2、2...。也就是说，除了第一次，后面每次，两个线程读取到的计数都是旧的错误数据，这个错误数据我们把它叫作&lt;strong&gt;脏数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因此，对共享数据进行读写时，应视其为独占资源，进行排它访问，避免同时读写。在一个线程对其进行读写时，其它线程必须等待。避免同时读写共享数据最简单的方法就是加&lt;strong&gt;锁&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;修改一下示例，对 &lt;code&gt;count&lt;/code&gt; 加锁：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;static int count { get; set; }
static readonly object key = new object();

static void Main(string[] args)
{
    ...
}

static void ThreadMethod(object threadNumber)
{
    while (true)
    {
        lock(key)
        {
            var temp = count;
            ...
             count = temp + 1;
            ...
        }
        Thread.Sleep(1000);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样就保证了同时只能有一个线程对共享数据进行读写，避免出现脏数据。&lt;/p&gt;
&lt;h2 id=&quot;死锁的发生&quot;&gt;死锁的发生&lt;/h2&gt;
&lt;p&gt;上面为了解决多线程同时读写共享数据问题，引入了锁。但如果同一个线程需要在一个任务内占用多个独占资源，这又会带来新的问题：死锁。简单来说，当线程在请求独占资源得不到满足而等待时，又不释放已占有资源，就会出现死锁。死锁就是多个线程同时彼此循环等待，都等着另一方释放其占有的资源给自己用，你等我，我待你，你我永远都处在彼此等待的状态，陷入僵局。下面用示例演示死锁是如何发生的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;class Program
{
    static void Main(string[] args)
    {
        var workers = new Workers();
        workers.StartThreads();
        var output = workers.GetResult();
        Console.WriteLine(output);
    }
}

class Workers
{
    Thread thread1, thread2;

    object resourceA = new object();
    object resourceB = new object();

    string output;

    public void StartThreads()
    {
        thread1 = new Thread(Thread1DoWork);
        thread2 = new Thread(Thread2DoWork);
        thread1.Start();
        thread2.Start();
    }

    public string GetResult()
    {
        thread1.Join();
        thread2.Join();
        return output;
    }

    public void Thread1DoWork()
    {
        lock (resourceA)
        {
            Thread.Sleep(100);
            lock (resourceB)
            {
                output += &quot;T1#&quot;;
            }
        }
    }

    public void Thread2DoWork()
    {
        lock (resourceB)
        {
            Thread.Sleep(100);
            lock (resourceA)
            {
                output += &quot;T2#&quot;;
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;示例运行后永远没有输出结果，发生了死锁。线程 1 工作时锁定了资源 A，期间需要锁定使用资源 B；但此时资源 B 被线程 2 独占，恰巧资线程 2 此时又在待资源 A 被释放；而资源 A 又被线程 1 占用......，如此，双方陷入了永远的循环等待中。&lt;/p&gt;
&lt;h2 id=&quot;死锁的避免&quot;&gt;死锁的避免&lt;/h2&gt;
&lt;p&gt;针对以上出现死锁的情况，要避免死锁，可以使用 &lt;code&gt;Monitor.TryEnter(obj, timeout)&lt;/code&gt; 方法来检查某个对象是否被占用。这个方法尝试获取指定对象的独占权限，如果 &lt;code&gt;timeout&lt;/code&gt; 时间内依然不能获得该对象的访问权，则主动“屈服”，调用 &lt;code&gt;Thread.Yield()&lt;/code&gt; 方法把该线程已占用的其它资源交还给 CUP，这样其它等待该资源的线程就可以继续执行了。即，线程在请求独占资源得不到满足时，主动作出让步，避免造成死锁。&lt;/p&gt;
&lt;p&gt;把上面示例代码的 &lt;code&gt;Workers&lt;/code&gt; 类的 &lt;code&gt;Thread1DoWork&lt;/code&gt; 方法使用 &lt;code&gt;Monitor.TryEnter&lt;/code&gt; 修改一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;// ...（省略相同代码）
public void Thread1DoWork()
{
    bool mustDoWork = true;
    while (mustDoWork)
    {
        lock (resourceA)
        {
            Thread.Sleep(100);
            if (Monitor.TryEnter(resourceB, 0))
            {
                output += &quot;T1#&quot;;
                mustDoWork = false;
                Monitor.Exit(resourceB);
            }
        }
        if (mustDoWork) Thread.Yield();
    }
}

public void Thread2DoWork()
{
    lock (resourceB)
    {
        Thread.Sleep(100);
        lock (resourceA)
        {
            output += &quot;T2#&quot;;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再次运行示例，程序正常输出 &lt;code&gt;T2#T1#&lt;/code&gt; 并正常结束，解决了死锁问题。&lt;/p&gt;
&lt;p&gt;注意，这个解决方法依赖于线程 2 对其所需的独占资源的固执占有和线程 1 愿意“屈服”作出让步，让线程 2 总是优先执行。同时注意，线程 1 在锁定 &lt;code&gt;resourceA&lt;/code&gt; 后，由于争夺不到 &lt;code&gt;resourceB&lt;/code&gt;，作出了让步，把已占有的 &lt;code&gt;resourceA&lt;/code&gt; 释放掉后，就必须等线程 2 使用完 &lt;code&gt;resourceA&lt;/code&gt; 重新锁定 &lt;code&gt;resourceA&lt;/code&gt; 再重做工作。&lt;/p&gt;
&lt;p&gt;正因为线程 2 总是优先，所以，如果线程 2 占用 &lt;code&gt;resourceA&lt;/code&gt; 或 &lt;code&gt;resourceB&lt;/code&gt; 的频率非常高（比如外面再嵌套一个类似 &lt;code&gt;while(true)&lt;/code&gt; 的循环 ），那么就可能导致线程 1 一直无法获得所需要的资源，这种现象叫&lt;strong&gt;线程饥饿&lt;/strong&gt;，是由高优先级线程吞噬低优先级线程 CPU 执行时间的原因造成的。线程饥饿除了这种的原因，还有可能是线程在等待一个本身也处于永久等待完成的任务。&lt;/p&gt;
&lt;p&gt;我们可以继续开个脑洞，上面示例中，如果线程 2 也愿意让步，会出现什么情况呢？&lt;/p&gt;
&lt;h2 id=&quot;活锁的发生和避免&quot;&gt;活锁的发生和避免&lt;/h2&gt;
&lt;p&gt;我们把上面示例改造一下，使线程 2 也愿意让步：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void Thread1DoWork()
{
    bool mustDoWork = true;
    Thread.Sleep(100);
    while (mustDoWork)
    {
        lock (resourceA)
        {
            Console.WriteLine(&quot;T1 重做&quot;);
            Thread.Sleep(1000);
            if (Monitor.TryEnter(resourceB, 0))
            {
                output += &quot;T1#&quot;;
                mustDoWork = false;
                Monitor.Exit(resourceB);
            }
        }
        if (mustDoWork) Thread.Yield();
    }
}

public void Thread2DoWork()
{
    bool mustDoWork = true;
    Thread.Sleep(100);
    while (mustDoWork)
    {
        lock (resourceB)
        {
            Console.WriteLine(&quot;T2 重做&quot;);
            Thread.Sleep(1100);
            if (Monitor.TryEnter(resourceA, 0))
            {
                output += &quot;T2#&quot;;
                mustDoWork = false;
                Monitor.Exit(resourceB);
            }
        }
        if (mustDoWork) Thread.Yield();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，为了使我要演示的效果更明显，我把两个线程的 Thread.Sleep 时间拉开了一点点。运行后的效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://w-share.oss-cn-shanghai.aliyuncs.com/202020201109153901.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过观察运行效果，我们发现线程 1 和线程 2 一直在相互让步，然后不断重新开始。两个线程都无法进入 &lt;code&gt;Monitor.TryEnter&lt;/code&gt; 代码块，虽然都在运行，但却没有真正地干活。&lt;/p&gt;
&lt;p&gt;我们把这种线程一直处于运行状态但其任务却一直无法进展的现象称为&lt;strong&gt;活锁&lt;/strong&gt;。活锁和死锁的区别在于，处于活锁的线程是运行状态，而处于死锁的线程表现为等待；活锁有可能自行解开，死锁则不能。&lt;/p&gt;
&lt;p&gt;要避免活锁，就要合理预估各线程对独占资源的占用时间，并合理安排任务调用时间间隔，要格外小心。现实中，这种业务场景很少见。示例中这种复杂的资源占用逻辑，很容易把人搞蒙，而且极不容易维护。推荐的做法是使用&lt;strong&gt;信号量机制&lt;/strong&gt;代替锁，这是另外一个话题，后面单独写文章讲。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;我们应该避免多线程同时读写共享数据，避免的方式，最简单的就是加锁，把共享数据作为独占资源来进行排它使用。&lt;/p&gt;
&lt;p&gt;多个线程在一次任务中需要对多个独占资源加锁时，就可能因相互循环等待而出现死锁。要避免死锁，就至少得有一个线程作出让步。即，在发现自己需要的资源得不到满足时，就要主动释放已占有的资源，以让别的线程可以顺利执行完成。&lt;/p&gt;
&lt;p&gt;大部分情况安排一个线程让步便可避免死锁，但在复杂业务中可能会有多个线程互相让步的情况造成活锁。为了避免活锁，需要合理安排线程任务调用的时间间隔，而这会使得业务代码变得非常复杂。更好的做法是放弃使用锁，而换成使用信号量机制来实现对资源的独占访问。&lt;/p&gt;
</description>
<pubDate>Thu, 12 Nov 2020 23:34:00 +0000</pubDate>
<dc:creator>精致码农</dc:creator>
<og:description>多线程编程时，如果涉及同时读写共享数据，就要格外小心。如果共享数据是独占资源，则要对共享数据的读写进行排它访问，最简单的方式就是加锁。锁也不能随便用，否则可能会造成死锁和活锁。本文将通过示例详细讲解死</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/willick/p/13967346.html</dc:identifier>
</item>
</channel>
</rss>