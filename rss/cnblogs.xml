<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[从源码学设计]蚂蚁金服SOFARegistry 之 服务注册和操作日志 - 罗西的思考</title>
<link>http://www.cnblogs.com/rossiXYZ/p/14238230.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/rossiXYZ/p/14238230.html</guid>
<description>&lt;p&gt;SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。 本系列文章重点在于分析设计和架构，即利用多篇文章，从多个角度反推总结 DataServer 或者 SOFARegistry 的实现机制和架构思路，让大家借以学习阿里如何设计。 本文为第十四篇，介绍SOFARegistry服务上线和操作日志。上文是从Session Server角度，本文从 Data Server 角度介绍。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;740.77106132661&quot;&gt;


&lt;h2 id=&quot;0x00-摘要&quot;&gt;0x00 摘要&lt;/h2&gt;
&lt;p&gt;SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。&lt;/p&gt;
&lt;p&gt;本系列文章重点在于分析设计和架构，即利用多篇文章，从多个角度反推总结 DataServer 或者 SOFARegistry 的实现机制和架构思路，让大家借以学习阿里如何设计。&lt;/p&gt;
&lt;p&gt;本文为第十四篇，介绍SOFARegistry服务上线和操作日志。上文是从Session Server角度，本文从 Data Server 角度介绍。&lt;/p&gt;
&lt;h2 id=&quot;0x01-整体业务流程&quot;&gt;0x01 整体业务流程&lt;/h2&gt;
&lt;p&gt;我们首先回顾总体业务流程，这部分属于数据分片。&lt;/p&gt;
&lt;h3 id=&quot;11-服务注册过程&quot;&gt;1.1 服务注册过程&lt;/h3&gt;
&lt;p&gt;回顾下“一次服务注册过程”的服务数据在内部流转过程。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Client 调用 publisher.register 向 SessionServer 注册服务。&lt;/li&gt;
&lt;li&gt;SessionServer 收到服务数据 （PublisherRegister） 后，将其写入内存 （SessionServer 会存储 Client 的数据到内存，用于后续可以跟 DataServer 做定期检查），再根据 dataInfoId 的一致性 Hash 寻找对应的 DataServer，将 PublisherRegister 发给 DataServer。&lt;/li&gt;
&lt;li&gt;DataServer 接收到 PublisherRegister 数据，首先也是将数据写入内存 ，DataServer 会以 dataInfoId 的维度汇总所有 PublisherRegister。同时，DataServer 将该 dataInfoId 的变更事件通知给所有 SessionServer，变更事件的内容是 dataInfoId 和版本号信息 version。&lt;/li&gt;
&lt;li&gt;同时，异步地，DataServer 以 dataInfoId 维度增量地同步数据给其他副本。因为 DataServer 在一致性 Hash 分片的基础上，对每个分片保存了多个副本（默认是3个副本）。&lt;/li&gt;
&lt;li&gt;SessionServer 接收到变更事件通知后，对比 SessionServer 内存中存储的 dataInfoId 的 version，若发现比 DataServer 发过来的小，则主动向 DataServer 获取 dataInfoId 的完整数据，即包含了所有该 dataInfoId 具体的 PublisherRegister 列表。&lt;/li&gt;
&lt;li&gt;最后，SessionServer 将数据推送给相应的 Client，Client 就接收到这一次服务注册之后的最新的服务列表数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;因为篇幅所限，上文讨论的是前两点，本文介绍第三，第四点&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;12-数据分片&quot;&gt;1.2 数据分片&lt;/h3&gt;
&lt;p&gt;当服务上线时，会计算新增服务的 dataInfoId Hash 值，从而对该服务进行分片，最后寻找最近的一个节点，存储到相应的节点上。&lt;/p&gt;
&lt;p&gt;DataServer 服务在启动时添加了 publishDataProcessor 来处理相应的服务发布者数据发布请求，该 publishDataProcessor 就是 PublishDataHandler。当有新的服务发布者上线，DataServer 的 PublishDataHandler 将会被触发。&lt;/p&gt;
&lt;p&gt;该 Handler 首先会判断当前节点的状态，若是非工作状态则返回请求失败。若是工作状态，则触发数据变化事件中心 DataChangeEventCenter 的 onChange 方法。&lt;/p&gt;
&lt;p&gt;DataChangeEventQueue 中维护着一个 DataChangeEventQueue 队列数组，数组中的每个元素是一个事件队列。当上文中的 onChange 方法被触发时，会计算该变化服务的 dataInfoId 的 Hash 值，从而进一步确定出该服务注册数据所在的队列编号，进而把该变化的数据封装成一个数据变化对象，传入到队列中。&lt;/p&gt;
&lt;p&gt;DataChangeEventQueue#start 方法在 DataChangeEventCenter 初始化的时候被一个新的线程调用，该方法会源源不断地从队列中获取新增事件，并且进行分发。新增数据会由此添加进节点内，实现分片。&lt;/p&gt;
&lt;p&gt;与此同时，&lt;u&gt;DataChangeHandler 会把这个事件变更信息通过 ChangeNotifier 对外发布，通知其他节点进行数据同步&lt;/u&gt;。&lt;/p&gt;
&lt;h2 id=&quot;0x02-基础数据结构&quot;&gt;0x02 基础数据结构&lt;/h2&gt;
&lt;p&gt;这里需要首先讲解几个相关数据结构。&lt;/p&gt;
&lt;h3 id=&quot;21-publisher&quot;&gt;2.1 Publisher&lt;/h3&gt;
&lt;p&gt;Publisher是&lt;u&gt;数据发布者信息&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Publisher extends BaseInfo {
    private List&amp;lt;ServerDataBox&amp;gt; dataList;
    private PublishType         publishType      = PublishType.NORMAL;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;22-datum&quot;&gt;2.2 Datum&lt;/h3&gt;
&lt;p&gt;是&lt;u&gt;从SOFARegistry本身出发而汇集的数据发布者信息&lt;/u&gt;，里面核心是 ：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;dataInfoId&lt;/strong&gt;：服务唯一标识，由``&amp;lt;分组 group&amp;gt;&lt;code&gt;和&lt;/code&gt;&amp;lt;租户 instanceId&amp;gt;&lt;code&gt;构成，例如在 SOFARPC 的场景下，一个 dataInfoId 通常是&lt;/code&gt; com.alipay.sofa.rpc.example.HelloService#@#SOFA#@#00001`，其中SOFA 是 group 名称，00001 是租户 id。group 和 instance 主要是方便对服务数据做逻辑上的切分，使不同 group 和 instance 的服务数据在逻辑上完全独立。模型里有 group 和 instanceId 字段，但这里不额外列出来，读者只要理解 dataInfoId 的含义即可；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;dataCenter&lt;/strong&gt;：一个物理机房，包含多个逻辑单元（zone）。zone：是一种单元化架构下的概念，代表一个机房内的逻辑单元。在服务发现场景下，发布服务时需指定逻辑单元（zone），而订阅服务者可以订阅逻辑单元（zone）维度的服务数据，也可以订阅物理机房（datacenter）维度的服务数据，即订阅该 datacenter 下的所有 zone 的服务数据。；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pubMap&lt;/strong&gt;：包括的Publisher；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;version&lt;/strong&gt;：对应的版本&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Datum implements Serializable {
    private String                                dataInfoId;
    private String                                dataCenter;
    private String                                dataId;
    private String                                instanceId;
    private String                                group;
    private Map&amp;lt;String/*registerId*/, Publisher&amp;gt; pubMap = new ConcurrentHashMap&amp;lt;&amp;gt;();
    private long                                  version;
    private boolean                               containsUnPub    = false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;23-datumcache&quot;&gt;2.3 DatumCache&lt;/h3&gt;
&lt;p&gt;DatumCache 是最新的Datum。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class DatumCache {
    @Autowired
    private DatumStorage localDatumStorage;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体存储是在LocalDatumStorage中完成。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class LocalDatumStorage implements DatumStorage {
    /**
     * row:     dataCenter
     * column:  dataInfoId
     * value:   datum
     */
    protected final Map&amp;lt;String, Map&amp;lt;String, Datum&amp;gt;&amp;gt;     DATUM_MAP            = new ConcurrentHashMap&amp;lt;&amp;gt;();

    /**
     * all datum index
     *
     * row:     ip:port
     * column:  registerId
     * value:   publisher
     */
    protected final Map&amp;lt;String, Map&amp;lt;String, Publisher&amp;gt;&amp;gt; ALL_CONNECT_ID_INDEX = new ConcurrentHashMap&amp;lt;&amp;gt;();

    @Autowired
    private DataServerConfig                            dataServerConfig;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;24-operator&quot;&gt;2.4 Operator&lt;/h3&gt;
&lt;p&gt;Operator 是&lt;u&gt;每一步Datum对应的操作&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Operator {
    private Long               version;
    private Long               sourceVersion;
    private Datum              datum;
    private DataSourceTypeEnum sourceType;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;25-acceptor&quot;&gt;2.5 Acceptor&lt;/h3&gt;
&lt;p&gt;记录了&lt;u&gt;所有的Datum操作&lt;/u&gt;。其中：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;logOperatorsOrder记录了操作的顺序；&lt;/li&gt;
&lt;li&gt;logOperators是所有的操作；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Acceptor {
    private final String                    dataInfoId;
    private final String                    dataCenter;
    private int                             maxBufferSize;
    static final int                        DEFAULT_DURATION_SECS = 30;
    private final Deque&amp;lt;Long/*version*/&amp;gt;   logOperatorsOrder = new ConcurrentLinkedDeque&amp;lt;&amp;gt;();
    private Map&amp;lt;Long/*version*/, Operator&amp;gt; logOperators = new ConcurrentHashMap&amp;lt;&amp;gt;();
    private final DatumCache                datumCache;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;26-总结&quot;&gt;2.6 总结&lt;/h3&gt;
&lt;p&gt;总结下这几个数据结构的联系：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Publisher是&lt;u&gt;数据发布者信息&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;Datum是&lt;u&gt;从SOFARegistry本身出发而汇集的数据发布者信息&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;DatumCache 是&lt;u&gt;最新的Datum&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;Operator 是&lt;u&gt;每一步Datum对应的操作&lt;/u&gt;。&lt;/li&gt;
&lt;li&gt;Acceptor记录了&lt;u&gt;所有的Datum操作&lt;/u&gt;。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;0x03-datum的来龙去脉&quot;&gt;0x03 Datum的来龙去脉&lt;/h2&gt;
&lt;p&gt;我们先回顾下 Datum 的来龙去脉。&lt;/p&gt;
&lt;h3 id=&quot;31-session-server-内部&quot;&gt;3.1 Session Server 内部&lt;/h3&gt;
&lt;p&gt;首先，我们讲讲Session Server 内部如何获取Datum&lt;/p&gt;
&lt;p&gt;在 Session Server 内部，Datum存储在 SessionCacheService 之中。&lt;/p&gt;
&lt;p&gt;比如在 DataChangeFetchCloudTask 内部，可以这样获取 Datum。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Map&amp;lt;String, Datum&amp;gt; getDatumsCache() {
    Map&amp;lt;String, Datum&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    NodeManager nodeManager = NodeManagerFactory.getNodeManager(NodeType.META);
    Collection&amp;lt;String&amp;gt; dataCenters = nodeManager.getDataCenters();
    if (dataCenters != null) {
        Collection&amp;lt;Key&amp;gt; keys = dataCenters.stream().
                map(dataCenter -&amp;gt; new Key(KeyType.OBJ, DatumKey.class.getName(),
                        new DatumKey(fetchDataInfoId, dataCenter))).
                collect(Collectors.toList());

        Map&amp;lt;Key, Value&amp;gt; values = null;
        values = sessionCacheService.getValues(keys);

        if (values != null) {
            values.forEach((key, value) -&amp;gt; {
                if (value != null &amp;amp;&amp;amp; value.getPayload() != null) {
                    map.put(((DatumKey) key.getEntityType()).getDataCenter(), (Datum) value.getPayload());
                }
            });
        }
    }
    return map;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;u&gt;Session Server 会向 Data Server 发送 PublishDataRequest 请求&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;32-publishdatahandler&quot;&gt;3.2 PublishDataHandler&lt;/h3&gt;
&lt;p&gt;&lt;u&gt;在DataServer内部，PublishDataHandler 是用来处理 PublishDataRequest&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class PublishDataHandler extends AbstractServerHandler&amp;lt;PublishDataRequest&amp;gt; {
    @Autowired
    private ForwardService                 forwardService;

    @Autowired
    private SessionServerConnectionFactory sessionServerConnectionFactory;

    @Autowired
    private DataChangeEventCenter          dataChangeEventCenter;

    @Autowired
    private DataServerConfig               dataServerConfig;

    @Autowired
    private DatumLeaseManager              datumLeaseManager;

    @Autowired
    private ThreadPoolExecutor             publishProcessorExecutor;

    @Override
    public Object doHandle(Channel channel, PublishDataRequest request) {
        Publisher publisher = Publisher.internPublisher(request.getPublisher());
        if (forwardService.needForward()) {
            CommonResponse response = new CommonResponse();
            response.setSuccess(false);
            response.setMessage(&quot;Request refused, Server status is not working&quot;);
            return response;
        }

        dataChangeEventCenter.onChange(publisher, dataServerConfig.getLocalDataCenter());

        if (publisher.getPublishType() != PublishType.TEMPORARY) {
            String connectId = WordCache.getInstance().getWordCache(
                publisher.getSourceAddress().getAddressString());
            sessionServerConnectionFactory.registerConnectId(request.getSessionServerProcessId(),
                connectId);
            // record the renew timestamp
            datumLeaseManager.renew(connectId);
        }

        return CommonResponse.buildSuccessResponse();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;33-datachangeeventcenter&quot;&gt;3.3 DataChangeEventCenter&lt;/h3&gt;
&lt;p&gt;&lt;u&gt;在 DataChangeEventCenter 的 onChange 函数中，会进行投放&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void onChange(Publisher publisher, String dataCenter) {
    int idx = hash(publisher.getDataInfoId());
    Datum datum = new Datum(publisher, dataCenter);
    if (publisher instanceof UnPublisher) {
        datum.setContainsUnPub(true);
    }
    if (publisher.getPublishType() != PublishType.TEMPORARY) {
        dataChangeEventQueues[idx].onChange(new DataChangeEvent(DataChangeTypeEnum.MERGE,
            DataSourceTypeEnum.PUB, datum));
    } else {
        dataChangeEventQueues[idx].onChange(new DataChangeEvent(DataChangeTypeEnum.MERGE,
            DataSourceTypeEnum.PUB_TEMP, datum));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;34-datachangeeventqueue&quot;&gt;3.4 DataChangeEventQueue&lt;/h3&gt;
&lt;p&gt;在DataChangeEventQueue之中，会调用 handleDatum 来处理。在这里对Datum进行存储。&lt;/p&gt;
&lt;h3 id=&quot;35-datachangehandler&quot;&gt;3.5 DataChangeHandler&lt;/h3&gt;
&lt;p&gt;在 DataChangeHandler 之中，会提取ChangeData，然后进行Notify。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void start() {
    DataChangeEventQueue[] queues = dataChangeEventCenter.getQueues();
    int queueCount = queues.length;
    Executor executor = ExecutorFactory.newFixedThreadPool(queueCount, DataChangeHandler.class.getSimpleName());
    Executor notifyExecutor = ExecutorFactory
            .newFixedThreadPool(dataServerConfig.getQueueCount() * 5, this.getClass().getSimpleName());
    for (int idx = 0; idx &amp;lt; queueCount; idx++) {
        final DataChangeEventQueue dataChangeEventQueue = queues[idx];
        final String name = dataChangeEventQueue.getName();
        executor.execute(() -&amp;gt; {
            while (true) {
                    final ChangeData changeData = dataChangeEventQueue.take();
                    notifyExecutor.execute(new ChangeNotifier(changeData, name));
            }
        });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                                           +
                           Session Server  |  Data Server
                                           |
                                           |
                                           |
                                           |
+--------------------------+  PublishDataRequest   +--------------------+
| DataChangeFetchCloudTask +---------------+-----&amp;gt; | PublishDataHandler |
+-----------+--------------+               |       +------+-------------+
            ^                              |              |
            | getValues                    |              |  onChange(Publisher)
            |                              |              v
            |                              |     +--------+--------------+
  +---------+----------+                   |     | DataChangeEventCenter |
  |sessionCacheService |                   |     +--------+--------------+
  +--------------------+                   |              |
                                           |              |  Datum
                                           |              |
                                           |              v
                                           |     +--------+-------------+
                                           |     | DataChangeEventQueue |
                                           |     +--------+-------------+
                                           |              |
                                           |              |
                                           |              | ChangeData
                                           |              v
                                           |      +-------+-----------+
                                           |      | DataChangeHandler |
                                           +      +-------------------+
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x04-datachangehandler处理&quot;&gt;0x04 DataChangeHandler处理&lt;/h2&gt;
&lt;p&gt;于是我们接着进行 DataChangeHandler 处理。即总述中提到的：DataChangeHandler 会把这个事件变更信息：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把这个事件变更信息变成Operator，放到AbstractAcceptorStore；&lt;/li&gt;
&lt;li&gt;通过 ChangeNotifier 对外发布，通知其他节点进行数据同步；&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;下面我们从第一部分 ：&lt;u&gt;把这个事件变更信息变成Operator，放到AbstractAcceptorStore&lt;/u&gt; 出发，进行讲解日志操作。&lt;/p&gt;
&lt;p&gt;即如图所示：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;                                           +
                           Session Server  |  Data Server
                                           |
                                           |
                                           |
                                           +
+--------------------------+  PublishDataRequest   +--------------------+
| DataChangeFetchCloudTask +---------------+-----&amp;gt; | PublishDataHandler |
+-----------+--------------+               |       +------+-------------+
            ^                              |              |
            | getValues                    |              |  onChange(Publisher)
            |                              |              v
            |                              |     +--------+--------------+
  +---------+----------+                   |     | DataChangeEventCenter |
  |sessionCacheService |                   |     +--------+--------------+
  +--------------------+                   |              |
                                           |              |  Datum
                                           |              |
                                           |              v
                                           |     +--------+-------------+
                                           |     | DataChangeEventQueue |
                                           |     +--------+-------------+
                                           |              |
                                           |              |
                                           |              | ChangeData
                                           |              v
                                           |      +-------+-----------+
                                           |      | DataChangeHandler |
                                           |      +-------+-----------+
                                           |              |
                                           |              |
                                           |              v
                                           |      +-------+---------+
                                           |      |  ChangeNotifier |
                                           |      +-------+---------+
                                           |              |
                                           |              |
                                           |              v
                                           |   +----------+------------+
                                           |   | AbstractAcceptorStore |
                                           |   +-----------------------+
                                           +
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Acceptor的appendOperator谁来调用？在Notifier 里面有，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class BackUpNotifier implements IDataChangeNotifier {

    @Autowired
    private SyncDataService syncDataService;

    @Override
    public void notify(Datum datum, Long lastVersion) {
        syncDataService.appendOperator(new Operator(datum.getVersion(), lastVersion, datum,
            DataSourceTypeEnum.BACKUP));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及另一个：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SnapshotBackUpNotifier implements IDataChangeNotifier {

    @Autowired
    private SyncDataService syncDataService;

    @Override
    public void notify(Datum datum, Long lastVersion) {
        syncDataService.appendOperator(new SnapshotOperator(datum.getVersion(), lastVersion, datum,
            DataSourceTypeEnum.BACKUP));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x05-abstractacceptorstore存储&quot;&gt;0x05 AbstractAcceptorStore存储&lt;/h2&gt;
&lt;p&gt;AbstractAcceptorStore是日志存储，我们下面详细分析。&lt;/p&gt;
&lt;h3 id=&quot;51-bean&quot;&gt;5.1 Bean&lt;/h3&gt;
&lt;p&gt;对于操作信息，提供了一个Bean来存储。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Bean
public AcceptorStore localAcceptorStore() {
    return new LocalAcceptorStore();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;52-storeservicefactory&quot;&gt;5.2 StoreServiceFactory&lt;/h3&gt;
&lt;p&gt;作用是在 storeServiceMap 中存放各种 AcceptorStore，目前只有LocalAcceptorStore 这一个。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class StoreServiceFactory implements ApplicationContextAware {

    private static Map&amp;lt;String/*supportType*/, AcceptorStore&amp;gt; storeServiceMap = new HashMap&amp;lt;&amp;gt;();

    /**
     * get AcceptorStore by storeType
     * @param storeType
     * @return
     */
    public static AcceptorStore getStoreService(String storeType) {
        return storeServiceMap.get(storeType);
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        Map&amp;lt;String, AcceptorStore&amp;gt; map = applicationContext.getBeansOfType(AcceptorStore.class);

        map.forEach((key, value) -&amp;gt; storeServiceMap.put(value.getType(), value));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;53-abstractacceptorstore&quot;&gt;5.3 AbstractAcceptorStore&lt;/h3&gt;
&lt;p&gt;AbstractAcceptorStore 是存储的基本实现类，几个基本成员是。&lt;/p&gt;
&lt;ul readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;acceptors ：是一个矩阵，按照dataCenter，dataInfoId维度来分类，存储了此维度下的Acceptor；就是说，针对每一个dataCenter，dataInfoId的组合，都有一个Acceptor，用来存储这下面的Operator。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;notifyAcceptorsCache ：是一个矩阵，按照dataCente，dataInfoId维度来分类，缓存了此维度下需要进一步处理的Acceptor；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;delayQueue ：配合notifyAcceptorsCache使用，针对notifyAcceptorsCache的每一个新acceptor，系统会添加一个消息进入queue，这个queue等延时到了，就会取出，并且从notifyAcceptorsCache取出对应的新acceptor进行相应处理；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;u&gt;按说应该是 cache 有东西，所以dequeue 时候就会取出来，但是如果这期间多放入了几个进入 Cache，原有cache 的 value 只是被替换而已，等时间到了，也会取出来&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;notifyAcceptorsCache 也是按照 data center 来控制的，只有定期 removeCache。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public abstract class AbstractAcceptorStore implements AcceptorStore {

    private static final int               DEFAULT_MAX_BUFFER_SIZE = 30;

    @Autowired
    protected IMetaServerService           metaServerService;

    @Autowired
    private Exchange                       boltExchange;

    @Autowired
    private DataServerConfig               dataServerConfig;

    @Autowired
    private DataServerConnectionFactory    dataServerConnectionFactory;

    @Autowired
    private DatumCache                     datumCache;

    private Map&amp;lt;String/*dataCenter*/, Map&amp;lt;String/*dataInfoId*/, Acceptor&amp;gt;&amp;gt; acceptors               = new ConcurrentHashMap&amp;lt;&amp;gt;();

    private Map&amp;lt;String/*dataCenter*/, Map&amp;lt;String/*dataInfoId*/, Acceptor&amp;gt;&amp;gt; notifyAcceptorsCache    = new ConcurrentHashMap&amp;lt;&amp;gt;();

    private DelayQueue&amp;lt;DelayItem&amp;lt;Acceptor&amp;gt;&amp;gt;     delayQueue 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体如下图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;+-----------------------------+                      +--&amp;gt; dataInfoId +---&amp;gt;  Acceptor +--&amp;gt; Map&amp;lt;&amp;gt;ersion, Operator&amp;gt;
|[AbstractAcceptorStore]      |                      |
|                             |   +-&amp;gt; dataCenter +---+
|                             |   |                  |
|     acceptors  +---------------&amp;gt;+                  +--&amp;gt; dataInfoId +---&amp;gt;  Acceptor +--&amp;gt; Map&amp;lt;&amp;gt;ersion, Operator&amp;gt;
|                             |   |
|     notifyAcceptorsCache    |   |                  +--&amp;gt; dataInfoId +---&amp;gt;  Acceptor +--&amp;gt; Map&amp;lt;&amp;gt;ersion, Operator&amp;gt;
|           +                 |   +-&amp;gt; dataCenter +--&amp;gt;+
+-----------------------------+                      |
            |                                        +--&amp;gt; dataInfoId +---&amp;gt;  Acceptor +--&amp;gt; Map&amp;lt;&amp;gt;ersion, Operator&amp;gt;
            |
            |
            |                                        +--&amp;gt; dataInfoId +---&amp;gt;  Acceptor +--&amp;gt; Map&amp;lt;&amp;gt;ersion, Operator&amp;gt;
            |                     +-&amp;gt; dataCenter +--&amp;gt;+
            |                     |                  +--&amp;gt; dataInfoId +---&amp;gt;  Acceptor +--&amp;gt; Map&amp;lt;&amp;gt;ersion, Operator&amp;gt;
            +--------------------&amp;gt;+
                                  |                  +--&amp;gt; dataInfoId +---&amp;gt;  Acceptor +--&amp;gt; Map&amp;lt;&amp;gt;ersion, Operator&amp;gt;
                                  +-&amp;gt; dataCenter +---+
                                                     +--&amp;gt; dataInfoId +---&amp;gt;  Acceptor +--&amp;gt; Map&amp;lt;&amp;gt;ersion, Operator&amp;gt;

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202101/1850883-20210105214317356-2032425088.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;有一点需要说明，就是&lt;u&gt;delayQueue 为何要延迟队列。这是由于SOFA的“秒级服务上下线通知“特性造成的&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;因为要实现此特性，所以涉及到了一个&lt;u&gt;连接敏感性问题&lt;/u&gt;，即在 SOFARegistry 里，所有 Client 都与 SessionServer 保持长连接，每条长连接都会有基于 bolt 的连接心跳，如果连接断开，Client 会马上重新建连，时刻保证 Client 与 SessionServer 之间有可靠的连接。&lt;/p&gt;
&lt;p&gt;因为强烈的连接敏感性，所以导致如果只是网络问题导致连接断开，实际的进程并没有宕机，那么 Client 会马上重连 SessionServer 并重新注册所有服务数据。这种&lt;u&gt;大量的短暂的服务下线后又重新上线会给用户带来困扰和麻烦&lt;/u&gt;。&lt;/p&gt;
&lt;p&gt;因此&lt;u&gt;在 DataServer 内部实现了数据延迟合并的功能，就是这里的DelayQueue&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;54-加入&quot;&gt;5.4 加入&lt;/h3&gt;
&lt;p&gt;addOperator的基本逻辑是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从Operator的Datum中提取dataCenter和dataInfoId；&lt;/li&gt;
&lt;li&gt;从acceptors取出dataCenter对应的Map&amp;lt;dataInfoId, Acceptor&amp;gt; acceptorMap；&lt;/li&gt;
&lt;li&gt;从acceptorMap中提取dataInfoId对应的existAcceptor；&lt;/li&gt;
&lt;li&gt;如果新operator是SnapshotOperator类型，则清除之前的 opeator queue。&lt;/li&gt;
&lt;li&gt;否则加入新operator；&lt;/li&gt;
&lt;li&gt;使用putCache(existAcceptor);把目前的Acceptor加入Cache，定时任务会处理；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在操作中，都是&lt;u&gt;使用putIfAbsent，这样短期内若有多个同样value插入，则不会替换原有的value，这样 起到了归并作用&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void addOperator(Operator operator) {

    Datum datum = operator.getDatum();
    String dataCenter = datum.getDataCenter();
    String dataInfoId = datum.getDataInfoId();
    try {
        Map&amp;lt;String/*dataInfoId*/, Acceptor&amp;gt; acceptorMap = acceptors.get(dataCenter);
        if (acceptorMap == null) {
            Map&amp;lt;String/*dataInfoId*/, Acceptor&amp;gt; newMap = new ConcurrentHashMap&amp;lt;&amp;gt;();
            acceptorMap = acceptors.putIfAbsent(dataCenter, newMap);
            if (acceptorMap == null) {
                acceptorMap = newMap;
            }
        }

        Acceptor existAcceptor = acceptorMap.get(dataInfoId);
        if (existAcceptor == null) {
            Acceptor newAcceptor = new Acceptor(DEFAULT_MAX_BUFFER_SIZE, dataInfoId,
                dataCenter, datumCache);
            existAcceptor = acceptorMap.putIfAbsent(dataInfoId, newAcceptor);
            if (existAcceptor == null) {
                existAcceptor = newAcceptor;
            }
        }

        if (operator instanceof SnapshotOperator) {
            //snapshot: clear the queue, Make other data retrieve the latest memory data
            existAcceptor.clearBefore();
        } else {
            existAcceptor.appendOperator(operator);
        }

        //put cache
        putCache(existAcceptor);
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;putCache的作用是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从acceptor中提取dataCenter和dataInfoId；&lt;/li&gt;
&lt;li&gt;从notifyAcceptorsCache中取出dataCenter对应的Map&amp;lt;dataInfoId, Acceptor&amp;gt; acceptorMap；&lt;/li&gt;
&lt;li&gt;向acceptorMap中放入dataInfoId对应的acceptor；&lt;/li&gt;
&lt;li&gt;如果acceptorMap中之前没有对应的value，则把acceptor放入delayQueue；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;u&gt;这里也使用putIfAbsent，这样短期内若有多个同样value插入，则不会替换原有的value，这样 起到了归并作用&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void putCache(Acceptor acceptor) {

    String dataCenter = acceptor.getDataCenter();
    String dataInfoId = acceptor.getDataInfoId();

    try {
        Map&amp;lt;String/*dataInfoId*/, Acceptor&amp;gt; acceptorMap = notifyAcceptorsCache.get(dataCenter);
        if (acceptorMap == null) {
            Map&amp;lt;String/*dataInfoId*/, Acceptor&amp;gt; newMap = new ConcurrentHashMap&amp;lt;&amp;gt;();
            acceptorMap = notifyAcceptorsCache.putIfAbsent(dataCenter, newMap);
            if (acceptorMap == null) {
                acceptorMap = newMap;
            }
        }
        Acceptor existAcceptor = acceptorMap.putIfAbsent(dataInfoId, acceptor);
        if (existAcceptor == null) {
            addQueue(acceptor);
        }
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;55-使用&quot;&gt;5.5 使用&lt;/h3&gt;
&lt;p&gt;具体消费是在定期任务中完成。消费日志的目的就是同步日志操作给其他 DataServer。&lt;/p&gt;
&lt;h4 id=&quot;551-scheduler&quot;&gt;5.5.1 Scheduler&lt;/h4&gt;
&lt;p&gt;Scheduler类是定期任务，&lt;u&gt;会启动两个线程池定期调用AcceptorStore的函数&lt;/u&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Scheduler {
    private final ScheduledExecutorService scheduler;
  
    public final ExecutorService           versionCheckExecutor;

    private final ThreadPoolExecutor       expireCheckExecutor;

    @Autowired
    private AcceptorStore                  localAcceptorStore;

   public Scheduler() {
        scheduler = new ScheduledThreadPoolExecutor(4, new NamedThreadFactory(&quot;SyncDataScheduler&quot;));

        expireCheckExecutor = new ThreadPoolExecutor(1, 3, 0, TimeUnit.SECONDS,
            new SynchronousQueue&amp;lt;&amp;gt;(), new NamedThreadFactory(&quot;SyncDataScheduler-expireChangeCheck&quot;));

        versionCheckExecutor = new ThreadPoolExecutor(2, 2, 0L, TimeUnit.MILLISECONDS,
            new LinkedBlockingQueue&amp;lt;&amp;gt;(), new NamedThreadFactory(
                &quot;SyncDataScheduler-versionChangeCheck&quot;));

    }
  
    public void startScheduler() {
        scheduler.schedule(
                new TimedSupervisorTask(&quot;FetchDataLocal&quot;, scheduler, expireCheckExecutor, 3,
                        TimeUnit.SECONDS, 10, () -&amp;gt; localAcceptorStore.checkAcceptorsChangAndExpired()),
                30, TimeUnit.SECONDS);

        versionCheckExecutor.execute(() -&amp;gt; localAcceptorStore.changeDataCheck());

    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AbstractAcceptorStore中函数如下：&lt;/p&gt;
&lt;h4 id=&quot;552-changedatacheck&quot;&gt;5.5.2 changeDataCheck&lt;/h4&gt;
&lt;p&gt;changeDataCheck 内部是一个while true，所以不需要再使用线程池。&lt;/p&gt;
&lt;p&gt;changeDataCheck绑定在delayQueue上，如果有新消息，则会取出Acceptor，也从notifyAcceptorsCache取出Acceptor，调用notifyChange(acceptor);进行处理 。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void changeDataCheck() {

    while (true) {
        try {
            DelayItem&amp;lt;Acceptor&amp;gt; delayItem = delayQueue.take();
            Acceptor acceptor = delayItem.getItem();
            removeCache(acceptor); // compare and remove
        } catch (InterruptedException e) {
            break;
        } catch (Throwable e) {
            LOGGER.error(e.getMessage(), e);
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;消费Cache用到的是removeCache。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void removeCache(Acceptor acceptor) {
    String dataCenter = acceptor.getDataCenter();
    String dataInfoId = acceptor.getDataInfoId();
    try {
        Map&amp;lt;String/*dataInfoId*/, Acceptor&amp;gt; acceptorMap = notifyAcceptorsCache.get(dataCenter);
        if (acceptorMap != null) {
            boolean result = acceptorMap.remove(dataInfoId, acceptor);
            if (result) {
                //data change notify
                notifyChange(acceptor);
            }
        }
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;5521-通知notifydatasyncrequest&quot;&gt;5.5.2.1 通知NotifyDataSyncRequest&lt;/h5&gt;
&lt;p&gt;在removeCache中，也使用notifyChange进行了通知，逻辑如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;从acceptor中提取 DataInfoId；&lt;/li&gt;
&lt;li&gt;根据DataInfoId从meta service中获取dataServerNodes的ip；&lt;/li&gt;
&lt;li&gt;遍历ip，通过bolt server进行通知syncServer.sendSync，就是给ip对应的data center发送 NotifyDataSyncRequest；&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void notifyChange(Acceptor acceptor) {

    Long lastVersion = acceptor.getLastVersion();

    NotifyDataSyncRequest request = new NotifyDataSyncRequest(acceptor.getDataInfoId(),
        acceptor.getDataCenter(), lastVersion, getType());

    List&amp;lt;String&amp;gt; targetDataIps = getTargetDataIp(acceptor.getDataInfoId());
    for (String targetDataIp : targetDataIps) {

        if (DataServerConfig.IP.equals(targetDataIp)) {
            continue;
        }

        Server syncServer = boltExchange.getServer(dataServerConfig.getSyncDataPort());

        for (int tryCount = 0; tryCount &amp;lt; dataServerConfig.getDataSyncNotifyRetry(); tryCount++) {
            try {
                Connection connection = dataServerConnectionFactory.getConnection(targetDataIp);
                if (connection == null) {
                    TimeUtil.randomDelay(1000);
                    continue;
                }
                syncServer.sendSync(syncServer.getChannel(connection.getRemoteAddress()),
                    request, 1000);
                break;
            } 
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这部分的调用逻辑为：&lt;code&gt;versionCheckExecutor.execute ------- localAcceptorStore.changeDataChheck ------ removeCache ----- notifyChange ------ NotifyDataSyncRequest&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;具体如下图：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;+--------------------------+
|                          |     +----------------------------------------------------------------------+
|   versionCheckExecutor   |     | [AbstractAcceptorStore]                                              |
|                          |     |                                                                      |
+--------+-----------------+     |                                                                      |
         |                       |                                                                      |
         |                       |                                                                      |
         |                       |                                                                      |
         |                       |     Map&amp;lt;dataCenter, Map&amp;lt;dataInfoId, Acceptor&amp;gt; &amp;gt; acceptors            |
         |   changeDataCheck     |                                                                      |
         +---------------------------&amp;gt; Map&amp;lt;dataCenter, Map&amp;lt;dataInfoId, Acceptor&amp;gt; &amp;gt; notifyAcceptorsCache |
  removeCache / notifyChange     |                                                                      |
                    +            +----------------------------------------------------------------------+
                    |
                    |
                    |
                    | NotifyDataSyncRequest
                    |
                    v
             +------+-----------+
             | Other DataServer |
             +------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202101/1850883-20210105214457907-902510385.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;553-checkacceptorschangandexpired&quot;&gt;5.5.3 checkAcceptorsChangAndExpired&lt;/h4&gt;
&lt;p&gt;checkAcceptorsChangAndExpired作用是遍历acceptors每个acceptor，看看是否expired，进行处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void checkAcceptorsChangAndExpired() {
    acceptors.forEach((dataCenter, acceptorMap) -&amp;gt; {
        if (acceptorMap != null &amp;amp;&amp;amp; !acceptorMap.isEmpty()) {
            acceptorMap.forEach((dataInfoId, acceptor) -&amp;gt; acceptor.checkExpired(0));
        }
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时，逻辑如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;+--------------------------+                                                                                     +------------------------+
|                          |     +----------------------------------------------------------------------+        |                        |
|   versionCheckExecutor   |     | [AbstractAcceptorStore]                                              |        |   expireCheckExecutor  |
|                          |     |                                                                      |        |                        |
+--------+-----------------+     |                                                                      |        +--------------+---------+
         |                       |                                                                      |                       |
         |                       |                                                                      |                       |
         |                       |                                                                      |                       |
         |                       |     Map&amp;lt;dataCenter, Map&amp;lt;dataInfoId, Acceptor&amp;gt; &amp;gt; acceptors  &amp;lt;---------------------------------+
         |   changeDataCheck     |                                                                      |     checkAcceptorsChangAndExpired
         +---------------------------&amp;gt; Map&amp;lt;dataCenter, Map&amp;lt;dataInfoId, Acceptor&amp;gt; &amp;gt; notifyAcceptorsCache |
  removeCache / notifyChange     |                                                                      |
                    +            +----------------------------------------------------------------------+
                    |
                    |
                    |
                    | NotifyDataSyncRequest
                    |
                    v
             +------+-----------+
             | Other DataServer |
             +------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202101/1850883-20210105214521330-373370029.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x06-acceptor日志操作&quot;&gt;0x06 Acceptor日志操作&lt;/h2&gt;
&lt;p&gt;这里记录了日志，即记录了所有的Datum操作。&lt;/p&gt;
&lt;p&gt;操作日志存储采用Queue方式，获取日志时候通过当前版本号在堆栈内所在位置，把所有版本之后的操作日志同步过来执行。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Acceptor {
    private final String                    dataInfoId;
    private final String                    dataCenter;
    private int                             maxBufferSize;
    static final int                        DEFAULT_DURATION_SECS = 30;
    private final Deque&amp;lt;Long/*version*/&amp;gt;   logOperatorsOrder     = new ConcurrentLinkedDeque&amp;lt;&amp;gt;();
    private Map&amp;lt;Long/*version*/, Operator&amp;gt; logOperators          = new ConcurrentHashMap&amp;lt;&amp;gt;();
    private final DatumCache                datumCache;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键变量是：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;logOperators：按照版本号为key存储的map，用来存储所有的Operator；&lt;/li&gt;
&lt;li&gt;logOperatorsOrder：&lt;u&gt;因为map没有办法排序，所以设置此queue来存储版本号&lt;/u&gt;；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;Operator 就是每一步操作对应的Datum。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Operator {
    private Long               version;
    private Long               sourceVersion;
    private Datum              datum;
    private DataSourceTypeEnum sourceType;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;61-appendoperator&quot;&gt;6.1 appendOperator&lt;/h3&gt;
&lt;p&gt;此函数作用是：添加一个操作日志。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;如果queue已经满了，则取出第一个消息，为了向后段插入一个新的 。&lt;/li&gt;
&lt;li&gt;如果Operator版本号为空，则设置为0L；&lt;/li&gt;
&lt;li&gt;如果Operator的前一个版本号与queue尾部Operator版本号不一致，说明queue里面不对了，需要清空map和queue。&lt;/li&gt;
&lt;li&gt;向map中加入Operator；&lt;/li&gt;
&lt;li&gt;如果是新版本的Operator，则把版本加入queue；&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;具体代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;/**
 * append operator to queue,if queue is full poll the first element and append.
 * Process will check version sequence,it must append with a consequent increase in version,
 * otherwise queue will be clean
 *
 * @param operator
 */
public void appendOperator(Operator operator) {
    write.lock();
    try {
        if (isFull()) {
            logOperators.remove(logOperatorsOrder.poll());
        }
        if (operator.getSourceVersion() == null) {
            operator.setSourceVersion(0L);
        }
        Long tailVersion = logOperatorsOrder.peekLast();
        if (tailVersion != null) {
            //operation add not by solid sequence
            if (tailVersion.longValue() != operator.getSourceVersion().longValue()) {
                clearBefore();
            }
        }

        Operator previousOperator = logOperators.put(operator.getVersion(), operator);
        if (previousOperator == null) {
            logOperatorsOrder.add(operator.getVersion());
        } 
    } finally {
        write.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;appendOperator谁来调用？在Notifier 里面有，比如：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class BackUpNotifier implements IDataChangeNotifier {

    @Autowired
    private SyncDataService syncDataService;

    @Override
    public void notify(Datum datum, Long lastVersion) {
        syncDataService.appendOperator(new Operator(datum.getVersion(), lastVersion, datum,
            DataSourceTypeEnum.BACKUP));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以及&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SnapshotBackUpNotifier implements IDataChangeNotifier {

    @Autowired
    private SyncDataService syncDataService;

    @Override
    public void notify(Datum datum, Long lastVersion) {
        syncDataService.appendOperator(new SnapshotOperator(datum.getVersion(), lastVersion, datum,
            DataSourceTypeEnum.BACKUP));
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;62-checkexpired&quot;&gt;6.2 checkExpired&lt;/h3&gt;
&lt;p&gt;此方法作用是去除过期日志。version是时间戳，所以可以定期check，如果过期，就清除。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void checkExpired(int durationSEC) {
    write.lock();
    try {
        //check all expired
        Long peekVersion = logOperatorsOrder.peek();
        if (peekVersion != null &amp;amp;&amp;amp; isExpired(durationSEC, peekVersion)) {
            logOperators.remove(logOperatorsOrder.poll());
            checkExpired(durationSEC);
        }
    } finally {
        write.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;0x07-notifydatasyncrequest通知数据同步&quot;&gt;0x07 NotifyDataSyncRequest通知数据同步&lt;/h2&gt;
&lt;p&gt;此请求作用是通知接收端进行数据同步。&lt;/p&gt;
&lt;p&gt;回忆下这部分的调用逻辑为：&lt;code&gt;versionCheckExecutor.execute ------- localAcceptorStore.changeDataChheck ------ removeCache ----- notifyChange ------ NotifyDataSyncRequest&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;71-notifydatasynchandler&quot;&gt;7.1 NotifyDataSyncHandler&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;&lt;u&gt;接收端data server&lt;/u&gt;&lt;/strong&gt;通过NotifyDataSyncHandler处理&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class NotifyDataSyncHandler extends AbstractClientHandler&amp;lt;NotifyDataSyncRequest&amp;gt; implements
                                                                                       AfterWorkingProcess {

    @Autowired
    private DataServerConfig                                      dataServerConfig;

    @Autowired
    private GetSyncDataHandler                                    getSyncDataHandler;

    @Autowired
    private DataChangeEventCenter                                 dataChangeEventCenter;

    private Executor                                              executor    = ExecutorFactory
                                                                                  .newFixedThreadPool(
                                                                                      10,
                                                                                      NotifyDataSyncHandler.class
                                                                                          .getSimpleName());

    private ThreadPoolExecutor                                    notifyExecutor;

    @Autowired
    private DataNodeStatus                                        dataNodeStatus;

    @Autowired
    private DatumCache                                            datumCache;
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;711-dohandle&quot;&gt;7.1.1 doHandle&lt;/h4&gt;
&lt;p&gt;doHandle方法用来继续处理。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public Object doHandle(Channel channel, NotifyDataSyncRequest request) {
    final Connection connection = ((BoltChannel) channel).getConnection();
    if (dataNodeStatus.getStatus() != LocalServerStatusEnum.WORKING) {
        noWorkQueue.add(new SyncDataRequestForWorking(connection, request));
        return CommonResponse.buildSuccessResponse();
    }
    executorRequest(connection, request);
    return CommonResponse.buildSuccessResponse();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;712-executorrequest&quot;&gt;7.1.2 executorRequest&lt;/h4&gt;
&lt;p&gt;因为接到了&lt;strong&gt;&lt;u&gt;发起端DataServer&lt;/u&gt;&lt;/strong&gt;的同步通知NotifyDataSyncRequest，所以&lt;strong&gt;&lt;u&gt;接收端DataServer&lt;/u&gt;&lt;/strong&gt;主动发起拉取，进行同步数据。即调用GetSyncDataHandler来发送SyncDataRequest&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void executorRequest(Connection connection, NotifyDataSyncRequest request) {
    executor.execute(() -&amp;gt; {
        fetchSyncData(connection, request);
    });
}

protected void fetchSyncData(Connection connection, NotifyDataSyncRequest request) {
    String dataInfoId = request.getDataInfoId();
    String dataCenter = request.getDataCenter();
    Datum datum = datumCache.get(dataCenter, dataInfoId);
    Long version = (datum == null) ? null : datum.getVersion();
    Long requestVersion = request.getVersion();

    if (version == null || requestVersion == 0L || version &amp;lt; requestVersion) {
        getSyncDataHandler.syncData(new SyncDataCallback(getSyncDataHandler, connection,
            new SyncDataRequest(dataInfoId, dataCenter, version, request.getDataSourceType()),
            dataChangeEventCenter));
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;713-getsyncdatahandler&quot;&gt;7.1.3 GetSyncDataHandler&lt;/h4&gt;
&lt;p&gt;GetSyncDataHandler和SyncDataCallback配合。&lt;/p&gt;
&lt;p&gt;即调用GetSyncDataHandler来发送SyncDataRequest，用SyncDataCallback接收同步结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;├── remoting
│   ├── dataserver
│   │   ├── DataServerConnectionFactory.java
│   │   ├── DataServerNodeFactory.java
│   │   ├── GetSyncDataHandler.java
│   │   ├── SyncDataCallback.java
│   │   ├── handler
│   │   └── task
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;GetSyncDataHandler 和 SyncDataCallback 这两个辅助类的位置比较奇怪，大概因为是功能类，所以放在dataserver目录下，个人认为也许单独设置一个目录存放更好。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class GetSyncDataHandler {
    @Autowired
    private DataNodeExchanger   dataNodeExchanger;

    public void syncData(SyncDataCallback callback) {
        int tryCount = callback.getRetryCount();
        if (tryCount &amp;gt; 0) {
            try {
                callback.setRetryCount(--tryCount);
                dataNodeExchanger.request(new Request() {
                    @Override
                    public Object getRequestBody() {
                        return callback.getRequest();
                    }

                    @Override
                    public URL getRequestUrl() {
                        return new URL(callback.getConnection().getRemoteIP(), callback
                            .getConnection().getRemotePort());
                    }

                    @Override
                    public CallbackHandler getCallBackHandler() {
                        return new CallbackHandler() {
                            @Override
                            public void onCallback(Channel channel, Object message) {
                                callback.onResponse(message);
                            }

                            @Override
                            public void onException(Channel channel, Throwable exception) {
                                callback.onException(exception);
                            }

                            @Override
                            public Executor getExecutor() {
                                return callback.getExecutor();
                            }
                        };
                    }
                });
            }
        }
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;714-syncdatacallback&quot;&gt;7.1.4 SyncDataCallback&lt;/h4&gt;
&lt;p&gt;这里接收同步结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SyncDataCallback implements InvokeCallback {

    private static final Executor EXECUTOR    = ExecutorFactory.newFixedThreadPool(5,
                                                  SyncDataCallback.class.getSimpleName());

    private static final int      RETRY_COUNT = 3;

    private Connection            connection;

    private SyncDataRequest       request;

    private GetSyncDataHandler    getSyncDataHandler;

    private int                   retryCount;

    private DataChangeEventCenter dataChangeEventCenter;

    @Override
    public void onResponse(Object obj) {
        GenericResponse&amp;lt;SyncData&amp;gt; response = (GenericResponse) obj;
        if (!response.isSuccess()) {
            getSyncDataHandler.syncData(this);
        } else {
            SyncData syncData = response.getData();
            Collection&amp;lt;Datum&amp;gt; datums = syncData.getDatums();
            DataSourceTypeEnum dataSourceTypeEnum = DataSourceTypeEnum.valueOf(request
                .getDataSourceType());
            if (syncData.getWholeDataTag()) {
                //handle all data, replace cache with these datum directly
                for (Datum datum : datums) {
                    if (datum == null) {
                        datum = new Datum();
                        datum.setDataInfoId(syncData.getDataInfoId());
                        datum.setDataCenter(syncData.getDataCenter());
                    }
                    Datum.internDatum(datum);
                    dataChangeEventCenter.sync(DataChangeTypeEnum.COVER, dataSourceTypeEnum, datum);
                    break;
                }
            } else {
                //handle incremental data one by one
                if (!CollectionUtils.isEmpty(datums)) {
                    for (Datum datum : datums) {
                        if (datum != null) {
                            Datum.internDatum(datum);
                            dataChangeEventCenter.sync(DataChangeTypeEnum.MERGE,
                                dataSourceTypeEnum, datum);
                        }
                    }
                } 
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时逻辑如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[Sender DataServer]

+--------------------------+                                                                                     +------------------------+
|                          |     +----------------------------------------------------------------------+        |                        |
|   versionCheckExecutor   |     | [AbstractAcceptorStore]                                              |        |   expireCheckExecutor  |
|                          |     |                                                                      |        |                        |
+--------+-----------------+     |                                                                      |        +--------------+---------+
         |                       |                                                                      |                       |
         |                       |                                                                      |                       |
         |                       |                                                                      |                       |
         |                       |     Map&amp;lt;dataCenter, Map&amp;lt;dataInfoId, Acceptor&amp;gt; &amp;gt; acceptors  &amp;lt;---------------------------------+
         |   changeDataCheck     |                                                                      |     checkAcceptorsChangAndExpired
         +---------------------------&amp;gt; Map&amp;lt;dataCenter, Map&amp;lt;dataInfoId, Acceptor&amp;gt; &amp;gt; notifyAcceptorsCache |
  removeCache / notifyChange     |                                                                      |
                     +           +----------------------------------------------------------------------+
                     |
NotifyDataSyncRequest| 1         ^ 2
                     |           |
+-------------------------------------------------------------------------------------------------------------------------------------------+
                     |           |  SyncDataRequest
                     v           |
             +-------+-----------------------------------+
             |[Other DataServer] |                       |
             |                   |                       |
             |                   |                       |
             |                   +                       |
             |  GetSyncDataHandler      SyncDataCallback |
             |                                           |
             |                                           |
             |                                           |
             |                                           |
             +-------------------------------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202101/1850883-20210105214548503-19644657.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x08-syncdatarequest回送通知&quot;&gt;0x08 SyncDataRequest回送通知&lt;/h2&gt;
&lt;p&gt;&lt;u&gt;SyncDataRequest发送回通知发送者。所以这里是other DataServer 发送给 Sender DataServer&lt;/u&gt;。&lt;/p&gt;
&lt;h3 id=&quot;81-syncdatarequest&quot;&gt;8.1 SyncDataRequest&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SyncDataRequest implements Serializable {

    private String            dataInfoId;

    private String            dataCenter;

    private String            dataSourceType;

    /**
     * be null when dataInfoId not exist in local datumCache
     */
    private Long              version;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;811-syncdatarequest-从哪里来&quot;&gt;8.1.1 SyncDataRequest 从哪里来&lt;/h4&gt;
&lt;p&gt;我们回忆下，SyncDataRequest 从哪里来？在 NotifyDataSyncHandler 的响应函数中，会产生 SyncDataRequest。这里会根据请求的信息，从cache之中获取infoId对应的version，然后发送请求。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class NotifyDataSyncHandler extends AbstractClientHandler&amp;lt;NotifyDataSyncRequest&amp;gt; implements AfterWorkingProcess {

    protected void fetchSyncData(Connection connection, NotifyDataSyncRequest request) {
        String dataInfoId = request.getDataInfoId();
        String dataCenter = request.getDataCenter();
        Datum datum = datumCache.get(dataCenter, dataInfoId);
        Long version = (datum == null) ? null : datum.getVersion();
        Long requestVersion = request.getVersion();

        if (version == null || requestVersion == 0L || version &amp;lt; requestVersion) {
            getSyncDataHandler.syncData(new SyncDataCallback(getSyncDataHandler, connection,
                new SyncDataRequest(dataInfoId, dataCenter, version, request.getDataSourceType()),
                dataChangeEventCenter));
        } 
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;进而在AbstractAcceptorStore之中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void notifyChange(Acceptor acceptor) {

    Long lastVersion = acceptor.getLastVersion();

    //may be delete by expired
    if (lastVersion == null) {
        lastVersion = 0L;
    }

    NotifyDataSyncRequest request = new NotifyDataSyncRequest(acceptor.getDataInfoId(),
        acceptor.getDataCenter(), lastVersion, getType());
    
    syncServer.sendSync(syncServer.getChannel(connection.getRemoteAddress()),
                        request, 1000);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;82-syncdatahandler&quot;&gt;8.2 syncDataHandler&lt;/h3&gt;
&lt;p&gt;通知发起者使用 SyncDataHandler 来处理。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;syncDataHandler&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;节点间数据同步 Handler，该 Handler 被触发时，会通过版本号进行比对，若当前 DataServer 所存储数据版本号含有当前请求版本号，则会返回所有大于当前请求数据版本号的所有数据，便于节点间进行数据同步。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SyncDataHandler extends AbstractServerHandler&amp;lt;SyncDataRequest&amp;gt; {

    @Autowired
    private SyncDataService syncDataService;

    @Override
    public Object doHandle(Channel channel, SyncDataRequest request) {
        SyncData syncData = syncDataService.getSyncDataChange(request);
        return new GenericResponse&amp;lt;SyncData&amp;gt;().fillSucceed(syncData);
    }

    @Override
    public HandlerType getType() {
        return HandlerType.PROCESSER;
    }

    @Override
    public Class interest() {
        return SyncDataRequest.class;
    }

    @Override
    protected Node.NodeType getConnectNodeType() {
        return Node.NodeType.DATA;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;83-syncdataserviceimpl&quot;&gt;8.3 SyncDataServiceImpl&lt;/h3&gt;
&lt;p&gt;具体业务服务是SyncDataServiceImpl。会从acceptorStore获取data，即getSyncDataChange方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SyncDataServiceImpl implements SyncDataService {

    @Override
    public void appendOperator(Operator operator) {
        AcceptorStore acceptorStore = StoreServiceFactory.getStoreService(operator.getSourceType()
            .toString());
        if (acceptorStore != null) {
            acceptorStore.addOperator(operator);
        } 
    }

    @Override
    public SyncData getSyncDataChange(SyncDataRequest syncDataRequest) {
        AcceptorStore acceptorStore = StoreServiceFactory.getStoreService(syncDataRequest
            .getDataSourceType());
        if (acceptorStore != null) {
            return acceptorStore.getSyncData(syncDataRequest);
        } 
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于appendOperator如何调用，前文有描述。&lt;/p&gt;
&lt;p&gt;SyncDataServiceImpl会继续调用到AbstractAcceptorStore。&lt;/p&gt;
&lt;h3 id=&quot;84-abstractacceptorstore&quot;&gt;8.4 AbstractAcceptorStore&lt;/h3&gt;
&lt;p&gt;根据dataCenter和dataInfoId获取出Acceptor，然后返回其process后的数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public SyncData getSyncData(SyncDataRequest syncDataRequest) {

    String dataCenter = syncDataRequest.getDataCenter();
    String dataInfoId = syncDataRequest.getDataInfoId();

    Long currentVersion = syncDataRequest.getVersion();
    try {
        Map&amp;lt;String/*dataInfoId*/, Acceptor&amp;gt; acceptorMap = acceptors.get(dataCenter);
        Acceptor existAcceptor = acceptorMap.get(dataInfoId);
        return existAcceptor.process(currentVersion);
    } 
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;85-acceptor&quot;&gt;8.5 Acceptor&lt;/h3&gt;
&lt;p&gt;然后是Acceptor的处理。&lt;/p&gt;
&lt;p&gt;处理发送数据的当前版本号，如果当前版本号存在于当前queue中，返回所有版本号大于当前版本号的Operator，否则所有Operator。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public SyncData process(Long currentVersion) {
    read.lock();
    try {
        Collection&amp;lt;Operator&amp;gt; operators = acceptOperator(currentVersion);
        List&amp;lt;Datum&amp;gt; retList = new LinkedList&amp;lt;&amp;gt;();
        SyncData syncData;
        boolean wholeDataTag = false;
        if (operators != null) {
            //first get all data
            if (operators.isEmpty()) {
                wholeDataTag = true;
                retList.add(datumCache.get(dataCenter, dataInfoId));
            } else {
                for (Operator operator : operators) {
                    retList.add(operator.getDatum());
                }
            }
            syncData = new SyncData(dataInfoId, dataCenter, wholeDataTag, retList);
        } else {
            //no match get all data
            wholeDataTag = true;
            retList.add(datumCache.get(dataCenter, dataInfoId));
            syncData = new SyncData(dataInfoId, dataCenter, wholeDataTag, retList);
        }

        return syncData;
    } finally {
        read.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;同步数据结构如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SyncData implements Serializable {

    private String            dataInfoId;

    private String            dataCenter;

    private Collection&amp;lt;Datum&amp;gt; datums;

    private boolean           wholeDataTag;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时图示如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[Sender DataServer]

+--------------------------+                                                                                     +------------------------+
|                          |     +----------------------------------------------------------------------+        |                        |
|   versionCheckExecutor   |     | [AbstractAcceptorStore]                                              |        |   expireCheckExecutor  |
|                          |     |                                                                      |        |                        |
+--------+-----------------+     |                                                                      |        +--------------+---------+
         |                       |                                                                      |                       |
         |                       |                                                                      |                       |
         |                       |                                                                      |                       |
         |                       |     Map&amp;lt;dataCenter, Map&amp;lt;dataInfoId, Acceptor&amp;gt; &amp;gt; acceptors  &amp;lt;---------------------------------+
         |   changeDataCheck     |                                                                      |     checkAcceptorsChangAndExpired
         +---------------------------&amp;gt; Map&amp;lt;dataCenter, Map&amp;lt;dataInfoId, Acceptor&amp;gt; &amp;gt; notifyAcceptorsCache |
  removeCache / notifyChange     |                                                                      |
                     +           +------------------------------------------------+-----+---------------+
                     |                                                            ^     |
NotifyDataSyncRequest| 1   +-----------------+  3     +--------------------+   4  |     |
                     |     | syncDataHandler +------&amp;gt; | SyncDataServiceImpl+------+     |
                     |     +-----+-----------+        +--------------------+            |
                     |           ^ 2                                                    |
                     |           |                                                      |  5
                     |           |                                                      |
+-------------------------------------------------------------------------------------------------------------------------------------------+
                     |           |  SyncDataRequest                                     |
                     v           |                                                      |
             +-------+-----------------------------------+                              |
             |[Other DataServer] |                       |                              |
             |                   |                       |                              |
             |                   |                       |                              |
             |                   +                       |                              |
             |  GetSyncDataHandler      SyncDataCallback |  &amp;lt;---------------------------+
             |                                           |
             |                                           |
             |                                           |
             |                                           |
             +-------------------------------------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202101/1850883-20210105214609535-2063635402.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x09-syncdatacallback接受者回调&quot;&gt;0x09 SyncDataCallback接受者回调&lt;/h2&gt;
&lt;p&gt;回到接受者，遍历接受到的所有Datum，逐一调用：&lt;/p&gt;
&lt;p&gt;如果是全部datum，调用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dataChangeEventCenter.sync(DataChangeTypeEnum.COVER, dataSourceTypeEnum, datum);&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;否则调用&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dataChangeEventCenter.sync(DataChangeTypeEnum.MERGE,dataSourceTypeEnum, datum)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;具体如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class SyncDataCallback implements InvokeCallback {

    private static final Executor EXECUTOR    = ExecutorFactory.newFixedThreadPool(5,
                                                  SyncDataCallback.class.getSimpleName());

    private static final int      RETRY_COUNT = 3;

    private Connection            connection;

    private SyncDataRequest       request;

    private GetSyncDataHandler    getSyncDataHandler;

    private int                   retryCount;

    private DataChangeEventCenter dataChangeEventCenter;

    @Override
    public void onResponse(Object obj) {
        GenericResponse&amp;lt;SyncData&amp;gt; response = (GenericResponse) obj;
        if (!response.isSuccess()) {
            getSyncDataHandler.syncData(this);
        } else {
            SyncData syncData = response.getData();
            Collection&amp;lt;Datum&amp;gt; datums = syncData.getDatums();
            DataSourceTypeEnum dataSourceTypeEnum = DataSourceTypeEnum.valueOf(request
                .getDataSourceType());
            if (syncData.getWholeDataTag()) {
                //handle all data, replace cache with these datum directly
                for (Datum datum : datums) {
                    if (datum == null) {
                        datum = new Datum();
                        datum.setDataInfoId(syncData.getDataInfoId());
                        datum.setDataCenter(syncData.getDataCenter());
                    }
                    Datum.internDatum(datum);
                    dataChangeEventCenter.sync(DataChangeTypeEnum.COVER, dataSourceTypeEnum, datum);
                    break;
                }
            } else {
                //handle incremental data one by one
                if (!CollectionUtils.isEmpty(datums)) {
                    for (Datum datum : datums) {
                        if (datum != null) {
                            Datum.internDatum(datum);
                            dataChangeEventCenter.sync(DataChangeTypeEnum.MERGE,
                                dataSourceTypeEnum, datum);
                        }
                    }
                } 
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DataChangeEventCenter调用如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void sync(DataChangeTypeEnum changeType, DataSourceTypeEnum sourceType, Datum datum) {
    int idx = hash(datum.getDataInfoId());
    DataChangeEvent event = new DataChangeEvent(changeType, sourceType, datum);
    dataChangeEventQueues[idx].onChange(event);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;DataChangeEventQueue调用handleDatum处理，这部分在其他文章中已经讲述。这里只是贴出代码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void run() {
    if (changeData instanceof SnapshotData) {
        SnapshotData snapshotData = (SnapshotData) changeData;
        String dataInfoId = snapshotData.getDataInfoId();
        Map&amp;lt;String, Publisher&amp;gt; toBeDeletedPubMap = snapshotData.getToBeDeletedPubMap();
        Map&amp;lt;String, Publisher&amp;gt; snapshotPubMap = snapshotData.getSnapshotPubMap();
        Datum oldDatum = datumCache.get(dataServerConfig.getLocalDataCenter(), dataInfoId);
        long lastVersion = oldDatum != null ? oldDatum.getVersion() : 0l;
        Datum datum = datumCache.putSnapshot(dataInfoId, toBeDeletedPubMap, snapshotPubMap);
        long version = datum != null ? datum.getVersion() : 0l;
        notify(datum, changeData.getSourceType(), null);
    } else {
        Datum datum = changeData.getDatum();
        String dataCenter = datum.getDataCenter();
        String dataInfoId = datum.getDataInfoId();
        DataSourceTypeEnum sourceType = changeData.getSourceType();
        DataChangeTypeEnum changeType = changeData.getChangeType();

        if (changeType == DataChangeTypeEnum.MERGE
            &amp;amp;&amp;amp; sourceType != DataSourceTypeEnum.BACKUP
            &amp;amp;&amp;amp; sourceType != DataSourceTypeEnum.SYNC) {
            //update version for pub or unPub merge to cache
            //if the version product before merge to cache,it may be cause small version override big one
            datum.updateVersion();
        }

        long version = datum.getVersion();

        try {
            if (sourceType == DataSourceTypeEnum.CLEAN) {
                if (datumCache.cleanDatum(dataCenter, dataInfoId)) {
                }
            } else if (sourceType == DataSourceTypeEnum.PUB_TEMP) {
                notifyTempPub(datum, sourceType, changeType);
            } else {
                MergeResult mergeResult = datumCache.putDatum(changeType, datum);
                Long lastVersion = mergeResult.getLastVersion();

                if (lastVersion != null
                    &amp;amp;&amp;amp; lastVersion.longValue() == LocalDatumStorage.ERROR_DATUM_VERSION) {
                    return;
                }

                //lastVersion null means first add datum
                if (lastVersion == null || version != lastVersion) {
                    if (mergeResult.isChangeFlag()) {
                        notify(datum, sourceType, lastVersion);
                    }
                }
            }
        } 
    }

}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;91-datachangehandler&quot;&gt;9.1 DataChangeHandler&lt;/h3&gt;
&lt;p&gt;DataChangeHandler 会定期提取DataChangeEventCenter中的消息，然后进行处理。&lt;/p&gt;
&lt;p&gt;ChangeNotifier存储了Datum。因为此时版本号已经更新，所以不会再次通知，至此流程结束。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;MergeResult mergeResult = datumCache.putDatum(changeType, datum);


//lastVersion null means first add datum
if (lastVersion == null || version != lastVersion) {
    if (mergeResult.isChangeFlag()) {
        notify(datum, sourceType, lastVersion);
     }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此时逻辑如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[Sender DataServer]

+--------------------------+                                                                                     +------------------------+
|                          |     +----------------------------------------------------------------------+        |                        |
|   versionCheckExecutor   |     | [AbstractAcceptorStore]                                              |        |   expireCheckExecutor  |
|                          |     |                                                                      |        |                        |
+--------+-----------------+     |                                                                      |        +--------------+---------+
         |                       |                                                                      |                       |
         |                       |                                                                      |                       |
         |                       |                                                                      |                       |
         |                       |     Map&amp;lt;dataCenter, Map&amp;lt;dataInfoId, Acceptor&amp;gt; &amp;gt; acceptors  &amp;lt;---------------------------------+
         |   changeDataCheck     |                                                                      |     checkAcceptorsChangAndExpired
         +---------------------------&amp;gt; Map&amp;lt;dataCenter, Map&amp;lt;dataInfoId, Acceptor&amp;gt; &amp;gt; notifyAcceptorsCache |
  removeCache / notifyChange     |                                                                      |
                     +           +------------------------------------------------+-----+---------------+
                     |                                                            ^     |
NotifyDataSyncRequest| 1   +-----------------+  3     +--------------------+   4  |     |
                     |     | syncDataHandler +------&amp;gt; | SyncDataServiceImpl+------+     |
                     |     +-----+-----------+        +--------------------+            |
                     |           ^ 2                                                    |
                     |           |                                                      |  5
                     |           |                                                      |
+-------------------------------------------------------------------------------------------------------------------------------------------+
                     |           |  SyncDataRequest                                     |
[Other DataServer]   |           |                                                      |
                     |           |                                                      |
                     |           |                                                      |
                     |           |              +---------------------------------------+
                     |           |              |
                     |           |              |
                     v           |              v
              +------+-----------++ +-----------+-------+  6    +-----------------------+  7   +--------------------+  8   +-----------------+
              | GetSyncDataHandler| |  SyncDataCallback +-----&amp;gt; | DataChangeEventCenter | +--&amp;gt; |DataChangeEventQueue| +--&amp;gt; |DataChangeHandler|
              +-------------------+ +-------------------+       +-----------------------+      +--------------------+      +-----------------+

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;手机上如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1850883/202101/1850883-20210105214629738-605270161.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;0x10-总结&quot;&gt;0x10 总结&lt;/h2&gt;
&lt;p&gt;回顾下“一次服务注册过程”的服务数据在内部流转过程。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Client 调用 publisher.register 向 SessionServer 注册服务。&lt;/li&gt;
&lt;li&gt;SessionServer 收到服务数据 （PublisherRegister） 后，将其写入内存 （SessionServer 会存储 Client 的数据到内存，用于后续可以跟 DataServer 做定期检查），再根据 dataInfoId 的一致性 Hash 寻找对应的 DataServer，将 PublisherRegister 发给 DataServer。&lt;/li&gt;
&lt;li&gt;DataServer 接收到 PublisherRegister 数据，首先也是将数据写入内存 ，DataServer 会以 dataInfoId 的维度汇总所有 PublisherRegister。同时，DataServer 将该 dataInfoId 的变更事件通知给所有 SessionServer，变更事件的内容是 dataInfoId 和版本号信息 version。&lt;/li&gt;
&lt;li&gt;同时，异步地，DataServer 以 dataInfoId 维度增量地同步数据给其他副本。因为 DataServer 在一致性 Hash 分片的基础上，对每个分片保存了多个副本（默认是3个副本）。&lt;/li&gt;
&lt;li&gt;SessionServer 接收到变更事件通知后，对比 SessionServer 内存中存储的 dataInfoId 的 version，若发现比 DataServer 发过来的小，则主动向 DataServer 获取 dataInfoId 的完整数据，即包含了所有该 dataInfoId 具体的 PublisherRegister 列表。&lt;/li&gt;
&lt;li&gt;最后，SessionServer 将数据推送给相应的 Client，Client 就接收到这一次服务注册之后的最新的服务列表数据。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;因为篇幅所限，上文讨论的是前两点，本文介绍第三，第四点&lt;/strong&gt;。如果以后有时间，会介绍最后两点。&lt;/p&gt;
&lt;h2 id=&quot;0xff-参考&quot;&gt;0xFF 参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liujunj/p/13401809.html&quot; target=&quot;_blank&quot;&gt;Eureka系列(六) TimedSupervisorTask类解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/boling_cavalry/article/details/82795825&quot; target=&quot;_blank&quot;&gt;Eureka的TimedSupervisorTask类（自动调节间隔的周期性任务）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dafanjoy/p/9729358.html&quot; target=&quot;_blank&quot;&gt;java线程池ThreadPoolExecutor类使用详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/rossiXYZ/p/dockone.io/article/8284&quot; target=&quot;_blank&quot;&gt;Java线程池ThreadPoolExecutor实现原理剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liuzhihu/p/8177371.html&quot; target=&quot;_blank&quot;&gt;深入理解Java线程池：ThreadPoolExecutor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/liuzhihu/p/8177371.html&quot; target=&quot;_blank&quot;&gt;深入理解Java线程池：ThreadPoolExecutor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://ifeve.com/java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0threadpoolexecutor%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/&quot; target=&quot;_blank&quot;&gt;Java中线程池ThreadPoolExecutor原理探究&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-dataserver-smooth-expansion-contraction/&quot; target=&quot;_blank&quot;&gt;蚂蚁金服服务注册中心如何实现 DataServer 平滑扩缩容&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-service-discovery-optimization/&quot; target=&quot;_blank&quot;&gt;蚂蚁金服服务注册中心 SOFARegistry 解析 | 服务发现优化之路&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-session-storage/&quot; target=&quot;_blank&quot;&gt;服务注册中心 Session 存储策略 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-introduction/&quot; target=&quot;_blank&quot;&gt;海量数据下的注册中心 - SOFARegistry 架构介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-registry-data-fragmentation-synchronization-scheme/&quot; target=&quot;_blank&quot;&gt;服务注册中心数据分片和同步方案详解 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-blot-connection-management-deep-dive/&quot; target=&quot;_blank&quot;&gt;蚂蚁金服开源通信框架SOFABolt解析之连接管理剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-bolt-timeout-and-heart-beat-deep-dive/&quot; target=&quot;_blank&quot;&gt;蚂蚁金服开源通信框架SOFABolt解析之超时控制机制及心跳机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/blog/sofa-bolt-framework-deep-dive/&quot; target=&quot;_blank&quot;&gt;蚂蚁金服开源通信框架 SOFABolt 协议框架解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/SOFAStack/article/details/104645427/&quot; target=&quot;_blank&quot;&gt;蚂蚁金服服务注册中心数据一致性方案分析 | SOFARegistry 解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_47364682/article/details/sohu.com/a/227222689_609518&quot; target=&quot;_blank&quot;&gt;蚂蚁通信框架实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/c740810af40c&quot; target=&quot;_blank&quot;&gt;sofa-bolt 远程调用&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_47364682/article/details/jianshu.com/p/f1fae13c7848&quot; target=&quot;_blank&quot;&gt;sofa-bolt学习&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/65c823de1249&quot; target=&quot;_blank&quot;&gt;SOFABolt 设计总结 - 优雅简洁的设计之道&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_34088913/article/details/108469517&quot; target=&quot;_blank&quot;&gt;SofaBolt源码分析-服务启动到消息处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/java-zhao/p/9824283.html&quot; target=&quot;_blank&quot;&gt;SOFABolt 源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/f2b8a2099323&quot; target=&quot;_blank&quot;&gt;SOFABolt 源码分析9 - UserProcessor 自定义处理器的设计&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.sofastack.tech/projects/sofa-registry/overview/&quot; target=&quot;_blank&quot;&gt;SOFARegistry 介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/weixin_47364682/article/details/jianshu.com/p/d17b60418c54&quot; target=&quot;_blank&quot;&gt;SOFABolt 源码分析13 - Connection 事件处理机制的设计&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sat, 09 Jan 2021 00:29:00 +0000</pubDate>
<dc:creator>罗西的思考</dc:creator>
<og:description>SOFARegistry 是蚂蚁金服开源的一个生产级、高时效、高可用的服务注册中心。 本系列文章重点在于分析设计和架构，即利用多篇文章，从多个角度反推总结 DataServer 或者 SOFARegi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/rossiXYZ/p/14238230.html</dc:identifier>
</item>
<item>
<title>CF1467C Three Bags - SummerMingQAQ</title>
<link>http://www.cnblogs.com/SSummerZzz/p/14253958.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/SSummerZzz/p/14253958.html</guid>
<description>&lt;p&gt;&lt;a href=&quot;https://codeforces.ml/contest/1467/problem/C&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1714202/202101/1714202-20210109023136333-1205187152.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1714202/202101/1714202-20210109023147590-2037326128.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;思路：对于一般情况，我们有三个袋子，容易想到把袋子里物品的价值排序。然后贪心，我们想让最后的价值最大，则三个袋子最后都可以剩余一个物品，这三个物品总和需要最大，最好的情况就是三个物品的符号“+”，“-”，“-”,这样总价值直接可以算是每个袋子中物品绝对值的累加和。为了让三个物品价值最大，我们可以容易想到，价值大的物品减去价值小的物品，让可用价值尽可能大，而且最后剩余每个袋子的最后物品符号分别是“+”“-”“-”。这样，我们之前每个袋子的物品都排好了序，容易想到，对于三个袋子中，每个袋子价值最小的物品是关键。因为我们需要让可用价值尽可能大，所以我们可以让三个袋子中，最小值最大的那个物品为“+”,然后让其他两个袋子中的最小物品收集其他价值，这样就满足了三个袋子都只剩下一个物品且满足“+”“-”“-”。我们可以让最小值最大和最小值中间大的袋子中其他物品累加减去和最小值最小的物品让其为“-”，然后让最小值最小的其他物品累加和减去最小值中间大的那个物品让其为“-”就可以了。但最小值最小的其他所有物品和最小值中间大的物品的差值会有特殊情况，例如：最小值的其他物品 1，1；中间值的最小值 4.这样（4-1-1 = 2）,这里需要特判一下，我们发现两者的差值只需要取一个abs就可以了，上面的例子可以转化为：1 - 中间值放入最小值的袋中，变成了abs（-3+1）。&lt;/p&gt;
&lt;p&gt;然后就是特殊情况，即三个袋子中任意一个袋子的物品只有一个的情况，需要特殊判断。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1714202/202101/1714202-20210109025845186-634506233.png&quot; alt=&quot;&quot; width=&quot;420&quot; height=&quot;419&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;63&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include &amp;lt;iostream&amp;gt;
&lt;span&gt; 2&lt;/span&gt; #include &amp;lt;cstdio&amp;gt;
&lt;span&gt; 3&lt;/span&gt; #include &amp;lt;algorithm&amp;gt;
&lt;span&gt; 4&lt;/span&gt; #include &amp;lt;cstring&amp;gt;
&lt;span&gt; 5&lt;/span&gt; #include &amp;lt;cmath&amp;gt;
&lt;span&gt; 6&lt;/span&gt; #include &amp;lt;queue&amp;gt;
&lt;span&gt; 7&lt;/span&gt; #include &amp;lt;vector&amp;gt;
&lt;span&gt; 8&lt;/span&gt; #include &amp;lt;cstring&amp;gt;
&lt;span&gt; 9&lt;/span&gt; #include &amp;lt;functional&amp;gt;
&lt;span&gt;10&lt;/span&gt; #include &amp;lt;map&amp;gt;
&lt;span&gt;11&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; LL long long
&lt;span&gt;12&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; lson(rt) (rt &amp;lt;&amp;lt; 1)
&lt;span&gt;13&lt;/span&gt; &lt;span&gt;#define&lt;/span&gt; rson(rt) (rt &amp;lt;&amp;lt; 1 | 1)
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; 
&lt;span&gt;16&lt;/span&gt; &lt;span&gt;const&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; N = 1e3 + &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;struct&lt;/span&gt;&lt;span&gt; node
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; v, id;
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; 
&lt;span&gt;21&lt;/span&gt;     &lt;span&gt;bool&lt;/span&gt; friend &lt;span&gt;operator&lt;/span&gt;&amp;lt;(&lt;span&gt;const&lt;/span&gt; node&amp;amp; a, &lt;span&gt;const&lt;/span&gt; node&amp;amp;&lt;span&gt; b)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;         &lt;span&gt;return&lt;/span&gt; a.v &amp;lt;&lt;span&gt; b.v;
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;};
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; a[N];
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; 
&lt;span&gt;28&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; solve ()
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt;&lt;span&gt; n, m, k, x;
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;n, &amp;amp;m, &amp;amp;&lt;span&gt;k);
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;     vector&amp;lt;&lt;span&gt;int&lt;/span&gt; &amp;gt; a[&lt;span&gt;3&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; n; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt;34&lt;/span&gt; 
&lt;span&gt;35&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt;         a[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].push_back(x);
&lt;/span&gt;&lt;span&gt;37&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; m; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;         a[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].push_back(x);
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; k; ++&lt;span&gt;i) {
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;         scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &amp;amp;&lt;span&gt;x);
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt;         a[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;].push_back(x);
&lt;/span&gt;&lt;span&gt;45&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;46&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;0&lt;/span&gt;; i &amp;lt; &lt;span&gt;3&lt;/span&gt;; ++&lt;span&gt;i) sort(a[i].begin(), a[i].end());
&lt;/span&gt;&lt;span&gt;47&lt;/span&gt; 
&lt;span&gt;48&lt;/span&gt;     vector&amp;lt;node &amp;gt;&lt;span&gt; vn;
&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;     vn.push_back({a[&lt;span&gt;0&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;0&lt;/span&gt;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;50&lt;/span&gt;     vn.push_back({a[&lt;span&gt;1&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;1&lt;/span&gt;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;51&lt;/span&gt;     vn.push_back({a[&lt;span&gt;2&lt;/span&gt;][&lt;span&gt;0&lt;/span&gt;], &lt;span&gt;2&lt;/span&gt;&lt;span&gt;});
&lt;/span&gt;&lt;span&gt;52&lt;/span&gt; 
&lt;span&gt;53&lt;/span&gt; &lt;span&gt;    sort(vn.begin(), vn.end());
&lt;/span&gt;&lt;span&gt;54&lt;/span&gt; 
&lt;span&gt;55&lt;/span&gt; 
&lt;span&gt;56&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; maxx = vn[&lt;span&gt;2&lt;/span&gt;&lt;span&gt;].id;
&lt;/span&gt;&lt;span&gt;57&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; midd = vn[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;].id;
&lt;/span&gt;&lt;span&gt;58&lt;/span&gt;     &lt;span&gt;int&lt;/span&gt; minn = vn[&lt;span&gt;0&lt;/span&gt;&lt;span&gt;].id;
&lt;/span&gt;&lt;span&gt;59&lt;/span&gt; 
&lt;span&gt;60&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; maxv, midv, minv;
&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;     maxv = midv = minv = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;62&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(auto x : a[maxx]) maxv +=&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;63&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(auto x : a[midd]) midv +=&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;64&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(auto x : a[minn]) minv +=&lt;span&gt; x;
&lt;/span&gt;&lt;span&gt;65&lt;/span&gt;   &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  printf(&quot;(%lld %lld %lld)\n&quot;, maxv, midv,minv);&lt;/span&gt;
&lt;span&gt;66&lt;/span&gt;     midv -= a[midd][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;67&lt;/span&gt;     minv -= a[minn][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;     maxv -= a[maxx][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;69&lt;/span&gt;  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;   printf(&quot;(%lld %lld %lld)\n&quot;, maxv, midv,minv);
&lt;/span&gt;&lt;span&gt;70&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; printf(&quot;(%d %d %d)\n&quot;, a[maxx].size(), a[midd].size(), a[minn].size());&lt;/span&gt;
&lt;span&gt;71&lt;/span&gt;     &lt;span&gt;long&lt;/span&gt; &lt;span&gt;long&lt;/span&gt; ans = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;72&lt;/span&gt;     &lt;span&gt;if&lt;/span&gt;(a[minn].size() == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;         ans += maxv + midv + a[maxx][&lt;span&gt;0&lt;/span&gt;] + a[midd][&lt;span&gt;0&lt;/span&gt;] - a[minn][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;74&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(a[midd].size() == &lt;span&gt;1&lt;/span&gt;&lt;span&gt;) {
&lt;/span&gt;&lt;span&gt;75&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     cout &amp;lt;&amp;lt; &quot;s&quot; &amp;lt;&amp;lt; endl;&lt;/span&gt;
&lt;span&gt;76&lt;/span&gt;         ans += abs(minv + a[minn][&lt;span&gt;0&lt;/span&gt;] - a[midd][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;77&lt;/span&gt;         ans += a[maxx][&lt;span&gt;0&lt;/span&gt;] +&lt;span&gt; maxv;
&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt;(a[maxx].size() == &lt;span&gt;1&lt;/span&gt; &amp;amp;&amp;amp; a[maxx][&lt;span&gt;0&lt;/span&gt;] &amp;lt; a[midd][&lt;span&gt;0&lt;/span&gt;] + a[minn][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]) {
&lt;/span&gt;&lt;span&gt;79&lt;/span&gt;         ans += midv + minv + a[midd][&lt;span&gt;0&lt;/span&gt;] + a[minn][&lt;span&gt;0&lt;/span&gt;] - a[maxx][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;80&lt;/span&gt;     } &lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
&lt;/span&gt;&lt;span&gt;81&lt;/span&gt;    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;     cout &amp;lt;&amp;lt; &quot;s&quot; &amp;lt;&amp;lt; endl;&lt;/span&gt;
&lt;span&gt;82&lt;/span&gt;         ans += a[maxx][&lt;span&gt;0&lt;/span&gt;] + maxv + midv - a[minn][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;];
&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;         ans += abs(minv - a[midd][&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]);
&lt;/span&gt;&lt;span&gt;84&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;85&lt;/span&gt; 
&lt;span&gt;86&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%lld\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, ans);
&lt;/span&gt;&lt;span&gt;87&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;88&lt;/span&gt; 
&lt;span&gt;89&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main ()
&lt;/span&gt;&lt;span&gt;90&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;91&lt;/span&gt; 
&lt;span&gt;92&lt;/span&gt; &lt;span&gt;    solve();
&lt;/span&gt;&lt;span&gt;93&lt;/span&gt; 
&lt;span&gt;94&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;95&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Fri, 08 Jan 2021 18:51:00 +0000</pubDate>
<dc:creator>SummerMingQAQ</dc:creator>
<og:description>传送门 思路：对于一般情况，我们有三个袋子，容易想到把袋子里物品的价值排序。然后贪心，我们想让最后的价值最大，则三个袋子最后都可以剩余一个物品，这三个物品总和需要最大，最好的情况就是三个物品的符号“+</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/SSummerZzz/p/14253958.html</dc:identifier>
</item>
<item>
<title>Liunx运维(十)-网络管理命令 - Mrwhite86</title>
<link>http://www.cnblogs.com/mrwhite2020/p/14196645.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mrwhite2020/p/14196645.html</guid>
<description>&lt;p&gt;文档目录：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q1&quot;&gt;一、ifconfig：配置或显示网络接口信息&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q2&quot;&gt;二、ifup:激活网络接口&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q3&quot;&gt;三、ifdown：禁用网络接口&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q4&quot;&gt;四、route：显示或管理理由表&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q5&quot;&gt;五、arp：管理系统的arp缓存&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q6&quot;&gt;六、ip：网络配置工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q7&quot;&gt;七、netstat：查看网络状态&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q8&quot;&gt;八、ss：查看网络状态&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q9&quot;&gt;九、ping：测试主机之间的网络的连通性&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q10&quot;&gt;十、traceroute：追踪数据传输路由状况&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q11&quot;&gt;十一、arping：发送arp请求&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q12&quot;&gt;十二、telnet：远程登录主机&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q13&quot;&gt;十三、nc：多功能网络工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q14&quot;&gt;十四、ssh：安全地远程登录主机&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q15&quot;&gt;十五、wget：命令行下载工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q16&quot;&gt;十六、mailq：显示邮件传输队列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q17&quot;&gt;十七、mail：发送和接受邮件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q18&quot;&gt;十八、nslookup：域名查询工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q19&quot;&gt;十九&lt;/a&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q19&quot;&gt;、dig：域名查询工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q20&quot;&gt;二十、host：域名查询工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q21&quot;&gt;二十一、nmap：网络探测工具和安全/端口扫描器&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/mrwhite2020/p/14196645.html#q22&quot;&gt;二十二、tcpdump：监听网络流量&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;---------------------------------------分割线：正文--------------------------------------------------------&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;一、ifconfig：配置或显示网络接口信息&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、ifconfig  #显示系统中所有网卡的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210103195534646-135476350.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、ifconfig ens33 #显示指定网卡的信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210103195806096-1174383920.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、ifconfig -a #查看所有的网卡信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210103200354371-125970939.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、ifconfig ens33 up #启动网卡&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210103200458135-1970434012.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、ifconfig ens33 down #关闭网卡&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210103200716532-1394799962.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 6、ifconfig ens33 192.168.37.10 #配置网卡的ip地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210103200957555-758493109.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 7、ifconfig ens33:1 192.168.37.10 netmask 255.255.255.0 up #网卡设置别名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210103204026182-75366418.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 8、ifconfig ens33 hw ether 00:0c:29:00:33:25 #修改网卡的MAC地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210103204412603-2053305426.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 9、永久修改网卡信息，需要修改网卡的配置文件，否则重启后失效&lt;/p&gt;
&lt;p&gt;网卡：ens33：对应配置文件路径：/etc/sysconfig/network-scripts/ifcfg-ens33&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、ifup:激活网络接口&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ifup ens33 #激活网络接口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210103210435291-1155049017.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 三、ifdown：禁用网络接口&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;ifdown ens33 #关闭网卡后网卡信息消失&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210103210938863-1531534197.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;四、route：显示或管理理由表&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、route #查看路由表信息，默认会根据IP地址进行DNS解析生成主机名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210103212321597-2059696514.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、route -n #不进行DNS域名解析，会加快显示速度&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210103212617783-314355723.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、具体含义：&lt;/p&gt;
&lt;p&gt;Destionation：网络号，network的意思&lt;/p&gt;
&lt;p&gt;Gateway：网关地址，通过该IP连接出去，0.0.0.0表示该路由是直接由本机传送出去&lt;/p&gt;
&lt;p&gt;Genmask：子网掩码&lt;/p&gt;
&lt;p&gt;Flags：路由标记信息，具体如下：&lt;/p&gt;
&lt;p&gt;U-启动状态&lt;/p&gt;
&lt;p&gt;H-目标路由是一个主机IP非网络&lt;/p&gt;
&lt;p&gt;R-使用动态路由时,恢复路由信息标记&lt;/p&gt;
&lt;p&gt;G-表示需要外部的主机来转接传递数据&lt;/p&gt;
&lt;p&gt;M-表示路由已经被修改了&lt;/p&gt;
&lt;p&gt;D-已经由服务设定为动态路由&lt;/p&gt;
&lt;p&gt;!-这个路由将不会被接受&lt;/p&gt;
&lt;p&gt;Metric：需要经过几个网络节点才能到达路由的目标网络地址&lt;/p&gt;
&lt;p&gt;Ref：参考到此路由规则的数目&lt;/p&gt;
&lt;p&gt;Use：有几个转送数据包参考到了此路由规则&lt;/p&gt;
&lt;p&gt;Iface：路由对应的网络设备接口&lt;/p&gt;
&lt;p&gt;4、route del default #删除网关方法1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210104233009385-863078521.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;route del default gw 192.168.37.2  #删除网关方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210104233246645-144379563.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、route add default gw 192.168.37.2 #添加网关方法1，指明网关地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210104233128529-237002526.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;route add default gw 192.168.37.2 dev ens33  #添加网关方法2，指明网关设备，适用于多块网络设备的主机&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210104233414148-525312781.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 6、route add -net 192.168.1.0/24 gw 192.168.37.8  #配置网络路由，实现两块网卡地址，192.168.37网段可访问192.168.1.0网段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210104234142731-138509561.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 7、路由配置永久生效配置方法：&lt;/p&gt;
&lt;p&gt;vi /etc/sysconfig/network-scripts/route-eth1 #方法一，默认此文件不存在&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210104234548206-895619357.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; vi /etc/sysconfig/network-scripts/route-eth1 #方法二，默认此文件不存在&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210104234708834-945355045.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; vi /etc/rc.local #方法三，写入开机启动&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210104234839792-734196340.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 配置默认网关可以写在网卡内&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210104234959637-411215071.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 8、配置和删除主机路由&lt;/p&gt;
&lt;p&gt;route add -host 192.168.2.13 dev ens33 #添加去往某个主机的路由&lt;/p&gt;
&lt;p&gt;route del -host 192.168.2.13 dev ens33 #删除主机路由&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210104235625982-2140383590.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;五、arp：管理系统的arp缓存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、arp #显示arp缓存区的所有条目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210104235759413-850738381.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;Flag：C-arp高速缓存中条目，M-静态arp条目&lt;/p&gt;
&lt;p&gt;2、arp -n #以数字形式显示arp缓存条目&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210105000211537-1656869842.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、arp -n 192.168.37.1 #指定查询arp信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210104235949743-1430926569.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、arp -s 192.168.37.11 00:0c:29:c0:5a:ef #静态绑定ip地址与mac地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210105000242899-1457641285.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、arp -d 192.168.37.11 #删除静态ARP绑定&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210105000332313-544189670.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 六、ip：网络配置工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、ip link show dev ens33 #显示ens33网卡属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210105000442454-361288184.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、ip -s -s  link show dev ens33 #使用两个-s获取更加详细的属性&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210105000530495-347712537.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、ip link set dev ens33 #激活ens33网卡&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210105000848183-235039015.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、ip link set down  ens33 #关闭ens33网卡&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210105000927708-1568118270.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、ip link set ens33 address 00:0c:29:00:33:24 #修改网卡mac地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210105001336256-721544689.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 6、ip a #同等与ip address查看激活与未激活的网卡信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210105001439045-988443039.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 7、删除ip地址&lt;/p&gt;
&lt;p&gt;ip a del 192.168.37.8/24 dev ens33 #删除ip地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210105002152454-1498303731.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 8、添加ip地址（并激活）&lt;/p&gt;
&lt;p&gt;ip a add  192.168.37.8/24 dev ens33 #添加ip地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210105002421817-1151712483.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;9、ip route #查看路由表&lt;/p&gt;
&lt;p&gt;ip route | column -t #colum格式化，-t默认空格分隔判断输入行的列数来创建一个表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106001452828-1887770374.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 10、ip route add 192.168.10.0/24 via 192.168.37.2 dev ens33 #添加静态路由&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106002429489-1732131467.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 11、ip route del 192.168.10.0/24 via 192.168.37.2 dev ens33 #删除静态路由&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106002501615-1941768902.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 12、ip neighbour #使用neighbour查看arp缓存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106002547175-1691845710.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 13、ip neighbour add 192.168.1.100 lladdr 00:0c:29:c0:5a:ef dev ens33 #添加静态ARP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106002651760-1619072844.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 14、ip neighbour del  192.168.1.100  dev ens33 #删除静态ARP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106002745246-1191224532.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;七、netstat：查看网络状态&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、netstat -an #显示所有连接信息&lt;/p&gt;
&lt;p&gt;第一行：活动网络(TCP/IP)连接说明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106003722414-841986914.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一列：Proto：socket使用的协议（TCP、UDP、RAW）&lt;/p&gt;
&lt;p&gt;第二列：Recv-Q：接收到但是还未处理的字节数&lt;/p&gt;
&lt;p&gt;第三列：Send-Q：已经发送但是未被远程主机确认收到的字节数&lt;/p&gt;
&lt;p&gt;第四列：Loacl Address：本地主机地址和端口&lt;/p&gt;
&lt;p&gt;第五列：Foreign Address：远程主机地址和端口&lt;/p&gt;
&lt;p&gt;第六列：State：socket的状态，通常仅仅TCP的状态，状态值可能有ESTABLISHED、SYN_SENT、SYN_RECV、FIN_WAIT1、FIN_WAIT2、TIME_WAIT、LISTEN等&lt;/p&gt;
&lt;p&gt;状态解释：&lt;/p&gt;
&lt;p&gt;ESTABLISHED：服务并发连接&lt;/p&gt;
&lt;p&gt;SYN_SENT：尝试建立连接&lt;/p&gt;
&lt;p&gt;SYN_RECV：已经从网络上收到一个连接请求&lt;/p&gt;
&lt;p&gt;FIN_WAIT1：socket已关闭，连接正在或正要关闭&lt;/p&gt;
&lt;p&gt;FIN_WAIT2：连接已关闭，冰球socket正在等待远端结束&lt;/p&gt;
&lt;p&gt;TIME_WAIT：socket正在等待关闭处理仍在网络上的数据包，这个连接状态在生产场景中很重要，需要重点关注&lt;/p&gt;
&lt;p&gt;CLOSED：socket不再被占用&lt;/p&gt;
&lt;p&gt;CLOSED_WAIT：远端已经结束，等待socket关闭&lt;/p&gt;
&lt;p&gt;LAST_ACK：远端已经结束，并且socket也已关闭，等待acknowlegement&lt;/p&gt;
&lt;p&gt;LISTEN：socket正在监听连接请求&lt;/p&gt;
&lt;p&gt;CLOSING：socket正在监听连接请求&lt;/p&gt;
&lt;p&gt;UNKNOWN：socket状态未知&lt;/p&gt;
&lt;p&gt;2、netstat -ntplu #显示所有TCP/UDP正在监听的连接信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106004947415-442652473.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; -p：进程号与进程名  -n：显示ip地址，不进行dns解析成主机名、域名   -t：显示所有tcp连接  -u：显示所有udp连接 -l：显示所有LISTEN状态的网络连接&lt;/p&gt;
&lt;p&gt; 3、 netstat -rn #显示当前系统的路由表&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106005251897-685414133.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、netstat -i #显示网络的接口状况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106005335509-651451301.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; Iface：表示网络设备的接口名称&lt;/p&gt;
&lt;p&gt;MTU：表示最大传输单元，单位为字节&lt;/p&gt;
&lt;p&gt;RX-OK/TX-OK：表示已经准确无误地接受/发送了多少数据包&lt;/p&gt;
&lt;p&gt;RX-ERR/TX-ERR：表示接受/发送数据包时产生了多少错误&lt;/p&gt;
&lt;p&gt;RX-DRP/TX-DRP：表示接受/发送数据包时丢弃了多少数据包&lt;/p&gt;
&lt;p&gt;RX-OVR/TX-OVR：表示由于误差而遗失了多少数据包&lt;/p&gt;
&lt;p&gt;Flg：表示接口标记，其中各标记含义具体如下。&lt;/p&gt;
&lt;p&gt;　　L：表示该接口是个回环设备。&lt;/p&gt;
&lt;p&gt;　　B：表示设置了广播地址。&lt;/p&gt;
&lt;p&gt;　　M：表示接受所有数据包。&lt;/p&gt;
&lt;p&gt;　　R：表示接口正在运行。&lt;/p&gt;
&lt;p&gt;　　U：表示接口处于活动状态。&lt;/p&gt;
&lt;p&gt;　　O：表示在该接口上禁用arp。&lt;/p&gt;
&lt;p&gt;　　P：表示一个点到点的连接。&lt;/p&gt;
&lt;p&gt;正常情况下，RX-ERR/TX-ERR、RX-DRP/TX-DRP、RX-OVR/TX-OVR值应该为0，如果这几项值不为0，并且很大，那么网络质量肯定有问题，网络传输性能也一定会下降&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;八、ss：查看网络状态&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、ss -an #显示所有socket连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106010106035-579725414.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; ss -an | column -t #格式化展示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106010154561-1424317455.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、ss -ntplu|column -t #显示所有正在监听的tcp和udp连接&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106010306957-1300165827.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、ss -s #统计当前established、closed、orphaned、waiting的所有tcp socket数量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210106010451557-6960971.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;九、ping：测试主机之间的网络的连通性&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、ping www.baidu.com #ping命令直接接域名或IP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107001109230-1906052365.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、ping -c 3 -i 3 -s 1024 -t 255 www.baidu.com #-c 3:发送3次ICMP包，-i 3:每次发包时间间隔3s -s:1024 设置发送数据包大小1024字节 -t 255 设置发送数据库的ttl为255&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107001456284-257131064.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十、traceroute：追踪数据传输路由状况&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、traceroute www.baidu.com #查看主机的路由状况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107001827471-1651984120.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、traceroute -I www.baidu.com #加快查询时间 ping查询&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107001954065-715818149.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、traceroute -In www.baidu.com #不解析主机名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107002027125-489206471.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;十一、arping：发送arp请求&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、arping -f 192.168.37.9  #使用-f 选项收到第一个响应时就退出，用于检测目的主机是否存活&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107215855029-320954259.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、arping -f 10.0.0.3 #没有运行的主机不会响应，命令一直等待，值到ctrl+c终止&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107220019489-1286361606.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、arping -c 1 -I ens33 -s 10.0.0.5 10.0.0.2 #10.0.05-vip地址,10.0.0.2 上网网关。负载均衡器宕机时arp缓存导致故障时，让客户端缓存失效&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;十二、telnet：远程登录主机&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;telnet为明文，ssh为密文&lt;/p&gt;
&lt;p&gt;telnet 192.168.37.9 22 #连接成功 ctrl+]进入&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107221155167-803144565.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十三、nc：多功能网络工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试nv命令时需要关闭防火墙和seliunx&lt;/p&gt;
&lt;p&gt;systemctl stop firewalld.service #关闭防火墙&lt;/p&gt;
&lt;p&gt;getenforce  #关闭selinux&lt;/p&gt;
&lt;p&gt;1、nc -l 12345 &amp;gt; test01.nc #监听12345端口，将数据写入test01.nc&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107225647056-1499302853.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  2、nc 192.168.37.8 12345 &amp;lt; test01.txt #使用nc命令向192.168.37.8端口传输 test01.txt文件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107225707718-309919150.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、 nc -l 80 &amp;lt; testweb.txt #一直监听80端口，test.txt是发送给用户的内容&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107231314528-1943633662.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、nc cnblogs.com 80 #手动建立与HTTP服务器建立连接的例子&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107233002871-1249301038.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、nc -z -v 192.168.37.8 20-30  #扫描主机20-30端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210107233314544-56187869.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;6、nc 127.0.0.1 12345 #模拟qq聊天工具，以下为窗口1，窗口2，窗口3&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108001432113-715397675.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108001443311-1378721202.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108001450932-1686564333.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;十四、ssh：安全地远程登录主机&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、ssh 192.168.37.9 #等同于ssh -p 22（默认22）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108001733817-166538046.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;  ctrl+d或logout退出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108001828039-43961422.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、ssh -p 22 lulu@192.168.37.9 #登录指定用户&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108002011691-919788068.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、ssh -v root@192.168.37.9 #登录慢问题排查&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108002132855-883746572.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;十五、wget：命令行下载工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、特点：支持断点续传，支持FTP与HTTP，支持代理服务器，非常稳定&lt;/p&gt;
&lt;p&gt;2、wget https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png #wget接-下载地址&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108003112645-1939319258.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、wget -o ./testdir/123.png https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png #-o 指定文件报错的地址与文件名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108003523260-199251584.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、wget --limit-rate=3k https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png #限速下载3k/s&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108232621530-598657690.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、wget -c http://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso #断点续传&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108233650660-513883022.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 6、wget -c -b http://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso #-b 使用后台下载&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108234259860-11984492.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;7、wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://mirrors.aliyun.com/centos/7/isos/x86_64/CentOS-7-x86_64-DVD-2009.iso #伪装代理名称下载，用于一些网站的限制&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108234438155-245391263.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 8、wget -q -T 3 --tries=1  --spider www.baidu.com #采用静默访问方式，3秒超时，重试1此，模拟爬虫方式进行访问&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108234933105-20221966.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十六、mailq：显示邮件传输队列&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、mailq #查看邮件队列&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108235131542-1421166281.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、mailq -v #调式信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210108235145872-196856760.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十七、mail：发送和接受邮件&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、mail是个软链接，真实的程序是mailx&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109001214892-209070343.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、mail -s &quot;hello world from bk&quot; 114558020@qq.com #发送邮件，以下手动输入，ctrl+d结束，邮件发出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109001349815-2040014629.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、echo -e &quot;hello,this is a mail\nwelcom to www.baidu.com&quot;|mail -s &quot;hello from bk&quot; 114558020@qq.com #使用管道发送邮件，echo后面是正文&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109001521515-1789198191.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、#使用输入重定向将文件内容发送mail&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109001657880-40276431.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、echo &quot;test&quot;|mail -s &quot;test&quot; -a abc.jpg  114558020@qq.com #发送邮件附件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109002804556-1959367621.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 十八、nslookup：域名查询工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、 nslookup #进入交互模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109003530678-1306307921.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、nslookup - 223.5.5.5 #命令行指定解析域名服务器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109003656036-635752358.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、nslookup www.baidu.com 223.5.5.5 #非交互模式-使用域名解析服务器地址 查询域名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109003747422-410623248.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;十九、dig：域名查询工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、dig www.baidu.com #查询指定域名的ip&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109003838882-72933201.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、dig -x 223.5.5.5   #反向域名解析&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109004135284-571099696.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、dig -t MX www.baidu.com #查询MX类型的域名&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109004215160-1578784777.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、dig @223.5.5.5 www.baidu.com +trace #显示域名解析成IP的完整过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109004324199-430887262.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109004332583-1658259940.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、dig +nocmd +nocomment +nostat www.baidu.com #精简一些说明信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109004506692-1147527784.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 二十、host：域名查询工具&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、host www.baidu.com #域名查找&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109004555805-1788915358.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、host -a www.baidu.com #查询详细信息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109004659718-1560426067.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、host -a www.baidu.com 223.5.5.5 #直接接指定的dns服务器IP&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109004808668-1891659271.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、host -t MX www.baidu.com #指定查询类型&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109004854710-1079554839.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 二十一、nmap：网络探测工具和安全/端口扫描器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、nmap 192.168.37.9 #查看主机当前开放的端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109005735695-1068798879.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、nmap -p 1024-65535 192.168.37.9 #扫描指定的端口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109010059195-1456617820.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、nmap 192.168.37.0/24 #扫描局域网网段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109010641522-2024252910.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、nmap 192.168.37.7-9 #范围扫描&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109010610549-1917007851.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、nmap -O -sV 192.168.37.8 #探测目标主机服务和操作系统&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109010830659-1446331770.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt; 二十二、tcpdump：监听网络流量&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1、tcpdump #监视第一个网络接口下所有的数据包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109011121288-1072959282.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 2、tcpdump -i ens33 -q #-i指定端口 -q精简信息输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109011324196-2047168564.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 3、tcpdump -n host 192.168.37.8 -i ens33  #监听指定主机 -n不进行域名解析，加快显示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109011808870-1554454980.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 4、tcpdump -n src host 192.168.37.8 -i ens33  #只监听从192.168.37.8发出的数据包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109011940419-1932927913.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 5、tcpdump -n dst host 192.168.37.8 -i ens33 #只监听192.168.37.9收到数据包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109012130431-2099713318.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 6、tcpdump -nn port 22 -i ens33  #-n不进行DNS解析，但是22会换ssh，-nn彻底&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109012508464-1598554176.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 7、tcpdump -n arp -i ens33 #监听指定协议数据包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109012624869-90149072.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109012653336-517794558.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 8、tcpdump ip host 192.168.37.8 -i ens33 and ! 168.168.37.9 -i ens33  #获取主机1与除主机2外通信的所有数据包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109013423087-968790017.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt; 9、tcpdump tcp dst port 80 or scr 192.168.37.8 -i ens33 -n #抓取tcp包&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1767782/202101/1767782-20210109013220569-1421631808.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Fri, 08 Jan 2021 17:46:00 +0000</pubDate>
<dc:creator>Mrwhite86</dc:creator>
<og:description>文档目录： 一、ifconfig：配置或显示网络接口信息 二、ifup:激活网络接口 三、ifdown：禁用网络接口 四、route：显示或管理理由表 五、arp：管理系统的arp缓存 六、ip：网络</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mrwhite2020/p/14196645.html</dc:identifier>
</item>
<item>
<title>面试官：来，年轻人！请手撸5种常见限流算法！ - 浪人~</title>
<link>http://www.cnblogs.com/liqiangchn/p/14253924.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liqiangchn/p/14253924.html</guid>
<description>&lt;ol&gt;&lt;li&gt;&lt;strong&gt;瞬时流量过高，服务被压垮？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恶意用户高频光顾，导致服务器宕机？&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;消息消费过快，导致数据库压力过大，性能下降甚至崩溃？&lt;/strong&gt;&lt;br/&gt;……&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;在高并发系统中，出于系统保护角度考虑，通常会对流量进行限流；不但在工作中要频繁使用，而且也是面试中的高频考点。&lt;/p&gt;
&lt;p&gt;今天我们将图文并茂地对常见的限流算法分别进行介绍，通过各个算法的特点，给出限流算法选型的一些建议，并给出Java语言实现的代码示例。&lt;/p&gt;

&lt;p&gt;固定窗口又称固定窗口（又称计数器算法，Fixed Window）限流算法，是最简单的限流算法，通过在单位时间内维护的计数器来控制该时间单位内的最大访问量。&lt;/p&gt;
&lt;p&gt;假设限制每分钟请求量不超过60，设置一个计数器，当请求到达时如果计数器到达阈值，则拒绝请求，否则计数器加1；每分钟重置计数器为0。代码实现如下：&lt;/p&gt;
&lt;pre readability=&quot;6&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;6&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CounterRateLimiter&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyRateLimiter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; permitsPerSecond;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; timestamp = System.currentTimeMillis();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; counter;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;CounterRateLimiter&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; permitsPerSecond)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.permitsPerSecond = permitsPerSecond;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;tryAcquire&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; now = System.currentTimeMillis();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (now - timestamp &amp;lt; &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (counter &amp;lt; permitsPerSecond) {&lt;br/&gt;counter++;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;counter = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;timestamp = now;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;固定窗口最大的优点在于&lt;strong&gt;易于实现&lt;/strong&gt;；并且&lt;strong&gt;内存占用小&lt;/strong&gt;，我们只需要存储时间窗口中的计数即可；它能够确保处理更多的最新请求，不会因为旧请求的堆积导致新请求被饿死。当然也面临着&lt;strong&gt;临界问题&lt;/strong&gt;，当两个窗口交界处，瞬时流量可能为2n。&lt;/p&gt;
&lt;img src=&quot;https://source.mycookies.cn/ce661a997bb4b02df337ac567b0576e9.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;
&lt;p&gt;为了防止瞬时流量，可以把固定窗口近一步划分成多个格子，每次向后移动一小格，而不是固定窗口大小，这就是滑动窗口（Sliding Window）。&lt;/p&gt;
&lt;p&gt;比如每分钟可以分为6个10秒中的单元格，每个格子中分别维护一个计数器，窗口每次向前滑动一个单元格。每当请求到达时，只要窗口中所有单元格的计数总和不超过阈值都可以放行。TCP协议中数据包的传输，同样也是采用滑动窗口来进行流量控制。&lt;/p&gt;
&lt;img src=&quot;https://source.mycookies.cn/e64330ae253268e600f9c839a8468254.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre readability=&quot;11&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;16&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SlidingWindowRateLimiter&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyRateLimiter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; permitsPerMinute;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; TreeMap&amp;lt;Long, Integer&amp;gt; counters;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SlidingWindowRateLimiter&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; permitsPerMinute)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.permitsPerMinute = permitsPerMinute;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.counters = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;();&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;tryAcquire&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; currentWindowTime = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) / &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt; * &lt;span class=&quot;hljs-number&quot;&gt;10&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; currentWindowCount = getCurrentWindowCount(currentWindowTime);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (currentWindowCount &amp;gt;= permitsPerMinute) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;counters.merge(currentWindowTime, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, Integer::sum);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getCurrentWindowCount&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; currentWindowTime)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; startTime = currentWindowTime - &lt;span class=&quot;hljs-number&quot;&gt;50&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; result = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;Iterator&amp;lt;Map.Entry&amp;lt;Long, Integer&amp;gt;&amp;gt; iterator = counters.entrySet().iterator();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (iterator.hasNext()) {&lt;br/&gt;Map.Entry&amp;lt;Long, Integer&amp;gt; entry = iterator.next();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (entry.getKey() &amp;lt; startTime) {&lt;br/&gt;iterator.remove();&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;result += entry.getValue();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; result;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;滑动窗口解决了计数器中的瞬时流量高峰问题，其实计数器算法也是滑动窗口的一种，只不过窗口没有进行更细粒度单元的划分。对比计数器可见，当窗口划分的粒度越细，则流量控制更加精准和严格。&lt;/p&gt;
&lt;p&gt;不过当窗口中流量到达阈值时，流量会瞬间切断，在实际应用中我们要的限流效果往往不是把流量一下子掐断，而是让流量平滑地进入系统当中。&lt;/p&gt;

&lt;p&gt;如何更加平滑的限流？不妨看看漏桶算法（Leaky Bucket），请求就像水一样以任意速度注入漏桶，而桶会按照固定的速率将水漏掉；当注入速度持续大于漏出的速度时，漏桶会变满，此时新进入的请求将会被丢弃。&lt;strong&gt;限流&lt;/strong&gt;和&lt;strong&gt;整形&lt;/strong&gt;是漏桶算法的两个核心能力。&lt;/p&gt;
&lt;img src=&quot;https://source.mycookies.cn/118aff99537fa5540c283747db3efa83.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;11&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LeakyBucketRateLimiter&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyRateLimiter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; capacity;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; permitsPerSecond;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; leftWater;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; timeStamp = System.currentTimeMillis();&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;LeakyBucketRateLimiter&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; permitsPerSecond, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.capacity = capacity;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.permitsPerSecond = permitsPerSecond;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;tryAcquire&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; now = System.currentTimeMillis();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; timeGap = (now - timeStamp) / &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;;&lt;br/&gt;leftWater = Math.max(&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, leftWater - timeGap * permitsPerSecond);&lt;br/&gt;timeStamp = now;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (leftWater &amp;lt; capacity) {&lt;br/&gt;leftWater += &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这并不是一个完整的漏桶算法的实现，以上代码中只是对流量是否会被抛弃进行校验，即tryAcquire返回true表示漏桶未满，否则表示漏桶已满丢弃请求。&lt;/p&gt;
&lt;p&gt;想要以恒定的速率漏出流量，通常还应配合一个FIFO队列来实现，当tryAcquire返回true时，将请求入队，然后再以固定频率从队列中取出请求进行处理。示例代码如下：&lt;/p&gt;
&lt;pre readability=&quot;10&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;14&quot;&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Test&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;testLeakyBucketRateLimiter&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;{&lt;br/&gt;ScheduledExecutorService scheduledExecutorService = Executors.newSingleThreadScheduledExecutor();&lt;br/&gt;ExecutorService singleThread = Executors.newSingleThreadExecutor();&lt;p&gt;LeakyBucketRateLimiter rateLimiter = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; LeakyBucketRateLimiter(&lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;20&lt;/span&gt;);&lt;br/&gt;Queue&amp;lt;Integer&amp;gt; queue = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; LinkedList&amp;lt;&amp;gt;();&lt;br/&gt;singleThread.execute(() -&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; count = &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;) {&lt;br/&gt;count++;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; flag = rateLimiter.tryAcquire();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (flag) {&lt;br/&gt;queue.offer(count);&lt;br/&gt;System.out.println(count + &lt;span class=&quot;hljs-string&quot;&gt;&quot;--------流量被放行--------&quot;&lt;/span&gt;);&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;else&lt;/span&gt; {&lt;br/&gt;System.out.println(count + &lt;span class=&quot;hljs-string&quot;&gt;&quot;流量被限制&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;try&lt;/span&gt; {&lt;br/&gt;Thread.sleep((&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt;) (Math.random() * &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;));&lt;br/&gt;} &lt;span class=&quot;hljs-keyword&quot;&gt;catch&lt;/span&gt; (InterruptedException e) {&lt;br/&gt;e.printStackTrace();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;});&lt;/p&gt;&lt;p&gt;&lt;br/&gt;scheduledExecutorService.scheduleAtFixedRate(() -&amp;gt; {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (!queue.isEmpty()) {&lt;br/&gt;System.out.println(queue.poll() + &lt;span class=&quot;hljs-string&quot;&gt;&quot;被处理&quot;&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}, &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;hljs-number&quot;&gt;100&lt;/span&gt;, TimeUnit.MILLISECONDS);&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;while&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;) {&lt;br/&gt;Thread.sleep(&lt;span class=&quot;hljs-number&quot;&gt;10000&lt;/span&gt;);&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;漏桶算法存在目的主要是用来&lt;strong&gt;平滑突发的流量&lt;/strong&gt;，提供一种机制来确保网络中的突发流量被整合成平滑稳定的额流量。&lt;/p&gt;
&lt;p&gt;不过由于漏桶对流量的控制过于严格，在有些场景下&lt;strong&gt;不能充分使用系统资源&lt;/strong&gt;，因为漏桶的漏出速率是固定的，即使在某一时刻下游能够处理更大的流量，漏桶也不允许突发流量通过。&lt;/p&gt;

&lt;p&gt;如何在够限制流量速率的前提下，又能够允许突发流量呢？令牌桶算法了解一下！令牌桶算法是以恒定速率向令牌桶发送令牌，请求到达时，尝试从令牌桶中拿令牌，只有拿到令牌才能够放行，否则将会被拒绝。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://source.mycookies.cn/0233143ca414e9057a682fb8f45b5772.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;令牌桶具有以下特点：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;以恒定的速率发放令牌，假设限流速率为v/s，则表示每1/v秒发放一个令牌&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;假设令牌桶容量是b，如果令牌桶已满，则新的令牌会被丢弃&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;请求能够通过限流器的前提是令牌桶中有令牌&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;令牌桶算法中值得关注的参数有两个，即限流速率v/s，和令牌桶容量b；速率a表示限流器一般情况下的限流速率，而b则是burst的简写，表示限流器允许的最大突发流量。&lt;/p&gt;
&lt;p&gt;比如b=10，当令牌桶满的时候有10个可用令牌，此时允许10个请求同时通过限流器（&lt;strong&gt;允许流量一定程度的突发&lt;/strong&gt;），这10个请求瞬间消耗完令牌后，后续的流量只能按照速率r通过限流器。&lt;/p&gt;
&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TokenBucketRateLimiter&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyRateLimiter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; capacity;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; generatedPerSeconds;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; lastTokenTime = System.currentTimeMillis();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; currentTokens;&lt;p&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;TokenBucketRateLimiter&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; generatedPerSeconds, &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; capacity)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.generatedPerSeconds = generatedPerSeconds;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;this&lt;/span&gt;.capacity = capacity;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;tryAcquire&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; now = System.currentTimeMillis();&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (now - lastTokenTime &amp;gt;= &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt;) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; newPermits = (now - lastTokenTime) / &lt;span class=&quot;hljs-number&quot;&gt;1000&lt;/span&gt; * generatedPerSeconds;&lt;br/&gt;currentTokens = Math.min(currentTokens + newPermits, capacity);&lt;br/&gt;lastTokenTime = now;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (currentTokens &amp;gt; &lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;) {&lt;br/&gt;currentTokens--;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要主意的是，非常容易被想到的实现是生产者消费者模式；用一个生产者线程定时向阻塞队列中添加令牌，而试图通过限流器的线程则作为消费者线程，只有从阻塞队列中获取到令牌，才允许通过限流器。&lt;/p&gt;
&lt;p&gt;由于&lt;strong&gt;线程调度的不确定性&lt;/strong&gt;，在高并发场景时，定时器误差非常大，同时定时器本身会创建调度线程，也会对&lt;strong&gt;系统的性能&lt;/strong&gt;产生影响。&lt;/p&gt;

&lt;p&gt;滑动日志是一个比较“冷门”，但是确实好用的限流算法。滑动日志限速算法需要记录请求的时间戳，通常使用&lt;strong&gt;有序集合&lt;/strong&gt;来存储，我们可以在单个有序集合中跟踪用户在一个时间段内所有的请求。&lt;/p&gt;
&lt;p&gt;假设我们要限制给定T时间内的请求不超过N，我们只需要存储最近T时间之内的请求日志，每当请求到来时判断最近T时间内的请求总数是否超过阈值。&lt;/p&gt;
&lt;img src=&quot;https://source.mycookies.cn/b61b924418cc50f07e8dc22569dff946.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre readability=&quot;8.5&quot;&gt;
&lt;code class=&quot;java language-java hljs&quot; readability=&quot;11&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;SlidingLogRateLimiter&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;MyRateLimiter&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; PERMITS_PER_MINUTE = &lt;span class=&quot;hljs-number&quot;&gt;60&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;final&lt;/span&gt; TreeMap&amp;lt;Long, Integer&amp;gt; requestLogCountMap = &lt;span class=&quot;hljs-keyword&quot;&gt;new&lt;/span&gt; TreeMap&amp;lt;&amp;gt;();&lt;p&gt;&lt;span class=&quot;hljs-meta&quot;&gt;@Override&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;synchronized&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;tryAcquire&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; currentTimestamp = LocalDateTime.now().toEpochSecond(ZoneOffset.UTC);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; currentWindowCount = getCurrentWindowCount(currentTimestamp);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;if&lt;/span&gt; (currentWindowCount &amp;gt;= PERMITS_PER_MINUTE) {&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;false&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;requestLogCountMap.merge(currentTimestamp, &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;, Integer::sum);&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;true&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-function&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;getCurrentWindowCount&lt;/span&gt;&lt;span class=&quot;hljs-params&quot;&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; currentTime)&lt;/span&gt; &lt;/span&gt;{&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;long&lt;/span&gt; startTime = currentTime - &lt;span class=&quot;hljs-number&quot;&gt;59&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;return&lt;/span&gt; requestLogCountMap.entrySet()&lt;br/&gt;.stream()&lt;br/&gt;.filter(entry -&amp;gt; entry.getKey() &amp;gt;= startTime)&lt;br/&gt;.mapToInt(Map.Entry::getValue)&lt;br/&gt;.sum();&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;滑动日志能够避免突发流量，实现较为精准的限流；同样&lt;strong&gt;更加灵活，能够支持更加复杂的限流策略&lt;/strong&gt;，如多级限流，每分钟不超过100次，每小时不超过300次，每天不超过1000次，我们只需要保存最近24小时所有的请求日志即可实现。&lt;/p&gt;
&lt;p&gt;灵活并不是没有代价的，带来的缺点就是&lt;strong&gt;占用存储空间要高于其他限流算法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;以上几种限流算法的实现都仅适合单机限流。虽然给每台机器平均分配限流配额可以达到限流的目的，但是由于机器性能，流量分布不均以及计算数量动态变化等问题，单机限流在分布式场景中的效果总是差强人意。&lt;/p&gt;
&lt;p&gt;分布式限流最简单的实现就是利用中心化存储，即将单机限流存储在本地的数据存储到同一个存储空间中，如常见的Redis等。&lt;/p&gt;
&lt;img src=&quot;https://source.mycookies.cn/9fab6c78c24591cf0302d07336d4d943.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;&lt;p&gt;当然也可以从上层流量入口进行限流，Nginx代理服务就提供了限流模块，同样能够实现高性能，精准的限流，其底层是漏桶算法。&lt;/p&gt;
&lt;img src=&quot;https://source.mycookies.cn/e4ea7049b473909f26758f3b0a543b50.jpg&quot; alt=&quot;&quot; title=&quot;&quot;/&gt;
&lt;ol readability=&quot;11&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;固定窗口算法实现简单，性能高，但是会有临界突发流量问题，瞬时流量最大可以达到阈值的2倍。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;为了解决临界突发流量，可以将窗口划分为多个更细粒度的单元，每次窗口向右移动一个单元，于是便有了滑动窗口算法。&lt;/p&gt;
&lt;p&gt;滑动窗口当流量到达阈值时会瞬间掐断流量，所以导致流量不够平滑。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;想要达到限流的目的，又不会掐断流量，使得流量更加平滑？可以考虑漏桶算法！需要注意的是，漏桶算法通常配置一个FIFO的队列使用以达到允许限流的作用。&lt;/p&gt;
&lt;p&gt;由于速率固定，即使在某个时刻下游处理能力过剩，也不能得到很好的利用，这是漏桶算法的一个短板。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;限流和瞬时流量其实并不矛盾，在大多数场景中，短时间突发流量系统是完全可以接受的。令牌桶算法就是不二之选了，令牌桶以固定的速率v产生令牌放入一个固定容量为n的桶中，当请求到达时尝试从桶中获取令牌。&lt;/p&gt;
&lt;p&gt;当桶满时，允许最大瞬时流量为n；当桶中没有剩余流量时则限流速率最低，为令牌生成的速率v。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;3&quot;&gt;
&lt;p&gt;如何实现更加灵活的多级限流呢？滑动日志限流算法了解一下！这里的日志则是请求的时间戳，通过计算制定时间段内请求总数来实现灵活的限流。&lt;/p&gt;
&lt;p&gt;当然，由于需要存储时间戳信息，其占用的存储空间要比其他限流算法要大得多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;不管黑猫白猫，能抓到老鼠的就是好猫。限流算法并没有绝对的好劣之分，如何选择合适的限流算法呢？不妨从性能，&lt;strong&gt;是否允许超出阈值&lt;/strong&gt;，&lt;strong&gt;落地成本&lt;/strong&gt;，&lt;strong&gt;流量平滑度&lt;/strong&gt;，&lt;strong&gt;是否允许突发流量&lt;/strong&gt;以及&lt;strong&gt;系统资源&lt;/strong&gt;大小限制多方面考虑。&lt;/p&gt;
&lt;p&gt;当然，市面上也有比较成熟的限流工具和框架。如Google出品的&lt;strong&gt;Guava&lt;/strong&gt;中基于令牌桶实现的限流组件，拿来即用；以及alibaba开源的面向分布式服务架构的流量控制框架&lt;strong&gt;Sentinel&lt;/strong&gt;更会让你爱不释手，它是基于滑动窗口实现的。&lt;a href=&quot;https://github.com/liqianggh/liqiang-learning/tree/master/java/src/main/java/cn/mycookies/ratelimiter&quot;&gt;「本文代码地址」&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;看后点赞，养成习惯！本次分享就到这里，我们下期见！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;http://source.mycookies.cn/202002212337_444.png?ERROR&quot; alt=&quot;img&quot; title=&quot;img&quot;/&gt;img</description>
<pubDate>Fri, 08 Jan 2021 17:11:00 +0000</pubDate>
<dc:creator>浪人~</dc:creator>
<og:description>填坑限流算法！练就计数器，滑动窗口，令牌桶，漏桶，滑动日志五毒神掌。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/liqiangchn/p/14253924.html</dc:identifier>
</item>
<item>
<title>Java并发包源码学习系列：AQS共享式与独占式获取与释放资源的区别 - 天乔巴夏丶</title>
<link>http://www.cnblogs.com/summerday152/p/14253917.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/summerday152/p/14253917.html</guid>
<description>&lt;p&gt;往期回顾：&lt;/p&gt;
&lt;p&gt;上一篇文章介绍了AQS内置队列节点的出队入队操作，以及独占式获取共享资源与释放资源的详细流程，为了结构完整，本篇继续以AQS的角度介绍另外一种：共享模式获取与释放资源的细节，本篇暂不分析具体子类如ReentrantLock、ReentrantReadWriteLock的实现，之后会陆续补充。&lt;/p&gt;
&lt;h2 id=&quot;独占式获取资源&quot;&gt;独占式获取资源&lt;/h2&gt;
&lt;blockquote readability=&quot;6.383631713555&quot;&gt;
&lt;p&gt;友情提示：本篇文章着重介绍共享模式获取和释放资源的特点，许多代码实现上面和共享式和独占式其实逻辑差不多，为了清晰对比，这边会将独占式的部分核心代码粘贴过来，注意理解共享式和独占式存在差异的地方。详细解析可戳：&lt;a href=&quot;https://blog.csdn.net/Sky_QiaoBa_Sum/article/details/112301359&quot; target=&quot;_blank&quot;&gt;Java并发包源码学习系列：CLH同步队列及同步资源获取与释放&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;void-acquireint-arg&quot;&gt;void acquire(int arg)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public final void acquire(int arg) {
        if (!tryAcquire(arg) &amp;amp;&amp;amp; // tryAcquire由子类实现，表示获取锁，如果成功，这个方法直接返回了
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) // 如果获取失败，执行
            selfInterrupt();
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;boolean-acquirequeuednode-int&quot;&gt;boolean acquireQueued(Node, int)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    // 这个方法如果返回true，代码将进入selfInterrupt()
        final boolean acquireQueued(final Node node, int arg) {
        // 注意默认为true
        boolean failed = true;
        try {
            // 是否中断
            boolean interrupted = false;
            // 自旋，即死循环
            for (;;) {
                // 得到node的前驱节点
                final Node p = node.predecessor();
                // 我们知道head是虚拟的头节点，p==head表示如果node为阻塞队列的第一个真实节点
                // 就执行tryAcquire逻辑，这里tryAcquire也需要由子类实现
                if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                    // tryAcquire获取成功走到这，执行setHead出队操作 
                    setHead(node);
                    p.next = null; // help GC
                    failed = false;
                    return interrupted;
                }
                // 走到这有两种情况 1.node不是第一个节点 2.tryAcquire争夺锁失败了
                // 这里就判断 如果当前线程争锁失败，是否需要挂起当前这个线程
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            // 死循环退出，只有tryAcquire获取锁失败的时候failed才为true
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;独占式释放资源&quot;&gt;独占式释放资源&lt;/h2&gt;
&lt;h3 id=&quot;boolean-releaseint-arg&quot;&gt;boolean release(int arg)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public final boolean release(int arg) {
        if (tryRelease(arg)) { // 子类实现tryRelease方法
            // 获得当前head
            Node h = head;
            // head不为null并且head的等待状态不为0
            if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
                // 唤醒下一个可以被唤醒的线程，不一定是next哦
                unparkSuccessor(h);
            return true;
        }
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;void-unparksuccessornode-node&quot;&gt;void unparkSuccessor(Node node)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;       private void unparkSuccessor(Node node) {
        /*
         * If status is negative (i.e., possibly needing signal) try
         * to clear in anticipation of signalling.  It is OK if this
         * fails or if status is changed by waiting thread.
         */
        int ws = node.waitStatus;
        // 如果node的waitStatus&amp;lt;0为signal，CAS修改为0
        // 将 head 节点的 ws 改成 0，清除信号。表示，他已经释放过了。不能重复释放。
        if (ws &amp;lt; 0)
            compareAndSetWaitStatus(node, ws, 0);

        /*
         * Thread to unpark is held in successor, which is normally
         * just the next node.  But if cancelled or apparently null,
         * traverse backwards from tail to find the actual
         * non-cancelled successor.
         */
        // 唤醒后继节点，但是有可能后继节点取消了等待 即 waitStatus == 1
        Node s = node.next;
        // 如果后继节点为空或者它已经放弃锁了
        if (s == null || s.waitStatus &amp;gt; 0) {
            s = null;
            // 从队尾往前找，找到没有没取消的所有节点排在最前面的【直到t为null或t==node才退出循环嘛】
            for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
                // 如果&amp;gt;0表示节点被取消了，就一直向前找呗，找到之后不会return，还会一直向前
                if (t.waitStatus &amp;lt;= 0)
                    s = t;
        }
        // 如果后继节点存在且没有被取消，会走到这，直接唤醒后继节点即可
        if (s != null)
            LockSupport.unpark(s.thread);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;共享式获取资源&quot;&gt;共享式获取资源&lt;/h2&gt;
&lt;h3 id=&quot;void-acquiresharedint-arg&quot;&gt;void acquireShared(int arg)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public final void acquireShared(int arg) {
        if (tryAcquireShared(arg) &amp;lt; 0) //子类实现
            doAcquireShared(arg);
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;tryAcquireShared(int)&lt;/code&gt;是AQS提供给子类实现的钩子方法，子类可以自定义实现&lt;strong&gt;共享式获取资源&lt;/strong&gt;的方式，获取状态失败返回小于0，返回零值表示被独占方式获取，返回正值表示共享方式获取。&lt;/li&gt;
&lt;li&gt;如果获取失败，则进入&lt;code&gt;doAcquireShared(arg);&lt;/code&gt;的逻辑。&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;void-doacquiresharedint-arg&quot;&gt;void doAcquireShared(int arg)&lt;/h3&gt;
&lt;p&gt;注意这里和独占式获取资源&lt;code&gt;acquireQueued&lt;/code&gt;的区别。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private void doAcquireShared(int arg) {
        // 包装成共享模式的节点，入队
        final Node node = addWaiter(Node.SHARED);
        boolean failed = true;
        try {
            boolean interrupted = false;
            // 自旋
            for (;;) {
                final Node p = node.predecessor();
                if (p == head) {
                    // 尝试获取同步状态，子类实现
                    int r = tryAcquireShared(arg);
                    if (r &amp;gt;= 0) {
                        // 设置新的首节点，并根据条件，唤醒下一个节点
                        setHeadAndPropagate(node, r);
                        p.next = null; // help GC
                        if (interrupted)
                            selfInterrupt();
                        failed = false;
                        return;
                    }
                }
                if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                    interrupted = true;
            }
        } finally {
            if (failed)
                cancelAcquire(node);
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到有几个存在差异的地方：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;在共享式获取资源失败的时候，会包装成SHARED模式的节点入队。&lt;/li&gt;
&lt;li&gt;如果前驱节点为head，则使用tryAcquireShared方法尝试获取同步状态，这个方法由子类实现。&lt;/li&gt;
&lt;li&gt;如果获取成功r&amp;gt;=0，这时调用&lt;code&gt;setHeadAndPropagate(node, r)&lt;/code&gt;，该方法首先会设置新的首节点，将第一个节点出队，接着会不断唤醒下一个共享模式节点，实现同步状态被多个线程共享获取。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;接下来我们着重看下setHeadAndPropagate方法。&lt;/p&gt;
&lt;h3 id=&quot;void-setheadandpropagatenode-node-int-propagate&quot;&gt;void setHeadAndPropagate(Node node, int propagate)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private void setHeadAndPropagate(Node node, int propagate) {
        Node h = head; // Record old head for check below
        // 节点出队，设置node为新的head
        setHead(node);
        /*
         * Try to signal next queued node if:
         *   Propagation was indicated by caller,
         *     or was recorded (as h.waitStatus either before
         *     or after setHead) by a previous operation
         *     (note: this uses sign-check of waitStatus because
         *      PROPAGATE status may transition to SIGNAL.)
         * and
         *   The next node is waiting in shared mode,
         *     or we don't know, because it appears null
         *
         * The conservatism in both of these checks may cause
         * unnecessary wake-ups, but only when there are multiple
         * racing acquires/releases, so most need signals now or soon
         * anyway.
         */
        // 这个方法进来的时候propagate&amp;gt;=0
        // propagate&amp;gt;0表示同步状态还可以被后面的节点获取
        // h指向原先的head节点，之后h = head，h表示新的head节点
        // h.waitStatus&amp;lt;0表示该节点后面还有节点需要被唤醒
        if (propagate &amp;gt; 0 || h == null || h.waitStatus &amp;lt; 0 ||
            (h = head) == null || h.waitStatus &amp;lt; 0) {
            // 获取下一个节点
            Node s = node.next;
            // 没有下一个节点或下一个节点为共享式获取状态
            if (s == null || s.isShared())
                // 唤醒后续的共享式获取同步状态的节点
                doReleaseShared();
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;先记录一下原来的头节点，然后设置node为新的头节点。&lt;/li&gt;
&lt;li&gt;原先的头节点或新的头节点等待状态是propagate或signal，可以继续向下唤醒。&lt;/li&gt;
&lt;li&gt;如果判断下个节点为shared节点，调用共享式释放资源方法唤醒后续节点。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;共享式释放资源&quot;&gt;共享式释放资源&lt;/h2&gt;
&lt;h3 id=&quot;boolean-releasesharedint-arg&quot;&gt;boolean releaseShared(int arg)&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    public final boolean releaseShared(int arg) {
        if (tryReleaseShared(arg)) { // 子类实现
            doReleaseShared();
            return true;
        }
        return false;
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;doreleaseshared&quot;&gt;doReleaseShared()&lt;/h3&gt;
&lt;p&gt;可以发现共享模式下，无论是获取资源还是释放资源都调用了doReleaseShared方法，可见该方法是共享模式释放资源唤醒节点的核心方法，主要功能是&lt;strong&gt;唤醒下一个线程或者设置传播状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;后继线程被唤醒后，会尝试获取共享锁，如果成功之后，则又会调用setHeadAndPropagate,将唤醒传播下去。这个方法的作用是保障在acquire和release存在竞争的情况下，保证队列中处于等待状态的节点能够有办法被唤醒。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;    private void doReleaseShared() {
        /*
         * Ensure that a release propagates, even if there are other
         * in-progress acquires/releases.  This proceeds in the usual
         * way of trying to unparkSuccessor of head if it needs
         * signal. But if it does not, status is set to PROPAGATE to
         * ensure that upon release, propagation continues.
         * Additionally, we must loop in case a new node is added
         * while we are doing this. Also, unlike other uses of
         * unparkSuccessor, we need to know if CAS to reset status
         * fails, if so rechecking.
         */
        // 自旋
        for (;;) {
            Node h = head;
            // 队列已经初始化且至少有一个节点
            if (h != null &amp;amp;&amp;amp; h != tail) {
                int ws = h.waitStatus;
                // 无论是独占还是共享，只有节点的ws为signal的时候，才会在释放的时候，唤醒后面的节点
                if (ws == Node.SIGNAL) {
                    // cas将ws设置为0，设置失败，将会继续从循环开始
                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                        continue;            // loop to recheck cases
                    // 唤醒后继节点，unparkSuccessor这个方法上面已经解析过
                    unparkSuccessor(h);
                }
                // 如果ws为0，则更新状态为propagate，
                // 之后setHeadAndPropagate读到ws&amp;lt;0的时候，会继续唤醒后面节点
                else if (ws == 0 &amp;amp;&amp;amp;
                         !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                    continue;                // loop on failed CAS
            }
            // 如果head在这个过程中被更改了，会继续自旋
            if (h == head)                   // loop if head changed
                break;
        }
    }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该方法在 head 节点存在后继节点的情况下，做了两件事情：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果 head 节点等待状态为 SIGNAL，则将 head 节点状态设为 0，并唤醒后继未取消节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;如果 head 节点等待状态为 0，则将 head 节点状态设为 PROPAGATE，保证唤醒能够正常传播下去。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;设置PROPAGATE的作用&lt;/strong&gt;：PROPAGATE状态用在[setHeadAndPropagate](#void setHeadAndPropagate(Node node, int propagate)) ,当头节点状态被设为 PROPAGATE 后，后继节点成为新的头结点后。若 &lt;code&gt;propagate &amp;gt; 0&lt;/code&gt; 条件不成立，则根据条件&lt;code&gt;h.waitStatus &amp;lt; 0&lt;/code&gt;成立与否，来决定是否唤醒后继节点，即向后传播唤醒动作。&lt;/p&gt;
&lt;p&gt;引入PROPAGATE是为了解决什么问题？&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/micrari/p/6937995.html&quot; target=&quot;_blank&quot;&gt;AbstractQueuedSynchronizer源码解读&lt;/a&gt;，强烈建议阅读这篇博客。&lt;/p&gt;
&lt;h2 id=&quot;独占式和共享式的区别总结&quot;&gt;独占式和共享式的区别总结&lt;/h2&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;共享式获取与独占式获取最大的区别就是同一时刻能否有多个线程同时获取到同步状态。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;共享式访问资源时，同一时刻其他共享式的访问会被允许。&lt;/li&gt;
&lt;li&gt;独占式访问资源时，同一时刻其他访问均被阻塞。&lt;/li&gt;
&lt;/ul&gt;&lt;/blockquote&gt;
&lt;p&gt;AQS都提供了子类实现的钩子方法，独占式的代表方法有：tryAcquire和tryRelease以及isHeldExclusively方法，共享式的代表方法有：tryAcquireShared和tryReleaseShared方法。&lt;/p&gt;
&lt;p&gt;AQS中获取操作和释放操作的标准形式：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;boolean acquire() throws InterruptedException{
    while( 当前状态不允许获取操作 ){
        if( 需要阻塞获取请求){
            如果当前线程不在队列中，则将其插入队列
            阻塞当前线程
        }else{
            返回失败
        }
    }
    可能更新同步器的状态
    如果线程位于队列中，则将其移除队列
    返回成功
}

void release(){
    更新同步器的状态
    if( 新的状态允许某个被阻塞的线程获取成功 ){
        解除队列中一个或多个线程的阻塞状态
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;图源：《并发编程的艺术》下图是独占式同步状态获取的流程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1771072/202101/1771072-20210109005143233-576068560.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当某个线程争夺同步资源失败之后，他们都会将线程包装为节点，并加入CLH同步队列的队尾，并保持自旋，一个是&lt;code&gt;addWaiter(Node.EXCLUSIVE)&lt;/code&gt;，一个是&lt;code&gt;addWaiter(Node.EXCLUSIVE)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同步队列中的线程在自旋时会判断其前驱节点是否为首节点，如果是首节点&lt;code&gt;node.predecessor() == head&lt;/code&gt;，他们都会尝试获取同步状态，只不过：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;独占式获取状态成功后，只会出队一个节点。&lt;/li&gt;
&lt;li&gt;共享式获取状态成功后，除了出队一个节点，还会唤醒后面的节点。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;线程执行完逻辑之后，他们都会释放同步状态，释放之后将会&lt;code&gt;unparkSuccessor(h)&lt;/code&gt;唤醒其后可被唤醒的某个后继节点。&lt;/p&gt;
&lt;h2 id=&quot;参考阅读&quot;&gt;参考阅读&lt;/h2&gt;
</description>
<pubDate>Fri, 08 Jan 2021 16:53:00 +0000</pubDate>
<dc:creator>天乔巴夏丶</dc:creator>
<og:description>Java并发包源码学习系列：AQS共享模式获取与释放资源 往期回顾： Java并发包源码学习系列：AbstractQueuedSynchronizer Java并发包源码学习系列：CLH同步队列及同步</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/summerday152/p/14253917.html</dc:identifier>
</item>
<item>
<title>[每日一题]面试官问：for in和for of 的区别和原理？ - saucxs</title>
<link>http://www.cnblogs.com/chengxs/p/14253898.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chengxs/p/14253898.html</guid>
<description>&lt;p&gt;关注「松宝写代码」，精选好文，每日一题&lt;/p&gt;
&lt;p&gt;​时间永远是自己的&lt;/p&gt;
&lt;p&gt;每分每秒也都是为自己的将来铺垫和增值&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;作者：saucxs ｜ songEagle&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、前言&quot;&gt;一、前言&lt;/h2&gt;
&lt;p&gt;2020.12.23 日刚立的 flag，每日一题，题目类型不限制，可以是：算法题，面试题，阐述题等等。&lt;/p&gt;
&lt;p&gt;本文是「每日一题」第 7 题：[每日一题]面试官问：for in和for of 的区别和原理？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/saucxs/full_stack_knowledge_list/master/daily-question/daily_question.png&quot; alt=&quot;每日一题&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;往期「每日一题」：&lt;/p&gt;
&lt;h2 id=&quot;二、for-in和for-of-的区别和原理？&quot;&gt;二、for in和for of 的区别和原理？&lt;/h2&gt;
&lt;p&gt;这个题目本身不是特别难，只能说是作为社招的基础面试题，但是如果想回答好这道题也不是很容易。&lt;/p&gt;
&lt;p&gt;不信接着往下看：&lt;/p&gt;
&lt;h3 id=&quot;1、简单回答&quot;&gt;1、简单回答&lt;/h3&gt;
&lt;p&gt;很多人会去问：for in 和for of的区别，&lt;/p&gt;
&lt;p&gt;我说：for in是获取属性名，for of获取属性值。&lt;/p&gt;
&lt;h3 id=&quot;2、看一些例子&quot;&gt;2、看一些例子&lt;/h3&gt;
&lt;p&gt;首先我们先看一个对象遍历的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var obj = {name: 'saucxs',age: 21,sex: 1};
for(key in obj){
    console.log(key, obj[key]);
    // name saucxs
    // age 21
    // sex 1
}
for(key of obj){
    console.log(key, obj[key]);
    // typeError :obj is not iterable报错
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说明obj对象没有iterable属性报错，使用不了for of。&lt;/p&gt;
&lt;p&gt;我们现在再看一个数组遍历的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var array = ['a','b','c'];
for(var key in array){
    console.log(key, array[key]);
    // 0 a
    // 1 b
    // 2 c
}
for(var key of array){
    console.log(key, array[key]);
    // a undefined
    // b undefined
    // c undefined
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这回没有报错，为什么呢？&lt;/p&gt;
&lt;p&gt;我们再看一个例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var array = ['a', 'b', 'c'];
array.name = 'saucxs'
for(key in array){
    console.log(key, array[key])
    // 0 a
    // 1 b
    // 2 c
    // name saucxs
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;3、for-in的特点&quot;&gt;3、for in的特点&lt;/h3&gt;
&lt;p&gt;for in 循环返回的值都是数据结构的&lt;strong&gt;键名&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;遍历对象返回的是对象的key值，遍历数组返回的是数组的下标。&lt;/p&gt;
&lt;p&gt;还会遍历原型上的值和手动添加的值&lt;/p&gt;
&lt;p&gt;总的来说：for in适合遍历对象。&lt;/p&gt;
&lt;h3 id=&quot;4、for-of的特点&quot;&gt;4、for of的特点&lt;/h3&gt;
&lt;p&gt;for of 循环获取一对键值中的&lt;strong&gt;键值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，可以使用for of。&lt;/p&gt;
&lt;p&gt;for of不同于forEach，for of是可以break，continue，return配合使用，for of 循环可以随时退出循环。&lt;/p&gt;
&lt;p&gt;总的来说：for of遍历所有数据结构的统一接口。&lt;/p&gt;
&lt;h3 id=&quot;5、深入探索&quot;&gt;5、深入探索&lt;/h3&gt;
&lt;p&gt;哪些数据结构部署了Symbol.iterator属性？&lt;/p&gt;
&lt;p&gt;以下数据结构的有iterator接口的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;数组Array&lt;/li&gt;
&lt;li&gt;Map&lt;/li&gt;
&lt;li&gt;Set&lt;/li&gt;
&lt;li&gt;String&lt;/li&gt;
&lt;li&gt;arguments对象&lt;/li&gt;
&lt;li&gt;Nodelist对象，类数组&lt;br/&gt;凡是部署了iterator接口的数据结构都可以使用数组的扩展运算符(...)，和解构赋值等操作。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如果我非常想让对象用for of？&lt;/p&gt;
&lt;p&gt;可以使用Object.keys()获取对象的key值集合，在用for of。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;var obj = {name: 'saucxs',age: 18, sex: 1};
for(var key of Object.keys(obj)){
    console.log(key, obj[key]);
    // name saucxs
    // age 21
    // sex 1
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样也可以给一个对象部署Symbol.iterator属性。&lt;/p&gt;
&lt;h2 id=&quot;各种福利&quot;&gt;各种福利&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/saucxs/full_stack_knowledge_list/master/daily-question/dongtai.gif&quot; alt=&quot;松宝写代码&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;「松宝写代码」：开发知识体系构建，技术分享，项目实战，实验室，每日一题，带你一起学习新技术，总结学习过程，让你进阶到高级资深工程师，学习项目管理，思考职业发展，生活感悟，充实中成长起来。问题或建议，请公众号留言。&lt;/p&gt;
&lt;h4 id=&quot;1、字节内推福利&quot;&gt;1、字节内推福利&lt;/h4&gt;
&lt;p&gt;回复「校招」获取内推码&lt;/p&gt;
&lt;p&gt;回复「社招」获取内推&lt;/p&gt;
&lt;p&gt;回复「实习生」获取内推&lt;/p&gt;
&lt;p&gt;后续会有更多福利&lt;/p&gt;
&lt;h4 id=&quot;2、学习资料福利&quot;&gt;2、学习资料福利&lt;/h4&gt;
&lt;p&gt;回复「算法」获取算法学习资料&lt;/p&gt;
&lt;h4 id=&quot;3、每日一题&quot;&gt;3、每日一题&lt;/h4&gt;
</description>
<pubDate>Fri, 08 Jan 2021 16:23:00 +0000</pubDate>
<dc:creator>saucxs</dc:creator>
<og:description>关注「松宝写代码」，精选好文，每日一题 ​时间永远是自己的 每分每秒也都是为自己的将来铺垫和增值 作者：saucxs ｜ songEagle 一、前言 2020.12.23 日刚立的 flag，每日一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/chengxs/p/14253898.html</dc:identifier>
</item>
<item>
<title>JAVA_基础反射机制 - BeautifulGirl230</title>
<link>http://www.cnblogs.com/BeautifulGirl230/p/14253822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/BeautifulGirl230/p/14253822.html</guid>
<description>&lt;h2 id=&quot;java反射机制概述&quot;&gt;Java反射机制概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Reflection&lt;/code&gt;（反射）是被视为动态语言的关键，反射机制允许程序在执行期 借助于&lt;code&gt;Reflection API&lt;/code&gt;取得任何类的内部信息，并能直接操作任意对象的内 部属性及方法。&lt;/p&gt;
&lt;p&gt;加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射。&lt;/p&gt;
&lt;p&gt;正常方式： 引入需要的包名称 → 通过new实例化对象 → 取得实例化对象&lt;br/&gt;反射方式： 通过实例化对象 → getClass()方法 → 得到完整的包名称&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Java反射机制提供的功能&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在运行时判断任意一个对象所属的类。&lt;/li&gt;
&lt;li&gt;在运行时构造任意一个类的对象。&lt;/li&gt;
&lt;li&gt;在运行时判断任意一个类所具有的成员变量和方法。&lt;/li&gt;
&lt;li&gt;在运行时获取泛型信息。&lt;/li&gt;
&lt;li&gt;在运行时调用任意一个对象的成员变量和方法。&lt;/li&gt;
&lt;li&gt;在运行时处理注解。&lt;/li&gt;
&lt;li&gt;生成动态代理。&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class Person {
    private String name;
    public int age;
    public void show() {
        System.out.println(&quot;您好！世界&quot;);
    }
    private String showNation(String nation){
        System.out.println(&quot;我的国际是：&quot; + nation);
        return nation;
    }
    private Person(String name) {
        this.name = name;
    }
        .....
}
public void test2() throws Exception {
    Class clazz = Person.class;
    // 1.通过反射，创建Person类的对象
    Constructor cons = clazz.getConstructor(String.class, int.class);
    Object obj = cons.newInstance(&quot;Tom&quot;, 12);
    Person p = (Person) obj;
    System.out.println(p.toString());
    // 2.通过反射，调用指定的属性、方法、对象
    // 调属性
    Field age = clazz.getDeclaredField(&quot;age&quot;);
    age.set(p,10);
    System.out.println(p.toString());
    // 调方法
    Method method = clazz.getDeclaredMethod(&quot;show&quot;);
    method.invoke(p);
    // 通过反射是可以调用私有的属性、方法、构造器
    // 调用私有构造器
    Constructor cons1 = clazz.getDeclaredConstructor(String.class);
    cons1.setAccessible(true);
    Person p1 = (Person) cons1.newInstance(&quot;Jerry&quot;);
    System.out.println(p1);
    // 调用私有方法
    Field name = clazz.getDeclaredField(&quot;name&quot;);
    name.setAccessible(true);
    name.set(p1,&quot;Han&quot;);
    System.out.println(p1);
    // 调用私有方法
    Method method1 = clazz.getDeclaredMethod(&quot;showNation&quot;, String.class);
    method1.setAccessible(true);
    String invoke = (String) method1.invoke(p1, &quot;中国&quot;);
    System.out.println(invoke);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;javalangclass类的理解&quot;&gt;java.lang.Class类的理解&lt;/h2&gt;
&lt;ol&gt;&lt;li&gt;类的加载过程：程序经过java.exe命令以后，会生成一个或多个字节码文件（.class），接着使用java.exe命令对字节码进行解释运行。相当与将某个字节码文件加载到内存中，此过程称为类的加载。加载到内存中的类，我们称之为运行时类，此运行时类，就作为Class的一个实例。&lt;/li&gt;
&lt;li&gt;Class的实例就是对应着一个运行时类。&lt;/li&gt;
&lt;li&gt;加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同方式来获取从运行时类。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 获取Class的实例的方法
public void test3() throws ClassNotFoundException {
    // 方式一：调用运行时类的属性.class
    Class clazz1 = Person.class;
    // 方式二：通过运行时类的对象
    Person person = new Person();
    Class clazz2 = person.getClass();
    // 方法三：调用Class的静态方法forName(String classPath)
    Class clazz3 = Class.forName(&quot;com.tyt.java.Person&quot;);
    // 方式四：类的加载器 ClassLoader
    ClassLoader classLoader = ReflectionTest.class.getClassLoader();
    Class clazz4 = classLoader.loadClass(&quot;com.tyt.java.Person&quot;);
    System.out.println(clazz1 == clazz2);
    System.out.println(clazz2 == clazz3);
    System.out.println(clazz3 == clazz4);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;class实例可以是那些结构的说明：&quot;&gt;Class实例可以是那些结构的说明：&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void test5() {
    Class c1 = Object.class;
    Class c2 = Comparable.class;
    Class c3 = String[].class;
    Class c4 = int[][].class;
    Class c5 = ElementType.class;
    Class c6 = Override.class;
    Class c7 = int.class;
    Class c8 = void.class;
    Class c9 = Class.class;

    int[] a = new int[10];
    int[] b = new int[100];
    Class c10 = a.getClass();
    Class c11 = b.getClass();
    // 只要数组元素类型与维度一样，就是同一个Class
    System.out.println(c10 == c11);// true
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用properties：用于读取配置文件。&quot;&gt;使用Properties：用于读取配置文件。&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 目录结构
// |--module
// |---stc
// |----com.tyt.java
// |-----PropertiesTest.java
// |-----jdbc1.properties
// |--jdbc.properties
public void test2() {
    String user = null;
    String passwored = null;
    FileInputStream inputStream = null;
    try {
        Properties properties = new Properties();
        // 读取配置方式一：
        // inputStream = new FileInputStream(&quot;jdbc.properties&quot;);
        // properties.load(inputStream);
        // 读取配置方式二：使用ClassLoader
        // 配置文件默认识别为：当前module的src下
        ClassLoader classLoader = ClassLoaderTest.class.getClassLoader();
        InputStream inputStream1 = classLoader.getResourceAsStream(&quot;jdbc1.properties&quot;);
        properties.load(inputStream1);
        user = properties.getProperty(&quot;user&quot;);
        passwored = properties.getProperty(&quot;passwored&quot;);
        System.out.println(&quot;user = &quot; + user + &quot;,passwored = &quot; + passwored);
    } catch (IOException e) {
        e.printStackTrace();
    } finally {
        if (inputStream != null) {
            try {
                inputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 08 Jan 2021 15:42:00 +0000</pubDate>
<dc:creator>BeautifulGirl230</dc:creator>
<og:description>Java反射机制概述 Reflection（反射）是被视为动态语言的关键，反射机制允许程序在执行期 借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内 部属性及方法。 加</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/BeautifulGirl230/p/14253822.html</dc:identifier>
</item>
<item>
<title>Docker进行MySQL主从复制操作 - 颜值六毛六</title>
<link>http://www.cnblogs.com/yumq/p/14253812.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yumq/p/14253812.html</guid>
<description>&lt;blockquote readability=&quot;2.7777777777778&quot;&gt;
&lt;p&gt;Docker的相关操作 与 Docker下MySQL容器的安装&lt;br/&gt;&lt;a href=&quot;https://www.cnblogs.com/yumq/p/14253360.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/yumq/p/14253360.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本次实验我是在单机状态下进行mysql的主从复制，和多机的原理一样&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;相关参数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-txt&quot;&gt;--name 容器的名称命名
-p 暴露端口,端口的映射 上述是本机的3307端口映射到容器内的3306端口,访问本机3307就能访问容器内的数据库(3306端口)
--privileged=true 赋予容器内以root用户来操作
-it 交互运行 
--hostname docker1 容器内hostname,我是为了区分docker添加的,如果用不到可以去掉
 
-e MYSQL_ROOT_PASSWORD=123456 环境参数配置,配置mysql root角色的密码
-e MYSQL_DATABASE=ymq 创建一个ymq的数据库,用不到的可以删除掉
-e MYSQL_USER=user 
-e MYSQL_PASSWORD=pass
`-v 非常重要,相当于docker容器的宝贵文件(相关配置,相关数据,相关日志)存放到容器外(即云服务器中),这样做的目的是不把数据放在容器内,保障数据安全`
-v /home/mysql/docker-data/3307/conf:/etc/mysql/conf.d
-v /home/mysql/docker-data/3307/data/:/var/lib/mysql
-v /home/mysql/docker-data/3307/logs/:/var/log/mysql -d mysql:5.7
-d 后台运行容器，并返回容器ID；
mysql:5.7 运行的镜像文件
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;直接运行下面代码就能启动mysql&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;mysql1&quot;&gt;mysql1&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run --name mysqldocker1 -p 3306:3306 --privileged=true -it -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=ymq --hostname docker1 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -v /home/mysql/docker-data/mysql1/conf:/etc/mysql/conf.d -v /home/mysql/docker-data/mysql1/data/:/var/lib/mysql -v /home/mysql/docker-data/mysql1/logs/:/var/log/mysql -d mysql:5.7
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mysql2&quot;&gt;mysql2&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run --name mysqldocker2 -p 3307:3306 --privileged=true -it -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=ymq --hostname docker2 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -v /home/mysql/docker-data/mysql2/conf:/etc/mysql/conf.d -v /home/mysql/docker-data/mysql2/data/:/var/lib/mysql -v /home/mysql/docker-data/mysql2/logs/:/var/log/mytsql -d mysql:5.7
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mysql3&quot;&gt;mysql3&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker run --name mysqldocker3 -p 3308:3306 --privileged=true -it -e MYSQL_ROOT_PASSWORD=123456 -e MYSQL_DATABASE=ymq --hostname docker3 -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -v /home/mysql/docker-data/mysql3/conf:/etc/mysql/conf.d -v /home/mysql/docker-data/mysql3/data/:/var/lib/mysql -v /home/mysql/docker-data/mysql3/logs/:/var/log/mytsql -d mysql:5.7
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;查看Docker内容器状态&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker ps
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1538452/202101/1538452-20210108224206077-306830953.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;现在是启动成功了，但是没有配置主从相关配置，所以我们下一步要配置MySQL。&lt;br/&gt;因为运行的时候我们将容器内的配置目录挂载到本机的&lt;code&gt;/home/mysql/docker-data/&lt;/code&gt;下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1538452/202101/1538452-20210108224436895-841000808.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;所以我们将对应容器的配置文件复制到对应目录下的conf目录下&lt;br/&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1538452/202101/1538452-20210108224635064-1417288217.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;my.cnf 文件内容如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-text&quot;&gt;# For advice on how to change settings please see
# http://dev.mysql.com/doc/refman/5.7/en/server-configuration-defaults.html

[mysqld]
#
# Remove leading # and set to the amount of RAM for the most important data
# cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%.
# innodb_buffer_pool_size = 128M
#
# Remove leading # to turn on a very important data integrity option: logging
# changes to the binary log between backups.
# log_bin
#
# Remove leading # to set options mainly useful for reporting servers.
# The server defaults are faster for transactions and fast SELECTs.
# Adjust sizes as needed, experiment to find the optimal values.
# join_buffer_size = 128M
# sort_buffer_size = 2M
# read_rnd_buffer_size = 2M
#datadir=/home/mysql/docker-data/3307/data
#socket=/home/mysql/docker-data/3307/mysql.sock

character_set_server=utf8
init_connect='SET NAMES utf8'

# Disabling symbolic-links is recommended to prevent assorted security risks
symbolic-links=0

#log-error=/home/mysql/docker-data/3307/logs/mysqld.log
#pid-file=/home/mysql/docker-data/3307/mysqld.pid
lower_case_table_names=1
server-id=4122
log-bin=mysql-bin
auto_increment_increment=2
auto_increment_offset=1

#rpl_semi_sync_master_enabled=1
#rpl_semi_sync_master_timeout=10000

&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;配置说明&lt;br/&gt;三个容器的my.conf 中不能相同server-id&lt;br/&gt;如上图我的第一个mysql的server-id为4122，那个我第二个server-id我就设置为4123&lt;br/&gt;log-bin=mysql-bin 是开启bin-log&lt;br/&gt;auto_increment_offset 表示自增长字段从哪个数开始，指字段一次递增多少，他的取值范围是1 .. 65535&lt;br/&gt;auto_increment_increment 表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535&lt;br/&gt;为了避免两台服务器同时做更新时自增长字段的值之间发生冲突，一般在主主同步配置时，&lt;br/&gt;需要将两台服务器的auto_increment_increment增长量都配置为2，&lt;br/&gt;而要把auto_increment_offset分别配置为1和2。&lt;br/&gt;当然如果三台就需要auto_increment_increment增长量都配置为3&lt;br/&gt;auto_increment_offset分别设置为1和2和3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1538452/202101/1538452-20210108230105652-163565124.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#先查看所有容器 
docker ps
#然后一个个重启相应的容器
docker restart 容器id

#因为我容器只有这三个mysql 所以我以这样方式重启全部容器
docker restart $(docker ps -aq)
&lt;/code&gt;
&lt;/pre&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;我是以docker1下的mysql作为master主机&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;进入docker1&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker exec -it 容器ID/容器名字 /bin/bash
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1538452/202101/1538452-20210108230729793-1784599073.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;看到&lt;code&gt;root@docker1&lt;/code&gt;时表示在docker1容器内&lt;br/&gt;如果操作完毕就exit退出容器&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;进入mysql&quot;&gt;进入mysql&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1538452/202101/1538452-20210108230941881-2146418011.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;根据容器的配置 我设置的密码为123456&lt;/p&gt;
&lt;h2 id=&quot;在master-mysql添加权限&quot;&gt;在master mysql添加权限&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;GRANT REPLICATION SLAVE,FILE,REPLICATION CLIENT ON *.* TO 'repluser'@'%' IDENTIFIED BY '123456';
FLUSH PRIVILEGES;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看master的二进制文件&quot;&gt;查看master的二进制文件&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;show master status;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1538452/202101/1538452-20210108231351403-708528441.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;这样master配置就成功了&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;分别进入docker2 和 docker3&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;docker exec -it 容器ID/容器名字 /bin/bash
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意当看到光标前显示 root@docker2 和 root@docker3 时才表明进入成功&lt;br/&gt;如果需要退出用exit进行退出。&lt;/p&gt;
&lt;h2 id=&quot;在slave中设置master信息&quot;&gt;在slave中设置master信息&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;change master to master_host='172.24.7.187',master_port=3306,master_user='repluser',master_password='123456',master_log_file='mysql-bin.000001',master_log_pos=154;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;master_host='172.24.7.187' 主机我是用的云服务器内网地址 master_port=3306 是master主机的端口，master_user='repluser' master主机上的角色&lt;br/&gt;master_log_file='mysql-bin.000001',master_log_pos=154; 必须与主机的二进制一样&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;开启slave，启动sql和io线程&quot;&gt;开启slave，启动SQL和IO线程&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;start slave;
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;如果需要关闭就 stop slave;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;查看slave的状态&quot;&gt;查看slave的状态&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;show slave status\G;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1538452/202101/1538452-20210108232052866-1742122837.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果都为YES 就表明配置成功，主从复制搭建完成！！&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;如果 Slave_IO_Running: NO 但 Slave_SQL_Running: Yes&lt;br/&gt;可能是在slave中设置master信息的sql中master_host地址填的127.0.0.1 或者 localhost。&lt;br/&gt;因为这两个地址会先去访问容器内的本机，而不是容器外的mysql,所以需要换成云服务器的公网或内网ip&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;如果 Slave_IO_Running: Yes 但 Slave_SQL_Running: NO&lt;br/&gt;可能是主从同步的时候相关数据同步上的错误，在slave端 删除冲突的数据就行，具体的错误信息会在&lt;br/&gt;&lt;code&gt;show slave status\G&lt;/code&gt;下面的信息中指出NO的原因&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1538452/202101/1538452-20210108233655996-1768292368.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 08 Jan 2021 15:38:00 +0000</pubDate>
<dc:creator>颜值六毛六</dc:creator>
<og:description>docker 下mysql主从复制的搭建</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yumq/p/14253812.html</dc:identifier>
</item>
<item>
<title>Windows搭建SkyWalking8.3环境进行JAVA应用性能监控及入门示例(使用Mysql持久化) - MrOldx</title>
<link>http://www.cnblogs.com/mroldx/p/14253782.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mroldx/p/14253782.html</guid>
<description>&lt;h2 id=&quot;下载skywalking&quot;&gt;下载SkyWalking&lt;/h2&gt;
&lt;p&gt;一、&lt;a href=&quot;http://skywalking.apache.org/downloads/&quot; target=&quot;_blank&quot;&gt;下载地址&lt;/a&gt;(点击)&lt;br/&gt;选择tar&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210108222440446.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;解压后进入&lt;strong&gt;config&lt;/strong&gt;文件夹先配置一下Mysql数据源,打开application.yml文件&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021010822262181.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;默认&lt;strong&gt;selector&lt;/strong&gt;是h2我们改成mysql&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210108222804782.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;找到mysql的配置选项&quot;&gt;找到&lt;strong&gt;mysql&lt;/strong&gt;的配置选项&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210108222959655.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;修改一下你要存SkyWalking的数据库配置 其中&lt;strong&gt;swtest&lt;/strong&gt;为&lt;strong&gt;mysql数据库名字&lt;/strong&gt;,可以自己单独建一个&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-sql&quot;&gt;create database swtest;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置完了后,&lt;strong&gt;找一下java操作mysql的jar包放进 oap-libs文件夹&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一般随便找一个springboot的项目就有&lt;br/&gt;或者进maven官方仓库下载一个 地址:&lt;strong&gt;&lt;a href=&quot;https://mvnrepository.com/artifact/mysql/mysql-connector-java&quot; target=&quot;_blank&quot;&gt;https://mvnrepository.com/artifact/mysql/mysql-connector-java&lt;/a&gt;&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;下载完后复制到oap-libs文件夹&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210108223400102.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;&lt;strong&gt;这一步关系到Skywalking的初始化数据是否正常插入进你所配置的数据库&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;开始初始化数据&quot;&gt;开始初始化数据&lt;/h2&gt;
&lt;p&gt;双击bin目录下的此bat脚本&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210108224236431.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;会弹出一个cmd窗口停顿几秒自动关闭&lt;br/&gt;现在可以去数据库查看一下有没有生成表&lt;br/&gt;如下图所示就是成功了&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210108224349407.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;进入agentconfig文件夹-编辑agentconfig-修改agentservice_name&quot;&gt;进入agent/config文件夹 ,编辑agent.config 修改agent.service_name&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210108224835355.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;接下来去agent文件夹找到skywalking-agent.jar文件&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210108225320277.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;此界面打开cmd窗口&lt;br/&gt;执行&lt;/p&gt;
&lt;h2 id=&quot;启动你的jar包&quot;&gt;启动你的jar包&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt; java -javaagent:G:\IDM_domlown_2\apache-skywalking-apm-8.3.0\apache-skywalking-apm-bin\agent\skywalking-agent.jar -jar febs.jar
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;等你的jar包启动成功,然后随便访问几个界面让他请求后端接口&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210108225916925.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;启动skywalking&quot;&gt;启动skywalking&lt;/h2&gt;
&lt;p&gt;双击bin文件夹下的startup.bat来启动skywalking&lt;/p&gt;
&lt;p&gt;执行startup.bat之后会启动如下两个服务：&lt;br/&gt;（1）Skywalking-Collector：追踪信息收集器，通过 gRPC/Http 收集客户端的采集信息 ，Http默认端口 12800，gRPC默认端口 11800。&lt;br/&gt;（2）Skywalking-Webapp：UI管理平台页面 默认端口 8080，登录信息 admin/admin&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210108230124539.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210108230837425.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;不成功的话可以看一下logs文件夹里的日志&lt;/p&gt;
</description>
<pubDate>Fri, 08 Jan 2021 15:26:00 +0000</pubDate>
<dc:creator>MrOldx</dc:creator>
<og:description>下载SkyWalking 一、下载地址(点击) 选择tar 解压后进入config文件夹先配置一下Mysql数据源,打开application.yml文件 默认selector是h2我们改成mysql</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/mroldx/p/14253782.html</dc:identifier>
</item>
<item>
<title>SpringBoot-启动流程 - 吴楠予</title>
<link>http://www.cnblogs.com/Narule/p/14253754.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Narule/p/14253754.html</guid>
<description>&lt;p&gt;SpringBoot如何启动，初始化配置，监听器，bean拦截器创建和调用， bean信息注册, 创建bean时间; 如何用生成动态代理对象&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;323&quot;&gt;

&lt;p&gt;平时开发springboot项目的时候，一个SpringApplication注解加一个main方法就可以启动服务器运行起来（默认tomcat），看了下源码，这里讲下认为主要的流程&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;主要流程如下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;0.启动main方法开始&lt;/p&gt;
&lt;p&gt;1.&lt;strong&gt;初始化配置&lt;/strong&gt;：通过类加载器，（loadFactories）读取classpath下所有的spring.factories配置文件，创建一些初始配置对象；通知监听者应用程序启动开始，创建环境对象environment，用于读取环境配置 如 application.yml&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;创建应用程序上下文&lt;/strong&gt;-createApplicationContext，创建 bean工厂对象&lt;/p&gt;
&lt;p&gt;3.&lt;strong&gt;刷新上下文（启动核心）&lt;/strong&gt;&lt;br/&gt;3.1 配置工厂对象，包括上下文类加载器，对象发布处理器，beanFactoryPostProcessor&lt;br/&gt;3.2 注册并实例化bean工厂发布处理器，并且调用这些处理器，对包扫描解析(主要是class文件)&lt;br/&gt;3.3 注册并实例化bean发布处理器 beanPostProcessor&lt;br/&gt;3.4 初始化一些与上下文有特别关系的bean对象（此处启动tomcat服务器）&lt;br/&gt;3.5 实例化所有bean工厂缓存的bean对象（剩下的）&lt;br/&gt;3.6 发布通知-通知上下文刷新完成&lt;/p&gt;
&lt;p&gt;4.&lt;strong&gt;通知监听者-启动程序完成&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动中，大部分对象都是BeanFactory对象通过反射创建&lt;/p&gt;
&lt;p&gt;SpringBoot的启动解析代码过多，下文是整体流程的部分主要代码&lt;/p&gt;
&lt;h2 id=&quot;启动&quot;&gt;启动&lt;/h2&gt;
&lt;p&gt;启动程序：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;import org.springframework.boot.SpringApplication;//启动类
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication //启动必要注解
public class YourApplication {
        //运行main方法启动springboot
        public static void main(String[] args) {
                SpringApplication.run(YourApplication.class, args);//启动类静态run方法
        }
    
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;启动类&quot;&gt;启动类&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;org.springframework.boot.SpringApplication&lt;/code&gt; 包含主流程方法&lt;/p&gt;
&lt;p&gt;启动类在运行静态run方法的时候，是先创建一个SpringApplication对象，再运行对象的run方法，工厂初始配置在构造函数中完成，run方法定义运行总体流程&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 静态方法 org.springframework.boot.SpringApplication.run(Class&amp;lt;?&amp;gt;[], String[])
public static ConfigurableApplicationContext run(Class&amp;lt;?&amp;gt;[] primarySources, String[] args) {
    return new SpringApplication(primarySources).run(args);
}

// 构造方法
public SpringApplication(ResourceLoader resourceLoader, Class&amp;lt;?&amp;gt;... primarySources) {
    //.......... 
    //// 1.(loadFactories)读取classpath下所有的spring.factories配置文件 ////
    // 配置应用程序启动前的初始化对象
    setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); 
    // 配置应用程序启动前的监听器
    setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));
    this.mainApplicationClass = deduceMainApplicationClass();
}

// 对象run方法 开始启动程序
public ConfigurableApplicationContext run(String... args) {
    //......
    // 通知监听者启动开始
    listeners.starting(); 
    try {
        // 创建应用程序环境 配置文件在此处读取(application.properties application.yml)
        ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments);
        //// 2.创建应用程序上下文...此处创建了beanfactory ////
        context = createApplicationContext();
        //// 3.刷新上下文（spring启动核心） ////
        refreshContext(context);

        //// 4.启动完成通知...... ////
        listeners.started(context);
    }
    catch (Throwable ex) {
        handleRunFailure(context, ex, exceptionReporters, listeners);
        throw new IllegalStateException(ex);
    }
    try {
        listeners.running(context);
    }
    catch (Throwable ex) {
        handleRunFailure(context, ex, exceptionReporters, null);
        throw new IllegalStateException(ex);
    }
    return context;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;初始化配置&quot;&gt;初始化配置&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;springboot启动应用程序之前，会创建一些初始化对象和监听器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个操作在构造方法中完成，根据配置文件，创建&lt;code&gt;ApplicationContextInitializer.class&lt;/code&gt;,&lt;code&gt;ApplicationListener.class&lt;/code&gt;两个接口的实现类，至于具体创建那些类对象，根据下面的方法逻辑去做&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.springframework.boot.SpringApplication.getSpringFactoriesInstances()&lt;/code&gt; -&amp;gt;&lt;br/&gt;&lt;code&gt;org.springframework.core.io.support.SpringFactoriesLoader.loadFactoryNames()&lt;/code&gt; -&amp;gt;&lt;br/&gt;&lt;code&gt;org.springframework.core.io.support.SpringFactoriesLoader.loadSpringFactories()&lt;/code&gt;-&amp;gt;&lt;br/&gt;&lt;code&gt;createSpringFactoriesInstances()&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//构造方法中的初始化对象创建
setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); 
setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));

//看一下getSpringFactoriesInstances方法
private &amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; getSpringFactoriesInstances(Class&amp;lt;T&amp;gt; type) {
    return getSpringFactoriesInstances(type, new Class&amp;lt;?&amp;gt;[] {});
}

private &amp;lt;T&amp;gt; Collection&amp;lt;T&amp;gt; getSpringFactoriesInstances(Class&amp;lt;T&amp;gt; type, Class&amp;lt;?&amp;gt;[] parameterTypes, Object... args) {
    ClassLoader classLoader = getClassLoader();
    // 获取初始化类的类名
    Set&amp;lt;String&amp;gt; names = new LinkedHashSet&amp;lt;&amp;gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));
    // 通过这些类名实例化对象
    List&amp;lt;T&amp;gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);
    AnnotationAwareOrderComparator.sort(instances);
    return instances;
}

// 读取配置方法
// 更详深层的代码在org.springframework.core.io.support.SpringFactoriesLoader.loadSpringFactories(ClassLoader)
public static List&amp;lt;String&amp;gt; loadFactoryNames(Class&amp;lt;?&amp;gt; factoryType, @Nullable ClassLoader classLoader) {
    String factoryTypeName = factoryType.getName();
    return loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());   
}
// loadSpringFactories(classLoader)读取运行环境中所有META-INF/spring.factories配置
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的方法，&lt;/p&gt;
&lt;p&gt;spring-boot-2.2.8.RELEASE.jar/META-INF/spring.factories的文件中是这样，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-F#&quot;&gt;# Application Context Initializers
org.springframework.context.ApplicationContextInitializer=\
org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,\
org.springframework.boot.context.ContextIdApplicationContextInitializer,\
org.springframework.boot.context.config.DelegatingApplicationContextInitializer,\
org.springframework.boot.rsocket.context.RSocketPortInfoApplicationContextInitializer,\
org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果只读取这一个文件，&lt;code&gt;loadFactoryNames(ApplicationContextInitializer.class,classLoader)&lt;/code&gt;读取返回的就是下面的数组:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;[org.springframework.context.ApplicationContextInitializer,
 org.springframework.boot.context.ConfigurationWarningsApplicationContextInitializer,
 org.springframework.boot.context.ContextIdApplicationContextInitializer,
 org.springframework.boot.context.config.DelegatingApplicationContextInitializer,
 org.springframework.boot.web.context.ServerPortInfoApplicationContextInitializer]
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;Class.forName(className)&lt;/code&gt;获取这些类的Class，最后反射&lt;code&gt;newInstance&lt;/code&gt;创建这些对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建好这些对象后，启动监听器&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;listeners.starting();  // 这里也是一些调用操作
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;读取application配置&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;监听器启动之后，会读取application.properties 或者 application.yml文件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;ConfigurableEnvironment environment = prepareEnvironment(listeners, applicationArguments); //此处application.properties配置文件会被读取
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;创建应用上下文&quot;&gt;创建应用上下文&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;创建应用上下文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;初始化和配置好后，开始创建应用程序上下文，createApplicationContext ，关键的工厂BeanFactory就是此处创建，具体逻辑如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 创建应用程序上下文
context = createApplicationContext();

protected ConfigurableApplicationContext createApplicationContext() {
    // 上下文创建的判断逻辑
    Class&amp;lt;?&amp;gt; contextClass = this.applicationContextClass;
    if (contextClass == null) {
        try {
            switch (this.webApplicationType) {
                case SERVLET:
                    contextClass = Class.forName(DEFAULT_SERVLET_WEB_CONTEXT_CLASS);
                    break;
                case REACTIVE:
                    contextClass = Class.forName(DEFAULT_REACTIVE_WEB_CONTEXT_CLASS);
                    break;
                default:
                    contextClass = Class.forName(DEFAULT_CONTEXT_CLASS);
            }
        }
        catch (ClassNotFoundException ex) {
            throw new IllegalStateException(
                &quot;Unable create a default ApplicationContext, please specify an ApplicationContextClass&quot;, ex);
        }
    }
    return (ConfigurableApplicationContext) BeanUtils.instantiateClass(contextClass);
}

public static final String DEFAULT_SERVLET_WEB_CONTEXT_CLASS = &quot;org.springframework.boot.&quot;
                        + &quot;web.servlet.context.AnnotationConfigServletWebServerApplicationContext&quot;;
// 默认是创建这个类
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里通过this.webApplicationType判断创建具体的应用上下文，也是反射创建对象，默认创建的是&lt;code&gt;org.springframework.boot.web.servlet.context.AnnotationConfigServletWebServerApplicationContext&lt;/code&gt;对象，看一下这个类的基本信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public class AnnotationConfigServletWebServerApplicationContext extends ServletWebServerApplicationContext
                implements AnnotationConfigRegistry {
    // 构造方法
        public AnnotationConfigServletWebServerApplicationContext() {
                this.reader = new AnnotatedBeanDefinitionReader(this);
                this.scanner = new ClassPathBeanDefinitionScanner(this);
        }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;创建工厂对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此类继承了很多类，其中一个父类是&lt;code&gt;org.springframework.context.support.GenericApplicationContext&lt;/code&gt;&lt;br/&gt;jvm机制，创建对象的时候，先运行父类的构造方法，所以创建了beanFactory&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 超级父类 GenericApplicationContext的构造方法
public GenericApplicationContext() {
    this.beanFactory = new DefaultListableBeanFactory();//创建工厂对象
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;刷新应用上下文&quot;&gt;刷新应用上下文&lt;/h2&gt;
&lt;p&gt;创建好上下文之后，开始刷新上下文，这里做了很多&lt;/p&gt;
&lt;p&gt;工厂配置，bean处理器配置，类的扫描，解析，bean定义，bean类信息缓存，服务器创建，bean实例化，动态代理对象的创建等，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;spring中注册bean信息和实例化bean是两件事情。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注册bean信息不是创建bean对象，是解析bean类获取详细信息，会创建BeanDefinition对象，携带bean类的字节码和方法等信息，把BeanDefinition对象注册保存到工厂BeanDefinitionMap中。&lt;/p&gt;
&lt;p&gt;工厂实例化bean时直接BeanDefinitionMap.get(beanName) 获取bean的字节码信息，通过反射创建对象，然后将bean对象保存到singletonObjects中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;refreshContext(context); //刷新上下文
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认实际对应的是&lt;code&gt;org.springframework.context.support.AbstractApplicationContext&lt;/code&gt;类的&lt;code&gt;refresh()&lt;/code&gt;方法&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;@Override
public void refresh() throws BeansException, IllegalStateException {
    synchronized (this.startupShutdownMonitor) {
        //......
        // 3.1配置工厂对象
        prepareBeanFactory(beanFactory);
        try {       
            postProcessBeanFactory(beanFactory);
            // 3.2注册并实例化bean工厂处理器,并调用他们
            invokeBeanFactoryPostProcessors(beanFactory);
            // 3.3注册并实例化bean处理器
            registerBeanPostProcessors(beanFactory);
            // 3.4 初始化一些与上下文有特别关系的bean对象（此处启动tomcat服务器）
            onRefresh();
            // 3.5 实例化所有bean工厂缓存的bean对象（剩下的）.
            finishBeanFactoryInitialization(beanFactory);
            // 3.6 发布通知-通知上下文刷新完成
            finishRefresh();
        }
        catch (BeansException ex) {// ......Propagate exception to caller.
            throw ex;
        }
        finally {// ......
            resetCommonCaches();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;配置工厂对象，包括上下文类加载器，bean工厂发布处理器&quot;&gt;配置工厂对象，包括上下文类加载器，bean工厂发布处理器&lt;/h3&gt;
&lt;p&gt;工厂创建好后，首先配置的是类加载器，然后是一些对象发布处理器（拦截器）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//// 3.1配置工厂对象 
prepareBeanFactory(beanFactory);

protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    // 设置类加载器
    beanFactory.setBeanClassLoader(getClassLoader());
    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

    // 添加BeanPostProcessor
    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
        // ......
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;注册并实例化bean工厂发布处理器并调用他们&quot;&gt;注册并实例化bean工厂发布处理器,并调用他们&lt;/h3&gt;
&lt;p&gt;过程主要是工厂发布处理器的创建和调用，逻辑较多&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//// 3.2注册并实例化bean工厂处理器,并调用他们
invokeBeanFactoryPostProcessors(beanFactory);

protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());
    // ......
}

// PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors
public static void invokeBeanFactoryPostProcessors(
                        ConfigurableListableBeanFactory beanFactory, List&amp;lt;BeanFactoryPostProcessor&amp;gt; beanFactoryPostProcessors) {
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        for (String ppName : postProcessorNames) {
            if (!processedBeans.contains(ppName) &amp;amp;&amp;amp; beanFactory.isTypeMatch(ppName, Ordered.class)) {
                // 创建BeanDefinitionRegistryPostProcessor处理器
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }
        // 调用这些处理器
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        // ...

}

// 循环调用
private static void invokeBeanDefinitionRegistryPostProcessors(
                        Collection&amp;lt;? extends BeanDefinitionRegistryPostProcessor&amp;gt; postProcessors, BeanDefinitionRegistry registry) {
    for (BeanDefinitionRegistryPostProcessor postProcessor : postProcessors) {
        postProcessor.postProcessBeanDefinitionRegistry(registry);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BeanDefinitionRegistryPostProcessor的子类对象在此处创建并调&lt;code&gt;postProcessBeanDefinitionRegistry&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;org.springframework.context.annotation.ConfigurationClassPostProcessor&lt;/code&gt;就是BeanDefinitionRegistryPostProcessor的子类，是一个spring的类解析器，扫描包下所有的类，解析出bean类，注册到bean工厂由此类主要参与，其中有不少递归&lt;/p&gt;
&lt;h3 id=&quot;注册并实例化bean发布处理器&quot;&gt;注册并实例化bean发布处理器&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//// 3.3注册并实例化bean处理器
registerBeanPostProcessors(beanFactory);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;BeanFactoryPostProcessors 和 BeanPostProcessors是有区别的&lt;/p&gt;
&lt;p&gt;BeanFactoryPostProcessors 是工厂发布处理器，定义什么是bean，知道哪些是bean类，解析class文件，包括注解解析，成员对象依赖解析等；BeanPostProcessors主要在BeanFactoryPostProcessors调用完之后工作&lt;/p&gt;
&lt;p&gt;一般在bean对像的创建之前或之后，BeanFactory调用这些bean处理器拦截处理，Spring代理对象的创建也是通过beanPostProcessor处理器来实现&lt;/p&gt;
&lt;h4 id=&quot;bean发布处理器生产aop代理对象&quot;&gt;bean发布处理器生产AOP代理对象&lt;/h4&gt;
&lt;p&gt;AnnotationAwareAspectJAutoProxyCreator实现了BeanPostProcessors，在bean被工厂创建之后，BeanFactory调用拦截器的postProcessAfterInitialization做拦截处理。此拦截器处理器实际执行的是父类&lt;code&gt;org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator&lt;/code&gt;的方法&lt;/p&gt;
&lt;p&gt;比如一个UserServiceImp类有@service注解，并且有切点Aspectj注解增强方法，bean工厂创建userServiceImp后，代理拦截器检测到AOP相关注解，会创建动态代理对象userServiceImp$$EnhancerBySpringCGLIB并返代理对象，而不是返回userServiceImp&lt;/p&gt;
&lt;p&gt;Spring工厂部分bean创建拦截代码逻辑&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.initializeBean(String, Object, RootBeanDefinition)
// bean初始化
protected Object initializeBean(String beanName, Object bean, @Nullable RootBeanDefinition mbd) {
    invokeAwareMethods(beanName, bean);
    Object wrappedBean = bean;
    if (mbd == null || !mbd.isSynthetic()) {
        // 初始化之前，拦截
        wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);
    }
    invokeInitMethods(beanName, wrappedBean, mbd);
    if (mbd == null || !mbd.isSynthetic()) {
        // 初始化之后拦截
        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);
    }
    return wrappedBean;
}

@Override
public Object applyBeanPostProcessorsAfterInitialization(Object existingBean, String beanName)
    throws BeansException {
    Object result = existingBean;
    for (BeanPostProcessor processor : getBeanPostProcessors()) {
        // 循环bean发布处理器调用postProcessAfterInitialization方法  
        Object current = processor.postProcessAfterInitialization(result, beanName);
        if (current == null) {
            return result;
        }
        result = current;
    }
    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;AbstractAutoProxyCreator在此循环中被调用，比如在userServiceImp服务类上有事务注解@Transactional，一般就会被拦截生成代理对象，添加额外的处理事务的功能代码，返回增强的代理对象&lt;/p&gt;
&lt;h3 id=&quot;初始化一些与上下文有特别关系的bean对象&quot;&gt;初始化一些与上下文有特别关系的bean对象&lt;/h3&gt;
&lt;p&gt;默认tomcat服务器的创建就是此方法完成，此处定义特别的bean创建，一般是服务器有关或个性化对象，&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//// 3.4 初始化一些与上下文有特别关系的bean对象（此处启动tomcat服务器）
onRefresh();

// org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext
// 子类context重写
@Override
protected void onRefresh() {
    super.onRefresh();
    try {
        createWebServer(); //创建tomcat服务器
    }
    catch (Throwable ex) {
        throw new ApplicationContextException(&quot;Unable to start web server&quot;, ex);
    }
}

private void createWebServer() {
    WebServer webServer = this.webServer;
    ServletContext servletContext = getServletContext();
    if (webServer == null &amp;amp;&amp;amp; servletContext == null) {
        ServletWebServerFactory factory = getWebServerFactory();
        this.webServer = factory.getWebServer(getSelfInitializer()); 
        // 此处创建了服务器
        // org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory.getWebServer()
    }
    // ......
    initPropertySources();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;实例化所有bean工厂缓存的bean对象&quot;&gt;实例化所有bean工厂缓存的bean对象&lt;/h3&gt;
&lt;p&gt;服务器启动后，创建spring工厂里面缓存的bean信息（没有被创建的单例）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;//// 3.5 实例化所有bean工厂缓存的bean对象（剩下的）.
finishBeanFactoryInitialization(beanFactory);

protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    // ......
    // Instantiate all remaining (non-lazy-init) singletons.
    beanFactory.preInstantiateSingletons();
}

// 子类org.springframework.beans.factory.support.DefaultListableBeanFactory实现方法，完成剩下的单例bean对象创建
@Override
public void preInstantiateSingletons() throws BeansException {
    List&amp;lt;String&amp;gt; beanNames = new ArrayList&amp;lt;&amp;gt;(this.beanDefinitionNames);
    for (String beanName : beanNames) {
        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
        if (!bd.isAbstract() &amp;amp;&amp;amp; bd.isSingleton() &amp;amp;&amp;amp; !bd.isLazyInit()) {
                getBean(beanName); //创建还没有实例化的bean对象
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;发布通知-通知上下文刷新完成&quot;&gt;发布通知-通知上下文刷新完成&lt;/h3&gt;
&lt;p&gt;上下文初始化完成之后，启动tomcat服务器&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;finishRefresh();

// super.finishRefresh
protected void finishRefresh() {
    // ...... 发布刷行完成事件
    // Publish the final event.
    publishEvent(new ContextRefreshedEvent(this));
}

// org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext.finishRefresh()
@Override
protected void finishRefresh() {
    super.finishRefresh();
    WebServer webServer = startWebServer();// 启动服务器
    if (webServer != null) {
        publishEvent(new ServletWebServerInitializedEvent(webServer, this));
    }
}

&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;通知监听者-启动程序完成&quot;&gt;&lt;strong&gt;通知监听者-启动程序完成&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;发布通知监听器启动完成，监听器会根据事件类型做个性化操作&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;listeners.started(context);
listeners.running(context);

void started(ConfigurableApplicationContext context) {
    for (SpringApplicationRunListener listener : this.listeners) {
        listener.started(context);
    }
}

void running(ConfigurableApplicationContext context) {
    for (SpringApplicationRunListener listener : this.listeners) {
        listener.running(context);
    }
}

@Override
public void started(ConfigurableApplicationContext context) {
    context.publishEvent(new ApplicationStartedEvent(this.application, this.args, context));
}

@Override
public void running(ConfigurableApplicationContext context) {
    context.publishEvent(new ApplicationReadyEvent(this.application, this.args, context));
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不定期更新...&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 08 Jan 2021 15:14:00 +0000</pubDate>
<dc:creator>吴楠予</dc:creator>
<og:description>SpringBoot如何启动，初始化配置，监听器，bean拦截器创建和调用， bean信息注册, 创建bean时间; 如何用生成动态代理对象</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/Narule/p/14253754.html</dc:identifier>
</item>
</channel>
</rss>