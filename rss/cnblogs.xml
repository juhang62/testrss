<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Go之获取系统性能指标 - goPsutil - 常见-youmen</title>
<link>http://www.cnblogs.com/you-men/p/14221464.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/you-men/p/14221464.html</guid>
<description>&lt;h3 id=&quot;简介&quot;&gt;简介&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;psutil&lt;/code&gt;是一个跨平台进程和系统监控的Python库，而&lt;code&gt;gopsutil&lt;/code&gt;是其Go语言版本的实现。&lt;br/&gt;Go语言部署简单、性能好的特点非常适合做一些诸如采集系统信息和监控的服务，本文介绍的&lt;a href=&quot;https://github.com/shirou/gopsutil&quot; target=&quot;_blank&quot;&gt;gopsutil&lt;/a&gt;库是知名Python库：&lt;a href=&quot;https://github.com/giampaolo/psutil&quot; target=&quot;_blank&quot;&gt;psutil&lt;/a&gt;的一个Go语言版本的实现。&lt;/p&gt;
&lt;h4 id=&quot;特点&quot;&gt;特点&lt;/h4&gt;
&lt;blockquote readability=&quot;12&quot;&gt;
&lt;p&gt;gopsutils为我们屏蔽了各个系统之间的差异, 具有非常强悍的可移植性, 有了gopsutil, 我们不再需要针对不同的系统使用syscall调用对应的系统方法, 更棒的是gopsutil的实现中没有任何cgo的代码, 使得交叉编译成为可能.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;go get github.com/shirou/gopsutil
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;功能&quot;&gt;功能&lt;/h4&gt;
&lt;p&gt;gopsutil将不同的功能划分到不同的子包中&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;/*
                cpu:            CPU相关
                disk:           磁盘相关
                docker:   docker相关
                host:                   主机相关
                mem:                    内存相关
                net:                    网络相关
                process:  进程相关
*/
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;cpu&quot;&gt;CPU&lt;/h3&gt;
&lt;h4 id=&quot;采集cpu相关信息&quot;&gt;采集CPU相关信息&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;
        &quot;github.com/shirou/gopsutil/cpu&quot;
        &quot;time&quot;
)

// cpu info
func getCpuInfo() {
        cpuInfos, err := cpu.Info()
        if err != nil {
                fmt.Printf(&quot;get cpu info failed, err:%v&quot;, err)
        }
        for _, ci := range cpuInfos {
                fmt.Println(ci)
        }
        // CPU使用率
        for {
                percent, _ := cpu.Percent(time.Second, false)
                fmt.Printf(&quot;cpu percent:%v\n&quot;, percent)
        }
}

func main()  {
        getCpuInfo()
}

go run ps.go  
{&quot;cpu&quot;:0,&quot;vendorId&quot;:&quot;GenuineIntel&quot;,&quot;family&quot;:&quot;6&quot;,&quot;model&quot;:&quot;142&quot;,&quot;stepping&quot;:10,&quot;physicalId&quot;:&quot;&quot;,&quot;coreId&quot;:&quot;&quot;,&quot;cores&quot;:4,&quot;modelName&quot;:&quot;Intel(R) Core(TM) i5-8257U CPU @ 1.40GHz&quot;,&quot;mhz&quot;:1400,&quot;cacheSize&quot;:256,&quot;flags&quot;:[&quot;fpu&quot;,&quot;vme&quot;,&quot;de&quot;,&quot;pse&quot;,&quot;tsc&quot;,&quot;msr&quot;,&quot;pae&quot;,&quot;mce&quot;,&quot;cx8&quot;,&quot;apic&quot;,&quot;sep&quot;,&quot;mtrr&quot;,&quot;pge&quot;,&quot;mca&quot;,&quot;cmov&quot;,&quot;pat&quot;,&quot;pse36&quot;,&quot;clfsh&quot;,&quot;ds&quot;,&quot;acpi&quot;,&quot;mmx&quot;,&quot;fxsr&quot;,&quot;sse&quot;,&quot;sse2&quot;,&quot;ss&quot;,&quot;htt&quot;,&quot;tm&quot;,&quot;pbe&quot;,&quot;sse3&quot;,&quot;pclmulqdq&quot;,&quot;dtes64&quot;,&quot;mon&quot;,&quot;dscpl&quot;,&quot;vmx&quot;,&quot;est&quot;,&quot;tm2&quot;,&quot;ssse3&quot;,&quot;fma&quot;,&quot;cx16&quot;,&quot;tpr&quot;,&quot;pdcm&quot;,&quot;sse4.1&quot;,&quot;sse4.2&quot;,&quot;x2apic&quot;,&quot;movbe&quot;,&quot;popcnt&quot;,&quot;aes&quot;,&quot;pcid&quot;,&quot;xsave&quot;,&quot;osxsave&quot;,&quot;seglim64&quot;,&quot;tsctmr&quot;,&quot;avx1.0&quot;,&quot;rdrand&quot;,&quot;f16c&quot;,&quot;rdwrfsgs&quot;,&quot;tsc_thread_offset&quot;,&quot;sgx&quot;,&quot;bmi1&quot;,&quot;avx2&quot;,&quot;smep&quot;,&quot;bmi2&quot;,&quot;erms&quot;,&quot;invpcid&quot;,&quot;fpu_csds&quot;,&quot;mpx&quot;,&quot;rdseed&quot;,&quot;adx&quot;,&quot;smap&quot;,&quot;clfsopt&quot;,&quot;ipt&quot;,&quot;mdclear&quot;,&quot;tsxfa&quot;,&quot;ibrs&quot;,&quot;stibp&quot;,&quot;l1df&quot;,&quot;ssbd&quot;,&quot;syscall&quot;,&quot;xd&quot;,&quot;1gbpage&quot;,&quot;em64t&quot;,&quot;lahf&quot;,&quot;lzcnt&quot;,&quot;prefetchw&quot;,&quot;rdtscp&quot;,&quot;tsci&quot;],&quot;microcode&quot;:&quot;&quot;}
cpu percent:[10.099750623570355]
cpu percent:[7.615480649005255]
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;获取cpu负载消息&quot;&gt;&lt;strong&gt;获取CPU负载消息&lt;/strong&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;
        &quot;github.com/shirou/gopsutil/load&quot;
)

func getCpuLoad()  {
        info, _ := load.Avg()
        fmt.Printf(&quot;%v\n&quot;,info)
}

func main()  {
        getCpuLoad()
}

go run ps.go 
{&quot;load1&quot;:2.591796875,&quot;load5&quot;:2.86572265625,&quot;load15&quot;:2.7578125}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;**&lt;/p&gt;
&lt;h3 id=&quot;memory&quot;&gt;Memory&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;
        &quot;github.com/shirou/gopsutil/mem&quot;
)

func getMemInfo()  {
        memInfo, _ := mem.VirtualMemory()
        fmt.Printf(&quot;mem info:%v\n&quot;,memInfo)
}

func main()  {
        getMemInfo()
}

go run ps.go
mem info:{&quot;total&quot;:8589934592,&quot;available&quot;:1984147456,&quot;used&quot;:6605787136,&quot;usedPercent&quot;:76.9014835357666,&quot;free&quot;:122396672,&quot;active&quot;:1884549120,&quot;inactive&quot;:1861750784,&quot;wired&quot;:2657144832,&quot;laundry&quot;:0,&quot;buffers&quot;:0,&quot;cached&quot;:0,&quot;writeback&quot;:0,&quot;dirty&quot;:0,&quot;writebacktmp&quot;:0,&quot;shared&quot;:0,&quot;slab&quot;:0,&quot;sreclaimable&quot;:0,&quot;sunreclaim&quot;:0,&quot;pagetables&quot;:0,&quot;swapcached&quot;:0,&quot;commitlimit&quot;:0,&quot;committedas&quot;:0,&quot;hightotal&quot;:0,&quot;highfree&quot;:0,&quot;lowtotal&quot;:0,&quot;lowfree&quot;:0,&quot;swaptotal&quot;:0,&quot;swapfree&quot;:0,&quot;mapped&quot;:0,&quot;vmalloctotal&quot;:0,&quot;vmallocused&quot;:0,&quot;vmallocchunk&quot;:0,&quot;hugepagestotal&quot;:0,&quot;hugepagesfree&quot;:0,&quot;hugepagesize&quot;:0}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;host&quot;&gt;Host&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;
        &quot;github.com/shirou/gopsutil/host&quot;
)

func getHostInfo() {
        hInfo, _ := host.Info()
        fmt.Printf(&quot;host info:%v uptime:%v boottime:%v\n&quot;, hInfo, hInfo.Uptime, hInfo.BootTime)
}

func main() {
        getHostInfo()
}

go run ps.go
host info:{&quot;hostname&quot;:&quot;youmendeMacBook-Pro.local&quot;,&quot;uptime&quot;:314216,&quot;bootTime&quot;:1609206164,&quot;procs&quot;:525,&quot;os&quot;:&quot;darwin&quot;,&quot;platform&quot;:&quot;darwin&quot;,&quot;platformFamily&quot;:&quot;Standalone Workstation&quot;,&quot;platformVersion&quot;:&quot;11.1&quot;,&quot;kernelVersion&quot;:&quot;20.2.0&quot;,&quot;kernelArch&quot;:&quot;x86_64&quot;,&quot;virtualizationSystem&quot;:&quot;&quot;,&quot;virtualizationRole&quot;:&quot;&quot;,&quot;hostid&quot;:&quot;82e2050c-5936-3d24-ad3b-ec4ec5c09e11&quot;} uptime:314216 boottime:1609206164
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;disk&quot;&gt;Disk&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;
        &quot;github.com/shirou/gopsutil/disk&quot;
)

// disk info
func getDiskInfo() {
        parts, err := disk.Partitions(true)
        if err != nil {
                fmt.Printf(&quot;get Partitions failed, err:%v\n&quot;, err)
                return
        }
        for _, part := range parts {
                fmt.Printf(&quot;part:%v\n&quot;, part.String())
                diskInfo, _ := disk.Usage(part.Mountpoint)
                fmt.Printf(&quot;disk info:used:%v free:%v\n&quot;, diskInfo.UsedPercent, diskInfo.Free)
        }

        ioStat, _ := disk.IOCounters()
        for k, v := range ioStat {
                fmt.Printf(&quot;%v:%v\n&quot;, k, v)
        }
}

func main() {
        getDiskInfo()
}




go run ps.go 
part:{&quot;device&quot;:&quot;/dev/disk1s2s1&quot;,&quot;mountpoint&quot;:&quot;/&quot;,&quot;fstype&quot;:&quot;apfs&quot;,&quot;opts&quot;:&quot;ro,journaled,multilabel&quot;}
disk info:used:21.590916437596942 free:54644285440
part:{&quot;device&quot;:&quot;devfs&quot;,&quot;mountpoint&quot;:&quot;/dev&quot;,&quot;fstype&quot;:&quot;devfs&quot;,&quot;opts&quot;:&quot;rw,nobrowse,multilabel&quot;}
disk info:used:100 free:0
part:{&quot;device&quot;:&quot;/dev/disk1s5&quot;,&quot;mountpoint&quot;:&quot;/System/Volumes/VM&quot;,&quot;fstype&quot;:&quot;apfs&quot;,&quot;opts&quot;:&quot;rw,noexec,nobrowse,journaled,multilabel,noatime&quot;}
disk info:used:3.781419239013729 free:54644285440
part:{&quot;device&quot;:&quot;/dev/disk1s3&quot;,&quot;mountpoint&quot;:&quot;/System/Volumes/Preboot&quot;,&quot;fstype&quot;:&quot;apfs&quot;,&quot;opts&quot;:&quot;rw,nobrowse,journaled,multilabel&quot;}
disk info:used:0.5894192171529189 free:54644285440
part:{&quot;device&quot;:&quot;/dev/disk1s6&quot;,&quot;mountpoint&quot;:&quot;/System/Volumes/Update&quot;,&quot;fstype&quot;:&quot;apfs&quot;,&quot;opts&quot;:&quot;rw,nobrowse,journaled,multilabel&quot;}
disk info:used:0.0014916323547500506 free:54644285440
part:{&quot;device&quot;:&quot;/dev/disk1s1&quot;,&quot;mountpoint&quot;:&quot;/System/Volumes/Data&quot;,&quot;fstype&quot;:&quot;apfs&quot;,&quot;opts&quot;:&quot;rw,nobrowse,journaled,multilabel&quot;}
disk info:used:76.48839834497826 free:54644285440
part:{&quot;device&quot;:&quot;map auto_home&quot;,&quot;mountpoint&quot;:&quot;/System/Volumes/Data/home&quot;,&quot;fstype&quot;:&quot;autofs&quot;,&quot;opts&quot;:&quot;rw,nobrowse,automounted,multilabel&quot;}
disk info:used:0 free:0
disk0:{&quot;readCount&quot;:7171236,&quot;mergedReadCount&quot;:0,&quot;writeCount&quot;:3480390,&quot;mergedWriteCount&quot;:0,&quot;readBytes&quot;:157156835328,&quot;writeBytes&quot;:130453229568,&quot;readTime&quot;:6791329,&quot;writeTime&quot;:2234950,&quot;iopsInProgress&quot;:0,&quot;ioTime&quot;:9026279,&quot;weightedIO&quot;:0,&quot;name&quot;:&quot;disk0&quot;,&quot;serialNumber&quot;:&quot;&quot;,&quot;label&quot;:&quot;&quot;}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;io&quot;&gt;IO&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-go&quot;&gt;package main

import (
        &quot;fmt&quot;
        &quot;github.com/shirou/gopsutil/net&quot;
)

func getNetInfo() {
        info, _ := net.IOCounters(true)
        for index, v := range info {
                fmt.Printf(&quot;%v:%v send:%v recv:%v\n&quot;, index, v, v.BytesSent, v.BytesRecv)
        }
}

func main() {
        getNetInfo()
}

 go run ps.go
0:{&quot;name&quot;:&quot;lo0&quot;,&quot;bytesSent&quot;:121344185,&quot;bytesRecv&quot;:121344185,&quot;packetsSent&quot;:433070,&quot;packetsRecv&quot;:433070,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:121344185 recv:121344185
1:{&quot;name&quot;:&quot;gif0&quot;,&quot;bytesSent&quot;:0,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:0,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:0 recv:0
2:{&quot;name&quot;:&quot;stf0&quot;,&quot;bytesSent&quot;:0,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:0,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:0 recv:0
3:{&quot;name&quot;:&quot;en3&quot;,&quot;bytesSent&quot;:14748522,&quot;bytesRecv&quot;:8111958,&quot;packetsSent&quot;:61122,&quot;packetsRecv&quot;:61250,&quot;errin&quot;:0,&quot;errout&quot;:1394,&quot;dropin&quot;:0,&quot;dropout&quot;:369,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:14748522 recv:8111958
4:{&quot;name&quot;:&quot;ap1&quot;,&quot;bytesSent&quot;:0,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:0,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:0 recv:0
5:{&quot;name&quot;:&quot;en0&quot;,&quot;bytesSent&quot;:2744132038,&quot;bytesRecv&quot;:12672282198,&quot;packetsSent&quot;:7843906,&quot;packetsRecv&quot;:9697152,&quot;errin&quot;:0,&quot;errout&quot;:1194,&quot;dropin&quot;:0,&quot;dropout&quot;:666,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:2744132038 recv:12672282198
6:{&quot;name&quot;:&quot;en1&quot;,&quot;bytesSent&quot;:0,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:0,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:0 recv:0
7:{&quot;name&quot;:&quot;en2&quot;,&quot;bytesSent&quot;:0,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:0,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:0 recv:0
8:{&quot;name&quot;:&quot;awdl0&quot;,&quot;bytesSent&quot;:241402,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:1961,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:241402 recv:0
9:{&quot;name&quot;:&quot;llw0&quot;,&quot;bytesSent&quot;:0,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:0,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:0 recv:0
10:{&quot;name&quot;:&quot;utun0&quot;,&quot;bytesSent&quot;:187730,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:1629,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:187730 recv:0
11:{&quot;name&quot;:&quot;utun1&quot;,&quot;bytesSent&quot;:187730,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:1629,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:187730 recv:0
12:{&quot;name&quot;:&quot;en6&quot;,&quot;bytesSent&quot;:20906,&quot;bytesRecv&quot;:6600,&quot;packetsSent&quot;:149,&quot;packetsRecv&quot;:60,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:20906 recv:6600
13:{&quot;name&quot;:&quot;en7&quot;,&quot;bytesSent&quot;:20906,&quot;bytesRecv&quot;:6600,&quot;packetsSent&quot;:149,&quot;packetsRecv&quot;:60,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:20906 recv:6600
14:{&quot;name&quot;:&quot;bridg&quot;,&quot;bytesSent&quot;:0,&quot;bytesRecv&quot;:0,&quot;packetsSent&quot;:0,&quot;packetsRecv&quot;:0,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:0 recv:0
15:{&quot;name&quot;:&quot;bridg&quot;,&quot;bytesSent&quot;:41812,&quot;bytesRecv&quot;:12360,&quot;packetsSent&quot;:298,&quot;packetsRecv&quot;:120,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:41812 recv:12360
16:{&quot;name&quot;:&quot;bridg&quot;,&quot;bytesSent&quot;:41812,&quot;bytesRecv&quot;:12360,&quot;packetsSent&quot;:298,&quot;packetsRecv&quot;:120,&quot;errin&quot;:0,&quot;errout&quot;:0,&quot;dropin&quot;:0,&quot;dropout&quot;:0,&quot;fifoin&quot;:0,&quot;fifoout&quot;:0} send:41812 recv:12360
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 01 Jan 2021 17:37:00 +0000</pubDate>
<dc:creator>常见-youmen</dc:creator>
<og:description>简介 psutil是一个跨平台进程和系统监控的Python库，而gopsutil是其Go语言版本的实现。 Go语言部署简单、性能好的特点非常适合做一些诸如采集系统信息和监控的服务，本文介绍的gopsu</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/you-men/p/14221464.html</dc:identifier>
</item>
<item>
<title>.NET 云原生架构师训练营（模块二 基础巩固 MongoDB 介绍和基础）--学习笔记 - MingsonZheng</title>
<link>http://www.cnblogs.com/MingsonZheng/p/14221398.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MingsonZheng/p/14221398.html</guid>
<description>&lt;ul&gt;&lt;li&gt;mysql vs mongo&lt;/li&gt;
&lt;li&gt;快速开始&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;mysql-vs-mongo&quot;&gt;mysql vs mongo&lt;/h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;对比&lt;/th&gt;
&lt;th&gt;mysql&lt;/th&gt;
&lt;th&gt;mongo&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;数据存储&lt;/td&gt;
&lt;td&gt;table 二维表结构，需要预先定义结构&lt;/td&gt;
&lt;td&gt;json 类文档，不需要预先定义结构。可随意新增或删除字段，新增字段不会对已存在的字段产生影响&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;查询语法&lt;/td&gt;
&lt;td&gt;sql (structured query language)&lt;/td&gt;
&lt;td&gt;mongo&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;索引&lt;/td&gt;
&lt;td&gt;如果不定义索引，则进行全表扫描&lt;/td&gt;
&lt;td&gt;如果不定义索引，则进行全表扫描&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;集群&lt;/td&gt;
&lt;td&gt;支持主从复制&lt;/td&gt;
&lt;td&gt;内置副本集、分片、和自动选举&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;场景&lt;/td&gt;
&lt;td&gt;关系型结构，在多行插入时需要事务保障&lt;/td&gt;
&lt;td&gt;实时数据分析、内容管理、iot设备、移动设备（事务需要有内置副本才可以做）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;数据结构&lt;/td&gt;
&lt;td&gt;结构化、数据 schema 定义清晰&lt;/td&gt;
&lt;td&gt;未知数据结构类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;风险&lt;/td&gt;
&lt;td&gt;sql 注入攻击&lt;/td&gt;
&lt;td&gt;相对来说风险更低&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;4&quot;&gt;&lt;td&gt;分析&lt;/td&gt;
&lt;td&gt;确实需要关系型数据库来保障&lt;/td&gt;
&lt;td&gt;写入并发高，没有 DBA&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2 id=&quot;快速开始&quot;&gt;快速开始&lt;/h2&gt;
&lt;p&gt;安装 mongo in docker&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;docker run -it --volume=/root/docker/mongo01/data:/data/db -p 27017:27017 --name mongo01 -d mongo
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;robt 3t 下载地址：&lt;br/&gt;&lt;a href=&quot;https://download.studio3t.com/robomongo/windows/robo3t-1.4.2-windows-x86_64-8650949.exe&quot; target=&quot;_blank&quot;&gt;https://download.studio3t.com/robomongo/windows/robo3t-1.4.2-windows-x86_64-8650949.exe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;新增数据库books，新增集合author&lt;/p&gt;
&lt;p&gt;增删改查&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;// 插入
db.author.insertOne({&quot;name&quot;:&quot;mingson&quot;, &quot;age&quot;:25}) 
db.author.insertOne({&quot;name&quot;:&quot;jesse&quot;, &quot;age&quot;:18}) 
db.author.insertOne({&quot;name&quot;:&quot;bobo&quot;, &quot;age&quot;:18})

// 查询 
db.getCollection('author').find({&quot;name&quot;:&quot;mingson&quot;})
db.getCollection('author').find({&quot;name&quot;:{$eq:&quot;mingson&quot;}})

// 更新
db.author.updateOne({&quot;name&quot;:&quot;mingson&quot;},{$set:{&quot;age&quot;:20}})

// 删除
db.author.deleteOne({&quot;name&quot;:&quot;bobo&quot;})

// 返回字段，1返回，0不返回
db.getCollection('author').find({&quot;name&quot;:&quot;mingson&quot;},{&quot;name&quot;:1,&quot;_id&quot;:0})

&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;mongo db 文档：&lt;br/&gt;&lt;a href=&quot;https://docs.mongodb.com/manual/introduction/&quot; target=&quot;_blank&quot;&gt;https://docs.mongodb.com/manual/introduction/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;中文 mongo db 手册：&lt;br/&gt;&lt;a href=&quot;https://mongoing.com/docs/tutorial/insert-documents.html&quot; target=&quot;_blank&quot;&gt;https://mongoing.com/docs/tutorial/insert-documents.html&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据库集合文档&quot;&gt;数据库/集合/文档&lt;/h2&gt;
&lt;p&gt;database/collection/document&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;mongo&lt;/th&gt;
&lt;th&gt;mysql&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;database&lt;/td&gt;
&lt;td&gt;database&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;collection&lt;/td&gt;
&lt;td&gt;table&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;document&lt;/td&gt;
&lt;td&gt;row&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;filed&lt;/td&gt;
&lt;td&gt;column&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3 id=&quot;数据库&quot;&gt;数据库&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;数据库的名称是大小写敏感&lt;/li&gt;
&lt;/ul&gt;&lt;pre&gt;
&lt;code&gt;不能包含以下字符（win）：/\.&quot;$*&amp;lt;&amp;gt;:|?
不能包含以下字符（unix/linux）：/\.&quot;$
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;不能超过64个字符&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;集合&quot;&gt;集合&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;不能包含$&lt;/li&gt;
&lt;li&gt;不能为空，不能包含null&lt;/li&gt;
&lt;li&gt;不能以system.开头&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;字段名&quot;&gt;字段名&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;不能为空，不能包含null&lt;/li&gt;
&lt;li&gt;顶级字段不能以$开头&lt;/li&gt;
&lt;li&gt;_id是保留字段名称&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;bosntypes&quot;&gt;BosnTypes&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://mongoing.com/docs/reference/bson-types.html&quot; target=&quot;_blank&quot;&gt;https://mongoing.com/docs/reference/bson-types.html&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;string&lt;/th&gt;
&lt;th&gt;string&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;Boolean&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;int&lt;/td&gt;
&lt;td&gt;int&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;long&lt;/td&gt;
&lt;td&gt;long&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;decimal&lt;/td&gt;
&lt;td&gt;decimal&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;double&lt;/td&gt;
&lt;td&gt;double&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;date&lt;/td&gt;
&lt;td&gt;date&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;timestamp&lt;/td&gt;
&lt;td&gt;timestamp&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;null&lt;/td&gt;
&lt;td&gt;null&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;ul&gt;&lt;li&gt;object&lt;/li&gt;
&lt;li&gt;array&lt;/li&gt;
&lt;li&gt;objectid&lt;/li&gt;
&lt;li&gt;regex&lt;/li&gt;
&lt;li&gt;javascripe&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;&lt;img alt=&quot;知识共享许可协议&quot; src=&quot;https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本作品采用&lt;a rel=&quot;license&quot; href=&quot;http://creativecommons.org/licenses/by-nc-sa/4.0/&quot;&gt;知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议&lt;/a&gt;进行许可。&lt;/p&gt;
&lt;p&gt;欢迎转载、使用、重新发布，但务必保留文章署名 郑子铭 （包含链接： &lt;a href=&quot;http://www.cnblogs.com/MingsonZheng/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/MingsonZheng/&lt;/a&gt; ），不得用于商业目的，基于本文修改后的作品务必以相同的许可发布。&lt;/p&gt;
&lt;p&gt;如有任何疑问，请与我联系 (MingsonZheng@outlook.com) 。&lt;/p&gt;
</description>
<pubDate>Fri, 01 Jan 2021 16:35:00 +0000</pubDate>
<dc:creator>MingsonZheng</dc:creator>
<og:description>2.5.1 MongoDB -- 介绍 mysql vs mongo 快速开始 mysql vs mongo 对比 mysql mongo 数据存储 table 二维表结构，需要预先定义结构 json</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MingsonZheng/p/14221398.html</dc:identifier>
</item>
<item>
<title>简单谈谈网络抓包，特别是thrift 接口 - KANLON</title>
<link>http://www.cnblogs.com/kanlon2015/p/14221216.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kanlon2015/p/14221216.html</guid>
<description>&lt;p&gt;最近，我在公司做这样的一个事情，整理老旧的api服务，需要统计接口的每个请求的ip和请求参数，找出对应的调用的ip，以便通知业务方修改为新的api服务。其中我们的这个api服务调用有分为thrift调用和http调用&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;117.05169686511&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;按照惯例先谈谈最近情况，最近不是刚好跨年吗？看到很多人都在写年度总结，所以我也在写年度总结文章（其实之前我基本没有写过的，今年有点感触，也想记录一下），结果发现写起来有点多，之前还想着元旦前发出来，结果元旦过后，今天我也还在写，而且还写不完，不过也差不多了，预计明天会发出来。然后最近需求比较多，工作比较忙，同时遇到了一个比较麻烦的需求，就想着记录一下，先充当一下这周的文章任务😂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;背景&quot;&gt;背景&lt;/h3&gt;
&lt;p&gt;最近，我在公司做这样的一个事情，整理老旧的api服务，需要统计接口的每个请求的ip和请求参数，找出对应的调用的ip，以便通知业务方修改为新的api服务。其中我们的这个api服务调用有分为thrift调用和http调用，由于之前的旧的服务设计比较简陋，没有通过dubbo 等注册中心调用，也没有完整的监控（不要问我为什么没有，我也很无奈😭），导致我想找出调用ip也找不到，日志里面没有记录。&lt;/p&gt;
&lt;h3 id=&quot;具体操作方法&quot;&gt;具体操作方法&lt;/h3&gt;
&lt;h4 id=&quot;方法一，直接修改业务代码&quot;&gt;方法一，直接修改业务代码&lt;/h4&gt;
&lt;p&gt;刚开始我们是想修改原业务代码，加上调用ip和请求参数的日志打印的。原本以为不会有什么问题，但是我们准备开始动手改造的时候，发现http协议提供的接口，比较好改造，直接 httpRequest 可以获取到客户端ip ，请求参数也很好打印。接着我们打算动手也修改一下thrift 接口的那部分，原本以为都是接口，估计thrift框架也会提供对应的方式获取（我们使用的原生的apche thrift 框架来提供服务），于是网上找了一下，发现thrift 接口好像并 http 接口那么好改造，网上说需要加个监听类，监听请求，类似以下情况：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;     /**
         * 调用RPC服务的时候触发
         * 每调用一次方法，就会触发一次
         */
        public void processContext(ServerContext serverContext, TTransport inputTransport, TTransport outputTransport)
        {
                /**
                 * 把TTransport对象转换成TSocket，然后在TSocket里面获取Socket，就可以拿到客户端IP  (这里有可能转化不成功的，inputTransport 不一定为 TSocket 类来的，还有可能为 TFrmef ，这里依赖于thrift 提供服务的方式 )
                 */
                TSocket socket = (TSocket)inputTransport;
                System.out.println(socket.getSocket().getRemoteSocketAddress());
        }

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;参考：两种方式获取Thrift调用的客户端IP地址&lt;br/&gt;&lt;a href=&quot;https://blog.csdn.net/mn960mn/article/details/50585278&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/mn960mn/article/details/50585278&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但是，我们实际操作的时候，建了这个监听类，起了自己的本地服务，并用单元测试去测试的时候，发现报了以下这样的一个错误。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;org.apache.thrift.transport.TFramedTransport cannot be cast to org.apache.thrift.transport.TSocket
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;说TFramedTransport 不能转成 TSocket 这个类 ，估计是实例类跟要强转的类不一致。&lt;/p&gt;
&lt;p&gt;一开始，还以为自己的写错了，对着网上的博客检查了以下没有问题。只是发现这个实际实例化出来的类不是 TSocket 类型。试了几次后，发现还是不行，于是有根据这个错误在网上找了一下，TFramedTransport 获取 IP&lt;span&gt;(参考这个错误描述： &lt;a href=&quot;https://www.oschina.net/question/858822_2182069&quot; target=&quot;_blank&quot;&gt;https://www.oschina.net/question/858822_2182069&lt;/a&gt;)&lt;/span&gt; 。这才发现，我们的thrift接口提供方式跟网上说的不一样，而我们这种情况，如果需要获取Client Ip ，有这几种方式：1. 修改thrift 框架源码， 2. 重新继承TFramedTransport类重写里面的一个方法。&lt;/p&gt;
&lt;p&gt;看到这两种方法，我们一下子就放弃了，原本想着只是简单加个监控，没想着修改太多东西，如果为了见这样一个监控，改动那么大的，害怕影响业务（我们这个api服务还是挺多业务方在使用的）。&lt;/p&gt;
&lt;h4 id=&quot;方法二，网络抓包&quot;&gt;方法二，网络抓包&lt;/h4&gt;
&lt;p&gt;于是，我们考虑起第二种方案，使用抓包去打印出客户端ip和请求参数。&lt;code&gt;tcpdump&lt;/code&gt; 是一开始就会想到的工具，当用 tcpdump 去抓包的时候，发现 thrift 接口有些是乱码的。接着就网上找一下是否thrift接口的监控工具，一圈下来，说 thrift-tool ，wireshark（tshark）可以使用，然后又去试了，安装了挺久的，发现由于我们机器的ubuntu的版本太久了，安装不了最新的 thrift-tool &lt;span&gt;（这个是安装之后，还要依赖tcpdump的版本，tcpdump版本太老也不行，tcpdump命令重装也重装了很久😰，最后发现也安装不了指定版本）&lt;/span&gt;和 wireshark ，发现都没有办法使用这两种工具。考虑到我们这个api服务都部署在很多老的物理机上面，考虑兼容性问题和可以方便在其他机器上也部署（我们这个api服务分别部署在10多台的物理机上）。&lt;/p&gt;
&lt;p&gt;于是又重新考虑回tcpdump 命令了&lt;span&gt;兜兜转转一圈又回到原点, tcpdump 🐮逼&lt;/span&gt;。简单实验了一下，抓包的出的thrift请求参数和响应结构，如果是英文的，大部分还是能正常显示的，可以根据 判断是否包含 接口请求参数英文关键字 和判断目标ip和端口，获取到对应的请求参数和的请求ip。如果发送的参数为英文tcpdump直接抓包是能显示大部分参数的，需要完整的参数信息也可以通过直接在业务代码中加监控，thrift 接口在代码中监控发送请求参数还是挺简单的，主要是获取请求ip有点麻烦。&lt;/p&gt;
&lt;p&gt;大概命令是这样的（这里假设read为请求参数关键字）&lt;br/&gt;&lt;code&gt;tcpdump -i any -A -s 0 'tcp port 9521' | grep -E &quot;read|&amp;gt; [0-9\.]+9521&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样就可以获取到 thrift 接口请求到的 9521 端口 的访问ip和请求参数，不过打印出来的日志，还需要自己的去处理一下的。基本上的请求参数的上一行就是该请求的ip。&lt;/p&gt;
&lt;h3 id=&quot;总结&quot;&gt;总结&lt;/h3&gt;
&lt;p&gt;这篇文章主要介绍了解决获取 thrift接口 的请求参数和客户端请求 ip 的问题。算作记录一下自己的解决问题的流程。其中顺便了解一下抓包工具 wireshark 的使用，之前一直有听说过这个软件，但是一直没有实际使用过，感觉的确好用。 另外算作也提醒自己在搭建api服务的时候，记得做好每次接口调用ip和请求ip的监控，不然后面接手的人查起来真的想崩溃，例如：我😪。&lt;/p&gt;
&lt;p&gt;这篇也算一篇比较水的文章吧，不过我自己从这次解决问题中还是学到了很多东西的，稍微记录一下：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;wireshark 过滤可以通过 &lt;code&gt;tcp and ip.addr == 127.0.0.1 and thrift&lt;/code&gt; 命令设置在 dispaly filter 来获取目标的请求， thrift 表示协议，不过如果wireshark 版本太低的话，可以识别不了这个协议。&lt;/li&gt;
&lt;li&gt;wireshark 的命令行版本为： tshark&lt;/li&gt;
&lt;li&gt;wireshark 的帮助文档地址 &lt;a href=&quot;https://gitlab.com/wireshark/wireshark/-/wikis/home&quot; target=&quot;_blank&quot;&gt;https://gitlab.com/wireshark/wireshark/-/wikis/home&lt;/a&gt; ,wireshark 的CaptureFilters（捕捉前过滤） 和DisplayFilters（捕捉后筛选） 区别&lt;/li&gt;
&lt;li&gt;&lt;code&gt;sudo tshark -s 512 -i eth0 -n -f 'tcp dst port 9521' -l&lt;/code&gt; tshark 的命令，捕捉tcp 的请求的，参考： &lt;a href=&quot;https://www.cnblogs.com/liun1994/p/6142505.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/liun1994/p/6142505.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;https://s3.ax1x.com/2020/11/25/DdddOS.png&quot; alt=&quot;微信公众号图片&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 01 Jan 2021 15:09:00 +0000</pubDate>
<dc:creator>KANLON</dc:creator>
<og:description>最近，我在公司做这样的一个事情，整理老旧的api服务，需要统计接口的每个请求的ip和请求参数，找出对应的调用的ip，以便通知业务方修改为新的api服务。其中我们的这个api服务调用有分为thrift调</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/kanlon2015/p/14221216.html</dc:identifier>
</item>
<item>
<title>对各向异性高光的理解 - lxycg</title>
<link>http://www.cnblogs.com/leixinyue/p/14221200.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leixinyue/p/14221200.html</guid>
<description>&lt;p&gt;在渲染头发、丝绸等材质时，常要用到各向异性高光(Anisotropic highlighting)。什么是各向异性高光呢？先来个直观的对比，如下面图1、图2。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/leixinyue/1910003/o_210101150208Blinn-Phong.PNG&quot; alt=&quot;Blinn-Phong&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;图1 普通的Blinn-Phong高光&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/leixinyue/1910003/o_210101150200Aniso.PNG&quot; alt=&quot;Aniso&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;图2 各项异性高光&lt;/p&gt;
&lt;p&gt;图1和图2是在同一个场景里、同一个模型(一个球)、相机、光源(只有一个平行光)，甚至它们的漫反射光照也一样，只有高光的计算方法不同。&lt;/p&gt;
&lt;p&gt;图1使用的传统的Blinn-Phong高光，可以看到高光呈一个圆形亮光斑，比较集中。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-glsl&quot;&gt;// Blinn-Phong specular highlight
vec3 col = vec3(0.);
vec3 halfDir = normalize(viewDir + lightDir);
float nh = dot(normal, halfDir);
float spec = pow(nh, 100.);        
col += nl * lightColor * albedo + specColor * spec;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;图2中渲染的是各向异性高光，呈环形，在头发渲染中又称为“天使环”，这里使用的光照模型是&lt;a href=&quot;http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf&quot; target=&quot;_blank&quot;&gt;Kajiya-Kay Model&lt;/a&gt;。在很多游戏中，头发渲染都使用了Kajiya-Kay Model，比如崩坏3(当然崩坏3在这个基础的模型基础上进行了一些创新，主要是一些参数的控制，我后面会说)。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-glsl&quot;&gt;// anisotropic highlighting
// http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf 
// 计算球在当前点的切线
vec3 tangent = SphereTangent(pos, normal);
// 切线偏移，可以移动“天使环”的位置，在上面链接里的PDF中详细说明，我不细说了
//float shift = texelFetch(iChannel0, ivec2(0), 0).r;
//shift = shift * 2. - 1.;
//tangent = ShiftTangent(tangent, normal, shift);

vec3 col = vec3(0.);
vec3 halfDir = normalize(viewDir + lightDir);
float dotTH = dot(tangent, halfDir);
// 关于dirAtten的计算说明见下文
float dirAtten = smoothstep(-1., 0., dotTH);
float sinTH = sqrt(1. - dotTH * dotTH);
// Kajiya-Kay Model
col += nl * lightColor * albedo + dirAtten * specColor * pow(sinTH, 100.);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://images.cnblogs.com/cnblogs_com/leixinyue/1910003/o_210101150213sinT.png&quot; alt=&quot;sinT&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;图3 Kajyiya-Kay Model&lt;/p&gt;
&lt;p&gt;从上面代码来看Kajiya-Kay Model模型使用切线T和半角向量H(即代码中的halfDir)之间夹角的正弦值来计算高光系数(即&lt;code&gt;pow(sinTH,100)&lt;/code&gt;)，而不是Blinn-Phong中的法线和H向量之间夹角的余弦(即&lt;code&gt;pow(nh, 100.)&lt;/code&gt;)。&lt;/p&gt;
&lt;p&gt;图3中，黄色的粗圆柱表示一根头发，T是其切线，V是视线，L是光源方向, H是L和V之间夹角的一半。&lt;strong&gt;其实T和H夹角的正弦恰好就是图3中H和N之间的余弦值&lt;/strong&gt;，这样说来Kajiya-Kay Model本质上还是使用的余弦值来计算高光系数。但是值得注意的是在每根头发的&lt;strong&gt;固定点&lt;/strong&gt;处，T总是保持不变的，N是随视线V变化而变化的，N总是在T和V组成平面内。&lt;strong&gt;也就是在一个被渲染的点处，其法线在各个(视线)方向是不同的&lt;/strong&gt;，&lt;strong&gt;这大概所谓就是的“各向异性”&lt;/strong&gt;。而我们之所以要有T就是为了计算出这个隐藏在背后的法线N。当然，我们不需要计算出这个N的确切值，其蕴含在T和H的正弦值中，V蕴含在H中。&lt;strong&gt;所以，我认为Kajiyaa-Kay Model本质上仍然是Blinn-Phong，只是它用切线T帮我们找到当前视线下的使高光最强的法线N&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外，注意上面的&lt;strong&gt;方向衰减系数dirAtten的计算&lt;/strong&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-glsl&quot;&gt;float dirAtten = smoothstep(-1., 0., dotTH);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为什么要这么计算？貌似好多人都只知道这是个衰减系数，而不知道为什么要这样计算，或者说不太清楚背后的几何意义。这个&lt;strong&gt;方向衰减系数&lt;/strong&gt;其实涉及到两个方向，一个是光源的方向L，一个是视线方向V，它们都蕴含在H中。首先，这里&lt;code&gt;smoothstep&lt;/code&gt;的第3个参数传的是dotTH，即切线和和H的余弦值。而这里&lt;a href=&quot;https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/smoothstep.xhtml&quot; target=&quot;_blank&quot;&gt;&lt;code&gt;smoothstep&lt;/code&gt;&lt;/a&gt;的第1个参数-1表明当dotTH&lt;strong&gt;小于或等于&lt;/strong&gt;-1时(实际上最多等于-1，不会比-1还小，因为所有参与计算的向量都是规范化的)，dirAtten值为0。什么时候dotTH为-1呢，就是图3中，H的方向恰好和T的方向相反时，这时候T和H之间的夹角为180度。而&lt;code&gt;smoothstep&lt;/code&gt;的第2个参数0表明当dotTH&lt;strong&gt;大于或等于&lt;/strong&gt;0时，&lt;code&gt;dirAtten&lt;/code&gt;的值为1。注意dotTH最大值为1，此时T和H的方向刚好相同，两者之间的夹角为0度。所以&lt;code&gt;smoothstep(-1., 0., dotTH)&lt;/code&gt;的作用就是取和切线T角夹在0至180度之间的H。当T和H之间的夹角不在这个范围内时，必然出现H和对应N的点积小于0，即&lt;strong&gt;此时高光为0&lt;/strong&gt; (此时光源照不到当前着色点或相机看不到当前着色点)，此时dirAtten的值就应当为0(即没有高光)。&lt;/p&gt;
&lt;p&gt;另外，一般的我们可以定制各向异性高光的参数，比如计算各向异性高光时&lt;code&gt;dirAtten * specColor * pow(sinTH, 100.);&lt;/code&gt;，其中的100就是一个可调参数，这个参数值越大，“天使环”的越细，其值越大，“天使环”越宽。这一点大家都可以理解。而我们可以更进一步，直接使用一张贴图来控制“天使环”在各处的宽度，使其在各处的宽度不同，甚至可以把“天使环”调成各种有趣的图案，以达到想要的艺术效果。还有渲染头发一般有两个“天”使环，第二个会较暗一些，且是有自己的颜色的，更靠近发根。只要理解了第一个“天使环”的原理，第二个只是在第一个基础上进行了偏移，颜色稍微有点不同而已，我不再赘述。&lt;/p&gt;
&lt;p&gt;我写了一个Shadertoy: &lt;a href=&quot;https://www.shadertoy.com/view/ttccRj&quot; target=&quot;_blank&quot;&gt;Anisotropic highlighting (shadertoy.com)&lt;/a&gt;，有源代码，在电脑上打开浏览器，可在线运行，可进行交互，调整天使环的位置，希望能帮助到一些同学。如果因为某些原因，打不开网址，我也录制了一个[视频](&lt;a href=&quot;https://www.zhihu.com/zvideo/1328388367751114752&quot; target=&quot;_blank&quot;&gt;A shdertoy: Anisotropic Hightlighting - 知乎 (zhihu.com)&lt;/a&gt;)，可在知乎上观看。&lt;/p&gt;
&lt;p&gt;最后，我想记录一下在写这个Shadertoy时用到的一个小技巧: 球的切线的计算。&lt;/p&gt;
&lt;p&gt;在代码中，那个红色的球是用数学公式建模的即 $ length(p - center) = r$，然后从相机处发射射线，判断射线与球是否相交以及距相机的距离，来求得交点，即当前着色点。法线的计算很简单，不赘述。但是怎么计算出切线呢？我是这样做的: 用当前着色点的三维坐标及其法线确定一个平面，然后把当前着色点的y坐标加1(当然加别的数值应该也可以)得到偏移后的一个点，然后把这个偏移后的点再投影到刚刚确定的那个平面上，则投影得到点减去当前着色点得到的向量就是当前着色点的一个切线向量，进行规范化即可。关于平面方程及点投影到平面，可参考这篇文章：平面(Plane) - 知乎 (zhihu.com)。&lt;/p&gt;
&lt;p&gt;代码如下:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-glsl&quot;&gt;// pos是当前着色点的三维坐标
vec3 SphereTangent(vec3 pos, vec3 normal) {
    vec3 posOffseted = pos;
    posOffseted.y += 1.;
    float D = - dot(normal, pos);
    float distToPlane = dot(normal, posOffseted) + D;
    vec3 proj = posOffseted - normal * distToPlane;
    vec3 tangent = normalize(proj - pos);
    return tangent;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我不知道有没有人这样做过，我是临时想到的，实现了一下效果还行。&lt;/p&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.shadertoy.com/view/ttccRj&quot; target=&quot;_blank&quot;&gt;Anisotropic highlighting (shadertoy.com)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://web.engr.oregonstate.edu/~mjb/cs519/Projects/Papers/HairRendering.pdf&quot; target=&quot;_blank&quot;&gt;Hair Rendering and Shading&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/102514602&quot; target=&quot;_blank&quot;&gt;平面(Plane) - 知乎 (zhihu.com)&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Jan 2021 15:05:00 +0000</pubDate>
<dc:creator>lxycg</dc:creator>
<og:description>在渲染头发、丝绸等材质时，常要用到各向异性高光(Anisotropic highlighting)。什么是各向异性高光呢？先来个直观的对比，如下面图1、图2。 图1 普通的Blinn-Phong高光</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/leixinyue/p/14221200.html</dc:identifier>
</item>
<item>
<title> 容器编排系统K8s之访问控制--准入控制 - Linux-1874</title>
<link>http://www.cnblogs.com/qiuhom-1874/p/14220402.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qiuhom-1874/p/14220402.html</guid>
<description>&lt;p&gt;　　前文我们聊到了k8s的访问控制第二关RBAC授权插件的相关话题，回顾请参考：&lt;a href=&quot;https://www.cnblogs.com/qiuhom-1874/p/14216634.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/qiuhom-1874/p/14216634.html&lt;/a&gt;；今天我们来聊一下k8s上的访问控制第三关准入控制相关话题；&lt;/p&gt;
&lt;p&gt;　　在说准入控制之前，我们先来回顾下之前的用户认证和授权，在k8s上用户认证和授权机制都是通过一个个插件进行功能的扩展，我们要要想使用某种用户认证和授权机制，相应的我们应该去启用对应的插件；对于用户认证和授权这两个机制来说，它们的工作逻辑都是一样的，都是一票通过的机制，一票通过是指启有多个插件，只要对应用户来认证或做授权验证，只要有其中的一个插件满足要求，对应的用户就能通过认证，同样的道理验证授权也是，在k8s上授权插件是显式授权的，即只要满足对应定义的授权规则，则对应的验证授权就会被通过，反之没有显式授权的，即便认真通过权限验证也是不能放行的；对于准入控制来说，在k8s上准入控制是通过准入控制器实现的，一个准入控制器就对应了一个插件，我们要使用对应的准入控制器，相应我们也要启用对应的插件才行；在k8s上准入控制、用户认证、授权默认都内置并启用一些插件，我们可以直接编写对应的规则即可；准入控制和用户认证、授权机制不同的是，准入控制的工作逻辑是一票否决机制，所谓一票否决是指在多个准入控制规则当中，只要不满足其中一个规则，对应的请求就是拒绝操作的；对于准入控制来说，它有两种类型，一种是变异型，一种是校验型；所谓变异型是指我们在提交给apiserver进行资源创建时，默认没有指定的对应字段的信息；它会给我们补上，或者我们定义资源的某些属性的值不太规范，它会帮助我们修改对应的属性的值为一个规范的值，然后提交给apiserver；这种准入控制器通常是帮助我们把对应提交的资源创建信息，规范后提交给apiserver，使得我们提交资源的信息是能够满足对应api规范；校验型准入控制器是用来限制我们对应创建资源是否合理，是否满足我们定义的规则，如果不满足就直接拒绝我们创建；这种控制器主要用来限制我们对k8s上的资源的使用；&lt;/p&gt;
&lt;p&gt;　　在k8s上准入控制器的模块有很多，其中比较常用的有LimitRanger、ResourceQuota、ServiceAccount、PodSecurityPolicy等等，对于前面三种准入控制器系统默认是启用的，我们只需要定义对应的规则即可；对于PodSecurityPolicy这种准入控制器，系统默认没有启用，如果我们要使用，就必需启用以后，对应规则才会正常生效；这里需要注意一点，对应psp准入控制器，一定要先写好对应的规则，把规则和权限绑定好以后，在启用对应的准入控制器，否则先启用准入控制器，没有对应的规则，默认情况它是拒绝操作，在k8s上没有显式定义规则都是拒绝，这可能导致现有的k8s系统跑的系统级pod无法正常工作；所以对于psp准入控制器要慎用，如果规则和权限做的足够精细，它会给我们的k8s系统安全带来大幅度的提升，反之，可能导致整个k8s系统不可用；&lt;/p&gt;
&lt;p&gt;　　查看apiserver启用的准入控制器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202101/1503305-20210101150844188-50787004.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：apiserver启用准入控制插件需要使用--enable-admission-plugins选项来指定，该选项可以使用多个值，用逗号隔开表示启用指定的准入控制插件；这里配置文件中显式启用了NodeRestrication这个插件；默认没有写在这上面的内置准入控制器，它也是启用了的，比如LimitRanger、ResourceQuota、ServiceAccount等等；对于不同的k8s版本，内置的准入控制器和启用与否请查看相关版本的官方文档；对于那些没有启动的准入控制器，我们可以在上面选项中直接启用，分别用逗号隔开即可；&lt;/p&gt;
&lt;p&gt;　　LimitRanger控制器&lt;/p&gt;
&lt;p&gt;　　LimitRanger准入控制器是k8s上一个内置的准入控制器，LimitRange是k8s上的一个标准资源，它主要用来定义在某个名称空间下限制pod或pod里的容器对k8s上的cpu和内存资源使用；它能够定义我们在某个名称空间下创建pod时使用的cpu和内存的上限和下限以及默认cpu、内存的上下限；如果我们创建pod时定义了资源上下限，但不满足LimitRange规则中定义的资源上下限，此时LimitRanger就会拒绝我们创建此pod；如果我们在LimitRange规则中定义了默认的资源上下限制，我们创建资源没有指定其资源限制，它默认会使用LimitRange规则中的默认资源限制；同样的逻辑LimitRanger可以限制一个pod使用资源的上下限，它还可以限制pod中的容器的资源上下限，比限制pod更加精准；不管是针对pod还是pod里的容器，它始终只是限制单个pod资源使用；&lt;/p&gt;
&lt;p&gt;　　LimitRange规则定义&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat LimitRang-demo.yaml
apiVersion: v1
kind: Namespace
metadata: 
  name: myns
---
apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-memory-limit-range
  namespace: myns
spec:
  limits:
  - default:
      cpu: 1000m
      memory: 1000Mi
    defaultRequest:
      cpu: 500m
      memory: 500Mi
    min:
      cpu: 500m
      memory: 500Mi
    max:
      cpu: 2000m
      memory: 2000Mi
    maxLimitRequestRatio:
      cpu: 4
      memory: 4
    type: Container
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上清单主要定义了两个资源，一个创建myns名称空间，一个是在对应myns名称空间下定义了LimitRange资源；其中LimitRange资源的名称为cpu-memory-limit-range，default字段用来指定默认容器资源上限值；defaultRequest用来指定默认容器资源下限值；min字段用来指定限制用户指定的资源下限不能小于对应资源的值；max是用来限制用户指定资源上限值不能大于该值；maxLimitRequestRatio字段用来指定资源的上限和下限的比值；即上限是下限的多少倍；type是用来描述对应资源限制的级别，该字段有两个值pod和container；上述资源清单表示在该名称空间下创建pod时，默认不指定其容器的资源限制，就限制对应容器最少要有0.5个核心的cpu和500M的内存；最大为1个核心cpu,1g内存；如果我们手动定义了容器的资源限制，那么对应资源限制最小不能小于cpu为0.5个核心，内存为500M，最大不能超过cpu为2个核心，内存为2000M；如果我们在创建pod时，只指定了容器的资源上限或下限，那么上限最大是下限的的4倍，如果指定cpu上限为2000m那么下限一定不会小于500m，如果只指定了cpu下限为500m那么上限最大不会超过2000m，对于内存也是同样的逻辑；&lt;/p&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f LimitRang-demo.yaml
namespace/myns created
limitrange/cpu-memory-limit-range created
[root@master01 ~]# kubectl get limitrange -n myns
NAME                     CREATED AT
cpu-memory-limit-range   2021-01-01T08:01:24Z
[root@master01 ~]# kubectl describe limitrange cpu-memory-limit-range -n myns                      
Name:       cpu-memory-limit-range
Namespace:  myns
Type        Resource  Min    Max     Default Request  Default Limit  Max Limit/Request Ratio
----        --------  ---    ---     ---------------  -------------  -----------------------
Container   cpu       500m   2       500m             1              4
Container   memory    500Mi  2000Mi  500Mi            1000Mi         4
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：资源清单中如果指定了maxLimitRequestRatio，需要注意min中和max中的对应资源的单位，如果指定的倍数和max与min中指定的值比例不同，它这里会不会让我们创建；如下提示&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f LimitRang-demo.yaml
namespace/myns unchanged
The LimitRange &quot;cpu-limit-range&quot; is invalid: spec.limits[0].maxLimitRequestRatio[memory]: Invalid value: resource.Quantity{i:resource.int64Amount{value:4, scale:0}, d:resource.infDecAmount{Dec:(*inf.Dec)(nil)}, s:&quot;4&quot;, Format:&quot;DecimalSI&quot;}: ratio 4 is greater than max/min = 3.814697
[root@master01 ~]#
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：我们在资源中指定maxLimitRequestRatio，它内部就是使用max/min,所以对应的值必须符合max/min的值；&lt;/p&gt;
&lt;p&gt;　　验证：在myns名称空间下创建一个pod，默认不指定其资源限制，看看它是否会被limitrange规则自动附加其资源限制？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# cat pod-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-demo
  namespace: myns
spec:
  containers:
  - image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    name: nginx
[root@master01 manifests]# kubectl apply -f pod-demo.yaml
pod/nginx-pod-demo created
[root@master01 manifests]# kubectl get pods -n myns
NAME             READY   STATUS    RESTARTS   AGE
nginx-pod-demo   1/1     Running   0          15s
[root@master01 manifests]# kubectl describe pod nginx-pod-demo -n myns
Name:         nginx-pod-demo
Namespace:    myns
Priority:     0
Node:         node01.k8s.org/192.168.0.44
Start Time:   Fri, 01 Jan 2021 16:12:53 +0800
Labels:       &amp;lt;none&amp;gt;
Annotations:  kubernetes.io/limit-ranger: LimitRanger plugin set: cpu, memory request for container nginx; cpu, memory limit for container nginx
Status:       Running
IP:           10.244.1.108
IPs:
  IP:  10.244.1.108
Containers:
  nginx:
    Container ID:   docker://4d566a239fe3f80e823352ff2eb0f4bc9e5ca1c107c62d87a5035e2d70e7d8f2
    Image:          nginx:1.14-alpine
    Image ID:       docker-pullable://nginx@sha256:485b610fefec7ff6c463ced9623314a04ed67e3945b9c08d7e53a47f6d108dc7
    Port:           &amp;lt;none&amp;gt;
    Host Port:      &amp;lt;none&amp;gt;
    State:          Running
      Started:      Fri, 01 Jan 2021 16:12:54 +0800
    Ready:          True
    Restart Count:  0
    Limits:
      cpu:     1
      memory:  1000Mi
    Requests:
      cpu:        500m
      memory:     500Mi
    Environment:  &amp;lt;none&amp;gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-n6tg5 (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  default-token-n6tg5:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-n6tg5
    Optional:    false
QoS Class:       Burstable
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                 node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  33s   default-scheduler  Successfully assigned myns/nginx-pod-demo to node01.k8s.org
  Normal  Pulled     32s   kubelet            Container image &quot;nginx:1.14-alpine&quot; already present on machine
  Normal  Created    32s   kubelet            Created container nginx
  Normal  Started    32s   kubelet            Started container nginx
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到我们在myns名称空间下创建的pod没有指定其容器资源限制，创建pod后，其内部容器自动就有了默认的资源限制；其大小就是我们在定义LimitRange规则中的default和defaultRequite字段中指定的资源限制；&lt;/p&gt;
&lt;p&gt;　　验证：创建一个pod指定其cpu下限为200m,看看对应pod是否允许我们创建？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# cat pod-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-demo2
  namespace: myns
spec:
  containers:
  - image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    name: nginx
    resources:   
      requests:
        cpu: 200m
[root@master01 manifests]# kubectl apply -f pod-demo.yaml 
Error from server (Forbidden): error when creating &quot;pod-demo.yaml&quot;: pods &quot;nginx-pod-demo2&quot; is forbidden: [minimum cpu usage per Container is 500m, but request is 200m, cpu max limit to request ratio per Container is 4, but provided ratio is 5.000000]
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：我们在创建资源清单中限制了容器使用cpu为200m，在应用资源清单时，它这里就不允许我们创建，其原因是我们指定的资源限制规则不满足LimitRange这条准入控制规则，所以对应创建pod的请求被拒绝；这也意味着我们在创建pod时，指定容器资源限制不能低于LimitRange准入控制规则中的最低限制，否则对应pod不被允许创建；&lt;/p&gt;
&lt;p&gt;　　验证：创建pod时指定其cpu最大限制为2500m,看看对应pod是否允许被创建？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# cat pod-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-demo2
  namespace: myns
spec:
  containers:
  - image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    name: nginx
    resources:   
      limits:
        cpu: 2500m
[root@master01 manifests]# kubectl apply -f pod-demo.yaml
Error from server (Forbidden): error when creating &quot;pod-demo.yaml&quot;: pods &quot;nginx-pod-demo2&quot; is forbidden: maximum cpu usage per Container is 2, but limit is 2500m
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到在pod容器里指定对应的资源限制上限大于LimitRange准入控制规则中的max字段的值时，对应pod是不被允许创建；&lt;/p&gt;
&lt;p&gt;　　验证：给定pod容器的cpu上限或下限为对应范围内的值看看对应pod是否允许被创建？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# cat pod-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-demo2
  namespace: myns
spec:
  containers:
  - image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    name: nginx
    resources:   
      requests:
        cpu: 700m
[root@master01 manifests]# kubectl apply -f pod-demo.yaml
pod/nginx-pod-demo2 created
[root@master01 manifests]# kubectl describe pod nginx-pod-demo2 -n myns
Name:         nginx-pod-demo2
Namespace:    myns
Priority:     0
Node:         node03.k8s.org/192.168.0.46
Start Time:   Fri, 01 Jan 2021 16:33:39 +0800
Labels:       &amp;lt;none&amp;gt;
Annotations:  kubernetes.io/limit-ranger: LimitRanger plugin set: memory request for container nginx; cpu, memory limit for container nginx
Status:       Running
IP:           10.244.3.119
IPs:
  IP:  10.244.3.119
Containers:
  nginx:
    Container ID:   docker://4a576eda79e0f2a377ca9d058ee6e64decf45223b720b93c3291eed9c2a920d1
    Image:          nginx:1.14-alpine
    Image ID:       docker-pullable://nginx@sha256:485b610fefec7ff6c463ced9623314a04ed67e3945b9c08d7e53a47f6d108dc7
    Port:           &amp;lt;none&amp;gt;
    Host Port:      &amp;lt;none&amp;gt;
    State:          Running
      Started:      Fri, 01 Jan 2021 16:33:40 +0800
    Ready:          True
    Restart Count:  0
    Limits:
      cpu:     1
      memory:  1000Mi
    Requests:
      cpu:        700m
      memory:     500Mi
    Environment:  &amp;lt;none&amp;gt;
    Mounts:
      /var/run/secrets/kubernetes.io/serviceaccount from default-token-n6tg5 (ro)
Conditions:
  Type              Status
  Initialized       True 
  Ready             True 
  ContainersReady   True 
  PodScheduled      True 
Volumes:
  default-token-n6tg5:
    Type:        Secret (a volume populated by a Secret)
    SecretName:  default-token-n6tg5
    Optional:    false
QoS Class:       Burstable
Node-Selectors:  &amp;lt;none&amp;gt;
Tolerations:     node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
                 node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
Events:
  Type    Reason     Age   From               Message
  ----    ------     ----  ----               -------
  Normal  Scheduled  23s   default-scheduler  Successfully assigned myns/nginx-pod-demo2 to node03.k8s.org
  Normal  Pulled     23s   kubelet            Container image &quot;nginx:1.14-alpine&quot; already present on machine
  Normal  Created    22s   kubelet            Created container nginx
  Normal  Started    22s   kubelet            Started container nginx
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：从上面的示例可以看到，我们给定资源下限，对应资源上限它会用默认值给填充；&lt;/p&gt;
&lt;p&gt;　　ResourceQuota准入控制器&lt;/p&gt;
&lt;p&gt;　　ResourceQuota准入控制器也是k8s上内置的准入控制器，默认该控制器是启用的状态，它主要作用是用来限制一个名称空间下的资源的使用；相对于LimitRanger准入控制器相比，它能防止在一个名称空间下的pod被过多创建时，导致过多占用k8s上的资源；简单讲它是用来在名称空间级别限制用户的资源使用；不同于LimitRanger准入控制器，Resourcequota准入控制器限制的是某个名称空间下的资源，而LimitRanger准入控制器限制的是单个pod或pod中的容器的资源使用；&lt;/p&gt;
&lt;p&gt;　　ResourceQuota资源的创建&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat resourcequota-demo.yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: quota-demo
  namespace: myns
spec:
  hard:
    pods: &quot;5&quot;
    requests.cpu: &quot;5&quot;
    requests.memory: 5Gi
    limits.cpu: &quot;4&quot;
    limits.memory: 10Gi
    count/deployments.apps: &quot;5&quot;
    count/deployments.extensions: &quot;5&quot;
    persistentvolumeclaims: &quot;5&quot;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：ResourceQuota的定义其kind类型为ResourceQuota，群组为核心群组v1；其中spec.hard字段是用来定义对应名称空间下的资源限制规则；pods用来限制在对应名称空间下的pod数量，requests.cpu字段用来限制对应名称空间下所有pod的cpu资源的下限总和；requests.memory用来限制对应名称空间下pod的内存资源的下限总和；limits.cpu用来限制对应名称空间下的podcpu资源的上限总和，limits.memory用来限制对应名称空间下pod内存资源上限总和；count/deployments.apps用来限制对应名称空间下apps群组下的deployments的个数，count/deployments.extensions用来限制对应名称空间下extensions群组下的deployments的数量；以上配置清单表示，在myns名称空间下运行的pod数量不能超过5个，或者所有pod的cpu资源下限总和不能大于5个核心，内存资源下限总和不能大于5G，或者cpu上限资源总和不能大于4个核心，内存上限总和不能超过10G，或者apps群组下的deployments控制器不能超过5个，exetensions群组下的deploy控制器不能超过5个，pv个数不能超过5个；以上条件中任意一个条目不满足，都将无法在对应名称空间创建对应的资源；&lt;/p&gt;
&lt;p&gt;　　应用资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f resourcequota-demo.yaml
resourcequota/quota-demo created
[root@master01 ~]# kubectl get resourcequota -n myns
NAME         AGE   REQUEST                                                                                                                                                      LIMIT
quota-demo   33s   count/deployments.apps: 0/5, count/deployments.extensions: 0/5, persistentvolumeclaims: 0/5, pods: 2/5, requests.cpu: 1200m/5, requests.memory: 1000Mi/5Gi   limits.cpu: 2/4, limits.memory: 2000Mi/10Gi
[root@master01 ~]# kubectl describe resourcequota quota-demo -n myns    
Name:                         quota-demo
Namespace:                    myns
Resource                      Used    Hard
--------                      ----    ----
count/deployments.apps        0       5
count/deployments.extensions  0       5
limits.cpu                    2       4
limits.memory                 2000Mi  10Gi
persistentvolumeclaims        0       5
pods                          2       5
requests.cpu                  1200m   5
requests.memory               1000Mi  5Gi
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到应用资源清单以后，对应名称空间下的资源使用情况可以通过查看resourcequota资源的详细信息就能了解到；从上述resourcequota资源的详细信息中可以看到，当前myns中pod的cpu资源上限已经使用了2颗核心，对应内存的上限是了2000M；&lt;/p&gt;
&lt;p&gt;　　验证：在myns下创建2个cpu资源上限为2000m的pod，看看对应pod是否被允许创建？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# cat pod-demo.yaml
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-demo3
  namespace: myns
spec:
  containers:
  - image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    name: nginx
    resources:   
      limits:
        cpu: 2000m
[root@master01 manifests]# kubectl apply -f pod-demo.yaml
pod/nginx-pod-demo3 created
[root@master01 manifests]# kubectl describe resourcequota quota-demo -n myns
Name:                         quota-demo
Namespace:                    myns
Resource                      Used    Hard
--------                      ----    ----
count/deployments.apps        0       5
count/deployments.extensions  0       5
limits.cpu                    4       4
limits.memory                 3000Mi  10Gi
persistentvolumeclaims        0       5
pods                          3       5
requests.cpu                  3200m   5
requests.memory               1500Mi  5Gi
[root@master01 manifests]# cat pod-demo2.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-demo4
  namespace: myns
spec:
  containers:
  - image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    name: nginx
    resources:   
      limits:
        cpu: 2000m
[root@master01 manifests]# kubectl apply -f pod-demo2.yaml
Error from server (Forbidden): error when creating &quot;pod-demo2.yaml&quot;: pods &quot;nginx-pod-demo4&quot; is forbidden: exceeded quota: quota-demo, requested: limits.cpu=2,requests.cpu=2, used: limits.cpu=4,requests.cpu=3200m, limited: limits.cpu=4,requests.cpu=5
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到在创建第一个pod时，对应pod成功创建，在创建第二个pod时，对应pod就能正常创建，其原因是对应myns名称空间下正常处于运行状态的pod的cpu资源上限总和已经和resourcequota准入控制规则中的limit.cpus字段的值一样了，再次创建pod时，myns名称空间下的pod的cpu资源上限总和大于limit.cpus的值，所以不满足resourcequota准入控制规则，所以第二个pod就不允许被创建；&lt;/p&gt;
&lt;p&gt;　　示例：使用resourcequota资源限制名称空间下的storage资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat resourcequota-storage-demo.yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: quota-storage-demo
  namespace: default
spec:
  hard:
    requests.storage: &quot;5Gi&quot;
    persistentvolumeclaims: &quot;5&quot;
    requests.ephemeral-storage: &quot;1Gi&quot;
    limits.ephemeral-storage: &quot;2Gi&quot;
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：requests.storage用来限制对应名称空间下的存储下限总和，persistenvolumeclaims用来限制pvc总数量，requests.ephemeral-storage用来现在使用本地临时存储的下限总容量；limits.ephemeral-storage用来限制使用本地临时存储上限总容量；以上配置表示在default名称空间下非停止状态的容器存储下限总容量不能超过5G，pvc的数量不能超过5个，本地临时存储下限容量不能超过1G，上限不能超过2G；&lt;/p&gt;
&lt;p&gt;　　应用配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f resourcequota-storage-demo.yaml
resourcequota/quota-storage-demo created
[root@master01 ~]# kubectl get resourcequota                        
NAME                 AGE   REQUEST                                                                                     LIMIT
quota-storage-demo   7s    persistentvolumeclaims: 3/5, requests.ephemeral-storage: 0/1Gi, requests.storage: 3Gi/5Gi   limits.ephemeral-storage: 0/2Gi
[root@master01 ~]# kubectl describe resourcequota quota-storage-demo
Name:                       quota-storage-demo
Namespace:                  default
Resource                    Used  Hard
--------                    ----  ----
limits.ephemeral-storage    0     2Gi
persistentvolumeclaims      3     5
requests.ephemeral-storage  0     1Gi
requests.storage            3Gi   5Gi
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证：在default名称空间下，再创建3个pvc看看对应资源是否被允许创建？&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat pvc-v1-demo.yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-nfs-pv-v4
  namespace: default
spec:
  accessModes:
    - ReadWriteMany
  volumeMode: Filesystem
  resources:
    requests:
      storage: 500Mi
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-nfs-pv-v5
  namespace: default
spec:
  accessModes:
    - ReadWriteMany
  volumeMode: Filesystem
  resources:
    requests:
      storage: 500Mi
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-nfs-pv-v6
  namespace: default
spec:
  accessModes:
    - ReadWriteMany
  volumeMode: Filesystem
  resources:
    requests:
      storage: 500Mi
[root@master01 ~]# kubectl apply -f pvc-v1-demo.yaml
persistentvolumeclaim/pvc-nfs-pv-v4 created
persistentvolumeclaim/pvc-nfs-pv-v5 created
Error from server (Forbidden): error when creating &quot;pvc-v1-demo.yaml&quot;: persistentvolumeclaims &quot;pvc-nfs-pv-v6&quot; is forbidden: exceeded quota: quota-storage-demo, requested: persistentvolumeclaims=1, used: persistentvolumeclaims=5, limited: persistentvolumeclaims=5
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到现在在default名称空间下创建3个pvc时，对应前两个被成功创建，第三个被拒绝了；原因是defualt名称空间下的pvc资源数量已经达到resourcequota准入控制规则中定义的数量，所以不予创建；&lt;/p&gt;
&lt;p&gt;　　示例：创建resourcequota准入控制规则，并限定其生效范围&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat resourcequota-scopes-demo.yaml
apiVersion: v1
kind: ResourceQuota
metadata:
  name: quota-scopes-demo
  namespace: myns
spec:
  hard:
    pods: &quot;5&quot;
  scopes: [&quot;BestEffort&quot;]
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：限制resourcequota准入控制规则生效范围，可以使用scopes字段来指定对应的范围；该字段为一个列表，默认不指定是指所有状态的pod；其中BsetEffort表示匹配对应pod的QOS(服务质量类别)值为BestEffort的pod ；NotBestEffort表示匹配对应pod的QOS值不是BestEffort的pod；Terminating表示匹配对应Pod状态为Terminating状态的pod；NotTerminating表示匹配状态不是Terminating状态的pod；上述清单规则表示只对pod的服务质量类别为BestEffort的pod生效；其他类型的pod不记录到对应规则中；即只能在对应名称空间下创建5个服务质量类别为BestEffort类别的pod；&lt;/p&gt;
&lt;p&gt;　　应用配置清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# kubectl apply -f resourcequota-scopes-demo.yaml
resourcequota/quota-scopes-demo created
[root@master01 ~]# kubectl get quota -n myns
NAME                AGE   REQUEST     LIMIT
quota-scopes-demo   12s   pods: 0/5   
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：限制pod的服务质量类别为BestEffort，只能对pod资源施加，其它资源都不支持；&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-s&quot;&gt;　　PodSecurityPolicy准入控制器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-s&quot;&gt;　　&lt;span class=&quot;pl-s&quot;&gt;PodSecurityPolicy准入控制器主要用来设置pod安全相关的策略，比如是否允许对应pod共享宿主机网络名称空间，是否允许pod允许为特权模式等等；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;pl-s&quot;&gt;&lt;span class=&quot;pl-s&quot;&gt;　　示例：定义psp准入控制器规则&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 psp]# cat psp-privileged.yaml 
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: privileged
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
spec:
  privileged: true
  allowPrivilegeEscalation: true
  allowedCapabilities:
  - '*'
  volumes:
  - '*'
  hostNetwork: true
  hostPorts:
  - min: 0
    max: 65535
  hostIPC: true
  hostPID: true
  runAsUser:
    rule: 'RunAsAny'
  seLinux:
    rule: 'RunAsAny'
  supplementalGroups:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'
[root@master01 psp]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：PodSecurityPolicy是k8s的标准资源，其类型为PodSecurityPolicy，群组版本为policy/v1beta1；其中spec字段用来定义对pod的相关安全属性的定义；privileged用来定义对应pod是否允许运行为特权模式；allowPrivilegeEscalation用来指定是否运行对应容器子进程特权；allowedCapabilities用来指定允许使用内核中的Capabilities功能，“*”表示所有；volumes用来指定可以使用的卷类型列表，*表示可以使用支持的任意类型的的卷；hostNetwork表示是否允许共享宿主机网络名称空间；hostPorts用来指定可以使用宿主机端口范围，min限制端口下限，max限制端口上限；hostIPC表示是否允许共享宿主机的IPC，hostPID表示是否共享宿主机的PID；runAsUser用来指定对应pod允许以那个用户身份运行，RunAsAny表示可以以任意用户身份运行；以上清单主要定义了一个特权psp准入控制规则，通常这类psp应该有应用在对所有系统级pod使用；一般的普通用户创建的pod不应该拥有上述权限；&lt;/p&gt;
&lt;p&gt;　　psp准入控制规则相关属性说明&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202101/1503305-20210101215632887-805293206.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　示例：定义一个非特权psp准入控制法则&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 psp]# cat psp-restricted.yaml
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: restricted
  annotations:
    seccomp.security.alpha.kubernetes.io/allowedProfileNames: 'docker/default'
    seccomp.security.alpha.kubernetes.io/defaultProfileName:  'docker/default'
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    - 'persistentVolumeClaim'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  supplementalGroups:
    rule: 'MustRunAs'
    ranges:
      - min: 1
        max: 65535
  fsGroup:
    rule: 'MustRunAs'
    ranges:
      - min: 1
        max: 65535
  readOnlyRootFilesystem: false
[root@master01 psp]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：定义好上述psp准入控制资源以后，我们还应该把对那个对应准入控制资源绑定到不同的角色上，以实现不同角色拥有不同的psp准入控制法则的使用权限；&lt;/p&gt;
&lt;p&gt;　　示例：定义clusterrole分别关联不同的psp准入控制资源&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 psp]# cat clusterrole-with-psp.yaml 
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: psp:restricted
rules:
- apiGroups: ['policy']
  resources: ['podsecuritypolicies']
  verbs:     ['use']
  resourceNames:
  - restricted
---
kind: ClusterRole
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: psp:privileged
rules:
- apiGroups: ['policy']
  resources: ['podsecuritypolicies']
  verbs:     ['use']
  resourceNames:
  - privileged
[root@master01 psp]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上定义了两个clusterrole，一个名为psp:restricted，该角色主要关联非特权psp资源，其资源名为restricted；第二个clusterrole名为psp:privileged，该角色主要关联特权psp资源；其对应psp资源名称为privileged；&lt;/p&gt;
&lt;p&gt;　　示例：创建clusterrolebinding关联相关用户和组&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 psp]# cat clusterrolebinding-with-psp.yaml 
kind: ClusterRoleBinding
apiVersion: rbac.authorization.k8s.io/v1
metadata:
  name: restricted-psp-user
roleRef:
  kind: ClusterRole
  name: psp:restricted
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: Group
  apiGroup: rbac.authorization.k8s.io
  name: system:authenticated
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: privileged-psp-user
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: psp:privileged
subjects:
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:masters
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:node
- apiGroup: rbac.authorization.k8s.io
  kind: Group
  name: system:serviceaccounts:kube-system
[root@master01 psp]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：以上配置主要创建了两个clusterrolebinding，第一个cluserrolebinding主要把在k8s上认证通过的用户的权限绑定到psp:restricted这个角色上，让其拥有对应的权限，即通过认证的用户拥有非特权psp准入控制法则权限；第二个clusterrolebinding主要绑定了三类用户，第一类是system:masters组上的用户，第二类是system:node组上的用户，第三类是system:serviceaccounts:kube-system组上的用户；这三个组都是系统级别用户，主要是系统及pod和组件使用的组；所以这些用户应该拥有特权psp准入控制法则，对应通过clusterrolebinding绑定到psp:privileged这个角色；&lt;/p&gt;
&lt;p&gt;　　应用上述资源清单&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 psp]# kubectl apply -f psp-privileged.yaml 
podsecuritypolicy.policy/privileged created
[root@master01 psp]# kubectl apply -f psp-restricted.yaml 
podsecuritypolicy.policy/restricted created
[root@master01 psp]# kubectl apply -f clusterrole-with-psp.yaml 
clusterrole.rbac.authorization.k8s.io/psp:restricted created
clusterrole.rbac.authorization.k8s.io/psp:privileged created
[root@master01 psp]# kubectl apply -f clusterrolebinding-with-psp.yaml 
clusterrolebinding.rbac.authorization.k8s.io/restricted-psp-user created
clusterrolebinding.rbac.authorization.k8s.io/privileged-psp-user created
[root@master01 psp]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：应用顺序先应用psp准入控制资源，然后在应用clusterrole资源，最后应用clusterrolebinding资源；&lt;/p&gt;
&lt;p&gt;　　启用psp准入控制器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1503305/202101/1503305-20210101205256525-979367428.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　提示：编辑/etc/kubernetes/manifests/kube-apiserver.yaml文件，找到--enable-admission-plugins选项，在最后加上PodSecurityPolicy用逗号隔开；然后保存退出；对应psp准入控制器就启用了；&lt;/p&gt;
&lt;p&gt;　　验证：把tom用户设置为myns名称空间下的管理员，然后使用tom用户的配置文件在myns下创建一个pod，该pod使用hostNetwork：true选项来共享宿主机网络名称空间，看看是否能够正常将pod创建出来？&lt;/p&gt;
&lt;p&gt;　　设置tom用户为myns名称空间下的管理员&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat tom-rolebinding-myns-admin.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tom-myns-admin
  namespace: myns
roleRef:
  kind: ClusterRole
  name: admin
  apiGroup: rbac.authorization.k8s.io
subjects:
- kind: User
  apiGroup: rbac.authorization.k8s.io
  name: tom
  
[root@master01 ~]# kubectl apply -f tom-rolebinding-myns-admin.yaml
rolebinding.rbac.authorization.k8s.io/tom-myns-admin created
[root@master01 ~]# kubectl get rolebinding -n myns
NAME             ROLE                AGE
tom-myns-admin   ClusterRole/admin   10s
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　验证tom用户证书信息不是在system:master组内&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat /tmp/myk8s.config |grep  client-certificate-data|awk {'print $2'}|base64 -d|openssl x509 -text -noout
Certificate:
    Data:
        Version: 1 (0x0)
        Serial Number:
            f4:39:a9:5d:2f:01:09:2b
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=kubernetes
        Validity
            Not Before: Dec 29 16:29:59 2020 GMT
            Not After : Dec 29 16:29:59 2021 GMT
        Subject: CN=tom, O=myuser
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:b7:02:e8:0d:ca:d5:3f:36:42:20:5c:16:6c:dd:
                    2a:be:53:f3:b7:14:8e:ca:9f:f4:45:4a:61:97:df:
                    3c:e8:c2:cd:2f:d8:80:85:29:3d:87:b1:9b:5e:9b:
                    dd:60:0b:5f:60:46:8f:71:8b:49:1a:a6:48:94:f8:
                    15:0c:f2:98:3c:ab:3a:7c:28:c4:64:76:bf:03:90:
                    53:f7:2b:6d:18:b5:9b:53:d2:7b:e1:9e:56:bd:c6:
                    41:a7:99:0a:20:d9:d3:1b:f2:3d:f8:84:bb:8a:22:
                    c7:66:1f:8e:7a:ee:e7:06:27:90:06:ce:23:69:eb:
                    c7:42:69:13:d3:bd:2a:c2:5f:bd:1d:2c:0a:19:ca:
                    f4:d6:a2:d4:47:73:bb:4e:5a:01:75:37:ba:2f:2b:
                    78:5f:70:3b:ce:5b:46:25:fb:c8:3f:8a:7b:15:ea:
                    85:aa:b0:b9:28:85:1a:fd:4a:7e:f2:92:40:bd:00:
                    2a:6c:08:84:eb:7b:dc:5b:e0:13:71:d3:af:75:e3:
                    6a:23:e1:a5:78:a2:03:ba:bf:e6:1b:bb:37:cc:11:
                    aa:aa:d2:66:10:22:8f:31:a3:4d:f8:79:d2:05:d7:
                    c9:9a:8c:ce:59:7c:30:7e:f1:2d:9a:4a:53:94:cc:
                    83:47:91:ea:6d:4f:01:9c:c9:3d:c6:9d:85:e0:41:
                    5c:ff
                Exponent: 65537 (0x10001)
    Signature Algorithm: sha256WithRSAEncryption
         41:47:71:e6:60:70:5b:b0:5f:9c:47:2d:05:07:fd:93:6d:1b:
         16:c3:fd:c8:d4:2e:45:b3:fd:d0:4c:e7:19:b4:80:86:ae:8f:
         01:5b:26:f7:01:00:3a:e0:0f:b7:ce:6e:0a:a2:e2:84:2c:86:
         cd:d8:cb:42:3a:c6:bd:b0:50:72:2e:35:fb:02:5e:78:0c:ce:
         fa:3d:28:bc:96:63:d0:83:30:93:6f:59:4d:94:27:8d:ea:5c:
         1e:19:1b:35:29:87:cf:76:3b:60:4d:8d:f2:b7:37:9a:5a:b6:
         7c:58:ae:dd:f0:7a:fd:de:b9:9f:77:bb:fb:9c:42:d8:50:bc:
         2f:50:5c:9b:56:4b:90:89:14:c9:52:6d:64:59:dd:3f:53:b1:
         e4:32:91:d5:98:fb:83:fa:78:23:45:0f:53:92:f0:1a:58:81:
         03:f3:a3:b4:0a:83:d3:7c:ef:04:e8:ee:27:df:e8:4f:68:dc:
         df:46:ef:6b:45:7b:c0:bb:55:fd:82:c6:d9:3b:66:26:14:4a:
         fe:79:7d:a1:24:43:ba:20:19:6b:b3:d8:0f:2f:30:2b:d3:22:
         e6:f9:a9:88:38:98:7b:d6:c4:41:17:62:8d:05:6e:1f:c3:e2:
         44:dc:35:a2:7f:ed:70:2f:68:75:50:61:74:41:d2:86:dd:75:
         18:21:a1:c9
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到tom用户的证书中O=myuser，并非system:master；&lt;/p&gt;
&lt;p&gt;　　使用tom用户的配置文件在myns名称空间下创建pod&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# cat pod-demo3.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-demo3
  namespace: myns
spec:
  containers:
  - image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    name: nginx
  hostNetwork: true
[root@master01 manifests]# kubectl apply -f pod-demo3.yaml --kubeconfig=/tmp/myk8s.config
Error from server (Forbidden): error when creating &quot;pod-demo3.yaml&quot;: pods &quot;nginx-pod-demo3&quot; is forbidden: PodSecurityPolicy: unable to admit pod: [spec.securityContext.hostNetwork: Invalid value: true: Host network is not allowed to be used]
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到tom用户在myns名称空间下创建pod并共享宿主机网络名称空间，被apiserver拒绝了；这是因为我们刚才启用了psp准入控制器，对应规则明确规定不在system:master组或system:serviceaccounts:system-kube组或system:node组的所有用户都不能创建pod共享宿主机名称空间；&lt;/p&gt;
&lt;p&gt;　　使用system:master组上的用户创建pod共享宿主机网络名称空间，看看是否可以？&lt;/p&gt;
&lt;p&gt;　　验证：kubectl的证书，看看对应的组是否是system:master&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 ~]# cat /etc/kubernetes/admin.conf |grep client-certificate-data|awk {'print $2'}|base64 -d |openssl x509 -text -noout
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 886870692518705366 (0xc4ecc322d4838d6)
    Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=kubernetes
        Validity
            Not Before: Dec  8 06:38:54 2020 GMT
            Not After : Dec  8 06:38:56 2021 GMT
        Subject: O=system:masters, CN=kubernetes-admin
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
                Public-Key: (2048 bit)
                Modulus:
                    00:c0:4f:cc:45:9b:4a:19:00:a4:af:68:13:f4:39:
                    b0:4c:a8:67:85:af:b3:f7:04:7e:de:16:4b:62:2c:
                    d4:e8:c8:b3:26:39:d2:9a:8e:00:71:ef:82:ff:d3:
                    ad:1a:89:f2:9b:2a:7b:84:c5:5c:85:5a:d0:c5:6e:
                    89:9d:96:e7:ec:db:92:50:f7:4f:a1:d8:14:2e:48:
                    33:de:05:48:f1:aa:36:d1:d3:9c:bf:6d:b9:6b:75:
                    ce:66:a5:72:52:6c:bb:6c:2b:96:98:da:e1:99:1b:
                    d4:51:3d:5d:d4:fa:76:d9:18:c7:d2:37:95:ad:3c:
                    e7:af:87:21:75:1b:96:bb:64:51:f5:ae:44:ba:43:
                    e1:d5:5d:39:57:a1:f0:04:e5:39:6c:af:8c:a6:7e:
                    eb:4f:98:5d:07:ce:da:89:91:08:34:db:67:0b:09:
                    0c:59:3b:16:b0:13:f7:13:b8:fb:6f:54:d1:c9:e5:
                    ce:27:a6:09:af:cc:9d:b5:1e:0a:9c:b4:d2:64:76:
                    cd:35:67:9e:b5:a6:ba:d8:44:e9:c9:e8:0d:fb:c7:
                    00:06:4a:ce:72:67:a7:0e:56:57:8c:75:2a:c7:0f:
                    bb:4a:d9:0c:ec:a1:27:3a:ce:92:13:e4:bf:d1:31:
                    c8:be:20:58:a0:d6:43:f7:21:8a:cb:e3:fe:5e:1d:
                    d9:2d
                Exponent: 65537 (0x10001)
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            X509v3 Extended Key Usage: 
                TLS Web Client Authentication
            X509v3 Authority Key Identifier: 
                keyid:BE:53:44:7A:0F:3D:B0:99:37:F3:D3:52:BE:C1:75:E6:EF:81:DD:13

    Signature Algorithm: sha256WithRSAEncryption
         35:ea:55:af:57:62:46:26:e9:60:59:82:c2:52:55:45:23:f3:
         f9:2a:2a:78:28:6c:26:6a:32:c9:df:75:17:ca:44:0f:7f:2a:
         ae:a5:7b:e5:d0:99:3e:97:27:1d:13:a9:5f:d7:09:29:c8:d9:
         68:a6:c1:c5:e3:28:14:6e:0f:c8:32:4b:06:8a:6b:fe:ba:ce:
         e4:59:b6:70:d4:11:71:cf:e9:c2:dc:da:86:9c:12:82:82:58:
         78:83:32:ac:ff:99:6e:1f:07:e0:9d:02:86:dc:e2:e4:30:a1:
         36:f1:43:cb:a1:13:1c:27:87:19:89:15:38:25:0a:29:dd:66:
         6b:ed:7e:8c:fe:95:8e:10:77:5f:70:47:98:a0:37:4f:9e:57:
         6a:66:35:9c:dc:64:f5:1a:01:cd:45:6e:01:bc:15:6f:6f:cd:
         f6:51:f4:8e:28:14:77:9e:50:42:42:e2:a8:42:76:b5:f9:c8:
         87:bb:a5:3e:64:ce:1c:88:6d:31:99:53:c6:8f:88:f1:72:7c:
         5a:d6:dc:fe:7e:fa:26:d2:e0:f3:b8:47:d5:8b:c7:b2:88:80:
         16:53:38:31:96:19:9a:73:98:c8:c3:30:13:23:71:b7:1d:d4:
         c9:00:c0:b0:99:bf:24:f3:cf:c6:76:27:d2:6e:3a:5f:fc:5c:
         55:25:98:e2
[root@master01 ~]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到对应证书信息中的O=system:master，说明使用kubectl工具加载/etc/kubernetes/admin.config文件，在apiserver上认证会被是被为system:master组上的成员；&lt;/p&gt;
&lt;p&gt;　　使用kubectl 加载/etc/kubernetes/admin.conf 创建pod共享宿主机上的网络名称空间；&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:bash;gutter:true;&quot;&gt;
[root@master01 manifests]# cat pod-demo3.yaml 
apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod-demo3
  namespace: myns
spec:
  containers:
  - image: nginx:1.14-alpine
    imagePullPolicy: IfNotPresent
    name: nginx
  hostNetwork: true
[root@master01 manifests]# kubectl apply -f pod-demo3.yaml --kubeconfig=/etc/kubernetes/admin.conf
pod/nginx-pod-demo3 created
[root@master01 manifests]# kubectl get pod -n myns --kubeconfig=/etc/kubernetes/admin.conf
NAME              READY   STATUS    RESTARTS   AGE
nginx-pod-demo3   1/1     Running   0          20s
[root@master01 manifests]# 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　提示：可以看到使用system:master组上用户的证书在myns名称空间下就能够正常创建共享宿主机网络名称空间的pod；通过上面的示例可以看到对应psp准入控制规则的设置是生效的；&lt;/p&gt;
</description>
<pubDate>Fri, 01 Jan 2021 14:41:00 +0000</pubDate>
<dc:creator>Linux-1874</dc:creator>
<og:description>前文我们聊到了k8s的访问控制第二关RBAC授权插件的相关话题，回顾请参考：https://www.cnblogs.com/qiuhom-1874/p/14216634.html；今天我们来聊一下k8</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/qiuhom-1874/p/14220402.html</dc:identifier>
</item>
<item>
<title>基于Let's Encrypt生成免费证书-支持多域名泛域名证书 - IT胖</title>
<link>http://www.cnblogs.com/FLY_DREAM/p/14221136.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/FLY_DREAM/p/14221136.html</guid>
<description>&lt;p&gt;Let’s Encrypt是一个由非营利性组织互联网安全研究小组（ISRG）提供的免费、自动化和开放的证书颁发机构（CA）。&lt;br/&gt;简单的说，借助Let’s Encrypt颁发的证书可以为我们的网站免费启用HTTPS(SSL/TLS)&lt;/p&gt;
&lt;h2 id=&quot;客户端&quot;&gt;客户端&lt;/h2&gt;
&lt;p&gt;Let’s Encrypt 使用 ACME 协议来验证您对给定域名的控制权并向您颁发证书。要获得 Let’s Encrypt 证书，您需要选择一个要使用的 ACME 客户端软件。Let’s Encrypt 不控制或审查第三方客户端，也不能保证其安全性或可靠性。&lt;/p&gt;
&lt;p&gt;官方提供了几种证书的申请方式方法&lt;/p&gt;
&lt;h3 id=&quot;certbot&quot;&gt;certbot&lt;/h3&gt;
&lt;p&gt;它既可以仅为您获取证书，也可以帮助您安装证书（如果您需要的话）。它易于使用，适用于许多操作系统，并且具有出色的文档。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://certbot.eff.org/&quot; target=&quot;_blank&quot;&gt;https://certbot.eff.org/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;acmesh&quot;&gt;acme.sh&lt;/h3&gt;
&lt;p&gt;目前 Let's Encrypt 免费证书客户端最简单、最智能的 shell 脚本，可以自动发布和续订 Let's Encrypt 中的免费证书&lt;/p&gt;
&lt;h2 id=&quot;安装acmesh&quot;&gt;安装acme.sh&lt;/h2&gt;
&lt;h3 id=&quot;1-自动安装&quot;&gt;1. 自动安装&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;curl https://get.acme.sh | sh&lt;/code&gt; (网络问题可能失败)&lt;/p&gt;
&lt;h3 id=&quot;2-手动安装&quot;&gt;2. 手动安装&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;git clone https://github.com/acmesh-official/acme.sh.git
cd ./acme.sh
./acme.sh --install
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;安装过程如下：&lt;/p&gt;
&lt;ol readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;默认安装到当前用户的主目录$HOME下的.acme.sh文件夹中，即&lt;code&gt;~/.acme.sh/&lt;/code&gt;，之后所有生成的证书也会按照域名放在这个目录下；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;创建指令别名： alias acme.sh=~/.acme.sh/acme.sh， 通过&lt;code&gt;acme.sh&lt;/code&gt;命令方便快速地使用 acme.sh 脚本&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;自动创建cronjob定时任务，每天 0:00 点自动检测所有的证书，如果快过期了，则会自动更新证书&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;#每天 0:00 点自动检测所有的证书, 如果快过期了, 需要更新, 则会自动更新证书
0 0 * * * /root/.acme.sh/acme.sh --cron --home /root/.acme.sh &amp;gt; /dev/null
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;3-测试收否安装成功&quot;&gt;3. 测试收否安装成功&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;user@owen-ubuntu:~$ acme.sh --version
https://github.com/acmesh-official/acme.sh
v2.8.8
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如有版本信息输出则表示环境正常；如果提示命令未找到，执行source ~/.bashrc命令重载一下环境配置文件。&lt;/p&gt;
&lt;p&gt;整个安装过程不会污染已有的系统任何功能和文件，所有的修改都限制在安装目录~/.acme.sh/中。&lt;/p&gt;
&lt;h2 id=&quot;使用acmesh生成证书&quot;&gt;使用acme.sh生成证书&lt;/h2&gt;
&lt;h3 id=&quot;1-http-方式&quot;&gt;1. HTTP 方式&lt;/h3&gt;
&lt;p&gt;http 方式需要在你的网站根目录下放置一个文件, 以此来验证你的域名所有权,完成验证，只需要指定域名, 并指定域名所在的网站根目录，acme.sh 会全自动的生成验证文件, 并放到网站的根目录, 然后自动完成验证，该方式较适合独立域名的站点使用，比如博客站点等&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;./acme.sh  --issue  -d mydomain.com -d www.mydomain.com  --webroot  /home/wwwroot/mydomain.com/

- issue 是acme.sh脚本用来颁发证书的指令；
- d是 --domain的简称，其后面须填写已备案的域名；
- w是 --webroot的简称，其后面须填写网站的根目录。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./acme.sh --issue -d devopsing.site -d www.devopsing.site --webroot /var/www/html/blog/&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;证书签发成功会有如下输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20210101222026.png&quot; alt=&quot;acme-http&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;执行成功，默认为生成如下证书：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;root@ecs-ubuntu18:/etc/nginx/sites-available# ls ~/.acme.sh/devopsing.site/ -l
total 28
-rw-r--r-- 1 root root 1587 Dec 16 12:34 ca.cer
-rw-r--r-- 1 root root 1866 Dec 16 12:34 devopsing.site.cer
-rw-r--r-- 1 root root  642 Dec 16 12:34 devopsing.site.conf
-rw-r--r-- 1 root root 1001 Dec 16 12:33 devopsing.site.csr
-rw-r--r-- 1 root root  232 Dec 16 12:33 devopsing.site.csr.conf
-rw-r--r-- 1 root root 1679 Dec 16 12:33 devopsing.site.key
-rw-r--r-- 1 root root 3453 Dec 16 12:34 fullchain.cer
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果用的apache/nginx服务器, acme.sh 还可以智能的从 nginx的配置中自动完成验证, 不需要指定网站根目录:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;acme.sh --issue -d mydomain.com --apache&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;acme.sh --issue -d mydomain.com --nginx&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-dns-方式&quot;&gt;2. DNS 方式&lt;/h3&gt;
&lt;p&gt;适合用于生成范解析证书&lt;/p&gt;
&lt;p&gt;优势：不需要任何服务器, 不需要任何公网 ip, 只需要 dns 的解析记录即可完成验证&lt;br/&gt;劣势：&lt;code&gt;如果不同时配置 Automatic DNS API，使用这种方式 acme.sh 将无法自动更新证书&lt;/code&gt;，每次都需要手动再次重新解析验证域名所有权`&lt;/p&gt;
&lt;h4 id=&quot;1-生成证书记录&quot;&gt;1. 生成证书记录&lt;/h4&gt;
&lt;p&gt;注意，第一次执行时使用 --issue，-d 指定需要生成证书的域名&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./acme.sh --issue -d *.example.com --dns --yes-I-know-dns-manual-mode-enough-go-ahead-please&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参数解释：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;--dns [dns_hook]    Use dns manual mode or dns api. Defaults to manual mode when argument is omitted.

--yes-I-know-dns-manual-mode-enough-go-ahead-please  Force use of dns manual mode.
See:  https://github.com/acmesh-official/acme.sh/wiki/dns-manual-mode
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2-在域名解析中手动添加txt记录&quot;&gt;2. 在域名解析中手动添加TXT记录&lt;/h4&gt;
&lt;p&gt;如果第一次添加该域名，会提示如下信息，需要在DNS解析中添加&lt;code&gt;TXT&lt;/code&gt;记录，用作判断你是否拥有域名使用权&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;[Wed Dec 16 16:04:49 CST 2020] Add the following TXT record:
[Wed Dec 16 16:04:49 CST 2020] Domain: '_acme-challenge.devopsing.site'
[Wed Dec 16 16:04:49 CST 2020] TXT value: '-jEWdpI**************EVh01_a3ywrW426wmppjuDqXOs'
[Wed Dec 16 16:04:49 CST 2020] Please be aware that you prepend _acme-challenge. before your domain
[Wed Dec 16 16:04:49 CST 2020] so the resulting subdomain will be: _acme-challenge.devopsing.site
[Wed Dec 16 16:04:49 CST 2020] Please add the TXT records to the domains, and re-run with --renew.
[Wed Dec 16 16:04:49 CST 2020] Please add '--debug' or '--log' to check more details.
[Wed Dec 16 16:04:49 CST 2020] See: https://github.com/acmesh-official/acme.sh/wiki/How-to-debug-acme.sh
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20210101215207.png&quot; alt=&quot;aliyun-dns&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证解析生效&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;user@owen-ubuntu:~$ nslookup -q=TXT _acme-challenge.devopsing.site
Server:         127.0.0.53
Address:        127.0.0.53#53

Non-authoritative answer:
_acme-challenge.devopsing.site  text = &quot;-jEWdpI****************1_a3ywrW426wmppjuDqXOs&quot;

Authoritative answers can be found from:
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3-重新生成证书&quot;&gt;3. 重新生成证书&lt;/h4&gt;
&lt;p&gt;注意，这里第二次执行是用的是 --renew&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./acme.sh --renew -d *.example.com --yes-I-know-dns-manual-mode-enough-go-ahead-please&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;./acme.sh --issue -d *.devopsing.site --dns --yes-I-know-dns-manual-mode-enough-go-ahead-please&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20210101222244.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;root@ecs-ubuntu18:/var/log/nginx# ls ~/.acme.sh/\*.devopsing.site/ -l
total 28
-rw-r--r-- 1 root root 1587 Dec 16 16:09  ca.cer
-rw-r--r-- 1 root root 1846 Dec 16 16:09 '*.devopsing.site.cer'
-rw-r--r-- 1 root root  613 Dec 16 16:09 '*.devopsing.site.conf'
-rw-r--r-- 1 root root  980 Dec 16 16:09 '*.devopsing.site.csr'
-rw-r--r-- 1 root root  211 Dec 16 16:09 '*.devopsing.site.csr.conf'
-rw-r--r-- 1 root root 1679 Dec 16 16:04 '*.devopsing.site.key'
-rw-r--r-- 1 root root 3433 Dec 16 16:09  fullchain.cer
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;4-使用dns-api的模式进行证书申请-支持自动更新&quot;&gt;4. 使用DNS API的模式进行证书申请 (支持自动更新)&lt;/h4&gt;
&lt;p&gt;dns 方式的真正强大之处在于可以使用域名解析商提供的 api 自动添加 txt 记录完成验证，acme.sh 目前支持 cloudflare, dnspod, cloudxns, godaddy 以及 ovh 等数十种解析商的自动集成。&lt;/p&gt;
&lt;h5 id=&quot;阿里云dns-api&quot;&gt;阿里云DNS API&lt;/h5&gt;
&lt;p&gt;首先获取阿里云的操作API 的 AccessKey ID和AccessKey Secret&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;export Ali_Key=&quot;key值&quot;
export Ali_Secret=&quot;key Secret&quot;
# 给出的 api id 和 api key 会被自动记录下,下次就不用再次执行上述命令

acme.sh --issue --dns dns_ali -d *.example.com --force
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;export Ali_Key=&quot;LTAI4F****i8qEeKeRios2r&quot;
export Ali_Secret=&quot;nIpymix0s****a0bJNgERE0QzjSrkF&quot;
acme.sh --issue --dns dns_ali -d *.devopsing.site --force
&lt;/code&gt;
&lt;/pre&gt;
&lt;h5 id=&quot;dnspod-api&quot;&gt;DnsPod API&lt;/h5&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;export DP_Id=&quot;1234&quot;
export DP_Key=&quot;sADDsdasdgdsf&quot;
acme.sh --issue  --dns dns_dp   -d *.example.com
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;查看删除证书&quot;&gt;查看/删除证书&lt;/h2&gt;
&lt;p&gt;查看安装证书 &lt;code&gt;acme.sh --list&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20210101222307.png&quot; alt=&quot;acme-list&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;删除证书 &lt;code&gt;acme.sh remove &amp;lt;SAN_Domains&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;user@ecs-ubuntu18:~$ acme.sh remove devopsing.site
[Thu Dec 17 14:05:53 CST 2020] devopsing.site is removed, the key and cert files are in /home/user/.acme.sh/devopsing.site
[Thu Dec 17 14:05:53 CST 2020] You can remove them by yourself.
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;使用acmesh安装证书&quot;&gt;使用acme.sh安装证书&lt;/h2&gt;
&lt;p&gt;上面生成的证书放在了&lt;code&gt;~/.acem.sh/&amp;lt;domain&amp;gt;&lt;/code&gt;目录，使用&lt;code&gt;--installcert&lt;/code&gt;命令，指定目标位置，可将证书copy 到相应的位置&lt;/p&gt;
&lt;h3 id=&quot;nginx-示例&quot;&gt;Nginx 示例&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;acme.sh --installcert -d &amp;lt;domain&amp;gt;.com \
--key-file /etc/nginx/ssl/&amp;lt;domain&amp;gt;.key \
--fullchain-file /etc/nginx/ssl/fullchain.cer \
--reloadcmd &quot;service nginx force-reload&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果要直接加载配置，可以使用 --reloadcmd &quot;service nginx force-reload&quot;，但是由于nginx 的配置可能不尽相同，所以一般选择手动 reload nginx&lt;/p&gt;
&lt;p&gt;注意:Nginx 的配置 ssl_certificate 使用 /etc/nginx/ssl/fullchain.cer ，而非 /etc/nginx/ssl/.cer ，否则 SSL Labs 的测试会报 Chain issues Incomplete 错误&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-conf&quot;&gt;server {
        listen 443 ssl;
        server_name demo.com;
        
        ssl on;
        ssl_certificate      /etc/nginx/ssl/fullchain.cer;
        ssl_certificate_key  /etc/nginx/ssl/&amp;lt;domain&amp;gt;.key;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;apache-示例&quot;&gt;Apache 示例&lt;/h3&gt;
&lt;p&gt;./acme.sh --install-cert -d *.example.com&lt;br/&gt;--cert-file /path/to/certfile/in/apache/cert.pem&lt;br/&gt;--key-file /path/to/keyfile/in/apache/key.pem&lt;br/&gt;--fullchain-file /path/to/fullchain/certfile/apache/fullchain.pem&lt;br/&gt;--reloadcmd &quot;service apache2 force-reload&quot;&lt;/p&gt;
&lt;h2 id=&quot;更新证书&quot;&gt;更新证书&lt;/h2&gt;
&lt;p&gt;目前 Let's Encrypt 的证书有效期是90天，时间到了会自动更新，无需任何操作。但是，也可以强制续签证书：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;acme.sh --renew -d example.com --force&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注：手动添加DNS获取证书的方式无法自动更新，但是使用DNS API的方式进行获取证书可以在证书有效期后自动更新, 你无需任何操作&lt;/p&gt;
&lt;p&gt;强制执行更新任务 &lt;code&gt;acme.sh --cron -f&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://gitee.com/owen2016/pic-hub/raw/master/pics/20210101222329.png&quot; alt=&quot;acme-cron&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;更新acmesh&quot;&gt;更新acme.sh&lt;/h2&gt;
&lt;p&gt;acme 协议和 letsencrypt CA 都在频繁的更新, 因此 acme.sh 也经常更新以保持同步。&lt;/p&gt;
&lt;p&gt;手动更新： &lt;code&gt;acme.sh --upgrade&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;开启自动更新：&lt;code&gt;acme.sh --upgrade --auto-upgrade&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;取消自动更新： &lt;code&gt;acme.sh --upgrade --auto-upgrade 0&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;删除acmesh&quot;&gt;删除acme.sh&lt;/h2&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;user@owen-ubuntu:~$ acme.sh --uninstall
[2020年 12月 18日 星期五 15:55:11 CST] Removing cron job
[2020年 12月 18日 星期五 15:55:11 CST] LE_WORKING_DIR='/home/user/.acme.sh'
[2020年 12月 18日 星期五 15:55:11 CST] Uninstalling alias from: '/home/user/.bashrc'
[2020年 12月 18日 星期五 15:55:11 CST] The keys and certs are in &quot;/home/user/.acme.sh&quot;, you can remove them by yourself.
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Fri, 01 Jan 2021 14:34:00 +0000</pubDate>
<dc:creator>IT胖</dc:creator>
<og:description>Let’s Encrypt是一个由非营利性组织互联网安全研究小组（ISRG）提供的免费、自动化和开放的证书颁发机构（CA）。 简单的说，借助Let’s Encrypt颁发的证书可以为我们的网站免费启用</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/FLY_DREAM/p/14221136.html</dc:identifier>
</item>
<item>
<title>.NET 5 开源工作流框架elsa技术研究 - Eric zhou</title>
<link>http://www.cnblogs.com/tianqing/p/14221030.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tianqing/p/14221030.html</guid>
<description>&lt;p&gt;今天假期第一天，研究了.NET 5开源工作流框架elsa，现在分享给大家。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、框架简介&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;elsa是一个开源的.NET Standard 工作流框架，官方网站：&lt;a class=&quot;external-link&quot; href=&quot;https://elsa-workflows.github.io/elsa-core/&quot; rel=&quot;nofollow&quot;&gt;https://elsa-workflows.github.io/elsa-core/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下列出了Elsa的一些关键功能：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;小巧，简单，快速。该库非常精简易用，同时快速执行并且易于通过自定义活动进行扩展。&lt;/li&gt;
&lt;li&gt;调用任意工作流程，就好像它们是我应用程序的功能一样。&lt;/li&gt;
&lt;li&gt;触发事件，使相应的工作流程基于该事件自动启动/恢复。&lt;/li&gt;
&lt;li&gt;支持长期运行的工作流程。当工作流程执行并遇到需要进行例如用户输入后，工作流将停止，保留并耗尽内存，直到可以恢复为止。这可能是几秒钟后，几分钟，几小时，几天甚至几年的时间。&lt;/li&gt;
&lt;li&gt;将工作流与特定于应用程序的数据相关联。这是长时间运行的工作流程的关键要求。&lt;/li&gt;
&lt;li&gt;以基于文件的格式存储工作流，因此我可以使其成为源代码管理的一部分。&lt;/li&gt;
&lt;li&gt;当我不想让工作流成为源代码管理的一部分时，可以将其存储在数据库中。&lt;/li&gt;
&lt;li&gt;基于Web版本的流程设计器。无论是将工作流存储在文件系统还是数据库中，还是将设计器在线托管还是仅在本地计算机上托管，都需要能够在线编辑工作流。&lt;/li&gt;
&lt;li&gt;使用表达式配置工作流程活动。通常，工作流处理的信息本质上是动态的，活动需要一种与该信息进行交互的方式。工作流表达式支持这类场景。&lt;/li&gt;
&lt;li&gt;可通过特定于应用程序的活动，支持自定义存储和脚本引擎进行扩展。&lt;/li&gt;
&lt;li&gt;调用其他工作流程。这允许从各种工作流程中调用可重用的应用程序逻辑。就像从C＃调用通用功能一样。&lt;/li&gt;
&lt;li&gt;查看和分析执行的工作流程实例。查看工作流采用的路径，运行时状态，发生故障的位置并补偿发生故障的工作流。&lt;/li&gt;
&lt;li&gt;支持Web的工作流设计器嵌入我自己的仪表板应用程序中。可以选择创建一个运行所有应用程序逻辑的工作流主机，还可以选择在单个微服务中托管工作流运行时（允许进行编排和编排）。&lt;/li&gt;
&lt;li&gt;关注点分离：工作流核心库，运行时和设计器设计上完全分离。即当工作流宿主不应该依赖于基于Web的设计器时。例如，这允许您实施基于桌面的设计器，或者根本不使用设计器，而仅使用YAML文件。最后，主机只需要工作流程定义和对持久性存储的访问。&lt;/li&gt;
&lt;li&gt;支持本地或云端管理，因为Elsa只是您从应用程序引用的一组NuGet软件包。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;二、产品主要功能&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;   &lt;strong&gt;1. 可视化的工作流编辑器&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;    Elsa带有一个独立的，可重复使用的HTML5工作流设计器Web组件，您可以将其嵌入自己的HTML网页中。设计器完全在客户端运行，并具有丰富的JavaScript API，该API可让您定义自定义插件以扩展其功能。&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202101/23525-20210101214929549-1101625531.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;   2. Dashboard 看板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   Elsa看板使您能够定义工作流程定义并检查执行的工作流程。要设计工作流程，只需右键单击画布，从活动选择器中选择一个活动，对其进行配置，然后拖动多个活动之间的连接以创建从简单的短期运行的工作流程到高级的长期运行的工作流程的流程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  3. 支持长期和短期的工作流模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;   Elsa提供了短期和长期工作流程。可以理解为简单的和复杂的流程设计&lt;/p&gt;
&lt;p&gt;   例如，当您需要实现业务规则引擎时，短时运行的工作流程非常有用，在该流程中，如果工作流程是一个接收输入并返回结果的函数，则可以从应用程序中调用它。&lt;/p&gt;
&lt;p&gt;   长时间运行的工作流能够轻松地实现涉及人和机器的复杂过程。长期运行过程的典型示例是文档批准工作流，其中某些文档的审阅过程涉及多方。这样的工作流程可能涉及计时器，电子邮件，提醒，HTTP请求，用户操作等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; 4. 丰富的工作流活动&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     基本元语：&lt;/strong&gt;是低级的技术活动。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SetVariable&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;      控制流：&lt;/strong&gt;控制流活动提供对过程的控制。例如，Fork活动会将工作流程分为两个或多个执行分支。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ForEach&lt;/li&gt;
&lt;li&gt;Fork&lt;/li&gt;
&lt;li&gt;IfElse&lt;/li&gt;
&lt;li&gt;Join&lt;/li&gt;
&lt;li&gt;Switch&lt;/li&gt;
&lt;li&gt;While&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;     工作流活动：&lt;/strong&gt;活动代表工作流程中的单个步骤。开箱即用的Elsa NuGet套件套件为您提供了一系列不错的活动，主要包含以下工作流活动&lt;/p&gt;
&lt;p&gt;     &lt;strong&gt;工作流程：&lt;/strong&gt;工作流类别中的活动与工作流级别的功能相关，例如相关性和信令。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Correlate&lt;/li&gt;
&lt;li&gt;Finish&lt;/li&gt;
&lt;li&gt;Signaled&lt;/li&gt;
&lt;li&gt;Start&lt;/li&gt;
&lt;li&gt;TriggerSignal&lt;/li&gt;
&lt;li&gt;TriggerWorkflow&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      &lt;strong&gt;控制台活动：&lt;/strong&gt;在实施带有工作流的基于控制台的应用程序时，控制台活动非常有用。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ReadLine&lt;/li&gt;
&lt;li&gt;WriteLine&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;      &lt;strong&gt;DropBox活动：&lt;/strong&gt;Dropbox活动可帮助实现与Dropbox API集成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;SaveToDropbox&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;      电子邮件活动：&lt;/strong&gt;电子邮件活动允许您使用SMTP发送电子邮件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;       HTTP活动：&lt;/strong&gt;能够实现发送传出HTTP请求并响应传入HTTP请求的工作流，非常适合与基于外部Web的API集成。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ReceiveHttpRequest&lt;/li&gt;
&lt;li&gt;SendHttpRequest&lt;/li&gt;
&lt;li&gt;WriteHttpResponse&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;      定时器活动&lt;/strong&gt;：定时器活动可以基于某些基于时间的事件（例如CRON表达式，常规计时器）或在将来的特定时间触发工作流。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;CronEvent&lt;/li&gt;
&lt;li&gt;InstantEvent&lt;/li&gt;
&lt;li&gt;TimerEvent&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;       User Task：&lt;/strong&gt;用户任务事件是用户自定义配置的活动，用户可以执行一系列可能的操作。每个动作对应于活动的结果。用户执行任何这些操作后，工作流将沿适当的路径恢复。这里的想法是您的应用程序将使用选定的操作触发工作流。&lt;/p&gt;
&lt;p&gt;          例如，这可以表示为一组简单的按钮。由您的应用程序决定如何呈现这些操作。&lt;/p&gt;
&lt;p&gt;    &lt;strong&gt;5. 版本控制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;      每个工作流程定义都是版本化的。发布工作流程的新版本时，其版本号会增加。现有工作流程实例仍将使用工作流程定义的先前版本，但新工作流程将使用最新版本。   &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;    6. 持久化支持&lt;/strong&gt;&lt;/p&gt;
&lt;ul readability=&quot;-0.5&quot;&gt;&lt;li&gt;
&lt;p&gt;CosmosDB (DocumentDB)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Entity Framework Core：各类关系型数据库，支持SQLServer&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Memory：Non-persistent, use only for tests and/or short-lived workflows.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MongoDB&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;YesSQL&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;    7. 表达式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;             工作流活动可以使用表达式，这些表达式可以炸运行时执行，使用表达式可以引用其他活动产生的值。Elsa支持以下三种类似的表达式：&lt;/p&gt;
&lt;p&gt;           &lt;strong&gt;  文字表达式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;             文字表达式不是一个真正的解释，当你需要设置，无需运行时计算活动属性的值才会被使用。&lt;/p&gt;
&lt;p&gt;           &lt;strong&gt;  JavaScript表达式：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;             当你需要计算一些数值或读取工作流程中的过程值时通常使用JavaScript表达式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;             液体表达式（这个名字很奇怪，目前还在研究中）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;             当你需要创建一个HTTP请求，HTTP响应的计算通常使用流式表达式，或例如其中主体被标记使用液体发送电子邮件时。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;  &lt;span&gt;  三、产品扩展能力&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Elsa的最重要和最强大的功能之一就是其可扩展性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 工作流活动&lt;/strong&gt;&lt;br/&gt;许多过程是特定业务领域的，并且能够使用代表业务领域的特定语言的一组活动来创建工作流是一项强大的功能。&lt;/p&gt;
&lt;p&gt;用特定领域的活动扩展Elsa非常简单。只需实现一个继承自C＃的C＃类，Activity并在服务容器中注册它，就可以使用了。活动将在工作流设计器中自动变为可用，并且默认情况下其所有公共属性都是可编辑的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 持久化扩展&lt;/strong&gt;&lt;br/&gt;Elsa附带了许多持久性提供程序，例如内存，EF Core，MongoDB，YesSQL和CosmosDB。尽管这些提供程序应满足最常见的需求，但当然不限于这些。实现IWorkflowDefinitionStore为工作流定义提供定制存储，并实现IWorkflowInstanceStore为工作流实例提供定制存储。请注意，用户可以混合和匹配，这意味着您可以例如将EntityFrameworkCoreWorkflowDefinitionStorefor用于工作流定义``。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. JavaScript函数&lt;/strong&gt;&lt;br/&gt;JavaScript表达式附带了一些您可能经常使用的有用的JavaScript函数。例如，它允许您从工作流程中读取变量并引用活动输出值。但是，如果您发现自己需要其他功能，则可以很容易地从您自己的应用程序中扩展功能集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 液体表达式&lt;/strong&gt;&lt;br/&gt;Liquid表达式还附带了一些可能经常使用的有用过滤器。例如，它允许您从工作流程中读取变量并引用活动输出值。但是，如果您发现自己需要其他功能，可以很容易地从您自己的应用程序中扩展过滤器集。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 表达式解析执行&lt;/strong&gt;&lt;br/&gt;也许JavaScript和Liquid还不够好，可以使用用C＃，VBScript或Python编写表达式。只需实现您自己的版本IExpressionEvaluator，即可在服务容器中注册它，即可在任何活动中使用自定义评估程序语法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;  四、与Windows Workflow Foundation对比&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;    目前，微软已经停止更新发展 Windows Workflow Foundation，同时技术社区也在努力做WF to .NET Standard, 但是elsa有以下2点优势：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Elsa intrinsically supports triggering events that starts new workflows and resumes halted workflow instances in an easy to use manner. E.g. workflowHost.TriggerWorkflowAsync(&quot;HttpRequestTrigger&quot;);&quot;will start and resume all workflows that either start with or are halted on the HttpRequestTrigger.Elsa has a web-based workflow designer. I once worked on a project for a customer that was building a huge SaaS platform.&lt;/li&gt;
&lt;li&gt;One of the requirements was to provide a workflow engine and a web-based editor.Although there are commercial workflow libraries and editors out there, the business model required open-source software. We used WF and the re-hosted Workflow Designer. It worked, but it wasn't great.&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;  五、源代码编译构建&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        项目源代码地址：&lt;a class=&quot;external-link&quot; href=&quot;https://github.com/elsa-workflows/elsa-core&quot; rel=&quot;nofollow&quot;&gt;https://github.com/elsa-workflows/elsa-core&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;        通过VS2019，使用克隆的方式，将代码克隆到本地编译构建。&lt;/p&gt;
&lt;p&gt;        &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202101/23525-20210101215815808-388953656.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;   项目使用了Angular，在调试运行前，本地需要完成NPM包安装和JS 编译，所以本地需要先安装NodeJS&lt;/p&gt;
&lt;p&gt;   切换到XX\src\dashboard\Elsa.Dashboard\Theme\argon-dashboard, 执行NPM Install       &lt;/p&gt;
&lt;p&gt;   安装过程中，涉及到Python相关的组件和环境变量配置，所以可能会安装失败，出现异常：&lt;/p&gt;
&lt;p&gt;         checking for Python executable &quot;python2&quot; in the PATH Can't find Python executable &quot;python2.7&quot;, you can set the PYTHON env variable.&lt;/p&gt;
&lt;p&gt;         此时，先删除delete &lt;code&gt;node_modules文件夹&lt;/code&gt;， 然后执行： &lt;code&gt;npm install --global windows-build-tools&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;         python组件安装完成后，执行以下命令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:javascript;gutter:true;&quot;&gt;
npm config set python C:\Users\zhougq\.windows-build-tools\python27\python.exe
 
npm install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202101/23525-20210101215953596-1827349407.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;     NPM Install成功后，在目录src\dashboard\Elsa.Dashboard\Theme\argon-dashboard下执行以下指令：&lt;strong&gt;gulp build&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;     &lt;img src=&quot;https://img2020.cnblogs.com/blog/23525/202101/23525-20210101220007312-723124667.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;       此时elsa Dashboard前端项目全部编译通过。&lt;/p&gt;
&lt;p&gt;接下来可以通过：&lt;/p&gt;
&lt;p&gt;VS：Elsa.Dashboard.Web 项目工程调式&lt;/p&gt;
&lt;p&gt;也可以在Elsa.Dashboard.Web文件件下运行&lt;code&gt;dotnet run&lt;/code&gt;. &lt;/p&gt;
&lt;p&gt;浏览器中直接访问：&lt;a class=&quot;external-link&quot; href=&quot;http://localhost:22174/elsa/home&quot; rel=&quot;nofollow&quot;&gt;http://localhost:port/elsa/home&lt;/a&gt;，就可以使用了elsa了。&lt;/p&gt;

&lt;p&gt;以上是对elsa的初步研究，分享给大家。&lt;/p&gt;

&lt;p&gt;周国庆&lt;/p&gt;
&lt;p&gt;2021/1/1&lt;/p&gt;

</description>
<pubDate>Fri, 01 Jan 2021 14:02:00 +0000</pubDate>
<dc:creator>Eric zhou</dc:creator>
<og:description>今天假期第一天，研究了.NET 5开源工作流框架elsa，现在分享给大家。 一、框架简介 elsa是一个开源的.NET Standard 工作流框架，官方网站：https://elsa-workflo</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tianqing/p/14221030.html</dc:identifier>
</item>
<item>
<title>51 张图助你彻底掌握 HTTP! - ErnestEvan</title>
<link>http://www.cnblogs.com/xiekun/p/14221020.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiekun/p/14221020.html</guid>
<description>&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;前言&lt;/span&gt;&lt;/h2&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如果说 TCP/IP 协议是互联网通信的根基，那么 HTTP 就是其中当之无愧的王者，小到日常生活中的游戏，新闻，大到双十一秒杀等都能看到它的身影，据 NetCraft 统计，目前全球至少有 16 亿个网站、2 亿多个独立域名，而这个庞大网络世界的底层运转机制就是 HTTP，可以毫不夸张的说，无 HTTP 不通信！&lt;/p&gt;
&lt;blockquote class=&quot;multiquote-1&quot; data-tool=&quot;mdnice编辑器&quot; readability=&quot;6&quot;&gt;
&lt;p&gt;画外音: TCP/IP 协议群如下, IP 不是 IP 地址，是 Internet Protocol 的简称 &lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e840892b61940d3901ebb82e89ff3b0~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 应用如此广泛，我们确实必要好好学习下它，不仅有助于我们理解和解释工作中的强制刷新，防盗链等现象和原理，还让我们在设计开源中间件时会有所启发，比如在设计 MQ, Dubbo 这些组件时，第一要务就是要设计协议，在其中你或多或少能看到 HTTP 协议的影子，学习了 HTTP 能让你在设计中间件等组件协议时，提供很好的思路&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将会全面剖析 HTTP 的设计理念，助你彻底掌握 HTTP，相信看完以下问题你会手到擒来！&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;什么是 HTTP，它有什么特点，为什么说 HTTP 是万能的&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;为什么说反爬是个伪命题&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;简要介绍一下 HTTP 0.9, 1.1, 2.0, 3.0 的特点&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;曾经在我司有一位同事在大群里抛了一个问题：在浏览器的地址栏输入图片 url，想预览一下图片，结果却变成了下载图片，你能替他解释一下其中的原因吗&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;DNS 协议了解多少，什么是 DNS 负载均衡&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;HTTP 1.1 唯一一个要求请求头必传的字段是哪个，它有什么作用&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;no-cache 真的是不缓存的意思？你对 HTTP 的缓存了解多少&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;为什么刷新了浏览器器却抓不到请求，而强制刷新却可以抓到，强制刷新到底做了什么事&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;301 和 302 的区别是啥&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;各种协议与 HTTP 的关系&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;老生常谈很多人的误解：GET 和 POST 的区别是啥&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;本文将会从以下几点来展开阐述 HTTP&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;什么是 HTTP&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 全称 &lt;strong&gt;H&lt;/strong&gt;yper&lt;strong&gt;T&lt;/strong&gt;ext &lt;strong&gt;T&lt;/strong&gt;ransfer &lt;strong&gt;P&lt;/strong&gt;rotocol「超文本传输协议」,拆成三个部分来看，即「超文本」,「传输」,「协议」&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f270c9a8848d40349fb5eed90f3d2412~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;超文本&lt;/strong&gt;：即「超越了普通文本的文本」，即音视频，图片，文件的混合体，大家常见的网页很多就内嵌了 img, video 这些标签解析展现而成的图片，视频等，除了这些超文本内容外，最关键的是超文本中含有&lt;strong&gt;超链接&lt;/strong&gt;，超链接意味着网页等文件内容的超文本上可以点击链接到其他页面上，互联网就是通过这样的超链接构成的。 &lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1d9ff53eed474ba6b1f235231aee5f10~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;超链接&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;传输&lt;/strong&gt;: 传输意味着至少有两个参与者，比如 A，B，这意味着 HTTP 协议是个双向协议，一般是将「超文本」按照约定的协议以二进制数据包的形式从 A 传到 B 或 B 传到 A， A &amp;lt;===&amp;gt; B，我们把发起请求的叫请求方，接到请求后返回数据的那一方称为应答方，但需要注意的是传输也不限于两个参与者，&lt;strong&gt;允许中间有中转或者接力&lt;/strong&gt;，只要参与者间遵循约定的协议即可传输。 &lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/743f1249408f4a3189c1d9bb58cef4b7~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;如图示：传输可以有多个参与者，只要遵循相应的协议即可&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;协议&lt;/strong&gt;：HTTP 是一个协议，啥是协议？在日常生活中协议并不少见，比如我们租房时签订的租房协议，入职后和企业签订的劳动合同协议，「协」意味着至少有两人参与，「议」意味着双方要就某项条款达成一致，比如租房协议规定月付 xx 元，劳动合同协议规定月工资 xx 元，协议即对通信双方的约束，双方按照约定传输数据才能进行明白对方的意思，否则便是鸡同鸭讲。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;经过以上解释，我们可以给 HTTP 下一个比较准确的定义了:&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;与 HTTP 相关的各种协议&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 虽然在当今互联网通信中占据统计地位，但要让它生效还必须依赖其他协议或规范的支持&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1. URI 和 URL&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先既然我们要在两点之间传输超文本，那这个超文本该怎么表示？超文本即资源，互联网上资源这么多，如何&lt;strong&gt;唯一标记&lt;/strong&gt;互联网上的资源。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;使用 URI（&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;R&lt;/strong&gt;esource &lt;strong&gt;I&lt;/strong&gt;dentifier） 即&lt;strong&gt;统一资源标识符&lt;/strong&gt;就可以唯一定位互联网上的资源。URI 大家比较少听过，大家更熟悉的可能是 URL（&lt;strong&gt;U&lt;/strong&gt;niform &lt;strong&gt;R&lt;/strong&gt;esource &lt;strong&gt;L&lt;/strong&gt;ocator），即统一资源定位符，URL 其实是 URI 的一种子集，区别就是&lt;strong&gt;URI 定义资源，而 URL 不单定义这个资源，还定义了如何找到这个资源。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;URL 主要由四个部分组成：协议、主机、端口、路径 &lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/660f36af4331458eab61133e31c14718~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;协议&lt;/strong&gt;：即通信双方指定的传输协议，应用最广的当然是本文要介绍的 http 协议，除此之外还有 ftp, mailto，file 等协议。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;主机名&lt;/strong&gt;：存放资源的服务器主机名或 IP 地址，当前有时候服务器由于安全原因还需要对用户进行认证，需要提供用户名和密码，此时需要在 hostname前加 username:password。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;端口&lt;/strong&gt;：整数，可选，省略时使用方案的默认端口，各种传输协议都有默认的端口，如 HTTP 默认用的 80 端口，HTTPS 用的 443 端口，传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;路径&lt;/strong&gt;：即资源在主机上的存放路径，一般表示主机的目录或文件地址&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;parameter&lt;/strong&gt;：用于指定特殊参数的可选项。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;query&lt;/strong&gt;：查询字符串，可选，用于给动态网页或接口传递参数，可有多个参数，用“&amp;amp;”符号隔开，每个参数的名和值用“=”符号隔开。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;fragment&lt;/strong&gt;：浏览器专用，用于指定网络资源中的片断，指定后打开网页可直接定位到 fragment 对应的位置。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;例子如下&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9077cf1949fd4444b42d955873120a65~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. TCP/IP 协议&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在上述 URL 地址中，如果你指定了「www.example.com 」 这样的主机名，最终会被 DNS 解析成 IP 地址然后才开始通信，为啥主机名最终要被解析成 IP 地址才能通信呢，因为 HTTP 协议使用的是 TCP/IP 协议栈，协议栈就是这样规定的，一起来看看 TCP/IP 协议栈各层的功能。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e95ff70547cd460dab06f43078e0f66e~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;TCP/IP协议栈&quot;/&gt;TCP/IP协议栈
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP/IP 协议栈总共有四层&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;link layer: 链接层，负责在以太网，WIFI 这样的底层网络上发送原始数据包，工作在网卡这一层，使用 MAC 地址来标记网络上的设备，所以也叫 MAC 层&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;Internet layer: 网络层，IP 协议即处于这一层，提供路由和寻址的功能，使两终端系统能够互连且决定最佳路径，並具有一定的拥塞控制和流量控制的能力。相当于传送邮件时需要地址一般重要&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;transport layer: 传输层，该层的协议为应用进程提供端到端的&lt;strong&gt;通信服务&lt;/strong&gt;，这层主要有 TCP，UDP 两个协议，TCP 提供面向连接的数据流支持、可靠性、流量控制、多路复用等服务，UDP不提供复杂的控制机制，利用 IP 提供面向无连接的简单消息传输&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;application layer: 即应用层，前面三层已经为网络通信打下了坚实的基础，这层可发挥的空间就大很多了，应用层协议可以想象为不同的服务，每个应用层协议都是为了解决某一类应用问题而生的，每一个服务需要用不同的协议，规定应用进程在通信时所遵循的协议。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;我们可以把前面三层认为是高速公路的基础设施，至于要传什么货物，高速公路是否要关闭等则由应用层决定。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;利用 TCP/IP 协议族进行网络通信时，会通过分层顺序与对方进行通信。每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4966684abdd74ad989d233de9b311260~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接收方收到数据后，同样的，每一层也会解析其首部字段，直到应用层收到相应的数据。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/02296e08700942119bb1372ce4d81702~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;图片来自文末参考链接&quot;/&gt;图片来自文末参考链接
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过这样分层的方式，每个层各司其职，只要管好自己的工作即可，可扩展性很好，比如对于 HTTP 来说，它底层可以用 TCP，也可以用 UDP 来传输，哪天如果再出现了更牛逼的协议，也可以替换之，不影响上下层，这就是计算机中比较有名的分层理论：没有什么是分层解决不了的，如果有那就再分一层。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;IP 包的首部中定义了32 位的源 IP 地址和目的 IP 地址，如下图所示址&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/29c575b9d91840ceb4c3cd3ad025fb88~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所以应用层在请求传输数据时必须事先要知道对方的 IP 地址，然后才能开始传输。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2. DNS 协议&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由上一节可知请求时需要事先知道对方的 IP 地址，但 IP 地址是由「161.117.232.65」这样的数字组成的，正常人根本记不住，想想看，如果我要上个百度，还要先知道它的 IP 地址，那岂不是要疯掉，那怎么办，联系生活场景，想想看，如果我们要打某人电话，记不住他的电话号码，是不是要先到电话本找某个人的名字，然后再打，电话本起的作用就是把姓名翻译成电话号码。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b4d6aa5ed0244aa3a23d692e7d16ea44~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;同样的，正常人只会记住 baidu.com 这样的网址，那就需要有类似电话本这样的翻译器把网址转成 IP 地址，DNS（域名服务器）就是干这个事的&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/85855ee42f0c465db76ce1f8750ad08a~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上面只是 DNS 的简化版本，实际上 DNS 解析无法一步到位，比较复杂，要理解 DNS 的工作机制，首先我们要看懂域名的层级结构，类似 www.baidu.com 这样的网址也叫域名，是一个有层次的结构, 最右边的被称为顶级域名，然后是二级域名，层级关系向左降低，最左边的是主机名，通常用来表示主机的用途，比如 「www」 表示提供万维网服务&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0989f3cb3b5846789825d5df6380090f~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;当然这也不是绝对的，起名的关键只是方便我们记忆而已。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;域名有层次之分，DNS 也是有层次之分，DNS 核心系统是一个三层的树状，分布式结构，基本对应域名结构。&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;根域名服务器（Root DNS Server）: 返回「com」,「cn」,「net」等顶级域名服务器的 IP 地址，&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;顶级域名服务器（Top-level DNS Server）：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 apple.com 域名服务器的 IP 地址；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;权威域名服务器（Authoritative DNS Server）：管理自己域名下主机的 IP 地址，比如 apple.com 权威域名服务器可以返回 www.apple.com 的 IP 地址。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/10ee77c182d34884957fd3627aa75779~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;DNS 核心系统层级结构&quot;/&gt;DNS 核心系统层级结构
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;根域名服务器是关键，必须是众所周知的，找到了它，下面的各级域名服务器才能找到，否则域名解析就无从谈起了。既然知道了 DNS 的层次之分，那么不难猜出请求 www.apple.com 的 DNS 解析如下&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;首先访问根域名服务器，获取「com」顶级域名服务器的地址&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;请求「com」顶级域名服务器，返回「apple.com」域名服务器的地址&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;然后返回「apple.com」域名服务器，返回 www.apple.com 的地址&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上三层解析我们称为 DNS 核心解析系统，那么大家想想，全世界的 PC，app 等设备多如牛毛，如果每发一次请求都要按上面的 DNS 解析来获取 IP，那估计 DNS 解析系统就要炸了，如何缓解这种压力呢，答案是用缓存，事实上很多大公司，或网络运营商都会自建自己的 DNS 服务器，作为用户查询的代理，代替用户请求核心 DNS 系统，这样如果查到的话可以缓存查询记录，再次收到请求的号如果有缓存结果或者缓存未过期，则直接返回原来的缓存结果，大家可能听过 Google 的 8.8.8.8 DNS 解析服务器，这种就是 Google 自建的，我们一般称这种自建的为「非权威域名服务器」。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26e9936e549242c292f6c14706f2b284~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;配置 DNS Server&quot;/&gt;配置 DNS Server
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除了非权威域名服务器，还有浏览器缓存，操作系统缓存（大家熟知的 /etc/hosts 就是操作系统 DSN 缓存的一种）&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这样的话如果请求 www.example.com，dns 的完整解析流程如下:&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f83b466a8a4b45a09786040e17181041~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、 浏览器中输入 www.example.com 后，会先查看 浏览器的 DNS 缓存是否过期，未过期直接取缓存的，已过期会继续请求操作系统的缓存（/etc/hosts 文件等），还未找到，进入步骤 2&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、 请求本地地址配置的 DNS resolver（非权威域名服务器），一般由用户的 Internet 服务提供商 (ISP) 进行管理，例如有线 Internet 服务提供商、DSL 宽带提供商或公司网，MAC 的同学可以打开网络配置中的 DNS Servers 来看下默认 ISP 提供的域名服务器（如果想用其他的非权威域名服务器，填入即可，这样就会覆盖 ISP 提供的默认地址） &lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6d3c7801d92d4db4b8bc2d9b34b7e846~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、 DNS resolver 将 www.example.com 的请求转发到 DNS 根名称服务器, 根服务器返回「.com」顶级域名服务器地址&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、 DNS resolver 再次转发 www.example.com 的请求，这次转发到步骤三获取到的 .com 域的一个 TLD 名称服务器。.com 域的名称服务器使用与 example.com 域相关的四个 Amazon Route 53 名称服务器的名称来响应该请求。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、Amazon Route 53 名称服务器在 example.com 托管区域中查找 www.example.com 记录，获得相关值，例如，Web 服务器的 IP 地址 (192.0.2.44)，并将 IP 地址返回至 DNS 解析程序。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;6、DNS resolver 最终获得用户需要的 IP 地址。解析程序将此值返回至 Web 浏览器。DNS 解析程序还会将 example.com 的 IP 地址缓存 (存储) 您指定的时长，以便它能够在下次有人浏览 example.com 时更快地作出响应。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以用 dig 工具来验证一下上面的请求流程&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d7f9b4766b624e7c860fb99a2418391c~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到请求流程确实与我们的流程图一致！另外我们注意到 ip 地址返回了四个，这样的话 client 可以随机选择其中一个请求，这就是我们常说的 DNS 负载均衡，可有效缓存 server 压力。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;HTTP 报文格式&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接下来我们再介绍下 HTTP 报文格式，通信双方要能正常通信，就必须遵循协议才能理解对方的信息，协议规定了 HTTP 请求和响应报文的格式。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e4a82a28486b4833aa4afb6fe17c68ce~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求和响应报文都由「起始行」，「头部」，「空行」，「实体」 四个部分组成，只不过起始行稍有不同。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;请求报文格式&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看下请求报文的格式&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b50dd25a68ac4874a8362647bc8d3df2~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例如下:&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b59bbee32b944b28aae917dfd9ccd0d~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求方法比较常见的有以下几类&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、 &lt;strong&gt;GET&lt;/strong&gt;: 请求 URL 指定的资源，指定的资源经服务器端解析后返回响应内容，GET 方法具有&lt;strong&gt;幂等性&lt;/strong&gt;，即无论请求多次，都只会返回资源，而&lt;strong&gt;不会额外创建或改变资源&lt;/strong&gt;， GET 请求只传请求头，不传请求体。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、 &lt;strong&gt;HEAD&lt;/strong&gt;: 语义上与 GET 类似，但 HEAD 的响应只有请求头，没有请求体&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、 &lt;strong&gt;POST&lt;/strong&gt;: 主要用来创建，修改，上传资源，不具有幂等性，一般将要请求的资源附在&lt;strong&gt;请求体&lt;/strong&gt;上传输&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、 &lt;strong&gt;PUT&lt;/strong&gt;: 修改资源，基本上不用，因为 POST 也具有修改的语义，所以基本上线上大多用 POST 来代替。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;5、 &lt;strong&gt;OPTIONS&lt;/strong&gt;: 列出可对资源实行的方法，这个方法很少见，但在跨域中会用到，也比较重要，后文结合 Cookie 谈到安全问题时我们会再提&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;协议版本指定了客户端当前支持的 HTTP 版本，HTTP 目前通用的有 1.1, 2.0 三个版本，如果请求方指定了 1.1，应答方收到之后也会使用 HTTP 1.1 协议进行回复。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;响应报文格式&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应行的报文格式如下&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/32b09f2091314a238d0f62649cc0baad~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;示例如下&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b0a56ac35c943efa1132012ba9204c9~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;响应报文主要有如下五类状态码：&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;2××：成功，报文已经收到并被正确处理；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;3××：重定向，资源位置发生变动，需要客户端重新发送请求；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;4××：客户端错误，请求报文有误，服务器无法处理；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;5××：服务器错误，服务器在处理请求时内部发生了错误。&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;常用的状态码及其释义如下（更详细的可以参考文末参考链接）&lt;/p&gt;
&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;状态码&lt;/th&gt;
&lt;th&gt;状态码的原因短语&lt;/th&gt;
&lt;th&gt;释义&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;18&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;Continue&lt;/td&gt;
&lt;td&gt;这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;200&lt;/td&gt;
&lt;td&gt;OK&lt;/td&gt;
&lt;td&gt;请求获取/创建资源成功&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;201&lt;/td&gt;
&lt;td&gt;Created&lt;/td&gt;
&lt;td&gt;该请求已成功，并因此创建了一个新的资源，通过用到 POST 请求中&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;206&lt;/td&gt;
&lt;td&gt;Partial Content&lt;/td&gt;
&lt;td&gt;服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;301&lt;/td&gt;
&lt;td&gt;Moved Permanently&lt;/td&gt;
&lt;td&gt;永久重定向，说明请求的资源已经被移动到了由 Location 头部指定的url上，是固定的不会再改变&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;302&lt;/td&gt;
&lt;td&gt;Found&lt;/td&gt;
&lt;td&gt;临时重定向，重定向状态码表明请求的资源被暂时的移动到了由Location 头部指定的 URL 上&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;Bad Request&lt;/td&gt;
&lt;td&gt;1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。2、请求参数有误&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;401&lt;/td&gt;
&lt;td&gt;Unauthorized&lt;/td&gt;
&lt;td&gt;当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;403&lt;/td&gt;
&lt;td&gt;Forbidden&lt;/td&gt;
&lt;td&gt;服务器已经理解请求，但是拒绝执行它，可以认为用户没有权限&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;404&lt;/td&gt;
&lt;td&gt;Not Found&lt;/td&gt;
&lt;td&gt;请求失败，请求所希望得到的资源未被在服务器上发现&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;405&lt;/td&gt;
&lt;td&gt;Method Not Allowed&lt;/td&gt;
&lt;td&gt;请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;Internal Server Error&lt;/td&gt;
&lt;td&gt;服务器遇到意外的情况并阻止其执行请求。&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;502&lt;/td&gt;
&lt;td&gt;Bad Gateway&lt;/td&gt;
&lt;td&gt;此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;了解这些状态码，我们定位排查问题就能成竹在胸，比如看到 5xx，就知道是 server 的逻辑有问题，看到 400 就知道是客户端的请求参数有问题，另一端就不用傻傻去排查了。&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;请求和响应头&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求和响应头部报文的 header 格式基本都是一样的，都是 key-value 的形式，key 和 value 都是用 「: 」分隔，此外 HTTP 头字段非常灵活，除了使用标准的 Host，Connection 等头字段外，也可以任意添加自定义头，&lt;strong&gt;这就给 HTTP 协议带来了无限的扩展可能！&lt;/strong&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;常用头字段&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 协议规定了非常多的头字段，可以实现各种各样的功能，但基本上可以分为以下四类&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;通用字段：在请求头和响应头里都可以出现；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;响应字段：仅能出现在响应头里，补充说明响应报文的信息；&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;对 HTTP 报文的解析和处理其实本质上就是对头字段的处理&lt;/strong&gt;，HTTP 的连接管理，缓存控制，内容协商等都是通过头字段来处理的，&lt;strong&gt;理解了头字段，基本上也就理解了 HTTP&lt;/strong&gt;，所以理解头字段非常重要。接下来我们就来看看这些头部字段的具体含义&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;1、通用字段&lt;/p&gt;
&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;首部字段名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;5&quot;&gt;&lt;tr&gt;&lt;td&gt;Cache-Control&lt;/td&gt;
&lt;td&gt;控制缓存的行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Connection&lt;/td&gt;
&lt;td&gt;逐跳首部、连接的管理&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Date&lt;/td&gt;
&lt;td&gt;创建报文的日期时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Pragma&lt;/td&gt;
&lt;td&gt;报文指令&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Trailer&lt;/td&gt;
&lt;td&gt;报文末端的首部一览&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Transfer-Encoding&lt;/td&gt;
&lt;td&gt;指定报文主体的传输编码方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Upgrade&lt;/td&gt;
&lt;td&gt;升级为其他协议&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Via&lt;/td&gt;
&lt;td&gt;代理服务器的相关信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Warning&lt;/td&gt;
&lt;td&gt;错误通知&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;2、请求首部字段&lt;/p&gt;
&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;首部字段名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;13&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Accept&lt;/td&gt;
&lt;td&gt;用户代理可处理的媒体类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Accept-Charset&lt;/td&gt;
&lt;td&gt;优先的字符集&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Accept-Encoding&lt;/td&gt;
&lt;td&gt;优先的内容编码&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Accept-Language&lt;/td&gt;
&lt;td&gt;优先的语言(自然语言)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Authorization&lt;/td&gt;
&lt;td&gt;Web 认证信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Expect&lt;/td&gt;
&lt;td&gt;期待服务器的特定行为&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;From&lt;/td&gt;
&lt;td&gt;用户的电子邮箱地址&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Host&lt;/td&gt;
&lt;td&gt;请求资源所在服务器&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;If-Match&lt;/td&gt;
&lt;td&gt;比较实体标记(ETag)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;If-Modified-Since&lt;/td&gt;
&lt;td&gt;比较资源的更新时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;If-None-Match&lt;/td&gt;
&lt;td&gt;比较实体标记(与 If-Match 相反)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;If-Range&lt;/td&gt;
&lt;td&gt;资源未更新时发送实体 Byte 的范围请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;If-Unmodified-Since&lt;/td&gt;
&lt;td&gt;比较资源的更新时间(与 If-Modified-Since 相反)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Max-Forwards&lt;/td&gt;
&lt;td&gt;最大传输逐跳数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Proxy-Authorization&lt;/td&gt;
&lt;td&gt;代理服务器要求客户端的认证信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Range&lt;/td&gt;
&lt;td&gt;实体的字节范围请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Referer&lt;/td&gt;
&lt;td&gt;对请求中 URI 的原始获取方 传输编码的优先级&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TE&lt;/td&gt;
&lt;td&gt;传输编码的优先级&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;User-Agent&lt;/td&gt;
&lt;td&gt;HTTP 客户端程序的信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;3、响应首部字段&lt;/p&gt;
&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;首部字段名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;15&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Accept-Ranges&lt;/td&gt;
&lt;td&gt;是否接受字节范围请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Age&lt;/td&gt;
&lt;td&gt;推算资源创建经过时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;ETag&lt;/td&gt;
&lt;td&gt;资源的匹配信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Location&lt;/td&gt;
&lt;td&gt;令客户端重定向至指定 URI&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Retry-After&lt;/td&gt;
&lt;td&gt;对再次发起请求的时机要求&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Server&lt;/td&gt;
&lt;td&gt;HTTP 服务器的安装信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Vary&lt;/td&gt;
&lt;td&gt;代理服务器缓存的管理信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;WWW-Authenticate&lt;/td&gt;
&lt;td&gt;服务器对客户端的认证信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;If-Match&lt;/td&gt;
&lt;td&gt;比较实体标记(ETag)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;If-Modified-Since&lt;/td&gt;
&lt;td&gt;比较资源的更新时间&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;If-None-Match&lt;/td&gt;
&lt;td&gt;比较实体标记(与 If-Match 相反)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;If-Range&lt;/td&gt;
&lt;td&gt;资源未更新时发送实体 Byte 的范围请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;If-Unmodified-Since&lt;/td&gt;
&lt;td&gt;比较资源的更新时间(与 If-Modified-Since 相反)&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Max-Forwards&lt;/td&gt;
&lt;td&gt;最大传输逐跳数&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Proxy-Authorization&lt;/td&gt;
&lt;td&gt;代理服务器要求客户端的认证信息&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Range&lt;/td&gt;
&lt;td&gt;实体的字节范围请求&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Referer&lt;/td&gt;
&lt;td&gt;对请求中 URI 的原始获取方 传输编码的优先级&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;TE&lt;/td&gt;
&lt;td&gt;传输编码的优先级&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;User-Agent&lt;/td&gt;
&lt;td&gt;HTTP 客户端程序的信息&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;4、实体首部字段&lt;/p&gt;
&lt;section class=&quot;table-container&quot; data-tool=&quot;mdnice编辑器&quot;&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;首部字段名&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;9&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Allow&lt;/td&gt;
&lt;td&gt;资源可支持的 HTTP 方法&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Content-Encoding&lt;/td&gt;
&lt;td&gt;实体主体适用的编码方式&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Content-Language&lt;/td&gt;
&lt;td&gt;实体主体的自然语言&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Content-Length&lt;/td&gt;
&lt;td&gt;实体主体的大小(单位 :字节)&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Content-Location&lt;/td&gt;
&lt;td&gt;替代对应资源的 URI&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Content-MD5&lt;/td&gt;
&lt;td&gt;实体主体的报文摘要&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Content-Range&lt;/td&gt;
&lt;td&gt;实体主体的位置范围&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Content-Type&lt;/td&gt;
&lt;td&gt;实体主体的媒体类型&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;Expires&lt;/td&gt;
&lt;td&gt;实体主体过期的日期时间&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/section&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这么多字段该怎么记呢，死记硬背肯定不行，&lt;strong&gt;从功能上理解会更易懂&lt;/strong&gt;，HTTP 主要为我们提供了如下功能&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;一、内容协商&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准，举一个常见的例子，大家在 Chrome 上设置不同的语言，主页也就展示不同的内容&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9a01fcc169324ac393cfc8b67229ed12~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;内容协商示例&quot;/&gt;内容协商示例
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;请求报文的「Accept」，「Accept-Charset」,「Accept-Encoding」，「Accept-Language」,「Content-Language」,即为内容协商的判定标准。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;举个例子&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e51195d5c174ea4bd96daca2c597e20~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;上图表示的含义如下&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;客户端：请给我类型为 text/*，语言为 en，编码类型最好为 br（如果没有 gzip 也可接受）的资源。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;服务器：好的，我找到了编码类型为 br（Content-Encoding: br），内容为 en（Content-Language: en）的资源，它的 url 为 URLe（Content-Location: /URLe），你拿到后再去请求下就有了。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;内容协议请求头和对应的响应头对应关系如下:&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ea9cbe34b34401abc834221ab5b7bb7~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;二、缓存管理&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;缓存管理也是 HTTP 协议非常重要的内容，这部分也是务必要掌握的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;对于资源来说，由于有些挺长时间内都不会更新，所以没必要每次请求都向 server 发起网络请求，如果第一次请求后能保存在本地，下次请求直接在本地取，那无疑会快得多，对服务器的压力也会减少。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;涉及到缓存的请求头为 Cache-Control。这个缓存指令是单向的，也就是说请求中设置的指令，不一定包含在响应中，请求中如果没有传 Cache-Control， server 也可以返回 Cache-Control。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/133a85a2e2754e9695b37d17d142fd10~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如图示：客户端发起请求后，服务器返回 Cache-Control： max-age=30，代表资源在客户端可以缓存 30 秒，30 秒内客户端的请求可以直接从缓存获取，超过 30 秒后需要向服务器发起网络请求。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;max-age&lt;/strong&gt; 是 HTTP 缓存控制最常用的属性，表示资源存储的最长时间，需要注意的是，时间的计算起点是响应报文的创建时刻（即 Date 字段，也就是离开服务器的时刻），超过后客户端需要重新发起请求。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;除此之外，还有其它属性值如下:&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;no-cache&lt;/strong&gt;: &lt;strong&gt;这个是很容易造成误解的字段&lt;/strong&gt;，它的含义并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;no-store&lt;/strong&gt;: &lt;strong&gt;这才是真正的不允许缓存&lt;/strong&gt;，比如秒杀页面这样变化非常频繁的页面就不适合缓存&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e3beb54478064ed08642a146866cc8a9~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;no-cache&quot;/&gt;no-cache
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;must-revalidate&lt;/strong&gt;：一旦资源过期（比如已经超过max-age），在成功向原始服务器验证之前，缓存不能用该资源响应后续请求。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;三者的区别如下：&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/82df8b54f1374097b87493dddbcd2426~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;Cache-Control 只能刷新数据，但不能很好地利用缓存，又因为缓存会失效，使用前还必须要去服务器验证是否是最新版，存在一定的性能稳定，所以 HTTP 又引入了条件缓存。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;条件请求以 If 开头，有「If-Match」，「If-Modified-Since」，「If-None-Match」,「If-Range」,「If-Unmodified-Since」五个头字段，我们最常用的是「if-Modified-Since」和「If-None-Match」这两个头字段，所以重点介绍一下。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;if-Modified-Since&lt;/strong&gt;：指的是文件最后修改时间，服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 响应，需要第一次请求提供「Last-modified」，第二次请求就可以在 「if-Modified-Since」首部带上此值了。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/988d239211cc4ac4917eb1f59f9629a0~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;If-None-Match&lt;/strong&gt;：条件请求首部，对于 &lt;strong&gt;GET&lt;/strong&gt; 和 &lt;strong&gt;HEAD&lt;/strong&gt; 请求方法来说，当且仅当服务器上没有任何资源的 ETag 属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为 200，&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;注意到上图中有个 ETag 返回，它是实体标签（Entity Tag）的缩写，是资源的唯一标识，主要解决修改时间无法准确区分文件变化的问题，比如文件在一秒内修改了多次，由于修改时间是秒级的，用 if-Modified-Since 就会误认为资源没有变化，而每次文件修改了都会修改 ETag，也就是说 ETag 可以精确识别资源的变动, 所以如果对资源变化很敏感觉的话，应该用 If-None-Match。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;注：ETag 有强，弱之分，强 ETag 要求资源在字节级别必须完全相符，弱 ETag 在值前有 「W/」标记，只要求资源在语义上没啥变化，比如加了几个空格等等。&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;需要注意的是不管是 if-Modified-Since 还是 If-None-Match，这两者只会在资源过期（即存活时间超 max-age）后才会触发，但如果在开发环境下，缓存可能会影响我们联调，我们希望每次请求都从 server 拿，而不是缓存里，该怎么办？这种情况下就要用到刷新或者强制刷新了。如果是刷新，请求头里会加上一个 &lt;strong&gt;Cache-Control: max-age=0&lt;/strong&gt;，代表需要最新的资源，浏览器看到了后就不会使用本地资源，会向 server 请求，如果是强制刷新，请求头会加上&lt;strong&gt;Cache-Control: no-cache&lt;/strong&gt;，也会向 server 发送请求，通常刷新和强制刷新效果一下。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;三、实体首部&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于实体部分可以传文本，音视频，文件等，所以一般要指定实体类型，内容大小，编码类型，实体采用的语言（英文，法语）等，这样应答方才会理解其内容。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;先来看最重要的 Content-Type，通常有以下几种数据类型&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b0d232b043e42e0bad3cde99f4bff6b~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些数据类型被称为 MIME 类型，指示资源所属类型，请求方如果要上传资源（一般是 POST 请求），可以在用 Content-Type 指定资源所属类型，如果请求方想要获取资源（GET 请求），可以用 Accept 请求头指定想要获取什么资源，这样 server 找到匹配的资源后就可以在 Content-Type 中指定返回的资源类型，浏览器等客户端看到后就可以据此解析处理了&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c7813464a7440369b9dd8754c7b100a~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;em&gt;&lt;em&gt;如图示：客户端使用 Accept: image/&lt;/em&gt; 告诉服务器，我想请求 png，jpeg，svg 等属于 image 类型的资源，服务端返回图片的同时用 Content-Type: image/png 告诉客户端资源类型为 png。&lt;/em&gt;*&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;通过 Content-Type 指定资源的方式浏览器等客户端就可以据此作出相关解析处理了，再看下开头的问题，为啥请求图片本来希望是能直接在浏览器上展示的，实际上却直接下载了呢，抓包看下它的 Content-Type&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0f3341d1bc64534b4794cfd3028d3d1~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到返回的 Content-Type 是 application/octet-stream，这个类型是应用程序文件的默认值，意思是未知的应用程序文件，浏览器一会不会自动执行或询问执行，会直接下载。那如果希望图片能自动展示在浏览器而非下载呢，server 指定一下 Content-Type 的具体类型如 image/png 这样的形式即可，浏览器识别到了具体类型就会自动解析展示出来。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其他请求方，应答方的实体首部对应关系在上文内容协商部分也给出了，再贴一下图：&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2b1786a532d491f8cb397047b81b4d5~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;四、连接管理&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;连接管理也是 HTTP 非常重要的功能，只不过因为用户无感知，所以被很多人忽略了，实际它是幕后英雄，对提升传输性能起了巨大的作用，也促进 HTTP 不断不断改版衍进的重要原因之一，我们可以从 HTTP 的各个版本来看下连接管理的功能改进。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;首先我们知道双方要建立&lt;strong&gt;可靠&lt;/strong&gt;连接要经过 TCP 的三次握手，然后才能开始传输 HTTP 的报文，报文传输之后要经过四次挥手断开连接&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 0.9，1.0 时期，发送完 HTTP 报文后， 连接立马关闭，这种连接被称为短链接&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/21a6b23c6b4a4a1bb102a9c1eb102455~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到短链接效率非常低下，大量时间浪费在无意义的三次握手和四次挥手上。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;于是 HTTP 1.1 对此进行了改进，每次报文发送后不立即关闭，可复用，我们称这样的链接为长链接，对比下图的长短链接可以看到，长链接由于减少了大量无意义的三次握手，四次挥手，效率大大提升了！&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/577eb3278c6840f99b64e94eab7e8c8a~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们可以在请求头里明确要求使用长链接，指定 &lt;strong&gt;Connection: keep-alive&lt;/strong&gt; 即可，&lt;strong&gt;在 HTTP 1.1 就算不指定也是默认开启的&lt;/strong&gt;。如果服务器支持长链接，不管客户端是否显式要求长链接，它都会在返回头里带上 &lt;strong&gt;Connection: keep-alive&lt;/strong&gt;，这样接下来双方就会使用长连接来收发报文，客户端如果想显式关闭关闭，只需要指定 &lt;strong&gt;Connection: Close&lt;/strong&gt; 头字段即可。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;长连接让传输效率大大提升，但新的问题又来了，因为 HTTP 规定报文必须一发一收，如果在要连接上发多个 HTTP 报文，多个报文会被累积到队列里依次处理（不能并行处理）只要队首的请求被阻塞了，后续 HTTP 的发送就受到影响，这就是有名的&lt;strong&gt;队头阻塞&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5375d7f4d22849ed8e2cd818c762448d~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;队头阻塞&quot;/&gt;队头阻塞
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;虽然 HTTP 1.1 提出了&lt;strong&gt;管线化机制&lt;/strong&gt;，一次可以发送多个请求，但依然要等前一个请求的响应返回后才能处理下一个请求，所以这种机制聊胜于无。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;我们再仔细想想，为啥会有队头阻塞这样的问题，本质上其实是因为我们没法区分每一个请求，再回顾一下我们上文的分层模型&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f0ab304a2ab42e8bd9e1be4a638741f~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;以上是每一层发出的包，每个数据链接层的包（准确地说，链路层的包应该叫帧）规定的 IP 数据报的大小是有限制的，一般把这个大小限制称为&lt;strong&gt;最大传输单元&lt;/strong&gt;（MTU, &lt;strong&gt;M&lt;/strong&gt;aximum &lt;strong&gt;T&lt;/strong&gt;ransmission &lt;strong&gt;U&lt;/strong&gt;nit）, TCP 数据报的大小也是有限制的，我们称之为 MSS（&lt;strong&gt;M&lt;/strong&gt;aximum &lt;strong&gt;T&lt;/strong&gt;ransmission &lt;strong&gt;U&lt;/strong&gt;nit）&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/04c10e08d132413d8315437c47a9d162~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;也就是说对于每一个最终发送的以太网包能传输的应用层数据是有限的，如果上层的应用层要发的数据大小超过了以太网包的大小，就需要对其进行拆分，分成几个以太网包再传输。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e5fa90c045f479dbca064a008f55997~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;接收方拿到每个包的应用层数据再组装成应用层数据，然后一个请求才算接收完成，响应也是类似的原理。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这也是实体首部字段 Content-Length 存在的意义，接收方通过 Content-Length 就可以判断几个请求报文组合后大小是否达到这个设置值，如果是说明报文接收完毕，就可以对请求进行解析了，如果少于这个值，说明还需要接收请求包直到达到这个设定的值。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;**画外音，Content-Length 指的是实体消息首部，也就是在 POST，PUT 等方法中传输实体数据时才会出现，GET 请求不会出现 **&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在底层，每个请求是复用同一个连接的，也就是说每个包发送都是串行的。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c61b613457b840f19c743bd43465bbc8~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在 HTTP 1.1 中，没法区分每个数据包所属的请求，所以它规定每个请求只能串行处理，每个请求通过 Content-Length 判断接收完每个请求的数据包并处理后，才能再处理下一个请求，这样的话如果某个请求处理太慢就会影响后续请求的处理。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 HTTP 2.0 又是如何处理队头阻塞的呢，接下来我们就来揭开一下 HTTP 2.0 的面纱。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;HTTP 2.0 概览&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 2.0 在性能上实现了很大的飞跃，更难得的是它在改进的同时保持了语义的不变，与 HTTP 1.1 的语义完全相同！比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，在我们的日常软件升级中，&lt;strong&gt;向下兼容&lt;/strong&gt;非常重要，也是促进产品大规模使用的一个前提，不然你一升级，各种接口之类的全换了，谁还敢升。 &lt;strong&gt;HTTP 2.0 只在语法上做了重要改进，完全变更了 HTTP 报文的传输格式&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在语法上主要实现了以下改造&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;1、头部压缩&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 1.1 考虑了 body 的压缩，但没有考虑 header 的压缩, 经常出现传了头部上百，上千字节，但 Body 却只有几十字节的情况，浪费了带宽，而且我们知道从 1.1 开始默认是长连接，几百上千个请求都用的这个连接，而请求的头部很多都是重复的，造成了带宽的极大浪费!想象一下面的这个请求，为了传输区区 「name=michale 」这几个字节，却要传输如此巨量的头部，浪费的带宽确实惊人。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/863990434e594f91a09a354ce74093fa~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;那么 HTTP 2.0 是如何解决的呢？它开发了专门的 「HPACK」算法，在客户端和服务器两端建立字典，用索引号表示重复的字符串，还采用哈夫曼编码来压缩数字和整数，可以达到最高达 90% 的压缩率&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a68bef9bb152466bb381e0c2cd1be603~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这里简单解释下，头部压缩需要在支持 HTTP 2.0 的客户端和服务器之间：&lt;/p&gt;
&lt;ol data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;维护一份静态的字典（Static table），包含常见的头部名称，以及特别常见的头部名称与值的组合。这样的话如果请求响应命中了静态字典，直接发索引号即可&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;维护一份相同的动态字典（Dynamic table），可以动态地添加字典，这样的话如果客户端首次请求由于「User-Agent: xxx」,「host:xxx」,「Cookie」这些的动态键值对没有命中静态字典，还是会传给服务器，但服务器收到后会基于传过来的键值对创建动态字典条目，如上图的「User-Agent: xxx」对应数字 62，「host:xxx」对应数字 63，这样双方都创建动态条目后，之后就可以用只传 62，63 这样的索引号来通信了！显而易见，传输数据急遽降低，极大地提升了传输效率！需要注意的是动态字典是每个连接自己维护的，也就是对于每个连接而言，首次都必须发送动态键值对&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;支持基于静态哈夫曼码表的哈夫曼编码（Huffman Coding）：对于静态、动态字典中不存在的内容，可以使用哈夫曼编码来减小体积。HTTP/2 使用了一份静态哈夫曼码表（详见），也需要内置在客户端和服务端之中。&lt;/section&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;2、二进制格式&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 1.1 是纯文本形式，而 2.0 是完全的二进制形式，它把 TCP 协议的部分特性挪到了应用层，把原来的 Header+Body 消息打散为了数个小版的二进制&quot;帧&quot;（Frame）,“HEADERS”帧存放头数据、“DATA”帧存放实体数据&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89058d4943334bd2aaf71c57fc4d31c3~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;HTTP 2.0 二进制帧&quot;/&gt;HTTP 2.0 二进制帧
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这些二进制帧只认 0，1，基于这种考虑 http 2.0 的协议解析决定采用二进制格式，使用二进制的形式虽然对人不友好，但&lt;strong&gt;大大方便了计算机的解析&lt;/strong&gt;，原来使用纯文本容易出现多义性，如大小写，空白字符等，程序在处理时必须用复杂的状态机，&lt;strong&gt;效率低，还麻烦&lt;/strong&gt;。而使用二进制的话可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，&lt;strong&gt;解析起来没有歧义，实现简单，而且体积小、速度快。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;3. 流&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 2 定义了「流」（stream）的的概念，它是二进制帧的双向传输序列，同一个消息往返的数据帧 （header 帧和 data 帧）会分配一个唯一的流 ID，这样我们就能区分每一个请求。在这个虚拟的流里，数据帧按先后次序传输，到达应答方后，将这些数据帧按它们的先后顺序组装起来，最后解析 HTTP 1.1 的请求头和实体。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;在&lt;strong&gt;同一时间&lt;/strong&gt;，请求方可以在流里发请求，应答方也可以也流里发响应，对比 HTTP 1.1 一个连接一次只能处理一次请求-应答，吞吐量大大提升&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/56614ba2d55840f9a44f932fded6e0a7~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如图示，一个连接里多个流可以同时收发请求-应答数据帧，每个流中数据包按序传输组装&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;所有的流都是在同一个连接中流动的，这也是 HTTP 2.0 经典的&lt;strong&gt;多路复用&lt;/strong&gt;（ Multiplexing），另外由于每个流都是独立的，所以谁先处理好请求，谁就可以先将响应通过连接发送给对方，也就解决了队头阻塞的问题。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4be4913473d142d98b28c180a6ccfb55~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;如图示，在 HTTP 2 中，两个请求同时发送，可以同时接收，而在 HTTP 1.1 中必须等上一个请求响应后才能处理下一个请求&lt;/strong&gt;&lt;/p&gt;
&lt;h3 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;&lt;strong&gt;HTTP 2 的队头阻塞&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 2 引入的流，帧等语法层面的改造确实让其传输效率有了质的飞跃，但是它依然存在着队头阻塞，这是咋回事？&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;其实主要是因为 HTTP 2 的分帧主要是在应用层处理的，而分帧最终还是要传给下层的 TCP 层经由它封装后再进行传输，每个连接最终还是顺序传输这些包，&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/711842bf12074605b853539d5534e17e~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;strong&gt;如图示：流只是我们虚拟出来的概念，最终在连接层面还是顺序传的&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;TCP 是可靠连接，为了保证这些包能顺序传给对方，会进行丢包重传机制，如果传了三个包，后两个包传成功，但第一个包传失败了，TCP 协议栈会把已收到的包暂存到缓存区中，停下等待第一个包的重传成功，这样的话在网络不佳的情况下只要一个包阻塞了，由于重传机制，后面的包就被阻塞了，上层应用由于拿不到包也只能干瞪眼了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;由于这是 TCP 协议层面的机制，无法改造，所以 HTTP 2 的队头阻塞是不可避免的。HTTP 3 对此进行了改进，将 TCP 换成了 UDP 来进行传输，由于 UDP 是无序的，不需要断建连，包之间没有依赖关系，所以从根本上解决了“队头阻塞”, 当然由于 UDP 本身的这些特性不足以支撑可靠的通信，所以 Google 在 UDP 的基础上也加了 TCP 的连接管理，拥塞窗口，流量控制等机制，这套协议我们称之为 QUIC 协议。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1ea5aaa61d68480c9d074d1e021eb9b6~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;HTTP 1,2,3 三者对比&quot;/&gt;HTTP 1,2,3 三者对比
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;可以看到不管是 HTTP 2 还是 3 它们底层都支持用 TLS，保留了 HTTPS 安全的特性，这也可以理解，在互联网发展如此迅猛的今天，各大企业也越来越重视通信安全。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;总结：HTTP 的特点&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;说了这么多 HTTP，接下来我们简单总结一下 HTTP 的特点&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、灵活可扩展&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;这可以说是 HTTP 最重要的特点&lt;/strong&gt;，也是 HTTP 能大行其道并碾压其他协议称霸于世的根本原因！它只规定了报文的基本格式，用空格分隔单词，用换行分隔字段，「header+body」等基本语义，但在语法层面并不做限制，它并没有强制规定 header 里应该传什么，也没有限制它底层应该用什么传输，这也为 HTTPS 添加 SSL/TLS 层来加密传输，HTTP2 使用帧，流来进行多路复用，HTTP 3 使用 UDP 彻底解决解决队头阻塞问题提供了可能！后续如果又出现了牛逼的协议，底层也随时可以替换&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、可靠传输&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;不管底层是 TCP 还是 QUIC（底层使用 UDP），它们的传输都是可靠的，都能保证应用层请求响应的可靠传输，这一点很重要，不然传输过程中缺胳膊少腿，应用层就无法解析了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、应用层协议&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 是一个协议，很多人把 HTTP 和 TCP 混在了一起， 就像前文所述，TCP 相当于高速公路，为我们提供了可靠的传输通道，HTTP 规定货物的表现形式（header + 空行+ body），货物是否可从中间站运回（缓存机制）高速公路是否应该关闭（连接控制），&lt;strong&gt;至于货物如何可靠传输到目的地，那是 TCP 的事，与 HTTP 无关&lt;/strong&gt;，这一点也是不少人经常搞混的。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4、请求应答模式&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 需要请求方发起请示，然后应答方对此作出响应，应答方不会无缘无故地发响应给请求方，另外请求和应答方的角色是可以互换的，比如 HTTP 2 中 server 是可以主动 push 给 client 的，这种情况下 server 即为请求方，cilent 即为应答方&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;5、无状态&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;HTTP 的每个请求-应答都是无关的，即每次的收发报文都是完全独立，没有任何联系的，服务器收到每个请求响应后，不会记录这个请求的任何信息，有人说不对啊，为啥我添加多次购物车，购物车列表还能保留我之前加过的商品呢？这就要简单地了解一下 Session 和 Cookie 了，Session 可以认为是 Server 用来追踪每个用户行为的一个会话，server 会给每个用户分配一个这个 Session 的 session，通过 Cookie 这个头字段返回给 client，之后 client 每次请求都会在 Cookie 里带上这个 sessionId，server 拿到 sessionId 之后就知道是哪个用户发起的了&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b49cd687a6104407a7f3921da70b3a37~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;回答开篇问题&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;大部分问题已经隐藏在本文的知识点讲述中了，还有一些问题，我们一起来看下&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;1、为什么说反爬是个伪命题&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;因为不管是正常的客户端请求，还是爬虫请求，都要遵循 HTTP 协议，爬虫发的 HTTP 报文与正常用户请求没有本质区别，服务器无法区分，服务器只能通过一些 trick，如短时间内发现某个 ip 的请求特别频繁认定其为爬虫，直接拒绝服务，或者通过验证码的方式等提高爬虫的难度，但无法彻底杜绝，当然爬虫也有应对之道，它可以在请求的时候不停地更换自己的 ip 以达到欺骗 server 的目的，也可以破解验证码，爬虫和反爬也是在相爱相杀中不断提高破解与被破解的手段了。&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;2、301 与 302 有啥区别&lt;/strong&gt; 这一点其实我在之前的&lt;a href=&quot;https://mp.weixin.qq.com/s/YTrBaERcyjvw7A0Fg2Iegw&quot;&gt;高性能短链设计&lt;/a&gt;有提过，在短链设计中，重定向是一个必须要考虑的点&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d405f5264a254cc58134a6dd5ff94628~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;如图示，输入 A 网址后，会重定向到 B 网址，就需要考虑是用 301 还是 302，两者的区别如下&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;301：代表永久重定向，也就是说第一次请求拿到长链接后，下次浏览器再去请求短链的话，不会向短网址服务器请求了，而是直接从浏览器的缓存里拿，这样在 server 层面就无法获取到短网址的点击数了，如果这个链接刚好是某个活动的链接，也就无法分析此活动的效果。所以我们一般不采用 301。&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;302：代表临时重定向，也就是说每次去请求短链都会去请求短网址服务器（除非响应中用 Cache-Control 或 Expired 暗示浏览器缓存）,这样就便于 server 统计点击数，所以虽然用 302 会给 server 增加一点压力，但在数据异常重要的今天，这点代码是值得的，所以推荐使用 302！&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;3、HTTP 1.1 唯一一个要求请求头必传的字段是哪个，它有什么作用&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;是 Host, HTTP 1.1 允许一台服务器搭建多个 Web 站点，也就是说一台服务器可以托管多个域名对应的网站，这样的话必须指定 Host，到达服务器后才能找到对应的网址向其请求。&lt;/p&gt;
&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2738b0ff139644fdadd9d575e418fef3~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;&lt;strong&gt;4. 老生常谈很多人的误解：GET 和 POST 的区别是啥&lt;/strong&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这个问题很多人都有误解，最常见的误解比如 POST 请求安全，GET参数通过 URL 传递，POST 放在请求体里等等，这些回答没有 GET 到点上，其实 GET，POST 都可以用来传输信息，GET 请求可以用 body 传输数据，在POST 请求时你可以不用不用 body 而用 url 传输数据，这都是可以实现的，这就好比你可以用救护车来运货，也可以用卡车来救人，都没有问题的，&lt;strong&gt;但这不符合人们的认知， 不符合 HTTP 对其定义的语义&lt;/strong&gt;，无规矩不成方圆，遵循语义大家沟通才能更高效，&lt;strong&gt;所以其实它们的区别只在语义上有区别&lt;/strong&gt;，至于安全，那是 HTTPS 的事了。&lt;/p&gt;
&lt;h2 data-tool=&quot;mdnice编辑器&quot;&gt;&lt;span class=&quot;content&quot;&gt;最后：求三连&lt;/span&gt;&lt;/h2&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;这篇文章断断续续写了两周，希望大家能三连走起，感谢支持!&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;未关注的朋友可以扫码关注，接收后续更多精彩内容！ &lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/503fcc160cfd4b749980664ccacbe7b4~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p data-tool=&quot;mdnice编辑器&quot;&gt;巨人的肩膀&lt;/p&gt;
&lt;ul data-tool=&quot;mdnice编辑器&quot;&gt;&lt;li&gt;
&lt;section&gt;极客时间-透视 HTTP 协议&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;图解 HTTP&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;https://blog.konghy.cn/2019/08/06/dns-overview/&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;https://aws.amazon.com/cn/route53/what-is-dns/&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;https://developer.mozilla.org/en-US/docs/Web/HTTP&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;跨域：https://blog.csdn.net/github_34708151/article/details/105383810&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;HTTP 状态码：https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;http://entropymine.com/jason/testbed/mime/&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;https://httpwg.org/specs/rfc7541.html#static.table.definition&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;https://imququ.com/post/header-compression-in-http2.html&lt;/section&gt;&lt;/li&gt;
&lt;li&gt;
&lt;section&gt;https://developers.google.com/web/fundamentals/performance/http2&lt;/section&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Fri, 01 Jan 2021 13:53:00 +0000</pubDate>
<dc:creator>ErnestEvan</dc:creator>
<og:description>前言 如果说 TCP/IP 协议是互联网通信的根基，那么 HTTP 就是其中当之无愧的王者，小到日常生活中的游戏，新闻，大到双十一秒杀等都能看到它的身影，据 NetCraft 统计，目前全球至少有 1</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xiekun/p/14221020.html</dc:identifier>
</item>
<item>
<title>SpringBoot进阶教程(六十九)ApplicationContextAware - 请叫我头头哥</title>
<link>http://www.cnblogs.com/toutou/p/ApplicationContextAware.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/toutou/p/ApplicationContextAware.html</guid>
<description>&lt;div id=&quot;cnblogs_post_description&quot; readability=&quot;35&quot;&gt;&lt;img class=&quot;desc_img zhaiyaoImage&quot; src=&quot;https://www.cnblogs.com/images/cnblogs_com/toutou/699740/o_spring.png&quot; alt=&quot;请叫我头头哥&quot;/&gt;在某些特殊的情况下，Bean需要实现某个功能，但该功能必须借助于Spring容器才能实现，此时就必须让该Bean先获取Spring容器，然后借助于Spring容器实现该功能。为了让Bean获取它所在的Spring容器，可以让该Bean实现ApplicationContextAware接口。ApplicationContextAware 通过它Spring容器会自动把上下文环境对象调用ApplicationContextAware接口中的setApplicationContext方法。在ApplicationContextAware的实现类中，就可以通过这个上下文环境对象得到Spring容器中的Bean。看到—Aware......&lt;/div&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;75.875776397516&quot;&gt;
&lt;div class=&quot;bodyCustomClass&quot; readability=&quot;32.5&quot;&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;在某些特殊的情况下，Bean需要实现某个功能，但该功能必须借助于Spring容器才能实现，此时就必须让该Bean先获取Spring容器，然后借助于Spring容器实现该功能。为了让Bean获取它所在的Spring容器，可以让该Bean实现ApplicationContextAware接口。ApplicationContextAware 通过它Spring容器会自动把上下文环境对象调用ApplicationContextAware接口中的setApplicationContext方法。在ApplicationContextAware的实现类中，就可以通过这个上下文环境对象得到Spring容器中的Bean。看到—Aware就知道是干什么的了，就是属性注入的，但是这个ApplicationContextAware的不同地方在于，实现了这个接口的bean，当spring容器初始化的时候，会自动的将ApplicationContext注入进来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/506684/202012/506684-20201210153414928-1580224793.png&quot; alt=&quot;SpringBoot进阶教程(六十九)ApplicationContextAware&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;1. 添加实现ApplicationContextAware的工具类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; learn.utils;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.beans.BeansException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContext;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.context.ApplicationContextAware;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.stereotype.Component;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; toutou
 * @date by 2020/12
 * @des
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SpringContextUtil &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; ApplicationContextAware {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ApplicationContext applicationContext;

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setApplicationContext(ApplicationContext context) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        applicationContext &lt;/span&gt;=&lt;span&gt; context;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt;&lt;span&gt; ApplicationContext getApplicationContext() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; applicationContext;
    }
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取Bean&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T getBean(Class&amp;lt;T&amp;gt;&lt;span&gt; requiredType){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; getApplicationContext().getBean(requiredType);
    }
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T getBean(String name){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (T) getApplicationContext().getBean(name);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2. 接口中直接调用&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
    @GetMapping(&quot;home&quot;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Result getUser(){
        UserAccountService userAccountService &lt;/span&gt;= SpringContextUtil.getBean(UserAccountService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Result.setSuccessResult(userAccountService.getUserAccountById(1&lt;span&gt;));
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3. service中内部调用&lt;/p&gt;
&lt;p&gt;由于项目中配置了多个数据源，若所有mybatis mapper访问都集中在单个service方法中，@AutoDBDecision声明的数据源会串。所以需要颗粒化。这样就会在单个service中需要请求内部的方法，这时候也可以用上ApplicationContextAware工具类。&lt;/p&gt;
&lt;p&gt;3.1 service中声明内部专用调用方法inside()&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; toutou
 * @date by 2020/12
 * des &lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/toutou/&lt;/span&gt;
 &lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; UserAccountService {
    &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; UserAccountService inside() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; SpringContextUtil.getBean(UserAccountService.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }

    UserAccountVO getUserAccountById(Integer id);

    UserAccountVO getUserAccountById2(Integer id);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3.2 impl中调用方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * &lt;/span&gt;&lt;span&gt;@author&lt;/span&gt;&lt;span&gt; toutou
 * @date by 2020/12
 * des &lt;/span&gt;&lt;span&gt;https://www.cnblogs.com/toutou/&lt;/span&gt;
 &lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@Service
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; UserAccountServiceImpl &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; UserAccountService{
    @Autowired
    UserAccountMapper userMapper;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserAccountVO getUserAccountById(Integer id){
        UserAccountVO accountVO &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
        UserAccount account &lt;/span&gt;=&lt;span&gt; userMapper.selectByPrimaryKey(id);
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (account != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            accountVO &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; UserAccountVO();
            accountVO.setId(account.getId());
            accountVO.setAccount(account.getAccount());
            accountVO.setAge(account.getAge());
            accountVO.setEmail(account.getEmail());
            accountVO.setUsername(account.getUsername());
            accountVO.setPhone(account.getPhone());
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; accountVO;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; UserAccountVO getUserAccountById2(Integer id){
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; inside().getUserAccountById(id);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其他参考/学习资料：&lt;/p&gt;

&lt;h2 id=&quot;_nav_1&quot; class=&quot;blogCustomTitleStyle&quot;&gt;&lt;span class=&quot;blogCustomTitleIco&quot;&gt;v&lt;/span&gt;源码地址&lt;/h2&gt;
&lt;p&gt;&lt;a title=&quot;请叫我头头哥&quot; href=&quot;https://github.com/toutouge/javademosecond/tree/master/hellolearn&quot; target=&quot;_blank&quot;&gt;https://github.com/toutouge/javademosecond/tree/master/hellolearn&lt;/a&gt;&lt;/p&gt;
&lt;div id=&quot;MySignature&quot; readability=&quot;9.0030211480363&quot;&gt;
&lt;p id=&quot;PSignature&quot;&gt;&lt;br/&gt;作　　者：&lt;strong&gt;&lt;span&gt;&lt;a href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;请叫我头头哥&lt;/a&gt;&lt;/span&gt;&lt;/strong&gt;&lt;br/&gt;出　　处：&lt;a title=&quot;请叫我头头哥&quot; href=&quot;http://www.cnblogs.com/toutou/&quot; target=&quot;_blank&quot;&gt;http://www.cnblogs.com/toutou/&lt;/a&gt;&lt;br/&gt;关于作者：专注于基础平台的项目开发。如有问题或建议，请多多赐教！&lt;br/&gt;版权声明：本文版权归作者和博客园共有，欢迎转载，但未经作者同意必须保留此段声明，且在文章页面明显位置给出原文链接。&lt;br/&gt;特此声明：所有评论和私信都会在第一时间回复。也欢迎园子的大大们指正错误，共同进步。或者&lt;a title=&quot;SpringBoot进阶教程(六十九)ApplicationContextAware&quot; href=&quot;http://msg.cnblogs.com/msg/send/%E8%AF%B7%E5%8F%AB%E6%88%91%E5%A4%B4%E5%A4%B4%E5%93%A5&quot;&gt;直接私信&lt;/a&gt;我&lt;br/&gt;声援博主：如果您觉得文章对您有帮助，可以点击文章右下角&lt;strong&gt;&lt;span&gt;【&lt;a id=&quot;post-up&quot;&gt;推荐&lt;/a&gt;】&lt;/span&gt;&lt;/strong&gt;一下。您的鼓励是作者坚持原创和持续写作的最大动力！&lt;br/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 01 Jan 2021 13:14:00 +0000</pubDate>
<dc:creator>请叫我头头哥</dc:creator>
<og:description>在某些特殊的情况下，Bean需要实现某个功能，但该功能必须借助于Spring容器才能实现，此时就必须让该Bean先获取Spring容器，然后借助于Spring容器实现该功能。为了让Bean获取它所在的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/toutou/p/ApplicationContextAware.html</dc:identifier>
</item>
<item>
<title>std::thread线程详解（1） - ink19</title>
<link>http://www.cnblogs.com/ink19/p/std_thread-1.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ink19/p/std_thread-1.html</guid>
<description>&lt;h2 id=&quot;目录&quot;&gt;目录&lt;/h2&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;本文主要介绍了标准库中的线程部分。线程是目前多核编程里面最重要的一部分。&lt;br/&gt;与进程进程相比，其所需的资源更少，线程之间沟通的方法更多； 他们之间的区别可以比较简明用以下几点概括[1]：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;进程是资源分配的最小单位，线程是CPU调度的最小单位；也就是说进程之间的资源是相互隔离，而线程之间的是可以相互访问的。&lt;/li&gt;
&lt;li&gt;线程的存在依赖于进程，一个进程可以保护多个线程；&lt;/li&gt;
&lt;li&gt;进程出现错误不会影响其他进程，但是一个线程出现错误，会影响同一进程下的所有线程。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;线程的使用&quot;&gt;线程的使用&lt;/h2&gt;
&lt;h3 id=&quot;线程的创建&quot;&gt;线程的创建&lt;/h3&gt;
&lt;p&gt;一般使用&lt;code&gt;std::thread&lt;/code&gt;创建一个线程。&lt;code&gt;std::thread&lt;/code&gt;支持输入一个函数对象，及一些参数，类似于&lt;code&gt;std::bind&lt;/code&gt;，不过没有占位符。&lt;/p&gt;
&lt;p&gt;最常见，最简单的是对输入一个匿名函数作为参数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c++&quot;&gt;std::thread t1([]() {
  std::cout &amp;lt;&amp;lt; &quot;Hello World&quot; &amp;lt;&amp;lt; std::endl;
});
t1.join();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要注意的是，在使用多线程的时候，如果使用类似于&lt;code&gt;std::cout &amp;lt;&amp;lt; &quot;Hello World&quot; &amp;lt;&amp;lt; std::endl;&lt;/code&gt;的语句，容易造成输出的混乱。比如&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;std::thread t1([]() {
  std::cout &amp;lt;&amp;lt; &quot;Hello World1&quot; &amp;lt;&amp;lt; std::endl;
});
std::thread t2([]() {
  std::cout &amp;lt;&amp;lt; &quot;Hello World2&quot; &amp;lt;&amp;lt; std::endl;
});
t1.join();
t2.join();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以上代码，我们一般来说期望的输出是&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2105008/202101/2105008-20210101210755155-528460963.png&quot; alt=&quot;期望的输出&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是，在一些情况下，它还会以以下的方法输出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2105008/202101/2105008-20210101210755069-745182546.png&quot; alt=&quot;错误的输出&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;造成这个的原因很简单，因为&lt;code&gt;&quot;Hello World&quot;&lt;/code&gt;和&lt;code&gt;std::endl&lt;/code&gt;的输出是分开的，所以他们之间可能被插入其他的输出。为了解决这个问题。一般会使用一个完整的字符串进行输出，但是C++在格式化这一方面做的比较差（&lt;code&gt;C++20&lt;/code&gt;的&lt;code&gt;format&lt;/code&gt;库看起来还不错），所以一般情况下会使用&lt;code&gt;printf&lt;/code&gt;输出。&lt;/p&gt;
&lt;h3 id=&quot;线程的方法和属性&quot;&gt;线程的方法和属性&lt;/h3&gt;
&lt;ol readability=&quot;4&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;joinable()&lt;/code&gt;判断线程是否可连接（可执行线程）的，有以下情况的，为不可连接的：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;构造时，&lt;code&gt;thread()&lt;/code&gt;没有参数；&lt;/li&gt;
&lt;li&gt;该对象的线程已经被移动了；&lt;/li&gt;
&lt;li&gt;该线程已经被&lt;code&gt;join&lt;/code&gt;或&lt;code&gt;detach&lt;/code&gt;；&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;get_id()&lt;/code&gt; 返回线程的ID；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;native_handle()&lt;/code&gt; 返回&lt;code&gt;POSIX&lt;/code&gt;标准的线程对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;join()&lt;/code&gt; 等待线程执行完成；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;code&gt;detach()&lt;/code&gt; 分离线程，分离后对象不再拥有线程。该线程结束后，会自动回收内存。（并不会开启另一个进程）；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;swap()&lt;/code&gt; 交换对象的线程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;stdjthread-c20&quot;&gt;std::jthread (C++20)&lt;/h3&gt;
&lt;p&gt;除了常用的&lt;code&gt;std::thread&lt;/code&gt;外，标准库还存在着另一个可以创建线程的类，&lt;code&gt;std::jthread&lt;/code&gt;。他们之间的差别比较明显的就是，&lt;code&gt;std::jthread&lt;/code&gt;会在解构的时候判断线程是否还在运行&lt;code&gt;joinable&lt;/code&gt;，如果还在运行则自动调用&lt;code&gt;request_stop&lt;/code&gt;和&lt;code&gt;join&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;除此之外，&lt;code&gt;std::jthread&lt;/code&gt;还提供了一个内置的&lt;code&gt;std::stop_token&lt;/code&gt;。可以通过线程函数的第一个参数来获取（如果函数的第一个参数类型为&lt;code&gt;std::stop_token&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;可以通过&lt;code&gt;get_stop_source&lt;/code&gt;、&lt;code&gt;get_stop_token&lt;/code&gt;、&lt;code&gt;request_stop&lt;/code&gt;等方法来对其进行操作。&lt;/p&gt;
&lt;h3 id=&quot;stop_token-c20&quot;&gt;stop_token (C++20)&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;stop_token&lt;/code&gt;类似于一个信号，告诉线程是否到了结束的时候。和&lt;code&gt;stop_source&lt;/code&gt;一起使用。&lt;code&gt;stop_token&lt;/code&gt;用来获取是否退出（读），而&lt;code&gt;stop_source&lt;/code&gt;用来请求推出（读写）。其方法：&lt;/p&gt;
&lt;ol readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;request_stop&lt;/code&gt; 请求退出&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;stop_requested&lt;/code&gt; 获取是否已经请求退出&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;code&gt;stop_possible&lt;/code&gt; 获取是否可以请求退出&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;样例：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-C++&quot;&gt;void thread_func(std::stop_token token) {
    int data = 0;
    while (!token.stop_requested()) {
        printf(&quot;%d\n&quot;, data);
        data++;
        std::this_thread::sleep_for(1s);
    }
    printf(&quot;Exit\n&quot;);
}

int main() {
    std::jthread mythread(thread_func);

    std::this_thread::sleep_for(4s);

    return 0;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/2105008/202101/2105008-20210101210755062-1194481525.png&quot; alt=&quot;jthread&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本次讲述了线程创建的一些方法，可以看到相比较C语言而言，由于C++11提出的函数对象（普通函数、匿名函数，&lt;code&gt;std::bind&lt;/code&gt;的输出等）使得线程的创建更加的方便。&lt;/p&gt;
&lt;p&gt;下一次将讲述线程之间的通信。在C++中，线程之间的通信方法和C语言提供的类似，不过是将其包装了一下。&lt;/p&gt;
&lt;h2 id=&quot;ref&quot;&gt;Ref&lt;/h2&gt;
&lt;p&gt;[1] &lt;a href=&quot;https://www.zhihu.com/question/25532384&quot; target=&quot;_blank&quot;&gt;https://www.zhihu.com/question/25532384&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 01 Jan 2021 13:12:00 +0000</pubDate>
<dc:creator>ink19</dc:creator>
<og:description>目录 目录 简介 线程的使用 线程的创建 线程的方法和属性 std::jthread (C++20) stop_token (C++20) 总结 Ref 简介 本文主要介绍了标准库中的线程部分。线程是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ink19/p/std_thread-1.html</dc:identifier>
</item>
</channel>
</rss>