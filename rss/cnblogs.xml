<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>Python基础之文件 - davieyang</title>
<link>http://www.cnblogs.com/davieyang/p/10246475.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/davieyang/p/10246475.html</guid>
<description>&lt;h2&gt;一、摘要&lt;/h2&gt;
&lt;p&gt;本片博文将介绍python处理文件的诸多方法&lt;/p&gt;
&lt;h2&gt;二、文件实操&lt;/h2&gt;
&lt;p&gt;文本文件可存储的数据量多得难以置信：天气数据、交通数据、社会经济数据、文学作品等。每当需要分析或修改存储在文件中的信息时，读取文件都很有用，对数据分析应用程序来说尤其如此。例如，你可以编写一个这样的程序：读取一个文本文件的内容，重新设置这些数据的格式并将其写入文件，让浏览器能够显示这些内容。要使用文本文件中的信息，首先需要将信息读取到内存中。为此，你可以一次性读取文件的全部内容，也可以以每次一行的方式逐步读取。&lt;/p&gt;
&lt;h3&gt;读取整个文件：&lt;/h3&gt;
&lt;p&gt;创建了一个python文件file_reader.py，文件里编写如下代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pi_digits.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as file_object:
    contents &lt;/span&gt;=&lt;span&gt; file_object.read()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(contents)
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&amp;gt;&amp;gt;&amp;gt; filepath = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Users/davieyang/Desktop/11111.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&amp;gt;&amp;gt;&amp;gt; file_object =&lt;span&gt; open(filepath)
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; file_content =&lt;span&gt; file_object.read()
&lt;/span&gt;&amp;gt;&amp;gt;&amp;gt; &lt;span&gt;print&lt;/span&gt;&lt;span&gt;(file_content)
&lt;/span&gt;1111111111
2222222222
3333333333
4444444444
5555555555
&amp;gt;&amp;gt;&amp;gt; file_object.close()
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;函数&lt;strong&gt;&lt;span&gt;open()&lt;/span&gt;&lt;/strong&gt;接受一个参数：要打开的文件的名称或者是带路径的文件名，例子中能够看到两种情况的使用。&lt;/p&gt;
&lt;p&gt;第一个例子：要打开的文件名是：pi_digits.txt，执行python文件的时候，被打开的文件pi_digits.txt必须跟python文件file_reader.py在同一个路径下，否则将找不到并报异常：FileNotFoundError: [Errno 2] No such file or directory: 'pi_digits.txt'，如果想避免这种情况，可以像第二个例子一样连路径一起传给open()函数，此例子Python在file_reader.py所在的目录中查找pi_digits.txt。函数open() 返回一个表示文件的对象。在这里，open('pi_digits.txt') 返回一个表示文件pi_digits.txt 的对象；Python将这个对象存储在我们将在后面使用的变量中，有了表示pi_digits.txt的文件对象后，我们使用方法&lt;strong&gt;&lt;span&gt;read()&lt;/span&gt;&lt;/strong&gt;，读取这个文件的全部内容，并将其作为一个长长的字符串存储在变量contents 中。这样，通过打印contents 的值，就可将这个文本文件的全部内容显示出来&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;关键字with 在不再需要访问文件后将其关闭。在这个程序中，注意到我们调用了open() ，但没有调用close() ；你也可以调用open() 和close() 来打开和关闭文件，但这样做时，如果程序存在bug，导致close() 语句未执行，文件将不会关闭。这看似微不足道，但未妥善地关闭文件可能会导致数据丢失或受损。如果在程序中过早地调用close() ，你会发现需要使用文件时它已关闭 （无法访问），这会导致更多的错误。并非在任何情况下都能轻松确定关闭文件的恰当时机，但通过使用前面所示的结构，可让Python去确定：你只管打开文件，并在需要时使用它，Python自会在合适的时候自动将其关闭&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1298012/201901/1298012-20190109214428107-1529939158.png&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;第二个例子：直接将带有路径的文件名传给了open()， 最后还要将打开的对象使用close()函数关闭&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;pi_digits.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as file_object:
    contents &lt;/span&gt;=&lt;span&gt; file_object.read()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(contents.rstrip())
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;read() 函数会在读到文件末尾时返回一个空字符串，而将这个空字符串显示出来时就是一个空行。要删除多出来的空行，可在print 语句中使用&lt;strong&gt;rstrip()&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;实际上除了给open()函数文件名、带绝对路径的文件名之外，还可以给他带相对路径的文件名，相对路径在不同操作系统中要特别注意，在Linux和OS X中，你可以这样编写代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text_files/filename.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) as file_object:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Windows系统中，在文件路径中使用反斜杠（\ ）而不是斜杠（/ ）：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
with open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;text_files\filename.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) as file_object:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如果程序报这样的错误：SyntaxError: (unicode error) 'unicodeescape' codec can't decode bytes in position 2-3: truncated \UXXXXXXXX escape， 那八成是斜杠反了&lt;/p&gt;
&lt;h3&gt;&lt;strong&gt;逐行读取：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;读取文件时，常常需要检查其中的每一行：你可能要在文件中查找特定的信息，或者要以某种方式修改文件中的文本。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
filename = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pi_digits.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    with open(filename) as file_object:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; file_object:
    　　&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(line)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1298012/201901/1298012-20190109232248597-1634889291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为何会出现这些空白行呢？因为在这个文件中，每行的末尾都有一个看不见的换行符，而print 语句也会加上一个换行符，因此每行末尾都有两个换行符：一个来自文件，另一个来自print 语句。要消除这些多余的空白行，可在print 语句中使用rstrip() ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
filename = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pi_digits.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    with open(filename) as file_object:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; file_object:
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(line.rstrip()) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1298012/201901/1298012-20190109232502963-1010555537.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建一个包含文件各行内容的列表：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用关键字with 时，open() 返回的文件对象只在with 代码块内可用。如果要在with 代码块外访问文件的内容，可在with 代码块内将文件的各行存储在一个列表中，并在with 代码块外使用该列表：你可以立即处理文件的各个部分，也可推迟到程序后面再处理。下面的示例在with 代码块中将文件pi_digits.txt的各行存储在一个列表中，再在with 代码块外打印它们：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
file_name = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;C:/Users/davieyang/Desktop/pi_digits.txt&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
with open(file_name) as file_object:
    lines &lt;/span&gt;=&lt;span&gt; file_object.readlines()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(lines)
&lt;/span&gt;&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lines:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(line.rstrip()) 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1298012/201901/1298012-20190109233330689-689363918.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;readlines()&lt;/span&gt;&lt;/strong&gt; 从文件中读取每一行，并将其存储在一个列表中；接下来，该列表被存储到变量lines 中；在with 代码块外，我们依然可以使用这个变量。在处，我们使用一个简单的for 循环来打印lines 中的各行。由于列表lines 的每个元素都对应于文件中的一行，因此输出与文件内容完全一致。&lt;/p&gt;
&lt;h3&gt;使用文件的内容：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
filename = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pi_digits.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
with open(filename) as file_object:
    lines &lt;/span&gt;=&lt;span&gt; file_object.readlines()
pi_string &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lines:
    pi_string &lt;/span&gt;+=&lt;span&gt; line.rstrip()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(pi_string)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(len(pi_string))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1298012/201901/1298012-20190109233723128-892687882.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在变量pi_string 存储的字符串中，包含原来位于每行左边的空格，为删除这些空格，可使用strip() 而不是rstrip() ：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
filename = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pi_30_digits.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
with open(filename) as file_object:
    lines &lt;/span&gt;=&lt;span&gt; file_object.readlines()
pi_string &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lines:
    pi_string &lt;/span&gt;+=&lt;span&gt; line.strip()
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(pi_string)
&lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(len(pi_string))
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;执行结果为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1298012/201901/1298012-20190109233928378-272190712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意：读取文本文件时，Python将其中的所有文本都解读为字符串。如果你读取的是数字，并要将其作为数值使用，就必须使用函数int() 将其转换为整数，或使用函数float() 将其转换为浮点数。&lt;/p&gt;
&lt;p&gt;关于：可处理的数据量，Python没有任何限制；只要系统的内存足够多，你想处理多少数据都可以。&lt;/p&gt;
&lt;p&gt;再看一个例子：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
filename = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;pi_million_digits.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
with open(filename) as file_object:
    lines &lt;/span&gt;=&lt;span&gt; file_object.readlines()
pi_string &lt;/span&gt;= &lt;span&gt;''&lt;/span&gt;
&lt;span&gt;for&lt;/span&gt; line &lt;span&gt;in&lt;/span&gt;&lt;span&gt; lines:
    pi_string &lt;/span&gt;+=&lt;span&gt; line.rstrip()
birthday &lt;/span&gt;= input(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Enter your birthday, in the form mmddyy: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; birthday &lt;span&gt;in&lt;/span&gt;&lt;span&gt; pi_string:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your birthday appears in the first million digits of pi!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Your birthday does not appear in the first million digits of pi.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;写入文件：&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
filename = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;programming.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
with open(filename, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as file_object:
    file_object.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I love programming.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;调用open() 时提供了两个实参。第一个实参也是要打开的文件的名称；第二个实参（'w' ）告诉Python，我们要以写入模式 打开这个文件。打开文件时，可指定读取模式 （'r' ）、写入模式 （'w' ）、附加模式 （'a' ）或让你能够读取和写入文件的模式（'r+' ）。如果你省略了模式实参，Python将以默认的只读模式打开文件。如果你要写入的文件不存在，函数open() 将自动创建它。然而，以写入（'w' ）模式打开文件时千万要小心，因为如果指定的文件已经存在，Python将在返回文件对象前清空该文件，本实例中我们使用文件对象的方法&lt;strong&gt;&lt;span&gt;write()&lt;/span&gt;&lt;/strong&gt; 将一个字符串写入文件&lt;/p&gt;
&lt;p&gt;注意：Python只能将字符串写入文本文件。要将数值数据存储到文本文件中，必须先使用函数str() 将其转换为字符串格式。&lt;/p&gt;
&lt;p&gt;另外：函数write() 不会在你写入的文本末尾添加换行符，因此如果你想写入多行时要指定换行符&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
filename = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;programming.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
with open(filename, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as file_object:
    file_object.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I love programming.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    file_object.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I love creating new games.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;附加到文件：&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;如果你要给文件添加内容，而不是覆盖原有的内容，可以附加模式 打开文件。你以附加模式打开文件时，Python不会在返回文件对象前清空文件，而你写入到文件的行都将添加到文件末尾。如果指定的文件不存在，Python将为你创建一个空文件。&lt;/p&gt;
&lt;p&gt;如下实例打开文件时指定了实参'a' ，以便将内容附加到文件末尾，而不是覆盖文件原来的内容&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
filename = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;programming.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
with open(filename, &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;a&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;) as file_object:
    file_object.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I also love finding meaning in large datasets.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    file_object.write(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;I love creating apps that can run in a browser.\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 09 Jan 2019 15:53:00 +0000</pubDate>
<dc:creator>davieyang</dc:creator>
<og:description>一、摘要 本片博文将介绍python处理文件的诸多方法 二、文件实操 文本文件可存储的数据量多得难以置信：天气数据、交通数据、社会经济数据、文学作品等。每当需要分析或修改存储在文件中的信息时，读取文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/davieyang/p/10246475.html</dc:identifier>
</item>
<item>
<title>Java中的Filter过滤器 - 卫旗</title>
<link>http://www.cnblogs.com/weiqihome/p/10247545.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/weiqihome/p/10247545.html</guid>
<description>&lt;h3 id=&quot;filter简介&quot;&gt;Filter简介&lt;/h3&gt;
&lt;p&gt;　　Filter也称之为过滤器，它是Servlet技术中最实用的技术，Web开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件或静态 html 文件等进行拦截，从而实现一些特殊的功能。例如实现URL级别的权限访问控制、过滤敏感词汇、压缩响应信息等一些高级功能。&lt;/p&gt;
&lt;p&gt;　　它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理。使用Filter的完整流程：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。&lt;/p&gt;
&lt;h3 id=&quot;filter功能&quot;&gt;Filter功能&lt;/h3&gt;
&lt;p&gt;　　在HttpServletRequest到达 Servlet 之前，拦截客户的HttpServletRequest 。根据需要检查HttpServletRequest，也可以修改HttpServletRequest 头和数据。&lt;br/&gt;　　在HttpServletResponse到达客户端之前，拦截HttpServletResponse 。根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。&lt;/p&gt;
&lt;h3 id=&quot;如何借助filter实现拦截功能&quot;&gt;如何借助Filter实现拦截功能&lt;/h3&gt;
&lt;p&gt;　　Filter接口中有一个doFilter方法，当开发人员编写好Filter，并配置对哪个web资源进行拦截后，Web服务器每次在调用web资源的service方法之前，都会先调用一下filter的doFilter方法，因此，在该方法内编写代码可达到如下目的：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;调用目标资源之前，让一段代码执行。
是否调用目标资源（即是否让用户访问web资源）。
web服务器在调用doFilter方法时，会传递一个filterChain对象进来，filterChain对象是filter接口中最重要的一个对象，它也提供了一个doFilter方法，开发人员可以根据需求决定是否调用此方法，调用该方法，则web服务器就会调用web资源的service方法，即web资源就会被访问，否则web资源不会被访问。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;filter开发两步走&quot;&gt;Filter开发两步走&lt;/h3&gt;
&lt;p&gt;　　1、编写java类实现Filter接口，并实现其doFilter方法。&lt;/p&gt;
&lt;p&gt;　　2、在web.xml文件中对编写的filter类进行注册，并设置它所能拦截的资源。&lt;/p&gt;
&lt;p&gt;web.xml配置各节点介绍：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;指定一个过滤器。
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;用于为过滤器指定一个名字，该元素的内容不能为空。
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;元素用于指定过滤器的完整的限定类名。
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;元素用于为过滤器指定初始化参数，它的子元素&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;指定参数的名字，&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;指定参数的值。
在过滤器中，可以使用FilterConfig接口对象来访问初始化参数。
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;元素用于设置一个 Filter 所负责拦截的资源。一个Filter拦截的资源可通过两种方式来指定：Servlet 名称和资源访问的请求路径
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;子元素用于设置filter的注册名称。该值必须是在&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;元素中声明过的过滤器的名字
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;设置 filter 所拦截的请求路径(过滤器关联的URL样式)
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;servlet-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;指定过滤器所拦截的Servlet名称。
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dispatcher&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;指定过滤器所拦截的资源被 Servlet 容器调用的方式，可以是REQUEST,INCLUDE,FORWARD和ERROR之一，默认REQUEST。用户可以设置多个&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dispatcher&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;子元素用来指定 Filter 对资源的多种调用方式进行拦截。
&lt;/span&gt;&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dispatcher&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;子元素可以设置的值及其意义
REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。
INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。
FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。
ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;filter链&quot;&gt;Filter链&lt;/h3&gt;
&lt;p&gt;　　在一个web应用中，可以开发编写多个Filter，这些Filter组合起来称之为一个Filter链。&lt;/p&gt;
&lt;p&gt;　　web服务器根据Filter在web.xml文件中的注册顺序，决定先调用哪个Filter，当第一个Filter的doFilter方法被调用时，web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第2个filter，如果没有，则调用目标资源。&lt;/p&gt;
&lt;h3 id=&quot;filter的生命周期&quot;&gt;Filter的生命周期&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public void init(FilterConfig filterConfig) throws ServletException;//初始化
和我们编写的Servlet程序一样，Filter的创建和销毁由WEB服务器负责。 web 应用程序启动时，web 服务器将创建Filter 的实例对象，并调用其init方法，读取web.xml配置，完成对象的初始化功能，从而为后续的用户请求作好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次）。开发人员通过init方法的参数，可获得代表当前filter配置信息的FilterConfig对象。

public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException;//拦截请求
这个方法完成实际的过滤操作。当客户请求访问与过滤器关联的URL的时候，Servlet过滤器将先执行doFilter方法。FilterChain参数用于访问后续过滤器。

public void destroy();//销毁
Filter对象创建后会驻留在内存，当web应用移除或服务器停止时才销毁。在Web容器卸载 Filter 对象之前被调用。该方法在Filter的生命周期中仅执行一次。在这个方法中，可以释放过滤器使用的资源。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;filterconfig接口&quot;&gt;FilterConfig接口&lt;/h3&gt;
&lt;p&gt;　　用户在配置filter时，可以使用为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的filterConfig对象传递进来。因此开发人员在编写filter时，通过filterConfig对象的方法，就可获得以下内容：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
String getFilterName();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到filter的名称。 &lt;/span&gt;
String getInitParameter(String name);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回在部署描述中指定名称的初始化参数的值。如果不存在返回null. &lt;/span&gt;
Enumeration getInitParameterNames();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回过滤器的所有初始化参数的名字的枚举集合。 &lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; ServletContext getServletContext();&lt;span&gt;//&lt;/span&gt;&lt;span&gt;返回Servlet上下文对象的引用。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;filter使用案例&quot;&gt;Filter使用案例&lt;/h3&gt;
&lt;p&gt;　　使用filter验证用户是否登录，如果未登录则跳转至登录页面。&lt;/p&gt;
&lt;h5 id=&quot;先在web.xml配置&quot;&gt;先在web.xml配置&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SessionFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.action.login.SessionFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;logonStrings&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 对登录页面不进行过滤 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/project/index.jsp;login.do&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;includeStrings&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 只对指定过滤参数后缀进行过滤 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;.do;.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;redirectPath&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; 未通过跳转到登录界面 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/index.jsp&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;disabletestfilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; Y:过滤无效 &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;N&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;SessionFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h5 id=&quot;接着编写filterservlet&quot;&gt;接着编写FilterServlet&lt;/h5&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; com.action.login;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.IOException;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.Filter;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.FilterChain;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.FilterConfig;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletException;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.ServletResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletRequest;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponse;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; javax.servlet.http.HttpServletResponseWrapper;

&lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 *    判断用户是否登录,未登录则退出系统
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; SessionFilter &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; Filter {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; FilterConfig config;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; destroy() {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.config = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isContains(String container, String[] regx) {
        &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt; result = &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;

        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (&lt;span&gt;int&lt;/span&gt; i = 0; i &amp;lt; regx.length; i++&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (container.indexOf(regx[i]) != -1&lt;span&gt;) {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
            }
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; doFilter(ServletRequest request, ServletResponse response, FilterChain chain) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
        HttpServletRequest hrequest &lt;/span&gt;=&lt;span&gt; (HttpServletRequest)request;
        HttpServletResponseWrapper wrapper &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpServletResponseWrapper((HttpServletResponse) response);

        String logonStrings &lt;/span&gt;= config.getInitParameter(&quot;logonStrings&quot;);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 登录登陆页面&lt;/span&gt;
        String includeStrings = config.getInitParameter(&quot;includeStrings&quot;);    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤资源后缀参数&lt;/span&gt;
        String redirectPath = hrequest.getContextPath() + config.getInitParameter(&quot;redirectPath&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 没有登陆转向页面&lt;/span&gt;
        String disabletestfilter = config.getInitParameter(&quot;disabletestfilter&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤器是否有效&lt;/span&gt;

        &lt;span&gt;if&lt;/span&gt; (disabletestfilter.toUpperCase().equals(&quot;Y&quot;)) {    &lt;span&gt;//&lt;/span&gt;&lt;span&gt; 过滤无效&lt;/span&gt;
&lt;span&gt;            chain.doFilter(request, response);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
        String[] logonList &lt;/span&gt;= logonStrings.split(&quot;;&quot;&lt;span&gt;);
        String[] includeList &lt;/span&gt;= includeStrings.split(&quot;;&quot;&lt;span&gt;);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (!&lt;span&gt;this&lt;/span&gt;.isContains(hrequest.getRequestURI(), includeList)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 只对指定过滤参数后缀进行过滤&lt;/span&gt;
&lt;span&gt;            chain.doFilter(request, response);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&lt;span&gt;this&lt;/span&gt;.isContains(hrequest.getRequestURI(), logonList)) {&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 对登录页面不进行过滤&lt;/span&gt;
&lt;span&gt;            chain.doFilter(request, response);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        String user &lt;/span&gt;= ( String ) hrequest.getSession().getAttribute(&quot;useronly&quot;);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;判断用户是否登录&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (user == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            wrapper.sendRedirect(redirectPath);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }&lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            chain.doFilter(request, response);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; init(FilterConfig filterConfig) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; ServletException {
        config &lt;/span&gt;=&lt;span&gt; filterConfig;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样既可完成对用户所有请求，均要经过这个Filter进行验证用户登录。&lt;/p&gt;
&lt;h4 id=&quot;防止中文乱码过滤器&quot;&gt;防止中文乱码过滤器&lt;/h4&gt;
&lt;p&gt;项目使用spring框架时。当前台JSP页面和Java代码中使用了不同的字符集进行编码的时候就会出现表单提交的数据或者上传/下载中文名称文件出现乱码的问题，那就可以使用这个过滤器。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;encoding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-class&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;encoding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;用来指定一个具体的字符集&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;UTF-8&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;forceEncoding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;&lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;true：无论request是否指定了字符集，都是用encoding；false：如果request已指定一个字符集，则不使用encoding&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;false&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;param-value&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;init-param&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;encoding&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-name&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;/*&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;url-pattern&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;filter-mapping&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Wed, 09 Jan 2019 15:43:00 +0000</pubDate>
<dc:creator>卫旗</dc:creator>
<og:description>Filter简介 Filter也称之为过滤器，它是Servlet技术中最实用的技术，Web开发人员通过Filter技术，对web服务器管理的所有web资源：例如Jsp, Servlet, 静态图片文件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/weiqihome/p/10247545.html</dc:identifier>
</item>
<item>
<title>抓取某东的TT购买记录分析TT购买趋势 - summer哥</title>
<link>http://www.cnblogs.com/airnew/p/10247540.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/airnew/p/10247540.html</guid>
<description>&lt;p&gt;最近学习了一些爬虫技术，想做个小项目检验下自己的学习成果，在逛某东的时候，突然给我推荐一个TT的产品，点击进去浏览一番之后就产生了抓取TT产品，然后进行数据分析，看下那个品牌的TT卖得最好。&lt;/p&gt;
&lt;p&gt;本文通过selenium抓取TT信息，存入到mongodb数据库中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;抓取TT产品信息&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;TT产品页面的连接是https://list.jd.com/list.html?cat=9192,9196,1502&amp;amp;page=1&amp;amp;sort=sort_totalsales15_desc&amp;amp;trans=1&amp;amp;JL=6_0_0#J_main。&lt;br/&gt;上面有个page参数，表示第几页。改变这个参数就可以爬取到不同页面的TT产品。&lt;/p&gt;
&lt;p&gt;通过开发者工具看下如果抓取TT的产品信息，例如名字、品牌、价格、评论数量等。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/condom_product.png&quot; title=&quot;condom&quot; alt=&quot;condom&quot;/&gt;&lt;br/&gt;通过上图可以看到一个TT产品信息对应的源代码是一个class为gl-item的li节点&lt;code&gt;&amp;lt;li class='gl-item'&amp;gt;&lt;/code&gt;。li节点中data-sku属性是产品的ID，后面抓取产品的评论信息会用到，brand_id是品牌ID。class为p-price的div节点对应的是TT产品的价格信息。class为p-comment的div节点对应的是评论总数信息。&lt;/p&gt;
&lt;p&gt;开始使用requests是总是无法解析到TT的价格和评论信息，最后适应selenium才解决了这个问题，如果有人知道怎么解决这问题，望不吝赐教。&lt;/p&gt;
&lt;p&gt;下面介绍抓取TT产品评论信息。&lt;/p&gt;
&lt;p&gt;点击一个TT产品，会跳转到产品详细页面，点击“商品评论”，然后勾选上“只看当前商品评价”选项（如果不勾选，就会看到该系列产品的评价）就会看到商品评论信息，我们用开发者工具看下如果抓取评论信息。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/condom_comment.png&quot; title=&quot;condom&quot; alt=&quot;condom&quot;/&gt;&lt;br/&gt;如上图所示，在开发者工具中，点击Network选项，就会看到“&lt;a href=&quot;https://club.jd.com/discussion/getSkuProductPageImageCommentList.action?productId=3521615&amp;amp;isShadowSku=0&amp;amp;callback=jQuery6014001&amp;amp;page=2&amp;amp;pageSize=10&amp;amp;_=1547042223100&quot; class=&quot;uri&quot;&gt;https://club.jd.com/discussion/getSkuProductPageImageCommentList.action?productId=3521615&amp;amp;isShadowSku=0&amp;amp;callback=jQuery6014001&amp;amp;page=2&amp;amp;pageSize=10&amp;amp;_=1547042223100&lt;/a&gt;” 的链接，这个链接返回的是json数据。其中productId就是TT产品页面的data-sku属性的数据。page参数是第几页评论。返回的json数据中，content是评论数，createTime是下单时间。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;
def parse_product(page,html):
    doc = pq(html)
    li_list = doc('.gl-item').items()
    for li in li_list:
        product_id = li('.gl-i-wrap').attr('data-sku')
        brand_id = li('.gl-i-wrap').attr('brand_id')
        time.sleep(get_random_time())
        title = li('.p-name').find('em').text()
        price_items = li('.p-price').find('.J_price').find('i').items()
        price = 0
        for price_item in price_items:
            price = price_item.text()
            break
        total_comment_num = li('.p-commit').find('strong a').text()
        if total_comment_num.endswith(&quot;万+&quot;):
            print('总评价数量：' + total_comment_num)
            total_comment_num = str(int(float(total_comment_num[0:len(total_comment_num) -2]) * 10000))
            print('转换后总评价数量：' + total_comment_num)
        elif total_comment_num.endswith(&quot;+&quot;):
            total_comment_num = total_comment_num[0:len(total_comment_num) - 1]
        condom = {}
        condom[&quot;product_id&quot;] = product_id
        condom[&quot;brand_id&quot;] = brand_id
        condom[&quot;condom_name&quot;] = title
        condom[&quot;total_comment_num&quot;] = total_comment_num
        condom[&quot;price&quot;] = price
        comment_url = 'https://club.jd.com/comment/skuProductPageComments.action?callback=fetchJSON_comment98vv117396&amp;amp;productId=%s&amp;amp;score=0&amp;amp;sortType=5&amp;amp;page=0&amp;amp;pageSize=10&amp;amp;isShadowSku=0&amp;amp;fold=1'
        comment_url = comment_url %(product_id)
        response = requests.get(comment_url,headers = headers)
        if response.text == '':
            for i in range(0,10):
                time.sleep(get_random_time())
                try:
                    response = requests.get(comment_url, headers=headers)
                except requests.exceptions.ProxyError:
                    time.sleep(get_random_time())
                    response = requests.get(comment_url, headers=headers)
                if response.text:
                    break
                else:
                    continue
        text = response.text
        text = text[28:len(text) - 2]
        jsons = json.loads(text)
        productCommentSummary = jsons.get('productCommentSummary')
        # productCommentSummary = response.json().get('productCommentSummary')
        poor_count = productCommentSummary.get('poorCount')
        general_count = productCommentSummary.get('generalCount')
        good_count = productCommentSummary.get('goodCount')
        comment_count = productCommentSummary.get('commentCount')
        poor_rate = productCommentSummary.get('poorRate')
        good_rate = productCommentSummary.get('goodRate')
        general_rate = productCommentSummary.get('generalRate')
        default_good_count = productCommentSummary.get('defaultGoodCount')
        condom[&quot;poor_count&quot;] = poor_count
        condom[&quot;general_count&quot;] = general_count
        condom[&quot;good_count&quot;] = good_count
        condom[&quot;comment_count&quot;] = comment_count
        condom[&quot;poor_rate&quot;] = poor_rate
        condom[&quot;good_rate&quot;] = good_rate
        condom[&quot;general_rate&quot;] = general_rate
        condom[&quot;default_good_count&quot;] = default_good_count
        collection.insert(condom)

        comments = jsons.get('comments')
        if comments:
            for comment in comments:
                print('解析评论')
                condom_comment = {}
                reference_time = comment.get('referenceTime')
                content = comment.get('content')
                product_color = comment.get('productColor')
                user_client_show = comment.get('userClientShow')
                user_level_name = comment.get('userLevelName')
                is_mobile = comment.get('isMobile')
                creation_time = comment.get('creationTime')
                guid = comment.get(&quot;guid&quot;)
                condom_comment[&quot;reference_time&quot;] = reference_time
                condom_comment[&quot;content&quot;] = content
                condom_comment[&quot;product_color&quot;] = product_color
                condom_comment[&quot;user_client_show&quot;] = user_client_show
                condom_comment[&quot;user_level_name&quot;] = user_level_name
                condom_comment[&quot;is_mobile&quot;] = is_mobile
                condom_comment[&quot;creation_time&quot;] = creation_time
                condom_comment[&quot;guid&quot;] = guid
                collection_comment.insert(condom_comment)
        parse_comment(product_id)


def parse_comment(product_id):
    comment_url = 'https://club.jd.com/comment/skuProductPageComments.action?callback=fetchJSON_comment98vv117396&amp;amp;productId=%s&amp;amp;score=0&amp;amp;sortType=5&amp;amp;page=%d&amp;amp;pageSize=10&amp;amp;isShadowSku=0&amp;amp;fold=1'
    for i in range(1,200):
        time.sleep(get_random_time())
        time.sleep(get_random_time())
        print('抓取第' + str(i) + '页评论')
        url = comment_url%(product_id,i)
        response = requests.get(url, headers=headers,timeout=10)
        print(response.status_code)
        if response.text == '':
            for i in range(0,10):
                print('抓取不到数据')
                response = requests.get(comment_url, headers=headers)
                if response.text:
                    break
                else:
                    continue
        text = response.text
        print(text)
        text = text[28:len(text) - 2]
        print(text)
        jsons = json.loads(text)
        comments = jsons.get('comments')
        if comments:
            for comment in comments:
                print('解析评论')
                condom_comment = {}
                reference_time = comment.get('referenceTime')
                content = comment.get('content')
                product_color = comment.get('productColor')
                user_client_show = comment.get('userClientShow')
                user_level_name = comment.get('userLevelName')
                is_mobile = comment.get('isMobile')
                creation_time = comment.get('creationTime')
                guid = comment.get(&quot;guid&quot;)
                id = comment.get(&quot;id&quot;)
                condom_comment[&quot;reference_time&quot;] = reference_time
                condom_comment[&quot;content&quot;] = content
                condom_comment[&quot;product_color&quot;] = product_color
                condom_comment[&quot;user_client_show&quot;] = user_client_show
                condom_comment[&quot;user_level_name&quot;] = user_level_name
                condom_comment[&quot;is_mobile&quot;] = is_mobile
                condom_comment[&quot;creation_time&quot;] = creation_time
                condom_comment[&quot;guid&quot;] = guid
                condom_comment[&quot;id&quot;] = id
                collection_comment.insert(condom_comment)

        else:
            break
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果想要获取抓取TT数据和评论的代码，请关注我的公众号“python_ai_bigdata”,然后恢复TT获取代码。&lt;/p&gt;
&lt;p&gt;一共抓取了8934条产品信息和17万条评论(购买)记录。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;产品最多的品牌&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先分析8934个产品，看下哪个品牌的TT在京东上卖得最多。由于品牌过多，京东上销售TT的品牌就有299个，我们只取卖得最多的前10个品牌。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/contom_bingtu.png&quot; title=&quot;condom&quot; alt=&quot;condom&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上面的图可以看出，排名第1的是杜杜，冈本次之，邦邦第3，前10品牌分别是杜蕾斯、冈本、杰士邦、倍力乐、名流、第六感、尚牌、赤尾、诺丝和米奥。这10个品牌中有5个是我没见过的，分别是倍力乐、名流、尚牌、赤尾和米奥，其他的都见过，特别是杜杜和邦邦常年占据各大超市收银台的醒目位置。&lt;/p&gt;
&lt;p&gt;这10个品牌中，杜蕾斯来自英国，冈本来自日本，杰士邦、第六感、赤尾、米奥和名流是国产的品牌，第六感是杰士邦旗下的一个避孕套品牌；倍力乐是中美合资的品牌，尚牌来自泰国，诺丝是来自美国的品牌。&lt;/p&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;import pymongo 
import pandas as pd 
import numpy as np 
import matplotlib.pyplot as plt 
from pandas import DataFrame,Series

client = pymongo.MongoClient(host='localhost',port=27017) 
db = client.condomdb

condom_new = db.condom_new

cursor = condom_new.find() 
condom_df = pd.DataFrame(list(cursor)) 

brand_name_df = condom_df['brand_name'].to_frame()
brand_name_df['condom_num'] = 1

brand_name_group = brand_name_df.groupby('brand_name').sum()

brand_name_sort = brand_name_group.sort_values(by='condom_num', ascending=False)
brand_name_top10 = brand_name_sort.head(10)


# print(3 * np.random.rand(4))
index_list = []
labels = []
value_list = []

for index,row in brand_name_top10.iterrows():
    index_list.append(index)
    labels.append(index)
    value_list.append(int(row['condom_num']))

plt.rcParams['font.sans-serif']=['SimHei'] #用来正常显示中文标签
plt.rcParams['axes.unicode_minus']=False #用来正常显示负号

series_condom = pd.Series(value_list, index=index_list, name='')
series_condom.plot.pie(labels=labels,
                 autopct='%.2f', fontsize=10, figsize=(10, 10))&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;卖得最好的产品&lt;/strong&gt;&lt;br/&gt;可以根据产品评价数量来判断一个产品卖得好坏，评价数最多的产品通常也是卖得最好的。&lt;/p&gt;
&lt;p&gt;产品评论中有个产品评论总数的字段，我们就根据这个字段来排序，看下评论数量最多的前10个产品是什么（也就是评论数量最多的）。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/condom_xiaoshoubang.png&quot; title=&quot;condom&quot; alt=&quot;condom&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从上图可以看出，卖得最好的还是杜杜的产品，10席中占了6席。杜杜的情爱四合一以1180000万的销量排名第一。&lt;/p&gt;
&lt;p&gt;最受欢迎的是超薄的TT，占了8席，持久型的也比较受欢迎，狼牙套竟然也上榜了，真是大大的出乎我的意料。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;销量分析&lt;/strong&gt;&lt;br/&gt;下图是TT销量最好的10天&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/condom_date_sale.png&quot; title=&quot;condom&quot; alt=&quot;condom&quot;/&gt;&lt;br/&gt;可以看出这10天分别分布在6月、11月和12月，应该和我们熟知的618、双11和双12购物节有关。&lt;/p&gt;
&lt;p&gt;现在很多电商都有自己的购物节，像618，双11和双12。由于一个产品最多只能显示100页的评论，每页10条评论，一个产品最多只能爬取到1000条评论，对于销量达到118万的情爱四合一来说，1000条评论不具有代表性，但是总的来说通过上图的分析，可以知道电商做活动的月份销量一般比较好。&lt;/p&gt;
&lt;p&gt;下图是每个月份TT销售量柱状图，更加验证了上面的说法。&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/condom_month_sale.png&quot; title=&quot;condom&quot; alt=&quot;condom&quot;/&gt;&lt;br/&gt;11月的销量最好，12月次之，6月份的销量第三。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;购物平台&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/condom_pingtai.png&quot; title=&quot;condom&quot; alt=&quot;condom&quot;/&gt;&lt;br/&gt;通过京东app购买TT的最多，91%的用户来自京东Android客户端和iphone客户端。6%的用户来自PC端，这几年4G的发展有关。&lt;/p&gt;
&lt;p&gt;通过上面的分析可以知道，超薄的TT最受欢迎。杜杜的产品卖得最好，这和他们的营销方案有关，杜杜的文案可以称作教科书级的，每次发布文案都引起大家的讨论，堪称个个经典。移动客户端购买TT已经成为主流，占据90%以上的流量。&lt;/p&gt;
&lt;p&gt;下面分享几个杜杜经典的文案。&lt;/p&gt;
&lt;p&gt;双11走心文案：&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://www.bigdata17.com/assets/images/dudu1.JPEG%22condom%22&quot;/&gt;&lt;/p&gt;
&lt;p&gt;滴滴出行宣布收购优步中国。&lt;br/&gt;杜蕾斯：DUDU打车，老司机的选择。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.bigdata17.com/assets/images/dudu2.jpeg&quot; title=&quot;condom&quot; alt=&quot;condom&quot;/&gt;&lt;/p&gt;
&lt;p&gt;王者荣耀最火时文案：&lt;/p&gt;
&lt;p&gt;&lt;embed src=&quot;http://www.bigdata17.com/assets/images/dudu3.JPEG%22condom%22&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Jan 2019 15:41:00 +0000</pubDate>
<dc:creator>summer哥</dc:creator>
<og:description>最近学习了一些爬虫技术，想做个小项目检验下自己的学习成果，在逛某东的时候，突然给我推荐一个TT的产品，点击进去浏览一番之后就产生了抓取TT产品，然后进行数据分析，看下那个品牌的TT卖得最好。 本文通过</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/airnew/p/10247540.html</dc:identifier>
</item>
<item>
<title>【wif 系列】C#之单例模式（Singleton）最佳实践（一） - 楚人Leo</title>
<link>http://www.cnblogs.com/leolion/p/10241822.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/leolion/p/10241822.html</guid>
<description>&lt;p class=&quot;toc&quot;&gt;目录&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;单例模式是软件工程中最着名的模式之一。从本质上讲，单例是一个只允许创建自身的单个实例的类，并且通常可以简单地访问该实例。最常见的是，单例不允许在创建实例时指定任何参数——否则对实例的第二个请求但具有不同的参数可能会有问题！（如果对于具有相同参数的所有请求都应访问相同的实例，则工厂模式更合适。）本文仅处理不需要参数的情况。通常，单例的要求是它们是懒惰地创建的——即直到第一次需要时才创建实例。&lt;/p&gt;
&lt;p&gt;在C＃中实现单例模式有各种不同的方法。我将以优雅的相反顺序呈现它们，从最常见的、不是线程安全的版本开始，一直到完全延迟加载的、线程安全的、简单且高性能的版本。&lt;/p&gt;
&lt;p&gt;然而，所有这些实现都有四个共同特征：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;单个构造函数，它是私有且无参数的。这可以防止其他类实例化它（这将违反模式）。请注意，它还可以防止子类化——如果一个单例对象可以被子类化一次，那么它就可以被子类化两次，如果每个子类都可以创建一个实例，则违反了该模式。如果您需要基类型的单个实例，则可以使用工厂模式，但是确切的类型要到运行时才能知道。&lt;/li&gt;
&lt;li&gt;类是密封的。严格来说，由于上述原因，这是不必要的，但是可以帮助JIT进行更多的优化。&lt;/li&gt;
&lt;li&gt;一个静态变量，用于保存对单个已创建实例的引用（如果有的话）。&lt;/li&gt;
&lt;li&gt;公共静态意味着获取对单个已创建实例的引用，必要时创建一个实例。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;em&gt;请注意，所有这些实现还使用公共静态属性&lt;code&gt;Instance&lt;/code&gt; 作为访问实例的方法。在所有情况下，可以轻松地将属性转换为方法，而不会影响线程安全性或性能。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第一个版本-不是线程安全的&quot;&gt;第一个版本 ——不是线程安全的&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// 糟糕的代码！不要使用！
public  sealed  class  Singleton 
{ 
    private  static  Singleton instance = null ; 

    private  Singleton（）
    { 
    } 

    public  static  Singleton Instance 
    { 
        get 
        { 
            if  （instance == null）
            { 
                instance =  new  Singleton（）; 
            } 
            return  instance; 
        } 
    } 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如前所述，上述内容不是线程安全的。两个不同的线程都可以评估测试&lt;code&gt;if (instance==null)&lt;/code&gt;并发现它为&lt;code&gt;true&lt;/code&gt;，然后两个都创建实例，这违反了单例模式。请注意，实际上，在计算表达式之前可能已经创建了实例，但是内存模型不保证其他线程可以看到实例的新值，除非已经传递了合适的内存屏障（互斥锁）。&lt;/p&gt;
&lt;h2 id=&quot;第二个版本-简单的线程安全&quot;&gt;第二个版本 —— 简单的线程安全&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public sealed class Singleton
{
    private static Singleton instance = null;
    private static readonly object padlock = new object();

    Singleton()
    {
    }

    public static Singleton Instance
    {
        get
        {
            lock (padlock)
            {
                if (instance == null)
                {
                    instance = new Singleton();
                }
                return instance;
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;此实现是线程安全的。线程取消对共享对象的锁定，然后在创建实例之前检查是否已创建实例。这会解决内存屏障问题（因为锁定确保在获取锁之后逻辑上发生所有读取，并且解锁确保在锁定释放之前逻辑上发生所有写入）并确保只有一个线程将创建实例（仅限于一次只能有一个线程可以在代码的那一部分中——当第二个线程进入它时，第一个线程将创建实例，因此表达式将计算为&lt;code&gt;false&lt;/code&gt;）。不幸的是，每次请求实例时都会获得锁定，因此性能会受到影响。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;请注意，不是&lt;code&gt;typeof(Singleton)&lt;/code&gt;像这个实现的某些版本那样锁定，而是锁定一个私有的静态变量的值。锁定其他类可以访问和锁定的对象（例如类型）会导致性能问题甚至死锁。这是我通常的风格偏好——只要有可能，只锁定专门为锁定目的而创建的对象，或者为了特定目的（例如，等待/触发队列）而锁定的文档。通常这些对象应该是它们所使用的类的私有对象。这有助于使编写线程安全的应用程序变得更加容易。&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;第三个版本---使用双重检查锁定尝试线程安全&quot;&gt;第三个版本 - 使用双重检查锁定尝试线程安全&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;// 糟糕的代码！不要使用！
public sealed class Singleton
{
    private static Singleton instance = null;
    private static readonly object padlock = new object();

    Singleton()
    {
    }

    public static Singleton Instance
    {
        get
        {
            if (instance == null)
            {
                lock (padlock)
                {
                    if (instance == null)
                    {
                        instance = new Singleton();
                    }
                }
            }
            return instance;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该实现尝试是线程安全的，而不必每次都取出锁。不幸的是，该模式有四个缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它在Java中不起作用。这似乎是一个奇怪的事情，但是如果您需要Java中的单例模式，这是值得知道的，C＃程序员也可能是Java程序员。Java内存模型无法确保构造函数在将新对象的引用分配给&lt;code&gt;Instance&lt;/code&gt;之前完成。Java内存模型经历了1.5版本的重新改进，但是在没有volatile变量（如在C＃中）的情况下，双重检查锁定仍然会被破坏。&lt;/li&gt;
&lt;li&gt;在没有任何内存障碍的情况下，ECMA CLI规范也打破了这一限制。有可能在.NET 2.0内存模型（比ECMA规范更强）下它是安全的，但我宁愿不依赖那些更强大的语义，特别是如果对安全性有任何疑问的话。使&lt;code&gt;instance&lt;/code&gt;变量volatile变得有效，就像明确的内存屏障调用一样，尽管在后一种情况下，甚至专家也无法准确地就需要哪些屏障达成一致。我尽量避免专家对对错意见也不一致的情况！&lt;/li&gt;
&lt;li&gt;这很容易出错。该模式需要完全如上所述——任何重大变化都可能影响性能或正确性。&lt;/li&gt;
&lt;li&gt;它的性能仍然不如后续的实现。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;第四个版本---不太懒不使用锁且线程安全&quot;&gt;第四个版本 - 不太懒，不使用锁且线程安全&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public sealed class Singleton
{
    private static readonly Singleton instance = new Singleton();

    // 显式静态构造函数告诉C＃编译器
    // 不要将类型标记为BeforeFieldInit
    static Singleton()
    {
    }

    private Singleton()
    {
    }

    public static Singleton Instance
    {
        get
        {
            return instance;
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;正如您所看到的，这实际上非常简单——但是为什么它是线程安全的，它有多懒惰？C＃中的静态构造函数仅在创建类的实例或引用静态成员时执行，并且每个AppDomain只执行一次。考虑到无论发生什么情况，都需要执行对新构造的类型的检查，这比在前面的示例中添加额外检查要快。然而，还有一些小缺陷：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;它并不像其他实现那样懒惰。特别是，如果您有&lt;code&gt;Instance&lt;/code&gt;之外的静态成员，那么对这些成员的第一次引用将涉及到创建实例。这将在下一个实现中得到纠正。&lt;/li&gt;
&lt;li&gt;如果一个静态构造函数调用另一个静态构造函数，而另一个静态构造函数再次调用第一个构造函数，则会出现复杂情况。查看.NET规范（目前是分区II的第9.5.3节），了解有关类型初始化器的确切性质的更多详细信息——它们不太可能会影响您，但是有必要了解静态构造函数在循环中相互引用的后果。&lt;/li&gt;
&lt;li&gt;类型初始化器的懒惰性只有在.NET没有使用名为&lt;code&gt;BeforeFieldInit&lt;/code&gt;的特殊标志标记类型时才能得到保证。不幸的是，C＃编译器（至少在.NET 1.1运行时中提供）将所有没有静态构造函数的类型（即看起来像构造函数但被标记为静态的块）标记为&lt;code&gt;BeforeFieldInit&lt;/code&gt;。我现在有一篇&lt;a href=&quot;http://csharpindepth.com/Articles/General/BeforeFieldInit.aspx&quot;&gt;文章，详细介绍了这个问题&lt;/a&gt;。另请注意，它会影响性能，如在页面底部所述的那样。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;您可以使用此实现（并且只有这一个）的一个快捷方式是将 &lt;code&gt;Instance&lt;/code&gt;作为一个公共静态只读变量，并完全删除该属性。这使得基本的框架代码非常小！然而，许多人更愿意拥有一个属性，以防将来需要采取进一步行动，而JIT内联可能会使性能相同。（注意，如果您需要懒惰的，静态构造函数本身仍然是必需的。）&lt;/p&gt;
&lt;h2 id=&quot;第五版---完全懒惰的实例化&quot;&gt;第五版 - 完全懒惰的实例化&lt;/h2&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public sealed class Singleton
{
    private Singleton()
    {
    }

    public static Singleton Instance { get { return Nested.instance; } }
        
    private class Nested
    {
        // 显式静态构造告诉C＃编译器
        // 未标记类型BeforeFieldInit
        static Nested()
        {
        }

        internal static readonly Singleton instance = new Singleton();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在这里，实例化是由对嵌套类的静态成员的第一次引用触发的，该引用只发生在&lt;code&gt;Instance&lt;/code&gt;中。这意味着实现是完全懒惰的，但是具有前面实现的所有性能优势。请注意，尽管嵌套类可以访问封闭类的私有成员，但反之则不然，因此需要&lt;code&gt;instance&lt;/code&gt;在此处为内部成员。不过，这不会引起任何其他问题，因为类本身是私有的。但是，为了使实例化变得懒惰，代码要稍微复杂一些。&lt;/p&gt;
&lt;h2 id=&quot;第六版---使用.net-4的-lazy-类型&quot;&gt;第六版 - 使用.NET 4的 Lazy 类型&lt;/h2&gt;
&lt;p&gt;如果您使用的是.NET 4（或更高版本），则可以使用 &lt;a href=&quot;http://msdn.microsoft.com/zh-cn/library/dd642331.aspx&quot;&gt;System.Lazy&lt;/a&gt; 类型使惰性变得非常简单。您需要做的就是将委托传递给调用Singleton构造函数的构造函数——使用lambda表达式最容易做到这一点。&lt;/p&gt;
&lt;pre class=&quot;c#&quot;&gt;
&lt;code&gt;public sealed class Singleton
{
    private static readonly Lazy&amp;lt;Singleton&amp;gt; lazy =
        new Lazy&amp;lt;Singleton&amp;gt;(() =&amp;gt; new Singleton());
    
    public static Singleton Instance { get { return lazy.Value; } }

    private Singleton()
    {
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;它很简单，而且性能很好。它还允许您检查是否已使用&lt;a href=&quot;http://msdn.microsoft.com/en-us/library/dd642334.aspx&quot;&gt;IsValueCreated&lt;/a&gt; 属性创建实例（如果需要的话）。&lt;/p&gt;
&lt;p&gt;上面的代码隐式地将&lt;code&gt;LazyThreadSafetyMode.ExecutionAndPublication&lt;/code&gt;用作&lt;code&gt;Lazy&amp;lt;Singleton&amp;gt;&lt;/code&gt;的线程安全模式。根据您的要求，您可能希望尝试其他模式。&lt;/p&gt;
&lt;h2 id=&quot;性能与懒惰&quot;&gt;性能与懒惰&lt;/h2&gt;
&lt;p&gt;在许多情况下，您实际上并不需要完全懒惰——除非您的类初始化做了一些特别耗时的事情，或者在其他地方产生了一些副作用，否则最好忽略上面所示的显式静态构造函数。这可以提高性能，因为它允许JIT编译器进行一次检查（例如在方法的开头）以确保类型已经初始化，然后从那时开始设定它。如果在相对紧密的循环中引用单例实例，则会产生（相对）显著的性能差异。您应该决定是否需要完全延迟实例化，并在类中适当地记录此决策。&lt;/p&gt;
&lt;p&gt;这个页面存在的很多原因是人们试图变得聪明，因此提出了双重检查锁定算法。我们常常认为锁定是昂贵的，这被误导的。我写了一个非常快速的基准测试，在一个循环中获取10亿次单例实例，并尝试不同的变体。这并不是很科学，因为在现实生活中，您可能想知道如果每次迭代都涉及到对获取单例的方法的调用，那么速度有多快。然而这确实显示了一个重要的观点。在我的笔记本电脑上，最慢的解决方案（大约5倍）是锁定解决方案（解决方案2）。这很重要吗？可能不会，当您记住它仍然能够在40秒内获取10亿次&lt;code&gt;Singleton&lt;/code&gt;。（注意：这篇文章最初是在很久以前写的——现在我希望有更好的性能。）这意味着，如果你是“仅仅”每秒获得40万次单例实例，那么花费的成本将是1％的性能——所以不会做很多事情去改进它。现在，如果你&lt;em&gt;经常&lt;/em&gt; 获得单例实例——你是否可能在循环中使用它？如果您非常关心如何提高性能，为什么不在循环外声明一个局部变量，先获取一次&lt;code&gt;Singleton&lt;/code&gt;，然后再循环呢。Bingo，即使是最慢的实现性能也足够了。&lt;/p&gt;
&lt;p&gt;我非常有兴趣看到一个真实的应用程序，在这个应用程序中，使用简单锁定和使用一种更快的解决方案之间的差异实际上会带来显著的性能差异。&lt;/p&gt;
&lt;h2 id=&quot;异常&quot;&gt;异常&lt;/h2&gt;
&lt;p&gt;有时，您需要在单例构造函数中执行一些操作，这可能会抛出异常，但可能不会对整个应用程序造成致命影响。您的应用程序可能能够解决此问题，并希望再次尝试。在这个阶段，使用类型初始化器来构造单例会出现问题。不同的运行时处理这种情况的方式不同，但我不知道有哪些运行时执行了所需的操作（再次运行类型初始化程序），即使有一个运行时这样做，您的代码也会在其他运行时被破坏。为了避免这些问题，我建议使用文章里列出的第二种模式 ——只需使用一个简单的锁，并每次都进行检查，如果尚未成功构建实例，则在方法/属性中构建实例。&lt;/p&gt;
&lt;h2 id=&quot;结论&quot;&gt;结论&lt;/h2&gt;
&lt;p&gt;在C＃中实现单例模式有各种不同的方法。读者已经写信给我详细说明了他已经封装了同步方面的方法，虽然我承认这可能在一些非常特殊的情况下有用（特别是在你想要非常高性能的地方，以及确定单例是否已经创建，并完全懒惰，而不考虑其他静态成员被调用）。我个人并不认为这种情况会经常出现，值得在这篇文章中进一步改进，但如果你处于这种情况，请&lt;a href=&quot;http://www.cnblogs.com/leolion/p/leolion610@outlook.com&quot;&gt;发邮件给我&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;我的个人的偏好是解决方案4：我通常唯一一次不采用它是因为我需要能够在不触发初始化的情况下调用其他静态方法，或者如果我需要知道单例是否已经被实例化。我不记得上次我处于那种情况是什么时候了，假设我有过，在那种情况下，我可能会选择解决方案2，这仍然是很好的，很容易正确实现。&lt;/p&gt;
&lt;p&gt;解决方案5很优雅，但是比2或4更复杂，正如我上面所说，它提供的好处似乎只是很少有用。解决方案6是一种更简单的方法来实现懒惰，如果你使用.NET 4.它还有一个优势，它显然是懒惰的。我目前仍然倾向于使用解决方案4，这仅仅是出于习惯——但如果我与没有经验的开发人员合作，我很可能会选择解决方案6作为一种简单且普遍适用的模式。&lt;/p&gt;
&lt;p&gt;（我不会使用解决方案1，因为它是有缺陷的，我也不会使用解决方案3，因为它的好处没有超过5。）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Jon Skeet&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://csharpindepth.com/Articles/General/Singleton.aspx#performance&quot;&gt;英文原文&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;项目代码wif&quot;&gt;项目代码：&lt;a href=&quot;https://github.com/LeoYang610/wif&quot;&gt;wif&lt;/a&gt;&lt;/h3&gt;
</description>
<pubDate>Wed, 09 Jan 2019 15:33:00 +0000</pubDate>
<dc:creator>楚人Leo</dc:creator>
<og:description>[TOC] 介绍 单例模式是软件工程中最着名的模式之一。从本质上讲，单例是一个只允许创建自身的单个实例的类，并且通常可以简单地访问该实例。最常见的是，单例不允许在创建实例时指定任何参数——否则对实例的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/leolion/p/10241822.html</dc:identifier>
</item>
<item>
<title>微信公众号02 接收文本消息、回复文本消息、接入百度翻译功能 - 寻渝记</title>
<link>http://www.cnblogs.com/NeverCtrl-C/p/10247498.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NeverCtrl-C/p/10247498.html</guid>
<description>
&lt;h2&gt;1 说明&lt;/h2&gt;
&lt;p&gt;　　本篇博文承接上一篇博文：&lt;a href=&quot;https://www.cnblogs.com/NeverCtrl-C/p/10241763.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/NeverCtrl-C/p/10241763.html&lt;/a&gt;&lt;/p&gt;

&lt;h2&gt;2 接收文本消息&lt;/h2&gt;
&lt;p&gt;　　微信公众号官方文档：https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140453&lt;/p&gt;
&lt;p&gt;　　说明：接收文本消息属于接收普通消息的范围，当公众号粉丝向公众号发送消息时，微信服务器会向开发者服务器发送一个POST请求，这个POST请求携带XML格式的数据包到开发者填写的URL上&lt;/p&gt;
&lt;h3&gt;2.1 文本消息XML格式&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xml&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ToUserName&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt; ![CDATA&lt;/span&gt;&lt;span&gt;[toUser] ]&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ToUserName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;FromUserName&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt; ![CDATA&lt;/span&gt;&lt;span&gt;[fromUser] ]&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;FromUserName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;CreateTime&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1348831860&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;CreateTime&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MsgType&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt; ![CDATA&lt;/span&gt;&lt;span&gt;[text] ]&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MsgType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt; ![CDATA&lt;/span&gt;&lt;span&gt;[this is a test] ]&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MsgId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1234567890123456&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MsgId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xml&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2 文本消息参数说明&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;2&quot;&gt;&lt;tr&gt;&lt;td&gt;ToUserName&lt;/td&gt;
&lt;td&gt;开发者微信号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;FromUserName&lt;/td&gt;
&lt;td&gt;发送方帐号（一个OpenID）&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CreateTime&lt;/td&gt;
&lt;td&gt;消息创建时间 （整型）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MsgType&lt;/td&gt;
&lt;td&gt;text&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Content&lt;/td&gt;
&lt;td&gt;文本消息内容&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MsgId&lt;/td&gt;
&lt;td&gt;消息id，64位整型&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;&lt;span&gt;&lt;br/&gt;step01 创建一个com.xunyji.xunyjitest.comm.TransformUtils类用来存放一下数据类型转换相关的工具方法&lt;/span&gt;2.3 Java代码实现&lt;/p&gt;
&lt;p&gt;step02 引入XML和对象相互转换相关的jar包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;xml2对象 start&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/dom4j/dom4j &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;dom4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;dom4j&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.6.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;xml2对象 end&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;

        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;对象2XML start&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/com.thoughtworks.xstream/xstream &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.thoughtworks.xstream&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;xstream&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.3.1&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt;对象2XML end&lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step03 创建com.xunyji.xunyjitest.comm.TransformUtils#xml2Map方法用于将XML转化成Map类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * xml转换成map【微信平台请求开发者平台时的数据格式都是XML格式的】
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; request
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;&lt;span&gt;
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; IOException
     * &lt;/span&gt;&lt;span&gt;@throws&lt;/span&gt;&lt;span&gt; DocumentException
     &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; Map&amp;lt;String, String&amp;gt; xml2Map(HttpServletRequest request) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, DocumentException {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        01 定义Map对象用来存放数据&lt;/span&gt;
        Map&amp;lt;String, String&amp;gt; map = &lt;span&gt;new&lt;/span&gt; HashMap&amp;lt;&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        02 创建SAXReader用于读取xml文件&lt;/span&gt;
        SAXReader reader = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SAXReader();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        03 读取Request中的信息&lt;/span&gt;
        InputStream ins =&lt;span&gt; request.getInputStream();
        Document doc &lt;/span&gt;=&lt;span&gt; reader.read(ins);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        04 获取xml的根元素&lt;/span&gt;
        Element root =&lt;span&gt; doc.getRootElement();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        05 获取根元素中的所有子元素&lt;/span&gt;
        List&amp;lt;Element&amp;gt; list =&lt;span&gt; root.elements();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        06 遍历所有子元素并将数据存放到定义好的集合中&lt;/span&gt;
        &lt;span&gt;for&lt;/span&gt;&lt;span&gt; (Element e : list) {
            map.put(e.getName(), e.getText());
        }

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        07 关闭输入流&lt;/span&gt;
&lt;span&gt;        ins.close();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        08 返回存放xml内容的Map对象&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; map;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step04 创建一个com.xunyji.xunyjitest.web.weixin.WeixinController#receiveMessage方法用于接收微信平台发送的POST请求&lt;/p&gt;
&lt;p&gt;　　step0401 该方法接收POST请求&lt;/p&gt;
&lt;p&gt;　　step0402 通过 HttpServletRequest 对象获取微信平台传过来的XML数据包&lt;/p&gt;
&lt;p&gt;　　step0403 将XML数据转化成Map数据并打印输出&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @PostMapping
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; receiveMessage(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, DocumentException {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        01 请求、响应编码格式设定&lt;/span&gt;
        request.setCharacterEncoding(&quot;UTF-8&quot;&lt;span&gt;);
        response.setCharacterEncoding(&lt;/span&gt;&quot;UTF-8&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        02 获取输出对象&lt;/span&gt;
        PrintWriter out =&lt;span&gt; response.getWriter();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        03 获取微信平台传过来的请求参数【PS：默认是XML格式的，这里转化成了Mapl类型】&lt;/span&gt;
        Map&amp;lt;String, String&amp;gt; receiveMap =&lt;span&gt; TransformUtils.xml2Map(request);
        log.info(&lt;/span&gt;&quot;接收微信消息时获取到的信息为：&quot; +&lt;span&gt; receiveMap);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        04 从Map对象中获取单个数据&lt;/span&gt;
        String fromUserName = receiveMap.get(&quot;FromUserName&quot;&lt;span&gt;);
        String toUserName &lt;/span&gt;= receiveMap.get(&quot;ToUserName&quot;&lt;span&gt;);
        String msgType &lt;/span&gt;= receiveMap.get(&quot;MsgType&quot;&lt;span&gt;);
        String content &lt;/span&gt;= receiveMap.get(&quot;Content&quot;&lt;span&gt;);

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　step0404 启动项目并通过粉丝账户向公众号发送文本消息，效果如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190109220112720-1255171027.png&quot; alt=&quot;&quot; width=&quot;812&quot; height=&quot;276&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;3 回复文本消息&lt;/h2&gt;
&lt;p&gt;　　回复文本消息属于被动回复消息的范围，微信官网提供的被动回复消息文档：https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;amp;id=mp1421140543&lt;/p&gt;
&lt;p&gt;　　技巧01：粉丝向公众号发送消息时微信服务器会向开发者服务器发送一个POST请求，开发者可以从这个POST请求中获取到一些信息，也可以像发送者返回一些信息&lt;/p&gt;
&lt;h3&gt;3.1 回复文本消息XML格式&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;xml&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;ToUserName&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt; ![CDATA&lt;/span&gt;&lt;span&gt;[toUser] ]&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;ToUserName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;FromUserName&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt; ![CDATA&lt;/span&gt;&lt;span&gt;[fromUser] ]&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;FromUserName&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;CreateTime&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;12345678&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;CreateTime&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;MsgType&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt; ![CDATA&lt;/span&gt;&lt;span&gt;[text] ]&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;MsgType&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
    &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;&lt;/span&gt;&lt;span&gt; ![CDATA&lt;/span&gt;&lt;span&gt;[你好] ]&lt;/span&gt;&lt;span&gt;&amp;gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;Content&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;xml&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2 回复文本消息参数说明&lt;/h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;是否必须&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;ToUserName&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;接收方帐号（收到的OpenID）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;FromUserName&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;开发者微信号&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;CreateTime&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;消息创建时间 （整型）&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;MsgType&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;image&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;2&quot;&gt;&lt;td&gt;MediaId&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;通过素材管理中的接口上传多媒体文件，得到的id。&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h3&gt;3.3 Java代码实现&lt;/h3&gt;
&lt;p&gt;step01 创建一个com.xunyji.xunyjitest.model.weixin.send.SendBaseMessage类作为所有被动回复消息的基类&lt;/p&gt;
&lt;p&gt;step02 创建一个com.xunyji.xunyjitest.model.weixin.send.ReplyTextMessage类作为回复文本消息的实体类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Data
@NoArgsConstructor
@AllArgsConstructor
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ReplyTextMessage &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ReplyBaseMessage {
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 回复的消息内容（换行：在content中能够换行，微信客户端就支持换行显示） &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String Content;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step03 创建一个com.xunyji.xunyjitest.comm.enums.weixin.MessageTypeEnum枚举类来存放各种消息类型&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Getter
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;enum&lt;/span&gt;&lt;span&gt; MessageTypeEnum {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    接收普通消息类型【0开头表示接收的消息类型】 start&lt;/span&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 被动回复文本消息 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
    RECEIVE_MESSAGE_TEXT(&lt;/span&gt;001, &quot;text&quot;&lt;span&gt;),
    RECEIVE_MESSAGE_IMAGE(&lt;/span&gt;002, &quot;image&quot;&lt;span&gt;),
    RECEIVE_MESSAGE_VOICE(&lt;/span&gt;003, &quot;voice&quot;&lt;span&gt;),
    RECEIVE_MESSAGE_LOCATION(&lt;/span&gt;004, &quot;location&quot;&lt;span&gt;),
    RECEIVE_MESSAGE_LINK(&lt;/span&gt;005, &quot;link&quot;&lt;span&gt;),
    RECEIVE_MESSAGE_SHORTVIDEO(&lt;/span&gt;06, &quot;shortvideo&quot;&lt;span&gt;),
    RECEIVE_MESSAGE_VIDEO(&lt;/span&gt;007, &quot;video&quot;&lt;span&gt;),
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;    接收普通消息类型【0开头表示接收的消息类型】 end&lt;/span&gt;
&lt;span&gt;    ;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 消息类型编号 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; Integer code;
    &lt;/span&gt;&lt;span&gt;/**&lt;/span&gt;&lt;span&gt; 消息类型（和微信文档中保持一致） &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String type;

    MessageTypeEnum(Integer code, String type) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.code =&lt;span&gt; code;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.type =&lt;span&gt; type;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step04 创建一个com.xunyji.xunyjitest.comm.util.weixin.MessageUtils类作为各种消息封装类&lt;/p&gt;
&lt;p&gt;　　step0401 创建com.xunyji.xunyjitest.comm.util.weixin.MessageUtils#replyTextMessageToXml方法实现将ReplyTextMessage 转化成 XML&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * ReplyTextMessage 转化成 XML
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; replyTextMessage
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;private&lt;/span&gt;&lt;span&gt; String replyTextMessageToXml(ReplyTextMessage replyTextMessage) {
        XStream xStream &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; XStream();
        xStream.alias(&lt;/span&gt;&quot;xml&quot;&lt;span&gt;, replyTextMessage.getClass());
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; xStream.toXML(replyTextMessage);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　step0402 创建com.xunyji.xunyjitest.comm.util.weixin.MessageUtils#initReplyTextMessage方法实现封装回复文本消息时所需的XML格式字符串&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * 封装XML格式的&quot;发送文本消息&quot;
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; fromUserName 粉丝appId
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; toUserName 公众号appId
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; content XML格式的字符串
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt;&lt;span&gt; String initReplyTextMessage(String fromUserName, String toUserName, String content) {
        ReplyTextMessage text &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ReplyTextMessage();
        text.setToUserName(fromUserName);
        text.setFromUserName(toUserName);
        text.setMsgType(MessageTypeEnum.RECEIVE_MESSAGE_TEXT.getType());
        &lt;/span&gt;&lt;span&gt;long&lt;/span&gt; time =&lt;span&gt; System.currentTimeMillis();
        text.setCreateTime(String.valueOf(time));
        text.setContent(&lt;/span&gt;&quot;逆向公众号发送了：&quot; +&lt;span&gt; content);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; replyTextMessageToXml(text);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step05 重构com.xunyji.xunyjitest.web.weixin.WeixinController#receiveMessage方法实现接收文本消息时回复文本消息，其他消息不做任何处理&lt;/p&gt;
&lt;p&gt;　　step0501 从封装了请求数据的map集合中获取公众号appid（toUserName）、粉丝appid（fromUserName）、接收消息类型（msgType）&lt;/p&gt;
&lt;p&gt;　　step0502 判断接收消息类型并做相应处理，此处以接收到的消息类型为文本消息为例&lt;/p&gt;
&lt;p&gt;　　　　如果是文本消息就获取文本内容，然后封装响应数据即可&lt;/p&gt;
&lt;p&gt;　　step0503 必须对响应数据进行非空处理，因为如果响应数据为null就会出现一个错误，很影响用户体验&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190109225118476-1534711243.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;&lt;img id=&quot;code_img_closed_ab8bc6ab-9ed1-486a-9155-403ddbafe052&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ab8bc6ab-9ed1-486a-9155-403ddbafe052&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ab8bc6ab-9ed1-486a-9155-403ddbafe052&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;65&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @PostMapping
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; receiveMessage(HttpServletRequest request, HttpServletResponse response) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, DocumentException {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        01 请求、响应编码格式设定&lt;/span&gt;
        request.setCharacterEncoding(&quot;UTF-8&quot;&lt;span&gt;);
        response.setCharacterEncoding(&lt;/span&gt;&quot;UTF-8&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        02 获取输出对象&lt;/span&gt;
        PrintWriter out =&lt;span&gt; response.getWriter();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        03 获取微信平台传过来的请求参数【PS：默认是XML格式的，这里转化成了Mapl类型】&lt;/span&gt;
        Map&amp;lt;String, String&amp;gt; receiveMap =&lt;span&gt; TransformUtils.xml2Map(request);
        log.info(&lt;/span&gt;&quot;接收微信消息时获取到的信息为：&quot; +&lt;span&gt; receiveMap);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        04 从Map对象中获取单个数据&lt;/span&gt;
        String fromUserName = receiveMap.get(&quot;FromUserName&quot;&lt;span&gt;);
        String toUserName &lt;/span&gt;= receiveMap.get(&quot;ToUserName&quot;&lt;span&gt;);
        String msgType &lt;/span&gt;= receiveMap.get(&quot;MsgType&quot;&lt;span&gt;);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        05 用于存放String类型的XML格式响应数据&lt;/span&gt;
        String message = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        06 如果接收的消息类型是text类型的处理逻辑&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt;&lt;span&gt; (MessageTypeEnum.RECEIVE_MESSAGE_TEXT.getType().equals(msgType)) {
            String content &lt;/span&gt;= receiveMap.get(&quot;Content&quot;&lt;span&gt;);
            message &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MessageUtils().initReplyTextMessage(fromUserName, toUserName, content);
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        07 响应对象非空处理，如果返回null会报异常（影响用户体验）&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (message == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            message &lt;/span&gt;= &quot;&quot;&lt;span&gt;;
        }
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        08 打印XML格式的响应消息&lt;/span&gt;
        log.info(&quot;被动回复消息的XML格式为：&quot; +&lt;span&gt; message);
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        09 响应XML格式数据给微信服务器&lt;/span&gt;
&lt;span&gt;        out.print(message);

    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt; step06 启动项目并向公众号发送文本消息，效果如图所示&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190109225350976-327518793.png&quot; alt=&quot;&quot; width=&quot;848&quot; height=&quot;120&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.4 代码重构&lt;/h3&gt;
&lt;p&gt;　　应该根据不同的消息类型调用不同的服务层方法来实现业务逻辑，不应该将所有业务逻辑都放到controller层中&lt;/p&gt;
&lt;p&gt;step01 引入fastjson依赖，因为需要将Map转化成Bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&amp;lt;!--&lt;/span&gt;&lt;span&gt; https://mvnrepository.com/artifact/com.alibaba/fastjson &lt;/span&gt;&lt;span&gt;--&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;com.alibaba&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;groupId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;fastjson&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;artifactId&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
            &lt;span&gt;&amp;lt;&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;1.2.54&lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;version&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
        &lt;span&gt;&amp;lt;/&lt;/span&gt;&lt;span&gt;dependency&lt;/span&gt;&lt;span&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step02 创建com.xunyji.xunyjitest.service.ReceiveMessageService接口用于定义处理各种接收到的消息&lt;/p&gt;
&lt;p&gt;step03 创建com.xunyji.xunyjitest.service.ReceiveMessageServiceImpl实现了实现处理各种接收到的消息&lt;/p&gt;
&lt;p&gt;step04 创建com.xunyji.xunyjitest.comm.TransformUtils#parseMap2Object方法用于将Map转化成Bean&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
     * Map类型转化成指定类型
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; paramMap 待转化的Map对象
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; clazz 目标类型的类类型
     * &lt;/span&gt;&lt;span&gt;@param&lt;/span&gt;&lt;span&gt; &amp;lt;T&amp;gt; 目标类型
     * &lt;/span&gt;&lt;span&gt;@return&lt;/span&gt;
     &lt;span&gt;*/&lt;/span&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &amp;lt;T&amp;gt; T parseMap2Object(Map&amp;lt;String, String&amp;gt; paramMap, Class&amp;lt;T&amp;gt;&lt;span&gt; clazz) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; JSONObject.parseObject(JSONObject.toJSONString(paramMap), clazz);
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;step05 创建com.xunyji.xunyjitest.service.ReceiveMessageServiceImpl#textMessageHandler方法用于处理文本类型消息&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190109231941477-1107588173.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37.5&quot;&gt;&lt;img id=&quot;code_img_closed_95f13502-4108-4c9c-b897-dd47870748d6&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_95f13502-4108-4c9c-b897-dd47870748d6&quot; class=&quot;code_img_opened&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_95f13502-4108-4c9c-b897-dd47870748d6&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;70&quot;&gt;
&lt;pre&gt;
&lt;span&gt;    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; String textMessageHandler(Map&amp;lt;String, String&amp;gt;&lt;span&gt; receiveParam) {
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        01 用于存放封装好的回复文本消息的XML数据&lt;/span&gt;
        String message = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        02 将Map类型参数转化成ReceiveTextMessage类型&lt;/span&gt;
        ReceiveTextMessage receiveTextMessage = TransformUtils.parseMap2Object(receiveParam, ReceiveTextMessage.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
        log.info(&lt;/span&gt;&quot;接收到的text消息请求参数为：&quot; +&lt;span&gt; receiveTextMessage);

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        03 获取文本内容和双方信息
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        0301 粉丝appId&lt;/span&gt;
        String fromUserName =&lt;span&gt; receiveTextMessage.getFromUserName();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        0302 公众号appId&lt;/span&gt;
        String toUserName =&lt;span&gt; receiveTextMessage.getToUserName();
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        0303 接收到的文本内容&lt;/span&gt;
        String content =&lt;span&gt; receiveTextMessage.getContent();
        content &lt;/span&gt;=&lt;span&gt; content.trim();

&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;        04 根据文本内容响应不同的数据 TODO: 应该将接收到的消息信息存储到数据库或者缓存中&lt;/span&gt;
        &lt;span&gt;if&lt;/span&gt; (&quot;1&quot;&lt;span&gt;.equals(content)) {
            message &lt;/span&gt;=&lt;span&gt; messageUtils.initReplyTextMessage(fromUserName, toUserName, messageUtils.firstMenu());
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;2&quot;&lt;span&gt;.equals(content)) {
            message &lt;/span&gt;=&lt;span&gt; messageUtils.initReplyTextMessage(fromUserName, toUserName, messageUtils.secondMenu());
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; (&quot;?&quot;.equals(content) || &quot;？&quot;&lt;span&gt;.equals(content)) {
            message &lt;/span&gt;=&lt;span&gt; messageUtils.initReplyTextMessage(fromUserName, toUserName, messageUtils.menuText());
        } &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt; {
            message &lt;/span&gt;=&lt;span&gt; messageUtils.initReplyTextMessage(fromUserName, toUserName, content);
        }

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; message;
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;View Code&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;step06 在com.xunyji.xunyjitest.web.weixin.WeixinController#receiveMessage方法中，如果是文本消息类型就调用com.xunyji.xunyjitest.service.ReceiveMessageService#textMessageHandler实现业务处理&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190109232128614-1780800272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;step07 启动应用并以此发送 1、2、？、?，效果图如下：&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190109232235946-424068947.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;4 接入百度翻译功能&lt;/h2&gt;
&lt;p&gt;　　待定更新时间：2019年1月10日23:23:02&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1057762/201901/1057762-20190109232346854-1591763347.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;扫码获取源代码&lt;/span&gt;&lt;/p&gt;


</description>
<pubDate>Wed, 09 Jan 2019 15:31:00 +0000</pubDate>
<dc:creator>寻渝记</dc:creator>
<og:description>1 说明 本篇博文承接上一篇博文：https://www.cnblogs.com/NeverCtrl-C/p/10241763.html 2 接收文本消息 微信公众号官方文档：https://mp.w</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/NeverCtrl-C/p/10247498.html</dc:identifier>
</item>
<item>
<title>最简单的JS实现json转csv - LinkLee</title>
<link>http://www.cnblogs.com/sunlightlee/p/10247501.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sunlightlee/p/10247501.html</guid>
<description>&lt;p&gt;　　工作久了，总会遇到各种各样的数据处理工作，比如同步数据，初始化一些数据，目前比较流行的交互数据格式就是JSON，可是服务器中得到的JSON数据如果提供给业务人员看的话可能会非常不方便，这时候，转成CSV文件，可以方便的被Excel工具进行读写。另外就是，json转CSV之后，会很容易的同部到数据库中，这样也非常有用，当然，这些软件功能已经被人开发过了，但是网上的多数代码都比较复杂，那些在线的转换工具也有不少，但是考虑数据安全，还是尽量别往任何不相干的网站上传数据，要知道万一敏感数据泄露可能会对自己非常不利。这里放上比较简单的一种实现方式，供大家使用：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;44&quot;&gt;
&lt;pre class=&quot;brush:html;gutter:true;&quot;&gt;
&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;title&amp;gt;JSON to CSV&amp;lt;/title&amp;gt;
   
    &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
    var json3 = { &quot;d&quot;: &quot;[{\&quot;Id\&quot;:1,\&quot;UserName\&quot;:\&quot;Sam Smith\&quot;},{\&quot;Id\&quot;:2,\&quot;UserName\&quot;:\&quot;Fred Frankly\&quot;},{\&quot;Id\&quot;:1,\&quot;UserName\&quot;:\&quot;Zachary Zupers\&quot;}]&quot; }

    //var winners = '{}';
    var winnerObject = JSON.parse(json3);
    
    downloadJSON2CSV(winnerObject);

    function downloadJSON2CSV(objArray)
    {
        var array = typeof objArray != 'object' ? JSON.parse(objArray) : objArray;

        var str = '';

        for (var i = 0; i &amp;lt; array.length; i++) {
            var line = '';

            for (var index in array[i]) {
                line += array[i][index] + ',';
            }

            // 添加双引号
            // for (var index in array[i]) {
            //    line += '&quot;' + array[i][index] + '&quot;,';
            // }

            line.slice(0,line.Length-1); 

            str += line + '\r';
        }
        window.open( &quot;data:text/csv;charset=utf-8,&quot; + str)
    }

    &amp;lt;/script&amp;gt;

&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;h1&amp;gt;This page onvert json to csv...&amp;lt;/h1&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;


</description>
<pubDate>Wed, 09 Jan 2019 15:31:00 +0000</pubDate>
<dc:creator>LinkLee</dc:creator>
<og:description>工作久了，总会遇到各种各样的数据处理工作，比如同步数据，初始化一些数据，目前比较流行的交互数据格式就是JSON，可是服务器中得到的JSON数据如果提供给业务人员看的话可能会非常不方便，这时候，转成CS</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/sunlightlee/p/10247501.html</dc:identifier>
</item>
<item>
<title>.NET程序员不加班——写在《华为工程师猝死，36岁，22月无休》之后 - 自由飞</title>
<link>http://www.cnblogs.com/freeflying/p/10236065.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/freeflying/p/10236065.html</guid>
<description>&lt;p&gt;我首先承认，有点标题党。因为这是我这个十年老码农——过了年就整整11年了，o(╥﹏╥)o——的个人观察、经验所得。如果有仍在加班的.NET童鞋，不要打我。一定要打的话，只有一个要求：不要打脸！&lt;/p&gt;
&lt;p&gt;写这篇博客是因为这篇报道：&lt;a href=&quot;https://news.cnblogs.com/n/616634/&quot;&gt;华为工程师猝死，36岁，22月无休：比挣钱更重要的是活着&lt;/a&gt;。作为一个37岁边缘，马上就要38周岁的老码农，心有戚戚。这个年龄，上有老下有小，自己走了就走了，但他们……唉，一声叹息。&lt;/p&gt;
&lt;p&gt;我刚入行的时候，就听人说，“珍惜生命，远离华为”，那时候还以为只是一句调侃。后来有认识的进了华为，隐隐约约听到他们的年薪，心里也还悄悄地酸不拉几了一下。但当这种血淋淋的现实摆在眼前，心里还是忍不住的震撼了一下。&lt;/p&gt;
&lt;p&gt;以前类似的事情，我多半会觉得言过其实，哪有什么“过劳死”，活人还会被尿憋死？累了不会打个盹么？说不定这人自己身体有啥问题……但这段文字，让我真的无话可说：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/49387/201901/49387-20190107181314578-1623280171.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;昨天为了省钱，飞哥自己给“源栈”刷地坪漆，半天下来，我的那个老腰哟——真正地体会到了什么叫做“岁月不饶人”。有时候，我们的心还年轻，但身体已经顶不住了。所以，还像年轻的时候那么拼，就真的要出问题了。&lt;/p&gt;
&lt;p&gt;又跑题了，还是说加班的问题。我当程序猿这么多年了，就真没怎么加过班。原因以前我也总结过，大致两条：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;一直用的.NET&lt;/li&gt;
&lt;li&gt;欧美外企工作&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;好吧，好吧，我承认，或许还有一条：我不怎么“追求上进”，嘿嘿，(*^▽^*)&lt;/p&gt;
&lt;p&gt;前面两条原因我在&lt;a href=&quot;http://17bang.ren/Article/102&quot; target=&quot;_blank&quot;&gt;学ASP.NET入门编程，合适么?&lt;/a&gt;已经解释过了：&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;一方面，愿意选择ASP.NET、肯花钱买windows server（服务器没人敢用盗版）的公司，“压榨人工”的渴望就不太强烈（&lt;em&gt;这个表述大家领会意思就可以了，不要怼飞哥。我知道，这个推断是不全面的、不可逆的&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;另一方面，使用ASP.NET的多半不是互联网行业，做的是2B（to Business）系统，一般都比较成熟稳定，紧迫性不高，比较从容；不像2C（to Customer）那样“赶”，需求今天改明天变，而且是你追我赶的要“啖头汤”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里，我为我的“不求上进”做点自我辩护。&lt;/p&gt;
&lt;p&gt;其实在我决定开设&lt;a href=&quot;http://17bang.ren/Article/255&quot; target=&quot;_blank&quot;&gt;ASP.NET全栈课程&lt;/a&gt;的时候，就已经有朋友劝我了：干嘛不教Java？现在这么火！你会C#，转Java超级简单的……但我不为所动，抛开其他种种考虑，“不求上进”也是其中的一个原因了。真正对自己狠的人，不论是找工作还是做培训，那就是不断地追求“利益最大化”：什么“火”或者什么“新”就学什么。就这三五年，我知道的：Android/iOS，node.js，各种前端框架，乱烘烘你方唱罢我登场，很多做培训的着实狠狠地捞了一笔！至于现在/后来凉了，反正钱都已经收了，是不是？&lt;/p&gt;
&lt;p&gt;ʅ(‾◡◝)ʃ&lt;/p&gt;
&lt;p&gt;我没有其他啥意思，要说实话：其实我有点嫉妒。这些人真的能拼，和有些同学想的不一样，这些培训老师可能也就是前脚学会后脚就开始上课了。没办法啊，这些技术也就刚刚出来，哪里去找“十/五/三/两年以上应用经验”的人？但他们就能控制住课堂，装出一副胸有成竹的样子，唬得学员一愣一愣的。飞哥就没有这种拼搏精神了，要教就教点自己熟悉的吧，轻松点，不心虚。&lt;/p&gt;
&lt;p&gt;反正我同时最多就只能有18个学员，全国这么大，只要真的把课讲好了，18个愿意学ASP.NET的人总是能找到的。我就不信所有人都是跟风的：因为大家都在学Java，所以我也跟着学Java吧。就没几个不跟风想抄底的？&lt;/p&gt;
&lt;p&gt;这些年经历的事越多，越觉得这个世界是大致公平的。很多古话越咀嚼越有味道，比如“世间事不如意十之八九”，最开始会以为这是一种悲观颓废；后来会觉得这里面居然有正能量（毕竟还有一二如意不是）；但现在，我觉得这不过是说一个事实而已。更有意思的是，所谓“世间事”，是世间所有的事，所有人的所有事，无论贫富贵贱贤与不肖！所以，这里面又透出一股子大道无情一视同仁，也就是公平的味道出来。&lt;/p&gt;
&lt;p&gt;自从暴露了我“黑律师/包工头/创业狗/野生程序猿……”的黑历史之后，长期收到这种问题：我要转行学编程，选哪一门语言好呢？这个问题很长一段时间让我很纠结（&lt;em&gt;现在不纠结了，当然是跟着飞哥学C#，斜眼笑.jpg&lt;/em&gt;）。因为压力很大，很怕给别人一个“错误的”建议，误了别人的终身！我连这些语言现在的优劣都分辨不出来，更遑论他们以后的发展和前途？最简单的，十年前，谁会想到微软会“拥抱开源”？别说十年了，就一年前，谁会想到这两天&lt;a href=&quot;http://www.sohu.com/a/287573727_115128&quot; target=&quot;_blank&quot;&gt;GitHub 私有库免费无限开放！&lt;/a&gt;的消息刷屏？唱衰.NET也就不过这两年的事，五年前，“Java已死”的声音才是主流吧？还有曾经高潮得一塌糊涂的node.js，要干掉SQL的noSql，现在不都凉了？&lt;/p&gt;
&lt;p&gt;世事无常，谁要是真能预测未来——艹，还用得着苦逼敲代码？去买股票算了！&lt;/p&gt;
&lt;p&gt;所以，敢拍着胸脯保证什么语言/技术一定有前途的，真就应了那句话，“不是蠢就是坏”。&lt;em&gt;（&lt;/em&gt;咳咳，飞哥除外？）&lt;/p&gt;
&lt;p&gt;回到之前那个问题：我要转行学编程，选哪一门语言好呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;随缘算了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为不管你怎么选，都不可能十全十美的，都不能保证这个选择是最正确的。以前说“三十年河东三十年河西”，在软件开发领域，“三年河东三年河西”还差不多！算你20岁开始学，60岁退休，中间40年的时间，什么变化都是可能的，唯一不变的可能就是变化。&lt;/p&gt;
&lt;p&gt;这个道理我记得也讲过很多次了。再举个例子吧，学编程选语言，大概就类似于学法律选方向，究竟是民法有前途还是学刑法有前途，这个问题怎么回答？学好了都有前途，可能这是最标准最正确的回答了。计算机各种语言也一样，而且很大概率到最后你什么语言都要学一点。就和法律职业资格考试一样，什么法都要考，因为案件难免会有交叉，民事领域的案子一过界就归刑法管了。你当然可以有一个主攻方向，但想着只管这个方向其他的都不闻不问肯定是不可能的。ASP.NET是飞哥的主攻方向，但这些年，C、Java、VB、Python……这么多语言，我啥都碰过了，难道说这不是我的方向，分到手上的活就不干了？你要敢这样，等着被老大喷一脸的口水吧！别说后来了，我培训的时候还学的是JSP呢，出来还不是干ASP.NET？ASP.NET好歹还学了点，那时候已经是WebForm 2.0了，比较火；最悲催的是，工作内容是升级之前的ASP系统，在一堆Html/JavaScript里去扒拉，VBScript既看不懂也不会调试——说起来都是泪。&lt;/p&gt;
&lt;p&gt;后来慢慢就习惯了，也明白了：这才是程序猿的常态。是你去适应项目，而不是让项目来适应你。各种语言之间转来转去的程序猿太多了，换个公司换个项目甚至啥都没换技术进步，都逼得你要不断的学习新技术。所以你回过头来想，纠结最开始入门的语言真是没什么必要。那些语言之争的月经贴，感兴趣的一定是菜鸟。像我们这些老码农，早就麻木了，不光是对语言优劣麻木，对新技术一样麻木。就那样呗，该用的时候就用，新鲜出炉的东西，等它先凉一下再说，谁都不愿意去“趟坑”……&lt;/p&gt;
&lt;p&gt;反复宣传什么什么“主流语言”“新技术”的老家伙，多半别有居心——嘿嘿，我承认，飞哥也是有点小心思，看破不说破，你懂的。&lt;/p&gt;
&lt;p&gt;差不多了，图穷匕见：&lt;/p&gt;
&lt;p&gt;————————————————&lt;/p&gt;
&lt;p&gt;“源栈”ASP.NET课程，再来一波大促销。考验同学们人脉的时候到了：&lt;/p&gt;
&lt;p&gt;1个人来报名9折，2个人组团来报名8折（注意：是两个人都8折！），3个人组团7折……直到最低5折，或者源栈首批18位学员满额（&lt;em&gt;已有8位同学缴纳订金&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;有意者，欢迎QQ群（729600626）撩我，&lt;img src=&quot;http://qzonestyle.gtimg.cn/qzone/em/e113.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;————————————————&lt;/p&gt;
&lt;p&gt;感谢博客园一直以来的包容，下一篇来点干货：《新手如何理解面向对象》，欢迎关注。&lt;/p&gt;
</description>
<pubDate>Wed, 09 Jan 2019 15:30:00 +0000</pubDate>
<dc:creator>自由飞</dc:creator>
<og:description>我首先承认，有点标题党。因为这是我这个十年老码农——过了年就整整11年了，o(╥﹏╥)o——的个人观察、经验所得。如果有仍在加班的.NET童鞋，不要打我。一定要打的话，只有一个要求：不要打脸！ 写这篇</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/freeflying/p/10236065.html</dc:identifier>
</item>
<item>
<title>其实你可以少写点if else和switch - 潇湘待雨</title>
<link>http://www.cnblogs.com/pqjwyn/p/10247336.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/pqjwyn/p/10247336.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;作为搬砖在第一线的底层工人，业务场景从来是没有做不到只有想不到的复杂。&lt;br/&gt;不过他强任他强，if-else全搞定，搬就完了。但是随着业务迭代或者项目交接，自己在看自己或者别人的if代码的时候，心情就不再表述了，各自深有体会。所以我们一起看看if还能怎么写&lt;/p&gt;
&lt;h2 id=&quot;最基本if-else&quot;&gt;最基本if-else&lt;/h2&gt;
&lt;p&gt;假设有这么个场景,不同情况下打印不同值。&lt;br/&gt;因为涉及到的条件太多，就不提三目运算之类优化了。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;if (a == 1) {
    console.log('a1')
} else if (a == 2) {
    console.log('b2')
} else if (a == 3) {
    console.log('c3')
} else if (a == 4) {
    console.log('d4')
}
/* n..... */&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在还算能看，因为逻辑简单，如果逻辑复杂，迭代多个版本之后，你还敢动吗。&lt;br/&gt;每动一下就战战兢兢，谁知道哪里会遗漏。&lt;br/&gt;那么换种方式呢&lt;/p&gt;
&lt;h2 id=&quot;switch-case&quot;&gt;switch-case&lt;/h2&gt;
&lt;p&gt;这样稍微清晰那么一点,差别好像没什么差别：&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;switch(a){
    case 1:
        console.log('a1');
        break;
    /* 省略。。。 */  
    case 40:
        console.log('a40');
        break;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;分离配置信息与执行动作&quot;&gt;分离配置信息与执行动作&lt;/h2&gt;
&lt;h3 id=&quot;object映射&quot;&gt;object映射&lt;/h3&gt;
&lt;p&gt;定义一个object作为配置对象来存放不同状态，通过链表查找&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const statusMap = {
    1:()=&amp;gt;{
        console.log('a1')
    },
    2:()=&amp;gt;{
        console.log('b2')
    }
    /* n.... */
}
// 执行
let a = 1 
statusMap[a || 1]()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样比较清晰，将条件配置与具体执行分离。如果要增加其他状态，只修改配置对象即可。&lt;/p&gt;
&lt;h3 id=&quot;数组映射&quot;&gt;数组映射&lt;/h3&gt;
&lt;p&gt;当然在某些状态下可以使用数组，来做这个配置对象。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 这里就涉及其他优化了，例如将执行函数抽离出来，大家不要关注func的内容就好。
// 它就是个function，内容很复杂
const statusArr = [function(){
    console.log(1)
},
    function () {
        console.log(2)
    },]
// 执行
let a = 1
statusArr[a || 1]()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;数组的要求更高一点，如果是其他key，例如字符串，那么数组就不能满足需求了&lt;/p&gt;
&lt;h2 id=&quot;升级版不同key相同value&quot;&gt;升级版：不同key相同value&lt;/h2&gt;
&lt;p&gt;这样看起来好一点了，那么需求又有变动了，&lt;br/&gt;前面是每种处理方式都不同，下面有几种情况下处理函数相同的，&lt;br/&gt;例如1-39的时候，调用a，40之后调用b，如果我们继续来用映射的方式来处理。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function f1 (){
    console.log(1)
}
function f2 (){
    console.log(2)
}
const statusMap={
    1:f1,
    2:f1,
    3:f1,
    4:f1,
    //省略
    40:f2
}
let a = 2
statusMap[a]()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这样当然也可以，不过重复写那么多f1，代码看起来不够简洁。&lt;/p&gt;
&lt;p&gt;开始重构之前我们先捋一下思路，无非是想把多个key合并起来，对应一个value。&lt;br/&gt;也就是说我们的键值不是字符串而是个数组，object显然只支持字符串，&lt;br/&gt;那么可以将这么多key合并成一个：'1,2,3,4,..,9'。&lt;/p&gt;
&lt;p&gt;但是查找的时候有点问题了，我们的参数肯定不能完全匹配。&lt;br/&gt;接着走下去，是不是做个遍历加个判断，包含在子集内的都算匹配，那么代码看起来就是下面这个样子。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 将键值key设置为一个拼接之后的字符串
const statusMap = {
    '1,2,3,4,5': f1,
    //省略
    40: f2
}
// 获取所有的键值，待会遍历用
const keys = Object.keys(statusMap),
    len = keys.length
// 遍历获取对应的值 
const getVal=(param='')=&amp;gt;{
    // 用for循环的原因在于匹配之后就不需要继续遍历
    for (let i = 0; i &amp;lt; len; i++) {
        const key = keys[i],
            val = statusMap[key]
        // 这里用什么来判断就随便了，两个字符串都有。    
        if (key.includes(param)) {
            return val
        }
    }
}
let a = 2,
    handle = getVal(a)
handle() // 1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是这样来看，增加了个遍历的过程，而且是拼接字符串，万一哪天传了个逗号进来，会得到了预料之外的结果。&lt;/p&gt;
&lt;h3 id=&quot;map&quot;&gt;map&lt;/h3&gt;
&lt;p&gt;es6有个新的数据结构Map，支持任意数据结构作为键值。如果用Map可能更清晰一点。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/**
 * map键值索引的是引用地址，
 * 如果是下面这样的写法不好意思，永远得不到值
 * map1.set([1,4,5],'引用地址')
 * map1.get([1,4,5])  //输出为undefined
 * 就像直接访问
 * map1.get([1,2,3,4,5]) //同样为undefined
 */
const map1 = new Map()
const statusArr = [1,2,3,4,5]
map1.set(statusArr,f1)
// 预设默认值，因为不能直接遍历
let handle = function(){}
const getVal = (param = '') =&amp;gt; {
for (let value of map1.entries()) {
    console.log(JSON.stringify(value))
    if (value[0].includes(param)){
        console.log(value)
        // 不能跳出 只能处理了
        handle = value[1]
    }
}
}
const a = 2
getVal(a)
handle()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;个人而言虽然这样减少了重复代码，但是又增加了一步匹配值的操作，优劣就见仁见智吧。&lt;/p&gt;
&lt;h3 id=&quot;二维数组&quot;&gt;二维数组&lt;/h3&gt;
&lt;p&gt;肯定有部分人就是不想做遍历的操作，既然一个数组不能满足，那么两个数组呢。&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;// 键值数组和value 保持对应关系
const keyArr = ['1,2,3,4,5','40']
const valArr = [f1,f2]
const getVal = (param = '')=&amp;gt;{
    // 查找参数对应的下标
    let index = keyArr.findIndex((it)=&amp;gt;{
        return it.includes(param)
    })
    // 获取对应值
    return valArr[index]
}
let a = 2,
    handle = getVal(a)
handle()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;利用数组提供的下标，将key和value对应起来，进而获取想要的值。&lt;br/&gt;这里一直没有达到我最初的目的，即键里面重复的数组，可以不通过多余操作匹配到，上面不管怎么样都进行了处理，这不是懒人的想要的。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;这是在写业务需求的时候做的一点总结，数组和对象的映射可能大家都在用。当遇到了不同key相同value的情况时，从懒出发不像重复罗列，就尝试了下。当然了，因为个人水平问题，肯定有更好的处理方式，欢迎一起讨论，抛砖引玉共同进步。此外现有成熟的库里loadsh也是可以到达目的，不过自己思考过之后再去看大神的作品理解会更深入一点。&lt;/p&gt;
</description>
<pubDate>Wed, 09 Jan 2019 14:42:00 +0000</pubDate>
<dc:creator>潇湘待雨</dc:creator>
<og:description>前言 作为搬砖在第一线的底层工人，业务场景从来是没有做不到只有想不到的复杂。 不过他强任他强，if else全搞定，搬就完了。但是随着业务迭代或者项目交接，自己在看自己或者别人的if代码的时候，心情就</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/pqjwyn/p/10247336.html</dc:identifier>
</item>
<item>
<title>开闭原则 - LieBrother</title>
<link>http://www.cnblogs.com/liebrother/p/10247314.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/liebrother/p/10247314.html</guid>
<description>&lt;p&gt;个人博客原文：&lt;br/&gt;&lt;a href=&quot;http://www.liebrother.com/open-closed-principle&quot;&gt;开闭原则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/c8e019382c954740a8f12f2a1369656b_0017_01.jpg&quot; alt=&quot;景&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;设计模式六大原则之六：开闭原则。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;姓名&lt;/strong&gt; ：开闭原则&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;英文名&lt;/strong&gt; ：Open Closed Principle&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;价值观&lt;/strong&gt; ：老顽童就是我，休想改变我&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;个人介绍&lt;/strong&gt; ：&lt;/p&gt;
&lt;p&gt;Software entities (classes, modules, functions, etc.) should be open for extension, but closed for modification.（软件中的对象（类，模块，函数等等）应该对于扩展是开放的，但是对于修改是封闭的）&lt;br/&gt;（来自维基百科）&lt;/p&gt;
&lt;p&gt;停更了三四天了，这几天比较忙，不仅仅是工作上，更多是精神上。周日突然老胃病又复发了，一直疼到凌晨 4，5 点。因为这次疼得蛮厉害的，所以准备去医院看一下医生，这时候才体验到大城市就医之苦。周日晚下载了微医 App （不是做广告哈），也不知道哪家医院好，在深圳两年半还没去过医院，随便选个三甲医院：北京大学深圳医院，看了消化内科门诊的医生列表，整整这一周主任医生都预约满了，顿时很崩溃，打电话给医院预约，最快只能预约 17 号，are you kidding？App 上有个 『立即问诊』功能，在线把状况告诉医生，医生一天之内接诊，需要花 60 块，我就尝试一下，没想到第二天医生回复后，说可以下午去医院看，他可以临时加号。就这样跳过了预约，直接看病，不知道你是否也苦于看病烦，可以尝试这个方法，当然，如果你有更好的方法，可以留言让更多的人了解到。&lt;/p&gt;
&lt;p&gt;跑题了跑题了，今天是想和大家分享设计模式最后一个原则：开闭原则。这个原则要求就是允许扩展，拒绝修改。既然上面讲到看医生，那就用一个跟看病有关的例子。&lt;/p&gt;
&lt;h2 id=&quot;故事从这里开始&quot;&gt;故事从这里开始&lt;/h2&gt;
&lt;p&gt;小明去医院看病，医生开了阿司匹林药，小明去了收费台，付了钱，总共 20 块钱。例子的代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class OcpTest {

    public static void main(String[] args) {
        Hospital hospital = new Hospital();
        IPatient xiaoMing = new Patient(&quot;小明&quot;);
        hospital.sellMedicine(xiaoMing);
    }

}


class Medicine {
    private String name;
    private BigDecimal price;

    public Medicine(String name, BigDecimal price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public BigDecimal getPrice() {
        return price;
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }
}

class Hospital {

    private Medicine medicine = new Medicine(&quot;阿司匹林&quot;, new BigDecimal(20));

    public void sellMedicine(IPatient patient) {
        BigDecimal money = patient.pay(medicine);
        System.out.println(patient.getName() + &quot; 花了 &quot; + money.setScale(2, BigDecimal.ROUND_UP) + &quot; 块钱买了药：&quot; + medicine.getName());
    }

}

interface IPatient {
    String getName();
    BigDecimal pay(Medicine medicine);
}

class Patient implements IPatient{

    private String name;

    public Patient(String name) {
        this.name = name;
    }

    @Override
    public BigDecimal pay(Medicine medicines) {
        return medicines.getPrice();
    }

    @Override
    public String getName() {
        return name;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二天和朋友聚会聊起这事，小红说道：不对呀，前几天我在医院也拿了阿司匹林药，才 14 块钱呢。小花说：奇怪了，我买的是 16 块钱。小杰回应：怎么我买的是 18 块。怎么这药这么多个价格。小明 Google 搜了一下，发现价格跟社保有关，几个人便发现，原来他们都是“不同人”：小明没有社保，小红社保是一档，小花社保是二挡，小杰社保是三挡。（假设社保一档打 7 折，社保二挡打 8 折，社保三挡打 9 折，虚拟的哈）&lt;br/&gt;发现了这秘密后，作为和 IT 工作相关的人，便讨论起医院系统具体实现是怎么实现的。小红说：这很简单呢，药品给不同人提供不同的价格。代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Medicine {
    private String name;
    private BigDecimal price;

    public Medicine(String name, BigDecimal price) {
        this.name = name;
        this.price = price;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public BigDecimal getPrice() {
        return price;
    }
    
    public BigDecimal getPrice1() {
        return price.multiply(new BigDecimal(0.7));
    }
    
    public BigDecimal getPrice2() {
        return price.multiply(new BigDecimal(0.8));
    }
    
    public BigDecimal getPrice3() {
        return price.multiply(new BigDecimal(0.9));
    }

    public void setPrice(BigDecimal price) {
        this.price = price;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小花说：药片本身的价格是不会变的，只是给不同人不同价格，所以可以在病人获取价钱的时候去区分。代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class Patient implements IPatient{

    private String name;
    private int level;

    public Patient(String name) {
        this.name = name;
    }

    @Override
    public BigDecimal pay(Medicine medicines) {
        if (level == 1) {
            return medicines.getPrice().multiply(new BigDecimal(0.7));
        } else if (level == 2) {
            return medicines.getPrice().multiply(new BigDecimal(0.8));
        } else if (level == 3) {
            return medicines.getPrice().multiply(new BigDecimal(0.9));
        }
        return medicines.getPrice();
    }

    @Override
    public String getName() {
        return name;
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;小杰陷入了沉思。。。&lt;br/&gt;小明发话：你们说的方法都可以实现，但是总感觉不对劲，如果以后有社保四挡，还是要修改原来的代码，前 2 天设计模式老师讲的开闭原则忘记了么？里面说要对扩展开放，对修改封闭。我觉得这个药片价格是因为我们人而变的，那是不是我们可以把没社保的归为一类人，一档社保的也为一类，以此类推。我觉得这样实现更好，增加多 3 类病人，分别是一档社保、二挡社保、三挡社保。代码如下：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;class OneLevelSocialSecurityPatient implements IPatient {

    private String name;

    public OneLevelSocialSecurityPatient(String name) {
        this.name = name;
    }

    @Override
    public BigDecimal pay(Medicine medicine) {
        return medicine.getPrice().multiply(new BigDecimal(0.7));
    }

    @Override
    public String getName() {
        return this.name;
    }
}

class TwoLevelSocialSecurityPatient implements IPatient {

    private String name;

    public TwoLevelSocialSecurityPatient(String name) {
        this.name = name;
    }

    @Override
    public BigDecimal pay(Medicine medicine) {
        return medicine.getPrice().multiply(new BigDecimal(&quot;0.8&quot;));
    }

    @Override
    public String getName() {
        return this.name;
    }
}

class ThreeLevelSocialSecurityPatient implements IPatient {

    private String name;

    public ThreeLevelSocialSecurityPatient(String name) {
        this.name = name;
    }

    @Override
    public BigDecimal pay(Medicine medicine) {
        return medicine.getPrice().multiply(new BigDecimal(&quot;0.9&quot;));
    }

    @Override
    public String getName() {
        return this.name;
    }
}

// 测试代码
public static void main(String[] args) {
    Hospital hospital = new Hospital();
    IPatient xiaoMing = new Patient(&quot;小明&quot;);
    hospital.sellMedicine(xiaoMing);

    IPatient xiaoHong = new OneLevelSocialSecurityPatient(&quot;小红&quot;);
    hospital.sellMedicine(xiaoHong);

    IPatient xiaoHua = new TwoLevelSocialSecurityPatient(&quot;小花&quot;);
    hospital.sellMedicine(xiaoHua);

    IPatient xiaoJie = new ThreeLevelSocialSecurityPatient(&quot;小杰&quot;);
    hospital.sellMedicine(xiaoJie);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码：&lt;br/&gt;&lt;a href=&quot;https://github.com/1CSH1/DesignPatterns/blob/master/src/com/liebrother/designpatterns/ocp/OcpTest.java&quot;&gt;OcpTest.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;看了他们的对话和代码，是不是能知道哪种方式更好了？对于小红来说，她没理清价格变化的原因，价格变化不在于药片；小花理清了，但是实现方式差了点，以后如果新增了四挡社保，她的实现要修改原有的代码，不符合开闭原则；小明的方法就符合开闭原则，如果新增四挡社保人员，他的方法只需要再额外扩展一个四挡社保人员就可以，不用动用其他代码。&lt;/p&gt;
&lt;p&gt;用了这个大家可能不太喜欢的看病的场景来描述这个开闭原则，不要忌讳哈，希望大家都健健康康，远离医院。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;重申一下：&lt;strong&gt;对扩展开放，对修改封闭&lt;/strong&gt;。如果有同学经常看一些开源框架源码就会发现，有很多很多抽象类和接口，debug 进去很绕，其实这些抽象类和接口很多都是为了扩展用，因为作为开源框架，不得不实现各种可想象到的方案，而这些都基于开闭原则来实现的。以后有机会也可以写一下源码的文章分享给大家。&lt;/p&gt;
&lt;p&gt;参考资料：《大话设计模式》、《Java设计模式》、《设计模式之禅》、《研磨设计模式》、《Head First 设计模式》&lt;/p&gt;
&lt;p&gt;这周事情比较多，更新会不及时，周五还要出差去一趟上海，周六回深圳，周日回一趟老家，各种奔波。。。&lt;/p&gt;
&lt;p&gt;希望文章对您有所帮助，设计模式系列会持续更新，感兴趣的同学可以关注公众号，第一时间获取文章推送阅读，也可以一起交流，交个朋友。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/mp/homepage?__biz=MzIxMzgwMTAyMg==&amp;amp;hid=2&amp;amp;sn=c97b64288d92312f57d3c8298f8d8888&quot;&gt;公众号之设计模式系列文章&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.liebrother.com/upload/df81ac224abe46b38131a0e78f4dcf9c_wechat.jpg&quot; alt=&quot;公众号&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Wed, 09 Jan 2019 14:39:00 +0000</pubDate>
<dc:creator>LieBrother</dc:creator>
<og:description>设计模式六大原则之六：开闭原则。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/liebrother/p/10247314.html</dc:identifier>
</item>
<item>
<title>【Netty】(9）---Netty编解码器 - 雨点的名字</title>
<link>http://www.cnblogs.com/qdhxhz/p/10245936.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qdhxhz/p/10245936.html</guid>
<description>&lt;p&gt;在了解Netty编解码之前,先了解Java的编解码:&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;编码&lt;/span&gt;（Encode）称为序列化， 它将&lt;span&gt;对象序列化为字节数组，用于网络传输、数据持久化或者其它用途&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;解码&lt;/span&gt;（Decode）称为反序列化，它把从&lt;span&gt;网络、磁盘等读取的字节数组还原成原始对象（通常是原始对象的拷贝）&lt;/span&gt;，以方便后续的业务逻辑操作。&lt;/p&gt;
&lt;p&gt;java序列化对象只需要实现java.io.&lt;span&gt;Serializable&lt;/span&gt;接口并生成序列化ID，这个类就能够通过java.io.ObjectInput和java.io.ObjectOutput序列化和反序列化。&lt;/p&gt;
&lt;p&gt;Java序列化&lt;span&gt;目的&lt;/span&gt;：1.网络传输。2.对象持久化。&lt;/p&gt;
&lt;p&gt;Java序列化&lt;span&gt;缺点&lt;/span&gt;：1.无法跨语言。 2.序列化后码流太大。3.序列化性能太低。&lt;/p&gt;
&lt;p&gt;Java序列化仅仅是Java编解码技术的一种，由于它的种种缺陷，衍生出了多种编解码技术和框架，这些编解码框架实现消息的高效序列化。&lt;/p&gt;
&lt;p&gt;下面我们来了解下Netty自己的编解码器。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;一、概念&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;      在网络应用中需要实现某种编解码器，将原始字节数据与自定义的消息对象进行互相转换。网络中都是以字节码的数据形式来传输数据的，服务器编码数据后发送到客户&lt;/p&gt;
&lt;p&gt;端，客户端需要对数据进行解码。&lt;/p&gt;
&lt;p&gt;netty提供了强大的编解码器框架，使得我们编写自定义的编解码器很容易，也容易封装重用。对于Netty而言，编解码器由两部分组成：编码器、解码器。 &lt;/p&gt;
&lt;p&gt;      &lt;span&gt;解码器&lt;/span&gt;：负责将消息从字节或其他序列形式转成指定的消息对象。&lt;/p&gt;
&lt;p&gt;      &lt;span&gt;编码器&lt;/span&gt;：将消息对象转成字节或其他序列形式在网络上传输。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;Netty 的编（解）码器实现了 ChannelHandlerAdapter，也是一种特殊的 ChannelHandler&lt;/span&gt;，所以依赖于 ChannelPipeline，可以将多个编（解）码器链接在一起，以实现复杂&lt;/p&gt;
&lt;p&gt;的转换逻辑。&lt;/p&gt;
&lt;p&gt;Netty里面的编解码： &lt;span&gt;解码器：负责处理“入站 InboundHandler”数据&lt;/span&gt;。   &lt;span&gt;编码器：负责“出站 OutboundHandler” 数据&lt;/span&gt;。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;二、解码器(Decoder)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;      解码器负责 解码“入站”数据&lt;span&gt;从一种格式到另一种格式&lt;/span&gt;，解码器处理入站数据是抽象&lt;span&gt;ChannelInboundHandler&lt;/span&gt;的实现。实践中使用解码器很简单，就是将入站数据转换格式后&lt;/p&gt;
&lt;p&gt;传递到ChannelPipeline中的下一个ChannelInboundHandler进行处理；这样的处理时很灵活的，我们可以将解码器放在ChannelPipeline中，重用逻辑。&lt;/p&gt;
&lt;p&gt;对于解码器，Netty中主要提供了抽象基类&lt;span&gt;ByteToMessageDecoder&lt;/span&gt;和&lt;span&gt;MessageToMessageDecoder&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190109170821697-1403986734.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;抽象解码器&lt;/p&gt;
&lt;p&gt;     1)  &lt;span&gt;ByteToMessageDecoder&lt;/span&gt;: 用于将字节转为消息，需要检查缓冲区是否有足够的字节&lt;/p&gt;
&lt;p&gt;    2)  &lt;span&gt;ReplayingDecoder&lt;/span&gt;: 继承ByteToMessageDecoder，不需要检查缓冲区是否有足够的字节,但是 ReplayingDecoder速度略慢于ByteToMessageDecoder,&lt;/p&gt;
&lt;p&gt;                                   同时不是所有的ByteBuf都支持。&lt;/p&gt;
&lt;p&gt;                            选择：项目复杂性高则使用ReplayingDecoder，否则使用 ByteToMessageDecoder&lt;/p&gt;
&lt;p&gt;    3）&lt;span&gt;MessageToMessageDecoder&lt;/span&gt;: 用于从一种消息解码为另外一种消息（例如POJO到POJO）&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;  1、ByteToMessageDecoder解码器&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      用于将接收到的二进制数据(Byte)解码，得到完整的请求报文(Message)。&lt;/p&gt;
&lt;p&gt;      ByteToMessageDecoder是一种ChannelInboundHandler，可以称为解码器，负责将byte字节流住(ByteBuf)转换成一种Message，Message是应用可以自己定义的一种&lt;/p&gt;
&lt;p&gt;Java对象。&lt;/p&gt;
&lt;p&gt; 下面列出了ByteToMessageDecoder两个主要方法：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; decode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt; out)&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这个方法是唯一的一个需要自己实现的抽象方法，作用是将ByteBuf数据解码成其他形式的数据。&lt;/span&gt;
decodeLast(ChannelHandlerContext, ByteBuf, List&amp;lt;Object&amp;gt;)，&lt;span&gt;//&lt;/span&gt;&lt;span&gt;实际上调用的是decode(...)。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;参数的作用如下：&lt;/p&gt;
&lt;p&gt;       &lt;span&gt;Bytubuf&lt;/span&gt;：需要解码的二进制数据。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;List&amp;lt;Object&amp;gt;&lt;/span&gt;：解码后的有效报文列表，我们需要将解码后的报文添加到这个List中。之所以使用一个List表示，是因为考虑到粘包问题，因此入参的in中可能包含多个有效报文。&lt;/p&gt;
&lt;p&gt;当然，也有可能发生了拆包，in中包含的数据还不足以构成一个有效报文，此时不往List中添加元素即可。&lt;/p&gt;
&lt;p&gt;另外特别要注意的是，在解码时，不能直接调用ByteBuf的readXXX方法来读取数据，而是应该首先要判断能否构成一个有效的报文。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;案例&lt;/span&gt;，假设协议规定传输的数据都是int类型的整数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190109171324389-1477503262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上图中显式输入的ByteBuf中包含4个字节，每个字节的值分别为：1，2，3，4。我们自定义一个ToIntegerDecoder进行解码，尽管这里我看到了4个字节刚好可以构成一个int类&lt;/p&gt;
&lt;p&gt;型整数，但是在真正解码之前，我们并不知道ByteBuf包含的字节数能否构成完成的有效报文，因此需要首先判断ByteBuf中剩余可读的字节，是否大于等于4，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ToIntegerDecoder &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ByteToMessageDecoder {
    @Override
   &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; decode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt; out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (in.readableBytes() &amp;gt;= 4&lt;span&gt;) {
        out.add(in.readInt());
    } }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;只有在可读字节数&amp;gt;=4的情况下，我们才进行解码，即读取一个int，并添加到List中。&lt;/p&gt;
&lt;p&gt;在可读字节数小于4的情况下，我们并没有做任何处理，假设剩余可读字节数为3，不足以构成1个int。那么父类ByteToMessageDecoder发现这次解码List中的元素没有变化，&lt;/p&gt;
&lt;p&gt;则会对in中的剩余3个字节进行缓存，等待下1个字节的到来，之后再回到调用ToIntegerDecoder的decode方法。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外需要注意: &lt;/span&gt;在ToIntegerDecoder的decode方法中，每次最多只读取一个1个int。如果ByteBuf中的字节数很多，例如为16，那么可以构成4个int，而这里只读取了1个int，&lt;/p&gt;
&lt;p&gt;那么剩余12字节怎么办？这个其实不用担心，ByteToMessageDecoder再每次回调子类的decode方法之后，都会判断输入的ByteBuf中是否还有剩余字节可读，如果还有，会再次&lt;/p&gt;
&lt;p&gt;回调子类的decode方法，直到某个回调decode方法List中的元素个数没有变化时才停止，元素个数没有变化，实际上意味着子类已经没有办法从剩余的字节中读取一个有效报文。&lt;/p&gt;
&lt;p&gt;由于存在剩余可读字节时，ByteToMessageDecoder会自动再次回调子类decode方法，因此笔者建议在实现ByteToMessageDecoder时，decode方法每次只解析一个有效报文&lt;/p&gt;
&lt;p&gt;即可，没有必要一次全部解析出来。&lt;/p&gt;
&lt;p&gt;在推荐一个用代码举例: &lt;a href=&quot;https://www.jianshu.com/p/0b79872eb515&quot; target=&quot;_blank&quot;&gt;自定义Decoder继承ByteToMessageDecoder实现解码的小案例&lt;/a&gt;(个人认为非常好）&lt;/p&gt;
&lt;p&gt;ByteToMessageDecoder提供的一些常见的实现类：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;4.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;FixedLengthFrameDecoder&lt;/span&gt;：定长协议解码器，我们可以指定固定的字节数算一个完整的报文&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;LineBasedFrameDecoder&lt;/span&gt;：  行分隔符解码器，遇到\n或者\r\n，则认为是一个完整的报文&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;DelimiterBasedFrameDecoder&lt;/span&gt;：    分隔符解码器，与LineBasedFrameDecoder类似，只不过分隔符可以自己指定&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;LengthFieldBasedFrameDecoder&lt;/span&gt;：长度编码解码器，将报文划分为报文头/报文体，根据报文头中的Length字段确定报文体的长度，因此报文提的长度是可变的&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt;JsonObjectDecoder&lt;/span&gt;：json格式解码器，当检测到匹配数量的&quot;{&quot; 、”}”或”[””]”时，则认为是一个完整的json对象或者json数组。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些实现类，都只是将接收到的二进制数据，解码成包含完整报文信息的ByteBuf实例后，就直接交给了之后的ChannelInboundHandler处理。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;2、ReplayingDecoder 解码器&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;ReplayingDecoder是byte-to-message解码的一种特殊的抽象基类&lt;/span&gt;，byte-to-message解码读取缓冲区的数据之前需要检查缓冲区是否有足够的字节，使用&lt;/p&gt;
&lt;p&gt;ReplayingDecoder就无需自己检查；若&lt;span&gt;ByteBuf中有足够的字节，则会正常读取；若没有足够的字节则会停止解码&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;也正因为这样的包装使得ReplayingDecoder带有一定的&lt;span&gt;局限性&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;         1) 不是所有的操作都被ByteBuf支持，如果调用一个不支持的操作会抛出DecoderException。&lt;/p&gt;
&lt;p&gt;         2)  ByteBuf.readableBytes()大部分时间不会返回期望值&lt;/p&gt;
&lt;p&gt;如果你能忍受上面列出的限制，相比ByteToMessageDecoder，你可能更喜欢ReplayingDecoder。在满足需求的情况下推荐使用ByteToMessageDecoder，因为它的处理比较&lt;/p&gt;
&lt;p&gt;简单，没有ReplayingDecoder实现的那么复杂。ReplayingDecoder继承于ByteToMessageDecoder，所以他们提供的接口是相同的。下面代码是ReplayingDecoder的实现：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * Integer解码器,ReplayingDecoder实现
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ToIntegerReplayingDecoder &lt;span&gt;extends&lt;/span&gt; ReplayingDecoder&amp;lt;Void&amp;gt;&lt;span&gt; {

    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; decode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt; out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        out.add(in.readInt());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;3、MessageToMessageDecoder&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      ByteToMessageDecoder是将二进制流进行解码后，得到有效报文。而&lt;span&gt;MessageToMessageDecoder则是将一个本身就包含完整报文信息的对象转换成另一个Java对象&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;举例&lt;/span&gt;: 前面介绍了ByteToMessageDecoder的部分子类解码后，会直接将包含了报文完整信息的ByteBuf实例交由之后的ChannelInboundHandler处理，此时，你可以在&lt;/p&gt;
&lt;p&gt;ChannelPipeline中，再添加一个MessageToMessageDecoder，将ByteBuf中的信息解析后封装到Java对象中，简化之后的ChannelInboundHandler的操作。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;另外&lt;/span&gt;：一些场景下，有可能你的报文信息已经封装到了Java对象中，但是还要继续转成另外的Java对象，因此一个MessageToMessageDecoder后面可能还跟着另一个&lt;/p&gt;
&lt;p&gt;MessageToMessageDecoder。一个比较容易的理解的类比案例是Java Web编程，通常客户端浏览器发送过来的二进制数据，已经被web容器(如tomcat)解析成了一个&lt;/p&gt;
&lt;p&gt;HttpServletRequest对象，但是我们还是需要将HttpServletRequest中的数据提取出来，封装成我们自己的POJO类，也就是从一个Java对象(HttpServletRequest)转换&lt;/p&gt;
&lt;p&gt;成另一个Java对象(我们的POJO类)。&lt;/p&gt;
&lt;p&gt;MessageToMessageDecoder的类声明如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
  * 其中泛型参数I表示我们要解码的消息类型。例前面，我们在ToIntegerDecoder中，把二进制字节流转换成了一个int类型的整数。
  &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MessageToMessageDecoder&amp;lt;I&amp;gt; &lt;span&gt;extends&lt;/span&gt; ChannelInboundHandlerAdapter
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;类似的，MessageToMessageDecoder也有一个decode方法需要覆盖 ，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
* 参数msg，需要进行解码的参数。例如ByteToMessageDecoder解码后的得到的包含完整报文信息ByteBuf
* List&amp;lt;Object&amp;gt; out参数：将msg经过解析后得到的java对象，添加到放到List&amp;lt;Object&amp;gt; out中
&lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; decode(ChannelHandlerContext ctx, I msg, List&amp;lt;Object&amp;gt; out) &lt;span&gt;throws&lt;/span&gt; Exception;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;例如，现在我们想编写一个IntegerToStringDecoder，把前面编写的ToIntegerDecoder输出的int参数转换成字符串，此时泛型I就应该是Integer类型。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190109172305138-2131937269.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;integerToStringDecoder源码如下所示&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IntegerToStringDecoder &lt;span&gt;extends&lt;/span&gt; MessageToMessageDecoder&amp;lt;Integer&amp;gt;&lt;span&gt; {
    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; decode(ChannelHandlerContext ctx, Integer msg List&amp;lt;Object&amp;gt; out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        out.add(String.valueOf(msg));
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们应该按照如下顺序组织ChannelPipieline中ToIntegerDecoder和IntegerToStringDecoder 的关系：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ChannelPipieline ch=&lt;span&gt;....
    ch.addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; ToIntegerDecoder());
    ch.addLast(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; IntegerToStringDecoder());
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;也就是说，&lt;span&gt;前一个ChannelInboudHandler输出的参数类型，就是后一个ChannelInboudHandler的输入类型&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;特别&lt;span&gt;注意&lt;/span&gt;，如果我们指定MessageToMessageDecoder的泛型参数为ByteBuf，表示其可以直接针对ByteBuf进行解码，那么其是否能替代ByteToMessageDecoder呢？&lt;/p&gt;
&lt;p&gt;答案是不可以的。因为&lt;span&gt;ByteToMessageDecoder除了进行解码，还要会对不足以构成一个完整数据的报文拆包数据(拆包)进行缓存。而MessageToMessageDecoder&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则没有这样的逻辑&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;因此通常的使用建议是，使用一个ByteToMessageDecoder进行粘包、拆包处理，得到完整的有效报文的ByteBuf实例，然后交由之后的一个或者多个&lt;/p&gt;
&lt;p&gt;MessageToMessageDecoder对ByteBuf实例中的数据进行解析，转换成POJO类。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;三 编码器(Encoder)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;与ByteToMessageDecoder和MessageToMessageDecoder相对应，Netty提供了对应的编码器实现&lt;span&gt;MessageToByteEncoder&lt;/span&gt;和&lt;span&gt;MessageToMessageEncoder&lt;/span&gt;，&lt;/p&gt;
&lt;p&gt;二者都实现ChannelOutboundHandler接口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1090617/201901/1090617-20190109172712667-1405746833.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;相对来说，&lt;span&gt;编码器比解码器的实现要更加简单，原因在于解码器除了要按照协议解析数据，还要要处理粘包、拆包问题；而编码器只要将数据转换成协议规定的二进制格式发送即可&lt;/span&gt;。&lt;/p&gt;
&lt;h4&gt;&lt;span&gt;1、抽象类MessageToByteEncoder&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;      MessageToByteEncoder也是一个泛型类，泛型参数I表示将需要编码的对象的类型，编码的结果是将信息转换成二进制流放入ByteBuf中。子类通过覆写其抽象方法encode&lt;/p&gt;
&lt;p&gt;来实现编码，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MessageToByteEncoder&amp;lt;I&amp;gt; &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ChannelOutboundHandlerAdapter {
....
     &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; encode(ChannelHandlerContext ctx, I msg, ByteBuf out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 可以看到，MessageToByteEncoder的输出对象out是一个ByteBuf实例，我们应该将泛型参数msg包含的信息写入到这个out对象中。&lt;/p&gt;
&lt;p&gt;MessageToByteEncoder使用案例：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; IntegerToByteEncoder &lt;span&gt;extends&lt;/span&gt; MessageToByteEncoder&amp;lt;Integer&amp;gt;&lt;span&gt; {
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; encode(ChannelHandlerContext ctx, Integer msg, ByteBuf out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        out.writeInt(msg);&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;将Integer转成二进制字节流写入ByteBuf中&lt;/span&gt;
&lt;span&gt;    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;&lt;span&gt;2、抽象类MessageToMessageEncoder&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;MessageToMessageEncoder同样是一个泛型类，泛型参数I表示将需要编码的对象的类型，编码的结果是将信息放到一个List中。子类通过覆写其抽象方法encode，来实现编码，如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MessageToMessageEncoder&amp;lt;I&amp;gt; &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ChannelOutboundHandlerAdapter {
   ...
   &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; encode(ChannelHandlerContext ctx, I msg, List&amp;lt;Object&amp;gt; out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
   ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;与MessageToByteEncoder不同的，MessageToMessageEncoder编码后的结果放到的out参数类型是一个List中。例如，你一次发送2个报文，因此msg参数中实际上包含了&lt;/p&gt;
&lt;p&gt;2个报文，因此应该解码出两个报文对象放到List中。&lt;/p&gt;
&lt;p&gt;MessageToMessageEncoder提供的常见子类包括：&lt;/p&gt;
&lt;ul class=&quot; list-paddingleft-2&quot; readability=&quot;3&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt; LineEncoder&lt;/span&gt;：按行编码，给定一个CharSequence(如String)，在其之后添加换行符\n或者\r\n，并封装到ByteBuf进行输出，与LineBasedFrameDecoder相对应。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt; Base64Encoder&lt;/span&gt;：给定一个ByteBuf，得到对其包含的二进制数据进行Base64编码后的新的ByteBuf进行输出，与Base64Decoder相对应。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt; LengthFieldPrepender&lt;/span&gt;：给定一个ByteBuf，为其添加报文头Length字段，得到一个新的ByteBuf进行输出。Length字段表示报文长度，与LengthFieldBasedFrameDecoder相对应。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;&lt;span&gt; StringEncoder&lt;/span&gt;：给定一个CharSequence(如：StringBuilder、StringBuffer、String等)，将其转换成ByteBuf进行输出，与StringDecoder对应。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这些MessageToMessageEncoder实现类最终输出的都是ByteBuf，因为最终在网络上传输的都要是二进制数据。&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;四、编码解码器Codec&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;    &lt;span&gt;编码解码器&lt;/span&gt;: 同时具有编码与解码功能，特点&lt;span&gt;同时实现了ChannelInboundHandler和ChannelOutboundHandler接口&lt;/span&gt;，因此在数据输入和输出时都能进行处理。&lt;/p&gt;
&lt;p&gt;Netty提供提供了一个ChannelDuplexHandler适配器类，编码解码器的抽象基类 ByteToMessageCodec 、MessageToMessageCodec都继承与此类，如下：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;ByteToMessageCodec内部维护了一个ByteToMessageDecoder和一个MessageToByteEncoder实例&lt;/span&gt;，可以认为是二者的功集合，泛型参数I是接受的编码类型：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ByteToMessageCodec&amp;lt;I&amp;gt; &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ChannelDuplexHandler {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; TypeParameterMatcher outboundMsgMatcher;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; MessageToByteEncoder&amp;lt;I&amp;gt;&lt;span&gt; encoder;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; ByteToMessageDecoder decoder = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ByteToMessageDecoder(){…}
  
    ...
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; encode(ChannelHandlerContext ctx, I msg, ByteBuf out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; decode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt; out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;MessageToMessageCodec内部维护了一个MessageToMessageDecoder和一个MessageToMessageEncoder实例，可以认为是二者的功集合，泛型参数&lt;/p&gt;
&lt;p&gt;&lt;span&gt;INBOUND_IN&lt;/span&gt;和&lt;span&gt;OUTBOUND_IN&lt;/span&gt;分别表示需要解码和编码的数据类型。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; MessageToMessageCodec&amp;lt;INBOUND_IN, OUTBOUND_IN&amp;gt; &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ChannelDuplexHandler {
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; MessageToMessageEncoder&amp;lt;Object&amp;gt; encoder=&lt;span&gt; ...
   &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; MessageToMessageDecoder&amp;lt;Object&amp;gt; decoder =&lt;span&gt;…
   ...
   &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; encode(ChannelHandlerContext ctx, OUTBOUND_IN msg, List&amp;lt;Object&amp;gt; out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
   &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;abstract&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; decode(ChannelHandlerContext ctx, INBOUND_IN msg, List&amp;lt;Object&amp;gt; out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;其他编解码方式&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;        使用编解码器来充当编码器和解码器的组合失去了单独使用编码器或解码器的灵活性，编解码器是要么都有要么都没有。你可能想知道是否有解决这个僵化问题&lt;/p&gt;
&lt;p&gt;的方式，还可以让编码器和解码器在ChannelPipeline中作为一个逻辑单元。幸运的是，Netty提供了一种解决方案，使用&lt;span&gt;CombinedChannelDuplexHandler&lt;/span&gt;。虽然这个&lt;/p&gt;
&lt;p&gt;类不是编解码器API的一部分，但是它经常被用来简历一个编解码器。&lt;/p&gt;
&lt;p&gt;     如何使用CombinedChannelDuplexHandler来结合解码器和编码器呢？下面我们从两个简单的例子看了解。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 解码器，将byte转成char
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ByteToCharDecoder &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; ByteToMessageDecoder {
 
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; decode(ChannelHandlerContext ctx, ByteBuf in, List&amp;lt;Object&amp;gt; out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        &lt;/span&gt;&lt;span&gt;while&lt;/span&gt;(in.readableBytes() &amp;gt;= 2&lt;span&gt;){
            out.add(Character.valueOf(in.readChar()));
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 编码器，将char转成byte
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CharToByteEncoder &lt;span&gt;extends&lt;/span&gt; MessageToByteEncoder&amp;lt;Character&amp;gt;&lt;span&gt; {
 
    @Override
    &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; encode(ChannelHandlerContext ctx, Character msg, ByteBuf out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
        out.writeChar(msg);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/**&lt;/span&gt;&lt;span&gt;
 * 继承CombinedChannelDuplexHandler，用于绑定解码器和编码器
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; CharCodec &lt;span&gt;extends&lt;/span&gt; CombinedChannelDuplexHandler&amp;lt;ByteToCharDecoder, CharToByteEncoder&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; CharCodec(){
        &lt;/span&gt;&lt;span&gt;super&lt;/span&gt;(&lt;span&gt;new&lt;/span&gt; ByteToCharDecoder(), &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CharToByteEncoder());
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从上面代码可以看出，使用CombinedChannelDuplexHandler绑定解码器和编码器很容易实现，比使用*Codec更灵活。&lt;/p&gt;


&lt;p&gt;&lt;span&gt;如果一个人充满快乐，正面的思想，那么好的人事物就会和他共鸣，而且被他吸引过来。同样，一个人老带悲伤，倒霉的事情也会跟过来。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;                                                                                    ——在自己心情低落的时候，告诫自己不要把负能量带给别人。（大校19） &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 09 Jan 2019 13:59:00 +0000</pubDate>
<dc:creator>雨点的名字</dc:creator>
<og:description>Netty编解码器 在了解Netty编解码之前,先了解Java的编解码: 编码（Encode）称为序列化， 它将对象序列化为字节数组，用于网络传输、数据持久化或者其它用途。 解码（Decode）称为反</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qdhxhz/p/10245936.html</dc:identifier>
</item>
</channel>
</rss>