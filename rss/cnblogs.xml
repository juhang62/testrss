<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>举例理解JDK动态代理 - Kobelieve</title>
<link>http://www.cnblogs.com/kobelieve/p/10441011.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kobelieve/p/10441011.html</guid>
<description>&lt;p&gt;说到java自带的动态代理api，肯定离不开反射。JDK的Proxy类实现动态代理最核心的方法：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public static Object newProxyInstance(ClassLoader loader,
                                          Class&amp;lt;?&amp;gt;[] interfaces,
                                          InvocationHandler h)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个方法的作用：在运行时，动态创建一组指定接口的实现类对象。其中的三大参数：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;
&lt;p&gt;ClassLoader loader&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;类加载器，主要作用是用来加载类的，把.class文件加载到jvm的方法区中，形成class对象&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Class&amp;lt;?&amp;gt;[] interfaces&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;实现的接口列表&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InvocationHandler h&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;InvocationHandler 是一个接口，里面有且只有一个方法invoke(Object proxy, Method method, Object[] args)，后面会介绍。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们可以先看个简单的例子：&lt;/p&gt;
&lt;pre class=&quot;java&quot;&gt;
&lt;code&gt;public class DynamicProxyDemo {

    @Test
    public void test1() {

        ClassLoader loader = this.getClass().getClassLoader();
        Class[] classes = {Human.class, Car.class};
        InvocationHandler h = new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                System.out.println(&quot;来了，老弟~&quot;);
                return null;
            }
        };

        Human human = (Human) Proxy.newProxyInstance(loader, classes, h);
        human.male();
        human.toString();
        human.getClass();
    }

}

interface Human {
    Object male();
}

interface Car {
    Object bmw();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;​ 输出：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;来了，老弟~
来了，老弟~&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到，代码并没有报错，因为Proxy.newProxyInstance(loader, classes, h)返回的对象是实现了指定接口的类对象，所以强转成Human没有问题，当调用Human对象的方法时，会执行InvocationHandler里的invoke方法的语句。但是我当我调用getClass()方法时，并没有执行对应的语句，这是由于此方法是native方法，是调用本地的方法。&lt;/p&gt;
&lt;p&gt;既然调用代理对象的所有方法（个别除外）都会调用某个方法(invoke())，我们可以在里面进行任意操作，达到前置或者后置增强的效果。&lt;/p&gt;
&lt;p&gt;未完待续。&lt;/p&gt;
</description>
<pubDate>Tue, 26 Feb 2019 15:43:00 +0000</pubDate>
<dc:creator>Kobelieve</dc:creator>
<og:description>JDK动态代理 说到java自带的动态代理api，肯定离不开反射。JDK的Proxy类实现动态代理最核心的方法： 这个方法的作用：在运行时，动态创建一组指定接口的实现类对象。其中的三大参数： Clas</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kobelieve/p/10441011.html</dc:identifier>
</item>
<item>
<title>论Scrapy中的数据持久化 - 温而新</title>
<link>http://www.cnblogs.com/peng104/p/10440928.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/peng104/p/10440928.html</guid>
<description>&lt;p&gt;Scrapy的数据持久化，主要包括存储到数据库、文件以及内置数据存储。&lt;/p&gt;
&lt;p&gt;那我们今天就来讲讲如何把Scrapy中的数据存储到数据库和文件当中。&lt;/p&gt;


&lt;p&gt;保证爬虫文件的parse方法中有可迭代类型对象（通常为列表or字典）的返回，该返回值可以通过终端指令的形式写入指定格式的文件中进行持久化操作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行输出指定格式进行存储：将爬取到的数据写入不同格式的文件中进行存储&lt;/span&gt;
    scrapy crawl 爬虫名称 -o xxx.json  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存为json文件&lt;/span&gt;
    scrapy crawl 爬虫名称 -o xxx.xml   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存为xml文件&lt;/span&gt;
    scrapy crawl 爬虫名称 -o xxx.csv   &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存为csv文件&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;scrapy框架中已经为我们专门集成好了高效、便捷的持久化操作功能，我们直接使用即可。要想使用scrapy的持久化操作功能，我们首先来认识如下两个文件：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#  &lt;/span&gt;&lt;span&gt;items.py：数据结构模板文件。定义数据属性。&lt;/span&gt;

&lt;span&gt;#  &lt;/span&gt;&lt;span&gt;pipelines.py：管道文件。接收数据（items），进行持久化操作。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;持久化流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol readability=&quot;-1.5&quot;&gt;&lt;li&gt;爬虫文件爬取到数据后，需要将数据封装到&lt;strong&gt;items&lt;/strong&gt;对象中。&lt;/li&gt;
&lt;li&gt;使用yield关键字将&lt;strong&gt;items&lt;/strong&gt;对象提交给&lt;strong&gt;pipelines&lt;/strong&gt;管道进行持久化操作。&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;在管道文件中的&lt;strong&gt;process_item&lt;/strong&gt;方法中接收爬虫文件提交过来的&lt;strong&gt;item&lt;/strong&gt;对象，然后编写持久化存储的代码将&lt;strong&gt;item&lt;/strong&gt;对象中存储的数据进行持久化存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;settings.py 配置文件中开启管道&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;举个栗子&lt;/h2&gt;
&lt;p&gt;将糗事百科首页中的段子和作者数据爬取下来，然后进行持久化存储&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- qiubaiDemo.py&lt;/strong&gt;（爬虫文件）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; secondblood.items &lt;span&gt;import&lt;/span&gt;&lt;span&gt; SecondbloodItem

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; QiubaidemoSpider(scrapy.Spider):
    name &lt;/span&gt;= &lt;span&gt;'&lt;/span&gt;&lt;span&gt;qiubaiDemo&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
    allowed_domains &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;www.qiushibaike.com&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    start_urls &lt;/span&gt;= [&lt;span&gt;'&lt;/span&gt;&lt;span&gt;http://www.qiushibaike.com/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; parse(self, response):
        odiv &lt;/span&gt;= response.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;//div[@id=&quot;content-left&quot;]/div&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; div &lt;span&gt;in&lt;/span&gt;&lt;span&gt; odiv:
            &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; xpath函数返回的为列表，列表中存放的数据为Selector类型的数据。我们解析到的内容被封装在了Selector对象中，需要调用extract()函数将解析的内容从Selecor中取出。&lt;/span&gt;
            author = div.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//div[@class=&quot;author clearfix&quot;]//h2/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract_first()
            author &lt;/span&gt;= author.strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;过滤空行&lt;/span&gt;
            content = div.xpath(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;.//div[@class=&quot;content&quot;]/span/text()&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;).extract_first()
            content &lt;/span&gt;= content.strip(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;过滤空行&lt;/span&gt;

            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将解析到的数据封装至items对象中&lt;/span&gt;
            item =&lt;span&gt; SecondbloodItem()
            item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; author
            item[&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] =&lt;span&gt; content

            &lt;/span&gt;&lt;span&gt;yield&lt;/span&gt; item  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 提交item到管道文件（pipelines.py）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;- items.py&lt;/strong&gt;（items文件）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; scrapy


&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SecondbloodItem(scrapy.Item):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; define the fields for your item here like:&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; name = scrapy.Field()&lt;/span&gt;
    author = scrapy.Field()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储作者&lt;/span&gt;
    content = scrapy.Field()  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 存储段子内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;- pipelines.py&lt;/strong&gt;（管道文件）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; SecondbloodPipeline(object):
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 构造方法&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        self.fp &lt;/span&gt;= None  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 定义一个文件描述符属性&lt;/span&gt;
&lt;span&gt;    #&lt;/span&gt;&lt;span&gt; 下列都是在重写父类的方法：&lt;/span&gt;
    &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开始爬虫时，执行一次&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; open_spider(self,spider):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;爬虫开始&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.fp &lt;/span&gt;= open(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;./data.txt&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;w&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)

　　 &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 因为该方法会被执行调用多次，所以文件的开启和关闭操作写在了另外两个只会各自执行一次的方法中。&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 将爬虫程序提交的item进行持久化存储&lt;/span&gt;
        self.fp.write(item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;:&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; + item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;] + &lt;span&gt;'&lt;/span&gt;&lt;span&gt;\n&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; item

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 结束爬虫时，执行一次&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; close_spider(self,spider):
        self.fp.close()
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;爬虫结束&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;- settings.py&lt;/strong&gt;（配置文件）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 开启管道&lt;/span&gt;
ITEM_PIPELINES =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;secondblood.pipelines.SecondbloodPipeline&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 300, &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 300表示为优先级，值越小优先级越高&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在管道文件里将item对象中的数据值存储到了磁盘中，如果将item数据写入mysql数据库的话，只需要将上述案例中的管道文件修改成如下形式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- pipelines.py&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 导入数据库的类&lt;/span&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; pymysql
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; QiubaiproPipelineByMysql(object):

    conn &lt;/span&gt;= None  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; mysql的连接对象声明&lt;/span&gt;
    cursor = None  &lt;span&gt;#&lt;/span&gt;&lt;span&gt; mysql游标对象声明&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; open_spider(self,spider):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;开始爬虫&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 链接数据库&lt;/span&gt;
        self.conn = pymysql.Connect(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,port=3306,user=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;root&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,password=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,db=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;qiubai&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 编写向数据库中存储数据的相关代码&lt;/span&gt;
    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 1.链接数据库&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; 2.执行sql语句&lt;/span&gt;
        sql = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;insert into qiubai values(&quot;%s&quot;,&quot;%s&quot;)&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%(item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;],item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;])
        self.cursor &lt;/span&gt;=&lt;span&gt; self.conn.cursor()
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 执行事务&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt;:
            self.cursor.execute(sql)
            self.conn.commit()
        &lt;/span&gt;&lt;span&gt;except&lt;/span&gt;&lt;span&gt; Exception as e:
            &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;&lt;span&gt;(e)
            self.conn.rollback()

        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; item
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; close_spider(self,spider):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;爬虫结束&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        self.cursor.close()
        self.conn.close()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;- settings.py&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ITEM_PIPELINES =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;qiubaiPro.pipelines.QiubaiproPipelineByMysql&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 300&lt;span&gt;,
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;基于redis的管道存储&lt;/h2&gt;
&lt;p&gt;在管道文件里将item对象中的数据值存储到了磁盘中，如果将item数据写入redis数据库的话，只需要将上述案例中的管道文件修改成如下形式：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;- pipelines.py&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; redis

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; QiubaiproPipelineByRedis(object):
    conn &lt;/span&gt;=&lt;span&gt; None
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; open_spider(self,spider):
        &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;开始爬虫&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 创建链接对象&lt;/span&gt;
        self.conn = redis.Redis(host=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;127.0.0.1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;,port=6379&lt;span&gt;)
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
        dict &lt;/span&gt;=&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;author&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;],
            &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;:item[&lt;span&gt;'&lt;/span&gt;&lt;span&gt;content&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
        }
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 写入redis中&lt;/span&gt;
        self.conn.lpush(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;data&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;, dict)
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; item
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;- settings.py&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
ITEM_PIPELINES =&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;qiubaiPro.pipelines.QiubaiproPipelineByRedis&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 300&lt;span&gt;,
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;抛出需求&lt;/h3&gt;
&lt;p&gt;如果最终需要将爬取到的数据值一份存储到磁盘文件，一份存储到数据库中，则应该如何操作scrapy？&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('716b01c3-0708-44f1-ad02-6855a81182c9')&quot; readability=&quot;34.5&quot;&gt;&lt;img id=&quot;code_img_closed_716b01c3-0708-44f1-ad02-6855a81182c9&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_716b01c3-0708-44f1-ad02-6855a81182c9&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('716b01c3-0708-44f1-ad02-6855a81182c9',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_716b01c3-0708-44f1-ad02-6855a81182c9&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;64&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 该类为管道类，该类中的process_item方法是用来实现持久化存储操作的。&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DoublekillPipeline(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;持久化操作代码 （方式1：写入磁盘文件）&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; item

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;如果想实现另一种形式的持久化操作，则可以再定制一个管道类：&lt;/span&gt;
&lt;span&gt;class&lt;/span&gt;&lt;span&gt; DoublekillPipeline_db(object):

    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt;&lt;span&gt; process_item(self, item, spider):
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 持久化操作代码 （方式1：写入数据库）&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt; item
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;pipelines.py&lt;/span&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('ff714a70-e92f-4e1a-bf68-dc562e402155')&quot; readability=&quot;33.5&quot;&gt;&lt;img id=&quot;code_img_closed_ff714a70-e92f-4e1a-bf68-dc562e402155&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_ff714a70-e92f-4e1a-bf68-dc562e402155&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('ff714a70-e92f-4e1a-bf68-dc562e402155',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_ff714a70-e92f-4e1a-bf68-dc562e402155&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;62&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下列结构为字典，字典中的键值表示的是即将被启用执行的管道文件和其执行的优先级。&lt;/span&gt;
ITEM_PIPELINES =&lt;span&gt; {
   &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;doublekill.pipelines.DoublekillPipeline&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 300&lt;span&gt;,
    &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;doublekill.pipelines.DoublekillPipeline_db&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;: 200&lt;span&gt;,
}

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 上述代码中，字典中的两组键值分别表示会执行管道文件中对应的两个管道类中的process_item方法，实现两种不同形式的持久化操作。&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;settings.py&lt;/span&gt;&lt;/div&gt;

</description>
<pubDate>Tue, 26 Feb 2019 15:20:00 +0000</pubDate>
<dc:creator>温而新</dc:creator>
<og:description>引入 Scrapy的数据持久化，主要包括存储到数据库、文件以及内置数据存储。 那我们今天就来讲讲如何把Scrapy中的数据存储到数据库和文件当中。 终端指令存储 保证爬虫文件的parse方法中有可迭代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/peng104/p/10440928.html</dc:identifier>
</item>
<item>
<title>Asp.Net Core中HttpClient的使用方式 - 微笑刺客D</title>
<link>http://www.cnblogs.com/CKExp/p/10426170.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CKExp/p/10426170.html</guid>
<description>&lt;p&gt;&lt;strong&gt;　　在.Net Core应用开发中，调用第三方接口也是常有的事情，HttpClient使用人数、使用频率算是最高的一种了，在.Net Core中，HttpClient的使用方式随着版本的升级也发生了一些变化，本次就讲解一下Asp.Net Core2.1前后使用的两种方式。&lt;/strong&gt;&lt;/p&gt;

&lt;h3&gt;&lt;span&gt;&lt;strong&gt;一、原先HttpClient使用方式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 　　一般来讲，喜欢要用的时候才会选择去获取资源，因此，当在有需求时才会用HttpClient去调用资源，便会使用如下这种方式或其它方式获取资源。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something...&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; httpClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient())
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; requestUri = &lt;span&gt;&quot;http://aspnetcore.online/api/resource/getresource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpResponseMessage = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; httpClient.GetAsync(requestUri);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something...&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(httpResponseMessage);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果可以正常访问目标地址的话，则会返回相应的资源信息。　　&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190226195417684-2118419899.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　又如Post方式提交并返回相应的内容，都是可以直接使用。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something...&lt;/span&gt;
&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; httpClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient())
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; requestUri = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://aspnetcore.online/api/resource/postresource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; httpResponseMessage = &lt;span&gt;await&lt;/span&gt; httpClient.PostAsJsonAsync(requestUri,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;星城软件&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something...&lt;/span&gt;

    &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(httpResponseMessage);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　但是这种情况下会出现一个严重的问题，在不停的调用情形下，tcp连接数会被耗尽，虽然使用using方式调用HttpClient并在退出前调用Dispose()方法将HttpClient释放了，但是tcp连接仍然处于保持状态，在240s后才会自动断开，这里就涉及到一个连接状态了，首先得理解下http的工作原理，http协议是建立在tcp协议基础之上，当浏览器需要从服务器获取数据的时候，会发出一次http请求。http会通过tcp建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，http会立即将tcp连接断开，这个过程是很短的。所以http连接是一种短连接，是一种无状态的连接。但是tcp的连接只要我们不通过代码把连接关闭，这个连接就会在客户端和服务端的进程中一直存在，相关状态数据会一直保存着，直到无响应状态持续了默认关闭时间后自动断开。&lt;/p&gt;
&lt;p&gt; 　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190226220159423-1246659262.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　当短期请求量过大时，这就可能导致了&quot;套接字资源耗尽异常&quot;，因此，为了解决这个问题，想到不释放HttpClient，将它作为单例一直使用，实现单例方式有很多种。&lt;/p&gt;
&lt;p&gt;　　如使用单例模式，只生成一个HttpClient&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; HttpClient _httpClient = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpClient CreateHttpClient()
{
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (_httpClient == &lt;span&gt;null&lt;/span&gt;) _httpClient = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _httpClient;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　亦或是在初始化时完成单例注入，创建一个IHttpClient接口，及相应的实现StandardHttpClient，实现类种加入HttpClient属性，在实现类构造函数中完成初始化后便可直接使用该实现类完成资源请求工作。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在startup中完成单例注入&lt;/span&gt;
services.AddSingleton&amp;lt;IHttpClient, StandardHttpClient&amp;gt;&lt;span&gt;();

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHttpClient
{
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something&lt;/span&gt;
&lt;span&gt;}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; StandardHttpClient : IHttpClient
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; HttpClient _client;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; StandardHttpClient()
    {
        _client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();
    }

    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;do something...&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; &lt;span&gt;&lt;strong&gt;　　&lt;/strong&gt;虽然这样解决了&quot;套接字资源耗尽异常&quot;，但是又带来了新的问题，熬不过DNS生存时间（TTL），&lt;/span&gt;当主机 DNS 更新时，又可能产生异常，提示无法解析主机名称，因为单例HttpClient不会随着主机DNS更新而更新，&lt;a href=&quot;https://github.com/dotnet/corefx/issues/11224&quot; target=&quot;_blank&quot;&gt;Singleton HttpClient doesn't respect DNS changes&lt;/a&gt;。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
An error occurred &lt;span&gt;while&lt;/span&gt; sending the request. Couldn&lt;span&gt;'&lt;/span&gt;&lt;span&gt;t resolve host name An error occurred while sending the request. Couldn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;t resolve host name
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;span&gt; &lt;/span&gt;&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;&lt;span&gt;&lt;strong&gt;二、现有HttpClient使用方式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt; 　　在.Net Core2.1后，微软引入了&lt;a href=&quot;https://github.com/aspnet/HttpClientFactory&quot; target=&quot;_blank&quot;&gt;HttpClientFactory&lt;/a&gt;彻底解决这个问题，工厂模式的职责是负责创建对象，这个类主要负责创建HttpClient实例&lt;/p&gt;
&lt;p&gt;　　首先在StartUp中注册，可能会提示安装这个Nuget包&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 services.AddHttpClient();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;　　&lt;/em&gt;该方法内部实现过程可以浏览：&lt;a href=&quot;https://www.cnblogs.com/lizhizhang/p/9502862.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/lizhizhang/p/9502862.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;　　其次，在需要使用时，使用构造函数注入即可&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
[ApiController]
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HttpClientController : ControllerBase
{
    IHttpClientFactory _httpClientFactory;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HttpClientController(IHttpClientFactory httpClientFactory)
    {
        _httpClientFactory &lt;/span&gt;=&lt;span&gt; httpClientFactory;
    }

    [HttpGet]
    [Route(nameof(Index))]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt;&lt;span&gt; Index()
    {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; client =&lt;span&gt; _httpClientFactory.CreateClient();
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; result = &lt;span&gt;await&lt;/span&gt; client.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://aspnetcore.online/api/resource/getresource&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok(result);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　具体实现原理简述为：HttpClientFactory内部管理着一个连接句柄池，对每一个HttpClient使用一个句柄进行跟踪管理，当该实例使用完毕后，句柄仍然控制资源释放，在短期大量处理时，可以将这部分句柄完成对不同实例的跟踪管理，使得句柄，也就是相应的套接字生命周期延长，对套接字完成了复用。&lt;/p&gt;

&lt;p&gt;　近日，长沙.NET技术社区已经建立，微信群：长沙.NET社区一群已满，如有需要来长沙发展或是回归长沙可以进入二群，加一下我来邀请进去。各大城市间的人才拉锯战进行中，不管是什么行业，什么职业，长沙都应&lt;strong&gt;留住人才，培养人才&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1133736/201902/1133736-20190226225124875-649517983.png&quot; alt=&quot;&quot; width=&quot;149&quot; height=&quot;149&quot;/&gt;&lt;/p&gt;
&lt;pre class=&quot;lang-java prettyprint prettyprinted&quot;&gt;
&lt;code class=&quot;hljs&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;str&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;typ&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;pun&quot;&gt;&lt;span class=&quot;pln&quot;&gt;&lt;span class=&quot;lit&quot;&gt;&lt;strong&gt;&lt;span class=&quot;hljs-number&quot;&gt;2019-02&lt;span class=&quot;hljs-number&quot;&gt;-&lt;span class=&quot;hljs-number&quot;&gt;26,望技术有成后能回来看见自己的脚步&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 26 Feb 2019 15:00:00 +0000</pubDate>
<dc:creator>微笑刺客D</dc:creator>
<og:description>在.Net Core应用开发中，调用第三方接口也是常有的事情，HttpClient使用人数、使用频率算是最高的一种了，在.Net Core中，HttpClient的使用方式随着版本的升级也发生了一些变</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/CKExp/p/10426170.html</dc:identifier>
</item>
<item>
<title>2018总结，今年的自己有些丧 - 小浩学长</title>
<link>http://www.cnblogs.com/xiaohaoxuezhang/p/10440566.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiaohaoxuezhang/p/10440566.html</guid>
<description>&lt;p&gt;今年8102，从年初写完去年的总结开始，回忆起这整整一年时间，得到的只有颓废、没干劲、玩物丧志这些负面的词汇，再次阅读去年的总结，不禁面红耳赤起来。&lt;br/&gt;　　本来这篇文章几天前就已经想写了，自己内心想要逃避。这段时间病了很久，躺在床上思考自己，今天大病初愈，站在镜子前，看了自己很久，感觉去年那个自己又回来了，遂提笔记录下这痛苦的一年时间。&lt;/p&gt;
&lt;p&gt;(1) 1-5月：颓废的时光&lt;/p&gt;
&lt;p&gt;　　年初一直坚持运动和学英语的自己，因为运动过多，导致脚上破皮感染，整个脚走不了路，没想到自己会被这种事情击败，但不得不说，这是我今年一个重大转折点。 &lt;br/&gt;　　当我停止运动开始，我整个精神状态、生物钟以及我的激情都在消失殆尽，到过年回家的时候一下子就把以前积累的所有正面情绪都消耗完了。转而开始过上颓废、安逸、舒适的生活，这时候的我也已经不再是我自己了。&lt;br/&gt;　　在过完年准备返回四川工作那天，开始玩上了一直不敢碰的wow，我是wow的骨灰级玩家，但从高中开始把学习当做第一位的时候，我就已经不敢再去碰wow，wow无疑是我感觉最好玩的游戏。我沉迷其中，每天醒来就想去网吧，玩到凌晨半夜回家，看着镜子里的自己，内心很小的呼声叫我停止这一切，但这声音很快又被wow的欲望覆盖。&lt;br/&gt;　　到五月份，我整整打了两个半月的wow，有一天Jack突然找到我，让我把wow号删了，我在多次尝试以后终于还是把它删了。我记得第二天起床，回忆起这两个月的时间，感觉无比轻松，就像自己从来没有沉迷在wow的时间里一样。&lt;/p&gt;

&lt;p&gt;(2) 6-8月：短暂的激情&lt;/p&gt;
&lt;p&gt;　　这两个月的时间是今年最有激情，也是编程效率最高的时候。Jack和我去了九寨沟闭关开发，脱离了外部环境的干扰，我整个人都沉浸在编程和学习的愉悦中。&lt;br/&gt;　　但欢乐时光却总是那么短暂，八月中旬，我们回到成都，当时成都温度很高，我感觉已经不适合人类居住了，每天如果不开空调无法入睡，在哪都是汗流浃背。我那时候胃不好，开空调肚子疼，晚上只能靠着风扇睡觉，然后开始噩梦般的生活，那时候整晚整晚的失眠，每天犹豫行尸走肉一般。&lt;br/&gt;　　从那时候开始，我和Jack开始互相积累对彼此的不满，我抱怨他提前闭关回成都，让我经历如此痛苦的折磨，那时候我是对他很生气的。然后我开始故意消极怠工，竟然发起了小孩子脾气，足见现在的我也依然会存在如此幼稚的思想，不够成熟，不够担当，这些问题也逐渐浮出水面。&lt;br/&gt;　　而Jack则感受到了我的不爽，他应该也开始积累了对我的不满，后面双方的抱怨足够多就爆发出来了。&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;(3) 9-12月：矛盾的激化&lt;/p&gt;
&lt;p&gt;　　鲁迅说，不在沉默中爆发，就在沉默中消亡。&lt;br/&gt;　　我们两个的矛盾终于还是爆发了出来，Jack开始质问我工作量不足，每天玩物丧志，而我那时候确实已经提不起精神做事了。那时候谈恋爱、打麻将、打游戏占了我一半时间，另外一半时间则是吃老本编程，代码没有重构、没有设计，学习一些新技术开发了公司官网，搭建了论坛和API文档，于我来说技术没有太大提升。&lt;br/&gt;　　后面Jack劝我出去上班，调整一下状态，刚开始我自然是不愿意，不过我想了很多晚上，我觉得这也许是个很不错的意见，于是我和Jack开诚布公，把我们所有这一年经历的事情以及对彼此的想法都谈了一下，说完之后轻松了很多。　　&lt;/p&gt;
&lt;p&gt;　　 足见沟通以及复盘在合作中多么重要。&lt;/p&gt;

&lt;p&gt;(4) 总结&lt;/p&gt;
&lt;p&gt;　　Jack常说，我们现在所暴露出来的问题，是好事，我们应该感激它，这样我们才能更加深刻的了解自己，并完善自己。&lt;br/&gt;　　今年所经历的所有困难，我记录于此，作为人生中最迷茫、最痛苦的一年，它对我来说意义很大，明年我将披荆斩月，克服自己的心理障碍，把今年落下的减肥和英语两项人生重大项目跟进。&lt;br/&gt;　　明年的自己会感激你，那个颓废的自己。&lt;/p&gt;
</description>
<pubDate>Tue, 26 Feb 2019 14:12:00 +0000</pubDate>
<dc:creator>小浩学长</dc:creator>
<og:description>今年8102，从年初写完去年的总结开始，回忆起这整整一年时间，得到的只有颓废、没干劲、玩物丧志这些负面的词汇，再次阅读去年的总结，不禁面红耳赤起来。 本来这篇文章几天前就已经想写了，自己内心想要逃避。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiaohaoxuezhang/p/10440566.html</dc:identifier>
</item>
<item>
<title>在BOSS直聘上和面试官的一问一答 - 夏天里的Jasmine</title>
<link>http://www.cnblogs.com/qianjinyan/p/10440326.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/qianjinyan/p/10440326.html</guid>
<description>&lt;p&gt;&lt;span&gt;&lt;strong&gt;岗位描述：&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;信用卡核心系统功能测试，负责测试计划制定，测试设计，测试执行，测试进度掌控，自动化工具建设等工作。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有责任心，执行力强，工作认真细致，逻辑思维强&lt;/span&gt;&lt;br/&gt;&lt;span&gt;熟悉linux，oracle或者IBM大型机操作&lt;/span&gt;&lt;br/&gt;&lt;span&gt;精通功能测试技术，有5年以上相关经验&lt;/span&gt;&lt;br/&gt;&lt;span&gt;掌握后端系统性能测试或自动化测试技术&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有分布式架构测试经验，大型系统迁移项目经验，或者熟悉信用卡业务&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;手抖点了下申请岗位，面试官，这个项目里的测试经理在BOSS直聘上直接发问了：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1. 做过测试环境监控吗？比如常驻进程，日志等？有没有用过什么监控工具？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;常见命令行工具&lt;/span&gt;&lt;br/&gt;&lt;span&gt;top&lt;/span&gt;&lt;br/&gt;&lt;span&gt;vmstat 是用来实时查看内存使用情况,反映的情况比用top直观一些&lt;/span&gt;&lt;br/&gt;&lt;span&gt;vmstat 2&lt;/span&gt;&lt;br/&gt;&lt;span&gt;free&lt;/span&gt;&lt;br/&gt;&lt;span&gt;下面是对内存查看free命令输出内容的解释：&lt;/span&gt;&lt;br/&gt;&lt;span&gt;total：总计物理内存的大小。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;used：已使用多大。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;free：可用有多少。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Shared：多个进程共享的内存总额。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Buffers/cached：磁盘缓存的大小。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190226213019017-867412938.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190226213033465-1280965238.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190226213047733-554218223.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;2. 是手工部署还是自动化部署？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;第一次搭环境都是手工，诸如配置tomcat，jboss，nginx，memcached，后期提交代码了，Jenkins自动部署&lt;/span&gt;&lt;br/&gt;&lt;span&gt;自动化部署脚本谁建的？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我啊， 就一个build文件啊&lt;/span&gt;&lt;br/&gt;&lt;span&gt;中间件只用过tomcat还有别的吗？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;tomcat和Jboss&lt;/span&gt;&lt;br/&gt;&lt;span&gt;Weblogic和websphere用过么？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;没有用过，但我学起来很快&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.接口自动化做的都是http的么？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;大部分是，有一些是soap协议的，也是用jmeter开发的自动化脚本&lt;/span&gt;&lt;br/&gt;&lt;span&gt;都是用jmeter做的自动化和性能测试吗？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;对的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4.场景过程中有涉及字符转码的场景么？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;字符串做md5加密算不算？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;算的，请求和应答都加密解密是么？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;请求中一般有字段需要做md5加密，应答中的解密一般没有，md5解密一般都不成功啊&lt;/span&gt;&lt;br/&gt;&lt;span&gt;URL解码还可能些，但目前公司几乎用不到&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5.那Jmeter里你用什么方法实现这些处理？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;比如MD5加密需求是32位大写加密，Jmeter可以连接数据库，每一个http请求添加一个预置数据处理，编写了一个存储过程，调用该proc可以算出md5加密的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我也编写了一个md5加密的java方法导出成jar，可以添加到Jmeter中的beanshell中计算md5的值&lt;/span&gt;&lt;br/&gt;&lt;span&gt;不过常用第一种，自动化总是要处理数据的，连DB最方便&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6.那对应答的预处理和断言是怎么做的？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;断言是根据需求文档，写死了的；比如场景规定返回000，E01等等；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;如果要处理应答呢？比如场景，响应报文以ebcdic编码，变长报文根据前16个字节决定断言字段的位置，断言预期结果是utf8编码&lt;/span&gt;&lt;br/&gt;&lt;span&gt;用正则表达式提取出需要转码的字段，再用后置处理器或者beanshell对值转码后，之后进行判断&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7. 对登录态和session的处理有怎样的经验？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;cookie是在本地的&lt;/span&gt;&lt;br/&gt;&lt;span&gt;session保存在服务器上，服务器关了你登陆就断了；或者时间久了session会过期；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;现在有的前后端分离系统，喜欢用token验证登录态。将token作为header或者请求体，去调用接口。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;登录之后有些系统要求必须带有token才能访问，session什么的建立连接之后获得sessionID塞入request head中&lt;/span&gt;&lt;br/&gt;&lt;span&gt;token怎么获取？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;也是正则表达式提取&lt;/span&gt;&lt;br/&gt;&lt;span&gt;用两个交易串行获取么？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;http请求后，请求中会有token：xxx aaa。正则表达式直接获取token：（.+）aaa&lt;/span&gt;&lt;br/&gt;&lt;span&gt;带着token去请求？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;带着token去请求，还需要再获取token吗？为什么要获取，是要刷新token吗？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;8. 集群服务器在垂直分片的数据库用多线程做批量数据DML要关注什么？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;这个不会。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1064427/201902/1064427-20190226213101763-1168178182.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;br/&gt;&lt;span&gt;&lt;strong&gt;9. Oracle的adg备份技术了解么？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;会应用在读写分离上&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;10. 读写分离和缓存数据存取的测试有经验吗？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;缓存数据存取，接触过memcache数据库&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有什么关注点？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当时主要是测试双机场景，两台机器同时在工作，不是主备模式。测试之后发现高并发的时候，客户端给到一个请求，服务器端可能响应两次；如若是多台服务器，有可能一个请求，服务器多次响应。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;还有什么吗，比如数据一致性？&lt;/span&gt;&lt;br/&gt;&lt;span&gt;一致性方式测试发现是满足的。一般查看下稳定向，容错性，一致性。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;11. 你刚说的双机测试，用的是什么负载均衡策略？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;当时只关注了ip用的是nonsticky模式，负载均衡策略可能是轮询法吧。当时是it搭的环境。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;大概是nginx通过设置weight轮询权值吧。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;12. 灾备的测试有经验么？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;很少涉及，压力测试下会遇到响应延迟场景。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;还有双机热备，人为shutdown一台机器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;13.你个人的职业规划是怎样的？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;想做一个有技术含量的测试工程师，从用户角度，到系统安全角度都能深入了解；&lt;/span&gt;&lt;br/&gt;&lt;span&gt;还有俗的，有技术含量了才能涨工资。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;个人感觉测试比较有创新性，目前没有问题的系统不能保证线上没有问题，只有测试懂的多了，想的全了，才能降低风险，比开发有意思，比运维也有意思。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;14.有带过团队么？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;哈哈哈，只带过实习生，后来公司还没要。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;15.有没有想过怎么把你的技能、想法传递给别人？&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;span&gt;培训，目前写写博客园博客，一来自己记录，二来同行共勉。&lt;/span&gt;&lt;br/&gt;&lt;span&gt;有专业人士带，学一门技术，二周就差不多了。&lt;/span&gt;&lt;/p&gt;





&lt;p&gt;&lt;span&gt;==========================================================================================================&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;上次你见到我的时候&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我还能嘟起小嘴&lt;/span&gt;&lt;br/&gt;&lt;span&gt;像小鱼吐吐气&lt;/span&gt;&lt;br/&gt;&lt;span&gt;再次相见的时候&lt;/span&gt;&lt;br/&gt;&lt;span&gt;我只能浅浅笑&lt;/span&gt;&lt;br/&gt;&lt;span&gt;用口罩拉远彼此的距离&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 26 Feb 2019 13:39:00 +0000</pubDate>
<dc:creator>夏天里的Jasmine</dc:creator>
<og:description>岗位描述： 信用卡核心系统功能测试，负责测试计划制定，测试设计，测试执行，测试进度掌控，自动化工具建设等工作。有责任心，执行力强，工作认真细致，逻辑思维强熟悉linux，oracle或者IBM大型机操</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/qianjinyan/p/10440326.html</dc:identifier>
</item>
<item>
<title>js中对象和对象创建方法 - Yellow_ice</title>
<link>http://www.cnblogs.com/Yellow-ice/p/10439386.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Yellow-ice/p/10439386.html</guid>
<description>&lt;p&gt;&lt;span&gt;这一次我们来说一说在JavaScript中经常会用到的一个复杂基本类型，对象，先从对象的属性讲起，再讲对象的创建方法，基本涵盖了创建对象的各种方法，大家一起学习呀~&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;一、对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    要掌握对象的使用及继承，首先当然需要先理解它，接下来，将会对对象的属性类型进行一个整理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;1、什么是对象&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;对象其实是无序属性的集合，其属性可以包含基本值，对象或者函数，比如像下面这个例子就是一个person对象啦&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; person =&lt;span&gt; {
    name: &lt;/span&gt;&quot;NIcholas&quot;&lt;span&gt;,
    age: &lt;/span&gt;29&lt;span&gt;,
    sayName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;从上面的例子我们可以看到，对象可以是由属性和其相应的值构成，对象中可以包含函数，也可以包含其它对象&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;strong&gt;2、属性类型&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;在JavaScript中，其实有两种属性，包括数据属性和访问器属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （1）数据属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    数据属性包含一个数据值的位置，在这个位置可以读取和写入值，一般来说，有4个描述其行为的特性：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    a、[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，默认值为true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    b、[[Enumerable]]：表示能否通过for-in循环返回属性，默认值为true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    c、[[Writable]]：表示能否修改属性的值，默认值为true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    d、[[Value]]：包含这个属性的数据值，默认值为undefined&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    一般来说，数据属性都有自己的默认值，那么如果我们要修改数据属性默认的特性，应该怎么办呢？这个时候就需要用到&lt;span&gt;Object,defineProperty()方法&lt;/span&gt;啦，这个方法接收三个参数：属性所在的对象，属性的名字和一个描述对象，来看下面的例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; person =&lt;span&gt; {};
Object.defineProperty(person, &lt;/span&gt;&quot;name&quot;&lt;span&gt;, {
    writable: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
    value: &lt;/span&gt;&quot;Nicholas&quot;&lt;span&gt;
});

console.log(person.name);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Nicholas&lt;/span&gt;&lt;span&gt;
//&lt;/span&gt;&lt;span&gt; 重新赋值&lt;/span&gt;
person.name = &quot;Greg&quot;&lt;span&gt;;
console.log(person.name);  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Nicholas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;从上面的例子我们可以看到，因为设置了person对象的name属性为不可修改，因此无论你在后面怎么修改person的name属性的值，name属性的值都不会发生改变&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （2）访问器属性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    访问器属性不包含数据值，它们包含一对儿getter和setter函数，在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值，在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据，访问器属性有以下4个特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    a、[[Configurable]]：表示能否通过delete删除属性从而重新定义属性，默认值为true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    b、[[Enumerable]]：表示能否通过for-in循环返回属性，默认值为true&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    c、[[Get]]：在读取属性时调用的函数，默认值为undefined&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    d、[[Set]]：在写入属性时调用的函数，默认值为undefined&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    访问器属性不能直接定义，必须调用&lt;span&gt;Object.definedProperty()&lt;/span&gt;来定义的，来看下面的例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;var&lt;/span&gt; book =&lt;span&gt; {
    _year:&lt;/span&gt;2004&lt;span&gt;,
    edition:&lt;/span&gt;1&lt;span&gt;
}

Object.defineProperty(book, &lt;/span&gt;&quot;year&quot;&lt;span&gt;, {
    get: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;._year;
    },
    set: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;(newValue) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._year =&lt;span&gt; newValue;
    }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;这里要说明一下，book对象中_year前面的&lt;span&gt;下划线是一种常用的记号，用于表示只能通过对象方法访问的属性&lt;/span&gt;，还有呀，大家不要小看了Object.definedProperty()这个方法，这个方法可是很强大呀，像&lt;span&gt;vue的双向数据绑定，其实就是用到了这个方法去实现&lt;/span&gt;的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    （3）读取属性的特性&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    既然JavaScript有数据属性和访问器属性，那么我们怎样才能读取它们呀，这个时候就需要用到&lt;span&gt;Object.getOwnPropertyDescriptor()&lt;/span&gt;方法了，这个方法可以取得给定属性的描述符，接收两个参数，分别是属性所在的对象和要读取其描述符的属性名称&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;二、对象的创建&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在了解了对象之后，接下来我们就需要说下怎么创建对象了，最简单的方法，当然就是使用前面说的对象字面量的方法去创建啦，但是如果我们需要创建好多个对象，用前面的方法就不行了，我们需要用到其它更加简便的方法，帮助我们创建出多个对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;1、工厂模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;这种模式其实是一个设计模式，抽象了创建具体对象的过程，主要是通过在函数内部创建一个对象，为其添加属性和方法，并将对象返回，从而实现创建多个对象的目的，来看下面的例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; createPerson(name, age) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    o.name &lt;/span&gt;=&lt;span&gt; name;
    o.age &lt;/span&gt;=&lt;span&gt; age;
    o.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    };
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = createPerson(&quot;Nicholas&quot;, 29&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = createPerson(&quot;Greg&quot;, 27);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;优点：能够解决创建多个对象的问题，兼容各个浏览器&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    缺点：没有解决对象识别的问题，不能知道一个对象的类型&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;strong&gt;2、构造函数模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这种模式主要通过创建自定义的构造函数，从而定义自定义对象类型的属性和方法，来看下面例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.sayName = &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Nicholas&quot;, 29&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Greg&quot;, 27);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;这里要说明一下，&lt;span&gt;构造函数需要以一个大写字母开头，而非构造函数应该以一个小写字母开头&lt;/span&gt;，这个主要是为了区别构造函数和其它函数，构造函数其实本身也是函数，只是用来创建对象而已&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    其中，要创建Person的新实例，需要&lt;span&gt;使用new操作符，其实这里会经过4个步骤，首先，将会创建一个新对象，接着会将构造函数的作用域赋给新对象，this指向了这个对象，接着会执行构造函数中的代码，为这个新对象添加属性，最后会返回新对象&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    优点：可以创建多个对象，解决对象的识别问题&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    缺点：每个实例都会创建不同的function实例，而其实创建完成同样任务的function实例是很没有必要的&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    这里还是要说明一下，对象类型的检测需要用到&lt;span&gt;instanceof操作符&lt;/span&gt;，比如像上面的例子可以用下面的方法检测&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
console.log(person1 &lt;span&gt;instanceof&lt;/span&gt; Person);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  true&lt;/span&gt;
console.log(person2 &lt;span&gt;instanceof&lt;/span&gt; Person);  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;使用构造函数模式可以解决对象的识别问题，而这也是工厂模式无法办到的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;    &lt;strong&gt;&lt;span&gt;3、原型模式&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt;&lt;span&gt; 我们都知道，每个函数都有一个prototype属性，这个属性是一个指针，指向一个对象，而这个对象就是原型对象，包含了所有实例共享的属性和方法，如果我们要创建的对象需要共享属性和方法，就可以使用这种方法创建&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person() {
}

Person.prototype.name &lt;/span&gt;= &quot;Nicholas&quot;&lt;span&gt;;
Person.prototype.age &lt;/span&gt;= 29&lt;span&gt;;
Person.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
    console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Person();
person1.sayName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Nicholas&lt;/span&gt;
person2.sayName();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Nicholas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;优点：不用为构造函数传递参数，可以创建多个相同的对象&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    缺点：原型中的属性被很多实例共享，当属性为包含引用类型值的属性时，修改一个实例中属性的值，另一个实例中的属性的值也会改变&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;strong&gt;4、组合使用构造函数模式和原型模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;通过前面的分析，我们应该可以看到构造函数模式和原型模式的优点和缺点啦，构造函数可以创建多个不同属性值的对象，原型模式可以用于定义方法和共享的属性，我们可以将这两种模式结合起来，这种模式现在是使用最广泛的一种模式啦&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
}

Person.prototype &lt;/span&gt;=&lt;span&gt; {
    constructor: Person,
    sayName: &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Nicholas&quot;, 29&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person2 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Greg&quot;, 27&lt;span&gt;);

person1.sayName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Nicholas&lt;/span&gt;
person2.sayName();  &lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Greg&lt;/span&gt;
person1.sayName === person2.sayName; &lt;span&gt;//&lt;/span&gt;&lt;span&gt; true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;从上面的例子我们可以看到，使用这种模式创建对象，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存，另外，这种混成模式还支持向构造函数传递参数，可谓是集两种模式之长&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;strong&gt;5、动态原型模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;   &lt;/strong&gt; 这种模式主要是将所有信息都封装在了构造函数里，因为在组合构造函数模式和原型模式中，构造函数和原型模式是独立的，有些开发人员会感到很困惑，因此，这种模式也是为了解决这个问题，通过在构造函数中初始化初始化原型，又保持了同时使用构造函数和原型的优点，换句话说，就是可以通过在构造函数中，检查某个应该存在的方法是否有效，来决定是否需要初始化原型&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;(&lt;span&gt;typeof&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.sayName != &quot;function&quot;&lt;span&gt;) {
        Person.prototype.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
            console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
        }
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Nicholas&quot;, 29&lt;span&gt;);
person1.sayName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Nicholas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;    &lt;span&gt;这里要说明一下，在if语句中的代码，只有在首次调用构造函数时才会执行，之后原型已经得到初始化，不需要再做什么修改了&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;strong&gt;6、寄生构造函数模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;这种模式其实和工厂模式很像，除了使用new操作符并把使用的包装函数叫做构造函数之外，和工厂模式可以说是一模一样的，这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码，然后再返回新创建的对象&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    o.name &lt;/span&gt;=&lt;span&gt; name;
    o.age &lt;/span&gt;=&lt;span&gt; age;
    o.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Nicholas&quot;, 29&lt;span&gt;);
person1.sayName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Nicholas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;寄生构造函数模式和工厂模式真的是很像，那么既然有了工厂模式，为什么还要有寄生构造函数模式呢？其实&lt;span&gt;这个模式主要是用来给js原生的构造函数定义一些新的方法&lt;/span&gt;，我们可以看下面这个例子&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; SpecialArray() {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; values = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Array();
    values.push.apply(values, argumens);
    values.toPipedString &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;.join(&quot;|&quot;&lt;span&gt;);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; values;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; colors = &lt;span&gt;new&lt;/span&gt; SpecialArray(&quot;red&quot;,&quot;blue&quot;&lt;span&gt;);
console.log(colors.toPipedString());  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  red|blue&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;从上面这个例子我们可以看到，我们在构造函数里面创建了一个新的数组，然后通过push方法初始化这个数组，并且又给数组的实例添加了一个toPipedString方法，并且将所创建的数组返回，因此呢，当我们通过new创建了SpecialArray实例时，其实就得到增加了新方法的数组实例啦，就可以在这个实例上使用我们添加的新的方法toPipedString&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    &lt;strong&gt;7、稳妥构造函数模式&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;    &lt;/strong&gt;在说这种模式之前，要先说一下稳妥对象，&lt;span&gt;稳妥对象就是指没有公共属性，而且其方法也不引用this的对象，稳妥对象最适合在一些安全的环境中，或者防止数据被其他应用程序改动时使用&lt;/span&gt;，稳妥构造函数模式遵循与寄生构造函数类似的模式，但是还是有下面的不同，&lt;span&gt;第一个是新创建的对象实例方法不引用this，第二个是不使用new操作符调用构造函数&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; Person(name, age) {
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; o = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Object();
    _name &lt;/span&gt;=&lt;span&gt; name;
    _age &lt;/span&gt;=&lt;span&gt; age;
    o.sayName &lt;/span&gt;= &lt;span&gt;function&lt;/span&gt;&lt;span&gt;() {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; _name;
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; o;
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Nicholas&quot;, 29&lt;span&gt;);
person1.sayName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Nicholas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;在上面这个例子中，我们在构造函数中创建了一个对象后，可以继续添加一些私有的变量和函数，要修改这些私有的变量和函数，只能通过创建的对象的方法进行访问，这里在对象上创建的方法其实可以看作就是公有方法，比如说这里的_name和_age就是私有变量，而对象o的sayName方法就是访问私有变量的公有方法了，这里除了调用sayName()方法外，没有其它方法可以访问其数据成员&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;span&gt;    8、es6中创建对象的方法&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;   &lt;/span&gt;&lt;/strong&gt; &lt;span&gt;最后要来说下es6中创建对象新增的方法啦，在es6中，引入了 Class（类）这个概念，作为对象的模板，通过&lt;code&gt;class&lt;/code&gt;关键字，可以定义类，基本上，ES6 的&lt;code&gt;class&lt;/code&gt;可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的&lt;code&gt;class&lt;/code&gt;写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;class Person {
    constructor(name, age) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.name =&lt;span&gt; name;
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.age =&lt;span&gt; age;
    }
    sayName() {
        console.log(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.name);
    }
}

&lt;/span&gt;&lt;span&gt;var&lt;/span&gt; person1 = &lt;span&gt;new&lt;/span&gt; Person(&quot;Nicholas&quot;, 29&lt;span&gt;);
person1.sayName();  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;  Nicholas&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;    &lt;span&gt;上面这个例子其实就是组合构造函数模式和原型模式的改写，其中，constructor属性直接指向类本身，该方法会默认返回实例对象，在里面定义的属性和方法都是实例本身具有的方法，不是其它实例共享的，而像sayName方法就是定义在原型上的方法了，是所有实例一起共享的&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;    好啦，今天就介绍到这里了，不知道大家对对象和对象的创建是否有了一个比较详细的了解了呢&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt; &lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;    &lt;/span&gt;&lt;/strong&gt;&lt;span&gt;  &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;    &lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Tue, 26 Feb 2019 12:54:00 +0000</pubDate>
<dc:creator>Yellow_ice</dc:creator>
<og:description>这一次我们来说一说在JavaScript中经常会用到的一个复杂基本类型，对象，先从对象的属性讲起，再讲对象的创建方法，基本涵盖了创建对象的各种方法，大家一起学习呀~ 一、对象 要掌握对象的使用及继承，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Yellow-ice/p/10439386.html</dc:identifier>
</item>
<item>
<title>Docker应用：Docker-compose（容器编排） - 漂亮的猫</title>
<link>http://www.cnblogs.com/lanxiaoke/p/10439282.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lanxiaoke/p/10439282.html</guid>
<description>&lt;p&gt;&lt;strong&gt;&lt;span&gt;阅读目录：&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;前言：&lt;/h2&gt;
&lt;p&gt;　　昨天完成了Docker入门示例（&lt;span&gt;Docker应用：Hello World&lt;/span&gt;），示例只是粗略展示了单机应用在Docker中部署的大概流程；&lt;/p&gt;
&lt;p&gt;但是即使先不考虑大型项目关联的多个应用服务，单单只是单机应用部署来说，过程也是略为复杂。&lt;/p&gt;
&lt;p&gt;　　因为现在的软件公司开发、测试、部署基本上分开，甚至交由不同的人完成各个阶段的工作，如果软件部署要敲写大量的命令，&lt;/p&gt;
&lt;p&gt;那还是很容易出错；甚至有些公司只是运维人员、工程人员在部署，一旦出了问题，他们想找到原因基本很难。&lt;/p&gt;
&lt;p&gt;所以要求部署必须是接近傻瓜式的，所以有了容器编排技术。&lt;/p&gt;

&lt;h2&gt;一、遗留问题&lt;/h2&gt;
&lt;p&gt;　　昨天的示例是遗留有一些问题的，比如容器重启后IP地址变化，容器重启后应用相关的远程容器服务都将失效，这点是非常致命的。&lt;/p&gt;
&lt;p&gt;第二是网络通信问题，昨天的示例中Web调用Mysql是通过ip映射，出到容器外部在访问另外一个容器内部的数据，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; conn = &lt;span&gt;new&lt;/span&gt; MySqlConnection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server=&lt;strong&gt;&lt;span&gt;198.198.198.181&lt;/span&gt;&lt;/strong&gt;;User Id=root;password=mima2100;Database=mysql-db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;198.198.198.181是我本地机器的局域网IP，由于这个IP，导致Web应用对Mysql容器有了硬耦合，得想办法去掉。&lt;/p&gt;

&lt;h2&gt;二、解决问题&lt;/h2&gt;
&lt;p&gt;1、其实也简单，在Dockerfile文件相同目录创建docker-compose.yml文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; version: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;3&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;services:
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;  web:
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;      build: .
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;      ports:
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt;        - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;8000:80&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;      depends_on:
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt;        -&lt;span&gt; mysql
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;  mysql:
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;    container_name: mysql_dc
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    environment:
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;       - MYSQL_ROOT_PASSWORD=&lt;span&gt;mima2100
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; &lt;span&gt;    image: mysql
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt; &lt;span&gt;    ports:
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt;       - &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;3306:3306&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、上边的docker-compose.yml文件格式，其他参数各自百度一下，意思就是创建2个应用：web、mysql&lt;/p&gt;
&lt;p&gt;2.1、web在本直接build（也有从镜像下载的方式），80端口映射到本地8000端口，依赖mysql&lt;/p&gt;
&lt;p&gt;2.2、mysql指定登录密码mima2100，容器3306端口映射到本地3306&lt;/p&gt;
&lt;p&gt;2.3、Mysql连接改成如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; Dapper;
&lt;/span&gt;&lt;span&gt; 2&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt; 4&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Data;
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Threading.Tasks;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;using&lt;/span&gt;&lt;span&gt; MySql.Data.MySqlClient;
&lt;/span&gt;&lt;span&gt; 7&lt;/span&gt; 
&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; WebApp_HelloWorld.Controllers
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;{
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;     &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; DBService
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;    {
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;         &lt;span&gt;protected&lt;/span&gt;&lt;span&gt; IDbConnection conn;
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt;&lt;span&gt; DBService()
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;             conn = &lt;span&gt;new&lt;/span&gt; MySqlConnection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;server=&lt;span&gt;&lt;strong&gt;mysql_dc&lt;/strong&gt;&lt;/span&gt;;User Id=root;password=mima2100;Database=mysql-db&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
&lt;/span&gt;&lt;span&gt;17&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; 
&lt;span&gt;19&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;T&amp;gt; Single&amp;lt;T&amp;gt;(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;object&lt;/span&gt; paramPairs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; conn.QuerySingleOrDefaultAsync&amp;lt;T&amp;gt;&lt;span&gt;(sql, paramPairs);
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt; 
&lt;span&gt;24&lt;/span&gt;         &lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt; Count(&lt;span&gt;string&lt;/span&gt; sql, &lt;span&gt;object&lt;/span&gt; paramPairs = &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; &lt;span&gt;        {
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt;             &lt;span&gt;return&lt;/span&gt; &lt;span&gt;await&lt;/span&gt; conn.QuerySingleOrDefaultAsync&amp;lt;&lt;span&gt;int&lt;/span&gt;&amp;gt;&lt;span&gt;(sql, paramPairs);
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt; &lt;span&gt;        }
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; }
&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;三、验证&lt;/h2&gt;
&lt;p&gt;1、验证一下docker-compose版本&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; docker-compose version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254672/201902/254672-20190226195359422-1414535603.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、定位到web目录，输入指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; docker-compose up -d
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254672/201902/254672-20190226194909572-158119402.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254672/201902/254672-20190226195007619-1413217159.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;3、查看容器&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot;&gt;
&lt;pre&gt;
&lt;span&gt;1&lt;/span&gt; docker ps -a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254672/201902/254672-20190226195842420-997735990.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到mysql与web都创建成功了，无报错。&lt;/p&gt;
&lt;p&gt;4、访问一下localhost:8000&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/254672/201902/254672-20190226195126559-1257134305.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;搞定。。&lt;/p&gt;

</description>
<pubDate>Tue, 26 Feb 2019 11:56:00 +0000</pubDate>
<dc:creator>漂亮的猫</dc:creator>
<og:description>阅读目录： Docker应用：Hello World Docker应用：Docker-compose（容器编排） 前言： 昨天完成了Docker入门示例（Docker应用：Hello World），示</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lanxiaoke/p/10439282.html</dc:identifier>
</item>
<item>
<title>KOA中间件的基本运作原理 - 大史不说话</title>
<link>http://www.cnblogs.com/dashnowords/p/10439605.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/dashnowords/p/10439605.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201902/1354575-20190226194955708-873816086.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;3.2041884816754&quot;&gt;
&lt;p&gt;示例代码托管在：&lt;a href=&quot;http://www.github.com/dashnowords/blogs&quot; class=&quot;uri&quot;&gt;http://www.github.com/dashnowords/blogs&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;博客园地址：&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/10127926.html&quot;&gt;《大史住在大前端》原创博文目录&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;华为云社区地址：&lt;a href=&quot;https://bbs.huaweicloud.com/blogs/8ae7e6420a4611e9bd5a7ca23e93a891&quot;&gt;【你要的前端打怪升级指南】&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在中间件系统的实现上，&lt;code&gt;KOA&lt;/code&gt;中间件通过&lt;code&gt;async/await&lt;/code&gt;来在不同中间件之间交换控制权，工作机制和&lt;strong&gt;栈&lt;/strong&gt;结构非常相似，建议结合&lt;a href=&quot;https://www.cnblogs.com/dashnowords/p/9683361.html&quot;&gt;《express中间件系统的基本实现》&lt;/a&gt;对比学习，两个框架所基于的语法特性有区别（&lt;code&gt;express&lt;/code&gt;使用&lt;code&gt;ES5&lt;/code&gt;的回调风格语法，&lt;code&gt;KOA&lt;/code&gt;使用&lt;code&gt;ES7&lt;/code&gt;的扁平式异步&lt;code&gt;async/await&lt;/code&gt;风格语法），但在框架基本原理上是很类似的，只是中间件写法和遍历机制稍有不同。&lt;/p&gt;
&lt;h2 id=&quot;一.-api层&quot;&gt;一. API层&lt;/h2&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;初始化方法&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;let middleware = new MiddleWare();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;添加中间件函数的方法&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//Fn为被添加的中间件,KOA中间件为async函数
middleware.use(Fn);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;预处理中间件栈&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//将存储于数组中的各个中间件组合为按照“先进后出”原则执行的中间件系统。
middleware.start = middleware.compose();&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动中间件队列&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;middleware.start(ctx);&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;二.-核心类的定义&quot;&gt;二. 核心类的定义&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;/*
* KOA中间件框架的基本实现
*/

class MiddleWare {
    constructor(){
        this.queue = []
    }

    //添加中间件函数
    use(fn){
       this.queue.push(fn);
    }

    //合并中间件处理流，是一个高阶函数，调用一次后会生成真正需要的函数。
    compose(){
        return function (ctx, next) {
           let _this= this;
           let index = -1;
           return dispatch(0);
           
           /**
            * KOA中间件的工作的步进函数
            */
           function dispatch(i) {
             index = i;
             //依次取用数组中添加的中间件函数
             let fn = i === _this.queue.length ? next : _this.queue[i];
             if(!fn){
               return Promise.resolve();
             }
             
             try{
                 /*
                 *中间件函数的形式为 async fn(ctx, next),可以看到此处透传了ctx的引用，
                 *同时next是一个延迟执行中间件队列中下一个中间件的函数，也就是说如果在前
                 *一个中间件的函数体中调用 await next()，就会启动下一个中间件,实际执行
                 *的函数是dispatch(i+1)。
                 */
                 return Promise.resolve(fn(ctx,()=&amp;gt;{
                   return dispatch(i+1);
                 }));
             }catch(err){
                 return Promise.reject(err);
             }
           }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三.-使用use方法添加中间件&quot;&gt;三. 使用use方法添加中间件&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//添加回调函数
middleware.use(async function(ctx, next){
  console.log('step 001');
  ctx.info = 'go through middleware1';
  await next();
  console.log('step 006');
});

middleware.use(async function(ctx, next){
  console.log('step 002');
  await next();
  console.log('step 005');
});

middleware.use(async function(ctx, next){
  console.log('step 003');
  await next();
  console.log('step 004');
});&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四.-中间件实例&quot;&gt;四. 中间件实例&lt;/h2&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//初始化
let middleware = new MiddleWare();

/*
...此处为添加中间件的代码
*/

middleware.start = middleware.compose();&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;五.-查看运行结果&quot;&gt;五. 查看运行结果&lt;/h2&gt;
&lt;p&gt;可以看到有错误发生和正常响应时的不同结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201902/1354575-20190226195034819-1269481118.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;六.-在服务器端运行&quot;&gt;六. 在服务器端运行&lt;/h2&gt;
&lt;p&gt;用&lt;code&gt;node&lt;/code&gt;起一个web服务器那真是太随意了~&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;//启动http服务
http.createServer(function(req, res){
    console.log(req.url);
    let info = {};
    middleware.start(info);
    res.end(JSON.stringify(info));
}).listen(9527);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;看一下效果(访问服务器时自定义消息就可以传至前台了)：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1354575/201902/1354575-20190226195104487-883315086.png&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 26 Feb 2019 11:51:00 +0000</pubDate>
<dc:creator>大史不说话</dc:creator>
<og:description>示例代码托管在： 'http://www.github.com/dashnowords/blogs' 博客园地址： '《大史住在大前端》原创博文目录' 华为云社区地址： '【你要的前端打怪升级指南】'</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/dashnowords/p/10439605.html</dc:identifier>
</item>
<item>
<title>Django-restframework 之频率源码分析 - Eurekaa</title>
<link>http://www.cnblogs.com/zuanzuan/p/10439590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zuanzuan/p/10439590.html</guid>
<description>&lt;h2 id=&quot;一-前言&quot;&gt;一 前言&lt;/h2&gt;
&lt;p&gt;经过权限判断之后就是进行频率的判断了，而频率的判断和权限又不一样，认证、权限和频率的执行流程都差不多，使用配置里面的相关类来进行判断。而不和认证和权限一样，频率的配置没有，查看&lt;code&gt;APIView&lt;/code&gt;的类属性如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcly1g0jolhvijhj31es0fo456.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcly1g0jomlax2gj31g00p2gu9.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二-频率组件执行流程&quot;&gt;二 频率组件执行流程&lt;/h2&gt;
&lt;p&gt;虽然&lt;code&gt;restframework&lt;/code&gt;原生灭有配置频率，但是提供了几个进行频率判断的类，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcly1g0joona2jrj311i066taz.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;SimpleRateThrottle&lt;/code&gt;类是根据访问者 ip 来进行频率限制的一个类，来看看这个类的执行流程。&lt;/p&gt;
&lt;h3 id=&quot;init方法&quot;&gt;1. init方法&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcly1g0jsqpl8dkj31fq0l8tft.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;get_rate&quot;&gt;2. get_rate&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws4.sinaimg.cn/large/006tKfTcly1g0jt3y8eoej31fu0dq0xd.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;执行-allow_request方法&quot;&gt;3. 执行 allow_request方法&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tKfTcly1g0jt85q53sj31ee0mqgsg.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;get_cache_key&quot;&gt;4. get_cache_key&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcly1g0jt9uszixj31ag07ogow.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;时间差判断&quot;&gt;5. 时间差判断&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws1.sinaimg.cn/large/006tKfTcly1g0jtef84ajj31ds0b2q9a.jpg&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;throttle_success&quot;&gt;6. throttle_success&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcly1g0jtgzjdg2j31ew07wn02.jpg&quot;/&gt;&lt;/p&gt;
&lt;p&gt;认证失败的话执行&lt;code&gt;throttle_failure&lt;/code&gt;，其实就是返回&lt;code&gt;False&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&quot;wait&quot;&gt;7. wait&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://ws3.sinaimg.cn/large/006tKfTcly1g0k1tmv4b2j31ew0dudji.jpg&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;三-自定义频率组件&quot;&gt;三 自定义频率组件&lt;/h2&gt;
&lt;h3 id=&quot;自定义频率类&quot;&gt;1. 自定义频率类&lt;/h3&gt;
&lt;p&gt;频率类需要继承自带的频率类&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# from rest_framework.throttling import BaseThrottle

class BookThrottle(BaseThrottle):

    VISIT_RECORD = {}

    def __init__(self):
        self.history = None

    def allow_request(self, request, view):
        print(request.META)
        REMOTE_ADDR = request.META.get('REMOTE_ADDR')

        import time
        ctime = time.time()
        if REMOTE_ADDR not in self.VISIT_RECORD:
            self.VISIT_RECORD[REMOTE_ADDR] = [ctime,]
            return True
        self.history = self.VISIT_RECORD.get(REMOTE_ADDR)

        while self.history and ctime - self.history[-1] &amp;gt; 60:
            self.history.pop()

        if len(self.history) &amp;lt; 3:
            self.history.insert(0, ctime)
            return True
        else:
            return False

    def wait(self):
        import time
        ctime = time.time()

        return 60 - (ctime - self.history[-1])&lt;/code&gt;
&lt;/pre&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# 频率类代码注释
         # 访问频率的逻辑
#         #     {'ip地址':[16:13:39,16:13:19,],'ip地址2':[时间1,时间2],}
#         # （1）取出访问者ip
#         # （2）判断当前ip不在访问字典里，添加进去，并且直接返回True,表示第一次访问，在字典里，继续往下走
#         # （3）循环判断当前ip的列表，有值，并且当前时间减去列表的最后一个时间大于60s，把这种数据pop掉，这样列表中只有60s以内的访问时间，
#         # （4）判断，当列表小于3，说明一分钟以内访问不足三次，把当前时间插入到列表第一个位置，返回True，顺利通过
#         # （5）当大于等于3，说明一分钟内访问超过三次，返回False验证失败
#         #（1）取出访问者ip
#         # print(request.META)
#         # REMOTE_ADDR 就是访问者的ip:127.0.0.1
#         ip=request.META.get('REMOTE_ADDR')
#         import time
#         # 获取当前时间
#         ctime=time.time()
#         # （2）判断当前ip不在访问字典里，添加进去，并且直接返回True,表示第一次访问
#         if ip not in self.VISIT_RECORD:
#             self.VISIT_RECORD[ip]=[ctime,]
#             # {'127.0.0.1':[时间1,时间1,]}
#             return True
#         # self.history=[时间1,时间1,]
#         self.history=self.VISIT_RECORD.get(ip)
#         # （3）循环判断当前ip的列表，有值，并且当前时间减去列表的最后一个时间大于60s，把这种数据pop掉，这样列表中只有60s以内的访问时间，
#         while self.history and ctime-self.history[-1]&amp;gt;60:
#             self.history.pop()
#         # （4）判断，当列表小于3，说明一分钟以内访问不足三次，把当前时间插入到列表第一个位置，返回True，顺利通过
#         # （5）当大于等于3，说明一分钟内访问超过三次，返回False验证失败
#         if len(self.history)&amp;lt;3:
#             self.history.insert(0,ctime)
#             return True
#         else:
#             return False&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;使用&quot;&gt;2. 使用&lt;/h3&gt;
&lt;p&gt;使用很简单，在需要进行频率控制的视图类中定义一个属性&lt;code&gt;throttle_classes&lt;/code&gt;，如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Book(APIView):
    authentication_classes = [authticate_classes.BookAuth]
    permission_classes = [permiss_classes.LoginPermission]
    throttle_classes = [thrott_classes.BookThrottle]
    # authentication_classes = []

    def dispatch(self, request, *args, **kwargs):
        return super().dispatch(request, *args, **kwargs)

    def get(self, request, id):
        print(request.user, '444')
        response = {'status': 100, 'msg': None}
        book_obj = models.Book.objects.filter(pk=id).first()
        if book_obj:
            book_ser = myser.BookSer(book_obj, many=False)
            response['book'] = book_ser.data
        else:
            response['msg'] = '图书没有对象'
            response['status'] = 101
        return Response(response)&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四-配置自定义频率类&quot;&gt;四 配置自定义频率类&lt;/h2&gt;
&lt;h3 id=&quot;局部配置&quot;&gt;1. 局部配置&lt;/h3&gt;
&lt;p&gt;其实上面的就是局部配置，&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;class Book(APIView):
    authentication_classes = [authticate_classes.BookAuth]
    permission_classes = [permiss_classes.LoginPermission]
    throttle_classes = [thrott_classes.BookThrottle]&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;全局使用&quot;&gt;2. 全局使用&lt;/h3&gt;
&lt;p&gt;全局配置如下：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;REST_FRAMEWORK={
    'DEFAULT_THROTTLE_CLASSES': ['app01.thrott_classes.BookThrottle']
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;局部禁用&quot;&gt;3. 局部禁用&lt;/h3&gt;
&lt;p&gt;局部禁用需要在视图类中定义一个空的&lt;code&gt;throttle_classes&lt;/code&gt;属性&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;throttle_classes = []&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 26 Feb 2019 11:47:00 +0000</pubDate>
<dc:creator>Eurekaa</dc:creator>
<og:description>Django restframework 之频率源码分析 一 前言 经过权限判断之后就是进行频率的判断了，而频率的判断和权限又不一样，认证、权限和频率的执行流程都差不多，使用配置里面的相关类来进行判断</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zuanzuan/p/10439590.html</dc:identifier>
</item>
<item>
<title>记录一下对swiper4.x.js在H5单页中的滑动优化 - xiangyuecn</title>
<link>http://www.cnblogs.com/xiangyuecn/p/10439504.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xiangyuecn/p/10439504.html</guid>
<description>&lt;p&gt;仅仅应用于单页应用的滑动操作，用&lt;code&gt;swiper4.x&lt;/code&gt;接管页面的滚动操作。用来支持顶部和尾部的回弹效果，进一步来支持常见那种下拉刷新动画效果。不适用于轮播图那种应用场景。&lt;/p&gt;
&lt;p&gt;虽然只是针对&lt;code&gt;swiper4.x&lt;/code&gt;，但相关原理，在别的框架中也是有参考意义的。&lt;/p&gt;

&lt;h2 id=&quot;一惯性动画不会在触摸时停止&quot;&gt;一、惯性动画不会在触摸时停止&lt;/h2&gt;
&lt;p&gt;快速滑动页面，手离开屏幕时产生的惯性动画还在运行时，此时触摸屏幕，动画不会停止。导致连续快速滑动页面，看起来有跳来跳去的感觉。&lt;/p&gt;
&lt;h2 id=&quot;二快速滑动手势大概率识别成慢滑动手势&quot;&gt;二、快速滑动手势大概率识别成慢滑动手势&lt;/h2&gt;
&lt;p&gt;连续快速多滑几下，有那么1、2下明显能够感知到滑动惯性动画变慢的情景，给人的感觉就是滑动不流畅。&lt;/p&gt;
&lt;h2 id=&quot;三惯性动画时长不合理&quot;&gt;三、惯性动画时长不合理&lt;/h2&gt;
&lt;p&gt;不管是很慢的滑动，还是很快的滑动，惯性动画时长只能设置一个固定值。慢慢移动松手后也会有一个很长的动画，快速滑的时候动画又有点短，综合看起来给人很卡的感觉。&lt;/p&gt;

&lt;p&gt;除了第一个问题，另外两个问题不修改&lt;code&gt;swiper4.x&lt;/code&gt;源码似乎无法克服。&lt;/p&gt;
&lt;h2 id=&quot;一解决惯性动画不会在触摸时停止的问题&quot;&gt;一、解决惯性动画不会在触摸时停止的问题&lt;/h2&gt;
&lt;p&gt;滑动时手离开屏幕时产生的惯性动画是&lt;code&gt;css动画&lt;/code&gt;，并未直接提供停止动画的方法。动画还在运行时如果触摸屏幕，不改源代码，那我们就监听一下&lt;code&gt;touchStart&lt;/code&gt;事件。&lt;/p&gt;
&lt;p&gt;用&lt;code&gt;setTranslate(translate)&lt;/code&gt;可以移除这个动画css，需要提供页面当前的滚动位置。用&lt;code&gt;getTranslate()&lt;/code&gt;就行了：&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;这与通过属性&lt;code&gt;mySwiper.translate&lt;/code&gt; 获取到的数值稍有不同，即使是在过渡时（&lt;code&gt;animating&lt;/code&gt;）也能获取到，而后者精度较高&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;解决方案代码&quot;&gt;解决方案代码&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//在touchStart事件中执行
mySwiper.setTranslate(mySwiper.getTranslate());&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;二解决快速滑动手势大概率识别成慢滑动手势问题&quot;&gt;二、解决快速滑动手势大概率识别成慢滑动手势问题&lt;/h2&gt;
&lt;p&gt;这个必须修改源代码才能解决，问题出在计算惯性动画起始速度时的计算参数精度不足。&lt;/p&gt;
&lt;h3 id=&quot;原代码&quot;&gt;原代码&lt;/h3&gt;
&lt;pre&gt;
&lt;code&gt;if (params.freeModeMomentum) {
        if (data.velocities.length &amp;gt; 1) {
          var lastMoveEvent = data.velocities.pop();
          var velocityEvent = data.velocities.pop(); //此处取值方式会导致精度不够

          var distance = lastMoveEvent.position - velocityEvent.position;
          var time = lastMoveEvent.time - velocityEvent.time;
          swiper.velocity = distance / time;
          swiper.velocity /= 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出，他计算起始速度&lt;code&gt;velocity&lt;/code&gt;参考的是&lt;code&gt;onTouchMove&lt;/code&gt;最后记录的两个点，单纯取最后两个点是不可靠的，可能因为最后两次&lt;code&gt;onTouchMove&lt;/code&gt;触发间隔比较长，导致计算出来的速度过低。从而导致偶尔会快速滑动但惯性效果是慢滑动的效果。&lt;/p&gt;
&lt;p&gt;如果触发间隔很短，导致动画速度变快，变快了其实感知上并无区别。最要命的还是变慢，感觉很卡一样。&lt;/p&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;解决方案&lt;/h3&gt;
&lt;p&gt;一个很短的时间内，人的滑动方向不太可能会产生变化，但这个短时间内产生的滑动位移能够很好的代表手势结尾的滑动速度。&lt;/p&gt;
&lt;p&gt;经过反复尝试，用100毫秒内的位移来计算惯性起始速度最好，100毫秒内，如果是快速滑动，会触发多次&lt;code&gt;onTouchMove&lt;/code&gt;，计算出来的速度是很接近实际的手势速度。&lt;/p&gt;
&lt;p&gt;问题的解决指向了100毫秒内的第一个点。解决代码：&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;if (params.freeModeMomentum) {
        if (data.velocities.length &amp;gt; 1) {
            //fix 惯性动画
            var velos=data.velocities;
            var firstEvent=velos[0];
            var lastMoveEvent = velos.pop();
            var velocityEvent =velos.pop();
            for(var i=velos.length-1;i&amp;gt;=0;i--){//找出100毫秒内的起始位置
                var velo=velos[i];
                if(lastMoveEvent.time-velo.time&amp;gt;100){
                    break;
                }
                velocityEvent=velo;
            }

          var distance = lastMoveEvent.position - velocityEvent.position;
          var time = lastMoveEvent.time - velocityEvent.time;
          swiper.velocity = distance / time;
          swiper.velocity /= 2;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三解决惯性动画时长不合理问题&quot;&gt;三、解决惯性动画时长不合理问题&lt;/h2&gt;
&lt;p&gt;慢滑动时惯性应该很小，动画很短；快速滑动时惯性应该很大，动画很长。&lt;code&gt;swiper4.x&lt;/code&gt;只能提供一个固定的惯性动画时长，不改源代码是解决不了的。&lt;/p&gt;
&lt;h3 id=&quot;原代码在第二问代码下面一点点&quot;&gt;原代码在第二问代码下面一点点&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var momentumDuration = 1000 * params.freeModeMomentumRatio; //写死了固定动画时长&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;优化动画&quot;&gt;优化动画&lt;/h3&gt;
&lt;p&gt;其实也简单，小的就小，大的就大，用初始速度&lt;code&gt;velocity&lt;/code&gt;来做乘法运算即可达到效果。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;var momentumDuration = Math.abs(swiper.velocity) * 1000 * params.freeModeMomentumRatio;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;结果：比原代码好很多，但跟别的app里面的滑动还是区别蛮大，慢滑时还是太快了点。&lt;/p&gt;
&lt;p&gt;App原生滑动动画，感知上是慢的更慢，快的更快。轻微滑动慢的要死，快速动一点点，飞快。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2152669-75e5d258144dccf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;/&gt;&lt;/p&gt;
&lt;p&gt;对数曲线！1-0范围蛮符合，缓的地方比线性的还缓，陡的地方奇陡无比。在上面优化的结果基础上用对数加持一下，效果非常不错。另外限定最长动画不超过3秒。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//取对数曲线优化一下0.5-1.5倍之间，慢的越慢，快的越快
momentumDuration*=-Math.log10(Math.min(0.3,Math.max(0.03,(3000-momentumDuration)/3000)));&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;解决方案代码-1&quot;&gt;解决方案代码&lt;/h3&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;//根据初始速度来确定惯性动画时长
var momentumDuration = Math.min(3000,Math.abs(swiper.velocity) * 1000 * params.freeModeMomentumRatio);
//取对数曲线优化一下0.5-1.5倍之间，慢的越慢，快的越快
momentumDuration*=-Math.log10(Math.min(0.3,Math.max(0.03,(3000-momentumDuration)/3000)));
momentumDuration=Math.min(3000,momentumDuration);&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;应用&lt;code&gt;swiper4.x&lt;/code&gt;修改后的单页滚动效果，已经很接近App的滚动效果，虽然还是会有些细微的抖动卡顿感，但要做到完全和App一样的流畅效果，估计蛮难，当前算是已经蛮优了。&lt;/p&gt;
&lt;p&gt;还是iscroll省心些，但已经上了&lt;code&gt;swiper4.x&lt;/code&gt;这条船了就算了，迁移过来又迁移过去白折腾。&lt;/p&gt;
&lt;p&gt;改良后的滚动效果，目前[2019-02-27]号以后可以到 &lt;a href=&quot;https://jiebian.life/&quot;&gt;https://jiebian.life/start/xcx/tool_jieri&lt;/a&gt; 体验（这个时间之前新版本应该还没有上线），小程序和H5共用的页面。&lt;/p&gt;
</description>
<pubDate>Tue, 26 Feb 2019 11:32:00 +0000</pubDate>
<dc:creator>xiangyuecn</dc:creator>
<og:description>应用场景 仅仅应用于单页应用的滑动操作，用 接管页面的滚动操作。用来支持顶部和尾部的回弹效果，进一步来支持常见那种下拉刷新动画效果。不适用于轮播图那种应用场景。 虽然只是针对 ，但相关原理，在别的框架</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/xiangyuecn/p/10439504.html</dc:identifier>
</item>
</channel>
</rss>