<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>[ASP.NET Core 3框架揭秘] 异步线程无法使用IServiceProvider？ - Artech</title>
<link>http://www.cnblogs.com/artech/p/async-di.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/artech/p/async-di.html</guid>
<description>&lt;p&gt;标题反映的是上周五一个同事咨询我的问题，我觉得这是一个很好的问题。这个问题有助于我们深入理解依赖注入框架在ASP.NET Core中的应用，以及服务实例的生命周期。&lt;/p&gt;

&lt;p&gt;我们通过一个简单的实例来模拟该同事遇到的问题。我们采用极简的方式创建了如下这个ASP.NET Core MVC应用。如下面的代码片段所示，除了注册与ASP.NET Core MVC框架相关的服务与中间件之外，我们还调用了IHostBuilder的UseDefaultServiceProvider方法将配置选项ServiceProviderOptions的ValidateScopes属性设置为True，以开启针对服务范围的验证。我们还采用Scoped生命周期模式注册了服务IFoobar，具体的实现类型Foobar还实现了IDisposable接口。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Program
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; Main()
    {
        Host
            .CreateDefaultBuilder()
            .UseDefaultServiceProvider(options &lt;/span&gt;=&amp;gt; options.ValidateScopes = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;)
            .ConfigureWebHostDefaults(builder &lt;/span&gt;=&amp;gt;&lt;span&gt; builder
                .ConfigureLogging(logging &lt;/span&gt;=&amp;gt;&lt;span&gt; logging.ClearProviders())
                .ConfigureServices(services &lt;/span&gt;=&amp;gt;&lt;span&gt; services
                    .AddScoped&lt;/span&gt;&amp;lt;IFoobar, Foobar&amp;gt;&lt;span&gt;()
                    .AddRouting()
                    .AddControllers())
                .Configure(app &lt;/span&gt;=&amp;gt;&lt;span&gt; app
                    .UseRouting()
                    .UseEndpoints(endpoints &lt;/span&gt;=&amp;gt;&lt;span&gt; endpoints.MapControllers())))
            .Build()
            .Run();
    }
}

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IFoobar { }
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Foobar : IFoobar, IDisposable
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Dispose() =&amp;gt; Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Foobar.Dispose();&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们创建了如下这个HomeController，它的构造函数中注入了一个IServiceProvider对象。在Action方法Index中，我们调用Task的静态方法Run异步执行了一些操作。具体来说，在异步执行的操作中，我们利用调用上面注入的这个IServiceProvider对象的GetRequiredService&amp;lt;T&amp;gt;方法试图获取一个IFoobar服务实例。由于这段操作时在一个Try/Catch中执行的，抛出的异常消息的堆栈信息会直接输出到控制台上。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController: Controller
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IServiceProvider _requestServices;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HomeController(IServiceProvider requestServices)
    {
        _requestServices &lt;/span&gt;=&lt;span&gt; requestServices;
    }
    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
    {
        Task.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt;() =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foobar = _requestServices.GetRequiredService&amp;lt;IFoobar&amp;gt;&lt;span&gt;();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
            }
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在运行该应用程序后，我们利用浏览器采用根路径（“/”）对Action方法Index发起访问后，服务端控制台上会出现如下所示的错误信息。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191202085157423-933863052.png&quot;&gt;&lt;img width=&quot;900&quot; height=&quot;210&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191202085158046-1580735359.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;从上图所示的错误消息可以看出，问题出在我们试图利用一个被Dispose的IServiceProvider来获取我们所需的服务实例。我们知道，ASP.NET Core应用在启动和请求处理过程中所需的服务几乎都是由代表DI容器的IServiceProvider提供的。具体来说，这里存在着两种类型的IServiceProvider对象，一种与当前应用的生命周期保持一致，我们一般将其称为ApplicationServices，另一种则是具体针对每个请求的IServiceProvider对象，我们将其称为RequestServices。&lt;/p&gt;
&lt;p&gt;一般来说，ApplicationServices用于提供管道构建过程中所需的服务实例，具体请求处理过程中所需的服务实例一般由RequestServices提供。具体来说，对于接收的每一个请求，ASP.NET Core框架都会利用ApplicationServices创建一个代表服务范围的IServiceScope对象，后者就是对RequestServices的封装。在完成了针对请求的处理之后，服务范围被终结，RequestServices被Dispose。&lt;/p&gt;
&lt;p&gt;对于我们演示的实例来说，注入到HomeController构造函数中的IServiceProvider是RequestServices，由于针对RequestServices的使用是在另一个后台线程中执行的，并且在使用的时候针对当前请求的处理已经结束（因为我们人为等待了100毫秒），自然就会出现上图所示的异常。&lt;/p&gt;

&lt;p&gt;既然与请求绑定的RequestServices不能用，我们只能使用与应用绑定的ApplicationServices，那么后者如何得到呢？ASP.NET Core 3采用了基于IHost/IHostBuilder的承载方式，表示宿主的IHost接口具有如下所示的Services属性，它返回的正式我们所需的ApplicationServices。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; IHost : IDisposable
{
    Task StartAsync(CancellationToken cancellationToken &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationToken());
    Task StopAsync(CancellationToken cancellationToken &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CancellationToken());

    IServiceProvider Services { &lt;/span&gt;&lt;span&gt;get&lt;/span&gt;&lt;span&gt;; }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于我们演示的程序来说，我们可以采用如下的方式在HomeController的构造中注入IHost服务的方式间接地获得这个ApplicationServices对象。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController: Controller
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IServiceProvider _applicationServices;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HomeController(IHost  host)
    {
        _applicationServices &lt;/span&gt;=&lt;span&gt; host.Services;
    }
    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
    {
        Task.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt;() =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foobar = _applicationServices.GetRequiredService&amp;lt;IFoobar&amp;gt;&lt;span&gt;();
            }
            &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex)
            {
                Console.WriteLine(ex.Message);
                Console.WriteLine(ex.StackTrace);
            }
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当我们采用如上的方式将RequestServices替换成ApplicationServices之后，我们的问题是否就解决了呢？在采用上面相同的方式进行测试之后，我们会发现服务端控制台上出现了如下所示的错误消息。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191202085158544-1581357261.png&quot;&gt;&lt;img width=&quot;666&quot; height=&quot;173&quot; title=&quot;image&quot; alt=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/19327/201912/19327-20191202085158927-1889425829.png&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;上面的问题是由我们试图利用一个代表“根容器”的IServiceProvider对象去解析一个生命周期模式为Scoped服务实例导致，具体的原因在《&lt;a href=&quot;https://www.cnblogs.com/artech/p/inside-asp-net-core-03-08.html&quot;&gt;依赖注入[8]：服务实例的生命周期&lt;/a&gt;》已经讲得很清楚了。为了解决这个问题，我们应该根据ApplicationServices创建一个“服务范围”，并在该服务范围内提取我们所需的服务实例。为了确保服务实例能够被正常回收，我们还应该将代表服务范围的IServiceScope对象及时终结掉。如下所示的是正确的编程方式。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; HomeController: Controller
{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;readonly&lt;/span&gt;&lt;span&gt; IServiceProvider _applicationServices;
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; HomeController(IHost  host)
    {
        _applicationServices &lt;/span&gt;=&lt;span&gt; host.Services;
    }
    [HttpGet(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; IActionResult Index()
    {
        Task.Run(&lt;/span&gt;&lt;span&gt;async&lt;/span&gt;() =&amp;gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt; Task.Delay(&lt;span&gt;100&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;using&lt;/span&gt; (&lt;span&gt;var&lt;/span&gt; scope =&lt;span&gt; _applicationServices.CreateScope())
            {
                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; foobar = scope.ServiceProvider.GetRequiredService&amp;lt;IFoobar&amp;gt;&lt;span&gt;();
            }
        });
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; Ok();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
</description>
<pubDate>Mon, 02 Dec 2019 00:52:00 +0000</pubDate>
<dc:creator>Artech</dc:creator>
<og:description>标题反映的是上周五一个同事咨询我的问题，我觉得这是一个很好的问题。这个问题有助于我们深入理解依赖注入框架在ASP.NET Core中的应用，以及服务实例的生命周期。 一、问题重现 我们通过一个简单的实</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/artech/p/async-di.html</dc:identifier>
</item>
<item>
<title>小白学 Python 爬虫（8）：网页基础 - 极客挖掘机</title>
<link>http://www.cnblogs.com/babycomeon/p/11968707.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/babycomeon/p/11968707.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191202084520418-832443133.jpg&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;人生苦短，我用 Python&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文传送门：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/13/3303836941/&quot;&gt;小白学 Python 爬虫（1）：开篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/20/2586166930/&quot;&gt;小白学 Python 爬虫（2）：前置准备（一）基本类库的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/21/1005563697/&quot;&gt;小白学 Python 爬虫（3）：前置准备（二）Linux基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/22/3679472340/&quot;&gt;小白学 Python 爬虫（4）：前置准备（三）Docker基础入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/24/334078215/&quot;&gt;小白学 Python 爬虫（5）：前置准备（四）数据库基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/25/1881661601/&quot;&gt;小白学 Python 爬虫（6）：前置准备（五）爬虫框架的安装&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.geekdigging.com/2019/11/26/1197821400/&quot;&gt;小白学 Python 爬虫（7）：HTTP 基础&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;先赞后看是个好习惯&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;网页的组成&quot;&gt;网页的组成&lt;/h2&gt;
&lt;p&gt;我们的数据来源是网页，那么我们在真正抓取数据之前，有必要先了解一下一个网页的组成。&lt;/p&gt;
&lt;p&gt;网页是由 HTML 、 CSS 、JavaScript 组成的。&lt;/p&gt;
&lt;p&gt;HTML 是用来搭建整个网页的骨架，而 CSS 是为了让整个页面更好看，包括我们看到的颜色，每个模块的大小、位置等都是由 CSS 来控制的， JavaScript 是用来让整个网页“动起来”，这个动起来有两层意思，一层是网页的数据动态交互，还有一层是真正的动，比如我们都见过一些网页上的动画，一般都是由 JavaScript 配合 CSS 来完成的。&lt;/p&gt;
&lt;p&gt;我们打开 Chrome 浏览器，访问博客站的首页，打开 F12 开发者工具，可以看到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191202084522272-437226853.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在选项 Elements 中可以看到网页的源代码，这里展示的就是 HTML 代码。&lt;/p&gt;
&lt;p&gt;不同类型的文字通过不同类型的标签来表示，如图片用 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签表示，视频用 &lt;code&gt;&amp;lt;video&amp;gt;&lt;/code&gt; 标签表示，段落用 &lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; 标签表示，它们之间的布局又常通过布局标签 &lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt; 嵌套组合而成，各种标签通过不同的排列和嵌套才形成了网页的框架。&lt;/p&gt;
&lt;p&gt;在右边 Style 标签页中，显示的就是当前选中的 HTML 代码标签的 CSS 层叠样式，“层叠”是指当在HTML中引用了数个样式文件，并且样式发生冲突时，浏览器能依据层叠顺序处理。“样式”指网页中文字大小、颜色、元素间距、排列等格式。&lt;/p&gt;
&lt;p&gt;而 JavaScript 就厉害了，它在 HTML 代码中通常使用 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 进行包裹，可以直接书写在 HTML 页面中，也可以以文件的形式引入。&lt;/p&gt;
&lt;h2 id=&quot;网页结构&quot;&gt;网页结构&lt;/h2&gt;
&lt;p&gt;我们来手写一个简单 HTML 页面来感受下。&lt;/p&gt;
&lt;p&gt;首先创建一个文本文件，将后缀名改为 &lt;code&gt;.html&lt;/code&gt; ，名字可以自取，写入如下内容：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE  html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div id=&quot;container&quot;&amp;gt;
            &amp;lt;div class=&quot;wrapper&quot;&amp;gt;
                &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;
                &amp;lt;div&amp;gt;Hello Python.&amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先，整个文档是以 &lt;code&gt;DOCTYPE&lt;/code&gt; 来开头的，这里定义了文档类型是 &lt;code&gt;html&lt;/code&gt; ，整个文档最外层的标签是 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; ，并且结尾还以 &lt;code&gt;&amp;lt;/html&amp;gt;&lt;/code&gt; 来表示闭和。&lt;/p&gt;
&lt;p&gt;这里简单讲一下，浏览器解析 HTML 的时候，并不强制需要每个标签都一定要有闭和标签，但是为了语义明确，最好每个标签都跟上对应的闭和标签。各位同学可以尝试删除其中的闭和标签进行尝试，并不会影响浏览器的解析。&lt;/p&gt;
&lt;p&gt;整个 HTML 文档一般分为 &lt;code&gt;head&lt;/code&gt; 和 &lt;code&gt;body&lt;/code&gt; 两个部分，在 &lt;code&gt;head&lt;/code&gt; 头中，我们一般会指定当前的编码格式为 &lt;code&gt;UTF-8&lt;/code&gt; ，并且使用 &lt;code&gt;title&lt;/code&gt; 来定义网页的标题，这个会显示在浏览器的标签上面。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;body&lt;/code&gt; 中的内容一般为整个 &lt;code&gt;html&lt;/code&gt; 文档的正文，这里小编简单写了几个 &lt;code&gt;div&lt;/code&gt; 的嵌套。&lt;/p&gt;
&lt;p&gt;这个页面的显示如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191202084522624-2011426230.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;html-dom&quot;&gt;HTML DOM&lt;/h2&gt;
&lt;p&gt;在 HTML 中，所有标签定义的内容都是节点，它们构成了一个 HTML DOM 树。&lt;/p&gt;
&lt;p&gt;根据 W3C 的 HTML DOM 标准，HTML 文档中的所有内容都是节点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;整个文档是一个文档节点&lt;/li&gt;
&lt;li&gt;每个 HTML 元素是元素节点&lt;/li&gt;
&lt;li&gt;HTML 元素内的文本是文本节点&lt;/li&gt;
&lt;li&gt;每个 HTML 属性是属性节点&lt;/li&gt;
&lt;li&gt;注释是注释节点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;HTML DOM 将 HTML 文档视作树结构。这种结构被称为节点树：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191202084522777-1471664863.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过 HTML DOM，树中的所有节点均可通过 JavaScript 进行访问。所有 HTML 元素（节点）均可被修改，也可以创建或删除节点。&lt;/p&gt;
&lt;p&gt;节点树中的节点彼此拥有层级关系。&lt;/p&gt;
&lt;p&gt;父（parent）、子（child）和同胞（sibling）等术语用于描述这些关系。父节点拥有子节点。同级的子节点被称为同胞（兄弟或姐妹）。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在节点树中，顶端节点被称为根（root）&lt;/li&gt;
&lt;li&gt;每个节点都有父节点、除了根（它没有父节点）&lt;/li&gt;
&lt;li&gt;一个节点可拥有任意数量的子&lt;/li&gt;
&lt;li&gt;同胞是拥有相同父节点的节点&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面的图片展示了节点树的一部分，以及节点之间的关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191202084522920-1399309500.gif&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;css&quot;&gt;CSS&lt;/h2&gt;
&lt;p&gt;前面我们介绍到 CSS 可以用来美化网页，那么我们简单加一点 CSS 修改下页面的显示效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&quot;UTF-8&quot;&amp;gt;
        &amp;lt;title&amp;gt;Demo&amp;lt;/title&amp;gt;
        &amp;lt;style type=&quot;text/css&quot;&amp;gt;
            .wrapper {
                text-align: center;
            }
        &amp;lt;/style&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;div id=&quot;container&quot;&amp;gt;
            &amp;lt;div class=&quot;wrapper&quot;&amp;gt;
                &amp;lt;h1&amp;gt;Hello World&amp;lt;/h1&amp;gt;
                &amp;lt;div&amp;gt;Hello Python.&amp;lt;/div&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们在 head 中添加了 style 标签，并注明其中的内容解析方式为 CSS 。其中的内容的含义是让文本居中显示，先看下增加 CSS 后的页面效果吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/908359/201912/908359-20191202084523075-322266455.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到，原来居左的文字已经居中显示了。&lt;/p&gt;
&lt;p&gt;那么，CSS 是如何表示它要修饰的文档结构的呢？这就要说到 CSS 选择器了。&lt;/p&gt;
&lt;p&gt;在CSS中，我们使用CSS选择器来定位节点。例如，上例中 &lt;code&gt;div&lt;/code&gt; 节点的 &lt;code&gt;id&lt;/code&gt; 为 &lt;code&gt;container&lt;/code&gt; ，那么就可以表示为 &lt;code&gt;#container&lt;/code&gt; ，其中 &lt;code&gt;#&lt;/code&gt; 开头代表选择 &lt;code&gt;id&lt;/code&gt; ，其后紧跟 &lt;code&gt;id&lt;/code&gt; 的名称。另外，如果我们想选择 &lt;code&gt;class&lt;/code&gt; 为 &lt;code&gt;wrapper&lt;/code&gt; 的节点，便可以使用 &lt;code&gt;.wrapper&lt;/code&gt; ，这里以点 &lt;code&gt;.&lt;/code&gt; 开头代表选择 &lt;code&gt;class&lt;/code&gt; ，其后紧跟 &lt;code&gt;class&lt;/code&gt; 的名称。&lt;/p&gt;
&lt;p&gt;另外， CSS 选择器还支持嵌套选择，各个选择器之间加上空格分隔开便可以代表嵌套关系，如 &lt;code&gt;#container .wrapper p&lt;/code&gt; 则代表先选择 id 为 container 的节点，然后选中其内部的 class 为 wrapper 的节点，然后再进一步选中其内部的 p 节点。另外，如果不加空格，则代表并列关系，如 &lt;code&gt;div#container .wrapper p.text&lt;/code&gt; 代表先选择 id 为 container 的 div 节点，然后选中其内部的 class 为 wrapper 的节点，再进一步选中其内部的 class 为 text 的 p 节点。这就是 CSS 选择器，其筛选功能还是非常强大的。&lt;/p&gt;
&lt;h2 id=&quot;参考&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.w3school.com.cn/htmldom/dom_nodes.asp&quot; class=&quot;uri&quot;&gt;https://www.w3school.com.cn/htmldom/dom_nodes.asp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://cuiqingcai.com/5476.html&quot; class=&quot;uri&quot;&gt;https://cuiqingcai.com/5476.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Dec 2019 00:45:00 +0000</pubDate>
<dc:creator>极客挖掘机</dc:creator>
<og:description>人生苦短，我用 Python 前文传送门： '小白学 Python 爬虫（1）：开篇' '小白学 Python 爬虫（2）：前置准备（一）基本类库的安装' '小白学 Python 爬虫（3）：前置准备</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/babycomeon/p/11968707.html</dc:identifier>
</item>
<item>
<title>EasyCode实现数据库到Swagger全自动化 - 后青春期的Keats</title>
<link>http://www.cnblogs.com/keatsCoder/p/11968704.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/keatsCoder/p/11968704.html</guid>
<description>&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;EasyCode是基于IntelliJ IDEA开发的代码生成插件，通过自定义生成模板可以完成定制化的 Mapper Service Controller 生成，结合数据库 Comment还可以实现从数据库到 Swagger 的一键配置，非常的强大与方便，项目地址：&lt;a href=&quot;https://gitee.com/makejava/EasyCode&quot;&gt;EasyCode--码云&lt;/a&gt; 这里推荐大家使用&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;和一般的Idea插件安装方式一样，点击 File -&amp;gt; Setting -&amp;gt; Plugins 搜索 EasyCode 点击 Install 安装即可，安装之后需要重启，当然如果是Idea最新的2019.3版本支持插件热安装就不需要重启了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/201912/1654189-20191202084336312-1404730899.png&quot; alt=&quot;image-20191201215718734&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;连接数据库&quot;&gt;连接数据库&lt;/h2&gt;
&lt;p&gt;安装之后需要使用Idea连接数据库，在Idea的右侧有个DataBase选项卡，点击之后选择对应的数据库。这边我使用的是 Mysql 数据库&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/201912/1654189-20191202084335939-376599313.png&quot; alt=&quot;image-20191201215907808&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置好连接名称，连接路径，账号密码和数据库测试连接，测试通过后点击OK，就可以成功的连接到数据库，这里Idea的数据库图形化界面做的也挺好的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/201912/1654189-20191202084335623-931561202.png&quot; alt=&quot;image-20191201220127365&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;配置easycode的模板&quot;&gt;配置EasyCode的模板&lt;/h2&gt;
&lt;h3 id=&quot;配置作者名称&quot;&gt;1. 配置作者名称&lt;/h3&gt;
&lt;p&gt;同样是 File -&amp;gt; Settings -&amp;gt; other Settings 选择 EasyCode 或者直接搜索 EasyCode 进行编辑，首先键入作者名称，这样在生成的类上面就会加上你的名字，时间等信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/201912/1654189-20191202084335244-1015423195.png&quot; alt=&quot;image-20191201220618628&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;type-manager-映射类型管理&quot;&gt;2. Type Manager 映射类型管理&lt;/h3&gt;
&lt;p&gt;此页面是用来建立数据库字段类型与Java变量类型关系的，其中已经预先定义好了很多对应关系，但对于 &lt;strong&gt;tinyint((\d+))? unsigned&lt;/strong&gt; (无符号的byte)类型却没有进行预定义，如果不进行手动配置，在进行逆向生成的时候会将其映射成 Java Object 类型，所以需要我们进行手动的&lt;strong&gt;添加关联关系&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/201912/1654189-20191202084334881-1763685553.png&quot; alt=&quot;image-20191201223534232&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;template-setting-模板设置&quot;&gt;3. Template Setting 模板设置&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/201912/1654189-20191202084334484-1189467448.png&quot; alt=&quot;image-20191201221538903&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这个页面就是我们主要需要配置的页面了，我们可以自己新建一个模板组，也可以直接在原来模板文件的基础上进行修改。这里我已经对原有的模板进行了自定义的修改，保留了 entity.java mapper.java mapper.xml service.java controller.java 去掉了原有的 dao serviceImpl.具体的模板内容如下，需要的朋友可以直接复制修改。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当然也可以点击配置作者名称页面的导入模板按钮，输入对应的 Token 进行一键替换&lt;/strong&gt;由于token只能保持6个小时，所以我就不在这里贴上了。&lt;/p&gt;
&lt;h4 id=&quot;entity.java&quot;&gt;entity.java&lt;/h4&gt;
&lt;p&gt;实体类模板改动如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;删除了原本的 Getter/Setter 采用 lombok 的 @Data 注解替换之&lt;/li&gt;
&lt;li&gt;类添加 @ApiModel(&quot;$tableInfo.comment&quot;) 注解，读取 Mysql 中表的注释作为类在Swagger中的解释&lt;/li&gt;
&lt;li&gt;字段添加 @ApiModelProperty(&quot;$column.comment&quot;) 注解，读取 Mysql 中字段的注释作为对应参数在Swagger中的注释&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;xml&quot;&gt;
&lt;code&gt;##引入宏定义
$!define

##使用宏定义设置回调（保存位置与文件后缀）
#save(&quot;/entity&quot;, &quot;.java&quot;)

##使用宏定义设置包后缀
#setPackageSuffix(&quot;entity&quot;)

##使用全局变量实现默认包导入
$!autoImport
import java.io.Serializable;
import io.swagger.annotations.*;
import lombok.Data;

##使用宏定义实现类注释信息
#tableComment(&quot;实体类&quot;)
@Data
@ApiModel(&quot;$tableInfo.comment&quot;)
public class $!{tableInfo.name} implements Serializable {
    private static final long serialVersionUID = $!tool.serial();
#foreach($column in $tableInfo.fullColumn)
    #if(${column.comment})/**
    * ${column.comment}
    */#end
    
    @ApiModelProperty(&quot;$column.comment&quot;)
    private $!{tool.getClsNameByFullName($column.type)} $!{column.name};
    
#end
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mapper.java&quot;&gt;mapper.java&lt;/h4&gt;
&lt;p&gt;Mapper接口改动如下&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;添加 @Mapper @Repository 注解&lt;/li&gt;
&lt;/ol&gt;&lt;pre class=&quot;xml-dtd&quot;&gt;
&lt;code&gt;##定义初始变量
#set($tableName = $tool.append($tableInfo.name, &quot;Mapper&quot;))
##设置回调
$!callback.setFileName($tool.append($tableName, &quot;.java&quot;))
$!callback.setSavePath($tool.append($tableInfo.savePath, &quot;/mapper&quot;))

##拿到主键
#if(!$tableInfo.pkColumn.isEmpty())
    #set($pk = $tableInfo.pkColumn.get(0))
#end

#if($tableInfo.savePackageName)package $!{tableInfo.savePackageName}.#{end}mapper;

import $!{tableInfo.savePackageName}.entity.$!{tableInfo.name};
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;
import org.springframework.stereotype.Repository;
import java.util.List;

/**
 * $!{tableInfo.comment}($!{tableInfo.name})表数据库访问层
 *
 * @author $!author
 * @since $!time.currTime()
 */
@Mapper
@Repository 
public interface $!{tableName} {

    /**
     * 通过ID查询单条数据
     *
     * @param $!pk.name 主键
     * @return 实例对象
     */
    $!{tableInfo.name} queryById($!pk.shortType $!pk.name);

    /**
     * 查询指定行数据
     *
     * @param offset 查询起始位置
     * @param limit 查询条数
     * @return 对象列表
     */
    List&amp;lt;$!{tableInfo.name}&amp;gt; queryAllByLimit(@Param(&quot;offset&quot;) int offset, @Param(&quot;limit&quot;) int limit);


    /**
     * 通过实体作为筛选条件查询
     *
     * @param $!tool.firstLowerCase($!{tableInfo.name}) 实例对象
     * @return 对象列表
     */
    List&amp;lt;$!{tableInfo.name}&amp;gt; queryAll($!{tableInfo.name} $!tool.firstLowerCase($!{tableInfo.name}));

    /**
     * 新增数据
     *
     * @param $!tool.firstLowerCase($!{tableInfo.name}) 实例对象
     * @return 影响行数
     */
    int insert($!{tableInfo.name} $!tool.firstLowerCase($!{tableInfo.name}));

    /**
     * 修改数据
     *
     * @param $!tool.firstLowerCase($!{tableInfo.name}) 实例对象
     * @return 影响行数
     */
    int update($!{tableInfo.name} $!tool.firstLowerCase($!{tableInfo.name}));

    /**
     * 通过主键删除数据
     *
     * @param $!pk.name 主键
     * @return 影响行数
     */
    int deleteById($!pk.shortType $!pk.name);

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;mapper.xml&quot;&gt;mapper.xml&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;##引入mybatis支持
$!mybatisSupport

##设置保存名称与保存位置
$!callback.setFileName($tool.append($!{tableInfo.name}, &quot;Mapper.xml&quot;))
$!callback.setSavePath($tool.append($modulePath, &quot;/src/main/resources/mapper&quot;))

##拿到主键
#if(!$tableInfo.pkColumn.isEmpty())
    #set($pk = $tableInfo.pkColumn.get(0))
#end

&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&amp;gt;
&amp;lt;mapper namespace=&quot;$!{tableInfo.savePackageName}.mapper.$!{tableInfo.name}Mapper&quot;&amp;gt;

    &amp;lt;resultMap type=&quot;$!{tableInfo.savePackageName}.entity.$!{tableInfo.name}&quot; id=&quot;$!{tableInfo.name}Map&quot;&amp;gt;
#foreach($column in $tableInfo.fullColumn)
        &amp;lt;result property=&quot;$!column.name&quot; column=&quot;$!column.obj.name&quot; jdbcType=&quot;$!column.ext.jdbcType&quot;/&amp;gt;
#end
    &amp;lt;/resultMap&amp;gt;

    &amp;lt;!--查询单个--&amp;gt;
    &amp;lt;select id=&quot;queryById&quot; resultMap=&quot;$!{tableInfo.name}Map&quot;&amp;gt;
        select
          #allSqlColumn()

        from $!{tableInfo.obj.parent.name}.$!tableInfo.obj.name
        where $!pk.obj.name = #{$!pk.name}
    &amp;lt;/select&amp;gt;

    &amp;lt;!--查询指定行数据--&amp;gt;
    &amp;lt;select id=&quot;queryAllByLimit&quot; resultMap=&quot;$!{tableInfo.name}Map&quot;&amp;gt;
        select
          #allSqlColumn()

        from $!{tableInfo.obj.parent.name}.$!tableInfo.obj.name
        limit #{offset}, #{limit}
    &amp;lt;/select&amp;gt;

    &amp;lt;!--通过实体作为筛选条件查询--&amp;gt;
    &amp;lt;select id=&quot;queryAll&quot; resultMap=&quot;$!{tableInfo.name}Map&quot;&amp;gt;
        select
          #allSqlColumn()

        from $!{tableInfo.obj.parent.name}.$!tableInfo.obj.name
        &amp;lt;where&amp;gt;
#foreach($column in $tableInfo.fullColumn)
            &amp;lt;if test=&quot;$!column.name != null#if($column.type.equals(&quot;java.lang.String&quot;)) and $!column.name != ''#end&quot;&amp;gt;
                and $!column.obj.name = #{$!column.name}
            &amp;lt;/if&amp;gt;
#end
        &amp;lt;/where&amp;gt;
    &amp;lt;/select&amp;gt;

    &amp;lt;!--新增所有列--&amp;gt;
    &amp;lt;insert id=&quot;insert&quot; keyProperty=&quot;$!pk.name&quot; useGeneratedKeys=&quot;true&quot;&amp;gt;
        insert into $!{tableInfo.obj.parent.name}.$!{tableInfo.obj.name}(#foreach($column in $tableInfo.otherColumn)$!column.obj.name#if($velocityHasNext), #end#end)
        values (#foreach($column in $tableInfo.otherColumn)#{$!{column.name}}#if($velocityHasNext), #end#end)
    &amp;lt;/insert&amp;gt;

    &amp;lt;!--通过主键修改数据--&amp;gt;
    &amp;lt;update id=&quot;update&quot;&amp;gt;
        update $!{tableInfo.obj.parent.name}.$!{tableInfo.obj.name}
        &amp;lt;set&amp;gt;
#foreach($column in $tableInfo.otherColumn)
            &amp;lt;if test=&quot;$!column.name != null#if($column.type.equals(&quot;java.lang.String&quot;)) and $!column.name != ''#end&quot;&amp;gt;
                $!column.obj.name = #{$!column.name},
            &amp;lt;/if&amp;gt;
#end
        &amp;lt;/set&amp;gt;
        where $!pk.obj.name = #{$!pk.name}
    &amp;lt;/update&amp;gt;

    &amp;lt;!--通过主键删除--&amp;gt;
    &amp;lt;delete id=&quot;deleteById&quot;&amp;gt;
        delete from $!{tableInfo.obj.parent.name}.$!{tableInfo.obj.name} where $!pk.obj.name = #{$!pk.name}
    &amp;lt;/delete&amp;gt;

&amp;lt;/mapper&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;service.java&quot;&gt;service.java&lt;/h4&gt;
&lt;p&gt;服务方法改动如下，这里我省略了 service 接口，而直接生成实现类。如果习惯于接口+实现类的使用方法可以保留接口和实现类，将@Servcie注解添加到接口上， Controller中继续注入接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;##定义初始变量
#set($tableName = $tool.append($tableInfo.name, &quot;Service&quot;))
##设置回调
$!callback.setFileName($tool.append($tableName, &quot;.java&quot;))
$!callback.setSavePath($tool.append($tableInfo.savePath, &quot;/service&quot;))

##拿到主键
#if(!$tableInfo.pkColumn.isEmpty())
    #set($pk = $tableInfo.pkColumn.get(0))
#end

#if($tableInfo.savePackageName)package $!{tableInfo.savePackageName}.#{end}service;

import $!{tableInfo.savePackageName}.entity.$!{tableInfo.name};
import $!{tableInfo.savePackageName}.mapper.$!{tableInfo.name}Mapper;
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;
import java.util.List;

/**
 * $!{tableInfo.comment}($!{tableInfo.name})表服务实现类
 *
 * @author $!author
 * @since $!time.currTime()
 */
@Service(&quot;$!tool.firstLowerCase($!{tableInfo.name})Service&quot;)
public class $!{tableName} {
    @Autowired
    private $!{tableInfo.name}Mapper $!tool.firstLowerCase($!{tableInfo.name})Mapper;

    /**
     * 通过ID查询单条数据
     *
     * @param $!pk.name 主键
     * @return 实例对象
     */
    public $!{tableInfo.name} queryById($!pk.shortType $!pk.name) {
        return this.$!{tool.firstLowerCase($!{tableInfo.name})}Mapper.queryById($!pk.name);
    }

    /**
     * 查询多条数据
     *
     * @param offset 查询起始位置
     * @param limit 查询条数
     * @return 对象列表
     */
    public List&amp;lt;$!{tableInfo.name}&amp;gt; queryAllByLimit(int offset, int limit) {
        return this.$!{tool.firstLowerCase($!{tableInfo.name})}Mapper.queryAllByLimit(offset, limit);
    }

    /**
     * 新增数据
     *
     * @param $!tool.firstLowerCase($!{tableInfo.name}) 实例对象
     * @return 实例对象
     */
    public $!{tableInfo.name} insert($!{tableInfo.name} $!tool.firstLowerCase($!{tableInfo.name})) {
        this.$!{tool.firstLowerCase($!{tableInfo.name})}Mapper.insert($!tool.firstLowerCase($!{tableInfo.name}));
        return $!tool.firstLowerCase($!{tableInfo.name});
    }

    /**
     * 修改数据
     *
     * @param $!tool.firstLowerCase($!{tableInfo.name}) 实例对象
     * @return 实例对象
     */
    public $!{tableInfo.name} update($!{tableInfo.name} $!tool.firstLowerCase($!{tableInfo.name})) {
        this.$!{tool.firstLowerCase($!{tableInfo.name})}Mapper.update($!tool.firstLowerCase($!{tableInfo.name}));
        return this.queryById($!{tool.firstLowerCase($!{tableInfo.name})}.get$!tool.firstUpperCase($pk.name)());
    }

    /**
     * 通过主键删除数据
     *
     * @param $!pk.name 主键
     * @return 是否成功
     */
    public boolean deleteById($!pk.shortType $!pk.name) {
        return this.$!{tool.firstLowerCase($!{tableInfo.name})}Mapper.deleteById($!pk.name) &amp;gt; 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;controller.java&quot;&gt;controller.java&lt;/h4&gt;
&lt;p&gt;控制层主要做了如下改动，&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;类上添加 @Api(tags = &quot;$!{tableInfo.comment}($!{tableInfo.name})&quot;) 以在 Swagger 中显示表注释&lt;/li&gt;
&lt;li&gt;selectOne 方法添加 @ApiOperation(value = &quot;根据id查询 $!{tableInfo.comment}&quot;)&lt;/li&gt;
&lt;li&gt;修改接口为 RestFul 格式调用，并添加对应的注解&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code&gt;##定义初始变量
#set($tableName = $tool.append($tableInfo.name, &quot;Controller&quot;))
##设置回调
$!callback.setFileName($tool.append($tableName, &quot;.java&quot;))
$!callback.setSavePath($tool.append($tableInfo.savePath, &quot;/controller&quot;))
##拿到主键
#if(!$tableInfo.pkColumn.isEmpty())
    #set($pk = $tableInfo.pkColumn.get(0))
#end

#if($tableInfo.savePackageName)package $!{tableInfo.savePackageName}.#{end}controller;

import $!{tableInfo.savePackageName}.entity.$!{tableInfo.name};
import $!{tableInfo.savePackageName}.service.$!{tableInfo.name}Service;
import org.springframework.web.bind.annotation.*;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import io.swagger.annotations.ApiParam;
import org.springframework.beans.factory.annotation.Autowired;

/**
 * $!{tableInfo.comment}($!{tableInfo.name})表控制层
 *
 * @author $!author
 * @since $!time.currTime()
 */
@Api(tags = &quot;$!{tableInfo.comment}($!{tableInfo.name})&quot;) 
@RestController
@RequestMapping(&quot;$!tool.firstLowerCase($tableInfo.name)&quot;)
public class $!{tableName} {
    /**
     * 服务对象
     */
    @Autowired
    private $!{tableInfo.name}Service $!tool.firstLowerCase($tableInfo.name)Service;

    /**
     * 通过主键查询单条数据
     *
     * @param id 主键
     * @return 单条数据
     */
    @ApiOperation(value = &quot;根据id查询 $!{tableInfo.comment}&quot;)
    @GetMapping(&quot;selectOne/{id}&quot;)
    public $!{tableInfo.name} selectOne(@ApiParam(value = &quot;$!pk.comment ID&quot;) @PathVariable(&quot;id&quot;) $!pk.shortType id) {
        return this.$!{tool.firstLowerCase($tableInfo.name)}Service.queryById(id);
    }

}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;说明&quot;&gt;说明&lt;/h4&gt;
&lt;p&gt;说明文档：&lt;br/&gt;属性&lt;br/&gt;$author 设置中的作者 java.lang.String&lt;br/&gt;$encode 设置的编码 java.lang.String&lt;br/&gt;$modulePath 选中的module路径 java.lang.String&lt;br/&gt;$projectPath 项目绝对路径 java.lang.String&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;对象
$tableInfo 表对象
    obj 表原始对象 com.intellij.database.model.DasTable
    name 表名（转换后的首字母大写）java.lang.String
    comment 表注释 java.lang.String
    fullColumn 所有列 java.util.List&amp;lt;ColumnInfo&amp;gt;
    pkColumn 主键列 java.util.List&amp;lt;ColumnInfo&amp;gt;
    otherColumn 其他列 java.util.List&amp;lt;ColumnInfo&amp;gt;,除主键以外的列
    savePackageName 保存的包名 java.lang.String
    savePath 保存路径 java.lang.String
    saveModelName 保存的model名称 java.lang.String
columnInfo 列对象
    obj 列原始对象 com.intellij.database.model.DasColumn
    name 列名（首字母小写） java.lang.String
    comment 列注释 java.lang.String
    type 列类型（类型全名） java.lang.String
    shortType 列类型（短类型） java.lang.String
    custom 是否附加列 java.lang.Boolean
    ext 附加字段（Map类型） java.lang.Map&amp;lt;java.lang.String, java.lang.Object&amp;gt;
$tableInfoList java.util.List&amp;lt;TableInfo&amp;gt;所有选中的表
$importList 所有需要导入的包集合 java.util.Set&amp;lt;java.lang.String&amp;gt;

回调
&amp;amp;callback        setFileName(String) 设置文件储存名字
    setSavePath(String) 设置文件储存路径，默认使用选中路径

工具
$tool
    firstUpperCase(String name) 首字母大写方法
    firstLowerCase(String name) 首字母小写方法
    getClsNameByFullName(String fullName) 通过包全名获取类名
    getJavaName(String name) 将下划线分割字符串转驼峰命名(属性名)
    getClassName(String name) 将下划线分割字符串转驼峰命名(类名)
    append(Object... objs) 多个数据进行拼接
    newHashSet(Object... objs) 创建一个HashSet对象
    newArrayList(Object... objs) 创建一个ArrayList对象
    newLinkedHashMap() 创建一个LinkedHashMap()对象
    newHashMap() 创建一个HashMap()对象
    getField(Object obj, String fieldName) 获取对象的属性值,可以访问任意修饰符修饰的属性.配合debug方法使用.
    call(Object... objs) 空白执行方法,用于调用某些方法时消除返回值
    debug(Object obj) 调式方法,用于查询对象结构.可查看对象所有属性与public方法
    serial() 随机获取序列化的UID
    service(String serviceName, Object... param)远程服务调用
    parseJson(String) 将字符串转Map对象
    toJson(Object, Boolean) 将对象转json对象，Boolean：是否格式化json，不填时为不格式化。
$time
    currTime(String format) 获取当前时间，指定时间格式（默认：yyyy-MM-dd HH:mm:ss）
$generateService
    run(String, Map&amp;lt;String,Object&amp;gt;) 代码生成服务，参数1：模板名称，参数2：附加参数。&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;一键生成&quot;&gt;4. 一键生成&lt;/h3&gt;
&lt;p&gt;点击Idea右边的DataBase选项卡，选择刚刚连接的数据库，选好对应的表格，点击右键选择 EasyCode -&amp;gt; Generate Code, 如果出现下面的提示，就复制类型后面的字段，到第2步进行配置&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/201912/1654189-20191202084334140-787287147.png&quot; alt=&quot;image-20191201224527473&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置完成后重新点击 Generate Code 会出现如下的配置框，选好路径后点击OK，就会生成对应的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/201912/1654189-20191202084333867-1064064968.png&quot; alt=&quot;image-20191201224658375&quot;/&gt;&lt;/p&gt;
&lt;p&gt;之后启动项目，访问Swagger路径就可以看到对应的配置已经完全自动化生成。这样我们只需要在创建表的时候对字段进行注释，就可以实现 Entity中和前后端交互时的自动化注释。非常方便&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1654189/201912/1654189-20191202084333284-698647549.png&quot; alt=&quot;image-20191201225214326&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我是 Keats @后青春期的Keats ，一个热爱技术的程序员，鉴于技术有限，如果本文有什么纰漏或者兄台还有其他更好的建议/实现方式，欢迎留言评论，谢谢您！&lt;/p&gt;
</description>
<pubDate>Mon, 02 Dec 2019 00:44:00 +0000</pubDate>
<dc:creator>后青春期的Keats</dc:creator>
<og:description>﻿ 简介 EasyCode是基于IntelliJ IDEA开发的代码生成插件，通过自定义生成模板可以完成定制化的 Mapper Service Controller 生成，结合数据库 Comment还</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/keatsCoder/p/11968704.html</dc:identifier>
</item>
<item>
<title>基于 HTML5 WebGL + VR 的 3D 机房数据中心可视化 - xhload3d</title>
<link>http://www.cnblogs.com/xhload3d/p/11968673.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/xhload3d/p/11968673.html</guid>
<description>&lt;p&gt;&lt;strong&gt;前言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 3D 机房数据中心可视化应用中，随着视频监控联网系统的不断普及和发展, 网络摄像机更多的应用于监控系统中，尤其是高清时代的来临，更加快了网络摄像机的发展和应用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180820020234801-137915723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在监控摄像机数量的不断庞大的同时，在监控系统中面临着严峻的现状问题：海量视频分散、孤立、视角不完整、位置不明确等问题，始终围绕着使用者。因此，如何更直观、更明确的管理摄像机和掌控视频动态，已成为提升视频应用价值的重要话题。所以当前项目正是从解决此现状问题的角度，应运而生。围绕如何提高、管理和有效利用前端设备采集的海量信息为公共安全服务，特别是在技术融合大趋势下，如何结合当前先进的视频融合，虚实融合、三维动态等技术，实现三维场景实时动态可视化监控，更有效的识别、分析、挖掘海量数据的有效信息服务公共应用，已成为视频监控平台可视化发展的趋势和方向。目前，在监控行业中，海康、大华等做监控行业领导者可基于这样的方式规划公共场所园区等的摄像头规划安放布局，可以通过海康、大华等摄像头品牌的摄像头参数，调整系统中摄像头模型的可视范围，监控方向等，更方便的让人们直观的了解摄像头的监控区域，监控角度等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180820020257928-452162414.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是项目地址：&lt;a href=&quot;http://www.hightopo.com/demo/Camera/index.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;基于 HTML5 的 WebGL 自定义 3D 摄像头监控模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;效果预览&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;整体场景-摄像头效果图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074129353-858216626.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;局部场景-摄像头效果图&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074159610-98573873.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;代码生成&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;摄像头模型及场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;项目中使用的摄像头模型是通过 3dMax 建模生成的，该建模工具可以导出 obj 与 mtl 文件，在 HT 中可以通过解析 obj 与 mtl 文件来生成 3d 场景中的摄像头模型。&lt;/p&gt;
&lt;p&gt;项目中场景通过 HT 的 3d 编辑器进行搭建，场景中的模型有些是通过 HT 建模，有些通过 3dMax 建模，之后导入 HT 中，场景中的地面白色的灯光，是通过 HT 的 3d 编辑器进行地面贴图呈现出来的效果。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;锥体建模&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;3D 模型是由最基础的三角形面拼接合成，例如 1 个矩形可以由 2 个三角形构成，1 个立方体由 6 个面即 12 个三角形构成， 以此类推更复杂的模型可以由许多的小三角形组合合成。因此 3D 模型定义即为对构造模型的所有三角形的描述， 而每个三角形由三个顶点 vertex 构成， 每个顶点 vertex 由 x, y, z 三维空间坐标决定，HT 采用右手螺旋定则来确定三个顶点构造三角形面的正面。&lt;/p&gt;
&lt;p&gt;HT 中通过 &lt;strong&gt;ht.Default.setShape3dModel(name, model)&lt;/strong&gt; 函数，可注册自定义 3D 模型，摄像头前方生成的锥体便是通过该方法生成。可以将该锥体看成由 5 个顶点，6 个三角形组成，具体图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074221681-1867969782.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;ht.Default.setShape3dModel(name, model)&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;1. &lt;strong&gt;name&lt;/strong&gt; 为模型名称，如果名称与预定义的一样，则会替换预定义的模型 &lt;br/&gt;2. &lt;strong&gt;model&lt;/strong&gt; 为JSON类型对象，其中 &lt;em&gt;&lt;strong&gt;vs&lt;/strong&gt;&lt;/em&gt; 表示顶点坐标数组，&lt;em&gt;&lt;strong&gt;is&lt;/strong&gt;&lt;/em&gt; 表示索引数组，&lt;em&gt;&lt;strong&gt;uv&lt;/strong&gt;&lt;/em&gt; 表示贴图坐标数组，如果想要单独定义某个面，可以通过 &lt;em&gt;&lt;strong&gt;bottom_vs，bottom_is，bottom_uv，top_vs，top_is， top_uv&lt;/strong&gt; &lt;/em&gt;等来定义，之后便可以通过&lt;em&gt;&lt;strong&gt; shape3d.top.*， shape3d.bottom.*&lt;/strong&gt;&lt;/em&gt;  等单独控制某个面&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是我定义模型的代码:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;79&quot;&gt;&lt;pre&gt;
// camera 是当前的摄像头图元
// fovy 为摄像头的张角的一半的 tan 值
var setRangeModel = function(camera, fovy) {
    var fovyVal = 0.5 * fovy;
    var pointArr = [0, 0, 0, -fovyVal, fovyVal, 0.5, fovyVal, fovyVal, 0.5, fovyVal, -fovyVal, 0.5, -fovyVal, -fovyVal, 0.5];
    ht.Default.setShape3dModel(camera.getTag(), [{
        vs: pointArr,
        is: [2, 1, 0, 4, 1, 0, 4, 3, 0, 3, 2, 0],
        from_vs: pointArr.slice(3, 15),
        from_is: [3, 1, 0, 3, 2, 1],
        from_uv: [0, 0, 1, 0, 1, 1, 0, 1]
    }]);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我将当前摄像头的 tag 标签值作为模型的名称，tag 标签在 HT 中用于唯一标识一个图元，用户可以自定义 tag 的值。通过 pointArr 记录当前五面体的五个顶点坐标信息，代码中通过 from_vs, from_is, from_uv 单独构建五面体底面，底面用于显示当前摄像头呈现的图像。&lt;/p&gt;
&lt;p&gt;代码中设置了锥体 style 对象的 &lt;strong&gt;wf.geometry&lt;/strong&gt; 属性，通过该属性可以为锥体添加模型的线框，增强模型的立体效果，并且通过&lt;strong&gt; wf.color，wf.width&lt;/strong&gt; 等参数调节线框的颜色，粗细等。&lt;/p&gt;
&lt;p&gt;相关模型 style 属性的设置代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;&lt;pre&gt;
 1 rangeNode.s({
 2     'shape3d': cameraName,
 3     // 摄像头模型名称
 4     'shape3d.color': 'rgba(52, 148, 252, 0.3)',
 5     // 锥体模型颜色
 6     'shape3d.reverse.flip': true,
 7     // 锥体模型的反面是否显示正面的内容
 8     'shape3d.light': false,
 9     // 锥体模型是否受光线影响
10     'shape3d.transparent': true,
11     // 锥体模型是否透明
12     '3d.movable': false,
13     // 锥体模型是否可移动
14     'wf.geometry': true // 是否显示锥体模型线框
15 });
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;摄像头图像生成原理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;透视投影&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;透视投影是为了获得接近真实三维物体的视觉效果而在二维的纸或者画布平面上绘图或者渲染的一种方法，它也称为透视图。 透视使得远的对象变小，近的对象变大，平行线会出现先交等更更接近人眼观察的视觉效果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074233279-699657637.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，透视投影最终显示到屏幕上的内容只有截头锥体( View Frustum )部分的内容， 因此 Graph3dView 提供了 eye, center, up, far，near，fovy 和 aspect 参数来控制截头锥体的具体范围。具体的透视投影可以参考 &lt;strong&gt;HT for Web&lt;/strong&gt; 的 &lt;a href=&quot;https://hightopo.com/guide/guide/core/3d/ht-3d-guide.html&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;3D&lt;/a&gt; 手册。&lt;/p&gt;
&lt;p&gt;根据上图的描述，在本项目中可以在摄像头初始化之后，缓存当前 3d 场景 eyes 眼睛的位置，以及 center 中心的位置，之后将 3d 场景 eyes 眼睛和 center 中心设置成摄像头中心点的位置，然后在这个时刻获取当前 3d 场景的截图，该截图即为当前摄像头的监控图像，之后再将 3d 场景的 center 与 eyes 设置成开始时缓存的 eyes 与 center 位置，通过该方法即可实现 3d 场景中任意位置的快照，从而实现摄像头监控图像实时生成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关伪代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;&lt;pre&gt;
 1 function getFrontImg(camera, rangeNode) {
 2     var oldEye = g3d.getEye();
 3     var oldCenter = g3d.getCenter();
 4     var oldFovy = g3d.getFovy();
 5     g3d.setEye(摄像头位置);
 6     g3d.setCenter(摄像头朝向);
 7     g3d.setFovy(摄像头张角);
 8     g3d.setAspect(摄像头宽高比);
 9     g3d.validateImp();
10     g3d.toDataURL();
11     g3d.setEye(oldEye);;
12     g3d.setCenter(oldCenter);
13     g3d.setFovy(oldFovy);
14     g3d.setAspect(undefined);
15     g3d.validateImp();
16 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;经过测试之后，通过该方法进行图像的获取会导致页面有所卡顿，因为是获取当前 3d 场景的整体截图，由于当前3d场景是比较大的，所以 toDataURL 获取图像信息是非常慢的，因此我采取了离屏的方式来获取图像，具体方式如下：&lt;br/&gt;   1. 创建一个新的 3d 场景，将当前场景的宽度与高度都设置为 200px 的大小，并且当前 3d 场景的内容与主屏的场景是一样的，HT中通过 new ht.graph3d.Graph3dView(dataModel) 来新建场景，其中的 dataModel 为当前场景的所有图元，所以主屏与离屏的 3d 场景都共用同一个 dataModel，保证了场景的一致。&lt;br/&gt;   2. 将新创建的场景位置设置成屏幕看不到的地方，并且添加进 dom 中。&lt;br/&gt;   3. 将之前对主屏获取图像的操作变成对离屏获取图像的操作，此时离屏图像的大小相对之前主屏获取图像的大小小很多，并且离屏获取不需要保存原来的眼睛 eyes 的位置以及 center 中心的位置，因为我们没有改变主屏的 eyes 与 center 的位置， 所以也减少的切换带来的开销，大大提高了摄像头获取图像的速度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下是该方法实现的代码：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;51&quot;&gt;&lt;pre&gt;
 1 function getFrontImg(camera, rangeNode) {
 2     // 截取当前图像时将该摄像头所属的五面体隐藏
 3     rangeNode.s('shape3d.from.visible', false);
 4     rangeNode.s('shape3d.visible', false);
 5     rangeNode.s('wf.geometry', false);
 6     var cameraP3 = camera.p3();
 7     var cameraR3 = camera.r3();
 8     var cameraS3 = camera.s3();
 9     var updateScreen = function() {
10         demoUtil.Canvas2dRender(camera, outScreenG3d.getCanvas());
11         rangeNode.s({
12             'shape3d.from.image': camera.a('canvas')
13         });
14         rangeNode.s('shape3d.from.visible', true);
15         rangeNode.s('shape3d.visible', true);
16         rangeNode.s('wf.geometry', true);
17     };
18 
19     // 当前锥体起始位置
20     var realP3 = [cameraP3[0], cameraP3[1] + cameraS3[1] / 2, cameraP3[2] + cameraS3[2] / 2];
21     // 将当前眼睛位置绕着摄像头起始位置旋转得到正确眼睛位置
22     var realEye = demoUtil.getCenter(cameraP3, realP3, cameraR3);
23 
24     outScreenG3d.setEye(realEye);
25     outScreenG3d.setCenter(demoUtil.getCenter(realEye, [realEye[0], realEye[1], realEye[2] + 5], cameraR3));
26     outScreenG3d.setFovy(camera.a('fovy'));
27     outScreenG3d.validate();
28     updateScreen();
29 }
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;上面代码中有一个 getCenter 方法是用于获取 3d 场景中点 A 绕着点 B 旋转 angle 角度之后得到的点 A 在 3d 场景中的位置，方法中采用了 HT 封装的 ht.Math 下面的方法，以下为代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
 1 // pointA 为 pointB 围绕的旋转点
 2 // pointB 为需要旋转的点
 3 // r3 为旋转的角度数组 [xAngle, yAngle, zAngle] 为绕着 x, y, z 轴分别旋转的角度 
 4 var getCenter = function(pointA, pointB, r3) {
 5     var mtrx = new ht.Math.Matrix4();
 6     var euler = new ht.Math.Euler();
 7     var v1 = new ht.Math.Vector3();
 8     var v2 = new ht.Math.Vector3();
 9 
10     mtrx.makeRotationFromEuler(euler.set(r3[0], r3[1], r3[2]));
11 
12     v1.fromArray(pointB).sub(v2.fromArray(pointA));
13     v2.copy(v1).applyMatrix4(mtrx);
14     v2.sub(v1);
15 
16     return [pointB[0] + v2.x, pointB[1] + v2.y, pointB[2] + v2.z];
17 };
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里应用到向量的部分知识，具体如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OA + OB = OC&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074251110-1058475078.jpg&quot; alt=&quot;&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法分为以下几个步骤求解：&lt;/p&gt;
&lt;p&gt;   1.  &lt;strong&gt;var mtrx = new ht.Math.Matrix4()&lt;/strong&gt; 创建一个转换矩阵，通过 &lt;strong&gt;mtrx.makeRotationFromEuler(euler.set(r3[0], r3[1], r3[2]))&lt;/strong&gt; 获取绕着 r3[0]，r3[1]，r3[2] 即 x 轴，y 轴，z 轴旋转的旋转矩阵。&lt;br/&gt;   2. 通过&lt;strong&gt; new ht.Math.Vector3()&lt;/strong&gt; 创建 v1，v2 两个向量。&lt;br/&gt;   3.&lt;strong&gt; v1.fromArray(pointB)&lt;/strong&gt; 为建立一个从原点到 pointB 的一个向量。&lt;br/&gt;   4. &lt;strong&gt;v2.fromArray(pointA)&lt;/strong&gt; 为建立一个从原点到 pointA 的一个向量。&lt;br/&gt;   5. &lt;strong&gt;v1.fromArray(pointB).sub(v2.fromArray(pointA))&lt;/strong&gt; 即向量 OB - OA 此时得到的向量为 AB，此时 v1 变为向量 AB。&lt;br/&gt;   6. &lt;strong&gt;v2.copy(v1)&lt;/strong&gt; v2 向量拷贝 v1 向量，之后通过 &lt;strong&gt;v2.copy(v1).applyMatrix4(mtrx)&lt;/strong&gt; 对 v2 向量应用旋转矩阵，变换之后即为 v1向量绕着 pointA 旋转之后的的向量 v2。&lt;br/&gt;   7. 此时通过 &lt;strong&gt;v2.sub(v1)&lt;/strong&gt; 就获取了起始点为 pointB，终点为 pointB 旋转之后点构成的向量，该向量此时即为 v2。&lt;br/&gt;   8. 通过向量公式得到旋转之后的点为 [pointB[0] + v2.x, pointB[1] + v2.y, pointB[2] + v2.z]。&lt;/p&gt;
&lt;p&gt;项目中的 3D 场景例子其实是 &lt;a href=&quot;http://www.hightopo.com/&quot; target=&quot;_blank&quot;&gt;Hightopo&lt;/a&gt; 最近贵州数博会，HT 上工业互联网展台的 VR 示例，大众对 VR/AR 的期待很高，但路还是得一步步走，即使融资了 23 亿美金的 Magic Leap 的第一款产品也只能是 &lt;a href=&quot;https://mp.weixin.qq.com/s/Z-gcPasf6E4OdNbqBwBhFA&quot; target=&quot;_blank&quot;&gt;Full of Shit&lt;/a&gt;，这话题以后再展开，这里就上段当时现场的视频照片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074306832-325606716.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2d 图像贴到 3d 模型&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过上一步的介绍我们可以获取当前摄像机位置的截屏图像，那么如何将当前图像贴到前面所构建的五面体底部呢？前面通过 from_vs, from_is 来构建底部的长方形，所以在 HT 中可以通过将五面体的 style 中 shape3d.from.image 属性设置成当前图像，其中 from_uv 数组用来定义贴图的位置，具体如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074323039-360588324.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;em id=&quot;__mceDel&quot;&gt;&lt;strong&gt;以下为定义贴图位置 from_uv 的代码：&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;1 from_uv: [0, 0, 1, 0, 1, 1, 0, 1] &lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;from_uv 就是定义贴图的位置数组，根据上图的解释，可以将 2d 图像贴到 3d 模型的 from 面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制面板&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HT 中通过 &lt;strong&gt;new ht.widget.Panel()&lt;/strong&gt; 来生成如下图的面板：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074334164-1462206036.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;面板中每个摄像头都有一个模块来呈现当前监控图像，其实这个地方也是一个 canvas，该 canvas 与场景中锥体前面的监控图像是同一个 canvas，每一个摄像头都有一个自己的 canvas 用来保存当前摄像头的实时监控画面，这样就可以将该 canvas 贴到任何地方，将该 canvas 添加进面板的代码如下：&lt;/p&gt;
&lt;p&gt; &lt;span class=&quot;cnblogs_code&quot;&gt;1 formPane.addRow([{ 2 element: camera.a('canvas') 3 }], 240, 240); &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码中将 canvas 节点存储在摄像头图元的 attr 属性下面，之后便可以通过&lt;strong&gt; camera.a('canvas')&lt;/strong&gt; 来获取当前摄像头的画面。&lt;/p&gt;
&lt;p&gt;在面板中的每一个控制节点都是通过&lt;strong&gt; formPane.addRow&lt;/strong&gt; 来进行添加，具体可参考 HT for Web 的&lt;a href=&quot;http://www.hightopo.com/guide/guide/plugin/form/ht-form-guide.html&quot; target=&quot;_blank&quot;&gt;表单手册&lt;/a&gt;。之后通过 ht.widget.Panel 将表单面板 formPane 添加进 panel 面板中，具体可参考 HT for Web 的&lt;a href=&quot;http://www.hightopo.com/guide/guide/plugin/panel/ht-panel-guide.html&quot; target=&quot;_blank&quot;&gt;面板手册&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;部分控制代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;&lt;pre&gt;
 1 formPane.addRow(['rotateY', {
 2     slider: {
 3         min: -Math.PI,
 4         max: Math.PI,
 5         value: r3[1],
 6         onValueChanged: function() {
 7             var cameraR3 = camera.r3();
 8             camera.r3([cameraR3[0], this.getValue(), cameraR3[2]]);
 9             rangeNode.r3([cameraR3[0], this.getValue(), cameraR3[2]]);
10             getFrontImg(camera, rangeNode);
11         }
12     }
13 }], [0.1, 0.15]);
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;控制面板通过 &lt;strong&gt;addRow&lt;/strong&gt; 来添加控制元素，以上代码为添加摄像头绕着 y 轴进行旋转的控制，&lt;strong&gt;onValueChanged&lt;/strong&gt; 在 slider 的数值改变的时候调用，此时通过&lt;strong&gt; camera.r3()&lt;/strong&gt; 获取当前摄像头的旋转参数， 由于是绕着 y 轴旋转所以 x 轴与 z 轴的角度是不变的，变的是 y 轴的旋转角度，所以通过&lt;strong&gt; camera.r3([cameraR3[0], this.getValue(), cameraR3[2]])&lt;/strong&gt; 来调整摄像头的旋转角度以及通过 &lt;strong&gt;rangeNode.r3([cameraR3[0], this.getValue(), cameraR3[2]])&lt;/strong&gt; 来设置摄像头前方锥体的旋转角度，然后调用之前封装好的 &lt;strong&gt;getFrontImg&lt;/strong&gt; 函数来获取此时旋转角度下面的实时图像信息。&lt;/p&gt;
&lt;p&gt;项目中通过 Panel 面板的配置参数 &lt;strong&gt;titleBackground: rgba(230, 230, 230, 0.4) &lt;/strong&gt;即可将标题背景设置为具有透明度的背景，其它类似的 titleColor, titleHeight 等标题参数都可以配置，通过 separatorColor,separatorWidth 等分割参数可以设置内部面板之间分割线的颜色，宽度等。最后面板通过&lt;strong&gt; panel.setPositionRelativeTo('rightTop')&lt;/strong&gt; 将面板的位置设置成右上角，并且通过 &lt;strong&gt;document.body.appendChild(panel.getView())&lt;/strong&gt; 将面板最外层的 div 添加进页面中， &lt;strong&gt;panel.getView()&lt;/strong&gt; 用来获取面板的最外层 dom 节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;具体初始化面板代码如下：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;70&quot;&gt;1 function initPanel() {
&lt;pre&gt;
 2     var panel = new ht.widget.Panel();
 3     var config = {
 4         title: &quot;摄像头控制面板&quot;,
 5         titleBackground: 'rgba(230, 230, 230, 0.4)',
 6         titleColor: 'rgb(0, 0, 0)',
 7         titleHeight: 30,
 8         separatorColor: 'rgb(67, 175, 241)',
 9         separatorWidth: 1,
10         exclusive: true,
11         items: []
12     };
13     cameraArr.forEach(function(data, num) {
14         var camera = data['camera'];
15         var rangeNode = data['rangeNode'];
16         var formPane = new ht.widget.FormPane();
17         initFormPane(formPane, camera, rangeNode);
18         config.items.push({
19             title: &quot;摄像头&quot; + (num + 1),
20             titleBackground: 'rgba(230, 230, 230, 0.4)',
21             titleColor: 'rgb(0, 0, 0)',
22             titleHeight: 30,
23             separatorColor: 'rgb(67, 175, 241)',
24             separatorWidth: 1,
25             content: formPane,
26             flowLayout: true,
27             contentHeight: 400,
28             width: 250,
29             expanded: num === 0
30         });
31     });
32     panel.setConfig(config);
33     panel.setPositionRelativeTo('rightTop');
34     document.body.appendChild(panel.getView());
35     window.addEventListener(&quot;resize&quot;,
36     function() {
37         panel.invalidate();
38     });
39 }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在控制面板中可以调整摄像头的方向，摄像头监控的辐射范围，摄像头前方锥体的长度等等，并且摄像头的图像是实时生成，以下为运行截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074359161-1813880965.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以下是本项目采用的 3D 场景结合 HT for Web 的 VR 技术实现的操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://images2018.cnblogs.com/blog/591709/201808/591709-20180813074423850-451548743.gif&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Dec 2019 00:29:00 +0000</pubDate>
<dc:creator>xhload3d</dc:creator>
<og:description>前言 在 3D 机房数据中心可视化应用中，随着视频监控联网系统的不断普及和发展, 网络摄像机更多的应用于监控系统中，尤其是高清时代的来临，更加快了网络摄像机的发展和应用。 在监控摄像机数量的不断庞大的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/xhload3d/p/11968673.html</dc:identifier>
</item>
<item>
<title>迈进java初中级程序员分水岭是否合格？十个题告诉你！ - 宜春</title>
<link>http://www.cnblogs.com/yichunguo/p/11968660.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yichunguo/p/11968660.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;不论你是职场新人还是步入职场N年的职场新人大哥大~当然这个N&amp;lt;3~,我能担保你答不对这十个题~不要问我为什么这么自信~，这些个题还是“有水平”的&lt;code&gt;javase&lt;/code&gt;的基础题，传闻小白指定鸭蛋分，一测一个准，哈哈。&lt;/p&gt;
&lt;p&gt;作为将来要成为架构师的男人，对，你没看错，就是在说你 ~皮一下很开森~ ，what？你是小白？我顶你个肺，我叫声杠精，你敢应吗，那个代号9527的杠精，说你呢快快来答题，看你能答对几道题。&lt;/p&gt;
&lt;h4 id=&quot;题一&quot;&gt;题一&lt;/h4&gt;
&lt;p&gt;下面的程序有问题吗？如果有问题说明一下， 如果没有问题猜测一下运行结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public static void main(String[] args){ 
    short s = 1;
     s=s+1; 
    System.out.println(s); 
} &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps : 各位兄嘚都是大孩子了，各位都把自己的结果记在个小本本上再看下面的分析答案~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分析： &lt;code&gt;s = s + 1&lt;/code&gt; 计算结果被提升为&lt;code&gt;int&lt;/code&gt;类型，再向&lt;code&gt;short&lt;/code&gt;类型赋值时发生错误，因为不能将取值范围 大的类型赋值到取值范围小的类型，所以这个程序会报错编译失败。&lt;/p&gt;
&lt;h4 id=&quot;题二&quot;&gt;题二&lt;/h4&gt;
&lt;p&gt;下面的程序有问题吗？如果有问题说明一下， 如果没有问题猜测一下运行结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public static void main(String[] args){ 
    short s = 1;
     s+=1; 
    System.out.println(s); 
} &lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps : 各位兄嘚都是大孩子了，各位都把自己的结果记在个小本本上再看下面的分析答案~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分析： &lt;code&gt;s += 1&lt;/code&gt; 逻辑上看作是 &lt;code&gt;s = s + 1&lt;/code&gt; 计算结果被提升为int类型，再向&lt;code&gt;short&lt;/code&gt;类型赋值时发生错误，因为不能将取值范围 大的类型赋值到取值范围小的类型。但是， &lt;code&gt;s=s+1&lt;/code&gt;进行两次运算 ， &lt;code&gt;+=&lt;/code&gt; 是一个运算符，&lt;strong&gt;只运算一次&lt;/strong&gt;，并带有&lt;strong&gt;强制转换&lt;/strong&gt;的特点， 也就是说 &lt;code&gt;s += 1&lt;/code&gt; 就是 &lt;code&gt;s = (short)(s + 1)&lt;/code&gt; ，因此程序没有问题编译通过，运行结果是&lt;code&gt;2&lt;/code&gt;.&lt;/p&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;到这里，两个都错了的自觉点给楼主文章右上角点个赞，鸭！恭喜获得第&lt;code&gt;N+1&lt;/code&gt;个准确无疑的天真小白荣誉勋章，千万别嫌弃，就像侠岚风语咒里说的：只要心怀正义，侠岚无处不在！所以我只想表达的是，天真小白荣誉勋章也是勋章。hhhhhh, ~哎哎哎，别打...别打...别打脸.~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;题三&quot;&gt;题三&lt;/h4&gt;
&lt;p&gt;下面的程序有问题吗？如果有问题说明一下， 如果没有问题猜测一下运行结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public static void main(String[] args){ 
        byte b1=1; 
        byte b2=2; 
        byte b3=1 + 2; 
        byte b4=b2 + b3; 
        System.out.println(b3); 
        System.out.println(b4); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps : 各位兄嘚都是大孩子了，各位都把自己的结果记在个小本本上再看下面的分析答案~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分析： &lt;code&gt;b3 = 1 + 2&lt;/code&gt; ， 1 和 2 是常量，为固定不变的数据，在编译的时候（编译器&lt;code&gt;javac&lt;/code&gt;），已经确定了 &lt;code&gt;1+2&lt;/code&gt; 的结果并没 有超过&lt;code&gt;byte&lt;/code&gt;类型的取值范围，可以赋值给变量 b3 ，因此 &lt;code&gt;b3=1 + 2&lt;/code&gt; 是正确的。 反之， &lt;code&gt;b4 = b2 + b3&lt;/code&gt; ， b2 和 b3 是变量，变量的值是可能变化的，在编译的时候，编译器&lt;code&gt;javac&lt;/code&gt;不确定&lt;code&gt;b2+b3&lt;/code&gt;的结果是什 么，因此会将结果以&lt;code&gt;int&lt;/code&gt;类型进行处理，所以&lt;code&gt;int&lt;/code&gt;类型不能赋值给&lt;code&gt;byte&lt;/code&gt;类型，因此编译失败。&lt;/p&gt;
&lt;h4 id=&quot;题四&quot;&gt;题四&lt;/h4&gt;
&lt;p&gt;下面的程序有问题吗？如果有问题说明一下， 如果没有问题猜测一下运行结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public static void main(String[] args){ 
      short s = 32767;
      s = (short)(s + 10);

      System.out.println(s); 
}&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps : 各位兄嘚都是大孩子了，各位都把自己的结果记在个小本本上再看下面的分析答案~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分析：定义s为&lt;code&gt;short&lt;/code&gt;范围内最大值 &lt;code&gt;(2^15) - 1 = 32767&lt;/code&gt;，运算后，强制转换（&lt;code&gt;int&lt;/code&gt;换为&lt;code&gt;short&lt;/code&gt;），砍掉2个字节后会出现不确定的结果，因为这个值以及超出了&lt;code&gt;short&lt;/code&gt;类型数据的范围，从而变成负数结果&lt;code&gt;-32759&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;到这里，四个题都错了的自觉点给楼主文章右上角点个赞，还有小白同学千万别灰心，想当年楼主刚学java的时候，在腾讯课堂听课直播的是时候，那个老师出的就是这些类型题，我一直答错，那个老师提了楼主我好几次：这位小白同学又是你，你又答错了...不提了，往事不堪回首。所以，小白同学千万别灰心哦~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;题五&quot;&gt;题五&lt;/h4&gt;
&lt;p&gt;下面的程序有问题吗？如果有问题说明一下， 如果没有问题猜测一下运行结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
      
     int a=0;
     for (int i = 0; i &amp;gt;= a &amp;amp;&amp;amp; i&amp;lt;100 ; i++){
         a+=i;
     }
        System.out.println(a);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps : 各位兄嘚都是大孩子了，各位都把自己的结果记在个小本本上再看下面的分析答案~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分析：这个稍微没有任何细节以及“套路”，只是单纯的掺杂着些逻辑，所以段个点&lt;code&gt;debug&lt;/code&gt;吧，感受一下吧，结果是6&lt;/p&gt;
&lt;h4 id=&quot;题六&quot;&gt;题六&lt;/h4&gt;
&lt;p&gt;下面的程序有问题吗？如果有问题说明一下， 如果没有问题猜测一下运行结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
      
        int  x=4;
        System.out.println(&quot;value  is  &quot; + ((x&amp;gt;4) ? 99.9 : 9));

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析：这个题我估计&lt;code&gt;99%&lt;/code&gt;的会错 ~包括我自己~ ，如果我没猜错的话你的结果是&lt;code&gt;9&lt;/code&gt;，啥？你的结果是&lt;code&gt;99.9&lt;/code&gt;，额这个，如果这位同学你不是杠精那我建议你回家种田吧，我和你一起，你锄地我耕田...呃呃呃那结果是什么呢，结果居然是&lt;code&gt;9.0&lt;/code&gt; 。。。至于原因我还是不断定的哈哈没有仔细去专研过，如果必须要个结果我估计java把9这个整数默认当成浮点类型数据，我当然只是推论，那么知道的大佬就请评论出来吧。&lt;/p&gt;
&lt;h4 id=&quot;题七&quot;&gt;题七&lt;/h4&gt;
&lt;p&gt;下面的程序有问题吗？如果有问题说明一下， 如果没有问题猜测一下运行结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; public static void main(String[] args) {
 //对于下面两句代码是否编译出错，很基础的哦
          double d=3.10;
          float f=3.10; 
//对于下面两句代码是否编译出错,以及打印结果是多少
        float a = 12345678.90123456789f;
        double b=0.12345678901234567890;
        float c=0.12345678901234567890f;
     
        System.out.println(a);
        System.out.println(b);
        System.out.println(c);

    }&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;ps : 各位兄嘚都是大孩子了，各位都把自己的结果记在个小本本上再看下面的分析答案~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分析：&lt;code&gt;3.10&lt;/code&gt;是浮点型，浮点型字面值默认当做&lt;code&gt;double&lt;/code&gt;类型来处理，直接编译通过；如果是&lt;code&gt;float&lt;/code&gt;类型则必须加 &lt;code&gt;F&lt;/code&gt;或者&lt;code&gt;f&lt;/code&gt;，若没加，直接编译不通过，会报错“&lt;strong&gt;损失精度&lt;/strong&gt;”，至于解决方法也很简单， 第一种方式：强制类型转换&lt;code&gt;float f1=（float）3.10&lt;/code&gt;； 第二种方式：没有类型转换直接加&lt;code&gt;F&lt;/code&gt;或者&lt;code&gt;f&lt;/code&gt;，&lt;code&gt;如 folat f2=3.10f&lt;/code&gt; ；对于abc的打印结果&lt;code&gt;a = 1.2345679E7&lt;/code&gt;、&lt;code&gt;b = 0.12345678901234568&lt;/code&gt;、&lt;code&gt;c = 0.12345679&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果还不懂java浮点类型&lt;code&gt;float&lt;/code&gt;以及&lt;code&gt;double&lt;/code&gt;，可以参考这篇文章&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/101982298&quot;&gt;什么是浮点型？什么是单精度浮点数（float）以及双精度浮点数（double）？&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;题八&quot;&gt;题八&lt;/h4&gt;
&lt;p&gt;分析下列程序代码，猜想下输出结果。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt; public static void main(String[] args) { 
     int a = 1; int b = 2; 
     System.out.println(a); 
     System.out.println(b); 
     change(a, b); 
     System.out.println(a); 
     System.out.println(b); 
     }
     public static void change(int a, int b) { 
     a = a + b; b = b + a; 
 } &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析下列程序代码，猜想下输出结果。&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;public static void main(String[] args) { 
    int[] arr = {1,3,5}; 
    System.out.println(arr[0]); 
    change(arr); 
    System.out.println(arr[0]); 
}
    
    public static void change(int[] arr) {
    arr[0] = 200; 
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这个题就不分析了，主要是考察数组的，答错的童靴可能对数组了解的不是特别清析，可以参考这篇文章 &lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102099067&quot;&gt;java数组定义、使用、以及数组内存分析详解&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&quot;题九&quot;&gt;题九&lt;/h4&gt;
&lt;p&gt;运行结果是怎样的呢？&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;  public static void main(String[] args) {
       
        int i = 1, j = ++i;
        System.out.println(i);
        System.out.println(j);
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析：估计各位会觉得&lt;code&gt;i=1，j=2&lt;/code&gt;，噗哈哈，你还太单纯了，啥？你的答案是&lt;code&gt;i=1，j=1&lt;/code&gt;？回家种田吧兄嘚我陪你。那么结果是什么呢？&lt;code&gt;i=2，j=2&lt;/code&gt;，原因也很简单，i其实是个&lt;strong&gt;变量&lt;/strong&gt;，j也是个&lt;strong&gt;变量&lt;/strong&gt;，之前i值是1，之后j经历了&lt;code&gt;++i&lt;/code&gt;，就这个经历的同时，i已经自增&lt;code&gt;++&lt;/code&gt;了，所以也是2.&lt;/p&gt;
&lt;p&gt;到这里，九个题错了一半以上的同学自觉点给楼主文章右上角点个赞，千万别灰心，就像侠岚风语咒里说的：只要心怀正义，侠岚无处不在！所以还要继续加油哇！向架构师道路冲鸭！！！&lt;/p&gt;
&lt;h4 id=&quot;题十&quot;&gt;题十&lt;/h4&gt;
&lt;p&gt;这个题主要考察多态知识，涉及到向上转型和向下转型的概念，所以是比较偏难的！&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;package Polymorphic;
//爷爷类
class Ye {
    public String show(Sun obj) {
        return (&quot;Ye and Sun&quot;);
    }

    public String show(Ye obj) {
        return (&quot;Ye and Ye&quot;);
    }

}
//爸爸类
class Fu extends Ye {
    public String show(Fu obj) {
        return (&quot;Fu and Fu&quot;);
    }

    public String show(Ye obj) {
        return (&quot;Fu and Ye&quot;);
    }
}
//儿子类
class Zi extends Fu {

}
//孙子类
class Sun extends Fu {

}

public class PolymorphicTest {
    public static void main(String[] args) {
         Ye y = new Ye();
        Ye y2 = new Fu(); //向上
        Fu f = new Fu();
        Zi z = new Zi();
        Sun s = new Sun();


        System.out.println(&quot;第一题 &quot; + y.show(f));
        System.out.println(&quot;第二题 &quot; + y.show(z));
        System.out.println(&quot;第三题 &quot; + y.show(s));
        System.out.println(&quot;第四题 &quot; + y2.show(f));  //到这里挂了？？？
        System.out.println(&quot;第五题 &quot; + y2.show(z));
        System.out.println(&quot;第六题 &quot; + y2.show(s));
        System.out.println(&quot;第七题 &quot; + f.show(f));
        System.out.println(&quot;第八题 &quot; + f.show(z));
        System.out.println(&quot;第九题 &quot; + f.show(s));
     
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果&lt;/p&gt;
&lt;pre class=&quot;javascript&quot;&gt;
&lt;code&gt;第一题 Ye and Ye
第二题 Ye and Ye
第三题 Ye and Sun
第四题 Fu and Ye
第五题 Fu and Ye
第六题 Ye and Sun
第七题 Fu and Fu
第八题 Fu and Fu
第九题 Ye and Sun&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析的话就涉及到太多知识点了，比如多态的金典向上向下转型，这都是必备的重点基础的基础，建议参考这篇文章【蓝色字体，点击进入】&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qq_44543508/article/details/102409146&quot;&gt;【java基础之多态】理解多态的向上向下转型从“妈妈我想吃烤山药”讲起&lt;/a&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;到这里有木有全部正确的大哥大捏，如果有，我代表全体鸭蛋分的小白膜拜下大佬~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;最后已每题一分计算你得多少分勇敢说出来尽管笑死楼主&quot;&gt;最后，已每题一分计算，你得多少分？勇敢说出来，尽管笑死楼主&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;如果本文对你有一点点帮助，那么请点个赞呗，谢谢~&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;strong&gt;最后，若有不足或者不正之处，欢迎指正批评，感激不尽！如果有疑问欢迎留言，绝对第一时间回复！&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;欢迎各位关注我的公众号，一起探讨技术，向往技术，追求技术，说好了来了就是盆友喔...&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2019112519430061.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0NTQzNTA4,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Dec 2019 00:19:00 +0000</pubDate>
<dc:creator>宜春</dc:creator>
<og:description>前言 不论你是职场新人还是步入职场N年的职场新人大哥大~当然这个N ps : 各位兄嘚都是大孩子了，各位都把自己的结果记在个小本本上再看下面的分析答案~ 分析： 计算结果被提升为 类型，再向 类型赋值</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yichunguo/p/11968660.html</dc:identifier>
</item>
<item>
<title>【python测试开发栈】—python内存管理机制（二）—垃圾回收 - 布道师玄柯</title>
<link>http://www.cnblogs.com/zhouliweiblog/p/11968650.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhouliweiblog/p/11968650.html</guid>
<description>&lt;p&gt;在上一篇文章中(&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=MzIzODU5ODUxMA==&amp;amp;mid=2247483780&amp;amp;idx=1&amp;amp;sn=09d56bfa180b527a76d163be227eac11&amp;amp;chksm=e937a185de402893254a0b8954ae32153772e1c0a5ae6fc11bed7466e4c3b98b29d3d4e15282&amp;amp;token=2009673061&amp;amp;lang=zh_CN#rd&quot;&gt;python 内存管理机制—引用计数&lt;/a&gt;)中，我们介绍了python内存管理机制中的引用计数，python正是通过它来有效的管理内存。今天来介绍python的垃圾回收，其主要策略是&lt;strong&gt;引用计数&lt;/strong&gt;为主，&lt;strong&gt;标记-清除&lt;/strong&gt;和&lt;strong&gt;分代回收&lt;/strong&gt;为辅助的策略（熟悉java的同学回回忆下，其实这和JVM的策略是有类似之处的）。&lt;/p&gt;
&lt;h2 id=&quot;引用计数垃圾回收&quot;&gt;引用计数垃圾回收&lt;/h2&gt;
&lt;p&gt;我们还接着上一篇文章来接着介绍引用计数的相关场景，方便我们来理解python如何通过引用计数来进行垃圾回收。其实通过字面意思，我们应该也不难理解，当一个对象的引用计数变为0时，表示没有对象再使用这个对象，相当于这个对象变成了无用的&quot;垃圾&quot;，当python解释器扫描到这个对象时就可以将其回收掉。&lt;/p&gt;
&lt;p&gt;我们通过一些例子来看下，可以使python对象的引用计数增加或减少的场景：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;# coding=utf-8
&quot;&quot;&quot;
~~~~~~~~~~~~~~~~~
 @Author：xuanke
 @contact: 784876810@qq.com
 @date: 2019-11-29 19:52
 @function: 验证引用计数增加和减少的场景
&quot;&quot;&quot;
import sys

def ref_method(str):
    print(sys.getrefcount(str))
    print(&quot;我调用了{}&quot;.format(str))
    print('方法执行完了')

def ref_count():
    # 引用计数增加的场景
    print('测试引用计数增加')
    a = 'ABC'
    print(sys.getrefcount(a))
    b = a
    print(sys.getrefcount(a))
    ref_method(a)
    print(sys.getrefcount(a))
    c = [1, a, 'abc']
    print(sys.getrefcount(a))

    # 引用计数减少的场景
    print('测试引用计数减少')
    del b
    print(sys.getrefcount(a))
    c.remove(a)
    print(sys.getrefcount(a))
    del c
    print(sys.getrefcount(a))
    a = 783
    print(sys.getrefcount(a))

if __name__ == '__main__':
    ref_count()
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果如下：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;测试引用计数增加
7
8
10
我调用了ABC
方法执行完了
8
9
测试引用计数减少
8
7
7
4&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;从上面的结果我们得出以下结论：&lt;/p&gt;
&lt;h3 id=&quot;引用计数增加的场景&quot;&gt;引用计数增加的场景：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;对象被创建并赋值给某个变量，比如： a = 'ABC'&lt;/li&gt;
&lt;li&gt;变量间的相互引用（相当于变量指向了同一个对象），比如：b=a&lt;/li&gt;
&lt;li&gt;变量作为参数传到函数中。比如：ref_method(a)，其实上一篇文章，我们也提过调用getrefcount会使引用计数增加。&lt;/li&gt;
&lt;li&gt;将对象放到某个容器对象中(列表、元组、字典)。比如：c = [1, a, 'abc']&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;引用计数减少的场景&quot;&gt;引用计数减少的场景：&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;当一个变量离开了作用域，比如：函数执行完成时，上面的运行结果中，不知道大家发现没，执行方法前后的引用计数保持不变，这就是因为方法执行完后，对象的引用计数也会减少，如果在方法内打印，则能看到引用计数增加的效果。&lt;/li&gt;
&lt;li&gt;对象的引用变量被销毁时，比如del a 或者 del b。注意如果del a，再去获取a的引用计数会直接报错。&lt;/li&gt;
&lt;li&gt;对象被从容器对象中移除，比如：c.remove(a)&lt;/li&gt;
&lt;li&gt;直接将整个容器销毁，比如： del c&lt;/li&gt;
&lt;li&gt;对象的引用被赋值给其他对象，相当于变量不指向之前的对象，而是指向了一个新的对象，这种情况，引用计数肯定会发生改变。(排除两个对象默认引用计一致的场景)。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;引用计数虽然可以实时的知道某个对象是否可以被回收，但是也有两个缺点：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;需要额外的空间维护引用计数。&lt;/li&gt;
&lt;li&gt;遇到有&lt;strong&gt;循环引用&lt;/strong&gt;的对象，无法有效处理。所谓循环引用就是比如：对象A引用了对象B，而对象B又引用了对象A，造成它们两个引用计数都不能减少到0 ，因此不能被回收。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;标记-回收垃圾回收&quot;&gt;标记-回收垃圾回收&lt;/h2&gt;
&lt;p&gt;为了解决引用计数法无法解决的循环引用问题，python采用了标记-回收垃圾回收算法，它的整个过程分为两步：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;标记：&lt;/strong&gt; 遍历所有的对象，如果是&lt;strong&gt;可达的&lt;/strong&gt;（reachable），也就是还有对象正引用它，那么就标记该对象为可达；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;清除：&lt;/strong&gt; 再次遍历所有的对象，如果某个对象没有被标记为&lt;strong&gt;可达&lt;/strong&gt;，则将其回收掉。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;需要注意的是在python中可以产生循环引用问题的可能是：列表、字典、用户自定义类的对象、元组等对象，而对于数字字符串这种简单的数据类型，并不会产生循环引用，因此后者并不在标记清除算法的考虑之列。&lt;/p&gt;
&lt;p&gt;针对标记-回收垃圾回收的过程，我从网上找了几张图片，方便大家来了解整个过程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/367944/201912/367944-20191202080446544-365356347.png&quot; alt=&quot;1.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第一张图是初始状态，图片上不仅有ref_count，还有一个gc_ref的值，这个gc_ref其实就是为了来解决引用计数问题的，它是ref_count的一个副本，所以它的初始值和ref_count保持一致。当开始遍历所有对象时，当发现link1引用了link2对象时，会将link2的gc_ref值减少1，如此类推，就得到下图的结果。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/367944/201912/367944-20191202080446876-1475638193.png&quot; alt=&quot;2.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;第二张图中我们看到link2、link3、link4的gc_ref都已经为0，当python垃圾回收器再次扫描所有对象时，那么它们就会被标记为GC_TENTATIVELY_UNREACHABLE，同时被移到Unreachable列表中。有同学可能会疑惑为啥link2没有被移到Unreachable列表中，其实它理论上也应该被移到Unreachable列表中，如第三张图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/367944/201912/367944-20191202080447143-484262231.png&quot; alt=&quot;3.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果python垃圾回收器再次扫描对象时，发现某个对象的ref_count不为0，那么就会将其标记为GC_REACHABLE，表示还正在被引用着，如下图所示的link1就是这种情况。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/367944/201912/367944-20191202080447351-618644657.png&quot; alt=&quot;4.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;除了将link1标记为可达的之外，python垃圾回收器，还会从当前可达节点依次遍历所有可达的节点，比如从link1可以到达link2和link3，但link3已经被放到Unreachable列表中，因此还需要将link3再移回到Object to Scan列表中，表示对象还是可以触达的。最终的结果如下图所示，只有link4会被回收掉：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/367944/201912/367944-20191202080447550-1164824317.png&quot; alt=&quot;5.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;标记-清除法虽然可以解决循环引用的问题，但是缺点也比较明显，就是需要python垃圾回收器对python对象执行两遍扫描，而每次扫描，python解释器就会暂停处理其他事情，等到扫描结束后才能恢复正常。这个过程就好比：图书管理员要对图书馆进行清洁整理，那么将会关闭图书馆，直到收拾干净后才能重新打开图书馆，供同学们使用。&lt;/p&gt;
&lt;h2 id=&quot;分代垃圾回收&quot;&gt;分代垃圾回收&lt;/h2&gt;
&lt;p&gt;那既然在python垃圾回收过程中，会暂停整个应用程序，有没有更好的优化方案呢？答案是肯定的。在python解释器中，对象的存活时间是不一样的：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;长时间存活（或一直存活）的对象，它们是内存垃圾的可能性低，可以减少对它们扫描的次数。&lt;/li&gt;
&lt;li&gt;临时或短时间存活的对象，这种对象比较容易成为内存垃圾，所以得频繁扫描。&lt;/li&gt;
&lt;li&gt;位于前两种情况的之间的对象。可根据情况进行内存扫描。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样区分对象后，就可以节省每次扫描的时间(不需要所有对象都扫描)，重而能提升垃圾回收的速度。&lt;/p&gt;
&lt;p&gt;python中结合着上面列出的三种类型的对象分了三个对象代（0，1，2），它们其实对应了3个链表：每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation one,在这一个对象代扫描次数将会减少；如果它又活过了一轮gc,它又将被移至generation two，在这一个对象代对象扫描次数将会更少。&lt;/p&gt;
&lt;h2 id=&quot;python触发垃圾回收扫码的时机&quot;&gt;python触发垃圾回收扫码的时机&lt;/h2&gt;
&lt;p&gt;python解释器只会在触发某个条件时，才会去执行垃圾回收。这个条件就是当python分配对象的次数和取消分配对象的次数(引用计数变为0)做差值高于某个阈值，我们可以通过python提供的方法来查看这个阈值。&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def threshold_gc():
    # 获取阈值
    print(gc.get_threshold())
    # 可设置阈值
    gc.set_threshold(800, 10, 10)
    print(gc.get_threshold())

# 运行结果
(700, 10, 10)  
(800, 10, 10)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面程序运行结果中值的含义如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;700是垃圾回收启动的阈值。&lt;/li&gt;
&lt;li&gt;后面两个10与分代回收有关（上面介绍过python分了三个对象代：0、1、2），第一个10表示每进行10次0代对象扫描，则进行1次1代对象扫描。&lt;/li&gt;
&lt;li&gt;最后一个10表示每进行10次1代对象扫描，则执行1次2代对象扫描。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;此外可以自己根据情况，调用set_threshold()方法来调整垃圾回收的频率。比如：set_threshold(700,10,5)，相当于增加了对2代对象的扫描频率。&lt;/p&gt;
&lt;p&gt;gc这个库中还有一些很好玩的函数，大家可以了解下（更多方法可以参考官方文档）：&lt;/p&gt;
&lt;pre class=&quot;python&quot;&gt;
&lt;code&gt;def gc_method():
    # 启动垃圾回收
    gc.enable()
    # 停用垃圾回收
    gc.disable()
    # 手动指定垃圾回收，参数可以指定垃圾回收的代数，不填写参数就是完全的垃圾回收
    gc.collect()
    # 设置垃圾回收的标志，多用于内存泄漏的检测
    gc.set_debug(gc.DEBUG_LEAK)
    # 返回一个对象的引用列表
    gc.get_referrers()&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;额外补充-python内存分层结构&quot;&gt;额外补充-python内存分层结构&lt;/h2&gt;
&lt;p&gt;在python中，内存管理机制被抽象成分层次的结构，从python解释器Cpython的源码obmallic.c的注释中抓取了对内存分层的描述：&lt;/p&gt;
&lt;pre class=&quot;c&quot;&gt;
&lt;code&gt;/*
    Object-specific allocators
    _____   ______   ______       ________
   [ int ] [ dict ] [ list ] ... [ string ]       Python core         |
+3 | &amp;lt;----- Object-specific memory -----&amp;gt; | &amp;lt;-- Non-object memory --&amp;gt; |
    _______________________________       |                           |
   [   Python's object allocator   ]      |                           |
+2 | ####### Object memory ####### | &amp;lt;------ Internal buffers ------&amp;gt; |
    ______________________________________________________________    |
   [          Python's raw memory allocator (PyMem_ API)          ]   |
+1 | &amp;lt;----- Python memory (under PyMem manager's control) ------&amp;gt; |   |
    __________________________________________________________________
   [    Underlying general-purpose allocator (ex: C library malloc)   ]
 0 | &amp;lt;------ Virtual memory allocated for the python process -------&amp;gt; |
   =========================================================================
    _______________________________________________________________________
   [                OS-specific Virtual Memory Manager (VMM)               ]
-1 | &amp;lt;--- Kernel dynamic storage allocation &amp;amp; management (page-based) ---&amp;gt; |
    __________________________________   __________________________________
   [                                  ] [                                  ]
-2 | &amp;lt;-- Physical memory: ROM/RAM --&amp;gt; | | &amp;lt;-- Secondary storage (swap) --&amp;gt; |

*/&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;第-2层是物理内存层。&lt;/li&gt;
&lt;li&gt;第-1层是操作系统虚拟的内存管理器。&lt;/li&gt;
&lt;li&gt;第0层是C中的malloc、free等内存分配和释放相关的层。当申请的内存大于256K时，会调用第0层的malloc分配内存。&lt;/li&gt;
&lt;li&gt;第1层和第2层是python级别的内存分配器（内存池），当申请的内存小于256K时，会由这两层来进行处理。这两层存在3个级别的内存结构：arena&amp;gt;pool&amp;gt;block，其中arena大小固定是256K，pool的固定大小是4K，而block的大小是8的整数倍，用来满足最小分配需求。&lt;/li&gt;
&lt;li&gt;第3层是python对象内存分配器，也就是我们通常所用的python对象，比如：列表和字典、元组等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;python的内存这么分层设计，最根本的目的还是为了提高python的执行性能，因为如果不分层，频繁的调用malloc和free，非常的耗费系统资源，会产生性能问题。而分层之后，第1层和第2层充当了内存池的作用，根据分配的内存大小不同，交给不同的层去处理，减少了频繁的调用malloc。&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;本文介绍了python中垃圾回收的三种方式，以及python内存的分层管理方式，属于比较深层次的python知识，不过相信也可以帮助你了解python的内存管理方式。如果在之后找工作过程中再被面试官问道&quot;python垃圾回收机制&quot;这样的问题，假如你能将文中的内容讲出来绝对是加分项。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/367944/201912/367944-20191202080448008-1127034090.jpg&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Mon, 02 Dec 2019 00:05:00 +0000</pubDate>
<dc:creator>布道师玄柯</dc:creator>
<og:description>在上一篇文章中( 'python 内存管理机制—引用计数' )中，我们介绍了python内存管理机制中的引用计数，python正是通过它来有效的管理内存。今天来介绍python的垃圾回收，其主要策略是</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhouliweiblog/p/11968650.html</dc:identifier>
</item>
<item>
<title>EntityFramework Core 3.0查询 - Jeffcky</title>
<link>http://www.cnblogs.com/CreateMyself/p/11968440.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/CreateMyself/p/11968440.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;随着.NET Core 3.0的发布，EF Core 3.0也随之正式发布，关于这一块最近一段时间也没太多去关注，陆续会去对比之前版本有什么变化没有，本节我们来看下两个查询。&lt;/p&gt;
&lt;h2&gt;分组&lt;/h2&gt;
&lt;p&gt;我们知道在EF Core 3.0版本之前，对于分组查询是在客户端评估，也就是说在内存中操作，在EF Core 3.0版本后对于分组查询可以翻译成SQL在数据库进行，但是事实情况真的是这样吗？接下来我们来看下吧，如下给出代码例子。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; EFCoreDbContext : DbContext
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; EFCoreDbContext()
        {

        }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Blog&amp;gt; Blogs { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; DbSet&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;protected&lt;/span&gt; &lt;span&gt;override&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        &lt;/span&gt;=&amp;gt; optionsBuilder.UseSqlServer(&lt;span&gt;@&quot;&lt;/span&gt;&lt;span&gt;Server=.;Database=EFTest;Trusted_Connection=True;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Blog
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Name { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; List&amp;lt;Post&amp;gt; Posts { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Post
    {
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; Id { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; BlogId { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Content { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Blog Blog { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;&lt;span&gt;; }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来我们在控制台进行如下查询：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; posts = context.Posts.GroupBy(d =&amp;gt;&lt;span&gt; d.BlogId)
                .Select(g &lt;/span&gt;=&amp;gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; 
                {
                    id &lt;/span&gt;=&lt;span&gt; g.Key,
                    count &lt;/span&gt;=&lt;span&gt; g.Count()
                })
                .ToList();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上述我们查询每一篇博客的文章数组，我们通过SQL Profiler跟踪到上述示例代码最终翻译成的SQL如我们所期望的那样，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201912/589642-20191202000108318-1394288826.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;假设现在有这样一个场景：查询所有博客发表的第一篇博客文章。基于这种场景我们需要对发表博客文章进行分组，然后取第一篇，所以接下来我们进行如下查询：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; posts = context.Posts.GroupBy(d =&amp;gt;&lt;span&gt; d.BlogId)
                .Select(g &lt;/span&gt;=&amp;gt;&lt;span&gt; g.FirstOrDefault())
                .ToList();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201912/589642-20191202002629339-1611258391.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;既然这样无法翻译，根据官方文档可以使用Linq to Object进行查询《&lt;a href=&quot;https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-3.0/&quot;&gt;https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-3.0/&lt;/a&gt;》 ，那么我们就修改成如下代码查询看看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; posts = context.Posts.GroupBy(d =&amp;gt;&lt;span&gt; d.BlogId).AsEnumerable()
                .Select(d &lt;/span&gt;=&amp;gt;&lt;span&gt; d.FirstOrDefault())
                .ToList();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201912/589642-20191202003344437-26341235.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;咋客户端都无法支持了呢？我们只是想查询所有博客列表中第一篇文章，按照我们的理解，理论上是可以进行翻译的对不对，比如翻译成如下直接写的SQL语句：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;SELECT&lt;/span&gt;&lt;span&gt; 
    Id,BlogId,Title,Content 
&lt;/span&gt;&lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; (
  &lt;/span&gt;&lt;span&gt;SELECT&lt;/span&gt; &lt;span&gt;*&lt;/span&gt;&lt;span&gt;
      ,ROW_NUMBER() &lt;/span&gt;&lt;span&gt;OVER&lt;/span&gt;&lt;span&gt; (
                     PARTITION &lt;/span&gt;&lt;span&gt;BY&lt;/span&gt;&lt;span&gt; BlogId 
                     &lt;/span&gt;&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt;&lt;span&gt; Id
                ) &lt;/span&gt;&lt;span&gt;AS&lt;/span&gt; &lt;span&gt;[&lt;/span&gt;&lt;span&gt;ROW NUMBER&lt;/span&gt;&lt;span&gt;]&lt;/span&gt;
  &lt;span&gt;FROM&lt;/span&gt;&lt;span&gt; dbo.Posts
  ) groups
&lt;/span&gt;&lt;span&gt;WHERE&lt;/span&gt; groups.&lt;span&gt;[&lt;/span&gt;&lt;span&gt;ROW NUMBER&lt;/span&gt;&lt;span&gt;]&lt;/span&gt; &lt;span&gt;=&lt;/span&gt; &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;ORDER&lt;/span&gt; &lt;span&gt;BY&lt;/span&gt; groups.Id &lt;span&gt;DESC&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;所以到这里我们大概可以猜测出EF Core对分组查询支持的并不是那么好，目前应该只支持简单的分组求和而已，稍微复杂一点则无法翻译，所以我们还是老老实实将分组还是完全放在客户端评估吧，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; posts = context.Posts.ToList().GroupBy(d =&amp;gt;&lt;span&gt; d.BlogId)
                .Select(d &lt;/span&gt;=&amp;gt;&lt;span&gt; d.FirstOrDefault())
                .ToList();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201912/589642-20191202005226811-1346170738.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
&lt;h2&gt;查找&lt;/h2&gt;
&lt;p&gt;我们可以通过 &lt;span class=&quot;cnblogs_code&quot;&gt;EF.Functions.Like&lt;/span&gt; 来进行模糊查询，我们可以通过StartWith或EndWith来查询开头或结尾的数据，要是现在需要查询出博客文章标题中包含某一字符的文章列表，我们又该如何查询呢？我们想到通过IndexOf来查询，接下来我们来看看：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; posts = context.Posts.Where(d =&amp;gt; d.Title.IndexOf(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;) == &lt;span&gt;2&lt;/span&gt;).ToList();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201912/589642-20191202010227433-442920027.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;难道我们又只能将所有查询出来，然后在内存中操作吗？代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; posts = context.Posts.ToList().Where(d =&amp;gt; d.Title.IndexOf(&lt;span&gt;'C'&lt;/span&gt;) == &lt;span&gt;2&lt;/span&gt;).ToList();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其实我们只要将上述单引号修改双引号即可解决完全在客户端评估的问题，如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
            &lt;span&gt;var&lt;/span&gt; context = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; EFCoreDbContext();

            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; posts = context.Posts.Where(d =&amp;gt; d.Title.IndexOf(&lt;span&gt;&quot;C&quot;&lt;/span&gt;) == &lt;span&gt;2&lt;/span&gt;).ToList();
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201912/589642-20191202010810366-470580038.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;根据我们的查询描述，我们明明是想查询在标题中查询指定字符，为何对字符不能支持，只支持字符串呢，不知道官方是出于何种原因。同时这里我们也注意到，无论是MySQL还是SQL Server等等，尽量不要将表中列设置为可空，即使是可空也要设置为不可空，给定一个默认值即可，一旦数据量巨大时，会发现查询很慢，因为通过IS NULL或者IS NOT NULL不走索引导致。比如上述我们查询的Title，我们无论是通过Data Annotations还是Fluent Api，都必须配置成不可空，比如这里我们通过Data Annotations配置如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;        [Required]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Title { &lt;span&gt;get&lt;/span&gt;; &lt;span&gt;set&lt;/span&gt;; }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时我们继续进行上述查询时候，会发现对空值的判断已经没有了，同时也减少了查询语句，如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/589642/201912/589642-20191202011558217-218466242.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;请注意上述我所演示EF Core版本为3.0.1。本节我也只是通过简单的示例稍微给大家看了EF Core 3中一些小的问题，当然可能还存在其他的问题，更多细节等我后续研究会继续给出EF Core 3.x系列文章，感谢您的阅读，若有叙述不当或错误之处，还望指正，谢谢。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Dec 2019 23:40:00 +0000</pubDate>
<dc:creator>Jeffcky</dc:creator>
<og:description>前言 随着.NET Core 3.0的发布，EF Core 3.0也随之正式发布，关于这一块最近一段时间也没太多去关注，陆续会去对比之前版本有什么变化没有，本节我们来看下两个查询。 分组 我们知道在E</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/CreateMyself/p/11968440.html</dc:identifier>
</item>
<item>
<title>通俗化讲解JWT鉴权的使用场景及结构安全 - 字母哥博客</title>
<link>http://www.cnblogs.com/zimug/p/11968640.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zimug/p/11968640.html</guid>
<description>&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201912/1815316-20191202073734941-1901656824.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一基于session的应用开发的缺陷&quot;&gt;一、基于Session的应用开发的缺陷&lt;/h2&gt;
&lt;p&gt;在我们传统的B\S应用开发方式中，都是使用session进行状态管理的，比如说：保存登录、用户、权限等状态信息。这种方式的原理大致如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户登陆之后，将状态信息保存到session里面。服务端自动维护sessionid，即将sessionid写入cookie。&lt;/li&gt;
&lt;li&gt;cookie随着HTTP响应，被自动保存到浏览器端。&lt;/li&gt;
&lt;li&gt;当用户再次发送HTTP请求，sessionid随着cookies被带回服务器端&lt;/li&gt;
&lt;li&gt;服务器端根据sessionid，可以找回该用户之前保存在session里面的数据。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然，这整个过程中，cookies和sessionid都是服务端和浏览器端自动维护的。所以从编码层面是感知不到的，程序员只能感知到session数据的存取。但是，这种方式在有些情况下，是不适用的。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;比如：非浏览器的客户端、手机移动端等等，因为他们没有浏览器自动维护cookies的功能。&lt;/li&gt;
&lt;li&gt;比如：分布式应用，同一个应用部署甲、乙、丙三个主机上，实现负载均衡应用，其中一个挂掉了其他的还能负载工作。要知道session是保存在服务器内存里面的，三个主机一定是不同的内存。那么你登录的时候访问甲，而获取接口数据的时候访问乙，就无法保证session的唯一性和共享性。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;当然以上的这些情况我们都有方案(如redis共享session等)，可以继续使用session来保存状态。但是还有另外一种做法就是不用session了，即开发一个无状态的应用，JWT就是这样的一种方案。&lt;/p&gt;
&lt;h2 id=&quot;二jwt是什么&quot;&gt;二、JWT是什么？&lt;/h2&gt;
&lt;p&gt;笔者不想用比较高大上的名词解释JWT（JSON web tokens），你可以认为JWT是一个加密后的接口访问密码，并且该密码里面包含用户名信息。这样既可以知道你是谁？又可以知道你是否可以访问应用？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201912/1815316-20191202073735385-125229646.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;首先，客户端需要向服务端申请JWT令牌，这个过程通常是登录功能。即：由用户名和密码换取JWT令牌。&lt;/li&gt;
&lt;li&gt;当你访问系统其他的接口时，在HTTP的header中携带JWT令牌。header的名称可以自定义，前后端对应上即可。&lt;/li&gt;
&lt;li&gt;服务端解签验证JWT中的用户标识，根据用户标识从数据库中加载访问权限、用户信息等状态信息。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这就是JWT，以及JWT在应用服务开发中的使用方法。&lt;/p&gt;
&lt;h2 id=&quot;三jwt结构分析&quot;&gt;三、JWT结构分析&lt;/h2&gt;
&lt;p&gt;下图是我用在线的JWT解码工具，解码时候的截图。注意我这里用的是解码，不是解密。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1815316/201912/1815316-20191202073736399-110732456.jpg&quot; alt=&quot;file&quot;/&gt;&lt;/p&gt;
&lt;p&gt;从图中，我们可以看到JWT分为三个部分：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Header，这个部分通常是用来说明JWT使用的算法信息&lt;/li&gt;
&lt;li&gt;payload，这个部分通常用于携带一些自定义的状态附加信息（重要的是用户标识）。但是注意这部分是可以明文解码的，所以注意是用户标识，而不应该是用户名或者其他用户信息。&lt;/li&gt;
&lt;li&gt;signature，这部分是对前两部分数据的签名，防止前两部分数据被篡改。这里需要指定一个密钥secret，进行签名和解签。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;四jwt安全么&quot;&gt;四、JWT安全么？&lt;/h2&gt;
&lt;p&gt;很多的朋友看到上面的这个解码文件，就会生出一个疑问？你都把JWT给解析了，而且JWT又这么的被大家广泛熟知，它还安全么？我用一个简单的道理说明一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;JWT就像是一把钥匙，用来开你家里的锁。用户把钥匙一旦丢了，家自然是不安全的。其实和使用session管理状态是一样的，一旦网络或浏览器被劫持了，肯定不安全。&lt;/li&gt;
&lt;li&gt;signature通常被叫做签名，而不是密码。比如：天王盖地虎是签名，宝塔镇河妖就被用来解签。字你全都认识，但是暗号只有知道的人才对得上。当然JWT中的暗号secret不会设计的像诗词一样简单。&lt;/li&gt;
&lt;li&gt;JWT服务端也保存了一把钥匙，就是暗号secret。用来数据的签名和解签，secret一旦丢失，所有用户都是不安全的。所以对于IT人员，更重要的是保护secret的安全。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;如何加强JWT的安全性？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;避免网络劫持，因为使用HTTP的header传递JWT，所以使用HTTPS传输更加安全。这样在网络层面避免了JWT的泄露。&lt;/li&gt;
&lt;li&gt;secret是存放在服务器端的，所以只要应用服务器不被攻破，理论上JWT是安全的。因此要保证服务器的安全。&lt;/li&gt;
&lt;li&gt;那么有没有JWT加密算法被攻破的可能？当然有。但是对于JWT常用的算法要想攻破，目前已知的方法只能是暴力破解，白话说就是&quot;试密码&quot;。所以要定期更换secret并且保正secret的复杂度，等破解结果出来了，你的secret已经换了。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;话说回来，如果你的服务器、或者你团队的内部人员出现漏洞，同样没有一种协议和算法是安全的。&lt;/p&gt;
&lt;h2 id=&quot;期待您的关注&quot;&gt;期待您的关注&lt;/h2&gt;
</description>
<pubDate>Sun, 01 Dec 2019 23:38:00 +0000</pubDate>
<dc:creator>字母哥博客</dc:creator>
<og:description>一、基于Session的应用开发的缺陷 在我们传统的B\S应用开发方式中，都是使用session进行状态管理的，比如说：保存登录、用户、权限等状态信息。这种方式的原理大致如下： 用户登陆之后，将状态信</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zimug/p/11968640.html</dc:identifier>
</item>
<item>
<title>React躬行记（14）——测试框架 - 咖啡机（K.F.J）</title>
<link>http://www.cnblogs.com/strick/p/11906366.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/strick/p/11906366.html</guid>
<description>&lt;p&gt;　　测试不仅可以发现和预防问题，还能降低风险、减少企业损失。在React中，涌现了多种测试框架，本节会对其中的Jest和Enzyme做详细的讲解。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://jestjs.io/docs/zh-Hans/getting-started&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Jest&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;是由Facebook开源的一个测试框架，可无缝兼容&lt;span&gt;&lt;a href=&quot;https://jestjs.io/docs/zh-Hans/tutorial-react&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;React项目&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，专注简单，推崇零配置，开箱即用的宗旨，用于逻辑和组件的单元测试。它的语法和断言与Jasmine类似，并且还集成了快照测试、Mock、覆盖率报告等功能，支持多进程并行运行测试，在内部使用JSDOM操作DOM，&lt;span&gt;&lt;a href=&quot;https://github.com/jsdom/jsdom&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;JSDOM&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;是一种模拟的DOM环境，其行为类似于常规浏览器，可用来与用户交互、在节点上派发事件等。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）运行&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　为了便于运行Jest，本文使用&lt;span&gt;&lt;a href=&quot;https://www.html.cn/create-react-app/docs/running-tests/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Create React App&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;创建项目，命令如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npx create-react-app my-app
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　只要把测试文件放置在__tests__目录内，或将它们的名称添加.test.js或.spec.js后缀，并保存在项目的src目录中的任何深度，就能被Jest检测到。当运行下面的命令时，可得到相关的测试结果。&lt;/p&gt;

&lt;p&gt;　　默认情况下，Jest每次只运行与本次更改的文件相关的测试用例。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）创建测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　如果要创建测试用例（Test Case），那么需要使用&lt;span&gt;&lt;a href=&quot;https://jestjs.io/docs/zh-Hans/api#testname-fn-timeout&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;test()&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;或it()函数，其第一个参数是测试名称，第二个参数是包含测试代码的回调函数，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
test(&quot;two plus two is four&quot;, () =&amp;gt;&lt;span&gt; {
  expect(&lt;/span&gt;2 + 2).toBe(4&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://jestjs.io/docs/zh-Hans/expect#expectvalue&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;expect()&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;函数用于断言，它能接收一个实际值，并将其作为结果与匹配器中的期望值做比较。如果匹配失败，那么就会在控制台输出相应的错误提示。&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://jestjs.io/docs/zh-Hans/api#describename-fn&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;describe()&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;函数可将测试用例进行逻辑分组，其第一个参数可定义分组的名称，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
describe(&quot;my test case&quot;, () =&amp;gt;&lt;span&gt; {
  test(&lt;/span&gt;&quot;one plus one is two&quot;, () =&amp;gt;&lt;span&gt; {
    expect(&lt;/span&gt;1 + 1).toBe(2&lt;span&gt;);
  });
  test(&lt;/span&gt;&quot;two plus two is four&quot;, () =&amp;gt;&lt;span&gt; {
    expect(&lt;/span&gt;2 + 2).toBe(4&lt;span&gt;);
  });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）匹配器&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　通过&lt;span&gt;&lt;a href=&quot;https://jestjs.io/docs/zh-Hans/using-matchers&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;匹配器&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（Matcher）可以各种方式来测试代码，例如之前示例中的toBe()就是一个匹配器，它使用Object.is()来测试精确匹配，如果要检查对象是否相等，可改用toEqual()，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
test(&quot;object assignment&quot;, () =&amp;gt;&lt;span&gt; {
  const data &lt;/span&gt;= { name: &quot;strick&quot;&lt;span&gt; };
  data[&lt;/span&gt;&quot;age&quot;] = 28&lt;span&gt;;
  expect(data).toEqual({ name: &lt;/span&gt;&quot;strick&quot;, age: 28&lt;span&gt; });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其它常用的匹配器还有区分undefined、null和布尔值、比较数字、匹配字符串、检查数组或可迭代对象是否包含某个特定项、测试抛出的错误等功能。&lt;/p&gt;
&lt;p&gt;　　所有的匹配器都可以通过.not取反，例如验证toBeUndefined()不能匹配null，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
test(&quot;null is not undefined&quot;, () =&amp;gt;&lt;span&gt; {
  expect(&lt;/span&gt;&lt;span&gt;null&lt;/span&gt;&lt;span&gt;).not.toBeUndefined();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;4）异步测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Jest提供了多种方式来&lt;span&gt;&lt;a href=&quot;https://jestjs.io/docs/zh-Hans/asynchronous&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;测试异步代码&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，包括回调函数、Promise和Async/Await，接下来会逐个讲解用法。&lt;/p&gt;
&lt;p&gt;　　（1）默认情况下，Jest测试一旦执行到末尾就会完成，例如有一个check()函数（如下所示），它能接收一个回调函数，一旦check()执行结束，此测试就会在没有执行回调函数前结束。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; check(func) {
  const success &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;;
  func(success);
}
test(&lt;/span&gt;&quot;the data is truth&quot;, () =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; callback(data) {
    expect(data).toBeTruthy();
  }
  check(callback);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　若要解决此问题，可为test()的回调函数传递一个名为done的函数参数，Jest会等done()回调函数执行完后，再结束测试，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
test(&quot;the data is truth&quot;, done =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; callback(data) {
    expect(data).toBeTruthy();
    done();
  }
  check(callback);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（2）当异步代码返回Promise对象时，Jest会等待其状态的变化。如果状态变为已完成，那么得使用then()方法；如果状态变为已拒绝，那么得使用catch()方法，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;状态为已完成&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkResolve() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
    resolve(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
  });
}
test(&lt;/span&gt;&quot;the data is truth&quot;, () =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; checkResolve().then(data =&amp;gt;&lt;span&gt; {
    expect(data).toBeTruthy();
  });
});
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;状态为已拒绝&lt;/span&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkReject() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
    reject(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
  });
}
test(&lt;/span&gt;&quot;the data is falsity&quot;, () =&amp;gt;&lt;span&gt; {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; checkReject().&lt;span&gt;catch&lt;/span&gt;(data =&amp;gt;&lt;span&gt; {
    expect(data).toBeFalsy();
  });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　注意，要将Promise对象作为test()的回调函数的返回值，以免测试提前完成，导致没有进行方法链中的断言。&lt;/p&gt;
&lt;p&gt;　　在expect语句中也可以使用.resolves或.rejects两种匹配器来处理Promise的两种状态，如下所示，语法更为简洁。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
test(&quot;the data is truth&quot;, () =&amp;gt;&lt;span&gt; {
  expect(checkResolve()).resolves.toBeTruthy();
});
test(&lt;/span&gt;&quot;the data is falsity&quot;, () =&amp;gt;&lt;span&gt; {
  expect(checkReject()).rejects.toBeFalsy();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　（3）在测试中使用async和await两个关键字，也可以匹配Promise对象，例如断言checkResolve()的处理结果，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
test(&quot;the data is truth&quot;, async () =&amp;gt;&lt;span&gt; {
  const data &lt;/span&gt;=&lt;span&gt; await checkResolve();
  expect(data).toBeTruthy();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　它们也能用来测试已拒绝状态的Promise，如下所示，其中assertions()用于验证在测试中是否执行了指定数量的断言。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; checkError() {
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; Promise((resolve, reject) =&amp;gt;&lt;span&gt; {
    reject();
  }).&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;(() =&amp;gt;&lt;span&gt; {
    &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &quot;error&quot;&lt;span&gt;;
  });
}
test(&lt;/span&gt;&quot;the check fails with an error&quot;, async () =&amp;gt;&lt;span&gt; {
  expect.assertions(&lt;/span&gt;1&lt;span&gt;);
  &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    await checkError();
  } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (e) {
    expect(e).toMatch(&lt;/span&gt;&quot;error&quot;&lt;span&gt;);
  }
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　aysnc和awiat还可以与.resolves或.rejects结合使用，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
test(&quot;the data is truth&quot;, async () =&amp;gt;&lt;span&gt; {
  await expect(checkResolve()).resolves.toBeTruthy();
});
test(&lt;/span&gt;&quot;the check fails with an error&quot;, async () =&amp;gt;&lt;span&gt; {
  await expect(checkError()).rejects.toMatch(&lt;/span&gt;&quot;error&quot;&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;5）辅助函数&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　有时候，在运行测试前需要做些准备工作，而在运行测试之后又需要做些整理工作，Jest提供了四个相关的&lt;span&gt;&lt;a href=&quot;https://jestjs.io/docs/zh-Hans/setup-teardown&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;辅助函数&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;来处理这两类工作，如下所列。&lt;/p&gt;
&lt;p&gt;　　（1）beforeAll()和afterAll()会在所有测试用例之前和之后执行一次。&lt;/p&gt;
&lt;p&gt;　　（2）beforeEach()和afterEach()会在每个测试用例之前和之后执行，并且可以像异步测试那样处理异步代码。&lt;/p&gt;
&lt;p&gt;　　假设在四个辅助函数中输出各自的函数名称，并且有两个测试用例，如下代码所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
beforeAll(() =&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;&quot;beforeAll&quot;&lt;span&gt;);
});
afterAll(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;&quot;afterAll&quot;&lt;span&gt;);
});
beforeEach(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;&quot;beforeEach&quot;&lt;span&gt;);
});
afterEach(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
  console.log(&lt;/span&gt;&quot;afterEach&quot;&lt;span&gt;);
});

test(&lt;/span&gt;&quot;first&quot;, () =&amp;gt;&lt;span&gt; {
  expect(&lt;/span&gt;2).toBeGreaterThan(1&lt;span&gt;);
});
test(&lt;/span&gt;&quot;second&quot;, () =&amp;gt;&lt;span&gt; {
  expect(&lt;/span&gt;2).toBeLessThan(3&lt;span&gt;);
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　每次运行测试，在控制台将依次打印出“beforeAll”，两对“beforeEach”和“afterEach”，“afterAll”。&lt;/p&gt;
&lt;p&gt;　　当通过describe()对测试用例进行分组时（如下所示），外部的beforeEach()和afterEach()会优先执行。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
describe(&quot;scoped&quot;, () =&amp;gt;&lt;span&gt; {
  beforeEach(() &lt;/span&gt;=&amp;gt; console.log(&quot;inner beforeEach&quot;&lt;span&gt;));
  afterEach(() &lt;/span&gt;=&amp;gt; console.log(&quot;inner afterEach&quot;&lt;span&gt;));
  test(&lt;/span&gt;&quot;third&quot;, () =&amp;gt;&lt;span&gt; {
    expect([&lt;/span&gt;1, 2]).toContain(1&lt;span&gt;);
  });
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;6）Mock&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Jest内置了&lt;span&gt;&lt;a href=&quot;https://jestjs.io/docs/zh-Hans/mock-functions&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Mock函数&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，可用于擦除函数的实际实现来测试代码之间的连接，捕获函数的调用和参数、配置其返回值等。&lt;/p&gt;
&lt;p&gt;　　假设要测试一个自定义的forEach()函数的内部实现，那么可以使用jest.fn()创建一个Mock函数，然后通过检查它的mock属性来确保回调函数是否在按预期调用，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; forEach(items, callback) {
  &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (let index = 0; index &amp;lt; items.length; index++&lt;span&gt;) {
    callback(items[index]);
  }
}
test(&lt;/span&gt;&quot;forEach&quot;, () =&amp;gt;&lt;span&gt; {
  const mockFunc &lt;/span&gt;= jest.fn(x =&amp;gt; 42 +&lt;span&gt; x);
  forEach([&lt;/span&gt;0, 1&lt;span&gt;], mockFunc);
  expect(mockFunc.mock.calls.length).toBe(&lt;/span&gt;2);            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;此Mock函数被调用了两次&lt;/span&gt;
  expect(mockFunc.mock.calls[0][0]).toBe(0);             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次调用函数时的第一个参数是0&lt;/span&gt;
  expect(mockFunc.mock.calls[1][0]).toBe(1);             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第二次调用函数时的第一个参数是1&lt;/span&gt;
  expect(mockFunc.mock.results[0].value).toBe(42);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;第一次函数调用的返回值是42&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　每个Mock函数都会包含一个特殊的mock属性，记录了函数如何被调用、调用时的返回值等信息，通过该属性还能追踪每次调用时的this的值。如果要用Mock函数注入返回值，那么可以像下面这样链式的添加，首次调用返回10，第二次调用返回“x”，接下来的调用都返回true。其中mockName()方法可为Mock函数命名，该名称将在输出的日志中显示，可替换掉默认的“jest.fn()”。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
const myMock = jest.fn().mockName(&quot;returnValue&quot;&lt;span&gt;);
myMock
  .mockReturnValueOnce(&lt;/span&gt;10&lt;span&gt;)
  .mockReturnValueOnce(&lt;/span&gt;&quot;x&quot;&lt;span&gt;)
  .mockReturnValue(&lt;/span&gt;&lt;span&gt;true&lt;/span&gt;&lt;span&gt;);
console.log(myMock(), myMock(), myMock(), myMock());     &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;10, 'x', true, true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Mock函数还可以模拟模块，例如拦截axios请求得到的数据，如下代码所示，为.get提供了一个mockResolvedValue()方法，它会返回用于测试的假数据。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
import axios from &quot;axios&quot;&lt;span&gt;;
jest.mock(&lt;/span&gt;&quot;axios&quot;&lt;span&gt;);
class Users {
  static all() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; axios.get(&quot;./users.json&quot;).then(resp =&amp;gt;&lt;span&gt; resp.data);
  }
}
test(&lt;/span&gt;&quot;should fetch users&quot;, () =&amp;gt;&lt;span&gt; {
  const users &lt;/span&gt;= [{ name: &quot;strick&quot;&lt;span&gt; }];
  const resp &lt;/span&gt;=&lt;span&gt; { data: users };
  axios.get.mockResolvedValue(resp);
  &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Users.all().then(data =&amp;gt;&lt;span&gt; expect(data).toEqual(users));
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　原生的定时器函数测试起来并不方便，通过jest.useFakeTimers()可以模拟定时器函数，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;function&lt;/span&gt;&lt;span&gt; timerGame() {
  setTimeout(() &lt;/span&gt;=&amp;gt;&lt;span&gt; {
    console.log(&lt;/span&gt;&quot;start&quot;&lt;span&gt;);
  }, &lt;/span&gt;1000&lt;span&gt;);
}
jest.useFakeTimers();
test(&lt;/span&gt;&quot;setTimeout&quot;, () =&amp;gt;&lt;span&gt; {
  timerGame();
  expect(setTimeout).toHaveBeenCalledTimes(&lt;/span&gt;1);                        　　　　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;调用了1次&lt;/span&gt;
  expect(setTimeout).toHaveBeenLastCalledWith(expect.any(Function), 1000);        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;1秒后执行回调&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　Jest模拟出的定时器函数还有快进到正确的时间点、执行当前正在等待的定时器等功能。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;7）快照测试&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　Jest提供的&lt;span&gt;&lt;a href=&quot;https://jestjs.io/docs/zh-Hans/snapshot-testing&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;快照测试&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;（Spapshot Testing）是一种高效的UI测试，它会将React组件序列化成纯文本（即快照）并保存在硬盘中，每次测试就把当前生成的快照与保存的快照进行对比，接下来用一个例子来介绍快照测试的用法。&lt;/p&gt;
&lt;p&gt;　　首先创建一个Link组件，它会渲染出一条包含onMouseEnter事件的链接，当鼠标移动到这条链接时，会改变它的class属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
import React from &quot;react&quot;&lt;span&gt;;
const STATUS &lt;/span&gt;=&lt;span&gt; {
  HOVERED: &lt;/span&gt;&quot;hovered&quot;&lt;span&gt;,
  NORMAL: &lt;/span&gt;&quot;normal&quot;&lt;span&gt;
};
export &lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; class Link extends React.Component {
  constructor(props) {
    super(props);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;._onMouseEnter = &lt;span&gt;this&lt;/span&gt;._onMouseEnter.bind(&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.state =&lt;span&gt; {
      class: STATUS.NORMAL
    };
  }
  _onMouseEnter() {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.setState({ class: STATUS.HOVERED });
  }
  render() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; (
      &lt;/span&gt;&amp;lt;&lt;span&gt;a
        href&lt;/span&gt;=&quot;#&quot;&lt;span&gt;
        className&lt;/span&gt;={&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.state.class}
        onMouseEnter&lt;/span&gt;={&lt;span&gt;this&lt;/span&gt;&lt;span&gt;._onMouseEnter}
      &lt;/span&gt;&amp;gt;&lt;span&gt;
        {&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;.props.children}
      &lt;/span&gt;&amp;lt;/a&amp;gt;
&lt;span&gt;    );
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　然后创建测试文件spapshot.test.js，在其内部，除了要引入Link组件之外，还得引入&lt;span&gt;&lt;a href=&quot;https://zh-hans.reactjs.org/docs/test-renderer.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;react-test-renderer&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;，它不依赖浏览器和JSDOM，可将React组件渲染成JavaScript对象（即快照）。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
import React from &quot;react&quot;&lt;span&gt;;
import Link from &lt;/span&gt;&quot;./Link&quot;&lt;span&gt;;
import renderer from &lt;/span&gt;&quot;react-test-renderer&quot;&lt;span&gt;;

test(&lt;/span&gt;&quot;Link changes the class when hovered&quot;, () =&amp;gt;&lt;span&gt; {
    const component &lt;/span&gt;= renderer.create(&amp;lt;Link&amp;gt;Strick&amp;lt;/Link&amp;gt;);
    let tree =&lt;span&gt; component.toJSON();
    expect(tree).toMatchSnapshot();

    tree.props.onMouseEnter();         &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;触发事件&lt;/span&gt;
    tree = component.toJSON();         &lt;span&gt;//&lt;/span&gt;&lt;span&gt;重新渲染&lt;/span&gt;
&lt;span&gt;    expect(tree).toMatchSnapshot();
});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在第一次运行测试时，会自动创建__snapshots__目录，放置对应的快照文件spapshot.test.js.snap，其内容如下所示，包含两张快照，第二张是触发onMouseEnter事件后生成的。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
exports[`Link changes the class when hovered 1`] =&lt;span&gt; `
&lt;/span&gt;&amp;lt;&lt;span&gt;a
  className&lt;/span&gt;=&quot;normal&quot;&lt;span&gt;
  href&lt;/span&gt;=&quot;#&quot;&lt;span&gt;
  onMouseEnter&lt;/span&gt;=&lt;span&gt;{[Function]}
&lt;/span&gt;&amp;gt;&lt;span&gt;
  Strick
&lt;/span&gt;&amp;lt;/a&amp;gt;
&lt;span&gt;`;

exports[`Link changes the class when hovered &lt;/span&gt;2`] =&lt;span&gt; `
&lt;/span&gt;&amp;lt;&lt;span&gt;a
  className&lt;/span&gt;=&quot;hovered&quot;&lt;span&gt;
  href&lt;/span&gt;=&quot;#&quot;&lt;span&gt;
  onMouseEnter&lt;/span&gt;=&lt;span&gt;{[Function]}
&lt;/span&gt;&amp;gt;&lt;span&gt;
  Strick
&lt;/span&gt;&amp;lt;/a&amp;gt;
`;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　如果要刷新保存的快照，除了手动删除之外，还可以通过jest -u命令实现。&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://airbnb.io/enzyme/&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;Enzyme&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;是一款用于React组件的测试框架，可处理渲染出的DOM结构，开放的API类似于jQuery的语法，提供了三种不同的方式来测试组件：浅层渲染（Shallow Rendering）、完全渲染（Full Rendering）和静态渲染（Static Rendering）。从Enzyme 3开始，在安装Enzyme的同时，还需要安装与React版本相对应的适配器，命令如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
npm install --save enzyme enzyme-adapter-react-16
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1）浅层渲染&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　独立于DOM的&lt;span&gt;&lt;a href=&quot;https://airbnb.io/enzyme/docs/api/shallow.html&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;浅层渲染&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;只会渲染React组件的第一层，它会忽略子组件的行为，也就没必要渲染子组件了，这提供了更好的隔离性。不过浅层渲染也有它局限性，即不支持Refs。&lt;/p&gt;
&lt;p&gt;　　以上一节中的Link组件为例，在进行Enzyme之前，需要先通过configure()函数配置适配器，然后才能通过shallow()函数浅渲染Link组件，如下所示。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
import React from &quot;react&quot;&lt;span&gt;;
import { shallow, configure } from &lt;/span&gt;&quot;enzyme&quot;&lt;span&gt;;
import Adapter from &lt;/span&gt;&quot;enzyme-adapter-react-16&quot;&lt;span&gt;;
import Link from &lt;/span&gt;&quot;../component/Form/Link&quot;&lt;span&gt;;

configure({ adapter: &lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Adapter() });
test(&lt;/span&gt;&quot;Link changes the class after mouseenter&quot;, () =&amp;gt;&lt;span&gt; {
  const wrapper &lt;/span&gt;= shallow(&amp;lt;Link&amp;gt;Strick&amp;lt;/Link&amp;gt;),
    a = wrapper.find(&quot;a&quot;&lt;span&gt;);
  expect(wrapper.text()).toEqual(&lt;/span&gt;&quot;Strick&quot;&lt;span&gt;);
  a.simulate(&lt;/span&gt;&quot;mouseenter&quot;);                     　　　　&lt;span&gt;//&lt;/span&gt;&lt;span&gt;触发事件&lt;/span&gt;
  expect(a.prop(&quot;className&quot;)).toEqual(&quot;normal&quot;);       &lt;span&gt;//&lt;/span&gt;&lt;span&gt;匹配样式&lt;/span&gt;
});
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　wrapper是一个虚拟的DOM对象，它包含多个操作DOM的方法，例如find()可根据选择器找到指定的节点，simulate()可触发当前节点的事件。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2）完全渲染&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　mount()函数会完全渲染接收的组件，即它的子组件也会被渲染。完全渲染依赖JSDOM，当多个测试处理同一个DOM时，可能会相互影响，因此在测试结束后需要使用unmount()方法卸载组件。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3）静态渲染&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　render()函数会静态渲染组件，也就是将它渲染成HTML字符串，再通过Cheerio库解析该HTML结构。Cheerio类似于JSDOM，但更轻量，可像jQuery那样操作字符串。&lt;/p&gt;

</description>
<pubDate>Sun, 01 Dec 2019 23:32:00 +0000</pubDate>
<dc:creator>咖啡机（K.F.J）</dc:creator>
<og:description>测试不仅可以发现和预防问题，还能降低风险、减少企业损失。在React中，涌现了多种测试框架，本节会对其中的Jest和Enzyme做详细的讲解。 一、Jest Jest是由Facebook开源的一个测试</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/strick/p/11906366.html</dc:identifier>
</item>
<item>
<title>备忘录模式 - 纳兰小依</title>
<link>http://www.cnblogs.com/NaLanZiYi-LinEr/p/11966835.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/NaLanZiYi-LinEr/p/11966835.html</guid>
<description>&lt;h2&gt;&lt;span&gt;1.模式简介&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;      备忘录模式能够在不破坏封装性的前提下，实现对象状态的保存和恢复工作，又叫快照模式或Token模式。保存对象的状态是为了以后在需要的时候快速恢复到保存时的状态，因此常用在备份、撤销操作上，例如编辑器里的撤销、游戏里的存档和悔棋等功能。&lt;/p&gt;
&lt;p&gt;      备忘录模式有三个组成部分：&lt;/p&gt;
&lt;p&gt;      Originagor(发起人)：即需要备份的对象，可以创建备忘录，以及根据备忘录来恢复状态，可以看到备忘录提供的宽接口。&lt;/p&gt;
&lt;p&gt;      Memento(备忘录)：存储Originator的部分或所有状态，对外提供宽窄接口。&lt;/p&gt;
&lt;p&gt;      CareTaker(管理人)：负责保存Memento对象，只能看到备忘录提供的窄接口。&lt;/p&gt;
&lt;p&gt;      上面提到了宽接口和窄接口，有必要先解释一下，宽窄接口实际上代表了外界对备忘录的访问权限问题：&lt;/p&gt;
&lt;p&gt;      宽接口：能够看到备忘录保存的所有数据，一般只对发起人可见，对其他角色不可见。&lt;/p&gt;
&lt;p&gt;      窄接口：只能看到备忘录保存的部分数据(甚至可以实现不对外暴露任何数据)，通常出于封装和安全性考虑，对发起人之外的其他角色只提供窄接口。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;2. 示例&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;      下面以一个简单的例子演示备忘录模式的用法，示例模仿棋类游戏中的悔棋，为简单起见，只记录棋子的坐标。&lt;/p&gt;
&lt;p&gt;       先定义棋子类Chessman，包含棋子的x坐标和y坐标：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Chessman {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; positionx;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; positiony;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPosition(&lt;span&gt;int&lt;/span&gt; positionx, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; positiony) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positionx =&lt;span&gt; positionx;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positiony =&lt;span&gt; positiony;
  }

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;当前位置{&quot; +
      &quot;positionx=&quot; + positionx +
      &quot;, positiony=&quot; + positiony +
      '}'&lt;span&gt;;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Chessman(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positionx =&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positiony =&lt;span&gt; y;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Memento createMemento(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Memento(positionx, positiony);
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; restore(Memento memento){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positionx =&lt;span&gt; memento.getPositionx();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positiony =&lt;span&gt; memento.getPositiony();
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      接着定义备忘录类Memento，用来存储棋子的坐标信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Memento {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; positionx;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; positiony;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPositionx() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; positionx;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPositiony() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; positiony;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Memento(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positionx =&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positiony =&lt;span&gt; y;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      定义管理者类CareTaker，外界通过该类获取备份信息：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CareTaker {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; Memento memento;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; Memento getMemento() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; memento;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMemento(Memento memento) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.memento =&lt;span&gt; memento;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      接下来用客户端来测试这个简单的备忘录：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MementoTest {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    Chessman chessman &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Chessman(0,0&lt;span&gt;);
    chessman.setPosition(&lt;/span&gt;3,4&lt;span&gt;);
    System.out.println(chessman);
    CareTaker careTaker &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CareTaker();
    System.out.println(&lt;/span&gt;&quot;备份棋子位置。。。&quot;&lt;span&gt;);
    careTaker.setMemento(chessman.createMemento());
    chessman.setPosition(&lt;/span&gt;7,5&lt;span&gt;);
    System.out.println(chessman);
    System.out.println(&lt;/span&gt;&quot;悔棋。。。&quot;&lt;span&gt;);
    chessman.restore(careTaker.getMemento());
    System.out.println(chessman);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      输出为：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;p&gt;当前位置{positionx=3, positiony=4}&lt;br/&gt;备份棋子位置。。。&lt;br/&gt;当前位置{positionx=7, positiony=5}&lt;br/&gt;悔棋。。。&lt;br/&gt;当前位置{positionx=3, positiony=4}&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;      该示例所对应的类图结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/697450/201912/697450-20191201225935837-188228490.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      上面这个示例只是单备份，也就是说只能备份一个状态，将CareTaker中的Memento修改成集合的形式可以实现多备份。&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;3. “黑箱”备忘录模式&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;      其实上面的实现方式有一个很大的问题，就是Memento对所有的外界对象都是公开的，任何对象都可以访问和修改Memento的字段，这种模式称为“白箱”模式。由于没有相应的权限控制，这种方式无法保证备忘录的安全性，不具备太大的实用价值。一种解决方案是将Memento设置为Originator的内部类，并通过权限控制符来限制外界对他的访问。&lt;/p&gt;
&lt;p&gt;      修改后的Chessman类，拥有私有的Memebto类：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; ChessmanNew {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; positionx;
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; positiony;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; setPosition(&lt;span&gt;int&lt;/span&gt; positionx, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; positiony) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positionx =&lt;span&gt; positionx;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positiony =&lt;span&gt; positiony;
  }

  @Override
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; String toString() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &quot;当前位置{&quot; +
      &quot;positionx=&quot; + positionx +
      &quot;, positiony=&quot; + positiony +
      '}'&lt;span&gt;;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; ChessmanNew(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positionx =&lt;span&gt; x;
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positiony =&lt;span&gt; y;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MementoFace createMemento(){
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Memento(positionx, positiony);
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; restore(MementoFace memento){
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positionx =&lt;span&gt; memento.getx();
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positiony =&lt;span&gt; ((Memento)memento).getPositiony();
  }

  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Memento &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; MementoFace{
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; positionx;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; positiony;

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; Memento(&lt;span&gt;int&lt;/span&gt; x, &lt;span&gt;int&lt;/span&gt;&lt;span&gt; y){
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positionx =&lt;span&gt; x;
      &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.positiony =&lt;span&gt; y;
    }

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getPositiony(){
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.positiony;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getx() {
      &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.positionx;
    }
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      Memento对外以接口MementoFace的形式提供有限的服务(即只允许外界访问x坐标，而对外隐藏y坐标)，MementoFace的定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt;&lt;span&gt; MementoFace {
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;窄接口&lt;/span&gt;
  &lt;span&gt;int&lt;/span&gt;&lt;span&gt; getx();
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      CareTaker类也需要做对应的修改：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CareTakerNew {
  &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; MementoFace mementoFace;

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; MementoFace getMementoFace() {
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; mementoFace;
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; setMementoFace(MementoFace mementoFace) {
    &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.mementoFace =&lt;span&gt; mementoFace;
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      客户端测试如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; MementoTest {
  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
    newtest();
  }

  &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; newtest(){
    ChessmanNew chessman &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; ChessmanNew(0,0&lt;span&gt;);
    chessman.setPosition(&lt;/span&gt;3,4&lt;span&gt;);
    System.out.println(chessman);
    System.out.println(&lt;/span&gt;&quot;备份棋子位置。。。&quot;&lt;span&gt;);
    CareTakerNew careTaker &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; CareTakerNew();
    careTaker.setMementoFace(chessman.createMemento());
    System.out.println(chessman);
    System.out.println(&lt;/span&gt;&quot;悔棋。。。&quot;&lt;span&gt;);
    chessman.restore(careTaker.getMementoFace());
    System.out.println(chessman);
  }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;      输出与修改前的代码一致，这里略去。这种方式修改后，外界能够接触到的只有MementoFace接口，只能访问x坐标，其他什么也做不了，从而保证了封装性。&lt;/p&gt;
</description>
<pubDate>Sun, 01 Dec 2019 15:56:00 +0000</pubDate>
<dc:creator>纳兰小依</dc:creator>
<og:description>1.模式简介 备忘录模式能够在不破坏封装性的前提下，实现对象状态的保存和恢复工作，又叫快照模式或Token模式。保存对象的状态是为了以后在需要的时候快速恢复到保存时的状态，因此常用在备份、撤销操作上，</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/NaLanZiYi-LinEr/p/11966835.html</dc:identifier>
</item>
</channel>
</rss>