<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>程序员修神之路--高并发下如何缩短响应时间 - 架构师修行之路</title>
<link>http://www.cnblogs.com/zhanlang/p/11029098.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhanlang/p/11029098.html</guid>
<description>&lt;p&gt;当一个请求到达网站服务器，服务器便开始处理请求，一般会有专门处理业务请求的一个业务层，有的体现为rpc协议的微服务，有的体现为简单的一个代码分层。最终请求的数据会通过查询数据库来返回。其实这个过程和车站购票流程一样，每个窗口的处理能力是有限的，对应到服务器处理能力。由于这个原因，所以诞生了负载均衡的策略，核心思想就是：分。一台服务器不够，那就两台，三台，四台..... 直到并发的所有请求的响应时间都在可控范围之内。&lt;/p&gt;&lt;p&gt;数据库的情况类似，一个数据库扛不住压力，就加到N个数据库分散压力。一个表扛不住压力，就把这个表拆分开，拆分成多个表，甚至拆分到多个不同服务器数据库，这就是我们常用的拆表策略。有的时候在同一个数据库中进行表拆分，性能的提升并非最大化，因为一台服务器的磁盘IO是有上限的，就算拆成100个表，还是在同一个物理磁盘上，当然这样可缓解锁单表的情况。&lt;/p&gt;

&lt;p&gt;现在有很多的场景采用NOsql代替关系型数据库来缩短响应时间，在正常情况下，由于关系型数据库的本身因素在特定场景下的读写速度比Nosql要慢很多，所以系统设计初期，可以考虑采用关系型数据库和Nosql混用的方案。&lt;/p&gt;
</description>
<pubDate>Wed, 19 Jun 2019 00:58:00 +0000</pubDate>
<dc:creator>架构师修行之路</dc:creator>
<og:description>菜菜哥，请你看电影呀，但是得帮我一个忙 好呀，看什么？ 哥斯拉2：怪兽之王 看过了~ X战警：黑凤凰 看过了 追龙2和黑衣人呢？ 都看过了，你说帮什么忙吧 我一个网站响应特别慢，你帮我优化一下呗，很简</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhanlang/p/11029098.html</dc:identifier>
</item>
<item>
<title>深入理解defer（上）defer基础 - 爱写程序的阿波张</title>
<link>http://www.cnblogs.com/abozhang/p/11049304.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/abozhang/p/11049304.html</guid>
<description>&lt;p&gt;深入理解 defer 分上下两篇文章，本文为上篇，主要介绍如下内容：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;为什么需要&lt;/strong&gt; &lt;strong&gt;defer&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;先来看一段没有使用 defer 的代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func f() {
    r := getResource()  //0，获取资源
    ......
    if ... {
        r.release()  //1，释放资源
        return
    }
    ......
    if ... {
        r.release()  //2，释放资源
        return
    }
    ......
    if ... {
        r.release()  //3，释放资源
        return
    }
    ......
    r.release()  //4，释放资源
    return
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;f() 函数首先通过调用 getResource()  获取了某种资源（比如打开文件，加锁等），然后进行了一些我们不太关心的操作，但这些操作可能会导致 f() 函数提前返回，为了避免资源泄露，所以每个 return 之前都调用了 r.release() 函数对资源进行释放。这段代码看起来并不糟糕，但有两个小问题：&lt;strong&gt;代码臃肿&lt;/strong&gt;和&lt;strong&gt;可维护性比较差&lt;/strong&gt;。臃肿倒是其次，主要问题在于代码的可维护性差，因为随着开发和维护的进行，修改代码在所难免，一旦对 f() 函数进行修改添加某个提前返回的分支，就很有可能在提前 return 时忘记调用 r.release() 释放资源，从而导致资源泄漏。&lt;/p&gt;
&lt;p&gt;那么我们如何改善上述两个问题呢？一个不错的方案就是通过 &lt;strong&gt;defer&lt;/strong&gt; 调用 r.release() 来释放资源：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;34&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func f() {
     r := getResource()  //0，获取资源
     defer r.release()  //1，注册延迟调用函数，f()函数返回时才会调用r.release函数释放资源
     ......
     if ... {
         return
     }
     ......
     if ... {
         return
     }
     ......
     if ... {
         return
     }
     ......
     return
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看到通过使用 &lt;strong&gt;defer&lt;/strong&gt; 调用 r.release()，我们不需要在每个 return 之前都去手动调用 r.release() 函数，代码确实精简了一点，重要的是不管以后加多少提前 return 的代码，都不会出现资源泄露的问题，因为不管在什么地方 return ，r.release() 函数始终都会被调用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;defer&lt;/strong&gt; &lt;strong&gt;语法及语义&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;defer语法很简单，直接在普通写法的函数调用之前加 defer 关键字即可：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
defer xxx(arg0, arg1, arg2, ......)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;defer&lt;/strong&gt; 表示对紧跟其后的 xxx() 函数延迟到 defer 语句所在的当前函数返回时再进行调用。比如前文代码中注释 1 处的 defer r.release() 表示等 f() 函数返回时再调用 r.release() 。下文我们称 defer 语句中的函数叫 &lt;strong&gt;defer函数。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;defer&lt;/strong&gt; &lt;strong&gt;使用要点&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;对 defer 的使用需要注意如下几个要点：&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;延迟&lt;/strong&gt;对函数进行调用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;&lt;strong&gt;即时&lt;/strong&gt;对函数的参数进行求值；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;根据 defer 顺序&lt;strong&gt;反序调用&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;下面我们用例子来简单的看一下这几个要点。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;defer&lt;/strong&gt; &lt;strong&gt;函数延迟调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func f() {
     defer fmt.Println(&quot;defer&quot;)
     fmt.Println(&quot;begin&quot;)
     fmt.Println(&quot;end&quot;)
     return
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码首先会输出 begin 字符串，然后是 end ，最后才输出 defer 字符串。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;defer&lt;/strong&gt; &lt;strong&gt;函数&lt;/strong&gt;&lt;strong&gt;参数即时求值&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;36&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func g(i int) {
   fmt.Println(&quot;g i:&quot;, i)
}
func f() {
   i := 100
   defer g(i)  //1
   fmt.Println(&quot;begin i:&quot;, i)
   i = 200
   fmt.Println(&quot;end i:&quot;, i)
   return
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段代码首先输出 begin i: 100，然后输出 end i: 200，最后输出 g i: 100 ，可以看到 g() 函数虽然在f函数返回时才被调用，但传递给 g() 函数的参数还是100，因为代码 1 处的 defer g(i) 这条语句执行时 i 的值是100。也就是说 defer 函数会被延迟调用，但传递给 defer 函数的参数会在 defer 语句处就被准备好。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;反序调用&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
func f() {
     defer fmt.Println(&quot;defer01&quot;)
     fmt.Println(&quot;begin&quot;)
     defer fmt.Println(&quot;defer02&quot;)
     fmt.Println(&quot;----&quot;)
     defer fmt.Println(&quot;defer03&quot;)
     fmt.Println(&quot;end&quot;)
     return
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这段程序的输出如下：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;begin&lt;br/&gt;&lt;span&gt;&lt;span&gt;----&lt;br/&gt;&lt;span&gt;&lt;span&gt;end&lt;br/&gt;&lt;span&gt;&lt;span&gt;defer03&lt;br/&gt;&lt;span&gt;&lt;span&gt;defer02&lt;br/&gt;&lt;span&gt;&lt;span&gt;defer01&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出f函数返回时，第一个 defer 函数最后被执行，而最后一个 defer 函数却第一个被执行。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;defer&lt;/strong&gt; &lt;strong&gt;函数&lt;/strong&gt;&lt;strong&gt;的执行与&lt;/strong&gt; &lt;strong&gt;return&lt;/strong&gt; &lt;strong&gt;语句之间的关系&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;到目前为止，defer 看起来都还比较好理解。下面我们开始把问题复杂化&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import &quot;fmt&quot;

var g = 100

func f() (r int) {
    defer func() {
        g = 200
    }()

    fmt.Printf(&quot;f: g = %d\n&quot;, g)

    return g
}

func main() {
    i := f()
    fmt.Printf(&quot;main: i = %d, g = %d\n&quot;, i, g)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;$ ./defer&lt;br/&gt;&lt;span&gt;f: g &lt;span&gt;=&lt;span&gt;100&lt;br/&gt;&lt;span&gt;main: i &lt;span&gt;=&lt;span&gt;100, g &lt;span&gt;=&lt;span&gt;200&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;这个输出还是比较容易理解，f() 函数在执行 return g 之前 g 的值还是100，所以 main() 函数获得的 f() 函数的返回值是100，因为 g 已经被 defer 函数修改成了200，所以在 main 中输出的 g 的值为200，看起来 defer 函数在 return g 之后才运行。下面稍微修改一下上面的程序：&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:go;gutter:true;&quot;&gt;
package main

import &quot;fmt&quot;

var g = 100

func f() (r int) {
    r = g
    defer func() {
        r = 200
    }()

    fmt.Printf(&quot;f: r = %d\n&quot;, r)

    r = 0
    return r
}

func main() {
    i := f()
    fmt.Printf(&quot;main: i = %d, g = %d\n&quot;, i, g)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;输出：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt;$ ./defer &lt;br/&gt;&lt;span&gt;f: r &lt;span&gt;=&lt;span&gt;100&lt;br/&gt;&lt;span&gt;main: i &lt;span&gt;=&lt;span&gt;200, g &lt;span&gt;=&lt;span&gt;100&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;从这个输出可以看出，defer 函数修改了 f() 函数的返回值，从这里看起来 defer 函数的执行发生在 return r 之前，然而上一个例子我们得出的结论是 defer 函数在 return 语句之后才被调用执行，这两个结论很矛盾，到底是怎么回事呢？&lt;/p&gt;
&lt;p&gt;仅仅从go语言的角度来说确实不太好理解，我们需要深入到汇编来分析一下。&lt;/p&gt;
&lt;p&gt;老套路，使用 gdb 反汇编一下 f() 函数：&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;&lt;span&gt; &lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;74&quot;&gt;
&lt;pre&gt;
  0x0000000000488a30&amp;lt;+&lt;span&gt;0&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;  %&lt;span&gt;fs:&lt;/span&gt;&lt;span&gt;0xfffffffffffffff8,%rcx
  0x0000000000488a39&amp;lt;+&lt;/span&gt;&lt;span&gt;9&lt;/span&gt;&amp;gt;: &lt;span&gt;cmp&lt;/span&gt;&lt;span&gt;  0x10(%rcx),%rsp
  0x0000000000488a3d&amp;lt;+&lt;/span&gt;&lt;span&gt;13&lt;/span&gt;&amp;gt;: &lt;span&gt;jbe&lt;/span&gt;  0x488b33 &amp;lt;main.f+&lt;span&gt;259&lt;/span&gt;&lt;span&gt;&amp;gt;
  0x0000000000488a43&amp;lt;+&lt;/span&gt;&lt;span&gt;19&lt;/span&gt;&amp;gt;: &lt;span&gt;sub&lt;/span&gt;&lt;span&gt;  $0x68,%rsp
  0x0000000000488a47&amp;lt;+&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  %rbp,0x60(%rsp)
  0x0000000000488a4c&amp;lt;+&lt;/span&gt;&lt;span&gt;28&lt;/span&gt;&amp;gt;: &lt;span&gt;lea&lt;/span&gt;&lt;span&gt;   0x60(%rsp),%rbp
  0x0000000000488a51&amp;lt;+&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;&lt;span&gt;&amp;gt;: movq  $0x0,0x70(%rsp) # 初始化返回值r为0
  0x0000000000488a5a&amp;lt;+&lt;/span&gt;&lt;span&gt;42&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  0xbd66f(%rip),%rax       # 0x5460d0 &amp;lt;main.g&amp;gt;
  0x0000000000488a61&amp;lt;+&lt;/span&gt;&lt;span&gt;49&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  %rax,0x70(%rsp)  # r = g
  0x0000000000488a66&amp;lt;+&lt;/span&gt;&lt;span&gt;54&lt;/span&gt;&lt;span&gt;&amp;gt;: movl   $0x8,(%rsp)
  0x0000000000488a6d&amp;lt;+&lt;/span&gt;&lt;span&gt;61&lt;/span&gt;&amp;gt;: &lt;span&gt;lea&lt;/span&gt;&lt;span&gt;  0x384a4(%rip),%rax       # 0x4c0f18
  0x0000000000488a74&amp;lt;+&lt;/span&gt;&lt;span&gt;68&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  %rax,0x8(%rsp)
  0x0000000000488a79&amp;lt;+&lt;/span&gt;&lt;span&gt;73&lt;/span&gt;&amp;gt;: &lt;span&gt;lea&lt;/span&gt;&lt;span&gt;  0x70(%rsp),%rax
  0x0000000000488a7e&amp;lt;+&lt;/span&gt;&lt;span&gt;78&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  %rax,0x10(%rsp)
  0x0000000000488a83&amp;lt;+&lt;/span&gt;&lt;span&gt;83&lt;/span&gt;&lt;span&gt;&amp;gt;: callq  0x426c00 &amp;lt;runtime.deferproc&amp;gt;
  0x0000000000488a88&amp;lt;+&lt;/span&gt;&lt;span&gt;88&lt;/span&gt;&amp;gt;: &lt;span&gt;test&lt;/span&gt;&lt;span&gt;  %eax,%eax
  0x0000000000488a8a&amp;lt;+&lt;/span&gt;&lt;span&gt;90&lt;/span&gt;&amp;gt;: &lt;span&gt;jne&lt;/span&gt;  0x488b23 &amp;lt;main.f+&lt;span&gt;243&lt;/span&gt;&lt;span&gt;&amp;gt;
  0x0000000000488a90&amp;lt;+&lt;/span&gt;&lt;span&gt;96&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  0x70(%rsp),%rax
  0x0000000000488a95&amp;lt;+&lt;/span&gt;&lt;span&gt;101&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  %rax,(%rsp)
  0x0000000000488a99&amp;lt;+&lt;/span&gt;&lt;span&gt;105&lt;/span&gt;&lt;span&gt;&amp;gt;: callq  0x408950 &amp;lt;runtime.convT64&amp;gt;
  0x0000000000488a9e&amp;lt;+&lt;/span&gt;&lt;span&gt;110&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  0x8(%rsp),%rax
  0x0000000000488aa3&amp;lt;+&lt;/span&gt;&lt;span&gt;115&lt;/span&gt;&lt;span&gt;&amp;gt;: xorps  %xmm0,%xmm0
  0x0000000000488aa6&amp;lt;+&lt;/span&gt;&lt;span&gt;118&lt;/span&gt;&lt;span&gt;&amp;gt;: movups  %xmm0,0x50(%rsp)
  0x0000000000488aab&amp;lt;+&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&amp;gt;: &lt;span&gt;lea&lt;/span&gt;&lt;span&gt;  0x101ee(%rip),%rcx       # 0x498ca0
  0x0000000000488ab2&amp;lt;+&lt;/span&gt;&lt;span&gt;130&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  %rcx,0x50(%rsp)
  0x0000000000488ab7&amp;lt;+&lt;/span&gt;&lt;span&gt;135&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;   %rax,0x58(%rsp)
  0x0000000000488abc&amp;lt;+&lt;/span&gt;&lt;span&gt;140&lt;/span&gt;&amp;gt;: &lt;span&gt;nop&lt;/span&gt;&lt;span&gt;
  0x0000000000488abd&amp;lt;+&lt;/span&gt;&lt;span&gt;141&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  0xd0d2c(%rip),%rax# 0x5597f0 &amp;lt;os.Stdout&amp;gt;
  0x0000000000488ac4&amp;lt;+&lt;/span&gt;&lt;span&gt;148&lt;/span&gt;&amp;gt;: &lt;span&gt;lea&lt;/span&gt;&lt;span&gt;  0x495f5(%rip),%rcx# 0x4d20c0 &amp;lt;go.itab.*os.File,io.Writer&amp;gt;
  0x0000000000488acb&amp;lt;+&lt;/span&gt;&lt;span&gt;155&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;   %rcx,(%rsp)
  0x0000000000488acf&amp;lt;+&lt;/span&gt;&lt;span&gt;159&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  %rax,0x8(%rsp)
  0x0000000000488ad4&amp;lt;+&lt;/span&gt;&lt;span&gt;164&lt;/span&gt;&amp;gt;: &lt;span&gt;lea&lt;/span&gt;&lt;span&gt;   0x31ddb(%rip),%rax       # 0x4ba8b6
  0x0000000000488adb&amp;lt;+&lt;/span&gt;&lt;span&gt;171&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  %rax,0x10(%rsp)
  0x0000000000488ae0&amp;lt;+&lt;/span&gt;&lt;span&gt;176&lt;/span&gt;&lt;span&gt;&amp;gt;: movq   $0xa,0x18(%rsp)
  0x0000000000488ae9&amp;lt;+&lt;/span&gt;&lt;span&gt;185&lt;/span&gt;&amp;gt;: &lt;span&gt;lea&lt;/span&gt;&lt;span&gt;  0x50(%rsp),%rax
  0x0000000000488aee&amp;lt;+&lt;/span&gt;&lt;span&gt;190&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  %rax,0x20(%rsp)
  0x0000000000488af3&amp;lt;+&lt;/span&gt;&lt;span&gt;195&lt;/span&gt;&lt;span&gt;&amp;gt;: movq  $0x1,0x28(%rsp)
  0x0000000000488afc&amp;lt;+&lt;/span&gt;&lt;span&gt;204&lt;/span&gt;&lt;span&gt;&amp;gt;: movq  $0x1,0x30(%rsp)
  0x0000000000488b05&amp;lt;+&lt;/span&gt;&lt;span&gt;213&lt;/span&gt;&lt;span&gt;&amp;gt;: callq  0x480b20 &amp;lt;fmt.Fprintf&amp;gt;
  0x0000000000488b0a&amp;lt;+&lt;/span&gt;&lt;span&gt;218&lt;/span&gt;&amp;gt;: movq  $0x0,0x70(%rsp) # r = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  # ---- 下面5条指令对应着go代码中的 return r
  0x0000000000488b13&amp;lt;+&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;&amp;gt;: &lt;span&gt;nop&lt;/span&gt;&lt;span&gt;
  0x0000000000488b14&amp;lt;+&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;&lt;span&gt;&amp;gt;: callq  0x427490 &amp;lt;runtime.deferreturn&amp;gt;
  0x0000000000488b19&amp;lt;+&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  0x60(%rsp),%rbp
  0x0000000000488b1e&amp;lt;+&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;&amp;gt;: &lt;span&gt;add&lt;/span&gt;&lt;span&gt;  $0x68,%rsp
  0x0000000000488b22&amp;lt;+&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;&lt;span&gt;&amp;gt;: retq   
  # ---------------------------
  0x0000000000488b23&amp;lt;+&lt;/span&gt;&lt;span&gt;243&lt;/span&gt;&amp;gt;: &lt;span&gt;nop&lt;/span&gt;&lt;span&gt;
  0x0000000000488b24&amp;lt;+&lt;/span&gt;&lt;span&gt;244&lt;/span&gt;&lt;span&gt;&amp;gt;: callq  0x427490 &amp;lt;runtime.deferreturn&amp;gt;
  0x0000000000488b29&amp;lt;+&lt;/span&gt;&lt;span&gt;249&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  0x60(%rsp),%rbp
  0x0000000000488b2e&amp;lt;+&lt;/span&gt;&lt;span&gt;254&lt;/span&gt;&amp;gt;: &lt;span&gt;add&lt;/span&gt;&lt;span&gt;  $0x68,%rsp
  0x0000000000488b32&amp;lt;+&lt;/span&gt;&lt;span&gt;258&lt;/span&gt;&lt;span&gt;&amp;gt;: retq   
  0x0000000000488b33&amp;lt;+&lt;/span&gt;&lt;span&gt;259&lt;/span&gt;&lt;span&gt;&amp;gt;: callq  0x44f300 &amp;lt;runtime.morestack_noctxt&amp;gt;
  0x0000000000488b38&amp;lt;+&lt;/span&gt;&lt;span&gt;264&lt;/span&gt;&amp;gt;: jmpq  0x488a30 &amp;lt;main.f&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;f() 函数本来很简单，但里面使用了闭包和 Printf，所以汇编代码看起来比较复杂，这里我们只挑重点出来说。f() 函数最后 2 条语句被编译器翻译成了如下6条汇编指令：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
  0x0000000000488b0a&amp;lt;+&lt;span&gt;218&lt;/span&gt;&amp;gt;: movq   $0x0,0x70(%rsp) # r = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;
  # ---- 下面5条指令对应着go代码中的 return r
  0x0000000000488b13&amp;lt;+&lt;/span&gt;&lt;span&gt;227&lt;/span&gt;&amp;gt;: &lt;span&gt;nop&lt;/span&gt;&lt;span&gt;
  0x0000000000488b14&amp;lt;+&lt;/span&gt;&lt;span&gt;228&lt;/span&gt;&lt;span&gt;&amp;gt;: callq  0x427490 &amp;lt;runtime.deferreturn&amp;gt;  # deferreturn会调用defer注册的函数
  0x0000000000488b19&amp;lt;+&lt;/span&gt;&lt;span&gt;233&lt;/span&gt;&amp;gt;: &lt;span&gt;mov&lt;/span&gt;&lt;span&gt;  0x60(%rsp),%rbp  # 调整栈
  0x0000000000488b1e&amp;lt;+&lt;/span&gt;&lt;span&gt;238&lt;/span&gt;&amp;gt;: &lt;span&gt;add&lt;/span&gt;&lt;span&gt;  $0x68,%rsp # 调整栈
  0x0000000000488b22&amp;lt;+&lt;/span&gt;&lt;span&gt;242&lt;/span&gt;&lt;span&gt;&amp;gt;: retq   # 从f()函数返回
  # ---------------------------&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这6条指令中的第一条指令对应到的go语句是 r = 0，因为 r = 0 之后的下一行语句是 return r ，所以这条指令相当于把 f() 函数的返回值保存到了栈上，然后第三条指令调用了 runtime.deferreturn 函数，该函数会去调用我们在 f() 函数开始处使用 defer 注册的函数修改 r 的值为200，所以我们在main函数拿到的返回值是200，后面三条指令完成函数调用栈的调整及返回。&lt;/p&gt;
&lt;p&gt;从这几条指令可以得出，准确的说，defer 函数的执行既不是在 return 之后也不是在 return 之前，而是一条go语言的 return 语句包含了对 defer 函数的调用，即 return 会被翻译成如下几条伪指令&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;保存返回值到栈上
调用defer函数
调整函数栈
retq指令返回&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;到此我们已经知道，前面说的矛盾其实并非矛盾，只是从Go语言层面来理解不好理解而已，一旦我们深入到汇编层面，一切都会显得那么自然，正所谓&lt;strong&gt;汇编之下了无秘密&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;ul class=&quot;list-paddingleft-2&quot; readability=&quot;2&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;defer 主要用于简化编程（以及实现 panic/recover ，后面会专门写一篇相关文章来介绍）&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;defer 实现了函数的延迟调用；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;defer 使用要点：&lt;strong&gt;延迟调用，即时求值和反序调用&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;go 语言的 return 会被编译器翻译成多条指令，其中包括保存返回值，调用defer注册的函数以及实现函数返回。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;本文我们主要从使用的角度介绍了defer 的基础知识，下一篇文章我们将会深入 runtime.deferproc 和 runtime.deferreturn 这两个函数分析 defer 的实现机制。&lt;/p&gt;
</description>
<pubDate>Wed, 19 Jun 2019 00:48:00 +0000</pubDate>
<dc:creator>爱写程序的阿波张</dc:creator>
<og:description>深入理解 defer 分上下两篇文章，本文为上篇，主要介绍如下内容： 为什么需要 defer； defer 语法及语义； defer 使用要点； defer 语句中的函数到底是在 return 语句之</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/abozhang/p/11049304.html</dc:identifier>
</item>
<item>
<title>Consul初探-集成ocelot - Ron.Liang</title>
<link>http://www.cnblogs.com/viter/p/11047349.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/viter/p/11047349.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;由于 Consul 的高可用性、丰富的API、友好的 Web 控制台界面等特点，Consul 的发展非常迅猛，得益于 .NETCore 社区的快速发展和社区成员的贡献，我们现在可以非常方便快速的将 Consul 集成到 .NETCore 中，在 Ocelot 的集成方面也是非常的便捷，在 API Gateway 项目中，只需要通过引用一个包，就可以在项目中服务发现了。&lt;/p&gt;
&lt;h5 id=&quot;今天要完成的架构图&quot;&gt;今天要完成的架构图&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190618195902487-1471711345.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面就是今天要完成的业务架构图，客户端、Ocelot 网关、Consul 集群、计算器服务集群，这几个模块组成了基本的分布式网关模型。&lt;/p&gt;
&lt;h2 id=&quot;建立-apigateway-项目&quot;&gt;建立 APIGateway 项目&lt;/h2&gt;
&lt;h5 id=&quot;建立空项目&quot;&gt;建立空项目&lt;/h5&gt;
&lt;p&gt;首先我们建立一个空的 Asp.NetCore WebApplication 程序，对于一个简单的网关程序来说，空项目足够了，因为我们写代码的地方不多&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190618195907396-967522331.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;ocelot-的包引用&quot;&gt;Ocelot 的包引用&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190618195912993-365205060.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们只需要引用 Ocelot.Provider.Consul ，即可完成 ocelot 和 consul 的依赖引用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190618195919735-1058213332.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;配置网关&quot;&gt;配置网关&lt;/h5&gt;
&lt;p&gt;首先，我们需要为 ocelot 网关编写一个配置文件，ocelot 的配置功能非常丰富，具体参考：&lt;a href=&quot;https://ocelot.readthedocs.io/en/latest/%EF%BC%8C%E6%9C%AC%E6%AC%A1%E6%88%91%E4%BB%AC%E5%8F%AA%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84&quot; class=&quot;uri&quot;&gt;https://ocelot.readthedocs.io/en/latest/，本次我们只编写一个最简单的&lt;/a&gt; ocelot.json 文件，该配置文件决定了客户端的请求该如何转发到从 Consul 发现到真正的服务实例中。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;{
  &quot;ReRoutes&quot;: [
    {
      &quot;UseServiceDiscovery&quot;: true, // 使用服务发现
      &quot;DownstreamPathTemplate&quot;: &quot;/{url}&quot;, // 转发路由规则
      &quot;DownstreamScheme&quot;: &quot;http&quot;, // 协议
      &quot;ServiceName&quot;: &quot;node-1&quot;, // 服务名称
      &quot;LoadBalancerOptions&quot;: { // 负载均衡的算法（这里使用平均）
        &quot;Type&quot;: &quot;RoundRobin&quot;
      },
      &quot;UpstreamPathTemplate&quot;: &quot;/{url}&quot;, //  下游请求路由
      &quot;UpstreamHttpMethod&quot;: [ &quot;Get&quot;, &quot;Post&quot; ], // 支持请求方法
      &quot;ReRoutesCaseSensitive&quot;: false // 路由大小写敏感设置
    }
  ],
  &quot;GlobalConfiguration&quot;: { // 网关全局配置
    &quot;RequestKey&quot;: &quot;OcRequestId&quot;,
    &quot;ServiceDiscoveryProvider&quot;: { // 服务发现的配置
      &quot;Host&quot;: &quot;172.16.1.218&quot;,
      &quot;Port&quot;: 8500,
      &quot;ConfigurationKey&quot;: &quot;node-1&quot;
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面就是 ocelot 网关的配置，接下来，还需要在 Startup.cs 类中进行简单的配置。&lt;/p&gt;
&lt;h5 id=&quot;进行服务注入&quot;&gt;进行服务注入&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;        public void ConfigureServices(IServiceCollection services)
        {
            var ocelotConfig = new ConfigurationBuilder().AddJsonFile(&quot;ocelot.json&quot;, false, true).Build();
            services.AddOcelot(ocelotConfig)
                    .AddConsul()
                    .AddConfigStoredInConsul();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;首先加载 ocelot.json 文件，然后将配置注入到服务中&lt;/p&gt;
&lt;h5 id=&quot;设置路由转发&quot;&gt;设置路由转发&lt;/h5&gt;
&lt;pre&gt;
&lt;code&gt;        public void Configure(IApplicationBuilder app, IHostingEnvironment env)
        {
            app.UseHttpsRedirection()
               .UseOcelot()
               .Wait();
        }&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过上面的代码，将 ocelot 注入请求管道中，到这里，配置的工作就已经完成了&lt;/p&gt;
&lt;h2 id=&quot;创建一个计算器服务&quot;&gt;创建一个计算器服务&lt;/h2&gt;
&lt;p&gt;为了演示网关转发和服务发现，我们需要构建一个简单的计算器服务，我准备使用该计算器服务运行两个实例，两个实例运行于同一台服务器上，分别侦听 12008/12009 端口，在服务启动后，该计算器服务将会自动的把自己注册到 Consul 代理服务器集群中，然后 APIGateway 网关从 Consul 发现 12008/12009 服务，并使用负载均衡的机制对两个服务进行调用。&lt;/p&gt;
&lt;p&gt;为了方便演示，这里的计算器服务就使用上一篇的代码 &lt;embed src=&quot;https://www.cnblogs.com/viter/p/11024984.html&quot;/&gt; 进行测试了&lt;/p&gt;
&lt;h5 id=&quot;运行计算器服务1200812009&quot;&gt;运行计算器服务（12008/12009）&lt;/h5&gt;
&lt;p&gt;我们需要启动两个服务实例，然后注册到 Consul 中，启动服务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190618195928675-1448415076.gif&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;查看-consul-代理服务器集群的状态&quot;&gt;查看 Consul 代理服务器集群的状态&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190618195940393-1237499435.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务注册正常&lt;/p&gt;
&lt;h5 id=&quot;启动-ocelot-网关&quot;&gt;启动 ocelot 网关&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190618195946260-1452482465.png&quot;/&gt;&lt;/p&gt;
&lt;h5 id=&quot;访问-ocelot-网关&quot;&gt;访问 Ocelot 网关&lt;/h5&gt;
&lt;p&gt;计算器服务（12008/12009） 服务实例提供的路由地址为：/home/add/{x:int}/{y:int} ，ocelot 网关的侦听地址为：&lt;a href=&quot;http://172.16.10.227:12200&quot; class=&quot;uri&quot;&gt;http://172.16.10.227:12200&lt;/a&gt; ，根据路由转发规则，ocelot 网关会把客户端的请求完整的转发到 12008/12009 服务实例上，所以我们可以通过下面的 url 请求服务，即：ocelot网关+12008/12009 路由，组合起来就是：&lt;a href=&quot;http://172.16.10.227:12200/home/add/%7Bx:int%7D/%7By:int%7D%EF%BC%8C%E9%82%A3%E4%B9%88%E7%9C%9F%E6%AD%A3%E7%9A%84%E8%AF%B7%E6%B1%82&quot; class=&quot;uri&quot;&gt;http://172.16.10.227:12200/home/add/{x:int}/{y:int}，那么真正的请求&lt;/a&gt; url 为：&lt;a href=&quot;http://172.16.10.227:12200/home/add/10/10%EF%BC%8C%E9%A2%84%E6%9C%9F%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C%E4%B8%BA%EF%BC%9A30&quot; class=&quot;uri&quot;&gt;http://172.16.10.227:12200/home/add/10/10，预期输出结果为：30&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190618195954052-1679773424.gif&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过上面的输出，可以看到，从网关到真正的服务实例，这个环节已经打通了，通过不断的刷新网页请求，下方的两个服务实例总是一前一后的持续输出日志，这就足以证明我们在 ocelot 服务网关配置的负载均衡算法 &quot;Type&quot;: &quot;RoundRobin&quot; 发挥了作用。&lt;/p&gt;
&lt;h5 id=&quot;ocelot-配置文件管理&quot;&gt;ocelot 配置文件管理&lt;/h5&gt;
&lt;p&gt;通过查看 Consul Web 控制台的界面的 Key/Value 菜单，发现 ocelot 将配置文件 ocelot.json 存储到 Consul 中了，我们可以在 Consul 中对网关进行可视化管理，修改保存即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/26882/201906/26882-20190618200000436-365676710.png&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;
&lt;p&gt;从实验结果看，在 .NETCore 中集成 APIGateway 和 Consul 还是比较简单的事情，当然，大部分的项目在项目开放进程中，大概率是不会一次性使用到这么多组件的，不过我相信，随着架构的演进，这些项目最终也不得不考虑服务注册、发现、调度、负载均衡等这些问题，引入网关，就势在必行了。&lt;/p&gt;
&lt;h2 id=&quot;netcore-集成-consul-导读&quot;&gt;.NETCore 集成 Consul 导读&lt;/h2&gt;
&lt;h2 id=&quot;源代码下载&quot;&gt;源代码下载&lt;/h2&gt;
&lt;p&gt;本文所有源代码已托管到 Github ，欢迎下载测试 &lt;a href=&quot;https://github.com/lianggx/Examples/tree/master/Ron.Consul&quot; class=&quot;uri&quot;&gt;https://github.com/lianggx/Examples/tree/master/Ron.Consul&lt;/a&gt; ，如果觉得还行，请点击 star ，谢谢支持。&lt;/p&gt;
</description>
<pubDate>Wed, 19 Jun 2019 00:32:00 +0000</pubDate>
<dc:creator>Ron.Liang</dc:creator>
<og:description>前言 由于 Consul 的高可用性、丰富的API、友好的 Web 控制台界面等特点，Consul 的发展非常迅猛，得益于 .NETCore 社区的快速发展和社区成员的贡献，我们现在可以非常方便快速的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/viter/p/11047349.html</dc:identifier>
</item>
<item>
<title>Flink DataStream 编程入门 - 渡码</title>
<link>http://www.cnblogs.com/duma/p/11033182.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/duma/p/11033182.html</guid>
<description>&lt;p&gt;&lt;span&gt;流处理是 Flink 的核心，流处理的数据集用 DataStream 表示。数据流从可以从各种各样的数据源中创建（消息队列、Socket 和 文件等），经过 DataStream 的各种 transform 操作，最终输出文件或者标准输出。这个过程跟之前文章中介绍的 Flink 程序基本骨架一样。本篇介绍 DataStream 相关的入门知识。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Flink 101&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;为了学习 Flink 的朋友能查看到每个例子的源码，我创建了一个 GitHub 项目：&lt;a href=&quot;https://github.com/duma-repo/awesome-flink&quot;&gt;https://github.com/duma-repo/awesome-flink&lt;/a&gt; 这里会存放每一篇文章比较重要的示例的源码，目前支持 Java 和 Scala，仍在不断完善中。代码下载后可以在本地运行，也可以打包放在集群上运行。同时，欢迎各位将优质的资源提交到项目中。&lt;a href=&quot;https://github.com/duma-repo/awesome-flink&quot;&gt;&lt;br/&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;简单示例&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.flink.api.common.functions.FlatMapFunction;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.flink.api.java.tuple.Tuple2;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.flink.streaming.api.datastream.DataStream;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.flink.streaming.api.windowing.time.Time;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.apache.flink.util.Collector;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; WindowWordCount {

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; main(String[] args) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {

        StreamExecutionEnvironment env &lt;/span&gt;=&lt;span&gt; StreamExecutionEnvironment.getExecutionEnvironment();

        DataStream&lt;/span&gt;&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; dataStream =&lt;span&gt; env
                .socketTextStream(&lt;/span&gt;&quot;localhost&quot;, 9999&lt;span&gt;)
                .flatMap(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; Splitter())
                .keyBy(&lt;/span&gt;0&lt;span&gt;)
                .timeWindow(Time.seconds(&lt;/span&gt;5&lt;span&gt;))
                .sum(&lt;/span&gt;1&lt;span&gt;);

        dataStream.print();

        env.execute(&lt;/span&gt;&quot;Window WordCount&quot;&lt;span&gt;);
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; Splitter &lt;span&gt;implements&lt;/span&gt; FlatMapFunction&amp;lt;String, Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt;&lt;span&gt; {
        @Override
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; flatMap(String sentence, Collector&amp;lt;Tuple2&amp;lt;String, Integer&amp;gt;&amp;gt; out) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; Exception {
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; (String word: sentence.split(&quot; &quot;&lt;span&gt;)) {
                out.collect(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt; Tuple2&amp;lt;String, Integer&amp;gt;(word, 1&lt;span&gt;)); //空格分割后，每个单词转换成 (word, 1) 二元组输出
            }
        }
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;这个例子跟之间介绍 WordCount 的例子类似，这里详细介绍下涉及的 API 和含义&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;数据源&lt;/strong&gt;：socketTextStream 是从 socket 创建的数据流，可以使用 nc -l 9000 创建 socket 客户端发送数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;transform&lt;/strong&gt;：flatMap 将输入的数据按照空格分割后，扁平化处理（flat即为扁平的意思）；keyBy 会按照指定的 key 进行分组，这里就是将单词作为 key；timeWindow 指定时间窗口，这里是 5s 处理一次；sum 是聚合函数，将分组好的单词个数求和&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;输出&lt;/strong&gt;：print 将处理完的数据输出到标准输出流中，可以在控制台看到输出的结果。调用 execute 方法提交 Job&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;Data Source&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;经过以上的介绍，我们知道常见的数据源有 socket、消息队列和文件等。对于常见的数据源 Flink 已经定义好了读取函数，接下来一一介绍。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;基于文件&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;readTextFile(path)&lt;/strong&gt;：读文本文件，默认是文件类型是 TextInputFormat，并且返回类型是 String&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;readFile(fileInputFormat, path)&lt;/strong&gt;：读文件，需要指定输入文件的格式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;readFile(fileInputFormat, path, watchType, interval, typeInfo)&lt;/strong&gt;：以上两个方法内部都会调用这个方法，参数说明：&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt; fileInputFormat - 输入文件的类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; path - 输入文件路径&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; watchType - 取值为 FileProcessingMode.PROCESS_CONTINUOUSLY 和 FileProcessingMode.PROCESS_ONCE&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;FileProcessingMode.PROCESS_CONTINUOUSLY - 当输入路径下有文件被修改，整个路径下内容将会被重新处理&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;FileProcessingMode.PROCESS_ONCE - 只扫描一次，便退出。因此这种模式下输入数据只读取一次&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; interval - 依赖 watchType 参数，对于 FileProcessingMode.PROCESS_CONTINUOUSLY 每隔固定时间（单位：毫秒）检测路径下是否有新数据&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt; typeInfo - 返回数据的类型&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;需要注意，在底层 Flink 将读文件的过程分为两个子任务 —— 文件监控和数据读取（reader）。监控任务由 1 个 task 实现，而读取的任务由多个 task 实现，数量与 Job 的并行度相同。监控任务的作用是扫描输入路径（周期性或者只扫描一次，取决于 watchType），当数据可以被处理时，会将数据分割成多个分片，将分片分配给下游的 reader 。一个分片只会被一个 reader 读取，一个 reader 可以读取多个分片。&lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;基于 Socket&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;socketTextStream&lt;/strong&gt;：从 socket 数据流中读数据&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;基于 Collection&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;fromCollection(Collection)&lt;/strong&gt;：从 Java.util.Collection 类型的数据中创建输入流，collection 中的所有元素类型必须相同&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;fromCollection(Iterator, Class)&lt;/strong&gt;：从 iterator (迭代器）中创建输入流，Class 参数指定从 iterator 中的数据类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;fromElements(T ...)&lt;/strong&gt;：从给定的参数中创建输入流， 所有参数类型必须相同&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;fromParallelCollection(SplittableIterator, Class)&lt;/strong&gt;：从 iterator 中创建并行的输入流，Class 指定 iterator 中的数据类型&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;generateSequence(from, to)&lt;/strong&gt;：从 from 至 to 之间的数据序列创建并行的数据流&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3&gt;自定义&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;addSource&lt;/strong&gt;：可以自定义输入源，通过实现 SourceFunction 接口来自定义非并行的输入流；也可以实现 ParallelSourceFunction 接口或集成 RichParallelSourceFunction 类来自定义并行输入流，当然也可以定义好的数据源，如：Kafka，addSource(new FlinkKafkaConsumer08&amp;lt;&amp;gt;(...))&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;&lt;span&gt;DataStream 的 transform&lt;/span&gt; &lt;/h2&gt;
&lt;p&gt;&lt;span&gt;之前已经介绍了一些 transfrom 函数，如：map、flatMap 和 filter 等。同时还有窗口函数：window、timeWindow 等，聚合函数：sum、reduce 等。更多的 transform 函数以及使用将会单独写一篇文章介绍。&lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;Data Sink&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;Data Sink 便是数据的输出。同 Data Source 类似， Flink 也内置了一些输出函数，如下：&lt;/span&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;&lt;span&gt;&lt;strong&gt;writeAsText&lt;/strong&gt;(path) / TextOutputFormat：将数据作为 String 类型输出到指定文件&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;writeAsCsv&lt;/strong&gt;(...) / CsvOutputFormat：将 Tuple 类型输出到 ',' 分隔的 csv 类型的文件。行和列的分隔符可以通过参数配置，默认的为 '\n' 和 ','&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;print&lt;/strong&gt;() / printToErr()：将数据打印到标准输出流或者标准错误流，可以指定打印的前缀。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;writeUsingOutputFormat&lt;/strong&gt;() / FileOutputFormat：输出到 OutputFormat 类型指定的文件，支持对象到字节的转换。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;writeToSocket&lt;/strong&gt;：根据 SerializationSchema 将数据输出到 socket &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;&lt;strong&gt;addSink&lt;/strong&gt;：自定义输出函数，如：自定义将数据输出到 Kafka&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;本篇文章主要介绍了 Flink Streaming 编程的基本骨架。详细介绍了 Streaming 内置的 Data Source 和 DataSink 。下篇将继续介绍 Flink Streaming 编程涉及的基本概念。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;代码地址： &lt;a href=&quot;https://github.com/duma-repo/awesome-flink/blob/master/chapter-2-flink-streaming/2-1-streaming-starter.md&quot;&gt;https://github.com/duma-repo/awesome-flink/blob/master/chapter-2-flink-streaming/2-1-streaming-starter.md&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;欢迎关注公众号&lt;strong/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1129006/201906/1129006-20190610224613682-287034495.png&quot; alt=&quot;&quot; width=&quot;162&quot; height=&quot;161&quot;/&gt;&lt;/strong&gt;&lt;/p&gt;

</description>
<pubDate>Wed, 19 Jun 2019 00:23:00 +0000</pubDate>
<dc:creator>渡码</dc:creator>
<og:description>流处理是 Flink 的核心，流处理的数据集用 DataStream 表示。数据流从可以从各种各样的数据源中创建（消息队列、Socket 和 文件等），经过 DataStream 的各种 transf</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/duma/p/11033182.html</dc:identifier>
</item>
<item>
<title>kubectl技巧之通过jsonpath截取属性 - 周国通</title>
<link>http://www.cnblogs.com/tylerzhou/p/11049050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/tylerzhou/p/11049050.html</guid>
<description>&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tylerzhou/p/10969041.html&quot;&gt;系列目录&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前面一节我们介绍了使用go-template截取属性,go-template功能非常强大,可以定义变量,使用流程控制等,这是jsonpath所不具备的.然而,jsonpth使用的时候更为灵活.通过上一节我们发现,我们想要找到某个具体属性,必须从最外层一层层向内找到具体属性,这对于嵌套层次非常深的yaml对象来说操作是非常繁琐的.而使用jsonpath只需要知道顶层对象,然后可以省略中间的对象,递归查找直接找到我们想要的属性,这在很多时候对我们在不清楚对象的层次但是清楚知道某个属性名称的时候获取这个属性的值是非常有帮助的.并且jsonpath可以使用下标索引数组对象,这在实际工作中也是非常有帮助的(比如虽然pod里可以包含多个containers,但是很多时候一个pod里只有一个container,使用go-template我们为了找到这个对象需要写一个遍历表达式,而使用jsonpath可以直接取第0个对象,省去了写循环的麻烦),还有一点很重要的是jsonpath是一个标准,这对于熟悉jsonpath的开发者来说使用起来方便很多.&lt;/p&gt;
&lt;p&gt;jsonpath模板使用一对花括号(&lt;code&gt;{}&lt;/code&gt;)把jsonpath表达式包含在里面(&lt;code&gt;go-template&lt;/code&gt;是双花括号).除了标准jsonpath语法外,kubernetes jsonpath模板还额外支持以下语法:&lt;/p&gt;
&lt;ul readability=&quot;0&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;用&quot;&quot;双引号来引用JSONPath表达式中的文本&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用&lt;strong&gt;range&lt;/strong&gt;和&lt;strong&gt;end&lt;/strong&gt;来遍历集合(这点和go-template类似)&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;使用负数来从尾部索引集合&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;$操作符是可选的因为表达式默认总是从根节点开始选择&lt;br/&gt;对象通过它的&lt;code&gt;String()&lt;/code&gt;函数打印输出出来&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假如有以下JSON字符串&lt;/p&gt;
&lt;pre class=&quot;json&quot;&gt;
&lt;code&gt;{
  &quot;kind&quot;: &quot;List&quot;,
  &quot;items&quot;:[
    {
      &quot;kind&quot;:&quot;None&quot;,
      &quot;metadata&quot;:{&quot;name&quot;:&quot;127.0.0.1&quot;},
      &quot;status&quot;:{
        &quot;capacity&quot;:{&quot;cpu&quot;:&quot;4&quot;},
        &quot;addresses&quot;:[{&quot;type&quot;: &quot;LegacyHostIP&quot;, &quot;address&quot;:&quot;127.0.0.1&quot;}]
      }
    },
    {
      &quot;kind&quot;:&quot;None&quot;,
      &quot;metadata&quot;:{&quot;name&quot;:&quot;127.0.0.2&quot;},
      &quot;status&quot;:{
        &quot;capacity&quot;:{&quot;cpu&quot;:&quot;8&quot;},
        &quot;addresses&quot;:[
          {&quot;type&quot;: &quot;LegacyHostIP&quot;, &quot;address&quot;:&quot;127.0.0.2&quot;},
          {&quot;type&quot;: &quot;another&quot;, &quot;address&quot;:&quot;127.0.0.3&quot;}
        ]
      }
    }
  ],
  &quot;users&quot;:[
    {
      &quot;name&quot;: &quot;myself&quot;,
      &quot;user&quot;: {}
    },
    {
      &quot;name&quot;: &quot;e2e&quot;,
      &quot;user&quot;: {&quot;username&quot;: &quot;admin&quot;, &quot;password&quot;: &quot;secret&quot;}
    }
  ]
}&lt;/code&gt;
&lt;/pre&gt;
&lt;table&gt;&lt;thead/&gt;&lt;tbody readability=&quot;12&quot;&gt;&lt;tr class=&quot;odd&quot;&gt;&lt;td&gt;text&lt;/td&gt;
&lt;td&gt;the plain text&lt;/td&gt;
&lt;td&gt;kind is {.kind}&lt;/td&gt;
&lt;td&gt;kind is List&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;@&lt;/td&gt;
&lt;td&gt;the current object&lt;/td&gt;
&lt;td&gt;{@}&lt;/td&gt;
&lt;td&gt;the same as input&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;2&quot;&gt;&lt;td&gt;. or []&lt;/td&gt;
&lt;td&gt;child operator&lt;/td&gt;
&lt;td&gt;{.kind} or {[‘kind’]}&lt;/td&gt;
&lt;td&gt;List&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;..&lt;/td&gt;
&lt;td&gt;recursive descent&lt;/td&gt;
&lt;td&gt;{..name}&lt;/td&gt;
&lt;td&gt;127.0.0.1 127.0.0.2 myself e2e&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;4&quot;&gt;&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;wildcard. Get all objects&lt;/td&gt;
&lt;td&gt;{.items[*].metadata.name}&lt;/td&gt;
&lt;td&gt;[127.0.0.1 127.0.0.2]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot;&gt;&lt;td&gt;[start:end :step]&lt;/td&gt;
&lt;td&gt;subscript operator&lt;/td&gt;
&lt;td&gt;{.users[0].name}&lt;/td&gt;
&lt;td&gt;myself&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;5&quot;&gt;&lt;td&gt;[,]&lt;/td&gt;
&lt;td&gt;union operator&lt;/td&gt;
&lt;td&gt;{.items[*][‘metadata.name’, ‘status.capacity’]}&lt;/td&gt;
&lt;td&gt;127.0.0.1 127.0.0.2 map[cpu:4] map[cpu:8]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;?()&lt;/td&gt;
&lt;td&gt;filter&lt;/td&gt;
&lt;td&gt;{.users[?(@.name==“e2e”)].user.password}&lt;/td&gt;
&lt;td&gt;secret&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;odd&quot; readability=&quot;7&quot;&gt;&lt;td&gt;range, end&lt;/td&gt;
&lt;td&gt;iterate list&lt;/td&gt;
&lt;td&gt;{range .items[*]}[{.metadata.name}, {.status.capacity}] {end}&lt;/td&gt;
&lt;td&gt;[127.0.0.1, map[cpu:4]] [127.0.0.2, map[cpu:8]]&lt;/td&gt;
&lt;/tr&gt;&lt;tr class=&quot;even&quot; readability=&quot;2&quot;&gt;&lt;td&gt;“&lt;/td&gt;
&lt;td&gt;quote interpreted string&lt;/td&gt;
&lt;td&gt;{range .items[*]}{.metadata.name}{’\t’}{end}&lt;/td&gt;
&lt;td&gt;127.0.0.1 127.0.0.2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;使用jsonpath示例&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;kubectl get pods -o json
kubectl get pods -o=jsonpath='{@}'
kubectl get pods -o=jsonpath='{.items[0]}'
kubectl get pods -o=jsonpath='{.items[0].metadata.name}'
kubectl get pods -o=jsonpath='{range .items[*]}{.metadata.name}{&quot;\t&quot;}{.status.startTime}{&quot;\n&quot;}{end}'&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;9&quot;&gt;
&lt;p&gt;如果对象是集合类型,需要使用range关键字开始,以end关键字结果,同前面一节go-template类似.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们通过以下示例来看如何通过jsonpath简单地获取到容器所在节点名称&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;[centos@k8s-master ~]$ kubectl get po consul-0 -ojsonpath='{..nodeName}'
k8s-node1
[centos@k8s-master ~]$&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;当然以上也可以通过grep来获取到同样的信息,并且对于很多熟悉linux命令的童鞋来说更为方便,如果仅仅是查看.grep确实更为方便,但是通过jsonpath是准确地获取到了一个属性的值,而grep则是截取的包含这个关键字的一行,如果我们要把获取的值作为下一个命令的的输入值时,通过grep获取的结果往往是需要处理的.例如通过grep获取到的结果如下&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;&quot;k8s-node1&quot;,[centos@k8s-master ~]$ kubectl get po consul-0 -ojson|grep nodeName
        &quot;nodeName&quot;: &quot;k8s-node1&quot;,&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里想要准备的获取结果,产生要截取第二列值,然后再去掉引号,操作起来不如jsonpath方便.尤其在不同环境如果输出的格式不一样的话,通过字符串截取得到的结果可能是错误的.&lt;/p&gt;
</description>
<pubDate>Tue, 18 Jun 2019 23:59:00 +0000</pubDate>
<dc:creator>周国通</dc:creator>
<og:description>'系列目录' 前面一节我们介绍了使用go template截取属性,go template功能非常强大,可以定义变量,使用流程控制等,这是jsonpath所不具备的.然而,jsonpth使用的时候更为</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/tylerzhou/p/11049050.html</dc:identifier>
</item>
<item>
<title>用番茄工作法提升工作效率 （三）工作任务的管理（系列完结篇） - siwei718</title>
<link>http://www.cnblogs.com/siweihz/p/11044494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/siweihz/p/11044494.html</guid>
<description>&lt;p&gt;一、本文主题&lt;/p&gt;
&lt;p&gt;    程咬金有三板斧，本文章是本系列文章的最后一篇。&lt;/p&gt;
&lt;p&gt;    将介绍工作任务的管理，主要涉及周报，月报，年报的等工作计划的管理。有人可能会有疑问：&lt;em&gt;什么？这有什么可介绍的，按照公司要求就可以了。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;    不同的企业有不同的制度、管理方式：有的是Scrum的晨会（站会），有的要求员工写周报，月度总结，年度总结，等不一而足。&lt;/p&gt;
&lt;p&gt;二、主要方法和工具&lt;/p&gt;
&lt;p&gt;    如果你是项目经理，你不仅要做好自己工作的管理，同时要做好项目组成员的任务管理，项目的计划、进度、成本等管理；&lt;/p&gt;
&lt;p&gt;    如果你是架构师，你不仅要做好公司层级架构相关的规划，平台的设计，单个项目架构相关工作；&lt;/p&gt;
&lt;p&gt;    如果你是程序员，你要做好自己一天、一周、一月的任务；&lt;/p&gt;
&lt;p&gt;    如果你是产品经理，你要做好产品相关工作，&lt;/p&gt;
&lt;p&gt;    如果你是测试......&lt;/p&gt;
&lt;p&gt;    此处，&lt;strong&gt;我们不讨论项目管理涉及的方法论、工具&lt;/strong&gt;，单单讨论&lt;strong&gt;通过番茄工作法提升个人工作的效率（公司相关工作，个人自己规划的工作）&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;    可能你在使用周报、月报、年报的相关模板（如WORD,EXCEL,也可能公司OA里面的工具）：&lt;/p&gt;
&lt;p&gt;    周工作计划：&lt;/p&gt;
&lt;p&gt;    &lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/201906/600632-20190618160208734-1534364905.png&quot; alt=&quot;&quot; width=&quot;681&quot; height=&quot;357&quot;/&gt;&lt;/p&gt;

&lt;p&gt;  月工作计划： &lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/201906/600632-20190618160303097-1477613212.png&quot; alt=&quot;&quot; width=&quot;691&quot; height=&quot;364&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实话实说，我写几年的周报（月报），感觉这类的工作报告，无法满足个人的需求。&lt;/p&gt;
&lt;p&gt;三、观念的改变和工具的使用&lt;/p&gt;
&lt;p&gt;    其实要提升工作效率，只需要&lt;strong&gt;变“被动工作”为“主动工作”&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;    可能你会说，神经病，我又不是“工作狂”。这里是要将你从一直的“忙碌”（或者浑浑噩噩）中释放出来。&lt;/p&gt;
&lt;p&gt;    秘诀就是&lt;span&gt;&lt;strong&gt;弄清楚自己一天（周、月、年）要做的事情，然后专注的去做&lt;/strong&gt;&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;    1）一天要做的事情：可能是领导分配的工作，也可能是自己拟定的计划。&lt;/p&gt;
&lt;p&gt;        单个工作项的工作量不要太高（或太低），如果太高，就需要任务分解到多天完成。&lt;/p&gt;
&lt;p&gt;        任务的管理，可以用本系列第一篇文章涉及的工具和方法：&lt;/p&gt;
&lt;p&gt;        &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl01_DayList_TitleUrl_1&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/siweihz/p/11038407.html&quot;&gt;用番茄工作法提升工作效率 （一）关于任务清单（含工具代码分享）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;    2）专注：用本系列文章的第二篇即可&lt;/p&gt;
&lt;p&gt;        &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/siweihz/p/11043251.html&quot;&gt;用番茄工作法提升工作效率 （二）用番茄钟实现劳逸结合（简单到不可相信）&lt;/a&gt;&lt;br/&gt;     3）工具和技巧：非常简单，一个Word搞定&lt;/p&gt;
&lt;p&gt;       比如我2018年度，就用了“工作日报2018年度.docx”。该Word，主要包括年度、月度的工作安排，然后就是每天的工作项。&lt;/p&gt;
&lt;p&gt;      对于桌面上的所有任务，完成后就删除，在本Word中标记完成即可。&lt;/p&gt;

&lt;p&gt;具体如下：    &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/201906/600632-20190619062812774-2022185631.png&quot; alt=&quot;&quot; width=&quot;647&quot; height=&quot;265&quot;/&gt;&lt;/p&gt;

&lt;p&gt;    每天的工作记录：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/600632/201906/600632-20190619062549551-923654397.png&quot; alt=&quot;&quot; width=&quot;662&quot; height=&quot;237&quot;/&gt;&lt;/p&gt;

&lt;p&gt;四、总结&lt;/p&gt;
&lt;p&gt;    该系列三篇文章，按照结构化编程的思想（自顶向下，逐步分解），用番茄工作法来解决如何提升工作效率的问题。&lt;/p&gt;
&lt;p&gt;    1. 在同一个Word中记录年度、月度、周的工作清单（该清单根据需要随时调整，根据个人喜好，可以只有周清单，也可以只有月度清单）；&lt;/p&gt;
&lt;p&gt;        将每周（每月）的工作清单，分解到每一天中。每一个工作项，时间30分钟左右。&lt;/p&gt;
&lt;p&gt;    2. 将当天需要完成的工作项，通过本系列介绍的工具放到桌面上； &lt;/p&gt;
&lt;p&gt;        对于完成的工作项，从桌面列表中删除，同时对Word文档中的工作项标记完成。&lt;/p&gt;
&lt;p&gt;    3. 对于每一个工作项，应用本系列介绍的番茄时钟，通过专注提升效率&lt;/p&gt;
&lt;p&gt;        劳逸结合，立即行动，拒绝拖延。&lt;/p&gt;
&lt;p&gt;        本系列，也适用于提醒，比如大量琐碎的事项的记录。&lt;/p&gt;

</description>
<pubDate>Tue, 18 Jun 2019 22:14:00 +0000</pubDate>
<dc:creator>siwei718</dc:creator>
<og:description>一、本文主题 程咬金有三板斧，本文章是本系列文章的最后一篇。 将介绍工作任务的管理，主要涉及周报，月报，年报的等工作计划的管理。有人可能会有疑问：什么？这有什么可介绍的，按照公司要求就可以了。 不同的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/siweihz/p/11044494.html</dc:identifier>
</item>
<item>
<title>spark源码解析--Shuffle输出追踪者--MapOutputTracker - _朱葛</title>
<link>http://www.cnblogs.com/zhuge134/p/11048963.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhuge134/p/11048963.html</guid>
<description>&lt;p&gt;这个组件作为shuffle的一个辅助组件，在整个shuffle模块中具有很重要的作用。我们在前面一系列的分析中，或多或少都会提到这个组件，比如在DAGScheduler提交一个stage时会将这个stage封装成一个任务集（TaskSet），但是可能有的分区已经计算过了，有了结果（stage由于失败可能会多次提交，其中有部分task可能已经计算完成），这些分区就不需要再次计算，而只需要计算那些失败的分区，那么很显然需要有一个组件来维护shuffle过程中的任务失败成功的状态，以及计算结果的位置信息。&lt;br/&gt;此外，在shuffle读取阶段，我们知道一个reduce端的分区会依赖于多个map端的分区的输出数据，那么我们在读取一个reduce分区对应的数据时，就需要知道这个reduce分区依赖哪些map分区，每个block的物理位置是什么，blockId是什么，这个block中属于这个reduce分区的数据量大小是多少，这些信息的记录维护都是靠MapOutputTracker来实现的，所以我们现在知道MapOutputTracker的重要性了。&lt;/p&gt;
&lt;h2 id=&quot;mapoutputtracker.scala&quot;&gt;MapOutputTracker.scala&lt;/h2&gt;
&lt;p&gt;MapOutputTracker组件的主要功能类和辅助类全部在这个文件中，我先大概说一下各个类的主要作用，然后重点分析关键的类。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ShuffleStatus，这个类是对一个stage的shuffle输出状态的封装，它内部的一个主要的成员mapStatuses是一个数组，这个数组的下标就是map的分区序号，存放了每个map分区的输出情况，关于MapStatus具体可以看MapStatus.scala，这里不打算展开。&lt;/li&gt;
&lt;li&gt;MapOutputTrackerMessage，用于rpc请求的消息类，有两个实现类：GetMapOutputStatuses用于获取某次shuffle的所有输出状态；StopMapOutputTracker用于向driver端的发送停止MapOutputTrackerMasterEndpoint端点的请求。&lt;/li&gt;
&lt;li&gt;MapOutputTrackerMasterEndpoint，如果熟悉spark的rpc模块的话，对这个类应该就很熟悉，它就是一个rpc服务端，通过向RpcEnv注册自己，通过一个名称标识自己，从而接收到特定一些消息，也就是上面说的两种消息。&lt;/li&gt;
&lt;li&gt;MapOutputTracker，这个类是一个抽象类，只是定义了一些操作接口，它的一个最重要的作用可能就是内部维护了一个序列值epoch，这个值表示某一个一致的全局map输出状态，一旦有map输出发生变更，这个值就要加一，executor端会同步最新的epoch以判断自己的map输出状态的缓存是否过期。&lt;/li&gt;
&lt;li&gt;MapOutputTrackerMaster，运行在driver端，实现类MapOutputTracker的大部分功能，是最核心的类&lt;/li&gt;
&lt;li&gt;MapOutputTrackerWorker，运行在executor端，主要作用是封装了rpc调用的逻辑。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;总的来看，最核心的类是MapOutputTrackerMaster，其他的类都是围绕这个类的一些辅助类，所以我们重点分析MapOutputTrackerMaster，其他的类我不打算深入展开，相信读者自己也能够较为轻松地理解。&lt;/p&gt;
&lt;h2 id=&quot;mapoutputtrackermaster&quot;&gt;MapOutputTrackerMaster&lt;/h2&gt;
&lt;h3 id=&quot;findmissingpartitions&quot;&gt;findMissingPartitions&lt;/h3&gt;
&lt;p&gt;这个方法在上面已经提到了，会在DAGScheduler封装任务集的时候查找一个stage需要计算的分区时会调用到。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;   def findMissingPartitions(shuffleId: Int): Option[Seq[Int]] = {
   shuffleStatuses.get(shuffleId).map(_.findMissingPartitions())
   }&lt;/code&gt;
&lt;/pre&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;ShuffleStatus.findMissingPartitions&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;  def findMissingPartitions(): Seq[Int] = synchronized {
  val missing = (0 until numPartitions).filter(id =&amp;gt; mapStatuses(id) == null)
  assert(missing.size == numPartitions - _numAvailableOutputs,
    s&quot;${missing.size} missing, expected ${numPartitions - _numAvailableOutputs}&quot;)
  missing
  }&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这两段代码很简单，不用多说，就是从map结构中查找。&lt;/p&gt;
&lt;p&gt;此外，像registerShuffle，registerMapOutput，unregisterMapOutput，unregisterShuffle，removeOutputsOnHost等等，我们可以看到这几个方法本身都是很简答的，无非就是对内部map结构的插入，更新和查找，关键的是你要清楚这些方法的调用时机是什么？弄清这一点，会让我们对MapOutputTracker在整个spark框架中的作用和充当的角色有更深的理解。方法的调用地点，通过Idea这类IDE工具其实都可以很简单地定位到，这里我不做过多展开，仅仅简单地概括一下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;registerShuffle， DAGScheduler在创建一个ShuffleMapStage时会顺便把这个stage对应的shuffle注册进来。&lt;/li&gt;
&lt;li&gt;registerMapOutput， 在一个shuffleMapTask任务完成后，会把map输出的信息注册进来。&lt;/li&gt;
&lt;li&gt;removeOutputsOnHost，将某个host上的相关map输出信息全部移除，一般在主机丢失时调用此操作&lt;/li&gt;
&lt;li&gt;removeOutputsOnExecutor，同样地，将某个executor上的相关map输出信息全部移除，一般在executor丢失时调用此操作&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;getmapsizesbyexecutorid&quot;&gt;getMapSizesByExecutorId&lt;/h3&gt;
&lt;p&gt;我们来看另一个比较重要的方法，在reduce阶段读取数据时，一个task首先需要知道它依赖于哪些map输出，这时它回想driver端的MapOutputTrackerMasterEndpoint组件发送一个获取map输出的消息，经过一系列方法调用最终会调用这个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def getMapSizesByExecutorId(shuffleId: Int, startPartition: Int, endPartition: Int)
  : Seq[(BlockManagerId, Seq[(BlockId, Long)])] = {
logDebug(s&quot;Fetching outputs for shuffle $shuffleId, partitions $startPartition-$endPartition&quot;)
shuffleStatuses.get(shuffleId) match {
  case Some (shuffleStatus) =&amp;gt;
    // 将所有的mapStatus数组转换成(BlockManagerId, Seq[(BlockId, Long)])对象
    shuffleStatus.withMapStatuses { statuses =&amp;gt;
      MapOutputTracker.convertMapStatuses(shuffleId, startPartition, endPartition, statuses)
    }
  case None =&amp;gt;
    Seq.empty
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们看一下：MapOutputTracker.convertMapStatuses，这个方法也很简单，其实就是将每个map分区输出切分成reduce分区数量，最后产生的(BlockId, Long)元组数量等于map分区数量*reduce分区数量。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def convertMapStatuses(
  shuffleId: Int,
  startPartition: Int,
  endPartition: Int,
  statuses: Array[MapStatus]): Seq[(BlockManagerId, Seq[(BlockId, Long)])] = {
assert (statuses != null)
// 用于存放结果
val splitsByAddress = new HashMap[BlockManagerId, ArrayBuffer[(BlockId, Long)]]
// 最后产生的(BlockId, Long)元组数量等于map分区数量*reduce分区数量
for ((status, mapId) &amp;lt;- statuses.zipWithIndex) {
  if (status == null) {
    val errorMessage = s&quot;Missing an output location for shuffle $shuffleId&quot;
    logError(errorMessage)
    throw new MetadataFetchFailedException(shuffleId, startPartition, errorMessage)
  } else {
    for (part &amp;lt;- startPartition until endPartition) {
      splitsByAddress.getOrElseUpdate(status.location, ArrayBuffer()) +=
        ((ShuffleBlockId(shuffleId, mapId, part), status.getSizeForBlock(part)))
    }
  }
}

splitsByAddress.toSeq
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;getpreferredlocationsforshuffle&quot;&gt;getPreferredLocationsForShuffle&lt;/h3&gt;
&lt;p&gt;我们来看另外一个比较重要的方法。我们知道reduce端的分区一般会依赖于多个map端分区输出，但是对于每个map分区依赖的数据量是不同的，举个极端的例子，假设reduce端某个分区依赖于10个map端的输出分区，但是其中一个分区依赖的数据有10000条，而其他分区依赖的数据只有1条，这种情况下，显然我们应该吧这个reduce任务优先调度到那个依赖了10000条的executor上。当然这个例子举得很简单，可能也不是什么准确，但是也足够说明这个方法的作用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def getPreferredLocationsForShuffle(dep: ShuffleDependency[_, _, _], partitionId: Int)
  : Seq[String] = {
// 首先判断几个参数配置，如果都符合条件，那么再进行偏向位置的计算
if (shuffleLocalityEnabled &amp;amp;&amp;amp; dep.rdd.partitions.length &amp;lt; SHUFFLE_PREF_MAP_THRESHOLD &amp;amp;&amp;amp;
    dep.partitioner.numPartitions &amp;lt; SHUFFLE_PREF_REDUCE_THRESHOLD) {
  // 关键调用
  val blockManagerIds = getLocationsWithLargestOutputs(dep.shuffleId, partitionId,
    dep.partitioner.numPartitions, REDUCER_PREF_LOCS_FRACTION)
  if (blockManagerIds.nonEmpty) {
    blockManagerIds.get.map(_.host)
  } else {
    Nil
  }
} else {
  Nil
}
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看出来，关键的方法是getLocationsWithLargestOutputs，接下来，我们就来看一下这个方法：&lt;br/&gt;注释已经说得很清楚，这个方法的逻辑很简单，比如一个reduce端分区要读取的总数据量是100m, 某个executor上的所有map输出中与这个reduce分区相关的数据加起来有20m，即超过了总量的0.2，这时这个executor就能够成为偏向位置，是不是很简单。但是这里应该注意到一个问题，这个方法是以executor为最小单位计算偏向位置，而在前一个方法getPreferredLocationsForShuffle中，获取到成为偏向位置的那些BlockManagerId后，仅仅是取出了host作为偏向位置返回给上层调用者，问题在于一个host(即物理节点)上可能有多个executor，这就会造成返回的结果中会有重复的host，；另外，既然返回host作为偏向位置，那为什么不直接以host作为最小单位来计算偏向位置呢，比如将一个host上所有与这个reduce分区相关的数据加起来，如果超过0.2的占比就认为这个host能够作为偏向位置，这样好像更合理，也更容易产生偏向位置。举个极端的例子，一个host上运行了5个executor，每个executor与分区相关的数据占比0.1，另外有5个host上每个都只运行了一个executor，他们的数据占比均为0.1，这种情况下是不会产生偏向位置的，但是实际上显然应该将那个拥有5个executor的host作为偏向位置。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def getLocationsWithLargestOutputs(
  shuffleId: Int,
  reducerId: Int,
  numReducers: Int,
  fractionThreshold: Double)
: Option[Array[BlockManagerId]] = {

val shuffleStatus = shuffleStatuses.get(shuffleId).orNull
// 对shuffleStatus非空检查
if (shuffleStatus != null) {
  shuffleStatus.withMapStatuses { statuses =&amp;gt;
    // 对mapStatus数组的非空检查
    if (statuses.nonEmpty) {
      // HashMap to add up sizes of all blocks at the same location
      // 记录每个executor上的所有map输出的block中属于这个reduce端分区的数据量
      val locs = new HashMap[BlockManagerId, Long]
      var totalOutputSize = 0L
      var mapIdx = 0
      while (mapIdx &amp;lt; statuses.length) {
        val status = statuses(mapIdx)
        // status may be null here if we are called between registerShuffle, which creates an
        // array with null entries for each output, and registerMapOutputs, which populates it
        // with valid status entries. This is possible if one thread schedules a job which
        // depends on an RDD which is currently being computed by another thread.
        if (status != null) {
          val blockSize = status.getSizeForBlock(reducerId)
          if (blockSize &amp;gt; 0) {
            locs(status.location) = locs.getOrElse(status.location, 0L) + blockSize
            totalOutputSize += blockSize
          }
        }
        mapIdx = mapIdx + 1
      }
      // 最后，判断一个executor能否成为偏向位置的条件是：
      // 这个executor上所有与这个reduce分区相关的数据大小与这个分区数据总量的比值是否大于一个阈值
      // 这个阈值默认是0.2
      val topLocs = locs.filter { case (loc, size) =&amp;gt;
        size.toDouble / totalOutputSize &amp;gt;= fractionThreshold
      }
      // Return if we have any locations which satisfy the required threshold
      if (topLocs.nonEmpty) {
        return Some(topLocs.keys.toArray)
      }
    }
  }
}
None
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;国际惯例，再晚也要总结一下。我们简单总结一下map输出追踪器的作用：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;维护所有shuffle的map输出状态信息，位置信息等&lt;/li&gt;
&lt;li&gt;查找某个stage还有哪些未计算的分区&lt;/li&gt;
&lt;li&gt;获取reduce分区的偏向位置&lt;/li&gt;
&lt;li&gt;获取reduce分区依赖哪些map输出，他们的位置，每个map输出中相关数据的大小&lt;/li&gt;
&lt;/ul&gt;</description>
<pubDate>Tue, 18 Jun 2019 17:29:00 +0000</pubDate>
<dc:creator>_朱葛</dc:creator>
<og:description>Shuffle输出追踪者 MapOutputTracker 这个组件作为shuffle的一个辅助组件，在整个shuffle模块中具有很重要的作用。我们在前面一系列的分析中，或多或少都会提到这个组件，比</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhuge134/p/11048963.html</dc:identifier>
</item>
<item>
<title>OpenGL ES 入门 - SharpCJ</title>
<link>http://www.cnblogs.com/joy99/p/11048881.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/joy99/p/11048881.html</guid>
<description>&lt;p&gt;记录一下 OpenGL ES Android 开发的入门教程。逻辑性可能不那么强，想到哪写到哪。也可能自己的一些理解有误。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;blockquote readability=&quot;4.390243902439&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://learnopengl-cn.github.io/&quot;&gt;LearnOpenGL CN&lt;/a&gt;&lt;br/&gt;&lt;a href=&quot;https://developer.android.google.cn/guide/topics/graphics/opengl?hl=en&quot;&gt;Android官方文档&lt;/a&gt;&lt;br/&gt;《OpenGL ES应用开发实践指南Android卷》&lt;br/&gt;《OpenGL ES 3.0 编程指南第2版》&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;目前android 4.3或以上支持opengles 3.0，但目前很多运行android 4.3系统的硬件能支持opengles 3.0的也是非常少的。不过,opengles 3.0是向后兼容的，当程序发现硬件不支持opengles 3.0时则会自动调用opengles 2.0的API。Andorid 中使用 OpenGLES 有两种方式，一种是基于Android框架API， 另一种是基于 Native Development Kit（NDK）使用 OpenGL。本文介绍Android框架接口。&lt;/p&gt;

&lt;p&gt;本文写一个最基本的三角形绘制，来说明一下 OpenGL ES 的基本流程，以及注意点。&lt;/p&gt;
&lt;h2 id=&quot;创建一个-android-工程在-androidmanifest.xml-文件中声明使用-opengles3.0&quot;&gt;2.1 创建一个 Android 工程，在 AndroidManifest.xml 文件中声明使用 opengles3.0&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;!-- Tell the system this app requires OpenGL ES 3.0. --&amp;gt;
&amp;lt;uses-feature android:glEsVersion=&quot;0x00030000&quot; android:required=&quot;true&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果程序中使用了纹理压缩的话，还需进行如下声明，以防止不支持这些压缩格式的设备尝试运行程序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;lt;supports-gl-texture android:name=&quot;GL_OES_compressed_ETC1_RGB8_texture&quot; /&amp;gt;
&amp;lt;supports-gl-texture android:name=&quot;GL_OES_compressed_paletted_texture&quot; /&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;mainactivity-使用-glsurfaceview&quot;&gt;2.2 MainActivity 使用 GLSurfaceView&lt;/h2&gt;
&lt;p&gt;MainActivity.java 代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.openglesdemo;

import android.app.ActivityManager;
import android.content.Context;
import android.content.pm.ConfigurationInfo;
import android.opengl.GLSurfaceView;
import android.os.Build;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.util.Log;

public class MainActivity extends AppCompatActivity {
    private static final String TAG = MainActivity.class.getSimpleName();

    private GLSurfaceView mGlSurfaceView;
    private boolean mRendererSet;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
//        setContentView(R.layout.activity_main);
        if (!checkGlEsSupport(this)) {
            Log.d(TAG, &quot;Device is not support OpenGL ES 2&quot;);
            return;
        }
        mGlSurfaceView = new GLSurfaceView(this);
        mGlSurfaceView.setEGLContextClientVersion(2);
        mGlSurfaceView.setEGLConfigChooser(8, 8, 8, 8, 16, 0);
        mGlSurfaceView.setRenderer(new MyRenderer(this));
        setContentView(mGlSurfaceView);
        mRendererSet = true;
    }

    @Override
    protected void onPause() {
        super.onPause();
        if (mRendererSet) {
            mGlSurfaceView.onPause();
        }
    }

    @Override
    protected void onResume() {
        super.onResume();
        if (mRendererSet) {
            mGlSurfaceView.onResume();
        }
    }

    /**
     * 检查设备是否支持 OpenGLEs 2.0
     *
     * @param context 上下文环境
     * @return 返回设备是否支持 OpenGLEs 2.0
     */
    public boolean checkGlEsSupport(Context context) {
        final ActivityManager activityManager = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
        final ConfigurationInfo configurationInfo = activityManager.getDeviceConfigurationInfo();
        final boolean supportGlEs2 = configurationInfo.reqGlEsVersion &amp;gt;= 0x20000
                || (Build.VERSION.SDK_INT &amp;gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH_MR1
                &amp;amp;&amp;amp; (Build.FINGERPRINT.startsWith(&quot;generic&quot;)
                || Build.FINGERPRINT.startsWith(&quot;unknown&quot;)
                || Build.MODEL.contains(&quot;google_sdk&quot;)
                || Build.MODEL.contains(&quot;Emulator&quot;)
                || Build.MODEL.contains(&quot;Andorid SDK built for x86&quot;)));
        return supportGlEs2;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;关键步骤：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;创建一个 GLSurfaceView 对象&lt;/li&gt;
&lt;li&gt;给GLSurfaceView 对象设置 Renderer 对象&lt;/li&gt;
&lt;li&gt;调用 &lt;code&gt;setContentView()&lt;/code&gt; 方法，传入 GLSurfaceView 对象。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;实现-surfaceview.renderer-接口中的方法&quot;&gt;2.3 实现 SurfaceView.Renderer 接口中的方法&lt;/h2&gt;
&lt;p&gt;创建一个类，实现 &lt;code&gt;GLSurfaceView.Renderer&lt;/code&gt; 接口，并实现其中的关键方法&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.openglesdemo;

import android.content.Context;
import android.opengl.GLSurfaceView;

import javax.microedition.khronos.egl.EGLConfig;
import javax.microedition.khronos.opengles.GL10;

import static android.opengl.GLES30.*;


public class MyRenderer implements GLSurfaceView.Renderer {
    private Context mContext;
    private MyTriangle mTriangle;

    public MyRenderer(Context mContext) {
        this.mContext = mContext;
    }

    @Override
    public void onSurfaceCreated(GL10 gl, EGLConfig config) {
        glClearColor(1.0f, 1.0f, 1.0f, 1.0f);
        mTriangle = new MyTriangle(mContext);
    }

    @Override
    public void onSurfaceChanged(GL10 gl, int width, int height) {
        glViewport(0, 0, width, height);
    }

    @Override
    public void onDrawFrame(GL10 gl) {
        glClear(GL_COLOR_BUFFER_BIT);
        mTriangle.draw();
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;三个关键方法：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;onSurfaceCreated() - 在View的OpenGL环境被创建的时候调用。&lt;/li&gt;
&lt;li&gt;onSurfaceChanged() - 如果视图的几何形状发生变化（例如，当设备的屏幕方向改变时），则调用此方法。&lt;/li&gt;
&lt;li&gt;onDrawFrame() - 每一次View的重绘都会调用&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;14&quot;&gt;
&lt;p&gt;glViewport(0, 0, width, height); 用于设置视口。&lt;br/&gt;glCrearColor(1.0f, 1.0f, 1.0f, 1.0f) 方法用指定颜色（这里是白色）清空屏幕。&lt;br/&gt;在 onDrawFrame 中调用 glClearColor(GL_COLOR_BUFFER_BIT) ，擦除屏幕现有的绘制，并用之前的颜色清空屏幕。 该方法中一定要绘制一些东西，即便只是清空屏幕，因为该方法调用后会交换缓冲区，并显示在屏幕上，否则可能会出现闪烁。该例子中将具体的绘制封装在了 Triangle 类中的 &lt;code&gt;draw&lt;/code&gt; 方法中了。&lt;br/&gt;注意：在 windows 版的 OpenGL 中，需要手动调用 &lt;code&gt;glfwSwapBuffers(window)&lt;/code&gt; 来交换缓冲区。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;opengl-es-的关键绘制流程&quot;&gt;2.4 OpenGL ES 的关键绘制流程&lt;/h2&gt;
&lt;p&gt;创建 &lt;code&gt;MyTriangle.java&lt;/code&gt; 类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.openglesdemo;

import android.content.Context;

import com.sharpcj.openglesdemo.util.ShaderHelper;
import com.sharpcj.openglesdemo.util.TextResourceReader;

import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.FloatBuffer;

import static android.opengl.GLES30.*;

public class MyTriangle {
    private final FloatBuffer mVertexBuffer;

    static final int COORDS_PER_VERTEX = 3;  // number of coordinates per vertex in this array
    static final int COLOR_PER_VERTEX = 3;  // number of coordinates per vertex in this array

    static float triangleCoords[] = {   // in counterclockwise order:
            0.0f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f,     // top
            -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f,   // bottom left
            0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f     // bottom right
    };


    private Context mContext;
    private int mProgram;

    public MyTriangle(Context context) {
        mContext = context;
        // initialize vertex byte buffer for shape coordinates
        mVertexBuffer = ByteBuffer.allocateDirect(triangleCoords.length * 4).order(ByteOrder.nativeOrder()).asFloatBuffer();
        mVertexBuffer.put(triangleCoords);  // add the coordinates to the FloatBuffer
        mVertexBuffer.position(0);  // set the buffer to read the first coordinate

        String vertexShaderCode = TextResourceReader.readTextFileFromResource(mContext, R.raw.simple_vertex_glsl);
        String fragmentShaderCode = TextResourceReader.readTextFileFromResource(mContext, R.raw.simple_fragment_glsl);

        int vertexShader = ShaderHelper.compileVertexShader(vertexShaderCode);
        int fragmentShader = ShaderHelper.compileFragmentShader(fragmentShaderCode);

        mProgram = ShaderHelper.linkProgram(vertexShader, fragmentShader);
    }

    public void draw() {
        if (!ShaderHelper.validateProgram(mProgram)) {
            glDeleteProgram(mProgram);
            return;
        }
        glUseProgram(mProgram);  // Add program to OpenGL ES environment

//        int aPos = glGetAttribLocation(mProgram, &quot;aPos&quot;);  // get handle to vertex shader's vPosition member
        mVertexBuffer.position(0);
        glVertexAttribPointer(0, COORDS_PER_VERTEX, GL_FLOAT, false, (COORDS_PER_VERTEX + COLOR_PER_VERTEX) * 4, mVertexBuffer);  // Prepare the triangle coordinate data
        glEnableVertexAttribArray(0);  // Enable a handle to the triangle vertices

//        int aColor = glGetAttribLocation(mProgram, &quot;aColor&quot;);
        mVertexBuffer.position(3);
        glVertexAttribPointer(1, COORDS_PER_VERTEX, GL_FLOAT, false, (COORDS_PER_VERTEX + COLOR_PER_VERTEX) * 4, mVertexBuffer);  // Prepare the triangle coordinate data
        glEnableVertexAttribArray(1);

        // Draw the triangle
        glDrawArrays(GL_TRIANGLES, 0, 3);

    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在该类中，我们使用了，两个工具类：&lt;br/&gt;&lt;code&gt;TextResourceReader.java&lt;/code&gt;, 用于读取文件的类容，返回一个字符串，准确说，它与 OpenGL 本身没有关系。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.openglesdemo.util;

import android.content.Context;
import android.content.res.Resources;
import android.util.Log;

import java.io.BufferedReader;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;

public class TextResourceReader {

    private static String TAG = &quot;TextResourceReader&quot;;

    public static String readTextFileFromResource(Context context, int resourceId) {
        StringBuilder body = new StringBuilder();
        InputStream inputStream = null;
        InputStreamReader inputStreamReader = null;
        BufferedReader bufferedReader = null;
        try {
            inputStream = context.getResources().openRawResource(resourceId);
            inputStreamReader = new InputStreamReader(inputStream);
            bufferedReader = new BufferedReader(inputStreamReader);
            String nextLine;
            while ((nextLine = bufferedReader.readLine()) != null) {
                body.append(nextLine);
                body.append(&quot;\n&quot;);
            }
        } catch (IOException e) {
            throw new RuntimeException(&quot;Could not open resource: &quot; + resourceId, e);
        } catch (Resources.NotFoundException nfe) {
            throw new RuntimeException(&quot;Resource not found: &quot; + resourceId, nfe);
        } finally {
            closeStream(inputStream);
            closeStream(inputStreamReader);
            closeStream(bufferedReader);
        }
        return body.toString();
    }

    private static void closeStream(Closeable c) {
        if (c != null) {
            try {
                c.close();
            } catch (IOException e) {
                Log.e(TAG, e.getMessage());
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ShaderHelper.java&lt;/code&gt; 着色器的工具类，这个跟 OpenGL 就有非常大的关系了。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;package com.sharpcj.openglesdemo.util;

import android.util.Log;

import static android.opengl.GLES30.*;

public class ShaderHelper {
    private static final String TAG = &quot;ShaderHelper&quot;;

    public static int compileVertexShader(String shaderCode) {
        return compileShader(GL_VERTEX_SHADER, shaderCode);
    }

    public static int compileFragmentShader(String shaderCode) {
        return compileShader(GL_FRAGMENT_SHADER, shaderCode);
    }

    private static int compileShader(int type, String shaderCode) {
        final int shaderObjectId = glCreateShader(type);
        if (shaderObjectId == 0) {
            Log.w(TAG, &quot;could not create new shader.&quot;);
            return 0;
        }
        glShaderSource(shaderObjectId, shaderCode);
        glCompileShader(shaderObjectId);

        final int[] compileStatus = new int[1];
        glGetShaderiv(shaderObjectId, GL_COMPILE_STATUS, compileStatus, 0);
        /*Log.d(TAG, &quot;Results of compiling source: &quot; + &quot;\n&quot; + shaderCode + &quot;\n: &quot;
                + glGetShaderInfoLog(shaderObjectId));*/

        if (compileStatus[0] == 0) {
            glDeleteShader(shaderObjectId);
            Log.w(TAG, &quot;Compilation of shader failed.&quot;);
            return 0;
        }
        return shaderObjectId;
    }

    public static int linkProgram(int vertexShaderId, int fragmentShaderId) {
        final int programObjectId = glCreateProgram();
        if (programObjectId == 0) {
            Log.w(TAG, &quot;could not create new program&quot;);
            return 0;
        }
        glAttachShader(programObjectId, vertexShaderId);
        glAttachShader(programObjectId, fragmentShaderId);
        glLinkProgram(programObjectId);
        final int[] linkStatus = new int[1];
        glGetProgramiv(programObjectId, GL_LINK_STATUS, linkStatus, 0);
        /*Log.d(TAG, &quot;Results of linking program: \n&quot;
                + glGetProgramInfoLog(programObjectId));*/
        if (linkStatus[0] == 0) {
            glDeleteProgram(programObjectId);
            Log.w(TAG, &quot;Linking of program failed&quot;);
            return 0;
        }
        return programObjectId;
    }

    public static boolean validateProgram(int programId) {
        glValidateProgram(programId);
        final int[] validateStatus = new int[1];
        glGetProgramiv(programId, GL_VALIDATE_STATUS, validateStatus, 0);
        /*Log.d(TAG, &quot;Results of validating program: &quot; + validateStatus[0]
                + &quot;\n Log: &quot; + glGetProgramInfoLog(programId));*/
        return validateStatus[0] != 0;
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;着色器是 OpenGL 里面非常重要的概念，这里我先把代码贴上来，然后来讲流程。&lt;br/&gt;在 res/raw 文件夹下，我们创建了两个着色器文件。&lt;br/&gt;顶点着色器，&lt;code&gt;simple_vertex_shader.glsl&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#version 330

layout (location = 0) in vec3 aPos;   // 位置变量的属性位置值为 0
layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1

out vec3 vColor; // 向片段着色器输出一个颜色

void main()
{
    gl_Position = vec4(aPos.xyz, 1.0);
    vColor = aColor; // 将ourColor设置为我们从顶点数据那里得到的输入颜色
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;片段着色器， &lt;code&gt;simple_fragment_shader.glsl&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#version 330
precision mediump float;

in vec3 vColor;

out vec4 FragColor;

void main()
{
    FragColor = vec4(vColor, 1.0);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;全部的代码就只这样了,具体绘制过程下面来说。运行程序，我们看到效果如下：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201906/758949-20190619004538755-698638252.gif&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201906/758949-20190619004613553-1224029981.png&quot;/&gt;&lt;br/&gt;一张图说明 OpenGL 渲染过程：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201906/758949-20190619004631873-805615489.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们看 &lt;code&gt;MyTriangle.java&lt;/code&gt; 这个类。&lt;br/&gt;要绘制三角形，我们肯定要定义三角形的顶点坐标和颜色。(废话，不然GPU怎么知道用什么颜色绘制在哪里)。&lt;br/&gt;首先我们定义了一个 float 型数组：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;static float triangleCoords[] = {   // in counterclockwise order:
            0.0f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f,     // top
            -0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f,   // bottom left
            0.5f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f     // bottom right
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;这个数组中，定义了 top， bottom left, bottom right 三个点。每个点包含六个数据，前三个数表示顶点坐标，后三个点表示颜色的 RGB 值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;坐标系统&quot;&gt;坐标系统&lt;/h3&gt;
&lt;p&gt;可能注意到了，因为我们这里绘制最简单的平面二维图像，Z 轴坐标都为 0 ，屏幕中的 X， Y 坐标点都是在（-1,1）的范围。我们没有对视口做任何变换，设置的默认视口，此时的坐标系统是以屏幕正中心为坐标原点。 屏幕最左为 X 轴 -1 , 屏幕最右为 X 轴 +1。同理，屏幕最下方为 Y 轴 -1， 屏幕最上方为 Y 轴 +1。OpenGL 坐标系统使用的是右手坐标系，Z 轴正方向为垂直屏幕向外。&lt;/p&gt;
&lt;h2 id=&quot;复制数据到本地内存&quot;&gt;3.1 复制数据到本地内存&lt;/h2&gt;
&lt;pre&gt;
&lt;code&gt;mVertexBuffer = ByteBuffer.allocateDirect(triangleCoords.length * 4).order(ByteOrder.nativeOrder()).asFloatBuffer();
mVertexBuffer.put(triangleCoords);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这一行代码，作用是将数据从 java 堆复制到本地堆。我们知道，在 java 虚拟机内存模型中，数组存在 java 堆中，受 JVM 垃圾回收机制影响，可能会被回收掉。所以我们要将数据复制到本地堆。&lt;br/&gt;首先调用 &lt;code&gt;ByteBuffer.allocateDirect()&lt;/code&gt; 分配一块本地内存，一个 float 类型的数字占 4 个字节，所以分配的内存大小为 triangleCoords.length * 4 。&lt;br/&gt;调用 &lt;code&gt;order()&lt;/code&gt; 指定字节缓冲区中的排列顺序， 传入 ByteOrder.nativeOrder() 保证作为一个平台，使用相同的排序顺序。&lt;br/&gt;调用 &lt;code&gt;asFloatBuffer()&lt;/code&gt; 可以得到一个反映底层字节的 FloatBuffer 类的实例。&lt;br/&gt;最后调用 &lt;code&gt;put(triangleCoords)&lt;/code&gt; 把数据从 Android 虚拟机堆内存中复制到本地内存。&lt;/p&gt;
&lt;h2 id=&quot;编译着色器并链接到程序&quot;&gt;3.2 编译着色器并链接到程序&lt;/h2&gt;
&lt;p&gt;接下来，通过 TextResourceReader 工具类，读取顶点着色器和片段着色器文件的的内容。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;String vertexShaderCode = TextResourceReader.readTextFileFromResource(mContext, R.raw.simple_vertex_shader);
String fragmentShaderCode = TextResourceReader.readTextFileFromResource(mContext, R.raw.simple_fragment_shader);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后通过 ShaderHelper 工具类编译着色器。然后链接到程序。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int vertexShader = ShaderHelper.compileVertexShader(vertexShaderCode);
int fragmentShader = ShaderHelper.compileFragmentShader(fragmentShaderCode);

mProgram = ShaderHelper.linkProgram(vertexShader, fragmentShader);
ShaderHelper.validateProgram(mProgram);&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;着色器&quot;&gt;着色器&lt;/h3&gt;
&lt;p&gt;着色器是一个运行在 GPU 上的小程序。着色器的文件其实定义了变量，并且包含 main 函数。关于着色器的详细教程，请查阅：(LearnOpenGL CN 中的着色器教程)[https://learnopengl-cn.github.io/01%20Getting%20started/05%20Shaders/]&lt;/p&gt;
&lt;p&gt;我这里记录一下，着色器的编译过程：&lt;/p&gt;
&lt;h4 id=&quot;创建着色器对象&quot;&gt;3.2.1 创建着色器对象&lt;/h4&gt;
&lt;pre&gt;
&lt;code&gt;int shaderObjectId = glCreateShader(type);`    &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个着色器，并返回着色器的句柄（类似java中的引用），如果返回了 0 ，说明创建失败。GLES 中定义了常量，&lt;code&gt;GL_VERTEX_SHADER&lt;/code&gt; 和 &lt;code&gt;GL_FRAGMENT_SHADER&lt;/code&gt; 作为参数，分别创建顶点着色器和片段着色器。&lt;/p&gt;
&lt;h4 id=&quot;编译着色器&quot;&gt;3.2.2 编译着色器&lt;/h4&gt;
&lt;p&gt;编译着色器，&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;glShaderSource(shaderObjectId, shaderCode);
glCompileShader(shaderObjectId);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;下面的代码，用于获取编译着色器的状态结果。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final int[] compileStatus = new int[1];
glGetShaderiv(shaderObjectId, GL_COMPILE_STATUS, compileStatus, 0);
Log.d(TAG, &quot;Results of compiling source: &quot; + &quot;\n&quot; + shaderCode + &quot;\n: &quot;
        + glGetShaderInfoLog(shaderObjectId));

if (compileStatus[0] == 0) {
    glDeleteShader(shaderObjectId);
    Log.w(TAG, &quot;Compilation of shader failed.&quot;);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;亲测上面的程序在我手上真机可以正常运行，在 genymotion 模拟器中运行报了如下错误：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;JNI DETECTED ERROR IN APPLICATION: input is not valid Modified UTF-8: illegal start byte 0xfe&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;网上搜索了一下，这个异常是由于Java虚拟机内部的dalvik/vm/CheckJni.c中的checkUtfString函数抛出的，并且JVM的这个接口明确是不支持四个字节的UTF8字符。因此需要在调用函数之前，对接口传入的字符串进行过滤，过滤函数，可以上网搜到，这不是本文重点，所以我把这个 log 注释掉了&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Log.d(TAG, &quot;Results of compiling source: &quot; + &quot;\n&quot; + shaderCode + &quot;\n: &quot;
        + glGetShaderInfoLog(shaderObjectId));&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;将着色器连接到程序&quot;&gt;3.2.3 将着色器连接到程序&lt;/h4&gt;
&lt;p&gt;编译完着色器之后，需要将着色器连接到程序才能使用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int programObjectId = glCreateProgram();&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建一个 program 对象，并返回句柄，如果返回了 0 ，说明创建失败。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;glAttachShader(programObjectId, vertexShaderId);
glAttachShader(programObjectId, fragmentShaderId);
glLinkProgram(programObjectId);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;将顶点着色器个片段着色器链接到 program 对象。下面的代码用于获取链接的状态结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;final int[] linkStatus = new int[1];
glGetProgramiv(programObjectId, GL_LINK_STATUS, linkStatus, 0);
/*Log.d(TAG, &quot;Results of linking program: \n&quot;
        + glGetProgramInfoLog(programObjectId));*/
if (linkStatus[0] == 0) {
    glDeleteProgram(programObjectId);
    Log.w(TAG, &quot;Linking of program failed&quot;);
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;判断-program-对象是否有效&quot;&gt;3.2.4 判断 program 对象是否有效&lt;/h4&gt;
&lt;p&gt;在使用 program 对象之前，我们还做了有效性判断：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;glValidateProgram(programId);
final int[] validateStatus = new int[1];
glGetProgramiv(programId, GL_VALIDATE_STATUS, validateStatus, 0);
/*Log.d(TAG, &quot;Results of validating program: &quot; + validateStatus[0]
                + &quot;\n Log: &quot; + glGetProgramInfoLog(programId));*/&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果 validateStatus[0] == 0 ， 则无效。&lt;/p&gt;
&lt;h2 id=&quot;关联属性与顶点数据的数组&quot;&gt;3.3 关联属性与顶点数据的数组&lt;/h2&gt;
&lt;p&gt;首先调用&lt;code&gt;glUseProgram(mProgram)&lt;/code&gt; 将 program 对象添加到 OpenGL ES 的绘制环境。&lt;/p&gt;
&lt;p&gt;看如下代码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mVertexData.position(0); // 移动指针到 0，表示从开头开始读取

// 告诉 OpenGL， 可以在缓冲区中找到 a_Position 对应的数据
int aPos = glGetAttribLocation(mProgram, &quot;aPos&quot;); 
glVertexAttribPointer(aPos, COORDS_PER_VERTEX, GL_FLOAT, false, (COORDS_PER_VERTEX + COLOR_PER_VERTEX) * 4, mVertexBuffer);  // Prepare the triangle coordinate data
glEnableVertexAttribArray(aPos);

int aColor = glGetUniformLocation(mProgram, &quot;aColor&quot;);
glVertexAttribPointer(1, COORDS_PER_VERTEX, GL_FLOAT, false, (COORDS_PER_VERTEX + COLOR_PER_VERTEX) * 4, mVertexBuffer);  // Prepare the triangle coordinate data
glEnableVertexAttribArray(aColor);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在 OpenGL ES 2.0 中，我们通过如上代码，使用数据。调用 &lt;code&gt;glGetAttribLocation()&lt;/code&gt; 方法，找到顶点和颜色对应的数据位置，第一个参数是 program 对象，第二个参数是着色器中的入参参数名。&lt;br/&gt;然后调用 &lt;code&gt;glVertexAttribPointer()&lt;/code&gt; 方法&lt;br/&gt;参数如下(图片截取自《OpenGL ES应用开发实践指南Android卷》)：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/758949/201906/758949-20190619004646523-1443558725.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;最后调用&lt;code&gt;glEnableVertexAttribArray(aPos);&lt;/code&gt; 使 OpenGL 能使用这个数据。&lt;/p&gt;
&lt;p&gt;但是你发现，我们上面给的代码中并没有调用 &lt;code&gt;glGetAttribLocation()&lt;/code&gt; 方法寻找位置，这是因为，我使用的 OpenGLES 3.0 ，在 OpenGL ES 3.0 中，着色器代码中，新增了 &lt;code&gt;layout(location = 0)&lt;/code&gt; 类似的语法支持。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;#version 330

layout (location = 0) in vec3 aPos;   // 位置变量的属性位置值为 0
layout (location = 1) in vec3 aColor; // 颜色变量的属性位置值为 1

out vec3 vColor; // 向片段着色器输出一个颜色

void main()
{
    gl_Position = vec4(aPos.xyz, 1.0);
    vColor = aColor; // 将ourColor设置为我们从顶点数据那里得到的输入颜色
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里已经指明了属性在顶点数组中对应的位置，所以在代码中，可以直接使用 0 和 1 来表示位置。&lt;/p&gt;
&lt;h2 id=&quot;绘制图形&quot;&gt;3.4 绘制图形&lt;/h2&gt;
&lt;p&gt;最后调用 &lt;code&gt;glDrawArrays(GL_TRIANGLES, 0, 3)&lt;/code&gt; 绘制出一个三角形。&lt;br/&gt;glDrawArrays() 方法第一个参数指定绘制的类型, OpenGLES 中定义了一些常量，通常有 GL_TRIANGLES , GL_POINTS, GL_LINES, GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN 等等类型，具体每种类型代表的意思可以查阅API 文档。&lt;/p&gt;

&lt;p&gt;VAO : 顶点数组对象&lt;br/&gt;VBO ：顶点缓冲对象&lt;/p&gt;
&lt;p&gt;通过使用 VAO 和 VBO ，可以建立 VAO 与 VBO 的索引对应关系，一次写入数据之后，每次使用只需要调用 &lt;code&gt;glBindVertexArray&lt;/code&gt; 方法即可，避免重复进行数据的复制, 大大提高绘制效率。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;int[] VBO = new int[2];
int[] VAO = new int[2];

glGenVertexArrays(0, VAO, 0);
glGenBuffers(0, VBO, 0);
glBindVertexArray(VAO[0]);
glBindBuffer(GL_ARRAY_BUFFER, VBO[0]);
glBufferData(GL_ARRAY_BUFFER, triangleCoords.length * 4, mVertexBuffer, GL_STATIC_DRAW);

glVertexAttribPointer(0, COORDS_PER_VERTEX, GL_FLOAT, false, (COORDS_PER_VERTEX + COLOR_PER_VERTEX) * 4, 0);
glEnableVertexAttribArray(0);
glVertexAttribPointer(1, COORDS_PER_VERTEX, GL_FLOAT, false, (COORDS_PER_VERTEX + COLOR_PER_VERTEX) * 4, COORDS_PER_VERTEX * 4);
glEnableVertexAttribArray(1);
glBindVertexArray(VAO[0]);

glGenVertexArrays(1, VAO, 0);
glGenBuffers(1, VBO, 0);
glBindVertexArray(VAO[1]);
glBindBuffer(GL_ARRAY_BUFFER, VBO[1]);
glBufferData(GL_ARRAY_BUFFER, triangleCoords.length * 4, mVertexBuffer2, GL_STATIC_DRAW);

glVertexAttribPointer(0, COORDS_PER_VERTEX, GL_FLOAT, false, (COORDS_PER_VERTEX + COLOR_PER_VERTEX) * 4, 0);
glEnableVertexAttribArray(0);
glVertexAttribPointer(1, COORDS_PER_VERTEX, GL_FLOAT, false, (COORDS_PER_VERTEX + COLOR_PER_VERTEX) * 4, COORDS_PER_VERTEX * 4);
glEnableVertexAttribArray(1);
glBindVertexArray(VAO[1]);


glBindVertexArray(VAO[0]);
glDrawArrays(GL_TRIANGLES, 0, 3);

glBindVertexArray(VAO[1]);
glDrawArrays(GL_TRIANGLES, 0, 3);&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Tue, 18 Jun 2019 17:01:00 +0000</pubDate>
<dc:creator>SharpCJ</dc:creator>
<og:description>记录一下 OpenGL ES 在 Android 开发中的入门教程，绘制一个简单的三角形,介绍一下基本流程。。。</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/joy99/p/11048881.html</dc:identifier>
</item>
<item>
<title>《Fluid Engine Development》 学习笔记3-光滑粒子流体动力学 - 寂灭万乘</title>
<link>http://www.cnblogs.com/millionsmultiplication/p/11048840.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/millionsmultiplication/p/11048840.html</guid>
<description>&lt;p&gt;用粒子表示流体最热门的方法就是就是光滑粒子流体动力学（Smoothed Particle Hydrodynamics (SPH).）&lt;/p&gt;
&lt;p&gt;这种方法模糊了流体的边界，用有限数量的粒子代表流体，该方法的基本思想是将视作连续的流体(或固体)用相互作用的质点组来描述，各个物质点上承载各种物理量，包括质量、速度等，通过求解质点组的动力学方程和跟踪每个质点的运动轨道，求得整个系统的力学行为&lt;/p&gt;
&lt;h2 id=&quot;经典核函数&quot;&gt;经典核函数&lt;/h2&gt;
&lt;p&gt;SPH算法涉及到“光滑核”的概念，可以这样理解这个概念，粒子的属性都会“扩散”到周围，并且随着距离的增加影响逐渐变小，这种随着距离而衰减的函数被称为“光滑核”函数，最大影响半径为“光滑核半径”。&lt;/p&gt;
&lt;p&gt;书中提到的经典核函数有 $W_{std}(r) = \frac{315}{64\pi h^{3}}(1 -\frac{r^{2}}{h_{2}})^{3} (0 \leq r \leq h) $，其他情况为0&lt;/p&gt;
&lt;h2 id=&quot;sph插值&quot;&gt;SPH插值&lt;/h2&gt;
&lt;p&gt;SPH插值的基本思想是通过查找附近的粒子来测量任意给定位置的任何物理量。它是一个加权平均，权重是质量乘以核函数除以相邻粒子的密度。&lt;/p&gt;
&lt;p&gt;质量除以密度就是体积，因此这个插值，将更多的权重放在离原点更近的值上&lt;/p&gt;
&lt;p&gt;相关代码实现如下&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Vector3D CalfFluidEngine::SphSystemData3::Interpolate(const Vector3D &amp;amp; origin, const std::vector&amp;lt;Vector3D&amp;gt;&amp;amp; values) const
{
    Vector3D sum = Vector3D::zero;
    auto&amp;amp; d = GetDensities();
    SphStandardKernel3 kernel(_kernelRadius);
    const double m = GetParticleMass();

    GetNeighborSearcher()-&amp;gt;ForEachNearbyPoint(
        origin, _kernelRadius, [&amp;amp;](size_t i, const Vector3D&amp;amp; neighborPosition) 
        {
            double dist = Vector3D::Distance(origin,neighborPosition);
            double weight = m / d[i] * kernel(dist);
            sum += weight * values[i];
        }
    );

    return sum;
}

double CalfFluidEngine::SphStandardKernel3::operator()(double distance) const
{
    if (distance * distance &amp;gt;= h2) {
        return 0.0;
    }
    else {
        double x = 1.0 - distance * distance / h2;
        return 315.0 / (64.0 * kPiD * h3) * x * x * x;
    }
}

void CalfFluidEngine::PointHashGridSearcher3::ForEachNearbyPoint(const Vector3D &amp;amp; origin, double radius, const std::function&amp;lt;void(size_t, const Vector3D&amp;amp;)&amp;gt;&amp;amp; callback) const
{
    if (_buckets.empty()) {
        return;
    }

    size_t nearbyKeys[8];
    getNearbyKeys(origin, nearbyKeys);

    const double queryRadiusSquared = radius * radius;

    for (int i = 0; i &amp;lt; 8; i++) {
        const auto&amp;amp; bucket = _buckets[nearbyKeys[i]];
        size_t numberOfPointsInBucket = bucket.size();

        for (size_t j = 0; j &amp;lt; numberOfPointsInBucket; ++j) {
            size_t pointIndex = bucket[j];
            double rSquared = (_points[pointIndex] - origin).SquareMagnitude();
            if (rSquared &amp;lt;= queryRadiusSquared) {
                callback(pointIndex, _points[pointIndex]);
            }
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以看到插值函数依赖于密度，因为粒子的位置在每个时间步长都会改变，而密度也随之在每个时间步长都会改。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void CalfFluidEngine::SphSystemData3::UpdateDensities()
{
    auto&amp;amp; p = GetPositions();
    auto&amp;amp; d = GetDensities();
    const double m = GetParticleMass();

    tbb::parallel_for(
        tbb::blocked_range&amp;lt;size_t&amp;gt;(0, GetNumberOfParticles()),
        [&amp;amp;](const tbb::blocked_range&amp;lt;size_t&amp;gt; &amp;amp; b) {
        for (size_t i = b.begin(); i != b.end(); ++i)
        {
            double sum = SumOfKernelNearby(p[i]);
            d[i] = m * sum;
        }
    });
}

double CalfFluidEngine::SphSystemData3::SumOfKernelNearby(const Vector3D &amp;amp; origin) const
{
    double sum = 0.0;
    SphStandardKernel3 kernel(_kernelRadius);
    GetNeighborSearcher()-&amp;gt;ForEachNearbyPoint(
        origin, _kernelRadius, [&amp;amp;](size_t, const Vector3D&amp;amp; neighborPosition) {
        double dist = Vector3D::Distance(origin, neighborPosition);
        sum += kernel(dist);
    });
    &lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;梯度算子&quot;&gt;梯度算子&lt;/h2&gt;
&lt;p&gt;类似于之前的插值，梯度能用类似的方法获得&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Vector3D CalfFluidEngine::SphSystemData3::GradientAt(size_t i, const std::vector&amp;lt;double&amp;gt;&amp;amp; values) const
{
    Vector3D sum;
    auto&amp;amp; p = GetPositions();
    auto&amp;amp; d = GetDensities();
    const auto&amp;amp; neighbors = GetNeighborLists()[i];
    Vector3D origin = p[i];
    SphSpikyKernel3 kernel(_kernelRadius);
    const double m = GetParticleMass();

    for (size_t j : neighbors) {
        Vector3D neighborPosition = p[j];
        double dist = Vector3D::Distance(origin, neighborPosition);
        if (dist &amp;gt; kEpsilonD) {
            Vector3D dir = (neighborPosition - origin) / dist;
            sum += m * values[i] / d[j] *
                kernel.Gradient(dist, dir);
        }
    }

    return sum;
}

Vector3D ...::Gradient(double distance, const Vector3D &amp;amp; directionToParticle) const
{
    return -firstDerivative(distance) * directionToParticle;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然而这种梯度的实现是不对称的，相邻的粒子可能会因为拥有不同的价值和密度而拥有不同的梯度，这也意味着2个粒子将被施加不同的力。根据牛顿第三运动定律，每一个作用力都有一个相等且相反的作用力&lt;/p&gt;
&lt;p&gt;为解决这个问题，需要修改梯度实现。&lt;/p&gt;
&lt;p&gt;书所使用的公式是 &lt;span class=&quot;math inline&quot;&gt;\(\nabla \phi（x）= \rho _{j}m \sum_{j}(\frac{\phi_{i}}{\rho _{i} ^{2}} + \frac{\phi_{j}}{\rho _{j} ^{2}}) \nabla W(|x - x_{j}|)\)&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;Vector3D CalfFluidEngine::SphSystemData3::GradientAt(size_t i, const std::vector&amp;lt;double&amp;gt;&amp;amp; values) const
{
    Vector3D sum;
    auto&amp;amp; p = GetPositions();
    auto&amp;amp; d = GetDensities();
    const auto&amp;amp; neighbors = GetNeighborLists()[i];
    Vector3D origin = p[i];
    SphSpikyKernel3 kernel(_kernelRadius);
    const double m = GetParticleMass();

    for (size_t j : neighbors) {
        Vector3D neighborPosition = p[j];
        double dist = Vector3D::Distance(origin, neighborPosition);
        if (dist &amp;gt; kEpsilonD) {
            Vector3D dir = (neighborPosition - origin) / dist;
            sum += d[i] * m *
                (values[i] / (d[i] * d[i]) + values[j] / (d[j] * d[j])) *
                kernel.Gradient(dist, dir);
        }
    }

    return sum;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;拉普拉斯算子&quot;&gt;拉普拉斯算子&lt;/h2&gt;
&lt;p&gt;类似于之前的插值，按照拉普拉斯的数学定义，尝试计算拉普拉斯算子，结果如下&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;double CalfFluidEngine::SphSystemData3::LaplacianAt(size_t i, const std::vector&amp;lt;double&amp;gt;&amp;amp; values) const
{
    double sum = 0.0;
    auto&amp;amp; p = GetPositions();
    auto&amp;amp; d = GetDensities();
    const auto&amp;amp; neighbors = GetNeighborLists()[i];
    Vector3D origin = p[i];
    SphSpikyKernel3 kernel(_kernelRadius);
    const double m = GetParticleMass();

    for (size_t j : neighbors) {
        Vector3D neighborPosition = p[j];
        double dist = Vector3D::Distance(origin, neighborPosition);
        sum += m * values[j]  / d[j] * kernel.Laplacian(dist);
    }

    return sum;
}

double ...::Laplacian(double distance) const
{
    return secondDerivative(distance);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;遗憾的是这般计算拉普拉斯算子在即便所有场值都是相同的非零值时，也不会输出零场&lt;/p&gt;
&lt;p&gt;拉普拉斯正确的计算方法如下 &lt;span class=&quot;math inline&quot;&gt;\(\nabla^{2} \phi（x）=m \sum_{j}(\frac{\phi_{j} - \phi_{i}}{\rho _{j} } ) \nabla^{2} W(|x - x_{j}|)\)&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;double CalfFluidEngine::SphSystemData3::LaplacianAt(size_t i, const std::vector&amp;lt;double&amp;gt;&amp;amp; values) const
{
    double sum = 0.0;
    auto&amp;amp; p = GetPositions();
    auto&amp;amp; d = GetDensities();
    const auto&amp;amp; neighbors = GetNeighborLists()[i];
    Vector3D origin = p[i];
    SphSpikyKernel3 kernel(_kernelRadius);
    const double m = GetParticleMass();

    for (size_t j : neighbors) {
        Vector3D neighborPosition = p[j];
        double dist = Vector3D::Distance(origin, neighborPosition);
        sum += m * (values[j] - values[i]) / d[j] * kernel.Laplacian(dist);
    }

    return sum;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;spiky核函数&quot;&gt;Spiky核函数&lt;/h2&gt;
&lt;p&gt;梯度算子是用来计算压力梯度的，粒子太接近，压力就会把粒子推开，然而经典核函数即使粒子越来越接近，也会出现压力越来越小的情况，甚至还会出现负值&lt;/p&gt;
&lt;p&gt;如下图是原书中的图,a是经典核函数，实线是原核函数，虚线是一阶偏导，点线是二阶导&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/IceLanguage/icelanguage.github.io/master/images/SphKernel.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;为解决这个问题，Spiky核函数诞生了，如上图b&lt;/p&gt;
&lt;p&gt;公式为$W_{spiky}(r) = \frac{15}{\pi h^{3}}(1 -\frac{r^{3}}{h_{3}})^{3} (0 \leq r \leq h) $其他情况为0&lt;/p&gt;
&lt;p&gt;我们插值获取权重时使用经典核函数，计算拉普拉斯算子和梯度时使用Spiky核函数&lt;/p&gt;
&lt;h2 id=&quot;主体代码结构&quot;&gt;主体代码结构&lt;/h2&gt;
&lt;p&gt;这里给出SPH系统的头文件&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;class SphSystemSolver3 : public ParticleSystemSolver3
    {
    public:
        SphSystemSolver3();
        virtual ~SphSystemSolver3();
        void SetViscosityCoefficient(
            double newViscosityCoefficient) {
            _viscosityCoefficient = std::max(newViscosityCoefficient, 0.0);
        }
        void SetPseudoViscosityCoefficient(
            double newPseudoViscosityCoefficient) {
            _pseudoViscosityCoefficient
                = std::max(newPseudoViscosityCoefficient, 0.0);
        }
        void SetTimeStepLimitScale(double newScale) {
            _timeStepLimitScale = std::max(newScale, 0.0);
        }
        std::shared_ptr&amp;lt;SphSystemData3&amp;gt; GetSphData() const;
    protected:
        virtual void accumulateForces(double timeIntervalInSeconds) override;
        virtual void onTimeStepStart(double timeStepInSeconds) override;
        virtual void onTimeStepEnd(double timeStepInSeconds) override;
        virtual unsigned int getNumberOfSubTimeSteps(
            double timeIntervalInSeconds) const override;
    private:
        void accumulateViscosityForce();
        void accumulatePressureForce(double timeStepInSeconds);
        void computePressure();
        void accumulatePressureForce(
            const std::vector&amp;lt;Vector3D&amp;gt;&amp;amp; positions,
            const std::vector&amp;lt;double&amp;gt;&amp;amp; densities,
            const std::vector&amp;lt;double&amp;gt;&amp;amp; pressures,
            std::vector&amp;lt;Vector3D&amp;gt;&amp;amp; pressureForces);
        void computePseudoViscosity(double timeStepInSeconds);

        //! Exponent component of equation - of - state(or Tait's equation).
        double _eosExponent = 7.0;

        //! Speed of sound in medium to determin the stiffness of the system.
        //! Ideally, it should be the actual speed of sound in the fluid, but in
        //! practice, use lower value to trace-off performance and compressibility.
        double _speedOfSound = 100.0;

        //! Negative pressure scaling factor.
        //! Zero means clamping. One means do nothing.
        double _negativePressureScale = 0.0;

        double _viscosityCoefficient = 0.01;

        //Scales the max allowed time-step.
        double _timeStepLimitScale = 1.0;

        //! Pseudo-viscosity coefficient velocity filtering.
        //! This is a minimum &quot;safety-net&quot; for SPH solver which is quite
        //! sensitive to the parameters.
        double _pseudoViscosityCoefficient = 10.0;
    };&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SPH系统相比正常的粒子动画系统，重写了accumulateForces函数和onTimeStepStart函数以及onTimeStepEnd函数，分别用以添加粘度压力计算，更新密度，抑制噪声&lt;/p&gt;
&lt;p&gt;以下是accumulateForces函数的代码结构&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void CalfFluidEngine::SphSystemSolver3::accumulateForces(double timeIntervalInSeconds)
{
    ParticleSystemSolver3::accumulateForces(timeIntervalInSeconds);
    accumulateViscosityForce();
    accumulatePressureForce(timeIntervalInSeconds);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到了相比粒子动画，多了粘度和压力的计算&lt;/p&gt;
&lt;p&gt;以下是onTimeStepStart函数，用以更新粒子集合的密度&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void CalfFluidEngine::SphSystemSolver3::onTimeStepStart(double timeStepInSeconds)
{
    auto particles = GetSphData();

    particles-&amp;gt;BuildNeighborSearcher(particles-&amp;gt;GetKernelRadius());
    particles-&amp;gt;BuildNeighborLists(particles-&amp;gt;GetKernelRadius());
    particles-&amp;gt;UpdateDensities();
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;以下是onTimeStepEnd函数&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void CalfFluidEngine::SphSystemSolver3::onTimeStepEnd(double timeStepInSeconds)
{
    computePseudoViscosity(timeStepInSeconds);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;计算压强&quot;&gt;计算压强&lt;/h2&gt;
&lt;p&gt;状态方程（Equation-of-State ，EOS）描述了状态变量间的关系，我们通过状态方程 &lt;span class=&quot;math inline&quot;&gt;\(p = \frac{\kappa}{\gamma}( \frac{\rho}{\rho_{0}}- 1)^{\gamma}\)&lt;/span&gt; 将密度映射为压强&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;inline double computePressureFromEos(
    double density,
    double targetDensity,
    double eosScale,
    double eosExponent,
    double negativePressureScale) {
    // Equation of state
    // (http://www.ifi.uzh.ch/vmml/publications/pcisph/pcisph.pdf)
    double p = eosScale / eosExponent
        * (std::pow((density / targetDensity), eosExponent) - 1.0);

    return p;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;观察上公式，我们发现density 小于 targetDensity会出现负压强的情况，而液体表面附近的确会出现密度过小的情况&lt;/p&gt;
&lt;p&gt;为防止负压强的引入，我们需要夹紧压强，具体如下&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;inline double computePressureFromEos(
    double density,
    double targetDensity,
    double eosScale,
    double eosExponent,
    double negativePressureScale) {
    // Equation of state
    // (http://www.ifi.uzh.ch/vmml/publications/pcisph/pcisph.pdf)
    double p = eosScale / eosExponent
        * (std::pow((density / targetDensity), eosExponent) - 1.0);

    // Negative pressure scaling
    if (p &amp;lt; 0) {
        p *= negativePressureScale;
    }

    return p;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;压强计算代码如下&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void CalfFluidEngine::SphSystemSolver3::computePressure()
{
    auto particles = GetSphData();
    size_t numberOfParticles = particles-&amp;gt;GetNumberOfParticles();
    auto&amp;amp; d = particles-&amp;gt;GetDensities();
    auto&amp;amp; p = particles-&amp;gt;GetPressures();

    // See Equation 9 from
    // http://cg.informatik.uni-freiburg.de/publications/2007_SCA_SPH.pdf
    const double targetDensity = particles-&amp;gt;GetDensity();
    const double eosScale
        = targetDensity * (_speedOfSound * _speedOfSound) / _eosExponent;

    tbb::parallel_for(
        tbb::blocked_range&amp;lt;size_t&amp;gt;(0, numberOfParticles),
        [&amp;amp;](const tbb::blocked_range&amp;lt;size_t&amp;gt; &amp;amp; b) {
        for (size_t i = b.begin(); i != b.end(); ++i)
        {
            p[i] = computePressureFromEos(
                d[i],
                targetDensity,
                eosScale,
                _eosExponent,
                _negativePressureScale);
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里注意到eosScale参数的计算，并不是我们想象中那样随便取个值，需要通过公式 $\kappa =\rho_{0} \frac{c_{s}}{\gamma} $ cs是流体中的声速，实践中可以用较低的值跟踪性能。&lt;/p&gt;
&lt;h2 id=&quot;计算压力&quot;&gt;计算压力&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(f_{p} = - m \frac{\nabla p}{\rho}\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;回忆我们之前提到的梯度算子计算方法，我们可以得到&lt;span class=&quot;math inline&quot;&gt;\(f_{p}= m^{2} \sum_{j}(\frac{p_{i}}{\rho _{i} ^{2}} + \frac{p_{j}}{\rho _{j} ^{2}}) \nabla W(|x - x_{j}|)\)&lt;/span&gt;&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void CalfFluidEngine::SphSystemSolver3::accumulatePressureForce(const std::vector&amp;lt;Vector3D&amp;gt;&amp;amp; positions, const std::vector&amp;lt;double&amp;gt;&amp;amp; densities, const std::vector&amp;lt;double&amp;gt;&amp;amp; pressures, std::vector&amp;lt;Vector3D&amp;gt;&amp;amp; pressureForces)
{
    auto particles = GetSphData();
    size_t numberOfParticles = particles-&amp;gt;GetNumberOfParticles();

    double mass = particles-&amp;gt;GetParticleMass();
    const double massSquared = mass * mass;
    const SphSpikyKernel3 kernel(particles-&amp;gt;GetKernelRadius());

    tbb::parallel_for(
        tbb::blocked_range&amp;lt;size_t&amp;gt;(0, numberOfParticles),
        [&amp;amp;](const tbb::blocked_range&amp;lt;size_t&amp;gt; &amp;amp; b) {
        for (size_t i = b.begin(); i != b.end(); ++i)
        {
            const auto&amp;amp; neighbors = particles-&amp;gt;GetNeighborLists()[i];
            for (size_t j : neighbors) {
                double dist = Vector3D::Distance(positions[i], positions[j]);

                if (dist &amp;gt; kEpsilonD) {
                    Vector3D dir = (positions[j] - positions[i]) / dist;
                    pressureForces[i] -= massSquared
                        * (pressures[i] / (densities[i] * densities[i])
                            + pressures[j] / (densities[j] * densities[j]))
                        * kernel.Gradient(dist, dir);
                }
            }
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;计算粘度&quot;&gt;计算粘度&lt;/h2&gt;
&lt;p&gt;粘度力公式为&lt;span class=&quot;math inline&quot;&gt;\(f_{v} = - m \mu \nabla^{2}u\)&lt;/span&gt; 代入之前拉普拉斯算子的计算方法，可得公式&lt;span class=&quot;math inline&quot;&gt;\(\nabla^{2} \phi（x）=m^{2} \mu\sum_{j}(\frac{u_{j} - u_{i}}{\rho _{j} } ) \nabla^{2} W(|x - x_{j}|)\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;代码实现如下&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void CalfFluidEngine::SphSystemSolver3::accumulateViscosityForce()
{
    auto particles = GetSphData();
    size_t numberOfParticles = particles-&amp;gt;GetNumberOfParticles();
    auto&amp;amp; x = particles-&amp;gt;GetPositions();
    auto&amp;amp; v = particles-&amp;gt;GetVelocities();
    auto&amp;amp; d = particles-&amp;gt;GetDensities();
    auto&amp;amp; f = particles-&amp;gt;GetForces();

    double mass = particles-&amp;gt;GetParticleMass();
    const double massSquared = mass * mass;
    const SphSpikyKernel3 kernel(particles-&amp;gt;GetKernelRadius());

    tbb::parallel_for(
        tbb::blocked_range&amp;lt;size_t&amp;gt;(0, numberOfParticles),
        [&amp;amp;](const tbb::blocked_range&amp;lt;size_t&amp;gt; &amp;amp; b) {
        for (size_t i = b.begin(); i != b.end(); ++i)
        {
            const auto&amp;amp; neighbors = particles-&amp;gt;GetNeighborLists()[i];
            for (size_t j : neighbors) {
                double dist = Vector3D::Distance(x[i],x[j]);

                f[i] += _viscosityCoefficient * massSquared
                    * (v[j] - v[i]) / d[j]
                    * kernel.Laplacian(dist);
            }
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;降低噪声&quot;&gt;降低噪声&lt;/h2&gt;
&lt;p&gt;降低噪声的方法很简单，以参数_pseudoViscosityCoefficient线性插值速度场和加权平均速度即可&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;void CalfFluidEngine::SphSystemSolver3::computePseudoViscosity(double timeStepInSeconds)
{
    auto particles = GetSphData();
    size_t numberOfParticles = particles-&amp;gt;GetNumberOfParticles();
    auto&amp;amp; x = particles-&amp;gt;GetPositions();
    auto&amp;amp; v = particles-&amp;gt;GetVelocities();
    auto&amp;amp; d = particles-&amp;gt;GetDensities();

    const double mass = particles-&amp;gt;GetParticleMass();
    const SphSpikyKernel3 kernel(particles-&amp;gt;GetKernelRadius());

    std::vector&amp;lt;Vector3D&amp;gt; smoothedVelocities(numberOfParticles);

    tbb::parallel_for(
        tbb::blocked_range&amp;lt;size_t&amp;gt;(0, numberOfParticles),
        [&amp;amp;](const tbb::blocked_range&amp;lt;size_t&amp;gt; &amp;amp; b) {
        for (size_t i = b.begin(); i != b.end(); ++i)
        {
            double weightSum = 0.0;
            Vector3D smoothedVelocity;

            const auto&amp;amp; neighbors = particles-&amp;gt;GetNeighborLists()[i];
            for (size_t j : neighbors) {
                double dist = Vector3D::Distance(x[i],x[j]);
                double wj = mass / d[j] * kernel(dist);
                weightSum += wj;
                smoothedVelocity += wj * v[j];
            }

            double wi = mass / d[i];
            weightSum += wi;
            smoothedVelocity += wi * v[i];

            if (weightSum &amp;gt; 0.0) {
                smoothedVelocity /= weightSum;
            }

            smoothedVelocities[i] = smoothedVelocity;
        }
    });

    double factor = timeStepInSeconds * _pseudoViscosityCoefficient;
    factor = Clamp(factor, 0.0, 1.0); 

    tbb::parallel_for(
        tbb::blocked_range&amp;lt;size_t&amp;gt;(0, numberOfParticles),
        [&amp;amp;](const tbb::blocked_range&amp;lt;size_t&amp;gt; &amp;amp; b) {
        for (size_t i = b.begin(); i != b.end(); ++i)
        {
            v[i] = Lerp(
                v[i], smoothedVelocities[i], factor);
        }
    });
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;声速参数和时间步长&quot;&gt;声速参数和时间步长&lt;/h2&gt;
&lt;p&gt;之前我们计算压强时使用了声速cs，为什么会有声速呢，因为在一个时间步长内，压力传播不能大于粒子核半径h，而水中传播的最快速度就是声速，所以时间步长的理想步长是h/cs&lt;/p&gt;
&lt;p&gt;最后，根据几位科学家的研究成果，时间步长需要做如下的限制&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\Delta t _{v} =\frac{ \lambda _{v} h}{c_{s}} ,\Delta t_{f} = \lambda_{f}\sqrt{\frac{hm}{F_{Max}}}, \Delta \leq(\Delta t_{v},\Delta t_{f})\)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math inline&quot;&gt;\(\lambda_{v},\lambda_{f}\)&lt;/span&gt;是2个预设好的标量，大概0.25~0.4之间，&lt;span class=&quot;math inline&quot;&gt;\(F_{max}\)&lt;/span&gt; 是力向量的最大大小&lt;/p&gt;
&lt;p&gt;然后时间步长因为这种限制可能会非常小，导致巨大的计算成本，而且实际上我们也无法评估最大速度和最大力是多少&lt;/p&gt;
&lt;p&gt;为从根本解决这个问题，Solenthaler 和Pajarola提出一种预测-校正模型，消除了对声速的依赖。这个新的模型将在下一篇笔记中阐述。&lt;/p&gt;
&lt;h2 id=&quot;演示模拟结果&quot;&gt;演示模拟结果&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/IceLanguage/icelanguage.github.io/master/images/SPHWaterDrop.gif&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Tue, 18 Jun 2019 16:34:00 +0000</pubDate>
<dc:creator>寂灭万乘</dc:creator>
<og:description>用粒子表示流体最热门的方法就是就是光滑粒子流体动力学（Smoothed Particle Hydrodynamics (SPH).） 这种方法模糊了流体的边界，用有限数量的粒子代表流体，该方法的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/millionsmultiplication/p/11048840.html</dc:identifier>
</item>
<item>
<title>synchronized凭什么锁得住？ - OKevin</title>
<link>http://www.cnblogs.com/yulinfeng/p/11048307.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yulinfeng/p/11048307.html</guid>
<description>&lt;p dir=&quot;ltr&quot;&gt;相关链接：&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;&lt;a href=&quot;https://www.cnblogs.com/yulinfeng/p/11020576.html&quot; target=&quot;_blank&quot;&gt;《synchronized锁住的是谁？》&lt;/a&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;我们知道synchronized是重量级锁，我们知道synchronized锁住的是一个对象上的Monitor对象，我们也知道synchronized用于同步代码块时会执行monitorenter和monitorexit等。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;上面几个问题仅仅是校招级。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;那么synchronized为什么“重”呢？Monitor对象从何而来呢？synchronized用于实例方法或者静态方法又是怎么锁住的呢？&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;在&lt;a href=&quot;https://www.cnblogs.com/yulinfeng/p/11020576.html&quot; target=&quot;_blank&quot;&gt;《synchronized锁住的是谁？》&lt;/a&gt;中我们明确了，synchronized锁住的对象，本文讲述synchronized凭什么锁得住。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;首先我们需要知道的是在Hotspot虚拟机实现中，对象实例在堆内存中结构分为3个部分：对象头、实例数据、对其填充字节。在Java中万物皆为对象。就算一个Java类被编译称为class二进制文件在被加载到内存时，它仍然会在堆内存中创建一个Class对象。这也就解释了，为什么synchronized能对类加锁（因为每个类在堆内存中有一个Class对象，对于类synchronized锁的实际上是Class对象，下文会继续解释）。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;在解释了Java中对象实例在Hotspot中的内存结构（对象头、实例数据、对其填充字节）后，synchronized锁住的Monitor对象就存在于对象头之中。对象头又分为：Mark Word、指向类的指针、数组长度（数组对象）。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;对象头在Hotspot虚拟机实现中，分为32位和64位的实现，实际上Hotspot源代码实现中的注释已经解释得非常清楚了（openjdk/hotspot/share/oops/markOop.hpp)，对象头的Mark Word位格式在32位机器中是32位长，在64位机器中是64位长（采用 big endian ，低地址存放最高有效字节，即低位在左，高位再右）。&lt;/p&gt;
&lt;div dir=&quot;ltr&quot;&gt;
&lt;table&gt;&lt;colgroup&gt;&lt;col width=&quot;*&quot;/&gt;&lt;col width=&quot;*&quot;/&gt;&lt;col width=&quot;*&quot;/&gt;&lt;col width=&quot;*&quot;/&gt;&lt;col width=&quot;*&quot;/&gt;&lt;col width=&quot;*&quot;/&gt;&lt;/colgroup&gt;&lt;tbody readability=&quot;3&quot;&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td colspan=&quot;6&quot; readability=&quot;5&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;32bit位虚拟机Mark Word&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td rowspan=&quot;2&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;锁状态&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;25bit&lt;/p&gt;
&lt;/td&gt;
&lt;td rowspan=&quot;2&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;4bit&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;1bit&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;2bit&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;23bit&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;2bit&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;是否是偏向锁&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;锁标志位&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;无锁状态&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;2&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;对象的hashcode&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;分代年龄&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;0&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;偏向锁&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;线程ID&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;偏向时间戳&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;分代年龄&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;1&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;01&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;轻量级锁&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;4&quot; readability=&quot;5&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;指向栈中锁记录的指针&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;00&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;3&quot;&gt;&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;重量级锁&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;4&quot; readability=&quot;5&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;指向重量级锁（Monitor）的指针&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;10&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;GC标记&lt;/p&gt;
&lt;/td&gt;
&lt;td colspan=&quot;4&quot;&gt;
&lt;p dir=&quot;ltr&quot;&gt;空&lt;/p&gt;
&lt;/td&gt;
&lt;td&gt;
&lt;p dir=&quot;ltr&quot;&gt;11&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;p dir=&quot;ltr&quot;&gt;和synchronized相关的就是Java在Hotspot虚拟机实现中对象头中的Mark Word。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;在以前（JDK5之前），synchronized被称为重量级锁是无可厚非的，但在JDK6后，JVM对其进行了一系列优化，尽量使得synchronized不再那么重。之所以synchronized重，是因为它涉及到了操作系统用户态与核心态的转换，下文再详细解释。这里我们从最轻的偏向锁-&amp;gt;轻量级锁-&amp;gt;重量级锁的过程，注意他们只能升级加锁的强度，不能降级。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;&lt;strong&gt;偏向锁&lt;/strong&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;上面提到了JDK6过后优化了synchronized的加锁过程，尽量使得synchronized不再那么重。偏向锁即是如此。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;JVM的研究者表明，大多数情况下锁的竞争不是那么激励，在不那么激励的时候如果通过获取Monitor来进行同步访问，会造成线程在操作系统用户态和核心态的转换，这会使得系统性能下降。偏向锁表示，当只有一个线程进入同步方法或同步代码块时，并不会直接获取Monitor锁，而是先判断对象头中Mark Word部分的锁标志位是否处于“01”，如果处于“01”，此时再判断线程ID是否是本线程ID，如果是则直接进入方法进行后续操作；如果不是，此时则通过CAS（无锁机制竞争）如果竞争成功，此时将线程ID设置为本线程ID，如果竞争失败，说明造成了有了较为强烈的锁竞争，偏向锁已不能满足，此时偏向锁晋级为轻量级锁。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;&lt;strong&gt;轻量级锁&lt;/strong&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;当锁发生竞争时，持有偏向锁的线程会撤销偏向锁，转而晋级为轻量级锁（状态）。轻量级锁的核心是，不让未获取锁的线程进入阻塞状态，因为这会使得线程由用户态转为核心态，这会造成很大的性能损失，而是采用“死循环”的方式不断的获取锁，这种采用“死循环”获取的锁的方式称为——锁自旋。它不会让线程陷入阻塞，但同时仅适用于持有锁时间较短的场景。那么轻量级锁升级为重量级锁的条件就是，自旋等待的时间过长，并且又有了新的线程来竞争。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;&lt;strong&gt;重量级锁&lt;/strong&gt;&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;这种锁，就是地地道道原原本本synchronized的本意了。线程会去抢夺对象上的一个互斥量（这个互斥量就是Monitor），每个对象都会有，就算是类也有一个Monitor互斥量（因为类在堆内存中有一个Class对象）。当一个线程获取到对象的Monitor锁时，其余线程会被阻塞挂起，并且由用户态转为核心态。&lt;/p&gt;
&lt;p&gt;上文提到在锁的竞争状态晋级为重量级锁时，Java对象头中的Mark Word前30位存储的是Monitor对象的指针。Monitor对象定义在openjdk/hotspot/share/runtime/objectMonitor.hpp中，在ObjectMonitor中定义了：计数器、持有Monitor的线程、处于wait状态的线程、处于阻塞状态的线程等等。&lt;/p&gt;
&lt;p&gt;synchronized无论是普通实例还是同步代码块，它所获取的锁是对象实例中的Monitor锁，而对象的Monitor又是存在于Java对象头的Mark Work之中，所以可以这么说，synchronized获取的锁在Java对象头中。对于普通实例或者静态方法，JVM并没有显示的指令进入临界区，而是在方法上标识了“ACC_SYNCHRONIZED”，标识是synchronized同步方法，方法内部都是临界区。而对于同步代码块，则在synchronized代码块开始执行了monitorenter，结束或者抛出异常时执行了monitorexit指令。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt;synchronized凭借的就是Monitor锁住的对象，Monitor又是借助于操作系统的mutex lock，之所以它重是因为它被挂起后线程会由用户态转换为内核态，这个转换会带来性能损耗。JDK6开始对其进行了优化，提出了偏向锁和轻量级锁，针对锁竞争较为激烈的场景不会直接去获取Monitor对象，减少性能损耗。因此在现如今的synchronized实现中，它的性能劣势也已不再那么明显。&lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt; &lt;/p&gt;
&lt;p dir=&quot;ltr&quot;&gt; &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这是一个能给程序员加buff的公众号 （CoderBuff）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/630246/201901/630246-20190106013233246-1297584549.png&quot; alt=&quot;&quot;/&gt; &lt;/p&gt;
</description>
<pubDate>Tue, 18 Jun 2019 16:12:00 +0000</pubDate>
<dc:creator>OKevin</dc:creator>
<og:description>相关链接： 《synchronized锁住的是谁？》 我们知道synchronized是重量级锁，我们知道synchronized锁住的是一个对象上的Monitor对象，我们也知道synchroniz</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/yulinfeng/p/11048307.html</dc:identifier>
</item>
</channel>
</rss>