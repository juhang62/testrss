<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>分享一个.NET平台开源免费跨平台的大数据分析框架.NET for Apache Spark - AjuPrince</title>
<link>http://www.cnblogs.com/haoxiaozhang/p/10768816.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haoxiaozhang/p/10768816.html</guid>
<description>&lt;p&gt;我们都知道Spark是一种流行的开源分布式处理引擎，适用于大型数据集(通常是TB级别)的分析。Spark可用于处理批量数据，实时流，机器学习和即时查询。处理任务分布在一个节点集群上，数据被缓存在内存中，以减少计算时间。到目前为止，Spark已经可以通过Scala，Java，Python和R访问，却不能通过.NET进行访问。&lt;/p&gt;
&lt;p&gt;而.NET for Apache Spark就是旨在使.NET开发人员可以跨所有Spark API访问Apache®Spark™。&lt;/p&gt;
&lt;p&gt;.NET for Apache Spark为C#和F#提供了高性能的API来操作Spark。使用这个.NET API，您可以访问Apache Spark的所有功能，包括SparkSQL、DataFrames、流、MLLib等等。.NET for Apache Spark允许您重用作为.NET开发人员已经拥有的所有知识、技能、代码和库。&lt;/p&gt;
&lt;p&gt;C#/F#语言绑定到Spark将被写入一个新的Spark交互层，这提供了更容易的扩展性。这一新的Spark交互层的编写考虑了语言扩展的最佳实践，并针对交互和性能进行了优化。长期来看，这种扩展性可以用于在Spark中添加对其他语言的支持。&lt;/p&gt;
&lt;p&gt;具体请查看GitHub：https://github.com/dotnet/spark&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/562098/201904/562098-20190425153741838-1501049173.png&quot; alt=&quot;&quot;/&gt;定时分享DotNet Core 相关知识！&lt;/p&gt;

</description>
<pubDate>Thu, 25 Apr 2019 07:39:00 +0000</pubDate>
<dc:creator>AjuPrince</dc:creator>
<og:description>我们都知道Spark是一种流行的开源分布式处理引擎，适用于大型数据集(通常是TB级别)的分析。Spark可用于处理批量数据，实时流，机器学习和即时查询。处理任务分布在一个节点集群上，数据被缓存在内存中</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/haoxiaozhang/p/10768816.html</dc:identifier>
</item>
<item>
<title>python接口自动化（二十三）--unittest断言——上（详解） - 北京-宏哥</title>
<link>http://www.cnblogs.com/du-hong/p/10755859.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/du-hong/p/10755859.html</guid>
<description>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;　　在测试用例中，执行完测试用例后，最后一步是判断测试结果是 pass 还是 fail，自动化测试脚本里面一般把这种生成测试结果的方法称为断言（assert）。用 unittest 组件测试用例的时候，断言的方法还是很多的，下面介绍几种常用的断&lt;/p&gt;
&lt;p&gt;言方法：assertEqual、assertIn、assertTrue。想了解更多可以点击 &lt;a href=&quot;https://www.cnblogs.com/du-hong/p/10754903.html&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt; 看一下最后的小结有大致介绍。&lt;/p&gt;
&lt;p&gt;　　unittest断言计划是分上、中、下三篇有简单到复杂的给小伙伴们介绍一下，填补一下这部分的空白。&lt;/p&gt;
&lt;h2&gt;基本断言方法&lt;/h2&gt;
&lt;p&gt;基本的断言方法提供了测试结果是True还是False。所有的断言方法都有一个msg参数，如果指定msg参数的值，则将该信息作为失败的错误信息返回。&lt;/p&gt;
&lt;div class=&quot;table-box&quot; readability=&quot;38&quot;&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;断言方法&lt;/th&gt;
&lt;th&gt;断言描述&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody readability=&quot;34.5&quot;&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;assertEqual(arg1, arg2, msg=None)&lt;/td&gt;
&lt;td&gt;验证arg1=arg2，不等则fail&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;7&quot;&gt;&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;assertNotEqual(arg1, arg2, msg=None)&lt;/td&gt;
&lt;td&gt;验证arg1 != arg2, 相等则fail&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;assertTrue(expr, msg=None)&lt;/td&gt;
&lt;td&gt;验证expr是true，如果为false，则fail&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;assertFalse(expr,msg=None)&lt;/td&gt;
&lt;td&gt;验证expr是false，如果为true，则fail&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;assertIs(arg1, arg2, msg=None)&lt;/td&gt;
&lt;td&gt;验证arg1、arg2是同一个对象，不是则fail&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;assertIsNot(arg1, arg2, msg=None)&lt;/td&gt;
&lt;td&gt;验证arg1、arg2不是同一个对象，是则fail&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;assertIsNone(expr, msg=None)&lt;/td&gt;
&lt;td&gt;验证expr是None，不是则fail&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;5&quot;&gt;&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;assertIsNotNone(expr, msg=None)&lt;/td&gt;
&lt;td&gt;验证expr不是None，是则fail&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;assertIn(arg1, arg2, msg=None)&lt;/td&gt;
&lt;td&gt;验证arg1是arg2的子串，不是则fail&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;assertNotIn(arg1, arg2, msg=None)&lt;/td&gt;
&lt;td&gt;验证arg1不是arg2的子串，是则fail&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;assertIsInstance(obj, cls, msg=None)&lt;/td&gt;
&lt;td&gt;验证obj是cls的实例，不是则fail&lt;/td&gt;
&lt;/tr&gt;&lt;tr readability=&quot;6&quot;&gt;&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;assertNotIsInstance(obj, cls, msg=None)&lt;/td&gt;
&lt;td&gt;验证obj不是cls的实例，是则fail&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h2&gt;简单的case&lt;/h2&gt;
&lt;p&gt;1、实例，写了四个测试用例，其中第四个是失败的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190425094035734-758759196.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、运行结果（python3）&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190425094004331-501418205.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;python2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190425152302748-26245934.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3、在python2中执行的结果，中文编码不对，没正常显示中文，遇到这种情况，可以自定义异常输出，python3正常。有时候也可以根据实际需要采用自定义异常输出，要灵活掌握。&lt;/p&gt;
&lt;h2&gt;参考代码&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; # coding=utf-&lt;span&gt;8&lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行
&lt;/span&gt;&lt;span&gt; 3&lt;/span&gt; 
&lt;span&gt; 4&lt;/span&gt; #&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;-&lt;span&gt;25&lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; @author: 北京-&lt;span&gt;宏哥
&lt;/span&gt;&lt;span&gt; 8&lt;/span&gt; &lt;span&gt;Project:学习和使用unittest框架编写断言
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt; &lt;span&gt;'''
&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; #&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入unittest模块
&lt;/span&gt;&lt;span&gt;11&lt;/span&gt; &lt;span&gt;import unittest
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt; #&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.编写测试用例和断言
&lt;/span&gt;&lt;span&gt;13&lt;/span&gt; 
&lt;span&gt;14&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test(unittest.TestCase):
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    def test01(self):
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;判断 a == b &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;17&lt;/span&gt;         a = &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;18&lt;/span&gt;         b = &lt;span&gt;1&lt;/span&gt;
&lt;span&gt;19&lt;/span&gt; &lt;span&gt;        self.assertEqual(a, b)
&lt;/span&gt;&lt;span&gt;20&lt;/span&gt; &lt;span&gt;    def test02(self):
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;判断 a in b &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;22&lt;/span&gt;         a = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello hongge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;23&lt;/span&gt;         b = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello hongge and world!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;24&lt;/span&gt; &lt;span&gt;        self.assertIn(a, b)
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt; 
&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    def test03(self):
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;判断 a is True &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;28&lt;/span&gt;         a =&lt;span&gt; True
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;        self.assertTrue(a)
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt; 
&lt;span&gt;31&lt;/span&gt; &lt;span&gt;    def test04(self):
&lt;/span&gt;&lt;span&gt;32&lt;/span&gt;         &lt;span&gt;'''&lt;/span&gt;&lt;span&gt;失败案例&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;
&lt;span&gt;33&lt;/span&gt;         a = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;北京-宏哥&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;         b = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hongge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;span&gt;35&lt;/span&gt; &lt;span&gt;        self.assertEqual(a, b)
&lt;/span&gt;&lt;span&gt;36&lt;/span&gt; 
&lt;span&gt;37&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
&lt;/span&gt;&lt;span&gt;38&lt;/span&gt;     unittest.main()
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;自定义异常输出&lt;/h2&gt;
&lt;p&gt;1、以 assertEqual 为例分析，在pycharm中通过ctrl（command）+🖱️左键我们可以定位到方法的位置：&lt;/p&gt;
&lt;p&gt;python3&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190425135159452-1599240793.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;python2&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190425152349327-676285006.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、python2翻译：如果两个对象不能相等，就返回失败，相当于 return: first==second&lt;/p&gt;
&lt;p&gt;      python3如果你断言的 语句正确 则什么反应都没有，但是如果你出错之后 就会报出    AssertionError 并且错误可以自己填写。&lt;/p&gt;
&lt;p&gt;3、这里除了相比较的两个参数 first 和 second，还有第三个参数 msg=None,这个 msg 参数就是遇到异常后自定义输出信息&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1232840/201904/1232840-20190425152903796-1149254712.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、参考代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
# coding=utf-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;.先设置编码，utf-&lt;span&gt;8可支持中英文，如上，一般放在第一行

#&lt;/span&gt;&lt;span&gt;2&lt;/span&gt;&lt;span&gt;.注释：包括记录创建时间，创建人，项目名称。
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;Created on &lt;span&gt;2019&lt;/span&gt;-&lt;span&gt;4&lt;/span&gt;-&lt;span&gt;25&lt;/span&gt;&lt;span&gt;
@author: 北京&lt;/span&gt;-&lt;span&gt;宏哥
Project:学习和使用unittest框架编写断言
&lt;/span&gt;&lt;span&gt;'''
&lt;/span&gt;#&lt;span&gt;3&lt;/span&gt;&lt;span&gt;.导入unittest模块
import unittest
#&lt;/span&gt;&lt;span&gt;4&lt;/span&gt;&lt;span&gt;.编写测试用例和断言

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; Test(unittest.TestCase):
    def test01(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;判断 a == b &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        a &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        b &lt;/span&gt;= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
        self.assertEqual(a, b)
    def test02(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;判断 a in b &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        a &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello hongge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        b &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hello hongge and world!&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        self.assertIn(a, b)

    def test03(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;判断 a is True &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        a &lt;/span&gt;=&lt;span&gt; True
        self.assertTrue(a)

    def test04(self):
        &lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;失败案例&lt;/span&gt;&lt;span&gt;'''&lt;/span&gt;&lt;span&gt;
        a &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;北京-宏哥&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        b &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;hongge&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
        self.assertEqual(a, b,msg&lt;/span&gt;=&lt;span&gt;'&lt;/span&gt;&lt;span&gt;失败原因: %s!=%s&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;%&lt;span&gt;(a,b))

&lt;/span&gt;&lt;span&gt;if&lt;/span&gt; __name__ == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;:
    unittest.main()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;小结&lt;/h2&gt;
&lt;p&gt;　　unittest断言开篇就介绍这里，另外大家也不要纠结python2或者python3，建议小伙伴们使用python3，因为python2到2020年官方就好像不会维护了！！！&lt;/p&gt;
&lt;/div&gt;
</description>
<pubDate>Thu, 25 Apr 2019 07:33:00 +0000</pubDate>
<dc:creator>北京-宏哥</dc:creator>
<og:description>简介 在测试用例中，执行完测试用例后，最后一步是判断测试结果是 pass 还是 fail，自动化测试脚本里面一般把这种生成测试结果的方法称为断言（assert）。用 unittest 组件测试用例的时</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/du-hong/p/10755859.html</dc:identifier>
</item>
<item>
<title>使用 ASP.NET Core MVC 创建 Web API（五） - DotNet菜园</title>
<link>http://www.cnblogs.com/chillsrc/p/10768738.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chillsrc/p/10768738.html</guid>
<description>&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;strong&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;span class=&quot;postTitle2&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10614598.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（一）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10649898.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（二）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10697463.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（三）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;a id=&quot;homepage1_HomePageDays_DaysList_ctl00_DayList_TitleUrl_0&quot; class=&quot;postTitle2&quot; href=&quot;https://www.cnblogs.com/chillsrc/p/10727666.html&quot;&gt;&lt;span&gt;使用 ASP.NET Core MVC 创建 Web API（四）&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2&gt;&lt;span&gt;十五、添加更新方法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;    Http定义了与 服务器的交互方法，其中除了一般我们用的最多的GET,POST这两个方法之外， 其实还有PUT和DELETE。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    PUT通常用于向服务器发送请求，如果URI不存在，则要求服务器根据请求创建资源，如果存在，服务器就接受请求内容，并修改URI资源的原始版本。如果新的资源被创建，这个原始服务器就必须通过201（Created）响应通知用户代理。如果已有资源被修改，则发送200或者204响应，表示成功完成了该请求。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;   PutBookItem&lt;/code&gt;与 &lt;code&gt;PostBookItem&lt;/code&gt; 类似，但是使用的是 HTTP PUT。 响应是 204（无内容）。 根据 HTTP 规范，PUT 请求需要客户端发送整个更新的实体，而不仅仅是更改。如果在调用 &lt;code&gt;PutBookItem&lt;/code&gt;时出错，请先调用 &lt;code&gt;GET&lt;/code&gt; 方法以确保数据库中有指定的书籍信息。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;       在Visual Studio 2017中打开BookController.cs文件，添加以下 &lt;code&gt;PutBookItem&lt;/code&gt; 方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; PUT: api/Book/5&lt;/span&gt;
        [HttpPut(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; PutBookItem(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id, Book item)
        {
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (id !=&lt;span&gt; item.ID)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; BadRequest();
            }

            _context.Entry(item).State &lt;/span&gt;=&lt;span&gt; EntityState.Modified;
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _context.SaveChangesAsync();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NoContent();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;&lt;span&gt;     一）测试 &lt;code&gt;PutBookItem&lt;/code&gt;方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;      在进行 PUT 调用之前，在数据库中必须要有所要修改的书籍信息。请先调用 GET 方法以确认数据库中存在进行 PUT 调用的书籍信息数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     1) 在Visual Studio 2017中按F5，启动BookApi应用程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    2) 打开Firefox浏览器，并打开 Rester，在Reseter中，将 HTTP 方法设置为 &lt;code&gt;PUT&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     3) 选择“Headers”选项卡，选择“Content-Type”选项，并将值设置为 JSON (application/json)。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     4) 然后选择“BODY”选项卡，在请求正文中，输入书籍信息的 JSON，如下图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201904/10343-20190425152851652-1003966308.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; JSON字符串：{&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &quot;id&quot;: 24,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &quot;name&quot;: &quot;Python编程实例&quot;,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &quot;releaseDate&quot;: &quot;2018-03-02&quot;,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &quot;price&quot;: 59.49,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &quot;author&quot;: &quot;马瑟斯&quot;,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &quot;publishing&quot;: &quot;机械工业出版社&quot;,&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     &quot;rowVersion&quot;: &quot;AAAAAAAANrE=&quot;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;}&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt;    5) 使用鼠标左键，单击“SEND”按钮。 响应返回204，这次修改成功。结果如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201904/10343-20190425152907762-1045979678.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     6) 如下图，我们对ID=24的书籍信息进行了修改。我们来看一下更新前后的变化。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201904/10343-20190425152919943-5310623.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;h2&gt;&lt;span&gt;十六、添加删除方法&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;span&gt;     我们通过Http定义的DELETE方法删除一条书籍信息。DELETE请求就是执行相应的删除操作，配合数据库进行相应的删除动作。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;code&gt;  DeleteBookItem&lt;/code&gt;使用的是 HTTP DELETE。 响应是 204（无内容）。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    在Visual Studio 2017中打开BookController.cs文件，添加以下 &lt;code&gt;DeleteBookItem&lt;/code&gt; 方法：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; DELETE: api/Book/5&lt;/span&gt;
        [HttpDelete(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;async&lt;/span&gt; Task&amp;lt;IActionResult&amp;gt; DeleteBookItem(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; book = &lt;span&gt;await&lt;/span&gt;&lt;span&gt; _context.Book.FindAsync(id); 

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (book == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;)
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NotFound();
            } 
            _context.Book.Remove(book);
            &lt;/span&gt;&lt;span&gt;await&lt;/span&gt;&lt;span&gt; _context.SaveChangesAsync();
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; NoContent();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;&lt;span&gt;    一）  测试 DeleteBookItem方法&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;span&gt;    在进行 DELETE 调用之前，在数据库中必须要有所要删除的书籍信息。请先调用 GET 方法以确认数据库中存在进行 DELETE 调用的书籍信息数据。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   1) 在Visual Studio 2017中按F5，启动BookApi应用程序。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   2) 打开Firefox浏览器，并打开 Rester，在Reseter中，将 HTTP 方法设置为 &lt;code&gt;DELETE&lt;/code&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   3) 然后在URL输入框中输入要删除的对象URI，例如 &lt;code&gt;http://localhost:5000/api/book/24&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;   4) 使用鼠标，点击“Send”按钮。如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201904/10343-20190425152945390-847020811.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    5) 删除成功，如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201904/10343-20190425153002430-1617546159.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;      6)如果数据库中没有我们所要删除的数据，则会提示如下图。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201904/10343-20190425153021431-991756343.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;     7) 我们在浏览器中查询刚才的URI地址，如下图。数据已经不存在了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/10343/201904/10343-20190425153035478-187859704.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Apr 2019 07:31:00 +0000</pubDate>
<dc:creator>DotNet菜园</dc:creator>
<og:description>通过使用Http定义的服务器的交互方法，进行更新与删除。 PUT通常用于向服务器发送请求，如果URI不存在，则要求服务器根据请求创建资源，如果存在，服务器就接受请求内容，并修改URI资源的原</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chillsrc/p/10768738.html</dc:identifier>
</item>
<item>
<title>WebSocket协议详解与c++&amp;c#实现 - 知然</title>
<link>http://www.cnblogs.com/zhiranok/p/websocketintro.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhiranok/p/websocketintro.html</guid>
<description>&lt;h2 id=&quot;摘要&quot;&gt;摘要：&lt;/h2&gt;
&lt;p&gt;随着手机游戏、H5游戏以及微信小游戏的普及，越来越多的客户端-服务器端的通讯采用websocket协议。Websocket协议是全双工的、基于数据帧的、建立在tcp之上的长连接协议。Websocket的协议是头是字符串的兼容http的，而握手之后的数据帧则是紧凑的二进制，所以websocket是紧凑和高效的。现在主流的PC浏览器以及手机浏览器对websocket都实现了非常成熟的支持。Websocket协议有着统一的标准的，所有websocket通讯无论实现的语言如何，无论使用的终端如何，最终都是一致的。&lt;br/&gt;Websocket的有点有：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;Websocket有公共的标准，有很多公共的库可以使用，比如web端，各个浏览器都已原生的支持websocket，所以拿来即用，非常的方便。比如cocos2dx就继承了websocket。&lt;/li&gt;
&lt;li&gt;比如游戏使用了websocket，那么就可以非常容易的用web调用js发websocket消息，从而模拟客户端的操作。&lt;/li&gt;
&lt;li&gt;Websocket相对于http是长连接的，这样就可以实现实时的推送消息。&lt;/li&gt;
&lt;li&gt;Websocket既能支持文本格式也可以支持二进制格式，这样无论是js还是c++，都可以适当的选择自己喜欢的数据格式。&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/282357/201904/282357-20190425151301014-857877233.png&quot;/&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;Websocket可以说完全治好了大家关于长连接使用什么协议的纠结。再游戏行业，服务器一般都是使用C++专门开发的网络程序，常规的一般都是使用比较传统的二进制协议，现在想用websocket的人越来越多，但是可以用于服务器端的websocket库却很少，要不就是库太重量级依赖了太多不需要的模块要不就是绑定了特定的网络接口实现，github上搜了下还websocket库很少。下面介绍一下我的通用websocket解析库，具有如下特点。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;轻量，只封装websocket的解析，不依赖任何网络接口，拿来即用。&lt;/li&gt;
&lt;li&gt;逻辑清晰，你可以直接看代码，直接能够理解websocket的协议。&lt;/li&gt;
&lt;li&gt;One header file only。全部实现就在一个头文件里，集成不能再容易了。&lt;/li&gt;
&lt;li&gt;目前提供C++和c#的实现。别的语言我就没空写了，刚兴趣的可以照猫画虎来一个。&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;websocket消息头&quot;&gt;Websocket消息头：&lt;/h2&gt;
&lt;p&gt;模拟发送websocket非常的容易，我们写一个很简单的html+js就可以实现，当然你可以直接使用我的这个模拟客户端: &lt;a href=&quot;https://fanchy.github.io/client.html%E3%80%82%E6%AF%94%E5%A6%82%E6%88%91%E4%BB%AC%E8%BE%93%E5%85%A5ip%E4%B8%BA127.0.0.1%E7%AB%AF%E5%8F%A344000%EF%BC%8C%E5%B0%86%E4%BC%9A%E5%8F%97%E5%88%B0%E8%BF%99%E6%A0%B7%E7%9A%84%E6%96%87%E6%9C%AC%E5%8D%8F%E8%AE%AE&quot; class=&quot;uri&quot;&gt;https://fanchy.github.io/client.html。比如我们输入ip为127.0.0.1端口44000，将会受到这样的文本协议&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&quot;html&quot;&gt;
&lt;code&gt;GET /chat HTTP/1.1
Host: 127.0.0.1:44000
Connection: Upgrade
Pragma: no-cache
Cache-Control: no-cache
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36
Upgrade: websocket
Origin: https://fanchy.github.io
Sec-WebSocket-Version: 13
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Sec-WebSocket-Key: 8SIMf+o8pqn1RCe/ivxtPg==
Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关键参数有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Get /chat 这个是客户端指定的目录，我们做游戏服务器的，基本上根据目录区分服务器，只根据端口区分服务器，所以这个参数实际上可以忽略。&lt;/li&gt;
&lt;li&gt;Upgrade: websocket 这个必须有，这个是兼容http的需要，有这个字段说明这个不是普通的http是一个websocket的连接。&lt;/li&gt;
&lt;li&gt;Sec-WebSocket-Version版本号，可以忽略。&lt;/li&gt;
&lt;li&gt;Sec-WebSocket-Key这个是用作握手的key，具体使用见下文。&lt;br/&gt;Websocket协议的验证&lt;br/&gt;我们游戏服务器可能使用多种协议，比如同时兼容二进制协议和websocket协议。因为有websocket一定是GET开头的，所以我们可以通过验证第一个消息是不是带GET字符串从而判断对方连接是websocket连接还是普通连接。示例代码：&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;if (statusWebSocketConnection == -1)
{
    return false;
}
cacheRecvData.append(buff, len);
if (dictParams.empty() == true)
{
    std::string&amp;amp; strRecvData = cacheRecvData;
    if (strRecvData.size() &amp;gt;= 3)
    {
        if (strRecvData.find(&quot;GET&quot;) == std::string::npos)
        {
            statusWebSocketConnection = -1;
            return false;
        }
    }
    else if (strRecvData.size() &amp;gt;= 2)
    {
        if (strRecvData.find(&quot;GE&quot;) == std::string::npos)
        {
            statusWebSocketConnection = -1;
            return false;
        }
    }
    else
    {
        if (strRecvData.find(&quot;G&quot;) == std::string::npos)
        {
            statusWebSocketConnection = -1;
            return false;
        }
    }
    statusWebSocketConnection = 1;
    if (strRecvData.find(&quot;\r\n\r\n&quot;) == std::string::npos)//!header data not end
    {
        return true;
    }
    if (strRecvData.find(&quot;Upgrade: websocket&quot;) == std::string::npos)
    {
        statusWebSocketConnection = -1;
        return false;
    }
    std::vector&amp;lt;std::string&amp;gt; strLines;
    strSplit(strRecvData, strLines, &quot;\r\n&quot;);
    for (size_t i = 0; i &amp;lt; strLines.size(); ++i)
    {
        const std::string&amp;amp; line = strLines[i];
        std::vector&amp;lt;std::string&amp;gt; strParams;
        strSplit(line, strParams, &quot;: &quot;);
        if (strParams.size() == 2)
        {
            dictParams[strParams[0]] = strParams[1];
        }
        else if (strParams.size() == 1 &amp;amp;&amp;amp; strParams[0].find(&quot;GET&quot;) != std::string::npos)
        {
            dictParams[&quot;PATH&quot;] = strParams[0];
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;websocket的握手&quot;&gt;Websocket的握手&lt;/h2&gt;
&lt;p&gt;Websocket因为要兼容http，所以会发一个常规的http的协议头，然后进行一次握手从而建立安全连接。Websocket握手的时候也就是建立连接后第一个消息会包含Sec-WebSocket-Key这个字段，服务器接收到这个字段后追加一个固定的guid值&quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;，然后做sha1加密并转base64变成可见字符返回给客户端。&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;if (dictParams.find(&quot;Sec-WebSocket-Key&quot;) != dictParams.end())
{
    const std::string&amp;amp; Sec_WebSocket_Key = dictParams[&quot;Sec-WebSocket-Key&quot;];
    std::string strGUID = Sec_WebSocket_Key + &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;;
    std::string dataHashed = sha1Encode(strGUID);
    std::string strHashBase64 = base64Encode(dataHashed.c_str(), dataHashed.length(), false);

    char buff[512] = {0};
    snprintf(buff, sizeof(buff), &quot;HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: %s\r\n\r\n&quot;, strHashBase64.c_str());

    addSendPkg(buff);
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;组装成websocket协议头如下：&lt;br/&gt;HTTP/1.1 101 Switching Protocols&lt;br/&gt;Upgrade: websocket&lt;br/&gt;Connection: Upgrade&lt;br/&gt;Sec-WebSocket-Accept: mzjDI+C9Ekz6tc/f5gWv38L5Hu0=&lt;br/&gt;客户端收到服务器的这个应答消息后，握手完成，连接建立完成，开始数据传输。&lt;/p&gt;
&lt;h2 id=&quot;数据帧&quot;&gt;数据帧&lt;/h2&gt;
&lt;p&gt;与tcp的流式数据不同，与http相似，websocket使用帧的方式传输数据，这样解包实际上是方便的，根据长度解析消息包这个最清晰了。&lt;br/&gt;ABNF如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/282357/201904/282357-20190425151602833-600685027.jpg&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;FIN：1 bit，如果不是分片，这个就是1，如果是分片，并且不是最后一个片，那么就是0&lt;/li&gt;
&lt;li&gt;RSV1, RSV2, RSV3: 每个1 bit，简单说用不到&lt;/li&gt;
&lt;li&gt;Opcode: 4 bits， 0，1, 2都代表数据，8代表关闭连接，0X9为ping，0XA为pong其他用不到。&lt;/li&gt;
&lt;li&gt;Mask: 1 bit 这个客户端必须是1.&lt;/li&gt;
&lt;li&gt;Payload length: 7 bits, 7+16 bits, 或者 7+64 bits，，如果是小于126就用一个字节表示数据长度，如果等于126，表示后续2字节表示长度，如果是127后续8字节表示长度。&lt;/li&gt;
&lt;li&gt;Masking-key: 0 or 4 bytes 客户端发送的必须有掩码&lt;/li&gt;
&lt;li&gt;Payload data不出意外剩下的就是数据了。&lt;/li&gt;
&lt;/ul&gt;&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;int nFIN = ((cacheRecvData[0] &amp;amp; 0x80) == 0x80)? 1: 0;
    int nOpcode = cacheRecvData[0] &amp;amp; 0x0F;
    //int nMask = ((cacheRecvData[1] &amp;amp; 0x80) == 0x80) ? 1 : 0; //!this must be 1
    int nPayload_length = cacheRecvData[1] &amp;amp; 0x7F;
    int nPlayLoadLenByteNum = 1;
    if (nPayload_length == 126)
    {
        nPlayLoadLenByteNum = 3;
    }
    int nMaskingKeyByteNum = 4;
    std::string aMasking_key;
    aMasking_key.assign(cacheRecvData.c_str() + 1 + nPlayLoadLenByteNum, nMaskingKeyByteNum);
    std::string aPayload_data;
    aPayload_data.assign(cacheRecvData.c_str() + 1 + nPlayLoadLenByteNum + nMaskingKeyByteNum, nPayload_length);
    int nLeftSize = cacheRecvData.size() - (1 + nPlayLoadLenByteNum + nMaskingKeyByteNum + nPayload_length);

    if (nLeftSize &amp;gt; 0)
    {
        std::string leftBytes;
        leftBytes.assign(cacheRecvData.c_str() + 1 + nPlayLoadLenByteNum + nMaskingKeyByteNum + nPayload_length, nLeftSize);
        cacheRecvData = leftBytes;
    }
    for (int i = 0; i &amp;lt; nPayload_length; i++)
    {
        aPayload_data[i] = (char)(aPayload_data[i] ^ aMasking_key[i % nMaskingKeyByteNum]);
    }

    if (8 == nOpcode)
    {
        addSendPkg(buildPkg(&quot;&quot;, nOpcode));// close
        bIsClose = true;
    }
    else if (2 == nOpcode || 1 == nOpcode || 0 == nOpcode || 9 == nOpcode)
    {
        if (9 == nOpcode)//!ping
        {
            addSendPkg(buildPkg(&quot;&quot;, 0xA));// pong
        }

        if (nFIN == 1)
        {
            if (dataFragmentation.size() == 0)
            {
                addRecvPkg(aPayload_data);
            }
            else
            {
                dataFragmentation += aPayload_data;
                addRecvPkg(dataFragmentation);
                dataFragmentation.clear();
            }
        }
        else
        {
            dataFragmentation += aPayload_data;
        }
    }&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;pingpongclose&quot;&gt;Ping/pong/close&lt;/h2&gt;
&lt;p&gt;收到ping就发pong，有可能ping的时候也带着数据，所以要处理下。但是貌似Chrome很长时间不会自动发ping。&lt;br/&gt;服务器收到close消息可以回一个消息应答一下，也可以直接关闭连接。&lt;br/&gt;集成到网络层&lt;br/&gt;在自己的socket里加一个WSProtocol对象，在收到消息的地方一般是HandleRecv函数里加一段WSProtocol判断和处理的代码就可以了，示例如下：&lt;/p&gt;
&lt;pre class=&quot;cpp&quot;&gt;
&lt;code&gt;if (m_oWSProtocol.handleRecv(buff, len))
{
    const vector&amp;lt;string&amp;gt;&amp;amp; waitToSend = m_oWSProtocol.getSendPkg();
    for (size_t i = 0; i &amp;lt; waitToSend.size(); ++i)
    {
        sp_-&amp;gt;sendRaw(waitToSend[i]);
    }
    m_oWSProtocol.clearSendPkg();

    const vector&amp;lt;string&amp;gt;&amp;amp; recvPkg = m_oWSProtocol.getRecvPkg();
    for (size_t i = 0; i &amp;lt; recvPkg.size(); ++i)
    {
        const string&amp;amp; eachRecvPkg = recvPkg[i];
        uint16_t nCmd = 0;
        m_message.getHead().cmd = nCmd;
        m_message.appendToBody(eachRecvPkg.c_str(), eachRecvPkg.size());
        m_message.getHead().size = eachRecvPkg.size();
        this-&amp;gt;post_msg(sp_);
        m_message.clear();
    }
    m_oWSProtocol.clearRecvPkg();
    if (m_oWSProtocol.isClose())
    {
        sp_-&amp;gt;close();
    }
    return 0;
}&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结：&lt;/h2&gt;
</description>
<pubDate>Thu, 25 Apr 2019 07:19:00 +0000</pubDate>
<dc:creator>知然</dc:creator>
<og:description>随着手机游戏、H5游戏以及微信小游戏的普及，越来越多的客户端-服务器端的通讯采用websocket协议。Websocket协议是全双工的、基于数据帧的、建立在tcp之上的长连接协议。Websocket</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhiranok/p/websocketintro.html</dc:identifier>
</item>
<item>
<title>asp.net core系列 60 Ocelot 构建服务认证示例 - 花阴偷移</title>
<link>http://www.cnblogs.com/MrHSR/p/10766590.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MrHSR/p/10766590.html</guid>
<description>&lt;h3&gt;一.概述&lt;/h3&gt;
&lt;p&gt;　　在Ocelot中，为了保护下游api资源，用户访问时需要进行认证鉴权，这需要在Ocelot 网关中添加认证服务。添加认证后，ReRoutes路由会进行身份验证,并使用Ocelot的基于声明的功能。在Startup.cs中注册认证服务，为每个注册提供一个方案 (authenticationProviderKey身份验证提供者密钥)。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面是在网关项目中，添加认证服务&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
{
    &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; authenticationProviderKey = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;TestKey&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;

    services.AddAuthentication()
        .AddJwtBearer(authenticationProviderKey, x &lt;/span&gt;=&amp;gt;&lt;span&gt;
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;..&lt;/span&gt;
&lt;span&gt;        });
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　其中TestKey是此提供程序已注册的方案，将映射到ReRoute的配置中&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
      &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuthenticationOptions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuthenticationProviderKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&lt;strong&gt;TestKey&lt;/strong&gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowedScopes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: []
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　当Ocelot运行时，会查看此configuration.json中的AuthenticationProviderKey节点，并检查是否使用给定密钥，该密钥是否已注册身份验证提供程序。如果没有，那么Ocelot将无法启动。如果有，则ReRoute将在执行时使用该提供程序。&lt;/p&gt;

&lt;p&gt;　　本次示例有四个项目：&lt;/p&gt;
&lt;p&gt;　　　　APIGateway网关项目　　http://localhost:9000&lt;/p&gt;
&lt;p&gt;　　　　AuthServer项目生成jwt令牌服务　　http://localhost:9009&lt;/p&gt;
&lt;p&gt;　　　　CustomerAPIServices 是web api项目　　http://localhost:9001&lt;/p&gt;
&lt;p&gt;　　　　ClientApp项目 模拟客户端HttpClient &lt;/p&gt;
&lt;p&gt;　　当客户想要访问web api服务时，首先访问API网关的身份验证模块。我们需要首先访问AuthServer以获取访问令牌，以便我们可以使用access_token访问受保护的api服务。开源&lt;a href=&quot;https://github.com/catcherwong-archive/APIGatewayDemo/tree/master/APIGatewayJWTAuthenticationDemo&quot; target=&quot;_blank&quot;&gt;Github地址&lt;/a&gt;，  架构如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190425094257319-526489470.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3 align=&quot;left&quot;&gt;二. AuthServer项目&lt;/h3&gt;
&lt;p&gt;　　此服务主要用于，为用户请求受保护的api，需要的jwt令牌&lt;span lang=&quot;EN-US&quot;&gt;。生成jwt关键代码如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;50&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt;用户使用 用户名密码 来请求服务器
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;服务器进行验证用户的信息
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;服务器通过验证发送给用户一个token
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;客户端存储token，并在每次请求时附送上这个token值, headers: {'Authorization': 'Bearer ' + token}
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;服务端验证token值，并返回数据
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;pwd&quot;&amp;gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
&lt;span&gt;        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IActionResult Get(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; pwd)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;验证用户，通过后发送一个token&lt;/span&gt;
            &lt;span&gt;if&lt;/span&gt; (name == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;catcher&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &amp;amp;&amp;amp; pwd == &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
            {

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; now =&lt;span&gt; DateTime.UtcNow;

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加用户的信息，转成一组声明，还可以写入更多用户信息声明&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; claims = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim[]
                {
                    
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;声明主题&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(JwtRegisteredClaimNames.Sub, name),
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;JWT ID 唯一标识符&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;发布时间戳 issued timestamp&lt;/span&gt;
                    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Claim(JwtRegisteredClaimNames.Iat, now.ToUniversalTime().ToString(), ClaimValueTypes.Integer64)
                };

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下面使用 Microsoft.IdentityModel.Tokens帮助库下的类来创建JwtToken

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;安全秘钥&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; signingKey = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SymmetricSecurityKey(Encoding.ASCII.GetBytes(_settings.Value.Secret));

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;生成jwt令牌(json web token)&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; jwt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityToken(
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jwt发行方&lt;/span&gt;
&lt;span&gt;                    issuer: _settings.Value.Iss,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jwt订阅者&lt;/span&gt;
&lt;span&gt;                    audience: _settings.Value.Aud,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jwt一组声明&lt;/span&gt;
&lt;span&gt;                    claims: claims,
                    notBefore: now,
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;jwt令牌过期时间&lt;/span&gt;
                    expires: now.Add(TimeSpan.FromMinutes(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;)),
                    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;签名凭证: 安全密钥、签名算法&lt;/span&gt;
                    signingCredentials: &lt;span&gt;new&lt;/span&gt;&lt;span&gt; SigningCredentials(signingKey, SecurityAlgorithms.HmacSha256)
                );
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;序列化jwt对象，写入一个字符串encodedJwt&lt;/span&gt;
                &lt;span&gt;var&lt;/span&gt; encodedJwt = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; JwtSecurityTokenHandler().WriteToken(jwt);

                &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; responseJson = &lt;span&gt;new&lt;/span&gt;&lt;span&gt;
                {
                    access_token &lt;/span&gt;=&lt;span&gt; encodedJwt,
                    expires_in &lt;/span&gt;= (&lt;span&gt;int&lt;/span&gt;)TimeSpan.FromMinutes(&lt;span&gt;2&lt;/span&gt;&lt;span&gt;).TotalSeconds
                };
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;以json形式返回&lt;/span&gt;
                &lt;span&gt;return&lt;/span&gt;&lt;span&gt; Json(responseJson);
            }
            &lt;/span&gt;&lt;span&gt;else&lt;/span&gt;&lt;span&gt;
            {
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; Json(&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　在之前讲IS4的第55篇中，讲ResourceOwnerPasswords项目，获取token也是要发送用户名和密码，那是由is4来完成，包括自动：验证用户，生成jwtToken。这里由System.IdentityModel.Tokens类库来生成jwtToken。最后返回jwt令牌token给用户。&lt;/p&gt;
&lt;p&gt;　　当catcher用户请求：http://localhost:9009/api/auth?name=catcher&amp;amp;pwd=123服务时，产生jwt令牌token，下面是换了行的Token, 如下所示：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
{&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;access_token&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9&lt;br/&gt;.eyJzdWIiOiJjYXRjaGVyIiwianRpIjoiZWJmNWIyZGItNDg5YS00OTBjLTk0NjUtODZmOTE5YWEzMDRjIiwiaWF0IjoiMjAxOS80LzI1IDE6NTc6MjAiLCJuYmYiOjE1NTYxNTc0NDAsImV4cC&lt;br/&gt;　　I6MTU1NjE1NzU2MCwiaXNzIjoiaHR0cDovL3d3dy5jLXNoYXJwY29ybmVyLmNvbS9tZW1iZXJzL2NhdGNoZXItd29uZyIsImF1ZCI6IkNhdGNoZXIgV29uZyJ9&lt;br/&gt;.O2jI7NSnothl9Agbr0VhmdoBsXhDEoxkYNOuGaSEkkg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;expires_in&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;:&lt;span&gt;120&lt;/span&gt;}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　简单了解下JWT(JSON Web Token)，它是在Web上以JSON格式传输的Token。该Token被设计为紧凑声明表示格式，意味着字节少，它可以在GET URL中，Header中，Post Parameter中进行传输。&lt;/p&gt;
&lt;p&gt;　　JWT一般由三段构成(Header.Payload.Signature)，用&quot;&lt;strong&gt;&lt;span&gt;.&lt;/span&gt;&lt;/strong&gt;&quot;号分隔开，是base64编码的，可以把该字符串放到https://jwt.io/中进行查看，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190425101125404-708015897.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　在Header中：alg:声明加密的算法，这里为HS256。typ:声明类型,这里为JWT。&lt;/p&gt;
&lt;p&gt;　　在Payload中：　　&lt;/p&gt;
&lt;p&gt;　　　　sub: 主题， jwt发布者名称。&lt;/p&gt;
&lt;p&gt;　　　　jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。也就是请求生成的token不一样。&lt;/p&gt;
&lt;p&gt;　　　　iat: 签发时间&lt;/p&gt;
&lt;p&gt;　　　　nbf: 在什么时间之前，该jwt都是不可用的,是时间戳格式。&lt;/p&gt;
&lt;p&gt;　　　　exp：jwt的过期时间，这个过期时间必须要大于签发时间。&lt;/p&gt;
&lt;p&gt;　　　　adu: 订阅者,接收jwt的一方。&lt;/p&gt;
&lt;p&gt;　　　　iss:  jwt的发行方。&lt;/p&gt;
&lt;p&gt;　　Signature(数字签名，防止信息被篡改)：&lt;/p&gt;
&lt;p&gt;　　　　包含了：base64后的Header，Payload ，Secret，secret就是用来进行jwt的签发和jwt的验证。相当于服务端的私钥。该secret在示例中，用在AuthServer和CustomerAPIServices项目中。&lt;/p&gt;

&lt;h3 align=&quot;left&quot;&gt;三. CustomerAPIServices项目&lt;/h3&gt;
&lt;p&gt;　　在该web api 项目中启用身份验证来保护api服务，使用JwtBearer，将默认的身份验证方案设置为TestKey。添加身份验证代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
 　　&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前用户(订阅者)信息&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; audienceConfig = Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Audience&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取安全秘钥&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; signingKey = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.ASCII.GetBytes(audienceConfig[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]));
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;token要验证的参数集合&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; tokenValidationParameters = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenValidationParameters
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须验证安全秘钥&lt;/span&gt;
                ValidateIssuerSigningKey = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                IssuerSigningKey &lt;/span&gt;=&lt;span&gt; signingKey,

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须验证发行方&lt;/span&gt;
                ValidateIssuer = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                ValidIssuer &lt;/span&gt;= audienceConfig[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Iss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须验证订阅者&lt;/span&gt;
                ValidateAudience = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                ValidAudience &lt;/span&gt;= audienceConfig[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Aud&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证Token有效期，使用当前时间与Token的Claims中的NotBefore和Expires对比&lt;/span&gt;
                ValidateLifetime = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 允许的服务器时间偏移量&lt;/span&gt;
                ClockSkew =&lt;span&gt; TimeSpan.Zero,
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否要求Token的Claims中必须包含Expires&lt;/span&gt;
                RequireExpirationTime = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加服务验证，方案为TestKey&lt;/span&gt;
            services.AddAuthentication(o =&amp;gt;&lt;span&gt;
            {
                o.DefaultAuthenticateScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            })
            .AddJwtBearer(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x =&amp;gt;&lt;span&gt;
             {
                 x.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                 &lt;/span&gt;&lt;span&gt;///&lt;/span&gt;&lt;span&gt;/在JwtBearerOptions配置中，IssuerSigningKey(签名秘钥)、ValidIssuer(Token颁发机构)、ValidAudience(颁发给谁)三个参数是必须的。&lt;/span&gt;
                 x.TokenValidationParameters =&lt;span&gt; tokenValidationParameters;
             });

            services.AddMvc();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;　　新建一个CustomersController类，在api方法中使用Authorize属性。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
   [Route(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;api/[controller]&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomersController : Controller
    {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;Authorize]:加了该标记，当用户请求时，需要发送有效的jwt&lt;/span&gt;
&lt;span&gt;        [Authorize]
        [HttpGet]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; IEnumerable&amp;lt;&lt;span&gt;string&lt;/span&gt;&amp;gt;&lt;span&gt; Get()
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;[] { &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Catcher Wong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;James Li&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; };
        }

        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;未加授权标记，不受保护，任何用户都可以获取&lt;/span&gt;
        [HttpGet(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;{id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)]
        &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;string&lt;/span&gt; Get(&lt;span&gt;int&lt;/span&gt;&lt;span&gt; id)
        {
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Catcher Wong - {id}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 　　下面运行，在浏览器中直接访问&lt;span lang=&quot;EN-US&quot;&gt;http://localhost:9001/api/customers 报&lt;span lang=&quot;EN-US&quot;&gt;http 500错误，而访问&lt;span lang=&quot;EN-US&quot;&gt;http://localhost:9001/api/customers/1 则成功http 200，显示“&lt;span lang=&quot;EN-US&quot;&gt;Catcher Wong - 1”&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h3&gt;四. APIGateway网关&lt;/h3&gt;
&lt;p&gt;　　添加认证服务，基本与CustomerAPIServices项目中的认证服务一样。代码如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;　　public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; ConfigureServices(IServiceCollection services)
        {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取当前用户(订阅者)信息&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; audienceConfig = Configuration.GetSection(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Audience&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取安全秘钥&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; signingKey = &lt;span&gt;new&lt;/span&gt; SymmetricSecurityKey(Encoding.ASCII.GetBytes(audienceConfig[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;]));
            
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;token要验证的参数集合&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; tokenValidationParameters = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TokenValidationParameters
            {
                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须验证安全秘钥&lt;/span&gt;
                ValidateIssuerSigningKey = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                IssuerSigningKey &lt;/span&gt;=&lt;span&gt; signingKey,

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须验证发行方&lt;/span&gt;
                ValidateIssuer = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                ValidIssuer &lt;/span&gt;= audienceConfig[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Iss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;必须验证订阅者&lt;/span&gt;
                ValidateAudience = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
                ValidAudience &lt;/span&gt;= audienceConfig[&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Aud&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;],

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否验证Token有效期，使用当前时间与Token的Claims中的NotBefore和Expires对比&lt;/span&gt;
                ValidateLifetime = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 允许的服务器时间偏移量&lt;/span&gt;
                ClockSkew =&lt;span&gt; TimeSpan.Zero,

                &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;是否要求Token的Claims中必须包含Expires&lt;/span&gt;
                RequireExpirationTime = &lt;span&gt;true&lt;/span&gt;&lt;span&gt;,
            };
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加服务验证，方案为TestKey&lt;/span&gt;
            services.AddAuthentication(o =&amp;gt;&lt;span&gt;
            {
                o.DefaultAuthenticateScheme &lt;/span&gt;= &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            })
            .AddJwtBearer(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, x =&amp;gt;&lt;span&gt;
             {
                 x.RequireHttpsMetadata &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;;
                 &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;在JwtBearerOptions配置中，IssuerSigningKey(签名秘钥)、ValidIssuer(Token颁发机构)、ValidAudience(颁发给谁)三个参数是必须的。&lt;/span&gt;
                 x.TokenValidationParameters =&lt;span&gt; tokenValidationParameters;
             });
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里也可以使用IS4承载令牌&lt;/span&gt;
            &lt;span&gt;/*&lt;/span&gt;&lt;span&gt;
             var authenticationProviderKey = &quot;TestKey&quot;;
             Action&amp;lt;IdentityServerAuthenticationOptions&amp;gt; options = o =&amp;gt;
            {
                 o.Authority = &quot;&lt;/span&gt;&lt;span&gt;https://whereyouridentityserverlives.com&lt;/span&gt;&lt;span&gt;&quot;;
                 o.ApiName = &quot;api&quot;;
                 o.SupportedTokens = SupportedTokens.Both;
                 o.ApiSecret = &quot;secret&quot;;
             };
            services.AddAuthentication()
                .AddIdentityServerAuthentication(authenticationProviderKey, options);
            &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;


            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;添加Ocelot网关服务时,包括Secret秘钥、Iss发布者、Aud订阅者&lt;/span&gt;
&lt;span&gt;            services.AddOcelot(Configuration);
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　在IS4中是由Authority参数指定OIDC服务地址，OIDC可以自动发现Issuer, IssuerSigningKey等配置，而o.Audience与x.TokenValidationParameters = new TokenValidationParameters { ValidAudience = &quot;api&quot; }是等效的。&lt;/p&gt;
&lt;p&gt; 　　下面应该修改configuration.json文件。添加一个名为AuthenticationOptions的新节点，并使AuthenticationProviderKey与我们在Startup类中定义的相同。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;42&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ReRoutes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
      {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/customers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamScheme&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;DownstreamHostAndPorts&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: [
          {
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Host&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;localhost&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
            &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Port&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;9001&lt;/span&gt;&lt;span&gt;
          }
        ],
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamPathTemplate&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/customers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;UpstreamHttpMethod&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: [ &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Get&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt; ],
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuthenticationOptions&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AuthenticationProviderKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;TestKey&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
          &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;AllowedScopes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: []
        }
      }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　APIGateway网关项目和CustomerAPIServices项目的appsettings.json文件，都配置了订阅者信息如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;{
    &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Audience&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;: {
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Secret&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Y2F0Y2hlciUyMHdvbmclMjBsb3ZlJTIwLm5ldA==&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Iss&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.c-sharpcorner.com/members/catcher-wong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,
        &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Aud&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;: &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Catcher Wong&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;五. ClientApp项目&lt;/h3&gt;
&lt;p&gt;　　最后使用的客户端应用程序，来模拟&lt;span lang=&quot;EN-US&quot;&gt;API网关的一些请求。首先，我们需要添加一个方法来获取&lt;span lang=&quot;EN-US&quot;&gt;access_token。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 获取jwtToken
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;string&lt;/span&gt;&lt;span&gt; GetJwt()
        {
            HttpClient client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;9000是网关，会自动转发到下游服务器，&lt;/span&gt;
            client.BaseAddress = &lt;span&gt;new&lt;/span&gt; Uri( &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:9000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            client.DefaultRequestHeaders.Clear();

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;转发到AuthServer的9009&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; res2 = client.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/api/auth?name=catcher&amp;amp;pwd=123&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Result;

            &lt;/span&gt;&lt;span&gt;dynamic&lt;/span&gt; jwt =&lt;span&gt; JsonConvert.DeserializeObject(res2.Content.ReadAsStringAsync().Result);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; jwt.access_token;
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　接着，编写了三段代码 ， 通过API Gateway网关， 来访问CustomerAPIServices项目中的api服务：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;39&quot;&gt;
&lt;pre&gt;
    &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; Main(&lt;span&gt;string&lt;/span&gt;&lt;span&gt;[] args)
        {
            HttpClient client &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpClient();

            client.DefaultRequestHeaders.Clear();
            client.BaseAddress &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; Uri(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://localhost:9000&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 1. 需要授权的api访问，没有token时,返回http状态401&lt;/span&gt;
            &lt;span&gt;var&lt;/span&gt; resWithoutToken = client.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/customers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Result;

            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Sending Request to /customers , without token.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result : {resWithoutToken.StatusCode}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;2. 需要授权的api访问，获取令牌请求api，返回http状态200正常&lt;/span&gt;
&lt;span&gt;            client.DefaultRequestHeaders.Clear();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nBegin Auth....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; jwt =&lt;span&gt; GetJwt();
            Console.WriteLine(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;End Auth....&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nToken={jwt}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);

            client.DefaultRequestHeaders.Add(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Authorization&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, $&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Bearer {jwt}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; resWithToken = client.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/customers&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Result;

            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nSend Request to /customers , with token.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result : {resWithToken.StatusCode}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(resWithToken.Content.ReadAsStringAsync().Result);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;3.不需要授权的api访问，返回http状态200正常&lt;/span&gt;
            Console.WriteLine(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\nNo Auth Service Here &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            client.DefaultRequestHeaders.Clear();
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; res = client.GetAsync(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/customers/1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;).Result;

            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Send Request to /customers/1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine($&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Result : {res.StatusCode}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            Console.WriteLine(res.Content.ReadAsStringAsync().Result);

            Console.Read();
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/151560/201904/151560-20190425142740847-625729701.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　参考文献&lt;/p&gt;
&lt;p&gt;　　　　&lt;a href=&quot;https://www.c-sharpcorner.com/article/building-api-gateway-using-ocelot-in-asp-net-core-part-two/&quot; target=&quot;_blank&quot;&gt;在ASP.NET核心中使用Ocelot构建API网关 - 身份验证&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; 　　　  &lt;a href=&quot;https://ocelot.readthedocs.io/en/latest/features/authentication.html&quot; target=&quot;_blank&quot;&gt;官方文档&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Apr 2019 07:06:00 +0000</pubDate>
<dc:creator>花阴偷移</dc:creator>
<og:description>一.概述 在Ocelot中，为了保护下游api资源，用户访问时需要进行认证鉴权，这需要在Ocelot 网关中添加认证服务。添加认证后，ReRoutes路由会进行身份验证,并使用Ocelot的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/MrHSR/p/10766590.html</dc:identifier>
</item>
<item>
<title>Vue2.0源码阅读笔记（三）：计算属性 - 雾雪天涯</title>
<link>http://www.cnblogs.com/lidengfeng/p/10768474.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lidengfeng/p/10768474.html</guid>
<description>&lt;p&gt;  计算属性是基于响应式依赖进行缓存的，只有在相关响应式依赖发生改变时才会重新求值，这种缓存机制在求值消耗比较大的情况下能够显著提高性能。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;一计算属性初始化&quot;&gt;一、计算属性初始化&lt;/h2&gt;
&lt;p&gt;  Vue 在做数据初始化时，通过 initComputed() 方法初始化计算属性。&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;const computedWatcherOptions = { lazy: true }

function initComputed (vm: Component, computed: Object) {
  const watchers = vm._computedWatchers = Object.create(null)
  const isSSR = isServerRendering()

  for (const key in computed) {
    const userDef = computed[key]
    const getter = typeof userDef === 'function' ? userDef : userDef.get
    if (process.env.NODE_ENV !== 'production' &amp;amp;&amp;amp; getter == null) {
      warn(`Getter is missing for computed property &quot;${key}&quot;.`, vm)
    }

    if (!isSSR) {
      watchers[key] = new Watcher(vm, getter || noop,
        noop, computedWatcherOptions)
    }

    if (!(key in vm)) {
      defineComputed(vm, key, userDef)
    } else if (process.env.NODE_ENV !== 'production') {
      if (key in vm.$data) {
        warn(`The computed property &quot;${key}&quot; is already defined in data.`, vm)
      } else if (vm.$options.props &amp;amp;&amp;amp; key in vm.$options.props) {
        warn(`The computed property &quot;${key}&quot; is already defined as a prop.`, vm)
      }
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  首先将变量 watchers 与变量 _computedWatchers 同时指向一个空对象，该对象用来存储所有计算属性的观察者。接着定义变量 isSSR 用来标识是否为服务器端渲染。&lt;/p&gt;&lt;p&gt;  然后对选项 computed 中的属性遍历，将属性赋值给 userDef 变量。计算属性有两种写法：函数、对象。如果是对象的话则必须要有 get(), set() 方法可以不实现。使用 getter 变量指向能够获取值的函数。&lt;/p&gt;&lt;p&gt;  在服务器端渲染时，使用计算属性的方式和使用方法基本一样。在非服务器端渲染时，生成该计算属性的观察者添加到变量 watchers 与变量 _computedWatchers 对应的属性上。&lt;/p&gt;&lt;p&gt;  最后检查 Vue 实例对象上有没有与计算属性同名的属性，因为不管选项 props 、data ，还是选项 computed 中的数据经过处理最终都会添加到 Vue 实例对象上。如果没有重复，则调用 defineComputed() 方法将计算属性处理之后添加到 Vue 实例对象上。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;二定义计算属性&quot;&gt;二、定义计算属性&lt;/h2&gt;
&lt;p&gt;  defineComputed() 函数的功能是将计算属性转化为 Vue 实例对象的访问器属性。&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;export function defineComputed (target: any, key: string,
  userDef: Object | Function
) {
  const shouldCache = !isServerRendering()
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache
      ? createComputedGetter(key)
      : createGetterInvoker(userDef)
    sharedPropertyDefinition.set = noop
  } else {
    sharedPropertyDefinition.get = userDef.get
      ? shouldCache &amp;amp;&amp;amp; userDef.cache !== false
        ? createComputedGetter(key)
        : createGetterInvoker(userDef.get)
      : noop
    sharedPropertyDefinition.set = userDef.set || noop
  }
  if (process.env.NODE_ENV !== 'production' &amp;amp;&amp;amp;
      sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn(
        `Computed property &quot;${key}&quot; was assigned to but it has no setter.`,
        this
      )
    }
  }
  Object.defineProperty(target, key, sharedPropertyDefinition)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  在非服务器端渲染时，若选项中计算属性是函数形式，则将 set() 方法设为空；若是对象形式，对象中提供 set() 方法，则采用该方法作为访问器属性的 set() 方法，如果没有提供，则 set() 方法为空。最后在 set() 方法为空的情况下，重写该方法，使其在非生产环境下访问器属性被设置时提示警告信息。&lt;/p&gt;&lt;p&gt;  计算属性的 get() 方法 为 createComputedGetter() 的返回值，该返回值为 computedGetter() 函数。&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;function createComputedGetter (key) {
  return function computedGetter () {
    const watcher = this._computedWatchers &amp;amp;&amp;amp; this._computedWatchers[key]
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate()
      }
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  比如传入 computed 选项如下：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;data () {
  retrun {
    a: 1
  }
}

computed: {
  b () {
    retrun a * 2
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  经过计算属性初始化处理之后，变成 Vue 实例对象 vm 上的属性：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;vm.b = Object.defineProperty(vm, 'b', {
  enumerable: true,
  configurable: true,
  get () {
    const watcher = this._computedWatchers &amp;amp;&amp;amp; this._computedWatchers[key]
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate()
      }
      if (Dep.target) {
        watcher.depend()
      }
      return watcher.value
    }
  },
  set () {
    warn(
      `Computed property &quot;${key}&quot; was assigned to but it has no setter.`,
      this
    )
  }
})&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;三计算属性观察者&quot;&gt;三、计算属性观察者&lt;/h2&gt;
&lt;p&gt;  上面例子中的计算属性 b 在初始化时创建的观察者对象 watcherB 如下：&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;watcherB = {
  vm: vm,
  lazy: true,
  deep: false,
  user: false,
  sync: false,
  cb: function () {},
  uid: 1,
  active: true,
  dirty: true,
  deps: [],
  newDeps: [],
  depIds: new Set(),
  newDepIds: new Set(),
  expression: 'function() {\n return a * 2 \n}',
  getter: function() { return a * 2 },
  value: undefined
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  在开发中最常见的是在模板中使用计算属性，该种情况下会先将模板转换成渲染函数，然后生成渲染函数观察者，在此过程中，会读取计算属性。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;读取计算属性时的函数执行情况&quot;&gt;（1）、读取计算属性时的函数执行情况&lt;/h3&gt;
&lt;p&gt;  在计算属性 b 被读取时，会调用访问器属性的 get() 方法。&lt;br/&gt;&lt;/p&gt;
&lt;pre class=&quot;js&quot;&gt;
&lt;code&gt;get () {
  const watcher = this._computedWatchers &amp;amp;&amp;amp; this._computedWatchers[key]
  if (watcher) {
    if (watcher.dirty) {
      watcher.evaluate()
    }
    if (Dep.target) {
      watcher.depend()
    }
    return watcher.value
  }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  此时，访问器属性的 get() 方法中的 watcher 为 watcherB ，Dep.target 为渲染函数观察者，记为 renderWatcher。函数执行的顺序如下：&lt;/p&gt;&lt;p&gt;1、watcherB.dirty 为 true ，所以先执行 watcherB.evaluate() 。在该方法中首先调用 watcherB.get() 。&lt;/p&gt;&lt;p&gt;2、watcherB.get() 先将 Dep.target 引用变量指向 watcherB ，然后 调用 watcherB.getter() 。&lt;/p&gt;&lt;p&gt;3、watcherB.getter() 会触发响应式数据 a 的 get() ，在该方法中调用 a 闭包引用的的变量 dep 的 depend() 方法。&lt;/p&gt;&lt;p&gt;4、在 dep.depend() 会调用 watcherB.addDep(dep)。&lt;/p&gt;&lt;p&gt;5、watcherB.addDep(dep)主要做三件事：将 dep.id 添加到 watcherB.newDepIds 集合中、将 dep 添加到 watcherB.newDeps 数组中、调用dep.addSub()方法。&lt;/p&gt;&lt;p&gt;6、dep.addSub() 方法会将 watcherB 添加到响应式数据 a 闭包引用的变量 dep 的 subs 数组中。&lt;/p&gt;&lt;p&gt;7、然后接着执行 watcherB.get()，首先将 Dep.target 的值设置为 renderWatcher ，再执行 watcherB.cleanupDeps()。&lt;/p&gt;&lt;p&gt;8、watcherB.cleanupDeps() 会将 watcherB.newDepIds、watcherB.newDeps 中的数据分别复制到 watcherB.depIds、watcherB.deps中，然后再清空 watcherB.newDepIds、watcherB.newDeps。&lt;/p&gt;&lt;p&gt;9、然后接着执行 watcherB.evaluate()，将 watcherB.dirty 设置为 false。&lt;/p&gt;&lt;p&gt;10、然后接着执行计算属性 b 的 get() 方法，调用 watcherB.depend()。&lt;/p&gt;&lt;p&gt;11、watcherB.depend() 方法循环 watcherB.deps 数组，调用数据 a 闭包引用的 dep 的 depend() 方法。此时的 Dep.target 的值为 renderWatcher，dep.depend() 将渲染函数观察者添加到数据 a 闭包引用的 dep 中。&lt;br/&gt;&lt;/p&gt;
&lt;h3 id=&quot;计算属性读取总结&quot;&gt;（2）、计算属性读取总结&lt;/h3&gt;
&lt;p&gt;  抛开较为繁琐的执行过程不说，当第一次读取计算属性时，主要做了以下几方面的事情：&lt;br/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;1、将&lt;strong&gt;计算属性观察者&lt;/strong&gt;收集进相关响应式数据的依赖容器中。&lt;/p&gt;&lt;p&gt;2、将使用计算属性的&lt;strong&gt;渲染函数观察者&lt;/strong&gt;收集进相关响应式数据的依赖容器中。&lt;/p&gt;&lt;p&gt;3、将&lt;strong&gt;计算属性观察者&lt;/strong&gt;的 dirty 属性设置为 false。若 dirty 为 true ，读取计算属性时会执行第1条操作。&lt;br/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;依赖改变时计算属性重新求值&quot;&gt;（3）、依赖改变时计算属性重新求值&lt;/h3&gt;
&lt;p&gt;  当计算属性依赖的响应式数据发生改变时，会触发依赖容器中的依赖，此时计算属性以及使用计算属性的渲染函数都会重新求值。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;四总结&quot;&gt;四、总结&lt;/h2&gt;
&lt;p&gt;  Vue在数据初始化时会将计算属性改造成实例对象上的访问器属性，同时生成对应的计算属性观察者。&lt;/p&gt;&lt;p&gt;  在初次读取计算属性时，会将计算属性观察者、读取计算属性的渲染函数观察者作为依赖收集到相关响应式数据的依赖容器中。再次读取计算属性时，仅仅将读取计算属性的渲染函数观察者收集到依赖容器中，因为计算属性与响应式数据的依赖关系没有发生变化，此时计算属性观察者已作为依赖被收集，不必重复添加。&lt;/p&gt;&lt;p&gt;  当相关响应式数据改变时，对应的计算属性以及渲染函数都会发生改变。&lt;/p&gt;&lt;p&gt;  计算属性就像响应式数据与渲染函数观察者之间的“桥梁”。如果渲染函数直接使用响应式数据，则只需要收集渲染函数观察者，计算属性存在的意义在于对响应式数据进行操作，而且不用每次都经过计算求值。&lt;/p&gt;&lt;p&gt;如需转载，烦请注明出处：&lt;a href=&quot;https://www.cnblogs.com/lidengfeng/p/10768474.html&quot; class=&quot;uri&quot;&gt;https://www.cnblogs.com/lidengfeng/p/10768474.html&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Apr 2019 07:00:00 +0000</pubDate>
<dc:creator>雾雪天涯</dc:creator>
<og:description>  计算属性是基于响应式依赖进行缓存的，只有在相关响应式依赖发生改变时才会重新求值，这种缓存机制在求值消耗比较大的情况下能够显著提高性能。 一、计算属性初始化  &amp;ems</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lidengfeng/p/10768474.html</dc:identifier>
</item>
<item>
<title>KnockOut 绑定之foreach绑定 - GavinJay</title>
<link>http://www.cnblogs.com/gavinjay/p/10768378.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/gavinjay/p/10768378.html</guid>
<description>&lt;p&gt;foreach绑定对于数组中的每一个元素复制一节标记语言，也就是html，并且将这节标记语言和数组里面的每一个元素绑定。当我们呈现一组list数据，或者一个表格的时候，十分有用。&lt;/p&gt;
&lt;p&gt;如果你绑定的数组是一个&quot;监控数组&quot; ,observable arra&lt;a href=&quot;http://knockoutjs.com/documentation/observableArrays.html&quot;&gt;y&lt;/a&gt;,(和wpf里面的ObservableCollection&amp;lt;T&amp;gt;差不多)。当你添加或移除，或者重新排序数组里面的元素的时候，会动态的更新UI界面。并且此时并不会影响原先的DOM元素。这样比我们直接重新生成一个数组并且绑定元素高效的多。&lt;/p&gt;
&lt;p&gt;当然，foreach也支持嵌套绑定，或者和其他工作流绑定例如if 或者with。&lt;/p&gt;
&lt;h3 class=&quot;customerh3&quot;&gt;Example 1: 迭代绑定一个数组&lt;/h3&gt;
&lt;p&gt;对数组中的每一个元素生成一行数据的只读表。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/Scripts/jquery-1.10.2.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/Scripts/knockout-3.2.0.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;table&amp;gt;
    &amp;lt;thead&amp;gt;
        &amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;First name&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;Last name&amp;lt;/th&amp;gt;&amp;lt;/tr&amp;gt;
    &amp;lt;/thead&amp;gt;
    &amp;lt;tbody data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foreach: people&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
        &amp;lt;tr&amp;gt;
            &amp;lt;td data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text: firstName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/td&amp;gt;
            &amp;lt;td data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text: lastName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/td&amp;gt;
        &amp;lt;/tr&amp;gt;
    &amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;

&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
    ko.applyBindings({
        people: [
            { firstName: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, lastName: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bertington&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
            { firstName: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Charles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, lastName: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Charlesforth&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
            { firstName: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Denise&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, lastName: &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Dentiste&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
        ]
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;example-2-live-example-with-addremove&quot; class=&quot;customerh3&quot;&gt;Example 2: 给例1中的制度表加上一个增加和移除方法&lt;/h3&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/Scripts/jquery-1.10.2.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/Scripts/knockout-3.2.0.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;

&amp;lt;h4&amp;gt;People&amp;lt;/h4&amp;gt;
&amp;lt;ul data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foreach: people&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;li&amp;gt;&lt;span&gt;
        Name at position &lt;/span&gt;&amp;lt;span data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text: $index&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; &amp;lt;/span&amp;gt;&lt;span&gt;:
        &lt;/span&gt;&amp;lt;span data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text: name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt; &amp;lt;/span&amp;gt;
        &amp;lt;a href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;click: $parent.removePerson&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Remove&amp;lt;/a&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;button data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;click: addPerson&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Add&amp;lt;/button&amp;gt;

&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
    function AppViewModel() {
        &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; self = &lt;span&gt;this&lt;/span&gt;&lt;span&gt;;

        self.people &lt;/span&gt;=&lt;span&gt; ko.observableArray([
            { name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Bert&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
            { name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Charles&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; },
            { name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Denise&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; }
        ]);

        self.addPerson &lt;/span&gt;=&lt;span&gt; function () {
            self.people.push({ name: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;New at &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Date() });
        };

        self.removePerson &lt;/span&gt;=&lt;span&gt; function () {
            self.people.remove(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;);
        }
    }

    ko.applyBindings(&lt;/span&gt;&lt;span&gt;new&lt;/span&gt;&lt;span&gt; AppViewModel());
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;note-1-referring-to-each-array-entry-using-data&quot; class=&quot;customerh3&quot;&gt;要点1:  用 $data来指向数组的每一条数据&lt;/h3&gt;
&lt;p&gt;就像在上面的例子中展示的。foreach绑定能够指向数组每一条数据的属性。例如例1中的firstName 和lastName.但是，如果我们想指向数组本身，应该怎么办，此时我们可以用$.data.在foreach绑定中，$data指的就是数组的当前的元素项。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/Scripts/jquery-1.10.2.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;~/Scripts/knockout-3.2.0.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;ul data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foreach: months&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;li&amp;gt;&lt;span&gt;
        The current item &lt;/span&gt;&lt;span&gt;is&lt;/span&gt;: &amp;lt;b data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text: $data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/b&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
    ko.applyBindings({
        months: [&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Jan&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Feb&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Mar&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;etc&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;]
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 当然，如果你非要这样做的话, 你也可以给你指向的每一个属性加上一个 &lt;code&gt;$data前缀&lt;/code&gt;.例如，你也可以在例1中像下面这样写,虽然这样写没必要，因为它的默认上下文就是&lt;code&gt;$data&lt;/code&gt;:&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;td data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text: $data.firstName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/td&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;note-2-using-index-parent-and-other-context-properties&quot; class=&quot;customerh3&quot;&gt;要点 2: 使用$index, $parent, 和其他的上下文属性&lt;/h3&gt;
&lt;p&gt;就像我们在例2 中看到的那样。你可一用$index 来表示数组中当前项从零开始的索引。 &lt;code&gt;$index是一个监控属性，当数组的项变更的时候$index也会自动更新。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;同样，你也可以用&lt;code&gt;$parent来指向foreach外的数据。如果foreach对应的是viewmodel的直接子元素，那么$parent就是指的viewmodel,$root是对应根元素，多层循环嵌套的时候使用$root&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;h1 data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text: blogPostTitle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/h1&amp;gt;
&amp;lt;ul data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foreach: likes&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;b data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text: name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/b&amp;gt; likes the blog post &amp;lt;b data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text: $parent.blogPostTitle&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/b&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&quot;note-3-using-as-to-give-an-alias-to-foreach-items&quot; class=&quot;customerh3&quot;&gt;要点 3: 用as 给foreach项赋值一个别名&lt;/h3&gt;
&lt;p&gt;就想在要点1里面描述的那样。我们可以引用每一个数组项用  &lt;code&gt;$data&lt;/code&gt; 上下文变量。但在一些特殊情况下，给当前项一个别名用起来更方便。尤其在多层嵌套结构中：&lt;/p&gt;
&lt;p&gt;别名使用的语法如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;ul data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foreach: { data: people, as: 'person' }&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在在foreach循环的任何地方，绑定都可以根据person指向当前people的数组项。这种语法在多层foreach嵌套的场景中非常有用。例如：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;44&quot;&gt;
&lt;pre&gt;
&amp;lt;ul data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foreach: { data: categories, as: 'category' }&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;li&amp;gt;
        &amp;lt;ul data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;foreach: { data: items, as: 'item' }&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;li&amp;gt;
                &amp;lt;span data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text: category.name&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;&lt;span&gt;:
                &lt;/span&gt;&amp;lt;span data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text: item&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;
            &amp;lt;/li&amp;gt;
        &amp;lt;/ul&amp;gt;
    &amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
 
&amp;lt;script&amp;gt;
    &lt;span&gt;var&lt;/span&gt; viewModel =&lt;span&gt; {
        categories: ko.observableArray([
            { name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Fruit&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, items: [ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Apple&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Orange&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Banana&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ] },
            { name: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;Vegetables&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, items: [ &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Celery&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Corn&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Spinach&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ] }
        ])
    };
    ko.applyBindings(viewModel);
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意: 记得通过as给别名 赋值的时候，传过去一个字符串&lt;code&gt;'category'&lt;/code&gt;, &lt;em&gt;不是&lt;/em&gt;&lt;code&gt;as: category&lt;/code&gt;), 因为我们是要给变量起一个别名，而不是传递一个标识符变量过去。&lt;/p&gt;
&lt;h3 id=&quot;note-4-using-foreach-without-a-container-element&quot; class=&quot;customerh3&quot;&gt;Note 4: 没有一个容器元素的时候使用foreach&lt;/h3&gt;
&lt;p&gt;在一些情况下，你想要通过foreach绑定一段标记语言html,但是没有供foreach绑定的元素。例如下面这张情景：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&amp;lt;ul&amp;gt;
    &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Header item&amp;lt;/li&amp;gt;
    &amp;lt;!-- The following are generated dynamically &lt;span&gt;from&lt;/span&gt; an array --&amp;gt;
    &amp;lt;li&amp;gt;Item A&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Item B&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;Item C&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这种情况下没有任何元素可供foreach绑定。你不能放到ul里面，因为这时候会把header也放到复制的循环里面去。你也不能放其它的元素在ul里面，因为ul里面只允许放&lt;code&gt;&amp;lt;li&amp;gt;元素。&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要想处理这种情况。我们可以用无容器绑定语法。这中情况是依赖于html的注释标签。如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&amp;lt;ul&amp;gt;
    &amp;lt;li &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;header&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;Header item&amp;lt;/li&amp;gt;
    &amp;lt;!-- ko &lt;span&gt;foreach&lt;/span&gt;: myItems --&amp;gt;
        &amp;lt;li&amp;gt;Item &amp;lt;span data-bind=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text: $data&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/span&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;!-- /ko --&amp;gt;
&amp;lt;/ul&amp;gt;
 
&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&lt;span&gt;
    ko.applyBindings({
        myItems: [ &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;, &lt;span&gt;'&lt;/span&gt;&lt;span&gt;C&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt; ]
    });
&lt;/span&gt;&amp;lt;/script&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;&amp;lt;!-- ko --&amp;gt;&lt;/code&gt; 和 &lt;code&gt;&amp;lt;!-- /ko --&amp;gt;&lt;/code&gt; 注释作为标签的开始和结束，定义了一个虚元素来包含我们需要重复引用的标记语言在里面，knockout理解这种虚元素语法。我们可以就当真的有一个html元素来使用它。&lt;/p&gt;
</description>
<pubDate>Thu, 25 Apr 2019 06:47:00 +0000</pubDate>
<dc:creator>GavinJay</dc:creator>
<og:description>foreach绑定对于数组中的每一个元素复制一节标记语言，也就是html，并且将这节标记语言和数组里面的每一个元素绑定。当我们呈现一组list数据，或者一个表格的时候，十分有用。 如果你绑定的数组是一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/gavinjay/p/10768378.html</dc:identifier>
</item>
<item>
<title>从css 3d说到空间坐标轴 - 陌上兮月</title>
<link>http://www.cnblogs.com/zhangnan35/p/10709876.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhangnan35/p/10709876.html</guid>
<description>&lt;p&gt;　　&lt;span&gt;有一次我们说到掷骰子那个游戏，当时是用了一个steps属性+雪碧图来制作帧动画，这当然颇为不错，但其实一开始我想的不是这样的，我想的是用真的3d和动画去做，这个方案涉及到不少空间的知识，今天来给大伙好好说说，这css 3d到底怎么玩。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;先上效果图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190425143054492-924541551.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;基本思路：三层结构：&lt;span&gt;&lt;strong&gt;&lt;span&gt;视角容器&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;载体&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&amp;gt;&amp;gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;具体3d图像&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;视角容器&lt;/span&gt;&lt;/strong&gt;：&lt;span&gt;决定3d的呈现效果，这里的pespective属性接收参数为像素，perspective的值越大，代表“&lt;strong&gt;眼睛离观察物越远&lt;/strong&gt;”，值越小，代表“&lt;strong&gt;眼睛越靠近观察物&lt;/strong&gt;”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;缺少perspective属性，将无法调整观测的视角。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190425134334250-446898701.jpg&quot; alt=&quot;&quot;/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190425134355709-764198521.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;strong&gt;&lt;span&gt;载体&lt;/span&gt;&lt;/strong&gt;：&lt;span&gt;支持承载3d图像&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这个载体跟普通的html标签最大的区别在于它多了一个属性:&lt;strong&gt;transform-style:preserve-3d&lt;/strong&gt;。表示它支持3d图像显示。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;如果缺少了这个属性，进行过3d转换的3d图形们将被压在一个2d平面内，无法呈现出3d效果，因为容器都是扁的，即使内容是3d的也于事无补。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;　　&lt;span&gt;&lt;strong&gt;具体3d图像&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;从2d到3d的转换&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;这里的3d图像都是由2d平面图像转换而来，那么如何转换呢。需要用到translateX，translateY，translateZ属性,当然简写也就是translate-3d，还有rotateX,rotateY,rotateZ等到。而translate（平移），rotate（旋转）的具体规则，都是基于下方这幅著名的参考图：三维坐标图进行的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190425135458622-1593901679.jpg&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;首先说translate的规则，这个自然不必多说，对照着看就可以了，比如说translateZ(-100px)在这幅图中就相当等于图像往-z轴的方向移了100px，形象一点的说法就是“&lt;strong&gt;向屏幕内部凹陷了100px&lt;/strong&gt;”。translateX，translateY以此类推。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　难点在rotate，告诉大家一个很简单的判断法则：&lt;span&gt;&lt;strong&gt;正向轴对着眼睛，顺时针则旋转角度为正，逆时针则旋转角度为负。&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　就是这么简单，比如现在我们要制作一个3d骰子,首先六个平面图都如上图所示摆在三维坐标系的中心店，他们的大小都跟载体一样，要变成一个骰子，需要做如下变换：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　&lt;span&gt;（注：载体和6个面的长宽均为200px）&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1328957/201904/1328957-20190425142223887-843487672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　&lt;span&gt;对照着3d图，大家比划比划就知道怎么回事了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　  附上全部源码：&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;
  &amp;lt;div class=&quot;box&quot;&amp;gt;
    &amp;lt;section class=&quot;cube&quot;&amp;gt;
      &amp;lt;div class=&quot;front&quot;&amp;gt;前面&amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;back&quot;&amp;gt;后面&amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;left&quot;&amp;gt;左面&amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;right&quot;&amp;gt;右面&amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;top&quot;&amp;gt;上面&amp;lt;/div&amp;gt;
      &amp;lt;div class=&quot;bottom&quot;&amp;gt;下面&amp;lt;/div&amp;gt;
    &amp;lt;/section&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;style lang=&quot;less&quot; scoped&amp;gt;&lt;span&gt;
.box {
  width: &lt;/span&gt;100%&lt;span&gt;;
  height: &lt;/span&gt;100%&lt;span&gt;;
  perspective: 500px;
}

.cube {
  position: relative;
  width: 200px;
  height: 200px;
  margin: 100px auto;
  color: #ff92ff;
  font&lt;/span&gt;-&lt;span&gt;size: 36px;
  font&lt;/span&gt;-weight: 100&lt;span&gt;;
  text&lt;/span&gt;-&lt;span&gt;align: center;
  line&lt;/span&gt;-&lt;span&gt;height: 200px;
  transform&lt;/span&gt;-style: preserve-&lt;span&gt;3d;
  transform: rotateX(&lt;/span&gt;-50deg) rotateY(-&lt;span&gt;50deg) rotateZ(0deg);
  &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; animation: move 8s infinite linear;&lt;/span&gt;
&lt;span&gt;
  @keyframes move {
    &lt;/span&gt;0%&lt;span&gt; {
      transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg);
    }
    &lt;/span&gt;100%&lt;span&gt; {
      transform: rotateX(720deg) rotateY(360deg) rotateZ(360deg);
    }
  }

  div {
    position: absolute;
    width: &lt;/span&gt;100%&lt;span&gt;;
    height: &lt;/span&gt;100%&lt;span&gt;;
    border: 10px solid #66daff;
    border&lt;/span&gt;-&lt;span&gt;radius: 20px;
    background&lt;/span&gt;-color: rgba(51, 51, 51, 0.3&lt;span&gt;);
  }

  .front {
    transform: translateZ(100px);
  }

  .back {
    transform: translateZ(&lt;/span&gt;-&lt;span&gt;100px) rotateY(180deg);
  }

  .left {
    transform: translateX(&lt;/span&gt;-100px) rotateY(-&lt;span&gt;90deg);
  }

  .right {
    transform: translateX(100px) rotateY(90deg);
  }

  .top {
    transform: translateY(&lt;/span&gt;-&lt;span&gt;100px) rotateX(90deg);
  }

  .bottom {
    transform: translateY(100px) rotateX(&lt;/span&gt;-&lt;span&gt;90deg);
  }
}
&lt;/span&gt;&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;



</description>
<pubDate>Thu, 25 Apr 2019 06:39:00 +0000</pubDate>
<dc:creator>陌上兮月</dc:creator>
<og:description>有一次我们说到掷骰子那个游戏，当时是用了一个steps属性+雪碧图来制作帧动画，这当然颇为不错，但其实一开始我想的不是这样的，我想的是用真的3d和动画去做，这个方案涉及到不少空间的知识，今天来给大伙好</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zhangnan35/p/10709876.html</dc:identifier>
</item>
<item>
<title>android渠道打包怎样实现最方便 - 往昔是少年</title>
<link>http://www.cnblogs.com/stall/p/10768299.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/stall/p/10768299.html</guid>
<description>&lt;p&gt;我们都知道，Android 市场被分割成几十个应用商店渠道，程序员给渠道打包、更新是一件异常繁杂又不得不做的工作，但现在有一种快捷灵活的免费多渠道统计方式，能最大程度的提高打包效率和数据安全性。&lt;/p&gt;
&lt;p&gt;首先登录&lt;a href=&quot;https://www.openinstall.io/android_package.html&quot; rel=&quot;nofollow&quot;&gt;openinstall&lt;/a&gt; 官网，下载Android SDK，一般5-10分钟可以集成完成，非常简单。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1556774/201904/1556774-20190425143252998-1177512053.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;集成完成后，进入控制台注册相关信息，创建应用，然后上传一次Apk原始包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201904/03/4148cf1d4d0219af1a50d59b71e6e4ea.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot; alt=&quot;Android免打包多渠道统计如何实现&quot;/&gt;&lt;/p&gt;
&lt;p&gt;以上步骤只需要做一次，往后App如果进行版本更新，则只需要上传新的原始包即可。&lt;/p&gt;
&lt;p&gt;接下来正式开始多渠道打包。&lt;/p&gt;
&lt;p&gt;1、首先在渠道管理中&lt;strong&gt;新增渠道&lt;/strong&gt;，可以自己定义渠道编号和名称，比如上传到应用宝市场的，可以定义渠道ID为“应用宝”，方便后期查看统计数据。然后自定义落地页，只要将需要统计数据的页面链接添加即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201904/03/ac00a3bb044668ec55c3436b6dd09964.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot; alt=&quot;Android免打包多渠道统计如何实现&quot;/&gt;&lt;/p&gt;
&lt;p&gt;2、添加完渠道后，在列表中选择对应渠道，在渠道包下点击“导出”按钮，选择对应的原始包即可导出，导出安装包后即可测试，测试无误再上传到相应的应用商店就能自动统计相应信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201904/03/3a48ed362241a938162c4f3eabb04a9c.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot; alt=&quot;Android免打包多渠道统计如何实现&quot;/&gt;&lt;/p&gt;
&lt;p&gt;至此，&lt;strong&gt;多渠道打包工作通过这两步就完成了&lt;/strong&gt;，理论上可以创建无数个渠道，简单到无以复加。接下来再介绍数据统计功能。&lt;/p&gt;
&lt;p&gt;3、渠道产生的统计数据可以直接在渠道列表中直观的查看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201904/03/4a6fb88b0fda52236df0edd3979d4285.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot; alt=&quot;Android免打包多渠道统计如何实现&quot;/&gt;&lt;/p&gt;
&lt;p&gt;也可以生成推广链接或二维码，不管是投放广告还是地推统计，都能实现高效率推广。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201904/03/13e085e339c7fa6c25519e4795321b57.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot; alt=&quot;Android免打包多渠道统计如何实现&quot;/&gt;&lt;/p&gt;
&lt;p&gt;更多用户画像和渠道信息分析，可以点击详细图表查看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201904/03/30feec182b8c2c38a18fdc47664e449d.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot; alt=&quot;Android免打包多渠道统计如何实现&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果怕地推业绩或者广告效益产生争议，可以将该渠道信息进行加密分享，所有数据一目了然。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201904/03/3527a67b1a674aeb16c310e4bd169db2.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot; alt=&quot;Android免打包多渠道统计如何实现&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4、如果你对统计维度不够满意，可以根据需求创建自定义效果点，代码中调用相关Api 即可实现，openinstall 的所有数据均是实时排重，实时统计的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://s1.51cto.com/images/blog/201904/03/a50fac81f3bb068a4d6483152f927844.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=&quot; alt=&quot;Android免打包多渠道统计如何实现&quot;/&gt;&lt;/p&gt;
&lt;p&gt;实际上只要完成1-2步即可实现多渠道打包，这也意味着，只要每次更新App时给出一个原始包，运营人员就能在后台自己进行操作管理，简单快捷到全程无需开发人员参与。&lt;/p&gt;
&lt;p&gt;如此高效的多渠道打包方式，你不想试试吗？&lt;/p&gt;
</description>
<pubDate>Thu, 25 Apr 2019 06:35:00 +0000</pubDate>
<dc:creator>往昔是少年</dc:creator>
<og:description>我们都知道，Android 市场被分割成几十个应用商店渠道，程序员给渠道打包、更新是一件异常繁杂又不得不做的工作，但现在有一种快捷灵活的免费多渠道统计方式，能最大程度的提高打包效率和数据安全性。 首先</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/stall/p/10768299.html</dc:identifier>
</item>
<item>
<title>目标检测 anchor 理解笔记 - zfCode</title>
<link>http://www.cnblogs.com/zfcode/p/mu-biao-jian-ce-anchor-li-jie-bi-ji.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zfcode/p/mu-biao-jian-ce-anchor-li-jie-bi-ji.html</guid>
<description>&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;anchor在计算机视觉中有锚点或锚框，目标检测中常出现的anchor box是锚框，表示&lt;strong&gt;固定的参考框&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;toc_0&quot;&gt;&lt;strong&gt;目标检测的任务：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;在哪里有东西&lt;/p&gt;
&lt;h3 id=&quot;toc_1&quot;&gt;&lt;strong&gt;难点：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;目标的类别不确定、数量不确定、位置不确定、尺度不确定&lt;/p&gt;
&lt;h3 id=&quot;toc_2&quot;&gt;&lt;strong&gt;传统算法的解决方式：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;都要金字塔多尺度+遍历滑窗的方式，逐尺度逐位置判断&quot;这个尺度的这个位置处有没有认识的目标&quot;，非常笨重耗时，并不能很好的推广适用。&lt;/p&gt;
&lt;h3 id=&quot;toc_3&quot;&gt;&lt;strong&gt;现状：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;近期顶尖(SOTA)的目标检测方法几乎都用了anchor技术&lt;/p&gt;
&lt;h3 id=&quot;toc_4&quot;&gt;&lt;strong&gt;作用：&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;首先预设一组不同尺度不同位置的固定参考框，覆盖几乎所有位置和尺度，&lt;strong&gt;每个参考框负责检测与其交并比大于阈值 (训练预设值，常用0.5或0.7) 的目标&lt;/strong&gt;，anchor技术将问题转换为&lt;strong&gt;&quot;这个固定参考框中有没有认识的目标，目标框偏离参考框多远&quot;&lt;/strong&gt;，不再需要多尺度遍历滑窗，真正实现了又好又快，如在Faster R-CNN和SSD两大主流目标检测框架及扩展算法中anchor都是重要部分。&lt;/p&gt;
&lt;h2 id=&quot;toc_5&quot;&gt;举例：&lt;/h2&gt;
&lt;p&gt;1.预设anchor&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/807393/201904/807393-20190425141646750-660111937.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;2.识别结果与预设anchor的IOU计算&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/807393/201904/807393-20190425141647324-1121290024.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;如按照上图所示，计算所有红色与绿色的IOU（交并比），根据阈值来过滤掉我们需要的后，可能如下图所示：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/807393/201904/807393-20190425141647413-1978610782.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;br/&gt;蓝色部分为符合阈值剩余的部分。&lt;br/&gt;当然在实际中存在一些其他的问题来辅助最后的预算，比如非极大值抑制（NMS）来挑选一个置信度最高的相似目标。&lt;/p&gt;
&lt;h2 id=&quot;toc_6&quot;&gt;注意：&lt;/h2&gt;
&lt;p&gt;上图的示例仅仅是一个示例&lt;br/&gt;真实的anchor应该参考如下图的方式：&lt;br/&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/807393/201904/807393-20190425141647258-1896636471.jpg&quot; alt=&quot;&quot;/&gt;￼&lt;/p&gt;
&lt;p&gt;b图中，生成的anchor为：\(8*8*(预设anchor数量)\)&lt;br/&gt;c图中，生成的anchor为：\(4*4*(预设anchor数量)\)&lt;/p&gt;
&lt;p&gt;以上为我根据查找的资料观摩后的个人理解&lt;br/&gt;并没有去深究代码实现和论文&lt;br/&gt;仅供参考&lt;br/&gt;如果理解有误，希望您能不吝赐教。&lt;/p&gt;
&lt;h2 id=&quot;toc_7&quot;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/55824651&quot;&gt;https://zhuanlan.zhihu.com/p/55824651&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Thu, 25 Apr 2019 06:17:00 +0000</pubDate>
<dc:creator>zfCode</dc:creator>
<og:description>anchor在计算机视觉中有锚点或锚框，目标检测中常出现的anchor box是锚框，表示固定的参考框。目标检测的任务：在哪里有东西难点：目标的类别不确定、数量不确定、位置不确定、尺度不确定传统算法的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zfcode/p/mu-biao-jian-ce-anchor-li-jie-bi-ji.html</dc:identifier>
</item>
</channel>
</rss>