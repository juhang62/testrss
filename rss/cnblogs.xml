<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>vue的.vue文件是怎么run起来的(vue-loader) - 薛小白</title>
<link>http://www.cnblogs.com/yangyangxxb/p/10094180.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yangyangxxb/p/10094180.html</guid>
<description>&lt;h2&gt;vue的.vue文件是怎么run起来的(vue-loader)&lt;/h2&gt;
&lt;p&gt;引子：vue的.vue文件是怎么跑起来的？&lt;/p&gt;
&lt;p&gt;　　　答：通过vue-loader，解析.vue文件，在webpack解析，拆解vue组件&lt;/p&gt;

&lt;p&gt;1、vue-loader做了什么？&lt;/p&gt;
&lt;p&gt;vue-loader是一个webpack加载器，这是vue组件的格式：&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&amp;lt;template&amp;gt;&lt;span&gt;
    ...
&lt;/span&gt;&amp;lt;/template&amp;gt;
&amp;lt;script&amp;gt;&lt;span&gt;
    ...
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;style&amp;gt;&lt;span&gt;
    ...
&lt;/span&gt;&amp;lt;/style&amp;gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;它可以把这样的vue组件转化为JS模块，这其中最值得关注的是，它生成了 &lt;span&gt;render function code&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;render function&lt;/span&gt;&lt;span&gt;&lt;span&gt; code&lt;/span&gt; 
是从模板编译而来（可以并且应该预编译）的组件核心渲染方法，
在每一次组件的 Render 过程中，
通过注入的数据执行可生成虚拟 Dom&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;hr/&gt;

&lt;p&gt;2、vue核心执行过程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1459163/201812/1459163-20181209230145607-875801588.png&quot; alt=&quot;&quot; width=&quot;300&quot; height=&quot;656&quot;/&gt;&lt;/p&gt;


&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;vue核心的执行过程主要分为这几个阶段：&lt;br/&gt;&lt;/span&gt;1&lt;span&gt;） 编译模板，
生成可复用的render &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; code，
这一步在vue实例的整个生命周期中只会执行一次甚至零次，
因为我们可以在打包的时候可以预编译&lt;br/&gt;&lt;/span&gt;2&lt;span&gt;） 生成watcher等核心渲染监听，
在整个vue实例的生命过程中持续发生着作用，
对view和modal进行双向绑定&lt;br/&gt;&lt;/span&gt;3&lt;span&gt;） 虚拟dom的diff比较，
当watcher监听到data的变更的时候，
就会根据注入新的data执行render &lt;/span&gt;&lt;span&gt;function&lt;/span&gt;&lt;span&gt; code，
生成新的虚拟dom，
跟老的虚拟dom（第一次执行的时候可能为空）进行diff比对，
不同的部分将写入真实的dom&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

</description>
<pubDate>Sun, 09 Dec 2018 15:49:00 +0000</pubDate>
<dc:creator>薛小白</dc:creator>
<og:description>vue的.vue文件是怎么run起来的(vue-loader) 引子：vue的.vue文件是怎么跑起来的？ 答：通过vue-loader，解析.vue文件，在webpack解析，拆解vue组件 1、v</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yangyangxxb/p/10094180.html</dc:identifier>
</item>
<item>
<title>eclipse使用struts2找不到action方法或找不到action的错误记录 - js957</title>
<link>http://www.cnblogs.com/js957/p/10094176.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/js957/p/10094176.html</guid>
<description>&lt;p&gt;  在确认web.xml已经配置，&lt;/p&gt;
&lt;p&gt;　　配置好struts.xml ，&lt;/p&gt;
&lt;p&gt;　　代码没有报错，&lt;/p&gt;
&lt;p&gt;　　jar包没有问题，&lt;/p&gt;
&lt;p&gt;　　服务器也没有问题，&lt;/p&gt;
&lt;p&gt;　　代码逻辑没有问题，&lt;/p&gt;
&lt;p&gt;　　关键字方法名action都没有写错，&lt;/p&gt;
&lt;p&gt;　　可以运行旧的相同的代码但是新加的代码却出现找不到方法或者找不到action类等问题的，&lt;/p&gt;
&lt;p&gt;　　新建的项目也不可以用的，&lt;/p&gt;
&lt;p&gt;　　可以想想什么时候动过eclipse配置，&lt;strong&gt;因为很有可能就是因为配置文件导致的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;试试将配置还原，或者删除eclipse工作空间下的.metadata目录。&lt;/p&gt;
&lt;p&gt;还原方法参考CSDN 作者：Anonymous-邦，(原文：https://blog.csdn.net/u012198382/article/details/38589715 ):&lt;/p&gt;
&lt;p&gt;1.Window -&amp;gt; Reset Perspective（有时候不一定行）&lt;/p&gt;
&lt;p&gt;2.File -&amp;gt; Switch workspace -&amp;gt;Other（然后删除原来的工作空间目录，再重启eclipse）&lt;/p&gt;
&lt;p&gt;3.删除eclipse工作空间下的.metadata目录,重启eclipse(这个文件记录着你所有关于eclipse的配置)(推荐★★★)&lt;/p&gt;
&lt;p&gt;4.Window-&amp;gt;Close Perspective&lt;/p&gt;
&lt;p&gt;5.File-&amp;gt;Restart&lt;/p&gt;


</description>
<pubDate>Sun, 09 Dec 2018 15:48:00 +0000</pubDate>
<dc:creator>js957</dc:creator>
<og:description>在确认web.xml已经配置， 配置好struts.xml ， 代码没有报错， jar包没有问题， 服务器也没有问题， 代码逻辑没有问题， 关键字方法名action都没有写错， 可以运行旧的相同的代码</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/js957/p/10094176.html</dc:identifier>
</item>
<item>
<title>消息队列中间件（一）介绍 - 雪漫士兵</title>
<link>http://www.cnblogs.com/niumoo/p/10094082.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/niumoo/p/10094082.html</guid>
<description>&lt;h2 id=&quot;消息队列介绍&quot;&gt;消息队列介绍&lt;/h2&gt;
&lt;p&gt;消息队列中间件是大型系统中的重要组件，已经逐渐成为企业系统内部通信的核心手段。它具有松耦合、异步消息、流量削峰、可靠投递、广播、流量控制、最终一致性等一系列功能，已经成为异步RPC的主要手段之一。&lt;br/&gt;目前常见的消息中间件有ActiveMQ、RabbitMQ、ZeroMQ、Kafka、MetaMQ、RocketMQ等。&lt;br/&gt;&lt;/p&gt;
&lt;h2 id=&quot;消息队列应用场景&quot;&gt;消息队列应用场景&lt;/h2&gt;
&lt;p&gt;消息队列在实际中常见的应用场景有应用解耦、异步处理、流量错峰与流控、日志处理等等。&lt;/p&gt;
&lt;h3 id=&quot;应用解耦&quot;&gt;应用解耦&lt;/h3&gt;
&lt;p&gt;消息中间件顾名思义是用于消息存放的中间件。拿支付订单流程举例，在没有中间件的情况下，流程大致如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;用户支付订单，更新订单状态&lt;/li&gt;
&lt;li&gt;调用库存服务，完成响应功能&lt;/li&gt;
&lt;li&gt;调用积分服务，完成响应功能&lt;/li&gt;
&lt;li&gt;调用短信服务，发送短信通知&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个过程是顺序执行的，如果库存和积分或者短信服务没有及时响应，或者短信服务处理堵塞，客户端用户收到响应的时间将会延长，体验变差。&lt;br/&gt;其实我们知道对于订单流程，只有订单处理才是核心服务，其他依赖系统不是那么重要，可以通知到即可。所以可以使用消息中间件，我们在处理完毕订单之后放入中间件立刻返回，然后后续服务从中间件中拿到数据进行后续的处理。&lt;/p&gt;
&lt;h3 id=&quot;异步处理&quot;&gt;异步处理&lt;/h3&gt;
&lt;p&gt;异步处理是使用消息中间件的一个重要功能，拿用户注册来说，如果没有消息中间件，流程大致如下：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;提交注册信息，保存注册信息①&lt;/li&gt;
&lt;li&gt;发送注册通知邮件②&lt;/li&gt;
&lt;li&gt;发送短信验证码③&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这个过程是顺序的，很明显在发送邮件或短信时候有可能因为网络等原因发送有一定延迟，这时候响应时间变长。时间为①+②+③。&lt;br/&gt;在不使用中间件的情况下我们可以稍微改进，可以在注册信息记录完毕之后同时调用发送通知邮件和发送短信验证码的程序。时间为①+（max(②，③)）。虽然改进，但是因为使用了并行处理，由于CPU的并行处理能力有限，瓶颈很快就会到来。&lt;br/&gt;可以继续改进，注册信息记录完毕之后写入中间件，立即返回。短信服务和邮件服务从中间件中取出信息发送通知，时间为①+写入中间件时间。&lt;/p&gt;
&lt;h3 id=&quot;流量错峰&quot;&gt;流量错峰&lt;/h3&gt;
&lt;p&gt;在类似于秒杀这样的场景中会在某个时间流量突增，大量的请求同时到达服务端，无疑对后端的压力会大大增加，如果都等着处理完成可能会堵死后续的请求。这时候可以使用消息中间件把需要处理的信息先存储在中间件，也可以控制活动的参与人数。在后续服务程序有能力时再拿出信息进行处理，就可以削平流量峰值。保证处理程序的正常运行。&lt;/p&gt;
&lt;h3 id=&quot;日志处理&quot;&gt;日志处理&lt;/h3&gt;
&lt;p&gt;在生产环境中，为了监控日志，会有大量的日志需要传输存储检索，现在比较有名的日志处理架构有ELK，在分布式应用中由于日志的数量级越来越大，存储起来对速度的要求也越快越快。这时候需要使用中间件解决大量日志传输的问题，比如Kafka。&lt;br/&gt;下图是一个常见的日志处理架构：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5408072-740536a1cb700d27.jpg?imageMogr2/auto-orient/&quot;/&gt;&lt;/p&gt;
&lt;ol readability=&quot;2&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Kafka：接收用户日志的消息队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;Logstash：做日志解析，统一成JSON输出给Elasticsearch。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Elasticsearch：实时日志分析服务的核心技术，一个schemaless，实时的数据存储服务，通过index组织数据，兼具强大的搜索和统计功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;Kibana：基于Elasticsearch的数据可视化组件，超强的数据可视化能力是众多公司选择ELK stack的重要原因。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;h2 id=&quot;jms消息服务&quot;&gt;JMS消息服务&lt;/h2&gt;
&lt;p&gt;JMS是Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。ActiveMQ就是JMS接口的实现。&lt;/p&gt;
&lt;h3 id=&quot;jms消息模式&quot;&gt;JMS消息模式&lt;/h3&gt;
&lt;p&gt;大部分的消息队列都有两种通信模式。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;点对点（Point-to-Point Messaging Domain）&lt;/li&gt;
&lt;li&gt;发布-订阅（Publish/Subscribe Messaging Domain）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;JMS也不例外的定义了这两种消息发送模型的规范，但是并没有给予实现,实现JMS接口的消息中间件(MOM)称为JMS Provider。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;点对点&lt;/strong&gt;&lt;br/&gt;消息到达消息系统，被保留在消息队列中，然后由一个或者多个消费者消费队列中的消息，一个消息只能被一个消费者消费，然后就会被移除。例如订单处理系统。&lt;br/&gt;&lt;strong&gt;发布-订阅&lt;/strong&gt;&lt;br/&gt;消息发送时指定主题（或者说通道），消息被保留在指定的主题中，消费者可以订阅多个主题，并使用主题中的所有的消息，例如现实中的电视与电视频道。所有客户端包括发布者和订阅者，主题中的消息可以被所有的订阅者消费，消费者只能消费订阅之后发送到主题中的消息。&lt;/p&gt;
&lt;h3 id=&quot;jms编码接口&quot;&gt;JMS编码接口&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;ConnectionFactory 用于创建连接到消费中间件的连接工厂&lt;/li&gt;
&lt;li&gt;Connection 代表了应用程序和消息服务器之间通信的线路&lt;/li&gt;
&lt;li&gt;Destination 指消息发布和接收的地点，包括队列和主题&lt;/li&gt;
&lt;li&gt;Session 表示一个单线程的上下文，用于发送和接收消息&lt;/li&gt;
&lt;li&gt;MessageConsumer 由会话创建，用于接收发送到目标的消息&lt;/li&gt;
&lt;li&gt;MessageProducer 由会话创建，用于发送消息到目标&lt;/li&gt;
&lt;li&gt;Message 是消费者在生产者之间传送的对象，消息头，一组消息属性，消息体&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&amp;lt;完&amp;gt;&lt;br/&gt;本文原发于个人博客：&lt;a href=&quot;https://www.codingme.net/&quot; class=&quot;uri&quot;&gt;https://www.codingme.net&lt;/a&gt; 转载请注明出处&lt;br/&gt;本文原文链接：&lt;a href=&quot;https://www.codingme.net/2018/11/io/mq-introduction/&quot; class=&quot;uri&quot;&gt;https://www.codingme.net/2018/11/io/mq-introduction/&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/2626549-e1b06fdf782b78e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 15:36:00 +0000</pubDate>
<dc:creator>雪漫士兵</dc:creator>
<og:description>消息队列介绍 消息队列中间件是大型系统中的重要组件，已经逐渐成为企业系统内部通信的核心手段。它具有松耦合、异步消息、流量削峰、可靠投递、广播、流量控制、最终一致性等一系列功能，已经成为异步RPC的主要</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/niumoo/p/10094082.html</dc:identifier>
</item>
<item>
<title>day81_淘淘商城项目_14_项目发布 + Linux下安装mysql + tomcat热部署 + 数据库分库分表 + Mycat学习_匠心笔记 - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10094085.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10094085.html</guid>
<description>&lt;div id=&quot;output_wrapper_id&quot; readability=&quot;234.21409939135&quot;&gt;
&lt;p&gt;第十四天：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;1、Linux上mysql的安装&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;2、系统的部署&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;3、mycat的介绍&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;4、项目总结&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;5、面试中的问题&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;h1&quot;&gt;&lt;span&gt;&lt;strong&gt;1、开发流程浅解&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gKbA.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h2&quot;&gt;&lt;span&gt;&lt;strong&gt;2、项目发布前的准备&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1、测试&lt;/strong&gt;&lt;br/&gt;  a) 本地单元测试&lt;br/&gt;  b) 测试环境测试(1，2，3，4，5)&lt;br/&gt;  c) 用户测试(仿真环境：UAT环境)&lt;br/&gt;&lt;strong&gt;2、确认服务器的资源&lt;/strong&gt;&lt;br/&gt;  a) 硬件资源(CPU、内存、硬盘)&lt;br/&gt;  b) 软件资源(Linux、Windows)&lt;br/&gt;  c) 网络资源(宽带、机房、云服务器)&lt;br/&gt;&lt;strong&gt;3、相关参与的人员确认&lt;/strong&gt;&lt;br/&gt;  a) 测试人员&lt;br/&gt;  b) 开发人员&lt;br/&gt;&lt;strong&gt;4、数据库脚本的准备&lt;/strong&gt;&lt;br/&gt;  a) 初始化数据的sql脚本(DBA、运维)&lt;br/&gt;  b) 权限的sql脚本等&lt;br/&gt;&lt;strong&gt;5、编写发布的文档&lt;/strong&gt;&lt;br/&gt;  a) 开发人员编写各自负责的功能模块的&lt;code&gt;发布文档&lt;/code&gt;信息&lt;br/&gt;  b) 测试的文档(测试用例)&lt;br/&gt;  c) 全员参与&lt;br/&gt;&lt;strong&gt;6、打包&lt;/strong&gt;&lt;br/&gt;  a) 专门负责的人员进行打包处理(运维)&lt;br/&gt;&lt;strong&gt;7、准备&lt;code&gt;回滚方案&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;h3&quot;&gt;&lt;span&gt;&lt;strong&gt;3、项目部署&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h31linuxmysql&quot;&gt;&lt;span&gt;&lt;strong&gt;3.1、Linux下安装mysql&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;第一步：&lt;/strong&gt;查看mysql是否安装。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;rpm&lt;/span&gt; -qa | grep mysql&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步：&lt;/strong&gt;如果mysql的版本不是想要的版本。需要把原来的mysql卸载。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs cs&quot;&gt;yum &lt;span class=&quot;hljs-keyword&quot;&gt;remove&lt;/span&gt; mysql mysql-server mysql-libs mysql-common&lt;br/&gt;rm -rf /&lt;span class=&quot;hljs-keyword&quot;&gt;var&lt;/span&gt;/lib/mysql&lt;br/&gt;rm -f /etc/my.cnf&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  使用yum命令，因为yum命令可以自动删除与mysql相关的依赖；如果使用rpm命令，则还需要手动去删除和mysql相关的文件。&lt;br/&gt;&lt;strong&gt;第三步：&lt;/strong&gt;安装mysql。需要使用yum命令安装。在安装mysql之前需要安装mysql的下载源。需要从oracle的官方网站下载。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;1）下载&lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql&lt;/span&gt;的源包：&lt;br/&gt;我们是&lt;span class=&quot;hljs-selector-tag&quot;&gt;centos6&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.4&lt;/span&gt;对应的&lt;span class=&quot;hljs-selector-tag&quot;&gt;rpm&lt;/span&gt;包为：&lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql-community-release-el6-5&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.noarch&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.rpm&lt;/span&gt;&lt;br/&gt;2）安装&lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql&lt;/span&gt;下载源：&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;yum&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;localinstall&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql-community-release-el6-5&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.noarch&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.rpm&lt;/span&gt;&lt;br/&gt;3）在线安装社区版的&lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql&lt;/span&gt;：&lt;br/&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;yum&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;mysql-community-server&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  rpm包位置：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gUD9.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;第四步：&lt;/strong&gt;启动mysql。
&lt;pre&gt;
&lt;code class=&quot;hljs nginx&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;service&lt;/span&gt; mysqld start&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第五步：&lt;/strong&gt;需要给root用户设置密码。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;/usr/bin/mysqladmin -u root password &lt;span class=&quot;hljs-string&quot;&gt;'new-password'&lt;/span&gt;　　&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第六步：&lt;/strong&gt;登录mysql。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost temp]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第七步：&lt;/strong&gt;需要先登录到mysql，远程连接授权。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs sql&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;GRANT&lt;/span&gt; ALL &lt;span class=&quot;hljs-keyword&quot;&gt;PRIVILEGES&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;ON&lt;/span&gt; *.* &lt;span class=&quot;hljs-keyword&quot;&gt;TO&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'myuser'&lt;/span&gt;@&lt;span class=&quot;hljs-string&quot;&gt;'%'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;IDENTIFIED&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;BY&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;'mypassword'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;WITH&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;GRANT&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;OPTION&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　注意：&lt;/strong&gt;&lt;/span&gt;&lt;code&gt;'myuser'&lt;/code&gt;、&lt;code&gt;'mypassword'&lt;/code&gt; 需要替换成实际的用户名和密码。&lt;br/&gt;　　mysql安装好了之后，启动服务，建立连接，导入taotao数据库文件。&lt;br/&gt;　　Linux上安装mysq链接：xxxxxxxxxxxxxxxxxxx后续补上&lt;/p&gt;
&lt;h3 id=&quot;h32&quot;&gt;&lt;span&gt;&lt;strong&gt;3.2、项目架构讲解&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gLNu.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h33&quot;&gt;&lt;span&gt;&lt;strong&gt;3.3、系统功能介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gEZN.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h34&quot;&gt;&lt;span&gt;&lt;strong&gt;3.4、网络拓扑图&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50g1KO.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h35&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5、系统部署&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h351&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.1、部署分析&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;工程共13个，如下所示，本着高可用的原则，每个工程至少有两台服务器。13个工程至少需要26台服务器。&lt;br/&gt;  taotao-manager&lt;br/&gt;  taotao-manager-web&lt;br/&gt;  taotao-content&lt;br/&gt;  taotao-portal-web&lt;br/&gt;  taotao-search&lt;br/&gt;  taotao-search-web&lt;br/&gt;  taotao-item-web&lt;br/&gt;  taotao-sso&lt;br/&gt;  taotao-sso-web&lt;br/&gt;  taotao-order&lt;br/&gt;  taotao-order-web&lt;br/&gt;  taotao-cart&lt;br/&gt;  taotao-cart-web&lt;br/&gt;  即淘淘商城在真实环境中要部署的话需要&lt;strong&gt;26&lt;/strong&gt;台服务器。&lt;/p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;服务&lt;/th&gt;
&lt;th&gt;服务器个数&lt;/th&gt;
&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Mysql&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Solr&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Redis&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;图片服务器&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Nginx&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;注册中心&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Activemq&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;  总共需要26+24=&lt;strong&gt;50&lt;/strong&gt;台服务器。但我们都知道，一般的小公司是绝不可能弄这么多服务器的，太昂贵了，比较可行的是采用&lt;strong&gt;&lt;code&gt;伪分布式&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;h4 id=&quot;h352&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.2、服务器规划&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;如下图所示，搭建服务原来需要&lt;strong&gt;24&lt;/strong&gt;台服务器，现在只需要&lt;strong&gt;7&lt;/strong&gt;台即可。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50g6We.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;搭建工程规划使用&lt;strong&gt;5&lt;/strong&gt;台服务器便可，如下图所示：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gAnq.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  这样规划的话，我们只需要7+5=&lt;strong&gt;12&lt;/strong&gt;台服务器即可。当然了，&lt;strong&gt;12&lt;/strong&gt;台服务器在一般的公司来说，也是达不到的，那么我们便可以进一步&lt;span&gt;&lt;strong&gt;压缩&lt;/strong&gt;&lt;/span&gt;，&lt;strong&gt;把更多的服务合并到一台服务器上，把更多的工程合并到一台服务器上&lt;/strong&gt;。&lt;br/&gt;　　我们&lt;code&gt;将服务精简成一台服务器&lt;/code&gt;：&lt;code&gt;192.168.25.133&lt;/code&gt;&lt;br/&gt;内存至少给2G以上。&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gIrd.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h353&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.3、工程规划&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;工程规划表：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gNiR.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;tomcat端口更新映射表：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50glmr.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h354&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.4、域名规划&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;域名规划表：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50g8hY.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h355tomcat&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.5、tomcat热部署&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  可以使用maven实现tomcat热部署。即&lt;code&gt;tomcat启动时部署工程&lt;/code&gt;。&lt;br/&gt;  tomcat有个&lt;code&gt;后台管理功能&lt;/code&gt;，可以实现工程热部署。部署完成后，我们不需要启动tomcat了，tomcat会自动把war包解压到ROOT目录下。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;这里以taotao-content及taotao-portal-web为例子演示：&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;  在Linux下，我们新建有13个tomcat放置12工程：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50giDy.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  先启动服务：启动redis，启动zookeeper，启动activemq，启动solr，启动mysql。&lt;br/&gt;配置方法：&lt;br/&gt;  先部署服务层工程，再部署表现层工程。&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;code&gt;a) 部署taotao-content&lt;/code&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br/&gt;&lt;strong&gt;linux系统上的配置：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第一步：&lt;/strong&gt;需要修改linux系统中对应的tomcat9002的conf/tomcat-users.xml配置文件。添加用户名、密码、权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;rolename&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;manager-gui&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;rolename&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;manager-script&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;username&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tomcat&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;password&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tomcat&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;roles&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;manager-gui, manager-script&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  我们要将war包放在对应的tomcat9002中的webapps目录下的ROOT目录下，所以我们先在webapps目录下创建ROOT目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost webapps]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步：&lt;/strong&gt;重新启动对应的tomcat9002。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;[root@localhost ~]&lt;br/&gt;/usr/&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;/taotao-projects/tomcat9002/bin&lt;br/&gt;[root@localhost bin]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步：&lt;/strong&gt;查看tomcat9002的启动日志。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost tomcat9002]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;开发机器上（windows系统）的配置：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第一步&lt;/strong&gt;：修改配置文件。&lt;br/&gt;  修改taotao-content工程中的相应的配置文件&lt;code&gt;db.properties&lt;/code&gt;中数据库的ip地址、端口、实例名、用户名、密码。修改&lt;code&gt;applicationContenxt-redis.xml&lt;/code&gt;中的ip地址、端口。（即：将原来的localhost修改为mysql所在的服务器的IP地址。）修改taotao-content工程中的发布服务的配置文件&lt;code&gt;applicationContenxt-service.xml&lt;/code&gt;中注册中心的地址，改成linux系统中的zookeeper的地址&lt;code&gt;192.168.25.133&lt;/code&gt;以及暴露服务的端口。&lt;br/&gt;&lt;strong&gt;第二步&lt;/strong&gt;：配置tomcat插件，需要修改taotao-content工程的pom.xml文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.tomcat.maven&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;tomcat7-maven-plugin&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;port&lt;/span&gt;&amp;gt;&lt;/span&gt;8083&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;port&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;/&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;http://192.168.25.133:9002/manager/text&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;username&lt;/span&gt;&amp;gt;&lt;/span&gt;tomcat&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;username&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;password&lt;/span&gt;&amp;gt;&lt;/span&gt;tomcat&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;password&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  &lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;添加了三行配置，&lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;里面的tomcat热部署地址的端口号有所变化，现在是9002。大家可能会有疑问，&lt;code&gt;&amp;lt;url&amp;gt;&lt;/code&gt;配置上面的那个&lt;code&gt;&amp;lt;port&amp;gt;8083&amp;lt;/port&amp;gt;&lt;/code&gt;有什么用？会不会对部署产生坏的影响。这个其实不用担心，这个&lt;code&gt;port&lt;/code&gt;对热部署来说，没有用，这里之所以没有把它删掉是因为我们在&lt;code&gt;Windows系统下开发&lt;/code&gt;的时候给这个工程规划的端口是&lt;code&gt;8083&lt;/code&gt;，如果需要&lt;code&gt;在Windows系统下启动该工程的&lt;/code&gt;话，这个port就是有用的，因此这个&lt;code&gt;&amp;lt;port&amp;gt;8083&amp;lt;/port&amp;gt;&lt;/code&gt;配置我们不必理会，搁那儿就行。&lt;br/&gt;&lt;strong&gt;第三步&lt;/strong&gt;：使用maven命令进行部署。&lt;br/&gt;  选中taotao-content工程，右键 --&amp;gt; Run As --&amp;gt; Maven build…&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;tomcat7:deploy      &lt;br/&gt;tomcat7:redeploy    &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  部署的路径是&lt;code&gt;“/”&lt;/code&gt;会把系统部署到&lt;code&gt;webapps/ROOT目录下&lt;/code&gt;。&lt;br/&gt;  部署工程&lt;code&gt;跳过测试&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;clean&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;tomcat7&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:redeploy&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;-DskipTests&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第四步&lt;/strong&gt;：在Linux下查看toamcat9002的日志&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost tomcat9002]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;日志输出内容如下图所示：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gxpX.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;每次&lt;code&gt;部署完服务后&lt;/code&gt;，都会停在如上图所示的位置上，需要我们&lt;code&gt;重新启动tomcat9002&lt;/code&gt;。暂时不知道为什么。&lt;br/&gt;&lt;strong&gt;第五步&lt;/strong&gt;：重新启动tomcat9002。&lt;br/&gt;&lt;strong&gt;第六步&lt;/strong&gt;：查看dubbo监控中心。&lt;br/&gt;  部署完服务层工程taotao-content后，我们到&lt;code&gt;dubbo服务治理&lt;/code&gt;--&amp;gt;&lt;code&gt;服务页面&lt;/code&gt;，发现多了两个服务，分别是com.taotao.content.service.ContentCategoryService和com.taotao.content.service.ContentService。说明我们的taotao-content工程部署成功。&lt;br/&gt;&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;b) 部署taotao-portal-web&lt;/code&gt;&lt;/strong&gt;&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;首先要确保新的服务器&lt;code&gt;192.168.25.133&lt;/code&gt;上安装的jdk是否与Eclipse开发时所用的jdk版本一致，我Eclipse开发时用的jdk1.7，因此服务器上的安装的jdk版本也要是1.7才行。不然会出现问题！！！&lt;strong&gt;（是个坑）&lt;/strong&gt;&lt;br/&gt;  Linux上安装jdk过程链接：&lt;a href=&quot;https://www.cnblogs.com/chenmingjun/p/9931593.html&quot; target=&quot;_blank&quot;&gt;https://www.cnblogs.com/chenmingjun/p/9931593.html&lt;/a&gt;&lt;br/&gt;&lt;strong&gt;linux系统上的配置：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第一步&lt;/strong&gt;：需要修改linux系统中对应的tomcat9003的conf/tomcat-users.xml配置文件。添加用户名、密码、权限。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;rolename&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;manager-gui&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;role&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;rolename&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;manager-script&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;user&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;username&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tomcat&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;password&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;tomcat&quot;&lt;/span&gt; &lt;span class=&quot;hljs-attr&quot;&gt;roles&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;&quot;manager-gui, manager-script&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  我们要将war包放在对应的tomcat9003中的webapps目录下的ROOT目录下，所以我们先在webapps目录下创建ROOT目录：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost webapps]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;：重新启动对应的tomcat9003。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;[root@localhost ~]&lt;br/&gt;/usr/&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;/taotao-projects/tomcat9003/bin&lt;br/&gt;[root@localhost bin]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;：查看tomcat9003的启动日志。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost tomcat9003]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;开发机器上（windows系统）的配置：&lt;/strong&gt;&lt;br/&gt;&lt;strong&gt;第一步&lt;/strong&gt;：修改配置文件。&lt;br/&gt;  修改taotao-portal-web工程中的引用服务的配置文件springmvc.xml中注册中心的地址，改成linux系统中的zookeeper的ip地址&lt;code&gt;192.168.25.133&lt;/code&gt;。&lt;br/&gt;&lt;strong&gt;第二步&lt;/strong&gt;：配置tomcat插件，需要修改taotao-portal-web工程的pom.xml文件。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.tomcat.maven&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;tomcat7-maven-plugin&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;port&lt;/span&gt;&amp;gt;&lt;/span&gt;8082&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;port&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;/&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;path&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;http://192.168.25.133:9003/manager/text&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;url&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;username&lt;/span&gt;&amp;gt;&lt;/span&gt;tomcat&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;username&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;password&lt;/span&gt;&amp;gt;&lt;/span&gt;tomcat&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;password&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;configuration&lt;/span&gt;&amp;gt;&lt;/span&gt;        &lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;plugin&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;plugins&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;build&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第三步&lt;/strong&gt;：使用maven命令进行部署。&lt;br/&gt;  选中taotao-portal-web工程，右键 --&amp;gt; Run As --&amp;gt; Maven build…&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs bash&quot;&gt;tomcat7:deploy      &lt;br/&gt;tomcat7:redeploy    &lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;  部署的路径是&lt;code&gt;“/”&lt;/code&gt;会把系统部署到webapps/ROOT目录下。&lt;br/&gt;  部署工程&lt;code&gt;跳过测试&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;&lt;span class=&quot;hljs-selector-tag&quot;&gt;clean&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;tomcat7&lt;/span&gt;&lt;span class=&quot;hljs-selector-pseudo&quot;&gt;:redeploy&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;-DskipTests&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第四步&lt;/strong&gt;：在Linux下查看toamcat9003的日志&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost tomcat9003]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;第五步&lt;/strong&gt;：重新启动tomcat9003。&lt;br/&gt;&lt;strong&gt;第六步&lt;/strong&gt;：查看dubbo监控中心。&lt;br/&gt;  部署完服务层工程taotao-portal-web后，我们到&lt;code&gt;dubbo服务治理&lt;/code&gt; --&amp;gt; &lt;code&gt;应用页面&lt;/code&gt;，发现多了两个应用，分别是taotao-content和taotao-portal-web。说明我们的taotao-portal-web工程部署成功。&lt;/p&gt;
&lt;h4 id=&quot;h356&quot;&gt;&lt;span&gt;&lt;strong&gt;3.5.6、其他工程部署&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  同上 &lt;strong&gt;&lt;code&gt;a) 部署taotao-content&lt;/code&gt;&lt;/strong&gt; 和 &lt;strong&gt;&lt;code&gt;b) 部署taotao-portal-web&lt;/code&gt;&lt;/strong&gt; 步骤。&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;注意1：&lt;/strong&gt;&lt;/span&gt;在工程部署之前需要启动所有的服务：zookeeper、solr、redis、mysql、activemq&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;注意2：&lt;/strong&gt;&lt;/span&gt;每个工程运行在不同的tomcat上，需要修改tomcat的端口号。&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;注意3：&lt;/strong&gt;&lt;/span&gt;先部署服务层工程，再部署表现层工程。&lt;br/&gt;  &lt;span&gt;&lt;strong&gt;注意4：&lt;/strong&gt;&lt;/span&gt;当部署使用到activemq的工程时，需要将原来的pom.xml文件的activemq的依赖配置项修改为新的，如下：&lt;br/&gt;原来的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.activemq&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;activemq-all&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新的：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs xml&quot;&gt;    &lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;org.apache.activemq&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;groupId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;activemq-core&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;artifactId&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-tag&quot;&gt;&amp;lt;/&lt;span class=&quot;hljs-name&quot;&gt;dependency&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果不修改成新的在部署的时候会报错，但是在开发使用原来的没有问题。（&lt;code&gt;这是一个坑&lt;/code&gt;）&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;部署大致步骤如下：&lt;br/&gt;&lt;strong&gt;第一步：&lt;/strong&gt;修改工程中的服务器的地址都改为192.168.25.133（在所有的jsp和xml中）&lt;br/&gt;&lt;strong&gt;第二步：&lt;/strong&gt;修改所有localhost对应正确的域名&lt;br/&gt;  例如：http://localhost:8088 --&amp;gt; http://sso.taotao.com&lt;br/&gt;&lt;strong&gt;第三步：&lt;/strong&gt;修改所有db.properties中的&lt;code&gt;localhost:3306/taotao&lt;/code&gt;为&lt;code&gt;192.168.25.133:3306/taotao&lt;/code&gt;，以及用户名和密码。&lt;br/&gt;&lt;strong&gt;第四步：&lt;/strong&gt;如果在数据库中没有创建taotao，需要创建一个，再导入数据。&lt;br/&gt;&lt;strong&gt;第五步：&lt;/strong&gt;反向代理配置如下&lt;code&gt;3.6、反向代理的配置&lt;/code&gt;所示：&lt;br/&gt;&lt;strong&gt;第六步：&lt;/strong&gt;测试，需要先将本地hosts切换为如下图所示配置：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gSNi.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h36&quot;&gt;&lt;span&gt;&lt;strong&gt;3.6、反向代理的配置&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;linux系统上的配置：&lt;/strong&gt;&lt;br/&gt;Linux系统上nginx配置反向代理，反向代理配置的是&lt;code&gt;表现层工程对应的端口&lt;/code&gt;，注意：配置upstream时不要有空格。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;[root@localhost conf]&lt;br/&gt;/usr/&lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;/nginx/conf&lt;br/&gt;[root@localhost conf]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;nginx.conf&lt;/p&gt;
&lt;pre readability=&quot;18.5&quot;&gt;
&lt;code class=&quot;hljs nginx&quot; readability=&quot;31&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;worker_processes&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;;&lt;p&gt;&lt;span class=&quot;hljs-section&quot;&gt;events&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;worker_connections&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;1024&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-section&quot;&gt;http&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;include&lt;/span&gt;       mime.types;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;default_type&lt;/span&gt;  application/octet-stream;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;sendfile&lt;/span&gt;        &lt;span class=&quot;hljs-literal&quot;&gt;on&lt;/span&gt;;&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;keepalive_timeout&lt;/span&gt;  &lt;span class=&quot;hljs-number&quot;&gt;65&lt;/span&gt;;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; manager.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9001&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; www.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9003&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; search.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9005&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; item.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9006&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; sso.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9008&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; order.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9010&lt;/span&gt;;&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;upstream&lt;/span&gt; cart.taotao.com {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;192.168.25.133:9012&lt;/span&gt;;&lt;br/&gt;}&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  manager.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://manager.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  www.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://www.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  search.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://search.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  item.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://item.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  sso.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://sso.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  order.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://order.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;span class=&quot;hljs-section&quot;&gt;server&lt;/span&gt; {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;listen&lt;/span&gt;       &lt;span class=&quot;hljs-number&quot;&gt;80&lt;/span&gt;;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;server_name&lt;/span&gt;  cart.taotao.com;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;location&lt;/span&gt; / {&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;proxy_pass&lt;/span&gt;   http://cart.taotao.com;&lt;br/&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;index&lt;/span&gt;  index.html index.htm;&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;}&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;　　注意：&lt;/strong&gt;&lt;/span&gt;修改好之后，需要&lt;code&gt;重新加载(reload)nginx的配置文件&lt;/code&gt;。&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;&lt;strong&gt;开发机器上（windows系统）的配置：&lt;/strong&gt;&lt;br/&gt;测试时使用域名访问网站，需要修改&lt;code&gt;本地电脑(windows)hosts&lt;/code&gt;文件。&lt;br/&gt;所有的域名应该指向&lt;code&gt;反向代理服务器nginx&lt;/code&gt;。&lt;br/&gt;配置hosts文件，内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs css&quot;&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;manager&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;www&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;search&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;sso&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;cart&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;192&lt;span class=&quot;hljs-selector-class&quot;&gt;.168&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.25&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.133&lt;/span&gt; &lt;span class=&quot;hljs-selector-tag&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.taotao&lt;/span&gt;&lt;span class=&quot;hljs-selector-class&quot;&gt;.com&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们可以使用一个软件来配置本地电脑(windows)hosts文件，以管理员身份运行SwitchHosts软件：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50g2Kl.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;以上都配置好后，我们就可以进行测试访问。
&lt;h3 id=&quot;h37&quot;&gt;&lt;span&gt;&lt;strong&gt;3.7、数据库的读写分离与分库分表&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  &lt;strong&gt;项目中：&lt;/strong&gt;执行查询的命令要比修改、删除、这些命令要多的多。所以为了保证数据库的&lt;code&gt;读写性能&lt;/code&gt;和数据库的&lt;code&gt;完整性&lt;/code&gt;。需要做&lt;code&gt;读写分离&lt;/code&gt;。&lt;br/&gt;&lt;strong&gt;什么是读写分离？&lt;/strong&gt;&lt;br/&gt;  通俗的讲就是读取的命令在一个数据库中，而写入的命令在另外一个库中。两个库中的数据必须&lt;code&gt;同步&lt;/code&gt;。&lt;br/&gt;Mysql提供的解决方案：&lt;code&gt;使用binlog进行数据库同步&lt;/code&gt;。需要配置mysql。&lt;br/&gt;&lt;strong&gt;代码中实现读写分类：&lt;/strong&gt;&lt;br/&gt;  1、可以使用aop实现一个切面。动态切换数据源。需要编程实现。&lt;br/&gt;  2、使用数据库中间件实现读写分离，&lt;code&gt;分库分表&lt;/code&gt;。（学习这个）&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50ggdB.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;&lt;strong&gt;什么是分库分表？&lt;/strong&gt;&lt;br/&gt;  当数据库的表中数据非常大的时候例如上千万条数据。查询性能非常低。可以把一张表数据保存到不同的数据库中的不同表中。根据经验&lt;code&gt;mysql 2000万以上&lt;/code&gt;和 &lt;code&gt;oracle11G 1亿以上&lt;/code&gt;时需要分库分表。&lt;br/&gt;  可以使用一个&lt;code&gt;数据库中间件Mycat&lt;/code&gt;。国产开源项目，前身是&lt;code&gt;cobar项目&lt;/code&gt;。&lt;/div&gt;&lt;div readability=&quot;68.085756169069&quot;&gt;
&lt;h2 id=&quot;h4mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;4、Mycat的学习&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h41mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;4.1、Mycat的介绍&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50g7oJ.png&quot; alt=&quot;&quot;/&gt;&lt;h3 id=&quot;h42mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;4.2、什么是Mycat&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;简单的说，Mycat就是：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;一个彻底开源的，面向企业应用开发的“大数据库集群”&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持事务、ACID(4种特新)、可以替代Mysql的加强版数据库&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个可以视为“Mysql”集群的企业级数据库，用来替代昂贵的Oracle集群&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个融合内存缓存技术、Nosql技术、HDFS大数据的新型SQL Server&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;结合传统数据库和新型分布式数据仓库的新一代企业级数据库产品&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;一个新颖的数据库中间件产品&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;span&gt;&lt;strong&gt;Mycat的目标是：&lt;/strong&gt;&lt;/span&gt;低成本的将现有的单机数据库和应用&lt;code&gt;平滑迁移&lt;/code&gt;到“云”端，解决数据存储和业务规模迅速增长情况下的&lt;code&gt;数据瓶颈&lt;/code&gt;问题。&lt;/p&gt;
&lt;h3 id=&quot;h43mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;4.3、Mycat的关键特性&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;支持 SQL 92标准&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持Mysql集群，可以作为Proxy使用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持JDBC连接ORACLE、DB2、SQL Server，将其模拟为MySQL Server使用&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持galera for mysql集群，percona-cluster 或者 mariadb cluster，提供高可用性数据分片集群&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;自动故障切换，高可用性&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持读写分离，支持Mysql双主多从，以及一主多从的模式&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持全局表，数据自动分片到多个节点，用于高效表关联查询&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;支持独有的基于E-R 关系的分片策略，实现了高效的表关联查询&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;多平台支持，部署和实施简单&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;h44mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;4.4、Mycat对多数据库的支持&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gnr6.png&quot; alt=&quot;&quot;/&gt;&lt;h2 id=&quot;h5mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;5、Mycat的下载及安装&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h51mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;5.1、下载Mycat&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;官方网站：&lt;br/&gt;  &lt;a href=&quot;http://www.mycat.org.cn/&quot; target=&quot;_blank&quot;&gt;http://www.mycat.org.cn/&lt;/a&gt;&lt;br/&gt;github地址：&lt;br/&gt;  &lt;a href=&quot;https://github.com/MyCATApache&quot; target=&quot;_blank&quot;&gt;https://github.com/MyCATApache&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;h52&quot;&gt;&lt;span&gt;&lt;strong&gt;5.2、环境准备&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;数据库准备，准备三个MySQL数据库实例。&lt;br/&gt;在Linux上安装一个MySQL数据库进行模拟，再设置三个数据库，作为集群中的库进行使用。&lt;br/&gt;&lt;strong&gt;分片规则：&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50gwz3.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;实现这个效果：需要在mycat中做一个配置。
&lt;h3 id=&quot;h53mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3、Mycat安装&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h531mycatlinux&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3.1、第一步：上传mycat的文件到linux中&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50goxp.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h532usrlocal&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3.2、第二步：移动并解压缩到/usr/local目录下&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;[root@localhost ~]&lt;br/&gt;[root@localhost ~]&lt;br/&gt;[root@localhost &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h533mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;5.3.3、第三步：配置Mycat实现分片&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;创建3个数据库实例&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50n3hK.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;查看mycat的conf目录：
&lt;pre&gt;
&lt;code class=&quot;hljs perl&quot;&gt;[root@localhost &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt;]&lt;br/&gt;[root@localhost conf]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件内容详解如下图：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50n5kG.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;配置server.xml，配置的是逻辑库的名称和连接该库的用户名和密码
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost conf]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置内容如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nDDn.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;配置逻辑库的时候注意：&lt;br/&gt;  注意：若是LINUX版本的MYSQL，则需要&lt;code&gt;设置为MySQL对大小写不敏感&lt;/code&gt;，否则可能会发生表找不到的问题。&lt;br/&gt;在MySQL的配置文件中/etc/my.cnf 中增加一行代码：
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;span class=&quot;hljs-attr&quot;&gt;lower_case_table_names&lt;/span&gt; = &lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置schema.xml，配置的是物理数据库的节点信息，包括：ip地址、端口、数据库名称、分片规则&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost conf]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置内容如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nF1Q.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;配置rule.xml，配置的是具体的分片规则
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost conf]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;配置内容如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nBpE.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;查找分片算法&lt;br/&gt;配置的分片规则算法，可以参考以下源码：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nHo2.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;源码位置：Mycat-server-1.4-RELEASE-sources.jar\org\opencloudb\route\function&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nmCz.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;配置分片算法&lt;br/&gt;根据分配片的java代码，继续在&lt;code&gt;rule.xml&lt;/code&gt;配置分片算法&lt;br/&gt;按下图方式配置分片规则算法：&lt;br/&gt;&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nXda.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;添加并编辑auto-id.txt文件，可以参考autopartition-long.txt文件
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost conf]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;文件内容如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ini&quot;&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;0-127&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;0&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;128-255&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-attr&quot;&gt;256-511&lt;/span&gt;=&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h54mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4、Mycat测试&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h541mysql&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.1、第一步：连接mysql数据库&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nzxS.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h5423&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.2、第二步：创建3个数据库实例&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;创建3个数据库实例，要求和mycat配置的schema.xml中的3个实例名称一致。&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nYzh.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h543mycat&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.3.第三步：启动mycat&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;启动命令：./mycat start&lt;br/&gt;停止命令：./mycat stop&lt;br/&gt;重启命令：./mycat restart&lt;br/&gt;具体操作：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost ~]&lt;br/&gt;[root@localhost bin]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内容如下：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50nQkN.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;查看启动日志
&lt;pre&gt;
&lt;code class=&quot;hljs coffeescript&quot;&gt;[root@localhost logs]&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h544mycatserver&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.4、第四步：连接mycat server&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/span&gt;可以使用mysql的客户端直接连接&lt;strong&gt;mycat服务&lt;/strong&gt;。默认服务端口为&lt;strong&gt;8066&lt;/strong&gt;&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s1.ax2x.com/2018/12/09/50n0vH.png&quot; alt=&quot;&quot;/&gt;&lt;h4 id=&quot;h545&quot;&gt;&lt;span&gt;&lt;strong&gt;5.4.5、测试&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  在mycat中创建数据库表，发现使用的三个库都创建了表。&lt;br/&gt;  在mycat中插入数据，发现按照规则给三个数据库分别插入了数据。&lt;/p&gt;
&lt;h2 id=&quot;h6&quot;&gt;&lt;span&gt;&lt;strong&gt;6、参考文章&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;  &lt;a href=&quot;https://blog.csdn.net/u012453843/article/details/73694543&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u012453843/article/details/73694543&lt;/a&gt;&lt;br/&gt;  &lt;a href=&quot;https://blog.csdn.net/u012453843/article/details/73656590&quot; target=&quot;_blank&quot;&gt;https://blog.csdn.net/u012453843/article/details/73656590&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Sun, 09 Dec 2018 15:27:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>第十四天： 1、Linux上mysql的安装 2、系统的部署 3、mycat的介绍 4、项目总结 5、面试中的问题 1、开发流程浅解 2、项目发布前的准备 1、测试 a) 本地单元测试 b) 测试环境</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10094085.html</dc:identifier>
</item>
<item>
<title>如何發佈一個完整Node.js Module - KingJaja</title>
<link>http://www.cnblogs.com/KingJaja/p/9697427.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/KingJaja/p/9697427.html</guid>
<description>
&lt;p&gt;本文會透過以下幾個段落，讓各位一步一步學習如何寫一個自已的Node.js Module並且發佈到npm package上&lt;/p&gt;
&lt;p&gt;Node.js Module 結構&lt;/p&gt;
&lt;p&gt;我們先建立一個 NodeModuleDemo 的資料夾 ，接下來利用 npm init 進行初始化&lt;/p&gt;
&lt;p&gt;(這裡不用特別設置，一路按 Enter 到底即可)&lt;/p&gt;
&lt;p&gt;Tips. 這裡可以簡單的利用VSCode 熱鍵 Ctrl + ` 開啟命令視窗&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181004235156464-940328204.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181004235157177-1746013498.png&quot; alt=&quot;image&quot; width=&quot;452&quot; height=&quot;359&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;初始化完成的畫面如上&lt;/p&gt;
&lt;p&gt;接下來我們會先建立好相關的資料夾用來分類我們的程式碼&lt;/p&gt;
&lt;p&gt;其中 lib 資料夾是我們要寫的原始程式碼，test 資料夾則專門放我們的測試程式&lt;/p&gt;
&lt;p&gt;最後 benchmark 資料夾裡面是用來做我們效能測試的程式&lt;/p&gt;
&lt;p&gt;因我們這次會利用 ES6 的 Class 語法來寫我們的模組程式，所以這裡也需要加入 babel 的設定&lt;/p&gt;
&lt;p&gt;再來為了讓我們的程式碼可以有統一的風格，我們也會加入 eslint 的設定&lt;/p&gt;
&lt;p&gt;( babel 與 eslint 我通常會裝成全域的package ，各位可以自已選擇要安裝的目標)&lt;/p&gt;
&lt;p&gt;先來安裝 babel 與 eslint 吧！&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013171515589-1466141479.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013171516407-672991999.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;292&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;安裝完後，可以像上圖中，透過 –version 來確認安裝的狀況&lt;/p&gt;
&lt;p&gt;這裡可以看到我們的 babel 版本為 6.26.0 而 eslint 則為 5.7.0&lt;/p&gt;
&lt;p&gt;再來我們下一步先建立 babel 的設定檔，檔名為 .babelrc 放置在我們的根目錄下&lt;/p&gt;
&lt;p&gt;內容直接設為&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;{&lt;/p&gt;
&lt;p&gt;&quot;presets&quot;: [&quot;env&quot;]&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;eslint 的部分則更簡單了，只需要在命令視窗輸入 eslint –init 選擇想要的範本即可，在我們的練習中，我們選擇&lt;/p&gt;
&lt;p&gt;standard 。最後會自動在根目錄產出 .eslintrc.js 檔 ，相關的操作如下圖 (黃字標示處)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013172319155-703345657.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013172319869-1444113976.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;292&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後，因為我們希望 eslint 只檢查我們 lib 主程式目錄，所以這裡需要加入一個 .eslintignore 檔&lt;/p&gt;
&lt;p&gt;將我們的 test 、benchmark 及輸出的 dist 資料夾做排除的動作，話不多說請看下圖&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013172441394-307346674.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013172441825-1070354282.png&quot; alt=&quot;image&quot; width=&quot;563&quot; height=&quot;307&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;整個 Node.js Module 的目錄架構會像下圖這樣 ( formatter 、output 、index.js 可以先建立起來)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013172442248-2010277364.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181013172442740-71218685.png&quot; alt=&quot;image&quot; width=&quot;501&quot; height=&quot;499&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來我們就開始動手寫我們的模組程式吧！&lt;/p&gt;
&lt;p&gt;我們這次要做一個很簡單的文字轉換程式，輸出效果大致如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181014195346747-1061055064.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181014195347252-210944986.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;144&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;首先我們先來寫做轉換的主程式，大致如下&lt;/p&gt;
&lt;blockquote readability=&quot;15&quot;&gt;
&lt;p&gt;export default class MyTextOutput {&lt;/p&gt;
&lt;p&gt;constructor (formatter = null) {&lt;/p&gt;
&lt;p&gt;  this.formatter = formatter&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;getResult (text) {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  if (!this.formatter) {&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    throw new Error('Text Formatter is required')&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;  }&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;   let result = this.formatter.getFormatterText(text)&lt;/p&gt;
&lt;p align=&quot;left&quot;&gt;    return result&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先 MyTextOutput 類需要在建立時指定要用的 formatter , 最後再透過 getResult 取得轉換後的內容&lt;/p&gt;
&lt;p&gt;而這裡我們就簡單的寫一個 SimpleFormatter 做到一個簡易的轉換效果&lt;/p&gt;
&lt;blockquote readability=&quot;13&quot;&gt;
&lt;p&gt;export default class SimpleFormatter {&lt;/p&gt;
&lt;p&gt;getFormatterText (text) {&lt;/p&gt;
&lt;p&gt;let trans = {&lt;/p&gt;
&lt;p&gt;'a': 'Ä',&lt;/p&gt;
&lt;p&gt;'b': 'ß',&lt;/p&gt;
&lt;p&gt;'c': 'Ć'&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;let outPutTxt = ''&lt;/p&gt;
&lt;p&gt;for (let index = 0; index &amp;lt; text.length; index++) {&lt;/p&gt;
&lt;p&gt;      const ele = text[index]&lt;/p&gt;
&lt;p&gt;    outPutTxt += trans[ele.toLowerCase()]&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;    return outPutTxt&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;p&gt;}&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;加入測試&lt;/p&gt;
&lt;p&gt;在我們完成程式之後，通常會寫一段測試程式來保護你的程式。 當然，如果是採用 TDD 開發方式的話，則是先寫完你的測試程式，再寫你的主程式。但我們這裡先不介紹 TDD , 單純的來介紹一下你的測試程式該怎麼寫&lt;/p&gt;
&lt;p&gt;在寫我們的測試程式之前，我們需要先安裝相關的套件，在這個範例中我們會用到 mocha 與 chai 這兩個套件&lt;/p&gt;
&lt;p&gt;安裝方式如下圖&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181014195347746-390324414.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181014195348359-1771090198.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;238&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來就是我們的測試程式了，我們這次會簡單的寫兩個案例&lt;/p&gt;
&lt;p&gt;一個是忘記指定要使用的formatter 另一個則是我們輸入文字 abc 應該要出現我們預期的結果&lt;/p&gt;
&lt;p&gt;完整的案例如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181014204846276-2002164700.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201810/830852-20181014204847172-1929127493.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;499&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;要運行上述的測試案例 我們需要在 package.json 裡添加相關的 script ，參考下圖&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201811/830852-20181114235148838-584641793.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201811/830852-20181114235149851-1671508172.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;314&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;接下來運行 npm run test 時便可自動的進行測試案例執行&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201811/830852-20181114235150466-879633841.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201811/830852-20181114235151121-328579248.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;163&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3.加入typing.d.ts&lt;/p&gt;
&lt;p&gt;這裡加入 typing 檔其實是為了讓使用者用 VSCode 在開發時，能夠擁有 Intellisense 的效果&lt;/p&gt;
&lt;p&gt;在這裡我們透過微軟提供的 dts-gen 來產生 typeing 檔案。首先我們需要先安裝 dts-gen 這個套件&lt;/p&gt;
&lt;p&gt;接下來比較麻煩的是，依照文件上說明，我們需要先透過 npm 安裝我們的套件，才可以產生 typing 檔&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;pre&gt;
npm install -g dts-gen
&lt;/pre&gt;
&lt;pre&gt;
npm install –g nodedemomodule
&lt;/pre&gt;
&lt;pre&gt;
dts-gen --dt --name nodedemomodule --template module
&lt;/pre&gt;&lt;/blockquote&gt;
&lt;p&gt;不過在我實作的過程中發現到， dts-gen  在產生的時候會少掉主程式的定義，變成我們主程式這個部分需要手動加入。最後產生出來的 typing 檔如下。其中 MyTextOutput 這裡面的定義是我手動加入的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209213920997-1026376754.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209213921752-1788018657.png&quot; alt=&quot;image&quot; width=&quot;640&quot; height=&quot;473&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來就是在 package.json 設定發佈時要將 typing 檔上傳&lt;/p&gt;
&lt;p&gt;這猚可以看到我們的 typing 檔檔名是叫 index.d.ts ，並且是放在根目錄底下&lt;/p&gt;
&lt;p&gt;原因是 VSCode 這裡在搜尋 typing 檔時，預設會從根目錄開始搜尋，並且優先比對 index.d.ts&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230430401-1147443701.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230431125-2027210195.png&quot; alt=&quot;image&quot; width=&quot;628&quot; height=&quot;378&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後的效果圖如下，可以看到 getFormatterText 是一個方法，並且相關參數的說明跟我們  typing 檔一樣&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209213922459-1829132388.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209213923684-1995207449.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;244&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;從下圖可以見到在還沒加入 typing 檔時，是不會有上面這樣的效果的&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209213924750-1067124100.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209213925348-149032156.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;225&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;4.加入Code Coverage&lt;/p&gt;
&lt;p&gt;接下來我們要做的是 Code Coverage 的設定 ， Code Coverage 其實是用來呈現你目前 測試案例完整的程度&lt;/p&gt;
&lt;p&gt;幫助你了解是否測試已經足夠，還有那些方法測試不足&lt;/p&gt;
&lt;p&gt;在這個部分我們為了能容易結合 TravisCI ，採用 nyc 與 coveralls 這兩個套件&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;npm install nyc –D&lt;/p&gt;
&lt;p&gt;npm install coveralls –D&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下來我們設定一 package.json 裡面執行的命令&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230432144-222036347.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230432764-2101583906.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;198&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後簡單執行&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;npm run coveralls&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;就會在目錄底下看到 .nyc_ouput 資料夾產生&lt;/p&gt;
&lt;p&gt;再來呢！ 我們需要到 &lt;a title=&quot;https://coveralls.io/sign-in&quot; href=&quot;https://coveralls.io/sign-in&quot;&gt;https://coveralls.io/sign-in&lt;/a&gt; 這個網站進行註冊與設定的動作&lt;/p&gt;
&lt;p&gt;因為我這裡直接選擇 github 登入。所以可以看到我在 ADD REPO 這裡，可以很容易選擇我想要呈現 code coverage 數據的 REPO&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230433488-996564900.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230434220-1854105318.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;206&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230435039-1566125317.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230436047-1023607520.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;456&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我們在這裡找到練習用的這個 REPO (如果在裡面沒有看到預計要使用的 REPO 的話，右上角有一個 SYNC REPOS 按下去後會進行同步的動作)&lt;/p&gt;
&lt;p&gt;接下來只要按一下 REPO 前面的那個 OFF 圖示，讓他變成 ON 就行了&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230436816-1654115395.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230437413-1792342064.png&quot; alt=&quot;image&quot; width=&quot;614&quot; height=&quot;251&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;再來我們需要移到 TravicsCI 做相關的設定，這樣 coveralls 才能收到相關的數據&lt;/p&gt;
&lt;p&gt;5.結合TravisCI 自動編譯與呈現Code Testing coverage&lt;/p&gt;
&lt;p&gt;同樣的，我們需要先在 TravisCI 上註冊一組我們的帳號，這裡為了求方便我一樣使用 GitHub 登入&lt;/p&gt;
&lt;p&gt;一進來的畫面如下，因為我先前已經有使用 TravisCI 來建置我的 REPO ，所以會看到有一個專案叫 HtmlSEO&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230438495-1299507189.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209230439058-685695715.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;233&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;但我們這次要建立我們練習用的專案來讓 TravisCI 做自動建置，所以我們選一下圖中紅框處的 + 號&lt;/p&gt;
&lt;p&gt;接下來直接搜尋我們要使用的 REPO ，這裡就是我練習用的 nodedemomodule 了。&lt;/p&gt;
&lt;p&gt;並把 REPO 旁邊的 X 按下去，成功後就會呈現打勾的狀態&lt;/p&gt;
&lt;p&gt;(如果沒有出現想使用的 REPO 在左方有一個 Sync account 按下去後就會同步重整了)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232228129-49106333.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232228626-915560916.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;276&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後回到我們的專案底下設定 TravisCI 專用的設定檔  .travis.yml ，這個檔案一般也都會放在根目錄底下&lt;/p&gt;
&lt;p&gt;設定完成的圖如下&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232229336-1343646489.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232230117-565776172.png&quot; alt=&quot;image&quot; width=&quot;627&quot; height=&quot;404&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;可以看到，我們首先要告知 TravisCI 我們的建置環境是 node_js 與 nodejs 的版本為 8&lt;/p&gt;
&lt;p&gt;再來則是需要安裝那些要全域執行的套件，最後就是常用的 npm install 還原我們專案所使用到的套件&lt;/p&gt;
&lt;p&gt;安裝完成後則進行建置的動作，最後再額外產生我們的 code coverage 檔案&lt;/p&gt;
&lt;p&gt;當這個檔案設定完成後，就可以進行 git commit 與 push 的動作！&lt;br/&gt;接下來就可以看到 TravisCI 幫忙你做建置的畫面囉！&lt;/p&gt;
&lt;p&gt;下圖就是 TravisCI 發現 REPO 有更新時自動觸發建置的畫面&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232230750-1613418955.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232231356-435680123.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;386&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後當 npm run coveralls 執行完成時 ，回到 coervalls.io 就可以看到我們的 code coverage 比率了 (如下圖)&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232231971-1094024576.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232232701-428455933.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;693&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;coveralls.io 上的 code coverage 結果&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232233516-2040592571.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232234373-1131221866.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;314&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最後你可以利用以下這幾個連結，放在你的 README 裡讓其它人知道你這個套件的狀態&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&lt;a href=&quot;https://badge.fury.io/js/%7B%E6%8F%9B%E6%88%90%E4%BD%A0%E7%9A%84%E5%A5%97%E4%BB%B6%E5%90%8D%E7%A8%B1%7D&quot;&gt;https://badge.fury.io/js/{換成你的套件名稱}&lt;/a&gt;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;img src=&quot;https://badge.fury.io/js/{換成你的套件名稱}.svg&quot; alt=&quot;npm version&quot; height=&quot;18&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;a href=&quot;https://travis-ci.org/{換成你的travisCI帳號}/{換成你的套件名稱}&quot;&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;img src=&quot;https://travis-ci.org/{換成你的travisCI帳號}/{換成你的套件名稱}.svg?branch=master&quot; alt=&quot;Travis CI&quot; /&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;a href='https://coveralls.io/github/{換成你的github帳號}/{換成你的套件名稱}?branch=master'&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;img src='https://coveralls.io/repos/github/{換成你的github帳號}/{換成你的套件名稱}/badge.svg?branch=master' alt='Coverage Status' /&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;p&gt;成功的話就會看到下面這樣的圖示&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232234860-1384209087.png&quot;&gt;&lt;img title=&quot;image&quot; src=&quot;https://img2018.cnblogs.com/blog/830852/201812/830852-20181209232235324-1937184636.png&quot; alt=&quot;image&quot; width=&quot;650&quot; height=&quot;96&quot; border=&quot;0&quot;/&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以上就是一個比較完成發佈 node module 的流程了！其它像 React 、 Vue 、Angular 其實都大同小異&lt;/p&gt;
&lt;p&gt;如果有任何問題再請留言讓我知道&lt;/p&gt;
&lt;p&gt;謝謝大家&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 15:23:00 +0000</pubDate>
<dc:creator>KingJaja</dc:creator>
<og:description>本文會透過以下幾個段落，讓各位一步一步學習如何寫一個自已的Node.js Module並且發佈到npm package上 Node.js Module 結構 我們先建立一個 NodeModuleDem</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/KingJaja/p/9697427.html</dc:identifier>
</item>
<item>
<title>RabbitMQ 消息确认机制 以及 原理解析 - 残剑今生</title>
<link>http://www.cnblogs.com/DBGzxx/p/10091070.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/DBGzxx/p/10091070.html</guid>
<description>&lt;ul&gt;&lt;li&gt;一、场景&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;当消息的投送方把消息投递出去，却不知道消息是否投递成功了。如果消息投送方不管的话，势必对系统的造成可靠性的影响。&lt;/li&gt;
&lt;li&gt;可是如果要保证系统的可靠性，消息投靠方，如何知道消息是否投放成功了呢？&lt;/li&gt;
&lt;li&gt;这个就需要消息的确认机制，我们来看下rabbitMQ的消息去人机制是如何做的。&lt;/li&gt;
&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;二、原理：上图&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;　　　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366148/201812/1366148-20181209141813371-1360392310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;ul&gt;&lt;li&gt;三、原理解析&lt;/li&gt;
&lt;/ul&gt;&lt;ol&gt;&lt;li&gt;消息的确认分两部分：rabbitMQ确认生产者投递的消息 和 消费者确认 rabbitMQ服务器的消息&lt;/li&gt;
&lt;li&gt;首先说RabbitMQ对生产者的确认，总共分为两种模式分别为 &lt;span&gt;同步模式&lt;/span&gt; 与 &lt;span&gt;&lt;span readability=&quot;2.5&quot;&gt;&lt;span readability=&quot;5&quot;&gt;异步模式&lt;span&gt;。&lt;/span&gt;&lt;p&gt;&lt;span&gt;(1)  同步模式分为 &lt;span&gt;单条消息确认&lt;/span&gt; 与 &lt;span&gt;批量确认&lt;/span&gt;。&lt;/span&gt;&lt;/p&gt;&lt;p&gt;　　①  单条消息确认： channel.waitForConfirms() 普通发送方确认模式；&lt;span&gt;消息到达&lt;/span&gt;交换器，&lt;span&gt;就会返回&lt;/span&gt;true&lt;span&gt;。&lt;/span&gt;&lt;br/&gt;&lt;/p&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　②  批量消息确认： &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;channel.waitForConfirmsOrDie()&lt;span&gt;批量确认模式；使用同步方式等所有的消息发送之后才会执行后面代码，只要有一个消息未&lt;/span&gt;&lt;span&gt;到达&lt;/span&gt;&lt;span&gt;交换器就会抛出&lt;/span&gt;IOException&lt;span&gt;异常。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;　　　 (2) 异步模式为生产者 &lt;span&gt;异步监听消息确认&lt;span&gt;。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　　　　　异步监听消息确认：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;channel.addConfirmListener()&lt;span&gt;异步监听发送方确认模式；&lt;/span&gt;&lt;span&gt;如何使用，参见代码&lt;/span&gt;no-spring&lt;span&gt;模块&lt;/span&gt;&lt;span&gt;包&lt;/span&gt;cn.enjoyedu. producerconfirm&lt;span&gt;中&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;　　  3. 其次说下消费者对RabbitMQ 消息确认。总共分为两种方式 分别为 手动确认 和 自动确认。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　消费者收到的每一条消息都必须进行确认。消息确认后，&lt;/span&gt;RabbitMQ&lt;span&gt;才会从队列删除这条消息，&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;不会为未确认的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消的消费者连接是否已经断开。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　这么设计的原因是RabbitMQ允许消费者消费一条消息的时间可以很久很久。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;　　　　(1)　自动确认：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　消费者在声明队列时，可以指定&lt;/span&gt;autoAck&lt;span&gt;参数，当&lt;/span&gt;&lt;span&gt;autoAck=true&lt;/span&gt;&lt;span&gt;时，一旦消费者接收到了消息，就视为自动确认了消息。如果消费者在处理消息的过程中，出了错，就没有什么办法重新处理这条消息，所以我们很多时候，&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;需要在消息处理成功后，再确认消息，这就需要手动确认。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;  (2)  手动确认：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　 ①当&lt;/span&gt;autoAck=false&lt;span&gt;时，&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;会等待消费者显式发回&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;信号后才从内存&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;和磁盘，如果是持久化消息的话&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;中移去消息。否则，&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;会在队列中消息被消费后立即删除它。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　　　　　　　 ②采用消息确认机制后，只要令&lt;/span&gt;autoAck=false&lt;span&gt;，消费者就有足够的时间处理消息&lt;/span&gt;&lt;span&gt;(&lt;/span&gt;&lt;span&gt;任务&lt;/span&gt;&lt;span&gt;)&lt;/span&gt;&lt;span&gt;，不用担心处理消息过程中消费者进程挂掉后消息丢失的问题，因为&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;会一直持有消息直到消费者显式调用&lt;/span&gt;&lt;span&gt;basicAck&lt;/span&gt;&lt;span&gt;为止。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;　　③当&lt;/span&gt;autoAck=false&lt;span&gt;时，对于&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;服务器端而言，队列中的消息分成了两部分：一部分是等待投递给消费者的消息；一部分是已经投递给消费者，但是还没有收到消费者&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;信号的消息。如果服务器端一直没有收到消费&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;者的&lt;/span&gt;&lt;span&gt;ack&lt;/span&gt;&lt;span&gt;信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;   ④通过运行程序，启动两个消费者&lt;/span&gt;A&lt;span&gt;、&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;，都可以收到消息，但是其中有一个消费者&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;不会对消息进行确认，当把这个消费者&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;关闭后，消费者&lt;/span&gt;&lt;span&gt;B&lt;/span&gt;&lt;span&gt;又会收到本来发送给消费者&lt;/span&gt;&lt;span&gt;A&lt;/span&gt;&lt;span&gt;的消息。所以我们一般使用手动确认的方法是，将消息的处理放在&lt;/span&gt;&lt;span&gt;try/catch&lt;/span&gt;&lt;span&gt;语句块中，成功处理了，就给&lt;/span&gt;&lt;span&gt;RabbitMQ&lt;/span&gt;&lt;span&gt;一个确认应答，如果处理异常了，就在&lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt;中，进行消息的拒绝&lt;/span&gt;&lt;/p&gt;



&lt;ul&gt;&lt;li&gt;如果有什么不足欢迎讨论！&lt;/li&gt;
&lt;/ul&gt;

</description>
<pubDate>Sun, 09 Dec 2018 15:20:00 +0000</pubDate>
<dc:creator>残剑今生</dc:creator>
<og:description>一、场景 二、原理：上图 三、原理解析 (2) 异步模式为生产者 异步监听消息确认。 异步监听消息确认：channel.addConfirmListener()异步监听发送方确认模式；如何使用，参见代</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/DBGzxx/p/10091070.html</dc:identifier>
</item>
<item>
<title>coderfun-boot接私活利器，文档详实，非一般的开发速度 - klguang</title>
<link>http://www.cnblogs.com/klguang/p/10094050.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/klguang/p/10094050.html</guid>
<description>&lt;p&gt;项目主页：&lt;a href=&quot;https://gitee.com/klguang/coderfun-boot&quot; target=&quot;_blank&quot;&gt;https://gitee.com/klguang/coderfun-boot&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;演示地址：&lt;a href=&quot;http://106.15.195.9:8080/admin/&quot;&gt;http://106.15.195.9:8080/admin/&lt;/a&gt;&lt;br/&gt;项目文档：&lt;a href=&quot;https://www.kancloud.cn/coderfun-boot/coderfun-boot-zh/868497&quot;&gt;https://www.kancloud.cn/coderfun-boot/coderfun-boot-zh/868497&lt;/a&gt;&lt;br/&gt;在飞速变化的互联网时代，时间是最大的成本和代价。开源的网站基础开发平台已经多如牛毛了，有思想的项目并不多。从互联网创业浪潮一路走来，总结这几年的开发经验，在空闲时间将之前做的项目经行重构，coderfun-boot便诞生了。本项目最大的特色就是，快速开发。一张业务表的增删改查（后台管理接口+后台管理页面+对外接口），30分钟足矣。&lt;/p&gt;
&lt;p&gt;曾经，我用一周开发一个点餐系统，用不到一个月开发一个进销存系统，只有我一个人。&lt;a href=&quot;https://gitee.com/klguang/fieldmeta&quot;&gt;fieldmeta项目&lt;/a&gt;也是功不可没。可能你会说，你做的是demo(假项目)吧，手动捂脸哈哈哈。事实上，一年半过去了，这些系统在多个地方依然运行良好。你的代码在运行，总是一件幸福的事情。&lt;/p&gt;
&lt;h2&gt;项目特点&lt;/h2&gt;
&lt;ul class=&quot;task-list&quot;&gt;&lt;li&gt;maven模块化开发&lt;/li&gt;
&lt;li&gt;通用网站开发脚手架，用户、角色、权限、菜单、字典管理&lt;/li&gt;
&lt;li&gt;支持集群，基于redis session 共享，阿里云oss做文件存储&lt;/li&gt;
&lt;li&gt;klg-jpa快捷增删改查封装&lt;/li&gt;
&lt;li&gt;easyui快捷增删改查封装&lt;/li&gt;
&lt;li&gt;springmvc 统一异常处理和错误码标准规范&lt;/li&gt;
&lt;li&gt;Aop日志模块&lt;/li&gt;
&lt;/ul&gt;&lt;h2&gt;技术选型&lt;/h2&gt;
&lt;ul class=&quot;task-list&quot;&gt;&lt;li&gt;运行环境：jdk1.7&lt;/li&gt;
&lt;li&gt;数据库：mysql 5.7&lt;/li&gt;
&lt;li&gt;java框架：spring mvc+spring-data-jpa+shiro&lt;/li&gt;
&lt;li&gt;前端框架：easyui 1.5.3&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;关于easyui+jpa的技术选型，可能很多人会吐槽，不过这里我说两句：&lt;/p&gt;
&lt;ol class=&quot;task-list&quot;&gt;&lt;li&gt;easyui并不过时，很适合做管理系统，界面美观，并且适合做结构复杂、数据量多的页面，组件丰富，文档完善。&lt;/li&gt;
&lt;li&gt;jpa运行效率并不低，或者说对系统的使用根本没有影响。缓存、cdn才是最主要需要考虑的。&lt;/li&gt;
&lt;li&gt;脱离应用场景说技术选型，没有意义。对于个人独立开发者（接私活哈哈），中小企业，甚至大公司做系统原型，快速开发是很重要的。&lt;/li&gt;
&lt;/ol&gt;&lt;h2&gt;快速上手&lt;/h2&gt;
&lt;p&gt;1.klg-jpa 便捷查询，详见&lt;a href=&quot;https://gitee.com/klguang/klg-jpa&quot;&gt;klg-jpa项目&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;15.5&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;26&quot;&gt;
&lt;pre&gt;
@ResponseBody
@RequestMapping(&quot;/findpage&quot;)
public EasyUIPage findpage(
        @RequestParam int page,
        @RequestParam int rows,
        @RequestParam(required=false) Long employeeid,
        @RequestParam(required=false) String typeCode,
        @RequestParam(required=false) @DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;) Date startDate,
        @RequestParam(required=false) @DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;) Date endDate){
        Pageable pageable=new PageRequest(page&amp;lt;1?0:page-1, rows, new Sort(Direction.DESC,&quot;numId&quot;));

        Page&amp;lt;DrugOut&amp;gt; pageData=drugOutService.findPage(pageable, 
                AExpr.eq(DrugOut_.employeeid, employeeid).igEmpty(),// igEmpty()忽略空值，包括null和&quot;&quot;
                AExpr.eq(DrugOut_.typeCode, typeCode).igEmpty(),
                AExpr.gte(DrugOut_.saledate, startDate).igEmpty(),//大于
                AExpr.lte(DrugOut_.saledate, endDate).igEmpty());//小于

        return new EasyUIPage(pageData);
}
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;2.easyui 表单增删改查封装，详见 &lt;a href=&quot;https://www.kancloud.cn/coderfun-boot/coderfun-boot-zh/868509&quot;&gt;easyui增删改查封装文档&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;white&quot; readability=&quot;12&quot;&gt;
&lt;div class=&quot;highlight&quot; readability=&quot;19&quot;&gt;
&lt;pre&gt;
   var dataTable = new DataTable({
                $datagrid_table :$(&quot;#datagrid-table&quot;),
                $data_form_dialog : $(&quot;#data-form-dlg&quot;),
                $data_form : $(&quot;#data-form&quot;),
                data_form_name : &quot;测评项目&quot;,
                
                addOpt : {
                        url : adminActionPath+&quot;/project/add&quot;
                },
                editOpt : {
                        url : adminActionPath+&quot;/project/edit&quot;
                },
                removeOpt : {
                        url : adminActionPath+&quot;/project/delete&quot;
                },
                saveOpt : {},
                searchOpt : {
                        $searchForm : $(&quot;#search-form&quot;),
                }
        });
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;h2&gt;部署说明&lt;/h2&gt;
&lt;p&gt;演示地址：&lt;a href=&quot;http://106.15.195.9:8080/admin/&quot;&gt;http://106.15.195.9:8080/admin/&lt;/a&gt;&lt;br/&gt;admin：111111&lt;/p&gt;
&lt;h2&gt;更新日志&lt;/h2&gt;
&lt;p&gt;2018-12-06 发布Alpha 0.0.1-SNAPSHOT&lt;/p&gt;
&lt;h2&gt;项目预览&lt;/h2&gt;
&lt;p&gt;&lt;img title=&quot;user.png&quot; src=&quot;https://images.gitee.com/uploads/images/2018/1203/183607_d68e8ebf_1063744.png&quot; alt=&quot;用户管理&quot;/&gt;&lt;img title=&quot;role.png&quot; src=&quot;https://images.gitee.com/uploads/images/2018/1203/183629_a73ca81c_1063744.png&quot; alt=&quot;角色&quot;/&gt;&lt;img title=&quot;loginlog.png&quot; src=&quot;https://images.gitee.com/uploads/images/2018/1203/183735_b8298cef_1063744.png&quot; alt=&quot;登录日志&quot;/&gt;&lt;img title=&quot;systemlog.png&quot; src=&quot;https://images.gitee.com/uploads/images/2018/1203/183752_cebe210f_1063744.png&quot; alt=&quot;系统日志&quot;/&gt;&lt;/p&gt;&lt;p&gt;&lt;img title=&quot;menu.png&quot; src=&quot;https://images.gitee.com/uploads/images/2018/1203/183805_7169e2ba_1063744.png&quot; alt=&quot;菜单管理&quot;/&gt;&lt;img title=&quot;permission.png&quot; src=&quot;https://images.gitee.com/uploads/images/2018/1203/183714_d31294e8_1063744.png&quot; alt=&quot;权限管理&quot;/&gt;&lt;img title=&quot;code.png&quot; src=&quot;https://images.gitee.com/uploads/images/2018/1203/183725_e95d2af3_1063744.png&quot; alt=&quot;数据字典&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 15:19:00 +0000</pubDate>
<dc:creator>klguang</dc:creator>
<og:description>项目主页：https://gitee.com/klguang/coderfun-boot 演示地址：http://106.15.195.9:8080/admin/项目文档：https://www.ka</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/klguang/p/10094050.html</dc:identifier>
</item>
<item>
<title>搞懂Python的类和对象名称空间 - 骏马金龙</title>
<link>http://www.cnblogs.com/f-ck-need-u/p/10094021.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/f-ck-need-u/p/10094021.html</guid>
<description>&lt;h2 id=&quot;代码块的分类&quot;&gt;代码块的分类&lt;/h2&gt;
&lt;p&gt;python中分几种代码块类型，它们都有自己的作用域，或者说名称空间：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;文件或模块整体是一个代码块，名称空间为全局范围&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;函数代码块，名称空间为函数自身范围，是本地作用域，在全局范围的内层
&lt;ul&gt;&lt;li&gt;函数内部可嵌套函数，嵌套函数有更内一层的名称空间&lt;br/&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;类代码块，&lt;strong&gt;名称空间为类自身&lt;/strong&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;类中可定义函数，类中的函数有自己的名称空间，在类的内层&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类的实例对象有自己的名称空间，和类的名称空间独立&lt;/strong&gt;&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;类可继承父类，可以链接至父类名称空间&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;正是这一层层隔离又连接的名称空间将变量、类、对象、函数等等都组织起来，使得它们可以拥有某些属性，可以进行属性查找。&lt;/p&gt;
&lt;p&gt;本文详细解释类和对象涉及的名称空间，属于纯理论类的内容，有助于理解python面向对象的细节。期间会涉及全局和本地变量作用域的查找规则，如有不明白之处，可先看文章：&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/9925021.html&quot;&gt;Python作用域详述&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;一个概括全文的示例&quot;&gt;一个概括全文的示例&lt;/h2&gt;
&lt;p&gt;以下是一个能在一定程度上概括全文的示例代码段：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;x = 11           # 全局变量x

def f():         # 全局变量f
    print(x)     # 引用全局变量x

def g():         # 全局变量g
    x = 22       # 定义本地变量x
    print(x)     # 引用本地变量x

class supcls():      # 全局变量supcls
    x = 33           # 类变量x
    def m(self):     # 类变量m，类内函数变量self
        x = 44       # 类内函数变量x
        self.x = 55  # 对象变量x

class cls(supcls):   # 全局变量cls
    x = supcls.x     # 引用父类属性x，并定义cls类属性x
    def n(self):     # 类变量n
        self.x = 66  # 对象变量x&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果能理解上面的每个x属于哪个作用域、哪个名称空间，本文内容基本上就理解了。&lt;/p&gt;

&lt;h2 id=&quot;类的名称空间&quot;&gt;类的名称空间&lt;/h2&gt;
&lt;p&gt;下面有一个类，类中有类属性x、y，有类方法m和n。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class supcls():
    x = 3
    y = 4

    def m(self):
        x = 33
        self.x = 333
        self.y = 444
        self.z = 555

    def n(self):
        return self.x, self.y, self.z&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当python解释到supcls代码块后，知道这是一个类，类有自己的名称空间。所以，当知道了这个类里面有x、y、m、n后，这几个属性都会放进类supcls的名称空间中。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181208154257036-590968626.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在上图中，类的名称空间中有属性x、y、m和n，&lt;strong&gt;它们都称为类属性&lt;/strong&gt;。需要说明的是，在python中，函数变量m、n和普通变量没什么区别，仅仅只是它保存了指向函数体的地址，函数体即上图中用func m和func n所表示的对象。&lt;/p&gt;
&lt;p&gt;因为&lt;strong&gt;有名称空间，可以直接使用完全限定名称去访问这个名称空间中的内容&lt;/strong&gt;。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(supcls.x)
print(supcls.y)
print(supcls.m)
print(supcls.n)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;输出结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;3
4
&amp;lt;function supcls.m at 0x02B83738&amp;gt;
&amp;lt;function supcls.n at 0x02B836F0&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为函数m和n也是类的属性，它们也可以直接通过类名来访问执行。例如，新加入一个函数，但不用self参数了，然后执行它。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class testcls():
    z = 3
    def a():
        x = 1
        print(x)
        # print(z)     # 这是错的

testcls.a()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;但是需要注意，&lt;strong&gt;类方法代码块中看不见类变量&lt;/strong&gt;。虽然类和类方法的作用域关系类似于全局作用域和函数本地作用域，但并不总是等价。例如，方法a()中无法直接访问类变量z。这就像类内部看不到全局变量一样。&lt;/p&gt;
&lt;p&gt;上面全都是使用&lt;code&gt;类名.属性&lt;/code&gt;这种完全限定名称去访问类中的属性的。如果生成类的对象，则可以通过对象去访问相关对象属性，因为对象有自己的名称空间，且部分属性来源于类。&lt;/p&gt;

&lt;h2 id=&quot;对象名称空间&quot;&gt;对象名称空间&lt;/h2&gt;
&lt;p&gt;类就像一个模板，可以根据这个模板大量生成具有自己特性的对象。在Python中，只需像调用函数一样直接调用类就可以创建对象。&lt;/p&gt;
&lt;p&gt;例如，下面创建了两个cls类的对象o1和o2，创建类的时候可以传递参数给类，这个参数可以传递给类的构造函数&lt;code&gt;__init__()&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;o1 = cls()
o2 = cls(&quot;some args&quot;)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对象有自己的名称空间。因为对象是根据类来创建的，类是它们的模板，所以对象名称空间中包含所有类属性，但是对象名称空间中这些属性的值不一定和类名称空间属性的值相同。&lt;/p&gt;
&lt;p&gt;现在根据supcls类构造两个对象s1和s2：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class supcls():
    x = 3
    y = 4
    def m(self):
        x = 33
        self.x = 333
        self.y = 444
        self.z = 555
    def n(self):
        return self.x, self.y, self.z

s1 = supcls()
s2 = supcls()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么它们的名称空间，以及类的名称空间的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181208154345461-1835886668.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在仅仅只是对象s1、s2连接到了类supcls，对象s1和s2有自己的名称空间。但因为类supcls中没有构造方法&lt;code&gt;__init__()&lt;/code&gt;初始化对象属性，所以它们的名称空间中除了python内部设置的一些&quot;其它&quot;属性，没有任何属于自己的属性。&lt;/p&gt;
&lt;p&gt;但因为s1、s2连接到了supcls类，所以可以进行对象属性查找，如果对象中没有，将会向上找到supcls。例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(s1.x)    # 输出3，搜索到类名称空间
print(s1.y)    # 输出4，搜索到类名称空间
# print(s1.z)  # 这是错的&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面不再是通过完全限定的名称去访问类中的属性，而是通过对象属性查找的方式搜索到了类属性。但上面访问z属性将报错，因为还没有调用m方法。&lt;/p&gt;
&lt;p&gt;当调用m方法后，将会通过&lt;code&gt;self.xxx&lt;/code&gt;的方式设置完全属于对象自身的属性，包括x、y、z。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s1.m()
s2.m()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，它们的名称空间以及类的名称空间的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181208154418490-2021528879.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;现在对象名称空间中有x、y和z共3个属性(不考虑其它python内部设置的属性)，再通过对象名去访问对象属性，仍然会查找属性，但对于这3个属性的搜索不会进一步搜索到类的名称空间。但如果访问对象中没有的属性，比如m和n，它们不存在于对象的名称空间中，所以会搜索到类名称空间。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(s1.x)  # 对象属性333，搜索到对象名称空间
print(s1.y)  # 对象属性444，搜索到对象名称空间
print(s1.z)  # 对象属性555，搜索到对象名称空间
s1.m()       # 搜索到类名称空间
s1.n()       # 搜索到类名称空间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;对象与对象之间的名称空间是完全隔离的，对象与类之间的名称空间存在连接关系。所以，s1和s2中的x和y和z是互不影响的，谁也看不见谁。&lt;/p&gt;
&lt;p&gt;但现在想要访问类变量x、y，而不是对象变量，该怎么办？直接通过类名的完全限定方式即可：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(s1.x)      # 输出333，对象属性，搜索到对象名称空间
print(supcls.x)  # 输出3，类属性，搜索到类名称空间&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;因为对象有了自己的名称空间，就可以直接向这个名称空间添加属性或设置属性。例如，下面为s1对象添加一个新的属性，但并不是在类内部设置，而是在类的外部设置：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;s1.x = 3333       # 在外部设置已有属性x
s1.var1 = &quot;aaa&quot;   # 在外部添加新属性var1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;新属性var1将只存在于s1，不存在于s2和类supcls中。&lt;/p&gt;

&lt;h3 id=&quot;类属性和对象属性&quot;&gt;类属性和对象属性&lt;/h3&gt;
&lt;p&gt;属于类的属性称为类属性，即那些存在于类名称空间的属性。类属性分为类变量和类方法。有些类方法无法通过对象来调用，这类方法称为称为静态方法。&lt;/p&gt;
&lt;p&gt;类似的，属于对象名称空间的属性称为对象属性。对象属性脱离类属性，和其它对象属性相互隔离。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class cls:
    x=3
    def f():
        y=4
        print(y)
    def m(self):
        self.z=3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的x、f、m都是类属性，x是类变量，f和m是类方法，z是对象属性。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;x可以通过类名和对象名来访问。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;f没有参数，不能通过对象来调用(通过对象调用时默认会传递对象名作为方法的第一个参数)，只能通过类名来调用，所以f属于静态方法。&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;m可以通过对象名来调用，也可以通过类名来调用(但这很不伦不类，因为你要传递一个本来应该是实例名称的参数)。&lt;/li&gt;
&lt;li&gt;z通过self设置，独属于每个self参数代表的对象，所以是对象属性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;子类继承时的名称空间&quot;&gt;子类继承时的名称空间&lt;/h2&gt;
&lt;p&gt;子类和父类之间有继承关系，它们的名称空间也通过一种特殊的方式进行了连接：子类可以继承父类的属性。&lt;/p&gt;
&lt;p&gt;例如下面的例子，子类&lt;code&gt;class childcls(supcls)&lt;/code&gt;表示childcls继承了父类supcls。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class supcls():
    x = 3
    y = 4
    def m(self):
        x = 33
        self.x = 333
        self.y = 444
        self.z = 555
    def n(self):
        return self.x, self.y, self.z

class childcls(supcls):
    y = supcls.y + 1    # 通过类名访问父类属性
    def n(self):
        self.z = 5555&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当python解释完这两段代码块时，初始时的名称空间结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181208110306402-1510693632.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当执行完&lt;code&gt;class childcls(supcls)&lt;/code&gt;代码块之后，子类childcls就有了自己的名称空间。初始时，这个名称空间中除了连接到父类supcls外，还有自己的类变量y和方法n()，子类中的方法n()重写了父类supcls的方法n()。&lt;/p&gt;
&lt;p&gt;因为&lt;strong&gt;有自己的名称空间，所以可以访问类属性。当访问的属性不存在于子类中时，将自动向上搜索到父类&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;print(childcls.x)   # 父类属性，搜索到父类名称空间
print(childcls.y)   # 子类自身属性，搜索到子类名称空间
print(childcls.z)   # 错误，子类和父类都没有该属性&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当创建子类对象的时候，子类对象的变量搜索规则：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;子类对象自身名称空间&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;子类的类名称空间&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;父类的类名称空间&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;例如，创建子类对象c1，并调用子类的方法n()：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;c1 = childcls()
c1.n()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;现在，子类对象c1、子类childcls和父类supcls的关系如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181208114724999-1426718700.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过前面的说明，想必已经不用过多解释。&lt;/p&gt;

&lt;h3 id=&quot;多重继承时的名称空间&quot;&gt;多重继承时的名称空间&lt;/h3&gt;
&lt;p&gt;python支持多重继承，只需将需要继承的父类放进子类定义的括号中即可。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class cls1():
    ...

class cls2():
    ...

class cls3(cls1,cls2):
    ...&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面cls3继承了cls1和cls2，它的名称空间将连接到两个父类名称空间，也就是说只要cls1或cls2拥有的属性，cls3构造的对象就拥有(注意，cls3类是不拥有的，只有cls3类的对象才拥有)。&lt;/p&gt;
&lt;p&gt;但多重继承时，如果cls1和cls2都具有同一个属性，比如cls1.x和cls2.x，那么cls3的对象c3.x取哪一个？会取cls1中的属性x，因为规则是按照(括号中)从左向右的方式搜索父类。&lt;/p&gt;
&lt;p&gt;再考虑一个问题，如果cls1中没有属性x，但它继承自cls0，而cls0有x属性，那么，c3.x取哪个属性。&lt;/p&gt;
&lt;p&gt;在python中，父类属性的搜索规则是&lt;strong&gt;先左后右，先深度后广度，搜索到了就停止&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/733013/201812/733013-20181208122532459-806005001.png&quot;/&gt;&lt;/p&gt;
&lt;p&gt;一般不建议使用多重继承，甚至不少语言根本就不支持多重继承，因为很容易带来属性混乱的问题。&lt;/p&gt;

&lt;h2 id=&quot;类自身就是一个全局属性&quot;&gt;类自身就是一个全局属性&lt;/h2&gt;
&lt;p&gt;在python中，类并没有什么特殊的，它存在于模块文件中，是全局名称空间中的一个属性。&lt;/p&gt;
&lt;p&gt;例如，在模块文件中定义了一个类cls，那么这个cls就是一个全局变量，只不过这个变量中保存的地址是类代码块所在数据对象。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 模块文件顶层
class cls():
    n = 3&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;而模块本身是一个对象，有自己的模块对象名称空间(即全局名称空间)，所以类是这个模块对象名称空间中的一个属性，仅此而已&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外需要注意的是，类代码块和函数代码块不一样，&lt;strong&gt;涉及到类代码块中的变量搜索时，只会根据对象与类的连接、子类与父类的继承连接进行搜索&lt;/strong&gt;。不会像全局变量和函数一样，函数内可以向上搜索全局变量、嵌套函数可以搜索外层函数。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;# 全局范围
x = 3
def f():
    print(x)   # 搜索到全局变量x

class sup():
    # print(x)   # 这是错的，不会搜索全局变量
    y = 3
    print(y)     # 这是对的，存在类属性y
    def m(self):
        # print(y)   # 这是错的，不会搜索到类变量
        self.z = 4

class childcls(sup):
    # print(y)      # 这是错的，不会搜索到父类&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其实很容易理解为什么面向对象要有自己的搜索规则。对象和类之间是&lt;code&gt;is a&lt;/code&gt;的关系，子类和父类也是&lt;code&gt;is a&lt;/code&gt;的关系，这两个&lt;code&gt;is a&lt;/code&gt;是面向对象时名称空间之间的连接关系，在搜索属性的时候可以顺着&quot;这根树&quot;不断向上爬，直到搜索到属性。&lt;/p&gt;

&lt;h2 id=&quot;dict__就是名称空间&quot;&gt;__dict__就是名称空间&lt;/h2&gt;
&lt;p&gt;前面一直说名称空间，这个抽象的东西用来描述作用域，比如全局作用域、本地作用域等等。&lt;/p&gt;
&lt;p&gt;在其他语言中可能很难直接查看名称空间，但是在python中非常容易，因为只要是数据对象，只要有属性，就有自己的&lt;code&gt;__dict__&lt;/code&gt;属性，它是一个字典，表示的就是名称空间。&lt;code&gt;__dict__&lt;/code&gt;内的所有东西，都可以直接通过点&quot;.&quot;的方式去访问、设置、删除，还可以直接向&lt;code&gt;__dict__&lt;/code&gt;中增加属性。&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class supcls():
    x=3

class childcls(supcls):
    y=4
    def f(self):
        self.z=5

&amp;gt;&amp;gt;&amp;gt; c=childcls()
&amp;gt;&amp;gt;&amp;gt; c.__dict__.keys()
dict_keys([])

&amp;gt;&amp;gt;&amp;gt; c.f()
&amp;gt;&amp;gt;&amp;gt; c.__dict__
{'z': 5}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以直接去增、删、改这个dict，所作的修改都会直接对名称空间起作用。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; c.newkey = &quot;NEWKEY&quot;
&amp;gt;&amp;gt;&amp;gt; c.__dict__[&quot;hello&quot;] = &quot;world&quot;
&amp;gt;&amp;gt;&amp;gt; c.__dict__
{'z': 5, 'newkey': 'NEWKEY', 'hello': 'world'}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意，&lt;code&gt;__dict__&lt;/code&gt;表示的是名称空间，所以不会显示类的属性以及父类的属性。正如上面刚创建childcls的实例时，dict中是空的，只有在c.f()之后才设置独属于对象的属性。&lt;/p&gt;
&lt;p&gt;如果要显示类以及继承自父类的属性，可以使用&lt;code&gt;dir()&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; c1 = childcls()
&amp;gt;&amp;gt;&amp;gt; c1.__dict__
{}
&amp;gt;&amp;gt;&amp;gt; dir(c1)
['__class__', '__delattr__', '__dict__',
......
'f', 'x', 'y']&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;关于&lt;code&gt;__dict__&lt;/code&gt;和dir()的详细说明和区别，参见&lt;a href=&quot;https://www.cnblogs.com/f-ck-need-u/p/10087696.html&quot;&gt;dir()和__dict__的区别&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;class__和__base__&quot;&gt;__class__和__base__&lt;/h2&gt;
&lt;p&gt;前面多次提到对象和类之间有连接关系，子类与父类也有连接关系。但是到底是怎么连接的？&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;对象与类之间，通过&lt;code&gt;__class__&lt;/code&gt;进行连接&lt;/strong&gt;：对象的&lt;code&gt;__class__&lt;/code&gt;的值为所属类的名称&lt;br/&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;子类与父类之间，通过&lt;code&gt;__bases__&lt;/code&gt;进行连接&lt;/strong&gt;：子类的&lt;code&gt;__bases__&lt;/code&gt;的值为父类的名称&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;例如：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;class supcls():
    x=3

class childcls(supcls):
    y=4
    def f(self):
        self.z=5

c = childcls()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;c是childcls类的一个实例对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; c.__class__
&amp;lt;class '__main__.childcls'&amp;gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;childcls继承自父类supcls，父类supcls继承自祖先类object：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; childcls.__bases__
(&amp;lt;class '__main__.supcls'&amp;gt;,)

&amp;gt;&amp;gt;&amp;gt; supcls.__bases__
(&amp;lt;class 'object'&amp;gt;,)&lt;/code&gt;
&lt;/pre&gt;

&lt;h3 id=&quot;查看类的继承层次&quot;&gt;查看类的继承层次&lt;/h3&gt;
&lt;p&gt;下面通过&lt;code&gt;__class__&lt;/code&gt;和&lt;code&gt;__bases__&lt;/code&gt;属性来查看对象所在类的继承树结构。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;def classtree(cls, indent):
    print(&quot;.&quot; * indent + cls.__name__)
    for supcls in cls.__bases__:
        classtree(supcls, indent + 3)


def objecttree(obj):
    print(&quot;Tree for %s&quot; % obj)
    classtree(obj.__class__, 3)


class A: pass
class B(A): pass
class C(A): pass
class D(B, C): pass
class E: pass
class F(D, E): pass

objecttree(B())
print(&quot;==============&quot;)
objecttree(F())&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行结果：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Tree for &amp;lt;__main__.B object at 0x037D1630&amp;gt;
...B
......A
.........object
==============
Tree for &amp;lt;__main__.F object at 0x037D1630&amp;gt;
...F
......D
.........B
............A
...............object
.........C
............A
...............object
......E
.........object&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sun, 09 Dec 2018 15:13:00 +0000</pubDate>
<dc:creator>骏马金龙</dc:creator>
<og:description>代码块的分类 python中分几种代码块类型，它们都有自己的作用域，或者说名称空间： 文件或模块整体是一个代码块，名称空间为全局范围 函数代码块，名称空间为函数自身范围，是本地作用域，在全局范围的内层</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/f-ck-need-u/p/10094021.html</dc:identifier>
</item>
<item>
<title>ML.NET教程之情感分析(二元分类问题) - Ken.W</title>
<link>http://www.cnblogs.com/kenwoo/p/10093362.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/kenwoo/p/10093362.html</guid>
<description>&lt;p&gt;机器学习的工作流程分为以下几个步骤：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;理解问题&lt;/li&gt;
&lt;li&gt;准备数据
&lt;ul&gt;&lt;li&gt;加载数据&lt;/li&gt;
&lt;li&gt;提取特征&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;构建与训练
&lt;ul&gt;&lt;li&gt;训练模型&lt;/li&gt;
&lt;li&gt;评估模型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;运行
&lt;ul&gt;&lt;li&gt;使用模型&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本教程需要解决的问题是根据网站内评论的意见采取合适的行动。&lt;/p&gt;
&lt;p&gt;可用的训练数据集中，网站评论可能是有毒(toxic)(1)或者无毒(not toxic)(0)两种类型。这种场景下，机器学习中的分类任务最为适合。&lt;/p&gt;
&lt;p&gt;分类任务用于区分数据内的类别(category)，类型(type)或种类(class)。常见的例子有：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;识别情感是正面或是负面&lt;/li&gt;
&lt;li&gt;将邮件按照是否为垃圾邮件归类&lt;/li&gt;
&lt;li&gt;判定病人的实验室样本是否为癌症&lt;/li&gt;
&lt;li&gt;按照客户的偏好进行分类以响应销售活动&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;分类任务可以是二元又或是多元的。这里面临的是二元分类的问题。&lt;/p&gt;

&lt;p&gt;首先建立一个控制台应用程序，基于.NET Core。完成搭建后，添加Microsoft.ML类库包。接着在工程下新建名为&lt;code&gt;Data&lt;/code&gt;的文件夹。&lt;/p&gt;
&lt;p&gt;之后，下载&lt;a href=&quot;https://github.com/dotnet/machinelearning/blob/master/test/data/wikipedia-detox-250-line-data.tsv&quot;&gt;WikiPedia-detox-250-line-data.tsv&lt;/a&gt;与&lt;a href=&quot;https://github.com/dotnet/machinelearning/blob/master/test/data/wikipedia-detox-250-line-test.tsv&quot;&gt;wikipedia-detox-250-line-test.tsv&lt;/a&gt;文件，并将它们放入&lt;code&gt;Data&lt;/code&gt;文件夹，值得注意的是，这两个文件的&lt;code&gt;Copy to Output Directory&lt;/code&gt;属性需要修改成&lt;code&gt;Copy if newer&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;Program.cs&lt;/code&gt;文件的&lt;code&gt;Main&lt;/code&gt;方法里加入以下代码：&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;MLContext mlContext = new MLContext(seed: 0);

_textLoader = mlContext.Data.TextReader(new TextLoader.Arguments()
{
    Separator = &quot;tab&quot;,
    HasHeader = true,
    Column = new[]
                {
                    new TextLoader.Column(&quot;Label&quot;, DataKind.Bool, 0),
                    new TextLoader.Column(&quot;SentimentText&quot;, DataKind.Text, 1)
                }
});&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其目的是通过使用TextLoader类为数据的加载作好准备。&lt;/p&gt;
&lt;p&gt;Column属性中构建了两个对象，即对应数据集中的两列数据。不过第一列这里必须使用&lt;code&gt;Label&lt;/code&gt;而不是&lt;code&gt;Sentiment&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;新建一个&lt;code&gt;SentimentData.cs&lt;/code&gt;文件，其中加入SentimentData类与SentimentPrediction。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public class SentimentData
{
    [Column(ordinal: &quot;0&quot;, name: &quot;Label&quot;)]
    public float Sentiment;
    [Column(ordinal: &quot;1&quot;)]
    public string SentimentText;
}

public class SentimentPrediction
{
    [ColumnName(&quot;PredictedLabel&quot;)]
    public bool Prediction { get; set; }

    [ColumnName(&quot;Probability&quot;)]
    public float Probability { get; set; }

    [ColumnName(&quot;Score&quot;)]
    public float Score { get; set; }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;SentimentData类中的SentimentText为输入数据集的特征，Sentiment则是数据集的标记(label)。&lt;/p&gt;
&lt;p&gt;SentimentPrediction类用于模型被训练后的预测。&lt;/p&gt;

&lt;p&gt;在&lt;code&gt;Program&lt;/code&gt;类中加入&lt;code&gt;Train&lt;/code&gt;方法。首先它会读取训练数据集，接着将特征列中的文本型数据转换为浮点型数组并设定了训练时所使用的决策树二元分类模型。之后，即是实际训练模型。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static ITransformer Train(MLContext mlContext, string dataPath)
{
    IDataView dataView = _textLoader.Read(dataPath);
    var pipeline = mlContext.Transforms.Text.FeaturizeText(&quot;SentimentText&quot;, &quot;Features&quot;)
        .Append(mlContext.BinaryClassification.Trainers.FastTree(numLeaves: 50, numTrees: 50, minDatapointsInLeaves: 20));

    Console.WriteLine(&quot;=============== Create and Train the Model ===============&quot;);
    var model = pipeline.Fit(dataView);
    Console.WriteLine(&quot;=============== End of training ===============&quot;);
    Console.WriteLine();

    return model;
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;加入&lt;code&gt;Evaluate&lt;/code&gt;方法。到了这一步，需要读取的是用于测试的数据集，且读取后的数据仍然需要转换成合适的数据类型。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;public static void Evaluate(MLContext mlContext, ITransformer model)
{
    IDataView dataView = _textLoader.Read(_testDataPath);
    Console.WriteLine(&quot;=============== Evaluating Model accuracy with Test data===============&quot;);
    var predictions = model.Transform(dataView);

    var metrics = mlContext.BinaryClassification.Evaluate(predictions, &quot;Label&quot;);
    Console.WriteLine();
    Console.WriteLine(&quot;Model quality metrics evaluation&quot;);
    Console.WriteLine(&quot;--------------------------------&quot;);
    Console.WriteLine($&quot;Accuracy: {metrics.Accuracy:P2}&quot;);
    Console.WriteLine($&quot;Auc: {metrics.Auc:P2}&quot;);
    Console.WriteLine($&quot;F1Score: {metrics.F1Score:P2}&quot;);
    Console.WriteLine(&quot;=============== End of model evaluation ===============&quot;);
}&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;训练及评估模型完成后，就可以正式使用它了。这里需要建立一个用于预测的对象(&lt;code&gt;PredictionFunction&lt;/code&gt;)，其预测方法的输入参数是&lt;code&gt;SentimentData&lt;/code&gt;类型，返回结果为&lt;code&gt;SentimentPrediction&lt;/code&gt;类型。&lt;/p&gt;
&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;private static void Predict(MLContext mlContext, ITransformer model)
{
    var predictionFunction = model.MakePredictionFunction&amp;lt;SentimentData, SentimentPrediction&amp;gt;(mlContext);
    SentimentData sampleStatement = new SentimentData
    {
        SentimentText = &quot;This is a very rude movie&quot;
    };

    var resultprediction = predictionFunction.Predict(sampleStatement);

    Console.WriteLine();
    Console.WriteLine(&quot;=============== Prediction Test of model with a single sample and test dataset ===============&quot;);

    Console.WriteLine();
    Console.WriteLine($&quot;Sentiment: {sampleStatement.SentimentText} | Prediction: {(Convert.ToBoolean(resultprediction.Prediction) ? &quot;Toxic&quot; : &quot;Not Toxic&quot;)} | Probability: {resultprediction.Probability} &quot;);
    Console.WriteLine(&quot;=============== End of Predictions ===============&quot;);
    Console.WriteLine();
}&lt;/code&gt;
&lt;/pre&gt;

&lt;pre class=&quot;csharp&quot;&gt;
&lt;code&gt;using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.ML;
using Microsoft.ML.Core.Data;
using Microsoft.ML.Runtime.Data;
using Microsoft.ML.Transforms.Text;

namespace SentimentAnalysis
{
    class Program
    {
        static readonly string _trainDataPath = Path.Combine(Environment.CurrentDirectory, &quot;Data&quot;, &quot;wikipedia-detox-250-line-data.tsv&quot;);
        static readonly string _testDataPath = Path.Combine(Environment.CurrentDirectory, &quot;Data&quot;, &quot;wikipedia-detox-250-line-test.tsv&quot;);
        static readonly string _modelPath = Path.Combine(Environment.CurrentDirectory, &quot;Data&quot;, &quot;Model.zip&quot;);
        static TextLoader _textLoader;

        static void Main(string[] args)
        {
            MLContext mlContext = new MLContext(seed: 0);

            _textLoader = mlContext.Data.TextReader(new TextLoader.Arguments()
            {
                Separator = &quot;tab&quot;,
                HasHeader = true,
                Column = new[]
                            {
                                new TextLoader.Column(&quot;Label&quot;, DataKind.Bool, 0),
                                new TextLoader.Column(&quot;SentimentText&quot;, DataKind.Text, 1)
                            }
            });

            var model = Train(mlContext, _trainDataPath);

            Evaluate(mlContext, model);

            Predict(mlContext, model);

            Console.Read();
        }

        public static ITransformer Train(MLContext mlContext, string dataPath)
        {
            IDataView dataView = _textLoader.Read(dataPath);
            var pipeline = mlContext.Transforms.Text.FeaturizeText(&quot;SentimentText&quot;, &quot;Features&quot;)
                .Append(mlContext.BinaryClassification.Trainers.FastTree(numLeaves: 50, numTrees: 50, minDatapointsInLeaves: 20));

            Console.WriteLine(&quot;=============== Create and Train the Model ===============&quot;);
            var model = pipeline.Fit(dataView);
            Console.WriteLine(&quot;=============== End of training ===============&quot;);
            Console.WriteLine();

            return model;
        }

        public static void Evaluate(MLContext mlContext, ITransformer model)
        {
            IDataView dataView = _textLoader.Read(_testDataPath);
            Console.WriteLine(&quot;=============== Evaluating Model accuracy with Test data===============&quot;);
            var predictions = model.Transform(dataView);

            var metrics = mlContext.BinaryClassification.Evaluate(predictions, &quot;Label&quot;);
            Console.WriteLine();
            Console.WriteLine(&quot;Model quality metrics evaluation&quot;);
            Console.WriteLine(&quot;--------------------------------&quot;);
            Console.WriteLine($&quot;Accuracy: {metrics.Accuracy:P2}&quot;);
            Console.WriteLine($&quot;Auc: {metrics.Auc:P2}&quot;);
            Console.WriteLine($&quot;F1Score: {metrics.F1Score:P2}&quot;);
            Console.WriteLine(&quot;=============== End of model evaluation ===============&quot;);
        }

        private static void Predict(MLContext mlContext, ITransformer model)
        {
            var predictionFunction = model.MakePredictionFunction&amp;lt;SentimentData, SentimentPrediction&amp;gt;(mlContext);
            SentimentData sampleStatement = new SentimentData
            {
                SentimentText = &quot;This is a very rude movie&quot;
            };

            var resultprediction = predictionFunction.Predict(sampleStatement);

            Console.WriteLine();
            Console.WriteLine(&quot;=============== Prediction Test of model with a single sample and test dataset ===============&quot;);

            Console.WriteLine();
            Console.WriteLine($&quot;Sentiment: {sampleStatement.SentimentText} | Prediction: {(Convert.ToBoolean(resultprediction.Prediction) ? &quot;Toxic&quot; : &quot;Not Toxic&quot;)} | Probability: {resultprediction.Probability} &quot;);
            Console.WriteLine(&quot;=============== End of Predictions ===============&quot;);
            Console.WriteLine();
        }
    }
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;程序运行后显示的结果：&lt;/p&gt;
&lt;pre class=&quot;plain&quot;&gt;
&lt;code&gt;=============== Create and Train the Model ===============
=============== End of training ===============

=============== Evaluating Model accuracy with Test data===============

Model quality metrics evaluation
--------------------------------
Accuracy: 83.33%
Auc: 98.77%
F1Score: 85.71%
=============== End of model evaluation ===============

=============== Prediction Test of model with a single sample and test dataset ===============

Sentiment: This is a very rude movie | Prediction: Toxic | Probability: 0.7387648
=============== End of Predictions ===============&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到在预测&lt;code&gt;This is a very rude movie&lt;/code&gt;(这是一部粗制滥造的电影)这句评论时，模型判定其是有毒的:-)&lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 14:42:00 +0000</pubDate>
<dc:creator>Ken.W</dc:creator>
<og:description>机器学习的工作流程分为以下几个步骤： 1. 理解问题 2. 准备数据 加载数据 提取特征 3. 构建与训练 训练模型 评估模型 4. 运行 使用模型 理解问题 本教程需要解决的问题是根据网站内评论的意</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/kenwoo/p/10093362.html</dc:identifier>
</item>
<item>
<title>Kafka性能测试实例 - 哥不是小萝莉</title>
<link>http://www.cnblogs.com/smartloli/p/10093838.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/smartloli/p/10093838.html</guid>
<description>&lt;p&gt;在分布式实时数据流场景下，随着数据量的增长，对Kafka集群的性能和稳定性的要求也很高。本篇博客将从生产者和消费者两方面来做性能测试，针对具体的业务和数据量，来调优Kafka集群。&lt;/p&gt;

&lt;h2&gt;2.1 测试环境&lt;/h2&gt;
&lt;p&gt;本次测试的环境信息由三台物理机组成，具体信息如下所示：&lt;/p&gt;
&lt;h2&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209203937106-1226673950.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;h2&gt;2.2 测试工具&lt;/h2&gt;
&lt;p&gt;Kafka系统提供了测试工具kafka-producer-perf-test.sh和kafka-consumer-perf-test.sh，通过该工具可以对生产者性能和消费者性能进行测试，获取一组最佳的参数值，进而提升生产者的发送效率和消费者的读取效率。这里如果需要实现带有线程参数功能的工具，可以修改工具源代码，新建一个kafka-producer-perf-test-0.8.sh脚本，实现内容如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 使用老版本的ProducerPerformance工具类
exec $(&lt;/span&gt;&lt;span&gt;dirname&lt;/span&gt; $&lt;span&gt;0&lt;/span&gt;)/kafka-run-class.&lt;span&gt;sh&lt;/span&gt; kafka.tools.ProducerPerformance &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;$@&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2.1 生产者测试参数&lt;/h3&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209204019736-1863850080.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;2.2.2 消费者测试参数&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209204054247-804978831.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;生产者测试，分别从线程数、分区数、副本数、Broker数、同步与异步模式、批处理大小、消息长度大小、数据压缩等维度来进行。&lt;/p&gt;
&lt;h2&gt;3.1 线程数&lt;/h2&gt;
&lt;p&gt;创建一个拥有6个分区、1个副本的Topic，设置不同的线程数并发送相同的数据量，查看性能变化。测试脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;47&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 创建主题
[hadoop@dn1 &lt;/span&gt;~]$ kafka-topics.&lt;span&gt;sh&lt;/span&gt; --create --zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;, dn2:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;,
 dn3:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt; --topic test_producer_perf --partitions &lt;span&gt;6&lt;/span&gt; --replication-factor &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

# 设置1个线程数
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf --threads &lt;span&gt;1&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;, dn2:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn3:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;

# 设置10个线程数
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf --threads &lt;span&gt;10&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;

# 设置20个线程数
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf --threads &lt;span&gt;20&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;

# 设置25个线程数
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf --threads &lt;span&gt;25&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;

# 设置30个线程数
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf --threads &lt;span&gt;30&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.1.1 测试结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209204535179-758153566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.1.2 结论&lt;/h3&gt;
&lt;p&gt;向一个拥有6个分区、1个副本的Topic中，发送500万条消息记录时，随着线程数的增加，每秒发送的消息记录会逐渐增加。在线程数为25时，每秒发送的消息记录达到最佳值，随后再增加线程数，每秒发送的消息记录数反而会减少。&lt;/p&gt;
&lt;h2&gt;3.2 分区数&lt;/h2&gt;
&lt;p&gt;（1）新建一个拥有12个分区、1个副本的主题；&lt;br/&gt;（2）新建一个拥有24个分区、1个副本的主题；&lt;br/&gt;（3）向拥有12个分区、1个副本的主题中发送相同数量的消息记录，查看性能变化；&lt;br/&gt;（4）向拥有24个分区、1个副本的主题中发送相同数量的消息记录，查看性能变化。&lt;/p&gt;
&lt;p&gt;执行命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 创建一个拥有12个分区的主题
[hadoop@dn1 &lt;/span&gt;~]$ kafka-topics.&lt;span&gt;sh&lt;/span&gt; --create --zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;, dn2:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;,
 dn3:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt; --topic test_producer_perf_p12 --partitions &lt;span&gt;12&lt;/span&gt;
 --replication-factor &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
# 创建一个拥有24个分区的主题
[hadoop@dn1 &lt;/span&gt;~]$ kafka-topics.&lt;span&gt;sh&lt;/span&gt; --create --zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;, dn2:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;,
 dn3:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt; --topic test_producer_perf_p24 --partitions &lt;span&gt;24&lt;/span&gt;
 --replication-factor &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

# 用一个线程发送数据到拥有12个分区的主题中
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_p12 --threads &lt;span&gt;1&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;

# 用一个线程发送数据到拥有24个分区的主题中
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_p24 --threads &lt;span&gt;1&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.2.1 测试结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209224304483-636891023.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.2.2 结论&lt;/h3&gt;
&lt;p&gt;从测试结果来看，分区数越多，单线程生产者的吞吐量越小。&lt;/p&gt;
&lt;h2&gt;3.3 副本数&lt;/h2&gt;
&lt;p&gt;（1）创建一个拥有两个副本、6个分区的主题；&lt;br/&gt;（2）创建一个拥有3个副本、6个分区的主题；&lt;br/&gt;（3）向拥有两个副本、6个分区的主题中发送相同数量的消息记录，查看性能变化；&lt;br/&gt;（4）向拥有3个副本、6个分区的主题中发送相同数量的消息记录，查看性能变化；&lt;/p&gt;
&lt;p&gt; 执行命令如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 创建一个拥有两个副本、6个分区的主题
[hadoop@dn1 &lt;/span&gt;~]$ kafka-topics.&lt;span&gt;sh&lt;/span&gt; --create --zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;, dn2:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;,
 dn3:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt; --topic test_producer_perf_r2 --partitions &lt;span&gt;6&lt;/span&gt;
 --replication-factor &lt;span&gt;2&lt;/span&gt;&lt;span&gt;

# 创建一个拥有3个副本、6个分区的主题
[hadoop@dn1 &lt;/span&gt;~]$ kafka-topics.&lt;span&gt;sh&lt;/span&gt; --create --zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;, dn2:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;,
 dn3:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt; --topic test_producer_perf_r3 --partitions &lt;span&gt;6&lt;/span&gt;
 --replication-factor &lt;span&gt;3&lt;/span&gt;&lt;span&gt;

# 用3个线程发送数据到拥有两个副本的主题中
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_r2 --threads &lt;span&gt;3&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;

# 用3个线程发送数据到拥有3个副本的主题中
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_r3 --threads &lt;span&gt;3&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.3.1 测试结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209224722093-127244098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.3.2 结论&lt;/h3&gt;
&lt;p&gt;从测试结果来看，副本数越多，吞吐量越小。&lt;/p&gt;
&lt;h3&gt;3.4 Broker数量&lt;/h3&gt;
&lt;p&gt;通过增加Broker节点数量来查看性能变化，脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# Kafka节点数为4个时，异步发送消息记录
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_b3 --threads &lt;span&gt;3&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt;, dn4:&lt;span&gt;9092&lt;/span&gt; --batch-size &lt;span&gt;3000&lt;/span&gt; --request-timeout-ms &lt;span&gt;100000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.4.1 测试结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209225012861-185940575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.4.2 结论&lt;/h3&gt;
&lt;p&gt;从测试结果来看，增加Kafka Broker数量，吞吐量会增加。&lt;/p&gt;
&lt;h2&gt;3.5 同步与异步模式&lt;/h2&gt;
&lt;p&gt;分别使用同步和异步模式发送相同数量的消息记录，查看性能变化。执行脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 创建一个有用3个副本、6个分区的主题
[hadoop@dn1 &lt;/span&gt;~]$ kafka-topics.&lt;span&gt;sh&lt;/span&gt; --create --zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;, dn2:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;,
 dn3:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt; --topic test_producer_perf_s2 --partitions &lt;span&gt;6&lt;/span&gt;
 --replication-factor &lt;span&gt;3&lt;/span&gt;&lt;span&gt;

# 使用同步模式发送消息数据
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_s2 --threads &lt;span&gt;3&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt; --&lt;span&gt;sync&lt;/span&gt;&lt;span&gt;

# 使用异步模式发送消息记录
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_s2 --threads &lt;span&gt;3&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.5.1 测试结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209225226658-1878413535.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.5.2 结论&lt;/h3&gt;
&lt;p&gt;从测试结果来看，使用异步模式发送消息数据，比使用同步模式发送消息数据，吞吐量是同步模式的3倍左右。&lt;/p&gt;
&lt;h2&gt;3.6 批处理大小&lt;/h2&gt;
&lt;p&gt;使用异步模式发送相同数量的消息数据，改变批处理量的大小，查看性能变化，执行脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 以批处理模式发送，大小为1000条
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_s2 --threads &lt;span&gt;3&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt; --batch-size &lt;span&gt;1000&lt;/span&gt;  --request-timeout-ms &lt;span&gt;100000&lt;/span&gt;&lt;span&gt;

# 以批处理模式发送，大小为3000条
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_s2 --threads &lt;span&gt;3&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt; --batch-size &lt;span&gt;3000&lt;/span&gt;  --request-timeout-ms &lt;span&gt;100000&lt;/span&gt;&lt;span&gt;

# 以批处理模式发送，大小为5000条
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_s2 --threads &lt;span&gt;3&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt; --batch-size &lt;span&gt;5000&lt;/span&gt;  --request-timeout-ms &lt;span&gt;100000&lt;/span&gt;&lt;span&gt;

# 以批处理模式发送，大小为7000条
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_s2 --threads &lt;span&gt;3&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt; --batch-size &lt;span&gt;7000&lt;/span&gt;  --request-timeout-ms &lt;span&gt;100000&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.6.1 测试结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209225439600-1847161992.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;3.6.2 结论&lt;/p&gt;
&lt;p&gt;从测试的结果来看，发送的消息随着批处理大小增加而增加。当批处理大小增加到3000~5000时，吞吐量达到最佳值。而后再增加批处理大小，吞吐量的性能会下降。&lt;/p&gt;
&lt;h2&gt;3.7 消息长度的大小&lt;/h2&gt;
&lt;p&gt;改变消息的长度大小，查看性能变化，执行脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 发送消息，长度为100字节
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_s2 --threads &lt;span&gt;3&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt; --batch-size &lt;span&gt;3000&lt;/span&gt;  --request-timeout-ms &lt;span&gt;100000&lt;/span&gt;
 --message-size &lt;span&gt;100&lt;/span&gt;&lt;span&gt;

# 发送消息，长度为200字节
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_s2 --threads &lt;span&gt;3&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt; --batch-size &lt;span&gt;3000&lt;/span&gt;  --request-timeout-ms &lt;span&gt;100000&lt;/span&gt;
 --message-size &lt;span&gt;200&lt;/span&gt;&lt;span&gt;

# 发送消息，长度为500字节
[hadoop@dn1 &lt;/span&gt;~]$ kafka-producer-perf-test-&lt;span&gt;0.8&lt;/span&gt;.&lt;span&gt;sh&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;
  --topics test_producer_perf_s2 --threads &lt;span&gt;3&lt;/span&gt; --broker-list  dn1:&lt;span&gt;9092&lt;/span&gt;&lt;span&gt;,
 dn2:&lt;/span&gt;&lt;span&gt;9092&lt;/span&gt;, dn3:&lt;span&gt;9092&lt;/span&gt; --batch-size &lt;span&gt;3000&lt;/span&gt;  --request-timeout-ms &lt;span&gt;100000&lt;/span&gt;
 --message-size &lt;span&gt;500&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;3.7.1 测试结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209225616114-1270879047.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;3.7.2 结论&lt;/h3&gt;
&lt;p&gt;从测试结果来看，随着消息长度的增加，每秒所能发送的消息数量逐渐减少（nMsg/sec）。但是，每秒发送的消息的总大小（MB/sec），会随着消息长度的增加而增加。&lt;/p&gt;

&lt;p&gt;消费者测试，可以从线程数、分区数、副本数等维度来进行测试。&lt;/p&gt;
&lt;h2&gt;4.1 线程数&lt;/h2&gt;
&lt;p&gt;创建一个拥有6个分区、1个备份的Topic，用不同的线程数读取相同的数据量，查看性能变化。测试脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 创建主题
[hadoop@dn1 &lt;/span&gt;~]$ kafka-topics.&lt;span&gt;sh&lt;/span&gt; --create --zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;, dn2:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;,
 dn3:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt; --topic test_consumer_perf --partitions &lt;span&gt;6&lt;/span&gt; --replication-factor &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

# 设置1个线程数
[hadoop@dn1 &lt;/span&gt;~]$ kafka-consumer-perf-test.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; –zookeeper
 dn1:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt;,dn2:&lt;span&gt;2181&lt;/span&gt;,dn3:&lt;span&gt;2181&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt; --&lt;span&gt;topic test_consumer_perf
 &lt;/span&gt;--group g1 --threads &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

# 设置3个线程数
[hadoop@dn1 &lt;/span&gt;~]$ kafka-consumer-perf-test.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; –zookeeper
 dn1:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt;,dn2:&lt;span&gt;2181&lt;/span&gt;,dn3:&lt;span&gt;2181&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt; --&lt;span&gt;topic test_consumer_perf
 &lt;/span&gt;--group g2 --threads &lt;span&gt;3&lt;/span&gt;&lt;span&gt;

# 设置6个线程数
[hadoop@dn1 &lt;/span&gt;~]$ kafka-consumer-perf-test.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; –zookeeper
 dn1:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt;,dn2:&lt;span&gt;2181&lt;/span&gt;,dn3:&lt;span&gt;2181&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt; --&lt;span&gt;topic test_consumer_perf
 &lt;/span&gt;--group g3 --threads &lt;span&gt;6&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.1.1 测试结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209222754429-2084486157.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.1.2 结论&lt;/h3&gt;
&lt;p&gt;随着线程数的增加，每秒读取的消息记录会逐渐增加。在线程数与消费主题的分区相等时，吞吐量达到最佳值。随后，再增加线程数，新增的线程数将会处于空闲状态，对提升消费者程序的吞吐量没有帮助。&lt;/p&gt;
&lt;h2&gt;4.2 分区数&lt;/h2&gt;
&lt;p&gt;新建一个Topic，改变它的分区数，读取相同数量的消息记录，查看性能变化，执行脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 创建一个拥有12个分区的主题
[hadoop@dn1 &lt;/span&gt;~]$ kafka-topics.&lt;span&gt;sh&lt;/span&gt; --create --zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;, dn2:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;,
 dn3:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt; --topic test_consumer_perf_p12 --partitions &lt;span&gt;12&lt;/span&gt;
 --replication-factor &lt;span&gt;1&lt;/span&gt;&lt;span&gt;
# 创建一个拥有24个分区的主题
[hadoop@dn1 &lt;/span&gt;~]$ kafka-topics.&lt;span&gt;sh&lt;/span&gt; --create --zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;, dn2:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;,
 dn3:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt; --topic test_consumer_perf_p24 --partitions &lt;span&gt;24&lt;/span&gt;
 --replication-factor &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

# 用一个线程读取数据到拥有12个分区的主题中
[hadoop@dn1 &lt;/span&gt;~]$ kafka-consumer-perf-test.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; –zookeeper
 dn1:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt;,dn2:&lt;span&gt;2181&lt;/span&gt;,dn3:&lt;span&gt;2181&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;&lt;span&gt; –topic
 test_consumer_perf_p12_&lt;/span&gt;--group g2 --threads &lt;span&gt;1&lt;/span&gt;&lt;span&gt;

# 用一个线程读取数据到拥有12个分区的主题中
[hadoop@dn1 &lt;/span&gt;~]$ kafka-consumer-perf-test.&lt;span&gt;sh&lt;/span&gt;&lt;span&gt; –zookeeper
 dn1:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt;,dn2:&lt;span&gt;2181&lt;/span&gt;,dn3:&lt;span&gt;2181&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;&lt;span&gt; –topic
 test_consumer_perf_p24_&lt;/span&gt;--group g3 --threads &lt;span&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.2.1 测试结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209225833387-1311325182.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h3&gt;4.2.2 结论&lt;/h3&gt;
&lt;p&gt;当分区数增加时，如果线程数保持不变，则消费者程序的吞吐量性能会下降。&lt;/p&gt;
&lt;h2&gt;4.3 副本数 &lt;/h2&gt;
&lt;p&gt;新建Topic，改变Topic的副本数，读取相同数量的消息记录，查看性能变化，执行脚本如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;# 创建一个有用两个副本、6个分区的主题
[hadoop@dn1 &lt;/span&gt;~]$ kafka-topics.&lt;span&gt;sh&lt;/span&gt; --create --zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;, dn2:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;,
 dn3:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt; –topic test_consumer_perf_r2 --partitions &lt;span&gt;6&lt;/span&gt;
 --replication-factor &lt;span&gt;2&lt;/span&gt;&lt;span&gt;

# 创建一个有3个副本、6个分区的主题
[hadoop@dn1 &lt;/span&gt;~]$ kafka-topics.&lt;span&gt;sh&lt;/span&gt; --create --zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;, dn2:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;,
 dn3:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt; –topic test_consumer_perf_r3 --partitions &lt;span&gt;6&lt;/span&gt;
 --replication-factor &lt;span&gt;3&lt;/span&gt;&lt;span&gt;

# 用3个线程读取数据到拥有两个副本的主题中
[hadoop@dn1 &lt;/span&gt;~]$ kafka-consumer-perf-test.&lt;span&gt;sh&lt;/span&gt; –zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;
,dn2:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt;,dn3:&lt;span&gt;2181&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;&lt;span&gt; –topic
 test_consumer_perf_r2_&lt;/span&gt;--group g2 --threads &lt;span&gt;3&lt;/span&gt;&lt;span&gt;

# 用3个线程读取数据到拥有3个副本的主题中
[hadoop@dn1 &lt;/span&gt;~]$ kafka-consumer-perf-test.&lt;span&gt;sh&lt;/span&gt; --zookeeper dn1:&lt;span&gt;2181&lt;/span&gt;&lt;span&gt;
,dn2:&lt;/span&gt;&lt;span&gt;2181&lt;/span&gt;,dn3:&lt;span&gt;2181&lt;/span&gt; --messages &lt;span&gt;5000000&lt;/span&gt;&lt;span&gt; –topic
 test_consumer_perf_r3_&lt;/span&gt;--group g3 --threads &lt;span&gt;3&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;4.3.1 测试结果&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/666745/201812/666745-20181209230054414-812503574.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.3.2 结论&lt;/p&gt;
&lt;p&gt;副本数对消费者程序的吞吐量影响较小，消费者程序是从Topic的每个分区的Leader上读取数据的，而与副本数无关。 &lt;/p&gt;

&lt;p&gt;Kafka性能测试步骤并不复杂，大家可以根据实际的测试环境、数据量，通过对生产者和消费者不同维度的测试，来获取一组最佳的调优参数值。&lt;/p&gt;

&lt;p&gt;这篇博客就和大家分享到这里，如果大家在研究学习的过程当中有什么问题，可以加群进行讨论或发送邮件给我，我会尽我所能为您解答，与君共勉！&lt;/p&gt;
&lt;p&gt;另外，博主出书了《&lt;a href=&quot;https://item.jd.com/12455361.html&quot; target=&quot;_blank&quot;&gt;Kafka并不难学&lt;/a&gt;》，喜欢的朋友或同学， 可以在公告栏那里点击购买链接购买博主的书进行学习，在此感谢大家的支持。 &lt;/p&gt;
</description>
<pubDate>Sun, 09 Dec 2018 14:37:00 +0000</pubDate>
<dc:creator>哥不是小萝莉</dc:creator>
<og:description>1.概述 在分布式实时数据流场景下，随着数据量的增长，对Kafka集群的性能和稳定性的要求也很高。本篇博客将从生产者和消费者两方面来做性能测试，针对具体的业务和数据量，来调优Kafka集群。 2.内容</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/smartloli/p/10093838.html</dc:identifier>
</item>
</channel>
</rss>