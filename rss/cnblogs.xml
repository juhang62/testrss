<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>洛谷 P1045 麦森数 - 尹昱钦</title>
<link>http://www.cnblogs.com/yinyuqin/p/10463850.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/yinyuqin/p/10463850.html</guid>
<description>&lt;pre&gt;
&lt;span&gt; 1&lt;/span&gt; #include&amp;lt;iostream&amp;gt;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;快速幂：2的p次方=（2的平方）的p/2次方 = （（2的平方）的平方）的 p/2/2次方...... &lt;/span&gt;
&lt;span&gt; 2&lt;/span&gt; #include&amp;lt;cstdio&amp;gt;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       f存的就是底数——2,2的2次方，2的二次方的二次方...... &lt;/span&gt;
&lt;span&gt; 3&lt;/span&gt; #include&amp;lt;cmath&amp;gt;                        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;       res 存的就是最后的答案 &lt;/span&gt;
&lt;span&gt; 4&lt;/span&gt; #include&amp;lt;cstring&amp;gt;                    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;        sav是每一次高精度乘法的临时数组 &lt;/span&gt;
&lt;span&gt; 5&lt;/span&gt; &lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt; 6&lt;/span&gt; &lt;span&gt;int&lt;/span&gt; p,f[&lt;span&gt;510&lt;/span&gt;],res[&lt;span&gt;510&lt;/span&gt;],sav[&lt;span&gt;510&lt;/span&gt;];                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;数组开500多一点已足够 &lt;/span&gt;
&lt;span&gt; 7&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rr1() {                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;rr1是将答案更新，乘上现在的底数 &lt;/span&gt;
&lt;span&gt; 8&lt;/span&gt;     memset(sav,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(sav));                 
&lt;/span&gt;&lt;span&gt; 9&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i &amp;lt;= &lt;span&gt;500&lt;/span&gt;; i++)            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;动手画一下 ，列一个竖式，就会发现[i]*[j]得到的数字其实是[i+j-1]位上的数字 &lt;/span&gt;
&lt;span&gt;10&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;;j &amp;lt;= &lt;span&gt;500&lt;/span&gt;; j++)        &lt;span&gt;//&lt;/span&gt;&lt;span&gt;这里只是乘，还没有进位 &lt;/span&gt;
&lt;span&gt;11&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(i+j&amp;lt;=&lt;span&gt;505&lt;/span&gt;) sav[i+j-&lt;span&gt;1&lt;/span&gt;] += res[i] *&lt;span&gt; f[j];
&lt;/span&gt;&lt;span&gt;12&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i &amp;lt;= &lt;span&gt;500&lt;/span&gt;; i++) {             &lt;span&gt;//&lt;/span&gt;&lt;span&gt;进位 &lt;/span&gt;
&lt;span&gt;13&lt;/span&gt;         sav[i+&lt;span&gt;1&lt;/span&gt;] += sav[i] / &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;14&lt;/span&gt;         sav[i] %= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;15&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;16&lt;/span&gt;     memcpy(res,sav,&lt;span&gt;sizeof&lt;/span&gt;(res));            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;把求出来的数组sav更新到res中 &lt;/span&gt;
&lt;span&gt;17&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;18&lt;/span&gt; &lt;span&gt;void&lt;/span&gt; rr2() {                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;rr2求得是底数的平方的值，存在f中 &lt;/span&gt;
&lt;span&gt;19&lt;/span&gt;     memset(sav,&lt;span&gt;0&lt;/span&gt;,&lt;span&gt;sizeof&lt;/span&gt;(sav));                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;同上 &lt;/span&gt;
&lt;span&gt;20&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i &amp;lt;= &lt;span&gt;500&lt;/span&gt;; i++&lt;span&gt;) 
&lt;/span&gt;&lt;span&gt;21&lt;/span&gt;         &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; j = &lt;span&gt;1&lt;/span&gt;;j &amp;lt;= &lt;span&gt;500&lt;/span&gt;; j++&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;22&lt;/span&gt;             &lt;span&gt;if&lt;/span&gt;(i+j&amp;lt;=&lt;span&gt;505&lt;/span&gt;)sav[i+j-&lt;span&gt;1&lt;/span&gt;] += f[i] *&lt;span&gt; f[j];
&lt;/span&gt;&lt;span&gt;23&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;1&lt;/span&gt;;i &amp;lt;= &lt;span&gt;500&lt;/span&gt;; i++&lt;span&gt;) { 
&lt;/span&gt;&lt;span&gt;24&lt;/span&gt;         sav[i+&lt;span&gt;1&lt;/span&gt;] += sav[i] / &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;25&lt;/span&gt;         sav[i] %= &lt;span&gt;10&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;26&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;27&lt;/span&gt;     memcpy(f,sav,&lt;span&gt;sizeof&lt;/span&gt;&lt;span&gt;(f));                
&lt;/span&gt;&lt;span&gt;28&lt;/span&gt; &lt;span&gt;}
&lt;/span&gt;&lt;span&gt;29&lt;/span&gt; &lt;span&gt;int&lt;/span&gt;&lt;span&gt; main() {
&lt;/span&gt;&lt;span&gt;30&lt;/span&gt;     scanf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;&lt;span&gt;p);
&lt;/span&gt;&lt;span&gt;31&lt;/span&gt;     printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d\n&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,(&lt;span&gt;int&lt;/span&gt;)(log10(&lt;span&gt;2&lt;/span&gt;) * p + &lt;span&gt;1&lt;/span&gt;));    &lt;span&gt;//&lt;/span&gt;&lt;span&gt;先输出位数 &lt;/span&gt;
&lt;span&gt;32&lt;/span&gt;     res[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;33&lt;/span&gt;     f[&lt;span&gt;1&lt;/span&gt;] = &lt;span&gt;2&lt;/span&gt;;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;初始化要为2，否则会一直乘1 &lt;/span&gt;
&lt;span&gt;34&lt;/span&gt;     &lt;span&gt;while&lt;/span&gt;(p != &lt;span&gt;0&lt;/span&gt;) {                            &lt;span&gt;//&lt;/span&gt;&lt;span&gt;快速幂 &lt;/span&gt;
&lt;span&gt;35&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(p % &lt;span&gt;2&lt;/span&gt; == &lt;span&gt;1&lt;/span&gt;) rr1();                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;任何一个数一直/2最后一定是1，这样就能确保更新答案 &lt;/span&gt;
&lt;span&gt;36&lt;/span&gt;         p /= &lt;span&gt;2&lt;/span&gt;;                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;rr1,rr2为高精度乘法&lt;/span&gt;
&lt;span&gt;37&lt;/span&gt;         rr2();                                &lt;span&gt;//&lt;/span&gt;&lt;span&gt;每一次都更新一遍f，也就是底数的平方 &lt;/span&gt;
&lt;span&gt;38&lt;/span&gt; &lt;span&gt;    }
&lt;/span&gt;&lt;span&gt;39&lt;/span&gt;     res[&lt;span&gt;1&lt;/span&gt;] -= &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;40&lt;/span&gt;     &lt;span&gt;for&lt;/span&gt;(&lt;span&gt;int&lt;/span&gt; i = &lt;span&gt;500&lt;/span&gt;;i &amp;gt;= &lt;span&gt;1&lt;/span&gt;; i--&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;41&lt;/span&gt;         &lt;span&gt;if&lt;/span&gt;(i != &lt;span&gt;500&lt;/span&gt; &amp;amp;&amp;amp; i % &lt;span&gt;50&lt;/span&gt; == &lt;span&gt;0&lt;/span&gt;) printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\n%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,res[i]); &lt;span&gt;//&lt;/span&gt;&lt;span&gt;注意输出格式。 &lt;/span&gt;
&lt;span&gt;42&lt;/span&gt;         &lt;span&gt;else&lt;/span&gt; printf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,res[i]);
&lt;/span&gt;&lt;span&gt;43&lt;/span&gt;     &lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
&lt;/span&gt;&lt;span&gt;44&lt;/span&gt; }
&lt;/pre&gt;</description>
<pubDate>Sat, 02 Mar 2019 17:42:00 +0000</pubDate>
<dc:creator>尹昱钦</dc:creator>
<og:description>题目链接：https://www.luogu.org/problemnew/show/P1045 题目意思：本题目的主要意思就是给定一个p，求2p-1的位数和后500位数。 解题思路： 首先看一下数据</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/yinyuqin/p/10463850.html</dc:identifier>
</item>
<item>
<title>Spring BPP中优雅的创建动态代理Bean - 小眼儿</title>
<link>http://www.cnblogs.com/hujunzheng/p/10463798.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/hujunzheng/p/10463798.html</guid>
<description>&lt;h2&gt;一、前言&lt;/h2&gt;
&lt;p&gt;　　本文章所讲并没有基于Aspectj，而是直接通过Cglib以及ProxyFactoryBean去创建代理Bean。通过下面的例子，可以看出Cglib方式创建的代理Bean和ProxyFactoryBean创建的代理Bean的区别。&lt;/p&gt;
&lt;h2&gt;二、基本测试代码&lt;/h2&gt;
&lt;p&gt;　　测试实体类，在BPP中创建BppTestDepBean类型的代理Bean。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BppTestBean {
    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BppTestDepBean depBean;

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test1() {
        depBean.testDep();
    }

    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test2() {
        depBean.testDep();
    }

    @TestMethod
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test3() {
        depBean.testDep();
    }
}

@Component
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BppTestDepBean {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testDep() {
        System.out.println(&lt;/span&gt;&quot;HEHE&quot;&lt;span&gt;);
    }
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; @&lt;span&gt;interface&lt;/span&gt;&lt;span&gt; TestMethod {
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　测试类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
@RunWith(SpringRunner.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)
@SpringBootTest
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; BppTest {

    @Autowired
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; BppTestBean bppTestBean;

    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; test() {
        bppTestBean.test1();
        bppTestBean.test2();
        bppTestBean.test3();
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;三、使用Cglib创建代理Bean&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxyBpp1 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanPostProcessor {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(ProxyBpp1.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessBeforeInitialization(Object bean, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bean &lt;span&gt;instanceof&lt;/span&gt;&lt;span&gt; BppTestBean) {
            Enhancer enhancer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
            enhancer.setSuperclass(bean.getClass());
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标识Spring-generated proxies&lt;/span&gt;
            enhancer.setInterfaces(&lt;span&gt;new&lt;/span&gt; Class[]{SpringProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;});
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置增强&lt;/span&gt;
            enhancer.setCallback((MethodInterceptor) (target, method, args, methodProxy) -&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;test1&quot;&lt;span&gt;.equals(method.getName())) {
                    LOGGER.info(&lt;/span&gt;&quot;ProxyBpp1 开始执行...&quot;&lt;span&gt;);
                    Object result &lt;/span&gt;=&lt;span&gt; methodProxy.invokeSuper(target, args);
                    LOGGER.info(&lt;/span&gt;&quot;ProxyBpp1 结束执行...&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; method.invoke(target, args);
            });

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; enhancer.create();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　主要是代理 BppTestBean的test1方法。其实这种方式创建的代理Bean使用问题的，@Autowired字段没有注入进来，所以会有出现NPE。methodProxy.invokeSuper(target, args)，这一行代码是有问题的，targe是代理类对象，而真实的对象是postProcessBeforeInitialization(Object bean, String beanName) 中的bean对象，此时bean对象@Autowired字段已经注入了。所以可以将methodProxy.invokeSuper(target, args) 修改为method.invoke(bean, args)解决无法注入@Autowired字段的问题。&lt;/p&gt;
&lt;h2&gt;四、使用ProxyFactoryBean创建代理Bean&lt;/h2&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxyBpp2 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; BeanPostProcessor {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(ProxyBpp2.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessBeforeInitialization(Object bean, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (bean &lt;span&gt;instanceof &lt;/span&gt;&lt;span&gt;BppTestBean) {
            ProxyFactoryBean pfb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProxyFactoryBean();
            pfb.setTarget(bean);
            pfb.setAutodetectInterfaces(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            NameMatchMethodPointcutAdvisor advisor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NameMatchMethodPointcutAdvisor();
            advisor.addMethodName(&lt;/span&gt;&quot;test1&quot;&lt;span&gt;);
            advisor.setAdvice((MethodInterceptor) invocation &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                LOGGER.info(&lt;/span&gt;&quot;ProxyBpp2 开始执行...&quot;&lt;span&gt;);
                Object result &lt;/span&gt;=&lt;span&gt; invocation.getMethod().invoke(invocation.getThis(), invocation.getArguments());
                LOGGER.info(&lt;/span&gt;&quot;ProxyBpp2 结束执行...&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            });
            pfb.addAdvisor(advisor);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pfb.getObject();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; bean;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　　使用ProxyFactoryBean创建代理Bean的时候，一定要一个targe对象的。Advisor在切入的时候，会逐个执行Advice。invocation.getThis()就是在通过ProxyFactoryBean创建代理Bean的时候传入的target对象。由于target对象就是postProcessBeforeInitialization(Object bean, String beanName) 中的bean对象，所以@Autowired字段也已经注入进来了。&lt;/p&gt;
&lt;h2&gt;五、@Autowired注解何时被处理&lt;/h2&gt;
&lt;p&gt;　　想必大家都知道@Autowired字段的处理也是通过一个BPP，不过这个BPP比我们平常使用的要高级一些，它就是InstantiationAwareBeanPostProcessor。这个BPP可以实现Bean的创建、属性的注入和解析（比如@Autowired、@Value、@Resource等等），大家可以参考一下CommonAnnotationBeanPostProcessor（处理JSR-250相关注解），AutowiredAnnotationBeanPostProcessor（处理@Autowired、@Value、@Inject相关注解）。&lt;/p&gt;
&lt;p&gt;　　InstantiationAwareBeanPostProcessor中有一个如下的方法，AutowiredAnnotationBeanPostProcessor就是覆盖这个方法实现了带有相关注解属性的自动注入。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Nullable
&lt;/span&gt;&lt;span&gt;default&lt;/span&gt;&lt;span&gt; PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName)
        &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {

    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;43&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Override
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt; PropertyValues postProcessProperties(PropertyValues pvs, Object bean, String beanName) {
    InjectionMetadata metadata &lt;/span&gt;=&lt;span&gt; findAutowiringMetadata(beanName, bean.getClass(), pvs);
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;span&gt;&lt;strong&gt;metadata.inject(bean, beanName, pvs);&lt;/strong&gt;&lt;/span&gt;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (BeanCreationException ex) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt;&lt;span&gt; ex;
    }
    &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Throwable ex) {
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt; BeanCreationException(beanName, &quot;Injection of autowired dependencies failed&quot;&lt;span&gt;, ex);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pvs;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　InstantiationAwareBeanPostProcessor的postProcessProperties方法实在Spring AbstractAutowireCapableBeanFactory的populateBean方法中被调用。在AbstractAutowireCapableBeanFactory的doCreateBan中有如下代码。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Initialize the bean instance.&lt;/span&gt;
Object exposedObject =&lt;span&gt; bean;#
&lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
    populateBean(beanName, mbd, instanceWrapper);
    exposedObject &lt;/span&gt;=&lt;span&gt; initializeBean(beanName, exposedObject, mbd);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　也就是先进行了Bean的属性填充，然后进行Bean的初始化工作。initializeBean方法中主要做了四件事。&lt;/p&gt;
&lt;p&gt;　　1、invokeAwareMethods&lt;br/&gt;　　2、applyBeanPostProcessorsBeforeInitialization&lt;br/&gt;　　3、invokeInitMethods&lt;br/&gt;　　4、applyBeanPostProcessorsAfterInitialization&lt;/p&gt;
&lt;p&gt;　　其中2和4就是分别调用的普通的BPP中的postProcessBeforeInitialization方法和postProcessAfterInitialization方法。&lt;/p&gt;
&lt;p&gt;　　这就是为什么在BPP中创建代理Bean的时候，对应的目标Bean相关的@Autowired字段已经注入的原因了。&lt;/p&gt;
&lt;h2&gt;六、InstantiationAwareBeanPostProcessor方式创建动态代理Bean&lt;/h2&gt;
&lt;p&gt;　　InstantiationAwareBeanPostProcessor接口中有个postProcessBeforeInstantiation方法，可以让我们自己去实例化Bean。通过查看AbstractAutowireCapableBeanFactory，方法调用：createBean方法 -&amp;gt; resolveBeforeInstantiation方法 -&amp;gt; applyBeanPostProcessorsBeforeInstantiation方法 -&amp;gt;InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation方法，如果最终返回一个非null的实例，那么就不会再执行doCreateBean方法。这就意味着不会有Bean属性的填充和初始化的流程了，但是可以借助AbstractAutowireCapableBeanFactory帮助我们实现。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &amp;lt;T&amp;gt;&lt;span&gt; T postProcess(T object) {
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (object == &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    T result;
    &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用容器autowireBeanFactory标准依赖注入方法autowireBean()处理 object对象的依赖注入&lt;/span&gt;
        &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.autowireBeanFactory.autowireBean(object);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 使用容器autowireBeanFactory标准初始化方法initializeBean()初始化对象 object&lt;/span&gt;
        result = (T) &lt;span&gt;this&lt;/span&gt;&lt;span&gt;.autowireBeanFactory.initializeBean(object,
                object.toString());
    } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (RuntimeException e) {
        Class&lt;/span&gt;&amp;lt;?&amp;gt; type =&lt;span&gt; object.getClass();
        &lt;/span&gt;&lt;span&gt;throw&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; RuntimeException(
                &lt;/span&gt;&quot;Could not postProcess &quot; + object + &quot; of type &quot; +&lt;span&gt; type, e);
    }
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上图代码，可以帮组我们实现非Spring容器Bean自动注入和初始化的功能。使用过Spring security同学都知道，内部也是用了这个方式解决对象中的属性注入问题。如果你阅读了Spring security的源码，你会发现很多对象，比如WebSecurity、ProviderManager、各个安全Filter等，这些对象的创建并不是通过bean定义的形式被容器发现和注册进入spring容器的，而是直接new出来的。Spring security提供的AutowireBeanFactoryObjectPostProcessor这个工具类可以使这些对象具有容器bean同样的生命周期，也能注入相应的依赖，从而进入准备好被使用的状态。&lt;/p&gt;
&lt;p&gt;　　使用Cglib在InstantiationAwareBeanPostProcessor 中创建动态代理Bean。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxyBpp3 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InstantiationAwareBeanPostProcessor {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(ProxyBpp3.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; AutowireCapableBeanFactory autowireBeanFactory;

    ProxyBpp3(AutowireCapableBeanFactory autowireBeanFactory) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.autowireBeanFactory =&lt;span&gt; autowireBeanFactory;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (beanClass.equals(BppConfig.BppTestBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
            Enhancer enhancer &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Enhancer();
            enhancer.setSuperclass(beanClass);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;标识Spring-generated proxies&lt;/span&gt;
            enhancer.setInterfaces(&lt;span&gt;new&lt;/span&gt; Class[]{SpringProxy.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;});
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;设置增强&lt;/span&gt;
            enhancer.setCallback((MethodInterceptor) (target, method, args, methodProxy) -&amp;gt;&lt;span&gt; {
                &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (&quot;test1&quot;&lt;span&gt;.equals(method.getName())) {
                    LOGGER.info(&lt;/span&gt;&quot;ProxyBpp3 开始执行...&quot;&lt;span&gt;);
                    Object result &lt;/span&gt;=&lt;span&gt; methodProxy.invokeSuper(target, args);
                    LOGGER.info(&lt;/span&gt;&quot;ProxyBpp3 结束执行...&quot;&lt;span&gt;);
                    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
                }
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; methodProxy.invokeSuper(target, args);
            });

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.postProcess(enhancer.create());&lt;/span&gt;
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }

    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　使用ProxyFactoryBean在InstantiationAwareBeanPostProcessor 中创建动态代理Bean。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt; ProxyBpp4 &lt;span&gt;implements&lt;/span&gt;&lt;span&gt; InstantiationAwareBeanPostProcessor {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;final&lt;/span&gt; Logger LOGGER = LoggerFactory.getLogger(ProxyBpp4.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);

    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;final&lt;/span&gt;&lt;span&gt; AutowireCapableBeanFactory autowireBeanFactory;

    ProxyBpp4(AutowireCapableBeanFactory autowireBeanFactory) {
        &lt;/span&gt;&lt;span&gt;this&lt;/span&gt;.autowireBeanFactory =&lt;span&gt; autowireBeanFactory;
    }

    @Override
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; Object postProcessBeforeInstantiation(Class&amp;lt;?&amp;gt; beanClass, String beanName) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; BeansException {
        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (beanClass.equals(BppConfig.BppTestBean.&lt;span&gt;class&lt;/span&gt;&lt;span&gt;)) {
            ProxyFactoryBean pfb &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; ProxyFactoryBean();
            pfb.setTarget(&lt;/span&gt;&lt;span&gt;this&lt;/span&gt;&lt;span&gt;&lt;span&gt;.postProcess(BeanUtils.instantiateClass(beanClass))&lt;/span&gt;);
            pfb.setAutodetectInterfaces(&lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;);
            NameMatchMethodPointcutAdvisor advisor &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; NameMatchMethodPointcutAdvisor();
            advisor.addMethodName(&lt;/span&gt;&quot;test1&quot;&lt;span&gt;);
            advisor.setAdvice((MethodInterceptor) invocation &lt;/span&gt;-&amp;gt;&lt;span&gt; {
                LOGGER.info(&lt;/span&gt;&quot;ProxyBpp4 开始执行...&quot;&lt;span&gt;);
                Object result &lt;/span&gt;=&lt;span&gt; invocation.getMethod().invoke(invocation.getThis(), invocation.getArguments());
                LOGGER.info(&lt;/span&gt;&quot;ProxyBpp4 结束执行...&quot;&lt;span&gt;);
                &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; result;
            });
            pfb.addAdvisor(advisor);

            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; pfb.getObject();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
    }
    ...
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　上述向两种方式，注意，实例化bean后主动通过postProcess方法借助AbstractAutowireCapableBeanFactory完成对象相关属性的注入以及对象的初始化流程。&lt;/p&gt;
&lt;h2&gt;七、源码分享&lt;/h2&gt;
&lt;p&gt;　　&lt;span&gt;&lt;a href=&quot;https://github.com/hjzgg/springbootdemo/tree/master/src/main/java/com/hjzgg/example/springboot/bpp&quot; target=&quot;_blank&quot;&gt;点我查看源码&lt;/a&gt;，如果有任何疑问请关注公众号后进行咨询。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 02 Mar 2019 16:50:00 +0000</pubDate>
<dc:creator>小眼儿</dc:creator>
<og:description>一、前言 本文章所讲并没有基于Aspectj，而是直接通过Cglib以及ProxyFactoryBean去创建代理Bean。通过下面的例子，可以看出Cglib方式创建的代理Bean和ProxyFact</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/hujunzheng/p/10463798.html</dc:identifier>
</item>
<item>
<title>Django的rest_framework的视图之Mixin类编写视图源码解析 - bainianminguo</title>
<link>http://www.cnblogs.com/bainianminguo/p/10463741.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/bainianminguo/p/10463741.html</guid>
<description>&lt;h2&gt; &lt;/h2&gt;
&lt;h2&gt;Mixin类编写视图&lt;/h2&gt;
&lt;p&gt;我们这里用auther表来做演示，先为auther和autherdetail写2个url&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    url(r'^autherdetail/(?P&amp;lt;id&amp;gt;\d+)', views.Book_detail_cbv.as_view(), name=&quot;autherdetail&quot;),
    url(r'^auther/', views.Book_cbv.as_view(),name=&quot;auther&quot;),　　
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后分别为这2个类写对应的序列化的类&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;33&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class authermodelserializer(serializers.ModelSerializer):
    class Meta:
        model = models.Auther
        fields = &quot;__all__&quot;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面我们开写视图函数　　&lt;/p&gt;
&lt;p&gt;需要在view文件中导入2个模块&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;32&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
from rest_framework import mixins
from rest_framework import generics
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;先介绍一下mixins类，我们主要用mixins类来对queryset对象或者model对象做操作&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;35&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
mixins.ListModelMixin

这个是用来显示queryset的数据

mixins.CreateModelMixin

这个用来创建一条model对象

mixins.RetrieveModelMixin

这个是用来显示一个model对象

mixins.DestroyModelMixin

这个是用来删除一个model对象

mixins.UpdateModelMixin

这个是用来更新一个model对象
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面我们一个一个来看下面的类&lt;/p&gt;
&lt;h3&gt;1、看下mixins.ListModelMixin&lt;/h3&gt;
&lt;p&gt;这个类就只有一个方法，list方法，我们看下面的代码其实很熟悉，就是把一个queryset对象做序列化后，然后把序列化后的结果返回&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class ListModelMixin(object):
    &quot;&quot;&quot;
    List a queryset.
    &quot;&quot;&quot;
    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们这里看到get_serializer中的参数有个queryset，那么这个queryset是什么呢？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190302234001219-1440148465.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 通过上面的图，我们大致可以猜到，是由self.get_queryset()这个方法返回的结果，那么这个方法又干了什么呢？&lt;/p&gt;
&lt;p&gt;首先我们要清楚self是什么？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190302234212696-1866293437.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 从上面的图我们知道，self其实就是Auther_view这个类的实例对象，这个实例对象根本就没有get_queryset这个方法，但是由于这个类继承了3个类，我们一个一个找，最终在&lt;/p&gt;
&lt;p&gt;generics.GenericAPIView这个类中找到了get_queryset这个方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;41&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def get_queryset(self):
        &quot;&quot;&quot;
        Get the list of items for this view.
        This must be an iterable, and may be a queryset.
        Defaults to using `self.queryset`.

        This method should always be used rather than accessing `self.queryset`
        directly, as `self.queryset` gets evaluated only once, and those results
        are cached for all subsequent requests.

        You may want to override this if you need to provide different
        querysets depending on the incoming request.

        (Eg. return a list of items that is specific to the user)
        &quot;&quot;&quot;
        assert self.queryset is not None, (
            &quot;'%s' should either include a `queryset` attribute, &quot;
            &quot;or override the `get_queryset()` method.&quot;
            % self.__class__.__name__
        )

        queryset = self.queryset
        if isinstance(queryset, QuerySet):
            # Ensure queryset is re-evaluated on each request.
            queryset = queryset.all()
        return queryset
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们可以很清晰的看到get_queryset这个方法返回的结果就是self.queryset&lt;/p&gt;
&lt;p&gt;那么self.queryset这个是什么呢？&lt;/p&gt;
&lt;p&gt;我们在Auhter_view这个类中已经定义了这个类变量，所以我们这里定义的2个类变量的名称是固定的，不能随意修改的，属于配置项&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190302234557200-584813489.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 下面我们走的流程就和之前差不多了&lt;/p&gt;
&lt;p&gt;先定义get请求的处理的函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190302234720736-1059922910.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;因为mixins.ListModelMixin这个类是为了显示queryset对象的类，那么下面我们进入这个类&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190302234831804-1790269560.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 所以我们在get方法中，直接调用list方法的返回结果就是我们想要的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190302234927098-176385921.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;2、在来看mixin.CreateModelMixin类&lt;/h3&gt;
&lt;p&gt;这个类是为了创建一个model对象&lt;/p&gt;
&lt;p&gt;首先进入这个类，看下具体的代码&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;43&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class CreateModelMixin(object):
    &quot;&quot;&quot;
    Create a model instance.
    &quot;&quot;&quot;
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)

    def perform_create(self, serializer):
        serializer.save()

    def get_success_headers(self, data):
        try:
            return {'Location': str(data[api_settings.URL_FIELD_NAME])}
        except (TypeError, KeyError):
            return {}
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;下面我们来分析一下代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190302235440051-1863884350.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先这里有个self.get_serializer方法，这个方法也在generics.GenericAPIView类中&lt;/p&gt;
&lt;p&gt;下面我们在来看下get_serializer方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;39&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def get_serializer(self, *args, **kwargs):
        &quot;&quot;&quot;
        Return the serializer instance that should be used for validating and
        deserializing input, and for serializing output.
        &quot;&quot;&quot;
        serializer_class = self.get_serializer_class()
        kwargs['context'] = self.get_serializer_context()
        return serializer_class(*args, **kwargs)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190302235723790-721692398.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们在来看下get_serializer_class这个方法&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190302235823675-190218940.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 我们看到非常清楚，这个函数的返回值就是我们先前定义个serializer_class的类变量，所以这个类变量的名称也不能修改，必须要这么写，属于一个配置类的变量&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190302235913196-177795380.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 流程我们已经梳理清楚了，下面我们在看下post请求的视图函数&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190303000037203-1790265593.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; post请求调用的mixins.CreateModelMixin类中的create方法&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class CreateModelMixin(object):
    &quot;&quot;&quot;
    Create a model instance.
    &quot;&quot;&quot;
    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190303000216570-1815811015.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; 最后我们在看下perform.create这个方法，是不是很熟悉了，调用save方法保存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190303000256141-257019002.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 3、然后来看下mixins.RetriveModelMixin类&lt;/h3&gt;
&lt;p&gt;先看下这个类的代码&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;37&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class RetrieveModelMixin(object):
    &quot;&quot;&quot;
    Retrieve a model instance.
    &quot;&quot;&quot;
    def retrieve(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance)
        return Response(serializer.data)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后在来看下get_object这个方法干了什么，这个方法同样在generics.GenericAPIView类中，我们一猜就知道这个方法是获取一个model对象，然后对这个model对象进行序列化处理&lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;40&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
    def get_object(self):
        &quot;&quot;&quot;
        Returns the object the view is displaying.

        You may want to override this if you need to provide non-standard
        queryset lookups.  Eg if objects are referenced using multiple
        keyword arguments in the url conf.
        &quot;&quot;&quot;
        queryset = self.filter_queryset(self.get_queryset())

        # Perform the lookup filtering.
        lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field

        assert lookup_url_kwarg in self.kwargs, (
            'Expected view %s to be called with a URL keyword argument '
            'named &quot;%s&quot;. Fix your URL conf, or set the `.lookup_field` '
            'attribute on the view correctly.' %
            (self.__class__.__name__, lookup_url_kwarg)
        )

        filter_kwargs = {self.lookup_field: self.kwargs[lookup_url_kwarg]}
        obj = get_object_or_404(queryset, **filter_kwargs)

        # May raise a permission denied
        self.check_object_permissions(self.request, obj)

        return obj
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;我们看到这个方法确实返回一个obj对象&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190303001632225-1907779267.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190303001658677-62384195.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;



&lt;p&gt;最后看下get请求，调用mixins。RetrieveModelMixin类中的retieve方法返回我们要查询的结果&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190303000901058-257200884.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h3&gt; 4、然后我们在看下mixins.DestroyModelMixin类&lt;/h3&gt;
&lt;p&gt; 直接拿到model独享，然后调用perform_destory方法删除这个model对象&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;38&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class DestroyModelMixin(object):
    &quot;&quot;&quot;
    Destroy a model instance.
    &quot;&quot;&quot;
    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        self.perform_destroy(instance)
        return Response(status=status.HTTP_204_NO_CONTENT)

    def perform_destroy(self, instance):
        instance.delete()
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;然后我们在看下视图函数中是如何处理delete请求的&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;48&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Autherdetail_view(mixins.RetrieveModelMixin,mixins.DestroyModelMixin,mixins.UpdateModelMixin,generics.GenericAPIView):
    queryset = models.Auther.objects.all()
    serializer_class = authermodelserializer

    def get(self,request,*args,**kwargs):
        return self.retrieve(request,*args,**kwargs)

    def delete(self,request,*args,**kwargs):
        return self.destroy(request,*args,**kwargs)
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;直接返回mixins.DestoryModelMixins的detory函数的返回值就可以了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190303001924611-1815946322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;h3&gt;5、最后看下mixins.UpdateModelMixin类&lt;/h3&gt;
&lt;p&gt;同样，先获取model对象，然后获取序列化类，然后把model对象和request.data一起传递给序列化类&lt;/p&gt;
&lt;p&gt;序列化类在调用调用sava方法保存数据 &lt;/p&gt;

&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;50&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class UpdateModelMixin(object):
    &quot;&quot;&quot;
    Update a model instance.
    &quot;&quot;&quot;
    def update(self, request, *args, **kwargs):
        partial = kwargs.pop('partial', False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data, partial=partial)
        serializer.is_valid(raise_exception=True)
        self.perform_update(serializer)

        if getattr(instance, '_prefetched_objects_cache', None):
            # If 'prefetch_related' has been applied to a queryset, we need to
            # forcibly invalidate the prefetch cache on the instance.
            instance._prefetched_objects_cache = {}

        return Response(serializer.data)

    def perform_update(self, serializer):
        serializer.save()

    def partial_update(self, request, *args, **kwargs):
        kwargs['partial'] = True
        return self.update(request, *args, **kwargs)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190303002357440-1871481415.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;我们在看put请求的视图函数&lt;/p&gt;
&lt;div class=&quot;cnblogs_Highlighter&quot; readability=&quot;53&quot;&gt;
&lt;pre class=&quot;brush:python;gutter:true;&quot;&gt;
class Autherdetail_view(mixins.RetrieveModelMixin,mixins.DestroyModelMixin,mixins.UpdateModelMixin,generics.GenericAPIView):
    queryset = models.Auther.objects.all()
    serializer_class = authermodelserializer

    def get(self,request,*args,**kwargs):
        return self.retrieve(request,*args,**kwargs)

    def delete(self,request,*args,**kwargs):
        return self.destroy(request,*args,**kwargs)

    def put(self,request,*args,**kwargs):
        return self.update(request,*args,**kwargs)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1101486/201903/1101486-20190303002437944-2104346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;





















</description>
<pubDate>Sat, 02 Mar 2019 16:25:00 +0000</pubDate>
<dc:creator>bainianminguo</dc:creator>
<og:description>Mixin类编写视图 我们这里用auther表来做演示，先为auther和autherdetail写2个url 然后分别为这2个类写对应的序列化的类 下面我们开写视图函数 需要在view文件中导入2个</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/bainianminguo/p/10463741.html</dc:identifier>
</item>
<item>
<title>大数据技术之_09_Hive学习_复习与总结 - 黑泽君</title>
<link>http://www.cnblogs.com/chenmingjun/p/10463713.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/chenmingjun/p/10463713.html</guid>
<description>&lt;p id=&quot;tocid_0&quot; class=&quot;toc&quot;&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h&quot;&gt;一、知识梳理&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h11&quot;&gt;1.1、背景表结构&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h111orderby&quot;&gt;1.1.1、order by&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h112sortby&quot;&gt;1.1.2、sort by&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h113distributeby&quot;&gt;1.1.3、distribute by&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h114clusterby&quot;&gt;1.1.4、cluster by&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h12udafudtf&quot;&gt;1.2、行转列、列转行（UDAF 与 UDTF）&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h121&quot;&gt;1.2.1、行转列&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h122&quot;&gt;1.2.2、列转行&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h13&quot;&gt;1.3、建表时的数组操作&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h14orc&quot;&gt;1.4、orc 存储&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h15hive&quot;&gt;1.5、Hive 分桶&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h151&quot;&gt;1.5.1、直接分桶&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h152&quot;&gt;1.5.2、在分区中分桶&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h-1&quot;&gt;二、总结&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h21hadoopzookeeper&quot;&gt;2.1 启动/停止hadoop集群、zookeeper集群、历史服务器&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h22hive&quot;&gt;2.2 访问hive的两种方式&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h23centos6xcenos7x&quot;&gt;2.3 CentOS6x与Cenos7x命令的区别&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h24&quot;&gt;2.4 大数据开发中重用的两种数据格式&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h25udfudafudtf&quot;&gt;2.5 UDF、UDAF、UDTF&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&quot;toc_item&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;span class=&quot;toc_left&quot;&gt;&lt;a href=&quot;http://www.cnblogs.com/chenmingjun/p/10463713.html#h26&quot;&gt;2.6 小知识总结&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;hr/&gt;&lt;h2 id=&quot;h&quot;&gt;&lt;span&gt;&lt;strong&gt;一、知识梳理&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h11&quot;&gt;&lt;span&gt;&lt;strong&gt;1.1、背景表结构&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;在讲解中我们需要贯串一个例子，所以需要设计一个情景，对应还要有一个表结构和填充数据。如下：有 3 个字段，分别为 personId 标识某一个人，company 标识一家公司名称，money 标识该公司每年盈利收入（单位：万元人民币）&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/03/kqamJx.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;建表并导入数据：
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;sql language-sql hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; company_info(&lt;br/&gt;personId &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;, &lt;br/&gt;company &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;,&lt;br/&gt;money &lt;span class=&quot;hljs-built_in&quot;&gt;float&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;delimited&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;fields&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;terminated&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\t&quot;&lt;/span&gt;;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; inpath &lt;span class=&quot;hljs-string&quot;&gt;'/opt/module/datas/company_info.txt'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; company_info;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h111orderby&quot;&gt;&lt;span&gt;&lt;strong&gt;1.1.1、order by&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  hive 中的 order by 语句会对查询结果做一次&lt;code&gt;全局排序&lt;/code&gt;，即，所有的 mapper 产生的结果都会交给一个 reducer 去处理，无论数据量大小，job 任务只会启动一个 reducer，如果数据量巨大，则会耗费大量的时间。&lt;br/&gt;  &lt;code&gt;尖叫提示&lt;/code&gt;：如果在严格模式下，order by 需要指定 limit 数据条数，不然数据量巨大的情况下会造成崩溃无输出结果。涉及属性：set hive.mapred.mode=nonstrict/strict&lt;br/&gt;  例如：按照 money 排序的例子&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; company_info &lt;span class=&quot;hljs-keyword&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; money &lt;span class=&quot;hljs-keyword&quot;&gt;desc&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h112sortby&quot;&gt;&lt;span&gt;&lt;strong&gt;1.1.2、sort by&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  hive 中的 sort by 语句会对每一块局部数据进行&lt;code&gt;局部排序&lt;/code&gt;，即每一个 reducer 处理的数据都是有序的，但是不能保证全局有序。&lt;/p&gt;
&lt;h4 id=&quot;h113distributeby&quot;&gt;&lt;span&gt;&lt;strong&gt;1.1.3、distribute by&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  hive 中的 distribute by 一般要和 sort by 一起使用，即将某一块数据归给(distribute by)某一个 reducer 处理，然后在指定的 reducer 中进行 sort by 排序。&lt;br/&gt;  &lt;code&gt;尖叫提示&lt;/code&gt;：distribute by 必须写在 sort by 之前。&lt;br/&gt;  &lt;code&gt;尖叫提示&lt;/code&gt;：涉及属性 mapreduce.job.reduces，hive.exec.reducers.bytes.per.reducer&lt;br/&gt;  例如：不同的人（personId）分为不同的组，每组按照 money 排序。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; company_info &lt;span class=&quot;hljs-keyword&quot;&gt;distribute&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; personId &lt;span class=&quot;hljs-keyword&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; personId &lt;span class=&quot;hljs-keyword&quot;&gt;asc&lt;/span&gt;, money &lt;span class=&quot;hljs-keyword&quot;&gt;desc&lt;/span&gt;;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h114clusterby&quot;&gt;&lt;span&gt;&lt;strong&gt;1.1.4、cluster by&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  hive 中的 cluster by 在 distribute by 和 sort by &lt;code&gt;排序字段一致&lt;/code&gt;的情况下是等价的。同时，cluster by 指定的列只能是&lt;code&gt;降序&lt;/code&gt;，即默认的 descend，而不能是 ascend。&lt;br/&gt;  例如：写一个等价于 distribute by 与 sort by 的例子。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; company_info &lt;span class=&quot;hljs-keyword&quot;&gt;distribute&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; personId &lt;span class=&quot;hljs-keyword&quot;&gt;sort&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; personId &lt;span class=&quot;hljs-keyword&quot;&gt;desc&lt;/span&gt;;&lt;br/&gt;等价于&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; * &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; compnay_info cluster &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; personId;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h12udafudtf&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2、行转列、列转行（UDAF 与 UDTF）&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;h4 id=&quot;h121&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2.1、行转列&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1、相关函数说明&lt;br/&gt;  1）CONCAT(string A/col, string B/col, …)：返回输入字符串连接后的结果，支持任意个输入字符串。&lt;br/&gt;  2）CONCAT_WS(separator, str1, str2,…)：它是一个&lt;code&gt;特殊形式的CONCAT()&lt;/code&gt;。第一个参数是剩余参数间的分隔符。分隔符可以是与剩余参数一样的字符串。如果分隔符是 NULL，返回值也将为 NULL。这个函数会跳过分隔符参数后的任何 NULL 和空字符串。分隔符将被加到被连接的字符串之间。&lt;br/&gt;  3）COLLECT_SET(col)：函数只接受基本数据类型，它的主要作用是&lt;code&gt;将某字段的值进行去重汇总，产生array类型字段&lt;/code&gt;。&lt;br/&gt;2、数据准备&lt;br/&gt;person_info.txt&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/03/kqaeF1.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;3、需求&lt;br/&gt;把星座和血型一样的人归类到一起。结果如下：
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;射手座,A    大海&lt;span class=&quot;hljs-params&quot;&gt;|凤姐&lt;br/&gt;白羊座,A    孙悟空|&lt;/span&gt;猪八戒&lt;br/&gt;白羊座,B    宋宋&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;分析过程：&lt;/p&gt;
&lt;img title=&quot;&quot; src=&quot;https://s2.ax1x.com/2019/03/03/kqaVoR.png&quot; alt=&quot;&quot;/&gt;&lt;br/&gt;4、创建本地person_info.txt，导入数据
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;[atguigu@hadoop102 datas]$ vim person_info.txt&lt;br/&gt;孙悟空    白羊座 A&lt;br/&gt;大海    射手座 A&lt;br/&gt;宋宋    白羊座 B&lt;br/&gt;猪八戒    白羊座 A&lt;br/&gt;凤姐    射手座 A&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、创建hive表并导入数据&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;sql language-sql hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; person_info(&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;, &lt;br/&gt;constellation &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;, &lt;br/&gt;blood_type &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&lt;br/&gt;) &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;delimited&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;fields&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;terminated&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\t&quot;&lt;/span&gt;;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; inpath &lt;span class=&quot;hljs-string&quot;&gt;'/opt/module/datas/person_info.txt'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; person_info;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、按需求查询数据&lt;/p&gt;
&lt;pre readability=&quot;22.5&quot;&gt;
&lt;code class=&quot;sql language-sql hljs&quot; readability=&quot;39&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;concat_ws&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;,&quot;&lt;/span&gt;, constellation, blood_type) &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; c_b, &lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; person_info; t1&lt;p&gt;+&lt;br/&gt;|  c_b   | name  |&lt;br/&gt;+&lt;br/&gt;| 白羊座,A  | 孙悟空   |&lt;br/&gt;| 射手座,A  | 大海    |&lt;br/&gt;| 白羊座,B  | 宋宋    |&lt;br/&gt;| 白羊座,A  | 猪八戒   |&lt;br/&gt;| 射手座,A  | 凤姐    |&lt;br/&gt;+&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;br/&gt;t1.c_b, collect_set(t1.name)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;br/&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;concat_ws&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;,&quot;&lt;/span&gt;, constellation, blood_type) &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; c_b, &lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; person_info) t1&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt;&lt;br/&gt;t1.c_b;&lt;/p&gt;&lt;p&gt;+&lt;br/&gt;| t1.c_b  |      _c1       |&lt;br/&gt;+&lt;br/&gt;| 射手座,A   | [&quot;大海&quot;,&quot;凤姐&quot;]    |&lt;br/&gt;| 白羊座,A   | [&quot;孙悟空&quot;,&quot;猪八戒&quot;]  |&lt;br/&gt;| 白羊座,B   | [&quot;宋宋&quot;]         |&lt;br/&gt;+&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;br/&gt;t1.c_b, &lt;span class=&quot;hljs-keyword&quot;&gt;concat_ws&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;|&quot;&lt;/span&gt;, collect_set(t1.name)) &lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt;&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;br/&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;concat_ws&lt;/span&gt;(&lt;span class=&quot;hljs-string&quot;&gt;&quot;,&quot;&lt;/span&gt;, constellation, blood_type) &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; c_b, &lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; person_info) t1&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;group&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt;&lt;br/&gt;t1.c_b;&lt;/p&gt;&lt;p&gt;+&lt;br/&gt;| t1.c_b  |   name   |&lt;br/&gt;+&lt;br/&gt;| 射手座,A   | 大海|凤姐    |&lt;br/&gt;| 白羊座,A   | 孙悟空|猪八戒  |&lt;br/&gt;| 白羊座,B   | 宋宋       |&lt;br/&gt;+&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;h122&quot;&gt;&lt;span&gt;&lt;strong&gt;1.2.2、列转行&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;1、函数说明&lt;br/&gt;  EXPLODE(col)：将hive一列中复杂的array或者map结构拆分成多行。&lt;br/&gt;  LATERAL VIEW&lt;br/&gt;    用法：LATERAL VIEW udtf(expression) tableAlias AS columnAlias&lt;br/&gt;    解释：lateral view 用于和split,explode等UDTF函数一起使用，它能够将一列数据拆成多行数据，在此基础上可以对拆分后的数据进行聚合。&lt;br/&gt;2、数据准备&lt;br/&gt;movie_info.txt&lt;/p&gt;
&lt;pre readability=&quot;9&quot;&gt;
&lt;code class=&quot;hljs vbnet&quot; readability=&quot;12&quot;&gt;movie           category&lt;p&gt;《疑犯追踪》    悬疑,动作,科幻,剧情&lt;br/&gt;《Lie &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;me&lt;/span&gt;》   悬疑,警匪,动作,心理,剧情&lt;br/&gt;《战狼&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;》   战争,动作,灾难&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;3、需求&lt;br/&gt;将电影分类中的数组数据展开。结果如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs vbnet&quot;&gt;《疑犯追踪》    悬疑&lt;br/&gt;《疑犯追踪》    动作&lt;br/&gt;《疑犯追踪》    科幻&lt;br/&gt;《疑犯追踪》    剧情&lt;br/&gt;《Lie &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;me&lt;/span&gt;》   悬疑&lt;br/&gt;《Lie &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;me&lt;/span&gt;》   警匪&lt;br/&gt;《Lie &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;me&lt;/span&gt;》   动作&lt;br/&gt;《Lie &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;me&lt;/span&gt;》   心理&lt;br/&gt;《Lie &lt;span class=&quot;hljs-keyword&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;me&lt;/span&gt;》   剧情&lt;br/&gt;《战狼&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;》   战争&lt;br/&gt;《战狼&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;》   动作&lt;br/&gt;《战狼&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;》   灾难&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;4、创建本地movie.txt，导入数据&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;hljs ruby&quot;&gt;[atguigu@hadoop102 datas]$ vim movie_info.txt&lt;br/&gt;《疑犯追踪》    悬疑,动作,科幻,剧情&lt;br/&gt;《Lie to me》   悬疑,警匪,动作,心理,剧情&lt;br/&gt;《战狼&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;》   战争,动作,灾难&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;5、创建hive表并导入数据&lt;/p&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;sql language-sql hljs&quot; readability=&quot;2&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; movie_info(&lt;br/&gt;movie &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;, &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;category&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;array&lt;/span&gt;&amp;lt;&lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;&amp;gt;&lt;br/&gt;) &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;delimited&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;fields&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;terminated&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\t&quot;&lt;/span&gt; &lt;br/&gt;collection items &lt;span class=&quot;hljs-keyword&quot;&gt;terminated&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;,&quot;&lt;/span&gt;; &lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; inpath &lt;span class=&quot;hljs-string&quot;&gt;&quot;/opt/module/datas/movie_info.txt&quot;&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; movie_info;&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;6、按需求查询数据&lt;/p&gt;
&lt;pre readability=&quot;8&quot;&gt;
&lt;code class=&quot;sql language-sql hljs&quot; readability=&quot;10&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt; &lt;br/&gt;movie&lt;br/&gt;explode(&lt;span class=&quot;hljs-keyword&quot;&gt;category&lt;/span&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt;&lt;br/&gt;movie_info;&lt;p&gt;上面是错误的。假设能执行的话，得到的是笛卡尔积。&lt;/p&gt;&lt;p&gt;小结：像split,explode等UDTF函数，是不能跟原表的字段直接进行查询的，UDTF函数一定要和lateral view联合在一块用。&lt;br/&gt;&lt;/p&gt;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;select&lt;/span&gt;&lt;br/&gt;movie,&lt;br/&gt;category_name&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;from&lt;/span&gt; &lt;br/&gt;movie_info lateral &lt;span class=&quot;hljs-keyword&quot;&gt;view&lt;/span&gt; explode(&lt;span class=&quot;hljs-keyword&quot;&gt;category&lt;/span&gt;) table_tmp &lt;span class=&quot;hljs-keyword&quot;&gt;as&lt;/span&gt; category_name; &lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h13&quot;&gt;&lt;span&gt;&lt;strong&gt;1.3、建表时的数组操作&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  fields terminated by：标识一张表中字段与字段之间的分隔符。&lt;br/&gt;  collection items terminated by：标识一个字段(数组字段)中各个子元素(item)的分隔符。注意：若有两个或两个以上的数组字段，那么他们的分隔符都得一样。&lt;/p&gt;
&lt;h3 id=&quot;h14orc&quot;&gt;&lt;span&gt;&lt;strong&gt;1.4、orc 存储&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  orc 即 Optimized Row Columnar (ORC) file，在 RCFile 的基础上演化而来，可以提供一种高效的方法在 Hive 中存储数据，提升了读、写、处理数据的效率。&lt;/p&gt;
&lt;h3 id=&quot;h15hive&quot;&gt;&lt;span&gt;&lt;strong&gt;1.5、Hive 分桶&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;为什么要用Hive 分桶？&lt;br/&gt;答：分区会产生新的文件和目录，在HDFS系统上NameNOde的压力会增大。&lt;br/&gt;Hive 可以将表或者表的分区进一步组织成桶，以达到：&lt;br/&gt;  1、数据取样效率更高&lt;br/&gt;  2、数据处理效率更高&lt;br/&gt;  桶通过对指定列进行哈希来实现，将一个列名下的数据切分为“一组桶”，每个桶都对应了一个该列名下的一个存储文件。&lt;/p&gt;
&lt;h4 id=&quot;h151&quot;&gt;&lt;span&gt;&lt;strong&gt;1.5.1、直接分桶&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  开始操作之前，需要将 hive.enforce.bucketing 属性设置为 true，以标识 Hive 可以识别桶。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;sql language-sql hljs&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; music(&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;, &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;float&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;delimited&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;fields&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;terminated&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\t&quot;&lt;/span&gt;&lt;br/&gt;clustered &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; (&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; buckets;&lt;br/&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;该代码的意思是将 music 表按照 id 将数据分成了 4 个桶，插入数据时，会对应 4 个 reduce 操作，输出 4 个文件。&lt;br/&gt;&lt;code&gt;分桶算法&lt;/code&gt;：id.hashCode % 4(桶数)&lt;br/&gt;&lt;code&gt;Map集合key去重的原理和set集合去重原理&lt;/code&gt;：先比较哈希值(本质是比较地址值,hashCode())，再比较所对应的具体值(equals())。&lt;br/&gt;set集合存储数据的本质是使用&lt;code&gt;Map集合&lt;/code&gt;来存储的。&lt;br/&gt;Map集合存储数据的本质是使用&lt;code&gt;数组&lt;/code&gt;来存储的。&lt;br/&gt;数组存储数据的本质是使用&lt;code&gt;索引+值&lt;/code&gt;来存储的。&lt;/p&gt;
&lt;h4 id=&quot;h152&quot;&gt;&lt;span&gt;&lt;strong&gt;1.5.2、在分区中分桶&lt;/strong&gt;&lt;/span&gt;&lt;/h4&gt;
&lt;p&gt;  当数据量过大，需要庞大分区数量时，可以考虑桶，因为&lt;code&gt;分区数量太大的情况可能会导致文件系统(HDFS)挂掉&lt;/code&gt;，而且桶比分区有更高的查询效率。数据最终落在哪一个桶里，取决于 clustered by 的那个列的值的 hash 数与桶的个数求余来决定。虽然有一定离散性，但不能保证每个桶中的数据量是一样的。&lt;/p&gt;
&lt;pre readability=&quot;4.5&quot;&gt;
&lt;code class=&quot;sql language-sql hljs&quot; readability=&quot;3&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;create&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; music2(&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;int&lt;/span&gt;,&lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;, &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;hljs-built_in&quot;&gt;float&lt;/span&gt;&lt;br/&gt;)&lt;br/&gt;partitioned &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;date&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;string&lt;/span&gt;)&lt;br/&gt;clustered &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;id&lt;/span&gt;) sorted &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt;(&lt;span class=&quot;hljs-keyword&quot;&gt;size&lt;/span&gt;) &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;hljs-number&quot;&gt;4&lt;/span&gt; bucket &lt;br/&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;row&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;format&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;delimited&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;fields&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;terminated&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; &lt;span class=&quot;hljs-string&quot;&gt;&quot;\t&quot;&lt;/span&gt;;&lt;p&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;load&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;local&lt;/span&gt; inpath &lt;span class=&quot;hljs-string&quot;&gt;'/opt/module/datas/music2.txt'&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;into&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;table&lt;/span&gt; music2 &lt;span class=&quot;hljs-keyword&quot;&gt;partition&lt;/span&gt;(&lt;span class=&quot;hljs-built_in&quot;&gt;date&lt;/span&gt;=&lt;span class=&quot;hljs-string&quot;&gt;'2017-08-30'&lt;/span&gt;);&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;h-1&quot;&gt;&lt;span&gt;&lt;strong&gt;二、总结&lt;/strong&gt;&lt;/span&gt;&lt;/h2&gt;
&lt;h3 id=&quot;h21hadoopzookeeper&quot;&gt;&lt;span&gt;&lt;strong&gt;2.1 启动/停止hadoop集群、zookeeper集群、历史服务器&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;hljs ruby&quot; readability=&quot;5&quot;&gt;[atguigu@hadoop102 hadoop-&lt;span class=&quot;hljs-number&quot;&gt;2.7&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]$ sbin/start-dfs.sh -- 启动dfs集群&lt;br/&gt;[atguigu@hadoop103 hadoop-&lt;span class=&quot;hljs-number&quot;&gt;2.7&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]$ sbin/start-yarn.sh -- 启动yarn集群&lt;br/&gt;[atguigu@hadoop102 ~]$ zkstart.sh -- 启动zookeeper集群&lt;br/&gt;[atguigu@hadoop102 hadoop-&lt;span class=&quot;hljs-number&quot;&gt;2.7&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]$ sbin/mr-jobhistory-daemon.sh start historyserver -- 启动历史服务器&lt;p&gt;[atguigu@hadoop102 hadoop-&lt;span class=&quot;hljs-number&quot;&gt;2.7&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]$ sbin/stop-dfs.sh -- 停止dfs集群&lt;br/&gt;[atguigu@hadoop103 hadoop-&lt;span class=&quot;hljs-number&quot;&gt;2.7&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]$ sbin/stop-yarn.sh -- 停止yarn集群&lt;br/&gt;[atguigu@hadoop102 ~]$ zkstop.sh -- 停止zookeeper集群&lt;br/&gt;[atguigu@hadoop102 hadoop-&lt;span class=&quot;hljs-number&quot;&gt;2.7&lt;/span&gt;.&lt;span class=&quot;hljs-number&quot;&gt;2&lt;/span&gt;]$ sbin/mr-jobhistory-daemon.sh stop historyserver -- 停止历史服务器&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h22hive&quot;&gt;&lt;span&gt;&lt;strong&gt;2.2 访问hive的两种方式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre readability=&quot;5.5&quot;&gt;
&lt;code class=&quot;hljs cs&quot; readability=&quot;5&quot;&gt;方式一：&lt;br/&gt;[&lt;span class=&quot;hljs-meta&quot;&gt;atguigu@hadoop102 hive&lt;/span&gt;]$ bin/hive -- 启动hive&lt;p&gt;方式二：&lt;br/&gt;[&lt;span class=&quot;hljs-meta&quot;&gt;atguigu@hadoop102 hive&lt;/span&gt;]$ bin/hiveserver2&lt;br/&gt;[&lt;span class=&quot;hljs-meta&quot;&gt;atguigu@hadoop102 hive&lt;/span&gt;]$ bin/beeline（在新的窗口中输入）&lt;br/&gt;Beeline version &lt;span class=&quot;hljs-number&quot;&gt;1.2&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.1&lt;/span&gt; &lt;span class=&quot;hljs-keyword&quot;&gt;by&lt;/span&gt; Apache Hive&lt;br/&gt;beeline&amp;gt; !connect jdbc:hive2:&lt;br/&gt;Connecting to jdbc:hive2:&lt;br/&gt;Enter username &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; jdbc:hive2:&lt;br/&gt;Enter password &lt;span class=&quot;hljs-keyword&quot;&gt;for&lt;/span&gt; jdbc:hive2:&lt;br/&gt;Connected to: &lt;span class=&quot;hljs-function&quot;&gt;Apache &lt;span class=&quot;hljs-title&quot;&gt;Hive&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;version &lt;span class=&quot;hljs-number&quot;&gt;1.2&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.1&lt;/span&gt;&lt;/span&gt;)&lt;br/&gt;Driver: Hive &lt;span class=&quot;hljs-title&quot;&gt;JDBC&lt;/span&gt; (&lt;span class=&quot;hljs-params&quot;&gt;version &lt;span class=&quot;hljs-number&quot;&gt;1.2&lt;/span&gt;&lt;span class=&quot;hljs-number&quot;&gt;.1&lt;/span&gt;&lt;/span&gt;)&lt;br/&gt;Transaction isolation: TRANSACTION_REPEATABLE_READ&lt;br/&gt;0: jdbc:hive2:&lt;br/&gt;+----------------+--+&lt;br/&gt;| database_name  |&lt;br/&gt;+----------------+--+&lt;br/&gt;| &lt;span class=&quot;hljs-keyword&quot;&gt;default&lt;/span&gt;        |&lt;br/&gt;| hive_db2       |&lt;br/&gt;+----------------+--+&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h23centos6xcenos7x&quot;&gt;&lt;span&gt;&lt;strong&gt;2.3 CentOS6x与Cenos7x命令的区别&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;pre readability=&quot;4&quot;&gt;
&lt;code class=&quot;hljs ruby&quot; readability=&quot;2&quot;&gt;CentOS6x&lt;br/&gt;[atguigu@hadoop102 ~]$ sudo service mysqld restart&lt;p&gt;CentOS7x&lt;br/&gt;[atguigu@hadoop102 ~]$ sudo systemctl restart mysqld.service&lt;br/&gt;&lt;/p&gt;&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;h24&quot;&gt;&lt;span&gt;&lt;strong&gt;2.4 大数据开发中重用的两种数据格式&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  xxx.tsv 文件中的字段是以\t来分割的。&lt;br/&gt;  xxx.csv 文件中的字段是以逗号(,)来分割的。(comma:逗号)&lt;/p&gt;
&lt;h3 id=&quot;h25udfudafudtf&quot;&gt;&lt;span&gt;&lt;strong&gt;2.5 UDF、UDAF、UDTF&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;  collect_set(clo) 将多行数据聚合成一列数据，UDAF函数&lt;br/&gt;  concat_ws(separator, str1, str2,…) 聚合函数，UDAF函数&lt;br/&gt;  split((col),explode(col) 将一列数据拆成多行数据，UDTF函数&lt;/p&gt;
&lt;h3 id=&quot;h26&quot;&gt;&lt;span&gt;&lt;strong&gt;2.6 小知识总结&lt;/strong&gt;&lt;/span&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;分桶算法&lt;/code&gt;：id.hashCode % 4(桶数)&lt;br/&gt;&lt;code&gt;Map集合key去重的原理和set集合去重原理&lt;/code&gt;：先比较哈希值(本质是比较地址值,hashCode())，再比较所对应的具体值(equals())。&lt;br/&gt;　　set集合存储数据的本质是使用&lt;code&gt;Map集合&lt;/code&gt;来存储的。&lt;br/&gt;　　Map集合存储数据的本质是使用&lt;code&gt;数组&lt;/code&gt;来存储的。&lt;br/&gt;　　数组存储数据的本质是使用&lt;code&gt;索引+值&lt;/code&gt;来存储的。&lt;/p&gt;
</description>
<pubDate>Sat, 02 Mar 2019 16:16:00 +0000</pubDate>
<dc:creator>黑泽君</dc:creator>
<og:description>一、知识梳理1.1、背景表结构1.1.1、order by1.1.2、sort by1.1.3、distribute by1.1.4、cluster by1.2、行转列、列转行（UDAF 与 UDTF</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/chenmingjun/p/10463713.html</dc:identifier>
</item>
<item>
<title>Java 核心系列教程 - www.bysocket.com</title>
<link>http://www.cnblogs.com/Alandre/p/10463664.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/Alandre/p/10463664.html</guid>
<description>&lt;p&gt;摘要: 原创出处 &lt;a href=&quot;https://www.bysocket.com&quot; class=&quot;uri&quot;&gt;https://www.bysocket.com&lt;/a&gt; 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！&lt;/p&gt;
&lt;hr/&gt;&lt;p&gt;关于Java核心技术学习积累的例子，是初学者及核心技术巩固的最佳实践。&lt;br/&gt;包括基础语法，OOP，字符串，集合，IO，反射，线程，网络等。&lt;br/&gt;未完成模块：java8，注解,fork/join，加解密等。欢迎fork，欢迎交流。&lt;/p&gt;
&lt;p&gt;Github 地址：【 &lt;a href=&quot;https://github.com/JeffLi1993/java-core-learning-example&quot;&gt;java-core-learning-example&lt;/a&gt; 】&lt;a href=&quot;https://github.com/JeffLi1993/java-core-learning-example&quot; class=&quot;uri&quot;&gt;https://github.com/JeffLi1993/java-core-learning-example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;文章如下：&lt;/p&gt;
&lt;p&gt;『 Java 进阶篇 』&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;连载中...&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;『 Java 集合篇 』&lt;/p&gt;
&lt;p&gt;『 Java IO 篇 』&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;http://www.bysocket.com/wp-content/uploads/2017/01/qrcode_for_gh_cd421e7eb7d6_430.jpg&quot; alt=&quot;&quot; width=&quot;224&quot; height=&quot;224&quot;/&gt;&lt;br/&gt;&lt;strong&gt;（关注微信公众号，领取 Java 精选干货学习资料）&lt;/strong&gt;&lt;/div&gt;
</description>
<pubDate>Sat, 02 Mar 2019 15:57:00 +0000</pubDate>
<dc:creator>www.bysocket.com</dc:creator>
<og:description>摘要: 原创出处 https://www.bysocket.com 「公众号：泥瓦匠BYSocket 」欢迎关注和转载，保留摘要，谢谢！ 关于Java核心技术学习积累的例子，是初学者及核心技术巩固的最</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/Alandre/p/10463664.html</dc:identifier>
</item>
<item>
<title>洛谷P1001 A+B Problem - 筱柒_Littleseven</title>
<link>http://www.cnblogs.com/littleseven777/p/10463652.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/littleseven777/p/10463652.html</guid>
<description>&lt;p&gt;题目链接：&lt;a href=&quot;https://www.luogu.org/problemnew/show/P1001&quot; target=&quot;_blank&quot;&gt;【洛谷】P1001 A+B Problem&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;　　第一篇博客（emmm…），选择了接触Code的第一道题&lt;span&gt;《A + B Proble&lt;/span&gt;m》。&lt;/p&gt;
&lt;p&gt;　　A+B Problem 作为语法基础第一题，是大家走上并&lt;span&gt;放弃&lt;/span&gt;享受Coding的&lt;span&gt;枯燥&lt;/span&gt;乐趣的第一道题。&lt;span&gt;&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;·分析&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;说&lt;/span&gt;&lt;span&gt;起分析这道题，作为语法基础题，并没有过多可以分析的东西，题目的要求呢，是 &lt;span&gt;输入两个整数a,b，输出它们的和(|a|,|b|&amp;lt;=10^9)&lt;/span&gt;  ，由于 |a|,|b|&amp;lt;=10^9 ，所以很轻松的使用 int 型变量来进行读入和计算即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　　所以选择 a，b 读入，最后在输出 a+b 即可。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;·代码&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;C++：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
#include &amp;lt;iostream&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;algorithm&amp;gt;&lt;span&gt;
#include &lt;/span&gt;&amp;lt;cstdio&amp;gt;
&lt;span&gt;using&lt;/span&gt; &lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; std;
&lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b;
    cin&lt;/span&gt;&amp;gt;&amp;gt;a&amp;gt;&amp;gt;&lt;span&gt;b;
    cout&lt;/span&gt;&amp;lt;&amp;lt;a+b&amp;lt;&amp;lt;&lt;span&gt;endl;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;C：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
#include &amp;lt;stdio.h&amp;gt;
&lt;span&gt;int&lt;/span&gt;&lt;span&gt; main()
{
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt;&lt;span&gt; a,b;
    scanf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,&amp;amp;a,&amp;amp;&lt;span&gt;b);
    printf(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;%d&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,a+&lt;span&gt;b);
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
}&lt;br/&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;　　祝愿大家在Coding的路上越走越远。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　　　　　　　　　　　——LittleSeven&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 02 Mar 2019 15:54:00 +0000</pubDate>
<dc:creator>筱柒_Littleseven</dc:creator>
<og:description>题目链接：【洛谷】P1001 A+B Problem ·前言 第一篇博客（emmm…），选择了接触Code的第一道题《A + B Problem》。 A+B Problem 作为语法基础第一</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/littleseven777/p/10463652.html</dc:identifier>
</item>
<item>
<title>Pytorch入门实战一：LeNet神经网络实现 MNIST手写数字识别 - 泽积</title>
<link>http://www.cnblogs.com/shenpings1314/p/10463647.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/shenpings1314/p/10463647.html</guid>
<description>&lt;p&gt;记得第一次接触手写数字识别数据集还在学习&lt;span lang=&quot;EN-US&quot;&gt;TensorFlow，各种&lt;span lang=&quot;EN-US&quot;&gt;sess.run()，头都绕晕了。自从接触&lt;span lang=&quot;EN-US&quot;&gt;pytorch以来，一直想写点什么。曾经在&lt;span lang=&quot;EN-US&quot;&gt;2017年&lt;span lang=&quot;EN-US&quot;&gt;5月，&lt;span lang=&quot;EN-US&quot;&gt;Andrej Karpathy发表的一片&lt;span lang=&quot;EN-US&quot;&gt;Twitter，调侃道：&lt;span lang=&quot;EN-US&quot;&gt;l've been using PyTorch a few months now, l've never felt better, l've more energy.My skin is clearer. My eye sight has improved。确实，使用&lt;span lang=&quot;EN-US&quot;&gt;pytorch以来，确实感觉心情要好多了，不像&lt;span lang=&quot;EN-US&quot;&gt;TensorFlow那样晦涩难懂。迫不及待的用&lt;span lang=&quot;EN-US&quot;&gt;pytorch实战了一把&lt;span lang=&quot;EN-US&quot;&gt;MNIST数据集，构建&lt;span lang=&quot;EN-US&quot;&gt;LeNet神经网络。话不多说，直接上代码！&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;94&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch.nn as nn
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch.nn.functional as F
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; torch.optim as optim
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; torchvision &lt;span&gt;import&lt;/span&gt;&lt;span&gt; datasets,transforms
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; torchvision
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; torch.autograd &lt;span&gt;import&lt;/span&gt;&lt;span&gt; Variable
&lt;/span&gt;&lt;span&gt;from&lt;/span&gt; torch.utils.data &lt;span&gt;import&lt;/span&gt;&lt;span&gt; DataLoader
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; cv2

&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt; LeNet(nn.Module):
    &lt;/span&gt;&lt;span&gt;def&lt;/span&gt; &lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;(self):
        super(LeNet, self).&lt;/span&gt;&lt;span&gt;__init__&lt;/span&gt;&lt;span&gt;()
        self.conv1 &lt;/span&gt;=&lt;span&gt; nn.Sequential(
            nn.Conv2d(&lt;/span&gt;1, 6, 3, 1, 2&lt;span&gt;),
            nn.ReLU(),
            nn.MaxPool2d(&lt;/span&gt;2, 2&lt;span&gt;)
        )

        self.conv2 &lt;/span&gt;=&lt;span&gt; nn.Sequential(
            nn.Conv2d(&lt;/span&gt;6, 16, 5&lt;span&gt;),
            nn.ReLU(),
            nn.MaxPool2d(&lt;/span&gt;2, 2&lt;span&gt;)
        )

        self.fc1 &lt;/span&gt;=&lt;span&gt; nn.Sequential(
            nn.Linear(&lt;/span&gt;16 * 5 * 5, 120&lt;span&gt;),
            nn.BatchNorm1d(&lt;/span&gt;120&lt;span&gt;),
            nn.ReLU()
        )

        self.fc2 &lt;/span&gt;=&lt;span&gt; nn.Sequential(
            nn.Linear(&lt;/span&gt;120, 84&lt;span&gt;),
            nn.BatchNorm1d(&lt;/span&gt;84),&lt;span&gt;#&lt;/span&gt;&lt;span&gt;加快收敛速度的方法（注：批标准化一般放在全连接层后面，激活函数层的前面）&lt;/span&gt;
&lt;span&gt;            nn.ReLU()
        )

        self.fc3 &lt;/span&gt;= nn.Linear(84, 10&lt;span&gt;)

    &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;         self.sfx = nn.Softmax()&lt;/span&gt;

    &lt;span&gt;def&lt;/span&gt;&lt;span&gt; forward(self, x):
        x &lt;/span&gt;=&lt;span&gt; self.conv1(x)
        x &lt;/span&gt;=&lt;span&gt; self.conv2(x)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;         print(x.shape)&lt;/span&gt;
        x = x.view(x.size()[0], -1&lt;span&gt;)
        x &lt;/span&gt;=&lt;span&gt; self.fc1(x)
        x &lt;/span&gt;=&lt;span&gt; self.fc2(x)
        x &lt;/span&gt;=&lt;span&gt; self.fc3(x)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;         x = self.sfx(x)&lt;/span&gt;
        &lt;span&gt;return&lt;/span&gt;&lt;span&gt; x

device &lt;/span&gt;= torch.device(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;cuda&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;if&lt;/span&gt; torch.cuda.is_available() &lt;span&gt;else&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;cpu&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
batch_size &lt;/span&gt;= 64&lt;span&gt;
LR &lt;/span&gt;= 0.001&lt;span&gt;
Momentum &lt;/span&gt;= 0.9

&lt;span&gt;#&lt;/span&gt;&lt;span&gt; 下载数据集&lt;/span&gt;
train_dataset = datasets.MNIST(root = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./data/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                              train&lt;/span&gt;=&lt;span&gt;True,
                              transform &lt;/span&gt;=&lt;span&gt; transforms.ToTensor(),
                              download&lt;/span&gt;=&lt;span&gt;False)
test_dataset &lt;/span&gt;=datasets.MNIST(root = &lt;span&gt;'&lt;/span&gt;&lt;span&gt;./data/&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
                            train&lt;/span&gt;=&lt;span&gt;False,
                            transform&lt;/span&gt;=&lt;span&gt;transforms.ToTensor(),
                            download&lt;/span&gt;=&lt;span&gt;False)
&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;建立一个数据迭代器&lt;/span&gt;
train_loader = torch.utils.data.DataLoader(dataset =&lt;span&gt; train_dataset,
                                          batch_size &lt;/span&gt;=&lt;span&gt; batch_size,
                                          shuffle &lt;/span&gt;=&lt;span&gt; True)
test_loader &lt;/span&gt;= torch.utils.data.DataLoader(dataset =&lt;span&gt; test_dataset,
                                         batch_size &lt;/span&gt;=&lt;span&gt; batch_size,
                                         shuffle &lt;/span&gt;=&lt;span&gt; False)

&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;实现单张图片可视化&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; images,labels = next(iter(train_loader))&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; img  = torchvision.utils.make_grid(images)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; img = img.numpy().transpose(1,2,0)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; # img.shape&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; std = [0.5,0.5,0.5]&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; mean = [0.5,0.5,0.5]&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; img = img*std +mean&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; cv2.imshow('win',img)&lt;/span&gt;&lt;span&gt;
#&lt;/span&gt;&lt;span&gt; key_pressed = cv2.waitKey(0)&lt;/span&gt;
&lt;span&gt;
net &lt;/span&gt;=&lt;span&gt; LeNet().to(device)
criterion &lt;/span&gt;= nn.CrossEntropyLoss()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;定义损失函数&lt;/span&gt;
optimizer = optim.SGD(net.parameters(),lr=LR,momentum=&lt;span&gt;Momentum)

epoch &lt;/span&gt;= 1
&lt;span&gt;if&lt;/span&gt; &lt;span&gt;__name__&lt;/span&gt; == &lt;span&gt;'&lt;/span&gt;&lt;span&gt;__main__&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; epoch &lt;span&gt;in&lt;/span&gt;&lt;span&gt; range(epoch):
        sum_loss &lt;/span&gt;= 0.0
        &lt;span&gt;for&lt;/span&gt; i, data &lt;span&gt;in&lt;/span&gt;&lt;span&gt; enumerate(train_loader):
            inputs, labels &lt;/span&gt;=&lt;span&gt; data
            inputs, labels &lt;/span&gt;=&lt;span&gt; Variable(inputs).cuda(), Variable(labels).cuda()
            optimizer.zero_grad()&lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将梯度归零&lt;/span&gt;
            outputs = net(inputs)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将数据传入网络进行前向运算&lt;/span&gt;
            loss = criterion(outputs, labels)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;得到损失函数&lt;/span&gt;
            loss.backward()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;反向传播&lt;/span&gt;
            optimizer.step()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;通过梯度做一步参数更新&lt;/span&gt;

            &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(loss)&lt;/span&gt;
            sum_loss +=&lt;span&gt; loss.item()
            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; i % 100 == 99&lt;span&gt;:
                &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;[%d,%d] loss:%.03f&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; % (epoch + 1, i + 1, sum_loss / 100&lt;span&gt;))
                sum_loss &lt;/span&gt;= 0.0

    &lt;span&gt;#&lt;/span&gt;&lt;span&gt;验证测试集&lt;/span&gt;
    net.eval()&lt;span&gt;#&lt;/span&gt;&lt;span&gt;将模型变换为测试模式&lt;/span&gt;
    correct =&lt;span&gt; 0
    total &lt;/span&gt;=&lt;span&gt; 0
    &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; data_test &lt;span&gt;in&lt;/span&gt;&lt;span&gt; test_loader:
        images, labels &lt;/span&gt;=&lt;span&gt; data_test
        images, labels &lt;/span&gt;=&lt;span&gt; Variable(images).cuda(), Variable(labels).cuda()
        output_test &lt;/span&gt;=&lt;span&gt; net(images)
        &lt;/span&gt;&lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;output_test:&quot;,output_test.shape)&lt;/span&gt;
&lt;span&gt;
        _, predicted &lt;/span&gt;= torch.max(output_test, 1)&lt;span&gt;#&lt;/span&gt;&lt;span&gt;此处的predicted获取的是最大值的下标&lt;/span&gt;
        &lt;span&gt;#&lt;/span&gt;&lt;span&gt; print(&quot;predicted:&quot;,predicted.shape)&lt;/span&gt;
        total +=&lt;span&gt; labels.size(0)
        correct &lt;/span&gt;+= (predicted ==&lt;span&gt; labels).sum()
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;correct1: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;,correct)
    &lt;/span&gt;&lt;span&gt;print&lt;/span&gt;(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Test acc: {0}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;.format(correct.item() / len(test_dataset)))&lt;span&gt;#&lt;/span&gt;&lt;span&gt;.cpu().numpy()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;本次识别手写数字，只做了1个&lt;span lang=&quot;EN-US&quot;&gt;epoch，&lt;span lang=&quot;EN-US&quot;&gt;train_loss：&lt;span lang=&quot;EN-US&quot;&gt;0.250，测试集上的准确率：&lt;span lang=&quot;EN-US&quot;&gt;0.9685，相当不错的结果。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1456807/201903/1456807-20190302235017312-273364728.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sat, 02 Mar 2019 15:51:00 +0000</pubDate>
<dc:creator>泽积</dc:creator>
<og:description>记得第一次接触手写数字识别数据集还在学习TensorFlow，各种sess.run()，头都绕晕了。自从接触pytorch以来，一直想写点什么。曾经在2017年5月，Andrej Karpathy发表</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/shenpings1314/p/10463647.html</dc:identifier>
</item>
<item>
<title>设计模式之装饰模式(结构型) - smileNicky</title>
<link>http://www.cnblogs.com/mzq123/p/10463633.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/mzq123/p/10463633.html</guid>
<description>&lt;h2 id=&quot;一模式定义&quot;&gt;一、模式定义&lt;/h2&gt;
&lt;p&gt;装饰模式：装饰模式就是允许向一个现有的对象添加新的功能，同时又不改变其结构，装饰模式是一种对象结构型设计模式。&lt;/p&gt;
&lt;h2 id=&quot;二模式角色&quot;&gt;二、模式角色&lt;/h2&gt;
&lt;p&gt;对于装饰模式可以分为如下角色&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Component：抽象构件&lt;/li&gt;
&lt;li&gt;ConcreteComponent：具体构件&lt;/li&gt;
&lt;li&gt;Decorator：抽象装饰类&lt;/li&gt;
&lt;li&gt;ConcreteDecorator：具体装饰类&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;三模式分析&quot;&gt;三、模式分析&lt;/h2&gt;
&lt;p&gt;对于装饰模式进行解释，更易于理解。要给一个类或对象新增行为，一般有两种方法，一种是继承方法，通过类继承的方法可以使Z子类拥有自身方法的同时，拥有父类的方法这就是一种新增类行为的方法；对于另外一种新增类行为的方法就是关联方法，即将一个类嵌入另外一个类，对于这个类，我们称之为装饰器(Decorator)&lt;/p&gt;
&lt;p&gt;上面说了继承机制和关联机制，对于关联机制与继承机制相比，关联优势在于不会破坏类的封装性，继承的耦合度还是比关联要大的，所以应用关联机制的装饰模式偶尔度还是比较小的，这个就是装饰模式的优点了，不过装饰模式需要创建比较多的对象，这种缺点或许可以用享元模式减少类的创建。&lt;br/&gt;下面给出装饰模式的经典代码：&lt;br/&gt;继承抽象构件接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Decorator extends Component
{
    private Component component;
    public Decorator(Component component)
    {
        this.component=component;
    }
    public void operation()
    {
        component.operation();
    }
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体装饰类型实现抽象装饰接口&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class ConcreteDecorator extends Decorator
{
    public ConcreteDecorator(Component component)
    {
        super(component);
    }
    public void operation()
    {
        super.operation();
        addedBehavior();
    }
    public void addedBehavior()
    {
                  //新增方法    
        }
} 
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;四模式例子&quot;&gt;四、模式例子&lt;/h2&gt;
&lt;p&gt;给出&lt;a href=&quot;https://baike.baidu.com/item/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/19696449&quot;&gt;《设计模式》&lt;/a&gt;一书的多重加密例子：&lt;/p&gt;
&lt;blockquote readability=&quot;8&quot;&gt;
&lt;p&gt;某系统提供了一个数据加密功能，可以对字符串进行加密。最简单的加密算法通过对字母进行移位来实现，同时还提供了稍复杂的逆向输出加密，还提供了更为高级的求模加密。用户先使用最简单的加密算法对字符串进行加密，如果觉得还不够可以对加密之后的结果使用其他加密算法进行二次加密，当然也可以进行第三次加密。现使用装饰模式设计该多重加密系统。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抽象构件接口：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public interface Cipher
{
    public String encrypt(String plainText);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体构件类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public final class SimpleCipher implements Cipher
{
    public String encrypt(String plainText)
    {
        String str=&quot;&quot;;
        for(int i=0;i&amp;lt;plainText.length();i++)
        {
            char c=plainText.charAt(i);
            if(c&amp;gt;='a'&amp;amp;&amp;amp;c&amp;lt;='z')
            {
                c+=6;
            if(c&amp;gt;'z') c-=26;
            if(c&amp;lt;'a') c+=26;
            }
            if(c&amp;gt;='A'&amp;amp;&amp;amp;c&amp;lt;='Z')
            {
                c+=6;
            if(c&amp;gt;'Z') c-=26;
            if(c&amp;lt;'A') c+=26;
            }
            str+=c;
        }
        return str;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;抽象装饰类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public abstract class CipherDecorator implements Cipher
{
    private Cipher cipher;
    
    public CipherDecorator(Cipher cipher)
    {
        this.cipher=cipher;
    }
    
    public String encrypt(String plainText)
    {
        return cipher.encrypt(plainText);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;具体装饰类：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class AdvancedCipher extends CipherDecorator
{
    public AdvancedCipher(Cipher cipher)
    {
        super(cipher);
    }
    
    public String encrypt(String plainText)
    {
        String result=super.encrypt(plainText);
        result=mod(result);
        return result;
    }
    
    public String mod(String text)
    {
        String str=&quot;&quot;;
        for(int i=0;i&amp;lt;text.length();i++)
        {
            String c=String.valueOf(text.charAt(i)%6);
            str+=c;
        }
        return str;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;public class ComplexCipher extends CipherDecorator
{
    public ComplexCipher(Cipher cipher)
    {
        super(cipher);
    }
    
    public String encrypt(String plainText)
    {
        String result=super.encrypt(plainText);
        result= this.reverse(result);
        return result;
    }
    
    public String reverse(String text)
    {
        String str=&quot;&quot;;
        for(int i=text.length();i&amp;gt;0;i--)
        {
            str+=text.substring(i-1,i);
        }
        return str;
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;客户端类进行调用：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;public class Client
{
    public static void main(String args[])
    {
        String password=&quot;sunnyLiu&quot;;  //明文
        String cpassword;       //密文
        Cipher sc,ac,cc;
        
        sc=new SimpleCipher();
        cpassword=sc.encrypt(password);
        System.out.println(cpassword);
        
        cc=new ComplexCipher(sc);
        cpassword=cc.encrypt(password);
        System.out.println(cpassword);
        
        ac=new AdvancedCipher(cc);
        cpassword=ac.encrypt(password);
        System.out.println(cpassword);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;模式应用&lt;/strong&gt;&lt;br/&gt;装饰模式应用最常见的就是JDK提供的Java IO操作&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;抽象构件类：InputStream&lt;/li&gt;
&lt;li&gt;具体构件类：FileInputStream、ByteArrayInputStream等&lt;/li&gt;
&lt;li&gt;抽象装饰类：FilterInputStream&lt;/li&gt;
&lt;li&gt;具体装饰类：BufferedInputStream、DataInputStream等&lt;br/&gt;...&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;五模式分类&quot;&gt;五、模式分类&lt;/h2&gt;
&lt;p&gt;装饰模式可以分为透明装饰模式和半透明装饰模式。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;透明装饰模式&lt;/strong&gt;&lt;br/&gt;透明装饰模式要求客户端面向抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Cipher sc,cc,ac;
sc=new SimpleCipher();
cc=new ComplexCipher(sc);   
ac=new AdvancedCipher(cc);&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;半透明装饰模式&lt;/strong&gt;&lt;br/&gt;半透明装饰模式是比较常见的，大多数装饰模式都是半透明(semi-transparent)的装饰模式，而不是完全透明(transparent)的，即允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;Transform camaro;
camaro=new Car();
camaro.move();
Robot bumblebee=new Robot(camaro);
bumblebee.move();
bumblebee.say(); 
&lt;/code&gt;
&lt;/pre&gt;</description>
<pubDate>Sat, 02 Mar 2019 15:44:00 +0000</pubDate>
<dc:creator>smileNicky</dc:creator>
<og:description>一、模式定义 装饰模式：装饰模式就是允许向一个现有的对象添加新的功能，同时又不改变其结构，装饰模式是一种对象结构型设计模式。 二、模式角色 对于装饰模式可以分为如下角色 Component：抽象构件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/mzq123/p/10463633.html</dc:identifier>
</item>
<item>
<title>6. ASP.NET MVC 5.0 中的HTML Helper【HTML 帮助类】 - 灰太狼的梦想</title>
<link>http://www.cnblogs.com/caofangsheng/p/10462494.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/caofangsheng/p/10462494.html</guid>
<description>&lt;p&gt;&lt;span&gt;         这篇文章，我将带领大家学习HTML Helper。【PS：上一篇--&amp;gt;&lt;a href=&quot;https://www.cnblogs.com/caofangsheng/p/10461541.html&quot; target=&quot;_blank&quot;&gt;5.ASP.NET MVC 中的Area【区域】是什么&lt;/a&gt;】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;HTML Helpers是用来创建HTML标签进而创建HTML控件的。HTML Helper仅仅是一个返回HTML字符串的方法。ASP.NET MVC 中有三种HTML Helpers&lt;/span&gt;&lt;span&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.Inline HTML Helper(内联HTML Helper)&lt;/strong&gt;:主要是通过使用Razor语法中的@helper标记来创建。内联HTML Helper仅仅只能在同一个视图中，被重复使用。如果想要在所有的视图中都能使用，有办法可以解决。待会会介绍。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.Built-In-HTML Helpers(内置的HTML Helpers)&lt;/strong&gt;：这类的HTML Helper是HtmlHelper类的扩展方法，进一步分为3类：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;2.1 标准HTML Helper【Standard HTML Helpers】&lt;/strong&gt;：用来创建最常用得HTML标签。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;    &lt;strong&gt;2.2 强类型的HTML Helpers【Strongly Typed HTML Helpers】&lt;/strong&gt;：这种是HTML通过Model类的属性生成，使用Lambda表达式来生成HTML。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　 &lt;strong&gt;2.3 模板化的HTML Helpers 【Templated HTML Helpers】&lt;/strong&gt;:这种helper生成的HTML取决于Model类的属性。&lt;br/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;3.自定义的HTML helpers【Custom HTML Helpers】&lt;/strong&gt;:你可以通过使用HtmlHelper扩展方法，或者在工具类中使用静态方法来创建自定义的helper 方法。&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;1.先来看看内联的HTML Helper&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建项目HTMLHelpersWithMVC，同时新建一个Home控制器，和Index视图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302214059014-2065296733.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 视图页面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302214841986-1037808972.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行一下：【效果图】&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302214951608-1131988837.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;现在假如，我还有一个Test页面，也要显示这个，怎么办呢？我们直接在Test页面写一下看看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302215145623-1779959834.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302215259862-2101559893.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302215247938-567541310.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; 看，报错了噢，内联方法只能在声明的视图页面使用噢，怎么办呢？我们可以这样做：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;右键项目创建一个App_Code文件夹：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302221336973-648795046.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 在App_Code文件夹下，创建一个分布视图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302221653892-468275575.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;然后，把刚才在Home控制器Index页面的内联Html Helper方法声明全部弄过来：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302221807793-481385184.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后运行项目：看：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302222058953-1233111974.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;咋回事还是报错了，现在Index页面也报错了，哪里出问题了？？？&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们这样改：把App_Code文件夹下的视图页面，属性改成嵌入的资源和如果较新则复制&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302222309433-1117318034.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后视图页面修改如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302222556965-863794366.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302222659781-426599322.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后接着运行看看两个页面的效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302222743184-39456757.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302222808178-1435019891.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;看这样就实现了，可以在多个页面实现【内联HTML Helpers】Inline HTML Helpers了。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;2.1 现在来看看，内置的HTML Helpers中的标准 HTML Helpers了&lt;/strong&gt;。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302223610303-2069326452.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行效果如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302223552207-25760776.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;strong&gt;2.2 现在开始学习 【Built-In HTML Helpers】内置的HTML之强类型HTML Helpers了&lt;/strong&gt;：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在Models文件夹下创建一个UserInfo类&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302224031251-150457082.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;为了演示这个强类型的，我新建一个控制器Account，并创建Index视图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302224814788-1553958916.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;运行程序：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302224933250-330253019.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2.3 现在看看模板化的HTML Helpers怎么做&lt;/span&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们在Account控制器中，添加一个Temp方法：并创建Temp视图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302225841671-2093544393.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302230200417-1971981553.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 运行到Temp页面：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302230237818-617505064.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;发现@Html.EditorForModel()自动为我们创建了控件&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3.最后我们来看看，怎么创建自定义HTML Helpers&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建一个Custom控制器：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302230602524-1165272098.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;创建一个CustomClass:&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; HTMLHelpersWithMVC.Common
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomClass
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 扩展方法实现方式--创建提交按钮
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;helper&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;扩展类对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MvcHtmlString CreateSubmit(&lt;span&gt;this&lt;/span&gt; HtmlHelper helper, &lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; btn = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;input type='submit' name='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+name+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' value='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+value+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MvcHtmlString(btn);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 静态类实现方式--创建提交按钮
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MvcHtmlString CreateSubmit(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;var&lt;/span&gt; btn = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;input type='submit' name='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' value='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + value + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MvcHtmlString(btn);
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302233252765-1327698304.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;注意这个类CustomClass类必须要在&lt;span&gt;程序根目录下创建&lt;/span&gt;，在视图中才能点出来【有智能提示】&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;正确的：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;38&quot;&gt;
&lt;pre&gt;
&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Collections.Generic;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Linq;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web;
&lt;/span&gt;&lt;span&gt;using&lt;/span&gt;&lt;span&gt; System.Web.Mvc;

&lt;/span&gt;&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt; HTMLHelpersWithMVC&lt;/strong&gt;&lt;/span&gt;
{
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; CustomClass
    {
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 扩展方法实现方式--创建提交按钮
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;helper&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;扩展类对象&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MvcHtmlString CreateSubmit(&lt;span&gt;this&lt;/span&gt; HtmlHelper helper, &lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; btn = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;input type='submit' name='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' value='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + value + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MvcHtmlString(btn);
        }
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt;&lt;span&gt; 静态类实现方式--创建提交按钮
        &lt;/span&gt;&lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;/summary&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;name&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮名称&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;param name=&quot;value&quot;&amp;gt;&lt;/span&gt;&lt;span&gt;按钮值&lt;/span&gt;&lt;span&gt;&amp;lt;/param&amp;gt;&lt;/span&gt;
        &lt;span&gt;///&lt;/span&gt; &lt;span&gt;&amp;lt;returns&amp;gt;&amp;lt;/returns&amp;gt;&lt;/span&gt;
        &lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; MvcHtmlString CreateSubmit(&lt;span&gt;string&lt;/span&gt; name, &lt;span&gt;string&lt;/span&gt;&lt;span&gt; value)
        {
            &lt;/span&gt;&lt;span&gt;string&lt;/span&gt; btn = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;&amp;lt;input type='submit' name='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + name + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;' value='&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + value + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;'/&amp;gt;&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt; &lt;span&gt;new&lt;/span&gt;&lt;span&gt; MvcHtmlString(btn);
        }

    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;在Custom控制器的Index视图中：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302233526623-400603412.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 运行程序：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302233616017-995550381.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/745221/201903/745221-20190302233648912-1176760359.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt; &lt;span&gt;好了，这篇文章到此为止就介绍完了，ASP.NET MVC HTML Helpers了，学会了么？&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 02 Mar 2019 15:40:00 +0000</pubDate>
<dc:creator>灰太狼的梦想</dc:creator>
<og:description>这篇文章，我将带领大家学习HTML Helper。【PS：上一篇--&gt;5.ASP.NET MVC 中的Area【区域】是什么】 HTML Helpers是用来创建HTML标签进而创建HTML控件</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/caofangsheng/p/10462494.html</dc:identifier>
</item>
<item>
<title>下载及配置Python+openCV - wenboz</title>
<link>http://www.cnblogs.com/wenbozhu/p/10463599.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/wenbozhu/p/10463599.html</guid>
<description>&lt;p&gt;一、下载Anaconda&lt;/p&gt;
&lt;p&gt;　　Anaconda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。&lt;/p&gt;
&lt;p&gt;　　1.官网下载地址：https://www.anaconda.com/distribution/#download-section&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;16&quot;&gt;
&lt;p&gt;　　选择符合你电脑的版本：windows/macOS/Linux，32位或64位&lt;/p&gt;
&lt;p&gt;　　2.若下载太慢或总是中断，换一个下载地址：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive&lt;/p&gt;
&lt;p&gt;　　下载好exe文件后，一直点next，直到： &lt;/p&gt;
&lt;p&gt;      &lt;img src=&quot;https://img2018.cnblogs.com/blog/1267287/201903/1267287-20190302213921296-189506074.png&quot; alt=&quot;&quot; width=&quot;352&quot; height=&quot;274&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　若电脑已经下载好pycharm，则两个都勾选，即完成了环境配置。&lt;/p&gt;
&lt;p&gt;　　下载完毕，打开命令行，输入python，出现：&lt;/p&gt;
&lt;p&gt;　　&lt;img src=&quot;https://img2018.cnblogs.com/blog/1267287/201903/1267287-20190302215436087-77628007.png&quot; alt=&quot;&quot; width=&quot;780&quot; height=&quot;65&quot;/&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;二、下载opencv_python&lt;/p&gt;
&lt;p&gt;　　下载网址：https://www.lfd.uci.edu/~gohlke/pythonlibs/&lt;/p&gt;
&lt;div class=&quot;para&quot;&gt;        &lt;img src=&quot;https://img2018.cnblogs.com/blog/1267287/201903/1267287-20190302223301156-653667305.png&quot; alt=&quot;&quot; width=&quot;668&quot; height=&quot;56&quot;/&gt;　　 &lt;/div&gt;
&lt;p&gt;　　在命令行中输入pip install opencv_python-3.4.5-cp37-cp37m-win_amd64.whl&lt;/p&gt;
&lt;div class=&quot;para&quot; readability=&quot;10.5&quot;&gt;
&lt;p&gt; 　　 &lt;img src=&quot;https://img2018.cnblogs.com/blog/1267287/201903/1267287-20190302223655722-417628857.png&quot; alt=&quot;&quot; width=&quot;561&quot; height=&quot;166&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　下载成功。&lt;/p&gt;
&lt;p&gt;三、配置pycharm&lt;/p&gt;
&lt;p&gt;　　输入测试代码：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;import cv2
img &lt;/span&gt;= cv2.imread(&lt;span&gt;'&lt;/span&gt;&lt;span&gt;1.jpg&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;)
cv2.imshow(&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;image&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,img)
cv2.waitKey(&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;)
cv2.destroyAllWindows()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1267287/201903/1267287-20190302232538438-306867725.png&quot; alt=&quot;&quot; width=&quot;504&quot; height=&quot;306&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显示图片，则说明配置成功。&lt;/p&gt;


&lt;/div&gt;
</description>
<pubDate>Sat, 02 Mar 2019 15:30:00 +0000</pubDate>
<dc:creator>wenboz</dc:creator>
<og:description>一、下载Anaconda Anaconda是一个开源的包、环境管理器，可以用于在同一个机器上安装不同版本的软件包及其依赖，并能够在不同的环境之间切换。 1.官网下载地址：https://www.ana</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/wenbozhu/p/10463599.html</dc:identifier>
</item>
</channel>
</rss>