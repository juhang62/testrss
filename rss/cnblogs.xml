<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title>【Ray Tracing The Next Week 超详解】 光线追踪2-5 - 林-兮</title>
<link>http://www.cnblogs.com/lv-anchoret/p/10295137.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/lv-anchoret/p/10295137.html</guid>
<description>
&lt;p&gt;&lt;strong&gt;&lt;span&gt;Chapter 5：Image Texture Mapping&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;先看效果：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190120105022094-1328440523.png&quot; alt=&quot;&quot; width=&quot;240&quot; height=&quot;190&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190120105143187-1848967996.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们之前的纹理是利用的是撞击点&lt;em&gt;&lt;strong&gt;&lt;span&gt;p&lt;/span&gt;&lt;/strong&gt;&lt;/em&gt;处的位置信息，比如大理石纹理&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;而我们今天的图片映射纹理采用2D（u，v）纹理坐标来进行。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;在图像中使用缩放（u，v）的直接方法是将u和v四舍五入为整数，并将其作用于（i，j）像素。而，我们的纹理和物体的尺寸并不一致，所以我们需要将其规格化，然后再放大适应至物体尺寸。即，我们采用某个点在当前图像中的比例，而不是具体的位置，例如，对于nx乘ny图像中的像素（i，j），图像纹理位置为：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;u = i / (nx - 1)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;v = j / (ny - 1)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;对于intersect，我们还需要在相交碰撞记录中返回u和v。对于球体，我们采用球面坐标。即：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190120145539129-1250080533.jpg&quot; alt=&quot;&quot; width=&quot;509&quot; height=&quot;538&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如上坐标系采用光线追踪惯用坐标系,设P点为单位球上一点&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;∠θ 为xOz平面与线段OP之间的夹角，θ∈0~π&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;∠φ 为线段OP在xOz平面的映射线与x轴正方向之间的夹角，φ∈0~2π&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;则：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;x = cosφ· cosθ&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;z = sinφ· cosθ&lt;/span&gt;&lt;br/&gt;&lt;span&gt;y = sinθ&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;将θ和φ规格化到【0,1】，则如下：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;u = φ/（2π）&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;v = θ/π&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt; &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt; &lt;/span&gt;过程：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们先将撞击点的坐标映射到单位球面上（规格化），得到纹理坐标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后材质纹理反射的时候将此规格化坐标带入&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;根据图片的规格展开得到图片对应的位置，返回图片对应处的rgb&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;可见，撞击点处应该存储关于图片纹理坐标的信息&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;所以，我们先将撞击点信息更新：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190120152541713-801297825.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;获取纹理坐标&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190120152834106-2062673332.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190120152903772-889764406.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;反射求取图片对应出的像素值&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190120153134109-1901501073.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;我们来解决图片纹理对应的value函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;下面是图片纹理类&lt;/span&gt;&lt;/p&gt;

&lt;div class=&quot;cnblogs_code&quot; onclick=&quot;cnblogs_code_show('af61edfe-51da-401e-ab8e-c2ba53337acd')&quot; readability=&quot;38.5&quot;&gt;&lt;img id=&quot;code_img_closed_af61edfe-51da-401e-ab8e-c2ba53337acd&quot; class=&quot;code_img_closed&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif&quot; alt=&quot;&quot;/&gt;&lt;img id=&quot;code_img_opened_af61edfe-51da-401e-ab8e-c2ba53337acd&quot; class=&quot;code_img_opened&quot; onclick=&quot;cnblogs_code_hide('af61edfe-51da-401e-ab8e-c2ba53337acd',event)&quot; src=&quot;https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif&quot; alt=&quot;&quot;/&gt;&lt;div id=&quot;cnblogs_code_open_af61edfe-51da-401e-ab8e-c2ba53337acd&quot; class=&quot;cnblogs_code_hide&quot; readability=&quot;72&quot;&gt;
&lt;pre&gt;
&lt;span&gt;///&lt;/span&gt;&lt;span&gt; image_tex.hpp&lt;/span&gt;

&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [author]        lv
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [begin ]        2019.1
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; [brief ]        the image_texture-class for the ray-tracing project
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;                from the 《ray tracing the next week》
&lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; -----------------------------------------------------&lt;/span&gt;

&lt;span&gt;#pragma&lt;/span&gt; once 

&lt;span&gt;namespace&lt;/span&gt;&lt;span&gt; rt
{
&lt;/span&gt;&lt;span&gt;class&lt;/span&gt; image_texture: &lt;span&gt;public&lt;/span&gt;&lt;span&gt; texture
    {
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    image_texture() {  }

    image_texture(unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; image, size_t a, size_t b);

    inline unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;* image()&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _image; }

    inline size_t sizeX()&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _sizeX; }

    inline size_t sizeY()&lt;/span&gt;&lt;span&gt;const&lt;/span&gt; { &lt;span&gt;return&lt;/span&gt;&lt;span&gt; _sizeY; }

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt;&lt;span&gt;:
    &lt;/span&gt;&lt;span&gt;virtual&lt;/span&gt; rtvec value(rtvar u, rtvar v, &lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; p)&lt;span&gt;const&lt;/span&gt; &lt;span&gt;override&lt;/span&gt;&lt;span&gt;;

&lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt;:
    unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; _image;

    size_t _sizeX;

    size_t _sizeY;
    };


image_texture::image_texture(unsigned &lt;/span&gt;&lt;span&gt;char&lt;/span&gt;*&lt;span&gt; image, size_t a, size_t b)
    :_image(image)
    ,_sizeX(a)
    ,_sizeY(b)
    {
    }

rtvec image_texture::value(rtvar u, rtvar v, &lt;/span&gt;&lt;span&gt;const&lt;/span&gt; rtvec&amp;amp; p)&lt;span&gt;const&lt;/span&gt;&lt;span&gt;
    {
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; i = u*&lt;span&gt;_sizeX;
    &lt;/span&gt;&lt;span&gt;int&lt;/span&gt; j = (&lt;span&gt;1&lt;/span&gt; - v)*_sizeY - &lt;span&gt;0.001&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;lt; &lt;span&gt;0&lt;/span&gt;)i = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (j &amp;lt; &lt;span&gt;0&lt;/span&gt;)j = &lt;span&gt;0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (i &amp;gt; _sizeX - &lt;span&gt;1&lt;/span&gt;)i = _sizeX - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (j &amp;gt; _sizeY - &lt;span&gt;1&lt;/span&gt;)j = _sizeY - &lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
    rtvar r &lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;(_image[&lt;span&gt;3&lt;/span&gt; * i + &lt;span&gt;3&lt;/span&gt; * _sizeX*j]) / &lt;span&gt;255.0&lt;/span&gt;&lt;span&gt;;
    rtvar g &lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;(_image[&lt;span&gt;3&lt;/span&gt; * i + &lt;span&gt;3&lt;/span&gt; * _sizeX*j + &lt;span&gt;1&lt;/span&gt;]) / &lt;span&gt;255.0&lt;/span&gt;&lt;span&gt;;
    rtvar b &lt;/span&gt;= &lt;span&gt;int&lt;/span&gt;(_image[&lt;span&gt;3&lt;/span&gt; * i + &lt;span&gt;3&lt;/span&gt; * _sizeX*j + &lt;span&gt;2&lt;/span&gt;]) / &lt;span&gt;255.0&lt;/span&gt;&lt;span&gt;;
    &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; rtvec(r, g, b);
    }

}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;span class=&quot;cnblogs_code_collapse&quot;&gt;image_texture.hpp&lt;/span&gt;&lt;/div&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;因为图片信息是有一维数组存储的，每个元素的rgb是顺序存储的，所以每个像素点有三个值，所以求取对应位置索引的时候要用3乘&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;现在我们需要的是读取并存储图像文件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们采用&lt;a href=&quot;https://blog.csdn.net/qq_35608277/article/details/80878507&quot; target=&quot;_blank&quot;&gt;stb图片读取处理库&lt;/a&gt;，我们就用一个函数&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;我们要在库引用之前先定义一个宏&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;#define STB_IMAGE_IMPLEMENTATION&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;然后#include “stb_image.h”&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果你们找不到地球图，就去我相册中下载一下吧&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;或者随便找一个也行&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190120154114934-2040956796.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt; 然后就可以得到第一张图&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;第二章图的话，就是下面那个是金属材质的球，可以采用下面函数&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1316111/201901/1316111-20190120154319575-273223014.png&quot; alt=&quot;&quot;/&gt;&lt;/span&gt;&lt;/p&gt;


&lt;p&gt;&lt;span&gt;如果有什么代码不完整的可以在下面留言&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;我们的代码，一般情况下会在每本书的后面做统一的整理公布&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;&lt;span&gt;感谢您的阅读，生活愉快~&lt;/span&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 20 Jan 2019 07:46:00 +0000</pubDate>
<dc:creator>林-兮</dc:creator>
<og:description>图片纹理</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/lv-anchoret/p/10295137.html</dc:identifier>
</item>
<item>
<title>再探go modules：使用与细节 - apocelipes</title>
<link>http://www.cnblogs.com/apocelipes/p/10295096.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/apocelipes/p/10295096.html</guid>
<description>&lt;p&gt;还有半个月go1.12就要发布了。这是首个将go modules纳入正式支持的稳定版本。&lt;/p&gt;
&lt;p&gt;距离go modules随着go1.11正式面向广大开发者进行体验也已经过去了半年，这段时间go modules也发生了一些变化，借此机会我想再次深入探讨go modules的使用，同时对这个新生包管理方案做一些思考。&lt;/p&gt;
&lt;blockquote id=&quot;bookmark&quot;&gt;
&lt;h4&gt;本文索引&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;vcs-semver&quot;&gt;版本控制和语义化版本&lt;/h2&gt;
&lt;p&gt;包的版本控制总是一个包管理器绕不开的古老话题，自然对于我们的go modules也是这样。&lt;/p&gt;
&lt;p&gt;我们将学习一种新的版本指定方式，然后深入地探讨一下golang官方推荐的&lt;code&gt;semver&lt;/code&gt;即语义化版本。&lt;/p&gt;
&lt;h3 id=&quot;vcs&quot;&gt;控制包版本&lt;/h3&gt;
&lt;p&gt;在讨论go get进行包管理时我们曾经讨论过如何对包版本进行控制（&lt;a href=&quot;https://www.cnblogs.com/apocelipes/p/9534885.html&quot;&gt;文章在此&lt;/a&gt;），支持的格式如下：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;vX.Y.Z-pre.0.yyyymmddhhmmss-abcdefabcdef
vX.0.0-yyyymmddhhmmss-abcdefabcdef
vX.Y.(Z+1)-0.yyyymmddhhmmss-abcdefabcdef
vX.Y.Z&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在go.mod文件中我们也需要这样指定，否则go mod无法正常工作，这带来了2个痛点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;目标库需要打上符合要求的tag，如果tag不符合要求不排除日后出现兼容问题（目前来说只要正确指定tag就行，唯一的特殊情况在下一节介绍）&lt;/li&gt;
&lt;li&gt;如果目标库没有打上tag，那么就必须毫无差错的编写大串的版本信息，大大加重了使用者的负担&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;基于以上原因，现在可以直接使用commit的hash来指定版本，如下：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;# 使用go get时
go get github.com/mqu/go-notify@ef6f6f49

# 在go.mod中指定
module my-module

require (
  // other packages
  github.com/mqu/go-notify ef6f6f49
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;随后我们运行&lt;code&gt;go build&lt;/code&gt;或&lt;code&gt;go mod tidy&lt;/code&gt;，这两条命令会整理并更新go.mod文件，更新后的文件会是这样：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;module my-module

require (
    github.com/mattn/go-gtk v0.0.0-20181205025739-e9a6766929f6 // indirect
    github.com/mqu/go-notify v0.0.0-20130719194048-ef6f6f49d093
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到hash信息自动扩充成了符合要求的版本信息，今后可以依赖这一特性简化包版本的指定。&lt;/p&gt;
&lt;p&gt;对于hash信息只有两个要求：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;指定hash信息时不要在前面加上&lt;code&gt;v&lt;/code&gt;，只需要给出commit hash即可&lt;/li&gt;
&lt;li&gt;hash至少需要8位，与git等工具不同，少于8位会导致go mod无法找到包的对应版本，推荐与go mod保持一致给出12位长度的hash&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;然而这和我们理想中的版本控制方式似乎还是有些出入，是不是觉得。。。有点不直观？接下来介绍的语义化版本也许能带来一些改观。&lt;/p&gt;
&lt;h3 id=&quot;#semver&quot;&gt;语义化版本&lt;/h3&gt;
&lt;p&gt;golang官方推荐的最佳实践叫做&lt;code&gt;semver&lt;/code&gt;，这是一个简称，写全了就是&lt;code&gt;Semantic Versioning&lt;/code&gt;，也就是语义化版本。&lt;/p&gt;
&lt;h4 id=&quot;semver-what&quot;&gt;何谓语义化&lt;/h4&gt;
&lt;p&gt;通俗地说，就是一种清晰可读的，明确反应版本信息的版本格式，更具体的规范在&lt;a href=&quot;https://semver.org/lang/zh-CN/&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;如规范所言，形如&lt;code&gt;vX.Y.Z&lt;/code&gt;的形式显然比一串hash更直观，所以golang的开发者才会把目光集中于此。&lt;/p&gt;
&lt;h4 id=&quot;semver-why&quot;&gt;为何使用语义化版本&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;semver&lt;/code&gt;简化版本指定的作用是显而易见的，然而仅此一条理由显然有点缺乏说服力，毕竟改进后的版本指定其实也不是那么麻烦，对吧？&lt;/p&gt;
&lt;p&gt;那么为何要引入一套新的规范呢？&lt;/p&gt;
&lt;p&gt;我想这可能与golang一贯重视工程化的哲学有关：&lt;/p&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;不要删除导出的名称，鼓励标记的复合文字等等。如果需要不同的功能，添加 新名称而不是更改旧名称。如果需要完整中断，请创建一个带有新导入路径的新包。 -go modules wiki&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过&lt;code&gt;semver&lt;/code&gt;对版本进行严格的约束，可以最大程度地保证向后兼容以及避免“breaking changes”，而这些都是golang所追求的。两者一拍即合，所以go modules提供了语义化版本的支持。&lt;/p&gt;
&lt;h4 id=&quot;semver-how&quot;&gt;语义化版本带来的影响&lt;/h4&gt;
&lt;p&gt;如果你使用和发布的包没有版本tag或者处于1.x版本，那么你可能体会不到什么区别，因为go mod所支持的格式从始至终是遵循&lt;code&gt;semver&lt;/code&gt;的，主要的区别体现在&lt;code&gt;v2.0.0&lt;/code&gt;以及更高版本的包上。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;“如果旧软件包和新软件包具有相同的导入路径，则新软件包必须向后兼容旧软件包。” - go modules wiki&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;正如这句话所说，相同名字的对象应该向后兼容，然而按照语义化版本的约定，当出现&lt;code&gt;v2.0.0&lt;/code&gt;的时候一定表示发生了重大变化，很可能无法保证向后兼容，这时候应该如何处理呢？&lt;/p&gt;
&lt;p&gt;答案很简单，我们为包的导入路径的末尾附加版本信息即可，例如：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;module my-module/v2

require (
  some/pkg/v2 v2.0.0
  some/pkg/v2/mod1 v2.0.0
  my/pkg/v3 v3.0.1
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;格式总结为&lt;code&gt;pkgpath/vN&lt;/code&gt;，其中&lt;code&gt;N&lt;/code&gt;是大于1的主要版本号。在代码里导入时也需要附带上这个版本信息，如&lt;code&gt;import &quot;some/pkg/v2&quot;&lt;/code&gt;。如此一来包的导入路径发生了变化，也不用担心名称相同的对象需要向后兼容的限制了，因为golang认为不同的导入路径意味着不同的包。&lt;/p&gt;
&lt;p&gt;不过这里有几个例外可以不用参照这种写法：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;当使用&lt;code&gt;gopkg.in&lt;/code&gt;格式时可以使用等价的&lt;code&gt;require gopkg.in/some/pkg.v2 v2.0.0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;在版本信息后加上&lt;code&gt;+incompatible&lt;/code&gt;就可以不需要指定&lt;code&gt;/vN&lt;/code&gt;，例如：&lt;code&gt;require some/pkg v2.0.0+incompatible&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;使用go1.11时设置&lt;code&gt;GO111MODULE=off&lt;/code&gt;将取消这种限制，当然go1.12里就不能这么干了&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;除此以外的情况如果直接使用v2+版本将会导致go mod报错。&lt;/p&gt;
&lt;p&gt;v2+版本的包允许和其他不同大版本的包同时存在（前提是添加了&lt;code&gt;/vN&lt;/code&gt;），它们将被当做不同的包来处理。&lt;/p&gt;
&lt;p&gt;另外&lt;code&gt;/vN&lt;/code&gt;并不会影响你的仓库，不需要创建一个v2对应的仓库，这只是go modules添加的一种附加信息而已。&lt;/p&gt;
&lt;p&gt;当然如果你不想遵循这一规范或者需要兼容现有代码，那么指定&lt;code&gt;+incompatible&lt;/code&gt;会是一个合理的选择。不过如其字面意思，go modules不推荐这种行为。&lt;/p&gt;
&lt;h4 id=&quot;semver-think&quot;&gt;一点思考&lt;/h4&gt;
&lt;p&gt;眼尖的读者可能已经发现了，&lt;code&gt;semver&lt;/code&gt;很眼熟。&lt;/p&gt;
&lt;p&gt;是的，&lt;code&gt;REST api&lt;/code&gt;是它的最忠实用户，像&lt;code&gt;xxx.com/api/v2/xxx&lt;/code&gt;的最佳实践我们恐怕都司空见惯了，所以golang才会要求v2+的包使用&lt;code&gt;pkg/v2&lt;/code&gt;的形式。然而把&lt;code&gt;REST api&lt;/code&gt;的最佳实践融合进包管理器设计，真的会是又一个最佳实践吗？&lt;/p&gt;
&lt;p&gt;我觉得未必如此，一个显而易见的缺点就在于向后兼容上，主流的包管理器都只采用&lt;code&gt;semver&lt;/code&gt;的子集，最大的原因在于如果只提供对版本的控制，而把先后兼容的责任交由开发者/用户相对于强行将无关的信息附加在包名上来说可能会造成一定的迷惑，但是这种做法可以最大限度的兼容现有代码，而golang则需要修改mod文件，修改引入路径，分散的修改往往导致潜在的缺陷，考虑到现有的golang生态这一做法显得不那么明智。同时将版本信息绑定进包名对于习惯了传统包管理器方案的用户（npm，pip）来说显得有些怪异，可能需要花上一些额外时间适应。&lt;/p&gt;
&lt;p&gt;不过检验真理的标准永远都是实践，随着go1.12的发布我们最终会见分晓，对于go modules现在是给予耐心提出建议的阶段，评判还为时尚早。&lt;/p&gt;
&lt;h2 id=&quot;replace&quot;&gt;replace的限制&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;go mod edit -replace&lt;/code&gt;无疑是一个十分强大的命令，但强大的同时它的限制也非常多。&lt;/p&gt;
&lt;p&gt;本部分你将看到两个例子，它们分别阐述了本地包替换的方法以及顶层依赖与间接依赖的区别，现在让我们进入第一个例子。&lt;/p&gt;
&lt;h3 id=&quot;replace-local&quot;&gt;本地包替换&lt;/h3&gt;
&lt;p&gt;replace除了可以将远程的包进行替换外，还可以将本地存在的modules替换成任意指定的名字。&lt;/p&gt;
&lt;p&gt;假设我们有如下的项目：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;tree my-mod

my-mod
├── go.mod
├── main.go
└── pkg
    ├── go.mod
    └── pkg.go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;其中main.go负责调用&lt;code&gt;my/example/pkg&lt;/code&gt;中的&lt;code&gt;Hello&lt;/code&gt;函数打印一句“Hello”，&lt;code&gt;my/example/pkg&lt;/code&gt;显然是个不存在的包，我们将用本地目录的&lt;code&gt;pkg&lt;/code&gt;包替换它，这是main.go：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package main

import &quot;my/example/pkg&quot;

func main() {
    pkg.Hello()
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的pkg.go相对来说很简单：&lt;/p&gt;
&lt;pre class=&quot;golang&quot;&gt;
&lt;code&gt;package pkg

import &quot;fmt&quot;

func Hello() {
    fmt.Println(&quot;Hello&quot;)
}&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;重点在于go.mod文件，虽然不推荐直接编辑mod文件，但在这个例子中与使用&lt;code&gt;go mod edit&lt;/code&gt;的效果几乎没有区别，所以你可以尝试自己动手修改my-mod/go.mod：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;module my-mod

require my/example/pkg v0.0.0

replace my/example/pkg =&amp;gt; ./pkg&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;至于pkg/go.mod，使用&lt;code&gt;go mod init&lt;/code&gt;生成后不用做任何修改，它只是让我们的pkg成为一个module，因为replace的源和目标都只能是go modules。&lt;/p&gt;
&lt;p&gt;因为被replace的包首先需要被require（wiki说本地替换不用指定，然而我试了报错），所以在my-mod/go.mod中我们需要先指定依赖的包，即使它并不存在。对于一个会被replace的包，如果是用本地的module进行替换，那么可以指定版本为&lt;code&gt;v0.0.0&lt;/code&gt;(对于没有使用版本控制的包只能指定这个版本)，否则应该和替换包的指定版本一致。&lt;/p&gt;
&lt;p&gt;再看&lt;code&gt;replace my/example/pkg =&amp;gt; ./pkg&lt;/code&gt;这句，与替换远程包时一样，只是将替换用的包名改为了本地module所在的绝对或相对路径。&lt;/p&gt;
&lt;p&gt;一切准备就绪，我们运行&lt;code&gt;go build&lt;/code&gt;，然后项目目录会变成这样：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;tree my-mod

my-mod
├── go.mod
├── main.go
├── my-mod
└── pkg
    ├── go.mod
    └── pkg.go&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那个叫my-mod的文件就是编译好的程序，我们运行它：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;./my-mod
Hello&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;运行成功，&lt;code&gt;my/example/pkg&lt;/code&gt;已经替换成了本地的&lt;code&gt;pkg&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;同时我们注意到，使用本地包进行替换时并不会生成go.sum所需的信息，所以go.sum文件也没有生成。&lt;/p&gt;
&lt;p&gt;本地替换的价值在于它提供了一种使自动生成的代码进入go modules系统的途径，毕竟不管是go tools还是rpc工具，这些自动生成代码也是项目的一部分，如果不能纳入包管理器的管理范围想必会带来很大的麻烦。&lt;/p&gt;
&lt;h3 id=&quot;replace-indirect&quot;&gt;顶层依赖与间接依赖&lt;/h3&gt;
&lt;p&gt;如果你因为&lt;code&gt;golang.org/x/...&lt;/code&gt;无法获取而使用replace进行替换，那么你肯定遇到过问题。明明已经replace的包为何还会去未替换的地址进行搜索和下载？&lt;/p&gt;
&lt;p&gt;解释这个问题前先看一个go.mod的例子，这个项目使用的第三方模块使用了&lt;code&gt;golang.org/x/...&lt;/code&gt;的包，但项目中没有直接引用它们：&lt;/p&gt;
&lt;pre class=&quot;text&quot;&gt;
&lt;code&gt;module schanclient

require (
    github.com/PuerkitoBio/goquery v1.4.1
    github.com/andybalholm/cascadia v1.0.0 // indirect
    github.com/chromedp/chromedp v0.1.2
    golang.org/x/net v0.0.0-20180824152047-4bcd98cce591 // indirect
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;注意&lt;code&gt;github.com/andybalholm/cascadia v1.0.0&lt;/code&gt;和&lt;code&gt;golang.org/x/net v0.0.0-20180824152047-4bcd98cce591&lt;/code&gt;后面的&lt;code&gt;// indirect&lt;/code&gt;，它表示这是一个间接依赖。&lt;/p&gt;
&lt;p&gt;间接依赖是指在当前module中没有直接import，而被当前module使用的第三方module引入的包，相对的顶层依赖就是在当前module中被直接import的包。如果二者规则发生冲突，那么顶层依赖的规则覆盖间接依赖。&lt;/p&gt;
&lt;p&gt;在这里&lt;code&gt;golang.org/x/net&lt;/code&gt;被&lt;code&gt;github.com/chromedp/chromedp&lt;/code&gt;引入，但当前项目未直接import，所以是一个间接依赖，而&lt;code&gt;github.com/chromedp/chromedp&lt;/code&gt;被直接引入和使用，所以它是一个顶层依赖。&lt;/p&gt;
&lt;p&gt;而我们的replace命令只能管理顶层依赖，所以在这里你使用&lt;code&gt;replace golang.org/x/net =&amp;gt; github.com/golang/net&lt;/code&gt;是没用的，这就是为什么会出现go build时仍然去下载&lt;code&gt;golang.org/x/net&lt;/code&gt;的原因。&lt;/p&gt;
&lt;p&gt;那么如果我把&lt;code&gt;// indirect&lt;/code&gt;去掉了，那么不就变成顶层依赖了吗？答案当然是不行。不管是直接编辑还是&lt;code&gt;go mod edit&lt;/code&gt;修改，我们为go.mod添加的信息都只是对&lt;code&gt;go mod&lt;/code&gt;的一种提示而已，当运行&lt;code&gt;go build&lt;/code&gt;或是&lt;code&gt;go mod tidy&lt;/code&gt;时golang会自动更新go.mod导致某些修改无效，简单来说&lt;mark&gt;一个包是顶层依赖还是间接依赖，取决于它在本module中是否被直接import，而不是在go.mod文件中是否包含&lt;code&gt;// indirect&lt;/code&gt;注释&lt;/mark&gt;。&lt;/p&gt;
&lt;h3 id=&quot;replace-limit&quot;&gt;限制&lt;/h3&gt;
&lt;p&gt;replace唯一的限制是它只能处理顶层依赖。&lt;/p&gt;
&lt;p&gt;这样限制的原因也很好理解，因为对于包进行替换后，通常不能保证兼容性，对于一些使用了这个包的第三方module来说可能意味着潜在的缺陷，而允许顶层依赖的替换则意味着你对自己的项目有充足的自信不会因为replace引入问题，是可控的。相当符合golang的工程性原则。&lt;/p&gt;
&lt;p&gt;也正如此replace的适用范围受到了相当的限制：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;可以使用本地包替换将生成代码纳入go modules的管理&lt;/li&gt;
&lt;li&gt;对于直接import的顶层依赖，可以替换不能正常访问的包或是过时的包&lt;/li&gt;
&lt;li&gt;go modules下import不再支持使用相对路径导入包，例如&lt;code&gt;import &quot;./mypkg&quot;&lt;/code&gt;，所以需要考虑replace&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;除此之外的replace暂时没有什么用处，当然以后如果有变动的话说不定可以发挥比现在更大的作用。&lt;/p&gt;
&lt;h2 id=&quot;release&quot;/&gt;
&lt;p&gt;发布go modules&lt;br/&gt;本部分将讨论如何发布你的modules到github等开源仓库以供他人使用，放心这是相对来说最轻松的一部分。&lt;/p&gt;
&lt;h3 id=&quot;release-gosum&quot;&gt;go.sum不是锁文件&lt;/h3&gt;
&lt;p&gt;也许你知道npm的package-lock.json的作用，它会记录所有库的准确版本，来源以及校验和，从而帮助开发者使用正确版本的包。通常我们发布时不会带上它，因为package.json已经够用，而package-lock.json的内容过于详细反而会对版本控制以及变更记录等带来负面影响。&lt;/p&gt;
&lt;p&gt;如果看到go.sum文件的话，也许你会觉得它和package-lock.json一样也是一个锁文件，那就大错特错了。go.sum不是锁文件。&lt;/p&gt;
&lt;p&gt;更准确地来说，go.sum是一个构建状态跟踪文件。它会记录当前module所有的顶层和间接依赖，以及这些依赖的校验和，从而提供一个可以100%复现的构建过程并对构建对象提供安全性的保证。&lt;/p&gt;
&lt;p&gt;go.sum同时还会保留过去使用的包的版本信息，以便日后可能的版本回退，这一点也与普通的锁文件不同。所以go.sum并不是包管理器的锁文件。&lt;/p&gt;
&lt;p&gt;因此我们应该把go.sum和go.mod一同添加进版本控制工具的跟踪列表，同时需要随着你的模块一起发布。如果你发布的模块中不包含此文件，使用者在构建时会报错，同时还可能出现安全风险（go.sum提供了安全性的校验）。&lt;/p&gt;
&lt;h3 id=&quot;release-vendor&quot;&gt;使用vendor目录&lt;/h3&gt;
&lt;p&gt;golang一直提供了工具选择上的自由性，如果你不喜欢go mod的缓存方式，你可以使用&lt;code&gt;go mod vendor&lt;/code&gt;回到&lt;code&gt;godep&lt;/code&gt;或&lt;code&gt;govendor&lt;/code&gt;使用的&lt;code&gt;vendor&lt;/code&gt;目录进行包管理的方式。&lt;/p&gt;
&lt;p&gt;当然这个命令并不能让你从godep之类的工具迁移到go modules，它只是单纯地把go.sum中的所有依赖下载到vendor目录里，如果你用它迁移godep你会发现vendor目录里的包回合godep指定的产生相当大的差异，所以请务必不要这样做。&lt;/p&gt;
&lt;p&gt;我们举第一部分中用到的项目做例子，使用&lt;code&gt;go mod vendor&lt;/code&gt;之后项目结构是这样的：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;tree my-module

my-module
├── go.mod
├── go.sum
├── main.go
└── vendor
    ├── github.com
    │   ├── mattn
    │   │   └── go-gtk
    │   │       └── glib
    │   │           ├── glib.go
    │   │           └── glib.go.h
    │   └── mqu
    │       └── go-notify
    │           ├── LICENSE
    │           ├── README
    │           └── notify.go
    └── modules.txt&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到依赖被放入了vendor目录。&lt;/p&gt;
&lt;p&gt;接下来使用&lt;code&gt;go build -mod=vendor&lt;/code&gt;来构建项目，因为在go modules模式下go build是屏蔽vendor机制的，所以需要特定参数重新开启vendor机制:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;go build -mod=vendor
./my-module
a notify!&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;构建成功。当发布时也只需要和使用godep时一样将vendor目录带上即可。&lt;/p&gt;
&lt;h3 id=&quot;release-version&quot;&gt;注意包版本&lt;/h3&gt;
&lt;p&gt;其实这是第一部分的老生常谈，当你发布一个v2+版本的库时，需要进行以下操作：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将&lt;code&gt;module my-module&lt;/code&gt;改成&lt;code&gt;module my-module/v2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将源代码中使用了v2+版本包的import语句从&lt;code&gt;import &quot;my-module&quot;&lt;/code&gt;改为&lt;code&gt;import &quot;my-module/v2&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;仔细检查你的代码中所有&lt;code&gt;my-module&lt;/code&gt;包的版本是否统一，修改那些不兼容的问题&lt;/li&gt;
&lt;li&gt;在changelog中仔细列出所有breaking changes&lt;/li&gt;
&lt;li&gt;当然，如果你觉得前面四步过于繁琐，注明你的用户需要指定&lt;code&gt;+incompatible&lt;/code&gt;是一个暂时性的解决方案。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;注意以上几点的话发布go modules也就是一个轻松的工作了。&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;小结&lt;/h2&gt;
&lt;p&gt;相比godep和vendor机制而言，go modules已经是向现代包管理器迈出的坚实一步，虽然还有不少僵硬甚至诡异的地方，但是个人还是推荐在go1.12发布后考虑逐步迁移到go modules，毕竟有官方的支持，相关issues的讨论也很活跃，不出意外应该是go包管理方案的最终答案，现在花上一些时间是值得的。&lt;/p&gt;
&lt;p&gt;当然包管理是一个很大的话题，就算本文也只是讲解了其中的一二，以后我也许有时间会介绍更多go modules相关的内容。&lt;/p&gt;
&lt;p&gt;总之go modules还是一个新兴事物，包管理器是一个需要不断在实践中完善的工具，如果你有建设性的想法请尽量向官方反馈。&lt;/p&gt;
&lt;p&gt;go modules的官方wiki也上线一段时间了，这篇文件基本上是与其结合的查漏补缺，同时也夹杂了一些个人见解，所以难免有所错误疏漏，欢迎指正。&lt;/p&gt;
&lt;h5 id=&quot;参考&quot;&gt;参考&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/golang/go/wiki/Modules&quot;&gt;go modules wiki&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 07:37:00 +0000</pubDate>
<dc:creator>apocelipes</dc:creator>
<og:description>还有半个月go1.12就要发布了。这是首个将go modules纳入正式支持的稳定版本。 距离go modules随着go1.11正式面向广大开发者进行体验也已经过去了半年，这段时间go module</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/apocelipes/p/10295096.html</dc:identifier>
</item>
<item>
<title>【详解】Spring Security 之 SecurityContext - 猫毛·波拿巴</title>
<link>http://www.cnblogs.com/longfurcat/p/10293819.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/longfurcat/p/10293819.html</guid>
<description>&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;　　本文主要整理一下SecurityContext的存储方式。&lt;/p&gt;
&lt;h2&gt;SecurityContext接口&lt;/h2&gt;
&lt;p&gt;顾名思义，安全上下文。即存储认证授权的相关信息，实际上就是存储&quot;&lt;strong&gt;当前用户&lt;/strong&gt;&quot;账号信息和相关权限。这个接口只有两个方法，Authentication对象的getter、setter。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.security.core.context;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; org.springframework.security.core.Authentication;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; SecurityContext &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Serializable {
    Authentication getAuthentication();

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt;&lt;span&gt; setAuthentication(Authentication var1);
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Authentication接口又是干嘛的？&lt;/h2&gt;
&lt;p&gt;注意：SecurityContext存储的Authentication对象是经过认证的，所以它会带有权限，它的getAuthorities()方法会返回相关权限。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;package&lt;/span&gt;&lt;span&gt; org.springframework.security.core;

&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.io.Serializable;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.security.Principal;
&lt;/span&gt;&lt;span&gt;import&lt;/span&gt;&lt;span&gt; java.util.Collection;

&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;interface&lt;/span&gt; Authentication &lt;span&gt;extends&lt;/span&gt;&lt;span&gt; Principal, Serializable {
    Collection&lt;/span&gt;&amp;lt;? &lt;span&gt;extends&lt;/span&gt; GrantedAuthority&amp;gt;&lt;span&gt; getAuthorities();

    Object getCredentials();

    Object getDetails();

    Object getPrincipal();

    &lt;/span&gt;&lt;span&gt;boolean&lt;/span&gt;&lt;span&gt; isAuthenticated();

    &lt;/span&gt;&lt;span&gt;void&lt;/span&gt; setAuthenticated(&lt;span&gt;boolean&lt;/span&gt; var1) &lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IllegalArgumentException;
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;SecurityContextHolder工具类&lt;/h2&gt;
&lt;p&gt;前面说的&quot;&lt;strong&gt;当前用户&lt;/strong&gt;&quot;实际上指的是当前这个请求所对应的用户，那么怎么知道当前用户是谁呢？由于一个请求从开始到结束都由一个线程处理，这个线程中途也不会去处理其他的请求。所以在这段时间内，相当于这个线程跟当前用户是一一对应的。SecurityContextHolder工具类就是把SecurityContext存储在当前线程中。&lt;/p&gt;
&lt;p&gt;SecurityContextHolder可以用来设置和获取SecurityContext。它主要是给框架内部使用的，可以利用它获取当前用户的SecurityContext进行请求检查，和访问控制等。&lt;/p&gt;
&lt;p&gt;在Web环境下，SecurityContextHolder是利用ThreadLocal来存储SecurityContext的。&lt;/p&gt;
&lt;h2&gt;&lt;strong&gt;请求结束，SecurityContext存储在哪里？&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;我们知道Sevlet中线程是被池化复用的，一旦处理完当前的请求，它可能马上就会被分配去处理其他的请求。而且也不能保证用户下次的请求会被分配到同一个线程。所以存在线程里面，请求一旦结束，就没了。如果没有保存，不是每次请求都要重新认证登录？想想看，如果没有权限框架我们是怎么处理的？&lt;/p&gt;
&lt;p&gt;想到了吧，如果不用权限框架，我们一般是把认证结果存在Session中的。同理，它也把认证结果存储到Session了。&lt;/p&gt;
&lt;p&gt;对应的Key是：&quot;&lt;span&gt;&lt;strong&gt;SPRING_SECURITY_CONTEXT&lt;/strong&gt;&lt;/span&gt;&quot;&lt;/p&gt;
&lt;h2&gt;流程视图&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1313132/201901/1313132-20190120155653707-1681055739.png&quot; alt=&quot;&quot; width=&quot;604&quot; height=&quot;424&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;SecurityContextPersistenceFilter拦截器&lt;/h2&gt;
&lt;p&gt; SecurityContextPersistenceFilter是Security的拦截器，而且是拦截链中的第一个拦截器，请求来临时它会从HttpSession中把SecurityContext取出来，然后放入SecurityContextHolder。在所有拦截器都处理完成后，再把SecurityContext存入HttpSession，并清除SecurityContextHolder内的引用。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;注：其中repo对象是HttpSessionSecurityContextRepository&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;45&quot;&gt;
&lt;pre&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; doFilter(ServletRequest req, ServletResponse res, FilterChain chain)
            &lt;/span&gt;&lt;span&gt;throws&lt;/span&gt;&lt;span&gt; IOException, ServletException {
        HttpServletRequest request &lt;/span&gt;=&lt;span&gt; (HttpServletRequest) req;
        HttpServletResponse response &lt;/span&gt;=&lt;span&gt; (HttpServletResponse) res;

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (request.getAttribute(FILTER_APPLIED) != &lt;span&gt;null&lt;/span&gt;&lt;span&gt;) {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; ensure that filter is only applied once per request&lt;/span&gt;
&lt;span&gt;            chain.doFilter(request, response);
            &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt;;
        }

        &lt;/span&gt;&lt;span&gt;final&lt;/span&gt; &lt;span&gt;boolean&lt;/span&gt; debug =&lt;span&gt; logger.isDebugEnabled();

        request.setAttribute(FILTER_APPLIED, Boolean.TRUE);

        &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (forceEagerSessionCreation) {
            HttpSession session &lt;/span&gt;=&lt;span&gt; request.getSession();

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt; (debug &amp;amp;&amp;amp;&lt;span&gt; session.isNew()) {
                logger.debug(&lt;/span&gt;&quot;Eagerly created session: &quot; +&lt;span&gt; session.getId());
            }
        }

        HttpRequestResponseHolder holder &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; HttpRequestResponseHolder(request,
                response);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用HttpSecurityContextRepository从HttpSesion中获取SecurityContext对象
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;如果没有HttpSession，即浏览器第一次访问服务器，还没有产生会话。
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;它会创建一个空的SecurityContext对象&lt;/span&gt;
        SecurityContext contextBeforeChainExecution =&lt;span&gt; repo.loadContext(holder);

        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;把SecurityContext放入到SecurityContextHolder中&lt;/span&gt;
&lt;span&gt;            SecurityContextHolder.setContext(contextBeforeChainExecution);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行拦截链，这个链会逐层向下执行&lt;/span&gt;
&lt;span&gt;            chain.doFilter(holder.getRequest(), holder.getResponse());

        }
        &lt;/span&gt;&lt;span&gt;finally&lt;/span&gt;&lt;span&gt; { 
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;当拦截器都执行完的时候把当前线程对应的SecurityContext从SecurityContextHolder中取出来&lt;/span&gt;
            SecurityContext contextAfterChainExecution =&lt;span&gt; SecurityContextHolder
                    .getContext();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; Crucial removal of SecurityContextHolder contents - do this before anything
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; else.&lt;/span&gt;
&lt;span&gt;            SecurityContextHolder.clearContext();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;利用HttpSecurityContextRepository把SecurityContext写入HttpSession&lt;/span&gt;
&lt;span&gt;            repo.saveContext(contextAfterChainExecution, holder.getRequest(),
                    holder.getResponse());
            request.removeAttribute(FILTER_APPLIED);

            &lt;/span&gt;&lt;span&gt;if&lt;/span&gt;&lt;span&gt; (debug) {
                logger.debug(&lt;/span&gt;&quot;SecurityContextHolder now cleared, as request processing completed&quot;&lt;span&gt;);
            }
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Tomcat建立会话的流程&lt;/h3&gt;
&lt;p&gt;　　有人可能对Tomcat建立会话的流程还不熟悉，这里稍微整理一下。是这样的，当客户浏览器打开后第一次访问Tomcat服务器，Tomcat会创建一个HttpSesion对象，存入一个ConcurrentHashMap，Key是SessionId，Value就是HttpSession。然后请求完成后，在返回的报文中添加&lt;strong&gt;Set-Cookie：JSESSIONID=xxx&lt;/strong&gt;，然后客户端浏览器会保存这个Cookie。当浏览器再次访问这个服务器的时候，都会带上这个Cookie。Tomcat接收到这个请求后，根据JSESSIONID把对应的HttpSession对象取出来，放入HttpSerlvetRequest对象里面。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;重点：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;1.HttpSession会一直存在服务端，实际上是&lt;span&gt;存在运行内存&lt;/span&gt;中。除非Session过期 OR Tomcat奔溃 OR 服务器奔溃，否则会话信息不会消失。&lt;/p&gt;
&lt;p&gt;2.如无特殊处理，Cookie JSESSIONID会在浏览器关闭的时候清除。&lt;/p&gt;
&lt;p&gt;3.Tomcat中HttpSesion的默认过期时间为30分钟。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4.这些处理都在Security的拦截链之前完成。&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 07:20:00 +0000</pubDate>
<dc:creator>猫毛&amp;#183;波拿巴</dc:creator>
<og:description>前言 本文主要整理一下SecurityContext的存储方式。 SecurityContext接口 顾名思义，安全上下文。即存储认证授权的相关信息，实际上就是存储&quot;当前用户&quot;账号</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/longfurcat/p/10293819.html</dc:identifier>
</item>
<item>
<title>关于接口测试的理解_Charles（Fiddler）、postman - 女汉纸tester</title>
<link>http://www.cnblogs.com/nhztester/p/10294827.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/nhztester/p/10294827.html</guid>
<description>&lt;p&gt;刚开始接触app测试，一无所知的时候只知道点点点，基本的手工测试，但是实际上，通过接口去测试，可能会有更高的效率和便捷，下面是我对接口测试的理解，目前还没验证是否酱紫：&lt;/p&gt;
&lt;p&gt;首先，说道基本的抓包工具Charles、fiddler、wireshark等，刚开始我接触的是fiddler，但是fiddler经常弄到我本地都无法进行链接网络，最后慢慢的同事给我介绍 了Charles这个抓包工具；刚开始，我作为一个测试新人，我不知道什么叫抓包，进到去时开发人员问我会不会抓包时，我还是一脸懵的，自己也没去查也没去学，到后面测试移动端的时间久了，也学到了一些基本的测试要领，就慢慢往外拓展自己的思维圈。抓包在百度的翻译是“抓包就是将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，也用来检查网络安全”，描述的比较官方，但是在我的理解就是：他是用来检查接口传的参数和前端返回的值得检测，接下来说说Charles工具的真实运用：&lt;/p&gt;
&lt;p&gt;1.如何设置代理信息及安装配置：&lt;/p&gt;
&lt;p&gt;在网上下载下来的版本，需要下载安装ssl/https，再进行设置操作&lt;/p&gt;
&lt;p&gt;（1）先下载安装&lt;/p&gt;
&lt;p&gt;下载地址：https://www.charlesproxy.com/documentation/additional/legacy-ssl-proxying/ &lt;/p&gt;
&lt;p&gt;（2）设置&lt;/p&gt;
&lt;p&gt;移动端和桌面端都安装完成后，先打开help——SSLProxying——install Charles Root Certificate;里面可能显示“此证书不被信任”，此时我们需要在证书上点击右键展开信任——选择始终信任，也可通过安装证书，根据向导找到下载的目录找到对应文件进行信任&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295305/201901/1295305-20190120141240147-768755758.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295305/201901/1295305-20190120141602618-1914689566.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;2.设置代理&lt;/p&gt;
&lt;p&gt;（1）先查找本地ip和端口号：&lt;/p&gt;
&lt;p&gt;       ip查找方式：cmd——ipconfig&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295305/201901/1295305-20190120142240022-392360111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;      端口：proxy——proxy Setting&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295305/201901/1295305-20190120142456989-1952782809.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）移动端设置代理：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295305/201901/1295305-20190120142129919-1009043165.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt; （3）配置好了后就可以正常使用了，第一次代理会提示是否允许的弹框，点击“allow”就可以了&lt;/p&gt;
&lt;p&gt;3.安装完成后，可能会链接不了的情况，一般分为几种&lt;/p&gt;
&lt;p&gt;（1）端口号被占用：&lt;/p&gt;
&lt;p&gt;         在Proxy里的Proxy Setting就可以设置端口号，默认为8080,，可自行进行修改&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295305/201901/1295305-20190120135132152-116806592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;（2）第二就是代理设置不正确或没装插件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1295305/201901/1295305-20190120134801319-1689420726.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;目前先更新介么多，后面慢慢补充如何方便利于我们的测试工作哦&lt;/p&gt;

</description>
<pubDate>Sun, 20 Jan 2019 06:29:00 +0000</pubDate>
<dc:creator>女汉纸tester</dc:creator>
<og:description>刚开始接触app测试，一无所知的时候只知道点点点，基本的手工测试，但是实际上，通过接口去测试，可能会有更高的效率和便捷，下面是我对接口测试的理解，目前还没验证是否酱紫： 首先，说道基本的抓包工具Cha</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/nhztester/p/10294827.html</dc:identifier>
</item>
<item>
<title>基于ITextSharp插件在ASP.NET MVC中将图表导出为PDF - 张子浩</title>
<link>http://www.cnblogs.com/ZaraNet/p/10294602.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ZaraNet/p/10294602.html</guid>
<description>&lt;h2&gt;样本：&lt;/h2&gt;
&lt;p&gt;在这个示例中，我们使用的是微软给我们提供的数据库，也就是家喻户晓的&lt;strong&gt;Northwind数据库。&lt;/strong&gt;要下载Microsoft的免费样本Northwind数据库，您需要访问以下URL。&lt;a href=&quot;http://www.microsoft.com/en-us/download/details.aspx?id=23654&quot; target=&quot;_blank&quot;&gt;下载Northwind数据库&lt;/a&gt;在页面上，您将找到下载按钮，如以下屏幕截图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190120152103276-443985367.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第2步：安装Microsoft的免费样本Northwind数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个安装程序文件（.msi）将被下载。您可以将其保存在桌面上，因为下载完成后您需要执行它。文件下载完成后，您可以通过双击安装文件或右键单击然后单击上下文菜单中的安装选项来开始安装。&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190120152126036-1852973305.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;安装完成后，您可以在以下位置检查已安装的数据库文件，您将在安装文件夹中找到Northwind数据库。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤3：使用Management Studio将Northwind MDF文件附加到SQL Server数据库&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;现在，你需要启动SQL Server Management Studio中，然后用鼠标右键单击数据库文件夹在对象资源管理器。在上下文菜单中，单击Attach选项，如下所示&lt;/p&gt;
&lt;div&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190120152141988-1778563919.png&quot; alt=&quot;&quot;/&gt;&lt;/div&gt;
&lt;p&gt;此选项将在SQL Server中打开文件浏览器，您需要导航并选择NORTHWIND.MDF文件并按OK按钮。&lt;/p&gt;
&lt;p&gt;这就是你将看到数据库现在可以在SQL Server中与其他数据库一起使用。&lt;/p&gt;
&lt;p&gt;如果因为数据库版本问题或其他原因，附加不上，那你就用那几个脚本文件。&lt;/p&gt;
&lt;h2&gt;安装图表：&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190120102830377-844839441.png&quot; alt=&quot;&quot;/&gt;&lt;/h2&gt;
&lt;p&gt; 这玩腻更新的还是比较快的，所以可用性还是比较大的。现在我们创建一个model（用于绑定图标值）&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
public class&lt;span&gt; OrderModel
    {
        public string ShipCity { get; set&lt;span&gt;; }
        public int TotalOrders { get; set&lt;span&gt;; }
    }&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;我们现在肯定是要去创建我们的控制器了，定义如下。&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;57&quot;&gt;
&lt;pre&gt;
using&lt;span&gt; System;
using&lt;span&gt; System.Collections.Generic;
using&lt;span&gt; System.Linq;
using&lt;span&gt; System.Web.Mvc;
using&lt;span&gt; System.IO;
using&lt;span&gt; iTextSharp.text;
using&lt;span&gt; iTextSharp.text.pdf;
using&lt;span&gt; WebApplication1.Models;
using&lt;span&gt; System.Web.Helpers;

namespace&lt;span&gt; WebApplication1.Controllers
{
    public class&lt;span&gt; PdfController : Controller
    {
        public static PdfContext pdfcontextoBJ = new&lt;span&gt; PdfContext();
        // GET: Pdf
        public&lt;span&gt; ActionResult Index()
        {
            byte[] bytes =&lt;span&gt; PopulateChart();
            ViewBag.ChartImageUrl = &quot;data:image/png;base64,&quot; + Convert.ToBase64String(bytes, 0&lt;span&gt;, bytes.Length);
            return&lt;span&gt; View();
        }
        [HttpPost]
        public&lt;span&gt; FileResult Export()
        {
            byte[] bytes =&lt;span&gt; PopulateChart();
            ViewBag.ChartImageUrl = &quot;data:image/png;base64,&quot; + Convert.ToBase64String(bytes, 0&lt;span&gt;, bytes.Length);
            using (MemoryStream stream = new&lt;span&gt; System.IO.MemoryStream())
            {
                //Initialize the PDF document object.
                using (Document pdfDoc = new&lt;span&gt; Document(PageSize.A4, 10f, 10f, 10f, 10f))
                {
                    PdfWriter writer =&lt;span&gt; PdfWriter.GetInstance(pdfDoc, stream);
                    pdfDoc.Open();

                    //Add the Image file to the PDF document object.
                    iTextSharp.text.Image img =&lt;span&gt; iTextSharp.text.Image.GetInstance(bytes);
                    pdfDoc.Add(img);
                    pdfDoc.Close();

                    //Download the PDF file.
                    return File(stream.ToArray(), &quot;application/pdf&quot;, &quot;Chart.pdf&quot;&lt;span&gt;);
                }
            }
        }
        private static byte&lt;span&gt;[] PopulateChart()
        {
            List&amp;lt;OrderModel&amp;gt; chartData = new List&amp;lt;OrderModel&amp;gt;&lt;span&gt;();
            //根据id统计的脚本
            var objList = pdfcontextoBJ.Orders.GroupBy(u =&amp;gt;&lt;span&gt; u.ShipCity)
                                    .Select(s =&amp;gt; new&lt;span&gt;
                                    {
                                        TotalOrders =&lt;span&gt; s.Key,
                                        count =&lt;span&gt; s.Count()
                                    }).ToList().Take(5&lt;span&gt;).ToList();
            
            foreach (var item in&lt;span&gt; objList)
            {
                chartData.Add(new&lt;span&gt; OrderModel()
                {
                    TotalOrders =&lt;span&gt; item.count,
                     ShipCity =&lt;span&gt; item.TotalOrders
                });
            }
            Chart chart = new Chart(width: 500, height: 500&lt;span&gt;, theme: ChartTheme.Blue);
            chart.AddTitle(&quot;USA City Distribution&quot;&lt;span&gt;);
            chart.AddSeries(&quot;Default&quot;, chartType: &quot;Pie&quot;, xValue: chartData, xField: &quot;ShipCity&quot;, yValues: chartData, yFields: &quot;TotalOrders&quot;&lt;span&gt;);
            return chart.GetBytes(format: &quot;jpeg&quot;&lt;span&gt;);
        }
    }
}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 在view中定义如下：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@{
    Layout = null&lt;span&gt;;
}

&amp;lt;!DOCTYPE html&amp;gt;

&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot; /&amp;gt;
    &amp;lt;title&amp;gt;Index&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
    &amp;lt;img alt=&quot;Chart&quot; src=&quot;@ViewBag.ChartImageUrl&quot; style=&quot;height:300px; width:300px&quot; /&amp;gt;
    &amp;lt;br /&amp;gt;&lt;span&gt;
    @using (Html.BeginForm(&quot;Export&quot;, &quot;Pdf&quot;&lt;span&gt;, FormMethod.Post))
    {
        &amp;lt;input type=&quot;submit&quot; id=&quot;btnSubmit&quot; value=&quot;Export&quot; /&amp;gt;&lt;span&gt;
    }
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;效果图：&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1366751/201901/1366751-20190120130421922-193669155.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

</description>
<pubDate>Sun, 20 Jan 2019 05:08:00 +0000</pubDate>
<dc:creator>张子浩</dc:creator>
<og:description>样本： 在这个示例中，我们使用的是微软给我们提供的数据库，也就是家喻户晓的Northwind数据库。要下载Microsoft的免费样本Northwind数据库，您需要访问以下URL。下载Northwi</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/ZaraNet/p/10294602.html</dc:identifier>
</item>
<item>
<title>MongoDB加auth权限 - nobody-junior</title>
<link>http://www.cnblogs.com/imgss/p/10274813.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/imgss/p/10274813.html</guid>
<description>&lt;p&gt;吹个牛B，自己的MongoDB裸奔了快半年，从未遭受黑客攻击。也不知道是自己运气好，还是黑客对我的乞丐版服务器看不上眼。不过既然知道了数据库裸奔的危险性，就要给它上把锁。然而上锁对我这种刻意回避数据库知识的人来说，也实在不是一件容易的事。&lt;/p&gt;
&lt;p&gt;在学习上锁的过程中，看了好些文章。为了防止大家看我这篇没懂后还有的看，先给出参考文档：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;https://www.cnblogs.com/chunlei36/p/6506048.html&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/u012900400/article/details/79207822&lt;/li&gt;
&lt;li&gt;https://blog.csdn.net/wangmao01/article/details/80805643&lt;/li&gt;
&lt;/ul&gt;&lt;h3 id=&quot;裸奔有多危险&quot;&gt;裸奔有多危险&lt;/h3&gt;
&lt;p&gt;一句话，没有密码的数据库，而且又没有改27017这个MongoDB默认端口号，别人一个命令就可以连上去：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;
mongo 192.168.0.5:27017
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://www.infoq.cn/article/TL*mYAa6vjUb26gItCdY&quot;&gt;这篇文章&lt;/a&gt;也给出了关于MongoDB安全性的详细说明&lt;/p&gt;
&lt;p&gt;当然你可能说，他怎么知道我用的什么数据库，然后猜到我的端口。我在这里只能说，我们要相信黑客的技术😂。&lt;/p&gt;
&lt;h3 id=&quot;mongodb修改默认端口号&quot;&gt;mongoDB修改默认端口号&lt;/h3&gt;
&lt;p&gt;在设置权限之前，我们要首先改掉默认端口号，这是防止被攻击的第一步。&lt;/p&gt;
&lt;p&gt;修改默认端口号可分为两步，第一步，关掉MongoDB；第二步，用新的端口号启动MongoDB&lt;/p&gt;
&lt;h4 id=&quot;关闭mongodb&quot;&gt;关闭MongoDB&lt;/h4&gt;
&lt;p&gt;关闭MongoDB也有两种方式，第一是借助mongo shell，使用&lt;code&gt;db.shutdownServer()&lt;/code&gt;,第二是直接杀进程。&lt;/p&gt;
&lt;p&gt;shutdownServer的使用方法如下:&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 进入mongo shell
mongo

# 显示现有的数据库
show dbs

# 进入admin数据库
use admin

# 关闭数据库
db.shutdownServer()&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当然，我更喜欢另外一种简单粗暴的方式：kill&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# mac
lsof -i :27017

# centOS
netstat -pan | grep 27017

# 查到pid后，kill
kill 36954&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;重启mongodb&quot;&gt;重启MongoDB&lt;/h4&gt;
&lt;p&gt;重启MongoDB也有两种方式：命令行参数启动 和 加载配置文件启动。两者的唯一区别就是后面的方法将配置参数放到了一个配置文件之中。两种方法中，我们要做的都是改掉默认端口号，先来看第一种方式：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 这个命令可以查看mongod可以接受哪些参数
mongod --help

# -p 可以用来设置port端口号

mongod --fork --logpath 你的log存放路径 --dbpath  你的数据库存放路径 -p 12345 &lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里讲一下 --fork 的意思，如果不带这个参数，MongoDB的日志会在前台运行，日志会直接打印到shell里面。带上这个参数则会将MongoDB转到后台运行，同时将运行日志写到logpath里面,而不是直接打印到命令行。&lt;/p&gt;
&lt;h3 id=&quot;设置密码&quot;&gt;设置密码&lt;/h3&gt;
&lt;p&gt;接下来，讲到设置密码的关键环节了，没有密码，只改变端口，就好像把门从朝东改成了朝南，却还是没有上锁。所以再加上密码这一步才算安全。在设置MongoDB的密码前，我们要知道以下几点：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;每个数据库之间的密码是独立的。&lt;/li&gt;
&lt;li&gt;数据库权限是分角色的。&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这里不讲每个角色(role)有哪些权限，更多角色相关的内容可以参考&lt;a href=&quot;https://docs.mongodb.com/manual/core/security-built-in-roles/&quot;&gt;官方文档build-in roles&lt;/a&gt;。下面设置密码的步骤主要参考MongoDB官方文档:https://docs.mongodb.com/manual/tutorial/enable-authentication/&lt;/p&gt;
&lt;p&gt;第一步：开启MongoDB服务&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mongod --port 23456 --dbpath /data/db1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二步：进入MongoDB shell，类似于node.js的&lt;code&gt;node&lt;/code&gt;命令&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mongo --port 23456&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第三步：进入admin数据库，以 userAdminAnyDatabase 的角色创建admin账号，这个账号创建后，可以为任何数据库创建用户&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;use admin #进入admin数据库

# 创建admin账号
db.createUser(
  {
    user: &quot;myUserAdmin&quot;, #用户名
    pwd: &quot;abc123&quot;, #密码
    roles: [ { role: &quot;userAdminAnyDatabase&quot;, db: &quot;admin&quot; }, &quot;readWriteAnyDatabase&quot; ]
  }
)&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;创建完成后推出mongo shell。&lt;/p&gt;
&lt;p&gt;第四步：加入授权重启MongoDB，方法上面介绍过了，但是要加上授权参数&lt;code&gt;--auth&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;mongod --auth --port 23456 --dbpath /data/db1&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第五步：使用&lt;code&gt;--auth&lt;/code&gt;启动后，登录mongo shell就需要输入密码了，可以将账号密码放在一条命令中，也可以先进入shell，再输入账号密码鉴权，分别对应如下两条语句：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;

mongo --port 23456 -u &quot;myUserAdmin&quot; -p &quot;abc123&quot; --authenticationDatabase &quot;admin&quot;&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;或者先登录再使用auth授权&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 先进入mongo shell
mongo --port 23456

# 使用auth函数输入admin数据库的账号密码

use admin
db.auth(&quot;myUserAdmin&quot;, &quot;abc123&quot; )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第六步：你登录 admin 数据库后，就可以为别的业务数据库创建账号密码了，比如为 test 和 reporting数据库创建账号密码：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;use test # 进入test数据库
db.createUser(
  {
    user: &quot;myTester&quot;,
    pwd: &quot;xyz123&quot;,
    roles: [ { role: &quot;readWrite&quot;, db: &quot;test&quot; },
             { role: &quot;read&quot;, db: &quot;reporting&quot; } ]
  }
)
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第七步：推出shell后，现在可以用新创建的账号密码登录test数据库了：&lt;/p&gt;
&lt;pre class=&quot;bash&quot;&gt;
&lt;code&gt;# 直接登录
mongo --port 23456 -u &quot;myTester&quot; -p &quot;xyz123&quot; --authenticationDatabase &quot;test&quot;

# 连接后登录

mongo --port 23456

use test
db.auth(&quot;myTester&quot;, &quot;xyz123&quot; )&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;如果你用moogoose登录，那你的url应该改成如下格式：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;mongodb://myTester:xyz123@127.0.0.1:23456/test&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;本文完&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 04:25:00 +0000</pubDate>
<dc:creator>nobody-junior</dc:creator>
<og:description>吹个牛B，自己的MongoDB裸奔了快半年，从未遭受黑客攻击。也不知道是自己运气好，还是黑客对我的乞丐版服务器看不上眼。不过既然知道了数据库裸奔的危险性，就要给它上把锁。然而上锁对我这种刻意回避数据库</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/imgss/p/10274813.html</dc:identifier>
</item>
<item>
<title>MySQL基础架构 - ZYXS</title>
<link>http://www.cnblogs.com/zyxsblogs/p/10293977.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zyxsblogs/p/10293977.html</guid>
<description>&lt;p&gt;&lt;span&gt;前段时间订阅了《Mysql实战45讲》（从原理到实战）,新的一年为自己充充电。对于这部分内容，我所知道的只来源于我大学里学习的课程《数据库原理》，在大学里学习的只是简单的查询，增加，删除，索引，锁，触发器，视图等内容。几乎没有基础的架构知识。因此在这里巩固一下原理，学习一下数据库Mysql在原理上究竟是怎样的。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;首先我们一起看一个Mysql的基本架构示意图：&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1435526/201901/1435526-20190120093106712-587528614.png&quot; alt=&quot;&quot; width=&quot;707&quot; height=&quot;609&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;1、Mysql可以分为Server层和存储引擎层两部分。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;2、Server层：包含连接器，查询缓存，分析器，优化器，执行器等，涵盖了MySQL的大多数核心功能区以及所有的内置函数。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①内置函数：日期，时间，数学和加密函数等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②所有跨存储引擎的功能都在这一层实现，例如存储过程，触发器，视图等；&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;3、存储引擎层：负责数据的存储和提取。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;①架构模式：插件式的，支持InnoDB（目前也是最常用的，MySQL5.5后默认存储引擎）、MyISAM、Memory等多个存储引擎。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;②create table 时不指定引擎类型，默认使用的就是InnoDB.如果使用其他类型，可以利用create table语句中使用engine=memory，等来指定使用内存引擎来创建表。不同的存储引擎数据存储方式不同，支持的功能也不同。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;4、不同的存储引擎共用一个server层，结合一个例子我们从总体上了解一下各部件的功能。&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; T &lt;span&gt;where&lt;/span&gt; ID&lt;span&gt;=&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt; 开启探索之旅：&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;一　　连接器&lt;/strong&gt;&lt;/span&gt;：&lt;span&gt;负责跟客户端建立连接，获取权限，维持和管理连接，这个连接器位于&lt;span&gt;server层&lt;/span&gt;&lt;span&gt;，我们通过连接器可以让客户端和server层连接起来，从而登录到mysql。连接命名一般就这样搞：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql &lt;span&gt;-&lt;/span&gt;h$ip &lt;span&gt;-&lt;/span&gt;P$port &lt;span&gt;-&lt;/span&gt;u$&lt;span&gt;user&lt;/span&gt; &lt;span&gt;-&lt;/span&gt;p
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　&lt;span&gt;　&lt;span&gt;在命令输完之后，我们需要在交互界面输入密码。虽然在-p后面我们可以把密码直接写上，但是安全性你懂得，如果我们连接的是生产服务器，强烈建议不要这样干！&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;连接过程是怎样的呢？&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;span&gt;链接命令中的mysql是客户端工具，用来跟服务器建立连接。（本菜鸟一直使用图形话的工具很少思考这方面的内容，实在是羞愧啊！只看到了表面，很少思考内在的东西！）&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;经典的TCP握手之后，服务器开始验证身份。我们这个时候要用到输入的用户名和密码：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;①如果用户名和密码不对，我们会被反馈“Access denied for user”的错误，然后就死翘翘了，(客户端程序结束执行）。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;②如果用户名和密码正确，连接器回到权限表里找到我们所拥有的权限。&lt;strong&gt;&lt;span&gt;之后在这个连接面里的权限判断逻辑，都会依赖于此时读到的权限。（&lt;span&gt;如果一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响到已经存在连接的权限，修改完成后，只有在新建的连接才会使用新的权限设置&lt;/span&gt;）；&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;连接完成之后呢？&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;　&lt;span&gt;　①如果你没有后续的动作，这个连接就会空闲下来，使用&lt;/span&gt;&lt;/span&gt;&lt;span&gt;show processlist 命令中看到它。&lt;br/&gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　②客户端如果太长时间没用动静，连接器就会自动断开，这个时间是由wait_timeout控制的，默认是8小时。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　如果在连接被断开之后，客户端再次发送请求的话，就会收到一个错误的提醒：Lost connection to Mysql server during query。这时候如果要继续，就需要重连，然后在执行请求了。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;&lt;span&gt;&lt;span&gt;长连接和短连接：&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　&lt;span&gt;　&lt;span&gt;长连接&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;&lt;span&gt;：在数据库里面，长连接是指连接成功之后，如果客户端持续有请求，则一直使用同一个连接。&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;　　&lt;span&gt;短连接&lt;/span&gt;&lt;/span&gt;&lt;/strong&gt;：指的是每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　建立连接的过程很复杂，建议在使用中尽量减少建立连接的动作，也就是尽量使用长连接；&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;strong&gt;&lt;span&gt;问题：但是如果全部使用长连接的话，你可能会发现Mysql占用内存特别快。&lt;/span&gt;&lt;/strong&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;原因&lt;/strong&gt;：MySQL在执行的时候临时使用的内存是管理在连接对象里面的，这些资源会在连接断开的时候释放，所以如果长连接列累积下来，可能会导致内存占用太大，被系统强制杀死（OOM）：&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;表现&lt;/strong&gt;：MySQL异常重启。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;/span&gt;①定期断开长连接，使用一段时间，或者程序里面判断执行过一个占内存的大查询后，断开连接，之后要查询再重连。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　②如果使用的是MySQL 5.7或者更高的版本，可以在每次执行一个比较大的操作后，通过执行mysql_reset_connection来重新初始化链接资源。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;二  查询缓存&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;查询缓存：在连接建立完成之后，我们就可以执行select语句了。具体过程是怎样的呢？&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;　　MySQL拿到一个查询请求之后，会到查询缓存看看，之前是否执行过这样的一条语句，之前执行过的语句及其结果可能会以key-value对的形式，被直接存放到内存中，key是查询的语句，value是查询的结果，如果你的查询能够直接在这个缓存中找到key,那么这个value就会被直接返回给客户端。&lt;/span&gt;&lt;span&gt;如果语句不在查询缓存中，就会继续后面的执行阶段，执行完成后，执行结果会被存入到查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;但是大多数情况下我会建议你不要使用查询缓存，为什么呢？&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;　　因为查询缓存往往弊大于利。 查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;好在MySQL也提供了这种“按需使用”的方式。你可以&lt;span&gt;将参数query_cache_type设置成DEMAND，这样对于默认的SQL语句都不使用查询缓存&lt;/span&gt;。而对于你&lt;span&gt;确定要使用查询缓存的语句，可以用SQL_CACHE显式指定&lt;/span&gt;，像下面这个语句一样：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; SQL_CACHE &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; T &lt;span&gt;where&lt;/span&gt; ID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;；
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了。 &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;三 分析器（关于词法分析和语法分析的内容可以看《编译原理》）&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;如果没有命中缓存，就要开始真正的执行SQL语句了，首先SQL语句需要知道你在做什么，因此需要对SQL语句做出解析。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;分析器做的工作如下：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; T &lt;span&gt;where&lt;/span&gt; ID&lt;span&gt;=&lt;/span&gt;;（以这个语句为例子）&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;词法分析：你输入的是由多个字符串和空格组成的一条SQL语句，Mysql需要识别出里面的字符分别是什么，代表什么。MySQL从你输入的“select”这个关键子识别出来，这是一条查询语句，他也要把字符串“T”识别成“表名T”,把字符串“ID”识别成“列ID”。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;语法分析：根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个SQL语句是否满足MySQL语法。如果你输入的语句不对，你会收到“you have an error in your SQL syntax”的错误提醒，比如下面这个语句select少打了一个字母&quot;S&quot;.&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;mysql&lt;span&gt;&amp;gt;&lt;/span&gt; elect &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; t &lt;span&gt;where&lt;/span&gt; ID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;1&lt;/span&gt;&lt;span&gt;;
ERROR &lt;/span&gt;&lt;span&gt;1064&lt;/span&gt; (&lt;span&gt;42000&lt;/span&gt;): You have an error &lt;span&gt;in&lt;/span&gt; your SQL syntax; &lt;span&gt;check&lt;/span&gt; the manual that corresponds &lt;span&gt;to&lt;/span&gt;&lt;span&gt; your MySQL
server version &lt;/span&gt;&lt;span&gt;for&lt;/span&gt; the &lt;span&gt;right&lt;/span&gt; syntax &lt;span&gt;to&lt;/span&gt; &lt;span&gt;use&lt;/span&gt; near &lt;span&gt;'&lt;/span&gt;&lt;span&gt;elect * from t where ID=1&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; at line &lt;span&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;span&gt;一般来说语法错误会提示第一个出现错误的位置，所以你要关注的是紧接“use near”的内容。&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;四 优化器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;经过了分析器，MySQL就知道你要做什么了，在开始执行之前，还要经过优化器的处理。&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;&lt;span&gt;　　优化器是在表里面有多个索引的时候，决定使用哪个索引；&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;　　在一个语句有多表关联（join）的时候，决定各个表的连接顺序。&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;span&gt;比如你执行下面这样的语句，这个语句是执行两个表的join：&lt;/span&gt;&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; t1 &lt;span&gt;join&lt;/span&gt; t2 using(ID) &lt;span&gt;where&lt;/span&gt; t1.c&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10&lt;/span&gt; &lt;span&gt;and&lt;/span&gt; t2.d&lt;span&gt;=&lt;/span&gt;&lt;span&gt;20&lt;/span&gt;;
&lt;/pre&gt;&lt;/div&gt;
&lt;ul&gt;&lt;li&gt;&lt;span&gt;既可以先从表t1里面取出c=10的记录的ID值，再根据ID值关联到表t2，再判断t2里面d的值是否等于20。&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span&gt;也可以先从表t2里面取出d=20的记录的ID值，再根据ID值关联到t1，再判断t1里面c的值是否等于10。&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span&gt;这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪 一个方案。 优化器阶段完成后，这个语句的执行方案就确定下来了，然后进入执行器阶段.&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;span&gt;五 执行器&lt;/span&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;MySQL通过分析器知道你要干啥了，通过优化器知道该怎么去干了。于是就进入到执行器阶段了，开始干活！&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span&gt;其中的流程如下：&lt;/span&gt;&lt;/p&gt;
&lt;ol&gt;&lt;li readability=&quot;-1.5&quot;&gt;判断你是否对这个表T有没有查询的权限，如果没有，就会返回没有权限的错误，如下所示：
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
mysql&lt;span&gt;&amp;gt;&lt;/span&gt; &lt;span&gt;select&lt;/span&gt; &lt;span&gt;*&lt;/span&gt; &lt;span&gt;from&lt;/span&gt; T &lt;span&gt;where&lt;/span&gt; ID&lt;span&gt;=&lt;/span&gt;&lt;span&gt;10&lt;/span&gt;;ERROR &lt;span&gt;1142&lt;/span&gt; (&lt;span&gt;42000&lt;/span&gt;): &lt;span&gt;SELECT&lt;/span&gt; command denied &lt;span&gt;to&lt;/span&gt; &lt;span&gt;user&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;b&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;@&lt;span&gt;'&lt;/span&gt;&lt;span&gt;localhos&lt;/span&gt;&lt;span&gt;'&lt;/span&gt; &lt;span&gt;for&lt;/span&gt; &lt;span&gt;table&lt;/span&gt; &lt;span&gt;'&lt;/span&gt;&lt;span&gt;T&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt; 判断如果你有权限，那就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。例如我们的这个例子中的表T中，ID字段没有索引，那么执行器的执行流程是这样的：&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;　　　　1、调用InnoDB引擎接口取这个表的第一行，判断ID的值是不是10，如果不是则跳过，如果是则将这行存在结果集中；&lt;/p&gt;
&lt;p&gt;　　　　2、调用引擎接口取“下一行”，重复相同的判断逻辑，直到取到这个表的最后一行；&lt;/p&gt;
&lt;p&gt;　　　　3、执行器将上述遍历过程中所有满足条件的行组成记录集作为结果集返回给客户端。&lt;/p&gt;
&lt;p&gt;至此这个语句结束了。&lt;/p&gt;
&lt;p&gt;对于有索引的表，执行的逻辑也差不多，第一次调用的是“取满足条件的第一行”这个接口，之后循环取“满足条件的下一行”这个接口，这写接口都是引擎中定义好的。&lt;/p&gt;
&lt;p&gt;你会在数据库的慢查询日志中看到看一个rows_examined字段，表示这个语句执行过程中扫描了多少行，这个值就是在执行器每次调用引擎获取数据行的时候累加的。&lt;/p&gt;
&lt;p&gt;在有些场景下，执行器调用一次，在引擎内部则扫描了很多行，因此引擎扫描行数跟rows_examined并不是完全相同的。&lt;/p&gt;
&lt;p&gt;逻辑架构大体就是这样子了。&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 04:00:00 +0000</pubDate>
<dc:creator>ZYXS</dc:creator>
<og:description>前段时间订阅了《Mysql实战45讲》（从原理到实战）,新的一年为自己充充电。对于这部分内容，我所知道的只来源于我大学里学习的课程《数据库原理》，在大学里学习的只是简单的查询，增加，删除，索引，锁，触</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/zyxsblogs/p/10293977.html</dc:identifier>
</item>
<item>
<title>分布式文件系统之FastDFS - 佳先森</title>
<link>http://www.cnblogs.com/cailijia52o/p/10263514.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cailijia52o/p/10263514.html</guid>
<description>&lt;h3&gt;环境引入：&lt;/h3&gt;
&lt;p&gt;　　在一个大型的教育官网，会拥有大量优质的视频教程，并且免费提供给用户去下载，文件太多如果高效存储？用户访问量大如何保证下载速度？分布式文件系统是解决这些问题的有效方法之一&lt;/p&gt;
&lt;h2&gt;一、什么是文件系统&lt;/h2&gt;
&lt;p&gt;　　分布式文件系统（Distributed File System）是指文件系统管理的物理存储资源不一定直接连接在本地节点上，而是通过计算机网络与节点相连。分布式文件系统的设计基于客户机/服务器模式。一个典型的网络可能包括多个供多用户访问的服务器。另外，对等特性允许一些系统扮演客户机和服务器的双重角色。例如，用户可以“发表”一个允许其他客户机访问的目录，一旦被访问，这个目录对客户机来说就像使用本地&lt;a href=&quot;https://baike.baidu.com/item/%E9%A9%B1%E5%8A%A8%E5%99%A8/310105&quot; target=&quot;_blank&quot; data-lemmaid=&quot;310105&quot;&gt;驱动器&lt;/a&gt;一样。&lt;/p&gt;
&lt;p&gt; 　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　-----------------百度百科&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么需要&lt;/strong&gt;：以前，我们将上传的视屏文件等放在一台宿主机内，如果一个盘符内存不够，就增加硬盘个数，但是单纯的增加硬盘个数已经无法满足当代的需求，毕竟硬盘访问速度有限&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方式&lt;/strong&gt;：增加计算机个数，将视屏分别放在不同计算机内，通过网络将一个一个计算机的文件系统连接起来组成一个网络文件系统，形成一个分布式网络&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：用于扩容、高并发场景&lt;/p&gt;
&lt;p&gt;　　　　1、一台计算机的文件系统处理能力扩充到多台计算机内同时处理&lt;/p&gt;
&lt;p&gt;　　　　2、一台计算机挂了还有另外副本计算提供数据&lt;/p&gt;
&lt;p&gt;　　　　3、每台计算机可以放在不同的地域，这样用户就可以就近访问，提高访问速度&lt;/p&gt;
&lt;h2&gt; 二、分布式文件服务提供商&lt;/h2&gt;
&lt;p&gt; 　　1、阿里的OSS&lt;/p&gt;
&lt;p&gt;　　 2、七牛云存储&lt;/p&gt;
&lt;p&gt;　　 3、百度云储存&lt;/p&gt;
&lt;h2&gt;三、什么是fastDFS&lt;/h2&gt;
&lt;div class=&quot;para&quot; readability=&quot;10.289230769231&quot;&gt;　　FastDFS是一个开源的轻量级&lt;a href=&quot;https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%BC%8F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/1250388&quot; target=&quot;_blank&quot; data-lemmaid=&quot;1250388&quot;&gt;分布式文件系统&lt;/a&gt;，它对文件进行管理，功能包括：文件存储、文件同步、文件访问（文件上传、文件下载）等，解决了大容量存储和负载均衡的问题。特别适合以文件为载体的在线服务，如相册网站、视频网站等等。&lt;/div&gt;
&lt;p&gt;FastDFS为互联网量身定制，充分考虑了冗余备份、负载均衡、线性扩容等机制，并注重高可用、高性能等指标，使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。&lt;/p&gt;
&lt;p&gt;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　           　　-----百度百科&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226944/201901/1226944-20190120103137140-696556272.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226944/201901/1226944-20190120103152475-149395923.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;　　            　　图片来源于百度百科&lt;/p&gt;

&lt;h2&gt;四、fastdfs安装:&lt;/h2&gt;
&lt;p&gt;　　1、安装编译环境&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@bogon ~]# docker exec -it centos /bin/&lt;span&gt;bash
[root@0b5933e7fd96 &lt;/span&gt;/]# yum -y groupinstall &lt;span&gt;'&lt;/span&gt;&lt;span&gt;Development Tools&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;
[root@0b5933e7fd96 &lt;/span&gt;/]# yum -y install wget
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　2、下载安装libfastcommon&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@0b5933e7fd96 /]#git clone https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/happyfish100/libfastcommon.git&lt;/span&gt;
[root@0b5933e7fd96 /]#cd libfastcommon/&lt;span&gt;
[root@0b5933e7fd96 &lt;/span&gt;/]#./&lt;span&gt;make.sh
[root@0b5933e7fd96 &lt;/span&gt;/]#./make.sh install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　3、下载安装fastdfs&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@0b5933e7fd96 /]#wget https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;github.com/happyfish100/fastdfs/archive/V5.05.tar.gz&lt;/span&gt;
[root@0b5933e7fd96 /]#tar -zxvf V5.&lt;span&gt;05&lt;/span&gt;&lt;span&gt;.tar.gz
[root@0b5933e7fd96 &lt;/span&gt;/]#cd fastdfs-&lt;span&gt;5.05&lt;/span&gt;/&lt;span&gt;
[root@0b5933e7fd96 &lt;/span&gt;/]#./&lt;span&gt;make.sh
[root@0b5933e7fd96 &lt;/span&gt;/]#./make.sh install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　4、修改tracker与storage配置文件命名&lt;/p&gt;
&lt;p&gt;　　 　　备份tracker与storage配置文件，为了防止数据文件的破坏&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@0b5933e7fd96 /]# find / -&lt;span&gt;name fdfs
&lt;/span&gt;/etc/&lt;span&gt;fdfs
[root@0b5933e7fd96 fdfs]# ll
total &lt;/span&gt;&lt;span&gt;40&lt;/span&gt;
-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1461&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;&lt;span&gt; client.conf.sample
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;7829&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;&lt;span&gt; storage.conf.sample
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;7102&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;&lt;span&gt; tracker.conf.sample
[root@0b5933e7fd96 fdfs]# cp client.conf.sample client.conf
[root@0b5933e7fd96 fdfs]#cp storage.conf.sample storage.conf
[root@0b5933e7fd96 fdfs]#cp tracker.conf.sample tracker.conf
[root@0b5933e7fd96 fdfs]# ll
total &lt;/span&gt;&lt;span&gt;40&lt;/span&gt;
-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1461&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;14&lt;/span&gt;&lt;span&gt; client.conf
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;1461&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;&lt;span&gt; client.conf.sample
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;7836&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;30&lt;/span&gt;&lt;span&gt; storage.conf
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;7829&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt;&lt;span&gt; storage.conf.sample
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;7103&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;28&lt;/span&gt;&lt;span&gt; tracker.conf
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;7102&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;02&lt;/span&gt;:&lt;span&gt;08&lt;/span&gt; tracker.conf.sample
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　5、配置tracker&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
[root@0b5933e7fd96 fdfs]# vi tracker.conf
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
disabled=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
port&lt;/span&gt;=&lt;span&gt;22122&lt;/span&gt;&lt;span&gt;
base_path&lt;/span&gt;=/home/fastdfs/&lt;span&gt;tracker
http.server_port&lt;/span&gt;=&lt;span&gt;8080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　7、配置storage&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
disabled=&lt;span&gt;false&lt;/span&gt;&lt;span&gt;
group_name&lt;/span&gt;=&lt;span&gt;group1
port&lt;/span&gt;=&lt;span&gt;23000&lt;/span&gt;&lt;span&gt;
base_path&lt;/span&gt;=/home/fastdfs/&lt;span&gt;storage&lt;br/&gt;store_path0=/home/fastdfs/storage-data
tracker_server&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;174.128&lt;/span&gt;:&lt;span&gt;22122&lt;/span&gt;&lt;span&gt;
http.server_port&lt;/span&gt;=&lt;span&gt;8888&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8、配置路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@0b5933e7fd96 home]# ll 
total &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
drwxr&lt;/span&gt;-xr-x. &lt;span&gt;5&lt;/span&gt; root root &lt;span&gt;53&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt;&lt;span&gt; fastdfs
[root@0b5933e7fd96 home]# cd fastdfs&lt;/span&gt;/&lt;span&gt;
[root@0b5933e7fd96 fastdfs]# ll
total &lt;/span&gt;&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
drwxr&lt;/span&gt;-xr-x. &lt;span&gt;3&lt;/span&gt; root root &lt;span&gt;17&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt;&lt;span&gt; storage
drwxr&lt;/span&gt;-xr-x. &lt;span&gt;2&lt;/span&gt; root root  &lt;span&gt;6&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;26&lt;/span&gt; storage-&lt;span&gt;data
drwxr&lt;/span&gt;-xr-x. &lt;span&gt;4&lt;/span&gt; root root &lt;span&gt;28&lt;/span&gt; Jan &lt;span&gt;13&lt;/span&gt; &lt;span&gt;03&lt;/span&gt;:&lt;span&gt;31&lt;/span&gt; tracker
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;　　8、启动tracker和storage&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@0b5933e7fd96 fdfs]# /usr/bin/fdfs_trackerd /etc/fdfs/&lt;span&gt;tracker.conf restart
[root@0b5933e7fd96 fdfs]# &lt;/span&gt;/usr/bin/fdfs_storaged /etc/fdfs/&lt;span&gt;storage.conf restart
[root@0b5933e7fd96 storage&lt;/span&gt;-data]# ps -ef |&lt;span&gt; grep fdfs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;五、构建JAVA Client API&lt;/h2&gt;
&lt;p&gt;github访问地址：https://github.com/happyfish100/fastdfs-client-java&lt;/p&gt;
&lt;p&gt;搭建环境 &lt;/p&gt;
&lt;p&gt;1、创建一个maven工程&lt;/p&gt;
&lt;p&gt;2、添加依赖&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&amp;lt;parent&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-boot-parent&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;1.5.9.RELEASE&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/parent&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;cn.ibo&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;fastdfs&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;dependencies&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-web&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;net.oschina.zcx7878&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;fastdfs-client-java&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;1.27.0.0&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;spring-boot-starter-test&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;dependency&amp;gt;&lt;br/&gt;&amp;lt;groupId&amp;gt;org.apache.commons&amp;lt;/groupId&amp;gt;&lt;br/&gt;&amp;lt;artifactId&amp;gt;commons-io&amp;lt;/artifactId&amp;gt;&lt;br/&gt;&amp;lt;version&amp;gt;1.3.2&amp;lt;/version&amp;gt;&lt;br/&gt;&amp;lt;/dependency&amp;gt;&lt;br/&gt;&amp;lt;/dependencies&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、新增配置文件fastdfs-client.properties&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
## fastdfs-&lt;span&gt;client.properties

fastdfs.connect_timeout_in_seconds &lt;/span&gt;= &lt;span&gt;5&lt;/span&gt;&lt;span&gt;
fastdfs.network_timeout_in_seconds &lt;/span&gt;= &lt;span&gt;30&lt;/span&gt;&lt;span&gt;

fastdfs.charset &lt;/span&gt;= UTF-&lt;span&gt;8&lt;/span&gt;&lt;span&gt;

fastdfs.http_anti_steal_token &lt;/span&gt;= &lt;span&gt;false&lt;/span&gt;&lt;span&gt;
fastdfs.http_secret_key &lt;/span&gt;=&lt;span&gt; FastDFS1234567890
fastdfs.http_tracker_http_port &lt;/span&gt;= &lt;span&gt;80&lt;/span&gt;&lt;span&gt;

fastdfs.tracker_servers &lt;/span&gt;= &lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;174.128&lt;/span&gt;:&lt;span&gt;22122&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt; 4、编写测试类&lt;/p&gt;
&lt;p&gt;　　4.1) 上传&lt;/p&gt;
&lt;p&gt;　　需求:将window 盘符下的指定文件通过fastFDS上传到linux指定目录下&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;40&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by 佳先森 on 2019/1/13.
 * 在此文件中通过fastDSF的client代码访问tracker和storage
 * 通过client的api代码访问tracker和storage,他们中间走的socket协议
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; TestFastDFS {
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt; 测试文件上传&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testUpload(){
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过fastDSF的client代码访问tracker和storage&lt;/span&gt;
        String local_filename = &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;77.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;上传文件名&lt;/span&gt;
        &lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载fastDFS客户端的配置文件&lt;/span&gt;
            ClientGlobal.initByProperties(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config/fastdfs-client.properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;network_timeout=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + ClientGlobal.g_network_timeout + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;charset=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ClientGlobal.g_charset);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建tracker的客户端&lt;/span&gt;
            TrackerClient tracker = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TrackerClient();
            TrackerServer trackerServer &lt;/span&gt;=&lt;span&gt; tracker.getConnection();
            StorageServer storageServer &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义storage的客户端&lt;/span&gt;
            StorageClient1 client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StorageClient1(trackerServer, storageServer);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件元数据(如文件名称大小等)&lt;/span&gt;
            NameValuePair[] metaList = &lt;span&gt;new&lt;/span&gt; NameValuePair[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            metaList[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; NameValuePair(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fileName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,local_filename);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是个数组，可以继续添加
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行上传&lt;/span&gt;
            String fileId = client.upload_file1(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;E:\\壁纸\\77.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;, metaList);
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;upload success. file id is: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; fileId);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭trackerServer的连接&lt;/span&gt;
&lt;span&gt;            trackerServer.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            ex.printStackTrace();
        }
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226944/201901/1226944-20190113211925131-1264119333.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;验证：此时在storage-data目录下可以看到上传的文件&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@bogon &lt;span&gt;00&lt;/span&gt;&lt;span&gt;]# pwd
&lt;/span&gt;/home/fastdfs/storage-data/data/&lt;span&gt;00&lt;/span&gt;/&lt;span&gt;00&lt;/span&gt;&lt;span&gt;
[root@bogon &lt;/span&gt;&lt;span&gt;00&lt;/span&gt;&lt;span&gt;]# ll
&lt;/span&gt;-rw-r--r--. &lt;span&gt;1&lt;/span&gt; root root &lt;span&gt;55310&lt;/span&gt; 1月  &lt;span&gt;13&lt;/span&gt; &lt;span&gt;21&lt;/span&gt;:&lt;span&gt;15&lt;/span&gt; wKiugFw7OeSAMlI9AADYDjkgjlY905.jpg
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4.2)  检索&lt;/p&gt;
&lt;p&gt;　　根据控制台打印的信息，利用文件ID检索文件信息&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;37&quot;&gt;
&lt;pre&gt;
&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询上传的文件&lt;/span&gt;
&lt;span&gt;    @Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; testSearch(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载fastDFS客户端的配置文件&lt;/span&gt;
            ClientGlobal.initByProperties(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config/fastdfs-client.properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;network_timeout=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + ClientGlobal.g_network_timeout + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;charset=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ClientGlobal.g_charset);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建tracker的客户端&lt;/span&gt;
            TrackerClient tracker = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TrackerClient();
            TrackerServer trackerServer &lt;/span&gt;=&lt;span&gt; tracker.getConnection();
            StorageServer storageServer &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义storage的客户端&lt;/span&gt;
            StorageClient1 client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StorageClient1(trackerServer, storageServer);
            FileInfo group1 &lt;/span&gt;= client.query_file_info(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;, &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;M00/00/00/wKiugFw7OeSAMlI9AADYDjkgjlY905.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            FileInfo fileInfo &lt;/span&gt;= client.query_file_info1(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1/M00/00/00/wKiugFw7OeSAMlI9AADYDjkgjlY905.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(group1);
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;&lt;span&gt;.println(fileInfo);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;查询文件元信息&lt;/span&gt;
            NameValuePair[] metadata1 = client.get_metadata1(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1/M00/00/00/wKiugFw7OeSAMlI9AADYDjkgjlY905.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            &lt;/span&gt;&lt;span&gt;for&lt;/span&gt;&lt;span&gt;(NameValuePair temp:metadata1){
                System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.print(temp.getName()+&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;\t&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;+&lt;span&gt;temp.getValue());
            }
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭trackerServer的连接&lt;/span&gt;
&lt;span&gt;            trackerServer.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            ex.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226944/201901/1226944-20190113215014803-2070318035.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;4.3) 下载文件&lt;/p&gt;
&lt;p&gt;　　根据文件ID下载文件到指定目录&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;36&quot;&gt;
&lt;pre&gt;
&lt;span&gt;@Test
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; downLoad(){
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载fastDFS客户端的配置文件&lt;/span&gt;
            ClientGlobal.initByProperties(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config/fastdfs-client.properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;network_timeout=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + ClientGlobal.g_network_timeout + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;charset=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ClientGlobal.g_charset);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建tracker的客户端&lt;/span&gt;
            TrackerClient tracker = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TrackerClient();
            TrackerServer trackerServer &lt;/span&gt;=&lt;span&gt; tracker.getConnection();
            StorageServer storageServer &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义storage的客户端&lt;/span&gt;
            StorageClient1 client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StorageClient1(trackerServer, storageServer);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;下载&lt;/span&gt;
            &lt;span&gt;byte&lt;/span&gt;[] bytes = client.download_file1(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;group1/M00/00/00/wKiugFw7OeSAMlI9AADYDjkgjlY905.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            File file &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt; File(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;e:/a.jpg&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            FileOutputStream fos &lt;/span&gt;= &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileOutputStream(file);
            fos.write(bytes);
            fos.close();
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭trackerServer的连接&lt;/span&gt;
&lt;span&gt;            trackerServer.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            ex.printStackTrace();
        }
    }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226944/201901/1226944-20190113215124513-1844835498.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;六、文件服务案列&lt;/h2&gt;
&lt;p&gt;　　先将文件存放到临时目录，再通过tracker server将临时文件上传到fastdfs中的storage中&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226944/201901/1226944-20190120104708775-22588068.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;注意：得先安装&lt;strong&gt;fastdfs-nginx-module，再安装nginx，在编译nginx过程中添加&lt;/strong&gt;fastdfs-nginx-module，顺序弄反，会报&lt;/p&gt;
&lt;p class=&quot;title-article&quot;&gt;[emerg] unknown directive &quot;ngx_fastdfs_module&quot; ngix整合fastdfs启动后报错&lt;/p&gt;
&lt;p&gt;　　FastDFS通过Tracker服务器,将文件放在Storage服务器存储，但是同组存储服务器之间需要进入文件复制，有同步延迟的问题。假设Tracker服务器将文件上传到了192.168.4.125，上传成功后文件ID已经返回给客户端。此时FastDFS存储集群机制会将这个文件同步到同组存储192.168.4.126，在文件还没有复制完成的情况下，客户端如果用这个文件ID在192.168.4.126上取文件,就会出现文件无法访问的错误。而fastdfs-nginx-module可以重定向文件连接到源服务器取文件,避免客户端由于复制延迟导致的文件无法访问错误。&lt;/p&gt;
&lt;p&gt;1、安装&lt;strong&gt;fastdfs-nginx-module&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参考博客:https://blog.csdn.net/u010098331/article/details/51646921&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
[root@bogon local]# wget https:&lt;span&gt;//&lt;/span&gt;&lt;span&gt;sourceforge.net/projects/fastdfs/files/FastDFS%20Nginx%20Module%20Source%20Code/fastdfs-nginx-module_v1.16.tar.gz&lt;/span&gt;
[root@bogon local]# tar xf fastdfs-nginx-module_v1.&lt;span&gt;16&lt;/span&gt;&lt;span&gt;.tar.gz 
[root@bogon local]# cd fastdfs&lt;/span&gt;-nginx-module/src/&lt;span&gt;
[root@bogon local]# vim config
&lt;span&gt;#编辑config文件，执行如下命令进行批量替换并保存退出，目的：去掉local前缀，指定正确路径目录&lt;/span&gt;
:&lt;/span&gt;%s+/usr/local/+/usr/+g
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@bogon src]# pwd
&lt;/span&gt;/usr/local/fastdfs-nginx-module/&lt;span&gt;src
[root@bogon src]# cp mod_fastdfs.conf &lt;/span&gt;/etc/&lt;span&gt;fdfs
[root@bogon local]# cd &lt;/span&gt;/etc/&lt;span&gt;fdfs
[root@bogon fdfs]# vim mod_fastdfs.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#修改内容如下：
connect_timeout&lt;/span&gt;=&lt;span&gt;10&lt;/span&gt;&lt;span&gt;
base_path&lt;/span&gt;=/tmp（默认为/&lt;span&gt;tmp）
tracker_server&lt;/span&gt;=&lt;span&gt;192.168&lt;/span&gt;.&lt;span&gt;174.128&lt;/span&gt;:&lt;span&gt;22122&lt;/span&gt;&lt;span&gt;
storage_server_port&lt;/span&gt;=&lt;span&gt;23000&lt;/span&gt;&lt;span&gt;（默认配置为23000）
url_have_group_name &lt;/span&gt;= &lt;span&gt;true&lt;/span&gt;&lt;span&gt;
store_path0&lt;/span&gt;=/home/fastdfs/storage-&lt;span&gt;data
group_name&lt;/span&gt;=group1（默认配置为group1）
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
[root@bogon fastdfs-&lt;span&gt;5.05&lt;/span&gt;&lt;span&gt;]# pwd
&lt;/span&gt;/usr/java/fastdfs-&lt;span&gt;5.05&lt;/span&gt;&lt;span&gt;
[root@bogon fastdfs&lt;/span&gt;-&lt;span&gt;5.05&lt;/span&gt;&lt;span&gt;]# cd conf
[root@bogon conf]# cp http.conf &lt;/span&gt;/etc/&lt;span&gt;fdfs
[root@bogon conf]# cp mime.types &lt;/span&gt;/etc/fdfs
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装nginx&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
[root@bogon local]# tar -zxvf nginx-&lt;span&gt;1.6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;
[root@bogon local]# cd nginx&lt;/span&gt;-&lt;span&gt;1.6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;/&lt;span&gt;
[root@bogon nginx&lt;/span&gt;-&lt;span&gt;1.6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;&lt;span&gt;]#
.&lt;/span&gt;/configure --prefix=/usr/local/nginx --add-module=/usr/local/fastdfs-nginx-module/&lt;span&gt;src
[root@bogon nginx&lt;/span&gt;-&lt;span&gt;1.6&lt;/span&gt;.&lt;span&gt;0&lt;/span&gt;]#make &amp;amp;&amp;amp; make install
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@bogon local]# cd nginx
[root@bogon nginx]# cd conf
[root@bogon conf]# vim nginx.conf&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
 location /group1/&lt;span&gt;M00 {
                root &lt;/span&gt;/home/fastdfs/storage-&lt;span&gt;data;
                ngx_fastdfs_module;
            }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;[root@bogon conf]# cd ..
[root@bogon nginx]# cd sbin&lt;/span&gt;/&lt;span&gt;
[root@bogon sbin]# .&lt;/span&gt;/&lt;span&gt;nginx
ngx_http_fastdfs_set pid&lt;/span&gt;=&lt;span&gt;11005&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;配置nginx：&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server {
        listen       &lt;/span&gt;&lt;span&gt;80&lt;/span&gt;&lt;span&gt;;
        server_name  localhost;

        #charset koi8&lt;/span&gt;-&lt;span&gt;r;

       #access_log  logs&lt;/span&gt;/&lt;span&gt;host.access.log  main;
        location &lt;/span&gt;/group1/&lt;span&gt;M00 {
           root &lt;/span&gt;/home/fastdfs/storage-data/&lt;span&gt;data;    &lt;span&gt;#storage_path0&lt;/span&gt;
           ngx_fastdfs_module;　　　　　　　　　　　　　&lt;span&gt;#虚拟模块&lt;/span&gt;
        }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时根据刚刚测试类中上传的文件利用nginx访问：如果nginx能够正常访问表示配置nginx成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226944/201901/1226944-20190117213245354-1412463966.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这是通过http的方式(集成nginx)访问上传图片&lt;/p&gt;
&lt;h2&gt;七、搭建文件管理服务&lt;/h2&gt;
&lt;p&gt;　　文件管理服务提供通过http方式上传文件、删除文件、查询文件的功能，管理员通过文件管理服务队文件服务器上的文件进行管理&lt;/p&gt;
&lt;p&gt;　　文件管理服务采用Spring Boot开发，文件管理服务通过与fastDFS交互最终将用户上传的文件存储到fastDFS上&lt;/p&gt;
&lt;p&gt;1、建立实体类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by 佳先森 on 2019/1/13.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;
&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileSystem {
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String fileId;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String filePath;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt; &lt;span&gt;long&lt;/span&gt;&lt;span&gt; fileSize;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String fileName;
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String fileType;
    &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;省去set/get&lt;/span&gt;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;2、编写配置文件application.yml&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;32&quot;&gt;
&lt;pre&gt;
&lt;span&gt;server:
  port: &lt;/span&gt;&lt;span&gt;22100&lt;/span&gt;&lt;span&gt;

fastdfs:
  #文件上传临时目录
  upload_location: E:\\download\\&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;3、建立controller&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;41&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by 佳先森 on 2019/1/13.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@RestController
@RequestMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/filesystem&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileServerController {

    @Value(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;${fastdfs.upload_location}&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)   //读取配置文件
    &lt;/span&gt;&lt;span&gt;private&lt;/span&gt;&lt;span&gt; String upload_location;

    @PostMapping(&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;/upload&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;)
    @ResponseBody
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; FileSystem upload(@RequestParam(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;file&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;) MultipartFile file) throws IOException {
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;先将文件存储在web服务器上(本机),再使用fastDFS的client将文件到fastDFS服务器&lt;/span&gt;
        FileSystem fileSystem = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; FileSystem();
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;得到文件的原始名称&lt;/span&gt;
        String originalFilename =&lt;span&gt; file.getOriginalFilename();
        String extention &lt;/span&gt;= originalFilename.substring(originalFilename.lastIndexOf(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;.&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;));
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;重构上传文件名&lt;/span&gt;
        String newFileName = UUID.randomUUID()+&lt;span&gt;extention;
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义file，使用file存储上传的文件&lt;/span&gt;
        File file1 =&lt;span&gt;new&lt;/span&gt; File(upload_location+&lt;span&gt;newFileName);
        file.transferTo(file1);
        &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;获取新上传文件的物理路径&lt;/span&gt;
        String newFilePath =&lt;span&gt; file1.getAbsolutePath();
        &lt;/span&gt;&lt;span&gt;try&lt;/span&gt;&lt;span&gt; {
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;加载fastDFS客户端的配置文件&lt;/span&gt;
            ClientGlobal.initByProperties(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;config/fastdfs-client.properties&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;network_timeout=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; + ClientGlobal.g_network_timeout + &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;ms&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;);
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;charset=&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; ClientGlobal.g_charset);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;创建tracker的客户端&lt;/span&gt;
            TrackerClient tracker = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; TrackerClient();
            TrackerServer trackerServer &lt;/span&gt;=&lt;span&gt; tracker.getConnection();
            StorageServer storageServer &lt;/span&gt;= &lt;span&gt;null&lt;/span&gt;&lt;span&gt;;
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;定义storage的客户端&lt;/span&gt;
            StorageClient1 client = &lt;span&gt;new&lt;/span&gt;&lt;span&gt; StorageClient1(trackerServer, storageServer);
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;文件元数据(如文件名称大小等)&lt;/span&gt;
            NameValuePair[] metaList = &lt;span&gt;new&lt;/span&gt; NameValuePair[&lt;span&gt;1&lt;/span&gt;&lt;span&gt;];
            metaList[&lt;/span&gt;&lt;span&gt;0&lt;/span&gt;] = &lt;span&gt;new&lt;/span&gt; NameValuePair(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;fileName&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;,originalFilename);&lt;span&gt;//&lt;/span&gt;&lt;span&gt;这是个数组，可以继续添加
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;执行上传,将上传成功的存放在web服务器(本机)上的文件上传到fastDFS&lt;/span&gt;
            String fileId =&lt;span&gt; client.upload_file1(newFilePath, extention, metaList);
            System.&lt;/span&gt;&lt;span&gt;out&lt;/span&gt;.println(&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;upload success. file id is: &lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; +&lt;span&gt; fileId);
            fileSystem.setFileId(fileId);
            fileSystem.setFilePath(fileId);
            fileSystem.setFileName(originalFilename);

            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;通过调用service即dao将文件路径存储到数据库中
            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;....todo


            &lt;/span&gt;&lt;span&gt;//&lt;/span&gt;&lt;span&gt;关闭trackerServer的连接&lt;/span&gt;
&lt;span&gt;            trackerServer.close();
        } &lt;/span&gt;&lt;span&gt;catch&lt;/span&gt;&lt;span&gt; (Exception ex) {
            ex.printStackTrace();
        }
        &lt;/span&gt;&lt;span&gt;return&lt;/span&gt;&lt;span&gt; fileSystem;
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;4、编写启动类&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;34&quot;&gt;
&lt;pre&gt;
&lt;span&gt;/*&lt;/span&gt;&lt;span&gt;*
 * Created by 佳先森 on 2019/1/13.
 &lt;/span&gt;&lt;span&gt;*/&lt;/span&gt;&lt;span&gt;
@SpringBootApplication
&lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;class&lt;/span&gt;&lt;span&gt; FileServiceApplication {
    &lt;/span&gt;&lt;span&gt;public&lt;/span&gt; &lt;span&gt;static&lt;/span&gt; &lt;span&gt;void&lt;/span&gt;&lt;span&gt; main(String[] args) {
        SpringApplication.run(FileServiceApplication.&lt;/span&gt;&lt;span&gt;class&lt;/span&gt;&lt;span&gt;);
    }
}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;  5、编写前端界面&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;46&quot;&gt;
&lt;pre&gt;
&amp;lt;!DOCTYPE HTML PUBLIC &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;-//W3C//DTD HTML 4.01//EN&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; &lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;http://www.w3.org/TR/html4/strict.dtd&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;html lang=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;en&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;Content-Type&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; content=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/html;charset=UTF-8&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
    &amp;lt;title&amp;gt;Upload&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;!-- 引入样式 --&amp;gt;
&amp;lt;link rel=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;stylesheet&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; href=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://unpkg.com/element-ui/lib/theme-chalk/index.css&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;

&amp;lt;body&amp;gt;
    &amp;lt;div id=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;clj&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
            &amp;lt;el-&lt;span&gt;upload
      action&lt;/span&gt;=&lt;span&gt;&quot;&quot;&lt;/span&gt;&lt;span&gt;
      list&lt;/span&gt;-type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;picture-card&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      :on&lt;/span&gt;-preview=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;handlePictureCardPreview&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;
      :on&lt;/span&gt;-remove=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;handleRemove&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;i &lt;span&gt;class&lt;/span&gt;=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;el-icon-plus&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/i&amp;gt;
&amp;lt;/el-upload&amp;gt;
&amp;lt;el-dialog :visible.sync=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dialogVisible&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;
      &amp;lt;img width=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;100%&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; :src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;dialogImageUrl&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; alt=&lt;span&gt;&quot;&quot;&lt;/span&gt;&amp;gt;
&amp;lt;/el-dialog&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;script type=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;text/javascript&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt; src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;vue.min.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;!-- 引入组件库 --&amp;gt;
&amp;lt;script src=&lt;span&gt;&quot;&lt;/span&gt;&lt;span&gt;https://unpkg.com/element-ui/lib/index.js&lt;/span&gt;&lt;span&gt;&quot;&lt;/span&gt;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
    &lt;span&gt;new&lt;/span&gt;&lt;span&gt; Vue({
        el: &lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;#clj&lt;/span&gt;&lt;span&gt;'&lt;/span&gt;&lt;span&gt;,
        data: {
            dialogVisible: &lt;/span&gt;&lt;span&gt;false&lt;/span&gt;&lt;span&gt;,
            dialogImageUrl: &lt;/span&gt;&lt;span&gt;''&lt;/span&gt;&lt;span&gt;
        },&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;　　　　　　methods: {&lt;br/&gt;　　　　　　　　handlePictureCardPreview(file){　　　　　　&lt;span&gt;#预览&lt;/span&gt;&lt;br/&gt;　　　　　　　　this.dialogImageUrl =&quot;http://192.168.174.128/&quot;+file.response.filePath   &lt;span&gt;#注意：预览时访问的图片地址是通过nginx代理的，需要配置图片所在宿主机地址&lt;/span&gt;  &lt;br/&gt;　　　　　　　　this.dialogVisible = true;&lt;br/&gt;　　　　　　},&lt;br/&gt;　　　　　　　　handleRemove(){}&lt;br/&gt;　　　　　　}&lt;/p&gt;
&lt;pre&gt;
&lt;span&gt;    })
&lt;/span&gt;&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;6、nginx中配置页面访问路径&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;33&quot;&gt;
&lt;pre&gt;
&lt;span&gt;#图片服务测试(图片页面)
       server {
            listen      &lt;/span&gt;&lt;span&gt;7283&lt;/span&gt;&lt;span&gt;;
            server_name localhost;
            location &lt;/span&gt;/&lt;span&gt; {
                root     &lt;/span&gt;/usr/java/javademo/springboot-vue-fastdfs/upload/&lt;span&gt;;
                index   index.html;
            }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时访问http://192.168.174.128:7283/upload.html,若成功访问到页面，则配置成功&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226944/201901/1226944-20190120093417944-351007723.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;但是这样远远不够的，因为页面中的action配置的请求后台的action是访问不到的，存在跨域问题(页面与后端代码不在同一台宿主机上)，解决跨域问题常见的思路就是在nginx中配置代理&lt;/p&gt;
&lt;div class=&quot;cnblogs_code&quot; readability=&quot;35&quot;&gt;
&lt;pre&gt;
&lt;span&gt; #图片服务测试(图片页面)
       server {
            listen      &lt;/span&gt;&lt;span&gt;7283&lt;/span&gt;&lt;span&gt;;
            server_name localhost;                                    &lt;span&gt;#这里配置的是页面所在宿主机ip&lt;/span&gt;
            location &lt;/span&gt;/&lt;span&gt; {
                root     &lt;/span&gt;/usr/java/javademo/springboot-vue-fastdfs/upload/&lt;span&gt;;
                index   index.html;
            }
        location &lt;/span&gt;^~ /filesystem/&lt;span&gt; {       &lt;span&gt; #配置代理&lt;/span&gt;
                proxy_pass http:&lt;/span&gt;&lt;span&gt;//192.168.2.174&lt;/span&gt;&lt;span&gt;&lt;span&gt;:22100/filesystem/;&lt;/span&gt;    #注意这里配置的是后端代码所在宿主机ip&lt;/span&gt;
&lt;span&gt;        }
        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时上传和预览功能已经完成&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/1226944/201901/1226944-20190120101931908-140398111.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;克隆源码地址：git@gitee.com:MR_JiaXianSen/FastDFS.git&lt;/p&gt;

</description>
<pubDate>Sun, 20 Jan 2019 03:30:00 +0000</pubDate>
<dc:creator>佳先森</dc:creator>
<og:description>环境引入： 在一个大型的教育官网，会拥有大量优质的视频教程，并且免费提供给用户去下载，文件太多如果高效存储？用户访问量大如何保证下载速度？分布式文件系统是解决这些问题的有效方法之一 一、什么是文件系统</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cailijia52o/p/10263514.html</dc:identifier>
</item>
<item>
<title>Redis in .NET Core 入门 (1) - solenovex</title>
<link>http://www.cnblogs.com/cgzl/p/10294175.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cgzl/p/10294175.html</guid>
<description>&lt;p&gt;Redis（&lt;a href=&quot;https://redis.io/&quot; target=&quot;_blank&quot;&gt;https://redis.io/&lt;/a&gt;）, 是一个内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。&lt;/p&gt;


&lt;p&gt;我很少在开发机中直接装各种数据库，我一般使用Docker，针对Redis也不例外，我还是使用Docker。&lt;/p&gt;
&lt;p&gt;这是Redis在DockerHub里的地址：&lt;a href=&quot;https://hub.docker.com/_/redis&quot; target=&quot;_blank&quot;&gt;https://hub.docker.com/_/redis&lt;/a&gt;，里面有文档。&lt;/p&gt;
&lt;p&gt;启动docker，下载redis镜像：&lt;strong&gt;docker pull redis&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119152205821-1628304056.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后运行镜像并发布端口6379：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119152833436-766058193.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后运行redis-cli（这是Redis的一个命令行管理工具）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119153252949-1117117284.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;进入redis-cli之后，我们可以设置一个key-value来试试：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119153415161-1266286766.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当你输入的时候，它是有提示的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119153537379-1271834291.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;通过get key（key为name），可以获得其对应的值。&lt;/p&gt;


&lt;p&gt;建立一个.NET Core 控制台项目，并安装Redis的.NET Core客户端。&lt;/p&gt;
&lt;p&gt;Redis有很多C#的客户端，这里有个列表：&lt;a href=&quot;https://redis.io/clients#c&quot; target=&quot;_blank&quot;&gt;https://redis.io/clients#c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我这使用的是 &lt;strong&gt;StackExchange.Redis &lt;/strong&gt;(&lt;a href=&quot;https://stackexchange.github.io/StackExchange.Redis/&quot; target=&quot;_blank&quot;&gt;https://stackexchange.github.io/StackExchange.Redis/&lt;/a&gt;)。&lt;/p&gt;
&lt;h2&gt;安装StackExchange.Redis&lt;/h2&gt;
&lt;p&gt; &lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119154159168-155945424.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;h2&gt;使用StackExchange.Redis&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119154917744-1211484179.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;ConnectionMultiplexer已经实现了IDisposable接口，之所以没有使用using表达式，是因为该对象应该重复利用的，具体请看文档。&lt;/p&gt;
&lt;p&gt;我之前通过redis-cli设置了key为name的值，这里我通过name这个key把相对应的值找出来，并打印在控制台：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119155138964-120032154.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如果所示，连接上了数据库，并把值输出到了控制台，OK。&lt;/p&gt;
&lt;h2&gt;使用C#写入值&lt;/h2&gt;
&lt;p&gt;这个也没什么特别的，看代码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119155417397-867405759.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;运行结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119155510334-1958235176.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;


&lt;p&gt;Redis的主要数据类型有这些：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Key&lt;/strong&gt;：就是key的意思。。。。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;String&lt;/strong&gt;：字符串&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;List&lt;/strong&gt;：有序字符串的集合&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hashes&lt;/strong&gt;：有点像对象，里面可以有若干个字段，字段都有自己的值，字段和值都是字符串类型的。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Set&lt;/strong&gt;：无序唯一字符串的集合&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Sorted-Set&lt;/strong&gt;：跟Set很像，但是每一个字符串元素都对应一个浮点数值，该数值叫做分数。它里面的元素通常是按照分数来排序的。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;一共有两种方式：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;AOF&lt;/strong&gt;（Append-only file）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;RDB&lt;/strong&gt;（Redis database file）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;首先需要知道Redis的操作都是在内存中完成的，因为这样速度快。&lt;/p&gt;
&lt;h2&gt;AOF&lt;/h2&gt;
&lt;p&gt;然后你可以启用AOF，它会把每个操作都记录到系统文件里。所以如果Redis服务器重启了，它会根据AOF这个文件来重建整个数据集。&lt;/p&gt;
&lt;p&gt;这个文件会很快就变得很大，但是Redis很聪明，它会使用里面最新版本的数据，并压缩文件到可控大小。&lt;/p&gt;
&lt;h2&gt;RDB&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;RDB是Redis的默认模式&lt;/strong&gt;，它有点像数据库的快照，创建一些时间点的数据，如果发生灾难，你可以从这些数据里进行恢复。&lt;/p&gt;
&lt;p&gt;当达到一些条件的时候，例如数据集里面在某段时间内新添加了一定条目的数据，Redis就会把数据做个快照，并写入一个RDB文件。&lt;/p&gt;

&lt;p&gt;最佳实践是两者都用，使用AOF因为其速度和可用性，使用RDB做灾难恢复。&lt;/p&gt;


&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf&quot; target=&quot;_blank&quot;&gt;https://raw.githubusercontent.com/antirez/redis/4.0/redis.conf&lt;/a&gt; 这是Redis 4.0 的一个标准配置文件。&lt;/p&gt;
&lt;h2&gt;RDB 快照相关&lt;/h2&gt;
&lt;p&gt;先看快照部分，也就是和RDB有关的部分：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119162047908-1083671578.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;里面的save 900 1.。。。这部分是指，900秒过后，如果至少1个key改变了，那么就做一个快照。&lt;/p&gt;
&lt;p&gt;下面的就是300秒过后，如果10个key改变了，那就做一个快照。。。&lt;/p&gt;
&lt;p&gt;这些就是进行快照动作的触发条件。&lt;/p&gt;

&lt;h2&gt;AOF相关&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119162355691-1329808372.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;AOF模式默认是不开启的，也就是no。如果想开启，那就改成yes即可。&lt;/p&gt;


&lt;h2&gt;RDB &amp;amp; AOF&lt;/h2&gt;
&lt;p&gt;把上述文件下载到本地，进行修改：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119162657924-2011410592.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我添加了一个RDB的条件，5秒内1个Key被修改就会触发快照动作。&lt;/p&gt;

&lt;p&gt;然后我启用了AOF：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119162749434-1415511984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;首先把之前的容器删除吧，然后再建立一个。&lt;/p&gt;
&lt;p&gt;这次建立docker容器的时候需要使用volume：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119163226029-1228707194.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;说明一下：&lt;/p&gt;
&lt;p&gt;-v这部分是指volume，redis.conf在我电脑里的位置是：D:\Projects\Redis\redis.conf，所以我把该位文件的位置挂载到了容器里的/usr/local/etc/redis/redis.conf这个地方。&lt;/p&gt;
&lt;p&gt;然后运行redis这个镜像，同时运行里面的redis-server，而redis-server的配置文件就是/usr/local/etc/redis/redis.conf。&lt;/p&gt;

&lt;p&gt;现在这个redis-server运行起来了。&lt;/p&gt;

&lt;p&gt;再打开一个redis-cli，还是使用容器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119163624547-966861346.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后我设置一个key的值：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119163726639-173613670.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这时就达到了RDB的最后一个条件，所以触发了快照动作。&lt;/p&gt;
&lt;p&gt;我就不再实验了。。。&lt;/p&gt;

&lt;p&gt;我再打开一下redis容器的bash，然后看一下aof文件是否生成：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190119164154849-88187453.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到每次操作后aof文件都会更新（里面可以认为就是事务的log）。&lt;/p&gt;

&lt;h2&gt;Master-Slave Replication 主从复制&lt;/h2&gt;
&lt;p&gt;简单讲一下Redis的主从复制，首先把之前的容器都删掉。。。&lt;/p&gt;
&lt;p&gt;然后我们先建立docker 网络：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120082332735-1613038954.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后创建redis master的容器，不过首先修改一下redis.conf里的bind地址，原来是127.0.0.1，改为 bind 0.0.0.0：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120082604042-55273681.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这样的话其它的ip地址也可以连接过来了。&lt;/p&gt;

&lt;p&gt;然后创建master容器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120082427528-1597361401.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意里面使用了之前创建的桥接网络。&lt;/p&gt;

&lt;p&gt;检查一下redis-net这个网络：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120082720522-1007807008.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120082742532-890791273.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到该网络里有一个容器master-redis，其ip为172.20.0.2。&lt;/p&gt;

&lt;p&gt;然后把redis.conf再复制一份，名字为redis2.conf。&lt;/p&gt;
&lt;p&gt;在redis2.conf的Replication部分里，把下面这部分取消注释，并修改为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120082843903-2040589542.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;注意这个ip地址和master-redis的ip要一样。&lt;/p&gt;

&lt;p&gt;现在我们可以运行这个redis的slave容器了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120083010654-1167831984.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后我们可以看到主从复制成功了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120083121050-140626447.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;打开master的redis-cli：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120083225273-438999730.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;操作一些操作，可以看到master和slave都几乎同步的做了一些动作，也就是主从复制：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120083412386-1633996245.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;h2&gt;设置密码&lt;/h2&gt;
&lt;p&gt;把之前的容器都清理掉。。。&lt;/p&gt;
&lt;p&gt;主从复制的master通常需要设置密码，修改redis.conf文件，找到requirepass这部分，取消注释并设置密码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120084828087-395741824.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;在slave的redis2.conf里，找到masterauth这部分，填写master的密码：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120085123769-441763370.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;首先我填写一个错误的密码。&lt;/p&gt;
&lt;p&gt;然后运行两个容器，看看什么效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120085214546-840757680.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;可以看到提示密码不正确，无法进行复制。&lt;/p&gt;

&lt;p&gt;然后删掉slave容器，再把redis2.conf的密码修正一下： &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120085026138-1967060461.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;

&lt;p&gt;然后再运行slave容器：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120085408595-325516672.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这次可以看到连接成功了。&lt;/p&gt;


&lt;h2&gt;redis-server的命令行参数&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120084145581-489989207.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上图，这就对port和replicaof进行配置，而没有使用redis2.conf（所以该命令前面的-v部分也是没有什么作用的）。&lt;/p&gt;

&lt;h2&gt;CONFIG SET&lt;/h2&gt;
&lt;p&gt;前面我们使用了自定义的配置文件来运行Redis，但是这样的话需要重启Redis Server。&lt;/p&gt;
&lt;p&gt;而如果使用CONFIG SET（&lt;a href=&quot;https://redis.io/commands/config-set&quot; target=&quot;_blank&quot;&gt;https://redis.io/commands/config-set&lt;/a&gt;）的话，那就不需要重启redis server直接就可以修改配置，但是这样做不会修改redis.conf等配置文件的。&lt;/p&gt;

&lt;p&gt;首先需要使用redis-cli，然后进行配置即可，例如：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2018.cnblogs.com/blog/986268/201901/986268-20190120084456411-379058743.png&quot; alt=&quot;&quot;/&gt;&lt;/p&gt;
&lt;p&gt;这就是添加了一个快照的设置：每20秒如果有两个变化就做一个快照。&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 02:44:00 +0000</pubDate>
<dc:creator>solenovex</dc:creator>
<og:description>Redis（https://redis.io/）, 是一个内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 安装Redis 我很少在开发机中直接装各种数据库，我一般使用Docker，针对</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/cgzl/p/10294175.html</dc:identifier>
</item>
<item>
<title>AeroSpike踩坑手记1：Architecture of a Real Time Operational DBMS论文导读 - HappenLee</title>
<link>http://www.cnblogs.com/happenlee/p/10294102.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/happenlee/p/10294102.html</guid>
<description>&lt;blockquote readability=&quot;7.4332171893148&quot;&gt;
&lt;p&gt;又开了一个新的坑，笔者工作之后维护着一个 &lt;strong&gt;NoSQL 数据库&lt;/strong&gt;。而笔者维护的数据库正是基于&lt;strong&gt;社区版本的 Aerospike&lt;/strong&gt;打造而来。所以这个踩坑系列的文章属于工作总结型的内容，会将使用开发 Aerospike 的各种问题进行总结梳理，希望能够给予大家启发和帮助。第一篇开山之文，就先从Aerospike 公司在16年数据库顶会 &lt;strong&gt;VLDB&lt;/strong&gt;的一篇论文 &lt;a href=&quot;https://www.aerospike.com/docs/architecture/assets/vldb2016.pdf&quot;&gt;&lt;em&gt;《Aerospike: Architecture of a Real Time Operational DBMS》&lt;/em&gt;&lt;/a&gt;展开，来高屋建瓴的审视一下 Aeropike 的设计思路，来看看如何&lt;strong&gt;Aerospike&lt;/strong&gt;这款分布式数据库有什么亮点值得我们学习借鉴的，由于论文发布在2016年，笔者完成这篇文章时Aerospike的版本已经发布到4.5了，很多最新的实现与老论文已经有些不同了，这点希望大家理解。准备好，老司机发车了~~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;aerospike-的定位与场景&quot;&gt;1.AeroSpike 的定位与场景&lt;/h3&gt;
&lt;p&gt;从论文的题目出发，这篇文章的核心在于&lt;strong&gt;实时操作数据库的架构&lt;/strong&gt;，在论文引言之中对Aerospike的定位是&lt;strong&gt;一个高性能分布式数据库，用于处理实时的交互式在线服务&lt;/strong&gt;。所以说，大多数使用Aerospike的场景是实时决策系统，它们有海量的数据规模，并且有严格的SLA要求，同时是百万级别的 QPS，具有ms的查询时延。显然，这样的场景使用传统的 RDMS 是不现实的，在论文之中，提到 Aerospike 的一个典型的应用场景，&lt;strong&gt;广告推荐系统&lt;/strong&gt;，我们来一起看看它们是如何契合的：&lt;/p&gt;
&lt;p&gt;众所周知，广告推荐系统这样的应用场景&lt;strong&gt;需要极高的吞吐量、低延迟和稳定的可用性。同时，广告推荐系统具有随时间增加其数据使用量以提高其推荐的质量的趋势，即，在固定时间量中可访问的数据越多，推荐就越精确。&lt;/strong&gt;下图展示了一个广告推荐系统是如何结合 Aerospike来提供推荐服务的：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8552201-01bc16f95ddd5549.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;利用 Aerospike 实现的广告推荐系统，一个典型的 Lambda 架构的场景&quot;/&gt;&lt;/p&gt;
&lt;p&gt;显然，这就是笔者之前的文章之中聊到的&lt;strong&gt;典型的Lambda架构，笔者当时正是以广告推荐系统进行举例&lt;/strong&gt;的。所以在这里笔者就不展开再聊Aerospike在其中充当的实时流存储的角色了，感兴趣的朋友可以看&lt;a href=&quot;https://www.jianshu.com/p/05329c5beb74&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;aerospike的总体架构&quot;&gt;2.Aerospike的总体架构&lt;/h3&gt;
&lt;p&gt;除了广告推荐系统之外，论文的原文还介绍了许多关于Aerospike的适用场景，有兴趣的可以通过原文深入了解。接下来我们直奔主题，来看看&lt;strong&gt;Aerospike的总体架构&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8552201-757dcaa41e9d7340.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Aerospike的总体架构&quot;/&gt;&lt;/p&gt;
&lt;p&gt;由上图所示，Aerospike核心分为三个层次:&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;客户端层&lt;/li&gt;
&lt;li&gt;分布式层&lt;/li&gt;
&lt;li&gt;数据层&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;所以接下来我们来一一解构，Aerospike的各个层次。&lt;/p&gt;
&lt;h3 id=&quot;分布式层&quot;&gt;2.1 分布式层&lt;/h3&gt;
&lt;p&gt;与Cassandra类似的是，&lt;strong&gt;Aerospike也采用了P2P的架构，也就是说，集群之中不存在的中心节点，每个节点都是对等的结构。&lt;/strong&gt;而分布式层聚焦在两点之上：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;节点分布&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据分布&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;节点分布&quot;&gt;2.1.1 节点分布&lt;/h4&gt;
&lt;p&gt;节点需要处理节点成员关系，并对Aerospike集群当前成员达成共识。比如：&lt;strong&gt;网络故障和节点加入或离开。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;节点分布所关心的点在于：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;集群中的所有节点到达当前集群成员的单一一致视图。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;自动检测新节点的加入与离开。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;检测网络故障并且能够容忍网络的不稳定性。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;尽量缩短集群成员变化的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h5 id=&quot;集群视图&quot;&gt;2.1.1.1 集群视图&lt;/h5&gt;
&lt;p&gt;每个Aerospike节点都会自动分配一个唯一的节点标识符，它是其MAC地址和监听端口唯一确定的。集群整体视图由一个元组定义：&lt;em&gt;&amp;lt;cluster_key，succession_list&amp;gt;&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;cluster_key是随机生成的8字节值标识一个唯一的集群视图&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;succession_list 是一个集合，标识了所有属于集群的Aerospike节点&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;cluster_key标识当前集群成员身份状态，并在每次集群视图更改时更改。 它使得Aerospike节点用于区分两个不同的集群视图。&lt;strong&gt;对集群视图的更改都对集群的性能有着有着显著影响，这意味着需要快速检测节点加入/离开，并且随后需要存在有效的一致性机制来处理对集群视图的更改。&lt;/strong&gt;&lt;/p&gt;
&lt;h5 id=&quot;节点检测&quot;&gt;2.1.1.2 节点检测&lt;/h5&gt;
&lt;p&gt;节点的加入或离开是通过不同节点之间定期交换的心跳消息来检测的。&lt;strong&gt;集群中的每个节点都维护一个邻接列表，该列表是最近向节点发送心跳消息的节点列表。&lt;/strong&gt;如果在配置的超时间隔内，由于没有收到对应的心跳消息，从邻近列表中删除对应的节点。&lt;/p&gt;
&lt;p&gt;而节点检测机制需要保证：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;避免由于零星和短暂的网络故障而将节点误删除出集群。&lt;/li&gt;
&lt;li&gt;防止不稳定节点频繁加入和离开集群。&lt;/li&gt;
&lt;/ul&gt;&lt;h6 id=&quot;辅助心跳&quot;&gt;辅助心跳&lt;/h6&gt;
&lt;p&gt;在阻塞的网络中，有可能任意丢失某些数据包。&lt;strong&gt;因此，除了常规的心跳消息之外，节点还使用了定期交换的其他消息作为备选的辅助心跳机制。&lt;/strong&gt;例如，副本写可以用作心跳消息的辅助。这确保了，只要节点之间的主要或次要心跳通信是完整的，仅主心跳信息的丢失不会引起集群视图的变更。&lt;/p&gt;
&lt;h6 id=&quot;健康检测&quot;&gt;健康检测&lt;/h6&gt;
&lt;p&gt;集群中的每个节点可以通过计算&lt;strong&gt;平均消息丢失来评估其每个节点的健康评分&lt;/strong&gt;，健康评分是通过：&lt;strong&gt;每个节点接收的预期消息数量与每个节点接收的实际消息数量的加权平均值计算而成的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;设t为心跳消息的发送间隔，w为心跳信息的发送频率，r为在这个窗口时间中丢失的心跳消息的数量，α是一个比例因子，la（prev）之前的健康因子。la（new）为更新之后的健康因子，所以它的计算方式如下图所示：&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8552201-b488cd6914dba5ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;健康因子的计算&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;健康因子在所有节点标准差两倍的节点是异常值，并且被认为是不健康的。如果不健康的节点是集群的成员，则将其从集群中删除。如果不是成员，则直到其平均消息丢失在可容忍的限度内才能加入集群。&lt;/strong&gt;在实践中，α被设置为0.95，节点的历史表现比赋予了更多的权重。窗口时间一般设置为1秒。&lt;/p&gt;
&lt;h5 id=&quot;视图更改&quot;&gt;2.1.1.3 视图更改&lt;/h5&gt;
&lt;p&gt;对邻近列表的更改就会产生新集群视图，这需要一次Paxos一致性算法。&lt;strong&gt;邻接链表之中节点标识符最高的节点充当Paxos提议者，如果建议被接受，节点就开始重新分配数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Aerospike实现了最小化集群由于单一故障事件而更改视图的次数。例如，&lt;strong&gt;有故障的网络交换机可能使集群成员的子集不可到达。一旦恢复了网络，就需要将这些节点添加到集群中。如果每个丢失或加入的节点都需要触发创建新的集群视图，这种代价是很高的。&lt;/strong&gt;所以Aerospike仅在固定的集群更改间隔（间隔本身的时间是可配置的）开始时做出集群视图的调整。&lt;strong&gt;这里的想法是避免如心跳子系统检测到的那样对节点到达和离开事件反应太快，而是用一个集群视图更改来处理一批节点加入或删除的事件。这避免了由重复的集群视图更改和数据分布导致的大量潜在开销。&lt;/strong&gt;集群更改间隔等于节点超时值的两倍，确保在单个间隔中明确检测到由于单个网络故障而失败的所有节点。&lt;/p&gt;
&lt;h4 id=&quot;数据分布&quot;&gt;2.2 数据分布&lt;/h4&gt;
&lt;p&gt;Aerospike使用&lt;strong&gt;RipeMD160算法将record的key散列为160字节的digest&lt;/strong&gt;，digest被划分为4096个分区。分区是Aerospike中最小的数据分布单元，根据key 的digest为记录分配分区。&lt;strong&gt;即使key的分布是倾斜的，在digest空间中分布也是均匀的，它有助于避免在数据访问期间创建热点，这有助于系统的容错。&lt;/strong&gt;&lt;br/&gt;一个好的数据分布需要满足下列条件：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;存储负载均匀地分布在集群中，&lt;/li&gt;
&lt;li&gt;具有较好的扩展性&lt;/li&gt;
&lt;li&gt;节点出现变化时，数据的重新平衡是非破坏性的&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8552201-473a3684a5b0985c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Aerospike 的数据分布&quot;/&gt;&lt;/p&gt;
&lt;p&gt;数据分配算法为每个分区生成一个副本列表。副本列表中的第一个节点是该分区的主节点，其余的节点是副本。在默认情况下，所有读/写都通过副本的主节点。Aerospike支持任意数量的副本，（&lt;strong&gt;通常设置为两副本，笔者在实际使用中也是两副本&lt;/strong&gt;）。 Aerospike 采取的是一致性哈希的分片分配的方式，当节点出现失效或宕机的情况时。这个节点可以从副本列表中删除，而后续节点的左移。如下图所示，如果该节点需要承载了数据的副本，则需要将此分区中的记录复制到新节点。一旦原始节点返回并再次成为集群的一部分，它将简单地重新获得其在分区复制列表中的位置。向集群中添加一个全新的节点将具有将此节点插入各个分区副本列表中的某个位置的效果。因此，将导致每个分区的后续节点的右移，而新节点左侧的分配不受影响。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8552201-100139a7a4ad466d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;主副本的分布与副本的移动&quot;/&gt;&lt;/p&gt;
&lt;p&gt;上面的讨论给出了算法就能确保副本的最低迁移成本。但是当一个节点被删除并重新加入集群时，它需要和其他副本进行同步。当一个全新的节点加入一个拥有大量现有数据的集群，所以新的节点需要获得对应分区中所有记录的全新副本，并且还能够处理新的读写操作。接下来我们来看看副本同步的机制：&lt;/p&gt;
&lt;h4 id=&quot;数据迁移&quot;&gt;2.2.1 数据迁移&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;将record从一个节点移动到另一个节点的过程称为迁移。在每次集群视图改变之后，就需要进行数据迁移。&lt;/strong&gt;每个分区的主副本为对应的分区分配唯一的分区版本，这个版本号会被复制到各个副本中。在集群视图更改之后，节点之间交换分区的分区版本和数据。&lt;/p&gt;
&lt;h5 id=&quot;增量迁移&quot;&gt;2.2.1.1 增量迁移&lt;/h5&gt;
&lt;p&gt;Aerospike使用增量迁移的方式优化迁移的速度。如果在能够在分区版本上建立总顺序，那么数据迁移的过程将更加有效。例如，如果节点1上的分区版本的值小于节点2上的相同分区版本的值，则节点1上的分区版本可能被丢弃。但是，&lt;strong&gt;通过分区版本号的排序是有问题的，因为网络分区引起的集群分裂会引起分区版本的冲突。&lt;/strong&gt;&lt;br/&gt;所以当两个版本冲突时，节点需要协商实际记录中的差异，并通过只对应于两个分区版本之间的差异的数据发送。在某些情况下，可以根据分区版本顺序完全避免迁移。在其他情况下，如滚动升级，可以传递增量的数据，而不是迁移整个分区。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;迁移流程中的读写&lt;br/&gt;如果分区正在进行迁移时，如果此时对应的分区有读写，主副本会读取所有的分区版本，协调出一个最终胜出的版本用于读或写事务。（&lt;strong&gt;按照笔者对文章的理解，这个流程会涉及多个副本，是一个耗时的操作&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;没有数据的主副本&lt;br/&gt;新添加到正在运行的集群的空节点成为了主副本，并且没有对应分区的数据，没有任何数据的分区的副本被标记为处于DESYNC状态。Aerospike会指定一个&lt;strong&gt;最多记录的分区版本作为这个分区的代理主副本&lt;/strong&gt;。所有的读操作都会指向代理主副本。（&lt;strong&gt;此时写还是在主副本上&lt;/strong&gt;）&lt;strong&gt;如果客户端可以容忍读取旧版本的记录，则可以减少协调胜出版本的损耗。&lt;/strong&gt;此代理主副本的工作会持续到对应分区的迁移完成。&lt;/li&gt;
&lt;li&gt;迁移顺序
&lt;ul&gt;&lt;li&gt;&lt;em&gt;小分区优先&lt;/em&gt;&lt;br/&gt;让分区版本中记录最少的分区开始迁移。这种策略可以快速减少特定分区的不同副本的数量。随着迁移的完成，延迟会改善，需要进行协调副本版本会减少对应的节点进行的通信。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;热分区优先&lt;/em&gt;&lt;br/&gt;根据分区的 qps 的大小确认分区迁移的顺序。这种策略的目标与小分区优先的逻辑是一致的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;h4 id=&quot;快速重启&quot;&gt;2.2.2 快速重启&lt;/h4&gt;
&lt;p&gt;节点重新启动是很常见的场景，比如：服务升级，宕机重启等。Aerospike的索引是内存中的而没有存储在持久设备上。在节点重新启动时，需要通过扫描持久设备上的记录来重新构建索引。（&lt;strong&gt;这个过程巨慢无比，笔者目前维护的大集群，单机存储数据量达1T，单次启动需要30分钟之久&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;为了避免在每次重新启动时重新构建索引，Aerospike的利用了共享内存来实现快速重启。（&lt;strong&gt;目前开源的版本是不支持这个功能的，笔者所在的团队通过二次开发实现了对应的功能。但是机器一旦重启之后，也必须重建索引，所以有机器频繁重启的，可以考虑一些对应索引进行落盘&lt;/strong&gt;）&lt;/p&gt;
&lt;h3 id=&quot;客户端层&quot;&gt;2.3 客户端层&lt;/h3&gt;
&lt;h4 id=&quot;服务发现&quot;&gt;2.3.1 服务发现&lt;/h4&gt;
&lt;p&gt;在Aerospike中，每个节点维护着一个&lt;strong&gt;邻接列表&lt;/strong&gt;标识着全局的节点分布情况。客户端从一个&lt;strong&gt;种子节点&lt;/strong&gt;，发现整个集群的节点。&lt;br/&gt;每个客户端进程都将集群分区映射的信息存储在共享内存之中。为了保持信息最新，客户端进程定期通过AeroSpike节点，来检查集群是否有任何变动。它通过根据服务器的最新版本检查本地存储的版本来实现这一点。对于单机的多个客户端，&lt;strong&gt;AeroSpike将数据存储在共享内存之中，并且用跨进程的互斥代码来实现集群信息的共享。&lt;/strong&gt;&lt;br/&gt;####2.3.2 连接管理&lt;br/&gt;对于每个集群节点，在初始化时，&lt;strong&gt;客户端需为节点创建一个内存结构，并存储其分区映射，并且为节点维护连接。&lt;/strong&gt;一旦出现节点和客户端的网络问题，这种频繁的内存调整容易产生性能问题。所以Aerospike客户端实现以下策略：&lt;br/&gt;####2.3.2.1 健康计数&lt;br/&gt;为了避免由于偶尔的网络故障导致上文的问题。当客户端连接集群节点操作发生问题时，会对集群节点进行&lt;strong&gt;故障计数&lt;/strong&gt;。当故障计数超过特定阈值时，客户端才会删除集群节点。对集群节点的成功操作可以将故障计数重置为0。&lt;br/&gt;####2.3.2.2 节点咨询&lt;br/&gt;网络的故障通常很难复杂。在某些极端情况下，集群节点可以彼此感知，但是客户端不能直接感知到集群节点X。在这些情况下，客户端连接集群之中所有可见节点，并咨询集群之中的所有节点在其邻接列表中是否包含X。如果没有包含，则客户端将等待一个阈值时间，永久移除X节点。&lt;/p&gt;
&lt;h3 id=&quot;跨数据中心同步&quot;&gt;3 跨数据中心同步&lt;/h3&gt;
&lt;h4 id=&quot;失效接管&quot;&gt;3.1.1 失效接管&lt;/h4&gt;
&lt;p&gt;在正常状态下（即，当没有故障时），每个节点只将节点上主副本的数据传送到远程集群。只在节点出现故障时才使用从副本。&lt;strong&gt;如果一个节点出现失效，所有其他节点能够检测到，并代表失效的节点接管工作。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;数据传输优化&quot;&gt;3.1.2 数据传输优化&lt;/h4&gt;
&lt;p&gt;当发生写操作时，主副本在日志之中记录。进行数据传输时，首先读取一批日志，如果同一个记录有多个更新，选取一批之中最近的更新记录。&lt;strong&gt;一旦选取了记录，将其与实际记录比较。如果日志文件上的记录小于实际的记录，则跳过该记录。&lt;/strong&gt;对于但是跳过记录的次数有一个上限，因为如果记录不断更新，那么可能永远不会推送记录。当系统中存在频繁更新记录的热键时，这些优化提供了巨大的好处。&lt;/p&gt;
&lt;h3 id=&quot;存储落地&quot;&gt;4 存储落地&lt;/h3&gt;
&lt;h4 id=&quot;存储管理&quot;&gt;4.1 存储管理&lt;/h4&gt;
&lt;p&gt;Aerospike的存储层是一个混合模型，&lt;strong&gt;其中索引存储在内存中（不持久），数据可以选择存储在持久存储（SSD）或内存之中。&lt;/strong&gt;而随机的读写SSD容易产生&lt;strong&gt;写放大&lt;/strong&gt;。（&lt;strong&gt;笔者之前的文章也同样聊过这个问题，可以参考&lt;a href=&quot;https://www.jianshu.com/p/8885fce8e168&quot;&gt;这里&lt;/a&gt;)&lt;/strong&gt;为了避免在SSD的单个块上产生不均匀的磨损，Aerospike采取了批量写的方式。&lt;strong&gt;当更新记录时，从SSD读取旧记录，并将更新后的副本写入缓冲区。当缓冲区在充满时刷新到SSD上。&lt;/strong&gt;&lt;br/&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/8552201-9b0895d002f085d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;Aerospike存储层&quot;/&gt;&lt;br/&gt;&lt;strong&gt;读取单元RBLOCKS的大小是128字节。而WBLOCK的大小，可配置，通常为1MB。这样的写入优化了磁盘寿命。&lt;/strong&gt;Aerospike通过Hash函数在多个设备上切分数据来操作多个设备。这允许并行访问多个设备，同时避免任何热点。&lt;/p&gt;
&lt;h4 id=&quot;defragmentation垃圾清理&quot;&gt;4.2 Defragmentation垃圾清理&lt;/h4&gt;
&lt;p&gt;Aerospike通过运行后台碎片整理进程来回收空间。每个设备对应的块都存在&lt;strong&gt;填充因子&lt;/strong&gt;。块的填充因子写入在块中。系统启动时，存储系统载入块中的填充因子，并在每次写入时保持更新。&lt;strong&gt;当块的填充因子低于阈值时，块成为碎片整理的候选者，然后排队等待碎片整理。&lt;/strong&gt;&lt;br/&gt;块进行碎片整理时，将读取有效记录并将其移动到新的写入缓冲区，当写入缓冲区已满时，将其刷新到磁盘。&lt;strong&gt;为了避免混合新写和旧写，Aerospike维护两个不同的写缓冲队列，一个用于普通客户端写，另一个用于碎片整理。&lt;/strong&gt;&lt;br/&gt;设置一个较高的阈值（通常为50%）会导致设备不断的刷写。而较低的设置会降低磁盘的利用率。&lt;strong&gt;所以基于可立即被写入可用磁盘空间，调整碎片整理速率以确保有效的空间利用。&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;性能与调优&quot;&gt;4.3 性能与调优&lt;/h4&gt;
&lt;h5 id=&quot;post-write-queue&quot;&gt;4.3.1 Post Write Queue&lt;/h5&gt;
&lt;p&gt;Aerospike没有维护LRU缓存，而是维护的&lt;strong&gt;post write queue&lt;/strong&gt;。这是最近写入的数据缓存，这个缓存不需要额外的内存空间。post write queue提高了缓存命中率，并减少了存储设备上的I/O负载。&lt;/p&gt;
&lt;h3 id=&quot;小结&quot;&gt;5.小结&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;关于论文之中对Aerospike的设计笔者已经夹带私货的阐述清晰了。&lt;/strong&gt;而关于单机优化和Aerospike性能测试，笔者就不再赘述了，感兴趣的可以回到论文之中继续一探究竟。对于论文之中的细节想要进一步的了解，可以继续关注笔者后续关于Aerospike的拆坑手记～～～&lt;/p&gt;
</description>
<pubDate>Sun, 20 Jan 2019 02:08:00 +0000</pubDate>
<dc:creator>HappenLee</dc:creator>
<og:description>又开了一个新的坑，笔者工作之后维护着一个 NoSQL 数据库 。而笔者维护的数据库正是基于 社区版本的 Aerospike 打造而来。所以这个踩坑系列的文章属于工作总结型的内容，会将使用开发 Aero</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>http://www.cnblogs.com/happenlee/p/10294102.html</dc:identifier>
</item>
</channel>
</rss>