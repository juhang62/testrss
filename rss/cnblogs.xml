<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="css/feed.xsl"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:media="http://search.yahoo.com/mrss/" xmlns:og="http://ogp.me/ns#">
<channel>
<atom:link rel="self" href="http://192.168.1.4/fivefilters/makefulltextfeed.php?url=feed.cnblogs.com%2Fblog%2Fsitehome%2Frss&amp;max=10&amp;links=preserve&amp;exc=" />
<atom:link rel="alternate" title="Source URL" href="http://feed.cnblogs.com/blog/sitehome/rss" />
<atom:link rel="related" title="Subscribe to feed" href="http://www.subtome.com/#/subscribe?feeds=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D&amp;back=http%3A%2F%2F192.168.1.4%2Ffivefilters%2Fmakefulltextfeed.php%3Furl%3Dfeed.cnblogs.com%252Fblog%252Fsitehome%252Frss%26max%3D10%26links%3Dpreserve%26exc%3D" />
<title>博客园_首页</title>
<link></link>
<description>代码改变世界</description>
<item>
<title> Redis-第七章节-持久化 - Mr-Tsing</title>
<link>http://www.cnblogs.com/ld320321/p/14380535.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/ld320321/p/14380535.html</guid>
<description>&lt;ul&gt;&lt;li&gt;概述&lt;/li&gt;
&lt;li&gt;RDB&lt;/li&gt;
&lt;li&gt;AOF&lt;/li&gt;
&lt;li&gt;如何选择持久化机制&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;1、概述&quot;&gt;1、概述&lt;/h2&gt;
&lt;p&gt;Redis 是内存数据库，如果不能将内存中的数据保存到磁盘中，那么一旦服务器进程退出，服务器的数据库数据也会消失，所以Redis提供了持久化的功能,redis分为两种持久化方式：&lt;strong&gt;RDB&lt;/strong&gt;和&lt;strong&gt;AOF&lt;/strong&gt;。有以下几个特点：&lt;/p&gt;
&lt;ul readability=&quot;3.5&quot;&gt;&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;1.RDB持久化方式能够在指定的时间间隔能对你的数据进行快照存储。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;2.AOF持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件后台重写，使得AOF文件的体积不至于过大。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;3.如果你只希望你的数据在服务器运行的时候存在，你也可以不使用任何持久化的方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;1&quot;&gt;
&lt;p&gt;4.你也可以同时开启两种持久化方式，在这种情况下，当redis重启的时候会优先载入AOF文件来恢复原始的数据。因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;2、rdb&quot;&gt;2、RDB&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;1、概念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在指定的时间间隔内将内存中的数据集快照写入磁盘中，它恢复的时候是将快照中的文件直接读取到内存中。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;2、持久化机制-BGSAVE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6.5&quot;&gt;
&lt;blockquote readability=&quot;10&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://static01.imgkr.com/temp/441c8cc76be24d588cf26aea1fa87f0e.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;通常，会立即返回ok,Redis进程会执行&lt;code&gt;fork&lt;/code&gt;操作创建子进程，Redis在&lt;code&gt;fork&lt;/code&gt;时，父进程会继续为客户端提供服务，子进程会将数据持久化到硬盘上，然后退出。如果已经在后台执行保存或者正在运行另一个非后台保存的进程，特别是正在进行&lt;code&gt;AOF&lt;/code&gt;写入时，则会返回错误。如果使用了&lt;code&gt;bgsave&lt;/code&gt;任务，而正在进行&lt;code&gt;AOF&lt;/code&gt;写入时，该命令将立即返回ok,并计划在下一次机会运行后台保存。阻塞只会在&lt;code&gt;fork&lt;/code&gt;阶段。&lt;br/&gt;客户端可以使用&lt;code&gt;lastsave&lt;/code&gt;命令检查操作是否成功。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;3、持久化机制-SAVE&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;4.5&quot;&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/25edcd7f-54f9-41ad-b228-4b5f215470df.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=Zfdk99Cq4RmPjCQP6jljprtovxw%253D&amp;amp;Expires=1612621585&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;不会接受客户端执行的操作命令，等持久化工作完成之后，会将新的文件替换旧的文件。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4、持久化机制-自动触发&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;redis.conf&lt;/code&gt;中可以配置，让用户自定义&lt;code&gt;save&lt;/code&gt;属性，让服务器每一段时间内执行一次&lt;code&gt;bgsave&lt;/code&gt;操作。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;  # 服务器在900秒内，对数据库进行了至少1次修改
  save 900 1
  
  # 服务器在300秒内，对数据库进行了至少10次修改
  save 300 10
  
  # 服务器在60秒内，对数据库进行了至少10000次修改
  save 60 10000
  
  # bgsave发生错误时是否停止写入，一般为yes
  stop-writes-on-bgsave-error yes
  
  # 持久化时是否使用LZF压缩字符串对象?
  rdbcompression yes
  
  # 是否对rdb文件进行校验和检验，通常为yes
  rdbchecksum yes
  
  # RDB持久化文件名
  dbfilename dump.rdb
  
  # 持久化文件存储目录
  dir ./
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;5、恢复数据机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;只需要将rdb文件放在我们redis启动目录就可以了，redis启动的时候会自动检查文件并恢复其中的数据。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;6、优点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;RDB是一个非常紧凑的文件，它保存了某个时间点得数据集，非常适用于数据集的备份，比如你可以在每个小时报保存一下过去24小时内的数据，同时每天保存过去30天的数据，这样即使出了问题你也可以根据需求恢复到不同版本的数据集。&lt;/li&gt;
&lt;li&gt;RDB是一个紧凑的单一文件，很方便传送到另一个远端数据中心或者亚马逊的S3（可能加密），非常适用于灾难恢复。&lt;/li&gt;
&lt;li&gt;RDB在保存RDB文件时父进程唯一需要做的就是fork出一个子进程，接下来的工作全部由子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能。&lt;/li&gt;
&lt;li&gt;与AOF相比，在恢复大的数据集的时候，RDB方式会更快一些。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;7、缺点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;2&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;如果你希望在redis意外停止工作（例如电源中断）的情况下丢失的数据最少的话，那么RDB不适合你。虽然你可以配置不同的save时间点(例如每隔5分钟并且对数据集有100个写的操作)，是Redis要完整的保存整个数据集是一个比较繁重的工作，你通常会每隔5分钟或者更久做一次完整的保存，万一在Redis意外宕机，你可能会丢失几分钟的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;RDB 需要经常fork子进程来保存数据集到硬盘上，当数据集比较大的时候，fork的过程是非常耗时的，可能会导致Redis在一些毫秒级内不能响应客户端的请求。如果数据集巨大并且CPU性能不是很好的情况下，这种情况会持续1秒，AOF也需要fork，但是你可以调节重写日志文件的频率来提高数据集的耐久度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;3、aof&quot;&gt;3、AOF&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;1、概念&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;以日志的形式来记录每个写操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，换言之，Redis重启的话就会根据日志文件的内容将写的指令从前到后执行一次以完成数据的恢复工作。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2、持久化原理&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://imgkr2.cn-bj.ufileos.com/f6eb2ae6-5400-41fd-8322-a3cb91d7c5f8.png?UCloudPublicKey=TOKEN_8d8b72be-579a-4e83-bfd0-5f6ce1546f13&amp;amp;Signature=R2ykRvz6yAhBiJAIKYm4up%252BAvuc%253D&amp;amp;Expires=1612627121&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;br/&gt;所有操作的命令会追加在文件中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;3、开启AOF持久化&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-shell&quot;&gt;   
   # 开启aof持久化方式，默认no
   appendonly no
   
   # aof 持久化生成的文件名称
   appendfilename &quot;appendonly.aof&quot;
   
   # 三种持久化机制
   # appendfsync always
   appendfsync everysec
   # appendfsync no
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;4、三种触发持久化机制&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul readability=&quot;0.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;always&lt;br/&gt;同步持久化，每次发生数据变更会被立即持久化到硬盘中，性能比较差，但是数据完整性好。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;everysec&lt;br/&gt;异步操作，每秒持久化数据到硬盘一次，可能会丢失一秒的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;no&lt;br/&gt;从不持久化到硬盘。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;5、AOF文件损坏&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果 aof 文件被破坏，redis服务是启动不了的。redis本身提供了修复了工具。&lt;code&gt;redis-check-aof --fix appendonly.aof&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;5、优点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;根据配置不同的策略，让你选择持久化的方式。&lt;/li&gt;
&lt;li&gt;AOF文件是一个只进行追加的日志文件，所以不需要写入seek，即使由于某些原因(磁盘空间已满，写的过程中宕机等等)未执行完整的写入命令，你也也可使用redis-check-aof工具修复这些问题。&lt;/li&gt;
&lt;li&gt;Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。 整个重写操作是绝对安全的，因为 Redis 在创建新 AOF 文件的过程中，会继续将命令追加到现有的 AOF 文件里面，即使重写过程中发生停机，现有的 AOF 文件也不会丢失。 而一旦新 AOF 文件创建完毕，Redis 就会从旧 AOF 文件切换到新 AOF 文件，并开始对新 AOF 文件进行追加操作。&lt;/li&gt;
&lt;li&gt;AOF 文件有序地保存了对数据库执行的所有写入操作，这些写入操作以 Redis 协议的格式保存， 因此 AOF 文件的内容非常容易被人读懂，对文件进行分析（parse）也很轻松。导出（export）AOF文件也非常简单：举个例子， 如果你不小心执行了 FLUSHALL 命令， 但只要 AOF 文件未被重写，那么只要停止服务器，移除 AOF 文件末尾的 FLUSHALL 命令，并重启 Redis，就可以将数据集恢复到 FLUSHALL 执行之前的状态。&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote&gt;
&lt;p&gt;6、缺点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;&lt;li&gt;对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。&lt;/li&gt;
&lt;li&gt;根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB 。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。&lt;/li&gt;
&lt;/ul&gt;&lt;h2 id=&quot;4、如何选择持久化机制&quot;&gt;4、如何选择持久化机制&lt;/h2&gt;
&lt;p&gt;开启两种持久化方式，根据自己的业务需求针对redis进行配置的调整。&lt;/p&gt;
</description>
<pubDate>Sat, 06 Feb 2021 00:22:00 +0000</pubDate>
<dc:creator>Mr-Tsing</dc:creator>
<og:description>目录 概述 RDB AOF 如何选择持久化机制 1、概述 Redis 是内存数据库，如果不能将内存中的数据保存到磁盘中，那么一旦服务器进程退出，服务器的数据库数据也会消失，所以Redis提供了持久化的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/ld320321/p/14380535.html</dc:identifier>
</item>
<item>
<title>职场 | 跳槽之后，如何平稳走过试用期 - 知了一笑</title>
<link>http://www.cnblogs.com/cicada-smile/p/14380525.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cicada-smile/p/14380525.html</guid>
<description>&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;试用期什么事情最重要？把那些能帮助自己快速转正的事情做好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p align=&quot;center&quot;&gt;01&lt;/p&gt;
&lt;p&gt;完成跳槽之后，进入新公司并不说明就算真正进入该公司，试用期的三个月考核这才是正式开始。&lt;/p&gt;
&lt;p&gt;尤其互联网行业中，在试用期被离职或者主动离职的比比皆是，中间原因很难一概而论。&lt;/p&gt;
&lt;p&gt;不过大部分原因可能就是公司环境适应不下来，可能是开发环境，或者工作环境，再或者就是什么价值观不和的虚与委蛇。&lt;/p&gt;
&lt;p&gt;这也就是为什么很多人跳槽之后的三个月并不敢直接把房子搬到公司附近，因为总怕没转正来回折腾麻烦，这应该是大多数漂泊在外的朋友心中无言的伤。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生活就是这样，花里胡哨的，你可以不热爱但是要面对。&lt;/strong&gt;&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;02&lt;/p&gt;
&lt;p&gt;互联网公司的程序员试用期到底要做哪些事情？一句话形容：很多。&lt;/p&gt;
&lt;p&gt;入职的第一周，一天搭建环境，一天熟悉代码结构，三天看看业务和部分接口逻辑，这都是良心公司才有的安排，合不合理？谁知道呢。&lt;/p&gt;
&lt;p&gt;有些公司不讲武德，入职一天之后直接甩个小需求过来，美其名曰可以快速适应业务，说的也挺一本正经的。&lt;/p&gt;
&lt;p&gt;搭建公司的开发环境这是起手操作，一般除了实习阶段有人手把手的教环境搭建之外，后续在入职新公司都需要自己折腾。&lt;/p&gt;
&lt;p&gt;环境搭建好之后就是快速的把代码在本地构建好，并运行起来，这里可能会有一些特殊的配置可以根据环境文档操作即可，然后就是熟悉代码中的各种技术组件，规范和基础工具。&lt;/p&gt;
&lt;p&gt;新的公司不管系统如何，可能都会遇到自己不熟悉模块，比如公司系统开发的技术栈基于是分布式，有些新技术组件的需要学习，可以在下班后时间快速熟悉官方文档和结合项目用法，快速熟悉起来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;尤其注意的是这些不熟悉的技术组件，可以说自己不太熟但是不能说不会，利用空闲的时间快速恶补一下，然后照葫芦画瓢摆出一副不难的样子&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;对于大多数公司而言，环境和代码结构熟悉基本也就控制在两天的时间，然后就是&lt;strong&gt;对于现有产品的流程熟悉，这里一定要做到心里有数，熟悉产品中的核心业务流即可&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;借助业务文档，需求文档，和开发环境的，理清楚核心业务模式的流程，像系统基础，权限管理，架构这些内容都不是当前最关键的，只有熟悉核心流程，才能在后面需求开发的时候做到心里有数。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;03&lt;/p&gt;
&lt;p&gt;能给一周熟悉环境和产品的公司，目测绝对良心了，第二周开始就会介入到版本需求开发，工作的这几年真的不乏有很多人在第一个版本就凉了的。&lt;/p&gt;
&lt;p&gt;参加的第一个版本需求开发通常不会很难，可能是遗留的小需求或者线上出现的小的BUG，这个版本也不是用来考察新人的能力上限，基本就是看做事风格，思维，还有就是对环境的熟悉度。&lt;/p&gt;
&lt;p&gt;需求开发的基本套路无非就是评审，立项，开发，测试，上线，但是这是个拒绝犯错的版本，如果第一个需求开发不顺或者有重大失误，基本就试用期结束，注意下面几点，基本无压力：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一：理解基本需求&lt;/strong&gt;；这时候不需要端着，不合理不懂或者不理解，版本开始的时候就要讨论清楚，最忌讳开始说很明白，在周期结尾发现有关联问题或者考虑不周导致延期。这样会导致&lt;strong&gt;心里压力大，时间紧，效应型错误就会连续出现，然后HR谈话就会出现&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二：代码与规范&lt;/strong&gt;；首先就是新分支的创建，然后就是基本需求完成开发，实际的代码开发建议在开始的时候参考现有代码风格与逻辑即可，不需要过多加入自己的习惯和风格。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三：良好的意识&lt;/strong&gt;；业务开发真的很考验程序员的意识，因为业务之间的关联性可能在需求上不能直接体现，只有在不断推进和调试中才会出现，新人最大痛点莫过于需求开发完之后，引起一些盲区问题，所以在&lt;strong&gt;建议业务不熟悉的情况下，通过加班赶开发进度，提前开发完如果发现关联问题可以有时间处理，同时给团队留下很好的印象，避免处于被动状态&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果这个需求可以顺利完成上线，那就基本算正式融入这个新的环境了，不需要再有太多心里压力，后续就会开始不断的版本开发和业务熟悉的良好状态中。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;04&lt;/p&gt;
&lt;p&gt;这里来聊聊个人在团队中的定位，&lt;strong&gt;有多大的能力拿多少钱，就要承担相应的责任，这是通常的共识&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在一个合理的氛围良好的团队中，通常对于分工都是极其合理的，高级工程师承担核心业务，初级工程师负责边缘业务，架构师做日常架构维护和升级。&lt;/p&gt;
&lt;p&gt;所以自己以新人入职到一个团队之后，要明确部门对自己的定位，并且承担相应的责任，在试用期后半段，一般会按照能力分配不同难度的开发需求，保持良好的心态认真对待就好。&lt;/p&gt;
&lt;p&gt;另一个关键问题就是&lt;strong&gt;个人价值，如果作为新人对现有业务不熟悉是缺点，那作为新人带着之前公司的积累和经验过来就是个人的优势，能给现有团队带来多少影响和改变就是个人价值&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;相比之下显出好坏，所以每个跳槽的人心里都要清楚自己的优劣势，所以把自己之前工作的积累在新公司发挥出价值就至关重要，比如开发规范，好用的组件，业务解决方案，产品迭代等等。&lt;/p&gt;
&lt;p&gt;不管是专业技能还是经验，都可以帮自己快速融入新团队，快速在新的环境中产生价值。只有这样才能给后续的发展做好铺垫，这就是跳槽中的优势积累。&lt;/p&gt;
&lt;p align=&quot;center&quot;&gt;05&lt;/p&gt;
&lt;p&gt;最后聊一个现实的问题，如何面对转正述职，通常从&lt;strong&gt;工作内容、量化结果、未来规划&lt;/strong&gt;这三个核心方面做总结。&lt;/p&gt;
&lt;p&gt;其实真正实际考量的就是试用期的工作成果，你负责的模块要匹配你的薪酬水平，如果试用期没有犯过重大失误，而且承担的开发模块有一定的难度，这就基本判断可以通过试用期了。&lt;/p&gt;
&lt;p&gt;可以适当展示自己在需求开发中的文档，例如开发设计、流程描述、接口文档等内容，懂得不断积累的人通常更令人放心和信任。&lt;/p&gt;
&lt;p&gt;其次就是未来规划，思路清晰和规划明确的人可以承担更高难度的工作，因为明确自己要做什么并且懂得如何安排和具体落实，这里要可以针对具体系统问题或者产品规则层面来考虑，避免假大空放烟花。&lt;/p&gt;
&lt;p&gt;最后适当的彩虹屁要撒一波，比如同事靠谱团队氛围好，领导照顾公司前景等，不用过分和过度，几句话面面俱到即可。&lt;/p&gt;
&lt;p&gt;上篇：&lt;a href=&quot;https://mp.weixin.qq.com/s/DnjMqgjL5HanXtvu5uNxVQ&quot; target=&quot;_blank&quot;&gt;职场 | 3天准备5天面试，跳槽完成&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;阅读标签&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1342230680016683009#wechat_redirect&quot; target=&quot;_blank&quot;&gt;Java基础&lt;/a&gt;】【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1709518416274833422#wechat_redirect&quot; target=&quot;_blank&quot;&gt;设计模式&lt;/a&gt;】【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1709518416274833422#wechat_redirect&quot; target=&quot;_blank&quot;&gt;结构与算法&lt;/a&gt;】【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1334314473573744641#wechat_redirect&quot; target=&quot;_blank&quot;&gt;Linux系统&lt;/a&gt;】【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1376212870744358913#wechat_redirect&quot; target=&quot;_blank&quot;&gt;数据库&lt;/a&gt;】&lt;/p&gt;&lt;p&gt;【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1327025063014596608#wechat_redirect&quot; target=&quot;_blank&quot;&gt;分布式架构&lt;/a&gt;】【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1460269376221200386#wechat_redirect&quot; target=&quot;_blank&quot;&gt;微服务&lt;/a&gt;】【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1701021199339667459#wechat_redirect&quot; target=&quot;_blank&quot;&gt;大数据组件&lt;/a&gt;】【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1425309486268661760#wechat_redirect&quot; target=&quot;_blank&quot;&gt;SpringBoot进阶&lt;/a&gt;】【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1461797173297135618#wechat_redirect&quot; target=&quot;_blank&quot;&gt;Spring&amp;amp;Boot基础&lt;/a&gt;】&lt;/p&gt;&lt;p&gt;【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1695231212027428866#wechat_redirect&quot; target=&quot;_blank&quot;&gt;数据分析&lt;/a&gt;】【&lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1506615482391511042#wechat_redirect&quot; target=&quot;_blank&quot;&gt;技术导图&lt;/a&gt;】【 &lt;a href=&quot;https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU4Njg0MzYwNw==&amp;amp;action=getalbum&amp;amp;album_id=1719834087936278530#wechat_redirect&quot; target=&quot;_blank&quot;&gt;职场&lt;/a&gt;】&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/1691717/202008/1691717-20200811231321146-174169065.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Feb 2021 00:14:00 +0000</pubDate>
<dc:creator>知了一笑</dc:creator>
<og:description>试用期什么事情最重要？把那些能帮助自己快速转正的事情做好。 01 完成跳槽之后，进入新公司并不说明就算真正进入该公司，试用期的三个月考核这才是正式开始。 尤其互联网行业中，在试用期被离职或者主动离职的</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cicada-smile/p/14380525.html</dc:identifier>
</item>
<item>
<title>Vuejs 基础学习教程 - 1763392456</title>
<link>http://www.cnblogs.com/cnoneblog/p/14380521.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/cnoneblog/p/14380521.html</guid>
<description>&lt;p&gt;我们在实际开发中，我们一般会经历项目的开发阶段，测试阶段，和最终上线阶段，每个阶段对于项目代码的需要可能都有所不同，那我们怎么让它在不同阶段呈现不同的效果呢？我们下面看一下环境是不是可以解决这个问题呢？&lt;/p&gt;
&lt;p&gt;介绍&lt;/p&gt;

&lt;p&gt;正确的配置环境首先我们要认识一下不同配置之间的关系。随便画个图表示一下：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210110331723.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbnNlbjE5ODk=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;这里说的是最全的的可能，我们可以看到不同的环境有着不同的&lt;a title=&quot;http://www.dtmao.cc/news_show_1309867.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_1309867.shtml&quot; target=&quot;_blank&quot;&gt;配置&lt;/a&gt;，他们之间还有一些交集，就是他们的公公配置，那么我们思考一下在vue中我们需要怎么处理？&lt;br/&gt;其实很简单，就是在项目的跟目下创建不同的环境变量配置：&lt;br/&gt;如：&lt;br/&gt;.env 表示在所有环境中被载入&lt;br/&gt;.env.local 表示在所有环境中被载入，但是git会自动忽略&lt;br/&gt;.env.[mode] 表示只有指定的模式才会载入&lt;br/&gt;.env.[mode].local 表示只有在指定的模式才会载入，但是会被git自动忽略&lt;br/&gt;比如，我们在本地创建几个环境配置，如下图：&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210110346609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbnNlbjE5ODk=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;以.env.dev这个文件为例子，看一下这个文件中的环境变量怎么写&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210110514758.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;在脚本管理配置中加载这种环境模式试一下&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210110523124.png&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;马上启动一下看看这种环境是否生效&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210110530604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbnNlbjE5ODk=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;br/&gt;可以看到这种环境配置事情作用了的。&lt;/p&gt;
&lt;p&gt;这里其他的环境我们就不做详细讲解了，基本都八九不离十，这里我需要记录一下我测试的一些小发现，这些环境配置的优先权重是怎么样的呢。直接上干货：.env.[mode].local &amp;gt; .env.[mode] &amp;gt;.env.local &amp;gt;.env .&lt;br/&gt;但是这里说一下，除了环境的配置权重，不同的配置他们会进行合并操作，类似于Object.assign的用法。&lt;/p&gt;

&lt;p&gt;我们还可以通过新建配置文件的方式为不同的环境配置不同的变量，但是我们发现.env这种文件好像仅仅支持静态值。那怎么办，这里我想了一下发现可以手动在根目录下创建一个自己的配置文件。&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210110555651.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbnNlbjE5ODk=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们还可以直接在vue.config.js中直接注入这些动态地配置，这里可以查阅一下chainWebpack这个属性来修改DefinePlugin的值，我们看一下官网的写法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20181210110609233.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JlbnNlbjE5ODk=,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot;/&gt;&lt;/p&gt;

&lt;p&gt;环境的配置和管理对于项目的构建很重要，通过不同的项目配置可以增加灵活性，提高程序的扩展性，也可以帮我们有效的分析和定位不同环境下的运行机制和问题。&lt;/p&gt;
&lt;p&gt;&lt;span&gt;&lt;span&gt;&lt;a title=&quot;http://www.dtmao.cc/news_show_1309867.shtml&quot; href=&quot;http://www.dtmao.cc/news_show_1309867.shtml&quot; target=&quot;_blank&quot;&gt;&lt;span&gt;http://www.dtmao.cc/news_show_1309867.shtml&lt;/span&gt;&lt;/a&gt;&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
</description>
<pubDate>Sat, 06 Feb 2021 00:01:00 +0000</pubDate>
<dc:creator>1763392456</dc:creator>
<og:description>（四）构建基础进阶-env文件与环境设置 我们在实际开发中，我们一般会经历项目的开发阶段，测试阶段，和最终上线阶段，每个阶段对于项目代码的需要可能都有所不同，那我们怎么让它在不同阶段呈现不同的效果呢？</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/cnoneblog/p/14380521.html</dc:identifier>
</item>
<item>
<title>深入浅出Java线程池：源码篇 - 一只修仙的猿</title>
<link>http://www.cnblogs.com/huan89/p/14380465.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/huan89/p/14380465.html</guid>
<description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在上一篇文章&lt;a href=&quot;https://juejin.cn/post/6923856791117758472&quot; target=&quot;_blank&quot;&gt;深入浅出Java线程池：理论篇&lt;/a&gt;中，已经介绍了什么是线程池以及基本的使用。（本来写作的思路是使用篇，但经网友建议后，感觉改为理论篇会更加合适）。本文则深入线程池的源码，主要是介绍ThreadPoolExecutor内部的源码是如何实现的，对ThreadPoolExecutor有一个更加清晰的认识。&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor的源码相对而言比较好理解，没有特别难以读懂的地方。相信没有阅读源码习惯的读者，跟着本文，也可以很轻松地读懂ThreadPoolExecutor的核心源码逻辑。&lt;/p&gt;
&lt;p&gt;本文源码jdk版本为8，该类版本为jdk1.5，也就是在1.5之后，ThreadPoolExecutor的源码没有做修改。&lt;/p&gt;
&lt;h2 id=&quot;线程池家族&quot;&gt;线程池家族&lt;/h2&gt;
&lt;p&gt;Java中的线程池继承结构如下图：(类图中只写了部分方法且省略参数)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5140b90e35a94f10808ce1f449d32e50~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;顶层接口Executor表示一个执行器，他只有一个接口：&lt;code&gt;execute()&lt;/code&gt; ，表示可以执行任务&lt;/li&gt;
&lt;li&gt;ExecutorService在Executor的基础上拓展了更多的执行方法，如&lt;code&gt;submit()&lt;/code&gt; &lt;code&gt;shutdown()&lt;/code&gt; 等等,表示一个任务执行服务。&lt;/li&gt;
&lt;li&gt;AbstarctExecutorService是一个抽象类，他实现了ExecutorService的部分核心方法，如submit等&lt;/li&gt;
&lt;li&gt;ThreadPoolExecutor是最核心的类，也就是线程池，他继承了抽象类AbstarctExecutorService&lt;/li&gt;
&lt;li&gt;此外还有ScheduledExecutorService接口，他表示一个可以按照指定时间或周期执行的执行器服务，内部定义了如&lt;code&gt;schedule()&lt;/code&gt; 等方法来执行任务&lt;/li&gt;
&lt;li&gt;ScheduledThreadPoolExecutor实现了ScheduledExecutorService接口，同时继承于ThreadPoolExecutor，内部的线程池相关逻辑使用自ThreadPoolExecutor，在此基础上拓展了延迟、周期执行等功能特性&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;ScheduledThreadPoolExecutor相对来说用的是比较少。延时任务在我们Android中有更加熟悉的方案：Handler；而周期任务则用的非常少。现在android的后台限制非常严格，基本上一退出应用，应用进程很容易被系统干掉。当然ScheduledThreadPoolExecutor也不是完全没有用处，例如桌面小部件需要设置定时刷新，那么他就可以派上用场了。&lt;/p&gt;
&lt;p&gt;因此，我们本文的源码，主要针对ThreadPoolExecutor。在阅读源码之前，我们先来看一下ThreadPoolExecutor内部的结构以及关键角色。&lt;/p&gt;
&lt;h2 id=&quot;内部结构&quot;&gt;内部结构&lt;/h2&gt;
&lt;p&gt;阅读源码前，我们先把ThreadPoolExecutor整个源码结构讲解一下，形成一个整体概念，再阅读源码就不会迷失在源码中了。先来看一下ThreadPoolExecutor的内部结构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/90c4d7afa6164b72aefff5ac7af29379~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;yGOUkq.md.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ThreadPoolExecutor内部有三个关键的角色：阻塞队列、线程、以及RejectExecutionHandler（这里写个中文名纯粹因为不知道怎么翻译这个名字），他们的作用在理论篇有详细介绍，这里不再赘述。&lt;/li&gt;
&lt;li&gt;在ThreadPoolExecutor中，一个线程对应一个worker对象，工人，非常形象。每个worker内部有一个独立的线程，他会不断去阻塞队列获取任务来执行，也就是调用阻塞队列的 &lt;code&gt;poll&lt;/code&gt; 或者 &lt;code&gt;take&lt;/code&gt; 方法，他们区别后面会讲。如果队列没有任务了，那么就会阻塞在这里。&lt;/li&gt;
&lt;li&gt;workQueue，就是阻塞队列，当核心线程已满之后，任务就会被放置在这里等待被工人worker领取执行&lt;/li&gt;
&lt;li&gt;RejectExecutionHandler本身是一个接口，ThreadPoolExecutor内部有这样的一个接口对象，当任务无法被执行会调用这个对象的方法。ThreadPoolExecutor提供了该接口的4种实现方案，我们可以直接拿来用，或者自己继承接口，实现自定义逻辑。在构造线程池的时候可以传入RejectExecutionHandler对象。&lt;/li&gt;
&lt;li&gt;整个ThreadPoolExecutor中最核心的方法就是execute，他会根据具体的情况来选择不同的执行方案或者拒绝执行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这样，我们就清楚ThreadPoolExecutor的内部结构了，然后，我们开始 Read the fucking code 吧。&lt;/p&gt;
&lt;h2 id=&quot;源码分析&quot;&gt;源码分析&lt;/h2&gt;
&lt;h4 id=&quot;内部关键属性&quot;&gt;内部关键属性&lt;/h4&gt;
&lt;p&gt;ThreadPoolExecutor内部有很多的变量，他们包含的信息非常重要，先来了解一下。&lt;/p&gt;
&lt;p&gt;ThreadPoolExecutor的状态和线程数整合在同一个int变量中，类似于view测量中MeasureSpec。他的高三位表示线程池的状态，低29位表示线程池中线程的数量,如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// AtomicInteger对象可以利用CAS实现线程安全的修改，其中包含了线程池状态和线程数量信息
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));
// COUNT_BITS=29,（对于int长度为32来说）表示线程数量的字节位数
private static final int COUNT_BITS = Integer.SIZE - 3;
// 状态掩码，高三位是1，低29位全是0，可以通过 ctl&amp;amp;COUNT_MASK 运算来获取线程池状态
private static final int COUNT_MASK = (1 &amp;lt;&amp;lt; COUNT_BITS) - 1;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;线程池的状态一共有5个：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;运行running：线程池创建之后即是运行状态&lt;/li&gt;
&lt;li&gt;关闭shutdown：调用shutdown方法之后线程池处于shutdown状态，该状态会停止接收任何任务，阻塞队列中的任务执行完成之后会自动终止线程池&lt;/li&gt;
&lt;li&gt;停止stop：调用shutdownNow方法之后线程池处于stop状态。和shutdown的区别是这个状态下的线程池不会去执行队列中剩下的任务&lt;/li&gt;
&lt;li&gt;整理tidying：在线程池stop之后，进入tidying状态，然后执行 &lt;code&gt;terminated()&lt;/code&gt; 方法，再进入terminated状态&lt;/li&gt;
&lt;li&gt;终止terminated：线程池中没有任何线程在执行任务，线程池完全终止。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;在源码中这几个状态分别对应：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// runState is stored in the high-order bits
private static final int RUNNING    = -1 &amp;lt;&amp;lt; COUNT_BITS;
private static final int SHUTDOWN   =  0 &amp;lt;&amp;lt; COUNT_BITS;
private static final int STOP       =  1 &amp;lt;&amp;lt; COUNT_BITS;
private static final int TIDYING    =  2 &amp;lt;&amp;lt; COUNT_BITS;
private static final int TERMINATED =  3 &amp;lt;&amp;lt; COUNT_BITS;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;上面的位操作不够直观，转化后如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private static final int RUNNING    = 111 00000 00000000 00000000 00000000;
private static final int SHUTDOWN   = 000 00000 00000000 00000000 00000000; 
private static final int STOP       = 001 00000 00000000 00000000 00000000;
private static final int TIDYING    = 010 00000 00000000 00000000 00000000;
private static final int TERMINATED = 011 00000 00000000 00000000 00000000;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到除了running是负数，其他的状态都是正数，且状态越靠后，数值越大。因此我们可以通过判断 &lt;code&gt;ctl&amp;amp;COUNT_MASK &amp;gt; SHUTDOWN&lt;/code&gt; 来判断状态是否处于 stop、tidying、terminated之一。后续源码中会有很多的这样的判断，举其中的一个方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 这里来判断线程池的状态
if(runStateAtLeast(ctl,SHUTDOWN)) {
    ...
}
// 这里执行逻辑，直接判断两个数的大小
private static boolean runStateAtLeast(int c, int s) {
    return c &amp;gt;= s;
}

ps：这里怎么没有使用掩码COUNT_MASK ？因为状态是处于高位，低位的数值不影响高位的大小判断。当然如果要判断相等，就还是需要使用掩码COUNT_MASK的。
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接下来是ThreadPoolExecutor内部的三个关键角色对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 阻塞队列
private final BlockingQueue&amp;lt;Runnable&amp;gt; workQueue;
// 存储worker的hashSet,worker被创建之后会被存储到这里
private final HashSet&amp;lt;Worker&amp;gt; workers = new HashSet&amp;lt;&amp;gt;();
// RejectedExecutionHandler默认的实现是AbortPolicy
private volatile RejectedExecutionHandler handler;
private static final RejectedExecutionHandler defaultHandler =
        new AbortPolicy();

&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;内部使用的锁对象：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 这里是两个锁。ThreadPoolExecutor内部并没有使用Synchronize关键字来保持同步
// 而是使用Lock；和Synchronize的区别就是他是应用层的锁，而synchronize是jvm层的锁
private final ReentrantLock mainLock = new ReentrantLock();
private final Condition termination = mainLock.newCondition();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后是内部一些参数的配置，前面都介绍过，把源码贴出来再回顾一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 线程池历史达到的最大线程数
private int largestPoolSize;
// 线程池完成的任务数。
// 该数并不是实时更新的，在获取线程池完成的任务数时，需要去统计每个worker完成的任务并累加起来
// 当一个worker被销毁之后，他的任务数就会被累加到这个数据中
private long completedTaskCount;
// 线程工厂，用于创建线程
private volatile ThreadFactory threadFactory;
// 空闲线程存储的时间
private volatile long keepAliveTime;
// 是否允许核心线程被回收
private volatile boolean allowCoreThreadTimeOut;
// 核心线程数限额
private volatile int corePoolSize;
// 线程总数限额
private volatile int maximumPoolSize;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不是吧sir？源码还没看到魂呢，整出来这么无聊的变量？&lt;br/&gt;咳咳，别急嘛，源码解析马上来。这些变量会贯穿整个源码过程始终，先对他们有个印象，后续阅读源码就会轻松畅通很多。&lt;/p&gt;
&lt;h4 id=&quot;关键方法：execute&quot;&gt;关键方法：execute()&lt;/h4&gt;
&lt;p&gt;这个方法的主要任务就是根据线程池的当前状态，选择任务的执行策略。该方法的核心逻辑思路是：&lt;/p&gt;
&lt;ol readability=&quot;9&quot;&gt;&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;在线程数没有达到核心线程数时，会创建一个核心线程来执行任务&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void execute(Runnable command) {
    // 不能传入空任务
    if (command == null)
        throw new NullPointerException();

    // 获取ctl变量，就是上面我们讲的将状态和线程数合在一起的一个变量
    int c = ctl.get();
    // 判断核心线程数是否超过限额，否则创建一个核心线程来执行任务
    if (workerCountOf(c) &amp;lt; corePoolSize) {
        // addWorker方法是创建一个worker，也就是创建一个线程，参数true表示这是一个核心线程
        // 如果添加成功则直接返回
        // 否则意味着中间有其他的worker被添加了，导致超出核心线程数;或者线程池被关闭了等其他情况
        // 需要进入下一步继续判断
        if (addWorker(command, true))
            return;
        c = ctl.get();
    }
    ...
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;当线程数达到核心线程数时，新任务会被放入到等待队列中等待被执行&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;当等待队列已经满了之后，如果线程数没有到达总的线程数上限，那么会创建一个非核心线程来执行任务&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;8&quot;&gt;
&lt;p&gt;当线程数已经到达总的线程数限制时，新的任务会被拒绝策略者处理，线程池无法执行该任务。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void execute(Runnable command) {
    ...
    // 如果线程池还在运行,则尝试添加任务到队列中
    if (isRunning(c) &amp;amp;&amp;amp; workQueue.offer(command)) {
        int recheck = ctl.get();
        // 再次检查如果线程池被关闭了，那么把任务移出队列
        // 如果移除成功则拒绝本次任务
        // 这里主要是判断在插入队列的过程中，线程池有没有被关闭了
        if (! isRunning(recheck) &amp;amp;&amp;amp; remove(command))
            reject(command);
        // 否则再次检查线程数是否为0，如果是，则创建一个没有任务的非主线程worker
        // 这里对应核心线程为0的情况，指定任务为null，worker会去队列拿任务来执行
        // 这里表示线程池至少有一个线程来执行队列中的任务
        else if (workerCountOf(recheck) == 0)
            addWorker(null, false);
    }
    // 如果上面添加到队列中失败，则尝试创建一个非核心线程来执行任务
    // 如果创建失败，则拒绝任务
    else if (!addWorker(command, false))
        reject(command);
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;源码中还设计到两个关键方法：addWorker创建一个新的worker，也就是创建一个线程；reject拒绝一个任务。后者比较简单我们先看一下。&lt;/p&gt;
&lt;h4 id=&quot;拒绝任务：reject&quot;&gt;拒绝任务：reject()&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 拒绝任务，调用rejectedExecutionHandler来处理
final void reject(Runnable command) {
    handler.rejectedExecution(command, this);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;默认的实现类有4个，我们依次来看一下：&lt;/p&gt;
&lt;ul readability=&quot;11.5&quot;&gt;&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;AbortPolicy是默认实现，会抛出一个RejectedExecutionException异常：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static class AbortPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +
                                             &quot; rejected from &quot; +
                                             e.toString());
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;DiscardPolicy最简单，就是：什么都不做，直接抛弃任务。（这是非常渣男不负责任的行为，咱们不能学他，所以也不要用它 [此处狗头] ）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static class DiscardPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;5&quot;&gt;
&lt;p&gt;DiscardOldestPolicy会删除队列头的一个任务，然后再次执行自己（挤掉原位，自己上位，绿茶行为？）&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static class DiscardOldestPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            e.getQueue().poll();
            e.execute(r);
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;li readability=&quot;4&quot;&gt;
&lt;p&gt;CallerRunsPolicy最猛，他干脆在自己的线程执行run方法，不依靠线程池了，自己动手丰衣足食。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public static class CallerRunsPolicy implements RejectedExecutionHandler {
    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
        if (!e.isShutdown()) {
            r.run();
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面4个ThreadPoolExecutor已经帮我们实现了，他的静态内部类，在创建ThreadPoolExecutor的时候我们可以直接拿来用。也可以自己继承接口实现自己的逻辑。具体选择哪个需要根据实际的业务需求来决定。&lt;/p&gt;
&lt;p&gt;那么接下来看创建worker的方法。&lt;/p&gt;
&lt;h4 id=&quot;创建worker：addworker&quot;&gt;创建worker：addWorker()&lt;/h4&gt;
&lt;p&gt;方法的目的很简单：创建一个worker。前面我们讲到，worker内部创建了一个线程，每一个worker则代表了一个线程，非常类似android中的looper。looper的loop()方法会不断地去MessageQueue获取message，而Worker的run()方法会不断地去阻塞队列获取任务，这个我们后面讲。&lt;/p&gt;
&lt;p&gt;addWorker() 方法的逻辑整体上分为两个部分：&lt;/p&gt;
&lt;ol readability=&quot;10&quot;&gt;&lt;li readability=&quot;14&quot;&gt;
&lt;p&gt;检查&lt;strong&gt;线程状态&lt;/strong&gt;和&lt;strong&gt;线程数&lt;/strong&gt;是否满足条件：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 第一个参数是创建的线程首次要执行的任务，可以是null，则表示初始化一个线程
// 第二参数表示是否是一个核心线程
private boolean addWorker(Runnable firstTask, boolean core) {
    retry:
    for (int c = ctl.get();;) {
        // 还记不记得我们前面讲到线程池的状态控制？
        // runStateAtLeast(c, SHUTDOWN)表示状态至少为shutdown，后面类同
        // 如果线程池处于stop及以上，不会再创建worker
        // 如果线程池状态在shutdown时，如果队列不为空或者任务!=null，则还会创建worker
        if (runStateAtLeast(c, SHUTDOWN)
            &amp;amp;&amp;amp; (runStateAtLeast(c, STOP)
                || firstTask != null
                || workQueue.isEmpty()))
            // 其他情况返回false，表示拒绝创建worker
            return false;
        
                // 这里采用CAS轮询，也就是循环锁的策略来让线程总数+1
        for (;;) {
            // 检查是否超出线程数限制
            // 这里根据core参数判断是核心线程还是非核心线程
            if (workerCountOf(c)
                &amp;gt;= ((core ? corePoolSize : maximumPoolSize) &amp;amp; COUNT_MASK))
                return false;
            // 利用CAS让ctl变量自增，表示worker+1
            // 如果CAS失败，则表示发生了竞争，则再来一次
            if (compareAndIncrementWorkerCount(c))
                // 成功则跳出最外层循环
                break retry;
            // 如果这个期间ctl被改变了，则获取ctl，再尝试一次
            c = ctl.get();  
            // 如果线程池被shutdown了，那么重复最外层的循环，重新判断状态是否可以创建worker
            if (runStateAtLeast(c, SHUTDOWN))
                // 继续最外层循环
                continue retry;
        }
    }
    
    // 创建worker逻辑
    ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;不知道读者对于源码中的&lt;code&gt;retry:&lt;/code&gt; 有没有疑惑，毕竟平时很少用到。他的作用是标记一个循环，这样我们在内层的循环就可以跳转到任意一个外层的循环。这里的retry只是一个名字，改成 &lt;code&gt;repeat:&lt;/code&gt; 甚至 &lt;code&gt;a:&lt;/code&gt; 都是可以的。他的本质就是：&lt;strong&gt;一个循环的标记&lt;/strong&gt; 。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;6&quot;&gt;
&lt;p&gt;创建worker对象，并调用其内部线程的start()方法来启动线程：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private boolean addWorker(Runnable firstTask, boolean core) {
        ...
    boolean workerStarted = false;
    boolean workerAdded = false;
    Worker w = null;
    try {
        // 创建一个新的worker
        // 创建的过程中内部会创建一个线程
        w = new Worker(firstTask);
        final Thread t = w.thread;
        if (t != null) {
            // 获得全局锁并加锁
            final ReentrantLock mainLock = this.mainLock;
            mainLock.lock();
            try {
                // 获取锁之后，需要再次检查状态
                int c = ctl.get();
                                // 只有运行状态或者shutDown&amp;amp;&amp;amp;task==null才会被执行
                if (isRunning(c) ||
                    (runStateLessThan(c, STOP) &amp;amp;&amp;amp; firstTask == null)) {
                    // 如果这个线程不是刚创建的，则抛出异常
                    if (t.getState() != Thread.State.NEW)
                        throw new IllegalThreadStateException(); 
                    // 添加到workerSet中
                    workers.add(w);
                    workerAdded = true;
                    int s = workers.size();
                    // 跟踪线程池到达的最多线程数量
                    if (s &amp;gt; largestPoolSize)
                        largestPoolSize = s;
                }
            } finally {
                // 释放锁
                mainLock.unlock();
            }
            // 如果添加成功，启动线程
            if (workerAdded) {
                t.start();
                workerStarted = true;
            }
        }
    } finally {
        // 如果线程没有启动，表示添加worker失败，可能在添加的过程中线程池被关闭了
        if (! workerStarted)
            // 把worker从workerSet中移除
            addWorkerFailed(w);
    }
    return workerStarted;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;经过前面两步，如果没有出现异常，则创建worker成功。最后还涉及到一个方法： &lt;code&gt;addWorkerFailed(w)&lt;/code&gt; ，他的内容比较简答，顺便提一下吧：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 添加worker失败
private void addWorkerFailed(Worker w) {
    final ReentrantLock mainLock = this.mainLock;
    // 加锁
    mainLock.lock();
    try {
        if (w != null)
            workers.remove(w);
        // 这里会让线程总数-1
        decrementWorkerCount();
        // 尝试设置线程池的状态为terminad
        // 因为添加失败有可能是线程池在添加worker的过程中被shutdown
        // 那么这个时候如果没有任务正在执行就需要设置状态为terminad
        // 这个方法后面会详细讲
        tryTerminate();
    } finally {
        mainLock.unlock();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;那么到这里，execute()方法中的一些调用方法就分析完了。阻塞队列相关的方法不属于本文的范畴，就不展开了。那么还有一个问题：worker是如何工作的呢？worker内部有一个线程，当线程启动时，初始化线程的runnable对象的run方法会被调用，那么这个runnable对象是什么？我直接来看worker。&lt;/p&gt;
&lt;h4 id=&quot;打工人：worker&quot;&gt;打工人：Worker&lt;/h4&gt;
&lt;p&gt;首先我们看到他的构造方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;Worker(Runnable firstTask) {
    setState(-1); // inhibit interrupts until runWorker
    this.firstTask = firstTask;
    this.thread = getThreadFactory().newThread(this);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;源码很简单，把传进来的任务设置给内部变量firstTask，然后把自己传给线程工厂去创建一个线程。所以线程启动时，Worker本身的run方法会被调用，那么我们看到Worker的 &lt;code&gt;run()&lt;/code&gt;方法。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;public void run() {
    runWorker(this);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;Worker是ThreadPoolExecutor的内部类，这里直接调用到了ThreadPoolExecutor的方法： &lt;code&gt;runWorker()&lt;/code&gt;来开始执行。那么接下来，我们就看到这个方法。&lt;/p&gt;
&lt;h4 id=&quot;启动worker：runworker&quot;&gt;启动worker：runWorker()&lt;/h4&gt;
&lt;p&gt;这个方法是worker执行的方法，在线程被销毁前他会一直执行，类似于Handler的looper，不断去队列获取消息来执行：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final void runWorker(Worker w) {
    Thread wt = Thread.currentThread();
    // 获取worker初始化时设置的任务，可以为null。如果为null则表示仅仅创建线程
    Runnable task = w.firstTask;
    w.firstTask = null;
    w.unlock(); 
    // 这个参数的作用后面解释，需要结合其他的源码
    boolean completedAbruptly = true;
    try {
        // 如果自身的task不为null，那么会执行自身的task
        // 否则调用getTask去队列获取一个task来执行
        // 这个getTask最终会去调用队列的方法来获取任务
        // 而队列如果为空他的获取方法会进行阻塞，这里也就阻塞了,后面深入讲
        while (task != null || (task = getTask()) != null) {
            try{
            // 执行任务
            ...
            } finally {
                // 任务执行完成，把task设置为null
                task = null;
                // 任务总数+1
                w.completedTasks++;
                // 释放锁
                w.unlock();
            }
        }
        // 这里设置为false，先记住他
        completedAbruptly = false;
    } finally {
        // 如果worker退出，那么需要执行后续的善后工作
        processWorkerExit(w, completedAbruptly);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这个方法的整体框架还是比较简单的，核心就在于 &lt;code&gt;while (task != null || (task = getTask()) != null)&lt;/code&gt; 这个循环中，如果 &lt;code&gt;getTask()&lt;/code&gt; 返回null，则表示线程该结束了，这和Handler机制也是一样的。&lt;/p&gt;
&lt;p&gt;上面的源码省略了具体执行任务的逻辑，他的逻辑也是很简单：判断状态+运行任务。我们来看一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final void runWorker(Worker w) {
    ...;
    try {
        while (task != null || (task = getTask()) != null) {
            w.lock();
            // 如果线程池已经设置为stop状态，那么保证线程是interrupted标志
            // 如果线程池没有在stop状态，那么保证线程不是interrupted标志
            if ((runStateAtLeast(ctl.get(), STOP) ||
                 (Thread.interrupted() &amp;amp;&amp;amp;
                  runStateAtLeast(ctl.get(), STOP))) &amp;amp;&amp;amp;
                !wt.isInterrupted())
                wt.interrupt();
            try {
                // 回调方法，这个方法是一个空实现
                beforeExecute(wt, task);
                try {
                    // 运行任务
                    task.run();
                    // 回调方法，也是一个空实现
                    afterExecute(task, null);
                } catch (Throwable ex) {
                    afterExecute(task, ex);
                    throw ex;
                }
            }
            ...
        }
        completedAbruptly = false;
    } finally {
        processWorkerExit(w, completedAbruptly);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;在获取到一个任务后，就会去执行该任务的run方法，然后再回去继续获取新的任务。&lt;/p&gt;
&lt;p&gt;我们会发现其中有很多的空实现方法，他是给子类去实现的，有点类似于Activity的生命周期，子类需要重写这些方法，在具体的情况做一些工作。当然，一般的使用是不需要去重写这些方法。接下来需要来看看 &lt;code&gt;getTask()&lt;/code&gt; 是如何获取任务的。&lt;/p&gt;
&lt;h4 id=&quot;获取任务：gettask&quot;&gt;获取任务：getTask()&lt;/h4&gt;
&lt;p&gt;这个方法的内容可以分为两个部分：判断当前线程池的状态+阻塞地从队列中获取一个任务。&lt;/p&gt;
&lt;p&gt;第一部分是判断当前线程池的状况，如果处于关闭状态那么直接返回null来让worker结束，否则需要判断当前线程是否超时或者超出最大限制的线程数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Runnable getTask() {
    boolean timedOut = false; 
    // 内部使用了CAS，这里需要有一个循环来不断尝试
    for (;;) {
        int c = ctl.get();
        // 如果处于shutdown状态而且队列为空，或者处于stop状态，返回null
        // 这和前面我们讨论到不同的线程池的状态的不同行为一致
        if (runStateAtLeast(c, SHUTDOWN)
            &amp;amp;&amp;amp; (runStateAtLeast(c, STOP) || workQueue.isEmpty())) {
            // 这里表示让线程总数-1，记住他，后面会继续聊到
            decrementWorkerCount();
            return null;
        }
        
        // 获取目前的线程总数
        int wc = workerCountOf(c);
        // 判断该线程在空闲情况是否可以被销毁：允许核心线程为null或者当前线程超出核心线程数
        // 可以看到这里并没有去区分具体的线程是核心还是非核心，只有线程数量处于核心范围还是非核心范围
        boolean timed = allowCoreThreadTimeOut || wc &amp;gt; corePoolSize;
        // 超出最大线程数或者已经超时；
        // 这里可能是用户通过 setMaximumPoolSize 改动了数据才会导致这里超出最大线程数
        // 同时还必须保证当前线程数量大于1或者队列已经没有任务了
        // 这样就确保了当有任务存在时，一定至少有一个线程在执行任务
        if ((wc &amp;gt; maximumPoolSize || (timed &amp;amp;&amp;amp; timedOut))
            &amp;amp;&amp;amp; (wc &amp;gt; 1 || workQueue.isEmpty())) {
            // 使用CAS尝试让当前线程总数-1，失败则从来一次上面的逻辑
            if (compareAndDecrementWorkerCount(c))
                return null;
            continue;
        }
        
        // 获取任务逻辑
        ...
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;第二部分是获取一个任务并执行。获取任务使用的是阻塞队列的方法，如果队列中没有任务，则会被阻塞：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private Runnable getTask() {
    boolean timedOut = false; 
    // 内部使用了CAS，这里需要有一个循环来不断尝试
    for (;;) {
        // 判断线程池状态逻辑
        ...
        try {
            // 获取一个任务
            // poll方法等待具体时间之后如果没有获取到对象，会返回null
            // take方法会一直等到获取新对象，除非被interrupt
            Runnable r = timed ?
                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
                workQueue.take();
            if (r != null)
                return r;
            // r==null,说明超时了，重新循环
            timedOut = true;
        } catch (InterruptedException retry) {
            // 被interrupt，说明可能线程池被关闭了，重新判断情况
            timedOut = false;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;这里需要重点关注的是阻塞队列的 &lt;code&gt;poll()&lt;/code&gt; 和 &lt;code&gt;take()&lt;/code&gt; 方法，他们都会去队列中获取一个任务；但是，&lt;code&gt;poll()&lt;/code&gt; 方法会阻塞指定时间后返回，而 &lt;code&gt;take()&lt;/code&gt; 则是无限期阻塞。这里对应的就是有存活时间的线程和不会被销毁的核心线程。&lt;/p&gt;
&lt;p&gt;同时注意 &lt;code&gt;timedOut = true&lt;/code&gt; 是在这一部分被赋值的，当赋值为true之后需要再执行一次循环，在上面的判断中就会被拦截下来并返回false，这在第一部分逻辑介绍了。而如果线程在等待的时候被 &lt;code&gt;interrupt&lt;/code&gt; 了，说明线程池被关闭了，此时也会重走一次上面判断状态的逻辑。&lt;/p&gt;
&lt;p&gt;到这里关于执行的逻辑就讲得差不多了，下面聊一聊线程池关闭以及worker结束的相关逻辑。&lt;/p&gt;
&lt;h4 id=&quot;worker退出工作：processworkerexit&quot;&gt;worker退出工作：processWorkerExit&lt;/h4&gt;
&lt;p&gt;前面已经介绍 &lt;code&gt;runWorker()&lt;/code&gt; 了方法，这个方法的主要任务就是让worker动起来，不断去队列获取任务。而当获取任务的时候返回了null，则表示该worker可以结束了，最后会调用 &lt;code&gt;processWorkerExit()&lt;/code&gt; 方法，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final void runWorker(Worker w) {
    ...
    try {
       ...
    } finally {
        // 如果worker退出，那么需要执行后续的善后工作
        processWorkerExit(w, completedAbruptly);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;processWorkerExit()&lt;/code&gt; 会完成worker退出的善后工作。具体的内容是：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;把完成的任务数合并到总的任务数,移除worker，尝试设置线程池的状态为terminated：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void processWorkerExit(Worker w, boolean completedAbruptly) {
    // 如果不是经过getTask方法返回null正常退出的，那么需要让线程总数-1
    // 这个参数前面一直让你们注意一下不知道你们还记不记得
    // 如果是在正常情况下退出，那么在getTask() 方法中就会执行decrementWorkerCount()了
    // 而如果出现一些特殊的情况突然结束了，并不是通过在getTask返回null结束
    // Abruptly就是突然的意思，那么completedAbruptly就为true,正常情况下在runWorker方法中会被设置为false
    // 那什么叫突然结束？用户的任务抛出了异常，这个时候线程就突然结束了，没有经过getTask方法
    // 这里就需要让线程总数-1
    if (completedAbruptly) 
        decrementWorkerCount();

    // 获取锁，并累加完成的任务总数，从set中移除worker
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        completedTaskCount += w.completedTasks;
        workers.remove(w);
    } finally {
        mainLock.unlock();
    }

    // 尝试设置线程池的状态为terminated
    // 这个方法前面我们addWorker失败的时候提到过，后面再展开
    tryTerminate();
        ...
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;移除worker之后，如果线程池还没有被stop，那么最后必须保证队列任务至少有一个线程在执行队列中的任务：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;private void processWorkerExit(Worker w, boolean completedAbruptly) {
    ...
        int c = ctl.get();
    // stop及以上的状态不需要执行剩下的任务
    if (runStateLessThan(c, STOP)) {
        // 如果线程是突然终止的，那肯定需要重新创建一个
        // 否则进行判断是否要保留一个线程
        if (!completedAbruptly) {
            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;
            if (min == 0 &amp;amp;&amp;amp; ! workQueue.isEmpty())
                min = 1;
            if (workerCountOf(c) &amp;gt;= min)
                return; 
        }
        // 如果此时线程数&amp;lt;=核心线程数，或者当核心线程可被销毁时，线程数==0且队列不为空
        // 那么需要创建一个线程来执行任务
        addWorker(null, false);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;代码虽然看起来很多，但是具体的逻辑内容还是比较简单的。前面一直提到一个方法 &lt;code&gt;tryTerminate()&lt;/code&gt; 但一直没有展开解释，下面来介绍一下。&lt;/p&gt;
&lt;h4 id=&quot;尝试终止线程池：tryterminate&quot;&gt;尝试终止线程池：tryTerminate()&lt;/h4&gt;
&lt;p&gt;这个方法出现在任何可能让线程池进入终止状态的地方。如添加worker失败时，那么这个时候可能线程池已经处于stop状态，且已经没有任何正在执行的worker了，那么此时可以进入terminated状态；再如worker被销毁的时候，可能这是最后一个被销毁的worker，那么此时线程池需要进入terminated状态。&lt;/p&gt;
&lt;p&gt;根据这个方法的使用情况其实就已经差不多可以推断出这个方法的内容：&lt;strong&gt;判断当前线程池的状态，如果符合条件则设置线程池的状态为terminated&lt;/strong&gt; 。如果此时不能转换为terminated状态，则什么也不做，直接返回。&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;首先判断当前线程池状态是否符合转化为terminated。如果处于运行状态或者tidying以上状态，则肯定不需要进行状态转换。因为running需要先进入stop状态，而tidying其实已经是准备进入terminated状态了。如果处于shutdown状态且队列不为空，那么需要执行完队列中的任务，所以也不适合状态转换：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final void tryTerminate() {
    for (;;) {
        int c = ctl.get();
        // 如果处于运行状态或者tidying以上状态时，直接返回，不需要修改状态
        // 如果处于stop以下状态且队列不为空，那么需要等队列中的任务执行完成，直接返回
        if (isRunning(c) ||
            runStateAtLeast(c, TIDYING) ||
            (runStateLessThan(c, STOP) &amp;amp;&amp;amp; ! workQueue.isEmpty()))
            return;
        // 到这里说明线程池肯定处于stop状态
        // 线程的数量不等于0，尝试中断一个空闲的worker线程
        // 这里他只中断workerSet中的其中一个，当其中的一个线程停止时，会再次调用tryTerminate
        // 然后又会再去中断workerSet中的一个worker，不断循环下去直到剩下最后一个，workercount==0
        // 这就是 链式反应 。
        if (workerCountOf(c) != 0) { 
            interruptIdleWorkers(ONLY_ONE);
            return;
        }
                
        // 设置状态为terminated逻辑
        ...
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ol start=&quot;2&quot;&gt;&lt;li&gt;经过上面的判断，能到第二部分逻辑，线程池肯定是具备进入terminated状态的条件了。剩下的代码就是把线程池的状态设置为terminated：&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;final void tryTerminate() {
    for (;;) {
        // 上一部分逻辑
        ...
        // 首先获取全局锁
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            // 尝试把线程池的状态从stop修改为tidying
            // 如果修改失败，说明状态已经被修改了，那么外层循环再跑一个
            if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) {
                try {
                    // 这个方法是一个空实现，需要子类继承重写
                    terminated();
                } finally {
                    // 最后再设置状态为terminated
                    ctl.set(ctlOf(TERMINATED, 0));
                    // 唤醒所有等待终止锁的线程
                    termination.signalAll();
                }
                return;
            }
        } finally {
            // 释放锁
            mainLock.unlock();
        }
        // CAS修改线程池的状态失败，重新进行判断
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;当线程池被标记为terminated状态时，那么这个线程池就彻底地终止了。&lt;/p&gt;
&lt;p&gt;好了到这里，恭喜你，关于ThreadPoolExecutor的源码解析理解得差不多了。接下来剩下几个常用的api方法：&lt;code&gt;submit()&lt;/code&gt; 、 &lt;code&gt;shutdown()/shutdownNow()&lt;/code&gt; 顺便看一下吧，他们的逻辑也是都非常简单。&lt;/p&gt;
&lt;h4 id=&quot;关闭线程池：shutdownshutdownnow&quot;&gt;关闭线程池：shutdown/shutdownNow&lt;/h4&gt;
&lt;p&gt;关闭线程池有两个方法：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;shutdown：设置线程池的状态为shutdown，同时尝试中断所有空闲线程，但是会等待队列中的任务执行结束再终止线程池。&lt;/li&gt;
&lt;li&gt;shutdownNow：设置线程池的状态为stop，同时尝试中断所有空闲线程，不会等待队列中的任务完成，正在执行中的线程执行结束，线程池马上进入terminated状态。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我们各自来看一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 关闭后队列中的任务依旧会被执行，但是不会再添加新的任务
public void shutdown() {
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        checkShutdownAccess();
        // 设置状态为shutdown
        advanceRunState(SHUTDOWN);
        // 尝试中断所有空闲的worker
        interruptIdleWorkers();
        // 回调方法，这个方法是个空方法，ScheduledThreadPoolExecutor中重写了该方法
        onShutdown(); 
    } finally {
        mainLock.unlock();
    }
    // 尝试设置线程池状态为terminated
    tryTerminate();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;再看一下另一个方法shutdownNow：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 关闭后队列中剩余的任务不会被执行
// 会把剩下的任务返回交给开发者去处理
public List&amp;lt;Runnable&amp;gt; shutdownNow() {
    List&amp;lt;Runnable&amp;gt; tasks;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try {
        // 检查是否可以关闭线程
        checkShutdownAccess();
        // 设置状态为stop
        advanceRunState(STOP);
        // 尝试中断所有线程
        interruptWorkers();
        // 返回队列中剩下的任务
        tasks = drainQueue();
    } finally {
        mainLock.unlock();
    }
    tryTerminate();
    return tasks;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;最后再来看一下和 &lt;code&gt;execute()&lt;/code&gt;不同的提交任务方法：submit。&lt;/p&gt;
&lt;h4 id=&quot;提交任务：submit&quot;&gt;提交任务：submit()&lt;/h4&gt;
&lt;p&gt;submit方法并不是ThreadPoolExecutor实现的，而是AbstractExecutorService，如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// runnable没有返回值，创建FutureTask的返回参数传入null
public Future&amp;lt;?&amp;gt; submit(Runnable task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture&amp;lt;Void&amp;gt; ftask = newTaskFor(task, null);
    execute(ftask);
    return ftask;
}
// 有参数返回值的runnable
// 最终也是构造一个callable来执行，把返回值设置为result
public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Runnable task, T result) {
    if (task == null) throw new NullPointerException();
    RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task, result);
    execute(ftask);
    return ftask;
}
// callable本身就拥有返回值
public &amp;lt;T&amp;gt; Future&amp;lt;T&amp;gt; submit(Callable&amp;lt;T&amp;gt; task) {
    if (task == null) throw new NullPointerException();
    RunnableFuture&amp;lt;T&amp;gt; ftask = newTaskFor(task);
    execute(ftask);
    return ftask;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;他们的逻辑都几乎一样：调用newTaskFor方法来构造一个Future对象并返回。我们看到newTaskFor方法：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-java&quot;&gt;// 创建一个FutureTask来返回
protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Runnable runnable, T value) {
    return new FutureTask&amp;lt;T&amp;gt;(runnable, value);
}
protected &amp;lt;T&amp;gt; RunnableFuture&amp;lt;T&amp;gt; newTaskFor(Callable&amp;lt;T&amp;gt; callable) {
    return new FutureTask&amp;lt;T&amp;gt;(callable);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可以看到这个方法很简单：构造一个FutureTask并返回，FutureTask也是Future接口目前唯一的实现类。&lt;/p&gt;
&lt;p&gt;更加具体关于Future的内容就不展开了，有兴趣的读者可以去了解一下。&lt;/p&gt;
&lt;h2 id=&quot;最后&quot;&gt;最后&lt;/h2&gt;
&lt;p&gt;好了到这里，关于ThreadPoolExecutor的源码分析内容就讲完了。最后让我们再回顾一下吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/de29e7d09e144e77b9095bf2f012a9f6~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;yGOUkq.md.png&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;ThreadPoolExecutor的整个执行流程从execute方法开始，他会根据具体的情况，采用合适的执行方案&lt;/li&gt;
&lt;li&gt;线程被封装在worker对象中，worker对象通过runWorker方法，会一直不断地调用getTask方法来调用队列的poll或take方法获取任务&lt;/li&gt;
&lt;li&gt;当需要退出一个worker时，只要getTask方法返回null即可退出&lt;/li&gt;
&lt;li&gt;当线程池关闭时，会根据不同的关闭方法，等待所有的线程执行完成，然后关闭线程池。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;线程池整体的模型和handler是十分类似的：一个生产者-消费者模型。但和Handler不同的是，ThreadPoolExecutor不支持延时任务，这点在ScheduledThreadPoolExecutor得到了实现；Handler的线程安全采用synchronize关键字，而ThreadPoolExecutor采用的是Lock和一些利用CAS实现线程安全的整型变量；Handler无法拒绝任务，线程池可以；Handler抛出异常会直接程序崩溃，而线程池不会等等。&lt;/p&gt;
&lt;p&gt;了解了线程池的内部源码，对于他更加了解后，那么可以根据具体的问题，做出更加合适的解决方案。ThreadPoolExecutor还有一些源码没有讲到，以及ScheduledThreadPoolExecutor、阻塞队列的源码，有兴趣读者可以自行去深入了解一下，拓展关于线程池的一切。&lt;/p&gt;
&lt;p&gt;全文到此，假期肝文不容易啊，如果文章对你有帮助，求一个大拇指&lt;img src=&quot;https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a3c8d81cc8f049c7a2fe0c675c66e0d9~tplv-k3u1fbpfcp-zoom-1.image&quot; alt=&quot;yJsExU.png&quot; loading=&quot;lazy&quot;/&gt;，赞一下再走呗。&lt;/p&gt;
&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;
&lt;ul&gt;&lt;li&gt;《Java并发编程的艺术》：并发编程必读，作者对一些原理讲的很透彻&lt;/li&gt;
&lt;li&gt;《Java核心技术卷》：这系列的书主要是讲解框架的使用，不会深入原理，适合入门&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://snailclimb.gitee.io/javaguide/#/./docs/java/multi-thread/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93?id=_61-%e7%ae%80%e4%bb%8b&quot; target=&quot;_blank&quot;&gt;javaGuide&lt;/a&gt;：javaGuide，对java知识总结得很不错的一个博客&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/dolphin0520/p/3932921.html&quot; target=&quot;_blank&quot;&gt;Java并发编程：线程池的使用&lt;/a&gt;：博客园上一位很优秀的博主，文章写得通俗易懂且不失深度&lt;/li&gt;
&lt;/ul&gt;&lt;blockquote readability=&quot;7.7&quot;&gt;
&lt;p&gt;全文到此，原创不易，觉得有帮助可以点赞收藏评论转发。&lt;br/&gt;笔者才疏学浅，有任何想法欢迎评论区交流指正。&lt;br/&gt;如需转载请评论区或私信交流。&lt;/p&gt;
&lt;p&gt;另外欢迎光临笔者的个人博客：&lt;a href=&quot;https://qwerhuan.gitee.io&quot; target=&quot;_blank&quot;&gt;传送门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
<pubDate>Fri, 05 Feb 2021 18:03:00 +0000</pubDate>
<dc:creator>一只修仙的猿</dc:creator>
<og:description>前言 在上一篇文章深入浅出Java线程池：理论篇中，已经介绍了什么是线程池以及基本的使用。（本来写作的思路是使用篇，但经网友建议后，感觉改为理论篇会更加合适）。本文则深入线程池的源码，主要是介绍Thr</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/huan89/p/14380465.html</dc:identifier>
</item>
<item>
<title>前端模块化之CommonJS - RisingSunBlogs</title>
<link>http://www.cnblogs.com/zhaojian-08/p/14377815.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/zhaojian-08/p/14377815.html</guid>
<description>&lt;h2 id=&quot;一、commonjs特点&quot;&gt;一、CommonJS特点&lt;/h2&gt;
&lt;p&gt;​ 经过前面讨论，已经知道无模块化时项目中存在的问题。CommonJS的特点就是解决这些问题即：&lt;/p&gt;
&lt;p&gt;​ 1.每个文件都是一个单独的模块，有自己的作用域，声明的变量不是全局变量(除非在模块内声明的变量挂载到global上)&lt;/p&gt;
&lt;p&gt;​ 2.每个文件中的成员都是私有的，对外不可见&lt;/p&gt;
&lt;p&gt;​ 3.A模块依赖B模块时，在A模块内部使用require函数引入B模块即可，模块之间依赖关系更加清晰&lt;/p&gt;
&lt;p&gt;​ 4.模块的加载有缓存机制，当加载完一次后，后续再加载就会读取缓存中的内容&lt;/p&gt;
&lt;p&gt;​ 5.模块的加载顺序是按照代码的书写顺序来加载&lt;/p&gt;
&lt;h2 id=&quot;二、commonjs的应用环境&quot;&gt;二、CommonJS的应用环境&lt;/h2&gt;
&lt;p&gt;​ 应用在Node.js中。CommonJS的加载机制是同步的，在Node环境中模块文件是存在本地硬盘中，所以加载起来比较快，不用考虑异步模式。&lt;/p&gt;
&lt;h2 id=&quot;三、commonjs的用法&quot;&gt;三、CommonJS的用法&lt;/h2&gt;
&lt;p&gt;​ 已经知到CommonJS规范下，每个文件就是一个模块，都有私有作用域，那如何才能让外部访问某个模块中的内容呢？&lt;/p&gt;
&lt;p&gt;​ 方式1：把模块中的成员挂载到global全局对象中 【非常不推荐】&lt;/p&gt;
&lt;p&gt;​ 方式2：使用模块的成员module.exports或者exports导出成员&lt;/p&gt;
&lt;p&gt;​ 最后在外部使用require函数引入所需模块&lt;/p&gt;
&lt;h3 id=&quot;方式1：把变量挂载到global模块下【看完忘掉即可】&quot;&gt;方式1：把变量挂载到global模块下【看完忘掉即可】&lt;/h3&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-b.js
var a = 10;
global.a = a;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-a.js
require(&quot;./module-b.js&quot;);
console.log(a); //10
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;方式2：使用moduleexports导出成员&quot;&gt;方式2：使用module.exports导出成员&lt;/h3&gt;
&lt;h4 id=&quot;1、使用moduleexports单个导出&quot;&gt;1、使用module.exports单个导出&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-b.js
const a = 10;
const add = function(a, b) {
    return a + b;
}
module.exports.a = a;
module.exports.add = add;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-a.js
const moduleB = require(&quot;./module-b.js&quot;);

console.log(moduleB.a); //10
console.log(moduleB.add(1, 1)); //2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;2、使用moduleexports直接导出一个对象&quot;&gt;2、使用module.exports直接导出一个对象&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-b.js
const a = 10;
const add = function(a, b) {
    return a + b;
}
module.exports={a,add};
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-a.js
const moduleB = require(&quot;./module-b.js&quot;);

console.log(moduleB.a); //10
console.log(moduleB.add(1, 1)); //2
&lt;/code&gt;
&lt;/pre&gt;
&lt;h4 id=&quot;3、使用exports代替moduleexports来导出成员&quot;&gt;3、使用exports代替module.exports来导出成员&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-b.js
const a = 10;
const add = function(a, b) {
    return a + b;
}
exports.a=a;
exports.add=add;
//使用exports时 不可使用下面这种方式导出成员
exports={a,add}
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-a.js
const moduleB = require(&quot;./module-b.js&quot;);

console.log(moduleB.a); //10
console.log(moduleB.add(1, 1)); //2
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;由代码可见，在使用module.exports和exports导出成员时略有不同，具体是为什么呢？稍后作出解释&lt;/p&gt;
&lt;h2 id=&quot;四、moduleexports、exports和require为什么可以直接使用？&quot;&gt;四、module.exports、exports和require为什么可以直接使用？&lt;/h2&gt;
&lt;p&gt;从我们平时写代码的经验来看，在一个文件中可以使用的成员由以下几种情况：&lt;/p&gt;
&lt;p&gt;1、全局成员&lt;/p&gt;
&lt;p&gt;2、在文件内部声明了该成员&lt;/p&gt;
&lt;p&gt;但我们所了解的代码运行环境中的全局成员只有一个，像window和global这种，那大概率不是全局成员。而且我们在模块内部并未声明这三个变量，那为何能直接使用呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;其实在node运行环境中，每个模块都是运行在一个函数中，正是因为这个函数的存在，才让每个模块有了私有作用域&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;(function (exports, require, module, __filename, __dirname) {
  // HERE IS YOUR CODE
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;通过代码来证明一下这个函数的存在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;既然我们写的代码都在函数内部，那我们应该通过&lt;strong&gt;arguments&lt;/strong&gt;能获取到这个函数的参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-JavaScript&quot;&gt;//module-a.js
console.log('模块中的第一句代码');
console.log(arguments.length)

//运行结果
模块中的第一句代码
5
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;arguments.length的值是5，那八成就是这个样子了。但感觉说服力不强，继续看...&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-a.js
console.log('模块中的第一句代码');
console.log(arguments.callee.toString())

//运行结果
模块中的第一句代码
function (exports, require, module, __filename, __dirname) {
    console.log('模块中的第一句代码');
    console.log(arguments.callee.toString())
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;终于露出了庐山真面目，为什么可以直接用，应该一目了然了！（可以尝试打印一下这个五个参数中都是什么内容）&lt;/p&gt;
&lt;h2 id=&quot;五、moduleexports和exports&quot;&gt;五、module.exports和exports&lt;/h2&gt;
&lt;p&gt;通过打印module成员，可以看到exports是module下的一个对象。module的exports属性表示当前模块对外输出的桥梁，module.exports指向的成员都会被暴露出去&lt;/p&gt;
&lt;p&gt;以上示例中的写法都是把模块内的成员挂载到module.exports中暴露出去的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const a = 10;
const add = function(a, b) {
    return a + b;
}
module.exports.a = a;
module.exports.add = add;
或者使用
module.exports={a,add}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;exports又如何导出的呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-a.js
console.log(module.exports)
console.log(exports)
//输出结果
{}
{}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;两个成员都是对象，那会不会是同一个东西呢？&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;//module-a.js
console.log(module.exports)
console.log(exports)
console.log(module.exports===exports)
//输出结果
{}
{}
true
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;可见两个成员完全相等，则指向的堆内存的地址是同一个，所以使用exports导出模块内的成员也是理所应当的了。&lt;/p&gt;
&lt;p&gt;所以模块最外部函数应该是有这么一句代码的&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;(function (exports, require, module, __filename, __dirname) {
    exports=module.exports={}; //指向同一个内存地址
  // HERE IS YOUR CODE
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;既然exports和module.exports是指向的是同一个内存，按说用法是一样的，为什么上边使用exports导出成员时，特意说明不可以使用exports直接导出一个对象呢？不妨试一下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-b.js
const a = 10;
const add = function(a, b) {
    return a + b;
}

// module.exports = { a, add };
exports = { a, add};
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;const moduleB = require(&quot;./module-b.js&quot;);

console.log(moduleB)//{}
console.log(moduleB.a)//undefined
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;实验得出，通过exports直接导出一个对象时在外部并拿不到导出的数据，为什么呢？&lt;/p&gt;
&lt;p&gt;看一下module.exports和exports在内存中的情况&lt;/p&gt;
&lt;p&gt;当加载该模块时，执行完exports=module.exports={}后的内存情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/741018/202102/741018-20210205223621398-162919077.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当执行完exports={a,add}时的内存情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img2020.cnblogs.com/blog/741018/202102/741018-20210205223636112-513475076.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;当exports={a, add}时，exports在内存中和module.exports指向的就不是同一个内存地址了，说白了抱不了module.exports的大腿了，咱们上面说过，模块导出成员是通过module.exports导出的。exports和module.exports不是同一个内存时，exports自然无法导出成员了。&lt;/p&gt;
&lt;p&gt;既然如此那就把导出的成员老老实实挂载到exports下吧。整洋气一些，module.exports和exports同时使用&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-b.js
const a = 10;
const add = function(a, b) {
    return a + b;
}

module.exports = add;
exports.a = a;
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-a.js
const moduleB = require(&quot;./module-b.js&quot;);

console.log(moduleB)//Function
console.log(moduleB.a)//undefined
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;纳尼？？？把导出的成员挂载到exports下了为何引用的时候还是undefined？？？&lt;/p&gt;
&lt;p&gt;注意：在使用exports.a=a前 使用了module.exports=add了，这时候使用exports为什么导不出成员，大家应该都明白了【原因同上】&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了避免在导出成员时，有这样或那样的问题，建议在模块中全部使用module.exports吧&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;六、require&quot;&gt;六、require()&lt;/h2&gt;
&lt;p&gt;通过上面一系列的代码案例可以看出，require的作用是加载所依赖的文件。说白了就是执行了所加载模块的最外层的函数。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-b.js
const a = 10;
console.log('module-b中打印', a)
module.exports = { a };
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//module-a.js
const moduleB = require(&quot;./module-b.js&quot;);
console.log(moduleB);
&lt;/code&gt;
&lt;/pre&gt;
&lt;pre&gt;
&lt;code&gt;执行module-a.js的结果：

module-b中打印 10
{ a: 10 }
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;module-b.js中的console.log执行了。可见require函数确实令模块最外部的函数执行了。&lt;/p&gt;
&lt;p&gt;由require执行完后有个参数来接受返回值看出，模块最外部的函数执行完后是有返回值的，那么模块最外部的函数应该是这个样子：&lt;/p&gt;
&lt;pre&gt;
&lt;code&gt;(function (exports, require, module, __filename, __dirname) {
  exports = module.exports = {}; //指向同一个内存地址
  // HERE IS YOUR CODE
  return module.exports;//把module.exports返回出去，同时module.exports下挂载的成员也返回出去了
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;1、require加载文件的方式（后缀名默认是js）&quot;&gt;1、require加载文件的方式（后缀名默认是js）&lt;/h3&gt;
&lt;p&gt;​ （1）通过相对路径加载模块，以&quot;./&quot;或&quot;../&quot;开头。比如：require(&quot;./module-b&quot;)是加载同级目录下的module-b.js&lt;/p&gt;
&lt;p&gt;​ （2）通过绝对路径加载模块，以&quot;/&quot;开头，这时候会去磁盘盘符根目录或者网站根目录去找此模块。比如：require(&quot;/module-b&quot;),此时 会去根目录去找module-b.js&lt;/p&gt;
&lt;p&gt;​ （3）直接通过模块名加载,比如：require(&quot;math&quot;)，这是加载提供node内置的核心模块或者node_modules目录中安装的模块。当加 载的是node_modules中的模块时，查找规则如下&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-javascript&quot;&gt;//文件所在目录  E:/Work/Module/CommonJs/module-a.js
const math = require(&quot;math&quot;);
查找规则：【假设每次在对应的目录下都没找到math模块】
1、先去CommonJS目录下的node_modules中去查找math模块
2、再去Module文件夹下的node_modules中去查找math模块
3、再去Work文件夹下node_modules中去查找math模块
4、再去E盘下的node_modules中去查找math模块
最顶级目录还找不到的话则报错...
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2、模块的加载机制&quot;&gt;2、模块的加载机制&lt;/h3&gt;
&lt;p&gt;CommonJS模块的加载机制是，引入的值是输出的值的拷贝，一旦模块内的值导出后，在外部如何改变都不会影响模块内部，同样模块内部对这个值如何改变也不会影响模块外部，犹如“嫁出去的女儿，泼出去的水”&lt;/p&gt;
</description>
<pubDate>Fri, 05 Feb 2021 16:40:00 +0000</pubDate>
<dc:creator>RisingSunBlogs</dc:creator>
<og:description>一、CommonJS特点 ​ 经过前面讨论，已经知道无模块化时项目中存在的问题。CommonJS的特点就是解决这些问题即： ​ 1.每个文件都是一个单独的模块，有自己的作用域，声明的变量不是全局变量(</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/zhaojian-08/p/14377815.html</dc:identifier>
</item>
<item>
<title>产品的定价策略（一）：想通过产品挣钱，首先你产品的目标客户得不差钱 - sheng.chao</title>
<link>http://www.cnblogs.com/sheng_chao/p/14380364.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/sheng_chao/p/14380364.html</guid>
<description>&lt;p&gt;有许多工程技术上很好，很优秀的产品，甚至一定程度上得到了认可，却无法生存的产品，关门大吉。人们常常说是因为技术人不善于营销，这是一方面原因，更重要的我认为是他们的产品本身，就不适合放在市场上赚钱，再怎么营销也很难翻盘。这无关产品本身是否优秀，而是指产品的定位和产品的形态。&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;98.13153961136&quot;&gt;
&lt;p&gt;有许多工程技术上很好，很优秀的产品，甚至一定程度上得到了认可，却无法生存的产品，关门大吉。人们常常说是因为技术人不善于营销，这是一方面原因，更重要的我认为是他们的产品本身，就不适合放在市场上赚钱，再怎么营销也很难翻盘。这无关产品本身是否优秀，而是指产品的定位和产品的形态。&lt;/p&gt;
&lt;h3 id=&quot;什么是产品的客户&quot;&gt;什么是产品的客户&lt;/h3&gt;
&lt;p&gt;许多技术人做产品，只考虑产品对别人“有没有用”，认为只要有用，产品就有价值，用的人就是客户，这是很单纯的。&lt;br/&gt;愿意付钱的才是客户，不愿意付钱的不算客户，是空气，甚至连空气都不如，浪费别人的时间和精力。&lt;/p&gt;
&lt;p&gt;注意：人们是否愿意为产品付钱，往往与这个产品有没有用没有必然关系。所以会有那么多的技术团队创业失败，他们没有认识到这其中的关系。&lt;br/&gt;人们往往只会付“必须要付的钱”，这又怎么理解呢？思考以下几个问题：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;你的产品是必须要用的吗？&lt;/li&gt;
&lt;li&gt;有替代方案吗？Excel 行不行，不要软件手工行不行。&lt;/li&gt;
&lt;li&gt;有更便宜的竞品吗？性能差点没事，能用就行。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这其中任何一点，都与产品本身是否优秀，没有关系。都会导致你的产品卖不掉。&lt;/p&gt;
&lt;h3 id=&quot;价格便宜有用吗&quot;&gt;价格便宜有用吗&lt;/h3&gt;
&lt;p&gt;用处不大。要么你就彻底免费什么的，照死了怼。只要你不是免费的，那么价格便宜用处就不大。&lt;br/&gt;有朋友说你做的产品应该价格便宜是优势。我认为这是一个技术人员典型的误区。&lt;br/&gt;有技术人员会认为我先把用户量做上来，然后我哪怕一年收1000块行不行？&lt;/p&gt;
&lt;p&gt;用户分两种：&lt;/p&gt;
&lt;ul readability=&quot;1&quot;&gt;&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;愿意付钱的&lt;br/&gt;对于这部分客户，定价策略我更倾向于选择合适的 价格区间 中的上限。关键是一定要选择好一个合适的价格区间，&lt;br/&gt;有朋友会认为我找企业要一万块，不行，那我要一千块总行吧。也不行，因为不愿意出一万块的企业，他大概率连一千块也不会出。&lt;br/&gt;所以价格区间的选择，很关键的。假设一千到一万是一个价格区间，那么在这个区间内，只有愿意付钱的和不愿意付钱的两种潜在客户，愿意付钱的这部分客户，他对这个区间内的价格波动并不敏感。区间内更低的价格只会损失自身的利润，不会因为你更便宜就能改善销量。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;不愿意付钱的&lt;br/&gt;对于不愿意付钱的人/企业，我认为直接放弃是最明智的选择，想通过低价转化他们，基本是不可能的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;我这一单不赚钱，长线发展，以后再慢慢赚钱。可以吗？&lt;br/&gt;不可以，企业的调性和人的性格一样，扣就是扣，他这一次不给你赚钱，你也不要幻想以后就大方起来。你会成为他白嫖的一个过客。&lt;/p&gt;
&lt;p&gt;我们现在正在做什么产品呢，我们做了一款在线客服系统，相比竞品，在产品力上有非常大的优势，我会通过这款产品的开发和运营，来详细的记录这其中的体会与发现：&lt;br/&gt;&lt;a href=&quot;https://blog.shengxunwei.com/Home/Post/9b667212-565c-43a8-8379-bd0b832a3720&quot; target=&quot;_blank&quot;&gt;https://blog.shengxunwei.com/Home/Post/9b667212-565c-43a8-8379-bd0b832a3720&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;产品的目标客户得不差钱是什么意思&quot;&gt;产品的目标客户得不差钱是什么意思&lt;/h3&gt;
&lt;p&gt;这一点是本文的核心，我放在这里来解释。&lt;br/&gt;我看到很多做技术的人去设计开发产品，甚至考虑创业，但是只要一看他们的产品选型，我就知道他们死路一条。&lt;/p&gt;
&lt;p&gt;最重要的一点：他们的潜在用户也是屌丝，他哪有钱给你呢？他哪会愿意给你钱呢？你做的一切都是徒劳。这无异于在贫民区开一家高定西装店。很可笑，而现实中有许多技术团队都在做这样的事情。&lt;/p&gt;
&lt;p&gt;做技术的人容易搞反一件事，他们会先看自己能做什么，再去想象谁会用这个产品。正确的做法是先找到不差钱的客户群，我先看好富人区在哪，再去开店，开什么店是次要的。&lt;/p&gt;
&lt;p&gt;无论做什么产品，先看看潜在客户群有没有钱，找到有钱的客户群，给他们服务，才能事半功倍。企业才能良好运转。&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 05 Feb 2021 16:20:00 +0000</pubDate>
<dc:creator>sheng.chao</dc:creator>
<og:description>有许多工程技术上很好，很优秀的产品，甚至一定程度上得到了认可，却无法生存的产品，关门大吉。人们常常说是因为技术人不善于营销，这是一方面原因，更重要的我认为是他们的产品本身，就不适合放在市场上赚钱，再怎</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/sheng_chao/p/14380364.html</dc:identifier>
</item>
<item>
<title>C#脚本引擎RulesEngine - 波多尔斯基</title>
<link>http://www.cnblogs.com/podolski/p/14380360.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/podolski/p/14380360.html</guid>
<description>&lt;p&gt;当编写应用程序时，经常性需要花费大量的时间与精力处理业务逻辑，往往业务逻辑的变化需要重构或者增加大量代码，对开发测试人员很不友好。&lt;/p&gt;
&lt;p&gt;之前在&lt;a href=&quot;https://www.cnblogs.com/podolski/p/14192599.html&quot; target=&quot;_blank&quot;&gt;这篇文章&lt;/a&gt;说过，可以使用脚本引擎来将我们需要经常变化的代码进行动态编译执行，自由度非常大，不过对应的需要资源也多。如果只是针对非常具体业务逻辑的变化，可以尝试使用RulesEngine对程序进行操作。&lt;/p&gt;
&lt;blockquote readability=&quot;4.047619047619&quot;&gt;
&lt;p&gt;下文使用了官方示例且部分内容翻译自&lt;a href=&quot;https://github.com/microsoft/RulesEngine/wiki/Getting-Started#getting-started-with-rules-engine&quot; target=&quot;_blank&quot;&gt;说明文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;简介&quot;&gt;简介&lt;/h2&gt;
&lt;p&gt;RulesEngine是微软推出的规则引擎，规则引擎在很多企业开发中有所应用，是处理经常变动需求的一种优雅的方法。个人任务，规则引擎适用于以下的一些场景：&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;输入输出类型数量比较固定，但是执行逻辑经常变化；&lt;/li&gt;
&lt;li&gt;switch条件经常变化，复杂switch语句的替代；&lt;/li&gt;
&lt;li&gt;会变动的，具有多种条件或者规则的业务逻辑；&lt;/li&gt;
&lt;li&gt;规则自由度不要求特别高的场景。（这种情况建议使用脚本引擎）&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;RulesEngine的规则使用JSON进行存储，通过lambda表达式方式表述规则（Rules）。&lt;/p&gt;
&lt;p&gt;安装很方便，直接使用nuget进行安装：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-powershell&quot;&gt;install-pacakge RulesEngine
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;规则定义&quot;&gt;规则定义&lt;/h2&gt;
&lt;p&gt;需要有Rules，有WorkflowName，然后还有一些属性。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;[
  {
    &quot;WorkflowName&quot;: &quot;Discount&quot;,
    &quot;Rules&quot;: [
      {
        &quot;RuleName&quot;: &quot;GiveDiscount10&quot;,
        &quot;SuccessEvent&quot;: &quot;10&quot;,
        &quot;ErrorMessage&quot;: &quot;One or more adjust rules failed.&quot;,
        &quot;ErrorType&quot;: &quot;Error&quot;,
        &quot;RuleExpressionType&quot;: &quot;LambdaExpression&quot;,
        &quot;Expression&quot;: &quot;input1.country == \&quot;india\&quot; AND input1.loyalityFactor &amp;lt;= 2 AND input1.totalPurchasesToDate &amp;gt;= 5000 AND input2.totalOrders &amp;gt; 2 AND input3.noOfVisitsPerMonth &amp;gt; 2&quot;
      }
    ]
  }
]
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;除了标准的&lt;code&gt;RuleExpressionType&lt;/code&gt;，还可以通过定义Rules嵌套多个条件，下面是Or逻辑。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
&quot;RuleName&quot;: &quot;GiveDiscount30NestedOrExample&quot;,
&quot;SuccessEvent&quot;: &quot;30&quot;,
&quot;ErrorMessage&quot;: &quot;One or more adjust rules failed.&quot;,
&quot;ErrorType&quot;: &quot;Error&quot;,
&quot;Operator&quot;: &quot;OrElse&quot;,
&quot;Rules&quot;:[
    {
    &quot;RuleName&quot;: &quot;IsLoyalAndHasGoodSpend&quot;,
    &quot;ErrorMessage&quot;: &quot;One or more adjust rules failed.&quot;,
    &quot;ErrorType&quot;: &quot;Error&quot;,
    &quot;RuleExpressionType&quot;: &quot;LambdaExpression&quot;,
    &quot;Expression&quot;: &quot;input1.loyalityFactor &amp;gt; 3 AND input1.totalPurchasesToDate &amp;gt;= 50000 AND input1.totalPurchasesToDate &amp;lt;= 100000&quot;
    },
    {
    &quot;RuleName&quot;: &quot;OrHasHighNumberOfTotalOrders&quot;,
    &quot;ErrorMessage&quot;: &quot;One or more adjust rules failed.&quot;,
    &quot;ErrorType&quot;: &quot;Error&quot;,
    &quot;RuleExpressionType&quot;: &quot;LambdaExpression&quot;,
    &quot;Expression&quot;: &quot;input2.totalOrders &amp;gt; 15&quot;
    }
]
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;示例&quot;&gt;示例&lt;/h2&gt;
&lt;p&gt;可以从官方的代码库中下载示例，定义了上述规则，就可以直接开始用了。示例描述了这么一个应用场景：&lt;/p&gt;
&lt;p&gt;根据不同的客户属性，提供不同的折扣。由于销售的情况变化较快，提供折扣的&lt;strong&gt;规则&lt;/strong&gt;也需要经常变动。因此比较适用于规则引擎。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public void Run()
{
    Console.WriteLine($&quot;Running {nameof(BasicDemo)}....&quot;);
    //创建输入
    var basicInfo = &quot;{\&quot;name\&quot;: \&quot;hello\&quot;,\&quot;email\&quot;: \&quot;abcy@xyz.com\&quot;,\&quot;creditHistory\&quot;: \&quot;good\&quot;,\&quot;country\&quot;: \&quot;canada\&quot;,\&quot;loyalityFactor\&quot;: 3,\&quot;totalPurchasesToDate\&quot;: 10000}&quot;;
    var orderInfo = &quot;{\&quot;totalOrders\&quot;: 5,\&quot;recurringItems\&quot;: 2}&quot;;
    var telemetryInfo = &quot;{\&quot;noOfVisitsPerMonth\&quot;: 10,\&quot;percentageOfBuyingToVisit\&quot;: 15}&quot;;

    var converter = new ExpandoObjectConverter();

    dynamic input1 = JsonConvert.DeserializeObject&amp;lt;ExpandoObject&amp;gt;(basicInfo, converter);
    dynamic input2 = JsonConvert.DeserializeObject&amp;lt;ExpandoObject&amp;gt;(orderInfo, converter);
    dynamic input3 = JsonConvert.DeserializeObject&amp;lt;ExpandoObject&amp;gt;(telemetryInfo, converter);

    var inputs = new dynamic[]
        {
            input1,
            input2,
            input3
        };
    //加载规则
    var files = Directory.GetFiles(Directory.GetCurrentDirectory(), &quot;Discount.json&quot;, SearchOption.AllDirectories);
    if (files == null || files.Length == 0)
        throw new Exception(&quot;Rules not found.&quot;);

    var fileData = File.ReadAllText(files[0]);
    var workflowRules = JsonConvert.DeserializeObject&amp;lt;List&amp;lt;WorkflowRules&amp;gt;&amp;gt;(fileData);
    //初始化规则引擎
    var bre = new RulesEngine.RulesEngine(workflowRules.ToArray(), null);

    string discountOffered = &quot;No discount offered.&quot;;
    //执行规则
    List&amp;lt;RuleResultTree&amp;gt; resultList = bre.ExecuteAllRulesAsync(&quot;Discount&quot;, inputs).Result;
    //处理结果
    resultList.OnSuccess((eventName) =&amp;gt; {
        discountOffered = $&quot;Discount offered is {eventName} % over MRP.&quot;;
    });

    resultList.OnFail(() =&amp;gt; {
        discountOffered = &quot;The user is not eligible for any discount.&quot;;
    });

    Console.WriteLine(discountOffered);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;输入&quot;&gt;输入&lt;/h2&gt;
&lt;p&gt;输入一般来说是&lt;code&gt;IEnumerable&amp;lt;dynamic&amp;gt;&lt;/code&gt;或者是匿名类型，上面实例展示的是由json反序列化形成的dynamic类型，对于程序生成的数据，使用匿名类型更加方便。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;var nestedInput = new {
                SimpleProp = &quot;simpleProp&quot;,
                NestedProp = new {
                    SimpleProp = &quot;nestedSimpleProp&quot;,
                    ListProp = new List&amp;lt;ListItem&amp;gt;
                    {
                        new ListItem
                        {
                            Id = 1,
                            Value = &quot;first&quot;
                        },
                        new ListItem
                        {
                            Id = 2,
                            Value = &quot;second&quot;
                        }
                    }
                }

            };
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;命名空间&quot;&gt;命名空间&lt;/h2&gt;
&lt;p&gt;和脚本引擎一样，默认规则引擎只能访问System的命名空间。如果需要使用到稍微复杂一些的类型，可以自己定义类型或者函数。比如定义一个这样的函数：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;public static class Utils
{
    public static bool CheckContains(string check, string valList)
    {
        if (String.IsNullOrEmpty(check) || String.IsNullOrEmpty(valList))
            return false;

        var list = valList.Split(',').ToList();
        return list.Contains(check);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;需要使用的时候，先将类传递给RulesEngine：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;var reSettingsWithCustomTypes = new ReSettings { CustomTypes = new Type[] { typeof(Utils) } };
var engine = new RulesEngine.RulesEngine(workflowRules.ToArray(), null, reSettingsWithCustomTypes);
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;然后就可以直接在表达式中使用了。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;&quot;Expression&quot;: &quot;Utils.CheckContains(input1.country, \&quot;india,usa,canada,France\&quot;) == true&quot;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;规则参数&quot;&gt;规则参数&lt;/h2&gt;
&lt;p&gt;默认情况下，规则的输入使用的是类似&lt;em&gt;input1 input2&lt;/em&gt;这样的形式，如果想直观一点，可以使用&lt;code&gt;RuleParameter&lt;/code&gt;来进行封装具体的参数类型。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-c#&quot;&gt;RuleParameter ruleParameter = new RuleParameter(&quot;NIP&quot;, nestedInput);
var resultList = bre.ExecuteAllRulesAsync(workflow.WorkflowName, ruleParameter).Result;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;本地变量&quot;&gt;本地变量&lt;/h2&gt;
&lt;p&gt;如果表达式比较复杂的情况下，可以使用本地变量来进行分段处理，这对调试来说会比较方便。&lt;/p&gt;
&lt;p&gt;本地变量的关键字为localParams，可以将中间的内容简单理解成&lt;strong&gt;var name = expression&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
        &quot;name&quot;: &quot;allow_access_if_all_mandatory_trainings_are_done_or_access_isSecure&quot;,
        &quot;errorMessage&quot;: &quot;Please complete all your training(s) to get access to this content or access it from a secure domain/location.&quot;,
        &quot;errorType&quot;: &quot;Error&quot;,
        &quot;localParams&quot;: [
          {
            &quot;name&quot;: &quot;completedSecurityTrainings&quot;,
            &quot;expression&quot;: &quot;MasterSecurityComplainceTrainings.Where(Status.Equals(\&quot;Completed\&quot;, StringComparison.InvariantCultureIgnoreCase))&quot;
          },
          {
            &quot;name&quot;: &quot;completedProjectTrainings&quot;,
            &quot;expression&quot;: &quot;MasterProjectComplainceTrainings.Where(Status.Equals(\&quot;Completed\&quot;, StringComparison.InvariantCultureIgnoreCase))&quot;
          },
          {
            &quot;name&quot;: &quot;isRequestAccessSecured&quot;,
            &quot;expression&quot;: &quot;UserRequestDetails.Location.Country == \&quot;India\&quot; ? ((UserRequestDetails.Location.City == \&quot;Bangalore\&quot; &amp;amp;&amp;amp; UserRequestDetails.Domain=\&quot;xxxx\&quot;)? true : false):false&quot;
          }
        ],
        &quot;expression&quot;: &quot;(completedSecurityTrainings.Any() &amp;amp;&amp;amp; completedProjectTrainings.Any()) || isRequestAccessSecured &quot;
      }
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;使用规则引擎，可以将经常变动的业务逻辑独立摘出来，为我们编写动态、可拓展的程序提供了很大的便利。RulesEngine这个东西提供的API也比较简洁，上手非常简单。&lt;/p&gt;
</description>
<pubDate>Fri, 05 Feb 2021 16:17:00 +0000</pubDate>
<dc:creator>波多尔斯基</dc:creator>
<og:description>当编写应用程序时，经常性需要花费大量的时间与精力处理业务逻辑，往往业务逻辑的变化需要重构或者增加大量代码，对开发测试人员很不友好。 之前在这篇文章说过，可以使用脚本引擎来将我们需要经常变化的代码进行动</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/podolski/p/14380360.html</dc:identifier>
</item>
<item>
<title>[译]Rxjs&amp;Angular-退订可观察对象的n种方式 - Laggage</title>
<link>http://www.cnblogs.com/laggage/p/14380301.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/laggage/p/14380301.html</guid>
<description>&lt;p&gt;翻译-RxJS &amp;amp; Angular — Unsubscribe Like a Pro, 原文: https://medium.com/swlh/rxjs-angular-unsubscribe-like-a-pro-ffeedec60aa7&lt;/p&gt;&lt;div id=&quot;cnblogs_post_body&quot; readability=&quot;233.01083448594&quot;&gt;
&lt;blockquote readability=&quot;1.3392857142857&quot;&gt;
&lt;p&gt;原文/出处: &lt;a href=&quot;https://medium.com/swlh/rxjs-angular-unsubscribe-like-a-pro-ffeedec60aa7&quot; target=&quot;_blank&quot;&gt;RxJS &amp;amp; Angular — Unsubscribe Like a Pro&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在angular项目中我们不可避免的要使用&lt;code&gt;RxJS&lt;/code&gt;可观察对象(&lt;code&gt;Observables&lt;/code&gt;)来进行订阅(&lt;code&gt;Subscribe&lt;/code&gt;)和退订(&lt;code&gt;Unsubscribe&lt;/code&gt;)操作;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;概述&lt;/h2&gt;
&lt;p&gt;我们的每个angular项目中都会用到&lt;code&gt;RxJS&lt;/code&gt;, &lt;code&gt;RxJS&lt;/code&gt;在我们的angular app中对数据流和性能有非常大的影响。&lt;/p&gt;
&lt;p&gt;为了避免内存泄漏，在适当的时机对可观察对象进行退订是非常重要的; 本文会向你展示各种在angular组件中退订可观察对象的方法！&lt;/p&gt;
&lt;p&gt;首先，我们创建一个帮助类来帮我们创建的订阅对象(&lt;code&gt;Subscription&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-ts&quot;&gt;
@Injectable({
  providedIn: 'root',
})
export class DummyService {
  getEmissions(scope: string): Observable&amp;lt;string&amp;gt; {
    return Observable.create((observer) =&amp;gt; {
      console.log(`${scope} Subscribed`);

      const subscription: Subscription = timer(0, 1000)
        .pipe(
          map((n) =&amp;gt; `${scope} Emission #${n}`),
          tap(console.log)
        )
        .subscribe(observer);

      return () =&amp;gt; {
        subscription.unsubscribe();
        console.log(`${scope} Unsubscribed`);
      };
    });
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我们的帮助类有一个&lt;code&gt;getEmissions&lt;/code&gt;方法, 它接受一个&lt;code&gt;scope&lt;/code&gt;参数来记录日志, 它的返回值是一个会每秒发出 &lt;code&gt;${scope} Emission #n&lt;/code&gt;字符串的可观察对象.&lt;/p&gt;
&lt;h2 id=&quot;方式一-常规的取消订阅的方式&quot;&gt;方式一 &quot;常规&quot;的取消订阅的方式&lt;/h2&gt;
&lt;p&gt;最简单的订阅和取消订阅一个可观察对象的方式是在 &lt;code&gt;ngOnInit&lt;/code&gt; 方法中订阅可观察对象(&lt;code&gt;Observable&lt;/code&gt;), 然后在组件类中创建一个类属性用来保存这个订阅(&lt;code&gt;Subscription&lt;/code&gt;), 并在 &lt;code&gt;ngOnDestroy&lt;/code&gt; 中取消对可观察对象对订阅. 简单起见, 我们可以使用&lt;code&gt;Subscription.EMPTY&lt;/code&gt;来初始化一个订阅对象(&lt;code&gt;Subscription&lt;/code&gt;), 这样可以防止在取消订阅时遇到空引用对问题.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-ts&quot;&gt;@Component({
  selector: 'app-regular',
  template: `&amp;lt;div&amp;gt;{{ emission }}&amp;lt;/div&amp;gt;`,
})
export class RegularComponent implements OnInit, OnDestroy {
  emission: string;

  /* 
    Note: we initialize to Subscription.EMPTY to avoid null checking within ngOnDestroy
   */
  private subscription: Subscription = Subscription.EMPTY;

  constructor(private dummyService: DummyService) {}

  ngOnInit(): void {
    this.subscription = this.dummyService
      .getEmissions('Regular')
      .subscribe((emission) =&amp;gt; (this.emission = emission));
  }

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;为了验证代码有效我们在三秒后从&lt;code&gt;DOM&lt;/code&gt;中移除这个组件&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1400/1*fFuAAdjKoMF7H5JkUpwDfQ.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;如上所述, 这是最基本对取消订阅的方式, 如果我们的组件类中只有一个订阅对象(&lt;code&gt;Subscription&lt;/code&gt;), 这种方式没什么问题. 但是当我们有多个订阅对象(&lt;code&gt;Subscription&lt;/code&gt;)时, 针对每一个我们都需要在组件类中创建一个字段保存这个对象的的引用并在 &lt;code&gt;ngOnDestroy&lt;/code&gt; 中调用 &lt;code&gt;unsubscribe&lt;/code&gt;来取消订阅.&lt;/p&gt;
&lt;h2 id=&quot;方式二-使用-subscriptionadd-方法&quot;&gt;方式二 使用 Subscription.add 方法&lt;/h2&gt;
&lt;p&gt;RxJS的订阅类(&lt;code&gt;Subscription&lt;/code&gt;)内建了 &lt;a href=&quot;https://rxjs.dev/api/index/class/Subscription#add-&quot; target=&quot;_blank&quot;&gt;Subscription.add&lt;/a&gt; 方法允许我们使用单个订阅对象的实例(&lt;code&gt;Subscription instance&lt;/code&gt;)来简化我们操作多个订阅对象的.&lt;/p&gt;
&lt;p&gt;首先, 在组件类中使用&lt;code&gt;new Subscription()&lt;/code&gt;实例化创建一个字段, 然后调用该实例的 &lt;code&gt;Subscription.add&lt;/code&gt; 方法, 最后在 &lt;code&gt;ngOnDestroy&lt;/code&gt; 中取消订阅.&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-ts&quot;&gt;@Component({
  selector: 'app-add',
  template: `
    &amp;lt;div&amp;gt;{{ emissionA }}&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;{{ emissionB }}&amp;lt;/div&amp;gt;
  `,
})
export class AddComponent implements OnInit, OnDestroy {
  emissionA: string;
  emissionB: string;

  private subscription: Subscription = new Subscription();

  constructor(private dummyService: DummyService) {}

  ngOnInit(): void {
    this.subscription.add(
      this.dummyService
        .getEmissions('[Add A]')
        .subscribe((emission) =&amp;gt; (this.emissionA = emission))
    );

    this.subscription.add(
      this.dummyService
        .getEmissions('[Add B]')
        .subscribe((emission) =&amp;gt; (this.emissionB = emission))
    );
  }

  ngOnDestroy(): void {
    this.subscription.unsubscribe();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;打开浏览器控制台, 我们可以看到两个订阅对象:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1400/1*wUflYxiwIq-Irih_oRLX1A.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;使用这种方式, 我们可以使用RsJS内建的方法轻松的取消订阅多个可观察对象而不必在组件类创建多个字段保存订阅对象的引用.&lt;/p&gt;
&lt;h2 id=&quot;方式三-asyncpipe&quot;&gt;方式三 AsyncPipe&lt;/h2&gt;
&lt;p&gt;Angular内置了许多非常有用的管道(pipe), 其中一个就是&lt;a href=&quot;https://angular.io/api/common/AsyncPipe&quot; target=&quot;_blank&quot;&gt;AsyncPipe&lt;/a&gt;. &lt;code&gt;AsyncPipe&lt;/code&gt;接受一个可观察对象并在组件生命周期结束时(&lt;code&gt;ngOnDestroy&lt;/code&gt;)自动取消订阅.&lt;/p&gt;
&lt;p&gt;与前两个示例不同, 这里我们&lt;strong&gt;不需要在组件中手动取消订阅&lt;/strong&gt;, 而是将可观察对象(&lt;code&gt;Observable&lt;/code&gt;)传递个 &lt;code&gt;AsyncPipe&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-ts&quot;&gt;@Component({
  selector: 'app-async',
  template: `&amp;lt;div&amp;gt;{{ emissions$ | async }}&amp;lt;/div&amp;gt;`
})
export class AsyncComponent implements OnInit {
  emissions$: Observable&amp;lt;string&amp;gt;;

  constructor(private dummyService: DummyService) {}

  ngOnInit(): void {
    this.emissions$ = this.dummyService.getEmissions('[Async]');
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1400/1*1H9y-W7yN55skoeG2iIELw.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在我看来, 这是在Angular中使用可观察对象(&lt;code&gt;Observables&lt;/code&gt;)最简明的方式. 你只需创建可观察对象(&lt;code&gt;Observables&lt;/code&gt;)然后Angular会帮助你进行订阅和取消订阅.&lt;/p&gt;
&lt;h2 id=&quot;方式4-takeuntil-操作符&quot;&gt;方式4 takeUntil 操作符&lt;/h2&gt;
&lt;p&gt;RxJS包含许多有用的操作符, &lt;a href=&quot;https://www.learnrxjs.io/learn-rxjs/operators/filtering/takeuntil&quot; target=&quot;_blank&quot;&gt;takeUntil&lt;/a&gt;就是其中之一. 像这个操作符的签名一样, takeUntil 接受一个会发出取消订阅源可观察对象通知的可观察对象(&lt;code&gt;notifier&lt;/code&gt;).&lt;br/&gt;在我们的示例中, 我们希望在组件被销毁后发出通知, 所以我们给组件类添加一个叫 &lt;code&gt;componentDestroyed$&lt;/code&gt; 的字段, 它的类型是 &lt;code&gt;Subject&amp;lt;void&amp;gt;&lt;/code&gt;, 这个字段承担了&lt;code&gt;通知人(notifier)&lt;/code&gt;的角色.&lt;br/&gt;然后我们只需在&lt;code&gt;ngOnDestroy&lt;/code&gt;发出&quot;通知&quot;即可, 最终的代码像下面这样:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-ts&quot;&gt;@Component({
  selector: 'app-until',
  template: `&amp;lt;div&amp;gt;{{ emission }}&amp;lt;/div&amp;gt;`,
})
export class UntilComponent implements OnInit, OnDestroy {
  emission: string;

  private componentDestroyed$: Subject&amp;lt;void&amp;gt; = new Subject&amp;lt;void&amp;gt;();

  constructor(private dummyService: DummyService) {}

  ngOnInit(): void {
    this.dummyService
      .getEmissions('takeUntil')
      .pipe(takeUntil(this.componentDestroyed$))
      .subscribe((emission) =&amp;gt; (this.emission = emission));
  }

  ngOnDestroy(): void {
    this.componentDestroyed$.next();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1400/1*-mmehK6LSr1QHwZmH-moJw.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;与之前&lt;code&gt;常规&lt;/code&gt;的方式相比, 这种方式在我们有多个订阅对象时不必在组件类中创建多个字段保存对订阅对象的引用. 我们只需在管道中加入 &lt;code&gt;takeUntil(componentDestroyed$)&lt;/code&gt; 即可, 剩下的RxJS会帮我们完成.&lt;/p&gt;
&lt;h2 id=&quot;方式五-subsink-库&quot;&gt;方式五 SubSink 库&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/wardbell/subsink&quot; target=&quot;_blank&quot;&gt;SubSink&lt;/a&gt;是&lt;a href=&quot;https://github.com/wardbell&quot; target=&quot;_blank&quot;&gt;Ward Bell&lt;/a&gt;写的一个很棒的库, 它使你可以优雅的在你的组件中取消对可观察对象的订阅.&lt;/p&gt;
&lt;p&gt;首先, 通过&lt;code&gt;npm i subsink&lt;/code&gt;或&lt;code&gt;yarn add subsink&lt;/code&gt;安装SubSink. 然后在组件类中创建一个&lt;code&gt;SubSink&lt;/code&gt;类型的字段.&lt;br/&gt;SubSink有两种方式, 一种是简单技术(使用&lt;code&gt;sink&lt;/code&gt;属性设置器), 另一种是 数组/添加(Array/Add)技术.&lt;/p&gt;
&lt;p&gt;使用简单技术只需要使用&lt;code&gt;sink&lt;/code&gt;设置器属性即可. 使用_数组/添加(Array/Add)技术_的话代码类似RxJS原生的&lt;code&gt;Subscription.add&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;为每一种方式创建一个订阅对象, 我们的组件类看起来像下面这样&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-ts&quot;&gt;@Component({
  selector: 'app-sink',
  template: `
    &amp;lt;div&amp;gt;{{ easyEmission }}&amp;lt;/div&amp;gt;
    &amp;lt;div&amp;gt;{{ arrayAddEmission }}&amp;lt;/div&amp;gt;
  `,
})
export class SinkComponent implements OnInit, OnDestroy {
  easyEmission: string;
  arrayAddEmission: string;

  private subs = new SubSink();

  constructor(private dummyService: DummyService) {}

  ngOnInit(): void {
    /* 使用简单技术 */
    this.subs.sink = this.dummyService
      .getEmissions('[Easy Technique]')
      .subscribe((emission) =&amp;gt; (this.easyEmission = emission));

    /* 使用数组/添加(Array/Add)技术 */
    this.subs.add(
      this.dummyService
        .getEmissions('[Array/Add Technique]')
        .subscribe((emission) =&amp;gt; (this.easyEmission = emission))
    );
  }

  ngOnDestroy(): void {
    this.subs.unsubscribe();
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1400/1*guFofx9EQxMOh1EhEIajtA.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;方式六-until-destroy-库&quot;&gt;方式六 until-destroy 库&lt;/h2&gt;
&lt;blockquote readability=&quot;5.5443037974684&quot;&gt;
&lt;p&gt;注意: 这个库在Pre Ivy Angular上行为不同, 更多信息请访问&lt;a href=&quot;https://github.com/ngneat/until-destroy#use-with-view-engine-pre-ivy&quot; target=&quot;_blank&quot;&gt;文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ngneat/until-destroy&quot; target=&quot;_blank&quot;&gt;until-destroy&lt;/a&gt;是&lt;a href=&quot;https://github.com/ngneat&quot; target=&quot;_blank&quot;&gt;ngneat&lt;/a&gt;许多很棒的库之一, 它使用&lt;code&gt;UntilDestroy&lt;/code&gt;装饰器来确认哪些字段的是订阅对象(&lt;code&gt;Subscriptions&lt;/code&gt;)并在组件销毁时取消订阅它们;&lt;br/&gt;我们还可以不通过组件类字段, 而是使用_until-destroy_定义的叫&lt;code&gt;untilDestroyed&lt;/code&gt;的RxJS操作符来取消订阅.&lt;/p&gt;
&lt;p&gt;要使用它我们需要给组件类加上 &lt;code&gt;UntilDestroy&lt;/code&gt; 装饰器, 然后在可观察对象管道中加入 &lt;code&gt;untilDestroyed&lt;/code&gt; 操作符:&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-ts&quot;&gt;@UntilDestroy()
@Component({
  selector: 'app-destroyed',
  template: `&amp;lt;div&amp;gt;{{ emission }}&amp;lt;/div&amp;gt; `,
})
export class DestroyedComponent implements OnInit {
  emission: string;

  constructor(private dummyService: DummyService) {}

  ngOnInit(): void {
    this.dummyService
      .getEmissions('[UntilDestroy]')
      .pipe(untilDestroyed(this))
      .subscribe((emission) =&amp;gt; (this.emission = emission));
  }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://miro.medium.com/max/1400/1*1hZgWMWAFsxLONsVIN8H7w.png&quot; alt=&quot;image&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;总的来说, until-destroy是个非常强大的库, 他可以帮你自动取消对可观察对象的订阅.&lt;br/&gt;此外, until-destroy还有许多其他在本文中没有进行说明的特性, 所以赶快去看看它们的&lt;a href=&quot;https://github.com/ngneat/until-destroy&quot; target=&quot;_blank&quot;&gt;github仓库&lt;/a&gt;吧!&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;上面我们已经看到来许多订阅和退订可观察对象方式, 每个都各有各的优劣并且有着不同的编码风格.&lt;/p&gt;
&lt;p&gt;但是最重要是不管我们选择那种方式, 我们都要&lt;strong&gt;保持编码风格的一致&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;</description>
<pubDate>Fri, 05 Feb 2021 15:53:00 +0000</pubDate>
<dc:creator>Laggage</dc:creator>
<og:description>翻译-RxJS &amp; Angular — Unsubscribe Like a Pro, 原文: https://medium.com/swlh/rxjs-angular-unsubscribe-lik</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/laggage/p/14380301.html</dc:identifier>
</item>
<item>
<title>从单页应用(SPA)到服务器渲染(SSR) - 是浩然呀</title>
<link>http://www.cnblogs.com/haoranya/p/14380281.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/haoranya/p/14380281.html</guid>
<description>&lt;hr/&gt;&lt;h2 id=&quot;情景回顾&quot;&gt;情景回顾&lt;/h2&gt;
&lt;p&gt;在学习Vue开发一个电商网站的管理后台时,使用到了一个组件 &lt;strong&gt;vue-quill-editor&lt;/strong&gt; 主要是一个快捷的一个富文本编辑器&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://www.hualigs.cn/image/601cd239e1a5d.jpg&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在使用这个组件的组件的时候看到了两种的使用方式分别是&lt;strong&gt;SPA&lt;/strong&gt;和&lt;strong&gt;SSR&lt;/strong&gt;,技术不够的我,只能面向百度编程🌍,那我们来看看是🐂是🐎吧！&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;本文分别从两者的概念，主要的不同，优劣势列举等等去分析SPA和SSR。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;spasingle-page-web-application单页面应用程序&quot;&gt;SPA(Single Page Web Application)[单页面应用程序]&lt;/h2&gt;
&lt;h3 id=&quot;概述&quot;&gt;概述&lt;/h3&gt;
&lt;blockquote readability=&quot;11&quot;&gt;
&lt;p&gt;单页Web应用就是只有一张Web页面的应用，是加载单个HTML 页面并在用户与应用程序交互时动态更新该页面的Web应用程序。也就是网页上通过hash(#)的变化来实现推动界面变化,通过不同的组件切换,展示所对应的功能模块,也避免了页面的重新加载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用spa的主流框架mvvmmodel-view-viewmodel&quot;&gt;使用SPA的主流框架(MVVM:Model-View-ViewModel)&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;AngularJS&lt;/li&gt;
&lt;li&gt;VueJS&lt;/li&gt;
&lt;li&gt;backone&lt;/li&gt;
&lt;li&gt;extjs&lt;/li&gt;
&lt;/ol&gt;&lt;h4 id=&quot;小知识点&quot;&gt;小知识点&lt;/h4&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;a href=&quot;target&quot;&amp;gt;go target&amp;lt;/a&amp;gt;
&amp;lt;div id=&quot;target&quot;&amp;gt;i am target place&amp;lt;/div&amp;gt;
&amp;lt;!-- 
    点击a链接,文档会自动滚动到id为target的div区域中,运用在电商网站的楼层跳跃等实际当中
    hash除了整个功能还有另一种含义:
    指导浏览器行为但是不上传服务器

    因为改变URL中的任何一个字符都会使浏览器重新去请求服务器,导致很多已经加载过的资源都会重新请求

    简而言之:
    [改变#后面的值不触发网页重载，但会记录到浏览器history中去。]
 --&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;spa优点&quot;&gt;SPA优点&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;很好的用户操作，用户不需要刷新页面，整个交互都通过AJAX向服务器发起请求,后通过服务器返回的内容进行下一步的操作&lt;/li&gt;
&lt;li&gt;适合用于前后端分类开发,服务端提供API地址,前端使用对应服务的API地址和对应的请求方式,拿到数据对客户端进行渲染&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;spa缺点&quot;&gt;SPA缺点&lt;/h3&gt;
&lt;ol readability=&quot;-2&quot;&gt;&lt;li&gt;
&lt;p&gt;初次加载耗时多&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;在加载页面显示的时候加载打包文件，如果打包文件较大或者网速慢则用户体验不好，首屏时需要请求一次html，同时还要发送一次js请求，两次请求回来了，首屏才会展示出来。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li readability=&quot;-1&quot;&gt;
&lt;p&gt;SEO(搜索引擎优化)不友好&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;因为搜索引擎只认识html里的内容，不认识js的内容，而单页应用的内容都是靠js渲染生成出来的，搜索引擎不识别这部分内容，也就不会给一个好的排名，会导致单页应用做出来的网页在百度和谷歌上的排名差。使用单页面应用将大大减少搜索引擎对网站的收录。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;实现一个简单的基础的spa&quot;&gt;实现一个简单的基础的SPA&lt;/h3&gt;
&lt;p&gt;主要通过 &lt;code&gt;onhashchange&lt;/code&gt; 事件,所以我们主要监听这个事件的触发即可实现&lt;/p&gt;
&lt;p&gt;下面是一个利用$.ajax实现的单页面切换的例子：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-js&quot;&gt;
window.onhashchange = function(){ //监听hash值变化，实现页面变换
　　var hash=window.location.hash;
　　changePage(hash); 
}

function changePage(hash){
　　switch (hash) // 通过不同的hash地址路由到对应的页面
　　{
　　case '#index':
　　　　url='partials/list.html';
　　　　break;
　　case '#newpage':
　　　　url='partials/newpage.html';
　　　　break;
　　case '#edit':
　　　　url='partials/edit.html';
　　　　break;
　　case '#view':
　　　　url='partials/view.html';
　　　　break;
　　}

　　$.ajax({            //根据hash值选择页面
　　　　type:'GET',
　　　　url:url,
　　　　success:function(data){
　　　　　　main.innerHTML=data; // 服务器拿到响应数据再渲染
　　　　　}
　　});
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;ssr&quot;&gt;SSR&lt;/h2&gt;
&lt;p&gt;那在上面我们已经初步的了解了SPA的一些特别之处还有弊端&lt;br/&gt;那我们再来看看SSR又能够带给我们怎么样的特点呢&lt;/p&gt;
&lt;p&gt;SSR: &lt;code&gt;Server-Side Render&lt;/code&gt; 服务端渲染&lt;/p&gt;
&lt;p&gt;简单的说就是: 服务端直接渲染出&lt;code&gt;HTML&lt;/code&gt;字符串模板,浏览器可以直接通过解析该字符串模板显示页面,因此首屏的内容不在依赖JavaScript的渲染！！！&lt;/p&gt;
&lt;p&gt;就好像我不需要再通过JS动态切换,而是服务端已经渲染好,我直接拿来就是可以使用&lt;/p&gt;
&lt;h3 id=&quot;ssr优势&quot;&gt;SSR优势&lt;/h3&gt;
&lt;ol&gt;&lt;li&gt;首屏加载时间：因为是 HTML 直出，浏览器可以直接解析该字符串模版显示页面。&lt;/li&gt;
&lt;li&gt;SEO 友好：正是因为服务端渲染输出到浏览器的是完备的 html 字符串，使得搜索引擎 能抓取到真实的内容，利于 SEO。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;ssr缺点&quot;&gt;SSR缺点&lt;/h3&gt;
&lt;ol readability=&quot;2.5&quot;&gt;&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;虽然 SSR 能快速呈现页面，但是在 UI 框架（比如 React）加载成功之前，页面是没法进行 UI 交互的。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;0&quot;&gt;
&lt;p&gt;TTFB (Time To First Byte)，即第一字节时间会变长，因为 SSR 相对于 CSR 需要在服务端渲染出更多的 HTML 片段，因此加载时间会变长。&lt;/p&gt;
&lt;/li&gt;
&lt;li readability=&quot;2&quot;&gt;
&lt;p&gt;更多的服务器端负载。由于 SSR 需要依赖 Node.js 服务渲染页面，显然会比仅仅提供静态文件的 CSR 应用需要占用更多服务器 CPU 资源。以 React 为例，它的 renderToString() 方法是同步 CPU 绑定调用，这就意味着在它完成之前，服务器是无法处理其他请求的。因此在高并发场景，需要准备相应的服务器负载，并且做好缓存策略。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;&lt;img src=&quot;http://www.zyiz.net/upload/202003/17/202003171101347288.png&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;hr/&gt;&lt;p&gt;SPA:&lt;br/&gt;优点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;页面之间的切换快&lt;/li&gt;
&lt;li&gt;一定程度上减少了后端服务器的压力&lt;/li&gt;
&lt;li&gt;后端程序只需要提供API，不用管client是手机端还是PC端&lt;br/&gt;缺点:&lt;/li&gt;
&lt;li&gt;首屏打开很慢，用户首次打开要下载SPA框架及应用程序的代码，然后再渲染页面&lt;/li&gt;
&lt;li&gt;不利于SEO搜索引擎优化&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;SSR:&lt;br/&gt;优点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;更快的响应时间，不用等待所有的js都下载完成，浏览器变成现实比较完整的页面&lt;/li&gt;
&lt;li&gt;更好的SEO，我们可以将SEO的关键数据直接在后台就渲染成html，从而保证搜索引擎的爬虫能爬取到关键数据&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;缺点:&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;占用更多的cpu和内存资源&lt;/li&gt;
&lt;li&gt;一些常用的浏览器API无法使用，比如window，document，alert等，如果使用的话需要对运行环境加以判断&lt;/li&gt;
&lt;li&gt;开发调试会比较麻烦，对SPA的一些组件的生命周期的管理会变得复杂，只会执行ComponentMount之前的生命周期，第三库使用受限，学习成本大。&lt;/li&gt;
&lt;/ol&gt;&lt;h3 id=&quot;为什么ssr比spa要快&quot;&gt;为什么SSR比SPA要快&lt;/h3&gt;
&lt;h4 id=&quot;服务端渲染路线&quot;&gt;服务端渲染路线&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712222152121.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzg0Mzc5,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h4 id=&quot;客户端渲染路线&quot;&gt;客户端渲染路线&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20190712222237582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5Mzg0Mzc5,size_16,color_FFFFFF,t_70&quot; alt=&quot;&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;服务器端渲染会先向后端请求数据，生成完整首屏HTML后返回给客户端&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;客户端渲染会等待JS下载，解析完之后再向服务器请求数据，等待过程中是什么也没有的，所以会出现首屏白页的情况&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;参考文档&quot;&gt;参考文档&lt;/h2&gt;
&lt;p&gt;这些文章都是我在搜索资源时,感觉能够很大程度帮助你理解一些概念，并通过简单的言语能够表达清晰,有需要的可以去查看&lt;/p&gt;
</description>
<pubDate>Fri, 05 Feb 2021 15:48:00 +0000</pubDate>
<dc:creator>是浩然呀</dc:creator>
<og:description>从单页应用(SPA)到服务器渲染(SSR) 情景回顾 在学习Vue开发一个电商网站的管理后台时,使用到了一个组件 vue-quill-editor 主要是一个快捷的一个富文本编辑器 在使用这个组件的组</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/haoranya/p/14380281.html</dc:identifier>
</item>
<item>
<title>《进击吧！Blazor！》第一章 4.数据交互 - MicrosoftReactor</title>
<link>http://www.cnblogs.com/MSReactor/p/14380219.html</link>
<guid isPermaLink="true" >http://www.cnblogs.com/MSReactor/p/14380219.html</guid>
<description>&lt;blockquote readability=&quot;6.1580135440181&quot;&gt;
&lt;p&gt;《进击吧！Blazor！》是本人与张善友老师合作的Blazor零基础入门系列视频，此系列能让一个从未接触过Blazor的程序员掌握开发Blazor应用的能力。&lt;br/&gt;视频地址：&lt;a href=&quot;https://space.bilibili.com/483888821/channel/detail?cid=151273&quot; target=&quot;_blank&quot;&gt;https://space.bilibili.com/483888821/channel/detail?cid=151273&lt;/a&gt;&lt;br/&gt;演示代码：&lt;a href=&quot;https://github.com/TimChen44/Blazor-ToDo&quot; target=&quot;_blank&quot;&gt;https://github.com/TimChen44/Blazor-ToDo&lt;/a&gt;&lt;br/&gt;本系列文章是基于《进击吧！Blazor！》直播内容编写，升级.Net5，改进问题，讲解更全面。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;7&quot;&gt;
&lt;p&gt;作者：陈超超&lt;br/&gt;Ant Design Blazor 项目贡献者，拥有十多年从业经验，长期基于.Net技术栈进行架构与开发产品的工作，现就职于正泰集团。&lt;br/&gt;邮箱：timchen@live.com&lt;br/&gt;欢迎各位读者有任何问题联系我，我们共同进步。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一次课程我们完成了ToDo应用的界面制作，这次我们要将客户端的数据写入数据库，并从数据库中读物我们需要的数据。&lt;/p&gt;

&lt;p&gt;我们先看一下从客户端到数据库的流程&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210128202235394.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;blazor&quot;&gt;Blazor&lt;/h2&gt;
&lt;p&gt;Blazor客户端就是我们上节课做的ToDo程序。&lt;/p&gt;
&lt;h2 id=&quot;httpclient&quot;&gt;HttpClient&lt;/h2&gt;
&lt;p&gt;HttpClient就是我们完成网络通讯用的组件，对于这类组件我们希望在一个应用中只构造一次，这样避免重复分配资源，因此我们在&lt;code&gt;Program.cs&lt;/code&gt;中进行注册。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class Program
{
    public static async Task Main(string[] args)
    {
        builder.Services.AddScoped(sp =&amp;gt; new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;BaseAddress&lt;/code&gt;为基地址，这样我们使用时，Url只需要传入相对地址即可，此处默认为当前主机的地址。&lt;br/&gt;&lt;code&gt;DefaultRequestHeaders&lt;/code&gt; 默认HTTP请求头参数&lt;br/&gt;&lt;code&gt;Timeout&lt;/code&gt; 连接超时参数&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;依赖关系注入&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;上面通过服务注入的方式实现了&lt;code&gt;HttpClient&lt;/code&gt;全局共享（单例），那么如何使用服务？这里我们就需要引入一下“依赖关系注入 (DI)”的概念。&lt;/p&gt;
&lt;p&gt;DI是一种技术，基本原理是把有依赖关系的类放到容器中，解析出这些类的实例，就是依赖注入。应用可通过将内置服务注入组件来使用这些服务。 应用还可定义和注册自定义服务，并通过 DI 使其在整个应用中可用。&lt;/p&gt;
&lt;p&gt;该技术在 Blazor 应用中常用于以下两个方面：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210128213219478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;服务生存期决定了服务何时创建，何时销毁，有三种模式：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Scoped&lt;/code&gt;：&lt;code&gt;Blazor WebAssembly&lt;/code&gt; 应用当前没有 DI 范围的概念。 已注册 &lt;code&gt;Scoped&lt;/code&gt; 的服务的行为与 &lt;code&gt;Singleton&lt;/code&gt; 服务类似。 但是，Blazor Server 托管模型支持 &lt;code&gt;Scoped&lt;/code&gt; 生存期。 在 &lt;code&gt;Blazor Server&lt;/code&gt; 应用中，&lt;code&gt;Scoped&lt;/code&gt;服务注册的范围为“连接”。 因此，即使当前意图是在浏览器中运行客户端，对于范围应限定为当前用户的服务来说，首选使用 &lt;code&gt;Scoped&lt;/code&gt; 服务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Singleton&lt;/code&gt;：DI 创建服务的单个实例。 需要 &lt;code&gt;Singleton&lt;/code&gt; 服务的所有组件都会接收同一服务的实例。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Transient&lt;/code&gt;：每当组件从服务容器获取 &lt;code&gt;Transient&lt;/code&gt; 服务的实例时，它都会接收该服务的新实例。&lt;/p&gt;
&lt;p&gt;这里的 &lt;code&gt;HttpClient&lt;/code&gt; 使用了 &lt;code&gt;AddScoped&lt;/code&gt; 方法，那么就是当前范围内使用同一个实例，因为项目是&lt;code&gt;Blazor WebAssembly&lt;/code&gt;模式，所以相当于单例服务。&lt;/p&gt;
&lt;h2 id=&quot;aspnet-core&quot;&gt;ASP.Net Core&lt;/h2&gt;
&lt;p&gt;我用ASP.Net Core项目给Blazor应用提供WebAPI接口&lt;/p&gt;
&lt;blockquote readability=&quot;1.271186440678&quot;&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/aspnet/core&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/aspnet/core&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;项目结构如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210128210132892.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;launchSettings.json&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;这里配置了我们调试的方式，端口等，相对于普通的Web项目多了&lt;code&gt;inspectUri&lt;/code&gt;属性，具有以下作用：&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;使 IDE 能够检测到该应用为 Blazor WebAssembly 应用。&lt;/li&gt;
&lt;li&gt;指示脚本调试基础结构通过 Blazor 的调试代理连接到浏览器。&lt;/li&gt;
&lt;li&gt;已启动的浏览器 (browserInspectUri) 上 WebSocket 协议 (wsProtocol)、主机 (url.hostname)、端口 (url.port) 和检查器 URI 的占位符值由框架提供。&lt;/li&gt;
&lt;/ol&gt;&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;{
//省略其他配置
    &quot;profiles&quot;: {
      &quot;IIS Express&quot;: {
        &quot;commandName&quot;: &quot;IISExpress&quot;,
        &quot;launchBrowser&quot;: true,
        &quot;inspectUri&quot;: &quot;{wsProtocol}://{url.hostname}:{url.port}/_framework/debug/ws-proxy?browser={browserInspectUri}&quot;,
        &quot;environmentVariables&quot;: {
          &quot;ASPNETCORE_ENVIRONMENT&quot;: &quot;Development&quot;
        }
      },
//省略其他配置
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Controllers&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;控制器（&lt;code&gt;Controller&lt;/code&gt;）放在这里，站点的路由表是通过遍历项目中带有&lt;code&gt;ApiControllerAttribute&lt;/code&gt;（基类&lt;code&gt;ControllerAttribute&lt;/code&gt;）的类，然后寻找里面的方法实现，他和Blazor的路由表创建方法上有点相似。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    [ApiController]
    [Route(&quot;api/[controller]/[action]&quot;)]
    public class TaskController : ControllerBase
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Route&lt;/code&gt;定义了路由格式，上例中&lt;code&gt;[controller]/[action]&lt;/code&gt;意为使用&lt;code&gt;Controller&lt;/code&gt;和&lt;code&gt;action&lt;/code&gt;的名称作为路由地址，这样写可以省去每个&lt;code&gt;action&lt;/code&gt;上标记路由名字的麻烦。&lt;/p&gt;
&lt;p&gt;存放页面文件的位置，因为我们的项目页面全部使用Blazor构建，所以用不到此文件夹，因此这里就不做介绍了。&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;appsettings.json&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;站点的配置文件，我们的项目就用到了数据库链接字符串配置&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Program.cs&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;应用的&lt;code&gt;Main&lt;/code&gt;函数在这里，这里完成了&lt;code&gt;Host&lt;/code&gt;的创建与启动&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;strong&gt;Startup.cs&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;启动类，项目启动时的服务注册，配置等工作都在此处完成&lt;br/&gt;&lt;code&gt;ConfigureServices&lt;/code&gt;使用此方法将服务添加到容器。&lt;br/&gt;&lt;code&gt;Configure&lt;/code&gt;使用此方法来配置HTTP请求管道。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
//省略其他代码
    app.UseBlazorFrameworkFiles();
    app.UseStaticFiles();
    app.UseRouting();
    app.UseEndpoints(endpoints =&amp;gt;
    {
        endpoints.MapRazorPages();
        endpoints.MapControllers();
        endpoints.MapFallbackToFile(&quot;index.html&quot;);
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;app.UseBlazorFrameworkFiles();&lt;/code&gt;配置应用程序提供Blazor WebAssembly框架文件，默认根路径为&lt;code&gt;/&lt;/code&gt;，也可以自定义路径前缀&lt;br/&gt;&lt;code&gt;endpoints.MapControllers();&lt;/code&gt;添加控制器（&lt;code&gt;Controller&lt;/code&gt;）的路由。&lt;br/&gt;&lt;code&gt;endpoints.MapFallbackToFile(&quot;index.html&quot;);&lt;/code&gt;添加默认路由地址是&lt;code&gt;index.html&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;ef-code&quot;&gt;EF Code&lt;/h2&gt;
&lt;p&gt;所有的数据我们需要保存入数据库，这里我选择使用EF Core作为我们的数据访问技术&lt;/p&gt;
&lt;blockquote readability=&quot;1.4705882352941&quot;&gt;
&lt;p&gt;官方文档：&lt;a href=&quot;https://docs.microsoft.com/zh-cn/ef/&quot; target=&quot;_blank&quot;&gt;https://docs.microsoft.com/zh-cn/ef/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;EF Core部分特点&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;Entity Framework (EF) Core 是轻量化、可扩展、开源和跨平台版的数据访问技术。&lt;/li&gt;
&lt;li&gt;EF Core可用作对象关系映射程序 (O/RM)，能让我们用对象来处理数据库，使用Linq进行查询，这样我们就可以不用编写大量SQL代码了。&lt;/li&gt;
&lt;li&gt;EF Core 支持多个数据库引擎，比如MySQL、SQLite等。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210202154002226.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;他支持采用Code Firs或者Database First两种模式&lt;/p&gt;
&lt;ul&gt;&lt;li&gt;&lt;code&gt;Code Firs&lt;/code&gt;用代码编写对象关系，然后通过它创建数据库。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Database First&lt;/code&gt;可以提供现有数据库，反向生成对象映射 。&lt;/li&gt;
&lt;/ul&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210202154252725.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70#pic_center&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h2 id=&quot;database&quot;&gt;Database&lt;/h2&gt;
&lt;p&gt;数据库我选择SQL Server，使用全套微软技术栈工具链使用体验比较好，当然我们也可以选择其他数据库。&lt;/p&gt;
&lt;p&gt;SQL Server产品家族中有一个SQL Server LocalDB的东西，它是SQL Server的一个超级精简版本，安装包只有几十MB（安装好后200+MB），它包含了数据库的基础功能，但是不支持联网，只能本机连接，对于个人开发资源占用少，强烈推荐，VS安装Web开发组件会默认安装此数据库。&lt;/p&gt;
&lt;p&gt;连接时服务器名称默认是&lt;code&gt;(localdb)\MSSQLLocalDB&lt;/code&gt;，也可以使用&lt;code&gt;C:\Program Files\Microsoft SQL Server\130\Tools\Binn\SqlLocalDB.exe&lt;/code&gt;进行配置数据库实例&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210202202639720.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用VS的SQL Server对象资源管理器来查看我们的数据库，不过我这里强烈推荐使用SQL Server Management Studio (SSMS) 的“数据库关系图”功能来维护数据库，可视化编辑表，主外键关系等，保存即更新数据库，这对于数据库优先的模式下开发非常友好，效率极高。&lt;/p&gt;
&lt;p&gt;下图是我们ToDo应用使用的表结构。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210202204619325.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;

&lt;p&gt;上面介绍了数据交互的流程概念，接下来我们改造上回制作的ToDo项目。&lt;/p&gt;
&lt;h2 id=&quot;引入和配置ef-code&quot;&gt;引入和配置EF Code&lt;/h2&gt;
&lt;p&gt;我们先创建一个&lt;code&gt;ToDo.Entity&lt;/code&gt;项目用于存储ORM映射以及EF的Context。&lt;/p&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;注意：目前VS 16.8.4版本创建类库会默认使用.net core 3.1，需要手动修改成.net 5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;使用ef-core-power-tools工具创建代码&quot;&gt;使用EF Core Power Tools工具创建代码&lt;/h3&gt;
&lt;p&gt;因为我们上面已经把数据库设计完成了，所以我们采用&lt;code&gt;Database First&lt;/code&gt;模式创建EF相关的代码。&lt;/p&gt;
&lt;p&gt;此处推荐一个从数据库到EF实体的代码生成扩展&lt;code&gt;EF Core Power Tools&lt;/code&gt;&lt;/p&gt;
&lt;blockquote readability=&quot;1.09375&quot;&gt;
&lt;p&gt;扩展下载地址：&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=ErikEJ.EFCorePowerTools&quot; target=&quot;_blank&quot;&gt;https://marketplace.visualstudio.com/items?itemName=ErikEJ.EFCorePowerTools&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210202210615393.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择要连接的数据库。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2021020221082758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;选择要添加的数据库对象。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210202210952804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;配置&lt;code&gt;Context&lt;/code&gt;的名称和命名空间等，下图是我常用配置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210202212149486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;EF Core Power Tools&lt;/code&gt;生成的代码文件如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210202212257557.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;h3 id=&quot;appsettingsjson中添加链接字符串&quot;&gt;appsettings.json中添加链接字符串&lt;/h3&gt;
&lt;p&gt;打开&lt;code&gt;ToDo.Server\appsettings.json&lt;/code&gt;添加数据库连接字符串&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-json&quot;&gt;  &quot;ConnectionStrings&quot;: {
    &quot;DefaultConnection&quot;: &quot;Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=ToDo;Integrated Security=True&quot;
  },
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;6&quot;&gt;
&lt;p&gt;使用&lt;code&gt;EF Core Power Tools&lt;/code&gt;生成的&lt;code&gt;TodoContext.cs&lt;/code&gt;文件中就有默认的连接字符串，开发时想偷懒可以直接从这里复制😁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;configureservices中添加服务注册&quot;&gt;ConfigureServices中添加服务注册&lt;/h3&gt;
&lt;p&gt;打开&lt;code&gt;ToDo.Server\Startup.cs&lt;/code&gt;，把&lt;code&gt;TodoContext&lt;/code&gt;注册到&lt;code&gt;DbContext&lt;/code&gt;中为，并设置连接字符串&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;services.AddDbContext&amp;lt;TodoContext&amp;gt;(options =&amp;gt;
{
    options.UseSqlServer(Configuration.GetConnectionString(&quot;DefaultConnection&quot;));
});
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;有时候我们需要在输出EF执行的SQL语句，这便于我们调试以及优化数据库，下面的配置就把EF日志输出到控制台&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;/// &amp;lt;summary&amp;gt;
/// 输出日志
/// &amp;lt;/summary&amp;gt;
public static readonly ILoggerFactory loggerFactory = LoggerFactory.Create(builder =&amp;gt; { builder.AddConsole(); });

public void ConfigureServices(IServiceCollection services)
{
//省略其他代码
    services.AddDbContext&amp;lt;TodoContext&amp;gt;(options =&amp;gt;
    {
        options.UseSqlServer(Configuration.GetConnectionString(&quot;DefaultConnection&quot;)).UseLoggerFactory(loggerFactory);
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id=&quot;功能实现&quot;&gt;功能实现&lt;/h2&gt;
&lt;p&gt;首先创建&lt;code&gt;ToDo.Server\Controllers\TaskController.cs&lt;/code&gt;文件用于编写WebAPI接口，代码如下：&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;namespace ToDo.Server.Controllers
{
    [ApiController]
    [Route(&quot;api/[controller]/[action]&quot;)]
    public class TaskController : ControllerBase
    {
        TodoContext Context;

        public TaskController(TodoContext context)
        {
            Context = context;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过依赖注入将&lt;code&gt;TodoContext&lt;/code&gt;注入到当前类中。&lt;/p&gt;
&lt;h3 id=&quot;1-列出当天的所有代办工作&quot;&gt;1. 列出当天的所有代办工作&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Server&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TaskController.cs&lt;/code&gt;中添加&lt;code&gt;GetToDayTask&lt;/code&gt;方法用于返回当前待办数据。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[HttpGet]
public List&amp;lt;TaskDto&amp;gt; GetToDayTask()
{
    var result = Context.Task.Where(x =&amp;gt; x.PlanTime == DateTime.Now.Date);
    return QueryToDto(result).ToList();
}

[NonAction]
private IQueryable&amp;lt;TaskDto&amp;gt; QueryToDto(IQueryable&amp;lt;Entity.Task&amp;gt; query)
{
    return query.Select(x =&amp;gt; new TaskDto()
    {
        TaskId = x.TaskId,
        Title = x.Title,
        Description = x.Description,
        PlanTime = x.PlanTime,
        Deadline = x.Deadline,
        IsImportant = x.IsImportant,
        IsFinish = x.IsFinish,
    });
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Client&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;添加&lt;code&gt;Pages\ToDay.razor.cs&lt;/code&gt;类文件，VS会自动将&lt;code&gt;ToDay.razor&lt;/code&gt;与&lt;code&gt;ToDay.razor.cs&lt;/code&gt;折叠到一起。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210202215123994.png&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;p&gt;在类定义中增加&lt;code&gt;partial&lt;/code&gt;关键字，声明类为局部类，你可以理解成&lt;code&gt;ToDay.razor&lt;/code&gt;与&lt;code&gt;ToDay.razor.cs&lt;/code&gt;中的代码都属于同一个类，只是放在不同文件中，编译器编译时会将他们合并到一起后进行编译。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;    public partial class ToDay
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;接着做一下代码迁移&lt;/p&gt;
&lt;ol&gt;&lt;li&gt;将&lt;code&gt;Pages\ToDay.razor&lt;/code&gt;文件&lt;code&gt;@code{}&lt;/code&gt;中的代码剪切到&lt;code&gt;ToDay.razor.cs&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将&lt;code&gt;Pages\ToDay.razor&lt;/code&gt;文件&lt;code&gt;@inject&lt;/code&gt;代码采用&lt;code&gt;[Inject] public MessageService MsgSrv { get; set; }&lt;/code&gt;这样的格式等价的迁移到&lt;code&gt;ToDay.razor.cs&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;&lt;p&gt;这样做我们可以实现界面代码与业务代码分开在不同的文件中，方便整理代码，提高代码可读性。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;后续其他页面我默认完成了创建局部类的操作，不再赘述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;ToDay.razor.cs&lt;/code&gt;中添加&lt;code&gt;HttpClient&lt;/code&gt;的依赖注入，用于向服务端发起Http请求&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[Inject] public HttpClient Http { get; set; }
&lt;/code&gt;
&lt;/pre&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;项目中其他类如果使用到&lt;code&gt;HttpClient&lt;/code&gt;，我默认完成了依赖注入，不再赘述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote readability=&quot;5.003355704698&quot;&gt;
&lt;p&gt;🎈广告时间🎈&lt;br/&gt;&lt;code&gt;Blazor&lt;/code&gt;和&lt;code&gt;Ant Design Blazor&lt;/code&gt;中有很多服务，我们经常在不同的地方需要注入，为了编码方便，我们提供了一个VS扩展快速插入常用服务代码段，安装地址：&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=TimChen44.AntDesignBlazorSnippets&quot; target=&quot;_blank&quot;&gt;https://marketplace.visualstudio.com/items?itemName=TimChen44.AntDesignBlazorSnippets&lt;/a&gt;&lt;br/&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/20210203110302128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1RpbUNoZW40NA==,size_16,color_FFFFFF,t_70&quot; alt=&quot;在这里插入图片描述&quot; loading=&quot;lazy&quot;/&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;修改&lt;code&gt;OnInitializedAsync&lt;/code&gt;方法的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;private List&amp;lt;TaskDto&amp;gt; taskDtos = new List&amp;lt;TaskDto&amp;gt;();
bool isLoading = true;
protected async override Task OnInitializedAsync()
{
    isLoading = true;
    taskDtos = await Http.GetFromJsonAsync&amp;lt;List&amp;lt;TaskDto&amp;gt;&amp;gt;(&quot;api/Task/GetToDayTask&quot;);
    isLoading = false;
    await base.OnInitializedAsync();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Http.GetFromJsonAsync&amp;lt;List&amp;lt;TaskDto&amp;gt;&amp;gt;&lt;/code&gt;使用&lt;code&gt;HttpGet&lt;/code&gt;模式请求数据，这里使用&lt;code&gt;await&lt;/code&gt;进行异步等待，充分利用&lt;code&gt;await&lt;/code&gt;可以极大的简化代码量。&lt;br/&gt;&lt;code&gt;isLoading&lt;/code&gt;是载入状态，网络通讯必定有延迟，避免白屏，我们在载入前后分别改变载入状态，同时修改&lt;code&gt;ToDay.razor&lt;/code&gt;代码添加&lt;code&gt;Spin&lt;/code&gt;组件用于显示载入效果。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;PageHeader Title=&quot;@(&quot;我的一天&quot;)&quot; Subtitle=&quot;@DateTime.Now.ToString(&quot;yyyy年MM月dd日&quot;)&quot;&amp;gt;&amp;lt;/PageHeader&amp;gt;
&amp;lt;Spin Spinning=&quot;isLoading&quot;&amp;gt;&amp;lt;!--插入代码--&amp;gt;
    @foreach (var item in taskDtos)
&amp;lt;!--省略其他代码--&amp;gt;
        &amp;lt;Input @bind-Value=&quot;@newTask.Title&quot; OnkeyUp=&quot;OnInsert&quot; /&amp;gt;
    &amp;lt;/div&amp;gt;
&amp;lt;/Spin&amp;gt;&amp;lt;!--插入代码--&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;2-添加代办&quot;&gt;2. 添加代办&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Server&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;TaskController.cs&lt;/code&gt;中添加&lt;code&gt;SaveTask&lt;/code&gt;方法用于保存新的待办内容&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[HttpPost]
public Guid SaveTask(TaskDto dto)
{
    Entity.Task entity;
    if (dto.TaskId == Guid.Empty)
    {
        entity = new Entity.Task();
        entity.TaskId = Guid.NewGuid();
        Context.Add(entity);
    }
    else
    {
        entity = Context.Task.FirstOrDefault(x =&amp;gt; x.TaskId == dto.TaskId);
    }
    entity.Title = dto.Title;
    entity.Description = dto.Description;
    entity.PlanTime = dto.PlanTime;
    entity.Deadline = dto.Deadline;
    entity.IsImportant = dto.IsImportant;
    entity.IsFinish = dto.IsFinish;
    Context.SaveChanges();
    return entity.TaskId;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;我通过判断&lt;code&gt;dto.TaskId&lt;/code&gt;的值，直接将新增与更新写在一个接口中，这样可以复用代码。&lt;/p&gt;
&lt;blockquote readability=&quot;5&quot;&gt;
&lt;p&gt;此处可以使用&lt;code&gt;AutoMapper&lt;/code&gt;库来简化赋值过程，这将在将来的章节中详细介绍&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Client&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;ToDay.razor.cs&lt;/code&gt;文件修改&lt;code&gt;OnInsert&lt;/code&gt;方法相关的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;TaskDto newTask = new TaskDto() { PlanTime = DateTime.Now.Date };
[Inject] public MessageService MsgSrv { get; set; }
bool isNewLoading = false;
async void OnInsert(KeyboardEventArgs e)
{
    if (e.Code == &quot;Enter&quot;)
    {
        if (string.IsNullOrWhiteSpace(newTask.Title))
        {
            MsgSrv.Error($&quot;标题必须填写&quot;);
            return;
        }
        isNewLoading = true;
        var result = await Http.PostAsJsonAsync&amp;lt;TaskDto&amp;gt;($&quot;api/Task/SaveTask&quot;, newTask);
        if (result.IsSuccessStatusCode)
        {
            newTask.TaskId = await result.Content.ReadFromJsonAsync&amp;lt;Guid&amp;gt;();
            taskDtos.Add(newTask);
            newTask = new TaskDto() { PlanTime = DateTime.Now.Date };
        }
        else
        {
            MsgSrv.Error($&quot;请求发生错误 {result.StatusCode}&quot;);
        }
        isNewLoading = false;
        StateHasChanged();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ToDay.razor&lt;/code&gt;文件增加保存时等待组件&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;    &amp;lt;Spin Spinning=&quot;isNewLoading&quot;&amp;gt;&amp;lt;!--插入代码--&amp;gt;
        &amp;lt;div class=&quot;task-input&quot;&amp;gt;
            &amp;lt;DatePicker Picker=&quot;@DatePickerType.Date&quot; @bind-Value=&quot;@newTask.PlanTime&quot; /&amp;gt;
            &amp;lt;Input @bind-Value=&quot;@newTask.Title&quot; OnkeyUp=&quot;OnInsert&quot; /&amp;gt;
        &amp;lt;/div&amp;gt;
    &amp;lt;/Spin&amp;gt;&amp;lt;!--插入代码--&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;通过&lt;code&gt;Http.PostAsJsonAsync&lt;/code&gt;调用&lt;code&gt;api/Task/SaveTask&lt;/code&gt;将&lt;code&gt;newTask&lt;/code&gt;内容提交到后端并保存，返回的&lt;code&gt;HttpResponseMessage&lt;/code&gt;包含了状态编码等，如果成功就在界面上显示新的待办，失败就提示错误&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MessageService&lt;/code&gt;全局展示操作反馈信息。&lt;/p&gt;
&lt;blockquote readability=&quot;1.2962962962963&quot;&gt;
&lt;p&gt;组件文档地址：&lt;a href=&quot;https://ant-design-blazor.github.io/zh-CN/components/message&quot; target=&quot;_blank&quot;&gt;https://ant-design-blazor.github.io/zh-CN/components/message&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;3-编辑待办&quot;&gt;3. 编辑待办&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Server&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;TaskController.cs&lt;/code&gt;中添加&lt;code&gt;GetTaskDto&lt;/code&gt;方法用于获取待办信息&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public TaskDto GetTaskDto(Guid taskId)
{
    var result = Context.Task.Where(x =&amp;gt; x.TaskId == taskId);
    return QueryToDto(result).FirstOrDefault();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Client&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;TaskInfo.razor&lt;/code&gt;文件中增加&lt;code&gt;Spin&lt;/code&gt;与&lt;code&gt;@if&lt;/code&gt;代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;&amp;lt;Spin Spinning=&quot;isLoading&quot;&amp;gt;
    @if (taskDto != null)&amp;lt;!--页面打开时taskDto并没有值，所以直接绑定到Form会发生异常，所以这里需要做一个不为空判断--&amp;gt;
    {
        &amp;lt;Form OnFinish=&quot;OnSave&quot; Model=&quot;taskDto&quot; LabelColSpan=&quot;8&quot;&amp;gt;&amp;lt;!--当用户点击submit按钮时会触发OnFinish事件，所以通常会在这里进行保存操作--&amp;gt;
&amp;lt;!--省略其他代码--&amp;gt;
            &amp;lt;div&amp;gt;
                &amp;lt;Button HtmlType=&quot;submit&quot;&amp;gt;保存&amp;lt;/Button&amp;gt;
                &amp;lt;Button OnClick=&quot;OnCancel&quot;&amp;gt;取消&amp;lt;/Button&amp;gt;
            &amp;lt;/div&amp;gt;
        &amp;lt;/Form&amp;gt;
    }
&amp;lt;/Spin&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TaskInfo.razor.cs&lt;/code&gt;添加下面代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public partial class TaskInfo : DrawerTemplate&amp;lt;TaskDto, TaskDto&amp;gt;
{
    [Inject]
    public HttpClient Http { get; set; }

    [Inject]
    public MessageService MsgSvr { get; set; }

    TaskDto taskDto;

    bool isLoading = false;

    protected override async Task OnInitializedAsync()
    {
        //通过api/Task/GetTaskDto接口获得待办内容
        taskDto = await Http.GetFromJsonAsync&amp;lt;TaskDto&amp;gt;($&quot;api/Task/GetTaskDto?taskId={base.Options.TaskId}&quot;);
        await base.OnInitializedAsync();
    }

    async void OnSave()
    {
        var result = await Http.PostAsJsonAsync&amp;lt;TaskDto&amp;gt;($&quot;api/Task/SaveTask&quot;, taskDto);
        if (result.StatusCode == System.Net.HttpStatusCode.OK)
        {
            await base.CloseAsync(taskDto);//关闭抽屉，并返回当前待办数据
        }
        else
        {
            MsgSvr.Error($&quot;请求发生错误 {result.StatusCode}&quot;);
        }
    }

    async void OnCancel()
    {
        await base.CloseAsync(null);//如果点击了取消，那么将null返回出去
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ToDay.razor.cs&lt;/code&gt;中的&lt;code&gt;OnCardClick&lt;/code&gt;方法更新&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[Inject] public DrawerService DrawerSrv { get; set; }
async void OnCardClick(TaskDto task)
{
    var result = await DrawerSrv.CreateDialogAsync&amp;lt;TaskInfo, TaskDto, TaskDto&amp;gt;(task, title: task.Title, width: 450);
    if (result == null) return;
    var index = taskDtos.FindIndex(x =&amp;gt; x.TaskId == result.TaskId);
    taskDtos[index] = result;
    await InvokeAsync(StateHasChanged);
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;DrawerSrv.CreateDialogAsync&lt;/code&gt;相对于&lt;code&gt;DrawerSrv.CreateAsync&lt;/code&gt;简化了调用方法，默认将抽屉的&lt;code&gt;CloseAsync&lt;/code&gt;参数返回，这就简化了每次使用抽屉时需要注册&lt;code&gt;CloseAsync&lt;/code&gt;事件的麻烦，也让代码更加清晰。&lt;br/&gt;&lt;code&gt;title: task.Title, width: 450&lt;/code&gt;使用可选参数简化对抽屉的参数配置。&lt;/p&gt;
&lt;blockquote readability=&quot;1.8279569892473&quot;&gt;
&lt;p&gt;DrawerService组件帮助文档：&lt;a href=&quot;https://ant-design-blazor.github.io/zh-CN/components/drawer&quot; target=&quot;_blank&quot;&gt;https://ant-design-blazor.github.io/zh-CN/components/drawer&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;4-修改重要程度&quot;&gt;4. 修改重要程度&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Server&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;TaskController.cs&lt;/code&gt;中添加&lt;code&gt;SetImportant&lt;/code&gt;方法用于修改&lt;code&gt;IsImportant&lt;/code&gt;字段的值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[HttpPost]
public void SetImportant(SetImportantReq req)
{
    var entity = Context.Task.FirstOrDefault(x =&amp;gt; x.TaskId == req.TaskId);
    entity.IsImportant = req.IsImportant;
    Context.SaveChanges();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Shared&lt;/strong&gt;&lt;br/&gt;添加&lt;code&gt;SetImportantReq&lt;/code&gt;类用于&lt;code&gt;SetImportant&lt;/code&gt;接口请求参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class SetImportantReq
{
    public Guid TaskId { get; set; }
    public bool IsImportant { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Client&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;ToDay.razor.cs&lt;/code&gt;中的&lt;code&gt;OnStar&lt;/code&gt;方法更新&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;private async void OnStar(TaskDto task)
{
    var req = new SetImportantReq()//ToDo.Shared项目中的类可以前后端公用，这就是Blazor优势之一。
    {
        TaskId = task.TaskId,
        IsImportant = !task.IsImportant,
    };

    var result = await Http.PostAsJsonAsync&amp;lt;SetImportantReq&amp;gt;(&quot;api/Task/SetImportant&quot;, req);
    if (result.IsSuccessStatusCode)
    {
        task.IsImportant = req.IsImportant;//请求成功后需要修改本地重要状态
        StateHasChanged();//状态改变，刷新页面的显示
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;5-修改完成状态&quot;&gt;5. 修改完成状态&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Server&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;TaskController.cs&lt;/code&gt;中添加&lt;code&gt;SetFinish&lt;/code&gt;方法用于修改&lt;code&gt;IsFinish&lt;/code&gt;字段的值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[HttpPost]
public void SetFinish(SetFinishReq req)
{
    var entity = Context.Task.FirstOrDefault(x =&amp;gt; x.TaskId == req.TaskId);
    entity.IsFinish = req.IsFinish;
    Context.SaveChanges();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Shared&lt;/strong&gt;&lt;br/&gt;添加&lt;code&gt;SetFinishReq&lt;/code&gt;类用于&lt;code&gt;SetFinish&lt;/code&gt;接口请求参数&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class SetFinishReq
{
    public Guid TaskId { get; set; }

    public bool IsFinish { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Client&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;ToDay.razor.cs&lt;/code&gt;中的&lt;code&gt;OnFinish&lt;/code&gt;方法更新&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;private async void OnFinish(TaskDto task)
{
    var req = new SetFinishReq()
    {
        TaskId = task.TaskId,
        IsFinish = !task.IsFinish,
    };

    var result = await Http.PostAsJsonAsync&amp;lt;SetFinishReq&amp;gt;(&quot;api/Task/SetFinish&quot;, req);
    if (result.IsSuccessStatusCode)
    {
        task.IsFinish = req.IsFinish;
        StateHasChanged();
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h3 id=&quot;6-删除代办&quot;&gt;6. 删除代办&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Server&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;TaskController.cs&lt;/code&gt;中添加&lt;code&gt;DelTask&lt;/code&gt;方法用于删除待办。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[HttpDelete]
public void DelTask(Guid taskId)
{
    Context.Task.Remove(Context.Task.Find(taskId));
    Context.SaveChanges();
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Client&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;ToDay.razor.cs&lt;/code&gt;中的&lt;code&gt;OnFinish&lt;/code&gt;方法更新&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[Inject] public ConfirmService ConfirmSrv { get; set; }
public async Task OnDel(TaskDto task)
{
    if (await ConfirmSrv.Show($&quot;是否删除任务 {task.Title}&quot;, &quot;删除&quot;, ConfirmButtons.YesNo, ConfirmIcon.Info) == ConfirmResult.Yes)
    {
        taskDtos.Remove(task);
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;ConfirmService&lt;/code&gt;可以快捷地弹出一个内置的确认框，类似于 Windows MessageBox。&lt;/p&gt;
&lt;blockquote readability=&quot;1.8817204301075&quot;&gt;
&lt;p&gt;ConfirmService组件帮助文档：&lt;a href=&quot;https://ant-design-blazor.github.io/zh-CN/components/modal&quot; target=&quot;_blank&quot;&gt;https://ant-design-blazor.github.io/zh-CN/components/modal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;7-查询代办&quot;&gt;7. 查询代办&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Server&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;TaskController.cs&lt;/code&gt;中添加&lt;code&gt;GetSearch&lt;/code&gt;方法用于修改&lt;code&gt;SetFinish&lt;/code&gt;字段的值&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[HttpPost]
public GetSearchRsp GetSearch(GetSearchReq req)
{
    if (req.PageIndex == 0) req.PageIndex = 1;
    var query = Context.Task.Where(x =&amp;gt; x.Title.Contains(req.QueryTitle ?? &quot;&quot;));

    foreach (var sort in req.Sorts)
    {
        if (sort.SortOrder == &quot;descend&quot;)
            query = query.OrderBy(sort.SortField + &quot; DESC&quot;);
        else
            query = query.OrderBy(sort.SortField);
    }

    var result = new GetSearchRsp()
    {
        Data = QueryToDto(query.Skip(--req.PageIndex * req.PageSize).Take(req.PageSize)).ToList(),
        Total = query.Count(),
    };

    return result;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;if (req.PageIndex == 0) req.PageIndex = 1&lt;/code&gt; &lt;em&gt;😣吐槽开始：几乎所有的UI框架页码都是从0开始，但是AntDesign规范的页码是从1开始的，然而没有载入数据时又是返回0😵，所以要特别注意。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OrderBy&lt;/code&gt;使用了&lt;code&gt;System.Linq.Dynamic.Core&lt;/code&gt; 扩展包，它提供了一些动态的Linq支持，比如此处排序我传入的参数不是一个表达式，而是一个字符串，这样可以让代码灵活性大增。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Shared&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;public class GetSearchReq
{
    public string QueryTitle { get; set; }
    public int PageIndex { get; set; }
    public int PageSize { get; set; }
    public List&amp;lt;SortFieldName&amp;gt; Sorts { get; set; }
}

public class SortFieldName
{
    /// &amp;lt;summary&amp;gt;
    /// 排序字段
    /// &amp;lt;/summary&amp;gt;
    public string SortField { get; set; }
    /// &amp;lt;summary&amp;gt;
    /// 排序方向
    /// &amp;lt;/summary&amp;gt;
    public string SortOrder { get; set; }
}
    
public class GetSearchRsp
{
    public List&amp;lt;TaskDto&amp;gt; Data { get; set; }
    public int Total { get; set; }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;ToDo.Client&lt;/strong&gt;&lt;br/&gt;&lt;code&gt;TaskSearch.razor&lt;/code&gt; 文件的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;@page &quot;/search&quot;
&amp;lt;PageHeader Title=&quot;@(&quot;全部待办事项&quot;)&quot; Subtitle=&quot;@($&quot;数量：{total}&quot;)&quot;&amp;gt;&amp;lt;/PageHeader&amp;gt;
&amp;lt;Search @bind-Value=&quot;queryTitle&quot; OnSearch=&quot;OnSearch&quot;&amp;gt;&amp;lt;/Search&amp;gt;
&amp;lt;Table Loading=&quot;@isLoading&quot; DataSource=&quot;@datas&quot; PageSize=&quot;10&quot; Total=&quot;@total&quot; OnChange=&quot;OnChange&quot; TItem=&quot;TaskDto&quot;&amp;gt;
    &amp;lt;AntDesign.Column @bind-Field=&quot;@context.Title&quot; Sortable&amp;gt;
        @context.Title
        @if (context.IsImportant)
        {
            &amp;lt;Tag Color=&quot;orange&quot;&amp;gt;重要&amp;lt;/Tag&amp;gt;
        }
    &amp;lt;/AntDesign.Column&amp;gt;
    &amp;lt;AntDesign.Column @bind-Field=&quot;@context.Description&quot; /&amp;gt;
    &amp;lt;AntDesign.Column @bind-Field=&quot;@context.PlanTime&quot; Sortable /&amp;gt;
    &amp;lt;AntDesign.Column @bind-Field=&quot;@context.Deadline&quot; /&amp;gt;
    &amp;lt;AntDesign.Column @bind-Field=&quot;@context.IsFinish&quot;&amp;gt;
        @if (context.IsFinish)
        {
            &amp;lt;Icon Type=&quot;check&quot; Theme=&quot;outline&quot; /&amp;gt;
        }
    &amp;lt;/AntDesign.Column&amp;gt;
&amp;lt;/Table&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TaskSearch.razor.cs&lt;/code&gt; 文件的代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[Inject] public HttpClient Http { get; set; }
private bool isLoading = false;
List&amp;lt;TaskDto&amp;gt; datas = new List&amp;lt;TaskDto&amp;gt;();
private string queryTitle;
private int total = 0;
//点击查询按钮时检索数据
private async Task OnSearch()
{
    await OnQuery(1, 10, new List&amp;lt;SortFieldName&amp;gt;());
}
//当前页码，排序发生改变时调用查询方法检索数据
private async Task OnChange(AntDesign.TableModels.QueryModel&amp;lt;TaskDto&amp;gt; queryModel)
{
    await OnQuery(
        queryModel.PageIndex,
        queryModel.PageSize,
        queryModel.SortModel.Where(x =&amp;gt; string.IsNullOrEmpty(x.SortType.Name) == false).OrderBy(x =&amp;gt; x.Priority)
        .Select(x =&amp;gt; new SortFieldName() { SortField = x.FieldName, SortOrder = x.SortType.Name }).ToList()
        );
}
//检索数据
private async Task OnQuery(int pageIndex, int pageSize, List&amp;lt;SortFieldName&amp;gt; sort)
{
    isLoading = true;
    var req = new GetSearchReq()
    {
        QueryTitle = queryTitle,
        PageIndex = pageIndex,
        PageSize = pageSize,
        Sorts = sort,
    };
    var httpRsp = await Http.PostAsJsonAsync&amp;lt;GetSearchReq&amp;gt;($&quot;api/Task/GetSearch&quot;, req);
    var result = await httpRsp.Content.ReadFromJsonAsync&amp;lt;GetSearchRsp&amp;gt;();
    datas = result.Data;
    total = result.Total;
    isLoading = false;
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Search&lt;/code&gt;带有查询按钮的文本框框&lt;/p&gt;
&lt;blockquote readability=&quot;1.5882352941176&quot;&gt;
&lt;p&gt;Search组件文档地址：&lt;a href=&quot;https://ant-design-blazor.github.io/zh-CN/components/input&quot; target=&quot;_blank&quot;&gt;https://ant-design-blazor.github.io/zh-CN/components/input&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;查看详细服务&quot;&gt;查看详细服务&lt;/h3&gt;
&lt;p&gt;在&lt;code&gt;我的一天&lt;/code&gt;与&lt;code&gt;全部&lt;/code&gt;页面上均存在打开待办详情的功能需求，这时我们就可以自己做一个服务将两边的功能合并到一起。&lt;br/&gt;添加&lt;code&gt;TaskDetailServices.cs&lt;/code&gt;文件，加入以下代码&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;namespace ToDo.Client
{
    public class TaskDetailServices
    {
        public DrawerService DrawerSvr { get; set; }

        public TaskDetailServices(DrawerService drawerSvr)
        {
            DrawerSvr = drawerSvr;
        }

        public async Task EditTask(TaskDto taskDto, List&amp;lt;TaskDto&amp;gt; datas)
        {
            var taskItem = await DrawerSvr.CreateDialogAsync&amp;lt;TaskInfo, TaskDto, TaskDto&amp;gt;(taskDto, title: taskDto.Title, width: 450);
            if (taskItem == null) return;
            var index = datas.FindIndex(x =&amp;gt; x.TaskId == taskItem.TaskId);
            datas[index] = taskItem;
        }
    }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TaskDetailServices(DrawerService drawerSvr)&lt;/code&gt; 只有&lt;code&gt;razor&lt;/code&gt;文件可以使用&lt;code&gt;[Inject]&lt;/code&gt;标记属性进行注入服务，普通得类需要在构造函数中定义才能注入服务。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Program.cs&lt;/code&gt;文件中注册&lt;code&gt;TaskDetailServices&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;builder.Services.AddScoped&amp;lt;TaskDetailServices&amp;gt;();
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TaskSearch.razor&lt;/code&gt;文件中添加详情按钮&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-html&quot;&gt;    &amp;lt;AntDesign.Column TData=&quot;object&quot;&amp;gt;
        &amp;lt;Button OnClick=&quot;x=&amp;gt;OnDetail(context)&quot;&amp;gt;详情&amp;lt;/Button&amp;gt;
    &amp;lt;/AntDesign.Column&amp;gt;
&lt;/code&gt;
&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;TaskSearch.razor.cs&lt;/code&gt; 插入以下代码，我们注入自定义的服务，使用服务中的方法打开编辑界面。&lt;/p&gt;
&lt;pre&gt;
&lt;code class=&quot;language-csharp&quot;&gt;[Inject] public TaskDetailServices TaskSrv { get; set; }

private async Task OnDetail(TaskDto taskDto)
{
    await TaskSrv.EditTask(taskDto, datas);
}
&lt;/code&gt;
&lt;/pre&gt;

&lt;p&gt;下一次我们要介绍Blazor的精髓，也是我个人认为Blazor框架体系中最优秀的特性——组件。我们通过几个小实例展示Blazor的组件开发方法，敬请期待&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/TimChen44/article/details/112465463&quot; target=&quot;_blank&quot;&gt;返回目录&lt;/a&gt;&lt;/p&gt;
</description>
<pubDate>Fri, 05 Feb 2021 15:23:00 +0000</pubDate>
<dc:creator>MicrosoftReactor</dc:creator>
<og:description>《进击吧！Blazor！》是本人与张善友老师合作的Blazor零基础入门系列视频，此系列能让一个从未接触过Blazor的程序员掌握开发Blazor应用的能力。 视频地址：https://space.b</og:description>
<dc:language>zh-cn</dc:language>
<dc:format>text/html</dc:format>
<dc:identifier>https://www.cnblogs.com/MSReactor/p/14380219.html</dc:identifier>
</item>
</channel>
</rss>